{"docstring": "// Try and match cChord\n", "func_signal": "C_SIZE mapKeys(C_SIZE chord, bool lookup)", "code": "{\n    lookup = lookup || repEngaged;\n#ifndef NO_DEBUG\n    if (!lookup) uprint(\"SENT!\\n\");\n#endif\n    // Single key chords\n    for (int i = 0; i < keyLen; i++) {\n        if (keyDict[i].chord == chord) {\n            if (!lookup) SEND(keyDict[i].key);\n            return chord;\n        }\n    }\n\n    // strings\n    for (int i = 0; i < stringLen; i++) {\n        struct stringEntry fromPgm;\n        memcpy_P(&fromPgm, &strDict[i], sizeof(stringEntry_t));\n        if (fromPgm.chord == chord) {\n            if (!lookup) {\n                if (get_mods() & (MOD_LSFT | MOD_RSFT)) {\n                    set_mods(get_mods() & ~(MOD_LSFT | MOD_RSFT));\n                    set_oneshot_mods(MOD_LSFT);\n                }\n                send_string_P((PGM_P)(fromPgm.str));\n            }\n            return chord;\n        }\n    }\n\n    // combos\n    for (int i = 0; i < comboLen; i++) {\n        struct comboEntry fromPgm;\n        memcpy_P(&fromPgm, &cmbDict[i], sizeof(comboEntry_t));\n        if (fromPgm.chord == chord) {\n#ifndef NO_DEBUG\n            uprintf(\"%d found combo\\n\", i);\n#endif\n\n            if (!lookup) {\n                uint8_t comboKeys[COMBO_MAX];\n                memcpy_P(&comboKeys, fromPgm.keys, sizeof(uint8_t) * COMBO_MAX);\n                for (int j = 0; j < COMBO_MAX; j++)\n#ifndef NO_DEBUG\n                    uprintf(\"Combo [%u]: %u\\n\", j, comboKeys[j]);\n#endif\n\n                for (int j = 0; (j < COMBO_MAX) && (comboKeys[j] != COMBO_END); j++) {\n#ifndef NO_DEBUG\n                    uprintf(\"Combo [%u]: %u\\n\", j, comboKeys[j]);\n#endif\n                    SEND(comboKeys[j]);\n                }\n            }\n            return chord;\n        }\n    }\n\n    // functions\n    for (int i = 0; i < funcsLen; i++) {\n        if (funDict[i].chord == chord) {\n            if (!lookup) funDict[i].act();\n            return chord;\n        }\n    }\n\n    // Special handling\n    for (int i = 0; i < specialLen; i++) {\n        if (spcDict[i].chord == chord) {\n            if (!lookup) {\n                uint16_t arg = spcDict[i].arg;\n                switch (spcDict[i].action) {\n                    case SPEC_STICKY:\n                        SET_STICKY(arg);\n                        break;\n                    case SPEC_REPEAT:\n                        REPEAT();\n                        break;\n                    case SPEC_CLICK:\n                        CLICK_MOUSE((uint8_t)arg);\n                        break;\n                    case SPEC_SWITCH:\n                        SWITCH_LAYER(arg);\n                        break;\n                    default:\n                        SEND_STRING(\"Invalid Special in Keymap\");\n                }\n            }\n            return chord;\n        }\n    }\n\n    if ((chord & IN_CHORD_MASK) && (chord & IN_CHORD_MASK) != chord && mapKeys((chord & IN_CHORD_MASK), true) == (chord & IN_CHORD_MASK)) {\n#ifndef NO_DEBUG\n        uprintf(\"Try with ignore mask:%u\\n\", (chord & IN_CHORD_MASK));\n#endif\n        mapKeys((chord & ~IN_CHORD_MASK), lookup);\n        mapKeys((chord & IN_CHORD_MASK), lookup);\n        return chord;\n    }\n#ifndef NO_DEBUG\n    uprintf(\"Reached end\\n\");\n#endif\n    return 0;\n}", "path": "qmk_firmware/keyboards/gboards/engine/engine.c", "commit_date": "2020-05-04 00:00:00", "repo_name": "qmk/qmk_firmware", "stars": 16782, "license": "gpl-2.0", "language": "c", "size": 296418}
{"docstring": "/**\n * @brief   USB device configured handler.\n *\n * @param[in] qmkusbp      pointer to a @p QMKUSBDriver object\n *\n * @iclass\n */\n", "func_signal": "void qmkusbConfigureHookI(QMKUSBDriver *qmkusbp)", "code": "{\n    ibqResetI(&qmkusbp->ibqueue);\n    bqResumeX(&qmkusbp->ibqueue);\n    obqResetI(&qmkusbp->obqueue);\n    bqResumeX(&qmkusbp->obqueue);\n    chnAddFlagsI(qmkusbp, CHN_CONNECTED);\n    (void)qmkusb_start_receive(qmkusbp);\n}", "path": "qmk_firmware/tmk_core/protocol/chibios/usb_driver.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "qmk/qmk_firmware", "stars": 16782, "license": "gpl-2.0", "language": "c", "size": 296418}
{"docstring": "/**\n * @brief   USB device wakeup handler.\n * @details Generates a @p CHN_CONNECT event and resumes normal queues\n *          operations.\n *\n * @note    If this function is not called from an ISR then an explicit call\n *          to @p osalOsRescheduleS() in necessary afterward.\n *\n * @param[in] qmkusbp      pointer to a @p QMKUSBDriver object\n *\n * @iclass\n */\n", "func_signal": "void qmkusbWakeupHookI(QMKUSBDriver *qmkusbp)", "code": "{\n    chnAddFlagsI(qmkusbp, CHN_CONNECTED);\n    bqResumeX(&qmkusbp->ibqueue);\n    bqResumeX(&qmkusbp->obqueue);\n}", "path": "qmk_firmware/tmk_core/protocol/chibios/usb_driver.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "qmk/qmk_firmware", "stars": 16782, "license": "gpl-2.0", "language": "c", "size": 296418}
{"docstring": "/*\n * Interface implementation.\n */\n", "func_signal": "static size_t _write(void *ip, const uint8_t *bp, size_t n)", "code": "{ return obqWriteTimeout(&((QMKUSBDriver *)ip)->obqueue, bp, n, TIME_INFINITE); }\n\nstatic size_t _read(void *ip, uint8_t *bp, size_t n) { return ibqReadTimeout(&((QMKUSBDriver *)ip)->ibqueue, bp, n, TIME_INFINITE); }\n\nstatic msg_t _put(void *ip, uint8_t b) { return obqPutTimeout(&((QMKUSBDriver *)ip)->obqueue, b, TIME_INFINITE); }\n\nstatic msg_t _get(void *ip) { return ibqGetTimeout(&((QMKUSBDriver *)ip)->ibqueue, TIME_INFINITE); }\n\nstatic msg_t _putt(void *ip, uint8_t b, sysinterval_t timeout) { return obqPutTimeout(&((QMKUSBDriver *)ip)->obqueue, b, timeout); }\n\nstatic msg_t _gett(void *ip, sysinterval_t timeout) { return ibqGetTimeout(&((QMKUSBDriver *)ip)->ibqueue, timeout); }\n\nstatic size_t _writet(void *ip, const uint8_t *bp, size_t n, sysinterval_t timeout) { return obqWriteTimeout(&((QMKUSBDriver *)ip)->obqueue, bp, n, timeout); }\n\nstatic size_t _readt(void *ip, uint8_t *bp, size_t n, sysinterval_t timeout) { return ibqReadTimeout(&((QMKUSBDriver *)ip)->ibqueue, bp, n, timeout); }\n\nstatic const struct QMKUSBDriverVMT vmt = {0, _write, _read, _put, _get, _putt, _gett, _writet, _readt};\n\n/**\n * @brief   Notification of empty buffer released into the input buffers queue.\n *\n * @param[in] bqp       the buffers queue pointer.\n */\nstatic void ibnotify(io_buffers_queue_t *bqp) {\n    QMKUSBDriver *qmkusbp = bqGetLinkX(bqp);\n    (void)qmkusb_start_receive(qmkusbp);\n}", "path": "qmk_firmware/tmk_core/protocol/chibios/usb_driver.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "qmk/qmk_firmware", "stars": 16782, "license": "gpl-2.0", "language": "c", "size": 296418}
{"docstring": "/**\n * @brief   Configures and starts the driver.\n *\n * @param[in] qmkusbp      pointer to a @p QMKUSBDriver object\n * @param[in] config    the serial over USB driver configuration\n *\n * @api\n */\n", "func_signal": "void qmkusbStart(QMKUSBDriver *qmkusbp, const QMKUSBConfig *config)", "code": "{\n    USBDriver *usbp = config->usbp;\n\n    osalDbgCheck(qmkusbp != NULL);\n\n    osalSysLock();\n    osalDbgAssert((qmkusbp->state == QMKUSB_STOP) || (qmkusbp->state == QMKUSB_READY), \"invalid state\");\n    usbp->in_params[config->bulk_in - 1U]   = qmkusbp;\n    usbp->out_params[config->bulk_out - 1U] = qmkusbp;\n    if (config->int_in > 0U) {\n        usbp->in_params[config->int_in - 1U] = qmkusbp;\n    }\n    qmkusbp->config = config;\n    qmkusbp->state  = QMKUSB_READY;\n    osalSysUnlock();\n}", "path": "qmk_firmware/tmk_core/protocol/chibios/usb_driver.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "qmk/qmk_firmware", "stars": 16782, "license": "gpl-2.0", "language": "c", "size": 296418}
{"docstring": "// Runs constantly in the background, in a loop.\n", "func_signal": "void matrix_scan_user(void)", "code": "{\n\n    uint8_t layer = biton32(layer_state);\n\n    ergodox_right_led_1_off();\n    ergodox_right_led_2_off();\n    ergodox_right_led_3_off();\n    switch (layer) {\n      // TODO: Make this relevant to the ErgoDox EZ.\n        case 1:\n            ergodox_right_led_1_on();\n            break;\n        case 2:\n            ergodox_right_led_2_on();\n            break;\n        default:\n            // none\n            break;\n    }\n}", "path": "qmk_firmware/keyboards/hotdox/keymaps/default/keymap.c", "commit_date": "2019-08-30 00:00:00", "repo_name": "qmk/qmk_firmware", "stars": 16782, "license": "gpl-2.0", "language": "c", "size": 296418}
{"docstring": "//-------------------------------------------------\n//------- Internal routines to control serial line\n", "func_signal": "static uint8_t udi_cdc_setup_to_port(void)", "code": "{\n    uint8_t port;\n\n    /*\n    switch (udd_g_ctrlreq.req.wIndex & 0xFF) {\n#define UDI_CDC_IFACE_COMM_TO_PORT(iface, unused) \\\n    case UDI_CDC_COMM_IFACE_NUMBER_##iface: \\\n        port = iface; \\\n        break;\n    MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_IFACE_COMM_TO_PORT, ~)\n#undef UDI_CDC_IFACE_COMM_TO_PORT\n    default:\n        port = 0;\n        break;\n    }\n    */\n    port = 0;\n\n    return port;\n}", "path": "qmk_firmware/tmk_core/protocol/arm_atsam/usb/udi_cdc.c", "commit_date": "2020-04-20 00:00:00", "repo_name": "qmk/qmk_firmware", "stars": 16782, "license": "gpl-2.0", "language": "c", "size": 296418}
{"docstring": "// Traverse the chord history to a given point\n// Returns the mask to use\n", "func_signal": "void processChord(void)", "code": "{\n    // Save the clean chord state\n    C_SIZE savedChord = cChord;\n\n    // Apply Stick Bits if needed\n    if (stickyBits != 0) {\n        cChord |= stickyBits;\n        for (int i = 0; i <= chordIndex; i++) chordState[i] |= stickyBits;\n    }\n\n    // First we test if a whole chord was passsed\n    // If so we just run it handling repeat logic\n    if (mapKeys(cChord, true) == cChord) {\n        mapKeys(cChord, false);\n        // Repeat logic\n        if (repeatFlag) {\n#ifndef NO_DEBUG\n            uprintf(\"repeating?\\n\");\n#endif\n            restoreState();\n            repeatFlag = false;\n            processChord();\n        } else {\n            saveState(cChord);\n        }\n        return;\n    }\n\n    C_SIZE next = process_chord_getnext(cChord);\n    if (next && next != cChord) {\n#ifndef NO_DEBUG\n        uprintf(\"Trying next candidate: %u\\n\", next);\n#endif\n        if (mapKeys(next, true) == next) {\n            mapKeys(next, false);\n            // Repeat logic\n            if (repeatFlag) {\n#ifndef NO_DEBUG\n                uprintf(\"repeating?\\n\");\n#endif\n                restoreState();\n                repeatFlag = false;\n                processChord();\n            } else {\n                saveState(cChord);\n            }\n            return;\n        }\n    }\n\n#ifndef NO_DEBUG\n    uprintf(\"made it past the maw\\n\");\n#endif\n\n    // Iterate through chord picking out the individual\n    // and longest chords\n    C_SIZE bufChords[QWERBUF];\n    int    bufLen = 0;\n    C_SIZE mask   = 0;\n\n    // We iterate over it multiple times to catch the longest\n    // chord. Then that gets addded to the mask and re run.\n    while (savedChord != mask) {\n        C_SIZE test         = 0;\n        C_SIZE longestChord = 0;\n\n        for (int i = 0; i <= chordIndex; i++) {\n            cChord = chordState[i] & ~mask;\n            if (cChord == 0) continue;\n\n            test = mapKeys(cChord, true);\n            if (test != 0) {\n                longestChord = test;\n            }\n        }\n\n        mask |= longestChord;\n        bufChords[bufLen] = longestChord;\n        bufLen++;\n\n        // That's a loop of sorts, halt processing\n        if (bufLen >= QWERBUF) {\n#ifndef NO_DEBUG\n            uprintf(\"looped. exiting\");\n#endif\n            return;\n        }\n    }\n\n    // Now that the buffer is populated, we run it\n    for (int i = 0; i < bufLen; i++) {\n        cChord = bufChords[i];\n#ifndef NO_DEBUG\n        uprintf(\"sending: %u\\n\", cChord);\n#endif\n        mapKeys(cChord, false);\n    }\n\n    // Save state in case of repeat\n    if (!repeatFlag) {\n        saveState(savedChord);\n    }\n\n    // Restore cChord for held repeat\n    cChord = savedChord;\n    return;\n}", "path": "qmk_firmware/keyboards/gboards/engine/engine.c", "commit_date": "2020-05-04 00:00:00", "repo_name": "qmk/qmk_firmware", "stars": 16782, "license": "gpl-2.0", "language": "c", "size": 296418}
{"docstring": "/**\n * \\brief This is the code that gets called on processor reset.\n * To initialize the device, and call the main() routine.\n */\n", "func_signal": "void Reset_Handler(void)", "code": "{\n#ifdef KEYBOARD_massdrop_ctrl\n    /* WARNING: This is only for CTRL bootloader release \"v2.18Jun 22 2018 17:28:08\" for bootloader_jump support */\n    if (*MAGIC_ADDR == BOOTLOADER_MAGIC) {\n        /* At this point, the bootloader's memory is initialized properly, so undo the jump to here, then jump back */\n        *MAGIC_ADDR = 0x00000000;       /* Change value to prevent potential bootloader entrance loop */\n        __set_MSP(0x20008818);          /* MSP according to bootloader */\n        SCB->VTOR = 0x00000000;         /* Vector table back to bootloader's */\n        asm(\"bx %0\" ::\"r\"(0x00001267)); /* Jump past bootloader RCAUSE check using THUMB */\n    }\n#endif\n    uint32_t *pSrc, *pDest;\n\n    /* Initialize the relocate segment */\n    pSrc  = &_etext;\n    pDest = &_srelocate;\n\n    if (pSrc != pDest) {\n        for (; pDest < &_erelocate;) {\n            *pDest++ = *pSrc++;\n        }\n    }\n\n    /* Clear the zero segment */\n    for (pDest = &_szero; pDest < &_ezero;) {\n        *pDest++ = 0;\n    }\n\n    /* Set the vector table base address */\n    pSrc      = (uint32_t *)&_sfixed;\n    SCB->VTOR = ((uint32_t)pSrc & SCB_VTOR_TBLOFF_Msk);\n\n#if __FPU_USED\n    /* Enable FPU */\n    SCB->CPACR |= (0xFu << 20);\n    __DSB();\n    __ISB();\n#endif\n\n    /* Initialize the C library */\n    __libc_init_array();\n\n    /* Branch to main function */\n    main();\n\n    /* Infinite loop */\n    while (1)\n        ;\n}", "path": "qmk_firmware/tmk_core/protocol/arm_atsam/startup.c", "commit_date": "2019-08-30 00:00:00", "repo_name": "qmk/qmk_firmware", "stars": 16782, "license": "gpl-2.0", "language": "c", "size": 296418}
{"docstring": "/**\n * @brief   Default data received callback.\n * @details The application must use this function as callback for the OUT\n *          data endpoint.\n *\n * @param[in] usbp      pointer to the @p USBDriver object\n * @param[in] ep        OUT endpoint number\n */\n", "func_signal": "void qmkusbDataReceived(USBDriver *usbp, usbep_t ep)", "code": "{\n    QMKUSBDriver *qmkusbp = usbp->out_params[ep - 1U];\n    if (qmkusbp == NULL) {\n        return;\n    }\n\n    osalSysLockFromISR();\n\n    /* Signaling that data is available in the input queue.*/\n    chnAddFlagsI(qmkusbp, CHN_INPUT_AVAILABLE);\n\n    /* Posting the filled buffer in the queue.*/\n    ibqPostFullBufferI(&qmkusbp->ibqueue, usbGetReceiveTransactionSizeX(qmkusbp->config->usbp, qmkusbp->config->bulk_out));\n\n    /* The endpoint cannot be busy, we are in the context of the callback,\n       so a packet is in the buffer for sure. Trying to get a free buffer\n       for the next transaction.*/\n    (void)qmkusb_start_receive(qmkusbp);\n\n    osalSysUnlockFromISR();\n}", "path": "qmk_firmware/tmk_core/protocol/chibios/usb_driver.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "qmk/qmk_firmware", "stars": 16782, "license": "gpl-2.0", "language": "c", "size": 296418}
{"docstring": "/**\n * @brief   Default data received callback.\n * @details The application must use this function as callback for the IN\n *          interrupt endpoint.\n *\n * @param[in] usbp      pointer to the @p USBDriver object\n * @param[in] ep        endpoint number\n */\n", "func_signal": "void qmkusbInterruptTransmitted(USBDriver *usbp, usbep_t ep)", "code": "{\n    (void)usbp;\n    (void)ep;\n}", "path": "qmk_firmware/tmk_core/protocol/chibios/usb_driver.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "qmk/qmk_firmware", "stars": 16782, "license": "gpl-2.0", "language": "c", "size": 296418}
{"docstring": "/**\n * \\brief Default interrupt handler for unused IRQs.\n */\n", "func_signal": "void Dummy_Handler(void)", "code": "{\n    while (1) {\n    }\n}", "path": "qmk_firmware/tmk_core/protocol/arm_atsam/startup.c", "commit_date": "2019-08-30 00:00:00", "repo_name": "qmk/qmk_firmware", "stars": 16782, "license": "gpl-2.0", "language": "c", "size": 296418}
{"docstring": "/* Row pin configuration\n * row: 0    1    2    3    4    5\n * pin: PB7  PD0  PD1  PD2  PD3  PD5\n *\n * Reset Key uses its own pin PE2\n */\n", "func_signal": "static void init_rows(void)", "code": "{\n    DDRD  &= ~0b00101111;\n    PORTD &= ~0b00101111;\n\n    DDRB  &= ~0b10000000;\n    PORTB &= ~0b10000000;\n\n    DDRE  &= ~0b00000100;\n    PORTE |=  0b00000100;\n}", "path": "qmk_firmware/keyboards/duck/tcv3/matrix.c", "commit_date": "2020-12-06 00:00:00", "repo_name": "qmk/qmk_firmware", "stars": 16782, "license": "gpl-2.0", "language": "c", "size": 296418}
{"docstring": "/**\n * @brief   Stops the driver.\n * @details Any thread waiting on the driver's queues will be awakened with\n *          the message @p MSG_RESET.\n *\n * @param[in] qmkusbp      pointer to a @p QMKUSBDriver object\n *\n * @api\n */\n", "func_signal": "void qmkusbStop(QMKUSBDriver *qmkusbp)", "code": "{\n    USBDriver *usbp = qmkusbp->config->usbp;\n\n    osalDbgCheck(qmkusbp != NULL);\n\n    osalSysLock();\n\n    osalDbgAssert((qmkusbp->state == QMKUSB_STOP) || (qmkusbp->state == QMKUSB_READY), \"invalid state\");\n\n    /* Driver in stopped state.*/\n    usbp->in_params[qmkusbp->config->bulk_in - 1U]   = NULL;\n    usbp->out_params[qmkusbp->config->bulk_out - 1U] = NULL;\n    if (qmkusbp->config->int_in > 0U) {\n        usbp->in_params[qmkusbp->config->int_in - 1U] = NULL;\n    }\n    qmkusbp->config = NULL;\n    qmkusbp->state  = QMKUSB_STOP;\n\n    /* Enforces a disconnection.*/\n    chnAddFlagsI(qmkusbp, CHN_DISCONNECTED);\n    ibqResetI(&qmkusbp->ibqueue);\n    obqResetI(&qmkusbp->obqueue);\n    osalOsRescheduleS();\n\n    osalSysUnlock();\n}", "path": "qmk_firmware/tmk_core/protocol/chibios/usb_driver.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "qmk/qmk_firmware", "stars": 16782, "license": "gpl-2.0", "language": "c", "size": 296418}
{"docstring": "/**\n * @brief   SOF handler.\n * @details The SOF interrupt is used for automatic flushing of incomplete\n *          buffers pending in the output queue.\n *\n * @param[in] qmkusbp      pointer to a @p QMKUSBDriver object\n *\n * @iclass\n */\n", "func_signal": "void qmkusbSOFHookI(QMKUSBDriver *qmkusbp)", "code": "{\n    /* If the USB driver is not in the appropriate state then transactions\n       must not be started.*/\n    if ((usbGetDriverStateI(qmkusbp->config->usbp) != USB_ACTIVE) || (qmkusbp->state != QMKUSB_READY)) {\n        return;\n    }\n\n    /* If there is already a transaction ongoing then another one cannot be\n       started.*/\n    if (usbGetTransmitStatusI(qmkusbp->config->usbp, qmkusbp->config->bulk_in)) {\n        return;\n    }\n\n    /* Checking if there only a buffer partially filled, if so then it is\n       enforced in the queue and transmitted.*/\n    if (obqTryFlushI(&qmkusbp->obqueue)) {\n        size_t   n;\n        uint8_t *buf = obqGetFullBufferI(&qmkusbp->obqueue, &n);\n\n        /* For fixed size drivers, fill the end with zeros */\n        if (qmkusbp->config->fixed_size) {\n            memset(buf + n, 0, qmkusbp->config->in_size - n);\n            n = qmkusbp->config->in_size;\n        }\n\n        osalDbgAssert(buf != NULL, \"queue is empty\");\n\n        usbStartTransmitI(qmkusbp->config->usbp, qmkusbp->config->bulk_in, buf, n);\n    }\n}", "path": "qmk_firmware/tmk_core/protocol/chibios/usb_driver.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "qmk/qmk_firmware", "stars": 16782, "license": "gpl-2.0", "language": "c", "size": 296418}
{"docstring": "/**\n * @brief   Default requests hook.\n * @details Applications wanting to use the Serial over USB driver can use\n *          this function as requests hook in the USB configuration.\n *          The following requests are emulated:\n *          - CDC_GET_LINE_CODING.\n *          - CDC_SET_LINE_CODING.\n *          - CDC_SET_CONTROL_LINE_STATE.\n *          .\n *\n * @param[in] usbp      pointer to the @p USBDriver object\n * @return              The hook status.\n * @retval true         Message handled internally.\n * @retval false        Message not handled.\n */\n", "func_signal": "bool qmkusbRequestsHook(USBDriver *usbp)", "code": "{\n    if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {\n        switch (usbp->setup[1]) {\n            case CDC_GET_LINE_CODING:\n                usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);\n                return true;\n            case CDC_SET_LINE_CODING:\n                usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);\n                return true;\n            case CDC_SET_CONTROL_LINE_STATE:\n                /* Nothing to do, there are no control lines.*/\n                usbSetupTransfer(usbp, NULL, 0, NULL);\n                return true;\n            default:\n                return false;\n        }\n    }\n    return false;\n}", "path": "qmk_firmware/tmk_core/protocol/chibios/usb_driver.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "qmk/qmk_firmware", "stars": 16782, "license": "gpl-2.0", "language": "c", "size": 296418}
{"docstring": "// Some helpers for setting/getting HSV\n", "func_signal": "void _set_color( HS *color, uint8_t *data )", "code": "{\n    color->h = data[0];\n    color->s = data[1];\n}", "path": "qmk_firmware/keyboards/wilba_tech/wt_mono_backlight.c", "commit_date": "2020-01-20 00:00:00", "repo_name": "qmk/qmk_firmware", "stars": 16782, "license": "gpl-2.0", "language": "c", "size": 296418}
{"docstring": "/**\n * @brief   USB device suspend handler.\n * @details Generates a @p CHN_DISCONNECT event and puts queues in\n *          non-blocking mode, this way the application cannot get stuck\n *          in the middle of an I/O operations.\n * @note    If this function is not called from an ISR then an explicit call\n *          to @p osalOsRescheduleS() in necessary afterward.\n *\n * @param[in] qmkusbp      pointer to a @p QMKUSBDriver object\n *\n * @iclass\n */\n", "func_signal": "void qmkusbSuspendHookI(QMKUSBDriver *qmkusbp)", "code": "{\n    chnAddFlagsI(qmkusbp, CHN_DISCONNECTED);\n    bqSuspendI(&qmkusbp->ibqueue);\n    bqSuspendI(&qmkusbp->obqueue);\n}", "path": "qmk_firmware/tmk_core/protocol/chibios/usb_driver.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "qmk/qmk_firmware", "stars": 16782, "license": "gpl-2.0", "language": "c", "size": 296418}
{"docstring": "//macros to allow the user to set whatever default layer they want, even after reboot\n", "func_signal": "bool process_record_user(uint16_t keycode, keyrecord_t *record)", "code": "{\n    switch (keycode) {\n        case BASE_QWER:\n            if (record->event.pressed) {\n            // when keycode BASE_QWER is pressed\n                set_single_persistent_default_layer(_QWER);\n            } else {\n            // when keycode BASE_QWER is released\n            }\n            break;\n\n        case BASE_COLE:\n            if (record->event.pressed) {\n            // when keycode BASE_COLE is pressed\n                set_single_persistent_default_layer(_COLE);\n            } else {\n            // when keycode BASE_COLE is released\n            }\n            break;\n\n        case BASE_DVOR:\n            if (record->event.pressed) {\n            // when keycode BASE_DVOR is pressed\n                set_single_persistent_default_layer(_DVOR);\n            } else {\n            // when keycode BASE_DVOR is released\n            }\n            break;\n    }\n    return true;\n}", "path": "qmk_firmware/keyboards/bear_face/v1/keymaps/default/keymap.c", "commit_date": "2020-07-28 00:00:00", "repo_name": "qmk/qmk_firmware", "stars": 16782, "license": "gpl-2.0", "language": "c", "size": 296418}
{"docstring": "// Update Chord State\n", "func_signal": "bool process_record_kb(uint16_t keycode, keyrecord_t *record)", "code": "{\n    // Everything happens in here when steno keys come in.\n    // Bail on keyup\n\n    // Update key repeat timers\n    repTimer = timer_read();\n    bool pr  = record->event.pressed;\n    // Switch on the press adding to chord\n    switch (keycode) {\n        ENGINE_CONFIG\n        default:\n            return true;\n    }\n\n    // Handle any postprocessing\n\n    // All keys up, send it!\n    if (inChord && !pr && (pressed & IN_CHORD_MASK) == 0) {\n        processKeysUp();\n        return false;\n    }\n    if (pressed == 0 && !pr) {\n        processKeysUp();\n        return false;\n    }\n\n    cChord |= pressed;\n    cChord  = process_engine_post(cChord, keycode, record);\n    inChord = (cChord & IN_CHORD_MASK) != 0;\n\n    // Store previous state for fastQWER\n    if (pr) {\n        chordState[chordIndex] = cChord;\n        chordIndex++;\n    }\n\n#ifndef NO_DEBUG\n    uprintf(\"Chord: %u\\n\", cChord);\n#endif\n    return false;\n}", "path": "qmk_firmware/keyboards/gboards/engine/engine.c", "commit_date": "2020-05-04 00:00:00", "repo_name": "qmk/qmk_firmware", "stars": 16782, "license": "gpl-2.0", "language": "c", "size": 296418}
{"docstring": "/* Return the total amount used by a key (encoded length + payload) */\n", "func_signal": "static unsigned int zipmapRawKeyLength(unsigned char *p)", "code": "{\n    unsigned int l = zipmapDecodeLength(p);\n    return zipmapEncodeLength(NULL,l) + l;\n}", "path": "redis/src/zipmap.c", "commit_date": "2020-12-06 00:00:00", "repo_name": "redis/redis", "stars": 63572, "license": "bsd-3-clause", "language": "c", "size": 137196}
{"docstring": "/*\n** returns the index of a `key' for table traversals. First goes all\n** elements in the array part, then elements in the hash part. The\n** beginning of a traversal is signalled by -1.\n*/\n", "func_signal": "static int findindex (lua_State *L, Table *t, StkId key)", "code": "{\n  int i;\n  if (ttisnil(key)) return -1;  /* first iteration */\n  i = arrayindex(key);\n  if (0 < i && i <= t->sizearray)  /* is `key' inside array part? */\n    return i-1;  /* yes; that's the index (corrected to C) */\n  else {\n    Node *n = mainposition(t, key);\n    do {  /* check whether `key' is somewhere in the chain */\n      /* key may be dead already, but it is ok to use it in `next' */\n      if (luaO_rawequalObj(key2tval(n), key) ||\n            (ttype(gkey(n)) == LUA_TDEADKEY && iscollectable(key) &&\n             gcvalue(gkey(n)) == gcvalue(key))) {\n        i = cast_int(n - gnode(t, 0));  /* key index in hash table */\n        /* hash elements are numbered after array ones */\n        return i + t->sizearray;\n      }\n      else n = gnext(n);\n    } while (n);\n    luaG_runerror(L, \"invalid key to \" LUA_QL(\"next\"));  /* key not found */\n    return 0;  /* to avoid warnings */\n  }\n}", "path": "redis/deps/lua/src/ltable.c", "commit_date": "2011-05-25 00:00:00", "repo_name": "redis/redis", "stars": 63572, "license": "bsd-3-clause", "language": "c", "size": 137196}
{"docstring": "/* Return the number of entries inside a zipmap */\n", "func_signal": "unsigned int zipmapLen(unsigned char *zm)", "code": "{\n    unsigned int len = 0;\n    if (zm[0] < ZIPMAP_BIGLEN) {\n        len = zm[0];\n    } else {\n        unsigned char *p = zipmapRewind(zm);\n        while((p = zipmapNext(p,NULL,NULL,NULL,NULL)) != NULL) len++;\n\n        /* Re-store length if small enough */\n        if (len < ZIPMAP_BIGLEN) zm[0] = len;\n    }\n    return len;\n}", "path": "redis/src/zipmap.c", "commit_date": "2020-12-06 00:00:00", "repo_name": "redis/redis", "stars": 63572, "license": "bsd-3-clause", "language": "c", "size": 137196}
{"docstring": "/* Search for a matching key, returning a pointer to the entry inside the\n * zipmap. Returns NULL if the key is not found.\n *\n * If NULL is returned, and totlen is not NULL, it is set to the entire\n * size of the zipmap, so that the calling function will be able to\n * reallocate the original zipmap to make room for more entries. */\n", "func_signal": "static unsigned char *zipmapLookupRaw(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned int *totlen)", "code": "{\n    unsigned char *p = zm+1, *k = NULL;\n    unsigned int l,llen;\n\n    while(*p != ZIPMAP_END) {\n        unsigned char free;\n\n        /* Match or skip the key */\n        l = zipmapDecodeLength(p);\n        llen = zipmapEncodeLength(NULL,l);\n        if (key != NULL && k == NULL && l == klen && !memcmp(p+llen,key,l)) {\n            /* Only return when the user doesn't care\n             * for the total length of the zipmap. */\n            if (totlen != NULL) {\n                k = p;\n            } else {\n                return p;\n            }\n        }\n        p += llen+l;\n        /* Skip the value as well */\n        l = zipmapDecodeLength(p);\n        p += zipmapEncodeLength(NULL,l);\n        free = p[0];\n        p += l+1+free; /* +1 to skip the free byte */\n    }\n    if (totlen != NULL) *totlen = (unsigned int)(p-zm)+1;\n    return k;\n}", "path": "redis/src/zipmap.c", "commit_date": "2020-12-06 00:00:00", "repo_name": "redis/redis", "stars": 63572, "license": "bsd-3-clause", "language": "c", "size": 137196}
{"docstring": "/* HELLODICT.SET <key> <value>\n *\n * Set the specified key to the specified value. */\n", "func_signal": "int cmd_SET(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)", "code": "{\n    if (argc != 3) return RedisModule_WrongArity(ctx);\n    RedisModule_DictSet(Keyspace,argv[1],argv[2]);\n    /* We need to keep a reference to the value stored at the key, otherwise\n     * it would be freed when this callback returns. */\n    RedisModule_RetainString(NULL,argv[2]);\n    return RedisModule_ReplyWithSimpleString(ctx, \"OK\");\n}", "path": "redis/src/modules/hellodict.c", "commit_date": "2020-09-10 00:00:00", "repo_name": "redis/redis", "stars": 63572, "license": "bsd-3-clause", "language": "c", "size": 137196}
{"docstring": "/* A sample movable keys command that returns a list of all\n * arguments that follow a KEY argument, i.e.\n */\n", "func_signal": "int getkeys_command(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)", "code": "{\n    int i;\n    int count = 0;\n\n    /* Handle getkeys-api introspection */\n    if (RedisModule_IsKeysPositionRequest(ctx)) {\n        for (i = 0; i < argc; i++) {\n            size_t len;\n            const char *str = RedisModule_StringPtrLen(argv[i], &len);\n\n            if (len == 3 && !strncasecmp(str, \"key\", 3) && i + 1 < argc)\n                RedisModule_KeyAtPos(ctx, i + 1);\n        }\n\n        return REDISMODULE_OK;\n    }\n\n    /* Handle real command invocation */\n    RedisModule_ReplyWithArray(ctx, REDISMODULE_POSTPONED_ARRAY_LEN);\n    for (i = 0; i < argc; i++) {\n        size_t len;\n        const char *str = RedisModule_StringPtrLen(argv[i], &len);\n\n        if (len == 3 && !strncasecmp(str, \"key\", 3) && i + 1 < argc) {\n            RedisModule_ReplyWithString(ctx, argv[i+1]);\n            count++;\n        }\n    }\n    RedisModule_ReplySetArrayLength(ctx, count);\n\n    return REDISMODULE_OK;\n}", "path": "redis/tests/modules/getkeys.c", "commit_date": "2020-10-11 00:00:00", "repo_name": "redis/redis", "stars": 63572, "license": "bsd-3-clause", "language": "c", "size": 137196}
{"docstring": "/* Decode the encoded length pointed by 'p' */\n", "func_signal": "static unsigned int zipmapDecodeLength(unsigned char *p)", "code": "{\n    unsigned int len = *p;\n\n    if (len < ZIPMAP_BIGLEN) return len;\n    memcpy(&len,p+1,sizeof(unsigned int));\n    memrev32ifbe(&len);\n    return len;\n}", "path": "redis/src/zipmap.c", "commit_date": "2020-12-06 00:00:00", "repo_name": "redis/redis", "stars": 63572, "license": "bsd-3-clause", "language": "c", "size": 137196}
{"docstring": "/*\n** If your system does not support `stdout', you can just remove this function.\n** If you need, you can define your own `print' function, following this\n** model but changing `fputs' to put the strings at a proper place\n** (a console window or a log file, for instance).\n*/\n", "func_signal": "static int luaB_print (lua_State *L)", "code": "{\n  int n = lua_gettop(L);  /* number of arguments */\n  int i;\n  lua_getglobal(L, \"tostring\");\n  for (i=1; i<=n; i++) {\n    const char *s;\n    lua_pushvalue(L, -1);  /* function to be called */\n    lua_pushvalue(L, i);   /* value to print */\n    lua_call(L, 1, 1);\n    s = lua_tostring(L, -1);  /* get result */\n    if (s == NULL)\n      return luaL_error(L, LUA_QL(\"tostring\") \" must return a string to \"\n                           LUA_QL(\"print\"));\n    if (i>1) fputs(\"\\t\", stdout);\n    fputs(s, stdout);\n    lua_pop(L, 1);  /* pop result */\n  }\n  fputs(\"\\n\", stdout);\n  return 0;\n}", "path": "redis/deps/lua/src/lbaselib.c", "commit_date": "2013-04-29 00:00:00", "repo_name": "redis/redis", "stars": 63572, "license": "bsd-3-clause", "language": "c", "size": 137196}
{"docstring": "/*\n** Look for n-th local variable at line `line' in function `func'.\n** Returns NULL if not found.\n*/\n", "func_signal": "const char *luaF_getlocalname (const Proto *f, int local_number, int pc)", "code": "{\n  int i;\n  for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {\n    if (pc < f->locvars[i].endpc) {  /* is variable active? */\n      local_number--;\n      if (local_number == 0)\n        return getstr(f->locvars[i].varname);\n    }\n  }\n  return NULL;  /* not found */\n}", "path": "redis/deps/lua/src/lfunc.c", "commit_date": "2011-05-25 00:00:00", "repo_name": "redis/redis", "stars": 63572, "license": "bsd-3-clause", "language": "c", "size": 137196}
{"docstring": "/*\n** hash for lua_Numbers\n*/\n", "func_signal": "static Node *hashnum (const Table *t, lua_Number n)", "code": "{\n  unsigned int a[numints];\n  int i;\n  if (luai_numeq(n, 0))  /* avoid problems with -0 */\n    return gnode(t, 0);\n  memcpy(a, &n, sizeof(a));\n  for (i = 1; i < numints; i++) a[0] += a[i];\n  return hashmod(t, a[0]);\n}", "path": "redis/deps/lua/src/ltable.c", "commit_date": "2011-05-25 00:00:00", "repo_name": "redis/redis", "stars": 63572, "license": "bsd-3-clause", "language": "c", "size": 137196}
{"docstring": "/*\n** returns the `main' position of an element in a table (that is, the index\n** of its hash value)\n*/\n", "func_signal": "static Node *mainposition (const Table *t, const TValue *key)", "code": "{\n  switch (ttype(key)) {\n    case LUA_TNUMBER:\n      return hashnum(t, nvalue(key));\n    case LUA_TSTRING:\n      return hashstr(t, rawtsvalue(key));\n    case LUA_TBOOLEAN:\n      return hashboolean(t, bvalue(key));\n    case LUA_TLIGHTUSERDATA:\n      return hashpointer(t, pvalue(key));\n    default:\n      return hashpointer(t, gcvalue(key));\n  }\n}", "path": "redis/deps/lua/src/ltable.c", "commit_date": "2011-05-25 00:00:00", "repo_name": "redis/redis", "stars": 63572, "license": "bsd-3-clause", "language": "c", "size": 137196}
{"docstring": "/* This function must be present on each Redis module. It is used in order to\n * register the commands into the Redis server. */\n", "func_signal": "int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)", "code": "{\n    REDISMODULE_NOT_USED(argv);\n    REDISMODULE_NOT_USED(argc);\n\n    if (RedisModule_Init(ctx,\"hellodict\",1,REDISMODULE_APIVER_1)\n        == REDISMODULE_ERR) return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\"hellodict.set\",\n        cmd_SET,\"write deny-oom\",1,1,0) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\"hellodict.get\",\n        cmd_GET,\"readonly\",1,1,0) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\"hellodict.keyrange\",\n        cmd_KEYRANGE,\"readonly\",1,1,0) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    /* Create our global dictionary. Here we'll set our keys and values. */\n    Keyspace = RedisModule_CreateDict(NULL);\n\n    return REDISMODULE_OK;\n}", "path": "redis/src/modules/hellodict.c", "commit_date": "2020-09-10 00:00:00", "repo_name": "redis/redis", "stars": 63572, "license": "bsd-3-clause", "language": "c", "size": 137196}
{"docstring": "/* Validate the integrity of the data stracture.\n * when `deep` is 0, only the integrity of the header is validated.\n * when `deep` is 1, we scan all the entries one by one. */\n", "func_signal": "int zipmapValidateIntegrity(unsigned char *zm, size_t size, int deep)", "code": "{\n#define OUT_OF_RANGE(p) ( \\\n        (p) < zm + 2 || \\\n        (p) > zm + size - 1)\n    unsigned int l, s, e;\n\n    /* check that we can actually read the header (or ZIPMAP_END). */\n    if (size < 2)\n        return 0;\n\n    /* the last byte must be the terminator. */\n    if (zm[size-1] != ZIPMAP_END)\n        return 0;\n\n    if (!deep)\n        return 1;\n\n    unsigned int count = 0;\n    unsigned char *p = zm + 1; /* skip the count */\n    while(*p != ZIPMAP_END) {\n        /* read the field name length encoding type */\n        s = zipmapGetEncodedLengthSize(p);\n        /* make sure the entry length doesn't rech outside the edge of the zipmap */\n        if (OUT_OF_RANGE(p+s))\n            return 0;\n\n        /* read the field name length */\n        l = zipmapDecodeLength(p);\n        p += s; /* skip the encoded field size */\n        p += l; /* skip the field */\n\n        /* make sure the entry doesn't rech outside the edge of the zipmap */\n        if (OUT_OF_RANGE(p))\n            return 0;\n\n        /* read the value length encoding type */\n        s = zipmapGetEncodedLengthSize(p);\n        /* make sure the entry length doesn't rech outside the edge of the zipmap */\n        if (OUT_OF_RANGE(p+s))\n            return 0;\n\n        /* read the value length */\n        l = zipmapDecodeLength(p);\n        p += s; /* skip the encoded value size*/\n        e = *p++; /* skip the encoded free space (always encoded in one byte) */\n        p += l+e; /* skip the value and free space */\n        count++;\n\n        /* make sure the entry doesn't rech outside the edge of the zipmap */\n        if (OUT_OF_RANGE(p))\n            return 0;\n    }\n\n    /* check that the count in the header is correct */\n    if (zm[0] != ZIPMAP_BIGLEN && zm[0] != count)\n        return 0;\n\n    return 1;\n#undef OUT_OF_RANGE\n}", "path": "redis/src/zipmap.c", "commit_date": "2020-12-06 00:00:00", "repo_name": "redis/redis", "stars": 63572, "license": "bsd-3-clause", "language": "c", "size": 137196}
{"docstring": "/* Return the total amount used by a value\n * (encoded length + single byte free count + payload) */\n", "func_signal": "static unsigned int zipmapRawValueLength(unsigned char *p)", "code": "{\n    unsigned int l = zipmapDecodeLength(p);\n    unsigned int used;\n\n    used = zipmapEncodeLength(NULL,l);\n    used += p[used] + 1 + l;\n    return used;\n}", "path": "redis/src/zipmap.c", "commit_date": "2020-12-06 00:00:00", "repo_name": "redis/redis", "stars": 63572, "license": "bsd-3-clause", "language": "c", "size": 137196}
{"docstring": "/* Remove the specified key. If 'deleted' is not NULL the pointed integer is\n * set to 0 if the key was not found, to 1 if it was found and deleted. */\n", "func_signal": "unsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted)", "code": "{\n    unsigned int zmlen, freelen;\n    unsigned char *p = zipmapLookupRaw(zm,key,klen,&zmlen);\n    if (p) {\n        freelen = zipmapRawEntryLength(p);\n        memmove(p, p+freelen, zmlen-((p-zm)+freelen+1));\n        zm = zipmapResize(zm, zmlen-freelen);\n\n        /* Decrease zipmap length */\n        if (zm[0] < ZIPMAP_BIGLEN) zm[0]--;\n\n        if (deleted) *deleted = 1;\n    } else {\n        if (deleted) *deleted = 0;\n    }\n    return zm;\n}", "path": "redis/src/zipmap.c", "commit_date": "2020-12-06 00:00:00", "repo_name": "redis/redis", "stars": 63572, "license": "bsd-3-clause", "language": "c", "size": 137196}
{"docstring": "/*\n** search function for integers\n*/\n", "func_signal": "const TValue *luaH_getnum (Table *t, int key)", "code": "{\n  /* (1 <= key && key <= t->sizearray) */\n  if (cast(unsigned int, key-1) < cast(unsigned int, t->sizearray))\n    return &t->array[key-1];\n  else {\n    lua_Number nk = cast_num(key);\n    Node *n = hashnum(t, nk);\n    do {  /* check whether `key' is somewhere in the chain */\n      if (ttisnumber(gkey(n)) && luai_numeq(nvalue(gkey(n)), nk))\n        return gval(n);  /* that's it */\n      else n = gnext(n);\n    } while (n);\n    return luaO_nilobject;\n  }\n}", "path": "redis/deps/lua/src/ltable.c", "commit_date": "2011-05-25 00:00:00", "repo_name": "redis/redis", "stars": 63572, "license": "bsd-3-clause", "language": "c", "size": 137196}
{"docstring": "/*\n** returns the index for `key' if `key' is an appropriate key to live in\n** the array part of the table, -1 otherwise.\n*/\n", "func_signal": "static int arrayindex (const TValue *key)", "code": "{\n  if (ttisnumber(key)) {\n    lua_Number n = nvalue(key);\n    int k;\n    lua_number2int(k, n);\n    if (luai_numeq(cast_num(k), n))\n      return k;\n  }\n  return -1;  /* `key' did not match some condition */\n}", "path": "redis/deps/lua/src/ltable.c", "commit_date": "2011-05-25 00:00:00", "repo_name": "redis/redis", "stars": 63572, "license": "bsd-3-clause", "language": "c", "size": 137196}
{"docstring": "/* HELLODICT.GET <key>\n *\n * Return the value of the specified key, or a null reply if the key\n * is not defined. */\n", "func_signal": "int cmd_GET(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)", "code": "{\n    if (argc != 2) return RedisModule_WrongArity(ctx);\n    RedisModuleString *val = RedisModule_DictGet(Keyspace,argv[1],NULL);\n    if (val == NULL) {\n        return RedisModule_ReplyWithNull(ctx);\n    } else {\n        return RedisModule_ReplyWithString(ctx, val);\n    }\n}", "path": "redis/src/modules/hellodict.c", "commit_date": "2020-09-10 00:00:00", "repo_name": "redis/redis", "stars": 63572, "license": "bsd-3-clause", "language": "c", "size": 137196}
{"docstring": "/*\n** Reader for generic `load' function: `lua_load' uses the\n** stack for internal stuff, so the reader cannot change the\n** stack top. Instead, it keeps its resulting string in a\n** reserved slot inside the stack.\n*/\n", "func_signal": "static const char *generic_reader (lua_State *L, void *ud, size_t *size)", "code": "{\n  (void)ud;  /* to avoid warnings */\n  luaL_checkstack(L, 2, \"too many nested functions\");\n  lua_pushvalue(L, 1);  /* get function */\n  lua_call(L, 0, 1);  /* call it */\n  if (lua_isnil(L, -1)) {\n    *size = 0;\n    return NULL;\n  }\n  else if (lua_isstring(L, -1)) {\n    lua_replace(L, 3);  /* save string in a reserved stack slot */\n    return lua_tolstring(L, 3, size);\n  }\n  else luaL_error(L, \"reader function must return a string\");\n  return NULL;  /* to avoid warnings */\n}", "path": "redis/deps/lua/src/lbaselib.c", "commit_date": "2013-04-29 00:00:00", "repo_name": "redis/redis", "stars": 63572, "license": "bsd-3-clause", "language": "c", "size": 137196}
{"docstring": "/*\n** Try to find a boundary in table `t'. A `boundary' is an integer index\n** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).\n*/\n", "func_signal": "int luaH_getn (Table *t)", "code": "{\n  unsigned int j = t->sizearray;\n  if (j > 0 && ttisnil(&t->array[j - 1])) {\n    /* there is a boundary in the array part: (binary) search for it */\n    unsigned int i = 0;\n    while (j - i > 1) {\n      unsigned int m = (i+j)/2;\n      if (ttisnil(&t->array[m - 1])) j = m;\n      else i = m;\n    }\n    return i;\n  }\n  /* else must find a boundary in hash part */\n  else if (t->node == dummynode)  /* hash part is empty? */\n    return j;  /* that is easy... */\n  else return unbound_search(t, j);\n}", "path": "redis/deps/lua/src/ltable.c", "commit_date": "2011-05-25 00:00:00", "repo_name": "redis/redis", "stars": 63572, "license": "bsd-3-clause", "language": "c", "size": 137196}
{"docstring": "// Initialise timer\n//\n", "func_signal": "void _glfwInitTimer(void)", "code": "{\n    mach_timebase_info_data_t info;\n    mach_timebase_info(&info);\n\n    _glfw.ns_time.resolution = (double) info.numer / (info.denom * 1.0e9);\n    _glfw.ns_time.base = getRawTime();\n}", "path": "Craft/deps/glfw/src/mach_time.c", "commit_date": "2016-01-31 00:00:00", "repo_name": "fogleman/Craft", "stars": 10133, "license": "mit", "language": "c", "size": 14666}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n", "func_signal": "int _glfwPlatformCreateWindow(_GLFWwindow* window,\n                              const _GLFWwndconfig* wndconfig,\n                              const _GLFWctxconfig* ctxconfig,\n                              const _GLFWfbconfig* fbconfig)", "code": "{\n    if (!_glfwCreateContext(window, ctxconfig, fbconfig))\n        return GL_FALSE;\n\n    if (wndconfig->monitor)\n    {\n        GLFWvidmode mode;\n        _glfwPlatformGetVideoMode(wndconfig->monitor, &mode);\n\n        mir_surface_set_state(window->mir.surface, mir_surface_state_fullscreen);\n\n        if (wndconfig->width > mode.width || wndconfig->height > mode.height)\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"Mir: Requested surface size too large: %ix%i\",\n                            wndconfig->width, wndconfig->height);\n\n            return GL_FALSE;\n        }\n    }\n\n    window->mir.width  = wndconfig->width;\n    window->mir.height = wndconfig->height;\n\n    if (!createSurface(window))\n        return GL_FALSE;\n\n    window->mir.window = mir_buffer_stream_get_egl_native_window(\n                                   mir_surface_get_buffer_stream(window->mir.surface));\n\n    return GL_TRUE;\n}", "path": "Craft/deps/glfw/src/mir_window.c", "commit_date": "2016-01-31 00:00:00", "repo_name": "fogleman/Craft", "stars": 10133, "license": "mit", "language": "c", "size": 14666}
{"docstring": "/* new window size */\n", "func_signal": "void reshape( GLFWwindow* window, int width, int height )", "code": "{\n  GLfloat h = (GLfloat) height / (GLfloat) width;\n  GLfloat xmax, znear, zfar;\n\n  znear = 5.0f;\n  zfar  = 30.0f;\n  xmax  = znear * 0.5f;\n\n  glViewport( 0, 0, (GLint) width, (GLint) height );\n  glMatrixMode( GL_PROJECTION );\n  glLoadIdentity();\n  glFrustum( -xmax, xmax, -xmax*h, xmax*h, znear, zfar );\n  glMatrixMode( GL_MODELVIEW );\n  glLoadIdentity();\n  glTranslatef( 0.0, 0.0, -20.0 );\n}", "path": "Craft/deps/glfw/examples/gears.c", "commit_date": "2016-02-03 00:00:00", "repo_name": "fogleman/Craft", "stars": 10133, "license": "mit", "language": "c", "size": 14666}
{"docstring": "/* OpenGL draw function & timing */\n", "func_signal": "static void draw(void)", "code": "{\n  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n  glPushMatrix();\n    glRotatef(view_rotx, 1.0, 0.0, 0.0);\n    glRotatef(view_roty, 0.0, 1.0, 0.0);\n    glRotatef(view_rotz, 0.0, 0.0, 1.0);\n\n    glPushMatrix();\n      glTranslatef(-3.0, -2.0, 0.0);\n      glRotatef(angle, 0.0, 0.0, 1.0);\n      glCallList(gear1);\n    glPopMatrix();\n\n    glPushMatrix();\n      glTranslatef(3.1f, -2.f, 0.f);\n      glRotatef(-2.f * angle - 9.f, 0.f, 0.f, 1.f);\n      glCallList(gear2);\n    glPopMatrix();\n\n    glPushMatrix();\n      glTranslatef(-3.1f, 4.2f, 0.f);\n      glRotatef(-2.f * angle - 25.f, 0.f, 0.f, 1.f);\n      glCallList(gear3);\n    glPopMatrix();\n\n  glPopMatrix();\n}", "path": "Craft/deps/glfw/examples/gears.c", "commit_date": "2016-02-03 00:00:00", "repo_name": "fogleman/Craft", "stars": 10133, "license": "mit", "language": "c", "size": 14666}
{"docstring": "// FIXME implement\n", "func_signal": "int _glfwPlatformCreateCursor(_GLFWcursor* cursor,\n                              const GLFWimage* image,\n                              int xhot, int yhot)", "code": "{\n    MirBufferStream* stream;\n    MirPixelFormat pixel_format = findValidPixelFormat();\n\n    int i_w = image->width;\n    int i_h = image->height;\n\n    if (pixel_format == mir_pixel_format_invalid)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"Mir: Unable to find a correct pixel format\");\n        return GL_FALSE;\n    }\n\n    stream = mir_connection_create_buffer_stream_sync(_glfw.mir.connection,\n                                                      i_w, i_h,\n                                                      pixel_format,\n                                                      mir_buffer_usage_software);\n\n    cursor->mir.conf = mir_cursor_configuration_from_buffer_stream(stream, xhot, yhot);\n\n    char* dest;\n    unsigned char *pixels;\n    int i, r_stride, bytes_per_pixel, bytes_per_row;\n\n    MirGraphicsRegion region;\n    mir_buffer_stream_get_graphics_region(stream, &region);\n\n    // FIXME Figure this out based on the current_pf\n    bytes_per_pixel = 4;\n    bytes_per_row   = bytes_per_pixel * i_w;\n\n    dest   = region.vaddr;\n    pixels = image->pixels;\n\n    r_stride = region.stride;\n\n    for (i = 0; i < i_h; i++)\n    {\n        memcpy(dest, pixels, bytes_per_row);\n        dest   += r_stride;\n        pixels += r_stride;\n    }\n\n    cursor->mir.custom_cursor = stream;\n\n    return GL_TRUE;\n}", "path": "Craft/deps/glfw/src/mir_window.c", "commit_date": "2016-01-31 00:00:00", "repo_name": "fogleman/Craft", "stars": 10133, "license": "mit", "language": "c", "size": 14666}
{"docstring": "// Returns whether desktop compositing is enabled\n//\n", "func_signal": "BOOL _glfwIsCompositionEnabled(void)", "code": "{\n    BOOL enabled;\n\n    if (!_glfw_DwmIsCompositionEnabled)\n        return FALSE;\n\n    if (_glfw_DwmIsCompositionEnabled(&enabled) != S_OK)\n        return FALSE;\n\n    return enabled;\n}", "path": "Craft/deps/glfw/src/win32_init.c", "commit_date": "2016-01-31 00:00:00", "repo_name": "fogleman/Craft", "stars": 10133, "license": "mit", "language": "c", "size": 14666}
{"docstring": "// Return raw time\n//\n", "func_signal": "static unsigned __int64 getRawTime(void)", "code": "{\n    if (_glfw.win32_time.hasPC)\n    {\n        unsigned __int64 time;\n        QueryPerformanceCounter((LARGE_INTEGER*) &time);\n        return time;\n    }\n    else\n        return (unsigned __int64) _glfw_timeGetTime();\n}", "path": "Craft/deps/glfw/src/win32_time.c", "commit_date": "2016-01-31 00:00:00", "repo_name": "fogleman/Craft", "stars": 10133, "license": "mit", "language": "c", "size": 14666}
{"docstring": "/**\n\n  Draw a gear wheel.  You'll probably want to call this function when\n  building a display list since we do a lot of trig here.\n\n  Input:  inner_radius - radius of hole at center\n          outer_radius - radius at center of teeth\n          width - width of gear teeth - number of teeth\n          tooth_depth - depth of tooth\n\n **/\n", "func_signal": "static void\ngear(GLfloat inner_radius, GLfloat outer_radius, GLfloat width,\n  GLint teeth, GLfloat tooth_depth)", "code": "{\n  GLint i;\n  GLfloat r0, r1, r2;\n  GLfloat angle, da;\n  GLfloat u, v, len;\n\n  r0 = inner_radius;\n  r1 = outer_radius - tooth_depth / 2.f;\n  r2 = outer_radius + tooth_depth / 2.f;\n\n  da = 2.f * (float) M_PI / teeth / 4.f;\n\n  glShadeModel(GL_FLAT);\n\n  glNormal3f(0.f, 0.f, 1.f);\n\n  /* draw front face */\n  glBegin(GL_QUAD_STRIP);\n  for (i = 0; i <= teeth; i++) {\n    angle = i * 2.f * (float) M_PI / teeth;\n    glVertex3f(r0 * (float) cos(angle), r0 * (float) sin(angle), width * 0.5f);\n    glVertex3f(r1 * (float) cos(angle), r1 * (float) sin(angle), width * 0.5f);\n    if (i < teeth) {\n      glVertex3f(r0 * (float) cos(angle), r0 * (float) sin(angle), width * 0.5f);\n      glVertex3f(r1 * (float) cos(angle + 3 * da), r1 * (float) sin(angle + 3 * da), width * 0.5f);\n    }\n  }\n  glEnd();\n\n  /* draw front sides of teeth */\n  glBegin(GL_QUADS);\n  da = 2.f * (float) M_PI / teeth / 4.f;\n  for (i = 0; i < teeth; i++) {\n    angle = i * 2.f * (float) M_PI / teeth;\n\n    glVertex3f(r1 * (float) cos(angle), r1 * (float) sin(angle), width * 0.5f);\n    glVertex3f(r2 * (float) cos(angle + da), r2 * (float) sin(angle + da), width * 0.5f);\n    glVertex3f(r2 * (float) cos(angle + 2 * da), r2 * (float) sin(angle + 2 * da), width * 0.5f);\n    glVertex3f(r1 * (float) cos(angle + 3 * da), r1 * (float) sin(angle + 3 * da), width * 0.5f);\n  }\n  glEnd();\n\n  glNormal3f(0.0, 0.0, -1.0);\n\n  /* draw back face */\n  glBegin(GL_QUAD_STRIP);\n  for (i = 0; i <= teeth; i++) {\n    angle = i * 2.f * (float) M_PI / teeth;\n    glVertex3f(r1 * (float) cos(angle), r1 * (float) sin(angle), -width * 0.5f);\n    glVertex3f(r0 * (float) cos(angle), r0 * (float) sin(angle), -width * 0.5f);\n    if (i < teeth) {\n      glVertex3f(r1 * (float) cos(angle + 3 * da), r1 * (float) sin(angle + 3 * da), -width * 0.5f);\n      glVertex3f(r0 * (float) cos(angle), r0 * (float) sin(angle), -width * 0.5f);\n    }\n  }\n  glEnd();\n\n  /* draw back sides of teeth */\n  glBegin(GL_QUADS);\n  da = 2.f * (float) M_PI / teeth / 4.f;\n  for (i = 0; i < teeth; i++) {\n    angle = i * 2.f * (float) M_PI / teeth;\n\n    glVertex3f(r1 * (float) cos(angle + 3 * da), r1 * (float) sin(angle + 3 * da), -width * 0.5f);\n    glVertex3f(r2 * (float) cos(angle + 2 * da), r2 * (float) sin(angle + 2 * da), -width * 0.5f);\n    glVertex3f(r2 * (float) cos(angle + da), r2 * (float) sin(angle + da), -width * 0.5f);\n    glVertex3f(r1 * (float) cos(angle), r1 * (float) sin(angle), -width * 0.5f);\n  }\n  glEnd();\n\n  /* draw outward faces of teeth */\n  glBegin(GL_QUAD_STRIP);\n  for (i = 0; i < teeth; i++) {\n    angle = i * 2.f * (float) M_PI / teeth;\n\n    glVertex3f(r1 * (float) cos(angle), r1 * (float) sin(angle), width * 0.5f);\n    glVertex3f(r1 * (float) cos(angle), r1 * (float) sin(angle), -width * 0.5f);\n    u = r2 * (float) cos(angle + da) - r1 * (float) cos(angle);\n    v = r2 * (float) sin(angle + da) - r1 * (float) sin(angle);\n    len = (float) sqrt(u * u + v * v);\n    u /= len;\n    v /= len;\n    glNormal3f(v, -u, 0.0);\n    glVertex3f(r2 * (float) cos(angle + da), r2 * (float) sin(angle + da), width * 0.5f);\n    glVertex3f(r2 * (float) cos(angle + da), r2 * (float) sin(angle + da), -width * 0.5f);\n    glNormal3f((float) cos(angle), (float) sin(angle), 0.f);\n    glVertex3f(r2 * (float) cos(angle + 2 * da), r2 * (float) sin(angle + 2 * da), width * 0.5f);\n    glVertex3f(r2 * (float) cos(angle + 2 * da), r2 * (float) sin(angle + 2 * da), -width * 0.5f);\n    u = r1 * (float) cos(angle + 3 * da) - r2 * (float) cos(angle + 2 * da);\n    v = r1 * (float) sin(angle + 3 * da) - r2 * (float) sin(angle + 2 * da);\n    glNormal3f(v, -u, 0.f);\n    glVertex3f(r1 * (float) cos(angle + 3 * da), r1 * (float) sin(angle + 3 * da), width * 0.5f);\n    glVertex3f(r1 * (float) cos(angle + 3 * da), r1 * (float) sin(angle + 3 * da), -width * 0.5f);\n    glNormal3f((float) cos(angle), (float) sin(angle), 0.f);\n  }\n\n  glVertex3f(r1 * (float) cos(0), r1 * (float) sin(0), width * 0.5f);\n  glVertex3f(r1 * (float) cos(0), r1 * (float) sin(0), -width * 0.5f);\n\n  glEnd();\n\n  glShadeModel(GL_SMOOTH);\n\n  /* draw inside radius cylinder */\n  glBegin(GL_QUAD_STRIP);\n  for (i = 0; i <= teeth; i++) {\n    angle = i * 2.f * (float) M_PI / teeth;\n    glNormal3f(-(float) cos(angle), -(float) sin(angle), 0.f);\n    glVertex3f(r0 * (float) cos(angle), r0 * (float) sin(angle), -width * 0.5f);\n    glVertex3f(r0 * (float) cos(angle), r0 * (float) sin(angle), width * 0.5f);\n  }\n  glEnd();\n\n}", "path": "Craft/deps/glfw/examples/gears.c", "commit_date": "2016-02-03 00:00:00", "repo_name": "fogleman/Craft", "stars": 10133, "license": "mit", "language": "c", "size": 14666}
{"docstring": "// Returns a UTF-8 string version of the specified wide string\n//\n", "func_signal": "char* _glfwCreateUTF8FromWideString(const WCHAR* source)", "code": "{\n    char* target;\n    int length;\n\n    length = WideCharToMultiByte(CP_UTF8, 0, source, -1, NULL, 0, NULL, NULL);\n    if (!length)\n        return NULL;\n\n    target = calloc(length, sizeof(char));\n\n    if (!WideCharToMultiByte(CP_UTF8, 0, source, -1, target, length, NULL, NULL))\n    {\n        free(target);\n        return NULL;\n    }\n\n    return target;\n}", "path": "Craft/deps/glfw/src/win32_init.c", "commit_date": "2016-01-31 00:00:00", "repo_name": "fogleman/Craft", "stars": 10133, "license": "mit", "language": "c", "size": 14666}
{"docstring": "// Create key code translation tables\n//\n", "func_signal": "static void createKeyTables(void)", "code": "{\n    memset(_glfw.win32.publicKeys, -1, sizeof(_glfw.win32.publicKeys));\n\n    _glfw.win32.publicKeys[0x00B] = GLFW_KEY_0;\n    _glfw.win32.publicKeys[0x002] = GLFW_KEY_1;\n    _glfw.win32.publicKeys[0x003] = GLFW_KEY_2;\n    _glfw.win32.publicKeys[0x004] = GLFW_KEY_3;\n    _glfw.win32.publicKeys[0x005] = GLFW_KEY_4;\n    _glfw.win32.publicKeys[0x006] = GLFW_KEY_5;\n    _glfw.win32.publicKeys[0x007] = GLFW_KEY_6;\n    _glfw.win32.publicKeys[0x008] = GLFW_KEY_7;\n    _glfw.win32.publicKeys[0x009] = GLFW_KEY_8;\n    _glfw.win32.publicKeys[0x00A] = GLFW_KEY_9;\n    _glfw.win32.publicKeys[0x01E] = GLFW_KEY_A;\n    _glfw.win32.publicKeys[0x030] = GLFW_KEY_B;\n    _glfw.win32.publicKeys[0x02E] = GLFW_KEY_C;\n    _glfw.win32.publicKeys[0x020] = GLFW_KEY_D;\n    _glfw.win32.publicKeys[0x012] = GLFW_KEY_E;\n    _glfw.win32.publicKeys[0x021] = GLFW_KEY_F;\n    _glfw.win32.publicKeys[0x022] = GLFW_KEY_G;\n    _glfw.win32.publicKeys[0x023] = GLFW_KEY_H;\n    _glfw.win32.publicKeys[0x017] = GLFW_KEY_I;\n    _glfw.win32.publicKeys[0x024] = GLFW_KEY_J;\n    _glfw.win32.publicKeys[0x025] = GLFW_KEY_K;\n    _glfw.win32.publicKeys[0x026] = GLFW_KEY_L;\n    _glfw.win32.publicKeys[0x032] = GLFW_KEY_M;\n    _glfw.win32.publicKeys[0x031] = GLFW_KEY_N;\n    _glfw.win32.publicKeys[0x018] = GLFW_KEY_O;\n    _glfw.win32.publicKeys[0x019] = GLFW_KEY_P;\n    _glfw.win32.publicKeys[0x010] = GLFW_KEY_Q;\n    _glfw.win32.publicKeys[0x013] = GLFW_KEY_R;\n    _glfw.win32.publicKeys[0x01F] = GLFW_KEY_S;\n    _glfw.win32.publicKeys[0x014] = GLFW_KEY_T;\n    _glfw.win32.publicKeys[0x016] = GLFW_KEY_U;\n    _glfw.win32.publicKeys[0x02F] = GLFW_KEY_V;\n    _glfw.win32.publicKeys[0x011] = GLFW_KEY_W;\n    _glfw.win32.publicKeys[0x02D] = GLFW_KEY_X;\n    _glfw.win32.publicKeys[0x015] = GLFW_KEY_Y;\n    _glfw.win32.publicKeys[0x02C] = GLFW_KEY_Z;\n\n    _glfw.win32.publicKeys[0x028] = GLFW_KEY_APOSTROPHE;\n    _glfw.win32.publicKeys[0x02B] = GLFW_KEY_BACKSLASH;\n    _glfw.win32.publicKeys[0x033] = GLFW_KEY_COMMA;\n    _glfw.win32.publicKeys[0x00D] = GLFW_KEY_EQUAL;\n    _glfw.win32.publicKeys[0x029] = GLFW_KEY_GRAVE_ACCENT;\n    _glfw.win32.publicKeys[0x01A] = GLFW_KEY_LEFT_BRACKET;\n    _glfw.win32.publicKeys[0x00C] = GLFW_KEY_MINUS;\n    _glfw.win32.publicKeys[0x034] = GLFW_KEY_PERIOD;\n    _glfw.win32.publicKeys[0x01B] = GLFW_KEY_RIGHT_BRACKET;\n    _glfw.win32.publicKeys[0x027] = GLFW_KEY_SEMICOLON;\n    _glfw.win32.publicKeys[0x035] = GLFW_KEY_SLASH;\n    _glfw.win32.publicKeys[0x056] = GLFW_KEY_WORLD_2;\n\n    _glfw.win32.publicKeys[0x00E] = GLFW_KEY_BACKSPACE;\n    _glfw.win32.publicKeys[0x153] = GLFW_KEY_DELETE;\n    _glfw.win32.publicKeys[0x14F] = GLFW_KEY_END;\n    _glfw.win32.publicKeys[0x01C] = GLFW_KEY_ENTER;\n    _glfw.win32.publicKeys[0x001] = GLFW_KEY_ESCAPE;\n    _glfw.win32.publicKeys[0x147] = GLFW_KEY_HOME;\n    _glfw.win32.publicKeys[0x152] = GLFW_KEY_INSERT;\n    _glfw.win32.publicKeys[0x15D] = GLFW_KEY_MENU;\n    _glfw.win32.publicKeys[0x151] = GLFW_KEY_PAGE_DOWN;\n    _glfw.win32.publicKeys[0x149] = GLFW_KEY_PAGE_UP;\n    _glfw.win32.publicKeys[0x045] = GLFW_KEY_PAUSE;\n    _glfw.win32.publicKeys[0x039] = GLFW_KEY_SPACE;\n    _glfw.win32.publicKeys[0x00F] = GLFW_KEY_TAB;\n    _glfw.win32.publicKeys[0x03A] = GLFW_KEY_CAPS_LOCK;\n    _glfw.win32.publicKeys[0x145] = GLFW_KEY_NUM_LOCK;\n    _glfw.win32.publicKeys[0x046] = GLFW_KEY_SCROLL_LOCK;\n    _glfw.win32.publicKeys[0x03B] = GLFW_KEY_F1;\n    _glfw.win32.publicKeys[0x03C] = GLFW_KEY_F2;\n    _glfw.win32.publicKeys[0x03D] = GLFW_KEY_F3;\n    _glfw.win32.publicKeys[0x03E] = GLFW_KEY_F4;\n    _glfw.win32.publicKeys[0x03F] = GLFW_KEY_F5;\n    _glfw.win32.publicKeys[0x040] = GLFW_KEY_F6;\n    _glfw.win32.publicKeys[0x041] = GLFW_KEY_F7;\n    _glfw.win32.publicKeys[0x042] = GLFW_KEY_F8;\n    _glfw.win32.publicKeys[0x043] = GLFW_KEY_F9;\n    _glfw.win32.publicKeys[0x044] = GLFW_KEY_F10;\n    _glfw.win32.publicKeys[0x057] = GLFW_KEY_F11;\n    _glfw.win32.publicKeys[0x058] = GLFW_KEY_F12;\n    _glfw.win32.publicKeys[0x064] = GLFW_KEY_F13;\n    _glfw.win32.publicKeys[0x065] = GLFW_KEY_F14;\n    _glfw.win32.publicKeys[0x066] = GLFW_KEY_F15;\n    _glfw.win32.publicKeys[0x067] = GLFW_KEY_F16;\n    _glfw.win32.publicKeys[0x068] = GLFW_KEY_F17;\n    _glfw.win32.publicKeys[0x069] = GLFW_KEY_F18;\n    _glfw.win32.publicKeys[0x06A] = GLFW_KEY_F19;\n    _glfw.win32.publicKeys[0x06B] = GLFW_KEY_F20;\n    _glfw.win32.publicKeys[0x06C] = GLFW_KEY_F21;\n    _glfw.win32.publicKeys[0x06D] = GLFW_KEY_F22;\n    _glfw.win32.publicKeys[0x06E] = GLFW_KEY_F23;\n    _glfw.win32.publicKeys[0x076] = GLFW_KEY_F24;\n    _glfw.win32.publicKeys[0x038] = GLFW_KEY_LEFT_ALT;\n    _glfw.win32.publicKeys[0x01D] = GLFW_KEY_LEFT_CONTROL;\n    _glfw.win32.publicKeys[0x02A] = GLFW_KEY_LEFT_SHIFT;\n    _glfw.win32.publicKeys[0x15B] = GLFW_KEY_LEFT_SUPER;\n    _glfw.win32.publicKeys[0x137] = GLFW_KEY_PRINT_SCREEN;\n    _glfw.win32.publicKeys[0x138] = GLFW_KEY_RIGHT_ALT;\n    _glfw.win32.publicKeys[0x11D] = GLFW_KEY_RIGHT_CONTROL;\n    _glfw.win32.publicKeys[0x036] = GLFW_KEY_RIGHT_SHIFT;\n    _glfw.win32.publicKeys[0x15C] = GLFW_KEY_RIGHT_SUPER;\n    _glfw.win32.publicKeys[0x150] = GLFW_KEY_DOWN;\n    _glfw.win32.publicKeys[0x14B] = GLFW_KEY_LEFT;\n    _glfw.win32.publicKeys[0x14D] = GLFW_KEY_RIGHT;\n    _glfw.win32.publicKeys[0x148] = GLFW_KEY_UP;\n\n    _glfw.win32.publicKeys[0x052] = GLFW_KEY_KP_0;\n    _glfw.win32.publicKeys[0x04F] = GLFW_KEY_KP_1;\n    _glfw.win32.publicKeys[0x050] = GLFW_KEY_KP_2;\n    _glfw.win32.publicKeys[0x051] = GLFW_KEY_KP_3;\n    _glfw.win32.publicKeys[0x04B] = GLFW_KEY_KP_4;\n    _glfw.win32.publicKeys[0x04C] = GLFW_KEY_KP_5;\n    _glfw.win32.publicKeys[0x04D] = GLFW_KEY_KP_6;\n    _glfw.win32.publicKeys[0x047] = GLFW_KEY_KP_7;\n    _glfw.win32.publicKeys[0x048] = GLFW_KEY_KP_8;\n    _glfw.win32.publicKeys[0x049] = GLFW_KEY_KP_9;\n    _glfw.win32.publicKeys[0x04E] = GLFW_KEY_KP_ADD;\n    _glfw.win32.publicKeys[0x053] = GLFW_KEY_KP_DECIMAL;\n    _glfw.win32.publicKeys[0x135] = GLFW_KEY_KP_DIVIDE;\n    _glfw.win32.publicKeys[0x11C] = GLFW_KEY_KP_ENTER;\n    _glfw.win32.publicKeys[0x037] = GLFW_KEY_KP_MULTIPLY;\n    _glfw.win32.publicKeys[0x04A] = GLFW_KEY_KP_SUBTRACT;\n}", "path": "Craft/deps/glfw/src/win32_init.c", "commit_date": "2016-01-31 00:00:00", "repo_name": "fogleman/Craft", "stars": 10133, "license": "mit", "language": "c", "size": 14666}
{"docstring": "// Load necessary libraries (DLLs)\n//\n", "func_signal": "static GLboolean initLibraries(void)", "code": "{\n    _glfw.win32.winmm.instance = LoadLibraryW(L\"winmm.dll\");\n    if (!_glfw.win32.winmm.instance)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"Win32: Failed to load winmm.dll\");\n        return GL_FALSE;\n    }\n\n    _glfw.win32.winmm.joyGetDevCaps = (JOYGETDEVCAPS_T)\n        GetProcAddress(_glfw.win32.winmm.instance, \"joyGetDevCapsW\");\n    _glfw.win32.winmm.joyGetPos = (JOYGETPOS_T)\n        GetProcAddress(_glfw.win32.winmm.instance, \"joyGetPos\");\n    _glfw.win32.winmm.joyGetPosEx = (JOYGETPOSEX_T)\n        GetProcAddress(_glfw.win32.winmm.instance, \"joyGetPosEx\");\n    _glfw.win32.winmm.timeGetTime = (TIMEGETTIME_T)\n        GetProcAddress(_glfw.win32.winmm.instance, \"timeGetTime\");\n\n    if (!_glfw.win32.winmm.joyGetDevCaps ||\n        !_glfw.win32.winmm.joyGetPos ||\n        !_glfw.win32.winmm.joyGetPosEx ||\n        !_glfw.win32.winmm.timeGetTime)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"Win32: Failed to load winmm functions\");\n        return GL_FALSE;\n    }\n\n    _glfw.win32.user32.instance = LoadLibraryW(L\"user32.dll\");\n    if (_glfw.win32.user32.instance)\n    {\n        _glfw.win32.user32.SetProcessDPIAware = (SETPROCESSDPIAWARE_T)\n            GetProcAddress(_glfw.win32.user32.instance, \"SetProcessDPIAware\");\n        _glfw.win32.user32.ChangeWindowMessageFilterEx = (CHANGEWINDOWMESSAGEFILTEREX_T)\n            GetProcAddress(_glfw.win32.user32.instance, \"ChangeWindowMessageFilterEx\");\n    }\n\n    _glfw.win32.dwmapi.instance = LoadLibraryW(L\"dwmapi.dll\");\n    if (_glfw.win32.dwmapi.instance)\n    {\n        _glfw.win32.dwmapi.DwmIsCompositionEnabled = (DWMISCOMPOSITIONENABLED_T)\n            GetProcAddress(_glfw.win32.dwmapi.instance, \"DwmIsCompositionEnabled\");\n        _glfw.win32.dwmapi.DwmFlush = (DWMFLUSH_T)\n            GetProcAddress(_glfw.win32.dwmapi.instance, \"DwmFlush\");\n    }\n\n    return GL_TRUE;\n}", "path": "Craft/deps/glfw/src/win32_init.c", "commit_date": "2016-01-31 00:00:00", "repo_name": "fogleman/Craft", "stars": 10133, "license": "mit", "language": "c", "size": 14666}
{"docstring": "// TODO The mir_event_ref is not supposed to be used but ... its needed\n//      in this case. Need to wait until we can read from an FD set up by mir\n//      for single threaded event handling.\n", "func_signal": "static EventNode* newEventNode(const MirEvent* event, _GLFWwindow* context)", "code": "{\n    EventNode* new_node = calloc(1, sizeof(EventNode));\n    new_node->event     = mir_event_ref(event);\n    new_node->window    = context;\n\n    return new_node;\n}", "path": "Craft/deps/glfw/src/mir_window.c", "commit_date": "2016-01-31 00:00:00", "repo_name": "fogleman/Craft", "stars": 10133, "license": "mit", "language": "c", "size": 14666}
{"docstring": "// Returns a wide string version of the specified UTF-8 string\n//\n", "func_signal": "WCHAR* _glfwCreateWideStringFromUTF8(const char* source)", "code": "{\n    WCHAR* target;\n    int length;\n\n    length = MultiByteToWideChar(CP_UTF8, 0, source, -1, NULL, 0);\n    if (!length)\n        return NULL;\n\n    target = calloc(length, sizeof(WCHAR));\n\n    if (!MultiByteToWideChar(CP_UTF8, 0, source, -1, target, length))\n    {\n        free(target);\n        return NULL;\n    }\n\n    return target;\n}", "path": "Craft/deps/glfw/src/win32_init.c", "commit_date": "2016-01-31 00:00:00", "repo_name": "fogleman/Craft", "stars": 10133, "license": "mit", "language": "c", "size": 14666}
{"docstring": "/* program entry */\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n    GLFWwindow* window;\n    int width, height;\n\n    if( !glfwInit() )\n    {\n        fprintf( stderr, \"Failed to initialize GLFW\\n\" );\n        exit( EXIT_FAILURE );\n    }\n\n    glfwWindowHint(GLFW_DEPTH_BITS, 16);\n\n    window = glfwCreateWindow( 300, 300, \"Gears\", NULL, NULL );\n    if (!window)\n    {\n        fprintf( stderr, \"Failed to open GLFW window\\n\" );\n        glfwTerminate();\n        exit( EXIT_FAILURE );\n    }\n\n    // Set callback functions\n    glfwSetFramebufferSizeCallback(window, reshape);\n    glfwSetKeyCallback(window, key);\n\n    glfwMakeContextCurrent(window);\n    glfwSwapInterval( 1 );\n\n    glfwGetFramebufferSize(window, &width, &height);\n    reshape(window, width, height);\n\n    // Parse command-line options\n    init();\n\n    // Main loop\n    while( !glfwWindowShouldClose(window) )\n    {\n        // Draw gears\n        draw();\n\n        // Update animation\n        animate();\n\n        // Swap buffers\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n    }\n\n    // Terminate GLFW\n    glfwTerminate();\n\n    // Exit program\n    exit( EXIT_SUCCESS );\n}", "path": "Craft/deps/glfw/examples/gears.c", "commit_date": "2016-02-03 00:00:00", "repo_name": "fogleman/Craft", "stars": 10133, "license": "mit", "language": "c", "size": 14666}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n", "func_signal": "double _glfwPlatformGetTime(void)", "code": "{\n    return (double) (getRawTime() - _glfw.win32_time.base) *\n        _glfw.win32_time.resolution;\n}", "path": "Craft/deps/glfw/src/win32_time.c", "commit_date": "2016-01-31 00:00:00", "repo_name": "fogleman/Craft", "stars": 10133, "license": "mit", "language": "c", "size": 14666}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n", "func_signal": "int _glfwPlatformInit(void)", "code": "{\n    // To make SetForegroundWindow work as we want, we need to fiddle\n    // with the FOREGROUNDLOCKTIMEOUT system setting (we do this as early\n    // as possible in the hope of still being the foreground process)\n    SystemParametersInfoW(SPI_GETFOREGROUNDLOCKTIMEOUT, 0,\n                          &_glfw.win32.foregroundLockTimeout, 0);\n    SystemParametersInfoW(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, UIntToPtr(0),\n                          SPIF_SENDCHANGE);\n\n    if (!initLibraries())\n        return GL_FALSE;\n\n    createKeyTables();\n\n    if (_glfw_SetProcessDPIAware)\n        _glfw_SetProcessDPIAware();\n\n    if (!_glfwRegisterWindowClass())\n        return GL_FALSE;\n\n    if (!_glfwInitContextAPI())\n        return GL_FALSE;\n\n    _glfwInitTimer();\n    _glfwInitJoysticks();\n\n    return GL_TRUE;\n}", "path": "Craft/deps/glfw/src/win32_init.c", "commit_date": "2016-01-31 00:00:00", "repo_name": "fogleman/Craft", "stars": 10133, "license": "mit", "language": "c", "size": 14666}
{"docstring": "// Taken from wl_init.c\n", "func_signal": "static int toGLFWKeyCode(uint32_t key)", "code": "{\n    switch (key)\n    {\n        case KEY_GRAVE:         return GLFW_KEY_GRAVE_ACCENT;\n        case KEY_1:             return GLFW_KEY_1;\n        case KEY_2:             return GLFW_KEY_2;\n        case KEY_3:             return GLFW_KEY_3;\n        case KEY_4:             return GLFW_KEY_4;\n        case KEY_5:             return GLFW_KEY_5;\n        case KEY_6:             return GLFW_KEY_6;\n        case KEY_7:             return GLFW_KEY_7;\n        case KEY_8:             return GLFW_KEY_8;\n        case KEY_9:             return GLFW_KEY_9;\n        case KEY_0:             return GLFW_KEY_0;\n        case KEY_MINUS:         return GLFW_KEY_MINUS;\n        case KEY_EQUAL:         return GLFW_KEY_EQUAL;\n        case KEY_Q:             return GLFW_KEY_Q;\n        case KEY_W:             return GLFW_KEY_W;\n        case KEY_E:             return GLFW_KEY_E;\n        case KEY_R:             return GLFW_KEY_R;\n        case KEY_T:             return GLFW_KEY_T;\n        case KEY_Y:             return GLFW_KEY_Y;\n        case KEY_U:             return GLFW_KEY_U;\n        case KEY_I:             return GLFW_KEY_I;\n        case KEY_O:             return GLFW_KEY_O;\n        case KEY_P:             return GLFW_KEY_P;\n        case KEY_LEFTBRACE:     return GLFW_KEY_LEFT_BRACKET;\n        case KEY_RIGHTBRACE:    return GLFW_KEY_RIGHT_BRACKET;\n        case KEY_A:             return GLFW_KEY_A;\n        case KEY_S:             return GLFW_KEY_S;\n        case KEY_D:             return GLFW_KEY_D;\n        case KEY_F:             return GLFW_KEY_F;\n        case KEY_G:             return GLFW_KEY_G;\n        case KEY_H:             return GLFW_KEY_H;\n        case KEY_J:             return GLFW_KEY_J;\n        case KEY_K:             return GLFW_KEY_K;\n        case KEY_L:             return GLFW_KEY_L;\n        case KEY_SEMICOLON:     return GLFW_KEY_SEMICOLON;\n        case KEY_APOSTROPHE:    return GLFW_KEY_APOSTROPHE;\n        case KEY_Z:             return GLFW_KEY_Z;\n        case KEY_X:             return GLFW_KEY_X;\n        case KEY_C:             return GLFW_KEY_C;\n        case KEY_V:             return GLFW_KEY_V;\n        case KEY_B:             return GLFW_KEY_B;\n        case KEY_N:             return GLFW_KEY_N;\n        case KEY_M:             return GLFW_KEY_M;\n        case KEY_COMMA:         return GLFW_KEY_COMMA;\n        case KEY_DOT:           return GLFW_KEY_PERIOD;\n        case KEY_SLASH:         return GLFW_KEY_SLASH;\n        case KEY_BACKSLASH:     return GLFW_KEY_BACKSLASH;\n        case KEY_ESC:           return GLFW_KEY_ESCAPE;\n        case KEY_TAB:           return GLFW_KEY_TAB;\n        case KEY_LEFTSHIFT:     return GLFW_KEY_LEFT_SHIFT;\n        case KEY_RIGHTSHIFT:    return GLFW_KEY_RIGHT_SHIFT;\n        case KEY_LEFTCTRL:      return GLFW_KEY_LEFT_CONTROL;\n        case KEY_RIGHTCTRL:     return GLFW_KEY_RIGHT_CONTROL;\n        case KEY_LEFTALT:       return GLFW_KEY_LEFT_ALT;\n        case KEY_RIGHTALT:      return GLFW_KEY_RIGHT_ALT;\n        case KEY_LEFTMETA:      return GLFW_KEY_LEFT_SUPER;\n        case KEY_RIGHTMETA:     return GLFW_KEY_RIGHT_SUPER;\n        case KEY_MENU:          return GLFW_KEY_MENU;\n        case KEY_NUMLOCK:       return GLFW_KEY_NUM_LOCK;\n        case KEY_CAPSLOCK:      return GLFW_KEY_CAPS_LOCK;\n        case KEY_PRINT:         return GLFW_KEY_PRINT_SCREEN;\n        case KEY_SCROLLLOCK:    return GLFW_KEY_SCROLL_LOCK;\n        case KEY_PAUSE:         return GLFW_KEY_PAUSE;\n        case KEY_DELETE:        return GLFW_KEY_DELETE;\n        case KEY_BACKSPACE:     return GLFW_KEY_BACKSPACE;\n        case KEY_ENTER:         return GLFW_KEY_ENTER;\n        case KEY_HOME:          return GLFW_KEY_HOME;\n        case KEY_END:           return GLFW_KEY_END;\n        case KEY_PAGEUP:        return GLFW_KEY_PAGE_UP;\n        case KEY_PAGEDOWN:      return GLFW_KEY_PAGE_DOWN;\n        case KEY_INSERT:        return GLFW_KEY_INSERT;\n        case KEY_LEFT:          return GLFW_KEY_LEFT;\n        case KEY_RIGHT:         return GLFW_KEY_RIGHT;\n        case KEY_DOWN:          return GLFW_KEY_DOWN;\n        case KEY_UP:            return GLFW_KEY_UP;\n        case KEY_F1:            return GLFW_KEY_F1;\n        case KEY_F2:            return GLFW_KEY_F2;\n        case KEY_F3:            return GLFW_KEY_F3;\n        case KEY_F4:            return GLFW_KEY_F4;\n        case KEY_F5:            return GLFW_KEY_F5;\n        case KEY_F6:            return GLFW_KEY_F6;\n        case KEY_F7:            return GLFW_KEY_F7;\n        case KEY_F8:            return GLFW_KEY_F8;\n        case KEY_F9:            return GLFW_KEY_F9;\n        case KEY_F10:           return GLFW_KEY_F10;\n        case KEY_F11:           return GLFW_KEY_F11;\n        case KEY_F12:           return GLFW_KEY_F12;\n        case KEY_F13:           return GLFW_KEY_F13;\n        case KEY_F14:           return GLFW_KEY_F14;\n        case KEY_F15:           return GLFW_KEY_F15;\n        case KEY_F16:           return GLFW_KEY_F16;\n        case KEY_F17:           return GLFW_KEY_F17;\n        case KEY_F18:           return GLFW_KEY_F18;\n        case KEY_F19:           return GLFW_KEY_F19;\n        case KEY_F20:           return GLFW_KEY_F20;\n        case KEY_F21:           return GLFW_KEY_F21;\n        case KEY_F22:           return GLFW_KEY_F22;\n        case KEY_F23:           return GLFW_KEY_F23;\n        case KEY_F24:           return GLFW_KEY_F24;\n        case KEY_KPSLASH:       return GLFW_KEY_KP_DIVIDE;\n        case KEY_KPDOT:         return GLFW_KEY_KP_MULTIPLY;\n        case KEY_KPMINUS:       return GLFW_KEY_KP_SUBTRACT;\n        case KEY_KPPLUS:        return GLFW_KEY_KP_ADD;\n        case KEY_KP0:           return GLFW_KEY_KP_0;\n        case KEY_KP1:           return GLFW_KEY_KP_1;\n        case KEY_KP2:           return GLFW_KEY_KP_2;\n        case KEY_KP3:           return GLFW_KEY_KP_3;\n        case KEY_KP4:           return GLFW_KEY_KP_4;\n        case KEY_KP5:           return GLFW_KEY_KP_5;\n        case KEY_KP6:           return GLFW_KEY_KP_6;\n        case KEY_KP7:           return GLFW_KEY_KP_7;\n        case KEY_KP8:           return GLFW_KEY_KP_8;\n        case KEY_KP9:           return GLFW_KEY_KP_9;\n        case KEY_KPCOMMA:       return GLFW_KEY_KP_DECIMAL;\n        case KEY_KPEQUAL:       return GLFW_KEY_KP_EQUAL;\n        case KEY_KPENTER:       return GLFW_KEY_KP_ENTER;\n        default:                return GLFW_KEY_UNKNOWN;\n    }\n}", "path": "Craft/deps/glfw/src/mir_window.c", "commit_date": "2016-01-31 00:00:00", "repo_name": "fogleman/Craft", "stars": 10133, "license": "mit", "language": "c", "size": 14666}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n", "func_signal": "int _glfwCreateContextTLS(void)", "code": "{\n    _glfw.win32_tls.context = TlsAlloc();\n    if (_glfw.win32_tls.context == TLS_OUT_OF_INDEXES)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"Win32: Failed to allocate TLS index\");\n        return GL_FALSE;\n    }\n\n    _glfw.win32_tls.allocated = GL_TRUE;\n    return GL_TRUE;\n}", "path": "Craft/deps/glfw/src/win32_tls.c", "commit_date": "2016-01-31 00:00:00", "repo_name": "fogleman/Craft", "stars": 10133, "license": "mit", "language": "c", "size": 14666}
{"docstring": "// Initialise timer\n//\n", "func_signal": "void _glfwInitTimer(void)", "code": "{\n    unsigned __int64 frequency;\n\n    if (QueryPerformanceFrequency((LARGE_INTEGER*) &frequency))\n    {\n        _glfw.win32_time.hasPC = GL_TRUE;\n        _glfw.win32_time.resolution = 1.0 / (double) frequency;\n    }\n    else\n    {\n        _glfw.win32_time.hasPC = GL_FALSE;\n        _glfw.win32_time.resolution = 0.001; // winmm resolution is 1 ms\n    }\n\n    _glfw.win32_time.base = getRawTime();\n}", "path": "Craft/deps/glfw/src/win32_time.c", "commit_date": "2016-01-31 00:00:00", "repo_name": "fogleman/Craft", "stars": 10133, "license": "mit", "language": "c", "size": 14666}
{"docstring": "/* change view angle, exit upon ESC */\n", "func_signal": "void key( GLFWwindow* window, int k, int s, int action, int mods )", "code": "{\n  if( action != GLFW_PRESS ) return;\n\n  switch (k) {\n  case GLFW_KEY_Z:\n    if( mods & GLFW_MOD_SHIFT )\n      view_rotz -= 5.0;\n    else\n      view_rotz += 5.0;\n    break;\n  case GLFW_KEY_ESCAPE:\n    glfwSetWindowShouldClose(window, GL_TRUE);\n    break;\n  case GLFW_KEY_UP:\n    view_rotx += 5.0;\n    break;\n  case GLFW_KEY_DOWN:\n    view_rotx -= 5.0;\n    break;\n  case GLFW_KEY_LEFT:\n    view_roty += 5.0;\n    break;\n  case GLFW_KEY_RIGHT:\n    view_roty -= 5.0;\n    break;\n  default:\n    return;\n  }\n}", "path": "Craft/deps/glfw/examples/gears.c", "commit_date": "2016-02-03 00:00:00", "repo_name": "fogleman/Craft", "stars": 10133, "license": "mit", "language": "c", "size": 14666}
{"docstring": "// Convert the Tick value to time\n", "func_signal": "UINT64 Tick64ToTime64(UINT64 tick)", "code": "{\n\tUINT64 ret = 0;\n\tif (tick == 0)\n\t{\n\t\treturn 0;\n\t}\n\tLockList(tk64->AdjustTime);\n\t{\n\t\tINT i;\n\t\tfor (i = ((INT)LIST_NUM(tk64->AdjustTime) - 1); i >= 0; i--)\n\t\t{\n\t\t\tADJUST_TIME *t = LIST_DATA(tk64->AdjustTime, i);\n\t\t\tif (t->Tick <= tick)\n\t\t\t{\n\t\t\t\tret = t->Time + (tick - t->Tick);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tUnlockList(tk64->AdjustTime);\n\tif (ret == 0)\n\t{\n\t\tret++;\n\t}\n\treturn ret;\n}", "path": "SoftEtherVPN/src/Mayaqua/Tick64.c", "commit_date": "2019-01-14 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN", "stars": 10925, "license": "apache-2.0", "language": "c", "size": 540898}
{"docstring": "// Search the EtherIP key\n", "func_signal": "bool SearchEtherIPId(IPSEC_SERVER *s, ETHERIP_ID *id, char *id_str)", "code": "{\n\tbool ret = false;\n\t// Validate arguments\n\tif (s == NULL || id == NULL || id_str == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\tLock(s->LockSettings);\n\t{\n\t\tETHERIP_ID t, *k;\n\n\t\tZero(&t, sizeof(t));\n\n\t\tStrCpy(t.Id, sizeof(t.Id), id_str);\n\n\t\tk = Search(s->EtherIPIdList, &t);\n\n\t\tif (k != NULL)\n\t\t{\n\t\t\tCopy(id, k, sizeof(ETHERIP_ID));\n\n\t\t\tret = true;\n\t\t}\n\t}\n\tUnlock(s->LockSettings);\n\n\treturn ret;\n}", "path": "SoftEtherVPN/src/Cedar/Proto_IPsec.c", "commit_date": "2019-01-21 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN", "stars": 10925, "license": "apache-2.0", "language": "c", "size": 540898}
{"docstring": "// Delete the EtherIP key\n", "func_signal": "bool DeleteEtherIPId(IPSEC_SERVER *s, char *id_str)", "code": "{\n\tbool ret = false;\n\t// Validate arguments\n\tif (s == NULL || id_str == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\tLock(s->LockSettings);\n\t{\n\t\t// If there is the same key, remove them\n\t\tETHERIP_ID t, *k;\n\n\t\tZero(&t, sizeof(t));\n\n\t\tStrCpy(t.Id, sizeof(t.Id), id_str);\n\n\t\tk = Search(s->EtherIPIdList, &t);\n\n\t\tif (k != NULL)\n\t\t{\n\t\t\tDelete(s->EtherIPIdList, k);\n\n\t\t\tFree(k);\n\n\t\t\tret = true;\n\n\t\t\ts->EtherIPIdListSettingVerNo++;\n\t\t}\n\t}\n\tUnlock(s->LockSettings);\n\n\treturn ret;\n}", "path": "SoftEtherVPN/src/Cedar/Proto_IPsec.c", "commit_date": "2019-01-21 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN", "stars": 10925, "license": "apache-2.0", "language": "c", "size": 540898}
{"docstring": "// Set the service list\n", "func_signal": "void IPsecServerSetServices(IPSEC_SERVER *s, IPSEC_SERVICES *sl)", "code": "{\n\t// Validate arguments\n\tif (s == NULL || sl == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tif (IsZero(sl, sizeof(IPSEC_SERVICES)) == false)\n\t{\n\t\tif (s->NoMoreChangeSettings)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t}\n\n\tLock(s->LockSettings);\n\t{\n\t\tCopy(&s->Services, sl, sizeof(IPSEC_SERVICES));\n\n\t\tCopy(&s->UdpListener->ListenIP, &s->Cedar->Server->ListenIP, sizeof(IP));\n\n\t\tif (sl->L2TP_Raw)\n\t\t{\n\t\t\tAddPortToUdpListener(s->UdpListener, IPSEC_PORT_L2TP);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDeletePortFromUdpListener(s->UdpListener, IPSEC_PORT_L2TP);\n\t\t}\n\n\t\tif (sl->L2TP_IPsec || sl->EtherIP_IPsec)\n\t\t{\n\t\t\tAddPortToUdpListener(s->UdpListener, IPSEC_PORT_IPSEC_ISAKMP);\n\t\t\tAddPortToUdpListener(s->UdpListener, IPSEC_PORT_IPSEC_ESP_UDP);\n\t\t\tAddPortToUdpListener(s->UdpListener, IPSEC_PORT_IPSEC_ESP_RAW);\n\t\t\tAddPortToUdpListener(s->UdpListener, IPSEC_PORT_IPSEC_ESP_RAW_WPF);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDeletePortFromUdpListener(s->UdpListener, IPSEC_PORT_IPSEC_ISAKMP);\n\t\t\tDeletePortFromUdpListener(s->UdpListener, IPSEC_PORT_IPSEC_ESP_UDP);\n\t\t\tDeletePortFromUdpListener(s->UdpListener, IPSEC_PORT_IPSEC_ESP_RAW);\n\t\t\tDeletePortFromUdpListener(s->UdpListener, IPSEC_PORT_IPSEC_ESP_RAW_WPF);\n\t\t}\n\n\t\tif (IsEmptyStr(sl->IPsec_Secret) == false)\n\t\t{\n\t\t\tStrCpy(s->Ike->Secret, sizeof(s->Ike->Secret), sl->IPsec_Secret);\n\t\t}\n\n\t\tIPsecNormalizeServiceSetting(s);\n\t}\n\tUnlock(s->LockSettings);\n\n\tSet(s->OsServiceCheckThreadEvent);\n}", "path": "SoftEtherVPN/src/Cedar/Proto_IPsec.c", "commit_date": "2019-01-21 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN", "stars": 10925, "license": "apache-2.0", "language": "c", "size": 540898}
{"docstring": "// Initialize the IPsec server\n", "func_signal": "IPSEC_SERVER *NewIPsecServer(CEDAR *cedar)", "code": "{\n\tIPSEC_SERVER *s;\n\t// Validate arguments\n\tif (cedar == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\n\ts = ZeroMalloc(sizeof(IPSEC_SERVER));\n\n\ts->LockSettings = NewLock();\n\n\ts->Cedar = cedar;\n\n\tAddRef(s->Cedar->ref);\n\n\ts->L2TP = NewL2TPServer(cedar);\n\n\ts->Ike = NewIKEServer(cedar, s);\n\tStrCpy(s->Ike->Secret, sizeof(s->Ike->Secret), IPSEC_DEFAULT_SECRET);\n\n\ts->UdpListener = NewUdpListener(IPsecServerUdpPacketRecvProc, s, &cedar->Server->ListenIP);\n\n\ts->EtherIPIdList = NewList(CmpEtherIPId);\n\n\t// Start an OS service monitoring thread\n\ts->OsServiceCheckThreadEvent = NewEvent();\n\ts->OsServiceCheckThread = NewThread(IPsecOsServiceCheckThread, s);\n\n\treturn s;\n}", "path": "SoftEtherVPN/src/Cedar/Proto_IPsec.c", "commit_date": "2019-01-21 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN", "stars": 10925, "license": "apache-2.0", "language": "c", "size": 540898}
{"docstring": "// Release of the Tick64\n", "func_signal": "void FreeTick64()", "code": "{\n\tUINT i;\n\tif (tk64 == NULL)\n\t{\n\t\t// Uninitialized\n\t\treturn;\n\t}\n\n\t// Termination process\n\ttk64->Halt = true;\n\tSet(halt_tick_event);\n\tWaitThread(tk64->Thread, INFINITE);\n\tReleaseThread(tk64->Thread);\n\n\t// Releasing process\n\tfor (i = 0;i < LIST_NUM(tk64->AdjustTime);i++)\n\t{\n\t\tADJUST_TIME *t = LIST_DATA(tk64->AdjustTime, i);\n\t\tFree(t);\n\t}\n\tReleaseList(tk64->AdjustTime);\n\tDeleteLock(tk64->TickLock);\n\tFree(tk64);\n\ttk64 = NULL;\n\n\tReleaseEvent(halt_tick_event);\n\thalt_tick_event = NULL;\n}", "path": "SoftEtherVPN/src/Mayaqua/Tick64.c", "commit_date": "2019-01-14 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN", "stars": 10925, "license": "apache-2.0", "language": "c", "size": 540898}
{"docstring": "// Release and stop the IPsec server\n", "func_signal": "void FreeIPsecServer(IPSEC_SERVER *s)", "code": "{\n\tUINT i;\n\tIPSEC_SERVICES sl;\n\t// Validate arguments\n\tif (s == NULL)\n\t{\n\t\treturn;\n\t}\n\n\ts->NoMoreChangeSettings = true;\n\n\t// Stopp the L2TP server\n\tStopL2TPServer(s->L2TP, false);\n\n\t// Stop the IKE server\n\tStopIKEServer(s->Ike);\n\n\t// Stop all the services explicitly\n\tZero(&sl, sizeof(sl));\n\tIPsecServerSetServices(s, &sl);\n\n\t// Releasing process\n\tFreeUdpListener(s->UdpListener);\n\n\tReleaseCedar(s->Cedar);\n\n\tFreeL2TPServer(s->L2TP);\n\n\tFreeIKEServer(s->Ike);\n\n\tfor (i = 0;i < LIST_NUM(s->EtherIPIdList);i++)\n\t{\n\t\tETHERIP_ID *k = LIST_DATA(s->EtherIPIdList, i);\n\n\t\tFree(k);\n\t}\n\n\tReleaseList(s->EtherIPIdList);\n\n\t// Stop the OS monitoring thread\n\ts->Halt = true;\n\tSet(s->OsServiceCheckThreadEvent);\n\tWaitThread(s->OsServiceCheckThread, INFINITE);\n\tReleaseThread(s->OsServiceCheckThread);\n\tReleaseEvent(s->OsServiceCheckThreadEvent);\n\n\tDeleteLock(s->LockSettings);\n\n\tFree(s);\n}", "path": "SoftEtherVPN/src/Cedar/Proto_IPsec.c", "commit_date": "2019-01-21 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN", "stars": 10925, "license": "apache-2.0", "language": "c", "size": 540898}
{"docstring": "// Get the Tick value\n", "func_signal": "UINT64 Tick64()", "code": "{\n#ifdef\tOS_WIN32\n\treturn Win32FastTick64();\n#else\t// OS_WIN32\n\tUINT64 tick64;\n\tif (tk64 == NULL)\n\t{\n\t\treturn 0;\n\t}\n\tLock(tk64->TickLock);\n\t{\n\t\ttick64 = tk64->Tick;\n\t}\n\tUnlock(tk64->TickLock);\n\treturn tick64;\n#endif\t// OS_WIN32\n}", "path": "SoftEtherVPN/src/Mayaqua/Tick64.c", "commit_date": "2019-01-14 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN", "stars": 10925, "license": "apache-2.0", "language": "c", "size": 540898}
{"docstring": "// Add the EtherIP key\n", "func_signal": "void AddEtherIPId(IPSEC_SERVER *s, ETHERIP_ID *id)", "code": "{\n\t// Validate arguments\n\tif (s == NULL || id == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tLock(s->LockSettings);\n\t{\n\t\t// If there is the same key, remove them\n\t\tETHERIP_ID t, *k;\n\n\t\tZero(&t, sizeof(t));\n\n\t\tStrCpy(t.Id, sizeof(t.Id), id->Id);\n\n\t\tk = Search(s->EtherIPIdList, &t);\n\n\t\tif (k != NULL)\n\t\t{\n\t\t\tDelete(s->EtherIPIdList, k);\n\n\t\t\tFree(k);\n\t\t}\n\n\t\t// Add\n\t\tk = Clone(id, sizeof(ETHERIP_ID));\n\n\t\tInsert(s->EtherIPIdList, k);\n\n\t\ts->EtherIPIdListSettingVerNo++;\n\t}\n\tUnlock(s->LockSettings);\n}", "path": "SoftEtherVPN/src/Cedar/Proto_IPsec.c", "commit_date": "2019-01-21 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN", "stars": 10925, "license": "apache-2.0", "language": "c", "size": 540898}
{"docstring": "// Comparison of key EtherIP list entries\n", "func_signal": "int CmpEtherIPId(void *p1, void *p2)", "code": "{\n\tETHERIP_ID *k1, *k2;\n\t// Validate arguments\n\tif (p1 == NULL || p2 == NULL)\n\t{\n\t\treturn 0;\n\t}\n\tk1 = *(ETHERIP_ID **)p1;\n\tk2 = *(ETHERIP_ID **)p2;\n\tif (k1 == NULL || k2 == NULL)\n\t{\n\t\treturn 0;\n\t}\n\n\treturn StrCmpi(k1->Id, k2->Id);\n}", "path": "SoftEtherVPN/src/Cedar/Proto_IPsec.c", "commit_date": "2019-01-21 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN", "stars": 10925, "license": "apache-2.0", "language": "c", "size": 540898}
{"docstring": "// Normalize the IPsec service setttings\n", "func_signal": "void IPsecNormalizeServiceSetting(IPSEC_SERVER *s)", "code": "{\n\tCEDAR *c;\n\t// Validate arguments\n\tif (s == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tc = s->Cedar;\n\n\tLock(s->LockSettings);\n\t{\n\t\tbool reset_hub_setting = false;\n\n\t\tif (IsEmptyStr(s->Services.IPsec_Secret))\n\t\t{\n\t\t\t// If the secret is not set, set the default one\n\t\t\tStrCpy(s->Services.IPsec_Secret, sizeof(s->Services.IPsec_Secret), IPSEC_DEFAULT_SECRET);\n\t\t}\n\n\t\tLockList(c->HubList);\n\t\t{\n\t\t\tif (IsEmptyStr(s->Services.L2TP_DefaultHub))\n\t\t\t{\n\t\t\t\treset_hub_setting = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (IsHub(c, s->Services.L2TP_DefaultHub) == false)\n\t\t\t\t{\n\t\t\t\t\treset_hub_setting = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (reset_hub_setting)\n\t\t\t{\n\t\t\t\t// Select the first Virtual HUB if there is no HUB\n\t\t\t\tHUB *h = NULL;\n\t\t\t\t\n\t\t\t\tif (LIST_NUM(c->HubList) >= 1)\n\t\t\t\t{\n\t\t\t\t\th = LIST_DATA(c->HubList, 0);\n\t\t\t\t}\n\n\t\t\t\tif (h != NULL)\n\t\t\t\t{\n\t\t\t\t\tStrCpy(s->Services.L2TP_DefaultHub, sizeof(s->Services.L2TP_DefaultHub), h->Name);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tStrCpy(s->Services.L2TP_DefaultHub, sizeof(s->Services.L2TP_DefaultHub), \"\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tUnlockList(c->HubList);\n\t}\n\tUnlock(s->LockSettings);\n}", "path": "SoftEtherVPN/src/Cedar/Proto_IPsec.c", "commit_date": "2019-01-21 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN", "stars": 10925, "license": "apache-2.0", "language": "c", "size": 540898}
{"docstring": "// Monitoring process main\n", "func_signal": "bool IPsecCheckOsService(IPSEC_SERVER *s)", "code": "{\n\tbool b_ipsec;\n\tIPSEC_SERVICES sl;\n\tbool ret = false;\n\t// Validate arguments\n\tif (s == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\tIPsecServerGetServices(s, &sl);\n\n\tb_ipsec = (sl.EtherIP_IPsec || sl.L2TP_IPsec);\n\n\tif (b_ipsec != s->Check_LastEnabledStatus)\n\t{\n\t\ts->Check_LastEnabledStatus = b_ipsec;\n\n\t\tif (b_ipsec)\n\t\t{\n\t\t\t// Use of IPsec has been started\n#ifdef\tOS_WIN32\n\t\t\tif (s->Win7 == NULL)\n\t\t\t{\n\t\t\t\ts->Win7 = IPsecWin7Init();\n\t\t\t\ts->HostIPAddressListChanged = true;\n\t\t\t}\n\n\t\t\ts->OsServiceStoped = false;\n#else\t// OS_WIN32\n#endif\t// OS_WIN32\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Use of IPsec is stopped\n#ifdef\tOS_WIN32\n\t\t\tif (s->Win7 != NULL)\n\t\t\t{\n\t\t\t\tIPsecWin7Free(s->Win7);\n\t\t\t\ts->Win7 = NULL;\n\t\t\t}\n\n\t\t\tif (s->OsServiceStoped)\n\t\t\t{\n\t\t\t\tMsStartIPsecService();\n\t\t\t\ts->OsServiceStoped = false;\n\t\t\t}\n#else\t// OS_WIN32\n\t\t\tUnixSetEnableKernelEspProcessing(true);\n#endif\t// OS_WIN32\n\t\t}\n\t}\n\n\tif (b_ipsec)\n\t{\n#ifdef\tOS_WIN32\n\t\tif (MsStopIPsecService())\n\t\t{\n\t\t\ts->OsServiceStoped = true;\n\t\t\tret = true;\n\t\t}\n#else\t// OS_WIN32\n\t\tUnixSetEnableKernelEspProcessing(false);\n#endif\t// OS_WIN32\n\t}\n\n#ifdef\tOS_WIN32\n\tif (s->Win7 != NULL)\n\t{\n\t\tIPsecWin7UpdateHostIPAddressList(s->Win7);\n\t\ts->HostIPAddressListChanged = false;\n\t}\n#endif\t// OS_WIN32\n\n\treturn ret;\n}", "path": "SoftEtherVPN/src/Cedar/Proto_IPsec.c", "commit_date": "2019-01-21 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN", "stars": 10925, "license": "apache-2.0", "language": "c", "size": 540898}
{"docstring": "// Real-time clock measuring thread\n", "func_signal": "void Tick64Thread(THREAD *thread, void *param)", "code": "{\n\tUINT n = 0;\n\tbool first = false;\n\tbool create_first_entry = true;\n\tUINT tick_span;\n\t// Validate arguments\n\tif (thread == NULL)\n\t{\n\t\treturn;\n\t}\n\n#ifdef\tOS_WIN32\n\n\t// Raise the priority of the Win32 thread\n\tMsSetThreadPriorityRealtime();\n\n\ttick_span = TICK64_SPAN_WIN32;\n\n#else\t// OS_WIN32\n\n\t// Raise the priority of a POSIX threads\n\tUnixSetThreadPriorityRealtime();\n\n\ttick_span = TICK64_SPAN;\n\n#endif\t// OS_WIN32\n\n\twhile (true)\n\t{\n\t\tUINT tick;\n\t\tUINT64 tick64;\n\n#ifndef\tOS_WIN32\n\t\ttick = TickRealtime();\t\t// Get the current system clock\n\n\t\tif (tk64->LastTick > tick)\n\t\t{\n\t\t\tif ((tk64->LastTick - tick) >= (UINT64)0x0fffffff)\n\t\t\t{\n\t\t\t\t// The Tick has gone lap around\n\t\t\t\ttk64->RoundCount++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// tick skewed (System administrator might change hardware clock)\n\t\t\t\t// Normally, the clock skew appears as sub-seconds error\n\t\t\t\ttick = tk64->LastTick;\n\t\t\t}\n\t\t}\n\t\ttk64->LastTick = tick;\n\n\t\ttick64 = (UINT64)tk64->RoundCount * (UINT64)4294967296LL + (UINT64)tick;\n\n\t\tLock(tk64->TickLock);\n\t\t{\n\t\t\tif (tk64->TickStart == 0)\n\t\t\t{\n\t\t\t\ttk64->TickStart = tick64;\n\t\t\t}\n\t\t\ttick64 = tk64->Tick = tick64 - tk64->TickStart + (UINT64)1;\n\t\t}\n\t\tUnlock(tk64->TickLock);\n#else\t// OS_WIN32\n\t\ttick64 = Win32FastTick64();\n\t\ttick = (UINT)tick64;\n#endif\t// OS_WIN32\n\n\t\tif (create_first_entry)\n\t\t{\n\t\t\tADJUST_TIME *t = ZeroMalloc(sizeof(ADJUST_TIME));\n\t\t\tt->Tick = tick64;\n\t\t\tt->Time = SystemTime64();\n\t\t\ttk64->Tick64WithTime64 = tick64;\n\t\t\ttk64->Time64 = t->Time;\n\t\t\tAdd(tk64->AdjustTime, t);\n\n\t\t\t// Notify the completion of the initialization \n\t\t\tNoticeThreadInit(thread);\n\t\t\tcreate_first_entry = false;\n\t\t}\n\n\t\t// Time correction\n\t\tn += tick_span;\n\t\tif (n >= 1000 || first == false)\n\t\t{\n\t\t\tUINT64 now = SystemTime64();\n\n\t\t\tif (now < tk64->Time64 ||\n\t\t\t\tDiff64((now - tk64->Time64) + tk64->Tick64WithTime64, tick64) >= tick_span)\n\t\t\t{\n\t\t\t\tADJUST_TIME *t = ZeroMalloc(sizeof(ADJUST_TIME));\n\t\t\t\tLockList(tk64->AdjustTime);\n\t\t\t\t{\n\t\t\t\t\tt->Tick = tick64;\n\t\t\t\t\tt->Time = now;\n\t\t\t\t\tAdd(tk64->AdjustTime, t);\n\t\t\t\t\tDebug(\"Adjust Time: Tick = %I64u, Time = %I64u\\n\",\n\t\t\t\t\t\tt->Tick, t->Time);\n\n\t\t\t\t\t// To prevent consuming memory infinite on a system that clock is skewd\n\t\t\t\t\tif (LIST_NUM(tk64->AdjustTime) > MAX_ADJUST_TIME)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Remove the second\n\t\t\t\t\t\tADJUST_TIME *t2 = LIST_DATA(tk64->AdjustTime, 1);\n\n\t\t\t\t\t\tDelete(tk64->AdjustTime, t2);\n\n\t\t\t\t\t\tDebug(\"NUM_ADJUST TIME: %u\\n\", LIST_NUM(tk64->AdjustTime));\n\n\t\t\t\t\t\tFree(t2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tUnlockList(tk64->AdjustTime);\n\t\t\t\ttk64->Time64 = now;\n\t\t\t\ttk64->Tick64WithTime64 = tick64;\n\t\t\t}\n\t\t\tfirst = true;\n\t\t\tn = 0;\n\t\t}\n\n\t\tif (tk64->Halt)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n#ifdef\tOS_WIN32\n\t\tWait(halt_tick_event, tick_span);\n#else\t// OS_WIN32\n\t\tSleepThread(tick_span);\n#endif\t// OS_WIN32\n\t}\n}", "path": "SoftEtherVPN/src/Mayaqua/Tick64.c", "commit_date": "2019-01-14 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN", "stars": 10925, "license": "apache-2.0", "language": "c", "size": 540898}
{"docstring": "// Monitor the IPsec service of the OS, and stop it if it will conflict\n", "func_signal": "void IPsecOsServiceCheckThread(THREAD *t, void *p)", "code": "{\n\tUINT interval = IPSEC_CHECK_OS_SERVICE_INTERVAL_INITIAL;\n\tIPSEC_SERVER *s = (IPSEC_SERVER *)p;\n\t// Validate arguments\n\tif (t == NULL || p == NULL)\n\t{\n\t\treturn;\n\t}\n\n\ts->HostIPAddressListChanged = true;\n\ts->OsServiceStoped = false;\n\n\twhile (s->Halt == false)\n\t{\n\t\tif (IPsecCheckOsService(s))\n\t\t{\n\t\t\tinterval = IPSEC_CHECK_OS_SERVICE_INTERVAL_INITIAL;\n\t\t}\n\n\t\tif (Wait(s->OsServiceCheckThreadEvent, interval) == false)\n\t\t{\n\t\t\tinterval = MIN(interval * 2, IPSEC_CHECK_OS_SERVICE_INTERVAL_MAX);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tinterval = IPSEC_CHECK_OS_SERVICE_INTERVAL_INITIAL;\n\t\t}\n\t}\n\n\tIPsecCheckOsService(s);\n}", "path": "SoftEtherVPN/src/Cedar/Proto_IPsec.c", "commit_date": "2019-01-21 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN", "stars": 10925, "license": "apache-2.0", "language": "c", "size": 540898}
{"docstring": "// Processing of UDP packets (one by one)\n", "func_signal": "void IPsecProcPacket(IPSEC_SERVER *s, UDPPACKET *p)", "code": "{\n\tL2TP_SERVER *l2tp;\n\tIKE_SERVER *ike;\n\tvoid *old_data_ptr;\n\tUINT old_data_size;\n\tbool proc_this_packet = true;\n\t// Validate arguments\n\tif (s == NULL || p == NULL)\n\t{\n\t\treturn;\n\t}\n\n\told_data_ptr = p->Data;\n\told_data_size = p->Size;\n\n\tl2tp = s->L2TP;\n\tike = s->Ike;\n\n\t// UDP decapsulation process\n\tif (p->DestPort == IPSEC_PORT_IPSEC_ESP_UDP)\n\t{\n#ifdef\tOS_WIN32\n\t\tif (p->Size >= 12 && IsZero(p->Data, 4))\n\t\t{\n\t\t\tif (((*((UINT *)(((UCHAR *)p->Data) + sizeof(UINT) * 1))) == WFP_ESP_PACKET_TAG_1) &&\n\t\t\t\t((*((UINT *)(((UCHAR *)p->Data) + sizeof(UINT) * 2))) == WFP_ESP_PACKET_TAG_2))\n\t\t\t{\n\t\t\t\t// Truncate the head because the packet was modified by WFP\n\t\t\t\tp->Data = ((UCHAR *)p->Data) + 12;\n\t\t\t\tp->Size -= 12;\n\t\t\t}\n\t\t}\n#endif\t// OS_WIN32\n\n\t\tif (p->Size >= 4 && IsZero(p->Data, 4))\n\t\t{\n\t\t\t// Truncate the Non-ESP Marker\n\t\t\tp->Data = ((UCHAR *)p->Data) + 4;\n\t\t\tp->Size -= 4;\n\n\t\t\tp->Type = IKE_UDP_TYPE_ISAKMP;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp->Type = IKE_UDP_TYPE_ESP;\n\t\t}\n\t}\n\telse if (p->DestPort == IPSEC_PORT_IPSEC_ISAKMP)\n\t{\n\t\tif (p->Size >= 8 && IsZero(p->Data, 8))\n\t\t{\n\t\t\t// Truncate the Non-IKE Maker\n\t\t\tp->Data = ((UCHAR *)p->Data) + 8;\n\t\t\tp->Size -= 8;\n\n\t\t\tp->Type = IKE_UDP_TYPE_ESP;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp->Type = IKE_UDP_TYPE_ISAKMP;\n\t\t}\n\t}\n\telse if (p->DestPort == IPSEC_PORT_IPSEC_ESP_RAW)\n\t{\n\t\t// Raw ESP\n\t\tp->Type = IKE_UDP_TYPE_ESP;\n\t}\n\n\n\tif (proc_this_packet)\n\t{\n\t\tswitch (p->DestPort)\n\t\t{\n\t\tcase IPSEC_PORT_L2TP:\n\t\t\t// L2TP\n\t\t\tProcL2TPPacketRecv(l2tp, p);\n\t\t\tbreak;\n\n\t\tcase IPSEC_PORT_IPSEC_ISAKMP:\n\t\tcase IPSEC_PORT_IPSEC_ESP_UDP:\n\t\tcase IPSEC_PORT_IPSEC_ESP_RAW:\n\t\t\t// IPsec\n\t\t\tProcIKEPacketRecv(ike, p);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tp->Data = old_data_ptr;\n\tp->Size = old_data_size;\n}", "path": "SoftEtherVPN/src/Cedar/Proto_IPsec.c", "commit_date": "2019-01-21 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN", "stars": 10925, "license": "apache-2.0", "language": "c", "size": 540898}
{"docstring": "// Get the absolute value of the difference between the two 64 bit integers\n", "func_signal": "UINT64 Diff64(UINT64 a, UINT64 b)", "code": "{\n\tif (a > b)\n\t{\n\t\treturn a - b;\n\t}\n\telse\n\t{\n\t\treturn b - a;\n\t}\n}", "path": "SoftEtherVPN/src/Mayaqua/Tick64.c", "commit_date": "2019-01-14 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN", "stars": 10925, "license": "apache-2.0", "language": "c", "size": 540898}
{"docstring": "// Packet reception procedure of UDP listener\n", "func_signal": "void IPsecServerUdpPacketRecvProc(UDPLISTENER *u, LIST *packet_list)", "code": "{\n\tUINT i;\n\tIPSEC_SERVER *s;\n\tL2TP_SERVER *l2tp;\n\tIKE_SERVER *ike;\n\tUINT64 now;\n\tstatic UCHAR zero8[8] = {0, 0, 0, 0, 0, 0, 0, 0, };\n\t// Validate arguments\n\tif (u == NULL || packet_list == NULL)\n\t{\n\t\treturn;\n\t}\n\ts = (IPSEC_SERVER *)u->Param;\n\tif (s == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tif (u->HostIPAddressListChanged)\n\t{\n\t\tu->HostIPAddressListChanged = false;\n\n\t\ts->HostIPAddressListChanged = true;\n\n\t\tSet(s->OsServiceCheckThreadEvent);\n\t}\n\n\tnow = Tick64();\n\n\t// Adjustment about L2TP server timing\n\tl2tp = s->L2TP;\n\n\tif (l2tp->Interrupts == NULL)\n\t{\n\t\tl2tp->Interrupts = u->Interrupts;\n\t}\n\n\tif (l2tp->SockEvent == NULL)\n\t{\n\t\tSetL2TPServerSockEvent(l2tp, u->Event);\n\t}\n\n\tl2tp->Now = now;\n\n\t// Adjustment about IKE server timing\n\tike = s->Ike;\n\n\tif (ike->Interrupts == NULL)\n\t{\n\t\tike->Interrupts = u->Interrupts;\n\t}\n\n\tif (ike->SockEvent == NULL)\n\t{\n\t\tSetIKEServerSockEvent(ike, u->Event);\n\t}\n\n\tike->Now = now;\n\n\tif (ipsec_disable == false)\n\t{\n\t\t{\n\t\t\t// Process the received packet\n\t\t\tfor (i = 0;i < LIST_NUM(packet_list);i++)\n\t\t\t{\n\t\t\t\tUDPPACKET *p = LIST_DATA(packet_list, i);\n\n\t\t\t\tIPsecProcPacket(s, p);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Interrupt processing of L2TP server\n\tL2TPProcessInterrupts(l2tp);\n\n\t// L2TP packet transmission processing\n\tUdpListenerSendPackets(u, l2tp->SendPacketList);\n\tDeleteAll(l2tp->SendPacketList);\n\n\t// Interrupt processing of IKE server\n\tProcessIKEInterrupts(ike);\n\n\t// UDP encapsulation process of IKE server packet scheduled for transmission\n\tfor (i = 0;i < LIST_NUM(ike->SendPacketList);i++)\n\t{\n\t\tUDPPACKET *p = LIST_DATA(ike->SendPacketList, i);\n\n\t\tif (p->Type == IKE_UDP_TYPE_ISAKMP && p->SrcPort == IPSEC_PORT_IPSEC_ESP_UDP)\n\t\t{\n\t\t\t// Add the Non-ESP Marker\n\t\t\tvoid *old_data = p->Data;\n\n\t\t\tp->Data = AddHead(p->Data, p->Size, zero8, 4);\n\t\t\tp->Size += 4;\n\n\t\t\tFree(old_data);\n\t\t}\n\t\telse if (p->Type == IKE_UDP_TYPE_ESP && p->SrcPort == IPSEC_PORT_IPSEC_ISAKMP)\n\t\t{\n\t\t\t// Add the Non-IKE Marker\n\t\t\tvoid *old_data = p->Data;\n\n\t\t\tp->Data = AddHead(p->Data, p->Size, zero8, 8);\n\t\t\tp->Size += 8;\n\n\t\t\tFree(old_data);\n\t\t}\n\t}\n\n\t// IKE server packet transmission processing\n\tUdpListenerSendPackets(u, ike->SendPacketList);\n\tDeleteAll(ike->SendPacketList);\n}", "path": "SoftEtherVPN/src/Cedar/Proto_IPsec.c", "commit_date": "2019-01-21 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN", "stars": 10925, "license": "apache-2.0", "language": "c", "size": 540898}
{"docstring": "// Initialization of the Tick64\n", "func_signal": "void InitTick64()", "code": "{\n\tif (tk64 != NULL)\n\t{\n\t\t// Already initialized\n\t\treturn;\n\t}\n\n\thalt_tick_event = NewEvent();\n\n\t// Initialize the structure\n\ttk64 = ZeroMalloc(sizeof(TICK64));\n\ttk64->TickLock = NewLock();\n\ttk64->AdjustTime = NewList(NULL);\n\n\t// Creating a thread\n\ttk64->Thread = NewThread(Tick64Thread, NULL);\n\tWaitThreadInit(tk64->Thread);\n}", "path": "SoftEtherVPN/src/Mayaqua/Tick64.c", "commit_date": "2019-01-14 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN", "stars": 10925, "license": "apache-2.0", "language": "c", "size": 540898}
{"docstring": "// Get the service list\n", "func_signal": "void IPsecServerGetServices(IPSEC_SERVER *s, IPSEC_SERVICES *sl)", "code": "{\n\t// Validate arguments\n\tif (s == NULL || sl == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tLock(s->LockSettings);\n\t{\n\t\tIPsecNormalizeServiceSetting(s);\n\n\t\tCopy(sl, &s->Services, sizeof(IPSEC_SERVICES));\n\t}\n\tUnlock(s->LockSettings);\n}", "path": "SoftEtherVPN/src/Cedar/Proto_IPsec.c", "commit_date": "2019-01-21 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN", "stars": 10925, "license": "apache-2.0", "language": "c", "size": 540898}
{"docstring": "// Get the high-resolution time\n", "func_signal": "UINT64 TickHighres64()", "code": "{\n\n#ifdef\tOS_WIN32\n\n\treturn (UINT64)(MsGetHiResTimeSpan(MsGetHiResCounter()) * 1000.0f);\n\n#else\t// OS_WIN32\n\n\treturn Tick64();\n\n#endif\t// OS_WIN32\n\n}", "path": "SoftEtherVPN/src/Mayaqua/Tick64.c", "commit_date": "2019-01-14 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN", "stars": 10925, "license": "apache-2.0", "language": "c", "size": 540898}
{"docstring": "/**\n * Handle response MDNS packet\n * Only prints debug for now. Will need more code to do conflict resolution.\n */\n", "func_signal": "static void\nmdns_handle_response(struct mdns_packet *pkt)", "code": "{\n  /* Ignore all questions */\n  while (pkt->questions_left) {\n    struct mdns_question q;\n    err_t res;\n\n    res = mdns_read_question(pkt, &q);\n    if (res != ERR_OK) {\n      LWIP_DEBUGF(MDNS_DEBUG, (\"MDNS: Failed to parse question, skipping response packet\\n\"));\n      return;\n    }\n  }\n\n  while (pkt->answers_left) {\n    struct mdns_answer ans;\n    err_t res;\n\n    res = mdns_read_answer(pkt, &ans);\n    if (res != ERR_OK) {\n      LWIP_DEBUGF(MDNS_DEBUG, (\"MDNS: Failed to parse answer, skipping response packet\\n\"));\n      return;\n    }\n\n    LWIP_DEBUGF(MDNS_DEBUG, (\"MDNS: Answer for domain \"));\n    mdns_domain_debug_print(&ans.info.domain);\n    LWIP_DEBUGF(MDNS_DEBUG, (\" type %d class %d\\n\", ans.info.type, ans.info.klass));\n  }\n}", "path": "HarmonyOS/Huawei_LiteOS/components/net/lwip/lwip-2.0.3/src/apps/mdns/mdns.c", "commit_date": "2019-08-10 00:00:00", "repo_name": "Awesome-HarmonyOS/HarmonyOS", "stars": 19052, "license": "None", "language": "c", "size": 23807}
{"docstring": "/**\n * Return bytes needed to write before jump for best result of compressing supplied domain\n * against domain in outpacket starting at specified offset.\n * If a match is found, offset is updated to where to jump to\n * @param pbuf Pointer to pbuf with the partially constructed DNS packet\n * @param offset Start position of a domain written earlier. If this location is suitable\n *               for compression, the pointer is updated to where in the domain to jump to.\n * @param domain The domain to write\n * @return Number of bytes to write of the new domain before writing a jump to the offset.\n *         If compression can not be done against this previous domain name, the full new\n *         domain length is returned.\n */\n", "func_signal": "u16_t\nmdns_compress_domain(struct pbuf *pbuf, u16_t *offset, struct mdns_domain *domain)", "code": "{\n  struct mdns_domain target;\n  u16_t target_end;\n  u8_t target_len;\n  u8_t writelen = 0;\n  u8_t *ptr;\n  if (pbuf == NULL) {\n    return domain->length;\n  }\n  target_end = mdns_readname(pbuf, *offset, &target);\n  if (target_end == MDNS_READNAME_ERROR) {\n    return domain->length;\n  }\n  target_len = (u8_t)(target_end - *offset);\n  ptr = domain->name;\n  while (writelen < domain->length) {\n    u8_t domainlen = (u8_t)(domain->length - writelen);\n    u8_t labellen;\n    if (domainlen <= target.length && domainlen > DOMAIN_JUMP_SIZE) {\n      /* Compare domains if target is long enough, and we have enough left of the domain */\n      u8_t targetpos = (u8_t)(target.length - domainlen);\n      if ((targetpos + DOMAIN_JUMP_SIZE) >= target_len) {\n        /* We are checking at or beyond a jump in the original, stop looking */\n        break;\n      }\n      if (target.length >= domainlen &&\n          memcmp(&domain->name[writelen], &target.name[targetpos], domainlen) == 0) {\n        *offset += targetpos;\n        return writelen;\n      }\n    }\n    /* Skip to next label in domain */\n    labellen = *ptr;\n    writelen += 1 + labellen;\n    ptr += 1 + labellen;\n  }\n  /* Nothing found */\n  return domain->length;\n}", "path": "HarmonyOS/Huawei_LiteOS/components/net/lwip/lwip-2.0.3/src/apps/mdns/mdns.c", "commit_date": "2019-08-10 00:00:00", "repo_name": "Awesome-HarmonyOS/HarmonyOS", "stars": 19052, "license": "None", "language": "c", "size": 23807}
{"docstring": "/** Write a SRV RR to outpacket */\n", "func_signal": "static err_t\nmdns_add_srv_answer(struct mdns_outpacket *reply, u16_t cache_flush, struct mdns_host *mdns, struct mdns_service *service)", "code": "{\n  struct mdns_domain service_instance, srvhost;\n  u16_t srvdata[3];\n  mdns_build_service_domain(&service_instance, service, 1);\n  mdns_build_host_domain(&srvhost, mdns);\n  if (reply->legacy_query) {\n    /* RFC 6762 section 18.14:\n     * In legacy unicast responses generated to answer legacy queries,\n     * name compression MUST NOT be performed on SRV records.\n     */\n    srvhost.skip_compression = 1;\n  }\n  srvdata[0] = lwip_htons(SRV_PRIORITY);\n  srvdata[1] = lwip_htons(SRV_WEIGHT);\n  srvdata[2] = lwip_htons(service->port);\n  LWIP_DEBUGF(MDNS_DEBUG, (\"MDNS: Responding with SRV record\\n\"));\n  return mdns_add_answer(reply, &service_instance, DNS_RRTYPE_SRV, DNS_RRCLASS_IN, cache_flush, service->dns_ttl,\n                         (const u8_t *) &srvdata, sizeof(srvdata), &srvhost);\n}", "path": "HarmonyOS/Huawei_LiteOS/components/net/lwip/lwip-2.0.3/src/apps/mdns/mdns.c", "commit_date": "2019-08-10 00:00:00", "repo_name": "Awesome-HarmonyOS/HarmonyOS", "stars": 19052, "license": "None", "language": "c", "size": 23807}
{"docstring": "/**\n * Build domain for reverse lookup of IPv4 address\n * like 12.0.168.192.in-addr.arpa. for 192.168.0.12\n * @param domain Where to write the domain name\n * @param addr Pointer to an IPv4 address to encode\n * @return ERR_OK if domain was written, an err_t otherwise\n */\n", "func_signal": "static err_t\nmdns_build_reverse_v4_domain(struct mdns_domain *domain, const ip4_addr_t *addr)", "code": "{\n  int i;\n  err_t res;\n  const u8_t *ptr;\n  if (!domain || !addr) {\n    return ERR_ARG;\n  }\n  memset(domain, 0, sizeof(struct mdns_domain));\n  ptr = (const u8_t *) addr;\n  for (i = sizeof(ip4_addr_t) - 1; i >= 0; i--) {\n    char buf[4];\n    u8_t val = ptr[i];\n\n    lwip_itoa(buf, sizeof(buf), val);\n    res = mdns_domain_add_label(domain, buf, (u8_t)strlen(buf));\n    LWIP_ERROR(\"mdns_build_reverse_v4_domain: Failed to add label\", (res == ERR_OK), return res);\n  }\n  res = mdns_domain_add_label(domain, REVERSE_PTR_V4_DOMAIN, (u8_t)(sizeof(REVERSE_PTR_V4_DOMAIN)-1));\n  LWIP_ERROR(\"mdns_build_reverse_v4_domain: Failed to add label\", (res == ERR_OK), return res);\n  res = mdns_domain_add_label(domain, REVERSE_PTR_TOPDOMAIN, (u8_t)(sizeof(REVERSE_PTR_TOPDOMAIN)-1));\n  LWIP_ERROR(\"mdns_build_reverse_v4_domain: Failed to add label\", (res == ERR_OK), return res);\n  res = mdns_domain_add_label(domain, NULL, 0);\n  LWIP_ERROR(\"mdns_build_reverse_v4_domain: Failed to add label\", (res == ERR_OK), return res);\n\n  return ERR_OK;\n}", "path": "HarmonyOS/Huawei_LiteOS/components/net/lwip/lwip-2.0.3/src/apps/mdns/mdns.c", "commit_date": "2019-08-10 00:00:00", "repo_name": "Awesome-HarmonyOS/HarmonyOS", "stars": 19052, "license": "None", "language": "c", "size": 23807}
{"docstring": "/**\n * Read an answer from the packet\n * The variable length reply is not copied, its pbuf offset and length is stored instead.\n * @param pkt The MDNS packet to read. The answers_left field will be decremented and\n *            the parse_offset will be updated.\n * @param answer The struct to fill with answer data\n * @return ERR_OK on success, an err_t otherwise\n */\n", "func_signal": "static err_t\nmdns_read_answer(struct mdns_packet *pkt, struct mdns_answer *answer)", "code": "{\n  /* Read questions first */\n  if (pkt->questions_left) {\n    return ERR_VAL;\n  }\n\n  /* Safety check */\n  if (pkt->pbuf->tot_len < pkt->parse_offset) {\n    return ERR_VAL;\n  }\n\n  if (pkt->answers_left) {\n    u16_t copied, field16;\n    u32_t ttl;\n    err_t res;\n    pkt->answers_left--;\n\n    memset(answer, 0, sizeof(struct mdns_answer));\n    res = mdns_read_rr_info(pkt, &answer->info);\n    if (res != ERR_OK) {\n      return res;\n    }\n\n    /* Extract cache_flush flag from class field */\n    answer->cache_flush = answer->info.klass & 0x8000;\n    answer->info.klass &= 0x7FFF;\n\n    copied = pbuf_copy_partial(pkt->pbuf, &ttl, sizeof(ttl), pkt->parse_offset);\n    if (copied != sizeof(ttl)) {\n      return ERR_VAL;\n    }\n    pkt->parse_offset += copied;\n    answer->ttl = lwip_ntohl(ttl);\n\n    copied = pbuf_copy_partial(pkt->pbuf, &field16, sizeof(field16), pkt->parse_offset);\n    if (copied != sizeof(field16)) {\n      return ERR_VAL;\n    }\n    pkt->parse_offset += copied;\n    answer->rd_length = lwip_ntohs(field16);\n\n    answer->rd_offset = pkt->parse_offset;\n    pkt->parse_offset += answer->rd_length;\n\n    return ERR_OK;\n  }\n  return ERR_VAL;\n}", "path": "HarmonyOS/Huawei_LiteOS/components/net/lwip/lwip-2.0.3/src/apps/mdns/mdns.c", "commit_date": "2019-08-10 00:00:00", "repo_name": "Awesome-HarmonyOS/HarmonyOS", "stars": 19052, "license": "None", "language": "c", "size": 23807}
{"docstring": "/**\n * Read possibly compressed domain name from packet buffer\n * @param p The packet\n * @param offset start position of domain name in packet\n * @param domain The domain name destination\n * @return The new offset after the domain, or MDNS_READNAME_ERROR\n *         if reading failed\n */\n", "func_signal": "u16_t\nmdns_readname(struct pbuf *p, u16_t offset, struct mdns_domain *domain)", "code": "{\n  memset(domain, 0, sizeof(struct mdns_domain));\n  return mdns_readname_loop(p, offset, domain, 0);\n}", "path": "HarmonyOS/Huawei_LiteOS/components/net/lwip/lwip-2.0.3/src/apps/mdns/mdns.c", "commit_date": "2019-08-10 00:00:00", "repo_name": "Awesome-HarmonyOS/HarmonyOS", "stars": 19052, "license": "None", "language": "c", "size": 23807}
{"docstring": "/**\n  * @brief  DeInitializes the CRC peripheral.\n  * @param  hcrc pointer to a CRC_HandleTypeDef structure that contains\n  *         the configuration information for CRC\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_CRC_DeInit(CRC_HandleTypeDef *hcrc)", "code": "{\n  /* Check the CRC handle allocation */\n  if(hcrc == NULL)\n  {\n    return HAL_ERROR;\n  }\n\n  /* Check the parameters */\n  assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));\n\n  /* Change CRC peripheral state */\n  hcrc->State = HAL_CRC_STATE_BUSY;\n\n  /* DeInit the low level hardware */\n  HAL_CRC_MspDeInit(hcrc);\n\n  /* Change CRC peripheral state */\n  hcrc->State = HAL_CRC_STATE_RESET;\n\n  /* Release Lock */\n  __HAL_UNLOCK(hcrc);\n\n  /* Return function status */\n  return HAL_OK;\n}", "path": "HarmonyOS/Huawei_LiteOS/targets/Cloud_STM32F429IGTx_FIRE/Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_crc.c", "commit_date": "2019-08-10 00:00:00", "repo_name": "Awesome-HarmonyOS/HarmonyOS", "stars": 19052, "license": "None", "language": "c", "size": 23807}
{"docstring": "/**\n * Helper function for mdns_read_question/mdns_read_answer\n * Reads a domain, type and class from the packet\n * @param pkt The MDNS packet to read from. The parse_offset field will be\n *            incremented to point to the next unparsed byte.\n * @param info The struct to fill with domain, type and class\n * @return ERR_OK on success, an err_t otherwise\n */\n", "func_signal": "static err_t\nmdns_read_rr_info(struct mdns_packet *pkt, struct mdns_rr_info *info)", "code": "{\n  u16_t field16, copied;\n  pkt->parse_offset = mdns_readname(pkt->pbuf, pkt->parse_offset, &info->domain);\n  if (pkt->parse_offset == MDNS_READNAME_ERROR) {\n    return ERR_VAL;\n  }\n\n  copied = pbuf_copy_partial(pkt->pbuf, &field16, sizeof(field16), pkt->parse_offset);\n  if (copied != sizeof(field16)) {\n    return ERR_VAL;\n  }\n  pkt->parse_offset += copied;\n  info->type = lwip_ntohs(field16);\n\n  copied = pbuf_copy_partial(pkt->pbuf, &field16, sizeof(field16), pkt->parse_offset);\n  if (copied != sizeof(field16)) {\n    return ERR_VAL;\n  }\n  pkt->parse_offset += copied;\n  info->klass = lwip_ntohs(field16);\n\n  return ERR_OK;\n}", "path": "HarmonyOS/Huawei_LiteOS/components/net/lwip/lwip-2.0.3/src/apps/mdns/mdns.c", "commit_date": "2019-08-10 00:00:00", "repo_name": "Awesome-HarmonyOS/HarmonyOS", "stars": 19052, "license": "None", "language": "c", "size": 23807}
{"docstring": "/**\n * Send unsolicited answer containing all our known data\n * @param netif The network interface to send on\n * @param destination The target address to send to (usually multicast address)\n */\n", "func_signal": "static void\nmdns_announce(struct netif *netif, const ip_addr_t *destination)", "code": "{\n  struct mdns_outpacket announce;\n  int i;\n  struct mdns_host* mdns = NETIF_TO_HOST(netif);\n\n  memset(&announce, 0, sizeof(announce));\n  announce.netif = netif;\n  announce.cache_flush = 1;\n#if LWIP_IPV4\n  if (!ip4_addr_isany_val(*netif_ip4_addr(netif)))\n    announce.host_replies = REPLY_HOST_A | REPLY_HOST_PTR_V4;\n#endif\n#if LWIP_IPV6\n  for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; ++i) {\n    if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i))) {\n      announce.host_replies |= REPLY_HOST_AAAA | REPLY_HOST_PTR_V6;\n      announce.host_reverse_v6_replies |= (1 << i);\n    }\n  }\n#endif\n\n  for (i = 0; i < MDNS_MAX_SERVICES; i++) {\n    struct mdns_service *serv = mdns->services[i];\n    if (serv) {\n      announce.serv_replies[i] = REPLY_SERVICE_TYPE_PTR | REPLY_SERVICE_NAME_PTR |\n          REPLY_SERVICE_SRV | REPLY_SERVICE_TXT;\n    }\n  }\n\n  announce.dest_port = MDNS_PORT;\n  SMEMCPY(&announce.dest_addr, destination, sizeof(announce.dest_addr));\n  mdns_send_outpacket(&announce);\n}", "path": "HarmonyOS/Huawei_LiteOS/components/net/lwip/lwip-2.0.3/src/apps/mdns/mdns.c", "commit_date": "2019-08-10 00:00:00", "repo_name": "Awesome-HarmonyOS/HarmonyOS", "stars": 19052, "license": "None", "language": "c", "size": 23807}
{"docstring": "/**\n * Receive input function for MDNS packets.\n * Handles both IPv4 and IPv6 UDP pcbs.\n */\n", "func_signal": "static void\nmdns_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)", "code": "{\n  struct dns_hdr hdr;\n  struct mdns_packet packet;\n  struct netif *recv_netif = ip_current_input_netif();\n  u16_t offset = 0;\n\n  LWIP_UNUSED_ARG(arg);\n  LWIP_UNUSED_ARG(pcb);\n\n  LWIP_DEBUGF(MDNS_DEBUG, (\"MDNS: Received IPv%d MDNS packet, len %d\\n\", IP_IS_V6(addr)? 6 : 4, p->tot_len));\n\n  if (NETIF_TO_HOST(recv_netif) == NULL) {\n    /* From netif not configured for MDNS */\n    goto dealloc;\n  }\n\n  if (pbuf_copy_partial(p, &hdr, SIZEOF_DNS_HDR, offset) < SIZEOF_DNS_HDR) {\n    /* Too small */\n    goto dealloc;\n  }\n  offset += SIZEOF_DNS_HDR;\n\n  if (DNS_HDR_GET_OPCODE(&hdr)) {\n    /* Ignore non-standard queries in multicast packets (RFC 6762, section 18.3) */\n    goto dealloc;\n  }\n\n  memset(&packet, 0, sizeof(packet));\n  SMEMCPY(&packet.source_addr, addr, sizeof(packet.source_addr));\n  packet.source_port = port;\n  packet.netif = recv_netif;\n  packet.pbuf = p;\n  packet.parse_offset = offset;\n  packet.tx_id = lwip_ntohs(hdr.id);\n  packet.questions = packet.questions_left = lwip_ntohs(hdr.numquestions);\n  packet.answers = packet.answers_left = lwip_ntohs(hdr.numanswers) + lwip_ntohs(hdr.numauthrr) + lwip_ntohs(hdr.numextrarr);\n\n#if LWIP_IPV6\n  if (IP_IS_V6(ip_current_dest_addr())) {\n    if (!ip_addr_cmp(ip_current_dest_addr(), &v6group)) {\n      packet.recv_unicast = 1;\n    }\n  }\n#endif\n#if LWIP_IPV4\n  if (!IP_IS_V6(ip_current_dest_addr())) {\n    if (!ip_addr_cmp(ip_current_dest_addr(), &v4group)) {\n      packet.recv_unicast = 1;\n    }\n  }\n#endif\n\n  if (hdr.flags1 & DNS_FLAG1_RESPONSE) {\n    mdns_handle_response(&packet);\n  } else {\n    mdns_handle_question(&packet);\n  }\n\ndealloc:\n  pbuf_free(p);\n}", "path": "HarmonyOS/Huawei_LiteOS/components/net/lwip/lwip-2.0.3/src/apps/mdns/mdns.c", "commit_date": "2019-08-10 00:00:00", "repo_name": "Awesome-HarmonyOS/HarmonyOS", "stars": 19052, "license": "None", "language": "c", "size": 23807}
{"docstring": "/**\n  * @brief  Computes the 32-bit CRC of 32-bit data buffer independently\n  *         of the previous CRC value.\n  * @param  hcrc pointer to a CRC_HandleTypeDef structure that contains\n  *         the configuration information for CRC\n  * @param  pBuffer Pointer to the buffer containing the data to be computed\n  * @param  BufferLength Length of the buffer to be computed\n  * @retval 32-bit CRC\n  */\n", "func_signal": "uint32_t HAL_CRC_Calculate(CRC_HandleTypeDef *hcrc, uint32_t pBuffer[], uint32_t BufferLength)", "code": "{\n  uint32_t index = 0U;\n\n  /* Process Locked */\n  __HAL_LOCK(hcrc);\n\n  /* Change CRC peripheral state */\n  hcrc->State = HAL_CRC_STATE_BUSY;\n\n  /* Reset CRC Calculation Unit */\n  __HAL_CRC_DR_RESET(hcrc);\n\n  /* Enter Data to the CRC calculator */\n  for(index = 0U; index < BufferLength; index++)\n  {\n    hcrc->Instance->DR = pBuffer[index];\n  }\n\n  /* Change CRC peripheral state */\n  hcrc->State = HAL_CRC_STATE_READY;\n\n  /* Process Unlocked */\n  __HAL_UNLOCK(hcrc);\n\n  /* Return the CRC computed value */\n  return hcrc->Instance->DR;\n}", "path": "HarmonyOS/Huawei_LiteOS/targets/Cloud_STM32F429IGTx_FIRE/Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_crc.c", "commit_date": "2019-08-10 00:00:00", "repo_name": "Awesome-HarmonyOS/HarmonyOS", "stars": 19052, "license": "None", "language": "c", "size": 23807}
{"docstring": "/**\n * Send chosen answers as a reply\n *\n * Add all selected answers (first write will allocate pbuf)\n * Add additional answers based on the selected answers\n * Send the packet\n */\n", "func_signal": "static void\nmdns_send_outpacket(struct mdns_outpacket *outpkt)", "code": "{\n  struct mdns_service *service;\n  err_t res;\n  int i;\n  struct mdns_host* mdns = NETIF_TO_HOST(outpkt->netif);\n\n  /* Write answers to host questions */\n#if LWIP_IPV4\n  if (outpkt->host_replies & REPLY_HOST_A) {\n    res = mdns_add_a_answer(outpkt, outpkt->cache_flush, outpkt->netif);\n    if (res != ERR_OK) {\n      goto cleanup;\n    }\n    outpkt->answers++;\n  }\n  if (outpkt->host_replies & REPLY_HOST_PTR_V4) {\n    res = mdns_add_hostv4_ptr_answer(outpkt, outpkt->cache_flush, outpkt->netif);\n    if (res != ERR_OK) {\n      goto cleanup;\n    }\n    outpkt->answers++;\n  }\n#endif\n#if LWIP_IPV6\n  if (outpkt->host_replies & REPLY_HOST_AAAA) {\n    int addrindex;\n    for (addrindex = 0; addrindex < LWIP_IPV6_NUM_ADDRESSES; ++addrindex) {\n      if (ip6_addr_isvalid(netif_ip6_addr_state(outpkt->netif, addrindex))) {\n        res = mdns_add_aaaa_answer(outpkt, outpkt->cache_flush, outpkt->netif, addrindex);\n        if (res != ERR_OK) {\n          goto cleanup;\n        }\n        outpkt->answers++;\n      }\n    }\n  }\n  if (outpkt->host_replies & REPLY_HOST_PTR_V6) {\n    u8_t rev_addrs = outpkt->host_reverse_v6_replies;\n    int addrindex = 0;\n    while (rev_addrs) {\n      if (rev_addrs & 1) {\n        res = mdns_add_hostv6_ptr_answer(outpkt, outpkt->cache_flush, outpkt->netif, addrindex);\n        if (res != ERR_OK) {\n          goto cleanup;\n        }\n        outpkt->answers++;\n      }\n      addrindex++;\n      rev_addrs >>= 1;\n    }\n  }\n#endif\n\n  /* Write answers to service questions */\n  for (i = 0; i < MDNS_MAX_SERVICES; ++i) {\n    service = mdns->services[i];\n    if (!service) {\n      continue;\n    }\n\n    if (outpkt->serv_replies[i] & REPLY_SERVICE_TYPE_PTR) {\n      res = mdns_add_servicetype_ptr_answer(outpkt, service);\n      if (res != ERR_OK) {\n        goto cleanup;\n      }\n      outpkt->answers++;\n    }\n\n    if (outpkt->serv_replies[i] & REPLY_SERVICE_NAME_PTR) {\n      res = mdns_add_servicename_ptr_answer(outpkt, service);\n      if (res != ERR_OK) {\n        goto cleanup;\n      }\n      outpkt->answers++;\n    }\n\n    if (outpkt->serv_replies[i] & REPLY_SERVICE_SRV) {\n      res = mdns_add_srv_answer(outpkt, outpkt->cache_flush, mdns, service);\n      if (res != ERR_OK) {\n        goto cleanup;\n      }\n      outpkt->answers++;\n    }\n\n    if (outpkt->serv_replies[i] & REPLY_SERVICE_TXT) {\n      res = mdns_add_txt_answer(outpkt, outpkt->cache_flush, service);\n      if (res != ERR_OK) {\n        goto cleanup;\n      }\n      outpkt->answers++;\n    }\n  }\n\n  /* All answers written, add additional RRs */\n  for (i = 0; i < MDNS_MAX_SERVICES; ++i) {\n    service = mdns->services[i];\n    if (!service) {\n      continue;\n    }\n\n    if (outpkt->serv_replies[i] & REPLY_SERVICE_NAME_PTR) {\n      /* Our service instance requested, include SRV & TXT\n       * if they are already not requested. */\n      if (!(outpkt->serv_replies[i] & REPLY_SERVICE_SRV)) {\n        res = mdns_add_srv_answer(outpkt, outpkt->cache_flush, mdns, service);\n        if (res != ERR_OK) {\n          goto cleanup;\n        }\n        outpkt->additional++;\n      }\n\n      if (!(outpkt->serv_replies[i] & REPLY_SERVICE_TXT)) {\n        res = mdns_add_txt_answer(outpkt, outpkt->cache_flush, service);\n        if (res != ERR_OK) {\n          goto cleanup;\n        }\n        outpkt->additional++;\n      }\n    }\n\n    /* If service instance, SRV, record or an IP address is requested,\n     * supply all addresses for the host\n     */\n    if ((outpkt->serv_replies[i] & (REPLY_SERVICE_NAME_PTR | REPLY_SERVICE_SRV)) ||\n        (outpkt->host_replies & (REPLY_HOST_A | REPLY_HOST_AAAA))) {\n#if LWIP_IPV6\n      if (!(outpkt->host_replies & REPLY_HOST_AAAA)) {\n        int addrindex;\n        for (addrindex = 0; addrindex < LWIP_IPV6_NUM_ADDRESSES; ++addrindex) {\n          if (ip6_addr_isvalid(netif_ip6_addr_state(outpkt->netif, addrindex))) {\n            res = mdns_add_aaaa_answer(outpkt, outpkt->cache_flush, outpkt->netif, addrindex);\n            if (res != ERR_OK) {\n              goto cleanup;\n            }\n            outpkt->additional++;\n          }\n        }\n      }\n#endif\n#if LWIP_IPV4\n      if (!(outpkt->host_replies & REPLY_HOST_A)) {\n        res = mdns_add_a_answer(outpkt, outpkt->cache_flush, outpkt->netif);\n        if (res != ERR_OK) {\n          goto cleanup;\n        }\n        outpkt->additional++;\n      }\n#endif\n    }\n  }\n\n  if (outpkt->pbuf) {\n    const ip_addr_t *mcast_destaddr;\n    struct dns_hdr hdr;\n\n    /* Write header */\n    memset(&hdr, 0, sizeof(hdr));\n    hdr.flags1 = DNS_FLAG1_RESPONSE | DNS_FLAG1_AUTHORATIVE;\n    hdr.numanswers = lwip_htons(outpkt->answers);\n    hdr.numextrarr = lwip_htons(outpkt->additional);\n    if (outpkt->legacy_query) {\n      hdr.numquestions = lwip_htons(1);\n      hdr.id = lwip_htons(outpkt->tx_id);\n    }\n    pbuf_take(outpkt->pbuf, &hdr, sizeof(hdr));\n\n    /* Shrink packet */\n    pbuf_realloc(outpkt->pbuf, outpkt->write_offset);\n\n    if (IP_IS_V6_VAL(outpkt->dest_addr)) {\n#if LWIP_IPV6\n      mcast_destaddr = &v6group;\n#endif\n    } else {\n#if LWIP_IPV4\n      mcast_destaddr = &v4group;\n#endif\n    }\n    /* Send created packet */\n    LWIP_DEBUGF(MDNS_DEBUG, (\"MDNS: Sending packet, len=%d, unicast=%d\\n\", outpkt->write_offset, outpkt->unicast_reply));\n    if (outpkt->unicast_reply) {\n      udp_sendto_if(mdns_pcb, outpkt->pbuf, &outpkt->dest_addr, outpkt->dest_port, outpkt->netif);\n    } else {\n      udp_sendto_if(mdns_pcb, outpkt->pbuf, mcast_destaddr, MDNS_PORT, outpkt->netif);\n    }\n  }\n\ncleanup:\n  if (outpkt->pbuf) {\n    pbuf_free(outpkt->pbuf);\n    outpkt->pbuf = NULL;\n  }\n}", "path": "HarmonyOS/Huawei_LiteOS/components/net/lwip/lwip-2.0.3/src/apps/mdns/mdns.c", "commit_date": "2019-08-10 00:00:00", "repo_name": "Awesome-HarmonyOS/HarmonyOS", "stars": 19052, "license": "None", "language": "c", "size": 23807}
{"docstring": "/**\n * Internal readname function with max 6 levels of recursion following jumps\n * while decompressing name\n */\n", "func_signal": "static u16_t\nmdns_readname_loop(struct pbuf *p, u16_t offset, struct mdns_domain *domain, unsigned depth)", "code": "{\n  u8_t c;\n\n  do {\n    if (depth > 5) {\n      /* Too many jumps */\n      return MDNS_READNAME_ERROR;\n    }\n\n    c = pbuf_get_at(p, offset);\n    offset++;\n\n    /* is this a compressed label? */\n    if((c & 0xc0) == 0xc0) {\n      u16_t jumpaddr;\n      if (offset >= p->tot_len) {\n        /* Make sure both jump bytes fit in the packet */\n        return MDNS_READNAME_ERROR;\n      }\n      jumpaddr = (((c & 0x3f) << 8) | (pbuf_get_at(p, offset) & 0xff));\n      offset++;\n      if (jumpaddr >= SIZEOF_DNS_HDR && jumpaddr < p->tot_len) {\n        u16_t res;\n      /* Recursive call, maximum depth will be checked */\n        res = mdns_readname_loop(p, jumpaddr, domain, depth + 1);\n        /* Dont return offset since new bytes were not read (jumped to somewhere in packet) */\n        if (res == MDNS_READNAME_ERROR) {\n          return res;\n        }\n      } else {\n        return MDNS_READNAME_ERROR;\n      }\n      break;\n    }\n\n    /* normal label */\n    if (c <= MDNS_LABEL_MAXLEN) {\n      u8_t label[MDNS_LABEL_MAXLEN];\n      err_t res;\n\n      if (c + domain->length >= MDNS_DOMAIN_MAXLEN) {\n        return MDNS_READNAME_ERROR;\n      }\n      if (c != 0) {\n        if (pbuf_copy_partial(p, label, c, offset) != c) {\n          return MDNS_READNAME_ERROR;\n        }\n        offset += c;\n      }\n      res = mdns_domain_add_label(domain, (char *) label, c);\n      if (res != ERR_OK) {\n        return MDNS_READNAME_ERROR;\n      }\n    } else {\n      /* bad length byte */\n      return MDNS_READNAME_ERROR;\n    }\n  } while (c != 0);\n\n  return offset;\n}", "path": "HarmonyOS/Huawei_LiteOS/components/net/lwip/lwip-2.0.3/src/apps/mdns/mdns.c", "commit_date": "2019-08-10 00:00:00", "repo_name": "Awesome-HarmonyOS/HarmonyOS", "stars": 19052, "license": "None", "language": "c", "size": 23807}
{"docstring": "/**\n * @ingroup mdns\n * Add a service to the selected network interface.\n * @param netif The network interface to publish this service on\n * @param name The name of the service\n * @param service The service type, like \"_http\"\n * @param proto The service protocol, DNSSD_PROTO_TCP for TCP (\"_tcp\") and DNSSD_PROTO_UDP\n *              for others (\"_udp\")\n * @param port The port the service listens to\n * @param dns_ttl Validity time in seconds to send out for service data in DNS replies\n * @param txt_fn Callback to get TXT data. Will be called each time a TXT reply is created to\n *               allow dynamic replies.\n * @param txt_data Userdata pointer for txt_fn\n * @return ERR_OK if the service was added to the netif, an err_t otherwise\n */\n", "func_signal": "err_t\nmdns_resp_add_service(struct netif *netif, const char *name, const char *service, enum mdns_sd_proto proto, u16_t port, u32_t dns_ttl, service_get_txt_fn_t txt_fn, void *txt_data)", "code": "{\n  int i;\n  int slot = -1;\n  struct mdns_service *srv;\n  struct mdns_host* mdns;\n\n  LWIP_ASSERT(\"mdns_resp_add_service: netif != NULL\", netif);\n  mdns = NETIF_TO_HOST(netif);\n  LWIP_ERROR(\"mdns_resp_add_service: Not an mdns netif\", (mdns != NULL), return ERR_VAL);\n\n  LWIP_ERROR(\"mdns_resp_add_service: Name too long\", (strlen(name) <= MDNS_LABEL_MAXLEN), return ERR_VAL);\n  LWIP_ERROR(\"mdns_resp_add_service: Service too long\", (strlen(service) <= MDNS_LABEL_MAXLEN), return ERR_VAL);\n  LWIP_ERROR(\"mdns_resp_add_service: Bad proto (need TCP or UDP)\", (proto == DNSSD_PROTO_TCP || proto == DNSSD_PROTO_UDP), return ERR_VAL);\n\n  for (i = 0; i < MDNS_MAX_SERVICES; i++) {\n    if (mdns->services[i] == NULL) {\n      slot = i;\n      break;\n    }\n  }\n  LWIP_ERROR(\"mdns_resp_add_service: Service list full (increase MDNS_MAX_SERVICES)\", (slot >= 0), return ERR_MEM);\n\n  srv = (struct mdns_service*)mem_malloc(sizeof(struct mdns_service));\n  LWIP_ERROR(\"mdns_resp_add_service: Alloc failed\", (srv != NULL), return ERR_MEM);\n\n  memset(srv, 0, sizeof(struct mdns_service));\n\n  MEMCPY(&srv->name, name, LWIP_MIN(MDNS_LABEL_MAXLEN, strlen(name)));\n  MEMCPY(&srv->service, service, LWIP_MIN(MDNS_LABEL_MAXLEN, strlen(service)));\n  srv->txt_fn = txt_fn;\n  srv->txt_userdata = txt_data;\n  srv->proto = (u16_t)proto;\n  srv->port = port;\n  srv->dns_ttl = dns_ttl;\n\n  mdns->services[slot] = srv;\n\n  /* Announce on IPv6 and IPv4 */\n#if LWIP_IPV6\n  mdns_announce(netif, IP6_ADDR_ANY);\n#endif\n#if LWIP_IPV4\n  mdns_announce(netif, IP4_ADDR_ANY);\n#endif\n\n  return ERR_OK;\n}", "path": "HarmonyOS/Huawei_LiteOS/components/net/lwip/lwip-2.0.3/src/apps/mdns/mdns.c", "commit_date": "2019-08-10 00:00:00", "repo_name": "Awesome-HarmonyOS/HarmonyOS", "stars": 19052, "license": "None", "language": "c", "size": 23807}
{"docstring": "/**\n * @ingroup mdns\n * Initiate MDNS responder. Will open UDP sockets on port 5353\n */\n", "func_signal": "void\nmdns_resp_init(void)", "code": "{\n  err_t res;\n\n  mdns_pcb = udp_new_ip_type(IPADDR_TYPE_ANY);\n  LWIP_ASSERT(\"Failed to allocate pcb\", mdns_pcb != NULL);\n#if LWIP_MULTICAST_TX_OPTIONS\n  udp_set_multicast_ttl(mdns_pcb, MDNS_TTL);\n#else\n  mdns_pcb->ttl = MDNS_TTL;\n#endif\n  res = udp_bind(mdns_pcb, IP_ANY_TYPE, MDNS_PORT);\n  LWIP_UNUSED_ARG(res); /* in case of LWIP_NOASSERT */\n  LWIP_ASSERT(\"Failed to bind pcb\", res == ERR_OK);\n  udp_recv(mdns_pcb, mdns_recv, NULL);\n\n  mdns_netif_client_id = netif_alloc_client_data_id();\n}", "path": "HarmonyOS/Huawei_LiteOS/components/net/lwip/lwip-2.0.3/src/apps/mdns/mdns.c", "commit_date": "2019-08-10 00:00:00", "repo_name": "Awesome-HarmonyOS/HarmonyOS", "stars": 19052, "license": "None", "language": "c", "size": 23807}
{"docstring": "/**\n * Read a question from the packet.\n * All questions have to be read before the answers.\n * @param pkt The MDNS packet to read from. The questions_left field will be decremented\n *            and the parse_offset will be updated.\n * @param question The struct to fill with question data\n * @return ERR_OK on success, an err_t otherwise\n */\n", "func_signal": "static err_t\nmdns_read_question(struct mdns_packet *pkt, struct mdns_question *question)", "code": "{\n  /* Safety check */\n  if (pkt->pbuf->tot_len < pkt->parse_offset) {\n    return ERR_VAL;\n  }\n\n  if (pkt->questions_left) {\n    err_t res;\n    pkt->questions_left--;\n\n    memset(question, 0, sizeof(struct mdns_question));\n    res = mdns_read_rr_info(pkt, &question->info);\n    if (res != ERR_OK) {\n      return res;\n    }\n\n    /* Extract unicast flag from class field */\n    question->unicast = question->info.klass & 0x8000;\n    question->info.klass &= 0x7FFF;\n\n    return ERR_OK;\n  }\n  return ERR_VAL;\n}", "path": "HarmonyOS/Huawei_LiteOS/components/net/lwip/lwip-2.0.3/src/apps/mdns/mdns.c", "commit_date": "2019-08-10 00:00:00", "repo_name": "Awesome-HarmonyOS/HarmonyOS", "stars": 19052, "license": "None", "language": "c", "size": 23807}
{"docstring": "/** Write an IPv6 address (AAAA) RR to outpacket */\n", "func_signal": "static err_t\nmdns_add_aaaa_answer(struct mdns_outpacket *reply, u16_t cache_flush, struct netif *netif, int addrindex)", "code": "{\n  struct mdns_domain host;\n  mdns_build_host_domain(&host, NETIF_TO_HOST(netif));\n  LWIP_DEBUGF(MDNS_DEBUG, (\"MDNS: Responding with AAAA record\\n\"));\n  return mdns_add_answer(reply, &host, DNS_RRTYPE_AAAA, DNS_RRCLASS_IN, cache_flush, (NETIF_TO_HOST(netif))->dns_ttl, (const u8_t *) netif_ip6_addr(netif, addrindex), sizeof(ip6_addr_t), NULL);\n}", "path": "HarmonyOS/Huawei_LiteOS/components/net/lwip/lwip-2.0.3/src/apps/mdns/mdns.c", "commit_date": "2019-08-10 00:00:00", "repo_name": "Awesome-HarmonyOS/HarmonyOS", "stars": 19052, "license": "None", "language": "c", "size": 23807}
{"docstring": "/** Write a 4.3.2.1.in-addr.arpa -> hostname.local PTR RR to outpacket */\n", "func_signal": "static err_t\nmdns_add_hostv4_ptr_answer(struct mdns_outpacket *reply, u16_t cache_flush, struct netif *netif)", "code": "{\n  struct mdns_domain host, revhost;\n  mdns_build_host_domain(&host, NETIF_TO_HOST(netif));\n  mdns_build_reverse_v4_domain(&revhost, netif_ip4_addr(netif));\n  LWIP_DEBUGF(MDNS_DEBUG, (\"MDNS: Responding with v4 PTR record\\n\"));\n  return mdns_add_answer(reply, &revhost, DNS_RRTYPE_PTR, DNS_RRCLASS_IN, cache_flush, (NETIF_TO_HOST(netif))->dns_ttl, NULL, 0, &host);\n}", "path": "HarmonyOS/Huawei_LiteOS/components/net/lwip/lwip-2.0.3/src/apps/mdns/mdns.c", "commit_date": "2019-08-10 00:00:00", "repo_name": "Awesome-HarmonyOS/HarmonyOS", "stars": 19052, "license": "None", "language": "c", "size": 23807}
{"docstring": "/**\n * Return 1 if contents of domains match (case-insensitive)\n * @param a Domain name to compare 1\n * @param b Domain name to compare 2\n * @return 1 if domains are equal ignoring case, 0 otherwise\n */\n", "func_signal": "int\nmdns_domain_eq(struct mdns_domain *a, struct mdns_domain *b)", "code": "{\n  u8_t *ptra, *ptrb;\n  u8_t len;\n  int res;\n\n  if (a->length != b->length) {\n    return 0;\n  }\n\n  ptra = a->name;\n  ptrb = b->name;\n  while (*ptra && *ptrb && ptra < &a->name[a->length]) {\n    if (*ptra != *ptrb) {\n      return 0;\n    }\n    len = *ptra;\n    ptra++;\n    ptrb++;\n    res = lwip_strnicmp((char *) ptra, (char *) ptrb, len);\n    if (res != 0) {\n      return 0;\n    }\n    ptra += len;\n    ptrb += len;\n  }\n  if (*ptra != *ptrb && ptra < &a->name[a->length]) {\n    return 0;\n  }\n  return 1;\n}", "path": "HarmonyOS/Huawei_LiteOS/components/net/lwip/lwip-2.0.3/src/apps/mdns/mdns.c", "commit_date": "2019-08-10 00:00:00", "repo_name": "Awesome-HarmonyOS/HarmonyOS", "stars": 19052, "license": "None", "language": "c", "size": 23807}
{"docstring": "/**\n * Write a question to an outpacket\n * A question contains domain, type and class. Since an answer also starts with these fields this function is also\n * called from mdns_add_answer().\n * @param outpkt The outpacket to write to\n * @param domain The domain name the answer is for\n * @param type The DNS type of the answer (like 'AAAA', 'SRV')\n * @param klass The DNS type of the answer (like 'IN')\n * @param unicast If highest bit in class should be set, to instruct the responder to\n *                reply with a unicast packet\n * @return ERR_OK on success, an err_t otherwise\n */\n", "func_signal": "static err_t\nmdns_add_question(struct mdns_outpacket *outpkt, struct mdns_domain *domain, u16_t type, u16_t klass, u16_t unicast)", "code": "{\n  u16_t question_len;\n  u16_t field16;\n  err_t res;\n\n  if (!outpkt->pbuf) {\n    /* If no pbuf is active, allocate one */\n    outpkt->pbuf = pbuf_alloc(PBUF_TRANSPORT, OUTPACKET_SIZE, PBUF_RAM);\n    if (!outpkt->pbuf) {\n      return ERR_MEM;\n    }\n    outpkt->write_offset = SIZEOF_DNS_HDR;\n  }\n\n  /* Worst case calculation. Domain string might be compressed */\n  question_len = domain->length + sizeof(type) + sizeof(klass);\n  if (outpkt->write_offset + question_len > outpkt->pbuf->tot_len) {\n    /* No space */\n    return ERR_MEM;\n  }\n\n  /* Write name */\n  res = mdns_write_domain(outpkt, domain);\n  if (res != ERR_OK) {\n    return res;\n  }\n\n  /* Write type */\n  field16 = lwip_htons(type);\n  res = pbuf_take_at(outpkt->pbuf, &field16, sizeof(field16), outpkt->write_offset);\n  if (res != ERR_OK) {\n    return res;\n  }\n  outpkt->write_offset += sizeof(field16);\n\n  /* Write class */\n  if (unicast) {\n    klass |= 0x8000;\n  }\n  field16 = lwip_htons(klass);\n  res = pbuf_take_at(outpkt->pbuf, &field16, sizeof(field16), outpkt->write_offset);\n  if (res != ERR_OK) {\n    return res;\n  }\n  outpkt->write_offset += sizeof(field16);\n\n  return ERR_OK;\n}", "path": "HarmonyOS/Huawei_LiteOS/components/net/lwip/lwip-2.0.3/src/apps/mdns/mdns.c", "commit_date": "2019-08-10 00:00:00", "repo_name": "Awesome-HarmonyOS/HarmonyOS", "stars": 19052, "license": "None", "language": "c", "size": 23807}
{"docstring": "/*!\n\t\\brief \tThis function creates a sync object\n\n\tThe sync object is used for synchronization between different thread or ISR and\n\ta thread.\n\n\t\\param\tpSyncObj\t-\tpointer to the sync object control block\n\n\t\\return upon successful creation the function should return 0\n\t\t\tOtherwise, a negative value indicating the error code shall be returned\n\t\\note\n\t\\warning\n*/\n", "func_signal": "OsiReturnVal_e osi_SyncObjCreate(OsiSyncObj_t* pSyncObj)", "code": "{\n    SemaphoreHandle_t *pl_SyncObj = (SemaphoreHandle_t *)pSyncObj;\n\n    *pl_SyncObj = xSemaphoreCreateBinary();\n\n    ASSERT (*pSyncObj != NULL);\n\n    return OSI_OK;\n}", "path": "micropython/ports/cc3200/simplelink/oslib/osi_freertos.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython", "stars": 18067, "license": "other", "language": "c", "size": 63034}
{"docstring": "/*!\n\t\\brief \tThis function deletes a locking object.\n\n\t\\param\tpLockObj\t-\tpointer to the locking object control block\n\n\t\\return upon successful deletion the function should return 0\n\t\t\tOtherwise, a negative value indicating the error code shall be returned\n\t\\note\n\t\\warning\n*/\n", "func_signal": "OsiReturnVal_e _osi_LockObjDelete(OsiLockObj_t* pLockObj)", "code": "{\n    vSemaphoreDelete((SemaphoreHandle_t)*pLockObj );\n    return OSI_OK;\n}", "path": "micropython/ports/cc3200/simplelink/oslib/osi_freertos.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython", "stars": 18067, "license": "other", "language": "c", "size": 63034}
{"docstring": "/*!\n\t\\brief \tThis function is used to create the MsgQ\n\n\t\\param\tpMsgQ\t-\tpointer to the message queue\n\t\\param\tpMsgQName\t-\tmsg queue name\n\t\\param\tMsgSize\t-\tsize of message on the queue\n\t\\param\tMaxMsgs\t-\tmax. number of msgs that the queue can hold\n\n\t\\return - OsiReturnVal_e\n\t\\note\n\t\\warning\n*/\n", "func_signal": "OsiReturnVal_e osi_MsgQCreate(OsiMsgQ_t* \t\tpMsgQ , \n\t\t\t      char*\t\t\tpMsgQName,\n\t\t\t      unsigned long \t\tMsgSize,\n\t\t\t      unsigned long\t\tMaxMsgs)", "code": "{\n\tQueueHandle_t handle;\n\n\t//Create Queue\n\thandle = xQueueCreate( MaxMsgs, MsgSize );\n\tASSERT (handle != NULL);\n\n\t*pMsgQ = (OsiMsgQ_t)handle;\n\treturn OSI_OK;\n}", "path": "micropython/ports/cc3200/simplelink/oslib/osi_freertos.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython", "stars": 18067, "license": "other", "language": "c", "size": 63034}
{"docstring": "/*!\n\t\\brief \t\tThis function generates a sync signal for the object\n\t\t\t\tfrom ISR context.\n\n\tAll suspended threads waiting on this sync object are resumed\n\n\t\\param\t\tpSyncObj\t-\tpointer to the sync object control block\n\n\t\\return \tupon successful signalling the function should return 0\n\t\t\t\tOtherwise, a negative value indicating the error code shall be returned\n\t\\note\t\tthe function is called from ISR context\n\t\\warning\n*/\n", "func_signal": "OsiReturnVal_e osi_SyncObjSignalFromISR(OsiSyncObj_t* pSyncObj)", "code": "{\n\txHigherPriorityTaskWoken = pdFALSE;\n\tif(pdTRUE == xSemaphoreGiveFromISR( *pSyncObj, &xHigherPriorityTaskWoken ))\n\t{\n\t\tif( xHigherPriorityTaskWoken )\n\t\t{\n\t\t\ttaskYIELD ();\n\t\t}\n\t}\n\treturn OSI_OK;\n}", "path": "micropython/ports/cc3200/simplelink/oslib/osi_freertos.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython", "stars": 18067, "license": "other", "language": "c", "size": 63034}
{"docstring": "/*!\n\t\\brief \tThis function clears a sync object\n\n\t\\param\tpSyncObj\t-\tpointer to the sync object control block\n\n\t\\return upon successful clearing the function should return 0\n\t\t\tOtherwise, a negative value indicating the error code shall be returned\n\t\\note\n\t\\warning\n*/\n", "func_signal": "OsiReturnVal_e osi_SyncObjClear(OsiSyncObj_t* pSyncObj)", "code": "{\n    if (OSI_OK == osi_SyncObjWait(pSyncObj,0) )\n    {\n        return OSI_OK;\n    }\n    else\n    {\n        return OSI_OPERATION_FAILED;\n    }\n}", "path": "micropython/ports/cc3200/simplelink/oslib/osi_freertos.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython", "stars": 18067, "license": "other", "language": "c", "size": 63034}
{"docstring": "/*!\n\t\\brief \tThis function is used to write data to the MsgQ\n\n\t\\param\tpMsgQ\t-\tpointer to the message queue\n\t\\param\tpMsg\t-\tpointer to the Msg strut to read into\n\t\\param\tTimeout\t-\ttimeout to wait for the Msg to be available\n\n\t\\return - OsiReturnVal_e\n\t\\note\n\t\\warning\n*/\n", "func_signal": "OsiReturnVal_e osi_MsgQWrite(OsiMsgQ_t* pMsgQ, void* pMsg , OsiTime_t Timeout)", "code": "{\n\txHigherPriorityTaskWoken = pdFALSE;\n    if(pdPASS == xQueueSendFromISR((QueueHandle_t) *pMsgQ, pMsg, &xHigherPriorityTaskWoken ))\n    {\n\t\ttaskYIELD ();\n\t\treturn OSI_OK;\n    }\n\telse\n\t{\n\t\treturn OSI_OPERATION_FAILED;\n\t}\n}", "path": "micropython/ports/cc3200/simplelink/oslib/osi_freertos.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython", "stars": 18067, "license": "other", "language": "c", "size": 63034}
{"docstring": "/*!\n\t\\brief \tThis is the API to delete SL spawn task and delete the SL queue\n\n\t\\param\tnone\n\n\t\\return void\n\t\\note\n\t\\warning\n*/\n", "func_signal": "void VDeleteSimpleLinkSpawnTask( void )", "code": "{\n\tif(xSimpleLinkSpawnTaskHndl)\n\t{\n\t\tvTaskDelete( xSimpleLinkSpawnTaskHndl );\n\t\txSimpleLinkSpawnTaskHndl = 0;\n\t}\n\n\tif(xSimpleLinkSpawnQueue)\n\t{\n\t\tvQueueDelete( xSimpleLinkSpawnQueue );\n\t\txSimpleLinkSpawnQueue = 0;\n\t}\n}", "path": "micropython/ports/cc3200/simplelink/oslib/osi_freertos.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython", "stars": 18067, "license": "other", "language": "c", "size": 63034}
{"docstring": "/*!\n\t\\brief \tThis function De registers an interrupt in NVIC table\n\n\n\t\\param\tiIntrNum\t-\tInterrupt number to De register\n\n\t\\return \tnone\n\t\\note\n\t\\warning\n*/\n", "func_signal": "void osi_InterruptDeRegister(int iIntrNum)", "code": "{\n\tMAP_IntDisable(iIntrNum);\n\tMAP_IntUnregister(iIntrNum);\n}", "path": "micropython/ports/cc3200/simplelink/oslib/osi_freertos.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython", "stars": 18067, "license": "other", "language": "c", "size": 63034}
{"docstring": "/*!\n\t\\brief \tThis is the API to create SL spawn task and create the SL queue\n\n\t\\param\tuxPriority\t\t-\ttask priority\n\n\t\\return void\n\t\\note\n\t\\warning\n*/\n", "func_signal": "__attribute__ ((section (\".boot\")))\nOsiReturnVal_e VStartSimpleLinkSpawnTask(unsigned portBASE_TYPE uxPriority)", "code": "{\n    xSimpleLinkSpawnQueue = xQueueCreate( slQUEUE_SIZE, sizeof( tSimpleLinkSpawnMsg ) );\n    ASSERT (xSimpleLinkSpawnQueue != NULL);\n\n    /*\n    // This is the original code to create a task dynamically\n    ASSERT (pdPASS == xTaskCreate( vSimpleLinkSpawnTask, ( portCHAR * ) \"SLSPAWN\",\\\n                                   896 / sizeof(portSTACK_TYPE), NULL, uxPriority, &xSimpleLinkSpawnTaskHndl ));\n    */\n\n    // This code creates the task using static memory for the TCB and stack\n    xSimpleLinkSpawnTaskHndl = xTaskCreateStatic(\n        vSimpleLinkSpawnTask, ( portCHAR * ) \"SLSPAWN\",\n        896 / sizeof(portSTACK_TYPE), NULL, uxPriority,\n        spawnTaskStack, &spawnTaskTCB);\n\n    ASSERT(xSimpleLinkSpawnTaskHndl != NULL);\n\n    return OSI_OK;\n}", "path": "micropython/ports/cc3200/simplelink/oslib/osi_freertos.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython", "stars": 18067, "license": "other", "language": "c", "size": 63034}
{"docstring": "/*!\n\t\\brief \tThis is the simplelink spawn task to call SL callback from a different context \n\n\t\\param\tpvParameters\t\t-\tpointer to the task parameter\n\n\t\\return void\n\t\\note\n\t\\warning\n*/\n", "func_signal": "void vSimpleLinkSpawnTask(void *pvParameters)", "code": "{\n\ttSimpleLinkSpawnMsg Msg;\n\tportBASE_TYPE ret;\n\n\tfor(;;)\n\t{\n\t\tret = xQueueReceive( xSimpleLinkSpawnQueue, &Msg, SL_SPAWN_MAX_WAIT_MS);\n\t\tif(ret == pdPASS)\n\t\t{\n\t\t\t\tMsg.pEntry(Msg.pValue);\n\t\t}\n        // set the alive flag for the wdt\n        pybwdt_sl_alive();\n\t}\n}", "path": "micropython/ports/cc3200/simplelink/oslib/osi_freertos.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython", "stars": 18067, "license": "other", "language": "c", "size": 63034}
{"docstring": "/*!\n\t\\brief \tThis function registers an interrupt in NVIC table\n\n\tThe sync object is used for synchronization between different thread or ISR and\n\ta thread.\n\n\t\\param\tiIntrNum\t-\tInterrupt number to register\n\t\\param\tpEntry\t    -\tPointer to the interrupt handler\n\t\\param\tucPriority\t-\tpriority of the interrupt\n\n\t\\return upon successful creation the function should return 0\n\t\t\tOtherwise, a negative value indicating the error code shall be returned\n\t\\note\n\t\\warning\n*/\n", "func_signal": "OsiReturnVal_e osi_InterruptRegister(int iIntrNum,P_OSI_INTR_ENTRY pEntry,unsigned char ucPriority)", "code": "{\n\tMAP_IntRegister(iIntrNum,(void(*)(void))pEntry);\n\tMAP_IntPrioritySet(iIntrNum, ucPriority);\n\tMAP_IntEnable(iIntrNum);\n\treturn OSI_OK;\n}", "path": "micropython/ports/cc3200/simplelink/oslib/osi_freertos.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython", "stars": 18067, "license": "other", "language": "c", "size": 63034}
{"docstring": "/*!\n\t\\brief \tThis function is used to read data from the MsgQ\n\n\t\\param\tpMsgQ\t-\tpointer to the message queue\n\t\\param\tpMsg\t-\tpointer to the Msg strut to read into\n\t\\param\tTimeout\t-\ttimeout to wait for the Msg to be available\n\n\t\\return - OsiReturnVal_e\n\t\\note\n\t\\warning\n*/\n", "func_signal": "OsiReturnVal_e osi_MsgQRead(OsiMsgQ_t* pMsgQ, void* pMsg , OsiTime_t Timeout)", "code": "{\n\t//Receive Item from Queue\n\tif( pdTRUE  == xQueueReceive((QueueHandle_t)*pMsgQ,pMsg,Timeout) )\n\t{\n\t\treturn OSI_OK;\n\t}\n\telse\n\t{\n\t\treturn OSI_OPERATION_FAILED;\n\t}\n}", "path": "micropython/ports/cc3200/simplelink/oslib/osi_freertos.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython", "stars": 18067, "license": "other", "language": "c", "size": 63034}
{"docstring": "/*!\n\t\\brief \tThis function creates a locking object.\n\n\tThe locking object is used for protecting a shared resources between different\n\tthreads.\n\n\t\\param\tpLockObj\t-\tpointer to the locking object control block\n\n\t\\return upon successful creation the function should return 0\n\t\t\tOtherwise, a negative value indicating the error code shall be returned\n\t\\note\n\t\\warning\n*/\n", "func_signal": "OsiReturnVal_e osi_LockObjCreate(OsiLockObj_t* pLockObj)", "code": "{\n    SemaphoreHandle_t *pl_LockObj = (SemaphoreHandle_t *)pLockObj;\n\n    vSemaphoreCreateBinary(*pl_LockObj);\n\n    ASSERT (*pLockObj != NULL);\n\n    return OSI_OK;\n}", "path": "micropython/ports/cc3200/simplelink/oslib/osi_freertos.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython", "stars": 18067, "license": "other", "language": "c", "size": 63034}
{"docstring": "/*!\n\t\\brief \tThis function deletes a sync object\n\n\t\\param\tpSyncObj\t-\tpointer to the sync object control block\n\n\t\\return upon successful deletion the function should return 0\n\t\t\tOtherwise, a negative value indicating the error code shall be returned\n\t\\note\n\t\\warning\n*/\n", "func_signal": "OsiReturnVal_e osi_SyncObjDelete(OsiSyncObj_t* pSyncObj)", "code": "{\n    vSemaphoreDelete(*pSyncObj );\n    return OSI_OK;\n}", "path": "micropython/ports/cc3200/simplelink/oslib/osi_freertos.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython", "stars": 18067, "license": "other", "language": "c", "size": 63034}
{"docstring": "/*!\n\t\\brief \tThis function call the pEntry callback from a different context\n\n\t\\param\tpEntry\t\t-\tpointer to the entry callback function\n\n\t\\param\tpValue\t\t- \tpointer to any type of memory structure that would be\n\t\t\t\t\t\t\tpassed to pEntry callback from the execution thread.\n\n\t\\param\tflags\t\t- \texecution flags - reserved for future usage\n\n\t\\return upon successful registration of the spawn the function should return 0\n\t\t\t(the function is not blocked till the end of the execution of the function\n\t\t\tand could be returned before the execution is actually completed)\n\t\t\tOtherwise, a negative value indicating the error code shall be returned\n\t\\note\n\t\\warning\n*/\n", "func_signal": "OsiReturnVal_e osi_Spawn(P_OSI_SPAWN_ENTRY pEntry , void* pValue , unsigned long flags)", "code": "{\n\n\ttSimpleLinkSpawnMsg Msg;\n\tMsg.pEntry = pEntry;\n\tMsg.pValue = pValue;\n\txHigherPriorityTaskWoken = pdFALSE;\n\n\tif(pdTRUE == xQueueSendFromISR( xSimpleLinkSpawnQueue, &Msg, &xHigherPriorityTaskWoken ))\n\t{\n\t\tif( xHigherPriorityTaskWoken )\n\t\t{\n\t\t\ttaskYIELD ();\n\t\t}\n\t\treturn OSI_OK;\n\t}\n\treturn OSI_OPERATION_FAILED;\n}", "path": "micropython/ports/cc3200/simplelink/oslib/osi_freertos.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython", "stars": 18067, "license": "other", "language": "c", "size": 63034}
{"docstring": "/*!\n\t\\brief \tThis function locks a locking object.\n\n\tAll other threads that call this function before this thread calls\n\tthe osi_LockObjUnlock would be suspended\n\n\t\\param\tpLockObj\t-\tpointer to the locking object control block\n\t\\param\tTimeout\t\t-\tnumeric value specifies the maximum number of mSec to\n\t\t\t\t\t\t\tstay suspended while waiting for the locking object\n\t\t\t\t\t\t\tCurrently, the simple link driver uses only two values:\n\t\t\t\t\t\t\t\t- OSI_WAIT_FOREVER\n\t\t\t\t\t\t\t\t- OSI_NO_WAIT\n\n\n\t\\return upon successful reception of the locking object the function should return 0\n\t\t\tOtherwise, a negative value indicating the error code shall be returned\n\t\\note\n\t\\warning\n*/\n", "func_signal": "OsiReturnVal_e _osi_LockObjLock(OsiLockObj_t* pLockObj , OsiTime_t Timeout)", "code": "{\n    //Take Semaphore\n    if(pdTRUE == xSemaphoreTake( *pLockObj, ( TickType_t ) Timeout ))\n    {\n        return OSI_OK;\n    }\n    else\n    {\n        return OSI_OPERATION_FAILED;\n    }\n}", "path": "micropython/ports/cc3200/simplelink/oslib/osi_freertos.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython", "stars": 18067, "license": "other", "language": "c", "size": 63034}
{"docstring": "/*!\n\t\\brief \tThis function unlock a locking object.\n\n\t\\param\tpLockObj\t-\tpointer to the locking object control block\n\n\t\\return upon successful unlocking the function should return 0\n\t\t\tOtherwise, a negative value indicating the error code shall be returned\n\t\\note\n\t\\warning\n*/\n", "func_signal": "OsiReturnVal_e _osi_LockObjUnlock(OsiLockObj_t* pLockObj)", "code": "{\n\t//Release Semaphore\n    if(pdTRUE == xSemaphoreGive( *pLockObj ))\n    {\n    \treturn OSI_OK;\n    }\n    else\n    {\n    \treturn OSI_OPERATION_FAILED;\n    }\n}", "path": "micropython/ports/cc3200/simplelink/oslib/osi_freertos.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython", "stars": 18067, "license": "other", "language": "c", "size": 63034}
{"docstring": "/*!\n\t\\brief \tThis function creates a Task.\n\n\tCreates a new Task and add it to the last of tasks that are ready to run\n\n\t\\param\tpEntry\t-\tpointer to the Task Function\n\t\\param\tpcName\t-\tTask Name String\n\t\\param\tusStackDepth\t-\tStack Size in bytes\n\t\\param\tpvParameters\t-\tpointer to structure to be passed to the Task Function\n\t\\param\tuxPriority\t-\tTask Priority\n\n\t\\return upon successful creation the function should return 0\n\t\t\tOtherwise, a negative value indicating the error code shall be returned\n\t\\note\n\t\\warning\n*/\n", "func_signal": "OsiReturnVal_e osi_TaskCreate(P_OSI_TASK_ENTRY pEntry,const signed char * const pcName,\n                              unsigned short usStackDepth, void *pvParameters,\n                              unsigned long uxPriority,OsiTaskHandle* pTaskHandle)", "code": "{\n\tASSERT (pdPASS == xTaskCreate( pEntry, (char const*)pcName,\n                                (usStackDepth/(sizeof( portSTACK_TYPE ))), \n                                pvParameters,(unsigned portBASE_TYPE)uxPriority,\n                                (TaskHandle_t*)pTaskHandle ));\n\treturn OSI_OK;\n}", "path": "micropython/ports/cc3200/simplelink/oslib/osi_freertos.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython", "stars": 18067, "license": "other", "language": "c", "size": 63034}
{"docstring": "/*!\n\t\\brief \t\tThis function generates a sync signal for the object.\n\n\tAll suspended threads waiting on this sync object are resumed\n\n\t\\param\t\tpSyncObj\t-\tpointer to the sync object control block\n\n\t\\return \tupon successful signaling the function should return 0\n\t\t\t\tOtherwise, a negative value indicating the error code shall be returned\n\t\\note\t\tthe function could be called from ISR context\n\t\\warning\n*/\n", "func_signal": "OsiReturnVal_e osi_SyncObjSignal(OsiSyncObj_t* pSyncObj)", "code": "{\n    xSemaphoreGive( *pSyncObj );\n    return OSI_OK;\n}", "path": "micropython/ports/cc3200/simplelink/oslib/osi_freertos.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython", "stars": 18067, "license": "other", "language": "c", "size": 63034}
{"docstring": "/*!\n\t\\brief \tThis function is used to delete the MsgQ\n\n\t\\param\tpMsgQ\t-\tpointer to the message queue\n\n\t\\return - OsiReturnVal_e\n\t\\note\n\t\\warning\n*/\n", "func_signal": "OsiReturnVal_e osi_MsgQDelete(OsiMsgQ_t* pMsgQ)", "code": "{\n\tvQueueDelete((QueueHandle_t) *pMsgQ );\n    return OSI_OK;\n}", "path": "micropython/ports/cc3200/simplelink/oslib/osi_freertos.c", "commit_date": "2017-09-06 00:00:00", "repo_name": "micropython/micropython", "stars": 18067, "license": "other", "language": "c", "size": 63034}
{"docstring": "/* This function packages up the logic of adding a character or range of\ncharacters to a class. The character values in the arguments will be within the\nvalid values for the current mode (8-bit, 16-bit, UTF, etc). This function is\nmutually recursive with the function immediately below.\n\nArguments:\n  classbits     the bit map for characters < 256\n  uchardptr     points to the pointer for extra data\n  options       the options word\n  cd            contains pointers to tables etc.\n  start         start of range character\n  end           end of range character\n\nReturns:        the number of < 256 characters added\n                the pointer to extra data is updated\n*/\n", "func_signal": "static int\nadd_to_class(pcre_uint8 *classbits, pcre_uchar **uchardptr, int options,\n  compile_data *cd, pcre_uint32 start, pcre_uint32 end)", "code": "{\npcre_uint32 c;\npcre_uint32 classbits_end = (end <= 0xff ? end : 0xff);\nint n8 = 0;\n\n((void)uchardptr);\n((void)propposstab);\n((void)catposstab);\n((void)posspropstab);\n\n/* If caseless matching is required, scan the range and process alternate\ncases. In Unicode, there are 8-bit characters that have alternate cases that\nare greater than 255 and vice-versa. Sometimes we can just extend the original\nrange. */\n\nif ((options & PCRE_CASELESS) != 0)\n  {\n#ifdef SUPPORT_UCP\n  if ((options & PCRE_UTF8) != 0)\n    {\n    int rc;\n    pcre_uint32 oc, od;\n\n    options &= ~PCRE_CASELESS;   /* Remove for recursive calls */\n    c = start;\n\n    while ((rc = get_othercase_range(&c, end, &oc, &od)) >= 0)\n      {\n      /* Handle a single character that has more than one other case. */\n\n      if (rc > 0) n8 += add_list_to_class(classbits, uchardptr, options, cd,\n        PRIV(ucd_caseless_sets) + rc, oc);\n\n      /* Do nothing if the other case range is within the original range. */\n\n      else if (oc >= start && od <= end) continue;\n\n      /* Extend the original range if there is overlap, noting that if oc < c, we\n      can't have od > end because a subrange is always shorter than the basic\n      range. Otherwise, use a recursive call to add the additional range. */\n\n      else if (oc < start && od >= start - 1) start = oc; /* Extend downwards */\n      else if (od > end && oc <= end + 1)\n        {\n        end = od;       /* Extend upwards */\n        if (end > classbits_end) classbits_end = (end <= 0xff ? end : 0xff);\n        }\n      else n8 += add_to_class(classbits, uchardptr, options, cd, oc, od);\n      }\n    }\n  else\n#endif  /* SUPPORT_UCP */\n\n  /* Not UTF-mode, or no UCP */\n\n  for (c = start; c <= classbits_end; c++)\n    {\n    SETBIT(classbits, cd->fcc[c]);\n    n8++;\n    }\n  }\n\n/* Now handle the original range. Adjust the final value according to the bit\nlength - this means that the same lists of (e.g.) horizontal spaces can be used\nin all cases. */\n\n#if defined COMPILE_PCRE8\n#ifdef SUPPORT_UTF\n  if ((options & PCRE_UTF8) == 0)\n#endif\n  if (end > 0xff) end = 0xff;\n\n#elif defined COMPILE_PCRE16\n#ifdef SUPPORT_UTF\n  if ((options & PCRE_UTF16) == 0)\n#endif\n  if (end > 0xffff) end = 0xffff;\n\n#endif /* COMPILE_PCRE[8|16] */\n\n/* Use the bitmap for characters < 256. Otherwise use extra data.*/\n\nfor (c = start; c <= classbits_end; c++)\n  {\n  /* Regardless of start, c will always be <= 255. */\n  SETBIT(classbits, c);\n  n8++;\n  }\n\n#if defined SUPPORT_UTF || !defined COMPILE_PCRE8\nif (start <= 0xff) start = 0xff + 1;\n\nif (end >= start)\n  {\n  pcre_uchar *uchardata = *uchardptr;\n#ifdef SUPPORT_UTF\n  if ((options & PCRE_UTF8) != 0)  /* All UTFs use the same flag bit */\n    {\n    if (start < end)\n      {\n      *uchardata++ = XCL_RANGE;\n      uchardata += PRIV(ord2utf)(start, uchardata);\n      uchardata += PRIV(ord2utf)(end, uchardata);\n      }\n    else if (start == end)\n      {\n      *uchardata++ = XCL_SINGLE;\n      uchardata += PRIV(ord2utf)(start, uchardata);\n      }\n    }\n  else\n#endif  /* SUPPORT_UTF */\n\n  /* Without UTF support, character values are constrained by the bit length,\n  and can only be > 256 for 16-bit and 32-bit libraries. */\n\n#ifdef COMPILE_PCRE8\n    {}\n#else\n  if (start < end)\n    {\n    *uchardata++ = XCL_RANGE;\n    *uchardata++ = start;\n    *uchardata++ = end;\n    }\n  else if (start == end)\n    {\n    *uchardata++ = XCL_SINGLE;\n    *uchardata++ = start;\n    }\n#endif\n\n  *uchardptr = uchardata;   /* Updata extra data pointer */\n  }\n#endif /* SUPPORT_UTF || !COMPILE_PCRE8 */\n\nreturn n8;    /* Number of 8-bit characters */\n}", "path": "libgit2/deps/pcre/pcre_compile.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "libgit2/libgit2", "stars": 9365, "license": "other", "language": "c", "size": 70878}
{"docstring": "/* This function releases all the allocated frames. The base frame is on the\nmachine stack, and so must not be freed.\n\nArgument: the address of the base frame\nReturns:  nothing\n*/\n", "func_signal": "static void\nrelease_match_heapframes (heapframe *frame_base)", "code": "{\nheapframe *nextframe = frame_base->Xnextframe;\nwhile (nextframe != NULL)\n  {\n  heapframe *oldframe = nextframe;\n  nextframe = nextframe->Xnextframe;\n  (PUBL(stack_free))(oldframe);\n  }\n}", "path": "libgit2/deps/pcre/pcre_exec.c", "commit_date": "2019-05-19 00:00:00", "repo_name": "libgit2/libgit2", "stars": 9365, "license": "other", "language": "c", "size": 70878}
{"docstring": "/**\n * #### Writing Commits\n *\n * libgit2 provides a couple of methods to create commit objects easily as\n * well. There are four different create signatures, we'll just show one\n * of them here.  You can read about the other ones in the [commit API\n * docs][cd].\n *\n * [cd]: http://libgit2.github.com/libgit2/#HEAD/group/commit\n */\n", "func_signal": "static void commit_writing(git_repository *repo)", "code": "{\n\tgit_oid tree_id, parent_id, commit_id;\n\tgit_tree *tree;\n\tgit_commit *parent;\n\tgit_signature *author, *committer;\n\tchar oid_hex[GIT_OID_HEXSZ+1] = { 0 };\n\n\tprintf(\"\\n*Commit Writing*\\n\");\n\n\t/**\n\t * Creating signatures for an authoring identity and time is simple.  You\n\t * will need to do this to specify who created a commit and when.  Default\n\t * values for the name and email should be found in the `user.name` and\n\t * `user.email` configuration options.  See the `config` section of this\n\t * example file to see how to access config values.\n\t */\n\tgit_signature_new(&author,\n\t\t\t\"Scott Chacon\", \"schacon@gmail.com\", 123456789, 60);\n\tgit_signature_new(&committer,\n\t\t\t\"Scott A Chacon\", \"scott@github.com\", 987654321, 90);\n\n\t/**\n\t * Commit objects need a tree to point to and optionally one or more\n\t * parents.  Here we're creating oid objects to create the commit with,\n\t * but you can also use\n\t */\n\tgit_oid_fromstr(&tree_id, \"f60079018b664e4e79329a7ef9559c8d9e0378d1\");\n\tgit_tree_lookup(&tree, repo, &tree_id);\n\tgit_oid_fromstr(&parent_id, \"5b5b025afb0b4c913b4c338a42934a3863bf3644\");\n\tgit_commit_lookup(&parent, repo, &parent_id);\n\n\t/**\n\t * Here we actually create the commit object with a single call with all\n\t * the values we need to create the commit.  The SHA key is written to the\n\t * `commit_id` variable here.\n\t */\n\tgit_commit_create_v(\n\t\t\t&commit_id, /* out id */\n\t\t\trepo,\n\t\t\tNULL, /* do not update the HEAD */\n\t\t\tauthor,\n\t\t\tcommitter,\n\t\t\tNULL, /* use default message encoding */\n\t\t\t\"example commit\",\n\t\t\ttree,\n\t\t\t1, parent);\n\n\t/**\n\t * Now we can take a look at the commit SHA we've generated.\n\t */\n\tgit_oid_fmt(oid_hex, &commit_id);\n\tprintf(\"New Commit: %s\\n\", oid_hex);\n\n\t/**\n\t * Free all objects used in the meanwhile.\n\t */\n\tgit_tree_free(tree);\n\tgit_commit_free(parent);\n\tgit_signature_free(author);\n\tgit_signature_free(committer);\n}", "path": "libgit2/examples/general.c", "commit_date": "2020-06-01 00:00:00", "repo_name": "libgit2/libgit2", "stars": 9365, "license": "other", "language": "c", "size": 70878}
{"docstring": "/* This little function scans through a compiled pattern until it finds an\ninstance of OP_RECURSE.\n\nArguments:\n  code        points to start of expression\n  utf         TRUE in UTF-8 / UTF-16 / UTF-32 mode\n\nReturns:      pointer to the opcode for OP_RECURSE, or NULL if not found\n*/\n", "func_signal": "static const pcre_uchar *\nfind_recurse(const pcre_uchar *code, BOOL utf)", "code": "{\nfor (;;)\n  {\n  register pcre_uchar c = *code;\n  if (c == OP_END) return NULL;\n  if (c == OP_RECURSE) return code;\n\n  /* XCLASS is used for classes that cannot be represented just by a bit\n  map. This includes negated single high-valued characters. The length in\n  the table is zero; the actual length is stored in the compiled code. */\n\n  if (c == OP_XCLASS) code += GET(code, 1);\n\n  /* Otherwise, we can get the item's length from the table, except that for\n  repeated character types, we have to test for \\p and \\P, which have an extra\n  two bytes of parameters, and for MARK/PRUNE/SKIP/THEN with an argument, we\n  must add in its length. */\n\n  else\n    {\n    switch(c)\n      {\n      case OP_TYPESTAR:\n      case OP_TYPEMINSTAR:\n      case OP_TYPEPLUS:\n      case OP_TYPEMINPLUS:\n      case OP_TYPEQUERY:\n      case OP_TYPEMINQUERY:\n      case OP_TYPEPOSSTAR:\n      case OP_TYPEPOSPLUS:\n      case OP_TYPEPOSQUERY:\n      if (code[1] == OP_PROP || code[1] == OP_NOTPROP) code += 2;\n      break;\n\n      case OP_TYPEPOSUPTO:\n      case OP_TYPEUPTO:\n      case OP_TYPEMINUPTO:\n      case OP_TYPEEXACT:\n      if (code[1 + IMM2_SIZE] == OP_PROP || code[1 + IMM2_SIZE] == OP_NOTPROP)\n        code += 2;\n      break;\n\n      case OP_MARK:\n      case OP_PRUNE_ARG:\n      case OP_SKIP_ARG:\n      case OP_THEN_ARG:\n      code += code[1];\n      break;\n      }\n\n    /* Add in the fixed length from the table */\n\n    code += PRIV(OP_lengths)[c];\n\n    /* In UTF-8 mode, opcodes that are followed by a character may be followed\n    by a multi-byte character. The length in the table is a minimum, so we have\n    to arrange to skip the extra bytes. */\n\n#if defined SUPPORT_UTF && !defined COMPILE_PCRE32\n    if (utf) switch(c)\n      {\n      case OP_CHAR:\n      case OP_CHARI:\n      case OP_NOT:\n      case OP_NOTI:\n      case OP_EXACT:\n      case OP_EXACTI:\n      case OP_NOTEXACT:\n      case OP_NOTEXACTI:\n      case OP_UPTO:\n      case OP_UPTOI:\n      case OP_NOTUPTO:\n      case OP_NOTUPTOI:\n      case OP_MINUPTO:\n      case OP_MINUPTOI:\n      case OP_NOTMINUPTO:\n      case OP_NOTMINUPTOI:\n      case OP_POSUPTO:\n      case OP_POSUPTOI:\n      case OP_NOTPOSUPTO:\n      case OP_NOTPOSUPTOI:\n      case OP_STAR:\n      case OP_STARI:\n      case OP_NOTSTAR:\n      case OP_NOTSTARI:\n      case OP_MINSTAR:\n      case OP_MINSTARI:\n      case OP_NOTMINSTAR:\n      case OP_NOTMINSTARI:\n      case OP_POSSTAR:\n      case OP_POSSTARI:\n      case OP_NOTPOSSTAR:\n      case OP_NOTPOSSTARI:\n      case OP_PLUS:\n      case OP_PLUSI:\n      case OP_NOTPLUS:\n      case OP_NOTPLUSI:\n      case OP_MINPLUS:\n      case OP_MINPLUSI:\n      case OP_NOTMINPLUS:\n      case OP_NOTMINPLUSI:\n      case OP_POSPLUS:\n      case OP_POSPLUSI:\n      case OP_NOTPOSPLUS:\n      case OP_NOTPOSPLUSI:\n      case OP_QUERY:\n      case OP_QUERYI:\n      case OP_NOTQUERY:\n      case OP_NOTQUERYI:\n      case OP_MINQUERY:\n      case OP_MINQUERYI:\n      case OP_NOTMINQUERY:\n      case OP_NOTMINQUERYI:\n      case OP_POSQUERY:\n      case OP_POSQUERYI:\n      case OP_NOTPOSQUERY:\n      case OP_NOTPOSQUERYI:\n      if (HAS_EXTRALEN(code[-1])) code += GET_EXTRALEN(code[-1]);\n      break;\n      }\n#else\n    (void)(utf);  /* Keep compiler happy by referencing function argument */\n#endif\n    }\n  }\n}", "path": "libgit2/deps/pcre/pcre_compile.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "libgit2/libgit2", "stars": 9365, "license": "other", "language": "c", "size": 70878}
{"docstring": "/*\nArguments:\n  preg        points to a structure for recording the compiled expression\n  pattern     the pattern to compile\n  cflags      compilation flags\n\nReturns:      0 on success\n              various non-zero codes on failure\n*/\n", "func_signal": "PCREPOSIX_EXP_DEFN int PCRE_CALL_CONVENTION\npcre_regcomp(pcre_regex_t *preg, const char *pattern, int cflags)", "code": "{\nconst char *errorptr;\nint erroffset;\nint errorcode;\nint options = 0;\nint re_nsub = 0;\n\nif ((cflags & PCRE_REG_ICASE) != 0)    options |= PCRE_CASELESS;\nif ((cflags & PCRE_REG_NEWLINE) != 0)  options |= PCRE_MULTILINE;\nif ((cflags & PCRE_REG_DOTALL) != 0)   options |= PCRE_DOTALL;\nif ((cflags & PCRE_REG_NOSUB) != 0)    options |= PCRE_NO_AUTO_CAPTURE;\nif ((cflags & PCRE_REG_UTF8) != 0)     options |= PCRE_UTF8;\nif ((cflags & PCRE_REG_UCP) != 0)      options |= PCRE_UCP;\nif ((cflags & PCRE_REG_UNGREEDY) != 0) options |= PCRE_UNGREEDY;\n\npreg->re_pcre = pcre_compile2(pattern, options, &errorcode, &errorptr,\n  &erroffset, NULL);\npreg->re_erroffset = erroffset;\n\n/* Safety: if the error code is too big for the translation vector (which\nshould not happen, but we all make mistakes), return REG_BADPAT. */\n\nif (preg->re_pcre == NULL)\n  {\n  return (errorcode < (int)(sizeof(eint)/sizeof(const int)))?\n    eint[errorcode] : PCRE_REG_BADPAT;\n  }\n\n(void)pcre_fullinfo((const pcre *)preg->re_pcre, NULL, PCRE_INFO_CAPTURECOUNT,\n  &re_nsub);\npreg->re_nsub = (size_t)re_nsub;\npreg->re_erroffset = (size_t)(-1);  /* No meaning after successful compile */\nreturn 0;\n}", "path": "libgit2/deps/pcre/pcreposix.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "libgit2/libgit2", "stars": 9365, "license": "other", "language": "c", "size": 70878}
{"docstring": "/* This little function scans through a compiled pattern until it finds a\ncapturing bracket with the given number, or, if the number is negative, an\ninstance of OP_REVERSE for a lookbehind. The function is global in the C sense\nso that it can be called from pcre_study() when finding the minimum matching\nlength.\n\nArguments:\n  code        points to start of expression\n  utf         TRUE in UTF-8 / UTF-16 / UTF-32 mode\n  number      the required bracket number or negative to find a lookbehind\n\nReturns:      pointer to the opcode for the bracket, or NULL if not found\n*/\n", "func_signal": "const pcre_uchar *\nPRIV(find_bracket)(const pcre_uchar *code, BOOL utf, int number)", "code": "{\nfor (;;)\n  {\n  register pcre_uchar c = *code;\n\n  if (c == OP_END) return NULL;\n\n  /* XCLASS is used for classes that cannot be represented just by a bit\n  map. This includes negated single high-valued characters. The length in\n  the table is zero; the actual length is stored in the compiled code. */\n\n  if (c == OP_XCLASS) code += GET(code, 1);\n\n  /* Handle recursion */\n\n  else if (c == OP_REVERSE)\n    {\n    if (number < 0) return (pcre_uchar *)code;\n    code += PRIV(OP_lengths)[c];\n    }\n\n  /* Handle capturing bracket */\n\n  else if (c == OP_CBRA || c == OP_SCBRA ||\n           c == OP_CBRAPOS || c == OP_SCBRAPOS)\n    {\n    int n = (int)GET2(code, 1+LINK_SIZE);\n    if (n == number) return (pcre_uchar *)code;\n    code += PRIV(OP_lengths)[c];\n    }\n\n  /* Otherwise, we can get the item's length from the table, except that for\n  repeated character types, we have to test for \\p and \\P, which have an extra\n  two bytes of parameters, and for MARK/PRUNE/SKIP/THEN with an argument, we\n  must add in its length. */\n\n  else\n    {\n    switch(c)\n      {\n      case OP_TYPESTAR:\n      case OP_TYPEMINSTAR:\n      case OP_TYPEPLUS:\n      case OP_TYPEMINPLUS:\n      case OP_TYPEQUERY:\n      case OP_TYPEMINQUERY:\n      case OP_TYPEPOSSTAR:\n      case OP_TYPEPOSPLUS:\n      case OP_TYPEPOSQUERY:\n      if (code[1] == OP_PROP || code[1] == OP_NOTPROP) code += 2;\n      break;\n\n      case OP_TYPEUPTO:\n      case OP_TYPEMINUPTO:\n      case OP_TYPEEXACT:\n      case OP_TYPEPOSUPTO:\n      if (code[1 + IMM2_SIZE] == OP_PROP || code[1 + IMM2_SIZE] == OP_NOTPROP)\n        code += 2;\n      break;\n\n      case OP_MARK:\n      case OP_PRUNE_ARG:\n      case OP_SKIP_ARG:\n      case OP_THEN_ARG:\n      code += code[1];\n      break;\n      }\n\n    /* Add in the fixed length from the table */\n\n    code += PRIV(OP_lengths)[c];\n\n  /* In UTF-8 mode, opcodes that are followed by a character may be followed by\n  a multi-byte character. The length in the table is a minimum, so we have to\n  arrange to skip the extra bytes. */\n\n#if defined SUPPORT_UTF && !defined COMPILE_PCRE32\n    if (utf) switch(c)\n      {\n      case OP_CHAR:\n      case OP_CHARI:\n      case OP_NOT:\n      case OP_NOTI:\n      case OP_EXACT:\n      case OP_EXACTI:\n      case OP_NOTEXACT:\n      case OP_NOTEXACTI:\n      case OP_UPTO:\n      case OP_UPTOI:\n      case OP_NOTUPTO:\n      case OP_NOTUPTOI:\n      case OP_MINUPTO:\n      case OP_MINUPTOI:\n      case OP_NOTMINUPTO:\n      case OP_NOTMINUPTOI:\n      case OP_POSUPTO:\n      case OP_POSUPTOI:\n      case OP_NOTPOSUPTO:\n      case OP_NOTPOSUPTOI:\n      case OP_STAR:\n      case OP_STARI:\n      case OP_NOTSTAR:\n      case OP_NOTSTARI:\n      case OP_MINSTAR:\n      case OP_MINSTARI:\n      case OP_NOTMINSTAR:\n      case OP_NOTMINSTARI:\n      case OP_POSSTAR:\n      case OP_POSSTARI:\n      case OP_NOTPOSSTAR:\n      case OP_NOTPOSSTARI:\n      case OP_PLUS:\n      case OP_PLUSI:\n      case OP_NOTPLUS:\n      case OP_NOTPLUSI:\n      case OP_MINPLUS:\n      case OP_MINPLUSI:\n      case OP_NOTMINPLUS:\n      case OP_NOTMINPLUSI:\n      case OP_POSPLUS:\n      case OP_POSPLUSI:\n      case OP_NOTPOSPLUS:\n      case OP_NOTPOSPLUSI:\n      case OP_QUERY:\n      case OP_QUERYI:\n      case OP_NOTQUERY:\n      case OP_NOTQUERYI:\n      case OP_MINQUERY:\n      case OP_MINQUERYI:\n      case OP_NOTMINQUERY:\n      case OP_NOTMINQUERYI:\n      case OP_POSQUERY:\n      case OP_POSQUERYI:\n      case OP_NOTPOSQUERY:\n      case OP_NOTPOSQUERYI:\n      if (HAS_EXTRALEN(code[-1])) code += GET_EXTRALEN(code[-1]);\n      break;\n      }\n#else\n    (void)(utf);  /* Keep compiler happy by referencing function argument */\n#endif\n    }\n  }\n}", "path": "libgit2/deps/pcre/pcre_compile.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "libgit2/libgit2", "stars": 9365, "license": "other", "language": "c", "size": 70878}
{"docstring": "/**\n * ### References\n *\n * The [reference API][ref] allows you to list, resolve, create and update\n * references such as branches, tags and remote references (everything in\n * the .git/refs directory).\n *\n * [ref]: http://libgit2.github.com/libgit2/#HEAD/group/reference\n */\n", "func_signal": "static void reference_listing(git_repository *repo)", "code": "{\n\tgit_strarray ref_list;\n\tunsigned i;\n\n\tprintf(\"\\n*Reference Listing*\\n\");\n\n\t/**\n\t * Here we will implement something like `git for-each-ref` simply listing\n\t * out all available references and the object SHA they resolve to.\n\t *\n\t * Now that we have the list of reference names, we can lookup each ref\n\t * one at a time and resolve them to the SHA, then print both values out.\n\t */\n\n\tgit_reference_list(&ref_list, repo);\n\n\tfor (i = 0; i < ref_list.count; ++i) {\n\t\tgit_reference *ref;\n\t\tchar oid_hex[GIT_OID_HEXSZ+1] = GIT_OID_HEX_ZERO;\n\t\tconst char *refname;\n\n\t\trefname = ref_list.strings[i];\n\t\tgit_reference_lookup(&ref, repo, refname);\n\n\t\tswitch (git_reference_type(ref)) {\n\t\t\tcase GIT_REFERENCE_DIRECT:\n\t\t\t\tgit_oid_fmt(oid_hex, git_reference_target(ref));\n\t\t\t\tprintf(\"%s [%s]\\n\", refname, oid_hex);\n\t\t\t\tbreak;\n\n\t\t\tcase GIT_REFERENCE_SYMBOLIC:\n\t\t\t\tprintf(\"%s => %s\\n\", refname, git_reference_symbolic_target(ref));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"Unexpected reference type\\n\");\n\t\t\t\texit(1);\n\t\t}\n\n\t\tgit_reference_free(ref);\n\t}\n\n\tgit_strarray_dispose(&ref_list);\n}", "path": "libgit2/examples/general.c", "commit_date": "2020-06-01 00:00:00", "repo_name": "libgit2/libgit2", "stars": 9365, "license": "other", "language": "c", "size": 70878}
{"docstring": "/*************************************************\n*          Translate error code to string        *\n*************************************************/\n", "func_signal": "PCREPOSIX_EXP_DEFN size_t PCRE_CALL_CONVENTION\npcre_regerror(int errcode, const pcre_regex_t *preg, char *errbuf, size_t errbuf_size)", "code": "{\nconst char *message, *addmessage;\nsize_t length, addlength;\n\nmessage = (errcode >= (int)(sizeof(pstring)/sizeof(char *)))?\n  \"unknown error code\" : pstring[errcode];\nlength = strlen(message) + 1;\n\naddmessage = \" at offset \";\naddlength = (preg != NULL && (int)preg->re_erroffset != -1)?\n  strlen(addmessage) + 6 : 0;\n\nif (errbuf_size > 0)\n  {\n  if (addlength > 0 && errbuf_size >= length + addlength)\n    sprintf(errbuf, \"%s%s%-6d\", message, addmessage, (int)preg->re_erroffset);\n  else\n    {\n    strncpy(errbuf, message, errbuf_size - 1);\n    errbuf[errbuf_size-1] = 0;\n    }\n  }\n\nreturn length + addlength;\n}", "path": "libgit2/deps/pcre/pcreposix.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "libgit2/libgit2", "stars": 9365, "license": "other", "language": "c", "size": 70878}
{"docstring": "/* Replaces single character iterations with their possessive alternatives\nif appropriate. This function modifies the compiled opcode!\n\nArguments:\n  code        points to start of the byte code\n  utf         TRUE in UTF-8 / UTF-16 / UTF-32 mode\n  cd          static compile data\n\nReturns:      nothing\n*/\n", "func_signal": "static void\nauto_possessify(pcre_uchar *code, BOOL utf, const compile_data *cd)", "code": "{\nregister pcre_uchar c;\nconst pcre_uchar *end;\npcre_uchar *repeat_opcode;\npcre_uint32 list[8];\nint rec_limit;\n\nfor (;;)\n  {\n  c = *code;\n\n  /* When a pattern with bad UTF-8 encoding is compiled with NO_UTF_CHECK,\n  it may compile without complaining, but may get into a loop here if the code\n  pointer points to a bad value. This is, of course a documentated possibility,\n  when NO_UTF_CHECK is set, so it isn't a bug, but we can detect this case and\n  just give up on this optimization. */\n\n  if (c >= OP_TABLE_LENGTH) return;\n\n  if (c >= OP_STAR && c <= OP_TYPEPOSUPTO)\n    {\n    c -= get_repeat_base(c) - OP_STAR;\n    end = (c <= OP_MINUPTO) ?\n      get_chr_property_list(code, utf, cd->fcc, list) : NULL;\n    list[1] = c == OP_STAR || c == OP_PLUS || c == OP_QUERY || c == OP_UPTO;\n\n    rec_limit = 1000;\n    if (end != NULL && compare_opcodes(end, utf, cd, list, end, &rec_limit))\n      {\n      switch(c)\n        {\n        case OP_STAR:\n        *code += OP_POSSTAR - OP_STAR;\n        break;\n\n        case OP_MINSTAR:\n        *code += OP_POSSTAR - OP_MINSTAR;\n        break;\n\n        case OP_PLUS:\n        *code += OP_POSPLUS - OP_PLUS;\n        break;\n\n        case OP_MINPLUS:\n        *code += OP_POSPLUS - OP_MINPLUS;\n        break;\n\n        case OP_QUERY:\n        *code += OP_POSQUERY - OP_QUERY;\n        break;\n\n        case OP_MINQUERY:\n        *code += OP_POSQUERY - OP_MINQUERY;\n        break;\n\n        case OP_UPTO:\n        *code += OP_POSUPTO - OP_UPTO;\n        break;\n\n        case OP_MINUPTO:\n        *code += OP_POSUPTO - OP_MINUPTO;\n        break;\n        }\n      }\n    c = *code;\n    }\n  else if (c == OP_CLASS || c == OP_NCLASS || c == OP_XCLASS)\n    {\n#if defined SUPPORT_UTF || !defined COMPILE_PCRE8\n    if (c == OP_XCLASS)\n      repeat_opcode = code + GET(code, 1);\n    else\n#endif\n      repeat_opcode = code + 1 + (32 / sizeof(pcre_uchar));\n\n    c = *repeat_opcode;\n    if (c >= OP_CRSTAR && c <= OP_CRMINRANGE)\n      {\n      /* end must not be NULL. */\n      end = get_chr_property_list(code, utf, cd->fcc, list);\n\n      list[1] = (c & 1) == 0;\n\n      rec_limit = 1000;\n      if (compare_opcodes(end, utf, cd, list, end, &rec_limit))\n        {\n        switch (c)\n          {\n          case OP_CRSTAR:\n          case OP_CRMINSTAR:\n          *repeat_opcode = OP_CRPOSSTAR;\n          break;\n\n          case OP_CRPLUS:\n          case OP_CRMINPLUS:\n          *repeat_opcode = OP_CRPOSPLUS;\n          break;\n\n          case OP_CRQUERY:\n          case OP_CRMINQUERY:\n          *repeat_opcode = OP_CRPOSQUERY;\n          break;\n\n          case OP_CRRANGE:\n          case OP_CRMINRANGE:\n          *repeat_opcode = OP_CRPOSRANGE;\n          break;\n          }\n        }\n      }\n    c = *code;\n    }\n\n  switch(c)\n    {\n    case OP_END:\n    return;\n\n    case OP_TYPESTAR:\n    case OP_TYPEMINSTAR:\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEQUERY:\n    case OP_TYPEMINQUERY:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEPOSPLUS:\n    case OP_TYPEPOSQUERY:\n    if (code[1] == OP_PROP || code[1] == OP_NOTPROP) code += 2;\n    break;\n\n    case OP_TYPEUPTO:\n    case OP_TYPEMINUPTO:\n    case OP_TYPEEXACT:\n    case OP_TYPEPOSUPTO:\n    if (code[1 + IMM2_SIZE] == OP_PROP || code[1 + IMM2_SIZE] == OP_NOTPROP)\n      code += 2;\n    break;\n\n#if defined SUPPORT_UTF || !defined COMPILE_PCRE8\n    case OP_XCLASS:\n    code += GET(code, 1);\n    break;\n#endif\n\n    case OP_MARK:\n    case OP_PRUNE_ARG:\n    case OP_SKIP_ARG:\n    case OP_THEN_ARG:\n    code += code[1];\n    break;\n    }\n\n  /* Add in the fixed length from the table */\n\n  code += PRIV(OP_lengths)[c];\n\n  /* In UTF-8 mode, opcodes that are followed by a character may be followed by\n  a multi-byte character. The length in the table is a minimum, so we have to\n  arrange to skip the extra bytes. */\n\n#if defined SUPPORT_UTF && !defined COMPILE_PCRE32\n  if (utf) switch(c)\n    {\n    case OP_CHAR:\n    case OP_CHARI:\n    case OP_NOT:\n    case OP_NOTI:\n    case OP_STAR:\n    case OP_MINSTAR:\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_UPTO:\n    case OP_MINUPTO:\n    case OP_EXACT:\n    case OP_POSSTAR:\n    case OP_POSPLUS:\n    case OP_POSQUERY:\n    case OP_POSUPTO:\n    case OP_STARI:\n    case OP_MINSTARI:\n    case OP_PLUSI:\n    case OP_MINPLUSI:\n    case OP_QUERYI:\n    case OP_MINQUERYI:\n    case OP_UPTOI:\n    case OP_MINUPTOI:\n    case OP_EXACTI:\n    case OP_POSSTARI:\n    case OP_POSPLUSI:\n    case OP_POSQUERYI:\n    case OP_POSUPTOI:\n    case OP_NOTSTAR:\n    case OP_NOTMINSTAR:\n    case OP_NOTPLUS:\n    case OP_NOTMINPLUS:\n    case OP_NOTQUERY:\n    case OP_NOTMINQUERY:\n    case OP_NOTUPTO:\n    case OP_NOTMINUPTO:\n    case OP_NOTEXACT:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSUPTO:\n    case OP_NOTSTARI:\n    case OP_NOTMINSTARI:\n    case OP_NOTPLUSI:\n    case OP_NOTMINPLUSI:\n    case OP_NOTQUERYI:\n    case OP_NOTMINQUERYI:\n    case OP_NOTUPTOI:\n    case OP_NOTMINUPTOI:\n    case OP_NOTEXACTI:\n    case OP_NOTPOSSTARI:\n    case OP_NOTPOSPLUSI:\n    case OP_NOTPOSQUERYI:\n    case OP_NOTPOSUPTOI:\n    if (HAS_EXTRALEN(code[-1])) code += GET_EXTRALEN(code[-1]);\n    break;\n    }\n#else\n  (void)(utf);  /* Keep compiler happy by referencing function argument */\n#endif\n  }\n}", "path": "libgit2/deps/pcre/pcre_compile.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "libgit2/libgit2", "stars": 9365, "license": "other", "language": "c", "size": 70878}
{"docstring": "/* This is called by several functions that scan a compiled expression looking\nfor a fixed first character, or an anchoring op code etc. It skips over things\nthat do not influence this. For some calls, it makes sense to skip negative\nforward and all backward assertions, and also the \\b assertion; for others it\ndoes not.\n\nArguments:\n  code         pointer to the start of the group\n  skipassert   TRUE if certain assertions are to be skipped\n\nReturns:       pointer to the first significant opcode\n*/\n", "func_signal": "static const pcre_uchar*\nfirst_significant_code(const pcre_uchar *code, BOOL skipassert)", "code": "{\nfor (;;)\n  {\n  switch ((int)*code)\n    {\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    if (!skipassert) return code;\n    do code += GET(code, 1); while (*code == OP_ALT);\n    code += PRIV(OP_lengths)[*code];\n    break;\n\n    case OP_WORD_BOUNDARY:\n    case OP_NOT_WORD_BOUNDARY:\n    if (!skipassert) return code;\n    /* Fall through */\n\n    case OP_CALLOUT:\n    case OP_CREF:\n    case OP_DNCREF:\n    case OP_RREF:\n    case OP_DNRREF:\n    case OP_DEF:\n    code += PRIV(OP_lengths)[*code];\n    break;\n\n    default:\n    return code;\n    }\n  }\n/* Control never reaches here */\n}", "path": "libgit2/deps/pcre/pcre_compile.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "libgit2/libgit2", "stars": 9365, "license": "other", "language": "c", "size": 70878}
{"docstring": "/* This function is called when the PCRE_AUTO_CALLOUT option is set, to insert\ncallout points before each pattern item.\n\nArguments:\n  code           current code pointer\n  ptr            current pattern pointer\n  cd             pointers to tables etc\n\nReturns:         new code pointer\n*/\n", "func_signal": "static pcre_uchar *\nauto_callout(pcre_uchar *code, const pcre_uchar *ptr, compile_data *cd)", "code": "{\n*code++ = OP_CALLOUT;\n*code++ = 255;\nPUT(code, 0, (int)(ptr - cd->start_pattern));  /* Pattern offset */\nPUT(code, LINK_SIZE, 0);                       /* Default length */\nreturn code + 2 * LINK_SIZE;\n}", "path": "libgit2/deps/pcre/pcre_compile.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "libgit2/libgit2", "stars": 9365, "license": "other", "language": "c", "size": 70878}
{"docstring": "/* A callout item contains the length of the next item in the pattern, which\nwe can't fill in till after we have reached the relevant point. This is used\nfor both automatic and manual callouts.\n\nArguments:\n  previous_callout   points to previous callout item\n  ptr                current pattern pointer\n  cd                 pointers to tables etc\n\nReturns:             nothing\n*/\n", "func_signal": "static void\ncomplete_callout(pcre_uchar *previous_callout, const pcre_uchar *ptr, compile_data *cd)", "code": "{\nint length = (int)(ptr - cd->start_pattern - GET(previous_callout, 2));\nPUT(previous_callout, 2 + LINK_SIZE, length);\n}", "path": "libgit2/deps/pcre/pcre_compile.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "libgit2/libgit2", "stars": 9365, "license": "other", "language": "c", "size": 70878}
{"docstring": "/**\n * Almost all libgit2 functions return 0 on success or negative on error.\n * This is not production quality error checking, but should be sufficient\n * as an example.\n */\n", "func_signal": "static void check_error(int error_code, const char *action)", "code": "{\n\tconst git_error *error = git_error_last();\n\tif (!error_code)\n\t\treturn;\n\n\tprintf(\"Error %d %s - %s\\n\", error_code, action,\n\t\t\t(error && error->message) ? error->message : \"???\");\n\n\texit(1);\n}", "path": "libgit2/examples/general.c", "commit_date": "2020-06-01 00:00:00", "repo_name": "libgit2/libgit2", "stars": 9365, "license": "other", "language": "c", "size": 70878}
{"docstring": "/**\n * ### Config Files\n *\n * The [config API][config] allows you to list and updatee config values\n * in any of the accessible config file locations (system, global, local).\n *\n * [config]: http://libgit2.github.com/libgit2/#HEAD/group/config\n */\n", "func_signal": "static void config_files(const char *repo_path, git_repository* repo)", "code": "{\n\tconst char *email;\n\tchar config_path[256];\n\tint32_t autocorrect;\n\tgit_config *cfg;\n\tgit_config *snap_cfg;\n\tint error_code;\n\n\tprintf(\"\\n*Config Listing*\\n\");\n\n\t/**\n\t * Open a config object so we can read global values from it.\n\t */\n\tsprintf(config_path, \"%s/config\", repo_path);\n\tcheck_error(git_config_open_ondisk(&cfg, config_path), \"opening config\");\n\n\tif (git_config_get_int32(&autocorrect, cfg, \"help.autocorrect\") == 0)\n\t\tprintf(\"Autocorrect: %d\\n\", autocorrect);\n\n\tcheck_error(git_repository_config_snapshot(&snap_cfg, repo), \"config snapshot\");\n\tgit_config_get_string(&email, snap_cfg, \"user.email\");\n\tprintf(\"Email: %s\\n\", email);\n\n\terror_code = git_config_get_int32(&autocorrect, cfg, \"help.autocorrect\");\n\tswitch (error_code)\n\t{\n\t\tcase 0:\n\t\t\tprintf(\"Autocorrect: %d\\n\", autocorrect);\n\t\t\tbreak;\n\t\tcase GIT_ENOTFOUND:\n\t\t\tprintf(\"Autocorrect: Undefined\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcheck_error(error_code, \"get_int32 failed\");\n\t}\n\tgit_config_free(cfg);\n\n\tcheck_error(git_repository_config_snapshot(&snap_cfg, repo), \"config snapshot\");\n\terror_code = git_config_get_string(&email, snap_cfg, \"user.email\");\n\tswitch (error_code)\n\t{\n\t\tcase 0:\n\t\t\tprintf(\"Email: %s\\n\", email);\n\t\t\tbreak;\n\t\tcase GIT_ENOTFOUND:\n\t\t\tprintf(\"Email: Undefined\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcheck_error(error_code, \"get_string failed\");\n\t}\n\n\tgit_config_free(snap_cfg);\n}", "path": "libgit2/examples/general.c", "commit_date": "2020-06-01 00:00:00", "repo_name": "libgit2/libgit2", "stars": 9365, "license": "other", "language": "c", "size": 70878}
{"docstring": "/* This function is called during the second compiling phase, if the number of\nforward references fills the existing workspace, which is originally a block on\nthe stack. A larger block is obtained from malloc() unless the ultimate limit\nhas been reached or the increase will be rather small.\n\nArgument: pointer to the compile data block\nReturns:  0 if all went well, else an error number\n*/\n", "func_signal": "static int\nexpand_workspace(compile_data *cd)", "code": "{\npcre_uchar *newspace;\nint newsize = cd->workspace_size * 2;\n\nif (newsize > COMPILE_WORK_SIZE_MAX) newsize = COMPILE_WORK_SIZE_MAX;\nif (cd->workspace_size >= COMPILE_WORK_SIZE_MAX ||\n    newsize - cd->workspace_size < WORK_SIZE_SAFETY_MARGIN)\n return ERR72;\n\nnewspace = (PUBL(malloc))(IN_UCHARS(newsize));\nif (newspace == NULL) return ERR21;\nmemcpy(newspace, cd->start_workspace, cd->workspace_size * sizeof(pcre_uchar));\ncd->hwm = (pcre_uchar *)newspace + (cd->hwm - cd->start_workspace);\nif (cd->workspace_size > COMPILE_WORK_SIZE)\n  (PUBL(free))((void *)cd->start_workspace);\ncd->start_workspace = newspace;\ncd->workspace_size = newsize;\nreturn 0;\n}", "path": "libgit2/deps/pcre/pcre_compile.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "libgit2/libgit2", "stars": 9365, "license": "other", "language": "c", "size": 70878}
{"docstring": "/* This function is called between compiling passes to add an entry to the\nname/number table, maintaining alphabetical order. Checking for permitted\nand forbidden duplicates has already been done.\n\nArguments:\n  cd           the compile data block\n  name         the name to add\n  length       the length of the name\n  groupno      the group number\n\nReturns:       nothing\n*/\n", "func_signal": "static void\nadd_name(compile_data *cd, const pcre_uchar *name, int length,\n  unsigned int groupno)", "code": "{\nint i;\npcre_uchar *slot = cd->name_table;\n\nfor (i = 0; i < cd->names_found; i++)\n  {\n  int crc = memcmp(name, slot+IMM2_SIZE, IN_UCHARS(length));\n  if (crc == 0 && slot[IMM2_SIZE+length] != 0)\n    crc = -1; /* Current name is a substring */\n\n  /* Make space in the table and break the loop for an earlier name. For a\n  duplicate or later name, carry on. We do this for duplicates so that in the\n  simple case (when ?(| is not used) they are in order of their numbers. In all\n  cases they are in the order in which they appear in the pattern. */\n\n  if (crc < 0)\n    {\n    memmove(slot + cd->name_entry_size, slot,\n      IN_UCHARS((cd->names_found - i) * cd->name_entry_size));\n    break;\n    }\n\n  /* Continue the loop for a later or duplicate name */\n\n  slot += cd->name_entry_size;\n  }\n\nPUT2(slot, 0, groupno);\nmemcpy(slot + IMM2_SIZE, name, IN_UCHARS(length));\nslot[IMM2_SIZE + length] = 0;\ncd->names_found++;\n}", "path": "libgit2/deps/pcre/pcre_compile.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "libgit2/libgit2", "stars": 9365, "license": "other", "language": "c", "size": 70878}
{"docstring": "/**\n * ### Revwalking\n *\n * The libgit2 [revision walking api][rw] provides methods to traverse the\n * directed graph created by the parent pointers of the commit objects.\n * Since all commits point back to the commit that came directly before\n * them, you can walk this parentage as a graph and find all the commits\n * that were ancestors of (reachable from) a given starting point.  This\n * can allow you to create `git log` type functionality.\n *\n * [rw]: http://libgit2.github.com/libgit2/#HEAD/group/revwalk\n */\n", "func_signal": "static void revwalking(git_repository *repo)", "code": "{\n\tconst git_signature *cauth;\n\tconst char *cmsg;\n\tint error;\n\tgit_revwalk *walk;\n\tgit_commit *wcommit;\n\tgit_oid oid;\n\n\tprintf(\"\\n*Revwalking*\\n\");\n\n\tgit_oid_fromstr(&oid, \"5b5b025afb0b4c913b4c338a42934a3863bf3644\");\n\n\t/**\n\t * To use the revwalker, create a new walker, tell it how you want to sort\n\t * the output and then push one or more starting points onto the walker.\n\t * If you want to emulate the output of `git log` you would push the SHA\n\t * of the commit that HEAD points to into the walker and then start\n\t * traversing them.  You can also 'hide' commits that you want to stop at\n\t * or not see any of their ancestors.  So if you want to emulate `git log\n\t * branch1..branch2`, you would push the oid of `branch2` and hide the oid\n\t * of `branch1`.\n\t */\n\tgit_revwalk_new(&walk, repo);\n\tgit_revwalk_sorting(walk, GIT_SORT_TOPOLOGICAL | GIT_SORT_REVERSE);\n\tgit_revwalk_push(walk, &oid);\n\n\t/**\n\t * Now that we have the starting point pushed onto the walker, we start\n\t * asking for ancestors. It will return them in the sorting order we asked\n\t * for as commit oids.  We can then lookup and parse the committed pointed\n\t * at by the returned OID; note that this operation is specially fast\n\t * since the raw contents of the commit object will be cached in memory\n\t */\n\twhile ((git_revwalk_next(&oid, walk)) == 0) {\n\t\terror = git_commit_lookup(&wcommit, repo, &oid);\n\t\tcheck_error(error, \"looking up commit during revwalk\");\n\n\t\tcmsg  = git_commit_message(wcommit);\n\t\tcauth = git_commit_author(wcommit);\n\t\tprintf(\"%s (%s)\\n\", cmsg, cauth->email);\n\n\t\tgit_commit_free(wcommit);\n\t}\n\n\t/**\n\t * Like the other objects, be sure to free the revwalker when you're done\n\t * to prevent memory leaks.  Also, make sure that the repository being\n\t * walked it not deallocated while the walk is in progress, or it will\n\t * result in undefined behavior\n\t */\n\tgit_revwalk_free(walk);\n}", "path": "libgit2/examples/general.c", "commit_date": "2020-06-01 00:00:00", "repo_name": "libgit2/libgit2", "stars": 9365, "license": "other", "language": "c", "size": 70878}
{"docstring": "/* Checks whether the code points to an opcode that can take part in auto-\npossessification, and if so, fills a list with its properties.\n\nArguments:\n  code        points to start of expression\n  utf         TRUE if in UTF-8 / UTF-16 / UTF-32 mode\n  fcc         points to case-flipping table\n  list        points to output list\n              list[0] will be filled with the opcode\n              list[1] will be non-zero if this opcode\n                can match an empty character string\n              list[2..7] depends on the opcode\n\nReturns:      points to the start of the next opcode if *code is accepted\n              NULL if *code is not accepted\n*/\n", "func_signal": "static const pcre_uchar *\nget_chr_property_list(const pcre_uchar *code, BOOL utf,\n  const pcre_uint8 *fcc, pcre_uint32 *list)", "code": "{\npcre_uchar c = *code;\npcre_uchar base;\nconst pcre_uchar *end;\npcre_uint32 chr;\n\n#ifdef SUPPORT_UCP\npcre_uint32 *clist_dest;\nconst pcre_uint32 *clist_src;\n#else\n((void)utf); /* Suppress \"unused parameter\" compiler warning */\n#endif\n\nlist[0] = c;\nlist[1] = FALSE;\ncode++;\n\nif (c >= OP_STAR && c <= OP_TYPEPOSUPTO)\n  {\n  base = get_repeat_base(c);\n  c -= (base - OP_STAR);\n\n  if (c == OP_UPTO || c == OP_MINUPTO || c == OP_EXACT || c == OP_POSUPTO)\n    code += IMM2_SIZE;\n\n  list[1] = (c != OP_PLUS && c != OP_MINPLUS && c != OP_EXACT && c != OP_POSPLUS);\n\n  switch(base)\n    {\n    case OP_STAR:\n    list[0] = OP_CHAR;\n    break;\n\n    case OP_STARI:\n    list[0] = OP_CHARI;\n    break;\n\n    case OP_NOTSTAR:\n    list[0] = OP_NOT;\n    break;\n\n    case OP_NOTSTARI:\n    list[0] = OP_NOTI;\n    break;\n\n    case OP_TYPESTAR:\n    list[0] = *code;\n    code++;\n    break;\n    }\n  c = list[0];\n  }\n\nswitch(c)\n  {\n  case OP_NOT_DIGIT:\n  case OP_DIGIT:\n  case OP_NOT_WHITESPACE:\n  case OP_WHITESPACE:\n  case OP_NOT_WORDCHAR:\n  case OP_WORDCHAR:\n  case OP_ANY:\n  case OP_ALLANY:\n  case OP_ANYNL:\n  case OP_NOT_HSPACE:\n  case OP_HSPACE:\n  case OP_NOT_VSPACE:\n  case OP_VSPACE:\n  case OP_EXTUNI:\n  case OP_EODN:\n  case OP_EOD:\n  case OP_DOLL:\n  case OP_DOLLM:\n  return code;\n\n  case OP_CHAR:\n  case OP_NOT:\n  GETCHARINCTEST(chr, code);\n  list[2] = chr;\n  list[3] = NOTACHAR;\n  return code;\n\n  case OP_CHARI:\n  case OP_NOTI:\n  list[0] = (c == OP_CHARI) ? OP_CHAR : OP_NOT;\n  GETCHARINCTEST(chr, code);\n  list[2] = chr;\n\n#ifdef SUPPORT_UCP\n  if (chr < 128 || (chr < 256 && !utf))\n    list[3] = fcc[chr];\n  else\n    list[3] = UCD_OTHERCASE(chr);\n#elif defined SUPPORT_UTF || !defined COMPILE_PCRE8\n  list[3] = (chr < 256) ? fcc[chr] : chr;\n#else\n  list[3] = fcc[chr];\n#endif\n\n  /* The othercase might be the same value. */\n\n  if (chr == list[3])\n    list[3] = NOTACHAR;\n  else\n    list[4] = NOTACHAR;\n  return code;\n\n#ifdef SUPPORT_UCP\n  case OP_PROP:\n  case OP_NOTPROP:\n  if (code[0] != PT_CLIST)\n    {\n    list[2] = code[0];\n    list[3] = code[1];\n    return code + 2;\n    }\n\n  /* Convert only if we have enough space. */\n\n  clist_src = PRIV(ucd_caseless_sets) + code[1];\n  clist_dest = list + 2;\n  code += 2;\n\n  do {\n     if (clist_dest >= list + 8)\n       {\n       /* Early return if there is not enough space. This should never\n       happen, since all clists are shorter than 5 character now. */\n       list[2] = code[0];\n       list[3] = code[1];\n       return code;\n       }\n     *clist_dest++ = *clist_src;\n     }\n  while(*clist_src++ != NOTACHAR);\n\n  /* All characters are stored. The terminating NOTACHAR\n  is copied form the clist itself. */\n\n  list[0] = (c == OP_PROP) ? OP_CHAR : OP_NOT;\n  return code;\n#endif\n\n  case OP_NCLASS:\n  case OP_CLASS:\n#if defined SUPPORT_UTF || !defined COMPILE_PCRE8\n  case OP_XCLASS:\n  if (c == OP_XCLASS)\n    end = code + GET(code, 0) - 1;\n  else\n#endif\n    end = code + 32 / sizeof(pcre_uchar);\n\n  switch(*end)\n    {\n    case OP_CRSTAR:\n    case OP_CRMINSTAR:\n    case OP_CRQUERY:\n    case OP_CRMINQUERY:\n    case OP_CRPOSSTAR:\n    case OP_CRPOSQUERY:\n    list[1] = TRUE;\n    end++;\n    break;\n\n    case OP_CRPLUS:\n    case OP_CRMINPLUS:\n    case OP_CRPOSPLUS:\n    end++;\n    break;\n\n    case OP_CRRANGE:\n    case OP_CRMINRANGE:\n    case OP_CRPOSRANGE:\n    list[1] = (GET2(end, 1) == 0);\n    end += 1 + 2 * IMM2_SIZE;\n    break;\n    }\n  list[2] = (pcre_uint32)(end - code);\n  return end;\n  }\nreturn NULL;    /* Opcode not accepted */\n}", "path": "libgit2/deps/pcre/pcre_compile.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "libgit2/libgit2", "stars": 9365, "license": "other", "language": "c", "size": 70878}
{"docstring": "/* During compilation, the \"first char\" settings from forward assertions are\ndiscarded, because they can cause conflicts with actual literals that follow.\nHowever, if we end up without a first char setting for an unanchored pattern,\nit is worth scanning the regex to see if there is an initial asserted first\nchar. If all branches start with the same asserted char, or with a\nnon-conditional bracket all of whose alternatives start with the same asserted\nchar (recurse ad lib), then we return that char, with the flags set to zero or\nREQ_CASELESS; otherwise return zero with REQ_NONE in the flags.\n\nArguments:\n  code       points to start of expression (the bracket)\n  flags      points to the first char flags, or to REQ_NONE\n  inassert   TRUE if in an assertion\n\nReturns:     the fixed first char, or 0 with REQ_NONE in flags\n*/\n", "func_signal": "static pcre_uint32\nfind_firstassertedchar(const pcre_uchar *code, pcre_int32 *flags,\n  BOOL inassert)", "code": "{\nregister pcre_uint32 c = 0;\nint cflags = REQ_NONE;\n\n*flags = REQ_NONE;\ndo {\n   pcre_uint32 d;\n   int dflags;\n   int xl = (*code == OP_CBRA || *code == OP_SCBRA ||\n             *code == OP_CBRAPOS || *code == OP_SCBRAPOS)? IMM2_SIZE:0;\n   const pcre_uchar *scode = first_significant_code(code + 1+LINK_SIZE + xl,\n     TRUE);\n   register pcre_uchar op = *scode;\n\n   switch(op)\n     {\n     default:\n     return 0;\n\n     case OP_BRA:\n     case OP_BRAPOS:\n     case OP_CBRA:\n     case OP_SCBRA:\n     case OP_CBRAPOS:\n     case OP_SCBRAPOS:\n     case OP_ASSERT:\n     case OP_ONCE:\n     case OP_ONCE_NC:\n     d = find_firstassertedchar(scode, &dflags, op == OP_ASSERT);\n     if (dflags < 0)\n       return 0;\n     if (cflags < 0) { c = d; cflags = dflags; } else if (c != d || cflags != dflags) return 0;\n     break;\n\n     case OP_EXACT:\n     scode += IMM2_SIZE;\n     /* Fall through */\n\n     case OP_CHAR:\n     case OP_PLUS:\n     case OP_MINPLUS:\n     case OP_POSPLUS:\n     if (!inassert) return 0;\n     if (cflags < 0) { c = scode[1]; cflags = 0; }\n       else if (c != scode[1]) return 0;\n     break;\n\n     case OP_EXACTI:\n     scode += IMM2_SIZE;\n     /* Fall through */\n\n     case OP_CHARI:\n     case OP_PLUSI:\n     case OP_MINPLUSI:\n     case OP_POSPLUSI:\n     if (!inassert) return 0;\n     if (cflags < 0) { c = scode[1]; cflags = REQ_CASELESS; }\n       else if (c != scode[1]) return 0;\n     break;\n     }\n\n   code += GET(code, 1);\n   }\nwhile (*code == OP_ALT);\n\n*flags = cflags;\nreturn c;\n}", "path": "libgit2/deps/pcre/pcre_compile.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "libgit2/libgit2", "stars": 9365, "license": "other", "language": "c", "size": 70878}
{"docstring": "/* The error texts are now all in one long string, to save on relocations. As\nsome of the text is of unknown length, we can't use a table of offsets.\nInstead, just count through the strings. This is not a performance issue\nbecause it happens only when there has been a compilation error.\n\nArgument:   the error number\nReturns:    pointer to the error string\n*/\n", "func_signal": "static const char *\nfind_error_text(int n)", "code": "{\nconst char *s = error_texts;\nfor (; n > 0; n--)\n  {\n  while (*s++ != CHAR_NULL) {};\n  if (*s == CHAR_NULL) return \"Error text not found (please report)\";\n  }\nreturn s;\n}", "path": "libgit2/deps/pcre/pcre_compile.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "libgit2/libgit2", "stars": 9365, "license": "other", "language": "c", "size": 70878}
{"docstring": "/***********************************************************************\n * hb_dvdnav_reset\n ***********************************************************************\n * Once dvdnav has entered the 'stopped' state, it can not be revived\n * dvdnav_reset doesn't work because it doesn't remember the path\n * So this function re-opens dvdnav\n **********************************************************************/\n", "func_signal": "static int hb_dvdnav_reset( hb_dvdnav_t * d )", "code": "{\n    char * path_ccp = hb_utf8_to_cp( d->path );\n    if ( d->dvdnav )\n        dvdnav_close( d->dvdnav );\n\n    /* Open device */\n    if( dvdnav_open(&d->dvdnav, path_ccp) != DVDNAV_STATUS_OK )\n    {\n        /*\n         * Not an error, may be a stream - which we'll try in a moment.\n         */\n        hb_log( \"dvd: not a dvd - trying as a stream/file instead\" );\n        goto fail;\n    }\n\n    if (dvdnav_set_readahead_flag(d->dvdnav, DVD_READ_CACHE) !=\n        DVDNAV_STATUS_OK)\n    {\n        hb_error(\"Error: dvdnav_set_readahead_flag: %s\\n\",\n                 dvdnav_err_to_string(d->dvdnav));\n        goto fail;\n    }\n\n    /*\n     ** set the PGC positioning flag to have position information\n     ** relatively to the whole feature instead of just relatively to the\n     ** current chapter\n     **/\n    if (dvdnav_set_PGC_positioning_flag(d->dvdnav, 1) != DVDNAV_STATUS_OK)\n    {\n        hb_error(\"Error: dvdnav_set_PGC_positioning_flag: %s\\n\",\n                 dvdnav_err_to_string(d->dvdnav));\n        goto fail;\n    }\n\n    free( path_ccp );\n\n    return 1;\n\nfail:\n    if( d->dvdnav ) dvdnav_close( d->dvdnav );\n    free( path_ccp );\n    return 0;\n}", "path": "HandBrake/libhb/dvdnav.c", "commit_date": "2020-08-20 00:00:00", "repo_name": "HandBrake/HandBrake", "stars": 15103, "license": "other", "language": "c", "size": 109379}
{"docstring": "/***********************************************************************\n * hb_bd_init\n ***********************************************************************\n *\n **********************************************************************/\n", "func_signal": "hb_bd_t * hb_bd_init( hb_handle_t *h, const char * path )", "code": "{\n    hb_bd_t * d;\n    int ii;\n\n    d = calloc( sizeof( hb_bd_t ), 1 );\n    d->h = h;\n\n    /* Open device */\n    d->bd = bd_open( path, NULL );\n    if( d->bd == NULL )\n    {\n        /*\n         * Not an error, may be a stream - which we'll try in a moment.\n         */\n        hb_log( \"bd: not a bd - trying as a stream/file instead\" );\n        goto fail;\n    }\n\n    d->title_count = bd_get_titles( d->bd, TITLES_RELEVANT, 0 );\n    if ( d->title_count == 0 )\n    {\n        hb_log( \"bd: not a bd - trying as a stream/file instead\" );\n        goto fail;\n    }\n    d->title_info = calloc( sizeof( BLURAY_TITLE_INFO* ) , d->title_count );\n    for ( ii = 0; ii < d->title_count; ii++ )\n    {\n        d->title_info[ii] = bd_get_title_info( d->bd, ii, 0 );\n    }\n    qsort(d->title_info, d->title_count, sizeof( BLURAY_TITLE_INFO* ), title_info_compare_mpls );\n    d->disc_info = bd_get_disc_info(d->bd);\n    d->path = strdup( path );\n\n    return d;\n\nfail:\n    if( d->bd ) bd_close( d->bd );\n    free( d );\n    return NULL;\n}", "path": "HandBrake/libhb/bd.c", "commit_date": "2020-06-05 00:00:00", "repo_name": "HandBrake/HandBrake", "stars": 15103, "license": "other", "language": "c", "size": 109379}
{"docstring": "/***********************************************************************\n * hb_dvdnav_set_angle\n ***********************************************************************\n * Sets the angle to read\n **********************************************************************/\n", "func_signal": "static void hb_dvdnav_set_angle( hb_dvd_t * e, int angle )", "code": "{\n    hb_dvdnav_t * d = &(e->dvdnav);\n\n    if (dvdnav_angle_change( d->dvdnav, angle) != DVDNAV_STATUS_OK)\n    {\n        hb_log(\"dvdnav_angle_change %s\", dvdnav_err_to_string(d->dvdnav));\n    }\n}", "path": "HandBrake/libhb/dvdnav.c", "commit_date": "2020-08-20 00:00:00", "repo_name": "HandBrake/HandBrake", "stars": 15103, "license": "other", "language": "c", "size": 109379}
{"docstring": "//  Dictionary extraction helpers\n//\n// Extract the given key from the dict and assign to dst *only*\n// if key is found in dict.  Values are converted to the requested\n// data type.\n//\n// return: 1 - key is in dict\n//         0 - key is not in dict\n", "func_signal": "int hb_dict_extract_int(int *dst, const hb_dict_t * dict, const char * key)", "code": "{\n    if (dict == NULL || key == NULL || dst == NULL)\n    {\n        return 0;\n    }\n\n    hb_value_t *val = hb_dict_get(dict, key);\n    if (val == NULL)\n    {\n        return 0;\n    }\n\n    *dst = hb_value_get_int(val);\n    return 1;\n}", "path": "HandBrake/libhb/hb_dict.c", "commit_date": "2020-04-22 00:00:00", "repo_name": "HandBrake/HandBrake", "stars": 15103, "license": "other", "language": "c", "size": 109379}
{"docstring": "/***********************************************************************\n * hb_bd_start\n ***********************************************************************\n * Title and chapter start at 1\n **********************************************************************/\n", "func_signal": "int hb_bd_start( hb_bd_t * d, hb_title_t *title )", "code": "{\n    BD_EVENT event;\n\n    d->duration  = title->duration;\n\n    // Calling bd_get_event initializes libbluray event queue.\n    bd_select_title( d->bd, d->title_info[title->index - 1]->idx );\n    bd_get_event( d->bd, &event );\n    d->chapter = 0;\n    d->next_chap = 1;\n    d->stream = hb_bd_stream_open( d->h, title );\n    if ( d->stream == NULL )\n    {\n        return 0;\n    }\n    return 1;\n}", "path": "HandBrake/libhb/bd.c", "commit_date": "2020-06-05 00:00:00", "repo_name": "HandBrake/HandBrake", "stars": 15103, "license": "other", "language": "c", "size": 109379}
{"docstring": "/***********************************************************************\n * hb_dvdnav_title_scan\n **********************************************************************/\n", "func_signal": "static int find_title( hb_list_t * list_title, int title )", "code": "{\n    int ii;\n\n    for ( ii = 0; ii < hb_list_count( list_title ); ii++ )\n    {\n        hb_title_t * hbtitle = hb_list_item( list_title, ii );\n        if ( hbtitle->index == title )\n            return ii;\n    }\n    return -1;\n}", "path": "HandBrake/libhb/dvdnav.c", "commit_date": "2020-08-20 00:00:00", "repo_name": "HandBrake/HandBrake", "stars": 15103, "license": "other", "language": "c", "size": 109379}
{"docstring": "/***********************************************************************\n * hb_dvdnav_title_count\n **********************************************************************/\n", "func_signal": "static int hb_dvdnav_title_count( hb_dvd_t * e )", "code": "{\n    int titles = 0;\n    hb_dvdnav_t * d = &(e->dvdnav);\n\n    dvdnav_get_number_of_titles(d->dvdnav, &titles);\n    return titles;\n}", "path": "HandBrake/libhb/dvdnav.c", "commit_date": "2020-08-20 00:00:00", "repo_name": "HandBrake/HandBrake", "stars": 15103, "license": "other", "language": "c", "size": 109379}
{"docstring": "/***********************************************************************\n * hb_dvdnav_title_scan\n **********************************************************************/\n", "func_signal": "static hb_title_t * hb_dvdnav_title_scan( hb_dvd_t * e, int t, uint64_t min_duration )", "code": "{\n\n    hb_dvdnav_t      * d = &(e->dvdnav);\n    hb_title_t       * title;\n    int                pgcn, i;\n    pgc_t            * pgc;\n    hb_chapter_t     * chapter;\n    hb_dvd_chapter_t * dvd_chapter;\n    int                count;\n    const char       * title_string;\n    char               name[1024];\n    unsigned char      unused[1024];\n    const char       * codec_name;\n\n    hb_log( \"scan: scanning title %d\", t );\n\n    title = hb_title_init( d->path, t );\n    title->type = HB_DVD_TYPE;\n    if (dvdnav_get_title_string(d->dvdnav, &title_string) == DVDNAV_STATUS_OK)\n    {\n        title->name = strdup(title_string);\n    }\n\n    if (title->name == NULL || title->name[0] == 0)\n    {\n        free((char*)title->name);\n        if (DVDUDFVolumeInfo(d->reader, name, sizeof(name),\n                             unused, sizeof(unused)))\n        {\n            char * p_cur, * p_last = d->path;\n            for( p_cur = d->path; *p_cur; p_cur++ )\n            {\n                if( IS_DIR_SEP(p_cur[0]) && p_cur[1] )\n                {\n                    p_last = &p_cur[1];\n                }\n            }\n            title->name = strdup(p_last);\n            char *dot_term = strrchr(title->name, '.');\n            if (dot_term)\n                *dot_term = '\\0';\n        }\n        else\n        {\n            title->name = strdup(name);\n        }\n    }\n\n    if (!TitleOpenIfo(d, t))\n    {\n        goto fail;\n    }\n\n    /* ignore titles with bogus cell addresses so we don't abort later\n     ** in libdvdread. */\n    for ( i = 0; i < d->ifo->vts_c_adt->nr_of_vobs; ++i)\n    {\n        if( (d->ifo->vts_c_adt->cell_adr_table[i].start_sector & 0xffffff ) ==\n            0xffffff )\n        {\n            hb_log( \"scan: cell_adr_table[%d].start_sector invalid (0x%x) \"\n                    \"- skipping title\", i,\n                    d->ifo->vts_c_adt->cell_adr_table[i].start_sector );\n            goto fail;\n        }\n        if( (d->ifo->vts_c_adt->cell_adr_table[i].last_sector & 0xffffff ) ==\n            0xffffff )\n        {\n            hb_log( \"scan: cell_adr_table[%d].last_sector invalid (0x%x) \"\n                    \"- skipping title\", i,\n                    d->ifo->vts_c_adt->cell_adr_table[i].last_sector );\n            goto fail;\n        }\n    }\n\n    if (global_verbosity_level == 4)\n    {\n        ifo_print( d->reader, d->vts );\n    }\n\n    /* Get duration */\n    title->duration = d->duration;\n    title->hours    =   title->duration / 90000  / 3600;\n    title->minutes  = ((title->duration / 90000) % 3600) / 60;\n    title->seconds  = ( title->duration / 90000) % 60;\n\n    hb_log( \"scan: duration is %02d:%02d:%02d (%\"PRId64\" ms)\",\n            title->hours, title->minutes, title->seconds,\n            title->duration / 90 );\n\n    /* ignore titles under 10 seconds because they're often stills or\n     * clips with no audio & our preview code doesn't currently handle\n     * either of these. */\n    if (title->duration < min_duration)\n    {\n        hb_log( \"scan: ignoring title (too short)\" );\n        goto fail;\n    }\n\n    /* Get pgc */\n    if (d->pgcn < 1                                 ||\n        d->pgcn > d->ifo->vts_pgcit->nr_of_pgci_srp ||\n        d->pgcn >= MAX_PGCN)\n    {\n        hb_log( \"invalid PGC ID %d for title %d, skipping\", d->pgcn, t );\n        goto fail;\n    }\n\n    // Check all pgc's for validity\n    uint32_t pgcn_map[MAX_PGCN/32];\n    pgcn = d->pgcn;\n    PgcWalkInit( pgcn_map );\n    do\n    {\n        pgc = d->ifo->vts_pgcit->pgci_srp[pgcn-1].pgc;\n\n        if (!pgc || !pgc->program_map)\n        {\n            hb_log( \"scan: pgc not valid, skipping\" );\n            goto fail;\n        }\n\n        if (pgc->cell_playback == NULL)\n        {\n            hb_log( \"invalid PGC cell_playback table for title %d, skipping\", t );\n            goto fail;\n        }\n    } while ((pgcn = NextPgcn(d->ifo, pgcn, pgcn_map)) != 0);\n\n    pgc = d->ifo->vts_pgcit->pgci_srp[d->pgcn-1].pgc;\n\n    hb_log(\"pgc_id: %d, pgn: %d: pgc: %p\", d->pgcn, d->pgn, pgc);\n    if (d->pgn > pgc->nr_of_programs)\n    {\n        hb_log( \"invalid PGN %d for title %d, skipping\", d->pgn, t );\n        goto fail;\n    }\n\n    /* Detect languages */\n    for (i = 0; i < d->ifo->vtsi_mat->nr_of_vts_audio_streams; i++)\n    {\n        int audio_format, lang_code, lang_extension, audio_control, position, j;\n        hb_audio_t * audio, * audio_tmp;\n        iso639_lang_t * lang;\n\n        hb_log( \"scan: checking audio %d\", i + 1 );\n\n        audio = calloc( sizeof( hb_audio_t ), 1 );\n\n        audio_format   = d->ifo->vtsi_mat->vts_audio_attr[i].audio_format;\n        lang_code      = d->ifo->vtsi_mat->vts_audio_attr[i].lang_code;\n        lang_extension = d->ifo->vtsi_mat->vts_audio_attr[i].code_extension;\n        audio_control  =\n            d->ifo->vts_pgcit->pgci_srp[d->pgcn-1].pgc->audio_control[i];\n\n        if (!(audio_control & 0x8000))\n        {\n            hb_log( \"scan: audio channel is not active\" );\n            free( audio );\n            continue;\n        }\n\n        position = ( audio_control & 0x7F00 ) >> 8;\n\n        switch( audio_format )\n        {\n            case 0x00:\n                audio->id    = ( ( 0x80 + position ) << 8 ) | 0xbd;\n                audio->config.in.codec = HB_ACODEC_AC3;\n                audio->config.in.codec_param = AV_CODEC_ID_AC3;\n                codec_name = \"AC3\";\n                break;\n\n            case 0x02:\n            case 0x03:\n                audio->id    = 0xc0 + position;\n                audio->config.in.codec = HB_ACODEC_FFMPEG;\n                audio->config.in.codec_param = AV_CODEC_ID_MP2;\n                codec_name = \"MPEG\";\n                break;\n\n            case 0x04:\n                audio->id    = ( ( 0xa0 + position ) << 8 ) | 0xbd;\n                audio->config.in.codec = HB_ACODEC_LPCM;\n                codec_name = \"LPCM\";\n                break;\n\n            case 0x06:\n                audio->id    = ( ( 0x88 + position ) << 8 ) | 0xbd;\n                audio->config.in.codec = HB_ACODEC_DCA;\n                audio->config.in.codec_param = AV_CODEC_ID_DTS;\n                codec_name = \"DTS\";\n                break;\n\n            default:\n                audio->id    = 0;\n                audio->config.in.codec = 0;\n                codec_name = \"Unknown\";\n                hb_log( \"scan: unknown audio codec (%x)\",\n                        audio_format );\n                break;\n        }\n        if( !audio->id )\n        {\n            continue;\n        }\n        const char * name = NULL;\n        switch ( lang_extension )\n        {\n            case 1:\n                audio->config.lang.attributes = HB_AUDIO_ATTR_NORMAL;\n                break;\n            case 2:\n                audio->config.lang.attributes = HB_AUDIO_ATTR_VISUALLY_IMPAIRED;\n                name = \"Visually Impaired\";\n                break;\n            case 3:\n                audio->config.lang.attributes = HB_AUDIO_ATTR_COMMENTARY;\n                name = \"Commentary\";\n                break;\n            case 4:\n                audio->config.lang.attributes = HB_AUDIO_ATTR_ALT_COMMENTARY;\n                name = \"Commentary\";\n                break;\n            default:\n                audio->config.lang.attributes = HB_AUDIO_ATTR_NONE;\n                break;\n        }\n        if (name != NULL)\n        {\n            audio->config.in.name = strdup(name);\n        }\n\n        /* Check for duplicate tracks */\n        audio_tmp = NULL;\n        for( j = 0; j < hb_list_count( title->list_audio ); j++ )\n        {\n            audio_tmp = hb_list_item( title->list_audio, j );\n            if( audio->id == audio_tmp->id )\n            {\n                break;\n            }\n            audio_tmp = NULL;\n        }\n        if( audio_tmp )\n        {\n            hb_log( \"scan: duplicate audio track\" );\n            free( audio );\n            continue;\n        }\n\n        lang = lang_for_code( lang_code );\n\n\n        snprintf( audio->config.lang.simple,\n                  sizeof( audio->config.lang.simple ), \"%s\",\n                  strlen( lang->native_name ) ? lang->native_name : lang->eng_name );\n        snprintf( audio->config.lang.iso639_2,\n                  sizeof( audio->config.lang.iso639_2 ), \"%s\", lang->iso639_2 );\n\n        hb_log(\"scan: id=0x%x, lang=%s (%s), 3cc=%s ext=%i\", audio->id,\n               audio->config.lang.simple, codec_name,\n               audio->config.lang.iso639_2, lang_extension);\n\n        audio->config.in.track        = i;\n        audio->config.in.timebase.num = 1;\n        audio->config.in.timebase.den = 90000;\n\n        hb_list_add( title->list_audio, audio );\n    }\n\n    /* Check for subtitles */\n    for( i = 0; i < d->ifo->vtsi_mat->nr_of_vts_subp_streams; i++ )\n    {\n        int             spu_control, pos, lang_ext = 0;\n        iso639_lang_t * lang;\n\n        hb_log( \"scan: checking subtitle %d\", i + 1 );\n\n        // spu_control\n        // 0x80000000 - Subtitle enabled\n        // 0x1f000000 - Position mask for 4:3 aspect subtitle track\n        // 0x001f0000 - Position mask for Wide Screen subtitle track\n        // 0x00001f00 - Position mask for Letterbox subtitle track\n        // 0x0000001f - Position mask for Pan&Scan subtitle track\n        spu_control =\n            d->ifo->vts_pgcit->pgci_srp[d->pgcn-1].pgc->subp_control[i];\n\n        if( !( spu_control & 0x80000000 ) )\n        {\n            hb_log( \"scan: subtitle channel is not active\" );\n            continue;\n        }\n\n        lang_ext = d->ifo->vtsi_mat->vts_subp_attr[i].code_extension;\n        lang     = lang_for_code(d->ifo->vtsi_mat->vts_subp_attr[i].lang_code);\n\n        // display_aspect_ratio\n        // 0     = 4:3\n        // 3     = 16:9\n        // other = invalid\n        if (d->ifo->vtsi_mat->vts_video_attr.display_aspect_ratio)\n        {\n            // Add Wide Screen subtitle.\n            pos = (spu_control >> 16) & 0x1F;\n            add_subtitle(title->list_subtitle, pos, lang, lang_ext,\n                (uint8_t*)d->ifo->vts_pgcit->pgci_srp[d->pgcn-1].pgc->palette,\n                HB_VOBSUB_STYLE_WIDE);\n\n            // permitted_df\n            // 1 - Letterbox not permitted\n            // 2 - Pan&Scan not permitted\n            // 3 - Letterbox and Pan&Scan not permitted\n            if (!(d->ifo->vtsi_mat->vts_video_attr.permitted_df & 1))\n            {\n                // Letterbox permitted.  Add Letterbox subtitle.\n                pos = (spu_control >> 8) & 0x1F;\n                add_subtitle(title->list_subtitle, pos, lang, lang_ext,\n                    (uint8_t*)d->ifo->vts_pgcit->pgci_srp[d->pgcn-1].pgc->palette,\n                    HB_VOBSUB_STYLE_LETTERBOX);\n            }\n            if (!(d->ifo->vtsi_mat->vts_video_attr.permitted_df & 2))\n            {\n                // Pan&Scan permitted.  Add Pan&Scan subtitle.\n                pos = spu_control & 0x1F;\n                add_subtitle(title->list_subtitle, pos, lang, lang_ext,\n                    (uint8_t*)d->ifo->vts_pgcit->pgci_srp[d->pgcn-1].pgc->palette,\n                    HB_VOBSUB_STYLE_PANSCAN);\n            }\n        }\n        else\n        {\n            pos = (spu_control >> 24) & 0x1F;\n            add_subtitle(title->list_subtitle, pos, lang, lang_ext,\n                (uint8_t*)d->ifo->vts_pgcit->pgci_srp[d->pgcn-1].pgc->palette,\n                HB_VOBSUB_STYLE_4_3);\n        }\n    }\n\n    /* Chapters */\n    count = hb_list_count(d->list_dvd_chapter);\n    hb_log( \"scan: title %d has %d chapters\", t, count );\n    for (i = 0; i < count; i++)\n    {\n        char chapter_title[80];\n\n        dvd_chapter       = hb_list_item(d->list_dvd_chapter, i);\n        chapter           = calloc(sizeof( hb_chapter_t ), 1);\n        chapter->index    = i + 1;\n        chapter->duration = dvd_chapter->duration;\n\n        sprintf(chapter_title, \"Chapter %d\", chapter->index);\n        hb_chapter_set_title(chapter, chapter_title);\n\n        hb_list_add( title->list_chapter, chapter );\n\n        int seconds       = ( chapter->duration + 45000 ) / 90000;\n        chapter->hours    = ( seconds / 3600 );\n        chapter->minutes  = ( seconds % 3600 ) / 60;\n        chapter->seconds  = ( seconds % 60 );\n\n        hb_log( \"scan: chap %d, %\"PRId64\" ms\",\n                chapter->index, chapter->duration / 90 );\n    }\n\n    /* Get aspect. We don't get width/height/rate infos here as\n       they tend to be wrong */\n    switch (d->ifo->vtsi_mat->vts_video_attr.display_aspect_ratio)\n    {\n        case 0:\n            title->container_dar.num = 4;\n            title->container_dar.den = 3;\n            break;\n        case 3:\n            title->container_dar.num = 16;\n            title->container_dar.den = 9;\n            break;\n        default:\n            hb_log( \"scan: unknown aspect\" );\n            goto fail;\n    }\n\n    switch (d->ifo->vtsi_mat->vts_video_attr.mpeg_version)\n    {\n        case 0:\n            title->video_codec       = WORK_DECAVCODECV;\n            title->video_codec_param = AV_CODEC_ID_MPEG1VIDEO;\n            break;\n        case 1:\n            title->video_codec       = WORK_DECAVCODECV;\n            title->video_codec_param = AV_CODEC_ID_MPEG2VIDEO;\n            break;\n        default:\n            hb_log(\"scan: unknown/reserved MPEG version %d\",\n                    d->ifo->vtsi_mat->vts_video_attr.mpeg_version);\n            title->video_codec       = WORK_DECAVCODECV;\n            title->video_codec_param = AV_CODEC_ID_MPEG2VIDEO;\n            break;\n    }\n\n    hb_log(\"scan: aspect = %d:%d\",\n           title->container_dar.num, title->container_dar.den);\n\n    /* This title is ok so far */\n    goto cleanup;\n\nfail:\n    hb_title_close( &title );\n\ncleanup:\n    TitleCloseIfo(d);\n\n    return title;\n}", "path": "HandBrake/libhb/dvdnav.c", "commit_date": "2020-08-20 00:00:00", "repo_name": "HandBrake/HandBrake", "stars": 15103, "license": "other", "language": "c", "size": 109379}
{"docstring": "/***********************************************************************\n * hb_dvdnav_start\n ***********************************************************************\n * Title and chapter start at 1\n **********************************************************************/\n", "func_signal": "static int hb_dvdnav_start( hb_dvd_t * e, hb_title_t *title, int c )", "code": "{\n    hb_dvdnav_t * d = &(e->dvdnav);\n    int t = title->index;\n    hb_dvd_chapter_t *chapter;\n    dvdnav_status_t result;\n\n    if ( d->stopped && !hb_dvdnav_reset(d) )\n    {\n        return 0;\n    }\n    if (!TitleOpenIfo(d, t))\n    {\n        return 0;\n    }\n    dvdnav_reset( d->dvdnav );\n    chapter = hb_list_item( d->list_dvd_chapter, c - 1);\n    if (chapter != NULL)\n        result = dvdnav_program_play(d->dvdnav, t, chapter->pgcn, chapter->pgn);\n    else\n        result = dvdnav_part_play(d->dvdnav, t, 1);\n    if (result != DVDNAV_STATUS_OK)\n    {\n        hb_error( \"dvd: dvdnav_*_play failed - %s\",\n                  dvdnav_err_to_string(d->dvdnav) );\n        return 0;\n    }\n    d->stopped = 0;\n    d->chapter = 0;\n    d->cell = 0;\n    return 1;\n}", "path": "HandBrake/libhb/dvdnav.c", "commit_date": "2020-08-20 00:00:00", "repo_name": "HandBrake/HandBrake", "stars": 15103, "license": "other", "language": "c", "size": 109379}
{"docstring": "/***********************************************************************\n * hb_bd_set_angle\n ***********************************************************************\n * Sets the angle to read\n **********************************************************************/\n", "func_signal": "void hb_bd_set_angle( hb_bd_t * d, int angle )", "code": "{\n\n    if ( !bd_select_angle( d->bd, angle) )\n    {\n        hb_log(\"bd_select_angle failed\");\n    }\n}", "path": "HandBrake/libhb/bd.c", "commit_date": "2020-06-05 00:00:00", "repo_name": "HandBrake/HandBrake", "stars": 15103, "license": "other", "language": "c", "size": 109379}
{"docstring": "/***********************************************************************\n * hb_bd_read\n ***********************************************************************\n *\n **********************************************************************/\n", "func_signal": "hb_buffer_t * hb_bd_read( hb_bd_t * d )", "code": "{\n    int result;\n    int error_count = 0;\n    int retry_count = 0;\n    uint8_t buf[192];\n    BD_EVENT event;\n    uint64_t pos;\n    hb_buffer_t * out = NULL;\n    uint8_t discontinuity;\n\n    while ( 1 )\n    {\n        discontinuity = 0;\n        result = next_packet( d->bd, buf );\n        while ( bd_get_event( d->bd, &event ) )\n        {\n            switch ( event.event )\n            {\n                case BD_EVENT_CHAPTER:\n                    // The muxers expect to only get chapter 2 and above\n                    // They write chapter 1 when chapter 2 is detected.\n                    if (event.param > d->chapter)\n                    {\n                        d->next_chap = event.param;\n                    }\n                    break;\n\n                case BD_EVENT_PLAYITEM:\n                    discontinuity = 1;\n                    hb_deep_log(2, \"bd: Play item %u\", event.param);\n                    break;\n\n                case BD_EVENT_STILL:\n                    bd_read_skip_still( d->bd );\n                    break;\n\n                case BD_EVENT_END_OF_TITLE:\n                    hb_log(\"bd: End of title\");\n                    if (result <= 0)\n                    {\n                        return NULL;\n                    }\n                    break;\n\n                default:\n                    break;\n            }\n        }\n\n        if ( result < 0 )\n        {\n            hb_error(\"bd: Read Error\");\n            pos = bd_tell( d->bd );\n            bd_seek( d->bd, pos + 192 );\n            error_count++;\n            if (error_count > 10)\n            {\n                hb_error(\"bd: Error, too many consecutive read errors\");\n                hb_set_work_error(d->h, HB_ERROR_READ);\n                return NULL;\n            }\n            continue;\n        }\n        else if ( result == 0 )\n        {\n            // libbluray returns 0 when it encounters and skips a bad unit.\n            // So retry a few times to be certain there is no more data\n            // to be read.\n            retry_count++;\n            if (retry_count > 1000)\n            {\n                // A unit is 6144 bytes (32 TS packets).  Give up after we've\n                // seen > 6MB of invalid data.\n                return NULL;\n            }\n            continue;\n        }\n\n        if (retry_count > 0)\n        {\n            hb_error(\"bd: Read Error, skipping bad data.\");\n            retry_count = 0;\n        }\n\n        error_count = 0;\n        // buf+4 to skip the BD timestamp at start of packet\n        if (d->chapter != d->next_chap)\n        {\n            d->chapter = d->next_chap;\n            out = hb_ts_decode_pkt(d->stream, buf+4, d->chapter, discontinuity);\n        }\n        else\n        {\n            out = hb_ts_decode_pkt(d->stream, buf+4, 0, discontinuity);\n        }\n        if (out != NULL)\n        {\n            return out;\n        }\n    }\n}", "path": "HandBrake/libhb/bd.c", "commit_date": "2020-06-05 00:00:00", "repo_name": "HandBrake/HandBrake", "stars": 15103, "license": "other", "language": "c", "size": 109379}
{"docstring": "/***********************************************************************\n * hb_bd_seek\n ***********************************************************************\n *\n **********************************************************************/\n", "func_signal": "int hb_bd_seek( hb_bd_t * d, float f )", "code": "{\n    uint64_t pos = f * d->duration;\n\n    bd_seek_time(d->bd, pos);\n    d->next_chap = bd_get_current_chapter( d->bd ) + 1;\n    hb_ts_stream_reset(d->stream);\n    return 1;\n}", "path": "HandBrake/libhb/bd.c", "commit_date": "2020-06-05 00:00:00", "repo_name": "HandBrake/HandBrake", "stars": 15103, "license": "other", "language": "c", "size": 109379}
{"docstring": "/***********************************************************************\n * hb_dvdnav_seek\n ***********************************************************************\n *\n **********************************************************************/\n", "func_signal": "static int hb_dvdnav_seek( hb_dvd_t * e, float f )", "code": "{\n    hb_dvdnav_t * d = &(e->dvdnav);\n    uint64_t sector = f * d->title_block_count;\n    int result, event, len;\n    uint8_t buf[HB_DVD_READ_BUFFER_SIZE];\n    int done = 0, ii;\n\n    if (d->stopped)\n    {\n        return 0;\n    }\n\n    // XXX the current version of libdvdnav can't seek outside the current\n    // PGC. Check if the place we're seeking to is in a different\n    // PGC. Position there & adjust the offset if so.\n    uint64_t pgc_offset = 0;\n    uint64_t chap_offset = 0;\n    hb_dvd_chapter_t *pgc_change = hb_list_item(d->list_dvd_chapter, 0 );\n    for ( ii = 0; ii < hb_list_count( d->list_dvd_chapter ); ++ii )\n    {\n        hb_dvd_chapter_t *chapter = hb_list_item( d->list_dvd_chapter, ii );\n        uint64_t chap_len = chapter->block_end - chapter->block_start + 1;\n\n        if ( chapter->pgcn != pgc_change->pgcn )\n        {\n            // this chapter's in a different pgc from the previous - note the\n            // change so we can make sector offset's be pgc relative.\n            pgc_offset = chap_offset;\n            pgc_change = chapter;\n        }\n        if ( chap_offset <= sector && sector < chap_offset + chap_len )\n        {\n            // this chapter contains the sector we want - see if it's in a\n            // different pgc than the one we're currently in.\n            int32_t title, pgcn, pgn;\n            if (dvdnav_current_title_program( d->dvdnav, &title, &pgcn, &pgn ) != DVDNAV_STATUS_OK)\n                hb_log(\"dvdnav cur pgcn err: %s\", dvdnav_err_to_string(d->dvdnav));\n            // If we find ourselves in a new title, it means a title\n            // transition was made while reading data.  Jumping between\n            // titles can cause the vm to get into a bad state.  So\n            // reset the vm in this case.\n            if ( d->title != title )\n                dvdnav_reset( d->dvdnav );\n\n            if ( d->title != title || chapter->pgcn != pgcn )\n            {\n                // this chapter is in a different pgc - switch to it.\n                if (dvdnav_program_play(d->dvdnav, d->title, chapter->pgcn, chapter->pgn) != DVDNAV_STATUS_OK)\n                    hb_log(\"dvdnav prog play err: %s\", dvdnav_err_to_string(d->dvdnav));\n            }\n            // seek sectors are pgc-relative so remove the pgc start sector.\n            sector -= pgc_offset;\n            break;\n        }\n        chap_offset += chap_len;\n    }\n\n    // dvdnav will not let you seek or poll current position\n    // till it reaches a certain point in parsing.  so we\n    // have to get blocks until we reach a cell\n    // Put an arbitrary limit of 100 blocks on how long we search\n    for (ii = 0; ii < 100 && !done; ii++)\n    {\n        result = dvdnav_get_next_block( d->dvdnav, buf, &event, &len );\n        if ( result == DVDNAV_STATUS_ERR )\n        {\n            hb_error(\"dvdnav: Read Error, %s\", dvdnav_err_to_string(d->dvdnav));\n            return 0;\n        }\n        switch ( event )\n        {\n        case DVDNAV_BLOCK_OK:\n        case DVDNAV_CELL_CHANGE:\n            done = 1;\n            break;\n\n        case DVDNAV_STILL_FRAME:\n            dvdnav_still_skip( d->dvdnav );\n            break;\n\n        case DVDNAV_WAIT:\n            dvdnav_wait_skip( d->dvdnav );\n            break;\n\n        case DVDNAV_STOP:\n            hb_log(\"dvdnav: stop encountered during seek\");\n            d->stopped = 1;\n            return 0;\n\n        case DVDNAV_HOP_CHANNEL:\n        case DVDNAV_NAV_PACKET:\n        case DVDNAV_VTS_CHANGE:\n        case DVDNAV_HIGHLIGHT:\n        case DVDNAV_AUDIO_STREAM_CHANGE:\n        case DVDNAV_SPU_STREAM_CHANGE:\n        case DVDNAV_SPU_CLUT_CHANGE:\n        case DVDNAV_NOP:\n        default:\n            break;\n        }\n    }\n\n    if (dvdnav_sector_search(d->dvdnav, sector, SEEK_SET) != DVDNAV_STATUS_OK)\n    {\n        hb_error( \"dvd: dvdnav_sector_search failed - %s\",\n                  dvdnav_err_to_string(d->dvdnav) );\n        return 0;\n    }\n    d->chapter = 0;\n    d->cell = 0;\n    return 1;\n}", "path": "HandBrake/libhb/dvdnav.c", "commit_date": "2020-08-20 00:00:00", "repo_name": "HandBrake/HandBrake", "stars": 15103, "license": "other", "language": "c", "size": 109379}
{"docstring": "/***********************************************************************\n * hb_bd_main_feature\n **********************************************************************/\n", "func_signal": "int hb_bd_main_feature( hb_bd_t * d, hb_list_t * list_title )", "code": "{\n    int longest = 0;\n    int ii;\n    uint64_t longest_duration = 0;\n    int highest_rank = 0, rank;\n    int most_chapters = 0;\n    int ranks[9] = {0, 1, 3, 2, 6, 5, 7, 4, 8};\n    BLURAY_TITLE_INFO * ti;\n\n    for ( ii = 0; ii < hb_list_count( list_title ); ii++ )\n    {\n        hb_title_t * title = hb_list_item( list_title, ii );\n        ti = d->title_info[title->index - 1];\n        if ( ti )\n        {\n            BLURAY_STREAM_INFO * bdvideo = &ti->clips[0].video_streams[0];\n            if ( title->duration > longest_duration * 0.7 && bdvideo->format < 8 )\n            {\n                rank = 0;\n                if (bdvideo->format <= 8)\n                {\n                    rank = ranks[bdvideo->format];\n                }\n                if (highest_rank < rank ||\n                    ( title->duration > longest_duration &&\n                      highest_rank == rank))\n                {\n                    longest = title->index;\n                    longest_duration = title->duration;\n                    highest_rank = rank;\n                    most_chapters = ti->chapter_count;\n                }\n                else if (highest_rank == rank &&\n                         title->duration == longest_duration &&\n                         ti->chapter_count > most_chapters)\n                {\n                    longest = title->index;\n                    most_chapters = ti->chapter_count;\n                }\n            }\n        }\n        else if ( title->duration > longest_duration )\n        {\n            longest_duration = title->duration;\n            longest = title->index;\n        }\n    }\n    return longest;\n}", "path": "HandBrake/libhb/bd.c", "commit_date": "2020-06-05 00:00:00", "repo_name": "HandBrake/HandBrake", "stars": 15103, "license": "other", "language": "c", "size": 109379}
{"docstring": "/***********************************************************************\n * hb_bd_title_scan\n **********************************************************************/\n", "func_signal": "hb_title_t * hb_bd_title_scan( hb_bd_t * d, int tt, uint64_t min_duration )", "code": "{\n\n    hb_title_t   * title;\n    hb_chapter_t * chapter;\n    int            ii, jj;\n    BLURAY_TITLE_INFO * ti = NULL;\n\n    hb_log( \"bd: scanning title %d\", tt );\n\n    title = hb_title_init( d->path, tt );\n    title->demuxer = HB_TS_DEMUXER;\n    title->type = HB_BD_TYPE;\n    title->reg_desc = STR4_TO_UINT32(\"HDMV\");\n\n    if (d->disc_info->disc_name != NULL && d->disc_info->disc_name[0] != 0)\n    {\n        title->name = strdup(d->disc_info->disc_name);\n    }\n    else if (d->disc_info->udf_volume_id != NULL &&\n             d->disc_info->udf_volume_id[0] != 0)\n    {\n        title->name = strdup(d->disc_info->udf_volume_id);\n    }\n    else\n    {\n        char * p_cur, * p_last = d->path;\n        for( p_cur = d->path; *p_cur; p_cur++ )\n        {\n            if( IS_DIR_SEP(p_cur[0]) && p_cur[1] )\n            {\n                p_last = &p_cur[1];\n            }\n        }\n        title->name = strdup(p_last);\n        char *dot_term = strrchr(title->name, '.');\n        if (dot_term)\n            *dot_term = '\\0';\n    }\n\n    if (tt <= d->title_count)\n    {\n        ti = d->title_info[tt - 1];\n    }\n    if ( ti == NULL )\n    {\n        hb_log( \"bd: invalid title\" );\n        goto fail;\n    }\n    if ( ti->clip_count == 0 )\n    {\n        hb_log( \"bd: stream has no clips\" );\n        goto fail;\n    }\n    if ( ti->clips[0].video_stream_count == 0 )\n    {\n        hb_log( \"bd: stream has no video\" );\n        goto fail;\n    }\n\n    hb_log( \"bd: playlist %05d.MPLS\", ti->playlist );\n    title->playlist = ti->playlist;\n\n    uint64_t pkt_count = 0;\n    for ( ii = 0; ii < ti->clip_count; ii++ )\n    {\n        pkt_count += ti->clips[ii].pkt_count;\n    }\n\n    title->angle_count = ti->angle_count;\n\n    /* Get duration */\n    title->duration = ti->duration;\n    title->hours    = title->duration / 90000 / 3600;\n    title->minutes  = ( ( title->duration / 90000 ) % 3600 ) / 60;\n    title->seconds  = ( title->duration / 90000 ) % 60;\n    hb_log( \"bd: duration is %02d:%02d:%02d (%\"PRIu64\" ms)\",\n            title->hours, title->minutes, title->seconds,\n            title->duration / 90 );\n\n    /* ignore short titles because they're often stills */\n    if( ti->duration < min_duration )\n    {\n        hb_log( \"bd: ignoring title (too short)\" );\n        goto fail;\n    }\n    if (global_verbosity_level >= 2)\n    {\n        show_clip_list(ti);\n    }\n\n    BLURAY_STREAM_INFO * bdvideo = &ti->clips[0].video_streams[0];\n\n    title->video_id = bdvideo->pid;\n    title->video_stream_type = bdvideo->coding_type;\n\n    hb_log( \"bd: video id=0x%x, stream type=%s, format %s\", title->video_id,\n            bdvideo->coding_type == BLURAY_STREAM_TYPE_VIDEO_MPEG1 ? \"MPEG1\" :\n            bdvideo->coding_type == BLURAY_STREAM_TYPE_VIDEO_MPEG2 ? \"MPEG2\" :\n            bdvideo->coding_type == BLURAY_STREAM_TYPE_VIDEO_VC1 ? \"VC-1\" :\n            bdvideo->coding_type == BLURAY_STREAM_TYPE_VIDEO_H264 ? \"H.264\" :\n            bdvideo->coding_type == BLURAY_STREAM_TYPE_VIDEO_HEVC ? \"HEVC\" :\n            \"Unknown\",\n            bdvideo->format == BLURAY_VIDEO_FORMAT_480I ? \"480i\" :\n            bdvideo->format == BLURAY_VIDEO_FORMAT_576I ? \"576i\" :\n            bdvideo->format == BLURAY_VIDEO_FORMAT_480P ? \"480p\" :\n            bdvideo->format == BLURAY_VIDEO_FORMAT_1080I ? \"1080i\" :\n            bdvideo->format == BLURAY_VIDEO_FORMAT_720P ? \"720p\" :\n            bdvideo->format == BLURAY_VIDEO_FORMAT_1080P ? \"1080p\" :\n            bdvideo->format == BLURAY_VIDEO_FORMAT_576P ? \"576p\" :\n            bdvideo->format == BLURAY_VIDEO_FORMAT_2160P ? \"2160p\" :\n            \"Unknown\"\n          );\n\n    switch( bdvideo->coding_type )\n    {\n        case BLURAY_STREAM_TYPE_VIDEO_MPEG1:\n        case BLURAY_STREAM_TYPE_VIDEO_MPEG2:\n            title->video_codec = WORK_DECAVCODECV;\n            title->video_codec_param = AV_CODEC_ID_MPEG2VIDEO;\n            break;\n\n        case BLURAY_STREAM_TYPE_VIDEO_VC1:\n            title->video_codec = WORK_DECAVCODECV;\n            title->video_codec_param = AV_CODEC_ID_VC1;\n            break;\n\n        case BLURAY_STREAM_TYPE_VIDEO_H264:\n            title->video_codec = WORK_DECAVCODECV;\n            title->video_codec_param = AV_CODEC_ID_H264;\n            break;\n\n        case BLURAY_STREAM_TYPE_VIDEO_HEVC:\n            title->video_codec = WORK_DECAVCODECV;\n            title->video_codec_param = AV_CODEC_ID_HEVC;\n            break;\n\n        default:\n            hb_log( \"scan: unknown video codec (0x%x)\",\n                    bdvideo->coding_type );\n            goto fail;\n    }\n\n    switch ( bdvideo->aspect )\n    {\n        case BLURAY_ASPECT_RATIO_4_3:\n            title->container_dar.num = 4;\n            title->container_dar.den = 3;\n            break;\n        case BLURAY_ASPECT_RATIO_16_9:\n            title->container_dar.num = 16;\n            title->container_dar.den = 9;\n            break;\n        default:\n            hb_log( \"bd: unknown aspect %d, assuming 16:9\", bdvideo->aspect );\n            title->container_dar.num = 16;\n            title->container_dar.den = 9;\n            break;\n    }\n    hb_log(\"bd: aspect = %d:%d\",\n           title->container_dar.num, title->container_dar.den);\n\n    /* Detect audio */\n    // Max primary BD audios is 32\n    int matches;\n    int most_audio = 0;\n    int audio_clip_index = 0;\n    if (ti->clip_count > 2)\n    {\n        // All BD clips are not all required to have the same audio.\n        // But clips that have seamless transition are required\n        // to have the same audio as the previous clip.\n        // So find the clip that has the most other clips with the\n        // matching audio.\n        for ( ii = 0; ii < ti->clip_count; ii++ )\n        {\n            matches = 0;\n            for ( jj = 0; jj < ti->clip_count; jj++ )\n            {\n                if ( bd_audio_equal( &ti->clips[ii], &ti->clips[jj] ) )\n                {\n                    matches++;\n                }\n            }\n            if ( matches > most_audio )\n            {\n                most_audio = matches;\n                audio_clip_index = ii;\n            }\n        }\n    }\n    else if (ti->clip_count == 2)\n    {\n        // If there are only 2 clips, pick audios from the longer clip\n        if (ti->clips[0].pkt_count < ti->clips[1].pkt_count)\n            audio_clip_index = 1;\n    }\n\n    // Add all the audios found in the above clip.\n    for (ii = 0; ii < ti->clips[audio_clip_index].audio_stream_count; ii++)\n    {\n        BLURAY_STREAM_INFO * bdaudio;\n\n        bdaudio = &ti->clips[audio_clip_index].audio_streams[ii];\n\n        switch (bdaudio->coding_type)\n        {\n            case BLURAY_STREAM_TYPE_AUDIO_TRUHD:\n                // Add 2 audio tracks.  One for TrueHD and one for AC-3\n                add_audio(ii, title->list_audio, bdaudio, HB_SUBSTREAM_BD_AC3,\n                          HB_ACODEC_AC3, AV_CODEC_ID_AC3, HB_AUDIO_ATTR_NONE);\n                add_audio(ii, title->list_audio, bdaudio, HB_SUBSTREAM_BD_TRUEHD,\n                          HB_ACODEC_FFTRUEHD, AV_CODEC_ID_TRUEHD,\n                          HB_AUDIO_ATTR_NONE);\n                break;\n\n            case BLURAY_STREAM_TYPE_AUDIO_DTS:\n                add_audio(ii, title->list_audio, bdaudio, 0,\n                          HB_ACODEC_DCA, AV_CODEC_ID_DTS, HB_AUDIO_ATTR_NONE);\n                break;\n\n            case BLURAY_STREAM_TYPE_AUDIO_MPEG2:\n            case BLURAY_STREAM_TYPE_AUDIO_MPEG1:\n                add_audio(ii, title->list_audio, bdaudio, 0,\n                          HB_ACODEC_FFMPEG, AV_CODEC_ID_MP2,\n                          HB_AUDIO_ATTR_NONE);\n                break;\n\n            case BLURAY_STREAM_TYPE_AUDIO_AC3PLUS:\n                add_audio(ii, title->list_audio, bdaudio, 0,\n                          HB_ACODEC_FFEAC3, AV_CODEC_ID_EAC3,\n                          HB_AUDIO_ATTR_NONE);\n                break;\n\n            case BLURAY_STREAM_TYPE_AUDIO_AC3PLUS_SECONDARY:\n                add_audio(ii, title->list_audio, bdaudio, 0,\n                          HB_ACODEC_FFEAC3, AV_CODEC_ID_EAC3,\n                          HB_AUDIO_ATTR_NONE);\n                break;\n\n            case BLURAY_STREAM_TYPE_AUDIO_LPCM:\n                add_audio(ii, title->list_audio, bdaudio, 0,\n                          HB_ACODEC_FFMPEG, AV_CODEC_ID_PCM_BLURAY,\n                          HB_AUDIO_ATTR_NONE);\n                break;\n\n            case BLURAY_STREAM_TYPE_AUDIO_AC3:\n                add_audio(ii, title->list_audio, bdaudio, 0,\n                          HB_ACODEC_AC3, AV_CODEC_ID_AC3, HB_AUDIO_ATTR_NONE);\n                break;\n\n            case BLURAY_STREAM_TYPE_AUDIO_DTSHD_MASTER:\n            case BLURAY_STREAM_TYPE_AUDIO_DTSHD:\n                // Add 2 audio tracks.  One for DTS-HD and one for DTS\n                add_audio(ii, title->list_audio, bdaudio, HB_SUBSTREAM_BD_DTS,\n                          HB_ACODEC_DCA, AV_CODEC_ID_DTS, HB_AUDIO_ATTR_NONE);\n                // DTS-HD is special.  The substreams must be concatinated\n                // DTS-core followed by DTS-hd-extensions.  Setting\n                // a substream id of 0 says use all substreams.\n                add_audio(ii, title->list_audio, bdaudio, 0,\n                          HB_ACODEC_DCA_HD, AV_CODEC_ID_DTS,\n                          HB_AUDIO_ATTR_NONE);\n                break;\n\n            case BLURAY_STREAM_TYPE_AUDIO_DTSHD_SECONDARY:\n                // BD \"DTSHD_SECONDARY\" is DTS Express which has no\n                // DTS core\n                add_audio(ii, title->list_audio, bdaudio, 0,\n                          HB_ACODEC_DCA_HD, AV_CODEC_ID_DTS,\n                          HB_AUDIO_ATTR_NONE);\n                break;\n\n            default:\n                hb_log(\"scan: unknown audio pid 0x%x codec 0x%x\", bdaudio->pid,\n                       bdaudio->coding_type);\n                break;\n        }\n    }\n\n    // Add all the secondary audios found in the above clip.\n    for (jj = 0; jj < ti->clips[audio_clip_index].sec_audio_stream_count; jj++, ii++)\n    {\n        BLURAY_STREAM_INFO * bdaudio;\n\n        bdaudio = &ti->clips[audio_clip_index].sec_audio_streams[jj];\n\n        switch (bdaudio->coding_type)\n        {\n            case BLURAY_STREAM_TYPE_AUDIO_TRUHD:\n                // Add 2 audio tracks.  One for TrueHD and one for AC-3\n                add_audio(ii, title->list_audio, bdaudio, HB_SUBSTREAM_BD_AC3,\n                          HB_ACODEC_AC3, AV_CODEC_ID_AC3,\n                          HB_AUDIO_ATTR_SECONDARY);\n                add_audio(ii, title->list_audio, bdaudio, HB_SUBSTREAM_BD_TRUEHD,\n                          HB_ACODEC_FFTRUEHD, AV_CODEC_ID_TRUEHD,\n                          HB_AUDIO_ATTR_SECONDARY);\n                break;\n\n            case BLURAY_STREAM_TYPE_AUDIO_DTS:\n                add_audio(ii, title->list_audio, bdaudio, 0,\n                          HB_ACODEC_DCA, AV_CODEC_ID_DTS,\n                          HB_AUDIO_ATTR_SECONDARY);\n                break;\n\n            case BLURAY_STREAM_TYPE_AUDIO_MPEG2:\n            case BLURAY_STREAM_TYPE_AUDIO_MPEG1:\n                add_audio(ii, title->list_audio, bdaudio, 0,\n                          HB_ACODEC_FFMPEG, AV_CODEC_ID_MP2,\n                          HB_AUDIO_ATTR_SECONDARY);\n                break;\n\n            case BLURAY_STREAM_TYPE_AUDIO_AC3PLUS:\n            case BLURAY_STREAM_TYPE_AUDIO_AC3PLUS_SECONDARY:\n                add_audio(ii, title->list_audio, bdaudio, 0,\n                          HB_ACODEC_FFEAC3, AV_CODEC_ID_EAC3,\n                          HB_AUDIO_ATTR_SECONDARY);\n                break;\n\n            case BLURAY_STREAM_TYPE_AUDIO_LPCM:\n                add_audio(ii, title->list_audio, bdaudio, 0,\n                          HB_ACODEC_FFMPEG, AV_CODEC_ID_PCM_BLURAY,\n                          HB_AUDIO_ATTR_SECONDARY);\n                break;\n\n            case BLURAY_STREAM_TYPE_AUDIO_AC3:\n                add_audio(ii, title->list_audio, bdaudio, 0,\n                          HB_ACODEC_AC3, AV_CODEC_ID_AC3,\n                          HB_AUDIO_ATTR_SECONDARY);\n                break;\n\n            case BLURAY_STREAM_TYPE_AUDIO_DTSHD_MASTER:\n            case BLURAY_STREAM_TYPE_AUDIO_DTSHD:\n                // Add 2 audio tracks.  One for DTS-HD and one for DTS\n                add_audio(ii, title->list_audio, bdaudio, HB_SUBSTREAM_BD_DTS,\n                          HB_ACODEC_DCA, AV_CODEC_ID_DTS,\n                          HB_AUDIO_ATTR_SECONDARY);\n                // DTS-HD is special.  The substreams must be concatinated\n                // DTS-core followed by DTS-hd-extensions.  Setting\n                // a substream id of 0 says use all substreams.\n                add_audio(ii, title->list_audio, bdaudio, 0,\n                          HB_ACODEC_DCA_HD, AV_CODEC_ID_DTS,\n                          HB_AUDIO_ATTR_SECONDARY);\n                break;\n\n            case BLURAY_STREAM_TYPE_AUDIO_DTSHD_SECONDARY:\n                // BD \"DTSHD_SECONDARY\" is DTS Express which has no\n                // DTS core\n                add_audio(ii, title->list_audio, bdaudio, 0,\n                          HB_ACODEC_DCA_HD, AV_CODEC_ID_DTS,\n                          HB_AUDIO_ATTR_SECONDARY);\n                break;\n\n            default:\n                hb_log(\"scan: unknown audio pid 0x%x codec 0x%x\", bdaudio->pid,\n                       bdaudio->coding_type);\n                break;\n        }\n    }\n\n    // Add all the subtitles found in the above clip.\n    for ( ii = 0; ii < ti->clips[audio_clip_index].pg_stream_count; ii++ )\n    {\n        BLURAY_STREAM_INFO * bdpgs;\n\n        bdpgs = &ti->clips[audio_clip_index].pg_streams[ii];\n\n        switch( bdpgs->coding_type )\n        {\n            case BLURAY_STREAM_TYPE_SUB_PG:\n                add_subtitle(ii, title->list_subtitle, bdpgs, WORK_DECAVSUB,\n                             AV_CODEC_ID_HDMV_PGS_SUBTITLE);\n                break;\n            default:\n                hb_log( \"scan: unknown subtitle pid 0x%x codec 0x%x\",\n                        bdpgs->pid, bdpgs->coding_type );\n                break;\n        }\n    }\n\n    /* Chapters */\n    for ( ii = 0, jj = 0; ii < ti->chapter_count; ii++ )\n    {\n        char chapter_title[80];\n\n        // Sanity check start time of this chapter.\n        // If it is beyond the end of the title, drop it.\n        if (ti->chapters[ii].start > ti->duration)\n        {\n            hb_log(\"bd: chapter %d invalid start %\"PRIu64\", dropping\", ii+1,\n                   ti->chapters[ii].start);\n            continue;\n        }\n\n        chapter = calloc( sizeof( hb_chapter_t ), 1 );\n\n        chapter->index = ++jj;\n        sprintf( chapter_title, \"Chapter %d\", chapter->index );\n        hb_chapter_set_title( chapter, chapter_title );\n\n        chapter->duration = ti->chapters[ii].duration;\n\n        // Sanity check chapter duration and start times\n        // Have seen some invalid durations in the wild\n        if (ii < ti->chapter_count - 1)\n        {\n            // Validate start time\n            if (ti->chapters[ii+1].start < ti->chapters[ii].start)\n            {\n                hb_log(\"bd: chapter %d invalid start %\"PRIu64\"\", ii+1,\n                       ti->chapters[ii+1].start);\n                ti->chapters[ii+1].start = ti->chapters[ii].start +\n                                           chapter->duration;\n            }\n            if (ti->chapters[ii+1].start - ti->chapters[ii].start !=\n                chapter->duration)\n            {\n                hb_log(\"bd: chapter %d invalid duration %\"PRIu64\"\", ii+1,\n                       chapter->duration);\n                chapter->duration = ti->chapters[ii+1].start -\n                                    ti->chapters[ii].start;\n            }\n        }\n        else\n        {\n            if (ti->duration - ti->chapters[ii].start != chapter->duration)\n            {\n                hb_log(\"bd: chapter %d invalid duration %\"PRIu64\"\", ii+1,\n                       chapter->duration);\n                chapter->duration = ti->duration - ti->chapters[ii].start;\n            }\n        }\n\n        int seconds      = ( chapter->duration + 45000 ) / 90000;\n        chapter->hours   = ( seconds / 3600 );\n        chapter->minutes = ( seconds % 3600 ) / 60;\n        chapter->seconds = ( seconds % 60 );\n\n        hb_log( \"bd: chap %d, %\"PRIu64\" ms\",\n                chapter->index,\n                chapter->duration / 90 );\n\n        hb_list_add( title->list_chapter, chapter );\n    }\n    hb_log( \"bd: title %d has %d chapters\", tt, ti->chapter_count );\n\n    /* This title is ok so far */\n    goto cleanup;\n\nfail:\n    hb_title_close( &title );\n\ncleanup:\n\n    return title;\n}", "path": "HandBrake/libhb/bd.c", "commit_date": "2020-06-05 00:00:00", "repo_name": "HandBrake/HandBrake", "stars": 15103, "license": "other", "language": "c", "size": 109379}
{"docstring": "/***********************************************************************\n * FindChapterIndex\n ***********************************************************************\n * Assumes pgc and cell_cur are correctly set, and sets cell_next to the\n * cell to be read when we will be done with cell_cur.\n **********************************************************************/\n", "func_signal": "static int FindChapterIndex( hb_list_t * list, int pgcn, int pgn )", "code": "{\n    int count, ii;\n    hb_dvd_chapter_t * chapter;\n\n    count = hb_list_count( list );\n    for (ii = 0; ii < count; ii++)\n    {\n        chapter = hb_list_item( list, ii );\n        if (chapter->pgcn == pgcn && chapter->pgn == pgn)\n            return chapter->index;\n    }\n    return 0;\n}", "path": "HandBrake/libhb/dvdnav.c", "commit_date": "2020-08-20 00:00:00", "repo_name": "HandBrake/HandBrake", "stars": 15103, "license": "other", "language": "c", "size": 109379}
{"docstring": "/***********************************************************************\n * dvdtime2msec\n ***********************************************************************\n * From lsdvd\n **********************************************************************/\n", "func_signal": "static int dvdtime2msec(dvd_time_t * dt)", "code": "{\n    double frames_per_s[4] = {-1.0, 25.00, -1.0, 29.97};\n    double fps = frames_per_s[(dt->frame_u & 0xc0) >> 6];\n    long   ms;\n    ms  = (((dt->hour &   0xf0) >> 3) * 5 + (dt->hour   & 0x0f)) * 3600000;\n    ms += (((dt->minute & 0xf0) >> 3) * 5 + (dt->minute & 0x0f)) * 60000;\n    ms += (((dt->second & 0xf0) >> 3) * 5 + (dt->second & 0x0f)) * 1000;\n\n    if( fps > 0 )\n    {\n        ms += (((dt->frame_u & 0x30) >> 3) * 5 +\n                (dt->frame_u & 0x0f)) * 1000.0 / fps;\n    }\n\n    return ms;\n}", "path": "HandBrake/libhb/dvdnav.c", "commit_date": "2020-08-20 00:00:00", "repo_name": "HandBrake/HandBrake", "stars": 15103, "license": "other", "language": "c", "size": 109379}
{"docstring": "/***********************************************************************\n * hb_dvdnav_chapter\n ***********************************************************************\n * Returns in which chapter the next block to be read is.\n * Chapter numbers start at 1.\n **********************************************************************/\n", "func_signal": "static int hb_dvdnav_chapter( hb_dvd_t * e )", "code": "{\n    hb_dvdnav_t * d = &(e->dvdnav);\n    int32_t t, pgcn, pgn;\n    int32_t c;\n\n    if (dvdnav_current_title_program(d->dvdnav, &t, &pgcn, &pgn) != DVDNAV_STATUS_OK)\n    {\n        return -1;\n    }\n    c = FindChapterIndex( d->list_dvd_chapter, pgcn, pgn );\n    return c;\n}", "path": "HandBrake/libhb/dvdnav.c", "commit_date": "2020-08-20 00:00:00", "repo_name": "HandBrake/HandBrake", "stars": 15103, "license": "other", "language": "c", "size": 109379}
{"docstring": "/***********************************************************************\n * hb_dvdnav_init\n ***********************************************************************\n *\n **********************************************************************/\n", "func_signal": "static hb_dvd_t * hb_dvdnav_init( hb_handle_t * h, const char * path )", "code": "{\n    hb_dvd_t * e;\n    hb_dvdnav_t * d;\n    int region_mask;\n    char * path_ccp;\n\n    e = calloc( sizeof( hb_dvd_t ), 1 );\n    d = &(e->dvdnav);\n    d->h = h;\n\n    /*\n     * Convert UTF-8 path to current code page on Windows\n     * hb_utf8_to_cp() is the same as strdup on non-Windows,\n     * so no #ifdef required here\n     */\n    path_ccp = hb_utf8_to_cp( path );\n\n\t/* Log DVD drive region code */\n    if ( hb_dvd_region( path_ccp, &region_mask ) == 0 )\n    {\n        hb_log( \"dvd: Region mask 0x%02x\", region_mask );\n        if ( region_mask == 0xFF )\n        {\n            hb_log( \"dvd: Warning, DVD device has no region set\" );\n        }\n    }\n\n    /* Open device */\n    if( dvdnav_open(&d->dvdnav, path_ccp) != DVDNAV_STATUS_OK )\n    {\n        /*\n         * Not an error, may be a stream - which we'll try in a moment.\n         */\n        hb_log( \"dvd: not a dvd - trying as a stream/file instead\" );\n        goto fail;\n    }\n\n    if (dvdnav_set_readahead_flag(d->dvdnav, DVD_READ_CACHE) !=\n        DVDNAV_STATUS_OK)\n    {\n        hb_error(\"Error: dvdnav_set_readahead_flag: %s\\n\",\n                 dvdnav_err_to_string(d->dvdnav));\n        goto fail;\n    }\n\n    /*\n     ** set the PGC positioning flag to have position information\n     ** relatively to the whole feature instead of just relatively to the\n     ** current chapter\n     **/\n    if (dvdnav_set_PGC_positioning_flag(d->dvdnav, 1) != DVDNAV_STATUS_OK)\n    {\n        hb_error(\"Error: dvdnav_set_PGC_positioning_flag: %s\\n\",\n                 dvdnav_err_to_string(d->dvdnav));\n        goto fail;\n    }\n\n    /* Open device */\n    if( !( d->reader = DVDOpen( path_ccp ) ) )\n    {\n        /*\n         * Not an error, may be a stream - which we'll try in a moment.\n         */\n        hb_log( \"dvd: not a dvd - trying as a stream/file instead\" );\n        goto fail;\n    }\n\n    /* Open main IFO */\n    if( !( d->vmg = ifoOpen( d->reader, 0 ) ) )\n    {\n        hb_error( \"dvd: ifoOpen failed\" );\n        goto fail;\n    }\n\n    d->path = strdup( path ); /* hb_dvdnav_title_scan assumes UTF-8 path, so not path_ccp here */\n    free( path_ccp );\n\n    return e;\n\nfail:\n    if( d->dvdnav ) dvdnav_close( d->dvdnav );\n    if( d->vmg )    ifoClose( d->vmg );\n    if( d->reader ) DVDClose( d->reader );\n    free( e );\n    free( path_ccp );\n    return NULL;\n}", "path": "HandBrake/libhb/dvdnav.c", "commit_date": "2020-08-20 00:00:00", "repo_name": "HandBrake/HandBrake", "stars": 15103, "license": "other", "language": "c", "size": 109379}
{"docstring": "/***********************************************************************\n * FindNextCell\n ***********************************************************************\n * Assumes pgc and cell_cur are correctly set, and sets cell_next to the\n * cell to be read when we will be done with cell_cur.\n **********************************************************************/\n", "func_signal": "static int FindNextCell( pgc_t *pgc, int cell_cur )", "code": "{\n    int i = 0;\n    int cell_next;\n\n    if( pgc->cell_playback[cell_cur].block_type ==\n            BLOCK_TYPE_ANGLE_BLOCK )\n    {\n\n        while( pgc->cell_playback[cell_cur+i].block_mode !=\n                   BLOCK_MODE_LAST_CELL )\n        {\n             i++;\n        }\n        cell_next = cell_cur + i + 1;\n        hb_log( \"dvd: Skipping multi-angle cells %d-%d\",\n                cell_cur,\n                cell_next - 1 );\n    }\n    else\n    {\n        cell_next = cell_cur + 1;\n    }\n    return cell_next;\n}", "path": "HandBrake/libhb/dvdnav.c", "commit_date": "2020-08-20 00:00:00", "repo_name": "HandBrake/HandBrake", "stars": 15103, "license": "other", "language": "c", "size": 109379}
{"docstring": "// Transmit all pending message blocks\n", "func_signal": "static void\nflush_messages(void)", "code": "{\n    if (!transmit_pos)\n        return;\n    pru_rpmsg_send(&transport, CHAN_PORT, transport_dst\n                   , transmit_buf, transmit_pos);\n    transmit_pos = 0;\n}", "path": "klipper/src/pru/pru0.c", "commit_date": "2019-02-27 00:00:00", "repo_name": "Klipper3d/klipper", "stars": 8453, "license": "gpl-3.0", "language": "c", "size": 167207}
{"docstring": "// Signal PRU1 that a new command is ready\n", "func_signal": "static void\nsend_pru1_command(const struct command_parser *cp)", "code": "{\n    barrier();\n    SHARED_MEM->next_command = cp;\n    barrier();\n    write_r31(R31_WRITE_IRQ_SELECT | (KICK_PRU1_EVENT - R31_WRITE_IRQ_OFFSET));\n}", "path": "klipper/src/pru/pru0.c", "commit_date": "2019-02-27 00:00:00", "repo_name": "Klipper3d/klipper", "stars": 8453, "license": "gpl-3.0", "language": "c", "size": 167207}
{"docstring": "// Generate messages - only used for ack/nak messages\n", "func_signal": "void\nconsole_sendf(const struct command_encoder *ce, va_list args)", "code": "{\n    uint8_t buf[MESSAGE_MIN];\n    build_message(buf, sizeof(buf));\n}", "path": "klipper/src/pru/pru0.c", "commit_date": "2019-02-27 00:00:00", "repo_name": "Klipper3d/klipper", "stars": 8453, "license": "gpl-3.0", "language": "c", "size": 167207}
{"docstring": "// Dispatch all the commands in a message block\n", "func_signal": "static void\ndo_dispatch(uint8_t *buf, uint32_t msglen)", "code": "{\n    uint8_t *p = &buf[MESSAGE_HEADER_SIZE];\n    uint8_t *msgend = &buf[msglen-MESSAGE_TRAILER_SIZE];\n    while (p < msgend) {\n        // Parse command\n        uint_fast8_t cmdid = *p++;\n        const struct command_parser *cp = &SHARED_MEM->command_index[cmdid];\n        if (!cmdid || cmdid >= SHARED_MEM->command_index_size\n            || cp->num_args > ARRAY_SIZE(SHARED_MEM->next_command_args)) {\n            send_pru1_shutdown();\n            return;\n        }\n        p = command_parsef(p, msgend, cp, SHARED_MEM->next_command_args);\n\n        send_pru1_command(ALT_PRU_PTR(cp));\n        wait_pru1_command();\n    }\n}", "path": "klipper/src/pru/pru0.c", "commit_date": "2019-02-27 00:00:00", "repo_name": "Klipper3d/klipper", "stars": 8453, "license": "gpl-3.0", "language": "c", "size": 167207}
{"docstring": "// Process any incoming commands\n", "func_signal": "void\nconsole_task(void)", "code": "{\n    uint_fast8_t rpos = readb(&receive_pos), pop_count;\n    int_fast8_t ret = command_find_block(receive_buf, rpos, &pop_count);\n    if (ret > 0)\n        command_dispatch(receive_buf, pop_count);\n    if (ret) {\n        console_pop_input(pop_count);\n        if (ret > 0)\n            command_send_ack();\n    }\n}", "path": "klipper/src/generic/serial_irq.c", "commit_date": "2019-03-17 00:00:00", "repo_name": "Klipper3d/klipper", "stars": 8453, "license": "gpl-3.0", "language": "c", "size": 167207}
{"docstring": "// Initialize the clocks using an external 32K crystal\n", "func_signal": "static void\nclock_init_32k(void)", "code": "{\n    // Enable external 32Khz crystal\n    uint32_t val = (OSC32KCTRL_XOSC32K_ENABLE | OSC32KCTRL_XOSC32K_EN32K\n                    | OSC32KCTRL_XOSC32K_CGM_XT | OSC32KCTRL_XOSC32K_XTALEN);\n    OSC32KCTRL->XOSC32K.reg = val;\n    while (!(OSC32KCTRL->STATUS.reg & OSC32KCTRL_STATUS_XOSC32KRDY))\n        ;\n\n    // Generate 120Mhz clock on PLL0 (with XOSC32 as reference)\n    uint32_t mul = DIV_ROUND_CLOSEST(FREQ_MAIN, FREQ_32K);\n    config_dpll(0, mul, OSCCTRL_DPLLCTRLB_REFCLK_XOSC32);\n\n    // Switch main clock to 120Mhz PLL0\n    gen_clock(CLKGEN_MAIN, GCLK_GENCTRL_SRC_DPLL0);\n\n    // Generate 48Mhz clock on PLL1 (with XOSC32 as reference)\n    mul = DIV_ROUND_CLOSEST(FREQ_48M, FREQ_32K);\n    config_dpll(1, mul, OSCCTRL_DPLLCTRLB_REFCLK_XOSC32);\n    gen_clock(CLKGEN_48M, GCLK_GENCTRL_SRC_DPLL1);\n}", "path": "klipper/src/atsamd/samd51_clock.c", "commit_date": "2019-11-18 00:00:00", "repo_name": "Klipper3d/klipper", "stars": 8453, "license": "gpl-3.0", "language": "c", "size": 167207}
{"docstring": "// Initialize clocks from factory calibrated internal clock\n", "func_signal": "static void\nclock_init_internal(void)", "code": "{\n    // Enable USB clock recovery mode if applicable\n    if (CONFIG_USBSERIAL) {\n        // Temporarily switch main clock to internal 32K clock\n        gen_clock(CLKGEN_MAIN, GCLK_GENCTRL_SRC_OSCULP32K);\n\n        // Configure DFLL48M clock (with USB 1Khz SOF as reference)\n        uint32_t mul = DIV_ROUND_CLOSEST(FREQ_48M, 1000);\n        uint32_t dfllmul = OSCCTRL_DFLLMUL_FSTEP(10) | OSCCTRL_DFLLMUL_MUL(mul);\n        uint32_t ctrlb = (OSCCTRL_DFLLCTRLB_MODE | OSCCTRL_DFLLCTRLB_USBCRM\n                          | OSCCTRL_DFLLCTRLB_CCDIS);\n        config_dfll(dfllmul, ctrlb);\n    }\n\n    // Route factory calibrated DFLL48M to CLKGEN_48M\n    gen_clock(CLKGEN_48M, GCLK_GENCTRL_SRC_DFLL);\n\n    // Generate CLKGEN_2M (with CLKGEN_48M as reference)\n    uint32_t div = DIV_ROUND_CLOSEST(FREQ_48M, FREQ_2M);\n    gen_clock(CLKGEN_2M, GCLK_GENCTRL_SRC_DFLL | GCLK_GENCTRL_DIV(div));\n\n    // Generate 120Mhz clock on PLL0 (with CLKGEN_2M as reference)\n    route_pclock(OSCCTRL_GCLK_ID_FDPLL0, CLKGEN_2M);\n    uint32_t mul = DIV_ROUND_CLOSEST(FREQ_MAIN, FREQ_2M);\n    config_dpll(0, mul, OSCCTRL_DPLLCTRLB_REFCLK_GCLK);\n\n    // Switch main clock to 120Mhz PLL0\n    gen_clock(CLKGEN_MAIN, GCLK_GENCTRL_SRC_DPLL0);\n}", "path": "klipper/src/atsamd/samd51_clock.c", "commit_date": "2019-11-18 00:00:00", "repo_name": "Klipper3d/klipper", "stars": 8453, "license": "gpl-3.0", "language": "c", "size": 167207}
{"docstring": "// Rx interrupt - store read data\n", "func_signal": "void\nserial_rx_byte(uint_fast8_t data)", "code": "{\n    if (data == MESSAGE_SYNC)\n        sched_wake_tasks();\n    if (receive_pos >= sizeof(receive_buf))\n        // Serial overflow - ignore it as crc error will force retransmit\n        return;\n    receive_buf[receive_pos++] = data;\n}", "path": "klipper/src/generic/serial_irq.c", "commit_date": "2019-03-17 00:00:00", "repo_name": "Klipper3d/klipper", "stars": 8453, "license": "gpl-3.0", "language": "c", "size": 167207}
{"docstring": "// Generate a message block and queue it for transmission\n", "func_signal": "static void\nbuild_message(uint8_t *msg, int msglen)", "code": "{\n    if (transmit_pos + msglen > sizeof(transmit_buf))\n        flush_messages();\n    memcpy(&transmit_buf[transmit_pos], msg, msglen);\n    command_add_frame(&transmit_buf[transmit_pos], msglen);\n    transmit_pos += msglen;\n}", "path": "klipper/src/pru/pru0.c", "commit_date": "2019-02-27 00:00:00", "repo_name": "Klipper3d/klipper", "stars": 8453, "license": "gpl-3.0", "language": "c", "size": 167207}
{"docstring": "// Main processing loop\n", "func_signal": "static void\nprocess_io(void)", "code": "{\n    for (;;) {\n        CT_INTC.SECR0 = ((1 << KICK_PRU0_FROM_ARM_EVENT)\n                         | (1 << KICK_PRU0_EVENT));\n        check_can_send();\n        int can_sleep = check_can_read();\n        if (can_sleep) {\n            flush_messages();\n            while (!(read_r31() & (1 << (WAKE_PRU0_IRQ + R31_IRQ_OFFSET)))) {\n                //asm(\"slp 1\");\n            }\n        }\n    }\n}", "path": "klipper/src/pru/pru0.c", "commit_date": "2019-02-27 00:00:00", "repo_name": "Klipper3d/klipper", "stars": 8453, "license": "gpl-3.0", "language": "c", "size": 167207}
{"docstring": "// Remove from the receive buffer the given number of bytes\n", "func_signal": "static void\nconsole_pop_input(uint_fast8_t len)", "code": "{\n    uint_fast8_t copied = 0;\n    for (;;) {\n        uint_fast8_t rpos = readb(&receive_pos);\n        uint_fast8_t needcopy = rpos - len;\n        if (needcopy) {\n            memmove(&receive_buf[copied], &receive_buf[copied + len]\n                    , needcopy - copied);\n            copied = needcopy;\n            sched_wake_tasks();\n        }\n        irqstatus_t flag = irq_save();\n        if (rpos != readb(&receive_pos)) {\n            // Raced with irq handler - retry\n            irq_restore(flag);\n            continue;\n        }\n        receive_pos = needcopy;\n        irq_restore(flag);\n        break;\n    }\n}", "path": "klipper/src/generic/serial_irq.c", "commit_date": "2019-03-17 00:00:00", "repo_name": "Klipper3d/klipper", "stars": 8453, "license": "gpl-3.0", "language": "c", "size": 167207}
{"docstring": "// Configure the dfll\n", "func_signal": "static void\nconfig_dfll(uint32_t dfllmul, uint32_t ctrlb)", "code": "{\n    // Disable the dfllmul and reenable in this order due to chip errata\n    OSCCTRL->DFLLCTRLA.reg = 0;\n    while (OSCCTRL->DFLLSYNC.reg & OSCCTRL_DFLLSYNC_ENABLE)\n        ;\n    OSCCTRL->DFLLMUL.reg = dfllmul;\n    while (OSCCTRL->DFLLSYNC.reg & OSCCTRL_DFLLSYNC_DFLLMUL)\n        ;\n    OSCCTRL->DFLLCTRLB.reg = 0;\n    while (OSCCTRL->DFLLSYNC.reg & OSCCTRL_DFLLSYNC_DFLLCTRLB)\n        ;\n    OSCCTRL->DFLLCTRLA.reg = OSCCTRL_DFLLCTRLA_ENABLE;\n    while (OSCCTRL->DFLLSYNC.reg & OSCCTRL_DFLLSYNC_ENABLE)\n        ;\n    OSCCTRL->DFLLVAL.reg = OSCCTRL->DFLLVAL.reg;\n    while(OSCCTRL->DFLLSYNC.reg & OSCCTRL_DFLLSYNC_DFLLVAL)\n        ;\n    OSCCTRL->DFLLCTRLB.reg = ctrlb;\n    while (OSCCTRL->DFLLSYNC.reg & OSCCTRL_DFLLSYNC_DFLLCTRLB)\n        ;\n}", "path": "klipper/src/atsamd/samd51_clock.c", "commit_date": "2019-11-18 00:00:00", "repo_name": "Klipper3d/klipper", "stars": 8453, "license": "gpl-3.0", "language": "c", "size": 167207}
{"docstring": "/****************************************************************\n * General Purpose Input Output (GPIO) pins\n ****************************************************************/\n", "func_signal": "struct gpio_out\ngpio_out_setup(uint8_t pin, uint8_t val)", "code": "{\n    if (GPIO2PORT(pin) >= ARRAY_SIZE(digital_regs))\n        goto fail;\n    struct gpio_regs *regs = digital_regs[GPIO2PORT(pin)];\n    uint32_t bit = GPIO2BIT(pin);\n    struct gpio_out rv = (struct gpio_out){.reg=&regs->cleardataout, .bit=bit};\n    gpio_out_write(rv, val);\n    regs->oe &= ~bit;\n    set_pin_mux(pin, 0x0f);\n    return rv;\nfail:\n    shutdown(\"Not an output pin\");\n}", "path": "klipper/src/pru/gpio.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "Klipper3d/klipper", "stars": 8453, "license": "gpl-3.0", "language": "c", "size": 167207}
{"docstring": "// Startup initialization\n", "func_signal": "static void\nsetup_io(void)", "code": "{\n    // Fixup pointers in command_parsers\n    SHARED_MEM->command_index = ALT_PRU_PTR(SHARED_MEM->command_index);\n    struct command_parser *p = (void*)SHARED_MEM->command_index;\n    int i;\n    for (i=0; i<SHARED_MEM->command_index_size; i++, p++)\n        if (p->param_types)\n            p->param_types = ALT_PRU_PTR(p->param_types);\n}", "path": "klipper/src/pru/pru0.c", "commit_date": "2019-02-27 00:00:00", "repo_name": "Klipper3d/klipper", "stars": 8453, "license": "gpl-3.0", "language": "c", "size": 167207}
{"docstring": "// Route a peripheral clock to a given clkgen\n", "func_signal": "static inline void\nroute_pclock(uint32_t pclk_id, uint32_t clkgen_id)", "code": "{\n    uint32_t val = GCLK_PCHCTRL_GEN(clkgen_id) | GCLK_PCHCTRL_CHEN;\n    GCLK->PCHCTRL[pclk_id].reg = val;\n    while (GCLK->PCHCTRL[pclk_id].reg != val)\n        ;\n}", "path": "klipper/src/atsamd/samd51_clock.c", "commit_date": "2019-11-18 00:00:00", "repo_name": "Klipper3d/klipper", "stars": 8453, "license": "gpl-3.0", "language": "c", "size": 167207}
{"docstring": "// Instruct PRU1 to shutdown\n", "func_signal": "static void\nsend_pru1_shutdown(void)", "code": "{\n    wait_pru1_command();\n    send_pru1_command(SHARED_MEM->shutdown_handler);\n    wait_pru1_command();\n}", "path": "klipper/src/pru/pru0.c", "commit_date": "2019-02-27 00:00:00", "repo_name": "Klipper3d/klipper", "stars": 8453, "license": "gpl-3.0", "language": "c", "size": 167207}
{"docstring": "// See if there are commands from the host ready to be processed\n", "func_signal": "static int\ncheck_can_read(void)", "code": "{\n    // Read data\n    uint16_t dst, len;\n    uint8_t *p = SHARED_MEM->read_data;\n    int16_t ret = pru_rpmsg_receive(&transport, &transport_dst, &dst, p, &len);\n    if (ret)\n        return ret == PRU_RPMSG_NO_BUF_AVAILABLE;\n\n    // Check for force shutdown request\n    if (len == 15 && p[14] == '\\n' && memcmp(p, \"FORCE_SHUTDOWN\\n\", 15) == 0) {\n        send_pru1_shutdown();\n        return 0;\n    }\n\n    // Parse data into message blocks\n    for (;;) {\n        uint_fast8_t pop_count, msglen = len > MESSAGE_MAX ? MESSAGE_MAX : len;\n        int_fast8_t ret = command_find_block(p, msglen, &pop_count);\n        if (!ret)\n            break;\n        if (ret > 0) {\n            do_dispatch(p, pop_count);\n            command_send_ack();\n        }\n        p += pop_count;\n        len -= pop_count;\n    }\n    return 0;\n}", "path": "klipper/src/pru/pru0.c", "commit_date": "2019-02-27 00:00:00", "repo_name": "Klipper3d/klipper", "stars": 8453, "license": "gpl-3.0", "language": "c", "size": 167207}
{"docstring": "// Configure a dpll to a given clock multiplier\n", "func_signal": "static void\nconfig_dpll(uint32_t pll, uint32_t mul, uint32_t ctrlb)", "code": "{\n    OSCCTRL->Dpll[pll].DPLLCTRLA.reg = 0;\n    while (OSCCTRL->Dpll[0].DPLLSYNCBUSY.reg & OSCCTRL_DPLLSYNCBUSY_ENABLE)\n        ;\n    OSCCTRL->Dpll[pll].DPLLRATIO.reg = OSCCTRL_DPLLRATIO_LDR(mul - 1);\n    while (OSCCTRL->Dpll[0].DPLLSYNCBUSY.reg & OSCCTRL_DPLLSYNCBUSY_DPLLRATIO)\n        ;\n    OSCCTRL->Dpll[pll].DPLLCTRLB.reg = ctrlb | OSCCTRL_DPLLCTRLB_LBYPASS;\n    OSCCTRL->Dpll[pll].DPLLCTRLA.reg = OSCCTRL_DPLLCTRLA_ENABLE;\n    uint32_t mask = OSCCTRL_DPLLSTATUS_CLKRDY | OSCCTRL_DPLLSTATUS_LOCK;\n    while ((OSCCTRL->Dpll[pll].DPLLSTATUS.reg & mask) != mask)\n        ;\n}", "path": "klipper/src/atsamd/samd51_clock.c", "commit_date": "2019-11-18 00:00:00", "repo_name": "Klipper3d/klipper", "stars": 8453, "license": "gpl-3.0", "language": "c", "size": 167207}
{"docstring": "// Check if there is data to be sent from PRU1 to the host\n", "func_signal": "static void\ncheck_can_send(void)", "code": "{\n    for (;;) {\n        uint32_t send_pop_pos = SHARED_MEM->send_pop_pos;\n        struct shared_response_buffer *s = &SHARED_MEM->send_data[send_pop_pos];\n        uint32_t count = readl(&s->count);\n        if (!count)\n            // Queue empty\n            break;\n        build_message(s->data, count);\n        writel(&s->count, 0);\n        SHARED_MEM->send_pop_pos = (\n            (send_pop_pos + 1) % ARRAY_SIZE(SHARED_MEM->send_data));\n    }\n}", "path": "klipper/src/pru/pru0.c", "commit_date": "2019-02-27 00:00:00", "repo_name": "Klipper3d/klipper", "stars": 8453, "license": "gpl-3.0", "language": "c", "size": 167207}
{"docstring": "// Configure a clock generator using a given source as input\n", "func_signal": "static inline void\ngen_clock(uint32_t clkgen_id, uint32_t flags)", "code": "{\n    GCLK->GENCTRL[clkgen_id].reg = flags | GCLK_GENCTRL_GENEN;\n    while (GCLK->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL(1 << clkgen_id))\n        ;\n}", "path": "klipper/src/atsamd/samd51_clock.c", "commit_date": "2019-11-18 00:00:00", "repo_name": "Klipper3d/klipper", "stars": 8453, "license": "gpl-3.0", "language": "c", "size": 167207}
{"docstring": "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r R G B I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterRGBImage() removes format registrations made by the RGB module\n%  from the list of supported formats.\n%\n%  The format of the UnregisterRGBImage method is:\n%\n%      UnregisterRGBImage(void)\n%\n*/\n", "func_signal": "ModuleExport void UnregisterRGBImage(void)", "code": "{\n  (void) UnregisterMagickInfo(\"RGBO\");\n  (void) UnregisterMagickInfo(\"RGBA\");\n  (void) UnregisterMagickInfo(\"RGB\");\n}", "path": "ImageMagick/coders/rgb.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "ImageMagick/ImageMagick", "stars": 10773, "license": "other", "language": "c", "size": 166162}
{"docstring": "/* Simplify the exception handling\n * technically we should abort the program if\n *      severity >= ErrorException\n */\n", "func_signal": "void ThrowWandException(MagickWand *wand)", "code": "{ char\n  *description;\n\n  ExceptionType\n  severity;\n\n  description=MagickGetException(wand,&severity);\n  (void) fprintf(stderr,\"%s %s %lu %s\\n\",GetMagickModule(),description);\n  description=(char *) MagickRelinquishMemory(description);\n}", "path": "ImageMagick/MagickWand/tests/add_norm_lists.c", "commit_date": "2012-03-29 00:00:00", "repo_name": "ImageMagick/ImageMagick", "stars": 10773, "license": "other", "language": "c", "size": 166162}
{"docstring": "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r I C O N I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterICONImage() removes format registrations made by the\n%  ICON module from the list of supported formats.\n%\n%  The format of the UnregisterICONImage method is:\n%\n%      UnregisterICONImage(void)\n%\n*/\n", "func_signal": "ModuleExport void UnregisterICONImage(void)", "code": "{\n  (void) UnregisterMagickInfo(\"CUR\");\n  (void) UnregisterMagickInfo(\"ICO\");\n  (void) UnregisterMagickInfo(\"ICON\");\n}", "path": "ImageMagick/coders/icon.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "ImageMagick/ImageMagick", "stars": 10773, "license": "other", "language": "c", "size": 166162}
{"docstring": "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   M a g i c C o m p o n e n t T e r m i n u s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MagicComponentTerminus() destroys the magic component.\n%\n%  The format of the MagicComponentTerminus method is:\n%\n%      MagicComponentTerminus(void)\n%\n*/\n", "func_signal": "static void *DestroyMagicElement(void *magic_info)", "code": "{\n  MagicInfo\n    *p;\n\n  p=(MagicInfo *) magic_info;\n  if (p->exempt == MagickFalse)\n    {\n      if (p->path != (char *) NULL)\n        p->path=DestroyString(p->path);\n      if (p->name != (char *) NULL)\n        p->name=DestroyString(p->name);\n      if (p->target != (char *) NULL)\n        p->target=DestroyString(p->target);\n      if (p->magic != (unsigned char *) NULL)\n        p->magic=(unsigned char *) RelinquishMagickMemory(p->magic);\n    }\n  p=(MagicInfo *) RelinquishMagickMemory(p);\n  return((void *) NULL);\n}", "path": "ImageMagick/MagickCore/magic.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "ImageMagick/ImageMagick", "stars": 10773, "license": "other", "language": "c", "size": 166162}
{"docstring": "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r M P R I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterMPRImage() removes format registrations made by the\n%  MPR module from the list of supported formats.\n%\n%  The format of the UnregisterMPRImage method is:\n%\n%      UnregisterMPRImage(void)\n%\n*/\n", "func_signal": "ModuleExport void UnregisterMPRImage(void)", "code": "{\n  (void) UnregisterMagickInfo(\"MPRI\");\n  (void) UnregisterMagickInfo(\"MPR\");\n}", "path": "ImageMagick/coders/mpr.c", "commit_date": "2019-11-26 00:00:00", "repo_name": "ImageMagick/ImageMagick", "stars": 10773, "license": "other", "language": "c", "size": 166162}
{"docstring": "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   E l a p s e d T i m e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ElapsedTime() returns the elapsed time (in seconds) since the last call to\n%  StartTimer().\n%\n%  The format of the ElapsedTime method is:\n%\n%      double ElapsedTime()\n%\n*/\n", "func_signal": "static double ElapsedTime(void)", "code": "{\n#if defined(MAGICKCORE_HAVE_CLOCK_GETTIME)\n#define NANOSECONDS_PER_SECOND  1000000000.0\n#if defined(CLOCK_HIGHRES)\n#  define CLOCK_ID CLOCK_HIGHRES\n#elif defined(CLOCK_MONOTONIC_RAW)\n#  define CLOCK_ID CLOCK_MONOTONIC_RAW\n#elif defined(CLOCK_MONOTONIC_PRECISE)\n#  define CLOCK_ID CLOCK_MONOTONIC_PRECISE\n#elif defined(CLOCK_MONOTONIC)\n#  define CLOCK_ID CLOCK_MONOTONIC\n#else\n#  define CLOCK_ID CLOCK_REALTIME\n#endif\n\n  struct timespec \n    timer;\n\n  (void) clock_gettime(CLOCK_ID,&timer);\n  return((double) timer.tv_sec+timer.tv_nsec/NANOSECONDS_PER_SECOND);\n#elif defined(MAGICKCORE_HAVE_TIMES) && defined(MAGICKCORE_HAVE_SYSCONF)\n  struct tms\n    timer;\n\n  return((double) times(&timer)/sysconf(_SC_CLK_TCK));\n#else\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  return(NTElapsedTime());\n#else\n  return((double) clock()/CLOCKS_PER_SEC);\n#endif\n#endif\n}", "path": "ImageMagick/MagickCore/timer.c", "commit_date": "2020-01-26 00:00:00", "repo_name": "ImageMagick/ImageMagick", "stars": 10773, "license": "other", "language": "c", "size": 166162}
{"docstring": "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r G R A Y I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterGRAYImage() removes format registrations made by the GRAY module\n%  from the list of supported formats.\n%\n%  The format of the UnregisterGRAYImage method is:\n%\n%      UnregisterGRAYImage(void)\n%\n*/\n", "func_signal": "ModuleExport void UnregisterGRAYImage(void)", "code": "{\n  (void) UnregisterMagickInfo(\"GRAYA\");\n  (void) UnregisterMagickInfo(\"GRAY\");\n}", "path": "ImageMagick/coders/gray.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "ImageMagick/ImageMagick", "stars": 10773, "license": "other", "language": "c", "size": 166162}
{"docstring": "/* Simplify the exception handling\n * technically we should abort the program if\n *      severity >= ErrorException\n */\n", "func_signal": "void ThrowWandException(MagickWand *wand)", "code": "{ char\n  *description;\n\n  ExceptionType\n  severity;\n\n  description=MagickGetException(wand,&severity);\n  (void) fprintf(stderr,\"%s %s %lu %s\\n\",GetMagickModule(),description);\n  description=(char *) MagickRelinquishMemory(description);\n}", "path": "ImageMagick/MagickWand/tests/add_first_lists.c", "commit_date": "2012-03-29 00:00:00", "repo_name": "ImageMagick/ImageMagick", "stars": 10773, "license": "other", "language": "c", "size": 166162}
{"docstring": "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r R A W I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterRAWImage() removes format registrations made by the RAW module\n%  from the list of supported formats.\n%\n%  The format of the UnregisterRAWImage method is:\n%\n%      UnregisterRAWImage(void)\n%\n*/\n", "func_signal": "ModuleExport void UnregisterRAWImage(void)", "code": "{\n  (void) UnregisterMagickInfo(\"R\");\n  (void) UnregisterMagickInfo(\"C\");\n  (void) UnregisterMagickInfo(\"G\");\n  (void) UnregisterMagickInfo(\"M\");\n  (void) UnregisterMagickInfo(\"B\");\n  (void) UnregisterMagickInfo(\"Y\");\n  (void) UnregisterMagickInfo(\"A\");\n  (void) UnregisterMagickInfo(\"O\");\n  (void) UnregisterMagickInfo(\"K\");\n}", "path": "ImageMagick/coders/raw.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "ImageMagick/ImageMagick", "stars": 10773, "license": "other", "language": "c", "size": 166162}
{"docstring": "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   M a g i c C o m p o n e n t G e n e s i s                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MagicComponentGenesis() instantiates the magic component.\n%\n%  The format of the MagicComponentGenesis method is:\n%\n%      MagickBooleanType MagicComponentGenesis(void)\n%\n*/\n", "func_signal": "MagickPrivate MagickBooleanType MagicComponentGenesis(void)", "code": "{\n  if (magic_list_semaphore == (SemaphoreInfo *) NULL)\n    magic_list_semaphore=AcquireSemaphoreInfo();\n  return(MagickTrue);\n}", "path": "ImageMagick/MagickCore/magic.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "ImageMagick/ImageMagick", "stars": 10773, "license": "other", "language": "c", "size": 166162}
{"docstring": "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T T F I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTTFImage() removes format registrations made by the\n%  TTF module from the list of supported formats.\n%\n%  The format of the UnregisterTTFImage method is:\n%\n%      UnregisterTTFImage(void)\n%\n*/\n", "func_signal": "ModuleExport void UnregisterTTFImage(void)", "code": "{\n  (void) UnregisterMagickInfo(\"TTF\");\n  (void) UnregisterMagickInfo(\"TTC\");\n  (void) UnregisterMagickInfo(\"OTF\");\n  (void) UnregisterMagickInfo(\"PFA\");\n  (void) UnregisterMagickInfo(\"PFB\");\n  (void) UnregisterMagickInfo(\"PFA\");\n  (void) UnregisterMagickInfo(\"DFONT\");\n}", "path": "ImageMagick/coders/ttf.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "ImageMagick/ImageMagick", "stars": 10773, "license": "other", "language": "c", "size": 166162}
{"docstring": "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r D O T I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterDOTImage() removes format registrations made by the\n%  DOT module from the list of supported formats.\n%\n%  The format of the UnregisterDOTImage method is:\n%\n%      UnregisterDOTImage(void)\n%\n*/\n", "func_signal": "ModuleExport void UnregisterDOTImage(void)", "code": "{\n  (void) UnregisterMagickInfo(\"GV\");\n  (void) UnregisterMagickInfo(\"DOT\");\n#if defined(MAGICKCORE_GVC_DELEGATE)\n  if (graphic_context != (GVC_t *) NULL)\n    {\n      gvFreeContext(graphic_context);\n      graphic_context=(GVC_t *) NULL;\n    }\n#endif\n}", "path": "ImageMagick/coders/dot.c", "commit_date": "2020-10-30 00:00:00", "repo_name": "ImageMagick/ImageMagick", "stars": 10773, "license": "other", "language": "c", "size": 166162}
{"docstring": "/* Simplify the exception handling\n * technically we should abort the program if\n *      severity >= ErrorException\n */\n", "func_signal": "void ThrowWandException(MagickWand *wand)", "code": "{ char\n  *description;\n\n  ExceptionType\n  severity;\n\n  description=MagickGetException(wand,&severity);\n  (void) fprintf(stderr,\"%s %s %lu %s\\n\",GetMagickModule(),description);\n  description=(char *) MagickRelinquishMemory(description);\n}", "path": "ImageMagick/MagickWand/tests/loop_over_lists.c", "commit_date": "2012-03-29 00:00:00", "repo_name": "ImageMagick/ImageMagick", "stars": 10773, "license": "other", "language": "c", "size": 166162}
{"docstring": "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r G R A D I E N T I m a g e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterGRADIENTImage() removes format registrations made by the\n%  GRADIENT module from the list of supported formats.\n%\n%  The format of the UnregisterGRADIENTImage method is:\n%\n%      UnregisterGRADIENTImage(void)\n%\n*/\n", "func_signal": "ModuleExport void UnregisterGRADIENTImage(void)", "code": "{\n  (void) UnregisterMagickInfo(\"RADIAL-GRADIENT\");\n  (void) UnregisterMagickInfo(\"GRADIENT\");\n}", "path": "ImageMagick/coders/gradient.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "ImageMagick/ImageMagick", "stars": 10773, "license": "other", "language": "c", "size": 166162}
{"docstring": "/*\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %   R e g i s t e r I P L I m a g e                                           %\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %\n % RegisterIPLImage() add attributes for the Scanalytics IPL image format to the\n % list of supported formats.  \n %\n %\n */\n", "func_signal": "ModuleExport size_t RegisterIPLImage(void)", "code": "{\n  MagickInfo\n    *entry;\n  \n  entry=AcquireMagickInfo(\"IPL\",\"IPL\",\"IPL Image Sequence\");\n  entry->decoder=(DecodeImageHandler *) ReadIPLImage;\n  entry->encoder=(EncodeImageHandler *) WriteIPLImage;\n  entry->magick=(IsImageFormatHandler *) IsIPL;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}", "path": "ImageMagick/coders/ipl.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "ImageMagick/ImageMagick", "stars": 10773, "license": "other", "language": "c", "size": 166162}
{"docstring": "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r C A L S I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterCALSImage() removes format registrations made by the\n%  CALS module from the list of supported formats.\n%\n%  The format of the UnregisterCALSImage method is:\n%\n%      UnregisterCALSImage(void)\n%\n*/\n", "func_signal": "ModuleExport void UnregisterCALSImage(void)", "code": "{\n  (void) UnregisterMagickInfo(\"CAL\");\n  (void) UnregisterMagickInfo(\"CALS\");\n}", "path": "ImageMagick/coders/cals.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "ImageMagick/ImageMagick", "stars": 10773, "license": "other", "language": "c", "size": 166162}
{"docstring": "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   U s e r T i m e                                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UserTime() returns the total time the process has been scheduled (in\n%  seconds) since the last call to StartTimer().\n%\n%  The format of the UserTime method is:\n%\n%      double UserTime()\n%\n*/\n", "func_signal": "static double UserTime(void)", "code": "{\n#if defined(MAGICKCORE_HAVE_TIMES) && defined(MAGICKCORE_HAVE_SYSCONF)\n  struct tms\n    timer;\n\n  (void) times(&timer);\n  return((double) (timer.tms_utime+timer.tms_stime)/sysconf(_SC_CLK_TCK));\n#else\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  return(NTUserTime());\n#else\n  return((double) clock()/CLOCKS_PER_SEC);\n#endif\n#endif\n}", "path": "ImageMagick/MagickCore/timer.c", "commit_date": "2020-01-26 00:00:00", "repo_name": "ImageMagick/ImageMagick", "stars": 10773, "license": "other", "language": "c", "size": 166162}
{"docstring": "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t M a g i c k T i m e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetMagickTime() returns the time as the number of seconds since the Epoch.\n%\n%  The format of the GetElapsedTime method is:\n%\n%      time_t GetElapsedTime(void)\n%\n*/\n", "func_signal": "MagickExport time_t GetMagickTime(void)", "code": "{\n  static const char\n    *source_date_epoch = (const char *) NULL;\n\n  static MagickBooleanType\n    epoch_initalized = MagickFalse;\n\n  if (epoch_initalized == MagickFalse)\n    {\n      source_date_epoch=getenv(\"SOURCE_DATE_EPOCH\");\n      epoch_initalized=MagickTrue;\n    }\n  if (source_date_epoch != (const char *) NULL)\n    {\n      time_t\n        epoch;\n\n      epoch=(time_t) StringToDouble(source_date_epoch,(char **) NULL);\n      if ((epoch > 0) && (epoch <= time((time_t *) NULL)))\n        return(epoch);\n    }\n  return(time((time_t *) NULL));\n}", "path": "ImageMagick/MagickCore/timer.c", "commit_date": "2020-01-26 00:00:00", "repo_name": "ImageMagick/ImageMagick", "stars": 10773, "license": "other", "language": "c", "size": 166162}
{"docstring": "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e T i m e r I n f o                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireTimerInfo() initializes the TimerInfo structure.  It effectively\n%  creates a stopwatch and starts it.\n%\n%  The format of the AcquireTimerInfo method is:\n%\n%      TimerInfo *AcquireTimerInfo(void)\n%\n*/\n", "func_signal": "MagickExport TimerInfo *AcquireTimerInfo(void)", "code": "{\n  TimerInfo\n    *timer_info;\n\n  timer_info=(TimerInfo *) AcquireCriticalMemory(sizeof(*timer_info));\n  (void) memset(timer_info,0,sizeof(*timer_info));\n  timer_info->signature=MagickCoreSignature;\n  GetTimerInfo(timer_info);\n  return(timer_info);\n}", "path": "ImageMagick/MagickCore/timer.c", "commit_date": "2020-01-26 00:00:00", "repo_name": "ImageMagick/ImageMagick", "stars": 10773, "license": "other", "language": "c", "size": 166162}
{"docstring": "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S t o p T i m e r                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  StopTimer() stops the stopwatch.\n%\n%  The format of the StopTimer method is:\n%\n%      void StopTimer(TimerInfo *time_info)\n%\n%  A description of each parameter follows.\n%\n%    o  time_info: Timer statistics structure.\n%\n*/\n", "func_signal": "static void StopTimer(TimerInfo *time_info)", "code": "{\n  assert(time_info != (TimerInfo *) NULL);\n  assert(time_info->signature == MagickCoreSignature);\n  time_info->elapsed.stop=ElapsedTime();\n  time_info->user.stop=UserTime();\n  if (time_info->state == RunningTimerState)\n    {\n      time_info->user.total+=time_info->user.stop-\n        time_info->user.start+MagickEpsilon;\n      time_info->elapsed.total+=time_info->elapsed.stop-\n        time_info->elapsed.start+MagickEpsilon;\n    }\n  time_info->state=StoppedTimerState;\n}", "path": "ImageMagick/MagickCore/timer.c", "commit_date": "2020-01-26 00:00:00", "repo_name": "ImageMagick/ImageMagick", "stars": 10773, "license": "other", "language": "c", "size": 166162}
{"docstring": "/*\n * Returns true if configuration file has a valid syntax, otherwise\n * returns false\n */\n", "func_signal": "static bool\nnc_test_conf(struct instance *nci)", "code": "{\n    struct conf *cf;\n\n    cf = conf_create(nci->conf_filename);\n    if (cf == NULL) {\n        log_stderr(\"nutcracker: configuration file '%s' syntax is invalid\",\n                   nci->conf_filename);\n        return false;\n    }\n\n    conf_destroy(cf);\n\n    log_stderr(\"nutcracker: configuration file '%s' syntax is ok\",\n               nci->conf_filename);\n    return true;\n}", "path": "twemproxy/src/nc.c", "commit_date": "2014-12-07 00:00:00", "repo_name": "twitter/twemproxy", "stars": 11992, "license": "apache-2.0", "language": "c", "size": 2961}
{"docstring": "/*\n * Return true, if the memcache command is a storage command, otherwise\n * return false\n */\n", "func_signal": "static bool\nmemcache_storage(struct msg *r)", "code": "{\n    switch (r->type) {\n    case MSG_REQ_MC_SET:\n    case MSG_REQ_MC_CAS:\n    case MSG_REQ_MC_ADD:\n    case MSG_REQ_MC_REPLACE:\n    case MSG_REQ_MC_APPEND:\n    case MSG_REQ_MC_PREPEND:\n        return true;\n\n    default:\n        break;\n    }\n\n    return false;\n}", "path": "twemproxy/src/proto/nc_memcache.c", "commit_date": "2015-06-20 00:00:00", "repo_name": "twitter/twemproxy", "stars": 11992, "license": "apache-2.0", "language": "c", "size": 2961}
{"docstring": "/*\n * Return true, if the memcache command is a delete command, otherwise\n * return false\n */\n", "func_signal": "static bool\nmemcache_delete(struct msg *r)", "code": "{\n    if (r->type == MSG_REQ_MC_DELETE) {\n        return true;\n    }\n\n    return false;\n}", "path": "twemproxy/src/proto/nc_memcache.c", "commit_date": "2015-06-20 00:00:00", "repo_name": "twitter/twemproxy", "stars": 11992, "license": "apache-2.0", "language": "c", "size": 2961}
{"docstring": "/*\n * Copy one response from src to dst and return bytes copied\n */\n", "func_signal": "static rstatus_t\nmemcache_copy_bulk(struct msg *dst, struct msg *src)", "code": "{\n    struct mbuf *mbuf, *nbuf;\n    uint8_t *p;\n    uint32_t len = 0;\n    uint32_t bytes = 0;\n    uint32_t i = 0;\n\n    for (mbuf = STAILQ_FIRST(&src->mhdr);\n         mbuf && mbuf_empty(mbuf);\n         mbuf = STAILQ_FIRST(&src->mhdr)) {\n\n        mbuf_remove(&src->mhdr, mbuf);\n        mbuf_put(mbuf);\n    }\n\n    mbuf = STAILQ_FIRST(&src->mhdr);\n    if (mbuf == NULL) {\n        return NC_OK;           /* key not exists */\n    }\n    p = mbuf->pos;\n\n    /*\n     * get : VALUE key 0 len\\r\\nval\\r\\n\n     * gets: VALUE key 0 len cas\\r\\nval\\r\\n\n     */\n    ASSERT(*p == 'V');\n    for (i = 0; i < 3; i++) {                 /*  eat 'VALUE key 0 '  */\n        for (; *p != ' ';) {\n            p++;\n        }\n        p++;\n    }\n\n    len = 0;\n    for (; p < mbuf->last && isdigit(*p); p++) {\n        len = len * 10 + (uint32_t)(*p - '0');\n    }\n\n    for (; p < mbuf->last && ('\\r' != *p); p++) { /* eat cas for gets */\n        ;\n    }\n\n    len += CRLF_LEN * 2;\n    len += (p - mbuf->pos);\n\n    bytes = len;\n\n    /* copy len bytes to dst */\n    for (; mbuf;) {\n        if (mbuf_length(mbuf) <= len) {   /* steal this mbuf from src to dst */\n            nbuf = STAILQ_NEXT(mbuf, next);\n            mbuf_remove(&src->mhdr, mbuf);\n            mbuf_insert(&dst->mhdr, mbuf);\n            len -= mbuf_length(mbuf);\n            mbuf = nbuf;\n        } else {                        /* split it */\n            nbuf = mbuf_get();\n            if (nbuf == NULL) {\n                return NC_ENOMEM;\n            }\n            mbuf_copy(nbuf, mbuf->pos, len);\n            mbuf_insert(&dst->mhdr, nbuf);\n            mbuf->pos += len;\n            break;\n        }\n    }\n\n    dst->mlen += bytes;\n    src->mlen -= bytes;\n    log_debug(LOG_VVERB, \"memcache_copy_bulk copy bytes: %d\", bytes);\n    return NC_OK;\n}", "path": "twemproxy/src/proto/nc_memcache.c", "commit_date": "2015-06-20 00:00:00", "repo_name": "twitter/twemproxy", "stars": 11992, "license": "apache-2.0", "language": "c", "size": 2961}
{"docstring": "/*\n * Return true, if the memcache command is a retrieval command, otherwise\n * return false\n */\n", "func_signal": "static bool\nmemcache_retrieval(struct msg *r)", "code": "{\n    switch (r->type) {\n    case MSG_REQ_MC_GET:\n    case MSG_REQ_MC_GETS:\n        return true;\n\n    default:\n        break;\n    }\n\n    return false;\n}", "path": "twemproxy/src/proto/nc_memcache.c", "commit_date": "2015-06-20 00:00:00", "repo_name": "twitter/twemproxy", "stars": 11992, "license": "apache-2.0", "language": "c", "size": 2961}
{"docstring": "/*\n * Post-coalesce handler is invoked when the message is a response to\n * the fragmented multi vector request - 'get' or 'gets' and all the\n * responses to the fragmented request vector has been received and\n * the fragmented request is consider to be done\n */\n", "func_signal": "void\nmemcache_post_coalesce(struct msg *request)", "code": "{\n    struct msg *response = request->peer;\n    struct msg *sub_msg;\n    uint32_t i;\n    rstatus_t status;\n\n    ASSERT(!response->request);\n    ASSERT(request->request && (request->frag_owner == request));\n    if (request->error || request->ferror) {\n        response->owner->err = 1;\n        return;\n    }\n\n    for (i = 0; i < array_n(request->keys); i++) {      /* for each  key */\n        sub_msg = request->frag_seq[i]->peer;           /* get it's peer response */\n        if (sub_msg == NULL) {\n            response->owner->err = 1;\n            return;\n        }\n        status = memcache_copy_bulk(response, sub_msg);\n        if (status != NC_OK) {\n            response->owner->err = 1;\n            return;\n        }\n    }\n\n    /* append END\\r\\n */\n    status = msg_append(response, (uint8_t *)\"END\\r\\n\", 5);\n    if (status != NC_OK) {\n        response->owner->err = 1;\n        return;\n    }\n}", "path": "twemproxy/src/proto/nc_memcache.c", "commit_date": "2015-06-20 00:00:00", "repo_name": "twitter/twemproxy", "stars": 11992, "license": "apache-2.0", "language": "c", "size": 2961}
{"docstring": "/*\n * Returns true if the connection is authenticated or doesn't require\n * authentication, otherwise return false\n */\n", "func_signal": "bool\nconn_authenticated(struct conn *conn)", "code": "{\n    struct server_pool *pool;\n\n    ASSERT(!conn->proxy);\n\n    pool = conn->client ? conn->owner : ((struct server *)conn->owner)->owner;\n\n    if (!pool->require_auth) {\n        return true;\n    }\n\n    if (!conn->authenticated) {\n        return false;\n    }\n\n    return true;\n}", "path": "twemproxy/src/nc_connection.c", "commit_date": "2015-06-21 00:00:00", "repo_name": "twitter/twemproxy", "stars": 11992, "license": "apache-2.0", "language": "c", "size": 2961}
{"docstring": "/*\n * read the comment in proto/nc_redis.c\n */\n", "func_signal": "static rstatus_t\nmemcache_fragment_retrieval(struct msg *r, uint32_t ncontinuum,\n                            struct msg_tqh *frag_msgq,\n                            uint32_t key_step)", "code": "{\n    struct mbuf *mbuf;\n    struct msg **sub_msgs;\n    uint32_t i;\n    rstatus_t status;\n\n    sub_msgs = nc_zalloc(ncontinuum * sizeof(*sub_msgs));\n    if (sub_msgs == NULL) {\n        return NC_ENOMEM;\n    }\n\n    ASSERT(r->frag_seq == NULL);\n    r->frag_seq = nc_alloc(array_n(r->keys) * sizeof(*r->frag_seq));\n    if (r->frag_seq == NULL) {\n        nc_free(sub_msgs);\n        return NC_ENOMEM;\n    }\n\n    mbuf = STAILQ_FIRST(&r->mhdr);\n    mbuf->pos = mbuf->start;\n\n    /*\n     * This code is based on the assumption that 'gets ' is located\n     * in a contiguous location.\n     * This is always true because we have capped our MBUF_MIN_SIZE at 512 and\n     * whenever we have multiple messages, we copy the tail message into a new mbuf\n     */\n    for (; *(mbuf->pos) != ' ';) {          /* eat get/gets  */\n        mbuf->pos++;\n    }\n    mbuf->pos++;\n\n    r->frag_id = msg_gen_frag_id();\n    r->nfrag = 0;\n    r->frag_owner = r;\n\n    for (i = 0; i < array_n(r->keys); i++) {        /* for each  key */\n        struct msg *sub_msg;\n        struct keypos *kpos = array_get(r->keys, i);\n        uint32_t idx = msg_backend_idx(r, kpos->start, kpos->end - kpos->start);\n\n        if (sub_msgs[idx] == NULL) {\n            sub_msgs[idx] = msg_get(r->owner, r->request, r->redis);\n            if (sub_msgs[idx] == NULL) {\n                nc_free(sub_msgs);\n                return NC_ENOMEM;\n            }\n        }\n        r->frag_seq[i] = sub_msg = sub_msgs[idx];\n\n        sub_msg->narg++;\n        status = memcache_append_key(sub_msg, kpos->start, kpos->end - kpos->start);\n        if (status != NC_OK) {\n            nc_free(sub_msgs);\n            return status;\n        }\n    }\n\n    for (i = 0; i < ncontinuum; i++) {     /* prepend mget header, and forward it */\n        struct msg *sub_msg = sub_msgs[i];\n        if (sub_msg == NULL) {\n            continue;\n        }\n\n        /* prepend get/gets */\n        if (r->type == MSG_REQ_MC_GET) {\n            status = msg_prepend(sub_msg, (uint8_t *)\"get \", 4);\n        } else if (r->type == MSG_REQ_MC_GETS) {\n            status = msg_prepend(sub_msg, (uint8_t *)\"gets \", 5);\n        }\n        if (status != NC_OK) {\n            nc_free(sub_msgs);\n            return status;\n        }\n\n        /* append \\r\\n */\n        status = msg_append(sub_msg, (uint8_t *)CRLF, CRLF_LEN);\n        if (status != NC_OK) {\n            nc_free(sub_msgs);\n            return status;\n        }\n\n        sub_msg->type = r->type;\n        sub_msg->frag_id = r->frag_id;\n        sub_msg->frag_owner = r->frag_owner;\n\n        TAILQ_INSERT_TAIL(frag_msgq, sub_msg, m_tqe);\n        r->nfrag++;\n    }\n\n    nc_free(sub_msgs);\n    return NC_OK;\n}", "path": "twemproxy/src/proto/nc_memcache.c", "commit_date": "2015-06-20 00:00:00", "repo_name": "twitter/twemproxy", "stars": 11992, "license": "apache-2.0", "language": "c", "size": 2961}
{"docstring": "/*\n * Unresolve the socket descriptor peer address by translating it to a\n * character string describing the host and service\n *\n * This routine is not reentrant\n */\n", "func_signal": "char *\nnc_unresolve_peer_desc(int sd)", "code": "{\n    static struct sockinfo si;\n    struct sockaddr *addr;\n    socklen_t addrlen;\n    int status;\n\n    memset(&si, 0, sizeof(si));\n    addr = (struct sockaddr *)&si.addr;\n    addrlen = sizeof(si.addr);\n\n    status = getpeername(sd, addr, &addrlen);\n    if (status < 0) {\n        return \"unknown\";\n    }\n\n    return nc_unresolve_addr(addr, addrlen);\n}", "path": "twemproxy/src/nc_util.c", "commit_date": "2015-06-26 00:00:00", "repo_name": "twitter/twemproxy", "stars": 11992, "license": "apache-2.0", "language": "c", "size": 2961}
{"docstring": "/*\n * Return true, if the memcache command is a touch command, otherwise\n * return false\n */\n", "func_signal": "static bool\nmemcache_touch(struct msg *r)", "code": "{\n    if (r->type == MSG_REQ_MC_TOUCH) {\n        return true;\n    }\n\n    return false;\n}", "path": "twemproxy/src/proto/nc_memcache.c", "commit_date": "2015-06-20 00:00:00", "repo_name": "twitter/twemproxy", "stars": 11992, "license": "apache-2.0", "language": "c", "size": 2961}
{"docstring": "/*\n * Return true, if the memcache command is a arithmetic command, otherwise\n * return false\n */\n", "func_signal": "static bool\nmemcache_arithmetic(struct msg *r)", "code": "{\n    switch (r->type) {\n    case MSG_REQ_MC_INCR:\n    case MSG_REQ_MC_DECR:\n        return true;\n\n    default:\n        break;\n    }\n\n    return false;\n}", "path": "twemproxy/src/proto/nc_memcache.c", "commit_date": "2015-06-20 00:00:00", "repo_name": "twitter/twemproxy", "stars": 11992, "license": "apache-2.0", "language": "c", "size": 2961}
{"docstring": "/*\n * Resolve a hostname and service by translating it to socket address and\n * return it in si\n *\n * This routine is reentrant\n */\n", "func_signal": "int\nnc_resolve(struct string *name, int port, struct sockinfo *si)", "code": "{\n    if (name != NULL && name->data[0] == '/') {\n        return nc_resolve_unix(name, si);\n    }\n\n    return nc_resolve_inet(name, port, si);\n}", "path": "twemproxy/src/nc_util.c", "commit_date": "2015-06-26 00:00:00", "repo_name": "twitter/twemproxy", "stars": 11992, "license": "apache-2.0", "language": "c", "size": 2961}
{"docstring": "/*\n * Disable Nagle algorithm on TCP socket.\n *\n * This option helps to minimize transmit latency by disabling coalescing\n * of data to fill up a TCP segment inside the kernel. Sockets with this\n * option must use readv() or writev() to do data transfer in bulk and\n * hence avoid the overhead of small packets.\n */\n", "func_signal": "int\nnc_set_tcpnodelay(int sd)", "code": "{\n    int nodelay;\n    socklen_t len;\n\n    nodelay = 1;\n    len = sizeof(nodelay);\n\n    return setsockopt(sd, IPPROTO_TCP, TCP_NODELAY, &nodelay, len);\n}", "path": "twemproxy/src/nc_util.c", "commit_date": "2015-06-26 00:00:00", "repo_name": "twitter/twemproxy", "stars": 11992, "license": "apache-2.0", "language": "c", "size": 2961}
{"docstring": "/*\n * Return true if request is in error, false otherwise\n *\n * A request is in error, if there was an error in receiving response for the\n * given request. A multiget request is in error if there was an error in\n * receiving response for any its fragments.\n */\n", "func_signal": "bool\nreq_error(struct conn *conn, struct msg *msg)", "code": "{\n    struct msg *cmsg; /* current message */\n    uint64_t id;\n    uint32_t nfragment;\n\n    ASSERT(msg->request && req_done(conn, msg));\n\n    if (msg->error) {\n        return true;\n    }\n\n    id = msg->frag_id;\n    if (id == 0) {\n        return false;\n    }\n\n    if (msg->ferror) {\n        /* request has already been marked to be in error */\n        return true;\n    }\n\n    /* check if any of the fragments of the given request are in error */\n\n    for (cmsg = TAILQ_PREV(msg, msg_tqh, c_tqe);\n         cmsg != NULL && cmsg->frag_id == id;\n         cmsg = TAILQ_PREV(cmsg, msg_tqh, c_tqe)) {\n\n        if (cmsg->error) {\n            goto ferror;\n        }\n    }\n\n    for (cmsg = TAILQ_NEXT(msg, c_tqe);\n         cmsg != NULL && cmsg->frag_id == id;\n         cmsg = TAILQ_NEXT(cmsg, c_tqe)) {\n\n        if (cmsg->error) {\n            goto ferror;\n        }\n    }\n\n    return false;\n\nferror:\n\n    /*\n     * Mark all fragments of the given request to be in error to speed up\n     * future req_error calls for any of fragments of this request\n     */\n\n    msg->ferror = 1;\n    nfragment = 1;\n\n    for (cmsg = TAILQ_PREV(msg, msg_tqh, c_tqe);\n         cmsg != NULL && cmsg->frag_id == id;\n         cmsg = TAILQ_PREV(cmsg, msg_tqh, c_tqe)) {\n        cmsg->ferror = 1;\n        nfragment++;\n    }\n\n    for (cmsg = TAILQ_NEXT(msg, c_tqe);\n         cmsg != NULL && cmsg->frag_id == id;\n         cmsg = TAILQ_NEXT(cmsg, c_tqe)) {\n        cmsg->ferror = 1;\n        nfragment++;\n    }\n\n    log_debug(LOG_DEBUG, \"req from c %d with fid %\"PRIu64\" and %\"PRIu32\" \"\n              \"fragments is in error\", conn->sd, id, nfragment);\n\n    return true;\n}", "path": "twemproxy/src/nc_request.c", "commit_date": "2015-10-21 00:00:00", "repo_name": "twitter/twemproxy", "stars": 11992, "license": "apache-2.0", "language": "c", "size": 2961}
{"docstring": "/*\n * Unresolve the socket descriptor address by translating it to a\n * character string describing the host and service\n *\n * This routine is not reentrant\n */\n", "func_signal": "char *\nnc_unresolve_desc(int sd)", "code": "{\n    static struct sockinfo si;\n    struct sockaddr *addr;\n    socklen_t addrlen;\n    int status;\n\n    memset(&si, 0, sizeof(si));\n    addr = (struct sockaddr *)&si.addr;\n    addrlen = sizeof(si.addr);\n\n    status = getsockname(sd, addr, &addrlen);\n    if (status < 0) {\n        return \"unknown\";\n    }\n\n    return nc_unresolve_addr(addr, addrlen);\n}", "path": "twemproxy/src/nc_util.c", "commit_date": "2015-06-26 00:00:00", "repo_name": "twitter/twemproxy", "stars": 11992, "license": "apache-2.0", "language": "c", "size": 2961}
{"docstring": "/*\n * Return true, if the memcache command is a cas command, otherwise\n * return false\n */\n", "func_signal": "static bool\nmemcache_cas(struct msg *r)", "code": "{\n    if (r->type == MSG_REQ_MC_CAS) {\n        return true;\n    }\n\n    return false;\n}", "path": "twemproxy/src/proto/nc_memcache.c", "commit_date": "2015-06-20 00:00:00", "repo_name": "twitter/twemproxy", "stars": 11992, "license": "apache-2.0", "language": "c", "size": 2961}
{"docstring": "/*\n * Send n bytes on a blocking descriptor\n */\n", "func_signal": "ssize_t\n_nc_sendn(int sd, const void *vptr, size_t n)", "code": "{\n    size_t nleft;\n    ssize_t\tnsend;\n    const char *ptr;\n\n    ptr = vptr;\n    nleft = n;\n    while (nleft > 0) {\n        nsend = send(sd, ptr, nleft, 0);\n        if (nsend < 0) {\n            if (errno == EINTR) {\n                continue;\n            }\n            return nsend;\n        }\n        if (nsend == 0) {\n            return -1;\n        }\n\n        nleft -= (size_t)nsend;\n        ptr += nsend;\n    }\n\n    return (ssize_t)n;\n}", "path": "twemproxy/src/nc_util.c", "commit_date": "2015-06-26 00:00:00", "repo_name": "twitter/twemproxy", "stars": 11992, "license": "apache-2.0", "language": "c", "size": 2961}
{"docstring": "/*\n * Return the current time in microseconds since Epoch\n */\n", "func_signal": "int64_t\nnc_usec_now(void)", "code": "{\n    struct timeval now;\n    int64_t usec;\n    int status;\n\n    status = gettimeofday(&now, NULL);\n    if (status < 0) {\n        log_error(\"gettimeofday failed: %s\", strerror(errno));\n        return -1;\n    }\n\n    usec = (int64_t)now.tv_sec * 1000000LL + (int64_t)now.tv_usec;\n\n    return usec;\n}", "path": "twemproxy/src/nc_util.c", "commit_date": "2015-06-26 00:00:00", "repo_name": "twitter/twemproxy", "stars": 11992, "license": "apache-2.0", "language": "c", "size": 2961}
{"docstring": "/*\n * Recv n bytes from a blocking descriptor\n */\n", "func_signal": "ssize_t\n_nc_recvn(int sd, void *vptr, size_t n)", "code": "{\n\tsize_t nleft;\n\tssize_t\tnrecv;\n\tchar *ptr;\n\n\tptr = vptr;\n\tnleft = n;\n\twhile (nleft > 0) {\n        nrecv = recv(sd, ptr, nleft, 0);\n        if (nrecv < 0) {\n            if (errno == EINTR) {\n                continue;\n            }\n            return nrecv;\n        }\n        if (nrecv == 0) {\n            break;\n        }\n\n        nleft -= (size_t)nrecv;\n        ptr += nrecv;\n    }\n\n    return (ssize_t)(n - nleft);\n}", "path": "twemproxy/src/nc_util.c", "commit_date": "2015-06-26 00:00:00", "repo_name": "twitter/twemproxy", "stars": 11992, "license": "apache-2.0", "language": "c", "size": 2961}
{"docstring": "/*\n * Return true if request is done, false otherwise\n *\n * A request is done, if we received response for the given request.\n * A request vector is done if we received responses for all its\n * fragments.\n */\n", "func_signal": "bool\nreq_done(struct conn *conn, struct msg *msg)", "code": "{\n    struct msg *cmsg, *pmsg; /* current and previous message */\n    uint64_t id;             /* fragment id */\n    uint32_t nfragment;      /* # fragment */\n\n    ASSERT(conn->client && !conn->proxy);\n    ASSERT(msg->request);\n\n    if (!msg->done) {\n        return false;\n    }\n\n    id = msg->frag_id;\n    if (id == 0) {\n        return true;\n    }\n\n    if (msg->fdone) {\n        /* request has already been marked as done */\n        return true;\n    }\n\n    if (msg->nfrag_done < msg->nfrag) {\n        return false;\n    }\n\n    /* check all fragments of the given request vector are done */\n\n    for (pmsg = msg, cmsg = TAILQ_PREV(msg, msg_tqh, c_tqe);\n         cmsg != NULL && cmsg->frag_id == id;\n         pmsg = cmsg, cmsg = TAILQ_PREV(cmsg, msg_tqh, c_tqe)) {\n\n        if (!cmsg->done) {\n            return false;\n        }\n    }\n\n    for (pmsg = msg, cmsg = TAILQ_NEXT(msg, c_tqe);\n         cmsg != NULL && cmsg->frag_id == id;\n         pmsg = cmsg, cmsg = TAILQ_NEXT(cmsg, c_tqe)) {\n\n        if (!cmsg->done) {\n            return false;\n        }\n    }\n\n    /*\n     * At this point, all the fragments including the last fragment have\n     * been received.\n     *\n     * Mark all fragments of the given request vector to be done to speed up\n     * future req_done calls for any of fragments of this request\n     */\n\n    msg->fdone = 1;\n    nfragment = 0;\n\n    for (pmsg = msg, cmsg = TAILQ_PREV(msg, msg_tqh, c_tqe);\n         cmsg != NULL && cmsg->frag_id == id;\n         pmsg = cmsg, cmsg = TAILQ_PREV(cmsg, msg_tqh, c_tqe)) {\n        cmsg->fdone = 1;\n        nfragment++;\n    }\n\n    for (pmsg = msg, cmsg = TAILQ_NEXT(msg, c_tqe);\n         cmsg != NULL && cmsg->frag_id == id;\n         pmsg = cmsg, cmsg = TAILQ_NEXT(cmsg, c_tqe)) {\n        cmsg->fdone = 1;\n        nfragment++;\n    }\n\n    ASSERT(msg->frag_owner->nfrag == nfragment);\n\n    msg->post_coalesce(msg->frag_owner);\n\n    log_debug(LOG_DEBUG, \"req from c %d with fid %\"PRIu64\" and %\"PRIu32\" \"\n              \"fragments is done\", conn->sd, id, nfragment);\n\n    return true;\n}", "path": "twemproxy/src/nc_request.c", "commit_date": "2015-10-21 00:00:00", "repo_name": "twitter/twemproxy", "stars": 11992, "license": "apache-2.0", "language": "c", "size": 2961}
{"docstring": "/*\n** function to close regular files\n*/\n", "func_signal": "static int io_fclose (lua_State *L)", "code": "{\n  FILE **p = tofilep(L);\n  int ok = (fclose(*p) == 0);\n  *p = NULL;\n  return pushresult(L, ok, NULL);\n}", "path": "redis-3.0-annotated/deps/lua/src/liolib.c", "commit_date": "2013-04-29 00:00:00", "repo_name": "huangz1990/redis-3.0-annotated", "stars": 9830, "license": "bsd-3-clause", "language": "c", "size": 5937}
{"docstring": "/*\n** this function has a separated environment, which defines the\n** correct __close for 'popen' files\n*/\n", "func_signal": "static int io_popen (lua_State *L)", "code": "{\n  const char *filename = luaL_checkstring(L, 1);\n  const char *mode = luaL_optstring(L, 2, \"r\");\n  FILE **pf = newfile(L);\n  *pf = lua_popen(L, filename, mode);\n  return (*pf == NULL) ? pushresult(L, 0, filename) : 1;\n}", "path": "redis-3.0-annotated/deps/lua/src/liolib.c", "commit_date": "2013-04-29 00:00:00", "repo_name": "huangz1990/redis-3.0-annotated", "stars": 9830, "license": "bsd-3-clause", "language": "c", "size": 5937}
{"docstring": "/* Create an empty intset. \n *\n * \u521b\u5efa\u5e76\u8fd4\u56de\u4e00\u4e2a\u65b0\u7684\u7a7a\u6574\u6570\u96c6\u5408\n *\n * T = O(1)\n */\n", "func_signal": "intset *intsetNew(void)", "code": "{\n\n    // \u4e3a\u6574\u6570\u96c6\u5408\u7ed3\u6784\u5206\u914d\u7a7a\u95f4\n    intset *is = zmalloc(sizeof(intset));\n\n    // \u8bbe\u7f6e\u521d\u59cb\u7f16\u7801\n    is->encoding = intrev32ifbe(INTSET_ENC_INT16);\n\n    // \u521d\u59cb\u5316\u5143\u7d20\u6570\u91cf\n    is->length = 0;\n\n    return is;\n}", "path": "redis-3.0-annotated/src/intset.c", "commit_date": "2013-08-01 00:00:00", "repo_name": "huangz1990/redis-3.0-annotated", "stars": 9830, "license": "bsd-3-clause", "language": "c", "size": 5937}
{"docstring": "/* strbuf_append_fmt() should only be used when an upper bound\n * is known for the output string. */\n", "func_signal": "void strbuf_append_fmt(strbuf_t *s, int len, const char *fmt, ...)", "code": "{\n    va_list arg;\n    int fmt_len;\n\n    strbuf_ensure_empty_length(s, len);\n\n    va_start(arg, fmt);\n    fmt_len = vsnprintf(s->buf + s->length, len, fmt, arg);\n    va_end(arg);\n\n    if (fmt_len < 0)\n        die(\"BUG: Unable to convert number\");  /* This should never happen.. */\n\n    s->length += fmt_len;\n}", "path": "redis-3.0-annotated/deps/lua/src/strbuf.c", "commit_date": "2011-10-19 00:00:00", "repo_name": "huangz1990/redis-3.0-annotated", "stars": 9830, "license": "bsd-3-clause", "language": "c", "size": 5937}
{"docstring": "/* Generate red-black tree functions. */\n", "func_signal": "rb_gen(, extent_tree_szad_, extent_tree_t, extent_node_t, link_szad,\n    extent_szad_comp)\n\nstatic inline int\nextent_ad_comp(extent_node_t *a, extent_node_t *b)", "code": "{\n\tuintptr_t a_addr = (uintptr_t)a->addr;\n\tuintptr_t b_addr = (uintptr_t)b->addr;\n\n\treturn ((a_addr > b_addr) - (a_addr < b_addr));\n}", "path": "redis-3.0-annotated/deps/jemalloc/src/extent.c", "commit_date": "2012-05-16 00:00:00", "repo_name": "huangz1990/redis-3.0-annotated", "stars": 9830, "license": "bsd-3-clause", "language": "c", "size": 5937}
{"docstring": "/* Return the value at pos, given an encoding. \n *\n * \u6839\u636e\u7ed9\u5b9a\u7684\u7f16\u7801\u65b9\u5f0f enc \uff0c\u8fd4\u56de\u96c6\u5408\u7684\u5e95\u5c42\u6570\u7ec4\u5728 pos \u7d22\u5f15\u4e0a\u7684\u5143\u7d20\u3002\n *\n * T = O(1)\n */\n", "func_signal": "static int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc)", "code": "{\n    int64_t v64;\n    int32_t v32;\n    int16_t v16;\n\n    // ((ENCODING*)is->contents) \u9996\u5148\u5c06\u6570\u7ec4\u8f6c\u6362\u56de\u88ab\u7f16\u7801\u7684\u7c7b\u578b\n    // \u7136\u540e ((ENCODING*)is->contents)+pos \u8ba1\u7b97\u51fa\u5143\u7d20\u5728\u6570\u7ec4\u4e2d\u7684\u6b63\u786e\u4f4d\u7f6e\n    // \u4e4b\u540e member(&vEnc, ..., sizeof(vEnc)) \u518d\u4ece\u6570\u7ec4\u4e2d\u62f7\u8d1d\u51fa\u6b63\u786e\u6570\u91cf\u7684\u5b57\u8282\n    // \u5982\u679c\u6709\u9700\u8981\u7684\u8bdd\uff0c memrevEncifbe(&vEnc) \u4f1a\u5bf9\u62f7\u8d1d\u51fa\u7684\u5b57\u8282\u8fdb\u884c\u5927\u5c0f\u7aef\u8f6c\u6362\n    // \u6700\u540e\u5c06\u503c\u8fd4\u56de\n    if (enc == INTSET_ENC_INT64) {\n        memcpy(&v64,((int64_t*)is->contents)+pos,sizeof(v64));\n        memrev64ifbe(&v64);\n        return v64;\n    } else if (enc == INTSET_ENC_INT32) {\n        memcpy(&v32,((int32_t*)is->contents)+pos,sizeof(v32));\n        memrev32ifbe(&v32);\n        return v32;\n    } else {\n        memcpy(&v16,((int16_t*)is->contents)+pos,sizeof(v16));\n        memrev16ifbe(&v16);\n        return v16;\n    }\n}", "path": "redis-3.0-annotated/src/intset.c", "commit_date": "2013-08-01 00:00:00", "repo_name": "huangz1990/redis-3.0-annotated", "stars": 9830, "license": "bsd-3-clause", "language": "c", "size": 5937}
{"docstring": "/* Ensure strbuf can handle a string length bytes long (ignoring NULL\n * optional termination). */\n", "func_signal": "void strbuf_resize(strbuf_t *s, int len)", "code": "{\n    int newsize;\n\n    newsize = calculate_new_size(s, len);\n\n    if (s->debug > 1) {\n        fprintf(stderr, \"strbuf(%lx) resize: %d => %d\\n\",\n                (long)s, s->size, newsize);\n    }\n\n    s->size = newsize;\n    s->buf = realloc(s->buf, s->size);\n    if (!s->buf)\n        die(\"Out of memory\");\n    s->reallocs++;\n}", "path": "redis-3.0-annotated/deps/lua/src/strbuf.c", "commit_date": "2011-10-19 00:00:00", "repo_name": "huangz1990/redis-3.0-annotated", "stars": 9830, "license": "bsd-3-clause", "language": "c", "size": 5937}
{"docstring": "/* Search for the position of \"value\".\n * \n * \u5728\u96c6\u5408 is \u7684\u5e95\u5c42\u6570\u7ec4\u4e2d\u67e5\u627e\u503c value \u6240\u5728\u7684\u7d22\u5f15\u3002\n *\n * Return 1 when the value was found and \n * sets \"pos\" to the position of the value within the intset. \n *\n * \u6210\u529f\u627e\u5230 value \u65f6\uff0c\u51fd\u6570\u8fd4\u56de 1 \uff0c\u5e76\u5c06 *pos \u7684\u503c\u8bbe\u4e3a value \u6240\u5728\u7684\u7d22\u5f15\u3002\n *\n * Return 0 when the value is not present in the intset \n * and sets \"pos\" to the position where \"value\" can be inserted. \n *\n * \u5f53\u5728\u6570\u7ec4\u4e2d\u6ca1\u627e\u5230 value \u65f6\uff0c\u8fd4\u56de 0 \u3002\n * \u5e76\u5c06 *pos \u7684\u503c\u8bbe\u4e3a value \u53ef\u4ee5\u63d2\u5165\u5230\u6570\u7ec4\u4e2d\u7684\u4f4d\u7f6e\u3002\n *\n * T = O(log N)\n */\n", "func_signal": "static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos)", "code": "{\n    int min = 0, max = intrev32ifbe(is->length)-1, mid = -1;\n    int64_t cur = -1;\n\n    /* The value can never be found when the set is empty */\n    // \u5904\u7406 is \u4e3a\u7a7a\u65f6\u7684\u60c5\u51b5\n    if (intrev32ifbe(is->length) == 0) {\n        if (pos) *pos = 0;\n        return 0;\n    } else {\n        /* Check for the case where we know we cannot find the value,\n         * but do know the insert position. */\n        // \u56e0\u4e3a\u5e95\u5c42\u6570\u7ec4\u662f\u6709\u5e8f\u7684\uff0c\u5982\u679c value \u6bd4\u6570\u7ec4\u4e2d\u6700\u540e\u4e00\u4e2a\u503c\u90fd\u8981\u5927\n        // \u90a3\u4e48 value \u80af\u5b9a\u4e0d\u5b58\u5728\u4e8e\u96c6\u5408\u4e2d\uff0c\n        // \u5e76\u4e14\u5e94\u8be5\u5c06 value \u6dfb\u52a0\u5230\u5e95\u5c42\u6570\u7ec4\u7684\u6700\u672b\u7aef\n        if (value > _intsetGet(is,intrev32ifbe(is->length)-1)) {\n            if (pos) *pos = intrev32ifbe(is->length);\n            return 0;\n        // \u56e0\u4e3a\u5e95\u5c42\u6570\u7ec4\u662f\u6709\u5e8f\u7684\uff0c\u5982\u679c value \u6bd4\u6570\u7ec4\u4e2d\u6700\u524d\u4e00\u4e2a\u503c\u90fd\u8981\u5c0f\n        // \u90a3\u4e48 value \u80af\u5b9a\u4e0d\u5b58\u5728\u4e8e\u96c6\u5408\u4e2d\uff0c\n        // \u5e76\u4e14\u5e94\u8be5\u5c06\u5b83\u6dfb\u52a0\u5230\u5e95\u5c42\u6570\u7ec4\u7684\u6700\u524d\u7aef\n        } else if (value < _intsetGet(is,0)) {\n            if (pos) *pos = 0;\n            return 0;\n        }\n    }\n\n    // \u5728\u6709\u5e8f\u6570\u7ec4\u4e2d\u8fdb\u884c\u4e8c\u5206\u67e5\u627e\n    // T = O(log N)\n    while(max >= min) {\n        mid = (min+max)/2;\n        cur = _intsetGet(is,mid);\n        if (value > cur) {\n            min = mid+1;\n        } else if (value < cur) {\n            max = mid-1;\n        } else {\n            break;\n        }\n    }\n\n    // \u68c0\u67e5\u662f\u5426\u5df2\u7ecf\u627e\u5230\u4e86 value\n    if (value == cur) {\n        if (pos) *pos = mid;\n        return 1;\n    } else {\n        if (pos) *pos = min;\n        return 0;\n    }\n}", "path": "redis-3.0-annotated/src/intset.c", "commit_date": "2013-08-01 00:00:00", "repo_name": "huangz1990/redis-3.0-annotated", "stars": 9830, "license": "bsd-3-clause", "language": "c", "size": 5937}
{"docstring": "/* Set the value at pos, using the configured encoding. \n *\n * \u6839\u636e\u96c6\u5408\u7684\u7f16\u7801\u65b9\u5f0f\uff0c\u5c06\u5e95\u5c42\u6570\u7ec4\u5728 pos \u4f4d\u7f6e\u4e0a\u7684\u503c\u8bbe\u4e3a value \u3002\n *\n * T = O(1)\n */\n", "func_signal": "static void _intsetSet(intset *is, int pos, int64_t value)", "code": "{\n\n    // \u53d6\u51fa\u96c6\u5408\u7684\u7f16\u7801\u65b9\u5f0f\n    uint32_t encoding = intrev32ifbe(is->encoding);\n\n    // \u6839\u636e\u7f16\u7801 ((Enc_t*)is->contents) \u5c06\u6570\u7ec4\u8f6c\u6362\u56de\u6b63\u786e\u7684\u7c7b\u578b\n    // \u7136\u540e ((Enc_t*)is->contents)[pos] \u5b9a\u4f4d\u5230\u6570\u7ec4\u7d22\u5f15\u4e0a\n    // \u63a5\u7740 ((Enc_t*)is->contents)[pos] = value \u5c06\u503c\u8d4b\u7ed9\u6570\u7ec4\n    // \u6700\u540e\uff0c ((Enc_t*)is->contents)+pos \u5b9a\u4f4d\u5230\u521a\u521a\u8bbe\u7f6e\u7684\u65b0\u503c\u4e0a \n    // \u5982\u679c\u6709\u9700\u8981\u7684\u8bdd\uff0c memrevEncifbe \u5c06\u5bf9\u503c\u8fdb\u884c\u5927\u5c0f\u7aef\u8f6c\u6362\n    if (encoding == INTSET_ENC_INT64) {\n        ((int64_t*)is->contents)[pos] = value;\n        memrev64ifbe(((int64_t*)is->contents)+pos);\n    } else if (encoding == INTSET_ENC_INT32) {\n        ((int32_t*)is->contents)[pos] = value;\n        memrev32ifbe(((int32_t*)is->contents)+pos);\n    } else {\n        ((int16_t*)is->contents)[pos] = value;\n        memrev16ifbe(((int16_t*)is->contents)+pos);\n    }\n}", "path": "redis-3.0-annotated/src/intset.c", "commit_date": "2013-08-01 00:00:00", "repo_name": "huangz1990/redis-3.0-annotated", "stars": 9830, "license": "bsd-3-clause", "language": "c", "size": 5937}
{"docstring": "/*\n * If the caller specifies (*zero == false), it is still possible to receive\n * zeroed memory, in which case *zero is toggled to true.  arena_chunk_alloc()\n * takes advantage of this to avoid demanding zeroed chunks, but taking\n * advantage of them if they are returned.\n */\n", "func_signal": "void *\nchunk_alloc(size_t size, size_t alignment, bool base, bool *zero,\n    dss_prec_t dss_prec)", "code": "{\n\tvoid *ret;\n\n\tassert(size != 0);\n\tassert((size & chunksize_mask) == 0);\n\tassert(alignment != 0);\n\tassert((alignment & chunksize_mask) == 0);\n\n\t/* \"primary\" dss. */\n\tif (config_dss && dss_prec == dss_prec_primary) {\n\t\tif ((ret = chunk_recycle(&chunks_szad_dss, &chunks_ad_dss, size,\n\t\t    alignment, base, zero)) != NULL)\n\t\t\tgoto label_return;\n\t\tif ((ret = chunk_alloc_dss(size, alignment, zero)) != NULL)\n\t\t\tgoto label_return;\n\t}\n\t/* mmap. */\n\tif ((ret = chunk_recycle(&chunks_szad_mmap, &chunks_ad_mmap, size,\n\t    alignment, base, zero)) != NULL)\n\t\tgoto label_return;\n\tif ((ret = chunk_alloc_mmap(size, alignment, zero)) != NULL)\n\t\tgoto label_return;\n\t/* \"secondary\" dss. */\n\tif (config_dss && dss_prec == dss_prec_secondary) {\n\t\tif ((ret = chunk_recycle(&chunks_szad_dss, &chunks_ad_dss, size,\n\t\t    alignment, base, zero)) != NULL)\n\t\t\tgoto label_return;\n\t\tif ((ret = chunk_alloc_dss(size, alignment, zero)) != NULL)\n\t\t\tgoto label_return;\n\t}\n\n\t/* All strategies for allocation failed. */\n\tret = NULL;\nlabel_return:\n\tif (config_ivsalloc && base == false && ret != NULL) {\n\t\tif (rtree_set(chunks_rtree, (uintptr_t)ret, ret)) {\n\t\t\tchunk_dealloc(ret, size, true);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\tif ((config_stats || config_prof) && ret != NULL) {\n\t\tbool gdump;\n\t\tmalloc_mutex_lock(&chunks_mtx);\n\t\tif (config_stats)\n\t\t\tstats_chunks.nchunks += (size / chunksize);\n\t\tstats_chunks.curchunks += (size / chunksize);\n\t\tif (stats_chunks.curchunks > stats_chunks.highchunks) {\n\t\t\tstats_chunks.highchunks = stats_chunks.curchunks;\n\t\t\tif (config_prof)\n\t\t\t\tgdump = true;\n\t\t} else if (config_prof)\n\t\t\tgdump = false;\n\t\tmalloc_mutex_unlock(&chunks_mtx);\n\t\tif (config_prof && opt_prof && opt_prof_gdump && gdump)\n\t\t\tprof_gdump();\n\t}\n\tif (config_debug && *zero && ret != NULL) {\n\t\tsize_t i;\n\t\tsize_t *p = (size_t *)(uintptr_t)ret;\n\n\t\tVALGRIND_MAKE_MEM_DEFINED(ret, size);\n\t\tfor (i = 0; i < size / sizeof(size_t); i++)\n\t\t\tassert(p[i] == 0);\n\t}\n\tassert(CHUNK_ADDR2BASE(ret) == ret);\n\treturn (ret);\n}", "path": "redis-3.0-annotated/deps/jemalloc/src/chunk.c", "commit_date": "2012-11-28 00:00:00", "repo_name": "huangz1990/redis-3.0-annotated", "stars": 9830, "license": "bsd-3-clause", "language": "c", "size": 5937}
{"docstring": "/*\n** function to (not) close the standard files stdin, stdout, and stderr\n*/\n", "func_signal": "static int io_noclose (lua_State *L)", "code": "{\n  lua_pushnil(L);\n  lua_pushliteral(L, \"cannot close standard file\");\n  return 2;\n}", "path": "redis-3.0-annotated/deps/lua/src/liolib.c", "commit_date": "2013-04-29 00:00:00", "repo_name": "huangz1990/redis-3.0-annotated", "stars": 9830, "license": "bsd-3-clause", "language": "c", "size": 5937}
{"docstring": "/* Upgrades the intset to a larger encoding and inserts the given integer. \n *\n * \u6839\u636e\u503c value \u6240\u4f7f\u7528\u7684\u7f16\u7801\u65b9\u5f0f\uff0c\u5bf9\u6574\u6570\u96c6\u5408\u7684\u7f16\u7801\u8fdb\u884c\u5347\u7ea7\uff0c\n * \u5e76\u5c06\u503c value \u6dfb\u52a0\u5230\u5347\u7ea7\u540e\u7684\u6574\u6570\u96c6\u5408\u4e2d\u3002\n *\n * \u8fd4\u56de\u503c\uff1a\u6dfb\u52a0\u65b0\u5143\u7d20\u4e4b\u540e\u7684\u6574\u6570\u96c6\u5408\n *\n * T = O(N)\n */\n", "func_signal": "static intset *intsetUpgradeAndAdd(intset *is, int64_t value)", "code": "{\n    \n    // \u5f53\u524d\u7684\u7f16\u7801\u65b9\u5f0f\n    uint8_t curenc = intrev32ifbe(is->encoding);\n\n    // \u65b0\u503c\u6240\u9700\u7684\u7f16\u7801\u65b9\u5f0f\n    uint8_t newenc = _intsetValueEncoding(value);\n\n    // \u5f53\u524d\u96c6\u5408\u7684\u5143\u7d20\u6570\u91cf\n    int length = intrev32ifbe(is->length);\n\n    // \u6839\u636e value \u7684\u503c\uff0c\u51b3\u5b9a\u662f\u5c06\u5b83\u6dfb\u52a0\u5230\u5e95\u5c42\u6570\u7ec4\u7684\u6700\u524d\u7aef\u8fd8\u662f\u6700\u540e\u7aef\n    // \u6ce8\u610f\uff0c\u56e0\u4e3a value \u7684\u7f16\u7801\u6bd4\u96c6\u5408\u539f\u6709\u7684\u5176\u4ed6\u5143\u7d20\u7684\u7f16\u7801\u90fd\u8981\u5927\n    // \u6240\u4ee5 value \u8981\u4e48\u5927\u4e8e\u96c6\u5408\u4e2d\u7684\u6240\u6709\u5143\u7d20\uff0c\u8981\u4e48\u5c0f\u4e8e\u96c6\u5408\u4e2d\u7684\u6240\u6709\u5143\u7d20\n    // \u56e0\u6b64\uff0cvalue \u53ea\u80fd\u6dfb\u52a0\u5230\u5e95\u5c42\u6570\u7ec4\u7684\u6700\u524d\u7aef\u6216\u6700\u540e\u7aef\n    int prepend = value < 0 ? 1 : 0;\n\n    /* First set new encoding and resize */\n    // \u66f4\u65b0\u96c6\u5408\u7684\u7f16\u7801\u65b9\u5f0f\n    is->encoding = intrev32ifbe(newenc);\n    // \u6839\u636e\u65b0\u7f16\u7801\u5bf9\u96c6\u5408\uff08\u7684\u5e95\u5c42\u6570\u7ec4\uff09\u8fdb\u884c\u7a7a\u95f4\u8c03\u6574\n    // T = O(N)\n    is = intsetResize(is,intrev32ifbe(is->length)+1);\n\n    /* Upgrade back-to-front so we don't overwrite values.\n     * Note that the \"prepend\" variable is used to make sure we have an empty\n     * space at either the beginning or the end of the intset. */\n    // \u6839\u636e\u96c6\u5408\u539f\u6765\u7684\u7f16\u7801\u65b9\u5f0f\uff0c\u4ece\u5e95\u5c42\u6570\u7ec4\u4e2d\u53d6\u51fa\u96c6\u5408\u5143\u7d20\n    // \u7136\u540e\u518d\u5c06\u5143\u7d20\u4ee5\u65b0\u7f16\u7801\u7684\u65b9\u5f0f\u6dfb\u52a0\u5230\u96c6\u5408\u4e2d\n    // \u5f53\u5b8c\u6210\u4e86\u8fd9\u4e2a\u6b65\u9aa4\u4e4b\u540e\uff0c\u96c6\u5408\u4e2d\u6240\u6709\u539f\u6709\u7684\u5143\u7d20\u5c31\u5b8c\u6210\u4e86\u4ece\u65e7\u7f16\u7801\u5230\u65b0\u7f16\u7801\u7684\u8f6c\u6362\n    // \u56e0\u4e3a\u65b0\u5206\u914d\u7684\u7a7a\u95f4\u90fd\u653e\u5728\u6570\u7ec4\u7684\u540e\u7aef\uff0c\u6240\u4ee5\u7a0b\u5e8f\u5148\u4ece\u540e\u7aef\u5411\u524d\u7aef\u79fb\u52a8\u5143\u7d20\n    // \u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5047\u8bbe\u539f\u6765\u6709 curenc \u7f16\u7801\u7684\u4e09\u4e2a\u5143\u7d20\uff0c\u5b83\u4eec\u5728\u6570\u7ec4\u4e2d\u6392\u5217\u5982\u4e0b\uff1a\n    // | x | y | z | \n    // \u5f53\u7a0b\u5e8f\u5bf9\u6570\u7ec4\u8fdb\u884c\u91cd\u5206\u914d\u4e4b\u540e\uff0c\u6570\u7ec4\u5c31\u88ab\u6269\u5bb9\u4e86\uff08\u7b26\u53f7 \uff1f \u8868\u793a\u672a\u4f7f\u7528\u7684\u5185\u5b58\uff09\uff1a\n    // | x | y | z | ? |   ?   |   ?   |\n    // \u8fd9\u65f6\u7a0b\u5e8f\u4ece\u6570\u7ec4\u540e\u7aef\u5f00\u59cb\uff0c\u91cd\u65b0\u63d2\u5165\u5143\u7d20\uff1a\n    // | x | y | z | ? |   z   |   ?   |\n    // | x | y |   y   |   z   |   ?   |\n    // |   x   |   y   |   z   |   ?   |\n    // \u6700\u540e\uff0c\u7a0b\u5e8f\u53ef\u4ee5\u5c06\u65b0\u5143\u7d20\u6dfb\u52a0\u5230\u6700\u540e \uff1f \u53f7\u6807\u793a\u7684\u4f4d\u7f6e\u4e2d\uff1a\n    // |   x   |   y   |   z   |  new  |\n    // \u4e0a\u9762\u6f14\u793a\u7684\u662f\u65b0\u5143\u7d20\u6bd4\u539f\u6765\u7684\u6240\u6709\u5143\u7d20\u90fd\u5927\u7684\u60c5\u51b5\uff0c\u4e5f\u5373\u662f prepend == 0\n    // \u5f53\u65b0\u5143\u7d20\u6bd4\u539f\u6765\u7684\u6240\u6709\u5143\u7d20\u90fd\u5c0f\u65f6\uff08prepend == 1\uff09\uff0c\u8c03\u6574\u7684\u8fc7\u7a0b\u5982\u4e0b\uff1a\n    // | x | y | z | ? |   ?   |   ?   |\n    // | x | y | z | ? |   ?   |   z   |\n    // | x | y | z | ? |   y   |   z   |\n    // | x | y |   x   |   y   |   z   |\n    // \u5f53\u6dfb\u52a0\u65b0\u503c\u65f6\uff0c\u539f\u672c\u7684 | x | y | \u7684\u6570\u636e\u5c06\u88ab\u65b0\u503c\u4ee3\u66ff\n    // |  new  |   x   |   y   |   z   |\n    // T = O(N)\n    while(length--)\n        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));\n\n    /* Set the value at the beginning or the end. */\n    // \u8bbe\u7f6e\u65b0\u503c\uff0c\u6839\u636e prepend \u7684\u503c\u6765\u51b3\u5b9a\u662f\u6dfb\u52a0\u5230\u6570\u7ec4\u5934\u8fd8\u662f\u6570\u7ec4\u5c3e\n    if (prepend)\n        _intsetSet(is,0,value);\n    else\n        _intsetSet(is,intrev32ifbe(is->length),value);\n\n    // \u66f4\u65b0\u6574\u6570\u96c6\u5408\u7684\u5143\u7d20\u6570\u91cf\n    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);\n\n    return is;\n}", "path": "redis-3.0-annotated/src/intset.c", "commit_date": "2013-08-01 00:00:00", "repo_name": "huangz1990/redis-3.0-annotated", "stars": 9830, "license": "bsd-3-clause", "language": "c", "size": 5937}
{"docstring": "/*\n * \u5411\u524d\u6216\u5148\u540e\u79fb\u52a8\u6307\u5b9a\u7d22\u5f15\u8303\u56f4\u5185\u7684\u6570\u7ec4\u5143\u7d20\n *\n * \u51fd\u6570\u540d\u4e2d\u7684 MoveTail \u5176\u5b9e\u662f\u4e00\u4e2a\u6709\u8bef\u5bfc\u6027\u7684\u540d\u5b57\uff0c\n * \u8fd9\u4e2a\u51fd\u6570\u53ef\u4ee5\u5411\u524d\u6216\u5411\u540e\u79fb\u52a8\u5143\u7d20\uff0c\n * \u800c\u4e0d\u4ec5\u4ec5\u662f\u5411\u540e\n *\n * \u5728\u6dfb\u52a0\u65b0\u5143\u7d20\u5230\u6570\u7ec4\u65f6\uff0c\u5c31\u9700\u8981\u8fdb\u884c\u5411\u540e\u79fb\u52a8\uff0c\n * \u5982\u679c\u6570\u7ec4\u8868\u793a\u5982\u4e0b\uff08\uff1f\u8868\u793a\u4e00\u4e2a\u672a\u8bbe\u7f6e\u65b0\u503c\u7684\u7a7a\u95f4\uff09\uff1a\n * | x | y | z | ? |\n *     |<----->|\n * \u800c\u65b0\u5143\u7d20 n \u7684 pos \u4e3a 1 \uff0c\u90a3\u4e48\u6570\u7ec4\u5c06\u79fb\u52a8 y \u548c z \u4e24\u4e2a\u5143\u7d20\n * | x | y | y | z |\n *         |<----->|\n * \u63a5\u7740\u5c31\u53ef\u4ee5\u5c06\u65b0\u5143\u7d20 n \u8bbe\u7f6e\u5230 pos \u4e0a\u4e86\uff1a\n * | x | n | y | z |\n *\n * \u5f53\u4ece\u6570\u7ec4\u4e2d\u5220\u9664\u5143\u7d20\u65f6\uff0c\u5c31\u9700\u8981\u8fdb\u884c\u5411\u524d\u79fb\u52a8\uff0c\n * \u5982\u679c\u6570\u7ec4\u8868\u793a\u5982\u4e0b\uff0c\u5e76\u4e14 b \u4e3a\u8981\u5220\u9664\u7684\u76ee\u6807\uff1a\n * | a | b | c | d |\n *         |<----->|\n * \u90a3\u4e48\u7a0b\u5e8f\u5c31\u4f1a\u79fb\u52a8 b \u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u4e00\u4e2a\u5143\u7d20\u7684\u4f4d\u7f6e\uff0c\n * \u4ece\u800c\u8986\u76d6 b \u7684\u6570\u636e\uff1a\n * | a | c | d | d |\n *     |<----->|\n * \u6700\u540e\uff0c\u7a0b\u5e8f\u518d\u4ece\u6570\u7ec4\u672b\u5c3e\u5220\u9664\u4e00\u4e2a\u5143\u7d20\u7684\u7a7a\u95f4\uff1a\n * | a | c | d |\n * \u8fd9\u6837\u5c31\u5b8c\u6210\u4e86\u5220\u9664\u64cd\u4f5c\u3002\n *\n * T = O(N)\n */\n", "func_signal": "static void intsetMoveTail(intset *is, uint32_t from, uint32_t to)", "code": "{\n\n    void *src, *dst;\n\n    // \u8981\u79fb\u52a8\u7684\u5143\u7d20\u4e2a\u6570\n    uint32_t bytes = intrev32ifbe(is->length)-from;\n\n    // \u96c6\u5408\u7684\u7f16\u7801\u65b9\u5f0f\n    uint32_t encoding = intrev32ifbe(is->encoding);\n\n    // \u6839\u636e\u4e0d\u540c\u7684\u7f16\u7801\n    // src = (Enc_t*)is->contents+from \u8bb0\u5f55\u79fb\u52a8\u5f00\u59cb\u7684\u4f4d\u7f6e\n    // dst = (Enc_t*)is_.contents+to \u8bb0\u5f55\u79fb\u52a8\u7ed3\u675f\u7684\u4f4d\u7f6e\n    // bytes *= sizeof(Enc_t) \u8ba1\u7b97\u4e00\u5171\u8981\u79fb\u52a8\u591a\u5c11\u5b57\u8282\n    if (encoding == INTSET_ENC_INT64) {\n        src = (int64_t*)is->contents+from;\n        dst = (int64_t*)is->contents+to;\n        bytes *= sizeof(int64_t);\n    } else if (encoding == INTSET_ENC_INT32) {\n        src = (int32_t*)is->contents+from;\n        dst = (int32_t*)is->contents+to;\n        bytes *= sizeof(int32_t);\n    } else {\n        src = (int16_t*)is->contents+from;\n        dst = (int16_t*)is->contents+to;\n        bytes *= sizeof(int16_t);\n    }\n\n    // \u8fdb\u884c\u79fb\u52a8\n    // T = O(N)\n    memmove(dst,src,bytes);\n}", "path": "redis-3.0-annotated/src/intset.c", "commit_date": "2013-08-01 00:00:00", "repo_name": "huangz1990/redis-3.0-annotated", "stars": 9830, "license": "bsd-3-clause", "language": "c", "size": 5937}
{"docstring": "/* Delete integer from intset \n *\n * \u4ece\u6574\u6570\u96c6\u5408\u4e2d\u5220\u9664\u503c value \u3002\n *\n * *success \u7684\u503c\u6307\u793a\u5220\u9664\u662f\u5426\u6210\u529f\uff1a\n * - \u56e0\u503c\u4e0d\u5b58\u5728\u800c\u9020\u6210\u5220\u9664\u5931\u8d25\u65f6\u8be5\u503c\u4e3a 0 \u3002\n * - \u5220\u9664\u6210\u529f\u65f6\u8be5\u503c\u4e3a 1 \u3002\n *\n * T = O(N)\n */\n", "func_signal": "intset *intsetRemove(intset *is, int64_t value, int *success)", "code": "{\n\n    // \u8ba1\u7b97 value \u7684\u7f16\u7801\u65b9\u5f0f\n    uint8_t valenc = _intsetValueEncoding(value);\n    uint32_t pos;\n\n    // \u9ed8\u8ba4\u8bbe\u7f6e\u6807\u8bc6\u503c\u4e3a\u5220\u9664\u5931\u8d25\n    if (success) *success = 0;\n\n    // \u5f53 value \u7684\u7f16\u7801\u5927\u5c0f\u5c0f\u4e8e\u6216\u7b49\u4e8e\u96c6\u5408\u7684\u5f53\u524d\u7f16\u7801\u65b9\u5f0f\uff08\u8bf4\u660e value \u6709\u53ef\u80fd\u5b58\u5728\u4e8e\u96c6\u5408\uff09\n    // \u5e76\u4e14 intsetSearch \u7684\u7ed3\u679c\u4e3a\u771f\uff0c\u90a3\u4e48\u6267\u884c\u5220\u9664\n    // T = O(log N)\n    if (valenc <= intrev32ifbe(is->encoding) && intsetSearch(is,value,&pos)) {\n\n        // \u53d6\u51fa\u96c6\u5408\u5f53\u524d\u7684\u5143\u7d20\u6570\u91cf\n        uint32_t len = intrev32ifbe(is->length);\n\n        /* We know we can delete */\n        // \u8bbe\u7f6e\u6807\u8bc6\u503c\u4e3a\u5220\u9664\u6210\u529f\n        if (success) *success = 1;\n\n        /* Overwrite value with tail and update length */\n        // \u5982\u679c value \u4e0d\u662f\u4f4d\u4e8e\u6570\u7ec4\u7684\u672b\u5c3e\n        // \u90a3\u4e48\u9700\u8981\u5bf9\u539f\u672c\u4f4d\u4e8e value \u4e4b\u540e\u7684\u5143\u7d20\u8fdb\u884c\u79fb\u52a8\n        //\n        // \u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5982\u679c\u6570\u7ec4\u8868\u793a\u5982\u4e0b\uff0c\u800c b \u4e3a\u5220\u9664\u7684\u76ee\u6807\n        // | a | b | c | d |\n        // \u90a3\u4e48 intsetMoveTail \u5c06 b \u4e4b\u540e\u7684\u6240\u6709\u6570\u636e\u5411\u524d\u79fb\u52a8\u4e00\u4e2a\u5143\u7d20\u7684\u7a7a\u95f4\uff0c\n        // \u8986\u76d6 b \u539f\u6765\u7684\u6570\u636e\n        // | a | c | d | d |\n        // \u4e4b\u540e intsetResize \u7f29\u5c0f\u5185\u5b58\u5927\u5c0f\u65f6\uff0c\n        // \u6570\u7ec4\u672b\u5c3e\u591a\u51fa\u6765\u7684\u4e00\u4e2a\u5143\u7d20\u7684\u7a7a\u95f4\u5c06\u88ab\u79fb\u9664\n        // | a | c | d |\n        if (pos < (len-1)) intsetMoveTail(is,pos+1,pos);\n        // \u7f29\u5c0f\u6570\u7ec4\u7684\u5927\u5c0f\uff0c\u79fb\u9664\u88ab\u5220\u9664\u5143\u7d20\u5360\u7528\u7684\u7a7a\u95f4\n        // T = O(N)\n        is = intsetResize(is,len-1);\n        // \u66f4\u65b0\u96c6\u5408\u7684\u5143\u7d20\u6570\u91cf\n        is->length = intrev32ifbe(len-1);\n    }\n\n    return is;\n}", "path": "redis-3.0-annotated/src/intset.c", "commit_date": "2013-08-01 00:00:00", "repo_name": "huangz1990/redis-3.0-annotated", "stars": 9830, "license": "bsd-3-clause", "language": "c", "size": 5937}
{"docstring": "/* strbuf_append_fmt_retry() can be used when the there is no known\n * upper bound for the output string. */\n", "func_signal": "void strbuf_append_fmt_retry(strbuf_t *s, const char *fmt, ...)", "code": "{\n    va_list arg;\n    int fmt_len, try;\n    int empty_len;\n\n    /* If the first attempt to append fails, resize the buffer appropriately\n     * and try again */\n    for (try = 0; ; try++) {\n        va_start(arg, fmt);\n        /* Append the new formatted string */\n        /* fmt_len is the length of the string required, excluding the\n         * trailing NULL */\n        empty_len = strbuf_empty_length(s);\n        /* Add 1 since there is also space to store the terminating NULL. */\n        fmt_len = vsnprintf(s->buf + s->length, empty_len + 1, fmt, arg);\n        va_end(arg);\n\n        if (fmt_len <= empty_len)\n            break;  /* SUCCESS */\n        if (try > 0)\n            die(\"BUG: length of formatted string changed\");\n\n        strbuf_resize(s, s->length + fmt_len);\n    }\n\n    s->length += fmt_len;\n}", "path": "redis-3.0-annotated/deps/lua/src/strbuf.c", "commit_date": "2011-10-19 00:00:00", "repo_name": "huangz1990/redis-3.0-annotated", "stars": 9830, "license": "bsd-3-clause", "language": "c", "size": 5937}
{"docstring": "/* Return the required encoding for the provided value. \n *\n * \u8fd4\u56de\u9002\u7528\u4e8e\u4f20\u5165\u503c v \u7684\u7f16\u7801\u65b9\u5f0f\n *\n * T = O(1)\n */\n", "func_signal": "static uint8_t _intsetValueEncoding(int64_t v)", "code": "{\n    if (v < INT32_MIN || v > INT32_MAX)\n        return INTSET_ENC_INT64;\n    else if (v < INT16_MIN || v > INT16_MAX)\n        return INTSET_ENC_INT32;\n    else\n        return INTSET_ENC_INT16;\n}", "path": "redis-3.0-annotated/src/intset.c", "commit_date": "2013-08-01 00:00:00", "repo_name": "huangz1990/redis-3.0-annotated", "stars": 9830, "license": "bsd-3-clause", "language": "c", "size": 5937}
{"docstring": "/*============================================================*/\n/* GRAMMAR RULES */\n/*============================================================*/\n", "func_signal": "static void field (LexState *ls, expdesc *v)", "code": "{\n  /* field -> ['.' | ':'] NAME */\n  FuncState *fs = ls->fs;\n  expdesc key;\n  luaK_exp2anyreg(fs, v);\n  luaX_next(ls);  /* skip the dot or colon */\n  checkname(ls, &key);\n  luaK_indexed(fs, v, &key);\n}", "path": "redis-3.0-annotated/deps/lua/src/lparser.c", "commit_date": "2013-04-29 00:00:00", "repo_name": "huangz1990/redis-3.0-annotated", "stars": 9830, "license": "bsd-3-clause", "language": "c", "size": 5937}
{"docstring": "/* Determine whether a value belongs to this set \n *\n * \u68c0\u67e5\u7ed9\u5b9a\u503c value \u662f\u5426\u96c6\u5408\u4e2d\u7684\u5143\u7d20\u3002\n *\n * \u662f\u8fd4\u56de 1 \uff0c\u4e0d\u662f\u8fd4\u56de 0 \u3002\n *\n * T = O(log N)\n */\n", "func_signal": "uint8_t intsetFind(intset *is, int64_t value)", "code": "{\n\n    // \u8ba1\u7b97 value \u7684\u7f16\u7801\n    uint8_t valenc = _intsetValueEncoding(value);\n\n    // \u5982\u679c value \u7684\u7f16\u7801\u5927\u4e8e\u96c6\u5408\u7684\u5f53\u524d\u7f16\u7801\uff0c\u90a3\u4e48 value \u4e00\u5b9a\u4e0d\u5b58\u5728\u4e8e\u96c6\u5408\n    // \u5f53 value \u7684\u7f16\u7801\u5c0f\u4e8e\u7b49\u4e8e\u96c6\u5408\u7684\u5f53\u524d\u7f16\u7801\u65f6\uff0c\n    // \u624d\u518d\u4f7f\u7528 intsetSearch \u8fdb\u884c\u67e5\u627e\n    return valenc <= intrev32ifbe(is->encoding) && intsetSearch(is,value,NULL);\n}", "path": "redis-3.0-annotated/src/intset.c", "commit_date": "2013-08-01 00:00:00", "repo_name": "huangz1990/redis-3.0-annotated", "stars": 9830, "license": "bsd-3-clause", "language": "c", "size": 5937}
{"docstring": "/*\n** check whether, in an assignment to a local variable, the local variable\n** is needed in a previous assignment (to a table). If so, save original\n** local value in a safe place and use this safe copy in the previous\n** assignment.\n*/\n", "func_signal": "static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v)", "code": "{\n  FuncState *fs = ls->fs;\n  int extra = fs->freereg;  /* eventual position to save local variable */\n  int conflict = 0;\n  for (; lh; lh = lh->prev) {\n    if (lh->v.k == VINDEXED) {\n      if (lh->v.u.s.info == v->u.s.info) {  /* conflict? */\n        conflict = 1;\n        lh->v.u.s.info = extra;  /* previous assignment will use safe copy */\n      }\n      if (lh->v.u.s.aux == v->u.s.info) {  /* conflict? */\n        conflict = 1;\n        lh->v.u.s.aux = extra;  /* previous assignment will use safe copy */\n      }\n    }\n  }\n  if (conflict) {\n    luaK_codeABC(fs, OP_MOVE, fs->freereg, v->u.s.info, 0);  /* make copy */\n    luaK_reserveregs(fs, 1);\n  }\n}", "path": "redis-3.0-annotated/deps/lua/src/lparser.c", "commit_date": "2013-04-29 00:00:00", "repo_name": "huangz1990/redis-3.0-annotated", "stars": 9830, "license": "bsd-3-clause", "language": "c", "size": 5937}
{"docstring": "/*\n** When creating file handles, always creates a `closed' file handle\n** before opening the actual file; so, if there is a memory error, the\n** file is not left opened.\n*/\n", "func_signal": "static FILE **newfile (lua_State *L)", "code": "{\n  FILE **pf = (FILE **)lua_newuserdata(L, sizeof(FILE *));\n  *pf = NULL;  /* file handle is currently `closed' */\n  luaL_getmetatable(L, LUA_FILEHANDLE);\n  lua_setmetatable(L, -2);\n  return pf;\n}", "path": "redis-3.0-annotated/deps/lua/src/liolib.c", "commit_date": "2013-04-29 00:00:00", "repo_name": "huangz1990/redis-3.0-annotated", "stars": 9830, "license": "bsd-3-clause", "language": "c", "size": 5937}
{"docstring": "/* report a zlib or i/o error */\n", "func_signal": "void zerr(int ret)", "code": "{\n    fputs(\"zpipe: \", stderr);\n    switch (ret) {\n    case Z_ERRNO:\n        if (ferror(stdin))\n            fputs(\"error reading stdin\\n\", stderr);\n        if (ferror(stdout))\n            fputs(\"error writing stdout\\n\", stderr);\n        break;\n    case Z_STREAM_ERROR:\n        fputs(\"invalid compression level\\n\", stderr);\n        break;\n    case Z_DATA_ERROR:\n        fputs(\"invalid or incomplete deflate data\\n\", stderr);\n        break;\n    case Z_MEM_ERROR:\n        fputs(\"out of memory\\n\", stderr);\n        break;\n    case Z_VERSION_ERROR:\n        fputs(\"zlib version mismatch!\\n\", stderr);\n    }\n}", "path": "hashcat/deps/zlib/examples/zpipe.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "hashcat/hashcat", "stars": 19504, "license": "None", "language": "c", "size": 80387}
{"docstring": "/*\ntypedef struct wpa_pmkid\n{\n  u32  pmkid[4];\n  u32  pmkid_data[16];\n  u8   orig_mac_ap[6];\n  u8   orig_mac_sta[6];\n  u8   essid_len;\n  u32  essid_buf[16];\n\n} wpa_pmkid_t;\n\ntypedef struct wpa_pmk_tmp\n{\n  u32 out[8];\n\n} wpa_pmk_tmp_t;\n*/\n", "func_signal": "const char *module_benchmark_mask (MAYBE_UNUSED const hashconfig_t *hashconfig, MAYBE_UNUSED const user_options_t *user_options, MAYBE_UNUSED const user_options_extra_t *user_options_extra)", "code": "{\n  const char *mask = \"?a?a?a?a?a?a?a?axxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\";\n\n  return mask;\n}", "path": "hashcat/src/modules/module_16801.c", "commit_date": "2020-09-29 00:00:00", "repo_name": "hashcat/hashcat", "stars": 19504, "license": "None", "language": "c", "size": 80387}
{"docstring": "/* read a four-byte unsigned integer, little-endian, from in */\n", "func_signal": "unsigned long read4(file *in)", "code": "{\n    unsigned long val;\n\n    val = read1(in);\n    val += (unsigned)read1(in) << 8;\n    val += (unsigned long)read1(in) << 16;\n    val += (unsigned long)read1(in) << 24;\n    return val;\n}", "path": "hashcat/deps/zlib/examples/gzappend.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "hashcat/hashcat", "stars": 19504, "license": "None", "language": "c", "size": 80387}
{"docstring": "/* decompress gzip file \"name\", return strm with a deflate stream ready to\n   continue compression of the data in the gzip file, and return a file\n   descriptor pointing to where to write the compressed data -- the deflate\n   stream is initialized to compress using level \"level\" */\n", "func_signal": "local int gzscan(char *name, z_stream *strm, int level)", "code": "{\n    int ret, lastbit, left, full;\n    unsigned have;\n    unsigned long crc, tot;\n    unsigned char *window;\n    off_t lastoff, end;\n    file gz;\n\n    /* open gzip file */\n    gz.name = name;\n    gz.fd = open(name, O_RDWR, 0);\n    if (gz.fd == -1) bye(\"cannot open \", name);\n    gz.buf = malloc(CHUNK);\n    if (gz.buf == NULL) bye(\"out of memory\", \"\");\n    gz.size = LGCHUNK;\n    gz.left = 0;\n\n    /* skip gzip header */\n    gzheader(&gz);\n\n    /* prepare to decompress */\n    window = malloc(DSIZE);\n    if (window == NULL) bye(\"out of memory\", \"\");\n    strm->zalloc = Z_NULL;\n    strm->zfree = Z_NULL;\n    strm->opaque = Z_NULL;\n    ret = inflateInit2(strm, -15);\n    if (ret != Z_OK) bye(\"out of memory\", \" or library mismatch\");\n\n    /* decompress the deflate stream, saving append information */\n    lastbit = 0;\n    lastoff = lseek(gz.fd, 0L, SEEK_CUR) - gz.left;\n    left = 0;\n    strm->avail_in = gz.left;\n    strm->next_in = gz.next;\n    crc = crc32(0L, Z_NULL, 0);\n    have = full = 0;\n    do {\n        /* if needed, get more input */\n        if (strm->avail_in == 0) {\n            readmore(&gz);\n            strm->avail_in = gz.left;\n            strm->next_in = gz.next;\n        }\n\n        /* set up output to next available section of sliding window */\n        strm->avail_out = DSIZE - have;\n        strm->next_out = window + have;\n\n        /* inflate and check for errors */\n        ret = inflate(strm, Z_BLOCK);\n        if (ret == Z_STREAM_ERROR) bye(\"internal stream error!\", \"\");\n        if (ret == Z_MEM_ERROR) bye(\"out of memory\", \"\");\n        if (ret == Z_DATA_ERROR)\n            bye(\"invalid compressed data--format violated in\", name);\n\n        /* update crc and sliding window pointer */\n        crc = crc32(crc, window + have, DSIZE - have - strm->avail_out);\n        if (strm->avail_out)\n            have = DSIZE - strm->avail_out;\n        else {\n            have = 0;\n            full = 1;\n        }\n\n        /* process end of block */\n        if (strm->data_type & 128) {\n            if (strm->data_type & 64)\n                left = strm->data_type & 0x1f;\n            else {\n                lastbit = strm->data_type & 0x1f;\n                lastoff = lseek(gz.fd, 0L, SEEK_CUR) - strm->avail_in;\n            }\n        }\n    } while (ret != Z_STREAM_END);\n    inflateEnd(strm);\n    gz.left = strm->avail_in;\n    gz.next = strm->next_in;\n\n    /* save the location of the end of the compressed data */\n    end = lseek(gz.fd, 0L, SEEK_CUR) - gz.left;\n\n    /* check gzip trailer and save total for deflate */\n    if (crc != read4(&gz))\n        bye(\"invalid compressed data--crc mismatch in \", name);\n    tot = strm->total_out;\n    if ((tot & 0xffffffffUL) != read4(&gz))\n        bye(\"invalid compressed data--length mismatch in\", name);\n\n    /* if not at end of file, warn */\n    if (gz.left || readin(&gz))\n        fprintf(stderr,\n            \"gzappend warning: junk at end of gzip file overwritten\\n\");\n\n    /* clear last block bit */\n    lseek(gz.fd, lastoff - (lastbit != 0), SEEK_SET);\n    if (read(gz.fd, gz.buf, 1) != 1) bye(\"reading after seek on \", name);\n    *gz.buf = (unsigned char)(*gz.buf ^ (1 << ((8 - lastbit) & 7)));\n    lseek(gz.fd, -1L, SEEK_CUR);\n    if (write(gz.fd, gz.buf, 1) != 1) bye(\"writing after seek to \", name);\n\n    /* if window wrapped, build dictionary from window by rotating */\n    if (full) {\n        rotate(window, DSIZE, have);\n        have = DSIZE;\n    }\n\n    /* set up deflate stream with window, crc, total_in, and leftover bits */\n    ret = deflateInit2(strm, level, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY);\n    if (ret != Z_OK) bye(\"out of memory\", \"\");\n    deflateSetDictionary(strm, window, have);\n    strm->adler = crc;\n    strm->total_in = tot;\n    if (left) {\n        lseek(gz.fd, --end, SEEK_SET);\n        if (read(gz.fd, gz.buf, 1) != 1) bye(\"reading after seek on \", name);\n        deflatePrime(strm, 8 - left, *gz.buf);\n    }\n    lseek(gz.fd, end, SEEK_SET);\n\n    /* clean up and return */\n    free(window);\n    free(gz.buf);\n    return gz.fd;\n}", "path": "hashcat/deps/zlib/examples/gzappend.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "hashcat/hashcat", "stars": 19504, "license": "None", "language": "c", "size": 80387}
{"docstring": "/*\n if (destFinish) - then unpack data block is finished at (*destLen) position,\n                   and we can return data that were not processed by filter\n\noutput (status) can be :\n  CODER_STATUS_NOT_FINISHED\n  CODER_STATUS_FINISHED_WITH_MARK\n  CODER_STATUS_NEEDS_MORE_INPUT - not implemented still\n*/\n", "func_signal": "static SRes MixCoder_Code(CMixCoder *p,\n    Byte *dest, SizeT *destLen, int destFinish,\n    const Byte *src, SizeT *srcLen, int srcWasFinished,\n    ECoderFinishMode finishMode)", "code": "{\n  SizeT destLenOrig = *destLen;\n  SizeT srcLenOrig = *srcLen;\n\n  *destLen = 0;\n  *srcLen = 0;\n\n  if (p->wasFinished)\n    return p->res;\n  \n  p->status = CODER_STATUS_NOT_FINISHED;\n\n  // if (p->SingleBufMode)\n  if (p->outBuf)\n  {\n    SRes res;\n    SizeT destLen2, srcLen2;\n    int wasFinished;\n    \n    PRF_STR(\"------- MixCoder Single ----------\");\n      \n    srcLen2 = srcLenOrig;\n    destLen2 = destLenOrig;\n    \n    {\n      IStateCoder *coder = &p->coders[0];\n      res = coder->Code2(coder->p, NULL, &destLen2, src, &srcLen2, srcWasFinished, finishMode,\n          // &wasFinished,\n          &p->status);\n      wasFinished = (p->status == CODER_STATUS_FINISHED_WITH_MARK);\n    }\n    \n    p->res = res;\n    \n    /*\n    if (wasFinished)\n      p->status = CODER_STATUS_FINISHED_WITH_MARK;\n    else\n    {\n      if (res == SZ_OK)\n        if (destLen2 != destLenOrig)\n          p->status = CODER_STATUS_NEEDS_MORE_INPUT;\n    }\n    */\n\n    \n    *srcLen = srcLen2;\n    src += srcLen2;\n    p->outWritten += destLen2;\n    \n    if (res != SZ_OK || srcWasFinished || wasFinished)\n      p->wasFinished = True;\n    \n    if (p->numCoders == 1)\n      *destLen = destLen2;\n    else if (p->wasFinished)\n    {\n      unsigned i;\n      size_t processed = p->outWritten;\n      \n      for (i = 1; i < p->numCoders; i++)\n      {\n        IStateCoder *coder = &p->coders[i];\n        processed = coder->Filter(coder->p, p->outBuf, processed);\n        if (wasFinished || (destFinish && p->outWritten == destLenOrig))\n          processed = p->outWritten;\n        PRF_STR_INT(\"filter\", i);\n      }\n      *destLen = processed;\n    }\n    return res;\n  }\n\n  PRF_STR(\"standard mix\");\n\n  if (p->numCoders != 1)\n  {\n    if (!p->buf)\n    {\n      p->buf = (Byte *)ISzAlloc_Alloc(p->alloc, CODER_BUF_SIZE * (MIXCODER_NUM_FILTERS_MAX - 1));\n      if (!p->buf)\n        return SZ_ERROR_MEM;\n    }\n    \n    finishMode = CODER_FINISH_ANY;\n  }\n\n  for (;;)\n  {\n    BoolInt processed = False;\n    BoolInt allFinished = True;\n    SRes resMain = SZ_OK;\n    unsigned i;\n\n    p->status = CODER_STATUS_NOT_FINISHED;\n    /*\n    if (p->numCoders == 1 && *destLen == destLenOrig && finishMode == LZMA_FINISH_ANY)\n      break;\n    */\n\n    for (i = 0; i < p->numCoders; i++)\n    {\n      SRes res;\n      IStateCoder *coder = &p->coders[i];\n      Byte *dest2;\n      SizeT destLen2, srcLen2; // destLen2_Orig;\n      const Byte *src2;\n      int srcFinished2;\n      int encodingWasFinished;\n      ECoderStatus status2;\n      \n      if (i == 0)\n      {\n        src2 = src;\n        srcLen2 = srcLenOrig - *srcLen;\n        srcFinished2 = srcWasFinished;\n      }\n      else\n      {\n        size_t k = i - 1;\n        src2 = p->buf + (CODER_BUF_SIZE * k) + p->pos[k];\n        srcLen2 = p->size[k] - p->pos[k];\n        srcFinished2 = p->finished[k];\n      }\n      \n      if (i == p->numCoders - 1)\n      {\n        dest2 = dest;\n        destLen2 = destLenOrig - *destLen;\n      }\n      else\n      {\n        if (p->pos[i] != p->size[i])\n          continue;\n        dest2 = p->buf + (CODER_BUF_SIZE * i);\n        destLen2 = CODER_BUF_SIZE;\n      }\n      \n      // destLen2_Orig = destLen2;\n      \n      if (p->results[i] != SZ_OK)\n      {\n        if (resMain == SZ_OK)\n          resMain = p->results[i];\n        continue;\n      }\n\n      res = coder->Code2(coder->p,\n          dest2, &destLen2,\n          src2, &srcLen2, srcFinished2,\n          finishMode,\n          // &encodingWasFinished,\n          &status2);\n\n      if (res != SZ_OK)\n      {\n        p->results[i] = res;\n        if (resMain == SZ_OK)\n          resMain = res;\n      }\n\n      encodingWasFinished = (status2 == CODER_STATUS_FINISHED_WITH_MARK);\n      \n      if (!encodingWasFinished)\n      {\n        allFinished = False;\n        if (p->numCoders == 1 && res == SZ_OK)\n          p->status = status2;\n      }\n\n      if (i == 0)\n      {\n        *srcLen += srcLen2;\n        src += srcLen2;\n      }\n      else\n        p->pos[(size_t)i - 1] += srcLen2;\n\n      if (i == p->numCoders - 1)\n      {\n        *destLen += destLen2;\n        dest += destLen2;\n      }\n      else\n      {\n        p->size[i] = destLen2;\n        p->pos[i] = 0;\n        p->finished[i] = encodingWasFinished;\n      }\n      \n      if (destLen2 != 0 || srcLen2 != 0)\n        processed = True;\n    }\n    \n    if (!processed)\n    {\n      if (allFinished)\n        p->status = CODER_STATUS_FINISHED_WITH_MARK;\n      return resMain;\n    }\n  }\n}", "path": "hashcat/deps/LZMA-SDK/C/XzDec.c", "commit_date": "2019-07-15 00:00:00", "repo_name": "hashcat/hashcat", "stars": 19504, "license": "None", "language": "c", "size": 80387}
{"docstring": "// #define NUM_PARENTS_MAX 128\n", "func_signal": "int MY_CDECL main(int numargs, char *args[])", "code": "{\n  ISzAlloc allocImp;\n  ISzAlloc allocTempImp;\n\n  CFileInStream archiveStream;\n  CLookToRead2 lookStream;\n  CSzArEx db;\n  SRes res;\n  UInt16 *temp = NULL;\n  size_t tempSize = 0;\n  // UInt32 parents[NUM_PARENTS_MAX];\n\n  Print(\"\\n7z Decoder \" MY_VERSION_CPU \" : \" MY_COPYRIGHT_DATE \"\\n\\n\");\n\n  if (numargs == 1)\n  {\n    Print(\n      \"Usage: 7zDec <command> <archive_name>\\n\\n\"\n      \"<Commands>\\n\"\n      \"  e: Extract files from archive (without using directory names)\\n\"\n      \"  l: List contents of archive\\n\"\n      \"  t: Test integrity of archive\\n\"\n      \"  x: eXtract files with full paths\\n\");\n    return 0;\n  }\n\n  if (numargs < 3)\n  {\n    PrintError(\"incorrect command\");\n    return 1;\n  }\n\n  #if defined(_WIN32) && !defined(USE_WINDOWS_FILE) && !defined(UNDER_CE)\n  g_FileCodePage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;\n  #endif\n\n\n  allocImp = g_Alloc;\n  allocTempImp = g_Alloc;\n\n  #ifdef UNDER_CE\n  if (InFile_OpenW(&archiveStream.file, L\"\\test.7z\"))\n  #else\n  if (InFile_Open(&archiveStream.file, args[2]))\n  #endif\n  {\n    PrintError(\"can not open input file\");\n    return 1;\n  }\n\n  FileInStream_CreateVTable(&archiveStream);\n  LookToRead2_CreateVTable(&lookStream, False);\n  lookStream.buf = NULL;\n\n  res = SZ_OK;\n\n  {\n    lookStream.buf = (Byte *)ISzAlloc_Alloc(&allocImp, kInputBufSize);\n    if (!lookStream.buf)\n      res = SZ_ERROR_MEM;\n    else\n    {\n      lookStream.bufSize = kInputBufSize;\n      lookStream.realStream = &archiveStream.vt;\n      LookToRead2_Init(&lookStream);\n    }\n  }\n    \n  CrcGenerateTable();\n    \n  SzArEx_Init(&db);\n    \n  if (res == SZ_OK)\n  {\n    res = SzArEx_Open(&db, &lookStream.vt, &allocImp, &allocTempImp);\n  }\n  \n  if (res == SZ_OK)\n  {\n    char *command = args[1];\n    int listCommand = 0, testCommand = 0, fullPaths = 0;\n    \n    if (strcmp(command, \"l\") == 0) listCommand = 1;\n    else if (strcmp(command, \"t\") == 0) testCommand = 1;\n    else if (strcmp(command, \"e\") == 0) { }\n    else if (strcmp(command, \"x\") == 0) { fullPaths = 1; }\n    else\n    {\n      PrintError(\"incorrect command\");\n      res = SZ_ERROR_FAIL;\n    }\n\n    if (res == SZ_OK)\n    {\n      UInt32 i;\n\n      /*\n      if you need cache, use these 3 variables.\n      if you use external function, you can make these variable as static.\n      */\n      UInt32 blockIndex = 0xFFFFFFFF; /* it can have any value before first call (if outBuffer = 0) */\n      Byte *outBuffer = 0; /* it must be 0 before first call for each new archive. */\n      size_t outBufferSize = 0;  /* it can have any value before first call (if outBuffer = 0) */\n\n      for (i = 0; i < db.NumFiles; i++)\n      {\n        size_t offset = 0;\n        size_t outSizeProcessed = 0;\n        // const CSzFileItem *f = db.Files + i;\n        size_t len;\n        unsigned isDir = SzArEx_IsDir(&db, i);\n        if (listCommand == 0 && isDir && !fullPaths)\n          continue;\n        len = SzArEx_GetFileNameUtf16(&db, i, NULL);\n        // len = SzArEx_GetFullNameLen(&db, i);\n\n        if (len > tempSize)\n        {\n          SzFree(NULL, temp);\n          tempSize = len;\n          temp = (UInt16 *)SzAlloc(NULL, tempSize * sizeof(temp[0]));\n          if (!temp)\n          {\n            res = SZ_ERROR_MEM;\n            break;\n          }\n        }\n\n        SzArEx_GetFileNameUtf16(&db, i, temp);\n        /*\n        if (SzArEx_GetFullNameUtf16_Back(&db, i, temp + len) != temp)\n        {\n          res = SZ_ERROR_FAIL;\n          break;\n        }\n        */\n\n        if (listCommand)\n        {\n          char attr[8], s[32], t[32];\n          UInt64 fileSize;\n\n          GetAttribString(SzBitWithVals_Check(&db.Attribs, i) ? db.Attribs.Vals[i] : 0, isDir, attr);\n\n          fileSize = SzArEx_GetFileSize(&db, i);\n          UInt64ToStr(fileSize, s, 10);\n          \n          if (SzBitWithVals_Check(&db.MTime, i))\n            ConvertFileTimeToString(&db.MTime.Vals[i], t);\n          else\n          {\n            size_t j;\n            for (j = 0; j < 19; j++)\n              t[j] = ' ';\n            t[j] = '\\0';\n          }\n          \n          Print(t);\n          Print(\" \");\n          Print(attr);\n          Print(\" \");\n          Print(s);\n          Print(\"  \");\n          res = PrintString(temp);\n          if (res != SZ_OK)\n            break;\n          if (isDir)\n            Print(\"/\");\n          PrintLF();\n          continue;\n        }\n\n        Print(testCommand ?\n            \"Testing    \":\n            \"Extracting \");\n        res = PrintString(temp);\n        if (res != SZ_OK)\n          break;\n        \n        if (isDir)\n          Print(\"/\");\n        else\n        {\n          res = SzArEx_Extract(&db, &lookStream.vt, i,\n              &blockIndex, &outBuffer, &outBufferSize,\n              &offset, &outSizeProcessed,\n              &allocImp, &allocTempImp);\n          if (res != SZ_OK)\n            break;\n        }\n        \n        if (!testCommand)\n        {\n          CSzFile outFile;\n          size_t processedSize;\n          size_t j;\n          UInt16 *name = (UInt16 *)temp;\n          const UInt16 *destPath = (const UInt16 *)name;\n \n          for (j = 0; name[j] != 0; j++)\n            if (name[j] == '/')\n            {\n              if (fullPaths)\n              {\n                name[j] = 0;\n                MyCreateDir(name);\n                name[j] = CHAR_PATH_SEPARATOR;\n              }\n              else\n                destPath = name + j + 1;\n            }\n    \n          if (isDir)\n          {\n            MyCreateDir(destPath);\n            PrintLF();\n            continue;\n          }\n          else if (OutFile_OpenUtf16(&outFile, destPath))\n          {\n            PrintError(\"can not open output file\");\n            res = SZ_ERROR_FAIL;\n            break;\n          }\n\n          processedSize = outSizeProcessed;\n          \n          if (File_Write(&outFile, outBuffer + offset, &processedSize) != 0 || processedSize != outSizeProcessed)\n          {\n            PrintError(\"can not write output file\");\n            res = SZ_ERROR_FAIL;\n            break;\n          }\n\n          #ifdef USE_WINDOWS_FILE\n          {\n            FILETIME mtime, ctime;\n            FILETIME *mtimePtr = NULL;\n            FILETIME *ctimePtr = NULL;\n\n            if (SzBitWithVals_Check(&db.MTime, i))\n            {\n              const CNtfsFileTime *t = &db.MTime.Vals[i];\n              mtime.dwLowDateTime = (DWORD)(t->Low);\n              mtime.dwHighDateTime = (DWORD)(t->High);\n              mtimePtr = &mtime;\n            }\n            if (SzBitWithVals_Check(&db.CTime, i))\n            {\n              const CNtfsFileTime *t = &db.CTime.Vals[i];\n              ctime.dwLowDateTime = (DWORD)(t->Low);\n              ctime.dwHighDateTime = (DWORD)(t->High);\n              ctimePtr = &ctime;\n            }\n            if (mtimePtr || ctimePtr)\n              SetFileTime(outFile.handle, ctimePtr, NULL, mtimePtr);\n          }\n          #endif\n          \n          if (File_Close(&outFile))\n          {\n            PrintError(\"can not close output file\");\n            res = SZ_ERROR_FAIL;\n            break;\n          }\n          \n          #ifdef USE_WINDOWS_FILE\n          if (SzBitWithVals_Check(&db.Attribs, i))\n          {\n            UInt32 attrib = db.Attribs.Vals[i];\n            /* p7zip stores posix attributes in high 16 bits and adds 0x8000 as marker.\n               We remove posix bits, if we detect posix mode field */\n            if ((attrib & 0xF0000000) != 0)\n              attrib &= 0x7FFF;\n            SetFileAttributesW((LPCWSTR)destPath, attrib);\n          }\n          #endif\n        }\n        PrintLF();\n      }\n      ISzAlloc_Free(&allocImp, outBuffer);\n    }\n  }\n\n  SzFree(NULL, temp);\n  SzArEx_Free(&db, &allocImp);\n  ISzAlloc_Free(&allocImp, lookStream.buf);\n\n  File_Close(&archiveStream.file);\n  \n  if (res == SZ_OK)\n  {\n    Print(\"\\nEverything is Ok\\n\");\n    return 0;\n  }\n  \n  if (res == SZ_ERROR_UNSUPPORTED)\n    PrintError(\"decoder doesn't support this archive\");\n  else if (res == SZ_ERROR_MEM)\n    PrintError(\"can not allocate memory\");\n  else if (res == SZ_ERROR_CRC)\n    PrintError(\"CRC error\");\n  else\n  {\n    char s[32];\n    UInt64ToStr(res, s, 0);\n    PrintError(s);\n  }\n  \n  return 1;\n}", "path": "hashcat/deps/LZMA-SDK/C/Util/7z/7zMain.c", "commit_date": "2019-07-15 00:00:00", "repo_name": "hashcat/hashcat", "stars": 19504, "license": "None", "language": "c", "size": 80387}
{"docstring": "/* return the greatest common divisor of a and b using Euclid's algorithm,\n   modified to be fast when one argument much greater than the other, and\n   coded to avoid unnecessary swapping */\n", "func_signal": "local unsigned gcd(unsigned a, unsigned b)", "code": "{\n    unsigned c;\n\n    while (a && b)\n        if (a > b) {\n            c = b;\n            while (a - c >= c)\n                c <<= 1;\n            a -= c;\n        }\n        else {\n            c = a;\n            while (b - c >= c)\n                c <<= 1;\n            b -= c;\n        }\n    return a + b;\n}", "path": "hashcat/deps/zlib/examples/gzappend.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "hashcat/hashcat", "stars": 19504, "license": "None", "language": "c", "size": 80387}
{"docstring": "// alternate base64 using ./ instead of +/, used in python passlib hashes\n", "func_signal": "u8 int_to_ab64 (const u8 c)", "code": "{\n  const u8 tbl[0x40] =\n  {\n    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50,\n    0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,\n    0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,\n    0x77, 0x78, 0x79, 0x7a, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x2e, 0x2f,\n  };\n\n  return tbl[c];\n}", "path": "hashcat/src/convert.c", "commit_date": "2020-04-30 00:00:00", "repo_name": "hashcat/hashcat", "stars": 19504, "license": "None", "language": "c", "size": 80387}
{"docstring": "/* Compress from file source to file dest until EOF on source.\n   def() returns Z_OK on success, Z_MEM_ERROR if memory could not be\n   allocated for processing, Z_STREAM_ERROR if an invalid compression\n   level is supplied, Z_VERSION_ERROR if the version of zlib.h and the\n   version of the library linked do not match, or Z_ERRNO if there is\n   an error reading or writing the files. */\n", "func_signal": "int def(FILE *source, FILE *dest, int level)", "code": "{\n    int ret, flush;\n    unsigned have;\n    z_stream strm;\n    unsigned char in[CHUNK];\n    unsigned char out[CHUNK];\n\n    /* allocate deflate state */\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    ret = deflateInit(&strm, level);\n    if (ret != Z_OK)\n        return ret;\n\n    /* compress until end of file */\n    do {\n        strm.avail_in = fread(in, 1, CHUNK, source);\n        if (ferror(source)) {\n            (void)deflateEnd(&strm);\n            return Z_ERRNO;\n        }\n        flush = feof(source) ? Z_FINISH : Z_NO_FLUSH;\n        strm.next_in = in;\n\n        /* run deflate() on input until output buffer not full, finish\n           compression if all of source has been read in */\n        do {\n            strm.avail_out = CHUNK;\n            strm.next_out = out;\n            ret = deflate(&strm, flush);    /* no bad return value */\n            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */\n            have = CHUNK - strm.avail_out;\n            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {\n                (void)deflateEnd(&strm);\n                return Z_ERRNO;\n            }\n        } while (strm.avail_out == 0);\n        assert(strm.avail_in == 0);     /* all input will be used */\n\n        /* done when last data in file processed */\n    } while (flush != Z_FINISH);\n    assert(ret == Z_STREAM_END);        /* stream will be complete */\n\n    /* clean up and return */\n    (void)deflateEnd(&strm);\n    return Z_OK;\n}", "path": "hashcat/deps/zlib/examples/zpipe.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "hashcat/hashcat", "stars": 19504, "license": "None", "language": "c", "size": 80387}
{"docstring": "/* append file \"name\" to gzip file gd using deflate stream strm -- if last\n   is true, then finish off the deflate stream at the end */\n", "func_signal": "local void gztack(char *name, int gd, z_stream *strm, int last)", "code": "{\n    int fd, len, ret;\n    unsigned left;\n    unsigned char *in, *out;\n\n    /* open file to compress and append */\n    fd = 0;\n    if (name != NULL) {\n        fd = open(name, O_RDONLY, 0);\n        if (fd == -1)\n            fprintf(stderr, \"gzappend warning: %s not found, skipping ...\\n\",\n                    name);\n    }\n\n    /* allocate buffers */\n    in = malloc(CHUNK);\n    out = malloc(CHUNK);\n    if (in == NULL || out == NULL) bye(\"out of memory\", \"\");\n\n    /* compress input file and append to gzip file */\n    do {\n        /* get more input */\n        len = read(fd, in, CHUNK);\n        if (len == -1) {\n            fprintf(stderr,\n                    \"gzappend warning: error reading %s, skipping rest ...\\n\",\n                    name);\n            len = 0;\n        }\n        strm->avail_in = (unsigned)len;\n        strm->next_in = in;\n        if (len) strm->adler = crc32(strm->adler, in, (unsigned)len);\n\n        /* compress and write all available output */\n        do {\n            strm->avail_out = CHUNK;\n            strm->next_out = out;\n            ret = deflate(strm, last && len == 0 ? Z_FINISH : Z_NO_FLUSH);\n            left = CHUNK - strm->avail_out;\n            while (left) {\n                len = write(gd, out + CHUNK - strm->avail_out - left, left);\n                if (len == -1) bye(\"writing gzip file\", \"\");\n                left -= (unsigned)len;\n            }\n        } while (strm->avail_out == 0 && ret != Z_STREAM_END);\n    } while (len != 0);\n\n    /* write trailer after last entry */\n    if (last) {\n        deflateEnd(strm);\n        out[0] = (unsigned char)(strm->adler);\n        out[1] = (unsigned char)(strm->adler >> 8);\n        out[2] = (unsigned char)(strm->adler >> 16);\n        out[3] = (unsigned char)(strm->adler >> 24);\n        out[4] = (unsigned char)(strm->total_in);\n        out[5] = (unsigned char)(strm->total_in >> 8);\n        out[6] = (unsigned char)(strm->total_in >> 16);\n        out[7] = (unsigned char)(strm->total_in >> 24);\n        len = 8;\n        do {\n            ret = write(gd, out + 8 - len, len);\n            if (ret == -1) bye(\"writing gzip file\", \"\");\n            len -= ret;\n        } while (len);\n        close(gd);\n    }\n\n    /* clean up and return */\n    free(out);\n    free(in);\n    if (fd > 0) close(fd);\n}", "path": "hashcat/deps/zlib/examples/gzappend.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "hashcat/hashcat", "stars": 19504, "license": "None", "language": "c", "size": 80387}
{"docstring": "/* read from file in, exit if end-of-file */\n", "func_signal": "local int readmore(file *in)", "code": "{\n    if (readin(in) == 0) bye(\"unexpected end of \", in->name);\n    return 0;\n}", "path": "hashcat/deps/zlib/examples/gzappend.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "hashcat/hashcat", "stars": 19504, "license": "None", "language": "c", "size": 80387}
{"docstring": "/* rotate list[0..len-1] left by rot positions, in place */\n", "func_signal": "local void rotate(unsigned char *list, unsigned len, unsigned rot)", "code": "{\n    unsigned char tmp;\n    unsigned cycles;\n    unsigned char *start, *last, *to, *from;\n\n    /* normalize rot and handle degenerate cases */\n    if (len < 2) return;\n    if (rot >= len) rot %= len;\n    if (rot == 0) return;\n\n    /* pointer to last entry in list */\n    last = list + (len - 1);\n\n    /* do simple left shift by one */\n    if (rot == 1) {\n        tmp = *list;\n        memcpy(list, list + 1, len - 1);\n        *last = tmp;\n        return;\n    }\n\n    /* do simple right shift by one */\n    if (rot == len - 1) {\n        tmp = *last;\n        memmove(list + 1, list, len - 1);\n        *list = tmp;\n        return;\n    }\n\n    /* otherwise do rotate as a set of cycles in place */\n    cycles = gcd(len, rot);             /* number of cycles */\n    do {\n        start = from = list + cycles;   /* start index is arbitrary */\n        tmp = *from;                    /* save entry to be overwritten */\n        for (;;) {\n            to = from;                  /* next step in cycle */\n            from += rot;                /* go right rot positions */\n            if (from > last) from -= len;   /* (pointer better not wrap) */\n            if (from == start) break;   /* all but one shifted */\n            *to = *from;                /* shift left */\n        }\n        *to = tmp;                      /* complete the circle */\n    } while (--cycles);\n}", "path": "hashcat/deps/zlib/examples/gzappend.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "hashcat/hashcat", "stars": 19504, "license": "None", "language": "c", "size": 80387}
{"docstring": "/*\ntypedef struct wpa_pmkid\n{\n  u32  pmkid[4];\n  u32  pmkid_data[16];\n  u8   orig_mac_ap[6];\n  u8   orig_mac_sta[6];\n  u8   essid_len;\n  u32  essid_buf[16];\n\n} wpa_pmkid_t;\n\ntypedef struct wpa_pbkdf2_tmp\n{\n  u32 ipad[5];\n  u32 opad[5];\n\n  u32 dgst[10];\n  u32 out[10];\n\n} wpa_pbkdf2_tmp_t;\n*/\n", "func_signal": "const char *module_benchmark_mask (MAYBE_UNUSED const hashconfig_t *hashconfig, MAYBE_UNUSED const user_options_t *user_options, MAYBE_UNUSED const user_options_extra_t *user_options_extra)", "code": "{\n  const char *mask = \"?a?a?a?a?a?a?a?a\";\n\n  return mask;\n}", "path": "hashcat/src/modules/module_16800.c", "commit_date": "2020-09-29 00:00:00", "repo_name": "hashcat/hashcat", "stars": 19504, "license": "None", "language": "c", "size": 80387}
{"docstring": "/* Decompress from file source to file dest until stream ends or EOF.\n   inf() returns Z_OK on success, Z_MEM_ERROR if memory could not be\n   allocated for processing, Z_DATA_ERROR if the deflate data is\n   invalid or incomplete, Z_VERSION_ERROR if the version of zlib.h and\n   the version of the library linked do not match, or Z_ERRNO if there\n   is an error reading or writing the files. */\n", "func_signal": "int inf(FILE *source, FILE *dest)", "code": "{\n    int ret;\n    unsigned have;\n    z_stream strm;\n    unsigned char in[CHUNK];\n    unsigned char out[CHUNK];\n\n    /* allocate inflate state */\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit(&strm);\n    if (ret != Z_OK)\n        return ret;\n\n    /* decompress until deflate stream ends or end of file */\n    do {\n        strm.avail_in = fread(in, 1, CHUNK, source);\n        if (ferror(source)) {\n            (void)inflateEnd(&strm);\n            return Z_ERRNO;\n        }\n        if (strm.avail_in == 0)\n            break;\n        strm.next_in = in;\n\n        /* run inflate() on input until output buffer not full */\n        do {\n            strm.avail_out = CHUNK;\n            strm.next_out = out;\n            ret = inflate(&strm, Z_NO_FLUSH);\n            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */\n            switch (ret) {\n            case Z_NEED_DICT:\n                ret = Z_DATA_ERROR;     /* and fall through */\n            case Z_DATA_ERROR:\n            case Z_MEM_ERROR:\n                (void)inflateEnd(&strm);\n                return ret;\n            }\n            have = CHUNK - strm.avail_out;\n            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {\n                (void)inflateEnd(&strm);\n                return Z_ERRNO;\n            }\n        } while (strm.avail_out == 0);\n\n        /* done when inflate() says it's done */\n    } while (ret != Z_STREAM_END);\n\n    /* clean up and return */\n    (void)inflateEnd(&strm);\n    return ret == Z_STREAM_END ? Z_OK : Z_DATA_ERROR;\n}", "path": "hashcat/deps/zlib/examples/zpipe.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "hashcat/hashcat", "stars": 19504, "license": "None", "language": "c", "size": 80387}
{"docstring": "/* compress or decompress from stdin to stdout */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n    int ret;\n\n    /* avoid end-of-line conversions */\n    SET_BINARY_MODE(stdin);\n    SET_BINARY_MODE(stdout);\n\n    /* do compression if no arguments */\n    if (argc == 1) {\n        ret = def(stdin, stdout, Z_DEFAULT_COMPRESSION);\n        if (ret != Z_OK)\n            zerr(ret);\n        return ret;\n    }\n\n    /* do decompression if -d specified */\n    else if (argc == 2 && strcmp(argv[1], \"-d\") == 0) {\n        ret = inf(stdin, stdout);\n        if (ret != Z_OK)\n            zerr(ret);\n        return ret;\n    }\n\n    /* otherwise, report usage */\n    else {\n        fputs(\"zpipe usage: zpipe [-d] < source > dest\\n\", stderr);\n        return 1;\n    }\n}", "path": "hashcat/deps/zlib/examples/zpipe.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "hashcat/hashcat", "stars": 19504, "license": "None", "language": "c", "size": 80387}
{"docstring": "/* process the compression level option if present, scan the gzip file, and\n   append the specified files, or append the data from stdin if no other file\n   names are provided on the command line -- the gzip file must be writable\n   and seekable */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n    int gd, level;\n    z_stream strm;\n\n    /* ignore command name */\n    argc--; argv++;\n\n    /* provide usage if no arguments */\n    if (*argv == NULL) {\n        printf(\n            \"gzappend 1.2 (11 Oct 2012) Copyright (C) 2003, 2012 Mark Adler\\n\"\n               );\n        printf(\n            \"usage: gzappend [-level] file.gz [ addthis [ andthis ... ]]\\n\");\n        return 0;\n    }\n\n    /* set compression level */\n    level = Z_DEFAULT_COMPRESSION;\n    if (argv[0][0] == '-') {\n        if (argv[0][1] < '0' || argv[0][1] > '9' || argv[0][2] != 0)\n            bye(\"invalid compression level\", \"\");\n        level = argv[0][1] - '0';\n        if (*++argv == NULL) bye(\"no gzip file name after options\", \"\");\n    }\n\n    /* prepare to append to gzip file */\n    gd = gzscan(*argv++, &strm, level);\n\n    /* append files on command line, or from stdin if none */\n    if (*argv == NULL)\n        gztack(NULL, gd, &strm, 1);\n    else\n        do {\n            gztack(*argv, gd, &strm, argv[1] == NULL);\n        } while (*++argv != NULL);\n    return 0;\n}", "path": "hashcat/deps/zlib/examples/gzappend.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "hashcat/hashcat", "stars": 19504, "license": "None", "language": "c", "size": 80387}
{"docstring": "/* print an error message and terminate with extreme prejudice */\n", "func_signal": "local void bye(char *msg1, char *msg2)", "code": "{\n    fprintf(stderr, \"gzappend error: %s%s\\n\", msg1, msg2);\n    exit(1);\n}", "path": "hashcat/deps/zlib/examples/gzappend.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "hashcat/hashcat", "stars": 19504, "license": "None", "language": "c", "size": 80387}
{"docstring": "/* skip over n bytes of in */\n", "func_signal": "local void skip(file *in, unsigned n)", "code": "{\n    unsigned bypass;\n\n    if (n > in->left) {\n        n -= in->left;\n        bypass = n & ~((1U << in->size) - 1);\n        if (bypass) {\n            if (lseek(in->fd, (off_t)bypass, SEEK_CUR) == -1)\n                bye(\"seeking \", in->name);\n            n -= bypass;\n        }\n        readmore(in);\n        if (n > in->left)\n            bye(\"unexpected end of \", in->name);\n    }\n    in->left -= n;\n    in->next += n;\n}", "path": "hashcat/deps/zlib/examples/gzappend.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "hashcat/hashcat", "stars": 19504, "license": "None", "language": "c", "size": 80387}
{"docstring": "/* skip over gzip header */\n", "func_signal": "local void gzheader(file *in)", "code": "{\n    int flags;\n    unsigned n;\n\n    if (read1(in) != 31 || read1(in) != 139) bye(in->name, \" not a gzip file\");\n    if (read1(in) != 8) bye(\"unknown compression method in\", in->name);\n    flags = read1(in);\n    if (flags & 0xe0) bye(\"unknown header flags set in\", in->name);\n    skip(in, 6);\n    if (flags & 4) {\n        n = read1(in);\n        n += (unsigned)(read1(in)) << 8;\n        skip(in, n);\n    }\n    if (flags & 8) while (read1(in) != 0) ;\n    if (flags & 16) while (read1(in) != 0) ;\n    if (flags & 2) skip(in, 2);\n}", "path": "hashcat/deps/zlib/examples/gzappend.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "hashcat/hashcat", "stars": 19504, "license": "None", "language": "c", "size": 80387}
{"docstring": "/* reload buffer */\n", "func_signal": "local int readin(file *in)", "code": "{\n    int len;\n\n    len = read(in->fd, in->buf, 1 << in->size);\n    if (len == -1) bye(\"error reading \", in->name);\n    in->left = (unsigned)len;\n    in->next = in->buf;\n    return len;\n}", "path": "hashcat/deps/zlib/examples/gzappend.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "hashcat/hashcat", "stars": 19504, "license": "None", "language": "c", "size": 80387}
{"docstring": "/* 0 - 1.0, 1 - 1.2 */\n", "func_signal": "int get_dtls_version(const unsigned char* buf, int len)", "code": "{\n\tif(buf && (len>3) && (buf[2] == 0xfd))\n\t\treturn 1;\n\treturn 0;\n}", "path": "coturn/src/apps/relay/dtls_listener.c", "commit_date": "2019-03-08 00:00:00", "repo_name": "coturn/coturn", "stars": 10275, "license": "other", "language": "c", "size": 4935}
{"docstring": "//////////////// Unsent buffers //////////////////////\n", "func_signal": "void clear_unsent_buffer(unsent_buffer *ub)", "code": "{\n\tif(ub) {\n\t\tif(ub->bufs) {\n\t\t\tsize_t sz;\n\t\t\tfor(sz = 0; sz<ub->sz; sz++) {\n\t\t\t\tioa_network_buffer_handle nbh = ub->bufs[sz];\n\t\t\t\tif(nbh) {\n\t\t\t\t\tioa_network_buffer_delete(NULL, nbh);\n\t\t\t\t\tub->bufs[sz] = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(ub->bufs);\n\t\t\tub->bufs = NULL;\n\t\t}\n\t\tub->sz = 0;\n\t}\n}", "path": "coturn/src/server/ns_turn_allocation.c", "commit_date": "2019-03-08 00:00:00", "repo_name": "coturn/coturn", "stars": 10275, "license": "other", "language": "c", "size": 4935}
{"docstring": "///////////////////////// Attach /////////////////////////////////\n", "func_signal": "redis_context_handle redisLibeventAttach(struct event_base *base, char *ip0, int port0, char *pwd, int db)", "code": "{\n\n  struct redisLibeventEvents *e = NULL;\n  redisAsyncContext *ac = NULL;\n\n  char ip[256];\n  if(ip0 && ip0[0])\n\t  STRCPY(ip,ip0);\n  else\n\t  STRCPY(ip,\"127.0.0.1\");\n\n  int port = DEFAULT_REDIS_PORT;\n  if(port0>0)\n\t  port=port0;\n\n  ac = redisAsyncConnect(ip, port);\n  if (!ac) {\n  \tfprintf(stderr,\"Error: %s:%s\\n\", ac->errstr, ac->c.errstr);\n  \treturn NULL;\n  }\n\n  /* Create container for context and r/w events */\n  e = (struct redisLibeventEvents*)malloc(sizeof(struct redisLibeventEvents));\n  bzero(e,sizeof(struct redisLibeventEvents));\n\n  e->allocated = 1;\n  e->context = ac;\n  e->base = base;\n  e->ip = strdup(ip);\n  e->port = port;\n  if(pwd)\n\t  e->pwd = strdup(pwd);\n  e->db = db;\n\n  /* Register functions to start/stop listening for events */\n  ac->ev.addRead = redisLibeventAddRead;\n  ac->ev.delRead = redisLibeventDelRead;\n  ac->ev.addWrite = redisLibeventAddWrite;\n  ac->ev.delWrite = redisLibeventDelWrite;\n  ac->ev.cleanup = redisLibeventCleanup;\n\n  ac->ev.data = e;\n\n  /* Initialize and install read/write events */\n  e->rev = event_new(e->base,e->context->c.fd,\n  \t\t     EV_READ|EV_PERSIST,redisLibeventReadEvent,\n  \t\t     e);\n\n  e->wev = event_new(e->base,e->context->c.fd,\n\t\t     EV_WRITE,redisLibeventWriteEvent,\n  \t\t     e);\n\n  if (e->rev == NULL || e->wev == NULL) {\n\t  free(e);\n\t  return NULL;\n  }\n  \n  event_add(e->wev, NULL);\n  e->wev_set = 1;\n\n  //Authentication\n  if(redis_le_valid(e) && pwd) {\n\t  if(redisAsyncCommand(ac, NULL, e, \"AUTH %s\", pwd)!=REDIS_OK) {\n\t\t  e->invalid = 1;\n\t  }\n  }\n\n  if(redis_le_valid(e)) {\n\t  if(redisAsyncCommand(ac, NULL, e, \"SELECT %d\", db)!=REDIS_OK) {\n\t\t  e->invalid = 1;\n\t  }\n  }\n\n  return (redis_context_handle)e;\n}", "path": "coturn/src/apps/common/hiredis_libevent2.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "coturn/coturn", "stars": 10275, "license": "other", "language": "c", "size": 4935}
{"docstring": "/////////////// AUX SERVERS ////////////////\n", "func_signal": "static void add_aux_server_list(const char *saddr, turn_server_addrs_list_t *list)", "code": "{\n\tif(saddr && list) {\n\t\tioa_addr addr;\n\t\tif(make_ioa_addr_from_full_string((const uint8_t*)saddr, 0, &addr)!=0) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"Wrong full address format: %s\\n\",saddr);\n\t\t} else {\n\t\t  list->addrs = (ioa_addr*)realloc(list->addrs,sizeof(ioa_addr)*(list->size+1));\n\t\t\taddr_cpy(&(list->addrs[(list->size)++]),&addr);\n\t\t\t{\n\t\t\t\tuint8_t s[1025];\n\t\t\t\taddr_to_string(&addr, s);\n\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"Aux server: %s\\n\",s);\n\t\t\t}\n\t\t}\n\t}\n}", "path": "coturn/src/apps/relay/netengine.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "coturn/coturn", "stars": 10275, "license": "other", "language": "c", "size": 4935}
{"docstring": "/////////////// io handlers ///////////////////\n", "func_signal": "static ioa_socket_handle dtls_accept_client_connection(\n\t\t\t\tdtls_listener_relay_server_type* server,\n\t\t\t\tioa_socket_handle sock,\n\t\t\t\tSSL *ssl,\n\t\t\t\tioa_addr *remote_addr, ioa_addr *local_addr,\n\t\t\t\tioa_network_buffer_handle nbh)", "code": "{\n\tFUNCSTART;\n\n\tif (!ssl)\n\t\treturn NULL;\n\n\tint rc = ssl_read(sock->fd, ssl, nbh, server->verbose);\n\n\tif (rc < 0)\n\t\treturn NULL;\n\n\taddr_debug_print(server->verbose, remote_addr, \"Accepted connection from\");\n\n\tioa_socket_handle ioas = create_ioa_socket_from_ssl(server->e, sock, ssl, DTLS_SOCKET, CLIENT_SOCKET, remote_addr, local_addr);\n\tif(ioas) {\n\t\taddr_cpy(&(server->sm.m.sm.nd.src_addr),remote_addr);\n\t\tserver->sm.m.sm.nd.recv_ttl = TTL_IGNORE;\n\t\tserver->sm.m.sm.nd.recv_tos = TOS_IGNORE;\n\t\tserver->sm.m.sm.s = ioas;\n\t} else {\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"Cannot create ioa_socket from SSL\\n\");\n\t}\n\n\tFUNCEND\t;\n\n\treturn ioas;\n}", "path": "coturn/src/apps/relay/dtls_listener.c", "commit_date": "2019-03-08 00:00:00", "repo_name": "coturn/coturn", "stars": 10275, "license": "other", "language": "c", "size": 4935}
{"docstring": "///////////// ORIGIN ///////////////////\n", "func_signal": "int get_default_protocol_port(const char* scheme, size_t slen)", "code": "{\n\tif(scheme && (slen>0)) {\n\t\tswitch(slen) {\n\t\tcase 3:\n\t\t\tif(!memcmp(\"ftp\",scheme,3))\n\t\t\t\treturn 21;\n\t\t\tif(!memcmp(\"svn\",scheme,3))\n\t\t\t\treturn 3690;\n\t\t\tif(!memcmp(\"ssh\",scheme,3))\n\t\t\t\treturn 22;\n\t\t\tif(!memcmp(\"sip\",scheme,3))\n\t\t\t\treturn 5060;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif(!memcmp(\"http\",scheme,4))\n\t\t\t\treturn 80;\n\t\t\tif(!memcmp(\"ldap\",scheme,4))\n\t\t\t\treturn 389;\n\t\t\tif(!memcmp(\"sips\",scheme,4))\n\t\t\t\treturn 5061;\n\t\t\tif(!memcmp(\"turn\",scheme,4))\n\t\t\t\treturn 3478;\n\t\t\tif(!memcmp(\"stun\",scheme,4))\n\t\t\t\treturn 3478;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tif(!memcmp(\"https\",scheme,5))\n\t\t\t\treturn 443;\n\t\t\tif(!memcmp(\"ldaps\",scheme,5))\n\t\t\t\treturn 636;\n\t\t\tif(!memcmp(\"turns\",scheme,5))\n\t\t\t\treturn 5349;\n\t\t\tif(!memcmp(\"stuns\",scheme,5))\n\t\t\t\treturn 5349;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tif(!memcmp(\"telnet\",scheme,6))\n\t\t\t\treturn 23;\n\t\t\tif(!memcmp(\"radius\",scheme,6))\n\t\t\t\treturn 1645;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tif(!memcmp(\"svn+ssh\",scheme,7))\n\t\t\t\treturn 22;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t};\n\t}\n\treturn 0;\n}", "path": "coturn/src/apps/common/ns_turn_utils.c", "commit_date": "2020-09-01 00:00:00", "repo_name": "coturn/coturn", "stars": 10275, "license": "other", "language": "c", "size": 4935}
{"docstring": "/////////////////// Callbacks ////////////////////////////\n", "func_signal": "static void redisLibeventReadEvent(int fd, short event, void *arg)", "code": "{\n  ((void)fd); ((void)event);\n  struct redisLibeventEvents *e = (struct redisLibeventEvents*)arg;\n  if(redis_le_valid(e)) {\n\t  {\n\t\t  char buf[8];\n\t\t  int len = 0;\n\t\t  do {\n\t\t\t  len = recv(fd,buf,sizeof(buf),MSG_PEEK);\n\t\t  } while((len<0)&&(errno == EINTR));\n\t\t  if(len<1) {\n\t\t\t  e->invalid = 1;\n\t\t\t  TURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: Redis connection broken: e=0x%lx\\n\", __FUNCTION__, ((unsigned long)e));\n\t\t  }\n\t  }\n\t  if(redis_le_valid(e)) {\n\t\t  redisAsyncHandleRead(e->context);\n\t  }\n  } else {\n\t  redis_reconnect(e);\n  }\n}", "path": "coturn/src/apps/common/hiredis_libevent2.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "coturn/coturn", "stars": 10275, "license": "other", "language": "c", "size": 4935}
{"docstring": "/**\n * @ret:\n * 1 - success\n * 0 - not found\n */\n", "func_signal": "static int rtcp_map_del(rtcp_map* map, rtcp_token_type token)", "code": "{\n  if(!rtcp_map_valid(map)) return 0;\n  else {\n    TURN_MUTEX_LOCK(&map->mutex);\n    int ret = ur_map_del(map->map,token,rtcp_alloc_free);\n    TURN_MUTEX_UNLOCK(&map->mutex);\n    return ret;\n  }\n}", "path": "coturn/src/server/ns_turn_maps_rtcp.c", "commit_date": "2019-03-08 00:00:00", "repo_name": "coturn/coturn", "stars": 10275, "license": "other", "language": "c", "size": 4935}
{"docstring": "///////////////////// operations //////////////////////////\n", "func_signal": "static int create_server_socket(dtls_listener_relay_server_type* server, int report_creation)", "code": "{\n\n  FUNCSTART;\n\n  if(!server) return -1;\n\n  clean_server(server);\n\n  {\n\t  ioa_socket_raw udp_listen_fd = -1;\n\n\t  udp_listen_fd = socket(server->addr.ss.sa_family, CLIENT_DGRAM_SOCKET_TYPE, CLIENT_DGRAM_SOCKET_PROTOCOL);\n\t  if (udp_listen_fd < 0) {\n\t\t  perror(\"socket\");\n\t\t  return -1;\n\t  }\n\n\t  server->udp_listen_s = create_ioa_socket_from_fd(server->e, udp_listen_fd, NULL, UDP_SOCKET, LISTENER_SOCKET, NULL, &(server->addr));\n\n\t  set_sock_buf_size(udp_listen_fd,UR_SERVER_SOCK_BUF_SIZE);\n\n\t  if(sock_bind_to_device(udp_listen_fd, (unsigned char*)server->ifname)<0) {\n\t\t  TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\"Cannot bind listener socket to device %s\\n\",server->ifname);\n\t  }\n\n\t  set_raw_socket_ttl_options(udp_listen_fd, server->addr.ss.sa_family);\n\t  set_raw_socket_tos_options(udp_listen_fd, server->addr.ss.sa_family);\n\n\t  {\n\t\t  const int max_binding_time = 60;\n\t\t  int addr_bind_cycle = 0;\n\t\t  retry_addr_bind:\n\n\t\t  if(addr_bind(udp_listen_fd,&server->addr,1,1,UDP_SOCKET)<0) {\n\t\t\t  perror(\"Cannot bind local socket to addr\");\n\t\t\t  char saddr[129];\n\t\t\t  addr_to_string(&server->addr,(uint8_t*)saddr);\n\t\t\t  TURN_LOG_FUNC(TURN_LOG_LEVEL_WARNING,\"Cannot bind DTLS/UDP listener socket to addr %s\\n\",saddr);\n\t\t\t  if(addr_bind_cycle++<max_binding_time) {\n\t\t\t\t  TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\"Trying to bind DTLS/UDP listener socket to addr %s, again...\\n\",saddr);\n\t\t\t\t  sleep(1);\n\t\t\t\t  goto retry_addr_bind;\n\t\t\t  }\n\t\t\t  TURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR,\"Fatal final failure: cannot bind DTLS/UDP listener socket to addr %s\\n\",saddr);\n\t\t\t  exit(-1);\n\t\t  }\n\t  }\n\n\t  server->udp_listen_ev = event_new(server->e->event_base,udp_listen_fd,\n\t\t\t\t    EV_READ|EV_PERSIST,udp_server_input_handler,\n\t\t\t\t    server);\n\n\t  event_add(server->udp_listen_ev,NULL);\n  }\n\n  if(report_creation) {\n\t  if(!turn_params.no_udp && !turn_params.no_dtls)\n\t\t  addr_debug_print(server->verbose, &server->addr,\"DTLS/UDP listener opened on\");\n\t  else if(!turn_params.no_dtls)\n\t\t  addr_debug_print(server->verbose, &server->addr,\"DTLS listener opened on\");\n\t  else if(!turn_params.no_udp)\n\t\t  addr_debug_print(server->verbose, &server->addr,\"UDP listener opened on\");\n  }\n\n  FUNCEND;\n  \n  return 0;\n}", "path": "coturn/src/apps/relay/dtls_listener.c", "commit_date": "2019-03-08 00:00:00", "repo_name": "coturn/coturn", "stars": 10275, "license": "other", "language": "c", "size": 4935}
{"docstring": "//////////// UDP send ////////////////\n", "func_signal": "void udp_send_message(dtls_listener_relay_server_type *server, ioa_network_buffer_handle nbh, ioa_addr *dest)", "code": "{\n\tif(server && dest && nbh && (server->udp_listen_s))\n\t\tudp_send(server->udp_listen_s, dest, (char*)ioa_network_buffer_data(nbh), (int)ioa_network_buffer_get_size(nbh));\n}", "path": "coturn/src/apps/relay/dtls_listener.c", "commit_date": "2019-03-08 00:00:00", "repo_name": "coturn/coturn", "stars": 10275, "license": "other", "language": "c", "size": 4935}
{"docstring": "/////////////// ALLOCATION //////////////////////////////////////\n", "func_signal": "void init_allocation(void *owner, allocation* a, ur_map *tcp_connections)", "code": "{\n  if(a) {\n    bzero(a,sizeof(allocation));\n    a->owner = owner;\n    a->tcp_connections = tcp_connections;\n    init_turn_permission_hashtable(&(a->addr_to_perm));\n  }\n}", "path": "coturn/src/server/ns_turn_allocation.c", "commit_date": "2019-03-08 00:00:00", "repo_name": "coturn/coturn", "stars": 10275, "license": "other", "language": "c", "size": 4935}
{"docstring": "//////////// RFC 6062 ///////////////\n", "func_signal": "int turn_tcp_connect(int verbose, app_ur_conn_info *clnet_info, ioa_addr *peer_addr)", "code": "{\n\n\t{\n\t\tint cp_sent = 0;\n\n\t\tstun_buffer message;\n\n\t\tstun_init_request(STUN_METHOD_CONNECT, &message);\n\t\tstun_attr_add_addr(&message, STUN_ATTRIBUTE_XOR_PEER_ADDRESS, peer_addr);\n\n\t\tadd_origin(&message);\n\n\t\tif(add_integrity(clnet_info, &message)<0) return -1;\n\n\t\tstun_attr_add_fingerprint_str(message.buf,(size_t*)&(message.len));\n\n\t\twhile (!cp_sent) {\n\n\t\t\tint len = send_buffer(clnet_info, &message, 0,0);\n\n\t\t\tif (len > 0) {\n\t\t\t\tif (verbose) {\n\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"tcp connect sent\\n\");\n\t\t\t\t}\n\t\t\t\tcp_sent = 1;\n\t\t\t} else {\n\t\t\t\tperror(\"send\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\t////////////<<==connect send\n\n\treturn 0;\n}", "path": "coturn/src/apps/uclient/startuclient.c", "commit_date": "2019-03-08 00:00:00", "repo_name": "coturn/coturn", "stars": 10275, "license": "other", "language": "c", "size": 4935}
{"docstring": "////////////////////// main method /////////////////\n", "func_signal": "static int start_client(const char *remote_address, int port,\n\t\t\tconst unsigned char* ifname, const char *local_address, \n\t\t\tint messagenumber, \n\t\t\tint i)", "code": "{\n\n  app_ur_session* ss=create_new_ss();\n  app_ur_session* ss_rtcp=NULL;\n\n  if(!no_rtcp)\n    ss_rtcp = create_new_ss();\n\n  app_ur_conn_info clnet_info_probe; /* for load balancing probe */\n  bzero(&clnet_info_probe,sizeof(clnet_info_probe));\n  clnet_info_probe.fd = -1;\n\n  app_ur_conn_info *clnet_info=&(ss->pinfo);\n  app_ur_conn_info *clnet_info_rtcp=NULL;\n\n  if(!no_rtcp) \n    clnet_info_rtcp = &(ss_rtcp->pinfo);\n\n  uint16_t chnum=0;\n  uint16_t chnum_rtcp=0;\n\n  start_connection(port, remote_address, \n\t\t   ifname, local_address, \n\t\t   clnet_verbose,\n\t\t   &clnet_info_probe,\n\t\t   clnet_info, &chnum,\n\t\t   clnet_info_rtcp, &chnum_rtcp);\n\t\t   \n  if(clnet_info_probe.ssl) {\n  \tSSL_free(clnet_info_probe.ssl);\n  \tclnet_info_probe.fd = -1;\n  } else if(clnet_info_probe.fd != -1) {\n\t  socket_closesocket(clnet_info_probe.fd);\n\t  clnet_info_probe.fd = -1;\n  }\n  \n  socket_set_nonblocking(clnet_info->fd);\n  \n  if(!no_rtcp) \n\t  socket_set_nonblocking(clnet_info_rtcp->fd);\n  \n  struct event* ev = event_new(client_event_base,clnet_info->fd,\n\t\t\t\tEV_READ|EV_PERSIST,client_input_handler,\n\t\t\t\tss);\n\n  event_add(ev,NULL);\n  \n  struct event* ev_rtcp = NULL;\n\n  if(!no_rtcp) {\n    ev_rtcp = event_new(client_event_base,clnet_info_rtcp->fd,\n\t\t\tEV_READ|EV_PERSIST,client_input_handler,\n\t\t\tss_rtcp);\n  \n    event_add(ev_rtcp,NULL);\n  }\n  \n  ss->state=UR_STATE_READY;\n  \n  ss->input_ev=ev;\n  ss->tot_msgnum=messagenumber;\n  ss->recvmsgnum=-1;\n  ss->chnum=chnum;\n\n  if(!no_rtcp) {\n\n    ss_rtcp->state=UR_STATE_READY;\n    \n    ss_rtcp->input_ev=ev_rtcp;\n    ss_rtcp->tot_msgnum=ss->tot_msgnum;\n    if(ss_rtcp->tot_msgnum<1) ss_rtcp->tot_msgnum=1;\n    ss_rtcp->recvmsgnum=-1;\n    ss_rtcp->chnum=chnum_rtcp;\n  }\n  \n  elems[i]=ss;\n\n  refresh_channel(ss, 0, 600);\n\n  if(!no_rtcp)\n    elems[i+1]=ss_rtcp;\n\n  return 0;\n}", "path": "coturn/src/apps/uclient/uclient.c", "commit_date": "2020-04-30 00:00:00", "repo_name": "coturn/coturn", "stars": 10275, "license": "other", "language": "c", "size": 4935}
{"docstring": "/**\n * @ret:\n * 0 - success\n * -1 - error\n */\n", "func_signal": "int rtcp_map_put(rtcp_map* map, rtcp_token_type token, ioa_socket_handle s)", "code": "{\n  if(!rtcp_map_valid(map)) return -1;\n  else {\n    rtcp_alloc_type *value=(rtcp_alloc_type*)malloc(sizeof(rtcp_alloc_type));\n    if(!value) return -1;\n    bzero(value,sizeof(rtcp_alloc_type));\n    value->s=s;\n    value->t=turn_time() + RTCP_TIMEOUT;\n    value->token=token;\n    TURN_MUTEX_LOCK(&map->mutex);\n    int ret = ur_map_put(map->map,token,(ur_map_value_type)value);\n    //TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\"%s: 111.111: ret=%d, token=%llu\\n\",__FUNCTION__,ret,token);\n    TURN_MUTEX_UNLOCK(&map->mutex);\n    if(ret<0) free(value);\n    return ret;\n  }\n}", "path": "coturn/src/server/ns_turn_maps_rtcp.c", "commit_date": "2019-03-08 00:00:00", "repo_name": "coturn/coturn", "stars": 10275, "license": "other", "language": "c", "size": 4935}
{"docstring": "/////// Check whether this is a good address //////////////\n", "func_signal": "int ioa_addr_is_multicast(ioa_addr *addr)", "code": "{\n\tif(addr) {\n\t\tif(addr->ss.sa_family == AF_INET) {\n\t\t\tconst uint8_t *u = ((const uint8_t*)&(addr->s4.sin_addr));\n\t\t\treturn (u[0] > 223);\n\t\t} else if(addr->ss.sa_family == AF_INET6) {\n\t\t\tuint8_t u = ((const uint8_t*)&(addr->s6.sin6_addr))[0];\n\t\t\treturn (u == 255);\n\t\t}\n\t}\n\treturn 0;\n}", "path": "coturn/src/client/ns_turn_ioaddr.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "coturn/coturn", "stars": 10275, "license": "other", "language": "c", "size": 4935}
{"docstring": "// <<== communications between listener and relays\n", "func_signal": "static ioa_engine_handle create_new_listener_engine(void)", "code": "{\n\tstruct event_base *eb = turn_event_base_new();\n\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\"IO method (udp listener/relay thread): %s\\n\",event_base_get_method(eb));\n\tsuper_memory_t* sm = new_super_memory_region();\n\tioa_engine_handle e = create_ioa_engine(sm, eb, turn_params.listener.tp, turn_params.relay_ifname, turn_params.relays_number, turn_params.relay_addrs,\n\t\t\tturn_params.default_relays, turn_params.verbose\n#if !defined(TURN_NO_HIREDIS)\n\t\t\t,turn_params.redis_statsdb\n#endif\n\t);\n\tset_ssl_ctx(e, &turn_params);\n\tioa_engine_set_rtcp_map(e, turn_params.listener.rtcpmap);\n\treturn e;\n}", "path": "coturn/src/apps/relay/netengine.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "coturn/coturn", "stars": 10275, "license": "other", "language": "c", "size": 4935}
{"docstring": "/**\n * @ret:\n * >=0 - success\n * <0 - not found\n */\n", "func_signal": "ioa_socket_handle rtcp_map_get(rtcp_map* map, rtcp_token_type token)", "code": "{\n\tioa_socket_handle s = NULL;\n\tif (rtcp_map_valid(map)) {\n\t\tur_map_value_type value;\n\t\tTURN_MUTEX_LOCK(&map->mutex);\n\t\tint ret = ur_map_get(map->map, token, &value);\n\t\tif (ret) {\n\t\t\trtcp_alloc_type* rval = (rtcp_alloc_type*) value;\n\t\t\tif (rval) {\n\t\t\t\ts = rval->s;\n\t\t\t\trtcp_map_del_savefd(map, token);\n\t\t\t}\n\t\t}\n\t\tTURN_MUTEX_UNLOCK(&map->mutex);\n\t}\n\treturn s;\n}", "path": "coturn/src/server/ns_turn_maps_rtcp.c", "commit_date": "2019-03-08 00:00:00", "repo_name": "coturn/coturn", "stars": 10275, "license": "other", "language": "c", "size": 4935}
{"docstring": "////////////////////// BUFFERS ///////////////////////////\n", "func_signal": "int stun_init_buffer(stun_buffer *buf)", "code": "{\n  if(!buf) return -1;\n  bzero(buf->buf,sizeof(buf->buf));\n  buf->len=0;\n  buf->offset=0;\n  buf->coffset=0;\n  return 0;\n}", "path": "coturn/src/apps/common/stun_buffer.c", "commit_date": "2019-03-08 00:00:00", "repo_name": "coturn/coturn", "stars": 10275, "license": "other", "language": "c", "size": 4935}
{"docstring": "/////////////// ALTERNATE SERVERS ////////////////\n", "func_signal": "static void add_alt_server(const char *saddr, int default_port, turn_server_addrs_list_t *list)", "code": "{\n\tif(saddr && list) {\n\t\tioa_addr addr;\n\n\t\tturn_mutex_lock(&(list->m));\n\n\t\tif(make_ioa_addr_from_full_string((const uint8_t*)saddr, default_port, &addr)!=0) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"Wrong IP address format: %s\\n\",saddr);\n\t\t} else {\n\t\t  list->addrs = (ioa_addr*)realloc(list->addrs,sizeof(ioa_addr)*(list->size+1));\n\t\t\taddr_cpy(&(list->addrs[(list->size)++]),&addr);\n\t\t\t{\n\t\t\t\tuint8_t s[1025];\n\t\t\t\taddr_to_string(&addr, s);\n\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"Alternate server added: %s\\n\",s);\n\t\t\t}\n\t\t}\n\n\t\tturn_mutex_unlock(&(list->m));\n\t}\n}", "path": "coturn/src/apps/relay/netengine.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "coturn/coturn", "stars": 10275, "license": "other", "language": "c", "size": 4935}
{"docstring": "////////////////// TCP connections ///////////////////////////////\n", "func_signal": "static void set_new_tc_id(uint8_t server_id, tcp_connection *tc)", "code": "{\n\tallocation *a = (allocation*)(tc->owner);\n\tur_map *map = a->tcp_connections;\n\tuint32_t newid;\n\tuint32_t sid = server_id;\n\tsid = sid<<24;\n\tdo {\n\t\tnewid = 0;\n\t\twhile (!newid) {\n\t\t\tnewid = (uint32_t)turn_random();\n\t\t\tif(!newid) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnewid = newid & 0x00FFFFFF;\n\t\t\tif(!newid) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnewid = newid | sid;\n\t\t}\n\t} while(ur_map_get(map, (ur_map_key_type)newid, NULL));\n\ttc->id = newid;\n\tur_map_put(map, (ur_map_key_type)newid, (ur_map_value_type)tc);\n}", "path": "coturn/src/server/ns_turn_allocation.c", "commit_date": "2019-03-08 00:00:00", "repo_name": "coturn/coturn", "stars": 10275, "license": "other", "language": "c", "size": 4935}
{"docstring": "// 1 covered 0 uncovered  \n", "func_signal": "void cal(int a[6][32][32],int n,int col,int laststate,int nowstate)", "code": "{\n\tif (col >= n)\n\t{\n\t\t++a[n][laststate][nowstate];  \n\t\treturn;  \n\t}  \n\t//\u4e0d\u586b \u6216\u8005\u75281*1\u7684\u586b  \n\tcal(a,n, col + 1, laststate, nowstate);  \n\tif (((laststate >> col) & 1) == 0)\n\t{\n\t\tcal(a,n, col + 1, laststate, nowstate | (1 << col));  \n\t\tif ((col + 1 < n) && (((laststate >> (col + 1)) & 1) == 0))\n\t\t{\n\t\t\tcal(a,n, col + 2, laststate, nowstate);  \n\t\t}  \n\t}  \n}", "path": "The-Art-Of-Programming-By-July-2nd/ebook/code/c/4.1\uff1a\u6728\u5757\u780c\u5899.c", "commit_date": "2014-04-09 00:00:00", "repo_name": "julycoding/The-Art-Of-Programming-By-July-2nd", "stars": 21190, "license": "None", "language": "c", "size": 27547}
{"docstring": "//\u5728\u4e0a\u9762\u7684bigIndex_hashcode\u51fd\u6570\u7684\u57fa\u7840\u4e0a\uff0c\u4fee\u6539\n", "func_signal": "void bigIndex_hashcode(const char *in_file_path, const char *out_file_path)", "code": "{  \n\tFILE *fr, *fw;  \n\tint len, value;  \n\tchar *pbuf, *pleft, *p;  \n\tchar keyvalue[TERM_MAX_LENG], str[WORD_MAX_LENG];  \n\n\tif(in_file_path == NULL || *in_file_path == '\\0') {  \n\t\tprintf(\"input file path error!\\n\");  \n\t\treturn;  \n\t}  \n\n\tif(out_file_path == NULL || *out_file_path == '\\0') {  \n\t\tprintf(\"output file path error!\\n\");  \n\t\treturn;  \n\t}  \n\n\tfr = fopen(in_file_path, \"r\");  //\u8bfb\u53d6in_file_path\u8def\u5f84\u6587\u4ef6  \n\tfw = fopen(out_file_path, \"w\");  \n\n\tif(fr == NULL || fw == NULL)  \n\t{  \n\t\tprintf(\"open read or write file error!\\n\");  \n\t\treturn;  \n\t}  \n\n\tpbuf = (char*)malloc(BUFF_MAX_LENG);  \n\tpleft = (char*)malloc(BUFF_MAX_LENG);  \n\tif(pbuf == NULL || pleft == NULL)  \n\t{  \n\t\tprintf(\"allocate memory error!\");  \n\t\tfclose(fr);  \n\t\treturn ;  \n\t}  \n\n\tmemset(pbuf, 0, BUFF_MAX_LENG);  \n\n\tint offset = 1;  \n\twhile(fgets(pbuf, BUFF_MAX_LENG, fr))  \n\t{  \n\t\tif (--offset > 0)  \n\t\t\tcontinue;  \n\n\t\tif(GetRealString(pbuf) <= 1)  \n\t\t\tcontinue;  \n\n\t\tp = strstr(pbuf, \"#####\");    \n\t\tif(p != NULL)  \n\t\t\tcontinue;  \n\n\t\tp = strstr(pbuf, \"  \");  \n\t\tif (p == NULL)  \n\t\t{  \n\t\t\tprintf(\"file contents error!\");  \n\t\t}  \n\n\t\tlen = p - pbuf;  \n\n\t\t// \u786e\u5b9a\u8df3\u8fc7\u884c\u6570  \n\t\tstrcpy(pleft, p+1);   \n\t\toffset = atoi(pleft) + 1;  \n\n\t\tstrncpy(keyvalue, pbuf, len);    \n\t\tkeyvalue[len] = '\\0';  \n\t\tvalue = insert_string(keyvalue);  \n\n\t\tif (value != -1) {  \n\n\t\t\t// key value\u4e2d\u63d2\u5165\u7a7a\u683c  \n\t\t\tkeyvalue[len] = ' ';  \n\t\t\tkeyvalue[len+1] = '\\0';  \n\n\t\t\titoa(value, str, 10);  \n\t\t\tstrcat(keyvalue, str);  \n\n\t\t\tkeyvalue[len+strlen(str)+1] = ' ';  \n\t\t\tkeyvalue[len+strlen(str)+2] = '\\0';  \n\n\t\t\tkeysize++;  \n\t\t\titoa(keysize, str, 10);  \n\t\t\tstrcat(keyvalue, str);  \n\n\t\t\t// \u5c06key value\u5199\u5165\u6587\u4ef6  \n\t\t\tfprintf (fw, \"%s\\n\", keyvalue);  \n\n\t\t}  \n\t}  \n\tfree(pbuf);  \n\tfclose(fr);  \n\tfclose(fw);  \n}", "path": "The-Art-Of-Programming-By-July-2nd/ebook/code/c/7.3\uff1a\u5012\u6392\u7d22\u5f15\u5173\u952e\u8bcd\u4e0d\u91cd\u590dHash\u7f16\u7801.c", "commit_date": "2014-04-09 00:00:00", "repo_name": "julycoding/The-Art-Of-Programming-By-July-2nd", "stars": 21190, "license": "None", "language": "c", "size": 27547}
{"docstring": "//\u89e3\u6cd5\u4e00\n//\u77e9\u9635\u4e58\u6cd5\uff0c3\u4e2afor\u5faa\u73af\u641e\u5b9a    \n", "func_signal": "void Mul(int** matrixA, int** matrixB, int** matrixC)", "code": "{    \n\tfor(int i = 0; i < 2; ++i)     \n\t{    \n\t\tfor(int j = 0; j < 2; ++j)     \n\t\t{    \n\t\t\tmatrixC[i][j] = 0;    \n\t\t\tfor(int k = 0; k < 2; ++k)     \n\t\t\t{    \n\t\t\t\tmatrixC[i][j] += matrixA[i][k] * matrixB[k][j];    \n\t\t\t}    \n\t\t}    \n\t}    \n}", "path": "The-Art-Of-Programming-By-July-2nd/ebook/code/c/2.8\uff1a\u77e9\u9635\u76f8\u4e58\u4e4bStrassen\u7b97\u6cd5.c", "commit_date": "2014-04-09 00:00:00", "repo_name": "julycoding/The-Art-Of-Programming-By-July-2nd", "stars": 21190, "license": "None", "language": "c", "size": 27547}
{"docstring": "//\u4ee3\u7801\u4e8c\n//\u67e5\u627e\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\uff0c\u7b2c2\u4e2a\u7a0b\u5e8f\n//copyright@ yansha\n//July\u3001updated\uff0c2011.04.24.\n", "func_signal": "char FirstNotRepeatChar(char* pString)", "code": "{\n\tif (!pString)\n\t\treturn '\\0';\n\n\tconst int tableSize = 256;\n\tint hashTable[tableSize] = {0}; //\u5b58\u5165\u6570\u7ec4\uff0c\u5e76\u521d\u59cb\u5316\u4e3a0\n\n\tchar* pHashKey = pString;\n\twhile (*(pHashKey) != '\\0')\n\t\thashTable[*(pHashKey++)]++;\n\n\twhile (*pString != '\\0')\n\t{\n\t\tif (hashTable[*pString] == 1)\n\t\t\treturn *pString;\n\n\t\tpString++;\n\t}\n\treturn '\\0';  //\u6ca1\u6709\u627e\u5230\u6ee1\u8db3\u6761\u4ef6\u7684\u5b57\u7b26\uff0c\u9000\u51fa\n}", "path": "The-Art-Of-Programming-By-July-2nd/ebook/code/c/6.8\uff1a\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26.c", "commit_date": "2014-04-09 00:00:00", "repo_name": "julycoding/The-Art-Of-Programming-By-July-2nd", "stars": 21190, "license": "None", "language": "c", "size": 27547}
{"docstring": "//\u51fd\u6570GetHashTablePos\u4e2d\uff0clpszString \u4e3a\u8981\u5728hash\u8868\u4e2d\u67e5\u627e\u7684\u5b57\u7b26\u4e32\uff1blpTable \u4e3a\u5b58\u50a8\u5b57\u7b26\u4e32hash\u503c\u7684hash\u8868\uff1bnTableSize \u4e3ahash\u8868\u7684\u957f\u5ea6\uff1a   \n", "func_signal": "int GetHashTablePos( char *lpszString, MPQHASHTABLE *lpTable, int nTableSize )", "code": "{  \n\tconst int  HASH_OFFSET = 0, HASH_A = 1, HASH_B = 2;  \n\n\tint  nHash = HashString( lpszString, HASH_OFFSET );  \n\tint  nHashA = HashString( lpszString, HASH_A );  \n\tint  nHashB = HashString( lpszString, HASH_B );  \n\tint  nHashStart = nHash % nTableSize;  \n\tint  nHashPos = nHashStart;  \n\n\twhile ( lpTable[nHashPos].bExists )  \n\t{  \n\t\t//     \u5982\u679c\u4ec5\u4ec5\u662f\u5224\u65ad\u5728\u8be5\u8868\u4e2d\u65f6\u5019\u5b58\u5728\u8fd9\u4e2a\u5b57\u7b26\u4e32\uff0c\u5c31\u6bd4\u8f83\u8fd9\u4e24\u4e2ahash\u503c\u5c31\u53ef\u4ee5\u4e86\uff0c\u4e0d\u7528\u5bf9\u7ed3\u6784\u4f53\u4e2d\u7684\u5b57\u7b26\u4e32\u8fdb\u884c\u6bd4\u8f83\u3002  \n\t\t//         \u8fd9\u6837\u4f1a\u52a0\u5feb\u8fd0\u884c\u7684\u901f\u5ea6\uff1f\u51cf\u5c11hash\u8868\u5360\u7528\u7684\u7a7a\u95f4\uff1f\u8fd9\u79cd\u65b9\u6cd5\u4e00\u822c\u5e94\u7528\u5728\u4ec0\u4e48\u573a\u5408\uff1f  \n\t\tif ( \u3000 lpTable[nHashPos].nHashA == nHashA  \n\t\t\t&&  lpTable[nHashPos].nHashB == nHashB )  \n\t\t{  \n\t\t\treturn nHashPos;  \n\t\t}  \n\t\telse  \n\t\t{  \n\t\t\tnHashPos = (nHashPos + 1) % nTableSize;  \n\t\t}  \n\n\t\tif (nHashPos == nHashStart)  \n\t\t\tbreak;  \n\t}  \n\treturn -1;  \n}", "path": "The-Art-Of-Programming-By-July-2nd/ebook/code/c/7.3\uff1a\u5012\u6392\u7d22\u5f15\u5173\u952e\u8bcd\u4e0d\u91cd\u590dHash\u7f16\u7801.c", "commit_date": "2014-04-09 00:00:00", "repo_name": "julycoding/The-Art-Of-Programming-By-July-2nd", "stars": 21190, "license": "None", "language": "c", "size": 27547}
{"docstring": "//\u76f4\u63a5\u8c03\u7528\u4e0a\u9762\u7684hashstring\uff0cnHashPos\u5c31\u662f\u5bf9\u5e94\u7684HASH\u503c\u3002  \n", "func_signal": "int insert_string(const char *string_in)", "code": "{  \n\tconst int HASH_OFFSET = 0, HASH_C = 1, HASH_D = 2;  \n\tunsigned int nHash = HashString(string_in, HASH_OFFSET);  \n\tunsigned int nHashC = HashString(string_in, HASH_C);  \n\tunsigned int nHashD = HashString(string_in, HASH_D);  \n\tunsigned int nHashStart = nHash % nTableSize;  \n\tunsigned int nHashPos = nHashStart;  \n\tint ln, ires = 0;  \n\n\twhile (TestHashTable[nHashPos].bExists)  \n\t{  \n\t\t//      if (TestHashCTable[nHashPos]  == (int) nHashC && TestHashDTable[nHashPos] == (int) nHashD)  \n\t\t//          break;  \n\t\t//      //...  \n\t\t//      else  \n\t\t//\u5982\u4e4b\u524d\u6240\u63d0\u793a\u8bfb\u8005\u7684\u90a3\u822c\uff0c\u66b4\u96ea\u7684Hash\u7b97\u6cd5\u5bf9\u4e8e\u67e5\u8be2\u90a3\u6837\u5904\u7406\u53ef\u4ee5\uff0c\u4f46\u5bf9\u63d2\u5165\u5c31\u4e0d\u80fd\u90a3\u4e48\u89e3\u51b3  \n\t\tnHashPos = (nHashPos + 1) % nTableSize;  \n\n\t\tif (nHashPos == nHashStart)  \n\t\t\tbreak;  \n\t}  \n\n\tln = strlen(string_in);  \n\tif (!TestHashTable[nHashPos].bExists && (ln < nMaxStrLen))  \n\t{   \n\t\tTestHashCTable[nHashPos] = nHashC;  \n\t\tTestHashDTable[nHashPos] = nHashD;  \n\n\t\ttest_data[nHashPos] = (KEYNODE *) malloc (sizeof(KEYNODE) * 1);  \n\t\tif(test_data[nHashPos] == NULL)  \n\t\t{  \n\t\t\tprintf(\"10000 EMS ERROR !!!!\\n\");  \n\t\t\treturn 0;  \n\t\t}  \n\n\t\ttest_data[nHashPos]->pkey = (char *)malloc(ln+1);  \n\t\tif(test_data[nHashPos]->pkey == NULL)  \n\t\t{  \n\t\t\tprintf(\"10000 EMS ERROR !!!!\\n\");  \n\t\t\treturn 0;  \n\t\t}  \n\n\t\tmemset(test_data[nHashPos]->pkey, 0, ln+1);  \n\t\tstrncpy(test_data[nHashPos]->pkey, string_in, ln);  \n\t\t*((test_data[nHashPos]->pkey)+ln) = 0;  \n\t\ttest_data[nHashPos]->weight = nHashPos;  \n\n\t\tTestHashTable[nHashPos].bExists = 1;  \n\t}  \n\telse  \n\t{  \n\t\tif(TestHashTable[nHashPos].bExists)  \n\t\t\tprintf(\"30000 in the hash table %s !!!\\n\", string_in);  \n\t\telse  \n\t\t\tprintf(\"90000 strkey error !!!\\n\");  \n\t}  \n\treturn nHashPos;  \n}", "path": "The-Art-Of-Programming-By-July-2nd/ebook/code/c/7.3\uff1a\u5012\u6392\u7d22\u5f15\u5173\u952e\u8bcd\u4e0d\u91cd\u590dHash\u7f16\u7801.c", "commit_date": "2014-04-09 00:00:00", "repo_name": "julycoding/The-Art-Of-Programming-By-July-2nd", "stars": 21190, "license": "None", "language": "c", "size": 27547}
{"docstring": "//\u6307\u9488\u79fb\u4f4d\u6cd5\n", "func_signal": "void leftShift2(char * arr, int len, int n)", "code": "{\n    int i;\n    size_t tmpLen = len;\n    int p0 = 0;\n    int p1 = n;\n    char tmpChar;\n    /*  O(m - n - k)  k is the last section*/\n    while (p1 + n - 1 < tmpLen)\n    {\n        tmpChar = *(arr + p0);\n        *(arr + p0) = *(arr + p1);\n        *(arr + p1) = tmpChar;\n        p0++;\n        p1++;\n    }\n    /*\n     *  not good O(k * (n + k)) k = tmpLen - p1\n     for(i = 0;i < tmpLen - p1;i++){ //\u79fb\u52a8\u540e\u9762\u5269\u4e0b\u7684\n     tmpChar = *(arr + tmpLen - 1);\n     for(j = tmpLen - 1;j > p0;j--){\n     *(arr + j) = *(arr + j -1);\n     }\n     *(arr + p0) = tmpChar;\n     }\n     */\n    /* good O(k * n) */\n    while (p1 < tmpLen)\n    {\n        tmpChar = *(arr + p1);\n        for (i = p1; i > p0; i--)\n        {\n            *(arr + i) = *(arr + i - 1);\n        }\n        *(arr + p0) = tmpChar;\n        p0++;\n        p1++;\n    }\n}", "path": "The-Art-Of-Programming-By-July-2nd/ebook/code/c/1.1\uff1a\u5de6\u65cb\u8f6c\u5b57\u7b26\u4e32.c", "commit_date": "2014-03-22 00:00:00", "repo_name": "julycoding/The-Art-Of-Programming-By-July-2nd", "stars": 21190, "license": "None", "language": "c", "size": 27547}
{"docstring": "//\u6307\u9488\u79fb\u4f4d\u6cd5,\u9012\u5f52\n", "func_signal": "void leftShift4(char * arr, int len, int n)", "code": "{\n    size_t tmpLen = len;\n    int p0 = 0;\n    int p1 = n;\n    char tmpChar;\n    /*  O(m - n - k)  k is the last section*/\n    while (p1 < tmpLen)\n    {\n        tmpChar = *(arr + p0);\n        *(arr + p0) = *(arr + p1);\n        *(arr + p1) = tmpChar;\n        p0++;\n        p1++;\n    }\n    int i = n - tmpLen % n;\n    if (i != 0 && p0 != tmpLen - 1) // p0 can not be the tmpLen - 1\n    {\n        leftShift4((arr + p0), n, i);\n    }\n}", "path": "The-Art-Of-Programming-By-July-2nd/ebook/code/c/1.1\uff1a\u5de6\u65cb\u8f6c\u5b57\u7b26\u4e32.c", "commit_date": "2014-03-22 00:00:00", "repo_name": "julycoding/The-Art-Of-Programming-By-July-2nd", "stars": 21190, "license": "None", "language": "c", "size": 27547}
{"docstring": "//\u72b6\u6001\u8868\u793adp[step][i][j] \u5e76\u4e14i <= j, \u7b2cstep\u6b65  \u4e24\u4e2a\u4eba\u5206\u522b\u5728\u7b2ci\u884c\u548c\u7b2cj\u884c\u7684\u6700\u5927\u5f97\u5206 \u65f6\u95f4\u590d\u6742\u5ea6O(n^3) \u4f7f\u7528\u6eda\u52a8\u6570\u7ec4 \u7a7a\u95f4\u590d\u6742\u5ea6O(n^2)\n", "func_signal": "int getAnswer(int a[N][N], int n)", "code": "{\n\tint P = n * 2 - 2; //\u6700\u7ec8\u7684\u6b65\u6570\n\tint i, j, step, s;\n\n\t//\u4e0d\u80fd\u5230\u8fbe\u7684\u4f4d\u7f6e \u8bbe\u7f6e\u4e3a\u8d1f\u65e0\u7a77\u5927\n\tfor (i = 0; i < n; ++i)\n\t{\n\t\tfor (j = i; j < n; ++j)\n\t\t{\n\t\t\tdp[0][i][j] = -inf;\n\t\t}\n\t}\n\tdp[0][0][0] = a[0][0];\n\n\tfor (step = 1; step <= P; ++step)\n\t{\n\t\tfor (i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (j = i; j < n; ++j)\n\t\t\t{\n\t\t\t\tdp[step][i][j] = -inf;\n\t\t\t\tif (!isValid(step, i, j, n))   //\u975e\u6cd5\u4f4d\u7f6e\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ts = step % 2;  //\u72b6\u6001\u4e0b\u8868\u6807\n\t\t\t\t//\u5bf9\u4e8e\u5408\u6cd5\u7684\u4f4d\u7f6e\u8fdb\u884cdp\n\t\t\t\tif (i != j)\n\t\t\t\t{\n\t\t\t\t\tdp[s][i][j] = max(dp[s][i][j], getValue(step - 1, i - 1, j - 1, n));\n\t\t\t\t\tdp[s][i][j] = max(dp[s][i][j], getValue(step - 1, i - 1, j, n));\n\t\t\t\t\tdp[s][i][j] = max(dp[s][i][j], getValue(step - 1, i, j - 1, n));\n\t\t\t\t\tdp[s][i][j] = max(dp[s][i][j], getValue(step - 1, i, j, n));\n\t\t\t\t\tdp[s][i][j] += a[i][step - i] + a[j][step - j];  //\u4e0d\u5728\u540c\u4e00\u4e2a\u683c\u5b50\uff0c\u52a0\u4e24\u4e2a\u6570\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[s][i][j] = max(dp[s][i][j], getValue(step - 1, i - 1, j - 1, n));\n\t\t\t\t\tdp[s][i][j] = max(dp[s][i][j], getValue(step - 1, i - 1, j,  n));\n\t\t\t\t\tdp[s][i][j] = max(dp[s][i][j], getValue(step - 1, i, j,  n));\n\t\t\t\t\tdp[s][i][j] += a[i][step - i]; // \u5728\u540c\u4e00\u4e2a\u683c\u5b50\u91cc\uff0c\u53ea\u80fd\u52a0\u4e00\u6b21\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[P % 2][n - 1][n - 1];\n}", "path": "The-Art-Of-Programming-By-July-2nd/ebook/code/c/4.2\uff1a\u683c\u5b50\u53d6\u6570\u95ee\u9898.c", "commit_date": "2014-04-09 00:00:00", "repo_name": "julycoding/The-Art-Of-Programming-By-July-2nd", "stars": 21190, "license": "None", "language": "c", "size": 27547}
{"docstring": "//\u72b6\u6001\u8868\u793adp[step][i][j] \u5e76\u4e14i <= j, \u7b2cstep\u6b65  \u4e24\u4e2a\u4eba\u5206\u522b\u5728\u7b2ci\u884c\u548c\u7b2cj\u884c\u7684\u6700\u5927\u5f97\u5206 \u65f6\u95f4\u590d\u6742\u5ea6O(n^3) \u7a7a\u95f4\u590d\u6742\u5ea6O(n^3)\n", "func_signal": "int getAnswer(int a[N][N], int n)", "code": "{\n\tint P = n * 2 - 2; //\u6700\u7ec8\u7684\u6b65\u6570\n\tint i, j, step;\n\n\t//\u4e0d\u80fd\u5230\u8fbe\u7684\u4f4d\u7f6e \u8bbe\u7f6e\u4e3a\u8d1f\u65e0\u7a77\u5927\n\tfor (i = 0; i < n; ++i)\n\t{\n\t\tfor (j = i; j < n; ++j)\n\t\t{\n\t\t\tdp[0][i][j] = -inf;\n\t\t}\n\t}\n\tdp[0][0][0] = a[0][0];\n\n\tfor (step = 1; step <= P; ++step)\n\t{\n\t\tfor (i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (j = i; j < n; ++j)\n\t\t\t{\n\t\t\t\tdp[step][i][j] = -inf;\n\t\t\t\tif (!isValid(step, i, j, n))   //\u975e\u6cd5\u4f4d\u7f6e\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//\u5bf9\u4e8e\u5408\u6cd5\u7684\u4f4d\u7f6e\u8fdb\u884cdp\n\t\t\t\tif (i != j)\n\t\t\t\t{\n\t\t\t\t\tdp[step][i][j] = max(dp[step][i][j], getValue(step - 1, i - 1, j - 1, n));\n\t\t\t\t\tdp[step][i][j] = max(dp[step][i][j], getValue(step - 1, i - 1, j, n));\n\t\t\t\t\tdp[step][i][j] = max(dp[step][i][j], getValue(step - 1, i, j - 1, n));\n\t\t\t\t\tdp[step][i][j] = max(dp[step][i][j], getValue(step - 1, i, j, n));\n\t\t\t\t\tdp[step][i][j] += a[i][step - i] + a[j][step - j];  //\u4e0d\u5728\u540c\u4e00\u4e2a\u683c\u5b50\uff0c\u52a0\u4e24\u4e2a\u6570\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[step][i][j] = max(dp[step][i][j], getValue(step - 1, i - 1, j - 1, n));\n\t\t\t\t\tdp[step][i][j] = max(dp[step][i][j], getValue(step - 1, i - 1, j,  n));\n\t\t\t\t\tdp[step][i][j] = max(dp[step][i][j], getValue(step - 1, i, j,  n));\n\t\t\t\t\tdp[step][i][j] += a[i][step - i]; // \u5728\u540c\u4e00\u4e2a\u683c\u5b50\u91cc\uff0c\u53ea\u80fd\u52a0\u4e00\u6b21\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[P][n - 1][n - 1];\n}", "path": "The-Art-Of-Programming-By-July-2nd/ebook/code/c/4.2\uff1a\u683c\u5b50\u53d6\u6570\u95ee\u9898.c", "commit_date": "2014-04-09 00:00:00", "repo_name": "julycoding/The-Art-Of-Programming-By-July-2nd", "stars": 21190, "license": "None", "language": "c", "size": 27547}
{"docstring": "//dp[i][j]\u8868\u793asource[0-i)\u4e0etarget[0-j)\u7684\u7f16\u8f91\u8ddd\u79bb\n", "func_signal": "int editDistance(char *pSource, char *pTarget)", "code": "{\n\tint srcLength = strlen(pSource);\n\tint targetLength = strlen(pTarget);\n\tint i, j;\n\t//\u8fb9\u754cdp[i][0] = i\uff0cdp[0][j] = j  \n\tfor (i = 1; i <= srcLength; ++i)\n\t{\n\t\tdp[i][0] = i;\n\t}\n\tfor (j = 1; j <= targetLength; ++j)\n\t{\n\t\tdp[0][j] = j;\n\t}\n\tfor (i = 1; i <= srcLength; ++i)\n\t{\n\t\tfor (j = 1; j <= targetLength; ++j)\n\t\t{\n\t\t\tif (pSource[i - 1] == pTarget[j - 1])\n\t\t\t{\n\t\t\t\tdp[i][j] = dp[i - 1][j - 1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[srcLength][targetLength];\n}", "path": "The-Art-Of-Programming-By-July-2nd/ebook/code/c/5.3\uff1a\u5b57\u7b26\u4e32\u7f16\u8f91\u8ddd\u79bb.c", "commit_date": "2014-05-30 00:00:00", "repo_name": "julycoding/The-Art-Of-Programming-By-July-2nd", "stars": 21190, "license": "None", "language": "c", "size": 27547}
{"docstring": "//24.4\u3001\u66b4\u96ea\u7684Hash\u7b97\u6cd5\n//\u51fd\u6570prepareCryptTable\u4ee5\u4e0b\u7684\u51fd\u6570\u751f\u6210\u4e00\u4e2a\u957f\u5ea6\u4e3a0x500\uff08\u540810\u8fdb\u5236\u6570\uff1a1280\uff09\u7684cryptTable[0x500]  \n", "func_signal": "void prepareCryptTable()", "code": "{   \n\tunsigned long seed = 0x00100001, index1 = 0, index2 = 0, i;  \n\n\tfor( index1 = 0; index1 < 0x100; index1++ )  \n\t{   \n\t\tfor( index2 = index1, i = 0; i < 5; i++, index2 += 0x100 )  \n\t\t{   \n\t\t\tunsigned long temp1, temp2;  \n\n\t\t\tseed = (seed * 125 + 3) % 0x2AAAAB;  \n\t\t\ttemp1 = (seed & 0xFFFF) << 0x10;  \n\n\t\t\tseed = (seed * 125 + 3) % 0x2AAAAB;  \n\t\t\ttemp2 = (seed & 0xFFFF);  \n\n\t\t\tcryptTable[index2] = ( temp1 | temp2 );   \n\t\t}   \n\t}   \n}", "path": "The-Art-Of-Programming-By-July-2nd/ebook/code/c/7.3\uff1a\u5012\u6392\u7d22\u5f15\u5173\u952e\u8bcd\u4e0d\u91cd\u590dHash\u7f16\u7801.c", "commit_date": "2014-04-09 00:00:00", "repo_name": "julycoding/The-Art-Of-Programming-By-July-2nd", "stars": 21190, "license": "None", "language": "c", "size": 27547}
{"docstring": "//\u5faa\u73af\u79fb\u4f4d\u6cd5\n", "func_signal": "void leftShift6(char * arr, int len, int n)", "code": "{\n    int group = gcd(len, n);\n    char tmpChar;\n    int x = len / group;\n    int i, j;\n    for (i = 0; i < group; i++)\n    {\n        tmpChar = *(arr + i);\n        for (j = 0; j < x - 1; j++)\n        {\n            *(arr + (i + (j * n)) % len) = *(arr + (i + (j * n) + n) % len);\n        }\n        *(arr + (i + (j * n)) % len) = tmpChar;\n    }\n}", "path": "The-Art-Of-Programming-By-July-2nd/ebook/code/c/1.1\uff1a\u5de6\u65cb\u8f6c\u5b57\u7b26\u4e32.c", "commit_date": "2014-03-22 00:00:00", "repo_name": "julycoding/The-Art-Of-Programming-By-July-2nd", "stars": 21190, "license": "None", "language": "c", "size": 27547}
{"docstring": "//\u6307\u9488\u79fb\u4f4d\u6cd5,\u5c3e\u90e8\u5904\u7406\u7528\u9012\u5f52\n", "func_signal": "void leftShift3(char * arr, int len, int n)", "code": "{\n    size_t tmpLen = len;\n    int p0 = 0;\n    int p1 = n;\n    char tmpChar;\n    /*  O(m - n - k)  k is the last section*/\n    while (p1 + n - 1 < tmpLen)\n    {\n        tmpChar = *(arr + p0);\n        *(arr + p0) = *(arr + p1);\n        *(arr + p1) = tmpChar;\n        p0++;\n        p1++;\n    }\n    if (p1 < tmpLen)\n    {\n        leftShift2(arr + p0, len - p0, n);\n    }\n}", "path": "The-Art-Of-Programming-By-July-2nd/ebook/code/c/1.1\uff1a\u5de6\u65cb\u8f6c\u5b57\u7b26\u4e32.c", "commit_date": "2014-03-22 00:00:00", "repo_name": "julycoding/The-Art-Of-Programming-By-July-2nd", "stars": 21190, "license": "None", "language": "c", "size": 27547}
{"docstring": "//\u51fd\u6570HashString\u4ee5\u4e0b\u51fd\u6570\u8ba1\u7b97lpszFileName \u5b57\u7b26\u4e32\u7684hash\u503c\uff0c\u5176\u4e2ddwHashType \u4e3ahash\u7684\u7c7b\u578b \n", "func_signal": "unsigned long HashString(const char *lpszkeyName, unsigned long dwHashType )", "code": "{  \n\tunsigned char *key  = (unsigned char *)lpszkeyName;  \n\tunsigned long seed1 = 0x7FED7FED;  \n\tunsigned long seed2 = 0xEEEEEEEE;  \n\tint ch;  \n\n\twhile( *key != 0 )  \n\t{  \n\t\tch = *key++;  \n\t\tseed1 = cryptTable[(dwHashType<<8) + ch] ^ (seed1 + seed2);  \n\t\tseed2 = ch + seed1 + seed2 + (seed2<<5) + 3;  \n\t}  \n\treturn seed1;  \n}", "path": "The-Art-Of-Programming-By-July-2nd/ebook/code/c/7.3\uff1a\u5012\u6392\u7d22\u5f15\u5173\u952e\u8bcd\u4e0d\u91cd\u590dHash\u7f16\u7801.c", "commit_date": "2014-04-09 00:00:00", "repo_name": "julycoding/The-Art-Of-Programming-By-July-2nd", "stars": 21190, "license": "None", "language": "c", "size": 27547}
{"docstring": "/**\n * @brief \u987a\u65f6\u9488\u6253\u5370\u87ba\u65cb\u6570\u7ec4\n *        \u91c7\u7528\u6a21\u62df\u7684\u65b9\u6cd5\uff0c\u6a21\u62df\u6570\u7ec4\u7684\u6253\u5370\u8fc7\u7a0b\uff0c\u987a\u65f6\u9488\u87ba\u65cb\u8f93\u51fa1\uff5en*n\u7684\u6570\u503c\n * @notice \u4e3a\u65b9\u4fbf\u903b\u8f91\u7406\u89e3\uff0c\u6570\u7ec4\u591a\u7533\u8bf7\u4e86\u4e00\u884c\u548c\u4e00\u5217\uff0c\u4fbf\u4e8e\u4e0b\u6807\u4ece1\u5f00\u59cb\u8ba1\u7b97\n * @param n \u87ba\u65cb\u6570\u7ec4\u7684\u884c\uff08\u5217\uff09\u6570\n */\n", "func_signal": "void PrintSpiralMatrix(int n)", "code": "{\n    if (n > 0) {\n        int i = 0, j = 0;\n        // \u6b63\u5728\u6a21\u62df\u7684\u5f53\u524d\u5f85\u586b\u5165\u6570\u503c\u3001\u5f53\u524d\u884c\u3001\u5f53\u524d\u5217\n        int curNum = 0, curRow = 0, curCol = 0;\n        \n        // \u4e3a\u77e9\u9635\u52a8\u6001\u5206\u914d\u7a7a\u95f4\n        // \u5982\u679c\u4ec5\u4ec5\u662f\u6253\u5370\uff0c\u53ef\u4ee5\u4e0d\u7528\u5206\u914d\uff0c\u6b64\u5904\u4ec5\u4e3a\u6f14\u793a\n        int **matrix = (int **) malloc((n+1) * sizeof(int *));\n        if (NULL == matrix) {\n            fprintf(stderr, \"malloc failed: out of memory\\n\");\n            exit(-1);\n        }\n\n        for (i = 0; i <= n; i++) {\n            matrix[i] = (int *) malloc((n+1) * sizeof(int));\n            if (NULL == matrix[i]) {\n                fprintf(stderr, \"malloc failed: out of memory\\n\");\n                exit(-1);\n            }\n        } \n\n        curNum = 1;\n        // \u9700\u8981\u8f6cn/2\u5708\n        for (i = 1; i <= n/2; i++) {\n            // \u987a\u5e8f\u586b\u5199\u7b2ccurRow\u884c\n            curRow = i;\n            for (curCol = i; curCol <= n-i; curCol++) {\n                matrix[curRow][curCol] = curNum++;\n            }\n\n            // \u987a\u5e8f\u586b\u5199\u7b2ccurCol\u5217\n            curCol = n + 1 - i;\n            for (curRow = i; curRow <= n-i; curRow++) {\n                matrix[curRow][curCol] = curNum++;\n            }\n\n            // \u9006\u5e8f\u586b\u5199\u7b2ccurRow\u884c\n            curRow = n + 1 - i;\n            for (curCol = n+1-i; curCol >= i+1; curCol--) {\n                matrix[curRow][curCol] = curNum++;\n            }\n\n            // \u9006\u5e8f\u586b\u5199\u7b2ccurCol\u5217\n            curCol = i;\n            for (curRow = n+1-i; curRow >= i+1; curRow--) {\n                matrix[curRow][curCol] = curNum++;\n            }\n        } // end for\n    \n        // \u5982\u679c\u65b9\u9635\u7684\u9636\u4e3a\u5947\u6570\uff0c\u586b\u5165\u4e2d\u5fc3\u6570\n        if (n % 2 == 1) {\n            matrix[n/2+1][n/2+1] = curNum; \n        }\n        \n        // \u6253\u5370\u87ba\u65cb\u6570\u7ec4\n        for (i = 1; i <= n; i++) {\n            for (j = 1; j <= n; j++) {\n                printf(\"%4d\", matrix[i][j]);\n            }\n            printf(\"\\n\");\n        }\n\n        // \u4e0d\u8981\u5fd8\u8bb0\u91ca\u653emalloc\u7684\u5185\u5b58\n        // \u5e76\u8bf7\u6ce8\u610f\u91ca\u653e\u65b9\u6cd5\n        for (i = 0; i <= n; i++) {\n            free(matrix[i]);\n        }\n        free(matrix);\n    }\n}", "path": "The-Art-Of-Programming-By-July-2nd/ebook/code/c/4.5\uff1a\u6253\u5370\u87ba\u65cb\u77e9\u9635.SpiralMatrix.c", "commit_date": "2014-03-24 00:00:00", "repo_name": "julycoding/The-Art-Of-Programming-By-July-2nd", "stars": 21190, "license": "None", "language": "c", "size": 27547}
{"docstring": "//\u66b4\u529b\u79fb\u4f4d\u6cd5\n", "func_signal": "void leftShift1(char * arr, int n)", "code": "{\n    size_t tmpLen = strlen(arr);\n    char tmpChar;\n    int i, j;\n    if (n >= 0)\n    {\n        for (i = 0; i < n; i++)\n        {\n            tmpChar = *arr;\n            for (j = 0; j < tmpLen - 1; j++)\n            {\n                *(arr + j) = *(arr + j + 1);\n            }\n            *(arr + tmpLen - 1) = tmpChar;\n        }\n    }\n    else\n    {\n        for (i = 0; i < -n; i++)\n        {\n            tmpChar = *(arr + tmpLen - 1);\n            for (j = tmpLen - 1; j > 0; j--)\n            {\n                *(arr + j) = *(arr + j - 1);\n            }\n            *arr = tmpChar;\n        }\n    }\n}", "path": "The-Art-Of-Programming-By-July-2nd/ebook/code/c/1.1\uff1a\u5de6\u65cb\u8f6c\u5b57\u7b26\u4e32.c", "commit_date": "2014-03-22 00:00:00", "repo_name": "julycoding/The-Art-Of-Programming-By-July-2nd", "stars": 21190, "license": "None", "language": "c", "size": 27547}
{"docstring": "//24.5\u3001\u4e0d\u91cd\u590dHash\u7f16\u7801\n//\u51fd\u6570prepareCryptTable\u4ee5\u4e0b\u7684\u51fd\u6570\u751f\u6210\u4e00\u4e2a\u957f\u5ea6\u4e3a0x500\uff08\u540810\u8fdb\u5236\u6570\uff1a1280\uff09\u7684cryptTable[0x500]  \n", "func_signal": "void prepareCryptTable()", "code": "{  \n\tunsigned long seed = 0x00100001, index1 = 0, index2 = 0, i;  \n\n\tfor( index1 = 0; index1 <0x100; index1++ )  \n\t{  \n\t\tfor( index2 = index1, i = 0; i < 5; i++, index2 += 0x100)  \n\t\t{  \n\t\t\tunsigned long temp1, temp2;  \n\t\t\tseed = (seed * 125 + 3) % 0x2AAAAB;  \n\t\t\ttemp1 = (seed & 0xFFFF)<<0x10;  \n\t\t\tseed = (seed * 125 + 3) % 0x2AAAAB;  \n\t\t\ttemp2 = (seed & 0xFFFF);  \n\t\t\tcryptTable[index2] = ( temp1 | temp2 );  \n\t\t}  \n\t}  \n}", "path": "The-Art-Of-Programming-By-July-2nd/ebook/code/c/7.3\uff1a\u5012\u6392\u7d22\u5f15\u5173\u952e\u8bcd\u4e0d\u91cd\u590dHash\u7f16\u7801.c", "commit_date": "2014-04-09 00:00:00", "repo_name": "julycoding/The-Art-Of-Programming-By-July-2nd", "stars": 21190, "license": "None", "language": "c", "size": 27547}
{"docstring": "//\u67e5\u627e\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\uff0c\u7b2c1\u4e2a\u7a0b\u5e8f\n//copyright@ Sorehead && July\n//July\u3001updated\uff0c2011.04.24.\n", "func_signal": "char find_first_unique_char(char *str)", "code": "{\n\tint data[256];\n\tchar *p;\n\n\tif (str == NULL)\n\t\treturn '\\0';\n\n\tmemset(data, 0, sizeof(data));    //\u6570\u7ec4\u5143\u7d20\u5148\u5168\u90e8\u521d\u59cb\u5316\u4e3a0\n\tp = str;\n\twhile (*p != '\\0')\n\t\tdata[(unsigned char)*p++]++;  //\u904d\u5386\u5b57\u7b26\u4e32\uff0c\u5728\u76f8\u5e94\u4f4d\u7f6e++\uff0c\uff08\u540c\u65f6\uff0c\u4e0b\u6807\u5f3a\u5236\u8f6c\u6362\uff09\n\n\twhile (*str != '\\0')\n\t{\n\t\tif (data[(unsigned char)*str] == 1)  //\u6700\u540e\uff0c\u8f93\u51fa\u90a3\u4e2a\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u6b21\u6570\u4e3a1\u7684\u5b57\u7b26\n\t\t\treturn *str;\n\n\t\tstr++;\n\t}\n\n\treturn '\\0';\n}", "path": "The-Art-Of-Programming-By-July-2nd/ebook/code/c/6.8\uff1a\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26.c", "commit_date": "2014-04-09 00:00:00", "repo_name": "julycoding/The-Art-Of-Programming-By-July-2nd", "stars": 21190, "license": "None", "language": "c", "size": 27547}
{"docstring": "//\u51fd\u6570HashString\u4ee5\u4e0b\u51fd\u6570\u8ba1\u7b97lpszFileName \u5b57\u7b26\u4e32\u7684hash\u503c\uff0c\u5176\u4e2ddwHashType \u4e3ahash\u7684\u7c7b\u578b\uff0c  \n", "func_signal": "unsigned long HashString(const char *lpszkeyName, unsigned long dwHashType )", "code": "{  \n\tunsigned char *key  = (unsigned char *)lpszkeyName;  \n\tunsigned long seed1 = 0x7FED7FED;  \n\tunsigned long seed2 = 0xEEEEEEEE;  \n\tint ch;  \n\n\twhile( *key != 0 )  \n\t{  \n\t\tch = *key++;  \n\t\tseed1 = cryptTable[(dwHashType<<8) + ch] ^ (seed1 + seed2);  \n\t\tseed2 = ch + seed1 + seed2 + (seed2<<5) + 3;  \n\t}  \n\treturn seed1;  \n}", "path": "The-Art-Of-Programming-By-July-2nd/ebook/code/c/7.3\uff1a\u5012\u6392\u7d22\u5f15\u5173\u952e\u8bcd\u4e0d\u91cd\u590dHash\u7f16\u7801.c", "commit_date": "2014-04-09 00:00:00", "repo_name": "julycoding/The-Art-Of-Programming-By-July-2nd", "stars": 21190, "license": "None", "language": "c", "size": 27547}
{"docstring": "/* As written, this function can only promote jemalloc_zone. */\n", "func_signal": "static void\nzone_promote(void)", "code": "{\n\tmalloc_zone_t *zone;\n\n\tdo {\n\t\t/*\n\t\t * Unregister and reregister the default zone.  On OSX >= 10.6,\n\t\t * unregistering takes the last registered zone and places it\n\t\t * at the location of the specified zone.  Unregistering the\n\t\t * default zone thus makes the last registered one the default.\n\t\t * On OSX < 10.6, unregistering shifts all registered zones.\n\t\t * The first registered zone then becomes the default.\n\t\t */\n\t\tmalloc_zone_unregister(default_zone);\n\t\tmalloc_zone_register(default_zone);\n\n\t\t/*\n\t\t * On OSX 10.6, having the default purgeable zone appear before\n\t\t * the default zone makes some things crash because it thinks it\n\t\t * owns the default zone allocated pointers.  We thus\n\t\t * unregister/re-register it in order to ensure it's always\n\t\t * after the default zone.  On OSX < 10.6, there is no purgeable\n\t\t * zone, so this does nothing.  On OSX >= 10.6, unregistering\n\t\t * replaces the purgeable zone with the last registered zone\n\t\t * above, i.e. the default zone.  Registering it again then puts\n\t\t * it at the end, obviously after the default zone.\n\t\t */\n\t\tif (purgeable_zone != NULL) {\n\t\t\tmalloc_zone_unregister(purgeable_zone);\n\t\t\tmalloc_zone_register(purgeable_zone);\n\t\t}\n\n\t\tzone = zone_default_get();\n\t} while (zone != &jemalloc_zone);\n}", "path": "jemalloc/src/zone.c", "commit_date": "2017-07-11 00:00:00", "repo_name": "jemalloc/jemalloc", "stars": 8925, "license": "other", "language": "c", "size": 12257}
{"docstring": "/* Generate a random integer in [0..limit). */\n", "func_signal": "uint64_t gen_rand64_range(sfmt_t *ctx, uint64_t limit)", "code": "{\n    uint64_t ret, above;\n\n    above = KQU(0xffffffffffffffff) - (KQU(0xffffffffffffffff) % limit);\n    while (1) {\n\tret = gen_rand64(ctx);\n\tif (ret < above) {\n\t    ret %= limit;\n\t    break;\n\t}\n    }\n    return ret;\n}", "path": "jemalloc/test/src/SFMT.c", "commit_date": "2017-04-24 00:00:00", "repo_name": "jemalloc/jemalloc", "stars": 8925, "license": "other", "language": "c", "size": 12257}
{"docstring": "/* Generate a random integer in [0..limit). */\n", "func_signal": "uint32_t gen_rand32_range(sfmt_t *ctx, uint32_t limit)", "code": "{\n    uint32_t ret, above;\n\n    above = 0xffffffffU - (0xffffffffU % limit);\n    while (1) {\n\tret = gen_rand32(ctx);\n\tif (ret < above) {\n\t    ret %= limit;\n\t    break;\n\t}\n    }\n    return ret;\n}", "path": "jemalloc/test/src/SFMT.c", "commit_date": "2017-04-24 00:00:00", "repo_name": "jemalloc/jemalloc", "stars": 8925, "license": "other", "language": "c", "size": 12257}
{"docstring": "/* Compute purge interval for background threads. */\n", "func_signal": "static uint64_t\narena_decay_compute_purge_interval(tsdn_t *tsdn, arena_t *arena)", "code": "{\n\tuint64_t i1, i2;\n\ti1 = arena_decay_compute_purge_interval_impl(tsdn,\n\t    &arena->pa_shard.pac.decay_dirty, &arena->pa_shard.pac.ecache_dirty);\n\tif (i1 == BACKGROUND_THREAD_MIN_INTERVAL_NS) {\n\t\treturn i1;\n\t}\n\ti2 = arena_decay_compute_purge_interval_impl(tsdn,\n\t    &arena->pa_shard.pac.decay_muzzy, &arena->pa_shard.pac.ecache_muzzy);\n\n\treturn i1 < i2 ? i1 : i2;\n}", "path": "jemalloc/src/background_thread.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "jemalloc/jemalloc", "stars": 8925, "license": "other", "language": "c", "size": 12257}
{"docstring": "/**\n * This function generates and returns 64-bit pseudorandom number.\n * init_gen_rand or init_by_array must be called before this function.\n * The function gen_rand64 should not be called after gen_rand32,\n * unless an initialization is again executed.\n * @return 64-bit pseudorandom number\n */\n", "func_signal": "uint64_t gen_rand64(sfmt_t *ctx)", "code": "{\n#if defined(BIG_ENDIAN64) && !defined(ONLY64)\n    uint32_t r1, r2;\n    uint32_t *psfmt32 = &ctx->sfmt[0].u[0];\n#else\n    uint64_t r;\n    uint64_t *psfmt64 = (uint64_t *)&ctx->sfmt[0].u[0];\n#endif\n\n    assert(ctx->initialized);\n    assert(ctx->idx % 2 == 0);\n\n    if (ctx->idx >= N32) {\n\tgen_rand_all(ctx);\n\tctx->idx = 0;\n    }\n#if defined(BIG_ENDIAN64) && !defined(ONLY64)\n    r1 = psfmt32[ctx->idx];\n    r2 = psfmt32[ctx->idx + 1];\n    ctx->idx += 2;\n    return ((uint64_t)r2 << 32) | r1;\n#else\n    r = psfmt64[ctx->idx / 2];\n    ctx->idx += 2;\n    return r;\n#endif\n}", "path": "jemalloc/test/src/SFMT.c", "commit_date": "2017-04-24 00:00:00", "repo_name": "jemalloc/jemalloc", "stars": 8925, "license": "other", "language": "c", "size": 12257}
{"docstring": "/*\n * On systems which can't merge extents, tests that call this function generate\n * a lot of dirty memory very quickly.  Purging between cycles mitigates\n * potential OOM on e.g. 32-bit Windows.\n */\n", "func_signal": "static void\npurge(void)", "code": "{\n\texpect_d_eq(mallctl(\"arena.0.purge\", NULL, NULL, NULL, 0), 0,\n\t    \"Unexpected mallctl error\");\n}", "path": "jemalloc/test/integration/aligned_alloc.c", "commit_date": "2020-02-20 00:00:00", "repo_name": "jemalloc/jemalloc", "stars": 8925, "license": "other", "language": "c", "size": 12257}
{"docstring": "/*\n * Sleep for approximately ns nanoseconds.  No lower *nor* upper bound on sleep\n * time is guaranteed.\n */\n", "func_signal": "void\nsleep_ns(unsigned ns)", "code": "{\n\tassert(ns <= 1000*1000*1000);\n\n#ifdef _WIN32\n\tSleep(ns / 1000 / 1000);\n#else\n\t{\n\t\tstruct timespec timeout;\n\n\t\tif (ns < 1000*1000*1000) {\n\t\t\ttimeout.tv_sec = 0;\n\t\t\ttimeout.tv_nsec = ns;\n\t\t} else {\n\t\t\ttimeout.tv_sec = 1;\n\t\t\ttimeout.tv_nsec = 0;\n\t\t}\n\t\tnanosleep(&timeout, NULL);\n\t}\n#endif\n}", "path": "jemalloc/test/src/sleep.c", "commit_date": "2020-01-22 00:00:00", "repo_name": "jemalloc/jemalloc", "stars": 8925, "license": "other", "language": "c", "size": 12257}
{"docstring": "/* defined(JEMALLOC_BACKGROUND_THREAD) */\n", "func_signal": "bool\nbackground_thread_boot0(void)", "code": "{\n\tif (!have_background_thread && opt_background_thread) {\n\t\tmalloc_printf(\"<jemalloc>: option background_thread currently \"\n\t\t    \"supports pthread only\\n\");\n\t\treturn true;\n\t}\n#ifdef JEMALLOC_PTHREAD_CREATE_WRAPPER\n\tif ((config_lazy_lock || opt_background_thread) &&\n\t    pthread_create_fptr_init()) {\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}", "path": "jemalloc/src/background_thread.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "jemalloc/jemalloc", "stars": 8925, "license": "other", "language": "c", "size": 12257}
{"docstring": "/**\n * This function initializes the internal state array with a 32-bit\n * integer seed.\n *\n * @param seed a 32-bit integer used as the seed.\n */\n", "func_signal": "sfmt_t *init_gen_rand(uint32_t seed)", "code": "{\n    void *p;\n    sfmt_t *ctx;\n    int i;\n    uint32_t *psfmt32;\n\n    if (posix_memalign(&p, sizeof(w128_t), sizeof(sfmt_t)) != 0) {\n\treturn NULL;\n    }\n    ctx = (sfmt_t *)p;\n    psfmt32 = &ctx->sfmt[0].u[0];\n\n    psfmt32[idxof(0)] = seed;\n    for (i = 1; i < N32; i++) {\n\tpsfmt32[idxof(i)] = 1812433253UL * (psfmt32[idxof(i - 1)]\n\t\t\t\t\t    ^ (psfmt32[idxof(i - 1)] >> 30))\n\t    + i;\n    }\n    ctx->idx = N32;\n    period_certification(ctx);\n    ctx->initialized = 1;\n\n    return ctx;\n}", "path": "jemalloc/test/src/SFMT.c", "commit_date": "2017-04-24 00:00:00", "repo_name": "jemalloc/jemalloc", "stars": 8925, "license": "other", "language": "c", "size": 12257}
{"docstring": "/*\n * GCC \"-Walloc-size-larger-than\" warning detects when one of the memory\n * allocation functions is called with a size larger than the maximum size that\n * they support. Here we want to explicitly test that the allocation functions\n * do indeed fail properly when this is the case, which triggers the warning.\n * Therefore we disable the warning for these tests.\n */\n", "func_signal": "JEMALLOC_DIAGNOSTIC_PUSH\nJEMALLOC_DIAGNOSTIC_IGNORE_ALLOC_SIZE_LARGER_THAN\n\nTEST_BEGIN(test_oom_errors)", "code": "{\n\tsize_t alignment, size;\n\tvoid *p;\n\n#if LG_SIZEOF_PTR == 3\n\talignment = UINT64_C(0x8000000000000000);\n\tsize      = UINT64_C(0x8000000000000000);\n#else\n\talignment = 0x80000000LU;\n\tsize      = 0x80000000LU;\n#endif\n\tset_errno(0);\n\tp = aligned_alloc(alignment, size);\n\texpect_false(p != NULL || get_errno() != ENOMEM,\n\t    \"Expected error for aligned_alloc(%zu, %zu)\",\n\t    alignment, size);\n\n#if LG_SIZEOF_PTR == 3\n\talignment = UINT64_C(0x4000000000000000);\n\tsize      = UINT64_C(0xc000000000000001);\n#else\n\talignment = 0x40000000LU;\n\tsize      = 0xc0000001LU;\n#endif\n\tset_errno(0);\n\tp = aligned_alloc(alignment, size);\n\texpect_false(p != NULL || get_errno() != ENOMEM,\n\t    \"Expected error for aligned_alloc(%zu, %zu)\",\n\t    alignment, size);\n\n\talignment = 0x10LU;\n#if LG_SIZEOF_PTR == 3\n\tsize = UINT64_C(0xfffffffffffffff0);\n#else\n\tsize = 0xfffffff0LU;\n#endif\n\tset_errno(0);\n\tp = aligned_alloc(alignment, size);\n\texpect_false(p != NULL || get_errno() != ENOMEM,\n\t    \"Expected error for aligned_alloc(&p, %zu, %zu)\",\n\t    alignment, size);\n}", "path": "jemalloc/test/integration/aligned_alloc.c", "commit_date": "2020-02-20 00:00:00", "repo_name": "jemalloc/jemalloc", "stars": 8925, "license": "other", "language": "c", "size": 12257}
{"docstring": "/*\n * We want to support a degree of user reentrancy.  This tests a variety of\n * allocation scenarios.\n */\n", "func_signal": "static void\nbe_reentrant()", "code": "{\n\t/* Let's make sure the tcache is non-empty if enabled. */\n\talloc_free_size(1);\n\talloc_free_size(1024);\n\talloc_free_size(64 * 1024);\n\talloc_free_size(256 * 1024);\n\talloc_free_size(1024 * 1024);\n\n\t/* Some reallocation. */\n\tvoid *ptr = mallocx(129, 0);\n\tptr = rallocx(ptr, 130, 0);\n\tfree(ptr);\n\n\tptr = mallocx(2 * 1024 * 1024, 0);\n\tfree(ptr);\n\tptr = mallocx(1 * 1024 * 1024, 0);\n\tptr = rallocx(ptr, 2 * 1024 * 1024, 0);\n\tfree(ptr);\n\n\tptr = mallocx(1, 0);\n\tptr = rallocx(ptr, 1000, 0);\n\tfree(ptr);\n}", "path": "jemalloc/test/unit/hook.c", "commit_date": "2020-02-20 00:00:00", "repo_name": "jemalloc/jemalloc", "stars": 8925, "license": "other", "language": "c", "size": 12257}
{"docstring": "/* Note that this test relies on the unusual slab sizes set in slab_sizes.sh. */\n", "func_signal": "TEST_BEGIN(test_slab_sizes)", "code": "{\n\tunsigned nbins;\n\tsize_t page;\n\tsize_t sizemib[4];\n\tsize_t slabmib[4];\n\tsize_t len;\n\n\tlen = sizeof(nbins);\n\texpect_d_eq(mallctl(\"arenas.nbins\", &nbins, &len, NULL, 0), 0,\n\t    \"nbins mallctl failure\");\n\n\tlen = sizeof(page);\n\texpect_d_eq(mallctl(\"arenas.page\", &page, &len, NULL, 0), 0,\n\t    \"page mallctl failure\");\n\n\tlen = 4;\n\texpect_d_eq(mallctlnametomib(\"arenas.bin.0.size\", sizemib, &len), 0,\n\t    \"bin size mallctlnametomib failure\");\n\n\tlen = 4;\n\texpect_d_eq(mallctlnametomib(\"arenas.bin.0.slab_size\", slabmib, &len),\n\t    0, \"slab size mallctlnametomib failure\");\n\n\tsize_t biggest_slab_seen = 0;\n\n\tfor (unsigned i = 0; i < nbins; i++) {\n\t\tsize_t bin_size;\n\t\tsize_t slab_size;\n\t\tlen = sizeof(size_t);\n\t\tsizemib[2] = i;\n\t\tslabmib[2] = i;\n\t\texpect_d_eq(mallctlbymib(sizemib, 4, (void *)&bin_size, &len,\n\t\t    NULL, 0), 0, \"bin size mallctlbymib failure\");\n\n\t\tlen = sizeof(size_t);\n\t\texpect_d_eq(mallctlbymib(slabmib, 4, (void *)&slab_size, &len,\n\t\t    NULL, 0), 0, \"slab size mallctlbymib failure\");\n\n\t\tif (bin_size < 100) {\n\t\t\t/*\n\t\t\t * Then we should be as close to 17 as possible.  Since\n\t\t\t * not all page sizes are valid (because of bitmap\n\t\t\t * limitations on the number of items in a slab), we\n\t\t\t * should at least make sure that the number of pages\n\t\t\t * goes up.\n\t\t\t */\n\t\t\texpect_zu_ge(slab_size, biggest_slab_seen,\n\t\t\t    \"Slab sizes should go up\");\n\t\t\tbiggest_slab_seen = slab_size;\n\t\t} else if (\n\t\t    (100 <= bin_size && bin_size < 128)\n\t\t    || (128 < bin_size && bin_size <= 200)) {\n\t\t\texpect_zu_eq(slab_size, page,\n\t\t\t    \"Forced-small slabs should be small\");\n\t\t} else if (bin_size == 128) {\n\t\t\texpect_zu_eq(slab_size, 2 * page,\n\t\t\t    \"Forced-2-page slab should be 2 pages\");\n\t\t} else if (200 < bin_size && bin_size <= 4096) {\n\t\t\texpect_zu_ge(slab_size, biggest_slab_seen,\n\t\t\t    \"Slab sizes should go up\");\n\t\t\tbiggest_slab_seen = slab_size;\n\t\t}\n\t}\n\t/*\n\t * For any reasonable configuration, 17 pages should be a valid slab\n\t * size for 4096-byte items.\n\t */\n\texpect_zu_eq(biggest_slab_seen, 17 * page, \"Didn't hit page target\");\n}", "path": "jemalloc/test/integration/slab_sizes.c", "commit_date": "2020-02-20 00:00:00", "repo_name": "jemalloc/jemalloc", "stars": 8925, "license": "other", "language": "c", "size": 12257}
{"docstring": "/* Re-enable the \"-Walloc-size-larger-than=\" warning */\n", "func_signal": "JEMALLOC_DIAGNOSTIC_POP\n\nTEST_BEGIN(test_alignment_and_size)", "code": "{\n#define NITER 4\n\tsize_t alignment, size, total;\n\tunsigned i;\n\tvoid *ps[NITER];\n\n\tfor (i = 0; i < NITER; i++) {\n\t\tps[i] = NULL;\n\t}\n\n\tfor (alignment = 8;\n\t    alignment <= MAXALIGN;\n\t    alignment <<= 1) {\n\t\ttotal = 0;\n\t\tfor (size = 1;\n\t\t    size < 3 * alignment && size < (1U << 31);\n\t\t    size += (alignment >> (LG_SIZEOF_PTR-1)) - 1) {\n\t\t\tfor (i = 0; i < NITER; i++) {\n\t\t\t\tps[i] = aligned_alloc(alignment, size);\n\t\t\t\tif (ps[i] == NULL) {\n\t\t\t\t\tchar buf[BUFERROR_BUF];\n\n\t\t\t\t\tbuferror(get_errno(), buf, sizeof(buf));\n\t\t\t\t\ttest_fail(\n\t\t\t\t\t    \"Error for alignment=%zu, \"\n\t\t\t\t\t    \"size=%zu (%#zx): %s\",\n\t\t\t\t\t    alignment, size, size, buf);\n\t\t\t\t}\n\t\t\t\ttotal += malloc_usable_size(ps[i]);\n\t\t\t\tif (total >= (MAXALIGN << 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < NITER; i++) {\n\t\t\t\tif (ps[i] != NULL) {\n\t\t\t\t\tfree(ps[i]);\n\t\t\t\t\tps[i] = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpurge();\n\t}\n#undef NITER\n}", "path": "jemalloc/test/integration/aligned_alloc.c", "commit_date": "2020-02-20 00:00:00", "repo_name": "jemalloc/jemalloc", "stars": 8925, "license": "other", "language": "c", "size": 12257}
{"docstring": "/* Create a new background thread if needed. */\n", "func_signal": "bool\nbackground_thread_create(tsd_t *tsd, unsigned arena_ind)", "code": "{\n\tassert(have_background_thread);\n\n\tbool ret;\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &background_thread_lock);\n\tret = background_thread_create_locked(tsd, arena_ind);\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &background_thread_lock);\n\n\treturn ret;\n}", "path": "jemalloc/src/background_thread.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "jemalloc/jemalloc", "stars": 8925, "license": "other", "language": "c", "size": 12257}
{"docstring": "/*\n * This file is logically part of the PA module.  While pa.c contains the core\n * allocator functionality, this file contains boring integration functionality;\n * things like the pre- and post- fork handlers, and stats merging for CTL\n * refreshes.\n */\n", "func_signal": "void\npa_shard_prefork0(tsdn_t *tsdn, pa_shard_t *shard)", "code": "{\n\tmalloc_mutex_prefork(tsdn, &shard->pac.decay_dirty.mtx);\n\tmalloc_mutex_prefork(tsdn, &shard->pac.decay_muzzy.mtx);\n}", "path": "jemalloc/src/pa_extra.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "jemalloc/jemalloc", "stars": 8925, "license": "other", "language": "c", "size": 12257}
{"docstring": "/**\n * This function generates and returns 32-bit pseudorandom number.\n * init_gen_rand or init_by_array must be called before this function.\n * @return 32-bit pseudorandom number\n */\n", "func_signal": "uint32_t gen_rand32(sfmt_t *ctx)", "code": "{\n    uint32_t r;\n    uint32_t *psfmt32 = &ctx->sfmt[0].u[0];\n\n    assert(ctx->initialized);\n    if (ctx->idx >= N32) {\n\tgen_rand_all(ctx);\n\tctx->idx = 0;\n    }\n    r = psfmt32[ctx->idx++];\n    return r;\n}", "path": "jemalloc/test/src/SFMT.c", "commit_date": "2017-04-24 00:00:00", "repo_name": "jemalloc/jemalloc", "stars": 8925, "license": "other", "language": "c", "size": 12257}
{"docstring": "/**\n * This function initializes the internal state array,\n * with an array of 32-bit integers used as the seeds\n * @param init_key the array of 32-bit integers, used as a seed.\n * @param key_length the length of init_key.\n */\n", "func_signal": "sfmt_t *init_by_array(uint32_t *init_key, int key_length)", "code": "{\n    void *p;\n    sfmt_t *ctx;\n    int i, j, count;\n    uint32_t r;\n    int lag;\n    int mid;\n    int size = N * 4;\n    uint32_t *psfmt32;\n\n    if (posix_memalign(&p, sizeof(w128_t), sizeof(sfmt_t)) != 0) {\n\treturn NULL;\n    }\n    ctx = (sfmt_t *)p;\n    psfmt32 = &ctx->sfmt[0].u[0];\n\n    if (size >= 623) {\n\tlag = 11;\n    } else if (size >= 68) {\n\tlag = 7;\n    } else if (size >= 39) {\n\tlag = 5;\n    } else {\n\tlag = 3;\n    }\n    mid = (size - lag) / 2;\n\n    memset(ctx->sfmt, 0x8b, sizeof(ctx->sfmt));\n    if (key_length + 1 > N32) {\n\tcount = key_length + 1;\n    } else {\n\tcount = N32;\n    }\n    r = func1(psfmt32[idxof(0)] ^ psfmt32[idxof(mid)]\n\t      ^ psfmt32[idxof(N32 - 1)]);\n    psfmt32[idxof(mid)] += r;\n    r += key_length;\n    psfmt32[idxof(mid + lag)] += r;\n    psfmt32[idxof(0)] = r;\n\n    count--;\n    for (i = 1, j = 0; (j < count) && (j < key_length); j++) {\n\tr = func1(psfmt32[idxof(i)] ^ psfmt32[idxof((i + mid) % N32)]\n\t\t  ^ psfmt32[idxof((i + N32 - 1) % N32)]);\n\tpsfmt32[idxof((i + mid) % N32)] += r;\n\tr += init_key[j] + i;\n\tpsfmt32[idxof((i + mid + lag) % N32)] += r;\n\tpsfmt32[idxof(i)] = r;\n\ti = (i + 1) % N32;\n    }\n    for (; j < count; j++) {\n\tr = func1(psfmt32[idxof(i)] ^ psfmt32[idxof((i + mid) % N32)]\n\t\t  ^ psfmt32[idxof((i + N32 - 1) % N32)]);\n\tpsfmt32[idxof((i + mid) % N32)] += r;\n\tr += i;\n\tpsfmt32[idxof((i + mid + lag) % N32)] += r;\n\tpsfmt32[idxof(i)] = r;\n\ti = (i + 1) % N32;\n    }\n    for (j = 0; j < N32; j++) {\n\tr = func2(psfmt32[idxof(i)] + psfmt32[idxof((i + mid) % N32)]\n\t\t  + psfmt32[idxof((i + N32 - 1) % N32)]);\n\tpsfmt32[idxof((i + mid) % N32)] ^= r;\n\tr -= i;\n\tpsfmt32[idxof((i + mid + lag) % N32)] ^= r;\n\tpsfmt32[idxof(i)] = r;\n\ti = (i + 1) % N32;\n    }\n\n    ctx->idx = N32;\n    period_certification(ctx);\n    ctx->initialized = 1;\n\n    return ctx;\n}", "path": "jemalloc/test/src/SFMT.c", "commit_date": "2017-04-24 00:00:00", "repo_name": "jemalloc/jemalloc", "stars": 8925, "license": "other", "language": "c", "size": 12257}
{"docstring": "/* Check if we need to signal the background thread early. */\n", "func_signal": "void\nbackground_thread_interval_check(tsdn_t *tsdn, arena_t *arena, decay_t *decay,\n    size_t npages_new)", "code": "{\n\tbackground_thread_info_t *info = arena_background_thread_info_get(\n\t    arena);\n\tif (malloc_mutex_trylock(tsdn, &info->mtx)) {\n\t\t/*\n\t\t * Background thread may hold the mutex for a long period of\n\t\t * time.  We'd like to avoid the variance on application\n\t\t * threads.  So keep this non-blocking, and leave the work to a\n\t\t * future epoch.\n\t\t */\n\t\treturn;\n\t}\n\n\tif (info->state != background_thread_started) {\n\t\tgoto label_done;\n\t}\n\tif (malloc_mutex_trylock(tsdn, &decay->mtx)) {\n\t\tgoto label_done;\n\t}\n\n\tssize_t decay_time = decay_ms_read(decay);\n\tif (decay_time <= 0) {\n\t\t/* Purging is eagerly done or disabled currently. */\n\t\tgoto label_done_unlock2;\n\t}\n\tuint64_t decay_interval_ns = decay_epoch_duration_ns(decay);\n\tassert(decay_interval_ns > 0);\n\n\tnstime_t diff;\n\tnstime_init(&diff, background_thread_wakeup_time_get(info));\n\tif (nstime_compare(&diff, &decay->epoch) <= 0) {\n\t\tgoto label_done_unlock2;\n\t}\n\tnstime_subtract(&diff, &decay->epoch);\n\tif (nstime_ns(&diff) < BACKGROUND_THREAD_MIN_INTERVAL_NS) {\n\t\tgoto label_done_unlock2;\n\t}\n\n\tif (npages_new > 0) {\n\t\tsize_t n_epoch = (size_t)(nstime_ns(&diff) / decay_interval_ns);\n\t\t/*\n\t\t * Compute how many new pages we would need to purge by the next\n\t\t * wakeup, which is used to determine if we should signal the\n\t\t * background thread.\n\t\t */\n\t\tuint64_t npurge_new;\n\t\tif (n_epoch >= SMOOTHSTEP_NSTEPS) {\n\t\t\tnpurge_new = npages_new;\n\t\t} else {\n\t\t\tuint64_t h_steps_max = h_steps[SMOOTHSTEP_NSTEPS - 1];\n\t\t\tassert(h_steps_max >=\n\t\t\t    h_steps[SMOOTHSTEP_NSTEPS - 1 - n_epoch]);\n\t\t\tnpurge_new = npages_new * (h_steps_max -\n\t\t\t    h_steps[SMOOTHSTEP_NSTEPS - 1 - n_epoch]);\n\t\t\tnpurge_new >>= SMOOTHSTEP_BFP;\n\t\t}\n\t\tinfo->npages_to_purge_new += npurge_new;\n\t}\n\n\tbool should_signal;\n\tif (info->npages_to_purge_new > BACKGROUND_THREAD_NPAGES_THRESHOLD) {\n\t\tshould_signal = true;\n\t} else if (unlikely(background_thread_indefinite_sleep(info)) &&\n\t    (ecache_npages_get(&arena->pa_shard.pac.ecache_dirty) > 0 ||\n\t    ecache_npages_get(&arena->pa_shard.pac.ecache_muzzy) > 0 ||\n\t    info->npages_to_purge_new > 0)) {\n\t\tshould_signal = true;\n\t} else {\n\t\tshould_signal = false;\n\t}\n\n\tif (should_signal) {\n\t\tinfo->npages_to_purge_new = 0;\n\t\tpthread_cond_signal(&info->cond);\n\t}\nlabel_done_unlock2:\n\tmalloc_mutex_unlock(tsdn, &decay->mtx);\nlabel_done:\n\tmalloc_mutex_unlock(tsdn, &info->mtx);\n}", "path": "jemalloc/src/background_thread.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "jemalloc/jemalloc", "stars": 8925, "license": "other", "language": "c", "size": 12257}
{"docstring": "/*\n * When lazy lock is enabled, we need to make sure setting isthreaded before\n * taking any background_thread locks.  This is called early in ctl (instead of\n * wait for the pthread_create calls to trigger) because the mutex is required\n * before creating background threads.\n */\n", "func_signal": "void\nbackground_thread_ctl_init(tsdn_t *tsdn)", "code": "{\n\tmalloc_mutex_assert_not_owner(tsdn, &background_thread_lock);\n#ifdef JEMALLOC_PTHREAD_CREATE_WRAPPER\n\tpthread_create_fptr_init();\n\tpthread_create_wrapper_init();\n#endif\n}", "path": "jemalloc/src/background_thread.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "jemalloc/jemalloc", "stars": 8925, "license": "other", "language": "c", "size": 12257}
{"docstring": "/**\n * This function fills the internal state array with pseudorandom\n * integers.\n */\n", "func_signal": "static inline void gen_rand_all(sfmt_t *ctx)", "code": "{\n    int i;\n    w128_t *r1, *r2;\n\n    r1 = &ctx->sfmt[N - 2];\n    r2 = &ctx->sfmt[N - 1];\n    for (i = 0; i < N - POS1; i++) {\n\tdo_recursion(&ctx->sfmt[i], &ctx->sfmt[i], &ctx->sfmt[i + POS1], r1,\n\t  r2);\n\tr1 = r2;\n\tr2 = &ctx->sfmt[i];\n    }\n    for (; i < N; i++) {\n\tdo_recursion(&ctx->sfmt[i], &ctx->sfmt[i], &ctx->sfmt[i + POS1 - N], r1,\n\t  r2);\n\tr1 = r2;\n\tr2 = &ctx->sfmt[i];\n    }\n}", "path": "jemalloc/test/src/SFMT.c", "commit_date": "2017-04-24 00:00:00", "repo_name": "jemalloc/jemalloc", "stars": 8925, "license": "other", "language": "c", "size": 12257}
{"docstring": "/* safe_fwrite() :\n * performs fwrite(), ensure operation success, or immediately exit() */\n", "func_signal": "static void safe_fwrite(void* buf, size_t eltSize, size_t nbElt, FILE* f)", "code": "{\n    size_t const writtenSize = fwrite(buf, eltSize, nbElt, f);\n    size_t const expectedSize = eltSize * nbElt;\n    if (nbElt>0) assert(expectedSize / nbElt == eltSize);  /* check overflow */\n    if (writtenSize < expectedSize) {\n        if (ferror(f))  /* note : ferror() must follow fwrite */\n            fprintf(stderr, \"Write failed \\n\");\n        else\n            fprintf(stderr, \"Write too short \\n\");\n        exit(1);\n    }\n}", "path": "lz4/examples/frameCompress.c", "commit_date": "2019-08-21 00:00:00", "repo_name": "lz4/lz4", "stars": 9059, "license": "other", "language": "c", "size": 7221}
{"docstring": "/*! BMK_loadFiles() :\n    Loads `buffer` with content of files listed within `fileNamesTable`.\n    At most, fills `buffer` entirely */\n", "func_signal": "static void BMK_loadFiles(void* buffer, size_t bufferSize,\n                          size_t* fileSizes,\n                          const char** fileNamesTable, unsigned nbFiles)", "code": "{\n    size_t pos = 0, totalSize = 0;\n    unsigned n;\n    for (n=0; n<nbFiles; n++) {\n        FILE* f;\n        U64 fileSize = UTIL_getFileSize(fileNamesTable[n]);\n        if (UTIL_isDirectory(fileNamesTable[n])) {\n            DISPLAYLEVEL(2, \"Ignoring %s directory...       \\n\", fileNamesTable[n]);\n            fileSizes[n] = 0;\n            continue;\n        }\n        f = fopen(fileNamesTable[n], \"rb\");\n        if (f==NULL) EXM_THROW(10, \"impossible to open file %s\", fileNamesTable[n]);\n        DISPLAYUPDATE(2, \"Loading %s...       \\r\", fileNamesTable[n]);\n        if (fileSize > bufferSize-pos) { /* buffer too small - stop after this file */\n            fileSize = bufferSize-pos;\n            nbFiles=n;\n        }\n        { size_t const readSize = fread(((char*)buffer)+pos, 1, (size_t)fileSize, f);\n          if (readSize != (size_t)fileSize) EXM_THROW(11, \"could not read %s\", fileNamesTable[n]);\n          pos += readSize; }\n        fileSizes[n] = (size_t)fileSize;\n        totalSize += (size_t)fileSize;\n        fclose(f);\n    }\n\n    if (totalSize == 0) EXM_THROW(12, \"no data to bench\");\n}", "path": "lz4/programs/bench.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "lz4/lz4", "stars": 9059, "license": "other", "language": "c", "size": 7221}
{"docstring": "/* decompression functions */\n", "func_signal": "static int local_LZ4_decompress_fast(const char* in, char* out, int inSize, int outSize)", "code": "{\n    (void)inSize;\n    LZ4_decompress_fast(in, out, outSize);\n    return outSize;\n}", "path": "lz4/tests/fullbench.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "lz4/lz4", "stars": 9059, "license": "other", "language": "c", "size": 7221}
{"docstring": "/* @result : 1==error, 0==success */\n", "func_signal": "static int decompress_file(FILE* f_in, FILE* f_out)", "code": "{\n    assert(f_in != NULL); assert(f_out != NULL);\n\n    /* Ressource allocation */\n    void* const src = malloc(IN_CHUNK_SIZE);\n    if (!src) { perror(\"decompress_file(src)\"); return 1; }\n\n    LZ4F_dctx* dctx;\n    {   size_t const dctxStatus = LZ4F_createDecompressionContext(&dctx, LZ4F_VERSION);\n        if (LZ4F_isError(dctxStatus)) {\n            printf(\"LZ4F_dctx creation error: %s\\n\", LZ4F_getErrorName(dctxStatus));\n    }   }\n\n    int const result = !dctx ? 1 /* error */ :\n                       decompress_file_allocDst(f_in, f_out, dctx, src, IN_CHUNK_SIZE);\n\n    free(src);\n    LZ4F_freeDecompressionContext(dctx);   /* note : free works on NULL */\n    return result;\n}", "path": "lz4/examples/frameCompress.c", "commit_date": "2019-08-21 00:00:00", "repo_name": "lz4/lz4", "stars": 9059, "license": "other", "language": "c", "size": 7221}
{"docstring": "/* is expected to be triggered on linux+gcc */\n", "func_signal": "static void* FUZ_createLowAddr(size_t size)", "code": "{\n    void* const lowBuff = mmap((void*)(0x1000), size,\n                    PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS,\n                    -1, 0);\n    DISPLAYLEVEL(2, \"generating low buffer at address %p \\n\", lowBuff);\n    return lowBuff;\n}", "path": "lz4/tests/fuzzer.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "lz4/lz4", "stars": 9059, "license": "other", "language": "c", "size": 7221}
{"docstring": "/*! readU32FromChar() :\n * @return : unsigned integer value read from input in `char` format\n *  allows and interprets K, KB, KiB, M, MB and MiB suffix.\n *  Will also modify `*stringPtr`, advancing it to position where it stopped reading.\n *  Note : function result can overflow if digit string > MAX_UINT */\n", "func_signal": "static unsigned readU32FromChar(const char** stringPtr)", "code": "{\n    unsigned result = 0;\n    while ((**stringPtr >='0') && (**stringPtr <='9')) {\n        result *= 10;\n        result += (unsigned)(**stringPtr - '0');\n        (*stringPtr)++ ;\n    }\n    if ((**stringPtr=='K') || (**stringPtr=='M')) {\n        result <<= 10;\n        if (**stringPtr=='M') result <<= 10;\n        (*stringPtr)++ ;\n        if (**stringPtr=='i') (*stringPtr)++;\n        if (**stringPtr=='B') (*stringPtr)++;\n    }\n    return result;\n}", "path": "lz4/programs/lz4cli.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "lz4/lz4", "stars": 9059, "license": "other", "language": "c", "size": 7221}
{"docstring": "/* frame functions */\n", "func_signal": "static int local_LZ4F_compressFrame(const char* in, char* out, int inSize)", "code": "{\n    assert(inSize >= 0);\n    return (int)LZ4F_compressFrame(out, LZ4F_compressFrameBound((size_t)inSize, NULL), in, (size_t)inSize, NULL);\n}", "path": "lz4/tests/fullbench.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "lz4/lz4", "stars": 9059, "license": "other", "language": "c", "size": 7221}
{"docstring": "/* ================================================= */\n/*     Streaming decompression example               */\n/* ================================================= */\n", "func_signal": "static size_t get_block_size(const LZ4F_frameInfo_t* info)", "code": "{\n    switch (info->blockSizeID) {\n        case LZ4F_default:\n        case LZ4F_max64KB:  return 1 << 16;\n        case LZ4F_max256KB: return 1 << 18;\n        case LZ4F_max1MB:   return 1 << 20;\n        case LZ4F_max4MB:   return 1 << 22;\n        default:\n            printf(\"Impossible with expected frame specification (<=v1.6.1)\\n\");\n            exit(1);\n    }\n}", "path": "lz4/examples/frameCompress.c", "commit_date": "2019-08-21 00:00:00", "repo_name": "lz4/lz4", "stars": 9059, "license": "other", "language": "c", "size": 7221}
{"docstring": "/* always provide input by block of 64 KB */\n", "func_signal": "static int local_LZ4F_decompress_noHint(const char* src, char* dst, int srcSize, int dstSize)", "code": "{\n    size_t totalInSize = (size_t)srcSize;\n    size_t maxOutSize = (size_t)dstSize;\n\n    size_t inPos = 0;\n    size_t inSize = 64 KB;\n    size_t outPos = 0;\n    size_t outRemaining = maxOutSize - outPos;\n\n    for (;;) {\n        size_t const sizeHint = LZ4F_decompress(g_dCtx, dst+outPos, &outRemaining, src+inPos, &inSize, NULL);\n        assert(!LZ4F_isError(sizeHint));\n\n        inPos += inSize;\n        inSize = (inPos + 64 KB <= totalInSize) ? 64 KB : totalInSize - inPos;\n\n        outPos += outRemaining;\n        outRemaining = maxOutSize - outPos;\n\n        if (!sizeHint) break;\n    }\n\n    /* frame completed */\n    if (inPos != totalInSize) {\n        DISPLAY(\"Error decompressing frame : must read (%u) full frame (%u) \\n\",\n                (unsigned)inPos, (unsigned)totalInSize);\n        exit(10);\n    }\n    return (int)outPos;\n\n}", "path": "lz4/tests/fullbench.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "lz4/lz4", "stars": 9059, "license": "other", "language": "c", "size": 7221}
{"docstring": "/**\n * Main procedure for standalone fuzzing engine.\n *\n * Reads filenames from the argument array. For each filename, read the file\n * into memory and then call the fuzzing interface with the data.\n */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n  int ii;\n  for(ii = 1; ii < argc; ii++)\n  {\n    FILE *infile;\n    printf(\"[%s] \", argv[ii]);\n\n    /* Try and open the file. */\n    infile = fopen(argv[ii], \"rb\");\n    if(infile)\n    {\n      uint8_t *buffer = NULL;\n      size_t buffer_len;\n\n      printf(\"Opened.. \");\n\n      /* Get the length of the file. */\n      fseek(infile, 0L, SEEK_END);\n      buffer_len = ftell(infile);\n\n      /* Reset the file indicator to the beginning of the file. */\n      fseek(infile, 0L, SEEK_SET);\n\n      /* Allocate a buffer for the file contents. */\n      buffer = (uint8_t *)calloc(buffer_len, sizeof(uint8_t));\n      if(buffer)\n      {\n        /* Read all the text from the file into the buffer. */\n        fread(buffer, sizeof(uint8_t), buffer_len, infile);\n        printf(\"Read %zu bytes, fuzzing.. \", buffer_len);\n\n        /* Call the fuzzer with the data. */\n        LLVMFuzzerTestOneInput(buffer, buffer_len);\n\n        printf(\"complete !!\");\n\n        /* Free the buffer as it's no longer needed. */\n        free(buffer);\n        buffer = NULL;\n      }\n      else\n      {\n        fprintf(stderr,\n                \"[%s] Failed to allocate %zu bytes \\n\",\n                argv[ii],\n                buffer_len);\n      }\n\n      /* Close the file as it's no longer needed. */\n      fclose(infile);\n      infile = NULL;\n    }\n    else\n    {\n      /* Failed to open the file. Maybe wrong name or wrong permissions? */\n      fprintf(stderr, \"[%s] Open failed. \\n\", argv[ii]);\n    }\n\n    printf(\"\\n\");\n  }\n}", "path": "lz4/ossfuzz/standaloneengine.c", "commit_date": "2019-07-15 00:00:00", "repo_name": "lz4/lz4", "stars": 9059, "license": "other", "language": "c", "size": 7221}
{"docstring": "/*! FUZ_findDiff() :\n*   find the first different byte between buff1 and buff2.\n*   presumes buff1 != buff2.\n*   presumes a difference exists before end of either buffer.\n*   Typically invoked after a checksum mismatch.\n*/\n", "func_signal": "static void FUZ_findDiff(const void* buff1, const void* buff2)", "code": "{\n    const BYTE* const b1 = (const BYTE*)buff1;\n    const BYTE* const b2 = (const BYTE*)buff2;\n    size_t u = 0;\n    while (b1[u]==b2[u]) u++;\n    DISPLAY(\"\\nWrong Byte at position %u \\n\", (unsigned)u);\n}", "path": "lz4/tests/fuzzer.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "lz4/lz4", "stars": 9059, "license": "other", "language": "c", "size": 7221}
{"docstring": "/*********************************************************\n*  Memory management, to test LZ4_USER_MEMORY_FUNCTIONS\n*********************************************************/\n", "func_signal": "void* LZ4_malloc(size_t s)", "code": "{ return malloc(s); }\nvoid* LZ4_calloc(size_t n, size_t s) { return calloc(n,s); }\nvoid  LZ4_free(void* p) { free(p); }\n\n\n/*********************************************************\n*  Benchmark function\n*********************************************************/\nstatic LZ4_stream_t LZ4_stream;\nstatic void local_LZ4_resetDictT(void)\n{\n    void* const r = LZ4_initStream(&LZ4_stream, sizeof(LZ4_stream));\n    assert(r != NULL); (void)r;\n}", "path": "lz4/tests/fullbench.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "lz4/lz4", "stars": 9059, "license": "other", "language": "c", "size": 7221}
{"docstring": "/*====== Canonical representation   ======*/\n", "func_signal": "XXH_PUBLIC_API void XXH64_canonicalFromHash(XXH64_canonical_t* dst, XXH64_hash_t hash)", "code": "{\n    XXH_STATIC_ASSERT(sizeof(XXH64_canonical_t) == sizeof(XXH64_hash_t));\n    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap64(hash);\n    memcpy(dst, &hash, sizeof(*dst));\n}", "path": "lz4/lib/xxhash.c", "commit_date": "2018-09-18 00:00:00", "repo_name": "lz4/lz4", "stars": 9059, "license": "other", "language": "c", "size": 7221}
{"docstring": "/** longCommandWArg() :\n *  check if *stringPtr is the same as longCommand.\n *  If yes, @return 1 and advances *stringPtr to the position which immediately follows longCommand.\n * @return 0 and doesn't modify *stringPtr otherwise.\n */\n", "func_signal": "static int longCommandWArg(const char** stringPtr, const char* longCommand)", "code": "{\n    size_t const comSize = strlen(longCommand);\n    int const result = !strncmp(*stringPtr, longCommand, comSize);\n    if (result) *stringPtr += comSize;\n    return result;\n}", "path": "lz4/programs/lz4cli.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "lz4/lz4", "stars": 9059, "license": "other", "language": "c", "size": 7221}
{"docstring": "/*-***************************\n*  Functions\n*****************************/\n", "func_signal": "static int usage(const char* exeName)", "code": "{\n    DISPLAY( \"Usage : \\n\");\n    DISPLAY( \"      %s [arg] [input] [output] \\n\", exeName);\n    DISPLAY( \"\\n\");\n    DISPLAY( \"input   : a filename \\n\");\n    DISPLAY( \"          with no FILE, or when FILE is - or %s, read standard input\\n\", stdinmark);\n    DISPLAY( \"Arguments : \\n\");\n    DISPLAY( \" -1     : Fast compression (default) \\n\");\n    DISPLAY( \" -9     : High compression \\n\");\n    DISPLAY( \" -d     : decompression (default for %s extension)\\n\", LZ4_EXTENSION);\n    DISPLAY( \" -z     : force compression \\n\");\n    DISPLAY( \" -D FILE: use FILE as dictionary \\n\");\n    DISPLAY( \" -f     : overwrite output without prompting \\n\");\n    DISPLAY( \" -k     : preserve source files(s)  (default) \\n\");\n    DISPLAY( \"--rm    : remove source file(s) after successful de/compression \\n\");\n    DISPLAY( \" -h/-H  : display help/long help and exit \\n\");\n    return 0;\n}", "path": "lz4/programs/lz4cli.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "lz4/lz4", "stars": 9059, "license": "other", "language": "c", "size": 7221}
{"docstring": "/*! exeNameMatch() :\n    @return : a non-zero value if exeName matches test, excluding the extension\n   */\n", "func_signal": "static int exeNameMatch(const char* exeName, const char* test)", "code": "{\n    return !strncmp(exeName, test, strlen(test)) &&\n        (exeName[strlen(test)] == '\\0' || exeName[strlen(test)] == '.');\n}", "path": "lz4/programs/lz4cli.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "lz4/lz4", "stars": 9059, "license": "other", "language": "c", "size": 7221}
{"docstring": "/*! Default XXH result types are basic unsigned 32 and 64 bits.\n*   The canonical representation follows human-readable write convention, aka big-endian (large digits first).\n*   These functions allow transformation of hash result into and from its canonical format.\n*   This way, hash values can be written into a file or buffer, remaining comparable across different systems.\n*/\n", "func_signal": "XXH_PUBLIC_API void XXH32_canonicalFromHash(XXH32_canonical_t* dst, XXH32_hash_t hash)", "code": "{\n    XXH_STATIC_ASSERT(sizeof(XXH32_canonical_t) == sizeof(XXH32_hash_t));\n    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap32(hash);\n    memcpy(dst, &hash, sizeof(*dst));\n}", "path": "lz4/lib/xxhash.c", "commit_date": "2018-09-18 00:00:00", "repo_name": "lz4/lz4", "stars": 9059, "license": "other", "language": "c", "size": 7221}
{"docstring": "/* Force direct memory access. Only works on CPU which support unaligned memory access in hardware */\n", "func_signal": "static U64 XXH_read64(const void* memPtr)", "code": "{ return *(const U64*) memPtr; }\n\n#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))\n\n/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */\n/* currently only defined for gcc and icc */\ntypedef union { U32 u32; U64 u64; } __attribute__((packed)) unalign64;\nstatic U64 XXH_read64(const void* ptr) { return ((const unalign64*)ptr)->u64; }\n\n#else\n\n/* portable and safe solution. Generally efficient.\n * see : http://stackoverflow.com/a/32095106/646947\n */\n\nstatic U64 XXH_read64(const void* memPtr)\n{\n    U64 val;\n    memcpy(&val, memPtr, sizeof(val));\n    return val;\n}", "path": "lz4/lib/xxhash.c", "commit_date": "2018-09-18 00:00:00", "repo_name": "lz4/lz4", "stars": 9059, "license": "other", "language": "c", "size": 7221}
{"docstring": "/* @return : 1==error, 0==completed */\n", "func_signal": "static int\ndecompress_file_allocDst(FILE* f_in, FILE* f_out,\n                        LZ4F_dctx* dctx,\n                        void* src, size_t srcCapacity)", "code": "{\n    assert(f_in != NULL); assert(f_out != NULL);\n    assert(dctx != NULL);\n    assert(src != NULL);\n    assert(srcCapacity >= LZ4F_HEADER_SIZE_MAX);  /* ensure LZ4F_getFrameInfo() can read enough data */\n\n    /* Read Frame header */\n    size_t const readSize = fread(src, 1, srcCapacity, f_in);\n    if (readSize == 0 || ferror(f_in)) {\n        printf(\"Decompress: not enough input or error reading file\\n\");\n        return 1;\n    }\n\n    LZ4F_frameInfo_t info;\n    size_t consumedSize = readSize;\n    {   size_t const fires = LZ4F_getFrameInfo(dctx, &info, src, &consumedSize);\n        if (LZ4F_isError(fires)) {\n            printf(\"LZ4F_getFrameInfo error: %s\\n\", LZ4F_getErrorName(fires));\n            return 1;\n    }   }\n\n    /* Allocating enough space for an entire block isn't necessary for\n     * correctness, but it allows some memcpy's to be elided.\n     */\n    size_t const dstCapacity = get_block_size(&info);\n    void* const dst = malloc(dstCapacity);\n    if (!dst) { perror(\"decompress_file(dst)\"); return 1; }\n\n    int const decompressionResult = decompress_file_internal(\n                        f_in, f_out,\n                        dctx,\n                        src, srcCapacity, readSize-consumedSize, consumedSize,\n                        dst, dstCapacity);\n\n    free(dst);\n    return decompressionResult;\n}", "path": "lz4/examples/frameCompress.c", "commit_date": "2019-08-21 00:00:00", "repo_name": "lz4/lz4", "stars": 9059, "license": "other", "language": "c", "size": 7221}
{"docstring": "/*! FUZ_AddressOverflow() :\n*   Aggressively pushes memory allocation limits,\n*   and generates patterns which create address space overflow.\n*   only possible in 32-bits mode */\n", "func_signal": "static int FUZ_AddressOverflow(void)", "code": "{\n    char* buffers[MAX_NB_BUFF_I134+1];\n    int nbBuff=0;\n    int highAddress = 0;\n\n    DISPLAY(\"Overflow tests : \");\n\n    /* Only possible in 32-bits */\n    if (sizeof(void*)==8) {\n        DISPLAY(\"64 bits mode : no overflow \\n\");\n        fflush(stdout);\n        return 0;\n    }\n\n    buffers[0] = (char*)malloc(BLOCKSIZE_I134);\n    buffers[1] = (char*)malloc(BLOCKSIZE_I134);\n    if ((!buffers[0]) || (!buffers[1])) {\n        free(buffers[0]); free(buffers[1]);\n        DISPLAY(\"not enough memory for tests \\n\");\n        return 0;\n    }\n\n    for (nbBuff=2; nbBuff < MAX_NB_BUFF_I134; nbBuff++) {\n        DISPLAY(\"%3i \\b\\b\\b\\b\", nbBuff); fflush(stdout);\n        buffers[nbBuff] = (char*)malloc(BLOCKSIZE_I134);\n        if (buffers[nbBuff]==NULL) goto _endOfTests;\n\n        if (((uintptr_t)buffers[nbBuff] > (uintptr_t)0x80000000) && (!highAddress)) {\n            DISPLAY(\"high address detected : \");\n            fflush(stdout);\n            highAddress=1;\n        }\n\n        {   size_t const sizeToGenerateOverflow = (size_t)(- ((uintptr_t)buffers[nbBuff-1]) + 512);\n            int const nbOf255 = (int)((sizeToGenerateOverflow / 255) + 1);\n            char* const input = buffers[nbBuff-1];\n            char* output = buffers[nbBuff];\n            int r;\n            input[0] = (char)0xF0;   /* Literal length overflow */\n            input[1] = (char)0xFF;\n            input[2] = (char)0xFF;\n            input[3] = (char)0xFF;\n            { int u; for(u = 4; u <= nbOf255+4; u++) input[u] = (char)0xff; }\n            r = LZ4_decompress_safe(input, output, nbOf255+64, BLOCKSIZE_I134);\n            if (r>0) { DISPLAY(\"LZ4_decompress_safe = %i \\n\", r); goto _overflowError; }\n            input[0] = (char)0x1F;   /* Match length overflow */\n            input[1] = (char)0x01;\n            input[2] = (char)0x01;\n            input[3] = (char)0x00;\n            r = LZ4_decompress_safe(input, output, nbOf255+64, BLOCKSIZE_I134);\n            if (r>0) { DISPLAY(\"LZ4_decompress_safe = %i \\n\", r); goto _overflowError; }\n\n            output = buffers[nbBuff-2];   /* Reverse in/out pointer order */\n            input[0] = (char)0xF0;   /* Literal length overflow */\n            input[1] = (char)0xFF;\n            input[2] = (char)0xFF;\n            input[3] = (char)0xFF;\n            r = LZ4_decompress_safe(input, output, nbOf255+64, BLOCKSIZE_I134);\n            if (r>0) goto _overflowError;\n            input[0] = (char)0x1F;   /* Match length overflow */\n            input[1] = (char)0x01;\n            input[2] = (char)0x01;\n            input[3] = (char)0x00;\n            r = LZ4_decompress_safe(input, output, nbOf255+64, BLOCKSIZE_I134);\n            if (r>0) goto _overflowError;\n        }\n    }\n\n    nbBuff++;\n_endOfTests:\n    { int i; for (i=0 ; i<nbBuff; i++) free(buffers[i]); }\n    if (!highAddress) DISPLAY(\"high address not possible \\n\");\n    else DISPLAY(\"all overflows correctly detected \\n\");\n    return 0;\n\n_overflowError:\n    DISPLAY(\"Address space overflow error !! \\n\");\n    exit(1);\n}", "path": "lz4/tests/fuzzer.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "lz4/lz4", "stars": 9059, "license": "other", "language": "c", "size": 7221}
{"docstring": "/*\n * Decode one bit. In some versions, this function has been splitted in three\n * functions so that the compiler is supposed to be able to more easily avoid\n * an extra branch. In this particular version of the LZMA decoder, this\n * doesn't seem to be a good idea (tested with GCC 3.3.6, 3.4.6, and 4.3.3\n * on x86). Using a non-splitted version results in nicer looking code too.\n *\n * NOTE: This must return an int. Do not make it return a bool or the speed\n * of the code generated by GCC 3.x decreases 10-15 %. (GCC 4.3 doesn't care,\n * and it generates 10-20 % faster code than GCC 3.x from this file anyway.)\n */\n", "func_signal": "static __always_inline int XZ_FUNC rc_bit(struct rc_dec *rc, uint16_t *prob)", "code": "{\n\tuint32_t bound;\n\tint bit;\n\n\trc_normalize(rc);\n\tbound = (rc->range >> RC_BIT_MODEL_TOTAL_BITS) * *prob;\n\tif (rc->code < bound) {\n\t\trc->range = bound;\n\t\t*prob += (RC_BIT_MODEL_TOTAL - *prob) >> RC_MOVE_BITS;\n\t\tbit = 0;\n\t} else {\n\t\trc->range -= bound;\n\t\trc->code -= bound;\n\t\t*prob -= *prob >> RC_MOVE_BITS;\n\t\tbit = 1;\n\t}\n\n\treturn bit;\n}", "path": "rufus/src/bled/xz_dec_lzma2.c", "commit_date": "2015-01-23 00:00:00", "repo_name": "pbatard/rufus", "stars": 26375, "license": "gpl-3.0", "language": "c", "size": 35243}
{"docstring": "/* Reset the range decoder. */\n", "func_signal": "static void XZ_FUNC rc_reset(struct rc_dec *rc)", "code": "{\n\trc->range = (uint32_t)-1;\n\trc->code = 0;\n\trc->init_bytes_left = RC_INIT_BYTES;\n}", "path": "rufus/src/bled/xz_dec_lzma2.c", "commit_date": "2015-01-23 00:00:00", "repo_name": "pbatard/rufus", "stars": 26375, "license": "gpl-3.0", "language": "c", "size": 35243}
{"docstring": "/* LZMA decoder core */\n", "func_signal": "static bool XZ_FUNC lzma_main(struct xz_dec_lzma2 *s)", "code": "{\n\tuint32_t pos_state;\n\n\t/*\n\t * If the dictionary was reached during the previous call, try to\n\t * finish the possibly pending repeat in the dictionary.\n\t */\n\tif (dict_has_space(&s->dict) && s->lzma.len > 0)\n\t\tdict_repeat(&s->dict, &s->lzma.len, s->lzma.rep0);\n\n\t/*\n\t * Decode more LZMA symbols. One iteration may consume up to\n\t * LZMA_IN_REQUIRED - 1 bytes.\n\t */\n\twhile (dict_has_space(&s->dict) && !rc_limit_exceeded(&s->rc)) {\n\t\tpos_state = s->dict.pos & s->lzma.pos_mask;\n\n\t\tif (!rc_bit(&s->rc, &s->lzma.is_match[\n\t\t\t\ts->lzma.state][pos_state])) {\n\t\t\tlzma_literal(s);\n\t\t} else {\n\t\t\tif (rc_bit(&s->rc, &s->lzma.is_rep[s->lzma.state]))\n\t\t\t\tlzma_rep_match(s, pos_state);\n\t\t\telse\n\t\t\t\tlzma_match(s, pos_state);\n\n\t\t\tif (!dict_repeat(&s->dict, &s->lzma.len, s->lzma.rep0))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * Having the range decoder always normalized when we are outside\n\t * this function makes it easier to correctly handle end of the chunk.\n\t */\n\trc_normalize(&s->rc);\n\n\treturn true;\n}", "path": "rufus/src/bled/xz_dec_lzma2.c", "commit_date": "2015-01-23 00:00:00", "repo_name": "pbatard/rufus", "stars": 26375, "license": "gpl-3.0", "language": "c", "size": 35243}
{"docstring": "/* Set dictionary write limit */\n", "func_signal": "static void XZ_FUNC dict_limit(struct dictionary *dict, size_t out_max)", "code": "{\n\tif (dict->end - dict->pos <= out_max)\n\t\tdict->limit = dict->end;\n\telse\n\t\tdict->limit = dict->pos + out_max;\n}", "path": "rufus/src/bled/xz_dec_lzma2.c", "commit_date": "2015-01-23 00:00:00", "repo_name": "pbatard/rufus", "stars": 26375, "license": "gpl-3.0", "language": "c", "size": 35243}
{"docstring": "/*\n * Decode and validate LZMA properties (lc/lp/pb) and calculate the bit masks\n * from the decoded lp and pb values. On success, the LZMA decoder state is\n * reset and true is returned.\n */\n", "func_signal": "static bool XZ_FUNC lzma_props(struct xz_dec_lzma2 *s, uint8_t props)", "code": "{\n\tif (props > (4 * 5 + 4) * 9 + 8)\n\t\treturn false;\n\n\ts->lzma.pos_mask = 0;\n\twhile (props >= 9 * 5) {\n\t\tprops -= 9 * 5;\n\t\t++s->lzma.pos_mask;\n\t}\n\n\ts->lzma.pos_mask = (1 << s->lzma.pos_mask) - 1;\n\n\ts->lzma.literal_pos_mask = 0;\n\twhile (props >= 9) {\n\t\tprops -= 9;\n\t\t++s->lzma.literal_pos_mask;\n\t}\n\n\ts->lzma.lc = props;\n\n\tif (s->lzma.lc + s->lzma.literal_pos_mask > 4)\n\t\treturn false;\n\n\ts->lzma.literal_pos_mask = (1 << s->lzma.literal_pos_mask) - 1;\n\n\tlzma_reset(s);\n\n\treturn true;\n}", "path": "rufus/src/bled/xz_dec_lzma2.c", "commit_date": "2015-01-23 00:00:00", "repo_name": "pbatard/rufus", "stars": 26375, "license": "gpl-3.0", "language": "c", "size": 35243}
{"docstring": "/*\n * Reset the LZMA decoder and range decoder state. Dictionary is nore reset\n * here, because LZMA state may be reset without resetting the dictionary.\n */\n", "func_signal": "static void XZ_FUNC lzma_reset(struct xz_dec_lzma2 *s)", "code": "{\n\tuint16_t *probs;\n\tsize_t i;\n\n\ts->lzma.state = STATE_LIT_LIT;\n\ts->lzma.rep0 = 0;\n\ts->lzma.rep1 = 0;\n\ts->lzma.rep2 = 0;\n\ts->lzma.rep3 = 0;\n\n\t/*\n\t * All probabilities are initialized to the same value. This hack\n\t * makes the code smaller by avoiding a separate loop for each\n\t * probability array.\n\t *\n\t * This could be optimized so that only that part of literal\n\t * probabilities that are actually required. In the common case\n\t * we would write 12 KiB less.\n\t */\n\tprobs = s->lzma.is_match[0];\n\tfor (i = 0; i < PROBS_TOTAL; ++i)\n\t\tprobs[i] = RC_BIT_MODEL_TOTAL / 2;\n\n\trc_reset(&s->rc);\n}", "path": "rufus/src/bled/xz_dec_lzma2.c", "commit_date": "2015-01-23 00:00:00", "repo_name": "pbatard/rufus", "stars": 26375, "license": "gpl-3.0", "language": "c", "size": 35243}
{"docstring": "/*\n * Flush pending data from dictionary to b->out. It is assumed that there is\n * enough space in b->out. This is guaranteed because caller uses dict_limit()\n * before decoding data into the dictionary.\n */\n", "func_signal": "static uint32_t XZ_FUNC dict_flush(struct dictionary *dict, struct xz_buf *b)", "code": "{\n\tsize_t copy_size = dict->pos - dict->start;\n\n\tif (DEC_IS_MULTI(dict->mode)) {\n\t\tif (dict->pos == dict->end)\n\t\t\tdict->pos = 0;\n\n\t\tmemcpy(b->out + b->out_pos, dict->buf + dict->start,\n\t\t\t\tcopy_size);\n\t}\n\n\tdict->start = dict->pos;\n\tb->out_pos += copy_size;\n\treturn (uint32_t)copy_size;\n}", "path": "rufus/src/bled/xz_dec_lzma2.c", "commit_date": "2015-01-23 00:00:00", "repo_name": "pbatard/rufus", "stars": 26375, "license": "gpl-3.0", "language": "c", "size": 35243}
{"docstring": "/* Decode a bittree starting from the most significant bit. */\n", "func_signal": "static __always_inline uint32_t XZ_FUNC rc_bittree(\n\t\tstruct rc_dec *rc, uint16_t *probs, uint32_t limit)", "code": "{\n\tuint32_t symbol = 1;\n\n\tdo {\n\t\tif (rc_bit(rc, &probs[symbol]))\n\t\t\tsymbol = (symbol << 1) + 1;\n\t\telse\n\t\t\tsymbol <<= 1;\n\t} while (symbol < limit);\n\n\treturn symbol;\n}", "path": "rufus/src/bled/xz_dec_lzma2.c", "commit_date": "2015-01-23 00:00:00", "repo_name": "pbatard/rufus", "stars": 26375, "license": "gpl-3.0", "language": "c", "size": 35243}
{"docstring": "/* Copy uncompressed data as is from input to dictionary and output buffers. */\n", "func_signal": "static void XZ_FUNC dict_uncompressed(\n\t\tstruct dictionary *dict, struct xz_buf *b, uint32_t *left)", "code": "{\n\tsize_t copy_size;\n\n\twhile (*left > 0 && b->in_pos < b->in_size\n\t\t\t&& b->out_pos < b->out_size) {\n\t\tcopy_size = min(b->in_size - b->in_pos,\n\t\t\t\tb->out_size - b->out_pos);\n\t\tif (copy_size > dict->end - dict->pos)\n\t\t\tcopy_size = dict->end - dict->pos;\n\t\tif (copy_size > *left)\n\t\t\tcopy_size = *left;\n\n\t\t*left -= (uint32_t)copy_size;\n\n\t\tmemcpy(dict->buf + dict->pos, b->in + b->in_pos, copy_size);\n\t\tdict->pos += copy_size;\n\n\t\tif (dict->full < dict->pos)\n\t\t\tdict->full = dict->pos;\n\n\t\tif (DEC_IS_MULTI(dict->mode)) {\n\t\t\tif (dict->pos == dict->end)\n\t\t\t\tdict->pos = 0;\n\n\t\t\tmemcpy(b->out + b->out_pos, b->in + b->in_pos,\n\t\t\t\t\tcopy_size);\n\t\t}\n\n\t\tdict->start = dict->pos;\n\n\t\tb->out_pos += copy_size;\n\t\tb->in_pos += copy_size;\n\t}\n}", "path": "rufus/src/bled/xz_dec_lzma2.c", "commit_date": "2015-01-23 00:00:00", "repo_name": "pbatard/rufus", "stars": 26375, "license": "gpl-3.0", "language": "c", "size": 35243}
{"docstring": "/* Decode a bittree starting from the least significant bit. */\n", "func_signal": "static __always_inline void XZ_FUNC rc_bittree_reverse(struct rc_dec *rc,\n\t\tuint16_t *probs, uint32_t *dest, uint32_t limit)", "code": "{\n\tuint32_t symbol = 1;\n\tuint32_t i = 0;\n\n\tdo {\n\t\tif (rc_bit(rc, &probs[symbol])) {\n\t\t\tsymbol = (symbol << 1) + 1;\n\t\t\t*dest += 1 << i;\n\t\t} else {\n\t\t\tsymbol <<= 1;\n\t\t}\n\t} while (++i < limit);\n}", "path": "rufus/src/bled/xz_dec_lzma2.c", "commit_date": "2015-01-23 00:00:00", "repo_name": "pbatard/rufus", "stars": 26375, "license": "gpl-3.0", "language": "c", "size": 35243}
{"docstring": "/* Get pointer to literal coder probability array. */\n", "func_signal": "static uint16_t * XZ_FUNC lzma_literal_probs(struct xz_dec_lzma2 *s)", "code": "{\n\tuint32_t prev_byte = dict_get(&s->dict, 0);\n\tuint32_t low = prev_byte >> (8 - s->lzma.lc);\n\tuint32_t high = (s->dict.pos & s->lzma.literal_pos_mask) << s->lzma.lc;\n\treturn s->lzma.literal[low + high];\n}", "path": "rufus/src/bled/xz_dec_lzma2.c", "commit_date": "2015-01-23 00:00:00", "repo_name": "pbatard/rufus", "stars": 26375, "license": "gpl-3.0", "language": "c", "size": 35243}
{"docstring": "/* Decode the length of the match into s->lzma.len. */\n", "func_signal": "static void XZ_FUNC lzma_len(struct xz_dec_lzma2 *s, struct lzma_len_dec *l,\n\t\tuint32_t pos_state)", "code": "{\n\tuint16_t *probs;\n\tuint32_t limit;\n\n\tif (!rc_bit(&s->rc, &l->choice)) {\n\t\tprobs = l->low[pos_state];\n\t\tlimit = LEN_LOW_SYMBOLS;\n\t\ts->lzma.len = MATCH_LEN_MIN;\n\t} else {\n\t\tif (!rc_bit(&s->rc, &l->choice2)) {\n\t\t\tprobs = l->mid[pos_state];\n\t\t\tlimit = LEN_MID_SYMBOLS;\n\t\t\ts->lzma.len = MATCH_LEN_MIN + LEN_LOW_SYMBOLS;\n\t\t} else {\n\t\t\tprobs = l->high;\n\t\t\tlimit = LEN_HIGH_SYMBOLS;\n\t\t\ts->lzma.len = MATCH_LEN_MIN + LEN_LOW_SYMBOLS\n\t\t\t\t\t+ LEN_MID_SYMBOLS;\n\t\t}\n\t}\n\n\ts->lzma.len += rc_bittree(&s->rc, probs, limit) - limit;\n}", "path": "rufus/src/bled/xz_dec_lzma2.c", "commit_date": "2015-01-23 00:00:00", "repo_name": "pbatard/rufus", "stars": 26375, "license": "gpl-3.0", "language": "c", "size": 35243}
{"docstring": "/*\n * Take care of the LZMA2 control layer, and forward the job of actual LZMA\n * decoding or copying of uncompressed chunks to other functions.\n */\n", "func_signal": "XZ_EXTERN NOINLINE enum xz_ret XZ_FUNC xz_dec_lzma2_run(\n\t\tstruct xz_dec_lzma2 *s, struct xz_buf *b)", "code": "{\n\tuint32_t tmp;\n\n\twhile (b->in_pos < b->in_size || s->lzma2.sequence == SEQ_LZMA_RUN) {\n\t\tswitch (s->lzma2.sequence) {\n\t\tcase SEQ_CONTROL:\n\t\t\t/*\n\t\t\t * LZMA2 control byte\n\t\t\t *\n\t\t\t * Exact values:\n\t\t\t *   0x00   End marker\n\t\t\t *   0x01   Dictionary reset followed by\n\t\t\t *          an uncompressed chunk\n\t\t\t *   0x02   Uncompressed chunk (no dictionary reset)\n\t\t\t *\n\t\t\t * Highest three bits (s->control & 0xE0):\n\t\t\t *   0xE0   Dictionary reset, new properties and state\n\t\t\t *          reset, followed by LZMA compressed chunk\n\t\t\t *   0xC0   New properties and state reset, followed\n\t\t\t *          by LZMA compressed chunk (no dictionary\n\t\t\t *          reset)\n\t\t\t *   0xA0   State reset using old properties,\n\t\t\t *          followed by LZMA compressed chunk (no\n\t\t\t *          dictionary reset)\n\t\t\t *   0x80   LZMA chunk (no dictionary or state reset)\n\t\t\t *\n\t\t\t * For LZMA compressed chunks, the lowest five bits\n\t\t\t * (s->control & 1F) are the highest bits of the\n\t\t\t * uncompressed size (bits 16-20).\n\t\t\t *\n\t\t\t * A new LZMA2 stream must begin with a dictionary\n\t\t\t * reset. The first LZMA chunk must set new\n\t\t\t * properties and reset the LZMA state.\n\t\t\t *\n\t\t\t * Values that don't match anything described above\n\t\t\t * are invalid and we return XZ_DATA_ERROR.\n\t\t\t */\n\t\t\ttmp = b->in[b->in_pos++];\n\n\t\t\tif (tmp == 0x00)\n\t\t\t\treturn XZ_STREAM_END;\n\n\t\t\tif (tmp >= 0xE0 || tmp == 0x01) {\n\t\t\t\ts->lzma2.need_props = true;\n\t\t\t\ts->lzma2.need_dict_reset = false;\n\t\t\t\tdict_reset(&s->dict, b);\n\t\t\t} else if (s->lzma2.need_dict_reset) {\n\t\t\t\treturn XZ_DATA_ERROR;\n\t\t\t}\n\n\t\t\tif (tmp >= 0x80) {\n\t\t\t\ts->lzma2.uncompressed = (tmp & 0x1F) << 16;\n\t\t\t\ts->lzma2.sequence = SEQ_UNCOMPRESSED_1;\n\n\t\t\t\tif (tmp >= 0xC0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * When there are new properties,\n\t\t\t\t\t * state reset is done at\n\t\t\t\t\t * SEQ_PROPERTIES.\n\t\t\t\t\t */\n\t\t\t\t\ts->lzma2.need_props = false;\n\t\t\t\t\ts->lzma2.next_sequence\n\t\t\t\t\t\t\t= SEQ_PROPERTIES;\n\n\t\t\t\t} else if (s->lzma2.need_props) {\n\t\t\t\t\treturn XZ_DATA_ERROR;\n\n\t\t\t\t} else {\n\t\t\t\t\ts->lzma2.next_sequence\n\t\t\t\t\t\t\t= SEQ_LZMA_PREPARE;\n\t\t\t\t\tif (tmp >= 0xA0)\n\t\t\t\t\t\tlzma_reset(s);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (tmp > 0x02)\n\t\t\t\t\treturn XZ_DATA_ERROR;\n\n\t\t\t\ts->lzma2.sequence = SEQ_COMPRESSED_0;\n\t\t\t\ts->lzma2.next_sequence = SEQ_COPY;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase SEQ_UNCOMPRESSED_1:\n\t\t\ts->lzma2.uncompressed\n\t\t\t\t\t+= (uint32_t)b->in[b->in_pos++] << 8;\n\t\t\ts->lzma2.sequence = SEQ_UNCOMPRESSED_2;\n\t\t\tbreak;\n\n\t\tcase SEQ_UNCOMPRESSED_2:\n\t\t\ts->lzma2.uncompressed\n\t\t\t\t\t+= (uint32_t)b->in[b->in_pos++] + 1;\n\t\t\ts->lzma2.sequence = SEQ_COMPRESSED_0;\n\t\t\tbreak;\n\n\t\tcase SEQ_COMPRESSED_0:\n\t\t\ts->lzma2.compressed\n\t\t\t\t\t= (uint32_t)b->in[b->in_pos++] << 8;\n\t\t\ts->lzma2.sequence = SEQ_COMPRESSED_1;\n\t\t\tbreak;\n\n\t\tcase SEQ_COMPRESSED_1:\n\t\t\ts->lzma2.compressed\n\t\t\t\t\t+= (uint32_t)b->in[b->in_pos++] + 1;\n\t\t\ts->lzma2.sequence = s->lzma2.next_sequence;\n\t\t\tbreak;\n\n\t\tcase SEQ_PROPERTIES:\n\t\t\tif (!lzma_props(s, b->in[b->in_pos++]))\n\t\t\t\treturn XZ_DATA_ERROR;\n\n\t\t\ts->lzma2.sequence = SEQ_LZMA_PREPARE;\n\n\t\tcase SEQ_LZMA_PREPARE:\n\t\t\tif (s->lzma2.compressed < RC_INIT_BYTES)\n\t\t\t\treturn XZ_DATA_ERROR;\n\n\t\t\tif (!rc_read_init(&s->rc, b))\n\t\t\t\treturn XZ_OK;\n\n\t\t\ts->lzma2.compressed -= RC_INIT_BYTES;\n\t\t\ts->lzma2.sequence = SEQ_LZMA_RUN;\n\n\t\tcase SEQ_LZMA_RUN:\n\t\t\t/*\n\t\t\t * Set dictionary limit to indicate how much we want\n\t\t\t * to be encoded at maximum. Decode new data into the\n\t\t\t * dictionary. Flush the new data from dictionary to\n\t\t\t * b->out. Check if we finished decoding this chunk.\n\t\t\t * In case the dictionary got full but we didn't fill\n\t\t\t * the output buffer yet, we may run this loop\n\t\t\t * multiple times without changing s->lzma2.sequence.\n\t\t\t */\n\t\t\tdict_limit(&s->dict, min_t(size_t,\n\t\t\t\t\tb->out_size - b->out_pos,\n\t\t\t\t\ts->lzma2.uncompressed));\n\t\t\tif (!lzma2_lzma(s, b))\n\t\t\t\treturn XZ_DATA_ERROR;\n\n\t\t\ts->lzma2.uncompressed -= dict_flush(&s->dict, b);\n\n\t\t\tif (s->lzma2.uncompressed == 0) {\n\t\t\t\tif (s->lzma2.compressed > 0 || s->lzma.len > 0\n\t\t\t\t\t\t|| !rc_is_finished(&s->rc))\n\t\t\t\t\treturn XZ_DATA_ERROR;\n\n\t\t\t\trc_reset(&s->rc);\n\t\t\t\ts->lzma2.sequence = SEQ_CONTROL;\n\n\t\t\t} else if (b->out_pos == b->out_size\n\t\t\t\t\t|| (b->in_pos == b->in_size\n\t\t\t\t\t\t&& s->temp.size\n\t\t\t\t\t\t< s->lzma2.compressed)) {\n\t\t\t\treturn XZ_OK;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase SEQ_COPY:\n\t\t\tdict_uncompressed(&s->dict, b, &s->lzma2.compressed);\n\t\t\tif (s->lzma2.compressed > 0)\n\t\t\t\treturn XZ_OK;\n\n\t\t\ts->lzma2.sequence = SEQ_CONTROL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn XZ_OK;\n}", "path": "rufus/src/bled/xz_dec_lzma2.c", "commit_date": "2015-01-23 00:00:00", "repo_name": "pbatard/rufus", "stars": 26375, "license": "gpl-3.0", "language": "c", "size": 35243}
{"docstring": "/* Decode direct bits (fixed fifty-fifty probability) */\n", "func_signal": "static inline void XZ_FUNC rc_direct(\n\t\tstruct rc_dec *rc, uint32_t *dest, uint32_t limit)", "code": "{\n\tuint32_t mask;\n\n\tdo {\n\t\trc_normalize(rc);\n\t\trc->range >>= 1;\n\t\trc->code -= rc->range;\n\t\tmask = (uint32_t)0 - (rc->code >> 31);\n\t\trc->code += rc->range & mask;\n\t\t*dest = (*dest << 1) + (mask + 1);\n\t} while (--limit > 0);\n}", "path": "rufus/src/bled/xz_dec_lzma2.c", "commit_date": "2015-01-23 00:00:00", "repo_name": "pbatard/rufus", "stars": 26375, "license": "gpl-3.0", "language": "c", "size": 35243}
{"docstring": "/* Read the next input byte if needed. */\n", "func_signal": "static __always_inline void XZ_FUNC rc_normalize(struct rc_dec *rc)", "code": "{\n\tif (rc->range < RC_TOP_VALUE) {\n\t\trc->range <<= RC_SHIFT_BITS;\n\t\trc->code = (rc->code << RC_SHIFT_BITS) + rc->in[rc->in_pos++];\n\t}\n}", "path": "rufus/src/bled/xz_dec_lzma2.c", "commit_date": "2015-01-23 00:00:00", "repo_name": "pbatard/rufus", "stars": 26375, "license": "gpl-3.0", "language": "c", "size": 35243}
{"docstring": "/*\n * Read the first five initial bytes into rc->code if they haven't been\n * read already. (Yes, the first byte gets completely ignored.)\n */\n", "func_signal": "static bool XZ_FUNC rc_read_init(struct rc_dec *rc, struct xz_buf *b)", "code": "{\n\twhile (rc->init_bytes_left > 0) {\n\t\tif (b->in_pos == b->in_size)\n\t\t\treturn false;\n\n\t\trc->code = (rc->code << 8) + b->in[b->in_pos++];\n\t\t--rc->init_bytes_left;\n\t}\n\n\treturn true;\n}", "path": "rufus/src/bled/xz_dec_lzma2.c", "commit_date": "2015-01-23 00:00:00", "repo_name": "pbatard/rufus", "stars": 26375, "license": "gpl-3.0", "language": "c", "size": 35243}
{"docstring": "/*\n * Decode a repeated match. The distance is one of the four most recently\n * seen matches. The distance will be stored in s->lzma.rep0.\n */\n", "func_signal": "static void XZ_FUNC lzma_rep_match(struct xz_dec_lzma2 *s, uint32_t pos_state)", "code": "{\n\tuint32_t tmp;\n\n\tif (!rc_bit(&s->rc, &s->lzma.is_rep0[s->lzma.state])) {\n\t\tif (!rc_bit(&s->rc, &s->lzma.is_rep0_long[\n\t\t\t\ts->lzma.state][pos_state])) {\n\t\t\tlzma_state_short_rep(&s->lzma.state);\n\t\t\ts->lzma.len = 1;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (!rc_bit(&s->rc, &s->lzma.is_rep1[s->lzma.state])) {\n\t\t\ttmp = s->lzma.rep1;\n\t\t} else {\n\t\t\tif (!rc_bit(&s->rc, &s->lzma.is_rep2[s->lzma.state])) {\n\t\t\t\ttmp = s->lzma.rep2;\n\t\t\t} else {\n\t\t\t\ttmp = s->lzma.rep3;\n\t\t\t\ts->lzma.rep3 = s->lzma.rep2;\n\t\t\t}\n\n\t\t\ts->lzma.rep2 = s->lzma.rep1;\n\t\t}\n\n\t\ts->lzma.rep1 = s->lzma.rep0;\n\t\ts->lzma.rep0 = tmp;\n\t}\n\n\tlzma_state_long_rep(&s->lzma.state);\n\tlzma_len(s, &s->lzma.rep_len_dec, pos_state);\n}", "path": "rufus/src/bled/xz_dec_lzma2.c", "commit_date": "2015-01-23 00:00:00", "repo_name": "pbatard/rufus", "stars": 26375, "license": "gpl-3.0", "language": "c", "size": 35243}
{"docstring": "/*\n * Get a byte from the dictionary at the given distance. The distance is\n * assumed to valid, or as a special case, zero when the dictionary is\n * still empty. This special case is needed for single-call decoding to\n * avoid writing a '\\0' to the end of the destination buffer.\n */\n", "func_signal": "static __always_inline uint32_t XZ_FUNC dict_get(\n\t\tconst struct dictionary *dict, uint32_t dist)", "code": "{\n\tsize_t offset = dict->pos - dist - 1;\n\n\tif (dist >= dict->pos)\n\t\toffset += dict->end;\n\n\treturn dict->full > 0 ? dict->buf[offset] : 0;\n}", "path": "rufus/src/bled/xz_dec_lzma2.c", "commit_date": "2015-01-23 00:00:00", "repo_name": "pbatard/rufus", "stars": 26375, "license": "gpl-3.0", "language": "c", "size": 35243}
{"docstring": "/*\n * Reset the dictionary state. When in single-call mode, set up the beginning\n * of the dictionary to point to the actual output buffer.\n */\n", "func_signal": "static void XZ_FUNC dict_reset(struct dictionary *dict, struct xz_buf *b)", "code": "{\n\tif (DEC_IS_SINGLE(dict->mode)) {\n\t\tdict->buf = b->out + b->out_pos;\n\t\tdict->end = b->out_size - b->out_pos;\n\t}\n\n\tdict->start = 0;\n\tdict->pos = 0;\n\tdict->limit = 0;\n\tdict->full = 0;\n}", "path": "rufus/src/bled/xz_dec_lzma2.c", "commit_date": "2015-01-23 00:00:00", "repo_name": "pbatard/rufus", "stars": 26375, "license": "gpl-3.0", "language": "c", "size": 35243}
{"docstring": "/*\n * The LZMA decoder assumes that if the input limit (s->rc.in_limit) hasn't\n * been exceeded, it is safe to read up to LZMA_IN_REQUIRED bytes. This\n * wrapper function takes care of making the LZMA decoder's assumption safe.\n *\n * As long as there is plenty of input left to be decoded in the current LZMA\n * chunk, we decode directly from the caller-supplied input buffer until\n * there's LZMA_IN_REQUIRED bytes left. Those remaining bytes are copied into\n * s->temp.buf, which (hopefully) gets filled on the next call to this\n * function. We decode a few bytes from the temporary buffer so that we can\n * continue decoding from the caller-supplied input buffer again.\n */\n", "func_signal": "static bool XZ_FUNC lzma2_lzma(struct xz_dec_lzma2 *s, struct xz_buf *b)", "code": "{\n\tsize_t in_avail;\n\tuint32_t tmp;\n\n\tin_avail = b->in_size - b->in_pos;\n\tif (s->temp.size > 0 || s->lzma2.compressed == 0) {\n\t\ttmp = 2 * LZMA_IN_REQUIRED - s->temp.size;\n\t\tif (tmp > s->lzma2.compressed - s->temp.size)\n\t\t\ttmp = s->lzma2.compressed - s->temp.size;\n\t\tif (tmp > in_avail)\n\t\t\ttmp = (uint32_t)in_avail;\n\n\t\tmemcpy(s->temp.buf + s->temp.size, b->in + b->in_pos, tmp);\n\n\t\tif (s->temp.size + tmp == s->lzma2.compressed) {\n\t\t\tmemzero(s->temp.buf + s->temp.size + tmp,\n\t\t\t\t\tsizeof(s->temp.buf)\n\t\t\t\t\t\t- s->temp.size - tmp);\n\t\t\ts->rc.in_limit = s->temp.size + tmp;\n\t\t} else if (s->temp.size + tmp < LZMA_IN_REQUIRED) {\n\t\t\ts->temp.size += tmp;\n\t\t\tb->in_pos += tmp;\n\t\t\treturn true;\n\t\t} else {\n\t\t\ts->rc.in_limit = s->temp.size + tmp - LZMA_IN_REQUIRED;\n\t\t}\n\n\t\ts->rc.in = s->temp.buf;\n\t\ts->rc.in_pos = 0;\n\n\t\tif (!lzma_main(s) || s->rc.in_pos > s->temp.size + tmp)\n\t\t\treturn false;\n\n\t\ts->lzma2.compressed -= (uint32_t)s->rc.in_pos;\n\n\t\tif (s->rc.in_pos < s->temp.size) {\n\t\t\ts->temp.size -= (uint32_t)s->rc.in_pos;\n\t\t\tmemmove(s->temp.buf, s->temp.buf + s->rc.in_pos,\n\t\t\t\t\ts->temp.size);\n\t\t\treturn true;\n\t\t}\n\n\t\tb->in_pos += s->rc.in_pos - s->temp.size;\n\t\ts->temp.size = 0;\n\t}\n\n\tin_avail = b->in_size - b->in_pos;\n\tif (in_avail >= LZMA_IN_REQUIRED) {\n\t\ts->rc.in = b->in;\n\t\ts->rc.in_pos = b->in_pos;\n\n\t\tif (in_avail >= s->lzma2.compressed + LZMA_IN_REQUIRED)\n\t\t\ts->rc.in_limit = b->in_pos + s->lzma2.compressed;\n\t\telse\n\t\t\ts->rc.in_limit = b->in_size - LZMA_IN_REQUIRED;\n\n\t\tif (!lzma_main(s))\n\t\t\treturn false;\n\n\t\tin_avail = s->rc.in_pos - b->in_pos;\n\t\tif (in_avail > s->lzma2.compressed)\n\t\t\treturn false;\n\n\t\ts->lzma2.compressed -= (uint32_t)in_avail;\n\t\tb->in_pos = s->rc.in_pos;\n\t}\n\n\tin_avail = b->in_size - b->in_pos;\n\tif (in_avail < LZMA_IN_REQUIRED) {\n\t\tif (in_avail > s->lzma2.compressed)\n\t\t\tin_avail = s->lzma2.compressed;\n\n\t\tmemcpy(s->temp.buf, b->in + b->in_pos, in_avail);\n\t\ts->temp.size = (uint32_t)in_avail;\n\t\tb->in_pos += in_avail;\n\t}\n\n\treturn true;\n}", "path": "rufus/src/bled/xz_dec_lzma2.c", "commit_date": "2015-01-23 00:00:00", "repo_name": "pbatard/rufus", "stars": 26375, "license": "gpl-3.0", "language": "c", "size": 35243}
{"docstring": "/*\n * Get rectangles representing the border around the child window. Some borders\n * are adjacent to the screen-edge and thus not returned. Return value is the\n * number of rectangles.\n *\n */\n", "func_signal": "static size_t x_get_border_rectangles(Con *con, xcb_rectangle_t rectangles[4])", "code": "{\n    size_t count = 0;\n    int border_style = con_border_style(con);\n\n    if (border_style != BS_NONE && con_is_leaf(con)) {\n        adjacent_t borders_to_hide = con_adjacent_borders(con) & config.hide_edge_borders;\n        Rect br = con_border_style_rect(con);\n\n        if (!(borders_to_hide & ADJ_LEFT_SCREEN_EDGE)) {\n            rectangles[count++] = (xcb_rectangle_t){\n                .x = 0,\n                .y = 0,\n                .width = br.x,\n                .height = con->rect.height,\n            };\n        }\n        if (!(borders_to_hide & ADJ_RIGHT_SCREEN_EDGE)) {\n            rectangles[count++] = (xcb_rectangle_t){\n                .x = con->rect.width + (br.width + br.x),\n                .y = 0,\n                .width = -(br.width + br.x),\n                .height = con->rect.height,\n            };\n        }\n        if (!(borders_to_hide & ADJ_LOWER_SCREEN_EDGE)) {\n            rectangles[count++] = (xcb_rectangle_t){\n                .x = br.x,\n                .y = con->rect.height + (br.height + br.y),\n                .width = con->rect.width + br.width,\n                .height = -(br.height + br.y),\n            };\n        }\n        /* pixel border have an additional line at the top */\n        if (border_style == BS_PIXEL && !(borders_to_hide & ADJ_UPPER_SCREEN_EDGE)) {\n            rectangles[count++] = (xcb_rectangle_t){\n                .x = br.x,\n                .y = 0,\n                .width = con->rect.width + br.width,\n                .height = br.y,\n            };\n        }\n    }\n\n    return count;\n}", "path": "i3/src/x.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "i3/i3", "stars": 8920, "license": "bsd-3-clause", "language": "c", "size": 14347}
{"docstring": "/*\n * Kills the window decoration associated with the given container.\n *\n */\n", "func_signal": "void x_con_kill(Con *con)", "code": "{\n    _x_con_kill(con);\n    xcb_destroy_window(conn, con->frame.id);\n}", "path": "i3/src/x.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "i3/i3", "stars": 8920, "license": "bsd-3-clause", "language": "c", "size": 14347}
{"docstring": "/*\n * Sets or removes the _NET_WM_STATE_HIDDEN property on con if necessary.\n *\n */\n", "func_signal": "static void set_hidden_state(Con *con)", "code": "{\n    if (con->window == NULL) {\n        return;\n    }\n\n    con_state *state = state_for_frame(con->frame.id);\n    bool should_be_hidden = con_is_hidden(con);\n    if (should_be_hidden == state->is_hidden)\n        return;\n\n    if (should_be_hidden) {\n        DLOG(\"setting _NET_WM_STATE_HIDDEN for con = %p\\n\", con);\n        xcb_add_property_atom(conn, con->window->id, A__NET_WM_STATE, A__NET_WM_STATE_HIDDEN);\n    } else {\n        DLOG(\"removing _NET_WM_STATE_HIDDEN for con = %p\\n\", con);\n        xcb_remove_property_atom(conn, con->window->id, A__NET_WM_STATE, A__NET_WM_STATE_HIDDEN);\n    }\n\n    state->is_hidden = should_be_hidden;\n}", "path": "i3/src/x.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "i3/i3", "stars": 8920, "license": "bsd-3-clause", "language": "c", "size": 14347}
{"docstring": "/*\n * Set up the I3_SHMLOG_PATH atom.\n *\n */\n", "func_signal": "void update_shmlog_atom(void)", "code": "{\n    if (*shmlogname == '\\0') {\n        xcb_delete_property(conn, root, A_I3_SHMLOG_PATH);\n    } else {\n        xcb_change_property(conn, XCB_PROP_MODE_REPLACE, root,\n                            A_I3_SHMLOG_PATH, A_UTF8_STRING, 8,\n                            strlen(shmlogname), shmlogname);\n    }\n}", "path": "i3/src/x.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "i3/i3", "stars": 8920, "license": "bsd-3-clause", "language": "c", "size": 14347}
{"docstring": "/*\n * This function pushes the properties of each node of the layout tree to\n * X11 if they have changed (like the map state, position of the window, \u2026).\n * It recursively traverses all children of the given node.\n *\n */\n", "func_signal": "void x_push_node(Con *con)", "code": "{\n    Con *current;\n    con_state *state;\n    Rect rect = con->rect;\n\n    //DLOG(\"Pushing changes for node %p / %s\\n\", con, con->name);\n    state = state_for_frame(con->frame.id);\n\n    if (state->name != NULL) {\n        DLOG(\"pushing name %s for con %p\\n\", state->name, con);\n\n        xcb_change_property(conn, XCB_PROP_MODE_REPLACE, con->frame.id,\n                            XCB_ATOM_WM_NAME, XCB_ATOM_STRING, 8, strlen(state->name), state->name);\n        FREE(state->name);\n    }\n\n    if (con->window == NULL) {\n        /* Calculate the height of all window decorations which will be drawn on to\n         * this frame. */\n        uint32_t max_y = 0, max_height = 0;\n        TAILQ_FOREACH (current, &(con->nodes_head), nodes) {\n            Rect *dr = &(current->deco_rect);\n            if (dr->y >= max_y && dr->height >= max_height) {\n                max_y = dr->y;\n                max_height = dr->height;\n            }\n        }\n        rect.height = max_y + max_height;\n        if (rect.height == 0)\n            con->mapped = false;\n    }\n\n    bool need_reshape = false;\n\n    /* reparent the child window (when the window was moved due to a sticky\n     * container) */\n    if (state->need_reparent && con->window != NULL) {\n        DLOG(\"Reparenting child window\\n\");\n\n        /* Temporarily set the event masks to XCB_NONE so that we won\u2019t get\n         * UnmapNotify events (otherwise the handler would close the container).\n         * These events are generated automatically when reparenting. */\n        uint32_t values[] = {XCB_NONE};\n        xcb_change_window_attributes(conn, state->old_frame, XCB_CW_EVENT_MASK, values);\n        xcb_change_window_attributes(conn, con->window->id, XCB_CW_EVENT_MASK, values);\n\n        xcb_reparent_window(conn, con->window->id, con->frame.id, 0, 0);\n\n        values[0] = FRAME_EVENT_MASK;\n        xcb_change_window_attributes(conn, state->old_frame, XCB_CW_EVENT_MASK, values);\n        values[0] = CHILD_EVENT_MASK;\n        xcb_change_window_attributes(conn, con->window->id, XCB_CW_EVENT_MASK, values);\n\n        state->old_frame = XCB_NONE;\n        state->need_reparent = false;\n\n        con->ignore_unmap++;\n        DLOG(\"ignore_unmap for reparenting of con %p (win 0x%08x) is now %d\\n\",\n             con, con->window->id, con->ignore_unmap);\n\n        need_reshape = true;\n    }\n\n    /* We need to update shape when window frame dimensions is updated. */\n    need_reshape |= state->rect.width != rect.width ||\n                    state->rect.height != rect.height ||\n                    state->window_rect.width != con->window_rect.width ||\n                    state->window_rect.height != con->window_rect.height;\n\n    /* We need to set shape when container becomes floating. */\n    need_reshape |= con_is_floating(con) && !state->was_floating;\n\n    /* The pixmap of a borderless leaf container will not be used except\n     * for the titlebar in a stack or tabs (issue #1013). */\n    bool is_pixmap_needed = (con->border_style != BS_NONE ||\n                             !con_is_leaf(con) ||\n                             con->parent->layout == L_STACKED ||\n                             con->parent->layout == L_TABBED);\n\n    /* The root con and output cons will never require a pixmap. In particular for the\n     * __i3 output, this will likely not work anyway because it might be ridiculously\n     * large, causing an XCB_ALLOC error. */\n    if (con->type == CT_ROOT || con->type == CT_OUTPUT)\n        is_pixmap_needed = false;\n\n    bool fake_notify = false;\n    /* Set new position if rect changed (and if height > 0) or if the pixmap\n     * needs to be recreated */\n    if ((is_pixmap_needed && con->frame_buffer.id == XCB_NONE) || (!rect_equals(state->rect, rect) &&\n                                                                   rect.height > 0)) {\n        /* We first create the new pixmap, then render to it, set it as the\n         * background and only afterwards change the window size. This reduces\n         * flickering. */\n\n        bool has_rect_changed = (state->rect.x != rect.x || state->rect.y != rect.y ||\n                                 state->rect.width != rect.width || state->rect.height != rect.height);\n\n        /* Check if the container has an unneeded pixmap left over from\n         * previously having a border or titlebar. */\n        if (!is_pixmap_needed && con->frame_buffer.id != XCB_NONE) {\n            draw_util_surface_free(conn, &(con->frame_buffer));\n            xcb_free_pixmap(conn, con->frame_buffer.id);\n            con->frame_buffer.id = XCB_NONE;\n        }\n\n        if (is_pixmap_needed && (has_rect_changed || con->frame_buffer.id == XCB_NONE)) {\n            if (con->frame_buffer.id == XCB_NONE) {\n                con->frame_buffer.id = xcb_generate_id(conn);\n            } else {\n                draw_util_surface_free(conn, &(con->frame_buffer));\n                xcb_free_pixmap(conn, con->frame_buffer.id);\n            }\n\n            uint16_t win_depth = root_depth;\n            if (con->window)\n                win_depth = con->window->depth;\n\n            /* Ensure we have valid dimensions for our surface. */\n            // TODO This is probably a bug in the condition above as we should never enter this path\n            //      for height == 0. Also, we should probably handle width == 0 the same way.\n            int width = MAX((int32_t)rect.width, 1);\n            int height = MAX((int32_t)rect.height, 1);\n\n            xcb_create_pixmap(conn, win_depth, con->frame_buffer.id, con->frame.id, width, height);\n            draw_util_surface_init(conn, &(con->frame_buffer), con->frame_buffer.id,\n                                   get_visualtype_by_id(get_visualid_by_depth(win_depth)), width, height);\n\n            /* For the graphics context, we disable GraphicsExposure events.\n             * Those will be sent when a CopyArea request cannot be fulfilled\n             * properly due to parts of the source being unmapped or otherwise\n             * unavailable. Since we always copy from pixmaps to windows, this\n             * is not a concern for us. */\n            xcb_change_gc(conn, con->frame_buffer.gc, XCB_GC_GRAPHICS_EXPOSURES, (uint32_t[]){0});\n\n            draw_util_surface_set_size(&(con->frame), width, height);\n            con->pixmap_recreated = true;\n\n            /* Don\u2019t render the decoration for windows inside a stack which are\n             * not visible right now */\n            // TODO Should this work the same way for L_TABBED?\n            if (!con->parent ||\n                con->parent->layout != L_STACKED ||\n                TAILQ_FIRST(&(con->parent->focus_head)) == con)\n                /* Render the decoration now to make the correct decoration visible\n                 * from the very first moment. Later calls will be cached, so this\n                 * doesn\u2019t hurt performance. */\n                x_deco_recurse(con);\n        }\n\n        DLOG(\"setting rect (%d, %d, %d, %d)\\n\", rect.x, rect.y, rect.width, rect.height);\n        /* flush to ensure that the following commands are sent in a single\n         * buffer and will be processed directly afterwards (the contents of a\n         * window get lost when resizing it, therefore we want to provide it as\n         * fast as possible) */\n        xcb_flush(conn);\n        xcb_set_window_rect(conn, con->frame.id, rect);\n        if (con->frame_buffer.id != XCB_NONE) {\n            draw_util_copy_surface(&(con->frame_buffer), &(con->frame), 0, 0, 0, 0, con->rect.width, con->rect.height);\n        }\n        xcb_flush(conn);\n\n        memcpy(&(state->rect), &rect, sizeof(Rect));\n        fake_notify = true;\n    }\n\n    /* dito, but for child windows */\n    if (con->window != NULL &&\n        !rect_equals(state->window_rect, con->window_rect)) {\n        DLOG(\"setting window rect (%d, %d, %d, %d)\\n\",\n             con->window_rect.x, con->window_rect.y, con->window_rect.width, con->window_rect.height);\n        xcb_set_window_rect(conn, con->window->id, con->window_rect);\n        memcpy(&(state->window_rect), &(con->window_rect), sizeof(Rect));\n        fake_notify = true;\n    }\n\n    set_shape_state(con, need_reshape);\n\n    /* Map if map state changed, also ensure that the child window\n     * is changed if we are mapped and there is a new, unmapped child window.\n     * Unmaps are handled in x_push_node_unmaps(). */\n    if ((state->mapped != con->mapped || (con->window != NULL && !state->child_mapped)) &&\n        con->mapped) {\n        xcb_void_cookie_t cookie;\n\n        if (con->window != NULL) {\n            /* Set WM_STATE_NORMAL because GTK applications don\u2019t want to\n             * drag & drop if we don\u2019t. Also, xprop(1) needs it. */\n            long data[] = {XCB_ICCCM_WM_STATE_NORMAL, XCB_NONE};\n            xcb_change_property(conn, XCB_PROP_MODE_REPLACE, con->window->id,\n                                A_WM_STATE, A_WM_STATE, 32, 2, data);\n        }\n\n        uint32_t values[1];\n        if (!state->child_mapped && con->window != NULL) {\n            cookie = xcb_map_window(conn, con->window->id);\n\n            /* We are interested in EnterNotifys as soon as the window is\n             * mapped */\n            values[0] = CHILD_EVENT_MASK;\n            xcb_change_window_attributes(conn, con->window->id, XCB_CW_EVENT_MASK, values);\n            DLOG(\"mapping child window (serial %d)\\n\", cookie.sequence);\n            state->child_mapped = true;\n        }\n\n        cookie = xcb_map_window(conn, con->frame.id);\n\n        values[0] = FRAME_EVENT_MASK;\n        xcb_change_window_attributes(conn, con->frame.id, XCB_CW_EVENT_MASK, values);\n\n        /* copy the pixmap contents to the frame window immediately after mapping */\n        if (con->frame_buffer.id != XCB_NONE) {\n            draw_util_copy_surface(&(con->frame_buffer), &(con->frame), 0, 0, 0, 0, con->rect.width, con->rect.height);\n        }\n        xcb_flush(conn);\n\n        DLOG(\"mapping container %08x (serial %d)\\n\", con->frame.id, cookie.sequence);\n        state->mapped = con->mapped;\n    }\n\n    state->unmap_now = (state->mapped != con->mapped) && !con->mapped;\n    state->was_floating = con_is_floating(con);\n\n    if (fake_notify) {\n        DLOG(\"Sending fake configure notify\\n\");\n        fake_absolute_configure_notify(con);\n    }\n\n    set_hidden_state(con);\n\n    /* Handle all children and floating windows of this node. We recurse\n     * in focus order to display the focused client in a stack first when\n     * switching workspaces (reduces flickering). */\n    TAILQ_FOREACH (current, &(con->focus_head), focused) {\n        x_push_node(current);\n    }\n}", "path": "i3/src/x.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "i3/i3", "stars": 8920, "license": "bsd-3-clause", "language": "c", "size": 14347}
{"docstring": "/**\n * g_utf8_make_valid:\n * @str: string to coerce into UTF-8\n * @len: the maximum length of @str to use, in bytes. If @len < 0,\n *     then the string is nul-terminated.\n *\n * If the provided string is valid UTF-8, return a copy of it. If not,\n * return a copy in which bytes that could not be interpreted as valid Unicode\n * are replaced with the Unicode replacement character (U+FFFD).\n *\n * For example, this is an appropriate function to use if you have received\n * a string that was incorrectly declared to be UTF-8, and you need a valid\n * UTF-8 version of it that can be logged or displayed to the user, with the\n * assumption that it is close enough to ASCII or UTF-8 to be mostly\n * readable as-is.\n *\n * Returns: (transfer full): a valid UTF-8 string whose content resembles @str\n *\n * Since: 2.52\n */\n", "func_signal": "gchar *\ng_utf8_make_valid (const gchar *str,\n                   gssize       len)", "code": "{\n  GString *string;\n  const gchar *remainder, *invalid;\n  gsize remaining_bytes, valid_bytes;\n\n  g_return_val_if_fail (str != NULL, NULL);\n\n  if (len < 0)\n    len = strlen (str);\n\n  string = NULL;\n  remainder = str;\n  remaining_bytes = len;\n\n  while (remaining_bytes != 0)\n    {\n      if (g_utf8_validate (remainder, remaining_bytes, &invalid))\n\tbreak;\n      valid_bytes = invalid - remainder;\n\n      if (string == NULL)\n\tstring = g_string_sized_new (remaining_bytes);\n\n      g_string_append_len (string, remainder, valid_bytes);\n      /* append U+FFFD REPLACEMENT CHARACTER */\n      g_string_append (string, \"\\357\\277\\275\");\n\n      remaining_bytes -= valid_bytes + 1;\n      remainder = invalid + 1;\n    }\n\n  if (string == NULL)\n    return g_strndup (str, len);\n\n  g_string_append_len (string, remainder, remaining_bytes);\n  g_string_append_c (string, '\\0');\n\n  g_assert (g_utf8_validate (string->str, -1, NULL));\n\n  return g_string_free (string, FALSE);\n}", "path": "i3/libi3/g_utf8_make_valid.c", "commit_date": "2020-04-19 00:00:00", "repo_name": "i3/i3", "stars": 8920, "license": "bsd-3-clause", "language": "c", "size": 14347}
{"docstring": "/*\n * Reset the container frame shape.\n */\n", "func_signal": "static void x_unshape_frame(Con *con, xcb_shape_sk_t shape_kind)", "code": "{\n    assert(con->window);\n\n    xcb_shape_mask(conn, XCB_SHAPE_SO_SET, shape_kind, con->frame.id, 0, 0, XCB_PIXMAP_NONE);\n}", "path": "i3/src/x.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "i3/i3", "stars": 8920, "license": "bsd-3-clause", "language": "c", "size": 14347}
{"docstring": "/*\n * Converts the given string to UCS-2 big endian for use with\n * xcb_image_text_16(). The amount of real glyphs is stored in real_strlen,\n * a buffer containing the UCS-2 encoded string (16 bit per glyph) is\n * returned. It has to be freed when done.\n *\n */\n", "func_signal": "xcb_char2b_t *convert_utf8_to_ucs2(char *input, size_t *real_strlen)", "code": "{\n    /* Calculate the input buffer size (UTF-8 is strlen-safe) */\n    size_t input_size = strlen(input);\n\n    /* Calculate the output buffer size and allocate the buffer */\n    size_t buffer_size = input_size * sizeof(xcb_char2b_t);\n    xcb_char2b_t *buffer = smalloc(buffer_size);\n\n    /* We need to use an additional pointer, because iconv() modifies it */\n    size_t output_bytes_left = buffer_size;\n    xcb_char2b_t *output = buffer;\n\n    if (ucs2_conversion_descriptor == (iconv_t)-1) {\n        /* Get a new conversion descriptor. //IGNORE is a GNU suffix that makes\n         * iconv to silently discard characters that cannot be represented in\n         * the target character set. */\n        ucs2_conversion_descriptor = iconv_open(\"UCS-2BE//IGNORE\", \"UTF-8\");\n        if (ucs2_conversion_descriptor == (iconv_t)-1) {\n            ucs2_conversion_descriptor = iconv_open(\"UCS-2BE\", \"UTF-8\");\n        }\n        if (ucs2_conversion_descriptor == (iconv_t)-1) {\n            err(EXIT_FAILURE, \"Error opening the conversion context\");\n        }\n    } else {\n        /* Reset the existing conversion descriptor */\n        iconv(ucs2_conversion_descriptor, NULL, NULL, NULL, NULL);\n    }\n\n    /* Do the conversion */\n    size_t rc = iconv(ucs2_conversion_descriptor, &input, &input_size,\n                      (char **)&output, &output_bytes_left);\n    if (rc == (size_t)-1) {\n        /* Conversion will only be partial. */\n        perror(\"Converting to UCS-2 failed\");\n    }\n\n    /* If no bytes where converted, this is equivalent to freeing buffer. */\n    buffer_size -= output_bytes_left;\n    buffer = srealloc(buffer, buffer_size);\n\n    /* Return the resulting string's length */\n    if (real_strlen != NULL) {\n        *real_strlen = buffer_size / sizeof(xcb_char2b_t);\n    }\n\n    return buffer;\n}", "path": "i3/libi3/ucs2_conversion.c", "commit_date": "2020-04-20 00:00:00", "repo_name": "i3/i3", "stars": 8920, "license": "bsd-3-clause", "language": "c", "size": 14347}
{"docstring": "/*\n * Draws the decoration of the given container onto its parent.\n *\n */\n", "func_signal": "void x_draw_decoration(Con *con)", "code": "{\n    Con *parent = con->parent;\n    bool leaf = con_is_leaf(con);\n\n    /* This code needs to run for:\n     *  \u2022 leaf containers\n     *  \u2022 non-leaf containers which are in a stacked/tabbed container\n     *\n     * It does not need to run for:\n     *  \u2022 direct children of outputs or dockareas\n     *  \u2022 floating containers (they don\u2019t have a decoration)\n     */\n    if ((!leaf &&\n         parent->layout != L_STACKED &&\n         parent->layout != L_TABBED) ||\n        parent->type == CT_OUTPUT ||\n        parent->type == CT_DOCKAREA ||\n        con->type == CT_FLOATING_CON)\n        return;\n\n    /* Skip containers whose height is 0 (for example empty dockareas) */\n    if (con->rect.height == 0)\n        return;\n\n    /* Skip containers whose pixmap has not yet been created (can happen when\n     * decoration rendering happens recursively for a window for which\n     * x_push_node() was not yet called) */\n    if (leaf && con->frame_buffer.id == XCB_NONE)\n        return;\n\n    /* 1: build deco_params and compare with cache */\n    struct deco_render_params *p = scalloc(1, sizeof(struct deco_render_params));\n\n    /* find out which colors to use */\n    if (con->urgent)\n        p->color = &config.client.urgent;\n    else if (con == focused || con_inside_focused(con))\n        p->color = &config.client.focused;\n    else if (con == TAILQ_FIRST(&(parent->focus_head)))\n        p->color = &config.client.focused_inactive;\n    else\n        p->color = &config.client.unfocused;\n\n    p->border_style = con_border_style(con);\n\n    Rect *r = &(con->rect);\n    Rect *w = &(con->window_rect);\n    p->con_rect = (struct width_height){r->width, r->height};\n    p->con_window_rect = (struct width_height){w->width, w->height};\n    p->con_deco_rect = con->deco_rect;\n    p->background = config.client.background;\n    p->con_is_leaf = con_is_leaf(con);\n    p->parent_layout = con->parent->layout;\n\n    if (con->deco_render_params != NULL &&\n        (con->window == NULL || !con->window->name_x_changed) &&\n        !parent->pixmap_recreated &&\n        !con->pixmap_recreated &&\n        !con->mark_changed &&\n        memcmp(p, con->deco_render_params, sizeof(struct deco_render_params)) == 0) {\n        free(p);\n        goto copy_pixmaps;\n    }\n\n    Con *next = con;\n    while ((next = TAILQ_NEXT(next, nodes))) {\n        FREE(next->deco_render_params);\n    }\n\n    FREE(con->deco_render_params);\n    con->deco_render_params = p;\n\n    if (con->window != NULL && con->window->name_x_changed)\n        con->window->name_x_changed = false;\n\n    parent->pixmap_recreated = false;\n    con->pixmap_recreated = false;\n    con->mark_changed = false;\n\n    /* 2: draw the client.background, but only for the parts around the window_rect */\n    if (con->window != NULL) {\n        /* top area */\n        draw_util_rectangle(&(con->frame_buffer), config.client.background,\n                            0, 0, r->width, w->y);\n        /* bottom area */\n        draw_util_rectangle(&(con->frame_buffer), config.client.background,\n                            0, w->y + w->height, r->width, r->height - (w->y + w->height));\n        /* left area */\n        draw_util_rectangle(&(con->frame_buffer), config.client.background,\n                            0, 0, w->x, r->height);\n        /* right area */\n        draw_util_rectangle(&(con->frame_buffer), config.client.background,\n                            w->x + w->width, 0, r->width - (w->x + w->width), r->height);\n    }\n\n    /* 3: draw a rectangle in border color around the client */\n    if (p->border_style != BS_NONE && p->con_is_leaf) {\n        /* Fill the border. We don\u2019t just fill the whole rectangle because some\n         * children are not freely resizable and we want their background color\n         * to \"shine through\". */\n        xcb_rectangle_t rectangles[4];\n        size_t rectangles_count = x_get_border_rectangles(con, rectangles);\n        for (size_t i = 0; i < rectangles_count; i++) {\n            draw_util_rectangle(&(con->frame_buffer), p->color->child_border,\n                                rectangles[i].x,\n                                rectangles[i].y,\n                                rectangles[i].width,\n                                rectangles[i].height);\n        }\n\n        /* Highlight the side of the border at which the next window will be\n         * opened if we are rendering a single window within a split container\n         * (which is undistinguishable from a single window outside a split\n         * container otherwise. */\n        Rect br = con_border_style_rect(con);\n        if (TAILQ_NEXT(con, nodes) == NULL &&\n            TAILQ_PREV(con, nodes_head, nodes) == NULL &&\n            con->parent->type != CT_FLOATING_CON) {\n            if (p->parent_layout == L_SPLITH) {\n                draw_util_rectangle(&(con->frame_buffer), p->color->indicator,\n                                    r->width + (br.width + br.x), br.y, -(br.width + br.x), r->height + br.height);\n            } else if (p->parent_layout == L_SPLITV) {\n                draw_util_rectangle(&(con->frame_buffer), p->color->indicator,\n                                    br.x, r->height + (br.height + br.y), r->width + br.width, -(br.height + br.y));\n            }\n        }\n    }\n\n    /* If the parent hasn't been set up yet, skip the decoration rendering\n     * for now. */\n    if (parent->frame_buffer.id == XCB_NONE)\n        goto copy_pixmaps;\n\n    /* For the first child, we clear the parent pixmap to ensure there's no\n     * garbage left on there. This is important to avoid tearing when using\n     * transparency. */\n    if (con == TAILQ_FIRST(&(con->parent->nodes_head))) {\n        draw_util_clear_surface(&(con->parent->frame_buffer), COLOR_TRANSPARENT);\n        FREE(con->parent->deco_render_params);\n    }\n\n    /* if this is a borderless/1pixel window, we don\u2019t need to render the\n     * decoration. */\n    if (p->border_style != BS_NORMAL)\n        goto copy_pixmaps;\n\n    /* 4: paint the bar */\n    draw_util_rectangle(&(parent->frame_buffer), p->color->background,\n                        con->deco_rect.x, con->deco_rect.y, con->deco_rect.width, con->deco_rect.height);\n\n    /* 5: draw title border */\n    x_draw_title_border(con, p);\n\n    /* 6: draw the title */\n    int text_offset_y = (con->deco_rect.height - config.font.height) / 2;\n\n    const int title_padding = logical_px(2);\n    const int deco_width = (int)con->deco_rect.width;\n    int mark_width = 0;\n    if (config.show_marks && !TAILQ_EMPTY(&(con->marks_head))) {\n        char *formatted_mark = sstrdup(\"\");\n        bool had_visible_mark = false;\n\n        mark_t *mark;\n        TAILQ_FOREACH (mark, &(con->marks_head), marks) {\n            if (mark->name[0] == '_')\n                continue;\n            had_visible_mark = true;\n\n            char *buf;\n            sasprintf(&buf, \"%s[%s]\", formatted_mark, mark->name);\n            free(formatted_mark);\n            formatted_mark = buf;\n        }\n\n        if (had_visible_mark) {\n            i3String *mark = i3string_from_utf8(formatted_mark);\n            mark_width = predict_text_width(mark);\n\n            int mark_offset_x = (config.title_align == ALIGN_RIGHT)\n                                    ? title_padding\n                                    : deco_width - mark_width - title_padding;\n\n            draw_util_text(mark, &(parent->frame_buffer),\n                           p->color->text, p->color->background,\n                           con->deco_rect.x + mark_offset_x,\n                           con->deco_rect.y + text_offset_y, mark_width);\n            I3STRING_FREE(mark);\n\n            mark_width += title_padding;\n        }\n\n        FREE(formatted_mark);\n    }\n\n    i3String *title = NULL;\n    struct Window *win = con->window;\n    if (win == NULL) {\n        if (con->title_format == NULL) {\n            char *_title;\n            char *tree = con_get_tree_representation(con);\n            sasprintf(&_title, \"i3: %s\", tree);\n            free(tree);\n\n            title = i3string_from_utf8(_title);\n            FREE(_title);\n        } else {\n            title = con_parse_title_format(con);\n        }\n    } else {\n        title = con->title_format == NULL ? win->name : con_parse_title_format(con);\n    }\n    if (title == NULL) {\n        goto copy_pixmaps;\n    }\n\n    int title_offset_x;\n    switch (config.title_align) {\n        case ALIGN_LEFT:\n            /* (pad)[text    ](pad)[mark + its pad) */\n            title_offset_x = title_padding;\n            break;\n        case ALIGN_CENTER:\n            /* (pad)[  text  ](pad)[mark + its pad)\n             * To center the text inside its allocated space, the surface\n             * between the brackets, we use the formula\n             * (surface_width - predict_text_width) / 2\n             * where surface_width = deco_width - 2 * pad - mark_width\n             * so, offset = pad + (surface_width - predict_text_width) / 2 =\n             * = \u2026 = (deco_width - mark_width - predict_text_width) / 2 */\n            title_offset_x = max(title_padding, (deco_width - mark_width - predict_text_width(title)) / 2);\n            break;\n        case ALIGN_RIGHT:\n            /* [mark + its pad](pad)[    text](pad) */\n            title_offset_x = max(title_padding + mark_width, deco_width - title_padding - predict_text_width(title));\n            break;\n    }\n\n    draw_util_text(title, &(parent->frame_buffer),\n                   p->color->text, p->color->background,\n                   con->deco_rect.x + title_offset_x,\n                   con->deco_rect.y + text_offset_y,\n                   deco_width - mark_width - 2 * title_padding);\n\n    if (win == NULL || con->title_format != NULL) {\n        I3STRING_FREE(title);\n    }\n\n    x_draw_decoration_after_title(con, p);\ncopy_pixmaps:\n    draw_util_copy_surface(&(con->frame_buffer), &(con->frame), 0, 0, 0, 0, con->rect.width, con->rect.height);\n}", "path": "i3/src/x.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "i3/i3", "stars": 8920, "license": "bsd-3-clause", "language": "c", "size": 14347}
{"docstring": "/*\n * Raises the specified container in the internal stack of X windows. The\n * next call to x_push_changes() will make the change visible in X11.\n *\n */\n", "func_signal": "void x_raise_con(Con *con)", "code": "{\n    con_state *state;\n    state = state_for_frame(con->frame.id);\n    //DLOG(\"raising in new stack: %p / %s / %s / xid %08x\\n\", con, con->name, con->window ? con->window->name_json : \"\", state->id);\n\n    CIRCLEQ_REMOVE(&state_head, state, state);\n    CIRCLEQ_INSERT_HEAD(&state_head, state, state);\n}", "path": "i3/src/x.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "i3/i3", "stars": 8920, "license": "bsd-3-clause", "language": "c", "size": 14347}
{"docstring": "/*\n * Having verboselog(), errorlog() and debuglog() is necessary when using libi3.\n *\n */\n", "func_signal": "void verboselog(char *fmt, ...)", "code": "{\n    va_list args;\n\n    va_start(args, fmt);\n    vfprintf(stdout, fmt, args);\n    va_end(args);\n}", "path": "i3/i3-config-wizard/main.c", "commit_date": "2020-05-17 00:00:00", "repo_name": "i3/i3", "stars": 8920, "license": "bsd-3-clause", "language": "c", "size": 14347}
{"docstring": "/*\n * Enables or disables nonrectangular shape of the container frame.\n */\n", "func_signal": "void x_set_shape(Con *con, xcb_shape_sk_t kind, bool enable)", "code": "{\n    struct con_state *state;\n    if ((state = state_for_frame(con->frame.id)) == NULL) {\n        ELOG(\"window state for con %p not found\\n\", con);\n        return;\n    }\n\n    switch (kind) {\n        case XCB_SHAPE_SK_BOUNDING:\n            con->window->shaped = enable;\n            break;\n        case XCB_SHAPE_SK_INPUT:\n            con->window->input_shaped = enable;\n            break;\n        default:\n            ELOG(\"Received unknown shape event kind for con %p. This is a bug.\\n\",\n                 con);\n            return;\n    }\n\n    if (con_is_floating(con)) {\n        if (enable) {\n            x_shape_frame(con, kind);\n        } else {\n            x_unshape_frame(con, kind);\n        }\n\n        xcb_flush(conn);\n    }\n}", "path": "i3/src/x.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "i3/i3", "stars": 8920, "license": "bsd-3-clause", "language": "c", "size": 14347}
{"docstring": "/*\n * Same idea as in x_push_node(), but this function only unmaps windows. It is\n * necessary to split this up to handle new fullscreen clients properly: The\n * new window needs to be mapped and focus needs to be set *before* the\n * underlying windows are unmapped. Otherwise, focus will revert to the\n * PointerRoot and will then be set to the new window, generating unnecessary\n * FocusIn/FocusOut events.\n *\n */\n", "func_signal": "static void x_push_node_unmaps(Con *con)", "code": "{\n    Con *current;\n    con_state *state;\n\n    //DLOG(\"Pushing changes (with unmaps) for node %p / %s\\n\", con, con->name);\n    state = state_for_frame(con->frame.id);\n\n    /* map/unmap if map state changed, also ensure that the child window\n     * is changed if we are mapped *and* in initial state (meaning the\n     * container was empty before, but now got a child) */\n    if (state->unmap_now) {\n        xcb_void_cookie_t cookie;\n        if (con->window != NULL) {\n            /* Set WM_STATE_WITHDRAWN, it seems like Java apps need it */\n            long data[] = {XCB_ICCCM_WM_STATE_WITHDRAWN, XCB_NONE};\n            xcb_change_property(conn, XCB_PROP_MODE_REPLACE, con->window->id,\n                                A_WM_STATE, A_WM_STATE, 32, 2, data);\n        }\n\n        cookie = xcb_unmap_window(conn, con->frame.id);\n        DLOG(\"unmapping container %p / %s (serial %d)\\n\", con, con->name, cookie.sequence);\n        /* we need to increase ignore_unmap for this container (if it\n         * contains a window) and for every window \"under\" this one which\n         * contains a window */\n        if (con->window != NULL) {\n            con->ignore_unmap++;\n            DLOG(\"ignore_unmap for con %p (frame 0x%08x) now %d\\n\", con, con->frame.id, con->ignore_unmap);\n        }\n        state->mapped = con->mapped;\n    }\n\n    /* handle all children and floating windows of this node */\n    TAILQ_FOREACH (current, &(con->nodes_head), nodes) {\n        x_push_node_unmaps(current);\n    }\n\n    TAILQ_FOREACH (current, &(con->floating_head), floating_windows) {\n        x_push_node_unmaps(current);\n    }\n}", "path": "i3/src/x.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "i3/i3", "stars": 8920, "license": "bsd-3-clause", "language": "c", "size": 14347}
{"docstring": "/*\n * Returns true if the given container is currently attached to its parent.\n *\n * TODO: Remove once #1185 has been fixed\n */\n", "func_signal": "static bool is_con_attached(Con *con)", "code": "{\n    if (con->parent == NULL)\n        return false;\n\n    Con *current;\n    TAILQ_FOREACH (current, &(con->parent->nodes_head), nodes) {\n        if (current == con)\n            return true;\n    }\n\n    return false;\n}", "path": "i3/src/x.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "i3/i3", "stars": 8920, "license": "bsd-3-clause", "language": "c", "size": 14347}
{"docstring": "/*\n * Recursively calls x_draw_decoration. This cannot be done in x_push_node\n * because x_push_node uses focus order to recurse (see the comment above)\n * while drawing the decoration needs to happen in the actual order.\n *\n */\n", "func_signal": "void x_deco_recurse(Con *con)", "code": "{\n    Con *current;\n    bool leaf = TAILQ_EMPTY(&(con->nodes_head)) &&\n                TAILQ_EMPTY(&(con->floating_head));\n    con_state *state = state_for_frame(con->frame.id);\n\n    if (!leaf) {\n        TAILQ_FOREACH (current, &(con->nodes_head), nodes) {\n            x_deco_recurse(current);\n        }\n\n        TAILQ_FOREACH (current, &(con->floating_head), floating_windows) {\n            x_deco_recurse(current);\n        }\n\n        if (state->mapped) {\n            draw_util_copy_surface(&(con->frame_buffer), &(con->frame), 0, 0, 0, 0, con->rect.width, con->rect.height);\n        }\n    }\n\n    if ((con->type != CT_ROOT && con->type != CT_OUTPUT) &&\n        (!leaf || con->mapped))\n        x_draw_decoration(con);\n}", "path": "i3/src/x.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "i3/i3", "stars": 8920, "license": "bsd-3-clause", "language": "c", "size": 14347}
{"docstring": "/*\n * Handle button presses to make clicking on \"<win>\" and \"<alt>\" work\n *\n */\n", "func_signal": "static void handle_button_press(xcb_button_press_event_t *event)", "code": "{\n    if (current_step != STEP_GENERATE)\n        return;\n\n    if (event->event_x < col_x(5) || event->event_x > col_x(10))\n        return;\n\n    if (event->event_y >= row_y(4) && event->event_y <= (row_y(4) + font.height)) {\n        modifier = MOD_Mod4;\n        handle_expose();\n    }\n\n    if (event->event_y >= row_y(5) && event->event_y <= (row_y(5) + font.height)) {\n        modifier = MOD_Mod1;\n        handle_expose();\n    }\n}", "path": "i3/i3-config-wizard/main.c", "commit_date": "2020-05-17 00:00:00", "repo_name": "i3/i3", "stars": 8920, "license": "bsd-3-clause", "language": "c", "size": 14347}
{"docstring": "/*\n * Kills the given X11 window using WM_DELETE_WINDOW (if supported).\n *\n */\n", "func_signal": "void x_window_kill(xcb_window_t window, kill_window_t kill_window)", "code": "{\n    /* if this window does not support WM_DELETE_WINDOW, we kill it the hard way */\n    if (!window_supports_protocol(window, A_WM_DELETE_WINDOW)) {\n        if (kill_window == KILL_WINDOW) {\n            LOG(\"Killing specific window 0x%08x\\n\", window);\n            xcb_destroy_window(conn, window);\n        } else {\n            LOG(\"Killing the X11 client which owns window 0x%08x\\n\", window);\n            xcb_kill_client(conn, window);\n        }\n        return;\n    }\n\n    /* Every X11 event is 32 bytes long. Therefore, XCB will copy 32 bytes.\n     * In order to properly initialize these bytes, we allocate 32 bytes even\n     * though we only need less for an xcb_configure_notify_event_t */\n    void *event = scalloc(32, 1);\n    xcb_client_message_event_t *ev = event;\n\n    ev->response_type = XCB_CLIENT_MESSAGE;\n    ev->window = window;\n    ev->type = A_WM_PROTOCOLS;\n    ev->format = 32;\n    ev->data.data32[0] = A_WM_DELETE_WINDOW;\n    ev->data.data32[1] = XCB_CURRENT_TIME;\n\n    LOG(\"Sending WM_DELETE to the client\\n\");\n    xcb_send_event(conn, false, window, XCB_EVENT_MASK_NO_EVENT, (char *)ev);\n    xcb_flush(conn);\n    free(event);\n}", "path": "i3/src/x.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "i3/i3", "stars": 8920, "license": "bsd-3-clause", "language": "c", "size": 14347}
{"docstring": "/*\n * Shape or unshape container frame based on the con state.\n */\n", "func_signal": "static void set_shape_state(Con *con, bool need_reshape)", "code": "{\n    if (!shape_supported || con->window == NULL) {\n        return;\n    }\n\n    struct con_state *state;\n    if ((state = state_for_frame(con->frame.id)) == NULL) {\n        ELOG(\"window state for con %p not found\\n\", con);\n        return;\n    }\n\n    if (need_reshape && con_is_floating(con)) {\n        /* We need to reshape the window frame only if it already has shape. */\n        if (con->window->shaped) {\n            x_shape_frame(con, XCB_SHAPE_SK_BOUNDING);\n        }\n        if (con->window->input_shaped) {\n            x_shape_frame(con, XCB_SHAPE_SK_INPUT);\n        }\n    }\n\n    if (state->was_floating && !con_is_floating(con)) {\n        /* Remove the shape when container is no longer floating. */\n        if (con->window->shaped) {\n            x_unshape_frame(con, XCB_SHAPE_SK_BOUNDING);\n        }\n        if (con->window->input_shaped) {\n            x_unshape_frame(con, XCB_SHAPE_SK_INPUT);\n        }\n    }\n}", "path": "i3/src/x.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "i3/i3", "stars": 8920, "license": "bsd-3-clause", "language": "c", "size": 14347}
{"docstring": "/*\n * Converts the given string to UTF-8 from UCS-2 big endian. The return value\n * must be freed after use.\n *\n */\n", "func_signal": "char *convert_ucs2_to_utf8(xcb_char2b_t *text, size_t num_glyphs)", "code": "{\n    /* Allocate the output buffer (UTF-8 is at most 4 bytes per glyph) */\n    size_t buffer_size = num_glyphs * 4 + 1;\n    char *buffer = scalloc(buffer_size, 1);\n\n    /* We need to use an additional pointer, because iconv() modifies it */\n    char *output = buffer;\n    size_t output_size = buffer_size - 1;\n\n    if (utf8_conversion_descriptor == (iconv_t)-1) {\n        /* Get a new conversion descriptor */\n        utf8_conversion_descriptor = iconv_open(\"UTF-8\", \"UCS-2BE\");\n        if (utf8_conversion_descriptor == (iconv_t)-1)\n            err(EXIT_FAILURE, \"Error opening the conversion context\");\n    } else {\n        /* Reset the existing conversion descriptor */\n        iconv(utf8_conversion_descriptor, NULL, NULL, NULL, NULL);\n    }\n\n    /* Do the conversion */\n    size_t input_len = num_glyphs * sizeof(xcb_char2b_t);\n    size_t rc = iconv(utf8_conversion_descriptor, (char **)&text,\n                      &input_len, &output, &output_size);\n    if (rc == (size_t)-1) {\n        perror(\"Converting to UTF-8 failed\");\n        free(buffer);\n        return NULL;\n    }\n\n    return buffer;\n}", "path": "i3/libi3/ucs2_conversion.c", "commit_date": "2020-04-20 00:00:00", "repo_name": "i3/i3", "stars": 8920, "license": "bsd-3-clause", "language": "c", "size": 14347}
{"docstring": "/*\n * Reparents the child window of the given container (necessary for sticky\n * containers). The reparenting happens in the next call of x_push_changes().\n *\n */\n", "func_signal": "void x_reparent_child(Con *con, Con *old)", "code": "{\n    struct con_state *state;\n    if ((state = state_for_frame(con->frame.id)) == NULL) {\n        ELOG(\"window state for con not found\\n\");\n        return;\n    }\n\n    state->need_reparent = true;\n    state->old_frame = old->frame.id;\n}", "path": "i3/src/x.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "i3/i3", "stars": 8920, "license": "bsd-3-clause", "language": "c", "size": 14347}
{"docstring": "/* ===============================================================\n *\n *                              STYLE\n *\n * ===============================================================*/\n", "func_signal": "NK_API void nk_style_default(struct nk_context *ctx)", "code": "{nk_style_from_table(ctx, 0);}\n#define NK_COLOR_MAP(NK_COLOR)\\\n    NK_COLOR(NK_COLOR_TEXT,                     175,175,175,255) \\\n    NK_COLOR(NK_COLOR_WINDOW,                   45, 45, 45, 255) \\\n    NK_COLOR(NK_COLOR_HEADER,                   40, 40, 40, 255) \\\n    NK_COLOR(NK_COLOR_BORDER,                   65, 65, 65, 255) \\\n    NK_COLOR(NK_COLOR_BUTTON,                   50, 50, 50, 255) \\\n    NK_COLOR(NK_COLOR_BUTTON_HOVER,             40, 40, 40, 255) \\\n    NK_COLOR(NK_COLOR_BUTTON_ACTIVE,            35, 35, 35, 255) \\\n    NK_COLOR(NK_COLOR_TOGGLE,                   100,100,100,255) \\\n    NK_COLOR(NK_COLOR_TOGGLE_HOVER,             120,120,120,255) \\\n    NK_COLOR(NK_COLOR_TOGGLE_CURSOR,            45, 45, 45, 255) \\\n    NK_COLOR(NK_COLOR_SELECT,                   45, 45, 45, 255) \\\n    NK_COLOR(NK_COLOR_SELECT_ACTIVE,            35, 35, 35,255) \\\n    NK_COLOR(NK_COLOR_SLIDER,                   38, 38, 38, 255) \\\n    NK_COLOR(NK_COLOR_SLIDER_CURSOR,            100,100,100,255) \\\n    NK_COLOR(NK_COLOR_SLIDER_CURSOR_HOVER,      120,120,120,255) \\\n    NK_COLOR(NK_COLOR_SLIDER_CURSOR_ACTIVE,     150,150,150,255) \\\n    NK_COLOR(NK_COLOR_PROPERTY,                 38, 38, 38, 255) \\\n    NK_COLOR(NK_COLOR_EDIT,                     38, 38, 38, 255)  \\\n    NK_COLOR(NK_COLOR_EDIT_CURSOR,              175,175,175,255) \\\n    NK_COLOR(NK_COLOR_COMBO,                    45, 45, 45, 255) \\\n    NK_COLOR(NK_COLOR_CHART,                    120,120,120,255) \\\n    NK_COLOR(NK_COLOR_CHART_COLOR,              45, 45, 45, 255) \\\n    NK_COLOR(NK_COLOR_CHART_COLOR_HIGHLIGHT,    255, 0,  0, 255) \\\n    NK_COLOR(NK_COLOR_SCROLLBAR,                40, 40, 40, 255) \\\n    NK_COLOR(NK_COLOR_SCROLLBAR_CURSOR,         100,100,100,255) \\\n    NK_COLOR(NK_COLOR_SCROLLBAR_CURSOR_HOVER,   120,120,120,255) \\\n    NK_COLOR(NK_COLOR_SCROLLBAR_CURSOR_ACTIVE,  150,150,150,255) \\\n    NK_COLOR(NK_COLOR_TAB_HEADER,               40, 40, 40,255)\n\nNK_GLOBAL const struct nk_color\nnk_default_color_style[NK_COLOR_COUNT] = {\n#define NK_COLOR(a,b,c,d,e) {b,c,d,e},\n    NK_COLOR_MAP(NK_COLOR)\n#undef NK_COLOR\n}", "path": "nuklear/src/nuklear_style.c", "commit_date": "2018-04-14 00:00:00", "repo_name": "vurtun/nuklear", "stars": 13631, "license": "None", "language": "c", "size": 12127}
{"docstring": "/* ===============================================================\n *\n *                              TABLE\n *\n * ===============================================================*/\n", "func_signal": "NK_LIB struct nk_table*\nnk_create_table(struct nk_context *ctx)", "code": "{\n    struct nk_page_element *elem;\n    elem = nk_create_page_element(ctx);\n    if (!elem) return 0;\n    nk_zero_struct(*elem);\n    return &elem->data.tbl;\n}", "path": "nuklear/src/nuklear_table.c", "commit_date": "2018-04-02 00:00:00", "repo_name": "vurtun/nuklear", "stars": 13631, "license": "None", "language": "c", "size": 12127}
{"docstring": "/* ==============================================================\n *\n *                          COMBO\n *\n * ===============================================================*/\n", "func_signal": "NK_INTERN int\nnk_combo_begin(struct nk_context *ctx, struct nk_window *win,\n    struct nk_vec2 size, int is_clicked, struct nk_rect header)", "code": "{\n    struct nk_window *popup;\n    int is_open = 0;\n    int is_active = 0;\n    struct nk_rect body;\n    nk_hash hash;\n\n    NK_ASSERT(ctx);\n    NK_ASSERT(ctx->current);\n    NK_ASSERT(ctx->current->layout);\n    if (!ctx || !ctx->current || !ctx->current->layout)\n        return 0;\n\n    popup = win->popup.win;\n    body.x = header.x;\n    body.w = size.x;\n    body.y = header.y + header.h-ctx->style.window.combo_border;\n    body.h = size.y;\n\n    hash = win->popup.combo_count++;\n    is_open = (popup) ? nk_true:nk_false;\n    is_active = (popup && (win->popup.name == hash) && win->popup.type == NK_PANEL_COMBO);\n    if ((is_clicked && is_open && !is_active) || (is_open && !is_active) ||\n        (!is_open && !is_active && !is_clicked)) return 0;\n    if (!nk_nonblock_begin(ctx, 0, body,\n        (is_clicked && is_open)?nk_rect(0,0,0,0):header, NK_PANEL_COMBO)) return 0;\n\n    win->popup.type = NK_PANEL_COMBO;\n    win->popup.name = hash;\n    return 1;\n}", "path": "nuklear/src/nuklear_combo.c", "commit_date": "2018-04-02 00:00:00", "repo_name": "vurtun/nuklear", "stars": 13631, "license": "None", "language": "c", "size": 12127}
{"docstring": "/* ===============================================================\n *\n *                          EDIT\n *\n * ===============================================================*/\n", "func_signal": "NK_LIB void\nnk_edit_draw_text(struct nk_command_buffer *out,\n    const struct nk_style_edit *style, float pos_x, float pos_y,\n    float x_offset, const char *text, int byte_len, float row_height,\n    const struct nk_user_font *font, struct nk_color background,\n    struct nk_color foreground, int is_selected)", "code": "{\n    NK_ASSERT(out);\n    NK_ASSERT(font);\n    NK_ASSERT(style);\n    if (!text || !byte_len || !out || !style) return;\n\n    {int glyph_len = 0;\n    nk_rune unicode = 0;\n    int text_len = 0;\n    float line_width = 0;\n    float glyph_width;\n    const char *line = text;\n    float line_offset = 0;\n    int line_count = 0;\n\n    struct nk_text txt;\n    txt.padding = nk_vec2(0,0);\n    txt.background = background;\n    txt.text = foreground;\n\n    glyph_len = nk_utf_decode(text+text_len, &unicode, byte_len-text_len);\n    if (!glyph_len) return;\n    while ((text_len < byte_len) && glyph_len)\n    {\n        if (unicode == '\\n') {\n            /* new line separator so draw previous line */\n            struct nk_rect label;\n            label.y = pos_y + line_offset;\n            label.h = row_height;\n            label.w = line_width;\n            label.x = pos_x;\n            if (!line_count)\n                label.x += x_offset;\n\n            if (is_selected) /* selection needs to draw different background color */\n                nk_fill_rect(out, label, 0, background);\n            nk_widget_text(out, label, line, (int)((text + text_len) - line),\n                &txt, NK_TEXT_CENTERED, font);\n\n            text_len++;\n            line_count++;\n            line_width = 0;\n            line = text + text_len;\n            line_offset += row_height;\n            glyph_len = nk_utf_decode(text + text_len, &unicode, (int)(byte_len-text_len));\n            continue;\n        }\n        if (unicode == '\\r') {\n            text_len++;\n            glyph_len = nk_utf_decode(text + text_len, &unicode, byte_len-text_len);\n            continue;\n        }\n        glyph_width = font->width(font->userdata, font->height, text+text_len, glyph_len);\n        line_width += (float)glyph_width;\n        text_len += glyph_len;\n        glyph_len = nk_utf_decode(text + text_len, &unicode, byte_len-text_len);\n        continue;\n    }\n    if (line_width > 0) {\n        /* draw last line */\n        struct nk_rect label;\n        label.y = pos_y + line_offset;\n        label.h = row_height;\n        label.w = line_width;\n        label.x = pos_x;\n        if (!line_count)\n            label.x += x_offset;\n\n        if (is_selected)\n            nk_fill_rect(out, label, 0, background);\n        nk_widget_text(out, label, line, (int)((text + text_len) - line),\n            &txt, NK_TEXT_LEFT, font);\n    }}\n}", "path": "nuklear/src/nuklear_edit.c", "commit_date": "2018-04-02 00:00:00", "repo_name": "vurtun/nuklear", "stars": 13631, "license": "None", "language": "c", "size": 12127}
{"docstring": "/* ===============================================================\n *\n *                              TOOLTIP\n *\n * ===============================================================*/\n", "func_signal": "NK_API int\nnk_tooltip_begin(struct nk_context *ctx, float width)", "code": "{\n    int x,y,w,h;\n    struct nk_window *win;\n    const struct nk_input *in;\n    struct nk_rect bounds;\n    int ret;\n\n    NK_ASSERT(ctx);\n    NK_ASSERT(ctx->current);\n    NK_ASSERT(ctx->current->layout);\n    if (!ctx || !ctx->current || !ctx->current->layout)\n        return 0;\n\n    /* make sure that no nonblocking popup is currently active */\n    win = ctx->current;\n    in = &ctx->input;\n    if (win->popup.win && (win->popup.type & NK_PANEL_SET_NONBLOCK))\n        return 0;\n\n    w = nk_iceilf(width);\n    h = nk_iceilf(nk_null_rect.h);\n    x = nk_ifloorf(in->mouse.pos.x + 1) - (int)win->layout->clip.x;\n    y = nk_ifloorf(in->mouse.pos.y + 1) - (int)win->layout->clip.y;\n\n    bounds.x = (float)x;\n    bounds.y = (float)y;\n    bounds.w = (float)w;\n    bounds.h = (float)h;\n\n    ret = nk_popup_begin(ctx, NK_POPUP_DYNAMIC,\n        \"__##Tooltip##__\", NK_WINDOW_NO_SCROLLBAR|NK_WINDOW_BORDER, bounds);\n    if (ret) win->layout->flags &= ~(nk_flags)NK_WINDOW_ROM;\n    win->popup.type = NK_PANEL_TOOLTIP;\n    ctx->current->layout->type = NK_PANEL_TOOLTIP;\n    return ret;\n}", "path": "nuklear/src/nuklear_tooltip.c", "commit_date": "2018-04-05 00:00:00", "repo_name": "vurtun/nuklear", "stars": 13631, "license": "None", "language": "c", "size": 12127}
{"docstring": "/* ===============================================================\n *\n *                          DEMO\n *\n * ===============================================================*/\n", "func_signal": "static void error_callback(int e, const char *d)", "code": "{printf(\"Error %d: %s\\n\", e, d);}\n\nint main(void)\n{\n    /* Platform */\n    static GLFWwindow *win;\n    int width = 0, height = 0;\n    struct nk_context *ctx;\n    struct nk_colorf bg;\n    struct nk_image img;\n\n    /* GLFW */\n    glfwSetErrorCallback(error_callback);\n    if (!glfwInit()) {\n        fprintf(stdout, \"[GFLW] failed to init!\\n\");\n        exit(1);\n    }\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 5);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n#ifdef __APPLE__\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n#endif\n    win = glfwCreateWindow(WINDOW_WIDTH, WINDOW_HEIGHT, \"Demo\", NULL, NULL);\n    glfwMakeContextCurrent(win);\n    glfwGetWindowSize(win, &width, &height);\n\n    /* OpenGL */\n    glViewport(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);\n    glewExperimental = 1;\n    if (glewInit() != GLEW_OK) {\n        fprintf(stderr, \"Failed to setup GLEW\\n\");\n        exit(1);\n    }\n\n    ctx = nk_glfw3_init(win, NK_GLFW3_INSTALL_CALLBACKS, MAX_VERTEX_BUFFER, MAX_ELEMENT_BUFFER);\n    /* Load Fonts: if none of these are loaded a default font will be used  */\n    /* Load Cursor: if you uncomment cursor loading please hide the cursor */\n    {struct nk_font_atlas *atlas;\n    nk_glfw3_font_stash_begin(&atlas);\n    /*struct nk_font *droid = nk_font_atlas_add_from_file(atlas, \"../../../extra_font/DroidSans.ttf\", 14, 0);*/\n    /*struct nk_font *roboto = nk_font_atlas_add_from_file(atlas, \"../../../extra_font/Roboto-Regular.ttf\", 14, 0);*/\n    /*struct nk_font *future = nk_font_atlas_add_from_file(atlas, \"../../../extra_font/kenvector_future_thin.ttf\", 13, 0);*/\n    /*struct nk_font *clean = nk_font_atlas_add_from_file(atlas, \"../../../extra_font/ProggyClean.ttf\", 12, 0);*/\n    /*struct nk_font *tiny = nk_font_atlas_add_from_file(atlas, \"../../../extra_font/ProggyTiny.ttf\", 10, 0);*/\n    /*struct nk_font *cousine = nk_font_atlas_add_from_file(atlas, \"../../../extra_font/Cousine-Regular.ttf\", 13, 0);*/\n    nk_glfw3_font_stash_end();\n    /*nk_style_load_all_cursors(ctx, atlas->cursors);*/\n    /*nk_style_set_font(ctx, &droid->handle);*/}\n\n    #ifdef INCLUDE_STYLE\n    /*set_style(ctx, THEME_WHITE);*/\n    /*set_style(ctx, THEME_RED);*/\n    /*set_style(ctx, THEME_BLUE);*/\n    /*set_style(ctx, THEME_DARK);*/\n    #endif\n\n    /* Create bindless texture.\n     * The index returned is not the opengl resource id.\n     * IF you need the GL resource id use: nk_glfw3_get_tex_ogl_id() */\n    {int tex_index = 0;\n    enum {tex_width = 256, tex_height = 256};\n    char pixels[tex_width * tex_height * 4];\n    memset(pixels, 128, sizeof(pixels));\n    tex_index = nk_glfw3_create_texture(pixels, tex_width, tex_height);\n    img = nk_image_id(tex_index);}\n\n    bg.r = 0.10f, bg.g = 0.18f, bg.b = 0.24f, bg.a = 1.0f;\n    while (!glfwWindowShouldClose(win))\n    {\n        /* Input */\n        glfwPollEvents();\n        nk_glfw3_new_frame();\n\n        /* GUI */\n        if (nk_begin(ctx, \"Demo\", nk_rect(50, 50, 230, 250),\n            NK_WINDOW_BORDER|NK_WINDOW_MOVABLE|NK_WINDOW_SCALABLE|\n            NK_WINDOW_MINIMIZABLE|NK_WINDOW_TITLE))\n        {\n            enum {EASY, HARD};\n            static int op = EASY;\n            static int property = 20;\n            nk_layout_row_static(ctx, 30, 80, 1);\n            if (nk_button_label(ctx, \"button\"))\n                fprintf(stdout, \"button pressed\\n\");\n\n            nk_layout_row_dynamic(ctx, 30, 2);\n            if (nk_option_label(ctx, \"easy\", op == EASY)) op = EASY;\n            if (nk_option_label(ctx, \"hard\", op == HARD)) op = HARD;\n\n            nk_layout_row_dynamic(ctx, 25, 1);\n            nk_property_int(ctx, \"Compression:\", 0, &property, 100, 10, 1);\n\n            nk_layout_row_dynamic(ctx, 20, 1);\n            nk_label(ctx, \"background:\", NK_TEXT_LEFT);\n            nk_layout_row_dynamic(ctx, 25, 1);\n            if (nk_combo_begin_color(ctx, nk_rgb_cf(bg), nk_vec2(nk_widget_width(ctx),400))) {\n                nk_layout_row_dynamic(ctx, 120, 1);\n                bg = nk_color_picker(ctx, bg, NK_RGBA);\n                nk_layout_row_dynamic(ctx, 25, 1);\n                bg.r = nk_propertyf(ctx, \"#R:\", 0, bg.r, 1.0f, 0.01f,0.005f);\n                bg.g = nk_propertyf(ctx, \"#G:\", 0, bg.g, 1.0f, 0.01f,0.005f);\n                bg.b = nk_propertyf(ctx, \"#B:\", 0, bg.b, 1.0f, 0.01f,0.005f);\n                bg.a = nk_propertyf(ctx, \"#A:\", 0, bg.a, 1.0f, 0.01f,0.005f);\n                nk_combo_end(ctx);\n            }\n        }\n        nk_end(ctx);\n\n        /* Bindless Texture */\n        if (nk_begin(ctx, \"Texture\", nk_rect(250, 150, 230, 250),\n            NK_WINDOW_BORDER|NK_WINDOW_MOVABLE|NK_WINDOW_SCALABLE|\n            NK_WINDOW_MINIMIZABLE|NK_WINDOW_TITLE))\n        {\n            struct nk_command_buffer *canvas = nk_window_get_canvas(ctx);\n            struct nk_rect total_space = nk_window_get_content_region(ctx);\n            nk_draw_image(canvas, total_space, &img, nk_white);\n        }\n        nk_end(ctx);\n\n        /* -------------- EXAMPLES ---------------- */\n        #ifdef INCLUDE_CALCULATOR\n          calculator(ctx);\n        #endif\n        #ifdef INCLUDE_OVERVIEW\n          overview(ctx);\n        #endif\n        #ifdef INCLUDE_NODE_EDITOR\n          node_editor(ctx);\n        #endif\n        /* ----------------------------------------- */\n\n        /* Draw */\n        glfwGetWindowSize(win, &width, &height);\n        glViewport(0, 0, width, height);\n        glClear(GL_COLOR_BUFFER_BIT);\n        glClearColor(bg.r, bg.g, bg.b, bg.a);\n        /* IMPORTANT: `nk_glfw_render` modifies some global OpenGL state\n         * with blending, scissor, face culling, depth test and viewport and\n         * defaults everything back into a default state.\n         * Make sure to either a.) save and restore or b.) reset your own state after\n         * rendering the UI. */\n        nk_glfw3_render(NK_ANTI_ALIASING_ON);\n        glfwSwapBuffers(win);\n    }\n    nk_glfw3_shutdown();\n    glfwTerminate();\n    return 0;\n}", "path": "nuklear/demo/glfw_opengl4/main.c", "commit_date": "2018-10-30 00:00:00", "repo_name": "vurtun/nuklear", "stars": 13631, "license": "None", "language": "c", "size": 12127}
{"docstring": "/*----------------------------------------------------------------\n *\n *                          OPTION\n *\n * --------------------------------------------------------------*/\n", "func_signal": "NK_API int\nnk_option_text(struct nk_context *ctx, const char *text, int len, int is_active)", "code": "{\n    struct nk_window *win;\n    struct nk_panel *layout;\n    const struct nk_input *in;\n    const struct nk_style *style;\n\n    struct nk_rect bounds;\n    enum nk_widget_layout_states state;\n\n    NK_ASSERT(ctx);\n    NK_ASSERT(ctx->current);\n    NK_ASSERT(ctx->current->layout);\n    if (!ctx || !ctx->current || !ctx->current->layout)\n        return is_active;\n\n    win = ctx->current;\n    style = &ctx->style;\n    layout = win->layout;\n\n    state = nk_widget(&bounds, ctx);\n    if (!state) return (int)state;\n    in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;\n    nk_do_toggle(&ctx->last_widget_state, &win->buffer, bounds, &is_active,\n        text, len, NK_TOGGLE_OPTION, &style->option, in, style->font);\n    return is_active;\n}", "path": "nuklear/src/nuklear_toggle.c", "commit_date": "2018-04-02 00:00:00", "repo_name": "vurtun/nuklear", "stars": 13631, "license": "None", "language": "c", "size": 12127}
{"docstring": "/* ===============================================================\n *\n *                          LAYOUT\n *\n * ===============================================================*/\n", "func_signal": "NK_API void\nnk_layout_set_min_row_height(struct nk_context *ctx, float height)", "code": "{\n    struct nk_window *win;\n    struct nk_panel *layout;\n\n    NK_ASSERT(ctx);\n    NK_ASSERT(ctx->current);\n    NK_ASSERT(ctx->current->layout);\n    if (!ctx || !ctx->current || !ctx->current->layout)\n        return;\n\n    win = ctx->current;\n    layout = win->layout;\n    layout->row.min_height = height;\n}", "path": "nuklear/src/nuklear_layout.c", "commit_date": "2018-08-30 00:00:00", "repo_name": "vurtun/nuklear", "stars": 13631, "license": "None", "language": "c", "size": 12127}
{"docstring": "/* ==============================================================\n *\n *                          DRAW\n *\n * ===============================================================*/\n", "func_signal": "NK_LIB void\nnk_command_buffer_init(struct nk_command_buffer *cb,\n    struct nk_buffer *b, enum nk_command_clipping clip)", "code": "{\n    NK_ASSERT(cb);\n    NK_ASSERT(b);\n    if (!cb || !b) return;\n    cb->base = b;\n    cb->use_clipping = (int)clip;\n    cb->begin = b->allocated;\n    cb->end = b->allocated;\n    cb->last = b->allocated;\n}", "path": "nuklear/src/nuklear_draw.c", "commit_date": "2018-04-02 00:00:00", "repo_name": "vurtun/nuklear", "stars": 13631, "license": "None", "language": "c", "size": 12127}
{"docstring": "/* ==============================================================\n *\n *                          COLOR PICKER\n *\n * ===============================================================*/\n", "func_signal": "NK_LIB int\nnk_color_picker_behavior(nk_flags *state,\n    const struct nk_rect *bounds, const struct nk_rect *matrix,\n    const struct nk_rect *hue_bar, const struct nk_rect *alpha_bar,\n    struct nk_colorf *color, const struct nk_input *in)", "code": "{\n    float hsva[4];\n    int value_changed = 0;\n    int hsv_changed = 0;\n\n    NK_ASSERT(state);\n    NK_ASSERT(matrix);\n    NK_ASSERT(hue_bar);\n    NK_ASSERT(color);\n\n    /* color matrix */\n    nk_colorf_hsva_fv(hsva, *color);\n    if (nk_button_behavior(state, *matrix, in, NK_BUTTON_REPEATER)) {\n        hsva[1] = NK_SATURATE((in->mouse.pos.x - matrix->x) / (matrix->w-1));\n        hsva[2] = 1.0f - NK_SATURATE((in->mouse.pos.y - matrix->y) / (matrix->h-1));\n        value_changed = hsv_changed = 1;\n    }\n    /* hue bar */\n    if (nk_button_behavior(state, *hue_bar, in, NK_BUTTON_REPEATER)) {\n        hsva[0] = NK_SATURATE((in->mouse.pos.y - hue_bar->y) / (hue_bar->h-1));\n        value_changed = hsv_changed = 1;\n    }\n    /* alpha bar */\n    if (alpha_bar) {\n        if (nk_button_behavior(state, *alpha_bar, in, NK_BUTTON_REPEATER)) {\n            hsva[3] = 1.0f - NK_SATURATE((in->mouse.pos.y - alpha_bar->y) / (alpha_bar->h-1));\n            value_changed = 1;\n        }\n    }\n    nk_widget_state_reset(state);\n    if (hsv_changed) {\n        *color = nk_hsva_colorfv(hsva);\n        *state = NK_WIDGET_STATE_ACTIVE;\n    }\n    if (value_changed) {\n        color->a = hsva[3];\n        *state = NK_WIDGET_STATE_ACTIVE;\n    }\n    /* set color picker widget state */\n    if (nk_input_is_mouse_hovering_rect(in, *bounds))\n        *state = NK_WIDGET_STATE_HOVERED;\n    if (*state & NK_WIDGET_STATE_HOVER && !nk_input_is_mouse_prev_hovering_rect(in, *bounds))\n        *state |= NK_WIDGET_STATE_ENTERED;\n    else if (nk_input_is_mouse_prev_hovering_rect(in, *bounds))\n        *state |= NK_WIDGET_STATE_LEFT;\n    return value_changed;\n}", "path": "nuklear/src/nuklear_color_picker.c", "commit_date": "2018-04-02 00:00:00", "repo_name": "vurtun/nuklear", "stars": 13631, "license": "None", "language": "c", "size": 12127}
{"docstring": "/* ===============================================================\n *\n *                          INPUT\n *\n * ===============================================================*/\n", "func_signal": "NK_API void\nnk_input_begin(struct nk_context *ctx)", "code": "{\n    int i;\n    struct nk_input *in;\n    NK_ASSERT(ctx);\n    if (!ctx) return;\n    in = &ctx->input;\n    for (i = 0; i < NK_BUTTON_MAX; ++i)\n        in->mouse.buttons[i].clicked = 0;\n\n    in->keyboard.text_len = 0;\n    in->mouse.scroll_delta = nk_vec2(0,0);\n    in->mouse.prev.x = in->mouse.pos.x;\n    in->mouse.prev.y = in->mouse.pos.y;\n    in->mouse.delta.x = 0;\n    in->mouse.delta.y = 0;\n    for (i = 0; i < NK_KEY_MAX; i++)\n        in->keyboard.keys[i].clicked = 0;\n}", "path": "nuklear/src/nuklear_input.c", "commit_date": "2018-10-31 00:00:00", "repo_name": "vurtun/nuklear", "stars": 13631, "license": "None", "language": "c", "size": 12127}
{"docstring": "/* ===============================================================\n *\n *                          IMAGE\n *\n * ===============================================================*/\n", "func_signal": "NK_API nk_handle\nnk_handle_ptr(void *ptr)", "code": "{\n    nk_handle handle = {0};\n    handle.ptr = ptr;\n    return handle;\n}", "path": "nuklear/src/nuklear_image.c", "commit_date": "2018-04-02 00:00:00", "repo_name": "vurtun/nuklear", "stars": 13631, "license": "None", "language": "c", "size": 12127}
{"docstring": "/* ==============================================================\n *\n *                          CONTEXTUAL\n *\n * ===============================================================*/\n", "func_signal": "NK_API int\nnk_contextual_begin(struct nk_context *ctx, nk_flags flags, struct nk_vec2 size,\n    struct nk_rect trigger_bounds)", "code": "{\n    struct nk_window *win;\n    struct nk_window *popup;\n    struct nk_rect body;\n\n    NK_STORAGE const struct nk_rect null_rect = {-1,-1,0,0};\n    int is_clicked = 0;\n    int is_open = 0;\n    int ret = 0;\n\n    NK_ASSERT(ctx);\n    NK_ASSERT(ctx->current);\n    NK_ASSERT(ctx->current->layout);\n    if (!ctx || !ctx->current || !ctx->current->layout)\n        return 0;\n\n    win = ctx->current;\n    ++win->popup.con_count;\n    if (ctx->current != ctx->active)\n        return 0;\n\n    /* check if currently active contextual is active */\n    popup = win->popup.win;\n    is_open = (popup && win->popup.type == NK_PANEL_CONTEXTUAL);\n    is_clicked = nk_input_mouse_clicked(&ctx->input, NK_BUTTON_RIGHT, trigger_bounds);\n    if (win->popup.active_con && win->popup.con_count != win->popup.active_con)\n        return 0;\n    if (!is_open && win->popup.active_con)\n        win->popup.active_con = 0;\n    if ((!is_open && !is_clicked))\n        return 0;\n\n    /* calculate contextual position on click */\n    win->popup.active_con = win->popup.con_count;\n    if (is_clicked) {\n        body.x = ctx->input.mouse.pos.x;\n        body.y = ctx->input.mouse.pos.y;\n    } else {\n        body.x = popup->bounds.x;\n        body.y = popup->bounds.y;\n    }\n    body.w = size.x;\n    body.h = size.y;\n\n    /* start nonblocking contextual popup */\n    ret = nk_nonblock_begin(ctx, flags|NK_WINDOW_NO_SCROLLBAR, body,\n            null_rect, NK_PANEL_CONTEXTUAL);\n    if (ret) win->popup.type = NK_PANEL_CONTEXTUAL;\n    else {\n        win->popup.active_con = 0;\n        win->popup.type = NK_PANEL_NONE;\n        if (win->popup.win)\n            win->popup.win->flags = 0;\n    }\n    return ret;\n}", "path": "nuklear/src/nuklear_contextual.c", "commit_date": "2018-04-23 00:00:00", "repo_name": "vurtun/nuklear", "stars": 13631, "license": "None", "language": "c", "size": 12127}
{"docstring": "/* ==============================================================\n *\n *                          CONTEXT\n *\n * ===============================================================*/\n", "func_signal": "NK_INTERN void\nnk_setup(struct nk_context *ctx, const struct nk_user_font *font)", "code": "{\n    NK_ASSERT(ctx);\n    if (!ctx) return;\n    nk_zero_struct(*ctx);\n    nk_style_default(ctx);\n    ctx->seq = 1;\n    if (font) ctx->style.font = font;\n#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT\n    nk_draw_list_init(&ctx->draw_list);\n#endif\n}", "path": "nuklear/src/nuklear_context.c", "commit_date": "2018-04-02 00:00:00", "repo_name": "vurtun/nuklear", "stars": 13631, "license": "None", "language": "c", "size": 12127}
{"docstring": "/* ===============================================================\n *\n *                              SCROLLBAR\n *\n * ===============================================================*/\n", "func_signal": "NK_LIB float\nnk_scrollbar_behavior(nk_flags *state, struct nk_input *in,\n    int has_scrolling, const struct nk_rect *scroll,\n    const struct nk_rect *cursor, const struct nk_rect *empty0,\n    const struct nk_rect *empty1, float scroll_offset,\n    float target, float scroll_step, enum nk_orientation o)", "code": "{\n    nk_flags ws = 0;\n    int left_mouse_down;\n    int left_mouse_clicked;\n    int left_mouse_click_in_cursor;\n    float scroll_delta;\n\n    nk_widget_state_reset(state);\n    if (!in) return scroll_offset;\n\n    left_mouse_down = in->mouse.buttons[NK_BUTTON_LEFT].down;\n    left_mouse_clicked = in->mouse.buttons[NK_BUTTON_LEFT].clicked;\n    left_mouse_click_in_cursor = nk_input_has_mouse_click_down_in_rect(in,\n        NK_BUTTON_LEFT, *cursor, nk_true);\n    if (nk_input_is_mouse_hovering_rect(in, *scroll))\n        *state = NK_WIDGET_STATE_HOVERED;\n\n    scroll_delta = (o == NK_VERTICAL) ? in->mouse.scroll_delta.y: in->mouse.scroll_delta.x;\n    if (left_mouse_down && left_mouse_click_in_cursor && !left_mouse_clicked) {\n        /* update cursor by mouse dragging */\n        float pixel, delta;\n        *state = NK_WIDGET_STATE_ACTIVE;\n        if (o == NK_VERTICAL) {\n            float cursor_y;\n            pixel = in->mouse.delta.y;\n            delta = (pixel / scroll->h) * target;\n            scroll_offset = NK_CLAMP(0, scroll_offset + delta, target - scroll->h);\n            cursor_y = scroll->y + ((scroll_offset/target) * scroll->h);\n            in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.y = cursor_y + cursor->h/2.0f;\n        } else {\n            float cursor_x;\n            pixel = in->mouse.delta.x;\n            delta = (pixel / scroll->w) * target;\n            scroll_offset = NK_CLAMP(0, scroll_offset + delta, target - scroll->w);\n            cursor_x = scroll->x + ((scroll_offset/target) * scroll->w);\n            in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x = cursor_x + cursor->w/2.0f;\n        }\n    } else if ((nk_input_is_key_pressed(in, NK_KEY_SCROLL_UP) && o == NK_VERTICAL && has_scrolling)||\n            nk_button_behavior(&ws, *empty0, in, NK_BUTTON_DEFAULT)) {\n        /* scroll page up by click on empty space or shortcut */\n        if (o == NK_VERTICAL)\n            scroll_offset = NK_MAX(0, scroll_offset - scroll->h);\n        else scroll_offset = NK_MAX(0, scroll_offset - scroll->w);\n    } else if ((nk_input_is_key_pressed(in, NK_KEY_SCROLL_DOWN) && o == NK_VERTICAL && has_scrolling) ||\n        nk_button_behavior(&ws, *empty1, in, NK_BUTTON_DEFAULT)) {\n        /* scroll page down by click on empty space or shortcut */\n        if (o == NK_VERTICAL)\n            scroll_offset = NK_MIN(scroll_offset + scroll->h, target - scroll->h);\n        else scroll_offset = NK_MIN(scroll_offset + scroll->w, target - scroll->w);\n    } else if (has_scrolling) {\n        if ((scroll_delta < 0 || (scroll_delta > 0))) {\n            /* update cursor by mouse scrolling */\n            scroll_offset = scroll_offset + scroll_step * (-scroll_delta);\n            if (o == NK_VERTICAL)\n                scroll_offset = NK_CLAMP(0, scroll_offset, target - scroll->h);\n            else scroll_offset = NK_CLAMP(0, scroll_offset, target - scroll->w);\n        } else if (nk_input_is_key_pressed(in, NK_KEY_SCROLL_START)) {\n            /* update cursor to the beginning  */\n            if (o == NK_VERTICAL) scroll_offset = 0;\n        } else if (nk_input_is_key_pressed(in, NK_KEY_SCROLL_END)) {\n            /* update cursor to the end */\n            if (o == NK_VERTICAL) scroll_offset = target - scroll->h;\n        }\n    }\n    if (*state & NK_WIDGET_STATE_HOVER && !nk_input_is_mouse_prev_hovering_rect(in, *scroll))\n        *state |= NK_WIDGET_STATE_ENTERED;\n    else if (nk_input_is_mouse_prev_hovering_rect(in, *scroll))\n        *state |= NK_WIDGET_STATE_LEFT;\n    return scroll_offset;\n}", "path": "nuklear/src/nuklear_scrollbar.c", "commit_date": "2018-08-26 00:00:00", "repo_name": "vurtun/nuklear", "stars": 13631, "license": "None", "language": "c", "size": 12127}
{"docstring": "/* ===============================================================\n *\n *                              TOGGLE\n *\n * ===============================================================*/\n", "func_signal": "NK_LIB int\nnk_toggle_behavior(const struct nk_input *in, struct nk_rect select,\n    nk_flags *state, int active)", "code": "{\n    nk_widget_state_reset(state);\n    if (nk_button_behavior(state, select, in, NK_BUTTON_DEFAULT)) {\n        *state = NK_WIDGET_STATE_ACTIVE;\n        active = !active;\n    }\n    if (*state & NK_WIDGET_STATE_HOVER && !nk_input_is_mouse_prev_hovering_rect(in, select))\n        *state |= NK_WIDGET_STATE_ENTERED;\n    else if (nk_input_is_mouse_prev_hovering_rect(in, select))\n        *state |= NK_WIDGET_STATE_LEFT;\n    return active;\n}", "path": "nuklear/src/nuklear_toggle.c", "commit_date": "2018-04-02 00:00:00", "repo_name": "vurtun/nuklear", "stars": 13631, "license": "None", "language": "c", "size": 12127}
{"docstring": "/*----------------------------------------------------------------\n *\n *                          CHECKBOX\n *\n * --------------------------------------------------------------*/\n", "func_signal": "NK_API int\nnk_check_text(struct nk_context *ctx, const char *text, int len, int active)", "code": "{\n    struct nk_window *win;\n    struct nk_panel *layout;\n    const struct nk_input *in;\n    const struct nk_style *style;\n\n    struct nk_rect bounds;\n    enum nk_widget_layout_states state;\n\n    NK_ASSERT(ctx);\n    NK_ASSERT(ctx->current);\n    NK_ASSERT(ctx->current->layout);\n    if (!ctx || !ctx->current || !ctx->current->layout)\n        return active;\n\n    win = ctx->current;\n    style = &ctx->style;\n    layout = win->layout;\n\n    state = nk_widget(&bounds, ctx);\n    if (!state) return active;\n    in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;\n    nk_do_toggle(&ctx->last_widget_state, &win->buffer, bounds, &active,\n        text, len, NK_TOGGLE_CHECK, &style->checkbox, in, style->font);\n    return active;\n}", "path": "nuklear/src/nuklear_toggle.c", "commit_date": "2018-04-02 00:00:00", "repo_name": "vurtun/nuklear", "stars": 13631, "license": "None", "language": "c", "size": 12127}
{"docstring": "/* ===============================================================\n *\n *                          DEMO\n *\n * ===============================================================*/\n", "func_signal": "int\nmain(void)", "code": "{\n    long dt;\n    long started;\n    int running = 1;\n    XWindow xw;\n    struct nk_context *ctx;\n\n    /* X11 */\n    memset(&xw, 0, sizeof xw);\n    xw.dpy = XOpenDisplay(NULL);\n    if (!xw.dpy) die(\"Could not open a display; perhaps $DISPLAY is not set?\");\n    xw.root = DefaultRootWindow(xw.dpy);\n    xw.screen = XDefaultScreen(xw.dpy);\n    xw.vis = XDefaultVisual(xw.dpy, xw.screen);\n    xw.cmap = XCreateColormap(xw.dpy,xw.root,xw.vis,AllocNone);\n\n    xw.swa.colormap = xw.cmap;\n    xw.swa.event_mask =\n        ExposureMask | KeyPressMask | KeyReleaseMask |\n        ButtonPress | ButtonReleaseMask| ButtonMotionMask |\n        Button1MotionMask | Button3MotionMask | Button4MotionMask | Button5MotionMask|\n        PointerMotionMask | KeymapStateMask;\n    xw.win = XCreateWindow(xw.dpy, xw.root, 0, 0, WINDOW_WIDTH, WINDOW_HEIGHT, 0,\n        XDefaultDepth(xw.dpy, xw.screen), InputOutput,\n        xw.vis, CWEventMask | CWColormap, &xw.swa);\n\n    XStoreName(xw.dpy, xw.win, \"X11\");\n    XMapWindow(xw.dpy, xw.win);\n    xw.wm_delete_window = XInternAtom(xw.dpy, \"WM_DELETE_WINDOW\", False);\n    XSetWMProtocols(xw.dpy, xw.win, &xw.wm_delete_window, 1);\n    XGetWindowAttributes(xw.dpy, xw.win, &xw.attr);\n    xw.width = (unsigned int)xw.attr.width;\n    xw.height = (unsigned int)xw.attr.height;\n\n    /* GUI */\n    xw.font = nk_xfont_create(xw.dpy, \"Arial\");\n    ctx = nk_xlib_init(xw.font, xw.dpy, xw.screen, xw.win,\n#ifdef NK_XLIB_USE_XFT\n                    xw.vis, xw.cmap,\n#endif\n                    xw.width, xw.height);\n\n    #ifdef INCLUDE_STYLE\n    /*set_style(ctx, THEME_WHITE);*/\n    /*set_style(ctx, THEME_RED);*/\n    /*set_style(ctx, THEME_BLUE);*/\n    /*set_style(ctx, THEME_DARK);*/\n    #endif\n\n    while (running)\n    {\n        /* Input */\n        XEvent evt;\n        started = timestamp();\n        nk_input_begin(ctx);\n        while (XPending(xw.dpy)) {\n            XNextEvent(xw.dpy, &evt);\n            if (evt.type == ClientMessage) goto cleanup;\n            if (XFilterEvent(&evt, xw.win)) continue;\n            nk_xlib_handle_event(xw.dpy, xw.screen, xw.win, &evt);\n        }\n        nk_input_end(ctx);\n\n        /* GUI */\n        if (nk_begin(ctx, \"Demo\", nk_rect(50, 50, 200, 200),\n            NK_WINDOW_BORDER|NK_WINDOW_MOVABLE|NK_WINDOW_SCALABLE|\n            NK_WINDOW_CLOSABLE|NK_WINDOW_MINIMIZABLE|NK_WINDOW_TITLE))\n        {\n            enum {EASY, HARD};\n            static int op = EASY;\n            static int property = 20;\n\n            nk_layout_row_static(ctx, 30, 80, 1);\n            if (nk_button_label(ctx, \"button\"))\n                fprintf(stdout, \"button pressed\\n\");\n            nk_layout_row_dynamic(ctx, 30, 2);\n            if (nk_option_label(ctx, \"easy\", op == EASY)) op = EASY;\n            if (nk_option_label(ctx, \"hard\", op == HARD)) op = HARD;\n            nk_layout_row_dynamic(ctx, 25, 1);\n            nk_property_int(ctx, \"Compression:\", 0, &property, 100, 10, 1);\n        }\n        nk_end(ctx);\n        if (nk_window_is_hidden(ctx, \"Demo\")) break;\n\n        /* -------------- EXAMPLES ---------------- */\n        #ifdef INCLUDE_CALCULATOR\n          calculator(ctx);\n        #endif\n        #ifdef INCLUDE_OVERVIEW\n          overview(ctx);\n        #endif\n        #ifdef INCLUDE_NODE_EDITOR\n          node_editor(ctx);\n        #endif\n        /* ----------------------------------------- */\n\n        /* Draw */\n        XClearWindow(xw.dpy, xw.win);\n        nk_xlib_render(xw.win, nk_rgb(30,30,30));\n        XFlush(xw.dpy);\n\n        /* Timing */\n        dt = timestamp() - started;\n        if (dt < DTIME)\n            sleep_for(DTIME - dt);\n    }\n\ncleanup:\n    nk_xfont_del(xw.dpy, xw.font);\n    nk_xlib_shutdown();\n    XUnmapWindow(xw.dpy, xw.win);\n    XFreeColormap(xw.dpy, xw.cmap);\n    XDestroyWindow(xw.dpy, xw.win);\n    XCloseDisplay(xw.dpy);\n    return 0;\n}", "path": "nuklear/demo/x11_xft/main.c", "commit_date": "2018-06-21 00:00:00", "repo_name": "vurtun/nuklear", "stars": 13631, "license": "None", "language": "c", "size": 12127}
{"docstring": "/* ===============================================================\n *\n *                          FILTER\n *\n * ===============================================================*/\n", "func_signal": "NK_API int\nnk_filter_default(const struct nk_text_edit *box, nk_rune unicode)", "code": "{\n    NK_UNUSED(unicode);\n    NK_UNUSED(box);\n    return nk_true;\n}", "path": "nuklear/src/nuklear_edit.c", "commit_date": "2018-04-02 00:00:00", "repo_name": "vurtun/nuklear", "stars": 13631, "license": "None", "language": "c", "size": 12127}
{"docstring": "/* ===============================================================\n *\n *                              SLIDER\n *\n * ===============================================================*/\n", "func_signal": "NK_LIB float\nnk_slider_behavior(nk_flags *state, struct nk_rect *logical_cursor,\n    struct nk_rect *visual_cursor, struct nk_input *in,\n    struct nk_rect bounds, float slider_min, float slider_max, float slider_value,\n    float slider_step, float slider_steps)", "code": "{\n    int left_mouse_down;\n    int left_mouse_click_in_cursor;\n\n    /* check if visual cursor is being dragged */\n    nk_widget_state_reset(state);\n    left_mouse_down = in && in->mouse.buttons[NK_BUTTON_LEFT].down;\n    left_mouse_click_in_cursor = in && nk_input_has_mouse_click_down_in_rect(in,\n            NK_BUTTON_LEFT, *visual_cursor, nk_true);\n\n    if (left_mouse_down && left_mouse_click_in_cursor) {\n        float ratio = 0;\n        const float d = in->mouse.pos.x - (visual_cursor->x+visual_cursor->w*0.5f);\n        const float pxstep = bounds.w / slider_steps;\n\n        /* only update value if the next slider step is reached */\n        *state = NK_WIDGET_STATE_ACTIVE;\n        if (NK_ABS(d) >= pxstep) {\n            const float steps = (float)((int)(NK_ABS(d) / pxstep));\n            slider_value += (d > 0) ? (slider_step*steps) : -(slider_step*steps);\n            slider_value = NK_CLAMP(slider_min, slider_value, slider_max);\n            ratio = (slider_value - slider_min)/slider_step;\n            logical_cursor->x = bounds.x + (logical_cursor->w * ratio);\n            in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x = logical_cursor->x;\n        }\n    }\n\n    /* slider widget state */\n    if (nk_input_is_mouse_hovering_rect(in, bounds))\n        *state = NK_WIDGET_STATE_HOVERED;\n    if (*state & NK_WIDGET_STATE_HOVER &&\n        !nk_input_is_mouse_prev_hovering_rect(in, bounds))\n        *state |= NK_WIDGET_STATE_ENTERED;\n    else if (nk_input_is_mouse_prev_hovering_rect(in, bounds))\n        *state |= NK_WIDGET_STATE_LEFT;\n    return slider_value;\n}", "path": "nuklear/src/nuklear_slider.c", "commit_date": "2018-04-02 00:00:00", "repo_name": "vurtun/nuklear", "stars": 13631, "license": "None", "language": "c", "size": 12127}
{"docstring": "// note that we treat any error as \"the symbols aren't there\" (and don't care if dlclose() failed)\n", "func_signal": "void uiprivLoadFutures(void)", "code": "{\n\tvoid *handle;\n\n\t// dlsym() walks the dependency chain, so opening the current process should be sufficient\n\thandle = dlopen(NULL, RTLD_LAZY);\n\tif (handle == NULL)\n\t\treturn;\n#define GET(var, fn) *((void **) (&var)) = dlsym(handle, #fn)\n\tGET(newFeaturesAttr, pango_attr_font_features_new);\n\tGET(newFGAlphaAttr, pango_attr_foreground_alpha_new);\n\tGET(newBGAlphaAttr, pango_attr_background_alpha_new);\n\tGET(gwpIterSetObjectName, gtk_widget_path_iter_set_object_name);\n\tdlclose(handle);\n}", "path": "libui/unix/future.c", "commit_date": "2018-05-12 00:00:00", "repo_name": "andlabs/libui", "stars": 10609, "license": "other", "language": "c", "size": 6375}
{"docstring": "// see https://msdn.microsoft.com/en-us/library/windows/desktop/ff684171%28v=vs.85%29.aspx#skew_transform\n// TODO see if there's a way we can avoid the multiplication\n", "func_signal": "void uiprivFallbackSkew(uiDrawMatrix *m, double x, double y, double xamount, double yamount)", "code": "{\n\tuiDrawMatrix n;\n\n\tuiDrawMatrixSetIdentity(&n);\n\t// TODO explain this\n\tn.M12 = tan(yamount);\n\tn.M21 = tan(xamount);\n\tn.M31 = -y * tan(xamount);\n\tn.M32 = -x * tan(yamount);\n\tuiDrawMatrixMultiply(m, &n);\n}", "path": "libui/common/matrix.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "andlabs/libui", "stars": 10609, "license": "other", "language": "c", "size": 6375}
{"docstring": "// x, y, xdist, ydist, and c.rect must have the same units\n// so must time, maxTime, and c.prevTime\n", "func_signal": "int uiprivClickCounterClick(uiprivClickCounter *c, int button, int x, int y, uintptr_t time, uintptr_t maxTime, int32_t xdist, int32_t ydist)", "code": "{\n\t// different button than before? if so, don't count\n\tif (button != c->curButton)\n\t\tc->count = 0;\n\n\t// (x, y) in the allowed region for a double-click? if not, don't count\n\tif (x < c->rectX0)\n\t\tc->count = 0;\n\tif (y < c->rectY0)\n\t\tc->count = 0;\n\tif (x >= c->rectX1)\n\t\tc->count = 0;\n\tif (y >= c->rectY1)\n\t\tc->count = 0;\n\n\t// too slow? if so, don't count\n\t// note the below expression; time > (c.prevTime + maxTime) can overflow!\n\tif ((time - c->prevTime) > maxTime)\t// too slow; don't count\n\t\tc->count = 0;\n\n\tc->count++;\t\t// if either of the above ifs happened, this will make the click count 1; otherwise it will make the click count 2, 3, 4, 5, ...\n\n\t// now we need to update the internal structures for the next test\n\tc->curButton = button;\n\tc->prevTime = time;\n\tc->rectX0 = x - xdist;\n\tc->rectY0 = y - ydist;\n\tc->rectX1 = x + xdist;\n\tc->rectY1 = y + ydist;\n\n\treturn c->count;\n}", "path": "libui/common/areaevents.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "andlabs/libui", "stars": 10609, "license": "other", "language": "c", "size": 6375}
{"docstring": "// encoded must have at most 2 elements\n", "func_signal": "size_t uiprivUTF16EncodeRune(uint32_t rune, uint16_t *encoded)", "code": "{\n\tuint16_t low, high;\n\n\t// not in the valid range for Unicode\n\tif (rune > 0x10FFFF)\n\t\trune = badrune;\n\t// surrogate runes cannot be encoded\n\tif (rune >= 0xD800 && rune < 0xE000)\n\t\trune = badrune;\n\n\tif (rune < 0x10000) {\n\t\tencoded[0] = (uint16_t) rune;\n\t\treturn 1;\n\t}\n\n\trune -= 0x10000;\n\tlow = (uint16_t) (rune & 0x3FF);\n\trune >>= 10;\n\thigh = (uint16_t) (rune & 0x3FF);\n\tencoded[0] = high | 0xD800;\n\tencoded[1] = low | 0xDC00;\n\treturn 2;\n}", "path": "libui/common/utf.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "andlabs/libui", "stars": 10609, "license": "other", "language": "c", "size": 6375}
{"docstring": "// TODO neither these nor the overall extents seem to include trailing whitespace... we need to figure that out too\n", "func_signal": "static void computeLineMetrics(uiDrawTextLayout *tl)", "code": "{\n\tPangoLayoutIter *iter;\n\tPangoLayoutLine *pll;\n\tPangoRectangle lineStartPos, lineExtents;\n\tint i, n;\n\tuiDrawTextLayoutLineMetrics *m;\n\n\tn = tl->nLines;\t\t// TODO remove this variable\n\ttl->lineMetrics = (uiDrawTextLayoutLineMetrics *) uiAlloc(n * sizeof (uiDrawTextLayoutLineMetrics), \"uiDrawTextLayoutLineMetrics[] (text layout)\");\n\titer = pango_layout_get_iter(tl->layout);\n\n\tm = tl->lineMetrics;\n\tfor (i = 0; i < n; i++) {\n\t\tint baselineY;\n\n\t\t// TODO we use this instead of _get_yrange() because of the block of text in that function's description about how line spacing is distributed in Pango; we have to worry about this when we start adding line spacing...\n\t\tbaselineY = pango_layout_iter_get_baseline(iter);\n\t\tpll = pango_layout_iter_get_line_readonly(iter);\n\t\tpango_layout_index_to_pos(tl->layout, pll->start_index, &lineStartPos);\n\t\tpango_layout_line_get_extents(pll, NULL, &lineExtents);\n\t\t// TODO unref pll?\n\n\t\t// TODO is this correct for RTL glyphs?\n\t\tm->X = pangoToCairo(lineStartPos.x);\n\t\t// TODO fix the whole combined not being updated shenanigans in the static build (here because ugh)\n\t\tm->Y = pangoToCairo(baselineY - PANGO_ASCENT(lineExtents));\n\t\t// TODO this does not include the last space if any\n\t\tm->Width = pangoToCairo(lineExtents.width);\n\t\tm->Height = pangoToCairo(lineExtents.height);\n\n\t\tm->BaselineY = pangoToCairo(baselineY);\n\t\tm->Ascent = pangoToCairo(PANGO_ASCENT(lineExtents));\n\t\tm->Descent = pangoToCairo(PANGO_DESCENT(lineExtents));\n\t\tm->Leading = 0;\t\t// TODO\n\n\t\tm->ParagraphSpacingBefore = 0;\t\t// TODO\n\t\tm->LineHeightSpace = 0;\t\t\t\t// TODO\n\t\tm->LineSpacing = 0;\t\t\t\t// TODO\n\t\tm->ParagraphSpacing = 0;\t\t\t// TODO\n\n\t\t// don't worry about the return value; we're not using this after the last line\n\t\tpango_layout_iter_next_line(iter);\n\t\tm++;\n\t}\n\n\tpango_layout_iter_free(iter);\n}", "path": "libui/_wip/attrstr_metrics/unix_OLD_drawtext.c", "commit_date": "2018-03-18 00:00:00", "repo_name": "andlabs/libui", "stars": 10609, "license": "other", "language": "c", "size": 6375}
{"docstring": "// the basic algorithm is from cairo\n// but it's the same algorithm as the transform point, just without M31 and M32 taken into account, so let's just do that instead\n", "func_signal": "void uiprivFallbackTransformSize(uiDrawMatrix *m, double *x, double *y)", "code": "{\n\tuiDrawMatrix m2;\n\n\tm2 = *m;\n\tm2.M31 = 0;\n\tm2.M32 = 0;\n\tuiDrawMatrixTransformPoint(&m2, x, y);\n}", "path": "libui/common/matrix.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "andlabs/libui", "stars": 10609, "license": "other", "language": "c", "size": 6375}
{"docstring": "// gtk_main_quit() may run immediately, or it may wait for other pending events; \"it depends\" (thanks mclasen in irc.gimp.net/#gtk+)\n// PostQuitMessage() on Windows always waits, so we must do so too\n// we'll do it by using an idle callback\n", "func_signal": "static gboolean quit(gpointer data)", "code": "{\n\tif (iteration == stepsIteration)\n\t\tstepsQuit = TRUE;\n\t\t// TODO run a gtk_main() here just to do the cleanup steps of syncing the clipboard and other stuff gtk_main() does before it returns\n\telse\n\t\tgtk_main_quit();\n\treturn FALSE;\n}", "path": "libui/unix/main.c", "commit_date": "2018-08-09 00:00:00", "repo_name": "andlabs/libui", "stars": 10609, "license": "other", "language": "c", "size": 6375}
{"docstring": "// note: Pango will not let us place the cursor at the end of a line the same way other OSs do; see https://git.gnome.org/browse/pango/tree/pango/pango-layout.c?id=f4cbd27f4e5bf8490ea411190d41813e14f12165#n4204\n// ideally there'd be a way to say \"I don't need this hack; I'm well behaved\" but GTK+ 2 and 3 AND Qt 4 and 5 all behave like this, with the behavior seeming to date back to TkTextView, so...\n", "func_signal": "void uiDrawTextLayoutHitTest(uiDrawTextLayout *tl, double x, double y, size_t *pos, int *line)", "code": "{\n\tint p, trailing;\n\tint i;\n\n\t// this is layout-global, so it takes line origins into account\n\tpango_layout_xy_to_index(tl->layout,\n\t\tcairoToPango(x), cairoToPango(y),\n\t\t&p, &trailing);\n\t// on a trailing hit, align to the nearest cluster\n\t// fortunately Pango provides that info directly\n\tif (trailing != 0)\n\t\tp += trailing;\n\t*pos = p;\n\n\tfor (i = 0; i < tl->nLines; i++) {\n\t\tdouble ltop, lbottom;\n\n\t\tltop = tl->lineMetrics[i].Y;\n\t\tlbottom = ltop + tl->lineMetrics[i].Height;\n\t\t// y will already >= ltop at this point since the past lbottom should == ltop\n\t\tif (y < lbottom)\n\t\t\tbreak;\n\t}\n\tif (i == pango_layout_get_line_count(tl->layout))\n\t\ti--;\n\t*line = i;\n}", "path": "libui/_wip/attrstr_metrics/unix_OLD_drawtext.c", "commit_date": "2018-03-18 00:00:00", "repo_name": "andlabs/libui", "stars": 10609, "license": "other", "language": "c", "size": 6375}
{"docstring": "// encoded must be at most 4 bytes\n// TODO clean this code up somehow\n", "func_signal": "size_t uiprivUTF8EncodeRune(uint32_t rune, char *encoded)", "code": "{\n\tuint8_t b, c, d, e;\n\tsize_t n;\n\n\t// not in the valid range for Unicode\n\tif (rune > 0x10FFFF)\n\t\trune = badrune;\n\t// surrogate runes cannot be encoded\n\tif (rune >= 0xD800 && rune < 0xE000)\n\t\trune = badrune;\n\n\tif (rune < 0x80) {\t\t// ASCII bytes represent themselves\n\t\tb = (uint8_t) (rune & 0xFF);\n\t\tn = 1;\n\t\tgoto done;\n\t}\n\tif (rune < 0x800) {\t\t// two-byte encoding\n\t\tc = (uint8_t) (rune & 0x3F);\n\t\tc |= 0x80;\n\t\trune >>= 6;\n\t\tb = (uint8_t) (rune & 0x1F);\n\t\tb |= 0xC0;\n\t\tn = 2;\n\t\tgoto done;\n\t}\n\tif (rune < 0x10000) {\t// three-byte encoding\n\t\td = (uint8_t) (rune & 0x3F);\n\t\td |= 0x80;\n\t\trune >>= 6;\n\t\tc = (uint8_t) (rune & 0x3F);\n\t\tc |= 0x80;\n\t\trune >>= 6;\n\t\tb = (uint8_t) (rune & 0x0F);\n\t\tb |= 0xE0;\n\t\tn = 3;\n\t\tgoto done;\n\t}\n\t// otherwise use a four-byte encoding\n\te = (uint8_t) (rune & 0x3F);\n\te |= 0x80;\n\trune >>= 6;\n\td = (uint8_t) (rune & 0x3F);\n\td |= 0x80;\n\trune >>= 6;\n\tc = (uint8_t) (rune & 0x3F);\n\tc |= 0x80;\n\trune >>= 6;\n\tb = (uint8_t) (rune & 0x07);\n\tb |= 0xF0;\n\tn = 4;\n\ndone:\n\tencoded[0] = b;\n\tif (n > 1)\n\t\tencoded[1] = c;\n\tif (n > 2)\n\t\tencoded[2] = d;\n\tif (n > 3)\n\t\tencoded[3] = e;\n\treturn n;\n}", "path": "libui/common/utf.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "andlabs/libui", "stars": 10609, "license": "other", "language": "c", "size": 6375}
{"docstring": "// TODO find a way to reduce the code in all of these somehow\n// TODO find a way to remove u as well\n", "func_signal": "size_t uiprivUTF8RuneCount(const char *s, size_t nElem)", "code": "{\n\tsize_t len;\n\tuint32_t rune;\n\n\tif (nElem != 0) {\n\t\tconst char *t, *u;\n\n\t\tlen = 0;\n\t\tt = s;\n\t\twhile (nElem != 0) {\n\t\t\tu = uiprivUTF8DecodeRune(t, nElem, &rune);\n\t\t\tlen++;\n\t\t\tnElem -= u - t;\n\t\t\tt = u;\n\t\t}\n\t\treturn len;\n\t}\n\tlen = 0;\n\twhile (*s) {\n\t\ts = uiprivUTF8DecodeRune(s, nElem, &rune);\n\t\tlen++;\n\t}\n\treturn len;\n}", "path": "libui/common/utf.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "andlabs/libui", "stars": 10609, "license": "other", "language": "c", "size": 6375}
{"docstring": "// we do NOT want programmatic updates to raise an ::activated signal\n", "func_signal": "static void singleSetChecked(GtkCheckMenuItem *menuitem, gboolean checked, gulong signal)", "code": "{\n\tg_signal_handler_block(menuitem, signal);\n\tgtk_check_menu_item_set_active(menuitem, checked);\n\tg_signal_handler_unblock(menuitem, signal);\n}", "path": "libui/unix/menu.c", "commit_date": "2018-05-12 00:00:00", "repo_name": "andlabs/libui", "stars": 10609, "license": "other", "language": "c", "size": 6375}
{"docstring": "// the only difference is we ignore the return value from gtk_main_iteration_do(), since it will always be TRUE if gtk_main() was never called\n// gtk_main_iteration_do() will still run the main loop regardless\n", "func_signal": "static gboolean stepsIteration(gboolean block)", "code": "{\n\tgtk_main_iteration_do(block);\n\treturn stepsQuit;\n}", "path": "libui/unix/main.c", "commit_date": "2018-08-09 00:00:00", "repo_name": "andlabs/libui", "stars": 10609, "license": "other", "language": "c", "size": 6375}
{"docstring": "// TODO share?\n", "func_signal": "static uiCheckbox *newCheckbox(uiBox *box, const char *text)", "code": "{\n\tuiCheckbox *c;\n\n\tc = uiNewCheckbox(text);\n\tuiCheckboxOnToggled(c, checkboxChecked, NULL);\n\tuiBoxAppend(box, uiControl(c), 0);\n\treturn c;\n}", "path": "libui/_wip/examples_drawtext/emptystr_hittest.c", "commit_date": "2018-03-11 00:00:00", "repo_name": "andlabs/libui", "stars": 10609, "license": "other", "language": "c", "size": 6375}
{"docstring": "// TODO is this the right algorithm?\n", "func_signal": "static void match(gpointer surface, gpointer data)", "code": "{\n\tcairo_surface_t *cs = (cairo_surface_t *) surface;\n\tstruct matcher *m = (struct matcher *) data;\n\tint x, y;\n\tint x2, y2;\n\n\tx = cairo_image_surface_get_width(cs);\n\ty = cairo_image_surface_get_height(cs);\n\tif (m->best == NULL)\n\t\tgoto writeMatch;\n\n\tif (x < m->targetX && y < m->targetY)\n\t\tif (m->foundLarger)\n\t\t\t// always prefer larger ones\n\t\t\treturn;\n\tif (x >= m->targetX && y >= m->targetY && !m->foundLarger)\n\t\t// we set foundLarger below\n\t\tgoto writeMatch;\n\n\tx2 = abs(m->targetX - x);\n\ty2 = abs(m->targetY - y);\n\tif (x2 < m->distX && y2 < m->distY)\n\t\tgoto writeMatch;\n\n\t// TODO weight one dimension? threshhold?\n\treturn;\n\nwriteMatch:\n\t// must set this here too; otherwise the first image will never have ths set\n\tif (x >= m->targetX && y >= m->targetY && !m->foundLarger)\n\t\tm->foundLarger = TRUE;\n\tm->best = cs;\n\tm->distX = abs(m->targetX - x);\n\tm->distY = abs(m->targetY - y);\n}", "path": "libui/unix/image.c", "commit_date": "2018-08-30 00:00:00", "repo_name": "andlabs/libui", "stars": 10609, "license": "other", "language": "c", "size": 6375}
{"docstring": "// TODO scroll to end?\n", "func_signal": "void uiMultilineEntryAppend(uiMultilineEntry *e, const char *text)", "code": "{\n\tGtkTextIter end;\n\n\tgtk_text_buffer_get_end_iter(e->textbuf, &end);\n\t// we need to inhibit sending of ::changed because this WILL send a ::changed otherwise\n\tg_signal_handler_block(e->textbuf, e->onChangedSignal);\n\tgtk_text_buffer_insert(e->textbuf, &end, text, -1);\n\tg_signal_handler_unblock(e->textbuf, e->onChangedSignal);\n}", "path": "libui/unix/multilineentry.c", "commit_date": "2017-02-08 00:00:00", "repo_name": "andlabs/libui", "stars": 10609, "license": "other", "language": "c", "size": 6375}
{"docstring": "// TODO see if this can be cleaned up somehow\n", "func_signal": "const uint16_t *uiprivUTF16DecodeRune(const uint16_t *s, size_t nElem, uint32_t *rune)", "code": "{\n\tuint16_t high, low;\n\n\tif (*s < 0xD800 || *s >= 0xE000) {\n\t\t// self-representing character\n\t\t*rune = *s;\n\t\ts++;\n\t\treturn s;\n\t}\n\tif (*s >= 0xDC00) {\n\t\t// out-of-order surrogates\n\t\t*rune = badrune;\n\t\ts++;\n\t\treturn s;\n\t}\n\tif (nElem == 1) {\t\t// not enough elements\n\t\t*rune = badrune;\n\t\ts++;\n\t\treturn s;\n\t}\n\thigh = *s;\n\thigh &= 0x3FF;\n\tif (s[1] < 0xDC00 || s[1] >= 0xE000) {\n\t\t// bad surrogate pair\n\t\t*rune = badrune;\n\t\ts++;\n\t\treturn s;\n\t}\n\ts++;\n\tlow = *s;\n\ts++;\n\tlow &= 0x3FF;\n\t*rune = high;\n\t*rune <<= 10;\n\t*rune |= low;\n\t*rune += 0x10000;\n\treturn s;\n}", "path": "libui/common/utf.c", "commit_date": "2018-04-16 00:00:00", "repo_name": "andlabs/libui", "stars": 10609, "license": "other", "language": "c", "size": 6375}
{"docstring": "// note: we can't use gtk_render_insertion_cursor() because that doesn't take information about what line to render on\n// we'll just recreate what it does\n", "func_signal": "void caretDrawParams(uiDrawContext *c, double height, struct caretDrawParams *p)", "code": "{\n\tGdkColor *color;\n\tGdkRGBA rgba;\n\tgfloat aspectRatio;\n\tgint width, xoff;\n\n\tgtk_style_context_get_style(c->style,\n\t\t\"cursor-color\", &color,\n\t\t\"cursor-aspect-ratio\", &aspectRatio,\n\t\tNULL);\n\tif (color != NULL) {\n\t\tp->r = ((double) (color->red)) / 65535.0;\n\t\tp->g = ((double) (color->green)) / 65535.0;\n\t\tp->b = ((double) (color->blue)) / 65535.0;\n\t\tp->a = 1.0;\n\t\tgdk_color_free(color);\n\t} else {\n\t\tgtk_style_context_get_color(c->style, GTK_STATE_FLAG_NORMAL, &rgba);\n\t\tp->r = rgba.red;\n\t\tp->g = rgba.green;\n\t\tp->b = rgba.blue;\n\t\tp->a = rgba.alpha;\n\t}\n\n\t// GTK+ itself uses integer arithmetic here; let's do the same\n\twidth = height * aspectRatio + 1;\n\t// TODO this is for LTR\n\txoff = width / 2;\n\n\tp->xoff = xoff;\n\tp->width = width;\n}", "path": "libui/_wip/attrstr_metrics/unix_OLD_drawtext.c", "commit_date": "2018-03-18 00:00:00", "repo_name": "andlabs/libui", "stars": 10609, "license": "other", "language": "c", "size": 6375}
{"docstring": "// returns a to allow expressions like b = uiprivAttributeRetain(a)\n// TODO would this allow us to copy attributes between strings in a foreach func, and if so, should that be allowed?\n", "func_signal": "uiAttribute *uiprivAttributeRetain(uiAttribute *a)", "code": "{\n\ta->ownedByUser = 0;\n\ta->refcount++;\n\treturn a;\n}", "path": "libui/common/attribute.c", "commit_date": "2018-04-15 00:00:00", "repo_name": "andlabs/libui", "stars": 10609, "license": "other", "language": "c", "size": 6375}
{"docstring": "// TODO add a test for childless windows\n// TODO add tests for contianers with all controls hidden\n", "func_signal": "static uiGroup *newg(const char *n, int s)", "code": "{\n\tuiGroup *g;\n\n\tg = uiNewGroup(n);\n\tif (s)\n\t\tuiGroupSetChild(g, NULL);\n\treturn g;\n}", "path": "libui/test/page11.c", "commit_date": "2016-06-14 00:00:00", "repo_name": "andlabs/libui", "stars": 10609, "license": "other", "language": "c", "size": 6375}
{"docstring": "// helper to quickly set a brush color\n", "func_signal": "static void setSolidBrush(uiDrawBrush *brush, uint32_t color, double alpha)", "code": "{\n\tuint8_t component;\n\n\tbrush->Type = uiDrawBrushTypeSolid;\n\tcomponent = (uint8_t) ((color >> 16) & 0xFF);\n\tbrush->R = ((double) component) / 255;\n\tcomponent = (uint8_t) ((color >> 8) & 0xFF);\n\tbrush->G = ((double) component) / 255;\n\tcomponent = (uint8_t) (color & 0xFF);\n\tbrush->B = ((double) component) / 255;\n\tbrush->A = alpha;\n}", "path": "libui/examples/histogram/main.c", "commit_date": "2016-05-16 00:00:00", "repo_name": "andlabs/libui", "stars": 10609, "license": "other", "language": "c", "size": 6375}
{"docstring": "/* WIN32 */\n", "func_signal": "static int\ncompute_file_id_with_cdc (const char *path, SeafStat *st,\n                          SeafileCrypt *crypt, int repo_version,\n                          uint32_t blk_avg_size, uint32_t blk_min_size, uint32_t blk_max_size,\n                          unsigned char sha1[])", "code": "{\n    CDCFileDescriptor cdc;\n\n    memset (&cdc, 0, sizeof(cdc));\n    cdc.block_sz = blk_avg_size;\n    cdc.block_min_sz = blk_min_size;\n    cdc.block_max_sz = blk_max_size;\n    cdc.write_block = seafile_write_chunk;\n    if (filename_chunk_cdc (path, &cdc, crypt, FALSE) < 0) {\n        seaf_warning (\"Failed to chunk file.\\n\");\n        return -1;\n    }\n\n    if (repo_version > 0)\n        seaf_fs_manager_calculate_seafile_id_json (repo_version, &cdc, sha1);\n    else\n        memcpy (sha1, cdc.file_sum, 20);\n\n    if (cdc.blk_sha1s)\n        free (cdc.blk_sha1s);\n\n    return 0;\n}", "path": "seafile/daemon/vc-utils.c", "commit_date": "2020-08-18 00:00:00", "repo_name": "haiwen/seafile", "stars": 11487, "license": "other", "language": "c", "size": 12132}
{"docstring": "/*\n * strtok_r code directly from glibc.git /string/strtok_r.c since windows\n * doesn't have it.\n */\n", "func_signal": "char *\nstrtok_r(char *s, const char *delim, char **save_ptr)", "code": "{\n    char *token;\n    \n    if(s == NULL)\n        s = *save_ptr;\n    \n    /* Scan leading delimiters.  */\n    s += strspn(s, delim);\n    if(*s == '\\0') {\n        *save_ptr = s;\n        return NULL;\n    }\n    \n    /* Find the end of the token.  */\n    token = s;\n    s = strpbrk(token, delim);\n    \n    if(s == NULL) {\n        /* This token finishes the string.  */\n        *save_ptr = strchr(token, '\\0');\n    } else {\n        /* Terminate the token and make *SAVE_PTR point past it.  */\n        *s = '\\0';\n        *save_ptr = s + 1;\n    }\n    \n    return token;\n}", "path": "seafile/lib/utils.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "haiwen/seafile", "stars": 11487, "license": "other", "language": "c", "size": 12132}
{"docstring": "/*\n * Returns < 0 if dira includes dirb or dira == dirb;\n * Returns 0 if no inclusive relationship;\n * Returns > 0 if dirb includes dira.\n */\n", "func_signal": "static int\ncheck_dir_inclusiveness (const char *dira, const char *dirb)", "code": "{\n    char *a, *b;\n    char *p1, *p2;\n    int ret = 0;\n\n    a = g_strdup(dira);\n    b = g_strdup(dirb);\n    remove_trail_slash (a);\n    remove_trail_slash (b);\n\n    p1 = a;\n    p2 = b;\n    while (*p1 != 0 && *p2 != 0) {\n        /* Go to the last one in a path separator sequence. */\n        while (is_separator(*p1) && is_separator(p1[1]))\n            ++p1;\n        while (is_separator(*p2) && is_separator(p2[1]))\n            ++p2;\n\n        if (!(is_separator(*p1) && is_separator(*p2)) && *p1 != *p2)\n            goto out;\n\n        ++p1;\n        ++p2;\n    }\n\n    /* Example:\n     *            p1\n     * a: /abc/def/ghi\n     *            p2\n     * b: /abc/def\n     */\n    if (*p1 == 0 && *p2 == 0)\n        ret = -1;\n    else if (*p1 != 0 && is_separator(*p1))\n        ret = 1;\n    else if (*p2 != 0 && is_separator(*p2))\n        ret = -1;\n\nout:\n    g_free (a);\n    g_free (b);\n    return ret;\n}", "path": "seafile/daemon/clone-mgr.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "haiwen/seafile", "stars": 11487, "license": "other", "language": "c", "size": 12132}
{"docstring": "/**\n * string_list_is_exists:\n * @str_list: \n * @string: a C string or %NULL\n *\n * Check whether @string is in @str_list.\n *\n * returns: %TRUE if @string is in str_list, %FALSE otherwise\n */\n", "func_signal": "gboolean\nstring_list_is_exists (GList *str_list, const char *string)", "code": "{\n    GList *ptr;\n    for (ptr = str_list; ptr; ptr = ptr->next) {\n        if (g_strcmp0(string, ptr->data) == 0)\n            return TRUE;\n    }\n    return FALSE;\n}", "path": "seafile/lib/utils.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "haiwen/seafile", "stars": 11487, "license": "other", "language": "c", "size": 12132}
{"docstring": "/**\n * handle the empty string problem.\n */\n", "func_signal": "gchar* \nccnet_key_file_get_string (GKeyFile *keyf,\n                           const char *category,\n                           const char *key)", "code": "{\n    gchar *v;\n\n    if (!g_key_file_has_key (keyf, category, key, NULL))\n        return NULL;\n\n    v = g_key_file_get_string (keyf, category, key, NULL);\n    if (v != NULL && v[0] == '\\0') {\n        g_free(v);\n        return NULL;\n    }\n\n    return v;\n}", "path": "seafile/lib/utils.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "haiwen/seafile", "stars": 11487, "license": "other", "language": "c", "size": 12132}
{"docstring": "/* read the /proc fs to determine whether some process is running */\n", "func_signal": "gboolean process_is_running (const char *process_name)", "code": "{\n    DIR *proc_dir = opendir(\"/proc\");\n    if (!proc_dir) {\n        fprintf (stderr, \"failed to open /proc/ dir\\n\");\n        return FALSE;\n    }\n\n    struct dirent *subdir = NULL;\n    while ((subdir = readdir(proc_dir))) {\n        char first = subdir->d_name[0];\n        /* /proc/[1-9][0-9]* */\n        if (first > '9' || first < '1')\n            continue;\n        int pid = find_process_in_dirent(subdir, process_name);\n        if (pid > 0) {\n            closedir(proc_dir);\n            return TRUE;\n        }\n    }\n\n    closedir(proc_dir);\n    return FALSE;\n}", "path": "seafile/lib/utils.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "haiwen/seafile", "stars": 11487, "license": "other", "language": "c", "size": 12132}
{"docstring": "/**\n * string_list_append:\n * @str_list: \n * @string: a C string (can't be %NULL\n *\n * Append @string to @str_list if it is in the list.\n *\n * returns: the new start of the list\n */\n", "func_signal": "GList*\nstring_list_append (GList *str_list, const char *string)", "code": "{\n    g_return_val_if_fail (string != NULL, str_list);\n\n    if (string_list_is_exists(str_list, string))\n        return str_list;\n\n    str_list = g_list_append (str_list, g_strdup(string));\n    return str_list;\n}", "path": "seafile/lib/utils.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "haiwen/seafile", "stars": 11487, "license": "other", "language": "c", "size": 12132}
{"docstring": "/*\n * Rename file from @tmp_path to @obj_path.\n * This also makes sure the changes to @obj_path's parent folder\n * is flushed to disk.\n */\n", "func_signal": "static int\nrename_and_sync (const char *tmp_path, const char *obj_path)", "code": "{\n#ifdef __linux__\n    char *parent_dir;\n    int ret = 0;\n\n    if (rename (tmp_path, obj_path) < 0) {\n        seaf_warning (\"Failed to rename from %s to %s: %s.\\n\",\n                      tmp_path, obj_path, strerror(errno));\n        return -1;\n    }\n\n    parent_dir = g_path_get_dirname (obj_path);\n    int dir_fd = open (parent_dir, O_RDONLY);\n    if (dir_fd < 0) {\n        seaf_warning (\"Failed to open dir %s: %s.\\n\", parent_dir, strerror(errno));\n        goto out;\n    }\n\n    /* Some file systems don't support fsyncing a directory. Just ignore the error.\n     */\n    if (fsync (dir_fd) < 0) {\n        if (errno != EINVAL) {\n            seaf_warning (\"Failed to fsync dir %s: %s.\\n\",\n                          parent_dir, strerror(errno));\n            ret = -1;\n        }\n        goto out;\n    }\n\nout:\n    g_free (parent_dir);\n    if (dir_fd >= 0)\n        close (dir_fd);\n    return ret;\n#endif\n\n#ifdef __APPLE__\n    /*\n     * OS X garantees an existence of obj_path always exists,\n     * even when the system crashes.\n     */\n    if (rename (tmp_path, obj_path) < 0) {\n        seaf_warning (\"Failed to rename from %s to %s: %s.\\n\",\n                      tmp_path, obj_path, strerror(errno));\n        return -1;\n    }\n    return 0;\n#endif\n\n#ifdef WIN32\n    wchar_t *w_tmp_path = g_utf8_to_utf16 (tmp_path, -1, NULL, NULL, NULL);\n    wchar_t *w_obj_path = g_utf8_to_utf16 (obj_path, -1, NULL, NULL, NULL);\n    int ret = 0;\n\n    if (!MoveFileExW (w_tmp_path, w_obj_path,\n                      MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH)) {\n        seaf_warning (\"MoveFilExW failed: %lu.\\n\", GetLastError());\n        ret = -1;\n        goto out;\n    }\n\nout:\n    g_free (w_tmp_path);\n    g_free (w_obj_path);\n    return ret;\n#endif\n}", "path": "seafile/common/obj-backend-fs.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "haiwen/seafile", "stars": 11487, "license": "other", "language": "c", "size": 12132}
{"docstring": "/* Write \"n\" bytes to a descriptor. */\n", "func_signal": "writen(int fd, const void *vptr, size_t n)", "code": "{\n\tsize_t\t\tnleft;\n\tssize_t\t\tnwritten;\n\tconst char\t*ptr;\n\n\tptr = vptr;\n\tnleft = n;\n\twhile (nleft > 0) {\n\t\tif ( (nwritten = write(fd, ptr, nleft)) <= 0) {\n\t\t\tif (nwritten < 0 && errno == EINTR)\n\t\t\t\tnwritten = 0;\t\t/* and call write() again */\n\t\t\telse\n\t\t\t\treturn(-1);\t\t\t/* error */\n\t\t}\n\n\t\tnleft -= nwritten;\n\t\tptr   += nwritten;\n\t}\n\treturn(n);\n}", "path": "seafile/lib/utils.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "haiwen/seafile", "stars": 11487, "license": "other", "language": "c", "size": 12132}
{"docstring": "/* convert utf8 input to locale specific string  */\n", "func_signal": "char *ccnet_locale_from_utf8 (const gchar *src)", "code": "{\n    if (!src)\n        return NULL;\n\n    gsize bytes_read = 0;\n    gsize bytes_written = 0;\n    GError *error = NULL;\n    gchar *dst = NULL;\n\n    dst = g_locale_from_utf8\n        (src,                   /* locale specific string */\n         strlen(src),           /* len of src */\n         &bytes_read,           /* length processed */\n         &bytes_written,        /* output length */\n         &error);\n\n    if (error) {\n        return NULL;\n    }\n\n    return dst;\n}", "path": "seafile/lib/utils.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "haiwen/seafile", "stars": 11487, "license": "other", "language": "c", "size": 12132}
{"docstring": "/* Read \"n\" bytes from a descriptor. */\n", "func_signal": "recvn(evutil_socket_t fd, void *vptr, size_t n)", "code": "{\n\tsize_t\tnleft;\n\tssize_t\tnread;\n\tchar\t*ptr;\n\n\tptr = vptr;\n\tnleft = n;\n\twhile (nleft > 0) {\n#ifndef WIN32\n        if ( (nread = read(fd, ptr, nleft)) < 0)\n#else\n        if ( (nread = recv(fd, ptr, nleft, 0)) < 0)\n#endif\n        {\n\t\t\tif (errno == EINTR)\n\t\t\t\tnread = 0;\t\t/* and call read() again */\n\t\t\telse\n\t\t\t\treturn(-1);\n\t\t} else if (nread == 0)\n\t\t\tbreak;\t\t\t\t/* EOF */\n\n\t\tnleft -= nread;\n\t\tptr   += nread;\n\t}\n\treturn(n - nleft);\t\t/* return >= 0 */\n}", "path": "seafile/lib/utils.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "haiwen/seafile", "stars": 11487, "license": "other", "language": "c", "size": 12132}
{"docstring": "/* On Mac, we only check whether an office file is opened and locked.\n * The detection is done by checking ~$* tmp file.\n */\n", "func_signal": "gboolean\ndo_check_file_locked (const char *path, const char *worktree, gboolean locked_on_server)", "code": "{\n#define OFFICE_FILE_PATTERN \".*\\\\.(docx|xlsx|pptx|doc|xls|ppt|vsdx)\"\n    char *dir_name = NULL, *file_name = NULL;\n    char *fullpath = NULL;\n    char *tmp_name = NULL;\n    int ret = FALSE;\n\n    if (!g_regex_match_simple (OFFICE_FILE_PATTERN, path, 0, 0))\n        return FALSE;\n\n    dir_name = g_path_get_dirname (path);\n    if (strcmp (dir_name, \".\") == 0) {\n        g_free (dir_name);\n        dir_name = g_strdup(\"\");\n    }\n    file_name = g_path_get_basename (path);\n\n    tmp_name = g_strconcat (\"~$\", file_name, NULL);\n    fullpath = g_build_path (\"/\", worktree, dir_name, tmp_name, NULL);\n    if (g_file_test (fullpath, G_FILE_TEST_IS_REGULAR)) {\n        ret = TRUE;\n        goto out;\n    }\n    g_free (tmp_name);\n    g_free (fullpath);\n\n    /* Sometimes the first two characters are replaced by ~$. */\n\n    if (g_utf8_strlen(file_name, -1) < 2)\n        goto out;\n\n    char *ptr = g_utf8_find_next_char(g_utf8_find_next_char (file_name, NULL), NULL);\n    tmp_name = g_strconcat (\"~$\", ptr, NULL);\n    fullpath = g_build_path (\"/\", worktree, dir_name, tmp_name, NULL);\n    if (g_file_test (fullpath, G_FILE_TEST_IS_REGULAR)) {\n        ret = TRUE;\n        goto out;\n    }\n\nout:\n    g_free (fullpath);\n    g_free (tmp_name);\n    g_free (dir_name);\n    g_free (file_name);\n    return ret;\n}", "path": "seafile/daemon/vc-utils.c", "commit_date": "2020-08-18 00:00:00", "repo_name": "haiwen/seafile", "stars": 11487, "license": "other", "language": "c", "size": 12132}
{"docstring": "/* Read \"n\" bytes from a descriptor. */\n", "func_signal": "readn(int fd, void *vptr, size_t n)", "code": "{\n\tsize_t\tnleft;\n\tssize_t\tnread;\n\tchar\t*ptr;\n\n\tptr = vptr;\n\tnleft = n;\n\twhile (nleft > 0) {\n\t\tif ( (nread = read(fd, ptr, nleft)) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tnread = 0;\t\t/* and call read() again */\n\t\t\telse\n\t\t\t\treturn(-1);\n\t\t} else if (nread == 0)\n\t\t\tbreak;\t\t\t\t/* EOF */\n\n\t\tnleft -= nread;\n\t\tptr   += nread;\n\t}\n\treturn(n - nleft);\t\t/* return >= 0 */\n}", "path": "seafile/lib/utils.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "haiwen/seafile", "stars": 11487, "license": "other", "language": "c", "size": 12132}
{"docstring": "/* seaf_pipe() should only be called in the main loop,\n * since it accesses the static global socket.\n */\n", "func_signal": "int\nseaf_pipe (seaf_pipe_t handles[2])", "code": "{\n    int len = sizeof( pg_serv_addr );\n\n    handles[0] = handles[1] = INVALID_SOCKET;\n\n    if (pg_serv_sock == INVALID_SOCKET) {\n        if ((pg_serv_sock = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) {\n            seaf_warning(\"seaf_pipe failed to create socket: %d\\n\", WSAGetLastError());\n            return -1;\n        }\n\n        memset(&pg_serv_addr, 0, sizeof(pg_serv_addr));\n        pg_serv_addr.sin_family = AF_INET;\n        pg_serv_addr.sin_port = htons(0);\n        pg_serv_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\n        if (bind(pg_serv_sock, (SOCKADDR *)&pg_serv_addr, len) == SOCKET_ERROR) {\n            seaf_warning(\"seaf_pipe failed to bind: %d\\n\", WSAGetLastError());\n            closesocket(pg_serv_sock);\n            pg_serv_sock = INVALID_SOCKET;\n            return -1;\n        }\n\n        if (listen(pg_serv_sock, SOMAXCONN) == SOCKET_ERROR) {\n            seaf_warning(\"seaf_pipe failed to listen: %d\\n\", WSAGetLastError());\n            closesocket(pg_serv_sock);\n            pg_serv_sock = INVALID_SOCKET;\n            return -1;\n        }\n\n        struct sockaddr_in tmp_addr;\n        int tmp_len = sizeof(tmp_addr);\n        if (getsockname(pg_serv_sock, (SOCKADDR *)&tmp_addr, &tmp_len) == SOCKET_ERROR) {\n            seaf_warning(\"seaf_pipe failed to getsockname: %d\\n\", WSAGetLastError());\n            closesocket(pg_serv_sock);\n            pg_serv_sock = INVALID_SOCKET;\n            return -1;\n        }\n        pg_serv_addr.sin_port = tmp_addr.sin_port;\n    }\n\n    if ((handles[1] = socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)\n    {\n        seaf_warning(\"seaf_pipe failed to create socket 2: %d\\n\", WSAGetLastError());\n        closesocket(pg_serv_sock);\n        pg_serv_sock = INVALID_SOCKET;\n        return -1;\n    }\n\n    if (connect(handles[1], (SOCKADDR *)&pg_serv_addr, len) == SOCKET_ERROR)\n    {\n        seaf_warning(\"seaf_pipe failed to connect socket: %d\\n\", WSAGetLastError());\n        closesocket(handles[1]);\n        handles[1] = INVALID_SOCKET;\n        closesocket(pg_serv_sock);\n        pg_serv_sock = INVALID_SOCKET;\n        return -1;\n    }\n\n    struct sockaddr_in client_addr;\n    int client_len = sizeof(client_addr);\n    if ((handles[0] = accept(pg_serv_sock, (SOCKADDR *)&client_addr, &client_len)) == INVALID_SOCKET)\n    {\n        seaf_warning(\"seaf_pipe failed to accept socket: %d\\n\", WSAGetLastError());\n        closesocket(handles[1]);\n        handles[1] = INVALID_SOCKET;\n        closesocket(pg_serv_sock);\n        pg_serv_sock = INVALID_SOCKET;\n        return -1;\n    }\n\n    return 0;\n}", "path": "seafile/lib/utils.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "haiwen/seafile", "stars": 11487, "license": "other", "language": "c", "size": 12132}
{"docstring": "/*\n * Flush operating system and disk caches for @fd.\n */\n", "func_signal": "static int\nfsync_obj_contents (int fd)", "code": "{\n#ifdef __linux__\n    /* Some file systems may not support fsync().\n     * In this case, just skip the error.\n     */\n    if (fsync (fd) < 0) {\n        if (errno == EINVAL)\n            return 0;\n        else {\n            seaf_warning (\"Failed to fsync: %s.\\n\", strerror(errno));\n            return -1;\n        }\n    }\n    return 0;\n#endif\n\n#ifdef __APPLE__\n    /* OS X: fcntl() is required to flush disk cache, fsync() only\n     * flushes operating system cache.\n     */\n    if (fcntl (fd, F_FULLFSYNC, NULL) < 0) {\n        seaf_warning (\"Failed to fsync: %s.\\n\", strerror(errno));\n        return -1;\n    }\n    return 0;\n#endif\n\n#ifdef WIN32\n    HANDLE handle;\n\n    handle = (HANDLE)_get_osfhandle (fd);\n    if (handle == INVALID_HANDLE_VALUE) {\n        seaf_warning (\"Failed to get handle from fd.\\n\");\n        return -1;\n    }\n\n    if (!FlushFileBuffers (handle)) {\n        seaf_warning (\"FlushFileBuffer() failed: %lu.\\n\", GetLastError());\n        return -1;\n    }\n\n    return 0;\n#endif\n}", "path": "seafile/common/obj-backend-fs.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "haiwen/seafile", "stars": 11487, "license": "other", "language": "c", "size": 12132}
{"docstring": "/* read the link of /proc/123/exe and compare with `process_name' */\n", "func_signal": "static int\nfind_process_in_dirent(struct dirent *dir, const char *process_name)", "code": "{\n    char path[512];\n    /* fisrst construct a path like /proc/123/exe */\n    if (sprintf (path, \"/proc/%s/exe\", dir->d_name) < 0) {\n        return -1;\n    }\n\n    char buf[SEAF_PATH_MAX];\n    /* get the full path of exe */\n    ssize_t l = readlink(path, buf, SEAF_PATH_MAX);\n\n    if (l < 0)\n        return -1;\n    buf[l] = '\\0';\n\n    /* get the base name of exe */\n    char *base = g_path_get_basename(buf);\n    int ret = strcmp(base, process_name);\n    g_free(base);\n\n    if (ret == 0)\n        return atoi(dir->d_name);\n    else\n        return -1;\n}", "path": "seafile/lib/utils.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "haiwen/seafile", "stars": 11487, "license": "other", "language": "c", "size": 12132}
{"docstring": "/* convert locale specific input to utf8 encoded string  */\n", "func_signal": "char *ccnet_locale_to_utf8 (const gchar *src)", "code": "{\n    if (!src)\n        return NULL;\n\n    gsize bytes_read = 0;\n    gsize bytes_written = 0;\n    GError *error = NULL;\n    gchar *dst = NULL;\n\n    dst = g_locale_to_utf8\n        (src,                   /* locale specific string */\n         strlen(src),           /* len of src */\n         &bytes_read,           /* length processed */\n         &bytes_written,        /* output length */\n         &error);\n\n    if (error) {\n        return NULL;\n    }\n\n    return dst;\n}", "path": "seafile/lib/utils.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "haiwen/seafile", "stars": 11487, "license": "other", "language": "c", "size": 12132}
{"docstring": "/* Convert a (possible) 8.3 format path to long path */\n", "func_signal": "wchar_t *\nwin32_83_path_to_long_path (const char *worktree, const wchar_t *path, int path_len)", "code": "{\n    wchar_t *worktree_w = g_utf8_to_utf16 (worktree, -1, NULL, NULL, NULL);\n    int wt_len;\n    wchar_t *p;\n    wchar_t *fullpath_w = NULL;\n    wchar_t *fullpath_long = NULL;\n    wchar_t *ret = NULL;\n    char *fullpath;\n\n    for (p = worktree_w; *p != L'\\0'; ++p)\n        if (*p == L'/')\n            *p = L'\\\\';\n\n    wt_len = wcslen(worktree_w);\n\n    fullpath_w = g_new0 (wchar_t, wt_len + path_len + 6);\n    wcscpy (fullpath_w, L\"\\\\\\\\?\\\\\");\n    wcscat (fullpath_w, worktree_w);\n    wcscat (fullpath_w, L\"\\\\\");\n    wcsncat (fullpath_w, path, path_len);\n\n    fullpath_long = g_new0 (wchar_t, SEAF_PATH_MAX);\n\n    DWORD n = GetLongPathNameW (fullpath_w, fullpath_long, SEAF_PATH_MAX);\n    if (n == 0) {\n        /* Failed. */\n        fullpath = g_utf16_to_utf8 (fullpath_w, -1, NULL, NULL, NULL);\n        g_free (fullpath);\n\n        goto out;\n    } else if (n > SEAF_PATH_MAX) {\n        /* In this case n is the necessary length for the buf. */\n        g_free (fullpath_long);\n        fullpath_long = g_new0 (wchar_t, n);\n\n        if (GetLongPathNameW (fullpath_w, fullpath_long, n) != (n - 1)) {\n            fullpath = g_utf16_to_utf8 (fullpath_w, -1, NULL, NULL, NULL);\n            g_free (fullpath);\n\n            goto out;\n        }\n    }\n\n    /* Remove \"\\\\?\\worktree\\\" from the beginning. */\n    ret = wcsdup (fullpath_long + wt_len + 5);\n\nout:\n    g_free (worktree_w);\n    g_free (fullpath_w);\n    g_free (fullpath_long);\n\n    return ret;\n}", "path": "seafile/lib/utils.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "haiwen/seafile", "stars": 11487, "license": "other", "language": "c", "size": 12132}
{"docstring": "/* JSON related utils. For compatibility with json-glib. */\n", "func_signal": "const char *\njson_object_get_string_member (json_t *object, const char *key)", "code": "{\n    json_t *string = json_object_get (object, key);\n    if (!string)\n        return NULL;\n    return json_string_value (string);\n}", "path": "seafile/lib/utils.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "haiwen/seafile", "stars": 11487, "license": "other", "language": "c", "size": 12132}
{"docstring": "/*\n * Generate a conflict-free path to be used as worktree.\n * This worktree path can be used as the @worktree parameter\n * for seaf_clone_manager_add_task().\n */\n", "func_signal": "char *\nseaf_clone_manager_gen_default_worktree (SeafCloneManager *mgr,\n                                         const char *worktree_parent,\n                                         const char *repo_name)", "code": "{\n    char *wt = g_build_filename (worktree_parent, repo_name, NULL);\n    char *worktree;\n\n    worktree = make_worktree (mgr, wt, TRUE, NULL);\n    if (!worktree)\n        return wt;\n\n    g_free (wt);\n    return worktree;\n}", "path": "seafile/daemon/clone-mgr.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "haiwen/seafile", "stars": 11487, "license": "other", "language": "c", "size": 12132}
{"docstring": "/*\n h = a * p\n where a = a[0]+256*a[1]+...+256^31 a[31]\n\n Preconditions:\n a[31] <= 127\n\n p is public\n */\n", "func_signal": "void\nge25519_scalarmult(ge25519_p3 *h, const unsigned char *a, const ge25519_p3 *p)", "code": "{\n    signed char     e[64];\n    signed char     carry;\n    ge25519_p1p1    r;\n    ge25519_p2      s;\n    ge25519_p1p1    t2, t3, t4, t5, t6, t7, t8;\n    ge25519_p3      p2, p3, p4, p5, p6, p7, p8;\n    ge25519_cached  pi[8];\n    ge25519_cached  t;\n    int             i;\n\n    ge25519_p3_to_cached(&pi[1 - 1], p);   /* p */\n\n    ge25519_p3_dbl(&t2, p);\n    ge25519_p1p1_to_p3(&p2, &t2);\n    ge25519_p3_to_cached(&pi[2 - 1], &p2); /* 2p = 2*p */\n\n    ge25519_add_cached(&t3, p, &pi[2 - 1]);\n    ge25519_p1p1_to_p3(&p3, &t3);\n    ge25519_p3_to_cached(&pi[3 - 1], &p3); /* 3p = 2p+p */\n\n    ge25519_p3_dbl(&t4, &p2);\n    ge25519_p1p1_to_p3(&p4, &t4);\n    ge25519_p3_to_cached(&pi[4 - 1], &p4); /* 4p = 2*2p */\n\n    ge25519_add_cached(&t5, p, &pi[4 - 1]);\n    ge25519_p1p1_to_p3(&p5, &t5);\n    ge25519_p3_to_cached(&pi[5 - 1], &p5); /* 5p = 4p+p */\n\n    ge25519_p3_dbl(&t6, &p3);\n    ge25519_p1p1_to_p3(&p6, &t6);\n    ge25519_p3_to_cached(&pi[6 - 1], &p6); /* 6p = 2*3p */\n\n    ge25519_add_cached(&t7, p, &pi[6 - 1]);\n    ge25519_p1p1_to_p3(&p7, &t7);\n    ge25519_p3_to_cached(&pi[7 - 1], &p7); /* 7p = 6p+p */\n\n    ge25519_p3_dbl(&t8, &p4);\n    ge25519_p1p1_to_p3(&p8, &t8);\n    ge25519_p3_to_cached(&pi[8 - 1], &p8); /* 8p = 2*4p */\n\n    for (i = 0; i < 32; ++i) {\n        e[2 * i + 0] = (a[i] >> 0) & 15;\n        e[2 * i + 1] = (a[i] >> 4) & 15;\n    }\n    /* each e[i] is between 0 and 15 */\n    /* e[63] is between 0 and 7 */\n\n    carry = 0;\n    for (i = 0; i < 63; ++i) {\n        e[i] += carry;\n        carry = e[i] + 8;\n        carry >>= 4;\n        e[i] -= carry * ((signed char) 1 << 4);\n    }\n    e[63] += carry;\n    /* each e[i] is between -8 and 8 */\n\n    ge25519_p3_0(h);\n\n    for (i = 63; i != 0; i--) {\n        ge25519_cmov8_cached(&t, pi, e[i]);\n        ge25519_add_cached(&r, h, &t);\n\n        ge25519_p1p1_to_p2(&s, &r);\n        ge25519_p2_dbl(&r, &s);\n        ge25519_p1p1_to_p2(&s, &r);\n        ge25519_p2_dbl(&r, &s);\n        ge25519_p1p1_to_p2(&s, &r);\n        ge25519_p2_dbl(&r, &s);\n        ge25519_p1p1_to_p2(&s, &r);\n        ge25519_p2_dbl(&r, &s);\n\n        ge25519_p1p1_to_p3(h, &r);  /* *16 */\n    }\n    ge25519_cmov8_cached(&t, pi, e[i]);\n    ge25519_add_cached(&r, h, &t);\n\n    ge25519_p1p1_to_p3(h, &r);\n}", "path": "libsodium/src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c", "commit_date": "2020-10-06 00:00:00", "repo_name": "jedisct1/libsodium", "stars": 11811, "license": "other", "language": "c", "size": 8564}
{"docstring": "/*\n * Inversion - returns 0 if z=0\n */\n", "func_signal": "void\nfe25519_invert(fe25519 out, const fe25519 z)", "code": "{\n    fe25519 t0, t1, t2, t3;\n    int     i;\n\n    fe25519_sq(t0, z);\n    fe25519_sq(t1, t0);\n    fe25519_sq(t1, t1);\n    fe25519_mul(t1, z, t1);\n    fe25519_mul(t0, t0, t1);\n    fe25519_sq(t2, t0);\n    fe25519_mul(t1, t1, t2);\n    fe25519_sq(t2, t1);\n    for (i = 1; i < 5; ++i) {\n        fe25519_sq(t2, t2);\n    }\n    fe25519_mul(t1, t2, t1);\n    fe25519_sq(t2, t1);\n    for (i = 1; i < 10; ++i) {\n        fe25519_sq(t2, t2);\n    }\n    fe25519_mul(t2, t2, t1);\n    fe25519_sq(t3, t2);\n    for (i = 1; i < 20; ++i) {\n        fe25519_sq(t3, t3);\n    }\n    fe25519_mul(t2, t3, t2);\n    for (i = 1; i < 11; ++i) {\n        fe25519_sq(t2, t2);\n    }\n    fe25519_mul(t1, t2, t1);\n    fe25519_sq(t2, t1);\n    for (i = 1; i < 50; ++i) {\n        fe25519_sq(t2, t2);\n    }\n    fe25519_mul(t2, t2, t1);\n    fe25519_sq(t3, t2);\n    for (i = 1; i < 100; ++i) {\n        fe25519_sq(t3, t3);\n    }\n    fe25519_mul(t2, t3, t2);\n    for (i = 1; i < 51; ++i) {\n        fe25519_sq(t2, t2);\n    }\n    fe25519_mul(t1, t2, t1);\n    for (i = 1; i < 6; ++i) {\n        fe25519_sq(t1, t1);\n    }\n    fe25519_mul(out, t1, t0);\n}", "path": "libsodium/src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c", "commit_date": "2020-10-06 00:00:00", "repo_name": "jedisct1/libsodium", "stars": 11811, "license": "other", "language": "c", "size": 8564}
{"docstring": "/* montgomery to edwards */\n", "func_signal": "static void\nge25519_mont_to_ed(fe25519 xed, fe25519 yed, const fe25519 x, const fe25519 y)", "code": "{\n    fe25519 one;\n    fe25519 x_plus_one;\n    fe25519 x_minus_one;\n    fe25519 x_plus_one_y_inv;\n\n    fe25519_1(one);\n    fe25519_add(x_plus_one, x, one);\n    fe25519_sub(x_minus_one, x, one);\n\n    /* xed = sqrt(-A-2)*x/y */\n    fe25519_mul(x_plus_one_y_inv, x_plus_one, y);\n    fe25519_invert(x_plus_one_y_inv, x_plus_one_y_inv); /* 1/((x+1)*y) */\n    fe25519_mul(xed, x, ed25519_sqrtam2);\n    fe25519_mul(xed, xed, x_plus_one_y_inv);            /* sqrt(-A-2)*x/((x+1)*y) */\n    fe25519_mul(xed, xed, x_plus_one);\n\n    /* yed = (x-1)/(x+1) */\n    fe25519_mul(yed, x_plus_one_y_inv, y);              /* 1/(x+1) */\n    fe25519_mul(yed, yed, x_minus_one);\n    fe25519_cmov(yed, one, fe25519_iszero(x_plus_one_y_inv));\n}", "path": "libsodium/src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c", "commit_date": "2020-10-06 00:00:00", "repo_name": "jedisct1/libsodium", "stars": 11811, "license": "other", "language": "c", "size": 8564}
{"docstring": "/*\n * Reject small order points early to mitigate the implications of\n * unexpected optimizations that would affect the ref10 code.\n * See https://eprint.iacr.org/2017/806.pdf for reference.\n */\n", "func_signal": "static int\nhas_small_order(const unsigned char s[32])", "code": "{\n    CRYPTO_ALIGN(16)\n    static const unsigned char blocklist[][32] = {\n        /* 0 (order 4) */\n        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },\n        /* 1 (order 1) */\n        { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },\n        /* 325606250916557431795983626356110631294008115727848805560023387167927233504\n           (order 8) */\n        { 0xe0, 0xeb, 0x7a, 0x7c, 0x3b, 0x41, 0xb8, 0xae, 0x16, 0x56, 0xe3,\n          0xfa, 0xf1, 0x9f, 0xc4, 0x6a, 0xda, 0x09, 0x8d, 0xeb, 0x9c, 0x32,\n          0xb1, 0xfd, 0x86, 0x62, 0x05, 0x16, 0x5f, 0x49, 0xb8, 0x00 },\n        /* 39382357235489614581723060781553021112529911719440698176882885853963445705823\n           (order 8) */\n        { 0x5f, 0x9c, 0x95, 0xbc, 0xa3, 0x50, 0x8c, 0x24, 0xb1, 0xd0, 0xb1,\n          0x55, 0x9c, 0x83, 0xef, 0x5b, 0x04, 0x44, 0x5c, 0xc4, 0x58, 0x1c,\n          0x8e, 0x86, 0xd8, 0x22, 0x4e, 0xdd, 0xd0, 0x9f, 0x11, 0x57 },\n        /* p-1 (order 2) */\n        { 0xec, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f },\n        /* p (=0, order 4) */\n        { 0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f },\n        /* p+1 (=1, order 1) */\n        { 0xee, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f }\n    };\n    unsigned char c[7] = { 0 };\n    unsigned int  k;\n    size_t        i, j;\n\n    COMPILER_ASSERT(7 == sizeof blocklist / sizeof blocklist[0]);\n    for (j = 0; j < 31; j++) {\n        for (i = 0; i < sizeof blocklist / sizeof blocklist[0]; i++) {\n            c[i] |= s[j] ^ blocklist[i][j];\n        }\n    }\n    for (i = 0; i < sizeof blocklist / sizeof blocklist[0]; i++) {\n        c[i] |= (s[j] & 0x7f) ^ blocklist[i][j];\n    }\n    k = 0;\n    for (i = 0; i < sizeof blocklist / sizeof blocklist[0]; i++) {\n        k |= (c[i] - 1);\n    }\n    return (int) ((k >> 8) & 1);\n}", "path": "libsodium/src/libsodium/crypto_scalarmult/curve25519/ref10/x25519_ref10.c", "commit_date": "2020-08-15 00:00:00", "repo_name": "jedisct1/libsodium", "stars": 11811, "license": "other", "language": "c", "size": 8564}
{"docstring": "/*\n r = p + q\n */\n", "func_signal": "static void\nge25519_add_precomp(ge25519_p1p1 *r, const ge25519_p3 *p, const ge25519_precomp *q)", "code": "{\n    fe25519 t0;\n\n    fe25519_add(r->X, p->Y, p->X);\n    fe25519_sub(r->Y, p->Y, p->X);\n    fe25519_mul(r->Z, r->X, q->yplusx);\n    fe25519_mul(r->Y, r->Y, q->yminusx);\n    fe25519_mul(r->T, q->xy2d, p->T);\n    fe25519_add(t0, p->Z, p->Z);\n    fe25519_sub(r->X, r->Z, r->Y);\n    fe25519_add(r->Y, r->Z, r->Y);\n    fe25519_add(r->Z, t0, r->T);\n    fe25519_sub(r->T, t0, r->T);\n}", "path": "libsodium/src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c", "commit_date": "2020-10-06 00:00:00", "repo_name": "jedisct1/libsodium", "stars": 11811, "license": "other", "language": "c", "size": 8564}
{"docstring": "/*\n * returns z^((p-5)/8) = z^(2^252-3)\n * used to compute square roots since we have p=5 (mod 8); see Cohen and Frey.\n */\n", "func_signal": "static void\nfe25519_pow22523(fe25519 out, const fe25519 z)", "code": "{\n    fe25519 t0, t1, t2;\n    int     i;\n\n    fe25519_sq(t0, z);\n    fe25519_sq(t1, t0);\n    fe25519_sq(t1, t1);\n    fe25519_mul(t1, z, t1);\n    fe25519_mul(t0, t0, t1);\n    fe25519_sq(t0, t0);\n    fe25519_mul(t0, t1, t0);\n    fe25519_sq(t1, t0);\n    for (i = 1; i < 5; ++i) {\n        fe25519_sq(t1, t1);\n    }\n    fe25519_mul(t0, t1, t0);\n    fe25519_sq(t1, t0);\n    for (i = 1; i < 10; ++i) {\n        fe25519_sq(t1, t1);\n    }\n    fe25519_mul(t1, t1, t0);\n    fe25519_sq(t2, t1);\n    for (i = 1; i < 20; ++i) {\n        fe25519_sq(t2, t2);\n    }\n    fe25519_mul(t1, t2, t1);\n    for (i = 1; i < 11; ++i) {\n        fe25519_sq(t1, t1);\n    }\n    fe25519_mul(t0, t1, t0);\n    fe25519_sq(t1, t0);\n    for (i = 1; i < 50; ++i) {\n        fe25519_sq(t1, t1);\n    }\n    fe25519_mul(t1, t1, t0);\n    fe25519_sq(t2, t1);\n    for (i = 1; i < 100; ++i) {\n        fe25519_sq(t2, t2);\n    }\n    fe25519_mul(t1, t2, t1);\n    for (i = 1; i < 51; ++i) {\n        fe25519_sq(t1, t1);\n    }\n    fe25519_mul(t0, t1, t0);\n    fe25519_sq(t0, t0);\n    fe25519_sq(t0, t0);\n    fe25519_mul(out, t0, z);\n}", "path": "libsodium/src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c", "commit_date": "2020-10-06 00:00:00", "repo_name": "jedisct1/libsodium", "stars": 11811, "license": "other", "language": "c", "size": 8564}
{"docstring": "/*\n Input:\n s[0]+256*s[1]+...+256^63*s[63] = s\n *\n Output:\n s[0]+256*s[1]+...+256^31*s[31] = s mod l\n where l = 2^252 + 27742317777372353535851937790883648493.\n Overwrites s in place.\n */\n", "func_signal": "void\nsc25519_reduce(unsigned char s[64])", "code": "{\n    int64_t s0  = 2097151 & load_3(s);\n    int64_t s1  = 2097151 & (load_4(s + 2) >> 5);\n    int64_t s2  = 2097151 & (load_3(s + 5) >> 2);\n    int64_t s3  = 2097151 & (load_4(s + 7) >> 7);\n    int64_t s4  = 2097151 & (load_4(s + 10) >> 4);\n    int64_t s5  = 2097151 & (load_3(s + 13) >> 1);\n    int64_t s6  = 2097151 & (load_4(s + 15) >> 6);\n    int64_t s7  = 2097151 & (load_3(s + 18) >> 3);\n    int64_t s8  = 2097151 & load_3(s + 21);\n    int64_t s9  = 2097151 & (load_4(s + 23) >> 5);\n    int64_t s10 = 2097151 & (load_3(s + 26) >> 2);\n    int64_t s11 = 2097151 & (load_4(s + 28) >> 7);\n    int64_t s12 = 2097151 & (load_4(s + 31) >> 4);\n    int64_t s13 = 2097151 & (load_3(s + 34) >> 1);\n    int64_t s14 = 2097151 & (load_4(s + 36) >> 6);\n    int64_t s15 = 2097151 & (load_3(s + 39) >> 3);\n    int64_t s16 = 2097151 & load_3(s + 42);\n    int64_t s17 = 2097151 & (load_4(s + 44) >> 5);\n    int64_t s18 = 2097151 & (load_3(s + 47) >> 2);\n    int64_t s19 = 2097151 & (load_4(s + 49) >> 7);\n    int64_t s20 = 2097151 & (load_4(s + 52) >> 4);\n    int64_t s21 = 2097151 & (load_3(s + 55) >> 1);\n    int64_t s22 = 2097151 & (load_4(s + 57) >> 6);\n    int64_t s23 = (load_4(s + 60) >> 3);\n\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n    int64_t carry10;\n    int64_t carry11;\n    int64_t carry12;\n    int64_t carry13;\n    int64_t carry14;\n    int64_t carry15;\n    int64_t carry16;\n\n    s11 += s23 * 666643;\n    s12 += s23 * 470296;\n    s13 += s23 * 654183;\n    s14 -= s23 * 997805;\n    s15 += s23 * 136657;\n    s16 -= s23 * 683901;\n\n    s10 += s22 * 666643;\n    s11 += s22 * 470296;\n    s12 += s22 * 654183;\n    s13 -= s22 * 997805;\n    s14 += s22 * 136657;\n    s15 -= s22 * 683901;\n\n    s9 += s21 * 666643;\n    s10 += s21 * 470296;\n    s11 += s21 * 654183;\n    s12 -= s21 * 997805;\n    s13 += s21 * 136657;\n    s14 -= s21 * 683901;\n\n    s8 += s20 * 666643;\n    s9 += s20 * 470296;\n    s10 += s20 * 654183;\n    s11 -= s20 * 997805;\n    s12 += s20 * 136657;\n    s13 -= s20 * 683901;\n\n    s7 += s19 * 666643;\n    s8 += s19 * 470296;\n    s9 += s19 * 654183;\n    s10 -= s19 * 997805;\n    s11 += s19 * 136657;\n    s12 -= s19 * 683901;\n\n    s6 += s18 * 666643;\n    s7 += s18 * 470296;\n    s8 += s18 * 654183;\n    s9 -= s18 * 997805;\n    s10 += s18 * 136657;\n    s11 -= s18 * 683901;\n\n    carry6 = (s6 + (int64_t) (1L << 20)) >> 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L << 21);\n    carry8 = (s8 + (int64_t) (1L << 20)) >> 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L << 21);\n    carry10 = (s10 + (int64_t) (1L << 20)) >> 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L << 21);\n    carry12 = (s12 + (int64_t) (1L << 20)) >> 21;\n    s13 += carry12;\n    s12 -= carry12 * ((uint64_t) 1L << 21);\n    carry14 = (s14 + (int64_t) (1L << 20)) >> 21;\n    s15 += carry14;\n    s14 -= carry14 * ((uint64_t) 1L << 21);\n    carry16 = (s16 + (int64_t) (1L << 20)) >> 21;\n    s17 += carry16;\n    s16 -= carry16 * ((uint64_t) 1L << 21);\n\n    carry7 = (s7 + (int64_t) (1L << 20)) >> 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L << 21);\n    carry9 = (s9 + (int64_t) (1L << 20)) >> 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L << 21);\n    carry11 = (s11 + (int64_t) (1L << 20)) >> 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L << 21);\n    carry13 = (s13 + (int64_t) (1L << 20)) >> 21;\n    s14 += carry13;\n    s13 -= carry13 * ((uint64_t) 1L << 21);\n    carry15 = (s15 + (int64_t) (1L << 20)) >> 21;\n    s16 += carry15;\n    s15 -= carry15 * ((uint64_t) 1L << 21);\n\n    s5 += s17 * 666643;\n    s6 += s17 * 470296;\n    s7 += s17 * 654183;\n    s8 -= s17 * 997805;\n    s9 += s17 * 136657;\n    s10 -= s17 * 683901;\n\n    s4 += s16 * 666643;\n    s5 += s16 * 470296;\n    s6 += s16 * 654183;\n    s7 -= s16 * 997805;\n    s8 += s16 * 136657;\n    s9 -= s16 * 683901;\n\n    s3 += s15 * 666643;\n    s4 += s15 * 470296;\n    s5 += s15 * 654183;\n    s6 -= s15 * 997805;\n    s7 += s15 * 136657;\n    s8 -= s15 * 683901;\n\n    s2 += s14 * 666643;\n    s3 += s14 * 470296;\n    s4 += s14 * 654183;\n    s5 -= s14 * 997805;\n    s6 += s14 * 136657;\n    s7 -= s14 * 683901;\n\n    s1 += s13 * 666643;\n    s2 += s13 * 470296;\n    s3 += s13 * 654183;\n    s4 -= s13 * 997805;\n    s5 += s13 * 136657;\n    s6 -= s13 * 683901;\n\n    s0 += s12 * 666643;\n    s1 += s12 * 470296;\n    s2 += s12 * 654183;\n    s3 -= s12 * 997805;\n    s4 += s12 * 136657;\n    s5 -= s12 * 683901;\n    s12 = 0;\n\n    carry0 = (s0 + (int64_t) (1L << 20)) >> 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L << 21);\n    carry2 = (s2 + (int64_t) (1L << 20)) >> 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L << 21);\n    carry4 = (s4 + (int64_t) (1L << 20)) >> 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L << 21);\n    carry6 = (s6 + (int64_t) (1L << 20)) >> 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L << 21);\n    carry8 = (s8 + (int64_t) (1L << 20)) >> 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L << 21);\n    carry10 = (s10 + (int64_t) (1L << 20)) >> 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L << 21);\n\n    carry1 = (s1 + (int64_t) (1L << 20)) >> 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L << 21);\n    carry3 = (s3 + (int64_t) (1L << 20)) >> 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L << 21);\n    carry5 = (s5 + (int64_t) (1L << 20)) >> 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L << 21);\n    carry7 = (s7 + (int64_t) (1L << 20)) >> 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L << 21);\n    carry9 = (s9 + (int64_t) (1L << 20)) >> 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L << 21);\n    carry11 = (s11 + (int64_t) (1L << 20)) >> 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L << 21);\n\n    s0 += s12 * 666643;\n    s1 += s12 * 470296;\n    s2 += s12 * 654183;\n    s3 -= s12 * 997805;\n    s4 += s12 * 136657;\n    s5 -= s12 * 683901;\n    s12 = 0;\n\n    carry0 = s0 >> 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L << 21);\n    carry1 = s1 >> 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L << 21);\n    carry2 = s2 >> 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L << 21);\n    carry3 = s3 >> 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L << 21);\n    carry4 = s4 >> 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L << 21);\n    carry5 = s5 >> 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L << 21);\n    carry6 = s6 >> 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L << 21);\n    carry7 = s7 >> 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L << 21);\n    carry8 = s8 >> 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L << 21);\n    carry9 = s9 >> 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L << 21);\n    carry10 = s10 >> 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L << 21);\n    carry11 = s11 >> 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L << 21);\n\n    s0 += s12 * 666643;\n    s1 += s12 * 470296;\n    s2 += s12 * 654183;\n    s3 -= s12 * 997805;\n    s4 += s12 * 136657;\n    s5 -= s12 * 683901;\n\n    carry0 = s0 >> 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L << 21);\n    carry1 = s1 >> 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L << 21);\n    carry2 = s2 >> 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L << 21);\n    carry3 = s3 >> 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L << 21);\n    carry4 = s4 >> 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L << 21);\n    carry5 = s5 >> 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L << 21);\n    carry6 = s6 >> 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L << 21);\n    carry7 = s7 >> 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L << 21);\n    carry8 = s8 >> 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L << 21);\n    carry9 = s9 >> 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L << 21);\n    carry10 = s10 >> 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L << 21);\n\n    s[0]  = s0 >> 0;\n    s[1]  = s0 >> 8;\n    s[2]  = (s0 >> 16) | (s1 * ((uint64_t) 1 << 5));\n    s[3]  = s1 >> 3;\n    s[4]  = s1 >> 11;\n    s[5]  = (s1 >> 19) | (s2 * ((uint64_t) 1 << 2));\n    s[6]  = s2 >> 6;\n    s[7]  = (s2 >> 14) | (s3 * ((uint64_t) 1 << 7));\n    s[8]  = s3 >> 1;\n    s[9]  = s3 >> 9;\n    s[10] = (s3 >> 17) | (s4 * ((uint64_t) 1 << 4));\n    s[11] = s4 >> 4;\n    s[12] = s4 >> 12;\n    s[13] = (s4 >> 20) | (s5 * ((uint64_t) 1 << 1));\n    s[14] = s5 >> 7;\n    s[15] = (s5 >> 15) | (s6 * ((uint64_t) 1 << 6));\n    s[16] = s6 >> 2;\n    s[17] = s6 >> 10;\n    s[18] = (s6 >> 18) | (s7 * ((uint64_t) 1 << 3));\n    s[19] = s7 >> 5;\n    s[20] = s7 >> 13;\n    s[21] = s8 >> 0;\n    s[22] = s8 >> 8;\n    s[23] = (s8 >> 16) | (s9 * ((uint64_t) 1 << 5));\n    s[24] = s9 >> 3;\n    s[25] = s9 >> 11;\n    s[26] = (s9 >> 19) | (s10 * ((uint64_t) 1 << 2));\n    s[27] = s10 >> 6;\n    s[28] = (s10 >> 14) | (s11 * ((uint64_t) 1 << 7));\n    s[29] = s11 >> 1;\n    s[30] = s11 >> 9;\n    s[31] = s11 >> 17;\n}", "path": "libsodium/src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c", "commit_date": "2020-10-06 00:00:00", "repo_name": "jedisct1/libsodium", "stars": 11811, "license": "other", "language": "c", "size": 8564}
{"docstring": "/* Ristretto group */\n", "func_signal": "static int\nristretto255_sqrt_ratio_m1(fe25519 x, const fe25519 u, const fe25519 v)", "code": "{\n    fe25519 v3;\n    fe25519 vxx;\n    fe25519 m_root_check, p_root_check, f_root_check;\n    fe25519 x_sqrtm1;\n    int     has_m_root, has_p_root, has_f_root;\n\n    fe25519_sq(v3, v);\n    fe25519_mul(v3, v3, v); /* v3 = v^3 */\n    fe25519_sq(x, v3);\n    fe25519_mul(x, x, u);\n    fe25519_mul(x, x, v); /* x = uv^7 */\n\n    fe25519_pow22523(x, x); /* x = (uv^7)^((q-5)/8) */\n    fe25519_mul(x, x, v3);\n    fe25519_mul(x, x, u); /* x = uv^3(uv^7)^((q-5)/8) */\n\n    fe25519_sq(vxx, x);\n    fe25519_mul(vxx, vxx, v); /* vx^2 */\n    fe25519_sub(m_root_check, vxx, u); /* vx^2-u */\n    fe25519_add(p_root_check, vxx, u); /* vx^2+u */\n    fe25519_mul(f_root_check, u, fe25519_sqrtm1); /* u*sqrt(-1) */\n    fe25519_add(f_root_check, vxx, f_root_check); /* vx^2+u*sqrt(-1) */\n    has_m_root = fe25519_iszero(m_root_check);\n    has_p_root = fe25519_iszero(p_root_check);\n    has_f_root = fe25519_iszero(f_root_check);\n    fe25519_mul(x_sqrtm1, x, fe25519_sqrtm1); /* x*sqrt(-1) */\n\n    fe25519_cmov(x, x_sqrtm1, has_p_root | has_f_root);\n    fe25519_abs(x, x);\n\n    return has_m_root | has_p_root;\n}", "path": "libsodium/src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c", "commit_date": "2020-10-06 00:00:00", "repo_name": "jedisct1/libsodium", "stars": 11811, "license": "other", "language": "c", "size": 8564}
{"docstring": "/*\n r = p - q\n */\n", "func_signal": "void\nge25519_sub_cached(ge25519_p1p1 *r, const ge25519_p3 *p, const ge25519_cached *q)", "code": "{\n    fe25519 t0;\n\n    fe25519_add(r->X, p->Y, p->X);\n    fe25519_sub(r->Y, p->Y, p->X);\n    fe25519_mul(r->Z, r->X, q->YminusX);\n    fe25519_mul(r->Y, r->Y, q->YplusX);\n    fe25519_mul(r->T, q->T2d, p->T);\n    fe25519_mul(r->X, p->Z, q->Z);\n    fe25519_add(t0, r->X, r->X);\n    fe25519_sub(r->X, r->Z, r->Y);\n    fe25519_add(r->Y, r->Z, r->Y);\n    fe25519_sub(r->Z, t0, r->T);\n    fe25519_add(r->T, t0, r->T);\n}", "path": "libsodium/src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c", "commit_date": "2020-10-06 00:00:00", "repo_name": "jedisct1/libsodium", "stars": 11811, "license": "other", "language": "c", "size": 8564}
{"docstring": "/*\n Input:\n s[0]+256*a[1]+...+256^31*a[31] = a\n n\n *\n Output:\n s[0]+256*s[1]+...+256^31*s[31] = x * s^(s^n) mod l\n where l = 2^252 + 27742317777372353535851937790883648493.\n Overwrites s in place.\n */\n", "func_signal": "static inline void\nsc25519_sqmul(unsigned char s[32], const int n, const unsigned char a[32])", "code": "{\n    int i;\n\n    for (i = 0; i < n; i++) {\n        sc25519_sq(s, s);\n    }\n    sc25519_mul(s, s, a);\n}", "path": "libsodium/src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c", "commit_date": "2020-10-06 00:00:00", "repo_name": "jedisct1/libsodium", "stars": 11811, "license": "other", "language": "c", "size": 8564}
{"docstring": "/* multiply by the order of the main subgroup l = 2^252+27742317777372353535851937790883648493 */\n", "func_signal": "static void\nge25519_mul_l(ge25519_p3 *r, const ge25519_p3 *p)", "code": "{\n    ge25519_p3 _10, _11, _100, _110, _1000, _1011, _10000, _100000, _100110,\n        _1000000, _1010000, _1010011, _1100011, _1100111, _1101011, _10010011,\n        _10010111, _10111101, _11010011, _11100111, _11101101, _11110101;\n\n    ge25519_p3p3_dbl(&_10, p);\n    ge25519_p3_add(&_11, p, &_10);\n    ge25519_p3_add(&_100, p, &_11);\n    ge25519_p3_add(&_110, &_10, &_100);\n    ge25519_p3_add(&_1000, &_10, &_110);\n    ge25519_p3_add(&_1011, &_11, &_1000);\n    ge25519_p3p3_dbl(&_10000, &_1000);\n    ge25519_p3p3_dbl(&_100000, &_10000);\n    ge25519_p3_add(&_100110, &_110, &_100000);\n    ge25519_p3p3_dbl(&_1000000, &_100000);\n    ge25519_p3_add(&_1010000, &_10000, &_1000000);\n    ge25519_p3_add(&_1010011, &_11, &_1010000);\n    ge25519_p3_add(&_1100011, &_10000, &_1010011);\n    ge25519_p3_add(&_1100111, &_100, &_1100011);\n    ge25519_p3_add(&_1101011, &_100, &_1100111);\n    ge25519_p3_add(&_10010011, &_1000000, &_1010011);\n    ge25519_p3_add(&_10010111, &_100, &_10010011);\n    ge25519_p3_add(&_10111101, &_100110, &_10010111);\n    ge25519_p3_add(&_11010011, &_1000000, &_10010011);\n    ge25519_p3_add(&_11100111, &_1010000, &_10010111);\n    ge25519_p3_add(&_11101101, &_110, &_11100111);\n    ge25519_p3_add(&_11110101, &_1000, &_11101101);\n\n    ge25519_p3_add(r, &_1011, &_11110101);\n    ge25519_p3_dbladd(r, 126, &_1010011);\n    ge25519_p3_dbladd(r, 9, &_10);\n    ge25519_p3_add(r, r, &_11110101);\n    ge25519_p3_dbladd(r, 7, &_1100111);\n    ge25519_p3_dbladd(r, 9, &_11110101);\n    ge25519_p3_dbladd(r, 11, &_10111101);\n    ge25519_p3_dbladd(r, 8, &_11100111);\n    ge25519_p3_dbladd(r, 9, &_1101011);\n    ge25519_p3_dbladd(r, 6, &_1011);\n    ge25519_p3_dbladd(r, 14, &_10010011);\n    ge25519_p3_dbladd(r, 10, &_1100011);\n    ge25519_p3_dbladd(r, 9, &_10010111);\n    ge25519_p3_dbladd(r, 10, &_11110101);\n    ge25519_p3_dbladd(r, 8, &_11010011);\n    ge25519_p3_dbladd(r, 8, &_11101101);\n}", "path": "libsodium/src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c", "commit_date": "2020-10-06 00:00:00", "repo_name": "jedisct1/libsodium", "stars": 11811, "license": "other", "language": "c", "size": 8564}
{"docstring": "/* multiply by the cofactor */\n", "func_signal": "static void\nge25519_clear_cofactor(ge25519_p3 *p3)", "code": "{\n    ge25519_p1p1 p1;\n    ge25519_p2   p2;\n\n    ge25519_p3_dbl(&p1, p3);\n    ge25519_p1p1_to_p2(&p2, &p1);\n    ge25519_p2_dbl(&p1, &p2);\n    ge25519_p1p1_to_p2(&p2, &p1);\n    ge25519_p2_dbl(&p1, &p2);\n    ge25519_p1p1_to_p3(p3, &p1);\n}", "path": "libsodium/src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c", "commit_date": "2020-10-06 00:00:00", "repo_name": "jedisct1/libsodium", "stars": 11811, "license": "other", "language": "c", "size": 8564}
{"docstring": "/*\n Input:\n a[0]+256*a[1]+...+256^31*a[31] = a\n b[0]+256*b[1]+...+256^31*b[31] = b\n *\n Output:\n s[0]+256*s[1]+...+256^31*s[31] = (ab) mod l\n where l = 2^252 + 27742317777372353535851937790883648493.\n */\n", "func_signal": "void\nsc25519_mul(unsigned char s[32], const unsigned char a[32], const unsigned char b[32])", "code": "{\n    int64_t a0  = 2097151 & load_3(a);\n    int64_t a1  = 2097151 & (load_4(a + 2) >> 5);\n    int64_t a2  = 2097151 & (load_3(a + 5) >> 2);\n    int64_t a3  = 2097151 & (load_4(a + 7) >> 7);\n    int64_t a4  = 2097151 & (load_4(a + 10) >> 4);\n    int64_t a5  = 2097151 & (load_3(a + 13) >> 1);\n    int64_t a6  = 2097151 & (load_4(a + 15) >> 6);\n    int64_t a7  = 2097151 & (load_3(a + 18) >> 3);\n    int64_t a8  = 2097151 & load_3(a + 21);\n    int64_t a9  = 2097151 & (load_4(a + 23) >> 5);\n    int64_t a10 = 2097151 & (load_3(a + 26) >> 2);\n    int64_t a11 = (load_4(a + 28) >> 7);\n\n    int64_t b0  = 2097151 & load_3(b);\n    int64_t b1  = 2097151 & (load_4(b + 2) >> 5);\n    int64_t b2  = 2097151 & (load_3(b + 5) >> 2);\n    int64_t b3  = 2097151 & (load_4(b + 7) >> 7);\n    int64_t b4  = 2097151 & (load_4(b + 10) >> 4);\n    int64_t b5  = 2097151 & (load_3(b + 13) >> 1);\n    int64_t b6  = 2097151 & (load_4(b + 15) >> 6);\n    int64_t b7  = 2097151 & (load_3(b + 18) >> 3);\n    int64_t b8  = 2097151 & load_3(b + 21);\n    int64_t b9  = 2097151 & (load_4(b + 23) >> 5);\n    int64_t b10 = 2097151 & (load_3(b + 26) >> 2);\n    int64_t b11 = (load_4(b + 28) >> 7);\n\n    int64_t s0;\n    int64_t s1;\n    int64_t s2;\n    int64_t s3;\n    int64_t s4;\n    int64_t s5;\n    int64_t s6;\n    int64_t s7;\n    int64_t s8;\n    int64_t s9;\n    int64_t s10;\n    int64_t s11;\n    int64_t s12;\n    int64_t s13;\n    int64_t s14;\n    int64_t s15;\n    int64_t s16;\n    int64_t s17;\n    int64_t s18;\n    int64_t s19;\n    int64_t s20;\n    int64_t s21;\n    int64_t s22;\n    int64_t s23;\n\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n    int64_t carry10;\n    int64_t carry11;\n    int64_t carry12;\n    int64_t carry13;\n    int64_t carry14;\n    int64_t carry15;\n    int64_t carry16;\n    int64_t carry17;\n    int64_t carry18;\n    int64_t carry19;\n    int64_t carry20;\n    int64_t carry21;\n    int64_t carry22;\n\n    s0 = a0 * b0;\n    s1 = a0 * b1 + a1 * b0;\n    s2 = a0 * b2 + a1 * b1 + a2 * b0;\n    s3 = a0 * b3 + a1 * b2 + a2 * b1 + a3 * b0;\n    s4 = a0 * b4 + a1 * b3 + a2 * b2 + a3 * b1 + a4 * b0;\n    s5 = a0 * b5 + a1 * b4 + a2 * b3 + a3 * b2 + a4 * b1 + a5 * b0;\n    s6 = a0 * b6 + a1 * b5 + a2 * b4 + a3 * b3 + a4 * b2 + a5 * b1 + a6 * b0;\n    s7 = a0 * b7 + a1 * b6 + a2 * b5 + a3 * b4 + a4 * b3 + a5 * b2 +\n         a6 * b1 + a7 * b0;\n    s8 = a0 * b8 + a1 * b7 + a2 * b6 + a3 * b5 + a4 * b4 + a5 * b3 +\n         a6 * b2 + a7 * b1 + a8 * b0;\n    s9 = a0 * b9 + a1 * b8 + a2 * b7 + a3 * b6 + a4 * b5 + a5 * b4 +\n         a6 * b3 + a7 * b2 + a8 * b1 + a9 * b0;\n    s10 = a0 * b10 + a1 * b9 + a2 * b8 + a3 * b7 + a4 * b6 + a5 * b5 +\n          a6 * b4 + a7 * b3 + a8 * b2 + a9 * b1 + a10 * b0;\n    s11 = a0 * b11 + a1 * b10 + a2 * b9 + a3 * b8 + a4 * b7 + a5 * b6 +\n          a6 * b5 + a7 * b4 + a8 * b3 + a9 * b2 + a10 * b1 + a11 * b0;\n    s12 = a1 * b11 + a2 * b10 + a3 * b9 + a4 * b8 + a5 * b7 + a6 * b6 +\n          a7 * b5 + a8 * b4 + a9 * b3 + a10 * b2 + a11 * b1;\n    s13 = a2 * b11 + a3 * b10 + a4 * b9 + a5 * b8 + a6 * b7 + a7 * b6 +\n          a8 * b5 + a9 * b4 + a10 * b3 + a11 * b2;\n    s14 = a3 * b11 + a4 * b10 + a5 * b9 + a6 * b8 + a7 * b7 + a8 * b6 +\n          a9 * b5 + a10 * b4 + a11 * b3;\n    s15 = a4 * b11 + a5 * b10 + a6 * b9 + a7 * b8 + a8 * b7 + a9 * b6 +\n          a10 * b5 + a11 * b4;\n    s16 =\n        a5 * b11 + a6 * b10 + a7 * b9 + a8 * b8 + a9 * b7 + a10 * b6 + a11 * b5;\n    s17 = a6 * b11 + a7 * b10 + a8 * b9 + a9 * b8 + a10 * b7 + a11 * b6;\n    s18 = a7 * b11 + a8 * b10 + a9 * b9 + a10 * b8 + a11 * b7;\n    s19 = a8 * b11 + a9 * b10 + a10 * b9 + a11 * b8;\n    s20 = a9 * b11 + a10 * b10 + a11 * b9;\n    s21 = a10 * b11 + a11 * b10;\n    s22 = a11 * b11;\n    s23 = 0;\n\n    carry0 = (s0 + (int64_t) (1L << 20)) >> 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L << 21);\n    carry2 = (s2 + (int64_t) (1L << 20)) >> 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L << 21);\n    carry4 = (s4 + (int64_t) (1L << 20)) >> 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L << 21);\n    carry6 = (s6 + (int64_t) (1L << 20)) >> 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L << 21);\n    carry8 = (s8 + (int64_t) (1L << 20)) >> 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L << 21);\n    carry10 = (s10 + (int64_t) (1L << 20)) >> 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L << 21);\n    carry12 = (s12 + (int64_t) (1L << 20)) >> 21;\n    s13 += carry12;\n    s12 -= carry12 * ((uint64_t) 1L << 21);\n    carry14 = (s14 + (int64_t) (1L << 20)) >> 21;\n    s15 += carry14;\n    s14 -= carry14 * ((uint64_t) 1L << 21);\n    carry16 = (s16 + (int64_t) (1L << 20)) >> 21;\n    s17 += carry16;\n    s16 -= carry16 * ((uint64_t) 1L << 21);\n    carry18 = (s18 + (int64_t) (1L << 20)) >> 21;\n    s19 += carry18;\n    s18 -= carry18 * ((uint64_t) 1L << 21);\n    carry20 = (s20 + (int64_t) (1L << 20)) >> 21;\n    s21 += carry20;\n    s20 -= carry20 * ((uint64_t) 1L << 21);\n    carry22 = (s22 + (int64_t) (1L << 20)) >> 21;\n    s23 += carry22;\n    s22 -= carry22 * ((uint64_t) 1L << 21);\n\n    carry1 = (s1 + (int64_t) (1L << 20)) >> 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L << 21);\n    carry3 = (s3 + (int64_t) (1L << 20)) >> 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L << 21);\n    carry5 = (s5 + (int64_t) (1L << 20)) >> 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L << 21);\n    carry7 = (s7 + (int64_t) (1L << 20)) >> 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L << 21);\n    carry9 = (s9 + (int64_t) (1L << 20)) >> 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L << 21);\n    carry11 = (s11 + (int64_t) (1L << 20)) >> 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L << 21);\n    carry13 = (s13 + (int64_t) (1L << 20)) >> 21;\n    s14 += carry13;\n    s13 -= carry13 * ((uint64_t) 1L << 21);\n    carry15 = (s15 + (int64_t) (1L << 20)) >> 21;\n    s16 += carry15;\n    s15 -= carry15 * ((uint64_t) 1L << 21);\n    carry17 = (s17 + (int64_t) (1L << 20)) >> 21;\n    s18 += carry17;\n    s17 -= carry17 * ((uint64_t) 1L << 21);\n    carry19 = (s19 + (int64_t) (1L << 20)) >> 21;\n    s20 += carry19;\n    s19 -= carry19 * ((uint64_t) 1L << 21);\n    carry21 = (s21 + (int64_t) (1L << 20)) >> 21;\n    s22 += carry21;\n    s21 -= carry21 * ((uint64_t) 1L << 21);\n\n    s11 += s23 * 666643;\n    s12 += s23 * 470296;\n    s13 += s23 * 654183;\n    s14 -= s23 * 997805;\n    s15 += s23 * 136657;\n    s16 -= s23 * 683901;\n\n    s10 += s22 * 666643;\n    s11 += s22 * 470296;\n    s12 += s22 * 654183;\n    s13 -= s22 * 997805;\n    s14 += s22 * 136657;\n    s15 -= s22 * 683901;\n\n    s9 += s21 * 666643;\n    s10 += s21 * 470296;\n    s11 += s21 * 654183;\n    s12 -= s21 * 997805;\n    s13 += s21 * 136657;\n    s14 -= s21 * 683901;\n\n    s8 += s20 * 666643;\n    s9 += s20 * 470296;\n    s10 += s20 * 654183;\n    s11 -= s20 * 997805;\n    s12 += s20 * 136657;\n    s13 -= s20 * 683901;\n\n    s7 += s19 * 666643;\n    s8 += s19 * 470296;\n    s9 += s19 * 654183;\n    s10 -= s19 * 997805;\n    s11 += s19 * 136657;\n    s12 -= s19 * 683901;\n\n    s6 += s18 * 666643;\n    s7 += s18 * 470296;\n    s8 += s18 * 654183;\n    s9 -= s18 * 997805;\n    s10 += s18 * 136657;\n    s11 -= s18 * 683901;\n\n    carry6 = (s6 + (int64_t) (1L << 20)) >> 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L << 21);\n    carry8 = (s8 + (int64_t) (1L << 20)) >> 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L << 21);\n    carry10 = (s10 + (int64_t) (1L << 20)) >> 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L << 21);\n    carry12 = (s12 + (int64_t) (1L << 20)) >> 21;\n    s13 += carry12;\n    s12 -= carry12 * ((uint64_t) 1L << 21);\n    carry14 = (s14 + (int64_t) (1L << 20)) >> 21;\n    s15 += carry14;\n    s14 -= carry14 * ((uint64_t) 1L << 21);\n    carry16 = (s16 + (int64_t) (1L << 20)) >> 21;\n    s17 += carry16;\n    s16 -= carry16 * ((uint64_t) 1L << 21);\n\n    carry7 = (s7 + (int64_t) (1L << 20)) >> 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L << 21);\n    carry9 = (s9 + (int64_t) (1L << 20)) >> 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L << 21);\n    carry11 = (s11 + (int64_t) (1L << 20)) >> 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L << 21);\n    carry13 = (s13 + (int64_t) (1L << 20)) >> 21;\n    s14 += carry13;\n    s13 -= carry13 * ((uint64_t) 1L << 21);\n    carry15 = (s15 + (int64_t) (1L << 20)) >> 21;\n    s16 += carry15;\n    s15 -= carry15 * ((uint64_t) 1L << 21);\n\n    s5 += s17 * 666643;\n    s6 += s17 * 470296;\n    s7 += s17 * 654183;\n    s8 -= s17 * 997805;\n    s9 += s17 * 136657;\n    s10 -= s17 * 683901;\n\n    s4 += s16 * 666643;\n    s5 += s16 * 470296;\n    s6 += s16 * 654183;\n    s7 -= s16 * 997805;\n    s8 += s16 * 136657;\n    s9 -= s16 * 683901;\n\n    s3 += s15 * 666643;\n    s4 += s15 * 470296;\n    s5 += s15 * 654183;\n    s6 -= s15 * 997805;\n    s7 += s15 * 136657;\n    s8 -= s15 * 683901;\n\n    s2 += s14 * 666643;\n    s3 += s14 * 470296;\n    s4 += s14 * 654183;\n    s5 -= s14 * 997805;\n    s6 += s14 * 136657;\n    s7 -= s14 * 683901;\n\n    s1 += s13 * 666643;\n    s2 += s13 * 470296;\n    s3 += s13 * 654183;\n    s4 -= s13 * 997805;\n    s5 += s13 * 136657;\n    s6 -= s13 * 683901;\n\n    s0 += s12 * 666643;\n    s1 += s12 * 470296;\n    s2 += s12 * 654183;\n    s3 -= s12 * 997805;\n    s4 += s12 * 136657;\n    s5 -= s12 * 683901;\n    s12 = 0;\n\n    carry0 = (s0 + (int64_t) (1L << 20)) >> 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L << 21);\n    carry2 = (s2 + (int64_t) (1L << 20)) >> 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L << 21);\n    carry4 = (s4 + (int64_t) (1L << 20)) >> 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L << 21);\n    carry6 = (s6 + (int64_t) (1L << 20)) >> 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L << 21);\n    carry8 = (s8 + (int64_t) (1L << 20)) >> 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L << 21);\n    carry10 = (s10 + (int64_t) (1L << 20)) >> 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L << 21);\n\n    carry1 = (s1 + (int64_t) (1L << 20)) >> 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L << 21);\n    carry3 = (s3 + (int64_t) (1L << 20)) >> 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L << 21);\n    carry5 = (s5 + (int64_t) (1L << 20)) >> 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L << 21);\n    carry7 = (s7 + (int64_t) (1L << 20)) >> 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L << 21);\n    carry9 = (s9 + (int64_t) (1L << 20)) >> 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L << 21);\n    carry11 = (s11 + (int64_t) (1L << 20)) >> 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L << 21);\n\n    s0 += s12 * 666643;\n    s1 += s12 * 470296;\n    s2 += s12 * 654183;\n    s3 -= s12 * 997805;\n    s4 += s12 * 136657;\n    s5 -= s12 * 683901;\n    s12 = 0;\n\n    carry0 = s0 >> 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L << 21);\n    carry1 = s1 >> 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L << 21);\n    carry2 = s2 >> 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L << 21);\n    carry3 = s3 >> 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L << 21);\n    carry4 = s4 >> 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L << 21);\n    carry5 = s5 >> 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L << 21);\n    carry6 = s6 >> 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L << 21);\n    carry7 = s7 >> 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L << 21);\n    carry8 = s8 >> 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L << 21);\n    carry9 = s9 >> 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L << 21);\n    carry10 = s10 >> 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L << 21);\n    carry11 = s11 >> 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L << 21);\n\n    s0 += s12 * 666643;\n    s1 += s12 * 470296;\n    s2 += s12 * 654183;\n    s3 -= s12 * 997805;\n    s4 += s12 * 136657;\n    s5 -= s12 * 683901;\n\n    carry0 = s0 >> 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L << 21);\n    carry1 = s1 >> 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L << 21);\n    carry2 = s2 >> 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L << 21);\n    carry3 = s3 >> 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L << 21);\n    carry4 = s4 >> 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L << 21);\n    carry5 = s5 >> 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L << 21);\n    carry6 = s6 >> 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L << 21);\n    carry7 = s7 >> 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L << 21);\n    carry8 = s8 >> 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L << 21);\n    carry9 = s9 >> 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L << 21);\n    carry10 = s10 >> 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L << 21);\n\n    s[0]  = s0 >> 0;\n    s[1]  = s0 >> 8;\n    s[2]  = (s0 >> 16) | (s1 * ((uint64_t) 1 << 5));\n    s[3]  = s1 >> 3;\n    s[4]  = s1 >> 11;\n    s[5]  = (s1 >> 19) | (s2 * ((uint64_t) 1 << 2));\n    s[6]  = s2 >> 6;\n    s[7]  = (s2 >> 14) | (s3 * ((uint64_t) 1 << 7));\n    s[8]  = s3 >> 1;\n    s[9]  = s3 >> 9;\n    s[10] = (s3 >> 17) | (s4 * ((uint64_t) 1 << 4));\n    s[11] = s4 >> 4;\n    s[12] = s4 >> 12;\n    s[13] = (s4 >> 20) | (s5 * ((uint64_t) 1 << 1));\n    s[14] = s5 >> 7;\n    s[15] = (s5 >> 15) | (s6 * ((uint64_t) 1 << 6));\n    s[16] = s6 >> 2;\n    s[17] = s6 >> 10;\n    s[18] = (s6 >> 18) | (s7 * ((uint64_t) 1 << 3));\n    s[19] = s7 >> 5;\n    s[20] = s7 >> 13;\n    s[21] = s8 >> 0;\n    s[22] = s8 >> 8;\n    s[23] = (s8 >> 16) | (s9 * ((uint64_t) 1 << 5));\n    s[24] = s9 >> 3;\n    s[25] = s9 >> 11;\n    s[26] = (s9 >> 19) | (s10 * ((uint64_t) 1 << 2));\n    s[27] = s10 >> 6;\n    s[28] = (s10 >> 14) | (s11 * ((uint64_t) 1 << 7));\n    s[29] = s11 >> 1;\n    s[30] = s11 >> 9;\n    s[31] = s11 >> 17;\n}", "path": "libsodium/src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c", "commit_date": "2020-10-06 00:00:00", "repo_name": "jedisct1/libsodium", "stars": 11811, "license": "other", "language": "c", "size": 8564}
{"docstring": "/*\n Input:\n a[0]+256*a[1]+...+256^31*a[31] = a\n b[0]+256*b[1]+...+256^31*b[31] = b\n c[0]+256*c[1]+...+256^31*c[31] = c\n *\n Output:\n s[0]+256*s[1]+...+256^31*s[31] = (ab+c) mod l\n where l = 2^252 + 27742317777372353535851937790883648493.\n */\n", "func_signal": "void\nsc25519_muladd(unsigned char s[32], const unsigned char a[32],\n               const unsigned char b[32], const unsigned char c[32])", "code": "{\n    int64_t a0  = 2097151 & load_3(a);\n    int64_t a1  = 2097151 & (load_4(a + 2) >> 5);\n    int64_t a2  = 2097151 & (load_3(a + 5) >> 2);\n    int64_t a3  = 2097151 & (load_4(a + 7) >> 7);\n    int64_t a4  = 2097151 & (load_4(a + 10) >> 4);\n    int64_t a5  = 2097151 & (load_3(a + 13) >> 1);\n    int64_t a6  = 2097151 & (load_4(a + 15) >> 6);\n    int64_t a7  = 2097151 & (load_3(a + 18) >> 3);\n    int64_t a8  = 2097151 & load_3(a + 21);\n    int64_t a9  = 2097151 & (load_4(a + 23) >> 5);\n    int64_t a10 = 2097151 & (load_3(a + 26) >> 2);\n    int64_t a11 = (load_4(a + 28) >> 7);\n\n    int64_t b0  = 2097151 & load_3(b);\n    int64_t b1  = 2097151 & (load_4(b + 2) >> 5);\n    int64_t b2  = 2097151 & (load_3(b + 5) >> 2);\n    int64_t b3  = 2097151 & (load_4(b + 7) >> 7);\n    int64_t b4  = 2097151 & (load_4(b + 10) >> 4);\n    int64_t b5  = 2097151 & (load_3(b + 13) >> 1);\n    int64_t b6  = 2097151 & (load_4(b + 15) >> 6);\n    int64_t b7  = 2097151 & (load_3(b + 18) >> 3);\n    int64_t b8  = 2097151 & load_3(b + 21);\n    int64_t b9  = 2097151 & (load_4(b + 23) >> 5);\n    int64_t b10 = 2097151 & (load_3(b + 26) >> 2);\n    int64_t b11 = (load_4(b + 28) >> 7);\n\n    int64_t c0  = 2097151 & load_3(c);\n    int64_t c1  = 2097151 & (load_4(c + 2) >> 5);\n    int64_t c2  = 2097151 & (load_3(c + 5) >> 2);\n    int64_t c3  = 2097151 & (load_4(c + 7) >> 7);\n    int64_t c4  = 2097151 & (load_4(c + 10) >> 4);\n    int64_t c5  = 2097151 & (load_3(c + 13) >> 1);\n    int64_t c6  = 2097151 & (load_4(c + 15) >> 6);\n    int64_t c7  = 2097151 & (load_3(c + 18) >> 3);\n    int64_t c8  = 2097151 & load_3(c + 21);\n    int64_t c9  = 2097151 & (load_4(c + 23) >> 5);\n    int64_t c10 = 2097151 & (load_3(c + 26) >> 2);\n    int64_t c11 = (load_4(c + 28) >> 7);\n\n    int64_t s0;\n    int64_t s1;\n    int64_t s2;\n    int64_t s3;\n    int64_t s4;\n    int64_t s5;\n    int64_t s6;\n    int64_t s7;\n    int64_t s8;\n    int64_t s9;\n    int64_t s10;\n    int64_t s11;\n    int64_t s12;\n    int64_t s13;\n    int64_t s14;\n    int64_t s15;\n    int64_t s16;\n    int64_t s17;\n    int64_t s18;\n    int64_t s19;\n    int64_t s20;\n    int64_t s21;\n    int64_t s22;\n    int64_t s23;\n\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n    int64_t carry10;\n    int64_t carry11;\n    int64_t carry12;\n    int64_t carry13;\n    int64_t carry14;\n    int64_t carry15;\n    int64_t carry16;\n    int64_t carry17;\n    int64_t carry18;\n    int64_t carry19;\n    int64_t carry20;\n    int64_t carry21;\n    int64_t carry22;\n\n    s0 = c0 + a0 * b0;\n    s1 = c1 + a0 * b1 + a1 * b0;\n    s2 = c2 + a0 * b2 + a1 * b1 + a2 * b0;\n    s3 = c3 + a0 * b3 + a1 * b2 + a2 * b1 + a3 * b0;\n    s4 = c4 + a0 * b4 + a1 * b3 + a2 * b2 + a3 * b1 + a4 * b0;\n    s5 = c5 + a0 * b5 + a1 * b4 + a2 * b3 + a3 * b2 + a4 * b1 + a5 * b0;\n    s6 = c6 + a0 * b6 + a1 * b5 + a2 * b4 + a3 * b3 + a4 * b2 + a5 * b1 +\n         a6 * b0;\n    s7 = c7 + a0 * b7 + a1 * b6 + a2 * b5 + a3 * b4 + a4 * b3 + a5 * b2 +\n         a6 * b1 + a7 * b0;\n    s8 = c8 + a0 * b8 + a1 * b7 + a2 * b6 + a3 * b5 + a4 * b4 + a5 * b3 +\n         a6 * b2 + a7 * b1 + a8 * b0;\n    s9 = c9 + a0 * b9 + a1 * b8 + a2 * b7 + a3 * b6 + a4 * b5 + a5 * b4 +\n         a6 * b3 + a7 * b2 + a8 * b1 + a9 * b0;\n    s10 = c10 + a0 * b10 + a1 * b9 + a2 * b8 + a3 * b7 + a4 * b6 + a5 * b5 +\n          a6 * b4 + a7 * b3 + a8 * b2 + a9 * b1 + a10 * b0;\n    s11 = c11 + a0 * b11 + a1 * b10 + a2 * b9 + a3 * b8 + a4 * b7 + a5 * b6 +\n          a6 * b5 + a7 * b4 + a8 * b3 + a9 * b2 + a10 * b1 + a11 * b0;\n    s12 = a1 * b11 + a2 * b10 + a3 * b9 + a4 * b8 + a5 * b7 + a6 * b6 +\n          a7 * b5 + a8 * b4 + a9 * b3 + a10 * b2 + a11 * b1;\n    s13 = a2 * b11 + a3 * b10 + a4 * b9 + a5 * b8 + a6 * b7 + a7 * b6 +\n          a8 * b5 + a9 * b4 + a10 * b3 + a11 * b2;\n    s14 = a3 * b11 + a4 * b10 + a5 * b9 + a6 * b8 + a7 * b7 + a8 * b6 +\n          a9 * b5 + a10 * b4 + a11 * b3;\n    s15 = a4 * b11 + a5 * b10 + a6 * b9 + a7 * b8 + a8 * b7 + a9 * b6 +\n          a10 * b5 + a11 * b4;\n    s16 =\n        a5 * b11 + a6 * b10 + a7 * b9 + a8 * b8 + a9 * b7 + a10 * b6 + a11 * b5;\n    s17 = a6 * b11 + a7 * b10 + a8 * b9 + a9 * b8 + a10 * b7 + a11 * b6;\n    s18 = a7 * b11 + a8 * b10 + a9 * b9 + a10 * b8 + a11 * b7;\n    s19 = a8 * b11 + a9 * b10 + a10 * b9 + a11 * b8;\n    s20 = a9 * b11 + a10 * b10 + a11 * b9;\n    s21 = a10 * b11 + a11 * b10;\n    s22 = a11 * b11;\n    s23 = 0;\n\n    carry0 = (s0 + (int64_t) (1L << 20)) >> 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L << 21);\n    carry2 = (s2 + (int64_t) (1L << 20)) >> 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L << 21);\n    carry4 = (s4 + (int64_t) (1L << 20)) >> 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L << 21);\n    carry6 = (s6 + (int64_t) (1L << 20)) >> 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L << 21);\n    carry8 = (s8 + (int64_t) (1L << 20)) >> 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L << 21);\n    carry10 = (s10 + (int64_t) (1L << 20)) >> 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L << 21);\n    carry12 = (s12 + (int64_t) (1L << 20)) >> 21;\n    s13 += carry12;\n    s12 -= carry12 * ((uint64_t) 1L << 21);\n    carry14 = (s14 + (int64_t) (1L << 20)) >> 21;\n    s15 += carry14;\n    s14 -= carry14 * ((uint64_t) 1L << 21);\n    carry16 = (s16 + (int64_t) (1L << 20)) >> 21;\n    s17 += carry16;\n    s16 -= carry16 * ((uint64_t) 1L << 21);\n    carry18 = (s18 + (int64_t) (1L << 20)) >> 21;\n    s19 += carry18;\n    s18 -= carry18 * ((uint64_t) 1L << 21);\n    carry20 = (s20 + (int64_t) (1L << 20)) >> 21;\n    s21 += carry20;\n    s20 -= carry20 * ((uint64_t) 1L << 21);\n    carry22 = (s22 + (int64_t) (1L << 20)) >> 21;\n    s23 += carry22;\n    s22 -= carry22 * ((uint64_t) 1L << 21);\n\n    carry1 = (s1 + (int64_t) (1L << 20)) >> 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L << 21);\n    carry3 = (s3 + (int64_t) (1L << 20)) >> 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L << 21);\n    carry5 = (s5 + (int64_t) (1L << 20)) >> 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L << 21);\n    carry7 = (s7 + (int64_t) (1L << 20)) >> 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L << 21);\n    carry9 = (s9 + (int64_t) (1L << 20)) >> 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L << 21);\n    carry11 = (s11 + (int64_t) (1L << 20)) >> 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L << 21);\n    carry13 = (s13 + (int64_t) (1L << 20)) >> 21;\n    s14 += carry13;\n    s13 -= carry13 * ((uint64_t) 1L << 21);\n    carry15 = (s15 + (int64_t) (1L << 20)) >> 21;\n    s16 += carry15;\n    s15 -= carry15 * ((uint64_t) 1L << 21);\n    carry17 = (s17 + (int64_t) (1L << 20)) >> 21;\n    s18 += carry17;\n    s17 -= carry17 * ((uint64_t) 1L << 21);\n    carry19 = (s19 + (int64_t) (1L << 20)) >> 21;\n    s20 += carry19;\n    s19 -= carry19 * ((uint64_t) 1L << 21);\n    carry21 = (s21 + (int64_t) (1L << 20)) >> 21;\n    s22 += carry21;\n    s21 -= carry21 * ((uint64_t) 1L << 21);\n\n    s11 += s23 * 666643;\n    s12 += s23 * 470296;\n    s13 += s23 * 654183;\n    s14 -= s23 * 997805;\n    s15 += s23 * 136657;\n    s16 -= s23 * 683901;\n\n    s10 += s22 * 666643;\n    s11 += s22 * 470296;\n    s12 += s22 * 654183;\n    s13 -= s22 * 997805;\n    s14 += s22 * 136657;\n    s15 -= s22 * 683901;\n\n    s9 += s21 * 666643;\n    s10 += s21 * 470296;\n    s11 += s21 * 654183;\n    s12 -= s21 * 997805;\n    s13 += s21 * 136657;\n    s14 -= s21 * 683901;\n\n    s8 += s20 * 666643;\n    s9 += s20 * 470296;\n    s10 += s20 * 654183;\n    s11 -= s20 * 997805;\n    s12 += s20 * 136657;\n    s13 -= s20 * 683901;\n\n    s7 += s19 * 666643;\n    s8 += s19 * 470296;\n    s9 += s19 * 654183;\n    s10 -= s19 * 997805;\n    s11 += s19 * 136657;\n    s12 -= s19 * 683901;\n\n    s6 += s18 * 666643;\n    s7 += s18 * 470296;\n    s8 += s18 * 654183;\n    s9 -= s18 * 997805;\n    s10 += s18 * 136657;\n    s11 -= s18 * 683901;\n\n    carry6 = (s6 + (int64_t) (1L << 20)) >> 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L << 21);\n    carry8 = (s8 + (int64_t) (1L << 20)) >> 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L << 21);\n    carry10 = (s10 + (int64_t) (1L << 20)) >> 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L << 21);\n    carry12 = (s12 + (int64_t) (1L << 20)) >> 21;\n    s13 += carry12;\n    s12 -= carry12 * ((uint64_t) 1L << 21);\n    carry14 = (s14 + (int64_t) (1L << 20)) >> 21;\n    s15 += carry14;\n    s14 -= carry14 * ((uint64_t) 1L << 21);\n    carry16 = (s16 + (int64_t) (1L << 20)) >> 21;\n    s17 += carry16;\n    s16 -= carry16 * ((uint64_t) 1L << 21);\n\n    carry7 = (s7 + (int64_t) (1L << 20)) >> 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L << 21);\n    carry9 = (s9 + (int64_t) (1L << 20)) >> 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L << 21);\n    carry11 = (s11 + (int64_t) (1L << 20)) >> 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L << 21);\n    carry13 = (s13 + (int64_t) (1L << 20)) >> 21;\n    s14 += carry13;\n    s13 -= carry13 * ((uint64_t) 1L << 21);\n    carry15 = (s15 + (int64_t) (1L << 20)) >> 21;\n    s16 += carry15;\n    s15 -= carry15 * ((uint64_t) 1L << 21);\n\n    s5 += s17 * 666643;\n    s6 += s17 * 470296;\n    s7 += s17 * 654183;\n    s8 -= s17 * 997805;\n    s9 += s17 * 136657;\n    s10 -= s17 * 683901;\n\n    s4 += s16 * 666643;\n    s5 += s16 * 470296;\n    s6 += s16 * 654183;\n    s7 -= s16 * 997805;\n    s8 += s16 * 136657;\n    s9 -= s16 * 683901;\n\n    s3 += s15 * 666643;\n    s4 += s15 * 470296;\n    s5 += s15 * 654183;\n    s6 -= s15 * 997805;\n    s7 += s15 * 136657;\n    s8 -= s15 * 683901;\n\n    s2 += s14 * 666643;\n    s3 += s14 * 470296;\n    s4 += s14 * 654183;\n    s5 -= s14 * 997805;\n    s6 += s14 * 136657;\n    s7 -= s14 * 683901;\n\n    s1 += s13 * 666643;\n    s2 += s13 * 470296;\n    s3 += s13 * 654183;\n    s4 -= s13 * 997805;\n    s5 += s13 * 136657;\n    s6 -= s13 * 683901;\n\n    s0 += s12 * 666643;\n    s1 += s12 * 470296;\n    s2 += s12 * 654183;\n    s3 -= s12 * 997805;\n    s4 += s12 * 136657;\n    s5 -= s12 * 683901;\n    s12 = 0;\n\n    carry0 = (s0 + (int64_t) (1L << 20)) >> 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L << 21);\n    carry2 = (s2 + (int64_t) (1L << 20)) >> 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L << 21);\n    carry4 = (s4 + (int64_t) (1L << 20)) >> 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L << 21);\n    carry6 = (s6 + (int64_t) (1L << 20)) >> 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L << 21);\n    carry8 = (s8 + (int64_t) (1L << 20)) >> 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L << 21);\n    carry10 = (s10 + (int64_t) (1L << 20)) >> 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L << 21);\n\n    carry1 = (s1 + (int64_t) (1L << 20)) >> 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L << 21);\n    carry3 = (s3 + (int64_t) (1L << 20)) >> 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L << 21);\n    carry5 = (s5 + (int64_t) (1L << 20)) >> 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L << 21);\n    carry7 = (s7 + (int64_t) (1L << 20)) >> 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L << 21);\n    carry9 = (s9 + (int64_t) (1L << 20)) >> 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L << 21);\n    carry11 = (s11 + (int64_t) (1L << 20)) >> 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L << 21);\n\n    s0 += s12 * 666643;\n    s1 += s12 * 470296;\n    s2 += s12 * 654183;\n    s3 -= s12 * 997805;\n    s4 += s12 * 136657;\n    s5 -= s12 * 683901;\n    s12 = 0;\n\n    carry0 = s0 >> 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L << 21);\n    carry1 = s1 >> 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L << 21);\n    carry2 = s2 >> 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L << 21);\n    carry3 = s3 >> 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L << 21);\n    carry4 = s4 >> 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L << 21);\n    carry5 = s5 >> 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L << 21);\n    carry6 = s6 >> 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L << 21);\n    carry7 = s7 >> 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L << 21);\n    carry8 = s8 >> 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L << 21);\n    carry9 = s9 >> 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L << 21);\n    carry10 = s10 >> 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L << 21);\n    carry11 = s11 >> 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L << 21);\n\n    s0 += s12 * 666643;\n    s1 += s12 * 470296;\n    s2 += s12 * 654183;\n    s3 -= s12 * 997805;\n    s4 += s12 * 136657;\n    s5 -= s12 * 683901;\n\n    carry0 = s0 >> 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L << 21);\n    carry1 = s1 >> 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L << 21);\n    carry2 = s2 >> 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L << 21);\n    carry3 = s3 >> 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L << 21);\n    carry4 = s4 >> 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L << 21);\n    carry5 = s5 >> 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L << 21);\n    carry6 = s6 >> 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L << 21);\n    carry7 = s7 >> 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L << 21);\n    carry8 = s8 >> 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L << 21);\n    carry9 = s9 >> 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L << 21);\n    carry10 = s10 >> 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L << 21);\n\n    s[0]  = s0 >> 0;\n    s[1]  = s0 >> 8;\n    s[2]  = (s0 >> 16) | (s1 * ((uint64_t) 1 << 5));\n    s[3]  = s1 >> 3;\n    s[4]  = s1 >> 11;\n    s[5]  = (s1 >> 19) | (s2 * ((uint64_t) 1 << 2));\n    s[6]  = s2 >> 6;\n    s[7]  = (s2 >> 14) | (s3 * ((uint64_t) 1 << 7));\n    s[8]  = s3 >> 1;\n    s[9]  = s3 >> 9;\n    s[10] = (s3 >> 17) | (s4 * ((uint64_t) 1 << 4));\n    s[11] = s4 >> 4;\n    s[12] = s4 >> 12;\n    s[13] = (s4 >> 20) | (s5 * ((uint64_t) 1 << 1));\n    s[14] = s5 >> 7;\n    s[15] = (s5 >> 15) | (s6 * ((uint64_t) 1 << 6));\n    s[16] = s6 >> 2;\n    s[17] = s6 >> 10;\n    s[18] = (s6 >> 18) | (s7 * ((uint64_t) 1 << 3));\n    s[19] = s7 >> 5;\n    s[20] = s7 >> 13;\n    s[21] = s8 >> 0;\n    s[22] = s8 >> 8;\n    s[23] = (s8 >> 16) | (s9 * ((uint64_t) 1 << 5));\n    s[24] = s9 >> 3;\n    s[25] = s9 >> 11;\n    s[26] = (s9 >> 19) | (s10 * ((uint64_t) 1 << 2));\n    s[27] = s10 >> 6;\n    s[28] = (s10 >> 14) | (s11 * ((uint64_t) 1 << 7));\n    s[29] = s11 >> 1;\n    s[30] = s11 >> 9;\n    s[31] = s11 >> 17;\n}", "path": "libsodium/src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c", "commit_date": "2020-10-06 00:00:00", "repo_name": "jedisct1/libsodium", "stars": 11811, "license": "other", "language": "c", "size": 8564}
{"docstring": "/* r = r*(2^n)+q */\n", "func_signal": "static void\nge25519_p3_dbladd(ge25519_p3 *r, const int n, const ge25519_p3 *q)", "code": "{\n    ge25519_p2   p2;\n    ge25519_p1p1 p1p1;\n    int          i;\n\n    ge25519_p3_to_p2(&p2, r);\n    for (i = 0; i < n; i++) {\n        ge25519_p2_dbl(&p1p1, &p2);\n        ge25519_p1p1_to_p2(&p2, &p1p1);\n    }\n    ge25519_p1p1_to_p3(r, &p1p1);\n    ge25519_p3_add(r, r, q);\n}", "path": "libsodium/src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c", "commit_date": "2020-10-06 00:00:00", "repo_name": "jedisct1/libsodium", "stars": 11811, "license": "other", "language": "c", "size": 8564}
{"docstring": "/* r = p+q */\n", "func_signal": "static void\nge25519_p3_add(ge25519_p3 *r, const ge25519_p3 *p, const ge25519_p3 *q)", "code": "{\n    ge25519_cached q_cached;\n    ge25519_p1p1   p1p1;\n\n    ge25519_p3_to_cached(&q_cached, q);\n    ge25519_add_cached(&p1p1, p, &q_cached);\n    ge25519_p1p1_to_p3(r, &p1p1);\n}", "path": "libsodium/src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c", "commit_date": "2020-10-06 00:00:00", "repo_name": "jedisct1/libsodium", "stars": 11811, "license": "other", "language": "c", "size": 8564}
{"docstring": "/*\n r = p + q\n */\n", "func_signal": "void\nge25519_add_cached(ge25519_p1p1 *r, const ge25519_p3 *p, const ge25519_cached *q)", "code": "{\n    fe25519 t0;\n\n    fe25519_add(r->X, p->Y, p->X);\n    fe25519_sub(r->Y, p->Y, p->X);\n    fe25519_mul(r->Z, r->X, q->YplusX);\n    fe25519_mul(r->Y, r->Y, q->YminusX);\n    fe25519_mul(r->T, q->T2d, p->T);\n    fe25519_mul(r->X, p->Z, q->Z);\n    fe25519_add(t0, r->X, r->X);\n    fe25519_sub(r->X, r->Z, r->Y);\n    fe25519_add(r->Y, r->Z, r->Y);\n    fe25519_add(r->Z, t0, r->T);\n    fe25519_sub(r->T, t0, r->T);\n}", "path": "libsodium/src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c", "commit_date": "2020-10-06 00:00:00", "repo_name": "jedisct1/libsodium", "stars": 11811, "license": "other", "language": "c", "size": 8564}
{"docstring": "/*\n r = a * A + b * B\n where a = a[0]+256*a[1]+...+256^31 a[31].\n and b = b[0]+256*b[1]+...+256^31 b[31].\n B is the Ed25519 base point (x,4/5) with x positive.\n\n Only used for signatures verification.\n */\n", "func_signal": "void\nge25519_double_scalarmult_vartime(ge25519_p2 *r, const unsigned char *a,\n                                  const ge25519_p3 *A, const unsigned char *b)", "code": "{\n    static const ge25519_precomp Bi[8] = {\n#ifdef HAVE_TI_MODE\n# include \"fe_51/base2.h\"\n#else\n# include \"fe_25_5/base2.h\"\n#endif\n    };\n    signed char    aslide[256];\n    signed char    bslide[256];\n    ge25519_cached Ai[8]; /* A,3A,5A,7A,9A,11A,13A,15A */\n    ge25519_p1p1   t;\n    ge25519_p3     u;\n    ge25519_p3     A2;\n    int            i;\n\n    slide_vartime(aslide, a);\n    slide_vartime(bslide, b);\n\n    ge25519_p3_to_cached(&Ai[0], A);\n\n    ge25519_p3_dbl(&t, A);\n    ge25519_p1p1_to_p3(&A2, &t);\n\n    ge25519_add_cached(&t, &A2, &Ai[0]);\n    ge25519_p1p1_to_p3(&u, &t);\n    ge25519_p3_to_cached(&Ai[1], &u);\n\n    ge25519_add_cached(&t, &A2, &Ai[1]);\n    ge25519_p1p1_to_p3(&u, &t);\n    ge25519_p3_to_cached(&Ai[2], &u);\n\n    ge25519_add_cached(&t, &A2, &Ai[2]);\n    ge25519_p1p1_to_p3(&u, &t);\n    ge25519_p3_to_cached(&Ai[3], &u);\n\n    ge25519_add_cached(&t, &A2, &Ai[3]);\n    ge25519_p1p1_to_p3(&u, &t);\n    ge25519_p3_to_cached(&Ai[4], &u);\n\n    ge25519_add_cached(&t, &A2, &Ai[4]);\n    ge25519_p1p1_to_p3(&u, &t);\n    ge25519_p3_to_cached(&Ai[5], &u);\n\n    ge25519_add_cached(&t, &A2, &Ai[5]);\n    ge25519_p1p1_to_p3(&u, &t);\n    ge25519_p3_to_cached(&Ai[6], &u);\n\n    ge25519_add_cached(&t, &A2, &Ai[6]);\n    ge25519_p1p1_to_p3(&u, &t);\n    ge25519_p3_to_cached(&Ai[7], &u);\n\n    ge25519_p2_0(r);\n\n    for (i = 255; i >= 0; --i) {\n        if (aslide[i] || bslide[i]) {\n            break;\n        }\n    }\n\n    for (; i >= 0; --i) {\n        ge25519_p2_dbl(&t, r);\n\n        if (aslide[i] > 0) {\n            ge25519_p1p1_to_p3(&u, &t);\n            ge25519_add_cached(&t, &u, &Ai[aslide[i] / 2]);\n        } else if (aslide[i] < 0) {\n            ge25519_p1p1_to_p3(&u, &t);\n            ge25519_sub_cached(&t, &u, &Ai[(-aslide[i]) / 2]);\n        }\n\n        if (bslide[i] > 0) {\n            ge25519_p1p1_to_p3(&u, &t);\n            ge25519_add_precomp(&t, &u, &Bi[bslide[i] / 2]);\n        } else if (bslide[i] < 0) {\n            ge25519_p1p1_to_p3(&u, &t);\n            ge25519_sub_precomp(&t, &u, &Bi[(-bslide[i]) / 2]);\n        }\n\n        ge25519_p1p1_to_p2(r, &t);\n    }\n}", "path": "libsodium/src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c", "commit_date": "2020-10-06 00:00:00", "repo_name": "jedisct1/libsodium", "stars": 11811, "license": "other", "language": "c", "size": 8564}
{"docstring": "/*\n r = p - q\n */\n", "func_signal": "static void\nge25519_sub_precomp(ge25519_p1p1 *r, const ge25519_p3 *p, const ge25519_precomp *q)", "code": "{\n    fe25519 t0;\n\n    fe25519_add(r->X, p->Y, p->X);\n    fe25519_sub(r->Y, p->Y, p->X);\n    fe25519_mul(r->Z, r->X, q->yminusx);\n    fe25519_mul(r->Y, r->Y, q->yplusx);\n    fe25519_mul(r->T, q->xy2d, p->T);\n    fe25519_add(t0, p->Z, p->Z);\n    fe25519_sub(r->X, r->Z, r->Y);\n    fe25519_add(r->Y, r->Z, r->Y);\n    fe25519_sub(r->Z, t0, r->T);\n    fe25519_add(r->T, t0, r->T);\n}", "path": "libsodium/src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c", "commit_date": "2020-10-06 00:00:00", "repo_name": "jedisct1/libsodium", "stars": 11811, "license": "other", "language": "c", "size": 8564}
{"docstring": "/* montgomery -- recover y = sqrt(x^3 + A*x^2 + x) */\n", "func_signal": "static int\nge25519_xmont_to_ymont(fe25519 y, const fe25519 x)", "code": "{\n    fe25519 x2;\n    fe25519 x3;\n\n    fe25519_sq(x2, x);\n    fe25519_mul(x3, x, x2);\n    fe25519_mul32(x2, x2, ed25519_A_32);\n    fe25519_add(y, x3, x);\n    fe25519_add(y, y, x2);\n\n    return fe25519_sqrt(y, y);\n}", "path": "libsodium/src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c", "commit_date": "2020-10-06 00:00:00", "repo_name": "jedisct1/libsodium", "stars": 11811, "license": "other", "language": "c", "size": 8564}
{"docstring": "/*\n * SET CLIENT_ENCODING\n */\n", "func_signal": "bool\ncheck_client_encoding(char **newval, void **extra, GucSource source)", "code": "{\n\tint\t\t\tencoding;\n\tconst char *canonical_name;\n\n\t/* Look up the encoding by name */\n\tencoding = pg_valid_client_encoding(*newval);\n\tif (encoding < 0)\n\t\treturn false;\n\n\t/* Get the canonical name (no aliases, uniform case) */\n\tcanonical_name = pg_encoding_to_char(encoding);\n\n\t/*\n\t * If we are not within a transaction then PrepareClientEncoding will not\n\t * be able to look up the necessary conversion procs.  If we are still\n\t * starting up, it will return \"OK\" anyway, and InitializeClientEncoding\n\t * will fix things once initialization is far enough along.  After\n\t * startup, we'll fail.  This would only happen if someone tries to change\n\t * client_encoding in postgresql.conf and then SIGHUP existing sessions.\n\t * It seems like a bad idea for client_encoding to change that way anyhow,\n\t * so we don't go out of our way to support it.\n\t *\n\t * Note: in the postmaster, or any other process that never calls\n\t * InitializeClientEncoding, PrepareClientEncoding will always succeed,\n\t * and so will SetClientEncoding; but they won't do anything, which is OK.\n\t */\n\tif (PrepareClientEncoding(encoding) < 0)\n\t{\n\t\tif (IsTransactionState())\n\t\t{\n\t\t\t/* Must be a genuine no-such-conversion problem */\n\t\t\tGUC_check_errcode(ERRCODE_FEATURE_NOT_SUPPORTED);\n\t\t\tGUC_check_errdetail(\"Conversion between %s and %s is not supported.\",\n\t\t\t\t\t\t\t\tcanonical_name,\n\t\t\t\t\t\t\t\tGetDatabaseEncodingName());\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Provide a useful complaint */\n\t\t\tGUC_check_errdetail(\"Cannot change \\\"client_encoding\\\" now.\");\n\t\t}\n\t\treturn false;\n\t}\n\n\t/*\n\t * Replace the user-supplied string with the encoding's canonical name.\n\t * This gets rid of aliases and case-folding variations.\n\t *\n\t * XXX Although canonicalizing seems like a good idea in the abstract, it\n\t * breaks pre-9.1 JDBC drivers, which expect that if they send \"UNICODE\"\n\t * as the client_encoding setting then it will read back the same way. As\n\t * a workaround, don't replace the string if it's \"UNICODE\".  Remove that\n\t * hack when pre-9.1 JDBC drivers are no longer in use.\n\t */\n\tif (strcmp(*newval, canonical_name) != 0 &&\n\t\tstrcmp(*newval, \"UNICODE\") != 0)\n\t{\n\t\tfree(*newval);\n\t\t*newval = strdup(canonical_name);\n\t\tif (!*newval)\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * Save the encoding's ID in *extra, for use by assign_client_encoding.\n\t */\n\t*extra = malloc(sizeof(int));\n\tif (!*extra)\n\t\treturn false;\n\t*((int *) *extra) = encoding;\n\n\treturn true;\n}", "path": "yugabyte-db/src/postgres/src/backend/commands/variable.c", "commit_date": "2020-10-10 00:00:00", "repo_name": "yugabyte/yugabyte-db", "stars": 8389, "license": "other", "language": "c", "size": 660299}
{"docstring": "/*\n * Compute the hash value for a tuple\n *\n * The passed-in key is a pointer to TupleHashEntryData.  In an actual hash\n * table entry, the firstTuple field points to a tuple (in MinimalTuple\n * format).  LookupTupleHashEntry sets up a dummy TupleHashEntryData with a\n * NULL firstTuple field --- that cues us to look at the inputslot instead.\n * This convention avoids the need to materialize virtual input tuples unless\n * they actually need to get copied into the table.\n *\n * Also, the caller must select an appropriate memory context for running\n * the hash functions. (dynahash.c doesn't change GetCurrentMemoryContext().)\n */\n", "func_signal": "static uint32\nTupleHashTableHash(struct tuplehash_hash *tb, const MinimalTuple tuple)", "code": "{\n\tTupleHashTable hashtable = (TupleHashTable) tb->private_data;\n\tint\t\t\tnumCols = hashtable->numCols;\n\tAttrNumber *keyColIdx = hashtable->keyColIdx;\n\tuint32\t\thashkey = hashtable->hash_iv;\n\tTupleTableSlot *slot;\n\tFmgrInfo   *hashfunctions;\n\tint\t\t\ti;\n\n\tif (tuple == NULL)\n\t{\n\t\t/* Process the current input tuple for the table */\n\t\tslot = hashtable->inputslot;\n\t\thashfunctions = hashtable->in_hash_funcs;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Process a tuple already stored in the table.\n\t\t *\n\t\t * (this case never actually occurs due to the way simplehash.h is\n\t\t * used, as the hash-value is stored in the entries)\n\t\t */\n\t\tslot = hashtable->tableslot;\n\t\tExecStoreMinimalTuple(tuple, slot, false);\n\t\thashfunctions = hashtable->tab_hash_funcs;\n\t}\n\n\tfor (i = 0; i < numCols; i++)\n\t{\n\t\tAttrNumber\tatt = keyColIdx[i];\n\t\tDatum\t\tattr;\n\t\tbool\t\tisNull;\n\n\t\t/* rotate hashkey left 1 bit at each step */\n\t\thashkey = (hashkey << 1) | ((hashkey & 0x80000000) ? 1 : 0);\n\n\t\tattr = slot_getattr(slot, att, &isNull);\n\n\t\tif (!isNull)\t\t\t/* treat nulls as having hash key 0 */\n\t\t{\n\t\t\tuint32\t\thkey;\n\n\t\t\thkey = DatumGetUInt32(FunctionCall1(&hashfunctions[i],\n\t\t\t\t\t\t\t\t\t\t\t\tattr));\n\t\t\thashkey ^= hkey;\n\t\t}\n\t}\n\n\t/*\n\t * The way hashes are combined above, among each other and with the IV,\n\t * doesn't lead to good bit perturbation. As the IV's goal is to lead to\n\t * achieve that, perform a round of hashing of the combined hash -\n\t * resulting in near perfect perturbation.\n\t */\n\treturn murmurhash32(hashkey);\n}", "path": "yugabyte-db/src/postgres/src/backend/executor/execGrouping.c", "commit_date": "2020-02-28 00:00:00", "repo_name": "yugabyte/yugabyte-db", "stars": 8389, "license": "other", "language": "c", "size": 660299}
{"docstring": "/*\n * Random number seed\n *\n * We can't roll back the random sequence on error, and we don't want\n * config file reloads to affect it, so we only want interactive SET SEED\n * commands to set it.  We use the \"extra\" storage to ensure that rollbacks\n * don't try to do the operation again.\n */\n", "func_signal": "bool\ncheck_random_seed(double *newval, void **extra, GucSource source)", "code": "{\n\t*extra = malloc(sizeof(int));\n\tif (!*extra)\n\t\treturn false;\n\t/* Arm the assign only if source of value is an interactive SET */\n\t*((int *) *extra) = (source >= PGC_S_INTERACTIVE);\n\n\treturn true;\n}", "path": "yugabyte-db/src/postgres/src/backend/commands/variable.c", "commit_date": "2020-10-10 00:00:00", "repo_name": "yugabyte/yugabyte-db", "stars": 8389, "license": "other", "language": "c", "size": 660299}
{"docstring": "/*\n * check_datestyle: GUC check_hook for datestyle\n */\n", "func_signal": "bool\ncheck_datestyle(char **newval, void **extra, GucSource source)", "code": "{\n\tint\t\t\tnewDateStyle = DateStyle;\n\tint\t\t\tnewDateOrder = DateOrder;\n\tbool\t\thave_style = false;\n\tbool\t\thave_order = false;\n\tbool\t\tok = true;\n\tchar\t   *rawstring;\n\tint\t\t   *myextra;\n\tchar\t   *result;\n\tList\t   *elemlist;\n\tListCell   *l;\n\n\t/* Need a modifiable copy of string */\n\trawstring = pstrdup(*newval);\n\n\t/* Parse string into list of identifiers */\n\tif (!SplitIdentifierString(rawstring, ',', &elemlist))\n\t{\n\t\t/* syntax error in list */\n\t\tGUC_check_errdetail(\"List syntax is invalid.\");\n\t\tpfree(rawstring);\n\t\tlist_free(elemlist);\n\t\treturn false;\n\t}\n\n\tforeach(l, elemlist)\n\t{\n\t\tchar\t   *tok = (char *) lfirst(l);\n\n\t\t/* Ugh. Somebody ought to write a table driven version -- mjl */\n\n\t\tif (pg_strcasecmp(tok, \"ISO\") == 0)\n\t\t{\n\t\t\tif (have_style && newDateStyle != USE_ISO_DATES)\n\t\t\t\tok = false;\t\t/* conflicting styles */\n\t\t\tnewDateStyle = USE_ISO_DATES;\n\t\t\thave_style = true;\n\t\t}\n\t\telse if (pg_strcasecmp(tok, \"SQL\") == 0)\n\t\t{\n\t\t\tif (have_style && newDateStyle != USE_SQL_DATES)\n\t\t\t\tok = false;\t\t/* conflicting styles */\n\t\t\tnewDateStyle = USE_SQL_DATES;\n\t\t\thave_style = true;\n\t\t}\n\t\telse if (pg_strncasecmp(tok, \"POSTGRES\", 8) == 0)\n\t\t{\n\t\t\tif (have_style && newDateStyle != USE_POSTGRES_DATES)\n\t\t\t\tok = false;\t\t/* conflicting styles */\n\t\t\tnewDateStyle = USE_POSTGRES_DATES;\n\t\t\thave_style = true;\n\t\t}\n\t\telse if (pg_strcasecmp(tok, \"GERMAN\") == 0)\n\t\t{\n\t\t\tif (have_style && newDateStyle != USE_GERMAN_DATES)\n\t\t\t\tok = false;\t\t/* conflicting styles */\n\t\t\tnewDateStyle = USE_GERMAN_DATES;\n\t\t\thave_style = true;\n\t\t\t/* GERMAN also sets DMY, unless explicitly overridden */\n\t\t\tif (!have_order)\n\t\t\t\tnewDateOrder = DATEORDER_DMY;\n\t\t}\n\t\telse if (pg_strcasecmp(tok, \"YMD\") == 0)\n\t\t{\n\t\t\tif (have_order && newDateOrder != DATEORDER_YMD)\n\t\t\t\tok = false;\t\t/* conflicting orders */\n\t\t\tnewDateOrder = DATEORDER_YMD;\n\t\t\thave_order = true;\n\t\t}\n\t\telse if (pg_strcasecmp(tok, \"DMY\") == 0 ||\n\t\t\t\t pg_strncasecmp(tok, \"EURO\", 4) == 0)\n\t\t{\n\t\t\tif (have_order && newDateOrder != DATEORDER_DMY)\n\t\t\t\tok = false;\t\t/* conflicting orders */\n\t\t\tnewDateOrder = DATEORDER_DMY;\n\t\t\thave_order = true;\n\t\t}\n\t\telse if (pg_strcasecmp(tok, \"MDY\") == 0 ||\n\t\t\t\t pg_strcasecmp(tok, \"US\") == 0 ||\n\t\t\t\t pg_strncasecmp(tok, \"NONEURO\", 7) == 0)\n\t\t{\n\t\t\tif (have_order && newDateOrder != DATEORDER_MDY)\n\t\t\t\tok = false;\t\t/* conflicting orders */\n\t\t\tnewDateOrder = DATEORDER_MDY;\n\t\t\thave_order = true;\n\t\t}\n\t\telse if (pg_strcasecmp(tok, \"DEFAULT\") == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Easiest way to get the current DEFAULT state is to fetch the\n\t\t\t * DEFAULT string from guc.c and recursively parse it.\n\t\t\t *\n\t\t\t * We can't simply \"return check_datestyle(...)\" because we need\n\t\t\t * to handle constructs like \"DEFAULT, ISO\".\n\t\t\t */\n\t\t\tchar\t   *subval;\n\t\t\tvoid\t   *subextra = NULL;\n\n\t\t\tsubval = strdup(GetConfigOptionResetString(\"datestyle\"));\n\t\t\tif (!subval)\n\t\t\t{\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!check_datestyle(&subval, &subextra, source))\n\t\t\t{\n\t\t\t\tfree(subval);\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmyextra = (int *) subextra;\n\t\t\tif (!have_style)\n\t\t\t\tnewDateStyle = myextra[0];\n\t\t\tif (!have_order)\n\t\t\t\tnewDateOrder = myextra[1];\n\t\t\tfree(subval);\n\t\t\tfree(subextra);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tGUC_check_errdetail(\"Unrecognized key word: \\\"%s\\\".\", tok);\n\t\t\tpfree(rawstring);\n\t\t\tlist_free(elemlist);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpfree(rawstring);\n\tlist_free(elemlist);\n\n\tif (!ok)\n\t{\n\t\tGUC_check_errdetail(\"Conflicting \\\"datestyle\\\" specifications.\");\n\t\treturn false;\n\t}\n\n\t/*\n\t * Prepare the canonical string to return.  GUC wants it malloc'd.\n\t */\n\tresult = (char *) malloc(32);\n\tif (!result)\n\t\treturn false;\n\n\tswitch (newDateStyle)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\t\tstrcpy(result, \"ISO\");\n\t\t\tbreak;\n\t\tcase USE_SQL_DATES:\n\t\t\tstrcpy(result, \"SQL\");\n\t\t\tbreak;\n\t\tcase USE_GERMAN_DATES:\n\t\t\tstrcpy(result, \"German\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(result, \"Postgres\");\n\t\t\tbreak;\n\t}\n\tswitch (newDateOrder)\n\t{\n\t\tcase DATEORDER_YMD:\n\t\t\tstrcat(result, \", YMD\");\n\t\t\tbreak;\n\t\tcase DATEORDER_DMY:\n\t\t\tstrcat(result, \", DMY\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcat(result, \", MDY\");\n\t\t\tbreak;\n\t}\n\n\tfree(*newval);\n\t*newval = result;\n\n\t/*\n\t * Set up the \"extra\" struct actually used by assign_datestyle.\n\t */\n\tmyextra = (int *) malloc(2 * sizeof(int));\n\tif (!myextra)\n\t\treturn false;\n\tmyextra[0] = newDateStyle;\n\tmyextra[1] = newDateOrder;\n\t*extra = (void *) myextra;\n\n\treturn true;\n}", "path": "yugabyte-db/src/postgres/src/backend/commands/variable.c", "commit_date": "2020-10-10 00:00:00", "repo_name": "yugabyte/yugabyte-db", "stars": 8389, "license": "other", "language": "c", "size": 660299}
{"docstring": "/*\n * ExecHashJoinOuterGetTuple variant for the parallel case.\n */\n", "func_signal": "static TupleTableSlot *\nExecParallelHashJoinOuterGetTuple(PlanState *outerNode,\n\t\t\t\t\t\t\t\t  HashJoinState *hjstate,\n\t\t\t\t\t\t\t\t  uint32 *hashvalue)", "code": "{\n\tHashJoinTable hashtable = hjstate->hj_HashTable;\n\tint\t\t\tcurbatch = hashtable->curbatch;\n\tTupleTableSlot *slot;\n\n\t/*\n\t * In the Parallel Hash case we only run the outer plan directly for\n\t * single-batch hash joins.  Otherwise we have to go to batch files, even\n\t * for batch 0.\n\t */\n\tif (curbatch == 0 && hashtable->nbatch == 1)\n\t{\n\t\tslot = ExecProcNode(outerNode);\n\n\t\twhile (!TupIsNull(slot))\n\t\t{\n\t\t\tExprContext *econtext = hjstate->js.ps.ps_ExprContext;\n\n\t\t\tecontext->ecxt_outertuple = slot;\n\t\t\tif (ExecHashGetHashValue(hashtable, econtext,\n\t\t\t\t\t\t\t\t\t hjstate->hj_OuterHashKeys,\n\t\t\t\t\t\t\t\t\t true,\t/* outer tuple */\n\t\t\t\t\t\t\t\t\t HJ_FILL_OUTER(hjstate),\n\t\t\t\t\t\t\t\t\t hashvalue))\n\t\t\t\treturn slot;\n\n\t\t\t/*\n\t\t\t * That tuple couldn't match because of a NULL, so discard it and\n\t\t\t * continue with the next one.\n\t\t\t */\n\t\t\tslot = ExecProcNode(outerNode);\n\t\t}\n\t}\n\telse if (curbatch < hashtable->nbatch)\n\t{\n\t\tMinimalTuple tuple;\n\n\t\ttuple = sts_parallel_scan_next(hashtable->batches[curbatch].outer_tuples,\n\t\t\t\t\t\t\t\t\t   hashvalue);\n\t\tif (tuple != NULL)\n\t\t{\n\t\t\tslot = ExecStoreMinimalTuple(tuple,\n\t\t\t\t\t\t\t\t\t\t hjstate->hj_OuterTupleSlot,\n\t\t\t\t\t\t\t\t\t\t false);\n\t\t\treturn slot;\n\t\t}\n\t\telse\n\t\t\tExecClearTuple(hjstate->hj_OuterTupleSlot);\n\t}\n\n\t/* End of this batch */\n\treturn NULL;\n}", "path": "yugabyte-db/src/postgres/src/backend/executor/nodeHashjoin.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "yugabyte/yugabyte-db", "stars": 8389, "license": "other", "language": "c", "size": 660299}
{"docstring": "/* ----------------------------------------------------------------\n *\t\tExecEndHashJoin\n *\n *\t\tclean up routine for HashJoin node\n * ----------------------------------------------------------------\n */\n", "func_signal": "void\nExecEndHashJoin(HashJoinState *node)", "code": "{\n\t/*\n\t * Free hash table\n\t */\n\tif (node->hj_HashTable)\n\t{\n\t\tExecHashTableDestroy(node->hj_HashTable);\n\t\tnode->hj_HashTable = NULL;\n\t}\n\n\t/*\n\t * Free the exprcontext\n\t */\n\tExecFreeExprContext(&node->js.ps);\n\n\t/*\n\t * clean out the tuple table\n\t */\n\tExecClearTuple(node->js.ps.ps_ResultTupleSlot);\n\tExecClearTuple(node->hj_OuterTupleSlot);\n\tExecClearTuple(node->hj_HashTupleSlot);\n\n\t/*\n\t * clean up subtrees\n\t */\n\tExecEndNode(outerPlanState(node));\n\tExecEndNode(innerPlanState(node));\n}", "path": "yugabyte-db/src/postgres/src/backend/executor/nodeHashjoin.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "yugabyte/yugabyte-db", "stars": 8389, "license": "other", "language": "c", "size": 660299}
{"docstring": "/*\n * ExecHashJoinSaveTuple\n *\t\tsave a tuple to a batch file.\n *\n * The data recorded in the file for each tuple is its hash value,\n * then the tuple in MinimalTuple format.\n *\n * Note: it is important always to call this in the regular executor\n * context, not in a shorter-lived context; else the temp file buffers\n * will get messed up.\n */\n", "func_signal": "void\nExecHashJoinSaveTuple(MinimalTuple tuple, uint32 hashvalue,\n\t\t\t\t\t  BufFile **fileptr)", "code": "{\n\tBufFile    *file = *fileptr;\n\tsize_t\t\twritten;\n\n\tif (file == NULL)\n\t{\n\t\t/* First write to this batch file, so open it. */\n\t\tfile = BufFileCreateTemp(false);\n\t\t*fileptr = file;\n\t}\n\n\twritten = BufFileWrite(file, (void *) &hashvalue, sizeof(uint32));\n\tif (written != sizeof(uint32))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to hash-join temporary file: %m\")));\n\n\twritten = BufFileWrite(file, (void *) tuple, tuple->t_len);\n\tif (written != tuple->t_len)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to hash-join temporary file: %m\")));\n}", "path": "yugabyte-db/src/postgres/src/backend/executor/nodeHashjoin.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "yugabyte/yugabyte-db", "stars": 8389, "license": "other", "language": "c", "size": 660299}
{"docstring": "/* ----------------------------------------------------------------\n *\t\tExecHashJoinImpl\n *\n *\t\tThis function implements the Hybrid Hashjoin algorithm.  It is marked\n *\t\twith an always-inline attribute so that ExecHashJoin() and\n *\t\tExecParallelHashJoin() can inline it.  Compilers that respect the\n *\t\tattribute should create versions specialized for parallel == true and\n *\t\tparallel == false with unnecessary branches removed.\n *\n *\t\tNote: the relation we build hash table on is the \"inner\"\n *\t\t\t  the other one is \"outer\".\n * ----------------------------------------------------------------\n */\n", "func_signal": "static pg_attribute_always_inline TupleTableSlot *\nExecHashJoinImpl(PlanState *pstate, bool parallel)", "code": "{\n\tHashJoinState *node = castNode(HashJoinState, pstate);\n\tPlanState  *outerNode;\n\tHashState  *hashNode;\n\tExprState  *joinqual;\n\tExprState  *otherqual;\n\tExprContext *econtext;\n\tHashJoinTable hashtable;\n\tTupleTableSlot *outerTupleSlot;\n\tuint32\t\thashvalue;\n\tint\t\t\tbatchno;\n\tParallelHashJoinState *parallel_state;\n\n\t/*\n\t * get information from HashJoin node\n\t */\n\tjoinqual = node->js.joinqual;\n\totherqual = node->js.ps.qual;\n\thashNode = (HashState *) innerPlanState(node);\n\touterNode = outerPlanState(node);\n\thashtable = node->hj_HashTable;\n\tecontext = node->js.ps.ps_ExprContext;\n\tparallel_state = hashNode->parallel_state;\n\n\t/*\n\t * Reset per-tuple memory context to free any expression evaluation\n\t * storage allocated in the previous tuple cycle.\n\t */\n\tResetExprContext(econtext);\n\n\t/*\n\t * run the hash join state machine\n\t */\n\tfor (;;)\n\t{\n\t\t/*\n\t\t * It's possible to iterate this loop many times before returning a\n\t\t * tuple, in some pathological cases such as needing to move much of\n\t\t * the current batch to a later batch.  So let's check for interrupts\n\t\t * each time through.\n\t\t */\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tswitch (node->hj_JoinState)\n\t\t{\n\t\t\tcase HJ_BUILD_HASHTABLE:\n\n\t\t\t\t/*\n\t\t\t\t * First time through: build hash table for inner relation.\n\t\t\t\t */\n\t\t\t\tAssert(hashtable == NULL);\n\n\t\t\t\t/*\n\t\t\t\t * If the outer relation is completely empty, and it's not\n\t\t\t\t * right/full join, we can quit without building the hash\n\t\t\t\t * table.  However, for an inner join it is only a win to\n\t\t\t\t * check this when the outer relation's startup cost is less\n\t\t\t\t * than the projected cost of building the hash table.\n\t\t\t\t * Otherwise it's best to build the hash table first and see\n\t\t\t\t * if the inner relation is empty.  (When it's a left join, we\n\t\t\t\t * should always make this check, since we aren't going to be\n\t\t\t\t * able to skip the join on the strength of an empty inner\n\t\t\t\t * relation anyway.)\n\t\t\t\t *\n\t\t\t\t * If we are rescanning the join, we make use of information\n\t\t\t\t * gained on the previous scan: don't bother to try the\n\t\t\t\t * prefetch if the previous scan found the outer relation\n\t\t\t\t * nonempty. This is not 100% reliable since with new\n\t\t\t\t * parameters the outer relation might yield different\n\t\t\t\t * results, but it's a good heuristic.\n\t\t\t\t *\n\t\t\t\t * The only way to make the check is to try to fetch a tuple\n\t\t\t\t * from the outer plan node.  If we succeed, we have to stash\n\t\t\t\t * it away for later consumption by ExecHashJoinOuterGetTuple.\n\t\t\t\t */\n\t\t\t\tif (HJ_FILL_INNER(node))\n\t\t\t\t{\n\t\t\t\t\t/* no chance to not build the hash table */\n\t\t\t\t\tnode->hj_FirstOuterTupleSlot = NULL;\n\t\t\t\t}\n\t\t\t\telse if (parallel)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * The empty-outer optimization is not implemented for\n\t\t\t\t\t * shared hash tables, because no one participant can\n\t\t\t\t\t * determine that there are no outer tuples, and it's not\n\t\t\t\t\t * yet clear that it's worth the synchronization overhead\n\t\t\t\t\t * of reaching consensus to figure that out.  So we have\n\t\t\t\t\t * to build the hash table.\n\t\t\t\t\t */\n\t\t\t\t\tnode->hj_FirstOuterTupleSlot = NULL;\n\t\t\t\t}\n\t\t\t\telse if (HJ_FILL_OUTER(node) ||\n\t\t\t\t\t\t (outerNode->plan->startup_cost < hashNode->ps.plan->total_cost &&\n\t\t\t\t\t\t  !node->hj_OuterNotEmpty))\n\t\t\t\t{\n\t\t\t\t\tnode->hj_FirstOuterTupleSlot = ExecProcNode(outerNode);\n\t\t\t\t\tif (TupIsNull(node->hj_FirstOuterTupleSlot))\n\t\t\t\t\t{\n\t\t\t\t\t\tnode->hj_OuterNotEmpty = false;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tnode->hj_OuterNotEmpty = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tnode->hj_FirstOuterTupleSlot = NULL;\n\n\t\t\t\t/*\n\t\t\t\t * Create the hash table.  If using Parallel Hash, then\n\t\t\t\t * whoever gets here first will create the hash table and any\n\t\t\t\t * later arrivals will merely attach to it.\n\t\t\t\t */\n\t\t\t\thashtable = ExecHashTableCreate(hashNode,\n\t\t\t\t\t\t\t\t\t\t\t\tnode->hj_HashOperators,\n\t\t\t\t\t\t\t\t\t\t\t\tHJ_FILL_INNER(node));\n\t\t\t\tnode->hj_HashTable = hashtable;\n\n\t\t\t\t/*\n\t\t\t\t * Execute the Hash node, to build the hash table.  If using\n\t\t\t\t * Parallel Hash, then we'll try to help hashing unless we\n\t\t\t\t * arrived too late.\n\t\t\t\t */\n\t\t\t\thashNode->hashtable = hashtable;\n\t\t\t\t(void) MultiExecProcNode((PlanState *) hashNode);\n\n\t\t\t\t/*\n\t\t\t\t * If the inner relation is completely empty, and we're not\n\t\t\t\t * doing a left outer join, we can quit without scanning the\n\t\t\t\t * outer relation.\n\t\t\t\t */\n\t\t\t\tif (hashtable->totalTuples == 0 && !HJ_FILL_OUTER(node))\n\t\t\t\t\treturn NULL;\n\n\t\t\t\t/*\n\t\t\t\t * need to remember whether nbatch has increased since we\n\t\t\t\t * began scanning the outer relation\n\t\t\t\t */\n\t\t\t\thashtable->nbatch_outstart = hashtable->nbatch;\n\n\t\t\t\t/*\n\t\t\t\t * Reset OuterNotEmpty for scan.  (It's OK if we fetched a\n\t\t\t\t * tuple above, because ExecHashJoinOuterGetTuple will\n\t\t\t\t * immediately set it again.)\n\t\t\t\t */\n\t\t\t\tnode->hj_OuterNotEmpty = false;\n\n\t\t\t\tif (parallel)\n\t\t\t\t{\n\t\t\t\t\tBarrier    *build_barrier;\n\n\t\t\t\t\tbuild_barrier = &parallel_state->build_barrier;\n\t\t\t\t\tAssert(BarrierPhase(build_barrier) == PHJ_BUILD_HASHING_OUTER ||\n\t\t\t\t\t\t   BarrierPhase(build_barrier) == PHJ_BUILD_DONE);\n\t\t\t\t\tif (BarrierPhase(build_barrier) == PHJ_BUILD_HASHING_OUTER)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If multi-batch, we need to hash the outer relation\n\t\t\t\t\t\t * up front.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (hashtable->nbatch > 1)\n\t\t\t\t\t\t\tExecParallelHashJoinPartitionOuter(node);\n\t\t\t\t\t\tBarrierArriveAndWait(build_barrier,\n\t\t\t\t\t\t\t\t\t\t\t WAIT_EVENT_HASH_BUILD_HASHING_OUTER);\n\t\t\t\t\t}\n\t\t\t\t\tAssert(BarrierPhase(build_barrier) == PHJ_BUILD_DONE);\n\n\t\t\t\t\t/* Each backend should now select a batch to work on. */\n\t\t\t\t\thashtable->curbatch = -1;\n\t\t\t\t\tnode->hj_JoinState = HJ_NEED_NEW_BATCH;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tnode->hj_JoinState = HJ_NEED_NEW_OUTER;\n\t\t\t\tswitch_fallthrough();\n\n\t\t\tcase HJ_NEED_NEW_OUTER:\n\n\t\t\t\t/*\n\t\t\t\t * We don't have an outer tuple, try to get the next one\n\t\t\t\t */\n\t\t\t\tif (parallel)\n\t\t\t\t\touterTupleSlot =\n\t\t\t\t\t\tExecParallelHashJoinOuterGetTuple(outerNode, node,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  &hashvalue);\n\t\t\t\telse\n\t\t\t\t\touterTupleSlot =\n\t\t\t\t\t\tExecHashJoinOuterGetTuple(outerNode, node, &hashvalue);\n\n\t\t\t\tif (TupIsNull(outerTupleSlot))\n\t\t\t\t{\n\t\t\t\t\t/* end of batch, or maybe whole join */\n\t\t\t\t\tif (HJ_FILL_INNER(node))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* set up to scan for unmatched inner tuples */\n\t\t\t\t\t\tExecPrepHashTableForUnmatched(node);\n\t\t\t\t\t\tnode->hj_JoinState = HJ_FILL_INNER_TUPLES;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tnode->hj_JoinState = HJ_NEED_NEW_BATCH;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tecontext->ecxt_outertuple = outerTupleSlot;\n\t\t\t\tnode->hj_MatchedOuter = false;\n\n\t\t\t\t/*\n\t\t\t\t * Find the corresponding bucket for this tuple in the main\n\t\t\t\t * hash table or skew hash table.\n\t\t\t\t */\n\t\t\t\tnode->hj_CurHashValue = hashvalue;\n\t\t\t\tExecHashGetBucketAndBatch(hashtable, hashvalue,\n\t\t\t\t\t\t\t\t\t\t  &node->hj_CurBucketNo, &batchno);\n\t\t\t\tnode->hj_CurSkewBucketNo = ExecHashGetSkewBucket(hashtable,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t hashvalue);\n\t\t\t\tnode->hj_CurTuple = NULL;\n\n\t\t\t\t/*\n\t\t\t\t * The tuple might not belong to the current batch (where\n\t\t\t\t * \"current batch\" includes the skew buckets if any).\n\t\t\t\t */\n\t\t\t\tif (batchno != hashtable->curbatch &&\n\t\t\t\t\tnode->hj_CurSkewBucketNo == INVALID_SKEW_BUCKET_NO)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Need to postpone this outer tuple to a later batch.\n\t\t\t\t\t * Save it in the corresponding outer-batch file.\n\t\t\t\t\t */\n\t\t\t\t\tAssert(parallel_state == NULL);\n\t\t\t\t\tAssert(batchno > hashtable->curbatch);\n\t\t\t\t\tExecHashJoinSaveTuple(ExecFetchSlotMinimalTuple(outerTupleSlot),\n\t\t\t\t\t\t\t\t\t\t  hashvalue,\n\t\t\t\t\t\t\t\t\t\t  &hashtable->outerBatchFile[batchno]);\n\n\t\t\t\t\t/* Loop around, staying in HJ_NEED_NEW_OUTER state */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* OK, let's scan the bucket for matches */\n\t\t\t\tnode->hj_JoinState = HJ_SCAN_BUCKET;\n\n\t\t\t\tswitch_fallthrough();\n\n\t\t\tcase HJ_SCAN_BUCKET:\n\n\t\t\t\t/*\n\t\t\t\t * Scan the selected hash bucket for matches to current outer\n\t\t\t\t */\n\t\t\t\tif (parallel)\n\t\t\t\t{\n\t\t\t\t\tif (!ExecParallelScanHashBucket(node, econtext))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* out of matches; check for possible outer-join fill */\n\t\t\t\t\t\tnode->hj_JoinState = HJ_FILL_OUTER_TUPLE;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!ExecScanHashBucket(node, econtext))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* out of matches; check for possible outer-join fill */\n\t\t\t\t\t\tnode->hj_JoinState = HJ_FILL_OUTER_TUPLE;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * We've got a match, but still need to test non-hashed quals.\n\t\t\t\t * ExecScanHashBucket already set up all the state needed to\n\t\t\t\t * call ExecQual.\n\t\t\t\t *\n\t\t\t\t * If we pass the qual, then save state for next call and have\n\t\t\t\t * ExecProject form the projection, store it in the tuple\n\t\t\t\t * table, and return the slot.\n\t\t\t\t *\n\t\t\t\t * Only the joinquals determine tuple match status, but all\n\t\t\t\t * quals must pass to actually return the tuple.\n\t\t\t\t */\n\t\t\t\tif (joinqual == NULL || ExecQual(joinqual, econtext))\n\t\t\t\t{\n\t\t\t\t\tnode->hj_MatchedOuter = true;\n\t\t\t\t\tHeapTupleHeaderSetMatch(HJTUPLE_MINTUPLE(node->hj_CurTuple));\n\n\t\t\t\t\t/* In an antijoin, we never return a matched tuple */\n\t\t\t\t\tif (node->js.jointype == JOIN_ANTI)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode->hj_JoinState = HJ_NEED_NEW_OUTER;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If we only need to join to the first matching inner\n\t\t\t\t\t * tuple, then consider returning this one, but after that\n\t\t\t\t\t * continue with next outer tuple.\n\t\t\t\t\t */\n\t\t\t\t\tif (node->js.single_match)\n\t\t\t\t\t\tnode->hj_JoinState = HJ_NEED_NEW_OUTER;\n\n\t\t\t\t\tif (otherqual == NULL || ExecQual(otherqual, econtext))\n\t\t\t\t\t\treturn ExecProject(node->js.ps.ps_ProjInfo);\n\t\t\t\t\telse\n\t\t\t\t\t\tInstrCountFiltered2(node, 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tInstrCountFiltered1(node, 1);\n\t\t\t\tbreak;\n\n\t\t\tcase HJ_FILL_OUTER_TUPLE:\n\n\t\t\t\t/*\n\t\t\t\t * The current outer tuple has run out of matches, so check\n\t\t\t\t * whether to emit a dummy outer-join tuple.  Whether we emit\n\t\t\t\t * one or not, the next state is NEED_NEW_OUTER.\n\t\t\t\t */\n\t\t\t\tnode->hj_JoinState = HJ_NEED_NEW_OUTER;\n\n\t\t\t\tif (!node->hj_MatchedOuter &&\n\t\t\t\t\tHJ_FILL_OUTER(node))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Generate a fake join tuple with nulls for the inner\n\t\t\t\t\t * tuple, and return it if it passes the non-join quals.\n\t\t\t\t\t */\n\t\t\t\t\tecontext->ecxt_innertuple = node->hj_NullInnerTupleSlot;\n\n\t\t\t\t\tif (otherqual == NULL || ExecQual(otherqual, econtext))\n\t\t\t\t\t\treturn ExecProject(node->js.ps.ps_ProjInfo);\n\t\t\t\t\telse\n\t\t\t\t\t\tInstrCountFiltered2(node, 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase HJ_FILL_INNER_TUPLES:\n\n\t\t\t\t/*\n\t\t\t\t * We have finished a batch, but we are doing right/full join,\n\t\t\t\t * so any unmatched inner tuples in the hashtable have to be\n\t\t\t\t * emitted before we continue to the next batch.\n\t\t\t\t */\n\t\t\t\tif (!ExecScanHashTableForUnmatched(node, econtext))\n\t\t\t\t{\n\t\t\t\t\t/* no more unmatched tuples */\n\t\t\t\t\tnode->hj_JoinState = HJ_NEED_NEW_BATCH;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Generate a fake join tuple with nulls for the outer tuple,\n\t\t\t\t * and return it if it passes the non-join quals.\n\t\t\t\t */\n\t\t\t\tecontext->ecxt_outertuple = node->hj_NullOuterTupleSlot;\n\n\t\t\t\tif (otherqual == NULL || ExecQual(otherqual, econtext))\n\t\t\t\t\treturn ExecProject(node->js.ps.ps_ProjInfo);\n\t\t\t\telse\n\t\t\t\t\tInstrCountFiltered2(node, 1);\n\t\t\t\tbreak;\n\n\t\t\tcase HJ_NEED_NEW_BATCH:\n\n\t\t\t\t/*\n\t\t\t\t * Try to advance to next batch.  Done if there are no more.\n\t\t\t\t */\n\t\t\t\tif (parallel)\n\t\t\t\t{\n\t\t\t\t\tif (!ExecParallelHashJoinNewBatch(node))\n\t\t\t\t\t\treturn NULL;\t/* end of parallel-aware join */\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!ExecHashJoinNewBatch(node))\n\t\t\t\t\t\treturn NULL;\t/* end of parallel-oblivious join */\n\t\t\t\t}\n\t\t\t\tnode->hj_JoinState = HJ_NEED_NEW_OUTER;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized hashjoin state: %d\",\n\t\t\t\t\t (int) node->hj_JoinState);\n\t\t}\n\t}\n}", "path": "yugabyte-db/src/postgres/src/backend/executor/nodeHashjoin.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "yugabyte/yugabyte-db", "stars": 8389, "license": "other", "language": "c", "size": 660299}
{"docstring": "/*\n * Guts of rule deletion.\n */\n", "func_signal": "void\nRemoveRewriteRuleById(Oid ruleOid)", "code": "{\n\tRelation\tRewriteRelation;\n\tScanKeyData skey[1];\n\tSysScanDesc rcscan;\n\tRelation\tevent_relation;\n\tHeapTuple\ttuple;\n\tOid\t\t\teventRelationOid;\n\n\t/*\n\t * Open the pg_rewrite relation.\n\t */\n\tRewriteRelation = heap_open(RewriteRelationId, RowExclusiveLock);\n\n\t/*\n\t * Find the tuple for the target rule.\n\t */\n\tScanKeyInit(&skey[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(ruleOid));\n\n\trcscan = systable_beginscan(RewriteRelation, RewriteOidIndexId, true,\n\t\t\t\t\t\t\t\tNULL, 1, skey);\n\n\ttuple = systable_getnext(rcscan);\n\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"could not find tuple for rule %u\", ruleOid);\n\n\t/*\n\t * We had better grab AccessExclusiveLock to ensure that no queries are\n\t * going on that might depend on this rule.  (Note: a weaker lock would\n\t * suffice if it's not an ON SELECT rule.)\n\t */\n\teventRelationOid = ((Form_pg_rewrite) GETSTRUCT(tuple))->ev_class;\n\tevent_relation = heap_open(eventRelationOid, AccessExclusiveLock);\n\n\t/*\n\t * Now delete the pg_rewrite tuple for the rule\n\t */\n\tCatalogTupleDelete(RewriteRelation, tuple);\n\n\tsystable_endscan(rcscan);\n\n\theap_close(RewriteRelation, RowExclusiveLock);\n\n\t/*\n\t * Issue shared-inval notice to force all backends (including me!) to\n\t * update relcache entries with the new rule set.\n\t */\n\tCacheInvalidateRelcache(event_relation);\n\n\t/* Close rel, but keep lock till commit... */\n\theap_close(event_relation, NoLock);\n}", "path": "yugabyte-db/src/postgres/src/backend/rewrite/rewriteRemove.c", "commit_date": "2019-03-06 00:00:00", "repo_name": "yugabyte/yugabyte-db", "stars": 8389, "license": "other", "language": "c", "size": 660299}
{"docstring": "/*\n * ExecHashJoinOuterGetTuple\n *\n *\t\tget the next outer tuple for a parallel oblivious hashjoin: either by\n *\t\texecuting the outer plan node in the first pass, or from the temp\n *\t\tfiles for the hashjoin batches.\n *\n * Returns a null slot if no more outer tuples (within the current batch).\n *\n * On success, the tuple's hash value is stored at *hashvalue --- this is\n * either originally computed, or re-read from the temp file.\n */\n", "func_signal": "static TupleTableSlot *\nExecHashJoinOuterGetTuple(PlanState *outerNode,\n\t\t\t\t\t\t  HashJoinState *hjstate,\n\t\t\t\t\t\t  uint32 *hashvalue)", "code": "{\n\tHashJoinTable hashtable = hjstate->hj_HashTable;\n\tint\t\t\tcurbatch = hashtable->curbatch;\n\tTupleTableSlot *slot;\n\n\tif (curbatch == 0)\t\t\t/* if it is the first pass */\n\t{\n\t\t/*\n\t\t * Check to see if first outer tuple was already fetched by\n\t\t * ExecHashJoin() and not used yet.\n\t\t */\n\t\tslot = hjstate->hj_FirstOuterTupleSlot;\n\t\tif (!TupIsNull(slot))\n\t\t\thjstate->hj_FirstOuterTupleSlot = NULL;\n\t\telse\n\t\t\tslot = ExecProcNode(outerNode);\n\n\t\twhile (!TupIsNull(slot))\n\t\t{\n\t\t\t/*\n\t\t\t * We have to compute the tuple's hash value.\n\t\t\t */\n\t\t\tExprContext *econtext = hjstate->js.ps.ps_ExprContext;\n\n\t\t\tecontext->ecxt_outertuple = slot;\n\t\t\tif (ExecHashGetHashValue(hashtable, econtext,\n\t\t\t\t\t\t\t\t\t hjstate->hj_OuterHashKeys,\n\t\t\t\t\t\t\t\t\t true,\t/* outer tuple */\n\t\t\t\t\t\t\t\t\t HJ_FILL_OUTER(hjstate),\n\t\t\t\t\t\t\t\t\t hashvalue))\n\t\t\t{\n\t\t\t\t/* remember outer relation is not empty for possible rescan */\n\t\t\t\thjstate->hj_OuterNotEmpty = true;\n\n\t\t\t\treturn slot;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * That tuple couldn't match because of a NULL, so discard it and\n\t\t\t * continue with the next one.\n\t\t\t */\n\t\t\tslot = ExecProcNode(outerNode);\n\t\t}\n\t}\n\telse if (curbatch < hashtable->nbatch)\n\t{\n\t\tBufFile    *file = hashtable->outerBatchFile[curbatch];\n\n\t\t/*\n\t\t * In outer-join cases, we could get here even though the batch file\n\t\t * is empty.\n\t\t */\n\t\tif (file == NULL)\n\t\t\treturn NULL;\n\n\t\tslot = ExecHashJoinGetSavedTuple(hjstate,\n\t\t\t\t\t\t\t\t\t\t file,\n\t\t\t\t\t\t\t\t\t\t hashvalue,\n\t\t\t\t\t\t\t\t\t\t hjstate->hj_OuterTupleSlot);\n\t\tif (!TupIsNull(slot))\n\t\t\treturn slot;\n\t}\n\n\t/* End of this batch */\n\treturn NULL;\n}", "path": "yugabyte-db/src/postgres/src/backend/executor/nodeHashjoin.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "yugabyte/yugabyte-db", "stars": 8389, "license": "other", "language": "c", "size": 660299}
{"docstring": "/*\n * show_log_timezone: GUC show_hook for log_timezone\n */\n", "func_signal": "const char *\nshow_log_timezone(void)", "code": "{\n\tconst char *tzn;\n\n\t/* Always show the zone's canonical name */\n\ttzn = pg_get_timezone_name(log_timezone);\n\n\tif (tzn != NULL)\n\t\treturn tzn;\n\n\treturn \"unknown\";\n}", "path": "yugabyte-db/src/postgres/src/backend/commands/variable.c", "commit_date": "2020-10-10 00:00:00", "repo_name": "yugabyte/yugabyte-db", "stars": 8389, "license": "other", "language": "c", "size": 660299}
{"docstring": "/*\n * assign_datestyle: GUC assign_hook for datestyle\n */\n", "func_signal": "void\nassign_datestyle(const char *newval, void *extra)", "code": "{\n\tint\t\t   *myextra = (int *) extra;\n\n\tDateStyle = myextra[0];\n\tDateOrder = myextra[1];\n}", "path": "yugabyte-db/src/postgres/src/backend/commands/variable.c", "commit_date": "2020-10-10 00:00:00", "repo_name": "yugabyte/yugabyte-db", "stars": 8389, "license": "other", "language": "c", "size": 660299}
{"docstring": "/*\n * SET TRANSACTION READ ONLY and SET TRANSACTION READ WRITE\n *\n * We allow idempotent changes (r/w -> r/w and r/o -> r/o) at any time, and\n * we also always allow changes from read-write to read-only.  However,\n * read-only may be changed to read-write only when in a top-level transaction\n * that has not yet taken an initial snapshot.  Can't do it in a hot standby,\n * either.\n *\n * If we are not in a transaction at all, just allow the change; it means\n * nothing since XactReadOnly will be reset by the next StartTransaction().\n * The IsTransactionState() test protects us against trying to check\n * RecoveryInProgress() in contexts where shared memory is not accessible.\n * (Similarly, if we're restoring state in a parallel worker, just allow\n * the change.)\n */\n", "func_signal": "bool\ncheck_transaction_read_only(bool *newval, void **extra, GucSource source)", "code": "{\n\tif (*newval == false && XactReadOnly && IsTransactionState() && !InitializingParallelWorker)\n\t{\n\t\t/* Can't go to r/w mode inside a r/o transaction */\n\t\tif (IsSubTransaction())\n\t\t{\n\t\t\tGUC_check_errcode(ERRCODE_ACTIVE_SQL_TRANSACTION);\n\t\t\tGUC_check_errmsg(\"cannot set transaction read-write mode inside a read-only transaction\");\n\t\t\treturn false;\n\t\t}\n\t\t/* Top level transaction can't change to r/w after first snapshot. */\n\t\tif (FirstSnapshotSet)\n\t\t{\n\t\t\tGUC_check_errcode(ERRCODE_ACTIVE_SQL_TRANSACTION);\n\t\t\tGUC_check_errmsg(\"transaction read-write mode must be set before any query\");\n\t\t\treturn false;\n\t\t}\n\t\t/* Can't go to r/w mode while recovery is still active */\n\t\tif (RecoveryInProgress())\n\t\t{\n\t\t\tGUC_check_errcode(ERRCODE_FEATURE_NOT_SUPPORTED);\n\t\t\tGUC_check_errmsg(\"cannot set transaction read-write mode during recovery\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "path": "yugabyte-db/src/postgres/src/backend/commands/variable.c", "commit_date": "2020-10-10 00:00:00", "repo_name": "yugabyte/yugabyte-db", "stars": 8389, "license": "other", "language": "c", "size": 660299}
{"docstring": "/*\n * BuildTupleHashTable is a backwards-compatibilty wrapper for\n * BuildTupleHashTableExt(), that allocates the hashtable's metadata in\n * tablecxt. Note that hashtables created this way cannot be reset leak-free\n * with ResetTupleHashTable().\n */\n", "func_signal": "TupleHashTable\nBuildTupleHashTable(PlanState *parent,\n\t\t\t\t\tTupleDesc inputDesc,\n\t\t\t\t\tint numCols, AttrNumber *keyColIdx,\n\t\t\t\t\tOid *eqfuncoids,\n\t\t\t\t\tFmgrInfo *hashfunctions,\n\t\t\t\t\tlong nbuckets, Size additionalsize,\n\t\t\t\t\tMemoryContext tablecxt,\n\t\t\t\t\tMemoryContext tempcxt,\n\t\t\t\t\tbool use_variable_hash_iv)", "code": "{\n\treturn BuildTupleHashTableExt(parent,\n\t\t\t\t\t\t\t\t  inputDesc,\n\t\t\t\t\t\t\t\t  numCols, keyColIdx,\n\t\t\t\t\t\t\t\t  eqfuncoids,\n\t\t\t\t\t\t\t\t  hashfunctions,\n\t\t\t\t\t\t\t\t  nbuckets, additionalsize,\n\t\t\t\t\t\t\t\t  tablecxt,\n\t\t\t\t\t\t\t\t  tablecxt,\n\t\t\t\t\t\t\t\t  tempcxt,\n\t\t\t\t\t\t\t\t  use_variable_hash_iv);\n}", "path": "yugabyte-db/src/postgres/src/backend/executor/execGrouping.c", "commit_date": "2020-02-28 00:00:00", "repo_name": "yugabyte/yugabyte-db", "stars": 8389, "license": "other", "language": "c", "size": 660299}
{"docstring": "/*\n * Find or create a hashtable entry for the tuple group containing the\n * given tuple.  The tuple must be the same type as the hashtable entries.\n *\n * If isnew is NULL, we do not create new entries; we return NULL if no\n * match is found.\n *\n * If isnew isn't NULL, then a new entry is created if no existing entry\n * matches.  On return, *isnew is true if the entry is newly created,\n * false if it existed already.  ->additional_data in the new entry has\n * been zeroed.\n */\n", "func_signal": "TupleHashEntry\nLookupTupleHashEntry(TupleHashTable hashtable, TupleTableSlot *slot,\n\t\t\t\t\t bool *isnew)", "code": "{\n\tTupleHashEntryData *entry;\n\tMemoryContext oldContext;\n\tbool\t\tfound;\n\tMinimalTuple key;\n\n\t/* Need to run the hash functions in short-lived context */\n\toldContext = MemoryContextSwitchTo(hashtable->tempcxt);\n\n\t/* set up data needed by hash and match functions */\n\thashtable->inputslot = slot;\n\thashtable->in_hash_funcs = hashtable->tab_hash_funcs;\n\thashtable->cur_eq_func = hashtable->tab_eq_func;\n\n\tkey = NULL;\t\t\t\t\t/* flag to reference inputslot */\n\n\tif (isnew)\n\t{\n\t\tentry = tuplehash_insert(hashtable->hashtab, key, &found);\n\n\t\tif (found)\n\t\t{\n\t\t\t/* found pre-existing entry */\n\t\t\t*isnew = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* created new entry */\n\t\t\t*isnew = true;\n\t\t\t/* zero caller data */\n\t\t\tentry->additional = NULL;\n\t\t\tMemoryContextSwitchTo(hashtable->tablecxt);\n\t\t\t/* Copy the first tuple into the table context */\n\t\t\tentry->firstTuple = ExecCopySlotMinimalTuple(slot);\n\t\t}\n\t}\n\telse\n\t{\n\t\tentry = tuplehash_lookup(hashtable->hashtab, key);\n\t}\n\n\tMemoryContextSwitchTo(oldContext);\n\n\treturn entry;\n}", "path": "yugabyte-db/src/postgres/src/backend/executor/execGrouping.c", "commit_date": "2020-02-28 00:00:00", "repo_name": "yugabyte/yugabyte-db", "stars": 8389, "license": "other", "language": "c", "size": 660299}
{"docstring": "/*\n * ExecHashJoinNewBatch\n *\t\tswitch to a new hashjoin batch\n *\n * Returns true if successful, false if there are no more batches.\n */\n", "func_signal": "static bool\nExecHashJoinNewBatch(HashJoinState *hjstate)", "code": "{\n\tHashJoinTable hashtable = hjstate->hj_HashTable;\n\tint\t\t\tnbatch;\n\tint\t\t\tcurbatch;\n\tBufFile    *innerFile;\n\tTupleTableSlot *slot;\n\tuint32\t\thashvalue;\n\n\tnbatch = hashtable->nbatch;\n\tcurbatch = hashtable->curbatch;\n\n\tif (curbatch > 0)\n\t{\n\t\t/*\n\t\t * We no longer need the previous outer batch file; close it right\n\t\t * away to free disk space.\n\t\t */\n\t\tif (hashtable->outerBatchFile[curbatch])\n\t\t\tBufFileClose(hashtable->outerBatchFile[curbatch]);\n\t\thashtable->outerBatchFile[curbatch] = NULL;\n\t}\n\telse\t\t\t\t\t\t/* we just finished the first batch */\n\t{\n\t\t/*\n\t\t * Reset some of the skew optimization state variables, since we no\n\t\t * longer need to consider skew tuples after the first batch. The\n\t\t * memory context reset we are about to do will release the skew\n\t\t * hashtable itself.\n\t\t */\n\t\thashtable->skewEnabled = false;\n\t\thashtable->skewBucket = NULL;\n\t\thashtable->skewBucketNums = NULL;\n\t\thashtable->nSkewBuckets = 0;\n\t\thashtable->spaceUsedSkew = 0;\n\t}\n\n\t/*\n\t * We can always skip over any batches that are completely empty on both\n\t * sides.  We can sometimes skip over batches that are empty on only one\n\t * side, but there are exceptions:\n\t *\n\t * 1. In a left/full outer join, we have to process outer batches even if\n\t * the inner batch is empty.  Similarly, in a right/full outer join, we\n\t * have to process inner batches even if the outer batch is empty.\n\t *\n\t * 2. If we have increased nbatch since the initial estimate, we have to\n\t * scan inner batches since they might contain tuples that need to be\n\t * reassigned to later inner batches.\n\t *\n\t * 3. Similarly, if we have increased nbatch since starting the outer\n\t * scan, we have to rescan outer batches in case they contain tuples that\n\t * need to be reassigned.\n\t */\n\tcurbatch++;\n\twhile (curbatch < nbatch &&\n\t\t   (hashtable->outerBatchFile[curbatch] == NULL ||\n\t\t\thashtable->innerBatchFile[curbatch] == NULL))\n\t{\n\t\tif (hashtable->outerBatchFile[curbatch] &&\n\t\t\tHJ_FILL_OUTER(hjstate))\n\t\t\tbreak;\t\t\t\t/* must process due to rule 1 */\n\t\tif (hashtable->innerBatchFile[curbatch] &&\n\t\t\tHJ_FILL_INNER(hjstate))\n\t\t\tbreak;\t\t\t\t/* must process due to rule 1 */\n\t\tif (hashtable->innerBatchFile[curbatch] &&\n\t\t\tnbatch != hashtable->nbatch_original)\n\t\t\tbreak;\t\t\t\t/* must process due to rule 2 */\n\t\tif (hashtable->outerBatchFile[curbatch] &&\n\t\t\tnbatch != hashtable->nbatch_outstart)\n\t\t\tbreak;\t\t\t\t/* must process due to rule 3 */\n\t\t/* We can ignore this batch. */\n\t\t/* Release associated temp files right away. */\n\t\tif (hashtable->innerBatchFile[curbatch])\n\t\t\tBufFileClose(hashtable->innerBatchFile[curbatch]);\n\t\thashtable->innerBatchFile[curbatch] = NULL;\n\t\tif (hashtable->outerBatchFile[curbatch])\n\t\t\tBufFileClose(hashtable->outerBatchFile[curbatch]);\n\t\thashtable->outerBatchFile[curbatch] = NULL;\n\t\tcurbatch++;\n\t}\n\n\tif (curbatch >= nbatch)\n\t\treturn false;\t\t\t/* no more batches */\n\n\thashtable->curbatch = curbatch;\n\n\t/*\n\t * Reload the hash table with the new inner batch (which could be empty)\n\t */\n\tExecHashTableReset(hashtable);\n\n\tinnerFile = hashtable->innerBatchFile[curbatch];\n\n\tif (innerFile != NULL)\n\t{\n\t\tif (BufFileSeek(innerFile, 0, 0L, SEEK_SET))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not rewind hash-join temporary file: %m\")));\n\n\t\twhile ((slot = ExecHashJoinGetSavedTuple(hjstate,\n\t\t\t\t\t\t\t\t\t\t\t\t innerFile,\n\t\t\t\t\t\t\t\t\t\t\t\t &hashvalue,\n\t\t\t\t\t\t\t\t\t\t\t\t hjstate->hj_HashTupleSlot)))\n\t\t{\n\t\t\t/*\n\t\t\t * NOTE: some tuples may be sent to future batches.  Also, it is\n\t\t\t * possible for hashtable->nbatch to be increased here!\n\t\t\t */\n\t\t\tExecHashTableInsert(hashtable, slot, hashvalue);\n\t\t}\n\n\t\t/*\n\t\t * after we build the hash table, the inner batch file is no longer\n\t\t * needed\n\t\t */\n\t\tBufFileClose(innerFile);\n\t\thashtable->innerBatchFile[curbatch] = NULL;\n\t}\n\n\t/*\n\t * Rewind outer batch file (if present), so that we can start reading it.\n\t */\n\tif (hashtable->outerBatchFile[curbatch] != NULL)\n\t{\n\t\tif (BufFileSeek(hashtable->outerBatchFile[curbatch], 0, 0L, SEEK_SET))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not rewind hash-join temporary file: %m\")));\n\t}\n\n\treturn true;\n}", "path": "yugabyte-db/src/postgres/src/backend/executor/nodeHashjoin.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "yugabyte/yugabyte-db", "stars": 8389, "license": "other", "language": "c", "size": 660299}
{"docstring": "/*\n * check_log_timezone: GUC check_hook for log_timezone\n */\n", "func_signal": "bool\ncheck_log_timezone(char **newval, void **extra, GucSource source)", "code": "{\n\tpg_tz\t   *new_tz;\n\n\t/*\n\t * Assume it is a timezone name, and try to load it.\n\t */\n\tnew_tz = pg_tzset(*newval);\n\n\tif (!new_tz)\n\t{\n\t\t/* Doesn't seem to be any great value in errdetail here */\n\t\treturn false;\n\t}\n\n\tif (!pg_tz_acceptable(new_tz))\n\t{\n\t\tGUC_check_errmsg(\"time zone \\\"%s\\\" appears to use leap seconds\",\n\t\t\t\t\t\t *newval);\n\t\tGUC_check_errdetail(\"PostgreSQL does not support leap seconds.\");\n\t\treturn false;\n\t}\n\n\t/*\n\t * Pass back data for assign_log_timezone to use\n\t */\n\t*extra = malloc(sizeof(pg_tz *));\n\tif (!*extra)\n\t\treturn false;\n\t*((pg_tz **) *extra) = new_tz;\n\n\treturn true;\n}", "path": "yugabyte-db/src/postgres/src/backend/commands/variable.c", "commit_date": "2020-10-10 00:00:00", "repo_name": "yugabyte/yugabyte-db", "stars": 8389, "license": "other", "language": "c", "size": 660299}
{"docstring": "/*\n * show_timezone: GUC show_hook for timezone\n */\n", "func_signal": "const char *\nshow_timezone(void)", "code": "{\n\tconst char *tzn;\n\n\t/* Always show the zone's canonical name */\n\ttzn = pg_get_timezone_name(session_timezone);\n\n\tif (tzn != NULL)\n\t\treturn tzn;\n\n\treturn \"unknown\";\n}", "path": "yugabyte-db/src/postgres/src/backend/commands/variable.c", "commit_date": "2020-10-10 00:00:00", "repo_name": "yugabyte/yugabyte-db", "stars": 8389, "license": "other", "language": "c", "size": 660299}
{"docstring": "/* ----------------------------------------------------------------\n *\t\tExecHashJoinReInitializeDSM\n *\n *\t\tReset shared state before beginning a fresh scan.\n * ----------------------------------------------------------------\n */\n", "func_signal": "void\nExecHashJoinReInitializeDSM(HashJoinState *state, ParallelContext *cxt)", "code": "{\n\tint\t\t\tplan_node_id = state->js.ps.plan->plan_node_id;\n\tParallelHashJoinState *pstate =\n\tshm_toc_lookup(cxt->toc, plan_node_id, false);\n\n\t/*\n\t * It would be possible to reuse the shared hash table in single-batch\n\t * cases by resetting and then fast-forwarding build_barrier to\n\t * PHJ_BUILD_DONE and batch 0's batch_barrier to PHJ_BATCH_PROBING, but\n\t * currently shared hash tables are already freed by now (by the last\n\t * participant to detach from the batch).  We could consider keeping it\n\t * around for single-batch joins.  We'd also need to adjust\n\t * finalize_plan() so that it doesn't record a dummy dependency for\n\t * Parallel Hash nodes, preventing the rescan optimization.  For now we\n\t * don't try.\n\t */\n\n\t/* Detach, freeing any remaining shared memory. */\n\tif (state->hj_HashTable != NULL)\n\t{\n\t\tExecHashTableDetachBatch(state->hj_HashTable);\n\t\tExecHashTableDetach(state->hj_HashTable);\n\t}\n\n\t/* Clear any shared batch files. */\n\tSharedFileSetDeleteAll(&pstate->fileset);\n\n\t/* Reset build_barrier to PHJ_BUILD_ELECTING so we can go around again. */\n\tBarrierInit(&pstate->build_barrier, 0);\n}", "path": "yugabyte-db/src/postgres/src/backend/executor/nodeHashjoin.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "yugabyte/yugabyte-db", "stars": 8389, "license": "other", "language": "c", "size": 660299}
{"docstring": "/*\n * check_timezone: GUC check_hook for timezone\n */\n", "func_signal": "bool\ncheck_timezone(char **newval, void **extra, GucSource source)", "code": "{\n\tpg_tz\t   *new_tz;\n\tlong\t\tgmtoffset;\n\tchar\t   *endptr;\n\tdouble\t\thours;\n\n\tif (pg_strncasecmp(*newval, \"interval\", 8) == 0)\n\t{\n\t\t/*\n\t\t * Support INTERVAL 'foo'.  This is for SQL spec compliance, not\n\t\t * because it has any actual real-world usefulness.\n\t\t */\n\t\tconst char *valueptr = *newval;\n\t\tchar\t   *val;\n\t\tInterval   *interval;\n\n\t\tvalueptr += 8;\n\t\twhile (isspace((unsigned char) *valueptr))\n\t\t\tvalueptr++;\n\t\tif (*valueptr++ != '\\'')\n\t\t\treturn false;\n\t\tval = pstrdup(valueptr);\n\t\t/* Check and remove trailing quote */\n\t\tendptr = strchr(val, '\\'');\n\t\tif (!endptr || endptr[1] != '\\0')\n\t\t{\n\t\t\tpfree(val);\n\t\t\treturn false;\n\t\t}\n\t\t*endptr = '\\0';\n\n\t\t/*\n\t\t * Try to parse it.  XXX an invalid interval format will result in\n\t\t * ereport(ERROR), which is not desirable for GUC.  We did what we\n\t\t * could to guard against this in flatten_set_variable_args, but a\n\t\t * string coming in from postgresql.conf might contain anything.\n\t\t */\n\t\tinterval = DatumGetIntervalP(DirectFunctionCall3(interval_in,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t CStringGetDatum(val),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(InvalidOid),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t Int32GetDatum(-1)));\n\n\t\tpfree(val);\n\t\tif (interval->month != 0)\n\t\t{\n\t\t\tGUC_check_errdetail(\"Cannot specify months in time zone interval.\");\n\t\t\tpfree(interval);\n\t\t\treturn false;\n\t\t}\n\t\tif (interval->day != 0)\n\t\t{\n\t\t\tGUC_check_errdetail(\"Cannot specify days in time zone interval.\");\n\t\t\tpfree(interval);\n\t\t\treturn false;\n\t\t}\n\n\t\t/* Here we change from SQL to Unix sign convention */\n\t\tgmtoffset = -(interval->time / USECS_PER_SEC);\n\t\tnew_tz = pg_tzset_offset(gmtoffset);\n\n\t\tpfree(interval);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Try it as a numeric number of hours (possibly fractional).\n\t\t */\n\t\thours = strtod(*newval, &endptr);\n\t\tif (endptr != *newval && *endptr == '\\0')\n\t\t{\n\t\t\t/* Here we change from SQL to Unix sign convention */\n\t\t\tgmtoffset = -hours * SECS_PER_HOUR;\n\t\t\tnew_tz = pg_tzset_offset(gmtoffset);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Otherwise assume it is a timezone name, and try to load it.\n\t\t\t */\n\t\t\tnew_tz = pg_tzset(*newval);\n\n\t\t\tif (!new_tz)\n\t\t\t{\n\t\t\t\t/* Doesn't seem to be any great value in errdetail here */\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!pg_tz_acceptable(new_tz))\n\t\t\t{\n\t\t\t\tGUC_check_errmsg(\"time zone \\\"%s\\\" appears to use leap seconds\",\n\t\t\t\t\t\t\t\t *newval);\n\t\t\t\tGUC_check_errdetail(\"PostgreSQL does not support leap seconds.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Test for failure in pg_tzset_offset, which we assume is out-of-range */\n\tif (!new_tz)\n\t{\n\t\tGUC_check_errdetail(\"UTC timezone offset is out of range.\");\n\t\treturn false;\n\t}\n\n\t/*\n\t * Pass back data for assign_timezone to use\n\t */\n\t*extra = malloc(sizeof(pg_tz *));\n\tif (!*extra)\n\t\treturn false;\n\t*((pg_tz **) *extra) = new_tz;\n\n\treturn true;\n}", "path": "yugabyte-db/src/postgres/src/backend/commands/variable.c", "commit_date": "2020-10-10 00:00:00", "repo_name": "yugabyte/yugabyte-db", "stars": 8389, "license": "other", "language": "c", "size": 660299}
{"docstring": "/* First parse staged info using git-diff-index(1), then parse unstaged\n * info using git-diff-files(1), and finally untracked files using\n * git-ls-files(1). */\n", "func_signal": "static enum status_code\nstatus_open(struct view *view, enum open_flags flags)", "code": "{\n\tconst char **staged_argv = is_initial_commit() ?\n\t\tstatus_list_no_head_argv : status_diff_index_argv;\n\tchar staged_status = staged_argv == status_list_no_head_argv ? 'A' : 0;\n\n\tif (!(repo.is_inside_work_tree || *repo.worktree))\n\t\treturn error(\"The status view requires a working tree\");\n\n\treset_view(view);\n\n\t/* FIXME: Watch untracked files and on-branch info. */\n\twatch_register(&view->watch, WATCH_INDEX);\n\n\tadd_line_nodata(view, LINE_HEADER);\n\tstatus_update_onbranch();\n\n\tupdate_index();\n\n\tif ((!show_untracked_only && !status_run(view, staged_argv, staged_status, LINE_STAT_STAGED)) ||\n\t    (!show_untracked_only && !status_run(view, status_diff_files_argv, 0, LINE_STAT_UNSTAGED)) ||\n\t    !status_read_untracked(view))\n\t\treturn error(\"Failed to load status data\");\n\n\t/* Restore the exact position or use the specialized restore\n\t * mode? */\n\tstatus_restore(view);\n\treturn SUCCESS;\n}", "path": "tig/src/status.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "jonas/tig", "stars": 12060, "license": "gpl-2.0", "language": "c", "size": 7544}
{"docstring": "/* HAVE_READLINE */\n", "func_signal": "bool\nprompt_menu(const char *prompt, const struct menu_item *items, int *selected)", "code": "{\n\tenum input_status status = INPUT_OK;\n\tchar buf[128];\n\tstruct key key;\n\tint size = 0;\n\n\twhile (items[size].text)\n\t\tsize++;\n\n\tassert(size > 0);\n\n\tcurs_set(1);\n\twhile (status == INPUT_OK) {\n\t\tconst struct menu_item *item = &items[*selected];\n\t\tconst char hotkey[] = { ' ', '[', (char) item->hotkey, ']', 0 };\n\t\tint i;\n\n\t\tif (!string_format(buf, \"(%d of %d)\", *selected + 1, size))\n\t\t\tbuf[0] = 0;\n\n\t\tupdate_status_with_context(buf, \"%s %s%s\", prompt, item->text,\n\t\t\t      item->hotkey ? hotkey : \"\");\n\n\t\tswitch (get_input(COLS - 1, &key)) {\n\t\tcase KEY_RETURN:\n\t\tcase KEY_ENTER:\n\t\tcase '\\n':\n\t\t\tstatus = INPUT_STOP;\n\t\t\tbreak;\n\n\t\tcase KEY_LEFT:\n\t\tcase KEY_UP:\n\t\t\t*selected = *selected - 1;\n\t\t\tif (*selected < 0)\n\t\t\t\t*selected = size - 1;\n\t\t\tbreak;\n\n\t\tcase KEY_RIGHT:\n\t\tcase KEY_DOWN:\n\t\t\t*selected = (*selected + 1) % size;\n\t\t\tbreak;\n\n\t\tcase KEY_ESC:\n\t\t\tstatus = INPUT_CANCEL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (key_to_control(&key) == 'C') {\n\t\t\t\tstatus = INPUT_CANCEL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (i = 0; items[i].text; i++)\n\t\t\t\tif (items[i].hotkey == key.data.bytes[0]) {\n\t\t\t\t\t*selected = i;\n\t\t\t\t\tstatus = INPUT_STOP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n\tcurs_set(0);\n\n\treport_clear();\n\n\treturn status != INPUT_CANCEL;\n}", "path": "tig/src/prompt.c", "commit_date": "2020-04-04 00:00:00", "repo_name": "jonas/tig", "stars": 12060, "license": "gpl-2.0", "language": "c", "size": 7544}
{"docstring": "/* Restore the previous line number to stay in the context or select a\n * line with something that can be updated. */\n", "func_signal": "static void\nstatus_restore(struct view *view)", "code": "{\n\tif (!check_position(&view->prev_pos))\n\t\treturn;\n\n\tif (view->prev_pos.lineno >= view->lines)\n\t\tview->prev_pos.lineno = view->lines - 1;\n\twhile (view->prev_pos.lineno < view->lines && !view->line[view->prev_pos.lineno].data)\n\t\tview->prev_pos.lineno++;\n\twhile (view->prev_pos.lineno > 0 && !view->line[view->prev_pos.lineno].data)\n\t\tview->prev_pos.lineno--;\n\n\t/* If the above fails, always skip the \"On branch\" line. */\n\tif (view->prev_pos.lineno < view->lines)\n\t\tview->pos.lineno = view->prev_pos.lineno;\n\telse\n\t\tview->pos.lineno = 1;\n\n\tif (view->prev_pos.offset > view->pos.lineno)\n\t\tview->pos.offset = view->pos.lineno;\n\telse if (view->prev_pos.offset < view->lines)\n\t\tview->pos.offset = view->prev_pos.offset;\n\n\tclear_position(&view->prev_pos);\n}", "path": "tig/src/status.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "jonas/tig", "stars": 12060, "license": "gpl-2.0", "language": "c", "size": 7544}
{"docstring": "/*\n * Dump view data to file.\n *\n * FIXME: Add support for more line state and column data.\n */\n", "func_signal": "bool\nsave_view(struct view *view, const char *path)", "code": "{\n\tstruct view_column_data column_data = {0};\n\tFILE *file = fopen(path, \"w\");\n\tsize_t i;\n\n\tif (!file)\n\t\treturn false;\n\n\tfprintf(file, \"View: %s\\n\", view->name);\n\tif (view->prev && view->prev != view)\n\t\tfprintf(file, \"Prev: %s\\n\", view->prev->name);\n\tif (view->parent)\n\t\tfprintf(file, \"Parent: %s\\n\", view->parent->name);\n\tfprintf(file, \"Ref: %s\\n\", view->ref);\n\tfprintf(file, \"Dimensions: height=%d width=%d\\n\", view->height, view->width);\n\tfprintf(file, \"Position: offset=%ld column=%ld lineno=%ld\\n\",\n\t\tview->pos.offset,\n\t\tview->pos.col,\n\t\tview->pos.lineno);\n\n\tfor (i = 0; i < view->lines; i++) {\n\t\tstruct line *line = &view->line[i];\n\n\t\tfprintf(file, \"line[%3zu] type=%s selected=%d\\n\",\n\t\t\ti,\n\t\t\tenum_name(get_line_type_name(line->type)),\n\t\t\tline->selected);\n\n\t\tif (!view->ops->get_column_data(view, line, &column_data)) {\n\t\t\tfclose(file);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (column_data.box) {\n\t\t\tconst struct box *box = column_data.box;\n\t\t\tsize_t j;\n\t\t\tsize_t offset;\n\n\t\t\tfprintf(file, \"line[%3zu] cells=%zu text=\",\n\t\t\t\ti, box->cells);\n\n\t\t\tfor (j = 0, offset = 0; j < box->cells; j++) {\n\t\t\t\tconst struct box_cell *cell = &box->cell[j];\n\n\t\t\t\tfprintf(file, \"[%.*s]\", (int) cell->length, box->text + offset);\n\t\t\t\toffset += cell->length;\n\t\t\t}\n\n\t\t\tfprintf(file, \"\\n\");\n\t\t}\n\t}\n\n\tfclose(file);\n\treturn true;\n}", "path": "tig/src/display.c", "commit_date": "2020-12-23 00:00:00", "repo_name": "jonas/tig", "stars": 12060, "license": "gpl-2.0", "language": "c", "size": 7544}
{"docstring": "/*\n * View opening\n */\n", "func_signal": "static enum request\nopen_run_request(struct view *view, enum request request)", "code": "{\n\tstruct run_request *req = get_run_request(request);\n\n\tif (!req) {\n\t\treport(\"Unknown run request\");\n\t\treturn REQ_NONE;\n\t}\n\n\treturn exec_run_request(view, req);\n}", "path": "tig/src/tig.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "jonas/tig", "stars": 12060, "license": "gpl-2.0", "language": "c", "size": 7544}
{"docstring": "/* Update status and title window. */\n", "func_signal": "static bool\nupdate_status_window(struct view *view, const char *context, const char *msg, va_list args)", "code": "{\n\tif (input_mode)\n\t\treturn false;\n\n\tif (!status_empty || *msg) {\n\t\twmove(status_win, 0, 0);\n\t\tif (view && view->has_scrolled && use_scroll_status_wclear)\n\t\t\twclear(status_win);\n\t\tif (*msg) {\n\t\t\tvw_printw(status_win, msg, args);\n\t\t\tstatus_empty = false;\n\t\t} else {\n\t\t\tstatus_empty = true;\n\t\t}\n\t\twclrtoeol(status_win);\n\n\t\tif (context && *context) {\n\t\t\tsize_t contextlen = strlen(context);\n\t\t\tint x, y, width, ___;\n\n\t\t\tgetyx(status_win, y, x);\n\t\t\tgetmaxyx(status_win, ___, width);\n\t\t\t(void) ___;\n\t\t\tif (contextlen < width - x) {\n\t\t\t\tmvwprintw(status_win, 0, width - contextlen, \"%s\", context);\n\t\t\t\twmove(status_win, y, x);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "path": "tig/src/display.c", "commit_date": "2020-12-23 00:00:00", "repo_name": "jonas/tig", "stars": 12060, "license": "gpl-2.0", "language": "c", "size": 7544}
{"docstring": "/* Get fields from the diff line:\n * :100644 100644 06a5d6ae9eca55be2e0e585a152e6b1336f2b20e 0000000000000000000000000000000000000000 M\n */\n", "func_signal": "inline bool\nstatus_get_diff(struct status *file, const char *buf, size_t bufsize)", "code": "{\n\tconst char *old_mode = buf +  1;\n\tconst char *new_mode = buf +  8;\n\tconst char *old_rev  = buf + 15;\n\tconst char *new_rev  = buf + 56;\n\tconst char *status   = buf + 97;\n\n\tif (bufsize < 98 ||\n\t    old_mode[-1] != ':' ||\n\t    new_mode[-1] != ' ' ||\n\t    old_rev[-1]  != ' ' ||\n\t    new_rev[-1]  != ' ' ||\n\t    status[-1]   != ' ')\n\t\treturn false;\n\n\tfile->status = *status;\n\n\tstring_copy_rev(file->old.rev, old_rev);\n\tstring_copy_rev(file->new.rev, new_rev);\n\n\tfile->old.mode = strtoul(old_mode, NULL, 8);\n\tfile->new.mode = strtoul(new_mode, NULL, 8);\n\n\tfile->old.name[0] = file->new.name[0] = 0;\n\n\treturn true;\n}", "path": "tig/src/status.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "jonas/tig", "stars": 12060, "license": "gpl-2.0", "language": "c", "size": 7544}
{"docstring": "/* Scrolling backend */\n", "func_signal": "void\ndo_scroll_view(struct view *view, int lines)", "code": "{\n\tbool redraw_current_line = false;\n\n\t/* The rendering expects the new offset. */\n\tview->pos.offset += lines;\n\n\tassert(0 <= view->pos.offset && view->pos.offset < view->lines);\n\tassert(lines);\n\n\t/* Move current line into the view. */\n\tif (view->pos.lineno < view->pos.offset) {\n\t\tview->pos.lineno = view->pos.offset;\n\t\tredraw_current_line = true;\n\t} else if (view->pos.lineno >= view->pos.offset + view->height) {\n\t\tview->pos.lineno = view->pos.offset + view->height - 1;\n\t\tredraw_current_line = true;\n\t}\n\n\tassert(view->pos.offset <= view->pos.lineno && view->pos.lineno < view->lines);\n\n\t/* Redraw the whole screen if scrolling is pointless. */\n\tif (view->height < ABS(lines)) {\n\t\tredraw_view(view);\n\n\t} else {\n\t\tint line = lines > 0 ? view->height - lines : 0;\n\t\tint end = line + ABS(lines);\n\n\t\tscrollok(view->win, true);\n\t\twscrl(view->win, lines);\n\t\tscrollok(view->win, false);\n\n\t\twhile (line < end && draw_view_line(view, line))\n\t\t\tline++;\n\n\t\tif (redraw_current_line)\n\t\t\tdraw_view_line(view, view->pos.lineno - view->pos.offset);\n\t\twnoutrefresh(view->win);\n\t}\n\n\tview->has_scrolled = true;\n\treport_clear();\n}", "path": "tig/src/view.c", "commit_date": "2020-12-22 00:00:00", "repo_name": "jonas/tig", "stars": 12060, "license": "gpl-2.0", "language": "c", "size": 7544}
{"docstring": "/*\n * Path manipulation.\n */\n", "func_signal": "bool\npath_expand(char *dst, size_t dstlen, const char *src)", "code": "{\n\tif (!src)\n\t\treturn false;\n\n\tif (src[0] == '~') {\n\t\t/* constrain wordexp to tilde expansion only */\n\t\tconst char *ifs = getenv(\"IFS\") ? getenv(\"IFS\") : \" \\t\\n\";\n\t\twordexp_t we_result;\n\t\tsize_t metachar_pos;\n\t\tchar metachars[SIZEOF_STR];\n\t\tchar leading[SIZEOF_STR];\n\n\t\tstring_format(metachars, \"%s%s\", \"/$|&;<>(){}`\", ifs);\n\t\tmetachar_pos = strcspn(src, metachars);\n\t\tif (src[metachar_pos] == '/' || src[metachar_pos] == 0) {\n\t\t\tstring_nformat(leading, metachar_pos + 1, NULL, \"%s\", src);\n\t\t\tif (wordexp(leading, &we_result, WRDE_NOCMD))\n\t\t\t\treturn false;\n\t\t\tstring_nformat(dst, dstlen, NULL, \"%s%s\", we_result.we_wordv[0], src + metachar_pos);\n\t\t\twordfree(&we_result);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* else */\n\tstring_ncopy_do(dst, dstlen, src, strlen(src));\n\treturn true;\n}", "path": "tig/src/io.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "jonas/tig", "stars": 12060, "license": "gpl-2.0", "language": "c", "size": 7544}
{"docstring": "/*\n * Incremental updating\n */\n", "func_signal": "void\nreset_view(struct view *view)", "code": "{\n\tint i;\n\n\tfor (i = 0; i < view->lines; i++)\n\t\tfree(view->line[i].data);\n\tfree(view->line);\n\n\treset_search(view);\n\tview->prev_pos = view->pos;\n\t/* A view without a previous view is the first view */\n\tif (!view->prev && !view->lines && view->prev_pos.lineno == 0)\n\t\tview->prev_pos.lineno = view->env->goto_lineno;\n\tclear_position(&view->pos);\n\n\tif (view->columns)\n\t\tview_column_reset(view);\n\n\tview->line = NULL;\n\tview->lines  = 0;\n\tview->vid[0] = 0;\n\tview->custom_lines = 0;\n\tview->update_secs = 0;\n}", "path": "tig/src/view.c", "commit_date": "2020-12-22 00:00:00", "repo_name": "jonas/tig", "stars": 12060, "license": "gpl-2.0", "language": "c", "size": 7544}
{"docstring": "/*\n * Executing external commands.\n */\n", "func_signal": "static void\nio_init(struct io *io)", "code": "{\n\tmemset(io, 0, sizeof(*io));\n\tio->pipe = -1;\n}", "path": "tig/src/io.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "jonas/tig", "stars": 12060, "license": "gpl-2.0", "language": "c", "size": 7544}
{"docstring": "/*\n * Revision graph\n */\n", "func_signal": "static inline enum line_type\nget_graph_color(int color_id)", "code": "{\n\tif (color_id == GRAPH_COMMIT_COLOR)\n\t\treturn LINE_GRAPH_COMMIT;\n\tassert(color_id < ARRAY_SIZE(palette_colors));\n\treturn palette_colors[color_id];\n}", "path": "tig/src/draw.c", "commit_date": "2020-12-22 00:00:00", "repo_name": "jonas/tig", "stars": 12060, "license": "gpl-2.0", "language": "c", "size": 7544}
{"docstring": "/*\n * View drawing.\n */\n", "func_signal": "static inline void\nset_view_attr(struct view *view, enum line_type type)", "code": "{\n\tif (!view->curline->selected && view->curtype != type) {\n\t\t(void) wattrset(view->win, get_view_attr(view, type));\n\t\twchgat(view->win, -1, 0, get_view_color(view, type), NULL);\n#if defined(NCURSES_VERSION_PATCH) && NCURSES_VERSION_PATCH < 20061217\n\t\ttouchwin(view->win);\n#endif\n\t\tview->curtype = type;\n\t}\n}", "path": "tig/src/draw.c", "commit_date": "2020-12-22 00:00:00", "repo_name": "jonas/tig", "stars": 12060, "license": "gpl-2.0", "language": "c", "size": 7544}
{"docstring": "/* HAVE_READLINE */\n", "func_signal": "static char *\nprompt_input(const char *prompt, struct input *input)", "code": "{\n\tenum input_status status = INPUT_OK;\n\tunsigned char chars_length[SIZEOF_STR];\n\tstruct key key;\n\tsize_t promptlen = strlen(prompt);\n\tint pos = 0, chars = 0;\n\tint last_buf_length = promptlen ? -1 : promptlen;\n\n\tinput->buf[0] = 0;\n\tinput->context[0] = 0;\n\n\tif (strlen(prompt) > 0)\n\t\tcurs_set(1);\n\n\twhile (status == INPUT_OK || status == INPUT_SKIP) {\n\t\tint buf_length = strlen(input->buf) + promptlen;\n\t\tint offset = pos || buf_length != last_buf_length ? pos + promptlen : -1;\n\n\t\tlast_buf_length = buf_length;\n\t\tif (offset >= 0)\n\t\t\tupdate_status_with_context(input->context, \"%s%.*s\", prompt, pos, input->buf);\n\t\telse\n\t\t\twmove(status_win, 0, buf_length);\n\n\t\tif (get_input(offset, &key) == OK) {\n\t\t\tint len = strlen(key.data.bytes);\n\n\t\t\tif (pos + len >= sizeof(input->buf)) {\n\t\t\t\treport(\"Input string too long\");\n\t\t\t\tcurs_set(0);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tstring_ncopy_do(input->buf + pos, sizeof(input->buf) - pos, key.data.bytes, len);\n\t\t\tpos += len;\n\t\t\tchars_length[chars++] = len;\n\t\t\tstatus = input->handler(input, &key);\n\t\t\tif (status != INPUT_OK) {\n\t\t\t\tpos -= len;\n\t\t\t\tchars--;\n\t\t\t} else {\n\t\t\t\tint changed_pos = strlen(input->buf);\n\n\t\t\t\tif (changed_pos != pos) {\n\t\t\t\t\tpos = changed_pos;\n\t\t\t\t\tchars_length[chars - 1] = changed_pos - (pos - len);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = input->handler(input, &key);\n\t\t\tif (status == INPUT_DELETE) {\n\t\t\t\tint len = chars_length[--chars];\n\n\t\t\t\tpos -= len;\n\t\t\t\tstatus = INPUT_OK;\n\t\t\t} else {\n\t\t\t\tint changed_pos = strlen(input->buf);\n\n\t\t\t\tif (changed_pos != pos) {\n\t\t\t\t\tpos = changed_pos;\n\t\t\t\t\tchars_length[chars++] = changed_pos - pos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinput->buf[pos] = 0;\n\t}\n\n\tcurs_set(0);\n\treport_clear();\n\n\tif (status == INPUT_CANCEL)\n\t\treturn NULL;\n\n\tinput->buf[pos++] = 0;\n\n\treturn input->buf;\n}", "path": "tig/src/prompt.c", "commit_date": "2020-04-04 00:00:00", "repo_name": "jonas/tig", "stars": 12060, "license": "gpl-2.0", "language": "c", "size": 7544}
{"docstring": "/*\n * Pager backend\n */\n", "func_signal": "bool\npager_get_column_data(struct view *view, const struct line *line, struct view_column_data *column_data)", "code": "{\n\tcolumn_data->text = box_text(line);\n\tcolumn_data->box = line->data;\n\treturn true;\n}", "path": "tig/src/pager.c", "commit_date": "2020-12-22 00:00:00", "repo_name": "jonas/tig", "stars": 12060, "license": "gpl-2.0", "language": "c", "size": 7544}
{"docstring": "/*\n * Git index utils.\n */\n", "func_signal": "bool\nupdate_index(void)", "code": "{\n\tconst char *update_index_argv[] = {\n\t\t\"git\", \"update-index\", \"-q\", \"--unmerged\", \"--refresh\", NULL\n\t};\n\n\treturn io_run_bg(update_index_argv, repo.exec_dir);\n}", "path": "tig/src/repo.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "jonas/tig", "stars": 12060, "license": "gpl-2.0", "language": "c", "size": 7544}
{"docstring": "/*\n * Navigation\n */\n", "func_signal": "bool\ngoto_view_line(struct view *view, unsigned long offset, unsigned long lineno)", "code": "{\n\tif (lineno >= view->lines)\n\t\tlineno = view->lines > 0 ? view->lines - 1 : 0;\n\n\tif (offset > lineno || offset + view->height <= lineno) {\n\t\tunsigned long half = view->height / 2;\n\n\t\tif (lineno > half)\n\t\t\toffset = lineno - half;\n\t\telse\n\t\t\toffset = 0;\n\t}\n\n\tif (offset != view->pos.offset || lineno != view->pos.lineno) {\n\t\tview->pos.offset = offset;\n\t\tview->pos.lineno = lineno;\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "path": "tig/src/view.c", "commit_date": "2020-12-22 00:00:00", "repo_name": "jonas/tig", "stars": 12060, "license": "gpl-2.0", "language": "c", "size": 7544}
{"docstring": "/*\n * User request switch noodle\n */\n", "func_signal": "static bool\nview_driver(struct view *view, enum request request)", "code": "{\n\tint i;\n\n\tif (request == REQ_NONE)\n\t\treturn true;\n\n\tif (request >= REQ_RUN_REQUESTS) {\n\t\trequest = open_run_request(view, request);\n\n\t\t// exit quickly rather than going through view_request and back\n\t\tif (request == REQ_QUIT)\n\t\t\treturn false;\n\t}\n\n\trequest = view_request(view, request);\n\tif (request == REQ_NONE)\n\t\treturn true;\n\n\tswitch (request) {\n\tcase REQ_MOVE_UP:\n\tcase REQ_MOVE_DOWN:\n\tcase REQ_MOVE_PAGE_UP:\n\tcase REQ_MOVE_PAGE_DOWN:\n\tcase REQ_MOVE_HALF_PAGE_UP:\n\tcase REQ_MOVE_HALF_PAGE_DOWN:\n\tcase REQ_MOVE_FIRST_LINE:\n\tcase REQ_MOVE_LAST_LINE:\n\tcase REQ_MOVE_WHEEL_DOWN:\n\tcase REQ_MOVE_WHEEL_UP:\n\t\tmove_view(view, request);\n\t\tbreak;\n\n\tcase REQ_SCROLL_FIRST_COL:\n\tcase REQ_SCROLL_LEFT:\n\tcase REQ_SCROLL_RIGHT:\n\tcase REQ_SCROLL_LINE_DOWN:\n\tcase REQ_SCROLL_LINE_UP:\n\tcase REQ_SCROLL_PAGE_DOWN:\n\tcase REQ_SCROLL_PAGE_UP:\n\tcase REQ_SCROLL_WHEEL_DOWN:\n\tcase REQ_SCROLL_WHEEL_UP:\n\t\tscroll_view(view, request);\n\t\tbreak;\n\n\tcase REQ_VIEW_GREP:\n\t\topen_grep_view(view);\n\t\tbreak;\n\n\tcase REQ_VIEW_MAIN:\n\t\topen_main_view(view, OPEN_DEFAULT);\n\t\tbreak;\n\tcase REQ_VIEW_DIFF:\n\t\tif (view && string_rev_is_null(view->env->commit))\n\t\t\topen_stage_view(view, NULL, 0, OPEN_DEFAULT);\n\t\telse\n\t\t\topen_diff_view(view, OPEN_DEFAULT);\n\t\tbreak;\n\tcase REQ_VIEW_LOG:\n\t\topen_log_view(view, OPEN_DEFAULT);\n\t\tbreak;\n\tcase REQ_VIEW_REFLOG:\n\t\topen_reflog_view(view, OPEN_DEFAULT);\n\t\tbreak;\n\tcase REQ_VIEW_TREE:\n\t\topen_tree_view(view, OPEN_DEFAULT);\n\t\tbreak;\n\tcase REQ_VIEW_HELP:\n\t\topen_help_view(view, OPEN_DEFAULT);\n\t\tbreak;\n\tcase REQ_VIEW_REFS:\n\t\topen_refs_view(view, OPEN_DEFAULT);\n\t\tbreak;\n\tcase REQ_VIEW_BLAME:\n\t\topen_blame_view(view, OPEN_DEFAULT);\n\t\tbreak;\n\tcase REQ_VIEW_BLOB:\n\t\topen_blob_view(view, OPEN_DEFAULT);\n\t\tbreak;\n\tcase REQ_VIEW_STATUS:\n\t\topen_status_view(view, false, OPEN_DEFAULT);\n\t\tbreak;\n\tcase REQ_VIEW_STAGE:\n\t\topen_stage_view(view, NULL, 0, OPEN_DEFAULT);\n\t\tbreak;\n\tcase REQ_VIEW_PAGER:\n\t\topen_pager_view(view, OPEN_DEFAULT);\n\t\tbreak;\n\tcase REQ_VIEW_STASH:\n\t\topen_stash_view(view, OPEN_DEFAULT);\n\t\tbreak;\n\n\tcase REQ_NEXT:\n\tcase REQ_PREVIOUS:\n\t\tif (view->parent) {\n\t\t\tint line;\n\n\t\t\tview = view->parent;\n\t\t\tline = view->pos.lineno;\n\t\t\tview_request(view, request);\n\t\t\tmove_view(view, request);\n\t\t\tif (view_is_displayed(view))\n\t\t\t\tupdate_view_title(view);\n\t\t\tif (line != view->pos.lineno)\n\t\t\t\tview_request(view, REQ_ENTER);\n\t\t} else {\n\t\t\tmove_view(view, request);\n\t\t}\n\t\tbreak;\n\n\tcase REQ_VIEW_NEXT:\n\t{\n\t\tint nviews = displayed_views();\n\t\tint next_view = nviews ? (current_view + 1) % nviews : current_view;\n\n\t\tif (next_view == current_view) {\n\t\t\treport(\"Only one view is displayed\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcurrent_view = next_view;\n\t\t/* Blur out the title of the previous view. */\n\t\tupdate_view_title(view);\n\t\treport_clear();\n\t\tbreak;\n\t}\n\tcase REQ_REFRESH:\n\t\treport(\"Refreshing is not supported by the %s view\", view->name);\n\t\tbreak;\n\n\tcase REQ_PARENT:\n\t\treport(\"Moving to parent is not supported by the %s view\", view->name);\n\t\tbreak;\n\n\tcase REQ_BACK:\n\t\treport(\"Going back is not supported by the %s view\", view->name);\n\t\tbreak;\n\n\tcase REQ_MAXIMIZE:\n\t\tif (displayed_views() == 2)\n\t\t\tmaximize_view(view, true);\n\t\tbreak;\n\n\tcase REQ_OPTIONS:\n\t\ttoggle_option(view);\n\t\tbreak;\n\n\tcase REQ_SEARCH:\n\tcase REQ_SEARCH_BACK:\n\t\tsearch_view(view, request);\n\t\tbreak;\n\n\tcase REQ_FIND_NEXT:\n\tcase REQ_FIND_PREV:\n\t\tfind_next(view, request);\n\t\tbreak;\n\n\tcase REQ_MOVE_NEXT_MERGE:\n\tcase REQ_MOVE_PREV_MERGE:\n\t\treport(\"Moving between merge commits is not supported by the %s view\", view->name);\n\t\tbreak;\n\n\tcase REQ_STOP_LOADING:\n\t\tforeach_view(view, i) {\n\t\t\tif (view->pipe)\n\t\t\t\treport(\"Stopped loading the %s view\", view->name),\n\t\t\tend_update(view, true);\n\t\t\tif (view_is_displayed(view))\n\t\t\t\tupdate_view_title(view);\n\t\t}\n\t\tbreak;\n\n\tcase REQ_SHOW_VERSION:\n\t\treport(\"tig-%s\", TIG_VERSION);\n\t\treturn true;\n\n\tcase REQ_SCREEN_REDRAW:\n\t\tredraw_display(true);\n\t\tbreak;\n\n\tcase REQ_EDIT:\n\t\treport(\"Nothing to edit\");\n\t\tbreak;\n\n\tcase REQ_ENTER:\n\t\treport(\"Nothing to enter\");\n\t\tbreak;\n\n\tcase REQ_VIEW_CLOSE_NO_QUIT:\n\tcase REQ_VIEW_CLOSE:\n\t\t/* XXX: Mark closed views by letting view->prev point to the\n\t\t * view itself. Parents to closed view should never be\n\t\t * followed. */\n\t\tif (view->prev && view->prev != view) {\n\t\t\tmaximize_view(view->prev, true);\n\t\t\tview->prev = view;\n\t\t\tbreak;\n\t\t}\n\t\tif (request == REQ_VIEW_CLOSE_NO_QUIT) {\n\t\t\treport(\"Can't close last remaining view\");\n\t\t\tbreak;\n\t\t}\n\t\t/* Fall-through */\n\tcase REQ_QUIT:\n\t\treturn false;\n\n\tdefault:\n\t\treport(\"Unknown key, press %s for help\",\n\t\t       get_view_key(view, REQ_VIEW_HELP));\n\t\treturn true;\n\t}\n\n\treturn true;\n}", "path": "tig/src/tig.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "jonas/tig", "stars": 12060, "license": "gpl-2.0", "language": "c", "size": 7544}
{"docstring": "/* HAVE_READLINE */\n", "func_signal": "static bool\nforward_request_to_child(struct view *child, enum request request)", "code": "{\n\treturn displayed_views() == 2 && view_is_displayed(child) &&\n\t\t!strcmp(child->vid, child->ops->id);\n}", "path": "tig/src/tig.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "jonas/tig", "stars": 12060, "license": "gpl-2.0", "language": "c", "size": 7544}
{"docstring": "/* Cursor moving */\n", "func_signal": "void\nmove_view(struct view *view, enum request request)", "code": "{\n\tint scroll_steps = 0;\n\tint steps;\n\n\tswitch (request) {\n\tcase REQ_MOVE_FIRST_LINE:\n\t\tsteps = -view->pos.lineno;\n\t\tbreak;\n\n\tcase REQ_MOVE_LAST_LINE:\n\t\tsteps = view->lines - view->pos.lineno - 1;\n\t\tbreak;\n\n\tcase REQ_MOVE_PAGE_UP:\n\t\tsteps = view->height > view->pos.lineno\n\t\t      ? -view->pos.lineno : -view->height;\n\t\tbreak;\n\n\tcase REQ_MOVE_PAGE_DOWN:\n\t\tsteps = view->pos.lineno + view->height >= view->lines\n\t\t      ? view->lines - view->pos.lineno - 1 : view->height;\n\t\tbreak;\n\n\tcase REQ_MOVE_HALF_PAGE_UP:\n\t\tsteps = view->height / 2 > view->pos.lineno\n\t\t      ? -view->pos.lineno : -(view->height / 2);\n\t\tbreak;\n\n\tcase REQ_MOVE_HALF_PAGE_DOWN:\n\t\tsteps = view->pos.lineno + view->height / 2 >= view->lines\n\t\t      ? view->lines - view->pos.lineno - 1 : view->height / 2;\n\t\tbreak;\n\n\tcase REQ_MOVE_WHEEL_DOWN:\n\t\tsteps = opt_mouse_scroll;\n\t\tbreak;\n\n\tcase REQ_MOVE_WHEEL_UP:\n\t\tsteps = -opt_mouse_scroll;\n\t\tbreak;\n\n\tcase REQ_MOVE_UP:\n\tcase REQ_PREVIOUS:\n\t\tsteps = -1;\n\t\tbreak;\n\n\tcase REQ_MOVE_DOWN:\n\tcase REQ_NEXT:\n\t\tsteps = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tdie(\"request %d not handled in switch\", request);\n\t}\n\n\tif (steps <= 0 && view->pos.lineno == 0) {\n\t\treport(\"Cannot move beyond the first line\");\n\t\treturn;\n\n\t} else if (steps >= 0 && view->pos.lineno + 1 >= view->lines) {\n\t\treport(\"Cannot move beyond the last line\");\n\t\treturn;\n\t}\n\n\t/* Move the current line */\n\tview->pos.lineno += steps;\n\tassert(0 <= view->pos.lineno && view->pos.lineno < view->lines);\n\n\t/* Check whether the view needs to be scrolled */\n\tif (view->pos.lineno < view->pos.offset ||\n\t    view->pos.lineno >= view->pos.offset + view->height) {\n\t\tscroll_steps = steps;\n\t\tif (steps < 0 && -steps > view->pos.offset) {\n\t\t\tscroll_steps = -view->pos.offset;\n\n\t\t} else if (steps > 0) {\n\t\t\tif (view->pos.lineno == view->lines - 1 &&\n\t\t\t    view->lines > view->height) {\n\t\t\t\tscroll_steps = view->lines - view->pos.offset - 1;\n\t\t\t\tif (scroll_steps >= view->height)\n\t\t\t\t\tscroll_steps -= view->height - 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!view_is_displayed(view)) {\n\t\tview->pos.offset += scroll_steps;\n\t\tassert(0 <= view->pos.offset && view->pos.offset < view->lines);\n\t\tview->ops->select(view, &view->line[view->pos.lineno]);\n\t\treturn;\n\t}\n\n\t/* Repaint the old \"current\" line if we be scrolling */\n\tif (ABS(steps) < view->height)\n\t\tdraw_view_line(view, view->pos.lineno - steps - view->pos.offset);\n\n\tif (scroll_steps) {\n\t\tdo_scroll_view(view, scroll_steps);\n\t\treturn;\n\t}\n\n\t/* Draw the current line */\n\tdraw_view_line(view, view->pos.lineno - view->pos.offset);\n\n\twnoutrefresh(view->win);\n\treport_clear();\n}", "path": "tig/src/view.c", "commit_date": "2020-12-22 00:00:00", "repo_name": "jonas/tig", "stars": 12060, "license": "gpl-2.0", "language": "c", "size": 7544}
{"docstring": "/* MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS */\n", "func_signal": "static mz_bool tdefl_compress_block(tdefl_compressor *d, mz_bool static_block)", "code": "{\n    if (static_block)\n        tdefl_start_static_block(d);\n    else\n        tdefl_start_dynamic_block(d);\n    return tdefl_compress_lz_codes(d);\n}", "path": "react-native-code-push/windows/CodePush/miniz/miniz.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "microsoft/react-native-code-push", "stars": 8768, "license": "other", "language": "c", "size": 9153}
{"docstring": "/* Read bytes from the current file.\n   buf contain buffer where data must be copied\n   len the size of buf.\n\n   return the number of byte copied if some bytes are copied\n   return 0 if the end of file was reached\n   return <0 with error code if there is an error (UNZ_ERRNO for IO error, or zLib error for uncompress error) */\n", "func_signal": "extern int ZEXPORT unzReadCurrentFile(unzFile file, voidp buf, unsigned len)", "code": "{\n    int err = UNZ_OK;\n    uInt read = 0;\n    unz64_s *s;\n    file_in_zip64_read_info_s *pfile_in_zip_read_info;\n    if (file == NULL)\n        return UNZ_PARAMERROR;\n    s = (unz64_s *)file;\n    pfile_in_zip_read_info = s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info == NULL)\n        return UNZ_PARAMERROR;\n    if (pfile_in_zip_read_info->read_buffer == NULL)\n        return UNZ_END_OF_LIST_OF_FILE;\n    if (len == 0)\n        return 0;\n\n    pfile_in_zip_read_info->stream.next_out = (Bytef *)buf;\n    pfile_in_zip_read_info->stream.avail_out = (uInt)len;\n\n    if (pfile_in_zip_read_info->raw) {\n        if (len > pfile_in_zip_read_info->rest_read_compressed + pfile_in_zip_read_info->stream.avail_in)\n            pfile_in_zip_read_info->stream.avail_out = (uInt)pfile_in_zip_read_info->rest_read_compressed +\n                                                       pfile_in_zip_read_info->stream.avail_in;\n    } else {\n        \n        // NOTE:\n        // This bit of code seems to try to set the amount of space in the output buffer based on the\n        // value stored in the headers stored in the .zip file. However, if those values are incorrect\n        // it may result in a loss of data when uncompresssing that file. The compressed data is still\n        // legit and will deflate without knowing the uncompressed code so this tidbit is unnecessary and\n        // may cause issues for some .zip files.\n        //\n        // It's removed in here to fix those issues.\n        //\n        // See: https://github.com/ZipArchive/ziparchive/issues/16\n        //\n        \n        /*\n        \n         \n         FIXME: Upgrading to minizip 1.1 caused issues here, Uncommented the code that was commented before. 11/24/2015\n         */\n        \n        if (len > pfile_in_zip_read_info->rest_read_uncompressed)\n            pfile_in_zip_read_info->stream.avail_out = (uInt)pfile_in_zip_read_info->rest_read_uncompressed;\n        \n         \n    \n    }\n\n    while (pfile_in_zip_read_info->stream.avail_out > 0) {\n        if (pfile_in_zip_read_info->stream.avail_in == 0) {\n            uInt bytes_to_read = UNZ_BUFSIZE;\n            uInt bytes_not_read = 0;\n            uInt bytes_read = 0;\n            uInt total_bytes_read = 0;\n\n            if (pfile_in_zip_read_info->stream.next_in != NULL)\n                bytes_not_read = (uInt)(pfile_in_zip_read_info->read_buffer + UNZ_BUFSIZE -\n                                        pfile_in_zip_read_info->stream.next_in);\n            bytes_to_read -= bytes_not_read;\n            if (bytes_not_read > 0)\n                memcpy(pfile_in_zip_read_info->read_buffer, pfile_in_zip_read_info->stream.next_in, bytes_not_read);\n            if (pfile_in_zip_read_info->rest_read_compressed < bytes_to_read)\n                bytes_to_read = (uInt)pfile_in_zip_read_info->rest_read_compressed;\n\n            while (total_bytes_read != bytes_to_read) {\n                if (ZSEEK64(pfile_in_zip_read_info->z_filefunc, pfile_in_zip_read_info->filestream,\n                            pfile_in_zip_read_info->pos_in_zipfile + pfile_in_zip_read_info->byte_before_the_zipfile,\n                            ZLIB_FILEFUNC_SEEK_SET) != 0)\n                    return UNZ_ERRNO;\n\n                bytes_read = (int)ZREAD64(pfile_in_zip_read_info->z_filefunc, pfile_in_zip_read_info->filestream,\n                                          pfile_in_zip_read_info->read_buffer + bytes_not_read + total_bytes_read,\n                                          bytes_to_read - total_bytes_read);\n\n                total_bytes_read += bytes_read;\n                pfile_in_zip_read_info->pos_in_zipfile += bytes_read;\n\n                if (bytes_read == 0) {\n                    if (ZERROR64(pfile_in_zip_read_info->z_filefunc, pfile_in_zip_read_info->filestream))\n                        return UNZ_ERRNO;\n\n                    err = unzGoToNextDisk(file);\n                    if (err != UNZ_OK)\n                        return err;\n\n                    pfile_in_zip_read_info->pos_in_zipfile = 0;\n                    pfile_in_zip_read_info->filestream = s->filestream;\n                }\n            }\n\n#ifndef NOUNCRYPT\n            if ((s->cur_file_info.flag & 1) != 0) {\n#ifdef HAVE_AES\n                if (s->cur_file_info.compression_method == AES_METHOD) {\n                    fcrypt_decrypt(pfile_in_zip_read_info->read_buffer, bytes_to_read, &s->pfile_in_zip_read->aes_ctx);\n                } else\n#endif\n                {\n                    uInt i;\n                    for (i = 0; i < total_bytes_read; i++)\n                        pfile_in_zip_read_info->read_buffer[i] =\n                            zdecode(s->keys, s->pcrc_32_tab, pfile_in_zip_read_info->read_buffer[i]);\n                }\n            }\n#endif\n\n            pfile_in_zip_read_info->rest_read_compressed -= total_bytes_read;\n            pfile_in_zip_read_info->stream.next_in = (Bytef *)pfile_in_zip_read_info->read_buffer;\n            pfile_in_zip_read_info->stream.avail_in = (uInt)bytes_not_read + total_bytes_read;\n        }\n\n        if ((pfile_in_zip_read_info->compression_method == 0) || (pfile_in_zip_read_info->raw)) {\n            uInt copy, i;\n\n            if ((pfile_in_zip_read_info->stream.avail_in == 0) &&\n                (pfile_in_zip_read_info->rest_read_compressed == 0))\n                return (read == 0) ? UNZ_EOF : read;\n\n            if (pfile_in_zip_read_info->stream.avail_out < pfile_in_zip_read_info->stream.avail_in)\n                copy = pfile_in_zip_read_info->stream.avail_out;\n            else\n                copy = pfile_in_zip_read_info->stream.avail_in;\n\n            for (i = 0; i < copy; i++)\n                *(pfile_in_zip_read_info->stream.next_out + i) =\n                    *(pfile_in_zip_read_info->stream.next_in + i);\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + copy;\n            pfile_in_zip_read_info->rest_read_uncompressed -= copy;\n            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,\n                                                  pfile_in_zip_read_info->stream.next_out, copy);\n\n            pfile_in_zip_read_info->stream.avail_in -= copy;\n            pfile_in_zip_read_info->stream.avail_out -= copy;\n            pfile_in_zip_read_info->stream.next_out += copy;\n            pfile_in_zip_read_info->stream.next_in += copy;\n            pfile_in_zip_read_info->stream.total_out += copy;\n            read += copy;\n        } else if (pfile_in_zip_read_info->compression_method == Z_BZIP2ED) {\n#ifdef HAVE_BZIP2\n            uLong total_out_before, total_out_after;\n            const Bytef *buf_before;\n            uLong out_bytes;\n\n            pfile_in_zip_read_info->bstream.next_in = (char *)pfile_in_zip_read_info->stream.next_in;\n            pfile_in_zip_read_info->bstream.avail_in = pfile_in_zip_read_info->stream.avail_in;\n            pfile_in_zip_read_info->bstream.total_in_lo32 = pfile_in_zip_read_info->stream.total_in;\n            pfile_in_zip_read_info->bstream.total_in_hi32 = 0;\n            pfile_in_zip_read_info->bstream.next_out = (char *)pfile_in_zip_read_info->stream.next_out;\n            pfile_in_zip_read_info->bstream.avail_out = pfile_in_zip_read_info->stream.avail_out;\n            pfile_in_zip_read_info->bstream.total_out_lo32 = pfile_in_zip_read_info->stream.total_out;\n            pfile_in_zip_read_info->bstream.total_out_hi32 = 0;\n\n            total_out_before = pfile_in_zip_read_info->bstream.total_out_lo32;\n            buf_before = (const Bytef *)pfile_in_zip_read_info->bstream.next_out;\n\n            err = BZ2_bzDecompress(&pfile_in_zip_read_info->bstream);\n\n            total_out_after = pfile_in_zip_read_info->bstream.total_out_lo32;\n            out_bytes = total_out_after - total_out_before;\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + out_bytes;\n            pfile_in_zip_read_info->rest_read_uncompressed -= out_bytes;\n            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32, buf_before, (uInt)(out_bytes));\n\n            read += (uInt)(total_out_after - total_out_before);\n\n            pfile_in_zip_read_info->stream.next_in = (Bytef *)pfile_in_zip_read_info->bstream.next_in;\n            pfile_in_zip_read_info->stream.avail_in = pfile_in_zip_read_info->bstream.avail_in;\n            pfile_in_zip_read_info->stream.total_in = pfile_in_zip_read_info->bstream.total_in_lo32;\n            pfile_in_zip_read_info->stream.next_out = (Bytef *)pfile_in_zip_read_info->bstream.next_out;\n            pfile_in_zip_read_info->stream.avail_out = pfile_in_zip_read_info->bstream.avail_out;\n            pfile_in_zip_read_info->stream.total_out = pfile_in_zip_read_info->bstream.total_out_lo32;\n\n            if (err == BZ_STREAM_END)\n                return (read == 0) ? UNZ_EOF : read;\n            if (err != BZ_OK)\n                break;\n#endif\n        } else {\n            ZPOS64_T total_out_before, total_out_after;\n            const Bytef *buf_before;\n            ZPOS64_T out_bytes;\n            int flush = Z_SYNC_FLUSH;\n\n            total_out_before = pfile_in_zip_read_info->stream.total_out;\n            buf_before = pfile_in_zip_read_info->stream.next_out;\n\n            /*\n               if ((pfile_in_zip_read_info->rest_read_uncompressed ==\n                     pfile_in_zip_read_info->stream.avail_out) &&\n                (pfile_in_zip_read_info->rest_read_compressed == 0))\n                flush = Z_FINISH;\n             */\n            err = inflate(&pfile_in_zip_read_info->stream, flush);\n\n            if ((err >= 0) && (pfile_in_zip_read_info->stream.msg != NULL))\n                err = Z_DATA_ERROR;\n\n            total_out_after = pfile_in_zip_read_info->stream.total_out;\n            out_bytes = total_out_after - total_out_before;\n\n            pfile_in_zip_read_info->total_out_64 += out_bytes;\n            pfile_in_zip_read_info->rest_read_uncompressed -= out_bytes;\n            pfile_in_zip_read_info->crc32 =\n                crc32(pfile_in_zip_read_info->crc32, buf_before, (uInt)(out_bytes));\n\n            read += (uInt)(total_out_after - total_out_before);\n\n            if (err == Z_STREAM_END)\n                return (read == 0) ? UNZ_EOF : read;\n            if (err != Z_OK)\n                break;\n        }\n    }\n\n    if (err == Z_OK)\n        return read;\n    return err;\n}", "path": "react-native-code-push/ios/CodePush/SSZipArchive/minizip/unzip.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "microsoft/react-native-code-push", "stars": 8768, "license": "other", "language": "c", "size": 9153}
{"docstring": "/* #ifndef MINIZ_NO_STDIO */\n", "func_signal": "static MZ_FORCEINLINE const mz_uint8 *mz_zip_get_cdh(mz_zip_archive *pZip, mz_uint file_index)", "code": "{\n    if ((!pZip) || (!pZip->m_pState) || (file_index >= pZip->m_total_files))\n        return NULL;\n    return &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));\n}", "path": "react-native-code-push/windows/CodePush/miniz/miniz.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "microsoft/react-native-code-push", "stars": 8768, "license": "other", "language": "c", "size": 9153}
{"docstring": "/* tdefl_calculate_minimum_redundancy() originally written by: Alistair Moffat, alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996. */\n", "func_signal": "static void tdefl_calculate_minimum_redundancy(tdefl_sym_freq *A, int n)", "code": "{\n    int root, leaf, next, avbl, used, dpth;\n    if (n == 0)\n        return;\n    else if (n == 1)\n    {\n        A[0].m_key = 1;\n        return;\n    }\n    A[0].m_key += A[1].m_key;\n    root = 0;\n    leaf = 2;\n    for (next = 1; next < n - 1; next++)\n    {\n        if (leaf >= n || A[root].m_key < A[leaf].m_key)\n        {\n            A[next].m_key = A[root].m_key;\n            A[root++].m_key = (mz_uint16)next;\n        }\n        else\n            A[next].m_key = A[leaf++].m_key;\n        if (leaf >= n || (root < next && A[root].m_key < A[leaf].m_key))\n        {\n            A[next].m_key = (mz_uint16)(A[next].m_key + A[root].m_key);\n            A[root++].m_key = (mz_uint16)next;\n        }\n        else\n            A[next].m_key = (mz_uint16)(A[next].m_key + A[leaf++].m_key);\n    }\n    A[n - 2].m_key = 0;\n    for (next = n - 3; next >= 0; next--)\n        A[next].m_key = A[A[next].m_key].m_key + 1;\n    avbl = 1;\n    used = dpth = 0;\n    root = n - 2;\n    next = n - 1;\n    while (avbl > 0)\n    {\n        while (root >= 0 && (int)A[root].m_key == dpth)\n        {\n            used++;\n            root--;\n        }\n        while (avbl > used)\n        {\n            A[next--].m_key = (mz_uint16)(dpth);\n            avbl--;\n        }\n        avbl = 2 * used;\n        dpth++;\n        used = 0;\n    }\n}", "path": "react-native-code-push/windows/CodePush/miniz/miniz.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "microsoft/react-native-code-push", "stars": 8768, "license": "other", "language": "c", "size": 9153}
{"docstring": "/* #ifndef MINIZ_NO_STDIO */\n", "func_signal": "static mz_bool mz_zip_writer_update_zip64_extension_block(mz_zip_array *pNew_ext, mz_zip_archive *pZip, const mz_uint8 *pExt, uint32_t ext_len, mz_uint64 *pComp_size, mz_uint64 *pUncomp_size, mz_uint64 *pLocal_header_ofs, mz_uint32 *pDisk_start)", "code": "{\n    /* + 64 should be enough for any new zip64 data */\n    if (!mz_zip_array_reserve(pZip, pNew_ext, ext_len + 64, MZ_FALSE))\n        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);\n\n    mz_zip_array_resize(pZip, pNew_ext, 0, MZ_FALSE);\n\n    if ((pUncomp_size) || (pComp_size) || (pLocal_header_ofs) || (pDisk_start))\n    {\n        mz_uint8 new_ext_block[64];\n        mz_uint8 *pDst = new_ext_block;\n        mz_write_le16(pDst, MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID);\n        mz_write_le16(pDst + sizeof(mz_uint16), 0);\n        pDst += sizeof(mz_uint16) * 2;\n\n        if (pUncomp_size)\n        {\n            mz_write_le64(pDst, *pUncomp_size);\n            pDst += sizeof(mz_uint64);\n        }\n\n        if (pComp_size)\n        {\n            mz_write_le64(pDst, *pComp_size);\n            pDst += sizeof(mz_uint64);\n        }\n\n        if (pLocal_header_ofs)\n        {\n            mz_write_le64(pDst, *pLocal_header_ofs);\n            pDst += sizeof(mz_uint64);\n        }\n\n        if (pDisk_start)\n        {\n            mz_write_le32(pDst, *pDisk_start);\n            pDst += sizeof(mz_uint32);\n        }\n\n        mz_write_le16(new_ext_block + sizeof(mz_uint16), (mz_uint16)((pDst - new_ext_block) - sizeof(mz_uint16) * 2));\n\n        if (!mz_zip_array_push_back(pZip, pNew_ext, new_ext_block, pDst - new_ext_block))\n            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);\n    }\n\n    if ((pExt) && (ext_len))\n    {\n        mz_uint32 extra_size_remaining = ext_len;\n        const mz_uint8 *pExtra_data = pExt;\n\n        do\n        {\n            mz_uint32 field_id, field_data_size, field_total_size;\n\n            if (extra_size_remaining < (sizeof(mz_uint16) * 2))\n                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);\n\n            field_id = MZ_READ_LE16(pExtra_data);\n            field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));\n            field_total_size = field_data_size + sizeof(mz_uint16) * 2;\n\n            if (field_total_size > extra_size_remaining)\n                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);\n\n            if (field_id != MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)\n            {\n                if (!mz_zip_array_push_back(pZip, pNew_ext, pExtra_data, field_total_size))\n                    return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);\n            }\n\n            pExtra_data += field_total_size;\n            extra_size_remaining -= field_total_size;\n        } while (extra_size_remaining);\n    }\n\n    return MZ_TRUE;\n}", "path": "react-native-code-push/windows/CodePush/miniz/miniz.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "microsoft/react-native-code-push", "stars": 8768, "license": "other", "language": "c", "size": 9153}
{"docstring": "/* TODO: This func is now pretty freakin complex due to zip64, split it up? */\n", "func_signal": "mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint src_file_index)", "code": "{\n    mz_uint n, bit_flags, num_alignment_padding_bytes, src_central_dir_following_data_size;\n    mz_uint64 src_archive_bytes_remaining, local_dir_header_ofs;\n    mz_uint64 cur_src_file_ofs, cur_dst_file_ofs;\n    mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];\n    mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;\n    mz_uint8 new_central_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];\n    size_t orig_central_dir_size;\n    mz_zip_internal_state *pState;\n    void *pBuf;\n    const mz_uint8 *pSrc_central_header;\n    mz_zip_archive_file_stat src_file_stat;\n    mz_uint32 src_filename_len, src_comment_len, src_ext_len;\n    mz_uint32 local_header_filename_size, local_header_extra_len;\n    mz_uint64 local_header_comp_size, local_header_uncomp_size;\n    mz_bool found_zip64_ext_data_in_ldir = MZ_FALSE;\n\n    /* Sanity checks */\n    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pSource_zip->m_pRead))\n        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);\n\n    pState = pZip->m_pState;\n\n    /* Don't support copying files from zip64 archives to non-zip64, even though in some cases this is possible */\n    if ((pSource_zip->m_pState->m_zip64) && (!pZip->m_pState->m_zip64))\n        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);\n\n    /* Get pointer to the source central dir header and crack it */\n    if (NULL == (pSrc_central_header = mz_zip_get_cdh(pSource_zip, src_file_index)))\n        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);\n\n    if (MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_SIG_OFS) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG)\n        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);\n\n    src_filename_len = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_FILENAME_LEN_OFS);\n    src_comment_len = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_COMMENT_LEN_OFS);\n    src_ext_len = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS);\n    src_central_dir_following_data_size = src_filename_len + src_ext_len + src_comment_len;\n\n    /* TODO: We don't support central dir's >= MZ_UINT32_MAX bytes right now (+32 fudge factor in case we need to add more extra data) */\n    if ((pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_central_dir_following_data_size + 32) >= MZ_UINT32_MAX)\n        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);\n\n    num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);\n\n    if (!pState->m_zip64)\n    {\n        if (pZip->m_total_files == MZ_UINT16_MAX)\n            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);\n    }\n    else\n    {\n        /* TODO: Our zip64 support still has some 32-bit limits that may not be worth fixing. */\n        if (pZip->m_total_files == MZ_UINT32_MAX)\n            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);\n    }\n\n    if (!mz_zip_file_stat_internal(pSource_zip, src_file_index, pSrc_central_header, &src_file_stat, NULL))\n        return MZ_FALSE;\n\n    cur_src_file_ofs = src_file_stat.m_local_header_ofs;\n    cur_dst_file_ofs = pZip->m_archive_size;\n\n    /* Read the source archive's local dir header */\n    if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)\n        return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);\n\n    if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)\n        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);\n\n    cur_src_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;\n\n    /* Compute the total size we need to copy (filename+extra data+compressed data) */\n    local_header_filename_size = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS);\n    local_header_extra_len = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);\n    local_header_comp_size = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS);\n    local_header_uncomp_size = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS);\n    src_archive_bytes_remaining = local_header_filename_size + local_header_extra_len + src_file_stat.m_comp_size;\n\n    /* Try to find a zip64 extended information field */\n    if ((local_header_extra_len) && ((local_header_comp_size == MZ_UINT32_MAX) || (local_header_uncomp_size == MZ_UINT32_MAX)))\n    {\n        mz_zip_array file_data_array;\n        const mz_uint8 *pExtra_data;\n        mz_uint32 extra_size_remaining = local_header_extra_len;\n\n        mz_zip_array_init(&file_data_array, 1);\n        if (!mz_zip_array_resize(pZip, &file_data_array, local_header_extra_len, MZ_FALSE))\n        {\n            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);\n        }\n\n        if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, src_file_stat.m_local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + local_header_filename_size, file_data_array.m_p, local_header_extra_len) != local_header_extra_len)\n        {\n            mz_zip_array_clear(pZip, &file_data_array);\n            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);\n        }\n\n        pExtra_data = (const mz_uint8 *)file_data_array.m_p;\n\n        do\n        {\n            mz_uint32 field_id, field_data_size, field_total_size;\n\n            if (extra_size_remaining < (sizeof(mz_uint16) * 2))\n            {\n                mz_zip_array_clear(pZip, &file_data_array);\n                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);\n            }\n\n            field_id = MZ_READ_LE16(pExtra_data);\n            field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));\n            field_total_size = field_data_size + sizeof(mz_uint16) * 2;\n\n            if (field_total_size > extra_size_remaining)\n            {\n                mz_zip_array_clear(pZip, &file_data_array);\n                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);\n            }\n\n            if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)\n            {\n                const mz_uint8 *pSrc_field_data = pExtra_data + sizeof(mz_uint32);\n\n                if (field_data_size < sizeof(mz_uint64) * 2)\n                {\n                    mz_zip_array_clear(pZip, &file_data_array);\n                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);\n                }\n\n                local_header_uncomp_size = MZ_READ_LE64(pSrc_field_data);\n                local_header_comp_size = MZ_READ_LE64(pSrc_field_data + sizeof(mz_uint64)); /* may be 0 if there's a descriptor */\n\n                found_zip64_ext_data_in_ldir = MZ_TRUE;\n                break;\n            }\n\n            pExtra_data += field_total_size;\n            extra_size_remaining -= field_total_size;\n        } while (extra_size_remaining);\n\n        mz_zip_array_clear(pZip, &file_data_array);\n    }\n\n    if (!pState->m_zip64)\n    {\n        /* Try to detect if the new archive will most likely wind up too big and bail early (+(sizeof(mz_uint32) * 4) is for the optional descriptor which could be present, +64 is a fudge factor). */\n        /* We also check when the archive is finalized so this doesn't need to be perfect. */\n        mz_uint64 approx_new_archive_size = cur_dst_file_ofs + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + src_archive_bytes_remaining + (sizeof(mz_uint32) * 4) +\n                                            pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_central_dir_following_data_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE + 64;\n\n        if (approx_new_archive_size >= MZ_UINT32_MAX)\n            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);\n    }\n\n    /* Write dest archive padding */\n    if (!mz_zip_writer_write_zeros(pZip, cur_dst_file_ofs, num_alignment_padding_bytes))\n        return MZ_FALSE;\n\n    cur_dst_file_ofs += num_alignment_padding_bytes;\n\n    local_dir_header_ofs = cur_dst_file_ofs;\n    if (pZip->m_file_offset_alignment)\n    {\n        MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0);\n    }\n\n    /* The original zip's local header+ext block doesn't change, even with zip64, so we can just copy it over to the dest zip */\n    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)\n        return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);\n\n    cur_dst_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;\n\n    /* Copy over the source archive bytes to the dest archive, also ensure we have enough buf space to handle optional data descriptor */\n    if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)MZ_MAX(32U, MZ_MIN((mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE, src_archive_bytes_remaining)))))\n        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);\n\n    while (src_archive_bytes_remaining)\n    {\n        n = (mz_uint)MZ_MIN((mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE, src_archive_bytes_remaining);\n        if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, n) != n)\n        {\n            pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);\n        }\n        cur_src_file_ofs += n;\n\n        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n)\n        {\n            pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);\n        }\n        cur_dst_file_ofs += n;\n\n        src_archive_bytes_remaining -= n;\n    }\n\n    /* Now deal with the optional data descriptor */\n    bit_flags = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS);\n    if (bit_flags & 8)\n    {\n        /* Copy data descriptor */\n        if ((pSource_zip->m_pState->m_zip64) || (found_zip64_ext_data_in_ldir))\n        {\n            /* src is zip64, dest must be zip64 */\n\n            /* name\t\t\tuint32_t's */\n            /* id\t\t\t\t1 (optional in zip64?) */\n            /* crc\t\t\t1 */\n            /* comp_size\t2 */\n            /* uncomp_size 2 */\n            if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, (sizeof(mz_uint32) * 6)) != (sizeof(mz_uint32) * 6))\n            {\n                pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n                return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);\n            }\n\n            n = sizeof(mz_uint32) * ((MZ_READ_LE32(pBuf) == MZ_ZIP_DATA_DESCRIPTOR_ID) ? 6 : 5);\n        }\n        else\n        {\n            /* src is NOT zip64 */\n            mz_bool has_id;\n\n            if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, sizeof(mz_uint32) * 4) != sizeof(mz_uint32) * 4)\n            {\n                pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n                return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);\n            }\n\n            has_id = (MZ_READ_LE32(pBuf) == MZ_ZIP_DATA_DESCRIPTOR_ID);\n\n            if (pZip->m_pState->m_zip64)\n            {\n                /* dest is zip64, so upgrade the data descriptor */\n                const mz_uint32 *pSrc_descriptor = (const mz_uint32 *)((const mz_uint8 *)pBuf + (has_id ? sizeof(mz_uint32) : 0));\n                const mz_uint32 src_crc32 = pSrc_descriptor[0];\n                const mz_uint64 src_comp_size = pSrc_descriptor[1];\n                const mz_uint64 src_uncomp_size = pSrc_descriptor[2];\n\n                mz_write_le32((mz_uint8 *)pBuf, MZ_ZIP_DATA_DESCRIPTOR_ID);\n                mz_write_le32((mz_uint8 *)pBuf + sizeof(mz_uint32) * 1, src_crc32);\n                mz_write_le64((mz_uint8 *)pBuf + sizeof(mz_uint32) * 2, src_comp_size);\n                mz_write_le64((mz_uint8 *)pBuf + sizeof(mz_uint32) * 4, src_uncomp_size);\n\n                n = sizeof(mz_uint32) * 6;\n            }\n            else\n            {\n                /* dest is NOT zip64, just copy it as-is */\n                n = sizeof(mz_uint32) * (has_id ? 4 : 3);\n            }\n        }\n\n        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n)\n        {\n            pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);\n        }\n\n        cur_src_file_ofs += n;\n        cur_dst_file_ofs += n;\n    }\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n\n    /* Finally, add the new central dir header */\n    orig_central_dir_size = pState->m_central_dir.m_size;\n\n    memcpy(new_central_header, pSrc_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);\n\n    if (pState->m_zip64)\n    {\n        /* This is the painful part: We need to write a new central dir header + ext block with updated zip64 fields, and ensure the old fields (if any) are not included. */\n        const mz_uint8 *pSrc_ext = pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_filename_len;\n        mz_zip_array new_ext_block;\n\n        mz_zip_array_init(&new_ext_block, sizeof(mz_uint8));\n\n        MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, MZ_UINT32_MAX);\n        MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, MZ_UINT32_MAX);\n        MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS, MZ_UINT32_MAX);\n\n        if (!mz_zip_writer_update_zip64_extension_block(&new_ext_block, pZip, pSrc_ext, src_ext_len, &src_file_stat.m_comp_size, &src_file_stat.m_uncomp_size, &local_dir_header_ofs, NULL))\n        {\n            mz_zip_array_clear(pZip, &new_ext_block);\n            return MZ_FALSE;\n        }\n\n        MZ_WRITE_LE16(new_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS, new_ext_block.m_size);\n\n        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, new_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))\n        {\n            mz_zip_array_clear(pZip, &new_ext_block);\n            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);\n        }\n\n        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, src_filename_len))\n        {\n            mz_zip_array_clear(pZip, &new_ext_block);\n            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);\n            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);\n        }\n\n        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, new_ext_block.m_p, new_ext_block.m_size))\n        {\n            mz_zip_array_clear(pZip, &new_ext_block);\n            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);\n            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);\n        }\n\n        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_filename_len + src_ext_len, src_comment_len))\n        {\n            mz_zip_array_clear(pZip, &new_ext_block);\n            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);\n            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);\n        }\n\n        mz_zip_array_clear(pZip, &new_ext_block);\n    }\n    else\n    {\n        /* sanity checks */\n        if (cur_dst_file_ofs > MZ_UINT32_MAX)\n            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);\n\n        if (local_dir_header_ofs >= MZ_UINT32_MAX)\n            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);\n\n        MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_dir_header_ofs);\n\n        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, new_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))\n            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);\n\n        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, src_central_dir_following_data_size))\n        {\n            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);\n            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);\n        }\n    }\n\n    /* This shouldn't trigger unless we screwed up during the initial sanity checks */\n    if (pState->m_central_dir.m_size >= MZ_UINT32_MAX)\n    {\n        /* TODO: Support central dirs >= 32-bits in size */\n        mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);\n        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);\n    }\n\n    n = (mz_uint32)orig_central_dir_size;\n    if (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &n, 1))\n    {\n        mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);\n        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);\n    }\n\n    pZip->m_total_files++;\n    pZip->m_archive_size = cur_dst_file_ofs;\n\n    return MZ_TRUE;\n}", "path": "react-native-code-push/windows/CodePush/miniz/miniz.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "microsoft/react-native-code-push", "stars": 8768, "license": "other", "language": "c", "size": 9153}
{"docstring": "/* Get Info about the current file in the zipfile, with internal only info */\n", "func_signal": "local int unz64local_GetCurrentFileInfoInternal(unzFile file, unz_file_info64 *pfile_info,\n                                                unz_file_info64_internal *pfile_info_internal, char *filename, uLong filename_size, void *extrafield,\n                                                uLong extrafield_size, char *comment, uLong comment_size)", "code": "{\n    unz64_s *s;\n    unz_file_info64 file_info;\n    unz_file_info64_internal file_info_internal;\n    ZPOS64_T bytes_to_read;\n    int err = UNZ_OK;\n    uLong uMagic;\n    long lSeek = 0;\n    ZPOS64_T current_pos = 0;\n    uLong acc = 0;\n    uLong uL;\n    ZPOS64_T uL64;\n\n    if (file == NULL)\n        return UNZ_PARAMERROR;\n    s = (unz64_s *)file;\n\n    if (ZSEEK64(s->z_filefunc, s->filestream_with_CD,\n                s->pos_in_central_dir + s->byte_before_the_zipfile, ZLIB_FILEFUNC_SEEK_SET) != 0)\n        err = UNZ_ERRNO;\n\n    /* Check the magic */\n    if (err == UNZ_OK) {\n        if (unz64local_getLong(&s->z_filefunc, s->filestream_with_CD, &uMagic) != UNZ_OK)\n            err = UNZ_ERRNO;\n        else if (uMagic != CENTRALHEADERMAGIC)\n            err = UNZ_BADZIPFILE;\n    }\n\n    /* Read central directory header */\n    if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &file_info.version) != UNZ_OK)\n        err = UNZ_ERRNO;\n    if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &file_info.version_needed) != UNZ_OK)\n        err = UNZ_ERRNO;\n    if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &file_info.flag) != UNZ_OK)\n        err = UNZ_ERRNO;\n    if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &file_info.compression_method) != UNZ_OK)\n        err = UNZ_ERRNO;\n    if (unz64local_getLong(&s->z_filefunc, s->filestream_with_CD, &file_info.dosDate) != UNZ_OK)\n        err = UNZ_ERRNO;\n    unz64local_DosDateToTmuDate(file_info.dosDate, &file_info.tmu_date);\n    if (unz64local_getLong(&s->z_filefunc, s->filestream_with_CD, &file_info.crc) != UNZ_OK)\n        err = UNZ_ERRNO;\n    if (unz64local_getLong(&s->z_filefunc, s->filestream_with_CD, &uL) != UNZ_OK)\n        err = UNZ_ERRNO;\n    file_info.compressed_size = uL;\n    if (unz64local_getLong(&s->z_filefunc, s->filestream_with_CD, &uL) != UNZ_OK)\n        err = UNZ_ERRNO;\n    file_info.uncompressed_size = uL;\n    if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &file_info.size_filename) != UNZ_OK)\n        err = UNZ_ERRNO;\n    if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &file_info.size_file_extra) != UNZ_OK)\n        err = UNZ_ERRNO;\n    if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &file_info.size_file_comment) != UNZ_OK)\n        err = UNZ_ERRNO;\n    if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &file_info.disk_num_start) != UNZ_OK)\n        err = UNZ_ERRNO;\n    if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &file_info.internal_fa) != UNZ_OK)\n        err = UNZ_ERRNO;\n    if (unz64local_getLong(&s->z_filefunc, s->filestream_with_CD, &file_info.external_fa) != UNZ_OK)\n        err = UNZ_ERRNO;\n    /* Relative offset of local header */\n    if (unz64local_getLong(&s->z_filefunc, s->filestream_with_CD, &uL) != UNZ_OK)\n        err = UNZ_ERRNO;\n\n    file_info.size_file_extra_internal = 0;\n    file_info.disk_offset = uL;\n    file_info_internal.offset_curfile = uL;\n#ifdef HAVE_AES\n    file_info_internal.aes_compression_method = 0;\n    file_info_internal.aes_encryption_mode = 0;\n    file_info_internal.aes_version = 0;\n#endif\n\n    lSeek += file_info.size_filename;\n\n    if ((err == UNZ_OK) && (filename != NULL)) {\n        if (file_info.size_filename < filename_size) {\n            *(filename + file_info.size_filename) = 0;\n            bytes_to_read = file_info.size_filename;\n        } else\n            bytes_to_read = filename_size;\n\n        if ((file_info.size_filename > 0) && (filename_size > 0))\n            if (ZREAD64(s->z_filefunc, s->filestream_with_CD, filename, (uLong)bytes_to_read) != bytes_to_read)\n                err = UNZ_ERRNO;\n        lSeek -= (uLong)bytes_to_read;\n    }\n\n    /* Read extrafield */\n    if ((err == UNZ_OK) && (extrafield != NULL)) {\n        if (file_info.size_file_extra < extrafield_size)\n            bytes_to_read = file_info.size_file_extra;\n        else\n            bytes_to_read = extrafield_size;\n\n        if (lSeek != 0) {\n            if (ZSEEK64(s->z_filefunc, s->filestream_with_CD, lSeek, ZLIB_FILEFUNC_SEEK_CUR) == 0)\n                lSeek = 0;\n            else\n                err = UNZ_ERRNO;\n        }\n\n        if ((file_info.size_file_extra > 0) && (extrafield_size > 0))\n            if (ZREAD64(s->z_filefunc, s->filestream_with_CD, extrafield, (uLong)bytes_to_read) != bytes_to_read)\n                err = UNZ_ERRNO;\n        lSeek += file_info.size_file_extra - (uLong)bytes_to_read;\n    } else\n        lSeek += file_info.size_file_extra;\n\n    if ((err == UNZ_OK) && (file_info.size_file_extra != 0)) {\n        if (lSeek != 0) {\n            if (ZSEEK64(s->z_filefunc, s->filestream_with_CD, lSeek, ZLIB_FILEFUNC_SEEK_CUR) == 0)\n                lSeek = 0;\n            else\n                err = UNZ_ERRNO;\n        }\n\n        /* We are going to parse the extra field so we need to move back */\n        current_pos = ZTELL64(s->z_filefunc, s->filestream_with_CD);\n        if (current_pos < file_info.size_file_extra)\n            err = UNZ_ERRNO;\n        current_pos -= file_info.size_file_extra;\n        if (ZSEEK64(s->z_filefunc, s->filestream_with_CD, current_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)\n            err = UNZ_ERRNO;\n\n        while ((err != UNZ_ERRNO) && (acc < file_info.size_file_extra)) {\n            uLong headerid;\n            uLong datasize;\n\n            if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &headerid) != UNZ_OK)\n                err = UNZ_ERRNO;\n            if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &datasize) != UNZ_OK)\n                err = UNZ_ERRNO;\n\n            /* ZIP64 extra fields */\n            if (headerid == 0x0001) {\n                /* Subtract size of ZIP64 field, since ZIP64 is handled internally */\n                file_info.size_file_extra_internal += 2 + 2 + datasize;\n\n                if (file_info.uncompressed_size == 0xffffffff) {\n                    if (unz64local_getLong64(&s->z_filefunc, s->filestream_with_CD, &file_info.uncompressed_size) != UNZ_OK)\n                        err = UNZ_ERRNO;\n                }\n                if (file_info.compressed_size == 0xffffffff) {\n                    if (unz64local_getLong64(&s->z_filefunc, s->filestream_with_CD, &file_info.compressed_size) != UNZ_OK)\n                        err = UNZ_ERRNO;\n                }\n                if (file_info_internal.offset_curfile == 0xffffffff) {\n                    /* Relative Header offset */\n                    if (unz64local_getLong64(&s->z_filefunc, s->filestream_with_CD, &uL64) != UNZ_OK)\n                        err = UNZ_ERRNO;\n                    file_info_internal.offset_curfile = uL64;\n                    file_info.disk_offset = uL64;\n                }\n                if (file_info.disk_num_start == 0xffffffff) {\n                    /* Disk Start Number */\n                    if (unz64local_getLong(&s->z_filefunc, s->filestream_with_CD, &file_info.disk_num_start) != UNZ_OK)\n                        err = UNZ_ERRNO;\n                }\n            }\n#ifdef HAVE_AES\n            /* AES header */\n            else if (headerid == 0x9901) {\n                /* Subtract size of AES field, since AES is handled internally */\n                file_info.size_file_extra_internal += 2 + 2 + datasize;\n\n                /* Verify version info */\n                if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &uL) != UNZ_OK)\n                    err = UNZ_ERRNO;\n                /* Support AE-1 and AE-2 */\n                if (uL != 1 && uL != 2)\n                    err = UNZ_ERRNO;\n                file_info_internal.aes_version = uL;\n                if (unz64local_getByte(&s->z_filefunc, s->filestream_with_CD, (int *)&uL) != UNZ_OK)\n                    err = UNZ_ERRNO;\n                if ((char)uL != 'A')\n                    err = UNZ_ERRNO;\n                if (unz64local_getByte(&s->z_filefunc, s->filestream_with_CD, (int *)&uL) != UNZ_OK)\n                    err = UNZ_ERRNO;\n                if ((char)uL != 'E')\n                    err = UNZ_ERRNO;\n                /* Get AES encryption strength and actual compression method */\n                if (unz64local_getByte(&s->z_filefunc, s->filestream_with_CD, (int *)&uL) != UNZ_OK)\n                    err = UNZ_ERRNO;\n                file_info_internal.aes_encryption_mode = uL;\n                if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &uL) != UNZ_OK)\n                    err = UNZ_ERRNO;\n                file_info_internal.aes_compression_method = uL;\n            }\n#endif\n            else {\n                if (ZSEEK64(s->z_filefunc, s->filestream_with_CD, datasize, ZLIB_FILEFUNC_SEEK_CUR) != 0)\n                    err = UNZ_ERRNO;\n            }\n\n            acc += 2 + 2 + datasize;\n        }\n    }\n\n    if (file_info.disk_num_start == s->gi.number_disk_with_CD)\n        file_info_internal.byte_before_the_zipfile = s->byte_before_the_zipfile;\n    else\n        file_info_internal.byte_before_the_zipfile = 0;\n\n    if ((err == UNZ_OK) && (comment != NULL)) {\n        if (file_info.size_file_comment < comment_size) {\n            *(comment + file_info.size_file_comment) = 0;\n            bytes_to_read = file_info.size_file_comment;\n        } else\n            bytes_to_read = comment_size;\n\n        if (lSeek != 0) {\n            if (ZSEEK64(s->z_filefunc, s->filestream_with_CD, lSeek, ZLIB_FILEFUNC_SEEK_CUR) != 0)\n                err = UNZ_ERRNO;\n        }\n\n        if ((file_info.size_file_comment > 0) && (comment_size > 0))\n            if (ZREAD64(s->z_filefunc, s->filestream_with_CD, comment, (uLong)bytes_to_read) != bytes_to_read)\n                err = UNZ_ERRNO;\n        lSeek += file_info.size_file_comment - (uLong)bytes_to_read;\n    } else\n        lSeek += file_info.size_file_comment;\n\n    if ((err == UNZ_OK) && (pfile_info != NULL))\n        *pfile_info = file_info;\n\n    if ((err == UNZ_OK) && (pfile_info_internal != NULL))\n        *pfile_info_internal = file_info_internal;\n\n    return err;\n}", "path": "react-native-code-push/ios/CodePush/SSZipArchive/minizip/unzip.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "microsoft/react-native-code-push", "stars": 8768, "license": "other", "language": "c", "size": 9153}
{"docstring": "/* perform 'in place' encryption and authentication */\n", "func_signal": "void fcrypt_encrypt(unsigned char data[], unsigned int data_len, fcrypt_ctx cx[1])", "code": "{\n    encr_data(data, data_len, cx);\n    hmac_sha_data(data, data_len, cx->auth_ctx);\n}", "path": "react-native-code-push/ios/CodePush/SSZipArchive/aes/fileenc.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "microsoft/react-native-code-push", "stars": 8768, "license": "other", "language": "c", "size": 9153}
{"docstring": "/* Note: Just because the archive is not zip64 doesn't necessarily mean it doesn't have Zip64 extended information extra field, argh. */\n", "func_signal": "mz_bool mz_zip_is_zip64(mz_zip_archive *pZip)", "code": "{\n    if ((!pZip) || (!pZip->m_pState))\n        return MZ_FALSE;\n\n    return pZip->m_pState->m_zip64;\n}", "path": "react-native-code-push/windows/CodePush/miniz/miniz.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "microsoft/react-native-code-push", "stars": 8768, "license": "other", "language": "c", "size": 9153}
{"docstring": "/* refresh the output buffer and update the random pool by adding   */\n/* entropy and remixing                                             */\n", "func_signal": "static void update_pool(prng_ctx ctx[1])", "code": "{   unsigned int    i = 0;\n\n    /* transfer random pool data to the output buffer   */\n    memcpy(ctx->obuf, ctx->rbuf, PRNG_POOL_SIZE);\n\n    /* enter entropy data into the pool */\n    while(i < PRNG_POOL_SIZE)\n        i += ctx->entropy(ctx->rbuf + i, PRNG_POOL_SIZE - i);\n\n    /* invert and xor the original pool data into the pool  */\n    for(i = 0; i < PRNG_POOL_SIZE; ++i)\n        ctx->rbuf[i] ^= ~ctx->obuf[i];\n\n    /* mix the pool and the output buffer   */\n    prng_mix(ctx->rbuf);\n    prng_mix(ctx->obuf);\n}", "path": "react-native-code-push/ios/CodePush/SSZipArchive/aes/prng.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "microsoft/react-native-code-push", "stars": 8768, "license": "other", "language": "c", "size": 9153}
{"docstring": "/* Higher level helper functions. */\n", "func_signal": "void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)", "code": "{\n    tinfl_decompressor decomp;\n    void *pBuf = NULL, *pNew_buf;\n    size_t src_buf_ofs = 0, out_buf_capacity = 0;\n    *pOut_len = 0;\n    tinfl_init(&decomp);\n    for (;;)\n    {\n        size_t src_buf_size = src_buf_len - src_buf_ofs, dst_buf_size = out_buf_capacity - *pOut_len, new_out_buf_capacity;\n        tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8 *)pSrc_buf + src_buf_ofs, &src_buf_size, (mz_uint8 *)pBuf, pBuf ? (mz_uint8 *)pBuf + *pOut_len : NULL, &dst_buf_size,\n                                               (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);\n        if ((status < 0) || (status == TINFL_STATUS_NEEDS_MORE_INPUT))\n        {\n            MZ_FREE(pBuf);\n            *pOut_len = 0;\n            return NULL;\n        }\n        src_buf_ofs += src_buf_size;\n        *pOut_len += dst_buf_size;\n        if (status == TINFL_STATUS_DONE)\n            break;\n        new_out_buf_capacity = out_buf_capacity * 2;\n        if (new_out_buf_capacity < 128)\n            new_out_buf_capacity = 128;\n        pNew_buf = MZ_REALLOC(pBuf, new_out_buf_capacity);\n        if (!pNew_buf)\n        {\n            MZ_FREE(pBuf);\n            *pOut_len = 0;\n            return NULL;\n        }\n        pBuf = pNew_buf;\n        out_buf_capacity = new_out_buf_capacity;\n    }\n    return pBuf;\n}", "path": "react-native-code-push/windows/CodePush/miniz/miniz.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "microsoft/react-native-code-push", "stars": 8768, "license": "other", "language": "c", "size": 9153}
{"docstring": "/* Translate date/time from Dos format to tm_unz (readable more easily) */\n", "func_signal": "local void unz64local_DosDateToTmuDate(ZPOS64_T ulDosDate, tm_unz *ptm)", "code": "{\n    ZPOS64_T uDate = (ZPOS64_T)(ulDosDate >> 16);\n\n    ptm->tm_mday = (uInt)(uDate & 0x1f);\n    ptm->tm_mon = (uInt)((((uDate) & 0x1E0) / 0x20) - 1);\n    ptm->tm_year = (uInt)(((uDate & 0x0FE00) / 0x0200) + 1980);\n    ptm->tm_hour = (uInt)((ulDosDate & 0xF800) / 0x800);\n    ptm->tm_min = (uInt)((ulDosDate & 0x7E0) / 0x20);\n    ptm->tm_sec = (uInt)(2 * (ulDosDate & 0x1f));\n\n#define unz64local_in_range(min, max, value) ((min) <= (value) && (value) <= (max))\n    if (!unz64local_in_range(0, 11, ptm->tm_mon) ||\n        !unz64local_in_range(1, 31, ptm->tm_mday) ||\n        !unz64local_in_range(0, 23, ptm->tm_hour) ||\n        !unz64local_in_range(0, 59, ptm->tm_min) ||\n        !unz64local_in_range(0, 59, ptm->tm_sec))\n        /* Invalid date stored, so don't return it. */\n        memset(ptm, 0, sizeof(tm_unz));\n#undef unz64local_in_range\n}", "path": "react-native-code-push/ios/CodePush/SSZipArchive/minizip/unzip.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "microsoft/react-native-code-push", "stars": 8768, "license": "other", "language": "c", "size": 9153}
{"docstring": "/* perform 'in place' authentication and decryption */\n", "func_signal": "void fcrypt_decrypt(unsigned char data[], unsigned int data_len, fcrypt_ctx cx[1])", "code": "{\n    hmac_sha_data(data, data_len, cx->auth_ctx);\n    encr_data(data, data_len, cx);\n}", "path": "react-native-code-push/ios/CodePush/SSZipArchive/aes/fileenc.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "microsoft/react-native-code-push", "stars": 8768, "license": "other", "language": "c", "size": 9153}
{"docstring": "/* #ifndef MINIZ_NO_TIME */\n", "func_signal": "static MZ_FORCEINLINE mz_bool mz_zip_set_error(mz_zip_archive *pZip, mz_zip_error err_num)", "code": "{\n    if (pZip)\n        pZip->m_last_error = err_num;\n    return MZ_FALSE;\n}", "path": "react-native-code-push/windows/CodePush/miniz/miniz.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "microsoft/react-native-code-push", "stars": 8768, "license": "other", "language": "c", "size": 9153}
{"docstring": "/* #ifndef MINIZ_NO_STDIO */\n", "func_signal": "static size_t mz_zip_compute_crc32_callback(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)", "code": "{\n    mz_uint32 *p = (mz_uint32 *)pOpaque;\n    (void)file_ofs;\n    *p = (mz_uint32)mz_crc32(*p, (const mz_uint8 *)pBuf, n);\n    return n;\n}", "path": "react-native-code-push/windows/CodePush/miniz/miniz.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "microsoft/react-native-code-push", "stars": 8768, "license": "other", "language": "c", "size": 9153}
{"docstring": "/* Simple PNG writer function by Alex Evans, 2011. Released into the public domain: https://gist.github.com/908299, more context at\n http://altdevblogaday.org/2011/04/06/a-smaller-jpg-encoder/.\n This is actually a modification of Alex's original code so PNG files generated by this function pass pngcheck. */\n", "func_signal": "void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip)", "code": "{\n    /* Using a local copy of this array here in case MINIZ_NO_ZLIB_APIS was defined. */\n    static const mz_uint s_tdefl_png_num_probes[11] = { 0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500 };\n    tdefl_compressor *pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));\n    tdefl_output_buffer out_buf;\n    int i, bpl = w * num_chans, y, z;\n    mz_uint32 c;\n    *pLen_out = 0;\n    if (!pComp)\n        return NULL;\n    MZ_CLEAR_OBJ(out_buf);\n    out_buf.m_expandable = MZ_TRUE;\n    out_buf.m_capacity = 57 + MZ_MAX(64, (1 + bpl) * h);\n    if (NULL == (out_buf.m_pBuf = (mz_uint8 *)MZ_MALLOC(out_buf.m_capacity)))\n    {\n        MZ_FREE(pComp);\n        return NULL;\n    }\n    /* write dummy header */\n    for (z = 41; z; --z)\n        tdefl_output_buffer_putter(&z, 1, &out_buf);\n    /* compress image data */\n    tdefl_init(pComp, tdefl_output_buffer_putter, &out_buf, s_tdefl_png_num_probes[MZ_MIN(10, level)] | TDEFL_WRITE_ZLIB_HEADER);\n    for (y = 0; y < h; ++y)\n    {\n        tdefl_compress_buffer(pComp, &z, 1, TDEFL_NO_FLUSH);\n        tdefl_compress_buffer(pComp, (mz_uint8 *)pImage + (flip ? (h - 1 - y) : y) * bpl, bpl, TDEFL_NO_FLUSH);\n    }\n    if (tdefl_compress_buffer(pComp, NULL, 0, TDEFL_FINISH) != TDEFL_STATUS_DONE)\n    {\n        MZ_FREE(pComp);\n        MZ_FREE(out_buf.m_pBuf);\n        return NULL;\n    }\n    /* write real header */\n    *pLen_out = out_buf.m_size - 41;\n    {\n        static const mz_uint8 chans[] = { 0x00, 0x00, 0x04, 0x02, 0x06 };\n        mz_uint8 pnghdr[41] = { 0x89, 0x50, 0x4e, 0x47, 0x0d,\n                                0x0a, 0x1a, 0x0a, 0x00, 0x00,\n                                0x00, 0x0d, 0x49, 0x48, 0x44,\n                                0x52, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x00, 0x00, 0x08,\n                                0x00, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x49, 0x44, 0x41,\n                                0x54 };\n        pnghdr[18] = (mz_uint8)(w >> 8);\n        pnghdr[19] = (mz_uint8)w;\n        pnghdr[22] = (mz_uint8)(h >> 8);\n        pnghdr[23] = (mz_uint8)h;\n        pnghdr[25] = chans[num_chans];\n        pnghdr[33] = (mz_uint8)(*pLen_out >> 24);\n        pnghdr[34] = (mz_uint8)(*pLen_out >> 16);\n        pnghdr[35] = (mz_uint8)(*pLen_out >> 8);\n        pnghdr[36] = (mz_uint8)*pLen_out;\n        c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, pnghdr + 12, 17);\n        for (i = 0; i < 4; ++i, c <<= 8)\n            ((mz_uint8 *)(pnghdr + 29))[i] = (mz_uint8)(c >> 24);\n        memcpy(out_buf.m_pBuf, pnghdr, 41);\n    }\n    /* write footer (IDAT CRC-32, followed by IEND chunk) */\n    if (!tdefl_output_buffer_putter(\"\\0\\0\\0\\0\\0\\0\\0\\0\\x49\\x45\\x4e\\x44\\xae\\x42\\x60\\x82\", 16, &out_buf))\n    {\n        *pLen_out = 0;\n        MZ_FREE(pComp);\n        MZ_FREE(out_buf.m_pBuf);\n        return NULL;\n    }\n    c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, out_buf.m_pBuf + 41 - 4, *pLen_out + 4);\n    for (i = 0; i < 4; ++i, c <<= 8)\n        (out_buf.m_pBuf + out_buf.m_size - 16)[i] = (mz_uint8)(c >> 24);\n    /* compute final size of file, grab compressed data buffer and return */\n    *pLen_out += 57;\n    MZ_FREE(pComp);\n    return out_buf.m_pBuf;\n}", "path": "react-native-code-push/windows/CodePush/miniz/miniz.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "microsoft/react-native-code-push", "stars": 8768, "license": "other", "language": "c", "size": 9153}
{"docstring": "/* provide random bytes from the random data pool   */\n", "func_signal": "void prng_rand(unsigned char data[], unsigned int data_len, prng_ctx ctx[1])", "code": "{   unsigned char   *rp = data;\n    unsigned int    len, pos = ctx->pos;\n\n    while(data_len)\n    {\n        /* transfer 'data_len' bytes (or the number of bytes remaining  */\n        /* the pool output buffer if less) into the output              */\n        len = (data_len < PRNG_POOL_SIZE - pos ? data_len : PRNG_POOL_SIZE - pos);\n        memcpy(rp, ctx->obuf + pos, len);\n        rp += len;          /* update ouput buffer position pointer     */\n        pos += len;         /* update pool output buffer pointer        */\n        data_len -= len;    /* update the remaining data count          */\n\n        /* refresh the random pool if necessary */\n        if(pos == PRNG_POOL_SIZE)\n        {\n            update_pool(ctx); pos = 0;\n        }\n    }\n\n    ctx->pos = pos;\n}", "path": "react-native-code-push/ios/CodePush/SSZipArchive/aes/prng.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "microsoft/react-native-code-push", "stars": 8768, "license": "other", "language": "c", "size": 9153}
{"docstring": "/* Read a byte from a gz_stream; Return EOF for end of file. */\n", "func_signal": "local int unz64local_getByte(const zlib_filefunc64_32_def *pzlib_filefunc_def, voidpf filestream, int *pi)", "code": "{\n    unsigned char c;\n    int err = (int)ZREAD64(*pzlib_filefunc_def, filestream, &c, 1);\n    if (err == 1) {\n        *pi = (int)c;\n        return UNZ_OK;\n    }\n    if (ZERROR64(*pzlib_filefunc_def, filestream))\n        return UNZ_ERRNO;\n    return UNZ_EOF;\n}", "path": "react-native-code-push/ios/CodePush/SSZipArchive/minizip/unzip.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "microsoft/react-native-code-push", "stars": 8768, "license": "other", "language": "c", "size": 9153}
{"docstring": "/* MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN */\n", "func_signal": "static MZ_FORCEINLINE void tdefl_record_literal(tdefl_compressor *d, mz_uint8 lit)", "code": "{\n    d->m_total_lz_bytes++;\n    *d->m_pLZ_code_buf++ = lit;\n    *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> 1);\n    if (--d->m_num_flags_left == 0)\n    {\n        d->m_num_flags_left = 8;\n        d->m_pLZ_flags = d->m_pLZ_code_buf++;\n    }\n    d->m_huff_count[0][lit]++;\n}", "path": "react-native-code-push/windows/CodePush/miniz/miniz.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "microsoft/react-native-code-push", "stars": 8768, "license": "other", "language": "c", "size": 9153}
{"docstring": "/* SHA1 final padding and digest calculation  */\n", "func_signal": "VOID_RETURN sha1_end(unsigned char hval[], sha1_ctx ctx[1])", "code": "{   uint_32t    i = (uint_32t)(ctx->count[0] & SHA1_MASK);\n\n    /* put bytes in the buffer in an order in which references to   */\n    /* 32-bit words will put bytes with lower addresses into the    */\n    /* top of 32 bit words on BOTH big and little endian machines   */\n    bsw_32(ctx->wbuf, (i + 3) >> 2);\n\n    /* we now need to mask valid bytes and add the padding which is */\n    /* a single 1 bit and as many zero bits as necessary. Note that */\n    /* we can always add the first padding byte here because the    */\n    /* buffer always has at least one empty slot                    */\n    ctx->wbuf[i >> 2] &= 0xffffff80 << 8 * (~i & 3);\n    ctx->wbuf[i >> 2] |= 0x00000080 << 8 * (~i & 3);\n\n    /* we need 9 or more empty positions, one for the padding byte  */\n    /* (above) and eight for the length count. If there is not      */\n    /* enough space, pad and empty the buffer                       */\n    if(i > SHA1_BLOCK_SIZE - 9)\n    {\n        if(i < 60) ctx->wbuf[15] = 0;\n        sha1_compile(ctx);\n        i = 0;\n    }\n    else    /* compute a word index for the empty buffer positions  */\n        i = (i >> 2) + 1;\n\n    while(i < 14) /* and zero pad all but last two positions        */\n        ctx->wbuf[i++] = 0;\n\n    /* the following 32-bit length fields are assembled in the      */\n    /* wrong byte order on little endian machines but this is       */\n    /* corrected later since they are only ever used as 32-bit      */\n    /* word values.                                                 */\n    ctx->wbuf[14] = (ctx->count[1] << 3) | (ctx->count[0] >> 29);\n    ctx->wbuf[15] = ctx->count[0] << 3;\n    sha1_compile(ctx);\n\n    /* extract the hash value as bytes in case the hash buffer is   */\n    /* misaligned for 32-bit words                                  */\n    for(i = 0; i < SHA1_DIGEST_SIZE; ++i)\n        hval[i] = (unsigned char)(ctx->hash[i >> 2] >> (8 * (~i & 3)));\n}", "path": "react-native-code-push/ios/CodePush/SSZipArchive/aes/sha1.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "microsoft/react-native-code-push", "stars": 8768, "license": "other", "language": "c", "size": 9153}
{"docstring": "/* Copy the last line of the stdio output buffer to `buffer` */\n", "func_signal": "int process_read_last_line(process_info_t *p,\n                           char* buffer,\n                           size_t buffer_len)", "code": "{\n  char* ptr;\n\n  int r = fseek(p->stdout_file, 0, SEEK_SET);\n  if (r < 0) {\n    perror(\"fseek\");\n    return -1;\n  }\n\n  buffer[0] = '\\0';\n\n  while (fgets(buffer, buffer_len, p->stdout_file) != NULL) {\n    for (ptr = buffer; *ptr && *ptr != '\\r' && *ptr != '\\n'; ptr++)\n      ;\n    *ptr = '\\0';\n  }\n\n  if (ferror(p->stdout_file)) {\n    perror(\"read\");\n    buffer[0] = '\\0';\n    return -1;\n  }\n  return 0;\n}", "path": "libuv/test/runner-unix.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "libuv/libuv", "stars": 22970, "license": "mit", "language": "c", "size": 16102}
{"docstring": "/* Returns the number of bytes in the stdio output buffer for process `p`. */\n", "func_signal": "long int process_output_size(process_info_t *p)", "code": "{\n  /* Size of the p->stdout_file */\n  struct stat buf;\n\n  int r = fstat(fileno(p->stdout_file), &buf);\n  if (r < 0) {\n    return -1;\n  }\n\n  return (long)buf.st_size;\n}", "path": "libuv/test/runner-unix.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "libuv/libuv", "stars": 22970, "license": "mit", "language": "c", "size": 16102}
{"docstring": "/* On the BSDs, SO_REUSEPORT implies SO_REUSEADDR but with some additional\n * refinements for programs that use multicast.\n *\n * Linux as of 3.9 has a SO_REUSEPORT socket option but with semantics that\n * are different from the BSDs: it _shares_ the port rather than steal it\n * from the current listener.  While useful, it's not something we can emulate\n * on other platforms so we don't enable it.\n *\n * zOS does not support getsockname with SO_REUSEPORT option when using\n * AF_UNIX.\n */\n", "func_signal": "static int uv__set_reuse(int fd)", "code": "{\n  int yes;\n  yes = 1;\n\n#if defined(SO_REUSEPORT) && defined(__MVS__)\n  struct sockaddr_in sockfd;\n  unsigned int sockfd_len = sizeof(sockfd);\n  if (getsockname(fd, (struct sockaddr*) &sockfd, &sockfd_len) == -1)\n      return UV__ERR(errno);\n  if (sockfd.sin_family == AF_UNIX) {\n    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)))\n      return UV__ERR(errno);\n  } else {\n    if (setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &yes, sizeof(yes)))\n       return UV__ERR(errno);\n  }\n#elif defined(SO_REUSEPORT) && !defined(__linux__)\n  if (setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &yes, sizeof(yes)))\n    return UV__ERR(errno);\n#else\n  if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)))\n    return UV__ERR(errno);\n#endif\n\n  return 0;\n}", "path": "libuv/src/unix/udp.c", "commit_date": "2020-09-23 00:00:00", "repo_name": "libuv/libuv", "stars": 22970, "license": "mit", "language": "c", "size": 16102}
{"docstring": "/* !__linux__ */\n", "func_signal": "int uv__random_getrandom(void* buf, size_t buflen)", "code": "{\n  ssize_t n;\n  size_t pos;\n  int rc;\n\n  rc = uv__random_getrandom_init();\n  if (rc != 0)\n    return rc;\n\n  for (pos = 0; pos != buflen; pos += n) {\n    do {\n      n = buflen - pos;\n\n      /* Most getrandom() implementations promise that reads <= 256 bytes\n       * will always succeed and won't be interrupted by signals.\n       * It's therefore useful to split it up in smaller reads because\n       * one big read may, in theory, continuously fail with EINTR.\n       */\n      if (n > 256)\n        n = 256;\n\n      n = uv__getrandom((char *) buf + pos, n, 0);\n    } while (n == -1 && errno == EINTR);\n\n    if (n == -1)\n      return UV__ERR(errno);\n\n    if (n == 0)\n      return UV_EIO;\n  }\n\n  return 0;\n}", "path": "libuv/src/unix/random-getrandom.c", "commit_date": "2019-09-18 00:00:00", "repo_name": "libuv/libuv", "stars": 22970, "license": "mit", "language": "c", "size": 16102}
{"docstring": "/* Invoke \"argv[0] test-name [test-part]\". Store process info in *p. Make sure\n * that all stdio output of the processes is buffered up. */\n", "func_signal": "int process_start(char* name, char* part, process_info_t* p, int is_helper)", "code": "{\n  FILE* stdout_file;\n  int stdout_fd;\n  const char* arg;\n  char* args[16];\n  int pipefd[2];\n  char fdstr[8];\n  ssize_t rc;\n  int n;\n  pid_t pid;\n\n  arg = getenv(\"UV_USE_VALGRIND\");\n  n = 0;\n\n  /* Disable valgrind for helpers, it complains about helpers leaking memory.\n   * They're killed after the test and as such never get a chance to clean up.\n   */\n  if (is_helper == 0 && arg != NULL && atoi(arg) != 0) {\n    args[n++] = \"valgrind\";\n    args[n++] = \"--quiet\";\n    args[n++] = \"--leak-check=full\";\n    args[n++] = \"--show-reachable=yes\";\n    args[n++] = \"--error-exitcode=125\";\n  }\n\n  args[n++] = executable_path;\n  args[n++] = name;\n  args[n++] = part;\n  args[n++] = NULL;\n\n  stdout_file = tmpfile();\n  stdout_fd = fileno(stdout_file);\n  if (!stdout_file) {\n    perror(\"tmpfile\");\n    return -1;\n  }\n\n  if (is_helper) {\n    if (pipe(pipefd)) {\n      perror(\"pipe\");\n      return -1;\n    }\n\n    snprintf(fdstr, sizeof(fdstr), \"%d\", pipefd[1]);\n    if (setenv(\"UV_TEST_RUNNER_FD\", fdstr, /* overwrite */ 1)) {\n      perror(\"setenv\");\n      return -1;\n    }\n  }\n\n  p->terminated = 0;\n  p->status = 0;\n\n  pid = fork();\n\n  if (pid < 0) {\n    perror(\"fork\");\n    return -1;\n  }\n\n  if (pid == 0) {\n    /* child */\n    if (is_helper)\n      closefd(pipefd[0]);\n    dup2(stdout_fd, STDOUT_FILENO);\n    dup2(stdout_fd, STDERR_FILENO);\n    execve(args[0], args, environ);\n    perror(\"execve()\");\n    _exit(127);\n  }\n\n  /* parent */\n  p->pid = pid;\n  p->name = strdup(name);\n  p->stdout_file = stdout_file;\n\n  if (!is_helper)\n    return 0;\n\n  closefd(pipefd[1]);\n  unsetenv(\"UV_TEST_RUNNER_FD\");\n\n  do\n    rc = read(pipefd[0], &n, 1);\n  while (rc == -1 && errno == EINTR);\n\n  closefd(pipefd[0]);\n\n  if (rc == -1) {\n    perror(\"read\");\n    return -1;\n  }\n\n  if (rc > 0) {\n    fprintf(stderr, \"EOF expected but got data.\\n\");\n    return -1;\n  }\n\n  return 0;\n}", "path": "libuv/test/runner-unix.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "libuv/libuv", "stars": 22970, "license": "mit", "language": "c", "size": 16102}
{"docstring": "/* Wait for all `n` processes in `vec` to terminate. Time out after `timeout`\n * msec, or never if timeout == -1. Return 0 if all processes are terminated,\n * -1 on error, -2 on timeout. */\n", "func_signal": "int process_wait(process_info_t* vec, int n, int timeout)", "code": "{\n  int i;\n  int r;\n  int retval;\n  process_info_t* p;\n  dowait_args args;\n  pthread_t tid;\n  pthread_attr_t attr;\n  unsigned int elapsed_ms;\n  struct timeval timebase;\n  struct timeval tv;\n  fd_set fds;\n\n  args.vec = vec;\n  args.n = n;\n  args.pipe[0] = -1;\n  args.pipe[1] = -1;\n\n  /* The simple case is where there is no timeout */\n  if (timeout == -1) {\n    dowait(&args);\n    return 0;\n  }\n\n  /* Hard case. Do the wait with a timeout.\n   *\n   * Assumption: we are the only ones making this call right now. Otherwise\n   * we'd need to lock vec.\n   */\n\n  r = pipe((int*)&(args.pipe));\n  if (r) {\n    perror(\"pipe()\");\n    return -1;\n  }\n\n  if (pthread_attr_init(&attr))\n    abort();\n\n#if defined(__MVS__)\n  if (pthread_attr_setstacksize(&attr, 1024 * 1024))\n#else\n  if (pthread_attr_setstacksize(&attr, 256 * 1024))\n#endif\n    abort();\n\n  r = pthread_create(&tid, &attr, dowait, &args);\n\n  if (pthread_attr_destroy(&attr))\n    abort();\n\n  if (r) {\n    perror(\"pthread_create()\");\n    retval = -1;\n    goto terminate;\n  }\n\n  if (gettimeofday(&timebase, NULL))\n    abort();\n\n  tv = timebase;\n  for (;;) {\n    /* Check that gettimeofday() doesn't jump back in time. */\n    assert(tv.tv_sec > timebase.tv_sec ||\n           (tv.tv_sec == timebase.tv_sec && tv.tv_usec >= timebase.tv_usec));\n\n    elapsed_ms =\n        (tv.tv_sec - timebase.tv_sec) * 1000 +\n        (tv.tv_usec / 1000) -\n        (timebase.tv_usec / 1000);\n\n    r = 0;  /* Timeout. */\n    if (elapsed_ms >= (unsigned) timeout)\n      break;\n\n    tv.tv_sec = (timeout - elapsed_ms) / 1000;\n    tv.tv_usec = (timeout - elapsed_ms) % 1000 * 1000;\n\n    FD_ZERO(&fds);\n    FD_SET(args.pipe[0], &fds);\n\n    r = select(args.pipe[0] + 1, &fds, NULL, NULL, &tv);\n    if (!(r == -1 && errno == EINTR))\n      break;\n\n    if (gettimeofday(&tv, NULL))\n      abort();\n  }\n\n  if (r == -1) {\n    perror(\"select()\");\n    retval = -1;\n\n  } else if (r) {\n    /* The thread completed successfully. */\n    retval = 0;\n\n  } else {\n    /* Timeout. Kill all the children. */\n    for (i = 0; i < n; i++) {\n      p = (process_info_t*)(vec + i * sizeof(process_info_t));\n      kill(p->pid, SIGTERM);\n    }\n    retval = -2;\n  }\n\n  if (pthread_join(tid, NULL))\n    abort();\n\nterminate:\n  close(args.pipe[0]);\n  close(args.pipe[1]);\n  return retval;\n}", "path": "libuv/test/runner-unix.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "libuv/libuv", "stars": 22970, "license": "mit", "language": "c", "size": 16102}
{"docstring": "/* Copy the contents of the stdio output buffer to `fd`. */\n", "func_signal": "int process_copy_output(process_info_t* p, FILE* stream)", "code": "{\n  char buf[1024];\n  int r;\n\n  r = fseek(p->stdout_file, 0, SEEK_SET);\n  if (r < 0) {\n    perror(\"fseek\");\n    return -1;\n  }\n\n  /* TODO: what if the line is longer than buf */\n  while ((r = fread(buf, 1, sizeof(buf), p->stdout_file)) != 0)\n    print_lines(buf, r, stream);\n\n  if (ferror(p->stdout_file)) {\n    perror(\"read\");\n    return -1;\n  }\n\n  return 0;\n}", "path": "libuv/test/runner-unix.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "libuv/libuv", "stars": 22970, "license": "mit", "language": "c", "size": 16102}
{"docstring": "/* Clean up after terminating process `p` (e.g. free the output buffer etc.). */\n", "func_signal": "void process_cleanup(process_info_t *p)", "code": "{\n  fclose(p->stdout_file);\n  free(p->name);\n}", "path": "libuv/test/runner-unix.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "libuv/libuv", "stars": 22970, "license": "mit", "language": "c", "size": 16102}
{"docstring": "/* To avoid deadlock with uv_cancel() it's crucial that the worker\n * never holds the global mutex and the loop-local mutex at the same time.\n */\n", "func_signal": "static void worker(void* arg)", "code": "{\n  struct uv__work* w;\n  QUEUE* q;\n  int is_slow_work;\n\n  uv_sem_post((uv_sem_t*) arg);\n  arg = NULL;\n\n  uv_mutex_lock(&mutex);\n  for (;;) {\n    /* `mutex` should always be locked at this point. */\n\n    /* Keep waiting while either no work is present or only slow I/O\n       and we're at the threshold for that. */\n    while (QUEUE_EMPTY(&wq) ||\n           (QUEUE_HEAD(&wq) == &run_slow_work_message &&\n            QUEUE_NEXT(&run_slow_work_message) == &wq &&\n            slow_io_work_running >= slow_work_thread_threshold())) {\n      idle_threads += 1;\n      uv_cond_wait(&cond, &mutex);\n      idle_threads -= 1;\n    }\n\n    q = QUEUE_HEAD(&wq);\n    if (q == &exit_message) {\n      uv_cond_signal(&cond);\n      uv_mutex_unlock(&mutex);\n      break;\n    }\n\n    QUEUE_REMOVE(q);\n    QUEUE_INIT(q);  /* Signal uv_cancel() that the work req is executing. */\n\n    is_slow_work = 0;\n    if (q == &run_slow_work_message) {\n      /* If we're at the slow I/O threshold, re-schedule until after all\n         other work in the queue is done. */\n      if (slow_io_work_running >= slow_work_thread_threshold()) {\n        QUEUE_INSERT_TAIL(&wq, q);\n        continue;\n      }\n\n      /* If we encountered a request to run slow I/O work but there is none\n         to run, that means it's cancelled => Start over. */\n      if (QUEUE_EMPTY(&slow_io_pending_wq))\n        continue;\n\n      is_slow_work = 1;\n      slow_io_work_running++;\n\n      q = QUEUE_HEAD(&slow_io_pending_wq);\n      QUEUE_REMOVE(q);\n      QUEUE_INIT(q);\n\n      /* If there is more slow I/O work, schedule it to be run as well. */\n      if (!QUEUE_EMPTY(&slow_io_pending_wq)) {\n        QUEUE_INSERT_TAIL(&wq, &run_slow_work_message);\n        if (idle_threads > 0)\n          uv_cond_signal(&cond);\n      }\n    }\n\n    uv_mutex_unlock(&mutex);\n\n    w = QUEUE_DATA(q, struct uv__work, wq);\n    w->work(w);\n\n    uv_mutex_lock(&w->loop->wq_mutex);\n    w->work = NULL;  /* Signal uv_cancel() that the work req is done\n                        executing. */\n    QUEUE_INSERT_TAIL(&w->loop->wq, &w->wq);\n    uv_async_send(&w->loop->wq_async);\n    uv_mutex_unlock(&w->loop->wq_mutex);\n\n    /* Lock `mutex` since that is expected at the start of the next\n     * iteration. */\n    uv_mutex_lock(&mutex);\n    if (is_slow_work) {\n      /* `slow_io_work_running` is protected by `mutex`. */\n      slow_io_work_running--;\n    }\n  }\n}", "path": "libuv/src/threadpool.c", "commit_date": "2020-04-22 00:00:00", "repo_name": "libuv/libuv", "stars": 22970, "license": "mit", "language": "c", "size": 16102}
{"docstring": "// two signal handlers in one loop\n", "func_signal": "void thread1_worker(void *userp)", "code": "{\n    uv_loop_t *loop1 = create_loop();\n\n    uv_signal_t sig1a, sig1b;\n    uv_signal_init(loop1, &sig1a);\n    uv_signal_start(&sig1a, signal_handler, SIGUSR1);\n\n    uv_signal_init(loop1, &sig1b);\n    uv_signal_start(&sig1b, signal_handler, SIGUSR1);\n\n    uv_run(loop1, UV_RUN_DEFAULT);\n}", "path": "libuv/docs/code/signal/main.c", "commit_date": "2017-04-28 00:00:00", "repo_name": "libuv/libuv", "stars": 22970, "license": "mit", "language": "c", "size": 16102}
{"docstring": "/* See description of uv_wsarecv_workaround. */\n", "func_signal": "int WSAAPI uv_wsarecvfrom_workaround(SOCKET socket, WSABUF* buffers,\n    DWORD buffer_count, DWORD* bytes, DWORD* flags, struct sockaddr* addr,\n    int* addr_len, WSAOVERLAPPED *overlapped,\n    LPWSAOVERLAPPED_COMPLETION_ROUTINE completion_routine)", "code": "{\n  NTSTATUS status;\n  void* apc_context;\n  IO_STATUS_BLOCK* iosb = (IO_STATUS_BLOCK*) &overlapped->Internal;\n  AFD_RECV_DATAGRAM_INFO info;\n  DWORD error;\n\n  if (overlapped == NULL || addr == NULL || addr_len == NULL ||\n      completion_routine != NULL) {\n    WSASetLastError(WSAEINVAL);\n    return SOCKET_ERROR;\n  }\n\n  info.BufferArray = buffers;\n  info.BufferCount = buffer_count;\n  info.AfdFlags = AFD_OVERLAPPED;\n  info.TdiFlags = TDI_RECEIVE_NORMAL;\n  info.Address = addr;\n  info.AddressLength = addr_len;\n\n  if (*flags & MSG_PEEK) {\n    info.TdiFlags |= TDI_RECEIVE_PEEK;\n  }\n\n  if (*flags & MSG_PARTIAL) {\n    info.TdiFlags |= TDI_RECEIVE_PARTIAL;\n  }\n\n  if (!((intptr_t) overlapped->hEvent & 1)) {\n    apc_context = (void*) overlapped;\n  } else {\n    apc_context = NULL;\n  }\n\n  iosb->Status = STATUS_PENDING;\n  iosb->Pointer = 0;\n\n  status = pNtDeviceIoControlFile((HANDLE) socket,\n                                  overlapped->hEvent,\n                                  NULL,\n                                  apc_context,\n                                  iosb,\n                                  IOCTL_AFD_RECEIVE_DATAGRAM,\n                                  &info,\n                                  sizeof(info),\n                                  NULL,\n                                  0);\n\n  *flags = 0;\n  *bytes = (DWORD) iosb->Information;\n\n  switch (status) {\n    case STATUS_SUCCESS:\n      error = ERROR_SUCCESS;\n      break;\n\n    case STATUS_PENDING:\n      error = WSA_IO_PENDING;\n      break;\n\n    case STATUS_BUFFER_OVERFLOW:\n      error = WSAEMSGSIZE;\n      break;\n\n    case STATUS_RECEIVE_EXPEDITED:\n      error = ERROR_SUCCESS;\n      *flags = MSG_OOB;\n      break;\n\n    case STATUS_RECEIVE_PARTIAL_EXPEDITED:\n      error = ERROR_SUCCESS;\n      *flags = MSG_PARTIAL | MSG_OOB;\n      break;\n\n    case STATUS_RECEIVE_PARTIAL:\n      error = ERROR_SUCCESS;\n      *flags = MSG_PARTIAL;\n      break;\n\n    default:\n      error = uv_ntstatus_to_winsock_error(status);\n      break;\n  }\n\n  WSASetLastError(error);\n\n  if (error == ERROR_SUCCESS) {\n    return 0;\n  } else {\n    return SOCKET_ERROR;\n  }\n}", "path": "libuv/src/win/winsock.c", "commit_date": "2020-01-08 00:00:00", "repo_name": "libuv/libuv", "stars": 22970, "license": "mit", "language": "c", "size": 16102}
{"docstring": "// two signal handlers, each in its own loop\n", "func_signal": "void thread2_worker(void *userp)", "code": "{\n    uv_loop_t *loop2 = create_loop();\n    uv_loop_t *loop3 = create_loop();\n\n    uv_signal_t sig2;\n    uv_signal_init(loop2, &sig2);\n    uv_signal_start(&sig2, signal_handler, SIGUSR1);\n\n    uv_signal_t sig3;\n    uv_signal_init(loop3, &sig3);\n    uv_signal_start(&sig3, signal_handler, SIGUSR1);\n\n    while (uv_run(loop2, UV_RUN_NOWAIT) || uv_run(loop3, UV_RUN_NOWAIT)) {\n    }\n}", "path": "libuv/docs/code/signal/main.c", "commit_date": "2017-04-28 00:00:00", "repo_name": "libuv/libuv", "stars": 22970, "license": "mit", "language": "c", "size": 16102}
{"docstring": "/*\n * We could use a static buffer for the path manipulations that we need outside\n * of the function, but this function could be called by multiple consumers and\n * we don't want to potentially create a race condition in the use of snprintf.\n * There is no direct way of getting the exe path in zOS - either through /procfs\n * or through some libc APIs. The below approach is to parse the argv[0]'s pattern\n * and use it in conjunction with PATH environment variable to craft one.\n */\n", "func_signal": "int uv_exepath(char* buffer, size_t* size)", "code": "{\n  int res;\n  char args[PATH_MAX];\n  int pid;\n\n  if (buffer == NULL || size == NULL || *size == 0)\n    return UV_EINVAL;\n\n  pid = getpid();\n  res = getexe(pid, args, sizeof(args));\n  if (res < 0)\n    return UV_EINVAL;\n\n  return uv__search_path(args, buffer, size);\n}", "path": "libuv/src/unix/os390.c", "commit_date": "2020-08-10 00:00:00", "repo_name": "libuv/libuv", "stars": 22970, "license": "mit", "language": "c", "size": 16102}
{"docstring": "/*\n * Synthetic errors (errors that originate from within libuv, not the system)\n * should produce sensible error messages when run through uv_strerror().\n *\n * See https://github.com/joyent/libuv/issues/210\n */\n", "func_signal": "TEST_IMPL(error_message)", "code": "{\n#if defined(__ASAN__)\n  RETURN_SKIP(\"Test does not currently work in ASAN\");\n#endif\n  char buf[32];\n\n  /* Cop out. Can't do proper checks on systems with\n   * i18n-ized error messages...\n   */\n  if (strcmp(uv_strerror(0), \"Success\") != 0) {\n    printf(\"i18n error messages detected, skipping test.\\n\");\n    return 0;\n  }\n\n  ASSERT(strstr(uv_strerror(UV_EINVAL), \"Success\") == NULL);\n  ASSERT(strcmp(uv_strerror(1337), \"Unknown error\") == 0);\n  ASSERT(strcmp(uv_strerror(-1337), \"Unknown error\") == 0);\n\n  ASSERT(strstr(uv_strerror_r(UV_EINVAL, buf, sizeof(buf)), \"Success\") == NULL);\n  ASSERT(strstr(uv_strerror_r(1337, buf, sizeof(buf)), \"1337\") != NULL);\n  ASSERT(strstr(uv_strerror_r(-1337, buf, sizeof(buf)), \"-1337\") != NULL);\n\n  return 0;\n}", "path": "libuv/test/test-error.c", "commit_date": "2020-10-21 00:00:00", "repo_name": "libuv/libuv", "stars": 22970, "license": "mit", "language": "c", "size": 16102}
{"docstring": "/* This function is run inside a pthread. We do this so that we can possibly\n * timeout.\n */\n", "func_signal": "static void* dowait(void* data)", "code": "{\n  dowait_args* args = data;\n\n  int i, r;\n  process_info_t* p;\n\n  for (i = 0; i < args->n; i++) {\n    p = (process_info_t*)(args->vec + i * sizeof(process_info_t));\n    if (p->terminated) continue;\n    r = waitpid(p->pid, &p->status, 0);\n    if (r < 0) {\n      perror(\"waitpid\");\n      return NULL;\n    }\n    p->terminated = 1;\n  }\n\n  if (args->pipe[1] >= 0) {\n    /* Write a character to the main thread to notify it about this. */\n    ssize_t r;\n\n    do\n      r = write(args->pipe[1], \"\", 1);\n    while (r == -1 && errno == EINTR);\n  }\n\n  return NULL;\n}", "path": "libuv/test/runner-unix.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "libuv/libuv", "stars": 22970, "license": "mit", "language": "c", "size": 16102}
{"docstring": "/* Do platform-specific initialization. */\n", "func_signal": "void platform_init(int argc, char **argv)", "code": "{\n  /* Disable stdio output buffering. */\n  setvbuf(stdout, NULL, _IONBF, 0);\n  setvbuf(stderr, NULL, _IONBF, 0);\n  signal(SIGPIPE, SIG_IGN);\n  snprintf(executable_path, sizeof(executable_path), \"%s\", argv[0]);\n}", "path": "libuv/test/runner-unix.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "libuv/libuv", "stars": 22970, "license": "mit", "language": "c", "size": 16102}
{"docstring": "/*\n * We could use a static buffer for the path manipulations that we need outside\n * of the function, but this function could be called by multiple consumers and\n * we don't want to potentially create a race condition in the use of snprintf.\n * There is no direct way of getting the exe path in AIX - either through /procfs\n * or through some libc APIs. The below approach is to parse the argv[0]'s pattern\n * and use it in conjunction with PATH environment variable to craft one.\n */\n", "func_signal": "int uv_exepath(char* buffer, size_t* size)", "code": "{\n  int res;\n  char args[UV__PATH_MAX];\n  size_t cached_len;\n  struct procsinfo pi;\n\n  if (buffer == NULL || size == NULL || *size == 0)\n    return UV_EINVAL;\n\n  uv_once(&process_title_mutex_once, init_process_title_mutex_once);\n  uv_mutex_lock(&process_title_mutex);\n  if (original_exepath != NULL) {\n    cached_len = strlen(original_exepath);\n    *size -= 1;\n    if (*size > cached_len)\n      *size = cached_len;\n    memcpy(buffer, original_exepath, *size);\n    buffer[*size] = '\\0';\n    uv_mutex_unlock(&process_title_mutex);\n    return 0;\n  }\n  uv_mutex_unlock(&process_title_mutex);\n  pi.pi_pid = getpid();\n  res = getargs(&pi, sizeof(pi), args, sizeof(args));\n\n  if (res < 0)\n    return UV_EINVAL;\n\n  return uv__search_path(args, buffer, size);\n}", "path": "libuv/src/unix/aix-common.c", "commit_date": "2020-08-10 00:00:00", "repo_name": "libuv/libuv", "stars": 22970, "license": "mit", "language": "c", "size": 16102}
{"docstring": "/* Move the console cursor one line up and back to the first column. */\n", "func_signal": "void rewind_cursor(void)", "code": "{\n#if defined(__MVS__)\n  fprintf(stderr, \"\\047[2K\\r\");\n#else\n  fprintf(stderr, \"\\033[2K\\r\");\n#endif\n}", "path": "libuv/test/runner-unix.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "libuv/libuv", "stars": 22970, "license": "mit", "language": "c", "size": 16102}
{"docstring": "/*\n * Retrieves the pointer to a winsock extension function.\n */\n", "func_signal": "static BOOL uv_get_extension_function(SOCKET socket, GUID guid,\n    void **target)", "code": "{\n  int result;\n  DWORD bytes;\n\n  result = WSAIoctl(socket,\n                    SIO_GET_EXTENSION_FUNCTION_POINTER,\n                    &guid,\n                    sizeof(guid),\n                    (void*)target,\n                    sizeof(*target),\n                    &bytes,\n                    NULL,\n                    NULL);\n\n  if (result == SOCKET_ERROR) {\n    *target = NULL;\n    return FALSE;\n  } else {\n    return TRUE;\n  }\n}", "path": "libuv/src/win/winsock.c", "commit_date": "2020-01-08 00:00:00", "repo_name": "libuv/libuv", "stars": 22970, "license": "mit", "language": "c", "size": 16102}
{"docstring": "/*\n* Entry point for getnameinfo\n* return 0 if a callback will be made\n* return error code if validation fails\n*/\n", "func_signal": "int uv_getnameinfo(uv_loop_t* loop,\n                   uv_getnameinfo_t* req,\n                   uv_getnameinfo_cb getnameinfo_cb,\n                   const struct sockaddr* addr,\n                   int flags)", "code": "{\n  if (req == NULL || addr == NULL)\n    return UV_EINVAL;\n\n  if (addr->sa_family == AF_INET) {\n    memcpy(&req->storage,\n           addr,\n           sizeof(struct sockaddr_in));\n  } else if (addr->sa_family == AF_INET6) {\n    memcpy(&req->storage,\n           addr,\n           sizeof(struct sockaddr_in6));\n  } else {\n    return UV_EINVAL;\n  }\n\n  uv__req_init(loop, (uv_req_t*)req, UV_GETNAMEINFO);\n\n  req->getnameinfo_cb = getnameinfo_cb;\n  req->flags = flags;\n  req->type = UV_GETNAMEINFO;\n  req->loop = loop;\n  req->retcode = 0;\n\n  if (getnameinfo_cb) {\n    uv__work_submit(loop,\n                    &req->work_req,\n                    UV__WORK_SLOW_IO,\n                    uv__getnameinfo_work,\n                    uv__getnameinfo_done);\n    return 0;\n  } else {\n    uv__getnameinfo_work(&req->work_req);\n    uv__getnameinfo_done(&req->work_req, 0);\n    return req->retcode;\n  }\n}", "path": "libuv/src/unix/getnameinfo.c", "commit_date": "2018-08-21 00:00:00", "repo_name": "libuv/libuv", "stars": 22970, "license": "mit", "language": "c", "size": 16102}
{"docstring": "/*\nboolean fastdfs_storage_modify_by_filename(string local_filename, \n\tlong file_offset, string group_name, appender_filename, \n\t[array tracker_server, array storage_server])\nreturn true for success, false for error\n*/\n", "func_signal": "static void php_fdfs_storage_modify_file_impl( \\\n\t\tINTERNAL_FUNCTION_PARAMETERS, FDFSPhpContext *pContext, \\\n\t\tconst byte upload_type, const bool bFileId)", "code": "{\n\tint result;\n\tint argc;\n\tzval *callback_obj;\n\tchar *local_filename;\n\tchar *appender_filename;\n\tzval *tracker_obj;\n\tzval *storage_obj;\n\tchar *group_name;\n\tHashTable *tracker_hash;\n\tHashTable *storage_hash;\n\tConnectionInfo tracker_server;\n\tConnectionInfo storage_server;\n\tConnectionInfo *pTrackerServer;\n\tConnectionInfo *pStorageServer;\n\tchar new_file_id[FDFS_GROUP_NAME_MAX_LEN + 128];\n\tzend_size_t filename_len;\n\tzend_size_t group_name_len;\n\tzend_size_t appender_filename_len;\n\tint saved_tracker_sock;\n\tint saved_storage_sock;\n\tint min_param_count;\n\tint max_param_count;\n\tlong file_offset = 0;\n\n\tif (bFileId)\n\t{\n\t\tmin_param_count = 3;\n\t\tmax_param_count = 5;\n\t}\n\telse\n\t{\n\t\tmin_param_count = 4;\n\t\tmax_param_count = 6;\n\t}\n\n    \targc = ZEND_NUM_ARGS();\n\tif (argc < min_param_count || argc > max_param_count)\n\t{\n\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\"storage_modify_file parameters \" \\\n\t\t\t\"count: %d < %d or > %d\", __LINE__, argc, \\\n\t\t\tmin_param_count, max_param_count);\n\t\tpContext->err_no = EINVAL;\n\t\tRETURN_BOOL(false);\n\t}\n\n\tlocal_filename = NULL;\n\tfilename_len = 0;\n\tcallback_obj = NULL;\n\ttracker_obj = NULL;\n\tstorage_obj = NULL;\n\tif (bFileId)\n\t{\n\t\tchar *pSeperator;\n\t\tchar *appender_file_id;\n\t\tzend_size_t appender_file_id_len;\n\n\t\tif (upload_type == FDFS_UPLOAD_BY_CALLBACK)\n\t\t{\n\t\tresult = zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \\\n\t\t\t\"als|aa\", &callback_obj, &file_offset, \\\n\t\t\t&appender_file_id, &appender_file_id_len, \\\n\t\t\t&tracker_obj, &storage_obj);\n\t\t}\n\t\telse\n\t\t{\n\t\tresult = zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \\\n\t\t\t\"sls|aa\", &local_filename, &filename_len, \\\n\t\t\t&file_offset, &appender_file_id, &appender_file_id_len, \\\n\t\t\t&tracker_obj, &storage_obj);\n\t\t}\n\t\tif (result == FAILURE)\n\t\t{\n\t\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\t\"zend_parse_parameters fail!\", __LINE__);\n\t\t\tpContext->err_no = EINVAL;\n\t\t\tRETURN_BOOL(false);\n\t\t}\n\n\t\tsnprintf(new_file_id, sizeof(new_file_id), \"%s\", appender_file_id);\n\t\tpSeperator = strchr(new_file_id, FDFS_FILE_ID_SEPERATOR);\n\t\tif (pSeperator == NULL)\n\t\t{\n\t\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\t\"appender_file_id is invalid, \" \\\n\t\t\t\t\"appender_file_id=%s\", \\\n\t\t\t\t__LINE__, appender_file_id);\n\t\t\tpContext->err_no = EINVAL;\n\t\t\tRETURN_BOOL(false);\n\t\t}\n\n\t\t*pSeperator = '\\0';\n\t\tgroup_name = new_file_id;\n\t\tappender_filename =  pSeperator + 1;\n\t}\n\telse\n\t{\n\t\tif (upload_type == FDFS_UPLOAD_BY_CALLBACK)\n\t\t{\n\t\tresult = zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \\\n\t\t\t\"alss|aa\", &callback_obj, &file_offset, \\\n\t\t\t&group_name, &group_name_len, \\\n\t\t\t&appender_filename, &appender_filename_len, \\\n\t\t\t&tracker_obj, &storage_obj);\n\t\t}\n\t\telse\n\t\t{\n\t\tresult = zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \\\n\t\t\t\"slss|aa\", &local_filename, &filename_len, \\\n\t\t\t&file_offset, &group_name, &group_name_len, \\\n\t\t\t&appender_filename, &appender_filename_len, \\\n\t\t\t&tracker_obj, &storage_obj);\n\t\t}\n\t\tif (result == FAILURE)\n\t\t{\n\t\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\t\"zend_parse_parameters fail!\", __LINE__);\n\t\t\tpContext->err_no = EINVAL;\n\t\t\tRETURN_BOOL(false);\n\t\t}\n\t}\n\n\tif (tracker_obj == NULL)\n\t{\n\t\tpTrackerServer = tracker_get_connection_no_pool( \\\n\t\t\t\t\tpContext->pTrackerGroup);\n\t\tif (pTrackerServer == NULL)\n\t\t{\n\t\t\tpContext->err_no = ENOENT;\n\t\t\tRETURN_BOOL(false);\n\t\t}\n\t\tsaved_tracker_sock = -1;\n\t\ttracker_hash = NULL;\n\t}\n\telse\n\t{\n\t\tpTrackerServer = &tracker_server;\n\t\ttracker_hash = Z_ARRVAL_P(tracker_obj);\n\t\tif ((result=php_fdfs_get_server_from_hash(tracker_hash, \\\n\t\t\t\tpTrackerServer)) != 0)\n\t\t{\n\t\t\tpContext->err_no = result;\n\t\t\tRETURN_BOOL(false);\n\t\t}\n\t\tsaved_tracker_sock = pTrackerServer->sock;\n\t}\n\n\tif (storage_obj == NULL)\n\t{\n\t\tpStorageServer = NULL;\n\t\tstorage_hash = NULL;\n\t\tsaved_storage_sock = -1;\n\t}\n\telse\n\t{\n\t\tpStorageServer = &storage_server;\n\t\tstorage_hash = Z_ARRVAL_P(storage_obj);\n\t\tif ((result=php_fdfs_get_server_from_hash(storage_hash, \\\n\t\t\t\tpStorageServer)) != 0)\n\t\t{\n\t\t\tpContext->err_no = result;\n\t\t\tRETURN_BOOL(false);\n\t\t}\n\n\t\tsaved_storage_sock = pStorageServer->sock;\n\t}\n\n\tif (upload_type == FDFS_UPLOAD_BY_FILE)\n\t{\n\tresult = storage_modify_by_filename(pTrackerServer, \\\n\t\t\tpStorageServer, local_filename, file_offset, \\\n\t\t\tgroup_name, appender_filename);\n\t}\n\telse if (upload_type == FDFS_UPLOAD_BY_BUFF)\n\t{\n\tresult = storage_modify_by_filebuff(pTrackerServer, \\\n\t\t\tpStorageServer, local_filename, \\\n\t\t\tfile_offset, filename_len, \\\n\t\t\tgroup_name, appender_filename);\n\t}\n\telse\n\t{\n\t\tHashTable *callback_hash;\n\t\tphp_fdfs_upload_callback_t php_callback;\n\n\t\tcallback_hash = Z_ARRVAL_P(callback_obj);\n\t\tresult = php_fdfs_get_upload_callback_from_hash( \\\n\t\t\t\tcallback_hash, &php_callback);\n\t\tif (result != 0)\n\t\t{\n\t\t\tpContext->err_no = result;\n\t\t\tRETURN_BOOL(false);\n\t\t}\n\n\t\tresult = storage_modify_by_callback(pTrackerServer, \\\n\t\t\tpStorageServer, php_fdfs_upload_callback, \\\n\t\t\t(void *)&php_callback, file_offset, \\\n\t\t\tphp_callback.file_size, group_name, \\\n\t\t\tappender_filename);\n\t}\n\n\tif (tracker_hash != NULL && pTrackerServer->sock != \\\n\t\tsaved_tracker_sock)\n\t{\n\t\tCLEAR_HASH_SOCK_FIELD(tracker_hash)\n\t}\n\tif (pStorageServer != NULL && pStorageServer->sock != \\\n\t\tsaved_storage_sock)\n\t{\n\t\tCLEAR_HASH_SOCK_FIELD(storage_hash)\n\t}\n\n\tpContext->err_no = result;\n\tif (result == 0)\n\t{\n\t\tRETURN_BOOL(true);\n\t}\n\telse\n\t{\n\t\tRETURN_BOOL(false);\n\t}\n}", "path": "fastdfs/php_client/fastdfs_client.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "happyfish100/fastdfs", "stars": 8815, "license": "gpl-3.0", "language": "c", "size": 11138}
{"docstring": "/**\n8 bytes: filename bytes\n8 bytes: old file size\n8 bytes: new file size\n4 bytes: source op timestamp\nFDFS_GROUP_NAME_MAX_LEN bytes: group_name\nfilename bytes : filename\n**/\n", "func_signal": "static int storage_sync_truncate_file(ConnectionInfo *pStorageServer, \\\n\tStorageBinLogReader *pReader, StorageBinLogRecord *pRecord)", "code": "{\n#define SYNC_TRUNCATE_FIELD_COUNT  3\n\tTrackerHeader *pHeader;\n\tchar *p;\n\tchar *pBuff;\n\tchar *fields[SYNC_TRUNCATE_FIELD_COUNT];\n\tchar full_filename[MAX_PATH_SIZE];\n\tchar out_buff[sizeof(TrackerHeader)+FDFS_GROUP_NAME_MAX_LEN+256];\n\tchar in_buff[1];\n\tstruct stat stat_buf;\n\tint64_t in_bytes;\n\tint64_t old_file_size;\n\tint64_t new_file_size;\n\tint result;\n\tint count;\n\n\tif ((count=splitEx(pRecord->filename, ' ', fields,\n                    SYNC_TRUNCATE_FIELD_COUNT)) != SYNC_TRUNCATE_FIELD_COUNT)\n\t{\n\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\"the format of binlog not correct, filename: %s\", \\\n\t\t\t__LINE__, pRecord->filename);\n\t\treturn EINVAL;\n\t}\n\n\told_file_size = strtoll((fields[1]), NULL, 10);\n\tnew_file_size = strtoll((fields[2]), NULL, 10);\n\t\n\tpRecord->filename_len = strlen(pRecord->filename);\n\tpRecord->true_filename_len = pRecord->filename_len;\n\tif ((result=storage_split_filename_ex(pRecord->filename, \\\n\t\t\t&pRecord->true_filename_len, pRecord->true_filename, \\\n\t\t\t&pRecord->store_path_index)) != 0)\n\t{\n\t\treturn result;\n\t}\n\n\tsnprintf(full_filename, sizeof(full_filename), \\\n\t\t\"%s/data/%s\", g_fdfs_store_paths.paths[pRecord->store_path_index].path, \\\n\t\tpRecord->true_filename);\n\tif (lstat(full_filename, &stat_buf) != 0)\n\t{\n\t\tif (errno == ENOENT)\n\t\t{\n\t\t\tlogDebug(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\t\"sync appender file, file: %s not exists, \"\\\n\t\t\t\t\"maybe deleted later?\", \\\n\t\t\t\t__LINE__, full_filename);\n\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = errno != 0 ? errno : EPERM;\n\t\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\t\"call stat fail, appender file: %s, \"\\\n\t\t\t\t\"error no: %d, error info: %s\", \\\n\t\t\t\t__LINE__, full_filename, \\\n\t\t\t\tresult, STRERROR(result));\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tif (stat_buf.st_size != new_file_size)\n\t{\n\t\tlogDebug(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\"appender file: %s 'size: %\"PRId64 \\\n\t\t\t\" != %\"PRId64\", maybe append/modify later\",\\\n\t\t\t__LINE__, full_filename, stat_buf.st_size, \n\t\t\tnew_file_size);\n\t}\n\n\tdo\n\t{\n\t\tint64_t body_len;\n\n\t\tpHeader = (TrackerHeader *)out_buff;\n\t\tmemset(pHeader, 0, sizeof(TrackerHeader));\n\n\t\tbody_len = 3 * FDFS_PROTO_PKG_LEN_SIZE + \\\n\t\t\t\t4 + FDFS_GROUP_NAME_MAX_LEN + \\\n\t\t\t\tpRecord->filename_len;\n\n\t\tlong2buff(body_len, pHeader->pkg_len);\n\t\tpHeader->cmd = STORAGE_PROTO_CMD_SYNC_TRUNCATE_FILE;\n\t\tpHeader->status = 0;\n\n\t\tp = out_buff + sizeof(TrackerHeader);\n\n\t\tlong2buff(pRecord->filename_len, p);\n\t\tp += FDFS_PROTO_PKG_LEN_SIZE;\n\n\t\tlong2buff(old_file_size, p);\n\t\tp += FDFS_PROTO_PKG_LEN_SIZE;\n\n\t\tlong2buff(new_file_size, p);\n\t\tp += FDFS_PROTO_PKG_LEN_SIZE;\n\n\t\tint2buff(pRecord->timestamp, p);\n\t\tp += 4;\n\n\t\tsprintf(p, \"%s\", g_group_name);\n\t\tp += FDFS_GROUP_NAME_MAX_LEN;\n\t\tmemcpy(p, pRecord->filename, pRecord->filename_len);\n\t\tp += pRecord->filename_len;\n\n\t\tif((result=tcpsenddata_nb(pStorageServer->sock, out_buff, \\\n\t\t\tp - out_buff, g_fdfs_network_timeout)) != 0)\n\t\t{\n\t\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\t\"sync data to storage server %s:%d fail, \" \\\n\t\t\t\t\"errno: %d, error info: %s\", \\\n\t\t\t\t__LINE__, pStorageServer->ip_addr, \\\n\t\t\t\tpStorageServer->port, \\\n\t\t\t\tresult, STRERROR(result));\n\n\t\t\tbreak;\n\t\t}\n\n\t\tpBuff = in_buff;\n\t\tif ((result=fdfs_recv_response(pStorageServer, \\\n\t\t\t&pBuff, 0, &in_bytes)) != 0)\n\t\t{\n            logError(\"file: \"__FILE__\", line: %d, \"\n                    \"fdfs_recv_response fail, result: %d\",\n                    __LINE__, result);\n\t\t\tbreak;\n\t\t}\n\t} while (0);\n\n\treturn result == EEXIST ? 0 : result;\n}", "path": "fastdfs/storage/storage_sync.c", "commit_date": "2019-12-26 00:00:00", "repo_name": "happyfish100/fastdfs", "stars": 8815, "license": "gpl-3.0", "language": "c", "size": 11138}
{"docstring": "/*\nboolean FastDFS::storage_download_file_to_callback(string group_name,\n\tstring remote_filename, array download_callback [, long file_offset, \n\tlong download_bytes, array tracker_server, array storage_server])\nreturn true for success, false for error\n*/\n", "func_signal": "PHP_METHOD(FastDFS, storage_download_file_to_callback)", "code": "{\n\tzval *object = getThis();\n\tphp_fdfs_t *i_obj;\n\n\ti_obj = (php_fdfs_t *) fdfs_get_object(object);\n\tphp_fdfs_storage_download_file_to_callback_impl( \\\n\t\tINTERNAL_FUNCTION_PARAM_PASSTHRU, &(i_obj->context), false);\n}", "path": "fastdfs/php_client/fastdfs_client.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "happyfish100/fastdfs", "stars": 8815, "license": "gpl-3.0", "language": "c", "size": 11138}
{"docstring": "/**\npkg format:\nHeader\n8 bytes: master filename len\n8 bytes: source filename len\n8 bytes: source file signature len\nFDFS_GROUP_NAME_MAX_LEN bytes: group_name\nFDFS_FILE_PREFIX_MAX_LEN bytes  : filename prefix, can be empty\nFDFS_FILE_EXT_NAME_MAX_LEN bytes: file ext name, do not include dot (.)\nmaster filename len: master filename\nsource filename len: source filename without group name\nsource file signature len: source file signature\n**/\n", "func_signal": "int storage_client_create_link(ConnectionInfo *pTrackerServer, \\\n\t\tConnectionInfo *pStorageServer, const char *master_filename,\\\n\t\tconst char *src_filename, const int src_filename_len, \\\n\t\tconst char *src_file_sig, const int src_file_sig_len, \\\n\t\tconst char *group_name, const char *prefix_name, \\\n\t\tconst char *file_ext_name, \\\n\t\tchar *remote_filename, int *filename_len)", "code": "{\n\tTrackerHeader *pHeader;\n\tint result;\n\tchar out_buff[sizeof(TrackerHeader) + 4 * FDFS_PROTO_PKG_LEN_SIZE + \\\n\t\tFDFS_GROUP_NAME_MAX_LEN + FDFS_FILE_PREFIX_MAX_LEN + \\\n\t\tFDFS_FILE_EXT_NAME_MAX_LEN + 256];\n\tchar in_buff[128];\n\tchar *p;\n\tint group_name_len;\n\tint master_filename_len;\n\tint64_t in_bytes;\n\tchar *pInBuff;\n\tConnectionInfo storageServer;\n\tbool new_connection;\n\n\t*remote_filename = '\\0';\n\tif (master_filename != NULL)\n\t{\n\t\tmaster_filename_len = strlen(master_filename);\n\t}\n\telse\n\t{\n\t\tmaster_filename_len = 0;\n\t}\n\tif (src_filename_len >= 128 || src_file_sig_len > 64 || \\\n\t\tmaster_filename_len >= 128)\n\t{\n\t\treturn EINVAL;\n\t}\n\n\tif ((result=storage_get_update_connection(pTrackerServer, \\\n\t\t&pStorageServer, group_name, src_filename, \\\n\t\t&storageServer, &new_connection)) != 0)\n\t{\n\t\treturn result;\n\t}\n\n\tdo\n\t{\n\tmemset(out_buff, 0, sizeof(out_buff));\n\tp = out_buff + sizeof(TrackerHeader);\n\tlong2buff(master_filename_len, p);\n\tp += FDFS_PROTO_PKG_LEN_SIZE;\n\tlong2buff(src_filename_len, p);\n\tp += FDFS_PROTO_PKG_LEN_SIZE;\n\tlong2buff(src_file_sig_len, p);\n\tp += FDFS_PROTO_PKG_LEN_SIZE;\n\n\tgroup_name_len = strlen(group_name);\n\tif (group_name_len > FDFS_GROUP_NAME_MAX_LEN)\n\t{\n\t\tgroup_name_len = FDFS_GROUP_NAME_MAX_LEN;\n\t}\n\tmemcpy(p, group_name, group_name_len);\n\tp += FDFS_GROUP_NAME_MAX_LEN;\n\n\tif (prefix_name != NULL)\n\t{\n\t\tint prefix_len;\n\n\t\tprefix_len = strlen(prefix_name);\n\t\tif (prefix_len > FDFS_FILE_PREFIX_MAX_LEN)\n\t\t{\n\t\t\tprefix_len = FDFS_FILE_PREFIX_MAX_LEN;\n\t\t}\n\t\tif (prefix_len > 0)\n\t\t{\n\t\t\tmemcpy(p, prefix_name, prefix_len);\n\t\t}\n\t}\n\tp += FDFS_FILE_PREFIX_MAX_LEN;\n\n\tif (file_ext_name != NULL)\n\t{\n\t\tint file_ext_len;\n\n\t\tfile_ext_len = strlen(file_ext_name);\n\t\tif (file_ext_len > FDFS_FILE_EXT_NAME_MAX_LEN)\n\t\t{\n\t\t\tfile_ext_len = FDFS_FILE_EXT_NAME_MAX_LEN;\n\t\t}\n\t\tif (file_ext_len > 0)\n\t\t{\n\t\t\tmemcpy(p, file_ext_name, file_ext_len);\n\t\t}\n\t}\n\tp += FDFS_FILE_EXT_NAME_MAX_LEN;\n\n\tif (master_filename_len > 0)\n\t{\n\t\tmemcpy(p, master_filename, master_filename_len);\n\t\tp += master_filename_len;\n\t}\n\tmemcpy(p, src_filename, src_filename_len);\n\tp += src_filename_len;\n\tmemcpy(p, src_file_sig, src_file_sig_len);\n\tp += src_file_sig_len;\n\n\tpHeader = (TrackerHeader *)out_buff;\n\tlong2buff(p - out_buff - sizeof(TrackerHeader), pHeader->pkg_len);\n\tpHeader->cmd = STORAGE_PROTO_CMD_CREATE_LINK;\n\tif ((result=tcpsenddata_nb(pStorageServer->sock, out_buff, \\\n\t\tp - out_buff, g_fdfs_network_timeout)) != 0)\n\t{\n\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\"send data to storage server %s:%d fail, \" \\\n\t\t\t\"errno: %d, error info: %s\", __LINE__, \\\n\t\t\tpStorageServer->ip_addr, pStorageServer->port, \\\n\t\t\tresult, STRERROR(result));\n\t\tbreak;\n\t}\n\n\tpInBuff = in_buff;\n\tif ((result=fdfs_recv_response(pStorageServer, \\\n\t\t&pInBuff, sizeof(in_buff), &in_bytes)) != 0)\n\t{\n\t\tlogError(\"file: \"__FILE__\", line: %d, \"\n                \"fdfs_recv_response fail, result: %d\",\n                __LINE__, result);\n\t\tbreak;\n\t}\n\n\tif (in_bytes <= FDFS_GROUP_NAME_MAX_LEN)\n\t{\n\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\"storage server %s:%d response data \" \\\n\t\t\t\"length: %\"PRId64\" is invalid, \" \\\n\t\t\t\"should > %d\", __LINE__, \\\n\t\t\tpStorageServer->ip_addr, pStorageServer->port, \\\n\t\t\tin_bytes, FDFS_GROUP_NAME_MAX_LEN);\n\t\tresult = EINVAL;\n\t\tbreak;\n\t}\n\n\t*(in_buff + in_bytes) = '\\0';\n\t*filename_len = in_bytes - FDFS_GROUP_NAME_MAX_LEN;\n\tmemcpy(remote_filename, in_buff + FDFS_GROUP_NAME_MAX_LEN, \\\n\t\t(*filename_len) + 1);\n\n\t} while (0);\n\n\tif (new_connection)\n\t{\n\t\ttracker_close_connection_ex(pStorageServer, result != 0);\n\t}\n\n\treturn result;\n}", "path": "fastdfs/client/storage_client.c", "commit_date": "2020-08-31 00:00:00", "repo_name": "happyfish100/fastdfs", "stars": 8815, "license": "gpl-3.0", "language": "c", "size": 11138}
{"docstring": "/**\n* request body format:\n*       namespace_len:  4 bytes big endian integer\n*       namespace: can be emtpy\n*       obj_id_len:  4 bytes big endian integer\n*       object_id: the object id (can be empty)\n*       key_len:  4 bytes big endian integer\n*       key:      key name\n* response body format:\n*      none\n*/\n", "func_signal": "int fdht_client_delete(FDHTServerInfo *pServer, const char keep_alive, \\\n\tconst time_t timestamp, const int prot_cmd, \\\n\tconst int key_hash_code, FDHTKeyInfo *pKeyInfo)", "code": "{\n\tint result;\n\tFDHTProtoHeader *pHeader;\n\tchar buff[sizeof(FDHTProtoHeader) + FDHT_MAX_FULL_KEY_LEN + 16];\n\tint in_bytes;\n\tchar *p;\n\n\tmemset(buff, 0, sizeof(buff));\n\tpHeader = (FDHTProtoHeader *)buff;\n\tpHeader->cmd = prot_cmd;\n\tpHeader->keep_alive = keep_alive;\n\tint2buff(timestamp, pHeader->timestamp);\n\tint2buff(key_hash_code, pHeader->key_hash_code);\n\tint2buff(12 + pKeyInfo->namespace_len + pKeyInfo->obj_id_len + \\\n\t\tpKeyInfo->key_len, pHeader->pkg_len);\n\n\tp = buff + sizeof(FDHTProtoHeader);\n\tPACK_BODY_UNTIL_KEY(pKeyInfo, p)\n\n\tif ((result=tcpsenddata_nb(pServer->sock, buff, p - buff, \\\n\t\tg_fdht_network_timeout)) != 0)\n\t{\n\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\"send data to server %s:%d fail, \" \\\n\t\t\t\"errno: %d, error info: %s\", __LINE__, \\\n\t\t\tpServer->ip_addr, pServer->port, \\\n\t\t\tresult, STRERROR(result));\n\t\treturn result;\n\t}\n\n\tif ((result=fdht_recv_header(pServer, &in_bytes)) != 0)\n\t{\n\t\tif (result == ENOENT)\n\t\t{\n\t\t\tlogWarning(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\t\"recv data from server %s:%d fail, \" \\\n\t\t\t\t\"errno: %d, error info: %s\", __LINE__, \\\n\t\t\t\tpServer->ip_addr, pServer->port, \\\n\t\t\t\tresult, STRERROR(result));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\t\"recv data from server %s:%d fail, \" \\\n\t\t\t\t\"errno: %d, error info: %s\", __LINE__, \\\n\t\t\t\tpServer->ip_addr, pServer->port, \\\n\t\t\t\tresult, STRERROR(result));\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tif (in_bytes != 0)\n\t{\n\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\"server %s:%d reponse bytes: %d != 0\", \\\n\t\t\t__LINE__, pServer->ip_addr, \\\n\t\t\tpServer->port, in_bytes);\n\t\treturn EINVAL;\n\t}\n\n\treturn 0;\n}", "path": "fastdfs/storage/fdht_client/fdht_proto.c", "commit_date": "2019-11-23 00:00:00", "repo_name": "happyfish100/fastdfs", "stars": 8815, "license": "gpl-3.0", "language": "c", "size": 11138}
{"docstring": "/*\narray FastDFS::connect_server(string ip_addr, int port)\nreturn array for success, false for error\n*/\n", "func_signal": "PHP_METHOD(FastDFS, connect_server)", "code": "{\n\tzval *object = getThis();\n\tphp_fdfs_t *i_obj;\n\n\ti_obj = (php_fdfs_t *) fdfs_get_object(object);\n\tphp_fdfs_connect_server_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, \\\n\t\t&(i_obj->context));\n}", "path": "fastdfs/php_client/fastdfs_client.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "happyfish100/fastdfs", "stars": 8815, "license": "gpl-3.0", "language": "c", "size": 11138}
{"docstring": "/*\nstring FastDFS::get_last_error_info()\nreturn last error info\n*/\n", "func_signal": "PHP_METHOD(FastDFS, get_last_error_info)", "code": "{\n\tchar *error_info;\n\tzval *object = getThis();\n\tphp_fdfs_t *i_obj;\n\n\ti_obj = (php_fdfs_t *) fdfs_get_object(object);\n\terror_info = STRERROR(i_obj->context.err_no);\n\tZEND_RETURN_STRINGL(error_info, strlen(error_info), 1);\n}", "path": "fastdfs/php_client/fastdfs_client.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "happyfish100/fastdfs", "stars": 8815, "license": "gpl-3.0", "language": "c", "size": 11138}
{"docstring": "/*\nboolean FastDFS::storage_modify_by_callback1(array callback_array, \n\tlong file_offset, string group_name, string appender_filename\n\t[, array tracker_server, array storage_server])\nreturn true for success, false for error\n*/\n", "func_signal": "PHP_METHOD(FastDFS, storage_modify_by_callback1)", "code": "{\n\tzval *object = getThis();\n\tphp_fdfs_t *i_obj;\n\n\ti_obj = (php_fdfs_t *) fdfs_get_object(object);\n\tphp_fdfs_storage_modify_file_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, \\\n\t\t&(i_obj->context), FDFS_UPLOAD_BY_CALLBACK, true);\n}", "path": "fastdfs/php_client/fastdfs_client.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "happyfish100/fastdfs", "stars": 8815, "license": "gpl-3.0", "language": "c", "size": 11138}
{"docstring": "/*\nboolean fastdfs_tracker_make_all_connections()\nreturn true for success, false for error\n*/\n", "func_signal": "ZEND_FUNCTION(fastdfs_tracker_make_all_connections)", "code": "{\n\tphp_fdfs_tracker_make_all_connections_impl( \\\n\t\tINTERNAL_FUNCTION_PARAM_PASSTHRU, &php_context);\n}", "path": "fastdfs/php_client/fastdfs_client.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "happyfish100/fastdfs", "stars": 8815, "license": "gpl-3.0", "language": "c", "size": 11138}
{"docstring": "/*\narray fastdfs_tracker_query_storage_update1(string file_id, \n\t\t[, array tracker_server])\nreturn array for success, false for error\n*/\n", "func_signal": "ZEND_FUNCTION(fastdfs_tracker_query_storage_update1)", "code": "{\n\tphp_fdfs_tracker_do_query_storage_impl( \\\n\t\tINTERNAL_FUNCTION_PARAM_PASSTHRU, &php_context, \\\n\t\tTRACKER_PROTO_CMD_SERVICE_QUERY_UPDATE, true);\n}", "path": "fastdfs/php_client/fastdfs_client.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "happyfish100/fastdfs", "stars": 8815, "license": "gpl-3.0", "language": "c", "size": 11138}
{"docstring": "/*\narray fastdfs_storage_upload_slave_by_callback(array callback_array, \n\tstring group_name, string master_filename, string prefix_name \n\t[, string file_ext_name, array meta_list, \n\tarray tracker_server, array storage_server])\nreturn array for success, false for error\n*/\n", "func_signal": "ZEND_FUNCTION(fastdfs_storage_upload_slave_by_callback)", "code": "{\n\tphp_fdfs_storage_upload_slave_file_impl( \\\n\t\tINTERNAL_FUNCTION_PARAM_PASSTHRU, &php_context, \\\n\t\tFDFS_UPLOAD_BY_CALLBACK, false);\n}", "path": "fastdfs/php_client/fastdfs_client.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "happyfish100/fastdfs", "stars": 8815, "license": "gpl-3.0", "language": "c", "size": 11138}
{"docstring": "/*\nstring FastDFS::storage_upload_by_filename1(string local_filename, \n\t[string file_ext_name, string meta_list, string group_name, \n\tarray tracker_server, array storage_server])\nreturn file_id for success, false for error\n*/\n", "func_signal": "PHP_METHOD(FastDFS, storage_upload_by_filename1)", "code": "{\n\tzval *object = getThis();\n\tphp_fdfs_t *i_obj;\n\n\ti_obj = (php_fdfs_t *) fdfs_get_object(object);\n\tphp_fdfs_storage_upload_file_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, \\\n\t\t&(i_obj->context), STORAGE_PROTO_CMD_UPLOAD_FILE, \\\n\t\tFDFS_UPLOAD_BY_FILE, true);\n}", "path": "fastdfs/php_client/fastdfs_client.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "happyfish100/fastdfs", "stars": 8815, "license": "gpl-3.0", "language": "c", "size": 11138}
{"docstring": "/*\nboolean fastdfs_storage_regenerate_appender_filename(string group_name,\n    string appender_filename, [array tracker_server, array storage_server])\nreturn assoc array for success, false for error\n*/\n", "func_signal": "PHP_METHOD(FastDFS, storage_regenerate_appender_filename)", "code": "{\n\tzval *object = getThis();\n\tphp_fdfs_t *i_obj;\n\n\ti_obj = (php_fdfs_t *) fdfs_get_object(object);\n\tphp_fdfs_storage_regenerate_appender_filename_impl(\n            INTERNAL_FUNCTION_PARAM_PASSTHRU, &(i_obj->context), false);\n}", "path": "fastdfs/php_client/fastdfs_client.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "happyfish100/fastdfs", "stars": 8815, "license": "gpl-3.0", "language": "c", "size": 11138}
{"docstring": "/*\nboolean fastdfs_storage_regenerate_appender_filename(string group_name,\n    string appender_filename, [array tracker_server, array storage_server])\nreturn assoc array for success, false for error\n*/\n", "func_signal": "static void php_fdfs_storage_regenerate_appender_filename_impl(\n\t\tINTERNAL_FUNCTION_PARAMETERS, FDFSPhpContext *pContext,\n\t\tconst bool bFileId)", "code": "{\n\tint result;\n\tint argc;\n\tchar *appender_filename;\n\tzval *tracker_obj;\n\tzval *storage_obj;\n\tchar *group_name;\n\tHashTable *tracker_hash;\n\tHashTable *storage_hash;\n\tConnectionInfo tracker_server;\n\tConnectionInfo storage_server;\n\tConnectionInfo *pTrackerServer;\n\tConnectionInfo *pStorageServer;\n    char new_group_name[FDFS_GROUP_NAME_MAX_LEN + 1];\n    char new_remote_filename[128];\n\tchar new_file_id[FDFS_GROUP_NAME_MAX_LEN + 128];\n\tzend_size_t group_name_len;\n\tzend_size_t appender_filename_len;\n\tint saved_tracker_sock;\n\tint saved_storage_sock;\n\tint min_param_count;\n\tint max_param_count;\n\n\tif (bFileId)\n\t{\n\t\tmin_param_count = 1;\n\t\tmax_param_count = 3;\n\t}\n\telse\n\t{\n\t\tmin_param_count = 2;\n\t\tmax_param_count = 4;\n\t}\n\n    argc = ZEND_NUM_ARGS();\n\tif (argc < min_param_count || argc > max_param_count)\n\t{\n\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\"storage_modify_file parameters \" \\\n\t\t\t\"count: %d < %d or > %d\", __LINE__, argc, \\\n\t\t\tmin_param_count, max_param_count);\n\t\tpContext->err_no = EINVAL;\n\t\tRETURN_BOOL(false);\n\t}\n\n\ttracker_obj = NULL;\n\tstorage_obj = NULL;\n\tif (bFileId)\n\t{\n\t\tchar *pSeperator;\n\t\tchar *appender_file_id;\n\t\tzend_size_t appender_file_id_len;\n\n\t\tresult = zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,\n\t\t\t\"s|aa\", &appender_file_id, &appender_file_id_len,\n\t\t\t&tracker_obj, &storage_obj);\n\t\tif (result == FAILURE)\n\t\t{\n\t\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\t\"zend_parse_parameters fail!\", __LINE__);\n\t\t\tpContext->err_no = EINVAL;\n\t\t\tRETURN_BOOL(false);\n\t\t}\n\n\t\tsnprintf(new_file_id, sizeof(new_file_id), \"%s\", appender_file_id);\n\t\tpSeperator = strchr(new_file_id, FDFS_FILE_ID_SEPERATOR);\n\t\tif (pSeperator == NULL)\n\t\t{\n\t\t\tlogError(\"file: \"__FILE__\", line: %d, \"\n\t\t\t\t\"appender_file_id is invalid, \"\n\t\t\t\t\"appender_file_id=%s\",\n\t\t\t\t__LINE__, appender_file_id);\n\t\t\tpContext->err_no = EINVAL;\n\t\t\tRETURN_BOOL(false);\n\t\t}\n\n\t\t*pSeperator = '\\0';\n\t\tgroup_name = new_file_id;\n\t\tappender_filename =  pSeperator + 1;\n\t}\n\telse\n\t{\n\t\tresult = zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,\n\t\t\t\"ss|aa\", &group_name, &group_name_len,\n\t\t\t&appender_filename, &appender_filename_len,\n\t\t\t&tracker_obj, &storage_obj);\n\t\tif (result == FAILURE)\n\t\t{\n\t\t\tlogError(\"file: \"__FILE__\", line: %d, \"\n\t\t\t\t\"zend_parse_parameters fail!\", __LINE__);\n\t\t\tpContext->err_no = EINVAL;\n\t\t\tRETURN_BOOL(false);\n\t\t}\n\t}\n\n\tif (tracker_obj == NULL)\n\t{\n\t\tpTrackerServer = tracker_get_connection_no_pool( \\\n\t\t\t\t\tpContext->pTrackerGroup);\n\t\tif (pTrackerServer == NULL)\n\t\t{\n\t\t\tpContext->err_no = ENOENT;\n\t\t\tRETURN_BOOL(false);\n\t\t}\n\t\tsaved_tracker_sock = -1;\n\t\ttracker_hash = NULL;\n\t}\n\telse\n\t{\n\t\tpTrackerServer = &tracker_server;\n\t\ttracker_hash = Z_ARRVAL_P(tracker_obj);\n\t\tif ((result=php_fdfs_get_server_from_hash(tracker_hash, \\\n\t\t\t\tpTrackerServer)) != 0)\n\t\t{\n\t\t\tpContext->err_no = result;\n\t\t\tRETURN_BOOL(false);\n\t\t}\n\t\tsaved_tracker_sock = pTrackerServer->sock;\n\t}\n\n\tif (storage_obj == NULL)\n\t{\n\t\tpStorageServer = NULL;\n\t\tstorage_hash = NULL;\n\t\tsaved_storage_sock = -1;\n\t}\n\telse\n\t{\n\t\tpStorageServer = &storage_server;\n\t\tstorage_hash = Z_ARRVAL_P(storage_obj);\n\t\tif ((result=php_fdfs_get_server_from_hash(storage_hash, \\\n\t\t\t\tpStorageServer)) != 0)\n\t\t{\n\t\t\tpContext->err_no = result;\n\t\t\tRETURN_BOOL(false);\n\t\t}\n\n\t\tsaved_storage_sock = pStorageServer->sock;\n\t}\n\n    pContext->err_no = storage_regenerate_appender_filename(pTrackerServer,\n\t\tpStorageServer, group_name, appender_filename,\n        new_group_name, new_remote_filename);\n\n\tif (tracker_hash != NULL && pTrackerServer->sock != \\\n\t\tsaved_tracker_sock)\n\t{\n\t\tCLEAR_HASH_SOCK_FIELD(tracker_hash)\n\t}\n\tif (pStorageServer != NULL && pStorageServer->sock != \\\n\t\tsaved_storage_sock)\n\t{\n\t\tCLEAR_HASH_SOCK_FIELD(storage_hash)\n\t}\n\n    if (pContext->err_no != 0)\n    {\n        RETURN_BOOL(false);\n    }\n\tif (bFileId)\n\t{\n\t\tchar file_id[FDFS_GROUP_NAME_MAX_LEN + 128];\n\t\tint file_id_len;\n\n\t\tfile_id_len = sprintf(file_id, \"%s%c%s\", new_group_name,\n\t\t\t\tFDFS_FILE_ID_SEPERATOR, new_remote_filename);\n\t\tZEND_RETURN_STRINGL(file_id, file_id_len, 1);\n\t}\n\telse\n\t{\n\t\tarray_init(return_value);\n\n\t\tzend_add_assoc_stringl_ex(return_value, \"group_name\",\n\t\t\tsizeof(\"group_name\"), new_group_name,\n\t\t\tstrlen(new_group_name), 1);\n\t\tzend_add_assoc_stringl_ex(return_value, \"filename\",\n\t\t\tsizeof(\"filename\"), new_remote_filename,\n\t\t\tstrlen(new_remote_filename), 1);\n\t}\n}", "path": "fastdfs/php_client/fastdfs_client.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "happyfish100/fastdfs", "stars": 8815, "license": "gpl-3.0", "language": "c", "size": 11138}
{"docstring": "/*\nboolean fastdfs_storage_modify_by_filename1(string local_filename, \n\tlong file_offset, string appender_file_id\n        [, array tracker_server, array storage_server])\nreturn true for success, false for error\n*/\n", "func_signal": "ZEND_FUNCTION(fastdfs_storage_modify_by_filename1)", "code": "{\n\tphp_fdfs_storage_modify_file_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, \\\n\t\t&php_context, FDFS_UPLOAD_BY_FILE, true);\n}", "path": "fastdfs/php_client/fastdfs_client.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "happyfish100/fastdfs", "stars": 8815, "license": "gpl-3.0", "language": "c", "size": 11138}
{"docstring": "/*\nboolean fastdfs_storage_truncate_file1(string appender_file_id\n\t[, long truncated_file_size = 0, array tracker_server, \n\tarray storage_server])\nreturn true for success, false for error\n*/\n", "func_signal": "ZEND_FUNCTION(fastdfs_storage_truncate_file1)", "code": "{\n\tphp_fdfs_storage_truncate_file_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, \\\n\t\t&php_context, true);\n}", "path": "fastdfs/php_client/fastdfs_client.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "happyfish100/fastdfs", "stars": 8815, "license": "gpl-3.0", "language": "c", "size": 11138}
{"docstring": "/*\nboolean fastdfs_storage_modify_by_filebuff(string file_buff, \n\tlong file_offset, string group_name, string appender_filename\n\t[, array tracker_server, array storage_server])\nreturn true for success, false for error\n*/\n", "func_signal": "ZEND_FUNCTION(fastdfs_storage_modify_by_filebuff)", "code": "{\n\tphp_fdfs_storage_modify_file_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, \\\n\t\t&php_context, FDFS_UPLOAD_BY_BUFF, false);\n}", "path": "fastdfs/php_client/fastdfs_client.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "happyfish100/fastdfs", "stars": 8815, "license": "gpl-3.0", "language": "c", "size": 11138}
{"docstring": "/*\narray fastdfs_tracker_query_storage_list(string group_name, \n\t\tstring remote_filename [, array tracker_server])\nreturn array for success, false for error\n*/\n", "func_signal": "ZEND_FUNCTION(fastdfs_tracker_query_storage_list)", "code": "{\n\tphp_fdfs_tracker_query_storage_list_impl( \\\n\t\tINTERNAL_FUNCTION_PARAM_PASSTHRU, \\\n\t\t&php_context, false);\n}", "path": "fastdfs/php_client/fastdfs_client.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "happyfish100/fastdfs", "stars": 8815, "license": "gpl-3.0", "language": "c", "size": 11138}
{"docstring": "/*\narray FastDFS::storage_upload_by_filebuff(string file_buff, \n\t[string file_ext_name, string meta_list, string group_name, \n\tarray tracker_server, array storage_server])\nreturn array for success, false for error\n*/\n", "func_signal": "PHP_METHOD(FastDFS, storage_upload_by_filebuff)", "code": "{\n\tzval *object = getThis();\n\tphp_fdfs_t *i_obj;\n\n\ti_obj = (php_fdfs_t *) fdfs_get_object(object);\n\tphp_fdfs_storage_upload_file_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, \\\n\t\t&(i_obj->context), STORAGE_PROTO_CMD_UPLOAD_FILE, \\\n\t\tFDFS_UPLOAD_BY_BUFF, false);\n}", "path": "fastdfs/php_client/fastdfs_client.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "happyfish100/fastdfs", "stars": 8815, "license": "gpl-3.0", "language": "c", "size": 11138}
{"docstring": "/*\narray FastDFS::tracker_query_storage_update1(string file_id \n\t\t[, array tracker_server])\nreturn array for success, false for error\n*/\n", "func_signal": "PHP_METHOD(FastDFS, tracker_query_storage_update1)", "code": "{\n\tzval *object = getThis();\n\tphp_fdfs_t *i_obj;\n\n\ti_obj = (php_fdfs_t *) fdfs_get_object(object);\n\tphp_fdfs_tracker_do_query_storage_impl( \\\n\t\tINTERNAL_FUNCTION_PARAM_PASSTHRU, &(i_obj->context), \\\n\t\tTRACKER_PROTO_CMD_SERVICE_QUERY_UPDATE, true);\n}", "path": "fastdfs/php_client/fastdfs_client.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "happyfish100/fastdfs", "stars": 8815, "license": "gpl-3.0", "language": "c", "size": 11138}
{"docstring": "/*\n * Filter on inbound (dir == 0) or outbound (dir == 1) traffic.\n * Outbound traffic is sent by this machine, while inbound traffic is\n * sent by a remote machine (and may include packets destined for a\n * unicast or multicast link-layer address we are not subscribing to).\n * These are the same definitions implemented by pcap_setdirection().\n * Capturing only unicast traffic destined for this host is probably\n * better accomplished using a higher-layer filter.\n */\n", "func_signal": "struct block *\ngen_inbound(compiler_state_t *cstate, int dir)", "code": "{\n\tregister struct block *b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/*\n\t * Only some data link types support inbound/outbound qualifiers.\n\t */\n\tswitch (cstate->linktype) {\n\tcase DLT_SLIP:\n\t\tb0 = gen_relation_internal(cstate, BPF_JEQ,\n\t\t\t  gen_load_internal(cstate, Q_LINK, gen_loadi_internal(cstate, 0), 1),\n\t\t\t  gen_loadi_internal(cstate, 0),\n\t\t\t  dir);\n\t\tbreak;\n\n\tcase DLT_IPNET:\n\t\tif (dir) {\n\t\t\t/* match outgoing packets */\n\t\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, IPNET_OUTBOUND);\n\t\t} else {\n\t\t\t/* match incoming packets */\n\t\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, IPNET_INBOUND);\n\t\t}\n\t\tbreak;\n\n\tcase DLT_LINUX_SLL:\n\t\t/* match outgoing packets */\n\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 0, BPF_H, LINUX_SLL_OUTGOING);\n\t\tif (!dir) {\n\t\t\t/* to filter on inbound traffic, invert the match */\n\t\t\tgen_not(b0);\n\t\t}\n\t\tbreak;\n\n\tcase DLT_LINUX_SLL2:\n\t\t/* match outgoing packets */\n\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 10, BPF_B, LINUX_SLL_OUTGOING);\n\t\tif (!dir) {\n\t\t\t/* to filter on inbound traffic, invert the match */\n\t\t\tgen_not(b0);\n\t\t}\n\t\tbreak;\n\n#ifdef HAVE_NET_PFVAR_H\n\tcase DLT_PFLOG:\n\t\tb0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, dir), BPF_B,\n\t\t    (bpf_int32)((dir == 0) ? PF_IN : PF_OUT));\n\t\tbreak;\n#endif\n\n\tcase DLT_PPP_PPPD:\n\t\tif (dir) {\n\t\t\t/* match outgoing packets */\n\t\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 0, BPF_B, PPP_PPPD_OUT);\n\t\t} else {\n\t\t\t/* match incoming packets */\n\t\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 0, BPF_B, PPP_PPPD_IN);\n\t\t}\n\t\tbreak;\n\n        case DLT_JUNIPER_MFR:\n        case DLT_JUNIPER_MLFR:\n        case DLT_JUNIPER_MLPPP:\n\tcase DLT_JUNIPER_ATM1:\n\tcase DLT_JUNIPER_ATM2:\n\tcase DLT_JUNIPER_PPPOE:\n\tcase DLT_JUNIPER_PPPOE_ATM:\n        case DLT_JUNIPER_GGSN:\n        case DLT_JUNIPER_ES:\n        case DLT_JUNIPER_MONITOR:\n        case DLT_JUNIPER_SERVICES:\n        case DLT_JUNIPER_ETHER:\n        case DLT_JUNIPER_PPP:\n        case DLT_JUNIPER_FRELAY:\n        case DLT_JUNIPER_CHDLC:\n        case DLT_JUNIPER_VP:\n        case DLT_JUNIPER_ST:\n        case DLT_JUNIPER_ISM:\n        case DLT_JUNIPER_VS:\n        case DLT_JUNIPER_SRX_E2E:\n        case DLT_JUNIPER_FIBRECHANNEL:\n\tcase DLT_JUNIPER_ATM_CEMIC:\n\n\t\t/* juniper flags (including direction) are stored\n\t\t * the byte after the 3-byte magic number */\n\t\tif (dir) {\n\t\t\t/* match outgoing packets */\n\t\t\tb0 = gen_mcmp(cstate, OR_LINKHDR, 3, BPF_B, 0, 0x01);\n\t\t} else {\n\t\t\t/* match incoming packets */\n\t\t\tb0 = gen_mcmp(cstate, OR_LINKHDR, 3, BPF_B, 1, 0x01);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * If we have packet meta-data indicating a direction,\n\t\t * and that metadata can be checked by BPF code, check\n\t\t * it.  Otherwise, give up, as this link-layer type has\n\t\t * nothing in the packet data.\n\t\t *\n\t\t * Currently, the only platform where a BPF filter can\n\t\t * check that metadata is Linux with the in-kernel\n\t\t * BPF interpreter.  If other packet capture mechanisms\n\t\t * and BPF filters also supported this, it would be\n\t\t * nice.  It would be even better if they made that\n\t\t * metadata available so that we could provide it\n\t\t * with newer capture APIs, allowing it to be saved\n\t\t * in pcapng files.\n\t\t */\n#if defined(linux) && defined(PF_PACKET) && defined(SO_ATTACH_FILTER)\n\t\t/*\n\t\t * This is Linux with PF_PACKET support.\n\t\t * If this is a *live* capture, we can look at\n\t\t * special meta-data in the filter expression;\n\t\t * if it's a savefile, we can't.\n\t\t */\n\t\tif (cstate->bpf_pcap->rfile != NULL) {\n\t\t\t/* We have a FILE *, so this is a savefile */\n\t\t\tbpf_error(cstate, \"inbound/outbound not supported on %s when reading savefiles\",\n\t\t\t    pcap_datalink_val_to_description_or_dlt(cstate->linktype));\n\t\t\tb0 = NULL;\n\t\t\t/*NOTREACHED*/\n\t\t}\n\t\t/* match outgoing packets */\n\t\tb0 = gen_cmp(cstate, OR_LINKHDR, SKF_AD_OFF + SKF_AD_PKTTYPE, BPF_H,\n\t\t             PACKET_OUTGOING);\n\t\tif (!dir) {\n\t\t\t/* to filter on inbound traffic, invert the match */\n\t\t\tgen_not(b0);\n\t\t}\n#else /* defined(linux) && defined(PF_PACKET) && defined(SO_ATTACH_FILTER) */\n\t\tbpf_error(cstate, \"inbound/outbound not supported on %s\",\n\t\t    pcap_datalink_val_to_description_or_dlt(cstate->linktype));\n\t\t/*NOTREACHED*/\n#endif /* defined(linux) && defined(PF_PACKET) && defined(SO_ATTACH_FILTER) */\n\t}\n\treturn (b0);\n}", "path": "nmap/libpcap/gencode.c", "commit_date": "2019-11-19 00:00:00", "repo_name": "nmap/nmap", "stars": 9019, "license": "other", "language": "c", "size": 110994}
{"docstring": "/*\n * The jvalue_arg dance is to avoid annoying whining by compilers that\n * jvalue might be clobbered by longjmp - yeah, it might, but *WHO CARES*?\n * It's not *used* after setjmp returns.\n */\n", "func_signal": "struct block *\ngen_mtp3field_code(compiler_state_t *cstate, int mtp3field,\n    bpf_u_int32 jvalue_arg, bpf_u_int32 jtype, int reverse)", "code": "{\n\tvolatile bpf_u_int32 jvalue = jvalue_arg;\n\tstruct block *b0;\n\tbpf_u_int32 val1 , val2 , val3;\n\tu_int newoff_sio;\n\tu_int newoff_opc;\n\tu_int newoff_dpc;\n\tu_int newoff_sls;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tnewoff_sio = cstate->off_sio;\n\tnewoff_opc = cstate->off_opc;\n\tnewoff_dpc = cstate->off_dpc;\n\tnewoff_sls = cstate->off_sls;\n\tswitch (mtp3field) {\n\n\tcase MH_SIO:\n\t\tnewoff_sio += 3; /* offset for MTP2_HSL */\n\t\t/* FALLTHROUGH */\n\n\tcase M_SIO:\n\t\tif (cstate->off_sio == OFFSET_NOT_SET)\n\t\t\tbpf_error(cstate, \"'sio' supported only on SS7\");\n\t\t/* sio coded on 1 byte so max value 255 */\n\t\tif(jvalue > 255)\n\t\t        bpf_error(cstate, \"sio value %u too big; max value = 255\",\n\t\t            jvalue);\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, newoff_sio, BPF_B, 0xffffffff,\n\t\t    (u_int)jtype, reverse, (u_int)jvalue);\n\t\tbreak;\n\n\tcase MH_OPC:\n\t\tnewoff_opc += 3;\n\n\t\t/* FALLTHROUGH */\n        case M_OPC:\n\t        if (cstate->off_opc == OFFSET_NOT_SET)\n\t\t\tbpf_error(cstate, \"'opc' supported only on SS7\");\n\t\t/* opc coded on 14 bits so max value 16383 */\n\t\tif (jvalue > 16383)\n\t\t        bpf_error(cstate, \"opc value %u too big; max value = 16383\",\n\t\t            jvalue);\n\t\t/* the following instructions are made to convert jvalue\n\t\t * to the form used to write opc in an ss7 message*/\n\t\tval1 = jvalue & 0x00003c00;\n\t\tval1 = val1 >>10;\n\t\tval2 = jvalue & 0x000003fc;\n\t\tval2 = val2 <<6;\n\t\tval3 = jvalue & 0x00000003;\n\t\tval3 = val3 <<22;\n\t\tjvalue = val1 + val2 + val3;\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, newoff_opc, BPF_W, 0x00c0ff0f,\n\t\t    (u_int)jtype, reverse, (u_int)jvalue);\n\t\tbreak;\n\n\tcase MH_DPC:\n\t\tnewoff_dpc += 3;\n\t\t/* FALLTHROUGH */\n\n\tcase M_DPC:\n\t        if (cstate->off_dpc == OFFSET_NOT_SET)\n\t\t\tbpf_error(cstate, \"'dpc' supported only on SS7\");\n\t\t/* dpc coded on 14 bits so max value 16383 */\n\t\tif (jvalue > 16383)\n\t\t        bpf_error(cstate, \"dpc value %u too big; max value = 16383\",\n\t\t            jvalue);\n\t\t/* the following instructions are made to convert jvalue\n\t\t * to the forme used to write dpc in an ss7 message*/\n\t\tval1 = jvalue & 0x000000ff;\n\t\tval1 = val1 << 24;\n\t\tval2 = jvalue & 0x00003f00;\n\t\tval2 = val2 << 8;\n\t\tjvalue = val1 + val2;\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, newoff_dpc, BPF_W, 0xff3f0000,\n\t\t    (u_int)jtype, reverse, (u_int)jvalue);\n\t\tbreak;\n\n\tcase MH_SLS:\n\t\tnewoff_sls += 3;\n\t\t/* FALLTHROUGH */\n\n\tcase M_SLS:\n\t        if (cstate->off_sls == OFFSET_NOT_SET)\n\t\t\tbpf_error(cstate, \"'sls' supported only on SS7\");\n\t\t/* sls coded on 4 bits so max value 15 */\n\t\tif (jvalue > 15)\n\t\t         bpf_error(cstate, \"sls value %u too big; max value = 15\",\n\t\t             jvalue);\n\t\t/* the following instruction is made to convert jvalue\n\t\t * to the forme used to write sls in an ss7 message*/\n\t\tjvalue = jvalue << 4;\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, newoff_sls, BPF_B, 0xf0,\n\t\t    (u_int)jtype,reverse, (u_int)jvalue);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\treturn b0;\n}", "path": "nmap/libpcap/gencode.c", "commit_date": "2019-11-19 00:00:00", "repo_name": "nmap/nmap", "stars": 9019, "license": "other", "language": "c", "size": 110994}
{"docstring": "/*\n * Like gen_ehostop, but for DLT_IEEE802 (Token Ring)\n */\n", "func_signal": "static struct block *\ngen_thostop(compiler_state_t *cstate, const u_char *eaddr, int dir)", "code": "{\n\tregister struct block *b0, *b1;\n\n\tswitch (dir) {\n\tcase Q_SRC:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 8, 6, eaddr);\n\n\tcase Q_DST:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 2, 6, eaddr);\n\n\tcase Q_AND:\n\t\tb0 = gen_thostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_thostop(cstate, eaddr, Q_DST);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\tb0 = gen_thostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_thostop(cstate, eaddr, Q_DST);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\t}\n\tabort();\n\t/*NOTREACHED*/\n}", "path": "nmap/libpcap/gencode.c", "commit_date": "2019-11-19 00:00:00", "repo_name": "nmap/nmap", "stars": 9019, "license": "other", "language": "c", "size": 110994}
{"docstring": "/*\n * Check for an LLC SNAP packet with a given organization code and\n * protocol type; we check the entire contents of the 802.2 LLC and\n * snap headers, checking for DSAP and SSAP of SNAP and a control\n * field of 0x03 in the LLC header, and for the specified organization\n * code and protocol type in the SNAP header.\n */\n", "func_signal": "static struct block *\ngen_snap(compiler_state_t *cstate, bpf_u_int32 orgcode, bpf_u_int32 ptype)", "code": "{\n\tu_char snapblock[8];\n\n\tsnapblock[0] = LLCSAP_SNAP;\t\t/* DSAP = SNAP */\n\tsnapblock[1] = LLCSAP_SNAP;\t\t/* SSAP = SNAP */\n\tsnapblock[2] = 0x03;\t\t\t/* control = UI */\n\tsnapblock[3] = (u_char)(orgcode >> 16);\t/* upper 8 bits of organization code */\n\tsnapblock[4] = (u_char)(orgcode >> 8);\t/* middle 8 bits of organization code */\n\tsnapblock[5] = (u_char)(orgcode >> 0);\t/* lower 8 bits of organization code */\n\tsnapblock[6] = (u_char)(ptype >> 8);\t/* upper 8 bits of protocol type */\n\tsnapblock[7] = (u_char)(ptype >> 0);\t/* lower 8 bits of protocol type */\n\treturn gen_bcmp(cstate, OR_LLC, 0, 8, snapblock);\n}", "path": "nmap/libpcap/gencode.c", "commit_date": "2019-11-19 00:00:00", "repo_name": "nmap/nmap", "stars": 9019, "license": "other", "language": "c", "size": 110994}
{"docstring": "/*\n * Generate code to match a particular packet type by matching the\n * link-layer type field or fields in the 802.2 LLC header.\n *\n * \"proto\" is an Ethernet type value, if > ETHERMTU, or an LLC SAP\n * value, if <= ETHERMTU.\n */\n", "func_signal": "static struct block *\ngen_linktype(compiler_state_t *cstate, int proto)", "code": "{\n\tstruct block *b0, *b1, *b2;\n\tconst char *description;\n\n\t/* are we checking MPLS-encapsulated packets? */\n\tif (cstate->label_stack_depth > 0) {\n\t\tswitch (proto) {\n\t\tcase ETHERTYPE_IP:\n\t\tcase PPP_IP:\n\t\t\t/* FIXME add other L3 proto IDs */\n\t\t\treturn gen_mpls_linktype(cstate, Q_IP);\n\n\t\tcase ETHERTYPE_IPV6:\n\t\tcase PPP_IPV6:\n\t\t\t/* FIXME add other L3 proto IDs */\n\t\t\treturn gen_mpls_linktype(cstate, Q_IPV6);\n\n\t\tdefault:\n\t\t\tbpf_error(cstate, \"unsupported protocol over mpls\");\n\t\t\t/*NOTREACHED*/\n\t\t}\n\t}\n\n\tswitch (cstate->linktype) {\n\n\tcase DLT_EN10MB:\n\tcase DLT_NETANALYZER:\n\tcase DLT_NETANALYZER_TRANSPARENT:\n\t\t/* Geneve has an EtherType regardless of whether there is an\n\t\t * L2 header. */\n\t\tif (!cstate->is_geneve)\n\t\t\tb0 = gen_prevlinkhdr_check(cstate);\n\t\telse\n\t\t\tb0 = NULL;\n\n\t\tb1 = gen_ether_linktype(cstate, proto);\n\t\tif (b0 != NULL)\n\t\t\tgen_and(b0, b1);\n\t\treturn b1;\n\t\t/*NOTREACHED*/\n\n\tcase DLT_C_HDLC:\n\t\tswitch (proto) {\n\n\t\tcase LLCSAP_ISONS:\n\t\t\tproto = (proto << 8 | LLCSAP_ISONS);\n\t\t\t/* fall through */\n\n\t\tdefault:\n\t\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, (bpf_int32)proto);\n\t\t\t/*NOTREACHED*/\n\t\t}\n\n\tcase DLT_IEEE802_11:\n\tcase DLT_PRISM_HEADER:\n\tcase DLT_IEEE802_11_RADIO_AVS:\n\tcase DLT_IEEE802_11_RADIO:\n\tcase DLT_PPI:\n\t\t/*\n\t\t * Check that we have a data frame.\n\t\t */\n\t\tb0 = gen_check_802_11_data_frame(cstate);\n\n\t\t/*\n\t\t * Now check for the specified link-layer type.\n\t\t */\n\t\tb1 = gen_llc_linktype(cstate, proto);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\t\t/*NOTREACHED*/\n\n\tcase DLT_FDDI:\n\t\t/*\n\t\t * XXX - check for LLC frames.\n\t\t */\n\t\treturn gen_llc_linktype(cstate, proto);\n\t\t/*NOTREACHED*/\n\n\tcase DLT_IEEE802:\n\t\t/*\n\t\t * XXX - check for LLC PDUs, as per IEEE 802.5.\n\t\t */\n\t\treturn gen_llc_linktype(cstate, proto);\n\t\t/*NOTREACHED*/\n\n\tcase DLT_ATM_RFC1483:\n\tcase DLT_ATM_CLIP:\n\tcase DLT_IP_OVER_FC:\n\t\treturn gen_llc_linktype(cstate, proto);\n\t\t/*NOTREACHED*/\n\n\tcase DLT_SUNATM:\n\t\t/*\n\t\t * Check for an LLC-encapsulated version of this protocol;\n\t\t * if we were checking for LANE, linktype would no longer\n\t\t * be DLT_SUNATM.\n\t\t *\n\t\t * Check for LLC encapsulation and then check the protocol.\n\t\t */\n\t\tb0 = gen_atmfield_code_internal(cstate, A_PROTOTYPE, PT_LLC, BPF_JEQ, 0);\n\t\tb1 = gen_llc_linktype(cstate, proto);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\t\t/*NOTREACHED*/\n\n\tcase DLT_LINUX_SLL:\n\t\treturn gen_linux_sll_linktype(cstate, proto);\n\t\t/*NOTREACHED*/\n\n\tcase DLT_SLIP:\n\tcase DLT_SLIP_BSDOS:\n\tcase DLT_RAW:\n\t\t/*\n\t\t * These types don't provide any type field; packets\n\t\t * are always IPv4 or IPv6.\n\t\t *\n\t\t * XXX - for IPv4, check for a version number of 4, and,\n\t\t * for IPv6, check for a version number of 6?\n\t\t */\n\t\tswitch (proto) {\n\n\t\tcase ETHERTYPE_IP:\n\t\t\t/* Check for a version number of 4. */\n\t\t\treturn gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, 0x40, 0xF0);\n\n\t\tcase ETHERTYPE_IPV6:\n\t\t\t/* Check for a version number of 6. */\n\t\t\treturn gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, 0x60, 0xF0);\n\n\t\tdefault:\n\t\t\treturn gen_false(cstate);\t/* always false */\n\t\t}\n\t\t/*NOTREACHED*/\n\n\tcase DLT_IPV4:\n\t\t/*\n\t\t * Raw IPv4, so no type field.\n\t\t */\n\t\tif (proto == ETHERTYPE_IP)\n\t\t\treturn gen_true(cstate);\t/* always true */\n\n\t\t/* Checking for something other than IPv4; always false */\n\t\treturn gen_false(cstate);\n\t\t/*NOTREACHED*/\n\n\tcase DLT_IPV6:\n\t\t/*\n\t\t * Raw IPv6, so no type field.\n\t\t */\n\t\tif (proto == ETHERTYPE_IPV6)\n\t\t\treturn gen_true(cstate);\t/* always true */\n\n\t\t/* Checking for something other than IPv6; always false */\n\t\treturn gen_false(cstate);\n\t\t/*NOTREACHED*/\n\n\tcase DLT_PPP:\n\tcase DLT_PPP_PPPD:\n\tcase DLT_PPP_SERIAL:\n\tcase DLT_PPP_ETHER:\n\t\t/*\n\t\t * We use Ethernet protocol types inside libpcap;\n\t\t * map them to the corresponding PPP protocol types.\n\t\t */\n\t\tproto = ethertype_to_ppptype(proto);\n\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, (bpf_int32)proto);\n\t\t/*NOTREACHED*/\n\n\tcase DLT_PPP_BSDOS:\n\t\t/*\n\t\t * We use Ethernet protocol types inside libpcap;\n\t\t * map them to the corresponding PPP protocol types.\n\t\t */\n\t\tswitch (proto) {\n\n\t\tcase ETHERTYPE_IP:\n\t\t\t/*\n\t\t\t * Also check for Van Jacobson-compressed IP.\n\t\t\t * XXX - do this for other forms of PPP?\n\t\t\t */\n\t\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, PPP_IP);\n\t\t\tb1 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, PPP_VJC);\n\t\t\tgen_or(b0, b1);\n\t\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, PPP_VJNC);\n\t\t\tgen_or(b1, b0);\n\t\t\treturn b0;\n\n\t\tdefault:\n\t\t\tproto = ethertype_to_ppptype(proto);\n\t\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H,\n\t\t\t\t(bpf_int32)proto);\n\t\t}\n\t\t/*NOTREACHED*/\n\n\tcase DLT_NULL:\n\tcase DLT_LOOP:\n\tcase DLT_ENC:\n\t\tswitch (proto) {\n\n\t\tcase ETHERTYPE_IP:\n\t\t\treturn (gen_loopback_linktype(cstate, AF_INET));\n\n\t\tcase ETHERTYPE_IPV6:\n\t\t\t/*\n\t\t\t * AF_ values may, unfortunately, be platform-\n\t\t\t * dependent; AF_INET isn't, because everybody\n\t\t\t * used 4.2BSD's value, but AF_INET6 is, because\n\t\t\t * 4.2BSD didn't have a value for it (given that\n\t\t\t * IPv6 didn't exist back in the early 1980's),\n\t\t\t * and they all picked their own values.\n\t\t\t *\n\t\t\t * This means that, if we're reading from a\n\t\t\t * savefile, we need to check for all the\n\t\t\t * possible values.\n\t\t\t *\n\t\t\t * If we're doing a live capture, we only need\n\t\t\t * to check for this platform's value; however,\n\t\t\t * Npcap uses 24, which isn't Windows's AF_INET6\n\t\t\t * value.  (Given the multiple different values,\n\t\t\t * programs that read pcap files shouldn't be\n\t\t\t * checking for their platform's AF_INET6 value\n\t\t\t * anyway, they should check for all of the\n\t\t\t * possible values. and they might as well do\n\t\t\t * that even for live captures.)\n\t\t\t */\n\t\t\tif (cstate->bpf_pcap->rfile != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Savefile - check for all three\n\t\t\t\t * possible IPv6 values.\n\t\t\t\t */\n\t\t\t\tb0 = gen_loopback_linktype(cstate, BSD_AFNUM_INET6_BSD);\n\t\t\t\tb1 = gen_loopback_linktype(cstate, BSD_AFNUM_INET6_FREEBSD);\n\t\t\t\tgen_or(b0, b1);\n\t\t\t\tb0 = gen_loopback_linktype(cstate, BSD_AFNUM_INET6_DARWIN);\n\t\t\t\tgen_or(b0, b1);\n\t\t\t\treturn (b1);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Live capture, so we only need to\n\t\t\t\t * check for the value used on this\n\t\t\t\t * platform.\n\t\t\t\t */\n#ifdef _WIN32\n\t\t\t\t/*\n\t\t\t\t * Npcap doesn't use Windows's AF_INET6,\n\t\t\t\t * as that collides with AF_IPX on\n\t\t\t\t * some BSDs (both have the value 23).\n\t\t\t\t * Instead, it uses 24.\n\t\t\t\t */\n\t\t\t\treturn (gen_loopback_linktype(cstate, 24));\n#else /* _WIN32 */\n#ifdef AF_INET6\n\t\t\t\treturn (gen_loopback_linktype(cstate, AF_INET6));\n#else /* AF_INET6 */\n\t\t\t\t/*\n\t\t\t\t * I guess this platform doesn't support\n\t\t\t\t * IPv6, so we just reject all packets.\n\t\t\t\t */\n\t\t\t\treturn gen_false(cstate);\n#endif /* AF_INET6 */\n#endif /* _WIN32 */\n\t\t\t}\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Not a type on which we support filtering.\n\t\t\t * XXX - support those that have AF_ values\n\t\t\t * #defined on this platform, at least?\n\t\t\t */\n\t\t\treturn gen_false(cstate);\n\t\t}\n\n#ifdef HAVE_NET_PFVAR_H\n\tcase DLT_PFLOG:\n\t\t/*\n\t\t * af field is host byte order in contrast to the rest of\n\t\t * the packet.\n\t\t */\n\t\tif (proto == ETHERTYPE_IP)\n\t\t\treturn (gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, af),\n\t\t\t    BPF_B, (bpf_int32)AF_INET));\n\t\telse if (proto == ETHERTYPE_IPV6)\n\t\t\treturn (gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, af),\n\t\t\t    BPF_B, (bpf_int32)AF_INET6));\n\t\telse\n\t\t\treturn gen_false(cstate);\n\t\t/*NOTREACHED*/\n#endif /* HAVE_NET_PFVAR_H */\n\n\tcase DLT_ARCNET:\n\tcase DLT_ARCNET_LINUX:\n\t\t/*\n\t\t * XXX should we check for first fragment if the protocol\n\t\t * uses PHDS?\n\t\t */\n\t\tswitch (proto) {\n\n\t\tdefault:\n\t\t\treturn gen_false(cstate);\n\n\t\tcase ETHERTYPE_IPV6:\n\t\t\treturn (gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t\t\t(bpf_int32)ARCTYPE_INET6));\n\n\t\tcase ETHERTYPE_IP:\n\t\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t\t\t     (bpf_int32)ARCTYPE_IP);\n\t\t\tb1 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t\t\t     (bpf_int32)ARCTYPE_IP_OLD);\n\t\t\tgen_or(b0, b1);\n\t\t\treturn (b1);\n\n\t\tcase ETHERTYPE_ARP:\n\t\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t\t\t     (bpf_int32)ARCTYPE_ARP);\n\t\t\tb1 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t\t\t     (bpf_int32)ARCTYPE_ARP_OLD);\n\t\t\tgen_or(b0, b1);\n\t\t\treturn (b1);\n\n\t\tcase ETHERTYPE_REVARP:\n\t\t\treturn (gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t\t\t\t(bpf_int32)ARCTYPE_REVARP));\n\n\t\tcase ETHERTYPE_ATALK:\n\t\t\treturn (gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t\t\t\t(bpf_int32)ARCTYPE_ATALK));\n\t\t}\n\t\t/*NOTREACHED*/\n\n\tcase DLT_LTALK:\n\t\tswitch (proto) {\n\t\tcase ETHERTYPE_ATALK:\n\t\t\treturn gen_true(cstate);\n\t\tdefault:\n\t\t\treturn gen_false(cstate);\n\t\t}\n\t\t/*NOTREACHED*/\n\n\tcase DLT_FRELAY:\n\t\t/*\n\t\t * XXX - assumes a 2-byte Frame Relay header with\n\t\t * DLCI and flags.  What if the address is longer?\n\t\t */\n\t\tswitch (proto) {\n\n\t\tcase ETHERTYPE_IP:\n\t\t\t/*\n\t\t\t * Check for the special NLPID for IP.\n\t\t\t */\n\t\t\treturn gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | 0xcc);\n\n\t\tcase ETHERTYPE_IPV6:\n\t\t\t/*\n\t\t\t * Check for the special NLPID for IPv6.\n\t\t\t */\n\t\t\treturn gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | 0x8e);\n\n\t\tcase LLCSAP_ISONS:\n\t\t\t/*\n\t\t\t * Check for several OSI protocols.\n\t\t\t *\n\t\t\t * Frame Relay packets typically have an OSI\n\t\t\t * NLPID at the beginning; we check for each\n\t\t\t * of them.\n\t\t\t *\n\t\t\t * What we check for is the NLPID and a frame\n\t\t\t * control field of UI, i.e. 0x03 followed\n\t\t\t * by the NLPID.\n\t\t\t */\n\t\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | ISO8473_CLNP);\n\t\t\tb1 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | ISO9542_ESIS);\n\t\t\tb2 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | ISO10589_ISIS);\n\t\t\tgen_or(b1, b2);\n\t\t\tgen_or(b0, b2);\n\t\t\treturn b2;\n\n\t\tdefault:\n\t\t\treturn gen_false(cstate);\n\t\t}\n\t\t/*NOTREACHED*/\n\n\tcase DLT_MFR:\n\t\tbpf_error(cstate, \"Multi-link Frame Relay link-layer type filtering not implemented\");\n\n        case DLT_JUNIPER_MFR:\n        case DLT_JUNIPER_MLFR:\n        case DLT_JUNIPER_MLPPP:\n\tcase DLT_JUNIPER_ATM1:\n\tcase DLT_JUNIPER_ATM2:\n\tcase DLT_JUNIPER_PPPOE:\n\tcase DLT_JUNIPER_PPPOE_ATM:\n        case DLT_JUNIPER_GGSN:\n        case DLT_JUNIPER_ES:\n        case DLT_JUNIPER_MONITOR:\n        case DLT_JUNIPER_SERVICES:\n        case DLT_JUNIPER_ETHER:\n        case DLT_JUNIPER_PPP:\n        case DLT_JUNIPER_FRELAY:\n        case DLT_JUNIPER_CHDLC:\n        case DLT_JUNIPER_VP:\n        case DLT_JUNIPER_ST:\n        case DLT_JUNIPER_ISM:\n        case DLT_JUNIPER_VS:\n        case DLT_JUNIPER_SRX_E2E:\n        case DLT_JUNIPER_FIBRECHANNEL:\n\tcase DLT_JUNIPER_ATM_CEMIC:\n\n\t\t/* just lets verify the magic number for now -\n\t\t * on ATM we may have up to 6 different encapsulations on the wire\n\t\t * and need a lot of heuristics to figure out that the payload\n\t\t * might be;\n\t\t *\n\t\t * FIXME encapsulation specific BPF_ filters\n\t\t */\n\t\treturn gen_mcmp(cstate, OR_LINKHDR, 0, BPF_W, 0x4d474300, 0xffffff00); /* compare the magic number */\n\n\tcase DLT_BACNET_MS_TP:\n\t\treturn gen_mcmp(cstate, OR_LINKHDR, 0, BPF_W, 0x55FF0000, 0xffff0000);\n\n\tcase DLT_IPNET:\n\t\treturn gen_ipnet_linktype(cstate, proto);\n\n\tcase DLT_LINUX_IRDA:\n\t\tbpf_error(cstate, \"IrDA link-layer type filtering not implemented\");\n\n\tcase DLT_DOCSIS:\n\t\tbpf_error(cstate, \"DOCSIS link-layer type filtering not implemented\");\n\n\tcase DLT_MTP2:\n\tcase DLT_MTP2_WITH_PHDR:\n\t\tbpf_error(cstate, \"MTP2 link-layer type filtering not implemented\");\n\n\tcase DLT_ERF:\n\t\tbpf_error(cstate, \"ERF link-layer type filtering not implemented\");\n\n\tcase DLT_PFSYNC:\n\t\tbpf_error(cstate, \"PFSYNC link-layer type filtering not implemented\");\n\n\tcase DLT_LINUX_LAPD:\n\t\tbpf_error(cstate, \"LAPD link-layer type filtering not implemented\");\n\n\tcase DLT_USB_FREEBSD:\n\tcase DLT_USB_LINUX:\n\tcase DLT_USB_LINUX_MMAPPED:\n\tcase DLT_USBPCAP:\n\t\tbpf_error(cstate, \"USB link-layer type filtering not implemented\");\n\n\tcase DLT_BLUETOOTH_HCI_H4:\n\tcase DLT_BLUETOOTH_HCI_H4_WITH_PHDR:\n\t\tbpf_error(cstate, \"Bluetooth link-layer type filtering not implemented\");\n\n\tcase DLT_CAN20B:\n\tcase DLT_CAN_SOCKETCAN:\n\t\tbpf_error(cstate, \"CAN link-layer type filtering not implemented\");\n\n\tcase DLT_IEEE802_15_4:\n\tcase DLT_IEEE802_15_4_LINUX:\n\tcase DLT_IEEE802_15_4_NONASK_PHY:\n\tcase DLT_IEEE802_15_4_NOFCS:\n\t\tbpf_error(cstate, \"IEEE 802.15.4 link-layer type filtering not implemented\");\n\n\tcase DLT_IEEE802_16_MAC_CPS_RADIO:\n\t\tbpf_error(cstate, \"IEEE 802.16 link-layer type filtering not implemented\");\n\n\tcase DLT_SITA:\n\t\tbpf_error(cstate, \"SITA link-layer type filtering not implemented\");\n\n\tcase DLT_RAIF1:\n\t\tbpf_error(cstate, \"RAIF1 link-layer type filtering not implemented\");\n\n\tcase DLT_IPMB_KONTRON:\n\tcase DLT_IPMB_LINUX:\n\t\tbpf_error(cstate, \"IPMB link-layer type filtering not implemented\");\n\n\tcase DLT_AX25_KISS:\n\t\tbpf_error(cstate, \"AX.25 link-layer type filtering not implemented\");\n\n\tcase DLT_NFLOG:\n\t\t/* Using the fixed-size NFLOG header it is possible to tell only\n\t\t * the address family of the packet, other meaningful data is\n\t\t * either missing or behind TLVs.\n\t\t */\n\t\tbpf_error(cstate, \"NFLOG link-layer type filtering not implemented\");\n\n\tdefault:\n\t\t/*\n\t\t * Does this link-layer header type have a field\n\t\t * indicating the type of the next protocol?  If\n\t\t * so, off_linktype.constant_part will be the offset of that\n\t\t * field in the packet; if not, it will be OFFSET_NOT_SET.\n\t\t */\n\t\tif (cstate->off_linktype.constant_part != OFFSET_NOT_SET) {\n\t\t\t/*\n\t\t\t * Yes; assume it's an Ethernet type.  (If\n\t\t\t * it's not, it needs to be handled specially\n\t\t\t * above.)\n\t\t\t */\n\t\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, (bpf_int32)proto);\n\t\t\t/*NOTREACHED */\n\t\t} else {\n\t\t\t/*\n\t\t\t * No; report an error.\n\t\t\t */\n\t\t\tdescription = pcap_datalink_val_to_description_or_dlt(cstate->linktype);\n\t\t\tbpf_error(cstate, \"%s link-layer type filtering not implemented\",\n\t\t\t    description);\n\t\t\t/*NOTREACHED */\n\t\t}\n\t}\n}", "path": "nmap/libpcap/gencode.c", "commit_date": "2019-11-19 00:00:00", "repo_name": "nmap/nmap", "stars": 9019, "license": "other", "language": "c", "size": 110994}
{"docstring": "/*\n * Load a value relative to the specified absolute offset.\n */\n", "func_signal": "static struct slist *\ngen_load_absoffsetrel(compiler_state_t *cstate, bpf_abs_offset *abs_offset,\n    u_int offset, u_int size)", "code": "{\n\tstruct slist *s, *s2;\n\n\ts = gen_abs_offset_varpart(cstate, abs_offset);\n\n\t/*\n\t * If \"s\" is non-null, it has code to arrange that the X register\n\t * contains the variable part of the absolute offset, so we\n\t * generate a load relative to that, with an offset of\n\t * abs_offset->constant_part + offset.\n\t *\n\t * Otherwise, we can do an absolute load with an offset of\n\t * abs_offset->constant_part + offset.\n\t */\n\tif (s != NULL) {\n\t\t/*\n\t\t * \"s\" points to a list of statements that puts the\n\t\t * variable part of the absolute offset into the X register.\n\t\t * Do an indirect load, to use the X register as an offset.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_LD|BPF_IND|size);\n\t\ts2->s.k = abs_offset->constant_part + offset;\n\t\tsappend(s, s2);\n\t} else {\n\t\t/*\n\t\t * There is no variable part of the absolute offset, so\n\t\t * just do an absolute load.\n\t\t */\n\t\ts = new_stmt(cstate, BPF_LD|BPF_ABS|size);\n\t\ts->s.k = abs_offset->constant_part + offset;\n\t}\n\treturn s;\n}", "path": "nmap/libpcap/gencode.c", "commit_date": "2019-11-19 00:00:00", "repo_name": "nmap/nmap", "stars": 9019, "license": "other", "language": "c", "size": 110994}
{"docstring": "/*\n * AND the field of size \"size\" at offset \"offset\" relative to the header\n * specified by \"offrel\" with \"mask\", and compare it with the value \"v\"\n * with the test specified by \"jtype\"; if \"reverse\" is true, the test\n * should test the opposite of \"jtype\".\n */\n", "func_signal": "static struct block *\ngen_ncmp(compiler_state_t *cstate, enum e_offrel offrel, bpf_u_int32 offset,\n    bpf_u_int32 size, bpf_u_int32 mask, bpf_u_int32 jtype, int reverse,\n    bpf_int32 v)", "code": "{\n\tstruct slist *s, *s2;\n\tstruct block *b;\n\n\ts = gen_load_a(cstate, offrel, offset, size);\n\n\tif (mask != 0xffffffff) {\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);\n\t\ts2->s.k = mask;\n\t\tsappend(s, s2);\n\t}\n\n\tb = new_block(cstate, JMP(jtype));\n\tb->stmts = s;\n\tb->s.k = v;\n\tif (reverse && (jtype == BPF_JGT || jtype == BPF_JGE))\n\t\tgen_not(b);\n\treturn b;\n}", "path": "nmap/libpcap/gencode.c", "commit_date": "2019-11-19 00:00:00", "repo_name": "nmap/nmap", "stars": 9019, "license": "other", "language": "c", "size": 110994}
{"docstring": "/*\n * Generate code to load into the X register the sum of the length of\n * the IPv4 header and the variable part of the offset of the link-layer\n * payload.\n */\n", "func_signal": "static struct slist *\ngen_loadx_iphdrlen(compiler_state_t *cstate)", "code": "{\n\tstruct slist *s, *s2;\n\n\ts = gen_abs_offset_varpart(cstate, &cstate->off_linkpl);\n\tif (s != NULL) {\n\t\t/*\n\t\t * The offset of the link-layer payload has a variable\n\t\t * part.  \"s\" points to a list of statements that put\n\t\t * the variable part of that offset into the X register.\n\t\t *\n\t\t * The 4*([k]&0xf) addressing mode can't be used, as we\n\t\t * don't have a constant offset, so we have to load the\n\t\t * value in question into the A register and add to it\n\t\t * the value from the X register.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);\n\t\ts2->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;\n\t\tsappend(s, s2);\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);\n\t\ts2->s.k = 0xf;\n\t\tsappend(s, s2);\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_LSH|BPF_K);\n\t\ts2->s.k = 2;\n\t\tsappend(s, s2);\n\n\t\t/*\n\t\t * The A register now contains the length of the IP header.\n\t\t * We need to add to it the variable part of the offset of\n\t\t * the link-layer payload, which is still in the X\n\t\t * register, and move the result into the X register.\n\t\t */\n\t\tsappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));\n\t\tsappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));\n\t} else {\n\t\t/*\n\t\t * The offset of the link-layer payload is a constant,\n\t\t * so no code was generated to load the (non-existent)\n\t\t * variable part of that offset.\n\t\t *\n\t\t * This means we can use the 4*([k]&0xf) addressing\n\t\t * mode.  Load the length of the IPv4 header, which\n\t\t * is at an offset of cstate->off_nl from the beginning of\n\t\t * the link-layer payload, and thus at an offset of\n\t\t * cstate->off_linkpl.constant_part + cstate->off_nl from the beginning\n\t\t * of the raw packet data, using that addressing mode.\n\t\t */\n\t\ts = new_stmt(cstate, BPF_LDX|BPF_MSH|BPF_B);\n\t\ts->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;\n\t}\n\treturn s;\n}", "path": "nmap/libpcap/gencode.c", "commit_date": "2019-11-19 00:00:00", "repo_name": "nmap/nmap", "stars": 9019, "license": "other", "language": "c", "size": 110994}
{"docstring": "/* IEEE 802.11 wireless header */\n", "func_signal": "struct block *\ngen_p80211_type(compiler_state_t *cstate, int type, int mask)", "code": "{\n\tstruct block *b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tswitch (cstate->linktype) {\n\n\tcase DLT_IEEE802_11:\n\tcase DLT_PRISM_HEADER:\n\tcase DLT_IEEE802_11_RADIO_AVS:\n\tcase DLT_IEEE802_11_RADIO:\n\t\tb0 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, (bpf_int32)type,\n\t\t    (bpf_int32)mask);\n\t\tbreak;\n\n\tdefault:\n\t\tbpf_error(cstate, \"802.11 link-layer types supported only on 802.11\");\n\t\t/*NOTREACHED*/\n\t}\n\n\treturn (b0);\n}", "path": "nmap/libpcap/gencode.c", "commit_date": "2019-11-19 00:00:00", "repo_name": "nmap/nmap", "stars": 9019, "license": "other", "language": "c", "size": 110994}
{"docstring": "/* add v to variable part of off */\n", "func_signal": "static void\ngen_vlan_vloffset_add(compiler_state_t *cstate, bpf_abs_offset *off, int v, struct slist *s)", "code": "{\n\tstruct slist *s2;\n\n\tif (!off->is_variable)\n\t\toff->is_variable = 1;\n\tif (off->reg == -1)\n\t\toff->reg = alloc_reg(cstate);\n\n\ts2 = new_stmt(cstate, BPF_LD|BPF_MEM);\n\ts2->s.k = off->reg;\n\tsappend(s, s2);\n\ts2 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_IMM);\n\ts2->s.k = v;\n\tsappend(s, s2);\n\ts2 = new_stmt(cstate, BPF_ST);\n\ts2->s.k = off->reg;\n\tsappend(s, s2);\n}", "path": "nmap/libpcap/gencode.c", "commit_date": "2019-11-19 00:00:00", "repo_name": "nmap/nmap", "stars": 9019, "license": "other", "language": "c", "size": 110994}
{"docstring": "/*\n * Generate check for \"vlan\" or \"vlan <id>\" on systems with support for BPF\n * extensions.  Even if kernel supports VLAN BPF extensions, (outermost) VLAN\n * tag can be either in metadata or in packet data; therefore if the\n * SKF_AD_VLAN_TAG_PRESENT test is negative, we need to check link\n * header for VLAN tag. As the decision is done at run time, we need\n * update variable part of the offsets\n */\n", "func_signal": "static struct block *\ngen_vlan_bpf_extensions(compiler_state_t *cstate, bpf_u_int32 vlan_num,\n    int has_vlan_tag)", "code": "{\n        struct block *b0, *b_tpid, *b_vid = NULL;\n        struct slist *s;\n\n        /* generate new filter code based on extracting packet\n         * metadata */\n        s = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);\n        s->s.k = SKF_AD_OFF + SKF_AD_VLAN_TAG_PRESENT;\n\n        b0 = new_block(cstate, JMP(BPF_JEQ));\n        b0->stmts = s;\n        b0->s.k = 1;\n\n\t/*\n\t * This is tricky. We need to insert the statements updating variable\n\t * parts of offsets before the the traditional TPID and VID tests so\n\t * that they are called whenever SKF_AD_VLAN_TAG_PRESENT fails but\n\t * we do not want this update to affect those checks. That's why we\n\t * generate both test blocks first and insert the statements updating\n\t * variable parts of both offsets after that. This wouldn't work if\n\t * there already were variable length link header when entering this\n\t * function but gen_vlan_bpf_extensions() isn't called in that case.\n\t */\n\tb_tpid = gen_vlan_tpid_test(cstate);\n\tif (has_vlan_tag)\n\t\tb_vid = gen_vlan_vid_test(cstate, vlan_num);\n\n\tgen_vlan_patch_tpid_test(cstate, b_tpid);\n\tgen_or(b0, b_tpid);\n\tb0 = b_tpid;\n\n\tif (has_vlan_tag) {\n\t\tgen_vlan_patch_vid_test(cstate, b_vid);\n\t\tgen_and(b0, b_vid);\n\t\tb0 = b_vid;\n\t}\n\n        return b0;\n}", "path": "nmap/libpcap/gencode.c", "commit_date": "2019-11-19 00:00:00", "repo_name": "nmap/nmap", "stars": 9019, "license": "other", "language": "c", "size": 110994}
{"docstring": "/*\n * patch block b_vid (VLAN id test) to load VID value either from packet\n * metadata (using BPF extensions) if SKF_AD_VLAN_TAG_PRESENT is true\n */\n", "func_signal": "static void\ngen_vlan_patch_vid_test(compiler_state_t *cstate, struct block *b_vid)", "code": "{\n\tstruct slist *s, *s2, *sjeq;\n\tunsigned cnt;\n\n\ts = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);\n\ts->s.k = SKF_AD_OFF + SKF_AD_VLAN_TAG_PRESENT;\n\n\t/* true -> next instructions, false -> beginning of b_vid */\n\tsjeq = new_stmt(cstate, JMP(BPF_JEQ));\n\tsjeq->s.k = 1;\n\tsjeq->s.jf = b_vid->stmts;\n\tsappend(s, sjeq);\n\n\ts2 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);\n\ts2->s.k = SKF_AD_OFF + SKF_AD_VLAN_TAG;\n\tsappend(s, s2);\n\tsjeq->s.jt = s2;\n\n\t/* Jump to the test in b_vid. We need to jump one instruction before\n\t * the end of the b_vid block so that we only skip loading the TCI\n\t * from packet data and not the 'and' instruction extractging VID.\n\t */\n\tcnt = 0;\n\tfor (s2 = b_vid->stmts; s2; s2 = s2->next)\n\t\tcnt++;\n\ts2 = new_stmt(cstate, JMP(BPF_JA));\n\ts2->s.k = cnt - 1;\n\tsappend(s, s2);\n\n\t/* insert our statements at the beginning of b_vid */\n\tsappend(s, b_vid->stmts);\n\tb_vid->stmts = s;\n}", "path": "nmap/libpcap/gencode.c", "commit_date": "2019-11-19 00:00:00", "repo_name": "nmap/nmap", "stars": 9019, "license": "other", "language": "c", "size": 110994}
{"docstring": "/*\n * This is quite tricky because there may be pad bytes in front of the\n * DECNET header, and then there are two possible data packet formats that\n * carry both src and dst addresses, plus 5 packet types in a format that\n * carries only the src node, plus 2 types that use a different format and\n * also carry just the src node.\n *\n * Yuck.\n *\n * Instead of doing those all right, we just look for data packets with\n * 0 or 1 bytes of padding.  If you want to look at other packets, that\n * will require a lot more hacking.\n *\n * To add support for filtering on DECNET \"areas\" (network numbers)\n * one would want to add a \"mask\" argument to this routine.  That would\n * make the filter even more inefficient, although one could be clever\n * and not generate masking instructions if the mask is 0xFFFF.\n */\n", "func_signal": "static struct block *\ngen_dnhostop(compiler_state_t *cstate, bpf_u_int32 addr, int dir)", "code": "{\n\tstruct block *b0, *b1, *b2, *tmp;\n\tu_int offset_lh;\t/* offset if long header is received */\n\tu_int offset_sh;\t/* offset if short header is received */\n\n\tswitch (dir) {\n\n\tcase Q_DST:\n\t\toffset_sh = 1;\t/* follows flags */\n\t\toffset_lh = 7;\t/* flgs,darea,dsubarea,HIORD */\n\t\tbreak;\n\n\tcase Q_SRC:\n\t\toffset_sh = 3;\t/* follows flags, dstnode */\n\t\toffset_lh = 15;\t/* flgs,darea,dsubarea,did,sarea,ssub,HIORD */\n\t\tbreak;\n\n\tcase Q_AND:\n\t\t/* Inefficient because we do our Calvinball dance twice */\n\t\tb0 = gen_dnhostop(cstate, addr, Q_SRC);\n\t\tb1 = gen_dnhostop(cstate, addr, Q_DST);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\t/* Inefficient because we do our Calvinball dance twice */\n\t\tb0 = gen_dnhostop(cstate, addr, Q_SRC);\n\t\tb1 = gen_dnhostop(cstate, addr, Q_DST);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is not a valid qualifier for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is not a valid qualifier for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tdefault:\n\t\tabort();\n\t\t/*NOTREACHED*/\n\t}\n\tb0 = gen_linktype(cstate, ETHERTYPE_DN);\n\t/* Check for pad = 1, long header case */\n\ttmp = gen_mcmp(cstate, OR_LINKPL, 2, BPF_H,\n\t    (bpf_int32)ntohs(0x0681), (bpf_int32)ntohs(0x07FF));\n\tb1 = gen_cmp(cstate, OR_LINKPL, 2 + 1 + offset_lh,\n\t    BPF_H, (bpf_int32)ntohs((u_short)addr));\n\tgen_and(tmp, b1);\n\t/* Check for pad = 0, long header case */\n\ttmp = gen_mcmp(cstate, OR_LINKPL, 2, BPF_B, (bpf_int32)0x06, (bpf_int32)0x7);\n\tb2 = gen_cmp(cstate, OR_LINKPL, 2 + offset_lh, BPF_H, (bpf_int32)ntohs((u_short)addr));\n\tgen_and(tmp, b2);\n\tgen_or(b2, b1);\n\t/* Check for pad = 1, short header case */\n\ttmp = gen_mcmp(cstate, OR_LINKPL, 2, BPF_H,\n\t    (bpf_int32)ntohs(0x0281), (bpf_int32)ntohs(0x07FF));\n\tb2 = gen_cmp(cstate, OR_LINKPL, 2 + 1 + offset_sh, BPF_H, (bpf_int32)ntohs((u_short)addr));\n\tgen_and(tmp, b2);\n\tgen_or(b2, b1);\n\t/* Check for pad = 0, short header case */\n\ttmp = gen_mcmp(cstate, OR_LINKPL, 2, BPF_B, (bpf_int32)0x02, (bpf_int32)0x7);\n\tb2 = gen_cmp(cstate, OR_LINKPL, 2 + offset_sh, BPF_H, (bpf_int32)ntohs((u_short)addr));\n\tgen_and(tmp, b2);\n\tgen_or(b2, b1);\n\n\t/* Combine with test for cstate->linktype */\n\tgen_and(b0, b1);\n\treturn b1;\n}", "path": "nmap/libpcap/gencode.c", "commit_date": "2019-11-19 00:00:00", "repo_name": "nmap/nmap", "stars": 9019, "license": "other", "language": "c", "size": 110994}
{"docstring": "/*\n * support for MPLS\n *\n * The label_num_arg dance is to avoid annoying whining by compilers that\n * label_num might be clobbered by longjmp - yeah, it might, but *WHO CARES*?\n * It's not *used* after setjmp returns.\n */\n", "func_signal": "struct block *\ngen_mpls(compiler_state_t *cstate, bpf_u_int32 label_num_arg,\n    int has_label_num)", "code": "{\n\tvolatile bpf_u_int32 label_num = label_num_arg;\n\tstruct\tblock\t*b0, *b1;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n        if (cstate->label_stack_depth > 0) {\n            /* just match the bottom-of-stack bit clear */\n            b0 = gen_mcmp(cstate, OR_PREVMPLSHDR, 2, BPF_B, 0, 0x01);\n        } else {\n            /*\n             * We're not in an MPLS stack yet, so check the link-layer\n             * type against MPLS.\n             */\n            switch (cstate->linktype) {\n\n            case DLT_C_HDLC: /* fall through */\n            case DLT_EN10MB:\n            case DLT_NETANALYZER:\n            case DLT_NETANALYZER_TRANSPARENT:\n                    b0 = gen_linktype(cstate, ETHERTYPE_MPLS);\n                    break;\n\n            case DLT_PPP:\n                    b0 = gen_linktype(cstate, PPP_MPLS_UCAST);\n                    break;\n\n                    /* FIXME add other DLT_s ...\n                     * for Frame-Relay/and ATM this may get messy due to SNAP headers\n                     * leave it for now */\n\n            default:\n                    bpf_error(cstate, \"no MPLS support for %s\",\n                          pcap_datalink_val_to_description_or_dlt(cstate->linktype));\n                    /*NOTREACHED*/\n            }\n        }\n\n\t/* If a specific MPLS label is requested, check it */\n\tif (has_label_num) {\n\t\tif (label_num > 0xFFFFF) {\n\t\t\tbpf_error(cstate, \"MPLS label %u greater than maximum %u\",\n\t\t\t    label_num, 0xFFFFF);\n\t\t}\n\t\tlabel_num = label_num << 12; /* label is shifted 12 bits on the wire */\n\t\tb1 = gen_mcmp(cstate, OR_LINKPL, 0, BPF_W, (bpf_int32)label_num,\n\t\t    0xfffff000); /* only compare the first 20 bits */\n\t\tgen_and(b0, b1);\n\t\tb0 = b1;\n\t}\n\n        /*\n         * Change the offsets to point to the type and data fields within\n         * the MPLS packet.  Just increment the offsets, so that we\n         * can support a hierarchy, e.g. \"mpls 100000 && mpls 1024\" to\n         * capture packets with an outer label of 100000 and an inner\n         * label of 1024.\n         *\n         * Increment the MPLS stack depth as well; this indicates that\n         * we're checking MPLS-encapsulated headers, to make sure higher\n         * level code generators don't try to match against IP-related\n         * protocols such as Q_ARP, Q_RARP etc.\n         *\n         * XXX - this is a bit of a kludge.  See comments in gen_vlan().\n         */\n        cstate->off_nl_nosnap += 4;\n        cstate->off_nl += 4;\n        cstate->label_stack_depth++;\n\treturn (b0);\n}", "path": "nmap/libpcap/gencode.c", "commit_date": "2019-11-19 00:00:00", "repo_name": "nmap/nmap", "stars": 9019, "license": "other", "language": "c", "size": 110994}
{"docstring": "/* PF firewall log rule number */\n", "func_signal": "struct block *\ngen_pf_rnr(compiler_state_t *cstate, int rnr)", "code": "{\n\tstruct block *b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tif (cstate->linktype != DLT_PFLOG) {\n\t\tbpf_error(cstate, \"rnr supported only on PF linktype\");\n\t\t/*NOTREACHED*/\n\t}\n\n\tb0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, rulenr), BPF_W,\n\t\t (bpf_int32)rnr);\n\treturn (b0);\n}", "path": "nmap/libpcap/gencode.c", "commit_date": "2019-11-19 00:00:00", "repo_name": "nmap/nmap", "stars": 9019, "license": "other", "language": "c", "size": 110994}
{"docstring": "/*\n * \"proto\" is an Ethernet type value and for IPNET, if it is not IPv4\n * or IPv6 then we have an error.\n */\n", "func_signal": "static struct block *\ngen_ipnet_linktype(compiler_state_t *cstate, int proto)", "code": "{\n\tswitch (proto) {\n\n\tcase ETHERTYPE_IP:\n\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B, (bpf_int32)IPH_AF_INET);\n\t\t/*NOTREACHED*/\n\n\tcase ETHERTYPE_IPV6:\n\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t    (bpf_int32)IPH_AF_INET6);\n\t\t/*NOTREACHED*/\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn gen_false(cstate);\n}", "path": "nmap/libpcap/gencode.c", "commit_date": "2019-11-19 00:00:00", "repo_name": "nmap/nmap", "stars": 9019, "license": "other", "language": "c", "size": 110994}
{"docstring": "/* PF firewall log matched interface */\n", "func_signal": "struct block *\ngen_pf_ifname(compiler_state_t *cstate, const char *ifname)", "code": "{\n\tstruct block *b0;\n\tu_int len, off;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tif (cstate->linktype != DLT_PFLOG) {\n\t\tbpf_error(cstate, \"ifname supported only on PF linktype\");\n\t\t/*NOTREACHED*/\n\t}\n\tlen = sizeof(((struct pfloghdr *)0)->ifname);\n\toff = offsetof(struct pfloghdr, ifname);\n\tif (strlen(ifname) >= len) {\n\t\tbpf_error(cstate, \"ifname interface names can only be %d characters\",\n\t\t    len-1);\n\t\t/*NOTREACHED*/\n\t}\n\tb0 = gen_bcmp(cstate, OR_LINKHDR, off, (u_int)strlen(ifname),\n\t    (const u_char *)ifname);\n\treturn (b0);\n}", "path": "nmap/libpcap/gencode.c", "commit_date": "2019-11-19 00:00:00", "repo_name": "nmap/nmap", "stars": 9019, "license": "other", "language": "c", "size": 110994}
{"docstring": "/*\n * Like gen_ehostop, but for RFC 2625 IP-over-Fibre-Channel.\n * (We assume that the addresses are IEEE 48-bit MAC addresses,\n * as the RFC states.)\n */\n", "func_signal": "static struct block *\ngen_ipfchostop(compiler_state_t *cstate, const u_char *eaddr, int dir)", "code": "{\n\tregister struct block *b0, *b1;\n\n\tswitch (dir) {\n\tcase Q_SRC:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 10, 6, eaddr);\n\n\tcase Q_DST:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 2, 6, eaddr);\n\n\tcase Q_AND:\n\t\tb0 = gen_ipfchostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_ipfchostop(cstate, eaddr, Q_DST);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\tb0 = gen_ipfchostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_ipfchostop(cstate, eaddr, Q_DST);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\t}\n\tabort();\n\t/*NOTREACHED*/\n}", "path": "nmap/libpcap/gencode.c", "commit_date": "2019-11-19 00:00:00", "repo_name": "nmap/nmap", "stars": 9019, "license": "other", "language": "c", "size": 110994}
{"docstring": "/*\n * support IEEE 802.1Q VLAN trunk over ethernet\n */\n", "func_signal": "struct block *\ngen_vlan(compiler_state_t *cstate, bpf_u_int32 vlan_num, int has_vlan_tag)", "code": "{\n\tstruct\tblock\t*b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/* can't check for VLAN-encapsulated packets inside MPLS */\n\tif (cstate->label_stack_depth > 0)\n\t\tbpf_error(cstate, \"no VLAN match after MPLS\");\n\n\t/*\n\t * Check for a VLAN packet, and then change the offsets to point\n\t * to the type and data fields within the VLAN packet.  Just\n\t * increment the offsets, so that we can support a hierarchy, e.g.\n\t * \"vlan 300 && vlan 200\" to capture VLAN 200 encapsulated within\n\t * VLAN 100.\n\t *\n\t * XXX - this is a bit of a kludge.  If we were to split the\n\t * compiler into a parser that parses an expression and\n\t * generates an expression tree, and a code generator that\n\t * takes an expression tree (which could come from our\n\t * parser or from some other parser) and generates BPF code,\n\t * we could perhaps make the offsets parameters of routines\n\t * and, in the handler for an \"AND\" node, pass to subnodes\n\t * other than the VLAN node the adjusted offsets.\n\t *\n\t * This would mean that \"vlan\" would, instead of changing the\n\t * behavior of *all* tests after it, change only the behavior\n\t * of tests ANDed with it.  That would change the documented\n\t * semantics of \"vlan\", which might break some expressions.\n\t * However, it would mean that \"(vlan and ip) or ip\" would check\n\t * both for VLAN-encapsulated IP and IP-over-Ethernet, rather than\n\t * checking only for VLAN-encapsulated IP, so that could still\n\t * be considered worth doing; it wouldn't break expressions\n\t * that are of the form \"vlan and ...\" or \"vlan N and ...\",\n\t * which I suspect are the most common expressions involving\n\t * \"vlan\".  \"vlan or ...\" doesn't necessarily do what the user\n\t * would really want, now, as all the \"or ...\" tests would\n\t * be done assuming a VLAN, even though the \"or\" could be viewed\n\t * as meaning \"or, if this isn't a VLAN packet...\".\n\t */\n\tswitch (cstate->linktype) {\n\n\tcase DLT_EN10MB:\n\tcase DLT_NETANALYZER:\n\tcase DLT_NETANALYZER_TRANSPARENT:\n#if defined(SKF_AD_VLAN_TAG_PRESENT)\n\t\t/* Verify that this is the outer part of the packet and\n\t\t * not encapsulated somehow. */\n\t\tif (cstate->vlan_stack_depth == 0 && !cstate->off_linkhdr.is_variable &&\n\t\t    cstate->off_linkhdr.constant_part ==\n\t\t    cstate->off_outermostlinkhdr.constant_part) {\n\t\t\t/*\n\t\t\t * Do we need special VLAN handling?\n\t\t\t */\n\t\t\tif (cstate->bpf_pcap->bpf_codegen_flags & BPF_SPECIAL_VLAN_HANDLING)\n\t\t\t\tb0 = gen_vlan_bpf_extensions(cstate, vlan_num,\n\t\t\t\t    has_vlan_tag);\n\t\t\telse\n\t\t\t\tb0 = gen_vlan_no_bpf_extensions(cstate,\n\t\t\t\t    vlan_num, has_vlan_tag);\n\t\t} else\n#endif\n\t\t\tb0 = gen_vlan_no_bpf_extensions(cstate, vlan_num,\n\t\t\t    has_vlan_tag);\n                break;\n\n\tcase DLT_IEEE802_11:\n\tcase DLT_PRISM_HEADER:\n\tcase DLT_IEEE802_11_RADIO_AVS:\n\tcase DLT_IEEE802_11_RADIO:\n\t\tb0 = gen_vlan_no_bpf_extensions(cstate, vlan_num, has_vlan_tag);\n\t\tbreak;\n\n\tdefault:\n\t\tbpf_error(cstate, \"no VLAN support for %s\",\n\t\t      pcap_datalink_val_to_description_or_dlt(cstate->linktype));\n\t\t/*NOTREACHED*/\n\t}\n\n        cstate->vlan_stack_depth++;\n\n\treturn (b0);\n}", "path": "nmap/libpcap/gencode.c", "commit_date": "2019-11-19 00:00:00", "repo_name": "nmap/nmap", "stars": 9019, "license": "other", "language": "c", "size": 110994}
{"docstring": "/*\n * A strdup whose allocations are freed after code generation is over.\n * This is used by the lexical analyzer, so it can't longjmp; it just\n * returns NULL on an allocation error, and the callers must check\n * for it.\n */\n", "func_signal": "char *\nsdup(compiler_state_t *cstate, const char *s)", "code": "{\n\tsize_t n = strlen(s) + 1;\n\tchar *cp = newchunk_nolongjmp(cstate, n);\n\n\tif (cp == NULL)\n\t\treturn (NULL);\n\tpcap_strlcpy(cp, s, n);\n\treturn (cp);\n}", "path": "nmap/libpcap/gencode.c", "commit_date": "2019-11-19 00:00:00", "repo_name": "nmap/nmap", "stars": 9019, "license": "other", "language": "c", "size": 110994}
{"docstring": "/* Verify validity of page, see \"lockBtree\" function in SQLCipher */\n", "func_signal": "static int enpass_verify_page(unsigned char *page1)", "code": "{\n\tuint32_t pageSize;\n\tuint32_t usableSize;\n\n\t/* if (memcmp(page1, SQLITE_FILE_HEADER, 16) != 0) {\n\t\treturn -1;\n\t} */\n\n\tif (page1[19] > 2) {\n\t\treturn -1;\n\t}\n\n\tif (memcmp(&page1[21], \"\\100\\040\\040\", 3) != 0) {\n\t\treturn -1;\n\t}\n\n\tpageSize = (page1[16] << 8) | (page1[17] << 16);\n\tif (((pageSize - 1) & pageSize) != 0 || pageSize > SQLITE_MAX_PAGE_SIZE || pageSize <= 256) {\n\t\treturn -1;\n\t}\n\n\tif ((pageSize & 7) != 0) {\n\t\treturn -1;\n\t}\n\tusableSize = pageSize - page1[20];\n\n\tif (usableSize < 480) {\n\t\treturn -1;\n\t}\n\n\treturn 0; // success!\n}", "path": "john/src/enpass_fmt_plug.c", "commit_date": "2020-02-28 00:00:00", "repo_name": "openwall/john", "stars": 9010, "license": "None", "language": "c", "size": 131512}
{"docstring": "/* ------- Initialization  ------- */\n", "func_signal": "static void build_kernel()", "code": "{\n\tstatic int num_int_cand;\n\n\tchar *task = \"$JOHN/opencl/sha512_gpl_kernel.cl\";\n\tchar opt[MAX_OCLINFO_STRING_LEN];\n\n\tbitmap_size = get_bitmap_size_bits(num_loaded_hashes, gpu_id);\n\n\tif (previous_size != bitmap_size || num_int_cand != mask_int_cand.num_int_cand) {\n\t\tprevious_size = bitmap_size;\n\t\tnum_int_cand = mask_int_cand.num_int_cand;\n\n\t\trelease_kernel();\n\n\t\tsnprintf(opt, sizeof(opt), \"-DBITMAP_SIZE_MINUS1=%u\", bitmap_size - 1U);\n\n\t\tif (mask_int_cand.num_int_cand > 1)\n\t\t\tstrncat(opt, \" -DGPU_MASK_MODE\", 64U);\n\n\t\topencl_build_kernel(task, gpu_id, opt, 0);\n\n\t\t// create kernel(s) to execute\n\t\tprepare_kernel = clCreateKernel(program[gpu_id], \"kernel_prepare\",\n\t\t\t\t\t\t&ret_code);\n\t\tHANDLE_CLERROR(ret_code,\n\t\t\t       \"Error creating kernel_prepare. Double-check kernel name?\");\n\n\t\tif (salted_format)\n\t\t\tcrypt_kernel = clCreateKernel(program[gpu_id],\n\t\t\t\t\t\t      \"kernel_crypt_xsha\", &ret_code);\n\t\telse\n\t\t\tcrypt_kernel = clCreateKernel(program[gpu_id],\n\t\t\t\t\t\t      \"kernel_crypt_raw\", &ret_code);\n\t\tHANDLE_CLERROR(ret_code,\n\t\t\t       \"Error creating kernel. Double-check kernel name?\");\n\t}\n\t//Allocate bit array and pass its size to OpenCL.\n\tcreate_mask_buffers();\n}", "path": "john/src/opencl_rawsha512_gpl_fmt_plug.c", "commit_date": "2020-09-25 00:00:00", "repo_name": "openwall/john", "stars": 9010, "license": "None", "language": "c", "size": 131512}
{"docstring": "/* ------- Salt functions ------- */\n", "func_signal": "static void *get_salt(char *ciphertext)", "code": "{\n\tstatic union {\n\t\tunsigned char c[SALT_SIZE_X];\n\t\tARCH_WORD dummy;\n\t} out;\n\tchar *p;\n\tint i;\n\tciphertext += XSHA512_TAG_LENGTH;\n\tp = ciphertext;\n\tfor (i = 0; i < sizeof(out.c); i++) {\n\t\tout.c[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n\t\tp += 2;\n\t}\n\n\treturn out.c;\n}", "path": "john/src/opencl_rawsha512_gpl_fmt_plug.c", "commit_date": "2020-09-25 00:00:00", "repo_name": "openwall/john", "stars": 9010, "license": "None", "language": "c", "size": 131512}
{"docstring": "/* ------- Key functions ------- */\n", "func_signal": "static void clear_keys(void)", "code": "{\n\toffset = 0;\n\toffset_idx = 0;\n\tkey_idx = 0;\n}", "path": "john/src/opencl_rawsha512_gpl_fmt_plug.c", "commit_date": "2020-09-25 00:00:00", "repo_name": "openwall/john", "stars": 9010, "license": "None", "language": "c", "size": 131512}
{"docstring": "// Legacy codepage to UCS-2, directly into vector key buffer\n", "func_signal": "static void set_key_CP(char *_key, int index)", "code": "{\n#ifdef SIMD_COEF_32\n\tconst uchar *key = (uchar*)_key;\n\tunsigned int *keybuf_word = (unsigned int*)&saved_key[GETPOS_W32(0, index)];\n\tunsigned int len, temp2;\n\n\tlen = 0;\n\twhile((temp2 = *key++)) {\n\t\tunsigned int temp;\n\t\ttemp2 = CP_to_Unicode[temp2];\n\t\tif ((temp = *key++) && len < PLAINTEXT_LENGTH - 1)\n\t\t{\n\t\t\ttemp = CP_to_Unicode[temp];\n\t\t\ttemp2 |= (temp << 16);\n\t\t\t*keybuf_word = temp2;\n\t\t} else {\n\t\t\ttemp2 |= (0x80 << 16);\n\t\t\t*keybuf_word = temp2;\n\t\t\tlen++;\n\t\t\tgoto key_cleaning_enc;\n\t\t}\n\t\tlen += 2;\n\t\tkeybuf_word += SIMD_COEF_32;\n\t}\n\t*keybuf_word = 0x80;\n\nkey_cleaning_enc:\n\tkeybuf_word += SIMD_COEF_32;\n\twhile(*keybuf_word) {\n\t\t*keybuf_word = 0;\n\t\tkeybuf_word += SIMD_COEF_32;\n\t}\n\t((unsigned int*)saved_key)[14*SIMD_COEF_32 + (index&(SIMD_COEF_32-1)) +\n\t                           (unsigned int)index/SIMD_COEF_32*16*SIMD_COEF_32] = len << 4;\n#else\n\tsaved_len[index] = enc_to_utf16(saved_key[index],\n\t                                       PLAINTEXT_LENGTH + 1,\n\t                                       (uchar*)_key,\n\t                                       strlen(_key)) << 1;\n\tif (saved_len[index] < 0)\n\t\tsaved_len[index] = strlen16(saved_key[index]);\n#endif\n\tkeys_prepared = 0;\n}", "path": "john/src/ntlmv1_mschapv2_fmt_plug.c", "commit_date": "2020-12-03 00:00:00", "repo_name": "openwall/john", "stars": 9010, "license": "None", "language": "c", "size": 131512}
{"docstring": "// ISO-8859-1 to UCS-2, directly into vector key buffer\n", "func_signal": "static void set_key_ansi(char *_key, int index)", "code": "{\n#ifdef SIMD_COEF_32\n\tconst uchar *key = (uchar*)_key;\n\tunsigned int *keybuf_word = (unsigned int*)&saved_key[GETPOS_W32(0, index)];\n\tunsigned int len, temp2;\n\n\tlen = 0;\n\twhile((temp2 = *key++)) {\n\t\tunsigned int temp;\n\t\tif ((temp = *key++) && len < PLAINTEXT_LENGTH - 1)\n\t\t{\n\t\t\ttemp2 |= (temp << 16);\n\t\t\t*keybuf_word = temp2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttemp2 |= (0x80 << 16);\n\t\t\t*keybuf_word = temp2;\n\t\t\tlen++;\n\t\t\tgoto key_cleaning;\n\t\t}\n\t\tlen += 2;\n\t\tkeybuf_word += SIMD_COEF_32;\n\t}\n\t*keybuf_word = 0x80;\n\nkey_cleaning:\n\tkeybuf_word += SIMD_COEF_32;\n\twhile(*keybuf_word) {\n\t\t*keybuf_word = 0;\n\t\tkeybuf_word += SIMD_COEF_32;\n\t}\n\t((unsigned int*)saved_key)[14*SIMD_COEF_32 + (index&(SIMD_COEF_32-1)) +\n\t                           (unsigned int)index/SIMD_COEF_32*16*SIMD_COEF_32] = len << 4;\n#else\n#if ARCH_LITTLE_ENDIAN\n\tUTF8 *s = (UTF8*)_key;\n\tUTF16 *d = saved_key[index];\n\twhile (*s)\n\t\t*d++ = *s++;\n\t*d = 0;\n\tsaved_len[index] = (int)((char*)d - (char*)saved_key[index]);\n#else\n\tUTF8 *s = (UTF8*)_key;\n\tUTF8 *d = (UTF8*)saved_key[index];\n\twhile (*s) {\n\t\t*d++ = *s++;\n\t\t++d;\n\t}\n\t*d = 0;\n\tsaved_len[index] = (int)((char*)d - (char*)saved_key[index]);\n#endif\n#endif\n\tkeys_prepared = 0;\n}", "path": "john/src/ntlmv1_mschapv2_fmt_plug.c", "commit_date": "2020-12-03 00:00:00", "repo_name": "openwall/john", "stars": 9010, "license": "None", "language": "c", "size": 131512}
{"docstring": "/* this function converts a 'native' @dynamic= signature string into a $dynamic_6xxx$ syntax string */\n", "func_signal": "static char *Convert(char *Buf, char *ciphertext, int in_load)", "code": "{\n\tchar *cp;\n\n\tif (text_in_dynamic_format_already(pDynamic, ciphertext))\n\t\treturn ciphertext;\n\n\tcp = ciphertext;\n\tif (!strncmp(ciphertext, \"@dynamic=\", 9)) {\n\t\tif (!strncmp(ciphertext, dyna_signature, dyna_sig_len))\n\t\t\tcp = &ciphertext[dyna_sig_len];\n\t\telse {\n\t\t\tcp = strchr(&ciphertext[1], '@');\n\t\t\tif (!cp)\n\t\t\t\treturn \"*\";\n\t\t\t++cp;\n\t\t}\n\t}\n\tif (in_load)\n\t\tsnprintf(Buf, sizeof(Conv_Buf), \"$dynamic_6xxx$%s\", cp);\n\telse\n\t\tsnprintf(Buf, sizeof(Conv_Buf), \"%s%s\", dyna_hash_type, cp);\n\n\treturn Buf;\n}", "path": "john/src/dynamic_compiler_fmt_plug.c", "commit_date": "2019-04-08 00:00:00", "repo_name": "openwall/john", "stars": 9010, "license": "None", "language": "c", "size": 131512}
{"docstring": "/*\n * This function will convert long hashes, into short ones (the short is now cannonical format)\n * converts\n *   $MSCHAPv2$95a87fa62ebcd2e3c8b09e1b448a6c72$ed8cc90fd40faa2d6bcd0abd0b1f562fd777df6c5609c98b$e2ae0995eaac6ceff0d9757428b51509$lulu\n * into\n *   $MSCHAPv2$ba75eb14efbfbf25$ed8cc90fd40faa2d6bcd0abd0b1f562fd777df6c5609c98b$$\n *\n * This code was moved from get_salt().\n */\n", "func_signal": "static char *chap_long_to_short(char *ciphertext)", "code": "{\n\tstatic char Buf[CHAP_TOTAL_LENGTH+1];\t// larger than we need, but not a big deal\n\tstatic SHA_CTX ctx;\n\tunsigned char tmp[16];\n\tunsigned char digest[20];\n\tchar *pos = NULL;\n\tint i;\n\tSHA1_Init(&ctx);\n\n\t/* Peer Challenge */\n\tpos = ciphertext + FORMAT_TAG_LEN + 16*2 + 1 + 24*2 + 1; /* Skip $MSCHAPv2$, Authenticator Challenge and Response Hash */\n\n\tmemset(tmp, 0, 16);\n\tfor (i = 0; i < 16; i++)\n\t\ttmp[i] = (atoi16[ARCH_INDEX(pos[i*2])] << 4) + atoi16[ARCH_INDEX(pos[i*2+1])];\n\n\tSHA1_Update(&ctx, tmp, 16);\n\n\t/* Authenticator Challenge */\n\tpos = ciphertext + FORMAT_TAG_LEN; /* Skip $MSCHAPv2$ */\n\n\tmemset(tmp, 0, 16);\n\tfor (i = 0; i < 16; i++)\n\t\ttmp[i] = (atoi16[ARCH_INDEX(pos[i*2])] << 4) + atoi16[ARCH_INDEX(pos[i*2+1])];\n\n\tSHA1_Update(&ctx, tmp, 16);\n\n\t/* Username - Only the user name (as presented by the peer and\n\t   excluding any prepended domain name) is used as input to SHAUpdate()\n\t*/\n\tpos = ciphertext + FORMAT_TAG_LEN + 16*2 + 1 + 24*2 + 1 + 16*2 + 1; /* Skip $MSCHAPv2$, Authenticator, Response and Peer */\n\tSHA1_Update(&ctx, pos, strlen(pos));\n\n\tSHA1_Final(digest, &ctx);\n\n\t// Ok, now we re-make our ciphertext buffer, into the short cannonical form.\n\tstrcpy(Buf, FORMAT_TAG);\n\tpos = Buf + FORMAT_TAG_LEN;\n\tfor (i = 0; i < SALT_SIZE; i++) {\n\t\t//binary_salt.u8[i] = (atoi16[ARCH_INDEX(pos[i*2])] << 4) + atoi16[ARCH_INDEX(pos[i*2+1])];\n\t\tpos[(i<<1)] = itoa16[digest[i]>>4];\n\t\tpos[(i<<1)+1] = itoa16[digest[i]&0xF];\n\t}\n\tmemcpy(&pos[16], &ciphertext[42], CIPHERTEXT_LENGTH+2);\n\tpos[16+CIPHERTEXT_LENGTH+2] = '$';\n\tpos[16+CIPHERTEXT_LENGTH+3] = 0;\n\t//printf(\"short=%s  original=%s\\n\", Buf, ciphertext);\n\treturn Buf;\n}", "path": "john/src/ntlmv1_mschapv2_fmt_plug.c", "commit_date": "2020-12-03 00:00:00", "repo_name": "openwall/john", "stars": 9010, "license": "None", "language": "c", "size": 131512}
{"docstring": "/*\nstatic void prepare_bitmap_1(cl_ulong bmp_sz, cl_uint **bitmap_ptr, uint32_t num_loaded_hashes)\n{\n\tunsigned int i;\n\tMEM_FREE(*bitmap_ptr);\n\t*bitmap_ptr = (cl_uint*) mem_calloc((bmp_sz >> 5), sizeof(cl_uint));\n\n\tfor (i = 0; i < num_loaded_hashes; i++) {\n\t\tunsigned int bmp_idx = loaded_hashes[4 * i + 3] & (bmp_sz - 1);\n\t\t(*bitmap_ptr)[bmp_idx >> 5] |= (1U << (bmp_idx & 31));\n\t}\n}*/\n", "func_signal": "static void select_bitmap(unsigned int num_loaded_hashes)", "code": "{\n\tcl_ulong max_local_mem_sz_bytes = 0;\n\n\tHANDLE_CLERROR(clGetDeviceInfo(devices[gpu_id], CL_DEVICE_LOCAL_MEM_SIZE,\n\t\tsizeof(cl_ulong), &max_local_mem_sz_bytes, 0),\n\t\t\"failed to get CL_DEVICE_LOCAL_MEM_SIZE.\");\n\n\tif (num_loaded_hashes <= 5100) {\n\t\tif (amd_gcn_10(device_info[gpu_id]) ||\n\t\t\tamd_vliw4(device_info[gpu_id]))\n\t\t\tbitmap_size_bits = 512 * 1024;\n\n\t\telse\n\t\t\tbitmap_size_bits = 256 * 1024;\n\t}\n\n\telse if (num_loaded_hashes <= 10100) {\n\t\tif (amd_gcn_10(device_info[gpu_id]) ||\n\t\t\tamd_vliw4(device_info[gpu_id]))\n\t\t\tbitmap_size_bits = 512 * 1024;\n\n\t\telse\n\t\t\tbitmap_size_bits = 256 * 1024;\n\n\t}\n\n\telse if (num_loaded_hashes <= 20100) {\n\t\tif (amd_gcn_10(device_info[gpu_id]) ||\n\t\t\tamd_vliw4(device_info[gpu_id]))\n\t\t\tbitmap_size_bits = 1024 * 1024;\n\n\t\telse\n\t\t\tbitmap_size_bits = 512 * 1024;\n\n\t}\n\n\telse if (num_loaded_hashes <= 250100)\n\t\tbitmap_size_bits = 2048 * 1024;\n\n\telse if (num_loaded_hashes <= 1100100) {\n\t\tif (!amd_gcn_11(device_info[gpu_id]))\n\t\t\tbitmap_size_bits = 4096 * 1024;\n\n\t\telse\n\t\t\tbitmap_size_bits = 2048 * 1024;\n\t}\n\telse {\n\t\tfprintf(stderr, \"Too many hashes (%d), max is 1100100\\n\",\n\t\t        num_loaded_hashes);\n\t\terror();\n\t}\n\n\tprepare_bitmap_4(bitmap_size_bits, &bitmaps, num_loaded_hashes);\n}", "path": "john/src/opencl_ntlmv2_fmt_plug.c", "commit_date": "2020-12-03 00:00:00", "repo_name": "openwall/john", "stars": 9010, "license": "None", "language": "c", "size": 131512}
{"docstring": "/* Either the cipherext already contains the MSCHAPv2 Challenge (4 Bytes) or\n   we are going to calculate it via:\n   sha1(|Peer/Client Challenge (8 Bytes)|Authenticator/Server Challenge (8 Bytes)|Username (<=256)|)\n\n   NOTE, we now ONLY call this function the the short form. The long form gets converted into the short\n   form in either prepare or split function.  The short form is cannonical form (Change made July, 2014, JimF)\n*/\n", "func_signal": "static void *chap_get_salt(char *ciphertext)", "code": "{\n\tstatic unsigned char *binary_salt;\n\tunsigned char digest[20];\n\n\tif (!binary_salt)\n\t\tbinary_salt = mem_alloc_tiny(SALT_SIZE, MEM_ALIGN_WORD);\n\n\t/* This is just to silence scan-build. It will never happen.\n\t   It is unclear why only this format gave warnings, many others do\n\t   similar things. */\n\tif (!ciphertext)\n\t\treturn ciphertext;\n\n\tmemset(binary_salt, 0, SALT_SIZE);\n\tmemset(digest, 0, 20);\n\n\tchap_get_challenge(ciphertext, binary_salt);\n\treturn (void*)binary_salt;\n}", "path": "john/src/ntlmv1_mschapv2_fmt_plug.c", "commit_date": "2020-12-03 00:00:00", "repo_name": "openwall/john", "stars": 9010, "license": "None", "language": "c", "size": 131512}
{"docstring": "/* ------- Reset functions ------- */\n", "func_signal": "static void tune(struct db_main *db)", "code": "{\n\tchar *tmp_value;\n\tsize_t gws_limit;\n\tint autotune_limit = 500;\n\n\tif ((tmp_value = getenv(\"_GPU_AUTOTUNE_LIMIT\")))\n\t\tautotune_limit = atoi(tmp_value);\n\n\t// Auto-tune / Benckmark / Self-test.\n\tgws_limit = MIN((0xf << 22) * 4 / BUFFER_SIZE,\n\t\t\tget_max_mem_alloc_size(gpu_id) / BUFFER_SIZE);\n\n\tif (options.flags & FLG_MASK_CHK)\n\t\tgws_limit = MIN(gws_limit,\n\t\t\tget_max_mem_alloc_size(gpu_id) /\n\t\t\t(mask_int_cand.num_int_cand  * 3 * sizeof(uint32_t)));\n\n\t//Initialize openCL tuning (library) for this format.\n\topencl_init_auto_setup(SEED, 0, NULL,\n\t\t\t       warn, 3, self, create_clobj, release_clobj,\n\t\t\t       2 * BUFFER_SIZE, gws_limit, db);\n\n\t//Auto tune execution from shared/included code.\n\tautotune_run(self, 1, gws_limit, autotune_limit);\n}", "path": "john/src/opencl_rawsha512_gpl_fmt_plug.c", "commit_date": "2020-09-25 00:00:00", "repo_name": "openwall/john", "stars": 9010, "license": "None", "language": "c", "size": 131512}
{"docstring": "// TODO: handle BE systems\n", "func_signal": "static int crypt_all(int *pcount, struct db_salt *salt)", "code": "{\n\tint i, result, curr_setting;\n\tstatic int warning_curr_setting16 = 0;\n\tstatic int warning_target_setting = 0;\n\n\tstatic unsigned char salt_buf[17]; // salt to send to device\n\tBF_salt *BF_salt = salt->salt;\n\n\tif (salt->count > bitstream.cmp_entries_max && !device_nocompar_mode) {\n\t\tfprintf(stderr, \"Warning: salt with %d hashes, onboard comparators \"\n\t\t\t\"support up to %d hashes/salt, turned off\\n\",\n\t\t\tsalt->count, bitstream.cmp_entries_max);\n\t\tjtr_device_list_set_app_mode(0x40);\n\t\tdevice_nocompar_mode = 1;\n\t}\n\n\t// It requires 16 bytes salt and 1 char subtype in network byte order\n\tfor (i = 0; i < 4; i++)\n\t\t((uint32_t *)(salt_buf))[i] = BF_salt->salt[i];\n\tsalt_buf[16] = BF_salt->subtype;\n\n\tif (device_nocompar_mode)\n\t\tcmp_config_nocompar_new(salt, salt_buf, 17);\n\telse\n\t\tcmp_config_new(salt, salt_buf, 17);\n\n\tcurr_setting = get_setting_by_cost(salt->cost[0]);\n\n\tif (!warning_curr_setting16 && curr_setting >= 16) {\n\t\tfprintf(stderr, \"Warning: hash with setting=%d, computation\"\n\t\t\t\" is going to be very slow, timeout is possible,\"\n\t\t\t\" consider to increase\"\n\t\t\t\" device_format.c:DEVICE_TASK_TIMEOUT\\n\", curr_setting);\n\t\tfprintf(stderr, \"Recommended DEVICE_TASK_TIMEOUT value for\"\n\t\t\t\" setting %d: %d\\n\", curr_setting,\n\t\t\tcurr_setting == 16 ? 10 :\n\t\t\tcurr_setting == 17 ? 20 :\n\t\t\tcurr_setting == 18 ? 35 :\n\t\t\t70);\n\t\twarning_curr_setting16 = 1;\n\t}\n\n\tif (!warning_target_setting && !bench_or_test_running\n\t\t\t&& (curr_setting > target_setting + 2\n\t\t\t|| curr_setting < target_setting - 2)\n\t) {\n\t\tfprintf(stderr, \"Warning: TargetSetting=%d, processing\"\n\t\t\t\" hash with setting=%d, expecting suboptimal performance or\"\n\t\t\t\" timeout, consider to adjust TargetSetting in john.conf\\n\",\n\t\t\ttarget_setting, curr_setting);\n\t\twarning_target_setting = 1;\n\t}\n\n\tresult = device_format_crypt_all(pcount, salt);\n\treturn result;\n}", "path": "john/src/ztex_bcrypt.c", "commit_date": "2020-11-01 00:00:00", "repo_name": "openwall/john", "stars": 9010, "license": "None", "language": "c", "size": 131512}
{"docstring": "/* ------- Helper functions ------- */\n", "func_signal": "static size_t get_task_max_work_group_size()", "code": "{\n\tsize_t s;\n\n\ts = autotune_get_task_max_work_group_size(FALSE, 0, crypt_kernel);\n\ts = MIN(s, autotune_get_task_max_work_group_size(FALSE, 0,\n\t        prepare_kernel));\n\treturn MIN(s, 512);\n}", "path": "john/src/opencl_rawsha512_gpl_fmt_plug.c", "commit_date": "2020-09-25 00:00:00", "repo_name": "openwall/john", "stars": 9010, "license": "None", "language": "c", "size": 131512}
{"docstring": "// UTF-8 to UCS-2, directly into vector key buffer\n", "func_signal": "static void set_key_utf8(char *_key, int index)", "code": "{\n#ifdef SIMD_COEF_32\n\tconst UTF8 *source = (UTF8*)_key;\n\tunsigned int *keybuf_word = (unsigned int*)&saved_key[GETPOS_W32(0, index)];\n\tUTF32 chl, chh = 0x80;\n\tunsigned int len = 0;\n\n\twhile (*source) {\n\t\tchl = *source;\n\t\tif (chl >= 0xC0) {\n\t\t\tunsigned int extraBytesToRead;\n\n\t\t\textraBytesToRead = opt_trailingBytesUTF8[chl & 0x3f];\n\t\t\tswitch (extraBytesToRead) {\n#if NT_FULL_UNICODE\n\t\t\tcase 3:\n\t\t\t\t++source;\n\t\t\t\tif (*source) {\n\t\t\t\t\tchl <<= 6;\n\t\t\t\t\tchl += *source;\n\t\t\t\t} else\n\t\t\t\t\tgoto bailout;\n#endif\n\t\t\tcase 2:\n\t\t\t\t++source;\n\t\t\t\tif (*source) {\n\t\t\t\t\tchl <<= 6;\n\t\t\t\t\tchl += *source;\n\t\t\t\t} else\n\t\t\t\t\tgoto bailout;\n\t\t\tcase 1:\n\t\t\t\t++source;\n\t\t\t\tif (*source) {\n\t\t\t\t\tchl <<= 6;\n\t\t\t\t\tchl += *source;\n\t\t\t\t} else\n\t\t\t\t\tgoto bailout;\n\t\t\tcase 0:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto bailout;\n\t\t\t}\n\t\t\tchl -= offsetsFromUTF8[extraBytesToRead];\n\t\t}\n\t\tsource++;\n\t\tlen++;\n#if NT_FULL_UNICODE\n\t\tif (chl > UNI_MAX_BMP) {\n\t\t\tif (len == PLAINTEXT_LENGTH) {\n\t\t\t\tchh = 0x80;\n\t\t\t\t*keybuf_word = (chh << 16) | chl;\n\t\t\t\tkeybuf_word += SIMD_COEF_32;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t#define halfBase 0x0010000UL\n\t\t\t#define halfShift 10\n\t\t\t#define halfMask 0x3FFUL\n\t\t\t#define UNI_SUR_HIGH_START  (UTF32)0xD800\n\t\t\t#define UNI_SUR_LOW_START   (UTF32)0xDC00\n\t\t\tchl -= halfBase;\n\t\t\tchh = (UTF16)((chl & halfMask) + UNI_SUR_LOW_START);;\n\t\t\tchl = (UTF16)((chl >> halfShift) + UNI_SUR_HIGH_START);\n\t\t\tlen++;\n\t\t} else\n#endif\n\t\tif (*source && len < PLAINTEXT_LENGTH) {\n\t\t\tchh = *source;\n\t\t\tif (chh >= 0xC0) {\n\t\t\t\tunsigned int extraBytesToRead =\n\t\t\t\t\topt_trailingBytesUTF8[chh & 0x3f];\n\t\t\t\tswitch (extraBytesToRead) {\n#if NT_FULL_UNICODE\n\t\t\t\tcase 3:\n\t\t\t\t\t++source;\n\t\t\t\t\tif (*source) {\n\t\t\t\t\t\tchl <<= 6;\n\t\t\t\t\t\tchl += *source;\n\t\t\t\t\t} else\n\t\t\t\t\t\tgoto bailout;\n#endif\n\t\t\t\tcase 2:\n\t\t\t\t\t++source;\n\t\t\t\t\tif (*source) {\n\t\t\t\t\t\tchh <<= 6;\n\t\t\t\t\t\tchh += *source;\n\t\t\t\t\t} else\n\t\t\t\t\t\tgoto bailout;\n\t\t\t\tcase 1:\n\t\t\t\t\t++source;\n\t\t\t\t\tif (*source) {\n\t\t\t\t\t\tchh <<= 6;\n\t\t\t\t\t\tchh += *source;\n\t\t\t\t\t} else\n\t\t\t\t\t\tgoto bailout;\n\t\t\t\tcase 0:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tgoto bailout;\n\t\t\t\t}\n\t\t\t\tchh -= offsetsFromUTF8[extraBytesToRead];\n\t\t\t}\n\t\t\tsource++;\n\t\t\tlen++;\n\t\t} else {\n\t\t\tchh = 0x80;\n\t\t\t*keybuf_word = (chh << 16) | chl;\n\t\t\tkeybuf_word += SIMD_COEF_32;\n\t\t\tbreak;\n\t\t}\n\t\t*keybuf_word = (chh << 16) | chl;\n\t\tkeybuf_word += SIMD_COEF_32;\n\t}\n\tif (chh != 0x80 || len == 0) {\n\t\t*keybuf_word = 0x80;\n\t\tkeybuf_word += SIMD_COEF_32;\n\t}\n\nbailout:\n\twhile(*keybuf_word) {\n\t\t*keybuf_word = 0;\n\t\tkeybuf_word += SIMD_COEF_32;\n\t}\n\t((unsigned int*)saved_key)[14*SIMD_COEF_32 + (index&(SIMD_COEF_32-1)) +\n\t                           (unsigned int)index/SIMD_COEF_32*16*SIMD_COEF_32] = len << 4;\n#else\n\tsaved_len[index] = utf8_to_utf16(saved_key[index],\n\t                                        PLAINTEXT_LENGTH + 1,\n\t                                        (uchar*)_key,\n\t                                        strlen(_key)) << 1;\n\tif (saved_len[index] < 0)\n\t\tsaved_len[index] = strlen16(saved_key[index]);\n#endif\n\tkeys_prepared = 0;\n}", "path": "john/src/ntlmv1_mschapv2_fmt_plug.c", "commit_date": "2020-12-03 00:00:00", "repo_name": "openwall/john", "stars": 9010, "license": "None", "language": "c", "size": 131512}
{"docstring": "// we do not have a CPUID for non linux. Simply return that we have all required switches.\n// if the user runs this on a machine which the SIMD is there, but FAILS to be new enough\n// then they will have to add the --disable-simd flag to configure.\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n\tif (argc==2) {\n\t\tif (!strcmp(argv[1], \"PPC_FEATURE_HAS_ALTIVEC\") ||\n\t\t    !strcmp(argv[1], \"PPC_FEATURE_HAS_VSX\") ||\n\t\t    !strcmp(argv[1], \"PPC_FEATURE2_ARCH_2_07\"))\n\t\t    return !!printf (\"1\\n\");\n\t}\n\tprintf (\"This program only returns meaningful data on a Linux system\\n\");\n\treturn 0;\n}", "path": "john/src/ppc_cpuid.c", "commit_date": "2017-12-14 00:00:00", "repo_name": "openwall/john", "stars": 9010, "license": "None", "language": "c", "size": 131512}
{"docstring": "/* ------- Create and destroy necessary objects ------- */\n", "func_signal": "static void create_mask_buffers()", "code": "{\n\trelease_mask_buffers();\n\n\tsaved_bitmap = (uint32_t *)\n\t\tmem_alloc((bitmap_size / 32 + 1) * sizeof(uint32_t));\n\tbuffer_bitmap = clCreateBuffer(context[gpu_id], CL_MEM_WRITE_ONLY,\n\t\t(bitmap_size / 32 + 1) * sizeof(uint32_t), NULL, &ret_code);\n\tHANDLE_CLERROR(ret_code, \"Error creating buffer argument buffer_bitmap\");\n\n\t//Set crypt kernel arguments\n\tHANDLE_CLERROR(clSetKernelArg(crypt_kernel, 7, sizeof(buffer_bitmap),\n\t                              (void *)&buffer_bitmap), \"Error setting argument 7\");\n}", "path": "john/src/opencl_rawsha512_gpl_fmt_plug.c", "commit_date": "2020-09-25 00:00:00", "repo_name": "openwall/john", "stars": 9010, "license": "None", "language": "c", "size": 131512}
{"docstring": "// Get the key back from the key buffer, from UCS-2\n", "func_signal": "static char *get_key(int index)", "code": "{\n#ifdef SIMD_COEF_32\n\tunsigned int *keybuf_word = (unsigned int*)&saved_key[GETPOS_W32(0, index)];\n\tstatic UTF16 key[PLAINTEXT_LENGTH + 1];\n\tunsigned int md4_size=0;\n\tunsigned int i=0;\n\n\tfor (; md4_size < PLAINTEXT_LENGTH; i += SIMD_COEF_32, md4_size++)\n\t{\n#if ARCH_LITTLE_ENDIAN==1\n\t\tkey[md4_size] = keybuf_word[i];\n\t\tkey[md4_size+1] = keybuf_word[i] >> 16;\n\t\tif (key[md4_size] == 0x80 && key[md4_size+1] == 0) {\n\t\t\tkey[md4_size] = 0;\n\t\t\tbreak;\n\t\t}\n\t\t++md4_size;\n\t\tif (key[md4_size] == 0x80 &&\n\t\t    ((keybuf_word[i+SIMD_COEF_32]&0xFFFF) == 0 ||\n\t\t     md4_size == PLAINTEXT_LENGTH))\n\t\t{\n\t\t\tkey[md4_size] = 0;\n\t\t\tbreak;\n\t\t}\n#else\n\t\tunsigned int INWORD = JOHNSWAP(keybuf_word[i]);\n\t\tkey[md4_size] = INWORD >> 16;\n\t\tkey[md4_size+1] = INWORD;\n\t\tif (key[md4_size] == 0x8000 && key[md4_size+1] == 0) {\n\t\t\tkey[md4_size] = 0;\n\t\t\tbreak;\n\t\t}\n\t\t++md4_size;\n\t\tif (key[md4_size] == 0x8000 && (md4_size == PLAINTEXT_LENGTH ||\n\t\t    (keybuf_word[i+SIMD_COEF_32]&0xFFFF0000) == 0))\n\t\t{\n\t\t\tkey[md4_size] = 0;\n\t\t\tbreak;\n\t\t}\n#endif\n\t}\n\treturn (char*)utf16_to_enc(key);\n#else\n\treturn (char*)utf16_to_enc(saved_key[index]);\n#endif\n}", "path": "john/src/ntlmv1_mschapv2_fmt_plug.c", "commit_date": "2020-12-03 00:00:00", "repo_name": "openwall/john", "stars": 9010, "license": "None", "language": "c", "size": 131512}
{"docstring": "/* ------- Crypt function ------- */\n", "func_signal": "static int crypt_all(int *pcount, struct db_salt *_salt)", "code": "{\n\tconst int count = *pcount;\n\tsize_t gws;\n\tsize_t *lws = local_work_size ? &local_work_size : NULL;\n\n\tgws = GET_NEXT_MULTIPLE(count, local_work_size);\n\n\t//Check if any password was cracked and reload (if necessary)\n\tif (num_loaded_hashes != get_num_loaded_hashes())\n\t\tload_hash();\n\n\tBENCH_CLERROR(clEnqueueNDRangeKernel(queue[gpu_id], prepare_kernel, 1,\n\t                                     NULL, &gws, lws, 0, NULL, multi_profilingEvent[0]),\n\t              \"failed in clEnqueueNDRangeKernel I\");\n\n\t//Send data to device.\n\tif (new_keys && key_idx > offset)\n\t\tBENCH_CLERROR(clEnqueueWriteBuffer(queue[gpu_id], pass_buffer,\n\t\t                                   CL_FALSE, sizeof(uint32_t) * offset,\n\t\t                                   sizeof(uint32_t) * (key_idx - offset), plaintext + offset, 0,\n\t\t                                   NULL, multi_profilingEvent[1]),\n\t\t              \"failed in clEnqueueWriteBuffer pass_buffer\");\n\n\tBENCH_CLERROR(clEnqueueWriteBuffer(queue[gpu_id], idx_buffer, CL_FALSE,\n\t                                   sizeof(uint32_t) * offset,\n\t                                   sizeof(uint32_t) * (gws - offset),\n\t                                   saved_idx + offset, 0, NULL, multi_profilingEvent[2]),\n\t              \"failed in clEnqueueWriteBuffer idx_buffer\");\n\n\tif (new_keys && mask_int_cand.num_int_cand > 1) {\n\t\tBENCH_CLERROR(clEnqueueWriteBuffer(queue[gpu_id], buffer_int_key_loc,\n\t\t                                   CL_FALSE, 0, 4 * gws, saved_int_key_loc, 0, NULL,\n\t\t                                   multi_profilingEvent[5]),\n\t\t              \"failed in clEnqueueWriteBuffer buffer_int_key_loc\");\n\n\t\tBENCH_CLERROR(clEnqueueWriteBuffer(queue[gpu_id], buffer_int_keys,\n\t\t                                   CL_FALSE, 0, 4 * mask_int_cand.num_int_cand,\n\t\t                                   mask_int_cand.int_cand, 0, NULL, multi_profilingEvent[6]),\n\t\t              \"failed in clEnqueueWriteBuffer buffer_int_keys\");\n\t}\n\t//Enqueue the kernel\n\tBENCH_CLERROR(clEnqueueNDRangeKernel(queue[gpu_id], crypt_kernel, 1, NULL,\n\t                                     &gws, lws, 0, NULL, multi_profilingEvent[3]),\n\t              \"failed in clEnqueueNDRangeKernel\");\n\n\t//Possible cracked hashes\n\tBENCH_CLERROR(clEnqueueReadBuffer(queue[gpu_id], buffer_hash_ids, CL_FALSE,\n\t                                  0, sizeof(uint32_t), hash_ids,\n\t                                  0, NULL, multi_profilingEvent[4]),\n\t              \"failed in reading data back buffer_hash_ids\");\n\n\t//Do the work\n\tBENCH_CLERROR(clFinish(queue[gpu_id]), \"failed in clFinish\");\n\tnew_keys = 0;\n\n#ifdef DEBUG\n\tif (hash_ids[0])\n\t\tfprintf(stderr, \"Some checks are going to be done on CPU: %u: %1.4f%%\\n\", hash_ids[0],\n\t\t\t((double) hash_ids[0]) / (global_work_size * mask_int_cand.num_int_cand) * 100);\n#endif\n\tif (hash_ids[0] > global_work_size * mask_int_cand.num_int_cand) {\n\t\tfprintf(stderr, \"Error, crypt_all() kernel: %u.\\n\", hash_ids[0]);\n\t\terror();\n\t}\n\n\tif (hash_ids[0]) {\n\t\tBENCH_CLERROR(clEnqueueReadBuffer(queue[gpu_id], buffer_hash_ids, CL_FALSE,\n\t\t\t0, (hash_ids[0] * 3 * sizeof(uint32_t) + sizeof(uint32_t)), hash_ids,\n\t\t\t\t\t\t  0, NULL, NULL),\n\t\t\t      \"failed in reading data back buffer_hash_ids\");\n\n\t\t//Do the work\n\t\tBENCH_CLERROR(clFinish(queue[gpu_id]), \"failed in clFinish\");\n\t}\n\t*pcount *= mask_int_cand.num_int_cand;\n\treturn hash_ids[0];\n}", "path": "john/src/opencl_rawsha512_gpl_fmt_plug.c", "commit_date": "2020-09-25 00:00:00", "repo_name": "openwall/john", "stars": 9010, "license": "None", "language": "c", "size": 131512}
{"docstring": "/* Use only for smaller bitmaps < 16MB */\n", "func_signal": "static void prepare_bitmap_4(cl_ulong bmp_sz, cl_uint **bitmap_ptr, uint32_t num_loaded_hashes)", "code": "{\n\tunsigned int i;\n\tMEM_FREE(*bitmap_ptr);\n\t*bitmap_ptr = (cl_uint*) mem_calloc((bmp_sz >> 3), sizeof(cl_uint));\n\n\tfor (i = 0; i < num_loaded_hashes; i++) {\n\t\tunsigned int bmp_idx = loaded_hashes[4 * i + 3] & (bmp_sz - 1);\n\t\t(*bitmap_ptr)[bmp_idx >> 5] |= (1U << (bmp_idx & 31));\n\n\t\tbmp_idx = loaded_hashes[4 * i + 2] & (bmp_sz - 1);\n\t\t(*bitmap_ptr)[(bmp_sz >> 5) + (bmp_idx >> 5)] |=\n\t\t\t(1U << (bmp_idx & 31));\n\n\t\tbmp_idx = loaded_hashes[4 * i + 1] & (bmp_sz - 1);\n\t\t(*bitmap_ptr)[(bmp_sz >> 4) + (bmp_idx >> 5)] |=\n\t\t\t(1U << (bmp_idx & 31));\n\n\t\tbmp_idx = loaded_hashes[4 * i] & (bmp_sz - 1);\n\t\t(*bitmap_ptr)[(bmp_sz >> 5) * 3 + (bmp_idx >> 5)] |=\n\t\t\t(1U << (bmp_idx & 31));\n\t}\n}", "path": "john/src/opencl_ntlmv2_fmt_plug.c", "commit_date": "2020-12-03 00:00:00", "repo_name": "openwall/john", "stars": 9010, "license": "None", "language": "c", "size": 131512}
{"docstring": "/* ------- Send hashes to crack (binary) to GPU ------- */\n", "func_signal": "static void load_hash()", "code": "{\n\tnum_loaded_hashes = get_num_loaded_hashes();\n\n\tprepare_bit_array();\n\n\tHANDLE_CLERROR(clEnqueueWriteBuffer(queue[gpu_id], buffer_bitmap, CL_TRUE, 0,\n\t\t(bitmap_size / 32 + 1) * sizeof(uint32_t),\n\t        saved_bitmap, 0, NULL, NULL),\n\t        \"failed in clEnqueueWriteBuffer buffer_bitmap\");\n\n\tHANDLE_CLERROR(clFinish(queue[gpu_id]), \"failed in clFinish\");\n}", "path": "john/src/opencl_rawsha512_gpl_fmt_plug.c", "commit_date": "2020-09-25 00:00:00", "repo_name": "openwall/john", "stars": 9010, "license": "None", "language": "c", "size": 131512}
{"docstring": "/* Primary Update */\n", "func_signal": "static BOOL update_message_DstBlt(rdpContext* context, const DSTBLT_ORDER* dstBlt)", "code": "{\n\tDSTBLT_ORDER* wParam;\n\n\tif (!context || !context->update || !dstBlt)\n\t\treturn FALSE;\n\n\twParam = (DSTBLT_ORDER*)malloc(sizeof(DSTBLT_ORDER));\n\n\tif (!wParam)\n\t\treturn FALSE;\n\n\tCopyMemory(wParam, dstBlt, sizeof(DSTBLT_ORDER));\n\treturn MessageQueue_Post(context->update->queue, (void*)context,\n\t                         MakeMessageId(PrimaryUpdate, DstBlt), (void*)wParam, NULL);\n}", "path": "FreeRDP/libfreerdp/core/message.c", "commit_date": "2020-08-10 00:00:00", "repo_name": "FreeRDP/FreeRDP", "stars": 9906, "license": "apache-2.0", "language": "c", "size": 66959}
{"docstring": "/* Window Update */\n", "func_signal": "static BOOL update_message_WindowCreate(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                        const WINDOW_STATE_ORDER* windowState)", "code": "{\n\tWINDOW_ORDER_INFO* wParam;\n\tWINDOW_STATE_ORDER* lParam;\n\n\tif (!context || !context->update || !orderInfo || !windowState)\n\t\treturn FALSE;\n\n\twParam = (WINDOW_ORDER_INFO*)malloc(sizeof(WINDOW_ORDER_INFO));\n\n\tif (!wParam)\n\t\treturn FALSE;\n\n\tCopyMemory(wParam, orderInfo, sizeof(WINDOW_ORDER_INFO));\n\tlParam = (WINDOW_STATE_ORDER*)malloc(sizeof(WINDOW_STATE_ORDER));\n\n\tif (!lParam)\n\t{\n\t\tfree(wParam);\n\t\treturn FALSE;\n\t}\n\n\tCopyMemory(lParam, windowState, sizeof(WINDOW_STATE_ORDER));\n\treturn MessageQueue_Post(context->update->queue, (void*)context,\n\t                         MakeMessageId(WindowUpdate, WindowCreate), (void*)wParam,\n\t                         (void*)lParam);\n}", "path": "FreeRDP/libfreerdp/core/message.c", "commit_date": "2020-08-10 00:00:00", "repo_name": "FreeRDP/FreeRDP", "stars": 9906, "license": "apache-2.0", "language": "c", "size": 66959}
{"docstring": "/*\n * Unnamed pipe\n */\n", "func_signal": "BOOL CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes,\n                DWORD nSize)", "code": "{\n\tint pipe_fd[2];\n\tWINPR_PIPE* pReadPipe;\n\tWINPR_PIPE* pWritePipe;\n\n\tWINPR_UNUSED(lpPipeAttributes);\n\tWINPR_UNUSED(nSize);\n\n\tpipe_fd[0] = -1;\n\tpipe_fd[1] = -1;\n\n\tif (pipe(pipe_fd) < 0)\n\t{\n\t\tWLog_ERR(TAG, \"failed to create pipe\");\n\t\treturn FALSE;\n\t}\n\n\tpReadPipe = (WINPR_PIPE*)calloc(1, sizeof(WINPR_PIPE));\n\tpWritePipe = (WINPR_PIPE*)calloc(1, sizeof(WINPR_PIPE));\n\n\tif (!pReadPipe || !pWritePipe)\n\t{\n\t\tfree(pReadPipe);\n\t\tfree(pWritePipe);\n\t\treturn FALSE;\n\t}\n\n\tpReadPipe->fd = pipe_fd[0];\n\tpWritePipe->fd = pipe_fd[1];\n\tWINPR_HANDLE_SET_TYPE_AND_MODE(pReadPipe, HANDLE_TYPE_ANONYMOUS_PIPE, WINPR_FD_READ);\n\tpReadPipe->ops = &ops;\n\t*((ULONG_PTR*)hReadPipe) = (ULONG_PTR)pReadPipe;\n\tWINPR_HANDLE_SET_TYPE_AND_MODE(pWritePipe, HANDLE_TYPE_ANONYMOUS_PIPE, WINPR_FD_READ);\n\tpWritePipe->ops = &ops;\n\t*((ULONG_PTR*)hWritePipe) = (ULONG_PTR)pWritePipe;\n\treturn TRUE;\n}", "path": "FreeRDP/winpr/libwinpr/pipe/pipe.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "FreeRDP/FreeRDP", "stars": 9906, "license": "apache-2.0", "language": "c", "size": 66959}
{"docstring": "/* Event Queue */\n", "func_signal": "static int input_message_free_input_class(wMessage* msg, int type)", "code": "{\n\tint status = 0;\n\n\tWINPR_UNUSED(msg);\n\n\tswitch (type)\n\t{\n\t\tcase Input_SynchronizeEvent:\n\t\t\tbreak;\n\n\t\tcase Input_KeyboardEvent:\n\t\t\tbreak;\n\n\t\tcase Input_UnicodeKeyboardEvent:\n\t\t\tbreak;\n\n\t\tcase Input_MouseEvent:\n\t\t\tbreak;\n\n\t\tcase Input_ExtendedMouseEvent:\n\t\t\tbreak;\n\n\t\tcase Input_FocusInEvent:\n\t\t\tbreak;\n\n\t\tcase Input_KeyboardPauseEvent:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tstatus = -1;\n\t\t\tbreak;\n\t}\n\n\treturn status;\n}", "path": "FreeRDP/libfreerdp/core/message.c", "commit_date": "2020-08-10 00:00:00", "repo_name": "FreeRDP/FreeRDP", "stars": 9906, "license": "apache-2.0", "language": "c", "size": 66959}
{"docstring": "/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\n", "func_signal": "static UINT wf_cliprdr_monitor_ready(CliprdrClientContext* context,\n                                     const CLIPRDR_MONITOR_READY* monitorReady)", "code": "{\n\tUINT rc;\n\twfClipboard* clipboard = (wfClipboard*)context->custom;\n\n\tif (!context || !monitorReady)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tclipboard->sync = TRUE;\n\trc = wf_cliprdr_send_client_capabilities(clipboard);\n\n\tif (rc != CHANNEL_RC_OK)\n\t\treturn rc;\n\n\treturn cliprdr_send_format_list(clipboard);\n}", "path": "FreeRDP/client/Windows/wf_cliprdr.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "FreeRDP/FreeRDP", "stars": 9906, "license": "apache-2.0", "language": "c", "size": 66959}
{"docstring": "/**\n * Named pipe\n */\n", "func_signal": "static void winpr_unref_named_pipe(WINPR_NAMED_PIPE* pNamedPipe)", "code": "{\n\tsize_t index;\n\tNamedPipeServerSocketEntry* baseSocket;\n\n\tif (!pNamedPipe)\n\t\treturn;\n\n\tassert(pNamedPipe->name);\n\tassert(g_NamedPipeServerSockets);\n\t// WLog_VRB(TAG, \"%p (%s)\", (void*) pNamedPipe, pNamedPipe->name);\n\tArrayList_Lock(g_NamedPipeServerSockets);\n\n\tfor (index = 0; index < ArrayList_Count(g_NamedPipeServerSockets); index++)\n\t{\n\t\tbaseSocket =\n\t\t    (NamedPipeServerSocketEntry*)ArrayList_GetItem(g_NamedPipeServerSockets, index);\n\t\tassert(baseSocket->name);\n\n\t\tif (!strcmp(baseSocket->name, pNamedPipe->name))\n\t\t{\n\t\t\tassert(baseSocket->references > 0);\n\t\t\tassert(baseSocket->serverfd != -1);\n\n\t\t\tif (--baseSocket->references == 0)\n\t\t\t{\n\t\t\t\t// WLog_DBG(TAG, \"removing shared server socked resource\");\n\t\t\t\t// WLog_DBG(TAG, \"closing shared serverfd %d\", baseSocket->serverfd);\n\t\t\t\tArrayList_Remove(g_NamedPipeServerSockets, baseSocket);\n\t\t\t\tclose(baseSocket->serverfd);\n\t\t\t\tfree(baseSocket->name);\n\t\t\t\tfree(baseSocket);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tArrayList_Unlock(g_NamedPipeServerSockets);\n}", "path": "FreeRDP/winpr/libwinpr/pipe/pipe.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "FreeRDP/FreeRDP", "stars": 9906, "license": "apache-2.0", "language": "c", "size": 66959}
{"docstring": "/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\n", "func_signal": "static UINT\nwf_cliprdr_server_format_data_request(CliprdrClientContext* context,\n                                      const CLIPRDR_FORMAT_DATA_REQUEST* formatDataRequest)", "code": "{\n\tUINT rc;\n\tsize_t size = 0;\n\tvoid* buff = NULL;\n\tchar* globlemem = NULL;\n\tHANDLE hClipdata = NULL;\n\tUINT32 requestedFormatId;\n\tCLIPRDR_FORMAT_DATA_RESPONSE response;\n\twfClipboard* clipboard;\n\n\tif (!context || !formatDataRequest)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tclipboard = (wfClipboard*)context->custom;\n\n\tif (!clipboard)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\trequestedFormatId = formatDataRequest->requestedFormatId;\n\n\tif (requestedFormatId == RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW))\n\t{\n\t\tsize_t len;\n\t\tsize_t i;\n\t\tWCHAR* wFileName;\n\t\tHRESULT result;\n\t\tLPDATAOBJECT dataObj;\n\t\tFORMATETC format_etc;\n\t\tSTGMEDIUM stg_medium;\n\t\tDROPFILES* dropFiles;\n\t\tFILEGROUPDESCRIPTORW* groupDsc;\n\t\tresult = OleGetClipboard(&dataObj);\n\n\t\tif (FAILED(result))\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\n\t\tZeroMemory(&format_etc, sizeof(FORMATETC));\n\t\tZeroMemory(&stg_medium, sizeof(STGMEDIUM));\n\t\t/* get DROPFILES struct from OLE */\n\t\tformat_etc.cfFormat = CF_HDROP;\n\t\tformat_etc.tymed = TYMED_HGLOBAL;\n\t\tformat_etc.dwAspect = 1;\n\t\tformat_etc.lindex = -1;\n\t\tresult = IDataObject_GetData(dataObj, &format_etc, &stg_medium);\n\n\t\tif (FAILED(result))\n\t\t{\n\t\t\tDEBUG_CLIPRDR(\"dataObj->GetData failed.\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\tdropFiles = (DROPFILES*)GlobalLock(stg_medium.hGlobal);\n\n\t\tif (!dropFiles)\n\t\t{\n\t\t\tGlobalUnlock(stg_medium.hGlobal);\n\t\t\tReleaseStgMedium(&stg_medium);\n\t\t\tclipboard->nFiles = 0;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tclear_file_array(clipboard);\n\n\t\tif (dropFiles->fWide)\n\t\t{\n\t\t\t/* dropFiles contains file names */\n\t\t\tfor (wFileName = (WCHAR*)((char*)dropFiles + dropFiles->pFiles);\n\t\t\t     (len = wcslen(wFileName)) > 0; wFileName += len + 1)\n\t\t\t{\n\t\t\t\twf_cliprdr_process_filename(clipboard, wFileName, wcslen(wFileName));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar* p;\n\n\t\t\tfor (p = (char*)((char*)dropFiles + dropFiles->pFiles); (len = strlen(p)) > 0;\n\t\t\t     p += len + 1, clipboard->nFiles++)\n\t\t\t{\n\t\t\t\tint cchWideChar;\n\t\t\t\tWCHAR* wFileName;\n\t\t\t\tcchWideChar = MultiByteToWideChar(CP_ACP, MB_COMPOSITE, p, len, NULL, 0);\n\t\t\t\twFileName = (LPWSTR)calloc(cchWideChar, sizeof(WCHAR));\n\t\t\t\tMultiByteToWideChar(CP_ACP, MB_COMPOSITE, p, len, wFileName, cchWideChar);\n\t\t\t\twf_cliprdr_process_filename(clipboard, wFileName, cchWideChar);\n\t\t\t}\n\t\t}\n\n\t\tGlobalUnlock(stg_medium.hGlobal);\n\t\tReleaseStgMedium(&stg_medium);\n\texit:\n\t\tsize = 4 + clipboard->nFiles * sizeof(FILEDESCRIPTORW);\n\t\tgroupDsc = (FILEGROUPDESCRIPTORW*)malloc(size);\n\n\t\tif (groupDsc)\n\t\t{\n\t\t\tgroupDsc->cItems = clipboard->nFiles;\n\n\t\t\tfor (i = 0; i < clipboard->nFiles; i++)\n\t\t\t{\n\t\t\t\tif (clipboard->fileDescriptor[i])\n\t\t\t\t\tgroupDsc->fgd[i] = *clipboard->fileDescriptor[i];\n\t\t\t}\n\n\t\t\tbuff = groupDsc;\n\t\t}\n\n\t\tIDataObject_Release(dataObj);\n\t}\n\telse\n\t{\n\t\t/* Ignore if other app is holding the clipboard */\n\t\tif (try_open_clipboard(clipboard->hwnd))\n\t\t{\n\t\t\thClipdata = GetClipboardData(requestedFormatId);\n\n\t\t\tif (!hClipdata)\n\t\t\t{\n\t\t\t\tCloseClipboard();\n\t\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t\t}\n\n\t\t\tgloblemem = (char*)GlobalLock(hClipdata);\n\t\t\tsize = (int)GlobalSize(hClipdata);\n\t\t\tbuff = malloc(size);\n\t\t\tCopyMemory(buff, globlemem, size);\n\t\t\tGlobalUnlock(hClipdata);\n\t\t\tCloseClipboard();\n\t\t}\n\t}\n\n\tresponse.msgFlags = CB_RESPONSE_OK;\n\tresponse.dataLen = size;\n\tresponse.requestedFormatData = (BYTE*)buff;\n\trc = clipboard->context->ClientFormatDataResponse(clipboard->context, &response);\n\tfree(buff);\n\treturn rc;\n}", "path": "FreeRDP/client/Windows/wf_cliprdr.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "FreeRDP/FreeRDP", "stars": 9906, "license": "apache-2.0", "language": "c", "size": 66959}
{"docstring": "/* Secondary Update */\n", "func_signal": "static BOOL update_message_CacheBitmap(rdpContext* context,\n                                       const CACHE_BITMAP_ORDER* cacheBitmapOrder)", "code": "{\n\tCACHE_BITMAP_ORDER* wParam;\n\n\tif (!context || !context->update || !cacheBitmapOrder)\n\t\treturn FALSE;\n\n\twParam = copy_cache_bitmap_order(context, cacheBitmapOrder);\n\n\tif (!wParam)\n\t\treturn FALSE;\n\n\treturn MessageQueue_Post(context->update->queue, (void*)context,\n\t                         MakeMessageId(SecondaryUpdate, CacheBitmap), (void*)wParam, NULL);\n}", "path": "FreeRDP/libfreerdp/core/message.c", "commit_date": "2020-08-10 00:00:00", "repo_name": "FreeRDP/FreeRDP", "stars": 9906, "license": "apache-2.0", "language": "c", "size": 66959}
{"docstring": "/* Pointer Update */\n", "func_signal": "static BOOL update_message_PointerPosition(rdpContext* context,\n                                           const POINTER_POSITION_UPDATE* pointerPosition)", "code": "{\n\tPOINTER_POSITION_UPDATE* wParam;\n\n\tif (!context || !context->update || !pointerPosition)\n\t\treturn FALSE;\n\n\twParam = copy_pointer_position_update(context, pointerPosition);\n\n\tif (!wParam)\n\t\treturn FALSE;\n\n\treturn MessageQueue_Post(context->update->queue, (void*)context,\n\t                         MakeMessageId(PointerUpdate, PointerPosition), (void*)wParam, NULL);\n}", "path": "FreeRDP/libfreerdp/core/message.c", "commit_date": "2020-08-10 00:00:00", "repo_name": "FreeRDP/FreeRDP", "stars": 9906, "license": "apache-2.0", "language": "c", "size": 66959}
{"docstring": "/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\n", "func_signal": "static UINT\nwf_cliprdr_server_unlock_clipboard_data(CliprdrClientContext* context,\n                                        const CLIPRDR_UNLOCK_CLIPBOARD_DATA* unlockClipboardData)", "code": "{\n\t(void)context;\n\t(void)unlockClipboardData;\n\treturn CHANNEL_RC_OK;\n}", "path": "FreeRDP/client/Windows/wf_cliprdr.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "FreeRDP/FreeRDP", "stars": 9906, "license": "apache-2.0", "language": "c", "size": 66959}
{"docstring": "/**\n * IStream\n */\n", "func_signal": "static HRESULT STDMETHODCALLTYPE CliprdrStream_QueryInterface(IStream* This, REFIID riid,\n                                                              void** ppvObject)", "code": "{\n\tif (IsEqualIID(riid, &IID_IStream) || IsEqualIID(riid, &IID_IUnknown))\n\t{\n\t\tIStream_AddRef(This);\n\t\t*ppvObject = This;\n\t\treturn S_OK;\n\t}\n\telse\n\t{\n\t\t*ppvObject = 0;\n\t\treturn E_NOINTERFACE;\n\t}\n}", "path": "FreeRDP/client/Windows/wf_cliprdr.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "FreeRDP/FreeRDP", "stars": 9906, "license": "apache-2.0", "language": "c", "size": 66959}
{"docstring": "/* Alternate Secondary Update */\n", "func_signal": "static BOOL\nupdate_message_CreateOffscreenBitmap(rdpContext* context,\n                                     const CREATE_OFFSCREEN_BITMAP_ORDER* createOffscreenBitmap)", "code": "{\n\tCREATE_OFFSCREEN_BITMAP_ORDER* wParam;\n\n\tif (!context || !context->update || !createOffscreenBitmap)\n\t\treturn FALSE;\n\n\twParam = (CREATE_OFFSCREEN_BITMAP_ORDER*)malloc(sizeof(CREATE_OFFSCREEN_BITMAP_ORDER));\n\n\tif (!wParam)\n\t\treturn FALSE;\n\n\tCopyMemory(wParam, createOffscreenBitmap, sizeof(CREATE_OFFSCREEN_BITMAP_ORDER));\n\twParam->deleteList.cIndices = createOffscreenBitmap->deleteList.cIndices;\n\twParam->deleteList.sIndices = wParam->deleteList.cIndices;\n\twParam->deleteList.indices = (UINT16*)calloc(wParam->deleteList.cIndices, sizeof(UINT16));\n\n\tif (!wParam->deleteList.indices)\n\t{\n\t\tfree(wParam);\n\t\treturn FALSE;\n\t}\n\n\tCopyMemory(wParam->deleteList.indices, createOffscreenBitmap->deleteList.indices,\n\t           wParam->deleteList.cIndices);\n\treturn MessageQueue_Post(context->update->queue, (void*)context,\n\t                         MakeMessageId(AltSecUpdate, CreateOffscreenBitmap), (void*)wParam,\n\t                         NULL);\n}", "path": "FreeRDP/libfreerdp/core/message.c", "commit_date": "2020-08-10 00:00:00", "repo_name": "FreeRDP/FreeRDP", "stars": 9906, "license": "apache-2.0", "language": "c", "size": 66959}
{"docstring": "/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\n", "func_signal": "static UINT\nwf_cliprdr_server_format_list_response(CliprdrClientContext* context,\n                                       const CLIPRDR_FORMAT_LIST_RESPONSE* formatListResponse)", "code": "{\n\t(void)context;\n\t(void)formatListResponse;\n\n\tif (formatListResponse->msgFlags != CB_RESPONSE_OK)\n\t\treturn E_FAIL;\n\n\treturn CHANNEL_RC_OK;\n}", "path": "FreeRDP/client/Windows/wf_cliprdr.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "FreeRDP/FreeRDP", "stars": 9906, "license": "apache-2.0", "language": "c", "size": 66959}
{"docstring": "/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\n", "func_signal": "static UINT\nwf_cliprdr_server_file_contents_response(CliprdrClientContext* context,\n                                         const CLIPRDR_FILE_CONTENTS_RESPONSE* fileContentsResponse)", "code": "{\n\twfClipboard* clipboard;\n\n\tif (!context || !fileContentsResponse)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tif (fileContentsResponse->msgFlags != CB_RESPONSE_OK)\n\t\treturn E_FAIL;\n\n\tclipboard = (wfClipboard*)context->custom;\n\n\tif (!clipboard)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tclipboard->req_fsize = fileContentsResponse->cbRequested;\n\tclipboard->req_fdata = (char*)malloc(fileContentsResponse->cbRequested);\n\n\tif (!clipboard->req_fdata)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tCopyMemory(clipboard->req_fdata, fileContentsResponse->requestedData,\n\t           fileContentsResponse->cbRequested);\n\n\tif (!SetEvent(clipboard->req_fevent))\n\t{\n\t\tfree(clipboard->req_fdata);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn CHANNEL_RC_OK;\n}", "path": "FreeRDP/client/Windows/wf_cliprdr.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "FreeRDP/FreeRDP", "stars": 9906, "license": "apache-2.0", "language": "c", "size": 66959}
{"docstring": "/**\n * IDataObject\n */\n", "func_signal": "static LONG cliprdr_lookup_format(CliprdrDataObject* instance, FORMATETC* pFormatEtc)", "code": "{\n\tULONG i;\n\n\tif (!instance || !pFormatEtc)\n\t\treturn -1;\n\n\tfor (i = 0; i < instance->m_nNumFormats; i++)\n\t{\n\t\tif ((pFormatEtc->tymed & instance->m_pFormatEtc[i].tymed) &&\n\t\t    pFormatEtc->cfFormat == instance->m_pFormatEtc[i].cfFormat &&\n\t\t    pFormatEtc->dwAspect & instance->m_pFormatEtc[i].dwAspect)\n\t\t{\n\t\t\treturn (LONG)i;\n\t\t}\n\t}\n\n\treturn -1;\n}", "path": "FreeRDP/client/Windows/wf_cliprdr.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "FreeRDP/FreeRDP", "stars": 9906, "license": "apache-2.0", "language": "c", "size": 66959}
{"docstring": "/* Message Queue */\n", "func_signal": "static BOOL update_message_free_update_class(wMessage* msg, int type)", "code": "{\n\trdpContext* context;\n\n\tif (!msg)\n\t\treturn FALSE;\n\n\tcontext = (rdpContext*)msg->context;\n\n\tswitch (type)\n\t{\n\t\tcase Update_BeginPaint:\n\t\t\tbreak;\n\n\t\tcase Update_EndPaint:\n\t\t\tbreak;\n\n\t\tcase Update_SetBounds:\n\t\t\tfree(msg->wParam);\n\t\t\tbreak;\n\n\t\tcase Update_Synchronize:\n\t\t\tbreak;\n\n\t\tcase Update_DesktopResize:\n\t\t\tbreak;\n\n\t\tcase Update_BitmapUpdate:\n\t\t{\n\t\t\tBITMAP_UPDATE* wParam = (BITMAP_UPDATE*)msg->wParam;\n\t\t\tfree_bitmap_update(context, wParam);\n\t\t}\n\t\tbreak;\n\n\t\tcase Update_Palette:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette = (PALETTE_UPDATE*)msg->wParam;\n\t\t\tfree_palette_update(context, palette);\n\t\t}\n\t\tbreak;\n\n\t\tcase Update_PlaySound:\n\t\t\tfree(msg->wParam);\n\t\t\tbreak;\n\n\t\tcase Update_RefreshRect:\n\t\t\tfree(msg->lParam);\n\t\t\tbreak;\n\n\t\tcase Update_SuppressOutput:\n\t\t\tfree(msg->lParam);\n\t\t\tbreak;\n\n\t\tcase Update_SurfaceCommand:\n\t\t{\n\t\t\twStream* s = (wStream*)msg->wParam;\n\t\t\tStream_Free(s, TRUE);\n\t\t}\n\t\tbreak;\n\n\t\tcase Update_SurfaceBits:\n\t\t{\n\t\t\tSURFACE_BITS_COMMAND* wParam = (SURFACE_BITS_COMMAND*)msg->wParam;\n\t\t\tfree_surface_bits_command(context, wParam);\n\t\t}\n\t\tbreak;\n\n\t\tcase Update_SurfaceFrameMarker:\n\t\t\tfree(msg->wParam);\n\t\t\tbreak;\n\n\t\tcase Update_SurfaceFrameAcknowledge:\n\t\tcase Update_SetKeyboardIndicators:\n\t\tcase Update_SetKeyboardImeStatus:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}", "path": "FreeRDP/libfreerdp/core/message.c", "commit_date": "2020-08-10 00:00:00", "repo_name": "FreeRDP/FreeRDP", "stars": 9906, "license": "apache-2.0", "language": "c", "size": 66959}
{"docstring": "/* Input */\n", "func_signal": "static BOOL input_message_SynchronizeEvent(rdpInput* input, UINT32 flags)", "code": "{\n\tif (!input)\n\t\treturn FALSE;\n\n\treturn MessageQueue_Post(input->queue, (void*)input, MakeMessageId(Input, SynchronizeEvent),\n\t                         (void*)(size_t)flags, NULL);\n}", "path": "FreeRDP/libfreerdp/core/message.c", "commit_date": "2020-08-10 00:00:00", "repo_name": "FreeRDP/FreeRDP", "stars": 9906, "license": "apache-2.0", "language": "c", "size": 66959}
{"docstring": "/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\n", "func_signal": "static UINT wf_cliprdr_server_capabilities(CliprdrClientContext* context,\n                                           const CLIPRDR_CAPABILITIES* capabilities)", "code": "{\n\tUINT32 index;\n\tCLIPRDR_CAPABILITY_SET* capabilitySet;\n\twfClipboard* clipboard = (wfClipboard*)context->custom;\n\n\tif (!context || !capabilities)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tfor (index = 0; index < capabilities->cCapabilitiesSets; index++)\n\t{\n\t\tcapabilitySet = &(capabilities->capabilitySets[index]);\n\n\t\tif ((capabilitySet->capabilitySetType == CB_CAPSTYPE_GENERAL) &&\n\t\t    (capabilitySet->capabilitySetLength >= CB_CAPSTYPE_GENERAL_LEN))\n\t\t{\n\t\t\tCLIPRDR_GENERAL_CAPABILITY_SET* generalCapabilitySet =\n\t\t\t    (CLIPRDR_GENERAL_CAPABILITY_SET*)capabilitySet;\n\t\t\tclipboard->capabilities = generalCapabilitySet->generalFlags;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn CHANNEL_RC_OK;\n}", "path": "FreeRDP/client/Windows/wf_cliprdr.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "FreeRDP/FreeRDP", "stars": 9906, "license": "apache-2.0", "language": "c", "size": 66959}
{"docstring": "/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\n", "func_signal": "static UINT\nwf_cliprdr_server_lock_clipboard_data(CliprdrClientContext* context,\n                                      const CLIPRDR_LOCK_CLIPBOARD_DATA* lockClipboardData)", "code": "{\n\t(void)context;\n\t(void)lockClipboardData;\n\treturn CHANNEL_RC_OK;\n}", "path": "FreeRDP/client/Windows/wf_cliprdr.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "FreeRDP/FreeRDP", "stars": 9906, "license": "apache-2.0", "language": "c", "size": 66959}
{"docstring": "/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\n", "func_signal": "static UINT\nwf_cliprdr_server_format_data_response(CliprdrClientContext* context,\n                                       const CLIPRDR_FORMAT_DATA_RESPONSE* formatDataResponse)", "code": "{\n\tBYTE* data;\n\tHANDLE hMem;\n\twfClipboard* clipboard;\n\n\tif (!context || !formatDataResponse)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tif (formatDataResponse->msgFlags != CB_RESPONSE_OK)\n\t\treturn E_FAIL;\n\n\tclipboard = (wfClipboard*)context->custom;\n\n\tif (!clipboard)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\thMem = GlobalAlloc(GMEM_MOVEABLE, formatDataResponse->dataLen);\n\n\tif (!hMem)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\tdata = (BYTE*)GlobalLock(hMem);\n\n\tif (!data)\n\t{\n\t\tGlobalFree(hMem);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\tCopyMemory(data, formatDataResponse->requestedFormatData, formatDataResponse->dataLen);\n\n\tif (!GlobalUnlock(hMem) && GetLastError())\n\t{\n\t\tGlobalFree(hMem);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\tclipboard->hmem = hMem;\n\n\tif (!SetEvent(clipboard->response_data_event))\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\treturn CHANNEL_RC_OK;\n}", "path": "FreeRDP/client/Windows/wf_cliprdr.c", "commit_date": "2020-05-06 00:00:00", "repo_name": "FreeRDP/FreeRDP", "stars": 9906, "license": "apache-2.0", "language": "c", "size": 66959}
{"docstring": "/*\n * Returns true if the given string matches the pattern (which may contain ?\n * and * as wildcards), and zero if it does not match.\n */\n", "func_signal": "static int match_pattern(const char *s, const char *pattern, size_t limit)", "code": "{\n  bool had_asterisk = false;\n  if (s == NULL || pattern == NULL || limit <= 0) {\n    return 0;\n  }\n\n  for (;;) {\n    /* If at end of pattern, accept if also at end of string. */\n    if (*pattern == '\\0') {\n        return (*s == '\\0');\n    }\n\n    while (*pattern == '*') {\n      /* Skip the asterisk. */\n      had_asterisk = true;\n      pattern++;\n    }\n\n    if (had_asterisk) {\n      /* If at end of pattern, accept immediately. */\n      if (!*pattern)\n        return 1;\n\n      /* If next character in pattern is known, optimize. */\n      if (*pattern != '?') {\n        /*\n         * Look instances of the next character in\n         * pattern, and try to match starting from\n         * those.\n         */\n        for (; *s; s++)\n          if (*s == *pattern && match_pattern(s + 1, pattern + 1, limit - 1)) {\n            return 1;\n          }\n        /* Failed. */\n        return 0;\n      }\n      /*\n       * Move ahead one character at a time and try to\n       * match at each position.\n       */\n      for (; *s; s++) {\n        if (match_pattern(s, pattern, limit - 1)) {\n          return 1;\n        }\n      }\n      /* Failed. */\n      return 0;\n    }\n    /*\n     * There must be at least one more character in the string.\n     * If we are at the end, fail.\n     */\n    if (!*s) {\n      return 0;\n    }\n\n    /* Check if the next character of the string is acceptable. */\n    if (*pattern != '?' && *pattern != *s) {\n      return 0;\n    }\n\n    /* Move to the next character, both in string and in pattern. */\n    s++;\n    pattern++;\n  }\n\n  /* NOTREACHED */\n  return 0;\n}", "path": "WindTerm/src/libssh/src/match.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "kingToolbox/WindTerm", "stars": 19629, "license": "None", "language": "c", "size": 18735}
{"docstring": "/**\n * @internal\n *\n * @brief Convert a buffer into an unpadded base64 string.\n * The caller has to free the memory.\n *\n * @param  hash         What should be converted to a base64 string.\n *\n * @param  len          Length of the buffer to convert.\n *\n * @return              The base64 string or NULL on error.\n *\n * @see ssh_string_free_char()\n */\n", "func_signal": "static char *ssh_get_b64_unpadded(const unsigned char *hash, size_t len)", "code": "{\n    char *b64_padded = NULL;\n    char *b64_unpadded = NULL;\n    size_t k;\n\n    b64_padded = (char *)bin_to_base64(hash, (int)len);\n    if (b64_padded == NULL) {\n        return NULL;\n    }\n    for (k = strlen(b64_padded); k != 0 && b64_padded[k-1] == '='; k--);\n\n    b64_unpadded = strndup(b64_padded, k);\n    SAFE_FREE(b64_padded);\n\n    return b64_unpadded;\n}", "path": "WindTerm/src/libssh/src/dh.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "kingToolbox/WindTerm", "stars": 19629, "license": "None", "language": "c", "size": 18735}
{"docstring": "/** @internal\n * @brief parse an incoming SSH_MSG_KEXDH_INIT packet and complete\n *        Diffie-Hellman key exchange\n **/\n", "func_signal": "static SSH_PACKET_CALLBACK(ssh_packet_server_dh_init)", "code": "{\n    (void)type;\n    (void)user;\n    SSH_LOG(SSH_LOG_DEBUG, \"Received SSH_MSG_KEXDH_INIT\");\n    ssh_packet_remove_callbacks(session, &ssh_dh_server_callbacks);\n    ssh_server_dh_process_init(session, packet);\n    return SSH_PACKET_USED;\n}", "path": "WindTerm/src/libssh/src/dh.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "kingToolbox/WindTerm", "stars": 19629, "license": "None", "language": "c", "size": 18735}
{"docstring": "/* Caller need to free the blob */\n", "func_signal": "int ssh_dh_get_next_server_publickey_blob(ssh_session session,\n                                          ssh_string *pubkey_blob)", "code": "{\n    const ssh_key pubkey = ssh_dh_get_next_server_publickey(session);\n\n    return ssh_pki_export_pubkey_blob(pubkey, pubkey_blob);\n}", "path": "WindTerm/src/libssh/src/dh.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "kingToolbox/WindTerm", "stars": 19629, "license": "None", "language": "c", "size": 18735}
{"docstring": "/** @internal\n * @brief Starts diffie-hellman-group1 key exchange\n */\n", "func_signal": "int ssh_client_dh_init(ssh_session session)", "code": "{\n  struct ssh_crypto_struct *crypto = session->next_crypto;\n  const_bignum pubkey;\n  int rc;\n\n  rc = ssh_dh_init_common(crypto);\n  if (rc == SSH_ERROR) {\n    goto error;\n  }\n\n  rc = ssh_dh_keypair_gen_keys(crypto->dh_ctx, DH_CLIENT_KEYPAIR);\n  if (rc == SSH_ERROR){\n      goto error;\n  }\n  rc = ssh_dh_keypair_get_keys(crypto->dh_ctx, DH_CLIENT_KEYPAIR,\n                               NULL, &pubkey);\n  if (rc != SSH_OK) {\n    goto error;\n  }\n  rc = ssh_buffer_pack(session->out_buffer, \"bB\", SSH2_MSG_KEXDH_INIT, pubkey);\n  if (rc != SSH_OK) {\n    goto error;\n  }\n\n  /* register the packet callbacks */\n  ssh_packet_set_callbacks(session, &ssh_dh_client_callbacks);\n  session->dh_handshake_state = DH_STATE_INIT_SENT;\n\n  rc = ssh_packet_send(session);\n  return rc;\nerror:\n  ssh_dh_cleanup(crypto);\n  return SSH_ERROR;\n}", "path": "WindTerm/src/libssh/src/dh.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "kingToolbox/WindTerm", "stars": 19629, "license": "None", "language": "c", "size": 18735}
{"docstring": "/** @brief Parse a SSH_MSG_KEXDH_INIT packet (server) and send a\n * SSH_MSG_KEXDH_REPLY\n */\n", "func_signal": "static SSH_PACKET_CALLBACK(ssh_packet_server_curve25519_init)", "code": "{\n    /* ECDH keys */\n    ssh_string q_c_string;\n    ssh_string q_s_string;\n    ssh_string server_pubkey_blob = NULL;\n\n    /* SSH host keys (rsa,dsa,ecdsa) */\n    ssh_key privkey;\n    enum ssh_digest_e digest = SSH_DIGEST_AUTO;\n    ssh_string sig_blob = NULL;\n    int rc;\n    (void)type;\n    (void)user;\n\n    ssh_packet_remove_callbacks(session, &ssh_curve25519_server_callbacks);\n\n    /* Extract the client pubkey from the init packet */\n    q_c_string = ssh_buffer_get_ssh_string(packet);\n    if (q_c_string == NULL) {\n        ssh_set_error(session,SSH_FATAL, \"No Q_C ECC point in packet\");\n        goto error;\n    }\n    if (ssh_string_len(q_c_string) != CURVE25519_PUBKEY_SIZE){\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Incorrect size for server Curve25519 public key: %zu\",\n                      ssh_string_len(q_c_string));\n        SSH_STRING_FREE(q_c_string);\n        goto error;\n    }\n\n    memcpy(session->next_crypto->curve25519_client_pubkey,\n           ssh_string_data(q_c_string), CURVE25519_PUBKEY_SIZE);\n    SSH_STRING_FREE(q_c_string);\n    /* Build server's keypair */\n\n    rc = ssh_curve25519_init(session);\n    if (rc != SSH_OK) {\n        ssh_set_error(session, SSH_FATAL, \"Failed to generate curve25519 keys\");\n        goto error;\n    }\n\n    rc = ssh_buffer_add_u8(session->out_buffer, SSH2_MSG_KEX_ECDH_REPLY);\n    if (rc < 0) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    /* build k and session_id */\n    rc = ssh_curve25519_build_k(session);\n    if (rc < 0) {\n        ssh_set_error(session, SSH_FATAL, \"Cannot build k number\");\n        goto error;\n    }\n\n    /* privkey is not allocated */\n    rc = ssh_get_key_params(session, &privkey, &digest);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n\n    rc = ssh_make_sessionid(session);\n    if (rc != SSH_OK) {\n        ssh_set_error(session, SSH_FATAL, \"Could not create a session id\");\n        goto error;\n    }\n\n    rc = ssh_dh_get_next_server_publickey_blob(session, &server_pubkey_blob);\n    if (rc != 0) {\n        ssh_set_error(session, SSH_FATAL, \"Could not export server public key\");\n        goto error;\n    }\n\n    /* add host's public key */\n    rc = ssh_buffer_add_ssh_string(session->out_buffer,\n                                   server_pubkey_blob);\n    SSH_STRING_FREE(server_pubkey_blob);\n    if (rc < 0) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    /* add ecdh public key */\n    q_s_string = ssh_string_new(CURVE25519_PUBKEY_SIZE);\n    if (q_s_string == NULL) {\n        goto error;\n    }\n\n    ssh_string_fill(q_s_string,\n                    session->next_crypto->curve25519_server_pubkey,\n                    CURVE25519_PUBKEY_SIZE);\n\n    rc = ssh_buffer_add_ssh_string(session->out_buffer, q_s_string);\n    SSH_STRING_FREE(q_s_string);\n    if (rc < 0) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n    /* add signature blob */\n    sig_blob = ssh_srv_pki_do_sign_sessionid(session, privkey, digest);\n    if (sig_blob == NULL) {\n        ssh_set_error(session, SSH_FATAL, \"Could not sign the session id\");\n        goto error;\n    }\n\n    rc = ssh_buffer_add_ssh_string(session->out_buffer, sig_blob);\n    SSH_STRING_FREE(sig_blob);\n    if (rc < 0) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    SSH_LOG(SSH_LOG_PROTOCOL, \"SSH_MSG_KEX_ECDH_REPLY sent\");\n    rc = ssh_packet_send(session);\n    if (rc == SSH_ERROR) {\n        return SSH_ERROR;\n    }\n\n    /* Send the MSG_NEWKEYS */\n    rc = ssh_buffer_add_u8(session->out_buffer, SSH2_MSG_NEWKEYS);\n    if (rc < 0) {\n        goto error;\n    }\n\n    session->dh_handshake_state = DH_STATE_NEWKEYS_SENT;\n    rc = ssh_packet_send(session);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n    SSH_LOG(SSH_LOG_PROTOCOL, \"SSH_MSG_NEWKEYS sent\");\n\n    return SSH_PACKET_USED;\nerror:\n    ssh_buffer_reinit(session->out_buffer);\n    session->session_state=SSH_SESSION_STATE_ERROR;\n    return SSH_PACKET_USED;\n}", "path": "WindTerm/src/libssh/src/curve25519.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "kingToolbox/WindTerm", "stars": 19629, "license": "None", "language": "c", "size": 18735}
{"docstring": "/** @internal\n * @brief Starts curve25519-sha256@libssh.org / curve25519-sha256 key exchange\n */\n", "func_signal": "int ssh_client_curve25519_init(ssh_session session)", "code": "{\n    int rc;\n\n    rc = ssh_curve25519_init(session);\n    if (rc != SSH_OK) {\n        return rc;\n    }\n\n    rc = ssh_buffer_pack(session->out_buffer,\n                         \"bdP\",\n                         SSH2_MSG_KEX_ECDH_INIT,\n                         CURVE25519_PUBKEY_SIZE,\n                         (size_t)CURVE25519_PUBKEY_SIZE,\n                         session->next_crypto->curve25519_client_pubkey);\n    if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        return SSH_ERROR;\n    }\n\n    /* register the packet callbacks */\n    ssh_packet_set_callbacks(session, &ssh_curve25519_client_callbacks);\n    session->dh_handshake_state = DH_STATE_INIT_SENT;\n    rc = ssh_packet_send(session);\n\n    return rc;\n}", "path": "WindTerm/src/libssh/src/curve25519.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "kingToolbox/WindTerm", "stars": 19629, "license": "None", "language": "c", "size": 18735}
{"docstring": "/** @brief generates a random integer between 0 and max\n * @returns 1 in case of success, 0 otherwise\n */\n", "func_signal": "int ssh_mbedcry_rand_range(bignum dest, bignum max)", "code": "{\n    size_t bits;\n    bignum rnd;\n    int rc;\n\n    bits = bignum_num_bits(max) + 64;\n    rnd = bignum_new();\n    if (rnd == NULL){\n        return 0;\n    }\n    rc = bignum_rand(rnd, bits);\n    if (rc != 1) {\n        bignum_safe_free(rnd);\n        return rc;\n    }\n    mbedtls_mpi_mod_mpi(dest, rnd, max);\n    bignum_safe_free(rnd);\n    return 1;\n}", "path": "WindTerm/src/libssh/src/mbedcrypto_missing.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "kingToolbox/WindTerm", "stars": 19629, "license": "None", "language": "c", "size": 18735}
{"docstring": "/* thanks sysk for debugging my mess :) */\n", "func_signal": "static void _bin_to_base64(uint8_t *dest,\n                           const uint8_t source[3],\n                           size_t len)", "code": "{\n#define BITS(n) ((1 << (n)) - 1)\n    switch (len) {\n        case 1:\n            dest[0] = alphabet[(source[0] >> 2)];\n            dest[1] = alphabet[((source[0] & BITS(2)) << 4)];\n            dest[2] = '=';\n            dest[3] = '=';\n            break;\n        case 2:\n            dest[0] = alphabet[source[0] >> 2];\n            dest[1] = alphabet[(source[1] >> 4) | ((source[0] & BITS(2)) << 4)];\n            dest[2] = alphabet[(source[1] & BITS(4)) << 2];\n            dest[3] = '=';\n            break;\n        case 3:\n            dest[0] = alphabet[(source[0] >> 2)];\n            dest[1] = alphabet[(source[1] >> 4) | ((source[0] & BITS(2)) << 4)];\n            dest[2] = alphabet[(source[2] >> 6) | (source[1] & BITS(4)) << 2];\n            dest[3] = alphabet[source[2] & BITS(6)];\n            break;\n    }\n#undef BITS\n}", "path": "WindTerm/src/libssh/src/base64.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "kingToolbox/WindTerm", "stars": 19629, "license": "None", "language": "c", "size": 18735}
{"docstring": "/** @internal\n * @brief benchmarks a scp upload using an\n * existing SSH session.\n * @param[in] session Open SSH session\n * @param[in] args Parsed command line arguments\n * @param[out] bps The calculated bytes per second obtained via benchmark.\n * @return 0 on success, -1 on error.\n */\n", "func_signal": "int benchmarks_scp_up (ssh_session session, struct argument_s *args,\n    float *bps)", "code": "{\n  unsigned long bytes;\n  struct timestamp_struct ts;\n  float ms=0.0;\n  unsigned long total=0;\n  ssh_scp scp;\n\n  bytes = args->datasize * 1024 * 1024;\n  scp = ssh_scp_new(session,SSH_SCP_WRITE,SCPDIR);\n  if(scp == NULL)\n    goto error;\n  if(ssh_scp_init(scp)==SSH_ERROR)\n    goto error;\n  if(ssh_scp_push_file(scp,SCPFILE,bytes,0777) != SSH_OK)\n    goto error;\n  if(args->verbose>0)\n    fprintf(stdout,\"Starting upload of %lu bytes now\\n\",bytes);\n  timestamp_init(&ts);\n  while(total < bytes){\n    unsigned long towrite = bytes - total;\n    int w;\n    if(towrite > args->chunksize)\n      towrite = args->chunksize;\n    w=ssh_scp_write(scp,buffer,towrite);\n    if(w == SSH_ERROR)\n      goto error;\n    total += towrite;\n  }\n  ms=elapsed_time(&ts);\n  *bps=8000 * (float)bytes / ms;\n  if(args->verbose > 0)\n    fprintf(stdout,\"Upload took %f ms for %lu bytes, at %f bps\\n\",ms,\n        bytes,*bps);\n  ssh_scp_close(scp);\n  ssh_scp_free(scp);\n  return 0;\nerror:\n  fprintf(stderr,\"Error during scp upload : %s\\n\",ssh_get_error(session));\n  if(scp){\n    ssh_scp_close(scp);\n    ssh_scp_free(scp);\n  }\n  return -1;\n}", "path": "WindTerm/src/libssh/tests/benchmarks/bench_scp.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "kingToolbox/WindTerm", "stars": 19629, "license": "None", "language": "c", "size": 18735}
{"docstring": "/**\n * @internal\n *\n * @brief Converts binary data to a base64 string.\n *\n * @returns the converted string\n */\n", "func_signal": "uint8_t *bin_to_base64(const uint8_t *source, size_t len)", "code": "{\n    uint8_t *base64 = NULL;\n    uint8_t *ptr = NULL;\n    size_t flen = len + (3 - (len % 3)); /* round to upper 3 multiple */\n    flen = (4 * flen) / 3 + 1;\n\n    base64 = malloc(flen);\n    if (base64 == NULL) {\n        return NULL;\n    }\n    ptr = base64;\n\n    while(len > 0){\n        _bin_to_base64(ptr, source, len > 3 ? 3 : len);\n        ptr += 4;\n        if (len < 3) {\n            break;\n        }\n        source += 3;\n        len -= 3;\n    }\n    ptr[0] = '\\0';\n\n    return base64;\n}", "path": "WindTerm/src/libssh/src/base64.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "kingToolbox/WindTerm", "stars": 19629, "license": "None", "language": "c", "size": 18735}
{"docstring": "/* Count the number of \"=\" signs and replace them by zeroes */\n", "func_signal": "static int get_equals(char *string)", "code": "{\n  char *ptr = string;\n  int num = 0;\n\n  while ((ptr=strchr(ptr,'=')) != NULL) {\n    num++;\n    *ptr = '\\0';\n    ptr++;\n  }\n\n  return num;\n}", "path": "WindTerm/src/libssh/src/base64.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "kingToolbox/WindTerm", "stars": 19629, "license": "None", "language": "c", "size": 18735}
{"docstring": "/**\n * @internal\n * @brief Finalize and free global constants used in DH key agreement\n */\n", "func_signal": "void ssh_dh_finalize(void)", "code": "{\n    if (!dh_crypto_initialized) {\n        return;\n    }\n\n    bignum_safe_free(ssh_dh_generator);\n    bignum_safe_free(ssh_dh_group1);\n    bignum_safe_free(ssh_dh_group14);\n    bignum_safe_free(ssh_dh_group16);\n    bignum_safe_free(ssh_dh_group18);\n\n    dh_crypto_initialized = 0;\n}", "path": "WindTerm/src/libssh/src/dh.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "kingToolbox/WindTerm", "stars": 19629, "license": "None", "language": "c", "size": 18735}
{"docstring": "/** @internal\n * @brief processes a SSH_MSG_KEXDH_INIT or SSH_MSG_KEX_DH_GEX_INIT packet and sends\n * the appropriate SSH_MSG_KEXDH_REPLY or SSH_MSG_KEX_DH_GEX_REPLY\n */\n", "func_signal": "int ssh_server_dh_process_init(ssh_session session, ssh_buffer packet)", "code": "{\n    struct ssh_crypto_struct *crypto = session->next_crypto;\n    ssh_key privkey = NULL;\n    enum ssh_digest_e digest = SSH_DIGEST_AUTO;\n    ssh_string sig_blob = NULL;\n    ssh_string pubkey_blob = NULL;\n    bignum client_pubkey;\n    const_bignum server_pubkey;\n    int packet_type;\n    int rc;\n\n    rc = ssh_buffer_unpack(packet, \"B\", &client_pubkey);\n    if (rc == SSH_ERROR) {\n        ssh_set_error(session, SSH_FATAL, \"No e number in client request\");\n        goto error;\n    }\n\n    rc = ssh_dh_keypair_set_keys(crypto->dh_ctx, DH_CLIENT_KEYPAIR,\n                                 NULL, client_pubkey);\n    if (rc != SSH_OK) {\n        bignum_safe_free(client_pubkey);\n        goto error;\n    }\n\n    rc = ssh_dh_keypair_gen_keys(crypto->dh_ctx, DH_SERVER_KEYPAIR);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n\n    rc = ssh_get_key_params(session, &privkey, &digest);\n    if (rc != SSH_OK) {\n        goto error;\n    }\n    rc = ssh_dh_compute_shared_secret(crypto->dh_ctx,\n                                      DH_SERVER_KEYPAIR, DH_CLIENT_KEYPAIR,\n                                      &crypto->shared_secret);\n    ssh_dh_debug_crypto(crypto);\n    if (rc == SSH_ERROR) {\n        ssh_set_error(session, SSH_FATAL, \"Could not generate shared secret\");\n        goto error;\n    }\n    rc = ssh_make_sessionid(session);\n    if (rc != SSH_OK) {\n        ssh_set_error(session, SSH_FATAL, \"Could not create a session id\");\n        goto error;\n    }\n    sig_blob = ssh_srv_pki_do_sign_sessionid(session, privkey, digest);\n    if (sig_blob == NULL) {\n        ssh_set_error(session, SSH_FATAL, \"Could not sign the session id\");\n        goto error;\n    }\n    switch (crypto->kex_type){\n    case SSH_KEX_DH_GROUP1_SHA1:\n    case SSH_KEX_DH_GROUP14_SHA1:\n    case SSH_KEX_DH_GROUP14_SHA256:\n    case SSH_KEX_DH_GROUP16_SHA512:\n    case SSH_KEX_DH_GROUP18_SHA512:\n        packet_type = SSH2_MSG_KEXDH_REPLY;\n        break;\n#ifdef WITH_GEX\n    case SSH_KEX_DH_GEX_SHA1:\n    case SSH_KEX_DH_GEX_SHA256:\n        packet_type = SSH2_MSG_KEX_DH_GEX_REPLY;\n        break;\n#endif /* WITH_GEX */\n    default:\n        ssh_set_error(session, SSH_FATAL, \"Invalid kex type\");\n        goto error;\n    }\n    rc = ssh_dh_keypair_get_keys(crypto->dh_ctx, DH_SERVER_KEYPAIR,\n                                 NULL, &server_pubkey);\n    if (rc != SSH_OK){\n        goto error;\n    }\n    rc = ssh_dh_get_next_server_publickey_blob(session, &pubkey_blob);\n    if (rc != SSH_OK){\n        ssh_set_error_oom(session);\n        goto error;\n    }\n    rc = ssh_buffer_pack(session->out_buffer,\n                         \"bSBS\",\n                         packet_type,\n                         pubkey_blob,\n                         server_pubkey,\n                         sig_blob);\n    SSH_STRING_FREE(sig_blob);\n    SSH_STRING_FREE(pubkey_blob);\n    if(rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        ssh_buffer_reinit(session->out_buffer);\n        goto error;\n    }\n    rc = ssh_packet_send(session);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n    SSH_LOG(SSH_LOG_DEBUG, \"Sent KEX_DH_[GEX]_REPLY\");\n\n    if (ssh_buffer_add_u8(session->out_buffer, SSH2_MSG_NEWKEYS) < 0) {\n        ssh_buffer_reinit(session->out_buffer);\n        goto error;\n    }\n    session->dh_handshake_state=DH_STATE_NEWKEYS_SENT;\n    if (ssh_packet_send(session) == SSH_ERROR) {\n        goto error;\n    }\n    SSH_LOG(SSH_LOG_PACKET, \"SSH_MSG_NEWKEYS sent\");\n\n    return SSH_OK;\nerror:\n    SSH_STRING_FREE(sig_blob);\n    SSH_STRING_FREE(pubkey_blob);\n\n    session->session_state = SSH_SESSION_STATE_ERROR;\n    ssh_dh_cleanup(session->next_crypto);\n    return SSH_ERROR;\n}", "path": "WindTerm/src/libssh/src/dh.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "kingToolbox/WindTerm", "stars": 19629, "license": "None", "language": "c", "size": 18735}
{"docstring": "/** @internal\n * @brief Choose a fallback group for the DH Group exchange if the\n * moduli file is not readable\n * @param[in] pmax maximum requestsd group size\n * @param[out] modulus\n * @param[out] generator\n * @returns SSH_OK on success, SSH_ERROR otherwise\n */\n", "func_signal": "int ssh_fallback_group(uint32_t pmax,\n                       bignum *modulus,\n                       bignum *generator)", "code": "{\n    *modulus = NULL;\n    *generator = NULL;\n\n    if (pmax < 3072) {\n        bignum_dup(ssh_dh_group14, modulus);\n    } else if (pmax < 6144) {\n        bignum_dup(ssh_dh_group16, modulus);\n    } else {\n        bignum_dup(ssh_dh_group18, modulus);\n    }\n    if (*modulus == NULL) {\n        return SSH_ERROR;\n    }\n\n    bignum_dup(ssh_dh_generator, generator);\n    if (*generator == NULL) {\n        bignum_safe_free((*modulus));\n        return SSH_ERROR;\n    }\n\n    return SSH_OK;\n}", "path": "WindTerm/src/libssh/src/dh.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "kingToolbox/WindTerm", "stars": 19629, "license": "None", "language": "c", "size": 18735}
{"docstring": "/** @internal\n * @brief benchmarks a scp download using an\n * existing SSH session.\n * @param[in] session Open SSH session\n * @param[in] args Parsed command line arguments\n * @param[out] bps The calculated bytes per second obtained via benchmark.\n * @return 0 on success, -1 on error.\n */\n", "func_signal": "int benchmarks_scp_down (ssh_session session, struct argument_s *args,\n    float *bps)", "code": "{\n  unsigned long bytes;\n  struct timestamp_struct ts;\n  float ms=0.0;\n  unsigned long total=0;\n  ssh_scp scp;\n  int r;\n  size_t size;\n\n  bytes = args->datasize * 1024 * 1024;\n  scp = ssh_scp_new(session,SSH_SCP_READ,SCPDIR SCPFILE);\n  if(scp == NULL)\n    goto error;\n  if(ssh_scp_init(scp)==SSH_ERROR)\n    goto error;\n  r=ssh_scp_pull_request(scp);\n  if(r == SSH_SCP_REQUEST_NEWFILE){\n    size=ssh_scp_request_get_size(scp);\n    if(bytes > size){\n      printf(\"Only %zd bytes available (on %lu requested).\\n\",size,bytes);\n      bytes = size;\n    }\n    if(size > bytes){\n      printf(\"File is %zd bytes (on %lu requested). Will cut the end\\n\",size,bytes);\n    }\n    if(args->verbose>0)\n      fprintf(stdout,\"Starting download of %lu bytes now\\n\",bytes);\n    timestamp_init(&ts);\n    ssh_scp_accept_request(scp);\n    while(total < bytes){\n      unsigned long toread = bytes - total;\n      if(toread > args->chunksize)\n        toread = args->chunksize;\n      r=ssh_scp_read(scp,buffer,toread);\n      if(r == SSH_ERROR || r == 0)\n        goto error;\n      total += r;\n    }\n    ms=elapsed_time(&ts);\n    *bps=8000 * (float)bytes / ms;\n    if(args->verbose > 0)\n      fprintf(stdout,\"download took %f ms for %lu bytes, at %f bps\\n\",ms,\n          bytes,*bps);\n  } else {\n    fprintf(stderr,\"Expected SSH_SCP_REQUEST_NEWFILE, got %d\\n\",r);\n    goto error;\n  }\n  ssh_scp_close(scp);\n  ssh_scp_free(scp);\n  return 0;\nerror:\n  fprintf(stderr,\"Error during scp download : %s\\n\",ssh_get_error(session));\n  if(scp){\n    ssh_scp_close(scp);\n    ssh_scp_free(scp);\n  }\n  return -1;\n}", "path": "WindTerm/src/libssh/tests/benchmarks/bench_scp.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "kingToolbox/WindTerm", "stars": 19629, "license": "None", "language": "c", "size": 18735}
{"docstring": "/* decompression */\n", "func_signal": "static z_stream *initdecompress(ssh_session session)", "code": "{\n  z_stream *stream = NULL;\n  int status;\n\n  stream = calloc(1, sizeof(z_stream));\n  if (stream == NULL) {\n    return NULL;\n  }\n\n  status = inflateInit(stream);\n  if (status != Z_OK) {\n    SAFE_FREE(stream);\n    ssh_set_error(session, SSH_FATAL,\n        \"Status = %d initiating inflate context!\", status);\n    return NULL;\n  }\n\n  return stream;\n}", "path": "WindTerm/src/libssh/src/gzip.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "kingToolbox/WindTerm", "stars": 19629, "license": "None", "language": "c", "size": 18735}
{"docstring": "/* num = numbers of final bytes to be decoded */\n", "func_signal": "static int _base64_to_bin(unsigned char dest[3], const char *source, int num)", "code": "{\n  unsigned long block;\n\n  if (to_block4(&block, source, num) < 0) {\n    return -1;\n  }\n  dest[0] = GET_A(block);\n  dest[1] = GET_B(block);\n  dest[2] = GET_C(block);\n\n  return 0;\n}", "path": "WindTerm/src/libssh/src/base64.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "kingToolbox/WindTerm", "stars": 19629, "license": "None", "language": "c", "size": 18735}
{"docstring": "/** @internal\n * @brief sets up the diffie-hellman-groupx kex callbacks\n */\n", "func_signal": "void ssh_server_dh_init(ssh_session session)", "code": "{\n    /* register the packet callbacks */\n    ssh_packet_set_callbacks(session, &ssh_dh_server_callbacks);\n\n    ssh_dh_init_common(session->next_crypto);\n}", "path": "WindTerm/src/libssh/src/dh.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "kingToolbox/WindTerm", "stars": 19629, "license": "None", "language": "c", "size": 18735}
{"docstring": "/* Caller need to free the blob */\n", "func_signal": "int ssh_dh_get_current_server_publickey_blob(ssh_session session,\n                                     ssh_string *pubkey_blob)", "code": "{\n    const ssh_key pubkey = ssh_dh_get_current_server_publickey(session);\n\n    return ssh_pki_export_pubkey_blob(pubkey, pubkey_blob);\n}", "path": "WindTerm/src/libssh/src/dh.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "kingToolbox/WindTerm", "stars": 19629, "license": "None", "language": "c", "size": 18735}
{"docstring": "/**\n * udev_enumerate_scan_devices:\n * @udev_enumerate: udev enumeration context\n *\n * Scan /sys for all devices which match the given filters. No matches\n * will return all currently available devices.\n *\n * Returns: 0 on success, otherwise a negative error value.\n **/\n", "func_signal": "_public_ int udev_enumerate_scan_devices(struct udev_enumerate *udev_enumerate)", "code": "{\n        assert_return(udev_enumerate, -EINVAL);\n\n        return device_enumerator_scan_devices(udev_enumerate->enumerator);\n}", "path": "systemd/src/libudev/libudev-enumerate.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "systemd/systemd", "stars": 12241, "license": "gpl-2.0", "language": "c", "size": 356800}
{"docstring": "/**\n * udev_enumerate_add_match_subsystem:\n * @udev_enumerate: context\n * @subsystem: filter for a subsystem of the device to include in the list\n *\n * Match only devices belonging to a certain kernel subsystem.\n *\n * Returns: 0 on success, otherwise a negative error value.\n */\n", "func_signal": "_public_ int udev_enumerate_add_match_subsystem(struct udev_enumerate *udev_enumerate, const char *subsystem)", "code": "{\n        int r;\n\n        assert_return(udev_enumerate, -EINVAL);\n\n        if (!subsystem)\n                return 0;\n\n        r = sd_device_enumerator_add_match_subsystem(udev_enumerate->enumerator, subsystem, true);\n        if (r < 0)\n                return r;\n\n        udev_enumerate->devices_uptodate = false;\n        return 0;\n}", "path": "systemd/src/libudev/libudev-enumerate.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "systemd/systemd", "stars": 12241, "license": "gpl-2.0", "language": "c", "size": 356800}
{"docstring": "/**\n * udev_enumerate_add_nomatch_subsystem:\n * @udev_enumerate: context\n * @subsystem: filter for a subsystem of the device to exclude from the list\n *\n * Match only devices not belonging to a certain kernel subsystem.\n *\n * Returns: 0 on success, otherwise a negative error value.\n */\n", "func_signal": "_public_ int udev_enumerate_add_nomatch_subsystem(struct udev_enumerate *udev_enumerate, const char *subsystem)", "code": "{\n        int r;\n\n        assert_return(udev_enumerate, -EINVAL);\n\n        if (!subsystem)\n                return 0;\n\n        r = sd_device_enumerator_add_match_subsystem(udev_enumerate->enumerator, subsystem, false);\n        if (r < 0)\n                return r;\n\n        udev_enumerate->devices_uptodate = false;\n        return 0;\n}", "path": "systemd/src/libudev/libudev-enumerate.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "systemd/systemd", "stars": 12241, "license": "gpl-2.0", "language": "c", "size": 356800}
{"docstring": "/**\n * udev_monitor_new_from_netlink:\n * @udev: udev library context\n * @name: name of event source\n *\n * Create new udev monitor and connect to a specified event\n * source. Valid sources identifiers are \"udev\" and \"kernel\".\n *\n * Applications should usually not connect directly to the\n * \"kernel\" events, because the devices might not be usable\n * at that time, before udev has configured them, and created\n * device nodes. Accessing devices at the same time as udev,\n * might result in unpredictable behavior. The \"udev\" events\n * are sent out after udev has finished its event processing,\n * all rules have been processed, and needed device nodes are\n * created.\n *\n * The initial refcount is 1, and needs to be decremented to\n * release the resources of the udev monitor.\n *\n * Returns: a new udev monitor, or #NULL, in case of an error\n **/\n", "func_signal": "_public_ struct udev_monitor *udev_monitor_new_from_netlink(struct udev *udev, const char *name)", "code": "{\n        _cleanup_(sd_device_monitor_unrefp) sd_device_monitor *m = NULL;\n        struct udev_monitor *udev_monitor;\n        MonitorNetlinkGroup g;\n        int r;\n\n        g = monitor_netlink_group_from_string(name);\n        if (g < 0)\n                return_with_errno(NULL, EINVAL);\n\n        r = device_monitor_new_full(&m, g, -1);\n        if (r < 0)\n                return_with_errno(NULL, r);\n\n        udev_monitor = new(struct udev_monitor, 1);\n        if (!udev_monitor)\n                return_with_errno(NULL, ENOMEM);\n\n        *udev_monitor = (struct udev_monitor) {\n                .udev = udev,\n                .n_ref = 1,\n                .monitor = TAKE_PTR(m),\n        };\n\n        return udev_monitor;\n}", "path": "systemd/src/libudev/libudev-monitor.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "systemd/systemd", "stars": 12241, "license": "gpl-2.0", "language": "c", "size": 356800}
{"docstring": "/**\n * udev_monitor_filter_update:\n * @udev_monitor: monitor\n *\n * Update the installed socket filter. This is only needed,\n * if the filter was removed or changed.\n *\n * Returns: 0 on success, otherwise a negative error value.\n */\n", "func_signal": "_public_ int udev_monitor_filter_update(struct udev_monitor *udev_monitor)", "code": "{\n        assert_return(udev_monitor, -EINVAL);\n\n        return sd_device_monitor_filter_update(udev_monitor->monitor);\n}", "path": "systemd/src/libudev/libudev-monitor.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "systemd/systemd", "stars": 12241, "license": "gpl-2.0", "language": "c", "size": 356800}
{"docstring": "/**\n * udev_monitor_set_receive_buffer_size:\n * @udev_monitor: the monitor which should receive events\n * @size: the size in bytes\n *\n * Set the size of the kernel socket buffer. This call needs the\n * appropriate privileges to succeed.\n *\n * Returns: 0 on success, otherwise -1 on error.\n */\n", "func_signal": "_public_ int udev_monitor_set_receive_buffer_size(struct udev_monitor *udev_monitor, int size)", "code": "{\n        assert_return(udev_monitor, -EINVAL);\n\n        return sd_device_monitor_set_receive_buffer_size(udev_monitor->monitor, (size_t) size);\n}", "path": "systemd/src/libudev/libudev-monitor.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "systemd/systemd", "stars": 12241, "license": "gpl-2.0", "language": "c", "size": 356800}
{"docstring": "/**\n * udev_monitor_get_udev:\n * @udev_monitor: udev monitor\n *\n * Retrieve the udev library context the monitor was created with.\n *\n * Returns: the udev library context\n **/\n", "func_signal": "_public_ struct udev *udev_monitor_get_udev(struct udev_monitor *udev_monitor)", "code": "{\n        assert_return(udev_monitor, NULL);\n\n        return udev_monitor->udev;\n}", "path": "systemd/src/libudev/libudev-monitor.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "systemd/systemd", "stars": 12241, "license": "gpl-2.0", "language": "c", "size": 356800}
{"docstring": "/**\n * udev_enumerate_get_list_entry:\n * @udev_enumerate: context\n *\n * Get the first entry of the sorted list of device paths.\n *\n * Returns: a udev_list_entry.\n */\n", "func_signal": "_public_ struct udev_list_entry *udev_enumerate_get_list_entry(struct udev_enumerate *udev_enumerate)", "code": "{\n        struct udev_list_entry *e;\n\n        assert_return_errno(udev_enumerate, NULL, EINVAL);\n\n        if (!udev_enumerate->devices_uptodate) {\n                sd_device *device;\n\n                udev_list_cleanup(udev_enumerate->devices_list);\n\n                FOREACH_DEVICE_AND_SUBSYSTEM(udev_enumerate->enumerator, device) {\n                        const char *syspath;\n                        int r;\n\n                        r = sd_device_get_syspath(device, &syspath);\n                        if (r < 0)\n                                return_with_errno(NULL, r);\n\n                        if (!udev_list_entry_add(udev_enumerate->devices_list, syspath, NULL))\n                                return_with_errno(NULL, ENOMEM);\n                }\n\n                udev_enumerate->devices_uptodate = true;\n        }\n\n        e = udev_list_get_entry(udev_enumerate->devices_list);\n        if (!e)\n                return_with_errno(NULL, ENODATA);\n\n        return e;\n}", "path": "systemd/src/libudev/libudev-enumerate.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "systemd/systemd", "stars": 12241, "license": "gpl-2.0", "language": "c", "size": 356800}
{"docstring": "/* Compile instructions for one list of addresses, one direction and one specific verdict on matches. */\n", "func_signal": "static int add_lookup_instructions(\n                BPFProgram *p,\n                int map_fd,\n                int protocol,\n                bool is_ingress,\n                int verdict)", "code": "{\n\n        int r, addr_offset, addr_size;\n\n        assert(p);\n        assert(map_fd >= 0);\n\n        switch (protocol) {\n\n        case ETH_P_IP:\n                addr_size = sizeof(uint32_t);\n                addr_offset = is_ingress ?\n                        offsetof(struct iphdr, saddr) :\n                        offsetof(struct iphdr, daddr);\n                break;\n\n        case ETH_P_IPV6:\n                addr_size = 4 * sizeof(uint32_t);\n                addr_offset = is_ingress ?\n                        offsetof(struct ip6_hdr, ip6_src.s6_addr) :\n                        offsetof(struct ip6_hdr, ip6_dst.s6_addr);\n                break;\n\n        default:\n                return -EAFNOSUPPORT;\n        }\n\n        do {\n                /* Compare IPv4 with one word instruction (32bit) */\n                struct bpf_insn insn[] = {\n                        /* If skb->protocol != ETH_P_IP, skip this whole block. The offset will be set later. */\n                        BPF_JMP_IMM(BPF_JNE, BPF_REG_7, htobe16(protocol), 0),\n\n                        /*\n                         * Call into BPF_FUNC_skb_load_bytes to load the dst/src IP address\n                         *\n                         * R1: Pointer to the skb\n                         * R2: Data offset\n                         * R3: Destination buffer on the stack (r10 - 4)\n                         * R4: Number of bytes to read (4)\n                         */\n\n                        BPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n                        BPF_MOV32_IMM(BPF_REG_2, addr_offset),\n\n                        BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),\n                        BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -addr_size),\n\n                        BPF_MOV32_IMM(BPF_REG_4, addr_size),\n                        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_skb_load_bytes),\n\n                        /*\n                         * Call into BPF_FUNC_map_lookup_elem to see if the address matches any entry in the\n                         * LPM trie map. For this to work, the prefixlen field of 'struct bpf_lpm_trie_key'\n                         * has to be set to the maximum possible value.\n                         *\n                         * On success, the looked up value is stored in R0. For this application, the actual\n                         * value doesn't matter, however; we just set the bit in @verdict in R8 if we found any\n                         * matching value.\n                         */\n\n                        BPF_LD_MAP_FD(BPF_REG_1, map_fd),\n                        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n                        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -addr_size - sizeof(uint32_t)),\n                        BPF_ST_MEM(BPF_W, BPF_REG_2, 0, addr_size * 8),\n\n                        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n                        BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 1),\n                        BPF_ALU32_IMM(BPF_OR, BPF_REG_8, verdict),\n                };\n\n                /* Jump label fixup */\n                insn[0].off = ELEMENTSOF(insn) - 1;\n\n                r = bpf_program_add_instructions(p, insn, ELEMENTSOF(insn));\n                if (r < 0)\n                        return r;\n\n        } while (false);\n\n        return 0;\n}", "path": "systemd/src/core/bpf-firewall.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "systemd/systemd", "stars": 12241, "license": "gpl-2.0", "language": "c", "size": 356800}
{"docstring": "/**\n * udev_monitor_filter_add_match_subsystem_devtype:\n * @udev_monitor: the monitor\n * @subsystem: the subsystem value to match the incoming devices against\n * @devtype: the devtype value to match the incoming devices against\n *\n * This filter is efficiently executed inside the kernel, and libudev subscribers\n * will usually not be woken up for devices which do not match.\n *\n * The filter must be installed before the monitor is switched to listening mode.\n *\n * Returns: 0 on success, otherwise a negative error value.\n */\n", "func_signal": "_public_ int udev_monitor_filter_add_match_subsystem_devtype(struct udev_monitor *udev_monitor, const char *subsystem, const char *devtype)", "code": "{\n        assert_return(udev_monitor, -EINVAL);\n\n        return sd_device_monitor_filter_add_match_subsystem_devtype(udev_monitor->monitor, subsystem, devtype);\n}", "path": "systemd/src/libudev/libudev-monitor.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "systemd/systemd", "stars": 12241, "license": "gpl-2.0", "language": "c", "size": 356800}
{"docstring": "/**\n * udev_monitor_receive_device:\n * @udev_monitor: udev monitor\n *\n * Receive data from the udev monitor socket, allocate a new udev\n * device, fill in the received data, and return the device.\n *\n * Only socket connections with uid=0 are accepted.\n *\n * The monitor socket is by default set to NONBLOCK. A variant of poll() on\n * the file descriptor returned by udev_monitor_get_fd() should to be used to\n * wake up when new devices arrive, or alternatively the file descriptor\n * switched into blocking mode.\n *\n * The initial refcount is 1, and needs to be decremented to\n * release the resources of the udev device.\n *\n * Returns: a new udev device, or #NULL, in case of an error\n **/\n", "func_signal": "_public_ struct udev_device *udev_monitor_receive_device(struct udev_monitor *udev_monitor)", "code": "{\n        _cleanup_(sd_device_unrefp) sd_device *device = NULL;\n        int r;\n\n        assert_return(udev_monitor, NULL);\n\n        r = udev_monitor_receive_sd_device(udev_monitor, &device);\n        if (r < 0)\n                return_with_errno(NULL, r);\n\n        return udev_device_new(udev_monitor->udev, device);\n}", "path": "systemd/src/libudev/libudev-monitor.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "systemd/systemd", "stars": 12241, "license": "gpl-2.0", "language": "c", "size": 356800}
{"docstring": "/**\n * udev_enumerate_add_match_sysattr:\n * @udev_enumerate: context\n * @sysattr: filter for a sys attribute at the device to include in the list\n * @value: optional value of the sys attribute\n *\n * Match only devices with a certain /sys device attribute.\n *\n * Returns: 0 on success, otherwise a negative error value.\n */\n", "func_signal": "_public_ int udev_enumerate_add_match_sysattr(struct udev_enumerate *udev_enumerate, const char *sysattr, const char *value)", "code": "{\n        int r;\n\n        assert_return(udev_enumerate, -EINVAL);\n\n        if (!sysattr)\n                return 0;\n\n        r = sd_device_enumerator_add_match_sysattr(udev_enumerate->enumerator, sysattr, value, true);\n        if (r < 0)\n                return r;\n\n        udev_enumerate->devices_uptodate = false;\n        return 0;\n}", "path": "systemd/src/libudev/libudev-enumerate.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "systemd/systemd", "stars": 12241, "license": "gpl-2.0", "language": "c", "size": 356800}
{"docstring": "/**\n * udev_enumerate_add_match_sysname:\n * @udev_enumerate: context\n * @sysname: filter for the name of the device to include in the list\n *\n * Match only devices with a given /sys device name.\n *\n * Returns: 0 on success, otherwise a negative error value.\n */\n", "func_signal": "_public_ int udev_enumerate_add_match_sysname(struct udev_enumerate *udev_enumerate, const char *sysname)", "code": "{\n        int r;\n\n        assert_return(udev_enumerate, -EINVAL);\n\n        if (!sysname)\n                return 0;\n\n        r = sd_device_enumerator_add_match_sysname(udev_enumerate->enumerator, sysname);\n        if (r < 0)\n                return r;\n\n        udev_enumerate->devices_uptodate = false;\n        return 0;\n}", "path": "systemd/src/libudev/libudev-enumerate.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "systemd/systemd", "stars": 12241, "license": "gpl-2.0", "language": "c", "size": 356800}
{"docstring": "/**\n * udev_monitor_filter_add_match_tag:\n * @udev_monitor: the monitor\n * @tag: the name of a tag\n *\n * This filter is efficiently executed inside the kernel, and libudev subscribers\n * will usually not be woken up for devices which do not match.\n *\n * The filter must be installed before the monitor is switched to listening mode.\n *\n * Returns: 0 on success, otherwise a negative error value.\n */\n", "func_signal": "_public_ int udev_monitor_filter_add_match_tag(struct udev_monitor *udev_monitor, const char *tag)", "code": "{\n        assert_return(udev_monitor, -EINVAL);\n\n        return sd_device_monitor_filter_add_match_tag(udev_monitor->monitor, tag);\n}", "path": "systemd/src/libudev/libudev-monitor.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "systemd/systemd", "stars": 12241, "license": "gpl-2.0", "language": "c", "size": 356800}
{"docstring": "/**\n * udev_enumerate_add_match_parent:\n * @udev_enumerate: context\n * @parent: parent device where to start searching\n *\n * Return the devices on the subtree of one given device. The parent\n * itself is included in the list.\n *\n * Returns: 0 on success, otherwise a negative error value.\n */\n", "func_signal": "_public_ int udev_enumerate_add_match_parent(struct udev_enumerate *udev_enumerate, struct udev_device *parent)", "code": "{\n        int r;\n\n        assert_return(udev_enumerate, -EINVAL);\n\n        if (!parent)\n                return 0;\n\n        r = sd_device_enumerator_add_match_parent(udev_enumerate->enumerator, udev_device_get_sd_device(parent));\n        if (r < 0)\n                return r;\n\n        udev_enumerate->devices_uptodate = false;\n        return 0;\n}", "path": "systemd/src/libudev/libudev-enumerate.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "systemd/systemd", "stars": 12241, "license": "gpl-2.0", "language": "c", "size": 356800}
{"docstring": "/**\n * udev_enumerate_add_match_is_initialized:\n * @udev_enumerate: context\n *\n * Match only devices which udev has set up already. This makes\n * sure, that the device node permissions and context are properly set\n * and that network devices are fully renamed.\n *\n * Usually, devices which are found in the kernel but not already\n * handled by udev, have still pending events. Services should subscribe\n * to monitor events and wait for these devices to become ready, instead\n * of using uninitialized devices.\n *\n * For now, this will not affect devices which do not have a device node\n * and are not network interfaces.\n *\n * Returns: 0 on success, otherwise a negative error value.\n */\n", "func_signal": "_public_ int udev_enumerate_add_match_is_initialized(struct udev_enumerate *udev_enumerate)", "code": "{\n        int r;\n\n        assert_return(udev_enumerate, -EINVAL);\n\n        r = device_enumerator_add_match_is_initialized(udev_enumerate->enumerator);\n        if (r < 0)\n                return r;\n\n        udev_enumerate->devices_uptodate = false;\n        return 0;\n}", "path": "systemd/src/libudev/libudev-enumerate.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "systemd/systemd", "stars": 12241, "license": "gpl-2.0", "language": "c", "size": 356800}
{"docstring": "/**\n * udev_enumerate_add_syspath:\n * @udev_enumerate: context\n * @syspath: path of a device\n *\n * Add a device to the list of devices, to retrieve it back sorted in dependency order.\n *\n * Returns: 0 on success, otherwise a negative error value.\n */\n", "func_signal": "_public_ int udev_enumerate_add_syspath(struct udev_enumerate *udev_enumerate, const char *syspath)", "code": "{\n        _cleanup_(sd_device_unrefp) sd_device *device = NULL;\n        int r;\n\n        assert_return(udev_enumerate, -EINVAL);\n\n        if (!syspath)\n                return 0;\n\n        r = sd_device_new_from_syspath(&device, syspath);\n        if (r < 0)\n                return r;\n\n        r = device_enumerator_add_device(udev_enumerate->enumerator, device);\n        if (r < 0)\n                return r;\n\n        udev_enumerate->devices_uptodate = false;\n        return 0;\n}", "path": "systemd/src/libudev/libudev-enumerate.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "systemd/systemd", "stars": 12241, "license": "gpl-2.0", "language": "c", "size": 356800}
{"docstring": "/**\n * udev_monitor_get_fd:\n * @udev_monitor: udev monitor\n *\n * Retrieve the socket file descriptor associated with the monitor.\n *\n * Returns: the socket file descriptor\n **/\n", "func_signal": "_public_ int udev_monitor_get_fd(struct udev_monitor *udev_monitor)", "code": "{\n        assert_return(udev_monitor, -EINVAL);\n\n        return device_monitor_get_fd(udev_monitor->monitor);\n}", "path": "systemd/src/libudev/libudev-monitor.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "systemd/systemd", "stars": 12241, "license": "gpl-2.0", "language": "c", "size": 356800}
{"docstring": "/**\n * udev_enumerate_add_match_tag:\n * @udev_enumerate: context\n * @tag: filter for a tag of the device to include in the list\n *\n * Match only devices with a certain tag.\n *\n * Returns: 0 on success, otherwise a negative error value.\n */\n", "func_signal": "_public_ int udev_enumerate_add_match_tag(struct udev_enumerate *udev_enumerate, const char *tag)", "code": "{\n        int r;\n\n        assert_return(udev_enumerate, -EINVAL);\n\n        if (!tag)\n                return 0;\n\n        r = sd_device_enumerator_add_match_tag(udev_enumerate->enumerator, tag);\n        if (r < 0)\n                return r;\n\n        udev_enumerate->devices_uptodate = false;\n        return 0;\n}", "path": "systemd/src/libudev/libudev-enumerate.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "systemd/systemd", "stars": 12241, "license": "gpl-2.0", "language": "c", "size": 356800}
{"docstring": "/**\n * udev_monitor_enable_receiving:\n * @udev_monitor: the monitor which should receive events\n *\n * Binds the @udev_monitor socket to the event source.\n *\n * Returns: 0 on success, otherwise a negative error value.\n */\n", "func_signal": "_public_ int udev_monitor_enable_receiving(struct udev_monitor *udev_monitor)", "code": "{\n        assert_return(udev_monitor, -EINVAL);\n\n        return device_monitor_enable_receiving(udev_monitor->monitor);\n}", "path": "systemd/src/libudev/libudev-monitor.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "systemd/systemd", "stars": 12241, "license": "gpl-2.0", "language": "c", "size": 356800}
{"docstring": "/**\n * Innermost print function for our kernel, directly accesses the video memory \n *\n * If 'col' and 'row' are negative, we will print at current cursor location\n * If 'attr' is zero it will use 'white on black' as default\n * Returns the offset of the next character\n * Sets the video cursor to the returned offset\n */\n", "func_signal": "int print_char(char c, int col, int row, char attr)", "code": "{\n    uint8_t *vidmem = (uint8_t*) VIDEO_ADDRESS;\n    if (!attr) attr = WHITE_ON_BLACK;\n\n    /* Error control: print a red 'E' if the coords aren't right */\n    if (col >= MAX_COLS || row >= MAX_ROWS) {\n        vidmem[2*(MAX_COLS)*(MAX_ROWS)-2] = 'E';\n        vidmem[2*(MAX_COLS)*(MAX_ROWS)-1] = RED_ON_WHITE;\n        return get_offset(col, row);\n    }\n\n    int offset;\n    if (col >= 0 && row >= 0) offset = get_offset(col, row);\n    else offset = get_cursor_offset();\n\n    if (c == '\\n') {\n        row = get_offset_row(offset);\n        offset = get_offset(0, row+1);\n    } else if (c == 0x08) { /* Backspace */\n        vidmem[offset] = ' ';\n        vidmem[offset+1] = attr;\n    } else {\n        vidmem[offset] = c;\n        vidmem[offset+1] = attr;\n        offset += 2;\n    }\n\n    /* Check if the offset is over screen size and scroll */\n    if (offset >= MAX_ROWS * MAX_COLS * 2) {\n        int i;\n        for (i = 1; i < MAX_ROWS; i++) \n            memory_copy((uint8_t*)(get_offset(0, i) + VIDEO_ADDRESS),\n                        (uint8_t*)(get_offset(0, i-1) + VIDEO_ADDRESS),\n                        MAX_COLS * 2);\n\n        /* Blank last line */\n        char *last_line = (char*) (get_offset(0, MAX_ROWS-1) + (uint8_t*) VIDEO_ADDRESS);\n        for (i = 0; i < MAX_COLS * 2; i++) last_line[i] = 0;\n\n        offset -= 2 * MAX_COLS;\n    }\n\n    set_cursor_offset(offset);\n    return offset;\n}", "path": "os-tutorial/23-fixes/drivers/screen.c", "commit_date": "2015-08-18 00:00:00", "repo_name": "cfenollosa/os-tutorial", "stars": 26177, "license": "bsd-3-clause", "language": "c", "size": 152}
{"docstring": "/**\n * Print a message on the specified location\n * If col, row, are negative, we will use the current offset\n */\n", "func_signal": "void kprint_at(char *message, int col, int row)", "code": "{\n    /* Set cursor if col/row are negative */\n    int offset;\n    if (col >= 0 && row >= 0)\n        offset = get_offset(col, row);\n    else {\n        offset = get_cursor_offset();\n        row = get_offset_row(offset);\n        col = get_offset_col(offset);\n    }\n\n    /* Loop through message and print it */\n    int i = 0;\n    while (message[i] != 0) {\n        offset = print_char(message[i++], col, row, WHITE_ON_BLACK);\n        /* Compute row/col for next iteration */\n        row = get_offset_row(offset);\n        col = get_offset_col(offset);\n    }\n}", "path": "os-tutorial/23-fixes/drivers/screen.c", "commit_date": "2015-08-18 00:00:00", "repo_name": "cfenollosa/os-tutorial", "stars": 26177, "license": "bsd-3-clause", "language": "c", "size": 152}
{"docstring": "/**\n * K&R implementation\n */\n", "func_signal": "void int_to_ascii(int n, char str[])", "code": "{\n    int i, sign;\n    if ((sign = n) < 0) n = -n;\n    i = 0;\n    do {\n        str[i++] = n % 10 + '0';\n    } while ((n /= 10) > 0);\n\n    if (sign < 0) str[i++] = '-';\n    str[i] = '\\0';\n\n    reverse(str);\n}", "path": "os-tutorial/23-fixes/libc/string.c", "commit_date": "2015-08-18 00:00:00", "repo_name": "cfenollosa/os-tutorial", "stars": 26177, "license": "bsd-3-clause", "language": "c", "size": 152}
{"docstring": "/**\n * Read a byte from the specified port\n */\n", "func_signal": "unsigned char port_byte_in (unsigned short port)", "code": "{\n    unsigned char result;\n    /* Inline assembler syntax\n     * !! Notice how the source and destination registers are switched from NASM !!\n     *\n     * '\"=a\" (result)'; set '=' the C variable '(result)' to the value of register e'a'x\n     * '\"d\" (port)': map the C variable '(port)' into e'd'x register\n     *\n     * Inputs and outputs are separated by colons\n     */\n    __asm__(\"in %%dx, %%al\" : \"=a\" (result) : \"d\" (port));\n    return result;\n}", "path": "os-tutorial/16-video-driver/drivers/ports.c", "commit_date": "2014-10-22 00:00:00", "repo_name": "cfenollosa/os-tutorial", "stars": 26177, "license": "bsd-3-clause", "language": "c", "size": 152}
{"docstring": "/* Can't do this with a loop because we need the address\n * of the function names */\n", "func_signal": "void isr_install()", "code": "{\n    set_idt_gate(0, (uint32_t)isr0);\n    set_idt_gate(1, (uint32_t)isr1);\n    set_idt_gate(2, (uint32_t)isr2);\n    set_idt_gate(3, (uint32_t)isr3);\n    set_idt_gate(4, (uint32_t)isr4);\n    set_idt_gate(5, (uint32_t)isr5);\n    set_idt_gate(6, (uint32_t)isr6);\n    set_idt_gate(7, (uint32_t)isr7);\n    set_idt_gate(8, (uint32_t)isr8);\n    set_idt_gate(9, (uint32_t)isr9);\n    set_idt_gate(10, (uint32_t)isr10);\n    set_idt_gate(11, (uint32_t)isr11);\n    set_idt_gate(12, (uint32_t)isr12);\n    set_idt_gate(13, (uint32_t)isr13);\n    set_idt_gate(14, (uint32_t)isr14);\n    set_idt_gate(15, (uint32_t)isr15);\n    set_idt_gate(16, (uint32_t)isr16);\n    set_idt_gate(17, (uint32_t)isr17);\n    set_idt_gate(18, (uint32_t)isr18);\n    set_idt_gate(19, (uint32_t)isr19);\n    set_idt_gate(20, (uint32_t)isr20);\n    set_idt_gate(21, (uint32_t)isr21);\n    set_idt_gate(22, (uint32_t)isr22);\n    set_idt_gate(23, (uint32_t)isr23);\n    set_idt_gate(24, (uint32_t)isr24);\n    set_idt_gate(25, (uint32_t)isr25);\n    set_idt_gate(26, (uint32_t)isr26);\n    set_idt_gate(27, (uint32_t)isr27);\n    set_idt_gate(28, (uint32_t)isr28);\n    set_idt_gate(29, (uint32_t)isr29);\n    set_idt_gate(30, (uint32_t)isr30);\n    set_idt_gate(31, (uint32_t)isr31);\n\n    // Remap the PIC\n    port_byte_out(0x20, 0x11);\n    port_byte_out(0xA0, 0x11);\n    port_byte_out(0x21, 0x20);\n    port_byte_out(0xA1, 0x28);\n    port_byte_out(0x21, 0x04);\n    port_byte_out(0xA1, 0x02);\n    port_byte_out(0x21, 0x01);\n    port_byte_out(0xA1, 0x01);\n    port_byte_out(0x21, 0x0);\n    port_byte_out(0xA1, 0x0); \n\n    // Install the IRQs\n    set_idt_gate(32, (uint32_t)irq0);\n    set_idt_gate(33, (uint32_t)irq1);\n    set_idt_gate(34, (uint32_t)irq2);\n    set_idt_gate(35, (uint32_t)irq3);\n    set_idt_gate(36, (uint32_t)irq4);\n    set_idt_gate(37, (uint32_t)irq5);\n    set_idt_gate(38, (uint32_t)irq6);\n    set_idt_gate(39, (uint32_t)irq7);\n    set_idt_gate(40, (uint32_t)irq8);\n    set_idt_gate(41, (uint32_t)irq9);\n    set_idt_gate(42, (uint32_t)irq10);\n    set_idt_gate(43, (uint32_t)irq11);\n    set_idt_gate(44, (uint32_t)irq12);\n    set_idt_gate(45, (uint32_t)irq13);\n    set_idt_gate(46, (uint32_t)irq14);\n    set_idt_gate(47, (uint32_t)irq15);\n\n    set_idt(); // Load with ASM\n}", "path": "os-tutorial/23-fixes/cpu/isr.c", "commit_date": "2015-08-28 00:00:00", "repo_name": "cfenollosa/os-tutorial", "stars": 26177, "license": "bsd-3-clause", "language": "c", "size": 152}
{"docstring": "/* Can't do this with a loop because we need the address\n * of the function names */\n", "func_signal": "void isr_install()", "code": "{\n    set_idt_gate(0, (u32)isr0);\n    set_idt_gate(1, (u32)isr1);\n    set_idt_gate(2, (u32)isr2);\n    set_idt_gate(3, (u32)isr3);\n    set_idt_gate(4, (u32)isr4);\n    set_idt_gate(5, (u32)isr5);\n    set_idt_gate(6, (u32)isr6);\n    set_idt_gate(7, (u32)isr7);\n    set_idt_gate(8, (u32)isr8);\n    set_idt_gate(9, (u32)isr9);\n    set_idt_gate(10, (u32)isr10);\n    set_idt_gate(11, (u32)isr11);\n    set_idt_gate(12, (u32)isr12);\n    set_idt_gate(13, (u32)isr13);\n    set_idt_gate(14, (u32)isr14);\n    set_idt_gate(15, (u32)isr15);\n    set_idt_gate(16, (u32)isr16);\n    set_idt_gate(17, (u32)isr17);\n    set_idt_gate(18, (u32)isr18);\n    set_idt_gate(19, (u32)isr19);\n    set_idt_gate(20, (u32)isr20);\n    set_idt_gate(21, (u32)isr21);\n    set_idt_gate(22, (u32)isr22);\n    set_idt_gate(23, (u32)isr23);\n    set_idt_gate(24, (u32)isr24);\n    set_idt_gate(25, (u32)isr25);\n    set_idt_gate(26, (u32)isr26);\n    set_idt_gate(27, (u32)isr27);\n    set_idt_gate(28, (u32)isr28);\n    set_idt_gate(29, (u32)isr29);\n    set_idt_gate(30, (u32)isr30);\n    set_idt_gate(31, (u32)isr31);\n\n    // Remap the PIC\n    port_byte_out(0x20, 0x11);\n    port_byte_out(0xA0, 0x11);\n    port_byte_out(0x21, 0x20);\n    port_byte_out(0xA1, 0x28);\n    port_byte_out(0x21, 0x04);\n    port_byte_out(0xA1, 0x02);\n    port_byte_out(0x21, 0x01);\n    port_byte_out(0xA1, 0x01);\n    port_byte_out(0x21, 0x0);\n    port_byte_out(0xA1, 0x0); \n\n    // Install the IRQs\n    set_idt_gate(32, (u32)irq0);\n    set_idt_gate(33, (u32)irq1);\n    set_idt_gate(34, (u32)irq2);\n    set_idt_gate(35, (u32)irq3);\n    set_idt_gate(36, (u32)irq4);\n    set_idt_gate(37, (u32)irq5);\n    set_idt_gate(38, (u32)irq6);\n    set_idt_gate(39, (u32)irq7);\n    set_idt_gate(40, (u32)irq8);\n    set_idt_gate(41, (u32)irq9);\n    set_idt_gate(42, (u32)irq10);\n    set_idt_gate(43, (u32)irq11);\n    set_idt_gate(44, (u32)irq12);\n    set_idt_gate(45, (u32)irq13);\n    set_idt_gate(46, (u32)irq14);\n    set_idt_gate(47, (u32)irq15);\n\n    set_idt(); // Load with ASM\n}", "path": "os-tutorial/21-shell/cpu/isr.c", "commit_date": "2015-03-23 00:00:00", "repo_name": "cfenollosa/os-tutorial", "stars": 26177, "license": "bsd-3-clause", "language": "c", "size": 152}
{"docstring": "/**\n * Read a byte from the specified port\n */\n", "func_signal": "u8 port_byte_in (u16 port)", "code": "{\n    u8 result;\n    /* Inline assembler syntax\n     * !! Notice how the source and destination registers are switched from NASM !!\n     *\n     * '\"=a\" (result)'; set '=' the C variable '(result)' to the value of register e'a'x\n     * '\"d\" (port)': map the C variable '(port)' into e'd'x register\n     *\n     * Inputs and outputs are separated by colons\n     */\n    __asm__(\"in %%dx, %%al\" : \"=a\" (result) : \"d\" (port));\n    return result;\n}", "path": "os-tutorial/22-malloc/cpu/ports.c", "commit_date": "2015-05-18 00:00:00", "repo_name": "cfenollosa/os-tutorial", "stars": 26177, "license": "bsd-3-clause", "language": "c", "size": 152}
{"docstring": "/* Implementation is just a pointer to some free memory which\n * keeps growing */\n", "func_signal": "u32 kmalloc(u32 size, int align, u32 *phys_addr)", "code": "{\n    /* Pages are aligned to 4K, or 0x1000 */\n    if (align == 1 && (free_mem_addr & 0xFFFFF000)) {\n        free_mem_addr &= 0xFFFFF000;\n        free_mem_addr += 0x1000;\n    }\n    /* Save also the physical address */\n    if (phys_addr) *phys_addr = free_mem_addr;\n\n    u32 ret = free_mem_addr;\n    free_mem_addr += size; /* Remember to increment the pointer */\n    return ret;\n}", "path": "os-tutorial/22-malloc/libc/mem.c", "commit_date": "2015-04-01 00:00:00", "repo_name": "cfenollosa/os-tutorial", "stars": 26177, "license": "bsd-3-clause", "language": "c", "size": 152}
{"docstring": "/**\n * Read a byte from the specified port\n */\n", "func_signal": "u8 port_byte_in (u16 port)", "code": "{\n    u8 result;\n    /* Inline assembler syntax\n     * !! Notice how the source and destination registers are switched from NASM !!\n     *\n     * '\"=a\" (result)'; set '=' the C variable '(result)' to the value of register e'a'x\n     * '\"d\" (port)': map the C variable '(port)' into e'd'x register\n     *\n     * Inputs and outputs are separated by colons\n     */\n    __asm__(\"in %%dx, %%al\" : \"=a\" (result) : \"d\" (port));\n    return result;\n}", "path": "os-tutorial/18-interrupts/drivers/ports.c", "commit_date": "2015-02-02 00:00:00", "repo_name": "cfenollosa/os-tutorial", "stars": 26177, "license": "bsd-3-clause", "language": "c", "size": 152}
{"docstring": "/* Can't do this with a loop because we need the address\n * of the function names */\n", "func_signal": "void isr_install()", "code": "{\n    set_idt_gate(0, (u32)isr0);\n    set_idt_gate(1, (u32)isr1);\n    set_idt_gate(2, (u32)isr2);\n    set_idt_gate(3, (u32)isr3);\n    set_idt_gate(4, (u32)isr4);\n    set_idt_gate(5, (u32)isr5);\n    set_idt_gate(6, (u32)isr6);\n    set_idt_gate(7, (u32)isr7);\n    set_idt_gate(8, (u32)isr8);\n    set_idt_gate(9, (u32)isr9);\n    set_idt_gate(10, (u32)isr10);\n    set_idt_gate(11, (u32)isr11);\n    set_idt_gate(12, (u32)isr12);\n    set_idt_gate(13, (u32)isr13);\n    set_idt_gate(14, (u32)isr14);\n    set_idt_gate(15, (u32)isr15);\n    set_idt_gate(16, (u32)isr16);\n    set_idt_gate(17, (u32)isr17);\n    set_idt_gate(18, (u32)isr18);\n    set_idt_gate(19, (u32)isr19);\n    set_idt_gate(20, (u32)isr20);\n    set_idt_gate(21, (u32)isr21);\n    set_idt_gate(22, (u32)isr22);\n    set_idt_gate(23, (u32)isr23);\n    set_idt_gate(24, (u32)isr24);\n    set_idt_gate(25, (u32)isr25);\n    set_idt_gate(26, (u32)isr26);\n    set_idt_gate(27, (u32)isr27);\n    set_idt_gate(28, (u32)isr28);\n    set_idt_gate(29, (u32)isr29);\n    set_idt_gate(30, (u32)isr30);\n    set_idt_gate(31, (u32)isr31);\n\n    // Remap the PIC\n    port_byte_out(0x20, 0x11);\n    port_byte_out(0xA0, 0x11);\n    port_byte_out(0x21, 0x20);\n    port_byte_out(0xA1, 0x28);\n    port_byte_out(0x21, 0x04);\n    port_byte_out(0xA1, 0x02);\n    port_byte_out(0x21, 0x01);\n    port_byte_out(0xA1, 0x01);\n    port_byte_out(0x21, 0x0);\n    port_byte_out(0xA1, 0x0); \n\n    // Install the IRQs\n    set_idt_gate(32, (u32)irq0);\n    set_idt_gate(33, (u32)irq1);\n    set_idt_gate(34, (u32)irq2);\n    set_idt_gate(35, (u32)irq3);\n    set_idt_gate(36, (u32)irq4);\n    set_idt_gate(37, (u32)irq5);\n    set_idt_gate(38, (u32)irq6);\n    set_idt_gate(39, (u32)irq7);\n    set_idt_gate(40, (u32)irq8);\n    set_idt_gate(41, (u32)irq9);\n    set_idt_gate(42, (u32)irq10);\n    set_idt_gate(43, (u32)irq11);\n    set_idt_gate(44, (u32)irq12);\n    set_idt_gate(45, (u32)irq13);\n    set_idt_gate(46, (u32)irq14);\n    set_idt_gate(47, (u32)irq15);\n\n    set_idt(); // Load with ASM\n}", "path": "os-tutorial/22-malloc/cpu/isr.c", "commit_date": "2015-05-18 00:00:00", "repo_name": "cfenollosa/os-tutorial", "stars": 26177, "license": "bsd-3-clause", "language": "c", "size": 152}
{"docstring": "/* K&R \n * Returns <0 if s1<s2, 0 if s1==s2, >0 if s1>s2 */\n", "func_signal": "int strcmp(char s1[], char s2[])", "code": "{\n    int i;\n    for (i = 0; s1[i] == s2[i]; i++) {\n        if (s1[i] == '\\0') return 0;\n    }\n    return s1[i] - s2[i];\n}", "path": "os-tutorial/21-shell/libc/string.c", "commit_date": "2015-03-20 00:00:00", "repo_name": "cfenollosa/os-tutorial", "stars": 26177, "license": "bsd-3-clause", "language": "c", "size": 152}
{"docstring": "/**\n * K&R implementation\n */\n", "func_signal": "void int_to_ascii(int n, char str[])", "code": "{\n    int i, sign;\n    if ((sign = n) < 0) n = -n;\n    i = 0;\n    do {\n        str[i++] = n % 10 + '0';\n    } while ((n /= 10) > 0);\n\n    if (sign < 0) str[i++] = '-';\n    str[i] = '\\0';\n\n    reverse(str);\n}", "path": "os-tutorial/21-shell/libc/string.c", "commit_date": "2015-03-20 00:00:00", "repo_name": "cfenollosa/os-tutorial", "stars": 26177, "license": "bsd-3-clause", "language": "c", "size": 152}
{"docstring": "/**\n * Innermost print function for our kernel, directly accesses the video memory \n *\n * If 'col' and 'row' are negative, we will print at current cursor location\n * If 'attr' is zero it will use 'white on black' as default\n * Returns the offset of the next character\n * Sets the video cursor to the returned offset\n */\n", "func_signal": "int print_char(char c, int col, int row, char attr)", "code": "{\n    u8 *vidmem = (u8*) VIDEO_ADDRESS;\n    if (!attr) attr = WHITE_ON_BLACK;\n\n    /* Error control: print a red 'E' if the coords aren't right */\n    if (col >= MAX_COLS || row >= MAX_ROWS) {\n        vidmem[2*(MAX_COLS)*(MAX_ROWS)-2] = 'E';\n        vidmem[2*(MAX_COLS)*(MAX_ROWS)-1] = RED_ON_WHITE;\n        return get_offset(col, row);\n    }\n\n    int offset;\n    if (col >= 0 && row >= 0) offset = get_offset(col, row);\n    else offset = get_cursor_offset();\n\n    if (c == '\\n') {\n        row = get_offset_row(offset);\n        offset = get_offset(0, row+1);\n    } else if (c == 0x08) { /* Backspace */\n        vidmem[offset] = ' ';\n        vidmem[offset+1] = attr;\n    } else {\n        vidmem[offset] = c;\n        vidmem[offset+1] = attr;\n        offset += 2;\n    }\n\n    /* Check if the offset is over screen size and scroll */\n    if (offset >= MAX_ROWS * MAX_COLS * 2) {\n        int i;\n        for (i = 1; i < MAX_ROWS; i++) \n            memory_copy((u8*)(get_offset(0, i) + VIDEO_ADDRESS),\n                        (u8*)(get_offset(0, i-1) + VIDEO_ADDRESS),\n                        MAX_COLS * 2);\n\n        /* Blank last line */\n        char *last_line = (char*) (get_offset(0, MAX_ROWS-1) + (u8*) VIDEO_ADDRESS);\n        for (i = 0; i < MAX_COLS * 2; i++) last_line[i] = 0;\n\n        offset -= 2 * MAX_COLS;\n    }\n\n    set_cursor_offset(offset);\n    return offset;\n}", "path": "os-tutorial/21-shell/drivers/screen.c", "commit_date": "2015-03-23 00:00:00", "repo_name": "cfenollosa/os-tutorial", "stars": 26177, "license": "bsd-3-clause", "language": "c", "size": 152}
{"docstring": "/**\n * Read a byte from the specified port\n */\n", "func_signal": "uint8_t port_byte_in (uint16_t port)", "code": "{\n    uint8_t result;\n    /* Inline assembler syntax\n     * !! Notice how the source and destination registers are switched from NASM !!\n     *\n     * '\"=a\" (result)'; set '=' the C variable '(result)' to the value of register e'a'x\n     * '\"d\" (port)': map the C variable '(port)' into e'd'x register\n     *\n     * Inputs and outputs are separated by colons\n     */\n    asm(\"in %%dx, %%al\" : \"=a\" (result) : \"d\" (port));\n    return result;\n}", "path": "os-tutorial/23-fixes/cpu/ports.c", "commit_date": "2015-08-18 00:00:00", "repo_name": "cfenollosa/os-tutorial", "stars": 26177, "license": "bsd-3-clause", "language": "c", "size": 152}
{"docstring": "/**\n * Innermost print function for our kernel, directly accesses the video memory \n *\n * If 'col' and 'row' are negative, we will print at current cursor location\n * If 'attr' is zero it will use 'white on black' as default\n * Returns the offset of the next character\n * Sets the video cursor to the returned offset\n */\n", "func_signal": "int print_char(char c, int col, int row, char attr)", "code": "{\n    unsigned char *vidmem = (unsigned char*) VIDEO_ADDRESS;\n    if (!attr) attr = WHITE_ON_BLACK;\n\n    /* Error control: print a red 'E' if the coords aren't right */\n    if (col >= MAX_COLS || row >= MAX_ROWS) {\n        vidmem[2*(MAX_COLS)*(MAX_ROWS)-2] = 'E';\n        vidmem[2*(MAX_COLS)*(MAX_ROWS)-1] = RED_ON_WHITE;\n        return get_offset(col, row);\n    }\n\n    int offset;\n    if (col >= 0 && row >= 0) offset = get_offset(col, row);\n    else offset = get_cursor_offset();\n\n    if (c == '\\n') {\n        row = get_offset_row(offset);\n        offset = get_offset(0, row+1);\n    } else {\n        vidmem[offset] = c;\n        vidmem[offset+1] = attr;\n        offset += 2;\n    }\n    set_cursor_offset(offset);\n    return offset;\n}", "path": "os-tutorial/16-video-driver/drivers/screen.c", "commit_date": "2014-10-22 00:00:00", "repo_name": "cfenollosa/os-tutorial", "stars": 26177, "license": "bsd-3-clause", "language": "c", "size": 152}
{"docstring": "/**\n * Read a byte from the specified port\n */\n", "func_signal": "unsigned char port_byte_in (unsigned short port)", "code": "{\n    unsigned char result;\n    /* Inline assembler syntax\n     * !! Notice how the source and destination registers are switched from NASM !!\n     *\n     * '\"=a\" (result)'; set '=' the C variable '(result)' to the value of register e'a'x\n     * '\"d\" (port)': map the C variable '(port)' into e'd'x register\n     *\n     * Inputs and outputs are separated by colons\n     */\n    __asm__(\"in %%dx, %%al\" : \"=a\" (result) : \"d\" (port));\n    return result;\n}", "path": "os-tutorial/17-video-scroll/drivers/ports.c", "commit_date": "2015-02-03 00:00:00", "repo_name": "cfenollosa/os-tutorial", "stars": 26177, "license": "bsd-3-clause", "language": "c", "size": 152}
{"docstring": "/**\n * Print a message on the specified location\n * If col, row, are negative, we will use the current offset\n */\n", "func_signal": "void kprint_at(char *message, int col, int row)", "code": "{\n    /* Set cursor if col/row are negative */\n    int offset;\n    if (col >= 0 && row >= 0)\n        offset = get_offset(col, row);\n    else {\n        offset = get_cursor_offset();\n        row = get_offset_row(offset);\n        col = get_offset_col(offset);\n    }\n\n    /* Loop through message and print it */\n    int i = 0;\n    while (message[i] != 0) {\n        offset = print_char(message[i++], col, row, WHITE_ON_BLACK);\n        /* Compute row/col for next iteration */\n        row = get_offset_row(offset);\n        col = get_offset_col(offset);\n    }\n}", "path": "os-tutorial/21-shell/drivers/screen.c", "commit_date": "2015-03-23 00:00:00", "repo_name": "cfenollosa/os-tutorial", "stars": 26177, "license": "bsd-3-clause", "language": "c", "size": 152}
{"docstring": "/**\n * Print a message on the specified location\n * If col, row, are negative, we will use the current offset\n */\n", "func_signal": "void kprint_at(char *message, int col, int row)", "code": "{\n    /* Set cursor if col/row are negative */\n    int offset;\n    if (col >= 0 && row >= 0)\n        offset = get_offset(col, row);\n    else {\n        offset = get_cursor_offset();\n        row = get_offset_row(offset);\n        col = get_offset_col(offset);\n    }\n\n    /* Loop through message and print it */\n    int i = 0;\n    while (message[i] != 0) {\n        offset = print_char(message[i++], col, row, WHITE_ON_BLACK);\n        /* Compute row/col for next iteration */\n        row = get_offset_row(offset);\n        col = get_offset_col(offset);\n    }\n}", "path": "os-tutorial/16-video-driver/drivers/screen.c", "commit_date": "2014-10-22 00:00:00", "repo_name": "cfenollosa/os-tutorial", "stars": 26177, "license": "bsd-3-clause", "language": "c", "size": 152}
{"docstring": "/* K&R \n * Returns <0 if s1<s2, 0 if s1==s2, >0 if s1>s2 */\n", "func_signal": "int strcmp(char s1[], char s2[])", "code": "{\n    int i;\n    for (i = 0; s1[i] == s2[i]; i++) {\n        if (s1[i] == '\\0') return 0;\n    }\n    return s1[i] - s2[i];\n}", "path": "os-tutorial/23-fixes/libc/string.c", "commit_date": "2015-08-18 00:00:00", "repo_name": "cfenollosa/os-tutorial", "stars": 26177, "license": "bsd-3-clause", "language": "c", "size": 152}
{"docstring": "/**\n * K&R implementation\n */\n", "func_signal": "void int_to_ascii(int n, char str[])", "code": "{\n    int i, sign;\n    if ((sign = n) < 0) n = -n;\n    i = 0;\n    do {\n        str[i++] = n % 10 + '0';\n    } while ((n /= 10) > 0);\n\n    if (sign < 0) str[i++] = '-';\n    str[i] = '\\0';\n\n    /* TODO: implement \"reverse\" */\n}", "path": "os-tutorial/19-interrupts-irqs/kernel/util.c", "commit_date": "2015-03-17 00:00:00", "repo_name": "cfenollosa/os-tutorial", "stars": 26177, "license": "bsd-3-clause", "language": "c", "size": 152}
{"docstring": "/** Initialize the BinReloc library (for libraries).\n *\n * This function must be called before using any other BinReloc functions.\n * It attempts to locate the calling library's canonical filename.\n *\n * @note The BinReloc source code MUST be included in your library, or this\n *       function won't work correctly.\n *\n * @param error  If BinReloc failed to initialize, then the error code will\n *               be stored in this variable. Set to NULL if you want to\n *               ignore this. See #BrInitError for a list of error codes.\n *\n * @returns 1 on success, 0 if a filename cannot be found.\n */\n", "func_signal": "int\nbr_init_lib (BrInitError *error)", "code": "{\n\texe = _br_find_exe_for_symbol ((const void *) \"\", error);\n\treturn exe != NULL;\n}", "path": "AppImageKit/src/binreloc.c", "commit_date": "2017-12-14 00:00:00", "repo_name": "AppImage/AppImageKit", "stars": 8361, "license": "other", "language": "c", "size": 16343}
{"docstring": "/** Locate the application's superuser binary folder.\n *\n * The path is generated by the following pseudo-code evaluation:\n * \\code\n * prefix + \"/sbin\"\n * \\endcode\n *\n * @param default_sbin_dir  A default path which will used as fallback.\n * @return A string containing the sbin folder's path, which must be freed when\n *         no longer necessary. If BinReloc is not initialized, or if the\n *         initialization function failed, then a copy of default_sbin_dir will\n *         be returned. If default_bin_dir is NULL, then NULL will be returned.\n */\n", "func_signal": "char *\nbr_find_sbin_dir (const char *default_sbin_dir)", "code": "{\n\tchar *prefix, *dir;\n\n\tprefix = br_find_prefix ((const char *) NULL);\n\tif (prefix == (char *) NULL) {\n\t\t/* BinReloc not initialized. */\n\t\tif (default_sbin_dir != (const char *) NULL)\n\t\t\treturn strdup (default_sbin_dir);\n\t\telse\n\t\t\treturn (char *) NULL;\n\t}\n\n\tdir = br_build_path (prefix, \"sbin\");\n\tfree (prefix);\n\treturn dir;\n}", "path": "AppImageKit/src/binreloc.c", "commit_date": "2017-12-14 00:00:00", "repo_name": "AppImage/AppImageKit", "stars": 8361, "license": "other", "language": "c", "size": 16343}
{"docstring": "/* Generate a squashfs filesystem using mksquashfs on the $PATH \n* execlp(), execvp(), and execvpe() search on the $PATH */\n", "func_signal": "int sfs_mksquashfs(char *source, char *destination, int offset)", "code": "{\n    pid_t pid = fork();\n    \n    if (pid == -1) {\n        // error, failed to fork()\n        return(-1);\n    } else if (pid > 0) {\n        int status;\n        waitpid(pid, &status, 0);\n    } else {\n        // we are the child\n        gchar* offset_string;\n        offset_string = g_strdup_printf(\"%i\", offset);\n\n        char* args[32];\n        bool use_xz = strcmp(sqfs_comp, \"xz\") >= 0;\n\n        int i = 0;\n#ifndef AUXILIARY_FILES_DESTINATION\n        args[i++] = \"mksquashfs\";\n#else\n        args[i++] = pathToMksquashfs;\n#endif\n        args[i++] = source;\n        args[i++] = destination;\n        args[i++] = \"-offset\";\n        args[i++] = offset_string;\n        args[i++] = \"-comp\";\n\n        if (use_xz)\n            args[i++] = \"xz\";\n        else\n            args[i++] = sqfs_comp;\n\n        args[i++] = \"-root-owned\";\n        args[i++] = \"-noappend\";\n\n        if (use_xz) {\n            // https://jonathancarter.org/2015/04/06/squashfs-performance-testing/ says:\n            // improved performance by using a 16384 block size with a sacrifice of around 3% more squashfs image space\n            args[i++] = \"-Xdict-size\";\n            args[i++] = \"100%\";\n            args[i++] = \"-b\";\n            args[i++] = \"16384\";\n        }\n\n        // check if ignore file exists and use it if possible\n        if (access(APPIMAGEIGNORE, F_OK) >= 0) {\n            printf(\"Including %s\", APPIMAGEIGNORE);\n            args[i++] = \"-wildcards\";\n            args[i++] = \"-ef\";\n\n            // avoid warning: assignment discards \u2018const\u2019 qualifier\n            char* buf = strdup(APPIMAGEIGNORE);\n            args[i++] = buf;\n        }\n\n        // if an exclude file has been passed on the command line, should be used, too\n        if (exclude_file != 0 && strlen(exclude_file) > 0) {\n            if (access(exclude_file, F_OK) < 0) {\n                printf(\"WARNING: exclude file %s not found!\", exclude_file);\n                return -1;\n            }\n\n            args[i++] = \"-wildcards\";\n            args[i++] = \"-ef\";\n            args[i++] = exclude_file;\n        }\n\n        args[i++] = \"-mkfs-time\";\n        args[i++] = \"0\";\n\n        args[i++] = 0;\n\n        if (verbose) {\n            printf(\"mksquashfs commandline: \");\n            for (char** t = args; *t != 0; t++) {\n                printf(\"%s \", *t);\n            }\n            printf(\"\\n\");\n        }\n\n#ifndef AUXILIARY_FILES_DESTINATION\n        execvp(\"mksquashfs\", args);\n#else\n        execvp(pathToMksquashfs, args);\n#endif\n\n        perror(\"execlp\");   // exec*() returns only on error\n        return -1; // exec never returns\n    }\n    return 0;\n}", "path": "AppImageKit/src/appimagetool.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "AppImage/AppImageKit", "stars": 8361, "license": "other", "language": "c", "size": 16343}
{"docstring": "/** Locate the application's localization folder.\n *\n * The path is generated by the following pseudo-code evaluation:\n * \\code\n * prefix + \"/share/locale\"\n * \\endcode\n *\n * @param default_locale_dir  A default path which will used as fallback.\n * @return A string containing the localization folder's path, which must be freed when\n *         no longer necessary. If BinReloc is not initialized, or if the\n *         initialization function failed, then a copy of default_locale_dir will be returned.\n *         If default_locale_dir is NULL, then NULL will be returned.\n */\n", "func_signal": "char *\nbr_find_locale_dir (const char *default_locale_dir)", "code": "{\n\tchar *data_dir, *dir;\n\n\tdata_dir = br_find_data_dir ((const char *) NULL);\n\tif (data_dir == (char *) NULL) {\n\t\t/* BinReloc not initialized. */\n\t\tif (default_locale_dir != (const char *) NULL)\n\t\t\treturn strdup (default_locale_dir);\n\t\telse\n\t\t\treturn (char *) NULL;\n\t}\n\n\tdir = br_build_path (data_dir, \"locale\");\n\tfree (data_dir);\n\treturn dir;\n}", "path": "AppImageKit/src/binreloc.c", "commit_date": "2017-12-14 00:00:00", "repo_name": "AppImage/AppImageKit", "stars": 8361, "license": "other", "language": "c", "size": 16343}
{"docstring": "/** Find the canonical filename of the current application.\n *\n * @param default_exe  A default filename which will be used as fallback.\n * @returns A string containing the application's canonical filename,\n *          which must be freed when no longer necessary. If BinReloc is\n *          not initialized, or if br_init() failed, then a copy of\n *          default_exe will be returned. If default_exe is NULL, then\n *          NULL will be returned.\n */\n", "func_signal": "char *\nbr_find_exe (const char *default_exe)", "code": "{\n\tif (exe == (char *) NULL) {\n\t\t/* BinReloc is not initialized. */\n\t\tif (default_exe != (const char *) NULL)\n\t\t\treturn strdup (default_exe);\n\t\telse\n\t\t\treturn (char *) NULL;\n\t}\n\treturn strdup (exe);\n}", "path": "AppImageKit/src/binreloc.c", "commit_date": "2017-12-14 00:00:00", "repo_name": "AppImage/AppImageKit", "stars": 8361, "license": "other", "language": "c", "size": 16343}
{"docstring": "/* Validate desktop file using desktop-file-validate on the $PATH\n* execlp(), execvp(), and execvpe() search on the $PATH */\n", "func_signal": "int validate_desktop_file(char *file)", "code": "{\n    int statval;\n    int child_pid;\n    child_pid = fork();\n    if(child_pid == -1)\n    {\n        printf(\"could not fork! \\n\");\n        return 1;\n    }\n    else if(child_pid == 0)\n    {\n        execlp(\"desktop-file-validate\", \"desktop-file-validate\", file, NULL);\n    }\n    else\n    {\n        waitpid(child_pid, &statval, WUNTRACED | WCONTINUED);\n        if(WIFEXITED(statval)){\n            return(WEXITSTATUS(statval));\n        }\n    }\n    return -1;\n}", "path": "AppImageKit/src/appimagetool.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "AppImage/AppImageKit", "stars": 8361, "license": "other", "language": "c", "size": 16343}
{"docstring": "/** Locate the application's configuration files folder.\n *\n * The path is generated by the following pseudo-code evaluation:\n * \\code\n * prefix + \"/etc\"\n * \\endcode\n *\n * @param default_etc_dir  A default path which will used as fallback.\n * @return A string containing the etc folder's path, which must be freed when\n *         no longer necessary. If BinReloc is not initialized, or if the initialization\n *         function failed, then a copy of default_etc_dir will be returned.\n *         If default_etc_dir is NULL, then NULL will be returned.\n */\n", "func_signal": "char *\nbr_find_etc_dir (const char *default_etc_dir)", "code": "{\n\tchar *prefix, *dir;\n\n\tprefix = br_find_prefix ((const char *) NULL);\n\tif (prefix == (char *) NULL) {\n\t\t/* BinReloc not initialized. */\n\t\tif (default_etc_dir != (const char *) NULL)\n\t\t\treturn strdup (default_etc_dir);\n\t\telse\n\t\t\treturn (char *) NULL;\n\t}\n\n\tdir = br_build_path (prefix, \"etc\");\n\tfree (prefix);\n\treturn dir;\n}", "path": "AppImageKit/src/binreloc.c", "commit_date": "2017-12-14 00:00:00", "repo_name": "AppImage/AppImageKit", "stars": 8361, "license": "other", "language": "c", "size": 16343}
{"docstring": "/** Locate the application's binary folder.\n *\n * The path is generated by the following pseudo-code evaluation:\n * \\code\n * prefix + \"/bin\"\n * \\endcode\n *\n * @param default_bin_dir  A default path which will used as fallback.\n * @return A string containing the bin folder's path, which must be freed when\n *         no longer necessary. If BinReloc is not initialized, or if\n *         the initialization function failed, then a copy of default_bin_dir will\n *         be returned. If default_bin_dir is NULL, then NULL will be returned.\n */\n", "func_signal": "char *\nbr_find_bin_dir (const char *default_bin_dir)", "code": "{\n\tchar *prefix, *dir;\n\n\tprefix = br_find_prefix ((const char *) NULL);\n\tif (prefix == (char *) NULL) {\n\t\t/* BinReloc not initialized. */\n\t\tif (default_bin_dir != (const char *) NULL)\n\t\t\treturn strdup (default_bin_dir);\n\t\telse\n\t\t\treturn (char *) NULL;\n\t}\n\n\tdir = br_build_path (prefix, \"bin\");\n\tfree (prefix);\n\treturn dir;\n}", "path": "AppImageKit/src/binreloc.c", "commit_date": "2017-12-14 00:00:00", "repo_name": "AppImage/AppImageKit", "stars": 8361, "license": "other", "language": "c", "size": 16343}
{"docstring": "/** Locate the application's library folder.\n *\n * The path is generated by the following pseudo-code evaluation:\n * \\code\n * prefix + \"/lib\"\n * \\endcode\n *\n * @param default_lib_dir  A default path which will used as fallback.\n * @return A string containing the library folder's path, which must be freed when\n *         no longer necessary. If BinReloc is not initialized, or if the initialization\n *         function failed, then a copy of default_lib_dir will be returned.\n *         If default_lib_dir is NULL, then NULL will be returned.\n */\n", "func_signal": "char *\nbr_find_lib_dir (const char *default_lib_dir)", "code": "{\n\tchar *prefix, *dir;\n\n\tprefix = br_find_prefix ((const char *) NULL);\n\tif (prefix == (char *) NULL) {\n\t\t/* BinReloc not initialized. */\n\t\tif (default_lib_dir != (const char *) NULL)\n\t\t\treturn strdup (default_lib_dir);\n\t\telse\n\t\t\treturn (char *) NULL;\n\t}\n\n\tdir = br_build_path (prefix, \"lib\");\n\tfree (prefix);\n\treturn dir;\n}", "path": "AppImageKit/src/binreloc.c", "commit_date": "2017-12-14 00:00:00", "repo_name": "AppImage/AppImageKit", "stars": 8361, "license": "other", "language": "c", "size": 16343}
{"docstring": "/** Locate the application's libexec folder.\n *\n * The path is generated by the following pseudo-code evaluation:\n * \\code\n * prefix + \"/libexec\"\n * \\endcode\n *\n * @param default_libexec_dir  A default path which will used as fallback.\n * @return A string containing the libexec folder's path, which must be freed when\n *         no longer necessary. If BinReloc is not initialized, or if the initialization\n *         function failed, then a copy of default_libexec_dir will be returned.\n *         If default_libexec_dir is NULL, then NULL will be returned.\n */\n", "func_signal": "char *\nbr_find_libexec_dir (const char *default_libexec_dir)", "code": "{\n\tchar *prefix, *dir;\n\n\tprefix = br_find_prefix ((const char *) NULL);\n\tif (prefix == (char *) NULL) {\n\t\t/* BinReloc not initialized. */\n\t\tif (default_libexec_dir != (const char *) NULL)\n\t\t\treturn strdup (default_libexec_dir);\n\t\telse\n\t\t\treturn (char *) NULL;\n\t}\n\n\tdir = br_build_path (prefix, \"libexec\");\n\tfree (prefix);\n\treturn dir;\n}", "path": "AppImageKit/src/binreloc.c", "commit_date": "2017-12-14 00:00:00", "repo_name": "AppImage/AppImageKit", "stars": 8361, "license": "other", "language": "c", "size": 16343}
{"docstring": "/** Locate the application's data folder.\n *\n * The path is generated by the following pseudo-code evaluation:\n * \\code\n * prefix + \"/share\"\n * \\endcode\n *\n * @param default_data_dir  A default path which will used as fallback.\n * @return A string containing the data folder's path, which must be freed when\n *         no longer necessary. If BinReloc is not initialized, or if the\n *         initialization function failed, then a copy of default_data_dir\n *         will be returned. If default_data_dir is NULL, then NULL will be\n *         returned.\n */\n", "func_signal": "char *\nbr_find_data_dir (const char *default_data_dir)", "code": "{\n\tchar *prefix, *dir;\n\n\tprefix = br_find_prefix ((const char *) NULL);\n\tif (prefix == (char *) NULL) {\n\t\t/* BinReloc not initialized. */\n\t\tif (default_data_dir != (const char *) NULL)\n\t\t\treturn strdup (default_data_dir);\n\t\telse\n\t\t\treturn (char *) NULL;\n\t}\n\n\tdir = br_build_path (prefix, \"share\");\n\tfree (prefix);\n\treturn dir;\n}", "path": "AppImageKit/src/binreloc.c", "commit_date": "2017-12-14 00:00:00", "repo_name": "AppImage/AppImageKit", "stars": 8361, "license": "other", "language": "c", "size": 16343}
{"docstring": "/** Extracts the directory component of a path.\n *\n * Similar to g_dirname() or the dirname commandline application.\n *\n * Example:\n * \\code\n * br_dirname (\"/usr/local/foobar\");  --> Returns: \"/usr/local\"\n * \\endcode\n *\n * @param path  A path.\n * @returns     A directory name. This string should be freed when no longer needed.\n */\n", "func_signal": "char *\nbr_dirname (const char *path)", "code": "{\n\tchar *end, *result;\n\n\tif (path == (const char *) NULL)\n\t\treturn (char *) NULL;\n\n\tend = strrchr (path, '/');\n\tif (end == (const char *) NULL)\n\t\treturn strdup (\".\");\n\n\twhile (end > path && *end == '/')\n\t\tend--;\n\tresult = br_strndup (path, end - path + 1);\n\tif (result[0] == 0) {\n\t\tfree (result);\n\t\treturn strdup (\"/\");\n\t} else\n\t\treturn result;\n}", "path": "AppImageKit/src/binreloc.c", "commit_date": "2017-12-14 00:00:00", "repo_name": "AppImage/AppImageKit", "stars": 8361, "license": "other", "language": "c", "size": 16343}
{"docstring": "/** Concatenate str1 and str2 to a newly allocated string.\n *\n * @param str1 A string.\n * @param str2 Another string.\n * @returns A newly-allocated string. This string should be freed when no longer needed.\n */\n", "func_signal": "char *\nbr_strcat (const char *str1, const char *str2)", "code": "{\n\tchar *result;\n\tsize_t len1, len2;\n\n\tif (str1 == NULL)\n\t\tstr1 = \"\";\n\tif (str2 == NULL)\n\t\tstr2 = \"\";\n\n\tlen1 = strlen (str1);\n\tlen2 = strlen (str2);\n\n\tresult = (char *) malloc (len1 + len2 + 1);\n\tmemcpy (result, str1, len1);\n\tmemcpy (result + len1, str2, len2);\n\tresult[len1 + len2] = '\\0';\n\n\treturn result;\n}", "path": "AppImageKit/src/binreloc.c", "commit_date": "2017-12-14 00:00:00", "repo_name": "AppImage/AppImageKit", "stars": 8361, "license": "other", "language": "c", "size": 16343}
{"docstring": "/* Emulates glibc's strndup() */\n", "func_signal": "static char *\nbr_strndup (const char *str, size_t size)", "code": "{\n\tchar *result = (char *) NULL;\n\tsize_t len;\n\n\tif (str == (const char *) NULL)\n\t\treturn (char *) NULL;\n\n\tlen = strlen (str);\n\tif (len == 0)\n\t\treturn strdup (\"\");\n\tif (size > len)\n\t\tsize = len;\n\n\tresult = (char *) malloc (len + 1);\n\tmemcpy (result, str, size);\n\tresult[size] = '\\0';\n\treturn result;\n}", "path": "AppImageKit/src/binreloc.c", "commit_date": "2017-12-14 00:00:00", "repo_name": "AppImage/AppImageKit", "stars": 8361, "license": "other", "language": "c", "size": 16343}
{"docstring": "/** Locate the directory in which the current application is installed.\n *\n * The prefix is generated by the following pseudo-code evaluation:\n * \\code\n * dirname(exename)\n * \\endcode\n *\n * @param default_dir  A default directory which will used as fallback.\n * @return A string containing the directory, which must be freed when no\n *         longer necessary. If BinReloc is not initialized, or if the\n *         initialization function failed, then a copy of default_dir\n *         will be returned. If default_dir is NULL, then NULL will be\n *         returned.\n */\n", "func_signal": "char *\nbr_find_exe_dir (const char *default_dir)", "code": "{\n\tif (exe == NULL) {\n\t\t/* BinReloc not initialized. */\n\t\tif (default_dir != NULL)\n\t\t\treturn strdup (default_dir);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\treturn br_dirname (exe);\n}", "path": "AppImageKit/src/binreloc.c", "commit_date": "2017-12-14 00:00:00", "repo_name": "AppImage/AppImageKit", "stars": 8361, "license": "other", "language": "c", "size": 16343}
{"docstring": "/** @internal\n * Find the canonical filename of the executable which owns symbol.\n * Returns a filename which must be freed, or NULL on error.\n */\n", "func_signal": "static char *\n_br_find_exe_for_symbol (const void *symbol, BrInitError *error)", "code": "{\n#ifndef ENABLE_BINRELOC\n\tif (error)\n\t\t*error = BR_INIT_ERROR_DISABLED;\n\treturn (char *) NULL;\n#else\n\t#define SIZE PATH_MAX + 100\n\tFILE *f;\n\tsize_t address_string_len;\n\tchar *address_string, line[SIZE], *found;\n\n\tif (symbol == NULL)\n\t\treturn (char *) NULL;\n\n\tf = fopen (\"/proc/self/maps\", \"r\");\n\tif (f == NULL)\n\t\treturn (char *) NULL;\n\n\taddress_string_len = 4;\n\taddress_string = (char *) malloc (address_string_len);\n\tfound = (char *) NULL;\n\n\twhile (!feof (f)) {\n\t\tchar *start_addr, *end_addr, *end_addr_end, *file;\n\t\tvoid *start_addr_p, *end_addr_p;\n\t\tsize_t len;\n\n\t\tif (fgets (line, SIZE, f) == NULL)\n\t\t\tbreak;\n\n\t\t/* Sanity check. */\n\t\tif (strstr (line, \" r-xp \") == NULL || strchr (line, '/') == NULL)\n\t\t\tcontinue;\n\n\t\t/* Parse line. */\n\t\tstart_addr = line;\n\t\tend_addr = strchr (line, '-');\n\t\tfile = strchr (line, '/');\n\n\t\t/* More sanity check. */\n\t\tif (!(file > end_addr && end_addr != NULL && end_addr[0] == '-'))\n\t\t\tcontinue;\n\n\t\tend_addr[0] = '\\0';\n\t\tend_addr++;\n\t\tend_addr_end = strchr (end_addr, ' ');\n\t\tif (end_addr_end == NULL)\n\t\t\tcontinue;\n\n\t\tend_addr_end[0] = '\\0';\n\t\tlen = strlen (file);\n\t\tif (len == 0)\n\t\t\tcontinue;\n\t\tif (file[len - 1] == '\\n')\n\t\t\tfile[len - 1] = '\\0';\n\n\t\t/* Get rid of \"(deleted)\" from the filename. */\n\t\tlen = strlen (file);\n\t\tif (len > 10 && strcmp (file + len - 10, \" (deleted)\") == 0)\n\t\t\tfile[len - 10] = '\\0';\n\n\t\t/* I don't know whether this can happen but better safe than sorry. */\n\t\tlen = strlen (start_addr);\n\t\tif (len != strlen (end_addr))\n\t\t\tcontinue;\n\n\n\t\t/* Transform the addresses into a string in the form of 0xdeadbeef,\n\t\t * then transform that into a pointer. */\n\t\tif (address_string_len < len + 3) {\n\t\t\taddress_string_len = len + 3;\n\t\t\taddress_string = (char *) realloc (address_string, address_string_len);\n\t\t}\n\n\t\tmemcpy (address_string, \"0x\", 2);\n\t\tmemcpy (address_string + 2, start_addr, len);\n\t\taddress_string[2 + len] = '\\0';\n\t\tsscanf (address_string, \"%p\", &start_addr_p);\n\n\t\tmemcpy (address_string, \"0x\", 2);\n\t\tmemcpy (address_string + 2, end_addr, len);\n\t\taddress_string[2 + len] = '\\0';\n\t\tsscanf (address_string, \"%p\", &end_addr_p);\n\n\n\t\tif (symbol >= start_addr_p && symbol < end_addr_p) {\n\t\t\tfound = file;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree (address_string);\n\tfclose (f);\n\n\tif (found == NULL)\n\t\treturn (char *) NULL;\n\telse\n\t\treturn strdup (found);\n#endif /* ENABLE_BINRELOC */\n}", "path": "AppImageKit/src/binreloc.c", "commit_date": "2017-12-14 00:00:00", "repo_name": "AppImage/AppImageKit", "stars": 8361, "license": "other", "language": "c", "size": 16343}
{"docstring": "/** Locate the prefix in which the current application is installed.\n *\n * The prefix is generated by the following pseudo-code evaluation:\n * \\code\n * dirname(dirname(exename))\n * \\endcode\n *\n * @param default_prefix  A default prefix which will used as fallback.\n * @return A string containing the prefix, which must be freed when no\n *         longer necessary. If BinReloc is not initialized, or if\n *         the initialization function failed, then a copy of default_prefix\n *         will be returned. If default_prefix is NULL, then NULL will be returned.\n */\n", "func_signal": "char *\nbr_find_prefix (const char *default_prefix)", "code": "{\n\tchar *dir1, *dir2;\n\n\tif (exe == (char *) NULL) {\n\t\t/* BinReloc not initialized. */\n\t\tif (default_prefix != (const char *) NULL)\n\t\t\treturn strdup (default_prefix);\n\t\telse\n\t\t\treturn (char *) NULL;\n\t}\n\n\tdir1 = br_dirname (exe);\n\tdir2 = br_dirname (dir1);\n\tfree (dir1);\n\treturn dir2;\n}", "path": "AppImageKit/src/binreloc.c", "commit_date": "2017-12-14 00:00:00", "repo_name": "AppImage/AppImageKit", "stars": 8361, "license": "other", "language": "c", "size": 16343}
{"docstring": "/** Initialize the BinReloc library (for applications).\n *\n * This function must be called before using any other BinReloc functions.\n * It attempts to locate the application's canonical filename.\n *\n * @note If you want to use BinReloc for a library, then you should call\n *       br_init_lib() instead.\n *\n * @param error  If BinReloc failed to initialize, then the error code will\n *               be stored in this variable. Set to NULL if you want to\n *               ignore this. See #BrInitError for a list of error codes.\n *\n * @returns 1 on success, 0 if BinReloc failed to initialize.\n */\n", "func_signal": "int\nbr_init (BrInitError *error)", "code": "{\n\texe = _br_find_exe (error);\n\treturn exe != NULL;\n}", "path": "AppImageKit/src/binreloc.c", "commit_date": "2017-12-14 00:00:00", "repo_name": "AppImage/AppImageKit", "stars": 8361, "license": "other", "language": "c", "size": 16343}
{"docstring": "/* run a command outside the current appimage, block environs like LD_LIBRARY_PATH */\n", "func_signal": "int run_external(const char *filename, char *const argv [])", "code": "{\n    int pid = fork();\n    if (pid < 0) {\n        g_print(\"run_external: fork failed\");\n        // fork failed\n        exit(1);\n    } else if (pid == 0) {\n        // blocks env defined in resources/AppRun\n        unsetenv(\"LD_LIBRARY_PATH\");\n        unsetenv(\"PYTHONPATH\");\n        unsetenv(\"XDG_DATA_DIRS\");\n        unsetenv(\"PERLLIB\");\n        unsetenv(\"GSETTINGS_SCHEMA_DIR\");\n        unsetenv(\"QT_PLUGIN_PATH\");\n        // runs command\n        execv(filename, argv);\n        // execv(3) returns, indicating error\n        g_print(\"run_external: subprocess execv(3) got error %s\", g_strerror(errno));\n        exit(1);\n    } else {\n        int wstatus;\n        if (waitpid(pid, &wstatus, 0) == -1) {\n            g_print(\"run_external: wait failed\");\n            return -1;\n        }\n        if (WIFEXITED(wstatus) && (WEXITSTATUS(wstatus) == 0)) {\n            return 0;\n        } else {\n            g_print(\"run_external: subprocess exited with status %d\", WEXITSTATUS(wstatus));\n            return 1;\n        }\n    }\n}", "path": "AppImageKit/src/appimagetool.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "AppImage/AppImageKit", "stars": 8361, "license": "other", "language": "c", "size": 16343}
{"docstring": "/* Function that prints the contents of a squashfs file\n* using libsquashfuse (#include \"squashfuse.h\") */\n", "func_signal": "int sfs_ls(char* image)", "code": "{\n    sqfs_err err = SQFS_OK;\n    sqfs_traverse trv;\n    sqfs fs;\n    \n    ssize_t fs_offset = appimage_get_elf_size(image);\n\n    // error check\n    if (fs_offset < 0)\n        die(\"failed to read elf size\");\n\n    if ((err = sqfs_open_image(&fs, image, fs_offset)))\n        die(\"sqfs_open_image error\");\n    \n    if ((err = sqfs_traverse_open(&trv, &fs, sqfs_inode_root(&fs))))\n        die(\"sqfs_traverse_open error\");\n    while (sqfs_traverse_next(&trv, &err)) {\n        if (!trv.dir_end) {\n            printf(\"%s\\n\", trv.path);\n        }\n    }\n    if (err)\n        die(\"sqfs_traverse_next error\");\n    sqfs_traverse_close(&trv);\n    \n    sqfs_fd_close(fs.fd);\n    return 0;\n}", "path": "AppImageKit/src/appimagetool.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "AppImage/AppImageKit", "stars": 8361, "license": "other", "language": "c", "size": 16343}
{"docstring": "/* Finds the length of a dns request for a DNS name of the given */\n/* length. The actual request may be smaller than the value returned */\n/* here */\n", "func_signal": "static size_t\nevdns_request_len(const struct evdns_base *base, const size_t name_len)", "code": "{\n\tint addional_section_len = 0;\n\tif (EDNS_ENABLED(base)) {\n\t\taddional_section_len = 1 + /* length of domain name string, always 0 */\n\t\t\t2 + /* space for resource type */\n\t\t\t2 + /* space for UDP payload size */\n\t\t\t4 + /* space for extended RCODE flags */\n\t\t\t2;  /* space for length of RDATA, always 0 */\n\t}\n\treturn 96 + /* length of the DNS standard header */\n\t\tname_len + 2 +\n\t\t4 /* space for the resource type */ +\n\t\taddional_section_len;\n}", "path": "libevent/evdns.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "libevent/libevent", "stars": 10577, "license": "other", "language": "c", "size": 12829}
{"docstring": "/* ================================================================= */\n/* Parsing resolv.conf files */\n", "func_signal": "static void\nevdns_resolv_set_defaults(struct evdns_base *base, int flags)", "code": "{\n\tint add_default = flags & DNS_OPTION_NAMESERVERS;\n\tif (flags & DNS_OPTION_NAMESERVERS_NO_DEFAULT)\n\t\tadd_default = 0;\n\n\t/* if the file isn't found then we assume a local resolver */\n\tASSERT_LOCKED(base);\n\tif (flags & DNS_OPTION_SEARCH)\n\t\tsearch_set_from_hostname(base);\n\tif (add_default)\n\t\tevdns_base_nameserver_ip_add(base, \"127.0.0.1\");\n}", "path": "libevent/evdns.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "libevent/libevent", "stars": 10577, "license": "other", "language": "c", "size": 12829}
{"docstring": "/* Remove tcp client and free all associated data from the TCP DNS server. */\n", "func_signal": "static int\nevdns_remove_tcp_client(struct evdns_server_port *port, struct client_tcp_connection *client)", "code": "{\n\tif (!port || !client)\n\t\tgoto error;\n\n\tevdns_tcp_disconnect(&client->connection);\n\tLIST_REMOVE(client, next);\n\tmm_free(client);\n\t--port->client_connections_count;\n\t--port->refcnt;\n\treturn 0;\nerror:\n\treturn -1;\n}", "path": "libevent/evdns.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "libevent/libevent", "stars": 10577, "license": "other", "language": "c", "size": 12829}
{"docstring": "/* Remove all tcp clients and free all associated data from the TCP DNS server. */\n", "func_signal": "static void\nevdns_remove_all_tcp_clients(struct evdns_server_port *port)", "code": "{\n\tstruct client_tcp_connection *client;\n\twhile ((client = LIST_FIRST(&port->client_connections))) {\n\t\tevdns_remove_tcp_client(port, client);\n\t}\n}", "path": "libevent/evdns.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "libevent/libevent", "stars": 10577, "license": "other", "language": "c", "size": 12829}
{"docstring": "/* called when a nameserver has been deemed to have failed. For example, too */\n/* many packets have timed out etc */\n", "func_signal": "static void\nnameserver_failed(struct nameserver *const ns, const char *msg, int err)", "code": "{\n\tstruct request *req, *started_at;\n\tstruct evdns_base *base = ns->base;\n\tint i;\n\tchar addrbuf[128];\n\n\tASSERT_LOCKED(base);\n\t/* if this nameserver has already been marked as failed */\n\t/* then don't do anything */\n\tif (!ns->state) return;\n\n\tlog(EVDNS_LOG_MSG, \"Nameserver %s has failed: %s\",\n\t    evutil_format_sockaddr_port_(\n\t\t    (struct sockaddr *)&ns->address,\n\t\t    addrbuf, sizeof(addrbuf)),\n\t    msg);\n\n\tbase->global_good_nameservers--;\n\tEVUTIL_ASSERT(base->global_good_nameservers >= 0);\n\tif (base->global_good_nameservers == 0) {\n\t\tlog(EVDNS_LOG_MSG, \"All nameservers have failed\");\n\t}\n\n\tns->state = 0;\n\tns->failed_times = 1;\n\n\tif (ns->connection) {\n\t\tdisconnect_and_free_connection(ns->connection);\n\t\tns->connection = NULL;\n\t} else if (err == ENOTCONN) {\n\t\t/* XXX: If recvfrom results in ENOTCONN, the socket remains readable\n\t\t * which triggers another recvfrom. The observed behavior is 100% CPU use.\n\t\t * This occurs on iOS (kqueue) after the process has been backgrounded\n\t\t * for a long time (~300 seconds) and then resumed.\n\t\t * All sockets, TCP and UDP, seem to get ENOTCONN and must be closed.\n\t\t * https://github.com/libevent/libevent/issues/265 */\n\t\tconst struct sockaddr *address = (const struct sockaddr *)&ns->address;\n\t\tevutil_closesocket(ns->socket);\n\t\tns->socket = evutil_socket_(address->sa_family,\n\t\t\tSOCK_DGRAM | EVUTIL_SOCK_NONBLOCK | EVUTIL_SOCK_CLOEXEC, 0);\n\n\t\tif (base->global_outgoing_addrlen &&\n\t\t\t!evutil_sockaddr_is_loopback_(address)) {\n\t\t\tif (bind(ns->socket,\n\t\t\t\t\t(struct sockaddr *)&base->global_outgoing_address,\n\t\t\t\t\tbase->global_outgoing_addrlen) < 0) {\n\t\t\t\tlog(EVDNS_LOG_WARN, \"Couldn't bind to outgoing address\");\n\t\t\t}\n\t\t}\n\n\t\tevent_del(&ns->event);\n\t\tevent_assign(&ns->event, ns->base->event_base, ns->socket,\n\t\t\tEV_READ | (ns->write_waiting ? EV_WRITE : 0) | EV_PERSIST,\n\t\t\tnameserver_ready_callback, ns);\n\t\tif (!base->disable_when_inactive && event_add(&ns->event, NULL) < 0) {\n\t\t\tlog(EVDNS_LOG_WARN, \"Couldn't add %s event\",\n\t\t\t\tns->write_waiting ? \"rw\": \"read\");\n\t\t}\n\t}\n\tif (evtimer_add(&ns->timeout_event,\n\t\t&base->global_nameserver_probe_initial_timeout) < 0) {\n\t\tlog(EVDNS_LOG_WARN,\n\t\t    \"Error from libevent when adding timer event for %s\",\n\t\t    evutil_format_sockaddr_port_(\n\t\t\t    (struct sockaddr *)&ns->address,\n\t\t\t    addrbuf, sizeof(addrbuf)));\n\t\t/* ???? Do more? */\n\t}\n\n\t/* walk the list of inflight requests to see if any can be reassigned to */\n\t/* a different server. Requests in the waiting queue don't have a */\n\t/* nameserver assigned yet */\n\n\t/* if we don't have *any* good nameservers then there's no point */\n\t/* trying to reassign requests to one */\n\tif (!base->global_good_nameservers) return;\n\n\tfor (i = 0; i < base->n_req_heads; ++i) {\n\t\treq = started_at = base->req_heads[i];\n\t\tif (req) {\n\t\t\tdo {\n\t\t\t\tif (req->tx_count == 0 && req->ns == ns) {\n\t\t\t\t\t/* still waiting to go out, can be moved */\n\t\t\t\t\t/* to another server */\n\t\t\t\t\trequest_swap_ns(req, nameserver_pick(base));\n\t\t\t\t}\n\t\t\t\treq = req->next;\n\t\t\t} while (req != started_at);\n\t\t}\n\t}\n}", "path": "libevent/evdns.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "libevent/libevent", "stars": 10577, "license": "other", "language": "c", "size": 12829}
{"docstring": "/* exported function */\n", "func_signal": "void\nevdns_base_search_ndots_set(struct evdns_base *base, const int ndots)", "code": "{\n\tEVDNS_LOCK(base);\n\tif (!base->global_search_state) base->global_search_state = search_state_new();\n\tif (base->global_search_state)\n\t\tbase->global_search_state->ndots = ndots;\n\tEVDNS_UNLOCK(base);\n}", "path": "libevent/evdns.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "libevent/libevent", "stars": 10577, "license": "other", "language": "c", "size": 12829}
{"docstring": "/* a libevent callback function which is called when a nameserver */\n/* has gone down and we want to test if it has came back to life yet */\n", "func_signal": "static void\nnameserver_prod_callback(evutil_socket_t fd, short events, void *arg)", "code": "{\n\tstruct nameserver *const ns = (struct nameserver *) arg;\n\t(void)fd;\n\t(void)events;\n\n\tEVDNS_LOCK(ns->base);\n\tnameserver_send_probe(ns);\n\tEVDNS_UNLOCK(ns->base);\n}", "path": "libevent/evdns.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "libevent/libevent", "stars": 10577, "license": "other", "language": "c", "size": 12829}
{"docstring": "/* exported function */\n", "func_signal": "struct evdns_server_port *\nevdns_add_server_port_with_listener(struct event_base *base, struct evconnlistener *listener, int flags, evdns_request_callback_fn_type cb, void *user_data)", "code": "{\n\tstruct evdns_server_port *port;\n\tif (!listener)\n\t\treturn NULL;\n\tif (flags)\n\t\treturn NULL; /* flags not yet implemented */\n\n\tif (!(port = mm_calloc(1, sizeof(struct evdns_server_port))))\n\t\treturn NULL;\n\tport->socket = -1;\n\tport->refcnt = 1;\n\tport->choked = 0;\n\tport->closing = 0;\n\tport->user_callback = cb;\n\tport->user_data = user_data;\n\tport->pending_replies = NULL;\n\tport->event_base = base;\n\tport->max_client_connections = MAX_CLIENT_CONNECTIONS;\n\tport->client_connections_count = 0;\n\tLIST_INIT(&port->client_connections);\n\tport->listener = listener;\n\tevconnlistener_set_cb(port->listener, incoming_conn_cb, port);\n\n\tEVTHREAD_ALLOC_LOCK(port->lock, EVTHREAD_LOCKTYPE_RECURSIVE);\n\treturn port;\n}", "path": "libevent/evdns.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "libevent/libevent", "stars": 10577, "license": "other", "language": "c", "size": 12829}
{"docstring": "/* exported function */\n", "func_signal": "int\nevdns_base_clear_nameservers_and_suspend(struct evdns_base *base)", "code": "{\n\tstruct nameserver *server, *started_at;\n\tint i;\n\n\tEVDNS_LOCK(base);\n\tserver = base->server_head;\n\tstarted_at = base->server_head;\n\tif (!server) {\n\t\tEVDNS_UNLOCK(base);\n\t\treturn 0;\n\t}\n\twhile (1) {\n\t\tstruct nameserver *next = server->next;\n\t\tdisconnect_and_free_connection(server->connection);\n\t\tserver->connection = NULL;\n\t\t(void) event_del(&server->event);\n\t\tif (evtimer_initialized(&server->timeout_event))\n\t\t\t(void) evtimer_del(&server->timeout_event);\n\t\tif (server->probe_request) {\n\t\t\tevdns_cancel_request(server->base, server->probe_request);\n\t\t\tserver->probe_request = NULL;\n\t\t}\n\t\tif (server->socket >= 0)\n\t\t\tevutil_closesocket(server->socket);\n\t\tmm_free(server);\n\t\tif (next == started_at)\n\t\t\tbreak;\n\t\tserver = next;\n\t}\n\tbase->server_head = NULL;\n\tbase->global_good_nameservers = 0;\n\n\tfor (i = 0; i < base->n_req_heads; ++i) {\n\t\tstruct request *req, *req_started_at;\n\t\treq = req_started_at = base->req_heads[i];\n\t\twhile (req) {\n\t\t\tstruct request *next = req->next;\n\t\t\treq->tx_count = req->reissue_count = 0;\n\t\t\treq->ns = NULL;\n\t\t\t/* ???? What to do about searches? */\n\t\t\t(void) evtimer_del(&req->timeout_event);\n\t\t\treq->trans_id = 0;\n\t\t\treq->transmit_me = 0;\n\n\t\t\tbase->global_requests_waiting++;\n\t\t\tevdns_request_insert(req, &base->req_waiting_head);\n\t\t\t/* We want to insert these suspended elements at the front of\n\t\t\t * the waiting queue, since they were pending before any of\n\t\t\t * the waiting entries were added.  This is a circular list,\n\t\t\t * so we can just shift the start back by one.*/\n\t\t\tbase->req_waiting_head = base->req_waiting_head->prev;\n\n\t\t\tif (next == req_started_at)\n\t\t\t\tbreak;\n\t\t\treq = next;\n\t\t}\n\t\tbase->req_heads[i] = NULL;\n\t}\n\n\tbase->global_requests_inflight = 0;\n\n\tEVDNS_UNLOCK(base);\n\treturn 0;\n}", "path": "libevent/evdns.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "libevent/libevent", "stars": 10577, "license": "other", "language": "c", "size": 12829}
{"docstring": "/* returns: */\n/*   0 didn't try to transmit anything */\n/*   1 tried to transmit something */\n", "func_signal": "static int\nevdns_transmit(struct evdns_base *base)", "code": "{\n\tchar did_try_to_transmit = 0;\n\tint i;\n\n\tASSERT_LOCKED(base);\n\tfor (i = 0; i < base->n_req_heads; ++i) {\n\t\tif (base->req_heads[i]) {\n\t\t\tstruct request *const started_at = base->req_heads[i], *req = started_at;\n\t\t\t/* first transmit all the requests which are currently waiting */\n\t\t\tdo {\n\t\t\t\tif (req->transmit_me) {\n\t\t\t\t\tdid_try_to_transmit = 1;\n\t\t\t\t\tevdns_request_transmit(req);\n\t\t\t\t}\n\n\t\t\t\treq = req->next;\n\t\t\t} while (req != started_at);\n\t\t}\n\t}\n\n\treturn did_try_to_transmit;\n}", "path": "libevent/evdns.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "libevent/libevent", "stars": 10577, "license": "other", "language": "c", "size": 12829}
{"docstring": "/* Try to write all pending replies on a given DNS server port. */\n", "func_signal": "static void\nserver_port_flush(struct evdns_server_port *port)", "code": "{\n\tstruct server_request *req = port->pending_replies;\n\tASSERT_LOCKED(port);\n\twhile (req) {\n\t\tint r = server_send_response(port, req);\n\t\tif (r < 0) {\n\t\t\tint err = evutil_socket_geterror(port->socket);\n\t\t\tif (EVUTIL_ERR_RW_RETRIABLE(err))\n\t\t\t\treturn;\n\t\t\tlog(EVDNS_LOG_WARN, \"Error %s (%d) while writing response to port; dropping\", evutil_socket_error_to_string(err), err);\n\t\t}\n\t\tif (server_request_free(req)) {\n\t\t\t/* we released the last reference to req->port. */\n\t\t\treturn;\n\t\t} else {\n\t\t\tEVUTIL_ASSERT(req != port->pending_replies);\n\t\t\treq = port->pending_replies;\n\t\t}\n\t}\n\n\t/* We have no more pending requests; stop listening for 'writeable' events. */\n\t(void) event_del(&port->event);\n\tevent_assign(&port->event, port->event_base,\n\t\t\t\t port->socket, EV_READ | EV_PERSIST,\n\t\t\t\t server_port_ready_callback, port);\n\n\tif (event_add(&port->event, NULL) < 0) {\n\t\tlog(EVDNS_LOG_WARN, \"Error from libevent when adding event for DNS server.\");\n\t\t/* ???? Do more? */\n\t}\n}", "path": "libevent/evdns.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "libevent/libevent", "stars": 10577, "license": "other", "language": "c", "size": 12829}
{"docstring": "/* exported function */\n", "func_signal": "int\nevdns_server_request_drop(struct evdns_server_request *req_)", "code": "{\n\tstruct server_request *req = TO_SERVER_REQUEST(req_);\n\tserver_request_free(req);\n\treturn 0;\n}", "path": "libevent/evdns.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "libevent/libevent", "stars": 10577, "license": "other", "language": "c", "size": 12829}
{"docstring": "/* Parse a raw request (packet,length) sent to a nameserver port (port) from */\n/* a DNS client (addr,addrlen), and if it's well-formed, call the corresponding */\n/* callback. */\n", "func_signal": "static int\nrequest_parse(u8 *packet, int length, struct evdns_server_port *port,\n\t\t\t\tstruct sockaddr *addr, ev_socklen_t addrlen, struct client_tcp_connection *client)", "code": "{\n\tint j = 0;\t/* index into packet */\n\tu16 t_;\t /* used by the macros */\n\tu32 t32_;  /* used by the macros */\n\tchar tmp_name[256]; /* used by the macros */\n\n\tint i;\n\tu16 trans_id, flags, questions, answers, authority, additional;\n\tstruct server_request *server_req = NULL;\n\tu32 ttl;\n\tu16 type, class, rdlen;\n\n\tASSERT_LOCKED(port);\n\n\t/* Get the header fields */\n\tGET16(trans_id);\n\tGET16(flags);\n\tGET16(questions);\n\tGET16(answers);\n\tGET16(authority);\n\tGET16(additional);\n\n\tif (flags & _QR_MASK) return -1; /* Must not be an answer. */\n\tflags &= (_RD_MASK|_CD_MASK); /* Only RD and CD get preserved. */\n\n\tserver_req = mm_malloc(sizeof(struct server_request));\n\tif (server_req == NULL) return -1;\n\tmemset(server_req, 0, sizeof(struct server_request));\n\n\tserver_req->trans_id = trans_id;\n\tif (addr) {\n\t\tmemcpy(&server_req->addr, addr, addrlen);\n\t\tserver_req->addrlen = addrlen;\n\t}\n\n\tserver_req->port = port;\n\tserver_req->client = client;\n\tserver_req->base.flags = flags;\n\tserver_req->base.nquestions = 0;\n\tserver_req->base.questions = mm_calloc(sizeof(struct evdns_server_question *), questions);\n\tif (server_req->base.questions == NULL)\n\t\tgoto err;\n\n\tfor (i = 0; i < questions; ++i) {\n\t\tu16 type, class;\n\t\tstruct evdns_server_question *q;\n\t\tint namelen;\n\t\tif (name_parse(packet, length, &j, tmp_name, sizeof(tmp_name))<0)\n\t\t\tgoto err;\n\t\tGET16(type);\n\t\tGET16(class);\n\t\tnamelen = (int)strlen(tmp_name);\n\t\tq = mm_malloc(sizeof(struct evdns_server_question) + namelen);\n\t\tif (!q)\n\t\t\tgoto err;\n\t\tq->type = type;\n\t\tq->dns_question_class = class;\n\t\tmemcpy(q->name, tmp_name, namelen+1);\n\t\tserver_req->base.questions[server_req->base.nquestions++] = q;\n\t}\n\n#define SKIP_RR \\\n\tdo { \\\n\t\tSKIP_NAME; \\\n\t\tj += 2 /* type */ + 2 /* class */ + 4 /* ttl */; \\\n\t\tGET16(rdlen); \\\n\t\tj += rdlen; \\\n\t} while (0)\n\n\tfor (i = 0; i < answers; ++i) {\n\t\tSKIP_RR;\n\t}\n\n\tfor (i = 0; i < authority; ++i) {\n\t\tSKIP_RR;\n\t}\n\n\tserver_req->max_udp_reply_size = DNS_MAX_UDP_SIZE;\n\tfor (i = 0; i < additional; ++i) {\n\t\tSKIP_NAME;\n\t\tGET16(type);\n\t\tGET16(class);\n\t\tGET32(ttl);\n\t\tGET16(rdlen);\n\t\t(void)ttl;\n\t\tj += rdlen;\n\t\tif (type == TYPE_OPT) {\n\t\t\t/* In case of OPT pseudo-RR `class` field is treated\n\t\t\t * as a requestor's UDP payload size. */\n\t\t\tserver_req->max_udp_reply_size = MAX(class, DNS_MAX_UDP_SIZE);\n\t\t\tevdns_server_request_add_reply(&(server_req->base),\n\t\t\t\tEVDNS_ADDITIONAL_SECTION,\n\t\t\t\t\"\", /* name */\n\t\t\t\tTYPE_OPT, /* type */\n\t\t\t\tDNS_MAX_UDP_SIZE, /* class */\n\t\t\t\t0, /* ttl */\n\t\t\t\t0, /* datalen */\n\t\t\t\t0, /* is_name */\n\t\t\t\tNULL /* data */\n\t\t\t);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tport->refcnt++;\n\n\t/* Only standard queries are supported. */\n\tif (flags & _OP_MASK) {\n\t\tevdns_server_request_respond(&(server_req->base), DNS_ERR_NOTIMPL);\n\t\treturn -1;\n\t}\n\n\tport->user_callback(&(server_req->base), port->user_data);\n\n\treturn 0;\nerr:\n\tif (server_req->base.questions) {\n\t\tfor (i = 0; i < server_req->base.nquestions; ++i)\n\t\t\tmm_free(server_req->base.questions[i]);\n\t\tmm_free(server_req->base.questions);\n\t}\n\tmm_free(server_req);\n\treturn -1;\n\n#undef SKIP_RR\n#undef SKIP_NAME\n#undef GET32\n#undef GET16\n#undef GET8\n}", "path": "libevent/evdns.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "libevent/libevent", "stars": 10577, "license": "other", "language": "c", "size": 12829}
{"docstring": "/* exported function */\n", "func_signal": "void\nevdns_cancel_request(struct evdns_base *base, struct evdns_request *handle)", "code": "{\n\tstruct request *req;\n\n\tif (!handle->current_req)\n\t\treturn;\n\n\tif (!base) {\n\t\t/* This redundancy is silly; can we fix it? (Not for 2.0) XXXX */\n\t\tbase = handle->base;\n\t\tif (!base)\n\t\t\tbase = handle->current_req->base;\n\t}\n\n\tEVDNS_LOCK(base);\n\tif (handle->pending_cb) {\n\t\tEVDNS_UNLOCK(base);\n\t\treturn;\n\t}\n\n\treq = handle->current_req;\n\tASSERT_VALID_REQUEST(req);\n\n\treply_schedule_callback(req, 0, DNS_ERR_CANCEL, NULL);\n\tif (req->ns) {\n\t\t/* remove from inflight queue */\n\t\trequest_finished(req, &REQ_HEAD(base, req->trans_id), 1);\n\t} else {\n\t\t/* remove from global_waiting head */\n\t\trequest_finished(req, &base->req_waiting_head, 1);\n\t}\n\tEVDNS_UNLOCK(base);\n}", "path": "libevent/evdns.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "libevent/libevent", "stars": 10577, "license": "other", "language": "c", "size": 12829}
{"docstring": "/* Free all storage held by table, but not the table itself. */\n", "func_signal": "static void\ndnslabel_clear(struct dnslabel_table *table)", "code": "{\n\tint i;\n\tfor (i = 0; i < table->n_labels; ++i)\n\t\tmm_free(table->labels[i].v);\n\ttable->n_labels = 0;\n}", "path": "libevent/evdns.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "libevent/libevent", "stars": 10577, "license": "other", "language": "c", "size": 12829}
{"docstring": "/* parses a raw request from a nameserver */\n", "func_signal": "static int\nreply_parse(struct evdns_base *base, u8 *packet, int length)", "code": "{\n\tint j = 0, k = 0;  /* index into packet */\n\tu16 t_;\t /* used by the macros */\n\tu32 t32_;  /* used by the macros */\n\tchar tmp_name[256], cmp_name[256]; /* used by the macros */\n\tint name_matches = 0;\n\n\tu16 trans_id, questions, answers, authority, additional, datalength;\n\tu16 flags = 0;\n\tu32 ttl, ttl_r = 0xffffffff;\n\tstruct reply reply;\n\tstruct request *req = NULL;\n\tunsigned int i, buf_size;\n\n\tASSERT_LOCKED(base);\n\n\tGET16(trans_id);\n\tGET16(flags);\n\tGET16(questions);\n\tGET16(answers);\n\tGET16(authority);\n\tGET16(additional);\n\t(void) authority; /* suppress \"unused variable\" warnings. */\n\t(void) additional; /* suppress \"unused variable\" warnings. */\n\n\treq = request_find_from_trans_id(base, trans_id);\n\tif (!req) return -1;\n\tEVUTIL_ASSERT(req->base == base);\n\n\tmemset(&reply, 0, sizeof(reply));\n\n\t/* If it's not an answer, it doesn't correspond to any request. */\n\tif (!(flags & _QR_MASK)) return -1;  /* must be an answer */\n\tif ((flags & (_RCODE_MASK|_TC_MASK)) && (flags & (_RCODE_MASK|_TC_MASK)) != DNS_ERR_NOTEXIST) {\n\t\t/* there was an error and it's not NXDOMAIN */\n\t\tgoto err;\n\t}\n\t/* if (!answers) return; */  /* must have an answer of some form */\n\n\t/* This macro skips a name in the DNS reply. */\n#define SKIP_NAME\t\t\t\t\t\t\\\n\tdo { tmp_name[0] = '\\0';\t\t\t\t\\\n\t\tif (name_parse(packet, length, &j, tmp_name,\t\\\n\t\t\tsizeof(tmp_name))<0)\t\t\t\\\n\t\t\tgoto err;\t\t\t\t\\\n\t} while (0)\n\n\treply.type = req->request_type;\n\n\t/* skip over each question in the reply */\n\tfor (i = 0; i < questions; ++i) {\n\t\t/* the question looks like\n\t\t *   <label:name><u16:type><u16:class>\n\t\t */\n\t\ttmp_name[0] = '\\0';\n\t\tcmp_name[0] = '\\0';\n\t\tk = j;\n\t\tif (name_parse(packet, length, &j, tmp_name, sizeof(tmp_name)) < 0)\n\t\t\tgoto err;\n\t\tif (name_parse(req->request, req->request_len, &k,\n\t\t\tcmp_name, sizeof(cmp_name))<0)\n\t\t\tgoto err;\n\t\tif (!base->global_randomize_case) {\n\t\t\tif (strcmp(tmp_name, cmp_name) == 0)\n\t\t\t\tname_matches = 1;\n\t\t} else {\n\t\t\tif (evutil_ascii_strcasecmp(tmp_name, cmp_name) == 0)\n\t\t\t\tname_matches = 1;\n\t\t}\n\n\t\tj += 4;\n\t\tif (j > length)\n\t\t\tgoto err;\n\t}\n\n\tif (!name_matches)\n\t\tgoto err;\n\n\t/* We can allocate less for the reply data, but to do it we'll have\n\t * to parse the response. To simplify things let's just allocate\n\t * a little bit more to avoid complex evaluations.\n\t */\n\tbuf_size = MAX(length - j, HOST_NAME_MAX);\n\treply.data.raw = mm_malloc(buf_size);\n\n\t/* now we have the answer section which looks like\n\t * <label:name><u16:type><u16:class><u32:ttl><u16:len><data...>\n\t */\n\n\tfor (i = 0; i < answers; ++i) {\n\t\tu16 type, class;\n\n\t\tSKIP_NAME;\n\t\tGET16(type);\n\t\tGET16(class);\n\t\tGET32(ttl);\n\t\tGET16(datalength);\n\n\t\tif (type == TYPE_A && class == CLASS_INET) {\n\t\t\tint addrcount;\n\t\t\tif (req->request_type != TYPE_A) {\n\t\t\t\tj += datalength; continue;\n\t\t\t}\n\t\t\tif ((datalength & 3) != 0) /* not an even number of As. */\n\t\t\t    goto err;\n\t\t\taddrcount = datalength >> 2;\n\n\t\t\tttl_r = MIN(ttl_r, ttl);\n\t\t\t/* we only bother with the first four addresses. */\n\t\t\tif (j + 4*addrcount > length) goto err;\n\t\t\tmemcpy(&reply.data.a[reply.rr_count],\n\t\t\t\t   packet + j, 4*addrcount);\n\t\t\tj += 4*addrcount;\n\t\t\treply.rr_count += addrcount;\n\t\t\treply.have_answer = 1;\n\t\t} else if (type == TYPE_PTR && class == CLASS_INET) {\n\t\t\tif (req->request_type != TYPE_PTR) {\n\t\t\t\tj += datalength; continue;\n\t\t\t}\n\t\t\tif (name_parse(packet, length, &j, reply.data.ptr_name,\n\t\t\t\t\t\t   buf_size)<0)\n\t\t\t\tgoto err;\n\t\t\tttl_r = MIN(ttl_r, ttl);\n\t\t\treply.have_answer = 1;\n\t\t\tbreak;\n\t\t} else if (type == TYPE_CNAME) {\n\t\t\tchar cname[HOST_NAME_MAX];\n\t\t\tif (!req->put_cname_in_ptr || *req->put_cname_in_ptr) {\n\t\t\t\tj += datalength; continue;\n\t\t\t}\n\t\t\tif (name_parse(packet, length, &j, cname,\n\t\t\t\tsizeof(cname))<0)\n\t\t\t\tgoto err;\n\t\t\t*req->put_cname_in_ptr = mm_strdup(cname);\n\t\t} else if (type == TYPE_AAAA && class == CLASS_INET) {\n\t\t\tint addrcount;\n\t\t\tif (req->request_type != TYPE_AAAA) {\n\t\t\t\tj += datalength; continue;\n\t\t\t}\n\t\t\tif ((datalength & 15) != 0) /* not an even number of AAAAs. */\n\t\t\t\tgoto err;\n\t\t\taddrcount = datalength >> 4;  /* each address is 16 bytes long */\n\t\t\tttl_r = MIN(ttl_r, ttl);\n\n\t\t\t/* we only bother with the first four addresses. */\n\t\t\tif (j + 16*addrcount > length) goto err;\n\t\t\tmemcpy(&reply.data.aaaa[reply.rr_count],\n\t\t\t\t   packet + j, 16*addrcount);\n\t\t\treply.rr_count += addrcount;\n\t\t\tj += 16*addrcount;\n\t\t\treply.have_answer = 1;\n\t\t} else {\n\t\t\t/* skip over any other type of resource */\n\t\t\tj += datalength;\n\t\t}\n\t}\n\n\tif (!reply.have_answer) {\n\t\tfor (i = 0; i < authority; ++i) {\n\t\t\tu16 type, class;\n\t\t\tSKIP_NAME;\n\t\t\tGET16(type);\n\t\t\tGET16(class);\n\t\t\tGET32(ttl);\n\t\t\tGET16(datalength);\n\t\t\tif (type == TYPE_SOA && class == CLASS_INET) {\n\t\t\t\tu32 serial, refresh, retry, expire, minimum;\n\t\t\t\tSKIP_NAME;\n\t\t\t\tSKIP_NAME;\n\t\t\t\tGET32(serial);\n\t\t\t\tGET32(refresh);\n\t\t\t\tGET32(retry);\n\t\t\t\tGET32(expire);\n\t\t\t\tGET32(minimum);\n\t\t\t\t(void)expire;\n\t\t\t\t(void)retry;\n\t\t\t\t(void)refresh;\n\t\t\t\t(void)serial;\n\t\t\t\tttl_r = MIN(ttl_r, ttl);\n\t\t\t\tttl_r = MIN(ttl_r, minimum);\n\t\t\t} else {\n\t\t\t\t/* skip over any other type of resource */\n\t\t\t\tj += datalength;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ttl_r == 0xffffffff)\n\t\tttl_r = 0;\n\n\treply_handle(req, flags, ttl_r, &reply);\n\tif (reply.data.raw)\n\t\tmm_free(reply.data.raw);\n\treturn 0;\n err:\n\tif (req)\n\t\treply_handle(req, flags, 0, NULL);\n\tif (reply.data.raw)\n\t\tmm_free(reply.data.raw);\n\treturn -1;\n}", "path": "libevent/evdns.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "libevent/libevent", "stars": 10577, "license": "other", "language": "c", "size": 12829}
{"docstring": "/* try to connect to a given server. */\n/* */\n/* return: */\n/*   0 ok */\n/*   1 temporary failure */\n/*   2 other failure */\n", "func_signal": "static int\nevdns_tcp_connect_if_disconnected(struct nameserver *server)", "code": "{\n\tstruct tcp_connection *conn = server->connection;\n\tstruct timeval *timeout = &server->base->global_tcp_idle_timeout;\n\tif (conn && conn->state != TS_DISCONNECTED && conn->bev != NULL)\n\t\treturn 0;\n\n\tdisconnect_and_free_connection(conn);\n\tconn = new_tcp_connecton(bufferevent_socket_new(server->base->event_base, -1, BEV_OPT_CLOSE_ON_FREE));\n\tif (!conn)\n\t\treturn 2;\n\tserver->connection = conn;\n\n\tif (bufferevent_set_timeouts(conn->bev, timeout, timeout))\n\t\treturn 1;\n\n\tEVUTIL_ASSERT(conn->state == TS_DISCONNECTED);\n\tif (bufferevent_socket_connect(conn->bev, (struct sockaddr *)&server->address, server->addrlen))\n\t\treturn 1;\n\n\tconn->state = TS_CONNECTING;\n\tlog(EVDNS_LOG_DEBUG, \"New tcp connection %p created\", conn);\n\treturn 0;\n}", "path": "libevent/evdns.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "libevent/libevent", "stars": 10577, "license": "other", "language": "c", "size": 12829}
{"docstring": "/* this is a libevent callback function which is called when a request */\n/* has timed out. */\n", "func_signal": "static void\nevdns_request_timeout_callback(evutil_socket_t fd, short events, void *arg)", "code": "{\n\tstruct request *const req = (struct request *) arg;\n\tstruct evdns_base *base = req->base;\n\n\t(void) fd;\n\t(void) events;\n\n\tlog(EVDNS_LOG_DEBUG, \"Request %p timed out\", arg);\n\tEVDNS_LOCK(base);\n\n\tif (req->tx_count >= req->base->global_max_retransmits) {\n\t\tstruct nameserver *ns = req->ns;\n\t\t/* this request has failed */\n\t\tlog(EVDNS_LOG_DEBUG, \"Giving up on request %p; tx_count==%d\",\n\t\t    arg, req->tx_count);\n\t\treply_schedule_callback(req, 0, DNS_ERR_TIMEOUT, NULL);\n\n\t\trequest_finished(req, &REQ_HEAD(req->base, req->trans_id), 1);\n\t\tnameserver_failed(ns, \"request timed out.\", 0);\n\t} else {\n\t\t/* if request is using tcp connection, so tear connection */\n\t\tif (req->handle->tcp_flags & DNS_QUERY_USEVC) {\n\t\t\tdisconnect_and_free_connection(req->ns->connection);\n\t\t\treq->ns->connection = NULL;\n\n\t\t\t/* client can have the only connection to DNS server */\n\t\t\tretransmit_all_tcp_requests_for(req->ns);\n\t\t} else {\n\t\t\t/* retransmit it */\n\t\t\tlog(EVDNS_LOG_DEBUG, \"Retransmitting request %p; tx_count==%d by udp\", arg, req->tx_count);\n\t\t\t(void) evtimer_del(&req->timeout_event);\n\t\t\trequest_swap_ns(req, nameserver_pick(base));\n\t\t\tevdns_request_transmit(req);\n\n\t\t\treq->ns->timedout++;\n\t\t\tif (req->ns->timedout > req->base->global_max_nameserver_timeout) {\n\t\t\t\treq->ns->timedout = 0;\n\t\t\t\tnameserver_failed(req->ns, \"request timed out.\", 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tEVDNS_UNLOCK(base);\n}", "path": "libevent/evdns.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "libevent/libevent", "stars": 10577, "license": "other", "language": "c", "size": 12829}
{"docstring": "/* Called to remove a request from a list and dealloc it. */\n/* head is a pointer to the head of the list it should be */\n/* removed from or NULL if the request isn't in a list. */\n/* when free_handle is one, free the handle as well. */\n", "func_signal": "static void\nrequest_finished(struct request *const req, struct request **head, int free_handle)", "code": "{\n\tstruct evdns_base *base = req->base;\n\tint was_inflight = (head != &base->req_waiting_head);\n\tEVDNS_LOCK(base);\n\tASSERT_VALID_REQUEST(req);\n\n\tif (head)\n\t\tevdns_request_remove(req, head);\n\n\tlog(EVDNS_LOG_DEBUG, \"Removing timeout for request %p\", req);\n\tif (was_inflight) {\n\t\tevtimer_del(&req->timeout_event);\n\t\tbase->global_requests_inflight--;\n\t\treq->ns->requests_inflight--;\n\t} else {\n\t\tbase->global_requests_waiting--;\n\t}\n\t/* it was initialized during request_new / evtimer_assign */\n\tevent_debug_unassign(&req->timeout_event);\n\n\tif (req->ns &&\n\t    req->ns->requests_inflight == 0 &&\n\t    req->base->disable_when_inactive) {\n\t\tevent_del(&req->ns->event);\n\t\tevtimer_del(&req->ns->timeout_event);\n\t}\n\n\tif (!req->request_appended) {\n\t\t/* need to free the request data on it's own */\n\t\tmm_free(req->request);\n\t} else {\n\t\t/* the request data is appended onto the header */\n\t\t/* so everything gets free()ed when we: */\n\t}\n\n\tif (req->handle) {\n\t\tEVUTIL_ASSERT(req->handle->current_req == req);\n\n\t\tif (free_handle) {\n\t\t\tsearch_request_finished(req->handle);\n\t\t\treq->handle->current_req = NULL;\n\t\t\tif (! req->handle->pending_cb) {\n\t\t\t\t/* If we're planning to run the callback,\n\t\t\t\t * don't free the handle until later. */\n\t\t\t\tmm_free(req->handle);\n\t\t\t}\n\t\t\treq->handle = NULL; /* If we have a bug, let's crash\n\t\t\t\t\t     * early */\n\t\t} else {\n\t\t\treq->handle->current_req = NULL;\n\t\t}\n\t}\n\n\tmm_free(req);\n\n\tevdns_requests_pump_waiting_queue(base);\n\tEVDNS_UNLOCK(base);\n}", "path": "libevent/evdns.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "libevent/libevent", "stars": 10577, "license": "other", "language": "c", "size": 12829}
{"docstring": "/* exported function */\n", "func_signal": "int\nevdns_base_nameserver_add(struct evdns_base *base, unsigned long int address)", "code": "{\n\tstruct sockaddr_in sin;\n\tint res;\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_addr.s_addr = address;\n\tsin.sin_port = htons(53);\n\tsin.sin_family = AF_INET;\n\tEVDNS_LOCK(base);\n\tres = evdns_nameserver_add_impl_(base, (struct sockaddr*)&sin, sizeof(sin));\n\tEVDNS_UNLOCK(base);\n\treturn res;\n}", "path": "libevent/evdns.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "libevent/libevent", "stars": 10577, "license": "other", "language": "c", "size": 12829}
{"docstring": "/*\n * If the server just has the raw password, make up a verifier entry on the\n * fly\n */\n", "func_signal": "int SSL_set_srp_server_param_pw(SSL *s, const char *user, const char *pass,\n                                const char *grp)", "code": "{\n    SRP_gN *GN = SRP_get_default_gN(grp);\n    if (GN == NULL)\n        return -1;\n    s->srp_ctx.N = BN_dup(GN->N);\n    s->srp_ctx.g = BN_dup(GN->g);\n    BN_clear_free(s->srp_ctx.v);\n    s->srp_ctx.v = NULL;\n    BN_clear_free(s->srp_ctx.s);\n    s->srp_ctx.s = NULL;\n    if (!SRP_create_verifier_BN_ex(user, pass, &s->srp_ctx.s, &s->srp_ctx.v,\n                                   GN->N, GN->g, s->ctx->libctx,\n                                   s->ctx->propq))\n        return -1;\n\n    return 1;\n}", "path": "openssl/ssl/tls_srp.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "openssl/openssl", "stars": 23848, "license": "apache-2.0", "language": "c", "size": 228777}
{"docstring": "/* server side */\n", "func_signal": "int SSL_srp_server_param_with_username(SSL *s, int *ad)", "code": "{\n    unsigned char b[SSL_MAX_MASTER_KEY_LENGTH];\n    int al;\n\n    *ad = SSL_AD_UNKNOWN_PSK_IDENTITY;\n    if ((s->srp_ctx.TLS_ext_srp_username_callback != NULL) &&\n        ((al =\n          s->srp_ctx.TLS_ext_srp_username_callback(s, ad,\n                                                   s->srp_ctx.SRP_cb_arg)) !=\n         SSL_ERROR_NONE))\n        return al;\n\n    *ad = SSL_AD_INTERNAL_ERROR;\n    if ((s->srp_ctx.N == NULL) ||\n        (s->srp_ctx.g == NULL) ||\n        (s->srp_ctx.s == NULL) || (s->srp_ctx.v == NULL))\n        return SSL3_AL_FATAL;\n\n    if (RAND_priv_bytes_ex(s->ctx->libctx, b, sizeof(b)) <= 0)\n        return SSL3_AL_FATAL;\n    s->srp_ctx.b = BN_bin2bn(b, sizeof(b), NULL);\n    OPENSSL_cleanse(b, sizeof(b));\n\n    /* Calculate:  B = (kv + g^b) % N  */\n\n    return ((s->srp_ctx.B =\n             SRP_Calc_B_ex(s->srp_ctx.b, s->srp_ctx.N, s->srp_ctx.g,\n                           s->srp_ctx.v, s->ctx->libctx, s->ctx->propq)) !=\n            NULL) ? SSL_ERROR_NONE : SSL3_AL_FATAL;\n}", "path": "openssl/ssl/tls_srp.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "openssl/openssl", "stars": 23848, "license": "apache-2.0", "language": "c", "size": 228777}
{"docstring": "/*\n * Refer to \"The TLS Protocol Version 1.0\" Section 5\n * (https://tools.ietf.org/html/rfc2246#section-5) and\n * \"The Transport Layer Security (TLS) Protocol Version 1.2\" Section 5\n * (https://tools.ietf.org/html/rfc5246#section-5).\n *\n * For TLS v1.0 and TLS v1.1:\n *\n *   PRF(secret, label, seed) = P_MD5(S1, label + seed) XOR\n *                              P_SHA-1(S2, label + seed)\n *\n * S1 is taken from the first half of the secret, S2 from the second half.\n *\n *   L_S = length in bytes of secret;\n *   L_S1 = L_S2 = ceil(L_S / 2);\n *\n * For TLS v1.2:\n *\n *   PRF(secret, label, seed) = P_<hash>(secret, label + seed)\n */\n", "func_signal": "static int tls1_prf_alg(EVP_MAC_CTX *mdctx, EVP_MAC_CTX *sha1ctx,\n                        const unsigned char *sec, size_t slen,\n                        const unsigned char *seed, size_t seed_len,\n                        unsigned char *out, size_t olen)", "code": "{\n    if (sha1ctx != NULL) {\n        /* TLS v1.0 and TLS v1.1 */\n        size_t i;\n        unsigned char *tmp;\n        /* calc: L_S1 = L_S2 = ceil(L_S / 2) */\n        size_t L_S1 = (slen + 1) / 2;\n        size_t L_S2 = L_S1;\n\n        if (!tls1_prf_P_hash(mdctx, sec, L_S1,\n                             seed, seed_len, out, olen))\n            return 0;\n\n        if ((tmp = OPENSSL_malloc(olen)) == NULL) {\n            ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);\n            return 0;\n        }\n\n        if (!tls1_prf_P_hash(sha1ctx, sec + slen - L_S2, L_S2,\n                             seed, seed_len, tmp, olen)) {\n            OPENSSL_clear_free(tmp, olen);\n            return 0;\n        }\n        for (i = 0; i < olen; i++)\n            out[i] ^= tmp[i];\n        OPENSSL_clear_free(tmp, olen);\n        return 1;\n    }\n\n    /* TLS v1.2 */\n    if (!tls1_prf_P_hash(mdctx, sec, slen, seed, seed_len, out, olen))\n        return 0;\n\n    return 1;\n}", "path": "openssl/providers/implementations/kdfs/tls1_prf.c", "commit_date": "2020-10-22 00:00:00", "repo_name": "openssl/openssl", "stars": 23848, "license": "apache-2.0", "language": "c", "size": 228777}
{"docstring": "/*-\n * a MUST be A-label\n * u MUST be U-label\n * Returns 0 if compared values are equal\n * 1 if not\n * -1 in case of errors\n */\n", "func_signal": "int ossl_a2ucompare(const char *a, const char *u)", "code": "{\n    char a_ulabel[LABEL_BUF_SIZE];\n    size_t a_size = sizeof(a_ulabel);\n\n    if (ossl_a2ulabel(a, a_ulabel, &a_size) <= 0) {\n        return -1;\n    }\n\n    return (strcmp(a_ulabel, u) == 0) ? 0 : 1;\n}", "path": "openssl/crypto/punycode.c", "commit_date": "2020-10-15 00:00:00", "repo_name": "openssl/openssl", "stars": 23848, "license": "apache-2.0", "language": "c", "size": 228777}
{"docstring": "/*\n * dgram_sctp_write - send message on SCTP socket\n * @b: BIO to write to\n * @in: data to send\n * @inl: amount of bytes in @in to send\n *\n * Returns -1 on error or the sent amount of bytes on success\n */\n", "func_signal": "static int dgram_sctp_write(BIO *b, const char *in, int inl)", "code": "{\n    int ret;\n    bio_dgram_sctp_data *data = (bio_dgram_sctp_data *) b->ptr;\n    struct bio_dgram_sctp_sndinfo *sinfo = &(data->sndinfo);\n    struct bio_dgram_sctp_prinfo *pinfo = &(data->prinfo);\n    struct bio_dgram_sctp_sndinfo handshake_sinfo;\n    struct iovec iov[1];\n    struct msghdr msg;\n    struct cmsghdr *cmsg;\n#  if defined(SCTP_SNDINFO) && defined(SCTP_PRINFO)\n    char cmsgbuf[CMSG_SPACE(sizeof(struct sctp_sndinfo)) +\n                 CMSG_SPACE(sizeof(struct sctp_prinfo))];\n    struct sctp_sndinfo *sndinfo;\n    struct sctp_prinfo *prinfo;\n#  else\n    char cmsgbuf[CMSG_SPACE(sizeof(struct sctp_sndrcvinfo))];\n    struct sctp_sndrcvinfo *sndrcvinfo;\n#  endif\n\n    clear_socket_error();\n\n    /*\n     * If we're send anything else than application data, disable all user\n     * parameters and flags.\n     */\n    if (in[0] != 23) {\n        memset(&handshake_sinfo, 0, sizeof(handshake_sinfo));\n#  ifdef SCTP_SACK_IMMEDIATELY\n        handshake_sinfo.snd_flags = SCTP_SACK_IMMEDIATELY;\n#  endif\n        sinfo = &handshake_sinfo;\n    }\n\n    /* We can only send a shutdown alert if the socket is dry */\n    if (data->save_shutdown) {\n        ret = BIO_dgram_sctp_wait_for_dry(b);\n        if (ret < 0)\n            return -1;\n        if (ret == 0) {\n            BIO_clear_retry_flags(b);\n            BIO_set_retry_write(b);\n            return -1;\n        }\n    }\n\n    iov[0].iov_base = (char *)in;\n    iov[0].iov_len = inl;\n    msg.msg_name = NULL;\n    msg.msg_namelen = 0;\n    msg.msg_iov = iov;\n    msg.msg_iovlen = 1;\n    msg.msg_control = (caddr_t) cmsgbuf;\n    msg.msg_controllen = 0;\n    msg.msg_flags = 0;\n#  if defined(SCTP_SNDINFO) && defined(SCTP_PRINFO)\n    cmsg = (struct cmsghdr *)cmsgbuf;\n    cmsg->cmsg_level = IPPROTO_SCTP;\n    cmsg->cmsg_type = SCTP_SNDINFO;\n    cmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_sndinfo));\n    sndinfo = (struct sctp_sndinfo *)CMSG_DATA(cmsg);\n    memset(sndinfo, 0, sizeof(*sndinfo));\n    sndinfo->snd_sid = sinfo->snd_sid;\n    sndinfo->snd_flags = sinfo->snd_flags;\n    sndinfo->snd_ppid = sinfo->snd_ppid;\n    sndinfo->snd_context = sinfo->snd_context;\n    msg.msg_controllen += CMSG_SPACE(sizeof(struct sctp_sndinfo));\n\n    cmsg =\n        (struct cmsghdr *)&cmsgbuf[CMSG_SPACE(sizeof(struct sctp_sndinfo))];\n    cmsg->cmsg_level = IPPROTO_SCTP;\n    cmsg->cmsg_type = SCTP_PRINFO;\n    cmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_prinfo));\n    prinfo = (struct sctp_prinfo *)CMSG_DATA(cmsg);\n    memset(prinfo, 0, sizeof(*prinfo));\n    prinfo->pr_policy = pinfo->pr_policy;\n    prinfo->pr_value = pinfo->pr_value;\n    msg.msg_controllen += CMSG_SPACE(sizeof(struct sctp_prinfo));\n#  else\n    cmsg = (struct cmsghdr *)cmsgbuf;\n    cmsg->cmsg_level = IPPROTO_SCTP;\n    cmsg->cmsg_type = SCTP_SNDRCV;\n    cmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_sndrcvinfo));\n    sndrcvinfo = (struct sctp_sndrcvinfo *)CMSG_DATA(cmsg);\n    memset(sndrcvinfo, 0, sizeof(*sndrcvinfo));\n    sndrcvinfo->sinfo_stream = sinfo->snd_sid;\n    sndrcvinfo->sinfo_flags = sinfo->snd_flags;\n#   ifdef __FreeBSD__\n    sndrcvinfo->sinfo_flags |= pinfo->pr_policy;\n#   endif\n    sndrcvinfo->sinfo_ppid = sinfo->snd_ppid;\n    sndrcvinfo->sinfo_context = sinfo->snd_context;\n    sndrcvinfo->sinfo_timetolive = pinfo->pr_value;\n    msg.msg_controllen += CMSG_SPACE(sizeof(struct sctp_sndrcvinfo));\n#  endif\n\n    ret = sendmsg(b->num, &msg, 0);\n\n    BIO_clear_retry_flags(b);\n    if (ret <= 0) {\n        if (BIO_dgram_should_retry(ret)) {\n            BIO_set_retry_write(b);\n            data->_errno = get_last_socket_error();\n        }\n    }\n    return ret;\n}", "path": "openssl/crypto/bio/bss_dgram.c", "commit_date": "2020-11-26 00:00:00", "repo_name": "openssl/openssl", "stars": 23848, "license": "apache-2.0", "language": "c", "size": 228777}
{"docstring": "/* Simple PKCS#12 file reader */\n", "func_signal": "static char *find_friendly_name(PKCS12 *p12)", "code": "{\n    STACK_OF(PKCS7) *safes;\n    int n, m;\n    char *name = NULL;\n    PKCS7 *safe;\n    STACK_OF(PKCS12_SAFEBAG) *bags;\n    PKCS12_SAFEBAG *bag;\n\n    if ((safes = PKCS12_unpack_authsafes(p12)) == NULL)\n        return NULL;\n\n    for (n = 0; n < sk_PKCS7_num(safes) && name == NULL; n++) {\n        safe = sk_PKCS7_value(safes, n);\n        if (OBJ_obj2nid(safe->type) != NID_pkcs7_data\n                || (bags = PKCS12_unpack_p7data(safe)) == NULL)\n            continue;\n\n        for (m = 0; m < sk_PKCS12_SAFEBAG_num(bags) && name == NULL; m++) {\n            bag = sk_PKCS12_SAFEBAG_value(bags, m);\n            name = PKCS12_get_friendlyname(bag);\n        }\n        sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);\n    }\n\n    sk_PKCS7_pop_free(safes, PKCS7_free);\n\n    return name;\n}", "path": "openssl/demos/pkcs12/pkread.c", "commit_date": "2020-04-23 00:00:00", "repo_name": "openssl/openssl", "stars": 23848, "license": "apache-2.0", "language": "c", "size": 228777}
{"docstring": "/*\n * Check whether an EC_POINT is on the curve or not. Note that the return\n * value for this function should NOT be treated as a boolean. Return values:\n *  1: The point is on the curve\n *  0: The point is not on the curve\n * -1: An error occurred\n */\n", "func_signal": "int EC_POINT_is_on_curve(const EC_GROUP *group, const EC_POINT *point,\n                         BN_CTX *ctx)", "code": "{\n    if (group->meth->is_on_curve == 0) {\n        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n    if (!ec_point_is_compat(point, group)) {\n        ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);\n        return 0;\n    }\n    return group->meth->is_on_curve(group, point, ctx);\n}", "path": "openssl/crypto/ec/ec_lib.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "openssl/openssl", "stars": 23848, "license": "apache-2.0", "language": "c", "size": 228777}
{"docstring": "/*-\n * Pseudocode:\n *\n * function adapt(delta,numpoints,firsttime):\n *  if firsttime then let delta = delta div damp\n *  else let delta = delta div 2\n *  let delta = delta + (delta div numpoints)\n *  let k = 0\n *  while delta > ((base - tmin) * tmax) div 2 do begin\n *    let delta = delta div (base - tmin)\n *    let k = k + base\n *  end\n *  return k + (((base - tmin + 1) * delta) div (delta + skew))\n */\n", "func_signal": "static int adapt(unsigned int delta, unsigned int numpoints,\n                 unsigned int firsttime)", "code": "{\n    unsigned int k = 0;\n\n    delta = (firsttime) ? delta / damp : delta / 2;\n    delta = delta + delta / numpoints;\n\n    while (delta > ((base - tmin) * tmax) / 2) {\n        delta = delta / (base - tmin);\n        k = k + base;\n    }\n\n    return k + (((base - tmin + 1) * delta) / (delta + skew));\n}", "path": "openssl/crypto/punycode.c", "commit_date": "2020-10-15 00:00:00", "repo_name": "openssl/openssl", "stars": 23848, "license": "apache-2.0", "language": "c", "size": 228777}
{"docstring": "/*\n * ec_precompute_mont_data sets |group->mont_data| from |group->order| and\n * returns one on success. On error it returns zero.\n */\n", "func_signal": "static int ec_precompute_mont_data(EC_GROUP *group)", "code": "{\n    BN_CTX *ctx = BN_CTX_new_ex(group->libctx);\n    int ret = 0;\n\n    BN_MONT_CTX_free(group->mont_data);\n    group->mont_data = NULL;\n\n    if (ctx == NULL)\n        goto err;\n\n    group->mont_data = BN_MONT_CTX_new();\n    if (group->mont_data == NULL)\n        goto err;\n\n    if (!BN_MONT_CTX_set(group->mont_data, group->order, ctx)) {\n        BN_MONT_CTX_free(group->mont_data);\n        group->mont_data = NULL;\n        goto err;\n    }\n\n    ret = 1;\n\n err:\n\n    BN_CTX_free(ctx);\n    return ret;\n}", "path": "openssl/crypto/ec/ec_lib.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "openssl/openssl", "stars": 23848, "license": "apache-2.0", "language": "c", "size": 228777}
{"docstring": "/* functions for EC_POINT objects */\n", "func_signal": "EC_POINT *EC_POINT_new(const EC_GROUP *group)", "code": "{\n    EC_POINT *ret;\n\n    if (group == NULL) {\n        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);\n        return NULL;\n    }\n    if (group->meth->point_init == NULL) {\n        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return NULL;\n    }\n\n    ret = OPENSSL_zalloc(sizeof(*ret));\n    if (ret == NULL) {\n        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    ret->meth = group->meth;\n    ret->curve_name = group->curve_name;\n\n    if (!ret->meth->point_init(ret)) {\n        OPENSSL_free(ret);\n        return NULL;\n    }\n\n    return ret;\n}", "path": "openssl/crypto/ec/ec_lib.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "openssl/openssl", "stars": 23848, "license": "apache-2.0", "language": "c", "size": 228777}
{"docstring": "/*\n * For this DSO_METHOD, our meth_data STACK will contain; (i) the handle\n * (void*) returned from dlopen().\n */\n", "func_signal": "static int dlfcn_load(DSO *dso)", "code": "{\n    void *ptr = NULL;\n    /* See applicable comments in dso_dl.c */\n    char *filename = DSO_convert_filename(dso, NULL);\n    int flags = DLOPEN_FLAG;\n    int saveerrno = get_last_sys_error();\n\n    if (filename == NULL) {\n        ERR_raise(ERR_LIB_DSO, DSO_R_NO_FILENAME);\n        goto err;\n    }\n# ifdef RTLD_GLOBAL\n    if (dso->flags & DSO_FLAG_GLOBAL_SYMBOLS)\n        flags |= RTLD_GLOBAL;\n# endif\n# ifdef _AIX\n    if (filename[strlen(filename) - 1] == ')')\n        flags |= RTLD_MEMBER;\n# endif\n    ptr = dlopen(filename, flags);\n    if (ptr == NULL) {\n        ERR_raise_data(ERR_LIB_DSO, DSO_R_LOAD_FAILED,\n                       \"filename(%s): %s\", filename, dlerror());\n        goto err;\n    }\n    /*\n     * Some dlopen() implementations (e.g. solaris) do no preserve errno, even\n     * on a successful call.\n     */\n    set_sys_error(saveerrno);\n    if (!sk_void_push(dso->meth_data, (char *)ptr)) {\n        ERR_raise(ERR_LIB_DSO, DSO_R_STACK_ERROR);\n        goto err;\n    }\n    /* Success */\n    dso->loaded_filename = filename;\n    return 1;\n err:\n    /* Cleanup! */\n    OPENSSL_free(filename);\n    if (ptr != NULL)\n        dlclose(ptr);\n    return 0;\n}", "path": "openssl/crypto/dso/dso_dlfcn.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "openssl/openssl", "stars": 23848, "license": "apache-2.0", "language": "c", "size": 228777}
{"docstring": "/*\n * Check if the explicit parameters group matches any built-in curves.\n *\n * We create a copy of the group just built, so that we can remove optional\n * fields for the lookup: we do this to avoid the possibility that one of\n * the optional parameters is used to force the library into using a less\n * performant and less secure EC_METHOD instead of the specialized one.\n * In any case, `seed` is not really used in any computation, while a\n * cofactor different from the one in the built-in table is just\n * mathematically wrong anyway and should not be used.\n */\n", "func_signal": "static EC_GROUP *ec_group_explicit_to_named(const EC_GROUP *group,\n                                            OSSL_LIB_CTX *libctx,\n                                            const char *propq,\n                                            BN_CTX *ctx)", "code": "{\n    EC_GROUP *ret_group = NULL, *dup = NULL;\n    int curve_name_nid;\n\n    const EC_POINT *point = EC_GROUP_get0_generator(group);\n    const BIGNUM *order = EC_GROUP_get0_order(group);\n    int no_seed = (EC_GROUP_get0_seed(group) == NULL);\n\n    if ((dup = EC_GROUP_dup(group)) == NULL\n            || EC_GROUP_set_seed(dup, NULL, 0) != 1\n            || !EC_GROUP_set_generator(dup, point, order, NULL))\n        goto err;\n    if ((curve_name_nid = ec_curve_nid_from_params(dup, ctx)) != NID_undef) {\n        /*\n         * The input explicit parameters successfully matched one of the\n         * built-in curves: often for built-in curves we have specialized\n         * methods with better performance and hardening.\n         *\n         * In this case we replace the `EC_GROUP` created through explicit\n         * parameters with one created from a named group.\n         */\n\n#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128\n        /*\n         * NID_wap_wsg_idm_ecid_wtls12 and NID_secp224r1 are both aliases for\n         * the same curve, we prefer the SECP nid when matching explicit\n         * parameters as that is associated with a specialized EC_METHOD.\n         */\n        if (curve_name_nid == NID_wap_wsg_idm_ecid_wtls12)\n            curve_name_nid = NID_secp224r1;\n#endif /* !def(OPENSSL_NO_EC_NISTP_64_GCC_128) */\n\n        ret_group = EC_GROUP_new_by_curve_name_ex(libctx, propq, curve_name_nid);\n        if (ret_group == NULL)\n            goto err;\n\n        /*\n         * Set the flag so that EC_GROUPs created from explicit parameters are\n         * serialized using explicit parameters by default.\n         */\n        EC_GROUP_set_asn1_flag(ret_group, OPENSSL_EC_EXPLICIT_CURVE);\n\n        /*\n         * If the input params do not contain the optional seed field we make\n         * sure it is not added to the returned group.\n         *\n         * The seed field is not really used inside libcrypto anyway, and\n         * adding it to parsed explicit parameter keys would alter their DER\n         * encoding output (because of the extra field) which could impact\n         * applications fingerprinting keys by their DER encoding.\n         */\n        if (no_seed) {\n            if (EC_GROUP_set_seed(ret_group, NULL, 0) != 1)\n                goto err;\n        }\n    } else {\n        ret_group = (EC_GROUP *)group;\n    }\n    EC_GROUP_free(dup);\n    return ret_group;\nerr:\n    EC_GROUP_free(dup);\n    EC_GROUP_free(ret_group);\n    return NULL;\n}", "path": "openssl/crypto/ec/ec_lib.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "openssl/openssl", "stars": 23848, "license": "apache-2.0", "language": "c", "size": 228777}
{"docstring": "/* Returns -2 for errors because both -1 and 0 are valid results. */\n", "func_signal": "int BN_kronecker(const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)", "code": "{\n    int i;\n    int ret = -2;               /* avoid 'uninitialized' warning */\n    int err = 0;\n    BIGNUM *A, *B, *tmp;\n    /*-\n     * In 'tab', only odd-indexed entries are relevant:\n     * For any odd BIGNUM n,\n     *     tab[BN_lsw(n) & 7]\n     * is $(-1)^{(n^2-1)/8}$ (using TeX notation).\n     * Note that the sign of n does not matter.\n     */\n    static const int tab[8] = { 0, 1, 0, -1, 0, -1, 0, 1 };\n\n    bn_check_top(a);\n    bn_check_top(b);\n\n    BN_CTX_start(ctx);\n    A = BN_CTX_get(ctx);\n    B = BN_CTX_get(ctx);\n    if (B == NULL)\n        goto end;\n\n    err = !BN_copy(A, a);\n    if (err)\n        goto end;\n    err = !BN_copy(B, b);\n    if (err)\n        goto end;\n\n    /*\n     * Kronecker symbol, implemented according to Henri Cohen,\n     * \"A Course in Computational Algebraic Number Theory\"\n     * (algorithm 1.4.10).\n     */\n\n    /* Cohen's step 1: */\n\n    if (BN_is_zero(B)) {\n        ret = BN_abs_is_word(A, 1);\n        goto end;\n    }\n\n    /* Cohen's step 2: */\n\n    if (!BN_is_odd(A) && !BN_is_odd(B)) {\n        ret = 0;\n        goto end;\n    }\n\n    /* now  B  is non-zero */\n    i = 0;\n    while (!BN_is_bit_set(B, i))\n        i++;\n    err = !BN_rshift(B, B, i);\n    if (err)\n        goto end;\n    if (i & 1) {\n        /* i is odd */\n        /* (thus  B  was even, thus  A  must be odd!)  */\n\n        /* set 'ret' to $(-1)^{(A^2-1)/8}$ */\n        ret = tab[BN_lsw(A) & 7];\n    } else {\n        /* i is even */\n        ret = 1;\n    }\n\n    if (B->neg) {\n        B->neg = 0;\n        if (A->neg)\n            ret = -ret;\n    }\n\n    /*\n     * now B is positive and odd, so what remains to be done is to compute\n     * the Jacobi symbol (A/B) and multiply it by 'ret'\n     */\n\n    while (1) {\n        /* Cohen's step 3: */\n\n        /*  B  is positive and odd */\n\n        if (BN_is_zero(A)) {\n            ret = BN_is_one(B) ? ret : 0;\n            goto end;\n        }\n\n        /* now  A  is non-zero */\n        i = 0;\n        while (!BN_is_bit_set(A, i))\n            i++;\n        err = !BN_rshift(A, A, i);\n        if (err)\n            goto end;\n        if (i & 1) {\n            /* i is odd */\n            /* multiply 'ret' by  $(-1)^{(B^2-1)/8}$ */\n            ret = ret * tab[BN_lsw(B) & 7];\n        }\n\n        /* Cohen's step 4: */\n        /* multiply 'ret' by  $(-1)^{(A-1)(B-1)/4}$ */\n        if ((A->neg ? ~BN_lsw(A) : BN_lsw(A)) & BN_lsw(B) & 2)\n            ret = -ret;\n\n        /* (A, B) := (B mod |A|, |A|) */\n        err = !BN_nnmod(B, B, A, ctx);\n        if (err)\n            goto end;\n        tmp = A;\n        A = B;\n        B = tmp;\n        tmp->neg = 0;\n    }\n end:\n    BN_CTX_end(ctx);\n    if (err)\n        return -2;\n    else\n        return ret;\n}", "path": "openssl/crypto/bn/bn_kron.c", "commit_date": "2019-09-28 00:00:00", "repo_name": "openssl/openssl", "stars": 23848, "license": "apache-2.0", "language": "c", "size": 228777}
{"docstring": "/*-\n * Try computing cofactor from the generator order (n) and field cardinality (q).\n * This works for all curves of cryptographic interest.\n *\n * Hasse thm: q + 1 - 2*sqrt(q) <= n*h <= q + 1 + 2*sqrt(q)\n * h_min = (q + 1 - 2*sqrt(q))/n\n * h_max = (q + 1 + 2*sqrt(q))/n\n * h_max - h_min = 4*sqrt(q)/n\n * So if n > 4*sqrt(q) holds, there is only one possible value for h:\n * h = \\lfloor (h_min + h_max)/2 \\rceil = \\lfloor (q + 1)/n \\rceil\n *\n * Otherwise, zero cofactor and return success.\n */\n", "func_signal": "static int ec_guess_cofactor(EC_GROUP *group)", "code": "{\n    int ret = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *q = NULL;\n\n    /*-\n     * If the cofactor is too large, we cannot guess it.\n     * The RHS of below is a strict overestimate of lg(4 * sqrt(q))\n     */\n    if (BN_num_bits(group->order) <= (BN_num_bits(group->field) + 1) / 2 + 3) {\n        /* default to 0 */\n        BN_zero(group->cofactor);\n        /* return success */\n        return 1;\n    }\n\n    if ((ctx = BN_CTX_new_ex(group->libctx)) == NULL)\n        return 0;\n\n    BN_CTX_start(ctx);\n    if ((q = BN_CTX_get(ctx)) == NULL)\n        goto err;\n\n    /* set q = 2**m for binary fields; q = p otherwise */\n    if (group->meth->field_type == NID_X9_62_characteristic_two_field) {\n        BN_zero(q);\n        if (!BN_set_bit(q, BN_num_bits(group->field) - 1))\n            goto err;\n    } else {\n        if (!BN_copy(q, group->field))\n            goto err;\n    }\n\n    /* compute h = \\lfloor (q + 1)/n \\rceil = \\lfloor (q + 1 + n/2)/n \\rfloor */\n    if (!BN_rshift1(group->cofactor, group->order) /* n/2 */\n        || !BN_add(group->cofactor, group->cofactor, q) /* q + n/2 */\n        /* q + 1 + n/2 */\n        || !BN_add(group->cofactor, group->cofactor, BN_value_one())\n        /* (q + 1 + n/2)/n */\n        || !BN_div(group->cofactor, NULL, group->cofactor, group->order, ctx))\n        goto err;\n    ret = 1;\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ret;\n}", "path": "openssl/crypto/ec/ec_lib.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "openssl/openssl", "stars": 23848, "license": "apache-2.0", "language": "c", "size": 228777}
{"docstring": "/*-\n * Default behavior, if group->meth->field_inverse_mod_ord is NULL:\n * - When group->order is even, this function returns an error.\n * - When group->order is otherwise composite, the correctness\n *   of the output is not guaranteed.\n * - When x is outside the range [1, group->order), the correctness\n *   of the output is not guaranteed.\n * - Otherwise, this function returns the multiplicative inverse in the\n *   range [1, group->order).\n *\n * EC_METHODs must implement their own field_inverse_mod_ord for\n * other functionality.\n */\n", "func_signal": "int ec_group_do_inverse_ord(const EC_GROUP *group, BIGNUM *res,\n                            const BIGNUM *x, BN_CTX *ctx)", "code": "{\n    if (group->meth->field_inverse_mod_ord != NULL)\n        return group->meth->field_inverse_mod_ord(group, res, x, ctx);\n    else\n        return ec_field_inverse_mod_ord(group, res, x, ctx);\n}", "path": "openssl/crypto/ec/ec_lib.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "openssl/openssl", "stars": 23848, "license": "apache-2.0", "language": "c", "size": 228777}
{"docstring": "/*\n * Encode a code point using UTF-8\n * return number of bytes on success, 0 on failure\n * (also produces U+FFFD, which uses 3 bytes on failure)\n */\n", "func_signal": "static int codepoint2utf8(unsigned char *out, unsigned long utf)", "code": "{\n    if (utf <= 0x7F) {\n        /* Plain ASCII */\n        out[0] = (unsigned char)utf;\n        out[1] = 0;\n        return 1;\n    } else if (utf <= 0x07FF) {\n        /* 2-byte unicode */\n        out[0] = (unsigned char)(((utf >> 6) & 0x1F) | 0xC0);\n        out[1] = (unsigned char)(((utf >> 0) & 0x3F) | 0x80);\n        out[2] = 0;\n        return 2;\n    } else if (utf <= 0xFFFF) {\n        /* 3-byte unicode */\n        out[0] = (unsigned char)(((utf >> 12) & 0x0F) | 0xE0);\n        out[1] = (unsigned char)(((utf >> 6) & 0x3F) | 0x80);\n        out[2] = (unsigned char)(((utf >> 0) & 0x3F) | 0x80);\n        out[3] = 0;\n        return 3;\n    } else if (utf <= 0x10FFFF) {\n        /* 4-byte unicode */\n        out[0] = (unsigned char)(((utf >> 18) & 0x07) | 0xF0);\n        out[1] = (unsigned char)(((utf >> 12) & 0x3F) | 0x80);\n        out[2] = (unsigned char)(((utf >> 6) & 0x3F) | 0x80);\n        out[3] = (unsigned char)(((utf >> 0) & 0x3F) | 0x80);\n        out[4] = 0;\n        return 4;\n    } else {\n        /* error - use replacement character */\n        out[0] = (unsigned char)0xEF;\n        out[1] = (unsigned char)0xBF;\n        out[2] = (unsigned char)0xBD;\n        out[3] = 0;\n        return 0;\n    }\n}", "path": "openssl/crypto/punycode.c", "commit_date": "2020-10-15 00:00:00", "repo_name": "openssl/openssl", "stars": 23848, "license": "apache-2.0", "language": "c", "size": 228777}
{"docstring": "/*\n * This dladdr()-implementation will also find the ptrgl (Pointer Glue) virtual\n * address of a function, which is just located in the DATA segment instead of\n * the TEXT segment.\n */\n", "func_signal": "static int dladdr(void *ptr, Dl_info *dl)", "code": "{\n    uintptr_t addr = (uintptr_t)ptr;\n    unsigned int found = 0;\n    struct ld_info *ldinfos, *next_ldi, *this_ldi;\n\n    if ((ldinfos = OPENSSL_malloc(DLFCN_LDINFO_SIZE)) == NULL) {\n        errno = ENOMEM;\n        dl->dli_fname = NULL;\n        return 0;\n    }\n\n    if ((loadquery(L_GETINFO, (void *)ldinfos, DLFCN_LDINFO_SIZE)) < 0) {\n        /*-\n         * Error handling is done through errno and dlerror() reading errno:\n         *  ENOMEM (ldinfos buffer is too small),\n         *  EINVAL (invalid flags),\n         *  EFAULT (invalid ldinfos ptr)\n         */\n        OPENSSL_free((void *)ldinfos);\n        dl->dli_fname = NULL;\n        return 0;\n    }\n    next_ldi = ldinfos;\n\n    do {\n        this_ldi = next_ldi;\n        if (((addr >= (uintptr_t)this_ldi->ldinfo_textorg)\n             && (addr < ((uintptr_t)this_ldi->ldinfo_textorg +\n                         this_ldi->ldinfo_textsize)))\n            || ((addr >= (uintptr_t)this_ldi->ldinfo_dataorg)\n                && (addr < ((uintptr_t)this_ldi->ldinfo_dataorg +\n                            this_ldi->ldinfo_datasize)))) {\n            char *buffer, *member;\n            size_t buffer_sz, member_len;\n\n            buffer_sz = strlen(this_ldi->ldinfo_filename) + 1;\n            member = this_ldi->ldinfo_filename + buffer_sz;\n            if ((member_len = strlen(member)) > 0)\n                buffer_sz += 1 + member_len + 1;\n            found = 1;\n            if ((buffer = OPENSSL_malloc(buffer_sz)) != NULL) {\n                OPENSSL_strlcpy(buffer, this_ldi->ldinfo_filename, buffer_sz);\n                if (member_len > 0) {\n                    /*\n                     * Need to respect a possible member name and not just\n                     * returning the path name in this case. See docs:\n                     * sys/ldr.h, loadquery() and dlopen()/RTLD_MEMBER.\n                     */\n                    OPENSSL_strlcat(buffer, \"(\", buffer_sz);\n                    OPENSSL_strlcat(buffer, member, buffer_sz);\n                    OPENSSL_strlcat(buffer, \")\", buffer_sz);\n                }\n                dl->dli_fname = buffer;\n            } else {\n                errno = ENOMEM;\n            }\n        } else {\n            next_ldi = (struct ld_info *)((uintptr_t)this_ldi +\n                                          this_ldi->ldinfo_next);\n        }\n    } while (this_ldi->ldinfo_next && !found);\n    OPENSSL_free((void *)ldinfos);\n    return (found && dl->dli_fname != NULL);\n}", "path": "openssl/crypto/dso/dso_dlfcn.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "openssl/openssl", "stars": 23848, "license": "apache-2.0", "language": "c", "size": 228777}
{"docstring": "/* client side */\n", "func_signal": "int srp_generate_client_master_secret(SSL *s)", "code": "{\n    BIGNUM *x = NULL, *u = NULL, *K = NULL;\n    int ret = -1, tmp_len = 0;\n    char *passwd = NULL;\n    unsigned char *tmp = NULL;\n\n    /*\n     * Checks if b % n == 0\n     */\n    if (SRP_Verify_B_mod_N(s->srp_ctx.B, s->srp_ctx.N) == 0\n            || (u = SRP_Calc_u_ex(s->srp_ctx.A, s->srp_ctx.B, s->srp_ctx.N,\n                                  s->ctx->libctx, s->ctx->propq))\n               == NULL\n            || s->srp_ctx.SRP_give_srp_client_pwd_callback == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n    if ((passwd = s->srp_ctx.SRP_give_srp_client_pwd_callback(s,\n                                                      s->srp_ctx.SRP_cb_arg))\n            == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_CALLBACK_FAILED);\n        goto err;\n    }\n    if ((x = SRP_Calc_x_ex(s->srp_ctx.s, s->srp_ctx.login, passwd,\n                           s->ctx->libctx, s->ctx->propq)) == NULL\n            || (K = SRP_Calc_client_key_ex(s->srp_ctx.N, s->srp_ctx.B,\n                                           s->srp_ctx.g, x,\n                                           s->srp_ctx.a, u,\n                                           s->ctx->libctx,\n                                           s->ctx->propq)) == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    tmp_len = BN_num_bytes(K);\n    if ((tmp = OPENSSL_malloc(tmp_len)) == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    BN_bn2bin(K, tmp);\n    /* Calls SSLfatal() as required */\n    ret = ssl_generate_master_secret(s, tmp, tmp_len, 1);\n err:\n    BN_clear_free(K);\n    BN_clear_free(x);\n    if (passwd != NULL)\n        OPENSSL_clear_free(passwd, strlen(passwd));\n    BN_clear_free(u);\n    return ret;\n}", "path": "openssl/ssl/tls_srp.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "openssl/openssl", "stars": 23848, "license": "apache-2.0", "language": "c", "size": 228777}
{"docstring": "/* functions for EC_GROUP objects */\n", "func_signal": "EC_GROUP *ec_group_new_ex(OSSL_LIB_CTX *libctx, const char *propq,\n                          const EC_METHOD *meth)", "code": "{\n    EC_GROUP *ret;\n\n    if (meth == NULL) {\n        ERR_raise(ERR_LIB_EC, EC_R_SLOT_FULL);\n        return NULL;\n    }\n    if (meth->group_init == 0) {\n        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return NULL;\n    }\n\n    ret = OPENSSL_zalloc(sizeof(*ret));\n    if (ret == NULL) {\n        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    ret->libctx = libctx;\n    if (propq != NULL) {\n        ret->propq = OPENSSL_strdup(propq);\n        if (ret->propq == NULL) {\n            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n    }\n    ret->meth = meth;\n    if ((ret->meth->flags & EC_FLAGS_CUSTOM_CURVE) == 0) {\n        ret->order = BN_new();\n        if (ret->order == NULL)\n            goto err;\n        ret->cofactor = BN_new();\n        if (ret->cofactor == NULL)\n            goto err;\n    }\n    ret->asn1_flag = OPENSSL_EC_NAMED_CURVE;\n    ret->asn1_form = POINT_CONVERSION_UNCOMPRESSED;\n    if (!meth->group_init(ret))\n        goto err;\n    return ret;\n\n err:\n    BN_free(ret->order);\n    BN_free(ret->cofactor);\n    OPENSSL_free(ret->propq);\n    OPENSSL_free(ret);\n    return NULL;\n}", "path": "openssl/crypto/ec/ec_lib.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "openssl/openssl", "stars": 23848, "license": "apache-2.0", "language": "c", "size": 228777}
{"docstring": "/*-\n * Coordinate blinding for EC_POINT.\n *\n * The underlying EC_METHOD can optionally implement this function:\n * underlying implementations should return 0 on errors, or 1 on\n * success.\n *\n * This wrapper returns 1 in case the underlying EC_METHOD does not\n * support coordinate blinding.\n */\n", "func_signal": "int ec_point_blind_coordinates(const EC_GROUP *group, EC_POINT *p, BN_CTX *ctx)", "code": "{\n    if (group->meth->blind_coordinates == NULL)\n        return 1; /* ignore if not implemented */\n\n    return group->meth->blind_coordinates(group, p, ctx);\n}", "path": "openssl/crypto/ec/ec_lib.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "openssl/openssl", "stars": 23848, "license": "apache-2.0", "language": "c", "size": 228777}
{"docstring": "/* ioctl callback function */\n", "func_signal": "static curlioerr my_ioctl(CURL *handle, curliocmd cmd, void *userp)", "code": "{\n  int *fdp = (int *)userp;\n  int fd = *fdp;\n\n  (void)handle; /* not used in here */\n\n  switch(cmd) {\n  case CURLIOCMD_RESTARTREAD:\n    /* mr libcurl kindly asks as to rewind the read data stream to start */\n    if(-1 == lseek(fd, 0, SEEK_SET))\n      /* couldn't rewind */\n      return CURLIOE_FAILRESTART;\n\n    break;\n\n  default: /* ignore unknown commands */\n    return CURLIOE_UNKNOWNCMD;\n  }\n  return CURLIOE_OK; /* success! */\n}", "path": "curl/docs/examples/anyauthput.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "curl/curl", "stars": 33384, "license": "other", "language": "c", "size": 84463}
{"docstring": "/* 3x download!\n * 1. normal\n * 2. dup handle\n * 3. with multi interface\n */\n", "func_signal": "int test(char *URL)", "code": "{\n  CURL *handle = NULL;\n  CURL *duphandle = NULL;\n  CURLM *mhandle = NULL;\n  int res = 0;\n  int still_running = 0;\n\n  start_test_timing();\n\n  global_init(CURL_GLOBAL_ALL);\n\n  easy_init(handle);\n\n  easy_setopt(handle, CURLOPT_URL, URL);\n  easy_setopt(handle, CURLOPT_WILDCARDMATCH, 1L);\n  easy_setopt(handle, CURLOPT_VERBOSE, 1L);\n\n  res = curl_easy_perform(handle);\n  if(res)\n    goto test_cleanup;\n\n  res = curl_easy_perform(handle);\n  if(res)\n    goto test_cleanup;\n\n  duphandle = curl_easy_duphandle(handle);\n  if(!duphandle)\n    goto test_cleanup;\n  curl_easy_cleanup(handle);\n  handle = duphandle;\n\n  multi_init(mhandle);\n\n  multi_add_handle(mhandle, handle);\n\n  multi_perform(mhandle, &still_running);\n\n  abort_on_test_timeout();\n\n  while(still_running) {\n    struct timeval timeout;\n    fd_set fdread;\n    fd_set fdwrite;\n    fd_set fdexcep;\n    int maxfd = -99;\n\n    timeout.tv_sec = 0;\n    timeout.tv_usec = 100000L; /* 100 ms */\n\n    FD_ZERO(&fdread);\n    FD_ZERO(&fdwrite);\n    FD_ZERO(&fdexcep);\n\n    multi_fdset(mhandle, &fdread, &fdwrite, &fdexcep, &maxfd);\n\n    /* At this point, maxfd is guaranteed to be greater or equal than -1. */\n\n    select_test(maxfd + 1, &fdread, &fdwrite, &fdexcep, &timeout);\n\n    abort_on_test_timeout();\n\n    multi_perform(mhandle, &still_running);\n\n    abort_on_test_timeout();\n  }\n\ntest_cleanup:\n\n  /* undocumented cleanup sequence - type UA */\n\n  curl_multi_cleanup(mhandle);\n  curl_easy_cleanup(handle);\n  curl_global_cleanup();\n\n  return res;\n}", "path": "curl/tests/libtest/lib575.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "curl/curl", "stars": 33384, "license": "other", "language": "c", "size": 84463}
{"docstring": "/* more than 16K */\n", "func_signal": "int test(char *URL)", "code": "{\n  CURL *curl = NULL;\n  CURLcode res = CURLE_OK;\n  curl_mime *mime = NULL;\n  curl_mimepart *part;\n  size_t i;\n\n  /* Checks huge binary-encoded mime post. */\n\n  /* Create a buffer with pseudo-binary data. */\n  for(i = 0; i < sizeof(buffer); i++)\n    if(i % 77 == 76)\n      buffer[i] = '\\n';\n    else\n      buffer[i] = (char) (0x41 + i % 26); /* A...Z */\n\n  if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {\n    fprintf(stderr, \"curl_global_init() failed\\n\");\n    return TEST_ERR_MAJOR_BAD;\n  }\n\n  curl = curl_easy_init();\n  if(!curl) {\n    fprintf(stderr, \"curl_easy_init() failed\\n\");\n    res = (CURLcode) TEST_ERR_MAJOR_BAD;\n    goto test_cleanup;\n  }\n\n  /* Build mime structure. */\n  mime = curl_mime_init(curl);\n  if(!mime) {\n    fprintf(stderr, \"curl_mime_init() failed\\n\");\n    res = (CURLcode) TEST_ERR_MAJOR_BAD;\n    goto test_cleanup;\n  }\n  part = curl_mime_addpart(mime);\n  if(!part) {\n    fprintf(stderr, \"curl_mime_addpart() failed\\n\");\n    res = (CURLcode) TEST_ERR_MAJOR_BAD;\n    goto test_cleanup;\n  }\n  res = curl_mime_name(part, \"upfile\");\n  if(res) {\n    fprintf(stderr, \"curl_mime_name() failed\\n\");\n    goto test_cleanup;\n  }\n  res = curl_mime_filename(part, \"myfile.txt\");\n  if(res) {\n    fprintf(stderr, \"curl_mime_filename() failed\\n\");\n    goto test_cleanup;\n  }\n  res = curl_mime_data(part, buffer, sizeof(buffer));\n  if(res) {\n    fprintf(stderr, \"curl_mime_data() failed\\n\");\n    goto test_cleanup;\n  }\n  res = curl_mime_encoder(part, \"binary\");\n  if(res) {\n    fprintf(stderr, \"curl_mime_encoder() failed\\n\");\n    goto test_cleanup;\n  }\n\n  /* First set the URL that is about to receive our mime mail. */\n  test_setopt(curl, CURLOPT_URL, URL);\n\n  /* Post form */\n  test_setopt(curl, CURLOPT_MIMEPOST, mime);\n\n  /* Shorten upload buffer. */\n  test_setopt(curl, CURLOPT_UPLOAD_BUFFERSIZE, 16411L);\n\n  /* get verbose debug output please */\n  test_setopt(curl, CURLOPT_VERBOSE, 1L);\n\n  /* include headers in the output */\n  test_setopt(curl, CURLOPT_HEADER, 1L);\n\n  /* Perform the request, res will get the return code */\n  res = curl_easy_perform(curl);\n\ntest_cleanup:\n\n  /* always cleanup */\n  curl_easy_cleanup(curl);\n\n  /* now cleanup the mime structure */\n  curl_mime_free(mime);\n\n  curl_global_cleanup();\n\n  return res;\n}", "path": "curl/tests/libtest/lib666.c", "commit_date": "2020-11-04 00:00:00", "repo_name": "curl/curl", "stars": 33384, "license": "other", "language": "c", "size": 84463}
{"docstring": "/* read callback function, fread() look alike */\n", "func_signal": "static size_t read_callback(char *ptr, size_t size, size_t nmemb, void *stream)", "code": "{\n  ssize_t retcode;\n  curl_off_t nread;\n\n  int *fdp = (int *)stream;\n  int fd = *fdp;\n\n  retcode = read(fd, ptr, (READ_3RD_ARG)(size * nmemb));\n\n  nread = (curl_off_t)retcode;\n\n  fprintf(stderr, \"*** We read %\" CURL_FORMAT_CURL_OFF_T\n          \" bytes from file\\n\", nread);\n\n  return retcode;\n}", "path": "curl/docs/examples/anyauthput.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "curl/curl", "stars": 33384, "license": "other", "language": "c", "size": 84463}
{"docstring": "/* more than 16K */\n", "func_signal": "int test(char *URL)", "code": "{\n  CURL *curl = NULL;\n  CURLcode res = CURLE_OK;\n  curl_mime *mime = NULL;\n  curl_mimepart *part;\n  struct curl_slist *recipients = NULL;\n\n  /* create a buffer with AAAA...BBBBB...CCCC...etc */\n  int i;\n  int size = (int)sizeof(buffer) / 10;\n\n  for(i = 0; i < size ; i++)\n    memset(&buffer[i * 10], 65 + (i % 26), 10);\n\n  if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {\n    fprintf(stderr, \"curl_global_init() failed\\n\");\n    return TEST_ERR_MAJOR_BAD;\n  }\n\n  curl = curl_easy_init();\n  if(!curl) {\n    fprintf(stderr, \"curl_easy_init() failed\\n\");\n    res = (CURLcode) TEST_ERR_MAJOR_BAD;\n    goto test_cleanup;\n  }\n\n  /* Build mime structure. */\n  mime = curl_mime_init(curl);\n  if(!mime) {\n    fprintf(stderr, \"curl_mime_init() failed\\n\");\n    res = (CURLcode) TEST_ERR_MAJOR_BAD;\n    goto test_cleanup;\n  }\n  part = curl_mime_addpart(mime);\n  if(!part) {\n    fprintf(stderr, \"curl_mime_addpart() failed\\n\");\n    res = (CURLcode) TEST_ERR_MAJOR_BAD;\n    goto test_cleanup;\n  }\n  res = curl_mime_filename(part, \"myfile.jpg\");\n  if(res) {\n    fprintf(stderr, \"curl_mime_filename() failed\\n\");\n    goto test_cleanup;\n  }\n  res = curl_mime_type(part, \"image/jpeg\");\n  if(res) {\n    fprintf(stderr, \"curl_mime_type() failed\\n\");\n    goto test_cleanup;\n  }\n  res = curl_mime_data(part, buffer, sizeof(buffer));\n  if(res) {\n    fprintf(stderr, \"curl_mime_data() failed\\n\");\n    goto test_cleanup;\n  }\n  res = curl_mime_encoder(part, \"base64\");\n  if(res) {\n    fprintf(stderr, \"curl_mime_encoder() failed\\n\");\n    goto test_cleanup;\n  }\n\n  /* Prepare recipients. */\n  recipients = curl_slist_append(NULL, \"someone@example.com\");\n  if(!recipients) {\n    fprintf(stderr, \"curl_slist_append() failed\\n\");\n    goto test_cleanup;\n  }\n\n  /* First set the URL that is about to receive our mime mail. */\n  test_setopt(curl, CURLOPT_URL, URL);\n\n  /* Set sender. */\n  test_setopt(curl, CURLOPT_MAIL_FROM, \"somebody@example.com\");\n\n  /* Set recipients. */\n  test_setopt(curl, CURLOPT_MAIL_RCPT, recipients);\n\n  /* send a multi-part mail */\n  test_setopt(curl, CURLOPT_MIMEPOST, mime);\n\n  /* Shorten upload buffer. */\n  test_setopt(curl, CURLOPT_UPLOAD_BUFFERSIZE, 16411L);\n\n  /* get verbose debug output please */\n  test_setopt(curl, CURLOPT_VERBOSE, 1L);\n\n  /* Perform the request, res will get the return code */\n  res = curl_easy_perform(curl);\n\ntest_cleanup:\n\n  /* always cleanup */\n  curl_easy_cleanup(curl);\n\n  /* now cleanup the mime structure */\n  curl_mime_free(mime);\n\n  /* cleanup the recipients. */\n  curl_slist_free_all(recipients);\n\n  curl_global_cleanup();\n\n  return res;\n}", "path": "curl/tests/libtest/lib652.c", "commit_date": "2020-11-04 00:00:00", "repo_name": "curl/curl", "stars": 33384, "license": "other", "language": "c", "size": 84463}
{"docstring": "/**\n * Invoke curl when a file descriptor is set.\n */\n", "func_signal": "static void checkFdSet(CURLM *curl, struct Sockets *sockets, fd_set *fdset,\n                       int evBitmask, const char *name)", "code": "{\n  int i;\n  for(i = 0; i < sockets->count; ++i) {\n    if(FD_ISSET(sockets->sockets[i], fdset)) {\n      notifyCurl(curl, sockets->sockets[i], evBitmask, name);\n    }\n  }\n}", "path": "curl/tests/libtest/lib582.c", "commit_date": "2020-11-04 00:00:00", "repo_name": "curl/curl", "stars": 33384, "license": "other", "language": "c", "size": 84463}
{"docstring": "/**\n * Callback invoked by curl to poll reading / writing of a socket.\n */\n", "func_signal": "static int curlSocketCallback(CURL *easy, curl_socket_t s, int action,\n                              void *userp, void *socketp)", "code": "{\n  struct ReadWriteSockets *sockets = userp;\n\n  (void)easy; /* unused */\n  (void)socketp; /* unused */\n\n  if(action == CURL_POLL_IN || action == CURL_POLL_INOUT)\n    addFd(&sockets->read, s, \"read\");\n\n  if(action == CURL_POLL_OUT || action == CURL_POLL_INOUT)\n    addFd(&sockets->write, s, \"write\");\n\n  if(action == CURL_POLL_REMOVE) {\n    removeFd(&sockets->read, s, 1);\n    removeFd(&sockets->write, s, 0);\n  }\n\n  return 0;\n}", "path": "curl/tests/libtest/lib582.c", "commit_date": "2020-11-04 00:00:00", "repo_name": "curl/curl", "stars": 33384, "license": "other", "language": "c", "size": 84463}
{"docstring": "/**\n * Update a fd_set with all of the sockets in use.\n */\n", "func_signal": "static void updateFdSet(struct Sockets *sockets, fd_set* fdset,\n                        curl_socket_t *maxFd)", "code": "{\n  int i;\n  for(i = 0; i < sockets->count; ++i) {\n    FD_SET(sockets->sockets[i], fdset);\n    if(*maxFd < sockets->sockets[i] + 1) {\n      *maxFd = sockets->sockets[i] + 1;\n    }\n  }\n}", "path": "curl/tests/libtest/lib582.c", "commit_date": "2020-11-04 00:00:00", "repo_name": "curl/curl", "stars": 33384, "license": "other", "language": "c", "size": 84463}
{"docstring": "/**\n * Callback invoked by curl to set a timeout.\n */\n", "func_signal": "static int curlTimerCallback(CURLM *multi, long timeout_ms, void *userp)", "code": "{\n  struct timeval *timeout = userp;\n\n  (void)multi; /* unused */\n  if(timeout_ms != -1) {\n    *timeout = tutil_tvnow();\n    timeout->tv_usec += timeout_ms * 1000;\n  }\n  else {\n    timeout->tv_sec = -1;\n  }\n  return 0;\n}", "path": "curl/tests/libtest/lib582.c", "commit_date": "2020-11-04 00:00:00", "repo_name": "curl/curl", "stars": 33384, "license": "other", "language": "c", "size": 84463}
{"docstring": "/*\n * Ensure that file descriptors 0, 1 and 2 (stdin, stdout, stderr) are\n * open before starting to run.  Otherwise, the first three network\n * sockets opened by curl could be used for input sources, downloaded data\n * or error logs as they will effectively be stdin, stdout and/or stderr.\n */\n", "func_signal": "static void main_checkfds(void)", "code": "{\n#ifdef HAVE_PIPE\n  int fd[2] = { STDIN_FILENO, STDIN_FILENO };\n  while(fd[0] == STDIN_FILENO ||\n        fd[0] == STDOUT_FILENO ||\n        fd[0] == STDERR_FILENO ||\n        fd[1] == STDIN_FILENO ||\n        fd[1] == STDOUT_FILENO ||\n        fd[1] == STDERR_FILENO)\n    if(pipe(fd) < 0)\n      return;   /* Out of handles. This isn't really a big problem now, but\n                   will be when we try to create a socket later. */\n  close(fd[0]);\n  close(fd[1]);\n#endif\n}", "path": "curl/src/tool_main.c", "commit_date": "2020-11-04 00:00:00", "repo_name": "curl/curl", "stars": 33384, "license": "other", "language": "c", "size": 84463}
{"docstring": "/* for libcurl older than 7.32.0 (CURLOPT_PROGRESSFUNCTION) */\n", "func_signal": "static int older_progress(void *p,\n                          double dltotal, double dlnow,\n                          double ultotal, double ulnow)", "code": "{\n  return xferinfo(p,\n                  (curl_off_t)dltotal,\n                  (curl_off_t)dlnow,\n                  (curl_off_t)ultotal,\n                  (curl_off_t)ulnow);\n}", "path": "curl/docs/examples/progressfunc.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "curl/curl", "stars": 33384, "license": "other", "language": "c", "size": 84463}
{"docstring": "/* Alloc. granule for curl_formadd_ccsid(). */\n", "func_signal": "static void\nmakeOS400IconvCode(char buf[ICONV_ID_SIZE], unsigned int ccsid)", "code": "{\n  /**\n  *** Convert a CCSID to the corresponding IBM iconv_open() character\n  ***  code identifier.\n  ***  This code is specific to the OS400 implementation of the iconv library.\n  ***  CCSID 65535 (no conversion) is replaced by the ASCII CCSID.\n  ***  CCSID 0 is interpreted by the OS400 as the job's CCSID.\n  **/\n\n  ccsid &= 0xFFFF;\n\n  if(ccsid == NOCONV_CCSID)\n    ccsid = ASCII_CCSID;\n\n  memset(buf, 0, ICONV_ID_SIZE);\n  curl_msprintf(buf, \"IBMCCSID%05u0000000\", ccsid);\n}", "path": "curl/packages/OS400/ccsidcurl.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "curl/curl", "stars": 33384, "license": "other", "language": "c", "size": 84463}
{"docstring": "/**\n * Check for curl completion.\n */\n", "func_signal": "static int checkForCompletion(CURLM *curl, int *success)", "code": "{\n  int numMessages;\n  CURLMsg *message;\n  int result = 0;\n  *success = 0;\n  while((message = curl_multi_info_read(curl, &numMessages)) != NULL) {\n    if(message->msg == CURLMSG_DONE) {\n      result = 1;\n      if(message->data.result == CURLE_OK)\n        *success = 1;\n      else\n        *success = 0;\n    }\n    else {\n      fprintf(stderr, \"Got an unexpected message from curl: %i\\n\",\n              (int)message->msg);\n      result = 1;\n      *success = 0;\n    }\n  }\n  return result;\n}", "path": "curl/tests/libtest/lib582.c", "commit_date": "2020-11-04 00:00:00", "repo_name": "curl/curl", "stars": 33384, "license": "other", "language": "c", "size": 84463}
{"docstring": "/* this is how the CURLOPT_XFERINFOFUNCTION callback works */\n", "func_signal": "static int xferinfo(void *p,\n                    curl_off_t dltotal, curl_off_t dlnow,\n                    curl_off_t ultotal, curl_off_t ulnow)", "code": "{\n  struct myprogress *myp = (struct myprogress *)p;\n  CURL *curl = myp->curl;\n  TIMETYPE curtime = 0;\n\n  curl_easy_getinfo(curl, TIMEOPT, &curtime);\n\n  /* under certain circumstances it may be desirable for certain functionality\n     to only run every N seconds, in order to do this the transaction time can\n     be used */\n  if((curtime - myp->lastruntime) >= MINIMAL_PROGRESS_FUNCTIONALITY_INTERVAL) {\n    myp->lastruntime = curtime;\n#ifdef TIME_IN_US\n    fprintf(stderr, \"TOTAL TIME: %\" CURL_FORMAT_CURL_OFF_T \".%06ld\\r\\n\",\n            (curtime / 1000000), (long)(curtime % 1000000));\n#else\n    fprintf(stderr, \"TOTAL TIME: %f \\r\\n\", curtime);\n#endif\n  }\n\n  fprintf(stderr, \"UP: %\" CURL_FORMAT_CURL_OFF_T \" of %\" CURL_FORMAT_CURL_OFF_T\n          \"  DOWN: %\" CURL_FORMAT_CURL_OFF_T \" of %\" CURL_FORMAT_CURL_OFF_T\n          \"\\r\\n\",\n          ulnow, ultotal, dlnow, dltotal);\n\n  if(dlnow > STOP_DOWNLOAD_AFTER_THIS_MANY_BYTES)\n    return 1;\n  return 0;\n}", "path": "curl/docs/examples/progressfunc.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "curl/curl", "stars": 33384, "license": "other", "language": "c", "size": 84463}
{"docstring": "/*\n * This is the main global destructor for the app. Call this after\n * _all_ libcurl usage is done.\n */\n", "func_signal": "static void main_free(struct GlobalConfig *config)", "code": "{\n  /* Cleanup the easy handle */\n  /* Main cleanup */\n  curl_global_cleanup();\n  convert_cleanup();\n  metalink_cleanup();\n#ifdef USE_NSS\n  if(PR_Initialized()) {\n    /* prevent valgrind from reporting still reachable mem from NSRP arenas */\n    PL_ArenaFinish();\n    /* prevent valgrind from reporting possibly lost memory (fd cache, ...) */\n    PR_Cleanup();\n  }\n#endif\n  free_globalconfig(config);\n\n  /* Free the config structures */\n  config_free(config->last);\n  config->first = NULL;\n  config->last = NULL;\n}", "path": "curl/src/tool_main.c", "commit_date": "2020-11-04 00:00:00", "repo_name": "curl/curl", "stars": 33384, "license": "other", "language": "c", "size": 84463}
{"docstring": "/**\n * Add a file descriptor to a sockets array.\n */\n", "func_signal": "static void addFd(struct Sockets *sockets, curl_socket_t fd, const char *what)", "code": "{\n  /**\n   * To ensure we only have each file descriptor once, we remove it then add\n   * it again.\n   */\n  fprintf(stderr, \"Add socket fd %d for %s\\n\", (int) fd, what);\n  removeFd(sockets, fd, 0);\n  /*\n   * Allocate array storage when required.\n   */\n  if(!sockets->sockets) {\n    sockets->sockets = malloc(sizeof(curl_socket_t) * 20U);\n    if(!sockets->sockets)\n      return;\n    sockets->max_count = 20;\n  }\n  else if(sockets->count + 1 > sockets->max_count) {\n    curl_socket_t *oldptr = sockets->sockets;\n    sockets->sockets = realloc(oldptr, sizeof(curl_socket_t) *\n                               (sockets->max_count + 20));\n    if(!sockets->sockets) {\n      /* cleanup in test_cleanup */\n      sockets->sockets = oldptr;\n      return;\n    }\n    sockets->max_count += 20;\n  }\n  /*\n   * Add file descriptor to array.\n   */\n  sockets->sockets[sockets->count] = fd;\n  ++sockets->count;\n}", "path": "curl/tests/libtest/lib582.c", "commit_date": "2020-11-04 00:00:00", "repo_name": "curl/curl", "stars": 33384, "license": "other", "language": "c", "size": 84463}
{"docstring": "/*\n * Simply download a HTTP file.\n */\n", "func_signal": "int main(void)", "code": "{\n  CURL *http_handle;\n  CURLM *multi_handle;\n\n  int still_running = 0; /* keep number of running handles */\n\n  http_handle = curl_easy_init();\n\n  /* set the options (I left out a few, you'll get the point anyway) */\n  curl_easy_setopt(http_handle, CURLOPT_URL, \"https://www.example.com/\");\n\n  curl_easy_setopt(http_handle, CURLOPT_DEBUGFUNCTION, my_trace);\n  curl_easy_setopt(http_handle, CURLOPT_VERBOSE, 1L);\n\n  /* init a multi stack */\n  multi_handle = curl_multi_init();\n\n  /* add the individual transfers */\n  curl_multi_add_handle(multi_handle, http_handle);\n\n  /* we start some action by calling perform right away */\n  curl_multi_perform(multi_handle, &still_running);\n\n  while(still_running) {\n    struct timeval timeout;\n    int rc; /* select() return code */\n    CURLMcode mc; /* curl_multi_fdset() return code */\n\n    fd_set fdread;\n    fd_set fdwrite;\n    fd_set fdexcep;\n    int maxfd = -1;\n\n    long curl_timeo = -1;\n\n    FD_ZERO(&fdread);\n    FD_ZERO(&fdwrite);\n    FD_ZERO(&fdexcep);\n\n    /* set a suitable timeout to play around with */\n    timeout.tv_sec = 1;\n    timeout.tv_usec = 0;\n\n    curl_multi_timeout(multi_handle, &curl_timeo);\n    if(curl_timeo >= 0) {\n      timeout.tv_sec = curl_timeo / 1000;\n      if(timeout.tv_sec > 1)\n        timeout.tv_sec = 1;\n      else\n        timeout.tv_usec = (curl_timeo % 1000) * 1000;\n    }\n\n    /* get file descriptors from the transfers */\n    mc = curl_multi_fdset(multi_handle, &fdread, &fdwrite, &fdexcep, &maxfd);\n\n    if(mc != CURLM_OK) {\n      fprintf(stderr, \"curl_multi_fdset() failed, code %d.\\n\", mc);\n      break;\n    }\n\n    /* On success the value of maxfd is guaranteed to be >= -1. We call\n       select(maxfd + 1, ...); specially in case of (maxfd == -1) there are\n       no fds ready yet so we call select(0, ...) --or Sleep() on Windows--\n       to sleep 100ms, which is the minimum suggested value in the\n       curl_multi_fdset() doc. */\n\n    if(maxfd == -1) {\n#ifdef _WIN32\n      Sleep(100);\n      rc = 0;\n#else\n      /* Portable sleep for platforms other than Windows. */\n      struct timeval wait = { 0, 100 * 1000 }; /* 100ms */\n      rc = select(0, NULL, NULL, NULL, &wait);\n#endif\n    }\n    else {\n      /* Note that on some platforms 'timeout' may be modified by select().\n         If you need access to the original value save a copy beforehand. */\n      rc = select(maxfd + 1, &fdread, &fdwrite, &fdexcep, &timeout);\n    }\n\n    switch(rc) {\n    case -1:\n      /* select error */\n      still_running = 0;\n      printf(\"select() returns error, this is badness\\n\");\n      break;\n    case 0:\n    default:\n      /* timeout or readable/writable sockets */\n      curl_multi_perform(multi_handle, &still_running);\n      break;\n    }\n  }\n\n  curl_multi_cleanup(multi_handle);\n\n  curl_easy_cleanup(http_handle);\n\n  return 0;\n}", "path": "curl/docs/examples/multi-debugcallback.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "curl/curl", "stars": 33384, "license": "other", "language": "c", "size": 84463}
{"docstring": "/*\n * Test GET_PARAMETER: PUT, HEARTBEAT, and POST\n */\n", "func_signal": "int test(char *URL)", "code": "{\n  int res;\n  CURL *curl;\n  int params;\n  FILE *paramsf = NULL;\n  struct_stat file_info;\n  char *stream_uri = NULL;\n  int request = 1;\n  struct curl_slist *custom_headers = NULL;\n\n  if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {\n    fprintf(stderr, \"curl_global_init() failed\\n\");\n    return TEST_ERR_MAJOR_BAD;\n  }\n\n  curl = curl_easy_init();\n  if(!curl) {\n    fprintf(stderr, \"curl_easy_init() failed\\n\");\n    curl_global_cleanup();\n    return TEST_ERR_MAJOR_BAD;\n  }\n\n\n  test_setopt(curl, CURLOPT_HEADERDATA, stdout);\n  test_setopt(curl, CURLOPT_WRITEDATA, stdout);\n  test_setopt(curl, CURLOPT_VERBOSE, 1L);\n\n  test_setopt(curl, CURLOPT_URL, URL);\n\n  /* SETUP */\n  stream_uri = suburl(URL, request++);\n  if(!stream_uri) {\n    res = TEST_ERR_MAJOR_BAD;\n    goto test_cleanup;\n  }\n  test_setopt(curl, CURLOPT_RTSP_STREAM_URI, stream_uri);\n  free(stream_uri);\n  stream_uri = NULL;\n\n  test_setopt(curl, CURLOPT_RTSP_TRANSPORT, \"Planes/Trains/Automobiles\");\n  test_setopt(curl, CURLOPT_RTSP_REQUEST, CURL_RTSPREQ_SETUP);\n  res = curl_easy_perform(curl);\n  if(res)\n    goto test_cleanup;\n\n  stream_uri = suburl(URL, request++);\n  if(!stream_uri) {\n    res = TEST_ERR_MAJOR_BAD;\n    goto test_cleanup;\n  }\n  test_setopt(curl, CURLOPT_RTSP_STREAM_URI, stream_uri);\n  free(stream_uri);\n  stream_uri = NULL;\n\n  /* PUT style GET_PARAMETERS */\n  params = open(\"log/file572.txt\", O_RDONLY);\n  fstat(params, &file_info);\n  close(params);\n\n  paramsf = fopen(\"log/file572.txt\", \"rb\");\n  if(paramsf == NULL) {\n    fprintf(stderr, \"can't open log/file572.txt\\n\");\n    res = TEST_ERR_MAJOR_BAD;\n    goto test_cleanup;\n  }\n  test_setopt(curl, CURLOPT_RTSP_REQUEST, CURL_RTSPREQ_GET_PARAMETER);\n\n  test_setopt(curl, CURLOPT_READDATA, paramsf);\n  test_setopt(curl, CURLOPT_UPLOAD, 1L);\n  test_setopt(curl, CURLOPT_INFILESIZE_LARGE, (curl_off_t) file_info.st_size);\n\n  res = curl_easy_perform(curl);\n  if(res)\n    goto test_cleanup;\n\n  test_setopt(curl, CURLOPT_UPLOAD, 0L);\n  fclose(paramsf);\n  paramsf = NULL;\n\n  /* Heartbeat GET_PARAMETERS */\n  stream_uri = suburl(URL, request++);\n  if(!stream_uri) {\n    res = TEST_ERR_MAJOR_BAD;\n    goto test_cleanup;\n  }\n  test_setopt(curl, CURLOPT_RTSP_STREAM_URI, stream_uri);\n  free(stream_uri);\n  stream_uri = NULL;\n\n  res = curl_easy_perform(curl);\n  if(res)\n    goto test_cleanup;\n\n  /* POST GET_PARAMETERS */\n\n  stream_uri = suburl(URL, request++);\n  if(!stream_uri) {\n    res = TEST_ERR_MAJOR_BAD;\n    goto test_cleanup;\n  }\n  test_setopt(curl, CURLOPT_RTSP_STREAM_URI, stream_uri);\n  free(stream_uri);\n  stream_uri = NULL;\n\n  test_setopt(curl, CURLOPT_RTSP_REQUEST, CURL_RTSPREQ_GET_PARAMETER);\n  test_setopt(curl, CURLOPT_POSTFIELDS, \"packets_received\\njitter\\n\");\n\n  res = curl_easy_perform(curl);\n  if(res)\n    goto test_cleanup;\n\n  test_setopt(curl, CURLOPT_POSTFIELDS, NULL);\n\n  /* Make sure we can do a normal request now */\n  stream_uri = suburl(URL, request++);\n  if(!stream_uri) {\n    res = TEST_ERR_MAJOR_BAD;\n    goto test_cleanup;\n  }\n  test_setopt(curl, CURLOPT_RTSP_STREAM_URI, stream_uri);\n  free(stream_uri);\n  stream_uri = NULL;\n\n  test_setopt(curl, CURLOPT_RTSP_REQUEST, CURL_RTSPREQ_OPTIONS);\n  res = curl_easy_perform(curl);\n\ntest_cleanup:\n\n  if(paramsf)\n    fclose(paramsf);\n\n  free(stream_uri);\n\n  if(custom_headers)\n    curl_slist_free_all(custom_headers);\n\n  curl_easy_cleanup(curl);\n  curl_global_cleanup();\n\n  return res;\n}", "path": "curl/tests/libtest/lib572.c", "commit_date": "2020-11-04 00:00:00", "repo_name": "curl/curl", "stars": 33384, "license": "other", "language": "c", "size": 84463}
{"docstring": "/**\n * Remove a file descriptor from a sockets array.\n */\n", "func_signal": "static void removeFd(struct Sockets *sockets, curl_socket_t fd, int mention)", "code": "{\n  int i;\n\n  if(mention)\n    fprintf(stderr, \"Remove socket fd %d\\n\", (int) fd);\n\n  for(i = 0; i < sockets->count; ++i) {\n    if(sockets->sockets[i] == fd) {\n      if(i < sockets->count - 1)\n        memmove(&sockets->sockets[i], &sockets->sockets[i + 1],\n              sizeof(curl_socket_t) * (sockets->count - (i + 1)));\n      --sockets->count;\n    }\n  }\n}", "path": "curl/tests/libtest/lib582.c", "commit_date": "2020-11-04 00:00:00", "repo_name": "curl/curl", "stars": 33384, "license": "other", "language": "c", "size": 84463}
{"docstring": "/*\n * This is the main global constructor for the app. Call this before\n * _any_ libcurl usage. If this fails, *NO* libcurl functions may be\n * used, or havoc may be the result.\n */\n", "func_signal": "static CURLcode main_init(struct GlobalConfig *config)", "code": "{\n  CURLcode result = CURLE_OK;\n\n#if defined(__DJGPP__) || defined(__GO32__)\n  /* stop stat() wasting time */\n  _djstat_flags |= _STAT_INODE | _STAT_EXEC_MAGIC | _STAT_DIRSIZE;\n#endif\n\n  /* Initialise the global config */\n  config->showerror = -1;             /* Will show errors */\n  config->errors = stderr;            /* Default errors to stderr */\n  config->styled_output = TRUE;       /* enable detection */\n  config->parallel_max = PARALLEL_DEFAULT;\n\n  /* Allocate the initial operate config */\n  config->first = config->last = malloc(sizeof(struct OperationConfig));\n  if(config->first) {\n    /* Perform the libcurl initialization */\n    result = curl_global_init(CURL_GLOBAL_DEFAULT);\n    if(!result) {\n      /* Get information about libcurl */\n      result = get_libcurl_info();\n\n      if(!result) {\n        /* Initialise the config */\n        config_init(config->first);\n        config->first->global = config;\n      }\n      else {\n        errorf(config, \"error retrieving curl library information\\n\");\n        free(config->first);\n      }\n    }\n    else {\n      errorf(config, \"error initializing curl library\\n\");\n      free(config->first);\n    }\n  }\n  else {\n    errorf(config, \"error initializing curl\\n\");\n    result = CURLE_FAILED_INIT;\n  }\n\n  return result;\n}", "path": "curl/src/tool_main.c", "commit_date": "2020-11-04 00:00:00", "repo_name": "curl/curl", "stars": 33384, "license": "other", "language": "c", "size": 84463}
{"docstring": "/// Initializes a Huffman table using canonical Huffman codes\n/// For more explanation on canonical Huffman codes see\n/// http://www.cs.uofs.edu/~mccloske/courses/cmps340/huff_canonical_dec2015.html\n/// Codes within a level are allocated in symbol order (i.e. smaller symbols get\n/// earlier codes)\n", "func_signal": "static void HUF_init_dtable(HUF_dtable *const table, const u8 *const bits,\n                            const int num_symbs)", "code": "{\n    memset(table, 0, sizeof(HUF_dtable));\n    if (num_symbs > HUF_MAX_SYMBS) {\n        ERROR(\"Too many symbols for Huffman\");\n    }\n\n    u8 max_bits = 0;\n    u16 rank_count[HUF_MAX_BITS + 1];\n    memset(rank_count, 0, sizeof(rank_count));\n\n    // Count the number of symbols for each number of bits, and determine the\n    // depth of the tree\n    for (int i = 0; i < num_symbs; i++) {\n        if (bits[i] > HUF_MAX_BITS) {\n            ERROR(\"Huffman table depth too large\");\n        }\n        max_bits = MAX(max_bits, bits[i]);\n        rank_count[bits[i]]++;\n    }\n\n    const size_t table_size = 1 << max_bits;\n    table->max_bits = max_bits;\n    table->symbols = malloc(table_size);\n    table->num_bits = malloc(table_size);\n\n    if (!table->symbols || !table->num_bits) {\n        free(table->symbols);\n        free(table->num_bits);\n        BAD_ALLOC();\n    }\n\n    // \"Symbols are sorted by Weight. Within same Weight, symbols keep natural\n    // order. Symbols with a Weight of zero are removed. Then, starting from\n    // lowest weight, prefix codes are distributed in order.\"\n\n    u32 rank_idx[HUF_MAX_BITS + 1];\n    // Initialize the starting codes for each rank (number of bits)\n    rank_idx[max_bits] = 0;\n    for (int i = max_bits; i >= 1; i--) {\n        rank_idx[i - 1] = rank_idx[i] + rank_count[i] * (1 << (max_bits - i));\n        // The entire range takes the same number of bits so we can memset it\n        memset(&table->num_bits[rank_idx[i]], i, rank_idx[i - 1] - rank_idx[i]);\n    }\n\n    if (rank_idx[0] != table_size) {\n        CORRUPTION();\n    }\n\n    // Allocate codes and fill in the table\n    for (int i = 0; i < num_symbs; i++) {\n        if (bits[i] != 0) {\n            // Allocate a code for this symbol and set its range in the table\n            const u16 code = rank_idx[bits[i]];\n            // Since the code doesn't care about the bottom `max_bits - bits[i]`\n            // bits of state, it gets a range that spans all possible values of\n            // the lower bits\n            const u16 len = 1 << (max_bits - bits[i]);\n            memset(&table->symbols[code], i, len);\n            rank_idx[bits[i]] += len;\n        }\n    }\n}", "path": "zstd/doc/educational_decoder/zstd_decompress.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "facebook/zstd", "stars": 21912, "license": "other", "language": "c", "size": 38327}
{"docstring": "/// If the remaining bits in a byte will be unused, advance to the end of the\n/// byte\n", "func_signal": "static inline void IO_align_stream(istream_t *const in)", "code": "{\n    if (in->bit_offset != 0) {\n        if (in->len == 0) {\n            INP_SIZE();\n        }\n        in->ptr++;\n        in->len--;\n        in->bit_offset = 0;\n    }\n}", "path": "zstd/doc/educational_decoder/zstd_decompress.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "facebook/zstd", "stars": 21912, "license": "other", "language": "c", "size": 38327}
{"docstring": "/// Consumes bits from the input and uses the current state to determine the\n/// next state\n", "func_signal": "static inline void FSE_update_state(const FSE_dtable *const dtable,\n                                    u16 *const state, const u8 *const src,\n                                    i64 *const offset)", "code": "{\n    const u8 bits = dtable->num_bits[*state];\n    const u16 rest = STREAM_read_bits(src, bits, offset);\n    *state = dtable->new_state_base[*state] + rest;\n}", "path": "zstd/doc/educational_decoder/zstd_decompress.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "facebook/zstd", "stars": 21912, "license": "other", "language": "c", "size": 38327}
{"docstring": "/******* SEQUENCE EXECUTION ***************************************************/\n", "func_signal": "static void execute_sequences(frame_context_t *const ctx, ostream_t *const out,\n                              const u8 *const literals,\n                              const size_t literals_len,\n                              const sequence_command_t *const sequences,\n                              const size_t num_sequences)", "code": "{\n    istream_t litstream = IO_make_istream(literals, literals_len);\n\n    u64 *const offset_hist = ctx->previous_offsets;\n    size_t total_output = ctx->current_total_output;\n\n    for (size_t i = 0; i < num_sequences; i++) {\n        const sequence_command_t seq = sequences[i];\n        {\n            const u32 literals_size = copy_literals(seq.literal_length, &litstream, out);\n            total_output += literals_size;\n        }\n\n        size_t const offset = compute_offset(seq, offset_hist);\n\n        size_t const match_length = seq.match_length;\n\n        execute_match_copy(ctx, offset, match_length, total_output, out);\n\n        total_output += match_length;\n    }\n\n    // Copy any leftover literals\n    {\n        size_t len = IO_istream_len(&litstream);\n        copy_literals(len, &litstream, out);\n        total_output += len;\n    }\n\n    ctx->current_total_output = total_output;\n}", "path": "zstd/doc/educational_decoder/zstd_decompress.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "facebook/zstd", "stars": 21912, "license": "other", "language": "c", "size": 38327}
{"docstring": "/******* DICTIONARY PARSING ***************************************************/\n", "func_signal": "dictionary_t* create_dictionary()", "code": "{\n    dictionary_t* const dict = calloc(1, sizeof(dictionary_t));\n    if (!dict) {\n        BAD_ALLOC();\n    }\n    return dict;\n}", "path": "zstd/doc/educational_decoder/zstd_decompress.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "facebook/zstd", "stars": 21912, "license": "other", "language": "c", "size": 38327}
{"docstring": "/******* OUTPUT SIZE COUNTING *************************************************/\n/// Get the decompressed size of an input stream so memory can be allocated in\n/// advance.\n/// This implementation assumes `src` points to a single ZSTD-compressed frame\n", "func_signal": "size_t ZSTD_get_decompressed_size(const void *src, const size_t src_len)", "code": "{\n    istream_t in = IO_make_istream(src, src_len);\n\n    // get decompressed size from ZSTD frame header\n    {\n        const u32 magic_number = (u32)IO_read_bits(&in, 32);\n\n        if (magic_number == ZSTD_MAGIC_NUMBER) {\n            // ZSTD frame\n            frame_header_t header;\n            parse_frame_header(&header, &in);\n\n            if (header.frame_content_size == 0 && !header.single_segment_flag) {\n                // Content size not provided, we can't tell\n                return (size_t)-1;\n            }\n\n            return header.frame_content_size;\n        } else {\n            // not a real frame or skippable frame\n            ERROR(\"ZSTD frame magic number did not match\");\n        }\n    }\n}", "path": "zstd/doc/educational_decoder/zstd_decompress.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "facebook/zstd", "stars": 21912, "license": "other", "language": "c", "size": 38327}
{"docstring": "/* --- test launcher --- */\n", "func_signal": "int main(int argc, const char **argv)", "code": "{\n  size_t numThreads;\n  (void)argc;\n  (void)argv;\n\n  if (POOL_create(0, 1)) {   /* should not be possible */\n    printf(\"FAIL: should not create POOL with 0 threads\\n\");\n    return 1;\n  }\n\n  for (numThreads = 1; numThreads <= 4; ++numThreads) {\n    size_t queueSize;\n    for (queueSize = 0; queueSize <= 2; ++queueSize) {\n      printf(\"queueSize==%u, numThreads=%u \\n\",\n            (unsigned)queueSize, (unsigned)numThreads);\n      if (testOrder(numThreads, queueSize)) {\n        printf(\"FAIL: testOrder\\n\");\n        return 1;\n      }\n      printf(\"SUCCESS: testOrder\\n\");\n      if (testWait(numThreads, queueSize)) {\n        printf(\"FAIL: testWait\\n\");\n        return 1;\n      }\n      printf(\"SUCCESS: testWait\\n\");\n    }\n  }\n\n  if (testThreadReduction()) {\n      printf(\"FAIL: thread reduction not effective \\n\");\n      return 1;\n  } else {\n      printf(\"SUCCESS: thread reduction effective \\n\");\n  }\n\n  if (testAbruptEnding()) {\n      printf(\"FAIL: jobs in queue not completed on early end \\n\");\n      return 1;\n  } else {\n      printf(\"SUCCESS: all jobs in queue completed on early end \\n\");\n  }\n\n  printf(\"PASS: all POOL tests\\n\");\n\n  return 0;\n}", "path": "zstd/tests/poolTests.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "facebook/zstd", "stars": 21912, "license": "other", "language": "c", "size": 38327}
{"docstring": "// ZDEC_NO_DICTIONARY is defined\n", "func_signal": "static void frame_context_apply_dict(frame_context_t *const ctx,\n                                     const dictionary_t *const dict)", "code": "{\n    (void)ctx;\n    if (dict && dict->content) ERROR(\"dictionary not supported\");\n}", "path": "zstd/doc/educational_decoder/zstd_decompress.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "facebook/zstd", "stars": 21912, "license": "other", "language": "c", "size": 38327}
{"docstring": "/// Given a sequence part and table mode, decode the FSE distribution\n/// Errors if the mode is `seq_repeat` without a pre-existing table in `table`\n", "func_signal": "static void decode_seq_table(FSE_dtable *const table, istream_t *const in,\n                             const seq_part_t type, const seq_mode_t mode)", "code": "{\n    // Constant arrays indexed by seq_part_t\n    const i16 *const default_distributions[] = {SEQ_LITERAL_LENGTH_DEFAULT_DIST,\n                                                SEQ_OFFSET_DEFAULT_DIST,\n                                                SEQ_MATCH_LENGTH_DEFAULT_DIST};\n    const size_t default_distribution_lengths[] = {36, 29, 53};\n    const size_t default_distribution_accuracies[] = {6, 5, 6};\n\n    const size_t max_accuracies[] = {9, 8, 9};\n\n    if (mode != seq_repeat) {\n        // Free old one before overwriting\n        FSE_free_dtable(table);\n    }\n\n    switch (mode) {\n    case seq_predefined: {\n        // \"Predefined_Mode : uses a predefined distribution table.\"\n        const i16 *distribution = default_distributions[type];\n        const size_t symbs = default_distribution_lengths[type];\n        const size_t accuracy_log = default_distribution_accuracies[type];\n\n        FSE_init_dtable(table, distribution, symbs, accuracy_log);\n        break;\n    }\n    case seq_rle: {\n        // \"RLE_Mode : it's a single code, repeated Number_of_Sequences times.\"\n        const u8 symb = IO_get_read_ptr(in, 1)[0];\n        FSE_init_dtable_rle(table, symb);\n        break;\n    }\n    case seq_fse: {\n        // \"FSE_Compressed_Mode : standard FSE compression. A distribution table\n        // will be present \"\n        FSE_decode_header(table, in, max_accuracies[type]);\n        break;\n    }\n    case seq_repeat:\n        // \"Repeat_Mode : re-use distribution table from previous compressed\n        // block.\"\n        // Nothing to do here, table will be unchanged\n        if (!table->symbols) {\n            // This mode is invalid if we don't already have a table\n            CORRUPTION();\n        }\n        break;\n    default:\n        // Impossible, as mode is from 0-3\n        IMPOSSIBLE();\n        break;\n    }\n\n}", "path": "zstd/doc/educational_decoder/zstd_decompress.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "facebook/zstd", "stars": 21912, "license": "other", "language": "c", "size": 38327}
{"docstring": "/// Decode an FSE header as defined in the Zstandard format specification and\n/// use the decoded frequencies to initialize a decoding table.\n", "func_signal": "static void FSE_decode_header(FSE_dtable *const dtable, istream_t *const in,\n                                const int max_accuracy_log)", "code": "{\n    // \"An FSE distribution table describes the probabilities of all symbols\n    // from 0 to the last present one (included) on a normalized scale of 1 <<\n    // Accuracy_Log .\n    //\n    // It's a bitstream which is read forward, in little-endian fashion. It's\n    // not necessary to know its exact size, since it will be discovered and\n    // reported by the decoding process.\n    if (max_accuracy_log > FSE_MAX_ACCURACY_LOG) {\n        ERROR(\"FSE accuracy too large\");\n    }\n\n    // The bitstream starts by reporting on which scale it operates.\n    // Accuracy_Log = low4bits + 5. Note that maximum Accuracy_Log for literal\n    // and match lengths is 9, and for offsets is 8. Higher values are\n    // considered errors.\"\n    const int accuracy_log = 5 + IO_read_bits(in, 4);\n    if (accuracy_log > max_accuracy_log) {\n        ERROR(\"FSE accuracy too large\");\n    }\n\n    // \"Then follows each symbol value, from 0 to last present one. The number\n    // of bits used by each field is variable. It depends on :\n    //\n    // Remaining probabilities + 1 : example : Presuming an Accuracy_Log of 8,\n    // and presuming 100 probabilities points have already been distributed, the\n    // decoder may read any value from 0 to 255 - 100 + 1 == 156 (inclusive).\n    // Therefore, it must read log2sup(156) == 8 bits.\n    //\n    // Value decoded : small values use 1 less bit : example : Presuming values\n    // from 0 to 156 (inclusive) are possible, 255-156 = 99 values are remaining\n    // in an 8-bits field. They are used this way : first 99 values (hence from\n    // 0 to 98) use only 7 bits, values from 99 to 156 use 8 bits. \"\n\n    i32 remaining = 1 << accuracy_log;\n    i16 frequencies[FSE_MAX_SYMBS];\n\n    int symb = 0;\n    while (remaining > 0 && symb < FSE_MAX_SYMBS) {\n        // Log of the number of possible values we could read\n        int bits = highest_set_bit(remaining + 1) + 1;\n\n        u16 val = IO_read_bits(in, bits);\n\n        // Try to mask out the lower bits to see if it qualifies for the \"small\n        // value\" threshold\n        const u16 lower_mask = ((u16)1 << (bits - 1)) - 1;\n        const u16 threshold = ((u16)1 << bits) - 1 - (remaining + 1);\n\n        if ((val & lower_mask) < threshold) {\n            IO_rewind_bits(in, 1);\n            val = val & lower_mask;\n        } else if (val > lower_mask) {\n            val = val - threshold;\n        }\n\n        // \"Probability is obtained from Value decoded by following formula :\n        // Proba = value - 1\"\n        const i16 proba = (i16)val - 1;\n\n        // \"It means value 0 becomes negative probability -1. -1 is a special\n        // probability, which means \"less than 1\". Its effect on distribution\n        // table is described in next paragraph. For the purpose of calculating\n        // cumulated distribution, it counts as one.\"\n        remaining -= proba < 0 ? -proba : proba;\n\n        frequencies[symb] = proba;\n        symb++;\n\n        // \"When a symbol has a probability of zero, it is followed by a 2-bits\n        // repeat flag. This repeat flag tells how many probabilities of zeroes\n        // follow the current one. It provides a number ranging from 0 to 3. If\n        // it is a 3, another 2-bits repeat flag follows, and so on.\"\n        if (proba == 0) {\n            // Read the next two bits to see how many more 0s\n            int repeat = IO_read_bits(in, 2);\n\n            while (1) {\n                for (int i = 0; i < repeat && symb < FSE_MAX_SYMBS; i++) {\n                    frequencies[symb++] = 0;\n                }\n                if (repeat == 3) {\n                    repeat = IO_read_bits(in, 2);\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n    IO_align_stream(in);\n\n    // \"When last symbol reaches cumulated total of 1 << Accuracy_Log, decoding\n    // is complete. If the last symbol makes cumulated total go above 1 <<\n    // Accuracy_Log, distribution is considered corrupted.\"\n    if (remaining != 0 || symb >= FSE_MAX_SYMBS) {\n        CORRUPTION();\n    }\n\n    // Initialize the decoding table using the determined weights\n    FSE_init_dtable(dtable, frequencies, symb, accuracy_log);\n}", "path": "zstd/doc/educational_decoder/zstd_decompress.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "facebook/zstd", "stars": 21912, "license": "other", "language": "c", "size": 38327}
{"docstring": "/******* BLOCK DECOMPRESSION **************************************************/\n", "func_signal": "static void decompress_block(frame_context_t *const ctx, ostream_t *const out,\n                             istream_t *const in)", "code": "{\n    // \"A compressed block consists of 2 sections :\n    //\n    // Literals_Section\n    // Sequences_Section\"\n\n\n    // Part 1: decode the literals block\n    u8 *literals = NULL;\n    const size_t literals_size = decode_literals(ctx, in, &literals);\n\n    // Part 2: decode the sequences block\n    sequence_command_t *sequences = NULL;\n    const size_t num_sequences =\n        decode_sequences(ctx, in, &sequences);\n\n    // Part 3: combine literals and sequence commands to generate output\n    execute_sequences(ctx, out, literals, literals_size, sequences,\n                      num_sequences);\n    free(literals);\n    free(sequences);\n}", "path": "zstd/doc/educational_decoder/zstd_decompress.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "facebook/zstd", "stars": 21912, "license": "other", "language": "c", "size": 38327}
{"docstring": "/// Free an allocated dictionary\n", "func_signal": "void free_dictionary(dictionary_t *const dict)", "code": "{\n    HUF_free_dtable(&dict->literals_dtable);\n    FSE_free_dtable(&dict->ll_dtable);\n    FSE_free_dtable(&dict->of_dtable);\n    FSE_free_dtable(&dict->ml_dtable);\n\n    free(dict->content);\n\n    memset(dict, 0, sizeof(dictionary_t));\n\n    free(dict);\n}", "path": "zstd/doc/educational_decoder/zstd_decompress.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "facebook/zstd", "stars": 21912, "license": "other", "language": "c", "size": 38327}
{"docstring": "/// Decode a frame that contains compressed data.  Not all frames do as there\n/// are skippable frames.\n/// See\n/// https://github.com/facebook/zstd/blob/dev/doc/zstd_compression_format.md#general-structure-of-zstandard-frame-format\n", "func_signal": "static void decode_data_frame(ostream_t *const out, istream_t *const in,\n                              const dictionary_t *const dict)", "code": "{\n    frame_context_t ctx;\n\n    // Initialize the context that needs to be carried from block to block\n    init_frame_context(&ctx, in, dict);\n\n    if (ctx.header.frame_content_size != 0 &&\n        ctx.header.frame_content_size > out->len) {\n        OUT_SIZE();\n    }\n\n    decompress_data(&ctx, out, in);\n\n    free_frame_context(&ctx);\n}", "path": "zstd/doc/educational_decoder/zstd_decompress.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "facebook/zstd", "stars": 21912, "license": "other", "language": "c", "size": 38327}
{"docstring": "/* --- test deadlocks --- */\n", "func_signal": "static void waitFn(void *opaque)", "code": "{\n  (void)opaque;\n  UTIL_sleepMilli(1);\n}", "path": "zstd/tests/poolTests.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "facebook/zstd", "stars": 21912, "license": "other", "language": "c", "size": 38327}
{"docstring": "/// Decompress the data from a frame block by block\n", "func_signal": "static void decompress_data(frame_context_t *const ctx, ostream_t *const out,\n                            istream_t *const in)", "code": "{\n    // \"A frame encapsulates one or multiple blocks. Each block can be\n    // compressed or not, and has a guaranteed maximum content size, which\n    // depends on frame parameters. Unlike frames, each block depends on\n    // previous blocks for proper decoding. However, each block can be\n    // decompressed without waiting for its successor, allowing streaming\n    // operations.\"\n    int last_block = 0;\n    do {\n        // \"Last_Block\n        //\n        // The lowest bit signals if this block is the last one. Frame ends\n        // right after this block.\n        //\n        // Block_Type and Block_Size\n        //\n        // The next 2 bits represent the Block_Type, while the remaining 21 bits\n        // represent the Block_Size. Format is little-endian.\"\n        last_block = (int)IO_read_bits(in, 1);\n        const int block_type = (int)IO_read_bits(in, 2);\n        const size_t block_len = IO_read_bits(in, 21);\n\n        switch (block_type) {\n        case 0: {\n            // \"Raw_Block - this is an uncompressed block. Block_Size is the\n            // number of bytes to read and copy.\"\n            const u8 *const read_ptr = IO_get_read_ptr(in, block_len);\n            u8 *const write_ptr = IO_get_write_ptr(out, block_len);\n\n            // Copy the raw data into the output\n            memcpy(write_ptr, read_ptr, block_len);\n\n            ctx->current_total_output += block_len;\n            break;\n        }\n        case 1: {\n            // \"RLE_Block - this is a single byte, repeated N times. In which\n            // case, Block_Size is the size to regenerate, while the\n            // \"compressed\" block is just 1 byte (the byte to repeat).\"\n            const u8 *const read_ptr = IO_get_read_ptr(in, 1);\n            u8 *const write_ptr = IO_get_write_ptr(out, block_len);\n\n            // Copy `block_len` copies of `read_ptr[0]` to the output\n            memset(write_ptr, read_ptr[0], block_len);\n\n            ctx->current_total_output += block_len;\n            break;\n        }\n        case 2: {\n            // \"Compressed_Block - this is a Zstandard compressed block,\n            // detailed in another section of this specification. Block_Size is\n            // the compressed size.\n\n            // Create a sub-stream for the block\n            istream_t block_stream = IO_make_sub_istream(in, block_len);\n            decompress_block(ctx, out, &block_stream);\n            break;\n        }\n        case 3:\n            // \"Reserved - this is not a block. This value cannot be used with\n            // current version of this specification.\"\n            CORRUPTION();\n            break;\n        default:\n            IMPOSSIBLE();\n        }\n    } while (!last_block);\n\n    if (ctx->header.content_checksum_flag) {\n        // This program does not support checking the checksum, so skip over it\n        // if it's present\n        IO_advance_input(in, 4);\n    }\n}", "path": "zstd/doc/educational_decoder/zstd_decompress.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "facebook/zstd", "stars": 21912, "license": "other", "language": "c", "size": 38327}
{"docstring": "/// Returns a pointer where `len` bytes can be read, and advances the internal\n/// state.  The stream must be byte aligned.\n", "func_signal": "static inline const u8 *IO_get_read_ptr(istream_t *const in, size_t len)", "code": "{\n    if (len > in->len) {\n        INP_SIZE();\n    }\n    if (in->bit_offset != 0) {\n        ERROR(\"Attempting to operate on a non-byte aligned stream\");\n    }\n    const u8 *const ptr = in->ptr;\n    in->ptr += len;\n    in->len -= len;\n\n    return ptr;\n}", "path": "zstd/doc/educational_decoder/zstd_decompress.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "facebook/zstd", "stars": 21912, "license": "other", "language": "c", "size": 38327}
{"docstring": "/// Takes the information provided in the header and dictionary, and initializes\n/// the context for this frame\n", "func_signal": "static void init_frame_context(frame_context_t *const context,\n                               istream_t *const in,\n                               const dictionary_t *const dict)", "code": "{\n    // Most fields in context are correct when initialized to 0\n    memset(context, 0, sizeof(frame_context_t));\n\n    // Parse data from the frame header\n    parse_frame_header(&context->header, in);\n\n    // Set up the offset history for the repeat offset commands\n    context->previous_offsets[0] = 1;\n    context->previous_offsets[1] = 4;\n    context->previous_offsets[2] = 8;\n\n    // Apply details from the dict if it exists\n    frame_context_apply_dict(context, dict);\n}", "path": "zstd/doc/educational_decoder/zstd_decompress.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "facebook/zstd", "stars": 21912, "license": "other", "language": "c", "size": 38327}
{"docstring": "// Decode a single sequence and update the state\n", "func_signal": "static sequence_command_t decode_sequence(sequence_states_t *const states,\n                                          const u8 *const src,\n                                          i64 *const offset)", "code": "{\n    // \"Each symbol is a code in its own context, which specifies Baseline and\n    // Number_of_Bits to add. Codes are FSE compressed, and interleaved with raw\n    // additional bits in the same bitstream.\"\n\n    // Decode symbols, but don't update states\n    const u8 of_code = FSE_peek_symbol(&states->of_table, states->of_state);\n    const u8 ll_code = FSE_peek_symbol(&states->ll_table, states->ll_state);\n    const u8 ml_code = FSE_peek_symbol(&states->ml_table, states->ml_state);\n\n    // Offset doesn't need a max value as it's not decoded using a table\n    if (ll_code > SEQ_MAX_CODES[seq_literal_length] ||\n        ml_code > SEQ_MAX_CODES[seq_match_length]) {\n        CORRUPTION();\n    }\n\n    // Read the interleaved bits\n    sequence_command_t seq;\n    // \"Decoding starts by reading the Number_of_Bits required to decode Offset.\n    // It then does the same for Match_Length, and then for Literals_Length.\"\n    seq.offset = ((u32)1 << of_code) + STREAM_read_bits(src, of_code, offset);\n\n    seq.match_length =\n        SEQ_MATCH_LENGTH_BASELINES[ml_code] +\n        STREAM_read_bits(src, SEQ_MATCH_LENGTH_EXTRA_BITS[ml_code], offset);\n\n    seq.literal_length =\n        SEQ_LITERAL_LENGTH_BASELINES[ll_code] +\n        STREAM_read_bits(src, SEQ_LITERAL_LENGTH_EXTRA_BITS[ll_code], offset);\n\n    // \"If it is not the last sequence in the block, the next operation is to\n    // update states. Using the rules pre-calculated in the decoding tables,\n    // Literals_Length_State is updated, followed by Match_Length_State, and\n    // then Offset_State.\"\n    // If the stream is complete don't read bits to update state\n    if (*offset != 0) {\n        FSE_update_state(&states->ll_table, &states->ll_state, src, offset);\n        FSE_update_state(&states->ml_table, &states->ml_state, src, offset);\n        FSE_update_state(&states->of_table, &states->of_state, src, offset);\n    }\n\n    return seq;\n}", "path": "zstd/doc/educational_decoder/zstd_decompress.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "facebook/zstd", "stars": 21912, "license": "other", "language": "c", "size": 38327}
{"docstring": "// Decode the Huffman table description\n", "func_signal": "static void decode_huf_table(HUF_dtable *const dtable, istream_t *const in)", "code": "{\n    // \"All literal values from zero (included) to last present one (excluded)\n    // are represented by Weight with values from 0 to Max_Number_of_Bits.\"\n\n    // \"This is a single byte value (0-255), which describes how to decode the list of weights.\"\n    const u8 header = IO_read_bits(in, 8);\n\n    u8 weights[HUF_MAX_SYMBS];\n    memset(weights, 0, sizeof(weights));\n\n    int num_symbs;\n\n    if (header >= 128) {\n        // \"This is a direct representation, where each Weight is written\n        // directly as a 4 bits field (0-15). The full representation occupies\n        // ((Number_of_Symbols+1)/2) bytes, meaning it uses a last full byte\n        // even if Number_of_Symbols is odd. Number_of_Symbols = headerByte -\n        // 127\"\n        num_symbs = header - 127;\n        const size_t bytes = (num_symbs + 1) / 2;\n\n        const u8 *const weight_src = IO_get_read_ptr(in, bytes);\n\n        for (int i = 0; i < num_symbs; i++) {\n            // \"They are encoded forward, 2\n            // weights to a byte with the first weight taking the top four bits\n            // and the second taking the bottom four (e.g. the following\n            // operations could be used to read the weights: Weight[0] =\n            // (Byte[0] >> 4), Weight[1] = (Byte[0] & 0xf), etc.).\"\n            if (i % 2 == 0) {\n                weights[i] = weight_src[i / 2] >> 4;\n            } else {\n                weights[i] = weight_src[i / 2] & 0xf;\n            }\n        }\n    } else {\n        // The weights are FSE encoded, decode them before we can construct the\n        // table\n        istream_t fse_stream = IO_make_sub_istream(in, header);\n        ostream_t weight_stream = IO_make_ostream(weights, HUF_MAX_SYMBS);\n        fse_decode_hufweights(&weight_stream, &fse_stream, &num_symbs);\n    }\n\n    // Construct the table using the decoded weights\n    HUF_init_dtable_usingweights(dtable, weights, num_symbs);\n}", "path": "zstd/doc/educational_decoder/zstd_decompress.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "facebook/zstd", "stars": 21912, "license": "other", "language": "c", "size": 38327}
{"docstring": "/// Reads `num` bits from a bitstream, and updates the internal offset\n", "func_signal": "static inline u64 IO_read_bits(istream_t *const in, const int num_bits)", "code": "{\n    if (num_bits > 64 || num_bits <= 0) {\n        ERROR(\"Attempt to read an invalid number of bits\");\n    }\n\n    const size_t bytes = (num_bits + in->bit_offset + 7) / 8;\n    const size_t full_bytes = (num_bits + in->bit_offset) / 8;\n    if (bytes > in->len) {\n        INP_SIZE();\n    }\n\n    const u64 result = read_bits_LE(in->ptr, num_bits, in->bit_offset);\n\n    in->bit_offset = (num_bits + in->bit_offset) % 8;\n    in->ptr += full_bytes;\n    in->len -= full_bytes;\n\n    return result;\n}", "path": "zstd/doc/educational_decoder/zstd_decompress.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "facebook/zstd", "stars": 21912, "license": "other", "language": "c", "size": 38327}
{"docstring": "/* produce a md4 message digest from data of length n bytes */\n", "func_signal": "void mdfour(unsigned char *out, unsigned char *in, int32_t n)", "code": "{\n  unsigned char buf[128];\n  uint32 M[16];\n  uint32 b = n * 8;\n  int32_t i;\n\n  A = 0x67452301;\n  B = 0xefcdab89;\n  C = 0x98badcfe;\n  D = 0x10325476;\n\n  while (n > 64) {\n    copy64(M, in);\n    mdfour64(M);\n    in += 64;\n    n -= 64;\n  }\n\n  for (i = 0; i < 128; i++)\n    buf[i] = 0;\n  memcpy(buf, in, n);\n  buf[n] = 0x80;\n\n  if (n <= 55) {\n    copy4(buf + 56, b);\n    copy64(M, buf);\n    mdfour64(M);\n  } else {\n    copy4(buf + 120, b);\n    copy64(M, buf);\n    mdfour64(M);\n    copy64(M, buf + 64);\n    mdfour64(M);\n  }\n\n  for (i = 0; i < 128; i++)\n    buf[i] = 0;\n  copy64(M, buf);\n\n  copy4(out, A);\n  copy4(out + 4, B);\n  copy4(out + 8, C);\n  copy4(out + 12, D);\n\n  A = B = C = D = 0;\n}", "path": "thc-hydra/ntlm.c", "commit_date": "2020-02-01 00:00:00", "repo_name": "vanhauser-thc/thc-hydra", "stars": 8834, "license": "agpl-3.0", "language": "c", "size": 3303}
{"docstring": "/* Does the des encryption from the FIRST 8 BYTES of the NT or LM MD4 hash. */\n", "func_signal": "void NTLMSSPOWFencrypt(uchar passwd[8], uchar *ntlmchalresp, uchar p24[24])", "code": "{\n  uchar p21[21];\n\n  memset(p21, '\\0', 21);\n  memcpy(p21, passwd, 8);\n  memset(p21 + 8, 0xbd, 8);\n\n  E_P24(p21, ntlmchalresp, p24);\n#ifdef DEBUG_PASSWORD\n  DEBUG(100, (\"NTLMSSPOWFencrypt: p21, c8, p24\\n\"));\n  dump_data(100, (char *)p21, 21);\n  dump_data(100, (char *)ntlmchalresp, 8);\n  dump_data(100, (char *)p24, 24);\n#endif\n}", "path": "thc-hydra/ntlm.c", "commit_date": "2020-02-01 00:00:00", "repo_name": "vanhauser-thc/thc-hydra", "stars": 8834, "license": "agpl-3.0", "language": "c", "size": 3303}
{"docstring": "/****************************************************************************\n Like strncpy but always null terminates. Make sure there is room!\n The variable n should always be one less than the available size.\n****************************************************************************/\n", "func_signal": "char *StrnCpy(char *dest, const char *src, size_t n)", "code": "{\n  char *d = dest;\n\n  if (!dest)\n    return (NULL);\n  if (!src) {\n    *dest = 0;\n    return (dest);\n  }\n  while (n-- && (*d++ = *src++))\n    ;\n  *d = 0;\n  return (dest);\n}", "path": "thc-hydra/ntlm.c", "commit_date": "2020-02-01 00:00:00", "repo_name": "vanhauser-thc/thc-hydra", "stars": 8834, "license": "agpl-3.0", "language": "c", "size": 3303}
{"docstring": "/*\n * Concat all the headers in the list in a single string.\n * Leave the list itself intact: do not clean it here.\n */\n", "func_signal": "char *stringify_headers(ptr_header_node *ptr_head)", "code": "{\n  char *headers_str = NULL;\n  ptr_header_node cur_ptr = *ptr_head;\n  int32_t ttl_size = 0;\n\n  for (; cur_ptr; cur_ptr = cur_ptr->next)\n    ttl_size += strlen(cur_ptr->header) + strlen(cur_ptr->value) + 4;\n\n  headers_str = (char *)malloc(ttl_size + 1);\n\n  if (headers_str) {\n    memset(headers_str, 0, ttl_size + 1);\n    for (cur_ptr = *ptr_head; cur_ptr; cur_ptr = cur_ptr->next) {\n      strcat(headers_str, cur_ptr->header);\n      strcat(headers_str, \": \");\n      strcat(headers_str, cur_ptr->value);\n      strcat(headers_str, \"\\r\\n\");\n    }\n  }\n\n  return headers_str;\n}", "path": "thc-hydra/hydra-http-form.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "vanhauser-thc/thc-hydra", "stars": 8834, "license": "agpl-3.0", "language": "c", "size": 3303}
{"docstring": "/* Does the des encryption from the NT or LM MD4 hash. */\n", "func_signal": "void SMBOWFencrypt(uchar passwd[16], uchar *c8, uchar p24[24])", "code": "{\n  uchar p21[21];\n\n  memset(p21, '\\0', 21);\n\n  memcpy(p21, passwd, 16);\n  E_P24(p21, c8, p24);\n}", "path": "thc-hydra/ntlm.c", "commit_date": "2020-02-01 00:00:00", "repo_name": "vanhauser-thc/thc-hydra", "stars": 8834, "license": "agpl-3.0", "language": "c", "size": 3303}
{"docstring": "/*\n * Convert a string into an NT UNICODE string.\n * Note that regardless of processor type\n * this must be in intel (little-endian)\n * format.\n */\n", "func_signal": "static int32_t _my_mbstowcs(int16 *dst, uchar *src, int32_t len)", "code": "{\n  int32_t i;\n  int16 val;\n\n  for (i = 0; i < len; i++) {\n    val = *src;\n    SSVAL(dst, 0, val);\n    dst++;\n    src++;\n    if (val == 0)\n      break;\n  }\n  return i;\n}", "path": "thc-hydra/ntlm.c", "commit_date": "2020-02-01 00:00:00", "repo_name": "vanhauser-thc/thc-hydra", "stars": 8834, "license": "agpl-3.0", "language": "c", "size": 3303}
{"docstring": "/*\n * Replace the value of the default header named 'hdrname'.\n */\n", "func_signal": "void hdrrepv(ptr_header_node *ptr_head, char *hdrname, char *new_value)", "code": "{\n  ptr_header_node cur_ptr = NULL;\n\n  for (cur_ptr = *ptr_head; cur_ptr; cur_ptr = cur_ptr->next) {\n    if ((cur_ptr->type == HEADER_TYPE_DEFAULT) && strcmp(cur_ptr->header, hdrname) == 0) {\n      cur_ptr->value = (char *)realloc(cur_ptr->value, strlen(new_value) + 1);\n      if (cur_ptr->value)\n        strcpy(cur_ptr->value, new_value);\n      else {\n        hydra_report(stderr, \"[ERROR] Out of memory (hdrrepv %lu)\\n\", strlen(new_value) + 1);\n        hydra_child_exit(0);\n      }\n    }\n  }\n}", "path": "thc-hydra/hydra-http-form.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "vanhauser-thc/thc-hydra", "stars": 8834, "license": "agpl-3.0", "language": "c", "size": 3303}
{"docstring": "/*\n * Creates the MD4 Hash of the users password in NT UNICODE.\n */\n", "func_signal": "void E_md4hash(uchar *passwd, uchar *p16)", "code": "{\n  int32_t len;\n  int16 wpwd[129];\n\n  /* Password cannot be longer than 128 characters */\n  len = strlen((char *)passwd);\n  if (len > 128)\n    len = 128;\n  /* Password must be converted to NT unicode */\n  _my_mbstowcs(wpwd, passwd, len);\n  wpwd[len] = 0; /* Ensure string is null terminated */\n  /* Calculate length in bytes */\n  len = _my_wcslen(wpwd) * sizeof(int16);\n\n  mdfour(p16, (unsigned char *)wpwd, len);\n}", "path": "thc-hydra/ntlm.c", "commit_date": "2020-02-01 00:00:00", "repo_name": "vanhauser-thc/thc-hydra", "stars": 8834, "license": "agpl-3.0", "language": "c", "size": 3303}
{"docstring": "/* Does both the NT and LM owfs of a user's password */\n", "func_signal": "void nt_lm_owf_gen(char *pwd, uchar nt_p16[16], uchar p16[16])", "code": "{\n  char passwd[130];\n\n  memset(passwd, '\\0', 130);\n  safe_strcpy(passwd, pwd, sizeof(passwd) - 1);\n\n  /* Calculate the MD4 hash (NT compatible) of the password */\n  memset(nt_p16, '\\0', 16);\n  E_md4hash((uchar *)passwd, nt_p16);\n\n#ifdef DEBUG_PASSWORD\n  DEBUG(100, (\"nt_lm_owf_gen: pwd, nt#\\n\"));\n  dump_data(120, passwd, strlen(passwd));\n  dump_data(100, (char *)nt_p16, 16);\n#endif\n\n  /* Mangle the passwords into Lanman format */\n  passwd[14] = '\\0';\n  strupper(passwd);\n\n  /* Calculate the SMB (lanman) hash functions of the password */\n\n  memset(p16, '\\0', 16);\n  E_P16((uchar *)passwd, (uchar *)p16);\n\n#ifdef DEBUG_PASSWORD\n  DEBUG(100, (\"nt_lm_owf_gen: pwd, lm#\\n\"));\n  dump_data(120, passwd, strlen(passwd));\n  dump_data(100, (char *)p16, 16);\n#endif\n  /* clear out local copy of user's password (just being paranoid). */\n  memset(passwd, '\\0', sizeof(passwd));\n}", "path": "thc-hydra/ntlm.c", "commit_date": "2020-02-01 00:00:00", "repo_name": "vanhauser-thc/thc-hydra", "stars": 8834, "license": "agpl-3.0", "language": "c", "size": 3303}
{"docstring": "/* Written by Kaveh R. Ghazi <ghazi@caip.rutgers.edu> */\n", "func_signal": "char *strndup(const char *s, size_t n)", "code": "{\n  char *result;\n  size_t len = strlen(s);\n\n  if (n < len)\n    len = n;\n\n  result = (char *)malloc(len + 1);\n  if (!result)\n    return 0;\n\n  memcpy(result, s, len);\n  result[len] = '\\0';\n  return (result);\n}", "path": "thc-hydra/hydra-http-form.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "vanhauser-thc/thc-hydra", "stars": 8834, "license": "agpl-3.0", "language": "c", "size": 3303}
{"docstring": "/*\n * Cookie list layout:\n * \t+----------+     +--------+     +------+\n * \t| ptr_head | --> | next   | --> | NULL |\n * \t+----------+     | header |     +------+\n * \t                 | value  |\n * \t                 +--------+\n * Returns 1 if success, or 0 otherwise.\n */\n", "func_signal": "int32_t add_or_update_cookie(ptr_cookie_node *ptr_cookie, char *cookie_expr)", "code": "{\n  ptr_cookie_node cur_ptr = NULL;\n  char *cookie_name = NULL, *cookie_value = strstr(cookie_expr, \"=\");\n\n  if (cookie_value) {\n    cookie_name = strndup(cookie_expr, cookie_value - cookie_expr);\n    cookie_value = strdup(cookie_value + 1);\n\n    // we've got the cookie's name and value, now it's time to insert or update\n    // the list\n    if (*ptr_cookie == NULL) {\n      // no cookies\n      append_cookie(cookie_name, cookie_value, ptr_cookie);\n    } else {\n      for (cur_ptr = *ptr_cookie; cur_ptr; cur_ptr = cur_ptr->next) {\n        if (strcmp(cur_ptr->name, cookie_name) == 0) {\n          free(cur_ptr->value); // free old value\n          free(cookie_name);    // we already have it\n          cur_ptr->value = cookie_value;\n          break;\n        }\n        if (cur_ptr->next == NULL) {\n          append_cookie(cookie_name, cookie_value, &cur_ptr);\n          break;\n        }\n      }\n    }\n  } else\n    return 0;\n  return 1;\n}", "path": "thc-hydra/hydra-http-form.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "vanhauser-thc/thc-hydra", "stars": 8834, "license": "agpl-3.0", "language": "c", "size": 3303}
{"docstring": "/* this applies md4 to 64 byte chunks */\n", "func_signal": "static void mdfour64(uint32 *M)", "code": "{\n  int32_t j;\n  uint32 AA, BB, CC, DD;\n  uint32 X[16];\n\n  for (j = 0; j < 16; j++)\n    X[j] = M[j];\n\n  AA = A;\n  BB = B;\n  CC = C;\n  DD = D;\n\n  ROUND1(A, B, C, D, 0, 3);\n  ROUND1(D, A, B, C, 1, 7);\n  ROUND1(C, D, A, B, 2, 11);\n  ROUND1(B, C, D, A, 3, 19);\n  ROUND1(A, B, C, D, 4, 3);\n  ROUND1(D, A, B, C, 5, 7);\n  ROUND1(C, D, A, B, 6, 11);\n  ROUND1(B, C, D, A, 7, 19);\n  ROUND1(A, B, C, D, 8, 3);\n  ROUND1(D, A, B, C, 9, 7);\n  ROUND1(C, D, A, B, 10, 11);\n  ROUND1(B, C, D, A, 11, 19);\n  ROUND1(A, B, C, D, 12, 3);\n  ROUND1(D, A, B, C, 13, 7);\n  ROUND1(C, D, A, B, 14, 11);\n  ROUND1(B, C, D, A, 15, 19);\n\n  ROUND2(A, B, C, D, 0, 3);\n  ROUND2(D, A, B, C, 4, 5);\n  ROUND2(C, D, A, B, 8, 9);\n  ROUND2(B, C, D, A, 12, 13);\n  ROUND2(A, B, C, D, 1, 3);\n  ROUND2(D, A, B, C, 5, 5);\n  ROUND2(C, D, A, B, 9, 9);\n  ROUND2(B, C, D, A, 13, 13);\n  ROUND2(A, B, C, D, 2, 3);\n  ROUND2(D, A, B, C, 6, 5);\n  ROUND2(C, D, A, B, 10, 9);\n  ROUND2(B, C, D, A, 14, 13);\n  ROUND2(A, B, C, D, 3, 3);\n  ROUND2(D, A, B, C, 7, 5);\n  ROUND2(C, D, A, B, 11, 9);\n  ROUND2(B, C, D, A, 15, 13);\n\n  ROUND3(A, B, C, D, 0, 3);\n  ROUND3(D, A, B, C, 8, 9);\n  ROUND3(C, D, A, B, 4, 11);\n  ROUND3(B, C, D, A, 12, 15);\n  ROUND3(A, B, C, D, 2, 3);\n  ROUND3(D, A, B, C, 10, 9);\n  ROUND3(C, D, A, B, 6, 11);\n  ROUND3(B, C, D, A, 14, 15);\n  ROUND3(A, B, C, D, 1, 3);\n  ROUND3(D, A, B, C, 9, 9);\n  ROUND3(C, D, A, B, 5, 11);\n  ROUND3(B, C, D, A, 13, 15);\n  ROUND3(A, B, C, D, 3, 3);\n  ROUND3(D, A, B, C, 11, 9);\n  ROUND3(C, D, A, B, 7, 11);\n  ROUND3(B, C, D, A, 15, 15);\n\n  A += AA;\n  B += BB;\n  C += CC;\n  D += DD;\n\n  A &= 0xFFFFFFFF;\n  B &= 0xFFFFFFFF;\n  C &= 0xFFFFFFFF;\n  D &= 0xFFFFFFFF;\n\n  for (j = 0; j < 16; j++)\n    X[j] = 0;\n}", "path": "thc-hydra/ntlm.c", "commit_date": "2020-02-01 00:00:00", "repo_name": "vanhauser-thc/thc-hydra", "stars": 8834, "license": "agpl-3.0", "language": "c", "size": 3303}
{"docstring": "/* Does the NT MD4 hash then des encryption. */\n", "func_signal": "void SMBNTencrypt(uchar *passwd, uchar *c8, uchar *p24)", "code": "{\n  uchar p21[21];\n\n  memset(p21, '\\0', 21);\n\n  E_md4hash(passwd, p21);\n  SMBOWFencrypt(p21, c8, p24);\n\n#ifdef DEBUG_PASSWORD\n  DEBUG(100, (\"SMBNTencrypt: nt#, challenge, response\\n\"));\n  dump_data(100, (char *)p21, 16);\n  dump_data(100, (char *)c8, 8);\n  dump_data(100, (char *)p24, 24);\n#endif\n}", "path": "thc-hydra/ntlm.c", "commit_date": "2020-02-01 00:00:00", "repo_name": "vanhauser-thc/thc-hydra", "stars": 8834, "license": "agpl-3.0", "language": "c", "size": 3303}
{"docstring": "/*\n * List layout:\n * \t+----------+     +--------+     +--------+     +--------+\n * \t| ptr_head | --> |  next  | --> |  next  | --> |  NULL  |\n * \t|          |     | header |     | header |     |  NULL  |\n * \t|          |     | value  |     |  value |     |  NULL  |\n * \t+----------+     +--------+     +--------+     +--------+\n *\n * \tReturns 1 if success, or 0 otherwise (out of memory).\n */\n", "func_signal": "int32_t add_header(ptr_header_node *ptr_head, char *header, char *value, char type)", "code": "{\n  ptr_header_node cur_ptr = NULL;\n  ptr_header_node existing_hdr, new_ptr;\n\n  // get to the last header\n  for (cur_ptr = *ptr_head; cur_ptr && cur_ptr->next; cur_ptr = cur_ptr->next)\n    ;\n\n  char *new_header = strdup(header);\n  char *new_value = strdup(value);\n\n  if (new_header && new_value) {\n    if ((type == HEADER_TYPE_USERHEADER) || (type == HEADER_TYPE_DEFAULT && !header_exists(ptr_head, new_header, HEADER_TYPE_USERHEADER_REPL)) || (type == HEADER_TYPE_USERHEADER_REPL && !header_exists(ptr_head, new_header, HEADER_TYPE_DEFAULT)) || (type == HEADER_TYPE_DEFAULT_REPL && !header_exists(ptr_head, new_header, HEADER_TYPE_DEFAULT))) {\n      /*\n       * We are in one of the following scenarios:\n       *      1. A default header with no user-supplied headers that replace it.\n       *      2. A user-supplied header that must be appended (option 'h').\n       *      3. A user-supplied header that must replace a default header\n       * (option 'h'), but no default headers exist with that name.\n       *\n       * In either case we just add the header to the list.\n       */\n      new_ptr = (ptr_header_node)malloc(sizeof(t_header_node));\n      if (!new_ptr) {\n        free(new_header);\n        free(new_value);\n        return 0;\n      }\n      new_ptr->header = new_header;\n      new_ptr->value = new_value;\n      new_ptr->type = type;\n      new_ptr->next = NULL;\n\n      if (cur_ptr)\n        cur_ptr->next = new_ptr;\n      else {\n        // head is NULL, so the list is empty\n        *ptr_head = new_ptr;\n      }\n    } else if ((type == HEADER_TYPE_DEFAULT_REPL || type == HEADER_TYPE_USERHEADER_REPL) && (existing_hdr = header_exists(ptr_head, new_header, HEADER_TYPE_DEFAULT)) != NULL) {\n      // It's a user-supplied header that must replace a default one\n      // Replace the default header's value with this new value\n      free(existing_hdr->value); // free old value\n      existing_hdr->value = new_value;\n      existing_hdr->type = type;\n      free(new_header); // we dont need this one anymore\n    }\n  } else {\n    // we're out of memory, so forcefully end\n    free(new_header);\n    free(new_value);\n    return 0;\n  }\n\n  return 1;\n}", "path": "thc-hydra/hydra-http-form.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "vanhauser-thc/thc-hydra", "stars": 8834, "license": "agpl-3.0", "language": "c", "size": 3303}
{"docstring": "/*\n * Returns 1 if specified header exists, or 0 otherwise.\n */\n", "func_signal": "ptr_header_node header_exists(ptr_header_node *ptr_head, char *header_name, char type)", "code": "{\n  ptr_header_node cur_ptr = *ptr_head, found_header = NULL;\n\n  for (cur_ptr = *ptr_head; cur_ptr && !found_header; cur_ptr = cur_ptr->next)\n    if (cur_ptr->header && strcmp(cur_ptr->header, header_name) == 0 && cur_ptr->type == type)\n      found_header = cur_ptr;\n\n  return found_header;\n}", "path": "thc-hydra/hydra-http-form.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "vanhauser-thc/thc-hydra", "stars": 8834, "license": "agpl-3.0", "language": "c", "size": 3303}
{"docstring": "/*\n This implements the X/Open SMB password encryption\n It takes a password, a 8 byte \"crypt key\" and puts 24 bytes of\n encrypted password into p24\n */\n", "func_signal": "void SMBencrypt(uchar *passwd, uchar *c8, uchar *p24)", "code": "{\n  uchar p14[15], p21[21];\n\n  memset(p21, '\\0', 21);\n  memset(p14, '\\0', 14);\n  StrnCpy((char *)p14, (char *)passwd, 14);\n\n  strupper((char *)p14);\n  E_P16(p14, p21);\n\n  SMBOWFencrypt(p21, c8, p24);\n\n#ifdef DEBUG_PASSWORD\n  DEBUG(100, (\"SMBencrypt: lm#, challenge, response\\n\"));\n  dump_data(100, (char *)p21, 16);\n  dump_data(100, (char *)c8, 8);\n  dump_data(100, (char *)p24, 24);\n#endif\n}", "path": "thc-hydra/ntlm.c", "commit_date": "2020-02-01 00:00:00", "repo_name": "vanhauser-thc/thc-hydra", "stars": 8834, "license": "agpl-3.0", "language": "c", "size": 3303}
{"docstring": "/*\n * Replace in all headers' values every occurrence of oldvalue by newvalue.\n * Only user-defined headers are considered.\n */\n", "func_signal": "void hdrrep(ptr_header_node *ptr_head, char *oldvalue, char *newvalue)", "code": "{\n  ptr_header_node cur_ptr = NULL;\n\n  for (cur_ptr = *ptr_head; cur_ptr; cur_ptr = cur_ptr->next) {\n    if ((cur_ptr->type == HEADER_TYPE_USERHEADER || cur_ptr->type == HEADER_TYPE_USERHEADER_REPL) && strstr(cur_ptr->value, oldvalue)) {\n      cur_ptr->value = (char *)realloc(cur_ptr->value, strlen(newvalue) + 1);\n      if (cur_ptr->value)\n        strcpy(cur_ptr->value, newvalue);\n      else {\n        hydra_report(stderr, \"[ERROR] Out of memory (hddrep).\\n\");\n        hydra_child_exit(0);\n      }\n    }\n  }\n}", "path": "thc-hydra/hydra-http-form.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "vanhauser-thc/thc-hydra", "stars": 8834, "license": "agpl-3.0", "language": "c", "size": 3303}
{"docstring": "// uncomment line below to see more trace stack\n//#define NCP_DEBUG\n", "func_signal": "int32_t start_ncp(int32_t s, char *ip, int32_t port, unsigned char options, char *miscptr, FILE *fp)", "code": "{\n  char *login;\n  char *pass;\n  char context[256];\n  uint32_t ncp_lib_error_code;\n  char *empty = \"\";\n  int32_t object_type = NCP_BINDERY_USER;\n\n  _NCP_DATA *session;\n\n  session = malloc(sizeof(_NCP_DATA));\n  memset(session, 0, sizeof(_NCP_DATA));\n  login = empty;\n  pass = empty;\n\n  if (strlen(login = hydra_get_next_login()) == 0) {\n    login = empty;\n  } else {\n    if (miscptr) {\n      if (strlen(miscptr) + strlen(login) > sizeof(context)) {\n        free(session);\n        return 4;\n      }\n      memset(context, 0, sizeof(context));\n      strncpy(context, login, sizeof(context) - 2);\n      context[sizeof(context) - 2] = 0;\n      strncpy(context + strlen(login), miscptr, sizeof(context) - strlen(login) - 1);\n      context[sizeof(context) - 1] = 0;\n      login = context;\n    }\n  }\n\n  // login and password are case insensitive\n  // str_upper(login);\n\n  if (strlen(pass = hydra_get_next_password()) == 0)\n    pass = empty;\n\n  ncp_lib_error_code = ncp_find_conn_spec3(hydra_address2string(ip), login, \"\", 1, getuid(), 0, &session->spec);\n  if (ncp_lib_error_code) {\n    free(session);\n    return 1;\n  }\n\n  ncp_lib_error_code = NWCCOpenConnByName(NULL, session->spec.server, NWCC_NAME_FORMAT_BIND, NWCC_OPEN_NEW_CONN, NWCC_RESERVED, &session->conn);\n  if (ncp_lib_error_code) {\n    free(session);\n    return 1;\n  }\n\n  memset(session->spec.password, 0, sizeof(session->spec.password));\n  memcpy(session->spec.password, pass, strlen(pass) + 1);\n  // str_upper(session->spec.password);\n\n  ncp_lib_error_code = ncp_login_conn(session->conn, session->spec.user, object_type, session->spec.password);\n  switch (ncp_lib_error_code & 0x0000FFFF) {\n  case 0x0000: /* Success */\n#ifdef NCP_DEBUG\n    printf(\"Connection success (%s / %s). Error code: %X\\n\", login, pass, ncp_lib_error_code);\n#endif\n    ncp_close(session->conn);\n    hydra_report_found_host(port, ip, \"ncp\", fp); // ok\n    hydra_completed_pair_found();\n    if (memcmp(hydra_get_next_pair(), &HYDRA_EXIT, sizeof(HYDRA_EXIT)) == 0)\n      return 3; // exit\n    free(session);\n    return 2; // next\n    break;\n  case 0x89DE: /* PASSWORD INVALID */\n  case 0x89F0: /* BIND WILDCARD INVALID */\n  case 0x89FF: /* NO OBJ OR BAD PASSWORD */\n  case 0xFD63: /* FAILED_AUTHENTICATION */\n  case 0xFDA7: /* NO_SUCH_ENTRY */\n#ifdef NCP_DEBUG\n    printf(\"Incorrect password (%s / %s). Error code: %X\\n\", login, pass, ncp_lib_error_code);\n#endif\n    ncp_close(session->conn);\n    hydra_completed_pair();\n    if (memcmp(hydra_get_next_pair(), &HYDRA_EXIT, sizeof(HYDRA_EXIT)) == 0) {\n      free(session);\n      return 2; // next\n    }\n    break;\n  default:\n#ifdef NCP_DEBUG\n    printf(\"Failed to open connection. Error code: %X\\n\", ncp_lib_error_code);\n#endif\n    if (session->conn != NULL)\n      ncp_close(session->conn);\n    break;\n  }\n  free(session);\n  return 1; // reconnect\n}", "path": "thc-hydra/hydra-ncp.c", "commit_date": "2020-02-01 00:00:00", "repo_name": "vanhauser-thc/thc-hydra", "stars": 8834, "license": "agpl-3.0", "language": "c", "size": 3303}
{"docstring": "/* Client program */\n", "func_signal": "int32_t start_rdp(char *ip, int32_t port, unsigned char options, char *miscptr, FILE *fp)", "code": "{\n  char *empty = \"\";\n  char *login, *pass;\n  char server[64];\n  char domain[256];\n  int32_t login_result = 0;\n\n  memset(domain, 0, sizeof(domain));\n\n  if (strlen(login = hydra_get_next_login()) == 0)\n    login = empty;\n  if (strlen(pass = hydra_get_next_password()) == 0)\n    pass = empty;\n\n  strncpy(server, hydra_address2string(ip), sizeof(server) - 1);\n\n  if ((miscptr != NULL) && (strlen(miscptr) > 0)) {\n    strncpy(domain, miscptr, sizeof(domain) - 1);\n    domain[sizeof(domain) - 1] = 0;\n  }\n\n  login_result = rdp_connect(server, port, domain, login, pass);\n  switch (login_result) {\n  case 0:\n    // login success\n    hydra_report_found_host(port, ip, \"rdp\", fp);\n    hydra_completed_pair_found();\n    break;\n  case 0x00020009:\n  case 0x00020014:\n  case 0x00020015:\n    // login failure\n    hydra_completed_pair();\n    break;\n  case 0x0002000d:\n    hydra_report(stderr,\n                 \"[%d][rdp] account on %s might be valid but account not \"\n                 \"active for remote desktop: login: %s password: %s, \"\n                 \"continuing attacking the account.\\n\",\n                 port, hydra_address2string_beautiful(ip), login, pass);\n    hydra_completed_pair();\n    break;\n  case 0x00020006:\n  case 0x00020008:\n  case 0x0002000c:\n    // cannot establish rdp connection, either the port is not opened or it's\n    // not rdp\n    return 3;\n  default:\n    if (verbose) {\n      hydra_report(stderr, \"[ERROR] freerdp: %s (0x%.8x)\\n\", freerdp_get_last_error_string(login_result), login_result);\n    }\n    return login_result;\n  }\n  if (memcmp(hydra_get_next_pair(), &HYDRA_EXIT, sizeof(HYDRA_EXIT)) == 0)\n    return 2;\n  return 1;\n}", "path": "thc-hydra/hydra-rdp.c", "commit_date": "2020-06-15 00:00:00", "repo_name": "vanhauser-thc/thc-hydra", "stars": 8834, "license": "agpl-3.0", "language": "c", "size": 3303}
{"docstring": "/* Routines for Windows NT MD4 Hash functions. */\n", "func_signal": "static int32_t _my_wcslen(int16 *str)", "code": "{\n  int32_t len = 0;\n\n  while (*str++ != 0)\n    len++;\n  return len;\n}", "path": "thc-hydra/ntlm.c", "commit_date": "2020-02-01 00:00:00", "repo_name": "vanhauser-thc/thc-hydra", "stars": 8834, "license": "agpl-3.0", "language": "c", "size": 3303}
{"docstring": "/*\n** Invoke the sub-routine at regGosub (generated by code in select.c) to\n** return the current row of Window.iEphCsr. If all window functions are\n** aggregate window functions that use the standard API, a single\n** OP_Gosub instruction is all that this routine generates. Extra VM code\n** for per-row processing is only generated for the following built-in window\n** functions:\n**\n**   nth_value()\n**   first_value()\n**   lag()\n**   lead()\n*/\n", "func_signal": "static void windowReturnOneRow(WindowCodeArg *p)", "code": "{\n  Window *pMWin = p->pMWin;\n  Vdbe *v = p->pVdbe;\n\n  if( pMWin->regStartRowid ){\n    windowFullScan(p);\n  }else{\n    Parse *pParse = p->pParse;\n    Window *pWin;\n\n    for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n      FuncDef *pFunc = pWin->pFunc;\n      if( pFunc->zName==nth_valueName\n       || pFunc->zName==first_valueName\n      ){\n        int csr = pWin->csrApp;\n        int lbl = sqlite3VdbeMakeLabel(pParse);\n        int tmpReg = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regResult);\n  \n        if( pFunc->zName==nth_valueName ){\n          sqlite3VdbeAddOp3(v, OP_Column,pMWin->iEphCsr,pWin->iArgCol+1,tmpReg);\n          windowCheckValue(pParse, tmpReg, 2);\n        }else{\n          sqlite3VdbeAddOp2(v, OP_Integer, 1, tmpReg);\n        }\n        sqlite3VdbeAddOp3(v, OP_Add, tmpReg, pWin->regApp, tmpReg);\n        sqlite3VdbeAddOp3(v, OP_Gt, pWin->regApp+1, lbl, tmpReg);\n        VdbeCoverageNeverNull(v);\n        sqlite3VdbeAddOp3(v, OP_SeekRowid, csr, 0, tmpReg);\n        VdbeCoverageNeverTaken(v);\n        sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol, pWin->regResult);\n        sqlite3VdbeResolveLabel(v, lbl);\n        sqlite3ReleaseTempReg(pParse, tmpReg);\n      }\n      else if( pFunc->zName==leadName || pFunc->zName==lagName ){\n        int nArg = pWin->pOwner->x.pList->nExpr;\n        int csr = pWin->csrApp;\n        int lbl = sqlite3VdbeMakeLabel(pParse);\n        int tmpReg = sqlite3GetTempReg(pParse);\n        int iEph = pMWin->iEphCsr;\n  \n        if( nArg<3 ){\n          sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regResult);\n        }else{\n          sqlite3VdbeAddOp3(v, OP_Column, iEph,pWin->iArgCol+2,pWin->regResult);\n        }\n        sqlite3VdbeAddOp2(v, OP_Rowid, iEph, tmpReg);\n        if( nArg<2 ){\n          int val = (pFunc->zName==leadName ? 1 : -1);\n          sqlite3VdbeAddOp2(v, OP_AddImm, tmpReg, val);\n        }else{\n          int op = (pFunc->zName==leadName ? OP_Add : OP_Subtract);\n          int tmpReg2 = sqlite3GetTempReg(pParse);\n          sqlite3VdbeAddOp3(v, OP_Column, iEph, pWin->iArgCol+1, tmpReg2);\n          sqlite3VdbeAddOp3(v, op, tmpReg2, tmpReg, tmpReg);\n          sqlite3ReleaseTempReg(pParse, tmpReg2);\n        }\n  \n        sqlite3VdbeAddOp3(v, OP_SeekRowid, csr, lbl, tmpReg);\n        VdbeCoverage(v);\n        sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol, pWin->regResult);\n        sqlite3VdbeResolveLabel(v, lbl);\n        sqlite3ReleaseTempReg(pParse, tmpReg);\n      }\n    }\n  }\n  sqlite3VdbeAddOp2(v, OP_Gosub, p->regGosub, p->addrGosub);\n}", "path": "mimikatz/modules/sqlite3.c", "commit_date": "2020-01-04 00:00:00", "repo_name": "gentilkiwi/mimikatz", "stars": 18483, "license": "None", "language": "c", "size": 6164}
{"docstring": "/*\n** Invalidate temp storage, either when the temp storage is changed\n** from default, or when 'file' and the temp_store_directory has changed\n*/\n", "func_signal": "static int invalidateTempStorage(Parse *pParse)", "code": "{\n  sqlite3 *db = pParse->db;\n  if( db->aDb[1].pBt!=0 ){\n    if( !db->autoCommit || sqlite3BtreeIsInReadTrans(db->aDb[1].pBt) ){\n      sqlite3ErrorMsg(pParse, \"temporary storage cannot be changed \"\n        \"from within a transaction\");\n      return SQLITE_ERROR;\n    }\n    sqlite3BtreeClose(db->aDb[1].pBt);\n    db->aDb[1].pBt = 0;\n    sqlite3ResetAllSchemasOfConnection(db);\n  }\n  return SQLITE_OK;\n}", "path": "mimikatz/modules/sqlite3.c", "commit_date": "2020-01-04 00:00:00", "repo_name": "gentilkiwi/mimikatz", "stars": 18483, "license": "None", "language": "c", "size": 6164}
{"docstring": "/*\n** If there are no outstanding cursors and we are not in the middle\n** of a transaction but there is a read lock on the database, then\n** this routine unrefs the first page of the database file which \n** has the effect of releasing the read lock.\n**\n** If there is a transaction in progress, this routine is a no-op.\n*/\n", "func_signal": "static void unlockBtreeIfUnused(BtShared *pBt)", "code": "{\n  assert( sqlite3_mutex_held(pBt->mutex) );\n  assert( countValidCursors(pBt,0)==0 || pBt->inTransaction>TRANS_NONE );\n  if( pBt->inTransaction==TRANS_NONE && pBt->pPage1!=0 ){\n    MemPage *pPage1 = pBt->pPage1;\n    assert( pPage1->aData );\n    assert( sqlite3PagerRefcount(pBt->pPager)==1 );\n    pBt->pPage1 = 0;\n    releasePageOne(pPage1);\n  }\n}", "path": "mimikatz/modules/sqlite3.c", "commit_date": "2020-01-04 00:00:00", "repo_name": "gentilkiwi/mimikatz", "stars": 18483, "license": "None", "language": "c", "size": 6164}
{"docstring": "/* \n** Attempt to locate an element of the hash table pH with a key\n** that matches pKey,nKey.  Return the data for this element if it is\n** found, or NULL if there is no match.\n*/\n", "func_signal": "SQLITE_PRIVATE void *sqlite3Fts3HashFind(const Fts3Hash *pH, const void *pKey, int nKey)", "code": "{\n  Fts3HashElem *pElem;            /* The element that matches key (if any) */\n\n  pElem = sqlite3Fts3HashFindElem(pH, pKey, nKey);\n  return pElem ? pElem->data : 0;\n}", "path": "mimikatz/modules/sqlite3.c", "commit_date": "2020-01-04 00:00:00", "repo_name": "gentilkiwi/mimikatz", "stars": 18483, "license": "None", "language": "c", "size": 6164}
{"docstring": "/*\n** This is called when the database connection passed as an argument is \n** being closed. The connection is removed from the blocked list.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3ConnectionClosed(sqlite3 *db)", "code": "{\n  sqlite3ConnectionUnlocked(db);\n  enterMutex();\n  removeFromBlockedList(db);\n  checkListProperties(db);\n  leaveMutex();\n}", "path": "mimikatz/modules/sqlite3.c", "commit_date": "2020-01-04 00:00:00", "repo_name": "gentilkiwi/mimikatz", "stars": 18483, "license": "None", "language": "c", "size": 6164}
{"docstring": "/*\n** Set the value returned by the sqlite3_last_insert_rowid() API function.\n*/\n", "func_signal": "SQLITE_API void sqlite3_set_last_insert_rowid(sqlite3 *db, sqlite3_int64 iRowid)", "code": "{\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( !sqlite3SafetyCheckOk(db) ){\n    (void)SQLITE_MISUSE_BKPT;\n    return;\n  }\n#endif\n  sqlite3_mutex_enter(db->mutex);\n  db->lastRowid = iRowid;\n  sqlite3_mutex_leave(db->mutex);\n}", "path": "mimikatz/modules/sqlite3.c", "commit_date": "2020-01-04 00:00:00", "repo_name": "gentilkiwi/mimikatz", "stars": 18483, "license": "None", "language": "c", "size": 6164}
{"docstring": "/*\n** Add a new subitem to the tree.  The moreToFollow flag indicates that this\n** is not the last item in the tree.\n*/\n", "func_signal": "static TreeView *sqlite3TreeViewPush(TreeView *p, u8 moreToFollow)", "code": "{\n  if( p==0 ){\n    p = sqlite3_malloc64( sizeof(*p) );\n    if( p==0 ) return 0;\n    memset(p, 0, sizeof(*p));\n  }else{\n    p->iLevel++;\n  }\n  assert( moreToFollow==0 || moreToFollow==1 );\n  if( p->iLevel<sizeof(p->bLine) ) p->bLine[p->iLevel] = moreToFollow;\n  return p;\n}", "path": "mimikatz/modules/sqlite3.c", "commit_date": "2020-01-04 00:00:00", "repo_name": "gentilkiwi/mimikatz", "stars": 18483, "license": "None", "language": "c", "size": 6164}
{"docstring": "/*\n** Expression p should encode a floating point value between 1.0 and 0.0.\n** Return 1024 times this value.  Or return -1 if p is not a floating point\n** value between 1.0 and 0.0.\n*/\n", "func_signal": "static int exprProbability(Expr *p)", "code": "{\n  double r = -1.0;\n  if( p->op!=TK_FLOAT ) return -1;\n  sqlite3AtoF(p->u.zToken, &r, sqlite3Strlen30(p->u.zToken), SQLITE_UTF8);\n  assert( r>=0.0 );\n  if( r>1.0 ) return -1;\n  return (int)(r*134217728.0);\n}", "path": "mimikatz/modules/sqlite3.c", "commit_date": "2020-01-04 00:00:00", "repo_name": "gentilkiwi/mimikatz", "stars": 18483, "license": "None", "language": "c", "size": 6164}
{"docstring": "/*\n** This routine is a copy of the sqlite3FileSuffix3() routine from the core.\n** It is a no-op unless SQLITE_ENABLE_8_3_NAMES is defined.\n**\n** If SQLITE_ENABLE_8_3_NAMES is set at compile-time and if the database\n** filename in zBaseFilename is a URI with the \"8_3_names=1\" parameter and\n** if filename in z[] has a suffix (a.k.a. \"extension\") that is longer than\n** three characters, then shorten the suffix on z[] to be the last three\n** characters of the original suffix.\n**\n** If SQLITE_ENABLE_8_3_NAMES is set to 2 at compile-time, then always\n** do the suffix shortening regardless of URI parameter.\n**\n** Examples:\n**\n**     test.db-journal    =>   test.nal\n**     test.db-wal        =>   test.wal\n**     test.db-shm        =>   test.shm\n**     test.db-mj7f3319fa =>   test.9fa\n*/\n", "func_signal": "static void rbuFileSuffix3(const char *zBase, char *z)", "code": "{\n#ifdef SQLITE_ENABLE_8_3_NAMES\n#if SQLITE_ENABLE_8_3_NAMES<2\n  if( sqlite3_uri_boolean(zBase, \"8_3_names\", 0) )\n#endif\n  {\n    int i, sz;\n    sz = (int)strlen(z)&0xffffff;\n    for(i=sz-1; i>0 && z[i]!='/' && z[i]!='.'; i--){}\n    if( z[i]=='.' && sz>i+4 ) memmove(&z[i+1], &z[sz-3], 4);\n  }\n#endif\n}", "path": "mimikatz/modules/sqlite3.c", "commit_date": "2020-01-04 00:00:00", "repo_name": "gentilkiwi/mimikatz", "stars": 18483, "license": "None", "language": "c", "size": 6164}
{"docstring": "/*\n** Free all resources held by the schema structure. The void* argument points\n** at a Schema struct. This function does not call sqlite3DbFree(db, ) on the \n** pointer itself, it just cleans up subsidiary resources (i.e. the contents\n** of the schema hash tables).\n**\n** The Schema.cache_size variable is not cleared.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3SchemaClear(void *p)", "code": "{\n  Hash temp1;\n  Hash temp2;\n  HashElem *pElem;\n  Schema *pSchema = (Schema *)p;\n\n  temp1 = pSchema->tblHash;\n  temp2 = pSchema->trigHash;\n  sqlite3HashInit(&pSchema->trigHash);\n  sqlite3HashClear(&pSchema->idxHash);\n  for(pElem=sqliteHashFirst(&temp2); pElem; pElem=sqliteHashNext(pElem)){\n    sqlite3DeleteTrigger(0, (Trigger*)sqliteHashData(pElem));\n  }\n  sqlite3HashClear(&temp2);\n  sqlite3HashInit(&pSchema->tblHash);\n  for(pElem=sqliteHashFirst(&temp1); pElem; pElem=sqliteHashNext(pElem)){\n    Table *pTab = sqliteHashData(pElem);\n    sqlite3DeleteTable(0, pTab);\n  }\n  sqlite3HashClear(&temp1);\n  sqlite3HashClear(&pSchema->fkeyHash);\n  pSchema->pSeqTab = 0;\n  if( pSchema->schemaFlags & DB_SchemaLoaded ){\n    pSchema->iGeneration++;\n  }\n  pSchema->schemaFlags &= ~(DB_SchemaLoaded|DB_ResetWanted);\n}", "path": "mimikatz/modules/sqlite3.c", "commit_date": "2020-01-04 00:00:00", "repo_name": "gentilkiwi/mimikatz", "stars": 18483, "license": "None", "language": "c", "size": 6164}
{"docstring": "/*\n** The near-set object passed as the first argument contains more than\n** one phrase. All phrases currently point to the same row. The\n** Fts5ExprPhrase.poslist buffers are populated accordingly. This function\n** tests if the current row contains instances of each phrase sufficiently\n** close together to meet the NEAR constraint. Non-zero is returned if it\n** does, or zero otherwise.\n**\n** If in/out parameter (*pRc) is set to other than SQLITE_OK when this\n** function is called, it is a no-op. Or, if an error (e.g. SQLITE_NOMEM)\n** occurs within this function (*pRc) is set accordingly before returning.\n** The return value is undefined in both these cases.\n** \n** If no error occurs and non-zero (a match) is returned, the position-list\n** of each phrase object is edited to contain only those entries that\n** meet the constraint before returning.\n*/\n", "func_signal": "static int fts5ExprNearIsMatch(int *pRc, Fts5ExprNearset *pNear)", "code": "{\n  Fts5NearTrimmer aStatic[4];\n  Fts5NearTrimmer *a = aStatic;\n  Fts5ExprPhrase **apPhrase = pNear->apPhrase;\n\n  int i;\n  int rc = *pRc;\n  int bMatch;\n\n  assert( pNear->nPhrase>1 );\n\n  /* If the aStatic[] array is not large enough, allocate a large array\n  ** using sqlite3_malloc(). This approach could be improved upon. */\n  if( pNear->nPhrase>ArraySize(aStatic) ){\n    sqlite3_int64 nByte = sizeof(Fts5NearTrimmer) * pNear->nPhrase;\n    a = (Fts5NearTrimmer*)sqlite3Fts5MallocZero(&rc, nByte);\n  }else{\n    memset(aStatic, 0, sizeof(aStatic));\n  }\n  if( rc!=SQLITE_OK ){\n    *pRc = rc;\n    return 0;\n  }\n\n  /* Initialize a lookahead iterator for each phrase. After passing the\n  ** buffer and buffer size to the lookaside-reader init function, zero\n  ** the phrase poslist buffer. The new poslist for the phrase (containing\n  ** the same entries as the original with some entries removed on account \n  ** of the NEAR constraint) is written over the original even as it is\n  ** being read. This is safe as the entries for the new poslist are a\n  ** subset of the old, so it is not possible for data yet to be read to\n  ** be overwritten.  */\n  for(i=0; i<pNear->nPhrase; i++){\n    Fts5Buffer *pPoslist = &apPhrase[i]->poslist;\n    fts5LookaheadReaderInit(pPoslist->p, pPoslist->n, &a[i].reader);\n    pPoslist->n = 0;\n    a[i].pOut = pPoslist;\n  }\n\n  while( 1 ){\n    int iAdv;\n    i64 iMin;\n    i64 iMax;\n\n    /* This block advances the phrase iterators until they point to a set of\n    ** entries that together comprise a match.  */\n    iMax = a[0].reader.iPos;\n    do {\n      bMatch = 1;\n      for(i=0; i<pNear->nPhrase; i++){\n        Fts5LookaheadReader *pPos = &a[i].reader;\n        iMin = iMax - pNear->apPhrase[i]->nTerm - pNear->nNear;\n        if( pPos->iPos<iMin || pPos->iPos>iMax ){\n          bMatch = 0;\n          while( pPos->iPos<iMin ){\n            if( fts5LookaheadReaderNext(pPos) ) goto ismatch_out;\n          }\n          if( pPos->iPos>iMax ) iMax = pPos->iPos;\n        }\n      }\n    }while( bMatch==0 );\n\n    /* Add an entry to each output position list */\n    for(i=0; i<pNear->nPhrase; i++){\n      i64 iPos = a[i].reader.iPos;\n      Fts5PoslistWriter *pWriter = &a[i].writer;\n      if( a[i].pOut->n==0 || iPos!=pWriter->iPrev ){\n        sqlite3Fts5PoslistWriterAppend(a[i].pOut, pWriter, iPos);\n      }\n    }\n\n    iAdv = 0;\n    iMin = a[0].reader.iLookahead;\n    for(i=0; i<pNear->nPhrase; i++){\n      if( a[i].reader.iLookahead < iMin ){\n        iMin = a[i].reader.iLookahead;\n        iAdv = i;\n      }\n    }\n    if( fts5LookaheadReaderNext(&a[iAdv].reader) ) goto ismatch_out;\n  }\n\n  ismatch_out: {\n    int bRet = a[0].pOut->n>0;\n    *pRc = rc;\n    if( a!=aStatic ) sqlite3_free(a);\n    return bRet;\n  }\n}", "path": "mimikatz/modules/sqlite3.c", "commit_date": "2020-01-04 00:00:00", "repo_name": "gentilkiwi/mimikatz", "stars": 18483, "license": "None", "language": "c", "size": 6164}
{"docstring": "/*\n** This function is only called for detail=columns tables. \n*/\n", "func_signal": "static int sqlite3Fts5ExprPhraseCollist(\n  Fts5Expr *pExpr, \n  int iPhrase, \n  const u8 **ppCollist, \n  int *pnCollist\n)", "code": "{\n  Fts5ExprPhrase *pPhrase = pExpr->apExprPhrase[iPhrase];\n  Fts5ExprNode *pNode = pPhrase->pNode;\n  int rc = SQLITE_OK;\n\n  assert( iPhrase>=0 && iPhrase<pExpr->nPhrase );\n  assert( pExpr->pConfig->eDetail==FTS5_DETAIL_COLUMNS );\n\n  if( pNode->bEof==0 \n   && pNode->iRowid==pExpr->pRoot->iRowid \n   && pPhrase->poslist.n>0\n  ){\n    Fts5ExprTerm *pTerm = &pPhrase->aTerm[0];\n    if( pTerm->pSynonym ){\n      Fts5Buffer *pBuf = (Fts5Buffer*)&pTerm->pSynonym[1];\n      rc = fts5ExprSynonymList(\n          pTerm, pNode->iRowid, pBuf, (u8**)ppCollist, pnCollist\n      );\n    }else{\n      *ppCollist = pPhrase->aTerm[0].pIter->pData;\n      *pnCollist = pPhrase->aTerm[0].pIter->nData;\n    }\n  }else{\n    *ppCollist = 0;\n    *pnCollist = 0;\n  }\n\n  return rc;\n}", "path": "mimikatz/modules/sqlite3.c", "commit_date": "2020-01-04 00:00:00", "repo_name": "gentilkiwi/mimikatz", "stars": 18483, "license": "None", "language": "c", "size": 6164}
{"docstring": "/*\n** This routine is called after all opcodes have been inserted.  It loops\n** through all the opcodes and fixes up some details.\n**\n** (1) For each jump instruction with a negative P2 value (a label)\n**     resolve the P2 value to an actual address.\n**\n** (2) Compute the maximum number of arguments used by any SQL function\n**     and store that value in *pMaxFuncArgs.\n**\n** (3) Update the Vdbe.readOnly and Vdbe.bIsReader flags to accurately\n**     indicate what the prepared statement actually does.\n**\n** (4) Initialize the p4.xAdvance pointer on opcodes that use it.\n**\n** (5) Reclaim the memory allocated for storing labels.\n**\n** This routine will only function correctly if the mkopcodeh.tcl generator\n** script numbers the opcodes correctly.  Changes to this routine must be\n** coordinated with changes to mkopcodeh.tcl.\n*/\n", "func_signal": "static void resolveP2Values(Vdbe *p, int *pMaxFuncArgs)", "code": "{\n  int nMaxArgs = *pMaxFuncArgs;\n  Op *pOp;\n  Parse *pParse = p->pParse;\n  int *aLabel = pParse->aLabel;\n  p->readOnly = 1;\n  p->bIsReader = 0;\n  pOp = &p->aOp[p->nOp-1];\n  while(1){\n\n    /* Only JUMP opcodes and the short list of special opcodes in the switch\n    ** below need to be considered.  The mkopcodeh.tcl generator script groups\n    ** all these opcodes together near the front of the opcode list.  Skip\n    ** any opcode that does not need processing by virtual of the fact that\n    ** it is larger than SQLITE_MX_JUMP_OPCODE, as a performance optimization.\n    */\n    if( pOp->opcode<=SQLITE_MX_JUMP_OPCODE ){\n      /* NOTE: Be sure to update mkopcodeh.tcl when adding or removing\n      ** cases from this switch! */\n      switch( pOp->opcode ){\n        case OP_Transaction: {\n          if( pOp->p2!=0 ) p->readOnly = 0;\n          /* fall thru */\n        }\n        case OP_AutoCommit:\n        case OP_Savepoint: {\n          p->bIsReader = 1;\n          break;\n        }\n#ifndef SQLITE_OMIT_WAL\n        case OP_Checkpoint:\n#endif\n        case OP_Vacuum:\n        case OP_JournalMode: {\n          p->readOnly = 0;\n          p->bIsReader = 1;\n          break;\n        }\n        case OP_Next:\n        case OP_SorterNext: {\n          pOp->p4.xAdvance = sqlite3BtreeNext;\n          pOp->p4type = P4_ADVANCE;\n          /* The code generator never codes any of these opcodes as a jump\n          ** to a label.  They are always coded as a jump backwards to a \n          ** known address */\n          assert( pOp->p2>=0 );\n          break;\n        }\n        case OP_Prev: {\n          pOp->p4.xAdvance = sqlite3BtreePrevious;\n          pOp->p4type = P4_ADVANCE;\n          /* The code generator never codes any of these opcodes as a jump\n          ** to a label.  They are always coded as a jump backwards to a \n          ** known address */\n          assert( pOp->p2>=0 );\n          break;\n        }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n        case OP_VUpdate: {\n          if( pOp->p2>nMaxArgs ) nMaxArgs = pOp->p2;\n          break;\n        }\n        case OP_VFilter: {\n          int n;\n          assert( (pOp - p->aOp) >= 3 );\n          assert( pOp[-1].opcode==OP_Integer );\n          n = pOp[-1].p1;\n          if( n>nMaxArgs ) nMaxArgs = n;\n          /* Fall through into the default case */\n        }\n#endif\n        default: {\n          if( pOp->p2<0 ){\n            /* The mkopcodeh.tcl script has so arranged things that the only\n            ** non-jump opcodes less than SQLITE_MX_JUMP_CODE are guaranteed to\n            ** have non-negative values for P2. */\n            assert( (sqlite3OpcodeProperty[pOp->opcode] & OPFLG_JUMP)!=0 );\n            assert( ADDR(pOp->p2)<-pParse->nLabel );\n            pOp->p2 = aLabel[ADDR(pOp->p2)];\n          }\n          break;\n        }\n      }\n      /* The mkopcodeh.tcl script has so arranged things that the only\n      ** non-jump opcodes less than SQLITE_MX_JUMP_CODE are guaranteed to\n      ** have non-negative values for P2. */\n      assert( (sqlite3OpcodeProperty[pOp->opcode]&OPFLG_JUMP)==0 || pOp->p2>=0);\n    }\n    if( pOp==p->aOp ) break;\n    pOp--;\n  }\n  sqlite3DbFree(p->db, pParse->aLabel);\n  pParse->aLabel = 0;\n  pParse->nLabel = 0;\n  *pMaxFuncArgs = nMaxArgs;\n  assert( p->bIsReader!=0 || DbMaskAllZero(p->btreeMask) );\n}", "path": "mimikatz/modules/sqlite3.c", "commit_date": "2020-01-04 00:00:00", "repo_name": "gentilkiwi/mimikatz", "stars": 18483, "license": "None", "language": "c", "size": 6164}
{"docstring": "/*\n** Duplicate a range of text from an SQL statement, then convert all\n** whitespace characters into ordinary space characters.\n*/\n", "func_signal": "static char *triggerSpanDup(sqlite3 *db, const char *zStart, const char *zEnd)", "code": "{\n  char *z = sqlite3DbSpanDup(db, zStart, zEnd);\n  int i;\n  if( z ) for(i=0; z[i]; i++) if( sqlite3Isspace(z[i]) ) z[i] = ' ';\n  return z;\n}", "path": "mimikatz/modules/sqlite3.c", "commit_date": "2020-01-04 00:00:00", "repo_name": "gentilkiwi/mimikatz", "stars": 18483, "license": "None", "language": "c", "size": 6164}
{"docstring": "/*\n** Recursively walk the expressions of a SELECT statement and generate\n** a bitmask indicating which tables are used in that expression\n** tree.\n*/\n", "func_signal": "static Bitmask exprSelectUsage(WhereMaskSet *pMaskSet, Select *pS)", "code": "{\n  Bitmask mask = 0;\n  while( pS ){\n    SrcList *pSrc = pS->pSrc;\n    mask |= sqlite3WhereExprListUsage(pMaskSet, pS->pEList);\n    mask |= sqlite3WhereExprListUsage(pMaskSet, pS->pGroupBy);\n    mask |= sqlite3WhereExprListUsage(pMaskSet, pS->pOrderBy);\n    mask |= sqlite3WhereExprUsage(pMaskSet, pS->pWhere);\n    mask |= sqlite3WhereExprUsage(pMaskSet, pS->pHaving);\n    if( ALWAYS(pSrc!=0) ){\n      int i;\n      for(i=0; i<pSrc->nSrc; i++){\n        mask |= exprSelectUsage(pMaskSet, pSrc->a[i].pSelect);\n        mask |= sqlite3WhereExprUsage(pMaskSet, pSrc->a[i].pOn);\n        if( pSrc->a[i].fg.isTabFunc ){\n          mask |= sqlite3WhereExprListUsage(pMaskSet, pSrc->a[i].u1.pFuncArg);\n        }\n      }\n    }\n    pS = pS->pPrior;\n  }\n  return mask;\n}", "path": "mimikatz/modules/sqlite3.c", "commit_date": "2020-01-04 00:00:00", "repo_name": "gentilkiwi/mimikatz", "stars": 18483, "license": "None", "language": "c", "size": 6164}
{"docstring": "/*\n** Compose a tcl-readable representation of expression pExpr. Return a \n** pointer to a buffer containing that representation. It is the \n** responsibility of the caller to at some point free the buffer using \n** sqlite3_free().\n*/\n", "func_signal": "static char *fts5ExprPrintTcl(\n  Fts5Config *pConfig, \n  const char *zNearsetCmd,\n  Fts5ExprNode *pExpr\n)", "code": "{\n  char *zRet = 0;\n  if( pExpr->eType==FTS5_STRING || pExpr->eType==FTS5_TERM ){\n    Fts5ExprNearset *pNear = pExpr->pNear;\n    int i; \n    int iTerm;\n\n    zRet = fts5PrintfAppend(zRet, \"%s \", zNearsetCmd);\n    if( zRet==0 ) return 0;\n    if( pNear->pColset ){\n      int *aiCol = pNear->pColset->aiCol;\n      int nCol = pNear->pColset->nCol;\n      if( nCol==1 ){\n        zRet = fts5PrintfAppend(zRet, \"-col %d \", aiCol[0]);\n      }else{\n        zRet = fts5PrintfAppend(zRet, \"-col {%d\", aiCol[0]);\n        for(i=1; i<pNear->pColset->nCol; i++){\n          zRet = fts5PrintfAppend(zRet, \" %d\", aiCol[i]);\n        }\n        zRet = fts5PrintfAppend(zRet, \"} \");\n      }\n      if( zRet==0 ) return 0;\n    }\n\n    if( pNear->nPhrase>1 ){\n      zRet = fts5PrintfAppend(zRet, \"-near %d \", pNear->nNear);\n      if( zRet==0 ) return 0;\n    }\n\n    zRet = fts5PrintfAppend(zRet, \"--\");\n    if( zRet==0 ) return 0;\n\n    for(i=0; i<pNear->nPhrase; i++){\n      Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];\n\n      zRet = fts5PrintfAppend(zRet, \" {\");\n      for(iTerm=0; zRet && iTerm<pPhrase->nTerm; iTerm++){\n        char *zTerm = pPhrase->aTerm[iTerm].zTerm;\n        zRet = fts5PrintfAppend(zRet, \"%s%s\", iTerm==0?\"\":\" \", zTerm);\n        if( pPhrase->aTerm[iTerm].bPrefix ){\n          zRet = fts5PrintfAppend(zRet, \"*\");\n        }\n      }\n\n      if( zRet ) zRet = fts5PrintfAppend(zRet, \"}\");\n      if( zRet==0 ) return 0;\n    }\n\n  }else{\n    char const *zOp = 0;\n    int i;\n    switch( pExpr->eType ){\n      case FTS5_AND: zOp = \"AND\"; break;\n      case FTS5_NOT: zOp = \"NOT\"; break;\n      default: \n        assert( pExpr->eType==FTS5_OR );\n        zOp = \"OR\"; \n        break;\n    }\n\n    zRet = sqlite3_mprintf(\"%s\", zOp);\n    for(i=0; zRet && i<pExpr->nChild; i++){\n      char *z = fts5ExprPrintTcl(pConfig, zNearsetCmd, pExpr->apChild[i]);\n      if( !z ){\n        sqlite3_free(zRet);\n        zRet = 0;\n      }else{\n        zRet = fts5PrintfAppend(zRet, \" [%z]\", z);\n      }\n    }\n  }\n\n  return zRet;\n}", "path": "mimikatz/modules/sqlite3.c", "commit_date": "2020-01-04 00:00:00", "repo_name": "gentilkiwi/mimikatz", "stars": 18483, "license": "None", "language": "c", "size": 6164}
{"docstring": "/*\n** Unregister a VFS so that it is no longer accessible.\n*/\n", "func_signal": "SQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs *pVfs)", "code": "{\n  MUTEX_LOGIC(sqlite3_mutex *mutex;)\n#ifndef SQLITE_OMIT_AUTOINIT\n  int rc = sqlite3_initialize();\n  if( rc ) return rc;\n#endif\n  MUTEX_LOGIC( mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); )\n  sqlite3_mutex_enter(mutex);\n  vfsUnlink(pVfs);\n  sqlite3_mutex_leave(mutex);\n  return SQLITE_OK;\n}", "path": "mimikatz/modules/sqlite3.c", "commit_date": "2020-01-04 00:00:00", "repo_name": "gentilkiwi/mimikatz", "stars": 18483, "license": "None", "language": "c", "size": 6164}
{"docstring": "/*\n** Argument p points to a buffer containing a varint to be interpreted as a\n** position list size field. Read the varint and return the number of bytes\n** read. Before returning, set *pnSz to the number of bytes in the position\n** list, and *pbDel to true if the delete flag is set, or false otherwise.\n*/\n", "func_signal": "static int fts5GetPoslistSize(const u8 *p, int *pnSz, int *pbDel)", "code": "{\n  int nSz;\n  int n = 0;\n  fts5FastGetVarint32(p, n, nSz);\n  assert_nc( nSz>=0 );\n  *pnSz = nSz/2;\n  *pbDel = nSz & 0x0001;\n  return n;\n}", "path": "mimikatz/modules/sqlite3.c", "commit_date": "2020-01-04 00:00:00", "repo_name": "gentilkiwi/mimikatz", "stars": 18483, "license": "None", "language": "c", "size": 6164}
{"docstring": "/*\n** Invoke SQLITE_FCNTL_MMAP_SIZE based on the current value of szMmap.\n*/\n", "func_signal": "static void pagerFixMaplimit(Pager *pPager)", "code": "{\n#if SQLITE_MAX_MMAP_SIZE>0\n  sqlite3_file *fd = pPager->fd;\n  if( isOpen(fd) && fd->pMethods->iVersion>=3 ){\n    sqlite3_int64 sz;\n    sz = pPager->szMmap;\n    pPager->bUseFetch = (sz>0);\n    setGetterMethod(pPager);\n    sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_MMAP_SIZE, &sz);\n  }\n#endif\n}", "path": "mimikatz/modules/sqlite3.c", "commit_date": "2020-01-04 00:00:00", "repo_name": "gentilkiwi/mimikatz", "stars": 18483, "license": "None", "language": "c", "size": 6164}
{"docstring": "/*\n** The iterator currently points to a table (not index) of type \n** RBU_PK_WITHOUT_ROWID. This function creates the PRIMARY KEY \n** declaration for the corresponding imposter table. For example,\n** if the iterator points to a table created as:\n**\n**   CREATE TABLE t1(a, b, c, PRIMARY KEY(b, a DESC)) WITHOUT ROWID\n**\n** this function returns:\n**\n**   PRIMARY KEY(\"b\", \"a\" DESC)\n*/\n", "func_signal": "static char *rbuWithoutRowidPK(sqlite3rbu *p, RbuObjIter *pIter)", "code": "{\n  char *z = 0;\n  assert( pIter->zIdx==0 );\n  if( p->rc==SQLITE_OK ){\n    const char *zSep = \"PRIMARY KEY(\";\n    sqlite3_stmt *pXList = 0;     /* PRAGMA index_list = (pIter->zTbl) */\n    sqlite3_stmt *pXInfo = 0;     /* PRAGMA index_xinfo = <pk-index> */\n   \n    p->rc = prepareFreeAndCollectError(p->dbMain, &pXList, &p->zErrmsg,\n        sqlite3_mprintf(\"PRAGMA main.index_list = %Q\", pIter->zTbl)\n    );\n    while( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pXList) ){\n      const char *zOrig = (const char*)sqlite3_column_text(pXList,3);\n      if( zOrig && strcmp(zOrig, \"pk\")==0 ){\n        const char *zIdx = (const char*)sqlite3_column_text(pXList,1);\n        if( zIdx ){\n          p->rc = prepareFreeAndCollectError(p->dbMain, &pXInfo, &p->zErrmsg,\n              sqlite3_mprintf(\"PRAGMA main.index_xinfo = %Q\", zIdx)\n          );\n        }\n        break;\n      }\n    }\n    rbuFinalize(p, pXList);\n\n    while( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pXInfo) ){\n      if( sqlite3_column_int(pXInfo, 5) ){\n        /* int iCid = sqlite3_column_int(pXInfo, 0); */\n        const char *zCol = (const char*)sqlite3_column_text(pXInfo, 2);\n        const char *zDesc = sqlite3_column_int(pXInfo, 3) ? \" DESC\" : \"\";\n        z = rbuMPrintf(p, \"%z%s\\\"%w\\\"%s\", z, zSep, zCol, zDesc);\n        zSep = \", \";\n      }\n    }\n    z = rbuMPrintf(p, \"%z)\", z);\n    rbuFinalize(p, pXInfo);\n  }\n  return z;\n}", "path": "mimikatz/modules/sqlite3.c", "commit_date": "2020-01-04 00:00:00", "repo_name": "gentilkiwi/mimikatz", "stars": 18483, "license": "None", "language": "c", "size": 6164}
{"docstring": "/**\n * @brief lwip callback from PPP client used here to produce PPP error related events,\n * as well as some IP events\n */\n", "func_signal": "static void on_ppp_status_changed(ppp_pcb *pcb, int err_code, void *ctx)", "code": "{\n    struct netif *pppif = ppp_netif(pcb);\n    const ip_addr_t *dest_ip = NULL;\n    esp_netif_t *netif = ctx;\n    ip_event_got_ip_t evt = {\n            .esp_netif = netif,\n            .if_index = -1,\n    };\n    esp_err_t err;\n    struct lwip_peer2peer_ctx *obj =  (struct lwip_peer2peer_ctx*)netif->related_data;\n    assert(obj->base.netif_type == PPP_LWIP_NETIF);\n    esp_ip4_addr_t ns1;\n    esp_ip4_addr_t ns2;\n    switch (err_code) {\n        case PPPERR_NONE: /* Connected */\n            ESP_LOGI(TAG, \"Connected\");\n            if (pcb->if4_up && !ip_addr_isany(&pppif->ip_addr)) {\n                esp_netif_ip_info_t *ip_info = netif->ip_info;\n                ip4_addr_set(&ip_info->ip, ip_2_ip4(&pppif->ip_addr));\n                ip4_addr_set(&ip_info->netmask, ip_2_ip4(&pppif->netmask));\n                ip4_addr_set(&ip_info->gw, ip_2_ip4(&pppif->gw));\n\n                evt.ip_info.ip.addr = pppif->ip_addr.u_addr.ip4.addr;\n                evt.ip_info.gw.addr = pppif->gw.u_addr.ip4.addr;\n                evt.ip_info.netmask.addr = pppif->netmask.u_addr.ip4.addr;\n\n                dest_ip = dns_getserver(0);\n                if(dest_ip != NULL){\n                    ns1.addr = (*dest_ip).u_addr.ip4.addr;\n                }\n                dest_ip = dns_getserver(1);\n                if(dest_ip != NULL){\n                    ns2.addr = (*dest_ip).u_addr.ip4.addr;\n                }\n                ESP_LOGI(TAG, \"Name Server1: \" IPSTR, IP2STR(&ns1));\n                ESP_LOGI(TAG, \"Name Server2: \" IPSTR, IP2STR(&ns2));\n\n\n                err = esp_event_post(IP_EVENT, netif->get_ip_event, &evt, sizeof(evt), 0);\n                if (ESP_OK != err) {\n                    ESP_LOGE(TAG, \"esp_event_post failed with code %d\", err);\n                }\n                return;\n#if PPP_IPV6_SUPPORT\n            } else if (pcb->if6_up && !ip_addr_isany(&pppif->ip6_addr[0])) {\n                esp_netif_ip6_info_t ip6_info;\n                ip6_addr_t lwip_ip6_info;\n                ip_event_got_ip6_t ip6_event = { .esp_netif = pppif->state, .if_index = -1 };\n\n                ip6_addr_set(&lwip_ip6_info, ip_2_ip6(&pppif->ip6_addr[0]));\n#if LWIP_IPV6_SCOPES\n                memcpy(&ip6_info.ip, &lwip_ip6_info, sizeof(esp_ip6_addr_t));\n#else\n                memcpy(&ip6_info.ip, &lwip_ip6_info, sizeof(ip6_addr_t));\n                ip6_info.ip.zone = 0;   // zero out zone, as not used in lwip\n#endif /* LWIP_IPV6_SCOPES */\n                memcpy(&ip6_event.ip6_info, &ip6_info, sizeof(esp_netif_ip6_info_t));\n\n                ESP_LOGI(TAG, \"Got IPv6 address \" IPV6STR, IPV62STR(pppif->ip6_addr[0].u_addr.ip6));\n                err = esp_event_post(IP_EVENT, IP_EVENT_GOT_IP6, &ip6_event, sizeof(ip6_event), 0);\n                if (ESP_OK != err) {\n                    ESP_LOGE(TAG, \"esp_event_post failed with code %d\", err);\n                }\n                return;\n#endif /* PPP_IPV6_SUPPORT */\n            } else {\n                ESP_LOGE(TAG, \"Unexpected connected event\");\n                return;\n            }\n\n        case PPPERR_PARAM:\n            ESP_LOGE(TAG, \"Invalid parameter\");\n            break;\n        case PPPERR_OPEN:\n            ESP_LOGE(TAG, \"Unable to open PPP session\");\n            break;\n        case PPPERR_DEVICE:\n            ESP_LOGE(TAG, \"Invalid I/O device for PPP\");\n            break;\n        case PPPERR_ALLOC:\n            ESP_LOGE(TAG, \"Unable to allocate resources\");\n            break;\n        case PPPERR_USER: /* User interrupt */\n            ESP_LOGI(TAG, \"User interrupt\");\n            break;\n        case PPPERR_CONNECT: /* Connection lost */\n            ESP_LOGI(TAG, \"Connection lost\");\n            err = esp_event_post(IP_EVENT, netif->lost_ip_event, &evt, sizeof(evt), 0);\n\n            if (ESP_OK != err) {\n                ESP_LOGE(TAG, \"esp_event_send_internal failed with code %d\", err);\n            }\n            return;\n\n        case PPPERR_AUTHFAIL:\n            ESP_LOGE(TAG, \"Failed authentication challenge\");\n            break;\n        case PPPERR_PROTOCOL:\n            ESP_LOGE(TAG, \"Failed to meet protocol\");\n            break;\n        case PPPERR_PEERDEAD:\n            ESP_LOGE(TAG, \"Connection timeout\");\n            break;\n        case PPPERR_IDLETIMEOUT:\n            ESP_LOGE(TAG, \"Idle Timeout\");\n            break;\n        case PPPERR_CONNECTTIME:\n            ESP_LOGE(TAG, \"Max connect time reached\");\n            break;\n        case PPPERR_LOOPBACK:\n            ESP_LOGE(TAG, \"Loopback detected\");\n            break;\n        default:\n            ESP_LOGE(TAG, \"Unknown error code %d\", err_code);\n            break;\n    }\n    if (obj->ppp_error_event_enabled) {\n        err = esp_event_post(NETIF_PPP_STATUS, err_code, &netif, sizeof(netif), 0);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"esp_event_post failed with code %d\", err);\n        }\n\n    }\n}", "path": "esp-idf/components/esp_netif/lwip/esp_netif_lwip_ppp.c", "commit_date": "2020-10-26 00:00:00", "repo_name": "espressif/esp-idf", "stars": 12155, "license": "apache-2.0", "language": "c", "size": 264987}
{"docstring": "/**\n * wpa_bss_update_start - Start a BSS table update from scan results\n * @wpa_s: Pointer to wpa_supplicant data\n *\n * This function is called at the start of each BSS table update round for new\n * scan results. The actual scan result entries are indicated with calls to\n * wpa_bss_update_scan_res() and the update round is finished with a call to\n * wpa_bss_update_end().\n */\n", "func_signal": "void wpa_bss_update_start(struct wpa_supplicant *wpa_s)", "code": "{\n\twpa_s->bss_update_idx++;\n\twpa_dbg(wpa_s, MSG_DEBUG, \"BSS: Start scan result update %u\",\n\t\twpa_s->bss_update_idx);\n\twpa_s->last_scan_res_used = 0;\n}", "path": "esp-idf/components/wpa_supplicant/src/common/bss.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "espressif/esp-idf", "stars": 12155, "license": "apache-2.0", "language": "c", "size": 264987}
{"docstring": "/**\n * wpa_bss_update_scan_res - Update a BSS table entry based on a scan result\n * @wpa_s: Pointer to wpa_supplicant data\n * @res: Scan result\n * @fetch_time: Time when the result was fetched from the driver\n *\n * This function updates a BSS table entry (or adds one) based on a scan result.\n * This is called separately for each scan result between the calls to\n * wpa_bss_update_start() and wpa_bss_update_end().\n */\n", "func_signal": "void wpa_bss_update_scan_res(struct wpa_supplicant *wpa_s,\n\t\t\t     struct wpa_scan_res *res,\n\t\t\t     struct os_reltime *fetch_time)", "code": "{\n\tconst u8 *ssid;\n\tstruct wpa_bss *bss;\n\n\tssid = wpa_scan_get_ie(res, WLAN_EID_SSID);\n\tif (ssid == NULL) {\n\t\twpa_dbg(wpa_s, MSG_DEBUG, \"BSS: No SSID IE included for \"\n\t\t\tMACSTR, MAC2STR(res->bssid));\n\t\treturn;\n\t}\n\tif (ssid[1] > SSID_MAX_LEN) {\n\t\twpa_dbg(wpa_s, MSG_DEBUG, \"BSS: Too long SSID IE included for \"\n\t\t\tMACSTR, MAC2STR(res->bssid));\n\t\treturn;\n\t}\n\n\t/* TODO: add option for ignoring BSSes we are not interested in\n\t * (to save memory) */\n\n\tbss = wpa_bss_get(wpa_s, res->bssid, ssid + 2, ssid[1]);\n\tif (bss == NULL)\n\t\tbss = wpa_bss_add(wpa_s, ssid + 2, ssid[1], res, fetch_time);\n\telse {\n\t\tbss = wpa_bss_update(wpa_s, bss, res, fetch_time);\n\t\tif (wpa_s->last_scan_res) {\n\t\t\tunsigned int i;\n\t\t\tfor (i = 0; i < wpa_s->last_scan_res_used; i++) {\n\t\t\t\tif (bss == wpa_s->last_scan_res[i]) {\n\t\t\t\t\t/* Already in the list */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bss == NULL)\n\t\treturn;\n\tif (wpa_s->last_scan_res_used >= wpa_s->last_scan_res_size) {\n\t\tstruct wpa_bss **n;\n\t\tunsigned int siz;\n\t\tif (wpa_s->last_scan_res_size == 0)\n\t\t\tsiz = 32;\n\t\telse\n\t\t\tsiz = wpa_s->last_scan_res_size * 2;\n\t\tn = os_realloc_array(wpa_s->last_scan_res, siz,\n\t\t\t\t     sizeof(struct wpa_bss *));\n\t\tif (n == NULL)\n\t\t\treturn;\n\t\twpa_s->last_scan_res = n;\n\t\twpa_s->last_scan_res_size = siz;\n\t}\n\n\tif (wpa_s->last_scan_res)\n\t\twpa_s->last_scan_res[wpa_s->last_scan_res_used++] = bss;\n}", "path": "esp-idf/components/wpa_supplicant/src/common/bss.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "espressif/esp-idf", "stars": 12155, "license": "apache-2.0", "language": "c", "size": 264987}
{"docstring": "/**\n * @brief PPP low level output callback used to transmit data using standard esp-netif interafce\n *\n * @param pcb PPP control block\n * @param data Buffer to write to serial port\n * @param len Length of the data buffer\n * @param ctx Context of callback\n *\n * @return uint32_t Length of data successfully sent\n */\n", "func_signal": "static uint32_t pppos_low_level_output(ppp_pcb *pcb, uint8_t *data, uint32_t len, void *netif)", "code": "{\n    esp_err_t ret = esp_netif_transmit(netif, data, len);\n    if (ret == ESP_OK) {\n        return len;\n    }\n    return 0;\n}", "path": "esp-idf/components/esp_netif/lwip/esp_netif_lwip_ppp.c", "commit_date": "2020-10-26 00:00:00", "repo_name": "espressif/esp-idf", "stars": 12155, "license": "apache-2.0", "language": "c", "size": 264987}
{"docstring": "/**\n * @brief Clock calibration function used by rtc_clk_cal and rtc_clk_cal_ratio\n * @param cal_clk which clock to calibrate\n * @param slowclk_cycles number of slow clock cycles to count. Max value is 32766.\n * @return number of XTAL clock cycles within the given number of slow clock cycles\n */\n", "func_signal": "static uint32_t rtc_clk_cal_internal(rtc_cal_sel_t cal_clk, uint32_t slowclk_cycles)", "code": "{\n    assert(slowclk_cycles < 32767);\n    /* Enable requested clock (150k clock is always on) */\n    int dig_32k_xtal_state = REG_GET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN);\n    if (cal_clk == RTC_CAL_32K_XTAL && !dig_32k_xtal_state) {\n        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN, 1);\n    }\n\n    if (cal_clk == RTC_CAL_8MD256) {\n        SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_CLK8M_D256_EN);\n    }\n    /* Prepare calibration */\n    REG_SET_FIELD(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_CLK_SEL, cal_clk);\n    CLEAR_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START_CYCLING);\n    REG_SET_FIELD(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_MAX, slowclk_cycles);\n    /* Figure out how long to wait for calibration to finish */\n    uint32_t expected_freq;\n    rtc_slow_freq_t slow_freq = REG_GET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL);\n    if (cal_clk == RTC_CAL_32K_XTAL ||\n        (cal_clk == RTC_CAL_RTC_MUX && slow_freq == RTC_SLOW_FREQ_32K_XTAL)) {\n        expected_freq = 32768; /* standard 32k XTAL */\n    } else if (cal_clk == RTC_CAL_8MD256 ||\n            (cal_clk == RTC_CAL_RTC_MUX && slow_freq == RTC_SLOW_FREQ_8MD256)) {\n        expected_freq = RTC_FAST_CLK_FREQ_APPROX / 256;\n    } else {\n        expected_freq = 150000; /* 150k internal oscillator */\n    }\n    uint32_t us_time_estimate = (uint32_t) (((uint64_t) slowclk_cycles) * MHZ / expected_freq);\n    /* Check if the required number of slowclk_cycles may result in an overflow of TIMG_RTC_CALI_VALUE */\n    rtc_xtal_freq_t xtal_freq = rtc_clk_xtal_freq_get();\n    if (xtal_freq == RTC_XTAL_FREQ_AUTO) {\n        /* XTAL frequency is not known yet; assume worst case (40 MHz) */\n        xtal_freq = RTC_XTAL_FREQ_40M;\n    }\n    const uint32_t us_timer_max =  TIMG_RTC_CALI_VALUE / (uint32_t) xtal_freq;\n    if (us_time_estimate >= us_timer_max) {\n        SOC_LOGE(TAG, \"slowclk_cycles value too large, possible overflow\");\n        return 0;\n    }\n    /* Start calibration */\n    CLEAR_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START);\n    SET_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START);\n    /* Wait the expected time calibration should take.\n     * TODO: if running under RTOS, and us_time_estimate > RTOS tick, use the\n     * RTOS delay function.\n     */\n    esp_rom_delay_us(us_time_estimate);\n    /* Wait for calibration to finish up to another us_time_estimate */\n    int timeout_us = us_time_estimate;\n    while (!GET_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_RDY) &&\n            timeout_us > 0) {\n        timeout_us--;\n        esp_rom_delay_us(1);\n    }\n\n    REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN, dig_32k_xtal_state);\n\n    if (cal_clk == RTC_CAL_8MD256) {\n        CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_CLK8M_D256_EN);\n    }\n    if (timeout_us == 0) {\n        /* timed out waiting for calibration */\n        return 0;\n    }\n\n    return REG_GET_FIELD(TIMG_RTCCALICFG1_REG(0), TIMG_RTC_CALI_VALUE);\n}", "path": "esp-idf/components/esp_hw_support/port/esp32/rtc_time.c", "commit_date": "2020-12-22 00:00:00", "repo_name": "espressif/esp-idf", "stars": 12155, "license": "apache-2.0", "language": "c", "size": 264987}
{"docstring": "/*\n * wpas_rrm_reset - Clear and reset all RRM data in wpa_supplicant\n * @wpa_s: Pointer to wpa_supplicant\n */\n", "func_signal": "void wpas_rrm_reset(struct wpa_supplicant *wpa_s)", "code": "{\n\twpa_s->rrm.rrm_used = 0;\n\n\teloop_cancel_timeout(wpas_rrm_neighbor_rep_timeout_handler, &wpa_s->rrm,\n\t\t\t     NULL);\n\tif (wpa_s->rrm.notify_neighbor_rep)\n\t\twpas_rrm_neighbor_rep_timeout_handler(&wpa_s->rrm, NULL);\n\twpa_s->rrm.next_neighbor_rep_token = 1;\n\twpas_clear_beacon_rep_data(wpa_s);\n}", "path": "esp-idf/components/wpa_supplicant/src/common/rrm.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "espressif/esp-idf", "stars": 12155, "license": "apache-2.0", "language": "c", "size": 264987}
{"docstring": "/**\n * wpa_bss_init - Initialize BSS table\n * @wpa_s: Pointer to wpa_supplicant data\n * Returns: 0 on success, -1 on failure\n *\n * This prepares BSS table lists and timer for periodic updates. The BSS table\n * is deinitialized with wpa_bss_deinit() once not needed anymore.\n */\n", "func_signal": "int wpa_bss_init(struct wpa_supplicant *wpa_s)", "code": "{\n\tdl_list_init(&wpa_s->bss);\n\tdl_list_init(&wpa_s->bss_id);\n\treturn 0;\n}", "path": "esp-idf/components/wpa_supplicant/src/common/bss.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "espressif/esp-idf", "stars": 12155, "license": "apache-2.0", "language": "c", "size": 264987}
{"docstring": "/* CONFIG_RSN_TESTING */\n", "func_signal": "static int wpa_write_wpa_ie(struct wpa_auth_config *conf, u8 *buf, size_t len)", "code": "{\n\tstruct wpa_ie_hdr *hdr;\n\tint num_suites;\n\tu8 *pos, *count;\n\tu32 suite;\n\n\thdr = (struct wpa_ie_hdr *) buf;\n\thdr->elem_id = WLAN_EID_VENDOR_SPECIFIC;\n\tRSN_SELECTOR_PUT(hdr->oui, WPA_OUI_TYPE);\n\tWPA_PUT_LE16(hdr->version, WPA_VERSION);\n\tpos = (u8 *) (hdr + 1);\n\n\tsuite = wpa_cipher_to_suite(WPA_PROTO_WPA, conf->wpa_group);\n\tif (suite == 0) {\n\t\twpa_printf( MSG_DEBUG, \"Invalid group cipher (%d).\",\n\t\t\t   conf->wpa_group);\n\t\treturn -1;\n\t}\n\tRSN_SELECTOR_PUT(pos, suite);\n\tpos += WPA_SELECTOR_LEN;\n\n\tcount = pos;\n\tpos += 2;\n\n\tnum_suites = wpa_cipher_put_suites(pos, conf->wpa_pairwise);\n\tif (num_suites == 0) {\n\t\twpa_printf( MSG_DEBUG, \"Invalid pairwise cipher (%d).\",\n\t\t\t   conf->wpa_pairwise);\n\t\treturn -1;\n\t}\n\tpos += num_suites * WPA_SELECTOR_LEN;\n\tWPA_PUT_LE16(count, num_suites);\n\n\tnum_suites = 0;\n\tcount = pos;\n\tpos += 2;\n\n\tif (conf->wpa_key_mgmt & WPA_KEY_MGMT_IEEE8021X) {\n\t\tRSN_SELECTOR_PUT(pos, WPA_AUTH_KEY_MGMT_UNSPEC_802_1X);\n\t\tpos += WPA_SELECTOR_LEN;\n\t\tnum_suites++;\n\t}\n\tif (conf->wpa_key_mgmt & WPA_KEY_MGMT_PSK) {\n\t\tRSN_SELECTOR_PUT(pos, WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X);\n\t\tpos += WPA_SELECTOR_LEN;\n\t\tnum_suites++;\n\t}\n\n\tif (num_suites == 0) {\n\t\twpa_printf( MSG_DEBUG, \"Invalid key management type (%d).\",\n\t\t\t   conf->wpa_key_mgmt);\n\t\treturn -1;\n\t}\n\tWPA_PUT_LE16(count, num_suites);\n\n\t/* WPA Capabilities; use defaults, so no need to include it */\n\n\thdr->len = (pos - buf) - 2;\n\n\treturn pos - buf;\n}", "path": "esp-idf/components/wpa_supplicant/src/ap/wpa_auth_ie.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "espressif/esp-idf", "stars": 12155, "license": "apache-2.0", "language": "c", "size": 264987}
{"docstring": "/**\n * wpa_parse_generic - Parse EAPOL-Key Key Data Generic IEs\n * @pos: Pointer to the IE header\n * @end: Pointer to the end of the Key Data buffer\n * @ie: Pointer to parsed IE data\n * Returns: 0 on success, 1 if end mark is found, -1 on failure\n */\n", "func_signal": "static int wpa_parse_generic(const u8 *pos, const u8 *end,\n\t\t\t     struct wpa_eapol_ie_parse *ie)", "code": "{\n\tif (pos[1] == 0)\n\t\treturn 1;\n\n\tif (pos[1] >= 6 &&\n\t    RSN_SELECTOR_GET(pos + 2) == WPA_OUI_TYPE &&\n\t    pos[2 + WPA_SELECTOR_LEN] == 1 &&\n\t    pos[2 + WPA_SELECTOR_LEN + 1] == 0) {\n\t\tie->wpa_ie = pos;\n\t\tie->wpa_ie_len = pos[1] + 2;\n\t\treturn 0;\n\t}\n\n\tif (pos + 1 + RSN_SELECTOR_LEN < end &&\n\t    pos[1] >= RSN_SELECTOR_LEN + PMKID_LEN &&\n\t    RSN_SELECTOR_GET(pos + 2) == RSN_KEY_DATA_PMKID) {\n\t\tie->pmkid = pos + 2 + RSN_SELECTOR_LEN;\n\t\treturn 0;\n\t}\n\n\tif (pos[1] > RSN_SELECTOR_LEN + 2 &&\n\t    RSN_SELECTOR_GET(pos + 2) == RSN_KEY_DATA_GROUPKEY) {\n\t\tie->gtk = pos + 2 + RSN_SELECTOR_LEN;\n\t\tie->gtk_len = pos[1] - RSN_SELECTOR_LEN;\n\t\treturn 0;\n\t}\n\n\tif (pos[1] > RSN_SELECTOR_LEN + 2 &&\n\t    RSN_SELECTOR_GET(pos + 2) == RSN_KEY_DATA_MAC_ADDR) {\n\t\tie->mac_addr = pos + 2 + RSN_SELECTOR_LEN;\n\t\tie->mac_addr_len = pos[1] - RSN_SELECTOR_LEN;\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_PEERKEY\n\tif (pos[1] > RSN_SELECTOR_LEN + 2 &&\n\t    RSN_SELECTOR_GET(pos + 2) == RSN_KEY_DATA_SMK) {\n\t\tie->smk = pos + 2 + RSN_SELECTOR_LEN;\n\t\tie->smk_len = pos[1] - RSN_SELECTOR_LEN;\n\t\treturn 0;\n\t}\n\n\tif (pos[1] > RSN_SELECTOR_LEN + 2 &&\n\t    RSN_SELECTOR_GET(pos + 2) == RSN_KEY_DATA_NONCE) {\n\t\tie->nonce = pos + 2 + RSN_SELECTOR_LEN;\n\t\tie->nonce_len = pos[1] - RSN_SELECTOR_LEN;\n\t\treturn 0;\n\t}\n\n\tif (pos[1] > RSN_SELECTOR_LEN + 2 &&\n\t    RSN_SELECTOR_GET(pos + 2) == RSN_KEY_DATA_LIFETIME) {\n\t\tie->lifetime = pos + 2 + RSN_SELECTOR_LEN;\n\t\tie->lifetime_len = pos[1] - RSN_SELECTOR_LEN;\n\t\treturn 0;\n\t}\n\n\tif (pos[1] > RSN_SELECTOR_LEN + 2 &&\n\t    RSN_SELECTOR_GET(pos + 2) == RSN_KEY_DATA_ERROR) {\n\t\tie->error = pos + 2 + RSN_SELECTOR_LEN;\n\t\tie->error_len = pos[1] - RSN_SELECTOR_LEN;\n\t\treturn 0;\n\t}\n#endif /* CONFIG_PEERKEY */\n\n#ifdef CONFIG_IEEE80211W\n\tif (pos[1] > RSN_SELECTOR_LEN + 2 &&\n\t    RSN_SELECTOR_GET(pos + 2) == RSN_KEY_DATA_IGTK) {\n\t\tie->igtk = pos + 2 + RSN_SELECTOR_LEN;\n\t\tie->igtk_len = pos[1] - RSN_SELECTOR_LEN;\n\t\treturn 0;\n\t}\n#endif /* CONFIG_IEEE80211W */\n\n\treturn 0;\n}", "path": "esp-idf/components/wpa_supplicant/src/ap/wpa_auth_ie.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "espressif/esp-idf", "stars": 12155, "license": "apache-2.0", "language": "c", "size": 264987}
{"docstring": "/**\n * @brief Checks if any subprotocols from the comma seperated list matches the supported one\n *\n * @param supported_subprotocol[in] The subprotocol supported by the URI\n * @param subprotocol[in],  [in]: A comma seperate list of subprotocols requested\n * @param buf_len Length of the buffer\n * @return true: found a matching subprotocol\n * @return false\n */\n", "func_signal": "static bool httpd_ws_get_response_subprotocol(const char *supported_subprotocol, char *subprotocol, size_t buf_len)", "code": "{\n    /* Request didnt contain any subprotocols */\n    if (strnlen(subprotocol, buf_len) == 0) {\n        return false;\n    }\n\n    if (supported_subprotocol == NULL) {\n        ESP_LOGW(TAG, \"Sec-WebSocket-Protocol %s not supported, URI do not support any subprotocols\", subprotocol);\n        return false;\n    }\n\n    /* Get first subprotocol from comma seperated list */\n    char *rest = NULL;\n    char *s = strtok_r(subprotocol, \", \", &rest);\n    do {\n        if (strncmp(s, supported_subprotocol, sizeof(subprotocol)) == 0) {\n            ESP_LOGD(TAG, \"Requested subprotocol supported: %s\", s);\n            return true;\n        }\n    } while ((s = strtok_r(NULL, \", \", &rest)) != NULL);\n\n    ESP_LOGW(TAG, \"Sec-WebSocket-Protocol %s not supported, supported subprotocol is %s\", subprotocol, supported_subprotocol);\n\n    /* No matches */\n    return false;\n\n}", "path": "esp-idf/components/esp_http_server/src/httpd_ws.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "espressif/esp-idf", "stars": 12155, "license": "apache-2.0", "language": "c", "size": 264987}
{"docstring": "/**\n * Returns 0 if the next element can be processed, 1 if some operation was\n * triggered, and -1 if processing failed (i.e., the element is in invalid\n * format or an internal error occurred).\n */\n", "func_signal": "static int\nwpas_rm_handle_beacon_req(struct wpa_supplicant *wpa_s,\n\t\t\t  u8 elem_token, int duration_mandatory,\n\t\t\t  const struct rrm_measurement_beacon_request *req,\n\t\t\t  size_t len, struct wpabuf **buf)", "code": "{\n\tstruct beacon_rep_data *data = &wpa_s->beacon_rep_data;\n\tstruct wpa_driver_scan_params *params = &data->scan_params;\n\tconst u8 *subelems;\n\tsize_t elems_len;\n\tu16 rand_interval;\n\tu32 interval_usec;\n\tu32 _rand;\n\tint ret = 0, res;\n\tu8 reject_mode;\n\n\tif (len < sizeof(*req))\n\t\treturn -1;\n\n\tif (req->mode != BEACON_REPORT_MODE_PASSIVE &&\n\t    req->mode != BEACON_REPORT_MODE_ACTIVE &&\n\t    req->mode != BEACON_REPORT_MODE_TABLE)\n\t\treturn 0;\n\n\tsubelems = req->variable;\n\telems_len = len - sizeof(*req);\n\trand_interval = le_to_host16(req->rand_interval);\n\n\tos_memset(data, 0, sizeof(*data));\n\n\tdata->token = elem_token;\n\n\t/* default reporting detail is all fixed length fields and all\n\t * elements */\n\tdata->report_detail = BEACON_REPORT_DETAIL_ALL_FIELDS_AND_ELEMENTS;\n\tos_memcpy(data->bssid, req->bssid, ETH_ALEN);\n\n\twhile (elems_len >= 2) {\n\t\tif (subelems[1] > elems_len - 2) {\n\t\t\twpa_printf(MSG_DEBUG,\n\t\t\t\t   \"Beacon Request: Truncated subelement\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = wpas_rm_handle_beacon_req_subelem(\n\t\t\twpa_s, data, subelems[0], subelems[1], &subelems[2]);\n\t\tif (res < 0) {\n\t\t\tret = res;\n\t\t\tgoto out;\n\t\t} else if (!res) {\n\t\t\treject_mode = MEASUREMENT_REPORT_MODE_REJECT_INCAPABLE;\n\t\t\tgoto out_reject;\n\t\t}\n\n\t\telems_len -= 2 + subelems[1];\n\t\tsubelems += 2 + subelems[1];\n\t}\n\n\tif (req->mode == BEACON_REPORT_MODE_TABLE) {\n\t\twpas_beacon_rep_table(wpa_s, buf);\n\t\tgoto out;\n\t}\n\tparams->channel = req->channel;\n\tparams->duration = le_to_host16(req->duration);\n\tparams->duration_mandatory = duration_mandatory;\n\tif (!params->duration) {\n\t\twpa_printf(MSG_DEBUG, \"Beacon request: Duration is 0\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (data->ssid_len) {\n\t\tparams->ssids[params->num_ssids].ssid = data->ssid;\n\t\tparams->ssids[params->num_ssids++].ssid_len = data->ssid_len;\n\t}\n\n\tif (os_get_random((u8 *) &_rand, sizeof(_rand)) < 0)\n\t\t_rand = os_random();\n\tinterval_usec = (_rand % (rand_interval + 1)) * 1024;\n\tos_sleep(0, interval_usec);\n\twpas_rrm_scan_timeout(wpa_s, NULL);\n\treturn 1;\nout_reject:\n\tif (!is_multicast_ether_addr(wpa_s->rrm.dst_addr) &&\n\t    wpas_rrm_report_elem(buf, elem_token, reject_mode,\n\t\t\t\t MEASURE_TYPE_BEACON, NULL, 0) < 0) {\n\t\twpa_printf(MSG_DEBUG, \"RRM: Failed to add report element\");\n\t\tret = -1;\n\t}\nout:\n\twpas_clear_beacon_rep_data(wpa_s);\n\treturn ret;\n}", "path": "esp-idf/components/wpa_supplicant/src/common/rrm.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "espressif/esp-idf", "stars": 12155, "license": "apache-2.0", "language": "c", "size": 264987}
{"docstring": "/**\n * wpa_bss_flush - Flush all unused BSS entries\n * @wpa_s: Pointer to wpa_supplicant data\n */\n", "func_signal": "void wpa_bss_flush(struct wpa_supplicant *wpa_s)", "code": "{\n\tstruct wpa_bss *bss, *n;\n\n\tif (wpa_s->bss.next == NULL)\n\t\treturn; /* BSS table not yet initialized */\n\n\tdl_list_for_each_safe(bss, n, &wpa_s->bss, struct wpa_bss, list) {\n\t\tif (wpa_bss_in_use(wpa_s, bss))\n\t\t\tcontinue;\n\t\twpa_bss_remove(wpa_s, bss, __func__);\n\t}\n}", "path": "esp-idf/components/wpa_supplicant/src/common/bss.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "espressif/esp-idf", "stars": 12155, "license": "apache-2.0", "language": "c", "size": 264987}
{"docstring": "/*\n * wpas_rrm_process_neighbor_rep - Handle incoming neighbor report\n * @wpa_s: Pointer to wpa_supplicant\n * @report: Neighbor report buffer, prefixed by a 1-byte dialog token\n * @report_len: Length of neighbor report buffer\n */\n", "func_signal": "void wpas_rrm_process_neighbor_rep(struct wpa_supplicant *wpa_s,\n\t\t\t\t   const u8 *report, size_t report_len)", "code": "{\n\n\twpa_hexdump(MSG_DEBUG, \"RRM: New Neighbor Report\", report, report_len);\n\tif (report_len < 1)\n\t\treturn;\n\n\tif (report[0] != wpa_s->rrm.next_neighbor_rep_token - 1) {\n\t\twpa_printf(MSG_DEBUG,\n\t\t\t   \"RRM: Discarding neighbor report with token %d (expected %d)\",\n\t\t\t   report[0], wpa_s->rrm.next_neighbor_rep_token - 1);\n\t\treturn;\n\t}\n\n\teloop_cancel_timeout(wpas_rrm_neighbor_rep_timeout_handler, &wpa_s->rrm,\n\t\t\t     NULL);\n\n\tif (!wpa_s->rrm.notify_neighbor_rep) {\n\t\twpa_msg(wpa_s, MSG_INFO, \"RRM: Unexpected neighbor report\");\n\t\treturn;\n\t}\n\n\twpa_printf(MSG_DEBUG, \"RRM: Notifying neighbor report (token = %d)\",\n\t\treport[0]);\n\twpa_s->rrm.notify_neighbor_rep(wpa_s->rrm.neighbor_rep_cb_ctx,\n\t\t\t\t       report, report_len);\n\twpa_s->rrm.notify_neighbor_rep = NULL;\n\twpa_s->rrm.neighbor_rep_cb_ctx = NULL;\n}", "path": "esp-idf/components/wpa_supplicant/src/common/rrm.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "espressif/esp-idf", "stars": 12155, "license": "apache-2.0", "language": "c", "size": 264987}
{"docstring": "/**\n * wpa_parse_kde_ies - Parse EAPOL-Key Key Data IEs\n * @buf: Pointer to the Key Data buffer\n * @len: Key Data Length\n * @ie: Pointer to parsed IE data\n * Returns: 0 on success, -1 on failure\n */\n", "func_signal": "int wpa_parse_kde_ies(const u8 *buf, size_t len, struct wpa_eapol_ie_parse *ie)", "code": "{\n\tconst u8 *pos, *end;\n\tint ret = 0;\n\n\tmemset(ie, 0, sizeof(*ie));\n\tfor (pos = buf, end = pos + len; pos + 1 < end; pos += 2 + pos[1]) {\n\t\tif (pos[0] == 0xdd &&\n\t\t    ((pos == buf + len - 1) || pos[1] == 0)) {\n\t\t\t/* Ignore padding */\n\t\t\tbreak;\n\t\t}\n\t\tif (pos + 2 + pos[1] > end) {\n\t\t\twpa_printf( MSG_DEBUG, \"WPA: EAPOL-Key Key Data \"\n\t\t\t\t   \"underflow (ie=%d len=%d pos=%d)\",\n\t\t\t\t   pos[0], pos[1], (int) (pos - buf));\n\t\t\twpa_hexdump_key(MSG_DEBUG, \"WPA: Key Data\",\n\t\t\t\t\tbuf, len);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif (*pos == WLAN_EID_RSN) {\n\t\t\tie->rsn_ie = pos;\n\t\t\tie->rsn_ie_len = pos[1] + 2;\n#ifdef CONFIG_IEEE80211R\n\t\t} else if (*pos == WLAN_EID_MOBILITY_DOMAIN) {\n\t\t\tie->mdie = pos;\n\t\t\tie->mdie_len = pos[1] + 2;\n\t\t} else if (*pos == WLAN_EID_FAST_BSS_TRANSITION) {\n\t\t\tie->ftie = pos;\n\t\t\tie->ftie_len = pos[1] + 2;\n#endif /* CONFIG_IEEE80211R */\n\t\t} else if (*pos == WLAN_EID_VENDOR_SPECIFIC) {\n\t\t\tret = wpa_parse_generic(pos, end, ie);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tif (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\twpa_hexdump(MSG_DEBUG, \"WPA: Unrecognized EAPOL-Key \"\n\t\t\t\t    \"Key Data IE\", pos, 2 + pos[1]);\n\t\t}\n\t}\n\n\treturn ret;\n}", "path": "esp-idf/components/wpa_supplicant/src/ap/wpa_auth_ie.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "espressif/esp-idf", "stars": 12155, "license": "apache-2.0", "language": "c", "size": 264987}
{"docstring": "/**\n * wpa_bss_get_bssid - Fetch a BSS table entry based on BSSID\n * @wpa_s: Pointer to wpa_supplicant data\n * @bssid: BSSID\n * Returns: Pointer to the BSS entry or %NULL if not found\n */\n", "func_signal": "struct wpa_bss * wpa_bss_get_bssid(struct wpa_supplicant *wpa_s,\n\t\t\t\t   const u8 *bssid)", "code": "{\n\tstruct wpa_bss *bss;\n\tdl_list_for_each_reverse(bss, &wpa_s->bss, struct wpa_bss, list) {\n\t\tif (os_memcmp(bss->bssid, bssid, ETH_ALEN) == 0)\n\t\t\treturn bss;\n\t}\n\treturn NULL;\n}", "path": "esp-idf/components/wpa_supplicant/src/common/bss.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "espressif/esp-idf", "stars": 12155, "license": "apache-2.0", "language": "c", "size": 264987}
{"docstring": "/* handle 'quit' command */\n", "func_signal": "static int do_cmd_quit(int argc, char **argv)", "code": "{\n    printf(\"ByeBye\\r\\n\");\n    s_repl->del(s_repl);\n    return 0;\n}", "path": "esp-idf/examples/protocols/icmp_echo/main/echo_example_main.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "espressif/esp-idf", "stars": 12155, "license": "apache-2.0", "language": "c", "size": 264987}
{"docstring": "/**\n * wpa_bss_get_next_bss - Fetch a next BSS table entry from the list\n * @wpa_s: Pointer to wpa_supplicant data\n * @bss: BSS\n * Returns: Pointer to the BSS entry or %NULL if not found\n */\n", "func_signal": "struct wpa_bss * wpa_bss_get_next_bss(struct wpa_supplicant *wpa_s,\n\t\t\t\t   struct wpa_bss *prev_bss)", "code": "{\n\tstruct wpa_bss *bss;\n\n\tif (!prev_bss)\n\t\treturn dl_list_first(&wpa_s->bss, struct wpa_bss, list);\n\tdl_list_for_each(bss, &wpa_s->bss, struct wpa_bss, list) {\n\t\tif (os_memcmp(bss->bssid, prev_bss->bssid, ETH_ALEN) == 0)\n\t\t\treturn dl_list_entry(bss->list.next, struct wpa_bss, list);\n\t}\n\treturn NULL;\n}", "path": "esp-idf/components/wpa_supplicant/src/common/bss.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "espressif/esp-idf", "stars": 12155, "license": "apache-2.0", "language": "c", "size": 264987}
{"docstring": "/**\n * @brief Notify phase callback which is called on each PPP internal state change\n *\n * @param pcb PPP control block\n * @param phase Phase ID\n * @param ctx Context of callback\n */\n", "func_signal": "static void on_ppp_notify_phase(ppp_pcb *pcb, u8_t phase, void *ctx)", "code": "{\n    switch (phase) {\n        case PPP_PHASE_DEAD:\n            ESP_LOGD(TAG, \"Phase Dead\");\n            break;\n        case PPP_PHASE_INITIALIZE:\n            ESP_LOGD(TAG, \"Phase Start\");\n            break;\n        case PPP_PHASE_ESTABLISH:\n            ESP_LOGD(TAG, \"Phase Establish\");\n            break;\n        case PPP_PHASE_AUTHENTICATE:\n            ESP_LOGD(TAG, \"Phase Authenticate\");\n            break;\n        case PPP_PHASE_NETWORK:\n            ESP_LOGD(TAG, \"Phase Network\");\n            break;\n        case PPP_PHASE_RUNNING:\n            ESP_LOGD(TAG, \"Phase Running\");\n            break;\n        case PPP_PHASE_TERMINATE:\n            ESP_LOGD(TAG, \"Phase Terminate\");\n            break;\n        case PPP_PHASE_DISCONNECT:\n            ESP_LOGD(TAG, \"Phase Disconnect\");\n            break;\n        default:\n            ESP_LOGW(TAG, \"Phase Unknown: %d\", phase);\n            break;\n    }\n    esp_netif_t *netif = ctx;\n    lwip_peer2peer_ctx_t *obj = (lwip_peer2peer_ctx_t *)netif->related_data;\n    assert(obj->base.netif_type == PPP_LWIP_NETIF);\n    if (obj && obj->ppp_phase_event_enabled) {\n        esp_err_t err = esp_event_post(NETIF_PPP_STATUS, NETIF_PP_PHASE_OFFSET + phase, &netif, sizeof(netif), 0);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"esp_event_post failed with code %d\", err);\n        }\n    }\n}", "path": "esp-idf/components/esp_netif/lwip/esp_netif_lwip_ppp.c", "commit_date": "2020-10-26 00:00:00", "repo_name": "espressif/esp-idf", "stars": 12155, "license": "apache-2.0", "language": "c", "size": 264987}
{"docstring": "/* handler for bluetooth stack enabled events */\n", "func_signal": "static void bt_hf_hdl_stack_evt(uint16_t event, void *p_param)", "code": "{\n    ESP_LOGD(BT_HF_TAG, \"%s evt %d\", __func__, event);\n    switch (event)\n    {\n        case BT_APP_EVT_STACK_UP:\n        {\n            /* set up device name */\n            char *dev_name = \"ESP_HFP_AG\";\n            esp_bt_dev_set_device_name(dev_name);\n\n            esp_bt_hf_register_callback(bt_app_hf_cb);\n\n            // init and register for HFP_AG functions\n            esp_bt_hf_init(hf_peer_addr);\n\n            /*\n            * Set default parameters for Legacy Pairing\n            * Use variable pin, input pin code when pairing\n            */\n            esp_bt_pin_type_t pin_type = ESP_BT_PIN_TYPE_VARIABLE;\n            esp_bt_pin_code_t pin_code;\n            pin_code[0] = '0';\n            pin_code[1] = '0';\n            pin_code[2] = '0';\n            pin_code[3] = '0';\n            esp_bt_gap_set_pin(pin_type, 4, pin_code);\n\n            /* set discoverable and connectable mode, wait to be connected */\n            esp_bt_gap_set_scan_mode(ESP_BT_CONNECTABLE, ESP_BT_GENERAL_DISCOVERABLE);\n            break;\n        }\n        default:\n            ESP_LOGE(BT_HF_TAG, \"%s unhandled evt %d\", __func__, event);\n            break;\n    }\n}", "path": "esp-idf/examples/bluetooth/bluedroid/classic_bt/hfp_ag/main/main.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "espressif/esp-idf", "stars": 12155, "license": "apache-2.0", "language": "c", "size": 264987}
{"docstring": "/**\n * wpa_bss_get - Fetch a BSS table entry based on BSSID and SSID\n * @wpa_s: Pointer to wpa_supplicant data\n * @bssid: BSSID\n * @ssid: SSID\n * @ssid_len: Length of @ssid\n * Returns: Pointer to the BSS entry or %NULL if not found\n */\n", "func_signal": "struct wpa_bss * wpa_bss_get(struct wpa_supplicant *wpa_s, const u8 *bssid,\n\t\t\t     const u8 *ssid, size_t ssid_len)", "code": "{\n\tstruct wpa_bss *bss;\n\tdl_list_for_each(bss, &wpa_s->bss, struct wpa_bss, list) {\n\t\tif (os_memcmp(bss->bssid, bssid, ETH_ALEN) == 0 &&\n\t\t    bss->ssid_len == ssid_len &&\n\t\t    os_memcmp(bss->ssid, ssid, ssid_len) == 0)\n\t\t\treturn bss;\n\t}\n\treturn NULL;\n}", "path": "esp-idf/components/wpa_supplicant/src/common/bss.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "espressif/esp-idf", "stars": 12155, "license": "apache-2.0", "language": "c", "size": 264987}
{"docstring": "// ---------------- BUFFER MANIPULATION -------------\n", "func_signal": "char*  bufcon_putc( char *buffer, unsigned char c )", "code": "{\n  unsigned char str[2];\n   \n     str[0] = c;\n     str[1] = 0;\n     \n     strcat( buffer,(const char*)str );\n     \n  return buffer;\n}", "path": "How-to-Make-a-Computer-Operating-System/src/sdk/src/libc/src/stdio/support_bufio.c", "commit_date": "2013-11-30 00:00:00", "repo_name": "SamyPesse/How-to-Make-a-Computer-Operating-System", "stars": 20829, "license": "apache-2.0", "language": "c", "size": 5986}
{"docstring": "/*************************************************************************\n * trio_get_alternative / trio_set_alternative [public]\n */\n", "func_signal": "int\ntrio_get_alternative\nTRIO_ARGS1((ref),\n\t   trio_pointer_t ref)", "code": "{\n  return (((trio_reference_t *)ref)->parameter->flags & FLAGS_ALTERNATIVE)\n    ? TRUE\n    : FALSE;\n}", "path": "How-to-Make-a-Computer-Operating-System/src/sdk/src/libc/src/trio/trio.c", "commit_date": "2013-11-30 00:00:00", "repo_name": "SamyPesse/How-to-Make-a-Computer-Operating-System", "stars": 20829, "license": "apache-2.0", "language": "c", "size": 5986}
{"docstring": "/*************************************************************************\n * TrioReadGroup\n *\n * FIXME: characterclass does not work with multibyte characters\n */\n", "func_signal": "TRIO_PRIVATE BOOLEAN_T\nTrioReadGroup\nTRIO_ARGS5((self, target, characterclass, flags, width),\n\t   trio_class_t *self,\n\t   char *target,\n\t   int *characterclass,\n\t   trio_flags_t flags,\n\t   int width)", "code": "{\n  int ch;\n  int i;\n  \n  assert(VALID(self));\n  assert(VALID(self->InStream));\n\n  ch = self->current;\n  for (i = 0;\n       ((width == NO_WIDTH) || (i < width)) &&\n       (! ((ch == EOF) ||\n\t   (((flags & FLAGS_EXCLUDE) != 0) ^ (characterclass[ch] == 0))));\n       i++)\n    {\n      if (target)\n\ttarget[i] = (char)ch;\n      self->InStream(self, &ch);\n    }\n  \n  if (target)\n    target[i] = NIL;\n  return TRUE;\n}", "path": "How-to-Make-a-Computer-Operating-System/src/sdk/src/libc/src/trio/trio.c", "commit_date": "2013-11-30 00:00:00", "repo_name": "SamyPesse/How-to-Make-a-Computer-Operating-System", "stars": 20829, "license": "apache-2.0", "language": "c", "size": 5986}
{"docstring": "/*************************************************************************\n * trio_printv_ref [public]\n */\n", "func_signal": "int\ntrio_printv_ref\nTRIO_ARGS3((ref, format, argarray),\n\t   trio_pointer_t ref,\n\t   TRIO_CONST char *format,\n\t   trio_pointer_t *argarray)", "code": "{\n  static va_list unused;\n  \n  assert(VALID(format));\n  \n  return TrioFormatRef((trio_reference_t *)ref, format, unused, argarray);\n}", "path": "How-to-Make-a-Computer-Operating-System/src/sdk/src/libc/src/trio/trio.c", "commit_date": "2013-11-30 00:00:00", "repo_name": "SamyPesse/How-to-Make-a-Computer-Operating-System", "stars": 20829, "license": "apache-2.0", "language": "c", "size": 5986}
{"docstring": "/**\n   Print at most @p max characters to string.\n\n   @param buffer Output string.\n   @param max Maximum number of characters to print.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\n", "func_signal": "TRIO_PUBLIC int\ntrio_snprintfv\nTRIO_ARGS4((buffer, max, format, args),\n\t   char *buffer,\n\t   size_t max,\n\t   TRIO_CONST char *format,\n\t   trio_pointer_t *args)", "code": "{\n  static va_list unused;\n  int status;\n  \n  assert(VALID(buffer));\n  assert(VALID(format));\n\n  status = TrioFormat(&buffer, max > 0 ? max - 1 : 0,\n\t\t      TrioOutStreamStringMax, format, unused, args);\n  if (max > 0)\n    *buffer = NIL;\n  return status;\n}", "path": "How-to-Make-a-Computer-Operating-System/src/sdk/src/libc/src/trio/trio.c", "commit_date": "2013-11-30 00:00:00", "repo_name": "SamyPesse/How-to-Make-a-Computer-Operating-System", "stars": 20829, "license": "apache-2.0", "language": "c", "size": 5986}
{"docstring": "/*************************************************************************\n * trio_get_padding / trio_set_padding [public]\n */\n", "func_signal": "int\ntrio_get_padding\nTRIO_ARGS1((ref),\n\t   trio_pointer_t ref)", "code": "{\n  return (((trio_reference_t *)ref)->parameter->flags & FLAGS_NILPADDING)\n    ? TRUE\n    : FALSE;\n}", "path": "How-to-Make-a-Computer-Operating-System/src/sdk/src/libc/src/trio/trio.c", "commit_date": "2013-11-30 00:00:00", "repo_name": "SamyPesse/How-to-Make-a-Computer-Operating-System", "stars": 20829, "license": "apache-2.0", "language": "c", "size": 5986}
{"docstring": "/*************************************************************************\n * TrioFormat\n */\n", "func_signal": "TRIO_PRIVATE int\nTrioFormat\nTRIO_ARGS6((destination, destinationSize, OutStream, format, arglist, argarray),\n\t   trio_pointer_t destination,\n\t   size_t destinationSize,\n\t   void (*OutStream) TRIO_PROTO((trio_class_t *, int)),\n\t   TRIO_CONST char *format,\n\t   va_list arglist,\n\t   trio_pointer_t *argarray)", "code": "{\n  int status;\n  trio_class_t data;\n  trio_parameter_t parameters[MAX_PARAMETERS];\n\n  assert(VALID(OutStream));\n  assert(VALID(format));\n\n  memset(&data, 0, sizeof(data));\n  data.OutStream = OutStream;\n  data.location = destination;\n  data.max = destinationSize;\n  data.error = 0;\n\n#if defined(USE_LOCALE)\n  if (NULL == internalLocaleValues)\n    {\n      TrioSetLocale();\n    }\n#endif\n\n  status = TrioParse(TYPE_PRINT, format, parameters, arglist, argarray);\n  if (status < 0)\n    return status;\n\n  status = TrioFormatProcess(&data, format, parameters);\n  if (data.error != 0)\n    {\n      status = data.error;\n    }\n  return status;\n}", "path": "How-to-Make-a-Computer-Operating-System/src/sdk/src/libc/src/trio/trio.c", "commit_date": "2013-11-30 00:00:00", "repo_name": "SamyPesse/How-to-Make-a-Computer-Operating-System", "stars": 20829, "license": "apache-2.0", "language": "c", "size": 5986}
{"docstring": "// ---------------- LENGTH OF NUMBERS AND STRINGS ---\n", "func_signal": "int  bufcon_leni(int num)", "code": "{\n  int p;\n  int sign;\n\n      if ( num < 0 ) \n      {\n        p = -num;\n      \tsign = 1;\n      }\n      else\n      {\n        p = num;\n      \tsign = 0;\n      }\n  \n\tif ( p < 10 ) return sign + 1;\n\tif ( p < 100 ) return sign + 2;\n\tif ( p < 1000 ) return sign + 3;\n\tif ( p < 10000 ) return sign + 4;\n\tif ( p < 100000 ) return sign + 5;\n\tif ( p < 1000000 ) return sign + 6;\n\tif ( p < 10000000 ) return sign + 7;\n\tif ( p < 100000000 ) return sign + 8;\n\tif ( p < 1000000000 ) return sign + 9;\n\n  return 10;\n}", "path": "How-to-Make-a-Computer-Operating-System/src/sdk/src/libc/src/stdio/support_bufio.c", "commit_date": "2013-11-30 00:00:00", "repo_name": "SamyPesse/How-to-Make-a-Computer-Operating-System", "stars": 20829, "license": "apache-2.0", "language": "c", "size": 5986}
{"docstring": "/*************************************************************************\n * TrioParse\n *\n * Description:\n *  Parse the format string\n */\n", "func_signal": "TRIO_PRIVATE int\nTrioParse\nTRIO_ARGS5((type, format, parameters, arglist, argarray),\n\t   int type,\n\t   TRIO_CONST char *format,\n\t   trio_parameter_t *parameters,\n\t   va_list arglist,\n\t   trio_pointer_t *argarray)", "code": "{\n  /* Count the number of times a parameter is referenced */\n  unsigned short usedEntries[MAX_PARAMETERS];\n  /* Parameter counters */\n  int parameterPosition;\n  int maxParam = -1;\n  /* Utility variables */\n  int offset;  /* Offset into formatting string */\n  BOOLEAN_T positional;  /* Does the specifier have a positional? */\n#if TRIO_FEATURE_STICKY\n  BOOLEAN_T gotSticky = FALSE;  /* Are there any sticky modifiers at all? */\n#endif\n  /*\n   * indices specifies the order in which the parameters must be\n   * read from the va_args (this is necessary to handle positionals)\n   */\n  int indices[MAX_PARAMETERS];\n  int pos = 0;\n  /* Various variables */\n#if defined(TRIO_COMPILER_SUPPORTS_MULTIBYTE)\n  int charlen;\n#endif\n  int save_errno;\n  int i = -1;\n  int num;\n\n  /*\n   * The 'parameters' array is not initialized, but we need to\n   * know which entries we have used.\n   */\n  memset(usedEntries, 0, sizeof(usedEntries));\n\n  save_errno = errno;\n  offset = 0;\n  parameterPosition = 0;\n#if defined(TRIO_COMPILER_SUPPORTS_MULTIBYTE)\n  (void)mblen(NULL, 0);\n#endif\n  \n  while (format[offset])\n    {\n      trio_parameter_t parameter = {};\n      int status;\n\n#if defined(TRIO_COMPILER_SUPPORTS_MULTIBYTE)\n      if (! isascii(format[offset]))\n\t{\n\t  /*\n\t   * Multibyte characters cannot be legal specifiers or\n\t   * modifiers, so we skip over them.\n\t   */\n\t  charlen = mblen(&format[offset], MB_LEN_MAX);\n\t  offset += (charlen > 0) ? charlen : 1;\n\t  continue; /* while */\n\t}\n#endif /* TRIO_COMPILER_SUPPORTS_MULTIBYTE */\n\n      switch(format[offset++]) {\n\n      case CHAR_IDENTIFIER:\n\t{\n\t  if (CHAR_IDENTIFIER == format[offset])\n\t    {\n\t      /* skip double \"%\" */\n\t      offset++;\n\t      continue; /* while */\n\t    }\n\n\t  status = TrioParseQualifiers(type, format, offset, &parameter);\n\t  if (status < 0)\n\t    return status; /* Return qualifier syntax error */\n\n\t  status = TrioParseSpecifier(type, format, parameter.endOffset, &parameter);\n\t  if (status < 0)\n\t    return status; /* Return specifier syntax error */\n\t}\n\tbreak;\n\n#if TRIO_EXTENSION\n      case CHAR_ALT_IDENTIFIER:\n\t{\n\t  status = TrioParseQualifiers(type, format, offset, &parameter);\n\t  if (status < 0)\n\t    continue; /* False alert, not a user defined specifier */\n\n\t  status = TrioParseSpecifier(type, format, parameter.endOffset, &parameter);\n\t  if ((status < 0) || (FORMAT_USER_DEFINED != parameter.type))\n\t    continue; /* False alert, not a user defined specifier */\n\t}\n\tbreak;\n#endif\n\n      default:\n\tcontinue; /* while */\n      }\n\n      /* now handle the parsed conversion specification */\n      positional = (NO_POSITION != parameter.position);\n\n      /*\n       * Parameters only need the type and value. The value is\n       * read later.\n       */\n      if (parameter.flags & FLAGS_WIDTH_PARAMETER)\n      {\n\t  if (parameter.width == NO_WIDTH)\n\t  {\n\t      parameter.width = parameterPosition++;\n\t  }\n\t  else\n\t  {\n\t      if (! positional)\n\t\t  parameter.position = parameter.width + 1;\n\t  }\n\n\t  usedEntries[parameter.width] += 1;\n\t  if (parameter.width > maxParam) maxParam = parameter.width;\n\t  parameters[pos].type = FORMAT_PARAMETER;\n\t  parameters[pos].flags = 0;\n\t  indices[parameter.width] = pos;\n\t  parameter.width = pos++;\n      }\n      if (parameter.flags & FLAGS_PRECISION_PARAMETER)\n      {\n\t  if (parameter.precision == NO_PRECISION)\n\t  {\n\t      parameter.precision = parameterPosition++;\n\t  }\n\t  else\n\t  {\n\t      if (! positional)\n\t\t  parameter.position = parameter.precision + 1;\n\t  }\n\n\t  usedEntries[parameter.precision] += 1;\n\t  if (parameter.precision > maxParam) maxParam = parameter.precision;\n\t  parameters[pos].type = FORMAT_PARAMETER;\n\t  parameters[pos].flags = 0;\n\t  indices[parameter.precision] = pos;\n\t  parameter.precision = pos++;\n      }\n      if (parameter.flags & FLAGS_BASE_PARAMETER)\n      {\n\t  if (parameter.base == NO_BASE)\n\t  {\n\t      parameter.base = parameterPosition++;\n\t  }\n\t  else\n\t  {\n\t      if (! positional)\n\t\t  parameter.position = parameter.base + 1;\n\t  }\n\n\t  usedEntries[parameter.base] += 1;\n\t  if (parameter.base > maxParam) maxParam = parameter.base;\n\t  parameters[pos].type = FORMAT_PARAMETER;\n\t  parameters[pos].flags = 0;\n\t  indices[parameter.base] = pos;\n\t  parameter.base = pos++;\n      }\n#if TRIO_FEATURE_VARSIZE\n      if (parameter.flags & FLAGS_VARSIZE_PARAMETER)\n      {\n\t  parameter.varsize = parameterPosition++;\n\n\t  usedEntries[parameter.varsize] += 1;\n\t  if (parameter.varsize > maxParam) maxParam = parameter.varsize;\n\t  parameters[pos].type = FORMAT_PARAMETER;\n\t  parameters[pos].flags = 0;\n\t  indices[parameter.varsize] = pos;\n\t  parameter.varsize = pos++;\n      }\n#endif\n#if TRIO_FEATURE_USER_DEFINED\n      if (parameter.flags & FLAGS_USER_DEFINED_PARAMETER)\n      {\n\t  parameter.user_defined.handler = parameterPosition++;\n\n\t  usedEntries[parameter.user_defined.handler] += 1;\n\t  if (parameter.user_defined.handler > maxParam) maxParam = parameter.user_defined.handler;\n\t  parameters[pos].type = FORMAT_PARAMETER;\n\t  parameters[pos].flags = FLAGS_USER_DEFINED;\n\t  indices[parameter.user_defined.handler] = pos;\n\t  parameter.user_defined.handler = pos++;\n      }\n#endif\n\n      if (NO_POSITION == parameter.position) {\n\t  parameter.position = parameterPosition++;\n      }\n\n      if (parameter.position > maxParam) maxParam = parameter.position;\n\n      if (parameter.position >= MAX_PARAMETERS)\n      {\n\t/* Bail out completely to make the error more obvious */\n\treturn TRIO_ERROR_RETURN(TRIO_ETOOMANY, offset);\n      }\n\n      indices[parameter.position] = pos;\n\n      /*  Count the number of times this entry has been used */\n      usedEntries[parameter.position] += 1;\n\n      /* Find last sticky parameters */\n#if TRIO_FEATURE_STICKY\n      if (parameter.flags & FLAGS_STICKY) {\n\tgotSticky = TRUE;\n      } else if (gotSticky) {\n\tfor (i = pos - 1; i >= 0; i--)\n\t{\n\t  if (parameters[i].type == FORMAT_PARAMETER)\n\t    continue;\n\t  if ((parameters[i].flags & FLAGS_STICKY) &&\n\t      (parameters[i].type == parameter.type))\n\t  {\n\t    /* Do not overwrite current qualifiers */\n\t    parameter.flags |= (parameters[i].flags & (unsigned long)~FLAGS_STICKY);\n\t    if (parameter.width == NO_WIDTH)\n\t      parameter.width = parameters[i].width;\n\t    if (parameter.precision == NO_PRECISION)\n\t      parameter.precision = parameters[i].precision;\n\t    if (parameter.base == NO_BASE)\n\t      parameter.base = parameters[i].base;\n\t    break;\n\t  }\n\t}\n      }\n#endif\n\n      if (parameter.base == NO_BASE) parameter.base = BASE_DECIMAL;\n\n      offset = parameter.endOffset;\n\n      memcpy(&parameters[pos++], &parameter, sizeof(parameter));\n    } /* while format characters left */\n\n  parameters[pos].type = FORMAT_SENTINEL;  /* end parameter array with sentinel */\n  parameters[pos].beginOffset = offset;\n\n  for (num = 0; num <= maxParam; num++)\n    {\n      if (usedEntries[num] != 1)\n\t{\n\t  if (usedEntries[num] == 0) /* gap detected */\n\t    return TRIO_ERROR_RETURN(TRIO_EGAP, num);\n\t  else /* double references detected */\n\t    return TRIO_ERROR_RETURN(TRIO_EDBLREF, num);\n\t}\n      \n      i = indices[num];\n\n      /*\n       * FORMAT_PARAMETERS are only present if they must be read,\n       * so it makes no sense to check the ignore flag (besides,\n       * the flags variable is not set for that particular type)\n       */\n      if ((parameters[i].type != FORMAT_PARAMETER) &&\n\t  (parameters[i].flags & FLAGS_IGNORE))\n\tcontinue; /* for all arguments */\n\n      /*\n       * The stack arguments are read according to ANSI C89\n       * default argument promotions:\n       *\n       *  char           = int\n       *  short          = int\n       *  unsigned char  = unsigned int\n       *  unsigned short = unsigned int\n       *  float          = double\n       *\n       * In addition to the ANSI C89 these types are read (the\n       * default argument promotions of C99 has not been\n       * considered yet)\n       *\n       *  long long\n       *  long double\n       *  size_t\n       *  ptrdiff_t\n       *  intmax_t\n       */\n      switch (parameters[i].type)\n\t{\n\tcase FORMAT_GROUP:\n\tcase FORMAT_STRING:\n#if TRIO_FEATURE_WIDECHAR\n\t  if (parameters[i].flags & FLAGS_WIDECHAR)\n\t    {\n\t      parameters[i].data.wstring = (argarray == NULL)\n\t\t? va_arg(arglist, trio_wchar_t *)\n\t\t: (trio_wchar_t *)(argarray[num]);\n\t    }\n\t  else\n#endif\n\t    {\n\t      parameters[i].data.string = (argarray == NULL)\n\t\t? va_arg(arglist, char *)\n\t\t: (char *)(argarray[num]);\n\t    }\n\t  break;\n\n#if TRIO_FEATURE_USER_DEFINED\n\tcase FORMAT_USER_DEFINED:\n#endif\n\tcase FORMAT_POINTER:\n\tcase FORMAT_COUNT:\n\tcase FORMAT_UNKNOWN:\n\t  parameters[i].data.pointer = (argarray == NULL)\n\t    ? va_arg(arglist, trio_pointer_t )\n\t    : argarray[num];\n\t  break;\n\n\tcase FORMAT_CHAR:\n\tcase FORMAT_INT:\n#if TRIO_FEATURE_SCANF\n\t  if (TYPE_SCAN == type)\n\t    {\n              if (argarray == NULL)\n                parameters[i].data.pointer = \n                  (trio_pointer_t)va_arg(arglist, trio_pointer_t);\n              else\n                {\n                  if (parameters[i].type == FORMAT_CHAR)\n                    parameters[i].data.pointer =\n                      (trio_pointer_t)((char *)argarray[num]);\n                  else if (parameters[i].flags & FLAGS_SHORT)\n                    parameters[i].data.pointer =\n                      (trio_pointer_t)((short *)argarray[num]);\n                  else\n                    parameters[i].data.pointer =\n                      (trio_pointer_t)((int *)argarray[num]);\n                }\n\t    }\n\t  else\n#endif /* TRIO_FEATURE_SCANF */\n\t    {\n#if TRIO_FEATURE_VARSIZE || TRIO_FEATURE_FIXED_SIZE\n\t      if (parameters[i].flags\n\t\t  & (FLAGS_VARSIZE_PARAMETER | FLAGS_FIXED_SIZE))\n\t\t{\n\t\t  int varsize;\n\t\t  if (parameters[i].flags & FLAGS_VARSIZE_PARAMETER)\n\t\t    {\n\t\t      /*\n\t\t       * Variable sizes are mapped onto the fixed sizes, in\n\t\t       * accordance with integer promotion.\n\t\t       *\n\t\t       * Please note that this may not be portable, as we\n\t\t       * only guess the size, not the layout of the numbers.\n\t\t       * For example, if int is little-endian, and long is\n\t\t       * big-endian, then this will fail.\n\t\t       */\n\t\t      varsize = (int)parameters[parameters[i].varsize].data.number.as_unsigned;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /* Used for the I<bits> modifiers */\n\t\t      varsize = parameters[i].varsize;\n\t\t    }\n\t\t  parameters[i].flags &= ~FLAGS_ALL_VARSIZES;\n\t\t  \n\t\t  if (varsize <= (int)sizeof(int))\n\t\t    ;\n\t\t  else if (varsize <= (int)sizeof(long))\n\t\t    parameters[i].flags |= FLAGS_LONG;\n#if TRIO_FEATURE_INTMAX_T\n\t\t  else if (varsize <= (int)sizeof(trio_longlong_t))\n\t\t    parameters[i].flags |= FLAGS_QUAD;\n\t\t  else\n\t\t    parameters[i].flags |= FLAGS_INTMAX_T;\n#else\n\t\t  else\n\t\t    parameters[i].flags |= FLAGS_QUAD;\n#endif\n\t\t}\n#endif /* TRIO_FEATURE_VARSIZE */\n#if TRIO_FEATURE_SIZE_T || TRIO_FEATURE_SIZE_T_UPPER\n\t      if (parameters[i].flags & FLAGS_SIZE_T)\n\t\tparameters[i].data.number.as_unsigned = (argarray == NULL)\n\t\t  ? (trio_uintmax_t)va_arg(arglist, size_t)\n\t\t  : (trio_uintmax_t)(*((size_t *)argarray[num]));\n\t      else\n#endif\n#if TRIO_FEATURE_PTRDIFF_T\n\t      if (parameters[i].flags & FLAGS_PTRDIFF_T)\n\t\tparameters[i].data.number.as_unsigned = (argarray == NULL)\n\t\t  ? (trio_uintmax_t)va_arg(arglist, ptrdiff_t)\n\t\t  : (trio_uintmax_t)(*((ptrdiff_t *)argarray[num]));\n\t      else\n#endif\n#if TRIO_FEATURE_INTMAX_T\n\t      if (parameters[i].flags & FLAGS_INTMAX_T)\n\t\tparameters[i].data.number.as_unsigned = (argarray == NULL)\n\t\t  ? (trio_uintmax_t)va_arg(arglist, trio_intmax_t)\n\t\t  : (trio_uintmax_t)(*((trio_intmax_t *)argarray[num]));\n\t      else\n#endif\n\t      if (parameters[i].flags & FLAGS_QUAD)\n\t\tparameters[i].data.number.as_unsigned = (argarray == NULL)\n\t\t  ? (trio_uintmax_t)va_arg(arglist, trio_ulonglong_t)\n\t\t  : (trio_uintmax_t)(*((trio_ulonglong_t *)argarray[num]));\n\t      else if (parameters[i].flags & FLAGS_LONG)\n\t\tparameters[i].data.number.as_unsigned = (argarray == NULL)\n\t\t  ? (trio_uintmax_t)va_arg(arglist, long)\n\t\t  : (trio_uintmax_t)(*((long *)argarray[num]));\n\t      else\n\t\t{\n\t\t  if (argarray == NULL)\n\t\t    parameters[i].data.number.as_unsigned = (trio_uintmax_t)va_arg(arglist, int);\n\t\t  else\n\t\t    {\n\t\t      if (parameters[i].type == FORMAT_CHAR)\n\t\t\tparameters[i].data.number.as_unsigned = (trio_uintmax_t)(*((char *)argarray[num]));\n\t\t      else if (parameters[i].flags & FLAGS_SHORT)\n\t\t\tparameters[i].data.number.as_unsigned = (trio_uintmax_t)(*((short *)argarray[num]));\n\t\t      else\n\t\t\tparameters[i].data.number.as_unsigned = (trio_uintmax_t)(*((int *)argarray[num]));\n\t\t    }\n\t\t}\n\t    }\n\t  break;\n\n\tcase FORMAT_PARAMETER:\n\t  /*\n\t   * The parameter for the user-defined specifier is a pointer,\n\t   * whereas the rest (width, precision, base) uses an integer.\n\t   */\n\t  if (parameters[i].flags & FLAGS_USER_DEFINED)\n\t    parameters[i].data.pointer = (argarray == NULL)\n\t      ? va_arg(arglist, trio_pointer_t )\n\t      : argarray[num];\n\t  else\n\t    parameters[i].data.number.as_unsigned = (argarray == NULL)\n\t      ? (trio_uintmax_t)va_arg(arglist, int)\n\t      : (trio_uintmax_t)(*((int *)argarray[num]));\n\t  break;\n\n#if TRIO_FEATURE_FLOAT\n\tcase FORMAT_DOUBLE:\n# if TRIO_FEATURE_SCANF\n\t  if (TYPE_SCAN == type)\n\t    {\n\t      if (parameters[i].flags & FLAGS_LONGDOUBLE)\n\t\tparameters[i].data.longdoublePointer = (argarray == NULL)\n\t\t  ? va_arg(arglist, trio_long_double_t *)\n\t\t  : (trio_long_double_t *)argarray[num];\n\t      else\n                {\n\t\t  if (parameters[i].flags & FLAGS_LONG)\n\t\t    parameters[i].data.doublePointer = (argarray == NULL)\n\t\t      ? va_arg(arglist, double *)\n\t\t      : (double *)argarray[num];\n\t\t  else\n\t\t    parameters[i].data.doublePointer = (argarray == NULL)\n\t\t      ? (double *)va_arg(arglist, float *)\n\t\t      : (double *)((float *)argarray[num]);\n                }\n\t    }\n\t  else\n# endif /* TRIO_FEATURE_SCANF */\n\t    {\n\t      if (parameters[i].flags & FLAGS_LONGDOUBLE)\n\t\tparameters[i].data.longdoubleNumber = (argarray == NULL)\n\t\t  ? va_arg(arglist, trio_long_double_t)\n\t\t  : (trio_long_double_t)(*((trio_long_double_t *)argarray[num]));\n\t      else\n\t\t{\n\t\t  if (argarray == NULL)\n\t\t    parameters[i].data.longdoubleNumber =\n\t\t      (trio_long_double_t)va_arg(arglist, double);\n\t\t  else\n\t\t    {\n\t\t      if (parameters[i].flags & FLAGS_SHORT)\n\t\t\tparameters[i].data.longdoubleNumber =\n\t\t\t  (trio_long_double_t)(*((float *)argarray[num]));\n\t\t      else\n\t\t\tparameters[i].data.longdoubleNumber =\n\t\t\t  (trio_long_double_t)(*((double *)argarray[num]));\n\t\t    }\n\t\t}\n\t    }\n\t  break;\n#endif /* TRIO_FEATURE_FLOAT */\n\n#if TRIO_FEATURE_ERRNO\n\tcase FORMAT_ERRNO:\n\t  parameters[i].data.errorNumber = save_errno;\n\t  break;\n#endif\n\n\tdefault:\n\t  break;\n\t}\n    } /* for all specifiers */\n  return num;\n}", "path": "How-to-Make-a-Computer-Operating-System/src/sdk/src/libc/src/trio/trio.c", "commit_date": "2013-11-30 00:00:00", "repo_name": "SamyPesse/How-to-Make-a-Computer-Operating-System", "stars": 20829, "license": "apache-2.0", "language": "c", "size": 5986}
{"docstring": "// ---------------- LENGTH OF NUMBERS AND STRINGS ---\n", "func_signal": "int  supcon_leni(int num)", "code": "{\n  int p;\n  int sign;\n\n      if ( num < 0 ) \n      {\n        p = -num;\n      \tsign = 1;\n      }\n      else\n      {\n        p = num;\n      \tsign = 0;\n      }\n  \n\tif ( p < 10 ) return sign + 1;\n\tif ( p < 100 ) return sign + 2;\n\tif ( p < 1000 ) return sign + 3;\n\tif ( p < 10000 ) return sign + 4;\n\tif ( p < 100000 ) return sign + 5;\n\tif ( p < 1000000 ) return sign + 6;\n\tif ( p < 10000000 ) return sign + 7;\n\tif ( p < 100000000 ) return sign + 8;\n\tif ( p < 1000000000 ) return sign + 9;\n\n  return 10;\n}", "path": "How-to-Make-a-Computer-Operating-System/src/sdk/src/libc/src/stdio/support_supcon.c", "commit_date": "2013-11-30 00:00:00", "repo_name": "SamyPesse/How-to-Make-a-Computer-Operating-System", "stars": 20829, "license": "apache-2.0", "language": "c", "size": 5986}
{"docstring": "/*************************************************************************\n * trio_print_int [public]\n */\n", "func_signal": "void\ntrio_print_int\nTRIO_ARGS2((ref, number),\n\t   trio_pointer_t ref,\n\t   int number)", "code": "{\n  trio_reference_t *self = (trio_reference_t *)ref;\n\n  TrioWriteNumber(self->data,\n\t\t  (trio_uintmax_t)number,\n\t\t  self->parameter->flags,\n\t\t  self->parameter->width,\n\t\t  self->parameter->precision,\n\t\t  self->parameter->base);\n}", "path": "How-to-Make-a-Computer-Operating-System/src/sdk/src/libc/src/trio/trio.c", "commit_date": "2013-11-30 00:00:00", "repo_name": "SamyPesse/How-to-Make-a-Computer-Operating-System", "stars": 20829, "license": "apache-2.0", "language": "c", "size": 5986}
{"docstring": "/*************************************************************************\n * TrioParseSpecifier\n *\n * Description:\n *  Parse the specifier part of a potential conversion specifier\n */\n", "func_signal": "TRIO_PRIVATE int\nTrioParseSpecifier\nTRIO_ARGS4((type, format, offset, parameter),\n\t   int type,\n\t   TRIO_CONST char *format,\n\t   int offset,\n\t   trio_parameter_t *parameter)", "code": "{\n  parameter->baseSpecifier = NO_BASE;\n\n  switch (format[offset++])\n    {\n#if defined(SPECIFIER_CHAR_UPPER)\n    case SPECIFIER_CHAR_UPPER:\n      parameter->flags |= FLAGS_WIDECHAR;\n      /* FALLTHROUGH */\n#endif\n    case SPECIFIER_CHAR:\n      if (parameter->flags & FLAGS_LONG)\n\tparameter->flags |= FLAGS_WIDECHAR;\n      else if (parameter->flags & FLAGS_SHORT)\n\tparameter->flags &= ~FLAGS_WIDECHAR;\n      parameter->type = FORMAT_CHAR;\n      break;\n\n#if defined(SPECIFIER_STRING_UPPER)\n    case SPECIFIER_STRING_UPPER:\n      parameter->flags |= FLAGS_WIDECHAR;\n      /* FALLTHROUGH */\n#endif\n    case SPECIFIER_STRING:\n      if (parameter->flags & FLAGS_LONG)\n\tparameter->flags |= FLAGS_WIDECHAR;\n      else if (parameter->flags & FLAGS_SHORT)\n\tparameter->flags &= ~FLAGS_WIDECHAR;\n      parameter->type = FORMAT_STRING;\n      break;\n\n#if defined(SPECIFIER_GROUP)\n    case SPECIFIER_GROUP:\n      if (TYPE_SCAN == type)\n\t{\n\t  int depth = 1;\n\t  parameter->type = FORMAT_GROUP;\n\t  if (format[offset] == QUALIFIER_CIRCUMFLEX)\n\t    offset++;\n\t  if (format[offset] == SPECIFIER_UNGROUP)\n\t    offset++;\n\t  if (format[offset] == QUALIFIER_MINUS)\n\t    offset++;\n\t  /* Skip nested brackets */\n\t  while (format[offset] != NIL)\n\t    {\n\t      if (format[offset] == SPECIFIER_GROUP)\n\t\t{\n\t\t  depth++;\n\t\t}\n\t      else if (format[offset] == SPECIFIER_UNGROUP)\n\t      {\n\t\tif (--depth <= 0)\n\t\t  {\n\t\t    offset++;\n\t\t    break;\n\t\t  }\n\t      }\n\t      offset++;\n\t    }\n\t}\n      break;\n#endif /* defined(SPECIFIER_GROUP) */\n\n    case SPECIFIER_INTEGER:\n      parameter->type = FORMAT_INT;\n      break;\n\n    case SPECIFIER_UNSIGNED:\n      parameter->flags |= FLAGS_UNSIGNED;\n      parameter->type = FORMAT_INT;\n      break;\n\n    case SPECIFIER_DECIMAL:\n      parameter->baseSpecifier = BASE_DECIMAL;\n      parameter->type = FORMAT_INT;\n      break;\n\n    case SPECIFIER_OCTAL:\n      parameter->flags |= FLAGS_UNSIGNED;\n      parameter->baseSpecifier = BASE_OCTAL;\n      parameter->type = FORMAT_INT;\n      break;\n\n#if TRIO_FEATURE_BINARY\n    case SPECIFIER_BINARY_UPPER:\n      parameter->flags |= FLAGS_UPPER;\n      /* FALLTHROUGH */\n    case SPECIFIER_BINARY:\n      parameter->flags |= FLAGS_NILPADDING;\n      parameter->baseSpecifier = BASE_BINARY;\n      parameter->type = FORMAT_INT;\n      break;\n#endif\n\n    case SPECIFIER_HEX_UPPER:\n      parameter->flags |= FLAGS_UPPER;\n      /* FALLTHROUGH */\n    case SPECIFIER_HEX:\n      parameter->flags |= FLAGS_UNSIGNED;\n      parameter->baseSpecifier = BASE_HEX;\n      parameter->type = FORMAT_INT;\n      break;\n\n#if defined(SPECIFIER_FLOAT_E)\n# if defined(SPECIFIER_FLOAT_E_UPPER)\n    case SPECIFIER_FLOAT_E_UPPER:\n      parameter->flags |= FLAGS_UPPER;\n      /* FALLTHROUGH */\n# endif\n    case SPECIFIER_FLOAT_E:\n      parameter->flags |= FLAGS_FLOAT_E;\n      parameter->type = FORMAT_DOUBLE;\n      break;\n#endif\n\n#if defined(SPECIFIER_FLOAT_G)\n# if defined(SPECIFIER_FLOAT_G_UPPER)\n    case SPECIFIER_FLOAT_G_UPPER:\n      parameter->flags |= FLAGS_UPPER;\n      /* FALLTHROUGH */\n# endif\n    case SPECIFIER_FLOAT_G:\n      parameter->flags |= FLAGS_FLOAT_G;\n      parameter->type = FORMAT_DOUBLE;\n      break;\n#endif\n\n#if defined(SPECIFIER_FLOAT_F)\n# if defined(SPECIFIER_FLOAT_F_UPPER)\n    case SPECIFIER_FLOAT_F_UPPER:\n      parameter->flags |= FLAGS_UPPER;\n      /* FALLTHROUGH */\n# endif\n    case SPECIFIER_FLOAT_F:\n      parameter->type = FORMAT_DOUBLE;\n      break;\n#endif\n\n#if defined(TRIO_COMPILER_VISUALC)\n# pragma warning( push )\n# pragma warning( disable : 4127 ) /* Conditional expression is constant */\n#endif\n    case SPECIFIER_POINTER:\n      if (sizeof(trio_pointer_t) == sizeof(trio_ulonglong_t))\n\tparameter->flags |= FLAGS_QUAD;\n      else if (sizeof(trio_pointer_t) == sizeof(long))\n\tparameter->flags |= FLAGS_LONG;\n      parameter->type = FORMAT_POINTER;\n      break;\n#if defined(TRIO_COMPILER_VISUALC)\n# pragma warning( pop )\n#endif\n\n    case SPECIFIER_COUNT:\n      parameter->type = FORMAT_COUNT;\n      break;\n\n#if TRIO_FEATURE_HEXFLOAT\n    case SPECIFIER_HEXFLOAT_UPPER:\n      parameter->flags |= FLAGS_UPPER;\n      /* FALLTHROUGH */\n    case SPECIFIER_HEXFLOAT:\n      parameter->baseSpecifier = BASE_HEX;\n      parameter->type = FORMAT_DOUBLE;\n      break;\n#endif\n\n#if TRIO_FEATURE_ERRNO\n    case SPECIFIER_ERRNO:\n      parameter->type = FORMAT_ERRNO;\n      break;\n#endif\n\n#if TRIO_FEATURE_USER_DEFINED\n    case SPECIFIER_USER_DEFINED_BEGIN:\n      {\n\tunsigned int max;\n\tint without_namespace = TRUE;\n\tchar* tmpformat = (char *)&format[offset];\n\tint ch;\n\n\tparameter->type = FORMAT_USER_DEFINED;\n\tparameter->user_defined.namespace[0] = NIL;\n\n\twhile ((ch = format[offset]) != NIL)\n\t  {\n\t    offset++;\n\t    if ((ch == SPECIFIER_USER_DEFINED_END) || (ch == SPECIFIER_USER_DEFINED_EXTRA))\n\t      {\n\t\tif (without_namespace)\n\t\t  /* No namespace, handler will be passed as an argument */\n\t\t  parameter->flags |= FLAGS_USER_DEFINED_PARAMETER;\n\n\t\t/* Copy the user data */\n\t\tmax = (unsigned int)(&format[offset] - tmpformat);\n\t\tif (max > MAX_USER_DATA)\n\t\t  max = MAX_USER_DATA;\n\t\ttrio_copy_max(parameter->user_data, max, tmpformat);\n\n\t\t/* Skip extra data (which is only there to keep the compiler happy) */\n\t\twhile ((ch != NIL) && (ch != SPECIFIER_USER_DEFINED_END))\n\t\t  ch = format[offset++];\n\n\t\tbreak; /* while */\n\t      }\n\n\t    if (ch == SPECIFIER_USER_DEFINED_SEPARATOR)\n\t      {\n\t\twithout_namespace = FALSE;\n\t\t/* Copy the namespace for later looking-up */\n\t\tmax = (int)(&format[offset] - tmpformat);\n\t\tif (max > MAX_USER_NAME)\n\t\t  max = MAX_USER_NAME;\n\t\ttrio_copy_max(parameter->user_defined.namespace, max, tmpformat);\n\t\ttmpformat = (char *)&format[offset];\n\t      }\n\t  }\n\n\tif (ch != SPECIFIER_USER_DEFINED_END)\n\t  return TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n      }\n      break;\n#endif /* TRIO_FEATURE_USER_DEFINED */\n\n    default:\n      /* Bail out completely to make the error more obvious */\n      return TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n  }\n\n  parameter->endOffset = offset;\n\n  return 0;\n}", "path": "How-to-Make-a-Computer-Operating-System/src/sdk/src/libc/src/trio/trio.c", "commit_date": "2013-11-30 00:00:00", "repo_name": "SamyPesse/How-to-Make-a-Computer-Operating-System", "stars": 20829, "license": "apache-2.0", "language": "c", "size": 5986}
{"docstring": "/*************************************************************************\n * TrioWriteNumber\n *\n * Description:\n *  Output a number.\n *  The complexity of this function is a result of the complexity\n *  of the dependencies of the flags.\n */\n", "func_signal": "TRIO_PRIVATE void\nTrioWriteNumber\nTRIO_ARGS6((self, number, flags, width, precision, base),\n\t   trio_class_t *self,\n\t   trio_uintmax_t number,\n\t   trio_flags_t flags,\n\t   int width,\n\t   int precision,\n\t   int base)", "code": "{\n  BOOLEAN_T isNegative;\n  BOOLEAN_T isNumberZero;\n  BOOLEAN_T isPrecisionZero;\n  BOOLEAN_T ignoreNumber;\n  char buffer[MAX_CHARS_IN(trio_uintmax_t) * (1 + MAX_LOCALE_SEPARATOR_LENGTH) + 1];\n  char *bufferend;\n  char *pointer;\n  TRIO_CONST char *digits;\n  int i;\n#if TRIO_FEATURE_QUOTE\n  int length;\n  char *p;\n#endif\n  int count;\n  int digitOffset;\n\n  assert(VALID(self));\n  assert(VALID(self->OutStream));\n  assert(((base >= MIN_BASE) && (base <= MAX_BASE)) || (base == NO_BASE));\n\n  digits = (flags & FLAGS_UPPER) ? internalDigitsUpper : internalDigitsLower;\n  if (base == NO_BASE)\n    base = BASE_DECIMAL;\n\n  isNumberZero = (number == 0);\n  isPrecisionZero = (precision == 0);\n  ignoreNumber = (isNumberZero\n\t\t  && isPrecisionZero\n\t\t  && !((flags & FLAGS_ALTERNATIVE) && (base == BASE_OCTAL)));\n\n  if (flags & FLAGS_UNSIGNED)\n    {\n      isNegative = FALSE;\n      flags &= ~FLAGS_SHOWSIGN;\n    }\n  else\n    {\n      isNegative = ((trio_intmax_t)number < 0);\n      if (isNegative)\n\tnumber = -((trio_intmax_t)number);\n    }\n\n  if (flags & FLAGS_QUAD)\n    number &= (trio_ulonglong_t)-1;\n  else if (flags & FLAGS_LONG)\n    number &= (unsigned long)-1;\n  else\n    number &= (unsigned int)-1;\n  \n  /* Build number */\n  pointer = bufferend = &buffer[sizeof(buffer) - 1];\n  *pointer-- = NIL;\n  for (i = 1; i < (int)sizeof(buffer); i++)\n    {\n      digitOffset = number % base;\n      *pointer-- = digits[digitOffset];\n      number /= base;\n      if (number == 0)\n\tbreak;\n\n#if TRIO_FEATURE_QUOTE\n      if ((flags & FLAGS_QUOTE) && TrioFollowedBySeparator(i + 1))\n\t{\n\t  /*\n\t   * We are building the number from the least significant\n\t   * to the most significant digit, so we have to copy the\n\t   * thousand separator backwards\n\t   */\n\t  length = internalThousandSeparatorLength;\n\t  if (((int)(pointer - buffer) - length) > 0)\n\t    {\n\t      p = &internalThousandSeparator[length - 1];\n\t      while (length-- > 0)\n\t\t*pointer-- = *p--;\n\t    }\n\t}\n#endif\n    }\n\n  if (! ignoreNumber)\n    {\n      /* Adjust width */\n      width -= (bufferend - pointer) - 1;\n    }\n\n  /* Adjust precision */\n  if (NO_PRECISION != precision)\n    {\n      precision -= (bufferend - pointer) - 1;\n      if (precision < 0)\n\tprecision = 0;\n      flags |= FLAGS_NILPADDING;\n    }\n\n  /* Calculate padding */\n  count = (! ((flags & FLAGS_LEFTADJUST) || (precision == NO_PRECISION)))\n    ? precision\n    : 0;\n  \n  /* Adjust width further */\n  if (isNegative || (flags & FLAGS_SHOWSIGN) || (flags & FLAGS_SPACE))\n    width--;\n  if ((flags & FLAGS_ALTERNATIVE) && !isNumberZero)\n    {\n      switch (base)\n\t{\n\tcase BASE_BINARY:\n\tcase BASE_HEX:\n\t  width -= 2;\n\t  break;\n\tcase BASE_OCTAL:\n\t  if (!(flags & FLAGS_NILPADDING) || (count == 0))\n\t    width--;\n\t  break;\n\tdefault:\n\t  break;\n\t}\n    }\n\n  /* Output prefixes spaces if needed */\n  if (! ((flags & FLAGS_LEFTADJUST) ||\n\t ((flags & FLAGS_NILPADDING) && (precision == NO_PRECISION))))\n    {\n      while (width-- > count)\n\tself->OutStream(self, CHAR_ADJUST);\n    }\n\n  /* width has been adjusted for signs and alternatives */\n  if (isNegative)\n    self->OutStream(self, '-');\n  else if (flags & FLAGS_SHOWSIGN)\n    self->OutStream(self, '+');\n  else if (flags & FLAGS_SPACE)\n    self->OutStream(self, ' ');\n\n  /* Prefix is not written when the value is zero */\n  if ((flags & FLAGS_ALTERNATIVE) && !isNumberZero)\n    {\n      switch (base)\n\t{\n\tcase BASE_BINARY:\n\t  self->OutStream(self, '0');\n\t  self->OutStream(self, (flags & FLAGS_UPPER) ? 'B' : 'b');\n\t  break;\n\n\tcase BASE_OCTAL:\n\t  if (!(flags & FLAGS_NILPADDING) || (count == 0))\n\t    self->OutStream(self, '0');\n\t  break;\n\n\tcase BASE_HEX:\n\t  self->OutStream(self, '0');\n\t  self->OutStream(self, (flags & FLAGS_UPPER) ? 'X' : 'x');\n\t  break;\n\n\tdefault:\n\t  break;\n\t} /* switch base */\n    }\n\n  /* Output prefixed zero padding if needed */\n  if (flags & FLAGS_NILPADDING)\n    {\n      if (precision == NO_PRECISION)\n\tprecision = width;\n      while (precision-- > 0)\n\t{\n\t  self->OutStream(self, '0');\n\t  width--;\n\t}\n    }\n\n  if (! ignoreNumber)\n    {\n      /* Output the number itself */\n      while (*(++pointer))\n\t{\n\t  self->OutStream(self, *pointer);\n\t}\n    }\n\n  /* Output trailing spaces if needed */\n  if (flags & FLAGS_LEFTADJUST)\n    {\n      while (width-- > 0)\n\tself->OutStream(self, CHAR_ADJUST);\n    }\n}", "path": "How-to-Make-a-Computer-Operating-System/src/sdk/src/libc/src/trio/trio.c", "commit_date": "2013-11-30 00:00:00", "repo_name": "SamyPesse/How-to-Make-a-Computer-Operating-System", "stars": 20829, "license": "apache-2.0", "language": "c", "size": 5986}
{"docstring": "/*************************************************************************\n * TrioWriteString\n *\n * Description:\n *  Output a string\n */\n", "func_signal": "TRIO_PRIVATE void\nTrioWriteString\nTRIO_ARGS5((self, string, flags, width, precision),\n\t   trio_class_t *self,\n\t   TRIO_CONST char *string,\n\t   trio_flags_t flags,\n\t   int width,\n\t   int precision)", "code": "{\n  int length;\n  int ch;\n\n  assert(VALID(self));\n  assert(VALID(self->OutStream));\n\n  if (string == NULL)\n    {\n      string = internalNullString;\n      length = sizeof(internalNullString) - 1;\n#if TRIO_FEATURE_QUOTE\n      /* Disable quoting for the null pointer */\n      flags &= (~FLAGS_QUOTE);\n#endif\n      width = 0;\n    }\n  else\n    {\n      if (precision == 0)\n\t{\n\t  length = trio_length(string);\n\t}\n      else\n\t{\n\t  length = trio_length_max(string, precision);\n\t}\n    }\n  if ((NO_PRECISION != precision) &&\n      (precision < length))\n    {\n      length = precision;\n    }\n  width -= length;\n\n#if TRIO_FEATURE_QUOTE\n  if (flags & FLAGS_QUOTE)\n    self->OutStream(self, CHAR_QUOTE);\n#endif\n\n  if (! (flags & FLAGS_LEFTADJUST))\n    {\n      while (width-- > 0)\n\tself->OutStream(self, CHAR_ADJUST);\n    }\n\n  while (length-- > 0)\n    {\n      /* The ctype parameters must be an unsigned char (or EOF) */\n      ch = (int)((unsigned char)(*string++));\n      TrioWriteStringCharacter(self, ch, flags);\n    }\n\n  if (flags & FLAGS_LEFTADJUST)\n    {\n      while (width-- > 0)\n\tself->OutStream(self, CHAR_ADJUST);\n    }\n#if TRIO_FEATURE_QUOTE\n  if (flags & FLAGS_QUOTE)\n    self->OutStream(self, CHAR_QUOTE);\n#endif\n}", "path": "How-to-Make-a-Computer-Operating-System/src/sdk/src/libc/src/trio/trio.c", "commit_date": "2013-11-30 00:00:00", "repo_name": "SamyPesse/How-to-Make-a-Computer-Operating-System", "stars": 20829, "license": "apache-2.0", "language": "c", "size": 5986}
{"docstring": "/**\n   Print to string.\n\n   @param buffer Output string.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\n", "func_signal": "TRIO_PUBLIC int\ntrio_sprintfv\nTRIO_ARGS3((buffer, format, args),\n\t   char *buffer,\n\t   TRIO_CONST char *format,\n\t   trio_pointer_t *args)", "code": "{\n  static va_list unused;\n  int status;\n  \n  assert(VALID(buffer));\n  assert(VALID(format));\n\n  status = TrioFormat(&buffer, 0, TrioOutStreamString, format, unused, args);\n  *buffer = NIL;\n  return status;\n}", "path": "How-to-Make-a-Computer-Operating-System/src/sdk/src/libc/src/trio/trio.c", "commit_date": "2013-11-30 00:00:00", "repo_name": "SamyPesse/How-to-Make-a-Computer-Operating-System", "stars": 20829, "license": "apache-2.0", "language": "c", "size": 5986}
{"docstring": "/*************************************************************************\n * trio_print_uint [public]\n */\n", "func_signal": "void\ntrio_print_uint\nTRIO_ARGS2((ref, number),\n\t   trio_pointer_t ref,\n\t   unsigned int number)", "code": "{\n  trio_reference_t *self = (trio_reference_t *)ref;\n\n  TrioWriteNumber(self->data,\n\t\t  (trio_uintmax_t)number,\n\t\t  self->parameter->flags | FLAGS_UNSIGNED,\n\t\t  self->parameter->width,\n\t\t  self->parameter->precision,\n\t\t  self->parameter->base);\n}", "path": "How-to-Make-a-Computer-Operating-System/src/sdk/src/libc/src/trio/trio.c", "commit_date": "2013-11-30 00:00:00", "repo_name": "SamyPesse/How-to-Make-a-Computer-Operating-System", "stars": 20829, "license": "apache-2.0", "language": "c", "size": 5986}
{"docstring": "/*************************************************************************\n * TrioSkipWhitespaces\n */\n", "func_signal": "TRIO_PRIVATE int\nTrioSkipWhitespaces\nTRIO_ARGS1((self),\n\t   trio_class_t *self)", "code": "{\n  int ch;\n\n  ch = self->current;\n  while (isspace(ch))\n    {\n      self->InStream(self, &ch);\n    }\n  return ch;\n}", "path": "How-to-Make-a-Computer-Operating-System/src/sdk/src/libc/src/trio/trio.c", "commit_date": "2013-11-30 00:00:00", "repo_name": "SamyPesse/How-to-Make-a-Computer-Operating-System", "stars": 20829, "license": "apache-2.0", "language": "c", "size": 5986}
{"docstring": "/*************************************************************************\n * TrioGetPosition\n *\n * Get the %n$ position.\n */\n", "func_signal": "TRIO_PRIVATE int\nTrioGetPosition\nTRIO_ARGS2((format, offsetPointer),\n\t   TRIO_CONST char *format,\n\t   int *offsetPointer)", "code": "{\n#if TRIO_FEATURE_POSITIONAL\n  char *tmpformat;\n  int number = 0;\n  int offset = *offsetPointer;\n\n  number = (int)trio_to_long(&format[offset], &tmpformat, BASE_DECIMAL);\n  offset = (int)(tmpformat - format);\n  if ((number != 0) && (QUALIFIER_POSITION == format[offset++]))\n    {\n      *offsetPointer = offset;\n      /*\n       * number is decreased by 1, because n$ starts from 1, whereas\n       * the array it is indexing starts from 0.\n       */\n      return number - 1;\n    }\n#endif\n  return NO_POSITION;\n}", "path": "How-to-Make-a-Computer-Operating-System/src/sdk/src/libc/src/trio/trio.c", "commit_date": "2013-11-30 00:00:00", "repo_name": "SamyPesse/How-to-Make-a-Computer-Operating-System", "stars": 20829, "license": "apache-2.0", "language": "c", "size": 5986}
{"docstring": "/**\n   Scan characters from string.\n\n   @param buffer Input string.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of scanned characters.\n */\n", "func_signal": "TRIO_PUBLIC int\ntrio_sscanfv\nTRIO_ARGS3((buffer, format, args),\n\t   TRIO_CONST char *buffer,\n\t   TRIO_CONST char *format,\n\t   trio_pointer_t *args)", "code": "{\n  static va_list unused;\n  \n  assert(VALID(buffer));\n  assert(VALID(format));\n  \n  return TrioScan((trio_pointer_t)&buffer, 0,\n\t\t  TrioInStreamString,\n\t\t  format, unused, args);\n}", "path": "How-to-Make-a-Computer-Operating-System/src/sdk/src/libc/src/trio/trio.c", "commit_date": "2013-11-30 00:00:00", "repo_name": "SamyPesse/How-to-Make-a-Computer-Operating-System", "stars": 20829, "license": "apache-2.0", "language": "c", "size": 5986}
{"docstring": "/*************************************************************************\n * TrioOutStreamString\n */\n", "func_signal": "TRIO_PRIVATE void\nTrioOutStreamString\nTRIO_ARGS2((self, output),\n\t   trio_class_t *self,\n\t   int output)", "code": "{\n  char **buffer;\n\n  assert(VALID(self));\n  assert(VALID(self->location));\n\n  buffer = (char **)self->location;\n  **buffer = (char)output;\n  (*buffer)++;\n  self->processed++;\n  self->committed++;\n}", "path": "How-to-Make-a-Computer-Operating-System/src/sdk/src/libc/src/trio/trio.c", "commit_date": "2013-11-30 00:00:00", "repo_name": "SamyPesse/How-to-Make-a-Computer-Operating-System", "stars": 20829, "license": "apache-2.0", "language": "c", "size": 5986}
{"docstring": "/* yy_get_next_buffer - try to read in a new buffer\n *\n * Returns a code representing an action:\n *\tEOB_ACT_LAST_MATCH -\n *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position\n *\tEOB_ACT_END_OF_FILE - end of file\n */\n", "func_signal": "static int yy_get_next_buffer (void)", "code": "{\n    \tchar *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tchar *source = (yytext_ptr);\n\tint number_to_move, i;\n\tint ret_val;\n\n\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) ((yy_c_buf_p) - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tyyrealloc( (void *) b->yy_ch_buf,\n\t\t\t\t\t\t\t (yy_size_t) (b->yy_buf_size + 2)  );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = NULL;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\t(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\t(yy_n_chars), num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tif ( (yy_n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tyyrestart( yyin  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tint new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(\n\t\t\t(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n\t\t/* \"- 2\" to take care of EOB's */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);\n\t}\n\n\t(yy_n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}", "path": "openwrt/scripts/config/lexer.lex.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "openwrt/openwrt", "stars": 17794, "license": "other", "language": "c", "size": 237444}
{"docstring": "/* Allocates the stack if it does not exist.\n *  Guarantees space for at least one push.\n */\n", "func_signal": "static void yyensure_buffer_stack (void)", "code": "{\n\tyy_size_t num_to_alloc;\n    \n\tif (!(yy_buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\n\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t\t(yy_buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc\n\t\t\t\t\t\t\t\t((yy_buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t}\n}", "path": "openwrt/scripts/config/lexer.lex.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "openwrt/openwrt", "stars": 17794, "license": "other", "language": "c", "size": 237444}
{"docstring": "/* \\fn static int lq_cbc_des_decrypt(struct ablkcipher_request *areq)\n * \\ingroup IFX_DES_FUNCTIONS\n * \\brief Decrypt function for DES algo\n * \\param *areq Pointer to ablkcipher request in memory\n * \\return 0 is success, -EINPROGRESS if encryting, EINVAL if failure\n*/\n", "func_signal": "static int lq_cbc_des_decrypt(struct ablkcipher_request *areq)", "code": "{\n    struct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(areq);\n    struct des_ctx *ctx = crypto_ablkcipher_ctx(cipher);\n\n    return lq_queue_mgr(ctx, areq, areq->info, CRYPTO_DIR_DECRYPT, 1);\n}", "path": "openwrt/package/kernel/lantiq/ltq-deu/src/ifxmips_async_des.c", "commit_date": "2020-05-17 00:00:00", "repo_name": "openwrt/openwrt", "stars": 17794, "license": "other", "language": "c", "size": 237444}
{"docstring": "/** Switch to a different input buffer.\n * @param new_buffer The new input buffer.\n * \n */\n", "func_signal": "void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )", "code": "{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tyypop_buffer_state();\n\t *\t\tyypush_buffer_state(new_buffer);\n     */\n\tyyensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tyy_load_buffer_state(  );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (yywrap()) processing, but the only time this flag\n\t * is looked at is after yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(yy_did_buffer_switch_on_eof) = 1;\n}", "path": "openwrt/scripts/config/lexer.lex.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "openwrt/openwrt", "stars": 17794, "license": "other", "language": "c", "size": 237444}
{"docstring": "/* Initializes or reinitializes a buffer.\n * This function is sometimes called more than once on the same buffer,\n * such as during a yyrestart() or at EOF.\n */\n", "func_signal": "static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )", "code": "{\n\tint oerrno = errno;\n    \n\tyy_flush_buffer( b );\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then yy_init_buffer was _probably_\n     * called from yyrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n        b->yy_is_interactive = 0;\n    \n\terrno = oerrno;\n}", "path": "openwrt/scripts/config/lexer.lex.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "openwrt/openwrt", "stars": 17794, "license": "other", "language": "c", "size": 237444}
{"docstring": "/* \\fn static int lq_des_encrypt(struct ablkcipher_request *areq)\n * \\ingroup IFX_DES_FUNCTIONS\n * \\brief Decrypt function for DES algo\n * \\param *areq Pointer to ablkcipher request in memory\n * \\return 0 is success, -EINPROGRESS if encryting, EINVAL if failure\n*/\n", "func_signal": "static int lq_des_encrypt(struct ablkcipher_request *areq)", "code": "{\n    struct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(areq);\n    struct des_ctx *ctx = crypto_ablkcipher_ctx(cipher);\n\n    return lq_queue_mgr(ctx, areq, NULL, CRYPTO_DIR_ENCRYPT, 5);\n\n}", "path": "openwrt/package/kernel/lantiq/ltq-deu/src/ifxmips_async_des.c", "commit_date": "2020-05-17 00:00:00", "repo_name": "openwrt/openwrt", "stars": 17794, "license": "other", "language": "c", "size": 237444}
{"docstring": "/** Destroy the buffer.\n * @param b a buffer created with yy_create_buffer()\n * \n */\n", "func_signal": "void yy_delete_buffer (YY_BUFFER_STATE  b )", "code": "{\n    \n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tyyfree( (void *) b->yy_ch_buf  );\n\n\tyyfree( (void *) b  );\n}", "path": "openwrt/scripts/config/lexer.lex.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "openwrt/openwrt", "stars": 17794, "license": "other", "language": "c", "size": 237444}
{"docstring": "/* yy_get_previous_state - get the state just before the EOB char was reached */\n", "func_signal": "static yy_state_type yy_get_previous_state (void)", "code": "{\n\tyy_state_type yy_current_state;\n\tchar *yy_cp;\n    \n\tyy_current_state = (yy_start);\n\n\tfor ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )\n\t\t{\n\t\tyy_current_state = yy_nxt[yy_current_state][(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1)];\n\t\t}\n\n\treturn yy_current_state;\n}", "path": "openwrt/scripts/config/lexer.lex.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "openwrt/openwrt", "stars": 17794, "license": "other", "language": "c", "size": 237444}
{"docstring": "/*! \\fn int lq_des3_ede_setkey(struct crypto_ablkcipher *tfm, const u8 *key, unsigned int keylen)\n *  \\ingroup IFX_DES_FUNCTIONS\n *  \\brief sets DES key\n *  \\param tfm linux crypto algo transform\n *  \\param key input key\n *  \\param keylen key length\n*/\n", "func_signal": "static int lq_des3_ede_setkey(struct crypto_ablkcipher *tfm, const u8 *in_key,\n                      unsigned int keylen)", "code": "{\n    struct des_ctx *dctx = crypto_ablkcipher_ctx(tfm);\n\n    //printk(\"setkey in %s\\n\", __FILE__);\n\n    dctx->controlr_M = keylen/8 + 1;   // des\n    dctx->key_length = keylen;\n\n    memcpy ((u8 *) (dctx->expkey), in_key, keylen);\n\n    return 0;\n}", "path": "openwrt/package/kernel/lantiq/ltq-deu/src/ifxmips_async_des.c", "commit_date": "2020-05-17 00:00:00", "repo_name": "openwrt/openwrt", "stars": 17794, "license": "other", "language": "c", "size": 237444}
{"docstring": "/** Setup the input buffer state to scan directly from a user-specified character buffer.\n * @param base the character buffer\n * @param size the size in bytes of the character buffer\n * \n * @return the newly allocated buffer state object.\n */\n", "func_signal": "YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )", "code": "{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn NULL;\n\n\tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = (int) (size - 2);\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = NULL;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer( b  );\n\n\treturn b;\n}", "path": "openwrt/scripts/config/lexer.lex.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "openwrt/openwrt", "stars": 17794, "license": "other", "language": "c", "size": 237444}
{"docstring": "/*! \\fn int __init lqdeu_async_des_init (void)\n *  \\ingroup IFX_DES_FUNCTIONS\n *  \\brief initialize des driver\n*/\n", "func_signal": "int __init lqdeu_async_des_init (void)", "code": "{\n    int i, j, ret = -EINVAL;\n\n     for (i = 0; i < ARRAY_SIZE(des_drivers_alg); i++) {\n         ret = crypto_register_alg(&des_drivers_alg[i].alg);\n\t //printk(\"driver: %s\\n\", des_drivers_alg[i].alg.cra_name);\n         if (ret)\n             goto des_err;\n     }\n            \n     des_chip_init();\n     CRTCL_SECT_INIT;\n\n\n    printk (KERN_NOTICE \"IFX DEU DES initialized%s%s.\\n\", disable_multiblock ? \"\" : \" (multiblock)\", disable_deudma ? \"\" : \" (DMA)\");\n    return ret;\n\ndes_err:\n     for (j = 0; j < i; j++) \n        crypto_unregister_alg(&des_drivers_alg[i].alg);\n\n     printk(KERN_ERR \"Lantiq %s driver initialization failed!\\n\", (char *)&des_drivers_alg[i].alg.cra_driver_name);\n     return ret;\n\ncbc_des3_ede_err:\n     for (i = 0; i < ARRAY_SIZE(des_drivers_alg); i++) {\n         if (!strcmp((char *)&des_drivers_alg[i].alg.cra_name, \"cbc(des3_ede)\"))\n             crypto_unregister_alg(&des_drivers_alg[i].alg);\n     }     \n\n     printk(KERN_ERR \"Lantiq %s driver initialization failed!\\n\", (char *)&des_drivers_alg[i].alg.cra_driver_name);\n     return ret;\n}", "path": "openwrt/package/kernel/lantiq/ltq-deu/src/ifxmips_async_des.c", "commit_date": "2020-05-17 00:00:00", "repo_name": "openwrt/openwrt", "stars": 17794, "license": "other", "language": "c", "size": 237444}
{"docstring": "/* \\fn static int process_next_packet(struct des_container *des_con,  struct ablkcipher_request *areq,\n *                                     int state)\n * \\ingroup IFX_DES_FUNCTIONS\n * \\brief Process the next packet after dequeuing the packet from crypto queue\n * \\param *des_con  Pointer to DES container structure\n * \\param *areq     Pointer to ablkcipher_request container\n * \\param state     State of the packet (scattered packet or new packet to be processed)\n * \\return -EINVAL: DEU failure, -EINPROGRESS: DEU encrypt/decrypt in progress, 1: no scatterlist left\n*/\n", "func_signal": "static int process_next_packet(struct des_container *des_con,  struct ablkcipher_request *areq,\n                               int state)", "code": "{\n    u8 *iv;\n    int mode, encdec, err = -EINVAL;\n    u32 remain, inc, chunk_size, nbytes;\n    struct scatterlist *src = NULL;\n    struct scatterlist *dst = NULL;\n    struct crypto_ablkcipher *cipher;\n    struct des_ctx *ctx;\n    unsigned long queue_flag;\n\n    spin_lock_irqsave(&des_queue->lock, queue_flag);\n\n    mode = des_con->mode;\n    encdec = des_con->encdec;\n    iv = des_con->iv;\n\n    if (state & PROCESS_SCATTER) {\n        src = scatterwalk_sg_next(areq->src);\n        dst = scatterwalk_sg_next(areq->dst);\n\n        if (!src || !dst) {\n            spin_unlock_irqrestore(&des_queue->lock, queue_flag);\n      \t    return 1;\n        }\n    }\n    else if (state & PROCESS_NEW_PACKET) {\n        src = areq->src;\n        dst = areq->dst;\n    }\n\n    remain = des_con->bytes_processed;\n    chunk_size = src->length;\n\n    //printk(\"debug ln: %d, func: %s, reqsize: %d, scattersize: %d\\n\", \n//\t\t__LINE__, __func__, areq->nbytes, chunk_size);\n\n    if (remain > DEU_MAX_PACKET_SIZE)\n        inc = DEU_MAX_PACKET_SIZE;\n    else if(remain > chunk_size)\n        inc = chunk_size;\n    else\n        inc = remain;\n \n    remain -= inc;\n    des_con->nbytes = inc;\n    \n    if (state & PROCESS_SCATTER) {\n        des_con->src_buf += des_con->nbytes;\n        des_con->dst_buf += des_con->nbytes;\n    } \n\n    lq_sg_init(des_con, src, dst);\n\n    nbytes = des_con->nbytes;\n\n    cipher = crypto_ablkcipher_reqtfm(areq);\n    ctx = crypto_ablkcipher_ctx(cipher);\n\n    if (des_queue->hw_status == DES_IDLE) {\n        des_queue->hw_status = DES_STARTED;\n    }\n    \n    des_con->bytes_processed -= des_con->nbytes;\n    err = ablkcipher_enqueue_request(&des_queue->list, &des_con->arequest);\n    if (err == -EBUSY) {\n        printk(\"Failed to enqueue request, ln: %d, err: %d\\n\",\n               __LINE__, err);\n        spin_unlock_irqrestore(&des_queue->lock, queue_flag);\n        return -EINVAL;\n    }\n\n    spin_unlock_irqrestore(&des_queue->lock, queue_flag);\n    err = lq_deu_des_core(ctx, des_con->dst_buf, des_con->src_buf, iv, nbytes, encdec, mode);\n \n    return err;\n}", "path": "openwrt/package/kernel/lantiq/ltq-deu/src/ifxmips_async_des.c", "commit_date": "2020-05-17 00:00:00", "repo_name": "openwrt/openwrt", "stars": 17794, "license": "other", "language": "c", "size": 237444}
{"docstring": "/** Setup the input buffer state to scan the given bytes. The next call to yylex() will\n * scan from a @e copy of @a bytes.\n * @param yybytes the byte buffer to scan\n * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.\n * \n * @return the newly allocated buffer state object.\n */\n", "func_signal": "YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )", "code": "{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = (yy_size_t) (_yybytes_len + 2);\n\tbuf = (char *) yyalloc( n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = yy_scan_buffer( buf, n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}", "path": "openwrt/scripts/config/lexer.lex.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "openwrt/openwrt", "stars": 17794, "license": "other", "language": "c", "size": 237444}
{"docstring": "/* \\fn static int des_crypto_thread (void *data)\n * \\ingroup IFX_DES_FUNCTIONS\n * \\brief DES thread that handles crypto requests from upper layer & DMA\n * \\param *data Not used\n * \\return -EINVAL: DEU failure, -EBUSY: DEU HW busy, 0: exit thread\n*/\n", "func_signal": "static int des_crypto_thread(void *data)", "code": "{\n    struct des_container *des_con = NULL;\n    struct ablkcipher_request *areq = NULL;\n    int err;\n    unsigned long queue_flag;\n\n    daemonize(\"lq_des_thread\");\n   \n    while (1)\n    {  \n       DEU_WAIT_EVENT(deu_dma_priv.deu_thread_wait, DES_ASYNC_EVENT, \n                       deu_dma_priv.des_event_flags);\n       spin_lock_irqsave(&des_queue->lock, queue_flag);\n\n       /* wait to prevent starting a crypto session before \n        * exiting the dma interrupt thread.\n        */\n       \n       if (des_queue->hw_status == DES_STARTED) {\n            areq = ablkcipher_dequeue_request(&des_queue->list);\n            des_con = des_container_cast(areq);\n            des_queue->hw_status = DES_BUSY;\n       }\n       else if (des_queue->hw_status == DES_IDLE) {\n            areq = ablkcipher_dequeue_request(&des_queue->list);\n            des_con = des_container_cast(areq);\n            des_queue->hw_status = DES_STARTED;\n       }\n       else if (des_queue->hw_status == DES_BUSY) {\n            areq = ablkcipher_dequeue_request(&des_queue->list);\n            des_con = des_container_cast(areq);\n       }\n       else if (des_queue->hw_status == DES_COMPLETED) {\n            areq->base.complete(&areq->base, 0);\n            lq_sg_complete(des_con);\n            des_queue->hw_status = DES_IDLE;\n            spin_unlock_irqrestore(&des_queue->lock, queue_flag);\n            return 0;\n       }\n       spin_unlock_irqrestore(&des_queue->lock, queue_flag);\n            \n       if ((des_con->bytes_processed == 0)) {\n            goto des_done;\n       }\n\n       if (!des_con) {\n           goto des_done;\n       }\n\n       if (des_con->flag & PROCESS_NEW_PACKET) { \n           des_con->flag = PROCESS_SCATTER;\n           err = process_next_packet(des_con, areq, PROCESS_NEW_PACKET);  \n       }\n       else\n           err = process_next_packet(des_con, areq, PROCESS_SCATTER);  \n       \n       if (err == -EINVAL) {\n           areq->base.complete(&areq->base, err);\n           lq_sg_complete(des_con);\n           printk(\"src/dst returned -EINVAL in func: %s\\n\", __func__);\n       }\n       else if (err > 0) { \n           printk(\"src/dst returned zero in func: %s\\n\", __func__);\n           goto des_done;\n       }\n\n       continue;\n   \ndes_done:\n       //printk(\"debug line - %d, func: %s, qlen: %d\\n\", __LINE__, __func__, des_queue->list.qlen);\n       areq->base.complete(&areq->base, 0);\n       lq_sg_complete(des_con);\n\n       spin_lock_irqsave(&des_queue->lock, queue_flag);\n       if (des_queue->list.qlen > 0) {\n           spin_unlock_irqrestore(&des_queue->lock, queue_flag);\n           tasklet_schedule(&des_queue->des_task);\n       } \n       else {\n           des_queue->hw_status = DES_IDLE;\n           spin_unlock_irqrestore(&des_queue->lock, queue_flag);\n       }\n    } // while(1)\n    \n    return 0;\n\n}", "path": "openwrt/package/kernel/lantiq/ltq-deu/src/ifxmips_async_des.c", "commit_date": "2020-05-17 00:00:00", "repo_name": "openwrt/openwrt", "stars": 17794, "license": "other", "language": "c", "size": 237444}
{"docstring": "/*! \\fn int lq_des_setkey(struct crypto_ablkcipher *tfm, const u8 *key, unsigned int keylen)\n *  \\ingroup IFX_DES_FUNCTIONS\n *  \\brief sets DES key\n *  \\param tfm linux crypto algo transform\n *  \\param key input key\n *  \\param keylen key length\n*/\n", "func_signal": "static int lq_des_setkey(struct crypto_ablkcipher *tfm, const u8 *key,\n                         unsigned int keylen)", "code": "{\n        struct des_ctx *dctx = crypto_ablkcipher_ctx(tfm);\n\n        //printk(\"setkey in %s\\n\", __FILE__);\n\n        dctx->controlr_M = 0;   // des\n        dctx->key_length = keylen;\n\n        memcpy ((u8 *) (dctx->expkey), key, keylen);\n\n        return 0;\n}", "path": "openwrt/package/kernel/lantiq/ltq-deu/src/ifxmips_async_des.c", "commit_date": "2020-05-17 00:00:00", "repo_name": "openwrt/openwrt", "stars": 17794, "license": "other", "language": "c", "size": 237444}
{"docstring": "/** Discard all buffered characters. On the next scan, YY_INPUT will be called.\n * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.\n * \n */\n", "func_signal": "void yy_flush_buffer (YY_BUFFER_STATE  b )", "code": "{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tyy_load_buffer_state(  );\n}", "path": "openwrt/scripts/config/lexer.lex.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "openwrt/openwrt", "stars": 17794, "license": "other", "language": "c", "size": 237444}
{"docstring": "/* \\fn static void lq_sg_complete(struct des_container *des_con)\n * \\ingroup IFX_DES_FUNCTIONS\n * \\brief Free the used up memory after encryt/decrypt.\n*/\n", "func_signal": "static void lq_sg_complete(struct des_container *des_con)", "code": "{\n    unsigned long queue_flag;\n  \n    spin_lock_irqsave(&des_queue->lock, queue_flag);\n    kfree(des_con); \n    spin_unlock_irqrestore(&des_queue->lock, queue_flag);\n}", "path": "openwrt/package/kernel/lantiq/ltq-deu/src/ifxmips_async_des.c", "commit_date": "2020-05-17 00:00:00", "repo_name": "openwrt/openwrt", "stars": 17794, "license": "other", "language": "c", "size": 237444}
{"docstring": "/** Immediately switch to a different input stream.\n * @param input_file A readable stream.\n * \n * @note This function does not reset the start condition to @c INITIAL .\n */\n", "func_signal": "void yyrestart  (FILE * input_file )", "code": "{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        yyensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            yy_create_buffer( yyin, YY_BUF_SIZE );\n\t}\n\n\tyy_init_buffer( YY_CURRENT_BUFFER, input_file );\n\tyy_load_buffer_state(  );\n}", "path": "openwrt/scripts/config/lexer.lex.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "openwrt/openwrt", "stars": 17794, "license": "other", "language": "c", "size": 237444}
{"docstring": "/** Pushes the new state onto the stack. The new state becomes\n *  the current state. This function will allocate the stack\n *  if necessary.\n *  @param new_buffer The new state.\n *  \n */\n", "func_signal": "void yypush_buffer_state (YY_BUFFER_STATE new_buffer )", "code": "{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tyyensure_buffer_stack();\n\n\t/* This block is copied from yy_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(yy_buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from yy_switch_to_buffer. */\n\tyy_load_buffer_state(  );\n\t(yy_did_buffer_switch_on_eof) = 1;\n}", "path": "openwrt/scripts/config/lexer.lex.c", "commit_date": "2020-09-22 00:00:00", "repo_name": "openwrt/openwrt", "stars": 17794, "license": "other", "language": "c", "size": 237444}
{"docstring": "/* \\fn void lq_sg_init(struct scatterlist *src,\n *                     struct scatterlist *dst)\n * \\ingroup IFX_DES_FUNCTIONS\n * \\brief Maps the scatterlists into a source/destination page.\n * \\param *src Pointer to the source scatterlist\n * \\param *dst Pointer to the destination scatterlist\n*/\n", "func_signal": "static void lq_sg_init(struct des_container *des_con, struct scatterlist *src,\n                       struct scatterlist *dst)", "code": "{\n    struct page *dst_page, *src_page;\n\n    src_page = sg_virt(src);\n    des_con->src_buf = (char *) src_page;\n\n    dst_page = sg_virt(dst);\n    des_con->dst_buf = (char *) dst_page;\n}", "path": "openwrt/package/kernel/lantiq/ltq-deu/src/ifxmips_async_des.c", "commit_date": "2020-05-17 00:00:00", "repo_name": "openwrt/openwrt", "stars": 17794, "license": "other", "language": "c", "size": 237444}
{"docstring": "// Returns the number of columns needed to display a given\n// string in a fixed-width font.\n", "func_signal": "int display_width(char *p, int len)", "code": "{\n  char *start = p;\n  int w = 0;\n  while (p - start < len) {\n    uint32_t c = decode_utf8(&p, p);\n    w += char_width(c);\n  }\n  return w;\n}", "path": "chibicc/unicode.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "rui314/chibicc", "stars": 8404, "license": "mit", "language": "c", "size": 882}
{"docstring": "// Compute the absolute address of a given node.\n// It's an error if a given node does not reside in memory.\n", "func_signal": "static void gen_addr(Node *node)", "code": "{\n  switch (node->kind) {\n  case ND_VAR:\n    // Variable-length array, which is always local.\n    if (node->var->ty->kind == TY_VLA) {\n      println(\"  mov %d(%%rbp), %%rax\", node->var->offset);\n      return;\n    }\n\n    // Local variable\n    if (node->var->is_local) {\n      println(\"  lea %d(%%rbp), %%rax\", node->var->offset);\n      return;\n    }\n\n    if (opt_fpic) {\n      // Thread-local variable\n      if (node->var->is_tls) {\n        println(\"  data16 lea %s@tlsgd(%%rip), %%rdi\", node->var->name);\n        println(\"  .value 0x6666\");\n        println(\"  rex64\");\n        println(\"  call __tls_get_addr@PLT\");\n        return;\n      }\n\n      // Function or global variable\n      println(\"  mov %s@GOTPCREL(%%rip), %%rax\", node->var->name);\n      return;\n    }\n\n    // Thread-local variable\n    if (node->var->is_tls) {\n      println(\"  mov %%fs:0, %%rax\");\n      println(\"  add $%s@tpoff, %%rax\", node->var->name);\n      return;\n    }\n\n    // Here, we generate an absolute address of a function or a global\n    // variable. Even though they exist at a certain address at runtime,\n    // their addresses are not known at link-time for the following\n    // two reasons.\n    //\n    //  - Address randomization: Executables are loaded to memory as a\n    //    whole but it is not known what address they are loaded to.\n    //    Therefore, at link-time, relative address in the same\n    //    exectuable (i.e. the distance between two functions in the\n    //    same executable) is known, but the absolute address is not\n    //    known.\n    //\n    //  - Dynamic linking: Dynamic shared objects (DSOs) or .so files\n    //    are loaded to memory alongside an executable at runtime and\n    //    linked by the runtime loader in memory. We know nothing\n    //    about addresses of global stuff that may be defined by DSOs\n    //    until the runtime relocation is complete.\n    //\n    // In order to deal with the former case, we use RIP-relative\n    // addressing, denoted by `(%rip)`. For the latter, we obtain an\n    // address of a stuff that may be in a shared object file from the\n    // Global Offset Table using `@GOTPCREL(%rip)` notation.\n\n    // Function\n    if (node->ty->kind == TY_FUNC) {\n      if (node->var->is_definition)\n        println(\"  lea %s(%%rip), %%rax\", node->var->name);\n      else\n        println(\"  mov %s@GOTPCREL(%%rip), %%rax\", node->var->name);\n      return;\n    }\n\n    // Global variable\n    println(\"  lea %s(%%rip), %%rax\", node->var->name);\n    return;\n  case ND_DEREF:\n    gen_expr(node->lhs);\n    return;\n  case ND_COMMA:\n    gen_expr(node->lhs);\n    gen_addr(node->rhs);\n    return;\n  case ND_MEMBER:\n    gen_addr(node->lhs);\n    println(\"  add $%d, %%rax\", node->member->offset);\n    return;\n  case ND_FUNCALL:\n    if (node->ret_buffer) {\n      gen_expr(node);\n      return;\n    }\n    break;\n  case ND_ASSIGN:\n  case ND_COND:\n    if (node->ty->kind == TY_STRUCT || node->ty->kind == TY_UNION) {\n      gen_expr(node);\n      return;\n    }\n    break;\n  case ND_VLA_PTR:\n    println(\"  lea %d(%%rbp), %%rax\", node->var->offset);\n    return;\n  }\n\n  error_tok(node->tok, \"not an lvalue\");\n}", "path": "chibicc/codegen.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "rui314/chibicc", "stars": 8404, "license": "mit", "language": "c", "size": 882}
{"docstring": "// Store %rax to an address that the stack top is pointing to.\n", "func_signal": "static void store(Type *ty)", "code": "{\n  pop(\"%rdi\");\n\n  switch (ty->kind) {\n  case TY_STRUCT:\n  case TY_UNION:\n    for (int i = 0; i < ty->size; i++) {\n      println(\"  mov %d(%%rax), %%r8b\", i);\n      println(\"  mov %%r8b, %d(%%rdi)\", i);\n    }\n    return;\n  case TY_FLOAT:\n    println(\"  movss %%xmm0, (%%rdi)\");\n    return;\n  case TY_DOUBLE:\n    println(\"  movsd %%xmm0, (%%rdi)\");\n    return;\n  case TY_LDOUBLE:\n    println(\"  fstpt (%%rdi)\");\n    return;\n  }\n\n  if (ty->size == 1)\n    println(\"  mov %%al, (%%rdi)\");\n  else if (ty->size == 2)\n    println(\"  mov %%ax, (%%rdi)\");\n  else if (ty->size == 4)\n    println(\"  mov %%eax, (%%rdi)\");\n  else\n    println(\"  mov %%rax, (%%rdi)\");\n}", "path": "chibicc/codegen.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "rui314/chibicc", "stars": 8404, "license": "mit", "language": "c", "size": 882}
{"docstring": "// Returns the number of columns needed to display a given\n// character in a fixed-width font.\n//\n// Based on https://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c\n", "func_signal": "static int char_width(uint32_t c)", "code": "{\n  static uint32_t range1[] = {\n    0x0000, 0x001F, 0x007f, 0x00a0, 0x0300, 0x036F, 0x0483, 0x0486,\n    0x0488, 0x0489, 0x0591, 0x05BD, 0x05BF, 0x05BF, 0x05C1, 0x05C2,\n    0x05C4, 0x05C5, 0x05C7, 0x05C7, 0x0600, 0x0603, 0x0610, 0x0615,\n    0x064B, 0x065E, 0x0670, 0x0670, 0x06D6, 0x06E4, 0x06E7, 0x06E8,\n    0x06EA, 0x06ED, 0x070F, 0x070F, 0x0711, 0x0711, 0x0730, 0x074A,\n    0x07A6, 0x07B0, 0x07EB, 0x07F3, 0x0901, 0x0902, 0x093C, 0x093C,\n    0x0941, 0x0948, 0x094D, 0x094D, 0x0951, 0x0954, 0x0962, 0x0963,\n    0x0981, 0x0981, 0x09BC, 0x09BC, 0x09C1, 0x09C4, 0x09CD, 0x09CD,\n    0x09E2, 0x09E3, 0x0A01, 0x0A02, 0x0A3C, 0x0A3C, 0x0A41, 0x0A42,\n    0x0A47, 0x0A48, 0x0A4B, 0x0A4D, 0x0A70, 0x0A71, 0x0A81, 0x0A82,\n    0x0ABC, 0x0ABC, 0x0AC1, 0x0AC5, 0x0AC7, 0x0AC8, 0x0ACD, 0x0ACD,\n    0x0AE2, 0x0AE3, 0x0B01, 0x0B01, 0x0B3C, 0x0B3C, 0x0B3F, 0x0B3F,\n    0x0B41, 0x0B43, 0x0B4D, 0x0B4D, 0x0B56, 0x0B56, 0x0B82, 0x0B82,\n    0x0BC0, 0x0BC0, 0x0BCD, 0x0BCD, 0x0C3E, 0x0C40, 0x0C46, 0x0C48,\n    0x0C4A, 0x0C4D, 0x0C55, 0x0C56, 0x0CBC, 0x0CBC, 0x0CBF, 0x0CBF,\n    0x0CC6, 0x0CC6, 0x0CCC, 0x0CCD, 0x0CE2, 0x0CE3, 0x0D41, 0x0D43,\n    0x0D4D, 0x0D4D, 0x0DCA, 0x0DCA, 0x0DD2, 0x0DD4, 0x0DD6, 0x0DD6,\n    0x0E31, 0x0E31, 0x0E34, 0x0E3A, 0x0E47, 0x0E4E, 0x0EB1, 0x0EB1,\n    0x0EB4, 0x0EB9, 0x0EBB, 0x0EBC, 0x0EC8, 0x0ECD, 0x0F18, 0x0F19,\n    0x0F35, 0x0F35, 0x0F37, 0x0F37, 0x0F39, 0x0F39, 0x0F71, 0x0F7E,\n    0x0F80, 0x0F84, 0x0F86, 0x0F87, 0x0F90, 0x0F97, 0x0F99, 0x0FBC,\n    0x0FC6, 0x0FC6, 0x102D, 0x1030, 0x1032, 0x1032, 0x1036, 0x1037,\n    0x1039, 0x1039, 0x1058, 0x1059, 0x1160, 0x11FF, 0x135F, 0x135F,\n    0x1712, 0x1714, 0x1732, 0x1734, 0x1752, 0x1753, 0x1772, 0x1773,\n    0x17B4, 0x17B5, 0x17B7, 0x17BD, 0x17C6, 0x17C6, 0x17C9, 0x17D3,\n    0x17DD, 0x17DD, 0x180B, 0x180D, 0x18A9, 0x18A9, 0x1920, 0x1922,\n    0x1927, 0x1928, 0x1932, 0x1932, 0x1939, 0x193B, 0x1A17, 0x1A18,\n    0x1B00, 0x1B03, 0x1B34, 0x1B34, 0x1B36, 0x1B3A, 0x1B3C, 0x1B3C,\n    0x1B42, 0x1B42, 0x1B6B, 0x1B73, 0x1DC0, 0x1DCA, 0x1DFE, 0x1DFF,\n    0x200B, 0x200F, 0x202A, 0x202E, 0x2060, 0x2063, 0x206A, 0x206F,\n    0x20D0, 0x20EF, 0x302A, 0x302F, 0x3099, 0x309A, 0xA806, 0xA806,\n    0xA80B, 0xA80B, 0xA825, 0xA826, 0xFB1E, 0xFB1E, 0xFE00, 0xFE0F,\n    0xFE20, 0xFE23, 0xFEFF, 0xFEFF, 0xFFF9, 0xFFFB, 0x10A01, 0x10A03,\n    0x10A05, 0x10A06, 0x10A0C, 0x10A0F, 0x10A38, 0x10A3A, 0x10A3F, 0x10A3F,\n    0x1D167, 0x1D169, 0x1D173, 0x1D182, 0x1D185, 0x1D18B, 0x1D1AA, 0x1D1AD,\n    0x1D242, 0x1D244, 0xE0001, 0xE0001, 0xE0020, 0xE007F, 0xE0100, 0xE01EF,\n    -1,\n  };\n\n  if (in_range(range1, c))\n    return 0;\n\n  static uint32_t range2[] = {\n    0x1100, 0x115F, 0x2329, 0x2329, 0x232A, 0x232A, 0x2E80, 0x303E,\n    0x3040, 0xA4CF, 0xAC00, 0xD7A3, 0xF900, 0xFAFF, 0xFE10, 0xFE19,\n    0xFE30, 0xFE6F, 0xFF00, 0xFF60, 0xFFE0, 0xFFE6, 0x1F000, 0x1F644,\n    0x20000, 0x2FFFD, 0x30000, 0x3FFFD, -1,\n  };\n\n  if (in_range(range2, c))\n    return 2;\n  return 1;\n}", "path": "chibicc/unicode.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "rui314/chibicc", "stars": 8404, "license": "mit", "language": "c", "size": 882}
{"docstring": "// Read a UTF-8-encoded Unicode code point from a source file.\n// We assume that source files are always in UTF-8.\n//\n// UTF-8 is a variable-width encoding in which one code point is\n// encoded in one to four bytes. One byte UTF-8 code points are\n// identical to ASCII. Non-ASCII characters are encoded using more\n// than one byte.\n", "func_signal": "uint32_t decode_utf8(char **new_pos, char *p)", "code": "{\n  if ((unsigned char)*p < 128) {\n    *new_pos = p + 1;\n    return *p;\n  }\n\n  char *start = p;\n  int len;\n  uint32_t c;\n\n  if ((unsigned char)*p >= 0b11110000) {\n    len = 4;\n    c = *p & 0b111;\n  } else if ((unsigned char)*p >= 0b11100000) {\n    len = 3;\n    c = *p & 0b1111;\n  } else if ((unsigned char)*p >= 0b11000000) {\n    len = 2;\n    c = *p & 0b11111;\n  } else {\n    error_at(start, \"invalid UTF-8 sequence\");\n  }\n\n  for (int i = 1; i < len; i++) {\n    if ((unsigned char)p[i] >> 6 != 0b10)\n      error_at(start, \"invalid UTF-8 sequence\");\n    c = (c << 6) | (p[i] & 0b111111);\n  }\n\n  *new_pos = p + len;\n  return c;\n}", "path": "chibicc/unicode.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "rui314/chibicc", "stars": 8404, "license": "mit", "language": "c", "size": 882}
{"docstring": "// [https://www.sigbus.info/n1570#D] C11 allows not only ASCII but\n// some multibyte characters in certan Unicode ranges to be used in an\n// identifier.\n//\n// This function returns true if a given character is acceptable as\n// the first character of an identifier.\n//\n// For example, \u00be (U+00BE) is a valid identifier because characters in\n// 0x00BE-0x00C0 are allowed, while neither \u27d8 (U+27D8) nor '\u3000'\n// (U+3000, full-width space) are allowed because they are out of range.\n", "func_signal": "bool is_ident1(uint32_t c)", "code": "{\n  static uint32_t range[] = {\n    '_', '_', 'a', 'z', 'A', 'Z', '$', '$',\n    0x00A8, 0x00A8, 0x00AA, 0x00AA, 0x00AD, 0x00AD, 0x00AF, 0x00AF,\n    0x00B2, 0x00B5, 0x00B7, 0x00BA, 0x00BC, 0x00BE, 0x00C0, 0x00D6,\n    0x00D8, 0x00F6, 0x00F8, 0x00FF, 0x0100, 0x02FF, 0x0370, 0x167F,\n    0x1681, 0x180D, 0x180F, 0x1DBF, 0x1E00, 0x1FFF, 0x200B, 0x200D,\n    0x202A, 0x202E, 0x203F, 0x2040, 0x2054, 0x2054, 0x2060, 0x206F,\n    0x2070, 0x20CF, 0x2100, 0x218F, 0x2460, 0x24FF, 0x2776, 0x2793,\n    0x2C00, 0x2DFF, 0x2E80, 0x2FFF, 0x3004, 0x3007, 0x3021, 0x302F,\n    0x3031, 0x303F, 0x3040, 0xD7FF, 0xF900, 0xFD3D, 0xFD40, 0xFDCF,\n    0xFDF0, 0xFE1F, 0xFE30, 0xFE44, 0xFE47, 0xFFFD,\n    0x10000, 0x1FFFD, 0x20000, 0x2FFFD, 0x30000, 0x3FFFD, 0x40000, 0x4FFFD,\n    0x50000, 0x5FFFD, 0x60000, 0x6FFFD, 0x70000, 0x7FFFD, 0x80000, 0x8FFFD,\n    0x90000, 0x9FFFD, 0xA0000, 0xAFFFD, 0xB0000, 0xBFFFD, 0xC0000, 0xCFFFD,\n    0xD0000, 0xDFFFD, 0xE0000, 0xEFFFD, -1,\n  };\n\n  return in_range(range, c);\n}", "path": "chibicc/unicode.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "rui314/chibicc", "stars": 8404, "license": "mit", "language": "c", "size": 882}
{"docstring": "// Returns true if a given character is acceptable as a non-first\n// character of an identifier.\n", "func_signal": "bool is_ident2(uint32_t c)", "code": "{\n  static uint32_t range[] = {\n    '0', '9', '$', '$', 0x0300, 0x036F, 0x1DC0, 0x1DFF, 0x20D0, 0x20FF,\n    0xFE20, 0xFE2F, -1,\n  };\n\n  return is_ident1(c) || in_range(range, c);\n}", "path": "chibicc/unicode.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "rui314/chibicc", "stars": 8404, "license": "mit", "language": "c", "size": 882}
{"docstring": "// Load a value from where %rax is pointing to.\n", "func_signal": "static void load(Type *ty)", "code": "{\n  switch (ty->kind) {\n  case TY_ARRAY:\n  case TY_STRUCT:\n  case TY_UNION:\n  case TY_FUNC:\n  case TY_VLA:\n    // If it is an array, do not attempt to load a value to the\n    // register because in general we can't load an entire array to a\n    // register. As a result, the result of an evaluation of an array\n    // becomes not the array itself but the address of the array.\n    // This is where \"array is automatically converted to a pointer to\n    // the first element of the array in C\" occurs.\n    return;\n  case TY_FLOAT:\n    println(\"  movss (%%rax), %%xmm0\");\n    return;\n  case TY_DOUBLE:\n    println(\"  movsd (%%rax), %%xmm0\");\n    return;\n  case TY_LDOUBLE:\n    println(\"  fldt (%%rax)\");\n    return;\n  }\n\n  char *insn = ty->is_unsigned ? \"movz\" : \"movs\";\n\n  // When we load a char or a short value to a register, we always\n  // extend them to the size of int, so we can assume the lower half of\n  // a register always contains a valid value. The upper half of a\n  // register for char, short and int may contain garbage. When we load\n  // a long value to a register, it simply occupies the entire register.\n  if (ty->size == 1)\n    println(\"  %sbl (%%rax), %%eax\", insn);\n  else if (ty->size == 2)\n    println(\"  %swl (%%rax), %%eax\", insn);\n  else if (ty->size == 4)\n    println(\"  movsxd (%%rax), %%rax\");\n  else\n    println(\"  mov (%%rax), %%rax\");\n}", "path": "chibicc/codegen.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "rui314/chibicc", "stars": 8404, "license": "mit", "language": "c", "size": 882}
{"docstring": "// Print tokens to stdout. Used for -E.\n", "func_signal": "static void print_tokens(Token *tok)", "code": "{\n  FILE *out = open_file(opt_o ? opt_o : \"-\");\n\n  int line = 1;\n  for (; tok->kind != TK_EOF; tok = tok->next) {\n    if (line > 1 && tok->at_bol)\n      fprintf(out, \"\\n\");\n    if (tok->has_space && !tok->at_bol)\n      fprintf(out, \" \");\n    fprintf(out, \"%.*s\", tok->len, tok->loc);\n    line++;\n  }\n  fprintf(out, \"\\n\");\n}", "path": "chibicc/main.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "rui314/chibicc", "stars": 8404, "license": "mit", "language": "c", "size": 882}
{"docstring": "// Generate code for a given node.\n", "func_signal": "static void gen_expr(Node *node)", "code": "{\n  println(\"  .loc %d %d\", node->tok->file->file_no, node->tok->line_no);\n\n  switch (node->kind) {\n  case ND_NULL_EXPR:\n    return;\n  case ND_NUM: {\n    switch (node->ty->kind) {\n    case TY_FLOAT: {\n      union { float f32; uint32_t u32; } u = { node->fval };\n      println(\"  mov $%u, %%eax  # float %Lf\", u.u32, node->fval);\n      println(\"  movq %%rax, %%xmm0\");\n      return;\n    }\n    case TY_DOUBLE: {\n      union { double f64; uint64_t u64; } u = { node->fval };\n      println(\"  mov $%lu, %%rax  # double %Lf\", u.u64, node->fval);\n      println(\"  movq %%rax, %%xmm0\");\n      return;\n    }\n    case TY_LDOUBLE: {\n      union { long double f80; uint64_t u64[2]; } u;\n      memset(&u, 0, sizeof(u));\n      u.f80 = node->fval;\n      println(\"  mov $%lu, %%rax  # long double %Lf\", u.u64[0], node->fval);\n      println(\"  mov %%rax, -16(%%rsp)\");\n      println(\"  mov $%lu, %%rax\", u.u64[1]);\n      println(\"  mov %%rax, -8(%%rsp)\");\n      println(\"  fldt -16(%%rsp)\");\n      return;\n    }\n    }\n\n    println(\"  mov $%ld, %%rax\", node->val);\n    return;\n  }\n  case ND_NEG:\n    gen_expr(node->lhs);\n\n    switch (node->ty->kind) {\n    case TY_FLOAT:\n      println(\"  mov $1, %%rax\");\n      println(\"  shl $31, %%rax\");\n      println(\"  movq %%rax, %%xmm1\");\n      println(\"  xorps %%xmm1, %%xmm0\");\n      return;\n    case TY_DOUBLE:\n      println(\"  mov $1, %%rax\");\n      println(\"  shl $63, %%rax\");\n      println(\"  movq %%rax, %%xmm1\");\n      println(\"  xorpd %%xmm1, %%xmm0\");\n      return;\n    case TY_LDOUBLE:\n      println(\"  fchs\");\n      return;\n    }\n\n    println(\"  neg %%rax\");\n    return;\n  case ND_VAR:\n    gen_addr(node);\n    load(node->ty);\n    return;\n  case ND_MEMBER: {\n    gen_addr(node);\n    load(node->ty);\n\n    Member *mem = node->member;\n    if (mem->is_bitfield) {\n      println(\"  shl $%d, %%rax\", 64 - mem->bit_width - mem->bit_offset);\n      if (mem->ty->is_unsigned)\n        println(\"  shr $%d, %%rax\", 64 - mem->bit_width);\n      else\n        println(\"  sar $%d, %%rax\", 64 - mem->bit_width);\n    }\n    return;\n  }\n  case ND_DEREF:\n    gen_expr(node->lhs);\n    load(node->ty);\n    return;\n  case ND_ADDR:\n    gen_addr(node->lhs);\n    return;\n  case ND_ASSIGN:\n    gen_addr(node->lhs);\n    push();\n    gen_expr(node->rhs);\n\n    if (node->lhs->kind == ND_MEMBER && node->lhs->member->is_bitfield) {\n      println(\"  mov %%rax, %%r8\");\n\n      // If the lhs is a bitfield, we need to read the current value\n      // from memory and merge it with a new value.\n      Member *mem = node->lhs->member;\n      println(\"  mov %%rax, %%rdi\");\n      println(\"  and $%ld, %%rdi\", (1L << mem->bit_width) - 1);\n      println(\"  shl $%d, %%rdi\", mem->bit_offset);\n\n      println(\"  mov (%%rsp), %%rax\");\n      load(mem->ty);\n\n      long mask = ((1L << mem->bit_width) - 1) << mem->bit_offset;\n      println(\"  mov $%ld, %%r9\", ~mask);\n      println(\"  and %%r9, %%rax\");\n      println(\"  or %%rdi, %%rax\");\n      store(node->ty);\n      println(\"  mov %%r8, %%rax\");\n      return;\n    }\n\n    store(node->ty);\n    return;\n  case ND_STMT_EXPR:\n    for (Node *n = node->body; n; n = n->next)\n      gen_stmt(n);\n    return;\n  case ND_COMMA:\n    gen_expr(node->lhs);\n    gen_expr(node->rhs);\n    return;\n  case ND_CAST:\n    gen_expr(node->lhs);\n    cast(node->lhs->ty, node->ty);\n    return;\n  case ND_MEMZERO:\n    // `rep stosb` is equivalent to `memset(%rdi, %al, %rcx)`.\n    println(\"  mov $%d, %%rcx\", node->var->ty->size);\n    println(\"  lea %d(%%rbp), %%rdi\", node->var->offset);\n    println(\"  mov $0, %%al\");\n    println(\"  rep stosb\");\n    return;\n  case ND_COND: {\n    int c = count();\n    gen_expr(node->cond);\n    cmp_zero(node->cond->ty);\n    println(\"  je .L.else.%d\", c);\n    gen_expr(node->then);\n    println(\"  jmp .L.end.%d\", c);\n    println(\".L.else.%d:\", c);\n    gen_expr(node->els);\n    println(\".L.end.%d:\", c);\n    return;\n  }\n  case ND_NOT:\n    gen_expr(node->lhs);\n    cmp_zero(node->lhs->ty);\n    println(\"  sete %%al\");\n    println(\"  movzx %%al, %%rax\");\n    return;\n  case ND_BITNOT:\n    gen_expr(node->lhs);\n    println(\"  not %%rax\");\n    return;\n  case ND_LOGAND: {\n    int c = count();\n    gen_expr(node->lhs);\n    cmp_zero(node->lhs->ty);\n    println(\"  je .L.false.%d\", c);\n    gen_expr(node->rhs);\n    cmp_zero(node->rhs->ty);\n    println(\"  je .L.false.%d\", c);\n    println(\"  mov $1, %%rax\");\n    println(\"  jmp .L.end.%d\", c);\n    println(\".L.false.%d:\", c);\n    println(\"  mov $0, %%rax\");\n    println(\".L.end.%d:\", c);\n    return;\n  }\n  case ND_LOGOR: {\n    int c = count();\n    gen_expr(node->lhs);\n    cmp_zero(node->lhs->ty);\n    println(\"  jne .L.true.%d\", c);\n    gen_expr(node->rhs);\n    cmp_zero(node->rhs->ty);\n    println(\"  jne .L.true.%d\", c);\n    println(\"  mov $0, %%rax\");\n    println(\"  jmp .L.end.%d\", c);\n    println(\".L.true.%d:\", c);\n    println(\"  mov $1, %%rax\");\n    println(\".L.end.%d:\", c);\n    return;\n  }\n  case ND_FUNCALL: {\n    if (node->lhs->kind == ND_VAR && !strcmp(node->lhs->var->name, \"alloca\")) {\n      gen_expr(node->args);\n      println(\"  mov %%rax, %%rdi\");\n      builtin_alloca();\n      return;\n    }\n\n    int stack_args = push_args(node);\n    gen_expr(node->lhs);\n\n    int gp = 0, fp = 0;\n\n    // If the return type is a large struct/union, the caller passes\n    // a pointer to a buffer as if it were the first argument.\n    if (node->ret_buffer && node->ty->size > 16)\n      pop(argreg64[gp++]);\n\n    for (Node *arg = node->args; arg; arg = arg->next) {\n      Type *ty = arg->ty;\n\n      switch (ty->kind) {\n      case TY_STRUCT:\n      case TY_UNION:\n        if (ty->size > 16)\n          continue;\n\n        bool fp1 = has_flonum1(ty);\n        bool fp2 = has_flonum2(ty);\n\n        if (fp + fp1 + fp2 < FP_MAX && gp + !fp1 + !fp2 < GP_MAX) {\n          if (fp1)\n            popf(fp++);\n          else\n            pop(argreg64[gp++]);\n\n          if (ty->size > 8) {\n            if (fp2)\n              popf(fp++);\n            else\n              pop(argreg64[gp++]);\n          }\n        }\n        break;\n      case TY_FLOAT:\n      case TY_DOUBLE:\n        if (fp < FP_MAX)\n          popf(fp++);\n        break;\n      case TY_LDOUBLE:\n        break;\n      default:\n        if (gp < GP_MAX)\n          pop(argreg64[gp++]);\n      }\n    }\n\n    println(\"  mov %%rax, %%r10\");\n    println(\"  mov $%d, %%rax\", fp);\n    println(\"  call *%%r10\");\n    println(\"  add $%d, %%rsp\", stack_args * 8);\n\n    depth -= stack_args;\n\n    // It looks like the most significant 48 or 56 bits in RAX may\n    // contain garbage if a function return type is short or bool/char,\n    // respectively. We clear the upper bits here.\n    switch (node->ty->kind) {\n    case TY_BOOL:\n      println(\"  movzx %%al, %%eax\");\n      return;\n    case TY_CHAR:\n      if (node->ty->is_unsigned)\n        println(\"  movzbl %%al, %%eax\");\n      else\n        println(\"  movsbl %%al, %%eax\");\n      return;\n    case TY_SHORT:\n      if (node->ty->is_unsigned)\n        println(\"  movzwl %%ax, %%eax\");\n      else\n        println(\"  movswl %%ax, %%eax\");\n      return;\n    }\n\n    // If the return type is a small struct, a value is returned\n    // using up to two registers.\n    if (node->ret_buffer && node->ty->size <= 16) {\n      copy_ret_buffer(node->ret_buffer);\n      println(\"  lea %d(%%rbp), %%rax\", node->ret_buffer->offset);\n    }\n\n    return;\n  }\n  case ND_LABEL_VAL:\n    println(\"  lea %s(%%rip), %%rax\", node->unique_label);\n    return;\n  case ND_CAS: {\n    gen_expr(node->cas_addr);\n    push();\n    gen_expr(node->cas_new);\n    push();\n    gen_expr(node->cas_old);\n    println(\"  mov %%rax, %%r8\");\n    load(node->cas_old->ty->base);\n    pop(\"%rdx\"); // new\n    pop(\"%rdi\"); // addr\n\n    int sz = node->cas_addr->ty->base->size;\n    println(\"  lock cmpxchg %s, (%%rdi)\", reg_dx(sz));\n    println(\"  sete %%cl\");\n    println(\"  je 1f\");\n    println(\"  mov %s, (%%r8)\", reg_ax(sz));\n    println(\"1:\");\n    println(\"  movzbl %%cl, %%eax\");\n    return;\n  }\n  case ND_EXCH: {\n    gen_expr(node->lhs);\n    push();\n    gen_expr(node->rhs);\n    pop(\"%rdi\");\n\n    int sz = node->lhs->ty->base->size;\n    println(\"  xchg %s, (%%rdi)\", reg_ax(sz));\n    return;\n  }\n  }\n\n  switch (node->lhs->ty->kind) {\n  case TY_FLOAT:\n  case TY_DOUBLE: {\n    gen_expr(node->rhs);\n    pushf();\n    gen_expr(node->lhs);\n    popf(1);\n\n    char *sz = (node->lhs->ty->kind == TY_FLOAT) ? \"ss\" : \"sd\";\n\n    switch (node->kind) {\n    case ND_ADD:\n      println(\"  add%s %%xmm1, %%xmm0\", sz);\n      return;\n    case ND_SUB:\n      println(\"  sub%s %%xmm1, %%xmm0\", sz);\n      return;\n    case ND_MUL:\n      println(\"  mul%s %%xmm1, %%xmm0\", sz);\n      return;\n    case ND_DIV:\n      println(\"  div%s %%xmm1, %%xmm0\", sz);\n      return;\n    case ND_EQ:\n    case ND_NE:\n    case ND_LT:\n    case ND_LE:\n      println(\"  ucomi%s %%xmm0, %%xmm1\", sz);\n\n      if (node->kind == ND_EQ) {\n        println(\"  sete %%al\");\n        println(\"  setnp %%dl\");\n        println(\"  and %%dl, %%al\");\n      } else if (node->kind == ND_NE) {\n        println(\"  setne %%al\");\n        println(\"  setp %%dl\");\n        println(\"  or %%dl, %%al\");\n      } else if (node->kind == ND_LT) {\n        println(\"  seta %%al\");\n      } else {\n        println(\"  setae %%al\");\n      }\n\n      println(\"  and $1, %%al\");\n      println(\"  movzb %%al, %%rax\");\n      return;\n    }\n\n    error_tok(node->tok, \"invalid expression\");\n  }\n  case TY_LDOUBLE: {\n    gen_expr(node->lhs);\n    gen_expr(node->rhs);\n\n    switch (node->kind) {\n    case ND_ADD:\n      println(\"  faddp\");\n      return;\n    case ND_SUB:\n      println(\"  fsubrp\");\n      return;\n    case ND_MUL:\n      println(\"  fmulp\");\n      return;\n    case ND_DIV:\n      println(\"  fdivrp\");\n      return;\n    case ND_EQ:\n    case ND_NE:\n    case ND_LT:\n    case ND_LE:\n      println(\"  fcomip\");\n      println(\"  fstp %%st(0)\");\n\n      if (node->kind == ND_EQ)\n        println(\"  sete %%al\");\n      else if (node->kind == ND_NE)\n        println(\"  setne %%al\");\n      else if (node->kind == ND_LT)\n        println(\"  seta %%al\");\n      else\n        println(\"  setae %%al\");\n\n      println(\"  movzb %%al, %%rax\");\n      return;\n    }\n\n    error_tok(node->tok, \"invalid expression\");\n  }\n  }\n\n  gen_expr(node->rhs);\n  push();\n  gen_expr(node->lhs);\n  pop(\"%rdi\");\n\n  char *ax, *di, *dx;\n\n  if (node->lhs->ty->kind == TY_LONG || node->lhs->ty->base) {\n    ax = \"%rax\";\n    di = \"%rdi\";\n    dx = \"%rdx\";\n  } else {\n    ax = \"%eax\";\n    di = \"%edi\";\n    dx = \"%edx\";\n  }\n\n  switch (node->kind) {\n  case ND_ADD:\n    println(\"  add %s, %s\", di, ax);\n    return;\n  case ND_SUB:\n    println(\"  sub %s, %s\", di, ax);\n    return;\n  case ND_MUL:\n    println(\"  imul %s, %s\", di, ax);\n    return;\n  case ND_DIV:\n  case ND_MOD:\n    if (node->ty->is_unsigned) {\n      println(\"  mov $0, %s\", dx);\n      println(\"  div %s\", di);\n    } else {\n      if (node->lhs->ty->size == 8)\n        println(\"  cqo\");\n      else\n        println(\"  cdq\");\n      println(\"  idiv %s\", di);\n    }\n\n    if (node->kind == ND_MOD)\n      println(\"  mov %%rdx, %%rax\");\n    return;\n  case ND_BITAND:\n    println(\"  and %s, %s\", di, ax);\n    return;\n  case ND_BITOR:\n    println(\"  or %s, %s\", di, ax);\n    return;\n  case ND_BITXOR:\n    println(\"  xor %s, %s\", di, ax);\n    return;\n  case ND_EQ:\n  case ND_NE:\n  case ND_LT:\n  case ND_LE:\n    println(\"  cmp %s, %s\", di, ax);\n\n    if (node->kind == ND_EQ) {\n      println(\"  sete %%al\");\n    } else if (node->kind == ND_NE) {\n      println(\"  setne %%al\");\n    } else if (node->kind == ND_LT) {\n      if (node->lhs->ty->is_unsigned)\n        println(\"  setb %%al\");\n      else\n        println(\"  setl %%al\");\n    } else if (node->kind == ND_LE) {\n      if (node->lhs->ty->is_unsigned)\n        println(\"  setbe %%al\");\n      else\n        println(\"  setle %%al\");\n    }\n\n    println(\"  movzb %%al, %%rax\");\n    return;\n  case ND_SHL:\n    println(\"  mov %%rdi, %%rcx\");\n    println(\"  shl %%cl, %s\", ax);\n    return;\n  case ND_SHR:\n    println(\"  mov %%rdi, %%rcx\");\n    if (node->lhs->ty->is_unsigned)\n      println(\"  shr %%cl, %s\", ax);\n    else\n      println(\"  sar %%cl, %s\", ax);\n    return;\n  }\n\n  error_tok(node->tok, \"invalid expression\");\n}", "path": "chibicc/codegen.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "rui314/chibicc", "stars": 8404, "license": "mit", "language": "c", "size": 882}
{"docstring": "// For many binary operators, we implicitly promote operands so that\n// both operands have the same type. Any integral type smaller than\n// int is always promoted to int. If the type of one operand is larger\n// than the other's (e.g. \"long\" vs. \"int\"), the smaller operand will\n// be promoted to match with the other.\n//\n// This operation is called the \"usual arithmetic conversion\".\n", "func_signal": "static void usual_arith_conv(Node **lhs, Node **rhs)", "code": "{\n  Type *ty = get_common_type((*lhs)->ty, (*rhs)->ty);\n  *lhs = new_cast(*lhs, ty);\n  *rhs = new_cast(*rhs, ty);\n}", "path": "chibicc/type.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "rui314/chibicc", "stars": 8404, "license": "mit", "language": "c", "size": 882}
{"docstring": "// Replace file extension\n", "func_signal": "static char *replace_extn(char *tmpl, char *extn)", "code": "{\n  char *filename = basename(strdup(tmpl));\n  char *dot = strrchr(filename, '.');\n  if (dot)\n    *dot = '\\0';\n  return format(\"%s%s\", filename, extn);\n}", "path": "chibicc/main.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "rui314/chibicc", "stars": 8404, "license": "mit", "language": "c", "size": 882}
{"docstring": "// Assign offsets to local variables.\n", "func_signal": "static void assign_lvar_offsets(Obj *prog)", "code": "{\n  for (Obj *fn = prog; fn; fn = fn->next) {\n    if (!fn->is_function)\n      continue;\n\n    // If a function has many parameters, some parameters are\n    // inevitably passed by stack rather than by register.\n    // The first passed-by-stack parameter resides at RBP+16.\n    int top = 16;\n    int bottom = 0;\n\n    int gp = 0, fp = 0;\n\n    // Assign offsets to pass-by-stack parameters.\n    for (Obj *var = fn->params; var; var = var->next) {\n      Type *ty = var->ty;\n\n      switch (ty->kind) {\n      case TY_STRUCT:\n      case TY_UNION:\n        if (ty->size <= 16) {\n          bool fp1 = has_flonum(ty, 0, 8, 0);\n          bool fp2 = has_flonum(ty, 8, 16, 8);\n          if (fp + fp1 + fp2 < FP_MAX && gp + !fp1 + !fp2 < GP_MAX) {\n            fp = fp + fp1 + fp2;\n            gp = gp + !fp1 + !fp2;\n            continue;\n          }\n        }\n        break;\n      case TY_FLOAT:\n      case TY_DOUBLE:\n        if (fp++ < FP_MAX)\n          continue;\n        break;\n      case TY_LDOUBLE:\n        break;\n      default:\n        if (gp++ < GP_MAX)\n          continue;\n      }\n\n      top = align_to(top, 8);\n      var->offset = top;\n      top += var->ty->size;\n    }\n\n    // Assign offsets to pass-by-register parameters and local variables.\n    for (Obj *var = fn->locals; var; var = var->next) {\n      if (var->offset)\n        continue;\n\n      // AMD64 System V ABI has a special alignment rule for an array of\n      // length at least 16 bytes. We need to align such array to at least\n      // 16-byte boundaries. See p.14 of\n      // https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-draft.pdf.\n      int align = (var->ty->kind == TY_ARRAY && var->ty->size >= 16)\n        ? MAX(16, var->align) : var->align;\n\n      bottom += var->ty->size;\n      bottom = align_to(bottom, align);\n      var->offset = -bottom;\n    }\n\n    fn->stack_size = align_to(bottom, 16);\n  }\n}", "path": "chibicc/codegen.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "rui314/chibicc", "stars": 8404, "license": "mit", "language": "c", "size": 882}
{"docstring": "// Load function call arguments. Arguments are already evaluated and\n// stored to the stack as local variables. What we need to do in this\n// function is to load them to registers or push them to the stack as\n// specified by the x86-64 psABI. Here is what the spec says:\n//\n// - Up to 6 arguments of integral type are passed using RDI, RSI,\n//   RDX, RCX, R8 and R9.\n//\n// - Up to 8 arguments of floating-point type are passed using XMM0 to\n//   XMM7.\n//\n// - If all registers of an appropriate type are already used, push an\n//   argument to the stack in the right-to-left order.\n//\n// - Each argument passed on the stack takes 8 bytes, and the end of\n//   the argument area must be aligned to a 16 byte boundary.\n//\n// - If a function is variadic, set the number of floating-point type\n//   arguments to RAX.\n", "func_signal": "static int push_args(Node *node)", "code": "{\n  int stack = 0, gp = 0, fp = 0;\n\n  // If the return type is a large struct/union, the caller passes\n  // a pointer to a buffer as if it were the first argument.\n  if (node->ret_buffer && node->ty->size > 16)\n    gp++;\n\n  // Load as many arguments to the registers as possible.\n  for (Node *arg = node->args; arg; arg = arg->next) {\n    Type *ty = arg->ty;\n\n    switch (ty->kind) {\n    case TY_STRUCT:\n    case TY_UNION:\n      if (ty->size > 16) {\n        arg->pass_by_stack = true;\n        stack += align_to(ty->size, 8) / 8;\n      } else {\n        bool fp1 = has_flonum1(ty);\n        bool fp2 = has_flonum2(ty);\n\n        if (fp + fp1 + fp2 < FP_MAX && gp + !fp1 + !fp2 < GP_MAX) {\n          fp = fp + fp1 + fp2;\n          gp = gp + !fp1 + !fp2;\n        } else {\n          arg->pass_by_stack = true;\n          stack += align_to(ty->size, 8) / 8;\n        }\n      }\n      break;\n    case TY_FLOAT:\n    case TY_DOUBLE:\n      if (fp++ >= FP_MAX) {\n        arg->pass_by_stack = true;\n        stack++;\n      }\n      break;\n    case TY_LDOUBLE:\n      arg->pass_by_stack = true;\n      stack += 2;\n      break;\n    default:\n      if (gp++ >= GP_MAX) {\n        arg->pass_by_stack = true;\n        stack++;\n      }\n    }\n  }\n\n  if ((depth + stack) % 2 == 1) {\n    println(\"  sub $8, %%rsp\");\n    depth++;\n    stack++;\n  }\n\n  push_args2(node->args, true);\n  push_args2(node->args, false);\n\n  // If the return type is a large struct/union, the caller passes\n  // a pointer to a buffer as if it were the first argument.\n  if (node->ret_buffer && node->ty->size > 16) {\n    println(\"  lea %d(%%rbp), %%rax\", node->ret_buffer->offset);\n    push();\n  }\n\n  return stack;\n}", "path": "chibicc/codegen.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "rui314/chibicc", "stars": 8404, "license": "mit", "language": "c", "size": 882}
{"docstring": "// Make room for new entires in a given hashmap by removing\n// tombstones and possibly extending the bucket size.\n", "func_signal": "static void rehash(HashMap *map)", "code": "{\n  // Compute the size of the new hashmap.\n  int nkeys = 0;\n  for (int i = 0; i < map->capacity; i++)\n    if (map->buckets[i].key && map->buckets[i].key != TOMBSTONE)\n      nkeys++;\n\n  int cap = map->capacity;\n  while ((nkeys * 100) / cap >= LOW_WATERMARK)\n    cap = cap * 2;\n  assert(cap > 0);\n\n  // Create a new hashmap and copy all key-values.\n  HashMap map2 = {};\n  map2.buckets = calloc(cap, sizeof(HashEntry));\n  map2.capacity = cap;\n\n  for (int i = 0; i < map->capacity; i++) {\n    HashEntry *ent = &map->buckets[i];\n    if (ent->key && ent->key != TOMBSTONE)\n      hashmap_put2(&map2, ent->key, ent->keylen, ent->val);\n  }\n\n  assert(map2.used == nkeys);\n  *map = map2;\n}", "path": "chibicc/hashmap.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "rui314/chibicc", "stars": 8404, "license": "mit", "language": "c", "size": 882}
{"docstring": "// Encode a given character in UTF-8.\n", "func_signal": "int encode_utf8(char *buf, uint32_t c)", "code": "{\n  if (c <= 0x7F) {\n    buf[0] = c;\n    return 1;\n  }\n\n  if (c <= 0x7FF) {\n    buf[0] = 0b11000000 | (c >> 6);\n    buf[1] = 0b10000000 | (c & 0b00111111);\n    return 2;\n  }\n\n  if (c <= 0xFFFF) {\n    buf[0] = 0b11100000 | (c >> 12);\n    buf[1] = 0b10000000 | ((c >> 6) & 0b00111111);\n    buf[2] = 0b10000000 | (c & 0b00111111);\n    return 3;\n  }\n\n  buf[0] = 0b11110000 | (c >> 18);\n  buf[1] = 0b10000000 | ((c >> 12) & 0b00111111);\n  buf[2] = 0b10000000 | ((c >> 6) & 0b00111111);\n  buf[3] = 0b10000000 | (c & 0b00111111);\n  return 4;\n}", "path": "chibicc/unicode.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "rui314/chibicc", "stars": 8404, "license": "mit", "language": "c", "size": 882}
{"docstring": "// Returns true if a given file exists.\n", "func_signal": "bool file_exists(char *path)", "code": "{\n  struct stat st;\n  return !stat(path, &st);\n}", "path": "chibicc/main.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "rui314/chibicc", "stars": 8404, "license": "mit", "language": "c", "size": 882}
{"docstring": "// Structs or unions equal or smaller than 16 bytes are passed\n// using up to two registers.\n//\n// If the first 8 bytes contains only floating-point type members,\n// they are passed in an XMM register. Otherwise, they are passed\n// in a general-purpose register.\n//\n// If a struct/union is larger than 8 bytes, the same rule is\n// applied to the the next 8 byte chunk.\n//\n// This function returns true if `ty` has only floating-point\n// members in its byte range [lo, hi).\n", "func_signal": "static bool has_flonum(Type *ty, int lo, int hi, int offset)", "code": "{\n  if (ty->kind == TY_STRUCT || ty->kind == TY_UNION) {\n    for (Member *mem = ty->members; mem; mem = mem->next)\n      if (!has_flonum(mem->ty, lo, hi, offset + mem->offset))\n        return false;\n    return true;\n  }\n\n  if (ty->kind == TY_ARRAY) {\n    for (int i = 0; i < ty->array_len; i++)\n      if (!has_flonum(ty->base, lo, hi, offset + ty->base->size * i))\n        return false;\n    return true;\n  }\n\n  return offset < lo || hi <= offset || ty->kind == TY_FLOAT || ty->kind == TY_DOUBLE;\n}", "path": "chibicc/codegen.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "rui314/chibicc", "stars": 8404, "license": "mit", "language": "c", "size": 882}
{"docstring": "/*\n * This is a block comment.\n */\n", "func_signal": "int main()", "code": "{\n  ASSERT(3, ({ int x; if (0) x=2; else x=3; x; }));\n  ASSERT(3, ({ int x; if (1-1) x=2; else x=3; x; }));\n  ASSERT(2, ({ int x; if (1) x=2; else x=3; x; }));\n  ASSERT(2, ({ int x; if (2-1) x=2; else x=3; x; }));\n\n  ASSERT(55, ({ int i=0; int j=0; for (i=0; i<=10; i=i+1) j=i+j; j; }));\n\n  ASSERT(10, ({ int i=0; while(i<10) i=i+1; i; }));\n\n  ASSERT(3, ({ 1; {2;} 3; }));\n  ASSERT(5, ({ ;;; 5; }));\n\n  ASSERT(10, ({ int i=0; while(i<10) i=i+1; i; }));\n  ASSERT(55, ({ int i=0; int j=0; while(i<=10) {j=i+j; i=i+1;} j; }));\n\n  ASSERT(3, (1,2,3));\n  ASSERT(5, ({ int i=2, j=3; (i=5,j)=6; i; }));\n  ASSERT(6, ({ int i=2, j=3; (i=5,j)=6; j; }));\n\n  ASSERT(55, ({ int j=0; for (int i=0; i<=10; i=i+1) j=j+i; j; }));\n  ASSERT(3, ({ int i=3; int j=0; for (int i=0; i<=10; i=i+1) j=j+i; i; }));\n\n  ASSERT(1, 0||1);\n  ASSERT(1, 0||(2-2)||5);\n  ASSERT(0, 0||0);\n  ASSERT(0, 0||(2-2));\n\n  ASSERT(0, 0&&1);\n  ASSERT(0, (2-2)&&5);\n  ASSERT(1, 1&&5);\n\n  ASSERT(3, ({ int i=0; goto a; a: i++; b: i++; c: i++; i; }));\n  ASSERT(2, ({ int i=0; goto e; d: i++; e: i++; f: i++; i; }));\n  ASSERT(1, ({ int i=0; goto i; g: i++; h: i++; i: i++; i; }));\n\n  ASSERT(1, ({ typedef int foo; goto foo; foo:; 1; }));\n\n  ASSERT(3, ({ int i=0; for(;i<10;i++) { if (i == 3) break; } i; }));\n  ASSERT(4, ({ int i=0; while (1) { if (i++ == 3) break; } i; }));\n  ASSERT(3, ({ int i=0; for(;i<10;i++) { for (;;) break; if (i == 3) break; } i; }));\n  ASSERT(4, ({ int i=0; while (1) { while(1) break; if (i++ == 3) break; } i; }));\n\n  ASSERT(10, ({ int i=0; int j=0; for (;i<10;i++) { if (i>5) continue; j++; } i; }));\n  ASSERT(6, ({ int i=0; int j=0; for (;i<10;i++) { if (i>5) continue; j++; } j; }));\n  ASSERT(10, ({ int i=0; int j=0; for(;!i;) { for (;j!=10;j++) continue; break; } j; }));\n  ASSERT(11, ({ int i=0; int j=0; while (i++<10) { if (i>5) continue; j++; } i; }));\n  ASSERT(5, ({ int i=0; int j=0; while (i++<10) { if (i>5) continue; j++; } j; }));\n  ASSERT(11, ({ int i=0; int j=0; while(!i) { while (j++!=10) continue; break; } j; }));\n\n  ASSERT(5, ({ int i=0; switch(0) { case 0:i=5;break; case 1:i=6;break; case 2:i=7;break; } i; }));\n  ASSERT(6, ({ int i=0; switch(1) { case 0:i=5;break; case 1:i=6;break; case 2:i=7;break; } i; }));\n  ASSERT(7, ({ int i=0; switch(2) { case 0:i=5;break; case 1:i=6;break; case 2:i=7;break; } i; }));\n  ASSERT(0, ({ int i=0; switch(3) { case 0:i=5;break; case 1:i=6;break; case 2:i=7;break; } i; }));\n  ASSERT(5, ({ int i=0; switch(0) { case 0:i=5;break; default:i=7; } i; }));\n  ASSERT(7, ({ int i=0; switch(1) { case 0:i=5;break; default:i=7; } i; }));\n  ASSERT(2, ({ int i=0; switch(1) { case 0: 0; case 1: 0; case 2: 0; i=2; } i; }));\n  ASSERT(0, ({ int i=0; switch(3) { case 0: 0; case 1: 0; case 2: 0; i=2; } i; }));\n\n  ASSERT(3, ({ int i=0; switch(-1) { case 0xffffffff: i=3; break; } i; }));\n\n  ASSERT(7, ({ int i=0; int j=0; do { j++; } while (i++ < 6); j; }));\n  ASSERT(4, ({ int i=0; int j=0; int k=0; do { if (++j > 3) break; continue; k++; } while (1); j; }));\n\n  ASSERT(0, 0.0 && 0.0);\n  ASSERT(0, 0.0 && 0.1);\n  ASSERT(0, 0.3 && 0.0);\n  ASSERT(1, 0.3 && 0.5);\n  ASSERT(0, 0.0 || 0.0);\n  ASSERT(1, 0.0 || 0.1);\n  ASSERT(1, 0.3 || 0.0);\n  ASSERT(1, 0.3 || 0.5);\n  ASSERT(5, ({ int x; if (0.0) x=3; else x=5; x; }));\n  ASSERT(3, ({ int x; if (0.1) x=3; else x=5; x; }));\n  ASSERT(5, ({ int x=5; if (0.0) x=3; x; }));\n  ASSERT(3, ({ int x=5; if (0.1) x=3; x; }));\n  ASSERT(10, ({ double i=10.0; int j=0; for (; i; i--, j++); j; }));\n  ASSERT(10, ({ double i=10.0; int j=0; do j++; while(--i); j; }));\n\n  ASSERT(2, ({ int i=0; switch(7) { case 0 ... 5: i=1; break; case 6 ... 20: i=2; break; } i; }));\n  ASSERT(1, ({ int i=0; switch(7) { case 0 ... 7: i=1; break; case 8 ... 10: i=2; break; } i; }));\n  ASSERT(1, ({ int i=0; switch(7) { case 0: i=1; break; case 7 ... 7: i=1; break; } i; }));\n\n  ASSERT(3, ({ void *p = &&v11; int i=0; goto *p; v11:i++; v12:i++; v13:i++; i; }));\n  ASSERT(2, ({ void *p = &&v22; int i=0; goto *p; v21:i++; v22:i++; v23:i++; i; }));\n  ASSERT(1, ({ void *p = &&v33; int i=0; goto *p; v31:i++; v32:i++; v33:i++; i; }));\n\n  ASSERT(3, ({ static void *p[]={&&v41,&&v42,&&v43}; int i=0; goto *p[0]; v41:i++; v42:i++; v43:i++; i; }));\n  ASSERT(2, ({ static void *p[]={&&v52,&&v52,&&v53}; int i=0; goto *p[1]; v51:i++; v52:i++; v53:i++; i; }));\n  ASSERT(1, ({ static void *p[]={&&v62,&&v62,&&v63}; int i=0; goto *p[2]; v61:i++; v62:i++; v63:i++; i; }));\n\n  printf(\"OK\\n\");\n  return 0;\n}", "path": "chibicc/test/control.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "rui314/chibicc", "stars": 8404, "license": "mit", "language": "c", "size": 882}
{"docstring": "// If -M options is given, the compiler write a list of input files to\n// stdout in a format that \"make\" command can read. This feature is\n// used to automate file dependency management.\n", "func_signal": "static void print_dependencies(void)", "code": "{\n  char *path;\n  if (opt_MF)\n    path = opt_MF;\n  else if (opt_MD)\n    path = replace_extn(opt_o ? opt_o : base_file, \".d\");\n  else if (opt_o)\n    path = opt_o;\n  else\n    path = \"-\";\n\n  FILE *out = open_file(path);\n  if (opt_MT)\n    fprintf(out, \"%s:\", opt_MT);\n  else\n    fprintf(out, \"%s:\", quote_makefile(replace_extn(base_file, \".o\")));\n\n  File **files = get_input_files();\n\n  for (int i = 0; files[i]; i++) {\n    if (opt_MMD && in_std_include_path(files[i]->name))\n      continue;\n    fprintf(out, \" \\\\\\n  %s\", files[i]->name);\n  }\n\n  fprintf(out, \"\\n\\n\");\n\n  if (opt_MP) {\n    for (int i = 1; files[i]; i++) {\n      if (opt_MMD && in_std_include_path(files[i]->name))\n        continue;\n      fprintf(out, \"%s:\\n\\n\", quote_makefile(files[i]->name));\n    }\n  }\n}", "path": "chibicc/main.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "rui314/chibicc", "stars": 8404, "license": "mit", "language": "c", "size": 882}
{"docstring": "/**\n * Check if `x`^th row is valid\n * @param a ::sudoku to check\n * @param x row to check\n * @param y ignored column\n * @param v value to check if it repeats\n * @returns `true` if valid\n * @returns `false` if in-valid\n */\n", "func_signal": "bool OKrow(const struct sudoku *a, int x, int y, int v)", "code": "{\n    int offset = x * a->N;\n    for (int j = 0; j < a->N; j++)\n        if (a->a[offset + j] == v)\n            // if the value is found in the row\n            return false;\n    return true;\n}", "path": "C/misc/sudoku_solver.c", "commit_date": "2020-07-04 00:00:00", "repo_name": "TheAlgorithms/C", "stars": 17769, "license": "gpl-3.0", "language": "c", "size": 21399}
{"docstring": "/**\n * Check if `y`^th column is valid\n * @param a ::sudoku to check\n * @param x ignored row\n * @param y column to check\n * @param v value to check if it repeats\n * @returns `true` if valid\n * @returns `false` if in-valid\n */\n", "func_signal": "bool OKcol(const struct sudoku *a, int x, int y, int v)", "code": "{\n    for (int i = 0; i < a->N; i++)\n        if (a->a[i * a->N + y] == v)\n            // if the value is found in the column\n            return false;\n    return true;\n}", "path": "C/misc/sudoku_solver.c", "commit_date": "2020-07-04 00:00:00", "repo_name": "TheAlgorithms/C", "stars": 17769, "license": "gpl-3.0", "language": "c", "size": 21399}
{"docstring": "/**\n * @brief Testing function\n * @returns `void`\n */\n", "func_signal": "static void test()", "code": "{\n    vec_3d a = {1., 2., 3.};\n    vec_3d b = {1., 1., 1.};\n    float d;\n\n    // printf(\"%s\", print_vector(&a, \"a\"));\n    // printf(\"%s\", print_vector(&b, \"b\"));\n\n    d = vector_norm(&a);\n    // printf(\"|a| = %.4g\\n\", d);\n    assert(fabsf(d - 3.742f) < 0.01);\n    d = vector_norm(&b);\n    // printf(\"|b| = %.4g\\n\", d);\n    assert(fabsf(d - 1.732f) < 0.01);\n\n    d = dot_prod(&a, &b);\n    // printf(\"Dot product: %f\\n\", d);\n    assert(fabsf(d - 6.f) < 0.01);\n\n    vec_3d c = vector_prod(&a, &b);\n    // printf(\"Vector product \");\n    // printf(\"%s\", print_vector(&c, \"c\"));\n    assert(fabsf(c.x - (-1.f)) < 0.01);\n    assert(fabsf(c.y - (2.f)) < 0.01);\n    assert(fabsf(c.z - (-1.f)) < 0.01);\n}", "path": "C/geometry/vectors_3d.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "TheAlgorithms/C", "stars": 17769, "license": "gpl-3.0", "language": "c", "size": 21399}
{"docstring": "/** \\brief Main function */\n", "func_signal": "int main()", "code": "{\n    test();\n\n    struct sudoku a;  // store the matrix as a 1D array\n    scanf(\"%\" SCNu8, &(a.N));\n    a.a = (uint8_t *)malloc(a.N * a.N * sizeof(uint8_t));\n    a.N2 = (uint8_t)sqrt(a.N);\n\n    for (int i = 0; i < a.N; i++)\n        for (int j = 0; j < a.N; j++) scanf(\"%\" SCNu8, &(a.a[i * a.N + j]));\n\n    printf(\"Entered a %udx%ud matrix with block size: %\" SCNu8 \"\\n\", a.N, a.N,\n           a.N2);\n    // print(&a);\n    printf(\"\\n\\n\");\n    if (solve(&a))\n        printf(\"Valid solution found!\\n\");\n    else\n        printf(\"Invalid\\n\");\n    print(&a);\n\n    free(a.a);\n    return 0;\n}", "path": "C/misc/sudoku_solver.c", "commit_date": "2020-07-04 00:00:00", "repo_name": "TheAlgorithms/C", "stars": 17769, "license": "gpl-3.0", "language": "c", "size": 21399}
{"docstring": "/**\n * Check if element `v` is valid to place at (x,y) location.\n * @param a ::sudoku to check\n * @param x row to place value\n * @param y column to place value\n * @param v value to check if it is valid\n * @returns `true` if valid\n * @returns `false` if in-valid\n */\n", "func_signal": "bool OK(const struct sudoku *a, int x, int y, int v)", "code": "{\n    bool result = OKrow(a, x, y, v);\n    if (result)\n        result = OKcol(a, x, y, v);\n    if (result)\n        result = OKbox(a, x, y, v);\n\n    return result;\n}", "path": "C/misc/sudoku_solver.c", "commit_date": "2020-07-04 00:00:00", "repo_name": "TheAlgorithms/C", "stars": 17769, "license": "gpl-3.0", "language": "c", "size": 21399}
{"docstring": "/**\n * @brief Function to solve a partially filled sudoku matrix. For each unknown\n * value (0), the function fills a possible value and calls the function again\n * to check forvalid solution.\n *\n * @param [in,out] a sudoku matrix to solve\n * @return `true` if solution found\n * @return `false` if no solution found\n */\n", "func_signal": "bool solve(struct sudoku *a)", "code": "{\n    static uint32_t counter = 0;\n    int i, j;\n    static char prefix[100] = \"\";  // enough memory\n\n    if (!get_next_unknown(a, &i, &j))\n    {\n        /* no more empty location found\n           implies all good in the matrix\n         */\n        return true;\n    }\n\n    /* try all possible values for the unknown */\n    for (uint8_t v = 1; v <= a->N; v++)\n    { /* try all possible values 1 thru N */\n        printf(\"%sTry (%d,%d) = %\" SCNu8 \"... \", prefix, i, j, v);\n        counter++;\n        if (OK(a, i, j, v))\n        {\n            /* if assignment checks satisfy, set the value and\n             continue with remaining elements */\n            printf(\"passed (counter=%\" SCNu32 \")\\n\", counter);\n            a->a[i * a->N + j] = v;\n            strcat(prefix, \"  \");\n            if (solve(a))\n            {\n                /* solution found */\n                return true;\n            }\n\n            printf(\"%sBacktrack (%d,%d) <- %\" SCNu8 \" (counter=%\" SCNu32 \")\\n\",\n                   prefix, i, j, a->a[i * a->N + j], counter);\n\n            prefix[strlen(prefix) - 2] = '\\0';  // truncate the prefix\n            a->a[i * a->N + j] = 0;\n        }\n        else\n        {\n            printf(\"\\r\");\n        }\n    }\n\n    return false;\n}", "path": "C/misc/sudoku_solver.c", "commit_date": "2020-07-04 00:00:00", "repo_name": "TheAlgorithms/C", "stars": 17769, "license": "gpl-3.0", "language": "c", "size": 21399}
{"docstring": "/** Utilitary procedure to free all nodes in a tree\n * @param root pointer to parent node\n */\n", "func_signal": "void purge(node *root)", "code": "{\n    if (root != NULL)\n    {\n        if (root->left != NULL)\n        {\n            purge(root->left);\n        }\n        if (root->right != NULL)\n        {\n            purge(root->right);\n        }\n        free(root);\n        root = NULL;  // reset pointer\n    }\n}", "path": "C/data_structures/binary_trees/binary_search_tree.c", "commit_date": "2020-07-22 00:00:00", "repo_name": "TheAlgorithms/C", "stars": 17769, "license": "gpl-3.0", "language": "c", "size": 21399}
{"docstring": "/**\n * @brief Main function\n *\n * @return 0 on exit\n */\n", "func_signal": "int main(void)", "code": "{\n    test();\n\n    return 0;\n}", "path": "C/geometry/vectors_3d.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "TheAlgorithms/C", "stars": 17769, "license": "gpl-3.0", "language": "c", "size": 21399}
{"docstring": "/**\n * Print the matrix to stdout\n * @param [in] a array to print\n */\n", "func_signal": "void print(const struct sudoku *a)", "code": "{\n    int i, j;\n    for (i = 0; i < a->N; i++)\n        for (j = 0; j < a->N; j++)\n            printf(\"%\" SCNu8 \"%c\", a->a[i * a->N + j],\n                   (j == a->N - 1 ? '\\n' : ' '));\n}", "path": "C/misc/sudoku_solver.c", "commit_date": "2020-07-04 00:00:00", "repo_name": "TheAlgorithms/C", "stars": 17769, "license": "gpl-3.0", "language": "c", "size": 21399}
{"docstring": "/**\n * Check if a 3x3 box is valid\n * @param a matrix to check\n * @param x row index of the element to check\n * @param y column index of the element to check\n * @param v value to check if it repeats\n * @returns `true` if valid\n * @returns `false` if in-valid\n */\n", "func_signal": "bool OKbox(const struct sudoku *a, int x, int y, int v)", "code": "{\n    /* get start indices of the box that the current (x,y) lies in\n       remember that in C/C++, division operation always rounds towards\n       -infinity for signed integers and towards 0 for unsigned integers\n    */\n    int bi = x - x % a->N2, bj = y - y % a->N2;\n    // printf(\"Checking box: (%d,%d)\\n\", bi, bj);\n\n    for (int i = bi; i < (bi + a->N2); i++)\n        for (int j = bj; j < (bj + a->N2); j++)\n            if (a->a[i * a->N + j] == v)\n                // if the value is found in the box\n                return false;\n    return true;\n}", "path": "C/misc/sudoku_solver.c", "commit_date": "2020-07-04 00:00:00", "repo_name": "TheAlgorithms/C", "stars": 17769, "license": "gpl-3.0", "language": "c", "size": 21399}
{"docstring": "/** Search procedure, which looks for the input key in the tree and returns 1 if\n * it's present or 0 if it's not in the tree\n * @param root pointer to parent node\n * @param data value to store int he new node\n * @returns 0 if value not found in the nodes\n * @returns 1 if value was found\n */\n", "func_signal": "int find(node *root, int data)", "code": "{\n    // If the root is null, the key's not present\n    if (root == NULL)\n    {\n        return 0;\n    }\n    else if (data > root->data)\n    {\n        // If the input key is greater than the root's, search in the right\n        // subtree\n        return find(root->right, data);\n    }\n    else if (data < root->data)\n    {\n        // If the input key is lower than the root's, search in the left subtree\n        return find(root->left, data);\n    }\n    else if (data == root->data)\n    {\n        // If the input and the root key match, return 1\n        return 1;\n    }\n    else\n    {  // unknown result!!\n        return 0;\n    }\n}", "path": "C/data_structures/binary_trees/binary_search_tree.c", "commit_date": "2020-07-22 00:00:00", "repo_name": "TheAlgorithms/C", "stars": 17769, "license": "gpl-3.0", "language": "c", "size": 21399}
{"docstring": "/**\n * Print formatted vector on stdout.\n * @param[in] a vector to print\n * @param[in] name  name of the vector\n * @returns string representation of vector\n */\n", "func_signal": "const char *print_vector(const vec_3d *a, const char *name)", "code": "{\n    static char vec_str[100];  // static to ensure the string life extends the\n                               // life of function\n\n    snprintf(vec_str, 99, \"vec(%s) = (%.3g)i + (%.3g)j + (%.3g)k\\n\", name, a->x,\n             a->y, a->z);\n    return vec_str;\n}", "path": "C/geometry/vectors_3d.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "TheAlgorithms/C", "stars": 17769, "license": "gpl-3.0", "language": "c", "size": 21399}
{"docstring": "/** Deletion procedure, which searches for the input key in the tree and removes\n * it if present\n * @param root pointer to parent node\n * @param data value to search for int the node\n * @returns pointer to parent node\n */\n", "func_signal": "node *delete (node *root, int data)", "code": "{\n    // If the root is null, nothing to be done\n    if (root == NULL)\n    {\n        return root;\n    }\n    else if (data > root->data)\n    {  // If the input key is greater than the root's, search in the right\n        // subtree\n        root->right = delete (root->right, data);\n    }\n    else if (data < root->data)\n    {  // If the input key is lower than the root's, search in the left subtree\n        root->left = delete (root->left, data);\n    }\n    else if (data == root->data)\n    {\n        // If the input key matches the root's, check the following cases\n        // termination condition\n        if ((root->left == NULL) && (root->right == NULL))\n        {  // Case 1: the root has no leaves, remove the node\n            free(root);\n            return NULL;\n        }\n        else if (root->left == NULL)\n        {  // Case 2: the root has one leaf, make the leaf the new root and\n            // remove\n            // the old root\n            node *tmp = root;\n            root = root->right;\n            free(tmp);\n            return root;\n        }\n        else if (root->right == NULL)\n        {\n            node *tmp = root;\n            root = root->left;\n            free(tmp);\n            return root;\n        }\n        else\n        {  // Case 3: the root has 2 leaves, find the greatest key in the left\n            // subtree and switch with the root's\n\n            // finds the biggest node in the left branch.\n            node *tmp = getMax(root->left);\n\n            // sets the data of this node equal to the data of the biggest node\n            // (lefts)\n            root->data = tmp->data;\n            root->left = delete (root->left, tmp->data);\n        }\n    }\n    return root;\n}", "path": "C/data_structures/binary_trees/binary_search_tree.c", "commit_date": "2020-07-22 00:00:00", "repo_name": "TheAlgorithms/C", "stars": 17769, "license": "gpl-3.0", "language": "c", "size": 21399}
{"docstring": "/** Utilitary procedure to measure the height of the binary tree\n * @param root pointer to parent node\n * @param data value to store int he new node\n * @returns 0 if value not found in the nodes\n * @returns height of nodes to get to data from parent node\n */\n", "func_signal": "int height(node *root)", "code": "{\n    // If the root is null, this is the bottom of the tree (height 0)\n    if (root == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        // Get the height from both left and right subtrees to check which is\n        // the greatest\n        int right_h = height(root->right);\n        int left_h = height(root->left);\n\n        // The final height is the height of the greatest subtree(left or right)\n        // plus 1(which is the root's level)\n        if (right_h > left_h)\n        {\n            return (right_h + 1);\n        }\n        else\n        {\n            return (left_h + 1);\n        }\n    }\n}", "path": "C/data_structures/binary_trees/binary_search_tree.c", "commit_date": "2020-07-22 00:00:00", "repo_name": "TheAlgorithms/C", "stars": 17769, "license": "gpl-3.0", "language": "c", "size": 21399}
{"docstring": "/** Traversal procedure to list the current keys in the tree in order of value\n * (from the left to the right)\n * @param root pointer to parent node\n */\n", "func_signal": "void inOrder(node *root)", "code": "{\n    if (root != NULL)\n    {\n        inOrder(root->left);\n        printf(\"\\t[ %d ]\\t\", root->data);\n        inOrder(root->right);\n    }\n}", "path": "C/data_structures/binary_trees/binary_search_tree.c", "commit_date": "2020-07-22 00:00:00", "repo_name": "TheAlgorithms/C", "stars": 17769, "license": "gpl-3.0", "language": "c", "size": 21399}
{"docstring": "/** Utilitary procedure to find the greatest key in the left subtree\n * @param root pointer to parent node\n * @returns pointer to parent node\n */\n", "func_signal": "node *getMax(node *root)", "code": "{\n    // If there's no leaf to the right, then this is the maximum key value\n    if (root->right != NULL)\n    {\n        return getMax(root->right);\n    }\n    return root;\n}", "path": "C/data_structures/binary_trees/binary_search_tree.c", "commit_date": "2020-07-22 00:00:00", "repo_name": "TheAlgorithms/C", "stars": 17769, "license": "gpl-3.0", "language": "c", "size": 21399}
{"docstring": "/**\n * @brief Find and get the location for next empty cell.\n *\n * @param [in] a pointer to sudoku instance\n * @param [out] x pointer to row index of next unknown\n * @param [out] y pointer to column index of next unknown\n * @returns `true` if an empty location was found\n * @returns `false` if no more empty locations found\n */\n", "func_signal": "bool get_next_unknown(const struct sudoku *a, int *x, int *y)", "code": "{\n    for (int i = 0; i < a->N; i++)\n    {\n        for (int j = 0; j < a->N; j++)\n        {\n            if (a->a[i * a->N + j] == 0)\n            {\n                *x = i;\n                *y = j;\n                return true;\n            }\n        }\n    }\n\n    /* no unknown locations found */\n    return false;\n}", "path": "C/misc/sudoku_solver.c", "commit_date": "2020-07-04 00:00:00", "repo_name": "TheAlgorithms/C", "stars": 17769, "license": "gpl-3.0", "language": "c", "size": 21399}
{"docstring": "/** The node constructor, which receives the key value input and returns a node\n * pointer\n * @param data data to store in a new node\n * @returns new node with the provided data\n * @note the node must be deleted before program terminates to avoid memory\n * leaks\n */\n", "func_signal": "node *newNode(int data)", "code": "{\n    // creates a slug\n    node *tmp = (node *)malloc(sizeof(node));\n\n    // initializes the slug\n    tmp->data = data;\n    tmp->left = NULL;\n    tmp->right = NULL;\n\n    return tmp;\n}", "path": "C/data_structures/binary_trees/binary_search_tree.c", "commit_date": "2020-07-22 00:00:00", "repo_name": "TheAlgorithms/C", "stars": 17769, "license": "gpl-3.0", "language": "c", "size": 21399}
{"docstring": "/**\n * @brief Exact solution of the problem. Used for solution comparison.\n *\n * @param[in] \t\tx \t\tindependent variable\n * @param[in,out]\ty\t\tdependent variable\n */\n", "func_signal": "void exact_solution(const double *x, double *y)", "code": "{\n    y[0] = cos(x[0]);\n    y[1] = -sin(x[0]);\n}", "path": "C/numerical_methods/ode_forward_euler.c", "commit_date": "2020-06-28 00:00:00", "repo_name": "TheAlgorithms/C", "stars": 17769, "license": "gpl-3.0", "language": "c", "size": 21399}
{"docstring": "/** Main funcion */\n", "func_signal": "int main()", "code": "{\n    // this reference don't change.\n    // only the tree changes.\n    node *root = NULL;\n    int opt = -1;\n    int data = 0;\n\n    // event-loop.\n    while (opt != 0)\n    {\n        printf(\n            \"\\n\\n[1] Insert Node\\n[2] Delete Node\\n[3] Find a Node\\n[4] Get \"\n            \"current Height\\n[5] Print Tree in Crescent Order\\n[0] Quit\\n\");\n        scanf(\"%d\", &opt);  // reads the choice of the user\n\n        // processes the choice\n        switch (opt)\n        {\n        case 1:\n            printf(\"Enter the new node's value:\\n\");\n            scanf(\"%d\", &data);\n            root = insert(root, data);\n            break;\n\n        case 2:\n            printf(\"Enter the value to be removed:\\n\");\n            if (root != NULL)\n            {\n                scanf(\"%d\", &data);\n                root = delete (root, data);\n            }\n            else\n            {\n                printf(\"Tree is already empty!\\n\");\n            }\n            break;\n\n        case 3:\n            printf(\"Enter the searched value:\\n\");\n            scanf(\"%d\", &data);\n            find(root, data) ? printf(\"The value is in the tree.\\n\")\n                             : printf(\"The value is not in the tree.\\n\");\n            break;\n\n        case 4:\n            printf(\"Current height of the tree is: %d\\n\", height(root));\n            break;\n\n        case 5:\n            inOrder(root);\n            break;\n        }\n    }\n\n    // deletes the tree from the heap.\n    purge(root);\n\n    return 0;\n}", "path": "C/data_structures/binary_trees/binary_search_tree.c", "commit_date": "2020-07-22 00:00:00", "repo_name": "TheAlgorithms/C", "stars": 17769, "license": "gpl-3.0", "language": "c", "size": 21399}
{"docstring": "/**\n ** Transmit machine\n **/\n", "func_signal": "static int\nbondport_can_transmit(bondport_ref p, int32_t current_secs,\n\t\t      __darwin_time_t * next_secs)", "code": "{\n    if (p->po_last_transmit_secs != current_secs) {\n\tp->po_last_transmit_secs = current_secs;\n\tp->po_n_transmit = 0;\n    }\n    if (p->po_n_transmit < LACP_PACKET_RATE) {\n\tp->po_n_transmit++;\n\treturn (1);\n    }\n    if (next_secs != NULL) {\n\t*next_secs = current_secs + 1;\n    }\n    return (0);\n}", "path": "darwin-xnu/bsd/net/if_bond.c", "commit_date": "2018-12-10 00:00:00", "repo_name": "apple/darwin-xnu", "stars": 10860, "license": "other", "language": "c", "size": 81924}
{"docstring": "/*\n * Function: bond_attach_protocol\n * Purpose:\n *   Attach a DLIL protocol to the interface.\n *\n *   The ethernet demux special cases to always return PF_BOND if the \n *   interface is bonded.  That means we receive all traffic from that\n *   interface without passing any of the traffic to any other attached\n *   protocol.\n */\n", "func_signal": "static int\nbond_attach_protocol(struct ifnet *ifp)", "code": "{\n    int\t\t\t\t\t\t\t\terror;\n    struct ifnet_attach_proto_param\treg;\n\t\n    bzero(&reg, sizeof(reg));\n    reg.input = bond_input;\n    reg.event = bond_event;\n    reg.detached = bond_detached;\n\t\n    error = ifnet_attach_protocol(ifp, PF_BOND, &reg);\n    if (error) {\n\tprintf(\"bond over %s%d: ifnet_attach_protocol failed, %d\\n\",\n\t       ifnet_name(ifp), ifnet_unit(ifp), error);\n    }\n    return (error);\n}", "path": "darwin-xnu/bsd/net/if_bond.c", "commit_date": "2018-12-10 00:00:00", "repo_name": "apple/darwin-xnu", "stars": 10860, "license": "other", "language": "c", "size": 81924}
{"docstring": "/**\n ** Receive machine\n **/\n", "func_signal": "static void\nbondport_UpdateDefaultSelected(bondport_ref p)", "code": "{\n    bondport_set_selected(p, SelectedState_UNSELECTED);\n    return;\n}", "path": "darwin-xnu/bsd/net/if_bond.c", "commit_date": "2018-12-10 00:00:00", "repo_name": "apple/darwin-xnu", "stars": 10860, "license": "other", "language": "c", "size": 81924}
{"docstring": "/*\n * generate standard sockaddr_in6 from embedded form.\n * touches sin6_addr and sin6_scope_id only.\n *\n * this function should be nuked in the future, when we get rid of\n * embedded scopeid thing.\n */\n", "func_signal": "int\nin6_recoverscope(\n\tstruct sockaddr_in6 *sin6,\n\tconst struct in6_addr *in6,\n\tstruct ifnet *ifp)", "code": "{\n\tu_int32_t scopeid;\n\n\tsin6->sin6_addr = *in6;\n\n\t/*\n\t * don't try to read *in6 beyond here, since the caller may\n\t * ask us to overwrite existing sockaddr_in6\n\t */\n\n\tsin6->sin6_scope_id = 0;\n\tif (IN6_IS_SCOPE_LINKLOCAL(in6) || IN6_IS_ADDR_MC_INTFACELOCAL(in6)) {\n\t\t/*\n\t\t * KAME assumption: link id == interface id\n\t\t */\n\t\tscopeid = ntohs(sin6->sin6_addr.s6_addr16[1]);\n\t\tif (scopeid) {\n\t\t\t/*\n\t\t\t * sanity check\n\t\t\t *\n\t\t\t * Since scopeid is unsigned, we only have to check it\n\t\t\t * against if_index\n\t\t\t */\n\t\t\tif (if_index < scopeid)\n\t\t\t\treturn (ENXIO);\n\t\t\tif (ifp && ifp->if_index != scopeid)\n\t\t\t\treturn (ENXIO);\n\t\t\tsin6->sin6_addr.s6_addr16[1] = 0;\n\t\t\tsin6->sin6_scope_id = scopeid;\n\t\t}\n\t}\n\n\treturn (0);\n}", "path": "darwin-xnu/bsd/netinet6/in6_src.c", "commit_date": "2018-12-10 00:00:00", "repo_name": "apple/darwin-xnu", "stars": 10860, "license": "other", "language": "c", "size": 81924}
{"docstring": "/* BYTE_ORDER == LITTLE_ENDIAN */\n", "func_signal": "static int\nS_mbuf_copy_uint32(struct mbuf * m, int32_t offset, uint32_t * val)", "code": "{\n    struct mbuf *\tcurrent;\n    u_char *\t\tcurrent_data;\n    struct mbuf *\tnext;\n    u_char *\t\tnext_data;\n    int\t\t\tspace_current;\n\n    current = S_mbuf_skip_to_offset(m, &offset);\n    if (current == NULL) {\n\treturn (1);\n    }\n    current_data = mtod(current, u_char *) + offset;\n    space_current = current->m_len - offset;\n    if (space_current >= (int)sizeof(uint32_t)) {\n\t*val = *((uint32_t *)current_data);\n\treturn (0);\n    }\n    next = current->m_next;\n    if (next == NULL || (next->m_len + space_current) < (int)sizeof(uint32_t)) {\n\treturn (1);\n    }\n    next_data = mtod(next, u_char *);\n    switch (space_current) {\n    case 1:\n\t*val = make_uint32(current_data[0], next_data[0],\n\t\t\t   next_data[1], next_data[2]);\n\tbreak;\n    case 2:\n\t*val = make_uint32(current_data[0], current_data[1],\n\t\t\t   next_data[0], next_data[1]);\n\tbreak;\n    default:\n\t*val = make_uint32(current_data[0], current_data[1],\n\t\t\t   current_data[2], next_data[0]);\n\tbreak;\n    }\n    return (0);\n}", "path": "darwin-xnu/bsd/net/if_bond.c", "commit_date": "2018-12-10 00:00:00", "repo_name": "apple/darwin-xnu", "stars": 10860, "license": "other", "language": "c", "size": 81924}
{"docstring": "/*\n * Default hop limit selection. The precedence is as follows:\n * 1. Hoplimit value specified via ioctl.\n * 2. (If the outgoing interface is detected) the current\n *     hop limit of the interface specified by router advertisement.\n * 3. The system default hoplimit.\n */\n", "func_signal": "int\nin6_selecthlim(struct in6pcb *in6p, struct ifnet *ifp)", "code": "{\n\tif (in6p && in6p->in6p_hops >= 0) {\n\t\treturn (in6p->in6p_hops);\n\t} else if (NULL != ifp) {\n\t\tu_int8_t chlim;\n\t\tstruct nd_ifinfo *ndi = ND_IFINFO(ifp);\n\t\tif (ndi && ndi->initialized) {\n\t\t\t/* access chlim without lock, for performance */\n\t\t\tchlim = ndi->chlim;\n\t\t} else {\n\t\t\tchlim = ip6_defhlim;\n\t\t}\n\t\treturn (chlim);\n\t}\n\n\treturn (ip6_defhlim);\n}", "path": "darwin-xnu/bsd/netinet6/in6_src.c", "commit_date": "2018-12-10 00:00:00", "repo_name": "apple/darwin-xnu", "stars": 10860, "license": "other", "language": "c", "size": 81924}
{"docstring": "/**\n ** bond locks\n **/\n", "func_signal": "static __inline__ lck_grp_t *\nmy_lck_grp_alloc_init(const char * grp_name)", "code": "{\n    lck_grp_t *\t\tgrp;\n    lck_grp_attr_t *\tgrp_attrs;\n    \n    grp_attrs = lck_grp_attr_alloc_init();\n    grp = lck_grp_alloc_init(grp_name, grp_attrs);\n    lck_grp_attr_free(grp_attrs);\n    return (grp);\n}", "path": "darwin-xnu/bsd/net/if_bond.c", "commit_date": "2018-12-10 00:00:00", "repo_name": "apple/darwin-xnu", "stars": 10860, "license": "other", "language": "c", "size": 81924}
{"docstring": "/*\n * Regardless of error, it will return an ifp with a reference held if the\n * caller provides a non-NULL ifpp.  The caller is responsible for checking\n * if the returned ifp is valid and release its reference at all times.\n */\n", "func_signal": "struct in6_addr *\nin6_selectsrc(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,\n    struct inpcb *inp, struct route_in6 *ro,\n    struct ifnet **ifpp, struct in6_addr *src_storage, unsigned int ifscope,\n    int *errorp)", "code": "{\n\tstruct ifnet *ifp = NULL;\n\tstruct in6_pktinfo *pi = NULL;\n\tstruct ip6_moptions *mopts;\n\tstruct ip6_out_args ip6oa;\n\tboolean_t inp_debug = FALSE;\n\tuint32_t hint_mask = 0;\n\tint prefer_tempaddr = 0;\n\tstruct ifnet *sifp = NULL;\n\n\tbzero(&ip6oa, sizeof(ip6oa));\n\tip6oa.ip6oa_boundif = ifscope;\n\tip6oa.ip6oa_flags = IP6OAF_SELECT_SRCIF;\n\tip6oa.ip6oa_sotc = SO_TC_UNSPEC;\n\tip6oa.ip6oa_netsvctype = _NET_SERVICE_TYPE_UNSPEC;\n\n\t*errorp = 0;\n\tif (ifpp != NULL)\n\t\t*ifpp = NULL;\n\n\tif (inp != NULL) {\n\t\tinp_debug = SASEL_DO_DBG(inp);\n\t\tmopts = inp->in6p_moptions;\n\t\tif (INP_NO_CELLULAR(inp))\n\t\t\tip6oa.ip6oa_flags |= IP6OAF_NO_CELLULAR;\n\t\tif (INP_NO_EXPENSIVE(inp))\n\t\t\tip6oa.ip6oa_flags |= IP6OAF_NO_EXPENSIVE;\n\t\tif (INP_AWDL_UNRESTRICTED(inp))\n\t\t\tip6oa.ip6oa_flags |= IP6OAF_AWDL_UNRESTRICTED;\n\t\tif (INP_INTCOPROC_ALLOWED(inp))\n\t\t\tip6oa.ip6oa_flags |= IP6OAF_INTCOPROC_ALLOWED;\n\t} else {\n\t\tmopts = NULL;\n\t\t/* Allow the kernel to retransmit packets. */\n\t\tip6oa.ip6oa_flags |= IP6OAF_INTCOPROC_ALLOWED |\n\t\t    IP6OAF_AWDL_UNRESTRICTED;\n\t}\n\n\tif (ip6oa.ip6oa_boundif != IFSCOPE_NONE)\n\t\tip6oa.ip6oa_flags |= IP6OAF_BOUND_IF;\n\n\t/*\n\t * If the source address is explicitly specified by the caller,\n\t * check if the requested source address is indeed a unicast address\n\t * assigned to the node, and can be used as the packet's source\n\t * address.  If everything is okay, use the address as source.\n\t */\n\tif (opts && (pi = opts->ip6po_pktinfo) &&\n\t    !IN6_IS_ADDR_UNSPECIFIED(&pi->ipi6_addr)) {\n\t\tstruct sockaddr_in6 srcsock;\n\t\tstruct in6_ifaddr *ia6;\n\n\t\t/* get the outgoing interface */\n\t\tif ((*errorp = in6_selectif(dstsock, opts, mopts, ro, &ip6oa,\n\t\t    &ifp)) != 0) {\n\t\t\tsrc_storage = NULL;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/*\n\t\t * determine the appropriate zone id of the source based on\n\t\t * the zone of the destination and the outgoing interface.\n\t\t * If the specified address is ambiguous wrt the scope zone,\n\t\t * the interface must be specified; otherwise, ifa_ifwithaddr()\n\t\t * will fail matching the address.\n\t\t */\n\t\tbzero(&srcsock, sizeof (srcsock));\n\t\tsrcsock.sin6_family = AF_INET6;\n\t\tsrcsock.sin6_len = sizeof (srcsock);\n\t\tsrcsock.sin6_addr = pi->ipi6_addr;\n\t\tif (ifp != NULL) {\n\t\t\t*errorp = in6_setscope(&srcsock.sin6_addr, ifp, NULL);\n\t\t\tif (*errorp != 0) {\n\t\t\t\tsrc_storage = NULL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tia6 = (struct in6_ifaddr *)ifa_ifwithaddr((struct sockaddr *)\n\t\t    (&srcsock));\n\t\tif (ia6 == NULL) {\n\t\t\t*errorp = EADDRNOTAVAIL;\n\t\t\tsrc_storage = NULL;\n\t\t\tgoto done;\n\t\t}\n\t\tIFA_LOCK_SPIN(&ia6->ia_ifa);\n\t\tif ((ia6->ia6_flags & (IN6_IFF_ANYCAST | IN6_IFF_NOTREADY | IN6_IFF_CLAT46)) ||\n\t\t    (inp && inp_restricted_send(inp, ia6->ia_ifa.ifa_ifp))) {\n\t\t\tIFA_UNLOCK(&ia6->ia_ifa);\n\t\t\tIFA_REMREF(&ia6->ia_ifa);\n\t\t\t*errorp = EHOSTUNREACH;\n\t\t\tsrc_storage = NULL;\n\t\t\tgoto done;\n\t\t}\n\n\t\t*src_storage = satosin6(&ia6->ia_addr)->sin6_addr;\n\t\tIFA_UNLOCK(&ia6->ia_ifa);\n\t\tIFA_REMREF(&ia6->ia_ifa);\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Otherwise, if the socket has already bound the source, just use it.\n\t */\n\tif (inp != NULL && !IN6_IS_ADDR_UNSPECIFIED(&inp->in6p_laddr)) {\n\t\tsrc_storage = &inp->in6p_laddr;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * If the address is not specified, choose the best one based on\n\t * the outgoing interface and the destination address.\n\t */\n\t/* get the outgoing interface */\n\tif ((*errorp = in6_selectif(dstsock, opts, mopts, ro, &ip6oa,\n\t    &ifp)) != 0) {\n\t\tsrc_storage = NULL;\n\t\tgoto done;\n\t}\n\n\tVERIFY(ifp != NULL);\n\n\tif (opts == NULL ||\n\t    opts->ip6po_prefer_tempaddr == IP6PO_TEMPADDR_SYSTEM) {\n\t\tprefer_tempaddr = ip6_prefer_tempaddr;\n\t} else if (opts->ip6po_prefer_tempaddr == IP6PO_TEMPADDR_NOTPREFER) {\n\t\tprefer_tempaddr = 0;\n\t} else\n\t\tprefer_tempaddr = 1;\n\n\tif (prefer_tempaddr)\n\t\thint_mask |= IPV6_SRCSEL_HINT_PREFER_TMPADDR;\n\n\tif (in6_selectsrc_core(dstsock, hint_mask, ifp, inp_debug, src_storage,\n\t    &sifp, errorp, NULL) == NULL) {\n\t\tsrc_storage = NULL;\n\t\tgoto done;\n\t}\n\n\tVERIFY(sifp != NULL);\n\n\tif (inp && inp_restricted_send(inp, sifp)) {\n\t\tsrc_storage = NULL;\n\t\t*errorp = EHOSTUNREACH;\n\t\tifnet_release(sifp);\n\t\tgoto done;\n\t} else {\n\t\tifnet_release(sifp);\n\t}\n\ndone:\n\tif (ifpp != NULL) {\n\t\t/* if ifp is non-NULL, refcnt held in in6_selectif() */\n\t\t*ifpp = ifp;\n\t} else if (ifp != NULL) {\n\t\tifnet_release(ifp);\n\t}\n\treturn (src_storage);\n}", "path": "darwin-xnu/bsd/netinet6/in6_src.c", "commit_date": "2018-12-10 00:00:00", "repo_name": "apple/darwin-xnu", "stars": 10860, "license": "other", "language": "c", "size": 81924}
{"docstring": "/**\n ** bond_globals\n **/\n", "func_signal": "static bond_globals_ref\nbond_globals_create(lacp_system_priority sys_pri,\n\t\t    lacp_system_ref sys)", "code": "{\n    bond_globals_ref\tb;\n\n    b = _MALLOC(sizeof(*b), M_BOND, M_WAITOK | M_ZERO);\n    if (b == NULL) {\n\treturn (NULL);\n    }\n    TAILQ_INIT(&b->ifbond_list);\n    b->system = *sys;\n    b->system_priority = sys_pri;\n    return (b);\n}", "path": "darwin-xnu/bsd/net/if_bond.c", "commit_date": "2018-12-10 00:00:00", "repo_name": "apple/darwin-xnu", "stars": 10860, "license": "other", "language": "c", "size": 81924}
{"docstring": "/**\n ** Periodic Transmission machine\n **/\n", "func_signal": "static void\nbondport_periodic_transmit_machine(bondport_ref p, LAEvent event,\n\t\t\t\t   __unused void * event_data)", "code": "{\n    int\t\t\tinterval;\n    partner_state_ref\tps;\n    struct timeval\ttv;\n\n    switch (event) {\n    case LAEventStart:\n\tif (g_bond->verbose) {\n\t    timestamp_printf(\"[%s] periodic_transmit Start\\n\",\n\t\t\t     bondport_get_name(p));\n\t}\n\t/* FALL THROUGH */\n    case LAEventMediaChange:\n\tdevtimer_cancel(p->po_periodic_timer);\n\tp->po_periodic_interval = 0;\n\tif (media_active(&p->po_media_info) == 0\n\t    || media_full_duplex(&p->po_media_info) == 0) {\n\t    break;\n\t}\n    case LAEventPacket:\n\t/* Neither Partner nor Actor are LACP Active, no periodic tx */\n\tps = &p->po_partner_state;\n\tif (lacp_actor_partner_state_active_lacp(p->po_actor_state) == 0\n\t    && (lacp_actor_partner_state_active_lacp(ps->ps_state) \n\t\t== 0)) {\n\t    devtimer_cancel(p->po_periodic_timer);\n\t    p->po_periodic_interval = 0;\n\t    break;\n\t}\n\tif (lacp_actor_partner_state_short_timeout(ps->ps_state)) {\n\t    interval = LACP_FAST_PERIODIC_TIME;\n\t}\n\telse {\n\t    interval = LACP_SLOW_PERIODIC_TIME;\n\t}\n\tif (p->po_periodic_interval != interval) {\n\t    if (interval == LACP_FAST_PERIODIC_TIME\n\t\t&& p->po_periodic_interval == LACP_SLOW_PERIODIC_TIME) {\n\t\tif (g_bond->verbose) {\n\t\t    timestamp_printf(\"[%s] periodic_transmit:\"\n\t\t\t\t     \" Need To Transmit\\n\",\n\t\t\t\t     bondport_get_name(p));\n\t\t}\n\t\tbondport_flags_set_ntt(p);\n\t    }\n\t    p->po_periodic_interval = interval;\n\t    tv.tv_usec = 0;\n\t    tv.tv_sec = interval;\n\t    devtimer_set_relative(p->po_periodic_timer, tv, \n\t\t\t\t  (devtimer_timeout_func)\n\t\t\t\t  bondport_periodic_transmit_machine,\n\t\t\t\t  (void *)LAEventTimeout, NULL);\n\t    if (g_bond->verbose) {\n\t\ttimestamp_printf(\"[%s] Periodic Transmission Timer: %d secs\\n\",\n\t\t\t\t bondport_get_name(p), \n\t\t\t\t p->po_periodic_interval);\n\t    }\n\t}\n\tbreak;\n    case LAEventTimeout:\n\tbondport_flags_set_ntt(p);\n\ttv.tv_sec = p->po_periodic_interval;\n\ttv.tv_usec = 0;\n\tdevtimer_set_relative(p->po_periodic_timer, tv, (devtimer_timeout_func)\n\t\t\t      bondport_periodic_transmit_machine,\n\t\t\t      (void *)LAEventTimeout, NULL);\n\tif (g_bond->verbose > 1) {\n\t    timestamp_printf(\"[%s] Periodic Transmission Timer: %d secs\\n\",\n\t\t\t     bondport_get_name(p), p->po_periodic_interval);\n\t}\n\tbreak;\n    default:\n\tbreak;\n    }\n    return;\n}", "path": "darwin-xnu/bsd/net/if_bond.c", "commit_date": "2018-12-10 00:00:00", "repo_name": "apple/darwin-xnu", "stars": 10860, "license": "other", "language": "c", "size": 81924}
{"docstring": "/*\n * XXX: this is borrowed from in6_pcbbind(). If possible, we should\n * share this function by all *bsd*...\n */\n", "func_signal": "int\nin6_pcbsetport(struct in6_addr *laddr, struct inpcb *inp, struct proc *p,\n    int locked)", "code": "{\n\tstruct socket *so = inp->inp_socket;\n\tu_int16_t lport = 0, first, last, *lastport;\n\tint count, error = 0, wild = 0;\n\tboolean_t counting_down;\n\tbool found;\n\tstruct inpcbinfo *pcbinfo = inp->inp_pcbinfo;\n\tkauth_cred_t cred;\n#pragma unused(laddr)\n\tif (!locked) { /* Make sure we don't run into a deadlock: 4052373 */\n\t\tif (!lck_rw_try_lock_exclusive(pcbinfo->ipi_lock)) {\n\t\t\tsocket_unlock(inp->inp_socket, 0);\n\t\t\tlck_rw_lock_exclusive(pcbinfo->ipi_lock);\n\t\t\tsocket_lock(inp->inp_socket, 0);\n\t\t}\n\n\t\t/*\n\t\t * Check if a local port was assigned to the inp while\n\t\t * this thread was waiting for the pcbinfo lock\n\t\t */\n\t\tif (inp->inp_lport != 0) {\n\t\t\tVERIFY(inp->inp_flags2 & INP2_INHASHLIST);\n\t\t\tlck_rw_done(pcbinfo->ipi_lock);\n\n\t\t\t/*\n\t\t\t * It is not an error if another thread allocated\n\t\t\t * a port\n\t\t\t */\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/* XXX: this is redundant when called from in6_pcbbind */\n\tif ((so->so_options & (SO_REUSEADDR|SO_REUSEPORT)) == 0)\n\t\twild = INPLOOKUP_WILDCARD;\n\n\tif (inp->inp_flags & INP_HIGHPORT) {\n\t\tfirst = ipport_hifirstauto;\t/* sysctl */\n\t\tlast  = ipport_hilastauto;\n\t\tlastport = &pcbinfo->ipi_lasthi;\n\t} else if (inp->inp_flags & INP_LOWPORT) {\n\t\tcred = kauth_cred_proc_ref(p);\n\t\terror = priv_check_cred(cred, PRIV_NETINET_RESERVEDPORT, 0);\n\t\tkauth_cred_unref(&cred);\n\t\tif (error != 0) {\n\t\t\tif (!locked)\n\t\t\t\tlck_rw_done(pcbinfo->ipi_lock);\n\t\t\treturn (error);\n\t\t}\n\t\tfirst = ipport_lowfirstauto;\t/* 1023 */\n\t\tlast  = ipport_lowlastauto;\t/* 600 */\n\t\tlastport = &pcbinfo->ipi_lastlow;\n\t} else {\n\t\tfirst = ipport_firstauto;\t/* sysctl */\n\t\tlast  = ipport_lastauto;\n\t\tlastport = &pcbinfo->ipi_lastport;\n\t}\n\t/*\n\t * Simple check to ensure all ports are not used up causing\n\t * a deadlock here.\n\t */\n\tfound = false;\n\tif (first > last) {\n\t\t/* counting down */\n\t\tcount = first - last;\n\t\tcounting_down = TRUE;\n\t} else {\n\t\t/* counting up */\n\t\tcount = last - first;\n\t\tcounting_down = FALSE;\n\t}\n\tdo {\n\t\tif (count-- < 0) {\t/* completely used? */\n\t\t\t/*\n\t\t\t * Undo any address bind that may have\n\t\t\t * occurred above.\n\t\t\t */\n\t\t\tinp->in6p_laddr = in6addr_any;\n\t\t\tinp->in6p_last_outifp = NULL;\n\t\t\tif (!locked)\n\t\t\t\tlck_rw_done(pcbinfo->ipi_lock);\n\t\t\treturn (EAGAIN);\n\t\t}\n\t\tif (counting_down) {\n\t\t\t--*lastport;\n\t\t\tif (*lastport > first || *lastport < last) {\n\t\t\t\t*lastport = first;\n\t\t\t}\n\t\t} else {\n\t\t\t++*lastport;\n\t\t\tif (*lastport < first || *lastport > last)\n\t\t\t\t*lastport = first;\n\t\t}\n\t\tlport = htons(*lastport);\n\t\tfound = (in6_pcblookup_local(pcbinfo, &inp->in6p_laddr,\n\t\t\t\t\t     lport, wild) == NULL);\n\t} while (!found);\n\n\tinp->inp_lport = lport;\n\tinp->inp_flags |= INP_ANONPORT;\n\n\tif (in_pcbinshash(inp, 1) != 0) {\n\t\tinp->in6p_laddr = in6addr_any;\n\t\tinp->in6p_last_outifp = NULL;\n\n\t\tinp->inp_lport = 0;\n\t\tinp->inp_flags &= ~INP_ANONPORT;\n\t\tif (!locked)\n\t\t\tlck_rw_done(pcbinfo->ipi_lock);\n\t\treturn (EAGAIN);\n\t}\n\n\tif (!locked)\n\t\tlck_rw_done(pcbinfo->ipi_lock);\n\treturn (0);\n}", "path": "darwin-xnu/bsd/netinet6/in6_src.c", "commit_date": "2018-12-10 00:00:00", "repo_name": "apple/darwin-xnu", "stars": 10860, "license": "other", "language": "c", "size": 81924}
{"docstring": "/*\n * Regardless of error, it will return an ifp with a reference held if the\n * caller provides a non-NULL retifp.  The caller is responsible for checking\n * if the returned ifp is valid and release its reference at all times.\n *\n * clone - meaningful only for bsdi and freebsd\n */\n", "func_signal": "int\nin6_selectroute(struct sockaddr_in6 *srcsock, struct sockaddr_in6 *dstsock,\n    struct ip6_pktopts *opts, struct ip6_moptions *mopts,\n    struct in6_ifaddr **retsrcia, struct route_in6 *ro, struct ifnet **retifp,\n    struct rtentry **retrt, int clone, struct ip6_out_args *ip6oa)", "code": "{\n\n\treturn (selectroute(srcsock, dstsock, opts, mopts, retsrcia, ro, retifp,\n\t    retrt, clone, 0, ip6oa));\n}", "path": "darwin-xnu/bsd/netinet6/in6_src.c", "commit_date": "2018-12-10 00:00:00", "repo_name": "apple/darwin-xnu", "stars": 10860, "license": "other", "language": "c", "size": 81924}
{"docstring": "/*\n * Function: ifbond_signal\n * Purpose:\n *   Allows the thread that previously invoked ifbond_wait() to \n *   give up exclusive access to the ifbond data structure, and wake up\n *   any other threads waiting to access\n * Notes:\n *   Before calling, you must be holding the bond_lock and have taken\n *   a reference on the ifbond_ref.\n */\n", "func_signal": "static void\nifbond_signal(ifbond_ref ifb, const char * msg)", "code": "{\n    ifbond_flags_clear_change_in_progress(ifb);\n    wakeup((caddr_t)ifb);\n    if (g_bond->verbose) {\n\tprintf(\"%s: %s wakeup\\n\", ifb->ifb_name, msg);\n    }\n    return;\n}", "path": "darwin-xnu/bsd/net/if_bond.c", "commit_date": "2018-12-10 00:00:00", "repo_name": "apple/darwin-xnu", "stars": 10860, "license": "other", "language": "c", "size": 81924}
{"docstring": "/* ENABLE_ADDRSEL */\n", "func_signal": "int\nwalk_addrsel_policy(int (*callback)(const struct in6_addrpolicy *, void *),\n    void *w)", "code": "{\n\tstruct addrsel_policyent *pol;\n\tint error = 0;\n\n\tADDRSEL_LOCK();\n\tTAILQ_FOREACH(pol, &addrsel_policytab, ape_entry) {\n\t\tif ((error = (*callback)(&pol->ape_policy, w)) != 0) {\n\t\t\tADDRSEL_UNLOCK();\n\t\t\treturn (error);\n\t\t}\n\t}\n\tADDRSEL_UNLOCK();\n\treturn (error);\n}", "path": "darwin-xnu/bsd/netinet6/in6_src.c", "commit_date": "2018-12-10 00:00:00", "repo_name": "apple/darwin-xnu", "stars": 10860, "license": "other", "language": "c", "size": 81924}
{"docstring": "/**\n ** Media information\n **/\n", "func_signal": "static int\nlink_speed(int active)", "code": "{\n    switch (IFM_SUBTYPE(active)) {\n    case IFM_10_T:\n    case IFM_10_2:\n    case IFM_10_5:\n    case IFM_10_STP:\n    case IFM_10_FL:\n\treturn (10);\n    case IFM_100_TX:\n    case IFM_100_FX:\n    case IFM_100_T4:\n    case IFM_100_VG:\n    case IFM_100_T2:\n\treturn (100);\n    case IFM_1000_SX:\n    case IFM_1000_LX:\n    case IFM_1000_CX:\n    case IFM_1000_TX:\n\treturn (1000);\n    case IFM_HPNA_1:\n\treturn (0);\n    default:\n\t/* assume that new defined types are going to be at least 10GigE */\n    case IFM_10G_SR:\n    case IFM_10G_LR:\n\treturn (10000);\n    case IFM_2500_T:\n\treturn (2500);\n    case IFM_5000_T:\n\treturn (5000);\n    }\n}", "path": "darwin-xnu/bsd/net/if_bond.c", "commit_date": "2018-12-10 00:00:00", "repo_name": "apple/darwin-xnu", "stars": 10860, "license": "other", "language": "c", "size": 81924}
{"docstring": "/*\n * Function: bondport_cancel_timers\n * Purpose:\n *   Cancel all of the timers for the bondport.\n */\n", "func_signal": "static void\nbondport_cancel_timers(bondport_ref p)", "code": "{\n    devtimer_cancel(p->po_current_while_timer);\n    devtimer_cancel(p->po_periodic_timer);\n    devtimer_cancel(p->po_wait_while_timer);\n    devtimer_cancel(p->po_transmit_timer);\n}", "path": "darwin-xnu/bsd/net/if_bond.c", "commit_date": "2018-12-10 00:00:00", "repo_name": "apple/darwin-xnu", "stars": 10860, "license": "other", "language": "c", "size": 81924}
{"docstring": "/*\n * Regardless of error, it will return an ifp with a reference held if the\n * caller provides a non-NULL retifp.  The caller is responsible for checking\n * if the returned ifp is valid and release its reference at all times.\n */\n", "func_signal": "int\nin6_selectif(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,\n    struct ip6_moptions *mopts, struct route_in6 *ro,\n    struct ip6_out_args *ip6oa, struct ifnet **retifp)", "code": "{\n\tint err = 0;\n\tstruct route_in6 sro;\n\tstruct rtentry *rt = NULL;\n\n\tif (ro == NULL) {\n\t\tbzero(&sro, sizeof (sro));\n\t\tro = &sro;\n\t}\n\n\tif ((err = selectroute(NULL, dstsock, opts, mopts, NULL, ro, retifp,\n\t    &rt, 0, 1, ip6oa)) != 0)\n\t\tgoto done;\n\n\t/*\n\t * do not use a rejected or black hole route.\n\t * XXX: this check should be done in the L2 output routine.\n\t * However, if we skipped this check here, we'd see the following\n\t * scenario:\n\t * - install a rejected route for a scoped address prefix\n\t *   (like fe80::/10)\n\t * - send a packet to a destination that matches the scoped prefix,\n\t *   with ambiguity about the scope zone.\n\t * - pick the outgoing interface from the route, and disambiguate the\n\t *   scope zone with the interface.\n\t * - ip6_output() would try to get another route with the \"new\"\n\t *   destination, which may be valid.\n\t * - we'd see no error on output.\n\t * Although this may not be very harmful, it should still be confusing.\n\t * We thus reject the case here.\n\t */\n\tif (rt && (rt->rt_flags & (RTF_REJECT | RTF_BLACKHOLE))) {\n\t\terr = ((rt->rt_flags & RTF_HOST) ? EHOSTUNREACH : ENETUNREACH);\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Adjust the \"outgoing\" interface.  If we're going to loop the packet\n\t * back to ourselves, the ifp would be the loopback interface.\n\t * However, we'd rather know the interface associated to the\n\t * destination address (which should probably be one of our own\n\t * addresses.)\n\t */\n\tif (rt != NULL && rt->rt_ifa != NULL && rt->rt_ifa->ifa_ifp != NULL &&\n\t    retifp != NULL) {\n\t\tifnet_reference(rt->rt_ifa->ifa_ifp);\n\t\tif (*retifp != NULL)\n\t\t\tifnet_release(*retifp);\n\t\t*retifp = rt->rt_ifa->ifa_ifp;\n\t}\n\ndone:\n\tif (ro == &sro) {\n\t\tVERIFY(rt == NULL || rt == ro->ro_rt);\n\t\tROUTE_RELEASE(ro);\n\t}\n\n\t/*\n\t * retifp might point to a valid ifp with a reference held;\n\t * caller is responsible for releasing it if non-NULL.\n\t */\n\treturn (err);\n}", "path": "darwin-xnu/bsd/netinet6/in6_src.c", "commit_date": "2018-12-10 00:00:00", "repo_name": "apple/darwin-xnu", "stars": 10860, "license": "other", "language": "c", "size": 81924}
{"docstring": "/*\n * Function: bond_detach_protocol\n * Purpose:\n *   Detach our DLIL protocol from an interface\n */\n", "func_signal": "static int\nbond_detach_protocol(struct ifnet *ifp)", "code": "{\n    int         error;\n\n    error = ifnet_detach_protocol(ifp, PF_BOND);\n    if (error) {\n\tprintf(\"bond over %s%d: ifnet_detach_protocol failed, %d\\n\",\n\t       ifnet_name(ifp), ifnet_unit(ifp), error);\n    }\n    return (error);\n}", "path": "darwin-xnu/bsd/net/if_bond.c", "commit_date": "2018-12-10 00:00:00", "repo_name": "apple/darwin-xnu", "stars": 10860, "license": "other", "language": "c", "size": 81924}
{"docstring": "/*\n * Function: bond_setmulti\n * Purpose:\n *   Enable multicast reception on \"our\" interface by enabling multicasts on\n *   each of the member ports.\n */\n", "func_signal": "static int\nbond_setmulti(struct ifnet * ifp)", "code": "{\n    ifbond_ref\t\tifb;\n    int\t\t\terror;\n    int\t\t\tresult = 0;\n    bondport_ref\tp;\n\n    bond_lock();\n    ifb = ifnet_softc(ifp);\n    if (ifb == NULL || ifbond_flags_if_detaching(ifb) \n\t|| TAILQ_EMPTY(&ifb->ifb_port_list)) {\n\tbond_unlock();\n\treturn (0);\n    }\n    ifbond_retain(ifb);\n    ifbond_wait(ifb, \"bond_setmulti\");\n\n    if (ifbond_flags_if_detaching(ifb)) {\n\t/* someone destroyed the bond while we were waiting */\n\tresult = EBUSY;\n\tgoto signal_done;\n    }\n    bond_unlock();\n\n    /* ifbond_wait() let's us safely walk the list without holding the lock */\n    TAILQ_FOREACH(p, &ifb->ifb_port_list, po_port_list) {\n\tstruct ifnet *\tport_ifp = p->po_ifp;\n\n\terror = multicast_list_program(&p->po_multicast,\n\t\t\t\t       ifp, port_ifp);\n\tif (error != 0) {\n\t    printf(\"bond_setmulti(%s): \"\n\t\t   \"multicast_list_program(%s%d) failed, %d\\n\",\n\t\t   ifb->ifb_name, ifnet_name(port_ifp),\n\t\t   ifnet_unit(port_ifp), error);\n\t    result = error;\n\t}\n    }\n    bond_lock();\n signal_done:\n    ifbond_signal(ifb, \"bond_setmulti\");\n    bond_unlock();\n    ifbond_release(ifb);\n    return (result);\n}", "path": "darwin-xnu/bsd/net/if_bond.c", "commit_date": "2018-12-10 00:00:00", "repo_name": "apple/darwin-xnu", "stars": 10860, "license": "other", "language": "c", "size": 81924}
{"docstring": "/**\n ** LACP ifbond, LAG routines\n **/\n", "func_signal": "static int\nifbond_selection(ifbond_ref bond)", "code": "{\n    int\t\t\tall_ports_ready = 0;\n    int\t\t\tactive_media = 0;\n    LAG_ref\t\tlag = NULL;\n    int\t\t\tlag_changed = 0;\n    bondport_ref\tp;\n    int\t\t\tport_speed = 0;\n    \n    lag = ifbond_find_best_LAG(bond, &active_media);\n    if (lag != bond->ifb_active_lag) {\n\tif (bond->ifb_active_lag != NULL) {\n\t    ifbond_deactivate_LAG(bond, bond->ifb_active_lag);\n\t    bond->ifb_active_lag = NULL;\n\t}\n\tbond->ifb_active_lag = lag;\n\tif (lag != NULL) {\n\t    ifbond_activate_LAG(bond, lag, active_media);\n\t}\n\tlag_changed = 1;\n    }\n    else if (lag != NULL) {\n\tif (lag->lag_active_media != active_media) {\n\t    if (g_bond->verbose) {\n\t\ttimestamp_printf(\"LAG PORT SPEED CHANGED from %d to %d\\n\",\n\t\t\t\t link_speed(lag->lag_active_media), \n\t\t\t\t link_speed(active_media));\n\t    }\n\t    ifbond_deactivate_LAG(bond, lag);\n\t    ifbond_activate_LAG(bond, lag, active_media);\n\t    lag_changed = 1;\n\t}\n    }\n    if (lag != NULL) {\n\tport_speed = link_speed(active_media);\n\tall_ports_ready = ifbond_all_ports_ready(bond);\n    }\n    TAILQ_FOREACH(p, &bond->ifb_port_list, po_port_list) {\n\tif (lag != NULL && p->po_lag == lag\n\t    && media_speed(&p->po_media_info) == port_speed\n\t    && (p->po_mux_state == MuxState_DETACHED\n\t\t|| p->po_selected == SelectedState_SELECTED\n\t\t|| p->po_selected == SelectedState_STANDBY)\n\t    && bondport_aggregatable(p)) {\n\t    if (bond->ifb_max_active > 0) {\n\t\tif (lag->lag_selected_port_count < bond->ifb_max_active) {\n\t\t    if (p->po_selected == SelectedState_STANDBY\n\t\t\t|| p->po_selected == SelectedState_UNSELECTED) {\n\t\t\tbondport_set_selected(p, SelectedState_SELECTED);\n\t\t    }\n\t\t}\n\t\telse if (p->po_selected == SelectedState_UNSELECTED) {\n\t\t    bondport_set_selected(p, SelectedState_STANDBY);\n\t\t}\n\t    }\n\t    else {\n\t\tbondport_set_selected(p, SelectedState_SELECTED);\n\t    }\n\t}\n\tif (bondport_flags_selected_changed(p)) {\n\t    bondport_flags_clear_selected_changed(p);\n\t    bondport_mux_machine(p, LAEventSelectedChange, NULL);\n\t}\n\tif (all_ports_ready\n\t    && bondport_flags_ready(p)\n\t    && p->po_mux_state == MuxState_WAITING) {\n\t    bondport_mux_machine(p, LAEventReady, NULL);\n\t}\n\tbondport_transmit_machine(p, LAEventStart, NULL);\n    }\n    return (lag_changed);\n}", "path": "darwin-xnu/bsd/net/if_bond.c", "commit_date": "2018-12-10 00:00:00", "repo_name": "apple/darwin-xnu", "stars": 10860, "license": "other", "language": "c", "size": 81924}
{"docstring": "// accelerated huffman table allows fast O(1) match of all symbols\n// of length <= STB_VORBIS_FAST_HUFFMAN_LENGTH\n", "func_signal": "static void compute_accelerated_huffman(Codebook *c)", "code": "{\n   int i, len;\n   for (i=0; i < FAST_HUFFMAN_TABLE_SIZE; ++i)\n      c->fast_huffman[i] = -1;\n\n   len = c->sparse ? c->sorted_entries : c->entries;\n   #ifdef STB_VORBIS_FAST_HUFFMAN_SHORT\n   if (len > 32767) len = 32767; // largest possible value we can encode!\n   #endif\n   for (i=0; i < len; ++i) {\n      if (c->codeword_lengths[i] <= STB_VORBIS_FAST_HUFFMAN_LENGTH) {\n         uint32 z = c->sparse ? bit_reverse(c->sorted_codewords[i]) : c->codewords[i];\n         // set table entries for all bit combinations in the higher bits\n         while (z < FAST_HUFFMAN_TABLE_SIZE) {\n             c->fast_huffman[z] = i;\n             z += 1 << c->codeword_lengths[i];\n         }\n      }\n   }\n}", "path": "stb/stb_vorbis.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "nothings/stb", "stars": 24651, "license": "other", "language": "c", "size": 5702}
{"docstring": "// slow way for debugging\n", "func_signal": "void inverse_mdct_slow(float *buffer, int n)", "code": "{\n   int i,j;\n   int n2 = n >> 1;\n   float *x = (float *) malloc(sizeof(*x) * n2);\n   memcpy(x, buffer, sizeof(*x) * n2);\n   for (i=0; i < n; ++i) {\n      float acc = 0;\n      for (j=0; j < n2; ++j)\n         // formula from paper:\n         //acc += n/4.0f * x[j] * (float) cos(M_PI / 2 / n * (2 * i + 1 + n/2.0)*(2*j+1));\n         // formula from wikipedia\n         //acc += 2.0f / n2 * x[j] * (float) cos(M_PI/n2 * (i + 0.5 + n2/2)*(j + 0.5));\n         // these are equivalent, except the formula from the paper inverts the multiplier!\n         // however, what actually works is NO MULTIPLIER!?!\n         //acc += 64 * 2.0f / n2 * x[j] * (float) cos(M_PI/n2 * (i + 0.5 + n2/2)*(j + 0.5));\n         acc += x[j] * (float) cos(M_PI / 2 / n * (2 * i + 1 + n/2.0)*(2*j+1));\n      buffer[i] = acc;\n   }\n   free(x);\n}", "path": "stb/stb_vorbis.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "nothings/stb", "stars": 24651, "license": "other", "language": "c", "size": 5702}
{"docstring": "// https://fgiesen.wordpress.com/2012/08/31/frustum-planes-from-the-projection-matrix/\n", "func_signal": "static void compute_frustum(void)", "code": "{\n   int i;\n   GLdouble mv[4][4],proj[4][4], mvproj[4][4];\n   glGetDoublev(GL_MODELVIEW_MATRIX , mv[0]);\n   glGetDoublev(GL_PROJECTION_MATRIX, proj[0]);\n   matd_mul(mvproj, proj, mv);\n   for (i=0; i < 4; ++i) {\n      (&frustum[0].x)[i] = (float) (mvproj[3][i] + mvproj[0][i]);\n      (&frustum[1].x)[i] = (float) (mvproj[3][i] - mvproj[0][i]);\n      (&frustum[2].x)[i] = (float) (mvproj[3][i] + mvproj[1][i]);\n      (&frustum[3].x)[i] = (float) (mvproj[3][i] - mvproj[1][i]);\n      (&frustum[4].x)[i] = (float) (mvproj[3][i] + mvproj[2][i]);\n      (&frustum[5].x)[i] = (float) (mvproj[3][i] - mvproj[2][i]);\n   }   \n}", "path": "stb/tests/caveview/cave_render.c", "commit_date": "2016-09-30 00:00:00", "repo_name": "nothings/stb", "stars": 24651, "license": "other", "language": "c", "size": 5702}
{"docstring": "//\n// DATA-PULLING API\n//\n", "func_signal": "static uint32 vorbis_find_page(stb_vorbis *f, uint32 *end, uint32 *last)", "code": "{\n   for(;;) {\n      int n;\n      if (f->eof) return 0;\n      n = get8(f);\n      if (n == 0x4f) { // page header candidate\n         unsigned int retry_loc = stb_vorbis_get_file_offset(f);\n         int i;\n         // check if we're off the end of a file_section stream\n         if (retry_loc - 25 > f->stream_len)\n            return 0;\n         // check the rest of the header\n         for (i=1; i < 4; ++i)\n            if (get8(f) != ogg_page_header[i])\n               break;\n         if (f->eof) return 0;\n         if (i == 4) {\n            uint8 header[27];\n            uint32 i, crc, goal, len;\n            for (i=0; i < 4; ++i)\n               header[i] = ogg_page_header[i];\n            for (; i < 27; ++i)\n               header[i] = get8(f);\n            if (f->eof) return 0;\n            if (header[4] != 0) goto invalid;\n            goal = header[22] + (header[23] << 8) + (header[24]<<16) + (header[25]<<24);\n            for (i=22; i < 26; ++i)\n               header[i] = 0;\n            crc = 0;\n            for (i=0; i < 27; ++i)\n               crc = crc32_update(crc, header[i]);\n            len = 0;\n            for (i=0; i < header[26]; ++i) {\n               int s = get8(f);\n               crc = crc32_update(crc, s);\n               len += s;\n            }\n            if (len && f->eof) return 0;\n            for (i=0; i < len; ++i)\n               crc = crc32_update(crc, get8(f));\n            // finished parsing probable page\n            if (crc == goal) {\n               // we could now check that it's either got the last\n               // page flag set, OR it's followed by the capture\n               // pattern, but I guess TECHNICALLY you could have\n               // a file with garbage between each ogg page and recover\n               // from it automatically? So even though that paranoia\n               // might decrease the chance of an invalid decode by\n               // another 2^32, not worth it since it would hose those\n               // invalid-but-useful files?\n               if (end)\n                  *end = stb_vorbis_get_file_offset(f);\n               if (last) {\n                  if (header[5] & 0x04)\n                     *last = 1;\n                  else\n                     *last = 0;\n               }\n               set_file_offset(f, retry_loc-1);\n               return 1;\n            }\n         }\n        invalid:\n         // not a valid page, so rewind and look for next one\n         set_file_offset(f, retry_loc);\n      }\n   }\n}", "path": "stb/stb_vorbis.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "nothings/stb", "stars": 24651, "license": "other", "language": "c", "size": 5702}
{"docstring": "// this is a weird definition of log2() for which log2(1) = 1, log2(2) = 2, log2(4) = 3\n// as required by the specification. fast(?) implementation from stb.h\n// @OPTIMIZE: called multiple times per-packet with \"constants\"; move to setup\n", "func_signal": "static int ilog(int32 n)", "code": "{\n   static signed char log2_4[16] = { 0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4 };\n\n   if (n < 0) return 0; // signed n returns 0\n\n   // 2 compares if n < 16, 3 compares otherwise (4 if signed or n > 1<<29)\n   if (n < (1 << 14))\n        if (n < (1 <<  4))            return  0 + log2_4[n      ];\n        else if (n < (1 <<  9))       return  5 + log2_4[n >>  5];\n             else                     return 10 + log2_4[n >> 10];\n   else if (n < (1 << 24))\n             if (n < (1 << 19))       return 15 + log2_4[n >> 15];\n             else                     return 20 + log2_4[n >> 20];\n        else if (n < (1 << 29))       return 25 + log2_4[n >> 25];\n             else                     return 30 + log2_4[n >> 30];\n}", "path": "stb/stb_vorbis.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "nothings/stb", "stars": 24651, "license": "other", "language": "c", "size": 5702}
{"docstring": "// only run while parsing the header (3 times)\n", "func_signal": "static int vorbis_validate(uint8 *data)", "code": "{\n   static uint8 vorbis[6] = { 'v', 'o', 'r', 'b', 'i', 's' };\n   return memcmp(data, vorbis, 6) == 0;\n}", "path": "stb/stb_vorbis.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "nothings/stb", "stars": 24651, "license": "other", "language": "c", "size": 5702}
{"docstring": "// @OPTIMIZE: primary accumulator for huffman\n// expand the buffer to as many bits as possible without reading off end of packet\n// it might be nice to allow f->valid_bits and f->acc to be stored in registers,\n// e.g. cache them locally and decode locally\n", "func_signal": "static __forceinline void prep_huffman(vorb *f)", "code": "{\n   if (f->valid_bits <= 24) {\n      if (f->valid_bits == 0) f->acc = 0;\n      do {\n         int z;\n         if (f->last_seg && !f->bytes_in_seg) return;\n         z = get8_packet_raw(f);\n         if (z == EOP) return;\n         f->acc += (unsigned) z << f->valid_bits;\n         f->valid_bits += 8;\n      } while (f->valid_bits <= 24);\n   }\n}", "path": "stb/stb_vorbis.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "nothings/stb", "stars": 24651, "license": "other", "language": "c", "size": 5702}
{"docstring": "// rarely used function to seek back to the preceding page while finding the\n// start of a packet\n", "func_signal": "static int go_to_page_before(stb_vorbis *f, unsigned int limit_offset)", "code": "{\n   unsigned int previous_safe, end;\n\n   // now we want to seek back 64K from the limit\n   if (limit_offset >= 65536 && limit_offset-65536 >= f->first_audio_page_offset)\n      previous_safe = limit_offset - 65536;\n   else\n      previous_safe = f->first_audio_page_offset;\n\n   set_file_offset(f, previous_safe);\n\n   while (vorbis_find_page(f, &end, NULL)) {\n      if (end >= limit_offset && stb_vorbis_get_file_offset(f) < limit_offset)\n         return 1;\n      set_file_offset(f, end);\n   }\n\n   return 0;\n}", "path": "stb/stb_vorbis.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "nothings/stb", "stars": 24651, "license": "other", "language": "c", "size": 5702}
{"docstring": "// @OPTIMIZE: this is the secondary bit decoder, so it's probably not as important\n// as the huffman decoder?\n", "func_signal": "static uint32 get_bits(vorb *f, int n)", "code": "{\n   uint32 z;\n\n   if (f->valid_bits < 0) return 0;\n   if (f->valid_bits < n) {\n      if (n > 24) {\n         // the accumulator technique below would not work correctly in this case\n         z = get_bits(f, 24);\n         z += get_bits(f, n-24) << 24;\n         return z;\n      }\n      if (f->valid_bits == 0) f->acc = 0;\n      while (f->valid_bits < n) {\n         int z = get8_packet_raw(f);\n         if (z == EOP) {\n            f->valid_bits = INVALID_BITS;\n            return 0;\n         }\n         f->acc += z << f->valid_bits;\n         f->valid_bits += 8;\n      }\n   }\n\n   assert(f->valid_bits >= n);\n   z = f->acc & ((1 << n)-1);\n   f->acc >>= n;\n   f->valid_bits -= n;\n   return z;\n}", "path": "stb/stb_vorbis.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "nothings/stb", "stars": 24651, "license": "other", "language": "c", "size": 5702}
{"docstring": "// zlib & jpeg huffman tables assume that the output symbols\n// can either be arbitrarily arranged, or have monotonically\n// increasing frequencies--they rely on the lengths being sorted;\n// this makes for a very simple generation algorithm.\n// vorbis allows a huffman table with non-sorted lengths. This\n// requires a more sophisticated construction, since symbols in\n// order do not map to huffman codes \"in order\".\n", "func_signal": "static void add_entry(Codebook *c, uint32 huff_code, int symbol, int count, int len, uint32 *values)", "code": "{\n   if (!c->sparse) {\n      c->codewords      [symbol] = huff_code;\n   } else {\n      c->codewords       [count] = huff_code;\n      c->codeword_lengths[count] = len;\n      values             [count] = symbol;\n   }\n}", "path": "stb/stb_vorbis.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "nothings/stb", "stars": 24651, "license": "other", "language": "c", "size": 5702}
{"docstring": "// seeking is implemented with a binary search, which narrows down the range to\n// 64K, before using a linear search (because finding the synchronization\n// pattern can be expensive, and the chance we'd find the end page again is\n// relatively high for small ranges)\n//\n// two initial interpolation-style probes are used at the start of the search\n// to try to bound either side of the binary search sensibly, while still\n// working in O(log n) time if they fail.\n", "func_signal": "static int get_seek_page_info(stb_vorbis *f, ProbedPage *z)", "code": "{\n   uint8 header[27], lacing[255];\n   int i,len;\n\n   // record where the page starts\n   z->page_start = stb_vorbis_get_file_offset(f);\n\n   // parse the header\n   getn(f, header, 27);\n   if (header[0] != 'O' || header[1] != 'g' || header[2] != 'g' || header[3] != 'S')\n      return 0;\n   getn(f, lacing, header[26]);\n\n   // determine the length of the payload\n   len = 0;\n   for (i=0; i < header[26]; ++i)\n      len += lacing[i];\n\n   // this implies where the page ends\n   z->page_end = z->page_start + 27 + header[26] + len;\n\n   // read the last-decoded sample out of the data\n   z->last_decoded_sample = header[6] + (header[7] << 8) + (header[8] << 16) + (header[9] << 24);\n\n   // restore file state to where we were\n   set_file_offset(f, z->page_start);\n   return 1;\n}", "path": "stb/stb_vorbis.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "nothings/stb", "stars": 24651, "license": "other", "language": "c", "size": 5702}
{"docstring": "// implements the search logic for finding a page and starting decoding. if\n// the function succeeds, current_loc_valid will be true and current_loc will\n// be less than or equal to the provided sample number (the closer the\n// better).\n", "func_signal": "static int seek_to_sample_coarse(stb_vorbis *f, uint32 sample_number)", "code": "{\n   ProbedPage left, right, mid;\n   int i, start_seg_with_known_loc, end_pos, page_start;\n   uint32 delta, stream_length, padding, last_sample_limit;\n   double offset = 0.0, bytes_per_sample = 0.0;\n   int probe = 0;\n\n   // find the last page and validate the target sample\n   stream_length = stb_vorbis_stream_length_in_samples(f);\n   if (stream_length == 0)            return error(f, VORBIS_seek_without_length);\n   if (sample_number > stream_length) return error(f, VORBIS_seek_invalid);\n\n   // this is the maximum difference between the window-center (which is the\n   // actual granule position value), and the right-start (which the spec\n   // indicates should be the granule position (give or take one)).\n   padding = ((f->blocksize_1 - f->blocksize_0) >> 2);\n   if (sample_number < padding)\n      last_sample_limit = 0;\n   else\n      last_sample_limit = sample_number - padding;\n\n   left = f->p_first;\n   while (left.last_decoded_sample == ~0U) {\n      // (untested) the first page does not have a 'last_decoded_sample'\n      set_file_offset(f, left.page_end);\n      if (!get_seek_page_info(f, &left)) goto error;\n   }\n\n   right = f->p_last;\n   assert(right.last_decoded_sample != ~0U);\n\n   // starting from the start is handled differently\n   if (last_sample_limit <= left.last_decoded_sample) {\n      if (stb_vorbis_seek_start(f)) {\n         if (f->current_loc > sample_number)\n            return error(f, VORBIS_seek_failed);\n         return 1;\n      }\n      return 0;\n   }\n\n   while (left.page_end != right.page_start) {\n      assert(left.page_end < right.page_start);\n      // search range in bytes\n      delta = right.page_start - left.page_end;\n      if (delta <= 65536) {\n         // there's only 64K left to search - handle it linearly\n         set_file_offset(f, left.page_end);\n      } else {\n         if (probe < 2) {\n            if (probe == 0) {\n               // first probe (interpolate)\n               double data_bytes = right.page_end - left.page_start;\n               bytes_per_sample = data_bytes / right.last_decoded_sample;\n               offset = left.page_start + bytes_per_sample * (last_sample_limit - left.last_decoded_sample);\n            } else {\n               // second probe (try to bound the other side)\n               double error = ((double) last_sample_limit - mid.last_decoded_sample) * bytes_per_sample;\n               if (error >= 0 && error <  8000) error =  8000;\n               if (error <  0 && error > -8000) error = -8000;\n               offset += error * 2;\n            }\n\n            // ensure the offset is valid\n            if (offset < left.page_end)\n               offset = left.page_end;\n            if (offset > right.page_start - 65536)\n               offset = right.page_start - 65536;\n\n            set_file_offset(f, (unsigned int) offset);\n         } else {\n            // binary search for large ranges (offset by 32K to ensure\n            // we don't hit the right page)\n            set_file_offset(f, left.page_end + (delta / 2) - 32768);\n         }\n\n         if (!vorbis_find_page(f, NULL, NULL)) goto error;\n      }\n\n      for (;;) {\n         if (!get_seek_page_info(f, &mid)) goto error;\n         if (mid.last_decoded_sample != ~0U) break;\n         // (untested) no frames end on this page\n         set_file_offset(f, mid.page_end);\n         assert(mid.page_start < right.page_start);\n      }\n\n      // if we've just found the last page again then we're in a tricky file,\n      // and we're close enough (if it wasn't an interpolation probe).\n      if (mid.page_start == right.page_start) {\n         if (probe >= 2 || delta <= 65536)\n            break;\n      } else {\n         if (last_sample_limit < mid.last_decoded_sample)\n            right = mid;\n         else\n            left = mid;\n      }\n\n      ++probe;\n   }\n\n   // seek back to start of the last packet\n   page_start = left.page_start;\n   set_file_offset(f, page_start);\n   if (!start_page(f)) return error(f, VORBIS_seek_failed);\n   end_pos = f->end_seg_with_known_loc;\n   assert(end_pos >= 0);\n\n   for (;;) {\n      for (i = end_pos; i > 0; --i)\n         if (f->segments[i-1] != 255)\n            break;\n\n      start_seg_with_known_loc = i;\n\n      if (start_seg_with_known_loc > 0 || !(f->page_flag & PAGEFLAG_continued_packet))\n         break;\n\n      // (untested) the final packet begins on an earlier page\n      if (!go_to_page_before(f, page_start))\n         goto error;\n\n      page_start = stb_vorbis_get_file_offset(f);\n      if (!start_page(f)) goto error;\n      end_pos = f->segment_count - 1;\n   }\n\n   // prepare to start decoding\n   f->current_loc_valid = FALSE;\n   f->last_seg = FALSE;\n   f->valid_bits = 0;\n   f->packet_bytes = 0;\n   f->bytes_in_seg = 0;\n   f->previous_length = 0;\n   f->next_seg = start_seg_with_known_loc;\n\n   for (i = 0; i < start_seg_with_known_loc; i++)\n      skip(f, f->segments[i]);\n\n   // start decoding (optimizable - this frame is generally discarded)\n   if (!vorbis_pump_first_frame(f))\n      return 0;\n   if (f->current_loc > sample_number)\n      return error(f, VORBIS_seek_failed);\n   return 1;\n\nerror:\n   // try to restore the file to a valid state\n   stb_vorbis_seek_start(f);\n   return error(f, VORBIS_seek_failed);\n}", "path": "stb/stb_vorbis.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "nothings/stb", "stars": 24651, "license": "other", "language": "c", "size": 5702}
{"docstring": "// STB_VORBIS_NO_PUSHDATA_API\n", "func_signal": "unsigned int stb_vorbis_get_file_offset(stb_vorbis *f)", "code": "{\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (f->push_mode) return 0;\n   #endif\n   if (USE_MEMORY(f)) return (unsigned int) (f->stream - f->stream_start);\n   #ifndef STB_VORBIS_NO_STDIO\n   return (unsigned int) (ftell(f->f) - f->f_start);\n   #endif\n}", "path": "stb/stb_vorbis.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "nothings/stb", "stars": 24651, "license": "other", "language": "c", "size": 5702}
{"docstring": "// The meaning of \"left\" and \"right\"\n//\n// For a given frame:\n//     we compute samples from 0..n\n//     window_center is n/2\n//     we'll window and mix the samples from left_start to left_end with data from the previous frame\n//     all of the samples from left_end to right_start can be output without mixing; however,\n//        this interval is 0-length except when transitioning between short and long frames\n//     all of the samples from right_start to right_end need to be mixed with the next frame,\n//        which we don't have, so those get saved in a buffer\n//     frame N's right_end-right_start, the number of samples to mix with the next frame,\n//        has to be the same as frame N+1's left_end-left_start (which they are by\n//        construction)\n", "func_signal": "static int vorbis_decode_initial(vorb *f, int *p_left_start, int *p_left_end, int *p_right_start, int *p_right_end, int *mode)", "code": "{\n   Mode *m;\n   int i, n, prev, next, window_center;\n   f->channel_buffer_start = f->channel_buffer_end = 0;\n\n  retry:\n   if (f->eof) return FALSE;\n   if (!maybe_start_packet(f))\n      return FALSE;\n   // check packet type\n   if (get_bits(f,1) != 0) {\n      if (IS_PUSH_MODE(f))\n         return error(f,VORBIS_bad_packet_type);\n      while (EOP != get8_packet(f));\n      goto retry;\n   }\n\n   if (f->alloc.alloc_buffer)\n      assert(f->alloc.alloc_buffer_length_in_bytes == f->temp_offset);\n\n   i = get_bits(f, ilog(f->mode_count-1));\n   if (i == EOP) return FALSE;\n   if (i >= f->mode_count) return FALSE;\n   *mode = i;\n   m = f->mode_config + i;\n   if (m->blockflag) {\n      n = f->blocksize_1;\n      prev = get_bits(f,1);\n      next = get_bits(f,1);\n   } else {\n      prev = next = 0;\n      n = f->blocksize_0;\n   }\n\n// WINDOWING\n\n   window_center = n >> 1;\n   if (m->blockflag && !prev) {\n      *p_left_start = (n - f->blocksize_0) >> 2;\n      *p_left_end   = (n + f->blocksize_0) >> 2;\n   } else {\n      *p_left_start = 0;\n      *p_left_end   = window_center;\n   }\n   if (m->blockflag && !next) {\n      *p_right_start = (n*3 - f->blocksize_0) >> 2;\n      *p_right_end   = (n*3 + f->blocksize_0) >> 2;\n   } else {\n      *p_right_start = window_center;\n      *p_right_end   = n;\n   }\n\n   return TRUE;\n}", "path": "stb/stb_vorbis.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "nothings/stb", "stars": 24651, "license": "other", "language": "c", "size": 5702}
{"docstring": "// used in setup, and for huffman that doesn't go fast path\n", "func_signal": "static unsigned int bit_reverse(unsigned int n)", "code": "{\n  n = ((n & 0xAAAAAAAA) >>  1) | ((n & 0x55555555) << 1);\n  n = ((n & 0xCCCCCCCC) >>  2) | ((n & 0x33333333) << 2);\n  n = ((n & 0xF0F0F0F0) >>  4) | ((n & 0x0F0F0F0F) << 4);\n  n = ((n & 0xFF00FF00) >>  8) | ((n & 0x00FF00FF) << 8);\n  return (n >> 16) | (n << 16);\n}", "path": "stb/stb_vorbis.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "nothings/stb", "stars": 24651, "license": "other", "language": "c", "size": 5702}
{"docstring": "// STB_VORBIS_NO_STDIO\n", "func_signal": "stb_vorbis * stb_vorbis_open_memory(const unsigned char *data, int len, int *error, const stb_vorbis_alloc *alloc)", "code": "{\n   stb_vorbis *f, p;\n   if (data == NULL) return NULL;\n   vorbis_init(&p, alloc);\n   p.stream = (uint8 *) data;\n   p.stream_end = (uint8 *) data + len;\n   p.stream_start = (uint8 *) p.stream;\n   p.stream_len = len;\n   p.push_mode = FALSE;\n   if (start_decoder(&p)) {\n      f = vorbis_alloc(&p);\n      if (f) {\n         *f = p;\n         vorbis_pump_first_frame(f);\n         if (error) *error = VORBIS__no_error;\n         return f;\n      }\n   }\n   if (error) *error = p.error;\n   vorbis_deinit(&p);\n   return NULL;\n}", "path": "stb/stb_vorbis.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "nothings/stb", "stars": 24651, "license": "other", "language": "c", "size": 5702}
{"docstring": "// the following were split out into separate functions while optimizing;\n// they could be pushed back up but eh. __forceinline showed no change;\n// they're probably already being inlined.\n", "func_signal": "static void imdct_step3_iter0_loop(int n, float *e, int i_off, int k_off, float *A)", "code": "{\n   float *ee0 = e + i_off;\n   float *ee2 = ee0 + k_off;\n   int i;\n\n   assert((n & 3) == 0);\n   for (i=(n>>2); i > 0; --i) {\n      float k00_20, k01_21;\n      k00_20  = ee0[ 0] - ee2[ 0];\n      k01_21  = ee0[-1] - ee2[-1];\n      ee0[ 0] += ee2[ 0];//ee0[ 0] = ee0[ 0] + ee2[ 0];\n      ee0[-1] += ee2[-1];//ee0[-1] = ee0[-1] + ee2[-1];\n      ee2[ 0] = k00_20 * A[0] - k01_21 * A[1];\n      ee2[-1] = k01_21 * A[0] + k00_20 * A[1];\n      A += 8;\n\n      k00_20  = ee0[-2] - ee2[-2];\n      k01_21  = ee0[-3] - ee2[-3];\n      ee0[-2] += ee2[-2];//ee0[-2] = ee0[-2] + ee2[-2];\n      ee0[-3] += ee2[-3];//ee0[-3] = ee0[-3] + ee2[-3];\n      ee2[-2] = k00_20 * A[0] - k01_21 * A[1];\n      ee2[-3] = k01_21 * A[0] + k00_20 * A[1];\n      A += 8;\n\n      k00_20  = ee0[-4] - ee2[-4];\n      k01_21  = ee0[-5] - ee2[-5];\n      ee0[-4] += ee2[-4];//ee0[-4] = ee0[-4] + ee2[-4];\n      ee0[-5] += ee2[-5];//ee0[-5] = ee0[-5] + ee2[-5];\n      ee2[-4] = k00_20 * A[0] - k01_21 * A[1];\n      ee2[-5] = k01_21 * A[0] + k00_20 * A[1];\n      A += 8;\n\n      k00_20  = ee0[-6] - ee2[-6];\n      k01_21  = ee0[-7] - ee2[-7];\n      ee0[-6] += ee2[-6];//ee0[-6] = ee0[-6] + ee2[-6];\n      ee0[-7] += ee2[-7];//ee0[-7] = ee0[-7] + ee2[-7];\n      ee2[-6] = k00_20 * A[0] - k01_21 * A[1];\n      ee2[-7] = k01_21 * A[0] + k00_20 * A[1];\n      A += 8;\n      ee0 -= 8;\n      ee2 -= 8;\n   }\n}", "path": "stb/stb_vorbis.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "nothings/stb", "stars": 24651, "license": "other", "language": "c", "size": 5702}
{"docstring": "// same as above, but just barely able to run in real time on modern machines\n", "func_signal": "void inverse_mdct_slow(float *buffer, int n, vorb *f, int blocktype)", "code": "{\n   float mcos[16384];\n   int i,j;\n   int n2 = n >> 1, nmask = (n << 2) -1;\n   float *x = (float *) malloc(sizeof(*x) * n2);\n   memcpy(x, buffer, sizeof(*x) * n2);\n   for (i=0; i < 4*n; ++i)\n      mcos[i] = (float) cos(M_PI / 2 * i / n);\n\n   for (i=0; i < n; ++i) {\n      float acc = 0;\n      for (j=0; j < n2; ++j)\n         acc += x[j] * mcos[(2 * i + 1 + n2)*(2*j+1) & nmask];\n      buffer[i] = acc;\n   }\n   free(x);\n}", "path": "stb/stb_vorbis.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "nothings/stb", "stars": 24651, "license": "other", "language": "c", "size": 5702}
{"docstring": "// naive backtracking implementation\n", "func_signal": "int wildmatch(char *expr, char *candidate)", "code": "{\n   while(*expr) {\n      if (*expr == '?') {\n         if (!*candidate) return 0;\n         ++candidate;\n         ++expr;\n      } else if (*expr == '*') {\n         ++expr;\n         while (*expr == '*' || *expr =='?') ++expr;\n         // '*' at end of expression matches anything\n         if (!*expr) return 1;\n         // now scan candidate 'til first match\n         while (*candidate) {\n            if (*candidate == *expr) {\n               // check this candidate\n               if (stb_wildmatch(expr+1, candidate+1))\n                  return 1;\n               // if not, then backtrack\n            }\n            ++candidate;\n         }\n      } else {\n         if (*expr != *candidate)\n            return 0;\n         ++expr, ++candidate;\n      }\n   }\n   return *candidate != 0;\n}", "path": "stb/tests/stb.c", "commit_date": "2019-03-04 00:00:00", "repo_name": "nothings/stb", "stars": 24651, "license": "other", "language": "c", "size": 5702}
{"docstring": "// if the fast table above doesn't work, we want to binary\n// search them... need to reverse the bits\n", "func_signal": "static void compute_sorted_huffman(Codebook *c, uint8 *lengths, uint32 *values)", "code": "{\n   int i, len;\n   // build a list of all the entries\n   // OPTIMIZATION: don't include the short ones, since they'll be caught by FAST_HUFFMAN.\n   // this is kind of a frivolous optimization--I don't see any performance improvement,\n   // but it's like 4 extra lines of code, so.\n   if (!c->sparse) {\n      int k = 0;\n      for (i=0; i < c->entries; ++i)\n         if (include_in_sort(c, lengths[i]))\n            c->sorted_codewords[k++] = bit_reverse(c->codewords[i]);\n      assert(k == c->sorted_entries);\n   } else {\n      for (i=0; i < c->sorted_entries; ++i)\n         c->sorted_codewords[i] = bit_reverse(c->codewords[i]);\n   }\n\n   qsort(c->sorted_codewords, c->sorted_entries, sizeof(c->sorted_codewords[0]), uint32_compare);\n   c->sorted_codewords[c->sorted_entries] = 0xffffffff;\n\n   len = c->sparse ? c->sorted_entries : c->entries;\n   // now we need to indicate how they correspond; we could either\n   //   #1: sort a different data structure that says who they correspond to\n   //   #2: for each sorted entry, search the original list to find who corresponds\n   //   #3: for each original entry, find the sorted entry\n   // #1 requires extra storage, #2 is slow, #3 can use binary search!\n   for (i=0; i < len; ++i) {\n      int huff_len = c->sparse ? lengths[values[i]] : lengths[i];\n      if (include_in_sort(c,huff_len)) {\n         uint32 code = bit_reverse(c->codewords[i]);\n         int x=0, n=c->sorted_entries;\n         while (n > 1) {\n            // invariant: sc[x] <= code < sc[x+n]\n            int m = x + (n >> 1);\n            if (c->sorted_codewords[m] <= code) {\n               x = m;\n               n -= (n>>1);\n            } else {\n               n >>= 1;\n            }\n         }\n         assert(c->sorted_codewords[x] == code);\n         if (c->sparse) {\n            c->sorted_values[x] = values[i];\n            c->codeword_lengths[x] = huff_len;\n         } else {\n            c->sorted_values[x] = i;\n         }\n      }\n   }\n}", "path": "stb/stb_vorbis.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "nothings/stb", "stars": 24651, "license": "other", "language": "c", "size": 5702}
{"docstring": "/* Set the extended payload length into the given pointer. */\n", "func_signal": "static void\nws_set_extended_header_size (const char *buf, int *extended)", "code": "{\n  uint64_t payloadlen = 0;\n  /* determine the payload length, else read more data */\n  payloadlen = WS_FRM_PAYLOAD (*(buf + 1));\n  switch (payloadlen) {\n  case WS_PAYLOAD_EXT16:\n    *extended = 2;\n    break;\n  case WS_PAYLOAD_EXT64:\n    *extended = 8;\n    break;\n  }\n}", "path": "goaccess/src/websocket.c", "commit_date": "2020-12-02 00:00:00", "repo_name": "allinurl/goaccess", "stars": 17301, "license": "mit", "language": "c", "size": 8436}
{"docstring": "/* Set a new named pipe for incoming messages and one for outgoing\n * messages from the client. */\n", "func_signal": "static void\nws_fifo (WSServer * server)", "code": "{\n  ws_openfifo_in (server->pipein);\n  ws_openfifo_out (server->pipeout);\n}", "path": "goaccess/src/websocket.c", "commit_date": "2020-12-02 00:00:00", "repo_name": "allinurl/goaccess", "stars": 17301, "license": "mit", "language": "c", "size": 8436}
{"docstring": "/* Get sockaddr, either IPv4 or IPv6 */\n", "func_signal": "static void *\nws_get_raddr (struct sockaddr *sa)", "code": "{\n  if (sa->sa_family == AF_INET)\n    return &(((struct sockaddr_in *) (void *) sa)->sin_addr);\n\n  return &(((struct sockaddr_in6 *) (void *) sa)->sin6_addr);\n}", "path": "goaccess/src/websocket.c", "commit_date": "2020-12-02 00:00:00", "repo_name": "allinurl/goaccess", "stars": 17301, "license": "mit", "language": "c", "size": 8436}
{"docstring": "/* From RFC2616, each header field consists of a name followed by a\n * colon (\":\") and the field value. Field names are case-insensitive.\n * The field value MAY be preceded by any amount of LWS, though a\n * single SP is preferred */\n", "func_signal": "static int\nws_set_header_fields (char *line, WSHeaders * headers)", "code": "{\n  char *path = NULL, *method = NULL, *proto = NULL, *p, *value;\n\n  if (line[0] == '\\n' || line[0] == '\\r')\n    return 1;\n\n  if ((strstr (line, \"GET \")) || (strstr (line, \"get \"))) {\n    if ((path = ws_parse_request (line, &method, &proto)) == NULL)\n      return 1;\n    headers->path = path;\n    headers->method = method;\n    headers->protocol = proto;\n\n    return 0;\n  }\n\n  if ((p = strchr (line, ':')) == NULL)\n    return 1;\n\n  value = p + 1;\n  while (p != line && isspace ((unsigned char) *(p - 1)))\n    p--;\n\n  if (p == line)\n    return 1;\n\n  *p = '\\0';\n  if (strpbrk (line, \" \\t\") != NULL) {\n    *p = ' ';\n    return 1;\n  }\n  while (isspace ((unsigned char) *value))\n    value++;\n\n  ws_set_header_key_value (headers, line, value);\n\n  return 0;\n}", "path": "goaccess/src/websocket.c", "commit_date": "2020-12-02 00:00:00", "repo_name": "allinurl/goaccess", "stars": 17301, "license": "mit", "language": "c", "size": 8436}
{"docstring": "/* Send an HTTP error status to the given client.\n *\n * On success, the number of sent bytes is returned. */\n", "func_signal": "static int\nhttp_error (WSClient * client, const char *buffer)", "code": "{\n  /* do access logging */\n  gettimeofday (&client->end_proc, NULL);\n  if (wsconfig.accesslog)\n    access_log (client, 400);\n\n  return ws_respond (client, buffer, strlen (buffer));\n}", "path": "goaccess/src/websocket.c", "commit_date": "2020-12-02 00:00:00", "repo_name": "allinurl/goaccess", "stars": 17301, "license": "mit", "language": "c", "size": 8436}
{"docstring": "/* Handle a websocket pong. */\n", "func_signal": "static void\nws_handle_pong (WSClient * client)", "code": "{\n  WSFrame **frm = &client->frame;\n\n  if (!(*frm)->fin) {\n    ws_handle_err (client, WS_CLOSE_PROTO_ERR, WS_ERR | WS_CLOSE, NULL);\n    return;\n  }\n  ws_free_message (client);\n}", "path": "goaccess/src/websocket.c", "commit_date": "2020-12-02 00:00:00", "repo_name": "allinurl/goaccess", "stars": 17301, "license": "mit", "language": "c", "size": 8436}
{"docstring": "/* Handle reading and sending the incoming data from the named pipe on\n * strict mode. */\n", "func_signal": "static void\nhandle_strict_fifo (WSServer * server)", "code": "{\n  WSPipeIn *pi = server->pipein;\n  WSPacket **pa = &pi->packet;\n  int bytes = 0, readh = 0, need = 0;\n\n  char *ptr = NULL;\n  uint32_t listener = 0, type = 0, size = 0;\n\n  readh = pi->hlen;     /* read from header so far */\n  need = HDR_SIZE - readh;      /* need to read */\n  if (need > 0) {\n    if ((bytes = ws_read_fifo (pi->fd, pi->hdr, &pi->hlen, readh, need)) < 0)\n      return;\n    if (bytes != need)\n      return;\n  }\n\n  /* unpack size, and type */\n  ptr = pi->hdr;\n  ptr += unpack_uint32 (ptr, &listener);\n  ptr += unpack_uint32 (ptr, &type);\n  ptr += unpack_uint32 (ptr, &size);\n\n  if (validate_fifo_packet (listener, type, size) == 1) {\n    close (pi->fd);\n    clear_fifo_packet (pi);\n    ws_openfifo_in (pi);\n    return;\n  }\n\n  if ((*pa) == NULL) {\n    (*pa) = xcalloc (1, sizeof (WSPacket));\n    (*pa)->type = type;\n    (*pa)->size = size;\n    (*pa)->data = xcalloc (size, sizeof (char));\n  }\n\n  readh = (*pa)->len;   /* read from payload so far */\n  need = (*pa)->size - readh;   /* need to read */\n  if (need > 0) {\n    if ((bytes = ws_read_fifo (pi->fd, (*pa)->data, &(*pa)->len, readh, need)) < 0)\n      return;\n    if (bytes != need)\n      return;\n  }\n\n  /* no clients to send data to */\n  if (list_count (server->colist) == 0) {\n    clear_fifo_packet (pi);\n    return;\n  }\n\n  /* Either send it to a specific client or broadcast message to all\n   * clients */\n  if (listener != 0)\n    ws_send_strict_fifo_to_client (server, listener, *pa);\n  else\n    list_foreach (server->colist, ws_broadcast_fifo, *pa);\n  clear_fifo_packet (pi);\n}", "path": "goaccess/src/websocket.c", "commit_date": "2020-12-02 00:00:00", "repo_name": "allinurl/goaccess", "stars": 17301, "license": "mit", "language": "c", "size": 8436}
{"docstring": "/* Open a named pipe (FIFO) for output from the server (writer). */\n", "func_signal": "static int\nws_openfifo_out (WSPipeOut * pipeout)", "code": "{\n  int status = 0;\n\n  ws_setfifo (wsconfig.pipeout);\n  status = open (wsconfig.pipeout, O_WRONLY | O_NONBLOCK);\n  /* will attempt on the next write */\n  if (status == -1 && errno == ENXIO)\n    LOG ((\"Unable to open fifo out: %s.\\n\", strerror (errno)));\n  else if (status < 0)\n    FATAL (\"Unable to open fifo out: %s.\", strerror (errno));\n  pipeout->fd = status;\n\n  if (status != -1 && status > max_file_fd)\n    max_file_fd = status;\n\n  return status;\n}", "path": "goaccess/src/websocket.c", "commit_date": "2020-12-02 00:00:00", "repo_name": "allinurl/goaccess", "stars": 17301, "license": "mit", "language": "c", "size": 8436}
{"docstring": "/* Create a new SSL structure for a connection and perform handshake */\n", "func_signal": "static void\nhandle_accept_ssl (WSClient * client, WSServer * server)", "code": "{\n  /* attempt to create SSL connection if we don't have one yet */\n  if (!client->ssl) {\n    if (!(client->ssl = SSL_new (server->ctx))) {\n      LOG ((\"SSL: SSL_new, new SSL structure failed.\\n\"));\n      return;\n    }\n    if (!SSL_set_fd (client->ssl, client->listener)) {\n      LOG ((\"SSL: unable to set file descriptor\\n\"));\n      return;\n    }\n  }\n\n  /* attempt to initiate the TLS/SSL handshake */\n  if (accept_ssl (client) == 0) {\n    LOG ((\"SSL Accepted: %d %s\\n\", client->listener, client->remote_ip));\n  }\n}", "path": "goaccess/src/websocket.c", "commit_date": "2020-12-02 00:00:00", "repo_name": "allinurl/goaccess", "stars": 17301, "license": "mit", "language": "c", "size": 8436}
{"docstring": "/* Attempt to send the queued up client's data to the given socket.\n *\n * On error, -1 is returned and the connection status is set.\n * On success, the number of bytes sent is returned. */\n", "func_signal": "static int\nws_respond_cache (WSClient * client)", "code": "{\n  WSQueue *queue = client->sockqueue;\n  int bytes = 0;\n\n  bytes = send_buffer (client, queue->queued, queue->qlen);\n  if (bytes == -1 && errno == EPIPE)\n    return ws_set_status (client, WS_ERR | WS_CLOSE, bytes);\n\n  if (bytes == -1 && (errno == EAGAIN || errno == EWOULDBLOCK))\n    return bytes;\n\n  if (chop_nchars (queue->queued, bytes, queue->qlen) == 0)\n    ws_clear_queue (client);\n  else\n    queue->qlen -= bytes;\n\n  return bytes;\n}", "path": "goaccess/src/websocket.c", "commit_date": "2020-12-02 00:00:00", "repo_name": "allinurl/goaccess", "stars": 17301, "license": "mit", "language": "c", "size": 8436}
{"docstring": "/* Check each client to determine if:\n * 1. We want to see if it has data for reading\n * 2. We want to write data to it.\n * If so, set the client's socket descriptor in the descriptor set. */\n", "func_signal": "static void\nset_rfds_wfds (int listener, WSServer * server, WSPipeIn * pi, WSPipeOut * po)", "code": "{\n  WSClient *client = NULL;\n  int conn;\n\n  /* pipe out */\n  if (po->fd != -1) {\n    if (po->status & WS_SENDING)\n      FD_SET (po->fd, &fdstate.wfds);\n  }\n  /* pipe in */\n  if (pi->fd != -1)\n    FD_SET (pi->fd, &fdstate.rfds);\n\n  /* self-pipe trick to stop the event loop */\n  FD_SET (server->self_pipe[0], &fdstate.rfds);\n  /* server socket, ready for accept() */\n  FD_SET (listener, &fdstate.rfds);\n\n  for (conn = 0; conn < FD_SETSIZE; ++conn) {\n    if (conn == pi->fd || conn == po->fd)\n      continue;\n    if (!(client = ws_get_client_from_list (conn, &server->colist)))\n      continue;\n\n    /* As long as we are not closing a connection, we assume we always\n     * check a client for reading */\n    if (!server->closing) {\n      FD_SET (conn, &fdstate.rfds);\n      if (conn > max_file_fd)\n        max_file_fd = conn;\n    }\n    /* Only if we have data to send the client */\n    if (client->status & WS_SENDING) {\n      FD_SET (conn, &fdstate.wfds);\n      if (conn > max_file_fd)\n        max_file_fd = conn;\n    }\n  }\n}", "path": "goaccess/src/websocket.c", "commit_date": "2020-12-02 00:00:00", "repo_name": "allinurl/goaccess", "stars": 17301, "license": "mit", "language": "c", "size": 8436}
{"docstring": "/* Send an error message to the given client.\n *\n * On success, the number of sent bytes is returned. */\n", "func_signal": "static int\nws_error (WSClient * client, unsigned short code, const char *err)", "code": "{\n  unsigned int len;\n  unsigned short code_be;\n  char buf[128] = { 0 };\n\n  len = 2;\n  code_be = htobe16 (code);\n  memcpy (buf, &code_be, 2);\n  if (err)\n    len += snprintf (buf + 2, sizeof buf - 4, \"%s\", err);\n\n  return ws_send_frame (client, WS_OPCODE_CLOSE, buf, len);\n}", "path": "goaccess/src/websocket.c", "commit_date": "2020-12-02 00:00:00", "repo_name": "allinurl/goaccess", "stars": 17301, "license": "mit", "language": "c", "size": 8436}
{"docstring": "/* Wait for a TLS/SSL client to initiate a TLS/SSL handshake\n *\n * On fatal error, the connection is shut down.\n * If data still needs to be read/written, -1 is returned.\n * On success, the TLS/SSL connection is completed and 0 is returned */\n", "func_signal": "static int\naccept_ssl (WSClient * client)", "code": "{\n  int ret = -1, err = 0;\n\n  /* all good on TLS handshake */\n  if ((ret = SSL_accept (client->ssl)) > 0) {\n    client->sslstatus &= ~WS_TLS_ACCEPTING;\n    return 0;\n  }\n\n  err = SSL_get_error (client->ssl, ret);\n  log_return_message (ret, err, \"SSL_accept\");\n\n  switch (err) {\n  case SSL_ERROR_WANT_READ:\n  case SSL_ERROR_WANT_WRITE:\n    client->sslstatus = WS_TLS_ACCEPTING;\n    break;\n  case SSL_ERROR_SYSCALL:\n    /* Wait for more activity else bail out, for instance if the socket is closed\n     * during the handshake. */\n    if (ret < 0 && (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)) {\n      client->sslstatus = WS_TLS_ACCEPTING;\n      break;\n    }\n    /* The peer notified that it is shutting down through a SSL \"close_notify\" so\n     * we shutdown too */\n    /* FALLTHRU */\n  case SSL_ERROR_ZERO_RETURN:\n  case SSL_ERROR_WANT_X509_LOOKUP:\n  default:\n    client->sslstatus &= ~WS_TLS_ACCEPTING;\n    return ws_set_status (client, WS_ERR | WS_CLOSE, 1);\n  }\n\n  return ret;\n}", "path": "goaccess/src/websocket.c", "commit_date": "2020-12-02 00:00:00", "repo_name": "allinurl/goaccess", "stars": 17301, "license": "mit", "language": "c", "size": 8436}
{"docstring": "/* Read data from the given client's socket and set a connection\n * status given the output of recv().\n *\n * On error, -1 is returned and the connection status is set.\n * On success, the number of bytes read is returned. */\n", "func_signal": "static int\nread_ssl_socket (WSClient * client, char *buffer, int size)", "code": "{\n  int bytes = 0, done = 0, err = 0;\n  do {\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    ERR_clear_error ();\n#endif\n\n    done = 0;\n    if ((bytes = SSL_read (client->ssl, buffer, size)) > 0)\n      break;\n\n    err = SSL_get_error (client->ssl, bytes);\n    log_return_message (bytes, err, \"SSL_read\");\n\n    switch (err) {\n    case SSL_ERROR_WANT_WRITE:\n      client->sslstatus = WS_TLS_READING;\n      done = 1;\n      break;\n    case SSL_ERROR_WANT_READ:\n      done = 1;\n      break;\n    case SSL_ERROR_SYSCALL:\n      if ((bytes < 0 && (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)))\n        break;\n      /* FALLTHRU */\n    case SSL_ERROR_ZERO_RETURN:\n    case SSL_ERROR_WANT_X509_LOOKUP:\n    default:\n      return ws_set_status (client, WS_ERR | WS_CLOSE, -1);\n    }\n  } while (SSL_pending (client->ssl) && !done);\n\n  return bytes;\n}", "path": "goaccess/src/websocket.c", "commit_date": "2020-12-02 00:00:00", "repo_name": "allinurl/goaccess", "stars": 17301, "license": "mit", "language": "c", "size": 8436}
{"docstring": "/* Remove all clients that are still hanging out. */\n", "func_signal": "static int\nws_remove_dangling_clients (void *value, void *user_data)", "code": "{\n  WSClient *client = value;\n  (void) (user_data);\n\n  if (client == NULL)\n    return 1;\n\n  if (client->headers)\n    ws_clear_handshake_headers (client->headers);\n  if (client->sockqueue)\n    ws_clear_queue (client);\n#ifdef HAVE_LIBSSL\n  if (client->ssl)\n    ws_shutdown_dangling_clients (client);\n#endif\n\n  return 0;\n}", "path": "goaccess/src/websocket.c", "commit_date": "2020-12-02 00:00:00", "repo_name": "allinurl/goaccess", "stars": 17301, "license": "mit", "language": "c", "size": 8436}
{"docstring": "/* Given the current status of the SSL buffer, perform that action.\n *\n * On error or if no SSL pending status, 1 is returned.\n * On success, the TLS/SSL pending action is called and 0 is returned */\n", "func_signal": "static int\nhandle_ssl_pending_rw (int conn, WSServer * server, WSClient * client)", "code": "{\n  if (!wsconfig.use_ssl)\n    return 1;\n\n  /* trying to write but still waiting for a successful SSL_accept */\n  if (client->sslstatus & WS_TLS_ACCEPTING) {\n    handle_accept_ssl (client, server);\n    return 0;\n  }\n  /* trying to read but still waiting for a successful SSL_read */\n  if (client->sslstatus & WS_TLS_READING) {\n    handle_reads (conn, server);\n    return 0;\n  }\n  /* trying to write but still waiting for a successful SSL_write */\n  if (client->sslstatus & WS_TLS_WRITING) {\n    handle_writes (conn, server);\n    return 0;\n  }\n  /* trying to write but still waiting for a successful SSL_shutdown */\n  if (client->sslstatus & WS_TLS_SHUTTING) {\n    if (shutdown_ssl (client) == 0)\n      handle_read_close (conn, client, server);\n    return 0;\n  }\n\n  return 1;\n}", "path": "goaccess/src/websocket.c", "commit_date": "2020-12-02 00:00:00", "repo_name": "allinurl/goaccess", "stars": 17301, "license": "mit", "language": "c", "size": 8436}
{"docstring": "/* Set into a queue the data that couldn't be sent in the outgoing\n * FIFO. */\n", "func_signal": "static void\nws_queue_fifobuf (WSPipeOut * pipeout, const char *buffer, int len, int bytes)", "code": "{\n  WSQueue **queue = &pipeout->fifoqueue;\n\n  if (bytes < 1)\n    bytes = 0;\n\n  (*queue) = xcalloc (1, sizeof (WSQueue));\n  (*queue)->queued = xcalloc (len - bytes, sizeof (char));\n  memcpy ((*queue)->queued, buffer + bytes, len - bytes);\n  (*queue)->qlen = len - bytes;\n\n  pipeout->status |= WS_SENDING;\n}", "path": "goaccess/src/websocket.c", "commit_date": "2020-12-02 00:00:00", "repo_name": "allinurl/goaccess", "stars": 17301, "license": "mit", "language": "c", "size": 8436}
{"docstring": "/* Ensure the fields coming from the named pipe are valid.\n *\n * On error, 1 is returned.\n * On success, 0 is returned. */\n", "func_signal": "static int\nvalidate_fifo_packet (uint32_t listener, uint32_t type, int size)", "code": "{\n  if (listener > FD_SETSIZE) {\n    LOG ((\"Invalid listener\\n\"));\n    return 1;\n  }\n\n  if (type != WS_OPCODE_TEXT && type != WS_OPCODE_BIN) {\n    LOG ((\"Invalid fifo packet type\\n\"));\n    return 1;\n  }\n\n  if (size > wsconfig.max_frm_size) {\n    LOG ((\"Invalid fifo packet size\\n\"));\n    return 1;\n  }\n\n  return 0;\n}", "path": "goaccess/src/websocket.c", "commit_date": "2020-12-02 00:00:00", "repo_name": "allinurl/goaccess", "stars": 17301, "license": "mit", "language": "c", "size": 8436}
{"docstring": "/* Decode a character maintaining state and a byte, and returns the\n * state achieved after processing the byte.\n *\n * The state after the by has been processed is returned. */\n", "func_signal": "static uint32_t\nutf8_decode (uint32_t * state, uint32_t * p, uint32_t b)", "code": "{\n  uint32_t type = utf8d[(uint8_t) b];\n\n  *p = (*state != UTF8_VALID) ? (b & 0x3fu) | (*p << 6) : (0xff >> type) & (b);\n  *state = utf8d[256 + *state * 16 + type];\n\n  return *state;\n}", "path": "goaccess/src/websocket.c", "commit_date": "2020-12-02 00:00:00", "repo_name": "allinurl/goaccess", "stars": 17301, "license": "mit", "language": "c", "size": 8436}
{"docstring": "/* Pack the given value into a network byte order.\n *\n * On success, the number size of uint32_t is returned. */\n", "func_signal": "size_t\npack_uint32 (void *buf, uint32_t val)", "code": "{\n  uint32_t v32 = htonl (val);\n  memcpy (buf, &v32, sizeof (uint32_t));\n\n  return sizeof (uint32_t);\n}", "path": "goaccess/src/websocket.c", "commit_date": "2020-12-02 00:00:00", "repo_name": "allinurl/goaccess", "stars": 17301, "license": "mit", "language": "c", "size": 8436}
{"docstring": "/* Process a desktop save order */\n", "func_signal": "static void\nprocess_desksave(STREAM s, DESKSAVE_ORDER * os, uint32 present, RD_BOOL delta)", "code": "{\n\tint width, height;\n\n\tif (present & 0x01)\n\t\tin_uint32_le(s, os->offset);\n\n\tif (present & 0x02)\n\t\trdp_in_coord(s, &os->left, delta);\n\n\tif (present & 0x04)\n\t\trdp_in_coord(s, &os->top, delta);\n\n\tif (present & 0x08)\n\t\trdp_in_coord(s, &os->right, delta);\n\n\tif (present & 0x10)\n\t\trdp_in_coord(s, &os->bottom, delta);\n\n\tif (present & 0x20)\n\t\tin_uint8(s, os->action);\n\n\tDEBUG((\"DESKSAVE(l=%d,t=%d,r=%d,b=%d,off=%d,op=%d)\\n\",\n\t       os->left, os->top, os->right, os->bottom, os->offset, os->action));\n\n\twidth = os->right - os->left + 1;\n\theight = os->bottom - os->top + 1;\n\n\tif (os->action == 0)\n\t\tui_desktop_save(os->offset, os->left, os->top, width, height);\n\telse\n\t\tui_desktop_restore(os->offset, os->left, os->top, width, height);\n}", "path": "reactos/base/applications/mstsc/orders.c", "commit_date": "2017-10-03 00:00:00", "repo_name": "reactos/reactos", "stars": 13852, "license": "gpl-2.0", "language": "c", "size": 632043}
{"docstring": "/*\n * FUNCTION: Initialize service provider for a client\n * ARGUMENTS:\n *     wVersionRequested = Highest WinSock SPI version that the caller can use\n *     lpWSPData         = Address of WSPDATA structure to initialize\n *     lpProtocolInfo    = Pointer to structure that defines the desired protocol\n *     UpcallTable       = Pointer to upcall table of the WinSock DLL\n *     lpProcTable       = Address of procedure table to initialize\n * RETURNS:\n *     Status of operation\n */\n", "func_signal": "_Must_inspect_result_\nint\nWSPAPI\nWSPStartup(\n    _In_ WORD wVersionRequested,\n    _In_ LPWSPDATA lpWSPData,\n    _In_ LPWSAPROTOCOL_INFOW lpProtocolInfo,\n    _In_ WSPUPCALLTABLE UpcallTable,\n    _Out_ LPWSPPROC_TABLE lpProcTable)", "code": "{\n    NTSTATUS Status;\n\n    if (((LOBYTE(wVersionRequested) == 2) && (HIBYTE(wVersionRequested) < 2)) ||\n        (LOBYTE(wVersionRequested) < 2))\n    {\n        ERR(\"WSPStartup NOT SUPPORTED for version 0x%X\\n\", wVersionRequested);\n        return WSAVERNOTSUPPORTED;\n    }\n    else\n        Status = NO_ERROR;\n    /* FIXME: Enable all cases of WSPStartup status */\n    Upcalls = UpcallTable;\n\n    if (Status == NO_ERROR)\n    {\n        lpProcTable->lpWSPAccept = WSPAccept;\n        lpProcTable->lpWSPAddressToString = WSPAddressToString;\n        lpProcTable->lpWSPAsyncSelect = WSPAsyncSelect;\n        lpProcTable->lpWSPBind = WSPBind;\n        lpProcTable->lpWSPCancelBlockingCall = WSPCancelBlockingCall;\n        lpProcTable->lpWSPCleanup = WSPCleanup;\n        lpProcTable->lpWSPCloseSocket = WSPCloseSocket;\n        lpProcTable->lpWSPConnect = WSPConnect;\n        lpProcTable->lpWSPDuplicateSocket = WSPDuplicateSocket;\n        lpProcTable->lpWSPEnumNetworkEvents = WSPEnumNetworkEvents;\n        lpProcTable->lpWSPEventSelect = WSPEventSelect;\n        lpProcTable->lpWSPGetOverlappedResult = WSPGetOverlappedResult;\n        lpProcTable->lpWSPGetPeerName = WSPGetPeerName;\n        lpProcTable->lpWSPGetSockName = WSPGetSockName;\n        lpProcTable->lpWSPGetSockOpt = WSPGetSockOpt;\n        lpProcTable->lpWSPGetQOSByName = WSPGetQOSByName;\n        lpProcTable->lpWSPIoctl = WSPIoctl;\n        lpProcTable->lpWSPJoinLeaf = WSPJoinLeaf;\n        lpProcTable->lpWSPListen = WSPListen;\n        lpProcTable->lpWSPRecv = WSPRecv;\n        lpProcTable->lpWSPRecvDisconnect = WSPRecvDisconnect;\n        lpProcTable->lpWSPRecvFrom = WSPRecvFrom;\n        lpProcTable->lpWSPSelect = WSPSelect;\n        lpProcTable->lpWSPSend = WSPSend;\n        lpProcTable->lpWSPSendDisconnect = WSPSendDisconnect;\n        lpProcTable->lpWSPSendTo = WSPSendTo;\n        lpProcTable->lpWSPSetSockOpt = WSPSetSockOpt;\n        lpProcTable->lpWSPShutdown = WSPShutdown;\n        lpProcTable->lpWSPSocket = WSPSocket;\n        lpProcTable->lpWSPStringToAddress = WSPStringToAddress;\n        lpWSPData->wVersion     = MAKEWORD(2, 2);\n        lpWSPData->wHighVersion = MAKEWORD(2, 2);\n        /* Save CatalogEntryId for all upcalls */\n        CatalogEntryId = lpProtocolInfo->dwCatalogEntryId;\n    }\n\n    TRACE(\"Status (%d).\\n\", Status);\n    return Status;\n}", "path": "reactos/dll/win32/msafd/misc/dllmain.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "reactos/reactos", "stars": 13852, "license": "gpl-2.0", "language": "c", "size": 632043}
{"docstring": "/*\n * FUNCTION: Associates a local address with a socket\n * ARGUMENTS:\n *     s       = Socket descriptor\n *     name    = Pointer to local address\n *     namelen = Length of name\n *     lpErrno = Address of buffer for error information\n * RETURNS:\n *     0, or SOCKET_ERROR if the socket could not be bound\n */\n", "func_signal": "INT\nWSPAPI\nWSPBind(SOCKET Handle,\n        const struct sockaddr *SocketAddress,\n        int SocketAddressLength,\n        LPINT lpErrno)", "code": "{\n    IO_STATUS_BLOCK         IOSB;\n    PAFD_BIND_DATA          BindData;\n    PSOCKET_INFORMATION     Socket = NULL;\n    NTSTATUS                Status;\n    SOCKADDR_INFO           SocketInfo;\n    HANDLE                  SockEvent;\n\n    /* Get the Socket Structure associate to this Socket*/\n    Socket = GetSocketStructure(Handle);\n    if (!Socket)\n    {\n       if (lpErrno) *lpErrno = WSAENOTSOCK;\n       return SOCKET_ERROR;\n    }\n    if (Socket->SharedData->State != SocketOpen)\n    {\n       if (lpErrno) *lpErrno = WSAEINVAL;\n       return SOCKET_ERROR;\n    }\n    if (!SocketAddress || SocketAddressLength < Socket->SharedData->SizeOfLocalAddress)\n    {\n        if (lpErrno) *lpErrno = WSAEINVAL;\n        return SOCKET_ERROR;\n    }\n\n    /* Get Address Information */\n    Socket->HelperData->WSHGetSockaddrType ((PSOCKADDR)SocketAddress,\n                                            SocketAddressLength,\n                                            &SocketInfo);\n\n    if (SocketInfo.AddressInfo == SockaddrAddressInfoBroadcast && !Socket->SharedData->Broadcast)\n    {\n       if (lpErrno) *lpErrno = WSAEADDRNOTAVAIL;\n       return SOCKET_ERROR;\n    }\n\n    Status = NtCreateEvent(&SockEvent,\n                           EVENT_ALL_ACCESS,\n                           NULL,\n                           SynchronizationEvent,\n                           FALSE);\n\n    if (!NT_SUCCESS(Status))\n    {\n        return SOCKET_ERROR;\n    }\n\n    /* See below */\n    BindData = HeapAlloc(GlobalHeap, 0, 0xA + SocketAddressLength);\n    if (!BindData)\n    {\n        return MsafdReturnWithErrno(STATUS_INSUFFICIENT_RESOURCES, lpErrno, 0, NULL);\n    }\n\n    /* Set up Address in TDI Format */\n    BindData->Address.TAAddressCount = 1;\n    BindData->Address.Address[0].AddressLength = (USHORT)(SocketAddressLength - sizeof(SocketAddress->sa_family));\n    BindData->Address.Address[0].AddressType = SocketAddress->sa_family;\n    RtlCopyMemory (BindData->Address.Address[0].Address,\n                   SocketAddress->sa_data,\n                   SocketAddressLength - sizeof(SocketAddress->sa_family));\n\n    /* Set the Share Type */\n    if (Socket->SharedData->ExclusiveAddressUse)\n    {\n        BindData->ShareType = AFD_SHARE_EXCLUSIVE;\n    }\n    else if (SocketInfo.EndpointInfo == SockaddrEndpointInfoWildcard)\n    {\n        BindData->ShareType = AFD_SHARE_WILDCARD;\n    }\n    else if (Socket->SharedData->ReuseAddresses)\n    {\n        BindData->ShareType = AFD_SHARE_REUSE;\n    }\n    else\n    {\n        BindData->ShareType = AFD_SHARE_UNIQUE;\n    }\n\n    /* Send IOCTL */\n    Status = NtDeviceIoControlFile((HANDLE)Socket->Handle,\n                                   SockEvent,\n                                   NULL,\n                                   NULL,\n                                   &IOSB,\n                                   IOCTL_AFD_BIND,\n                                   BindData,\n                                   0xA + Socket->SharedData->SizeOfLocalAddress, /* Can't figure out a way to calculate this in C*/\n                                   BindData,\n                                   0xA + Socket->SharedData->SizeOfLocalAddress); /* Can't figure out a way to calculate this C */\n\n    /* Wait for return */\n    if (Status == STATUS_PENDING)\n    {\n        WaitForSingleObject(SockEvent, INFINITE);\n        Status = IOSB.Status;\n    }\n\n    NtClose( SockEvent );\n    HeapFree(GlobalHeap, 0, BindData);\n\n    Socket->SharedData->SocketLastError = TranslateNtStatusError(Status);\n    if (Status != STATUS_SUCCESS)\n        return MsafdReturnWithErrno ( Status, lpErrno, 0, NULL );\n\n    /* Set up Socket Data */\n    Socket->SharedData->State = SocketBound;\n    Socket->TdiAddressHandle = (HANDLE)IOSB.Information;\n\n    if (Socket->HelperEvents & WSH_NOTIFY_BIND)\n    {\n        Status = Socket->HelperData->WSHNotify(Socket->HelperContext,\n                                               Socket->Handle,\n                                               Socket->TdiAddressHandle,\n                                               Socket->TdiConnectionHandle,\n                                               WSH_NOTIFY_BIND);\n\n        if (Status)\n        {\n            if (lpErrno) *lpErrno = Status;\n            return SOCKET_ERROR;\n        }\n    }\n\n    return MsafdReturnWithErrno ( Status, lpErrno, 0, NULL );\n}", "path": "reactos/dll/win32/msafd/misc/dllmain.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "reactos/reactos", "stars": 13852, "license": "gpl-2.0", "language": "c", "size": 632043}
{"docstring": "/* Process a 3-way blt order */\n", "func_signal": "static void\nprocess_triblt(STREAM s, TRIBLT_ORDER * os, uint32 present, RD_BOOL delta)", "code": "{\n\tRD_HBITMAP bitmap;\n\tBRUSH brush;\n\n\tif (present & 0x000001)\n\t{\n\t\tin_uint8(s, os->cache_id);\n\t\tin_uint8(s, os->colour_table);\n\t}\n\n\tif (present & 0x000002)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x000004)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x000008)\n\t\trdp_in_coord(s, &os->cx, delta);\n\n\tif (present & 0x000010)\n\t\trdp_in_coord(s, &os->cy, delta);\n\n\tif (present & 0x000020)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x000040)\n\t\trdp_in_coord(s, &os->srcx, delta);\n\n\tif (present & 0x000080)\n\t\trdp_in_coord(s, &os->srcy, delta);\n\n\tif (present & 0x000100)\n\t\trdp_in_colour(s, &os->bgcolour);\n\n\tif (present & 0x000200)\n\t\trdp_in_colour(s, &os->fgcolour);\n\n\trdp_parse_brush(s, &os->brush, present >> 10);\n\n\tif (present & 0x008000)\n\t\tin_uint16_le(s, os->cache_idx);\n\n\tif (present & 0x010000)\n\t\tin_uint16_le(s, os->unknown);\n\n\tDEBUG((\"TRIBLT(op=0x%x,x=%d,y=%d,cx=%d,cy=%d,id=%d,idx=%d,bs=%d,bg=0x%x,fg=0x%x)\\n\",\n\t       os->opcode, os->x, os->y, os->cx, os->cy, os->cache_id, os->cache_idx,\n\t       os->brush.style, os->bgcolour, os->fgcolour));\n\n\tbitmap = cache_get_bitmap(os->cache_id, os->cache_idx);\n\tif (bitmap == NULL)\n\t\treturn;\n\n\tsetup_brush(&brush, &os->brush);\n\n\tui_triblt(os->opcode, os->x, os->y, os->cx, os->cy,\n\t\t  bitmap, os->srcx, os->srcy, &brush, os->bgcolour, os->fgcolour);\n}", "path": "reactos/base/applications/mstsc/orders.c", "commit_date": "2017-10-03 00:00:00", "repo_name": "reactos/reactos", "stars": 13852, "license": "gpl-2.0", "language": "c", "size": 632043}
{"docstring": "/* Reset order state */\n", "func_signal": "void\nreset_order_state(void)", "code": "{\n\tmemset(&g_order_state, 0, sizeof(g_order_state));\n\tg_order_state.order_type = RDP_ORDER_PATBLT;\n}", "path": "reactos/base/applications/mstsc/orders.c", "commit_date": "2017-10-03 00:00:00", "repo_name": "reactos/reactos", "stars": 13852, "license": "gpl-2.0", "language": "c", "size": 632043}
{"docstring": "/* Process a memory blt order */\n", "func_signal": "static void\nprocess_memblt(STREAM s, MEMBLT_ORDER * os, uint32 present, RD_BOOL delta)", "code": "{\n\tRD_HBITMAP bitmap;\n\n\tif (present & 0x0001)\n\t{\n\t\tin_uint8(s, os->cache_id);\n\t\tin_uint8(s, os->colour_table);\n\t}\n\n\tif (present & 0x0002)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x0004)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x0008)\n\t\trdp_in_coord(s, &os->cx, delta);\n\n\tif (present & 0x0010)\n\t\trdp_in_coord(s, &os->cy, delta);\n\n\tif (present & 0x0020)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x0040)\n\t\trdp_in_coord(s, &os->srcx, delta);\n\n\tif (present & 0x0080)\n\t\trdp_in_coord(s, &os->srcy, delta);\n\n\tif (present & 0x0100)\n\t\tin_uint16_le(s, os->cache_idx);\n\n\tDEBUG((\"MEMBLT(op=0x%x,x=%d,y=%d,cx=%d,cy=%d,id=%d,idx=%d)\\n\",\n\t       os->opcode, os->x, os->y, os->cx, os->cy, os->cache_id, os->cache_idx));\n\n\tbitmap = cache_get_bitmap(os->cache_id, os->cache_idx);\n\tif (bitmap == NULL)\n\t\treturn;\n\n\tui_memblt(ROP2_S(os->opcode), os->x, os->y, os->cx, os->cy, bitmap, os->srcx, os->srcy);\n}", "path": "reactos/base/applications/mstsc/orders.c", "commit_date": "2017-10-03 00:00:00", "repo_name": "reactos/reactos", "stars": 13852, "license": "gpl-2.0", "language": "c", "size": 632043}
{"docstring": "/* Process a colourmap cache order */\n", "func_signal": "static void\nprocess_colcache(STREAM s)", "code": "{\n\tCOLOURENTRY *entry;\n\tCOLOURMAP map;\n\tRD_HCOLOURMAP hmap;\n\tuint8 cache_id;\n\tint i;\n\n\tin_uint8(s, cache_id);\n\tin_uint16_le(s, map.ncolours);\n\n\tmap.colours = (COLOURENTRY *) xmalloc(sizeof(COLOURENTRY) * map.ncolours);\n\n\tfor (i = 0; i < map.ncolours; i++)\n\t{\n\t\tentry = &map.colours[i];\n\t\tin_uint8(s, entry->blue);\n\t\tin_uint8(s, entry->green);\n\t\tin_uint8(s, entry->red);\n\t\tin_uint8s(s, 1);\t/* pad */\n\t}\n\n\tDEBUG((\"COLCACHE(id=%d,n=%d)\\n\", cache_id, map.ncolours));\n\n\thmap = ui_create_colourmap(&map);\n\n\tif (cache_id)\n\t\tui_set_colourmap(hmap);\n\n\txfree(map.colours);\n}", "path": "reactos/base/applications/mstsc/orders.c", "commit_date": "2017-10-03 00:00:00", "repo_name": "reactos/reactos", "stars": 13852, "license": "gpl-2.0", "language": "c", "size": 632043}
{"docstring": "/* Parse a brush */\n", "func_signal": "static RD_BOOL\nrdp_parse_brush(STREAM s, BRUSH * brush, uint32 present)", "code": "{\n\tif (present & 1)\n\t\tin_uint8(s, brush->xorigin);\n\n\tif (present & 2)\n\t\tin_uint8(s, brush->yorigin);\n\n\tif (present & 4)\n\t\tin_uint8(s, brush->style);\n\n\tif (present & 8)\n\t\tin_uint8(s, brush->pattern[0]);\n\n\tif (present & 16)\n\t\tin_uint8a(s, &brush->pattern[1], 7);\n\n\treturn s_check(s);\n}", "path": "reactos/base/applications/mstsc/orders.c", "commit_date": "2017-10-03 00:00:00", "repo_name": "reactos/reactos", "stars": 13852, "license": "gpl-2.0", "language": "c", "size": 632043}
{"docstring": "/* Process a polygon2 order */\n", "func_signal": "static void\nprocess_polygon2(STREAM s, POLYGON2_ORDER * os, uint32 present, RD_BOOL delta)", "code": "{\n\tint index, data, next;\n\tuint8 flags = 0;\n\tRD_POINT *points;\n\tBRUSH brush;\n\n\tif (present & 0x0001)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x0002)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x0004)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x0008)\n\t\tin_uint8(s, os->fillmode);\n\n\tif (present & 0x0010)\n\t\trdp_in_colour(s, &os->bgcolour);\n\n\tif (present & 0x0020)\n\t\trdp_in_colour(s, &os->fgcolour);\n\n\trdp_parse_brush(s, &os->brush, present >> 6);\n\n\tif (present & 0x0800)\n\t\tin_uint8(s, os->npoints);\n\n\tif (present & 0x1000)\n\t{\n\t\tin_uint8(s, os->datasize);\n\t\tin_uint8a(s, os->data, os->datasize);\n\t}\n\n\tDEBUG((\"POLYGON2(x=%d,y=%d,op=0x%x,fm=%d,bs=%d,bg=0x%x,fg=0x%x,n=%d,sz=%d)\\n\",\n\t       os->x, os->y, os->opcode, os->fillmode, os->brush.style, os->bgcolour, os->fgcolour,\n\t       os->npoints, os->datasize));\n\n\tDEBUG((\"Data: \"));\n\n\tfor (index = 0; index < os->datasize; index++)\n\t\tDEBUG((\"%02x \", os->data[index]));\n\n\tDEBUG((\"\\n\"));\n\n\tif (os->opcode < 0x01 || os->opcode > 0x10)\n\t{\n\t\terror(\"bad ROP2 0x%x\\n\", os->opcode);\n\t\treturn;\n\t}\n\n\tsetup_brush(&brush, &os->brush);\n\n\tpoints = (RD_POINT *) xmalloc((os->npoints + 1) * sizeof(RD_POINT));\n\tmemset(points, 0, (os->npoints + 1) * sizeof(RD_POINT));\n\n\tpoints[0].x = os->x;\n\tpoints[0].y = os->y;\n\n\tindex = 0;\n\tdata = ((os->npoints - 1) / 4) + 1;\n\tfor (next = 1; (next <= os->npoints) && (next < 256) && (data < os->datasize); next++)\n\t{\n\t\tif ((next - 1) % 4 == 0)\n\t\t\tflags = os->data[index++];\n\n\t\tif (~flags & 0x80)\n\t\t\tpoints[next].x = parse_delta(os->data, &data);\n\n\t\tif (~flags & 0x40)\n\t\t\tpoints[next].y = parse_delta(os->data, &data);\n\n\t\tflags <<= 2;\n\t}\n\n\tif (next - 1 == os->npoints)\n\t\tui_polygon(os->opcode - 1, os->fillmode, points, os->npoints + 1,\n\t\t\t   &brush, os->bgcolour, os->fgcolour);\n\telse\n\t\terror(\"polygon2 parse error\\n\");\n\n\txfree(points);\n}", "path": "reactos/base/applications/mstsc/orders.c", "commit_date": "2017-10-03 00:00:00", "repo_name": "reactos/reactos", "stars": 13852, "license": "gpl-2.0", "language": "c", "size": 632043}
{"docstring": "/* Parse bounds information */\n", "func_signal": "static RD_BOOL\nrdp_parse_bounds(STREAM s, BOUNDS * bounds)", "code": "{\n\tuint8 present;\n\n\tin_uint8(s, present);\n\n\tif (present & 1)\n\t\trdp_in_coord(s, &bounds->left, False);\n\telse if (present & 16)\n\t\trdp_in_coord(s, &bounds->left, True);\n\n\tif (present & 2)\n\t\trdp_in_coord(s, &bounds->top, False);\n\telse if (present & 32)\n\t\trdp_in_coord(s, &bounds->top, True);\n\n\tif (present & 4)\n\t\trdp_in_coord(s, &bounds->right, False);\n\telse if (present & 64)\n\t\trdp_in_coord(s, &bounds->right, True);\n\n\tif (present & 8)\n\t\trdp_in_coord(s, &bounds->bottom, False);\n\telse if (present & 128)\n\t\trdp_in_coord(s, &bounds->bottom, True);\n\n\treturn s_check(s);\n}", "path": "reactos/base/applications/mstsc/orders.c", "commit_date": "2017-10-03 00:00:00", "repo_name": "reactos/reactos", "stars": 13852, "license": "gpl-2.0", "language": "c", "size": 632043}
{"docstring": "/* Process a polyline order */\n", "func_signal": "static void\nprocess_polyline(STREAM s, POLYLINE_ORDER * os, uint32 present, RD_BOOL delta)", "code": "{\n\tint index, next, data;\n\tuint8 flags = 0;\n\tPEN pen;\n\tRD_POINT *points;\n\n\tif (present & 0x01)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x02)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x04)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x10)\n\t\trdp_in_colour(s, &os->fgcolour);\n\n\tif (present & 0x20)\n\t\tin_uint8(s, os->lines);\n\n\tif (present & 0x40)\n\t{\n\t\tin_uint8(s, os->datasize);\n\t\tin_uint8a(s, os->data, os->datasize);\n\t}\n\n\tDEBUG((\"POLYLINE(x=%d,y=%d,op=0x%x,fg=0x%x,n=%d,sz=%d)\\n\",\n\t       os->x, os->y, os->opcode, os->fgcolour, os->lines, os->datasize));\n\n\tDEBUG((\"Data: \"));\n\n\tfor (index = 0; index < os->datasize; index++)\n\t\tDEBUG((\"%02x \", os->data[index]));\n\n\tDEBUG((\"\\n\"));\n\n\tif (os->opcode < 0x01 || os->opcode > 0x10)\n\t{\n\t\terror(\"bad ROP2 0x%x\\n\", os->opcode);\n\t\treturn;\n\t}\n\n\tpoints = (RD_POINT *) xmalloc((os->lines + 1) * sizeof(RD_POINT));\n\tmemset(points, 0, (os->lines + 1) * sizeof(RD_POINT));\n\n\tpoints[0].x = os->x;\n\tpoints[0].y = os->y;\n\tpen.style = pen.width = 0;\n\tpen.colour = os->fgcolour;\n\n\tindex = 0;\n\tdata = ((os->lines - 1) / 4) + 1;\n\tfor (next = 1; (next <= os->lines) && (data < os->datasize); next++)\n\t{\n\t\tif ((next - 1) % 4 == 0)\n\t\t\tflags = os->data[index++];\n\n\t\tif (~flags & 0x80)\n\t\t\tpoints[next].x = parse_delta(os->data, &data);\n\n\t\tif (~flags & 0x40)\n\t\t\tpoints[next].y = parse_delta(os->data, &data);\n\n\t\tflags <<= 2;\n\t}\n\n\tif (next - 1 == os->lines)\n\t\tui_polyline(os->opcode - 1, points, os->lines + 1, &pen);\n\telse\n\t\terror(\"polyline parse error\\n\");\n\n\txfree(points);\n}", "path": "reactos/base/applications/mstsc/orders.c", "commit_date": "2017-10-03 00:00:00", "repo_name": "reactos/reactos", "stars": 13852, "license": "gpl-2.0", "language": "c", "size": 632043}
{"docstring": "/* Parse a delta co-ordinate in polyline/polygon order form */\n", "func_signal": "static int\nparse_delta(uint8 * buffer, int *offset)", "code": "{\n\tint value = buffer[(*offset)++];\n\tint two_byte = value & 0x80;\n\n\tif (value & 0x40)\t/* sign bit */\n\t\tvalue |= ~0x3f;\n\telse\n\t\tvalue &= 0x3f;\n\n\tif (two_byte)\n\t\tvalue = (value << 8) | buffer[(*offset)++];\n\n\treturn value;\n}", "path": "reactos/base/applications/mstsc/orders.c", "commit_date": "2017-10-03 00:00:00", "repo_name": "reactos/reactos", "stars": 13852, "license": "gpl-2.0", "language": "c", "size": 632043}
{"docstring": "/* Process a brush cache order */\n", "func_signal": "static void\nprocess_brushcache(STREAM s, uint16 flags)", "code": "{\n\tBRUSHDATA brush_data;\n\tuint8 cache_idx, colour_code, width, height, size, type;\n\tuint8 *comp_brush;\n\tint index;\n\tint Bpp;\n\n\tin_uint8(s, cache_idx);\n\tin_uint8(s, colour_code);\n\tin_uint8(s, width);\n\tin_uint8(s, height);\n\tin_uint8(s, type);\t/* type, 0x8x = cached */\n\tin_uint8(s, size);\n\n\tDEBUG((\"BRUSHCACHE(idx=%d,wd=%d,ht=%d,sz=%d)\\n\", cache_idx, width, height, size));\n\n\tif ((width == 8) && (height == 8))\n\t{\n\t\tif (colour_code == 1)\n\t\t{\n\t\t\tbrush_data.colour_code = 1;\n\t\t\tbrush_data.data_size = 8;\n\t\t\tbrush_data.data = xmalloc(8);\n\t\t\tif (size == 8)\n\t\t\t{\n\t\t\t\t/* read it bottom up */\n\t\t\t\tfor (index = 7; index >= 0; index--)\n\t\t\t\t{\n\t\t\t\t\tin_uint8(s, brush_data.data[index]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twarning(\"incompatible brush, colour_code %d size %d\\n\", colour_code,\n\t\t\t\t\tsize);\n\t\t\t}\n\t\t\tcache_put_brush_data(1, cache_idx, &brush_data);\n\t\t}\n\t\telse if ((colour_code >= 3) && (colour_code <= 6))\n\t\t{\n\t\t\tBpp = colour_code - 2;\n\t\t\tbrush_data.colour_code = colour_code;\n\t\t\tbrush_data.data_size = 8 * 8 * Bpp;\n\t\t\tbrush_data.data = xmalloc(8 * 8 * Bpp);\n\t\t\tif (size == 16 + 4 * Bpp)\n\t\t\t{\n\t\t\t\tin_uint8p(s, comp_brush, 16 + 4 * Bpp);\n\t\t\t\tprocess_compressed_8x8_brush_data(comp_brush, brush_data.data, Bpp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tin_uint8a(s, brush_data.data, 8 * 8 * Bpp);\n\t\t\t}\n\t\t\tcache_put_brush_data(colour_code, cache_idx, &brush_data);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twarning(\"incompatible brush, colour_code %d size %d\\n\", colour_code, size);\n\t\t}\n\t}\n\telse\n\t{\n\t\twarning(\"incompatible brush, width height %d %d\\n\", width, height);\n\t}\n\tif (type) {}\n}", "path": "reactos/base/applications/mstsc/orders.c", "commit_date": "2017-10-03 00:00:00", "repo_name": "reactos/reactos", "stars": 13852, "license": "gpl-2.0", "language": "c", "size": 632043}
{"docstring": "/* Process a text order */\n", "func_signal": "static void\nprocess_text2(STREAM s, TEXT2_ORDER * os, uint32 present, RD_BOOL delta)", "code": "{\n\tint i;\n\tBRUSH brush;\n\n\tif (present & 0x000001)\n\t\tin_uint8(s, os->font);\n\n\tif (present & 0x000002)\n\t\tin_uint8(s, os->flags);\n\n\tif (present & 0x000004)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x000008)\n\t\tin_uint8(s, os->mixmode);\n\n\tif (present & 0x000010)\n\t\trdp_in_colour(s, &os->fgcolour);\n\n\tif (present & 0x000020)\n\t\trdp_in_colour(s, &os->bgcolour);\n\n\tif (present & 0x000040)\n\t\tin_uint16_le(s, os->clipleft);\n\n\tif (present & 0x000080)\n\t\tin_uint16_le(s, os->cliptop);\n\n\tif (present & 0x000100)\n\t\tin_uint16_le(s, os->clipright);\n\n\tif (present & 0x000200)\n\t\tin_uint16_le(s, os->clipbottom);\n\n\tif (present & 0x000400)\n\t\tin_uint16_le(s, os->boxleft);\n\n\tif (present & 0x000800)\n\t\tin_uint16_le(s, os->boxtop);\n\n\tif (present & 0x001000)\n\t\tin_uint16_le(s, os->boxright);\n\n\tif (present & 0x002000)\n\t\tin_uint16_le(s, os->boxbottom);\n\n\trdp_parse_brush(s, &os->brush, present >> 14);\n\n\tif (present & 0x080000)\n\t\tin_uint16_le(s, os->x);\n\n\tif (present & 0x100000)\n\t\tin_uint16_le(s, os->y);\n\n\tif (present & 0x200000)\n\t{\n\t\tin_uint8(s, os->length);\n\t\tin_uint8a(s, os->text, os->length);\n\t}\n\n\tDEBUG((\"TEXT2(x=%d,y=%d,cl=%d,ct=%d,cr=%d,cb=%d,bl=%d,bt=%d,br=%d,bb=%d,bs=%d,bg=0x%x,fg=0x%x,font=%d,fl=0x%x,op=0x%x,mix=%d,n=%d)\\n\", os->x, os->y, os->clipleft, os->cliptop, os->clipright, os->clipbottom, os->boxleft, os->boxtop, os->boxright, os->boxbottom, os->brush.style, os->bgcolour, os->fgcolour, os->font, os->flags, os->opcode, os->mixmode, os->length));\n\n\tDEBUG((\"Text: \"));\n\n\tfor (i = 0; i < os->length; i++)\n\t\tDEBUG((\"%02x \", os->text[i]));\n\n\tDEBUG((\"\\n\"));\n\n\tsetup_brush(&brush, &os->brush);\n\n\tui_draw_text(os->font, os->flags, os->opcode - 1, os->mixmode, os->x, os->y,\n\t\t     os->clipleft, os->cliptop, os->clipright - os->clipleft,\n\t\t     os->clipbottom - os->cliptop, os->boxleft, os->boxtop,\n\t\t     os->boxright - os->boxleft, os->boxbottom - os->boxtop,\n\t\t     &brush, os->bgcolour, os->fgcolour, os->text, os->length);\n}", "path": "reactos/base/applications/mstsc/orders.c", "commit_date": "2017-10-03 00:00:00", "repo_name": "reactos/reactos", "stars": 13852, "license": "gpl-2.0", "language": "c", "size": 632043}
{"docstring": "/* Process a bitmap cache order */\n", "func_signal": "static void\nprocess_bmpcache(STREAM s)", "code": "{\n\tRD_HBITMAP bitmap;\n\tuint16 cache_idx, size;\n\tuint8 cache_id, width, height, bpp, Bpp;\n\tuint8 *data, *bmpdata;\n\tuint16 bufsize, pad2, row_size, final_size;\n\tuint8 pad1;\n\n\tpad2 = row_size = final_size = 0xffff;\t/* Shut the compiler up */\n\n\tin_uint8(s, cache_id);\n\tin_uint8(s, pad1);\t/* pad */\n\tin_uint8(s, width);\n\tin_uint8(s, height);\n\tin_uint8(s, bpp);\n\tBpp = (bpp + 7) / 8;\n\tin_uint16_le(s, bufsize);\t/* bufsize */\n\tin_uint16_le(s, cache_idx);\n\n\tif (g_rdp_version >= RDP_V5)\n\t{\n\t\tsize = bufsize;\n\t}\n\telse\n\t{\n\n\t\t/* Begin compressedBitmapData */\n\t\tin_uint16_le(s, pad2);\t/* pad */\n\t\tin_uint16_le(s, size);\n\t\t/*      in_uint8s(s, 4);  *//* row_size, final_size */\n\t\tin_uint16_le(s, row_size);\n\t\tin_uint16_le(s, final_size);\n\n\t}\n\tin_uint8p(s, data, size);\n\n\tDEBUG((\"BMPCACHE(cx=%d,cy=%d,id=%d,idx=%d,bpp=%d,size=%d,pad1=%d,bufsize=%d,pad2=%d,rs=%d,fs=%d)\\n\", width, height, cache_id, cache_idx, bpp, size, pad1, bufsize, pad2, row_size, final_size));\n\n\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\n\tif (bitmap_decompress(bmpdata, width, height, data, size, Bpp))\n\t{\n\t\tbitmap = ui_create_bitmap(width, height, bmpdata);\n\t\tcache_put_bitmap(cache_id, cache_idx, bitmap);\n\t}\n\telse\n\t{\n\t\tDEBUG((\"Failed to decompress bitmap data\\n\"));\n\t}\n\tif (pad1 || pad2) {}\n\n\txfree(bmpdata);\n}", "path": "reactos/base/applications/mstsc/orders.c", "commit_date": "2017-10-03 00:00:00", "repo_name": "reactos/reactos", "stars": 13852, "license": "gpl-2.0", "language": "c", "size": 632043}
{"docstring": "/* Process a pattern blt order */\n", "func_signal": "static void\nprocess_patblt(STREAM s, PATBLT_ORDER * os, uint32 present, RD_BOOL delta)", "code": "{\n\tBRUSH brush;\n\n\tif (present & 0x0001)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x0002)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x0004)\n\t\trdp_in_coord(s, &os->cx, delta);\n\n\tif (present & 0x0008)\n\t\trdp_in_coord(s, &os->cy, delta);\n\n\tif (present & 0x0010)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x0020)\n\t\trdp_in_colour(s, &os->bgcolour);\n\n\tif (present & 0x0040)\n\t\trdp_in_colour(s, &os->fgcolour);\n\n\trdp_parse_brush(s, &os->brush, present >> 7);\n\n\tDEBUG((\"PATBLT(op=0x%x,x=%d,y=%d,cx=%d,cy=%d,bs=%d,bg=0x%x,fg=0x%x)\\n\", os->opcode, os->x,\n\t       os->y, os->cx, os->cy, os->brush.style, os->bgcolour, os->fgcolour));\n\n\tsetup_brush(&brush, &os->brush);\n\n\tui_patblt(ROP2_P(os->opcode), os->x, os->y, os->cx, os->cy,\n\t\t  &brush, os->bgcolour, os->fgcolour);\n}", "path": "reactos/base/applications/mstsc/orders.c", "commit_date": "2017-10-03 00:00:00", "repo_name": "reactos/reactos", "stars": 13852, "license": "gpl-2.0", "language": "c", "size": 632043}
{"docstring": "/* Parse a pen */\n", "func_signal": "static RD_BOOL\nrdp_parse_pen(STREAM s, PEN * pen, uint32 present)", "code": "{\n\tif (present & 1)\n\t\tin_uint8(s, pen->style);\n\n\tif (present & 2)\n\t\tin_uint8(s, pen->width);\n\n\tif (present & 4)\n\t\trdp_in_colour(s, &pen->colour);\n\n\treturn s_check(s);\n}", "path": "reactos/base/applications/mstsc/orders.c", "commit_date": "2017-10-03 00:00:00", "repo_name": "reactos/reactos", "stars": 13852, "license": "gpl-2.0", "language": "c", "size": 632043}
{"docstring": "/* Read a colour entry */\n", "func_signal": "static void\nrdp_in_colour(STREAM s, uint32 * colour)", "code": "{\n\tuint32 i;\n\tin_uint8(s, i);\n\t*colour = i;\n\tin_uint8(s, i);\n\t*colour |= i << 8;\n\tin_uint8(s, i);\n\t*colour |= i << 16;\n}", "path": "reactos/base/applications/mstsc/orders.c", "commit_date": "2017-10-03 00:00:00", "repo_name": "reactos/reactos", "stars": 13852, "license": "gpl-2.0", "language": "c", "size": 632043}
{"docstring": "/* Process a font cache order */\n", "func_signal": "static void\nprocess_fontcache(STREAM s)", "code": "{\n\tRD_HGLYPH bitmap;\n\tuint8 font, nglyphs;\n\tuint16 character, offset, baseline, width, height;\n\tint i, datasize;\n\tuint8 *data;\n\n\tin_uint8(s, font);\n\tin_uint8(s, nglyphs);\n\n\tDEBUG((\"FONTCACHE(font=%d,n=%d)\\n\", font, nglyphs));\n\n\tfor (i = 0; i < nglyphs; i++)\n\t{\n\t\tin_uint16_le(s, character);\n\t\tin_uint16_le(s, offset);\n\t\tin_uint16_le(s, baseline);\n\t\tin_uint16_le(s, width);\n\t\tin_uint16_le(s, height);\n\n\t\tdatasize = (height * ((width + 7) / 8) + 3) & ~3;\n\t\tin_uint8p(s, data, datasize);\n\n\t\tbitmap = ui_create_glyph(width, height, data);\n\t\tcache_put_font(font, character, offset, baseline, width, height, bitmap);\n\t}\n}", "path": "reactos/base/applications/mstsc/orders.c", "commit_date": "2017-10-03 00:00:00", "repo_name": "reactos/reactos", "stars": 13852, "license": "gpl-2.0", "language": "c", "size": 632043}
{"docstring": "/* Process a screen blt order */\n", "func_signal": "static void\nprocess_screenblt(STREAM s, SCREENBLT_ORDER * os, uint32 present, RD_BOOL delta)", "code": "{\n\tif (present & 0x0001)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x0002)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x0004)\n\t\trdp_in_coord(s, &os->cx, delta);\n\n\tif (present & 0x0008)\n\t\trdp_in_coord(s, &os->cy, delta);\n\n\tif (present & 0x0010)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x0020)\n\t\trdp_in_coord(s, &os->srcx, delta);\n\n\tif (present & 0x0040)\n\t\trdp_in_coord(s, &os->srcy, delta);\n\n\tDEBUG((\"SCREENBLT(op=0x%x,x=%d,y=%d,cx=%d,cy=%d,srcx=%d,srcy=%d)\\n\",\n\t       os->opcode, os->x, os->y, os->cx, os->cy, os->srcx, os->srcy));\n\n\tui_screenblt(ROP2_S(os->opcode), os->x, os->y, os->cx, os->cy, os->srcx, os->srcy);\n}", "path": "reactos/base/applications/mstsc/orders.c", "commit_date": "2017-10-03 00:00:00", "repo_name": "reactos/reactos", "stars": 13852, "license": "gpl-2.0", "language": "c", "size": 632043}
{"docstring": "/*\n** free all CallInfo structures not in use by a thread\n*/\n", "func_signal": "void luaE_freeCI (lua_State *L)", "code": "{\n  CallInfo *ci = L->ci;\n  CallInfo *next = ci->next;\n  ci->next = NULL;\n  while ((ci = next) != NULL) {\n    next = ci->next;\n    luaM_free(L, ci);\n    L->nci--;\n  }\n}", "path": "skynet/3rd/lua/lstate.c", "commit_date": "2020-11-04 00:00:00", "repo_name": "cloudwu/skynet", "stars": 12631, "license": "mit", "language": "c", "size": 4752}
{"docstring": "/*\n** Called when 'getCcalls(L)' larger or equal to LUAI_MAXCCALLS.\n** If equal, raises an overflow error. If value is larger than\n** LUAI_MAXCCALLS (which means it is handling an overflow) but\n** not much larger, does not report an error (to allow overflow\n** handling to work).\n*/\n", "func_signal": "void luaE_checkcstack (lua_State *L)", "code": "{\n  if (getCcalls(L) == LUAI_MAXCCALLS)\n    luaG_runerror(L, \"C stack overflow\");\n  else if (getCcalls(L) >= (LUAI_MAXCCALLS / 10 * 11))\n    luaD_throw(L, LUA_ERRERR);  /* error while handing stack error */\n}", "path": "skynet/3rd/lua/lstate.c", "commit_date": "2020-11-04 00:00:00", "repo_name": "cloudwu/skynet", "stars": 12631, "license": "mit", "language": "c", "size": 4752}
{"docstring": "/*\n** creates a new string object\n*/\n", "func_signal": "static TString *createstrobj (lua_State *L, size_t l, int tag, unsigned int h)", "code": "{\n  TString *ts;\n  GCObject *o;\n  size_t totalsize;  /* total size of TString object */\n  totalsize = sizelstring(l);\n  o = luaC_newobj(L, tag, totalsize);\n  ts = gco2ts(o);\n  ts->hash = h;\n  ts->extra = 0;\n  ts->id = 0;\n  getstr(ts)[l] = '\\0';  /* ending 0 */\n  return ts;\n}", "path": "skynet/3rd/lua/lstring.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "cloudwu/skynet", "stars": 12631, "license": "mit", "language": "c", "size": 4752}
{"docstring": "/*\n** Pushes on the stack a string with given length. Avoid using 's' when\n** 'len' == 0 (as 's' can be NULL in that case), due to later use of\n** 'memcmp' and 'memcpy'.\n*/\n", "func_signal": "LUA_API const char *lua_pushlstring (lua_State *L, const char *s, size_t len)", "code": "{\n  TString *ts;\n  lua_lock(L);\n  ts = (len == 0) ? luaS_new(L, \"\") : luaS_newlstr(L, s, len);\n  setsvalue2s(L, L->top, ts);\n  api_incr_top(L);\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return getstr(ts);\n}", "path": "skynet/3rd/lua/lapi.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "cloudwu/skynet", "stars": 12631, "license": "mit", "language": "c", "size": 4752}
{"docstring": "/*\n** new string (with explicit length)\n*/\n", "func_signal": "TString *luaS_newlstr (lua_State *L, const char *str, size_t l)", "code": "{\n  if (l <= LUAI_MAXSHORTLEN)  /* short string? */\n    return internshrstr(L, str, l);\n  else {\n    TString *ts;\n    if (unlikely(l >= (MAX_SIZE - sizeof(TString))/sizeof(char)))\n      luaM_toobig(L);\n    ts = luaS_createlngstrobj(L, l);\n    memcpy(getstr(ts), str, l * sizeof(char));\n    return ts;\n  }\n}", "path": "skynet/3rd/lua/lstring.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "cloudwu/skynet", "stars": 12631, "license": "mit", "language": "c", "size": 4752}
{"docstring": "/*\n** open parts of the state that may cause memory-allocation errors.\n** ('g->nilvalue' being a nil value flags that the state was completely\n** build.)\n*/\n", "func_signal": "static void f_luaopen (lua_State *L, void *ud)", "code": "{\n  global_State *g = G(L);\n  UNUSED(ud);\n  stack_init(L, L);  /* init stack */\n  init_registry(L, g);\n  luaS_init(L);\n  luaT_init(L);\n  luaX_init(L);\n  g->gcrunning = 1;  /* allow gc */\n  setnilvalue(&g->nilvalue);\n  luai_userstateopen(L);\n}", "path": "skynet/3rd/lua/lstate.c", "commit_date": "2020-11-04 00:00:00", "repo_name": "cloudwu/skynet", "stars": 12631, "license": "mit", "language": "c", "size": 4752}
{"docstring": "/*\n** Initialize the string table and the string cache\n*/\n", "func_signal": "void luaS_init (lua_State *L)", "code": "{\n  global_State *g = G(L);\n  int i, j;\n  if (STRSEED == 0) {\n    STRSEED = luai_makeseed(L);\n  }\n  stringtable *tb = &G(L)->strt;\n  tb->hash = luaM_newvector(L, MINSTRTABSIZE, TString*);\n  tablerehash(tb->hash, 0, MINSTRTABSIZE);  /* clear array */\n  tb->size = MINSTRTABSIZE;\n  /* pre-create memory-error message */\n  g->memerrmsg = luaS_newliteral(L, MEMERRMSG);\n  luaC_fix(L, obj2gco(g->memerrmsg));  /* it should never be collected */\n  for (i = 0; i < STRCACHE_N; i++)  /* fill cache with valid strings */\n    for (j = 0; j < STRCACHE_M; j++)\n      g->strcache[i][j] = g->memerrmsg;\n}", "path": "skynet/3rd/lua/lstring.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "cloudwu/skynet", "stars": 12631, "license": "mit", "language": "c", "size": 4752}
{"docstring": "/*\n** Returns a pointer to the internal representation of an object.\n** Note that ANSI C does not allow the conversion of a pointer to\n** function to a 'void*', so the conversion here goes through\n** a 'size_t'. (As the returned pointer is only informative, this\n** conversion should not be a problem.)\n*/\n", "func_signal": "LUA_API const void *lua_topointer (lua_State *L, int idx)", "code": "{\n  const TValue *o = index2value(L, idx);\n  switch (ttypetag(o)) {\n    case LUA_VLCF: return cast_voidp(cast_sizet(fvalue(o)));\n    case LUA_VUSERDATA: case LUA_VLIGHTUSERDATA:\n      return touserdata(o);\n    default: {\n      if (iscollectable(o))\n        return gcvalue(o);\n      else\n        return NULL;\n    }\n  }\n}", "path": "skynet/3rd/lua/lapi.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "cloudwu/skynet", "stars": 12631, "license": "mit", "language": "c", "size": 4752}
{"docstring": "/*\n** Resize the string table. If allocation fails, keep the current size.\n** (This can degrade performance, but any non-zero size should work\n** correctly.)\n*/\n", "func_signal": "void luaS_resize (lua_State *L, int nsize)", "code": "{\n  stringtable *tb = &G(L)->strt;\n  int osize = tb->size;\n  TString **newvect;\n  if (nsize < osize)  /* shrinking table? */\n    tablerehash(tb->hash, osize, nsize);  /* depopulate shrinking part */\n  newvect = luaM_reallocvector(L, tb->hash, osize, nsize, TString*);\n  if (unlikely(newvect == NULL)) {  /* reallocation failed? */\n    if (nsize < osize)  /* was it shrinking table? */\n      tablerehash(tb->hash, nsize, osize);  /* restore to original size */\n    /* leave table as it was */\n  }\n  else {  /* allocation succeeded */\n    tb->hash = newvect;\n    tb->size = nsize;\n    if (nsize > osize)\n      tablerehash(newvect, osize, nsize);  /* rehash for new size */\n  }\n}", "path": "skynet/3rd/lua/lstring.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "cloudwu/skynet", "stars": 12631, "license": "mit", "language": "c", "size": 4752}
{"docstring": "/*\n** Checks whether short string exists and reuses it or creates a new one.\n*/\n", "func_signal": "static TString *internshrstr (lua_State *L, const char *str, size_t l)", "code": "{\n  TString *ts;\n  global_State *g = G(L);\n  stringtable *tb = &g->strt;\n  unsigned int h = luaS_hash(str, l, STRSEED);\n  TString **list = &tb->hash[lmod(h, tb->size)];\n  lua_assert(str != NULL);  /* otherwise 'memcmp'/'memcpy' are undefined */\n  for (ts = *list; ts != NULL; ts = ts->u.hnext) {\n    if (l == ts->shrlen && (memcmp(str, getstr(ts), l * sizeof(char)) == 0)) {\n      /* found! */\n      if (isdead(g, ts))  /* dead (but not collected yet)? */\n        changewhite(ts);  /* resurrect it */\n      return ts;\n    }\n  }\n  /* else must create a new string */\n  if (tb->nuse >= tb->size) {  /* need to grow string table? */\n    growstrtab(L, tb);\n    list = &tb->hash[lmod(h, tb->size)];  /* rehash with new size */\n  }\n  ts = createstrobj(L, l, LUA_VSHRSTR, h);\n  memcpy(getstr(ts), str, l * sizeof(char));\n  ts->shrlen = cast_byte(l);\n  ts->u.hnext = *list;\n  *list = ts;\n  tb->nuse++;\n  return ts;\n}", "path": "skynet/3rd/lua/lstring.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "cloudwu/skynet", "stars": 12631, "license": "mit", "language": "c", "size": 4752}
{"docstring": "/*\n** miscellaneous functions\n*/\n", "func_signal": "LUA_API int lua_error (lua_State *L)", "code": "{\n  TValue *errobj;\n  lua_lock(L);\n  errobj = s2v(L->top - 1);\n  api_checknelems(L, 1);\n  /* error object is the memory error message? */\n  if (ttisshrstring(errobj) && eqshrstr(tsvalue(errobj), G(L)->memerrmsg))\n    luaM_error(L);  /* raise a memory error */\n  else\n    luaG_errormsg(L);  /* raise a regular error */\n  /* code unreachable; will unlock when control actually leaves the kernel */\n  return 0;  /* to avoid warnings */\n}", "path": "skynet/3rd/lua/lapi.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "cloudwu/skynet", "stars": 12631, "license": "mit", "language": "c", "size": 4752}
{"docstring": "/*\n** free half of the CallInfo structures not in use by a thread,\n** keeping the first one.\n*/\n", "func_signal": "void luaE_shrinkCI (lua_State *L)", "code": "{\n  CallInfo *ci = L->ci->next;  /* first free CallInfo */\n  CallInfo *next;\n  if (ci == NULL)\n    return;  /* no extra elements */\n  while ((next = ci->next) != NULL) {  /* two extra elements? */\n    CallInfo *next2 = next->next;  /* next's next */\n    ci->next = next2;  /* remove next from the list */\n    L->nci--;\n    luaM_free(L, next);  /* free next */\n    if (next2 == NULL)\n      break;  /* no more elements */\n    else {\n      next2->previous = ci;\n      ci = next2;  /* continue */\n    }\n  }\n}", "path": "skynet/3rd/lua/lstate.c", "commit_date": "2020-11-04 00:00:00", "repo_name": "cloudwu/skynet", "stars": 12631, "license": "mit", "language": "c", "size": 4752}
{"docstring": "/*\n** push functions (C -> stack)\n*/\n", "func_signal": "LUA_API void lua_pushnil (lua_State *L)", "code": "{\n  lua_lock(L);\n  setnilvalue(s2v(L->top));\n  api_incr_top(L);\n  lua_unlock(L);\n}", "path": "skynet/3rd/lua/lapi.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "cloudwu/skynet", "stars": 12631, "license": "mit", "language": "c", "size": 4752}
{"docstring": "/*\n** Clear API string cache. (Entries cannot be empty, so fill them with\n** a non-collectable string.)\n*/\n", "func_signal": "void luaS_clearcache (global_State *g)", "code": "{\n  int i, j;\n  for (i = 0; i < STRCACHE_N; i++)\n    for (j = 0; j < STRCACHE_M; j++) {\n      if (iswhite(g->strcache[i][j]))  /* will entry be collected? */\n        g->strcache[i][j] = g->memerrmsg;  /* replace it with something fixed */\n    }\n}", "path": "skynet/3rd/lua/lstring.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "cloudwu/skynet", "stars": 12631, "license": "mit", "language": "c", "size": 4752}
{"docstring": "/*\n** access functions (stack -> C)\n*/\n", "func_signal": "LUA_API int lua_type (lua_State *L, int idx)", "code": "{\n  const TValue *o = index2value(L, idx);\n  return (isvalid(L, o) ? ttype(o) : LUA_TNONE);\n}", "path": "skynet/3rd/lua/lapi.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "cloudwu/skynet", "stars": 12631, "license": "mit", "language": "c", "size": 4752}
{"docstring": "/*\n** preinitialize a thread with consistent values without allocating\n** any memory (to avoid errors)\n*/\n", "func_signal": "static void preinit_thread (lua_State *L, global_State *g)", "code": "{\n  G(L) = g;\n  L->stack = NULL;\n  L->ci = NULL;\n  L->nci = 0;\n  L->twups = L;  /* thread has no upvalues */\n  L->errorJmp = NULL;\n  L->hook = NULL;\n  L->hookmask = 0;\n  L->basehookcount = 0;\n  L->allowhook = 1;\n  resethookcount(L);\n  L->openupval = NULL;\n  L->status = LUA_OK;\n  L->errfunc = 0;\n  L->oldpc = 0;\n}", "path": "skynet/3rd/lua/lstate.c", "commit_date": "2020-11-04 00:00:00", "repo_name": "cloudwu/skynet", "stars": 12631, "license": "mit", "language": "c", "size": 4752}
{"docstring": "/*\n** t[k] = value at the top of the stack (where 'k' is a string)\n*/\n", "func_signal": "static void auxsetstr (lua_State *L, const TValue *t, const char *k)", "code": "{\n  const TValue *slot;\n  TString *str = luaS_new(L, k);\n  api_checknelems(L, 1);\n  if (luaV_fastset(L, t, str, slot, luaH_getstr)) {\n    luaV_finishfastset(L, t, slot, s2v(L->top - 1));\n    L->top--;  /* pop value */\n  }\n  else {\n    setsvalue2s(L, L->top, str);  /* push 'str' (to make it a TValue) */\n    api_incr_top(L);\n    luaV_finishset(L, t, s2v(L->top - 1), s2v(L->top - 2), slot);\n    L->top -= 2;  /* pop value and key */\n  }\n  lua_unlock(L);  /* lock done by caller */\n}", "path": "skynet/3rd/lua/lapi.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "cloudwu/skynet", "stars": 12631, "license": "mit", "language": "c", "size": 4752}
{"docstring": "/*\n** Generate a warning from an error message\n*/\n", "func_signal": "void luaE_warnerror (lua_State *L, const char *where)", "code": "{\n  TValue *errobj = s2v(L->top - 1);  /* error object */\n  const char *msg = (ttisstring(errobj))\n                  ? svalue(errobj)\n                  : \"error object is not a string\";\n  /* produce warning \"error in %s (%s)\" (where, msg) */\n  luaE_warning(L, \"error in \", 1);\n  luaE_warning(L, where, 1);\n  luaE_warning(L, \" (\", 1);\n  luaE_warning(L, msg, 1);\n  luaE_warning(L, \")\", 0);\n}", "path": "skynet/3rd/lua/lstate.c", "commit_date": "2020-11-04 00:00:00", "repo_name": "cloudwu/skynet", "stars": 12631, "license": "mit", "language": "c", "size": 4752}
{"docstring": "/*\n** convert an acceptable stack index into an absolute index\n*/\n", "func_signal": "LUA_API int lua_absindex (lua_State *L, int idx)", "code": "{\n  return (idx > 0 || ispseudo(idx))\n         ? idx\n         : cast_int(L->top - L->ci->func) + idx;\n}", "path": "skynet/3rd/lua/lapi.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "cloudwu/skynet", "stars": 12631, "license": "mit", "language": "c", "size": 4752}
{"docstring": "/*\n** get functions (Lua -> stack)\n*/\n", "func_signal": "static int auxgetstr (lua_State *L, const TValue *t, const char *k)", "code": "{\n  const TValue *slot;\n  TString *str = luaS_new(L, k);\n  if (luaV_fastget(L, t, str, slot, luaH_getstr)) {\n    setobj2s(L, L->top, slot);\n    api_incr_top(L);\n  }\n  else {\n    setsvalue2s(L, L->top, str);\n    api_incr_top(L);\n    luaV_finishget(L, t, s2v(L->top - 1), L->top - 1, slot);\n  }\n  lua_unlock(L);\n  return ttype(s2v(L->top - 1));\n}", "path": "skynet/3rd/lua/lapi.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "cloudwu/skynet", "stars": 12631, "license": "mit", "language": "c", "size": 4752}
{"docstring": "/**\n * vips_tracked_free:\n * @s: (transfer full): memory to free\n *\n * Only use it to free\n * memory that was previously allocated with vips_tracked_malloc() with a \n * %NULL first argument.\n *\n * See also: vips_tracked_malloc().\n */\n", "func_signal": "void\nvips_tracked_free( void *s )", "code": "{\n\t/* Keep the size of the alloc in the previous 16 bytes. Ensures\n\t * alignment rules are kept.\n\t */\n\tvoid *start = (void *) ((char *) s - 16);\n\tsize_t size = *((size_t *) start);\n\n\tg_mutex_lock( vips_tracked_mutex );\n\n#ifdef DEBUG_VERBOSE\n\tprintf( \"vips_tracked_free: %p, %zd bytes\\n\", s, size ); \n#endif /*DEBUG_VERBOSE*/\n\n\tif( vips_tracked_allocs <= 0 ) \n\t\tg_warning( \"%s\", _( \"vips_free: too many frees\" ) );\n\tif( vips_tracked_mem < size )\n\t\tg_warning( \"%s\", _( \"vips_free: too much free\" ) );\n\n\tvips_tracked_mem -= size;\n\tvips_tracked_allocs -= 1;\n\n\tg_mutex_unlock( vips_tracked_mutex );\n\n\tg_free( start );\n\n\tVIPS_GATE_FREE( size ); \n}", "path": "libvips/libvips/iofuncs/memory.c", "commit_date": "2020-07-04 00:00:00", "repo_name": "libvips/libvips", "stars": 8851, "license": "lgpl-2.1", "language": "c", "size": 93246}
{"docstring": "/* What cmsColorSpaceSignature do we expect this image to be (roughly) after \n * preprocessing. Again, fragile :( see the FIXME above.\n */\n", "func_signal": "static cmsColorSpaceSignature\nvips_image_expected_sig( VipsImage *image )", "code": "{\n\tcmsColorSpaceSignature expected_sig;\n\n\tswitch( image->Type ) { \n\tcase VIPS_INTERPRETATION_B_W:\n\tcase VIPS_INTERPRETATION_GREY16:\n\t\texpected_sig = cmsSigGrayData;\n\t\tbreak;\n\n\tcase VIPS_INTERPRETATION_LAB:\n\tcase VIPS_INTERPRETATION_LABQ:\n\tcase VIPS_INTERPRETATION_LABS:\n\t\texpected_sig = cmsSigLabData;\n\t\tbreak;\n\n\tcase VIPS_INTERPRETATION_sRGB:\n\tcase VIPS_INTERPRETATION_RGB:\n\tcase VIPS_INTERPRETATION_RGB16:\n\tcase VIPS_INTERPRETATION_scRGB:\n\t\texpected_sig = cmsSigRgbData;\n\t\tbreak;\n\n\tcase VIPS_INTERPRETATION_XYZ:\n\t\texpected_sig = cmsSigXYZData;\n\t\tbreak;\n\n\tcase VIPS_INTERPRETATION_CMYK:\n\t\texpected_sig = cmsSigCmykData;\n\t\tbreak;\n\n\tcase VIPS_INTERPRETATION_HSV:\n\t\texpected_sig = cmsSigHsvData;\n\t\tbreak;\n\n\tcase VIPS_INTERPRETATION_YXY:\n\t\texpected_sig = cmsSigYxyData;\n\t\tbreak;\n\n\tcase VIPS_INTERPRETATION_MULTIBAND:\n\t\t/* A generic many-band image. Try to guess from the number of \n\t\t * image bands instead.\n\t\t */\n\t\tswitch( image->Bands ) {\n\t\tcase 1:\n\t\tcase 2:\n\t\t\texpected_sig = cmsSigGrayData;\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\texpected_sig = cmsSigRgbData;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\tcase 5:\n\t\t\texpected_sig = cmsSigCmykData;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\texpected_sig = -1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase VIPS_INTERPRETATION_LCH:\n\tcase VIPS_INTERPRETATION_CMC:\n\tcase VIPS_INTERPRETATION_HISTOGRAM:\n\tcase VIPS_INTERPRETATION_MATRIX:\n\tcase VIPS_INTERPRETATION_FOURIER:\n\tdefault:\n\t\texpected_sig = -1;\n\t\tbreak;\n\t}\n\n\treturn( expected_sig );\n}", "path": "libvips/libvips/colour/icc_transform.c", "commit_date": "2019-12-22 00:00:00", "repo_name": "libvips/libvips", "stars": 8851, "license": "lgpl-2.1", "language": "c", "size": 93246}
{"docstring": "/* Pack a buffer of floats into lcms's fixed-point formats. Cut from\n * lcms-1.0.8.\n */\n", "func_signal": "static void \nencode_lab( float *lab, guint16 *fixed, int n )", "code": "{\n\tint i;\n\n\tfor( i = 0; i < n; i++ ) {\n\t\tfloat L = lab[0];\n\t\tfloat a = lab[1];\n\t\tfloat b = lab[2];\n\n\t\tif( L < 0 ) \n\t\t\tL = 0;\n\t\tif( L > 100. ) \n\t\t\tL = 100.;\n\n\t\tif( a < -128. ) \n\t\t\ta = -128;\n\t\tif( a > 127.9961 ) \n\t\t\ta = 127.9961;\n\t\tif( b < -128. ) \n\t\t\tb = -128;\n\t\tif( b > 127.9961 ) \n\t\t\tb = 127.9961;\n\n\t\tfixed[0] = L *  652.800 + 0.5;\n\t\tfixed[1] = (a + 128.0) * 256.0 + 0.5;\n\t\tfixed[2] = (b + 128.0) * 256.0 + 0.5;\n\n\t\tlab += 3;\n\t\tfixed += 3;\n\t}\n}", "path": "libvips/libvips/colour/icc_transform.c", "commit_date": "2019-12-22 00:00:00", "repo_name": "libvips/libvips", "stars": 8851, "license": "lgpl-2.1", "language": "c", "size": 93246}
{"docstring": "/**\n * vips_tracked_get_mem_highwater:\n *\n * Returns the largest number of bytes simultaneously allocated via \n * vips_tracked_malloc(). Handy for estimating max memory requirements for a\n * program.\n *\n * Returns: the largest number of currently allocated bytes\n */\n", "func_signal": "size_t\nvips_tracked_get_mem_highwater( void )", "code": "{\n\tsize_t mx;\n\n\tvips_tracked_init(); \n\n\tg_mutex_lock( vips_tracked_mutex );\n\n\tmx = vips_tracked_mem_highwater;\n\n\tg_mutex_unlock( vips_tracked_mutex );\n\n\treturn( mx );\n}", "path": "libvips/libvips/iofuncs/memory.c", "commit_date": "2020-07-04 00:00:00", "repo_name": "libvips/libvips", "stars": 8851, "license": "lgpl-2.1", "language": "c", "size": 93246}
{"docstring": "/**\n * vips_hist_ismonotonic: (method)\n * @in: lookup-table to test\n * @out: (out): set non-zero if @in is monotonic\n * @...: %NULL-terminated list of optional named arguments\n *\n * Test @in for monotonicity. @out is set non-zero if @in is monotonic.\n *\n * Returns: 0 on success, -1 on error\n */\n", "func_signal": "int \nvips_hist_ismonotonic( VipsImage *in, gboolean *out, ... )", "code": "{\n\tva_list ap;\n\tint result;\n\n\tva_start( ap, out );\n\tresult = vips_call_split( \"hist_ismonotonic\", ap, in, out );\n\tva_end( ap );\n\n\treturn( result );\n}", "path": "libvips/libvips/histogram/hist_ismonotonic.c", "commit_date": "2017-09-30 00:00:00", "repo_name": "libvips/libvips", "stars": 8851, "license": "lgpl-2.1", "language": "c", "size": 93246}
{"docstring": "/**\n * vips_tracked_get_mem:\n *\n * Returns the number of bytes currently allocated via vips_malloc() and\n * friends. vips uses this figure to decide when to start dropping cache, see\n * #VipsOperation.\n *\n * Returns: the number of currently allocated bytes\n */\n", "func_signal": "size_t\nvips_tracked_get_mem( void )", "code": "{\n\tsize_t mem;\n\n\tvips_tracked_init(); \n\n\tg_mutex_lock( vips_tracked_mutex );\n\n\tmem = vips_tracked_mem;\n\n\tg_mutex_unlock( vips_tracked_mutex );\n\n\treturn( mem );\n}", "path": "libvips/libvips/iofuncs/memory.c", "commit_date": "2020-07-04 00:00:00", "repo_name": "libvips/libvips", "stars": 8851, "license": "lgpl-2.1", "language": "c", "size": 93246}
{"docstring": "/**\n * vips_icc_ac2rc: (method)\n * @in: input image\n * @out: (out): output image\n * @profile_filename: use this profile\n *\n * Transform an image from absolute to relative colorimetry using the\n * MediaWhitePoint stored in the ICC profile.\n *\n * See also: vips_icc_transform(), vips_icc_import().\n *\n * Returns: 0 on success, -1 on error.\n */\n", "func_signal": "int\nvips_icc_ac2rc( VipsImage *in, VipsImage **out, const char *profile_filename )", "code": "{\n\tVipsImage *t;\n\tcmsHPROFILE profile;\n\tcmsCIEXYZ *media;\n\tdouble X, Y, Z;\n\tdouble *add;\n\tdouble *mul;\n\tint i;\n\n\tif( !(profile = cmsOpenProfileFromFile( profile_filename, \"r\" )) )\n\t\treturn( -1 );\n\n\tif( !(media = cmsReadTag( profile, cmsSigMediaWhitePointTag )) ) {\n\t\tvips_error( \"vips_icc_ac2rc\", \n\t\t\t\"%s\", _( \"unable to get media white point\" ) );\n\t\treturn( -1 );\n\t}\n\n\tX = media->X;\n\tY = media->Y;\n\tZ = media->Z;\n\n\tcmsCloseProfile( profile );\n\n\t/* We need XYZ so we can adjust the white balance.\n\t */\n\tif( vips_colourspace( in, &t, VIPS_INTERPRETATION_XYZ, NULL ) )\n\t\treturn( -1 );\n\tin = t;\n\n\tif( !(add = VIPS_ARRAY( in, in->Bands, double )) ||\n\t\t!(mul = VIPS_ARRAY( in, in->Bands, double )) )\n\t\treturn( -1 );\n\n\t/* There might be extra bands off to the right somewhere.\n\t */\n\tfor( i = 0; i < in->Bands; i++ ) \n\t\tadd[i] = 0.0;\n\n\tmul[0] = VIPS_D50_X0 / (X * 100.0);\n\tmul[1] = VIPS_D50_Y0 / (Y * 100.0);\n\tmul[2] = VIPS_D50_Z0 / (Z * 100.0);\n\n\tfor( i = 3; i < in->Bands; i++ ) \n\t\tmul[i] = 1.0;\n\n\tif( vips_linear( in, &t, add, mul, in->Bands, NULL ) ) {\n\t\tg_object_unref( in );\n\t\treturn( -1 );\n\t}\n\tg_object_unref( in );\n\tin = t;\n\n\t*out = in;\n\n\treturn( 0 );\n}", "path": "libvips/libvips/colour/icc_transform.c", "commit_date": "2019-12-22 00:00:00", "repo_name": "libvips/libvips", "stars": 8851, "license": "lgpl-2.1", "language": "c", "size": 93246}
{"docstring": "/**\n * vips_strdup:\n * @object: (nullable): allocate memory local to this #VipsObject, or %NULL\n * @str: string to copy\n *\n * g_strdup() a string. When @object is freed, the string will be freed for\n * you.  If @object is %NULL, you need to \n * free the memory yourself with g_free().\n *\n * This function cannot fail. \n *\n * See also: vips_malloc().\n *\n * Returns: (transfer full): a pointer to the allocated memory\n */\n", "func_signal": "char *\nvips_strdup( VipsObject *object, const char *str )", "code": "{\n\tchar *str_dup;\n\n\tstr_dup = g_strdup( str );\n\n        if( object ) {\n\t\tg_signal_connect( object, \"postclose\", \n\t\t\tG_CALLBACK( vips_malloc_cb ), str_dup );\n\t\tobject->local_memory += strlen( str );\n\t}\n\n\treturn( str_dup );\n}", "path": "libvips/libvips/iofuncs/memory.c", "commit_date": "2020-07-04 00:00:00", "repo_name": "libvips/libvips", "stars": 8851, "license": "lgpl-2.1", "language": "c", "size": 93246}
{"docstring": "/**\n * vips_tracked_get_allocs:\n *\n * Returns the number of active allocations. \n *\n * Returns: the number of active allocations\n */\n", "func_signal": "int\nvips_tracked_get_allocs( void )", "code": "{\n\tint n;\n\n\tvips_tracked_init(); \n\n\tg_mutex_lock( vips_tracked_mutex );\n\n\tn = vips_tracked_allocs;\n\n\tg_mutex_unlock( vips_tracked_mutex );\n\n\treturn( n );\n}", "path": "libvips/libvips/iofuncs/memory.c", "commit_date": "2020-07-04 00:00:00", "repo_name": "libvips/libvips", "stars": 8851, "license": "lgpl-2.1", "language": "c", "size": 93246}
{"docstring": "/**\n * vips_tracked_open:\n * @pathname: name of file to open\n * @flags: flags for open()\n * @mode: open mode\n *\n * Exactly as open(2), but the number of files currently open via\n * vips_tracked_open() is available via vips_tracked_get_files(). This is used\n * by the vips operation cache to drop cache when the number of files\n * available is low.\n *\n * You must only close the file descriptor with vips_tracked_close().\n *\n * @pathname should be utf8.\n *\n * See also: vips_tracked_close(), vips_tracked_get_files().\n *\n * Returns: a file descriptor, or -1 on error.\n */\n", "func_signal": "int\nvips_tracked_open( const char *pathname, int flags, int mode )", "code": "{\n\tint fd;\n\n\tif( (fd = vips__open( pathname, flags, mode )) == -1 )\n\t\treturn( -1 );\n\n\tvips_tracked_init(); \n\n\tg_mutex_lock( vips_tracked_mutex );\n\n\tvips_tracked_files += 1;\n#ifdef DEBUG_VERBOSE\n\tprintf( \"vips_tracked_open: %s = %d (%d)\\n\", \n\t\tpathname, fd, vips_tracked_files );\n#endif /*DEBUG_VERBOSE*/\n\n\tg_mutex_unlock( vips_tracked_mutex );\n\n\treturn( fd );\n}", "path": "libvips/libvips/iofuncs/memory.c", "commit_date": "2020-07-04 00:00:00", "repo_name": "libvips/libvips", "stars": 8851, "license": "lgpl-2.1", "language": "c", "size": 93246}
{"docstring": "/**\n * vips_tracked_malloc:\n * @size: number of bytes to allocate\n *\n * Allocate an area of memory that will be tracked by vips_tracked_get_mem()\n * and friends. \n *\n * If allocation fails, vips_malloc() returns %NULL and \n * sets an error message.\n *\n * You must only free the memory returned with vips_tracked_free().\n *\n * See also: vips_tracked_free(), vips_malloc().\n *\n * Returns: (transfer full): a pointer to the allocated memory, or %NULL on error.\n */\n", "func_signal": "void *\nvips_tracked_malloc( size_t size )", "code": "{\n        void *buf;\n\n\tvips_tracked_init(); \n\n\t/* Need an extra sizeof(size_t) bytes to track \n\t * size of this block. Ask for an extra 16 to make sure we don't break\n\t * alignment rules.\n\t */\n\tsize += 16;\n\n        if( !(buf = g_try_malloc0( size )) ) {\n#ifdef DEBUG\n\t\tg_assert_not_reached();\n#endif /*DEBUG*/\n\n\t\tvips_error( \"vips_tracked\", \n\t\t\t_( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (size / (1024.0 * 1024.0))  );\n\t\tg_warning( _( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (size / (1024.0 * 1024.0))  );\n\n                return( NULL );\n\t}\n\n\tg_mutex_lock( vips_tracked_mutex );\n\n\t*((size_t *)buf) = size;\n\tbuf = (void *) ((char *)buf + 16);\n\n\tvips_tracked_mem += size;\n\tif( vips_tracked_mem > vips_tracked_mem_highwater ) \n\t\tvips_tracked_mem_highwater = vips_tracked_mem;\n\tvips_tracked_allocs += 1;\n\n#ifdef DEBUG_VERBOSE\n\tprintf( \"vips_tracked_malloc: %p, %zd bytes\\n\", buf, size ); \n#endif /*DEBUG_VERBOSE*/\n\n\tg_mutex_unlock( vips_tracked_mutex );\n\n\tVIPS_GATE_MALLOC( size ); \n\n        return( buf );\n}", "path": "libvips/libvips/iofuncs/memory.c", "commit_date": "2020-07-04 00:00:00", "repo_name": "libvips/libvips", "stars": 8851, "license": "lgpl-2.1", "language": "c", "size": 93246}
{"docstring": "/* Load a profile from a blob and check compatibility.\n */\n", "func_signal": "static cmsHPROFILE\nvips_icc_load_profile_blob( VipsBlob *blob, VipsImage *image )", "code": "{\n\tconst void *data;\n\tsize_t size;\n\tcmsHPROFILE profile;\n\n\tdata = vips_blob_get( blob, &size );\n\tif( !(profile = cmsOpenProfileFromMem( data, size )) ) {\n\t\tg_warning( \"%s\", _( \"corrupt profile\" ) );\n\t\treturn( NULL ); \n\t}\n\n\tif( image &&\n\t\tvips_image_expected_bands( image ) != \n\t\t\tvips_icc_profile_needs_bands( profile ) ) {\n\t\tVIPS_FREEF( cmsCloseProfile, profile );\n\t\tg_warning( \"%s\", _( \"profile incompatible with image\" ) );\n\t\treturn( NULL );\n\t}\n\tif( image &&\n\t\tvips_image_expected_sig( image ) != \n\t\t\tcmsGetColorSpace( profile ) ) {\n\t\tVIPS_FREEF( cmsCloseProfile, profile );\n\t\tg_warning( \"%s\", \n\t\t\t_( \"profile colourspace differs from image\" ) );\n\t\treturn( NULL );\n\t}\n\n\treturn( profile );\n}", "path": "libvips/libvips/colour/icc_transform.c", "commit_date": "2019-12-22 00:00:00", "repo_name": "libvips/libvips", "stars": 8851, "license": "lgpl-2.1", "language": "c", "size": 93246}
{"docstring": "/**\n * vips_malloc:\n * @object: (nullable): allocate memory local to this #VipsObject, or %NULL\n * @size: number of bytes to allocate\n *\n * g_malloc() local to @object, that is, the memory will be automatically \n * freed for you when the object is closed. If @object is %NULL, you need to \n * free the memory explicitly with g_free().\n *\n * This function cannot fail. See vips_tracked_malloc() if you are \n * allocating large amounts of memory.\n *\n * See also: vips_tracked_malloc().\n *\n * Returns: (transfer full): a pointer to the allocated memory.\n */\n", "func_signal": "void *\nvips_malloc( VipsObject *object, size_t size )", "code": "{\n\tvoid *buf;\n\n\tbuf = g_malloc0( size );\n\n        if( object ) {\n\t\tg_signal_connect( object, \"postclose\", \n\t\t\tG_CALLBACK( vips_malloc_cb ), buf );\n\t\tobject->local_memory += size;\n\t}\n\n\treturn( buf );\n}", "path": "libvips/libvips/iofuncs/memory.c", "commit_date": "2020-07-04 00:00:00", "repo_name": "libvips/libvips", "stars": 8851, "license": "lgpl-2.1", "language": "c", "size": 93246}
{"docstring": "/**\n * vips_icc_export: (method)\n * @in: input image\n * @out: (out): output image\n * @...: %NULL-terminated list of optional named arguments\n *\n * Optional arguments:\n *\n * * @intent: transform with this intent\n * * @depth: depth of output image in bits\n * * @output_profile: get the output profile from here\n * * @pcs: use XYZ or LAB PCS\n *\n * Export an image from D65 LAB to device space with an ICC profile. \n * If @pcs is\n * set to #VIPS_PCS_XYZ, use CIE XYZ PCS instead. \n * If @output_profile is not set, use the embedded profile, if any. \n * If @output_profile is set, export with that and attach it to the output \n * image. \n *\n * Returns: 0 on success, -1 on error.\n */\n", "func_signal": "int\nvips_icc_export( VipsImage *in, VipsImage **out, ... )", "code": "{\n\tva_list ap;\n\tint result;\n\n\tva_start( ap, out );\n\tresult = vips_call_split( \"icc_export\", ap, in, out );\n\tva_end( ap );\n\n\treturn( result );\n}", "path": "libvips/libvips/colour/icc_transform.c", "commit_date": "2019-12-22 00:00:00", "repo_name": "libvips/libvips", "stars": 8851, "license": "lgpl-2.1", "language": "c", "size": 93246}
{"docstring": "/* Process a buffer of data.\n */\n", "func_signal": "static void\nvips_icc_import_line( VipsColour *colour, \n\tVipsPel *out, VipsPel **in, int width )", "code": "{\n\tVipsIcc *icc = (VipsIcc *) colour;\n\n\tVipsPel *p;\n\tfloat *q;\n\tint i;\n\n\t/* Buffer of encoded 16-bit pixels we transform.\n\t */\n\tguint16 encoded[3 * PIXEL_BUFFER_SIZE];\n\n\tp = (VipsPel *) in[0];\n\tq = (float *) out;\n\tfor( i = 0; i < width; i += PIXEL_BUFFER_SIZE ) {\n\t\tconst int chunk = VIPS_MIN( width - i, PIXEL_BUFFER_SIZE );\n\n\t\tcmsDoTransform( icc->trans, p, encoded, chunk );\n\n\t\tif( icc->pcs == VIPS_PCS_LAB ) \n\t\t\tdecode_lab( encoded, q, chunk );\n\t\telse\n\t\t\tdecode_xyz( encoded, q, chunk );\n\n\t\tp += PIXEL_BUFFER_SIZE * VIPS_IMAGE_SIZEOF_PEL( colour->in[0] );\n\t\tq += PIXEL_BUFFER_SIZE * 3;\n\t}\n}", "path": "libvips/libvips/colour/icc_transform.c", "commit_date": "2019-12-22 00:00:00", "repo_name": "libvips/libvips", "stars": 8851, "license": "lgpl-2.1", "language": "c", "size": 93246}
{"docstring": "/* Is a profile just a pcs stub.\n */\n", "func_signal": "static gboolean\nis_pcs( cmsHPROFILE profile )", "code": "{\n\treturn( cmsGetColorSpace( profile ) == cmsSigLabData ||\n\t\tcmsGetColorSpace( profile ) == cmsSigXYZData ); \n}", "path": "libvips/libvips/colour/icc_transform.c", "commit_date": "2019-12-22 00:00:00", "repo_name": "libvips/libvips", "stars": 8851, "license": "lgpl-2.1", "language": "c", "size": 93246}
{"docstring": "/**\n * vips_tracked_get_files:\n *\n * Returns the number of open files. \n *\n * Returns: the number of open files\n */\n", "func_signal": "int\nvips_tracked_get_files( void )", "code": "{\n\tint n;\n\n\tvips_tracked_init(); \n\n\tg_mutex_lock( vips_tracked_mutex );\n\n\tn = vips_tracked_files;\n\n\tg_mutex_unlock( vips_tracked_mutex );\n\n\treturn( n );\n}", "path": "libvips/libvips/iofuncs/memory.c", "commit_date": "2020-07-04 00:00:00", "repo_name": "libvips/libvips", "stars": 8851, "license": "lgpl-2.1", "language": "c", "size": 93246}
{"docstring": "/* How many bands we expect to see from an image after preprocessing by our\n * parent classes. This is a bit fragile :-( \n *\n * FIXME ... split the _build() for colour into separate preprocess / process\n * / postprocess phases so we can load profiles after preprocess but before\n * actual processing takes place.\n */\n", "func_signal": "static int\nvips_image_expected_bands( VipsImage *image )", "code": "{\n\tint expected_bands;\n\n\tswitch( image->Type ) { \n\tcase VIPS_INTERPRETATION_B_W:\n\tcase VIPS_INTERPRETATION_GREY16:\n\t\texpected_bands = 1;\n\t\tbreak;\n\n\tcase VIPS_INTERPRETATION_XYZ:\n\tcase VIPS_INTERPRETATION_LAB:\n\tcase VIPS_INTERPRETATION_LABQ:\n\tcase VIPS_INTERPRETATION_RGB:\n\tcase VIPS_INTERPRETATION_CMC:\n\tcase VIPS_INTERPRETATION_LCH:\n\tcase VIPS_INTERPRETATION_LABS:\n\tcase VIPS_INTERPRETATION_sRGB:\n\tcase VIPS_INTERPRETATION_YXY:\n\tcase VIPS_INTERPRETATION_RGB16:\n\tcase VIPS_INTERPRETATION_scRGB:\n\tcase VIPS_INTERPRETATION_HSV:\n\t\texpected_bands = 3;\n\t\tbreak;\n\n\tcase VIPS_INTERPRETATION_CMYK:\n\t\texpected_bands = 4;\n\t\tbreak;\n\n\tcase VIPS_INTERPRETATION_MULTIBAND:\n\tcase VIPS_INTERPRETATION_HISTOGRAM:\n\tcase VIPS_INTERPRETATION_MATRIX:\n\tcase VIPS_INTERPRETATION_FOURIER:\n\tdefault:\n\t\texpected_bands = image->Bands;\n\t\tbreak;\n\t}\n\n\texpected_bands = VIPS_MIN( expected_bands, image->Bands );\n\n\treturn( expected_bands );\n}", "path": "libvips/libvips/colour/icc_transform.c", "commit_date": "2019-12-22 00:00:00", "repo_name": "libvips/libvips", "stars": 8851, "license": "lgpl-2.1", "language": "c", "size": 93246}
{"docstring": "/* TRUE if a profile is sane and is compatible with an image.\n */\n", "func_signal": "gboolean\nvips_icc_is_compatible_profile( VipsImage *image, \n\tconst void *data, size_t data_length )", "code": "{\n\tcmsHPROFILE profile;\n\n\tif( !(profile = cmsOpenProfileFromMem( data, data_length )) ) \n\t\t/* Corrupt profile. \n\t\t */\n\t\treturn( FALSE ); \n\n\tif( vips_image_expected_bands( image ) != \n\t\tvips_icc_profile_needs_bands( profile ) ) {\n\t\tVIPS_FREEF( cmsCloseProfile, profile );\n\t\treturn( FALSE );\n\t}\n\n\tif( vips_image_expected_sig( image ) != cmsGetColorSpace( profile ) ) {\n\t\tVIPS_FREEF( cmsCloseProfile, profile );\n\t\treturn( FALSE );\n\t}\n\n\tVIPS_FREEF( cmsCloseProfile, profile );\n\n\treturn( TRUE );\n}", "path": "libvips/libvips/colour/icc_transform.c", "commit_date": "2019-12-22 00:00:00", "repo_name": "libvips/libvips", "stars": 8851, "license": "lgpl-2.1", "language": "c", "size": 93246}
{"docstring": "/* Process a buffer of data.\n */\n", "func_signal": "static void\nvips_icc_export_line( VipsColour *colour, \n\tVipsPel *out, VipsPel **in, int width )", "code": "{\n\tVipsIcc *icc = (VipsIcc *) colour;\n\n\tfloat *p;\n\tVipsPel *q;\n\tint x;\n\n\t/* Buffer of encoded 16-bit pixels we transform.\n\t */\n\tguint16 encoded[3 * PIXEL_BUFFER_SIZE];\n\n\tp = (float *) in[0];\n\tq = (VipsPel *) out;\n\tfor( x = 0; x < width; x += PIXEL_BUFFER_SIZE ) {\n\t\tconst int chunk = VIPS_MIN( width - x, PIXEL_BUFFER_SIZE );\n\n\t\tif( icc->pcs == VIPS_PCS_LAB )\n\t\t\tencode_lab( p, encoded, chunk );\n\t\telse\n\t\t\tencode_xyz( p, encoded, chunk );\n\n\t\tcmsDoTransform( icc->trans, encoded, q, chunk );\n\n\t\tp += PIXEL_BUFFER_SIZE * 3;\n\t\tq += PIXEL_BUFFER_SIZE * VIPS_IMAGE_SIZEOF_PEL( colour->out );\n\t}\n}", "path": "libvips/libvips/colour/icc_transform.c", "commit_date": "2019-12-22 00:00:00", "repo_name": "libvips/libvips", "stars": 8851, "license": "lgpl-2.1", "language": "c", "size": 93246}
{"docstring": "// Assumes name has been validated\n", "func_signal": "static jv jv_basename(jv name)", "code": "{\n  const char *s = jv_string_value(name);\n  const char *p = strrchr(s, '/');\n  if (!p)\n    return name;\n  jv res = jv_string_fmt(\"%s\", p);\n  jv_free(name);\n  return res;\n}", "path": "jq/src/linker.c", "commit_date": "2019-02-27 00:00:00", "repo_name": "jqlang/jq", "stars": 28554, "license": "other", "language": "c", "size": 7949}
{"docstring": "/*------------------------------------------------.\n| Report that the YYRULE is going to be reduced.  |\n`------------------------------------------------*/\n", "func_signal": "static void\nyy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, YYLTYPE *yylsp, int yyrule, block* answer, int* errors, struct locfile* locations, struct lexer_param* lexer_param_ptr)", "code": "{\n  unsigned long yylno = yyrline[yyrule];\n  int yynrhs = yyr2[yyrule];\n  int yyi;\n  YYFPRINTF (stderr, \"Reducing stack by rule %d (line %lu):\\n\",\n             yyrule - 1, yylno);\n  /* The symbols being reduced.  */\n  for (yyi = 0; yyi < yynrhs; yyi++)\n    {\n      YYFPRINTF (stderr, \"   $%d = \", yyi + 1);\n      yy_symbol_print (stderr,\n                       yystos[yyssp[yyi + 1 - yynrhs]],\n                       &yyvsp[(yyi + 1) - (yynrhs)]\n                       , &(yylsp[(yyi + 1) - (yynrhs)])                       , answer, errors, locations, lexer_param_ptr);\n      YYFPRINTF (stderr, \"\\n\");\n    }\n}", "path": "jq/src/parser.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "jqlang/jq", "stars": 28554, "license": "other", "language": "c", "size": 7949}
{"docstring": "/* Assumes startchar is the first byte of a valid character sequence */\n", "func_signal": "int jvp_utf8_decode_length(char startchar)", "code": "{\n\tif ((startchar & 0x80) == 0) return 1;         // 0___ ____\n\telse if ((startchar & 0xE0) == 0xC0) return 2; // 110_ ____\n\telse if ((startchar & 0xF0) == 0xE0) return 3; // 1110 ____\n\telse return 4;                                 // 1111 ____\n}", "path": "jq/src/jv_unicode.c", "commit_date": "2017-05-20 00:00:00", "repo_name": "jqlang/jq", "stars": 28554, "license": "other", "language": "c", "size": 7949}
{"docstring": "// Doesn't actually check that name not be an absolute path, and we\n// don't have to: we always append relative paths to others (with a '/'\n// in between).\n", "func_signal": "static jv validate_relpath(jv name)", "code": "{\n  const char *s = jv_string_value(name);\n  if (strchr(s, '\\\\')) {\n    jv res = jv_invalid_with_msg(jv_string_fmt(\"Modules must be named by relative paths using '/', not '\\\\' (%s)\", s));\n    jv_free(name);\n    return res;\n  }\n  jv components = jv_string_split(jv_copy(name), jv_string(\"/\"));\n  jv_array_foreach(components, i, x) {\n    if (!strcmp(jv_string_value(x), \"..\")) {\n      jv_free(x);\n      jv_free(components);\n      jv res = jv_invalid_with_msg(jv_string_fmt(\"Relative paths to modules may not traverse to parent directories (%s)\", s));\n      jv_free(name);\n      return res;\n    }\n    if (i > 0 && jv_equal(jv_copy(x), jv_array_get(jv_copy(components), i - 1))) {\n      jv_free(x);\n      jv_free(components);\n      jv res = jv_invalid_with_msg(jv_string_fmt(\"module names must not have equal consecutive components: %s\",\n                                                 jv_string_value(name)));\n      jv_free(name);\n      return res;\n    }\n    jv_free(x);\n  }\n  jv_free(components);\n  return name;\n}", "path": "jq/src/linker.c", "commit_date": "2019-02-27 00:00:00", "repo_name": "jqlang/jq", "stars": 28554, "license": "other", "language": "c", "size": 7949}
{"docstring": "// Loads the library at lib_path into lib_state, putting the library's defs\n// into *out_block\n", "func_signal": "static int load_library(jq_state *jq, jv lib_path, int is_data, int raw, int optional, const char *as, block *out_block, struct lib_loading_state *lib_state)", "code": "{\n  int nerrors = 0;\n  struct locfile* src = NULL;\n  block program;\n  jv data;\n  if (is_data && !raw)\n    data = jv_load_file(jv_string_value(lib_path), 0);\n  else\n    data = jv_load_file(jv_string_value(lib_path), 1);\n  int state_idx;\n  if (!jv_is_valid(data)) {\n    program = gen_noop();\n    if (!optional) {\n      if (jv_invalid_has_msg(jv_copy(data)))\n        data = jv_invalid_get_msg(data);\n      else\n        data = jv_string(\"unknown error\");\n      jq_report_error(jq, jv_string_fmt(\"jq: error loading data file %s: %s\\n\", jv_string_value(lib_path), jv_string_value(data)));\n      nerrors++;\n    }\n    goto out;\n  } else if (is_data) {\n    // import \"foo\" as $bar;\n    program = gen_const_global(jv_copy(data), as);\n  } else {\n    // import \"foo\" as bar;\n    src = locfile_init(jq, jv_string_value(lib_path), jv_string_value(data), jv_string_length_bytes(jv_copy(data)));\n    nerrors += jq_parse_library(src, &program);\n    locfile_free(src);\n    if (nerrors == 0) {\n      char *lib_origin = strdup(jv_string_value(lib_path));\n      nerrors += process_dependencies(jq, jq_get_jq_origin(jq),\n                                      jv_string(dirname(lib_origin)),\n                                      &program, lib_state);\n      free(lib_origin);\n      program = block_bind_self(program, OP_IS_CALL_PSEUDO);\n    }\n  }\n  state_idx = lib_state->ct++;\n  lib_state->names = jv_mem_realloc(lib_state->names, lib_state->ct * sizeof(const char *));\n  lib_state->defs = jv_mem_realloc(lib_state->defs, lib_state->ct * sizeof(block));\n  lib_state->names[state_idx] = strdup(jv_string_value(lib_path));\n  lib_state->defs[state_idx] = program;\nout:\n  *out_block = program;\n  jv_free(lib_path);\n  jv_free(data);\n  return nerrors;\n}", "path": "jq/src/linker.c", "commit_date": "2019-02-27 00:00:00", "repo_name": "jqlang/jq", "stars": 28554, "license": "other", "language": "c", "size": 7949}
{"docstring": "/* Return the length of YYSTR.  */\n", "func_signal": "static YYSIZE_T\nyystrlen (const char *yystr)", "code": "{\n  YYSIZE_T yylen;\n  for (yylen = 0; yystr[yylen]; yylen++)\n    continue;\n  return yylen;\n}", "path": "jq/src/parser.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "jqlang/jq", "stars": 28554, "license": "other", "language": "c", "size": 7949}
{"docstring": "/* Copy to YYRES the contents of YYSTR after stripping away unnecessary\n   quotes and backslashes, so that it's suitable for yyerror.  The\n   heuristic is that double-quoting is unnecessary unless the string\n   contains an apostrophe, a comma, or backslash (other than\n   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is\n   null, do not copy; instead, return the length of what the result\n   would have been.  */\n", "func_signal": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)", "code": "{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n        switch (*++yyp)\n          {\n          case '\\'':\n          case ',':\n            goto do_not_strip_quotes;\n\n          case '\\\\':\n            if (*++yyp != '\\\\')\n              goto do_not_strip_quotes;\n            else\n              goto append;\n\n          append:\n          default:\n            if (yyres)\n              yyres[yyn] = *yyp;\n            yyn++;\n            break;\n\n          case '\"':\n            if (yyres)\n              yyres[yyn] = '\\0';\n            return yyn;\n          }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return (YYSIZE_T) (yystpcpy (yyres, yystr) - yyres);\n}", "path": "jq/src/parser.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "jqlang/jq", "stars": 28554, "license": "other", "language": "c", "size": 7949}
{"docstring": "// Given a lib_path to search first, creates a chain of search paths\n// in the following order:\n// 1. lib_path\n// 2. -L paths passed in on the command line (from jq_state*) or builtin list\n", "func_signal": "static jv build_lib_search_chain(jq_state *jq, jv search_path, jv jq_origin, jv lib_origin)", "code": "{\n  assert(jv_get_kind(search_path) == JV_KIND_ARRAY);\n  jv expanded = jv_array();\n  jv expanded_elt;\n  jv err = jv_null();\n  jv_array_foreach(search_path, i, path) {\n    if (jv_get_kind(path) != JV_KIND_STRING) {\n      jv_free(path);\n      continue;\n    }\n    path = expand_path(path);\n    if (!jv_is_valid(path)) {\n      err = path;\n      path = jv_null();\n      continue;\n    }\n    if (strcmp(\".\",jv_string_value(path)) == 0) {\n      expanded_elt = jv_copy(path);\n    } else if (strncmp(\"$ORIGIN/\",jv_string_value(path),sizeof(\"$ORIGIN/\") - 1) == 0) {\n      expanded_elt = jv_string_fmt(\"%s/%s\",\n                               jv_string_value(jq_origin),\n                               jv_string_value(path) + sizeof (\"$ORIGIN/\") - 1);\n    } else if (jv_get_kind(lib_origin) == JV_KIND_STRING &&\n               path_is_relative(jv_copy(path))) {\n      expanded_elt = jv_string_fmt(\"%s/%s\",\n                               jv_string_value(lib_origin),\n                               jv_string_value(path));\n    } else {\n      expanded_elt = path;\n      path = jv_invalid();\n    }\n    expanded = jv_array_append(expanded, expanded_elt);\n    jv_free(path);\n  }\n  jv_free(jq_origin);\n  jv_free(lib_origin);\n  jv_free(search_path);\n  return JV_ARRAY(expanded, err);\n}", "path": "jq/src/linker.c", "commit_date": "2019-02-27 00:00:00", "repo_name": "jqlang/jq", "stars": 28554, "license": "other", "language": "c", "size": 7949}
{"docstring": "/* Copy YYSRC to YYDEST, returning the address of the terminating '\\0' in\n   YYDEST.  */\n", "func_signal": "static char *\nyystpcpy (char *yydest, const char *yysrc)", "code": "{\n  char *yyd = yydest;\n  const char *yys = yysrc;\n\n  while ((*yyd++ = *yys++) != '\\0')\n    continue;\n\n  return yyd - 1;\n}", "path": "jq/src/parser.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "jqlang/jq", "stars": 28554, "license": "other", "language": "c", "size": 7949}
{"docstring": "/*-----------------------------------------------.\n| Release the memory associated to this symbol.  |\n`-----------------------------------------------*/\n", "func_signal": "static void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, YYLTYPE *yylocationp, block* answer, int* errors, struct locfile* locations, struct lexer_param* lexer_param_ptr)", "code": "{\n  YYUSE (yyvaluep);\n  YYUSE (yylocationp);\n  YYUSE (answer);\n  YYUSE (errors);\n  YYUSE (locations);\n  YYUSE (lexer_param_ptr);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n    case 4: /* IDENT  */\n#line 36 \"src/parser.y\" /* yacc.c:1257  */\n      { jv_free(((*yyvaluep).literal)); }\n#line 1955 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 5: /* FIELD  */\n#line 36 \"src/parser.y\" /* yacc.c:1257  */\n      { jv_free(((*yyvaluep).literal)); }\n#line 1961 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 6: /* LITERAL  */\n#line 36 \"src/parser.y\" /* yacc.c:1257  */\n      { jv_free(((*yyvaluep).literal)); }\n#line 1967 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 7: /* FORMAT  */\n#line 36 \"src/parser.y\" /* yacc.c:1257  */\n      { jv_free(((*yyvaluep).literal)); }\n#line 1973 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 42: /* QQSTRING_TEXT  */\n#line 36 \"src/parser.y\" /* yacc.c:1257  */\n      { jv_free(((*yyvaluep).literal)); }\n#line 1979 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 71: /* Module  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 1985 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 72: /* Imports  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 1991 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 73: /* FuncDefs  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 1997 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 74: /* Exp  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2003 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 75: /* Import  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2009 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 76: /* ImportWhat  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2015 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 77: /* ImportFrom  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2021 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 78: /* FuncDef  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2027 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 79: /* Params  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2033 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 80: /* Param  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2039 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 81: /* String  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2045 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 84: /* QQString  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2051 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 85: /* ElseBody  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2057 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 86: /* ExpD  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2063 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 87: /* Term  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2069 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 88: /* Args  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2075 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 89: /* Arg  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2081 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 90: /* RepPatterns  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2087 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 91: /* Patterns  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2093 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 92: /* Pattern  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2099 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 93: /* ArrayPats  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2105 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 94: /* ObjPats  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2111 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 95: /* ObjPat  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2117 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 96: /* Keyword  */\n#line 36 \"src/parser.y\" /* yacc.c:1257  */\n      { jv_free(((*yyvaluep).literal)); }\n#line 2123 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 97: /* MkDict  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2129 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n    case 98: /* MkDictPair  */\n#line 37 \"src/parser.y\" /* yacc.c:1257  */\n      { block_free(((*yyvaluep).blk)); }\n#line 2135 \"src/parser.c\" /* yacc.c:1257  */\n        break;\n\n      default:\n        break;\n    }\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}", "path": "jq/src/parser.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "jqlang/jq", "stars": 28554, "license": "other", "language": "c", "size": 7949}
{"docstring": "/*------------------------------------------------------------------.\n| yy_stack_print -- Print the state stack from its BOTTOM up to its |\n| TOP (included).                                                   |\n`------------------------------------------------------------------*/\n", "func_signal": "static void\nyy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)", "code": "{\n  YYFPRINTF (stderr, \"Stack now\");\n  for (; yybottom <= yytop; yybottom++)\n    {\n      int yybot = *yybottom;\n      YYFPRINTF (stderr, \" %d\", yybot);\n    }\n  YYFPRINTF (stderr, \"\\n\");\n}", "path": "jq/src/parser.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "jqlang/jq", "stars": 28554, "license": "other", "language": "c", "size": 7949}
{"docstring": "// FIXME It'd be nice to have an option to search the same search path\n// as we do in process_dependencies.\n", "func_signal": "jv load_module_meta(jq_state *jq, jv mod_relpath)", "code": "{\n  // We can't know the caller's origin; we could though, if it was passed in\n  jv lib_path = find_lib(jq, validate_relpath(mod_relpath), jq_get_lib_dirs(jq), \".jq\", jq_get_jq_origin(jq), jv_null());\n  if (!jv_is_valid(lib_path))\n    return lib_path;\n  jv meta = jv_null();\n  jv data = jv_load_file(jv_string_value(lib_path), 1);\n  if (jv_is_valid(data)) {\n    block program;\n    struct locfile* src = locfile_init(jq, jv_string_value(lib_path), jv_string_value(data), jv_string_length_bytes(jv_copy(data)));\n    int nerrors = jq_parse_library(src, &program);\n    if (nerrors == 0) {\n      meta = block_module_meta(program);\n      if (jv_get_kind(meta) == JV_KIND_NULL)\n        meta = jv_object();\n      meta = jv_object_set(meta, jv_string(\"deps\"), block_take_imports(&program));\n    }\n    locfile_free(src);\n    block_free(program);\n  }\n  jv_free(lib_path);\n  jv_free(data);\n  return meta;\n}", "path": "jq/src/linker.c", "commit_date": "2019-02-27 00:00:00", "repo_name": "jqlang/jq", "stars": 28554, "license": "other", "language": "c", "size": 7949}
{"docstring": "/*-----------------------------------.\n| Print this symbol's value on YYO.  |\n`-----------------------------------*/\n", "func_signal": "static void\nyy_symbol_value_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, block* answer, int* errors, struct locfile* locations, struct lexer_param* lexer_param_ptr)", "code": "{\n  FILE *yyoutput = yyo;\n  YYUSE (yyoutput);\n  YYUSE (yylocationp);\n  YYUSE (answer);\n  YYUSE (errors);\n  YYUSE (locations);\n  YYUSE (lexer_param_ptr);\n  if (!yyvaluep)\n    return;\n# ifdef YYPRINT\n  if (yytype < YYNTOKENS)\n    YYPRINT (yyo, yytoknum[yytype], *yyvaluep);\n# endif\n  YYUSE (yytype);\n}", "path": "jq/src/parser.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "jqlang/jq", "stars": 28554, "license": "other", "language": "c", "size": 7949}
{"docstring": "/* Returns string message if the block is a constant that is not valid as an\n * object key. */\n", "func_signal": "static jv check_object_key(block k)", "code": "{\n  if (block_is_const(k) && block_const_kind(k) != JV_KIND_STRING) {\n    char errbuf[15];\n    return jv_string_fmt(\"Cannot use %s (%s) as object key\",\n        jv_kind_name(block_const_kind(k)),\n        jv_dump_string_trunc(block_const(k), errbuf, sizeof(errbuf)));\n  }\n  return jv_invalid();\n}", "path": "jq/src/parser.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "jqlang/jq", "stars": 28554, "license": "other", "language": "c", "size": 7949}
{"docstring": "/* Print *YYLOCP on YYO.  Private, do not rely on its existence. */\n", "func_signal": "YY_ATTRIBUTE_UNUSED\nstatic int\nyy_location_print_ (FILE *yyo, YYLTYPE const * const yylocp)", "code": "{\n  int res = 0;\n  int end_col = 0 != yylocp->last_column ? yylocp->last_column - 1 : 0;\n  if (0 <= yylocp->first_line)\n    {\n      res += YYFPRINTF (yyo, \"%d\", yylocp->first_line);\n      if (0 <= yylocp->first_column)\n        res += YYFPRINTF (yyo, \".%d\", yylocp->first_column);\n    }\n  if (0 <= yylocp->last_line)\n    {\n      if (yylocp->first_line < yylocp->last_line)\n        {\n          res += YYFPRINTF (yyo, \"-%d\", yylocp->last_line);\n          if (0 <= end_col)\n            res += YYFPRINTF (yyo, \".%d\", end_col);\n        }\n      else if (0 <= end_col && yylocp->first_column < end_col)\n        res += YYFPRINTF (yyo, \"-%d\", end_col);\n    }\n  return res;\n }\n\n#  define YY_LOCATION_PRINT(File, Loc)          \\\n  yy_location_print_ (File, &(Loc))\n\n# else\n#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)\n# endif\n#endif\n\n\n# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \\\ndo {                                                                      \\\n  if (yydebug)                                                            \\\n    {                                                                     \\\n      YYFPRINTF (stderr, \"%s \", Title);                                   \\\n      yy_symbol_print (stderr,                                            \\\n                  Type, Value, Location, answer, errors, locations, lexer_param_ptr); \\\n      YYFPRINTF (stderr, \"\\n\");                                           \\\n    }                                                                     \\\n}", "path": "jq/src/parser.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "jqlang/jq", "stars": 28554, "license": "other", "language": "c", "size": 7949}
{"docstring": "// XXX Split this into a util that takes a callback, and then...\n", "func_signal": "static int process_dependencies(jq_state *jq, jv jq_origin, jv lib_origin, block *src_block, struct lib_loading_state *lib_state)", "code": "{\n  jv deps = block_take_imports(src_block);\n  block bk = *src_block;\n  int nerrors = 0;\n\n  // XXX This is a backward jv_array_foreach because bindings go in reverse\n  for (int i = jv_array_length(jv_copy(deps)); i > 0; ) {\n    i--;\n    jv dep = jv_array_get(jv_copy(deps), i);\n\n    const char *as_str = NULL;\n    int is_data = jv_get_kind(jv_object_get(jv_copy(dep), jv_string(\"is_data\"))) == JV_KIND_TRUE;\n    int raw = 0;\n    jv v = jv_object_get(jv_copy(dep), jv_string(\"raw\"));\n    if (jv_get_kind(v) == JV_KIND_TRUE)\n      raw = 1;\n    int optional = 0;\n    if (jv_get_kind(jv_object_get(jv_copy(dep), jv_string(\"optional\"))) == JV_KIND_TRUE)\n      optional = 1;\n    jv_free(v);\n    jv relpath = validate_relpath(jv_object_get(jv_copy(dep), jv_string(\"relpath\")));\n    jv as = jv_object_get(jv_copy(dep), jv_string(\"as\"));\n    assert(!jv_is_valid(as) || jv_get_kind(as) == JV_KIND_STRING);\n    if (jv_get_kind(as) == JV_KIND_STRING)\n      as_str = jv_string_value(as);\n    jv search = default_search(jq, jv_object_get(dep, jv_string(\"search\")));\n    // dep is now freed; do not reuse\n\n    // find_lib does a lot of work that could be cached...\n    jv resolved = find_lib(jq, relpath, search, is_data ? \".json\" : \".jq\", jv_copy(jq_origin), jv_copy(lib_origin));\n    // XXX ...move the rest of this into a callback.\n    if (!jv_is_valid(resolved)) {\n      jv_free(as);\n      if (optional) {\n        jv_free(resolved);\n        continue;\n      }\n      jv emsg = jv_invalid_get_msg(resolved);\n      jq_report_error(jq, jv_string_fmt(\"jq: error: %s\\n\",jv_string_value(emsg)));\n      jv_free(emsg);\n      jv_free(deps);\n      jv_free(jq_origin);\n      jv_free(lib_origin);\n      return 1;\n    }\n\n    if (is_data) {\n      // Can't reuse data libs because the wrong name is bound\n      block dep_def_block;\n      nerrors += load_library(jq, resolved, is_data, raw, optional, as_str, &dep_def_block, lib_state);\n      if (nerrors == 0) {\n        // Bind as both $data::data and $data for backward compatibility vs common sense\n        bk = block_bind_library(dep_def_block, bk, OP_IS_CALL_PSEUDO, as_str);\n        bk = block_bind_library(dep_def_block, bk, OP_IS_CALL_PSEUDO, NULL);\n      }\n    } else {\n      uint64_t state_idx = 0;\n      for (; state_idx < lib_state->ct; ++state_idx) {\n        if (strcmp(lib_state->names[state_idx],jv_string_value(resolved)) == 0)\n          break;\n      }\n\n      if (state_idx < lib_state->ct) { // Found\n        jv_free(resolved);\n        // Bind the library to the program\n        bk = block_bind_library(lib_state->defs[state_idx], bk, OP_IS_CALL_PSEUDO, as_str);\n      } else { // Not found.   Add it to the table before binding.\n        block dep_def_block = gen_noop();\n        nerrors += load_library(jq, resolved, is_data, raw, optional, as_str, &dep_def_block, lib_state);\n        // resolved has been freed\n        if (nerrors == 0) {\n          // Bind the library to the program\n          bk = block_bind_library(dep_def_block, bk, OP_IS_CALL_PSEUDO, as_str);\n        }\n      }\n    }\n\n    jv_free(as);\n  }\n  jv_free(lib_origin);\n  jv_free(jq_origin);\n  jv_free(deps);\n  return nerrors;\n}", "path": "jq/src/linker.c", "commit_date": "2019-02-27 00:00:00", "repo_name": "jqlang/jq", "stars": 28554, "license": "other", "language": "c", "size": 7949}
{"docstring": "// Asummes validated relative path to module\n", "func_signal": "static jv find_lib(jq_state *jq, jv rel_path, jv search, const char *suffix, jv jq_origin, jv lib_origin)", "code": "{\n  if (!jv_is_valid(rel_path)) {\n    jv_free(search);\n    return rel_path;\n  }\n  if (jv_get_kind(rel_path) != JV_KIND_STRING) {\n    jv_free(rel_path);\n    jv_free(search);\n    return jv_invalid_with_msg(jv_string_fmt(\"Module path must be a string\"));\n  }\n  if (jv_get_kind(search) != JV_KIND_ARRAY) {\n    jv_free(rel_path);\n    jv_free(search);\n    return jv_invalid_with_msg(jv_string_fmt(\"Module search path must be an array\"));\n  }\n\n  struct stat st;\n  int ret;\n\n  // Ideally we should cache this somewhere\n  search = build_lib_search_chain(jq, search, jq_origin, lib_origin);\n  jv err = jv_array_get(jv_copy(search), 1);\n  search = jv_array_get(search, 0);\n\n  jv bname = jv_basename(jv_copy(rel_path));\n\n  jv_array_foreach(search, i, spath) {\n    if (jv_get_kind(spath) == JV_KIND_NULL) {\n      jv_free(spath);\n      break;\n    }\n    if (jv_get_kind(spath) != JV_KIND_STRING ||\n        strcmp(jv_string_value(spath), \"\") == 0) {\n      jv_free(spath);\n      continue; /* XXX report non-strings in search path?? */\n    }\n    // Try ${search_dir}/${rel_path}.jq\n    jv testpath = jq_realpath(jv_string_fmt(\"%s/%s%s\",\n                                            jv_string_value(spath),\n                                            jv_string_value(rel_path),\n                                            suffix));\n    ret = stat(jv_string_value(testpath),&st);\n    if (ret == -1 && errno == ENOENT) {\n      jv_free(testpath);\n      // Try ${search_dir}/$(dirname ${rel_path})/jq/main.jq\n      testpath = jq_realpath(jv_string_fmt(\"%s/%s/%s%s\",\n                                           jv_string_value(spath),\n                                           jv_string_value(rel_path),\n                                           \"jq/main\",\n                                           suffix));\n      ret = stat(jv_string_value(testpath),&st);\n    }\n    if (ret == -1 && errno == ENOENT) {\n      jv_free(testpath);\n      // Try ${search_dir}/${rel_path}/$(basename ${rel_path}).jq\n      testpath = jq_realpath(jv_string_fmt(\"%s/%s/%s%s\",\n                                           jv_string_value(spath),\n                                           jv_string_value(rel_path),\n                                           jv_string_value(bname),\n                                           suffix));\n      ret = stat(jv_string_value(testpath),&st);\n    }\n    if (ret == 0) {\n      jv_free(err);\n      jv_free(rel_path);\n      jv_free(search);\n      jv_free(bname);\n      jv_free(spath);\n      return testpath;\n    }\n    jv_free(testpath);\n    jv_free(spath);\n  }\n  jv output;\n  if (!jv_is_valid(err)) {\n    err = jv_invalid_get_msg(err);\n    output = jv_invalid_with_msg(jv_string_fmt(\"module not found: %s (%s)\",\n                                               jv_string_value(rel_path),\n                                               jv_string_value(err)));\n  } else {\n    output = jv_invalid_with_msg(jv_string_fmt(\"module not found: %s\",\n                                               jv_string_value(rel_path)));\n  }\n  jv_free(err);\n  jv_free(rel_path);\n  jv_free(search);\n  jv_free(bname);\n  return output;\n}", "path": "jq/src/linker.c", "commit_date": "2019-02-27 00:00:00", "repo_name": "jqlang/jq", "stars": 28554, "license": "other", "language": "c", "size": 7949}
{"docstring": "// jvp_utf8_backtrack returns the beginning of the last codepoint in the\n// string, assuming that start is the last byte in the string.\n// If the last codepoint is incomplete, returns the number of missing bytes via\n// *missing_bytes.  If there are no leading bytes or an invalid byte is\n// encountered, NULL is returned and *missing_bytes is not altered.\n", "func_signal": "const char* jvp_utf8_backtrack(const char* start, const char* min, int *missing_bytes)", "code": "{\n  assert(min <= start);\n  if (min == start) {\n    return min;\n  }\n  int length = 0;\n  int seen = 1;\n  while (start >= min && (length = utf8_coding_length[(unsigned char)*start]) == UTF8_CONTINUATION_BYTE) {\n    start--;\n    seen++;\n  }\n  if (length == 0 || length == UTF8_CONTINUATION_BYTE || length - seen < 0) {\n    return NULL;\n  }\n  if (missing_bytes) *missing_bytes = length - seen;\n  return start;\n}", "path": "jq/src/jv_unicode.c", "commit_date": "2017-05-20 00:00:00", "repo_name": "jqlang/jq", "stars": 28554, "license": "other", "language": "c", "size": 7949}
{"docstring": "/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message\n   about the unexpected token YYTOKEN for the state stack whose top is\n   YYSSP.\n\n   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is\n   not large enough to hold the message.  In that case, also set\n   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the\n   required number of bytes is too large to store.  */\n", "func_signal": "static int\nyysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,\n                yytype_int16 *yyssp, int yytoken)", "code": "{\n  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);\n  YYSIZE_T yysize = yysize0;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *yyformat = YY_NULLPTR;\n  /* Arguments of yyformat. */\n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int yycount = 0;\n\n  /* There are many possibilities here to consider:\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in yychar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated yychar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[*yyssp];\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          /* Stay within bounds of both yycheck and yytname.  */\n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                {\n                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);\n                  if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)\n                    yysize = yysize1;\n                  else\n                    return 2;\n                }\n              }\n        }\n    }\n\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n    default: /* Avoid compiler warnings. */\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  {\n    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);\n    if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)\n      yysize = yysize1;\n    else\n      return 2;\n  }\n\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          yyp++;\n          yyformat++;\n        }\n  }\n  return 0;\n}", "path": "jq/src/parser.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "jqlang/jq", "stars": 28554, "license": "other", "language": "c", "size": 7949}
{"docstring": "/*---------------------------.\n| Print this symbol on YYO.  |\n`---------------------------*/\n", "func_signal": "static void\nyy_symbol_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, block* answer, int* errors, struct locfile* locations, struct lexer_param* lexer_param_ptr)", "code": "{\n  YYFPRINTF (yyo, \"%s %s (\",\n             yytype < YYNTOKENS ? \"token\" : \"nterm\", yytname[yytype]);\n\n  YY_LOCATION_PRINT (yyo, *yylocationp);\n  YYFPRINTF (yyo, \": \");\n  yy_symbol_value_print (yyo, yytype, yyvaluep, yylocationp, answer, errors, locations, lexer_param_ptr);\n  YYFPRINTF (yyo, \")\");\n}", "path": "jq/src/parser.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "jqlang/jq", "stars": 28554, "license": "other", "language": "c", "size": 7949}
{"docstring": "/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\n/* process data to be hashed */\n", "func_signal": "static SkeinHashReturn Update(hashState *state, const SkeinBitSequence *data, SkeinDataLength databitlen)", "code": "{\n  /* only the final Update() call is allowed do partial bytes, else assert an error */\n  Skein_Assert((state->u.h.T[1] & SKEIN_T1_FLAG_BIT_PAD) == 0 || databitlen == 0, SKEIN_FAIL);\n\n  Skein_Assert(state->statebits % 256 == 0 && (state->statebits-256) < 1024,SKEIN_FAIL);\n  if ((databitlen & 7) == 0)  /* partial bytes? */\n  {\n    return Skein_512_Update(&state->u.ctx_512,data,databitlen >> 3);\n  }\n  else\n  {   /* handle partial final byte */\n    size_t bCnt = (databitlen >> 3) + 1;                  /* number of bytes to handle (nonzero here!) */\n    u08b_t b,mask;\n\n    mask = (u08b_t) (1u << (7 - (databitlen & 7)));       /* partial byte bit mask */\n    b    = (u08b_t) ((data[bCnt-1] & (0-mask)) | mask);   /* apply bit padding on final byte */\n\n    Skein_512_Update(&state->u.ctx_512,data,bCnt-1); /* process all but the final byte    */\n    Skein_512_Update(&state->u.ctx_512,&b  ,  1   ); /* process the (masked) partial byte */\n    Skein_Set_Bit_Pad_Flag(state->u.h);                    /* set tweak flag for the final call */\n\n    return SKEIN_SUCCESS;\n  }\n}", "path": "xmrig/src/crypto/cn/c_skein.c", "commit_date": "2019-06-04 00:00:00", "repo_name": "xmrig/xmrig", "stars": 8202, "license": "gpl-3.0", "language": "c", "size": 13619}
{"docstring": "/* frees level until arity = 0 */\n", "func_signal": "static void\nhwloc_synthetic_free_levels(struct hwloc_synthetic_backend_data_s *data)", "code": "{\n  unsigned i;\n  for(i=0; i<HWLOC_SYNTHETIC_MAX_DEPTH; i++) {\n    struct hwloc_synthetic_level_data_s *curlevel = &data->level[i];\n    struct hwloc_synthetic_attached_s **pprev = &curlevel->attached;\n    while (*pprev) {\n      struct hwloc_synthetic_attached_s *cur = *pprev;\n      *pprev = cur->next;\n      free(cur);\n    }\n    free(curlevel->indexes.array);\n    if (!curlevel->arity)\n      break;\n  }\n  free(data->numa_attached_indexes.array);\n}", "path": "xmrig/src/3rdparty/hwloc/src/topology-synthetic.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "xmrig/xmrig", "stars": 8202, "license": "gpl-3.0", "language": "c", "size": 13619}
{"docstring": "/* called during topology init() */\n", "func_signal": "void hwloc_internal_distances_init(struct hwloc_topology *topology)", "code": "{\n  topology->first_dist = topology->last_dist = NULL;\n  topology->next_dist_id = 0;\n}", "path": "xmrig/src/3rdparty/hwloc/src/distances.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "xmrig/xmrig", "stars": 8202, "license": "gpl-3.0", "language": "c", "size": 13619}
{"docstring": "/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\n/* select the context size and init the context */\n", "func_signal": "static SkeinHashReturn Init(hashState *state, int hashbitlen)", "code": "{\n    state->statebits = 64*SKEIN_512_STATE_WORDS;\n    return Skein_512_Init(&state->u.ctx_512,(size_t) hashbitlen);\n}", "path": "xmrig/src/crypto/cn/c_skein.c", "commit_date": "2019-06-04 00:00:00", "repo_name": "xmrig/xmrig", "stars": 8202, "license": "gpl-3.0", "language": "c", "size": 13619}
{"docstring": "/******************************************************\n * Grouping objects according to distances\n */\n", "func_signal": "static int hwloc_compare_values(uint64_t a, uint64_t b, float accuracy)", "code": "{\n  if (accuracy != 0.0f && fabsf((float)a-(float)b) < (float)a * accuracy)\n    return 0;\n  return a < b ? -1 : a == b ? 0 : 1;\n}", "path": "xmrig/src/3rdparty/hwloc/src/distances.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "xmrig/xmrig", "stars": 8202, "license": "gpl-3.0", "language": "c", "size": 13619}
{"docstring": "/*\n * Look at object physical distances to group them.\n */\n", "func_signal": "static void\nhwloc__groups_by_distances(struct hwloc_topology *topology,\n\t\t\t   unsigned nbobjs,\n\t\t\t   struct hwloc_obj **objs,\n\t\t\t   uint64_t *_values,\n\t\t\t   unsigned long kind,\n\t\t\t   unsigned nbaccuracies,\n\t\t\t   float *accuracies,\n\t\t\t   int needcheck)", "code": "{\n  unsigned *groupids;\n  unsigned nbgroups = 0;\n  unsigned i,j;\n  int verbose = topology->grouping_verbose;\n  hwloc_obj_t *groupobjs;\n  unsigned * groupsizes;\n  uint64_t *groupvalues;\n  unsigned failed = 0;\n\n  if (nbobjs <= 2)\n      return;\n\n  if (!(kind & HWLOC_DISTANCES_KIND_MEANS_LATENCY))\n    /* don't know use to use those for grouping */\n    /* TODO hwloc__find_groups_by_max_distance() for bandwidth */\n    return;\n\n  groupids = malloc(nbobjs * sizeof(*groupids));\n  if (!groupids)\n    return;\n\n  for(i=0; i<nbaccuracies; i++) {\n    if (verbose)\n      fprintf(stderr, \"Trying to group %u %s objects according to physical distances with accuracy %f\\n\",\n\t      nbobjs, hwloc_obj_type_string(objs[0]->type), accuracies[i]);\n    if (needcheck && hwloc__check_grouping_matrix(nbobjs, _values, accuracies[i], verbose) < 0)\n      continue;\n    nbgroups = hwloc__find_groups_by_min_distance(nbobjs, _values, accuracies[i], groupids, verbose);\n    if (nbgroups)\n      break;\n  }\n  if (!nbgroups)\n    goto out_with_groupids;\n\n  groupobjs = malloc(nbgroups * sizeof(*groupobjs));\n  groupsizes = malloc(nbgroups * sizeof(*groupsizes));\n  groupvalues = malloc(nbgroups * nbgroups * sizeof(*groupvalues));\n  if (!groupobjs || !groupsizes || !groupvalues)\n    goto out_with_groups;\n\n      /* create new Group objects and record their size */\n      memset(&(groupsizes[0]), 0, sizeof(groupsizes[0]) * nbgroups);\n      for(i=0; i<nbgroups; i++) {\n          /* create the Group object */\n          hwloc_obj_t group_obj, res_obj;\n          group_obj = hwloc_alloc_setup_object(topology, HWLOC_OBJ_GROUP, HWLOC_UNKNOWN_INDEX);\n          group_obj->cpuset = hwloc_bitmap_alloc();\n          group_obj->attr->group.kind = HWLOC_GROUP_KIND_DISTANCE;\n          group_obj->attr->group.subkind = topology->grouping_next_subkind;\n          for (j=0; j<nbobjs; j++)\n\t    if (groupids[j] == i+1) {\n\t      /* assemble the group sets */\n\t      hwloc_obj_add_other_obj_sets(group_obj, objs[j]);\n              groupsizes[i]++;\n            }\n          hwloc_debug_1arg_bitmap(\"adding Group object with %u objects and cpuset %s\\n\",\n                                  groupsizes[i], group_obj->cpuset);\n          res_obj = hwloc__insert_object_by_cpuset(topology, NULL, group_obj,\n                                                   (kind & HWLOC_DISTANCES_KIND_FROM_USER) ? \"distances:fromuser:group\" : \"distances:group\");\n\t  /* res_obj may be NULL on failure to insert. */\n\t  if (!res_obj)\n\t    failed++;\n\t  /* or it may be different from groupobjs if we got groups from XML import before grouping */\n          groupobjs[i] = res_obj;\n      }\n      topology->grouping_next_subkind++;\n\n      if (failed)\n\t/* don't try to group above if we got a NULL group here, just keep this incomplete level */\n\tgoto out_with_groups;\n\n      /* factorize values */\n      memset(&(groupvalues[0]), 0, sizeof(groupvalues[0]) * nbgroups * nbgroups);\n#undef VALUE\n#define VALUE(i, j) _values[(i) * nbobjs + (j)]\n#define GROUP_VALUE(i, j) groupvalues[(i) * nbgroups + (j)]\n      for(i=0; i<nbobjs; i++)\n\tif (groupids[i])\n\t  for(j=0; j<nbobjs; j++)\n\t    if (groupids[j])\n                GROUP_VALUE(groupids[i]-1, groupids[j]-1) += VALUE(i, j);\n      for(i=0; i<nbgroups; i++)\n          for(j=0; j<nbgroups; j++) {\n              unsigned groupsize = groupsizes[i]*groupsizes[j];\n              GROUP_VALUE(i, j) /= groupsize;\n          }\n#ifdef HWLOC_DEBUG\n      hwloc_debug(\"%s\", \"generated new distance matrix between groups:\\n\");\n      hwloc_debug(\"%s\", \"  index\");\n      for(j=0; j<nbgroups; j++)\n\thwloc_debug(\" % 5d\", (int) j); /* print index because os_index is -1 for Groups */\n      hwloc_debug(\"%s\", \"\\n\");\n      for(i=0; i<nbgroups; i++) {\n\thwloc_debug(\"  % 5d\", (int) i);\n\tfor(j=0; j<nbgroups; j++)\n\t  hwloc_debug(\" %llu\", (unsigned long long) GROUP_VALUE(i, j));\n\thwloc_debug(\"%s\", \"\\n\");\n      }\n#endif\n\n      hwloc__groups_by_distances(topology, nbgroups, groupobjs, groupvalues, kind, nbaccuracies, accuracies, 0 /* no need to check generated matrix */);\n\n out_with_groups:\n  free(groupobjs);\n  free(groupsizes);\n  free(groupvalues);\n out_with_groupids:\n  free(groupids);\n}", "path": "xmrig/src/3rdparty/hwloc/src/distances.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "xmrig/xmrig", "stars": 8202, "license": "gpl-3.0", "language": "c", "size": 13619}
{"docstring": "/* called at the beginning of load() */\n", "func_signal": "void hwloc_internal_distances_prepare(struct hwloc_topology *topology)", "code": "{\n  char *env;\n  hwloc_localeswitch_declare;\n\n  topology->grouping = 1;\n  if (topology->type_filter[HWLOC_OBJ_GROUP] == HWLOC_TYPE_FILTER_KEEP_NONE)\n    topology->grouping = 0;\n  env = getenv(\"HWLOC_GROUPING\");\n  if (env && !atoi(env))\n    topology->grouping = 0;\n\n  if (topology->grouping) {\n    topology->grouping_next_subkind = 0;\n\n    HWLOC_BUILD_ASSERT(sizeof(topology->grouping_accuracies)/sizeof(*topology->grouping_accuracies) == 5);\n    topology->grouping_accuracies[0] = 0.0f;\n    topology->grouping_accuracies[1] = 0.01f;\n    topology->grouping_accuracies[2] = 0.02f;\n    topology->grouping_accuracies[3] = 0.05f;\n    topology->grouping_accuracies[4] = 0.1f;\n    topology->grouping_nbaccuracies = 5;\n\n    hwloc_localeswitch_init();\n    env = getenv(\"HWLOC_GROUPING_ACCURACY\");\n    if (!env) {\n      /* only use 0.0 */\n      topology->grouping_nbaccuracies = 1;\n    } else if (strcmp(env, \"try\")) {\n      /* use the given value */\n      topology->grouping_nbaccuracies = 1;\n      topology->grouping_accuracies[0] = (float) atof(env);\n    } /* otherwise try all values */\n    hwloc_localeswitch_fini();\n\n    topology->grouping_verbose = 0;\n    env = getenv(\"HWLOC_GROUPING_VERBOSE\");\n    if (env)\n      topology->grouping_verbose = atoi(env);\n  }\n}", "path": "xmrig/src/3rdparty/hwloc/src/distances.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "xmrig/xmrig", "stars": 8202, "license": "gpl-3.0", "language": "c", "size": 13619}
{"docstring": "/* can be called at the end of the import (to cleanup things early),\n * or by backend_exit() if load failed for other reasons.\n */\n", "func_signal": "static void\nhwloc_nolibxml_free_buffers(struct hwloc_xml_backend_data_s *bdata)", "code": "{\n  struct hwloc__nolibxml_backend_data_s *nbdata = bdata->data;\n  if (nbdata->buffer) {\n    free(nbdata->buffer);\n    nbdata->buffer = NULL;\n  }\n}", "path": "xmrig/src/3rdparty/hwloc/src/topology-xml-nolibxml.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "xmrig/xmrig", "stars": 8202, "license": "gpl-3.0", "language": "c", "size": 13619}
{"docstring": "/* called during topology destroy */\n", "func_signal": "void hwloc_internal_distances_destroy(struct hwloc_topology * topology)", "code": "{\n  struct hwloc_internal_distances_s *dist, *next = topology->first_dist;\n  while ((dist = next) != NULL) {\n    next = dist->next;\n    hwloc_internal_distances_free(dist);\n  }\n  topology->first_dist = topology->last_dist = NULL;\n}", "path": "xmrig/src/3rdparty/hwloc/src/distances.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "xmrig/xmrig", "stars": 8202, "license": "gpl-3.0", "language": "c", "size": 13619}
{"docstring": "/*\n * Recursively build objects whose cpu start at first_cpu\n * - level gives where to look in the type, arity and id arrays\n * - the id array is used as a variable to get unique IDs for a given level.\n * - generated memory should be added to *memory_kB.\n * - generated cpus should be added to parent_cpuset.\n * - next cpu number to be used should be returned.\n */\n", "func_signal": "static void\nhwloc__look_synthetic(struct hwloc_topology *topology,\n\t\t      struct hwloc_synthetic_backend_data_s *data,\n\t\t      int level,\n\t\t      hwloc_bitmap_t parent_cpuset)", "code": "{\n  hwloc_obj_t obj;\n  unsigned i;\n  struct hwloc_synthetic_level_data_s *curlevel = &data->level[level];\n  hwloc_obj_type_t type = curlevel->attr.type;\n  hwloc_bitmap_t set;\n  unsigned os_index;\n\n  assert(hwloc__obj_type_is_normal(type) || type == HWLOC_OBJ_NUMANODE);\n  assert(type != HWLOC_OBJ_MACHINE);\n\n  os_index = hwloc_synthetic_next_index(&curlevel->indexes, type);\n\n  set = hwloc_bitmap_alloc();\n  if (!curlevel->arity) {\n    hwloc_bitmap_set(set, os_index);\n  } else {\n    for (i = 0; i < curlevel->arity; i++)\n      hwloc__look_synthetic(topology, data, level + 1, set);\n  }\n\n  hwloc_bitmap_or(parent_cpuset, parent_cpuset, set);\n\n  if (hwloc_filter_check_keep_object_type(topology, type)) {\n    obj = hwloc_alloc_setup_object(topology, type, os_index);\n    obj->cpuset = hwloc_bitmap_dup(set);\n\n    if (type == HWLOC_OBJ_NUMANODE) {\n      obj->nodeset = hwloc_bitmap_alloc();\n      hwloc_bitmap_set(obj->nodeset, os_index);\n    }\n\n    hwloc_synthetic_set_attr(&curlevel->attr, obj);\n\n    hwloc__insert_object_by_cpuset(topology, NULL, obj, \"synthetic\");\n  }\n\n  hwloc_synthetic_insert_attached(topology, data, curlevel->attached, set);\n\n  hwloc_bitmap_free(set);\n}", "path": "xmrig/src/3rdparty/hwloc/src/topology-synthetic.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "xmrig/xmrig", "stars": 8202, "license": "gpl-3.0", "language": "c", "size": 13619}
{"docstring": "// keylen = number of bytes\n", "func_signal": "void hmac_blake224_init(hmac_state *S, const uint8_t *_key, uint64_t keylen)", "code": "{\n    const uint8_t *key = _key;\n    uint8_t keyhash[32];\n    uint8_t pad[64];\n    uint64_t i;\n\n    if (keylen > 64) {\n        blake256_hash(keyhash, key, keylen);\n        key = keyhash;\n        keylen = 28;\n    }\n\n    blake224_init(&S->inner);\n    memset(pad, 0x36, 64);\n    for (i = 0; i < keylen; ++i) {\n        pad[i] ^= key[i];\n    }\n    blake224_update(&S->inner, pad, 512);\n\n    blake224_init(&S->outer);\n    memset(pad, 0x5c, 64);\n    for (i = 0; i < keylen; ++i) {\n        pad[i] ^= key[i];\n    }\n    blake224_update(&S->outer, pad, 512);\n\n    memset(keyhash, 0, 32);\n}", "path": "xmrig/src/crypto/cn/c_blake256.c", "commit_date": "2019-06-04 00:00:00", "repo_name": "xmrig/xmrig", "stars": 8202, "license": "gpl-3.0", "language": "c", "size": 13619}
{"docstring": "/***************Instance and Position constructors**********/\n", "func_signal": "void init_block_value(block *b, uint8_t in)", "code": "{ memset(b->v, in, sizeof(b->v)); }\n\nvoid copy_block(block *dst, const block *src) {\n    memcpy(dst->v, src->v, sizeof(uint64_t) * ARGON2_QWORDS_IN_BLOCK);\n}", "path": "xmrig/src/3rdparty/argon2/lib/core.c", "commit_date": "2020-05-04 00:00:00", "repo_name": "xmrig/xmrig", "stars": 8202, "license": "gpl-3.0", "language": "c", "size": 13619}
{"docstring": "/********************\n * Backend routines *\n ********************/\n", "func_signal": "static void\nhwloc_nolibxml_backend_exit(struct hwloc_xml_backend_data_s *bdata)", "code": "{\n  struct hwloc__nolibxml_backend_data_s *nbdata = bdata->data;\n  hwloc_nolibxml_free_buffers(bdata);\n  free(nbdata);\n}", "path": "xmrig/src/3rdparty/hwloc/src/topology-xml-nolibxml.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "xmrig/xmrig", "stars": 8202, "license": "gpl-3.0", "language": "c", "size": 13619}
{"docstring": "/*\n * Place objects in groups if they are in a transitive graph of minimal values.\n * Return how many groups were created, or 0 if some incomplete distance graphs were found.\n */\n", "func_signal": "static unsigned\nhwloc__find_groups_by_min_distance(unsigned nbobjs,\n\t\t\t\t   uint64_t *_values,\n\t\t\t\t   float accuracy,\n\t\t\t\t   unsigned *groupids,\n\t\t\t\t   int verbose)", "code": "{\n  uint64_t min_distance = UINT64_MAX;\n  unsigned groupid = 1;\n  unsigned i,j,k;\n  unsigned skipped = 0;\n\n#define VALUE(i, j) _values[(i) * nbobjs + (j)]\n\n  memset(groupids, 0, nbobjs*sizeof(*groupids));\n\n  /* find the minimal distance */\n  for(i=0; i<nbobjs; i++)\n    for(j=0; j<nbobjs; j++) /* check the entire matrix, it may not be perfectly symmetric depending on the accuracy */\n      if (i != j && VALUE(i, j) < min_distance) /* no accuracy here, we want the real minimal */\n        min_distance = VALUE(i, j);\n  hwloc_debug(\"  found minimal distance %llu between objects\\n\", (unsigned long long) min_distance);\n\n  if (min_distance == UINT64_MAX)\n    return 0;\n\n  /* build groups of objects connected with this distance */\n  for(i=0; i<nbobjs; i++) {\n    unsigned size;\n    unsigned firstfound;\n\n    /* if already grouped, skip */\n    if (groupids[i])\n      continue;\n\n    /* start a new group */\n    groupids[i] = groupid;\n    size = 1;\n    firstfound = i;\n\n    while (firstfound != (unsigned)-1) {\n      /* we added new objects to the group, the first one was firstfound.\n       * rescan all connections from these new objects (starting at first found) to any other objects,\n       * so as to find new objects minimally-connected by transivity.\n       */\n      unsigned newfirstfound = (unsigned)-1;\n      for(j=firstfound; j<nbobjs; j++)\n\tif (groupids[j] == groupid)\n\t  for(k=0; k<nbobjs; k++)\n              if (!groupids[k] && !hwloc_compare_values(VALUE(j, k), min_distance, accuracy)) {\n\t      groupids[k] = groupid;\n\t      size++;\n\t      if (newfirstfound == (unsigned)-1)\n\t\tnewfirstfound = k;\n\t      if (i == j)\n\t\thwloc_debug(\"  object %u is minimally connected to %u\\n\", k, i);\n\t      else\n\t        hwloc_debug(\"  object %u is minimally connected to %u through %u\\n\", k, i, j);\n\t    }\n      firstfound = newfirstfound;\n    }\n\n    if (size == 1) {\n      /* cancel this useless group, ignore this object and try from the next one */\n      groupids[i] = 0;\n      skipped++;\n      continue;\n    }\n\n    /* valid this group */\n    groupid++;\n    if (verbose)\n      fprintf(stderr, \" Found transitive graph with %u objects with minimal distance %llu accuracy %f\\n\",\n\t      size, (unsigned long long) min_distance, accuracy);\n  }\n\n  if (groupid == 2 && !skipped)\n    /* we created a single group containing all objects, ignore it */\n    return 0;\n\n  /* return the last id, since it's also the number of used group ids */\n  return groupid-1;\n}", "path": "xmrig/src/3rdparty/hwloc/src/distances.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "xmrig/xmrig", "stars": 8202, "license": "gpl-3.0", "language": "c", "size": 13619}
{"docstring": "/******************************************************\n * Refresh objects in distances\n */\n", "func_signal": "static void\nhwloc_internal_distances_restrict(hwloc_obj_t *objs,\n\t\t\t\t  uint64_t *indexes,\n\t\t\t\t  uint64_t *values,\n\t\t\t\t  unsigned nbobjs, unsigned disappeared)", "code": "{\n  unsigned i, newi;\n  unsigned j, newj;\n\n  for(i=0, newi=0; i<nbobjs; i++)\n    if (objs[i]) {\n      for(j=0, newj=0; j<nbobjs; j++)\n\tif (objs[j]) {\n\t  values[newi*(nbobjs-disappeared)+newj] = values[i*nbobjs+j];\n\t  newj++;\n\t}\n      newi++;\n    }\n\n  for(i=0, newi=0; i<nbobjs; i++)\n    if (objs[i]) {\n      objs[newi] = objs[i];\n      if (indexes)\n\tindexes[newi] = indexes[i];\n      newi++;\n    }\n}", "path": "xmrig/src/3rdparty/hwloc/src/distances.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "xmrig/xmrig", "stars": 8202, "license": "gpl-3.0", "language": "c", "size": 13619}
{"docstring": "/* Read from description a series of integers describing a symmetrical\n   topology and update the hwloc_synthetic_backend_data_s accordingly.  On\n   success, return zero.  */\n", "func_signal": "static int\nhwloc_backend_synthetic_init(struct hwloc_synthetic_backend_data_s *data,\n\t\t\t     const char *description)", "code": "{\n  const char *pos, *next_pos;\n  unsigned long item, count;\n  unsigned i;\n  int type_count[HWLOC_OBJ_TYPE_MAX];\n  unsigned unset;\n  int verbose = 0;\n  const char *env = getenv(\"HWLOC_SYNTHETIC_VERBOSE\");\n  int err;\n  unsigned long totalarity = 1;\n\n  if (env)\n    verbose = atoi(env);\n\n  data->numa_attached_nr = 0;\n  data->numa_attached_indexes.array = NULL;\n\n  /* default values before we add root attributes */\n  data->level[0].totalwidth = 1;\n  data->level[0].attr.type = HWLOC_OBJ_MACHINE;\n  data->level[0].indexes.string = NULL;\n  data->level[0].indexes.array = NULL;\n  data->level[0].attr.memorysize = 0;\n  data->level[0].attached = NULL;\n  type_count[HWLOC_OBJ_MACHINE] = 1;\n  if (*description == '(') {\n    err = hwloc_synthetic_parse_attrs(description+1, &description, &data->level[0].attr, &data->level[0].indexes, verbose);\n    if (err < 0)\n      return err;\n  }\n\n  data->numa_attached_indexes.string = NULL;\n  data->numa_attached_indexes.array = NULL;\n\n  for (pos = description, count = 1; *pos; pos = next_pos) {\n    hwloc_obj_type_t type = HWLOC_OBJ_TYPE_NONE;\n    union hwloc_obj_attr_u attrs;\n\n    /* initialize parent arity to 0 so that the levels are not infinite */\n    data->level[count-1].arity = 0;\n\n    while (*pos == ' ' || *pos == '\\n')\n      pos++;\n\n    if (!*pos)\n      break;\n\n    if (*pos == '[') {\n      /* attached */\n      struct hwloc_synthetic_attached_s *attached, **pprev;\n      char *attr;\n\n      pos++;\n\n      if (hwloc_type_sscanf(pos, &type, &attrs, sizeof(attrs)) < 0) {\n\tif (verbose)\n\t  fprintf(stderr, \"Synthetic string with unknown attached object type at '%s'\\n\", pos);\n\terrno = EINVAL;\n\tgoto error;\n      }\n      if (type != HWLOC_OBJ_NUMANODE) {\n\tif (verbose)\n\t  fprintf(stderr, \"Synthetic string with disallowed attached object type at '%s'\\n\", pos);\n\terrno = EINVAL;\n\tgoto error;\n      }\n      data->numa_attached_nr += data->level[count-1].totalwidth;\n\n      attached = malloc(sizeof(*attached));\n      if (attached) {\n\tattached->attr.type = type;\n\tattached->attr.memorysize = 0;\n\t/* attached->attr.depth and .cachetype unused */\n\tattached->next = NULL;\n\tpprev = &data->level[count-1].attached;\n\twhile (*pprev)\n\t  pprev = &((*pprev)->next);\n\t*pprev = attached;\n      }\n\n      next_pos = strchr(pos, ']');\n      if (!next_pos) {\n\tif (verbose)\n\t  fprintf(stderr,\"Synthetic string doesn't have a closing `]' after attached object type at '%s'\\n\", pos);\n\terrno = EINVAL;\n\tgoto error;\n      }\n\n      attr = strchr(pos, '(');\n      if (attr && attr < next_pos && attached) {\n\tconst char *dummy;\n\terr = hwloc_synthetic_parse_attrs(attr+1, &dummy, &attached->attr, &data->numa_attached_indexes, verbose);\n\tif (err < 0)\n\t  goto error;\n      }\n\n      next_pos++;\n      continue;\n    }\n\n    /* normal level */\n\n    /* reset defaults */\n    data->level[count].indexes.string = NULL;\n    data->level[count].indexes.array = NULL;\n    data->level[count].attached = NULL;\n\n    if (*pos < '0' || *pos > '9') {\n      if (hwloc_type_sscanf(pos, &type, &attrs, sizeof(attrs)) < 0) {\n\tif (!strncmp(pos, \"Tile\", 4) || !strncmp(pos, \"Module\", 6)) {\n\t  /* possible future types */\n\t  type = HWLOC_OBJ_GROUP;\n\t} else {\n\t  /* FIXME: allow generic \"Cache\" string? would require to deal with possibly duplicate cache levels */\n\t  if (verbose)\n\t    fprintf(stderr, \"Synthetic string with unknown object type at '%s'\\n\", pos);\n\t  errno = EINVAL;\n\t  goto error;\n\t}\n      }\n      if (type == HWLOC_OBJ_MACHINE || type == HWLOC_OBJ_MISC || type == HWLOC_OBJ_BRIDGE || type == HWLOC_OBJ_PCI_DEVICE || type == HWLOC_OBJ_OS_DEVICE) {\n\tif (verbose)\n\t  fprintf(stderr, \"Synthetic string with disallowed object type at '%s'\\n\", pos);\n\terrno = EINVAL;\n\tgoto error;\n      }\n\n      next_pos = strchr(pos, ':');\n      if (!next_pos) {\n\tif (verbose)\n\t  fprintf(stderr,\"Synthetic string doesn't have a `:' after object type at '%s'\\n\", pos);\n\terrno = EINVAL;\n\tgoto error;\n      }\n      pos = next_pos + 1;\n    }\n\n    data->level[count].attr.type = type;\n    data->level[count].attr.depth = (unsigned) -1;\n    data->level[count].attr.cachetype = (hwloc_obj_cache_type_t) -1;\n    if (hwloc__obj_type_is_cache(type)) {\n      /* these are always initialized */\n      data->level[count].attr.depth = attrs.cache.depth;\n      data->level[count].attr.cachetype = attrs.cache.type;\n    } else if (type == HWLOC_OBJ_GROUP) {\n      /* could be -1 but will be set below */\n      data->level[count].attr.depth = attrs.group.depth;\n    }\n\n    /* number of normal children */\n    item = strtoul(pos, (char **)&next_pos, 0);\n    if (next_pos == pos) {\n      if (verbose)\n\tfprintf(stderr,\"Synthetic string doesn't have a number of objects at '%s'\\n\", pos);\n      errno = EINVAL;\n      goto error;\n    }\n    if (!item) {\n      if (verbose)\n\tfprintf(stderr,\"Synthetic string with disallow 0 number of objects at '%s'\\n\", pos);\n      errno = EINVAL;\n      goto error;\n    }\n\n    totalarity *= item;\n    data->level[count].totalwidth = totalarity;\n    data->level[count].indexes.string = NULL;\n    data->level[count].indexes.array = NULL;\n    data->level[count].attr.memorysize = 0;\n    if (*next_pos == '(') {\n      err = hwloc_synthetic_parse_attrs(next_pos+1, &next_pos, &data->level[count].attr, &data->level[count].indexes, verbose);\n      if (err < 0)\n\tgoto error;\n    }\n\n    if (count + 1 >= HWLOC_SYNTHETIC_MAX_DEPTH) {\n      if (verbose)\n\tfprintf(stderr,\"Too many synthetic levels, max %d\\n\", HWLOC_SYNTHETIC_MAX_DEPTH);\n      errno = EINVAL;\n      goto error;\n    }\n    if (item > UINT_MAX) {\n      if (verbose)\n\tfprintf(stderr,\"Too big arity, max %u\\n\", UINT_MAX);\n      errno = EINVAL;\n      goto error;\n    }\n\n    data->level[count-1].arity = (unsigned)item;\n    count++;\n  }\n\n  if (data->level[count-1].attr.type != HWLOC_OBJ_TYPE_NONE && data->level[count-1].attr.type != HWLOC_OBJ_PU) {\n    if (verbose)\n      fprintf(stderr, \"Synthetic string cannot use non-PU type for last level\\n\");\n    errno = EINVAL;\n    return -1;\n  }\n  data->level[count-1].attr.type = HWLOC_OBJ_PU;\n\n  for(i=HWLOC_OBJ_TYPE_MIN; i<HWLOC_OBJ_TYPE_MAX; i++) {\n    type_count[i] = 0;\n  }\n  for(i=count-1; i>0; i--) {\n    hwloc_obj_type_t type = data->level[i].attr.type;\n    if (type != HWLOC_OBJ_TYPE_NONE) {\n      type_count[type]++;\n    }\n  }\n\n  /* sanity checks */\n  if (!type_count[HWLOC_OBJ_PU]) {\n    if (verbose)\n      fprintf(stderr, \"Synthetic string missing ending number of PUs\\n\");\n    errno = EINVAL;\n    return -1;\n  } else if (type_count[HWLOC_OBJ_PU] > 1) {\n    if (verbose)\n      fprintf(stderr, \"Synthetic string cannot have several PU levels\\n\");\n    errno = EINVAL;\n    return -1;\n  }\n  if (type_count[HWLOC_OBJ_PACKAGE] > 1) {\n    if (verbose)\n      fprintf(stderr, \"Synthetic string cannot have several package levels\\n\");\n    errno = EINVAL;\n    return -1;\n  }\n  if (type_count[HWLOC_OBJ_DIE] > 1) {\n    if (verbose)\n      fprintf(stderr, \"Synthetic string cannot have several die levels\\n\");\n    errno = EINVAL;\n    return -1;\n  }\n  if (type_count[HWLOC_OBJ_NUMANODE] > 1) {\n    if (verbose)\n      fprintf(stderr, \"Synthetic string cannot have several NUMA node levels\\n\");\n    errno = EINVAL;\n    return -1;\n  }\n  if (type_count[HWLOC_OBJ_NUMANODE] && data->numa_attached_nr) {\n    if (verbose)\n      fprintf(stderr,\"Synthetic string cannot have NUMA nodes both as a level and attached\\n\");\n    errno = EINVAL;\n    return -1;\n  }\n  if (type_count[HWLOC_OBJ_CORE] > 1) {\n    if (verbose)\n      fprintf(stderr, \"Synthetic string cannot have several core levels\\n\");\n    errno = EINVAL;\n    return -1;\n  }\n\n  /* deal with missing intermediate levels */\n  unset = 0;\n  for(i=1; i<count-1; i++) {\n    if (data->level[i].attr.type == HWLOC_OBJ_TYPE_NONE)\n      unset++;\n  }\n  if (unset && unset != count-2) {\n    if (verbose)\n      fprintf(stderr, \"Synthetic string cannot mix unspecified and specified types for levels\\n\");\n    errno = EINVAL;\n    return -1;\n  }\n  if (unset) {\n    /* we want in priority: numa, package, core, up to 3 caches, groups */\n    unsigned _count = count;\n    unsigned neednuma = 0;\n    unsigned needpack = 0;\n    unsigned needcore = 0;\n    unsigned needcaches = 0;\n    unsigned needgroups = 0;\n    /* 2 levels for machine and PU */\n    _count -= 2;\n\n    neednuma = (_count >= 1 && !data->numa_attached_nr);\n    _count -= neednuma;\n\n    needpack = (_count >= 1);\n    _count -= needpack;\n\n    needcore = (_count >= 1);\n    _count -= needcore;\n\n    needcaches = (_count > 4 ? 4 : _count);\n    _count -= needcaches;\n\n    needgroups = _count;\n\n    /* we place them in order: groups, package, numa, caches, core */\n    for(i = 0; i < needgroups; i++) {\n      unsigned depth = 1 + i;\n      data->level[depth].attr.type = HWLOC_OBJ_GROUP;\n      type_count[HWLOC_OBJ_GROUP]++;\n    }\n    if (needpack) {\n      unsigned depth = 1 + needgroups;\n      data->level[depth].attr.type = HWLOC_OBJ_PACKAGE;\n      type_count[HWLOC_OBJ_PACKAGE] = 1;\n    }\n    if (neednuma) {\n      unsigned depth = 1 + needgroups + needpack;\n      data->level[depth].attr.type = HWLOC_OBJ_NUMANODE;\n      type_count[HWLOC_OBJ_NUMANODE] = 1;\n    }\n    if (needcaches) {\n      /* priority: l2, l1, l3, l1i */\n      /* order: l3, l2, l1, l1i */\n      unsigned l3depth = 1 + needgroups + needpack + neednuma;\n      unsigned l2depth = l3depth + (needcaches >= 3);\n      unsigned l1depth = l2depth + 1;\n      unsigned l1idepth = l1depth + 1;\n      if (needcaches >= 3) {\n\tdata->level[l3depth].attr.type = HWLOC_OBJ_L3CACHE;\n\tdata->level[l3depth].attr.depth = 3;\n\tdata->level[l3depth].attr.cachetype = HWLOC_OBJ_CACHE_UNIFIED;\n\ttype_count[HWLOC_OBJ_L3CACHE] = 1;\n      }\n      data->level[l2depth].attr.type = HWLOC_OBJ_L2CACHE;\n      data->level[l2depth].attr.depth = 2;\n      data->level[l2depth].attr.cachetype = HWLOC_OBJ_CACHE_UNIFIED;\n      type_count[HWLOC_OBJ_L2CACHE] = 1;\n      if (needcaches >= 2) {\n\tdata->level[l1depth].attr.type = HWLOC_OBJ_L1CACHE;\n\tdata->level[l1depth].attr.depth = 1;\n\tdata->level[l1depth].attr.cachetype = HWLOC_OBJ_CACHE_DATA;\n\ttype_count[HWLOC_OBJ_L1CACHE] = 1;\n      }\n      if (needcaches >= 4) {\n\tdata->level[l1idepth].attr.type = HWLOC_OBJ_L1ICACHE;\n\tdata->level[l1idepth].attr.depth = 1;\n\tdata->level[l1idepth].attr.cachetype = HWLOC_OBJ_CACHE_INSTRUCTION;\n\ttype_count[HWLOC_OBJ_L1ICACHE] = 1;\n      }\n    }\n    if (needcore) {\n      unsigned depth = 1 + needgroups + needpack + neednuma + needcaches;\n      data->level[depth].attr.type = HWLOC_OBJ_CORE;\n      type_count[HWLOC_OBJ_CORE] = 1;\n    }\n  }\n\n  /* enforce a NUMA level */\n  if (!type_count[HWLOC_OBJ_NUMANODE] && !data->numa_attached_nr) {\n    /* insert a NUMA level below the automatic machine root */\n    if (verbose)\n      fprintf(stderr, \"Inserting a NUMA level with a single object at depth 1\\n\");\n    /* move existing levels by one */\n    memmove(&data->level[2], &data->level[1], count*sizeof(struct hwloc_synthetic_level_data_s));\n    data->level[1].attr.type = HWLOC_OBJ_NUMANODE;\n    data->level[1].indexes.string = NULL;\n    data->level[1].indexes.array = NULL;\n    data->level[1].attr.memorysize = 0;\n    data->level[1].totalwidth = data->level[0].totalwidth;\n    /* update arity to insert a single NUMA node per parent */\n    data->level[1].arity = data->level[0].arity;\n    data->level[0].arity = 1;\n    count++;\n  }\n\n  for (i=0; i<count; i++) {\n    struct hwloc_synthetic_level_data_s *curlevel = &data->level[i];\n    hwloc_obj_type_t type = curlevel->attr.type;\n\n    if (type == HWLOC_OBJ_GROUP) {\n      if (curlevel->attr.depth == (unsigned)-1)\n\tcurlevel->attr.depth = type_count[HWLOC_OBJ_GROUP]--;\n\n    } else if (hwloc__obj_type_is_cache(type)) {\n      if (!curlevel->attr.memorysize) {\n\tif (1 == curlevel->attr.depth)\n\t  /* 32Kb in L1 */\n\t  curlevel->attr.memorysize = 32*1024;\n\telse\n\t  /* *4 at each level, starting from 1MB for L2, unified */\n\t  curlevel->attr.memorysize = 256ULL*1024 << (2*curlevel->attr.depth);\n      }\n\n    } else if (type == HWLOC_OBJ_NUMANODE && !curlevel->attr.memorysize) {\n      /* 1GB in memory nodes. */\n      curlevel->attr.memorysize = 1024*1024*1024;\n    }\n\n    hwloc_synthetic_process_indexes(data, &data->level[i].indexes, data->level[i].totalwidth, verbose);\n  }\n\n  hwloc_synthetic_process_indexes(data, &data->numa_attached_indexes, data->numa_attached_nr, verbose);\n\n  data->string = strdup(description);\n  data->level[count-1].arity = 0;\n  return 0;\n\n error:\n  hwloc_synthetic_free_levels(data);\n  return -1;\n}", "path": "xmrig/src/3rdparty/hwloc/src/topology-synthetic.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "xmrig/xmrig", "stars": 8202, "license": "gpl-3.0", "language": "c", "size": 13619}
{"docstring": "// datalen = number of bits\n", "func_signal": "void blake256_update(state *S, const uint8_t *data, uint64_t datalen)", "code": "{\n    int left = S->buflen >> 3;\n    int fill = 64 - left;\n\n    if (left && (((datalen >> 3) & 0x3F) >= (unsigned) fill)) {\n        memcpy((void *) (S->buf + left), (void *) data, fill);\n        S->t[0] += 512;\n        if (S->t[0] == 0) S->t[1]++;\n        blake256_compress(S, S->buf);\n        data += fill;\n        datalen -= (fill << 3);\n        left = 0;\n    }\n\n    while (datalen >= 512) {\n        S->t[0] += 512;\n        if (S->t[0] == 0) S->t[1]++;\n        blake256_compress(S, data);\n        data += 64;\n        datalen -= 512;\n    }\n\n    if (datalen > 0) {\n        memcpy((void *) (S->buf + left), (void *) data, datalen >> 3);\n        S->buflen = (left << 3) + (int) datalen;\n    } else {\n        S->buflen = 0;\n    }\n}", "path": "xmrig/src/crypto/cn/c_blake256.c", "commit_date": "2019-06-04 00:00:00", "repo_name": "xmrig/xmrig", "stars": 8202, "license": "gpl-3.0", "language": "c", "size": 13619}
{"docstring": "// inlen = number of bytes\n", "func_signal": "void blake256_hash(uint8_t *out, const uint8_t *in, uint64_t inlen)", "code": "{\n    state S;\n    blake256_init(&S);\n    blake256_update(&S, in, inlen * 8);\n    blake256_final(&S, out);\n}", "path": "xmrig/src/crypto/cn/c_blake256.c", "commit_date": "2019-06-04 00:00:00", "repo_name": "xmrig/xmrig", "stars": 8202, "license": "gpl-3.0", "language": "c", "size": 13619}
{"docstring": "/* The actual function exported to the user\n */\n", "func_signal": "int hwloc_distances_add(hwloc_topology_t topology,\n\t\t\tunsigned nbobjs, hwloc_obj_t *objs, hwloc_uint64_t *values,\n\t\t\tunsigned long kind, unsigned long flags)", "code": "{\n  unsigned i;\n  uint64_t *_values;\n  hwloc_obj_t *_objs;\n  int err;\n\n  if (nbobjs < 2 || !objs || !values || !topology->is_loaded) {\n    errno = EINVAL;\n    return -1;\n  }\n  if (topology->adopted_shmem_addr) {\n    errno = EPERM;\n    return -1;\n  }\n  if ((kind & ~HWLOC_DISTANCES_KIND_ALL)\n      || hwloc_weight_long(kind & HWLOC_DISTANCES_KIND_FROM_ALL) != 1\n      || hwloc_weight_long(kind & HWLOC_DISTANCES_KIND_MEANS_ALL) != 1\n      || (flags & ~HWLOC_DISTANCES_ADD_FLAG_ALL)) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  /* no strict need to check for duplicates, things shouldn't break */\n\n  for(i=1; i<nbobjs; i++)\n    if (!objs[i]) {\n      errno = EINVAL;\n      return -1;\n    }\n\n  /* copy the input arrays and give them to the topology */\n  _objs = malloc(nbobjs*sizeof(hwloc_obj_t));\n  _values = malloc(nbobjs*nbobjs*sizeof(*_values));\n  if (!_objs || !_values)\n    goto out_with_arrays;\n\n  memcpy(_objs, objs, nbobjs*sizeof(hwloc_obj_t));\n  memcpy(_values, values, nbobjs*nbobjs*sizeof(*_values));\n  err = hwloc_internal_distances_add(topology, NULL, nbobjs, _objs, _values, kind, flags);\n  if (err < 0)\n    goto out; /* _objs and _values freed in hwloc_internal_distances_add() */\n\n  /* in case we added some groups, see if we need to reconnect */\n  hwloc_topology_reconnect(topology, 0);\n\n  return 0;\n\n out_with_arrays:\n  free(_values);\n  free(_objs);\n out:\n  return -1;\n}", "path": "xmrig/src/3rdparty/hwloc/src/distances.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "xmrig/xmrig", "stars": 8202, "license": "gpl-3.0", "language": "c", "size": 13619}
{"docstring": "/* This function may be called with topology->tma set, it cannot free() or realloc() */\n", "func_signal": "int hwloc_internal_distances_dup(struct hwloc_topology *new, struct hwloc_topology *old)", "code": "{\n  struct hwloc_internal_distances_s *olddist;\n  int err;\n  new->next_dist_id = old->next_dist_id;\n  for(olddist = old->first_dist; olddist; olddist = olddist->next) {\n    err = hwloc_internal_distances_dup_one(new, olddist);\n    if (err < 0)\n      return err;\n  }\n  return 0;\n}", "path": "xmrig/src/3rdparty/hwloc/src/distances.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "xmrig/xmrig", "stars": 8202, "license": "gpl-3.0", "language": "c", "size": 13619}
{"docstring": "/* encode 16 bits unsigned int (lsb) */\n", "func_signal": "static inline char *ikcp_encode16u(char *p, unsigned short w)", "code": "{\n#if IWORDS_BIG_ENDIAN || IWORDS_MUST_ALIGN\n\t*(unsigned char*)(p + 0) = (w & 255);\n\t*(unsigned char*)(p + 1) = (w >> 8);\n#else\n\tmemcpy(p, &w, 2);\n#endif\n\tp += 2;\n\treturn p;\n}", "path": "kcp/ikcp.c", "commit_date": "2020-09-16 00:00:00", "repo_name": "skywind3000/kcp", "stars": 14413, "license": "mit", "language": "c", "size": 562}
{"docstring": "//---------------------------------------------------------------------\n// ikcp_flush\n//---------------------------------------------------------------------\n", "func_signal": "void ikcp_flush(ikcpcb *kcp)", "code": "{\n\tIUINT32 current = kcp->current;\n\tchar *buffer = kcp->buffer;\n\tchar *ptr = buffer;\n\tint count, size, i;\n\tIUINT32 resent, cwnd;\n\tIUINT32 rtomin;\n\tstruct IQUEUEHEAD *p;\n\tint change = 0;\n\tint lost = 0;\n\tIKCPSEG seg;\n\n\t// 'ikcp_update' haven't been called. \n\tif (kcp->updated == 0) return;\n\n\tseg.conv = kcp->conv;\n\tseg.cmd = IKCP_CMD_ACK;\n\tseg.frg = 0;\n\tseg.wnd = ikcp_wnd_unused(kcp);\n\tseg.una = kcp->rcv_nxt;\n\tseg.len = 0;\n\tseg.sn = 0;\n\tseg.ts = 0;\n\n\t// flush acknowledges\n\tcount = kcp->ackcount;\n\tfor (i = 0; i < count; i++) {\n\t\tsize = (int)(ptr - buffer);\n\t\tif (size + (int)IKCP_OVERHEAD > (int)kcp->mtu) {\n\t\t\tikcp_output(kcp, buffer, size);\n\t\t\tptr = buffer;\n\t\t}\n\t\tikcp_ack_get(kcp, i, &seg.sn, &seg.ts);\n\t\tptr = ikcp_encode_seg(ptr, &seg);\n\t}\n\n\tkcp->ackcount = 0;\n\n\t// probe window size (if remote window size equals zero)\n\tif (kcp->rmt_wnd == 0) {\n\t\tif (kcp->probe_wait == 0) {\n\t\t\tkcp->probe_wait = IKCP_PROBE_INIT;\n\t\t\tkcp->ts_probe = kcp->current + kcp->probe_wait;\n\t\t}\t\n\t\telse {\n\t\t\tif (_itimediff(kcp->current, kcp->ts_probe) >= 0) {\n\t\t\t\tif (kcp->probe_wait < IKCP_PROBE_INIT) \n\t\t\t\t\tkcp->probe_wait = IKCP_PROBE_INIT;\n\t\t\t\tkcp->probe_wait += kcp->probe_wait / 2;\n\t\t\t\tif (kcp->probe_wait > IKCP_PROBE_LIMIT)\n\t\t\t\t\tkcp->probe_wait = IKCP_PROBE_LIMIT;\n\t\t\t\tkcp->ts_probe = kcp->current + kcp->probe_wait;\n\t\t\t\tkcp->probe |= IKCP_ASK_SEND;\n\t\t\t}\n\t\t}\n\t}\telse {\n\t\tkcp->ts_probe = 0;\n\t\tkcp->probe_wait = 0;\n\t}\n\n\t// flush window probing commands\n\tif (kcp->probe & IKCP_ASK_SEND) {\n\t\tseg.cmd = IKCP_CMD_WASK;\n\t\tsize = (int)(ptr - buffer);\n\t\tif (size + (int)IKCP_OVERHEAD > (int)kcp->mtu) {\n\t\t\tikcp_output(kcp, buffer, size);\n\t\t\tptr = buffer;\n\t\t}\n\t\tptr = ikcp_encode_seg(ptr, &seg);\n\t}\n\n\t// flush window probing commands\n\tif (kcp->probe & IKCP_ASK_TELL) {\n\t\tseg.cmd = IKCP_CMD_WINS;\n\t\tsize = (int)(ptr - buffer);\n\t\tif (size + (int)IKCP_OVERHEAD > (int)kcp->mtu) {\n\t\t\tikcp_output(kcp, buffer, size);\n\t\t\tptr = buffer;\n\t\t}\n\t\tptr = ikcp_encode_seg(ptr, &seg);\n\t}\n\n\tkcp->probe = 0;\n\n\t// calculate window size\n\tcwnd = _imin_(kcp->snd_wnd, kcp->rmt_wnd);\n\tif (kcp->nocwnd == 0) cwnd = _imin_(kcp->cwnd, cwnd);\n\n\t// move data from snd_queue to snd_buf\n\twhile (_itimediff(kcp->snd_nxt, kcp->snd_una + cwnd) < 0) {\n\t\tIKCPSEG *newseg;\n\t\tif (iqueue_is_empty(&kcp->snd_queue)) break;\n\n\t\tnewseg = iqueue_entry(kcp->snd_queue.next, IKCPSEG, node);\n\n\t\tiqueue_del(&newseg->node);\n\t\tiqueue_add_tail(&newseg->node, &kcp->snd_buf);\n\t\tkcp->nsnd_que--;\n\t\tkcp->nsnd_buf++;\n\n\t\tnewseg->conv = kcp->conv;\n\t\tnewseg->cmd = IKCP_CMD_PUSH;\n\t\tnewseg->wnd = seg.wnd;\n\t\tnewseg->ts = current;\n\t\tnewseg->sn = kcp->snd_nxt++;\n\t\tnewseg->una = kcp->rcv_nxt;\n\t\tnewseg->resendts = current;\n\t\tnewseg->rto = kcp->rx_rto;\n\t\tnewseg->fastack = 0;\n\t\tnewseg->xmit = 0;\n\t}\n\n\t// calculate resent\n\tresent = (kcp->fastresend > 0)? (IUINT32)kcp->fastresend : 0xffffffff;\n\trtomin = (kcp->nodelay == 0)? (kcp->rx_rto >> 3) : 0;\n\n\t// flush data segments\n\tfor (p = kcp->snd_buf.next; p != &kcp->snd_buf; p = p->next) {\n\t\tIKCPSEG *segment = iqueue_entry(p, IKCPSEG, node);\n\t\tint needsend = 0;\n\t\tif (segment->xmit == 0) {\n\t\t\tneedsend = 1;\n\t\t\tsegment->xmit++;\n\t\t\tsegment->rto = kcp->rx_rto;\n\t\t\tsegment->resendts = current + segment->rto + rtomin;\n\t\t}\n\t\telse if (_itimediff(current, segment->resendts) >= 0) {\n\t\t\tneedsend = 1;\n\t\t\tsegment->xmit++;\n\t\t\tkcp->xmit++;\n\t\t\tif (kcp->nodelay == 0) {\n\t\t\t\tsegment->rto += _imax_(segment->rto, (IUINT32)kcp->rx_rto);\n\t\t\t}\telse {\n\t\t\t\tIINT32 step = (kcp->nodelay < 2)? \n\t\t\t\t\t((IINT32)(segment->rto)) : kcp->rx_rto;\n\t\t\t\tsegment->rto += step / 2;\n\t\t\t}\n\t\t\tsegment->resendts = current + segment->rto;\n\t\t\tlost = 1;\n\t\t}\n\t\telse if (segment->fastack >= resent) {\n\t\t\tif ((int)segment->xmit <= kcp->fastlimit || \n\t\t\t\tkcp->fastlimit <= 0) {\n\t\t\t\tneedsend = 1;\n\t\t\t\tsegment->xmit++;\n\t\t\t\tsegment->fastack = 0;\n\t\t\t\tsegment->resendts = current + segment->rto;\n\t\t\t\tchange++;\n\t\t\t}\n\t\t}\n\n\t\tif (needsend) {\n\t\t\tint need;\n\t\t\tsegment->ts = current;\n\t\t\tsegment->wnd = seg.wnd;\n\t\t\tsegment->una = kcp->rcv_nxt;\n\n\t\t\tsize = (int)(ptr - buffer);\n\t\t\tneed = IKCP_OVERHEAD + segment->len;\n\n\t\t\tif (size + need > (int)kcp->mtu) {\n\t\t\t\tikcp_output(kcp, buffer, size);\n\t\t\t\tptr = buffer;\n\t\t\t}\n\n\t\t\tptr = ikcp_encode_seg(ptr, segment);\n\n\t\t\tif (segment->len > 0) {\n\t\t\t\tmemcpy(ptr, segment->data, segment->len);\n\t\t\t\tptr += segment->len;\n\t\t\t}\n\n\t\t\tif (segment->xmit >= kcp->dead_link) {\n\t\t\t\tkcp->state = (IUINT32)-1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// flash remain segments\n\tsize = (int)(ptr - buffer);\n\tif (size > 0) {\n\t\tikcp_output(kcp, buffer, size);\n\t}\n\n\t// update ssthresh\n\tif (change) {\n\t\tIUINT32 inflight = kcp->snd_nxt - kcp->snd_una;\n\t\tkcp->ssthresh = inflight / 2;\n\t\tif (kcp->ssthresh < IKCP_THRESH_MIN)\n\t\t\tkcp->ssthresh = IKCP_THRESH_MIN;\n\t\tkcp->cwnd = kcp->ssthresh + resent;\n\t\tkcp->incr = kcp->cwnd * kcp->mss;\n\t}\n\n\tif (lost) {\n\t\tkcp->ssthresh = cwnd / 2;\n\t\tif (kcp->ssthresh < IKCP_THRESH_MIN)\n\t\t\tkcp->ssthresh = IKCP_THRESH_MIN;\n\t\tkcp->cwnd = 1;\n\t\tkcp->incr = kcp->mss;\n\t}\n\n\tif (kcp->cwnd < 1) {\n\t\tkcp->cwnd = 1;\n\t\tkcp->incr = kcp->mss;\n\t}\n}", "path": "kcp/ikcp.c", "commit_date": "2020-09-16 00:00:00", "repo_name": "skywind3000/kcp", "stars": 14413, "license": "mit", "language": "c", "size": 562}
{"docstring": "// redefine allocator\n", "func_signal": "void ikcp_allocator(void* (*new_malloc)(size_t), void (*new_free)(void*))", "code": "{\n\tikcp_malloc_hook = new_malloc;\n\tikcp_free_hook = new_free;\n}", "path": "kcp/ikcp.c", "commit_date": "2020-09-16 00:00:00", "repo_name": "skywind3000/kcp", "stars": 14413, "license": "mit", "language": "c", "size": 562}
{"docstring": "// write log\n", "func_signal": "void ikcp_log(ikcpcb *kcp, int mask, const char *fmt, ...)", "code": "{\n\tchar buffer[1024];\n\tva_list argptr;\n\tif ((mask & kcp->logmask) == 0 || kcp->writelog == 0) return;\n\tva_start(argptr, fmt);\n\tvsprintf(buffer, fmt, argptr);\n\tva_end(argptr);\n\tkcp->writelog(buffer, kcp, kcp->user);\n}", "path": "kcp/ikcp.c", "commit_date": "2020-09-16 00:00:00", "repo_name": "skywind3000/kcp", "stars": 14413, "license": "mit", "language": "c", "size": 562}
{"docstring": "/* decode 8 bits unsigned int */\n", "func_signal": "static inline const char *ikcp_decode8u(const char *p, unsigned char *c)", "code": "{\n\t*c = *(unsigned char*)p++;\n\treturn p;\n}", "path": "kcp/ikcp.c", "commit_date": "2020-09-16 00:00:00", "repo_name": "skywind3000/kcp", "stars": 14413, "license": "mit", "language": "c", "size": 562}
{"docstring": "//---------------------------------------------------------------------\n// update state (call it repeatedly, every 10ms-100ms), or you can ask \n// ikcp_check when to call it again (without ikcp_input/_send calling).\n// 'current' - current timestamp in millisec. \n//---------------------------------------------------------------------\n", "func_signal": "void ikcp_update(ikcpcb *kcp, IUINT32 current)", "code": "{\n\tIINT32 slap;\n\n\tkcp->current = current;\n\n\tif (kcp->updated == 0) {\n\t\tkcp->updated = 1;\n\t\tkcp->ts_flush = kcp->current;\n\t}\n\n\tslap = _itimediff(kcp->current, kcp->ts_flush);\n\n\tif (slap >= 10000 || slap < -10000) {\n\t\tkcp->ts_flush = kcp->current;\n\t\tslap = 0;\n\t}\n\n\tif (slap >= 0) {\n\t\tkcp->ts_flush += kcp->interval;\n\t\tif (_itimediff(kcp->current, kcp->ts_flush) >= 0) {\n\t\t\tkcp->ts_flush = kcp->current + kcp->interval;\n\t\t}\n\t\tikcp_flush(kcp);\n\t}\n}", "path": "kcp/ikcp.c", "commit_date": "2020-09-16 00:00:00", "repo_name": "skywind3000/kcp", "stars": 14413, "license": "mit", "language": "c", "size": 562}
{"docstring": "//---------------------------------------------------------------------\n// parse data\n//---------------------------------------------------------------------\n", "func_signal": "void ikcp_parse_data(ikcpcb *kcp, IKCPSEG *newseg)", "code": "{\n\tstruct IQUEUEHEAD *p, *prev;\n\tIUINT32 sn = newseg->sn;\n\tint repeat = 0;\n\t\n\tif (_itimediff(sn, kcp->rcv_nxt + kcp->rcv_wnd) >= 0 ||\n\t\t_itimediff(sn, kcp->rcv_nxt) < 0) {\n\t\tikcp_segment_delete(kcp, newseg);\n\t\treturn;\n\t}\n\n\tfor (p = kcp->rcv_buf.prev; p != &kcp->rcv_buf; p = prev) {\n\t\tIKCPSEG *seg = iqueue_entry(p, IKCPSEG, node);\n\t\tprev = p->prev;\n\t\tif (seg->sn == sn) {\n\t\t\trepeat = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (_itimediff(sn, seg->sn) > 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (repeat == 0) {\n\t\tiqueue_init(&newseg->node);\n\t\tiqueue_add(&newseg->node, p);\n\t\tkcp->nrcv_buf++;\n\t}\telse {\n\t\tikcp_segment_delete(kcp, newseg);\n\t}\n\n#if 0\n\tikcp_qprint(\"rcvbuf\", &kcp->rcv_buf);\n\tprintf(\"rcv_nxt=%lu\\n\", kcp->rcv_nxt);\n#endif\n\n\t// move available data from rcv_buf -> rcv_queue\n\twhile (! iqueue_is_empty(&kcp->rcv_buf)) {\n\t\tIKCPSEG *seg = iqueue_entry(kcp->rcv_buf.next, IKCPSEG, node);\n\t\tif (seg->sn == kcp->rcv_nxt && kcp->nrcv_que < kcp->rcv_wnd) {\n\t\t\tiqueue_del(&seg->node);\n\t\t\tkcp->nrcv_buf--;\n\t\t\tiqueue_add_tail(&seg->node, &kcp->rcv_queue);\n\t\t\tkcp->nrcv_que++;\n\t\t\tkcp->rcv_nxt++;\n\t\t}\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n#if 0\n\tikcp_qprint(\"queue\", &kcp->rcv_queue);\n\tprintf(\"rcv_nxt=%lu\\n\", kcp->rcv_nxt);\n#endif\n\n#if 1\n//\tprintf(\"snd(buf=%d, queue=%d)\\n\", kcp->nsnd_buf, kcp->nsnd_que);\n//\tprintf(\"rcv(buf=%d, queue=%d)\\n\", kcp->nrcv_buf, kcp->nrcv_que);\n#endif\n}", "path": "kcp/ikcp.c", "commit_date": "2020-09-16 00:00:00", "repo_name": "skywind3000/kcp", "stars": 14413, "license": "mit", "language": "c", "size": 562}
{"docstring": "// check log mask\n", "func_signal": "static int ikcp_canlog(const ikcpcb *kcp, int mask)", "code": "{\n\tif ((mask & kcp->logmask) == 0 || kcp->writelog == NULL) return 0;\n\treturn 1;\n}", "path": "kcp/ikcp.c", "commit_date": "2020-09-16 00:00:00", "repo_name": "skywind3000/kcp", "stars": 14413, "license": "mit", "language": "c", "size": 562}
{"docstring": "/* encode 32 bits unsigned int (lsb) */\n", "func_signal": "static inline char *ikcp_encode32u(char *p, IUINT32 l)", "code": "{\n#if IWORDS_BIG_ENDIAN || IWORDS_MUST_ALIGN\n\t*(unsigned char*)(p + 0) = (unsigned char)((l >>  0) & 0xff);\n\t*(unsigned char*)(p + 1) = (unsigned char)((l >>  8) & 0xff);\n\t*(unsigned char*)(p + 2) = (unsigned char)((l >> 16) & 0xff);\n\t*(unsigned char*)(p + 3) = (unsigned char)((l >> 24) & 0xff);\n#else\n\tmemcpy(p, &l, 4);\n#endif\n\tp += 4;\n\treturn p;\n}", "path": "kcp/ikcp.c", "commit_date": "2020-09-16 00:00:00", "repo_name": "skywind3000/kcp", "stars": 14413, "license": "mit", "language": "c", "size": 562}
{"docstring": "/* decode 32 bits unsigned int (lsb) */\n", "func_signal": "static inline const char *ikcp_decode32u(const char *p, IUINT32 *l)", "code": "{\n#if IWORDS_BIG_ENDIAN || IWORDS_MUST_ALIGN\n\t*l = *(const unsigned char*)(p + 3);\n\t*l = *(const unsigned char*)(p + 2) + (*l << 8);\n\t*l = *(const unsigned char*)(p + 1) + (*l << 8);\n\t*l = *(const unsigned char*)(p + 0) + (*l << 8);\n#else \n\tmemcpy(l, p, 4);\n#endif\n\tp += 4;\n\treturn p;\n}", "path": "kcp/ikcp.c", "commit_date": "2020-09-16 00:00:00", "repo_name": "skywind3000/kcp", "stars": 14413, "license": "mit", "language": "c", "size": 562}
{"docstring": "/* encode 8 bits unsigned int */\n", "func_signal": "static inline char *ikcp_encode8u(char *p, unsigned char c)", "code": "{\n\t*(unsigned char*)p++ = c;\n\treturn p;\n}", "path": "kcp/ikcp.c", "commit_date": "2020-09-16 00:00:00", "repo_name": "skywind3000/kcp", "stars": 14413, "license": "mit", "language": "c", "size": 562}
{"docstring": "//---------------------------------------------------------------------\n// ack append\n//---------------------------------------------------------------------\n", "func_signal": "static void ikcp_ack_push(ikcpcb *kcp, IUINT32 sn, IUINT32 ts)", "code": "{\n\tIUINT32 newsize = kcp->ackcount + 1;\n\tIUINT32 *ptr;\n\n\tif (newsize > kcp->ackblock) {\n\t\tIUINT32 *acklist;\n\t\tIUINT32 newblock;\n\n\t\tfor (newblock = 8; newblock < newsize; newblock <<= 1);\n\t\tacklist = (IUINT32*)ikcp_malloc(newblock * sizeof(IUINT32) * 2);\n\n\t\tif (acklist == NULL) {\n\t\t\tassert(acklist != NULL);\n\t\t\tabort();\n\t\t}\n\n\t\tif (kcp->acklist != NULL) {\n\t\t\tIUINT32 x;\n\t\t\tfor (x = 0; x < kcp->ackcount; x++) {\n\t\t\t\tacklist[x * 2 + 0] = kcp->acklist[x * 2 + 0];\n\t\t\t\tacklist[x * 2 + 1] = kcp->acklist[x * 2 + 1];\n\t\t\t}\n\t\t\tikcp_free(kcp->acklist);\n\t\t}\n\n\t\tkcp->acklist = acklist;\n\t\tkcp->ackblock = newblock;\n\t}\n\n\tptr = &kcp->acklist[kcp->ackcount * 2];\n\tptr[0] = sn;\n\tptr[1] = ts;\n\tkcp->ackcount++;\n}", "path": "kcp/ikcp.c", "commit_date": "2020-09-16 00:00:00", "repo_name": "skywind3000/kcp", "stars": 14413, "license": "mit", "language": "c", "size": 562}
{"docstring": "//---------------------------------------------------------------------\n// parse ack\n//---------------------------------------------------------------------\n", "func_signal": "static void ikcp_update_ack(ikcpcb *kcp, IINT32 rtt)", "code": "{\n\tIINT32 rto = 0;\n\tif (kcp->rx_srtt == 0) {\n\t\tkcp->rx_srtt = rtt;\n\t\tkcp->rx_rttval = rtt / 2;\n\t}\telse {\n\t\tlong delta = rtt - kcp->rx_srtt;\n\t\tif (delta < 0) delta = -delta;\n\t\tkcp->rx_rttval = (3 * kcp->rx_rttval + delta) / 4;\n\t\tkcp->rx_srtt = (7 * kcp->rx_srtt + rtt) / 8;\n\t\tif (kcp->rx_srtt < 1) kcp->rx_srtt = 1;\n\t}\n\trto = kcp->rx_srtt + _imax_(kcp->interval, 4 * kcp->rx_rttval);\n\tkcp->rx_rto = _ibound_(kcp->rx_minrto, rto, IKCP_RTO_MAX);\n}", "path": "kcp/ikcp.c", "commit_date": "2020-09-16 00:00:00", "repo_name": "skywind3000/kcp", "stars": 14413, "license": "mit", "language": "c", "size": 562}
{"docstring": "// output segment\n", "func_signal": "static int ikcp_output(ikcpcb *kcp, const void *data, int size)", "code": "{\n\tassert(kcp);\n\tassert(kcp->output);\n\tif (ikcp_canlog(kcp, IKCP_LOG_OUTPUT)) {\n\t\tikcp_log(kcp, IKCP_LOG_OUTPUT, \"[RO] %ld bytes\", (long)size);\n\t}\n\tif (size == 0) return 0;\n\treturn kcp->output((const char*)data, size, kcp, kcp->user);\n}", "path": "kcp/ikcp.c", "commit_date": "2020-09-16 00:00:00", "repo_name": "skywind3000/kcp", "stars": 14413, "license": "mit", "language": "c", "size": 562}
{"docstring": "// internal malloc\n", "func_signal": "static void* ikcp_malloc(size_t size)", "code": "{\n\tif (ikcp_malloc_hook) \n\t\treturn ikcp_malloc_hook(size);\n\treturn malloc(size);\n}", "path": "kcp/ikcp.c", "commit_date": "2020-09-16 00:00:00", "repo_name": "skywind3000/kcp", "stars": 14413, "license": "mit", "language": "c", "size": 562}
{"docstring": "/* decode 16 bits unsigned int (lsb) */\n", "func_signal": "static inline const char *ikcp_decode16u(const char *p, unsigned short *w)", "code": "{\n#if IWORDS_BIG_ENDIAN || IWORDS_MUST_ALIGN\n\t*w = *(const unsigned char*)(p + 1);\n\t*w = *(const unsigned char*)(p + 0) + (*w << 8);\n#else\n\tmemcpy(w, p, 2);\n#endif\n\tp += 2;\n\treturn p;\n}", "path": "kcp/ikcp.c", "commit_date": "2020-09-16 00:00:00", "repo_name": "skywind3000/kcp", "stars": 14413, "license": "mit", "language": "c", "size": 562}
{"docstring": "// read conv\n", "func_signal": "IUINT32 ikcp_getconv(const void *ptr)", "code": "{\n\tIUINT32 conv;\n\tikcp_decode32u((const char*)ptr, &conv);\n\treturn conv;\n}", "path": "kcp/ikcp.c", "commit_date": "2020-09-16 00:00:00", "repo_name": "skywind3000/kcp", "stars": 14413, "license": "mit", "language": "c", "size": 562}
{"docstring": "//---------------------------------------------------------------------\n// ikcp_encode_seg\n//---------------------------------------------------------------------\n", "func_signal": "static char *ikcp_encode_seg(char *ptr, const IKCPSEG *seg)", "code": "{\n\tptr = ikcp_encode32u(ptr, seg->conv);\n\tptr = ikcp_encode8u(ptr, (IUINT8)seg->cmd);\n\tptr = ikcp_encode8u(ptr, (IUINT8)seg->frg);\n\tptr = ikcp_encode16u(ptr, (IUINT16)seg->wnd);\n\tptr = ikcp_encode32u(ptr, seg->ts);\n\tptr = ikcp_encode32u(ptr, seg->sn);\n\tptr = ikcp_encode32u(ptr, seg->una);\n\tptr = ikcp_encode32u(ptr, seg->len);\n\treturn ptr;\n}", "path": "kcp/ikcp.c", "commit_date": "2020-09-16 00:00:00", "repo_name": "skywind3000/kcp", "stars": 14413, "license": "mit", "language": "c", "size": 562}
{"docstring": "//---------------------------------------------------------------------\n// Determine when should you invoke ikcp_update:\n// returns when you should invoke ikcp_update in millisec, if there \n// is no ikcp_input/_send calling. you can call ikcp_update in that\n// time, instead of call update repeatly.\n// Important to reduce unnacessary ikcp_update invoking. use it to \n// schedule ikcp_update (eg. implementing an epoll-like mechanism, \n// or optimize ikcp_update when handling massive kcp connections)\n//---------------------------------------------------------------------\n", "func_signal": "IUINT32 ikcp_check(const ikcpcb *kcp, IUINT32 current)", "code": "{\n\tIUINT32 ts_flush = kcp->ts_flush;\n\tIINT32 tm_flush = 0x7fffffff;\n\tIINT32 tm_packet = 0x7fffffff;\n\tIUINT32 minimal = 0;\n\tstruct IQUEUEHEAD *p;\n\n\tif (kcp->updated == 0) {\n\t\treturn current;\n\t}\n\n\tif (_itimediff(current, ts_flush) >= 10000 ||\n\t\t_itimediff(current, ts_flush) < -10000) {\n\t\tts_flush = current;\n\t}\n\n\tif (_itimediff(current, ts_flush) >= 0) {\n\t\treturn current;\n\t}\n\n\ttm_flush = _itimediff(ts_flush, current);\n\n\tfor (p = kcp->snd_buf.next; p != &kcp->snd_buf; p = p->next) {\n\t\tconst IKCPSEG *seg = iqueue_entry(p, const IKCPSEG, node);\n\t\tIINT32 diff = _itimediff(seg->resendts, current);\n\t\tif (diff <= 0) {\n\t\t\treturn current;\n\t\t}\n\t\tif (diff < tm_packet) tm_packet = diff;\n\t}\n\n\tminimal = (IUINT32)(tm_packet < tm_flush ? tm_packet : tm_flush);\n\tif (minimal >= kcp->interval) minimal = kcp->interval;\n\n\treturn current + minimal;\n}", "path": "kcp/ikcp.c", "commit_date": "2020-09-16 00:00:00", "repo_name": "skywind3000/kcp", "stars": 14413, "license": "mit", "language": "c", "size": 562}
{"docstring": "// internal free\n", "func_signal": "static void ikcp_free(void *ptr)", "code": "{\n\tif (ikcp_free_hook) {\n\t\tikcp_free_hook(ptr);\n\t}\telse {\n\t\tfree(ptr);\n\t}\n}", "path": "kcp/ikcp.c", "commit_date": "2020-09-16 00:00:00", "repo_name": "skywind3000/kcp", "stars": 14413, "license": "mit", "language": "c", "size": 562}
{"docstring": "/**\n * smix(B, r, N, V, XY):\n * Compute B = SMix_r(B, N).  The input B must be 128r bytes in length;\n * the temporary storage V must be 128rN bytes in length; the temporary\n * storage XY must be 256r + 64 bytes in length.  The value N must be a\n * power of 2 greater than 1.  The arrays B, V, and XY must be aligned to a\n * multiple of 64 bytes.\n */\n", "func_signal": "static void\nsmix(uint8_t * B, size_t r, uint32_t N, void * V, void * XY)", "code": "{\n\tsize_t s = 128 * r;\n\t__m128i * X = (__m128i *) V, * Y;\n\tuint32_t * X32 = (uint32_t *) V;\n\tuint32_t i, j;\n\tsize_t k;\n\n\t/* 1: X <-- B */\n\t/* 3: V_i <-- X */\n\tfor (k = 0; k < 2 * r; k++) {\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tX32[k * 16 + i] =\n\t\t\t    le32dec(&B[(k * 16 + (i * 5 % 16)) * 4]);\n\t\t}\n\t}\n\n\t/* 2: for i = 0 to N - 1 do */\n\tfor (i = 1; i < N - 1; i += 2) {\n\t\t/* 4: X <-- H(X) */\n\t\t/* 3: V_i <-- X */\n\t\tY = (__m128i *)((uintptr_t)(V) + i * s);\n\t\tblockmix_salsa8(X, Y, r);\n\n\t\t/* 4: X <-- H(X) */\n\t\t/* 3: V_i <-- X */\n\t\tX = (__m128i *)((uintptr_t)(V) + (i + 1) * s);\n\t\tblockmix_salsa8(Y, X, r);\n\t}\n\n\t/* 4: X <-- H(X) */\n\t/* 3: V_i <-- X */\n\tY = (__m128i *)((uintptr_t)(V) + i * s);\n\tblockmix_salsa8(X, Y, r);\n\n\t/* 4: X <-- H(X) */\n\t/* 3: V_i <-- X */\n\tX = (__m128i *) XY;\n\tblockmix_salsa8(Y, X, r);\n\n\tX32 = (uint32_t *) XY;\n\tY = (__m128i *)((uintptr_t)(XY) + s);\n\n\t/* 7: j <-- Integerify(X) mod N */\n\tj = integerify(X, r) & (N - 1);\n\n\t/* 6: for i = 0 to N - 1 do */\n\tfor (i = 0; i < N; i += 2) {\n\t\t__m128i * V_j = (__m128i *)((uintptr_t)(V) + j * s);\n\n\t\t/* 8: X <-- H(X \\xor V_j) */\n\t\t/* 7: j <-- Integerify(X) mod N */\n\t\tj = blockmix_salsa8_xor(X, V_j, Y, r) & (N - 1);\n\t\tV_j = (__m128i *)((uintptr_t)(V) + j * s);\n\n\t\t/* 8: X <-- H(X \\xor V_j) */\n\t\t/* 7: j <-- Integerify(X) mod N */\n\t\tj = blockmix_salsa8_xor(Y, V_j, X, r) & (N - 1);\n\t}\n\n\t/* 10: B' <-- X */\n\tfor (k = 0; k < 2 * r; k++) {\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tle32enc(&B[(k * 16 + (i * 5 % 16)) * 4],\n\t\t\t    X32[k * 16 + i]);\n\t\t}\n\t}\n}", "path": "toxcore/toxencryptsave/crypto_pwhash_scryptsalsa208sha256/sse/pwhash_scryptsalsa208sha256_sse.c", "commit_date": "2014-09-13 00:00:00", "repo_name": "irungentoo/toxcore", "stars": 8728, "license": "gpl-3.0", "language": "c", "size": 10353}
{"docstring": "/* Remove real pk from received_requests list.\n *\n *  return 0 if it removed it successfully.\n *  return -1 if it didn't find it.\n */\n", "func_signal": "int remove_request_received(Friend_Requests *fr, const uint8_t *real_pk)", "code": "{\n    uint32_t i;\n\n    for (i = 0; i < MAX_RECEIVED_STORED; ++i) {\n        if (id_equal(fr->received_requests[i], real_pk)) {\n            sodium_memzero(fr->received_requests[i], crypto_box_PUBLICKEYBYTES);\n            return 0;\n        }\n    }\n\n    return -1;\n}", "path": "toxcore/toxcore/friend_requests.c", "commit_date": "2016-01-26 00:00:00", "repo_name": "irungentoo/toxcore", "stars": 8728, "license": "gpl-3.0", "language": "c", "size": 10353}
{"docstring": "/* return 1 on success.\n * return 0 if could not send packet.\n * return -1 on failure (connection must be killed).\n */\n", "func_signal": "static int send_ping_request(TCP_Client_Connection *con)", "code": "{\n    if (!con->ping_request_id)\n        return 1;\n\n    uint8_t packet[1 + sizeof(uint64_t)];\n    packet[0] = TCP_PACKET_PING;\n    memcpy(packet + 1, &con->ping_request_id, sizeof(uint64_t));\n    int ret;\n\n    if ((ret = write_packet_TCP_secure_connection(con, packet, sizeof(packet), 1)) == 1) {\n        con->ping_request_id = 0;\n    }\n\n    return ret;\n}", "path": "toxcore/toxcore/TCP_client.c", "commit_date": "2018-10-03 00:00:00", "repo_name": "irungentoo/toxcore", "stars": 8728, "license": "gpl-3.0", "language": "c", "size": 10353}
{"docstring": "/* return 1 on success.\n * return 0 if no data received.\n * return -1 on failure (connection refused).\n */\n", "func_signal": "static int proxy_socks5_read_connection_response(TCP_Client_Connection *TCP_conn)", "code": "{\n    if (TCP_conn->ip_port.ip.family == AF_INET) {\n        uint8_t data[4 + sizeof(IP4) + sizeof(uint16_t)];\n        int ret = read_TCP_packet(TCP_conn->sock, data, sizeof(data));\n\n        if (ret == -1)\n            return 0;\n\n        if (data[0] == 5 && data[1] == 0)\n            return 1;\n\n    } else {\n        uint8_t data[4 + sizeof(IP6) + sizeof(uint16_t)];\n        int ret = read_TCP_packet(TCP_conn->sock, data, sizeof(data));\n\n        if (ret == -1)\n            return 0;\n\n        if (data[0] == 5 && data[1] == 0)\n            return 1;\n    }\n\n    return -1;\n}", "path": "toxcore/toxcore/TCP_client.c", "commit_date": "2018-10-03 00:00:00", "repo_name": "irungentoo/toxcore", "stars": 8728, "license": "gpl-3.0", "language": "c", "size": 10353}
{"docstring": "/* Set the number that will be used as an argument in the callbacks related to con_id.\n *\n * When not set by this function, the number is ~0.\n *\n * return 0 on success.\n * return -1 on failure.\n */\n", "func_signal": "int set_tcp_connection_number(TCP_Client_Connection *con, uint8_t con_id, uint32_t number)", "code": "{\n    if (con_id >= NUM_CLIENT_CONNECTIONS)\n        return -1;\n\n    if (con->connections[con_id].status == 0)\n        return -1;\n\n    con->connections[con_id].number = number;\n    return 0;\n}", "path": "toxcore/toxcore/TCP_client.c", "commit_date": "2018-10-03 00:00:00", "repo_name": "irungentoo/toxcore", "stars": 8728, "license": "gpl-3.0", "language": "c", "size": 10353}
{"docstring": "/* return 1 on success.\n * return 0 if could not send packet.\n * return -1 on failure (connection must be killed).\n */\n", "func_signal": "int send_disconnect_request(TCP_Client_Connection *con, uint8_t con_id)", "code": "{\n    if (con_id >= NUM_CLIENT_CONNECTIONS)\n        return -1;\n\n    con->connections[con_id].status = 0;\n    con->connections[con_id].number = 0;\n    return send_disconnect_notification(con, con_id + NUM_RESERVED_PORTS);\n}", "path": "toxcore/toxcore/TCP_client.c", "commit_date": "2018-10-03 00:00:00", "repo_name": "irungentoo/toxcore", "stars": 8728, "license": "gpl-3.0", "language": "c", "size": 10353}
{"docstring": "/* return 0 on success.\n * return -1 on failure.\n */\n", "func_signal": "static int generate_handshake(TCP_Client_Connection *TCP_conn)", "code": "{\n    uint8_t plain[crypto_box_PUBLICKEYBYTES + crypto_box_NONCEBYTES];\n    crypto_box_keypair(plain, TCP_conn->temp_secret_key);\n    random_nonce(TCP_conn->sent_nonce);\n    memcpy(plain + crypto_box_PUBLICKEYBYTES, TCP_conn->sent_nonce, crypto_box_NONCEBYTES);\n    memcpy(TCP_conn->last_packet, TCP_conn->self_public_key, crypto_box_PUBLICKEYBYTES);\n    new_nonce(TCP_conn->last_packet + crypto_box_PUBLICKEYBYTES);\n    int len = encrypt_data_symmetric(TCP_conn->shared_key, TCP_conn->last_packet + crypto_box_PUBLICKEYBYTES, plain,\n                                     sizeof(plain), TCP_conn->last_packet + crypto_box_PUBLICKEYBYTES + crypto_box_NONCEBYTES);\n\n    if (len != sizeof(plain) + crypto_box_MACBYTES)\n        return -1;\n\n    TCP_conn->last_packet_length = crypto_box_PUBLICKEYBYTES + crypto_box_NONCEBYTES + sizeof(plain) + crypto_box_MACBYTES;\n    TCP_conn->last_packet_sent = 0;\n    return 0;\n}", "path": "toxcore/toxcore/TCP_client.c", "commit_date": "2018-10-03 00:00:00", "repo_name": "irungentoo/toxcore", "stars": 8728, "license": "gpl-3.0", "language": "c", "size": 10353}
{"docstring": "/* return 1 on success\n * return 0 on failure\n */\n", "func_signal": "static int connect_sock_to(sock_t sock, IP_Port ip_port, TCP_Proxy_Info *proxy_info)", "code": "{\n    if (proxy_info->proxy_type != TCP_PROXY_NONE) {\n        ip_port = proxy_info->ip_port;\n    }\n\n    struct sockaddr_storage addr = {0};\n\n    size_t addrsize;\n\n    if (ip_port.ip.family == AF_INET) {\n        struct sockaddr_in *addr4 = (struct sockaddr_in *)&addr;\n\n        addrsize = sizeof(struct sockaddr_in);\n        addr4->sin_family = AF_INET;\n        addr4->sin_addr = ip_port.ip.ip4.in_addr;\n        addr4->sin_port = ip_port.port;\n    } else if (ip_port.ip.family == AF_INET6) {\n        struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&addr;\n\n        addrsize = sizeof(struct sockaddr_in6);\n        addr6->sin6_family = AF_INET6;\n        addr6->sin6_addr = ip_port.ip.ip6.in6_addr;\n        addr6->sin6_port = ip_port.port;\n    } else {\n        return 0;\n    }\n\n    /* nonblocking socket, connect will never return success */\n    connect(sock, (struct sockaddr *)&addr, addrsize);\n    return 1;\n}", "path": "toxcore/toxcore/TCP_client.c", "commit_date": "2018-10-03 00:00:00", "repo_name": "irungentoo/toxcore", "stars": 8728, "license": "gpl-3.0", "language": "c", "size": 10353}
{"docstring": "/* return 1 on success.\n * return 0 if could not send packet.\n * return -1 on failure.\n */\n", "func_signal": "int send_oob_packet(TCP_Client_Connection *con, const uint8_t *public_key, const uint8_t *data, uint16_t length)", "code": "{\n    if (length == 0 || length > TCP_MAX_OOB_DATA_LENGTH)\n        return -1;\n\n    uint8_t packet[1 + crypto_box_PUBLICKEYBYTES + length];\n    packet[0] = TCP_PACKET_OOB_SEND;\n    memcpy(packet + 1, public_key, crypto_box_PUBLICKEYBYTES);\n    memcpy(packet + 1 + crypto_box_PUBLICKEYBYTES, data, length);\n    return write_packet_TCP_secure_connection(con, packet, sizeof(packet), 0);\n}", "path": "toxcore/toxcore/TCP_client.c", "commit_date": "2018-10-03 00:00:00", "repo_name": "irungentoo/toxcore", "stars": 8728, "license": "gpl-3.0", "language": "c", "size": 10353}
{"docstring": "/* return 0 on failure (only if malloc fails)\n * return 1 on success\n */\n", "func_signal": "static _Bool add_priority(TCP_Client_Connection *con, const uint8_t *packet, uint16_t size, uint16_t sent)", "code": "{\n    TCP_Priority_List *p = con->priority_queue_end, *new;\n    new = malloc(sizeof(TCP_Priority_List) + size);\n\n    if (!new) {\n        return 0;\n    }\n\n    new->next = NULL;\n    new->size = size;\n    new->sent = sent;\n    memcpy(new->data, packet, size);\n\n    if (p) {\n        p->next = new;\n    } else {\n        con->priority_queue_start = new;\n    }\n\n    con->priority_queue_end = new;\n    return 1;\n}", "path": "toxcore/toxcore/TCP_client.c", "commit_date": "2018-10-03 00:00:00", "repo_name": "irungentoo/toxcore", "stars": 8728, "license": "gpl-3.0", "language": "c", "size": 10353}
{"docstring": "/* return 1 on success.\n * return 0 if could not send packet.\n * return -1 on failure (connection must be killed).\n */\n", "func_signal": "int send_onion_request(TCP_Client_Connection *con, const uint8_t *data, uint16_t length)", "code": "{\n    uint8_t packet[1 + length];\n    packet[0] = TCP_PACKET_ONION_REQUEST;\n    memcpy(packet + 1, data, length);\n    return write_packet_TCP_secure_connection(con, packet, sizeof(packet), 0);\n}", "path": "toxcore/toxcore/TCP_client.c", "commit_date": "2018-10-03 00:00:00", "repo_name": "irungentoo/toxcore", "stars": 8728, "license": "gpl-3.0", "language": "c", "size": 10353}
{"docstring": "/* return 1 on success.\n * return 0 if could not send packet.\n * return -1 on failure.\n */\n", "func_signal": "int send_data(TCP_Client_Connection *con, uint8_t con_id, const uint8_t *data, uint16_t length)", "code": "{\n    if (con_id >= NUM_CLIENT_CONNECTIONS)\n        return -1;\n\n    if (con->connections[con_id].status != 2)\n        return -1;\n\n    if (send_ping_response(con) == 0 || send_ping_request(con) == 0)\n        return 0;\n\n    uint8_t packet[1 + length];\n    packet[0] = con_id + NUM_RESERVED_PORTS;\n    memcpy(packet + 1, data, length);\n    return write_packet_TCP_secure_connection(con, packet, sizeof(packet), 0);\n}", "path": "toxcore/toxcore/TCP_client.c", "commit_date": "2018-10-03 00:00:00", "repo_name": "irungentoo/toxcore", "stars": 8728, "license": "gpl-3.0", "language": "c", "size": 10353}
{"docstring": "/* return 1 on success.\n * return 0 if no data received.\n * return -1 on failure (connection refused).\n */\n", "func_signal": "static int socks5_read_handshake_response(TCP_Client_Connection *TCP_conn)", "code": "{\n    uint8_t data[2];\n    int ret = read_TCP_packet(TCP_conn->sock, data, sizeof(data));\n\n    if (ret == -1)\n        return 0;\n\n    if (data[0] == 5 && data[1] == 0) // FIXME magic numbers\n        return 1;\n\n    return -1;\n}", "path": "toxcore/toxcore/TCP_client.c", "commit_date": "2018-10-03 00:00:00", "repo_name": "irungentoo/toxcore", "stars": 8728, "license": "gpl-3.0", "language": "c", "size": 10353}
{"docstring": "/* return 1 on success.\n * return 0 if could not send packet.\n * return -1 on failure (connection must be killed).\n */\n", "func_signal": "static int send_disconnect_notification(TCP_Client_Connection *con, uint8_t id)", "code": "{\n    uint8_t packet[1 + 1];\n    packet[0] = TCP_PACKET_DISCONNECT_NOTIFICATION;\n    packet[1] = id;\n    return write_packet_TCP_secure_connection(con, packet, sizeof(packet), 1);\n}", "path": "toxcore/toxcore/TCP_client.c", "commit_date": "2018-10-03 00:00:00", "repo_name": "irungentoo/toxcore", "stars": 8728, "license": "gpl-3.0", "language": "c", "size": 10353}
{"docstring": "/* Set the function used to check if a friend request should be displayed to the user or not. */\n", "func_signal": "void set_filter_function(Friend_Requests *fr, int (*function)(const uint8_t *, void *), void *userdata)", "code": "{\n    fr->filter_function = function;\n    fr->filter_function_userdata = userdata;\n}", "path": "toxcore/toxcore/friend_requests.c", "commit_date": "2016-01-26 00:00:00", "repo_name": "irungentoo/toxcore", "stars": 8728, "license": "gpl-3.0", "language": "c", "size": 10353}
{"docstring": "/* Add to list of received friend requests. */\n", "func_signal": "static void addto_receivedlist(Friend_Requests *fr, const uint8_t *real_pk)", "code": "{\n    if (fr->received_requests_index >= MAX_RECEIVED_STORED)\n        fr->received_requests_index = 0;\n\n    id_copy(fr->received_requests[fr->received_requests_index], real_pk);\n    ++fr->received_requests_index;\n}", "path": "toxcore/toxcore/friend_requests.c", "commit_date": "2016-01-26 00:00:00", "repo_name": "irungentoo/toxcore", "stars": 8728, "license": "gpl-3.0", "language": "c", "size": 10353}
{"docstring": "/* return 1 on success.\n * return 0 if could not send packet.\n * return -1 on failure (connection must be killed).\n */\n", "func_signal": "static int write_packet_TCP_secure_connection(TCP_Client_Connection *con, const uint8_t *data, uint16_t length,\n        _Bool priority)", "code": "{\n    if (length + crypto_box_MACBYTES > MAX_PACKET_SIZE)\n        return -1;\n\n    _Bool sendpriority = 1;\n\n    if (send_pending_data(con) == -1) {\n        if (priority) {\n            sendpriority = 0;\n        } else {\n            return 0;\n        }\n    }\n\n    uint8_t packet[sizeof(uint16_t) + length + crypto_box_MACBYTES];\n\n    uint16_t c_length = htons(length + crypto_box_MACBYTES);\n    memcpy(packet, &c_length, sizeof(uint16_t));\n    int len = encrypt_data_symmetric(con->shared_key, con->sent_nonce, data, length, packet + sizeof(uint16_t));\n\n    if ((unsigned int)len != (sizeof(packet) - sizeof(uint16_t)))\n        return -1;\n\n    if (priority) {\n        len = sendpriority ? send(con->sock, packet, sizeof(packet), MSG_NOSIGNAL) : 0;\n\n        if (len <= 0) {\n            len = 0;\n        }\n\n        increment_nonce(con->sent_nonce);\n\n        if ((unsigned int)len == sizeof(packet)) {\n            return 1;\n        }\n\n        return add_priority(con, packet, sizeof(packet), len);\n    }\n\n    len = send(con->sock, packet, sizeof(packet), MSG_NOSIGNAL);\n\n    if (len <= 0)\n        return 0;\n\n    increment_nonce(con->sent_nonce);\n\n    if ((unsigned int)len == sizeof(packet))\n        return 1;\n\n    memcpy(con->last_packet, packet, sizeof(packet));\n    con->last_packet_length = sizeof(packet);\n    con->last_packet_sent = len;\n    return 1;\n}", "path": "toxcore/toxcore/TCP_client.c", "commit_date": "2018-10-03 00:00:00", "repo_name": "irungentoo/toxcore", "stars": 8728, "license": "gpl-3.0", "language": "c", "size": 10353}
{"docstring": "/* return 0 on success\n * return -1 on failure\n */\n", "func_signal": "static int handle_TCP_packet(TCP_Client_Connection *conn, const uint8_t *data, uint16_t length)", "code": "{\n    if (length <= 1)\n        return -1;\n\n    switch (data[0]) {\n        case TCP_PACKET_ROUTING_RESPONSE: {\n            if (length != 1 + 1 + crypto_box_PUBLICKEYBYTES)\n                return -1;\n\n            if (data[1] < NUM_RESERVED_PORTS)\n                return 0;\n\n            uint8_t con_id = data[1] - NUM_RESERVED_PORTS;\n\n            if (conn->connections[con_id].status != 0)\n                return 0;\n\n            conn->connections[con_id].status = 1;\n            conn->connections[con_id].number = ~0;\n            memcpy(conn->connections[con_id].public_key, data + 2, crypto_box_PUBLICKEYBYTES);\n\n            if (conn->response_callback)\n                conn->response_callback(conn->response_callback_object, con_id, conn->connections[con_id].public_key);\n\n            return 0;\n        }\n\n        case TCP_PACKET_CONNECTION_NOTIFICATION: {\n            if (length != 1 + 1)\n                return -1;\n\n            if (data[1] < NUM_RESERVED_PORTS)\n                return -1;\n\n            uint8_t con_id = data[1] - NUM_RESERVED_PORTS;\n\n            if (conn->connections[con_id].status != 1)\n                return 0;\n\n            conn->connections[con_id].status = 2;\n\n            if (conn->status_callback)\n                conn->status_callback(conn->status_callback_object, conn->connections[con_id].number, con_id,\n                                      conn->connections[con_id].status);\n\n            return 0;\n        }\n\n        case TCP_PACKET_DISCONNECT_NOTIFICATION: {\n            if (length != 1 + 1)\n                return -1;\n\n            if (data[1] < NUM_RESERVED_PORTS)\n                return -1;\n\n            uint8_t con_id = data[1] - NUM_RESERVED_PORTS;\n\n            if (conn->connections[con_id].status == 0)\n                return 0;\n\n            if (conn->connections[con_id].status != 2)\n                return 0;\n\n            conn->connections[con_id].status = 1;\n\n            if (conn->status_callback)\n                conn->status_callback(conn->status_callback_object, conn->connections[con_id].number, con_id,\n                                      conn->connections[con_id].status);\n\n            return 0;\n        }\n\n        case TCP_PACKET_PING: {\n            if (length != 1 + sizeof(uint64_t))\n                return -1;\n\n            uint64_t ping_id;\n            memcpy(&ping_id, data + 1, sizeof(uint64_t));\n            conn->ping_response_id = ping_id;\n            send_ping_response(conn);\n            return 0;\n        }\n\n        case TCP_PACKET_PONG: {\n            if (length != 1 + sizeof(uint64_t))\n                return -1;\n\n            uint64_t ping_id;\n            memcpy(&ping_id, data + 1, sizeof(uint64_t));\n\n            if (ping_id) {\n                if (ping_id == conn->ping_id) {\n                    conn->ping_id = 0;\n                }\n\n                return 0;\n            } else {\n                return -1;\n            }\n        }\n\n        case TCP_PACKET_OOB_RECV: {\n            if (length <= 1 + crypto_box_PUBLICKEYBYTES)\n                return -1;\n\n            if (conn->oob_data_callback)\n                conn->oob_data_callback(conn->oob_data_callback_object, data + 1, data + 1 + crypto_box_PUBLICKEYBYTES,\n                                        length - (1 + crypto_box_PUBLICKEYBYTES));\n\n            return 0;\n        }\n\n        case TCP_PACKET_ONION_RESPONSE: {\n            conn->onion_callback(conn->onion_callback_object, data + 1, length - 1);\n            return 0;\n        }\n\n        default: {\n            if (data[0] < NUM_RESERVED_PORTS)\n                return -1;\n\n            uint8_t con_id = data[0] - NUM_RESERVED_PORTS;\n\n            if (conn->data_callback)\n                conn->data_callback(conn->data_callback_object, conn->connections[con_id].number, con_id, data + 1, length - 1);\n        }\n    }\n\n    return 0;\n}", "path": "toxcore/toxcore/TCP_client.c", "commit_date": "2018-10-03 00:00:00", "repo_name": "irungentoo/toxcore", "stars": 8728, "license": "gpl-3.0", "language": "c", "size": 10353}
{"docstring": "/**\n * escrypt_kdf(local, passwd, passwdlen, salt, saltlen,\n *     N, r, p, buf, buflen):\n * Compute scrypt(passwd[0 .. passwdlen - 1], salt[0 .. saltlen - 1], N, r,\n * p, buflen) and write the result into buf.  The parameters r, p, and buflen\n * must satisfy r * p < 2^30 and buflen <= (2^32 - 1) * 32.  The parameter N\n * must be a power of 2 greater than 1.\n *\n * Return 0 on success; or -1 on error.\n */\n", "func_signal": "int\nescrypt_kdf_sse(escrypt_local_t * local,\n    const uint8_t * passwd, size_t passwdlen,\n    const uint8_t * salt, size_t saltlen,\n    uint64_t N, uint32_t _r, uint32_t _p,\n    uint8_t * buf, size_t buflen)", "code": "{\n\tsize_t B_size, V_size, XY_size, need;\n\tuint8_t * B;\n\tuint32_t * V, * XY;\n    size_t r = _r, p = _p;\n\tuint32_t i;\n\n\t/* Sanity-check parameters. */\n#if SIZE_MAX > UINT32_MAX\n\tif (buflen > (((uint64_t)(1) << 32) - 1) * 32) {\n\t\terrno = EFBIG;\n\t\treturn -1;\n\t}\n#endif\n\tif ((uint64_t)(r) * (uint64_t)(p) >= (1 << 30)) {\n\t\terrno = EFBIG;\n\t\treturn -1;\n\t}\n\tif (N > UINT32_MAX) {\n\t\terrno = EFBIG;\n\t\treturn -1;\n\t}\n\tif (((N & (N - 1)) != 0) || (N < 2)) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif (r == 0 || p == 0) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif ((r > SIZE_MAX / 128 / p) ||\n#if SIZE_MAX / 256 <= UINT32_MAX\n\t    (r > SIZE_MAX / 256) ||\n#endif\n\t    (N > SIZE_MAX / 128 / r)) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\n\t/* Allocate memory. */\n\tB_size = (size_t)128 * r * p;\n\tV_size = (size_t)128 * r * N;\n\tneed = B_size + V_size;\n\tif (need < V_size) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\tXY_size = (size_t)256 * r + 64;\n\tneed += XY_size;\n\tif (need < XY_size) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\tif (local->size < need) {\n\t\tif (free_region(local))\n\t\t\treturn -1;\n\t\tif (!alloc_region(local, need))\n\t\t\treturn -1;\n\t}\n\tB = (uint8_t *)local->aligned;\n\tV = (uint32_t *)((uint8_t *)B + B_size);\n\tXY = (uint32_t *)((uint8_t *)V + V_size);\n\n\t/* 1: (B_0 ... B_{p-1}) <-- PBKDF2(P, S, 1, p * MFLen) */\n\tPBKDF2_SHA256(passwd, passwdlen, salt, saltlen, 1, B, B_size);\n\n\t/* 2: for i = 0 to p - 1 do */\n\tfor (i = 0; i < p; i++) {\n\t\t/* 3: B_i <-- MF(B_i, N) */\n\t\tsmix(&B[(size_t)128 * i * r], r, N, V, XY);\n\t}\n\n\t/* 5: DK <-- PBKDF2(P, B, 1, dkLen) */\n\tPBKDF2_SHA256(passwd, passwdlen, B, B_size, 1, buf, buflen);\n\n\t/* Success! */\n\treturn 0;\n}", "path": "toxcore/toxencryptsave/crypto_pwhash_scryptsalsa208sha256/sse/pwhash_scryptsalsa208sha256_sse.c", "commit_date": "2014-09-13 00:00:00", "repo_name": "irungentoo/toxcore", "stars": 8728, "license": "gpl-3.0", "language": "c", "size": 10353}
{"docstring": "/* Set the function that will be executed when a friend request is received. */\n", "func_signal": "void callback_friendrequest(Friend_Requests *fr, void (*function)(void *, const uint8_t *, const uint8_t *, size_t,\n                            void *), void *object, void *userdata)", "code": "{\n    fr->handle_friendrequest = function;\n    fr->handle_friendrequest_isset = 1;\n    fr->handle_friendrequest_object = object;\n    fr->handle_friendrequest_userdata = userdata;\n}", "path": "toxcore/toxcore/friend_requests.c", "commit_date": "2016-01-26 00:00:00", "repo_name": "irungentoo/toxcore", "stars": 8728, "license": "gpl-3.0", "language": "c", "size": 10353}
{"docstring": "/**\n  This function parses Form Package to get the efi varstore info according to the request ConfigHdr.\n\n  @param  DataBaseRecord        The DataBaseRecord instance contains the found Hii handle and package.\n  @param  ConfigHdr             Request string ConfigHdr. If it is NULL,\n                                the first found varstore will be as ConfigHdr.\n  @param  IsEfiVarstore         Whether the request storage type is efi varstore type.\n  @param  EfiVarStore           The efi varstore info which will return.\n**/\n", "func_signal": "EFI_STATUS\nGetVarStoreType (\n  IN     HII_DATABASE_RECORD        *DataBaseRecord,\n  IN     EFI_STRING                 ConfigHdr,\n  OUT    BOOLEAN                    *IsEfiVarstore,\n  OUT    EFI_IFR_VARSTORE_EFI       **EfiVarStore\n  )", "code": "{\n  EFI_STATUS               Status;\n  UINTN                    IfrOffset;\n  UINTN                    PackageOffset;\n  EFI_IFR_OP_HEADER        *IfrOpHdr;\n  CHAR16                   *VarStoreName;\n  UINTN                    NameSize;\n  EFI_STRING               GuidStr;\n  EFI_STRING               NameStr;\n  EFI_STRING               TempStr;\n  UINTN                    LengthString;\n  UINT8                    *HiiFormPackage;\n  UINTN                    PackageSize;\n  EFI_IFR_VARSTORE_EFI     *IfrEfiVarStore;\n  EFI_HII_PACKAGE_HEADER   *PackageHeader;\n\n  HiiFormPackage = NULL;\n  LengthString     = 0;\n  Status           = EFI_SUCCESS;\n  GuidStr          = NULL;\n  NameStr          = NULL;\n  TempStr          = NULL;\n  *IsEfiVarstore   = FALSE;\n\n  Status = GetFormPackageData(DataBaseRecord, &HiiFormPackage, &PackageSize);\n  if (EFI_ERROR (Status)) {\n    return Status;\n  }\n\n  IfrOffset     = sizeof (EFI_HII_PACKAGE_HEADER);\n  PackageOffset = IfrOffset;\n  PackageHeader = (EFI_HII_PACKAGE_HEADER *) HiiFormPackage;\n\n  while (IfrOffset < PackageSize) {\n    //\n    // More than one form packages exist.\n    //\n    if (PackageOffset >= PackageHeader->Length) {\n        //\n        // Process the new form package.\n        //\n        PackageOffset = sizeof (EFI_HII_PACKAGE_HEADER);\n        IfrOffset    += PackageOffset;\n        PackageHeader = (EFI_HII_PACKAGE_HEADER *) (HiiFormPackage + IfrOffset);\n    }\n\n    IfrOpHdr  = (EFI_IFR_OP_HEADER *) (HiiFormPackage + IfrOffset);\n    IfrOffset += IfrOpHdr->Length;\n    PackageOffset += IfrOpHdr->Length;\n\n    if (IfrOpHdr->OpCode == EFI_IFR_VARSTORE_EFI_OP ) {\n      IfrEfiVarStore = (EFI_IFR_VARSTORE_EFI *) IfrOpHdr;\n      //\n      // If the length is small than the structure, this is from old efi\n      // varstore definition. Old efi varstore get config directly from\n      // GetVariable function.\n      //\n      if (IfrOpHdr->Length < sizeof (EFI_IFR_VARSTORE_EFI)) {\n        continue;\n      }\n\n      NameSize = AsciiStrSize ((CHAR8 *)IfrEfiVarStore->Name);\n      VarStoreName = AllocateZeroPool (NameSize * sizeof (CHAR16));\n      if (VarStoreName == NULL) {\n        Status = EFI_OUT_OF_RESOURCES;\n        goto Done;\n      }\n      AsciiStrToUnicodeStrS ((CHAR8 *) IfrEfiVarStore->Name, VarStoreName, NameSize);\n\n      GenerateSubStr (L\"GUID=\", sizeof (EFI_GUID), (VOID *) &IfrEfiVarStore->Guid, 1, &GuidStr);\n      GenerateSubStr (L\"NAME=\", StrLen (VarStoreName) * sizeof (CHAR16), (VOID *) VarStoreName, 2, &NameStr);\n      LengthString = StrLen (GuidStr);\n      LengthString = LengthString + StrLen (NameStr) + 1;\n      TempStr = AllocateZeroPool (LengthString * sizeof (CHAR16));\n      if (TempStr == NULL) {\n        FreePool (GuidStr);\n        FreePool (NameStr);\n        FreePool (VarStoreName);\n        Status = EFI_OUT_OF_RESOURCES;\n        goto Done;\n      }\n      StrCpyS (TempStr, LengthString, GuidStr);\n      StrCatS (TempStr, LengthString, NameStr);\n      if (ConfigHdr == NULL || StrnCmp (ConfigHdr, TempStr, StrLen (TempStr)) == 0) {\n        *EfiVarStore = (EFI_IFR_VARSTORE_EFI *) AllocateZeroPool (IfrOpHdr->Length);\n        if (*EfiVarStore == NULL) {\n          FreePool (VarStoreName);\n          FreePool (GuidStr);\n          FreePool (NameStr);\n          FreePool (TempStr);\n          Status = EFI_OUT_OF_RESOURCES;\n          goto Done;\n        }\n        *IsEfiVarstore = TRUE;\n        CopyMem (*EfiVarStore, IfrEfiVarStore, IfrOpHdr->Length);\n      }\n\n      //\n      // Free allocated temp string.\n      //\n      FreePool (VarStoreName);\n      FreePool (GuidStr);\n      FreePool (NameStr);\n      FreePool (TempStr);\n\n      //\n      // Already found the varstore, break;\n      //\n      if (*IsEfiVarstore) {\n        break;\n      }\n    }\n  }\nDone:\n  if (HiiFormPackage != NULL) {\n    FreePool (HiiFormPackage);\n  }\n\n  return Status;\n}", "path": "OpenCorePkg/Library/OcHiiDatabaseLib/ConfigRouting.c", "commit_date": "2020-04-07 00:00:00", "repo_name": "acidanthera/OpenCorePkg", "stars": 12577, "license": "bsd-3-clause", "language": "c", "size": 225079}
{"docstring": "/**\n\nUpdate the default value in the block data which used as Bit VarStore\n\n@param  BlockLink     The Link of the block data.\n\n**/\n", "func_signal": "VOID\nUpdateBlockDataArray (\n  IN LIST_ENTRY        *BlockLink\n)", "code": "{\n  LIST_ENTRY          *Link;\n  LIST_ENTRY          *TempLink;\n  IFR_BLOCK_DATA      *BlockData;\n  IFR_BLOCK_DATA      *NextBlockData;\n\n  //\n  // 1. Update default value in BitVar block data.\n  // Sine some block datas are used as BitVarStore, then the default value recored in the block\n  // is for related bit field in the block. so we need to set the default value to the related bit\n  // fields in the block data if the block data is used as bit varstore, then the default value of\n  // the block will be updated.\n  //\n  UpdateDefaultValue (BlockLink);\n\n  //\n  // 2.Update default value for overlap BitVar blcok datas.\n  // For block datas have overlap region, we need to merge the default value in different blocks.\n  //\n  for (Link = BlockLink->ForwardLink; Link != BlockLink; Link = Link->ForwardLink) {\n    BlockData = BASE_CR (Link, IFR_BLOCK_DATA, Entry);\n    if (!BlockData ->IsBitVar) {\n      continue;\n    }\n    for (TempLink = Link->ForwardLink; TempLink != BlockLink; TempLink = TempLink->ForwardLink) {\n      NextBlockData = BASE_CR (TempLink, IFR_BLOCK_DATA, Entry);\n      if (!NextBlockData->IsBitVar || NextBlockData->Offset >= BlockData->Offset + BlockData->Width || BlockData->Offset >= NextBlockData->Offset + NextBlockData->Width) {\n        continue;\n      }\n      //\n      // Find two blocks are used as bit VarStore and have overlap region, so need to merge default value of these two blocks.\n      //\n      MergeBlockDefaultValue (BlockData, NextBlockData);\n    }\n  }\n}", "path": "OpenCorePkg/Library/OcHiiDatabaseLib/ConfigRouting.c", "commit_date": "2020-04-07 00:00:00", "repo_name": "acidanthera/OpenCorePkg", "stars": 12577, "license": "bsd-3-clause", "language": "c", "size": 225079}
{"docstring": "/**\n  parse the configrequest string, get the elements.\n\n  @param      ConfigRequest         The input configrequest string.\n  @param      Progress              Return the progress data.\n\n  @retval     Block data pointer.\n**/\n", "func_signal": "IFR_BLOCK_DATA *\nGetBlockElement (\n  IN  EFI_STRING          ConfigRequest,\n  OUT EFI_STRING          *Progress\n  )", "code": "{\n  EFI_STRING           StringPtr;\n  IFR_BLOCK_DATA       *BlockData;\n  IFR_BLOCK_DATA       *RequestBlockArray;\n  EFI_STATUS           Status;\n  UINT8                *TmpBuffer;\n  UINT16               Offset;\n  UINT16               Width;\n  LIST_ENTRY           *Link;\n  IFR_BLOCK_DATA       *NextBlockData;\n  UINTN                Length;\n\n  TmpBuffer = NULL;\n\n  //\n  // Init RequestBlockArray\n  //\n  RequestBlockArray = (IFR_BLOCK_DATA *) AllocateZeroPool (sizeof (IFR_BLOCK_DATA));\n  if (RequestBlockArray == NULL) {\n    goto Done;\n  }\n  InitializeListHead (&RequestBlockArray->Entry);\n\n  //\n  // Get the request Block array from the request string\n  // Offset and Width\n  //\n\n  //\n  // Parse each <RequestElement> if exists\n  // Only <BlockName> format is supported by this help function.\n  // <BlockName> ::= &'OFFSET='<Number>&'WIDTH='<Number>\n  //\n  StringPtr = ConfigRequest;\n  while (*StringPtr != 0 && StrnCmp (StringPtr, L\"&OFFSET=\", StrLen (L\"&OFFSET=\")) == 0) {\n    //\n    // Skip the OFFSET string\n    //\n    *Progress   = StringPtr;\n    StringPtr += StrLen (L\"&OFFSET=\");\n    //\n    // Get Offset\n    //\n    Status = GetValueOfNumber (StringPtr, &TmpBuffer, &Length);\n    if (EFI_ERROR (Status)) {\n      goto Done;\n    }\n    Offset = 0;\n    CopyMem (\n      &Offset,\n      TmpBuffer,\n      (((Length + 1) / 2) < sizeof (UINT16)) ? ((Length + 1) / 2) : sizeof (UINT16)\n      );\n    FreePool (TmpBuffer);\n\n    StringPtr += Length;\n    if (StrnCmp (StringPtr, L\"&WIDTH=\", StrLen (L\"&WIDTH=\")) != 0) {\n      goto Done;\n    }\n    StringPtr += StrLen (L\"&WIDTH=\");\n\n    //\n    // Get Width\n    //\n    Status = GetValueOfNumber (StringPtr, &TmpBuffer, &Length);\n    if (EFI_ERROR (Status)) {\n      goto Done;\n    }\n    Width = 0;\n    CopyMem (\n      &Width,\n      TmpBuffer,\n      (((Length + 1) / 2) < sizeof (UINT16)) ? ((Length + 1) / 2) : sizeof (UINT16)\n      );\n    FreePool (TmpBuffer);\n\n    StringPtr += Length;\n    if (*StringPtr != 0 && *StringPtr != L'&') {\n      goto Done;\n    }\n\n    //\n    // Set Block Data\n    //\n    BlockData = (IFR_BLOCK_DATA *) AllocateZeroPool (sizeof (IFR_BLOCK_DATA));\n    if (BlockData == NULL) {\n      goto Done;\n    }\n    BlockData->Offset = Offset;\n    BlockData->Width  = Width;\n    InsertBlockData (&RequestBlockArray->Entry, &BlockData);\n\n    //\n    // Skip &VALUE string if &VALUE does exists.\n    //\n    if (StrnCmp (StringPtr, L\"&VALUE=\", StrLen (L\"&VALUE=\")) == 0) {\n      StringPtr += StrLen (L\"&VALUE=\");\n\n      //\n      // Get Value\n      //\n      Status = GetValueOfNumber (StringPtr, &TmpBuffer, &Length);\n      if (EFI_ERROR (Status)) {\n        goto Done;\n      }\n      FreePool (TmpBuffer);\n      StringPtr += Length;\n      if (*StringPtr != 0 && *StringPtr != L'&') {\n        goto Done;\n      }\n    }\n    //\n    // If '\\0', parsing is finished.\n    //\n    if (*StringPtr == 0) {\n      break;\n    }\n  }\n\n  //\n  // Merge the requested block data.\n  //\n  Link = RequestBlockArray->Entry.ForwardLink;\n  while ((Link != &RequestBlockArray->Entry) && (Link->ForwardLink != &RequestBlockArray->Entry)) {\n    BlockData = BASE_CR (Link, IFR_BLOCK_DATA, Entry);\n    NextBlockData = BASE_CR (Link->ForwardLink, IFR_BLOCK_DATA, Entry);\n    if ((NextBlockData->Offset >= BlockData->Offset) && (NextBlockData->Offset <= (BlockData->Offset + BlockData->Width))) {\n      if ((NextBlockData->Offset + NextBlockData->Width) > (BlockData->Offset + BlockData->Width)) {\n        BlockData->Width = (UINT16) (NextBlockData->Offset + NextBlockData->Width - BlockData->Offset);\n      }\n      RemoveEntryList (Link->ForwardLink);\n      FreePool (NextBlockData);\n      continue;\n    }\n    Link = Link->ForwardLink;\n  }\n\n  return RequestBlockArray;\n\nDone:\n  if (RequestBlockArray != NULL) {\n    //\n    // Free Link Array RequestBlockArray\n    //\n    while (!IsListEmpty (&RequestBlockArray->Entry)) {\n      BlockData = BASE_CR (RequestBlockArray->Entry.ForwardLink, IFR_BLOCK_DATA, Entry);\n      RemoveEntryList (&BlockData->Entry);\n      FreePool (BlockData);\n    }\n\n    FreePool (RequestBlockArray);\n  }\n\n  return NULL;\n}", "path": "OpenCorePkg/Library/OcHiiDatabaseLib/ConfigRouting.c", "commit_date": "2020-04-07 00:00:00", "repo_name": "acidanthera/OpenCorePkg", "stars": 12577, "license": "bsd-3-clause", "language": "c", "size": 225079}
{"docstring": "/**\n  Converts the unicode character of the string from uppercase to lowercase.\n  This is a internal function.\n\n  @param ConfigString  String to be converted\n\n**/\n", "func_signal": "VOID\nEFIAPI\nHiiToLower (\n  IN EFI_STRING  ConfigString\n  )", "code": "{\n  EFI_STRING  String;\n  BOOLEAN     Lower;\n\n  ASSERT (ConfigString != NULL);\n\n  //\n  // Convert all hex digits in range [A-F] in the configuration header to [a-f]\n  //\n  for (String = ConfigString, Lower = FALSE; *String != L'\\0'; String++) {\n    if (*String == L'=') {\n      Lower = TRUE;\n    } else if (*String == L'&') {\n      Lower = FALSE;\n    } else if (Lower && *String >= L'A' && *String <= L'F') {\n      *String = (CHAR16) (*String - L'A' + L'a');\n    }\n  }\n\n  return;\n}", "path": "OpenCorePkg/Library/OcHiiDatabaseLib/ConfigRouting.c", "commit_date": "2020-04-07 00:00:00", "repo_name": "acidanthera/OpenCorePkg", "stars": 12577, "license": "bsd-3-clause", "language": "c", "size": 225079}
{"docstring": "/**\n  This function merges DefaultAltCfgResp string into AltCfgResp string for\n  the missing AltCfgId in AltCfgResq.\n\n  @param  AltCfgResp             Pointer to a null-terminated Unicode string in\n                                 <ConfigAltResp> format. The default value string\n                                 will be merged into it.\n  @param  DefaultAltCfgResp      Pointer to a null-terminated Unicode string in\n                                 <MultiConfigAltResp> format. The default value\n                                 string may contain more than one ConfigAltResp\n                                 string for the different varstore buffer.\n\n  @retval EFI_SUCCESS            The merged string returns.\n  @retval EFI_INVALID_PARAMETER  *AltCfgResp is to NULL.\n**/\n", "func_signal": "EFI_STATUS\nEFIAPI\nMergeDefaultString (\n  IN OUT EFI_STRING  *AltCfgResp,\n  IN     EFI_STRING  DefaultAltCfgResp\n  )", "code": "{\n  EFI_STRING   StringPtrDefault;\n  EFI_STRING   StringPtrEnd;\n  CHAR16       TempChar;\n  EFI_STRING   StringPtr;\n  EFI_STRING   AltConfigHdr;\n  UINTN        HeaderLength;\n  UINTN        SizeAltCfgResp;\n  UINTN        MaxLen;\n  UINTN        TotalSize;\n\n  if (*AltCfgResp == NULL) {\n    return EFI_INVALID_PARAMETER;\n  }\n\n  //\n  // Get the request ConfigHdr\n  //\n  SizeAltCfgResp  = 0;\n  StringPtr       = *AltCfgResp;\n\n  //\n  // Find <ConfigHdr> GUID=...&NAME=...&PATH=...\n  //\n  if (StrnCmp (StringPtr, L\"GUID=\", StrLen (L\"GUID=\")) != 0) {\n    return EFI_INVALID_PARAMETER;\n  }\n  while (*StringPtr != L'\\0' && StrnCmp (StringPtr, L\"&NAME=\", StrLen (L\"&NAME=\")) != 0) {\n    StringPtr++;\n  }\n  while (*StringPtr != L'\\0' && StrnCmp (StringPtr, L\"&PATH=\", StrLen (L\"&PATH=\")) != 0) {\n    StringPtr++;\n  }\n  if (*StringPtr == L'\\0') {\n    return EFI_INVALID_PARAMETER;\n  }\n  StringPtr += StrLen (L\"&PATH=\");\n  while (*StringPtr != L'\\0' && *StringPtr != L'&') {\n    StringPtr ++;\n  }\n  HeaderLength = StringPtr - *AltCfgResp;\n\n  //\n  // Construct AltConfigHdr string  \"&<ConfigHdr>&ALTCFG=XXXX\\0\"\n  //                                  |1| StrLen (ConfigHdr) | 8 | 4 | 1 |\n  //\n  MaxLen = 1 + HeaderLength + 8 + 4 + 1;\n  AltConfigHdr = AllocateZeroPool (MaxLen * sizeof (CHAR16));\n  if (AltConfigHdr == NULL) {\n    return EFI_OUT_OF_RESOURCES;\n  }\n  StrCpyS (AltConfigHdr, MaxLen, L\"&\");\n  StrnCatS (AltConfigHdr, MaxLen, *AltCfgResp, HeaderLength);\n  StrCatS (AltConfigHdr, MaxLen, L\"&ALTCFG=\");\n  HeaderLength = StrLen (AltConfigHdr);\n\n  StringPtrDefault = StrStr (DefaultAltCfgResp, AltConfigHdr);\n  while (StringPtrDefault != NULL) {\n    //\n    // Get AltCfg Name\n    //\n    StrnCatS (AltConfigHdr, MaxLen, StringPtrDefault + HeaderLength, 4);\n    StringPtr = StrStr (*AltCfgResp, AltConfigHdr);\n\n    //\n    // Append the found default value string to the input AltCfgResp\n    //\n    if (StringPtr == NULL) {\n      StringPtrEnd   = StrStr (StringPtrDefault + 1, L\"&GUID\");\n      SizeAltCfgResp = StrSize (*AltCfgResp);\n      if (StringPtrEnd == NULL) {\n        //\n        // No more default string is found.\n        //\n        TotalSize = SizeAltCfgResp + StrSize (StringPtrDefault);\n        *AltCfgResp    = (EFI_STRING) ReallocatePool (\n                                     SizeAltCfgResp,\n                                     TotalSize,\n                                     (VOID *) (*AltCfgResp)\n                                     );\n        if (*AltCfgResp == NULL) {\n          FreePool (AltConfigHdr);\n          return EFI_OUT_OF_RESOURCES;\n        }\n        StrCatS (*AltCfgResp, TotalSize / sizeof (CHAR16), StringPtrDefault);\n        break;\n      } else {\n        TempChar = *StringPtrEnd;\n        *StringPtrEnd = L'\\0';\n        TotalSize = SizeAltCfgResp + StrSize (StringPtrDefault);\n        *AltCfgResp = (EFI_STRING) ReallocatePool (\n                                     SizeAltCfgResp,\n                                     TotalSize,\n                                     (VOID *) (*AltCfgResp)\n                                     );\n        if (*AltCfgResp == NULL) {\n          *StringPtrEnd = TempChar;\n          FreePool (AltConfigHdr);\n          return EFI_OUT_OF_RESOURCES;\n        }\n        StrCatS (*AltCfgResp, TotalSize / sizeof (CHAR16), StringPtrDefault);\n        *StringPtrEnd = TempChar;\n      }\n    } else {\n      //\n      // The AltCfgResp contains <AltCfgResp>.\n      // If the <ConfigElement> in <AltCfgResp> in the DefaultAltCfgResp but not in the\n      // related <AltCfgResp> in AltCfgResp, merge it to AltCfgResp. else no need to merge.\n      //\n      CompareAndMergeDefaultString (AltCfgResp, DefaultAltCfgResp, AltConfigHdr);\n    }\n\n    //\n    // Find next AltCfg String\n    //\n    *(AltConfigHdr + HeaderLength) = L'\\0';\n    StringPtrDefault = StrStr (StringPtrDefault + 1, AltConfigHdr);\n  }\n\n  FreePool (AltConfigHdr);\n  return EFI_SUCCESS;\n}", "path": "OpenCorePkg/Library/OcHiiDatabaseLib/ConfigRouting.c", "commit_date": "2020-04-07 00:00:00", "repo_name": "acidanthera/OpenCorePkg", "stars": 12577, "license": "bsd-3-clause", "language": "c", "size": 225079}
{"docstring": "/**\n  Generate ConfigRequest Header base on the varstore info.\n\n  @param      VarStorageData        The varstore info.\n  @param      DevicePath            Device path for this varstore.\n  @param      ConfigHdr             The config header for this varstore.\n\n  @retval     EFI_SUCCESS           Generate the header success.\n  @retval     EFI_OUT_OF_RESOURCES  Allocate buffer fail.\n**/\n", "func_signal": "EFI_STATUS\nGenerateHdr (\n  IN   IFR_VARSTORAGE_DATA          *VarStorageData,\n  IN   EFI_DEVICE_PATH_PROTOCOL     *DevicePath,\n  OUT  EFI_STRING                   *ConfigHdr\n  )", "code": "{\n  EFI_STRING                   GuidStr;\n  EFI_STRING                   NameStr;\n  EFI_STRING                   PathStr;\n  UINTN                        Length;\n  EFI_STATUS                   Status;\n\n  Status  = EFI_SUCCESS;\n  NameStr = NULL;\n  GuidStr = NULL;\n  PathStr = NULL;\n\n  //\n  // Construct <ConfigHdr> : \"GUID=...&NAME=...&PATH=...\" by VarStorageData Guid, Name and DriverHandle\n  //\n  GenerateSubStr (L\"GUID=\", sizeof (EFI_GUID), (VOID *) &VarStorageData->Guid, 1, &GuidStr);\n  if (VarStorageData->Name != NULL) {\n    GenerateSubStr (L\"NAME=\", StrLen (VarStorageData->Name) * sizeof (CHAR16), (VOID *) VarStorageData->Name, 2, &NameStr);\n  } else {\n    GenerateSubStr (L\"NAME=\", 0, NULL, 2, &NameStr);\n  }\n  GenerateSubStr (\n    L\"PATH=\",\n    GetDevicePathSize ((EFI_DEVICE_PATH_PROTOCOL *) DevicePath),\n    (VOID *) DevicePath,\n    1,\n    &PathStr\n    );\n  Length = StrLen (GuidStr) + StrLen (NameStr) + StrLen (PathStr) + 1;\n  if (VarStorageData->Name == NULL) {\n    Length += 1;\n  }\n\n  *ConfigHdr = AllocateZeroPool (Length * sizeof (CHAR16));\n  if (*ConfigHdr == NULL) {\n    Status = EFI_OUT_OF_RESOURCES;\n    goto Done;\n  }\n  StrCpyS (*ConfigHdr, Length, GuidStr);\n  StrCatS (*ConfigHdr, Length, NameStr);\n  if (VarStorageData->Name == NULL) {\n    StrCatS (*ConfigHdr, Length, L\"&\");\n  }\n  StrCatS (*ConfigHdr, Length, PathStr);\n\n  //\n  // Remove the last character L'&'\n  //\n  *(*ConfigHdr + StrLen (*ConfigHdr) - 1) = L'\\0';\n\nDone:\n  if (GuidStr != NULL) {\n    FreePool (GuidStr);\n  }\n\n  if (NameStr != NULL) {\n    FreePool (NameStr);\n  }\n\n  if (PathStr != NULL) {\n    FreePool (PathStr);\n  }\n\n  return Status;\n}", "path": "OpenCorePkg/Library/OcHiiDatabaseLib/ConfigRouting.c", "commit_date": "2020-04-07 00:00:00", "repo_name": "acidanthera/OpenCorePkg", "stars": 12577, "license": "bsd-3-clause", "language": "c", "size": 225079}
{"docstring": "/**\n  This function inserts new DefaultValueData into the BlockData DefaultValue array.\n\n  @param  BlockData         The BlockData is updated to add new default value.\n  @param  DefaultValueData  The DefaultValue is added.\n\n**/\n", "func_signal": "VOID\nInsertDefaultValue (\n  IN IFR_BLOCK_DATA         *BlockData,\n  IN IFR_DEFAULT_DATA       *DefaultValueData\n  )", "code": "{\n  LIST_ENTRY             *Link;\n  IFR_DEFAULT_DATA       *DefaultValueArray;\n  LIST_ENTRY             *DefaultLink;\n\n  DefaultLink   = &BlockData->DefaultValueEntry;\n\n  for (Link = DefaultLink->ForwardLink; Link != DefaultLink; Link = Link->ForwardLink) {\n    DefaultValueArray = BASE_CR (Link, IFR_DEFAULT_DATA, Entry);\n    if (DefaultValueArray->DefaultId == DefaultValueData->DefaultId) {\n      //\n      // DEFAULT_VALUE_FROM_OPCODE has high priority, DEFAULT_VALUE_FROM_DEFAULT has low priority.\n      // When default types are DEFAULT_VALUE_FROM_OTHER_DEFAULT, the default value can be overrode.\n      //\n      if ((DefaultValueData->Type > DefaultValueArray->Type) || (DefaultValueData->Type == DefaultValueArray->Type && DefaultValueData->Type == DefaultValueFromOtherDefault)) {\n        //\n        // Update the default value array in BlockData.\n        //\n        CopyMem (&DefaultValueArray->Value, &DefaultValueData->Value, sizeof (EFI_IFR_TYPE_VALUE));\n        DefaultValueArray->Type  = DefaultValueData->Type;\n        DefaultValueArray->Cleaned = DefaultValueData->Cleaned;\n      }\n      return;\n    }\n  }\n\n  //\n  // Insert new default value data in tail.\n  //\n  DefaultValueArray = AllocateZeroPool (sizeof (IFR_DEFAULT_DATA));\n  ASSERT (DefaultValueArray != NULL);\n  CopyMem (DefaultValueArray, DefaultValueData, sizeof (IFR_DEFAULT_DATA));\n  InsertTailList (Link, &DefaultValueArray->Entry);\n}", "path": "OpenCorePkg/Library/OcHiiDatabaseLib/ConfigRouting.c", "commit_date": "2020-04-07 00:00:00", "repo_name": "acidanthera/OpenCorePkg", "stars": 12577, "license": "bsd-3-clause", "language": "c", "size": 225079}
{"docstring": "/**\n  Get the value of <Number> in <BlockConfig> format, i.e. the value of OFFSET\n  or WIDTH or VALUE.\n  <BlockConfig> ::= 'OFFSET='<Number>&'WIDTH='<Number>&'VALUE'=<Number>\n\n  This is a internal function.\n\n  @param  StringPtr              String in <BlockConfig> format and points to the\n                                 first character of <Number>.\n  @param  Number                 The output value. Caller takes the responsibility\n                                 to free memory.\n  @param  Len                    Length of the <Number>, in characters.\n\n  @retval EFI_OUT_OF_RESOURCES   Insufficient resources to store necessary\n                                 structures.\n  @retval EFI_SUCCESS            Value of <Number> is outputted in Number\n                                 successfully.\n\n**/\n", "func_signal": "EFI_STATUS\nGetValueOfNumber (\n  IN EFI_STRING                    StringPtr,\n  OUT UINT8                        **Number,\n  OUT UINTN                        *Len\n  )", "code": "{\n  EFI_STRING               TmpPtr;\n  UINTN                    Length;\n  EFI_STRING               Str;\n  UINT8                    *Buf;\n  EFI_STATUS               Status;\n  UINT8                    DigitUint8;\n  UINTN                    Index;\n  CHAR16                   TemStr[2];\n\n  if (StringPtr == NULL || *StringPtr == L'\\0' || Number == NULL || Len == NULL) {\n    return EFI_INVALID_PARAMETER;\n  }\n\n  Buf = NULL;\n\n  TmpPtr = StringPtr;\n  while (*StringPtr != L'\\0' && *StringPtr != L'&') {\n    StringPtr++;\n  }\n  *Len   = StringPtr - TmpPtr;\n  Length = *Len + 1;\n\n  Str = (EFI_STRING) AllocateZeroPool (Length * sizeof (CHAR16));\n  if (Str == NULL) {\n    Status = EFI_OUT_OF_RESOURCES;\n    goto Exit;\n  }\n  CopyMem (Str, TmpPtr, *Len * sizeof (CHAR16));\n  *(Str + *Len) = L'\\0';\n\n  Length = (Length + 1) / 2;\n  Buf = (UINT8 *) AllocateZeroPool (Length);\n  if (Buf == NULL) {\n    Status = EFI_OUT_OF_RESOURCES;\n    goto Exit;\n  }\n\n  Length = *Len;\n  ZeroMem (TemStr, sizeof (TemStr));\n  for (Index = 0; Index < Length; Index ++) {\n    TemStr[0] = Str[Length - Index - 1];\n    DigitUint8 = (UINT8) StrHexToUint64 (TemStr);\n    if ((Index & 1) == 0) {\n      Buf [Index/2] = DigitUint8;\n    } else {\n      Buf [Index/2] = (UINT8) ((DigitUint8 << 4) + Buf [Index/2]);\n    }\n  }\n\n  *Number = Buf;\n  Status  = EFI_SUCCESS;\n\nExit:\n  if (Str != NULL) {\n    FreePool (Str);\n  }\n\n  return Status;\n}", "path": "OpenCorePkg/Library/OcHiiDatabaseLib/ConfigRouting.c", "commit_date": "2020-04-07 00:00:00", "repo_name": "acidanthera/OpenCorePkg", "stars": 12577, "license": "bsd-3-clause", "language": "c", "size": 225079}
{"docstring": "/**\n  This function parses Form Package to get the efi varstore info according to the request ConfigHdr.\n\n  @param  DataBaseRecord        The DataBaseRecord instance contains the found Hii handle and package.\n  @param  ConfigHdr             Request string ConfigHdr. If it is NULL,\n                                the first found varstore will be as ConfigHdr.\n  @retval  TRUE                 This hii package is the request one.\n  @retval  FALSE                This hii package is not the request one.\n**/\n", "func_signal": "BOOLEAN\nIsThisPackageList (\n  IN     HII_DATABASE_RECORD        *DataBaseRecord,\n  IN     EFI_STRING                 ConfigHdr\n  )", "code": "{\n  EFI_STATUS               Status;\n  UINTN                    IfrOffset;\n  UINTN                    PackageOffset;\n  EFI_IFR_OP_HEADER        *IfrOpHdr;\n  CHAR16                   *VarStoreName;\n  UINTN                    NameSize;\n  UINT8                    *HiiFormPackage;\n  UINTN                    PackageSize;\n  EFI_IFR_VARSTORE_EFI     *IfrEfiVarStore;\n  EFI_HII_PACKAGE_HEADER   *PackageHeader;\n  EFI_IFR_VARSTORE         *IfrVarStore;\n  EFI_IFR_VARSTORE_NAME_VALUE *IfrNameValueVarStore;\n  BOOLEAN                  FindVarstore;\n\n  HiiFormPackage   = NULL;\n  VarStoreName     = NULL;\n  Status           = EFI_SUCCESS;\n  FindVarstore     = FALSE;\n\n  Status = GetFormPackageData(DataBaseRecord, &HiiFormPackage, &PackageSize);\n  if (EFI_ERROR (Status)) {\n    return FALSE;\n  }\n\n  IfrOffset     = sizeof (EFI_HII_PACKAGE_HEADER);\n  PackageOffset = IfrOffset;\n  PackageHeader = (EFI_HII_PACKAGE_HEADER *) HiiFormPackage;\n\n  while (IfrOffset < PackageSize) {\n    //\n    // More than one form packages exist.\n    //\n    if (PackageOffset >= PackageHeader->Length) {\n        //\n        // Process the new form package.\n        //\n        PackageOffset = sizeof (EFI_HII_PACKAGE_HEADER);\n        IfrOffset    += PackageOffset;\n        PackageHeader = (EFI_HII_PACKAGE_HEADER *) (HiiFormPackage + IfrOffset);\n    }\n\n    IfrOpHdr  = (EFI_IFR_OP_HEADER *) (HiiFormPackage + IfrOffset);\n    IfrOffset += IfrOpHdr->Length;\n    PackageOffset += IfrOpHdr->Length;\n\n    switch (IfrOpHdr->OpCode) {\n\n    case EFI_IFR_VARSTORE_OP:\n      IfrVarStore = (EFI_IFR_VARSTORE *) IfrOpHdr;\n\n      NameSize = AsciiStrSize ((CHAR8 *)IfrVarStore->Name);\n      VarStoreName = AllocateZeroPool (NameSize * sizeof (CHAR16));\n      if (VarStoreName == NULL) {\n        goto Done;\n      }\n      AsciiStrToUnicodeStrS ((CHAR8 *)IfrVarStore->Name, VarStoreName, NameSize);\n\n      if (IsThisVarstore((VOID *)&IfrVarStore->Guid, VarStoreName, ConfigHdr)) {\n        FindVarstore = TRUE;\n        goto Done;\n      } else {\n        FreePool (VarStoreName);\n        VarStoreName = NULL;\n      }\n      break;\n\n    case EFI_IFR_VARSTORE_EFI_OP:\n      IfrEfiVarStore = (EFI_IFR_VARSTORE_EFI *) IfrOpHdr;\n      NameSize = AsciiStrSize ((CHAR8 *)IfrEfiVarStore->Name);\n      VarStoreName = AllocateZeroPool (NameSize * sizeof (CHAR16));\n      if (VarStoreName == NULL) {\n        goto Done;\n      }\n      AsciiStrToUnicodeStrS ((CHAR8 *)IfrEfiVarStore->Name, VarStoreName, NameSize);\n\n      if (IsThisVarstore (&IfrEfiVarStore->Guid, VarStoreName, ConfigHdr)) {\n        FindVarstore = TRUE;\n        goto Done;\n      } else {\n        FreePool (VarStoreName);\n        VarStoreName = NULL;\n      }\n      break;\n\n    case EFI_IFR_VARSTORE_NAME_VALUE_OP:\n      IfrNameValueVarStore = (EFI_IFR_VARSTORE_NAME_VALUE *) IfrOpHdr;\n\n      if (IsThisVarstore (&IfrNameValueVarStore->Guid, NULL, ConfigHdr)) {\n        FindVarstore = TRUE;\n        goto Done;\n      }\n      break;\n\n    case EFI_IFR_FORM_OP:\n    case EFI_IFR_FORM_MAP_OP:\n      //\n      // No matched varstore is found and directly return.\n      //\n      goto Done;\n\n    default:\n      break;\n    }\n  }\nDone:\n  if (HiiFormPackage != NULL) {\n    FreePool (HiiFormPackage);\n  }\n\n  if (VarStoreName != NULL) {\n    FreePool (VarStoreName);\n  }\n\n  return FindVarstore;\n}", "path": "OpenCorePkg/Library/OcHiiDatabaseLib/ConfigRouting.c", "commit_date": "2020-04-07 00:00:00", "repo_name": "acidanthera/OpenCorePkg", "stars": 12577, "license": "bsd-3-clause", "language": "c", "size": 225079}
{"docstring": "/**\n  Calculate the number of Unicode characters of the incoming Configuration string,\n  not including NULL terminator.\n\n  This is a internal function.\n\n  @param  String                 String in <MultiConfigRequest> or\n                                 <MultiConfigResp> format.\n\n  @return The number of Unicode characters.\n\n**/\n", "func_signal": "UINTN\nCalculateConfigStringLen (\n  IN EFI_STRING                    String\n  )", "code": "{\n  EFI_STRING  TmpPtr;\n\n  //\n  // \"GUID=\" should be the first element of incoming string.\n  //\n  ASSERT (String != NULL);\n  ASSERT (StrnCmp (String, L\"GUID=\", StrLen (L\"GUID=\")) == 0);\n\n  //\n  // The beginning of next <ConfigRequest>/<ConfigResp> should be \"&GUID=\".\n  // Will meet '\\0' if there is only one <ConfigRequest>/<ConfigResp>.\n  //\n  TmpPtr = StrStr (String, L\"&GUID=\");\n  if (TmpPtr == NULL) {\n    return StrLen (String);\n  }\n\n  return (TmpPtr - String);\n}", "path": "OpenCorePkg/Library/OcHiiDatabaseLib/ConfigRouting.c", "commit_date": "2020-04-07 00:00:00", "repo_name": "acidanthera/OpenCorePkg", "stars": 12577, "license": "bsd-3-clause", "language": "c", "size": 225079}
{"docstring": "/**\n  This function checks VarOffset and VarWidth is in the block range.\n\n  @param  RequestBlockArray  The block array is to be checked.\n  @param  VarOffset          Offset of var to the structure\n  @param  VarWidth           Width of var.\n  @param  IsNameValueType    Whether this varstore is name/value varstore or not.\n  @param  HiiHandle          Hii handle for this hii package.\n\n  @retval TRUE   This Var is in the block range.\n  @retval FALSE  This Var is not in the block range.\n**/\n", "func_signal": "BOOLEAN\nInternalBlockArrayCheck (\n  IN IFR_BLOCK_DATA  *RequestBlockArray,\n  IN UINT16          VarOffset,\n  IN UINT16          VarWidth,\n  IN BOOLEAN         IsNameValueType,\n  IN EFI_HII_HANDLE  HiiHandle\n  )", "code": "{\n  LIST_ENTRY          *Link;\n  IFR_BLOCK_DATA      *BlockData;\n  EFI_STRING          Name;\n\n  //\n  // No Request Block array, all vars are got.\n  //\n  if (RequestBlockArray == NULL) {\n    return TRUE;\n  }\n\n  //\n  // Check the input var is in the request block range.\n  //\n  for (Link = RequestBlockArray->Entry.ForwardLink; Link != &RequestBlockArray->Entry; Link = Link->ForwardLink) {\n    BlockData = BASE_CR (Link, IFR_BLOCK_DATA, Entry);\n\n    if (IsNameValueType) {\n      Name = InternalGetString (HiiHandle, VarOffset);\n      ASSERT (Name != NULL);\n\n      if (StrnCmp (BlockData->Name, Name, StrLen (Name)) == 0) {\n        FreePool (Name);\n        return TRUE;\n      }\n      FreePool (Name);\n    } else {\n      if ((VarOffset >= BlockData->Offset) && ((VarOffset + VarWidth) <= (BlockData->Offset + BlockData->Width))) {\n        return TRUE;\n      }\n    }\n  }\n\n  return FALSE;\n}", "path": "OpenCorePkg/Library/OcHiiDatabaseLib/ConfigRouting.c", "commit_date": "2020-04-07 00:00:00", "repo_name": "acidanthera/OpenCorePkg", "stars": 12577, "license": "bsd-3-clause", "language": "c", "size": 225079}
{"docstring": "/**\n  Convert the hex UNICODE %02x encoding of a UEFI device path to binary\n  from <PathHdr> of <ConfigHdr>.\n\n  This is a internal function.\n\n  @param  String                 UEFI configuration string\n  @param  DevicePathData         Binary of a UEFI device path.\n\n  @retval EFI_NOT_FOUND          The device path is not invalid.\n  @retval EFI_INVALID_PARAMETER  Any incoming parameter is invalid.\n  @retval EFI_OUT_OF_RESOURCES   Lake of resources to store necessary structures.\n  @retval EFI_SUCCESS            The device path is retrieved and translated to\n                                 binary format.\n\n**/\n", "func_signal": "EFI_STATUS\nGetDevicePath (\n  IN  EFI_STRING                   String,\n  OUT UINT8                        **DevicePathData\n  )", "code": "{\n  UINTN                    Length;\n  EFI_STRING               PathHdr;\n  UINT8                    *DevicePathBuffer;\n  CHAR16                   TemStr[2];\n  UINTN                    Index;\n  UINT8                    DigitUint8;\n  EFI_DEVICE_PATH_PROTOCOL *DevicePath;\n\n\n  if (String == NULL || DevicePathData == NULL) {\n    return EFI_INVALID_PARAMETER;\n  }\n\n  //\n  // Find the 'PATH=' of <PathHdr> and skip it.\n  //\n  for (; (*String != 0 && StrnCmp (String, L\"PATH=\", StrLen (L\"PATH=\")) != 0); String++);\n  if (*String == 0) {\n    return EFI_INVALID_PARAMETER;\n  }\n  //\n  // Check whether path data does exist.\n  //\n  String += StrLen (L\"PATH=\");\n  if (*String == 0) {\n    return EFI_INVALID_PARAMETER;\n  }\n  PathHdr = String;\n\n  //\n  // The content between 'PATH=' of <ConfigHdr> and '&' of next element\n  // or '\\0' (end of configuration string) is the UNICODE %02x bytes encoding\n  // of UEFI device path.\n  //\n  for (Length = 0; *String != 0 && *String != L'&'; String++, Length++);\n  //\n  // Check DevicePath Length\n  //\n  if (((Length + 1) / 2) < sizeof (EFI_DEVICE_PATH_PROTOCOL)) {\n    return EFI_NOT_FOUND;\n  }\n\n  //\n  // The data in <PathHdr> is encoded as hex UNICODE %02x bytes in the same order\n  // as the device path resides in RAM memory.\n  // Translate the data into binary.\n  //\n  DevicePathBuffer = (UINT8 *) AllocateZeroPool ((Length + 1) / 2);\n  if (DevicePathBuffer == NULL) {\n    return EFI_OUT_OF_RESOURCES;\n  }\n\n  //\n  // Convert DevicePath\n  //\n  ZeroMem (TemStr, sizeof (TemStr));\n  for (Index = 0; Index < Length; Index ++) {\n    TemStr[0] = PathHdr[Index];\n    DigitUint8 = (UINT8) StrHexToUint64 (TemStr);\n    if ((Index & 1) == 0) {\n      DevicePathBuffer [Index/2] = DigitUint8;\n    } else {\n      DevicePathBuffer [Index/2] = (UINT8) ((DevicePathBuffer [Index/2] << 4) + DigitUint8);\n    }\n  }\n\n  //\n  // Validate DevicePath\n  //\n  DevicePath  = (EFI_DEVICE_PATH_PROTOCOL *) DevicePathBuffer;\n  while (!IsDevicePathEnd (DevicePath)) {\n    if ((DevicePath->Type == 0) || (DevicePath->SubType == 0) || (DevicePathNodeLength (DevicePath) < sizeof (EFI_DEVICE_PATH_PROTOCOL))) {\n      //\n      // Invalid device path\n      //\n      FreePool (DevicePathBuffer);\n      return EFI_NOT_FOUND;\n    }\n    DevicePath = NextDevicePathNode (DevicePath);\n  }\n\n  //\n  // return the device path\n  //\n  *DevicePathData = DevicePathBuffer;\n  return EFI_SUCCESS;\n}", "path": "OpenCorePkg/Library/OcHiiDatabaseLib/ConfigRouting.c", "commit_date": "2020-04-07 00:00:00", "repo_name": "acidanthera/OpenCorePkg", "stars": 12577, "license": "bsd-3-clause", "language": "c", "size": 225079}
{"docstring": "/**\n  parse the configrequest string, get the elements.\n\n  @param      ConfigRequest         The input config request string.\n  @param      Progress              Return the progress data.\n\n  @retval     return data block array.\n**/\n", "func_signal": "IFR_BLOCK_DATA *\nGetNameElement (\n  IN  EFI_STRING           ConfigRequest,\n  OUT EFI_STRING           *Progress\n  )", "code": "{\n  EFI_STRING           StringPtr;\n  EFI_STRING           NextTag;\n  IFR_BLOCK_DATA       *BlockData;\n  IFR_BLOCK_DATA       *RequestBlockArray;\n  BOOLEAN              HasValue;\n\n  StringPtr = ConfigRequest;\n\n  //\n  // Init RequestBlockArray\n  //\n  RequestBlockArray = (IFR_BLOCK_DATA *) AllocateZeroPool (sizeof (IFR_BLOCK_DATA));\n  if (RequestBlockArray == NULL) {\n    goto Done;\n  }\n  InitializeListHead (&RequestBlockArray->Entry);\n\n  //\n  // Get the request Block array from the request string\n  //\n\n  //\n  // Parse each <RequestElement> if exists\n  // Only <BlockName> format is supported by this help function.\n  // <BlockName> ::= &'Name***=***\n  //\n  while (StringPtr != NULL && *StringPtr == L'&') {\n\n    *Progress   = StringPtr;\n    //\n    // Skip the L\"&\" string\n    //\n    StringPtr += 1;\n\n    HasValue = FALSE;\n    if ((NextTag = StrStr (StringPtr, L\"=\")) != NULL) {\n      *NextTag = L'\\0';\n      HasValue = TRUE;\n    } else if ((NextTag = StrStr (StringPtr, L\"&\")) != NULL) {\n      *NextTag = L'\\0';\n    }\n\n    //\n    // Set Block Data\n    //\n    BlockData = (IFR_BLOCK_DATA *) AllocateZeroPool (sizeof (IFR_BLOCK_DATA));\n    if (BlockData == NULL) {\n      goto Done;\n    }\n\n    //\n    // Get Name\n    //\n    BlockData->Name = AllocateCopyPool(StrSize (StringPtr), StringPtr);\n    InsertBlockData (&RequestBlockArray->Entry, &BlockData);\n\n    if (HasValue) {\n      //\n      // If has value, skip the value.\n      //\n      StringPtr = NextTag + 1;\n      *NextTag  = L'=';\n      StringPtr = StrStr (StringPtr, L\"&\");\n    } else if (NextTag != NULL) {\n      //\n      // restore the '&' text.\n      //\n      StringPtr = NextTag;\n      *NextTag  = L'&';\n    }\n  }\n\n  return RequestBlockArray;\n\nDone:\n  if (RequestBlockArray != NULL) {\n    //\n    // Free Link Array RequestBlockArray\n    //\n    while (!IsListEmpty (&RequestBlockArray->Entry)) {\n      BlockData = BASE_CR (RequestBlockArray->Entry.ForwardLink, IFR_BLOCK_DATA, Entry);\n      RemoveEntryList (&BlockData->Entry);\n      if (BlockData->Name != NULL) {\n        FreePool (BlockData->Name);\n      }\n      FreePool (BlockData);\n    }\n\n    FreePool (RequestBlockArray);\n  }\n\n  return NULL;\n}", "path": "OpenCorePkg/Library/OcHiiDatabaseLib/ConfigRouting.c", "commit_date": "2020-04-07 00:00:00", "repo_name": "acidanthera/OpenCorePkg", "stars": 12577, "license": "bsd-3-clause", "language": "c", "size": 225079}
{"docstring": "/**\n  This function inserts new BlockData into the block link\n\n  @param  BlockLink      The list entry points to block array.\n  @param  BlockData      The point to BlockData is added.\n\n**/\n", "func_signal": "VOID\nInsertBlockData (\n  IN LIST_ENTRY        *BlockLink,\n  IN IFR_BLOCK_DATA    **BlockData\n  )", "code": "{\n  LIST_ENTRY          *Link;\n  IFR_BLOCK_DATA      *BlockArray;\n  IFR_BLOCK_DATA      *BlockSingleData;\n\n  BlockSingleData = *BlockData;\n\n  if (BlockSingleData->Name != NULL) {\n    InsertTailList (BlockLink, &BlockSingleData->Entry);\n    return;\n  }\n\n  //\n  // Insert block data in its Offset and Width order.\n  //\n  for (Link = BlockLink->ForwardLink; Link != BlockLink; Link = Link->ForwardLink) {\n    BlockArray = BASE_CR (Link, IFR_BLOCK_DATA, Entry);\n    if (BlockArray->Offset == BlockSingleData->Offset) {\n      if ((BlockArray->Width > BlockSingleData->Width) || (BlockSingleData->IsBitVar && BlockArray->Width == BlockSingleData->Width)) {\n        //\n        // Insert this block data in the front of block array\n        //\n        InsertTailList (Link, &BlockSingleData->Entry);\n        return;\n      }\n\n      if ((!BlockSingleData->IsBitVar) && BlockArray->Width == BlockSingleData->Width) {\n        //\n        // The same block array has been added.\n        //\n        if (BlockSingleData != BlockArray) {\n          FreePool (BlockSingleData);\n          *BlockData = BlockArray;\n        }\n        return;\n      }\n    } else if (BlockArray->Offset > BlockSingleData->Offset) {\n      //\n      // Insert new block data in the front of block array\n      //\n      InsertTailList (Link, &BlockSingleData->Entry);\n      return;\n    }\n  }\n\n  //\n  // Add new block data into the tail.\n  //\n  InsertTailList (Link, &BlockSingleData->Entry);\n}", "path": "OpenCorePkg/Library/OcHiiDatabaseLib/ConfigRouting.c", "commit_date": "2020-04-07 00:00:00", "repo_name": "acidanthera/OpenCorePkg", "stars": 12577, "license": "bsd-3-clause", "language": "c", "size": 225079}
{"docstring": "/**\n  Check whether the this varstore is the request varstore.\n\n  @param  VarstoreGuid      Varstore guid.\n  @param  Name              Varstore name.\n  @param  ConfigHdr         Current configRequest info.\n\n  @retval  TRUE              This varstore is the request one.\n  @retval  FALSE             This varstore is not the request one.\n\n**/\n", "func_signal": "BOOLEAN\nIsThisVarstore (\n  IN EFI_GUID    *VarstoreGuid,\n  IN CHAR16      *Name,\n  IN CHAR16      *ConfigHdr\n  )", "code": "{\n  EFI_STRING               GuidStr;\n  EFI_STRING               NameStr;\n  EFI_STRING               TempStr;\n  UINTN                    LengthString;\n  BOOLEAN                  RetVal;\n\n  RetVal       = FALSE;\n  GuidStr      = NULL;\n  TempStr      = NULL;\n\n  //\n  // If ConfigHdr has name field and varstore not has name, return FALSE.\n  //\n  if (Name == NULL && ConfigHdr != NULL && StrStr (ConfigHdr, L\"NAME=&\") == NULL) {\n    return FALSE;\n  }\n\n  GenerateSubStr (L\"GUID=\", sizeof (EFI_GUID), (VOID *)VarstoreGuid, 1, &GuidStr);\n  if (Name != NULL) {\n    GenerateSubStr (L\"NAME=\", StrLen (Name) * sizeof (CHAR16), (VOID *) Name, 2, &NameStr);\n  } else {\n    GenerateSubStr (L\"NAME=\", 0, NULL, 2, &NameStr);\n  }\n  LengthString = StrLen (GuidStr);\n  LengthString = LengthString + StrLen (NameStr) + 1;\n  TempStr = AllocateZeroPool (LengthString * sizeof (CHAR16));\n  if (TempStr == NULL) {\n    goto Done;\n  }\n\n  StrCpyS (TempStr, LengthString, GuidStr);\n  StrCatS (TempStr, LengthString, NameStr);\n\n  if (ConfigHdr == NULL || StrnCmp (ConfigHdr, TempStr, StrLen (TempStr)) == 0) {\n    RetVal = TRUE;\n  }\n\nDone:\n  if (GuidStr != NULL) {\n    FreePool (GuidStr);\n  }\n\n  if (NameStr != NULL) {\n    FreePool (NameStr);\n  }\n\n  if (TempStr != NULL) {\n    FreePool (TempStr);\n  }\n\n  return RetVal;\n}", "path": "OpenCorePkg/Library/OcHiiDatabaseLib/ConfigRouting.c", "commit_date": "2020-04-07 00:00:00", "repo_name": "acidanthera/OpenCorePkg", "stars": 12577, "license": "bsd-3-clause", "language": "c", "size": 225079}
{"docstring": "/**\n  Retrieve the <ConfigBody> from String then output it.\n\n  This is a internal function.\n\n  @param  String                 A sub string of a configuration string in\n                                 <MultiConfigAltResp> format.\n  @param  ConfigBody             Points to the output string. It's caller's\n                                 responsibility to free this buffer.\n\n  @retval EFI_INVALID_PARAMETER  There is no form package in current hii database.\n  @retval EFI_OUT_OF_RESOURCES   Not enough memory to finish this operation.\n  @retval EFI_SUCCESS            All existing storage is exported.\n\n**/\n", "func_signal": "EFI_STATUS\nOutputConfigBody (\n  IN  EFI_STRING                   String,\n  OUT EFI_STRING                   *ConfigBody\n  )", "code": "{\n  EFI_STRING  TmpPtr;\n  EFI_STRING  Result;\n  UINTN       Length;\n\n  if (String == NULL || ConfigBody == NULL) {\n    return EFI_INVALID_PARAMETER;\n  }\n\n  //\n  // The setting information should start OFFSET, not ALTCFG.\n  //\n  if (StrnCmp (String, L\"&ALTCFG=\", StrLen (L\"&ALTCFG=\")) == 0) {\n    return EFI_INVALID_PARAMETER;\n  }\n\n  TmpPtr = StrStr (String, L\"GUID=\");\n  if (TmpPtr == NULL) {\n    //\n    // It is the last <ConfigResp> of the incoming configuration string.\n    //\n    Result = AllocateCopyPool (StrSize (String), String);\n    if (Result == NULL) {\n      return EFI_OUT_OF_RESOURCES;\n    } else {\n      *ConfigBody = Result;\n      return EFI_SUCCESS;\n    }\n  }\n\n  Length = TmpPtr - String;\n  if (Length == 0) {\n    return EFI_NOT_FOUND;\n  }\n  Result = AllocateCopyPool (Length * sizeof (CHAR16), String);\n  if (Result == NULL) {\n    return EFI_OUT_OF_RESOURCES;\n  }\n\n  *(Result + Length - 1) = 0;\n  *ConfigBody = Result;\n  return EFI_SUCCESS;\n}", "path": "OpenCorePkg/Library/OcHiiDatabaseLib/ConfigRouting.c", "commit_date": "2020-04-07 00:00:00", "repo_name": "acidanthera/OpenCorePkg", "stars": 12577, "license": "bsd-3-clause", "language": "c", "size": 225079}
{"docstring": "/**\n  Generate ConfigRequest string base on the varstore info.\n\n  @param      ConfigHdr             The config header for this varstore.\n  @param      VarStorageData        The varstore info.\n  @param      Status                Return Status.\n  @param      ConfigRequest         The ConfigRequest info may be return.\n\n  @retval     TRUE                  Need to continue\n  @retval     Others                NO need to continue or error occur.\n**/\n", "func_signal": "BOOLEAN\nGenerateConfigRequest (\n  IN  CHAR16                       *ConfigHdr,\n  IN  IFR_VARSTORAGE_DATA          *VarStorageData,\n  OUT EFI_STATUS                   *Status,\n  IN OUT EFI_STRING                *ConfigRequest\n  )", "code": "{\n  BOOLEAN               DataExist;\n  UINTN                 Length;\n  LIST_ENTRY            *Link;\n  CHAR16                *FullConfigRequest;\n  CHAR16                *StringPtr;\n  IFR_BLOCK_DATA        *BlockData;\n\n  //\n  // Append VarStorageData BlockEntry into *Request string\n  // Now support only one varstore in a form package.\n  //\n\n  //\n  // Go through all VarStorageData Entry and get BlockEntry for each one for the multiple varstore in a single form package\n  // Then construct them all to return MultiRequest string : ConfigHdr BlockConfig\n  //\n\n  //\n  // Compute the length of the entire request starting with <ConfigHdr> and a\n  // Null-terminator\n  //\n  DataExist = FALSE;\n  Length    = StrLen (ConfigHdr) + 1;\n\n  for (Link = VarStorageData->BlockEntry.ForwardLink; Link != &VarStorageData->BlockEntry; Link = Link->ForwardLink) {\n    DataExist = TRUE;\n    BlockData = BASE_CR (Link, IFR_BLOCK_DATA, Entry);\n    if (VarStorageData->Type == EFI_HII_VARSTORE_NAME_VALUE) {\n      //\n      // Add <BlockName> length for each Name\n      //\n      // <BlockName> ::= &Name1&Name2&...\n      //                 |1| StrLen(Name1)\n      //\n      Length = Length + (1 + StrLen (BlockData->Name));\n    } else {\n      //\n      // Add <BlockName> length for each Offset/Width pair\n      //\n      // <BlockName> ::= &OFFSET=1234&WIDTH=1234\n      //                 |  8   | 4 |   7  | 4 |\n      //\n      Length = Length + (8 + 4 + 7 + 4);\n    }\n  }\n  //\n  // No any request block data is found. The request string can't be constructed.\n  //\n  if (!DataExist) {\n    *Status = EFI_SUCCESS;\n    return FALSE;\n  }\n\n  //\n  // Allocate buffer for the entire <ConfigRequest>\n  //\n  FullConfigRequest = AllocateZeroPool (Length * sizeof (CHAR16));\n  if (FullConfigRequest == NULL) {\n    *Status = EFI_OUT_OF_RESOURCES;\n    return FALSE;\n  }\n  StringPtr = FullConfigRequest;\n\n  //\n  // Start with <ConfigHdr>\n  //\n  StrCpyS (StringPtr, Length, ConfigHdr);\n  StringPtr += StrLen (StringPtr);\n\n  //\n  // Loop through all the Offset/Width pairs and append them to ConfigRequest\n  //\n  for (Link = VarStorageData->BlockEntry.ForwardLink; Link != &VarStorageData->BlockEntry; Link = Link->ForwardLink) {\n    BlockData = BASE_CR (Link, IFR_BLOCK_DATA, Entry);\n    if (VarStorageData->Type == EFI_HII_VARSTORE_NAME_VALUE) {\n      //\n      // Append &Name1\\0\n      //\n      UnicodeSPrint (\n        StringPtr,\n        (1 + StrLen (BlockData->Name) + 1) * sizeof (CHAR16),\n        L\"&%s\",\n        BlockData->Name\n      );\n    } else {\n      //\n      // Append &OFFSET=XXXX&WIDTH=YYYY\\0\n      //\n      UnicodeSPrint (\n        StringPtr,\n        (8 + 4 + 7 + 4 + 1) * sizeof (CHAR16),\n        L\"&OFFSET=%04X&WIDTH=%04X\",\n        BlockData->Offset,\n        BlockData->Width\n      );\n    }\n    StringPtr += StrLen (StringPtr);\n  }\n  //\n  // Set to the got full request string.\n  //\n  HiiToLower (FullConfigRequest);\n\n  if (*ConfigRequest != NULL) {\n    FreePool (*ConfigRequest);\n  }\n  *ConfigRequest = FullConfigRequest;\n\n  return TRUE;\n}", "path": "OpenCorePkg/Library/OcHiiDatabaseLib/ConfigRouting.c", "commit_date": "2020-04-07 00:00:00", "repo_name": "acidanthera/OpenCorePkg", "stars": 12577, "license": "bsd-3-clause", "language": "c", "size": 225079}
{"docstring": "/**\n  Check whether File Device Paths are equal.\n\n  @param[in] FilePath1  The first device path protocol to compare.\n  @param[in] FilePath2  The second device path protocol to compare.\n\n  @retval TRUE         The device paths matched\n  @retval FALSE        The device paths were different\n**/\n", "func_signal": "BOOLEAN\nFileDevicePathsEqual (\n  IN FILEPATH_DEVICE_PATH  *FilePath1,\n  IN FILEPATH_DEVICE_PATH  *FilePath2\n  )", "code": "{\n  ASSERT (FilePath1 != NULL);\n  ASSERT (FilePath2 != NULL);\n\n  return InternalFileDevicePathsEqualWorker (&FilePath1, &FilePath2);\n}", "path": "OpenCorePkg/Library/OcDevicePathLib/OcDevicePathLib.c", "commit_date": "2020-12-03 00:00:00", "repo_name": "acidanthera/OpenCorePkg", "stars": 12577, "license": "bsd-3-clause", "language": "c", "size": 225079}
{"docstring": "/**\n  Retrieves a string from a string package.\n\n  If HiiHandle is NULL, then ASSERT().\n  If StringId is 0, then ASSET.\n\n  @param[in]  HiiHandle  A handle that was previously registered in the HII Database.\n  @param[in]  StringId   The identifier of the string to retrieved from the string\n                         package associated with HiiHandle.\n\n  @retval NULL   The string specified by StringId is not present in the string package.\n  @retval Other  The string was returned.\n\n**/\n", "func_signal": "EFI_STRING\nInternalGetString (\n  IN EFI_HII_HANDLE  HiiHandle,\n  IN EFI_STRING_ID   StringId\n  )", "code": "{\n  EFI_STATUS  Status;\n  UINTN       StringSize;\n  CHAR16      TempString;\n  EFI_STRING  String;\n  CHAR8       *SupportedLanguages;\n  CHAR8       *PlatformLanguage;\n  CHAR8       *BestLanguage;\n  CHAR8       *Language;\n\n  ASSERT (HiiHandle != NULL);\n  ASSERT (StringId != 0);\n\n  //\n  // Initialize all allocated buffers to NULL\n  //\n  SupportedLanguages = NULL;\n  PlatformLanguage   = NULL;\n  BestLanguage       = NULL;\n  String             = NULL;\n  Language           = \"\";\n\n  //\n  // Get the languages that the package specified by HiiHandle supports\n  //\n  SupportedLanguages = GetSupportedLanguages (HiiHandle);\n  if (SupportedLanguages == NULL) {\n    goto Error;\n  }\n\n  //\n  // Get the current platform language setting\n  //\n  GetEfiGlobalVariable2 (L\"PlatformLang\", (VOID**)&PlatformLanguage, NULL);\n\n  //\n  // Get the best matching language from SupportedLanguages\n  //\n  BestLanguage = GetBestLanguage (\n                   SupportedLanguages,\n                   FALSE,                                             // RFC 4646 mode\n                   Language,                                          // Highest priority\n                   PlatformLanguage != NULL ? PlatformLanguage : \"\",  // Next highest priority\n                   SupportedLanguages,                                // Lowest priority\n                   NULL\n                   );\n  if (BestLanguage == NULL) {\n    goto Error;\n  }\n\n  //\n  // Retrieve the size of the string in the string package for the BestLanguage\n  //\n  StringSize = 0;\n  Status = mPrivate.HiiString.GetString (\n                         &mPrivate.HiiString,\n                         BestLanguage,\n                         HiiHandle,\n                         StringId,\n                         &TempString,\n                         &StringSize,\n                         NULL\n                         );\n  //\n  // If GetString() returns EFI_SUCCESS for a zero size,\n  // then there are no supported languages registered for HiiHandle.  If GetString()\n  // returns an error other than EFI_BUFFER_TOO_SMALL, then HiiHandle is not present\n  // in the HII Database\n  //\n  if (Status != EFI_BUFFER_TOO_SMALL) {\n    goto Error;\n  }\n\n  //\n  // Allocate a buffer for the return string\n  //\n  String = AllocateZeroPool (StringSize);\n  if (String == NULL) {\n    goto Error;\n  }\n\n  //\n  // Retrieve the string from the string package\n  //\n  Status = mPrivate.HiiString.GetString (\n                         &mPrivate.HiiString,\n                         BestLanguage,\n                         HiiHandle,\n                         StringId,\n                         String,\n                         &StringSize,\n                         NULL\n                         );\n  if (EFI_ERROR (Status)) {\n    //\n    // Free the buffer and return NULL if the supported languages can not be retrieved.\n    //\n    FreePool (String);\n    String = NULL;\n  }\n\nError:\n  //\n  // Free allocated buffers\n  //\n  if (SupportedLanguages != NULL) {\n    FreePool (SupportedLanguages);\n  }\n  if (PlatformLanguage != NULL) {\n    FreePool (PlatformLanguage);\n  }\n  if (BestLanguage != NULL) {\n    FreePool (BestLanguage);\n  }\n\n  //\n  // Return the Null-terminated Unicode string\n  //\n  return String;\n}", "path": "OpenCorePkg/Library/OcHiiDatabaseLib/ConfigRouting.c", "commit_date": "2020-04-07 00:00:00", "repo_name": "acidanthera/OpenCorePkg", "stars": 12577, "license": "bsd-3-clause", "language": "c", "size": 225079}
{"docstring": "/**\n  Get form package data from data base.\n\n  @param  DataBaseRecord         The DataBaseRecord instance contains the found Hii handle and package.\n  @param  HiiFormPackage         The buffer saves the package data.\n  @param  PackageSize            The buffer size of the package data.\n\n**/\n", "func_signal": "EFI_STATUS\nGetFormPackageData (\n  IN     HII_DATABASE_RECORD        *DataBaseRecord,\n  IN OUT UINT8                      **HiiFormPackage,\n  OUT    UINTN                      *PackageSize\n  )", "code": "{\n  EFI_STATUS                   Status;\n  UINTN                        Size;\n  UINTN                        ResultSize;\n\n  if (DataBaseRecord == NULL || HiiFormPackage == NULL || PackageSize == NULL) {\n    return EFI_INVALID_PARAMETER;\n  }\n\n  Size       = 0;\n  ResultSize = 0;\n  //\n  // 0. Get Hii Form Package by HiiHandle\n  //\n  Status = ExportFormPackages (\n             &mPrivate,\n             DataBaseRecord->Handle,\n             DataBaseRecord->PackageList,\n             0,\n             Size,\n             HiiFormPackage,\n             &ResultSize\n           );\n  if (EFI_ERROR (Status)) {\n    return Status;\n  }\n\n  (*HiiFormPackage) = AllocatePool (ResultSize);\n  if (*HiiFormPackage == NULL) {\n    Status = EFI_OUT_OF_RESOURCES;\n    return Status;\n  }\n\n  //\n  // Get HiiFormPackage by HiiHandle\n  //\n  Size   = ResultSize;\n  ResultSize    = 0;\n  Status = ExportFormPackages (\n             &mPrivate,\n             DataBaseRecord->Handle,\n             DataBaseRecord->PackageList,\n             0,\n             Size,\n             *HiiFormPackage,\n             &ResultSize\n           );\n  if (EFI_ERROR (Status)) {\n    FreePool (*HiiFormPackage);\n  }\n\n  *PackageSize = Size;\n\n  return Status;\n}", "path": "OpenCorePkg/Library/OcHiiDatabaseLib/ConfigRouting.c", "commit_date": "2020-04-07 00:00:00", "repo_name": "acidanthera/OpenCorePkg", "stars": 12577, "license": "bsd-3-clause", "language": "c", "size": 225079}
{"docstring": "/**\n * longCommandWArg():\n * Checks if *stringPtr is the same as longCommand.\n * If yes, @return 1 and advances *stringPtr to the position which immediately follows longCommand.\n * @return 0 and doesn't modify *stringPtr otherwise.\n */\n", "func_signal": "static int longCommandWArg(const char** stringPtr, const char* longCommand)", "code": "{\n    assert(longCommand); assert(stringPtr); assert(*stringPtr);\n    size_t const comSize = strlen(longCommand);\n    int const result = !strncmp(*stringPtr, longCommand, comSize);\n    if (result) *stringPtr += comSize;\n    return result;\n}", "path": "xxHash/tests/collisions/main.c", "commit_date": "2020-11-26 00:00:00", "repo_name": "Cyan4973/xxHash", "stars": 8222, "license": "other", "language": "c", "size": 4398}
{"docstring": "/*\n * Attach hash to 2 slots\n * return: Nb of potential candidates detected\n *          0: position not yet occupied\n *          2: position previously occupied by a single candidate (at most)\n *          1: position already occupied by multiple candidates\n */\n", "func_signal": "static inline int Filter_insert(Filter* bf, int bflog, uint64_t hash)", "code": "{\n     hash = avalanche64(hash);\n     unsigned const slot1 = hash & 255;\n     hash >>= 8;\n     unsigned const slot2 = hash & 255;\n     hash >>= 8;\n\n     size_t const fclmask = ((size_t)1 << (bflog-6)) - 1;\n     size_t const cacheLineNb = hash & fclmask;\n\n     size_t const pos1 = (cacheLineNb << 6) + (slot1 >> 2);\n     unsigned const shift1 = (slot1 & 3) * 2;\n     unsigned const ex1 = (bf[pos1] >> shift1) & 3;\n\n     size_t const pos2 = (cacheLineNb << 6) + (slot2 >> 2);\n     unsigned const shift2 = (slot2 & 3) * 2;\n     unsigned const ex2 = (bf[pos2] >> shift2) & 3;\n\n     unsigned const existing = MIN(ex1, ex2);\n\n     static const int addCandidates[4] = { 0, 2, 1, 1 };\n     static const unsigned nextValue[4] = { 1, 2, 3, 3 };\n\n     bf[pos1] &= (Filter)(~(3 << shift1)); /* erase previous value */\n     bf[pos1] |= (Filter)(MAX(ex1, nextValue[existing]) << shift1);\n     bf[pos2] |= (Filter)(MAX(ex2, nextValue[existing]) << shift2);\n\n     return addCandidates[existing];\n }\n\n\n/*\n * Check if provided 64-bit hash is a collision candidate\n * Requires the slot to be occupied by at least 2 candidates.\n * return >0 if hash is a collision candidate\n *         0 otherwise (slot unoccupied, or only one candidate)\n * note: unoccupied slots should not happen in this algorithm,\n *       since all hashes are supposed to have been inserted at least once.\n */\nstatic inline int Filter_check(const Filter* bf, int bflog, uint64_t hash)\n {\n     hash = avalanche64(hash);\n     unsigned const slot1 = hash & 255;\n     hash >>= 8;\n     unsigned const slot2 = hash & 255;\n     hash >>= 8;\n\n     size_t const fclmask = ((size_t)1 << (bflog-6)) - 1;\n     size_t const cacheLineNb = hash & fclmask;\n\n     size_t const pos1 = (cacheLineNb << 6) + (slot1 >> 2);\n     unsigned const shift1 = (slot1 & 3) * 2;\n     unsigned const ex1 = (bf[pos1] >> shift1) & 3;\n\n     size_t const pos2 = (cacheLineNb << 6) + (slot2 >> 2);\n     unsigned const shift2 = (slot2 & 3) * 2;\n     unsigned const ex2 = (bf[pos2] >> shift2) & 3;\n\n     return (ex1 >= 2) && (ex2 >= 2);\n }\n\n#endif // FILTER_1_PROBE\n\n\n/* ===  Display  === */\n\n#include <time.h>   /* clock_t, clock, time_t, time, difftime */\n\nvoid update_indicator(uint64_t v, uint64_t total)\n{\n    static clock_t start = 0;\n    if (start==0) start = clock();\n    clock_t const updateRate = CLOCKS_PER_SEC / 2;\n\n    clock_t const clockSpan = (clock_t)(clock() - start);\n    if (clockSpan > updateRate) {\n        start = clock();\n        assert(v <= total);\n        assert(total > 0);\n        double share = ((double)v / (double)total) * 100;\n        printf(\"%6.2f%% (%llu)  \\r\", share, (unsigned long long)v);\n        fflush(NULL);\n    }\n}", "path": "xxHash/tests/collisions/main.c", "commit_date": "2020-11-26 00:00:00", "repo_name": "Cyan4973/xxHash", "stars": 8222, "license": "other", "language": "c", "size": 4398}
{"docstring": "/*\n * fprintf wrapper that supports UTF-8.\n *\n * fprintf doesn't properly handle Unicode on Windows.\n *\n * Additionally, it is codepage sensitive on console and may crash the program.\n *\n * Instead, we use vsnprintf, and either print with fwrite or convert to UTF-16\n * for console output and use the codepage-independent WriteConsoleW.\n *\n * Credit to t-mat: https://github.com/t-mat/xxHash/commit/5691423\n */\n", "func_signal": "XSUM_ATTRIBUTE((__format__(__printf__, 2, 0)))\nXSUM_API int XSUM_vfprintf(FILE *stream, const char *format, va_list ap)", "code": "{\n    int result;\n    char* u8_str = NULL;\n\n    /*\n     * Generate the UTF-8 output string with vasprintf.\n     */\n    result = XSUM_vasprintf(&u8_str, format, ap);\n\n    if (result >= 0) {\n        const size_t nchar = (size_t)result + 1;\n\n        /*\n         * Check if we are outputting to a console. Don't use XSUM_isConsole\n         * directly -- we don't need to call _get_osfhandle twice.\n         */\n        int fileNb = _fileno(stream);\n        intptr_t handle_raw = _get_osfhandle(fileNb);\n        HANDLE handle = (HANDLE)handle_raw;\n        DWORD dwTemp;\n\n        if (handle_raw < 0) {\n             result = -1;\n        } else if (_isatty(fileNb) && GetConsoleMode(handle, &dwTemp)) {\n            /*\n             * Convert to UTF-16 and output with WriteConsoleW.\n             *\n             * This is codepage independent and works on Windows XP's default\n             * msvcrt.dll.\n             */\n            int len;\n            wchar_t* const u16_buf = XSUM_widenString(u8_str, &len);\n            if (u16_buf == NULL) {\n                result = -1;\n            } else {\n                if (WriteConsoleW(handle, u16_buf, (DWORD)len - 1, &dwTemp, NULL)) {\n                    result = (int)dwTemp;\n                } else {\n                    result = -1;\n                }\n                free(u16_buf);\n            }\n        } else {\n            /* fwrite the UTF-8 string if we are printing to a file */\n            result = (int)fwrite(u8_str, 1, nchar - 1, stream);\n            if (result == 0) {\n                result = -1;\n            }\n        }\n        free(u8_str);\n    }\n    return result;\n}", "path": "xxHash/cli/xsum_os_specific.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "Cyan4973/xxHash", "stars": 8222, "license": "other", "language": "c", "size": 4398}
{"docstring": "/* typedef'd to BMK_timedFnState_t within bench.h */\n", "func_signal": "BMK_timedFnState_t* BMK_createTimedFnState(unsigned total_ms, unsigned run_ms)", "code": "{\n    BMK_timedFnState_t* const r = (BMK_timedFnState_t*)malloc(sizeof(*r));\n    if (r == NULL) return NULL;   /* malloc() error */\n    BMK_resetTimedFnState(r, total_ms, run_ms);\n    return r;\n}", "path": "xxHash/tests/bench/benchfn.c", "commit_date": "2020-03-09 00:00:00", "repo_name": "Cyan4973/xxHash", "stars": 8222, "license": "other", "language": "c", "size": 4398}
{"docstring": "/*\n * Converts a UTF-16 string to UTF-8. Acts like strdup. The string must be freed afterwards.\n * This version allows keeping the output length.\n */\n", "func_signal": "static char* XSUM_narrowString(const wchar_t *str, int *lenOut)", "code": "{\n    int len = WideCharToMultiByte(CP_UTF8, 0, str, -1, NULL, 0, NULL, NULL);\n    if (lenOut != NULL) *lenOut = len;\n    if (len == 0) return NULL;\n    {   char* const buf = (char*)malloc((size_t)len * sizeof(char));\n        if (buf != NULL) {\n            if (WideCharToMultiByte(CP_UTF8, 0, str, -1, buf, len, NULL, NULL) == 0) {\n                free(buf);\n                return NULL;\n        }    }\n        return buf;\n    }\n}", "path": "xxHash/cli/xsum_os_specific.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "Cyan4973/xxHash", "stars": 8222, "license": "other", "language": "c", "size": 4398}
{"docstring": "/*\n * Converts a UTF-8 string to UTF-16. Acts like strdup. The string must be freed afterwards.\n * This version allows keeping the output length.\n */\n", "func_signal": "static wchar_t* XSUM_widenString(const char* str, int* lenOut)", "code": "{\n    int const len = MultiByteToWideChar(CP_UTF8, 0, str, -1, NULL, 0);\n    if (lenOut != NULL) *lenOut = len;\n    if (len == 0) return NULL;\n    {   wchar_t* buf = (wchar_t*)malloc((size_t)len * sizeof(wchar_t));\n        if (buf != NULL) {\n            if (MultiByteToWideChar(CP_UTF8, 0, str, -1, buf, len) == 0) {\n                free(buf);\n                return NULL;\n       }    }\n       return buf;\n    }\n}", "path": "xxHash/cli/xsum_os_specific.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "Cyan4973/xxHash", "stars": 8222, "license": "other", "language": "c", "size": 4398}
{"docstring": "/* @return : 0 on success, 1 on error */\n", "func_signal": "static int POOL_resize_internal(POOL_ctx* ctx, size_t numThreads)", "code": "{\n    if (numThreads <= ctx->threadCapacity) {\n        if (!numThreads) return 1;\n        ctx->threadLimit = numThreads;\n        return 0;\n    }\n    /* numThreads > threadCapacity */\n    {   ZSTD_pthread_t* const threadPool = (ZSTD_pthread_t*)malloc(numThreads * sizeof(ZSTD_pthread_t));\n        if (!threadPool) return 1;\n        /* replace existing thread pool */\n        memcpy(threadPool, ctx->threads, ctx->threadCapacity * sizeof(*threadPool));\n        free(ctx->threads);\n        ctx->threads = threadPool;\n        /* Initialize additional threads */\n        {   size_t threadId;\n            for (threadId = ctx->threadCapacity; threadId < numThreads; ++threadId) {\n                if (ZSTD_pthread_create(&threadPool[threadId], NULL, &POOL_thread, ctx)) {\n                    ctx->threadCapacity = threadId;\n                    return 1;\n            }   }\n    }   }\n    /* successfully expanded */\n    ctx->threadCapacity = numThreads;\n    ctx->threadLimit = numThreads;\n    return 0;\n}", "path": "xxHash/tests/collisions/pool.c", "commit_date": "2020-03-09 00:00:00", "repo_name": "Cyan4973/xxHash", "stars": 8222, "license": "other", "language": "c", "size": 4398}
{"docstring": "/* assumption: (htype*)hTablePtr[index] is valid */\n", "func_signal": "static void addHashCandidate(void* hTablePtr, UniHash h, Htype_e htype, size_t index)", "code": "{\n    if ((htype == ht64) || (htype == ht32)) {\n        ((uint64_t*)hTablePtr)[index] = h.h64;\n    } else {\n        assert(htype == ht128);\n        ((XXH128_hash_t*)hTablePtr)[index] = h.h128;\n    }\n}", "path": "xxHash/tests/collisions/main.c", "commit_date": "2020-11-26 00:00:00", "repo_name": "Cyan4973/xxHash", "stars": 8222, "license": "other", "language": "c", "size": 4398}
{"docstring": "/*\n * stat() wrapper which supports UTF-8 filenames.\n */\n", "func_signal": "static int XSUM_stat(const char* infilename, XSUM_stat_t* statbuf)", "code": "{\n    int r = -1;\n    wchar_t* const wide_filename = XSUM_widenString(infilename, NULL);\n    if (wide_filename != NULL) {\n        r = _wstat64(wide_filename, statbuf);\n        free(wide_filename);\n    }\n    return r;\n}", "path": "xxHash/cli/xsum_os_specific.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "Cyan4973/xxHash", "stars": 8222, "license": "other", "language": "c", "size": 4398}
{"docstring": "/* Nb of combinations of m bits in a register of n bits */\n", "func_signal": "static double Cnm(int n, int m)", "code": "{\n    assert(n > 0);\n    assert(m > 0);\n    assert(m <= m);\n    double acc = 1;\n    for (int i=0; i<m; i++) {\n        acc *= n - i;\n        acc /= 1 + i;\n    }\n    return acc;\n}", "path": "xxHash/tests/collisions/main.c", "commit_date": "2020-11-26 00:00:00", "repo_name": "Cyan4973/xxHash", "stars": 8222, "license": "other", "language": "c", "size": 4398}
{"docstring": "/*\n * Check if provided 64-bit hash is a collision candidate\n * Requires the slot to be occupied by at least 2 candidates.\n * return >0 if hash is a collision candidate\n *         0 otherwise (slot unoccupied, or only one candidate)\n * note: unoccupied slots should not happen in this algorithm,\n *       since all hashes are supposed to have been inserted at least once.\n */\n", "func_signal": "inline int Filter_check(const Filter* bf, int bflog, uint64_t hash)", "code": "{\n    int const slotNb = hash & 3;\n    int const shift = slotNb * 2;\n\n    size_t const bfmask = ((size_t)1 << bflog) - 1;\n    size_t const pos = (hash >> 2) & bfmask;\n\n    return (((const unsigned char*)bf)[pos]) >> (shift+1) & 1;\n}", "path": "xxHash/tests/collisions/main.c", "commit_date": "2020-11-26 00:00:00", "repo_name": "Cyan4973/xxHash", "stars": 8222, "license": "other", "language": "c", "size": 4398}
{"docstring": "/* initFn will be measured once, benchFn will be measured `nbLoops` times */\n/* initFn is optional, provide NULL if none */\n/* benchFn must return a size_t value that errorFn can interpret */\n/* takes # of blocks and list of size & stuff for each. */\n/* can report result of benchFn for each block into blockResult. */\n/* blockResult is optional, provide NULL if this information is not required */\n/* note : time per loop can be reported as zero if run time < timer resolution */\n", "func_signal": "BMK_runOutcome_t BMK_benchFunction(BMK_benchParams_t p,\n                                   unsigned nbLoops)", "code": "{\n    /* init */\n    {   size_t i;\n        for (i = 0; i < p.blockCount; i++) {\n            memset(p.dstBuffers[i], 0xE5, p.dstCapacities[i]);  /* warm up and erase result buffer */\n    }   }\n\n    /* benchmark */\n    {   UTIL_time_t const clockStart = UTIL_getTime();\n        size_t dstSize = 0;\n        unsigned loopNb, blockNb;\n        nbLoops += !nbLoops;   /* minimum nbLoops is 1 */\n        if (p.initFn != NULL) p.initFn(p.initPayload);\n        for (loopNb = 0; loopNb < nbLoops; loopNb++) {\n            for (blockNb = 0; blockNb < p.blockCount; blockNb++) {\n                size_t const res = p.benchFn(p.srcBuffers[blockNb], p.srcSizes[blockNb],\n                                   p.dstBuffers[blockNb], p.dstCapacities[blockNb],\n                                   p.benchPayload);\n                if (loopNb == 0) {\n                    if (p.blockResults != NULL) p.blockResults[blockNb] = res;\n                    if ((p.errorFn != NULL) && (p.errorFn(res))) {\n                        RETURN_QUIET_ERROR(BMK_runOutcome_error(res),\n                            \"Function benchmark failed on block %u (of size %u) with error %i\",\n                            blockNb, (unsigned)p.srcSizes[blockNb], (int)res);\n                    }\n                    dstSize += res;\n            }   }\n        }  /* for (loopNb = 0; loopNb < nbLoops; loopNb++) */\n\n        {   PTime const totalTime = UTIL_clockSpanNano(clockStart);\n            BMK_runTime_t rt;\n            rt.nanoSecPerRun = (double)totalTime / nbLoops;\n            rt.sumOfReturn = dstSize;\n            return BMK_setValid_runTime(rt);\n    }   }\n}", "path": "xxHash/tests/bench/benchfn.c", "commit_date": "2020-03-09 00:00:00", "repo_name": "Cyan4973/xxHash", "stars": 8222, "license": "other", "language": "c", "size": 4398}
{"docstring": "/* note: not thread safe */\n", "func_signal": "const char* displayDelay(double delay_s)", "code": "{\n    static char delayString[50];\n    memset(delayString, 0, sizeof(delayString));\n\n    int const mn = ((int)delay_s / 60) % 60;\n    int const h = (int)delay_s / 3600;\n    int const sec = (int)delay_s % 60;\n\n    char* p = delayString;\n    if (h) sprintf(p, \"%i h \", h);\n    if (mn || h) {\n        p = delayString + strlen(delayString);\n        sprintf(p, \"%i mn \", mn);\n    }\n    p = delayString + strlen(delayString);\n    sprintf(p, \"%is \", sec);\n\n    return delayString;\n}", "path": "xxHash/tests/collisions/main.c", "commit_date": "2020-11-26 00:00:00", "repo_name": "Cyan4973/xxHash", "stars": 8222, "license": "other", "language": "c", "size": 4398}
{"docstring": "/*\n * Determines whether the file at filename is a directory.\n */\n", "func_signal": "XSUM_API int XSUM_isDirectory(const char* filename)", "code": "{\n    XSUM_stat_t statbuf;\n    int r = XSUM_stat(filename, &statbuf);\n#ifdef _MSC_VER\n    if (!r && (statbuf.st_mode & _S_IFDIR)) return 1;\n#else\n    if (!r && S_ISDIR(statbuf.st_mode)) return 1;\n#endif\n    return 0;\n}", "path": "xxHash/cli/xsum_os_specific.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "Cyan4973/xxHash", "stars": 8222, "license": "other", "language": "c", "size": 4398}
{"docstring": "/* can't store nor analyze hash wider than 64-bits for the time being */\n", "func_signal": "uint64_t select_nbh(int nbBits)", "code": "{\n    assert(nbBits > 0);\n    if (nbBits > NB_BITS_MAX) nbBits = NB_BITS_MAX;\n    double targetColls = (double)((128 + 17) - (nbBits * 2));\n    uint64_t nbH = 24;\n    while (estimateNbCollisions(nbH, nbBits) < targetColls) nbH *= 2;\n    return nbH;\n}", "path": "xxHash/tests/collisions/main.c", "commit_date": "2020-11-26 00:00:00", "repo_name": "Cyan4973/xxHash", "stars": 8222, "license": "other", "language": "c", "size": 4398}
{"docstring": "/* Frees arguments returned by XSUM_convertArgv */\n", "func_signal": "static void XSUM_freeArgv(int argc, char** argv)", "code": "{\n    int i;\n    if (argv == NULL) {\n        return;\n    }\n    for (i = 0; i < argc; i++) {\n        free(argv[i]);\n    }\n    free(argv);\n}", "path": "xxHash/cli/xsum_os_specific.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "Cyan4973/xxHash", "stars": 8222, "license": "other", "language": "c", "size": 4398}
{"docstring": "/* Converts a UTF-16 argv to UTF-8. */\n", "func_signal": "static char** XSUM_convertArgv(int argc, wchar_t* utf16_argv[])", "code": "{\n    char** const utf8_argv = (char**)malloc((size_t)(argc + 1) * sizeof(char*));\n    if (utf8_argv != NULL) {\n        int i;\n        for (i = 0; i < argc; i++) {\n            utf8_argv[i] = XSUM_narrowString(utf16_argv[i], NULL);\n            if (utf8_argv[i] == NULL) {\n                /* Out of memory, whoops. */\n                while (i-- > 0) {\n                    free(utf8_argv[i]);\n                }\n                free(utf8_argv);\n                return NULL;\n            }\n        }\n        utf8_argv[argc] = NULL;\n    }\n    return utf8_argv;\n}", "path": "xxHash/cli/xsum_os_specific.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "Cyan4973/xxHash", "stars": 8222, "license": "other", "language": "c", "size": 4398}
{"docstring": "/**\n * Returns 1 if the queue is full and 0 otherwise.\n *\n * When queueSize is 1 (pool was created with an intended queueSize of 0),\n * then a queue is empty if there is a thread free _and_ no job is waiting.\n */\n", "func_signal": "static int isQueueFull(POOL_ctx const* ctx)", "code": "{\n    if (ctx->queueSize > 1) {\n        return ctx->queueHead == ((ctx->queueTail + 1) % ctx->queueSize);\n    } else {\n        return (ctx->numThreadsBusy == ctx->threadLimit) ||\n               !ctx->queueEmpty;\n    }\n}", "path": "xxHash/tests/collisions/pool.c", "commit_date": "2020-03-09 00:00:00", "repo_name": "Cyan4973/xxHash", "stars": 8222, "license": "other", "language": "c", "size": 4398}
{"docstring": "/* POOL_thread() :\n * Work thread for the thread pool.\n * Waits for jobs and executes them.\n * @returns : NULL on failure else non-null.\n */\n", "func_signal": "static void* POOL_thread(void* opaque)", "code": "{\n    POOL_ctx* const ctx = (POOL_ctx*)opaque;\n    if (!ctx) { return NULL; }\n    for (;;) {\n        /* Lock the mutex and wait for a non-empty queue or until shutdown */\n        ZSTD_pthread_mutex_lock(&ctx->queueMutex);\n\n        while ( ctx->queueEmpty\n            || (ctx->numThreadsBusy >= ctx->threadLimit) ) {\n            if (ctx->shutdown) {\n                /* even if !queueEmpty, (possible if numThreadsBusy >= threadLimit),\n                 * a few threads will be shutdown while !queueEmpty,\n                 * but enough threads will remain active to finish the queue */\n                ZSTD_pthread_mutex_unlock(&ctx->queueMutex);\n                return opaque;\n            }\n            ZSTD_pthread_cond_wait(&ctx->queuePopCond, &ctx->queueMutex);\n        }\n        /* Pop a job off the queue */\n        {   POOL_job const job = ctx->queue[ctx->queueHead];\n            ctx->queueHead = (ctx->queueHead + 1) % ctx->queueSize;\n            ctx->numThreadsBusy++;\n            ctx->queueEmpty = ctx->queueHead == ctx->queueTail;\n            /* Unlock the mutex, signal a pusher, and run the job */\n            ZSTD_pthread_cond_signal(&ctx->queuePushCond);\n            ZSTD_pthread_mutex_unlock(&ctx->queueMutex);\n\n            job.function(job.opaque);\n\n            /* If the intended queue size was 0, signal after finishing job */\n            ZSTD_pthread_mutex_lock(&ctx->queueMutex);\n            ctx->numThreadsBusy--;\n            if (ctx->queueSize == 1) {\n                ZSTD_pthread_cond_signal(&ctx->queuePushCond);\n            }\n            ZSTD_pthread_mutex_unlock(&ctx->queueMutex);\n        }\n    }  /* for (;;) */\n    assert(0);  /* Unreachable */\n}", "path": "xxHash/tests/collisions/pool.c", "commit_date": "2020-03-09 00:00:00", "repo_name": "Cyan4973/xxHash", "stars": 8222, "license": "other", "language": "c", "size": 4398}
{"docstring": "/* @return : 0 on success, 1 on error */\n", "func_signal": "int POOL_resize(POOL_ctx* ctx, size_t numThreads)", "code": "{\n    int result;\n    if (ctx==NULL) return 1;\n    ZSTD_pthread_mutex_lock(&ctx->queueMutex);\n    result = POOL_resize_internal(ctx, numThreads);\n    ZSTD_pthread_cond_broadcast(&ctx->queuePopCond);\n    ZSTD_pthread_mutex_unlock(&ctx->queueMutex);\n    return result;\n}", "path": "xxHash/tests/collisions/pool.c", "commit_date": "2020-03-09 00:00:00", "repo_name": "Cyan4973/xxHash", "stars": 8222, "license": "other", "language": "c", "size": 4398}
{"docstring": "//---------------------------------------------------------------------------\n// BigNum_CreateFromBigNum\n//---------------------------------------------------------------------------\n", "func_signal": "_FX BIGNUM BigNum_CreateFromBigNum(POOL *pool, BIGNUM Value)", "code": "{\n    //\n    // create a new bignum from the given input bignum.  note that leading\n    // zero words are stripped when creating the new bignum.\n    //\n\n    BIGNUM BigNum;\n    ULONG Words, WordIndex;\n\n    Words = *Value;\n    while (Words > 1 && Value[Words] == 0)\n        --Words;\n\n    BigNum = Pool_Alloc(pool, sizeof(ULONG) * (Words + 1));\n    if (BigNum) {\n\n        *BigNum = Words;\n        for (WordIndex = 1; WordIndex <= Words; ++WordIndex)\n            BigNum[WordIndex] = Value[WordIndex];\n    }\n\n    return BigNum;\n}", "path": "Sandboxie/Sandboxie/common/bignum.c", "commit_date": "2020-04-09 00:00:00", "repo_name": "sandboxie-plus/Sandboxie", "stars": 11788, "license": "gpl-3.0", "language": "c", "size": 86045}
{"docstring": "//---------------------------------------------------------------------------\n// Pool_Get_Cells\n//---------------------------------------------------------------------------\n", "func_signal": "ALIGNED void *Pool_Get_Cells(POOL *pool, ULONG size)", "code": "{\n    POOL_DECLARE_IRQL\n    PAGE *page, *next_page;\n    UCHAR *bitmap;\n    ULONG mask;\n    UCHAR *ptr;\n    ULONG index = -1;\n\n    Pool_Timing(NULL);\n\n    // look for a page that has enough free cells to satisfy the request\n\n    Pool_Timing(NULL);\n\n    POOL_LOCK(pages_lock);\n\n    page = (PAGE*)List_Head(&pool->pages);\n    while (page) {\n        next_page = (PAGE*)List_Next(page);\n\n        if (page->eyecatcher != pool->eyecatcher)\n            ABEND(POOL_GET_CELLS_EYECATCHER_MISMATCH);\n\n        if (page->num_free >= size) {\n\n            // the page says it has at least the number of cells we need.\n            // if we find a block of enough free cells, break here\n\n            index = Pool_Find_Cells(page, size);\n            if (index != -1)\n                break;\n\n            // if there were not enough free cells, then adjust the page\n            // to say it has at most one less than what we just asked for\n\n            page->num_free = (USHORT)(size - 1);\n\n            // after adjusting, if the page crosses the threshold and has\n            // too few free cells to bother with it again, we move it to\n            // the list of full pages that are not traversed\n\n            if (page->num_free < FULL_PAGE_THRESHOLD) {\n\n                List_Remove(&pool->pages, page);\n                List_Insert_Before(&pool->full_pages, NULL, page);\n            }\n        }\n\n        page = next_page;\n    }\n\n    Pool_Timing(&Pool_Get_Cells_1_Time);\n\n    // if we couldn't find a page, we have to allocate a new page.\n\n    if (! page) {\n\n        page = Pool_Alloc_Page(pool, pool->eyecatcher);\n        if (! page) {\n            POOL_UNLOCK(pages_lock);\n            return NULL;\n        }\n\n        index = 0;\n    }\n\n    // after allocation, if the page crosses the threshold and has\n    // too few free cells to bother with it again, we move it to\n    // the list of full pages that are not traversed\n\n    page->num_free = (USHORT)(page->num_free - size);\n\n    if (page->num_free < FULL_PAGE_THRESHOLD) {\n\n        List_Remove(&pool->pages, page);\n        List_Insert_Before(&pool->full_pages, NULL, page);\n    }\n\n    // we have a block of consecutive free cells of at least 'size' cells,\n    // mark it in use (or at least some of it)\n\n    Pool_Timing(NULL);\n\n    // printf(\"Satisfied request for %d cells \", size);\n\n    bitmap = (UCHAR *)page + PAGE_HEADER_SIZE + (index / 8);\n    mask = 1 << (index & 7);\n    while (size) {\n        if (mask == 1 && size > 8) {\n            *bitmap = 0xFF;\n            ++bitmap;\n            size -= 8;\n        } else {\n            *bitmap |= mask;\n            mask <<= 1;\n            mask = (mask & 0xFF) | (mask >> 8);\n            bitmap += mask & 1;\n            --size;\n        }\n    }\n\n    Pool_Timing(&Pool_Get_Cells_2_Time);\n\n    ptr = (UCHAR *)page + PAGE_HEADER_SIZE + PAGE_BITMAP_SIZE\n                        + index * POOL_CELL_SIZE;\n\n    // printf(\" at index %d address %08X (pool = %08X)\\n\", index, ptr, pool);\n    // Pool_Print_Page(page);\n\n    Pool_Timing(&Pool_Get_Cells_Time);\n\n    // unlock and return\n\n    POOL_UNLOCK(pages_lock);\n\n    return ptr;\n}", "path": "Sandboxie/Sandboxie/common/pool.c", "commit_date": "2020-04-09 00:00:00", "repo_name": "sandboxie-plus/Sandboxie", "stars": 11788, "license": "gpl-3.0", "language": "c", "size": 86045}
{"docstring": "//---------------------------------------------------------------------------\n// BigNum_ShiftRight\n//---------------------------------------------------------------------------\n", "func_signal": "_FX BIGNUM BigNum_ShiftRight(POOL *pool, BIGNUM BigNumA, ULONG Bits)", "code": "{\n    //\n    // shift an input bignum by the specified number of bits.  calculate\n    // the number of words in the result as the number of signficant words\n    // in the input, minus the number of shift bits divided by the size of\n    // a bignum word.  if the new length is zero or one words, then use a\n    // zero value or the value of the highest word, respectively, to create\n    // a single word bignum.  otherwise right-shift each two consecutive\n    // words from the input bignum into a single word in the result bignum.\n    //\n\n    BIGNUM BigNumB, BigNumC;\n    ULONG ShiftBits, WordsToSkip;\n    ULONG Words, WordIndex;\n    ULONG64 TwoWords;\n\n    Words = *BigNumA;\n    while (Words >= 1 && BigNumA[Words] == 0)\n        --Words;\n\n    ShiftBits = Bits % 32;\n    WordsToSkip = Bits / 32;\n\n    if (Words > WordsToSkip)\n        Words -= WordsToSkip;\n    else\n        Words = 0;\n\n    if (Words <= 1) {\n\n        if (Words == 0 || WordsToSkip >= *BigNumA)\n            WordIndex = 0;\n        else\n            WordIndex = BigNumA[WordsToSkip + 1];\n        WordIndex >>= ShiftBits;\n        BigNumB = BigNum_CreateFromInteger(pool, WordIndex);\n\n    } else {\n\n        BigNumB = Pool_Alloc(pool, sizeof(ULONG) * (Words + 1));\n        if (BigNumB) {\n\n            *BigNumB = Words;\n\n            for (WordIndex = 1; WordIndex <= Words; ++WordIndex) {\n                if (WordIndex < Words) {\n                    TwoWords = BigNumA[WordIndex + WordsToSkip + 1];\n                    TwoWords <<= 32;\n                } else\n                    TwoWords = 0;\n                TwoWords |= BigNumA[WordIndex + WordsToSkip];\n                BigNumB[WordIndex] = (ULONG)(TwoWords >> ShiftBits);\n            }\n\n            if (BigNumB[Words] == 0) {\n                BigNumC = BigNum_CreateFromBigNum(pool, BigNumB);\n                BigNum_Free(BigNumB);\n                BigNumB = BigNumC;\n            }\n        }\n    }\n\n    return BigNumB;\n}", "path": "Sandboxie/Sandboxie/common/bignum.c", "commit_date": "2020-04-09 00:00:00", "repo_name": "sandboxie-plus/Sandboxie", "stars": 11788, "license": "gpl-3.0", "language": "c", "size": 86045}
{"docstring": "//---------------------------------------------------------------------------\n// Pool_Find_Cells\n//---------------------------------------------------------------------------\n", "func_signal": "ALIGNED ULONG Pool_Find_Cells(PAGE *page, ULONG size)", "code": "{\n    UCHAR *bitmap = (UCHAR *)page + PAGE_HEADER_SIZE;\n    ULONG mask = 1;\n    ULONG i = 0;\n\n    Pool_Timing(NULL);\n\n    // find the\n\n    while (i < NUM_PAGE_CELLS) {\n        ULONG bit = *bitmap & mask;\n        ULONG j = i + 1;\n        mask <<= 1;\n        mask = (mask & 0xFF) | (mask >> 8);\n        bitmap += mask & 1;\n        if (bit) {\n            while (j < NUM_PAGE_CELLS) {\n                if (mask == 1 && *bitmap == 0xFF) {\n                    j += 8;\n                    ++bitmap;\n                } else {\n                    if ((*bitmap & mask) == 0)\n                        break;\n                    ++j;\n                    mask <<= 1;\n                    mask = (mask & 0xFF) | (mask >> 8);\n                    bitmap += mask & 1;\n                }\n            }\n        } else {\n            while (j < NUM_PAGE_CELLS && j - i < size) {\n                if (mask == 1 && *bitmap == 0) {\n                    j += 8;\n                    ++bitmap;\n                } else {\n                    if ((*bitmap & mask) != 0)\n                        break;\n                    ++j;\n                    mask <<= 1;\n                    mask = (mask & 0xFF) | (mask >> 8);\n                    bitmap += mask & 1;\n                }\n            }\n            if (j - i >= size) {\n                // printf(\"Page %08X has %d consecutive free cells, starting at %d:\\n\", page, size, i);\n                Pool_Print_Page(page);\n                Pool_Timing(&Pool_Find_Cells_Time);\n                return i;\n            }\n        }\n        i = j;\n    }\n\n    Pool_Timing(&Pool_Find_Cells_Time);\n\n    return -1;\n}", "path": "Sandboxie/Sandboxie/common/pool.c", "commit_date": "2020-04-09 00:00:00", "repo_name": "sandboxie-plus/Sandboxie", "stars": 11788, "license": "gpl-3.0", "language": "c", "size": 86045}
{"docstring": "//---------------------------------------------------------------------------\n// BigNum_Divide\n//---------------------------------------------------------------------------\n", "func_signal": "_FX BIGNUM BigNum_Divide(\n            POOL *pool, BIGNUM Dividend, BIGNUM Divisor, BIGNUM *pReminder)", "code": "{\n    //\n    // long division of bignum by bignum.  if the divisor is one word\n    // long, calls division by integer.  if the divisor is equal to or\n    // larger than the dividend, returns early.  otherwise this function\n    // sets up the data as requird by the Knuth long division algorithm,\n    // implemented by the divide helper function.  the requirements are:\n    //\n    // - divisor must be left-shifted such that its highest bit is on\n    // - dividend must be left-shifted by the same amount, to ensure the\n    // final quotient is correct\n    // - the adjusted dividend must have one more high order word than\n    // the original dividend.  if the shift operation did not satisfy\n    // this requirement (i.e. shift was too small), then do it explicitly\n    // - allocate space for quotient, number of words is the difference\n    // between words in the dividend and words in the divisor, plus 1.\n    //\n    // this function then calls the divide helper function.  on return,\n    // it is only necessary to right-shift the remainder.\n    //\n\n    ULONG Index, x, DivisorShift, Words;\n    BIGNUM Divisor2, Dividend2, Quotient, Temp;\n\n    //\n\n    if (pReminder)\n        *pReminder = NULL;\n\n    x = BigNum_Compare(Divisor, Dividend);\n\n    if (x == 1) {\n\n        Quotient = BigNum_CreateFromInteger(pool, 0);\n        if (Quotient && pReminder) {\n            Temp = BigNum_CreateFromBigNum(pool, Dividend);\n            if (Temp)\n                *pReminder = Temp;\n            else\n                { BigNum_FreeAndSetNull(Quotient); }\n        }\n        return Quotient;\n\n    } else if (x == 0) {\n\n        Quotient = BigNum_CreateFromInteger(pool, 1);\n        if (Quotient && pReminder) {\n            Temp = BigNum_CreateFromInteger(pool, 0);\n            if (Temp)\n                *pReminder = Temp;\n            else\n                { BigNum_FreeAndSetNull(Quotient); }\n        }\n        return Quotient;\n    }\n\n    //\n\n    Index = *Divisor;\n    while (Index > 1 && Divisor[Index] == 0)\n        --Index;\n\n    if (Index == 1) {\n\n        Quotient = BigNum_DivideByInteger(pool, Dividend, Divisor[1], &x);\n        if (Quotient && pReminder) {\n            Temp = BigNum_CreateFromInteger(pool, x);\n            if (Temp)\n                *pReminder = Temp;\n            else\n                { BigNum_FreeAndSetNull(Quotient); }\n        }\n        return Quotient;\n    }\n\n    //\n\n    Temp = NULL;\n\n    Dividend2 = NULL;\n\n    Quotient = NULL;\n\n    //\n\n    x = ((ULONG)-1 >> 31) << 31;\n    for (DivisorShift = 0; (Divisor[Index] & x) == 0; ++DivisorShift)\n        x >>= 1;\n\n    Divisor2 = BigNum_ShiftLeft(pool, Divisor, DivisorShift, 0);\n    BigNum_Assert(Divisor2);\n\n    //\n\n    Temp = BigNum_ShiftLeft(pool, Dividend, DivisorShift, 0);\n    BigNum_Assert(Temp);\n\n    if (*Temp != *Dividend) {\n\n        Dividend2 = Temp;\n\n    } else {\n\n        Words = *Temp + 1;\n        Dividend2 = Pool_Alloc(pool, sizeof(ULONG) * (Words + 1));\n        BigNum_Assert(Dividend2);\n        *Dividend2 = Words;\n        for (Index = 1; Index < Words; ++Index)\n            Dividend2[Index] = Temp[Index];\n        Dividend2[Index] = 0;\n        BigNum_Free(Temp);\n    }\n\n    Temp = NULL;\n\n    //\n\n    Words = *Dividend - *Divisor2 + 1;\n    Quotient = Pool_Alloc(pool, sizeof(ULONG) * (Words + 1));\n    BigNum_Assert(Quotient);\n    *Quotient = Words;\n\n    //\n\n    BigNum_DivideHelper(Dividend2, Divisor2, Quotient);\n\n    Temp = BigNum_CreateFromBigNum(pool, Quotient);\n    BigNum_FreeAndSetTo(Quotient, Temp);\n\n    if (Quotient && pReminder) {\n        Temp = BigNum_ShiftRight(pool, Dividend2, DivisorShift);\n        if (Temp)\n            *pReminder = Temp;\n        else\n            { BigNum_FreeAndSetNull(Quotient); }\n    }\n\n    Temp = NULL;\n\n    //\n\nfinish:\n\n    if (Temp)\n        BigNum_Free(Temp);\n\n    if (Dividend2)\n        BigNum_Free(Dividend2);\n\n    if (Divisor2)\n        BigNum_Free(Divisor2);\n\n    return Quotient;\n}", "path": "Sandboxie/Sandboxie/common/bignum.c", "commit_date": "2020-04-09 00:00:00", "repo_name": "sandboxie-plus/Sandboxie", "stars": 11788, "license": "gpl-3.0", "language": "c", "size": 86045}
{"docstring": "//---------------------------------------------------------------------------\n// Dll_JumpStub\n//---------------------------------------------------------------------------\n", "func_signal": "_FX void *Dll_JumpStub(void *OldCode, void *NewCode, ULONG_PTR Arg)", "code": "{\n    UCHAR *code, *ptr;\n\n    code = Dll_AllocCode128();\n    ptr = code;\n\n    //\n    // build stub which loads eax with (code + 32) then jumps to NewCode\n    //\n\n#ifdef _WIN64\n    *(USHORT *)ptr = 0xB848;    // mov rax\n    ptr += sizeof(USHORT);\n#else ! _WIN64\n    *ptr = 0xB8;                // mov eax\n    ++ptr;\n#endif _WIN64\n    *(ULONG_PTR *)ptr = (ULONG_PTR)(code + 32);\n    ptr += sizeof(ULONG_PTR);\n\n    *(USHORT *)ptr = 0x25FF;    // jmp dword/qword ptr [rip+6]\n    ptr += 2;\n#ifdef _WIN64\n    *(ULONG *)ptr = 0;\n#else ! _WIN64\n    *(ULONG *)ptr = (ULONG)(ptr + 4);\n#endif _WIN64\n    ptr += sizeof(ULONG);\n    *(ULONG_PTR *)ptr = (ULONG_PTR)NewCode;\n\n    //\n    // write data at (code + 32)\n    //\n\n    ptr = code + 32;\n    *(ULONG_PTR *)ptr = (ULONG_PTR)code;\n    ptr += sizeof(ULONG_PTR);\n    *(ULONG_PTR *)ptr = (ULONG_PTR)OldCode;\n    ptr += sizeof(ULONG_PTR);\n    *(ULONG_PTR *)ptr = (ULONG_PTR)Arg;\n\n    //\n    // write eyecatcher at (code + 64)\n    //\n\n    *(ULONG *)(code + 64) = tzuk;\n\n    return code;\n}", "path": "Sandboxie/Sandboxie/core/dll/dllhook.c", "commit_date": "2020-11-28 00:00:00", "repo_name": "sandboxie-plus/Sandboxie", "stars": 11788, "license": "gpl-3.0", "language": "c", "size": 86045}
{"docstring": "//---------------------------------------------------------------------------\n// Dll_SkipHook\n//---------------------------------------------------------------------------\n", "func_signal": "_FX BOOLEAN Dll_SkipHook(const WCHAR *HookName)", "code": "{\n    static WCHAR *HookText = NULL;\n    BOOLEAN found = FALSE;\n\n    //\n    // initialize hook text based on image name\n    //\n\n    if (! HookName) {\n\n        const WCHAR *deftext = NULL;\n\n        if (_wcsicmp(Dll_ImageName, L\"DragonSaga.exe\") == 0)\n            deftext = L\"ntqsi,enumwin,findwin\";\n\n        if (_wcsicmp(Dll_ImageName, L\"BatmanAC.exe\") == 0)\n            deftext = L\"enumwin,findwin\";\n\n        if (_wcsicmp(Dll_ImageName, L\"PotPlayer64.exe\") == 0 ||\n            _wcsicmp(Dll_ImageName, L\"PotPlayerMini64.exe\") == 0 ||\n            _wcsicmp(Dll_ImageName, L\"mpc-hc64.exe\") == 0) {\n\n            deftext = L\"cocreate\";\n        }\n\n        HookText = Dll_GetSettingsForImageName(L\"SkipHook\", deftext);\n\n    //\n    // query for a specific hook\n    //\n\n    } else if (HookText) {\n\n        ULONG len = wcslen(HookName);\n        WCHAR *ptr = HookText;\n        while (ptr) {\n            while (*ptr == L',')\n                ++ptr;\n            if (_wcsnicmp(ptr, HookName, len) == 0) {\n                found = TRUE;\n                break;\n            }\n            ptr = wcschr(ptr, L',');\n        }\n    }\n\n    return found;\n}", "path": "Sandboxie/Sandboxie/core/dll/dllhook.c", "commit_date": "2020-11-28 00:00:00", "repo_name": "sandboxie-plus/Sandboxie", "stars": 11788, "license": "gpl-3.0", "language": "c", "size": 86045}
{"docstring": "//---------------------------------------------------------------------------\n// Pool_Alloc_Page\n//---------------------------------------------------------------------------\n", "func_signal": "ALIGNED PAGE *Pool_Alloc_Page(POOL *pool, ULONG tag)", "code": "{\n    PAGE *page;\n\n    Pool_Timing(NULL);\n\n    page = (PAGE*)Pool_Alloc_Mem(POOL_PAGE_SIZE, tag);\n    if (page) {\n\n        page->eyecatcher = tag;\n        page->next = NULL;\n        page->num_free = NUM_PAGE_CELLS;\n\n        if (pool) {\n            UCHAR *bitmap = (UCHAR *)page + PAGE_HEADER_SIZE;\n            memcpy(bitmap, pool->initial_bitmap, PAGE_BITMAP_SIZE);\n            page->pool = pool;\n            List_Insert_Before(&pool->pages, NULL, page);\n        }\n    }\n\n    Pool_Timing(&Pool_Alloc_Page_Time);\n\n    return page;\n}", "path": "Sandboxie/Sandboxie/common/pool.c", "commit_date": "2020-04-09 00:00:00", "repo_name": "sandboxie-plus/Sandboxie", "stars": 11788, "license": "gpl-3.0", "language": "c", "size": 86045}
{"docstring": "//---------------------------------------------------------------------------\n// Pool_CreateTagged\n//---------------------------------------------------------------------------\n", "func_signal": "ALIGNED POOL *Pool_CreateTagged(ULONG tag)", "code": "{\n    PAGE *page;\n    UCHAR *bitmap;\n    ULONG i, ofs, bit;\n    POOL *pool;\n\n    // allocate the first pool page\n\n    page = Pool_Alloc_Page(NULL, tag);\n    if (! page)\n        return NULL;\n\n    // prepare the initial bitmap for the page.  first reset the entire\n    // cell-size-padded cell bitmap to zeroes.  then set to one just\n    // those bits that are used for padding and don't represent real cells\n\n    bitmap = (UCHAR *)page + PAGE_HEADER_SIZE;\n    memzero(bitmap, PAGE_BITMAP_SIZE);\n    i = NUM_PAGE_CELLS;\n    while (1) {\n        ofs = i / 8;\n        bit = 1 << (i & 7);\n        if (ofs >= PAGE_BITMAP_SIZE)\n            break;\n        if (bit == 1) {\n            bitmap[ofs] = 0xFF;\n            i += 8;\n        } else {\n            bitmap[ofs] |= bit;\n            ++i;\n        }\n    }\n\n    // allocate the pool structure just past the page bitmap,\n    // then initialize it\n\n    pool = (POOL *)((UCHAR *)page + PAGE_HEADER_SIZE + PAGE_BITMAP_SIZE);\n\n    page->pool = pool;\n\n    pool->eyecatcher = tag;\n\n#ifdef POOL_USE_CUSTOM_LOCK\n\n    pool->pages_lock        = LOCK_FREE;\n    pool->large_chunks_lock = LOCK_FREE;\n\n#elif defined(KERNEL_MODE)\n\n    pool->lock = ExAllocatePoolWithTag(\n                                NonPagedPool, sizeof(ERESOURCE), tag);\n    if (! pool->lock) {\n        Pool_Free_Mem(page, tag);\n        return NULL;\n    }\n    ExInitializeResourceLite(pool->lock);\n\n#else /* ! KERNEL_MODE */\n\n    InterlockedExchange(&pool->thread, 0);\n    InitializeCriticalSectionAndSpinCount(&pool->lock, 1000);\n\n#endif\n\n    memcpy(pool->initial_bitmap, bitmap, PAGE_BITMAP_SIZE);\n\n    List_Init(&pool->pages);\n    List_Insert_Before(&pool->pages, NULL, page);\n\n    List_Init(&pool->full_pages);\n    List_Init(&pool->large_chunks);\n\n    // mark in the bitmap, the cells allocated to the pool structure\n\n    i = 0;\n    while (i < NUM_CELLS(sizeof(POOL))) {\n        ofs = i / 8;\n        bit = 1 << (i & 7);\n        bitmap[ofs] |= bit;\n        ++i;\n    }\n\n    return pool;\n}", "path": "Sandboxie/Sandboxie/common/pool.c", "commit_date": "2020-04-09 00:00:00", "repo_name": "sandboxie-plus/Sandboxie", "stars": 11788, "license": "gpl-3.0", "language": "c", "size": 86045}
{"docstring": "//---------------------------------------------------------------------------\n// BigNum_CreateFromInteger\n//---------------------------------------------------------------------------\n", "func_signal": "_FX BIGNUM BigNum_CreateFromInteger(POOL *pool, ULONG Value)", "code": "{\n    //\n    // create a simple bignum with just one word, set to the input value\n    //\n\n    BIGNUM BigNum;\n\n    BigNum = Pool_Alloc(pool, sizeof(ULONG) * 2);\n    if (BigNum) {\n\n        *BigNum = 1;\n        BigNum[1] = Value;\n    }\n\n    return BigNum;\n}", "path": "Sandboxie/Sandboxie/common/bignum.c", "commit_date": "2020-04-09 00:00:00", "repo_name": "sandboxie-plus/Sandboxie", "stars": 11788, "license": "gpl-3.0", "language": "c", "size": 86045}
{"docstring": "//---------------------------------------------------------------------------\n// SbieDll_Hook\n//---------------------------------------------------------------------------\n", "func_signal": "_FX void *SbieDll_Hook(\n    const char *SourceFuncName, void *SourceFunc, void *DetourFunc)", "code": "{\n    static const WCHAR *_fmt1 = L\"%s (%d)\";\n    static const WCHAR *_fmt2 = L\"%s (%d, %d)\";\n    UCHAR *tramp, *func;\n    ULONG prot, dummy_prot;\n    ULONG_PTR diff;\n    ULONG_PTR target;\n#ifdef _WIN64\n    long long delta;\n    BOOLEAN CallInstruction64 = FALSE;\n#endif _WIN64\n\n    //\n    // validate parameters\n    //\n\n    if (! SourceFunc) {\n        SbieApi_Log(2303, _fmt1, SourceFuncName, 1);\n        return NULL;\n    }\n\n    //\n    // Chrome sandbox support\n    //\n\n    SourceFunc = SbieDll_Hook_CheckChromeHook(SourceFunc);\n\n    //\n    // if the source function begins with relative jump EB xx, it means\n    // someone else has already hooked it, so we try to hook the hook\n    // (this helps to co-exist with Cisco Security Agent)\n    //\n\n    if (*(UCHAR *)SourceFunc == 0xEB) {\n        signed char offset = *((signed char *)SourceFunc + 1);\n        SourceFunc = (UCHAR *)SourceFunc + offset + 2;\n    }\n\n    //\n    // if the source function begins with a near jump E9 xx xx xx xx\n    // then follow the jump to its destination.  if the destination\n    // turns out to be the same as DetourFunc, then abort,\n    // otherwise (for 32-bit code) just replace the jump target\n    //\n\n    while (*(UCHAR *)SourceFunc == 0xE9) {\n\n        diff = *(LONG *)((ULONG_PTR)SourceFunc + 1);\n        target = (ULONG_PTR)SourceFunc + diff + 5;\n        if (target == (ULONG_PTR)DetourFunc) {\n            SbieApi_Log(2303, _fmt1, SourceFuncName, 4);\n            return NULL;\n        }\n\n#ifdef _WIN64\n\n        SourceFunc = (void *)target;\n\n#else ! WIN_64\n\n        func = SbieDll_Hook_CheckChromeHook((void *)target);\n        if (func != (void *)target) {\n            SourceFunc = func;\n            goto skip_e9_rewrite;\n        }\n\n        func = (UCHAR *)SourceFunc;\n        diff = (UCHAR *)DetourFunc - (func + 5);\n        ++func;\n        if (! VirtualProtect(func, 4, PAGE_EXECUTE_READWRITE, &prot)) {\n            ULONG err = GetLastError();\n            SbieApi_Log(2303, _fmt2, SourceFuncName, 31, err);\n            return NULL;\n        }\n        *(ULONG *)func = (ULONG)diff;\n        VirtualProtect(func, 4, prot, &dummy_prot);\n\n        return (void *)target;\n\nskip_e9_rewrite: ;\n\n#endif _WIN64\n\n    }\n\n#ifdef _WIN64\n\n    //\n    // 64-bit only:  avast snxhk64.dll compatibility:  the function\n    // begins with nop+jmp (90,E9), and the jump target is a second\n    // jump instruction 'jmp qword ptr [x]', then advance the pointer\n    // to the second jump instruction so the next block of code\n    // can process it\n    //\n\n    if (*(USHORT *)SourceFunc == 0xE990) {\n        diff = *(LONG *)((ULONG_PTR)SourceFunc + 2);\n        target = (ULONG_PTR)SourceFunc + diff + 6;\n        if (*(USHORT *)target == 0x25FF)\n            SourceFunc = (void *)target;\n    }\n\n\t//\n\t// this simplification fails for delay loaded libraries, see coments about SetSecurityInfo,\n\t// resulting in an endless loop, so just dont do that \n\t//\n\n#if 0\n    //\n    // 64-bit only:  if the function begins with 'jmp qword ptr [x]'\n    // (6 bytes) then replace the value at x, rather than overwrite\n    // 12 bytes.\n    //\n\n    if (*(UCHAR *)SourceFunc == 0x48 &&\n            *(USHORT *)((UCHAR *)SourceFunc + 1) == 0x25FF) {\n        // 4825FF is same as 25FF\n        SourceFunc = (UCHAR *)SourceFunc + 1;\n    }\n\n    if (*(USHORT *)SourceFunc == 0x25FF) {\n\n        void *orig_addr;\n        /*\n        sprintf(buffer,\"0x25FF Hook: %s\\n\",SourceFuncName);\n        OutputDebugStringA(buffer);\n        */\n        diff = *(LONG *)((ULONG_PTR)SourceFunc + 2);\n        target = (ULONG_PTR)SourceFunc + 6 + diff;\n        orig_addr = (void *)*(ULONG_PTR *)target;\n        if (orig_addr == DetourFunc) {\n            SbieApi_Log(2303, _fmt1, SourceFuncName, 4);\n            return NULL;\n        }\n\n        func = (UCHAR *)target;\n        if (! VirtualProtect(func, 8, PAGE_EXECUTE_READWRITE, &prot)) {\n            ULONG err = GetLastError();\n            SbieApi_Log(2303, _fmt2, SourceFuncName, 32, err);\n            return NULL;\n        }\n        *(ULONG_PTR *)target = (ULONG_PTR)DetourFunc;\n        VirtualProtect(func, 8, prot, &dummy_prot);\n\n        return orig_addr;\n    }\n#endif\n\n#endif _WIN64\n\n    //\n    // 64-bit only:  if the function begins with 'call qword ptr [x]'\n    // (6 bytes) then overwrite at the call target address.\n    //\n\n#ifdef _WIN64\n\n    if (*(USHORT *)SourceFunc == 0x15FF) {\n\n        //\n        // the call instruction pushes a qword into the stack, we need\n        // to remove this qword before calling our detour function\n        //\n\n        UCHAR *NewDetour = Dll_AllocCode128();\n\n        NewDetour[0] = 0x58;        // pop rax\n        NewDetour[1] = 0x48;        // mov rax, DetourFunc\n        NewDetour[2] = 0xB8;\n        *(ULONG_PTR *)(&NewDetour[3]) = (ULONG_PTR)DetourFunc;\n        NewDetour[11] = 0xFF;       // jmp rax\n        NewDetour[12] = 0xE0;\n\n        DetourFunc = NewDetour;\n\n        //\n        // when our detour function calls the trampoline to invoke the\n        // original code, we have to push the qword back into the stack,\n        // because this is what the original code expects\n        //\n\n        NewDetour[16] = 0x48;       // mov rax, SourceFunc+6\n        NewDetour[17] = 0xB8;\n        *(ULONG_PTR *)(&NewDetour[18]) = (ULONG_PTR)SourceFunc + 6;\n        NewDetour[26] = 0x50;       // push rax\n        NewDetour[27] = 0x48;       // mov rax, trampoline code\n        NewDetour[28] = 0xB8;\n        *(ULONG_PTR *)(&NewDetour[29]) = 0;\n        NewDetour[37] = 0xFF;       // jmp rax\n        NewDetour[38] = 0xE0;\n\n        CallInstruction64 = TRUE;\n\n        //\n        // overwrite the code at the target of the call instruction\n        //\n\n        diff = *(LONG *)((ULONG_PTR)SourceFunc + 2);\n        target = (ULONG_PTR)SourceFunc + 6 + diff;\n        SourceFunc = (void *)*(ULONG_PTR *)target;\n    }\n\n#endif _WIN64\n\n    //\n    // invoke the driver to create a trampoline\n    //\n\n    tramp = Dll_AllocCode128();\n\n    if (SbieApi_HookTramp(SourceFunc, tramp) != 0) {\n        SbieApi_Log(2303, _fmt1, SourceFuncName, 2);\n        return NULL;\n    }\n\n\tULONG ByteCount = *(ULONG*)(tramp + 80);\n\tULONG UsedCount = 0;\n\t\n    //\n    // create the detour\n    //\n\n    func = (UCHAR *)SourceFunc;\n\n    if (!VirtualProtect(&func[-8], 20, PAGE_EXECUTE_READWRITE, &prot)) {\n\n        ULONG err = GetLastError();\n        SbieApi_Log(2303, _fmt2, SourceFuncName, 33, err);\n        return NULL;\n    }\n\n    //\n    // hook the source function\n    //\n\n#ifdef _WIN64\n    if (Dll_Windows >= 10) {\n        target = (ULONG_PTR)&func[6];\n    }\n    else {\n        target = (ULONG_PTR)&func[5];\n    }\n\n    diff = (ULONG_PTR)((ULONG_PTR)DetourFunc - target);\n    delta = diff;\n    delta < 0 ? delta *= -1 : delta;\n\n    //is DetourFunc in 32bit jump range\n    if (delta < 0x80000000) {\n        /*\n        sprintf(buffer,\"32 bit Hook: %s\\n\",SourceFuncName);\n        OutputDebugStringA(buffer);\n        */\n        if (Dll_Windows >= 10) {\n            func[0] = 0x48;             // 32bit relative JMP DetourFunc\n            func[1] = 0xE9;             // 32bit relative JMP DetourFunc\n            *(ULONG *)(&func[2]) = (ULONG)diff;\n\t\t\tUsedCount = 1 + 1 + 4;\n        }\n        else {\n            func[0] = 0xE9;             // 32bit relative JMP DetourFunc\n            *(ULONG *)(&func[1]) = (ULONG)diff;\n\t\t\tUsedCount = 1 + 4;\n        }\n    }\n\n    else {\n\n\n\n        BOOLEAN hookset = FALSE;\n        BOOLEAN defaultRange = FALSE;\n        int i;\n        EnterCriticalSection(&VT_CriticalSection);\n\n        if (bVTableEable) {\n            VECTOR_TABLE *ptrVTable = SbieDllVectorTable;\n            //default step size \n\n            for (i = 0; i < NUM_VTABLES && !hookset; i++, ptrVTable++) {\n                if (!ptrVTable->offset) {\n                    ULONG_PTR tempAddr;\n                    ULONG_PTR step = 0x20000;// + VTABLE_SIZE;\n                    ULONG_PTR max_attempts = 0x4000000 / step;\n                    // optimization for windows 7 and low memory DLL's\n\n                    if ((ULONG_PTR)func < 0x80000000 && ((ULONG_PTR)func > 0x4000000)) {\n                        step = 0x200000;\n                    }\n                    // optimization for windows 8.1\n                    else if ((ULONG_PTR)func < 0x4000000) {\n                        step *= -1;\n                    }\n                    else if ((ULONG_PTR)func < 0x10000000000) {\n                        step *= -1;\n                    }\n                    else {\n                        defaultRange = TRUE;\n                    }\n\n                    // sprintf(buffer,\"VTable Alloc: func = %p, step = %p, default = %d\\n\",func,step,defaultRange);\n                    // OutputDebugStringA(buffer);\n                    tempAddr = ((ULONG_PTR)func & 0xfffffffffffe0000) - (step << 2);\n\n                    if (defaultRange) {\n                        tempAddr -= 0x20000000;\n                    }\n\n                    for (; !ptrVTable->offset && max_attempts; tempAddr -= step, max_attempts--) {\n                        ptrVTable->offset = VirtualAlloc((void *)tempAddr, VTABLE_SIZE, MEM_COMMIT | MEM_RESERVE | MEM_TOP_DOWN, PAGE_READWRITE);\n                        //  sprintf(buffer,\"VTable Offset: func = %p, offset = %p, tryAddress = %p, attempt = 0x%x\\n\",func,ptrVTable->offset,tempAddr,max_attempts);\n                        //  OutputDebugStringA(buffer);\n                    }\n\n                    ptrVTable->index = 0;\n                    ptrVTable->maxEntries = VTABLE_SIZE / sizeof(void *);\n                }\n                if (ptrVTable->offset) {\n                    target = (ULONG_PTR)&func[6];\n                    diff = (ULONG_PTR) &((ULONG_PTR *)ptrVTable->offset)[ptrVTable->index];\n                    diff = diff - target;\n                    delta = diff;\n                    delta < 0 ? delta *= -1 : delta;\n\n                    // is DetourFunc in 32bit jump range\n                    if (delta < 0x80000000 && ptrVTable->index <= ptrVTable->maxEntries) {\n                        ((ULONG_PTR *)ptrVTable->offset)[ptrVTable->index] = (ULONG_PTR)DetourFunc;\n                        *(USHORT *)&func[0] = 0x25ff;\n                        *(ULONG *)&func[2] = (ULONG)diff;\n\t\t\t\t\t\tUsedCount = 2 + 4;\n                        ptrVTable->index++;\n                        hookset = TRUE;\n                    }\n                }\n                else {\n                    bVTableEable = FALSE;\n                    SbieApi_Log(2303, _fmt1, SourceFuncName, 888);\n                    LeaveCriticalSection(&VT_CriticalSection);\n                    return NULL;\n                }\n            }\n        }\n\n        LeaveCriticalSection(&VT_CriticalSection);\n        if (!hookset) {\n            // OutputDebugStringA(\"Memory alloc failed: 12 Byte Patch Disabled\\n\");\n            SbieApi_Log(2303, _fmt1, SourceFuncName, 999);\n            return NULL;\n        }\n    }\n\n#else\n    diff = (UCHAR *)DetourFunc - (func + 5);\n    func[0] = 0xE9;             // JMP DetourFunc\n    *(ULONG *)(&func[1]) = (ULONG)diff;\n\tUsedCount = 1 + 4;\n#endif\n\n\t// just in case nop out the rest of the code we moved to the trampoline\n\t// ToDo: why does this break unity games\n\t//for(; UsedCount < ByteCount; UsedCount++)\n\t//\tfunc[UsedCount] = 0x90; // nop\n\n\tVirtualProtect(&func[-8], 20, prot, &dummy_prot);\n\n    // the trampoline code begins at trampoline + 16 bytes\n    func = (UCHAR *)(ULONG_PTR)(tramp + 16);\n\n    //\n    // 64-bit only:  if we are hooking a function that started with a\n    // call instruction, then we have to return a secondary trampoline\n    //\n\n#ifdef _WIN64\n\n    if (CallInstruction64) {\n\n        UCHAR *NewDetour = (UCHAR *)DetourFunc;\n        *(ULONG_PTR *)(&NewDetour[29]) = (ULONG_PTR)func;\n        func = NewDetour + 16;\n    }\n\n#endif _WIN64\n\n    return func;\n}", "path": "Sandboxie/Sandboxie/core/dll/dllhook.c", "commit_date": "2020-11-28 00:00:00", "repo_name": "sandboxie-plus/Sandboxie", "stars": 11788, "license": "gpl-3.0", "language": "c", "size": 86045}
{"docstring": "//---------------------------------------------------------------------------\n// Pool_Free\n//---------------------------------------------------------------------------\n", "func_signal": "ALIGNED void Pool_Free(void *ptr, ULONG size)", "code": "{\n    if (ptr && size) {\n\n#if POOL_DEBUG\n        ULONG caller_size = size;\n        size += sizeof(ULONG);\n        if (*(ULONG *)((UCHAR *)ptr + caller_size) != size) {\n            // printf(\"got %d (at %08X), expected %d for %08X\\n\", *(ULONG *)((UCHAR *)ptr + caller_size), (ULONG *)((UCHAR *)ptr + caller_size), size, ptr);\n            ABEND(POOL_FREE_SIZE_MISMATCH);\n        }\n#endif\n\n        // if the pointer is page-aligned, this must be a LARGE_CHUNK\n        if (((ULONG_PTR)ptr & (POOL_PAGE_SIZE - 1)) == 0)\n            Pool_Free_Large_Chunk(ptr, size);\n        else\n            Pool_Free_Cells(ptr, NUM_CELLS(size));\n\n#if 0\n#if defined(KERNEL_MODE)\n    DbgPrint(\"Pool_Free                 %08X (%d)\\n\", ptr, size);\n#endif\n#endif\n\n    } else\n        ABEND(POOL_FREE_NULL_PTR_OR_ZERO_SIZE);\n}", "path": "Sandboxie/Sandboxie/common/pool.c", "commit_date": "2020-04-09 00:00:00", "repo_name": "sandboxie-plus/Sandboxie", "stars": 11788, "license": "gpl-3.0", "language": "c", "size": 86045}
{"docstring": "//---------------------------------------------------------------------------\n// Dll_GetSettingsForImageName\n//---------------------------------------------------------------------------\n", "func_signal": "_FX WCHAR *Dll_GetSettingsForImageName(\n    const WCHAR *setting, const WCHAR *deftext)", "code": "{\n    POOL *pool;\n    WCHAR *text, *image_lwr, *buf;\n    ULONG text_len, image_len;\n    ULONG index;\n\n    //\n    //\n    //\n\n    pool = Pool_Create();\n    if (! pool)\n        goto outofmem;\n\n    //\n    //\n    //\n\n    if (deftext)\n        text_len = wcslen(deftext);\n    else\n        text_len = 0;\n    text = Pool_Alloc(pool, (text_len + 1) * sizeof(WCHAR));\n    if (! text)\n        goto outofmem;\n    wmemcpy(text, deftext, text_len);\n    text[text_len] = L'\\0';\n\n    //\n    //\n    //\n\n    image_len = (wcslen(Dll_ImageName) + 1) * sizeof(WCHAR);\n    image_lwr = Pool_Alloc(pool, image_len);\n    if (! image_lwr)\n        goto outofmem;\n    memcpy(image_lwr, Dll_ImageName, image_len);\n    _wcslwr(image_lwr);\n    image_len = wcslen(image_lwr);\n\n    //\n    //\n    //\n\n    buf = Pool_Alloc(pool, 1024 * sizeof(WCHAR));\n    if (! buf)\n        goto outofmem;\n\n    index = 0;\n    while (1) {\n\n        WCHAR *ptr, *buf_ptr;\n        PATTERN *image_pat;\n\n        NTSTATUS status = SbieApi_QueryConfAsIs(\n                    NULL, setting, index, buf, 1020 * sizeof(WCHAR));\n        if (! NT_SUCCESS(status))\n            break;\n        ++index;\n\n        ptr = wcschr(buf, L',');\n        if (! ptr)\n            continue;\n        *ptr = L'\\0';\n\n        if (buf[0] == L'/' && buf[1] == L'/' &&\n                (Dll_ProcessFlags & SBIE_FLAG_IMAGE_FROM_SBIE_DIR)) {\n            // a // prefix in the image name (such as //start.exe) matches\n            // only if the image resides in our installation directory\n            buf_ptr = buf + 2;\n        } else\n            buf_ptr = buf;\n\n        image_pat = Pattern_Create(pool, buf_ptr, TRUE);\n        if (Pattern_Match(image_pat, image_lwr, image_len)) {\n\n            ULONG ptr_len;\n            WCHAR *new_text;\n            if (text_len)\n                *ptr = L',';    // restore comma if text is not empty\n            else\n                ++ptr;          // or skip comma if text is empty\n            ptr_len = wcslen(ptr);\n            new_text = Pool_Alloc(pool,\n                            (text_len + ptr_len + 1) * sizeof(WCHAR));\n            if (! new_text)\n                goto outofmem;\n            wmemcpy(new_text, text, text_len);\n            wmemcpy(new_text + text_len, ptr, ptr_len + 1);\n            text = new_text;\n            text_len = text_len + ptr_len;\n        }\n\n        Pattern_Free(image_pat);\n    }\n\n    //\n    // finish\n    //\n\n    buf = Dll_Alloc((text_len + 1) * sizeof(WCHAR));\n    wmemcpy(buf, text, text_len + 1);\n\n    Pool_Delete(pool);\n\n    return buf;\n\noutofmem:\n\n    SbieApi_Log(2305, NULL);\n    ExitProcess(-1);\n    return NULL;\n}", "path": "Sandboxie/Sandboxie/core/dll/dllhook.c", "commit_date": "2020-11-28 00:00:00", "repo_name": "sandboxie-plus/Sandboxie", "stars": 11788, "license": "gpl-3.0", "language": "c", "size": 86045}
{"docstring": "//---------------------------------------------------------------------------\n// BigNum_Multiply\n//---------------------------------------------------------------------------\n", "func_signal": "_FX BIGNUM BigNum_Multiply(POOL *pool, BIGNUM BigNumA, BIGNUM BigNumB)", "code": "{\n    //\n    // multiplication of bignum by bignum.  implemented by repeatedly\n    // multiplying each word from the first bignum by every word of\n    // the second bignum.  the product is shift according to the loop\n    // index, and placed into a result bignum, which has as many words\n    // as both input bignums.  note that the product is shifted.\n    //\n    // the result bignum will likely have zero in high order words,\n    // so we create a proper bignum and return it instead.\n    //\n    // each digit in the example below represents a single bignum word:\n    //\n    //    1234 <-- 4 bignum words\n    // *    56 <-- 2 words\n    //    ----\n    //    7404 <-- first iteration, no shift\n    // + 6170  <-- shifted by one bignum word\n    //   -----\n    //   69104 <-- result cannot be more than 4+2 = 6 words\n    //\n    //\n\n    BIGNUM BigNum, BigNumFinal;\n    ULONG Words, WordIndex1, WordIndex2, Carry;\n    ULONG64 Product;\n\n    Words = *BigNumA + *BigNumB;\n    BigNum = Pool_Alloc(pool, sizeof(ULONG) * (Words + 1));\n    if (! BigNum)\n        return NULL;\n    *BigNum = Words;\n\n    for (WordIndex1 = 1; WordIndex1 <= Words; ++WordIndex1)\n        BigNum[WordIndex1] = 0;\n\n    for (WordIndex1 = 1; WordIndex1 <= *BigNumA; ++WordIndex1) {\n        Carry = 0;\n        for (WordIndex2 = 1; WordIndex2 <= *BigNumB; ++WordIndex2) {\n            Product = (ULONG64)BigNumA[WordIndex1];\n            Product *= BigNumB[WordIndex2];\n            Product += BigNum[WordIndex1 + WordIndex2 - 1];\n            Product += Carry;\n            BigNum[WordIndex1 + WordIndex2 - 1] = (ULONG)Product;\n            Carry = (ULONG)(Product >> 32);\n        }\n        BigNum[WordIndex1 + WordIndex2 - 1] += Carry;\n    }\n\n    BigNumFinal = BigNum_CreateFromBigNum(pool, BigNum);\n    BigNum_Free(BigNum);\n    return BigNumFinal;\n}", "path": "Sandboxie/Sandboxie/common/bignum.c", "commit_date": "2020-04-09 00:00:00", "repo_name": "sandboxie-plus/Sandboxie", "stars": 11788, "license": "gpl-3.0", "language": "c", "size": 86045}
{"docstring": "//---------------------------------------------------------------------------\n// BigNum_ShiftLeft\n//---------------------------------------------------------------------------\n", "func_signal": "_FX BIGNUM BigNum_ShiftLeft(\n            POOL *pool, BIGNUM BigNumA, ULONG Bits, ULONG OrValue)", "code": "{\n    //\n    // shift an input bignum by the specified number of bits and 'or' the\n    // last parameter into the resulting low order word.  if the number of\n    // signficant words in the input is zero, the create a single word\n    // bignum using the 'or' value.  otherwise calculatevthe number of\n    // words in the result as the number of signficant words in the input,\n    // plus the number of shift bits divided by the size of a bignum word.\n    // left-shift each two consecutive words from the input bignum into a\n    // single word in the result bignum.\n    //\n\n    BIGNUM BigNumB, BigNumC;\n    ULONG ShiftBits, WordsToAdd;\n    ULONG Words, WordIndex;\n    ULONG64 TwoWords;\n\n    Words = *BigNumA;\n    while (Words >= 1 && BigNumA[Words] == 0)\n        --Words;\n\n    if (Words == 0) {\n\n        BigNumB = BigNum_CreateFromInteger(pool, OrValue);\n\n    } else {\n\n        ShiftBits = Bits % 32;\n        WordsToAdd = Bits / 32 + 1;\n\n        Words += WordsToAdd;\n        BigNumB = Pool_Alloc(pool, sizeof(ULONG) * (Words + 1));\n        if (BigNumB) {\n\n            *BigNumB = Words;\n\n            for (WordIndex = Words; WordIndex >= 1; --WordIndex) {\n                TwoWords = 0;\n                if (WordIndex >= WordsToAdd) {\n                    if (WordIndex < Words) {\n                        TwoWords = BigNumA[WordIndex - WordsToAdd + 1];\n                        TwoWords <<= 32;\n                    }\n                    if (WordIndex > WordsToAdd)\n                        TwoWords |= BigNumA[WordIndex - WordsToAdd];\n                }\n                BigNumB[WordIndex] = (ULONG)((TwoWords << ShiftBits) >> 32);\n            }\n\n            BigNumB[1] |= OrValue;\n\n            if (BigNumB[Words] == 0) {\n                BigNumC = BigNum_CreateFromBigNum(pool, BigNumB);\n                BigNum_Free(BigNumB);\n                BigNumB = BigNumC;\n            }\n        }\n    }\n\n    return BigNumB;\n}", "path": "Sandboxie/Sandboxie/common/bignum.c", "commit_date": "2020-04-09 00:00:00", "repo_name": "sandboxie-plus/Sandboxie", "stars": 11788, "license": "gpl-3.0", "language": "c", "size": 86045}
{"docstring": "//---------------------------------------------------------------------------\n// Pool_Alloc\n//---------------------------------------------------------------------------\n", "func_signal": "ALIGNED void *Pool_Alloc(POOL *pool, ULONG size)", "code": "{\n    void *ptr = NULL;\n    if (size) {\n\n#if POOL_DEBUG\n        ULONG caller_size = size;\n        size += sizeof(ULONG);\n#endif\n\n        if (size > LARGE_CHUNK_MINIMUM)\n            ptr = Pool_Get_Large_Chunk(pool, size);\n        else\n            ptr = Pool_Get_Cells(pool, NUM_CELLS(size));\n\n#if POOL_DEBUG\n        if (ptr) {\n            *(ULONG *)((UCHAR *)ptr + caller_size) = size;\n            // printf(\"put %d (at %08X) for %08X\\n\", size, (ULONG *)((UCHAR *)ptr + caller_size), ptr);\n        }\n#endif\n    }\n\n#if 0\n#if defined(KERNEL_MODE)\n    DbgPrint(\"Pool_Alloc (Pool=%08X) %08X (%d)\\n\", pool, ptr, size);\n#endif\n#endif\n\n    return ptr;\n}", "path": "Sandboxie/Sandboxie/common/pool.c", "commit_date": "2020-04-09 00:00:00", "repo_name": "sandboxie-plus/Sandboxie", "stars": 11788, "license": "gpl-3.0", "language": "c", "size": 86045}
{"docstring": "//---------------------------------------------------------------------------\n// Pool_Free_Mem\n//---------------------------------------------------------------------------\n", "func_signal": "ALIGNED void Pool_Free_Mem(void *ptr, ULONG tag)", "code": "{\n    // printf(\"Freeing at %08X\\n\", ptr);\n#ifdef KERNEL_MODE\n    ExFreePoolWithTag(ptr, tag);\n#else\n    if (! VirtualFree(ptr, 0, MEM_RELEASE)) {\n        RaiseException(\n            STATUS_ACCESS_VIOLATION,\n            EXCEPTION_NONCONTINUABLE_EXCEPTION, 0, NULL);\n        ExitProcess(-1);\n    }\n#endif\n}", "path": "Sandboxie/Sandboxie/common/pool.c", "commit_date": "2020-04-09 00:00:00", "repo_name": "sandboxie-plus/Sandboxie", "stars": 11788, "license": "gpl-3.0", "language": "c", "size": 86045}
{"docstring": "//---------------------------------------------------------------------------\n// SbieApi_HookTramp\n//---------------------------------------------------------------------------\n", "func_signal": "_FX LONG SbieApi_HookTramp(void *Source, void *Trampoline)", "code": "{\n\tNTSTATUS status;\n#ifdef _WIN64\n\tBOOLEAN is64 = TRUE;\n#else\n\tBOOLEAN is64 = FALSE;\n#endif _WIN64\n\n\tif (Hook_BuildTramp(Source, Trampoline, is64, TRUE))\n\t\tstatus = STATUS_SUCCESS;\n\telse\n\t\tstatus = STATUS_UNSUCCESSFUL;\n\n\treturn status;\n}", "path": "Sandboxie/Sandboxie/core/dll/dllhook.c", "commit_date": "2020-11-28 00:00:00", "repo_name": "sandboxie-plus/Sandboxie", "stars": 11788, "license": "gpl-3.0", "language": "c", "size": 86045}
{"docstring": "//---------------------------------------------------------------------------\n// Pool_Get_Large_Chunk\n//---------------------------------------------------------------------------\n", "func_signal": "ALIGNED void *Pool_Get_Large_Chunk(POOL *pool, ULONG size)", "code": "{\n    POOL_DECLARE_IRQL\n    ULONG large_chunk_size;\n    void *ptr;\n    LARGE_CHUNK *large_chunk;\n\n    // pad the requested size to a multiple of POOL_PAGE_SIZE, after\n    // adding the size of the (padded) LARGE_CHUNK structure\n    large_chunk_size = (size + LARGE_CHUNK_SIZE + POOL_PAGE_SIZE - 1)\n                     & ~(POOL_PAGE_SIZE - 1);\n\n    ptr = Pool_Alloc_Mem(large_chunk_size, pool->eyecatcher);\n    if (! ptr)\n        return NULL;\n\n    // position the LARGE_CHUNK structure at the end of the last page\n    large_chunk = (LARGE_CHUNK *)\n        ((UCHAR *)ptr + large_chunk_size - LARGE_CHUNK_SIZE);\n\n    large_chunk->eyecatcher = pool->eyecatcher;\n    large_chunk->pool = pool;\n    large_chunk->ptr  = ptr;\n    large_chunk->size = large_chunk_size;\n\n    // lock the pool and add the allocated large chunk\n\n    POOL_LOCK(large_chunks_lock);\n\n    List_Insert_Before(&pool->large_chunks, NULL, large_chunk);\n\n    POOL_UNLOCK(large_chunks_lock);\n\n    return ptr;\n}", "path": "Sandboxie/Sandboxie/common/pool.c", "commit_date": "2020-04-09 00:00:00", "repo_name": "sandboxie-plus/Sandboxie", "stars": 11788, "license": "gpl-3.0", "language": "c", "size": 86045}
{"docstring": "//---------------------------------------------------------------------------\n// Pool_Free_Cells\n//---------------------------------------------------------------------------\n", "func_signal": "ALIGNED void Pool_Free_Cells(void *ptr, ULONG size)", "code": "{\n    POOL_DECLARE_IRQL\n    PAGE *page = (PAGE *)((ULONG_PTR)ptr & POOL_MASK_LEFT);\n    ULONG index =\n        (((ULONG)(ULONG_PTR)ptr & POOL_MASK_RIGHT)\n            - PAGE_HEADER_SIZE - PAGE_BITMAP_SIZE)\n        / POOL_CELL_SIZE;\n    UCHAR *bitmap = (UCHAR *)page + PAGE_HEADER_SIZE + index / 8;\n    ULONG mask = 1 << (index & 7);\n    // printf(\"freeing ptr = %08X idx = %d (%d %d)\\n\", ptr, index, PAGE_HEADER_SIZE, PAGE_BITMAP_SIZE);\n\n    POOL *pool = page->pool;\n\n    //if ((page->eyecatcher != POOL_TAG) || (pool->eyecatcher != POOL_TAG))\n    if (page->eyecatcher != pool->eyecatcher)\n        ABEND(POOL_FREE_CELLS_EYECATCHER_MISMATCH);\n\n    POOL_LOCK(pages_lock);\n\n    // if after de-allocation, a full page crosses threshold in reverse,\n    // we move it to the list of usuable pages\n\n    if (page->num_free < FULL_PAGE_THRESHOLD &&\n            page->num_free + size >= FULL_PAGE_THRESHOLD) {\n\n        List_Remove(&pool->full_pages, page);\n        List_Insert_Before(&pool->pages, NULL, page);\n    }\n\n    page->num_free = (USHORT)(page->num_free + size);\n\n    // indicate the cells are now free\n\n    while (size) {\n        if (mask == 1 && size > 8) {\n            *bitmap = 0;\n            ++bitmap;\n            size -= 8;\n        } else {\n            *bitmap &= ~mask;\n            mask <<= 1;\n            mask = (mask & 0xFF) | (mask >> 8);\n            bitmap += mask & 1;\n            --size;\n        }\n    }\n\n    POOL_UNLOCK(pages_lock);\n}", "path": "Sandboxie/Sandboxie/common/pool.c", "commit_date": "2020-04-09 00:00:00", "repo_name": "sandboxie-plus/Sandboxie", "stars": 11788, "license": "gpl-3.0", "language": "c", "size": 86045}
{"docstring": "/* The maintenance thread is on a sleep/loop cycle, so it should join after a\n * short wait */\n", "func_signal": "void stop_slab_maintenance_thread(void)", "code": "{\n    mutex_lock(&slabs_rebalance_lock);\n    do_run_slab_rebalance_thread = 0;\n    pthread_cond_signal(&slab_rebalance_cond);\n    pthread_mutex_unlock(&slabs_rebalance_lock);\n\n    /* Wait for the maintenance thread to stop */\n    pthread_join(rebalance_tid, NULL);\n}", "path": "memcached/slabs.c", "commit_date": "2020-10-30 00:00:00", "repo_name": "memcached/memcached", "stars": 13055, "license": "bsd-3-clause", "language": "c", "size": 5217}
{"docstring": "/* Iterate at most once through the slab classes and pick a \"random\" source.\n * I like this better than calling rand() since rand() is slow enough that we\n * can just check all of the classes once instead.\n */\n", "func_signal": "static int slabs_reassign_pick_any(int dst)", "code": "{\n    static int cur = POWER_SMALLEST - 1;\n    int tries = power_largest - POWER_SMALLEST + 1;\n    for (; tries > 0; tries--) {\n        cur++;\n        if (cur > power_largest)\n            cur = POWER_SMALLEST;\n        if (cur == dst)\n            continue;\n        if (slabclass[cur].slabs > 1) {\n            return cur;\n        }\n    }\n    return -1;\n}", "path": "memcached/slabs.c", "commit_date": "2020-10-30 00:00:00", "repo_name": "memcached/memcached", "stars": 13055, "license": "bsd-3-clause", "language": "c", "size": 5217}
{"docstring": "// given memory base, quickly walk memory and do pointer fixup.\n// do this once on startup to avoid having to do pointer fixup on every\n// reference from hash table or LRU.\n", "func_signal": "unsigned int restart_fixup(void *orig_addr)", "code": "{\n    struct timeval tv;\n    uint64_t checked = 0;\n    const unsigned int page_size = settings.slab_page_size;\n    unsigned int page_remain = page_size;\n\n    gettimeofday(&tv, NULL);\n    if (settings.verbose > 0) {\n        fprintf(stderr, \"[restart] original memory base: [%p] new base: [%p]\\n\", orig_addr, mmap_base);\n        fprintf(stderr, \"[restart] recovery start [%d.%d]\\n\", (int)tv.tv_sec, (int)tv.tv_usec);\n    }\n\n    // since chunks don't align with pages, we have to also track page size.\n    while (checked < slabmem_limit) {\n        //fprintf(stderr, \"checked: %lu\\n\", checked);\n        item *it = (item *)((char *)mmap_base + checked);\n\n        int size = slabs_fixup((char *)mmap_base + checked,\n                checked % settings.slab_page_size);\n        //fprintf(stderr, \"id: %d, size: %d remain: %u\\n\", it->slabs_clsid, size, page_remain);\n        // slabber gobbled an entire page, skip and move on.\n        if (size == -1) {\n            assert(page_remain % page_size == 0);\n            assert(page_remain == page_size);\n            checked += page_remain;\n            page_remain = page_size;\n            continue;\n        }\n\n        if (it->it_flags & ITEM_LINKED) {\n            // fixup next/prev links while on LRU.\n            if (it->next) {\n                it->next = (item *)((mc_ptr_t)it->next - (mc_ptr_t)orig_addr);\n                it->next = (item *)((mc_ptr_t)it->next + (mc_ptr_t)mmap_base);\n            }\n            if (it->prev) {\n                it->prev = (item *)((mc_ptr_t)it->prev - (mc_ptr_t)orig_addr);\n                it->prev = (item *)((mc_ptr_t)it->prev + (mc_ptr_t)mmap_base);\n            }\n\n            //fprintf(stderr, \"item was linked\\n\");\n            do_item_link_fixup(it);\n        }\n\n        if (it->it_flags & (ITEM_CHUNKED|ITEM_CHUNK)) {\n            item_chunk *ch;\n            if (it->it_flags & ITEM_CHUNKED) {\n                ch = (item_chunk *) ITEM_schunk(it);\n                // Sigh. Chunked items are a hack; the clsid is the clsid of\n                // the full object (always the largest slab class) rather than\n                // the actual chunk.\n                // I bet this is fixable :(\n                size = slabs_size(ch->orig_clsid);\n                //fprintf(stderr, \"fixing chunked item header [%d]\\n\", size);\n            } else {\n                //fprintf(stderr, \"fixing item chunk [%d]\\n\", size);\n                ch = (item_chunk *) it;\n            }\n            if (ch->next) {\n                ch->next = (item_chunk *)((mc_ptr_t)ch->next - (mc_ptr_t)orig_addr);\n                ch->next = (item_chunk *)((mc_ptr_t)ch->next + (mc_ptr_t)mmap_base);\n            }\n            if (ch->prev) {\n                ch->prev = (item_chunk *)((mc_ptr_t)ch->prev - (mc_ptr_t)orig_addr);\n                ch->prev = (item_chunk *)((mc_ptr_t)ch->prev + (mc_ptr_t)mmap_base);\n            }\n            if (ch->head) {\n                ch->head = (item *)((mc_ptr_t)ch->head - (mc_ptr_t)orig_addr);\n                ch->head = (item *)((mc_ptr_t)ch->head + (mc_ptr_t)mmap_base);\n            }\n        }\n\n        // next chunk\n        checked += size;\n        page_remain -= size;\n        if (size > page_remain) {\n            //fprintf(stderr, \"doot %d\\n\", page_remain);\n            checked += page_remain;\n            page_remain = settings.slab_page_size;\n        }\n        //assert(checked != 3145728);\n    }\n\n    if (settings.verbose > 0) {\n        gettimeofday(&tv, NULL);\n        fprintf(stderr, \"[restart] recovery end [%d.%d]\\n\", (int)tv.tv_sec, (int)tv.tv_usec);\n    }\n\n    return 0;\n}", "path": "memcached/restart.c", "commit_date": "2020-04-12 00:00:00", "repo_name": "memcached/memcached", "stars": 13055, "license": "bsd-3-clause", "language": "c", "size": 5217}
{"docstring": "/* TODO: slabs_available_chunks should grow up to encompass this.\n * mem_flag is redundant with the other function.\n */\n", "func_signal": "unsigned int global_page_pool_size(bool *mem_flag)", "code": "{\n    unsigned int ret = 0;\n    pthread_mutex_lock(&slabs_lock);\n    if (mem_flag != NULL)\n        *mem_flag = mem_malloced >= mem_limit ? true : false;\n    ret = slabclass[SLAB_GLOBAL_PAGE_POOL].slabs;\n    pthread_mutex_unlock(&slabs_lock);\n    return ret;\n}", "path": "memcached/slabs.c", "commit_date": "2020-10-30 00:00:00", "repo_name": "memcached/memcached", "stars": 13055, "license": "bsd-3-clause", "language": "c", "size": 5217}
{"docstring": "/* Gracefully stop/close the shared memory segment */\n", "func_signal": "void restart_mmap_close(void)", "code": "{\n    msync(mmap_base, slabmem_limit, MS_SYNC);\n\n    if (restart_save(memory_file) != 0) {\n        fprintf(stderr, \"[restart] failed to save metadata\");\n    }\n\n    if (munmap(mmap_base, slabmem_limit) != 0) {\n        perror(\"[restart] failed to munmap shared memory\");\n    } else if (close(mmap_fd) != 0) {\n        perror(\"[restart] failed to close shared memory fd\");\n    }\n\n    free(memory_file);\n}", "path": "memcached/restart.c", "commit_date": "2020-04-12 00:00:00", "repo_name": "memcached/memcached", "stars": 13055, "license": "bsd-3-clause", "language": "c", "size": 5217}
{"docstring": "// TODO: could this work with the restartable memory?\n// Docs say hugepages only work with private shm allocs.\n/* Function split out for better error path handling */\n", "func_signal": "static void * alloc_large_chunk(const size_t limit)", "code": "{\n    void *ptr = NULL;\n#if defined(__linux__) && defined(MADV_HUGEPAGE)\n    size_t pagesize = 0;\n    FILE *fp;\n    int ret;\n\n    /* Get the size of huge pages */\n    fp = fopen(\"/proc/meminfo\", \"r\");\n    if (fp != NULL) {\n        char buf[64];\n\n        while ((fgets(buf, sizeof(buf), fp)))\n            if (!strncmp(buf, \"Hugepagesize:\", 13)) {\n                ret = sscanf(buf + 13, \"%zu\\n\", &pagesize);\n\n                /* meminfo huge page size is in KiBs */\n                pagesize <<= 10;\n            }\n        fclose(fp);\n    }\n\n    if (!pagesize) {\n        fprintf(stderr, \"Failed to get supported huge page size\\n\");\n        return NULL;\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \"huge page size: %zu\\n\", pagesize);\n\n    /* This works because glibc simply uses mmap when the alignment is\n     * above a certain limit. */\n    ret = posix_memalign(&ptr, pagesize, limit);\n    if (ret != 0) {\n        fprintf(stderr, \"Failed to get aligned memory chunk: %d\\n\", ret);\n        return NULL;\n    }\n\n    ret = madvise(ptr, limit, MADV_HUGEPAGE);\n    if (ret < 0) {\n        fprintf(stderr, \"Failed to set transparent hugepage hint: %d\\n\", ret);\n        free(ptr);\n        ptr = NULL;\n    }\n#elif defined(__FreeBSD__)\n    size_t align = (sizeof(size_t) * 8 - (__builtin_clzl(4095)));\n    ptr = mmap(NULL, limit, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON | MAP_ALIGNED(align) | MAP_ALIGNED_SUPER, -1, 0);\n    if (ptr == MAP_FAILED) {\n        fprintf(stderr, \"Failed to set super pages\\n\");\n        ptr = NULL;\n    }\n#else\n    ptr = malloc(limit);\n#endif\n    return ptr;\n}", "path": "memcached/slabs.c", "commit_date": "2020-10-30 00:00:00", "repo_name": "memcached/memcached", "stars": 13055, "license": "bsd-3-clause", "language": "c", "size": 5217}
{"docstring": "/*\n * Figures out which slab class (chunk size) is required to store an item of\n * a given size.\n *\n * Given object size, return id to use when allocating/freeing memory for object\n * 0 means error: can't store such a large object\n */\n", "func_signal": "unsigned int slabs_clsid(const size_t size)", "code": "{\n    int res = POWER_SMALLEST;\n\n    if (size == 0 || size > settings.item_size_max)\n        return 0;\n    while (size > slabclass[res].size)\n        if (res++ == power_largest)     /* won't fit in the biggest slab */\n            return power_largest;\n    return res;\n}", "path": "memcached/slabs.c", "commit_date": "2020-10-30 00:00:00", "repo_name": "memcached/memcached", "stars": 13055, "license": "bsd-3-clause", "language": "c", "size": 5217}
{"docstring": "// TODO:\n// - rolling checksum along with the writes.\n// - write final line + checksum + byte count or w/e.\n", "func_signal": "static int restart_save(const char *file)", "code": "{\n    // metadata is kept in a separate file.\n    // FIXME: function.\n    size_t flen = strlen(file);\n    const char *ext = \".meta\";\n    size_t extlen = strlen(ext);\n    char *metafile = calloc(1, flen + extlen + 1);\n    if (metafile == NULL) {\n        fprintf(stderr, \"[restart] failed to allocate memory during metadata save\\n\");\n        return -1;\n    }\n    memcpy(metafile, file, flen);\n    memcpy(metafile+flen, ext, extlen);\n\n    // restrictive permissions for the metadata file.\n    // TODO: also for the mmap file eh? :P\n    mode_t oldmask = umask(~(S_IRUSR | S_IWUSR));\n    FILE *f = fopen(metafile, \"w\");\n    umask(oldmask);\n    if (f == NULL) {\n        // FIXME: correct error handling.\n        free(metafile);\n        perror(\"failed to write metadata file\");\n        return -1;\n    }\n\n    restart_data_cb *cb = cb_stack;\n    restart_cb_ctx ctx;\n    ctx.f = f;\n    while (cb != NULL) {\n        // Plugins/engines in the metadata file are separated by tag lines.\n        fprintf(f, \"T%s\\n\", cb->tag);\n        if (cb->scb(cb->tag, &ctx, cb->data) != 0) {\n            fclose(f);\n            free(metafile);\n            return -1;\n        }\n\n        cb = cb->next;\n    }\n\n    fclose(f);\n    free(metafile);\n\n    return 0;\n}", "path": "memcached/restart.c", "commit_date": "2020-04-12 00:00:00", "repo_name": "memcached/memcached", "stars": 13055, "license": "bsd-3-clause", "language": "c", "size": 5217}
{"docstring": "/* This could potentially merge with above */\n", "func_signal": "static void window_global_sum(struct window_global *wg,\n        struct window_global *w, uint32_t size)", "code": "{\n    for (int x = 0; x < size; x++) {\n        struct window_global *d = &wg[x];\n        w->pool_high += d->pool_high;\n        w->pool_low += d->pool_low;\n    }\n}", "path": "memcached/slab_automove_extstore.c", "commit_date": "2019-05-20 00:00:00", "repo_name": "memcached/memcached", "stars": 13055, "license": "bsd-3-clause", "language": "c", "size": 5217}
{"docstring": "/* CALLED WITH slabs_lock HELD */\n/* detaches item/chunk from freelist. */\n", "func_signal": "static void slab_rebalance_cut_free(slabclass_t *s_cls, item *it)", "code": "{\n    /* Ensure this was on the freelist and nothing else. */\n    assert(it->it_flags == ITEM_SLABBED);\n    if (s_cls->slots == it) {\n        s_cls->slots = it->next;\n    }\n    if (it->next) it->next->prev = it->prev;\n    if (it->prev) it->prev->next = it->next;\n    s_cls->sl_curr--;\n}", "path": "memcached/slabs.c", "commit_date": "2020-10-30 00:00:00", "repo_name": "memcached/memcached", "stars": 13055, "license": "bsd-3-clause", "language": "c", "size": 5217}
{"docstring": "//-----------------------------------------------------------------------------\n// Finalization mix - force all bits of a hash block to avalanche\n", "func_signal": "static FORCE_INLINE uint32_t fmix32 ( uint32_t h )", "code": "{\n  h ^= h >> 16;\n  h *= 0x85ebca6b;\n  h ^= h >> 13;\n  h *= 0xc2b2ae35;\n  h ^= h >> 16;\n\n  return h;\n}", "path": "memcached/murmur3_hash.c", "commit_date": "2015-01-01 00:00:00", "repo_name": "memcached/memcached", "stars": 13055, "license": "bsd-3-clause", "language": "c", "size": 5217}
{"docstring": "/* CALLED WITH slabs_lock HELD */\n", "func_signal": "static void *slab_rebalance_alloc(const size_t size, unsigned int id)", "code": "{\n    slabclass_t *s_cls;\n    s_cls = &slabclass[slab_rebal.s_clsid];\n    int x;\n    item *new_it = NULL;\n\n    for (x = 0; x < s_cls->perslab; x++) {\n        new_it = do_slabs_alloc(size, id, SLABS_ALLOC_NO_NEWPAGE);\n        /* check that memory isn't within the range to clear */\n        if (new_it == NULL) {\n            break;\n        }\n        if ((void *)new_it >= slab_rebal.slab_start\n            && (void *)new_it < slab_rebal.slab_end) {\n            /* Pulled something we intend to free. Mark it as freed since\n             * we've already done the work of unlinking it from the freelist.\n             */\n            new_it->refcount = 0;\n            new_it->it_flags = ITEM_SLABBED|ITEM_FETCHED;\n#ifdef DEBUG_SLAB_MOVER\n            memcpy(ITEM_key(new_it), \"deadbeef\", 8);\n#endif\n            new_it = NULL;\n            slab_rebal.inline_reclaim++;\n        } else {\n            break;\n        }\n    }\n    return new_it;\n}", "path": "memcached/slabs.c", "commit_date": "2020-10-30 00:00:00", "repo_name": "memcached/memcached", "stars": 13055, "license": "bsd-3-clause", "language": "c", "size": 5217}
{"docstring": "// This function advances the file read while being called directly from the\n// callback.\n// The control inversion here (callback calling in which might change the next\n// callback) allows the callbacks to set up proper loops or sequences for\n// reading data back, avoiding an event model.\n", "func_signal": "enum restart_get_kv_ret restart_get_kv(void *ctx, char **key, char **val)", "code": "{\n    char *line = NULL;\n    size_t len = 0;\n    restart_data_cb *cb = NULL;\n    restart_cb_ctx *c = (restart_cb_ctx *) ctx;\n    // free previous line.\n    // we could just pass it into getline, but it can randomly realloc so we'd\n    // have to re-assign it into the structure anyway.\n    if (c->line != NULL) {\n        free(c->line);\n        c->line = NULL;\n    }\n\n    if (getline(&line, &len, c->f) != -1) {\n        // First char is an indicator:\n        // T for TAG, changing the callback we use.\n        // K for key/value, to ship to the active callback.\n        char *p = line;\n        while (*p != '\\n') {\n            p++;\n        }\n        *p = '\\0';\n\n        if (line[0] == 'T') {\n            cb = cb_stack;\n            while (cb != NULL) {\n                // NOTE: len is allocated size, not line len. need to chomp \\n\n                if (strcmp(cb->tag, line+1) == 0) {\n                    break;\n                }\n                cb = cb->next;\n            }\n            if (cb == NULL) {\n                fprintf(stderr, \"[restart] internal handler for metadata tag not found: %s:\\n\", line+1);\n                return RESTART_NOTAG;\n            }\n            c->cb = cb;\n        } else if (line[0] == 'K') {\n            char *p = line+1; // start just ahead of the token.\n            // tokenize the string and return the pointers?\n            if (key != NULL) {\n                *key = p;\n            }\n\n            // turn key into a normal NULL terminated string.\n            while (*p != ' ' && (p - line < len)) {\n                p++;\n            }\n            *p = '\\0';\n            p++;\n\n            // value _should_ run until where the newline was, which is \\0 now\n            if (val != NULL) {\n                *val = p;\n            }\n            c->line = line;\n\n            return RESTART_OK;\n        } else {\n            // FIXME: proper error chain.\n            fprintf(stderr, \"[restart] invalid metadata line:\\n\\n%s\\n\", line);\n            free(line);\n            return RESTART_BADLINE;\n        }\n    } else {\n        // EOF or error in read.\n        c->done = true;\n    }\n\n    return RESTART_DONE;\n}", "path": "memcached/restart.c", "commit_date": "2020-04-12 00:00:00", "repo_name": "memcached/memcached", "stars": 13055, "license": "bsd-3-clause", "language": "c", "size": 5217}
{"docstring": "/**\n * Determines the chunk sizes and initializes the slab class descriptors\n * accordingly.\n */\n", "func_signal": "void slabs_init(const size_t limit, const double factor, const bool prealloc, const uint32_t *slab_sizes, void *mem_base_external, bool reuse_mem)", "code": "{\n    int i = POWER_SMALLEST - 1;\n    unsigned int size = sizeof(item) + settings.chunk_size;\n\n    /* Some platforms use runtime transparent hugepages. If for any reason\n     * the initial allocation fails, the required settings do not persist\n     * for remaining allocations. As such it makes little sense to do slab\n     * preallocation. */\n    bool __attribute__ ((unused)) do_slab_prealloc = false;\n\n    mem_limit = limit;\n\n    if (prealloc && mem_base_external == NULL) {\n        mem_base = alloc_large_chunk(mem_limit);\n        if (mem_base) {\n            do_slab_prealloc = true;\n            mem_current = mem_base;\n            mem_avail = mem_limit;\n        } else {\n            fprintf(stderr, \"Warning: Failed to allocate requested memory in\"\n                    \" one large chunk.\\nWill allocate in smaller chunks\\n\");\n        }\n    } else if (prealloc && mem_base_external != NULL) {\n        // Can't (yet) mix hugepages with mmap allocations, so separate the\n        // logic from above. Reusable memory also force-preallocates memory\n        // pages into the global pool, which requires turning mem_* variables.\n        do_slab_prealloc = true;\n        mem_base = mem_base_external;\n        // _current shouldn't be used in this case, but we set it to where it\n        // should be anyway.\n        if (reuse_mem) {\n            mem_current = ((char*)mem_base) + mem_limit;\n            mem_avail = 0;\n        } else {\n            mem_current = mem_base;\n            mem_avail = mem_limit;\n        }\n    }\n\n    memset(slabclass, 0, sizeof(slabclass));\n\n    while (++i < MAX_NUMBER_OF_SLAB_CLASSES-1) {\n        if (slab_sizes != NULL) {\n            if (slab_sizes[i-1] == 0)\n                break;\n            size = slab_sizes[i-1];\n        } else if (size >= settings.slab_chunk_size_max / factor) {\n            break;\n        }\n        /* Make sure items are always n-byte aligned */\n        if (size % CHUNK_ALIGN_BYTES)\n            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);\n\n        slabclass[i].size = size;\n        slabclass[i].perslab = settings.slab_page_size / slabclass[i].size;\n        if (slab_sizes == NULL)\n            size *= factor;\n        if (settings.verbose > 1) {\n            fprintf(stderr, \"slab class %3d: chunk size %9u perslab %7u\\n\",\n                    i, slabclass[i].size, slabclass[i].perslab);\n        }\n    }\n\n    power_largest = i;\n    slabclass[power_largest].size = settings.slab_chunk_size_max;\n    slabclass[power_largest].perslab = settings.slab_page_size / settings.slab_chunk_size_max;\n    if (settings.verbose > 1) {\n        fprintf(stderr, \"slab class %3d: chunk size %9u perslab %7u\\n\",\n                i, slabclass[i].size, slabclass[i].perslab);\n    }\n\n    /* for the test suite:  faking of how much we've already malloc'd */\n    {\n        char *t_initial_malloc = getenv(\"T_MEMD_INITIAL_MALLOC\");\n        if (t_initial_malloc) {\n            int64_t env_malloced;\n            if (safe_strtoll((const char *)t_initial_malloc, &env_malloced)) {\n                mem_malloced = (size_t)env_malloced;\n            }\n        }\n\n    }\n\n    if (do_slab_prealloc) {\n        if (!reuse_mem) {\n            slabs_preallocate(power_largest);\n        }\n    }\n}", "path": "memcached/slabs.c", "commit_date": "2020-10-30 00:00:00", "repo_name": "memcached/memcached", "stars": 13055, "license": "bsd-3-clause", "language": "c", "size": 5217}
{"docstring": "/* Slab mover thread.\n * Sits waiting for a condition to jump off and shovel some memory about\n */\n", "func_signal": "static void *slab_rebalance_thread(void *arg)", "code": "{\n    int was_busy = 0;\n    int backoff_timer = 1;\n    int backoff_max = 1000;\n    /* So we first pass into cond_wait with the mutex held */\n    mutex_lock(&slabs_rebalance_lock);\n\n    /* Must finish moving page before stopping */\n    while (slab_rebalance_signal || do_run_slab_rebalance_thread) {\n        if (slab_rebalance_signal == 1) {\n            if (slab_rebalance_start() < 0) {\n                /* Handle errors with more specificity as required. */\n                slab_rebalance_signal = 0;\n            }\n\n            was_busy = 0;\n        } else if (slab_rebalance_signal && slab_rebal.slab_start != NULL) {\n            was_busy = slab_rebalance_move();\n        }\n\n        if (slab_rebal.done) {\n            slab_rebalance_finish();\n        } else if (was_busy) {\n            /* Stuck waiting for some items to unlock, so slow down a bit\n             * to give them a chance to free up */\n            usleep(backoff_timer);\n            backoff_timer = backoff_timer * 2;\n            if (backoff_timer > backoff_max)\n                backoff_timer = backoff_max;\n        }\n\n        if (slab_rebalance_signal == 0) {\n            /* always hold this lock while we're running */\n            pthread_cond_wait(&slab_rebalance_cond, &slabs_rebalance_lock);\n        }\n    }\n\n    // TODO: cancel in-flight slab page move\n    mutex_unlock(&slabs_rebalance_lock);\n    return NULL;\n}", "path": "memcached/slabs.c", "commit_date": "2020-10-30 00:00:00", "repo_name": "memcached/memcached", "stars": 13055, "license": "bsd-3-clause", "language": "c", "size": 5217}
{"docstring": "/* A percentage of memory is configured to be held \"free\" as buffers for the\n * external storage system.\n * % of global memory is desired in the global page pool\n * each slab class has a % of free chunks desired based on how much memory is\n * currently in the class. This allows time for extstore to flush data when\n * spikes or waves of set data arrive.\n * The global page pool reserve acts as a secondary buffer for any slab class,\n * which helps absorb shifts in which class is active.\n */\n", "func_signal": "static void memcheck(slab_automove *a)", "code": "{\n    unsigned int total_pages = 0;\n    if (current_time < a->last_memcheck_run + MEMCHECK_PERIOD)\n        return;\n    a->last_memcheck_run = current_time;\n    for (int n = 1; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {\n        slab_stats_automove *sam = &a->sam_after[n];\n        total_pages += sam->total_pages;\n        unsigned int hold_free = (sam->total_pages * sam->chunks_per_page)\n            * a->free_ratio;\n        if (sam->chunks_per_page * MIN_PAGES_FREE > hold_free)\n            hold_free = sam->chunks_per_page * MIN_PAGES_FREE;\n        a->free_mem[n] = hold_free;\n        if (a->settings->ext_free_memchunks[n] != hold_free && a->pool_filled_once) {\n            a->settings->ext_free_memchunks[n] = hold_free;\n        }\n    }\n    // remember to add what remains in global pool.\n    total_pages += a->sam_after[0].total_pages;\n    a->free_mem[0] = total_pages * a->free_ratio;\n}", "path": "memcached/slab_automove_extstore.c", "commit_date": "2019-05-20 00:00:00", "repo_name": "memcached/memcached", "stars": 13055, "license": "bsd-3-clause", "language": "c", "size": 5217}
{"docstring": "/*\n * dropping privileges is entering in capability mode\n * in FreeBSD vocabulary.\n */\n", "func_signal": "void drop_privileges()", "code": "{\n    cap_rights_t wd, rd;\n\n    if (cap_rights_init(&wd, CAP_WRITE, CAP_READ) == NULL) {\n        fprintf(stderr, \"cap_rights_init write protection failed: %s\\n\", strerror(errno));\n        exit(EXIT_FAILURE);\n    }\n\n    if (cap_rights_init(&rd, CAP_FCNTL, CAP_READ, CAP_EVENT) == NULL) {\n        fprintf(stderr, \"cap_rights_init read protection failed: %s\\n\", strerror(errno));\n        exit(EXIT_FAILURE);\n    }\n\n    if (cap_rights_limit(STDIN_FILENO, &rd) != 0) {\n        fprintf(stderr, \"cap_rights_limit stdin failed: %s\\n\", strerror(errno));\n        exit(EXIT_FAILURE);\n    }\n\n    if (cap_rights_limit(STDOUT_FILENO, &wd) != 0) {\n        fprintf(stderr, \"cap_rights_limit stdout failed: %s\\n\", strerror(errno));\n        exit(EXIT_FAILURE);\n    }\n\n    if (cap_rights_limit(STDERR_FILENO, &wd) != 0) {\n        fprintf(stderr, \"cap_rights_limit stderr failed: %s\\n\", strerror(errno));\n        exit(EXIT_FAILURE);\n    }\n\n    if (cap_enter() != 0) {\n        fprintf(stderr, \"cap_enter failed: %s\\n\", strerror(errno));\n        exit(EXIT_FAILURE);\n    }\n}", "path": "memcached/freebsd_priv.c", "commit_date": "2019-09-28 00:00:00", "repo_name": "memcached/memcached", "stars": 13055, "license": "bsd-3-clause", "language": "c", "size": 5217}
{"docstring": "// TODO: error string from cb?\n// - look for final line with checksum\n// - checksum entire file (up until final line)\n// - seek to start\n", "func_signal": "static int restart_check(const char *file)", "code": "{\n    // metadata is kept in a separate file.\n    size_t flen = strlen(file);\n    const char *ext = \".meta\";\n    char *metafile = calloc(1, flen + strlen(ext) + 1);\n    if (metafile == NULL) {\n        // probably in a really bad position if we hit here, so don't start.\n        fprintf(stderr, \"[restart] failed to allocate memory for restart check\\n\");\n        abort();\n    }\n    memcpy(metafile, file, flen);\n    memcpy(metafile+flen, ext, strlen(ext));\n\n    FILE *f = fopen(metafile, \"r\");\n    if (f == NULL) {\n        fprintf(stderr, \"[restart] no metadata save file, starting with a clean cache\\n\");\n        free(metafile);\n        return -1;\n    }\n\n    restart_cb_ctx ctx;\n\n    ctx.f = f;\n    ctx.cb = NULL;\n    ctx.line = NULL;\n    ctx.done = false;\n    if (restart_get_kv(&ctx, NULL, NULL) != RESTART_DONE) {\n        // First line must be a tag, so read it in and set up the proper\n        // callback here.\n        fprintf(stderr, \"[restart] corrupt metadata file\\n\");\n        // TODO: this should probably just return -1 and skip the reuse.\n        abort();\n    }\n    if (ctx.cb == NULL) {\n        fprintf(stderr, \"[restart] Failed to read a tag from metadata file\\n\");\n        abort();\n    }\n\n    // loop call the callback, check result code.\n    bool failed = false;\n    while (!ctx.done) {\n        restart_data_cb *cb = ctx.cb;\n        if (cb->ccb(cb->tag, &ctx, cb->data) != 0) {\n            failed = true;\n            break;\n        }\n    }\n\n    if (ctx.line)\n        free(ctx.line);\n\n    fclose(f);\n\n    unlink(metafile);\n    free(metafile);\n\n    if (failed) {\n        fprintf(stderr, \"[restart] failed to valiate metadata, starting with a clean cache\\n\");\n        return -1;\n    } else {\n        return 0;\n    }\n}", "path": "memcached/restart.c", "commit_date": "2020-04-12 00:00:00", "repo_name": "memcached/memcached", "stars": 13055, "license": "bsd-3-clause", "language": "c", "size": 5217}
{"docstring": "/* Must only be used if all pages are item_size_max */\n", "func_signal": "static void memory_release()", "code": "{\n    void *p = NULL;\n    if (mem_base != NULL)\n        return;\n\n    if (!settings.slab_reassign)\n        return;\n\n    while (mem_malloced > mem_limit &&\n            (p = get_page_from_global_pool()) != NULL) {\n        free(p);\n        mem_malloced -= settings.slab_page_size;\n    }\n}", "path": "memcached/slabs.c", "commit_date": "2020-10-30 00:00:00", "repo_name": "memcached/memcached", "stars": 13055, "license": "bsd-3-clause", "language": "c", "size": 5217}
{"docstring": "/* Definition modified slightly from the public domain interface (no seed +\n * return value */\n", "func_signal": "uint32_t MurmurHash3_x86_32 ( const void * key, size_t length)", "code": "{\n  const uint8_t * data = (const uint8_t*)key;\n  const int nblocks = length / 4;\n\n  uint32_t h1 = 0;\n\n  uint32_t c1 = 0xcc9e2d51;\n  uint32_t c2 = 0x1b873593;\n\n  //----------\n  // body\n\n  const uint32_t * blocks = (const uint32_t *)(data + nblocks*4);\n\n  for(int i = -nblocks; i; i++)\n  {\n    uint32_t k1 = getblock32(blocks,i);\n\n    k1 *= c1;\n    k1 = ROTL32(k1,15);\n    k1 *= c2;\n\n    h1 ^= k1;\n    h1 = ROTL32(h1,13);\n    h1 = h1*5+0xe6546b64;\n  }\n\n  //----------\n  // tail\n\n  const uint8_t * tail = (const uint8_t*)(data + nblocks*4);\n\n  uint32_t k1 = 0;\n\n  switch(length & 3)\n  {\n  case 3: k1 ^= tail[2] << 16;\n  case 2: k1 ^= tail[1] << 8;\n  case 1: k1 ^= tail[0];\n          k1 *= c1; k1 = ROTL32(k1,15); k1 *= c2; h1 ^= k1;\n  };\n\n  //----------\n  // finalization\n\n  h1 ^= length;\n\n  h1 = fmix32(h1);\n\n  //*(uint32_t*)out = h1;\n  return h1;\n}", "path": "memcached/murmur3_hash.c", "commit_date": "2015-01-01 00:00:00", "repo_name": "memcached/memcached", "stars": 13055, "license": "bsd-3-clause", "language": "c", "size": 5217}
{"docstring": "/*\n * The FixedDocumentSequence and FixedDocument parts determine\n * which parts correspond to actual pages, and the page order.\n */\n", "func_signal": "static void\nxps_add_fixed_document(fz_context *ctx, xps_document *doc, char *name)", "code": "{\n\txps_fixdoc *fixdoc;\n\n\t/* Check for duplicates first */\n\tfor (fixdoc = doc->first_fixdoc; fixdoc; fixdoc = fixdoc->next)\n\t\tif (!strcmp(fixdoc->name, name))\n\t\t\treturn;\n\n\tfixdoc = fz_malloc_struct(ctx, xps_fixdoc);\n\tfz_try(ctx)\n\t{\n\t\tfixdoc->name = fz_strdup(ctx, name);\n\t\tfixdoc->outline = NULL;\n\t\tfixdoc->next = NULL;\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_free(ctx, fixdoc);\n\t\tfz_rethrow(ctx);\n\t}\n\n\tif (!doc->first_fixdoc)\n\t{\n\t\tdoc->first_fixdoc = fixdoc;\n\t\tdoc->last_fixdoc = fixdoc;\n\t}\n\telse\n\t{\n\t\tdoc->last_fixdoc->next = fixdoc;\n\t\tdoc->last_fixdoc = fixdoc;\n\t}\n}", "path": "sumatrapdf/mupdf/source/xps/xps-doc.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "sumatrapdfreader/sumatrapdf", "stars": 12322, "license": "gpl-3.0", "language": "c", "size": 282658}
{"docstring": "// Adds a decoding error to the parser's error list, based on the current state\n// of the Utf8Iterator.\n", "func_signal": "static void add_error(Utf8Iterator* iter, GumboErrorType type)", "code": "{\n  GumboParser* parser = iter->_parser;\n\n  GumboError* error = gumbo_add_error(parser);\n  if (!error) {\n    return;\n  }\n  error->type = type;\n  error->position = iter->_pos;\n  error->original_text = iter->_start;\n\n  // At the point the error is recorded, the code point hasn't been computed\n  // yet (and can't be, because it's invalid), so we need to build up the raw\n  // hex value from the bytes under the cursor.\n  uint64_t code_point = 0;\n  for (int i = 0; i < iter->_width; ++i) {\n    code_point = (code_point << 8) | (unsigned char) iter->_start[i];\n  }\n  error->v.codepoint = code_point;\n}", "path": "sumatrapdf/ext/gumbo-parser/src/utf8.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "sumatrapdfreader/sumatrapdf", "stars": 12322, "license": "gpl-3.0", "language": "c", "size": 282658}
{"docstring": "/* The glyph cache lock is always held when this function is called. */\n", "func_signal": "static void\ndo_purge(fz_context *ctx)", "code": "{\n\tfz_glyph_cache *cache = ctx->glyph_cache;\n\tint i;\n\n\tfor (i = 0; i < GLYPH_HASH_LEN; i++)\n\t{\n\t\twhile (cache->entry[i])\n\t\t\tdrop_glyph_cache_entry(ctx, cache->entry[i]);\n\t}\n\n\tcache->total = 0;\n}", "path": "sumatrapdf/mupdf/source/fitz/draw-glyph.c", "commit_date": "2020-04-17 00:00:00", "repo_name": "sumatrapdfreader/sumatrapdf", "stars": 12322, "license": "gpl-3.0", "language": "c", "size": 282658}
{"docstring": "//------------------------------------------------------------------------------\n// Default custom functions\n", "func_signal": "static int CustomSetup(VP8Io* io)", "code": "{\n  WebPDecParams* const p = (WebPDecParams*)io->opaque;\n  const WEBP_CSP_MODE colorspace = p->output->colorspace;\n  const int is_rgb = WebPIsRGBMode(colorspace);\n  const int is_alpha = WebPIsAlphaMode(colorspace);\n\n  p->memory = NULL;\n  p->emit = NULL;\n  p->emit_alpha = NULL;\n  p->emit_alpha_row = NULL;\n  if (!WebPIoInitFromOptions(p->options, io, is_alpha ? MODE_YUV : MODE_YUVA)) {\n    return 0;\n  }\n  if (is_alpha && WebPIsPremultipliedMode(colorspace)) {\n    WebPInitUpsamplers();\n  }\n  if (io->use_scaling) {\n#if !defined(WEBP_REDUCE_SIZE)\n    const int ok = is_rgb ? InitRGBRescaler(io, p) : InitYUVRescaler(io, p);\n    if (!ok) {\n      return 0;    // memory error\n    }\n#else\n    return 0;   // rescaling support not compiled\n#endif\n  } else {\n    if (is_rgb) {\n      WebPInitSamplers();\n      p->emit = EmitSampledRGB;   // default\n      if (io->fancy_upsampling) {\n#ifdef FANCY_UPSAMPLING\n        const int uv_width = (io->mb_w + 1) >> 1;\n        p->memory = WebPSafeMalloc(1ULL, (size_t)(io->mb_w + 2 * uv_width));\n        if (p->memory == NULL) {\n          return 0;   // memory error.\n        }\n        p->tmp_y = (uint8_t*)p->memory;\n        p->tmp_u = p->tmp_y + io->mb_w;\n        p->tmp_v = p->tmp_u + uv_width;\n        p->emit = EmitFancyRGB;\n        WebPInitUpsamplers();\n#endif\n      }\n    } else {\n      p->emit = EmitYUV;\n    }\n    if (is_alpha) {  // need transparency output\n      p->emit_alpha =\n          (colorspace == MODE_RGBA_4444 || colorspace == MODE_rgbA_4444) ?\n              EmitAlphaRGBA4444\n          : is_rgb ? EmitAlphaRGB\n          : EmitAlphaYUV;\n      if (is_rgb) {\n        WebPInitAlphaProcessing();\n      }\n    }\n  }\n\n  return 1;\n}", "path": "sumatrapdf/ext/libwebp/src/dec/io_dec.c", "commit_date": "2019-10-29 00:00:00", "repo_name": "sumatrapdfreader/sumatrapdf", "stars": 12322, "license": "gpl-3.0", "language": "c", "size": 282658}
{"docstring": "// Sets the position and original text fields of an error to the value at the\n// mark.\n", "func_signal": "void utf8iterator_fill_error_at_mark(Utf8Iterator* iter, GumboError* error)", "code": "{\n  error->position = iter->_mark_pos;\n  error->original_text = iter->_mark;\n}", "path": "sumatrapdf/ext/gumbo-parser/src/utf8.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "sumatrapdfreader/sumatrapdf", "stars": 12322, "license": "gpl-3.0", "language": "c", "size": 282658}
{"docstring": "/*\n * Load the image into a virtual array.  We have to do this because RLE\n * files start at the lower left while the JPEG standard has them starting\n * in the upper left.  This is called the first time we want to get a row\n * of input.  What we do is load the RLE data into the array and then call\n * the appropriate routine to read one row from the array.  Before returning,\n * we set source->pub.get_pixel_rows so that subsequent calls go straight to\n * the appropriate row-reading routine.\n */\n", "func_signal": "METHODDEF(JDIMENSION)\nload_image (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)", "code": "{\n  rle_source_ptr source = (rle_source_ptr) sinfo;\n  JDIMENSION row, col;\n  JSAMPROW  scanline, red_ptr, green_ptr, blue_ptr;\n  rle_pixel **rle_row;\n  rle_map *colormap;\n  char channel;\n#ifdef PROGRESS_REPORT\n  cd_progress_ptr progress = (cd_progress_ptr) cinfo->progress;\n#endif\n\n  colormap = source->header.cmap;\n  rle_row = source->rle_row;\n\n  /* Read the RLE data into our virtual array.\n   * We assume here that (a) rle_pixel is represented the same as JSAMPLE,\n   * and (b) we are not on a machine where FAR pointers differ from regular.\n   */\n  RLE_CLR_BIT(source->header, RLE_ALPHA); /* don't read the alpha channel */\n\n#ifdef PROGRESS_REPORT\n  if (progress != NULL) {\n    progress->pub.pass_limit = cinfo->image_height;\n    progress->pub.pass_counter = 0;\n    (*progress->pub.progress_monitor) ((j_common_ptr) cinfo);\n  }\n#endif\n\n  switch (source->visual) {\n\n  case GRAYSCALE:\n  case PSEUDOCOLOR:\n    for (row = 0; row < cinfo->image_height; row++) {\n      rle_row = (rle_pixel **) (*cinfo->mem->access_virt_sarray)\n         ((j_common_ptr) cinfo, source->image, row, (JDIMENSION) 1, TRUE);\n      rle_getrow(&source->header, rle_row);\n#ifdef PROGRESS_REPORT\n      if (progress != NULL) {\n        progress->pub.pass_counter++;\n        (*progress->pub.progress_monitor) ((j_common_ptr) cinfo);\n      }\n#endif\n    }\n    break;\n\n  case MAPPEDGRAY:\n  case TRUECOLOR:\n    for (row = 0; row < cinfo->image_height; row++) {\n      scanline = * (*cinfo->mem->access_virt_sarray)\n        ((j_common_ptr) cinfo, source->image, row, (JDIMENSION) 1, TRUE);\n      rle_row = source->rle_row;\n      rle_getrow(&source->header, rle_row);\n\n      for (col = 0; col < cinfo->image_width; col++) {\n        for (channel = 0; channel < source->header.ncolors; channel++) {\n          *scanline++ = (JSAMPLE)\n            (colormap[GETJSAMPLE(rle_row[channel][col]) + 256 * channel] >> 8);\n        }\n      }\n\n#ifdef PROGRESS_REPORT\n      if (progress != NULL) {\n        progress->pub.pass_counter++;\n        (*progress->pub.progress_monitor) ((j_common_ptr) cinfo);\n      }\n#endif\n    }\n    break;\n\n  case DIRECTCOLOR:\n    for (row = 0; row < cinfo->image_height; row++) {\n      scanline = * (*cinfo->mem->access_virt_sarray)\n        ((j_common_ptr) cinfo, source->image, row, (JDIMENSION) 1, TRUE);\n      rle_getrow(&source->header, rle_row);\n\n      red_ptr   = rle_row[0];\n      green_ptr = rle_row[1];\n      blue_ptr  = rle_row[2];\n\n      for (col = cinfo->image_width; col > 0; col--) {\n        *scanline++ = *red_ptr++;\n        *scanline++ = *green_ptr++;\n        *scanline++ = *blue_ptr++;\n      }\n\n#ifdef PROGRESS_REPORT\n      if (progress != NULL) {\n        progress->pub.pass_counter++;\n        (*progress->pub.progress_monitor) ((j_common_ptr) cinfo);\n      }\n#endif\n    }\n  }\n\n#ifdef PROGRESS_REPORT\n  if (progress != NULL)\n    progress->completed_extra_passes++;\n#endif\n\n  /* Set up to call proper row-extraction routine in future */\n  if (source->visual == PSEUDOCOLOR) {\n    source->pub.buffer = source->rle_row;\n    source->pub.get_pixel_rows = get_pseudocolor_row;\n  } else {\n    source->pub.get_pixel_rows = get_rle_row;\n  }\n  source->row = cinfo->image_height;\n\n  /* And fetch the topmost (bottommost) row */\n  return (*source->pub.get_pixel_rows) (cinfo, sinfo);   \n}", "path": "sumatrapdf/ext/libjpeg-turbo/rdrle.c", "commit_date": "2010-12-06 00:00:00", "repo_name": "sumatrapdfreader/sumatrapdf", "stars": 12322, "license": "gpl-3.0", "language": "c", "size": 282658}
{"docstring": "/*\n * Read the file header; return image size and component count.\n */\n", "func_signal": "METHODDEF(void)\nstart_input_rle (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)", "code": "{\n  rle_source_ptr source = (rle_source_ptr) sinfo;\n  JDIMENSION width, height;\n#ifdef PROGRESS_REPORT\n  cd_progress_ptr progress = (cd_progress_ptr) cinfo->progress;\n#endif\n\n  /* Use RLE library routine to get the header info */\n  source->header = *rle_hdr_init(NULL);\n  source->header.rle_file = source->pub.input_file;\n  switch (rle_get_setup(&(source->header))) {\n  case RLE_SUCCESS:\n    /* A-OK */\n    break;\n  case RLE_NOT_RLE:\n    ERREXIT(cinfo, JERR_RLE_NOT);\n    break;\n  case RLE_NO_SPACE:\n    ERREXIT(cinfo, JERR_RLE_MEM);\n    break;\n  case RLE_EMPTY:\n    ERREXIT(cinfo, JERR_RLE_EMPTY);\n    break;\n  case RLE_EOF:\n    ERREXIT(cinfo, JERR_RLE_EOF);\n    break;\n  default:\n    ERREXIT(cinfo, JERR_RLE_BADERROR);\n    break;\n  }\n\n  /* Figure out what we have, set private vars and return values accordingly */\n  \n  width  = source->header.xmax - source->header.xmin + 1;\n  height = source->header.ymax - source->header.ymin + 1;\n  source->header.xmin = 0;\t\t/* realign horizontally */\n  source->header.xmax = width-1;\n\n  cinfo->image_width      = width;\n  cinfo->image_height     = height;\n  cinfo->data_precision   = 8;  /* we can only handle 8 bit data */\n\n  if (source->header.ncolors == 1 && source->header.ncmap == 0) {\n    source->visual     = GRAYSCALE;\n    TRACEMS2(cinfo, 1, JTRC_RLE_GRAY, width, height);\n  } else if (source->header.ncolors == 1 && source->header.ncmap == 1) {\n    source->visual     = MAPPEDGRAY;\n    TRACEMS3(cinfo, 1, JTRC_RLE_MAPGRAY, width, height,\n             1 << source->header.cmaplen);\n  } else if (source->header.ncolors == 1 && source->header.ncmap == 3) {\n    source->visual     = PSEUDOCOLOR;\n    TRACEMS3(cinfo, 1, JTRC_RLE_MAPPED, width, height,\n\t     1 << source->header.cmaplen);\n  } else if (source->header.ncolors == 3 && source->header.ncmap == 3) {\n    source->visual     = TRUECOLOR;\n    TRACEMS3(cinfo, 1, JTRC_RLE_FULLMAP, width, height,\n\t     1 << source->header.cmaplen);\n  } else if (source->header.ncolors == 3 && source->header.ncmap == 0) {\n    source->visual     = DIRECTCOLOR;\n    TRACEMS2(cinfo, 1, JTRC_RLE, width, height);\n  } else\n    ERREXIT(cinfo, JERR_RLE_UNSUPPORTED);\n  \n  if (source->visual == GRAYSCALE || source->visual == MAPPEDGRAY) {\n    cinfo->in_color_space   = JCS_GRAYSCALE;\n    cinfo->input_components = 1;\n  } else {\n    cinfo->in_color_space   = JCS_RGB;\n    cinfo->input_components = 3;\n  }\n\n  /*\n   * A place to hold each scanline while it's converted.\n   * (GRAYSCALE scanlines don't need converting)\n   */\n  if (source->visual != GRAYSCALE) {\n    source->rle_row = (rle_pixel**) (*cinfo->mem->alloc_sarray)\n      ((j_common_ptr) cinfo, JPOOL_IMAGE,\n       (JDIMENSION) width, (JDIMENSION) cinfo->input_components);\n  }\n\n  /* request a virtual array to hold the image */\n  source->image = (*cinfo->mem->request_virt_sarray)\n    ((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,\n     (JDIMENSION) (width * source->header.ncolors),\n     (JDIMENSION) height, (JDIMENSION) 1);\n\n#ifdef PROGRESS_REPORT\n  if (progress != NULL) {\n    /* count file input as separate pass */\n    progress->total_extra_passes++;\n  }\n#endif\n\n  source->pub.buffer_height = 1;\n}", "path": "sumatrapdf/ext/libjpeg-turbo/rdrle.c", "commit_date": "2010-12-06 00:00:00", "repo_name": "sumatrapdfreader/sumatrapdf", "stars": 12322, "license": "gpl-3.0", "language": "c", "size": 282658}
{"docstring": "// disabled for now. TODO(skal): make match the C-code\n", "func_signal": "static void ExportRowShrink_MIPS32(WebPRescaler* const wrk)", "code": "{\n  const int x_out_max = wrk->dst_width * wrk->num_channels;\n  uint8_t* dst = wrk->dst;\n  rescaler_t* irow = wrk->irow;\n  const rescaler_t* frow = wrk->frow;\n  const int yscale = wrk->fy_scale * (-wrk->y_accum);\n  int temp0, temp1, temp3, temp4, temp5, loop_end;\n  const int temp2 = (int)wrk->fxy_scale;\n  const int temp6 = x_out_max << 2;\n\n  assert(!WebPRescalerOutputDone(wrk));\n  assert(wrk->y_accum <= 0);\n  assert(!wrk->y_expand);\n  assert(wrk->fxy_scale != 0);\n  if (yscale) {\n    __asm__ volatile (\n      \"li       %[temp3],    0x10000                    \\n\\t\"\n      \"li       %[temp4],    0x8000                     \\n\\t\"\n      \"addu     %[loop_end], %[frow],     %[temp6]      \\n\\t\"\n    \"1:                                                 \\n\\t\"\n      \"lw       %[temp0],    0(%[frow])                 \\n\\t\"\n      \"mult     %[temp3],    %[temp4]                   \\n\\t\"\n      \"addiu    %[frow],     %[frow],     4             \\n\\t\"\n      \"maddu    %[temp0],    %[yscale]                  \\n\\t\"\n      \"mfhi     %[temp1]                                \\n\\t\"\n      \"lw       %[temp0],    0(%[irow])                 \\n\\t\"\n      \"addiu    %[dst],      %[dst],      1             \\n\\t\"\n      \"addiu    %[irow],     %[irow],     4             \\n\\t\"\n      \"subu     %[temp0],    %[temp0],    %[temp1]      \\n\\t\"\n      \"mult     %[temp3],    %[temp4]                   \\n\\t\"\n      \"maddu    %[temp0],    %[temp2]                   \\n\\t\"\n      \"mfhi     %[temp5]                                \\n\\t\"\n      \"sw       %[temp1],    -4(%[irow])                \\n\\t\"\n      \"sb       %[temp5],    -1(%[dst])                 \\n\\t\"\n      \"bne      %[frow],     %[loop_end], 1b            \\n\\t\"\n      : [temp0]\"=&r\"(temp0), [temp1]\"=&r\"(temp1), [temp3]\"=&r\"(temp3),\n        [temp4]\"=&r\"(temp4), [temp5]\"=&r\"(temp5), [frow]\"+r\"(frow),\n        [irow]\"+r\"(irow), [dst]\"+r\"(dst), [loop_end]\"=&r\"(loop_end)\n      : [temp2]\"r\"(temp2), [yscale]\"r\"(yscale), [temp6]\"r\"(temp6)\n      : \"memory\", \"hi\", \"lo\"\n    );\n  } else {\n    __asm__ volatile (\n      \"li       %[temp3],    0x10000                    \\n\\t\"\n      \"li       %[temp4],    0x8000                     \\n\\t\"\n      \"addu     %[loop_end], %[irow],     %[temp6]      \\n\\t\"\n    \"1:                                                 \\n\\t\"\n      \"lw       %[temp0],    0(%[irow])                 \\n\\t\"\n      \"addiu    %[dst],      %[dst],      1             \\n\\t\"\n      \"addiu    %[irow],     %[irow],     4             \\n\\t\"\n      \"mult     %[temp3],    %[temp4]                   \\n\\t\"\n      \"maddu    %[temp0],    %[temp2]                   \\n\\t\"\n      \"mfhi     %[temp5]                                \\n\\t\"\n      \"sw       $zero,       -4(%[irow])                \\n\\t\"\n      \"sb       %[temp5],    -1(%[dst])                 \\n\\t\"\n      \"bne      %[irow],     %[loop_end], 1b            \\n\\t\"\n      : [temp0]\"=&r\"(temp0), [temp1]\"=&r\"(temp1), [temp3]\"=&r\"(temp3),\n        [temp4]\"=&r\"(temp4), [temp5]\"=&r\"(temp5), [irow]\"+r\"(irow),\n        [dst]\"+r\"(dst), [loop_end]\"=&r\"(loop_end)\n      : [temp2]\"r\"(temp2), [temp6]\"r\"(temp6)\n      : \"memory\", \"hi\", \"lo\"\n    );\n  }\n}", "path": "sumatrapdf/ext/libwebp/src/dsp/rescaler_mips32.c", "commit_date": "2019-10-29 00:00:00", "repo_name": "sumatrapdfreader/sumatrapdf", "stars": 12322, "license": "gpl-3.0", "language": "c", "size": 282658}
{"docstring": "// Given the input 'filter' option, return an OR'd bit-set of filters to try.\n", "func_signal": "static uint32_t GetFilterMap(const uint8_t* alpha, int width, int height,\n                             int filter, int effort_level)", "code": "{\n  uint32_t bit_map = 0U;\n  if (filter == WEBP_FILTER_FAST) {\n    // Quick estimate of the best candidate.\n    int try_filter_none = (effort_level > 3);\n    const int kMinColorsForFilterNone = 16;\n    const int kMaxColorsForFilterNone = 192;\n    const int num_colors = GetNumColors(alpha, width, height, width);\n    // For low number of colors, NONE yields better compression.\n    filter = (num_colors <= kMinColorsForFilterNone)\n        ? WEBP_FILTER_NONE\n        : WebPEstimateBestFilter(alpha, width, height, width);\n    bit_map |= 1 << filter;\n    // For large number of colors, try FILTER_NONE in addition to the best\n    // filter as well.\n    if (try_filter_none || num_colors > kMaxColorsForFilterNone) {\n      bit_map |= FILTER_TRY_NONE;\n    }\n  } else if (filter == WEBP_FILTER_NONE) {\n    bit_map = FILTER_TRY_NONE;\n  } else {  // WEBP_FILTER_BEST -> try all\n    bit_map = FILTER_TRY_ALL;\n  }\n  return bit_map;\n}", "path": "sumatrapdf/ext/libwebp/src/enc/alpha_enc.c", "commit_date": "2019-10-29 00:00:00", "repo_name": "sumatrapdfreader/sumatrapdf", "stars": 12322, "license": "gpl-3.0", "language": "c", "size": 282658}
{"docstring": "// Returns the current input stream position to the mark.\n", "func_signal": "void utf8iterator_reset(Utf8Iterator* iter)", "code": "{\n  iter->_start = iter->_mark;\n  iter->_pos = iter->_mark_pos;\n  read_char(iter);\n}", "path": "sumatrapdf/ext/gumbo-parser/src/utf8.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "sumatrapdfreader/sumatrapdf", "stars": 12322, "license": "gpl-3.0", "language": "c", "size": 282658}
{"docstring": "//------------------------------------------------------------------------------\n// Row import\n", "func_signal": "static void ImportRowShrink_MIPS32(WebPRescaler* const wrk,\n                                   const uint8_t* src)", "code": "{\n  const int x_stride = wrk->num_channels;\n  const int x_out_max = wrk->dst_width * wrk->num_channels;\n  const int fx_scale = wrk->fx_scale;\n  const int x_add = wrk->x_add;\n  const int x_sub = wrk->x_sub;\n  const int x_stride1 = x_stride << 2;\n  int channel;\n  assert(!wrk->x_expand);\n  assert(!WebPRescalerInputDone(wrk));\n\n  for (channel = 0; channel < x_stride; ++channel) {\n    const uint8_t* src1 = src + channel;\n    rescaler_t* frow = wrk->frow + channel;\n    int temp1, temp2, temp3;\n    int base, frac, sum;\n    int accum, accum1;\n    int loop_c = x_out_max - channel;\n\n    __asm__ volatile (\n      \"li     %[temp1],   0x8000                    \\n\\t\"\n      \"li     %[temp2],   0x10000                   \\n\\t\"\n      \"li     %[sum],     0                         \\n\\t\"\n      \"li     %[accum],   0                         \\n\\t\"\n    \"1:                                             \\n\\t\"\n      \"addu   %[accum],   %[accum],   %[x_add]      \\n\\t\"\n      \"li     %[base],    0                         \\n\\t\"\n      \"blez   %[accum],   3f                        \\n\\t\"\n    \"2:                                             \\n\\t\"\n      \"lbu    %[base],    0(%[src1])                \\n\\t\"\n      \"subu   %[accum],   %[accum],   %[x_sub]      \\n\\t\"\n      \"addu   %[src1],    %[src1],    %[x_stride]   \\n\\t\"\n      \"addu   %[sum],     %[sum],     %[base]       \\n\\t\"\n      \"bgtz   %[accum],   2b                        \\n\\t\"\n    \"3:                                             \\n\\t\"\n      \"negu   %[accum1],  %[accum]                  \\n\\t\"\n      \"mul    %[frac],    %[base],    %[accum1]     \\n\\t\"\n      \"mul    %[temp3],   %[sum],     %[x_sub]      \\n\\t\"\n      \"subu   %[loop_c],  %[loop_c],  %[x_stride]   \\n\\t\"\n      \"mult   %[temp1],   %[temp2]                  \\n\\t\"\n      \"maddu  %[frac],    %[fx_scale]               \\n\\t\"\n      \"mfhi   %[sum]                                \\n\\t\"\n      \"subu   %[temp3],   %[temp3],   %[frac]       \\n\\t\"\n      \"sw     %[temp3],   0(%[frow])                \\n\\t\"\n      \"addu   %[frow],    %[frow],    %[x_stride1]  \\n\\t\"\n      \"bgtz   %[loop_c],  1b                        \\n\\t\"\n      : [accum]\"=&r\"(accum), [src1]\"+r\"(src1), [temp3]\"=&r\"(temp3),\n        [sum]\"=&r\"(sum), [base]\"=&r\"(base), [frac]\"=&r\"(frac),\n        [frow]\"+r\"(frow), [accum1]\"=&r\"(accum1),\n        [temp2]\"=&r\"(temp2), [temp1]\"=&r\"(temp1)\n      : [x_stride]\"r\"(x_stride), [fx_scale]\"r\"(fx_scale),\n        [x_sub]\"r\"(x_sub), [x_add]\"r\"(x_add),\n        [loop_c]\"r\"(loop_c), [x_stride1]\"r\"(x_stride1)\n      : \"memory\", \"hi\", \"lo\"\n    );\n    assert(accum == 0);\n  }\n}", "path": "sumatrapdf/ext/libwebp/src/dsp/rescaler_mips32.c", "commit_date": "2019-10-29 00:00:00", "repo_name": "sumatrapdfreader/sumatrapdf", "stars": 12322, "license": "gpl-3.0", "language": "c", "size": 282658}
{"docstring": "/*\n * Read one row of pixels.\n * Called only after load_image has read the image into the virtual array.\n * Used for GRAYSCALE, MAPPEDGRAY, TRUECOLOR, and DIRECTCOLOR images.\n */\n", "func_signal": "METHODDEF(JDIMENSION)\nget_rle_row (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)", "code": "{\n  rle_source_ptr source = (rle_source_ptr) sinfo;\n\n  source->row--;\n  source->pub.buffer = (*cinfo->mem->access_virt_sarray)\n    ((j_common_ptr) cinfo, source->image, source->row, (JDIMENSION) 1, FALSE);\n\n  return 1;\n}", "path": "sumatrapdf/ext/libjpeg-turbo/rdrle.c", "commit_date": "2010-12-06 00:00:00", "repo_name": "sumatrapdfreader/sumatrapdf", "stars": 12322, "license": "gpl-3.0", "language": "c", "size": 282658}
{"docstring": "//------------------------------------------------------------------------------\n// Main YUV<->RGB conversion functions\n", "func_signal": "static int EmitYUV(const VP8Io* const io, WebPDecParams* const p)", "code": "{\n  WebPDecBuffer* output = p->output;\n  const WebPYUVABuffer* const buf = &output->u.YUVA;\n  uint8_t* const y_dst = buf->y + io->mb_y * buf->y_stride;\n  uint8_t* const u_dst = buf->u + (io->mb_y >> 1) * buf->u_stride;\n  uint8_t* const v_dst = buf->v + (io->mb_y >> 1) * buf->v_stride;\n  const int mb_w = io->mb_w;\n  const int mb_h = io->mb_h;\n  const int uv_w = (mb_w + 1) / 2;\n  const int uv_h = (mb_h + 1) / 2;\n  int j;\n  for (j = 0; j < mb_h; ++j) {\n    memcpy(y_dst + j * buf->y_stride, io->y + j * io->y_stride, mb_w);\n  }\n  for (j = 0; j < uv_h; ++j) {\n    memcpy(u_dst + j * buf->u_stride, io->u + j * io->uv_stride, uv_w);\n    memcpy(v_dst + j * buf->v_stride, io->v + j * io->uv_stride, uv_w);\n  }\n  return io->mb_h;\n}", "path": "sumatrapdf/ext/libwebp/src/dec/io_dec.c", "commit_date": "2019-10-29 00:00:00", "repo_name": "sumatrapdfreader/sumatrapdf", "stars": 12322, "license": "gpl-3.0", "language": "c", "size": 282658}
{"docstring": "/*\n * Parse the fixed document sequence structure and _rels/.rels to find the start part.\n */\n", "func_signal": "static void\nxps_parse_metadata_imp(fz_context *ctx, xps_document *doc, fz_xml *item, xps_fixdoc *fixdoc)", "code": "{\n\twhile (item)\n\t{\n\t\tif (fz_xml_is_tag(item, \"Relationship\"))\n\t\t{\n\t\t\tchar *target = fz_xml_att(item, \"Target\");\n\t\t\tchar *type = fz_xml_att(item, \"Type\");\n\t\t\tif (target && type)\n\t\t\t{\n\t\t\t\tchar tgtbuf[1024];\n\t\t\t\txps_resolve_url(ctx, doc, tgtbuf, doc->base_uri, target, sizeof tgtbuf);\n\t\t\t\tif (!strcmp(type, REL_START_PART) || !strcmp(type, REL_START_PART_OXPS))\n\t\t\t\t{\n\t\t\t\t\tfz_free(ctx, doc->start_part);\n\t\t\t\t\tdoc->start_part = fz_strdup(ctx, tgtbuf);\n\t\t\t\t}\n\t\t\t\tif ((!strcmp(type, REL_DOC_STRUCTURE) || !strcmp(type, REL_DOC_STRUCTURE_OXPS)) && fixdoc)\n\t\t\t\t\tfixdoc->outline = fz_strdup(ctx, tgtbuf);\n\t\t\t\tif (!fz_xml_att(item, \"Id\"))\n\t\t\t\t\tfz_warn(ctx, \"missing relationship id for %s\", target);\n\t\t\t}\n\t\t}\n\n\t\tif (fz_xml_is_tag(item, \"DocumentReference\"))\n\t\t{\n\t\t\tchar *source = fz_xml_att(item, \"Source\");\n\t\t\tif (source)\n\t\t\t{\n\t\t\t\tchar srcbuf[1024];\n\t\t\t\txps_resolve_url(ctx, doc, srcbuf, doc->base_uri, source, sizeof srcbuf);\n\t\t\t\txps_add_fixed_document(ctx, doc, srcbuf);\n\t\t\t}\n\t\t}\n\n\t\tif (fz_xml_is_tag(item, \"PageContent\"))\n\t\t{\n\t\t\tchar *source = fz_xml_att(item, \"Source\");\n\t\t\tchar *width_att = fz_xml_att(item, \"Width\");\n\t\t\tchar *height_att = fz_xml_att(item, \"Height\");\n\t\t\tint width = width_att ? atoi(width_att) : 0;\n\t\t\tint height = height_att ? atoi(height_att) : 0;\n\t\t\tif (source)\n\t\t\t{\n\t\t\t\tchar srcbuf[1024];\n\t\t\t\txps_resolve_url(ctx, doc, srcbuf, doc->base_uri, source, sizeof srcbuf);\n\t\t\t\txps_add_fixed_page(ctx, doc, srcbuf, width, height);\n\t\t\t}\n\t\t}\n\n\t\tif (fz_xml_is_tag(item, \"LinkTarget\"))\n\t\t{\n\t\t\tchar *name = fz_xml_att(item, \"Name\");\n\t\t\tif (name)\n\t\t\t\txps_add_link_target(ctx, doc, name);\n\t\t}\n\n\t\txps_parse_metadata_imp(ctx, doc, fz_xml_down(item), fixdoc);\n\n\t\titem = fz_xml_next(item);\n\t}\n}", "path": "sumatrapdf/mupdf/source/xps/xps-doc.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "sumatrapdfreader/sumatrapdf", "stars": 12322, "license": "gpl-3.0", "language": "c", "size": 282658}
{"docstring": "//schemas.openxps.org/oxps/v1.0/documentstructure\"\n", "func_signal": "static void\nxps_rels_for_part(fz_context *ctx, xps_document *doc, char *buf, char *name, int buflen)", "code": "{\n\tchar *p, *basename;\n\tp = strrchr(name, '/');\n\tbasename = p ? p + 1 : name;\n\tfz_strlcpy(buf, name, buflen);\n\tp = strrchr(buf, '/');\n\tif (p) *p = 0;\n\tfz_strlcat(buf, \"/_rels/\", buflen);\n\tfz_strlcat(buf, basename, buflen);\n\tfz_strlcat(buf, \".rels\", buflen);\n}", "path": "sumatrapdf/mupdf/source/xps/xps-doc.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "sumatrapdfreader/sumatrapdf", "stars": 12322, "license": "gpl-3.0", "language": "c", "size": 282658}
{"docstring": "// Returns true if this Unicode code point is in the list of characters\n// forbidden by the HTML5 spec, such as undefined control chars.\n", "func_signal": "bool utf8_is_invalid_code_point(int c)", "code": "{\n  return (c >= 0x1 && c <= 0x8) || c == 0xB || (c >= 0xE && c <= 0x1F) ||\n         (c >= 0x7F && c <= 0x9F) || (c >= 0xFDD0 && c <= 0xFDEF) ||\n         ((c & 0xFFFF) == 0xFFFE) || ((c & 0xFFFF) == 0xFFFF);\n}", "path": "sumatrapdf/ext/gumbo-parser/src/utf8.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "sumatrapdfreader/sumatrapdf", "stars": 12322, "license": "gpl-3.0", "language": "c", "size": 282658}
{"docstring": "/*\n * The module selection routine for RLE format input.\n */\n", "func_signal": "GLOBAL(cjpeg_source_ptr)\njinit_read_rle (j_compress_ptr cinfo)", "code": "{\n  rle_source_ptr source;\n\n  /* Create module interface object */\n  source = (rle_source_ptr)\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n                                  SIZEOF(rle_source_struct));\n  /* Fill in method ptrs */\n  source->pub.start_input = start_input_rle;\n  source->pub.finish_input = finish_input_rle;\n  source->pub.get_pixel_rows = load_image;\n\n  return (cjpeg_source_ptr) source;\n}", "path": "sumatrapdf/ext/libjpeg-turbo/rdrle.c", "commit_date": "2010-12-06 00:00:00", "repo_name": "sumatrapdfreader/sumatrapdf", "stars": 12322, "license": "gpl-3.0", "language": "c", "size": 282658}
{"docstring": "//------------------------------------------------------------------------------\n// Main entry point\n", "func_signal": "void WebPInitCustomIo(WebPDecParams* const params, VP8Io* const io)", "code": "{\n  io->put      = CustomPut;\n  io->setup    = CustomSetup;\n  io->teardown = CustomTeardown;\n  io->opaque   = params;\n}", "path": "sumatrapdf/ext/libwebp/src/dec/io_dec.c", "commit_date": "2019-10-29 00:00:00", "repo_name": "sumatrapdfreader/sumatrapdf", "stars": 12322, "license": "gpl-3.0", "language": "c", "size": 282658}
{"docstring": "// Reads the next UTF-8 character in the iter.\n// This assumes that iter->_start points to the beginning of the character.\n// When this method returns, iter->_width and iter->_current will be set\n// appropriately, as well as any error flags.\n", "func_signal": "static void read_char(Utf8Iterator* iter)", "code": "{\n  if (iter->_start >= iter->_end) {\n    // No input left to consume; emit an EOF and set width = 0.\n    iter->_current = -1;\n    iter->_width = 0;\n    return;\n  }\n\n  uint32_t code_point = 0;\n  uint32_t state = UTF8_ACCEPT;\n  for (const char* c = iter->_start; c < iter->_end; ++c) {\n    decode(&state, &code_point, (uint32_t)(unsigned char) (*c));\n    if (state == UTF8_ACCEPT) {\n      iter->_width = c - iter->_start + 1;\n      // This is the special handling for carriage returns that is mandated by\n      // the HTML5 spec.  Since we're looking for particular 7-bit literal\n      // characters, we operate in terms of chars and only need a check for iter\n      // overrun, instead of having to read in a full next code point.\n      // http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream\n      if (code_point == '\\r') {\n        assert(iter->_width == 1);\n        const char* next = c + 1;\n        if (next < iter->_end && *next == '\\n') {\n          // Advance the iter, as if the carriage return didn't exist.\n          ++iter->_start;\n          // Preserve the true offset, since other tools that look at it may be\n          // unaware of HTML5's rules for converting \\r into \\n.\n          ++iter->_pos.offset;\n        }\n        code_point = '\\n';\n      }\n      if (utf8_is_invalid_code_point(code_point)) {\n        add_error(iter, GUMBO_ERR_UTF8_INVALID);\n        code_point = kUtf8ReplacementChar;\n      }\n      iter->_current = code_point;\n      return;\n    } else if (state == UTF8_REJECT) {\n      // We don't want to consume the invalid continuation byte of a multi-byte\n      // run, but we do want to skip past an invalid first byte.\n      iter->_width = c - iter->_start + (c == iter->_start);\n      iter->_current = kUtf8ReplacementChar;\n      add_error(iter, GUMBO_ERR_UTF8_INVALID);\n      return;\n    }\n  }\n  // If we got here without exiting early, then we've reached the end of the\n  // iterator.  Add an error for truncated input, set the width to consume the\n  // rest of the iterator, and emit a replacement character.  The next time we\n  // enter this method, it will detect that there's no input to consume and\n  // output an EOF.\n  iter->_current = kUtf8ReplacementChar;\n  iter->_width = iter->_end - iter->_start;\n  add_error(iter, GUMBO_ERR_UTF8_TRUNCATED);\n}", "path": "sumatrapdf/ext/gumbo-parser/src/utf8.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "sumatrapdfreader/sumatrapdf", "stars": 12322, "license": "gpl-3.0", "language": "c", "size": 282658}
{"docstring": "//------------------------------------------------------------------------------\n// Row export\n", "func_signal": "static void ExportRowExpand_MIPS32(WebPRescaler* const wrk)", "code": "{\n  uint8_t* dst = wrk->dst;\n  rescaler_t* irow = wrk->irow;\n  const int x_out_max = wrk->dst_width * wrk->num_channels;\n  const rescaler_t* frow = wrk->frow;\n  int temp0, temp1, temp3, temp4, temp5, loop_end;\n  const int temp2 = (int)wrk->fy_scale;\n  const int temp6 = x_out_max << 2;\n  assert(!WebPRescalerOutputDone(wrk));\n  assert(wrk->y_accum <= 0);\n  assert(wrk->y_expand);\n  assert(wrk->y_sub != 0);\n  if (wrk->y_accum == 0) {\n    __asm__ volatile (\n      \"li       %[temp3],    0x10000                    \\n\\t\"\n      \"li       %[temp4],    0x8000                     \\n\\t\"\n      \"addu     %[loop_end], %[frow],     %[temp6]      \\n\\t\"\n    \"1:                                                 \\n\\t\"\n      \"lw       %[temp0],    0(%[frow])                 \\n\\t\"\n      \"addiu    %[dst],      %[dst],      1             \\n\\t\"\n      \"addiu    %[frow],     %[frow],     4             \\n\\t\"\n      \"mult     %[temp3],    %[temp4]                   \\n\\t\"\n      \"maddu    %[temp0],    %[temp2]                   \\n\\t\"\n      \"mfhi     %[temp5]                                \\n\\t\"\n      \"sb       %[temp5],    -1(%[dst])                 \\n\\t\"\n      \"bne      %[frow],     %[loop_end], 1b            \\n\\t\"\n      : [temp0]\"=&r\"(temp0), [temp1]\"=&r\"(temp1), [temp3]\"=&r\"(temp3),\n        [temp4]\"=&r\"(temp4), [temp5]\"=&r\"(temp5), [frow]\"+r\"(frow),\n        [dst]\"+r\"(dst), [loop_end]\"=&r\"(loop_end)\n      : [temp2]\"r\"(temp2), [temp6]\"r\"(temp6)\n      : \"memory\", \"hi\", \"lo\"\n    );\n  } else {\n    const uint32_t B = WEBP_RESCALER_FRAC(-wrk->y_accum, wrk->y_sub);\n    const uint32_t A = (uint32_t)(WEBP_RESCALER_ONE - B);\n    __asm__ volatile (\n      \"li       %[temp3],    0x10000                    \\n\\t\"\n      \"li       %[temp4],    0x8000                     \\n\\t\"\n      \"addu     %[loop_end], %[frow],     %[temp6]      \\n\\t\"\n    \"1:                                                 \\n\\t\"\n      \"lw       %[temp0],    0(%[frow])                 \\n\\t\"\n      \"lw       %[temp1],    0(%[irow])                 \\n\\t\"\n      \"addiu    %[dst],      %[dst],      1             \\n\\t\"\n      \"mult     %[temp3],    %[temp4]                   \\n\\t\"\n      \"maddu    %[A],        %[temp0]                   \\n\\t\"\n      \"maddu    %[B],        %[temp1]                   \\n\\t\"\n      \"addiu    %[frow],     %[frow],     4             \\n\\t\"\n      \"addiu    %[irow],     %[irow],     4             \\n\\t\"\n      \"mfhi     %[temp5]                                \\n\\t\"\n      \"mult     %[temp3],    %[temp4]                   \\n\\t\"\n      \"maddu    %[temp5],    %[temp2]                   \\n\\t\"\n      \"mfhi     %[temp5]                                \\n\\t\"\n      \"sb       %[temp5],    -1(%[dst])                 \\n\\t\"\n      \"bne      %[frow],     %[loop_end], 1b            \\n\\t\"\n      : [temp0]\"=&r\"(temp0), [temp1]\"=&r\"(temp1), [temp3]\"=&r\"(temp3),\n        [temp4]\"=&r\"(temp4), [temp5]\"=&r\"(temp5), [frow]\"+r\"(frow),\n        [irow]\"+r\"(irow), [dst]\"+r\"(dst), [loop_end]\"=&r\"(loop_end)\n      : [temp2]\"r\"(temp2), [temp6]\"r\"(temp6), [A]\"r\"(A), [B]\"r\"(B)\n      : \"memory\", \"hi\", \"lo\"\n    );\n  }\n}", "path": "sumatrapdf/ext/libwebp/src/dsp/rescaler_mips32.c", "commit_date": "2019-10-29 00:00:00", "repo_name": "sumatrapdfreader/sumatrapdf", "stars": 12322, "license": "gpl-3.0", "language": "c", "size": 282658}
{"docstring": "/**\n * After we sum up all the numbers involved, we must \"fold\" the upper\n * 16-bits back into the lower 16-bits. Since something like 0x1FFFF\n * will fold into 0x10000, we need to call a second fold operation\n * (obtaining 0x0001 in this example). In other words, we need to \n * keep folding until the result is 16-bits, but that never takes\n * more than two folds. After this, we need to take the 1s-complement,\n * which means reversing the bits so that 0 becomes 1 and 1 becomes 0.\n */\n", "func_signal": "static unsigned\n_checksum_finish(unsigned sum)", "code": "{\n    sum = (sum >> 16) + (sum & 0xFFFF);\n    sum = (sum >> 16) + (sum & 0xFFFF);\n    return (~sum) & 0xFFFF;\n}", "path": "masscan/src/util-checksum.c", "commit_date": "2020-06-20 00:00:00", "repo_name": "robertdavidgraham/masscan", "stars": 22386, "license": "agpl-3.0", "language": "c", "size": 4095}
{"docstring": "/***************************************************************************\n * The receive thread doesn't transmit packets. Instead, it queues them\n * up on the transmit thread. Every so often, the transmit thread needs\n * to flush this transmit queue and send everything.\n *\n * This is an inherent design issue trying to send things as batches rather\n * than individually. It increases latency, but increases performance. We\n * don't really care about latency.\n ***************************************************************************/\n", "func_signal": "void\nstack_flush_packets(\n    struct stack_t *stack,\n    struct Adapter *adapter,\n    uint64_t *packets_sent,\n    uint64_t *batchsize)", "code": "{\n    /*\n     * Send a batch of queued packets\n     */\n    for ( ; (*batchsize); (*batchsize)--) {\n        int err;\n        struct PacketBuffer *p;\n\n        /*\n         * Get the next packet from the transmit queue. This packet was\n         * put there by a receive thread, and will contain things like\n         * an ACK or an HTTP request\n         */\n        err = rte_ring_sc_dequeue(stack->transmit_queue, (void**)&p);\n        if (err) {\n            break; /* queue is empty, nothing to send */\n        }\n\n\n        /*\n         * Actually send the packet\n         */\n        rawsock_send_packet(adapter, p->px, (unsigned)p->length, 1);\n\n        /*\n         * Now that we are done with the packet, put it on the free list\n         * of buffers that the transmit thread can reuse\n         */\n        for (err=1; err; ) {\n            err = rte_ring_sp_enqueue(stack->packet_buffers, p);\n            if (err) {\n                fprintf(stderr, \"[-] transmit queue full (should be impossible)\\n\");\n                pixie_usleep(10000);\n            }\n        }\n\n\n        /*\n         * Remember that we sent a packet, which will be used in\n         * throttling.\n         */\n        (*packets_sent)++;\n    }\n\n}", "path": "masscan/src/stack-queue.c", "commit_date": "2020-12-24 00:00:00", "repo_name": "robertdavidgraham/masscan", "stars": 22386, "license": "agpl-3.0", "language": "c", "size": 4095}
{"docstring": "/*****************************************************************************\n * Remove bad characters from the banner, especially new lines and HTML\n * control codes.\n *****************************************************************************/\n", "func_signal": "static const char *\nnormalize_json_string(const unsigned char *px, size_t length,\n                 char *buf, size_t buf_len)", "code": "{\n    size_t i=0;\n    size_t offset = 0;\n\n\n    for (i=0; i<length; i++) {\n        unsigned char c = px[i];\n\n        if (isprint(c) && c != '<' && c != '>' && c != '&' && c != '\\\\' && c != '\\\"' && c != '\\'') {\n            if (offset + 2 < buf_len)\n                buf[offset++] = px[i];\n        } else {\n            if (offset + 7 < buf_len) {\n                buf[offset++] = '\\\\';\n                buf[offset++] = 'u';\n                buf[offset++] = '0';\n                buf[offset++] = '0';\n                buf[offset++] = \"0123456789abcdef\"[px[i]>>4];\n                buf[offset++] = \"0123456789abcdef\"[px[i]&0xF];\n            }\n        }\n    }\n\n    buf[offset] = '\\0';\n\n    return buf;\n}", "path": "masscan/src/out-json.c", "commit_date": "2020-06-20 00:00:00", "repo_name": "robertdavidgraham/masscan", "stars": 22386, "license": "agpl-3.0", "language": "c", "size": 4095}
{"docstring": "/***************************************************************************\n * Some methods of transmit queue multiple packets in a buffer then\n * send all queued packets at once. At the end of a scan, we might have\n * some pending packets that haven't been transmitted yet. Therefore,\n * we'll have to flush them.\n ***************************************************************************/\n", "func_signal": "void\nrawsock_flush(struct Adapter *adapter)", "code": "{\n    if (adapter->sendq) {\n        PCAP.sendqueue_transmit(adapter->pcap, adapter->sendq, 0);\n\n        /* Dude, I totally forget why this step is necessary. I vaguely\n         * remember there's a good reason for it though */\n        PCAP.sendqueue_destroy(adapter->sendq);\n        adapter->sendq =  PCAP.sendqueue_alloc(SENDQ_SIZE);\n    }\n\n}", "path": "masscan/src/rawsock.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "robertdavidgraham/masscan", "stars": 22386, "license": "agpl-3.0", "language": "c", "size": 4095}
{"docstring": "/***************************************************************************\n * Checksum the IP header. This is a \"partial\" checksum, so we\n * don't reverse the bits ~.\n ***************************************************************************/\n", "func_signal": "static unsigned\nip_header_checksum(const unsigned char *px, unsigned offset, unsigned max_offset)", "code": "{\n    unsigned header_length = (px[offset]&0xF) * 4;\n    unsigned xsum = 0;\n    unsigned i;\n\n    /* restrict check only over packet */\n    if (max_offset > offset + header_length)\n        max_offset = offset + header_length;\n\n    /* add all the two-byte words together */\n    xsum = 0;\n    for (i = offset; i < max_offset; i += 2) {\n        xsum += px[i]<<8 | px[i+1];\n    }\n\n    /* if more than 16 bits in result, reduce to 16 bits */\n    xsum = (xsum & 0xFFFF) + (xsum >> 16);\n    xsum = (xsum & 0xFFFF) + (xsum >> 16);\n    xsum = (xsum & 0xFFFF) + (xsum >> 16);\n\n    return xsum;\n}", "path": "masscan/src/templ-pkt.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "robertdavidgraham/masscan", "stars": 22386, "license": "agpl-3.0", "language": "c", "size": 4095}
{"docstring": "/*****************************************************************************\n * Handles an NTP response.\n *****************************************************************************/\n", "func_signal": "unsigned\nntp_handle_response(struct Output *out, time_t timestamp,\n            const unsigned char *px, unsigned length,\n            struct PreprocessedInfo *parsed,\n            uint64_t entropy\n            )", "code": "{\n    ipaddress ip_them = parsed->src_ip;\n    unsigned request_id = 0;\n    struct BannerOutput banout[1];\n    unsigned offset = parsed->app_offset;\n    \n    UNUSEDPARM(length);\n    UNUSEDPARM(entropy);\n    \n    if (parsed->app_length < 4)\n        return 0;\n    \n    /* Initialize the \"banner output\" module that we'll use to print\n     * pretty text in place of the raw packet */\n    banout_init(banout);\n    \n    /* Parse the packet */\n    switch ((px[offset]>>3)&7) {\n        case 2:\n            ntp_v2_parse(\n               px + parsed->app_offset,    /* incoming  response */\n               parsed->app_length,         /* length of  response */\n               banout,                     /* banner printing */\n               &request_id);               /* syn-cookie info */\n            break;\n        default:\n            banout_release(banout);\n            return 0;\n    }\n    \n    /* Validate the \"syn-cookie\" style information. */\n    //seqno = (unsigned)syn_cookie(ip_them, port_them | Templ_UDP, ip_me, port_me);\n    //if ((seqno&0x7FFFffff) != request_id)\n    //    return 1;\n    \n    /* Print the banner information, or save to a file, depending */\n    output_report_banner(\n                         out, timestamp,\n                         ip_them, 17, parsed->port_src,\n                         PROTO_NTP,\n                         parsed->ip_ttl,\n                         banout_string(banout, PROTO_NTP),\n                         banout_string_length(banout, PROTO_NTP));\n    \n    /* Free memory for the banner, if there was any allocated */\n    banout_release(banout);\n    \n    return 0;\n}", "path": "masscan/src/proto-ntp.c", "commit_date": "2020-06-20 00:00:00", "repo_name": "robertdavidgraham/masscan", "stars": 22386, "license": "agpl-3.0", "language": "c", "size": 4095}
{"docstring": "/***************************************************************************\n * Configure the socket to not capture transmitted packets. This is needed\n * because we transmit packets at a rate of millions per second, which will\n * overwhelm the receive thread.\n *\n * PORTABILITY: Windows doesn't seem to support this feature, so instead\n * what we do is apply a BPF filter to ignore the transmits, so that they\n * still get filtered at a low level.\n ***************************************************************************/\n", "func_signal": "void\nrawsock_ignore_transmits(struct Adapter *adapter, const unsigned char *adapter_mac, const char *ifname)", "code": "{\n    UNUSEDPARM(adapter_mac);\n    if (adapter->ring) {\n        /* PORTABILITY: don't do anything for PF_RING, because it's\n         * actually done when we create the adapter, because we can't\n         * reconfigure the adapter after it's been activated. */\n        return;\n    }\n\n    if (adapter->pcap) {\n        int err;\n        err = PCAP.setdirection(adapter->pcap, PCAP_D_IN);\n        if (err) {\n            ; //PCAP.perror(adapter->pcap, \"if: pcap_setdirection(IN)\");\n        } else {\n            LOG(2, \"if:%s: not receiving transmits\\n\", ifname);\n        }\n    }\n}", "path": "masscan/src/rawsock.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "robertdavidgraham/masscan", "stars": 22386, "license": "agpl-3.0", "language": "c", "size": 4095}
{"docstring": "/***************************************************************************\n * Used on Windows: if the adpter name is a numeric index, convert it to\n * the full name.\n ***************************************************************************/\n", "func_signal": "const char *\nrawsock_win_name(const char *ifname)", "code": "{\n    if (is_numeric_index(ifname)) {\n        const char *new_adapter_name;\n\n        new_adapter_name = adapter_from_index(atoi(ifname));\n        if (new_adapter_name)\n            return new_adapter_name;\n    }\n\n    return ifname;\n}", "path": "masscan/src/rawsock.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "robertdavidgraham/masscan", "stars": 22386, "license": "agpl-3.0", "language": "c", "size": 4095}
{"docstring": "/***************************************************************************\n * Does the name look like a PF_RING DNA adapter? Common names are:\n * dna0\n * dna1\n * dna0@1\n *\n ***************************************************************************/\n", "func_signal": "static int\nis_pfring_dna(const char *name)", "code": "{\n    if (strlen(name) < 4)\n        return 0;\n    if (memcmp(name, \"zc:\", 3) == 0)\n        return 1;\n    if (memcmp(name, \"dna\", 3) != 0)\n        return 0;\n\n    name +=3;\n\n    if (!isdigit(name[0]&0xFF))\n        return 0;\n    while (isdigit(name[0]&0xFF))\n        name++;\n\n    if (name[0] == '\\0')\n        return 1;\n\n    if (name[0] != '@')\n        return 0;\n    else\n        name++;\n\n    if (!isdigit(name[0]&0xFF))\n        return 0;\n    while (isdigit(name[0]&0xFF))\n        name++;\n\n    if (name[0] == '\\0')\n        return 1;\n    else\n        return 0;\n}", "path": "masscan/src/rawsock.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "robertdavidgraham/masscan", "stars": 22386, "license": "agpl-3.0", "language": "c", "size": 4095}
{"docstring": "/***************************************************************************\n * Runs some tests when the \"--debug if\" option is given on the\n * command-line. This is useful to figure out why the interface you\n * are accessing doesn't work.\n ***************************************************************************/\n", "func_signal": "int\nrawsock_selftest_if(const char *ifname)", "code": "{\n    int err;\n    unsigned ipv4 = 0;\n    ipv6address ipv6;\n    unsigned router_ipv4 = 0;\n    unsigned char mac[6] = {0,0,0,0,0,0};\n    struct Adapter *adapter;\n    char ifname2[246];\n\n    if (ifname == NULL || ifname[0] == 0) {\n        err = rawsock_get_default_interface(ifname2, sizeof(ifname2));\n        if (err) {\n            fprintf(stderr, \"get-default-if: returned err %d\\n\", err);\n            return -1;\n        }\n        ifname = ifname2;\n    }\n\n    /* Name */\n    printf(\"if = %s\\n\", ifname);\n\n    /* IPv4 address */\n    ipv4 = rawsock_get_adapter_ip(ifname);\n    if (ipv4 == 0) {\n        fprintf(stderr, \"get-ip: returned err\\n\");\n    } else {\n        printf(\"ip = %u.%u.%u.%u\\n\",\n            (unsigned char)(ipv4>>24),\n            (unsigned char)(ipv4>>16),\n            (unsigned char)(ipv4>>8),\n            (unsigned char)(ipv4>>0));\n    }\n\n    /* IPv6 address */\n    ipv6 = rawsock_get_adapter_ipv6(ifname);\n    if (ipv6address_is_zero(ipv6)) {\n       LOG(0, \"ipv6 = [::]\\n\");\n    } else {\n       LOG(0, \"ipv6 = [%s]\\n\", ipv6address_fmt(ipv6).string);\n    }\n\n    /* MAC address */\n    err = rawsock_get_adapter_mac(ifname, mac);\n    if (err) {\n        fprintf(stderr, \"get-adapter-mac: returned err=%d\\n\", err);\n    } else {\n        printf(\"mac = %02x-%02x-%02x-%02x-%02x-%02x\\n\",\n            mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n    }\n\n    /* Gateway IP */\n    err = rawsock_get_default_gateway(ifname, &router_ipv4);\n    if (err) {\n        fprintf(stderr, \"get-default-gateway: returned err=%d\\n\", err);\n    } else {\n        unsigned char router_mac[6];\n\n        printf(\"gateway = %u.%u.%u.%u\\n\",\n            (unsigned char)(router_ipv4>>24),\n            (unsigned char)(router_ipv4>>16),\n            (unsigned char)(router_ipv4>>8),\n            (unsigned char)(router_ipv4>>0));\n\n\n        adapter = rawsock_init_adapter(ifname, 0, 0, 0, 0, 0, 0, 0);\n        if (adapter == 0) {\n            LOG(1, \"if:%s: failed\\n\", ifname);\n            return -1;\n        } else {\n            printf(\"pcap = opened\\n\");\n        }\n\n        memset(router_mac, 0, 6);\n        arp_resolve_sync(\n                adapter,\n                ipv4,\n                mac,\n                router_ipv4,\n                router_mac);\n\n        if (memcmp(router_mac, \"\\0\\0\\0\\0\\0\\0\", 6) != 0) {\n            printf(\"gateway = %02x-%02x-%02x-%02x-%02x-%02x\\n\",\n                router_mac[0],\n                router_mac[1],\n                router_mac[2],\n                router_mac[3],\n                router_mac[4],\n                router_mac[5]\n            );\n        } else {\n            printf(\"gateway = [failed to ARP address]\\n\");\n        }\n        rawsock_close_adapter(adapter);\n    }\n\n    return 0;\n}", "path": "masscan/src/rawsock.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "robertdavidgraham/masscan", "stars": 22386, "license": "agpl-3.0", "language": "c", "size": 4095}
{"docstring": "/***************************************************************************\n  * This function prints to the command line a list of all the network\n  * intefaces/devices.\n ***************************************************************************/\n", "func_signal": "void\nrawsock_list_adapters(void)", "code": "{\n    pcap_if_t *alldevs;\n    char errbuf[PCAP_ERRBUF_SIZE];\n    \n    if (PCAP.findalldevs(&alldevs, errbuf) != -1) {\n        int i;\n        const pcap_if_t *d;\n        i=0;\n        \n        if (alldevs == NULL) {\n            fprintf(stderr, \"ERR:libpcap: no adapters found, are you sure you are root?\\n\");\n        }\n        /* Print the list */\n        for(d=alldevs; d; d=PCAP.dev_next(d)) {\n            fprintf(stderr, \" %d  %s \\t\", i++, PCAP.dev_name(d));\n            if (PCAP.dev_description(d))\n                fprintf(stderr, \"(%s)\\n\", PCAP.dev_description(d));\n            else\n                fprintf(stderr, \"(No description available)\\n\");\n        }\n        fprintf(stderr,\"\\n\");\n        PCAP.freealldevs(alldevs);\n    } else {\n        fprintf(stderr, \"%s\\n\", errbuf);\n    }\n}", "path": "masscan/src/rawsock.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "robertdavidgraham/masscan", "stars": 22386, "license": "agpl-3.0", "language": "c", "size": 4095}
{"docstring": "/****************************************************************************\n * Prints out \"banner\" information for a port. This is done when there is\n * a protocol defined for a port, and we do some interaction to find out\n * more information about which protocol is running on a port, it's version,\n * and other useful information.\n ****************************************************************************/\n", "func_signal": "static void\nnull_out_banner(struct Output *out, FILE *fp, time_t timestamp,\n        ipaddress ip, unsigned ip_proto, unsigned port,\n        enum ApplicationProtocol proto, unsigned ttl,\n        const unsigned char *px, unsigned length)", "code": "{\n    UNUSEDPARM(ttl);\n    UNUSEDPARM(timestamp);\n    UNUSEDPARM(out);\n    UNUSEDPARM(fp);\n    UNUSEDPARM(ip);\n    UNUSEDPARM(ip_proto);\n    UNUSEDPARM(port);\n    UNUSEDPARM(proto);\n    UNUSEDPARM(px);\n    UNUSEDPARM(length);\n\n}", "path": "masscan/src/out-null.c", "commit_date": "2020-06-20 00:00:00", "repo_name": "robertdavidgraham/masscan", "stars": 22386, "license": "agpl-3.0", "language": "c", "size": 4095}
{"docstring": "/***************************************************************************\n * Here we take a packet template, parse it, then make it easier to work\n * with.\n ***************************************************************************/\n", "func_signal": "static void\n_template_init(\n    struct TemplatePacket *tmpl,\n    const unsigned char *mac_source,\n    const unsigned char *mac_dest,\n    const void *packet_bytes,\n    size_t packet_size,\n    unsigned data_link\n    )", "code": "{\n    unsigned char *px;\n    struct PreprocessedInfo parsed;\n    unsigned x;\n\n    /*\n     * Create the new template structure:\n     * - zero it out\n     * - make copy of the old packet to serve as new template\n     */\n    memset(tmpl, 0, sizeof(*tmpl));\n    tmpl->ipv4.length = (unsigned)packet_size;\n\n    tmpl->ipv4.packet = MALLOC(2048 + packet_size);\n    memcpy(tmpl->ipv4.packet, packet_bytes, tmpl->ipv4.length);\n    px = tmpl->ipv4.packet;\n\n    /*\n     * Parse the existing packet template. We support TCP, UDP, ICMP,\n     * and ARP packets.\n     */\n    x = preprocess_frame(px, tmpl->ipv4.length, 1 /*enet*/, &parsed);\n    if (!x || parsed.found == FOUND_NOTHING) {\n        LOG(0, \"ERROR: bad packet template\\n\");\n        exit(1);\n    }\n    tmpl->ipv4.offset_ip = parsed.ip_offset;\n    tmpl->ipv4.offset_tcp = parsed.transport_offset;\n    tmpl->ipv4.offset_app = parsed.app_offset;\n    if (parsed.found == FOUND_ARP) {\n        tmpl->ipv4.length = parsed.ip_offset + 28;\n    } else\n        tmpl->ipv4.length = parsed.ip_offset + parsed.ip_length;\n\n    /*\n     * Overwrite the MAC and IP addresses\n     */\n    memcpy(px+0, mac_dest, 6);\n    memcpy(px+6, mac_source, 6);\n    memset((void*)parsed._ip_src, 0, 4);\n    memset((void*)parsed._ip_dst, 0, 4);\n\n\n    /*\n     * ARP\n     *\n     * If this is an ARP template (for doing arpscans), then just set our\n     * configured source IP and MAC addresses.\n     */\n    if (parsed.found == FOUND_ARP) {\n        memcpy((char*)parsed._ip_src - 6, mac_source, 6);\n        tmpl->proto = Proto_ARP;\n        return;\n    }\n\n    /*\n     * IPv4\n     *\n     * Calculate the partial checksum. We zero out the fields that will be\n     * added later the packet, then calculate the checksum as if they were\n     * zero. This makes recalculation of the checksum easier when we transmit\n     */\n    memset(px + tmpl->ipv4.offset_ip + 4, 0, 2);  /* IP ID field */\n    memset(px + tmpl->ipv4.offset_ip + 10, 0, 2); /* checksum */\n    memset(px + tmpl->ipv4.offset_ip + 12, 0, 8); /* addresses */\n    tmpl->ipv4.checksum_ip = ip_header_checksum( tmpl->ipv4.packet,\n                                            tmpl->ipv4.offset_ip,\n                                            tmpl->ipv4.length);\n\n    /*\n     * Higher layer protocols: zero out dest/checksum fields, then calculate\n     * a partial checksum\n     */\n    switch (parsed.ip_protocol) {\n    case 1: /* ICMP */\n            tmpl->ipv4.offset_app = tmpl->ipv4.length;\n            tmpl->ipv4.checksum_tcp = icmp_ipv4_checksum(tmpl);\n            switch (px[tmpl->ipv4.offset_tcp]) {\n                case 8:\n                    tmpl->proto = Proto_ICMP_ping;\n                    break;\n                case 13:\n                    tmpl->proto = Proto_ICMP_timestamp;\n                    break;\n            }\n            break;\n        break;\n    case 6: /* TCP */\n        /* zero out fields that'll be overwritten */\n        memset(px + tmpl->ipv4.offset_tcp + 0, 0, 8); /* destination port and seqno */\n        memset(px + tmpl->ipv4.offset_tcp + 16, 0, 2); /* checksum */\n        tmpl->ipv4.checksum_tcp = tcp_ipv4_checksum(tmpl);\n        tmpl->proto = Proto_TCP;\n        break;\n    case 17: /* UDP */\n        memset(px + tmpl->ipv4.offset_tcp + 6, 0, 2); /* checksum */\n        tmpl->ipv4.checksum_tcp = udp_ipv4_checksum(tmpl);\n        tmpl->proto = Proto_UDP;\n        break;\n    case 132: /* SCTP */\n        tmpl->ipv4.checksum_tcp = sctp_checksum(\n                                    tmpl->ipv4.packet + tmpl->ipv4.offset_tcp,\n                                    tmpl->ipv4.length - tmpl->ipv4.offset_tcp);\n        tmpl->proto = Proto_SCTP;\n        break;\n    }\n\n    /*\n     * DATALINK KLUDGE\n     *\n     * Adjust the data link header in case of Raw IP packets. This isn't\n     * the correct way to do this, but I'm too lazy to refactor code\n     * for the right way, so we'll do it this way now.\n     */\n    if (data_link == 12 /* Raw IP */) {\n        tmpl->ipv4.length -= tmpl->ipv4.offset_ip;\n        tmpl->ipv4.offset_tcp -= tmpl->ipv4.offset_ip;\n        tmpl->ipv4.offset_app -= tmpl->ipv4.offset_ip;\n        memmove(tmpl->ipv4.packet,\n                tmpl->ipv4.packet + tmpl->ipv4.offset_ip,\n                tmpl->ipv4.length);\n        tmpl->ipv4.offset_ip = 0;\n    }\n\n    /* Now create an IPv6 template based upon the IPv4 template */\n    _template_init_ipv6(tmpl);\n\n}", "path": "masscan/src/templ-pkt.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "robertdavidgraham/masscan", "stars": 22386, "license": "agpl-3.0", "language": "c", "size": 4095}
{"docstring": "/**\n * Calculates the checksum over a buffer.\n * @param checksum\n *      The value of the pseudo-header checksum that this sum will be\n *      added to. This value must be calculated separately. This\n *      is the original value in 2s-complement. In other words,\n *      for TCP, which will be the integer value of the \n *      IP addresses, protocol number, and length field added together.\n * @param buf\n *      The buffer that we are checksumming, such as all the\n *      payload after an IPv4 or IPv6 header.\n */\n", "func_signal": "static unsigned\n_checksum_calculate(const void *vbuf, size_t length)", "code": "{\n    unsigned sum = 0;\n    size_t i;\n    const unsigned char *buf = (const unsigned char *)vbuf;\n    int is_remainder;\n\n    /* If there is an odd number of bytes, then we handle the \n     * last byte in a custom manner. */\n    is_remainder = (length & 1);\n    length &= (~1);\n\n    /* Sum up all the 16-bit words in the packet */\n    for (i=0; i<length; i += 2) {\n        sum += buf[i]<<8 | buf[i+1];\n    }\n\n    /* If there is an odd number of bytes, then add the last\n     * byte to the sum, in big-endian format as if there was\n     * an additional trailing byte of zero. */\n    if (is_remainder)\n        sum += buf[length]<<8;\n\n    /* Return the raw checksum. Note that this hasn't been\n     * truncated to 16-bits yet or had the bits reversed. */\n    return sum;\n}", "path": "masscan/src/util-checksum.c", "commit_date": "2020-06-20 00:00:00", "repo_name": "robertdavidgraham/masscan", "stars": 22386, "license": "agpl-3.0", "language": "c", "size": 4095}
{"docstring": "/***************************************************************************\n * Overwrites the TTL of the packet\n ***************************************************************************/\n", "func_signal": "void\ntemplate_set_ttl(struct TemplateSet *tmplset, unsigned ttl)", "code": "{\n    unsigned i;\n\n    for (i=0; i<tmplset->count; i++) {\n        struct TemplatePacket *tmpl = &tmplset->pkts[i];\n        unsigned char *px = tmpl->ipv4.packet;\n        unsigned offset = tmpl->ipv4.offset_ip;\n\n        px[offset+8] = (unsigned char)(ttl);\n        tmpl->ipv4.checksum_ip = ip_header_checksum(    tmpl->ipv4.packet,\n                                                    tmpl->ipv4.offset_ip,\n                                                    tmpl->ipv4.length);\n    }\n}", "path": "masscan/src/templ-pkt.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "robertdavidgraham/masscan", "stars": 22386, "license": "agpl-3.0", "language": "c", "size": 4095}
{"docstring": "/****************************************************************************\n * This function doesn't really \"close\" the file. Instead, it's purpose\n * is to print trailing information to the file. This is pretty much only\n * a concern for XML files that need stuff appeneded to the end.\n ****************************************************************************/\n", "func_signal": "static void\nnull_out_close(struct Output *out, FILE *fp)", "code": "{\n    UNUSEDPARM(out);\n    UNUSEDPARM(fp);\n}", "path": "masscan/src/out-null.c", "commit_date": "2020-06-20 00:00:00", "repo_name": "robertdavidgraham/masscan", "stars": 22386, "license": "agpl-3.0", "language": "c", "size": 4095}
{"docstring": "/****************************************************************************\n * Prints out the status of a port, which is almost always just \"open\"\n * or \"closed\".\n ****************************************************************************/\n", "func_signal": "static void\nnull_out_status(struct Output *out, FILE *fp, time_t timestamp,\n    int status, ipaddress ip, unsigned ip_proto, unsigned port, unsigned reason, unsigned ttl)", "code": "{\n    UNUSEDPARM(timestamp);\n    UNUSEDPARM(out);\n    UNUSEDPARM(fp);\n    UNUSEDPARM(status);\n    UNUSEDPARM(ip_proto);\n    UNUSEDPARM(ip);\n    UNUSEDPARM(port);\n    UNUSEDPARM(reason);\n    UNUSEDPARM(ttl);\n\n}", "path": "masscan/src/out-null.c", "commit_date": "2020-06-20 00:00:00", "repo_name": "robertdavidgraham/masscan", "stars": 22386, "license": "agpl-3.0", "language": "c", "size": 4095}
{"docstring": "/****************************************************************************\n * This function doesn't really \"open\" the file. Instead, the purpose of\n * this function is to initialize the file by printing header information.\n ****************************************************************************/\n", "func_signal": "static void\nnull_out_open(struct Output *out, FILE *fp)", "code": "{\n    UNUSEDPARM(out);\n    UNUSEDPARM(fp);\n}", "path": "masscan/src/out-null.c", "commit_date": "2020-06-20 00:00:00", "repo_name": "robertdavidgraham/masscan", "stars": 22386, "license": "agpl-3.0", "language": "c", "size": 4095}
{"docstring": "/*****************************************************************************\n * Translate string name into enumerated type\n *****************************************************************************/\n", "func_signal": "static enum SvcP_RecordType\nparse_type(const char *line, size_t *r_offset, size_t line_length)", "code": "{\n    static const struct {\n        const char *name;\n        size_t length;\n        enum SvcP_RecordType type;\n    } name_to_types[] = {\n        {\"exclude\",      7, SvcP_Exclude},\n        {\"probe\",        5, SvcP_Probe},\n        {\"match\",        5, SvcP_Match},\n        {\"softmatch\",    9, SvcP_Softmatch},\n        {\"ports\",        5, SvcP_Ports},\n        {\"sslports\",     8, SvcP_Sslports},\n        {\"totalwaitms\", 11, SvcP_Totalwaitms},\n        {\"tcpwrappedms\",12, SvcP_Tcpwrappedms},\n        {\"rarity\",       6, SvcP_Rarity},\n        {\"fallback\",     8, SvcP_Fallback},\n        {0, SvcP_Unknown}\n    };\n\n    size_t i;\n    size_t offset = *r_offset;\n    size_t name_length;\n    size_t name_offset;\n    enum SvcP_RecordType result;\n    \n    /* find length of command name */\n    name_offset = offset;\n    while (offset < line_length && !isspace(line[offset]))\n        offset++; /* name = all non-space chars until first space */\n    name_length = offset - name_offset;\n    while (offset < line_length && isspace(line[offset]))\n        offset++; /* trim whitespace after name */\n    *r_offset = offset;\n    \n    /* Lookup the command name */\n    for (i=0; name_to_types[i].name; i++) {\n        if (name_length != name_to_types[i].length)\n            continue;\n        if (strncasecmp(line+name_offset, name_to_types[i].name, name_length) == 0) {\n            break;\n        }\n    }\n    result = name_to_types[i].type;\n    \n    /* return the type */\n    return result;\n}", "path": "masscan/src/read-service-probes.c", "commit_date": "2019-04-22 00:00:00", "repo_name": "robertdavidgraham/masscan", "stars": 22386, "license": "agpl-3.0", "language": "c", "size": 4095}
{"docstring": "/***************************************************************************\n * Used on Windows: network adapters have horrible names, so therefore we\n * use numeric indexes instead. You can which adapter you are looking for\n * by typing \"--iflist\" as an option.\n ***************************************************************************/\n", "func_signal": "static int\nis_numeric_index(const char *ifname)", "code": "{\n    int result = 1;\n    int i;\n\n    /* emptry strings aren't numbers */\n    if (ifname[0] == '\\0')\n        return 0;\n\n    /* 'true' if all digits */\n    for (i=0; ifname[i]; i++) {\n        char c = ifname[i];\n\n        if (c < '0' || '9' < c)\n            result = 0;\n    }\n\n    return result;\n}", "path": "masscan/src/rawsock.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "robertdavidgraham/masscan", "stars": 22386, "license": "agpl-3.0", "language": "c", "size": 4095}
{"docstring": "/*\n\t========================================================================\n\t\n\tRoutine Description:\n\t\tGenerate random number by software.\n\n\tArguments:\n\t\tpAd\t\t-\tpointer to our pAdapter context \n\t\tmacAddr\t-\tpointer to local MAC address\n\t\t\n\tReturn Value:\n\n\tNote:\n\t\t802.1ii-2004  Annex H.5\n\t\t\n\t========================================================================\n*/\n", "func_signal": "VOID\tGenRandom(\n\tIN\tPRTMP_ADAPTER\tpAd, \n\tIN\tUCHAR\t\t\t*macAddr,\n\tOUT\tUCHAR\t\t\t*random)", "code": "{\t\n\tINT\t\ti, curr;\n\tUCHAR\tlocal[80], KeyCounter[32];\n\tUCHAR\tresult[80];\n\tULONG\tCurrentTime;\n\tUCHAR\tprefix[] = {'I', 'n', 'i', 't', ' ', 'C', 'o', 'u', 'n', 't', 'e', 'r'};\n\n\t/* Zero the related information*/\n\tNdisZeroMemory(result, 80);\n\tNdisZeroMemory(local, 80);\n\tNdisZeroMemory(KeyCounter, 32);\t\n\n\tfor\t(i = 0;\ti <\t32;\ti++)\n\t{\t\t\n\t\t/* copy the local MAC address*/\n\t\tCOPY_MAC_ADDR(local, macAddr);\n\t\tcurr =\tMAC_ADDR_LEN;\n\n\t\t/* concatenate the current time*/\n\t\tNdisGetSystemUpTime(&CurrentTime);\n\t\tNdisMoveMemory(&local[curr],  &CurrentTime,\tsizeof(CurrentTime));\n\t\tcurr +=\tsizeof(CurrentTime);\n\n\t\t/* concatenate the last result*/\n\t\tNdisMoveMemory(&local[curr],  result, 32);\n\t\tcurr +=\t32;\n\t\t\n\t\t/* concatenate a variable */\n\t\tNdisMoveMemory(&local[curr],  &i,  2);\t\t\n\t\tcurr +=\t2;\n\n\t\t/* calculate the result*/\n\t\tPRF(KeyCounter, 32, prefix,12, local, curr, result, 32); \n\t}\n\t\n\tNdisMoveMemory(random, result,\t32);\t\n}", "path": "lede/package/lean/mt/drivers/mt7612e/src/mt76x2/common/cmm_wpa.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "coolsnowwolf/lede", "stars": 28402, "license": "other", "language": "c", "size": 286238}
{"docstring": "/*\n\t========================================================================\n\t\n\tRoutine Description:\n\t\tBuild cipher suite in RSN-IE. \n\t\tIt only shall be called by RTMPMakeRSNIE. \n\n\tArguments:\n\t\tpAd\t\t\t-\tpointer to our pAdapter context\t\n    \tElementID\t-\tindicate the WPA1 or WPA2\n    \tWepStatus\t-\tindicate the encryption type\n\t\tbMixCipher\t-\ta boolean to indicate the pairwise cipher and group \n\t\t\t\t\t\tcipher are the same or not\n\t\t\n\tReturn Value:\n\t\t\n\tNote:\n\t\t\n\t========================================================================\n*/\n", "func_signal": "static VOID RTMPMakeRsnIeCipher(\n\tIN  PRTMP_ADAPTER   pAd,\n\tIN\tUCHAR\t\t\tElementID,\t\n\tIN\tUINT\t\t\tWepStatus,\n\tIN\tUCHAR\t\t\tapidx,\n\tIN\tBOOLEAN\t\t\tbMixCipher,\n\tIN\tUCHAR\t\t\tFlexibleCipher,\n\tOUT\tPUCHAR\t\t\tpRsnIe,\n\tOUT\tUCHAR\t\t\t*rsn_len)", "code": "{\t\t\n\tUCHAR\tPairwiseCnt;\n\n\t*rsn_len = 0;\n\n\t/* decide WPA2 or WPA1\t*/\n\tif (ElementID == Wpa2Ie)\n\t{\n\t\tRSNIE2\t*pRsnie_cipher = (RSNIE2*)pRsnIe;\n\n\t\t/* Assign the verson as 1*/\n\t\tpRsnie_cipher->version = 1;\n\n        switch (WepStatus)\n        {\n        \t/* TKIP mode*/\n            case Ndis802_11TKIPEnable:\n                NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA2_TKIP, 4);\n                pRsnie_cipher->ucount = 1;\n                NdisMoveMemory(pRsnie_cipher->ucast[0].oui, OUI_WPA2_TKIP, 4);\n                *rsn_len = sizeof(RSNIE2);\n                break;\n\n\t\t\t/* AES mode*/\n            case Ndis802_11AESEnable:\n\t\t\t\tif (bMixCipher)\n\t\t\t\t\tNdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA2_TKIP, 4);\n\t\t\t\telse\n\t\t\t\t\tNdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA2_CCMP, 4);\t\t\t\t\t\t\t\t\n                pRsnie_cipher->ucount = 1;\n                NdisMoveMemory(pRsnie_cipher->ucast[0].oui, OUI_WPA2_CCMP, 4);\n                *rsn_len = sizeof(RSNIE2);\n                break;\n\n\t\t\t/* TKIP-AES mix mode*/\n            case Ndis802_11TKIPAESMix:\n                NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA2_TKIP, 4);\n\n\t\t\t\tPairwiseCnt = 1;\n\t\t\t\t/* Insert WPA2 TKIP as the first pairwise cipher */\n\t\t\t\tif (MIX_CIPHER_WPA2_TKIP_ON(FlexibleCipher))\n\t\t\t\t{\n                \tNdisMoveMemory(pRsnie_cipher->ucast[0].oui, OUI_WPA2_TKIP, 4);\n\t\t\t\t\t/* Insert WPA2 AES as the secondary pairwise cipher*/\n\t\t\t\t\tif (MIX_CIPHER_WPA2_AES_ON(FlexibleCipher))\n\t\t\t\t\t{\n\t\t\t\t\t\tNdisMoveMemory(pRsnIe + sizeof(RSNIE2), OUI_WPA2_CCMP, 4);\n\t\t\t\t\t\tPairwiseCnt = 2;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* Insert WPA2 AES as the first pairwise cipher */\n\t\t\t\t\tNdisMoveMemory(pRsnie_cipher->ucast[0].oui, OUI_WPA2_CCMP, 4);\t\n\t\t\t\t}\n\t\t\t\t\t\t\t\n                pRsnie_cipher->ucount = PairwiseCnt;\t\t\t\t\n                *rsn_len = sizeof(RSNIE2) + (4 * (PairwiseCnt - 1));\n                break;\t\t\t\n        }   \n\n#ifdef CONFIG_STA_SUPPORT\n\t\tif ((pAd->OpMode == OPMODE_STA) &&\n\t\t\t(pAd->StaCfg.GroupCipher != Ndis802_11TKIPEnable) &&\n\t\t\t(pAd->StaCfg.GroupCipher != Ndis802_11AESEnable)\n\t\t\t)\n\t\t{\n\t\t\tUINT\tGroupCipher = pAd->StaCfg.GroupCipher;\n\t\t\tswitch(GroupCipher)\n\t\t\t{\n\t\t\t\tcase Ndis802_11GroupWEP40Enabled:\n\t\t\t\t\tNdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA2_WEP40, 4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Ndis802_11GroupWEP104Enabled:\n\t\t\t\t\tNdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA2_WEP104, 4);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif /* CONFIG_STA_SUPPORT */\n\n\t\t/* swap for big-endian platform*/\n\t\tpRsnie_cipher->version = cpu2le16(pRsnie_cipher->version);\n\t    pRsnie_cipher->ucount = cpu2le16(pRsnie_cipher->ucount);\n\t}\n\telse\n\t{\n\t\tRSNIE\t*pRsnie_cipher = (RSNIE*)pRsnIe;\n\n\t\t/* Assign OUI and version*/\n\t\tNdisMoveMemory(pRsnie_cipher->oui, OUI_WPA_VERSION, 4);\n        pRsnie_cipher->version = 1;\n\n\t\tswitch (WepStatus)\n\t\t{\n\t\t\t/* TKIP mode*/\n            case Ndis802_11TKIPEnable:\n                NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA_TKIP, 4);\n                pRsnie_cipher->ucount = 1;\n                NdisMoveMemory(pRsnie_cipher->ucast[0].oui, OUI_WPA_TKIP, 4);\n                *rsn_len = sizeof(RSNIE);\n                break;\n\n\t\t\t/* AES mode*/\n            case Ndis802_11AESEnable:\t\t\t\t\n\t\t\t\tif (bMixCipher)\n\t\t\t\t\tNdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA_TKIP, 4);\n\t\t\t\telse\n\t\t\t\t\tNdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA_CCMP, 4);\t\t\t\n                pRsnie_cipher->ucount = 1;\n                NdisMoveMemory(pRsnie_cipher->ucast[0].oui, OUI_WPA_CCMP, 4);\n                *rsn_len = sizeof(RSNIE);\n                break;\n\n\t\t\t/* TKIP-AES mix mode*/\n            case Ndis802_11TKIPAESMix:\n                NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA_TKIP, 4);\n\n\t\t\t\tPairwiseCnt = 1;\n\t\t\t\t/* Insert WPA TKIP as the first pairwise cipher */\n\t\t\t\tif (MIX_CIPHER_WPA_TKIP_ON(FlexibleCipher))\n\t\t\t\t{\n                \tNdisMoveMemory(pRsnie_cipher->ucast[0].oui, OUI_WPA_TKIP, 4);\n\t\t\t\t\t/* Insert WPA AES as the secondary pairwise cipher*/\n\t\t\t\t\tif (MIX_CIPHER_WPA_AES_ON(FlexibleCipher))\n\t\t\t\t\t{\n\t\t\t\t\t\tNdisMoveMemory(pRsnIe + sizeof(RSNIE), OUI_WPA_CCMP, 4);\n\t\t\t\t\t\tPairwiseCnt = 2;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* Insert WPA AES as the first pairwise cipher */\n\t\t\t\t\tNdisMoveMemory(pRsnie_cipher->ucast[0].oui, OUI_WPA_CCMP, 4);\t\n\t\t\t\t}\n\t\t\t\t\t\t\n                pRsnie_cipher->ucount = PairwiseCnt;\t\t\t\t\n                *rsn_len = sizeof(RSNIE) + (4 * (PairwiseCnt - 1));\t\t\t\t\n                break;\t\t\t\t\t\n        }\n\n#ifdef CONFIG_STA_SUPPORT\n\t\tif ((pAd->OpMode == OPMODE_STA) &&\n\t\t\t(pAd->StaCfg.GroupCipher != Ndis802_11TKIPEnable) &&\n\t\t\t(pAd->StaCfg.GroupCipher != Ndis802_11AESEnable)\n\t\t\t)\n\t\t{\n\t\t\tUINT\tGroupCipher = pAd->StaCfg.GroupCipher;\n\t\t\tswitch(GroupCipher)\n\t\t\t{\n\t\t\t\tcase Ndis802_11GroupWEP40Enabled:\n\t\t\t\t\tNdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA_WEP40, 4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Ndis802_11GroupWEP104Enabled:\n\t\t\t\t\tNdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA_WEP104, 4);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif /* CONFIG_STA_SUPPORT */\n\n\t\t/* swap for big-endian platform*/\n\t\tpRsnie_cipher->version = cpu2le16(pRsnie_cipher->version);\n\t    pRsnie_cipher->ucount = cpu2le16(pRsnie_cipher->ucount);\n\t}\n}", "path": "lede/package/lean/mt/drivers/mt7612e/src/mt76x2/common/cmm_wpa.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "coolsnowwolf/lede", "stars": 28402, "license": "other", "language": "c", "size": 286238}
{"docstring": "/* Find WPS IE Id in a buffer containing multiple IEs */\n", "func_signal": "const UCHAR *RTMPFindWPSIE(const UCHAR *Ies, INT32 Len)", "code": "{\n    const UCHAR *Ptr = Ies;\n    UCHAR WPSOUI[]={0x00, 0x50, 0xf2, 0x04};\n    if (!Ies || ! Len)\n        return NULL;\n    while ((Ptr = RTMPFindIE(WLAN_EID_VENDOR_SPECIFIC, Ptr, Len-(Ptr-Ies))) != NULL)\n    {\n        if (!NdisCmpMemory(Ptr+2, WPSOUI, 4))\n            break;\n        Ptr += Ptr[1] + 2;\n    }\n    return Ptr;\n}", "path": "lede/package/lean/mt/drivers/mt7612e/src/mt76x2/common/cmm_wpa.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "coolsnowwolf/lede", "stars": 28402, "license": "other", "language": "c", "size": 286238}
{"docstring": "/*\n\t========================================================================\n\tRoutine Description:\n\t\tCaller ensures we has 802.11n support.\n\t\tCalls at setting HT from AP/STASetinformation\n\n\tArguments:\n\t\tpAd - Pointer to our adapter\n\t\tphymode  - \n\n\t========================================================================\n*/\n", "func_signal": "VOID RTMPSetHT(\n\tIN RTMP_ADAPTER *pAd,\n\tIN OID_SET_HT_PHYMODE *pHTPhyMode)", "code": "{\n\tUCHAR RxStream = pAd->CommonCfg.RxStream;\n#ifdef CONFIG_AP_SUPPORT\n\tINT apidx;\n#endif /* CONFIG_AP_SUPPORT */\n\tINT bw;\n\tRT_HT_CAPABILITY *rt_ht_cap = &pAd->CommonCfg.DesiredHtPhy;\n\tHT_CAPABILITY_IE *ht_cap= &pAd->CommonCfg.HtCapability;\n\t\n#ifdef CONFIG_AP_SUPPORT\n\t/* sanity check for extention channel */\n\tif (CHAN_PropertyCheck(pAd, pAd->CommonCfg.Channel,\n\t\t\t\t\t\tCHANNEL_NO_FAT_BELOW | CHANNEL_NO_FAT_ABOVE) == TRUE)\n\t{\n\t\t/* only 20MHz is allowed */\n\t\tpHTPhyMode->BW = 0;\n\t}\n\telse if (pHTPhyMode->ExtOffset == EXTCHA_BELOW)\n\t{\n\t\t/* extension channel below this channel is not allowed */\n\t\tif (CHAN_PropertyCheck(pAd, pAd->CommonCfg.Channel,\n\t\t\t\t\t\tCHANNEL_NO_FAT_BELOW) == TRUE)\n\t\t{\n\t\t\tpHTPhyMode->ExtOffset = EXTCHA_ABOVE;\n\t\t}\n\t}\n\telse if (pHTPhyMode->ExtOffset == EXTCHA_ABOVE)\n\t{\n\t\t/* extension channel above this channel is not allowed */\n\t\tif (CHAN_PropertyCheck(pAd, pAd->CommonCfg.Channel,\n\t\t\t\t\t\tCHANNEL_NO_FAT_ABOVE) == TRUE)\n\t\t{\n\t\t\tpHTPhyMode->ExtOffset = EXTCHA_BELOW;\n\t\t}\n\t}\n#endif /* CONFIG_AP_SUPPORT */\n\n\tDBGPRINT(RT_DEBUG_TRACE, (\"RTMPSetHT : HT_mode(%d), ExtOffset(%d), MCS(%d), BW(%d), STBC(%d), SHORTGI(%d)\\n\",\n\t\t\t\t\t\t\t\t\t\tpHTPhyMode->HtMode, pHTPhyMode->ExtOffset, \n\t\t\t\t\t\t\t\t\t\tpHTPhyMode->MCS, pHTPhyMode->BW,\n\t\t\t\t\t\t\t\t\t\tpHTPhyMode->STBC, pHTPhyMode->SHORTGI));\n\t\t\t\n\t/* Don't zero supportedHyPhy structure.*/\n\tRTMPZeroMemory(ht_cap, sizeof(HT_CAPABILITY_IE));\n\tRTMPZeroMemory(&pAd->CommonCfg.AddHTInfo, sizeof(pAd->CommonCfg.AddHTInfo));\n\tRTMPZeroMemory(&pAd->CommonCfg.NewExtChanOffset, sizeof(pAd->CommonCfg.NewExtChanOffset));\n\tRTMPZeroMemory(rt_ht_cap, sizeof(RT_HT_CAPABILITY));\n\n   \tif (pAd->CommonCfg.bRdg)\n\t{\n\t\tht_cap->ExtHtCapInfo.PlusHTC = 1;\n\t\tht_cap->ExtHtCapInfo.RDGSupport = 1;\n\t}\n\telse\n\t{\n\t\tht_cap->ExtHtCapInfo.PlusHTC = 0;\n\t\tht_cap->ExtHtCapInfo.RDGSupport = 0;\n\t}\n\n\n\tif (RxStream == 1)\n\t{\n\t\tht_cap->HtCapParm.MaxRAmpduFactor = 2;\n\t\trt_ht_cap->MaxRAmpduFactor = 2;\n\t}\n\telse\n\t{\n\t\tht_cap->HtCapParm.MaxRAmpduFactor = 3;\n\t\trt_ht_cap->MaxRAmpduFactor = 3;\n\t}\n\n\tDBGPRINT(RT_DEBUG_TRACE, (\"RTMPSetHT : RxBAWinLimit = %d\\n\", pAd->CommonCfg.BACapability.field.RxBAWinLimit));\n\n\t/* Mimo power save, A-MSDU size, */\n\trt_ht_cap->AmsduEnable = (USHORT)pAd->CommonCfg.BACapability.field.AmsduEnable;\n\trt_ht_cap->AmsduSize = (UCHAR)pAd->CommonCfg.BACapability.field.AmsduSize;\n\trt_ht_cap->MimoPs = (UCHAR)pAd->CommonCfg.BACapability.field.MMPSmode;\n\trt_ht_cap->MpduDensity = (UCHAR)pAd->CommonCfg.BACapability.field.MpduDensity;\n\n\tht_cap->HtCapInfo.AMsduSize = (USHORT)pAd->CommonCfg.BACapability.field.AmsduSize;\n\tht_cap->HtCapInfo.MimoPs = (USHORT)pAd->CommonCfg.BACapability.field.MMPSmode;\n\t\n\tif (pAd->CommonCfg.ht_ldpc && (pAd->chipCap.phy_caps & fPHY_CAP_LDPC))\n\t\tht_cap->HtCapInfo.ht_rx_ldpc = 1;\n\telse\n\t\tht_cap->HtCapInfo.ht_rx_ldpc = 0;\n\t\n\tht_cap->HtCapParm.MpduDensity = (UCHAR)pAd->CommonCfg.BACapability.field.MpduDensity;\n\t\n\tDBGPRINT(RT_DEBUG_TRACE, (\"RTMPSetHT : AMsduSize = %d, MimoPs = %d, MpduDensity = %d, MaxRAmpduFactor = %d\\n\", \n\t\t\t\t\t\t\t\t\t\t\t\t\trt_ht_cap->AmsduSize, \n\t\t\t\t\t\t\t\t\t\t\t\t\trt_ht_cap->MimoPs,\n\t\t\t\t\t\t\t\t\t\t\t\t\trt_ht_cap->MpduDensity,\n\t\t\t\t\t\t\t\t\t\t\t\t\trt_ht_cap->MaxRAmpduFactor));\n\t\n\tif(pHTPhyMode->HtMode == HTMODE_GF)\n\t{\n\t\tht_cap->HtCapInfo.GF = 1;\n\t\trt_ht_cap->GF = 1;\n\t}\n\telse\n\t\trt_ht_cap->GF = 0;\n\t\n\t/* Decide Rx MCSSet*/\n\tswitch (RxStream)\n\t{\n\t\tcase 3:\n\t\t\tht_cap->MCSSet[2] =  0xff;\n\t\tcase 2:\n\t\t\tht_cap->MCSSet[1] =  0xff;\n\t\tcase 1:\n\t\tdefault:\n\t\t\tht_cap->MCSSet[0] =  0xff;\n\t\t\tbreak;\n\t}\n\n#ifdef DOT11N_DRAFT3\n\tif (pAd->CommonCfg.bForty_Mhz_Intolerant && (pHTPhyMode->BW == BW_40))\n\t{\n\t\tpHTPhyMode->BW = BW_20;\n\t\tht_cap->HtCapInfo.Forty_Mhz_Intolerant = 1;\n\t}\n#endif /* DOT11N_DRAFT3 */\n\n\t// TODO: shiang-6590, how about the \"bw\" when channel 14 for JP region???\n\t//CFG_TODO\n\tbw = BW_20;\n\tif(pHTPhyMode->BW == BW_40)\n\t{\n\t\tht_cap->MCSSet[4] = 0x1; /* MCS 32*/\n\t\tht_cap->HtCapInfo.ChannelWidth = 1;\n\t\tif (pAd->CommonCfg.Channel <= 14) \t\t\n\t\t\tht_cap->HtCapInfo.CCKmodein40 = 1;\n\n\t\trt_ht_cap->ChannelWidth = 1;\n\t\tpAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth = 1;\n\t\tpAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset = (pHTPhyMode->ExtOffset == EXTCHA_BELOW)? (EXTCHA_BELOW): EXTCHA_ABOVE;\n\t\t/* Set Regsiter for extension channel position.*/\n\t\trtmp_mac_set_ctrlch(pAd, pHTPhyMode->ExtOffset);\n\n\t\t/* Turn on BBP 40MHz mode now only as AP . */\n\t\t/* Sta can turn on BBP 40MHz after connection with 40MHz AP. Sta only broadcast 40MHz capability before connection.*/\n\t\tif ((pAd->OpMode == OPMODE_AP) || INFRA_ON(pAd) || ADHOC_ON(pAd)\n\t\t)\n\t\t{\n\t\t\tbbp_set_ctrlch(pAd, pHTPhyMode->ExtOffset);\t\n#ifdef GREENAP_SUPPORT\n\t\t\tif (pAd->ApCfg.bGreenAPActive == 1)\n\t\t\t\tbw = BW_20;\n\t\t\telse\n#endif /* GREENAP_SUPPORT */\n\t\t\t\tbw = BW_40;\n\t\t}\n\t}\n\telse\n\t{\n\t\tht_cap->HtCapInfo.ChannelWidth = 0;\n\t\trt_ht_cap->ChannelWidth = 0;\n\t\tpAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth = 0;\n\t\tpAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset = EXTCHA_NONE;\n\t\tpAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;\n\t\t/* Turn on BBP 20MHz mode by request here.*/\n\t\tbw = BW_20;\n\t}\n\n#ifdef DOT11_VHT_AC\n\tif (pHTPhyMode->BW == BW_40 &&\n\t\tpAd->CommonCfg.vht_bw == VHT_BW_80 && \n\t\tpAd->CommonCfg.vht_cent_ch)\n\t\tbw = BW_80;\n#endif /* DOT11_VHT_AC */\n\tbbp_set_bw(pAd, bw);\n\n\n\tif(pHTPhyMode->STBC == STBC_USE)\n\t{\n\t\tif (pAd->Antenna.field.TxPath >= 2)\n\t\t{\n\t\t\tht_cap->HtCapInfo.TxSTBC = 1;\n\t\t\trt_ht_cap->TxSTBC = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tht_cap->HtCapInfo.TxSTBC = 0;\n\t\t\trt_ht_cap->TxSTBC = 0; \t\n\t\t}\n\t\t\n\t\t/*\n\t\t\tRxSTBC\n\t\t\t\t0: not support,\n\t\t\t\t1: support for 1SS\n\t\t\t\t2: support for 1SS, 2SS\n\t\t\t\t3: support for 1SS, 2SS, 3SS\n\t\t*/\n\t\tif (pAd->Antenna.field.RxPath >= 1)\n\t\t{\n\t\t\tht_cap->HtCapInfo.RxSTBC = 1;\n\t\t\trt_ht_cap->RxSTBC = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tht_cap->HtCapInfo.RxSTBC = 0; \n\t\t\trt_ht_cap->RxSTBC = 0; \t\n\t\t}\n\t}\n\telse\n\t{\n\t\trt_ht_cap->TxSTBC = 0;\n\t\trt_ht_cap->RxSTBC = 0;\n\t}\n\n\tif(pHTPhyMode->SHORTGI == GI_400)\n\t{\n\t\tht_cap->HtCapInfo.ShortGIfor20 = 1;\n\t\tht_cap->HtCapInfo.ShortGIfor40 = 1;\n\t\trt_ht_cap->ShortGIfor20 = 1;\n\t\trt_ht_cap->ShortGIfor40 = 1;\n\t}\n\telse\n\t{\n\t\tht_cap->HtCapInfo.ShortGIfor20 = 0;\n\t\tht_cap->HtCapInfo.ShortGIfor40 = 0;\n\t\trt_ht_cap->ShortGIfor20 = 0;\n\t\trt_ht_cap->ShortGIfor40 = 0;\n\t}\n\t\n\t/* We support link adaptation for unsolicit MCS feedback, set to 2.*/\n\tpAd->CommonCfg.AddHTInfo.ControlChan = pAd->CommonCfg.Channel;\n\t/* 1, the extension channel above the control channel. */\n\t\n\t/* EDCA parameters used for AP's own transmission*/\n\tif (pAd->CommonCfg.APEdcaParm.bValid == FALSE)\n\t\tset_default_ap_edca_param(pAd);\n\tAsicSetEdcaParm(pAd, &pAd->CommonCfg.APEdcaParm);\n\n#ifdef TXBF_SUPPORT\n\tif (pAd->chipCap.FlgHwTxBfCap)\n\t{\n\t\t/* Set ETxBF */\n\t\tsetETxBFCap(pAd, &ht_cap->TxBFCap);\n\n\t\t/* Check ITxBF */\n\t\tpAd->CommonCfg.RegTransmitSetting.field.ITxBfEn &= rtmp_chk_itxbf_calibration(pAd);\n\n\t\t/* Apply to ASIC */\n\t\trtmp_asic_set_bf(pAd);\n\t}\n#endif /* TXBF_SUPPORT */\n\n#ifdef CONFIG_AP_SUPPORT\n\tIF_DEV_CONFIG_OPMODE_ON_AP(pAd)\n\t{\n\t\tfor (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)\n\t\t\tRTMPSetIndividualHT(pAd, apidx);\n#ifdef WDS_SUPPORT\n\t\tfor (apidx = 0; apidx < MAX_WDS_ENTRY; apidx++)\n\t\t\tRTMPSetIndividualHT(pAd, apidx + MIN_NET_DEVICE_FOR_WDS);\n#endif /* WDS_SUPPORT */\n#ifdef APCLI_SUPPORT\n\t\tfor (apidx = 0; apidx < MAX_APCLI_NUM; apidx++)\n\t\t\tRTMPSetIndividualHT(pAd, apidx + MIN_NET_DEVICE_FOR_APCLI);\n#endif /* APCLI_SUPPORT */\n\t}\n#endif /* CONFIG_AP_SUPPORT */\n\n#ifdef CONFIG_STA_SUPPORT\n\tIF_DEV_CONFIG_OPMODE_ON_STA(pAd)\n\t{\n\n#ifdef RT_CFG80211_P2P_SUPPORT\n\t\tfor (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)\n\t\t\tRTMPSetIndividualHT(pAd, apidx + MIN_NET_DEVICE_FOR_CFG80211_VIF_P2P_GO);\n\n#ifdef RT_CFG80211_P2P_CONCURRENT_DEVICE\n                for (apidx = 0; apidx < MAX_APCLI_NUM; apidx++)\n                        RTMPSetIndividualHT(pAd, apidx + MIN_NET_DEVICE_FOR_APCLI);\n#endif /* RT_CFG80211_P2P_CONCURRENT_DEVICE */\t\t\n#endif /* RT_CFG80211_P2P_SUPPORT */\n\n\t\tRTMPSetIndividualHT(pAd, 0);\n\t}\n#endif /* CONFIG_STA_SUPPORT */\n\n}", "path": "lede/package/lean/mt/drivers/mt7612e/src/mt76x2/mgmt/mgmt_ht.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "coolsnowwolf/lede", "stars": 28402, "license": "other", "language": "c", "size": 286238}
{"docstring": "/*\n    ========================================================================\n    \n    Routine Description:\n    Check Sanity RSN IE of EAPoL message\n\n    Arguments:\n        \n    Return Value:\n\n\t\t\n    ========================================================================\n*/\n", "func_signal": "BOOLEAN RTMPCheckRSNIE(\n\tIN  PRTMP_ADAPTER   pAd,\n\tIN  PUCHAR          pData,\n\tIN  UCHAR           DataLen,\n\tIN  MAC_TABLE_ENTRY *pEntry,\n\tOUT\tUCHAR\t\t\t*Offset)", "code": "{\n\tPUCHAR              pVIE;\n\tUCHAR               len;\n\tPEID_STRUCT         pEid;\n\tBOOLEAN\t\t\t\tresult = FALSE;\n\t\t\n\tpVIE = pData;\n\tlen\t = DataLen;\n\t*Offset = 0;\n\n\twhile (len > sizeof(RSNIE2))\n\t{\n\t\tpEid = (PEID_STRUCT) pVIE;\t\n\t\t/* WPA RSN IE*/\n\t\tif ((pEid->Eid == IE_WPA) && (NdisEqualMemory(pEid->Octet, WPA_OUI, 4)))\n\t\t{\t\t\t\n\t\t\tif ((pEntry->AuthMode == Ndis802_11AuthModeWPA || pEntry->AuthMode == Ndis802_11AuthModeWPAPSK) &&\n\t\t\t\t(NdisEqualMemory(pVIE, pEntry->RSN_IE, pEntry->RSNIE_Len)) &&\n\t\t\t\t(pEntry->RSNIE_Len == (pEid->Len + 2)))\n\t\t\t{\n\t\t\t\t\tresult = TRUE;\t\t\t\t\n\t\t\t}\t\t\n\t\t\t\n\t\t\t*Offset += (pEid->Len + 2);\t\t\t\n\t\t}\n\t\t/* WPA2 RSN IE, doesn't need to check RSNIE Capabilities field        */\n\t\telse if ((pEid->Eid == IE_RSN) && (NdisEqualMemory(pEid->Octet + 2, RSN_OUI, 3)))\n\t\t{\n\t\t\tif ((pEntry->AuthMode == Ndis802_11AuthModeWPA2 || pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK) &&\n\t\t\t\t(pEid->Eid == pEntry->RSN_IE[0]) &&\n\t\t\t\t((pEid->Len + 2) >= pEntry->RSNIE_Len) &&\n\t\t\t\t(NdisEqualMemory(pEid->Octet, &pEntry->RSN_IE[2], pEntry->RSNIE_Len - 4)))\n\t\t\t{\n\n\t\t\t\t\tresult = TRUE;\t\t\t\t\n\t\t\t}\t\t\t\n\n\t\t\t*Offset += (pEid->Len + 2);\n\t\t}\t\t\n\t\telse\n\t\t{\t\t\t\n\t\t\tbreak;\n\t\t}\n\n\t\tpVIE += (pEid->Len + 2);\n\t\tlen  -= (pEid->Len + 2);\n\t}\n\t\n\t\t\n\treturn result;\n\t\n}", "path": "lede/package/lean/mt/drivers/mt7612e/src/mt76x2/common/cmm_wpa.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "coolsnowwolf/lede", "stars": 28402, "license": "other", "language": "c", "size": 286238}
{"docstring": "/*\n\t========================================================================\n\t\n\tRoutine Description:\n\t\tProcess Pairwise key Msg 3 of 4-way handshaking and send Msg 4 \n\n\tArguments:\n\t\tpAd\tPointer\tto our adapter\n\t\tElem\t\tMessage body\n\t\t\n\tReturn Value:\n\t\tNone\n\t\t\n\tNote:\n\t\t\n\t========================================================================\n*/\n", "func_signal": "VOID PeerPairMsg3Action(\n    IN PRTMP_ADAPTER    pAd, \n    IN MAC_TABLE_ENTRY  *pEntry,\n    IN MLME_QUEUE_ELEM  *Elem)", "code": "{\n\tUCHAR               Header802_3[14];\n\tUCHAR\t\t\t\t*mpool;\n\tPEAPOL_PACKET\t\tpEapolFrame;\n\tPEAPOL_PACKET\t\tpMsg3;\n\tUINT            \tMsgLen;\t\t\t\t\n\tPUINT8\t\t\t\tpCurrentAddr = NULL;\n\tUCHAR\t\t\t\tgroup_cipher = Ndis802_11WEPDisabled;\n#ifdef MAC_REPEATER_SUPPORT\n\tUSHORT ifIndex = (USHORT)(Elem->Priv);\n\tUCHAR CliIdx = 0xFF;\n#endif /* MAC_REPEATER_SUPPORT */\n\tUCHAR idx = 0;\n\tBOOLEAN bWPA2 = FALSE;\n\n\tDBGPRINT(RT_DEBUG_TRACE, (\"===> PeerPairMsg3Action \\n\"));\n\t\n\tif ((!pEntry) || (!IS_ENTRY_CLIENT(pEntry) && !IS_ENTRY_APCLI(pEntry)))\n\t\treturn;\n\n    if (Elem->MsgLen < (LENGTH_802_11 + LENGTH_802_1_H + LENGTH_EAPOL_H + MIN_LEN_OF_EAPOL_KEY_MSG))\n\t\treturn;\n\n#ifdef CONFIG_AP_SUPPORT\n\tIF_DEV_CONFIG_OPMODE_ON_AP(pAd)\n\t{\n#ifdef APCLI_SUPPORT\n\t\tif (IS_ENTRY_APCLI(pEntry))\n\t\t{\n\t\t\tUINT IfIndex = 0;\n\t\t\n\t\t\tIfIndex = pEntry->wdev_idx;\n#ifdef MAC_REPEATER_SUPPORT\n\t\t\tif (ifIndex >= 64)\n\t\t\t\tCliIdx = ((ifIndex - 64) % 16);\n#endif /* MAC_REPEATER_SUPPORT */\n\n\t\t\tif (IfIndex >= MAX_APCLI_NUM)\n\t\t\t\treturn;\n\n#ifdef MAC_REPEATER_SUPPORT\n\t\t\tif (CliIdx != 0xFF)\n\t\t\t\tpCurrentAddr = pAd->ApCfg.ApCliTab[IfIndex].RepeaterCli[CliIdx].CurrentAddress;\n\t\t\telse\n#endif /* MAC_REPEATER_SUPPORT */\n\t\t\tpCurrentAddr = pAd->ApCfg.ApCliTab[IfIndex].wdev.if_addr;\n\t\t\tgroup_cipher = pAd->ApCfg.ApCliTab[IfIndex].GroupCipher;\n\n\t\t}\n#endif /* APCLI_SUPPORT */\t\t\t\n\t}\n#endif /* CONFIG_AP_SUPPORT */\n#ifdef CONFIG_STA_SUPPORT\n\tIF_DEV_CONFIG_OPMODE_ON_STA(pAd)\n\t{\t\t\t\t\n\t\t{\n\t\tpCurrentAddr = pAd->CurrentAddress;\n\t\tgroup_cipher = pAd->StaCfg.GroupCipher;\n\n\t}\t\n\t}\n#endif /* CONFIG_STA_SUPPORT */\n\n\tif (pCurrentAddr == NULL)\n\t\treturn;\n\t\n\t/* Record 802.11 header & the received EAPOL packet Msg3*/\n\tpMsg3 = (PEAPOL_PACKET) &Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];\n\tMsgLen = Elem->MsgLen - LENGTH_802_11 - LENGTH_802_1_H;\n\n\t/* Sanity Check peer Pairwise message 3 - Replay Counter, MIC, RSNIE*/\n\tif (PeerWpaMessageSanity(pAd, pMsg3, MsgLen, EAPOL_PAIR_MSG_3, pEntry) == FALSE)\n\t\treturn;\n\t\n\tif (group_cipher == Ndis802_11AESEnable)\n\t\tbWPA2 = TRUE;\n\tif ((pEntry->AllowInsPTK == TRUE) && bWPA2) {\n\t\tpEntry->CCMP_BC_PN = 0;\n\t\tpEntry->init_ccmp_bc_pn_passed = FALSE;\n\t\tfor (idx = 0; idx < LEN_KEY_DESC_RSC; idx++)\n\t\t\tpEntry->CCMP_BC_PN += (pMsg3->KeyDesc.KeyRsc[idx] << (idx*8));\n\t\tpEntry->AllowUpdateRSC = FALSE;\n\t\tDBGPRINT(RT_DEBUG_OFF, (\"%s(%d): update CCMP_BC_PN to %llu\\n\",\n\t\t\t__func__, pEntry->wcid, pEntry->CCMP_BC_PN ));\t\t\n\t}\n\t\n\t/* Save Replay counter, it will use construct message 4*/\n\tNdisMoveMemory(pEntry->R_Counter, pMsg3->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY);\n\n\t/* Double check ANonce*/\n\tif (!NdisEqualMemory(pEntry->ANonce, pMsg3->KeyDesc.KeyNonce, LEN_KEY_DESC_NONCE))\n\t{\n\t\treturn;\n\t}\n\n\t/* Allocate memory for output*/\n\tos_alloc_mem(NULL, (PUCHAR *)&mpool, TX_EAPOL_BUFFER);\n\tif (mpool == NULL)\n    {\n        DBGPRINT(RT_DEBUG_ERROR, (\"!!!%s : no memory!!!\\n\", __FUNCTION__));\n        return;\n    }\n\n\tpEapolFrame = (PEAPOL_PACKET)mpool;\n\tNdisZeroMemory(pEapolFrame, TX_EAPOL_BUFFER);\n\n\t/* Construct EAPoL message - Pairwise Msg 4*/\n\tConstructEapolMsg(pEntry,\n\t\t\t\t\t  group_cipher,\n\t\t\t\t\t  EAPOL_PAIR_MSG_4,  \n\t\t\t\t\t  0,\t\t\t\t\t/* group key index not used in message 4*/\n\t\t\t\t\t  NULL,\t\t\t\t\t/* Nonce not used in message 4*/\n\t\t\t\t\t  NULL,\t\t\t\t\t/* TxRSC not used in message 4*/\n\t\t\t\t\t  NULL,\t\t\t\t\t/* GTK not used in message 4*/\n\t\t\t\t\t  NULL,\t\t\t\t\t/* RSN IE not used in message 4*/\n\t\t\t\t\t  0,\n\t\t\t\t\t  pEapolFrame);\n\n\t/* Update WpaState*/\n\tpEntry->WpaState = AS_PTKINITDONE;\t \t\n\t/* Update pairwise key\t\t*/\n#ifdef CONFIG_AP_SUPPORT\n\tIF_DEV_CONFIG_OPMODE_ON_AP(pAd)\n\t{\n#ifdef APCLI_SUPPORT\n\t\tif (IS_ENTRY_APCLI(pEntry)) {\n\t\t\tif(pEntry->AllowInsPTK == TRUE) {\n\t\t\t\tAPCliInstallPairwiseKey(pAd, pEntry);\n\t\t\t\tpEntry->AllowInsPTK = FALSE;\n\t\t\t\tpEntry->AllowUpdateRSC = TRUE;\n\t\t\t} else {\n\t\t\t\tDBGPRINT(RT_DEBUG_ERROR, (\"!!!%s : the M3 reinstall attack, skip install key\\n\",\n\t\t\t\t\t\t__func__));\n\t\t\t}\n\t\t}\n#endif /* APCLI_SUPPORT */\n\t}\n#endif /* CONFIG_AP_SUPPORT */\n#ifdef CONFIG_STA_SUPPORT\n\tIF_DEV_CONFIG_OPMODE_ON_STA(pAd)\n\t{\n\t\t{\n\t\tNdisMoveMemory(pAd->StaCfg.PTK, pEntry->PTK, LEN_PTK);\n\t\tWPAInstallPairwiseKey(pAd, \n\t\t\t\t\t\t\t  BSS0, \n\t\t\t\t\t\t\t  pEntry, \n\t\t\t\t\t\t\t  FALSE);\n\t\t\t}\n\t}\n#endif /* CONFIG_STA_SUPPORT */\n\n\t/* open 802.1x port control and privacy filter*/\n\tif (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK || \n\t\tpEntry->AuthMode == Ndis802_11AuthModeWPA2)\n\t{\n\t\tpEntry->PortSecured = WPA_802_1X_PORT_SECURED;\n\t\tpEntry->PrivacyFilter = Ndis802_11PrivFilterAcceptAll;\t\n#ifdef MAC_REPEATER_SUPPORT\n\t\tif (CliIdx != 0xFF)\n\t\t{\n\t\t\tifIndex = ((ifIndex - 64) / 16);\n\t\t\tpAd->ApCfg.ApCliTab[ifIndex].RepeaterCli[CliIdx].CliConnectState = 2;\n\t\t}\n#endif /* MAC_REPEATER_SUPPORT */\n\n#ifdef CONFIG_AP_SUPPORT\n\t\tIF_DEV_CONFIG_OPMODE_ON_AP(pAd)\n\t\t{\t\t\t\t\n#ifdef APCLI_SUPPORT\n#ifdef APCLI_AUTO_CONNECT_SUPPORT\n\t\t\tif((pAd->ApCfg.ApCliAutoConnectRunning == TRUE)\n#ifdef MAC_REPEATER_SUPPORT\n\t\t\t\t&& (CliIdx == 0xFF)\n#endif /* MAC_REPEATER_SUPPORT */\n\t\t\t\t)\n\t\t\t{\n\t\t\t\tDBGPRINT(RT_DEBUG_TRACE, (\"Apcli auto connected:PeerPairMsg3Action() \\n\"));\n\t\t\t\tpAd->ApCfg.ApCliAutoConnectRunning = FALSE;\n\t\t\t}\n#endif /* APCLI_AUTO_CONNECT_SUPPORT */\n\n#ifdef MWDS\n\t\tif(pEntry &&\n\t\t   IS_ENTRY_APCLI(pEntry) &&\n\t\t   (pEntry->wdev_idx < MAX_APCLI_NUM))\n\t\t{\n\t\t\tif(pAd->ApCfg.ApCliTab[pEntry->wdev_idx].MlmeAux.bSupportMWDS && \n\t\t  \t\tpAd->ApCfg.ApCliTab[pEntry->wdev_idx].bSupportMWDS)\n\t\t\t{\n\t\t\t\tpAd->ApCfg.ApCliTab[pEntry->wdev_idx].bEnableMWDS = TRUE;\n\t\t\t\tpEntry->bEnableMWDS = TRUE;\n\t\t\t\tif((pEntry->PortSecured == WPA_802_1X_PORT_SECURED))\n\t\t\t\t{\n\t\t\t\t\tSET_MWDS_OPMODE_APCLI(pEntry);\n\t\t\t\t\tDBGPRINT(RT_DEBUG_ERROR, (\"SET_MWDS_OPMODE_APCLI OK!\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpAd->ApCfg.ApCliTab[pEntry->wdev_idx].bEnableMWDS = FALSE;\n\t\t\t\tpEntry->bEnableMWDS = FALSE;\n\t\t\t\tSET_MWDS_OPMODE_NONE(pEntry);\n\t\t\t}\n\t\t}\n#endif /* MWDS */\n\n#ifdef SMART_MESH_MONITOR\n\t\t\tif (IS_ENTRY_APCLI(pEntry) && \n\t\t\t\t(pEntry->wdev_idx < MAX_APCLI_NUM) &&\n\t\t\t\t(pEntry->PortSecured == WPA_802_1X_PORT_SECURED))\n\t\t\t{\n\t\t\t\tstruct nsmpif_drvevnt_buf drvevnt;\n\t\t\t\tdrvevnt.data.linkstate.type = NSMPIF_DRVEVNT_EXT_UPLINK_STAT;\n\t\t\t\tdrvevnt.data.linkstate.link_state = NSMP_UPLINK_STAT_CONNECTED;\n\t\t\t\tNdisCopyMemory(drvevnt.data.linkstate.bssid,pEntry->wdev->bssid,MAC_ADDR_LEN);\n\t\t\t\tdrvevnt.data.linkstate.channel = pAd->CommonCfg.Channel;\n\t\t\t\tNdisZeroMemory(drvevnt.data.linkstate.op_channels,sizeof(drvevnt.data.linkstate.op_channels));\n\t\t\t\tdrvevnt.data.linkstate.op_channels[0] = pAd->CommonCfg.Channel;\n#ifdef DOT11_N_SUPPORT\n\t\t\t\tif(pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth == BW_40)\n\t\t\t\t\tdrvevnt.data.linkstate.op_channels[1] = N_GetSecondaryChannel(pAd);\n#endif /* DOT11_N_SUPPORT */\n\t\t\t\tRtmpOSWrielessEventSend(pAd->net_dev, RT_WLAN_EVENT_CUSTOM,NSMPIF_DRVEVNT_EXT_UPLINK_STAT,\n\t\t\t\t\t\t\t\t\t\tNULL, (PUCHAR)&drvevnt.data.linkstate, sizeof(drvevnt.data.linkstate));\n\t\t\t}\n#endif /* SMART_MESH_MONITOR */\n#endif /* APLCI_SUPPORT */\n\t\t}\n#endif /* CONFIG_AP_SUPPORT */\n\n#ifdef CONFIG_STA_SUPPORT\n\t\tSTA_PORT_SECURED(pAd);\n#endif /* CONFIG_STA_SUPPORT */\n\t\tDBGPRINT(RT_DEBUG_TRACE, (\"PeerPairMsg3Action: AuthMode(%s) PairwiseCipher(%s) GroupCipher(%s) \\n\",\n\t\t\t\t\t\t\t\t\tGetAuthMode(pEntry->AuthMode),\n\t\t\t\t\t\t\t\t\tGetEncryptType(pEntry->WepStatus),\n\t\t\t\t\t\t\t\t\tGetEncryptType(group_cipher)));\n\t}\n\telse\n\t{\t\n#ifdef CONFIG_AP_SUPPORT\n\t\tIF_DEV_CONFIG_OPMODE_ON_AP(pAd)\n\t\t{\n#ifdef APCLI_SUPPORT\t\n\t\t\t/* Patch issue with gateway AP*/\n\t\t\t/* In WPA mode, AP doesn't send out message 1 of group-key HS.*/\n\t\t\t/* So, Supplicant shall maintain a timeout action to disconnect */\n\t\t\t/* this link.*/\n\t\t\t/* Todo - Does it need to apply to STA ?*/\n\t\t\tif (IS_ENTRY_APCLI(pEntry))\t\n\t\t\t \tRTMPSetTimer(&pEntry->RetryTimer, PEER_GROUP_KEY_UPDATE_INIV);\n#endif /* APCLI_SUPPORT */\n\t\t}\n#endif /* CONFIG_AP_SUPPORT */\t\t\n\t}\n\n\t/* Init 802.3 header and send out*/\n\tMAKE_802_3_HEADER(Header802_3, pEntry->Addr, pCurrentAddr, EAPOL);\t\n\tRTMPToWirelessSta(pAd, pEntry, \n\t\t\t\t\t  Header802_3, sizeof(Header802_3), \n\t\t\t\t\t  (PUCHAR)pEapolFrame, \n\t\t\t\t\t  CONV_ARRARY_TO_UINT16(pEapolFrame->Body_Len) + 4, TRUE);\n\n\tos_free_mem(NULL, mpool);\n\n\n\tDBGPRINT(RT_DEBUG_TRACE, (\"<=== PeerPairMsg3Action: send Msg4 of 4-way \\n\"));\n}", "path": "lede/package/lean/mt/drivers/mt7612e/src/mt76x2/common/cmm_wpa.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "coolsnowwolf/lede", "stars": 28402, "license": "other", "language": "c", "size": 286238}
{"docstring": "/** from wpa_supplicant\n * inc_byte_array - Increment arbitrary length byte array by one\n * @counter: Pointer to byte array\n * @len: Length of the counter in bytes\n *\n * This function increments the last byte of the counter by one and continues\n * rolling over to more significant bytes if the byte was incremented from\n * 0xff to 0x00.\n */\n", "func_signal": "void inc_byte_array(UCHAR *counter, int len)", "code": "{\n\tint pos = len - 1;\n\twhile (pos >= 0) {\n\t\tcounter[pos]++;\n\t\tif (counter[pos] != 0)\n\t\t\tbreak;\n\t\tpos--;\n\t}\n}", "path": "lede/package/lean/mt/drivers/mt7612e/src/mt76x2/common/cmm_wpa.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "coolsnowwolf/lede", "stars": 28402, "license": "other", "language": "c", "size": 286238}
{"docstring": "/*\n\t========================================================================\n\n\tRoutine Description:\n\t\tBuild RSN IE context. It is not included element-ID and length.\n\n\tArguments:\n\t\tpAd\t\t\t-\tpointer to our pAdapter context\t\n    \tAuthMode\t-\tindicate the authentication mode\n    \tWepStatus\t-\tindicate the encryption type\n\t\tapidx\t\t-\tindicate the interface index\n\t\t\n\tReturn Value:\n\t\t\n\tNote:\n\t\t\n\t========================================================================\n*/\n", "func_signal": "VOID RTMPMakeRSNIE(RTMP_ADAPTER *pAd, UINT AuthMode, UINT WepStatus, UCHAR apidx)", "code": "{\n\tPUCHAR\t\tpRsnIe = NULL;\t\t\t/* primary RSNIE*/\n\tUCHAR \t\t*rsnielen_cur_p = 0;\t/* the length of the primary RSNIE \t\t*/\n#ifdef CONFIG_AP_SUPPORT\n\tPUCHAR\t\tpRsnIe_ex = NULL;\t\t/* secondary RSNIE, it's ONLY used in WPA-mix mode */\n\tBOOLEAN               bMixRsnIe = FALSE;      /* indicate WPA-mix mode is on or off*/\n\tUCHAR\t\ts_offset;\n#endif /* CONFIG_AP_SUPPORT */\n\tUCHAR\t\t*rsnielen_ex_cur_p = 0;\t/* the length of the secondary RSNIE\t  \t*/\n\tUCHAR\t\tPrimaryRsnie;\t\t\t\n\tBOOLEAN\t\tbMixCipher = FALSE;\t/* indicate the pairwise and group cipher are different*/\n\tUCHAR\t\tp_offset;\t\t\n\tWPA_MIX_PAIR_CIPHER FlexibleCipher = MIX_CIPHER_NOTUSE;\t/* it provide the more flexible cipher combination in WPA-WPA2 and TKIPAES mode*/\n\t\t\n\trsnielen_cur_p = NULL;\n\trsnielen_ex_cur_p = NULL;\n\n\tdo\n\t{\n\n#ifdef APCLI_SUPPORT\t\n\t\tif (apidx >= MIN_NET_DEVICE_FOR_APCLI)\n\t\t{\n\t\t\tUINT apcliIfidx = 0;\n\n\t\t\t/* Only support WPAPSK or WPA2PSK for AP-Client mode */\n#ifdef WPA_SUPPLICANT_SUPPORT\n\t\t\tif (pAd->ApCfg.ApCliTab[apcliIfidx].wpa_supplicant_info.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE)\n\t\t\t{\n\t\t\t\tif (AuthMode < Ndis802_11AuthModeWPA)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n#endif /* WPA_SUPPLICANT_SUPPORT */\n\t\t\t{\n\t\t\t\tif ((AuthMode != Ndis802_11AuthModeWPAPSK) && \n\t\t\t\t\t(AuthMode != Ndis802_11AuthModeWPA2PSK))\n\t\t\t    \treturn;\n\t\t\t}\n\n\t\t\tDBGPRINT(RT_DEBUG_TRACE,(\"==> RTMPMakeRSNIE(ApCli)\\n\"));\n\t\n\t\t\tapcliIfidx = apidx - MIN_NET_DEVICE_FOR_APCLI;\n\n\t\t\t/* Initiate some related information */\n\t\t\t\tif (apcliIfidx < MAX_APCLI_NUM)\n\t\t\t\t{\n\t\t\tpAd->ApCfg.ApCliTab[apcliIfidx].RSNIE_Len = 0;\n\t\t\tNdisZeroMemory(pAd->ApCfg.ApCliTab[apcliIfidx].RSN_IE, MAX_LEN_OF_RSNIE);\n\t\t\trsnielen_cur_p = &pAd->ApCfg.ApCliTab[apcliIfidx].RSNIE_Len;\n\t\t\tpRsnIe = pAd->ApCfg.ApCliTab[apcliIfidx].RSN_IE;\n\t\n\t\t\tbMixCipher = pAd->ApCfg.ApCliTab[apcliIfidx].bMixCipher;\n\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDBGPRINT(RT_DEBUG_ERROR, (\"RTMPMakeRSNIE: invalid apcliIfidx(%d)\\n\", apcliIfidx));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t}\n#endif /* APCLI_SUPPORT */\n\n#ifdef CONFIG_AP_SUPPORT\n\t\tIF_DEV_CONFIG_OPMODE_ON_AP(pAd)\n\t\t{\n\t\t\t/* Sanity check for apidx */\n\t\t\tMBSS_MR_APIDX_SANITY_CHECK(pAd, apidx);\n#ifdef HOSTAPD_SUPPORT\n\t\t\tif(pAd->ApCfg.MBSSID[apidx].Hostapd != Hostapd_Diable)\n\t\t\t\treturn;\n#endif /* HOSTAPD_SUPPORT */\n\n\t\t\tif ((AuthMode != Ndis802_11AuthModeWPA) && \n\t\t\t\t(AuthMode != Ndis802_11AuthModeWPAPSK) && \n\t\t\t\t(AuthMode != Ndis802_11AuthModeWPA2) && \n\t\t\t\t(AuthMode != Ndis802_11AuthModeWPA2PSK) && \n\t\t\t\t(AuthMode != Ndis802_11AuthModeWPA1WPA2) && \n\t\t\t\t(AuthMode != Ndis802_11AuthModeWPA1PSKWPA2PSK)\n#ifdef WAPI_SUPPORT\n\t\t\t\t&& (AuthMode != Ndis802_11AuthModeWAICERT)\n\t\t\t\t&& (AuthMode != Ndis802_11AuthModeWAIPSK)\n#endif /* WAPI_SUPPORT */\n\t\t\t\t)\n\t\t\t\treturn;\n\n\t\t\tDBGPRINT(RT_DEBUG_TRACE,(\"==> RTMPMakeRSNIE(AP-ra%d)\\n\", apidx));\n\n\t\t\t/* decide the group key encryption type */\n\t\t\tif (WepStatus == Ndis802_11TKIPAESMix)\n\t\t\t{\n\t\t\t\tpAd->ApCfg.MBSSID[apidx].wdev.GroupKeyWepStatus = Ndis802_11TKIPEnable;\n\t\t\t\tFlexibleCipher = pAd->ApCfg.MBSSID[apidx].wdev.WpaMixPairCipher;\n\t\t\t}\n\t\t\telse\n\t\t\t\tpAd->ApCfg.MBSSID[apidx].wdev.GroupKeyWepStatus = WepStatus;\n\n\t\t\t/* Initiate some related information */\n\t\t\tpAd->ApCfg.MBSSID[apidx].RSNIE_Len[0] = 0;\n\t\t\tpAd->ApCfg.MBSSID[apidx].RSNIE_Len[1] = 0;\n\t\t\tNdisZeroMemory(pAd->ApCfg.MBSSID[apidx].RSN_IE[0], MAX_LEN_OF_RSNIE);\n\t\t\tNdisZeroMemory(pAd->ApCfg.MBSSID[apidx].RSN_IE[1], MAX_LEN_OF_RSNIE);\n\n\t\t\t/* Pointer to the first RSNIE context */\n\t\t\trsnielen_cur_p = &pAd->ApCfg.MBSSID[apidx].RSNIE_Len[0];\n\t\t\tpRsnIe = pAd->ApCfg.MBSSID[apidx].RSN_IE[0];\n\n\t\t\t/* Pointer to the secondary RSNIE context */\n\t\t\trsnielen_ex_cur_p = &pAd->ApCfg.MBSSID[apidx].RSNIE_Len[1];\n\t\t\tpRsnIe_ex = pAd->ApCfg.MBSSID[apidx].RSN_IE[1];\n\n\t\t\t/* Decide whether the authentication mode is WPA1-WPA2 mixed mode */\n\t\t\tif ((AuthMode == Ndis802_11AuthModeWPA1WPA2) || \n\t\t\t\t(AuthMode == Ndis802_11AuthModeWPA1PSKWPA2PSK))\n\t\t\t{\n\t\t\t\tbMixRsnIe = TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif /* CONFIG_AP_SUPPORT */\n\n#ifdef CONFIG_STA_SUPPORT\n\t\tIF_DEV_CONFIG_OPMODE_ON_STA(pAd)\n\t\t{\n#ifdef WPA_SUPPLICANT_SUPPORT\n\t\t\tif (pAd->StaCfg.wpa_supplicant_info.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE)\n\t\t\t{\n\t\t\t\tif (AuthMode < Ndis802_11AuthModeWPA)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n#endif /* WPA_SUPPLICANT_SUPPORT */\n\t\t\t{\n\t\t\t\t/* Support WPAPSK or WPA2PSK in STA-Infra mode */\n\t\t\t\t/* Support WPANone in STA-Adhoc mode */\n\t\t\t\tif ((AuthMode != Ndis802_11AuthModeWPAPSK) && \n\t\t\t\t\t(AuthMode != Ndis802_11AuthModeWPA2PSK) && \n\t\t\t\t\t(AuthMode != Ndis802_11AuthModeWPANone)\n#ifdef WAPI_SUPPORT\n\t\t\t\t\t&& (AuthMode != Ndis802_11AuthModeWAICERT)\n\t\t\t\t\t&& (AuthMode != Ndis802_11AuthModeWAIPSK)\n#endif /* WAPI_SUPPORT */\n\t\t\t\t\t)\n\t\t\t\t\treturn;\n\t\t\t}\t\n\t\n\t\t\tDBGPRINT(RT_DEBUG_TRACE,(\"==> RTMPMakeRSNIE(STA)\\n\"));\n\n\t\t\t/* Zero RSNIE context */\n\t\t\tpAd->StaCfg.RSNIE_Len = 0;\n\t\t\tNdisZeroMemory(pAd->StaCfg.RSN_IE, MAX_LEN_OF_RSNIE);\n\n\t\t\t/* Pointer to RSNIE */\n\t\t\trsnielen_cur_p = &pAd->StaCfg.RSNIE_Len;\n\t\t\tpRsnIe = pAd->StaCfg.RSN_IE;\n\n\t\t\tbMixCipher = pAd->StaCfg.bMixCipher;\n\t\t\tbreak;\n\t\t}\n#endif /* CONFIG_STA_SUPPORT */\n\t} while(FALSE);\n\n\t/* indicate primary RSNIE as WPA or WPA2*/\n\tif ((AuthMode == Ndis802_11AuthModeWPA) || \n\t\t(AuthMode == Ndis802_11AuthModeWPAPSK) || \n\t\t(AuthMode == Ndis802_11AuthModeWPANone) || \n\t\t(AuthMode == Ndis802_11AuthModeWPA1WPA2) || \n\t\t(AuthMode == Ndis802_11AuthModeWPA1PSKWPA2PSK))\n\t\tPrimaryRsnie = WpaIe;\n#ifdef WAPI_SUPPORT\n\telse if ((AuthMode == Ndis802_11AuthModeWAICERT) || \n\t\t\t (AuthMode == Ndis802_11AuthModeWAIPSK))\n\t\tPrimaryRsnie = WapiIe;\n#endif /* WAPI_SUPPORT */\n\telse\n\t\tPrimaryRsnie = Wpa2Ie;\n\n#ifdef WAPI_SUPPORT\n\tif (PrimaryRsnie == WapiIe)\n\t{\n\t\tRTMPInsertWapiIe(AuthMode, WepStatus, pRsnIe, &p_offset);\n\t}\n\telse\n#endif /* WAPI_SUPPORT */\t\t\n\t{\n\t\t/* Build the primary RSNIE*/\n\t\t/* 1. insert cipher suite*/\n\t\tRTMPMakeRsnIeCipher(pAd, PrimaryRsnie, WepStatus, apidx, bMixCipher, FlexibleCipher, pRsnIe, &p_offset);\n\n\t\t/* 2. insert AKM*/\n\t\tRTMPMakeRsnIeAKM(pAd, PrimaryRsnie, AuthMode, apidx, pRsnIe, &p_offset);\n\n\t\t/* 3. insert capability*/\n\t\tRTMPMakeRsnIeCap(pAd, PrimaryRsnie, apidx, pRsnIe, &p_offset);\n\n#ifdef DOT11W_PMF_SUPPORT\n\t\t/* 4. Insert PMKID */\n\t\tRTMPInsertRsnIeZeroPMKID(pAd, PrimaryRsnie, apidx, pRsnIe, &p_offset);\n\n\t\t/* 5. Insert Group Management Cipher*/\n\t\tPMF_MakeRsnIeGMgmtCipher(pAd, PrimaryRsnie, apidx, pRsnIe, &p_offset);\n#endif /* DOT11W_PMF_SUPPORT */\n\t}\n\n\t/* 4. update the RSNIE length*/\n\tif (rsnielen_cur_p == NULL)\n\t{\n\t\tDBGPRINT(RT_DEBUG_ERROR, (\"%s: rsnielen_cur_p == NULL!\\n\", __FUNCTION__));\n\t\treturn;\n\t}\n\n\t*rsnielen_cur_p = p_offset; \n\n\thex_dump(\"The primary RSNIE\", pRsnIe, (*rsnielen_cur_p));\n\n#ifdef CONFIG_AP_SUPPORT\n\tif ((pAd->OpMode == OPMODE_AP)\n\t\t)\n\t{\n\t\t/* if necessary, build the secondary RSNIE*/\n\t\tif (bMixRsnIe)\n\t\t{\n\t\t\t/* 1. insert cipher suite*/\n\t\t\tRTMPMakeRsnIeCipher(pAd, Wpa2Ie, WepStatus, apidx, bMixCipher, FlexibleCipher, pRsnIe_ex, &s_offset);\n\n\t\t\t/* 2. insert AKM*/\n\t\t\tRTMPMakeRsnIeAKM(pAd, Wpa2Ie, AuthMode, apidx, pRsnIe_ex, &s_offset);\n\n\t\t\t/* 3. insert capability*/\n\t\t\tRTMPMakeRsnIeCap(pAd, Wpa2Ie, apidx, pRsnIe_ex, &s_offset);\n\n#ifdef DOT11W_PMF_SUPPORT\n\t\t\t/* 4. Insert PMKID */\n\t\t\tRTMPInsertRsnIeZeroPMKID(pAd, Wpa2Ie, apidx, pRsnIe_ex, &s_offset);\n\n\t\t\t/* 5. Insert Group Management Cipher*/\n\t\t\tPMF_MakeRsnIeGMgmtCipher(pAd, Wpa2Ie, apidx, pRsnIe_ex, &s_offset);\n#endif /* DOT11W_PMF_SUPPORT */\n\n\t\t\t/* Update the RSNIE length*/\n\t\t\t*rsnielen_ex_cur_p = s_offset; \n\n\t\t\thex_dump(\"The secondary RSNIE\", pRsnIe_ex, (*rsnielen_ex_cur_p));\n\t\t}\n\t}\n#endif /* CONFIG_AP_SUPPORT */\n\n}", "path": "lede/package/lean/mt/drivers/mt7612e/src/mt76x2/common/cmm_wpa.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "coolsnowwolf/lede", "stars": 28402, "license": "other", "language": "c", "size": 286238}
{"docstring": "/* Find specific IE Id in a buffer containing multiple IEs */\n", "func_signal": "const UCHAR *RTMPFindIE(UCHAR Eid, const UCHAR *Ies, INT32 Len)", "code": "{\n\twhile (Len > 2 && Ies[0] != Eid) {\n\t\tLen -= Ies[1] + 2;\n\t\tIes += Ies[1] + 2;\n\t}\n\tif (Len < 2)\n\t\treturn NULL;\n\tif (Len < 2 + Ies[1])\n\t\treturn NULL;\n\treturn Ies;\n}", "path": "lede/package/lean/mt/drivers/mt7612e/src/mt76x2/common/cmm_wpa.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "coolsnowwolf/lede", "stars": 28402, "license": "other", "language": "c", "size": 286238}
{"docstring": "/*\n\t========================================================================\n\t\n\tRoutine Description:\n\t\tProcess Pairwise key Msg-1 of 4-way handshaking and send Msg-2 \n\n\tArguments:\n\t\tpAd\t\t\tPointer\tto our adapter\n\t\tElem\t\tMessage body\n\t\t\n\tReturn Value:\n\t\tNone\n\t\t\n\tNote:\n\t\t\n\t========================================================================\n*/\n", "func_signal": "VOID PeerPairMsg1Action(\n\tIN PRTMP_ADAPTER    pAd, \n    IN MAC_TABLE_ENTRY  *pEntry,\n    IN MLME_QUEUE_ELEM  *Elem)", "code": "{\n\tUCHAR\t\t\t\tPTK[80];\n\tUCHAR               Header802_3[14];\n\tPEAPOL_PACKET\t\tpMsg1;\n\tUINT            \tMsgLen;\t\n\tUCHAR   \t\t\t*mpool;\n    PEAPOL_PACKET\t\tpEapolFrame;\n\tPUINT8\t\t\t\tpCurrentAddr = NULL;\n\tPUINT8\t\t\t\tpmk_ptr = NULL;\n\tUCHAR\t\t\t\tgroup_cipher = Ndis802_11WEPDisabled;\n\tPUINT8\t\t\t\trsnie_ptr = NULL;\n\tUCHAR\t\t\t\trsnie_len = 0;\n#ifdef MAC_REPEATER_SUPPORT\n\tUSHORT ifIndex = (USHORT)(Elem->Priv);\n\tUCHAR CliIdx = 0xFF;\n#endif /* MAC_REPEATER_SUPPORT */\n\t   \n\tDBGPRINT(RT_DEBUG_TRACE, (\"===> PeerPairMsg1Action \\n\"));\n\n\tif ((!pEntry) || (!IS_ENTRY_CLIENT(pEntry) && !IS_ENTRY_APCLI(pEntry)))\n\t\treturn;\n\n    if (Elem->MsgLen < (LENGTH_802_11 + LENGTH_802_1_H + LENGTH_EAPOL_H + MIN_LEN_OF_EAPOL_KEY_MSG))\n        return;\n\t\n#ifdef CONFIG_AP_SUPPORT\n\tIF_DEV_CONFIG_OPMODE_ON_AP(pAd)\n\t{\n#ifdef APCLI_SUPPORT\n\t\tif (IS_ENTRY_APCLI(pEntry))\n\t\t{\n\t\t\tUINT IfIndex = 0;\n\t\t\t\n\t\t\tIfIndex = pEntry->wdev_idx;\n#ifdef MAC_REPEATER_SUPPORT\n\t\t\tif (ifIndex >= 64)\n\t\t\t\tCliIdx = ((ifIndex - 64) % 16);\n#endif /* MAC_REPEATER_SUPPORT */\n\n\t\t\tif (IfIndex >= MAX_APCLI_NUM)\n\t\t\t\treturn;\n\n#ifdef MAC_REPEATER_SUPPORT\n\t\t\tif (CliIdx != 0xFF)\n\t\t\t\tpCurrentAddr = pAd->ApCfg.ApCliTab[IfIndex].RepeaterCli[CliIdx].CurrentAddress;\n\t\t\telse\n#endif /* MAC_REPEATER_SUPPORT */\n\t\t\tpCurrentAddr = pAd->ApCfg.ApCliTab[IfIndex].wdev.if_addr;\n\t\t\tpmk_ptr = pAd->ApCfg.ApCliTab[IfIndex].PMK;\n\t\t\tgroup_cipher = pAd->ApCfg.ApCliTab[IfIndex].GroupCipher;\n\t\t\trsnie_ptr = pAd->ApCfg.ApCliTab[IfIndex].RSN_IE;\n\t\t\trsnie_len = pAd->ApCfg.ApCliTab[IfIndex].RSNIE_Len;\n\t\t}\n#endif /* APCLI_SUPPORT */\t\t\t\n\t}\n#endif /* CONFIG_AP_SUPPORT */\n#ifdef CONFIG_STA_SUPPORT\n\tIF_DEV_CONFIG_OPMODE_ON_STA(pAd)\n\t{\t\t\t\t\n\t\t{\n\t\tpCurrentAddr = pAd->CurrentAddress;\n\t\tpmk_ptr = pAd->StaCfg.PMK;\n\t\tgroup_cipher = pAd->StaCfg.GroupCipher;\n\t\trsnie_ptr = pAd->StaCfg.RSN_IE;\n\t\trsnie_len = pAd->StaCfg.RSNIE_Len;\n\t}\n\t}\n#endif /* CONFIG_STA_SUPPORT */\n\n\tif (pCurrentAddr == NULL)\n\t\treturn;\n\n\t/* Store the received frame*/\n\tpMsg1 = (PEAPOL_PACKET) &Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];\n\tMsgLen = Elem->MsgLen - LENGTH_802_11 - LENGTH_802_1_H;\n\t\n\t/* Sanity Check peer Pairwise message 1 - Replay Counter*/\n\tif (PeerWpaMessageSanity(pAd, pMsg1, MsgLen, EAPOL_PAIR_MSG_1, pEntry) == FALSE)\n\t\treturn;\n\t\n\t/* Store Replay counter, it will use to verify message 3 and construct message 2*/\n\tNdisMoveMemory(pEntry->R_Counter, pMsg1->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY);\t\t\n\n\t/* Store ANonce*/\n\tNdisMoveMemory(pEntry->ANonce, pMsg1->KeyDesc.KeyNonce, LEN_KEY_DESC_NONCE);\n\t\t\n\t/* Generate random SNonce*/\n\tGenRandom(pAd, (UCHAR *)pCurrentAddr, pEntry->SNonce);\n\tpEntry->AllowInsPTK = TRUE;\n\tpEntry->LastGroupKeyId = 0;\n\tpEntry->AllowUpdateRSC = FALSE;\n\tNdisZeroMemory(pEntry->LastGTK, MAX_LEN_GTK);\n\n#ifdef DOT11R_FT_SUPPORT\t\n\tif (IS_FT_RSN_STA(pEntry))\n\t{\n#ifdef CONFIG_STA_SUPPORT\n\t\tIF_DEV_CONFIG_OPMODE_ON_STA(pAd)\n\t\t{\t\n\t\t\tUINT8\t\t\t\tptk_len;\n\t\t\n\t\t\tFT_DerivePMKR0(pmk_ptr, \n\t\t\t\t\t\t\tLEN_PMK, \n\t\t\t\t\t\t\t (PUINT8)pAd->CommonCfg.Ssid, \n\t\t\t\t\t\t\t pAd->CommonCfg.SsidLen, \n\t\t\t\t\t\t\t pAd->StaCfg.Dot11RCommInfo.MdIeInfo.MdId, \t\n\t\t\t\t\t\t\t pAd->StaCfg.Dot11RCommInfo.R0khId,\t\t\t\t\n\t\t\t\t\t\t\t pAd->StaCfg.Dot11RCommInfo.R0khIdLen,\t\t\t\n\t\t\t\t\t\t\t pCurrentAddr, \n\t\t\t\t\t\t\t pAd->StaCfg.Dot11RCommInfo.PMKR0, \n\t\t\t\t\t\t\t pAd->StaCfg.Dot11RCommInfo.PMKR0Name);\n\n\t\t\tFT_DerivePMKR1(pAd->StaCfg.Dot11RCommInfo.PMKR0, \n\t\t\t\t\t\t\t pAd->StaCfg.Dot11RCommInfo.PMKR0Name, \n\t\t\t\t\t\t\t pEntry->Addr, \n\t\t\t\t\t\t\t pCurrentAddr, \n\t\t\t\t\t\t\t pEntry->FT_PMK_R1, \n\t\t\t\t\t\t\t pEntry->FT_PMK_R1_NAME);\n\n\t\t\tif (pEntry->WepStatus == Ndis802_11TKIPEnable)\n\t\t\t\tptk_len = 32+32;\n\t\t\telse\n\t\t\t\tptk_len = 32+16;\n\n\t\t\tFT_DerivePTK(pEntry->FT_PMK_R1, \n\t\t\t\t\t\t   pEntry->FT_PMK_R1_NAME, \n\t\t\t\t\t\t   pEntry->ANonce, \n\t\t\t\t\t\t   pEntry->SNonce, \n\t\t\t\t\t\t   pAd->CommonCfg.Bssid, \n\t\t\t\t\t\t   pCurrentAddr, \n\t\t\t\t\t\t   ptk_len, \t\t\t\t\t\n\t\t\t\t\t\t   pEntry->PTK, \n\t\t\t\t\t\t   pEntry->PTK_NAME);\n\t\t\t\n\t\t}\n#endif /* CONFIG_STA_SUPPORT */\n\t}\n\telse\t\t\n#endif /* DOT11R_FT_SUPPORT */\n#ifdef DOT11W_PMF_SUPPORT\n        if ((CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_USE_SHA256)))\n        {\n\t\tPMF_DerivePTK(pAd,\n                        (UCHAR *)pmk_ptr,  \n                        pEntry->ANonce, \n                        pEntry->Addr, \n                        pEntry->SNonce,\n                        pCurrentAddr, \n                        PTK, \n                        LEN_AES_PTK);   /* Must is 48 bytes */\n\n                NdisMoveMemory(pEntry->PTK, PTK, LEN_AES_PTK);\n                hex_dump(\"PTK\", PTK, LEN_AES_PTK);\n        }\n        else\n#endif /* DOT11W_PMF_SUPPORT */\n\t{\n\t    /* Calculate PTK(ANonce, SNonce)*/\n\t    WpaDerivePTK(pAd,\n\t    \t\t\tpmk_ptr,\n\t\t\t     \tpEntry->ANonce,\n\t\t\t\t \tpEntry->Addr, \n\t\t\t\t \tpEntry->SNonce,\n\t\t\t\t \tpCurrentAddr, \n\t\t\t\t    PTK, \n\t\t\t\t    LEN_PTK);\n\n\t\t/* Save key to PTK entry*/\n\t\tNdisMoveMemory(pEntry->PTK, PTK, LEN_PTK);\n\t}\t\t    \n\t\t\n\t/* Update WpaState*/\n\tpEntry->WpaState = AS_PTKINIT_NEGOTIATING;\n\n\t/* Allocate memory for output*/\n\tos_alloc_mem(NULL, (PUCHAR *)&mpool, TX_EAPOL_BUFFER);\n\tif (mpool == NULL)\n    {\n        DBGPRINT(RT_DEBUG_ERROR, (\"!!!%s : no memory!!!\\n\", __FUNCTION__));\n        return;\n    }\n\n\tpEapolFrame = (PEAPOL_PACKET)mpool;\n\tNdisZeroMemory(pEapolFrame, TX_EAPOL_BUFFER);\n\n\t/* Construct EAPoL message - Pairwise Msg 2*/\n\t/*  EAPOL-Key(0,1,0,0,P,0,0,SNonce,MIC,DataKD_M2)*/\n\tConstructEapolMsg(pEntry,\n\t\t\t\t\t  group_cipher,\n\t\t\t\t\t  EAPOL_PAIR_MSG_2,  \n\t\t\t\t\t  0,\t\t\t\t/* DefaultKeyIdx*/\n\t\t\t\t\t  pEntry->SNonce,\n\t\t\t\t\t  NULL,\t\t\t\t/* TxRsc*/\n\t\t\t\t\t  NULL,\t\t\t\t/* GTK*/\n\t\t\t\t\t  (UCHAR *)rsnie_ptr,\n\t\t\t\t\t  rsnie_len,\n\t\t\t\t\t  pEapolFrame);\n\n\t/* Make outgoing frame*/\n\tMAKE_802_3_HEADER(Header802_3, pEntry->Addr, pCurrentAddr, EAPOL);\t\n\t\n\tRTMPToWirelessSta(pAd, pEntry, \n\t\t\t\t\t  Header802_3, sizeof(Header802_3), (PUCHAR)pEapolFrame, \n\t\t\t\t\t  CONV_ARRARY_TO_UINT16(pEapolFrame->Body_Len) + 4, TRUE);\n\n\tos_free_mem(NULL, mpool);\n\t\t\n\tDBGPRINT(RT_DEBUG_TRACE, (\"<=== PeerPairMsg1Action: send Msg2 of 4-way \\n\"));\n}", "path": "lede/package/lean/mt/drivers/mt7612e/src/mt76x2/common/cmm_wpa.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "coolsnowwolf/lede", "stars": 28402, "license": "other", "language": "c", "size": 286238}
{"docstring": "/*\n\t========================================================================\n\t\n\tRoutine Description:\n\t\tBuild capability in RSN-IE. \n\t\tIt only shall be called by RTMPMakeRSNIE. \n\n\tArguments:\n\t\tpAd\t\t\t-\tpointer to our pAdapter context\t\n    \tElementID\t-\tindicate the WPA1 or WPA2    \t\n\t\tapidx\t\t-\tindicate the interface index\n\t\t\n\tReturn Value:\n\t\t\n\tNote:\n\t\t\n\t========================================================================\n*/\n", "func_signal": "static VOID RTMPMakeRsnIeCap(\t\n\tIN  PRTMP_ADAPTER   pAd,\t\n\tIN\tUCHAR\t\t\tElementID,\n\tIN\tUCHAR\t\t\tapidx,\n\tOUT\tPUCHAR\t\t\tpRsnIe,\n\tOUT\tUCHAR\t\t\t*rsn_len)", "code": "{\n\tRSN_CAPABILITIES    *pRSN_Cap;\n\n\t/* it could be ignored in WPA1 mode*/\n\tif (ElementID == WpaIe)\n\t\treturn;\n\t\n\tpRSN_Cap = (RSN_CAPABILITIES*)(pRsnIe + (*rsn_len));\n\t\n#ifdef CONFIG_AP_SUPPORT\n\tIF_DEV_CONFIG_OPMODE_ON_AP(pAd)\n\t{\n\t\tif (apidx < pAd->ApCfg.BssidNum)\t\t\n\t\t{\n\t\t\tPMULTISSID_STRUCT pMbss = &pAd->ApCfg.MBSSID[apidx];\n\n#ifdef DOT1X_SUPPORT\n        \t\tpRSN_Cap->field.PreAuth = (pMbss->PreAuth == TRUE) ? 1 : 0;\n#endif /* DOT1X_SUPPORT */\n#ifdef DOT11W_PMF_SUPPORT\n                        pRSN_Cap->field.MFPC = (pMbss->PmfCfg.MFPC) ? 1 : 0;\n                        pRSN_Cap->field.MFPR = (pMbss->PmfCfg.MFPR) ? 1 : 0;\n                        DBGPRINT(RT_DEBUG_ERROR, (\"[PMF]%s: RSNIE Capability MFPC=%d, MFPR=%d\\n\", __FUNCTION__, pRSN_Cap->field.MFPC, pRSN_Cap->field.MFPR));\n#endif /* DOT11W_PMF_SUPPORT */\n\t\t}\n\t}\n#endif /* CONFIG_AP_SUPPORT */\n\n#ifdef CONFIG_STA_SUPPORT\n#ifdef DOT11W_PMF_SUPPORT\n\tIF_DEV_CONFIG_OPMODE_ON_STA(pAd)\n\t{\t\t\n                pRSN_Cap->field.MFPC = (pAd->StaCfg.PmfCfg.MFPC) ? 1 : 0;\n\t\tpRSN_Cap->field.MFPR = (pAd->StaCfg.PmfCfg.MFPR) ? 1 : 0;\n                DBGPRINT(RT_DEBUG_ERROR, (\"[PMF]%s: RSNIE Capability MFPC=%d, MFPR=%d\\n\", __FUNCTION__, pRSN_Cap->field.MFPC, pRSN_Cap->field.MFPR));\n\t}\n#endif /* DOT11W_PMF_SUPPORT */\n\n#endif /* CONFIG_STA_SUPPORT */\t\t\t      \n\t\t\t\t\t \n\tpRSN_Cap->word = cpu2le16(pRSN_Cap->word);\n\t\n\t(*rsn_len) += sizeof(RSN_CAPABILITIES);\t/* update current RSNIE length*/\n\n}", "path": "lede/package/lean/mt/drivers/mt7612e/src/mt76x2/common/cmm_wpa.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "coolsnowwolf/lede", "stars": 28402, "license": "other", "language": "c", "size": 286238}
{"docstring": "/*\n\t========================================================================\n\n\tRoutine\tDescription:\n\t\tCopy frame from waiting queue into relative ring buffer and set \n\tappropriate ASIC register to kick hardware encryption before really\n\tsent out to air.\n\t\t\n\tArguments:\n\t\tpAd\t\tPointer\tto our adapter\n\t\tPNDIS_PACKET\tPointer to outgoing Ndis frame\n\t\tNumberOfFrag\tNumber of fragment required\n\t\t\n\tReturn Value:\n\t\tNone\n\n\tNote:\n\t\n\t========================================================================\n*/\n", "func_signal": "VOID RTMPToWirelessSta(\n    IN PRTMP_ADAPTER pAd,\n    IN PMAC_TABLE_ENTRY pEntry,\n    IN PUCHAR pHeader802_3,\n    IN UINT HdrLen,\n    IN PUCHAR pData,\n    IN UINT DataLen,\n    IN BOOLEAN bClearFrame)", "code": "{\n    PNDIS_PACKET pPacket;\n    NDIS_STATUS Status;\n\n\tif ((!pEntry) || (!IS_ENTRY_CLIENT(pEntry) && !IS_ENTRY_APCLI(pEntry)\n#if defined(DOT11Z_TDLS_SUPPORT) || defined(CFG_TDLS_SUPPORT)\n\t\t && (!IS_ENTRY_TDLS(pEntry))\n#endif /* defined(DOT11Z_TDLS_SUPPORT) || defined(CFG_TDLS_SUPPORT) */\n\t))\n\t\treturn;\n\n\tdo {\n        \tStatus = RTMPAllocateNdisPacket(pAd, &pPacket, pHeader802_3, HdrLen, pData, DataLen);\n        \tif (Status != NDIS_STATUS_SUCCESS)\n\t\t\tbreak;\n\n        \n\t\tif (bClearFrame)\n\t\t\tRTMP_SET_PACKET_CLEAR_EAP_FRAME(pPacket, 1);\n\t\telse\n\t\t\tRTMP_SET_PACKET_CLEAR_EAP_FRAME(pPacket, 0);\n\n#ifdef CONFIG_AP_SUPPORT\t\t\n#ifdef APCLI_SUPPORT\n\t\tif (IS_ENTRY_APCLI(pEntry))\n\t\t{\n\t\t\tRTMP_SET_PACKET_NET_DEVICE_APCLI(pPacket, pEntry->apidx);\n\t\t}\n\t\telse\n#endif /* APCLI_SUPPORT */\n#endif /* CONFIG_AP_SUPPORT */\n\t\t{\n\t\t}\n\n\t\tRTMP_SET_PACKET_NET_DEVICE_MBSSID(pPacket, MAIN_MBSSID);\t/* set a default value*/\n\t\tif(pEntry->apidx != 0)\n\t\t\tRTMP_SET_PACKET_NET_DEVICE_MBSSID(pPacket, pEntry->apidx);\n\n\t\tRTMP_SET_PACKET_WCID(pPacket, (UCHAR)pEntry->wcid);\n\t\tRTMP_SET_PACKET_MOREDATA(pPacket, FALSE);\n\n#ifdef CONFIG_AP_SUPPORT\n\t\tIF_DEV_CONFIG_OPMODE_ON_AP(pAd)\n\t\t{\n\t\t\t/* send out the packet */\n\t\t\tAPSendPacket(pAd, pPacket);\n\n\t\t\t/* Dequeue outgoing frames from TxSwQueue0..3 queue and process it*/\n\t\t\tRTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);\n\t\t}\n#endif /* CONFIG_AP_SUPPORT */\n#ifdef CONFIG_STA_SUPPORT\n\t\tIF_DEV_CONFIG_OPMODE_ON_STA(pAd)\n\t\t{\n\t\t\t/* send out the packet*/\n\t\t\tStatus = STASendPacket(pAd, pPacket);\n\t\t\tif (Status == NDIS_STATUS_SUCCESS)\n\t\t\t{\n\t\t\t\tUCHAR   Index;\n\t\t\t\t\n\t\t\t\t/* Dequeue one frame from TxSwQueue0..3 queue and process it*/\n\t\t\t\t/* There are three place calling dequeue for TX ring.*/\n\t\t\t\t/* 1. Here, right after queueing the frame.*/\n\t\t\t\t/* 2. At the end of TxRingTxDone service routine.*/\n\t\t\t\t/* 3. Upon NDIS call RTMPSendPackets*/\n\t\t\t\tif((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) && \n\t\t\t\t\t(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)))\n\t\t\t\t{\n\t\t\t\t\tRTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif /* CONFIG_STA_SUPPORT */\n  \n    } while (FALSE);\n}", "path": "lede/package/lean/mt/drivers/mt7612e/src/mt76x2/common/cmm_wpa.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "coolsnowwolf/lede", "stars": 28402, "license": "other", "language": "c", "size": 286238}
{"docstring": "/*\n\t========================================================================\n\n\tRoutine Description:\n\t\tSome received frames can't decrypt by Asic, so decrypt them by software.  \n\n\tArguments:\n\t\tpAd\t\t\t\t-\tpointer to our pAdapter context\t\n    \tPeerWepStatus\t-\tindicate the encryption type    \t\t\t \n\n\tReturn Value:\n\t\tNDIS_STATUS_SUCCESS\t\t-\tdecryption successful\t\n\t\tNDIS_STATUS_FAILURE\t\t-\tdecryption failure\n\t\t\n\t========================================================================\n*/\n", "func_signal": "NDIS_STATUS\tRTMPSoftDecryptionAction(\n\tIN\tPRTMP_ADAPTER\t\tpAd,\n\tIN \t\tPUCHAR\t\t\tpHdr,\n\tIN \t\tUCHAR    \t\tUserPriority,\n\tIN \t\tPCIPHER_KEY\t\tpKey,\n\tINOUT \tPUCHAR\t\t\tpData,\n\tINOUT \tUINT16\t\t\t*DataByteCnt)", "code": "{\t\t\n\tNDIS_STATUS NStatus;\n\tNStatus =0;\n\t\n\tswitch (pKey->CipherAlg)\n    {    \t        \t        \n\t\tcase CIPHER_WEP64:\n\t\tcase CIPHER_WEP128:\n\t\t\t/* handle WEP decryption */\n\t\t\tif (RTMPSoftDecryptWEP(pAd, pKey, pData, &(*DataByteCnt)) == FALSE)\t\t\n\t\t\t{\n\t\t\t\tDBGPRINT(RT_DEBUG_ERROR, (\"ERROR : SW decrypt WEP data fails.\\n\"));\t\n\t\t\t\t/* give up this frame*/\n\t\t\t\treturn NDIS_STATUS_FAILURE; \n\t\t\t}        \t\t\t\t\t\t\t\t\t\t\t\n\t\t\tbreak;\n\t\t\t\n\t\tcase CIPHER_TKIP:\n\t\t\t/* handle TKIP decryption */\n\t\t\tNStatus = RTMPSoftDecryptTKIP(pAd, pHdr, UserPriority, pKey, pData, &(*DataByteCnt));\n\t\t\tif (NStatus == NDIS_STATUS_FAILURE)\n\t\t\t{\n\t\t\t\tDBGPRINT(RT_DEBUG_ERROR, (\"ERROR : SW decrypt TKIP data fails.\\n\"));\n\t\t\t\t/* give up this frame*/\n\t\t\t\treturn NDIS_STATUS_FAILURE; \n\t\t\t}        \t\t\t\t\t\t\t\t\t\t\t\n\t\t\telse if (NStatus == NDIS_STATUS_MICERROR)\n\t\t\t{\n\t\t\t\tDBGPRINT(RT_DEBUG_ERROR, (\"ERROR : SW decrypt TKIP data mic error.\\n\"));\n\t\t\t\t/* give up this frame*/\n\t\t\t\treturn NDIS_STATUS_MICERROR; \n\t\t\t}           \t\t\t\t\t\t\t\t\t\t\t\n\t\t\tbreak;\n\t\t\t\n\t\tcase CIPHER_AES:\n\t\t\t/* handle AES decryption */\n\t\t\tif (RTMPSoftDecryptCCMP(pAd, pHdr, pKey, pData, &(*DataByteCnt)) == FALSE)\n\t\t\t{\n\t\t\t\tDBGPRINT(RT_DEBUG_ERROR, (\"ERROR : SW decrypt AES data fails.\\n\"));\n\t\t\t\t/* give up this frame*/\n\t\t\t\treturn NDIS_STATUS_FAILURE; \n        \t}\n\t\t\tbreak;\n#ifdef WAPI_SUPPORT\n#ifdef SOFT_ENCRYPT\n\t\tcase CIPHER_SMS4:\n\t\t\t{\n\t\t\t\tINT\tret;\n#ifdef RT_BIG_ENDIAN\n\t\t\t\tRTMPFrameEndianChange(pAd, pHdr, DIR_READ, FALSE);\n#endif\t\t\t\t\n\t\t\t\tif ((ret = RTMPSoftDecryptSMS4(pHdr, FALSE, pKey, pData, &(*DataByteCnt))) != STATUS_SUCCESS)\n\t\t\t\t{\n\t\t\t\t\tDBGPRINT(RT_DEBUG_ERROR, (\"ERROR : SW decrypt SMS4 data fails(%d).\\n\", ret));\n\t\t\t\t\t/* give up this frame*/\n\t\t\t\t\treturn NDIS_STATUS_FAILURE;  \n\t\t\t\t}\n#ifdef RT_BIG_ENDIAN\n\t\t\t\tRTMPFrameEndianChange(pAd, pHdr, DIR_READ, FALSE);\n#endif\t\t\t\t\n\t\t\t}\n\t\t\tbreak;\n#endif /* SOFT_ENCRYPT */\t\t\t\n#endif /* WAPI_SUPPORT */\t\t\t\n\t\tdefault:\n\t\t\t/* give up this frame*/\n\t\t\treturn NDIS_STATUS_FAILURE;  \n\t\t\tbreak;\t\t\t\n\t}\t\n\n\treturn NDIS_STATUS_SUCCESS;\n\t\t\n}", "path": "lede/package/lean/mt/drivers/mt7612e/src/mt76x2/common/cmm_wpa.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "coolsnowwolf/lede", "stars": 28402, "license": "other", "language": "c", "size": 286238}
{"docstring": "/*\n    ==========================================================================\n    Description:\n        When receiving the last packet of 2-way groupkey handshake.\n    Return:\n    ==========================================================================\n*/\n", "func_signal": "VOID PeerGroupMsg2Action(\n    IN PRTMP_ADAPTER    pAd, \n    IN MAC_TABLE_ENTRY  *pEntry,\n    IN VOID             *Msg,\n    IN UINT             MsgLen)", "code": "{\n    UINT            \tLen;\n    PUCHAR          \tpData;\n    BOOLEAN         \tCancelled;\n\tPEAPOL_PACKET       pMsg2;\t\n\tUCHAR\t\t\t\tgroup_cipher = Ndis802_11WEPDisabled;\t\n\n\tDBGPRINT(RT_DEBUG_TRACE, (\"===> PeerGroupMsg2Action \\n\"));\n\n    if ((!pEntry) || !IS_ENTRY_CLIENT(pEntry))\n        return;\n            \n    if (MsgLen < (LENGTH_802_1_H + LENGTH_EAPOL_H + MIN_LEN_OF_EAPOL_KEY_MSG))\n        return;\n            \n    if (pEntry->WpaState != AS_PTKINITDONE)\n        return;\n\n\n    do\n    {\n\n#ifdef CONFIG_AP_SUPPORT\n\t\tIF_DEV_CONFIG_OPMODE_ON_AP(pAd)\n\t\t{\n\t\t\tUCHAR\tapidx = 0;\n\t\t\n\t\t\tif (pEntry->apidx >= pAd->ApCfg.BssidNum)\n\t\t\t\treturn;\n\t\t    else\n\t\t\t\tapidx = pEntry->apidx;\t\n\n\t\t\tgroup_cipher = pAd->ApCfg.MBSSID[apidx].wdev.GroupKeyWepStatus;\n\t\t}\n#endif /* CONFIG_AP_SUPPORT */\n        \n        pData = (PUCHAR)Msg;\n\t\tpMsg2 = (PEAPOL_PACKET) (pData + LENGTH_802_1_H);\n        Len = MsgLen - LENGTH_802_1_H;\n\n\t\t/* Sanity Check peer group message 2 - Replay Counter, MIC*/\n\t\tif (PeerWpaMessageSanity(pAd, pMsg2, Len, EAPOL_GROUP_MSG_2, pEntry) == FALSE)\n            break;\n\n        /* 3.  upgrade state*/\n\n\t\tRTMPCancelTimer(&pEntry->RetryTimer, &Cancelled);\n        pEntry->GTKState = REKEY_ESTABLISHED;\n        \n\t\tif ((pEntry->AuthMode == Ndis802_11AuthModeWPA2) || (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK))\n\t\t{\n\t\t\t/* send wireless event - for set key done WPA2*/\n\t\t\t\tRTMPSendWirelessEvent(pAd, IW_SET_KEY_DONE_WPA2_EVENT_FLAG, pEntry->Addr, pEntry->apidx, 0); \n\n\t\t\tDBGPRINT(RT_DEBUG_OFF, (\"AP SETKEYS DONE - WPA2, AuthMode(%d)=%s, WepStatus(%d)=%s, GroupWepStatus(%d)=%s\\n\\n\", \n\t\t\t\t\t\t\t\t\t\tpEntry->AuthMode, GetAuthMode(pEntry->AuthMode), \n\t\t\t\t\t\t\t\t\t\tpEntry->WepStatus, GetEncryptType(pEntry->WepStatus), \n\t\t\t\t\t\t\t\t\t\tgroup_cipher, GetEncryptType(group_cipher)));\n\t\t}\n\t\telse\n\t\t{\n#ifdef MWDS\n\t\t\tif((pEntry->PortSecured == WPA_802_1X_PORT_SECURED))\n\t\t\t{\n\t\t\t\tMWDSProxyEntryDelete(pAd,pEntry->Addr);\n\t\t\t\tif(pEntry->bEnableMWDS)\n\t\t\t\t{\n\t\t\t\t\tSET_MWDS_OPMODE_AP(pEntry);\n\t\t\t\t\tMWDSConnEntryUpdate(pAd,pEntry->wcid);\n\t\t\t\t\tDBGPRINT(RT_DEBUG_ERROR, (\"SET_MWDS_OPMODE_AP OK!\\n\"));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tSET_MWDS_OPMODE_NONE(pEntry);\n\t\t\t}\n#endif /* MWDS */\n\n\t\t\t/* send wireless event - for set key done WPA*/\n\t\t\t\tRTMPSendWirelessEvent(pAd, IW_SET_KEY_DONE_WPA1_EVENT_FLAG, pEntry->Addr, pEntry->apidx, 0); \n\n#ifdef SMART_MESH_MONITOR\n\t\t\tif (pEntry->PortSecured == WPA_802_1X_PORT_SECURED)\n\t\t\t{\n\t\t\t\tstruct nsmpif_drvevnt_buf drvevnt;\n\t\t\t\tdrvevnt.data.join.type = NSMPIF_DRVEVNT_STA_JOIN;\n\t\t\t\tdrvevnt.data.join.channel = pAd->CommonCfg.Channel;\n\t\t\t\tNdisCopyMemory(drvevnt.data.join.sta_mac, pEntry->Addr, MAC_ADDR_LEN);\n\t\t\t\tdrvevnt.data.join.aid= pEntry->Aid;\n\t\t\t\tRtmpOSWrielessEventSend(pAd->net_dev, RT_WLAN_EVENT_CUSTOM,NSMPIF_DRVEVNT_STA_JOIN,\n\t\t\t\t\t\t\t\t\t\tNULL, (PUCHAR)&drvevnt.data.join, sizeof(drvevnt.data.join));\n\t\t\t}\n#endif /* SMART_MESH_MONITOR */\n\n        \tDBGPRINT(RT_DEBUG_OFF, (\"AP SETKEYS DONE - WPA1, AuthMode(%d)=%s, WepStatus(%d)=%s, GroupWepStatus(%d)=%s\\n\\n\", \n\t\t\t\t\t\t\t\t\t\tpEntry->AuthMode, GetAuthMode(pEntry->AuthMode), \n\t\t\t\t\t\t\t\t\t\tpEntry->WepStatus, GetEncryptType(pEntry->WepStatus), \n\t\t\t\t\t\t\t\t\t\tgroup_cipher, GetEncryptType(group_cipher)));\n\t\t}\t\n    }while(FALSE);  \n}", "path": "lede/package/lean/mt/drivers/mt7612e/src/mt76x2/common/cmm_wpa.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "coolsnowwolf/lede", "stars": 28402, "license": "other", "language": "c", "size": 286238}
{"docstring": "/*\n    ==========================================================================\n    Description:\n        When receiving the last packet of 4-way pairwisekey handshake.\n        Initilize 2-way groupkey handshake following.\n    Return:\n    ==========================================================================\n*/\n", "func_signal": "VOID PeerPairMsg4Action(\n    IN PRTMP_ADAPTER    pAd, \n    IN MAC_TABLE_ENTRY  *pEntry,\n    IN MLME_QUEUE_ELEM  *Elem)", "code": "{    \n\tPEAPOL_PACKET   \tpMsg4;    \n\tUINT            \tMsgLen;\n\tBOOLEAN             Cancelled;\n\tUCHAR\t\t\t\tgroup_cipher = Ndis802_11WEPDisabled;\n\n    DBGPRINT(RT_DEBUG_TRACE, (\"===> PeerPairMsg4Action\\n\"));\n\n    do\n    {\n        if ((!pEntry) || !IS_ENTRY_CLIENT(pEntry))\n            break;\n\t\t\n        if (Elem->MsgLen < (LENGTH_802_11 + LENGTH_802_1_H + LENGTH_EAPOL_H + MIN_LEN_OF_EAPOL_KEY_MSG ) )\n            break;\n\n        if (pEntry->WpaState < AS_PTKINIT_NEGOTIATING)\n            break;\n\n#ifdef CONFIG_AP_SUPPORT\n\t\tIF_DEV_CONFIG_OPMODE_ON_AP(pAd)\n\t\t{\n\t\t\tUCHAR apidx = 0;\n\t\t\n\t\t\tif (pEntry->apidx >= pAd->ApCfg.BssidNum)\n\t\t\t\tbreak;\n\t\t    else\n\t\t\t\tapidx = pEntry->apidx;\t\n\n\t\t\tgroup_cipher = pAd->ApCfg.MBSSID[apidx].wdev.GroupKeyWepStatus;\n\t\t}\n#endif /* CONFIG_AP_SUPPORT */\n\n\t\t/* skip 802.11_header(24-byte) and LLC_header(8) */\n\t\tpMsg4 = (PEAPOL_PACKET)&Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H]; \n\t\tMsgLen = Elem->MsgLen - LENGTH_802_11 - LENGTH_802_1_H;\n\n        /* Sanity Check peer Pairwise message 4 - Replay Counter, MIC*/\n\t\tif (PeerWpaMessageSanity(pAd, pMsg4, MsgLen, EAPOL_PAIR_MSG_4, pEntry) == FALSE)\n\t\t\tbreak;\n\n        /* 3. Install pairwise key */\n\t\tWPAInstallPairwiseKey(pAd, pEntry->apidx, pEntry, TRUE);\n        \n        /* 4. upgrade state */\n        pEntry->PrivacyFilter = Ndis802_11PrivFilterAcceptAll;\n        pEntry->WpaState = AS_PTKINITDONE;\n\t\tpEntry->PortSecured = WPA_802_1X_PORT_SECURED;\n        \n#ifdef WSC_AP_SUPPORT\n        if (pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.WscConfMode != WSC_DISABLE)\n            WscInformFromWPA(pEntry);\n#endif /* WSC_AP_SUPPORT */\n\n\t\tif (pEntry->AuthMode == Ndis802_11AuthModeWPA2 || \n\t\t\tpEntry->AuthMode == Ndis802_11AuthModeWPA2PSK)\n\t\t{\n\t\t\tpEntry->GTKState = REKEY_ESTABLISHED;\n\t\t\tRTMPCancelTimer(&pEntry->RetryTimer, &Cancelled);\n\n#ifdef CONFIG_AP_SUPPORT\n#ifdef DOT11R_FT_SUPPORT\n\t\t\tif (IS_FT_RSN_STA(pEntry))\n\t\t\t{\n\t\t\t\tPFT_R1HK_ENTRY pR1khEntry;\t\t\n\t\t\t\tPUINT8 \tpUCipher = NULL;\n\t\t\t\tPUINT8\tpAkm = NULL;\n\t\t\t\tUINT8\tcount;\n\n\t\t\t\tpUCipher = WPA_ExtractSuiteFromRSNIE(pEntry->RSN_IE, pEntry->RSNIE_Len, PAIRWISE_SUITE, &count);\n\t\t\t\tpAkm = WPA_ExtractSuiteFromRSNIE(pEntry->RSN_IE, pEntry->RSNIE_Len, AKM_SUITE, &count);\n\t\t\t\t\n\t\t\t\t/* Record the PMK-R0 related information */\n\t\t\t\tRTMPAddPMKIDCache(pAd, \n\t\t\t\t\t\t\t\t  pEntry->apidx, \n\t\t\t\t\t\t\t\t  pEntry->Addr, \n\t\t\t\t\t\t\t\t  pEntry->FT_PMK_R0_NAME, \n\t\t\t\t\t\t\t\t  pEntry->FT_PMK_R0);\n\t\t\t\t\n\t\t\t\t/* Delete previous entry */\n\t\t\t\tpR1khEntry = FT_R1khEntryTabLookup(pAd, pEntry->FT_PMK_R1_NAME);\n\t\t\t\tif (pR1khEntry != NULL)\n\t\t\t\t{\n\t\t\t\t\tFT_R1khEntryDelete(pAd, pR1khEntry);\n\t\t\t\t}\n\t\t\t\t/* Update R1KH table */\n\t\t\t\tif (pUCipher != NULL)\n\t\t\t\t\tNdisMoveMemory(pEntry->FT_UCipher, pUCipher, 4);\n\t\t\t\tif (pAkm != NULL)\n\t\t\t\t\tNdisMoveMemory(pEntry->FT_Akm, pAkm, 4);\n\n\t\t\t\tFT_R1khEntryInsert(pAd, \n\t\t\t\t\t\t\t\t   pEntry->FT_PMK_R0_NAME, \n\t\t\t\t\t\t\t\t   pEntry->FT_PMK_R1_NAME, \n\t\t\t\t\t\t\t\t   pEntry->FT_PMK_R1, \n\t\t\t\t\t\t\t\t   pUCipher, \n\t\t\t\t\t\t\t\t   pAkm, \n\t\t\t\t\t\t\t\t   (pAd->ApCfg.MBSSID[pEntry->apidx].PMKCachePeriod/OS_HZ), \n\t\t\t\t\t\t\t\t   20, \n\t\t\t\t\t\t\t\t   pAd->ApCfg.MBSSID[pEntry->apidx].FtCfg.FtR0khId, \n\t\t\t\t\t\t\t\t   pAd->ApCfg.MBSSID[pEntry->apidx].FtCfg.FtR0khIdLen, \n\t\t\t\t\t\t\t\t   pEntry->Addr);\n\t\t\t\t\n#ifdef IAPP_SUPPORT\n\t\t\t\t{\t\n\t\t\t\t\tFT_KDP_EVT_ASSOC EvtAssoc;\n\n\t\t\t\t\tEvtAssoc.SeqNum = 0;\n\t\t\t\t\tNdisMoveMemory(EvtAssoc.MacAddr, pEntry->Addr, MAC_ADDR_LEN);\n\n\t\t\t\t\tFT_KDP_EVENT_INFORM(pAd, \n\t\t\t\t\t\t\t\t\t\tpEntry->apidx, \n\t\t\t\t\t\t\t\t\t\tFT_KDP_SIG_FT_ASSOCIATION,\n\t\t\t\t\t\t\t\t\t\t&EvtAssoc, \n\t\t\t\t\t\t\t\t\t\tsizeof(EvtAssoc), \n\t\t\t\t\t\t\t\t\t\tNULL);\n\t\t\t\t}\t\n#endif /* IAPP_SUPPORT \t\t\t\t*/\n\n\t\t\t\tpR1khEntry = FT_R1khEntryTabLookup(pAd, pEntry->FT_PMK_R1_NAME);\n\t\t\t\tif (pR1khEntry != NULL)\n\t\t\t\t{\n\t\t\t\t\tpR1khEntry->AuthMode = pEntry->AuthMode;\n\t\t\t\t\thex_dump(\"R1KHTab-R0KHID\", pR1khEntry->R0khId, pR1khEntry->R0khIdLen);\n\t\t\t\t\thex_dump(\"R1KHTab-PairwiseCipher\", pR1khEntry->PairwisChipher, 4);\n\t\t\t\t\thex_dump(\"R1KHTab-AKM\", pR1khEntry->AkmSuite, 4);\n\t\t\t\t\thex_dump(\"R1KHTab-PMKR0Name\", pR1khEntry->PmkR0Name, 16);\n\t\t\t\t\thex_dump(\"R1KHTab-PMKR1Name\", pR1khEntry->PmkR1Name, 16);\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDBGPRINT(RT_DEBUG_WARN, (\"The entry in R1KH table doesn't exist\\n\"));\n\t\t\t\t}\t\t\t\t\t\t\t \t\t\t\n\t\t\t}\t\n\t\t\telse\n#endif /* DOT11R_FT_SUPPORT */\n#ifdef DOT1X_SUPPORT\n\t\t\tif (pEntry->AuthMode == Ndis802_11AuthModeWPA2)\n        \t{\n        \t\tUCHAR  PMK_key[20];\n\t\t\t\tUCHAR  digest[80];\n\t\t\t\n\t\t\t\t/* Calculate PMKID, refer to IEEE 802.11i-2004 8.5.1.2*/\n\t\t\t\tNdisMoveMemory(&PMK_key[0], \"PMK Name\", 8);\n\t\t\t\tNdisMoveMemory(&PMK_key[8], pAd->ApCfg.MBSSID[pEntry->apidx].wdev.bssid, MAC_ADDR_LEN);\n\t\t\t\tNdisMoveMemory(&PMK_key[14], pEntry->Addr, MAC_ADDR_LEN);\n\t\t\t\tRT_HMAC_SHA1(pAd->ApCfg.MBSSID[pEntry->apidx].PMK, PMK_LEN, PMK_key, 20, digest, SHA1_DIGEST_SIZE);\n\t\t\t\tRTMPAddPMKIDCache(pAd, pEntry->apidx, pEntry->Addr, digest, pAd->ApCfg.MBSSID[pEntry->apidx].PMK);\n\t\t\t\tDBGPRINT(RT_DEBUG_TRACE, (\"Calc PMKID=%02x:%02x:%02x:%02x:%02x:%02x\\n\", digest[0],digest[1],digest[2],digest[3],digest[4],digest[5]));\n        \t}\n#endif /* DOT1X_SUPPORT */\t\t\t\n#ifdef MWDS\n\t\t\tif((pEntry->PortSecured == WPA_802_1X_PORT_SECURED))\n\t\t\t{\n\t\t\t\tMWDSProxyEntryDelete(pAd,pEntry->Addr);\n\t\t\t\tif(pEntry->bEnableMWDS)\n\t\t\t\t{\n\t\t\t\t\tSET_MWDS_OPMODE_AP(pEntry);\n\t\t\t\t\tMWDSConnEntryUpdate(pAd,pEntry->wcid);\n\t\t\t\t\tDBGPRINT(RT_DEBUG_ERROR, (\"SET_MWDS_OPMODE_AP OK!\\n\"));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tSET_MWDS_OPMODE_NONE(pEntry);\n\t\t\t}\n#endif /* MWDS */\n#ifdef SMART_MESH_MONITOR\n\t\t\tif (pEntry->PortSecured == WPA_802_1X_PORT_SECURED)\n\t\t\t{\n\t\t\t\tstruct nsmpif_drvevnt_buf drvevnt;\n\t\t\t\tdrvevnt.data.join.type = NSMPIF_DRVEVNT_STA_JOIN;\n\t\t\t\tdrvevnt.data.join.channel = pAd->CommonCfg.Channel;\n\t\t\t\tNdisCopyMemory(drvevnt.data.join.sta_mac, pEntry->Addr, MAC_ADDR_LEN);\n\t\t\t\tdrvevnt.data.join.aid= pEntry->Aid;\n\t\t\t\tRtmpOSWrielessEventSend(pAd->net_dev, RT_WLAN_EVENT_CUSTOM,NSMPIF_DRVEVNT_STA_JOIN,\n\t\t\t\t\t\t\t\t\t\tNULL, (PUCHAR)&drvevnt.data.join, sizeof(drvevnt.data.join));\n\t\t\t}\n#endif /* SMART_MESH_MONITOR */\t\t\t\n#endif /* CONFIG_AP_SUPPORT */\n\n\t\t\t/* send wireless event - for set key done WPA2*/\n\t\t\t\tRTMPSendWirelessEvent(pAd, IW_SET_KEY_DONE_WPA2_EVENT_FLAG, pEntry->Addr, pEntry->apidx, 0); \n#ifdef CONFIG_HOTSPOT_R2\n\t\tif (pEntry->IsWNMReqValid == TRUE)\n\t\t{\n\t\t\tstruct wnm_req_data *req_data = pEntry->ReqData;\n\t\t\tSend_WNM_Notify_Req(pAd,\n\t\t\t\t     req_data->peer_mac_addr,\n\t\t\t\t     req_data->wnm_req,\n\t\t\t\t     req_data->wnm_req_len,\n\t\t\t\t     req_data->type);\n\n\t\t\tpEntry->IsWNMReqValid = FALSE;\n\t\t\tos_free_mem(NULL, req_data); \n\t\t\tprintk(\"!!!!msg 4 send wnm req\\n\");\n\t\t}\n\t\tif (pEntry->IsBTMReqValid == TRUE)\n\t\t{\n\t\t\tstruct btm_req_data *req_data = pEntry->ReqbtmData;\n\t\t\tSend_BTM_Req(pAd,\n\t\t\t\t     req_data->peer_mac_addr,\n\t\t\t\t     req_data->btm_req,\n\t\t\t\t     req_data->btm_req_len);\n\n\t\t\tpEntry->IsBTMReqValid = FALSE;\n\t\t\tos_free_mem(NULL, req_data); \n\t\t\tprintk(\"!!!!msg 4 send btm req\\n\");\n\t\t}\n#endif\t \n\t \n\t \n\t        DBGPRINT(RT_DEBUG_OFF, (\"AP SETKEYS DONE - WPA2, AuthMode(%d)=%s, WepStatus(%d)=%s, GroupWepStatus(%d)=%s\\n\\n\", \n\t\t\t\t\t\t\t\t\tpEntry->AuthMode, GetAuthMode(pEntry->AuthMode), \n\t\t\t\t\t\t\t\t\tpEntry->WepStatus, GetEncryptType(pEntry->WepStatus), \n\t\t\t\t\t\t\t\t\tgroup_cipher, \n\t\t\t\t\t\t\t\t\tGetEncryptType(group_cipher)));\n\t\t}\n\t\telse\n\t\t{\n        \t/* 5. init Group 2-way handshake if necessary.*/\n\t        WPAStart2WayGroupHS(pAd, pEntry);\n\n        \tpEntry->ReTryCounter = GROUP_MSG1_RETRY_TIMER_CTR;\n        \t/* retry timer is set inside WPAStart2WayGroupHS */\n\t\t\t//RTMPModTimer(&pEntry->RetryTimer, PEER_MSG3_RETRY_EXEC_INTV);\n\t\t}\n    }while(FALSE);\n    \n}", "path": "lede/package/lean/mt/drivers/mt7612e/src/mt76x2/common/cmm_wpa.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "coolsnowwolf/lede", "stars": 28402, "license": "other", "language": "c", "size": 286238}
{"docstring": "/*\n\t========================================================================\n\t\n\tRoutine Description:\n\n\tArguments:\n\t\t\n\tReturn Value:\n\t\t\n\tNote:\n\t\t\n\t========================================================================\n*/\n", "func_signal": "VOID RTMPDerivePMKID(\n\tIN\tPUINT8\t\t\tpAaddr,\n\tIN\tPUINT8\t\t\tpSpaddr,\n\tIN\tPUINT8\t\t\tpKey,\n\tIN\tPUINT8\t\t\tpAkm_oui,\n\tOUT\tPUINT8\t\t\tpPMKID)", "code": "{\n\tUCHAR\tdigest[80], text_buf[20];\n\tUINT8\ttext_len;\n\t\t\t\n\t/* Concatenate the text for PMKID calculation*/\n\tNdisMoveMemory(&text_buf[0], \"PMK Name\", 8);\t\n\tNdisMoveMemory(&text_buf[8], pAaddr, MAC_ADDR_LEN);\n\tNdisMoveMemory(&text_buf[14], pSpaddr, MAC_ADDR_LEN);\n\ttext_len = 20;\n\n#ifdef DOT11W_PMF_SUPPORT\n/* todo pmf*/\n\t/* \tWhen the negotiated AKM is 00-0F-AC:5 or 00-0F-AC:6,\n\t\tHMAC-SHA-256 is used to calculate the PMKID */\n\tif (NdisEqualMemory(pAkm_oui, OUI_PMF_8021X_AKM, 4) ||\n\t\tNdisEqualMemory(pAkm_oui, OUI_PMF_PSK_AKM, 4))\n\t{\n\t\tRT_HMAC_SHA256(pKey, PMK_LEN, text_buf, text_len, digest, SHA256_DIGEST_SIZE);\n\t}\n\telse\t\t\n#endif /* DOT11W_PMF_SUPPPORT */\n\t{\n\t\tRT_HMAC_SHA1(pKey, PMK_LEN, text_buf, text_len, digest, SHA1_DIGEST_SIZE);\n\t}\n\n\t/* Truncate the first 128-bit of output result */\n\tNdisMoveMemory(pPMKID, digest, LEN_PMKID);\n\n}", "path": "lede/package/lean/mt/drivers/mt7612e/src/mt76x2/common/cmm_wpa.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "coolsnowwolf/lede", "stars": 28402, "license": "other", "language": "c", "size": 286238}
{"docstring": "/*\n\t========================================================================\n\t\n\tRoutine Description:\n\t\tClassify WPA EAP message type\n\n\tArguments:\n\t\tEAPType\t\tValue of EAP message type\n\t\tMsgType\t\tInternal Message definition for MLME state machine\n\t\t\n\tReturn Value:\n\t\tTRUE\t\tFound appropriate message type\n\t\tFALSE\t\tNo appropriate message type\n\n\tIRQL = DISPATCH_LEVEL\n\t\n\tNote:\n\t\tAll these constants are defined in wpa_cmm.h\n\t\tFor supplicant, there is only EAPOL Key message avaliable\n\t\t\n\t========================================================================\n*/\n", "func_signal": "BOOLEAN\tWpaMsgTypeSubst(\n\tIN\tUCHAR\tEAPType,\n\tOUT\tINT\t\t*MsgType)", "code": "{\n\tswitch (EAPType)\n\t{\n\t\tcase EAPPacket:\n\t\t\t*MsgType = MT2_EAPPacket;\n\t\t\tbreak;\n\t\tcase EAPOLStart:\n\t\t\t*MsgType = MT2_EAPOLStart;\n\t\t\tbreak;\n\t\tcase EAPOLLogoff:\n\t\t\t*MsgType = MT2_EAPOLLogoff;\n\t\t\tbreak;\n\t\tcase EAPOLKey:\n\t\t\t*MsgType = MT2_EAPOLKey;\n\t\t\tbreak;\n\t\tcase EAPOLASFAlert:\n\t\t\t*MsgType = MT2_EAPOLASFAlert;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn FALSE;\t\t\n\t}\t\n\treturn TRUE;\n}", "path": "lede/package/lean/mt/drivers/mt7612e/src/mt76x2/common/cmm_wpa.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "coolsnowwolf/lede", "stars": 28402, "license": "other", "language": "c", "size": 286238}
{"docstring": "/* If the received frame is EAP-Packet ,find out its EAP-Code (Request(0x01), Response(0x02), Success(0x03), Failure(0x04)). */\n", "func_signal": "INT WpaCheckEapCode(\n\tIN RTMP_ADAPTER *pAd,\n\tIN UCHAR *pFrame,\n\tIN USHORT FrameLen,\n\tIN USHORT OffSet)", "code": "{\n\t\n\tPUCHAR\tpData;\n\tINT\tresult = 0;\n\t\t\n\tif( FrameLen < OffSet + LENGTH_EAPOL_H + LENGTH_EAP_H ) \n\t\treturn result;\n\t\t\n\tpData = pFrame + OffSet;\t\t/* skip offset bytes */\n \t\n\tif(*(pData+1) == EAPPacket) \t/* 802.1x header - Packet Type */\n\t{\n\t\t result = *(pData+4);\t\t/* EAP header - Code */\n\t}\n\n\treturn result;\n}", "path": "lede/package/lean/mt/drivers/mt7612e/src/mt76x2/common/cmm_wpa.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "coolsnowwolf/lede", "stars": 28402, "license": "other", "language": "c", "size": 286238}
{"docstring": "/*\n\t========================================================================\n\t\n\tRoutine Description:\n\t\tConstruct KDE common format  \n\t\tIts format is below,\n\t\t\n\t\t+--------------------+\n\t\t| Type (0xdd)\t\t |  1 octet\n\t\t+--------------------+\n\t\t| Length\t\t\t |\t1 octet\t\n\t\t+--------------------+\n\t\t| OUI\t\t\t\t |  3 octets\n\t\t+--------------------+\n\t\t| Data Type\t\t\t |\t1 octet\n\t\t+--------------------+\n\t\t\n\tArguments:\n\t\t\t\t\n\tReturn Value:\n\t\t\n\tNote:\n\t\tIt's defined in IEEE 802.11-2007 Figure 8-25.\n\t\t\n\t========================================================================\n*/\n", "func_signal": "VOID WPA_ConstructKdeHdr(\n\tIN \tUINT8\tdata_type,\t\n\tIN \tUINT8 \tdata_len,\n\tOUT PUCHAR \tpBuf)", "code": "{\n\tPKDE_HDR\tpHdr;\n\n\tpHdr = (PKDE_HDR)pBuf;\n\n\tNdisZeroMemory(pHdr, sizeof(KDE_HDR));\n\n    pHdr->Type = WPA_KDE_TYPE;\n\n\t/* The Length field specifies the number of octets in the OUI, Data\n\t   Type, and Data fields. */\t   \n\tpHdr->Len = 4 + data_len;\n\n\tNdisMoveMemory(pHdr->OUI, OUI_WPA2, 3);\n\tpHdr->DataType = data_type;\n\n}", "path": "lede/package/lean/mt/drivers/mt7612e/src/mt76x2/common/cmm_wpa.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "coolsnowwolf/lede", "stars": 28402, "license": "other", "language": "c", "size": 286238}
{"docstring": "/*\n\t========================================================================\n\t\n\tRoutine Description:\n\t\tBuild AKM suite in RSN-IE. \n\t\tIt only shall be called by RTMPMakeRSNIE. \n\n\tArguments:\n\t\tpAd\t\t\t-\tpointer to our pAdapter context\t\n    \tElementID\t-\tindicate the WPA1 or WPA2\n    \tAuthMode\t-\tindicate the authentication mode\n\t\tapidx\t\t-\tindicate the interface index\n\t\t\n\tReturn Value:\n\t\t\n\tNote:\n\t\t\n\t========================================================================\n*/\n", "func_signal": "static VOID RTMPMakeRsnIeAKM(\t\n\tIN  PRTMP_ADAPTER   pAd,\t\n\tIN\tUCHAR\t\t\tElementID,\t\n\tIN\tUINT\t\t\tAuthMode,\n\tIN\tUCHAR\t\t\tapidx,\n\tOUT\tPUCHAR\t\t\tpRsnIe,\n\tOUT\tUCHAR\t\t\t*rsn_len)", "code": "{\n\tRSNIE_AUTH\t\t*pRsnie_auth;\t\n\tUCHAR\t\t\tAkmCnt = 1;\t\t/* default as 1*/\n#ifdef DOT11R_FT_SUPPORT\t\n\tBOOLEAN\t\t\tbFtEnabled = FALSE;\n\tUINT8\t\t\tFtAkmOui[8];\n#endif /* DOT11R_FT_SUPPORT */\n\n\tpRsnie_auth = (RSNIE_AUTH*)(pRsnIe + (*rsn_len));\n\n\t/* decide WPA2 or WPA1\t */\n\tif (ElementID == Wpa2Ie)\n\t{\n#ifdef DOT11R_FT_SUPPORT\n#ifdef CONFIG_AP_SUPPORT\t\n\t\tIF_DEV_CONFIG_OPMODE_ON_AP(pAd)\n\t\t{\n\t\t\tif (apidx < pAd->ApCfg.BssidNum)\n\t\t\t{\n\t\t\t\t/* Indicate the FT is enabld*/\n\t\t\t\tif (pAd->ApCfg.MBSSID[apidx].FtCfg.FtCapFlag.Dot11rFtEnable)\n\t\t\t\t{\n\t\t\t\t\tbFtEnabled = TRUE;\n\t\t\t\t\tAkmCnt = 2;\n\t\t\t\t\tif (AuthMode == Ndis802_11AuthModeWPA2 || \n\t\t\t\t\t\tAuthMode == Ndis802_11AuthModeWPA1WPA2)\n\t\t\t\t\t{\n\t\t\t\t\t\tNdisMoveMemory(FtAkmOui, OUI_WPA2_8021X_AKM, 4);\n\t\t\t\t\t\tNdisMoveMemory(&FtAkmOui[4], OUI_FT_8021X_AKM, 4);\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse if (AuthMode == Ndis802_11AuthModeWPA2PSK || \n\t\t\t\t\t\t\tAuthMode == Ndis802_11AuthModeWPA1PSKWPA2PSK)\n\t\t\t\t\t{\n\t\t\t\t\t\tNdisMoveMemory(FtAkmOui, OUI_WPA2_PSK_AKM, 4);\n\t\t\t\t\t\tNdisMoveMemory(&FtAkmOui[4], OUI_FT_PSK_AKM, 4);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tAkmCnt = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif /* CONFIG_AP_SUPPORT */\n#ifdef CONFIG_STA_SUPPORT\t\n\t\tIF_DEV_CONFIG_OPMODE_ON_STA(pAd)\n\t\t{\n\t\t\t/* Indicate the FT is enabld*/\n\t\t\tif (pAd->MlmeAux.MdIeInfo.Len > 0)\n\t\t\t{\n\t\t\t\tbFtEnabled = TRUE;\n\t\t\t\tif (AuthMode == Ndis802_11AuthModeWPA2)\t\t\t\t\n\t\t\t\t\tNdisMoveMemory(&FtAkmOui[0], OUI_FT_8021X_AKM, 4);\n\t\t\t\telse if (AuthMode == Ndis802_11AuthModeWPA2PSK)\n\t\t\t\t\tNdisMoveMemory(&FtAkmOui[0], OUI_FT_PSK_AKM, 4);\n\t\t\t\telse\n\t\t\t\t\tAkmCnt = 0;\n\t\t\t}\n\t\t}\n#endif /* CONFIG_STA_SUPPORT */\n#endif /* DOT11R_FT_SUPPORT */\n\n\t\tswitch (AuthMode)\n        {\n            case Ndis802_11AuthModeWPA2:\n            case Ndis802_11AuthModeWPA1WPA2:\n#ifdef DOT11R_FT_SUPPORT\n\t\t\t\tif (bFtEnabled && (AkmCnt > 0))\n\t\t\t\t{\n\t\t\t\t\t/* append the primary AKM suite */\n\t\t\t\t\tNdisMoveMemory(pRsnie_auth->auth[0].oui, FtAkmOui, 4);\n\n\t\t\t\t\t/* Append the secondary AKM suite if it exists */\n\t\t\t\t\tif (AkmCnt == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Get the offset of the end of 1st AKM suite */\n\t\t\t\t\t\tUCHAR ext_akm_offset = (*rsn_len) + sizeof(RSNIE_AUTH);\n\n\t\t\t\t\t\tNdisMoveMemory(pRsnIe + ext_akm_offset, &FtAkmOui[4] , 4);\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\telse\n#endif /* DOT11R_FT_SUPPORT */\n                \tNdisMoveMemory(pRsnie_auth->auth[0].oui, OUI_WPA2_8021X_AKM, 4);\n\n#ifdef DOT11W_PMF_SUPPORT\n#ifdef CONFIG_AP_SUPPORT\t\n                IF_DEV_CONFIG_OPMODE_ON_AP(pAd)\n                {\n                        if (pAd->ApCfg.MBSSID[apidx].PmfCfg.MFPR) {\n                                NdisMoveMemory(pRsnie_auth->auth[0].oui, OUI_WPA2_1X_SHA256, 4);\n                                DBGPRINT(RT_DEBUG_WARN, (\"[PMF]%s: Insert 1X-SHA256 to AKM of RSNIE\\n\", __FUNCTION__));\n                        } else if ((pAd->ApCfg.MBSSID[apidx].PmfCfg.MFPC) && (pAd->ApCfg.MBSSID[apidx].PmfCfg.PMFSHA256)) {\n                                NdisMoveMemory(pRsnie_auth->auth[0].oui + (4*AkmCnt), OUI_WPA2_1X_SHA256, 4);\n                                AkmCnt++;\n                                DBGPRINT(RT_DEBUG_WARN, (\"[PMF]%s: Insert 1X-SHA256 to AKM of RSNIE\\n\", __FUNCTION__));\n                        }\n                }\n#endif /* CONFIG_AP_SUPPORT */\n#ifdef CONFIG_STA_SUPPORT\t\n                IF_DEV_CONFIG_OPMODE_ON_STA(pAd)\n                {\n                        ULONG BssIdx;\n                        BSS_ENTRY *pInBss = NULL;\n\n                        BssIdx = BssTableSearchWithSSID(&pAd->MlmeAux.SsidBssTab, pAd->MlmeAux.Bssid, pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen, pAd->CommonCfg.Channel);\n                        if (BssIdx != BSS_NOT_FOUND)\n                        {\n                                pInBss = &pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx];\n                                if (CLIENT_STATUS_TEST_FLAG(pInBss, fCLIENT_STATUS_USE_SHA256))\n                                {\n                                        NdisMoveMemory(pRsnie_auth->auth[0].oui, OUI_WPA2_1X_SHA256, 4);\n                                        DBGPRINT(RT_DEBUG_WARN, (\"[PMF]%s: Insert 1X-SHA256 to AKM of RSNIE\\n\", __FUNCTION__));\n                                }\n                        }\n                }\n#endif /* CONFIG_STA_SUPPORT */\n#endif /* DOT11W_PMF_SUPPORT */\n                break;\n\n            case Ndis802_11AuthModeWPA2PSK:\n            case Ndis802_11AuthModeWPA1PSKWPA2PSK:\n#ifdef DOT11R_FT_SUPPORT\n\t\t\t\tif (bFtEnabled && (AkmCnt > 0))\n\t\t\t\t{\n\t\t\t\t\t/* append the primary AKM suite */\n\t\t\t\t\tNdisMoveMemory(pRsnie_auth->auth[0].oui, FtAkmOui, 4);\n\n\t\t\t\t\t/* Append the secondary AKM suite if it exists */\n\t\t\t\t\tif (AkmCnt == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Get the offset of the end of 1st AKM suite */\n\t\t\t\t\t\tUCHAR ext_akm_offset = (*rsn_len) + sizeof(RSNIE_AUTH);\n\n\t\t\t\t\t\tNdisMoveMemory(pRsnIe + ext_akm_offset, &FtAkmOui[4] , 4);\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\telse\n#endif /* DOT11R_FT_SUPPORT */\n                \tNdisMoveMemory(pRsnie_auth->auth[0].oui, OUI_WPA2_PSK_AKM, 4);\n\n#ifdef DOT11W_PMF_SUPPORT\n#ifdef CONFIG_AP_SUPPORT\t\n                IF_DEV_CONFIG_OPMODE_ON_AP(pAd)\n                {\n                        if (pAd->ApCfg.MBSSID[apidx].PmfCfg.MFPR) {\n                                NdisMoveMemory(pRsnie_auth->auth[0].oui, OUI_WPA2_PSK_SHA256, 4);\n                                DBGPRINT(RT_DEBUG_WARN, (\"[PMF]%s: Insert PSK-SHA256 to AKM of RSNIE\\n\", __FUNCTION__));\n                        } else if ((pAd->ApCfg.MBSSID[apidx].PmfCfg.MFPC) && (pAd->ApCfg.MBSSID[apidx].PmfCfg.PMFSHA256)) {\n                                NdisMoveMemory(pRsnie_auth->auth[0].oui + (4*AkmCnt), OUI_WPA2_PSK_SHA256, 4);\n                                AkmCnt++;\n                                DBGPRINT(RT_DEBUG_WARN, (\"[PMF]%s: Insert PSK-SHA256 to AKM of RSNIE\\n\", __FUNCTION__));\n                        }\n                }\n#endif /* CONFIG_AP_SUPPORT */\n\n#ifdef CONFIG_STA_SUPPORT\t\n                IF_DEV_CONFIG_OPMODE_ON_STA(pAd)\n                {\n                        ULONG BssIdx;\n                        BSS_ENTRY *pInBss = NULL;\n\n                        BssIdx = BssTableSearchWithSSID(&pAd->MlmeAux.SsidBssTab, pAd->MlmeAux.Bssid, pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen, pAd->CommonCfg.Channel);\n                        if (BssIdx != BSS_NOT_FOUND)\n                        {\n                                pInBss = &pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx];\n                                if (CLIENT_STATUS_TEST_FLAG(pInBss, fCLIENT_STATUS_USE_SHA256))\n                                {\n                                        NdisMoveMemory(pRsnie_auth->auth[0].oui, OUI_WPA2_PSK_SHA256, 4);\n                                        DBGPRINT(RT_DEBUG_WARN, (\"[PMF]%s: Insert PSK-SHA256 to AKM of RSNIE\\n\", __FUNCTION__));\n                                }\n                        }\n                }\n#endif /* CONFIG_STA_SUPPORT */\n#endif /* DOT11W_PMF_SUPPORT */\n                break;\n\t\t\tdefault:\n\t\t\t\tAkmCnt = 0;\n\t\t\t\tbreak;\n\t\t\t\t\n        }\n\t}\n\telse\n\t{\n\t\tswitch (AuthMode)\n        {\n            case Ndis802_11AuthModeWPA:\n            case Ndis802_11AuthModeWPA1WPA2:\n                NdisMoveMemory(pRsnie_auth->auth[0].oui, OUI_WPA_8021X_AKM, 4);\n                break;\n\n            case Ndis802_11AuthModeWPAPSK:\n            case Ndis802_11AuthModeWPA1PSKWPA2PSK:\n                NdisMoveMemory(pRsnie_auth->auth[0].oui, OUI_WPA_PSK_AKM, 4);\n                break;\n\n\t\t\tcase Ndis802_11AuthModeWPANone:\n                NdisMoveMemory(pRsnie_auth->auth[0].oui, OUI_WPA_NONE_AKM, 4);\n                break;\n\t\t\tdefault:\n\t\t\t\tAkmCnt = 0;\n\t\t\t\tbreak;\t\n        }\t\t\t\n\t}\n\t\t \n\tpRsnie_auth->acount = AkmCnt;\n\tpRsnie_auth->acount = cpu2le16(pRsnie_auth->acount);\n\t\n\t/* update current RSNIE length*/\n\t(*rsn_len) += (sizeof(RSNIE_AUTH) + (4 * (AkmCnt - 1)));\t\n\n}", "path": "lede/package/lean/mt/drivers/mt7612e/src/mt76x2/common/cmm_wpa.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "coolsnowwolf/lede", "stars": 28402, "license": "other", "language": "c", "size": 286238}
{"docstring": "/* Only used by test code */\n", "func_signal": "void\nts_populate_scheduled_job_tuple(ScheduledBgwJob *sjob, Datum *values)", "code": "{\n\tif (sjob == NULL)\n\t\treturn;\n\n\tvalues[0] = Int32GetDatum(sjob->job.fd.id);\n\tvalues[1] = NameGetDatum(&sjob->job.fd.application_name);\n\tvalues[2] = IntervalPGetDatum(&sjob->job.fd.schedule_interval);\n\tvalues[3] = IntervalPGetDatum(&sjob->job.fd.max_runtime);\n\tvalues[4] = Int32GetDatum(sjob->job.fd.max_retries);\n\tvalues[5] = IntervalPGetDatum(&sjob->job.fd.retry_period);\n\tvalues[6] = TimestampTzGetDatum(sjob->next_start);\n\tvalues[7] = TimestampTzGetDatum(sjob->timeout_at);\n\tvalues[8] = BoolGetDatum(sjob->reserved_worker);\n\tvalues[9] = BoolGetDatum(sjob->may_need_mark_end);\n}", "path": "timescaledb/src/bgw/scheduler.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "timescale/timescaledb", "stars": 16230, "license": "other", "language": "c", "size": 39583}
{"docstring": "/////////////////////\n/// I/O Functions ///\n/////////////////////\n", "func_signal": "void\ndictionary_compressed_send(CompressedDataHeader *header, StringInfo buffer)", "code": "{\n\tuint32 data_size;\n\tuint32 size;\n\tconst DictionaryCompressed *compressed_header;\n\tconst char *compressed_data;\n\n\tAssert(header->compression_algorithm == COMPRESSION_ALGORITHM_DICTIONARY);\n\tcompressed_header = (DictionaryCompressed *) header;\n\n\tcompressed_data = (char *) compressed_header;\n\n\tcompressed_data += sizeof(*compressed_header);\n\n\tdata_size = VARSIZE(compressed_header);\n\tdata_size -= sizeof(*compressed_header);\n\n\tpq_sendbyte(buffer, compressed_header->has_nulls == true);\n\n\ttype_append_to_binary_string(compressed_header->element_type, buffer);\n\n\tsize = simple8brle_serialized_total_size((void *) compressed_data);\n\tsimple8brle_serialized_send(buffer, (void *) compressed_data);\n\tcompressed_data += size;\n\tdata_size -= size;\n\n\tif (compressed_header->has_nulls)\n\t{\n\t\tuint32 size = simple8brle_serialized_total_size((void *) compressed_data);\n\t\tsimple8brle_serialized_send(buffer, (void *) compressed_data);\n\t\tcompressed_data += size;\n\t\tdata_size -= size;\n\t}\n\n\tarray_compressed_data_send(buffer,\n\t\t\t\t\t\t\t   compressed_data,\n\t\t\t\t\t\t\t   data_size,\n\t\t\t\t\t\t\t   compressed_header->element_type,\n\t\t\t\t\t\t\t   false);\n}", "path": "timescaledb/tsl/src/compression/dictionary.c", "commit_date": "2020-06-02 00:00:00", "repo_name": "timescale/timescaledb", "stars": 16230, "license": "other", "language": "c", "size": 39583}
{"docstring": "/////////////////////\n/// SQL Functions ///\n/////////////////////\n", "func_signal": "Datum\ntsl_dictionary_compressor_append(PG_FUNCTION_ARGS)", "code": "{\n\tDictionaryCompressor *compressor =\n\t\t(DictionaryCompressor *) (PG_ARGISNULL(0) ? NULL : PG_GETARG_POINTER(0));\n\tMemoryContext agg_context;\n\tMemoryContext old_context;\n\n\tif (!AggCheckCallContext(fcinfo, &agg_context))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"tsl_dictionary_compressor_append called in non-aggregate context\");\n\t}\n\n\told_context = MemoryContextSwitchTo(agg_context);\n\n\tif (compressor == NULL)\n\t{\n\t\tOid type_to_compress = get_fn_expr_argtype(fcinfo->flinfo, 1);\n\t\tcompressor = dictionary_compressor_alloc(type_to_compress);\n\t}\n\tif (PG_ARGISNULL(1))\n\t\tdictionary_compressor_append_null(compressor);\n\telse\n\t\tdictionary_compressor_append(compressor, PG_GETARG_DATUM(1));\n\n\tMemoryContextSwitchTo(old_context);\n\tPG_RETURN_POINTER(compressor);\n}", "path": "timescaledb/tsl/src/compression/dictionary.c", "commit_date": "2020-06-02 00:00:00", "repo_name": "timescale/timescaledb", "stars": 16230, "license": "other", "language": "c", "size": 39583}
{"docstring": "/* some of the scheduler mock code calls functions from this file without going through\n * the main loop so we need a way to setup the memory contexts\n */\n", "func_signal": "void\nts_bgw_scheduler_setup_mctx()", "code": "{\n\tscheduler_mctx = AllocSetContextCreate(TopMemoryContext, \"Scheduler\", ALLOCSET_DEFAULT_SIZES);\n\tscratch_mctx =\n\t\tAllocSetContextCreate(scheduler_mctx, \"SchedulerScratch\", ALLOCSET_DEFAULT_SIZES);\n\tMemoryContextSwitchTo(scratch_mctx);\n}", "path": "timescaledb/src/bgw/scheduler.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "timescale/timescaledb", "stars": 16230, "license": "other", "language": "c", "size": 39583}
{"docstring": "/* Returns the earliest time the scheduler needs to kill a job according to its timeout  */\n", "func_signal": "static TimestampTz\nearliest_job_timeout()", "code": "{\n\tListCell *lc;\n\tTimestampTz earliest = DT_NOEND;\n\n\tforeach (lc, scheduled_jobs)\n\t{\n\t\tScheduledBgwJob *sjob = lfirst(lc);\n\n\t\tif (sjob->state == JOB_STATE_STARTED)\n\t\t\tearliest = least_timestamp(earliest, sjob->timeout_at);\n\t}\n\treturn earliest;\n}", "path": "timescaledb/src/bgw/scheduler.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "timescale/timescaledb", "stars": 16230, "license": "other", "language": "c", "size": 39583}
{"docstring": "/*********************\n ***  send / recv  ***\n *********************/\n", "func_signal": "ArrayCompressorSerializationInfo *\narray_compressed_data_recv(StringInfo buffer, Oid element_type)", "code": "{\n\tArrayCompressor *compressor = array_compressor_alloc(element_type);\n\tSimple8bRleDecompressionIterator nulls;\n\tuint8 has_nulls;\n\tDatumDeserializer *deser = create_datum_deserializer(element_type);\n\tbool use_binary_recv;\n\tuint32 num_elements;\n\tuint32 i;\n\n\thas_nulls = pq_getmsgbyte(buffer) != 0;\n\tif (has_nulls)\n\t\tsimple8brle_decompression_iterator_init_forward(&nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsimple8brle_serialized_recv(buffer));\n\n\tuse_binary_recv = pq_getmsgbyte(buffer) != 0;\n\n\t/* This is actually the number of not-null elements */\n\tnum_elements = pq_getmsgint32(buffer);\n\n\t/* if there are nulls, use that count instead */\n\tif (has_nulls)\n\t\tnum_elements = nulls.num_elements;\n\n\tfor (i = 0; i < num_elements; i++)\n\t{\n\t\tDatum val;\n\t\tif (has_nulls)\n\t\t{\n\t\t\tSimple8bRleDecompressResult null =\n\t\t\t\tsimple8brle_decompression_iterator_try_next_forward(&nulls);\n\t\t\tAssert(!null.is_done);\n\t\t\tif (null.val)\n\t\t\t{\n\t\t\t\tarray_compressor_append_null(compressor);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tval = binary_string_to_datum(deser,\n\t\t\t\t\t\t\t\t\t use_binary_recv ? BINARY_ENCODING : TEXT_ENCODING,\n\t\t\t\t\t\t\t\t\t buffer);\n\n\t\tarray_compressor_append(compressor, val);\n\t}\n\n\treturn array_compressor_get_serialization_info(compressor);\n}", "path": "timescaledb/tsl/src/compression/array.c", "commit_date": "2020-06-02 00:00:00", "repo_name": "timescale/timescaledb", "stars": 16230, "license": "other", "language": "c", "size": 39583}
{"docstring": "/*\n * Register SIGTERM and SIGHUP handlers for bgw_scheduler.\n * This function _must_ be called with signals blocked, i.e., after calling\n * BackgroundWorkerBlockSignals\n */\n", "func_signal": "void\nts_bgw_scheduler_register_signal_handlers(void)", "code": "{\n\t/*\n\t * do not use the default `bgworker_die` sigterm handler because it does\n\t * not respect critical sections\n\t */\n\tpqsignal(SIGTERM, handle_sigterm);\n\tpqsignal(SIGHUP, handle_sighup);\n\n\t/* Some SIGHUPS may already have been dropped, so we must load the file here */\n\tgot_SIGHUP = false;\n\tProcessConfigFile(PGC_SIGHUP);\n}", "path": "timescaledb/src/bgw/scheduler.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "timescale/timescaledb", "stars": 16230, "license": "other", "language": "c", "size": 39583}
{"docstring": "/********************\n *** SQL Bindings ***\n ********************/\n", "func_signal": "Datum\narray_compressed_recv(StringInfo buffer)", "code": "{\n\tArrayCompressorSerializationInfo *data;\n\tuint8 has_nulls;\n\tOid element_type;\n\n\thas_nulls = pq_getmsgbyte(buffer);\n\tif (has_nulls != 0 && has_nulls != 1)\n\t\telog(ERROR, \"invalid recv in array: bad bool\");\n\n\telement_type = binary_string_get_type(buffer);\n\n\tdata = array_compressed_data_recv(buffer, element_type);\n\n\tPG_RETURN_POINTER(array_compressed_from_serialization_info(data, element_type));\n}", "path": "timescaledb/tsl/src/compression/array.c", "commit_date": "2020-06-02 00:00:00", "repo_name": "timescale/timescaledb", "stars": 16230, "license": "other", "language": "c", "size": 39583}
{"docstring": "/******************\n *** Decompress ***\n ******************/\n", "func_signal": "static ArrayCompressedData\narray_compressed_data_from_bytes(const char *serialized_data, Size data_size, Oid element_type,\n\t\t\t\t\t\t\t\t bool has_nulls)", "code": "{\n\tArrayCompressedData data = { .element_type = element_type };\n\n\tif (has_nulls)\n\t{\n\t\tSimple8bRleSerialized *nulls = bytes_deserialize_simple8b_and_advance(&serialized_data);\n\t\tdata.nulls = nulls;\n\t\tdata_size -= simple8brle_serialized_total_size(nulls);\n\t}\n\n\tdata.sizes = bytes_deserialize_simple8b_and_advance(&serialized_data);\n\tdata_size -= simple8brle_serialized_total_size(data.sizes);\n\n\tdata.data = serialized_data;\n\tdata.data_len = data_size;\n\n\treturn data;\n}", "path": "timescaledb/tsl/src/compression/array.c", "commit_date": "2020-06-02 00:00:00", "repo_name": "timescale/timescaledb", "stars": 16230, "license": "other", "language": "c", "size": 39583}
{"docstring": "/* when working with time_buckets stored in our catalog, we may not know ahead of time which\n * bucketing function to use, this function dynamically dispatches to the correct time_bucket_<foo>\n * based on an inputted timestamp_type*/\n", "func_signal": "TSDLLEXPORT int64\nts_time_bucket_by_type(int64 interval, int64 timestamp, Oid timestamp_type)", "code": "{\n\tDatum timestamp_in_time_type = ts_internal_to_time_value(timestamp, timestamp_type);\n\tDatum interval_in_interval_type;\n\tDatum time_bucketed;\n\tDatum (*bucket_function)(PG_FUNCTION_ARGS);\n\n\tswitch (timestamp_type)\n\t{\n\t\tcase INT2OID:\n\t\t\tinterval_in_interval_type = ts_internal_to_interval_value(interval, timestamp_type);\n\t\t\tbucket_function = ts_int16_bucket;\n\t\t\tbreak;\n\t\tcase INT4OID:\n\t\t\tinterval_in_interval_type = ts_internal_to_interval_value(interval, timestamp_type);\n\t\t\tbucket_function = ts_int32_bucket;\n\t\t\tbreak;\n\t\tcase INT8OID:\n\t\t\tinterval_in_interval_type = ts_internal_to_interval_value(interval, timestamp_type);\n\t\t\tbucket_function = ts_int64_bucket;\n\t\t\tbreak;\n\t\tcase TIMESTAMPOID:\n\t\t\tinterval_in_interval_type = ts_internal_to_interval_value(interval, INTERVALOID);\n\t\t\tbucket_function = ts_timestamp_bucket;\n\t\t\tbreak;\n\t\tcase TIMESTAMPTZOID:\n\t\t\tinterval_in_interval_type = ts_internal_to_interval_value(interval, INTERVALOID);\n\t\t\tbucket_function = ts_timestamptz_bucket;\n\t\t\tbreak;\n\t\tcase DATEOID:\n\t\t\tinterval_in_interval_type = ts_internal_to_interval_value(interval, INTERVALOID);\n\t\t\tbucket_function = ts_date_bucket;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid time_bucket Oid %d\", timestamp_type);\n\t}\n\n\ttime_bucketed =\n\t\tDirectFunctionCall2(bucket_function, interval_in_interval_type, timestamp_in_time_type);\n\n\treturn ts_time_value_to_internal(time_bucketed, timestamp_type);\n}", "path": "timescaledb/src/time_bucket.c", "commit_date": "2020-06-02 00:00:00", "repo_name": "timescale/timescaledb", "stars": 16230, "license": "other", "language": "c", "size": 39583}
{"docstring": "/*\n *  Update the given job list with whatever is in the bgw_job table. For overlapping jobs,\n *  copy over any existing scheduler info from the given jobs list.\n *  Assume that both lists are ordered by job ID.\n *  Note that this function call will destroy cur_jobs_list and return a new list.\n */\n", "func_signal": "List *\nts_update_scheduled_jobs_list(List *cur_jobs_list, MemoryContext mctx)", "code": "{\n\tList *new_jobs = ts_bgw_job_get_scheduled(sizeof(ScheduledBgwJob), mctx);\n\tListCell *new_ptr = list_head(new_jobs);\n\tListCell *cur_ptr = list_head(cur_jobs_list);\n\n\twhile (cur_ptr != NULL && new_ptr != NULL)\n\t{\n\t\tScheduledBgwJob *new_sjob = lfirst(new_ptr);\n\t\tScheduledBgwJob *cur_sjob = lfirst(cur_ptr);\n\n\t\tif (cur_sjob->job.fd.id < new_sjob->job.fd.id)\n\t\t{\n\t\t\t/*\n\t\t\t * We don't need cur_sjob anymore. Make sure to clean up the job\n\t\t\t * state. Then keep advancing cur pointer until we catch up.\n\t\t\t */\n\t\t\tterminate_and_cleanup_job(cur_sjob);\n\n\t\t\tcur_ptr = lnext(cur_ptr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (cur_sjob->job.fd.id == new_sjob->job.fd.id)\n\t\t{\n\t\t\t/*\n\t\t\t * Then this job already exists. Copy over any state and advance\n\t\t\t * both pointers.\n\t\t\t */\n\t\t\tcur_sjob->job = new_sjob->job;\n\t\t\t*new_sjob = *cur_sjob;\n\n\t\t\t/* reload the scheduling information from the job_stats */\n\t\t\tif (cur_sjob->state == JOB_STATE_SCHEDULED)\n\t\t\t\tscheduled_bgw_job_transition_state_to(new_sjob, JOB_STATE_SCHEDULED);\n\n\t\t\tcur_ptr = lnext(cur_ptr);\n\t\t\tnew_ptr = lnext(new_ptr);\n\t\t}\n\t\telse if (cur_sjob->job.fd.id > new_sjob->job.fd.id)\n\t\t{\n\t\t\tscheduled_bgw_job_transition_state_to(new_sjob, JOB_STATE_SCHEDULED);\n\n\t\t\t/* Advance the new_job list until we catch up to cur_list */\n\t\t\tnew_ptr = lnext(new_ptr);\n\t\t}\n\t}\n\n\t/* If there's more stuff in cur_list, clean it all up */\n\tif (cur_ptr != NULL)\n\t{\n\t\tListCell *ptr;\n\n\t\tfor_each_cell (ptr, cur_ptr)\n\t\t\tterminate_and_cleanup_job(lfirst(ptr));\n\t}\n\n\tif (new_ptr != NULL)\n\t{\n\t\t/* Then there are more new jobs. Initialize all of them. */\n\t\tListCell *ptr;\n\n\t\tfor_each_cell (ptr, new_ptr)\n\t\t\tscheduled_bgw_job_transition_state_to(lfirst(ptr), JOB_STATE_SCHEDULED);\n\t}\n\n\t/* Free the old list */\n\tlist_free_deep(cur_jobs_list);\n\treturn new_jobs;\n}", "path": "timescaledb/src/bgw/scheduler.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "timescale/timescaledb", "stars": 16230, "license": "other", "language": "c", "size": 39583}
{"docstring": "/*\n * This function starts a job.\n * To correctly count crashes we need to mark the start of a job in a separate\n * txn before we kick off the actual job. Thus this function cannot be run\n * from within a transaction.\n */\n", "func_signal": "static void\nscheduled_ts_bgw_job_start(ScheduledBgwJob *sjob,\n\t\t\t\t\t\t   register_background_worker_callback_type bgw_register)", "code": "{\n\tpid_t pid;\n\tBgwHandleStatus status;\n\n\tscheduled_bgw_job_transition_state_to(sjob, JOB_STATE_STARTED);\n\n\tif (sjob->state != JOB_STATE_STARTED)\n\t\treturn;\n\n\tAssert(sjob->handle != NULL);\n\tif (bgw_register != NULL)\n\t\tbgw_register(sjob->handle);\n\n\tstatus = WaitForBackgroundWorkerStartup(sjob->handle, &pid);\n\tswitch (status)\n\t{\n\t\tcase BGWH_POSTMASTER_DIED:\n\t\t\tbgw_scheduler_on_postmaster_death();\n\t\t\tbreak;\n\t\tcase BGWH_STARTED:\n\t\t\t/* all good */\n\t\t\tbreak;\n\t\tcase BGWH_STOPPED:\n\t\t\tStartTransactionCommand();\n\t\t\tscheduled_bgw_job_transition_state_to(sjob, JOB_STATE_SCHEDULED);\n\t\t\tCommitTransactionCommand();\n\t\t\tMemoryContextSwitchTo(scratch_mctx);\n\t\t\tbreak;\n\t\tcase BGWH_NOT_YET_STARTED:\n\t\t\t/* should not be possible */\n\t\t\telog(ERROR, \"unexpected bgworker state %d\", status);\n\t\t\tbreak;\n\t}\n}", "path": "timescaledb/src/bgw/scheduler.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "timescale/timescaledb", "stars": 16230, "license": "other", "language": "c", "size": 39583}
{"docstring": "/* Set the state of the job.\n * This function is responsible for setting all of the variables in ScheduledBgwJob\n * except for the job itself.\n */\n", "func_signal": "static void\nscheduled_bgw_job_transition_state_to(ScheduledBgwJob *sjob, JobState new_state)", "code": "{\n#if USE_ASSERT_CHECKING\n\tJobState prev_state = sjob->state;\n#endif\n\n\tBgwJobStat *job_stat;\n\tOid owner_uid;\n\n\tswitch (new_state)\n\t{\n\t\tcase JOB_STATE_DISABLED:\n\t\t\tAssert(prev_state == JOB_STATE_STARTED || prev_state == JOB_STATE_TERMINATING);\n\t\t\tsjob->handle = NULL;\n\t\t\tbreak;\n\t\tcase JOB_STATE_SCHEDULED:\n\t\t\t/* prev_state can be any value, including itself */\n\n\t\t\tworker_state_cleanup(sjob);\n\n\t\t\tjob_stat = ts_bgw_job_stat_find(sjob->job.fd.id);\n\n\t\t\tAssert(!sjob->reserved_worker);\n\t\t\tsjob->next_start = ts_bgw_job_stat_next_start(job_stat, &sjob->job);\n\t\t\tbreak;\n\t\tcase JOB_STATE_STARTED:\n\t\t\tAssert(prev_state == JOB_STATE_SCHEDULED);\n\t\t\tAssert(sjob->handle == NULL);\n\t\t\tAssert(!sjob->reserved_worker);\n\n\t\t\tStartTransactionCommand();\n\n\t\t\tif (!ts_bgw_job_get_share_lock(sjob->job.fd.id, CurrentMemoryContext))\n\t\t\t{\n\t\t\t\telog(WARNING,\n\t\t\t\t\t \"scheduler detected that job %d was deleted when starting job\",\n\t\t\t\t\t sjob->job.fd.id);\n\t\t\t\tts_bgw_job_cache_invalidate_callback();\n\t\t\t\tCommitTransactionCommand();\n\t\t\t\tMemoryContextSwitchTo(scratch_mctx);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* If we are unable to reserve a worker go back to the scheduled state */\n\t\t\tsjob->reserved_worker = ts_bgw_worker_reserve();\n\t\t\tif (!sjob->reserved_worker)\n\t\t\t{\n\t\t\t\telog(WARNING,\n\t\t\t\t\t \"failed to launch job %d \\\"%s\\\": out of background workers\",\n\t\t\t\t\t sjob->job.fd.id,\n\t\t\t\t\t NameStr(sjob->job.fd.application_name));\n\t\t\t\tscheduled_bgw_job_transition_state_to(sjob, JOB_STATE_SCHEDULED);\n\t\t\t\tCommitTransactionCommand();\n\t\t\t\tMemoryContextSwitchTo(scratch_mctx);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * start the job before you can encounter any errors so that they\n\t\t\t * are always registered\n\t\t\t */\n\t\t\tmark_job_as_started(sjob);\n\t\t\tif (ts_bgw_job_has_timeout(&sjob->job))\n\t\t\t\tsjob->timeout_at =\n\t\t\t\t\tts_bgw_job_timeout_at(&sjob->job, ts_timer_get_current_timestamp());\n\t\t\telse\n\t\t\t\tsjob->timeout_at = DT_NOEND;\n\n\t\t\towner_uid = get_role_oid(NameStr(sjob->job.fd.owner), false);\n\t\t\tCommitTransactionCommand();\n\t\t\tMemoryContextSwitchTo(scratch_mctx);\n\n\t\t\telog(DEBUG1,\n\t\t\t\t \"launching job %d \\\"%s\\\"\",\n\t\t\t\t sjob->job.fd.id,\n\t\t\t\t NameStr(sjob->job.fd.application_name));\n\n\t\t\tsjob->handle = ts_bgw_job_start(&sjob->job, owner_uid);\n\t\t\tif (sjob->handle == NULL)\n\t\t\t{\n\t\t\t\telog(WARNING,\n\t\t\t\t\t \"failed to launch job %d \\\"%s\\\": failed to start a background worker\",\n\t\t\t\t\t sjob->job.fd.id,\n\t\t\t\t\t NameStr(sjob->job.fd.application_name));\n\t\t\t\ton_failure_to_start_job(sjob);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tAssert(sjob->reserved_worker);\n\t\t\tbreak;\n\t\tcase JOB_STATE_TERMINATING:\n\t\t\tAssert(prev_state == JOB_STATE_STARTED);\n\t\t\tAssert(sjob->handle != NULL);\n\t\t\tAssert(sjob->reserved_worker);\n\t\t\tTerminateBackgroundWorker(sjob->handle);\n\t\t\tbreak;\n\t}\n\tsjob->state = new_state;\n}", "path": "timescaledb/src/bgw/scheduler.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "timescale/timescaledb", "stars": 16230, "license": "other", "language": "c", "size": 39583}
{"docstring": "/**************************\n *** Decompress Reverse ***\n **************************/\n", "func_signal": "DecompressionIterator *\ntsl_array_decompression_iterator_from_datum_reverse(Datum compressed_array, Oid element_type)", "code": "{\n\tArrayCompressed *compressed_array_header;\n\tuint32 data_size;\n\tArrayCompressedData array_compressed_data;\n\tArrayDecompressionIterator *iterator = palloc(sizeof(*iterator));\n\tconst char *compressed_data = (void *) PG_DETOAST_DATUM(compressed_array);\n\titerator->base.compression_algorithm = COMPRESSION_ALGORITHM_ARRAY;\n\titerator->base.forward = false;\n\titerator->base.element_type = element_type;\n\titerator->base.try_next = array_decompression_iterator_try_next_reverse;\n\n\tcompressed_array_header = (ArrayCompressed *) compressed_data;\n\tcompressed_data += sizeof(*compressed_array_header);\n\n\tAssert(compressed_array_header->compression_algorithm == COMPRESSION_ALGORITHM_ARRAY);\n\tif (element_type != compressed_array_header->element_type)\n\t\telog(ERROR, \"trying to decompress the wrong type\");\n\n\tdata_size = VARSIZE(compressed_array_header);\n\tdata_size -= sizeof(*compressed_array_header);\n\n\tarray_compressed_data = array_compressed_data_from_bytes(compressed_data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t data_size,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t compressed_array_header->element_type,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t compressed_array_header->has_nulls);\n\n\titerator->has_nulls = array_compressed_data.nulls != NULL;\n\tif (iterator->has_nulls)\n\t\tsimple8brle_decompression_iterator_init_reverse(&iterator->nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tarray_compressed_data.nulls);\n\n\tsimple8brle_decompression_iterator_init_reverse(&iterator->sizes, array_compressed_data.sizes);\n\n\titerator->data = array_compressed_data.data;\n\titerator->num_data_bytes = array_compressed_data.data_len;\n\titerator->data_offset = iterator->num_data_bytes;\n\titerator->deserializer = create_datum_deserializer(iterator->base.element_type);\n\n\treturn &iterator->base;\n}", "path": "timescaledb/tsl/src/compression/array.c", "commit_date": "2020-06-02 00:00:00", "repo_name": "timescale/timescaledb", "stars": 16230, "license": "other", "language": "c", "size": 39583}
{"docstring": "////////////////////\n/// Decompressor ///\n////////////////////\n", "func_signal": "static void\ndictionary_decompression_iterator_init(DictionaryDecompressionIterator *iter, const char *data,\n\t\t\t\t\t\t\t\t\t   bool scan_forward, Oid element_type)", "code": "{\n\tconst DictionaryCompressed *bitmap = (const DictionaryCompressed *) data;\n\tSize total_size = VARSIZE(bitmap);\n\tSize remaining_size;\n\tSimple8bRleSerialized *s8_bitmap;\n\tDecompressionIterator *dictionary_iterator;\n\n\t*iter = (DictionaryDecompressionIterator){\n\t\t.base = {\n\t\t\t.compression_algorithm = COMPRESSION_ALGORITHM_DICTIONARY,\n\t\t\t.forward = scan_forward,\n\t\t\t.element_type = element_type,\n\t\t\t.try_next = (scan_forward ? dictionary_decompression_iterator_try_next_forward : dictionary_decompression_iterator_try_next_reverse),\n\t\t},\n\t\t.compressed = bitmap,\n\t\t.values = palloc(sizeof(Datum) * bitmap->num_distinct),\n\t\t.has_nulls = bitmap->has_nulls == 1,\n\t};\n\n\tdata += sizeof(DictionaryCompressed);\n\ts8_bitmap = bytes_deserialize_simple8b_and_advance(&data);\n\n\tif (scan_forward)\n\t\tsimple8brle_decompression_iterator_init_forward(&iter->bitmap, s8_bitmap);\n\telse\n\t\tsimple8brle_decompression_iterator_init_reverse(&iter->bitmap, s8_bitmap);\n\n\tif (iter->has_nulls)\n\t{\n\t\tSimple8bRleSerialized *s8_null = bytes_deserialize_simple8b_and_advance(&data);\n\t\tif (scan_forward)\n\t\t\tsimple8brle_decompression_iterator_init_forward(&iter->nulls, s8_null);\n\t\telse\n\t\t\tsimple8brle_decompression_iterator_init_reverse(&iter->nulls, s8_null);\n\t}\n\n\tremaining_size = total_size - (data - (char *) bitmap);\n\n\tdictionary_iterator = array_decompression_iterator_alloc_forward(data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t remaining_size,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t bitmap->element_type,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t /* has_nulls */ false);\n\n\tfor (int i = 0; i < bitmap->num_distinct; i++)\n\t{\n\t\tDecompressResult res = array_decompression_iterator_try_next_forward(dictionary_iterator);\n\t\tAssert(!res.is_null);\n\t\tAssert(!res.is_done);\n\t\titer->values[i] = res.val;\n\t}\n\tAssert(array_decompression_iterator_try_next_forward(dictionary_iterator).is_done);\n}", "path": "timescaledb/tsl/src/compression/dictionary.c", "commit_date": "2020-06-02 00:00:00", "repo_name": "timescale/timescaledb", "stars": 16230, "license": "other", "language": "c", "size": 39583}
{"docstring": "/* there are more efficient ways to do this that use\n * DictionaryCompressorSerializationInfo, but they are not worth implementing\n * yet\n */\n", "func_signal": "static ArrayCompressed *\ndictionary_compressed_to_array_compressed(DictionaryCompressed *compressed)", "code": "{\n\tArrayCompressor *compressor = array_compressor_alloc(compressed->element_type);\n\tDictionaryDecompressionIterator iterator;\n\tdictionary_decompression_iterator_init(&iterator,\n\t\t\t\t\t\t\t\t\t\t   (void *) compressed,\n\t\t\t\t\t\t\t\t\t\t   true,\n\t\t\t\t\t\t\t\t\t\t   compressed->element_type);\n\n\tfor (DecompressResult res = dictionary_decompression_iterator_try_next_forward(&iterator.base);\n\t\t !res.is_done;\n\t\t res = dictionary_decompression_iterator_try_next_forward(&iterator.base))\n\t{\n\t\tif (res.is_null)\n\t\t\tarray_compressor_append_null(compressor);\n\t\telse\n\t\t\tarray_compressor_append(compressor, res.val);\n\t}\n\n\treturn array_compressor_finish(compressor);\n}", "path": "timescaledb/tsl/src/compression/dictionary.c", "commit_date": "2020-06-02 00:00:00", "repo_name": "timescale/timescaledb", "stars": 16230, "license": "other", "language": "c", "size": 39583}
{"docstring": "/* Returns the earliest time the scheduler should start a job that is waiting to be started */\n", "func_signal": "static TimestampTz\nearliest_wakeup_to_start_next_job()", "code": "{\n\tListCell *lc;\n\tTimestampTz earliest = DT_NOEND;\n\tTimestampTz now = ts_timer_get_current_timestamp();\n\n\tforeach (lc, scheduled_jobs)\n\t{\n\t\tScheduledBgwJob *sjob = lfirst(lc);\n\n\t\tif (sjob->state == JOB_STATE_SCHEDULED)\n\t\t{\n\t\t\tTimestampTz start = sjob->next_start;\n\t\t\t/* if the start is less than now, this means we tried and failed to start it already, so\n\t\t\t * use the retry period */\n\t\t\tif (start < now)\n\t\t\t\tstart = TimestampTzPlusMilliseconds(now, START_RETRY_MS);\n\t\t\tearliest = least_timestamp(earliest, start);\n\t\t}\n\t}\n\treturn earliest;\n}", "path": "timescaledb/src/bgw/scheduler.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "timescale/timescaledb", "stars": 16230, "license": "other", "language": "c", "size": 39583}
{"docstring": "/******************\n *** Compressor ***\n ******************/\n", "func_signal": "static void\narray_compressor_append_datum(Compressor *compressor, Datum val)", "code": "{\n\tExtendedCompressor *extended = (ExtendedCompressor *) compressor;\n\tif (extended->internal == NULL)\n\t\textended->internal = array_compressor_alloc(extended->element_type);\n\n\tarray_compressor_append(extended->internal, val);\n}", "path": "timescaledb/tsl/src/compression/array.c", "commit_date": "2020-06-02 00:00:00", "repo_name": "timescale/timescaledb", "stars": 16230, "license": "other", "language": "c", "size": 39583}
{"docstring": "/* WARNING: mock_wait must _only_ be called from the bgw_scheduler, calling it from a worker will\n * clobber the timer state */\n", "func_signal": "static bool\nmock_wait(TimestampTz until)", "code": "{\n\telog(WARNING,\n\t\t \"[TESTING] Wait until \" INT64_FORMAT \", started at \" INT64_FORMAT,\n\t\t until,\n\t\t ts_params_get()->current_time);\n\n\tswitch (ts_params_get()->mock_wait_type)\n\t{\n\t\tcase WAIT_ON_JOB:\n\t\t\tif (bgw_handle != NULL)\n\t\t\t{\n\t\t\t\tWaitForBackgroundWorkerShutdown(bgw_handle);\n\t\t\t\tbgw_handle = NULL;\n\t\t\t}\n\t\t\tTS_FALLTHROUGH;\n\t\tcase IMMEDIATELY_SET_UNTIL:\n\t\t\tts_params_set_time(until, false);\n\t\t\treturn true;\n\t\tcase WAIT_FOR_OTHER_TO_ADVANCE:\n\t\t{\n\t\t\t/* Wait for another process to set \"next time\" */\n\t\t\tts_reset_and_wait_timer_latch();\n\n\t\t\treturn true;\n\t\t}\n\t\tcase WAIT_FOR_STANDARD_WAITLATCH:\n\t\t\tts_get_standard_timer()->wait(until);\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}", "path": "timescaledb/test/src/bgw/timer_mock.c", "commit_date": "2020-09-29 00:00:00", "repo_name": "timescale/timescaledb", "stars": 16230, "license": "other", "language": "c", "size": 39583}
{"docstring": "/* Special exit function only used in shmem_exit_callback.\n * Do not call the normal cleanup function (worker_state_cleanup), because\n * 1) we do not wait for the BGW to terminate,\n * 2) we cannot access the database at this time, so we should not be\n *    trying to update the bgw_stat table.\n */\n", "func_signal": "static void\nterminate_all_jobs_and_release_workers()", "code": "{\n\tListCell *lc;\n\n\tforeach (lc, scheduled_jobs)\n\t{\n\t\tScheduledBgwJob *sjob = lfirst(lc);\n\n\t\t/*\n\t\t * Clean up the background workers. Don't worry about state of the\n\t\t * sjobs, because this callback might have interrupted a state\n\t\t * transition.\n\t\t */\n\t\tif (sjob->handle != NULL)\n\t\t\tTerminateBackgroundWorker(sjob->handle);\n\n\t\tif (sjob->reserved_worker)\n\t\t{\n\t\t\tts_bgw_worker_release();\n\t\t\tsjob->reserved_worker = false;\n\t\t}\n\t}\n}", "path": "timescaledb/src/bgw/scheduler.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "timescale/timescaledb", "stars": 16230, "license": "other", "language": "c", "size": 39583}
{"docstring": "/*=======MAIN=====*/\n", "func_signal": "int main(void)", "code": "{\n  UnityBegin(\"testdata/testsample.c\");\n  RUN_TEST(test_TheFirstThingToTest, 21);\n  RUN_TEST(test_TheSecondThingToTest, 43);\n  RUN_TEST(test_TheThirdThingToTest, 53);\n  RUN_TEST(test_TheFourthThingToTest, 58);\n\n  return (UnityEnd());\n}", "path": "cJSON/tests/unity/test/expectdata/testsample_head1.c", "commit_date": "2017-02-07 00:00:00", "repo_name": "DaveGamble/cJSON", "stars": 9828, "license": "mit", "language": "c", "size": 2520}
{"docstring": "/* Replace array/object items with new ones. */\n", "func_signal": "CJSON_PUBLIC(cJSON_bool) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)", "code": "{\n    cJSON *after_inserted = NULL;\n\n    if (which < 0)\n    {\n        return false;\n    }\n\n    after_inserted = get_array_item(array, (size_t)which);\n    if (after_inserted == NULL)\n    {\n        return add_item_to_array(array, newitem);\n    }\n\n    newitem->next = after_inserted;\n    newitem->prev = after_inserted->prev;\n    after_inserted->prev = newitem;\n    if (after_inserted == array->child)\n    {\n        array->child = newitem;\n    }\n    else\n    {\n        newitem->prev->next = newitem;\n    }\n    return true;\n}", "path": "cJSON/cJSON.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "DaveGamble/cJSON", "stars": 9828, "license": "mit", "language": "c", "size": 2520}
{"docstring": "/* Internal constructor. */\n", "func_signal": "static cJSON *cJSON_New_Item(const internal_hooks * const hooks)", "code": "{\n    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));\n    if (node)\n    {\n        memset(node, '\\0', sizeof(cJSON));\n    }\n\n    return node;\n}", "path": "cJSON/cJSON.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "DaveGamble/cJSON", "stars": 9828, "license": "mit", "language": "c", "size": 2520}
{"docstring": "/* Delete a cJSON structure. */\n", "func_signal": "CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)", "code": "{\n    cJSON *next = NULL;\n    while (item != NULL)\n    {\n        next = item->next;\n        if (!(item->type & cJSON_IsReference) && (item->child != NULL))\n        {\n            cJSON_Delete(item->child);\n        }\n        if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))\n        {\n            global_hooks.deallocate(item->valuestring);\n        }\n        if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))\n        {\n            global_hooks.deallocate(item->string);\n        }\n        global_hooks.deallocate(item);\n        item = next;\n    }\n}", "path": "cJSON/cJSON.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "DaveGamble/cJSON", "stars": 9828, "license": "mit", "language": "c", "size": 2520}
{"docstring": "/* Create Arrays: */\n", "func_signal": "CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)", "code": "{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count < 0) || (numbers == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n\n    for(i = 0; a && (i < (size_t)count); i++)\n    {\n        n = cJSON_CreateNumber(numbers[i]);\n        if (!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a->child = n;\n        }\n        else\n        {\n            suffix_object(p, n);\n        }\n        p = n;\n    }\n\n    if (a && a->child) {\n        a->child->prev = n;\n    }\n\n    return a;\n}", "path": "cJSON/cJSON.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "DaveGamble/cJSON", "stars": 9828, "license": "mit", "language": "c", "size": 2520}
{"docstring": "/* securely comparison of floating-point variables */\n", "func_signal": "static cJSON_bool compare_double(double a, double b)", "code": "{\n    double maxVal = fabs(a) > fabs(b) ? fabs(a) : fabs(b);\n    return (fabs(a - b) <= maxVal * DBL_EPSILON);\n}", "path": "cJSON/cJSON.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "DaveGamble/cJSON", "stars": 9828, "license": "mit", "language": "c", "size": 2520}
{"docstring": "/* skip the UTF-8 BOM (byte order mark) if it is at the beginning of a buffer */\n", "func_signal": "static parse_buffer *skip_utf8_bom(parse_buffer * const buffer)", "code": "{\n    if ((buffer == NULL) || (buffer->content == NULL) || (buffer->offset != 0))\n    {\n        return NULL;\n    }\n\n    if (can_access_at_index(buffer, 4) && (strncmp((const char*)buffer_at_offset(buffer), \"\\xEF\\xBB\\xBF\", 3) == 0))\n    {\n        buffer->offset += 3;\n    }\n\n    return buffer;\n}", "path": "cJSON/cJSON.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "DaveGamble/cJSON", "stars": 9828, "license": "mit", "language": "c", "size": 2520}
{"docstring": "/* Render a value to text. */\n", "func_signal": "static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)", "code": "{\n    unsigned char *output = NULL;\n\n    if ((item == NULL) || (output_buffer == NULL))\n    {\n        return false;\n    }\n\n    switch ((item->type) & 0xFF)\n    {\n        case cJSON_NULL:\n            output = ensure(output_buffer, 5);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"null\");\n            return true;\n\n        case cJSON_False:\n            output = ensure(output_buffer, 6);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"false\");\n            return true;\n\n        case cJSON_True:\n            output = ensure(output_buffer, 5);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"true\");\n            return true;\n\n        case cJSON_Number:\n            return print_number(item, output_buffer);\n\n        case cJSON_Raw:\n        {\n            size_t raw_length = 0;\n            if (item->valuestring == NULL)\n            {\n                return false;\n            }\n\n            raw_length = strlen(item->valuestring) + sizeof(\"\");\n            output = ensure(output_buffer, raw_length);\n            if (output == NULL)\n            {\n                return false;\n            }\n            memcpy(output, item->valuestring, raw_length);\n            return true;\n        }\n\n        case cJSON_String:\n            return print_string(item, output_buffer);\n\n        case cJSON_Array:\n            return print_array(item, output_buffer);\n\n        case cJSON_Object:\n            return print_object(item, output_buffer);\n\n        default:\n            return false;\n    }\n}", "path": "cJSON/cJSON.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "DaveGamble/cJSON", "stars": 9828, "license": "mit", "language": "c", "size": 2520}
{"docstring": "/* Duplication */\n", "func_signal": "CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)", "code": "{\n    cJSON *newitem = NULL;\n    cJSON *child = NULL;\n    cJSON *next = NULL;\n    cJSON *newchild = NULL;\n\n    /* Bail on bad ptr */\n    if (!item)\n    {\n        goto fail;\n    }\n    /* Create new item */\n    newitem = cJSON_New_Item(&global_hooks);\n    if (!newitem)\n    {\n        goto fail;\n    }\n    /* Copy over all vars */\n    newitem->type = item->type & (~cJSON_IsReference);\n    newitem->valueint = item->valueint;\n    newitem->valuedouble = item->valuedouble;\n    if (item->valuestring)\n    {\n        newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);\n        if (!newitem->valuestring)\n        {\n            goto fail;\n        }\n    }\n    if (item->string)\n    {\n        newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);\n        if (!newitem->string)\n        {\n            goto fail;\n        }\n    }\n    /* If non-recursive, then we're done! */\n    if (!recurse)\n    {\n        return newitem;\n    }\n    /* Walk the ->next chain for the child. */\n    child = item->child;\n    while (child != NULL)\n    {\n        newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */\n        if (!newchild)\n        {\n            goto fail;\n        }\n        if (next != NULL)\n        {\n            /* If newitem->child already set, then crosswire ->prev and ->next and move on */\n            next->next = newchild;\n            newchild->prev = next;\n            next = newchild;\n        }\n        else\n        {\n            /* Set newitem->child and move to it */\n            newitem->child = newchild;\n            next = newchild;\n        }\n        child = child->next;\n    }\n    if (newitem && newitem->child)\n    {\n        newitem->child->prev = newchild;\n    }\n\n    return newitem;\n\nfail:\n    if (newitem != NULL)\n    {\n        cJSON_Delete(newitem);\n    }\n\n    return NULL;\n}", "path": "cJSON/cJSON.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "DaveGamble/cJSON", "stars": 9828, "license": "mit", "language": "c", "size": 2520}
{"docstring": "/* Parse the input text to generate a number, and populate the result into item. */\n", "func_signal": "static cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)", "code": "{\n    double number = 0;\n    unsigned char *after_end = NULL;\n    unsigned char number_c_string[64];\n    unsigned char decimal_point = get_decimal_point();\n    size_t i = 0;\n\n    if ((input_buffer == NULL) || (input_buffer->content == NULL))\n    {\n        return false;\n    }\n\n    /* copy the number into a temporary buffer and replace '.' with the decimal point\n     * of the current locale (for strtod)\n     * This also takes care of '\\0' not necessarily being available for marking the end of the input */\n    for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++)\n    {\n        switch (buffer_at_offset(input_buffer)[i])\n        {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case '+':\n            case '-':\n            case 'e':\n            case 'E':\n                number_c_string[i] = buffer_at_offset(input_buffer)[i];\n                break;\n\n            case '.':\n                number_c_string[i] = decimal_point;\n                break;\n\n            default:\n                goto loop_end;\n        }\n    }\nloop_end:\n    number_c_string[i] = '\\0';\n\n    number = strtod((const char*)number_c_string, (char**)&after_end);\n    if (number_c_string == after_end)\n    {\n        return false; /* parse_error */\n    }\n\n    item->valuedouble = number;\n\n    /* use saturation in case of overflow */\n    if (number >= INT_MAX)\n    {\n        item->valueint = INT_MAX;\n    }\n    else if (number <= (double)INT_MIN)\n    {\n        item->valueint = INT_MIN;\n    }\n    else\n    {\n        item->valueint = (int)number;\n    }\n\n    item->type = cJSON_Number;\n\n    input_buffer->offset += (size_t)(after_end - number_c_string);\n    return true;\n}", "path": "cJSON/cJSON.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "DaveGamble/cJSON", "stars": 9828, "license": "mit", "language": "c", "size": 2520}
{"docstring": "/* Get Array size/item / object item. */\n", "func_signal": "CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)", "code": "{\n    cJSON *child = NULL;\n    size_t size = 0;\n\n    if (array == NULL)\n    {\n        return 0;\n    }\n\n    child = array->child;\n\n    while(child != NULL)\n    {\n        size++;\n        child = child->next;\n    }\n\n    /* FIXME: Can overflow here. Cannot be fixed without breaking the API */\n\n    return (int)size;\n}", "path": "cJSON/cJSON.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "DaveGamble/cJSON", "stars": 9828, "license": "mit", "language": "c", "size": 2520}
{"docstring": "/* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */\n", "func_signal": "CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)", "code": "{\n    if (number >= INT_MAX)\n    {\n        object->valueint = INT_MAX;\n    }\n    else if (number <= (double)INT_MIN)\n    {\n        object->valueint = INT_MIN;\n    }\n    else\n    {\n        object->valueint = (int)number;\n    }\n\n    return object->valuedouble = number;\n}", "path": "cJSON/cJSON.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "DaveGamble/cJSON", "stars": 9828, "license": "mit", "language": "c", "size": 2520}
{"docstring": "/* Create basic types: */\n", "func_signal": "CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void)", "code": "{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = cJSON_NULL;\n    }\n\n    return item;\n}", "path": "cJSON/cJSON.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "DaveGamble/cJSON", "stars": 9828, "license": "mit", "language": "c", "size": 2520}
{"docstring": "/* converts a UTF-16 literal to UTF-8\n * A literal can be one or two sequences of the form \\uXXXX */\n", "func_signal": "static unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer)", "code": "{\n    long unsigned int codepoint = 0;\n    unsigned int first_code = 0;\n    const unsigned char *first_sequence = input_pointer;\n    unsigned char utf8_length = 0;\n    unsigned char utf8_position = 0;\n    unsigned char sequence_length = 0;\n    unsigned char first_byte_mark = 0;\n\n    if ((input_end - first_sequence) < 6)\n    {\n        /* input ends unexpectedly */\n        goto fail;\n    }\n\n    /* get the first utf16 sequence */\n    first_code = parse_hex4(first_sequence + 2);\n\n    /* check that the code is valid */\n    if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)))\n    {\n        goto fail;\n    }\n\n    /* UTF16 surrogate pair */\n    if ((first_code >= 0xD800) && (first_code <= 0xDBFF))\n    {\n        const unsigned char *second_sequence = first_sequence + 6;\n        unsigned int second_code = 0;\n        sequence_length = 12; /* \\uXXXX\\uXXXX */\n\n        if ((input_end - second_sequence) < 6)\n        {\n            /* input ends unexpectedly */\n            goto fail;\n        }\n\n        if ((second_sequence[0] != '\\\\') || (second_sequence[1] != 'u'))\n        {\n            /* missing second half of the surrogate pair */\n            goto fail;\n        }\n\n        /* get the second utf16 sequence */\n        second_code = parse_hex4(second_sequence + 2);\n        /* check that the code is valid */\n        if ((second_code < 0xDC00) || (second_code > 0xDFFF))\n        {\n            /* invalid second half of the surrogate pair */\n            goto fail;\n        }\n\n\n        /* calculate the unicode codepoint from the surrogate pair */\n        codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));\n    }\n    else\n    {\n        sequence_length = 6; /* \\uXXXX */\n        codepoint = first_code;\n    }\n\n    /* encode as UTF-8\n     * takes at maximum 4 bytes to encode:\n     * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */\n    if (codepoint < 0x80)\n    {\n        /* normal ascii, encoding 0xxxxxxx */\n        utf8_length = 1;\n    }\n    else if (codepoint < 0x800)\n    {\n        /* two bytes, encoding 110xxxxx 10xxxxxx */\n        utf8_length = 2;\n        first_byte_mark = 0xC0; /* 11000000 */\n    }\n    else if (codepoint < 0x10000)\n    {\n        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */\n        utf8_length = 3;\n        first_byte_mark = 0xE0; /* 11100000 */\n    }\n    else if (codepoint <= 0x10FFFF)\n    {\n        /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */\n        utf8_length = 4;\n        first_byte_mark = 0xF0; /* 11110000 */\n    }\n    else\n    {\n        /* invalid unicode codepoint */\n        goto fail;\n    }\n\n    /* encode as utf8 */\n    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)\n    {\n        /* 10xxxxxx */\n        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);\n        codepoint >>= 6;\n    }\n    /* encode first byte */\n    if (utf8_length > 1)\n    {\n        (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);\n    }\n    else\n    {\n        (*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);\n    }\n\n    *output_pointer += utf8_length;\n\n    return sequence_length;\n\nfail:\n    return 0;\n}", "path": "cJSON/cJSON.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "DaveGamble/cJSON", "stars": 9828, "license": "mit", "language": "c", "size": 2520}
{"docstring": "/* Render an array to text */\n", "func_signal": "static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer)", "code": "{\n    unsigned char *output_pointer = NULL;\n    size_t length = 0;\n    cJSON *current_element = item->child;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* Compose the output array. */\n    /* opening square bracket */\n    output_pointer = ensure(output_buffer, 1);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n\n    *output_pointer = '[';\n    output_buffer->offset++;\n    output_buffer->depth++;\n\n    while (current_element != NULL)\n    {\n        if (!print_value(current_element, output_buffer))\n        {\n            return false;\n        }\n        update_offset(output_buffer);\n        if (current_element->next)\n        {\n            length = (size_t) (output_buffer->format ? 2 : 1);\n            output_pointer = ensure(output_buffer, length + 1);\n            if (output_pointer == NULL)\n            {\n                return false;\n            }\n            *output_pointer++ = ',';\n            if(output_buffer->format)\n            {\n                *output_pointer++ = ' ';\n            }\n            *output_pointer = '\\0';\n            output_buffer->offset += length;\n        }\n        current_element = current_element->next;\n    }\n\n    output_pointer = ensure(output_buffer, 2);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n    *output_pointer++ = ']';\n    *output_pointer = '\\0';\n    output_buffer->depth--;\n\n    return true;\n}", "path": "cJSON/cJSON.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "DaveGamble/cJSON", "stars": 9828, "license": "mit", "language": "c", "size": 2520}
{"docstring": "/* Utility to jump whitespace and cr/lf */\n", "func_signal": "static parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)", "code": "{\n    if ((buffer == NULL) || (buffer->content == NULL))\n    {\n        return NULL;\n    }\n\n    if (cannot_access_at_index(buffer, 0))\n    {\n        return buffer;\n    }\n\n    while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32))\n    {\n       buffer->offset++;\n    }\n\n    if (buffer->offset == buffer->length)\n    {\n        buffer->offset--;\n    }\n\n    return buffer;\n}", "path": "cJSON/cJSON.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "DaveGamble/cJSON", "stars": 9828, "license": "mit", "language": "c", "size": 2520}
{"docstring": "/* Utility for array list handling. */\n", "func_signal": "static void suffix_object(cJSON *prev, cJSON *item)", "code": "{\n    prev->next = item;\n    item->prev = prev;\n}", "path": "cJSON/cJSON.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "DaveGamble/cJSON", "stars": 9828, "license": "mit", "language": "c", "size": 2520}
{"docstring": "/* calculate the new length of the string in a printbuffer and update the offset */\n", "func_signal": "static void update_offset(printbuffer * const buffer)", "code": "{\n    const unsigned char *buffer_pointer = NULL;\n    if ((buffer == NULL) || (buffer->buffer == NULL))\n    {\n        return;\n    }\n    buffer_pointer = buffer->buffer + buffer->offset;\n\n    buffer->offset += strlen((const char*)buffer_pointer);\n}", "path": "cJSON/cJSON.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "DaveGamble/cJSON", "stars": 9828, "license": "mit", "language": "c", "size": 2520}
{"docstring": "/* Utility for handling references. */\n", "func_signal": "static cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)", "code": "{\n    cJSON *reference = NULL;\n    if (item == NULL)\n    {\n        return NULL;\n    }\n\n    reference = cJSON_New_Item(hooks);\n    if (reference == NULL)\n    {\n        return NULL;\n    }\n\n    memcpy(reference, item, sizeof(cJSON));\n    reference->string = NULL;\n    reference->type |= cJSON_IsReference;\n    reference->next = reference->prev = NULL;\n    return reference;\n}", "path": "cJSON/cJSON.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "DaveGamble/cJSON", "stars": 9828, "license": "mit", "language": "c", "size": 2520}
{"docstring": "/* Parse the input text into an unescaped cinput, and populate item. */\n", "func_signal": "static cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)", "code": "{\n    const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;\n    const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;\n    unsigned char *output_pointer = NULL;\n    unsigned char *output = NULL;\n\n    /* not a string */\n    if (buffer_at_offset(input_buffer)[0] != '\\\"')\n    {\n        goto fail;\n    }\n\n    {\n        /* calculate approximate size of the output (overestimate) */\n        size_t allocation_length = 0;\n        size_t skipped_bytes = 0;\n        while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\\\"'))\n        {\n            /* is escape sequence */\n            if (input_end[0] == '\\\\')\n            {\n                if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length)\n                {\n                    /* prevent buffer overflow when last input character is a backslash */\n                    goto fail;\n                }\n                skipped_bytes++;\n                input_end++;\n            }\n            input_end++;\n        }\n        if (((size_t)(input_end - input_buffer->content) >= input_buffer->length) || (*input_end != '\\\"'))\n        {\n            goto fail; /* string ended unexpectedly */\n        }\n\n        /* This is at most how much we need for the output */\n        allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;\n        output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(\"\"));\n        if (output == NULL)\n        {\n            goto fail; /* allocation failure */\n        }\n    }\n\n    output_pointer = output;\n    /* loop through the string literal */\n    while (input_pointer < input_end)\n    {\n        if (*input_pointer != '\\\\')\n        {\n            *output_pointer++ = *input_pointer++;\n        }\n        /* escape sequence */\n        else\n        {\n            unsigned char sequence_length = 2;\n            if ((input_end - input_pointer) < 1)\n            {\n                goto fail;\n            }\n\n            switch (input_pointer[1])\n            {\n                case 'b':\n                    *output_pointer++ = '\\b';\n                    break;\n                case 'f':\n                    *output_pointer++ = '\\f';\n                    break;\n                case 'n':\n                    *output_pointer++ = '\\n';\n                    break;\n                case 'r':\n                    *output_pointer++ = '\\r';\n                    break;\n                case 't':\n                    *output_pointer++ = '\\t';\n                    break;\n                case '\\\"':\n                case '\\\\':\n                case '/':\n                    *output_pointer++ = input_pointer[1];\n                    break;\n\n                /* UTF-16 literal */\n                case 'u':\n                    sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer);\n                    if (sequence_length == 0)\n                    {\n                        /* failed to convert UTF16-literal to UTF-8 */\n                        goto fail;\n                    }\n                    break;\n\n                default:\n                    goto fail;\n            }\n            input_pointer += sequence_length;\n        }\n    }\n\n    /* zero terminate the output */\n    *output_pointer = '\\0';\n\n    item->type = cJSON_String;\n    item->valuestring = (char*)output;\n\n    input_buffer->offset = (size_t) (input_end - input_buffer->content);\n    input_buffer->offset++;\n\n    return true;\n\nfail:\n    if (output != NULL)\n    {\n        input_buffer->hooks.deallocate(output);\n    }\n\n    if (input_pointer != NULL)\n    {\n        input_buffer->offset = (size_t)(input_pointer - input_buffer->content);\n    }\n\n    return false;\n}", "path": "cJSON/cJSON.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "DaveGamble/cJSON", "stars": 9828, "license": "mit", "language": "c", "size": 2520}
{"docstring": "// Print out the assembly postamble\n", "func_signal": "void cgpostamble()", "code": "{\n  fputs(\n\t\"\\tmovl\t$0, %eax\\n\"\n\t\"\\tpopq\t%rbp\\n\"\n\t\"\\tret\\n\",\n  Outfile);\n}", "path": "acwj/04_Assembly/cg.c", "commit_date": "2019-10-18 00:00:00", "repo_name": "DoctorWkt/acwj", "stars": 9661, "license": "gpl-3.0", "language": "c", "size": 1544}
{"docstring": "// Scan in a string literal from the input file,\n// and store it in buf[]. Return the length of\n// the string. \n", "func_signal": "static int scanstr(char *buf)", "code": "{\n  int i, c;\n\n  // Loop while we have enough buffer space\n  for (i = 0; i < TEXTLEN - 1; i++) {\n    // Get the next char and append to buf\n    // Return when we hit the ending double quote\n    if ((c = scanch()) == '\"') {\n      buf[i] = 0;\n      return (i);\n    }\n    buf[i] = c;\n  }\n  // Ran out of buf[] space\n  fatal(\"String literal too long\");\n  return (0);\n}", "path": "acwj/29_Refactoring/scan.c", "commit_date": "2019-11-10 00:00:00", "repo_name": "DoctorWkt/acwj", "stars": 9661, "license": "gpl-3.0", "language": "c", "size": 1544}
{"docstring": "// Scan an identifier from the input file and\n// store it in buf[]. Return the identifier's length\n", "func_signal": "static int scanident(int c, char *buf, int lim)", "code": "{\n  int i = 0;\n\n  // Allow digits, alpha and underscores\n  while (isalpha(c) || isdigit(c) || '_' == c) {\n    // Error if we hit the identifier length limit,\n    // else append to buf[] and get next character\n    if (lim - 1 == i) {\n      fatal(\"Identifier too long\");\n    } else if (i < lim - 1) {\n      buf[i++] = c;\n    }\n    c = next();\n  }\n  // We hit a non-valid character, put it back.\n  // NUL-terminate the buf[] and return the length\n  putback(c);\n  buf[i] = '\\0';\n  return (i);\n}", "path": "acwj/29_Refactoring/scan.c", "commit_date": "2019-11-10 00:00:00", "repo_name": "DoctorWkt/acwj", "stars": 9661, "license": "gpl-3.0", "language": "c", "size": 1544}
{"docstring": "// Allocate a free register. Return the number of\n// the register. Die if no available registers.\n", "func_signal": "static int alloc_register(void)", "code": "{\n  for (int i=0; i<4; i++) {\n    if (freereg[i]) {\n      freereg[i]= 0;\n      return(i);\n    }\n  }\n  fprintf(stderr, \"Out of registers!\\n\");\n  exit(1);\n}", "path": "acwj/04_Assembly/cg.c", "commit_date": "2019-10-18 00:00:00", "repo_name": "DoctorWkt/acwj", "stars": 9661, "license": "gpl-3.0", "language": "c", "size": 1544}
{"docstring": "// Print out the assembly preamble\n", "func_signal": "void cgpreamble()", "code": "{\n  freeall_registers();\n  fputs(\n\t\"\\t.text\\n\"\n\t\".LC0:\\n\"\n\t\"\\t.string\\t\\\"%d\\\\n\\\"\\n\"\n\t\"printint:\\n\"\n\t\"\\tpushq\\t%rbp\\n\"\n\t\"\\tmovq\\t%rsp, %rbp\\n\"\n\t\"\\tsubq\\t$16, %rsp\\n\"\n\t\"\\tmovl\\t%edi, -4(%rbp)\\n\"\n\t\"\\tmovl\\t-4(%rbp), %eax\\n\"\n\t\"\\tmovl\\t%eax, %esi\\n\"\n\t\"\\tleaq\t.LC0(%rip), %rdi\\n\"\n\t\"\\tmovl\t$0, %eax\\n\"\n\t\"\\tcall\tprintf@PLT\\n\"\n\t\"\\tnop\\n\"\n\t\"\\tleave\\n\"\n\t\"\\tret\\n\"\n\t\"\\n\"\n\t\"\\t.globl\\tmain\\n\"\n\t\"\\t.type\\tmain, @function\\n\"\n\t\"main:\\n\"\n\t\"\\tpushq\\t%rbp\\n\"\n\t\"\\tmovq\t%rsp, %rbp\\n\",\n  Outfile);\n}", "path": "acwj/04_Assembly/cg.c", "commit_date": "2019-10-18 00:00:00", "repo_name": "DoctorWkt/acwj", "stars": 9661, "license": "gpl-3.0", "language": "c", "size": 1544}
{"docstring": "// Subtract the second register from the first and\n// return the number of the register with the result\n", "func_signal": "int cgsub(int r1, int r2)", "code": "{\n  fprintf(Outfile, \"\\tsubq\\t%s, %s\\n\", reglist[r2], reglist[r1]);\n  free_register(r2);\n  return(r1);\n}", "path": "acwj/04_Assembly/cg.c", "commit_date": "2019-10-18 00:00:00", "repo_name": "DoctorWkt/acwj", "stars": 9661, "license": "gpl-3.0", "language": "c", "size": 1544}
{"docstring": "// Add two registers together and return\n// the number of the register with the result\n", "func_signal": "int cgadd(int r1, int r2)", "code": "{\n  fprintf(Outfile, \"\\taddq\\t%s, %s\\n\", reglist[r1], reglist[r2]);\n  free_register(r1);\n  return(r2);\n}", "path": "acwj/04_Assembly/cg.c", "commit_date": "2019-10-18 00:00:00", "repo_name": "DoctorWkt/acwj", "stars": 9661, "license": "gpl-3.0", "language": "c", "size": 1544}
{"docstring": "// Scan and return the next token found in the input.\n// Return 1 if token valid, 0 if no tokens left.\n", "func_signal": "int scan(struct token *t)", "code": "{\n  int c, tokentype;\n\n  // If we have any rejected token, return it\n  if (Rejtoken != NULL) {\n    t = Rejtoken;\n    Rejtoken = NULL;\n    return (1);\n  }\n  // Skip whitespace\n  c = skip();\n\n  // Determine the token based on\n  // the input character\n  switch (c) {\n  case EOF:\n    t->token = T_EOF;\n    return (0);\n  case '+':\n    if ((c = next()) == '+') {\n      t->token = T_INC;\n    } else {\n      putback(c);\n      t->token = T_PLUS;\n    }\n    break;\n  case '-':\n    if ((c = next()) == '-') {\n      t->token = T_DEC;\n    } else {\n      putback(c);\n      t->token = T_MINUS;\n    }\n    break;\n  case '*':\n    t->token = T_STAR;\n    break;\n  case '/':\n    t->token = T_SLASH;\n    break;\n  case ';':\n    t->token = T_SEMI;\n    break;\n  case '{':\n    t->token = T_LBRACE;\n    break;\n  case '}':\n    t->token = T_RBRACE;\n    break;\n  case '(':\n    t->token = T_LPAREN;\n    break;\n  case ')':\n    t->token = T_RPAREN;\n    break;\n  case '[':\n    t->token = T_LBRACKET;\n    break;\n  case ']':\n    t->token = T_RBRACKET;\n    break;\n  case '~':\n    t->token = T_INVERT;\n    break;\n  case '^':\n    t->token = T_XOR;\n    break;\n  case ',':\n    t->token = T_COMMA;\n    break;\n  case '=':\n    if ((c = next()) == '=') {\n      t->token = T_EQ;\n    } else {\n      putback(c);\n      t->token = T_ASSIGN;\n    }\n    break;\n  case '!':\n    if ((c = next()) == '=') {\n      t->token = T_NE;\n    } else {\n      putback(c);\n      t->token = T_LOGNOT;\n    }\n    break;\n  case '<':\n    if ((c = next()) == '=') {\n      t->token = T_LE;\n    } else if (c == '<') {\n      t->token = T_LSHIFT;\n    } else {\n      putback(c);\n      t->token = T_LT;\n    }\n    break;\n  case '>':\n    if ((c = next()) == '=') {\n      t->token = T_GE;\n    } else if (c == '>') {\n      t->token = T_RSHIFT;\n    } else {\n      putback(c);\n      t->token = T_GT;\n    }\n    break;\n  case '&':\n    if ((c = next()) == '&') {\n      t->token = T_LOGAND;\n    } else {\n      putback(c);\n      t->token = T_AMPER;\n    }\n    break;\n  case '|':\n    if ((c = next()) == '|') {\n      t->token = T_LOGOR;\n    } else {\n      putback(c);\n      t->token = T_OR;\n    }\n    break;\n  case '\\'':\n    // If it's a quote, scan in the\n    // literal character value and\n    // the trailing quote\n    t->intvalue = scanch();\n    t->token = T_INTLIT;\n    if (next() != '\\'')\n      fatal(\"Expected '\\\\'' at end of char literal\");\n    break;\n  case '\"':\n    // Scan in a literal string\n    scanstr(Text);\n    t->token = T_STRLIT;\n    break;\n  default:\n    // If it's a digit, scan the\n    // literal integer value in\n    if (isdigit(c)) {\n      t->intvalue = scanint(c);\n      t->token = T_INTLIT;\n      break;\n    } else if (isalpha(c) || '_' == c) {\n      // Read in a keyword or identifier\n      scanident(c, Text, TEXTLEN);\n\n      // If it's a recognised keyword, return that token\n      if ((tokentype = keyword(Text)) != 0) {\n\tt->token = tokentype;\n\tbreak;\n      }\n      // Not a recognised keyword, so it must be an identifier\n      t->token = T_IDENT;\n      break;\n    }\n    // The character isn't part of any recognised token, error\n    fatalc(\"Unrecognised character\", c);\n  }\n\n  // We found a token\n  return (1);\n}", "path": "acwj/29_Refactoring/scan.c", "commit_date": "2019-11-10 00:00:00", "repo_name": "DoctorWkt/acwj", "stars": 9661, "license": "gpl-3.0", "language": "c", "size": 1544}
{"docstring": "// Return the position of character c\n// in string s, or -1 if c not found\n", "func_signal": "static int chrpos(char *s, int c)", "code": "{\n  char *p;\n\n  p = strchr(s, c);\n  return (p ? p - s : -1);\n}", "path": "acwj/29_Refactoring/scan.c", "commit_date": "2019-11-10 00:00:00", "repo_name": "DoctorWkt/acwj", "stars": 9661, "license": "gpl-3.0", "language": "c", "size": 1544}
{"docstring": "// Load an integer literal value into a register.\n// Return the number of the register\n", "func_signal": "int cgload(int value)", "code": "{\n\n  // Get a new register\n  int r= alloc_register();\n\n  // Print out the code to initialise it\n  fprintf(Outfile, \"\\tmovq\\t$%d, %s\\n\", value, reglist[r]);\n  return(r);\n}", "path": "acwj/04_Assembly/cg.c", "commit_date": "2019-10-18 00:00:00", "repo_name": "DoctorWkt/acwj", "stars": 9661, "license": "gpl-3.0", "language": "c", "size": 1544}
{"docstring": "// Get the next character from the input file.\n", "func_signal": "static int next(void)", "code": "{\n  int c;\n\n  if (Putback) {\t\t// Use the character put\n    c = Putback;\t\t// back if there is one\n    Putback = 0;\n    return (c);\n  }\n\n  c = fgetc(Infile);\t\t// Read from input file\n  if ('\\n' == c)\n    Line++;\t\t\t// Increment line count\n  return (c);\n}", "path": "acwj/29_Refactoring/scan.c", "commit_date": "2019-11-10 00:00:00", "repo_name": "DoctorWkt/acwj", "stars": 9661, "license": "gpl-3.0", "language": "c", "size": 1544}
{"docstring": "// Call printint() with the given register\n", "func_signal": "void cgprintint(int r)", "code": "{\n  fprintf(Outfile, \"\\tmovq\\t%s, %%rdi\\n\", reglist[r]);\n  fprintf(Outfile, \"\\tcall\\tprintint\\n\");\n  free_register(r);\n}", "path": "acwj/04_Assembly/cg.c", "commit_date": "2019-10-18 00:00:00", "repo_name": "DoctorWkt/acwj", "stars": 9661, "license": "gpl-3.0", "language": "c", "size": 1544}
{"docstring": "// Given a word from the input, return the matching\n// keyword token number or 0 if it's not a keyword.\n// Switch on the first letter so that we don't have\n// to waste time strcmp()ing against all the keywords.\n", "func_signal": "static int keyword(char *s)", "code": "{\n  switch (*s) {\n  case 'c':\n    if (!strcmp(s, \"char\"))\n      return (T_CHAR);\n    break;\n  case 'e':\n    if (!strcmp(s, \"else\"))\n      return (T_ELSE);\n    break;\n  case 'f':\n    if (!strcmp(s, \"for\"))\n      return (T_FOR);\n    break;\n  case 'i':\n    if (!strcmp(s, \"if\"))\n      return (T_IF);\n    if (!strcmp(s, \"int\"))\n      return (T_INT);\n    break;\n  case 'l':\n    if (!strcmp(s, \"long\"))\n      return (T_LONG);\n    break;\n  case 'r':\n    if (!strcmp(s, \"return\"))\n      return (T_RETURN);\n    break;\n  case 'w':\n    if (!strcmp(s, \"while\"))\n      return (T_WHILE);\n    break;\n  case 'v':\n    if (!strcmp(s, \"void\"))\n      return (T_VOID);\n    break;\n  }\n  return (0);\n}", "path": "acwj/29_Refactoring/scan.c", "commit_date": "2019-11-10 00:00:00", "repo_name": "DoctorWkt/acwj", "stars": 9661, "license": "gpl-3.0", "language": "c", "size": 1544}
{"docstring": "// Divide the first register by the second and\n// return the number of the register with the result\n", "func_signal": "int cgdiv(int r1, int r2)", "code": "{\n  fprintf(Outfile, \"\\tmovq\\t%s,%%rax\\n\", reglist[r1]);\n  fprintf(Outfile, \"\\tcqo\\n\");\n  fprintf(Outfile, \"\\tidivq\\t%s\\n\", reglist[r2]);\n  fprintf(Outfile, \"\\tmovq\\t%%rax,%s\\n\", reglist[r1]);\n  free_register(r2);\n  return(r1);\n}", "path": "acwj/04_Assembly/cg.c", "commit_date": "2019-10-18 00:00:00", "repo_name": "DoctorWkt/acwj", "stars": 9661, "license": "gpl-3.0", "language": "c", "size": 1544}
{"docstring": "// Multiply two registers together and return\n// the number of the register with the result\n", "func_signal": "int cgmul(int r1, int r2)", "code": "{\n  fprintf(Outfile, \"\\timulq\\t%s, %s\\n\", reglist[r1], reglist[r2]);\n  free_register(r1);\n  return(r2);\n}", "path": "acwj/04_Assembly/cg.c", "commit_date": "2019-10-18 00:00:00", "repo_name": "DoctorWkt/acwj", "stars": 9661, "license": "gpl-3.0", "language": "c", "size": 1544}
{"docstring": "// Return the next character from a character\n// or string literal\n", "func_signal": "static int scanch(void)", "code": "{\n  int c;\n\n  // Get the next input character and interpret\n  // metacharacters that start with a backslash\n  c = next();\n  if (c == '\\\\') {\n    switch (c = next()) {\n    case 'a':\n      return '\\a';\n    case 'b':\n      return '\\b';\n    case 'f':\n      return '\\f';\n    case 'n':\n      return '\\n';\n    case 'r':\n      return '\\r';\n    case 't':\n      return '\\t';\n    case 'v':\n      return '\\v';\n    case '\\\\':\n      return '\\\\';\n    case '\"':\n      return '\"';\n    case '\\'':\n      return '\\'';\n    default:\n      fatalc(\"unknown escape sequence\", c);\n    }\n  }\n  return (c);\t\t\t// Just an ordinary old character!\n}", "path": "acwj/29_Refactoring/scan.c", "commit_date": "2019-11-10 00:00:00", "repo_name": "DoctorWkt/acwj", "stars": 9661, "license": "gpl-3.0", "language": "c", "size": 1544}
{"docstring": "// Return a register to the list of available registers.\n// Check to see if it's not already there.\n", "func_signal": "static void free_register(int reg)", "code": "{\n  if (freereg[reg] != 0) {\n    fprintf(stderr, \"Error trying to free register %d\\n\", reg);\n    exit(1);\n  }\n  freereg[reg]= 1;\n}", "path": "acwj/04_Assembly/cg.c", "commit_date": "2019-10-18 00:00:00", "repo_name": "DoctorWkt/acwj", "stars": 9661, "license": "gpl-3.0", "language": "c", "size": 1544}
{"docstring": "// Reject the token that we just scanned\n", "func_signal": "void reject_token(struct token *t)", "code": "{\n  if (Rejtoken != NULL)\n    fatal(\"Can't reject token twice\");\n  Rejtoken = t;\n}", "path": "acwj/29_Refactoring/scan.c", "commit_date": "2019-11-10 00:00:00", "repo_name": "DoctorWkt/acwj", "stars": 9661, "license": "gpl-3.0", "language": "c", "size": 1544}
{"docstring": "// Skip past input that we don't need to deal with, \n// i.e. whitespace, newlines. Return the first\n// character we do need to deal with.\n", "func_signal": "static int skip(void)", "code": "{\n  int c;\n\n  c = next();\n  while (' ' == c || '\\t' == c || '\\n' == c || '\\r' == c || '\\f' == c) {\n    c = next();\n  }\n  return (c);\n}", "path": "acwj/29_Refactoring/scan.c", "commit_date": "2019-11-10 00:00:00", "repo_name": "DoctorWkt/acwj", "stars": 9661, "license": "gpl-3.0", "language": "c", "size": 1544}
{"docstring": "// Scan and return an integer literal\n// value from the input file.\n", "func_signal": "static int scanint(int c)", "code": "{\n  int k, val = 0;\n\n  // Convert each character into an int value\n  while ((k = chrpos(\"0123456789\", c)) >= 0) {\n    val = val * 10 + k;\n    c = next();\n  }\n\n  // We hit a non-integer character, put it back.\n  putback(c);\n  return (val);\n}", "path": "acwj/29_Refactoring/scan.c", "commit_date": "2019-11-10 00:00:00", "repo_name": "DoctorWkt/acwj", "stars": 9661, "license": "gpl-3.0", "language": "c", "size": 1544}
{"docstring": "/*\n * find the middle queue element if the queue has odd number of elements\n * or the first element of the queue's second part otherwise\n */\n", "func_signal": "ngx_queue_t *\nngx_queue_middle(ngx_queue_t *queue)", "code": "{\n    ngx_queue_t  *middle, *next;\n\n    middle = ngx_queue_head(queue);\n\n    if (middle == ngx_queue_last(queue)) {\n        return middle;\n    }\n\n    next = ngx_queue_head(queue);\n\n    for ( ;; ) {\n        middle = ngx_queue_next(middle);\n\n        next = ngx_queue_next(next);\n\n        if (next == ngx_queue_last(queue)) {\n            return middle;\n        }\n\n        next = ngx_queue_next(next);\n\n        if (next == ngx_queue_last(queue)) {\n            return middle;\n        }\n    }\n}", "path": "nginx/src/core/ngx_queue.c", "commit_date": "2012-01-18 00:00:00", "repo_name": "nginx/nginx", "stars": 19954, "license": "None", "language": "c", "size": 73356}
{"docstring": "/* the add procedure is optimized to add a growing up sequence */\n", "func_signal": "static char *\nngx_http_geo_add_range(ngx_conf_t *cf, ngx_http_geo_conf_ctx_t *ctx,\n    in_addr_t start, in_addr_t end)", "code": "{\n    in_addr_t              n;\n    ngx_uint_t             h, i, s, e;\n    ngx_array_t           *a;\n    ngx_http_geo_range_t  *range;\n\n    for (n = start; n <= end; n = (n + 0x10000) & 0xffff0000) {\n\n        h = n >> 16;\n\n        if (n == start) {\n            s = n & 0xffff;\n        } else {\n            s = 0;\n        }\n\n        if ((n | 0xffff) > end) {\n            e = end & 0xffff;\n\n        } else {\n            e = 0xffff;\n        }\n\n        a = (ngx_array_t *) ctx->high.low[h];\n\n        if (a == NULL) {\n            a = ngx_array_create(ctx->temp_pool, 64,\n                                 sizeof(ngx_http_geo_range_t));\n            if (a == NULL) {\n                return NGX_CONF_ERROR;\n            }\n\n            ctx->high.low[h] = (ngx_http_geo_range_t *) a;\n        }\n\n        i = a->nelts;\n        range = a->elts;\n\n        while (i) {\n\n            i--;\n\n            if (e < (ngx_uint_t) range[i].start) {\n                continue;\n            }\n\n            if (s > (ngx_uint_t) range[i].end) {\n\n                /* add after the range */\n\n                range = ngx_array_push(a);\n                if (range == NULL) {\n                    return NGX_CONF_ERROR;\n                }\n\n                range = a->elts;\n\n                ngx_memmove(&range[i + 2], &range[i + 1],\n                            (a->nelts - 2 - i) * sizeof(ngx_http_geo_range_t));\n\n                range[i + 1].start = (u_short) s;\n                range[i + 1].end = (u_short) e;\n                range[i + 1].value = ctx->value;\n\n                goto next;\n            }\n\n            if (s == (ngx_uint_t) range[i].start\n                && e == (ngx_uint_t) range[i].end)\n            {\n                ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                    \"duplicate range \\\"%V\\\", value: \\\"%v\\\", old value: \\\"%v\\\"\",\n                    ctx->net, ctx->value, range[i].value);\n\n                range[i].value = ctx->value;\n\n                goto next;\n            }\n\n            if (s > (ngx_uint_t) range[i].start\n                && e < (ngx_uint_t) range[i].end)\n            {\n                /* split the range and insert the new one */\n\n                range = ngx_array_push(a);\n                if (range == NULL) {\n                    return NGX_CONF_ERROR;\n                }\n\n                range = ngx_array_push(a);\n                if (range == NULL) {\n                    return NGX_CONF_ERROR;\n                }\n\n                range = a->elts;\n\n                ngx_memmove(&range[i + 3], &range[i + 1],\n                            (a->nelts - 3 - i) * sizeof(ngx_http_geo_range_t));\n\n                range[i + 2].start = (u_short) (e + 1);\n                range[i + 2].end = range[i].end;\n                range[i + 2].value = range[i].value;\n\n                range[i + 1].start = (u_short) s;\n                range[i + 1].end = (u_short) e;\n                range[i + 1].value = ctx->value;\n\n                range[i].end = (u_short) (s - 1);\n\n                goto next;\n            }\n\n            if (s == (ngx_uint_t) range[i].start\n                && e < (ngx_uint_t) range[i].end)\n            {\n                /* shift the range start and insert the new range */\n\n                range = ngx_array_push(a);\n                if (range == NULL) {\n                    return NGX_CONF_ERROR;\n                }\n\n                range = a->elts;\n\n                ngx_memmove(&range[i + 1], &range[i],\n                            (a->nelts - 1 - i) * sizeof(ngx_http_geo_range_t));\n\n                range[i + 1].start = (u_short) (e + 1);\n\n                range[i].start = (u_short) s;\n                range[i].end = (u_short) e;\n                range[i].value = ctx->value;\n\n                goto next;\n            }\n\n            if (s > (ngx_uint_t) range[i].start\n                && e == (ngx_uint_t) range[i].end)\n            {\n                /* shift the range end and insert the new range */\n\n                range = ngx_array_push(a);\n                if (range == NULL) {\n                    return NGX_CONF_ERROR;\n                }\n\n                range = a->elts;\n\n                ngx_memmove(&range[i + 2], &range[i + 1],\n                            (a->nelts - 2 - i) * sizeof(ngx_http_geo_range_t));\n\n                range[i + 1].start = (u_short) s;\n                range[i + 1].end = (u_short) e;\n                range[i + 1].value = ctx->value;\n\n                range[i].end = (u_short) (s - 1);\n\n                goto next;\n            }\n\n            s = (ngx_uint_t) range[i].start;\n            e = (ngx_uint_t) range[i].end;\n\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                         \"range \\\"%V\\\" overlaps \\\"%d.%d.%d.%d-%d.%d.%d.%d\\\"\",\n                         ctx->net,\n                         h >> 8, h & 0xff, s >> 8, s & 0xff,\n                         h >> 8, h & 0xff, e >> 8, e & 0xff);\n\n            return NGX_CONF_ERROR;\n        }\n\n        /* add the first range */\n\n        range = ngx_array_push(a);\n        if (range == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        range = a->elts;\n\n        ngx_memmove(&range[1], &range[0],\n                    (a->nelts - 1) * sizeof(ngx_http_geo_range_t));\n\n        range[0].start = (u_short) s;\n        range[0].end = (u_short) e;\n        range[0].value = ctx->value;\n\n    next:\n\n        if (h == 0xffff) {\n            break;\n        }\n    }\n\n    return NGX_CONF_OK;\n}", "path": "nginx/src/http/modules/ngx_http_geo_module.c", "commit_date": "2018-12-14 00:00:00", "repo_name": "nginx/nginx", "stars": 19954, "license": "None", "language": "c", "size": 73356}
{"docstring": "/* __amd64__ */\n", "func_signal": "static ngx_inline void\nngx_cpuid(uint32_t i, uint32_t *buf)", "code": "{\n    uint32_t  eax, ebx, ecx, edx;\n\n    __asm__ (\n\n        \"cpuid\"\n\n    : \"=a\" (eax), \"=b\" (ebx), \"=c\" (ecx), \"=d\" (edx) : \"a\" (i) );\n\n    buf[0] = eax;\n    buf[1] = ebx;\n    buf[2] = edx;\n    buf[3] = ecx;\n}", "path": "nginx/src/core/ngx_cpuinfo.c", "commit_date": "2012-01-18 00:00:00", "repo_name": "nginx/nginx", "stars": 19954, "license": "None", "language": "c", "size": 73356}
{"docstring": "/* the copy input filter */\n", "func_signal": "ngx_int_t\nngx_event_pipe_copy_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)", "code": "{\n    ngx_buf_t    *b;\n    ngx_chain_t  *cl;\n\n    if (buf->pos == buf->last) {\n        return NGX_OK;\n    }\n\n    if (p->upstream_done) {\n        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, p->log, 0,\n                       \"input data after close\");\n        return NGX_OK;\n    }\n\n    if (p->length == 0) {\n        p->upstream_done = 1;\n\n        ngx_log_error(NGX_LOG_WARN, p->log, 0,\n                      \"upstream sent more data than specified in \"\n                      \"\\\"Content-Length\\\" header\");\n\n        return NGX_OK;\n    }\n\n    cl = ngx_chain_get_free_buf(p->pool, &p->free);\n    if (cl == NULL) {\n        return NGX_ERROR;\n    }\n\n    b = cl->buf;\n\n    ngx_memcpy(b, buf, sizeof(ngx_buf_t));\n    b->shadow = buf;\n    b->tag = p->tag;\n    b->last_shadow = 1;\n    b->recycled = 1;\n    buf->shadow = b;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, p->log, 0, \"input buf #%d\", b->num);\n\n    if (p->in) {\n        *p->last_in = cl;\n    } else {\n        p->in = cl;\n    }\n    p->last_in = &cl->next;\n\n    if (p->length == -1) {\n        return NGX_OK;\n    }\n\n    if (b->last - b->pos > p->length) {\n\n        ngx_log_error(NGX_LOG_WARN, p->log, 0,\n                      \"upstream sent more data than specified in \"\n                      \"\\\"Content-Length\\\" header\");\n\n        b->last = b->pos + p->length;\n        p->upstream_done = 1;\n\n        return NGX_OK;\n    }\n\n    p->length -= b->last - b->pos;\n\n    return NGX_OK;\n}", "path": "nginx/src/event/ngx_event_pipe.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "nginx/nginx", "stars": 19954, "license": "None", "language": "c", "size": 73356}
{"docstring": "/* geo range is AF_INET only */\n", "func_signal": "static ngx_int_t\nngx_http_geo_cidr_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,\n    uintptr_t data)", "code": "{\n    ngx_http_geo_ctx_t *ctx = (ngx_http_geo_ctx_t *) data;\n\n    in_addr_t                   inaddr;\n    ngx_addr_t                  addr;\n    struct sockaddr_in         *sin;\n    ngx_http_variable_value_t  *vv;\n#if (NGX_HAVE_INET6)\n    u_char                     *p;\n    struct in6_addr            *inaddr6;\n#endif\n\n    if (ngx_http_geo_addr(r, ctx, &addr) != NGX_OK) {\n        vv = (ngx_http_variable_value_t *)\n                  ngx_radix32tree_find(ctx->u.trees.tree, INADDR_NONE);\n        goto done;\n    }\n\n    switch (addr.sockaddr->sa_family) {\n\n#if (NGX_HAVE_INET6)\n    case AF_INET6:\n        inaddr6 = &((struct sockaddr_in6 *) addr.sockaddr)->sin6_addr;\n        p = inaddr6->s6_addr;\n\n        if (IN6_IS_ADDR_V4MAPPED(inaddr6)) {\n            inaddr = p[12] << 24;\n            inaddr += p[13] << 16;\n            inaddr += p[14] << 8;\n            inaddr += p[15];\n\n            vv = (ngx_http_variable_value_t *)\n                      ngx_radix32tree_find(ctx->u.trees.tree, inaddr);\n\n        } else {\n            vv = (ngx_http_variable_value_t *)\n                      ngx_radix128tree_find(ctx->u.trees.tree6, p);\n        }\n\n        break;\n#endif\n\n#if (NGX_HAVE_UNIX_DOMAIN)\n    case AF_UNIX:\n        vv = (ngx_http_variable_value_t *)\n                  ngx_radix32tree_find(ctx->u.trees.tree, INADDR_NONE);\n        break;\n#endif\n\n    default: /* AF_INET */\n        sin = (struct sockaddr_in *) addr.sockaddr;\n        inaddr = ntohl(sin->sin_addr.s_addr);\n\n        vv = (ngx_http_variable_value_t *)\n                  ngx_radix32tree_find(ctx->u.trees.tree, inaddr);\n\n        break;\n    }\n\ndone:\n\n    *v = *vv;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"http geo: %v\", v);\n\n    return NGX_OK;\n}", "path": "nginx/src/http/modules/ngx_http_geo_module.c", "commit_date": "2018-12-14 00:00:00", "repo_name": "nginx/nginx", "stars": 19954, "license": "None", "language": "c", "size": 73356}
{"docstring": "/*\n * we ignore any possible event setting error and\n * fallback to usual periodic file retests\n */\n", "func_signal": "static void\nngx_open_file_add_event(ngx_open_file_cache_t *cache,\n    ngx_cached_open_file_t *file, ngx_open_file_info_t *of, ngx_log_t *log)", "code": "{\n    ngx_open_file_cache_event_t  *fev;\n\n    if (!(ngx_event_flags & NGX_USE_VNODE_EVENT)\n        || !of->events\n        || file->event\n        || of->fd == NGX_INVALID_FILE\n        || file->uses < of->min_uses)\n    {\n        return;\n    }\n\n    file->use_event = 0;\n\n    file->event = ngx_calloc(sizeof(ngx_event_t), log);\n    if (file->event== NULL) {\n        return;\n    }\n\n    fev = ngx_alloc(sizeof(ngx_open_file_cache_event_t), log);\n    if (fev == NULL) {\n        ngx_free(file->event);\n        file->event = NULL;\n        return;\n    }\n\n    fev->fd = of->fd;\n    fev->file = file;\n    fev->cache = cache;\n\n    file->event->handler = ngx_open_file_cache_remove;\n    file->event->data = fev;\n\n    /*\n     * although vnode event may be called while ngx_cycle->poll\n     * destruction, however, cleanup procedures are run before any\n     * memory freeing and events will be canceled.\n     */\n\n    file->event->log = ngx_cycle->log;\n\n    if (ngx_add_event(file->event, NGX_VNODE_EVENT, NGX_ONESHOT_EVENT)\n        != NGX_OK)\n    {\n        ngx_free(file->event->data);\n        ngx_free(file->event);\n        file->event = NULL;\n        return;\n    }\n\n    /*\n     * we do not set file->use_event here because there may be a race\n     * condition: a file may be deleted between opening the file and\n     * adding event, so we rely upon event notification only after\n     * one file revalidation on next file access\n     */\n\n    return;\n}", "path": "nginx/src/core/ngx_open_file_cache.c", "commit_date": "2016-03-30 00:00:00", "repo_name": "nginx/nginx", "stars": 19954, "license": "None", "language": "c", "size": 73356}
{"docstring": "/*\n * add the server address, the server names and the server core module\n * configurations to the port list\n */\n", "func_signal": "static ngx_int_t\nngx_http_add_address(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,\n    ngx_http_conf_port_t *port, ngx_http_listen_opt_t *lsopt)", "code": "{\n    ngx_http_conf_addr_t  *addr;\n\n    if (port->addrs.elts == NULL) {\n        if (ngx_array_init(&port->addrs, cf->temp_pool, 4,\n                           sizeof(ngx_http_conf_addr_t))\n            != NGX_OK)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n#if (NGX_HTTP_V2 && NGX_HTTP_SSL                                              \\\n     && !defined TLSEXT_TYPE_application_layer_protocol_negotiation           \\\n     && !defined TLSEXT_TYPE_next_proto_neg)\n\n    if (lsopt->http2 && lsopt->ssl) {\n        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                           \"nginx was built with OpenSSL that lacks ALPN \"\n                           \"and NPN support, HTTP/2 is not enabled for %V\",\n                           &lsopt->addr_text);\n    }\n\n#endif\n\n#if (NGX_HTTP_QUIC && !defined NGX_OPENSSL_QUIC)\n\n    if (lsopt->quic) {\n        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                           \"nginx was built with OpenSSL that lacks QUIC \"\n                           \"support, QUIC is not enabled for %V\",\n                           &lsopt->addr_text);\n    }\n\n#endif\n\n    addr = ngx_array_push(&port->addrs);\n    if (addr == NULL) {\n        return NGX_ERROR;\n    }\n\n    addr->opt = *lsopt;\n    addr->hash.buckets = NULL;\n    addr->hash.size = 0;\n    addr->wc_head = NULL;\n    addr->wc_tail = NULL;\n#if (NGX_PCRE)\n    addr->nregex = 0;\n    addr->regex = NULL;\n#endif\n    addr->default_server = cscf;\n    addr->servers.elts = NULL;\n\n    return ngx_http_add_server(cf, cscf, addr);\n}", "path": "nginx/src/http/ngx_http.c", "commit_date": "2020-07-21 00:00:00", "repo_name": "nginx/nginx", "stars": 19954, "license": "None", "language": "c", "size": 73356}
{"docstring": "/* the add procedure is optimized to add a growing up sequence */\n", "func_signal": "static char *\nngx_stream_geo_add_range(ngx_conf_t *cf, ngx_stream_geo_conf_ctx_t *ctx,\n    in_addr_t start, in_addr_t end)", "code": "{\n    in_addr_t                n;\n    ngx_uint_t               h, i, s, e;\n    ngx_array_t             *a;\n    ngx_stream_geo_range_t  *range;\n\n    for (n = start; n <= end; n = (n + 0x10000) & 0xffff0000) {\n\n        h = n >> 16;\n\n        if (n == start) {\n            s = n & 0xffff;\n        } else {\n            s = 0;\n        }\n\n        if ((n | 0xffff) > end) {\n            e = end & 0xffff;\n\n        } else {\n            e = 0xffff;\n        }\n\n        a = (ngx_array_t *) ctx->high.low[h];\n\n        if (a == NULL) {\n            a = ngx_array_create(ctx->temp_pool, 64,\n                                 sizeof(ngx_stream_geo_range_t));\n            if (a == NULL) {\n                return NGX_CONF_ERROR;\n            }\n\n            ctx->high.low[h] = (ngx_stream_geo_range_t *) a;\n        }\n\n        i = a->nelts;\n        range = a->elts;\n\n        while (i) {\n\n            i--;\n\n            if (e < (ngx_uint_t) range[i].start) {\n                continue;\n            }\n\n            if (s > (ngx_uint_t) range[i].end) {\n\n                /* add after the range */\n\n                range = ngx_array_push(a);\n                if (range == NULL) {\n                    return NGX_CONF_ERROR;\n                }\n\n                range = a->elts;\n\n                ngx_memmove(&range[i + 2], &range[i + 1],\n                           (a->nelts - 2 - i) * sizeof(ngx_stream_geo_range_t));\n\n                range[i + 1].start = (u_short) s;\n                range[i + 1].end = (u_short) e;\n                range[i + 1].value = ctx->value;\n\n                goto next;\n            }\n\n            if (s == (ngx_uint_t) range[i].start\n                && e == (ngx_uint_t) range[i].end)\n            {\n                ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                    \"duplicate range \\\"%V\\\", value: \\\"%v\\\", old value: \\\"%v\\\"\",\n                    ctx->net, ctx->value, range[i].value);\n\n                range[i].value = ctx->value;\n\n                goto next;\n            }\n\n            if (s > (ngx_uint_t) range[i].start\n                && e < (ngx_uint_t) range[i].end)\n            {\n                /* split the range and insert the new one */\n\n                range = ngx_array_push(a);\n                if (range == NULL) {\n                    return NGX_CONF_ERROR;\n                }\n\n                range = ngx_array_push(a);\n                if (range == NULL) {\n                    return NGX_CONF_ERROR;\n                }\n\n                range = a->elts;\n\n                ngx_memmove(&range[i + 3], &range[i + 1],\n                           (a->nelts - 3 - i) * sizeof(ngx_stream_geo_range_t));\n\n                range[i + 2].start = (u_short) (e + 1);\n                range[i + 2].end = range[i].end;\n                range[i + 2].value = range[i].value;\n\n                range[i + 1].start = (u_short) s;\n                range[i + 1].end = (u_short) e;\n                range[i + 1].value = ctx->value;\n\n                range[i].end = (u_short) (s - 1);\n\n                goto next;\n            }\n\n            if (s == (ngx_uint_t) range[i].start\n                && e < (ngx_uint_t) range[i].end)\n            {\n                /* shift the range start and insert the new range */\n\n                range = ngx_array_push(a);\n                if (range == NULL) {\n                    return NGX_CONF_ERROR;\n                }\n\n                range = a->elts;\n\n                ngx_memmove(&range[i + 1], &range[i],\n                           (a->nelts - 1 - i) * sizeof(ngx_stream_geo_range_t));\n\n                range[i + 1].start = (u_short) (e + 1);\n\n                range[i].start = (u_short) s;\n                range[i].end = (u_short) e;\n                range[i].value = ctx->value;\n\n                goto next;\n            }\n\n            if (s > (ngx_uint_t) range[i].start\n                && e == (ngx_uint_t) range[i].end)\n            {\n                /* shift the range end and insert the new range */\n\n                range = ngx_array_push(a);\n                if (range == NULL) {\n                    return NGX_CONF_ERROR;\n                }\n\n                range = a->elts;\n\n                ngx_memmove(&range[i + 2], &range[i + 1],\n                           (a->nelts - 2 - i) * sizeof(ngx_stream_geo_range_t));\n\n                range[i + 1].start = (u_short) s;\n                range[i + 1].end = (u_short) e;\n                range[i + 1].value = ctx->value;\n\n                range[i].end = (u_short) (s - 1);\n\n                goto next;\n            }\n\n            s = (ngx_uint_t) range[i].start;\n            e = (ngx_uint_t) range[i].end;\n\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                         \"range \\\"%V\\\" overlaps \\\"%d.%d.%d.%d-%d.%d.%d.%d\\\"\",\n                         ctx->net,\n                         h >> 8, h & 0xff, s >> 8, s & 0xff,\n                         h >> 8, h & 0xff, e >> 8, e & 0xff);\n\n            return NGX_CONF_ERROR;\n        }\n\n        /* add the first range */\n\n        range = ngx_array_push(a);\n        if (range == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        range = a->elts;\n\n        ngx_memmove(&range[1], &range[0],\n                    (a->nelts - 1) * sizeof(ngx_stream_geo_range_t));\n\n        range[0].start = (u_short) s;\n        range[0].end = (u_short) e;\n        range[0].value = ctx->value;\n\n    next:\n\n        if (h == 0xffff) {\n            break;\n        }\n    }\n\n    return NGX_CONF_OK;\n}", "path": "nginx/src/stream/ngx_stream_geo_module.c", "commit_date": "2018-12-14 00:00:00", "repo_name": "nginx/nginx", "stars": 19954, "license": "None", "language": "c", "size": 73356}
{"docstring": "/*\n * the event timer rbtree may contain the duplicate keys, however,\n * it should not be a problem, because we use the rbtree to find\n * a minimum timer value only\n */\n", "func_signal": "ngx_int_t\nngx_event_timer_init(ngx_log_t *log)", "code": "{\n    ngx_rbtree_init(&ngx_event_timer_rbtree, &ngx_event_timer_sentinel,\n                    ngx_rbtree_insert_timer_value);\n\n    return NGX_OK;\n}", "path": "nginx/src/event/ngx_event_timer.c", "commit_date": "2017-03-17 00:00:00", "repo_name": "nginx/nginx", "stars": 19954, "license": "None", "language": "c", "size": 73356}
{"docstring": "/* NGX_HAVE_OPENAT */\n", "func_signal": "static ngx_fd_t\nngx_open_file_wrapper(ngx_str_t *name, ngx_open_file_info_t *of,\n    ngx_int_t mode, ngx_int_t create, ngx_int_t access, ngx_log_t *log)", "code": "{\n    ngx_fd_t  fd;\n\n#if !(NGX_HAVE_OPENAT)\n\n    fd = ngx_open_file(name->data, mode, create, access);\n\n    if (fd == NGX_INVALID_FILE) {\n        of->err = ngx_errno;\n        of->failed = ngx_open_file_n;\n        return NGX_INVALID_FILE;\n    }\n\n    return fd;\n\n#else\n\n    u_char           *p, *cp, *end;\n    ngx_fd_t          at_fd;\n    ngx_str_t         at_name;\n\n    if (of->disable_symlinks == NGX_DISABLE_SYMLINKS_OFF) {\n        fd = ngx_open_file(name->data, mode, create, access);\n\n        if (fd == NGX_INVALID_FILE) {\n            of->err = ngx_errno;\n            of->failed = ngx_open_file_n;\n            return NGX_INVALID_FILE;\n        }\n\n        return fd;\n    }\n\n    p = name->data;\n    end = p + name->len;\n\n    at_name = *name;\n\n    if (of->disable_symlinks_from) {\n\n        cp = p + of->disable_symlinks_from;\n\n        *cp = '\\0';\n\n        at_fd = ngx_open_file(p, NGX_FILE_SEARCH|NGX_FILE_NONBLOCK,\n                              NGX_FILE_OPEN, 0);\n\n        *cp = '/';\n\n        if (at_fd == NGX_INVALID_FILE) {\n            of->err = ngx_errno;\n            of->failed = ngx_open_file_n;\n            return NGX_INVALID_FILE;\n        }\n\n        at_name.len = of->disable_symlinks_from;\n        p = cp + 1;\n\n    } else if (*p == '/') {\n\n        at_fd = ngx_open_file(\"/\",\n                              NGX_FILE_SEARCH|NGX_FILE_NONBLOCK,\n                              NGX_FILE_OPEN, 0);\n\n        if (at_fd == NGX_INVALID_FILE) {\n            of->err = ngx_errno;\n            of->failed = ngx_openat_file_n;\n            return NGX_INVALID_FILE;\n        }\n\n        at_name.len = 1;\n        p++;\n\n    } else {\n        at_fd = NGX_AT_FDCWD;\n    }\n\n    for ( ;; ) {\n        cp = ngx_strlchr(p, end, '/');\n        if (cp == NULL) {\n            break;\n        }\n\n        if (cp == p) {\n            p++;\n            continue;\n        }\n\n        *cp = '\\0';\n\n        if (of->disable_symlinks == NGX_DISABLE_SYMLINKS_NOTOWNER) {\n            fd = ngx_openat_file_owner(at_fd, p,\n                                       NGX_FILE_SEARCH|NGX_FILE_NONBLOCK,\n                                       NGX_FILE_OPEN, 0, log);\n\n        } else {\n            fd = ngx_openat_file(at_fd, p,\n                           NGX_FILE_SEARCH|NGX_FILE_NONBLOCK|NGX_FILE_NOFOLLOW,\n                           NGX_FILE_OPEN, 0);\n        }\n\n        *cp = '/';\n\n        if (fd == NGX_INVALID_FILE) {\n            of->err = ngx_errno;\n            of->failed = ngx_openat_file_n;\n            goto failed;\n        }\n\n        if (at_fd != NGX_AT_FDCWD && ngx_close_file(at_fd) == NGX_FILE_ERROR) {\n            ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n                          ngx_close_file_n \" \\\"%V\\\" failed\", &at_name);\n        }\n\n        p = cp + 1;\n        at_fd = fd;\n        at_name.len = cp - at_name.data;\n    }\n\n    if (p == end) {\n\n        /*\n         * If pathname ends with a trailing slash, assume the last path\n         * component is a directory and reopen it with requested flags;\n         * if not, fail with ENOTDIR as per POSIX.\n         *\n         * We cannot rely on O_DIRECTORY in the loop above to check\n         * that the last path component is a directory because\n         * O_DIRECTORY doesn't work on FreeBSD 8.  Fortunately, by\n         * reopening a directory, we don't depend on it at all.\n         */\n\n        fd = ngx_openat_file(at_fd, \".\", mode, create, access);\n        goto done;\n    }\n\n    if (of->disable_symlinks == NGX_DISABLE_SYMLINKS_NOTOWNER\n        && !(create & (NGX_FILE_CREATE_OR_OPEN|NGX_FILE_TRUNCATE)))\n    {\n        fd = ngx_openat_file_owner(at_fd, p, mode, create, access, log);\n\n    } else {\n        fd = ngx_openat_file(at_fd, p, mode|NGX_FILE_NOFOLLOW, create, access);\n    }\n\ndone:\n\n    if (fd == NGX_INVALID_FILE) {\n        of->err = ngx_errno;\n        of->failed = ngx_openat_file_n;\n    }\n\nfailed:\n\n    if (at_fd != NGX_AT_FDCWD && ngx_close_file(at_fd) == NGX_FILE_ERROR) {\n        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n                      ngx_close_file_n \" \\\"%V\\\" failed\", &at_name);\n    }\n\n    return fd;\n#endif\n}", "path": "nginx/src/core/ngx_open_file_cache.c", "commit_date": "2016-03-30 00:00:00", "repo_name": "nginx/nginx", "stars": 19954, "license": "None", "language": "c", "size": 73356}
{"docstring": "/* FILE_FLAG_BACKUP_SEMANTICS allows to obtain a handle to a directory */\n", "func_signal": "ngx_fd_t\nngx_open_file(u_char *name, u_long mode, u_long create, u_long access)", "code": "{\n    size_t      len;\n    u_short    *u;\n    ngx_fd_t    fd;\n    ngx_err_t   err;\n    u_short     utf16[NGX_UTF16_BUFLEN];\n\n    len = NGX_UTF16_BUFLEN;\n    u = ngx_utf8_to_utf16(utf16, name, &len);\n\n    if (u == NULL) {\n        return INVALID_HANDLE_VALUE;\n    }\n\n    fd = INVALID_HANDLE_VALUE;\n\n    if (create == NGX_FILE_OPEN\n        && ngx_win32_check_filename(name, u, len) != NGX_OK)\n    {\n        goto failed;\n    }\n\n    fd = CreateFileW(u, mode,\n                     FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,\n                     NULL, create, FILE_FLAG_BACKUP_SEMANTICS, NULL);\n\nfailed:\n\n    if (u != utf16) {\n        err = ngx_errno;\n        ngx_free(u);\n        ngx_set_errno(err);\n    }\n\n    return fd;\n}", "path": "nginx/src/os/win32/ngx_files.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "nginx/nginx", "stars": 19954, "license": "None", "language": "c", "size": 73356}
{"docstring": "/*\n * This processes one or more 64-byte data blocks, but does not update\n * the bit counters.  There are no alignment requirements.\n */\n", "func_signal": "static const u_char *\nngx_sha1_body(ngx_sha1_t *ctx, const u_char *data, size_t size)", "code": "{\n    uint32_t       a, b, c, d, e, temp;\n    uint32_t       saved_a, saved_b, saved_c, saved_d, saved_e;\n    uint32_t       words[80];\n    ngx_uint_t     i;\n    const u_char  *p;\n\n    p = data;\n\n    a = ctx->a;\n    b = ctx->b;\n    c = ctx->c;\n    d = ctx->d;\n    e = ctx->e;\n\n    do {\n        saved_a = a;\n        saved_b = b;\n        saved_c = c;\n        saved_d = d;\n        saved_e = e;\n\n        /* Load data block into the words array */\n\n        for (i = 0; i < 16; i++) {\n            words[i] = GET(i);\n        }\n\n        for (i = 16; i < 80; i++) {\n            words[i] = ROTATE(1, words[i - 3] ^ words[i - 8] ^ words[i - 14]\n                                 ^ words[i - 16]);\n        }\n\n        /* Transformations */\n\n        STEP(F1, a, b, c, d, e, words[0],  0x5a827999);\n        STEP(F1, a, b, c, d, e, words[1],  0x5a827999);\n        STEP(F1, a, b, c, d, e, words[2],  0x5a827999);\n        STEP(F1, a, b, c, d, e, words[3],  0x5a827999);\n        STEP(F1, a, b, c, d, e, words[4],  0x5a827999);\n        STEP(F1, a, b, c, d, e, words[5],  0x5a827999);\n        STEP(F1, a, b, c, d, e, words[6],  0x5a827999);\n        STEP(F1, a, b, c, d, e, words[7],  0x5a827999);\n        STEP(F1, a, b, c, d, e, words[8],  0x5a827999);\n        STEP(F1, a, b, c, d, e, words[9],  0x5a827999);\n        STEP(F1, a, b, c, d, e, words[10], 0x5a827999);\n        STEP(F1, a, b, c, d, e, words[11], 0x5a827999);\n        STEP(F1, a, b, c, d, e, words[12], 0x5a827999);\n        STEP(F1, a, b, c, d, e, words[13], 0x5a827999);\n        STEP(F1, a, b, c, d, e, words[14], 0x5a827999);\n        STEP(F1, a, b, c, d, e, words[15], 0x5a827999);\n        STEP(F1, a, b, c, d, e, words[16], 0x5a827999);\n        STEP(F1, a, b, c, d, e, words[17], 0x5a827999);\n        STEP(F1, a, b, c, d, e, words[18], 0x5a827999);\n        STEP(F1, a, b, c, d, e, words[19], 0x5a827999);\n\n        STEP(F2, a, b, c, d, e, words[20], 0x6ed9eba1);\n        STEP(F2, a, b, c, d, e, words[21], 0x6ed9eba1);\n        STEP(F2, a, b, c, d, e, words[22], 0x6ed9eba1);\n        STEP(F2, a, b, c, d, e, words[23], 0x6ed9eba1);\n        STEP(F2, a, b, c, d, e, words[24], 0x6ed9eba1);\n        STEP(F2, a, b, c, d, e, words[25], 0x6ed9eba1);\n        STEP(F2, a, b, c, d, e, words[26], 0x6ed9eba1);\n        STEP(F2, a, b, c, d, e, words[27], 0x6ed9eba1);\n        STEP(F2, a, b, c, d, e, words[28], 0x6ed9eba1);\n        STEP(F2, a, b, c, d, e, words[29], 0x6ed9eba1);\n        STEP(F2, a, b, c, d, e, words[30], 0x6ed9eba1);\n        STEP(F2, a, b, c, d, e, words[31], 0x6ed9eba1);\n        STEP(F2, a, b, c, d, e, words[32], 0x6ed9eba1);\n        STEP(F2, a, b, c, d, e, words[33], 0x6ed9eba1);\n        STEP(F2, a, b, c, d, e, words[34], 0x6ed9eba1);\n        STEP(F2, a, b, c, d, e, words[35], 0x6ed9eba1);\n        STEP(F2, a, b, c, d, e, words[36], 0x6ed9eba1);\n        STEP(F2, a, b, c, d, e, words[37], 0x6ed9eba1);\n        STEP(F2, a, b, c, d, e, words[38], 0x6ed9eba1);\n        STEP(F2, a, b, c, d, e, words[39], 0x6ed9eba1);\n\n        STEP(F3, a, b, c, d, e, words[40], 0x8f1bbcdc);\n        STEP(F3, a, b, c, d, e, words[41], 0x8f1bbcdc);\n        STEP(F3, a, b, c, d, e, words[42], 0x8f1bbcdc);\n        STEP(F3, a, b, c, d, e, words[43], 0x8f1bbcdc);\n        STEP(F3, a, b, c, d, e, words[44], 0x8f1bbcdc);\n        STEP(F3, a, b, c, d, e, words[45], 0x8f1bbcdc);\n        STEP(F3, a, b, c, d, e, words[46], 0x8f1bbcdc);\n        STEP(F3, a, b, c, d, e, words[47], 0x8f1bbcdc);\n        STEP(F3, a, b, c, d, e, words[48], 0x8f1bbcdc);\n        STEP(F3, a, b, c, d, e, words[49], 0x8f1bbcdc);\n        STEP(F3, a, b, c, d, e, words[50], 0x8f1bbcdc);\n        STEP(F3, a, b, c, d, e, words[51], 0x8f1bbcdc);\n        STEP(F3, a, b, c, d, e, words[52], 0x8f1bbcdc);\n        STEP(F3, a, b, c, d, e, words[53], 0x8f1bbcdc);\n        STEP(F3, a, b, c, d, e, words[54], 0x8f1bbcdc);\n        STEP(F3, a, b, c, d, e, words[55], 0x8f1bbcdc);\n        STEP(F3, a, b, c, d, e, words[56], 0x8f1bbcdc);\n        STEP(F3, a, b, c, d, e, words[57], 0x8f1bbcdc);\n        STEP(F3, a, b, c, d, e, words[58], 0x8f1bbcdc);\n        STEP(F3, a, b, c, d, e, words[59], 0x8f1bbcdc);\n\n        STEP(F2, a, b, c, d, e, words[60], 0xca62c1d6);\n        STEP(F2, a, b, c, d, e, words[61], 0xca62c1d6);\n        STEP(F2, a, b, c, d, e, words[62], 0xca62c1d6);\n        STEP(F2, a, b, c, d, e, words[63], 0xca62c1d6);\n        STEP(F2, a, b, c, d, e, words[64], 0xca62c1d6);\n        STEP(F2, a, b, c, d, e, words[65], 0xca62c1d6);\n        STEP(F2, a, b, c, d, e, words[66], 0xca62c1d6);\n        STEP(F2, a, b, c, d, e, words[67], 0xca62c1d6);\n        STEP(F2, a, b, c, d, e, words[68], 0xca62c1d6);\n        STEP(F2, a, b, c, d, e, words[69], 0xca62c1d6);\n        STEP(F2, a, b, c, d, e, words[70], 0xca62c1d6);\n        STEP(F2, a, b, c, d, e, words[71], 0xca62c1d6);\n        STEP(F2, a, b, c, d, e, words[72], 0xca62c1d6);\n        STEP(F2, a, b, c, d, e, words[73], 0xca62c1d6);\n        STEP(F2, a, b, c, d, e, words[74], 0xca62c1d6);\n        STEP(F2, a, b, c, d, e, words[75], 0xca62c1d6);\n        STEP(F2, a, b, c, d, e, words[76], 0xca62c1d6);\n        STEP(F2, a, b, c, d, e, words[77], 0xca62c1d6);\n        STEP(F2, a, b, c, d, e, words[78], 0xca62c1d6);\n        STEP(F2, a, b, c, d, e, words[79], 0xca62c1d6);\n\n        a += saved_a;\n        b += saved_b;\n        c += saved_c;\n        d += saved_d;\n        e += saved_e;\n\n        p += 64;\n\n    } while (size -= 64);\n\n    ctx->a = a;\n    ctx->b = b;\n    ctx->c = c;\n    ctx->d = d;\n    ctx->e = e;\n\n    return p;\n}", "path": "nginx/src/core/ngx_sha1.c", "commit_date": "2016-06-30 00:00:00", "repo_name": "nginx/nginx", "stars": 19954, "license": "None", "language": "c", "size": 73356}
{"docstring": "/* geo range is AF_INET only */\n", "func_signal": "static ngx_int_t\nngx_stream_geo_cidr_variable(ngx_stream_session_t *s,\n    ngx_stream_variable_value_t *v, uintptr_t data)", "code": "{\n    ngx_stream_geo_ctx_t *ctx = (ngx_stream_geo_ctx_t *) data;\n\n    in_addr_t                     inaddr;\n    ngx_addr_t                    addr;\n    struct sockaddr_in           *sin;\n    ngx_stream_variable_value_t  *vv;\n#if (NGX_HAVE_INET6)\n    u_char                       *p;\n    struct in6_addr              *inaddr6;\n#endif\n\n    if (ngx_stream_geo_addr(s, ctx, &addr) != NGX_OK) {\n        vv = (ngx_stream_variable_value_t *)\n                  ngx_radix32tree_find(ctx->u.trees.tree, INADDR_NONE);\n        goto done;\n    }\n\n    switch (addr.sockaddr->sa_family) {\n\n#if (NGX_HAVE_INET6)\n    case AF_INET6:\n        inaddr6 = &((struct sockaddr_in6 *) addr.sockaddr)->sin6_addr;\n        p = inaddr6->s6_addr;\n\n        if (IN6_IS_ADDR_V4MAPPED(inaddr6)) {\n            inaddr = p[12] << 24;\n            inaddr += p[13] << 16;\n            inaddr += p[14] << 8;\n            inaddr += p[15];\n\n            vv = (ngx_stream_variable_value_t *)\n                      ngx_radix32tree_find(ctx->u.trees.tree, inaddr);\n\n        } else {\n            vv = (ngx_stream_variable_value_t *)\n                      ngx_radix128tree_find(ctx->u.trees.tree6, p);\n        }\n\n        break;\n#endif\n\n#if (NGX_HAVE_UNIX_DOMAIN)\n    case AF_UNIX:\n        vv = (ngx_stream_variable_value_t *)\n                  ngx_radix32tree_find(ctx->u.trees.tree, INADDR_NONE);\n        break;\n#endif\n\n    default: /* AF_INET */\n        sin = (struct sockaddr_in *) addr.sockaddr;\n        inaddr = ntohl(sin->sin_addr.s_addr);\n\n        vv = (ngx_stream_variable_value_t *)\n                  ngx_radix32tree_find(ctx->u.trees.tree, inaddr);\n\n        break;\n    }\n\ndone:\n\n    *v = *vv;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,\n                   \"stream geo: %v\", v);\n\n    return NGX_OK;\n}", "path": "nginx/src/stream/ngx_stream_geo_module.c", "commit_date": "2018-12-14 00:00:00", "repo_name": "nginx/nginx", "stars": 19954, "license": "None", "language": "c", "size": 73356}
{"docstring": "/*\n * It seems that Darwin 9.4 (Mac OS X 1.5) sendfile() has the same\n * old bug as early FreeBSD sendfile() syscall:\n * http://bugs.freebsd.org/33771\n *\n * Besides sendfile() has another bug: if one calls sendfile()\n * with both a header and a trailer, then sendfile() ignores a file part\n * at all and sends only the header and the trailer together.\n * For this reason we send a trailer only if there is no a header.\n *\n * Although sendfile() allows to pass a header or a trailer,\n * it may send the header or the trailer and a part of the file\n * in different packets.  And FreeBSD workaround (TCP_NOPUSH option)\n * does not help.\n */\n", "func_signal": "ngx_chain_t *\nngx_darwin_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)", "code": "{\n    int              rc;\n    off_t            send, prev_send, sent;\n    off_t            file_size;\n    ssize_t          n;\n    ngx_uint_t       eintr;\n    ngx_err_t        err;\n    ngx_buf_t       *file;\n    ngx_event_t     *wev;\n    ngx_chain_t     *cl;\n    ngx_iovec_t      header, trailer;\n    struct sf_hdtr   hdtr;\n    struct iovec     headers[NGX_IOVS_PREALLOCATE];\n    struct iovec     trailers[NGX_IOVS_PREALLOCATE];\n\n    wev = c->write;\n\n    if (!wev->ready) {\n        return in;\n    }\n\n#if (NGX_HAVE_KQUEUE)\n\n    if ((ngx_event_flags & NGX_USE_KQUEUE_EVENT) && wev->pending_eof) {\n        (void) ngx_connection_error(c, wev->kq_errno,\n                               \"kevent() reported about an closed connection\");\n        wev->error = 1;\n        return NGX_CHAIN_ERROR;\n    }\n\n#endif\n\n    /* the maximum limit size is the maximum size_t value - the page size */\n\n    if (limit == 0 || limit > (off_t) (NGX_MAX_SIZE_T_VALUE - ngx_pagesize)) {\n        limit = NGX_MAX_SIZE_T_VALUE - ngx_pagesize;\n    }\n\n    send = 0;\n\n    header.iovs = headers;\n    header.nalloc = NGX_IOVS_PREALLOCATE;\n\n    trailer.iovs = trailers;\n    trailer.nalloc = NGX_IOVS_PREALLOCATE;\n\n    for ( ;; ) {\n        eintr = 0;\n        prev_send = send;\n\n        /* create the header iovec and coalesce the neighbouring bufs */\n\n        cl = ngx_output_chain_to_iovec(&header, in, limit - send, c->log);\n\n        if (cl == NGX_CHAIN_ERROR) {\n            return NGX_CHAIN_ERROR;\n        }\n\n        send += header.size;\n\n        if (cl && cl->buf->in_file && send < limit) {\n            file = cl->buf;\n\n            /* coalesce the neighbouring file bufs */\n\n            file_size = ngx_chain_coalesce_file(&cl, limit - send);\n\n            send += file_size;\n\n            if (header.count == 0 && send < limit) {\n\n                /*\n                 * create the trailer iovec and coalesce the neighbouring bufs\n                 */\n\n                cl = ngx_output_chain_to_iovec(&trailer, cl, limit - send,\n                                               c->log);\n                if (cl == NGX_CHAIN_ERROR) {\n                    return NGX_CHAIN_ERROR;\n                }\n\n                send += trailer.size;\n\n            } else {\n                trailer.count = 0;\n            }\n\n            /*\n             * sendfile() returns EINVAL if sf_hdtr's count is 0,\n             * but corresponding pointer is not NULL\n             */\n\n            hdtr.headers = header.count ? header.iovs : NULL;\n            hdtr.hdr_cnt = header.count;\n            hdtr.trailers = trailer.count ? trailer.iovs : NULL;\n            hdtr.trl_cnt = trailer.count;\n\n            sent = header.size + file_size;\n\n            ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                           \"sendfile: @%O %O h:%uz\",\n                           file->file_pos, sent, header.size);\n\n            rc = sendfile(file->file->fd, c->fd, file->file_pos,\n                          &sent, &hdtr, 0);\n\n            if (rc == -1) {\n                err = ngx_errno;\n\n                switch (err) {\n                case NGX_EAGAIN:\n                    break;\n\n                case NGX_EINTR:\n                    eintr = 1;\n                    break;\n\n                default:\n                    wev->error = 1;\n                    (void) ngx_connection_error(c, err, \"sendfile() failed\");\n                    return NGX_CHAIN_ERROR;\n                }\n\n                ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, err,\n                               \"sendfile() sent only %O bytes\", sent);\n            }\n\n            if (rc == 0 && sent == 0) {\n\n                /*\n                 * if rc and sent equal to zero, then someone\n                 * has truncated the file, so the offset became beyond\n                 * the end of the file\n                 */\n\n                ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n                              \"sendfile() reported that \\\"%s\\\" was truncated\",\n                              file->file->name.data);\n\n                return NGX_CHAIN_ERROR;\n            }\n\n            ngx_log_debug4(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                           \"sendfile: %d, @%O %O:%O\",\n                           rc, file->file_pos, sent, file_size + header.size);\n\n        } else {\n            n = ngx_writev(c, &header);\n\n            if (n == NGX_ERROR) {\n                return NGX_CHAIN_ERROR;\n            }\n\n            sent = (n == NGX_AGAIN) ? 0 : n;\n        }\n\n        c->sent += sent;\n\n        in = ngx_chain_update_sent(in, sent);\n\n        if (eintr) {\n            send = prev_send + sent;\n            continue;\n        }\n\n        if (send - prev_send != sent) {\n            wev->ready = 0;\n            return in;\n        }\n\n        if (send >= limit || in == NULL) {\n            return in;\n        }\n    }\n}", "path": "nginx/src/os/unix/ngx_darwin_sendfile_chain.c", "commit_date": "2017-01-20 00:00:00", "repo_name": "nginx/nginx", "stars": 19954, "license": "None", "language": "c", "size": 73356}
{"docstring": "/* the stable insertion sort */\n", "func_signal": "void\nngx_queue_sort(ngx_queue_t *queue,\n    ngx_int_t (*cmp)(const ngx_queue_t *, const ngx_queue_t *))", "code": "{\n    ngx_queue_t  *q, *prev, *next;\n\n    q = ngx_queue_head(queue);\n\n    if (q == ngx_queue_last(queue)) {\n        return;\n    }\n\n    for (q = ngx_queue_next(q); q != ngx_queue_sentinel(queue); q = next) {\n\n        prev = ngx_queue_prev(q);\n        next = ngx_queue_next(q);\n\n        ngx_queue_remove(q);\n\n        do {\n            if (cmp(prev, q) <= 0) {\n                break;\n            }\n\n            prev = ngx_queue_prev(prev);\n\n        } while (prev != ngx_queue_sentinel(queue));\n\n        ngx_queue_insert_after(prev, q);\n    }\n}", "path": "nginx/src/core/ngx_queue.c", "commit_date": "2012-01-18 00:00:00", "repo_name": "nginx/nginx", "stars": 19954, "license": "None", "language": "c", "size": 73356}
{"docstring": "/*\n * This processes one or more 64-byte data blocks, but does not update\n * the bit counters.  There are no alignment requirements.\n */\n", "func_signal": "static const u_char *\nngx_md5_body(ngx_md5_t *ctx, const u_char *data, size_t size)", "code": "{\n    uint32_t       a, b, c, d;\n    uint32_t       saved_a, saved_b, saved_c, saved_d;\n    const u_char  *p;\n#if !(NGX_HAVE_LITTLE_ENDIAN && NGX_HAVE_NONALIGNED)\n    uint32_t       block[16];\n#endif\n\n    p = data;\n\n    a = ctx->a;\n    b = ctx->b;\n    c = ctx->c;\n    d = ctx->d;\n\n    do {\n        saved_a = a;\n        saved_b = b;\n        saved_c = c;\n        saved_d = d;\n\n        /* Round 1 */\n\n        STEP(F, a, b, c, d, SET(0),  0xd76aa478, 7);\n        STEP(F, d, a, b, c, SET(1),  0xe8c7b756, 12);\n        STEP(F, c, d, a, b, SET(2),  0x242070db, 17);\n        STEP(F, b, c, d, a, SET(3),  0xc1bdceee, 22);\n        STEP(F, a, b, c, d, SET(4),  0xf57c0faf, 7);\n        STEP(F, d, a, b, c, SET(5),  0x4787c62a, 12);\n        STEP(F, c, d, a, b, SET(6),  0xa8304613, 17);\n        STEP(F, b, c, d, a, SET(7),  0xfd469501, 22);\n        STEP(F, a, b, c, d, SET(8),  0x698098d8, 7);\n        STEP(F, d, a, b, c, SET(9),  0x8b44f7af, 12);\n        STEP(F, c, d, a, b, SET(10), 0xffff5bb1, 17);\n        STEP(F, b, c, d, a, SET(11), 0x895cd7be, 22);\n        STEP(F, a, b, c, d, SET(12), 0x6b901122, 7);\n        STEP(F, d, a, b, c, SET(13), 0xfd987193, 12);\n        STEP(F, c, d, a, b, SET(14), 0xa679438e, 17);\n        STEP(F, b, c, d, a, SET(15), 0x49b40821, 22);\n\n        /* Round 2 */\n\n        STEP(G, a, b, c, d, GET(1),  0xf61e2562, 5);\n        STEP(G, d, a, b, c, GET(6),  0xc040b340, 9);\n        STEP(G, c, d, a, b, GET(11), 0x265e5a51, 14);\n        STEP(G, b, c, d, a, GET(0),  0xe9b6c7aa, 20);\n        STEP(G, a, b, c, d, GET(5),  0xd62f105d, 5);\n        STEP(G, d, a, b, c, GET(10), 0x02441453, 9);\n        STEP(G, c, d, a, b, GET(15), 0xd8a1e681, 14);\n        STEP(G, b, c, d, a, GET(4),  0xe7d3fbc8, 20);\n        STEP(G, a, b, c, d, GET(9),  0x21e1cde6, 5);\n        STEP(G, d, a, b, c, GET(14), 0xc33707d6, 9);\n        STEP(G, c, d, a, b, GET(3),  0xf4d50d87, 14);\n        STEP(G, b, c, d, a, GET(8),  0x455a14ed, 20);\n        STEP(G, a, b, c, d, GET(13), 0xa9e3e905, 5);\n        STEP(G, d, a, b, c, GET(2),  0xfcefa3f8, 9);\n        STEP(G, c, d, a, b, GET(7),  0x676f02d9, 14);\n        STEP(G, b, c, d, a, GET(12), 0x8d2a4c8a, 20);\n\n        /* Round 3 */\n\n        STEP(H, a, b, c, d, GET(5),  0xfffa3942, 4);\n        STEP(H, d, a, b, c, GET(8),  0x8771f681, 11);\n        STEP(H, c, d, a, b, GET(11), 0x6d9d6122, 16);\n        STEP(H, b, c, d, a, GET(14), 0xfde5380c, 23);\n        STEP(H, a, b, c, d, GET(1),  0xa4beea44, 4);\n        STEP(H, d, a, b, c, GET(4),  0x4bdecfa9, 11);\n        STEP(H, c, d, a, b, GET(7),  0xf6bb4b60, 16);\n        STEP(H, b, c, d, a, GET(10), 0xbebfbc70, 23);\n        STEP(H, a, b, c, d, GET(13), 0x289b7ec6, 4);\n        STEP(H, d, a, b, c, GET(0),  0xeaa127fa, 11);\n        STEP(H, c, d, a, b, GET(3),  0xd4ef3085, 16);\n        STEP(H, b, c, d, a, GET(6),  0x04881d05, 23);\n        STEP(H, a, b, c, d, GET(9),  0xd9d4d039, 4);\n        STEP(H, d, a, b, c, GET(12), 0xe6db99e5, 11);\n        STEP(H, c, d, a, b, GET(15), 0x1fa27cf8, 16);\n        STEP(H, b, c, d, a, GET(2),  0xc4ac5665, 23);\n\n        /* Round 4 */\n\n        STEP(I, a, b, c, d, GET(0),  0xf4292244, 6);\n        STEP(I, d, a, b, c, GET(7),  0x432aff97, 10);\n        STEP(I, c, d, a, b, GET(14), 0xab9423a7, 15);\n        STEP(I, b, c, d, a, GET(5),  0xfc93a039, 21);\n        STEP(I, a, b, c, d, GET(12), 0x655b59c3, 6);\n        STEP(I, d, a, b, c, GET(3),  0x8f0ccc92, 10);\n        STEP(I, c, d, a, b, GET(10), 0xffeff47d, 15);\n        STEP(I, b, c, d, a, GET(1),  0x85845dd1, 21);\n        STEP(I, a, b, c, d, GET(8),  0x6fa87e4f, 6);\n        STEP(I, d, a, b, c, GET(15), 0xfe2ce6e0, 10);\n        STEP(I, c, d, a, b, GET(6),  0xa3014314, 15);\n        STEP(I, b, c, d, a, GET(13), 0x4e0811a1, 21);\n        STEP(I, a, b, c, d, GET(4),  0xf7537e82, 6);\n        STEP(I, d, a, b, c, GET(11), 0xbd3af235, 10);\n        STEP(I, c, d, a, b, GET(2),  0x2ad7d2bb, 15);\n        STEP(I, b, c, d, a, GET(9),  0xeb86d391, 21);\n\n        a += saved_a;\n        b += saved_b;\n        c += saved_c;\n        d += saved_d;\n\n        p += 64;\n\n    } while (size -= 64);\n\n    ctx->a = a;\n    ctx->b = b;\n    ctx->c = c;\n    ctx->d = d;\n\n    return p;\n}", "path": "nginx/src/core/ngx_md5.c", "commit_date": "2016-06-30 00:00:00", "repo_name": "nginx/nginx", "stars": 19954, "license": "None", "language": "c", "size": 73356}
{"docstring": "/*\n * to keep cache locality for left leaf nodes, allocate nodes in following\n * order: node, left subtree, right subtree, inclusive subtree\n */\n", "func_signal": "static ngx_http_location_tree_node_t *\nngx_http_create_locations_tree(ngx_conf_t *cf, ngx_queue_t *locations,\n    size_t prefix)", "code": "{\n    size_t                          len;\n    ngx_queue_t                    *q, tail;\n    ngx_http_location_queue_t      *lq;\n    ngx_http_location_tree_node_t  *node;\n\n    q = ngx_queue_middle(locations);\n\n    lq = (ngx_http_location_queue_t *) q;\n    len = lq->name->len - prefix;\n\n    node = ngx_palloc(cf->pool,\n                      offsetof(ngx_http_location_tree_node_t, name) + len);\n    if (node == NULL) {\n        return NULL;\n    }\n\n    node->left = NULL;\n    node->right = NULL;\n    node->tree = NULL;\n    node->exact = lq->exact;\n    node->inclusive = lq->inclusive;\n\n    node->auto_redirect = (u_char) ((lq->exact && lq->exact->auto_redirect)\n                           || (lq->inclusive && lq->inclusive->auto_redirect));\n\n    node->len = (u_char) len;\n    ngx_memcpy(node->name, &lq->name->data[prefix], len);\n\n    ngx_queue_split(locations, q, &tail);\n\n    if (ngx_queue_empty(locations)) {\n        /*\n         * ngx_queue_split() insures that if left part is empty,\n         * then right one is empty too\n         */\n        goto inclusive;\n    }\n\n    node->left = ngx_http_create_locations_tree(cf, locations, prefix);\n    if (node->left == NULL) {\n        return NULL;\n    }\n\n    ngx_queue_remove(q);\n\n    if (ngx_queue_empty(&tail)) {\n        goto inclusive;\n    }\n\n    node->right = ngx_http_create_locations_tree(cf, &tail, prefix);\n    if (node->right == NULL) {\n        return NULL;\n    }\n\ninclusive:\n\n    if (ngx_queue_empty(&lq->list)) {\n        return node;\n    }\n\n    node->tree = ngx_http_create_locations_tree(cf, &lq->list, prefix + len);\n    if (node->tree == NULL) {\n        return NULL;\n    }\n\n    return node;\n}", "path": "nginx/src/http/ngx_http.c", "commit_date": "2020-07-21 00:00:00", "repo_name": "nginx/nginx", "stars": 19954, "license": "None", "language": "c", "size": 73356}
{"docstring": "/* add the server core module configuration to the address:port */\n", "func_signal": "static ngx_int_t\nngx_http_add_server(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,\n    ngx_http_conf_addr_t *addr)", "code": "{\n    ngx_uint_t                  i;\n    ngx_http_core_srv_conf_t  **server;\n\n    if (addr->servers.elts == NULL) {\n        if (ngx_array_init(&addr->servers, cf->temp_pool, 4,\n                           sizeof(ngx_http_core_srv_conf_t *))\n            != NGX_OK)\n        {\n            return NGX_ERROR;\n        }\n\n    } else {\n        server = addr->servers.elts;\n        for (i = 0; i < addr->servers.nelts; i++) {\n            if (server[i] == cscf) {\n                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                   \"a duplicate listen %V\",\n                                   &addr->opt.addr_text);\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    server = ngx_array_push(&addr->servers);\n    if (server == NULL) {\n        return NGX_ERROR;\n    }\n\n    *server = cscf;\n\n    return NGX_OK;\n}", "path": "nginx/src/http/ngx_http.c", "commit_date": "2020-07-21 00:00:00", "repo_name": "nginx/nginx", "stars": 19954, "license": "None", "language": "c", "size": 73356}
{"docstring": "/*\n * MacOSX thread has two thread ids:\n *\n * 1) MacOSX 10.6 (Snow Leoprad) has pthread_threadid_np() returning\n *    an uint64_t value, which is obtained using the __thread_selfid()\n *    syscall.  It is a number above 300,000.\n */\n", "func_signal": "ngx_tid_t\nngx_thread_tid(void)", "code": "{\n    uint64_t  tid;\n\n    (void) pthread_threadid_np(NULL, &tid);\n    return tid;\n}", "path": "nginx/src/os/unix/ngx_thread_id.c", "commit_date": "2015-03-14 00:00:00", "repo_name": "nginx/nginx", "stars": 19954, "license": "None", "language": "c", "size": 73356}
{"docstring": "/* auto detect the L2 cache line size of modern and widespread CPUs */\n", "func_signal": "void\nngx_cpuinfo(void)", "code": "{\n    u_char    *vendor;\n    uint32_t   vbuf[5], cpu[4], model;\n\n    vbuf[0] = 0;\n    vbuf[1] = 0;\n    vbuf[2] = 0;\n    vbuf[3] = 0;\n    vbuf[4] = 0;\n\n    ngx_cpuid(0, vbuf);\n\n    vendor = (u_char *) &vbuf[1];\n\n    if (vbuf[0] == 0) {\n        return;\n    }\n\n    ngx_cpuid(1, cpu);\n\n    if (ngx_strcmp(vendor, \"GenuineIntel\") == 0) {\n\n        switch ((cpu[0] & 0xf00) >> 8) {\n\n        /* Pentium */\n        case 5:\n            ngx_cacheline_size = 32;\n            break;\n\n        /* Pentium Pro, II, III */\n        case 6:\n            ngx_cacheline_size = 32;\n\n            model = ((cpu[0] & 0xf0000) >> 8) | (cpu[0] & 0xf0);\n\n            if (model >= 0xd0) {\n                /* Intel Core, Core 2, Atom */\n                ngx_cacheline_size = 64;\n            }\n\n            break;\n\n        /*\n         * Pentium 4, although its cache line size is 64 bytes,\n         * it prefetches up to two cache lines during memory read\n         */\n        case 15:\n            ngx_cacheline_size = 128;\n            break;\n        }\n\n    } else if (ngx_strcmp(vendor, \"AuthenticAMD\") == 0) {\n        ngx_cacheline_size = 64;\n    }\n}", "path": "nginx/src/core/ngx_cpuinfo.c", "commit_date": "2012-01-18 00:00:00", "repo_name": "nginx/nginx", "stars": 19954, "license": "None", "language": "c", "size": 73356}
{"docstring": "// Notifies shared code that a window has moved\n// The position is specified in content area relative screen coordinates\n//\n", "func_signal": "void _glfwInputWindowPos(_GLFWwindow* window, int x, int y)", "code": "{\n    if (window->callbacks.pos)\n        window->callbacks.pos((GLFWwindow*) window, x, y);\n}", "path": "glfw/src/window.c", "commit_date": "2020-08-23 00:00:00", "repo_name": "glfw/glfw", "stars": 12017, "license": "zlib", "language": "c", "size": 16575}
{"docstring": "/*****************************************************************************\n * Draw the purple grid of lines, behind the Boing ball.\n * When the Workbench is dropped to the bottom, Boing shows 12 rows.\n *****************************************************************************/\n", "func_signal": "void DrawGrid( void )", "code": "{\n   int              row, col;\n   const int        rowTotal    = 12;                   /* must be divisible by 2 */\n   const int        colTotal    = rowTotal;             /* must be same as rowTotal */\n   const GLfloat    widthLine   = 2.0;                  /* should be divisible by 2 */\n   const GLfloat    sizeCell    = GRID_SIZE / rowTotal;\n   const GLfloat    z_offset    = -40.0;\n   GLfloat          xl, xr;\n   GLfloat          yt, yb;\n\n   glPushMatrix();\n   glDisable( GL_CULL_FACE );\n\n  /*\n   * Another relative Z translation to separate objects.\n   */\n   glTranslatef( 0.0, 0.0, DIST_BALL );\n\n  /*\n   * Draw vertical lines (as skinny 3D rectangles).\n   */\n   for ( col = 0; col <= colTotal; col++ )\n   {\n     /*\n      * Compute co-ords of line.\n      */\n      xl = -GRID_SIZE / 2 + col * sizeCell;\n      xr = xl + widthLine;\n\n      yt =  GRID_SIZE / 2;\n      yb = -GRID_SIZE / 2 - widthLine;\n\n      glBegin( GL_POLYGON );\n\n      glColor3f( 0.6f, 0.1f, 0.6f );               /* purple */\n\n      glVertex3f( xr, yt, z_offset );       /* NE */\n      glVertex3f( xl, yt, z_offset );       /* NW */\n      glVertex3f( xl, yb, z_offset );       /* SW */\n      glVertex3f( xr, yb, z_offset );       /* SE */\n\n      glEnd();\n   }\n\n  /*\n   * Draw horizontal lines (as skinny 3D rectangles).\n   */\n   for ( row = 0; row <= rowTotal; row++ )\n   {\n     /*\n      * Compute co-ords of line.\n      */\n      yt = GRID_SIZE / 2 - row * sizeCell;\n      yb = yt - widthLine;\n\n      xl = -GRID_SIZE / 2;\n      xr =  GRID_SIZE / 2 + widthLine;\n\n      glBegin( GL_POLYGON );\n\n      glColor3f( 0.6f, 0.1f, 0.6f );               /* purple */\n\n      glVertex3f( xr, yt, z_offset );       /* NE */\n      glVertex3f( xl, yt, z_offset );       /* NW */\n      glVertex3f( xl, yb, z_offset );       /* SW */\n      glVertex3f( xr, yb, z_offset );       /* SE */\n\n      glEnd();\n   }\n\n   glPopMatrix();\n\n   return;\n}", "path": "glfw/examples/boing.c", "commit_date": "2019-05-24 00:00:00", "repo_name": "glfw/glfw", "stars": 12017, "license": "zlib", "language": "c", "size": 16575}
{"docstring": "// Notifies shared code that a window has been iconified or restored\n//\n", "func_signal": "void _glfwInputWindowIconify(_GLFWwindow* window, GLFWbool iconified)", "code": "{\n    if (window->callbacks.iconify)\n        window->callbacks.iconify((GLFWwindow*) window, iconified);\n}", "path": "glfw/src/window.c", "commit_date": "2020-08-23 00:00:00", "repo_name": "glfw/glfw", "stars": 12017, "license": "zlib", "language": "c", "size": 16575}
{"docstring": "/*****************************************************************************\n * Compute a cross product (for a normal vector).\n *\n * c = a x b\n *****************************************************************************/\n", "func_signal": "void CrossProduct( vertex_t a, vertex_t b, vertex_t c, vertex_t *n )", "code": "{\n   GLfloat u1, u2, u3;\n   GLfloat v1, v2, v3;\n\n   u1 = b.x - a.x;\n   u2 = b.y - a.y;\n   u3 = b.y - a.z;\n\n   v1 = c.x - a.x;\n   v2 = c.y - a.y;\n   v3 = c.z - a.z;\n\n   n->x = u2 * v3 - v2 * u3;\n   n->y = u3 * v1 - v3 * u1;\n   n->z = u1 * v2 - v1 * u2;\n}", "path": "glfw/examples/boing.c", "commit_date": "2019-05-24 00:00:00", "repo_name": "glfw/glfw", "stars": 12017, "license": "zlib", "language": "c", "size": 16575}
{"docstring": "// Notifies shared code that a window has been resized\n// The size is specified in screen coordinates\n//\n", "func_signal": "void _glfwInputWindowSize(_GLFWwindow* window, int width, int height)", "code": "{\n    if (window->callbacks.size)\n        window->callbacks.size((GLFWwindow*) window, width, height);\n}", "path": "glfw/src/window.c", "commit_date": "2020-08-23 00:00:00", "repo_name": "glfw/glfw", "stars": 12017, "license": "zlib", "language": "c", "size": 16575}
{"docstring": "/*****************************************************************************\n * display()\n *****************************************************************************/\n", "func_signal": "void display(void)", "code": "{\n   glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );\n   glPushMatrix();\n\n   drawBallHow = DRAW_BALL_SHADOW;\n   DrawBoingBall();\n\n   DrawGrid();\n\n   drawBallHow = DRAW_BALL;\n   DrawBoingBall();\n\n   glPopMatrix();\n   glFlush();\n}", "path": "glfw/examples/boing.c", "commit_date": "2019-05-24 00:00:00", "repo_name": "glfw/glfw", "stars": 12017, "license": "zlib", "language": "c", "size": 16575}
{"docstring": "/*======================================================================*\n * main()\n *======================================================================*/\n", "func_signal": "int main( void )", "code": "{\n   GLFWwindow* window;\n\n   /* Init GLFW */\n   if( !glfwInit() )\n      exit( EXIT_FAILURE );\n\n   window = glfwCreateWindow( 400, 400, \"Boing (classic Amiga demo)\", NULL, NULL );\n   if (!window)\n   {\n       glfwTerminate();\n       exit( EXIT_FAILURE );\n   }\n\n   glfwSetWindowAspectRatio(window, 1, 1);\n\n   glfwSetFramebufferSizeCallback(window, reshape);\n   glfwSetKeyCallback(window, key_callback);\n   glfwSetMouseButtonCallback(window, mouse_button_callback);\n   glfwSetCursorPosCallback(window, cursor_position_callback);\n\n   glfwMakeContextCurrent(window);\n   gladLoadGL(glfwGetProcAddress);\n   glfwSwapInterval( 1 );\n\n   glfwGetFramebufferSize(window, &width, &height);\n   reshape(window, width, height);\n\n   glfwSetTime( 0.0 );\n\n   init();\n\n   /* Main loop */\n   for (;;)\n   {\n       /* Timing */\n       t = glfwGetTime();\n       dt = t - t_old;\n       t_old = t;\n\n       /* Draw one frame */\n       display();\n\n       /* Swap buffers */\n       glfwSwapBuffers(window);\n       glfwPollEvents();\n\n       /* Check if we are still running */\n       if (glfwWindowShouldClose(window))\n           break;\n   }\n\n   glfwTerminate();\n   exit( EXIT_SUCCESS );\n}", "path": "glfw/examples/boing.c", "commit_date": "2019-05-24 00:00:00", "repo_name": "glfw/glfw", "stars": 12017, "license": "zlib", "language": "c", "size": 16575}
{"docstring": "/*****************************************************************************\n * Bounce the ball.\n *****************************************************************************/\n", "func_signal": "void BounceBall( double delta_t )", "code": "{\n   GLfloat sign;\n   GLfloat deg;\n\n   if ( override_pos )\n     return;\n\n   /* Bounce on walls */\n   if ( ball_x >  (BOUNCE_WIDTH/2 + WALL_R_OFFSET ) )\n   {\n      ball_x_inc = -0.5f - 0.75f * (GLfloat)rand() / (GLfloat)RAND_MAX;\n      deg_rot_y_inc = -deg_rot_y_inc;\n   }\n   if ( ball_x < -(BOUNCE_HEIGHT/2 + WALL_L_OFFSET) )\n   {\n      ball_x_inc =  0.5f + 0.75f * (GLfloat)rand() / (GLfloat)RAND_MAX;\n      deg_rot_y_inc = -deg_rot_y_inc;\n   }\n\n   /* Bounce on floor / roof */\n   if ( ball_y >  BOUNCE_HEIGHT/2      )\n   {\n      ball_y_inc = -0.75f - 1.f * (GLfloat)rand() / (GLfloat)RAND_MAX;\n   }\n   if ( ball_y < -BOUNCE_HEIGHT/2*0.85 )\n   {\n      ball_y_inc =  0.75f + 1.f * (GLfloat)rand() / (GLfloat)RAND_MAX;\n   }\n\n   /* Update ball position */\n   ball_x += ball_x_inc * ((float)delta_t*ANIMATION_SPEED);\n   ball_y += ball_y_inc * ((float)delta_t*ANIMATION_SPEED);\n\n  /*\n   * Simulate the effects of gravity on Y movement.\n   */\n   if ( ball_y_inc < 0 ) sign = -1.0; else sign = 1.0;\n\n   deg = (ball_y + BOUNCE_HEIGHT/2) * 90 / BOUNCE_HEIGHT;\n   if ( deg > 80 ) deg = 80;\n   if ( deg < 10 ) deg = 10;\n\n   ball_y_inc = sign * 4.f * (float) sin_deg( deg );\n}", "path": "glfw/examples/boing.c", "commit_date": "2019-05-24 00:00:00", "repo_name": "glfw/glfw", "stars": 12017, "license": "zlib", "language": "c", "size": 16575}
{"docstring": "// Notifies shared code that the window contents needs updating\n//\n", "func_signal": "void _glfwInputWindowDamage(_GLFWwindow* window)", "code": "{\n    if (window->callbacks.refresh)\n        window->callbacks.refresh((GLFWwindow*) window);\n}", "path": "glfw/src/window.c", "commit_date": "2020-08-23 00:00:00", "repo_name": "glfw/glfw", "stars": 12017, "license": "zlib", "language": "c", "size": 16575}
{"docstring": "/*****************************************************************************\n * reshape()\n *****************************************************************************/\n", "func_signal": "void reshape( GLFWwindow* window, int w, int h )", "code": "{\n   mat4x4 projection, view;\n\n   glViewport( 0, 0, (GLsizei)w, (GLsizei)h );\n\n   glMatrixMode( GL_PROJECTION );\n   mat4x4_perspective( projection,\n                       2.f * (float) atan2( RADIUS, 200.f ),\n                       (float)w / (float)h,\n                       1.f, VIEW_SCENE_DIST );\n   glLoadMatrixf((const GLfloat*) projection);\n\n   glMatrixMode( GL_MODELVIEW );\n   {\n      vec3 eye = { 0.f, 0.f, VIEW_SCENE_DIST };\n      vec3 center = { 0.f, 0.f, 0.f };\n      vec3 up = { 0.f, -1.f, 0.f };\n      mat4x4_look_at( view, eye, center, up );\n   }\n   glLoadMatrixf((const GLfloat*) view);\n}", "path": "glfw/examples/boing.c", "commit_date": "2019-05-24 00:00:00", "repo_name": "glfw/glfw", "stars": 12017, "license": "zlib", "language": "c", "size": 16575}
{"docstring": "/*****************************************************************************\n * Draw the Boing ball.\n *\n * The Boing ball is sphere in which each facet is a rectangle.\n * Facet colors alternate between red and white.\n * The ball is built by stacking latitudinal circles.  Each circle is composed\n * of a widely-separated set of points, so that each facet is noticeably large.\n *****************************************************************************/\n", "func_signal": "void DrawBoingBall( void )", "code": "{\n   GLfloat lon_deg;     /* degree of longitude */\n   double dt_total, dt2;\n\n   glPushMatrix();\n   glMatrixMode( GL_MODELVIEW );\n\n  /*\n   * Another relative Z translation to separate objects.\n   */\n   glTranslatef( 0.0, 0.0, DIST_BALL );\n\n   /* Update ball position and rotation (iterate if necessary) */\n   dt_total = dt;\n   while( dt_total > 0.0 )\n   {\n       dt2 = dt_total > MAX_DELTA_T ? MAX_DELTA_T : dt_total;\n       dt_total -= dt2;\n       BounceBall( dt2 );\n       deg_rot_y = TruncateDeg( deg_rot_y + deg_rot_y_inc*((float)dt2*ANIMATION_SPEED) );\n   }\n\n   /* Set ball position */\n   glTranslatef( ball_x, ball_y, 0.0 );\n\n  /*\n   * Offset the shadow.\n   */\n   if ( drawBallHow == DRAW_BALL_SHADOW )\n   {\n      glTranslatef( SHADOW_OFFSET_X,\n                    SHADOW_OFFSET_Y,\n                    SHADOW_OFFSET_Z );\n   }\n\n  /*\n   * Tilt the ball.\n   */\n   glRotatef( -20.0, 0.0, 0.0, 1.0 );\n\n  /*\n   * Continually rotate ball around Y axis.\n   */\n   glRotatef( deg_rot_y, 0.0, 1.0, 0.0 );\n\n  /*\n   * Set OpenGL state for Boing ball.\n   */\n   glCullFace( GL_FRONT );\n   glEnable( GL_CULL_FACE );\n   glEnable( GL_NORMALIZE );\n\n  /*\n   * Build a faceted latitude slice of the Boing ball,\n   * stepping same-sized vertical bands of the sphere.\n   */\n   for ( lon_deg = 0;\n         lon_deg < 180;\n         lon_deg += STEP_LONGITUDE )\n   {\n     /*\n      * Draw a latitude circle at this longitude.\n      */\n      DrawBoingBallBand( lon_deg,\n                         lon_deg + STEP_LONGITUDE );\n   }\n\n   glPopMatrix();\n\n   return;\n}", "path": "glfw/examples/boing.c", "commit_date": "2019-05-24 00:00:00", "repo_name": "glfw/glfw", "stars": 12017, "license": "zlib", "language": "c", "size": 16575}
{"docstring": "// Notifies shared code that the user wishes to close a window\n//\n", "func_signal": "void _glfwInputWindowCloseRequest(_GLFWwindow* window)", "code": "{\n    window->shouldClose = GLFW_TRUE;\n\n    if (window->callbacks.close)\n        window->callbacks.close((GLFWwindow*) window);\n}", "path": "glfw/src/window.c", "commit_date": "2020-08-23 00:00:00", "repo_name": "glfw/glfw", "stars": 12017, "license": "zlib", "language": "c", "size": 16575}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n//////                        GLFW native API                       //////\n//////////////////////////////////////////////////////////////////////////\n", "func_signal": "GLFWAPI int glfwGetOSMesaColorBuffer(GLFWwindow* handle, int* width,\n                                     int* height, int* format, void** buffer)", "code": "{\n    void* mesaBuffer;\n    GLint mesaWidth, mesaHeight, mesaFormat;\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    assert(window != NULL);\n\n    _GLFW_REQUIRE_INIT_OR_RETURN(GLFW_FALSE);\n\n    if (!OSMesaGetColorBuffer(window->context.osmesa.handle,\n                              &mesaWidth, &mesaHeight,\n                              &mesaFormat, &mesaBuffer))\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"OSMesa: Failed to retrieve color buffer\");\n        return GLFW_FALSE;\n    }\n\n    if (width)\n        *width = mesaWidth;\n    if (height)\n        *height = mesaHeight;\n    if (format)\n        *format = mesaFormat;\n    if (buffer)\n        *buffer = mesaBuffer;\n\n    return GLFW_TRUE;\n}", "path": "glfw/src/osmesa_context.c", "commit_date": "2019-05-24 00:00:00", "repo_name": "glfw/glfw", "stars": 12017, "license": "zlib", "language": "c", "size": 16575}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n", "func_signal": "GLFWbool _glfwInitOSMesa(void)", "code": "{\n    int i;\n    const char* sonames[] =\n    {\n#if defined(_GLFW_OSMESA_LIBRARY)\n        _GLFW_OSMESA_LIBRARY,\n#elif defined(_WIN32)\n        \"libOSMesa.dll\",\n        \"OSMesa.dll\",\n#elif defined(__APPLE__)\n        \"libOSMesa.8.dylib\",\n#elif defined(__CYGWIN__)\n        \"libOSMesa-8.so\",\n#else\n        \"libOSMesa.so.8\",\n        \"libOSMesa.so.6\",\n#endif\n        NULL\n    };\n\n    if (_glfw.osmesa.handle)\n        return GLFW_TRUE;\n\n    for (i = 0;  sonames[i];  i++)\n    {\n        _glfw.osmesa.handle = _glfw_dlopen(sonames[i]);\n        if (_glfw.osmesa.handle)\n            break;\n    }\n\n    if (!_glfw.osmesa.handle)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"OSMesa: Library not found\");\n        return GLFW_FALSE;\n    }\n\n    _glfw.osmesa.CreateContextExt = (PFN_OSMesaCreateContextExt)\n        _glfw_dlsym(_glfw.osmesa.handle, \"OSMesaCreateContextExt\");\n    _glfw.osmesa.CreateContextAttribs = (PFN_OSMesaCreateContextAttribs)\n        _glfw_dlsym(_glfw.osmesa.handle, \"OSMesaCreateContextAttribs\");\n    _glfw.osmesa.DestroyContext = (PFN_OSMesaDestroyContext)\n        _glfw_dlsym(_glfw.osmesa.handle, \"OSMesaDestroyContext\");\n    _glfw.osmesa.MakeCurrent = (PFN_OSMesaMakeCurrent)\n        _glfw_dlsym(_glfw.osmesa.handle, \"OSMesaMakeCurrent\");\n    _glfw.osmesa.GetColorBuffer = (PFN_OSMesaGetColorBuffer)\n        _glfw_dlsym(_glfw.osmesa.handle, \"OSMesaGetColorBuffer\");\n    _glfw.osmesa.GetDepthBuffer = (PFN_OSMesaGetDepthBuffer)\n        _glfw_dlsym(_glfw.osmesa.handle, \"OSMesaGetDepthBuffer\");\n    _glfw.osmesa.GetProcAddress = (PFN_OSMesaGetProcAddress)\n        _glfw_dlsym(_glfw.osmesa.handle, \"OSMesaGetProcAddress\");\n\n    if (!_glfw.osmesa.CreateContextExt ||\n        !_glfw.osmesa.DestroyContext ||\n        !_glfw.osmesa.MakeCurrent ||\n        !_glfw.osmesa.GetColorBuffer ||\n        !_glfw.osmesa.GetDepthBuffer ||\n        !_glfw.osmesa.GetProcAddress)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"OSMesa: Failed to load required entry points\");\n\n        _glfwTerminateOSMesa();\n        return GLFW_FALSE;\n    }\n\n    return GLFW_TRUE;\n}", "path": "glfw/src/osmesa_context.c", "commit_date": "2019-05-24 00:00:00", "repo_name": "glfw/glfw", "stars": 12017, "license": "zlib", "language": "c", "size": 16575}
{"docstring": "// Notifies shared code that a window framebuffer has been resized\n// The size is specified in pixels\n//\n", "func_signal": "void _glfwInputFramebufferSize(_GLFWwindow* window, int width, int height)", "code": "{\n    if (window->callbacks.fbsize)\n        window->callbacks.fbsize((GLFWwindow*) window, width, height);\n}", "path": "glfw/src/window.c", "commit_date": "2020-08-23 00:00:00", "repo_name": "glfw/glfw", "stars": 12017, "license": "zlib", "language": "c", "size": 16575}
{"docstring": "/*****************************************************************************\n * Draw a faceted latitude band of the Boing ball.\n *\n * Parms:   long_lo, long_hi\n *          Low and high longitudes of slice, resp.\n *****************************************************************************/\n", "func_signal": "void DrawBoingBallBand( GLfloat long_lo,\n                        GLfloat long_hi )", "code": "{\n   vertex_t vert_ne;            /* \"ne\" means south-east, so on */\n   vertex_t vert_nw;\n   vertex_t vert_sw;\n   vertex_t vert_se;\n   vertex_t vert_norm;\n   GLfloat  lat_deg;\n   static int colorToggle = 0;\n\n  /*\n   * Iterate through the points of a latitude circle.\n   * A latitude circle is a 2D set of X,Z points.\n   */\n   for ( lat_deg = 0;\n         lat_deg <= (360 - STEP_LATITUDE);\n         lat_deg += STEP_LATITUDE )\n   {\n     /*\n      * Color this polygon with red or white.\n      */\n      if ( colorToggle )\n         glColor3f( 0.8f, 0.1f, 0.1f );\n      else\n         glColor3f( 0.95f, 0.95f, 0.95f );\n#if 0\n      if ( lat_deg >= 180 )\n         if ( colorToggle )\n            glColor3f( 0.1f, 0.8f, 0.1f );\n         else\n            glColor3f( 0.5f, 0.5f, 0.95f );\n#endif\n      colorToggle = ! colorToggle;\n\n     /*\n      * Change color if drawing shadow.\n      */\n      if ( drawBallHow == DRAW_BALL_SHADOW )\n         glColor3f( 0.35f, 0.35f, 0.35f );\n\n     /*\n      * Assign each Y.\n      */\n      vert_ne.y = vert_nw.y = (float) cos_deg(long_hi) * RADIUS;\n      vert_sw.y = vert_se.y = (float) cos_deg(long_lo) * RADIUS;\n\n     /*\n      * Assign each X,Z with sin,cos values scaled by latitude radius indexed by longitude.\n      * Eg, long=0 and long=180 are at the poles, so zero scale is sin(longitude),\n      * while long=90 (sin(90)=1) is at equator.\n      */\n      vert_ne.x = (float) cos_deg( lat_deg                 ) * (RADIUS * (float) sin_deg( long_lo + STEP_LONGITUDE ));\n      vert_se.x = (float) cos_deg( lat_deg                 ) * (RADIUS * (float) sin_deg( long_lo                  ));\n      vert_nw.x = (float) cos_deg( lat_deg + STEP_LATITUDE ) * (RADIUS * (float) sin_deg( long_lo + STEP_LONGITUDE ));\n      vert_sw.x = (float) cos_deg( lat_deg + STEP_LATITUDE ) * (RADIUS * (float) sin_deg( long_lo                  ));\n\n      vert_ne.z = (float) sin_deg( lat_deg                 ) * (RADIUS * (float) sin_deg( long_lo + STEP_LONGITUDE ));\n      vert_se.z = (float) sin_deg( lat_deg                 ) * (RADIUS * (float) sin_deg( long_lo                  ));\n      vert_nw.z = (float) sin_deg( lat_deg + STEP_LATITUDE ) * (RADIUS * (float) sin_deg( long_lo + STEP_LONGITUDE ));\n      vert_sw.z = (float) sin_deg( lat_deg + STEP_LATITUDE ) * (RADIUS * (float) sin_deg( long_lo                  ));\n\n     /*\n      * Draw the facet.\n      */\n      glBegin( GL_POLYGON );\n\n      CrossProduct( vert_ne, vert_nw, vert_sw, &vert_norm );\n      glNormal3f( vert_norm.x, vert_norm.y, vert_norm.z );\n\n      glVertex3f( vert_ne.x, vert_ne.y, vert_ne.z );\n      glVertex3f( vert_nw.x, vert_nw.y, vert_nw.z );\n      glVertex3f( vert_sw.x, vert_sw.y, vert_sw.z );\n      glVertex3f( vert_se.x, vert_se.y, vert_se.z );\n\n      glEnd();\n\n#if BOING_DEBUG\n      printf( \"----------------------------------------------------------- \\n\" );\n      printf( \"lat = %f  long_lo = %f  long_hi = %f \\n\", lat_deg, long_lo, long_hi );\n      printf( \"vert_ne  x = %.8f  y = %.8f  z = %.8f \\n\", vert_ne.x, vert_ne.y, vert_ne.z );\n      printf( \"vert_nw  x = %.8f  y = %.8f  z = %.8f \\n\", vert_nw.x, vert_nw.y, vert_nw.z );\n      printf( \"vert_se  x = %.8f  y = %.8f  z = %.8f \\n\", vert_se.x, vert_se.y, vert_se.z );\n      printf( \"vert_sw  x = %.8f  y = %.8f  z = %.8f \\n\", vert_sw.x, vert_sw.y, vert_sw.z );\n#endif\n\n   }\n\n  /*\n   * Toggle color so that next band will opposite red/white colors than this one.\n   */\n   colorToggle = ! colorToggle;\n\n  /*\n   * This circular band is done.\n   */\n   return;\n}", "path": "glfw/examples/boing.c", "commit_date": "2019-05-24 00:00:00", "repo_name": "glfw/glfw", "stars": 12017, "license": "zlib", "language": "c", "size": 16575}
{"docstring": "/*****************************************************************************\n * init()\n *****************************************************************************/\n", "func_signal": "void init( void )", "code": "{\n   /*\n    * Clear background.\n    */\n   glClearColor( 0.55f, 0.55f, 0.55f, 0.f );\n\n   glShadeModel( GL_FLAT );\n}", "path": "glfw/examples/boing.c", "commit_date": "2019-05-24 00:00:00", "repo_name": "glfw/glfw", "stars": 12017, "license": "zlib", "language": "c", "size": 16575}
{"docstring": "// Notifies shared code that a window content scale has changed\n// The scale is specified as the ratio between the current and default DPI\n//\n", "func_signal": "void _glfwInputWindowContentScale(_GLFWwindow* window, float xscale, float yscale)", "code": "{\n    if (window->callbacks.scale)\n        window->callbacks.scale((GLFWwindow*) window, xscale, yscale);\n}", "path": "glfw/src/window.c", "commit_date": "2020-08-23 00:00:00", "repo_name": "glfw/glfw", "stars": 12017, "license": "zlib", "language": "c", "size": 16575}
{"docstring": "// Notifies shared code that a window has been maximized or restored\n//\n", "func_signal": "void _glfwInputWindowMaximize(_GLFWwindow* window, GLFWbool maximized)", "code": "{\n    if (window->callbacks.maximize)\n        window->callbacks.maximize((GLFWwindow*) window, maximized);\n}", "path": "glfw/src/window.c", "commit_date": "2020-08-23 00:00:00", "repo_name": "glfw/glfw", "stars": 12017, "license": "zlib", "language": "c", "size": 16575}
{"docstring": "// Notifies shared code that a window has lost or received input focus\n//\n", "func_signal": "void _glfwInputWindowFocus(_GLFWwindow* window, GLFWbool focused)", "code": "{\n    if (window->callbacks.focus)\n        window->callbacks.focus((GLFWwindow*) window, focused);\n\n    if (!focused)\n    {\n        int key, button;\n\n        for (key = 0;  key <= GLFW_KEY_LAST;  key++)\n        {\n            if (window->keys[key] == GLFW_PRESS)\n            {\n                const int scancode = _glfwPlatformGetKeyScancode(key);\n                _glfwInputKey(window, key, scancode, GLFW_RELEASE, 0);\n            }\n        }\n\n        for (button = 0;  button <= GLFW_MOUSE_BUTTON_LAST;  button++)\n        {\n            if (window->mouseButtons[button] == GLFW_PRESS)\n                _glfwInputMouseClick(window, button, GLFW_RELEASE, 0);\n        }\n    }\n}", "path": "glfw/src/window.c", "commit_date": "2020-08-23 00:00:00", "repo_name": "glfw/glfw", "stars": 12017, "license": "zlib", "language": "c", "size": 16575}
{"docstring": "/* Accumulate data from events sharing the same ID */\n", "func_signal": "Eventinfo *Accumulate(Eventinfo *lf, OSHash **acm_store, int *acm_lookups, time_t *acm_purge_ts)", "code": "{\n    int result;\n    int do_update = 0;\n\n    char _key[OS_ACM_MAXKEY];\n    OS_ACM_Store *stored_data = 0;\n\n    time_t  current_ts;\n    struct timeval tp;\n\n    if (lf == NULL) {\n        mdebug1(\"accumulator: DEBUG: Received NULL EventInfo\");\n        return lf;\n    }\n    if (lf->id == NULL) {\n        mdebug2(\"accumulator: DEBUG: No id available\");\n        return lf;\n    }\n    if (lf->decoder_info == NULL) {\n        mdebug1(\"accumulator: DEBUG: No decoder_info available\");\n        return lf;\n    }\n    if (lf->decoder_info->name == NULL) {\n        mdebug1(\"accumulator: DEBUG: No decoder name available\");\n        return lf;\n    }\n\n    /* Purge the cache as needed */\n    Accumulate_CleanUp(acm_store, acm_lookups, acm_purge_ts);\n\n    gettimeofday(&tp, NULL);\n    current_ts = tp.tv_sec;\n\n    /* Accumulator Key */\n    result = snprintf(_key, OS_FLSIZE, \"%s %s %s\",\n                      lf->hostname,\n                      lf->decoder_info->name,\n                      lf->id\n                     );\n    if ( result < 0 || (unsigned) result >= sizeof(_key) ) {\n        mdebug1(\"accumulator: DEBUG: error setting accumulator key, id:%s,name:%s\", lf->id, lf->decoder_info->name);\n        return lf;\n    }\n\n    /* Check if acm is already present */\n    if ((stored_data = (OS_ACM_Store *)OSHash_Get_ex(*acm_store, _key)) != NULL) {\n        mdebug2(\"accumulator: DEBUG: Lookup for '%s' found a stored value!\", _key);\n\n        if ( stored_data->timestamp > 0 && stored_data->timestamp < current_ts - OS_ACM_EXPIRE_ELM ) {\n            if (OSHash_Delete_ex(*acm_store, _key) != NULL) {\n                mdebug1(\"accumulator: DEBUG: Deleted expired hash entry for '%s'\", _key);\n                /* Clear this memory */\n                FreeACMStore(stored_data);\n                /* Reallocate what we need */\n                stored_data = InitACMStore();\n            }\n        } else {\n            /* Update the event */\n            do_update = 1;\n            if (acm_str_replace(&lf->dstuser, stored_data->dstuser) == 0) {\n                mdebug2(\"accumulator: DEBUG: (%s) updated lf->dstuser to %s\", _key, lf->dstuser);\n            }\n\n            if (acm_str_replace(&lf->srcuser, stored_data->srcuser) == 0) {\n                mdebug2(\"accumulator: DEBUG: (%s) updated lf->srcuser to %s\", _key, lf->srcuser);\n            }\n\n            if (acm_str_replace(&lf->dstip, stored_data->dstip) == 0) {\n                mdebug2(\"accumulator: DEBUG: (%s) updated lf->dstip to %s\", _key, lf->dstip);\n            }\n\n            if (acm_str_replace(&lf->srcip, stored_data->srcip) == 0) {\n                mdebug2(\"accumulator: DEBUG: (%s) updated lf->srcip to %s\", _key, lf->srcip);\n            }\n\n            if (acm_str_replace(&lf->dstport, stored_data->dstport) == 0) {\n                mdebug2(\"accumulator: DEBUG: (%s) updated lf->dstport to %s\", _key, lf->dstport);\n            }\n\n            if (acm_str_replace(&lf->srcport, stored_data->srcport) == 0) {\n                mdebug2(\"accumulator: DEBUG: (%s) updated lf->srcport to %s\", _key, lf->srcport);\n            }\n\n            if (acm_str_replace(&lf->data, stored_data->data) == 0) {\n                mdebug2(\"accumulator: DEBUG: (%s) updated lf->data to %s\", _key, lf->data);\n            }\n        }\n    } else {\n        stored_data = InitACMStore();\n    }\n\n    /* Store the object in the cache */\n    stored_data->timestamp = current_ts;\n    if (acm_str_replace(&stored_data->dstuser, lf->dstuser) == 0) {\n        mdebug2(\"accumulator: DEBUG: (%s) updated stored_data->dstuser to %s\", _key, stored_data->dstuser);\n    }\n\n    if (acm_str_replace(&stored_data->srcuser, lf->srcuser) == 0) {\n        mdebug2(\"accumulator: DEBUG: (%s) updated stored_data->srcuser to %s\", _key, stored_data->srcuser);\n    }\n\n    if (acm_str_replace(&stored_data->dstip, lf->dstip) == 0) {\n        mdebug2(\"accumulator: DEBUG: (%s) updated stored_data->dstip to %s\", _key, stored_data->dstip);\n    }\n\n    if (acm_str_replace(&stored_data->srcip, lf->srcip) == 0) {\n        mdebug2(\"accumulator: DEBUG: (%s) updated stored_data->srcip to %s\", _key, stored_data->srcip);\n    }\n\n    if (acm_str_replace(&stored_data->dstport, lf->dstport) == 0) {\n        mdebug2(\"accumulator: DEBUG: (%s) updated stored_data->dstport to %s\", _key, stored_data->dstport);\n    }\n\n    if (acm_str_replace(&stored_data->srcport, lf->srcport) == 0) {\n        mdebug2(\"accumulator: DEBUG: (%s) updated stored_data->srcport to %s\", _key, stored_data->srcport);\n    }\n\n    if (acm_str_replace(&stored_data->data, lf->data) == 0) {\n        mdebug2(\"accumulator: DEBUG: (%s) updated stored_data->data to %s\", _key, stored_data->data);\n    }\n\n    /* Update or Add to the hash */\n    if (do_update == 1) {\n        /* Update the hash entry */\n        if (result = OSHash_Update_ex(*acm_store, _key, stored_data), result != 1) {\n            merror(\"accumulator: ERROR: Update of stored data for %s failed (%d).\", _key, result);\n        } else {\n            mdebug1(\"accumulator: DEBUG: Updated stored data for %s\", _key);\n        }\n    } else {\n        if (result = OSHash_Add_ex(*acm_store, _key, stored_data), result != 2) {\n            FreeACMStore(stored_data);\n            merror(\"accumulator: ERROR: Addition of stored data for %s failed (%d).\", _key, result);\n        } else {\n            mdebug1(\"accumulator: DEBUG: Added stored data for %s\", _key);\n        }\n    }\n\n    return lf;\n}", "path": "wazuh/src/analysisd/accumulator.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "wazuh/wazuh", "stars": 8726, "license": "other", "language": "c", "size": 370734}
{"docstring": "/* Monitor the alerts and send them via syslog\n * Only return in case of error\n */\n", "func_signal": "void OS_CSyslogD(SyslogConfig **syslog_config)", "code": "{\n    int s = 0;\n    time_t tm;\n    struct tm tm_result = { .tm_sec = 0 };\n    int tries = 0;\n    alert_source_t sources = get_alert_sources(syslog_config);\n    file_queue *fileq = NULL;\n    file_queue jfileq;\n    alert_data *al_data = NULL;\n    cJSON *json_data = NULL;\n\n    if (sources.alert_log) {\n\n        /* Get current time before starting */\n        tm = time(NULL);\n        localtime_r(&tm, &tm_result);\n\n        /* Initialize file queue to read the alerts */\n        os_calloc(1, sizeof(file_queue), fileq);\n\n        for (tries = 0; tries < OS_CSYSLOGD_MAX_TRIES && Init_FileQueue(fileq, &tm_result, 0) < 0; tries++) {\n            sleep(1);\n        }\n\n        if (tries == OS_CSYSLOGD_MAX_TRIES) {\n            merror(\"Could not open queue after %d tries.\", tries);\n            sources.alert_log = 0;\n        } else {\n            mdebug1(\"File queue connected.\");\n        }\n    }\n\n    if (sources.alert_json) {\n        jqueue_init(&jfileq);\n\n        for (tries = 1; tries < OS_CSYSLOGD_MAX_TRIES && jqueue_open(&jfileq, 1) < 0; tries++) {\n            sleep(1);\n        }\n\n        if (tries == OS_CSYSLOGD_MAX_TRIES) {\n            merror(\"Could not open JSON queue after %d tries.\", tries);\n            sources.alert_json = 0;\n        } else {\n            mdebug1(\"JSON file queue connected.\");\n        }\n    }\n\n    if (!(sources.alert_log || sources.alert_json)) {\n        merror(\"No configurations available. Exiting.\");\n        exit(EXIT_FAILURE);\n    }\n\n    /* Connect to syslog */\n\n    for (s = 0; syslog_config[s]; s++) {\n        syslog_config[s]->socket = OS_ConnectUDP(syslog_config[s]->port, syslog_config[s]->server, 0);\n\n        if (syslog_config[s]->socket < 0) {\n            merror(CONNS_ERROR, syslog_config[s]->server, syslog_config[s]->port, \"udp\", strerror(errno));\n        } else {\n            minfo(\"Forwarding alerts via syslog to: '%s:%d'.\",\n                   syslog_config[s]->server, syslog_config[s]->port);\n        }\n    }\n\n    /* Infinite loop reading the alerts and inserting them */\n    while (1) {\n        tm = time(NULL);\n        localtime_r(&tm, &tm_result);\n\n        if (sources.alert_log) {\n            /* Get message if available (timeout of 5 seconds) */\n            mdebug2(\"Read_FileMon()\");\n            al_data = Read_FileMon(fileq, &tm_result, 1);\n        }\n\n        if (sources.alert_json) {\n            mdebug2(\"jqueue_next()\");\n            json_data = jqueue_next(&jfileq);\n        }\n\n        /* Send via syslog */\n\n        for (s = 0; syslog_config[s]; s++) {\n            if (syslog_config[s]->format == JSON_CSYSLOG) {\n                if (json_data) {\n                    OS_Alert_SendSyslog_JSON(json_data, syslog_config[s]);\n                }\n            } else if (al_data) {\n                OS_Alert_SendSyslog(al_data, syslog_config[s]);\n            }\n        }\n\n        /* Clear the memory */\n\n        if (al_data) {\n            FreeAlertData(al_data);\n        }\n\n        if (json_data) {\n            cJSON_Delete(json_data);\n        }\n    }\n}", "path": "wazuh/src/os_csyslogd/csyslogd.c", "commit_date": "2020-10-08 00:00:00", "repo_name": "wazuh/wazuh", "stars": 8726, "license": "other", "language": "c", "size": 370734}
{"docstring": "/* Initialize a storage object */\n", "func_signal": "OS_ACM_Store *InitACMStore()", "code": "{\n    OS_ACM_Store *obj;\n    os_calloc(1, sizeof(OS_ACM_Store), obj);\n\n    obj->timestamp = 0;\n    obj->srcuser = NULL;\n    obj->dstuser = NULL;\n    obj->srcip = NULL;\n    obj->dstip = NULL;\n    obj->srcport = NULL;\n    obj->dstport = NULL;\n    obj->data = NULL;\n\n    return obj;\n}", "path": "wazuh/src/analysisd/accumulator.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "wazuh/wazuh", "stars": 8726, "license": "other", "language": "c", "size": 370734}
{"docstring": "/* OSSECAlert decoder init */\n", "func_signal": "void *OSSECAlert_Decoder_Init()", "code": "{\n    mdebug1(\"Initializing OSSECAlert decoder.\");\n\n\n    /* There is nothing else to do over here */\n    return(NULL);\n}", "path": "wazuh/src/analysisd/decoders/plugins/ossecalert_decoder.c", "commit_date": "2020-10-02 00:00:00", "repo_name": "wazuh/wazuh", "stars": 8726, "license": "other", "language": "c", "size": 370734}
{"docstring": "/* Send alerts via syslog from JSON alert\n * Returns 1 on success or 0 on error\n */\n", "func_signal": "int OS_Alert_SendSyslog_JSON(cJSON *json_data, const SyslogConfig *syslog_config)", "code": "{\n    cJSON * rule;\n    cJSON * timestamp;\n    cJSON * groups;\n    cJSON * item;\n    char * string;\n    int i;\n    char msg[OS_MAXSTR];\n    struct tm tm = { .tm_sec = 0 };\n    time_t now;\n    char * end;\n    char strtime[64];\n\n    mdebug2(\"OS_Alert_SendSyslog_JSON()\");\n\n    if (rule = cJSON_GetObjectItem(json_data, \"rule\"), !rule) {\n        merror(\"Alert with no rule field.\");\n        return 0;\n    }\n\n    if (timestamp = cJSON_GetObjectItem(json_data, \"timestamp\"), !timestamp) {\n        merror(\"Alert with no timestamp field.\");\n        return 0;\n    }\n\n    /* Look if location is set */\n\n    if (syslog_config->location && !(item = cJSON_GetObjectItem(json_data, \"location\"), item && (string = item->valuestring, OSMatch_Execute(string, strlen(string), syslog_config->location)))) {\n        return 0;\n    }\n\n    /* Look for the level */\n\n    if (syslog_config->level && !(item = cJSON_GetObjectItem(rule, \"level\"), item && item->valueint >= (int)syslog_config->level)) {\n        return 0;\n    }\n\n    /* Look for rule id */\n\n    if (syslog_config->rule_id) {\n\n        // If no such rule or level, give up\n\n        if (!(rule && (item = cJSON_GetObjectItem(rule, \"id\"), item))) {\n            return 0;\n        }\n\n        for (i = 0; syslog_config->rule_id[i] && (int)syslog_config->rule_id[i] != atoi(item->valuestring); i++);\n\n        /* If we found, id is going to be a valid rule */\n\n        if (!syslog_config->rule_id[i]) {\n            return (0);\n        }\n    }\n\n    /* Look for the group */\n\n    if (syslog_config->group) {\n        int found = 0;\n\n        if (!(rule && (groups = cJSON_GetObjectItem(rule, \"groups\"), groups))) {\n            return 0;\n        }\n\n        cJSON_ArrayForEach(item, groups) {\n            string = item->valuestring;\n\n            if (OSMatch_Execute(string, strlen(string), syslog_config->group)) {\n                found++;\n                break;\n            }\n        }\n\n        if (!found) {\n            return 0;\n        }\n    }\n\n    string = cJSON_PrintUnformatted(json_data);\n\n    now = time(NULL);\n    localtime_r(&now, &tm);\n\n    if (end = strchr(timestamp->valuestring, '.'), end)\n        *end = '\\0';\n\n    if (end = strptime(timestamp->valuestring, \"%FT%T\", &tm), !end || *end) {\n        merror(\"Could not parse timestamp '%s'.\", timestamp->valuestring);\n    }\n\n    strftime(strtime, sizeof(strtime), \"%b %d %T\", &tm);\n\n    // Space-padding instead of zero-padding\n    if (strtime[4] == '0') {\n        strtime[4] = ' ';\n    }\n\n    /* Create the syslog message */\n    snprintf(msg, OS_MAXSTR,\n             \"<%u>%s %s ossec: %s\",\n\n             /* syslog header */\n             syslog_config->priority, strtime, syslog_config->use_fqdn ? __shost_long : __shost,\n\n             /* JSON Encoded Data */\n             string\n            );\n\n    mdebug2(\"OS_Alert_SendSyslog_JSON(): sending '%s'\", msg);\n    OS_SendUDPbySize(syslog_config->socket, strlen(msg), msg);\n    free(string);\n\n    return 1;\n}", "path": "wazuh/src/os_csyslogd/alert.c", "commit_date": "2020-03-30 00:00:00", "repo_name": "wazuh/wazuh", "stars": 8726, "license": "other", "language": "c", "size": 370734}
{"docstring": "/* setups/teardowns */\n", "func_signal": "static int setup_group(void **state)", "code": "{\n    test_mode = 1;\n    return 0;\n}", "path": "wazuh/src/unit_tests/os_crypto/sha1/test_sha1_op.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "wazuh/wazuh", "stars": 8726, "license": "other", "language": "c", "size": 370734}
{"docstring": "/* OS_SHA1_File_Nbytes */\n", "func_signal": "void OS_SHA1_File_Nbytes_unable_open_file (void **state)", "code": "{\n    const char *path = \"/home/test_file\";\n    SHA_CTX context;\n    os_sha1 output;\n    ssize_t nbytes = 4096;\n\n    int mode = OS_BINARY;\n\n    expect_value(__wrap_fopen, path, path);\n    expect_string(__wrap_fopen, mode, \"rb\");\n    will_return(__wrap_fopen, NULL);\n\n    int ret = OS_SHA1_File_Nbytes(path, &context, output, mode, nbytes);\n    assert_int_equal(ret, -1);\n}", "path": "wazuh/src/unit_tests/os_crypto/sha1/test_sha1_op.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "wazuh/wazuh", "stars": 8726, "license": "other", "language": "c", "size": 370734}
{"docstring": "/* Get port and protocol */\n", "func_signal": "static char *__get_port(char *str, char *proto, char *port, size_t msize)", "code": "{\n    int filtered = 0;\n    char *p, *q;\n\n    /* Remov whitespace */\n    while (*str == ' ') {\n        str++;\n    }\n\n    /* Get port */\n    p = strchr(str, '/');\n    if (!p) {\n        return (NULL);\n    }\n    *p = '\\0';\n    p++;\n\n    /* Get port */\n    strncpy(port, str, msize);\n    port[msize - 1] = '\\0';\n\n    /* Check if the port is open */\n    q = __go_after(p, NMAPG_OPEN);\n    if (!q) {\n        /* Port is not open */\n        filtered = 1;\n        q = p;\n\n        /* Going to the start of protocol field */\n        p = strchr(q, '/');\n        if (!p) {\n            return (NULL);\n        }\n        p++;\n    } else {\n        p = q;\n    }\n\n    /* Get protocol */\n    str = p;\n    p = strchr(str, '/');\n    if (!p) {\n        return (NULL);\n    }\n    *p = '\\0';\n    p++;\n\n    strncpy(proto, str, msize);\n    proto[msize - 1] = '\\0';\n\n    /* Set proto to null if port is not open */\n    if (filtered) {\n        proto[0] = '\\0';\n    }\n\n    /* Remove slashes */\n    if (*p == '/') {\n        p++;\n        q = p;\n        p = strchr(p, ',');\n        if (p) {\n            return (p);\n        }\n\n        return (q);\n    }\n\n    return (NULL);\n}", "path": "wazuh/src/logcollector/read_nmapg.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "wazuh/wazuh", "stars": 8726, "license": "other", "language": "c", "size": 370734}
{"docstring": "/* Send an alert via syslog\n * Returns 1 on success or 0 on error\n */\n", "func_signal": "int OS_Alert_SendSyslog(alert_data *al_data, const SyslogConfig *syslog_config)", "code": "{\n    char *tstamp;\n    char *hostname;\n    char syslog_msg[OS_MAXSTR];\n\n    /* Invalid socket */\n    if (syslog_config->socket < 0) {\n        return (0);\n    }\n\n    /* Clear the memory before insert */\n    memset(syslog_msg, '\\0', OS_MAXSTR);\n\n    /* Look if location is set */\n\n    if (syslog_config->location) {\n        //Check if location is headless\n        char * location_headless = strstr(al_data->location,\"->\");\n\n        if (location_headless){        //If location has head, cut it off\n            location_headless = location_headless + 2;\n        }\n\n        if (!OSMatch_Execute(location_headless ? location_headless : al_data->location,\n                             strlen(al_data->location),\n                             syslog_config->location)) {\n            return (0);\n        }\n\n    }\n\n\n    /* Look for the level */\n    if (syslog_config->level) {\n        if (al_data->level < syslog_config->level) {\n            return (0);\n        }\n    }\n\n    /* Look for rule id */\n    if (syslog_config->rule_id) {\n        int id_i = 0;\n        while (syslog_config->rule_id[id_i] != 0) {\n            if (syslog_config->rule_id[id_i] == al_data->rule) {\n                break;\n            }\n            id_i++;\n        }\n\n        /* If we found, id is going to be a valid rule */\n        if (!syslog_config->rule_id[id_i]) {\n            return (0);\n        }\n    }\n\n    /* Look for the group */\n    if (syslog_config->group) {\n        if (!OSMatch_Execute(al_data->group,\n                             strlen(al_data->group),\n                             syslog_config->group)) {\n            return (0);\n        }\n    }\n\n    /* Fix the timestamp to be syslog compatible\n     * We have 2008 Jul 10 10:11:23\n     * Should be: Jul 10 10:11:23\n     */\n    tstamp = al_data->date;\n    if (strlen(al_data->date) > 14) {\n        tstamp += 5;\n\n        /* Fix first digit if the day is < 10 */\n        if (tstamp[4] == '0') {\n            tstamp[4] = ' ';\n        }\n    }\n\n    if (syslog_config->use_fqdn) {\n        hostname = __shost_long;\n    } else {\n        hostname = __shost;\n    }\n\n    /* Insert data */\n    if (syslog_config->format == DEFAULT_CSYSLOG) {\n        /* Build syslog message */\n        snprintf(syslog_msg, OS_SIZE_2048,\n                 \"<%u>%s %s ossec: Alert Level: %u; Rule: %u - %s; Location: %s;\",\n                 syslog_config->priority, tstamp, hostname,\n                 al_data->level,\n                 al_data->rule, al_data->comment,\n                 al_data->location\n                );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" classification: %s;\", al_data->group );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" srcip: %s;\", al_data->srcip );\n#ifdef LIBGEOIP_ENABLED\n        field_add_string(syslog_msg, OS_SIZE_2048, \" srccity: %s;\", al_data->srcgeoip );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" dstcity: %s;\", al_data->dstgeoip );\n#endif\n        field_add_string(syslog_msg, OS_SIZE_2048, \" dstip: %s;\", al_data->dstip );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" user: %s;\", al_data->user );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" Previous MD5: %s;\", al_data->old_md5 );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" Current MD5: %s;\", al_data->new_md5 );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" Previous SHA1: %s;\", al_data->old_sha1 );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" Current SHA1: %s;\", al_data->new_sha1 );\n        if(al_data->old_sha256){\n            field_add_string(syslog_msg, OS_SIZE_2048, \" Previous SHA256: %s;\", al_data->old_sha256 );\n        }\n        if(al_data->new_sha256){\n            field_add_string(syslog_msg, OS_SIZE_2048, \" Current SHA256: %s;\", al_data->new_sha256 );\n        }\n     /* \"9/19/2016 - Sivakumar Nellurandi - parsing additions\" */\n        field_add_string(syslog_msg, OS_SIZE_2048, \" Size changed: from %s;\", al_data->file_size );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" User ownership: was %s;\", al_data->owner_chg );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" Group ownership: was %s;\", al_data->group_chg );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" Permissions changed: from %s;\", al_data->perm_chg );\n     /* \"9/19/2016 - Sivakumar Nellurandi - parsing additions\" */\n        field_add_truncated(syslog_msg, OS_SIZE_61440, \" %s\", al_data->log[0], 2 );\n    } else if (syslog_config->format == CEF_CSYSLOG) {\n        snprintf(syslog_msg, OS_SIZE_2048,\n                 \"<%u>%s CEF:0|%s|%s|%s|%u|%s|%u|dvc=%s cs1=%s cs1Label=Location\",\n                 syslog_config->priority,\n                 tstamp,\n                 __author,\n                 __ossec_name,\n                 __ossec_version,\n                 al_data->rule,\n                 al_data->comment,\n                 (al_data->level > 10) ? 10 : al_data->level,\n                 hostname, al_data->location);\n        field_add_string(syslog_msg, OS_SIZE_2048, \" cat=%s\", al_data->group );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" src=%s\", al_data->srcip );\n        field_add_int(syslog_msg, OS_SIZE_2048, \" dpt=%d\", al_data->dstport );\n        field_add_int(syslog_msg, OS_SIZE_2048, \" spt=%d\", al_data->srcport );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" fname=%s\", al_data->filename );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" dhost=%s\", al_data->dstip );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" shost=%s\", al_data->srcip );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" suser=%s\", al_data->user );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" dst=%s\", al_data->dstip );\n#ifdef LIBGEOIP_ENABLED\n        field_add_string(syslog_msg, OS_SIZE_2048, \" cs4Label=SrcCity cs4=%s\", al_data->srcgeoip );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" cs5Label=DstCity cs5=%s\", al_data->dstgeoip );\n#endif\n        field_add_string(syslog_msg, OS_SIZE_2048, \" suser=%s\", al_data->user );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" dst=%s\", al_data->dstip );\n        field_add_truncated(syslog_msg, OS_SIZE_61440, \" msg=%s\", al_data->log[0], 2 );\n        if (al_data->new_md5 && al_data->new_sha1) {\n            field_add_string(syslog_msg, OS_SIZE_2048, \" cs2Label=OldMD5 cs2=%s\", al_data->old_md5);\n            field_add_string(syslog_msg, OS_SIZE_2048, \" cs3Label=NewMD5 cs3=%s\", al_data->new_md5);\n            field_add_string(syslog_msg, OS_SIZE_2048, \" oldFileHash=%s\", al_data->old_sha1 );\n            field_add_string(syslog_msg, OS_SIZE_2048, \" fhash=%s\", al_data->new_sha1 );\n            field_add_string(syslog_msg, OS_SIZE_2048, \" fileHash=%s\", al_data->new_sha1 );\n        }\n    } else if (syslog_config->format == JSON_CSYSLOG) {\n        /* Build a JSON Object for logging */\n        cJSON *root;\n        char *json_string;\n        root = cJSON_CreateObject();\n\n        /* Data guaranteed to be there */\n        cJSON_AddNumberToObject(root, \"crit\",      al_data->level);\n        cJSON_AddNumberToObject(root, \"id\",        al_data->rule);\n        cJSON_AddStringToObject(root, \"component\", al_data->location);\n\n        /* Rule Meta Data */\n        if (al_data->group) {\n            cJSON_AddStringToObject(root, \"classification\", al_data->group);\n        }\n        if (al_data->comment) {\n            cJSON_AddStringToObject(root, \"description\",    al_data->comment);\n        }\n\n        /* Raw log message generating event */\n        if (al_data->log && al_data->log[0]) {\n            cJSON_AddStringToObject(root, \"message\",        al_data->log[0]);\n        }\n\n        /* Add data if it exists */\n        if (al_data->user) {\n            cJSON_AddStringToObject(root,   \"acct\",       al_data->user);\n        }\n        if (al_data->srcip) {\n            cJSON_AddStringToObject(root,   \"src_ip\",     al_data->srcip);\n        }\n        if (al_data->srcport) {\n            cJSON_AddNumberToObject(root,   \"src_port\",   al_data->srcport);\n        }\n        if (al_data->dstip) {\n            cJSON_AddStringToObject(root,   \"dst_ip\",     al_data->dstip);\n        }\n        if (al_data->dstport) {\n            cJSON_AddNumberToObject(root,   \"dst_port\",   al_data->dstport);\n        }\n        if (al_data->filename) {\n            cJSON_AddStringToObject(root,   \"file\",       al_data->filename);\n        }\n        if (al_data->old_md5) {\n            cJSON_AddStringToObject(root,   \"md5_old\",    al_data->old_md5);\n        }\n        if (al_data->new_md5) {\n            cJSON_AddStringToObject(root,   \"md5_new\",    al_data->new_md5);\n        }\n        if (al_data->old_sha1) {\n            cJSON_AddStringToObject(root,   \"sha1_old\",   al_data->old_sha1);\n        }\n        if (al_data->new_sha1) {\n            cJSON_AddStringToObject(root,   \"sha1_new\",   al_data->new_sha1);\n        }\n        if (al_data->old_sha256) {\n            cJSON_AddStringToObject(root,   \"sha256_old\",   al_data->old_sha256);\n        }\n        if (al_data->new_sha256) {\n            cJSON_AddStringToObject(root,   \"sha256_new\",   al_data->new_sha256);\n        }\n#ifdef LIBGEOIP_ENABLED\n        if (al_data->srcgeoip) {\n            cJSON_AddStringToObject(root, \"src_city\", al_data->srcgeoip);\n        }\n        if (al_data->dstgeoip) {\n            cJSON_AddStringToObject(root, \"dst_city\", al_data->dstgeoip);\n        }\n#endif\n\n        /* Create the JSON string */\n        json_string = cJSON_PrintUnformatted(root);\n\n        /* Create the syslog message */\n        snprintf(syslog_msg, OS_SIZE_2048,\n                 \"<%u>%s %s ossec: %s\",\n\n                 /* syslog header */\n                 syslog_config->priority, tstamp, hostname,\n\n                 /* JSON Encoded Data */\n                 json_string\n                );\n        /* Clean up the memory for the JSON structure */\n        free(json_string);\n        cJSON_Delete(root);\n    } else if (syslog_config->format == SPLUNK_CSYSLOG) {\n        /* Build a Splunk Style Key/Value string for logging */\n        snprintf(syslog_msg, OS_SIZE_2048,\n                 \"<%u>%s %s ossec: crit=%u id=%u description=\\\"%s\\\" component=\\\"%s\\\",\",\n\n                 /* syslog header */\n                 syslog_config->priority, tstamp, hostname,\n\n                 /* OSSEC metadata */\n                 al_data->level, al_data->rule, al_data->comment,\n                 al_data->location\n                );\n        /* Event specifics */\n        field_add_string(syslog_msg, OS_SIZE_2048, \" classification=\\\"%s\\\",\", al_data->group );\n\n        if ( field_add_string(syslog_msg, OS_SIZE_2048, \" src_ip=\\\"%s\\\",\", al_data->srcip ) > 0 ) {\n            field_add_int(syslog_msg, OS_SIZE_2048, \" src_port=%d,\", al_data->srcport );\n        }\n\n#ifdef LIBGEOIP_ENABLED\n        field_add_string(syslog_msg, OS_SIZE_2048, \" src_city=\\\"%s\\\",\", al_data->srcgeoip );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" dst_city=\\\"%s\\\",\", al_data->dstgeoip );\n#endif\n\n        if ( field_add_string(syslog_msg, OS_SIZE_2048, \" dst_ip=\\\"%s\\\",\", al_data->dstip ) > 0 ) {\n            field_add_int(syslog_msg, OS_SIZE_2048, \" dst_port=%d,\", al_data->dstport );\n        }\n\n        field_add_string(syslog_msg, OS_SIZE_2048, \" file=\\\"%s\\\",\", al_data->filename );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" acct=\\\"%s\\\",\", al_data->user );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" md5_old=\\\"%s\\\",\", al_data->old_md5 );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" md5_new=\\\"%s\\\",\", al_data->new_md5 );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" sha1_old=\\\"%s\\\",\", al_data->old_sha1 );\n        field_add_string(syslog_msg, OS_SIZE_2048, \" sha1_new=\\\"%s\\\",\", al_data->new_sha1 );\n        if(al_data->old_sha256){\n            field_add_string(syslog_msg, OS_SIZE_2048, \" sha256_old=\\\"%s\\\",\", al_data->old_sha256 );\n        }\n        if(al_data->new_sha256){\n            field_add_string(syslog_msg, OS_SIZE_2048, \" sha256_new=\\\"%s\\\",\", al_data->new_sha256 );\n        }\n        /* Message */\n        field_add_truncated(syslog_msg, OS_SIZE_61440, \" message=\\\"%s\\\"\", al_data->log[0], 2 );\n    }\n\n    OS_SendUDPbySize(syslog_config->socket, strlen(syslog_msg), syslog_msg);\n    return (1);\n}", "path": "wazuh/src/os_csyslogd/alert.c", "commit_date": "2020-03-30 00:00:00", "repo_name": "wazuh/wazuh", "stars": 8726, "license": "other", "language": "c", "size": 370734}
{"docstring": "/* Start the Accumulator module */\n", "func_signal": "int Accumulate_Init(OSHash **acm_store, int *acm_lookups, time_t *acm_purge_ts)", "code": "{\n    struct timeval tp;\n\n    *acm_lookups = 0;\n\n    /* Create store data */\n    *acm_store = OSHash_Create();\n    if (!(*acm_store)) {\n        merror(LIST_ERROR);\n        return (0);\n    }\n    if (!OSHash_setSize(*acm_store, 2048)) {\n        merror(LIST_ERROR);\n        return (0);\n    }\n\n    /* Default Expiry */\n    gettimeofday(&tp, NULL);\n    *acm_purge_ts = tp.tv_sec;\n\n    mdebug1(\"Accumulator Init completed.\");\n    return (1);\n}", "path": "wazuh/src/analysisd/accumulator.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "wazuh/wazuh", "stars": 8726, "license": "other", "language": "c", "size": 370734}
{"docstring": "// Setup / teardown\n", "func_signal": "static int teardown_json(void **state)", "code": "{\n    cJSON *json = *state;\n    cJSON_Delete(json);\n    return 0;\n}", "path": "wazuh/src/unit_tests/wazuh_modules/agent_upgrade/test_wm_agent_upgrade_commands.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "wazuh/wazuh", "stars": 8726, "license": "other", "language": "c", "size": 370734}
{"docstring": "/* Format Field for output */\n", "func_signal": "int field_add_string(char *dest, size_t size, const char *format, const char *value )", "code": "{\n    char buffer[OS_MAXSTR];\n    int len = 0;\n    int dest_sz = size - strlen(dest);\n\n    /* Not enough room in the buffer? */\n    if (dest_sz <= 0 ) {\n        return -1;\n    }\n\n    if (value != NULL &&\n            (\n                ((value[0] != '(') && (value[1] != 'n') && (value[2] != 'o')) ||\n                ((value[0] != '(') && (value[1] != 'u') && (value[2] != 'n')) ||\n                ((value[0] != 'u') && (value[1] != 'n') && (value[4] != 'k'))\n            )\n       ) {\n        len = snprintf(buffer, sizeof(buffer) - dest_sz - 1, format, value);\n        strncat(dest, buffer, dest_sz);\n    }\n\n    return len;\n}", "path": "wazuh/src/os_csyslogd/csyslogd.c", "commit_date": "2020-10-08 00:00:00", "repo_name": "wazuh/wazuh", "stars": 8726, "license": "other", "language": "c", "size": 370734}
{"docstring": "/* OS_SHA1_Stream */\n", "func_signal": "void OS_SHA1_Stream_ok (void **state)", "code": "{\n    char *buf = \"hello\";\n    os_sha1 output;\n    SHA_CTX context;\n\n    SHA1_Init(&context);\n\n    OS_SHA1_Stream(&context, output, buf);\n}", "path": "wazuh/src/unit_tests/os_crypto/sha1/test_sha1_op.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "wazuh/wazuh", "stars": 8726, "license": "other", "language": "c", "size": 370734}
{"docstring": "/* Monitor the alerts and insert them into the database\n * Only returns in case of error\n */\n", "func_signal": "void OS_DBD(DBConfig *db_config)", "code": "{\n    time_t tm;\n    file_queue *fileq;\n    alert_data *al_data;\n    struct tm tm_result = { .tm_sec = 0 };\n\n    /* Get current time before starting */\n    tm = time(NULL);\n    localtime_r(&tm, &tm_result);\n\n    /* Initialize file queue to read the alerts */\n    os_calloc(1, sizeof(file_queue), fileq);\n    Init_FileQueue(fileq, &tm_result, 0);\n\n    /* Get maximum ID */\n    db_config->alert_id = OS_SelectMaxID(db_config);\n    db_config->alert_id++;\n\n    /* Infinite loop reading the alerts and inserting them */\n    while (1) {\n        tm = time(NULL);\n        localtime_r(&tm, &tm_result);\n\n        /* Get message if available (timeout of 5 seconds) */\n        al_data = Read_FileMon(fileq, &tm_result, 5);\n        if (!al_data) {\n            continue;\n        }\n\n        /* Insert into the db */\n        OS_Alert_InsertDB(al_data, db_config);\n\n        /* Clear the memory */\n        FreeAlertData(al_data);\n    }\n}", "path": "wazuh/src/os_dbd/dbd.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "wazuh/wazuh", "stars": 8726, "license": "other", "language": "c", "size": 370734}
{"docstring": "/* setup/teardown */\n", "func_signal": "int test_free_file(void **state)", "code": "{\n    os_free(*state);\n    return 0;\n}", "path": "wazuh/src/unit_tests/shared/test_rootcheck_op.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "wazuh/wazuh", "stars": 8726, "license": "other", "language": "c", "size": 370734}
{"docstring": "/***  SETUPS/TEARDOWNS  ******/\n", "func_signal": "static int setup_module()", "code": "{\n    command_module = calloc(1, sizeof(wmodule));\n    const char *string =\n        \"<disabled>no</disabled>\\n\"\n        \"<tag>test</tag>\\n\"\n        \"<command>/bin/bash /root/script.sh</command>\\n\"\n        \"<interval>1d</interval>\\n\"\n        \"<ignore_output>no</ignore_output>\\n\"\n        \"<run_on_start>no</run_on_start>\\n\"\n        \"<timeout>0</timeout>\\n\"\n        \"<verify_sha1>da39a3ee5e6b4b0d3255bfef95601890afd80709</verify_sha1>\\n\"\n        \"<verify_sha256>292a188e498caea5c5fbfb0beca413c980e7a5edf40d47cf70e1dbc33e4f395e</verify_sha256>\\n\"\n        \"<interval>10m</interval>\\n\"\n        \"<skip_verification>yes</skip_verification>\"\n    ;\n    lxml = malloc(sizeof(OS_XML));\n    XML_NODE nodes = string_to_xml_node(string, lxml);\n\n    int ret = wm_command_read(nodes, command_module, 0);\n    OS_ClearNode(nodes);\n    test_mode = 1;\n    return ret;\n}", "path": "wazuh/src/unit_tests/wazuh_modules/command/test_wm_command.c", "commit_date": "2020-09-01 00:00:00", "repo_name": "wazuh/wazuh", "stars": 8726, "license": "other", "language": "c", "size": 370734}
{"docstring": "/********** setup/teardown *********************/\n", "func_signal": "int setup_wdb(void **state)", "code": "{\n    wdb_t *wdb = NULL;\n    os_calloc(1,sizeof(wdb_t),wdb);\n    os_strdup(\"000\",wdb->id);\n    os_calloc(1,sizeof(sqlite3 *),wdb->db);\n    *state = wdb;\n    return 0;\n}", "path": "wazuh/src/unit_tests/wazuh_db/test_wdb_rootcheck.c", "commit_date": "2020-10-15 00:00:00", "repo_name": "wazuh/wazuh", "stars": 8726, "license": "other", "language": "c", "size": 370734}
{"docstring": "/* Handle integers in the second position */\n", "func_signal": "int field_add_int(char *dest, size_t size, const char *format, const int value )", "code": "{\n    char buffer[255];\n    int len = 0;\n    int dest_sz = size - strlen(dest);\n\n    /* Not enough room in the buffer? */\n    if (dest_sz <= 0 ) {\n        return -1;\n    }\n\n    if ( value > 0 ) {\n        len = snprintf(buffer, sizeof(buffer), format, value);\n        strncat(dest, buffer, dest_sz);\n    }\n\n    return len;\n}", "path": "wazuh/src/os_csyslogd/csyslogd.c", "commit_date": "2020-10-08 00:00:00", "repo_name": "wazuh/wazuh", "stars": 8726, "license": "other", "language": "c", "size": 370734}
{"docstring": "/* Add a field, but truncate if too long */\n", "func_signal": "int field_add_truncated(char *dest, size_t size, const char *format, const char *value, int fmt_size )", "code": "{\n    char buffer[OS_MAXSTR];\n\n    int available_sz = size - strlen(dest);\n    int total_sz = strlen(value) + strlen(format) - fmt_size;\n    int field_sz = available_sz - strlen(format) + fmt_size;\n\n    int len = 0;\n    char trailer[] = \"...\";\n    char *truncated = NULL;\n\n    /* Not enough room in the buffer? */\n    if (available_sz <= 0 ) {\n        return -1;\n    }\n\n    if (\n        ((value[0] != '(') && (value[1] != 'n') && (value[2] != 'o')) ||\n        ((value[0] != '(') && (value[1] != 'u') && (value[2] != 'n')) ||\n        ((value[0] != 'u') && (value[1] != 'n') && (value[4] != 'k'))\n       ) {\n\n        if ( (truncated = (char *) malloc(field_sz + 1)) != NULL ) {\n            if ( total_sz > available_sz ) {\n                /* Truncate and add a trailer */\n                os_substr(truncated, value, 0, field_sz - strlen(trailer));\n                strcat(truncated, trailer);\n            } else {\n                strncpy(truncated, value, field_sz);\n            }\n\n            len = snprintf(buffer, available_sz, format, truncated);\n            strncat(dest, buffer, available_sz);\n        } else {\n            /* Memory Error */\n            len = -3;\n        }\n    }\n    /* Free the temporary pointer */\n    free(truncated);\n\n    return len;\n}", "path": "wazuh/src/os_csyslogd/csyslogd.c", "commit_date": "2020-10-08 00:00:00", "repo_name": "wazuh/wazuh", "stars": 8726, "license": "other", "language": "c", "size": 370734}
{"docstring": "/* Check if the string matches */\n", "func_signal": "static char *__go_after(char *x, const char *y)", "code": "{\n    size_t x_s;\n    size_t y_s;\n\n    /* X and Y must be not null */\n    if (!x || !y) {\n        return (NULL);\n    }\n\n    x_s = strlen(x);\n    y_s = strlen(y);\n\n    if (x_s <= y_s) {\n        return (NULL);\n    }\n\n    /* String does not match */\n    if (strncmp(x, y, y_s) != 0) {\n        return (NULL);\n    }\n\n    x += y_s;\n\n    return (x);\n}", "path": "wazuh/src/logcollector/read_nmapg.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "wazuh/wazuh", "stars": 8726, "license": "other", "language": "c", "size": 370734}
{"docstring": "// parse the outer vxlan frame\n", "func_signal": "int handle_outer(struct __sk_buff *skb)", "code": "{\n  u8 *cursor = 0;\n\n  struct ethernet_t *ethernet = cursor_advance(cursor, sizeof(*ethernet));\n\n  // filter bcast/mcast from the stats\n  if (ethernet->dst & (1ull << 40))\n    goto finish;\n\n  switch (ethernet->type) {\n    case 0x0800: goto ip;\n    default: goto finish;\n  }\n\nip: ;\n  struct ip_t *ip = cursor_advance(cursor, sizeof(*ip));\n  skb->cb[CB_SIP] = ip->src;\n  skb->cb[CB_DIP] = ip->dst;\n\n  switch (ip->nextp) {\n    case 17: goto udp;\n    default: goto finish;\n  }\n\nudp: ;\n  struct udp_t *udp = cursor_advance(cursor, sizeof(*udp));\n  switch (udp->dport) {\n    case 4789: goto vxlan;\n    default: goto finish;\n  }\n\nvxlan: ;\n  struct vxlan_t *vxlan = cursor_advance(cursor, sizeof(*vxlan));\n  skb->cb[CB_VNI] = vxlan->key;\n  skb->cb[CB_OFFSET] = (u64)vxlan + sizeof(*vxlan);\n  parser.call(skb, 2);\n\nfinish:\n  return 1;\n}", "path": "bcc/examples/networking/tunnel_monitor/monitor.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "iovisor/bcc", "stars": 19046, "license": "apache-2.0", "language": "c", "size": 20430}
{"docstring": "// Handle packets from the encap device, demux into the dest tenant\n", "func_signal": "int handle_ingress(struct __sk_buff *skb)", "code": "{\n  u8 *cursor = 0;\n\n  struct ethernet_t *ethernet = cursor_advance(cursor, sizeof(*ethernet));\n\n  struct bpf_tunnel_key tkey = {};\n  bpf_skb_get_tunnel_key(skb, &tkey,\n      offsetof(struct bpf_tunnel_key, remote_ipv6[1]), 0);\n\n  int *ifindex = vni2if.lookup(&tkey.tunnel_id);\n  if (ifindex) {\n    //bpf_trace_printk(\"ingress tunnel_id=%d ifindex=%d\\n\", tkey.tunnel_id, *ifindex);\n    struct vni_key vk = {ethernet->src, *ifindex, 0};\n    struct host *src_host = mac2host.lookup_or_try_init(&vk,\n        &(struct host){tkey.tunnel_id, tkey.remote_ipv4, 0, 0});\n    if (src_host) {\n      lock_xadd(&src_host->rx_pkts, 1);\n    }\n    bpf_clone_redirect(skb, *ifindex, 1/*ingress*/);\n  } else {\n    bpf_trace_printk(\"ingress invalid tunnel_id=%d\\n\", tkey.tunnel_id);\n  }\n\n  return 1;\n}", "path": "bcc/examples/networking/distributed_bridge/tunnel.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "iovisor/bcc", "stars": 19046, "license": "apache-2.0", "language": "c", "size": 20430}
{"docstring": "// Handle packets from the tenant, mux into the encap device\n", "func_signal": "int handle_egress(struct __sk_buff *skb)", "code": "{\n  u8 *cursor = 0;\n\n  int one = 1;\n  struct config *cfg = conf.lookup(&one);\n  if (!cfg) return 1;\n\n  struct ethernet_t *ethernet = cursor_advance(cursor, sizeof(*ethernet));\n\n  struct vni_key vk = {ethernet->dst, skb->ifindex, 0};\n  struct host *dst_host = mac2host.lookup(&vk);\n  struct bpf_tunnel_key tkey = {};\n  if (dst_host) {\n    u32 zero = 0;\n    tkey.tunnel_id = dst_host->tunnel_id;\n    tkey.remote_ipv4 = dst_host->remote_ipv4;\n    bpf_skb_set_tunnel_key(skb, &tkey,\n        offsetof(struct bpf_tunnel_key, remote_ipv6[1]), 0);\n    lock_xadd(&dst_host->tx_pkts, 1);\n  } else {\n    struct bpf_tunnel_key tkey = {};\n    vk.mac = 0xFFFFFFFFFFFFull;\n    dst_host = mac2host.lookup(&vk);\n    if (!dst_host)\n      return 1;\n    tkey.tunnel_id = dst_host->tunnel_id;\n    tkey.remote_ipv4 = dst_host->remote_ipv4;\n    bpf_skb_set_tunnel_key(skb, &tkey,\n        offsetof(struct bpf_tunnel_key, remote_ipv6[1]), 0);\n  }\n  bpf_clone_redirect(skb, cfg->tunnel_ifindex, 0/*egress*/);\n  return 1;\n}", "path": "bcc/examples/networking/distributed_bridge/tunnel.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "iovisor/bcc", "stars": 19046, "license": "apache-2.0", "language": "c", "size": 20430}
{"docstring": "// Trace return from clone() syscall in the child thread (return value > 0).\n", "func_signal": "int trace_clone(struct pt_regs *ctx, unsigned long flags, void *child_stack,\n                void *ptid, void *ctid, struct pt_regs *regs)", "code": "{\n  u32 child_pid = PT_REGS_RC(ctx);\n  if (child_pid <= 0) {\n    return 1;\n  }\n\n  struct thread_created_leaf_t thread_created_leaf = {};\n  thread_created_leaf.parent_pid = bpf_get_current_pid_tgid();\n  thread_created_leaf.stack_id =\n      stack_traces.get_stackid(ctx, BPF_F_USER_STACK);\n  bpf_get_current_comm(&thread_created_leaf.comm,\n                       sizeof(thread_created_leaf.comm));\n\n  struct thread_created_leaf_t *insert_result =\n      thread_to_parent.lookup_or_try_init(&child_pid, &thread_created_leaf);\n  if (!insert_result) {\n    bpf_trace_printk(\n        \"could not add thread_created_key, child: %d, parent: %d\\n\", child_pid,\n        thread_created_leaf.parent_pid);\n    return 1; // Could not insert, no more memory\n  }\n  return 0;\n}", "path": "bcc/tools/deadlock.c", "commit_date": "2020-05-25 00:00:00", "repo_name": "iovisor/bcc", "stars": 19046, "license": "apache-2.0", "language": "c", "size": 20430}
{"docstring": "// Process each neighbor packet, and store the source IP in the learned table.\n// Mark the inserted entry with a non-zero value to be used by the classify_wan\n// lookup.\n", "func_signal": "int classify_neighbor(struct __sk_buff *skb)", "code": "{\n  u8 *cursor = 0;\n  ethernet: {\n    struct ethernet_t *ethernet = cursor_advance(cursor, sizeof(*ethernet));\n    switch (ethernet->type) {\n      case ETH_P_IP: goto ip;\n      default: goto EOP;\n    }\n  }\n  ip: {\n    struct ip_t *ip = cursor_advance(cursor, sizeof(*ip));\n    u32 sip = ip->src;\n    struct ipkey key = {.client_ip=sip};\n    int val = 1;\n    learned_ips.insert(&key, &val);\n    goto EOP;\n  }\nEOP:\n  return 1;\n}", "path": "bcc/examples/networking/neighbor_sharing/tc_neighbor_sharing.c", "commit_date": "2017-04-01 00:00:00", "repo_name": "iovisor/bcc", "stars": 19046, "license": "apache-2.0", "language": "c", "size": 20430}
{"docstring": "// initial handler for each packet on an ingress tc filter\n", "func_signal": "int handle_ingress(struct __sk_buff *skb)", "code": "{\n  skb->cb[CB_FLAGS] = IS_INGRESS;\n  parser.call(skb, 1);  // jump to generic packet parser\n  return 1;\n}", "path": "bcc/examples/networking/tunnel_monitor/monitor.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "iovisor/bcc", "stars": 19046, "license": "apache-2.0", "language": "c", "size": 20430}
{"docstring": "// helper to swap the fields in an ipkey to give consistent ordering\n", "func_signal": "static inline\nvoid swap_ipkey(struct ipkey *key)", "code": "{\n  swap32(&key->outer_sip, &key->outer_dip);\n  swap32(&key->inner_sip, &key->inner_dip);\n}", "path": "bcc/examples/networking/tunnel_monitor/monitor.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "iovisor/bcc", "stars": 19046, "license": "apache-2.0", "language": "c", "size": 20430}
{"docstring": "/* Try to find the errno number using the errno(1) program */\n", "func_signal": "static int errno_by_name_dynamic(const char *errno_name)", "code": "{\n\tint len = strlen(errno_name);\n\tint err, number = -1;\n\tchar buf[128];\n\tchar cmd[64];\n\tchar *end;\n\tlong val;\n\tFILE *f;\n\n\t/* sanity check to not call popen with random input */\n\tfor (int i = 0; i < len; i++) {\n\t\tif (errno_name[i] < 'A' || errno_name[i] > 'Z') {\n\t\t\twarn(\"errno_name contains invalid char 0x%02x: %s\\n\",\n\t\t\t\t\terrno_name[i], errno_name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tsnprintf(cmd, sizeof(cmd), \"errno %s\", errno_name);\n\tf = popen(cmd, \"r\");\n\tif (!f) {\n\t\twarn(\"popen: %s: %s\\n\", cmd, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (!fgets(buf, sizeof(buf), f)) {\n\t\tgoto close;\n\t} else if (ferror(f)) {\n\t\twarn(\"fgets: %s\\n\", strerror(errno));\n\t\tgoto close;\n\t}\n\n\t// expecting \"<name> <number> <description>\"\n\tif (strncmp(errno_name, buf, len) || strlen(buf) < len+2) {\n\t\twarn(\"expected '%s': %s\\n\", errno_name, buf);\n\t\tgoto close;\n\t}\n\terrno = 0;\n\tval = strtol(buf+len+2, &end, 10);\n\tif (errno || end == (buf+len+2) || number < 0 || number > INT_MAX) {\n\t\twarn(\"can't parse the second column, expected int: %s\\n\", buf);\n\t\tgoto close;\n\t}\n\tnumber = val;\n\nclose:\n\terr = pclose(f);\n\tif (err < 0)\n\t\twarn(\"pclose: %s\\n\", strerror(errno));\n#ifndef __x86_64__\n\t/* Ignore the error for x86_64 where we have a table compiled in */\n\telse if (err && WEXITSTATUS(err) == 127) {\n\t\twarn(\"errno(1) required for errno name/number mapping\\n\");\n\t} else if (err) {\n\t\twarn(\"errno(1) exit status (see wait(2)): 0x%x\\n\", err);\n\t}\n#endif\n\treturn number;\n}", "path": "bcc/libbpf-tools/errno_helpers.c", "commit_date": "2020-06-02 00:00:00", "repo_name": "iovisor/bcc", "stars": 19046, "license": "apache-2.0", "language": "c", "size": 20430}
{"docstring": "// Process each wan packet, and determine if the packet is in the IP\n// table or not. Learned IPs are rate-limited and unclassified are not.\n// returns: > 0 when an IP is known\n//          = 0 when an IP is not known, or non-IP traffic\n", "func_signal": "int classify_wan(struct __sk_buff *skb)", "code": "{\n  u8 *cursor = 0;\n  ethernet: {\n    struct ethernet_t *ethernet = cursor_advance(cursor, sizeof(*ethernet));\n    switch (ethernet->type) {\n      case ETH_P_IP: goto ip;\n      default: goto EOP;\n    }\n  }\n  ip: {\n    struct ip_t *ip = cursor_advance(cursor, sizeof(*ip));\n    u32 dip = ip->dst;\n    struct ipkey key = {.client_ip=dip};\n    int *val = learned_ips.lookup(&key);\n    if (val)\n      return *val;\n    goto EOP;\n  }\nEOP:\n  return 0;\n}", "path": "bcc/examples/networking/neighbor_sharing/tc_neighbor_sharing.c", "commit_date": "2017-04-01 00:00:00", "repo_name": "iovisor/bcc", "stars": 19046, "license": "apache-2.0", "language": "c", "size": 20430}
{"docstring": "/*eBPF program.\n  Filter TCP/UDP/ICMP packets, having payload not empty\n  if the program is loaded as PROG_TYPE_SOCKET_FILTER\n  and attached to a socket\n  return  0 -> DROP the packet\n  return -1 -> KEEP the packet and return it to user space (userspace can read it from the socket_fd )\n*/\n", "func_signal": "int vlan_filter(struct __sk_buff *skb)", "code": "{ \n\tu8 *cursor = 0;\t\n\n\tstruct ethernet_t *ethernet = cursor_advance(cursor, sizeof(*ethernet));\n\t\n\t//filter IP packets (ethernet type = 0x0800) 0x0800 is IPv4 packet\n\tswitch(ethernet->type){\n\t\tcase 0x0800: goto IP;\n\t    \tdefault: goto DROP;\n\t}\n\n\t\n\tIP: ;\n\t\tstruct ip_t *ip = cursor_advance(cursor, sizeof(*ip));  // IP header (datagram)\n\t        switch (ip->nextp){\n\t\t\tcase 17: goto UDP;\n\t\t\tdefault: goto DROP;\n\t\t}\n\n\tUDP: ;\n\t\tstruct udp_t *udp = cursor_advance(cursor, sizeof(*udp));\n\t\tswitch (udp->dport) {\n    \t\t\tcase 4789: goto KEEP;\n    \t\t\tdefault: goto DROP;\n  \t\t}\n\n\t//keep the packet and send it to userspace returning -1\n\tKEEP:\n\t\treturn -1;\n\n\t//drop the packet returning 0\n\tDROP:\n\t\treturn 0;\n}", "path": "bcc/examples/networking/vlan_filter/data-plane-tracing.c", "commit_date": "2020-09-02 00:00:00", "repo_name": "iovisor/bcc", "stars": 19046, "license": "apache-2.0", "language": "c", "size": 20430}
{"docstring": "/**\n * @brief Reads the operation request arguments and stores the start data in the hash.\n * @param ctx The BPF context.\n */\n", "func_signal": "int trace_operation_start(struct pt_regs* ctx)", "code": "{\n    struct start_data_t start_data = {};\n    bpf_usdt_readarg_p(2, ctx, &start_data.input, sizeof(start_data.input));\n\n    FILTER ///< Replaced by python code.\n\n    bpf_usdt_readarg(1, ctx, &start_data.operation_id);\n\n    start_data.start = bpf_ktime_get_ns();\n    start_hash.update(&start_data.operation_id, &start_data);\n    return 0;\n}", "path": "bcc/examples/usdt_sample/scripts/bpf_text_shared.c", "commit_date": "2020-05-25 00:00:00", "repo_name": "iovisor/bcc", "stars": 19046, "license": "apache-2.0", "language": "c", "size": 20430}
{"docstring": "/*\nFinds a file descriptor for a given inode if it's a memory-backed fd.\n*/\n", "func_signal": "static char *_procutils_memfd_path(const int pid, const uint64_t inum)", "code": "{\n  char path_buffer[PATH_MAX + 1];\n  char *path = NULL;\n  char *dirstr;\n  DIR *dirstream;\n  struct stat sb;\n  struct dirent *dent;\n\n  snprintf(path_buffer, (PATH_MAX + 1), \"/proc/%d/fd\", pid);\n  dirstr = malloc(strlen(path_buffer) + 1);\n  strcpy(dirstr, path_buffer);\n  dirstream = opendir(dirstr);\n\n  if (dirstream == NULL) {\n    free(dirstr);\n    return NULL;\n  }\n\n  while (path == NULL && (dent = readdir(dirstream)) != NULL) {\n    snprintf(path_buffer, (PATH_MAX + 1), \"%s/%s\", dirstr, dent->d_name);\n    if (stat(path_buffer, &sb) == -1)\n      continue;\n\n    if (sb.st_ino == inum) {\n      char *pid_fd_path = malloc(strlen(path_buffer) + 1);\n      strcpy(pid_fd_path, path_buffer);\n      path = pid_fd_path;\n    }\n  }\n  closedir(dirstream);\n  free(dirstr);\n\n  return path;\n}", "path": "bcc/src/cc/bcc_proc.c", "commit_date": "2019-07-23 00:00:00", "repo_name": "iovisor/bcc", "stars": 19046, "license": "apache-2.0", "language": "c", "size": 20430}
{"docstring": "/* hope for the best */\n", "func_signal": "static int\ndump_hash_iter(int map_fd, void *keys, __u32 key_size,\n\t       void *values, __u32 value_size, __u32 *count,\n\t       void *invalid_key)", "code": "{\n\t__u8 key[key_size], next_key[key_size];\n\t__u32 n = 0;\n\tint err;\n\n\t/* First get keys */\n\t__builtin_memcpy(key, invalid_key, key_size);\n\twhile (n < *count) {\n\t\terr = bpf_map_get_next_key(map_fd, key, next_key);\n\t\tif (err && errno != ENOENT) {\n\t\t\treturn -1;\n\t\t} else if (err) {\n\t\t\tbreak;\n\t\t}\n\t\t__builtin_memcpy(key, next_key, key_size);\n\t\t__builtin_memcpy(keys + key_size * n, next_key, key_size);\n\t\tn++;\n\t}\n\n\t/* Now read values */\n\tfor (int i = 0; i < n; i++) {\n\t\terr = bpf_map_lookup_elem(map_fd, keys + key_size * i,\n\t\t\t\t\t  values + value_size * i);\n\t\tif (err)\n\t\t\treturn -1;\n\t}\n\n\t*count = n;\n\treturn 0;\n}", "path": "bcc/libbpf-tools/map_helpers.c", "commit_date": "2020-07-09 00:00:00", "repo_name": "iovisor/bcc", "stars": 19046, "license": "apache-2.0", "language": "c", "size": 20430}
{"docstring": "// The first argument to the user space function we are tracing\n// is a pointer to the mutex M held by thread T.\n//\n// mutexes_held[T].remove(M)\n", "func_signal": "int trace_mutex_release(struct pt_regs *ctx, void *mutex_addr)", "code": "{\n  // Higher 32 bits is process ID, Lower 32 bits is thread ID\n  u32 pid = bpf_get_current_pid_tgid();\n  u64 mutex = (u64)mutex_addr;\n\n  struct thread_to_held_mutex_leaf_t *leaf =\n      thread_to_held_mutexes.lookup(&pid);\n  if (!leaf) {\n    // If the leaf does not exist for the pid, then it means we either missed\n    // the acquire event, or we had no more memory and could not add it.\n    bpf_trace_printk(\n        \"could not find thread_to_held_mutex, thread: %d, mutex: %p\\n\", pid,\n        mutex);\n    return 1;\n  }\n\n  // For older kernels without \"Bpf: allow access into map value arrays\"\n  // (https://lkml.org/lkml/2016/8/30/287) the bpf verifier will fail with an\n  // invalid memory access on `leaf->held_mutexes[i]` below. On newer kernels,\n  // we can avoid making this extra copy in `value` and use `leaf` directly.\n  struct thread_to_held_mutex_leaf_t value = {};\n  bpf_probe_read_user(&value, sizeof(struct thread_to_held_mutex_leaf_t), leaf);\n\n  #pragma unroll\n  for (int i = 0; i < MAX_HELD_MUTEXES; ++i) {\n    // Find the current mutex (if it exists), and clear it.\n    // Note: Can't use `leaf->` in this if condition, see comment above.\n    if (value.held_mutexes[i].mutex == mutex) {\n      leaf->held_mutexes[i].mutex = 0;\n      leaf->held_mutexes[i].stack_id = 0;\n    }\n  }\n\n  return 0;\n}", "path": "bcc/tools/deadlock.c", "commit_date": "2020-05-25 00:00:00", "repo_name": "iovisor/bcc", "stars": 19046, "license": "apache-2.0", "language": "c", "size": 20430}
{"docstring": "// return: 0 -> callback returned < 0, stopped iterating\n//        -1 -> callback never indicated to stop\n", "func_signal": "int _procfs_maps_each_module(FILE *procmap, int pid,\n                             bcc_procutils_modulecb callback, void *payload)", "code": "{\n  char buf[PATH_MAX + 1], perm[5];\n  char *name;\n  mod_info mod;\n  uint8_t enter_ns;\n  while (true) {\n    enter_ns = 1;\n    buf[0] = '\\0';\n    // From fs/proc/task_mmu.c:show_map_vma\n    if (fscanf(procmap, \"%lx-%lx %4s %llx %lx:%lx %lu%[^\\n]\",\n          &mod.start_addr, &mod.end_addr, perm, &mod.file_offset,\n          &mod.dev_major, &mod.dev_minor, &mod.inode, buf) != 8)\n      break;\n\n    if (perm[2] != 'x')\n      continue;\n\n    name = buf;\n    while (isspace(*name))\n      name++;\n    mod.name = name;\n    if (!bcc_mapping_is_file_backed(name))\n      continue;\n\n    if (strstr(name, \"/memfd:\")) {\n      char *memfd_name = _procutils_memfd_path(pid, mod.inode);\n      if (memfd_name != NULL) {\n        strcpy(buf, memfd_name);\n        free(memfd_name);\n        mod.name = buf;\n        enter_ns = 0;\n      }\n    }\n\n    if (callback(&mod, enter_ns, payload) < 0)\n      return 0;\n  }\n\n  return -1;\n}", "path": "bcc/src/cc/bcc_proc.c", "commit_date": "2019-07-23 00:00:00", "repo_name": "iovisor/bcc", "stars": 19046, "license": "apache-2.0", "language": "c", "size": 20430}
{"docstring": "// Parse the inner frame, whatever it may be. If it is ipv4, add the inner\n// source/dest ip to the key, for finer grained stats\n", "func_signal": "int handle_inner(struct __sk_buff *skb)", "code": "{\n  int is_ingress = skb->cb[CB_FLAGS] & IS_INGRESS;\n  struct ipkey key = {\n    .vni=skb->cb[CB_VNI],\n    .outer_sip = skb->cb[CB_SIP],\n    .outer_dip = skb->cb[CB_DIP]\n  };\n  u8 *cursor = (u8 *)(u64)skb->cb[CB_OFFSET];\n\n  struct ethernet_t *ethernet = cursor_advance(cursor, sizeof(*ethernet));\n  switch (ethernet->type) {\n    case 0x0800: goto ip;\n    default: goto finish;\n  }\nip: ;\n  struct ip_t *ip = cursor_advance(cursor, sizeof(*ip));\n  key.inner_sip = ip->src;\n  key.inner_dip = ip->dst;\n\nfinish:\n  // consistent ordering\n  if (key.outer_dip < key.outer_sip)\n    swap_ipkey(&key);\n  struct counters zleaf = {0};\n  struct counters *leaf = stats.lookup_or_try_init(&key, &zleaf);\n  if (leaf) {\n    if (is_ingress) {\n      lock_xadd(&leaf->rx_pkts, 1);\n      lock_xadd(&leaf->rx_bytes, skb->len);\n    } else {\n      lock_xadd(&leaf->tx_pkts, 1);\n      lock_xadd(&leaf->tx_bytes, skb->len);\n    }\n  }\n  return 1;\n}", "path": "bcc/examples/networking/tunnel_monitor/monitor.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "iovisor/bcc", "stars": 19046, "license": "apache-2.0", "language": "c", "size": 20430}
{"docstring": "/**\n * @brief Helper method to filter based on the specified inputString.\n * @param inputString The operation input string to check against the filter.\n * @return True if the specified inputString starts with the hard-coded FILTER_STRING; otherwise, false.\n */\n", "func_signal": "static inline bool filter(char const* inputString)", "code": "{\n    char needle[] = \"FILTER_STRING\"; ///< The FILTER STRING is replaced by python code.\n    char haystack[sizeof(needle)] = {};\n    bpf_probe_read_user(&haystack, sizeof(haystack), (void*)inputString);\n    for (int i = 0; i < sizeof(needle) - 1; ++i) {\n        if (needle[i] != haystack[i]) {\n            return false;\n        }\n    }\n    return true;\n}", "path": "bcc/examples/usdt_sample/scripts/bpf_text_shared.c", "commit_date": "2020-05-25 00:00:00", "repo_name": "iovisor/bcc", "stars": 19046, "license": "apache-2.0", "language": "c", "size": 20430}
{"docstring": "// helper func to swap two memory locations\n", "func_signal": "static inline\nvoid swap32(u32 *a, u32 *b)", "code": "{\n  u32 t = *a;\n  *a = *b;\n  *b = t;\n}", "path": "bcc/examples/networking/tunnel_monitor/monitor.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "iovisor/bcc", "stars": 19046, "license": "apache-2.0", "language": "c", "size": 20430}
{"docstring": "// initial handler for each packet on an egress tc filter\n", "func_signal": "int handle_egress(struct __sk_buff *skb)", "code": "{\n  skb->cb[CB_FLAGS] = 0;\n  parser.call(skb, 1);  // jump to generic packet parser\n  return 1;\n}", "path": "bcc/examples/networking/tunnel_monitor/monitor.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "iovisor/bcc", "stars": 19046, "license": "apache-2.0", "language": "c", "size": 20430}
{"docstring": "// The first argument to the user space function we are tracing\n// is a pointer to the mutex M held by thread T.\n//\n// For all mutexes N held by mutexes_held[T]\n//   add edge N => M (held by T)\n// mutexes_held[T].add(M)\n", "func_signal": "int trace_mutex_acquire(struct pt_regs *ctx, void *mutex_addr)", "code": "{\n  // Higher 32 bits is process ID, Lower 32 bits is thread ID\n  u32 pid = bpf_get_current_pid_tgid();\n  u64 mutex = (u64)mutex_addr;\n\n  struct thread_to_held_mutex_leaf_t empty_leaf = {};\n  struct thread_to_held_mutex_leaf_t *leaf =\n      thread_to_held_mutexes.lookup_or_try_init(&pid, &empty_leaf);\n  if (!leaf) {\n    bpf_trace_printk(\n        \"could not add thread_to_held_mutex key, thread: %d, mutex: %p\\n\", pid,\n        mutex);\n    return 1; // Could not insert, no more memory\n  }\n\n  // Recursive mutexes lock the same mutex multiple times. We cannot tell if\n  // the mutex is recursive after the mutex is already created. To avoid noisy\n  // reports, disallow self edges. Do one pass to check if we are already\n  // holding the mutex, and if we are, do nothing.\n  #pragma unroll\n  for (int i = 0; i < MAX_HELD_MUTEXES; ++i) {\n    if (leaf->held_mutexes[i].mutex == mutex) {\n      return 1; // Disallow self edges\n    }\n  }\n\n  u64 stack_id =\n      stack_traces.get_stackid(ctx, BPF_F_USER_STACK);\n\n  int added_mutex = 0;\n  #pragma unroll\n  for (int i = 0; i < MAX_HELD_MUTEXES; ++i) {\n    // If this is a free slot, see if we can insert.\n    if (!leaf->held_mutexes[i].mutex) {\n      if (!added_mutex) {\n        leaf->held_mutexes[i].mutex = mutex;\n        leaf->held_mutexes[i].stack_id = stack_id;\n        added_mutex = 1;\n      }\n      continue; // Nothing to do for a free slot\n    }\n\n    // Add edges from held mutex => current mutex\n    struct edges_key_t edge_key = {};\n    edge_key.mutex1 = leaf->held_mutexes[i].mutex;\n    edge_key.mutex2 = mutex;\n\n    struct edges_leaf_t edge_leaf = {};\n    edge_leaf.mutex1_stack_id = leaf->held_mutexes[i].stack_id;\n    edge_leaf.mutex2_stack_id = stack_id;\n    edge_leaf.thread_pid = pid;\n    bpf_get_current_comm(&edge_leaf.comm, sizeof(edge_leaf.comm));\n\n    // Returns non-zero on error\n    int result = edges.update(&edge_key, &edge_leaf);\n    if (result) {\n      bpf_trace_printk(\"could not add edge key %p, %p, error: %d\\n\",\n                       edge_key.mutex1, edge_key.mutex2, result);\n      continue; // Could not insert, no more memory\n    }\n  }\n\n  // There were no free slots for this mutex.\n  if (!added_mutex) {\n    bpf_trace_printk(\"could not add mutex %p, added_mutex: %d\\n\", mutex,\n                     added_mutex);\n    return 1;\n  }\n  return 0;\n}", "path": "bcc/tools/deadlock.c", "commit_date": "2020-05-25 00:00:00", "repo_name": "iovisor/bcc", "stars": 19046, "license": "apache-2.0", "language": "c", "size": 20430}
{"docstring": "/*\n * Spawn the transfer tasks and then wait for them. Returns 0 on success,\n * -1 on failure.\n */\n", "func_signal": "static int tloop_spawnwait_tasks(struct bidirectional_transfer_state *s)", "code": "{\n\tpid_t pid1, pid2;\n\tint ret = 0;\n\n\t/* Fork thread #1: git to program. */\n\tpid1 = fork();\n\tif (pid1 < 0)\n\t\tdie_errno(_(\"can't start thread for copying data\"));\n\telse if (pid1 == 0) {\n\t\tudt_kill_transfer(&s->ptg);\n\t\texit(udt_copy_task_routine(&s->gtp) ? 0 : 1);\n\t}\n\n\t/* Fork thread #2: program to git. */\n\tpid2 = fork();\n\tif (pid2 < 0)\n\t\tdie_errno(_(\"can't start thread for copying data\"));\n\telse if (pid2 == 0) {\n\t\tudt_kill_transfer(&s->gtp);\n\t\texit(udt_copy_task_routine(&s->ptg) ? 0 : 1);\n\t}\n\n\t/*\n\t * Close both streams in parent as to not interfere with\n\t * end of file detection and wait for both tasks to finish.\n\t */\n\tudt_kill_transfer(&s->gtp);\n\tudt_kill_transfer(&s->ptg);\n\tret |= tloop_join(pid1, \"Git to program copy\");\n\tret |= tloop_join(pid2, \"Program to git copy\");\n\treturn ret;\n}", "path": "git/transport-helper.c", "commit_date": "2020-10-03 00:00:00", "repo_name": "git/git", "stars": 49044, "license": "other", "language": "c", "size": 243775}
{"docstring": "/*\n * Join process, with appropriate errors on failure. Name is name for the\n * process (for error messages). Returns 0 on success, 1 on failure.\n */\n", "func_signal": "static int tloop_join(pid_t pid, const char *name)", "code": "{\n\tint tret;\n\tif (waitpid(pid, &tret, 0) < 0) {\n\t\terror_errno(_(\"%s process failed to wait\"), name);\n\t\treturn 1;\n\t}\n\tif (!WIFEXITED(tret) || WEXITSTATUS(tret)) {\n\t\terror(_(\"%s process failed\"), name);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "path": "git/transport-helper.c", "commit_date": "2020-10-03 00:00:00", "repo_name": "git/git", "stars": 49044, "license": "other", "language": "c", "size": 243775}
{"docstring": "/*\n * Tries to read data from source into buffer. If buffer is full,\n * no data is read. Returns 0 on success, -1 on error.\n */\n", "func_signal": "static int udt_do_read(struct unidirectional_transfer *t)", "code": "{\n\tssize_t bytes;\n\n\tif (t->bufuse == BUFFERSIZE)\n\t\treturn 0;\t/* No space for more. */\n\n\ttransfer_debug(\"%s is readable\", t->src_name);\n\tbytes = xread(t->src, t->buf + t->bufuse, BUFFERSIZE - t->bufuse);\n\tif (bytes < 0) {\n\t\terror_errno(_(\"read(%s) failed\"), t->src_name);\n\t\treturn -1;\n\t} else if (bytes == 0) {\n\t\ttransfer_debug(\"%s EOF (with %i bytes in buffer)\",\n\t\t\tt->src_name, (int)t->bufuse);\n\t\tt->state = SSTATE_FLUSHING;\n\t} else if (bytes > 0) {\n\t\tt->bufuse += bytes;\n\t\ttransfer_debug(\"Read %i bytes from %s (buffer now at %i)\",\n\t\t\t(int)bytes, t->src_name, (int)t->bufuse);\n\t}\n\treturn 0;\n}", "path": "git/transport-helper.c", "commit_date": "2020-10-03 00:00:00", "repo_name": "git/git", "stars": 49044, "license": "other", "language": "c", "size": 243775}
{"docstring": "/*\n * path contains a path that might be a symlink.\n *\n * If path is a symlink, attempt to overwrite it with a path to the\n * real file or directory (which may or may not exist), following a\n * chain of symlinks if necessary.  Otherwise, leave path unmodified.\n *\n * This is a best-effort routine.  If an error occurs, path will\n * either be left unmodified or will name a different symlink in a\n * symlink chain that started with the original path.\n */\n", "func_signal": "static void resolve_symlink(struct strbuf *path)", "code": "{\n\tint depth = MAXDEPTH;\n\tstatic struct strbuf link = STRBUF_INIT;\n\n\twhile (depth--) {\n\t\tif (strbuf_readlink(&link, path->buf, path->len) < 0)\n\t\t\tbreak;\n\n\t\tif (is_absolute_path(link.buf))\n\t\t\t/* absolute path simply replaces p */\n\t\t\tstrbuf_reset(path);\n\t\telse\n\t\t\t/*\n\t\t\t * link is a relative path, so replace the\n\t\t\t * last element of p with it.\n\t\t\t */\n\t\t\ttrim_last_path_component(path);\n\n\t\tstrbuf_addbuf(path, &link);\n\t}\n\tstrbuf_reset(&link);\n}", "path": "git/lockfile.c", "commit_date": "2020-04-27 00:00:00", "repo_name": "git/git", "stars": 49044, "license": "other", "language": "c", "size": 243775}
{"docstring": "/*\n * Join thread, with appropriate errors on failure. Name is name for the\n * thread (for error messages). Returns 0 on success, 1 on failure.\n */\n", "func_signal": "static int tloop_join(pthread_t thread, const char *name)", "code": "{\n\tint err;\n\tvoid *tret;\n\terr = pthread_join(thread, &tret);\n\tif (!tret) {\n\t\terror(_(\"%s thread failed\"), name);\n\t\treturn 1;\n\t}\n\tif (err) {\n\t\terror(_(\"%s thread failed to join: %s\"), name, strerror(err));\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "path": "git/transport-helper.c", "commit_date": "2020-10-03 00:00:00", "repo_name": "git/git", "stars": 49044, "license": "other", "language": "c", "size": 243775}
{"docstring": "/*\n * Attempt to resolve and set the provided 'gitdir' for repository 'repo'.\n * Return 0 upon success and a non-zero value upon failure.\n */\n", "func_signal": "static int repo_init_gitdir(struct repository *repo, const char *gitdir)", "code": "{\n\tint ret = 0;\n\tint error = 0;\n\tchar *abspath = NULL;\n\tconst char *resolved_gitdir;\n\tstruct set_gitdir_args args = { NULL };\n\n\tabspath = real_pathdup(gitdir, 0);\n\tif (!abspath) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t/* 'gitdir' must reference the gitdir directly */\n\tresolved_gitdir = resolve_gitdir_gently(abspath, &error);\n\tif (!resolved_gitdir) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\trepo_set_gitdir(repo, resolved_gitdir, &args);\n\nout:\n\tfree(abspath);\n\treturn ret;\n}", "path": "git/repository.c", "commit_date": "2020-07-30 00:00:00", "repo_name": "git/git", "stars": 49044, "license": "other", "language": "c", "size": 243775}
{"docstring": "/* This should return a meaningful errno on failure */\n", "func_signal": "int hold_lock_file_for_update_timeout_mode(struct lock_file *lk,\n\t\t\t\t\t   const char *path, int flags,\n\t\t\t\t\t   long timeout_ms, int mode)", "code": "{\n\tint fd = lock_file_timeout(lk, path, flags, timeout_ms, mode);\n\tif (fd < 0) {\n\t\tif (flags & LOCK_DIE_ON_ERROR)\n\t\t\tunable_to_lock_die(path, errno);\n\t\tif (flags & LOCK_REPORT_ON_ERROR) {\n\t\t\tstruct strbuf buf = STRBUF_INIT;\n\t\t\tunable_to_lock_message(path, errno, &buf);\n\t\t\terror(\"%s\", buf.buf);\n\t\t\tstrbuf_release(&buf);\n\t\t}\n\t}\n\treturn fd;\n}", "path": "git/lockfile.c", "commit_date": "2020-04-27 00:00:00", "repo_name": "git/git", "stars": 49044, "license": "other", "language": "c", "size": 243775}
{"docstring": "/*\n * Try locking path, retrying with quadratic backoff for at least\n * timeout_ms milliseconds. If timeout_ms is 0, try locking the file\n * exactly once. If timeout_ms is -1, try indefinitely.\n */\n", "func_signal": "static int lock_file_timeout(struct lock_file *lk, const char *path,\n\t\t\t     int flags, long timeout_ms, int mode)", "code": "{\n\tint n = 1;\n\tint multiplier = 1;\n\tlong remaining_ms = 0;\n\tstatic int random_initialized = 0;\n\n\tif (timeout_ms == 0)\n\t\treturn lock_file(lk, path, flags, mode);\n\n\tif (!random_initialized) {\n\t\tsrand((unsigned int)getpid());\n\t\trandom_initialized = 1;\n\t}\n\n\tif (timeout_ms > 0)\n\t\tremaining_ms = timeout_ms;\n\n\twhile (1) {\n\t\tlong backoff_ms, wait_ms;\n\t\tint fd;\n\n\t\tfd = lock_file(lk, path, flags, mode);\n\n\t\tif (fd >= 0)\n\t\t\treturn fd; /* success */\n\t\telse if (errno != EEXIST)\n\t\t\treturn -1; /* failure other than lock held */\n\t\telse if (timeout_ms > 0 && remaining_ms <= 0)\n\t\t\treturn -1; /* failure due to timeout */\n\n\t\tbackoff_ms = multiplier * INITIAL_BACKOFF_MS;\n\t\t/* back off for between 0.75*backoff_ms and 1.25*backoff_ms */\n\t\twait_ms = (750 + rand() % 500) * backoff_ms / 1000;\n\t\tsleep_millisec(wait_ms);\n\t\tremaining_ms -= wait_ms;\n\n\t\t/* Recursion: (n+1)^2 = n^2 + 2n + 1 */\n\t\tmultiplier += 2*n + 1;\n\t\tif (multiplier > BACKOFF_MAX_MULTIPLIER)\n\t\t\tmultiplier = BACKOFF_MAX_MULTIPLIER;\n\t\telse\n\t\t\tn++;\n\t}\n}", "path": "git/lockfile.c", "commit_date": "2020-04-27 00:00:00", "repo_name": "git/git", "stars": 49044, "license": "other", "language": "c", "size": 243775}
{"docstring": "/* Print bidirectional transfer loop debug message. */\n", "func_signal": "__attribute__((format (printf, 1, 2)))\nstatic void transfer_debug(const char *fmt, ...)", "code": "{\n\t/*\n\t * NEEDSWORK: This function is sometimes used from multiple threads, and\n\t * we end up using debug_enabled racily. That \"should not matter\" since\n\t * we always write the same value, but it's still wrong. This function\n\t * is listed in .tsan-suppressions for the time being.\n\t */\n\n\tva_list args;\n\tchar msgbuf[PBUFFERSIZE];\n\tstatic int debug_enabled = -1;\n\n\tif (debug_enabled < 0)\n\t\tdebug_enabled = getenv(\"GIT_TRANSLOOP_DEBUG\") ? 1 : 0;\n\tif (!debug_enabled)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(msgbuf, PBUFFERSIZE, fmt, args);\n\tva_end(args);\n\tfprintf(stderr, \"Transfer loop debugging: %s\\n\", msgbuf);\n}", "path": "git/transport-helper.c", "commit_date": "2020-10-03 00:00:00", "repo_name": "git/git", "stars": 49044, "license": "other", "language": "c", "size": 243775}
{"docstring": "/*\n * path = absolute or relative path name\n *\n * Remove the last path name element from path (leaving the preceding\n * \"/\", if any).  If path is empty or the root directory (\"/\"), set\n * path to the empty string.\n */\n", "func_signal": "static void trim_last_path_component(struct strbuf *path)", "code": "{\n\tint i = path->len;\n\n\t/* back up past trailing slashes, if any */\n\twhile (i && path->buf[i - 1] == '/')\n\t\ti--;\n\n\t/*\n\t * then go backwards until a slash, or the beginning of the\n\t * string\n\t */\n\twhile (i && path->buf[i - 1] != '/')\n\t\ti--;\n\n\tstrbuf_setlen(path, i);\n}", "path": "git/lockfile.c", "commit_date": "2020-04-27 00:00:00", "repo_name": "git/git", "stars": 49044, "license": "other", "language": "c", "size": 243775}
{"docstring": "/* Close the source and target (for writing) for transfer. */\n", "func_signal": "static void udt_kill_transfer(struct unidirectional_transfer *t)", "code": "{\n\tt->state = SSTATE_FINISHED;\n\t/*\n\t * Socket read end left open isn't a disaster if nobody\n\t * attempts to read from it (mingw compat headers do not\n\t * have SHUT_RD)...\n\t *\n\t * We can't fully close the socket since otherwise gtp\n\t * task would first close the socket it sends data to\n\t * while closing the ptg file descriptors.\n\t */\n\tif (!t->src_is_sock)\n\t\tclose(t->src);\n\tif (t->dest_is_sock)\n\t\tshutdown(t->dest, SHUT_WR);\n\telse\n\t\tclose(t->dest);\n}", "path": "git/transport-helper.c", "commit_date": "2020-10-03 00:00:00", "repo_name": "git/git", "stars": 49044, "license": "other", "language": "c", "size": 243775}
{"docstring": "/*\n * Copies data from stdin to output and from input to stdout simultaneously.\n * Additionally filtering through given filter. If filter is NULL, uses\n * identity filter.\n */\n", "func_signal": "int bidirectional_transfer_loop(int input, int output)", "code": "{\n\tstruct bidirectional_transfer_state state;\n\n\t/* Fill the state fields. */\n\tstate.ptg.src = input;\n\tstate.ptg.dest = 1;\n\tstate.ptg.src_is_sock = (input == output);\n\tstate.ptg.dest_is_sock = 0;\n\tstate.ptg.state = SSTATE_TRANSFERRING;\n\tstate.ptg.bufuse = 0;\n\tstate.ptg.src_name = \"remote input\";\n\tstate.ptg.dest_name = \"stdout\";\n\n\tstate.gtp.src = 0;\n\tstate.gtp.dest = output;\n\tstate.gtp.src_is_sock = 0;\n\tstate.gtp.dest_is_sock = (input == output);\n\tstate.gtp.state = SSTATE_TRANSFERRING;\n\tstate.gtp.bufuse = 0;\n\tstate.gtp.src_name = \"stdin\";\n\tstate.gtp.dest_name = \"remote output\";\n\n\treturn tloop_spawnwait_tasks(&state);\n}", "path": "git/transport-helper.c", "commit_date": "2020-10-03 00:00:00", "repo_name": "git/git", "stars": 49044, "license": "other", "language": "c", "size": 243775}
{"docstring": "/* Make sure errno contains a meaningful value on error */\n", "func_signal": "static int lock_file(struct lock_file *lk, const char *path, int flags,\n\t\t     int mode)", "code": "{\n\tstruct strbuf filename = STRBUF_INIT;\n\n\tstrbuf_addstr(&filename, path);\n\tif (!(flags & LOCK_NO_DEREF))\n\t\tresolve_symlink(&filename);\n\n\tstrbuf_addstr(&filename, LOCK_SUFFIX);\n\tlk->tempfile = create_tempfile_mode(filename.buf, mode);\n\tstrbuf_release(&filename);\n\treturn lk->tempfile ? lk->tempfile->fd : -1;\n}", "path": "git/lockfile.c", "commit_date": "2020-04-27 00:00:00", "repo_name": "git/git", "stars": 49044, "license": "other", "language": "c", "size": 243775}
{"docstring": "/* Closes the target (for writing) if transfer has finished. */\n", "func_signal": "static void udt_close_if_finished(struct unidirectional_transfer *t)", "code": "{\n\tif (STATE_NEEDS_CLOSING(t->state) && !t->bufuse) {\n\t\tt->state = SSTATE_FINISHED;\n\t\tif (t->dest_is_sock)\n\t\t\tshutdown(t->dest, SHUT_WR);\n\t\telse\n\t\t\tclose(t->dest);\n\t\ttransfer_debug(\"Closed %s.\", t->dest_name);\n\t}\n}", "path": "git/transport-helper.c", "commit_date": "2020-10-03 00:00:00", "repo_name": "git/git", "stars": 49044, "license": "other", "language": "c", "size": 243775}
{"docstring": "/*\n * off is the offset of the first different character in the two strings\n * s1 and s2. If either s1 or s2 contains a prerelease suffix containing\n * that offset or a suffix ends right before that offset, then that\n * string will be forced to be on top.\n *\n * If both s1 and s2 contain a (different) suffix around that position,\n * their order is determined by the order of those two suffixes in the\n * configuration.\n * If any of the strings contains more than one different suffixes around\n * that position, then that string is sorted according to the contained\n * suffix which starts at the earliest offset in that string.\n * If more than one different contained suffixes start at that earliest\n * offset, then that string is sorted according to the longest of those\n * suffixes.\n *\n * Return non-zero if *diff contains the return value for versioncmp()\n */\n", "func_signal": "static int swap_prereleases(const char *s1,\n\t\t\t    const char *s2,\n\t\t\t    int off,\n\t\t\t    int *diff)", "code": "{\n\tint i;\n\tstruct suffix_match match1 = { -1, off, -1 };\n\tstruct suffix_match match2 = { -1, off, -1 };\n\n\tfor (i = 0; i < prereleases->nr; i++) {\n\t\tconst char *suffix = prereleases->items[i].string;\n\t\tint start, suffix_len = strlen(suffix);\n\t\tif (suffix_len < off)\n\t\t\tstart = off - suffix_len;\n\t\telse\n\t\t\tstart = 0;\n\t\tfind_better_matching_suffix(s1, suffix, suffix_len, start,\n\t\t\t\t\t    i, &match1);\n\t\tfind_better_matching_suffix(s2, suffix, suffix_len, start,\n\t\t\t\t\t    i, &match2);\n\t}\n\tif (match1.conf_pos == -1 && match2.conf_pos == -1)\n\t\treturn 0;\n\tif (match1.conf_pos == match2.conf_pos)\n\t\t/* Found the same suffix in both, e.g. \"-rc\" in \"v1.0-rcX\"\n\t\t * and \"v1.0-rcY\": the caller should decide based on \"X\"\n\t\t * and \"Y\". */\n\t\treturn 0;\n\n\tif (match1.conf_pos >= 0 && match2.conf_pos >= 0)\n\t\t*diff = match1.conf_pos - match2.conf_pos;\n\telse if (match1.conf_pos >= 0)\n\t\t*diff = -1;\n\telse /* if (match2.conf_pos >= 0) */\n\t\t*diff = 1;\n\treturn 1;\n}", "path": "git/versioncmp.c", "commit_date": "2017-06-15 00:00:00", "repo_name": "git/git", "stars": 49044, "license": "other", "language": "c", "size": 243775}
{"docstring": "/*\n * This function marks a rev and its ancestors as common.\n * In some cases, it is desirable to mark only the ancestors (for example\n * when only the server does not yet know that they are common).\n */\n", "func_signal": "static void mark_common(struct negotiation_state *ns, struct commit *commit,\n\t\tint ancestors_only, int dont_parse)", "code": "{\n\tif (commit != NULL && !(commit->object.flags & COMMON)) {\n\t\tstruct object *o = (struct object *)commit;\n\n\t\tif (!ancestors_only)\n\t\t\to->flags |= COMMON;\n\n\t\tif (!(o->flags & SEEN))\n\t\t\trev_list_push(ns, commit, SEEN);\n\t\telse {\n\t\t\tstruct commit_list *parents;\n\n\t\t\tif (!ancestors_only && !(o->flags & POPPED))\n\t\t\t\tns->non_common_revs--;\n\t\t\tif (!o->parsed && !dont_parse)\n\t\t\t\tif (parse_commit(commit))\n\t\t\t\t\treturn;\n\n\t\t\tfor (parents = commit->parents;\n\t\t\t\t\tparents;\n\t\t\t\t\tparents = parents->next)\n\t\t\t\tmark_common(ns, parents->item, 0,\n\t\t\t\t\t    dont_parse);\n\t\t}\n\t}\n}", "path": "git/negotiator/default.c", "commit_date": "2018-08-02 00:00:00", "repo_name": "git/git", "stars": 49044, "license": "other", "language": "c", "size": 243775}
{"docstring": "/* Tries to write data from buffer into destination. If buffer is empty,\n * no data is written. Returns 0 on success, -1 on error.\n */\n", "func_signal": "static int udt_do_write(struct unidirectional_transfer *t)", "code": "{\n\tssize_t bytes;\n\n\tif (t->bufuse == 0)\n\t\treturn 0;\t/* Nothing to write. */\n\n\ttransfer_debug(\"%s is writable\", t->dest_name);\n\tbytes = xwrite(t->dest, t->buf, t->bufuse);\n\tif (bytes < 0) {\n\t\terror_errno(_(\"write(%s) failed\"), t->dest_name);\n\t\treturn -1;\n\t} else if (bytes > 0) {\n\t\tt->bufuse -= bytes;\n\t\tif (t->bufuse)\n\t\t\tmemmove(t->buf, t->buf + bytes, t->bufuse);\n\t\ttransfer_debug(\"Wrote %i bytes to %s (buffer now at %i)\",\n\t\t\t(int)bytes, t->dest_name, (int)t->bufuse);\n\t}\n\treturn 0;\n}", "path": "git/transport-helper.c", "commit_date": "2020-10-03 00:00:00", "repo_name": "git/git", "stars": 49044, "license": "other", "language": "c", "size": 243775}
{"docstring": "/*\n * Get the next rev to send, ignoring the common.\n */\n", "func_signal": "static const struct object_id *get_rev(struct negotiation_state *ns)", "code": "{\n\tstruct commit *commit = NULL;\n\n\twhile (commit == NULL) {\n\t\tunsigned int mark;\n\t\tstruct commit_list *parents;\n\n\t\tif (ns->rev_list.nr == 0 || ns->non_common_revs == 0)\n\t\t\treturn NULL;\n\n\t\tcommit = prio_queue_get(&ns->rev_list);\n\t\tparse_commit(commit);\n\t\tparents = commit->parents;\n\n\t\tcommit->object.flags |= POPPED;\n\t\tif (!(commit->object.flags & COMMON))\n\t\t\tns->non_common_revs--;\n\n\t\tif (commit->object.flags & COMMON) {\n\t\t\t/* do not send \"have\", and ignore ancestors */\n\t\t\tcommit = NULL;\n\t\t\tmark = COMMON | SEEN;\n\t\t} else if (commit->object.flags & COMMON_REF)\n\t\t\t/* send \"have\", and ignore ancestors */\n\t\t\tmark = COMMON | SEEN;\n\t\telse\n\t\t\t/* send \"have\", also for its ancestors */\n\t\t\tmark = SEEN;\n\n\t\twhile (parents) {\n\t\t\tif (!(parents->item->object.flags & SEEN))\n\t\t\t\trev_list_push(ns, parents->item, mark);\n\t\t\tif (mark & COMMON)\n\t\t\t\tmark_common(ns, parents->item, 1, 0);\n\t\t\tparents = parents->next;\n\t\t}\n\t}\n\n\treturn &commit->object.oid;\n}", "path": "git/negotiator/default.c", "commit_date": "2018-08-02 00:00:00", "repo_name": "git/git", "stars": 49044, "license": "other", "language": "c", "size": 243775}
{"docstring": "/*\n * Spawn the transfer tasks and then wait for them. Returns 0 on success,\n * -1 on failure.\n */\n", "func_signal": "static int tloop_spawnwait_tasks(struct bidirectional_transfer_state *s)", "code": "{\n\tpthread_t gtp_thread;\n\tpthread_t ptg_thread;\n\tint err;\n\tint ret = 0;\n\terr = pthread_create(&gtp_thread, NULL, udt_copy_task_routine,\n\t\t&s->gtp);\n\tif (err)\n\t\tdie(_(\"can't start thread for copying data: %s\"), strerror(err));\n\terr = pthread_create(&ptg_thread, NULL, udt_copy_task_routine,\n\t\t&s->ptg);\n\tif (err)\n\t\tdie(_(\"can't start thread for copying data: %s\"), strerror(err));\n\n\tret |= tloop_join(gtp_thread, \"Git to program copy\");\n\tret |= tloop_join(ptg_thread, \"Program to git copy\");\n\treturn ret;\n}", "path": "git/transport-helper.c", "commit_date": "2020-10-03 00:00:00", "repo_name": "git/git", "stars": 49044, "license": "other", "language": "c", "size": 243775}
{"docstring": "/*\n * Initialize 'repo' based on the provided 'gitdir'.\n * Return 0 upon success and a non-zero value upon failure.\n */\n", "func_signal": "int repo_init(struct repository *repo,\n\t      const char *gitdir,\n\t      const char *worktree)", "code": "{\n\tstruct repository_format format = REPOSITORY_FORMAT_INIT;\n\tmemset(repo, 0, sizeof(*repo));\n\n\trepo->objects = raw_object_store_new();\n\trepo->parsed_objects = parsed_object_pool_new();\n\n\tif (repo_init_gitdir(repo, gitdir))\n\t\tgoto error;\n\n\tif (read_and_verify_repository_format(&format, repo->commondir))\n\t\tgoto error;\n\n\trepo_set_hash_algo(repo, format.hash_algo);\n\n\tif (worktree)\n\t\trepo_set_worktree(repo, worktree);\n\n\tclear_repository_format(&format);\n\treturn 0;\n\nerror:\n\trepo_clear(repo);\n\treturn -1;\n}", "path": "git/repository.c", "commit_date": "2020-07-30 00:00:00", "repo_name": "git/git", "stars": 49044, "license": "other", "language": "c", "size": 243775}
{"docstring": "// Generate a cyclic pattern of desired size, and charset, return with starting\n// offset of start.\n// The returned string is malloced, and it is the responsibility of the caller\n// to free the memory.\n", "func_signal": "R_API char* r_debruijn_pattern(int size, int start, const char* charset)", "code": "{\n\tchar *pat, *pat2;\n\tut64 len;\n\tif (!charset) {\n\t\tcharset = debruijn_charset;\n\t}\n\tif (start >= size) {\n\t\treturn (char*)NULL;\n\t}\n\tpat = de_bruijn (charset, 3 /*subsequence length*/, size);\n\tif (!pat) {\n\t\treturn NULL;\n\t}\n\tif (start == 0) {\n\t\tlen = strlen (pat);\n\t\tif (size != len) {\n\t\t\teprintf (\"warning: requested pattern of length %d, \"\n\t\t\t\t \"generated length %\"PFMT64d\"\\n\", size, len);\n\t\t}\n\t\treturn pat;\n\t}\n\tpat2 = calloc ((size - start) + 1, sizeof(char));\n\tif (!pat2) {\n\t\tfree (pat);\n\t\treturn NULL;\n\t}\n\tstrncpy (pat2, pat + start, size - start);\n\tpat2[size-start] = 0;\n\tfree (pat);\n\tlen = strlen (pat2);\n\tif (size != len) {\n\t\teprintf (\"warning: requested pattern of length %d, \"\n\t\t\t\t \"generated length %\"PFMT64d\"\\n\",\n\t\t\t\t size, len);\n\t}\n\treturn pat2;\n}", "path": "radare2/libr/util/debruijn.c", "commit_date": "2020-03-05 00:00:00", "repo_name": "radareorg/radare2", "stars": 19362, "license": "lgpl-3.0", "language": "c", "size": 169587}
{"docstring": "// Frees the bin_obj of the binary file\n", "func_signal": "static void destroy(RBinFile *bf)", "code": "{\n\tQnxObj *qo = bf->o->bin_obj;\n\tr_list_free (qo->sections);\n\tr_list_free (qo->fixups);\n\tbf->o->bin_obj = NULL;\n\tfree (qo);\n}", "path": "radare2/libr/bin/p/bin_qnx.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "radareorg/radare2", "stars": 19362, "license": "lgpl-3.0", "language": "c", "size": 169587}
{"docstring": "/* screen and input */\n", "func_signal": "R_API void bfvm_peek(BfvmCPU *c)", "code": "{\n\tint idx = c->input_idx;\n\tut8 *ptr = bfvm_get_ptr (c);\n\n\tif (idx >= c->input_size) {\n\t\tidx = 0;\n\t}\n\n\tif (ptr) {\n\t\t*ptr = c->input_buf[idx];\n\t\tc->input_idx = idx+1;\n\t}\n}", "path": "radare2/libr/debug/p/bfvm.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "radareorg/radare2", "stars": 19362, "license": "lgpl-3.0", "language": "c", "size": 169587}
{"docstring": "// Generate a De Bruijn sequence.\n", "func_signal": "static void de_bruijn_seq(int prenecklace_len_t, int lyndon_prefix_len_p, int order,\n\t\tint maxlen, int size, int* prenecklace_a, char* sequence, const char* charset)", "code": "{\n\tint j;\n\tif (!charset || !sequence || strlen (sequence) == maxlen) {\n\t\treturn;\n\t}\n\tif (prenecklace_len_t > order) {\n\t\tif (order % lyndon_prefix_len_p == 0) {\n\t\t\tfor (j = 1; j <= lyndon_prefix_len_p; j++) {\n\t\t\t\tsequence[strlen(sequence)] = charset[prenecklace_a[j]];\n\t\t\t\tif (strlen (sequence) == maxlen) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tprenecklace_a[prenecklace_len_t] =\n\t\t\tprenecklace_a[prenecklace_len_t - lyndon_prefix_len_p];\n\t\tde_bruijn_seq(prenecklace_len_t + 1, lyndon_prefix_len_p, order, maxlen,\n\t\t\t\tsize, prenecklace_a, sequence, charset);\n\t\tfor (j = prenecklace_a[prenecklace_len_t - lyndon_prefix_len_p] + 1;\n\t\t\t\tj < size; j++) {\n\t\t\tprenecklace_a[prenecklace_len_t] = j;\n\t\t\tde_bruijn_seq (prenecklace_len_t + 1, prenecklace_len_t, order, maxlen,\n\t\t\t\t\tsize, prenecklace_a, sequence, charset);\n\t\t}\n\t}\n}", "path": "radare2/libr/util/debruijn.c", "commit_date": "2020-03-05 00:00:00", "repo_name": "radareorg/radare2", "stars": 19362, "license": "lgpl-3.0", "language": "c", "size": 169587}
{"docstring": "/* return the address of the i-th instruction in the basicblock bb.\n * If the index of the instruction is not valid, it returns UT64_MAX */\n", "func_signal": "R_API ut64 r_anal_bb_opaddr_i(RAnalBlock *bb, int i)", "code": "{\n\tut16 offset = r_anal_bb_offset_inst (bb, i);\n\tif (offset == UT16_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\treturn bb->addr + offset;\n}", "path": "radare2/libr/anal/bb.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "radareorg/radare2", "stars": 19362, "license": "lgpl-3.0", "language": "c", "size": 169587}
{"docstring": "// Finds the offset of a given value in a cyclic pattern of an integer.\n", "func_signal": "R_API int r_debruijn_offset(ut64 value, bool is_big_endian)", "code": "{\n\tchar* needle, *pattern, buf[9];\n\tint retval = -1;\n\tchar* pch;\n\t// 0x10000 should be long enough. This is how peda works, and nobody complains\n\t// ... but is slow. Optimize for common case.\n\tint lens[2] = {0x1000, 0x10000};\n\tint j;\n\n\tif (value == 0) {\n\t\treturn -1;\n\t}\n\n\tfor (j = 0; j < 2 && retval == -1; j++) {\n\t\tpattern = r_debruijn_pattern (lens[j], 0, debruijn_charset);\n\n\t\tbuf[8] = '\\0';\n\t\tif (is_big_endian) {\n\t\t\tr_write_be64 (buf, value);\n\t\t} else {\n\t\t\tr_write_le64 (buf, value);\n\t\t}\n\t\tfor (needle = buf; !*needle; needle++) {\n\t\t\t/* do nothing here */\n\t\t}\n\n\t\tpch = strstr (pattern, needle);\n\n\t\tif (pch) {\n\t\t\tretval = (int)(size_t)(pch - pattern);\n\t\t}\n\t\tfree (pattern);\n\t}\n\treturn retval;\n}", "path": "radare2/libr/util/debruijn.c", "commit_date": "2020-03-05 00:00:00", "repo_name": "radareorg/radare2", "stars": 19362, "license": "lgpl-3.0", "language": "c", "size": 169587}
{"docstring": "/* lenp is 32 bit because converted comment can be longer than ZIP_UINT16_MAX */\n", "func_signal": "ZIP_EXTERN const char *\nzip_file_get_comment(struct zip *za, zip_uint64_t idx, zip_uint32_t *lenp, zip_flags_t flags)", "code": "{\n    struct zip_dirent *de;\n    zip_uint32_t len;\n    const zip_uint8_t *str;\n\n    if ((de=_zip_get_dirent(za, idx, flags, NULL)) == NULL)\n\treturn NULL;\n\n    if ((str=_zip_string_get(de->comment, &len, flags, &za->error)) == NULL)\n\treturn NULL;\n\n    if (lenp)\n\t*lenp = len;\n\n    return (const char *)str;\n}", "path": "radare2/shlr/zip/zip/zip_file_get_comment.c", "commit_date": "2013-11-14 00:00:00", "repo_name": "radareorg/radare2", "stars": 19362, "license": "lgpl-3.0", "language": "c", "size": 169587}
{"docstring": "/* return the offset of the i-th instruction in the basicblock bb.\n * If the index of the instruction is not valid, it returns UT16_MAX */\n", "func_signal": "R_API ut16 r_anal_bb_offset_inst(const RAnalBlock *bb, int i)", "code": "{\n\tif (i < 0 || i >= bb->ninstr) {\n\t\treturn UT16_MAX;\n\t}\n\treturn (i > 0 && (i - 1) < bb->op_pos_size)? bb->op_pos[i - 1]: 0;\n}", "path": "radare2/libr/anal/bb.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "radareorg/radare2", "stars": 19362, "license": "lgpl-3.0", "language": "c", "size": 169587}
{"docstring": "// returns the size of the i-th instruction in a basic block\n", "func_signal": "R_API ut64 r_anal_bb_size_i(RAnalBlock *bb, int i)", "code": "{\n\tif (i < 0 || i >= bb->ninstr) {\n\t\treturn UT64_MAX;\n\t}\n\tut16 idx_cur = r_anal_bb_offset_inst (bb, i);\n\tut16 idx_next = r_anal_bb_offset_inst (bb, i + 1);\n\treturn idx_next != UT16_MAX? idx_next - idx_cur: bb->size - idx_cur;\n}", "path": "radare2/libr/anal/bb.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "radareorg/radare2", "stars": 19362, "license": "lgpl-3.0", "language": "c", "size": 169587}
{"docstring": "/*\n * Provides the info about the binary file\n * @param RBinFile to extract the data from\n * @return RBinInfo file with the info\n */\n", "func_signal": "static RBinInfo *info(RBinFile *bf)", "code": "{\n\tr_return_val_if_fail (bf && bf->o && bf->o->bin_obj, NULL);\n\tRBinInfo *ret = R_NEW0 (RBinInfo);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->file = bf->file? strdup (bf->file): NULL;\n\tret->type = strdup (\"QNX Executable\");\n\tret->bclass = strdup (\"qnx\");\n\tret->machine = strdup (\"i386\");\n\tret->rclass = strdup (\"QNX\");\n\tret->arch = strdup (\"x86\");\n\tret->os = strdup (\"any\");\n\tret->subsystem = strdup (\"any\");\n\tret->lang = \"C/C++\";\n\tret->signature = true;\n\treturn ret;\n}", "path": "radare2/libr/bin/p/bin_qnx.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "radareorg/radare2", "stars": 19362, "license": "lgpl-3.0", "language": "c", "size": 169587}
{"docstring": "// Generate a De Bruijn sequence.\n// The returned string is malloced, and it is the responsibility of the caller\n// to free the memory.\n", "func_signal": "static char* de_bruijn(const char* charset, int order, int maxlen)", "code": "{\n\tif (!charset) {\n\t\treturn NULL;\n\t}\n\tint size = strlen (charset);\n\tint* prenecklace_a = calloc (size * order, sizeof (int));\n\tif (!prenecklace_a) {\n\t\treturn NULL;\n\t}\n\tchar* sequence = calloc (maxlen + 1, sizeof (char));\n\tif (!sequence) {\n\t\tfree (prenecklace_a);\n\t\treturn NULL;\n\t}\n\tde_bruijn_seq (1, 1, order, maxlen, size, prenecklace_a, sequence, charset);\n\tfree (prenecklace_a);\n\treturn sequence;\n}", "path": "radare2/libr/util/debruijn.c", "commit_date": "2020-03-05 00:00:00", "repo_name": "radareorg/radare2", "stars": 19362, "license": "lgpl-3.0", "language": "c", "size": 169587}
{"docstring": "/* returns the address of the basic block that contains addr or UT64_MAX if\n * there is no such basic block */\n", "func_signal": "R_API ut64 r_anal_get_bbaddr(RAnal *anal, ut64 addr)", "code": "{\n\tRAnalBlock *bb = r_anal_bb_from_offset (anal, addr);\n\treturn bb? bb->addr: UT64_MAX;\n}", "path": "radare2/libr/anal/bb.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "radareorg/radare2", "stars": 19362, "license": "lgpl-3.0", "language": "c", "size": 169587}
{"docstring": "/* return the address of the instruction that occupy a given offset.\n * If the offset is not part of the given basicblock, UT64_MAX is returned. */\n", "func_signal": "R_API ut64 r_anal_bb_opaddr_at(RAnalBlock *bb, ut64 off)", "code": "{\n\tut16 delta, delta_off, last_delta;\n\tint i;\n\n\tif (!r_anal_block_contains (bb, off)) {\n\t\treturn UT64_MAX;\n\t}\n\tlast_delta = 0;\n\tdelta_off = off - bb->addr;\n\tfor (i = 0; i < bb->ninstr; i++) {\n\t\tdelta = r_anal_bb_offset_inst (bb, i);\n\t\tif (delta > delta_off) {\n\t\t\treturn bb->addr + last_delta;\n\t\t}\n\t\tlast_delta = delta;\n\t}\n\treturn bb->addr + last_delta;\n}", "path": "radare2/libr/anal/bb.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "radareorg/radare2", "stars": 19362, "license": "lgpl-3.0", "language": "c", "size": 169587}
{"docstring": "// TODO: add r2pipe_assert\n", "func_signal": "static int __write(RIO *io, RIODesc *fd, const ut8 *buf, int count)", "code": "{\n\tchar fmt[4096];\n\tchar *bufn, bufnum[4096];\n\tint i, rv, rescount = -1;\n\tchar *res, *r;\n\tif (!fd || !fd->data) {\n\t\treturn -1;\n\t}\n\tbufn = bufnum;\n\t*bufn = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tint bufn_sz = sizeof (bufnum) - (bufn - bufnum);\n\t\tsnprintf (bufn, bufn_sz, \"%s%d\", i ? \",\" : \"\", buf[i]);\n\t\tbufn += strlen (bufn);\n\t}\n\t//TODO PJ (?)\n\tint len = snprintf (fmt, sizeof (fmt),\n\t\t\"{\\\"op\\\":\\\"write\\\",\\\"address\\\":%\" PFMT64d \",\\\"data\\\":[%s]}\",\n\t\tio->off, bufnum);\n\tif (len >= sizeof (fmt)) {\n\t\teprintf (\"r2pipe_write: error, fmt string has been truncated\\n\");\n\t\treturn -1;\n\t}\n\trv = r2pipe_write (R2P (fd), fmt);\n\tif (rv < 1) {\n\t\teprintf (\"r2pipe_write: error\\n\");\n\t\treturn -1;\n\t}\n\tres = r2pipe_read (R2P (fd));\n\t/* TODO: parse json back */\n\tr = strstr (res, \"result\");\n\tif (r) {\n\t\tcount = atoi (r + 6 + 1);\n\t}\n\tfree (res);\n\treturn rescount;\n}", "path": "radare2/libr/io/p/io_r2pipe.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "radareorg/radare2", "stars": 19362, "license": "lgpl-3.0", "language": "c", "size": 169587}
{"docstring": "// Returns the sections\n", "func_signal": "static RList* sections(RBinFile *bf)", "code": "{\n\tr_return_val_if_fail (bf && bf->o, NULL);\n\tQnxObj *qo = bf->o->bin_obj;\n\treturn r_list_clone (qo->sections);\n}", "path": "radare2/libr/bin/p/bin_qnx.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "radareorg/radare2", "stars": 19362, "license": "lgpl-3.0", "language": "c", "size": 169587}
{"docstring": "/* debug */\n", "func_signal": "R_API int bfvm_step(BfvmCPU *c, int over)", "code": "{\n\tut8 op2, op = bfvm_op (c);\n\n\tdo {\n\t\tT bfvm_trace_op (c, op);\n\t\tswitch (op) {\n\t\tcase '\\0':\n\t\t\t/* trap */\n\t\t\treturn 1;\n\t\tcase '.':\n\t\t\t//bfvm_get_ptr (c);\n\t\t\tbfvm_poke (c);\n\t\t\tbreak;\n\t\tcase ',':\n\t\t\tbfvm_peek (c);\n\t\t\t/* TODO read */\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\tbfvm_inc (c);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tbfvm_dec (c);\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tc->ptr++;\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tc->ptr--;\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\tbreak;\n\t\tcase ']':\n\t\t\tif (bfvm_get (c) != 0) {\n\t\t\t\tdo {\n\t\t\t\t\t/* control underflow */\n\t\t\t\t\tif (c->eip < (c->eip-1)) {\n\t\t\t\t\t\tc->eip = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tc->eip--;\n\t\t\t\t} while (bfvm_op (c)!='[');\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tc->eip++;\n\t\top2 = bfvm_op (c);\n\t} while (over && op == op2);\n\n\treturn 0;\n}", "path": "radare2/libr/debug/p/bfvm.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "radareorg/radare2", "stars": 19362, "license": "lgpl-3.0", "language": "c", "size": 169587}
{"docstring": "/*\n * Currently both physical and virtual address are set to 0\n * The memory map has different values for entry\n */\n", "func_signal": "static RList* entries(RBinFile *bf)", "code": "{\n\tRList *ret;\n\tRBinAddr *ptr = NULL;\n\tQnxObj *qo = bf->o->bin_obj;\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\tret->free = free;\n\tif (!(ptr = R_NEW0 (RBinAddr))) {\n\t\treturn ret;\n\t}\n\tptr->paddr = qo->lmfh.code_offset;\n\tptr->vaddr = qo->lmfh.code_offset + baddr (bf);\n\tr_list_append (ret, ptr);\n\treturn ret;\n}", "path": "radare2/libr/bin/p/bin_qnx.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "radareorg/radare2", "stars": 19362, "license": "lgpl-3.0", "language": "c", "size": 169587}
{"docstring": "/*\n * @param RBinFile\n * @return signature of the binary\n */\n", "func_signal": "static char *signature(RBinFile *bf, bool json)", "code": "{\n \tchar buf[64];\n \tQnxObj *qo = bf->o->bin_obj;\n\treturn qo? r_str_dup (NULL, sdb_itoa (qo->rwend.signature, buf, 10)): NULL;\n}", "path": "radare2/libr/bin/p/bin_qnx.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "radareorg/radare2", "stars": 19362, "license": "lgpl-3.0", "language": "c", "size": 169587}
{"docstring": "/* set the offset of the i-th instruction in the basicblock bb */\n", "func_signal": "R_API bool r_anal_bb_set_offset(RAnalBlock *bb, int i, ut16 v)", "code": "{\n\t// the offset 0 of the instruction 0 is not stored because always 0\n\tif (i > 0 && v > 0) {\n\t\tif (i >= bb->op_pos_size) {\n\t\t\tint new_pos_size = i * 2;\n\t\t\tut16 *tmp_op_pos = realloc (bb->op_pos, new_pos_size * sizeof (*bb->op_pos));\n\t\t\tif (!tmp_op_pos) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbb->op_pos_size = new_pos_size;\n\t\t\tbb->op_pos = tmp_op_pos;\n\t\t}\n\t\tbb->op_pos[i - 1] = v;\n\t\treturn true;\n\t}\n\treturn true;\n}", "path": "radare2/libr/anal/bb.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "radareorg/radare2", "stars": 19362, "license": "lgpl-3.0", "language": "c", "size": 169587}
{"docstring": "/*\n * Returns the base address of the image from the binary header\n * @param RBinFile\n * @return image_base address\n */\n", "func_signal": "static ut64 baddr(RBinFile *bf)", "code": "{\n\tQnxObj *qo = bf->o->bin_obj;\n\treturn qo? qo->lmfh.image_base: 0;\n}", "path": "radare2/libr/bin/p/bin_qnx.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "radareorg/radare2", "stars": 19362, "license": "lgpl-3.0", "language": "c", "size": 169587}
{"docstring": "/* Compute all eigenvalues and, optionally, eigenvectors of a real symmetric\nmatrix A */\n", "func_signal": "void THLapack_(syev)(char jobz, char uplo, int n, real *a, int lda, real *w, real *work, int lwork, int *info)", "code": "{\n#ifdef USE_LAPACK\n#if defined(TH_REAL_IS_DOUBLE)\n  dsyev_(&jobz, &uplo, &n, a, &lda, w, work, &lwork, info);\n#else\n  ssyev_(&jobz, &uplo, &n, a, &lda, w, work, &lwork, info);\n#endif\n#else\n  THError(\"syev : Lapack library not found in compile time\\n\");\n#endif\n}", "path": "torch7/lib/TH/generic/THLapack.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "torch/torch7", "stars": 8914, "license": "other", "language": "c", "size": 2624}
{"docstring": "/*\n  The orgqr function allows reconstruction of a matrix Q with orthogonal\n  columns, from a sequence of elementary reflectors, such as is produced by the\n  geqrf function.\n\n  Args:\n  * `ra_` - result Tensor, which will contain the matrix Q.\n  * `a`   - input Tensor, which should be a matrix with the directions of the\n            elementary reflectors below the diagonal. If NULL, `ra_` is used as\n            input.\n  * `tau` - input Tensor, containing the magnitudes of the elementary\n            reflectors.\n\n  For further details, please see the LAPACK documentation.\n\n*/\n", "func_signal": "void THTensor_(orgqr)(THTensor *ra_, THTensor *a, THTensor *tau)", "code": "{\n  if (a == NULL) a = ra_;\n  THArgCheck(a->nDimension == 2, 1, \"A should be 2 dimensional\");\n\n  THTensor *ra__ = NULL;\n  ra__ = THTensor_(cloneColumnMajor)(ra_, a);\n\n  int m = ra__->size[0];\n  int n = ra__->size[1];\n  int k = tau->size[0];\n  int lda = m;\n\n  /* Dry-run to query the suggested size of the workspace. */\n  int info = 0;\n  real wkopt = 0;\n  THLapack_(orgqr)(m, k, k, THTensor_(data)(ra__), lda,\n                   THTensor_(data)(tau),\n                   &wkopt, -1, &info);\n\n  /* Allocate the workspace and call LAPACK to do the real work. */\n  int lwork = (int)wkopt;\n  THTensor *work = THTensor_(newWithSize1d)(lwork);\n  THLapack_(orgqr)(m, k, k, THTensor_(data)(ra__), lda,\n                   THTensor_(data)(tau),\n                   THTensor_(data)(work), lwork, &info);\n\n  THLapackCheckWithCleanup(\" Lapack Error %s : unknown Lapack error. info = %i\",\n                           THCleanup(\n                               THTensor_(free)(ra__);\n                               THTensor_(free)(work);),\n                           \"orgqr\", info,\"\");\n  THTensor_(freeCopyTo)(ra__, ra_);\n  THTensor_(free)(work);\n}", "path": "torch7/lib/TH/generic/THTensorLapack.c", "commit_date": "2017-06-22 00:00:00", "repo_name": "torch/torch7", "stars": 8914, "license": "other", "language": "c", "size": 2624}
{"docstring": "/*\nSame as cloneColumnMajor, but accepts nrows argument, because some lapack calls require\nthe resulting tensor to be larger than src.\n*/\n", "func_signal": "static THTensor *THTensor_(cloneColumnMajorNrows)(THTensor *self, THTensor *src, int nrows)", "code": "{\n  THTensor *result;\n  THTensor *view;\n\n  if (src == NULL)\n    src = self;\n  result = THTensor_(checkLapackClone)(self, src, nrows);\n  if (src == result)\n    return result;\n\n  THTensor_(resize2d)(result, src->size[1], nrows);\n  THTensor_(checkTransposed)(result);\n\n  if (src->size[0] == nrows)\n    THTensor_(copy)(result, src);\n  else\n  {\n    view = THTensor_(newNarrow)(result, 0, 0, src->size[0]);\n    THTensor_(copy)(view, src);\n    THTensor_(free)(view);\n  }\n  return result;\n}", "path": "torch7/lib/TH/generic/THTensorLapack.c", "commit_date": "2017-06-22 00:00:00", "repo_name": "torch/torch7", "stars": 8914, "license": "other", "language": "c", "size": 2624}
{"docstring": "/*\n Computes the Cholesky factorization with complete pivoting of a real symmetric\n positive semidefinite matrix.\n\n Args:\n * `ra_`    - result Tensor in which to store the factor U or L from the\n              Cholesky factorization.\n * `rpiv_`  - result IntTensor containing sparse permutation matrix P, encoded\n              as P[rpiv_[k], k] = 1.\n * `a`      - input Tensor; the input matrix to factorize.\n * `uplo`   - string; specifies whether the upper or lower triangular part of\n              the symmetric matrix A is stored. \"U\"/\"L\" for upper/lower\n              triangular.\n * `tol`    - double; user defined tolerance, or < 0 for automatic choice.\n              The algorithm terminates when the pivot <= tol.\n */\n", "func_signal": "void THTensor_(pstrf)(THTensor *ra_, THIntTensor *rpiv_, THTensor *a, const char *uplo, real tol)", "code": "{\n  THArgCheck(a->nDimension == 2, 1, \"A should be 2 dimensional\");\n  THArgCheck(a->size[0] == a->size[1], 1, \"A should be square\");\n\n  int n = a->size[0];\n\n  THTensor *ra__ = THTensor_(cloneColumnMajor)(ra_, a);\n  THIntTensor_resize1d(rpiv_, n);\n\n  // Allocate working tensor\n  THTensor *work = THTensor_(newWithSize1d)(2 * n);\n\n  // Run Cholesky factorization\n  int lda = n;\n  int rank, info;\n\n  THLapack_(pstrf)(uplo[0], n, THTensor_(data)(ra__), lda,\n                   THIntTensor_data(rpiv_), &rank, tol,\n                   THTensor_(data)(work), &info);\n\n  THLapackCheckWithCleanup(\"Lapack Error %s : matrix is rank deficient or not positive semidefinite\",\n                           THCleanup(\n                               THTensor_(free)(ra__);\n                               THTensor_(free)(work);),\n                           \"pstrf\", info,\"\");\n\n  THTensor_(clearUpLoTriangle)(ra__, uplo);\n\n  THTensor_(freeCopyTo)(ra__, ra_);\n  THTensor_(free)(work);\n}", "path": "torch7/lib/TH/generic/THTensorLapack.c", "commit_date": "2017-06-22 00:00:00", "repo_name": "torch/torch7", "stars": 8914, "license": "other", "language": "c", "size": 2624}
{"docstring": "/*\n  The ormqr function multiplies Q with another matrix from a sequence of\n  elementary reflectors, such as is produced by the geqrf function.\n\n  Args:\n  * `ra_`   - result Tensor, which will contain the matrix Q' c.\n  * `a`     - input Tensor, which should be a matrix with the directions of the\n              elementary reflectors below the diagonal. If NULL, `ra_` is used as\n              input.\n  * `tau`   - input Tensor, containing the magnitudes of the elementary\n              reflectors.\n  * `c`     - input Tensor, containing the matrix to be multiplied.\n  * `side`  - char, determining whether c is left- or right-multiplied with Q.\n  * `trans` - char, determining whether to transpose Q before multiplying.\n\n  For further details, please see the LAPACK documentation.\n\n*/\n", "func_signal": "void THTensor_(ormqr)(THTensor *ra_, THTensor *a, THTensor *tau, THTensor *c, const char *side, const char *trans)", "code": "{\n  if (a == NULL) a = ra_;\n  THArgCheck(a->nDimension == 2, 1, \"A should be 2 dimensional\");\n\n  THTensor *ra__ = NULL;\n  ra__ = THTensor_(cloneColumnMajor)(ra_, c);\n\n  int m = c->size[0];\n  int n = c->size[1];\n  int k = tau->size[0];\n  int lda;\n  if (*side == 'L')\n  {\n    lda = m;\n  }\n  else\n  {\n    lda = n;\n  }\n  int ldc = m;\n\n  /* Dry-run to query the suggested size of the workspace. */\n  int info = 0;\n  real wkopt = 0;\n  THLapack_(ormqr)(side[0], trans[0], m, n, k, THTensor_(data)(a), lda,\n                   THTensor_(data)(tau), THTensor_(data)(ra__), ldc,\n                   &wkopt, -1, &info);\n\n  /* Allocate the workspace and call LAPACK to do the real work. */\n  int lwork = (int)wkopt;\n  THTensor *work = THTensor_(newWithSize1d)(lwork);\n  THLapack_(ormqr)(side[0], trans[0], m, n, k, THTensor_(data)(a), lda,\n                   THTensor_(data)(tau), THTensor_(data)(ra__), ldc,\n                   THTensor_(data)(work), lwork, &info);\n\n  THLapackCheckWithCleanup(\" Lapack Error %s : unknown Lapack error. info = %i\",\n                           THCleanup(\n                               THTensor_(free)(ra__);\n                               THTensor_(free)(work);),\n                           \"ormqr\", info,\"\");\n  THTensor_(freeCopyTo)(ra__, ra_);\n  THTensor_(free)(work);\n}", "path": "torch7/lib/TH/generic/THTensorLapack.c", "commit_date": "2017-06-22 00:00:00", "repo_name": "torch/torch7", "stars": 8914, "license": "other", "language": "c", "size": 2624}
{"docstring": "/* Compute the solution to a real system of linear equations  A * X = B */\n", "func_signal": "void THLapack_(gesv)(int n, int nrhs, real *a, int lda, int *ipiv, real *b, int ldb, int* info)", "code": "{\n#ifdef USE_LAPACK\n#if defined(TH_REAL_IS_DOUBLE)\n  dgesv_(&n, &nrhs, a, &lda, ipiv, b, &ldb, info);\n#else\n  sgesv_(&n, &nrhs, a, &lda, ipiv, b, &ldb, info);\n#endif\n#else\n  THError(\"gesv : Lapack library not found in compile time\\n\");\n#endif\n  return;\n}", "path": "torch7/lib/TH/generic/THLapack.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "torch/torch7", "stars": 8914, "license": "other", "language": "c", "size": 2624}
{"docstring": "/* Solve a triangular system of the form A * X = B  or A^T * X = B */\n", "func_signal": "void THLapack_(trtrs)(char uplo, char trans, char diag, int n, int nrhs, real *a, int lda, real *b, int ldb, int* info)", "code": "{\n#ifdef USE_LAPACK\n#if defined(TH_REAL_IS_DOUBLE)\n  dtrtrs_(&uplo, &trans, &diag, &n, &nrhs, a, &lda, b, &ldb, info);\n#else\n  strtrs_(&uplo, &trans, &diag, &n, &nrhs, a, &lda, b, &ldb, info);\n#endif\n#else\n  THError(\"trtrs : Lapack library not found in compile time\\n\");\n#endif\n  return;\n}", "path": "torch7/lib/TH/generic/THLapack.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "torch/torch7", "stars": 8914, "license": "other", "language": "c", "size": 2624}
{"docstring": "/* Resize */\n", "func_signal": "void THTensor_(resize)(THTensor *self, THLongStorage *size, THLongStorage *stride)", "code": "{\n  THArgCheck(size != NULL, 2, \"invalid size\");\n  if(stride)\n    THArgCheck(stride->size == size->size, 3, \"invalid stride\");\n\n#ifdef DEBUG\n  THAssert(size->size <= INT_MAX);\n#endif\n  THTensor_(resizeNd)(self, size->size, size->data, (stride ? stride->data : NULL));\n}", "path": "torch7/lib/TH/generic/THTensor.c", "commit_date": "2017-07-13 00:00:00", "repo_name": "torch/torch7", "stars": 8914, "license": "other", "language": "c", "size": 2624}
{"docstring": "/* Solve overdetermined or underdetermined real linear systems involving an\nM-by-N matrix A, or its transpose, using a QR or LQ factorization of A */\n", "func_signal": "void THLapack_(gels)(char trans, int m, int n, int nrhs, real *a, int lda, real *b, int ldb, real *work, int lwork, int *info)", "code": "{\n#ifdef USE_LAPACK\n#if defined(TH_REAL_IS_DOUBLE)\n  dgels_(&trans, &m, &n, &nrhs, a, &lda, b, &ldb, work, &lwork, info);\n#else\n  sgels_(&trans, &m, &n, &nrhs, a, &lda, b, &ldb, work, &lwork, info);\n#endif\n#else\n  THError(\"gels : Lapack library not found in compile time\\n\");\n#endif\n}", "path": "torch7/lib/TH/generic/THLapack.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "torch/torch7", "stars": 8914, "license": "other", "language": "c", "size": 2624}
{"docstring": "/* Cholesky factorization */\n", "func_signal": "void THLapack_(potrf)(char uplo, int n, real *a, int lda, int *info)", "code": "{\n#ifdef  USE_LAPACK\n#if defined(TH_REAL_IS_DOUBLE)\n  dpotrf_(&uplo, &n, a, &lda, info);\n#else\n  spotrf_(&uplo, &n, a, &lda, info);\n#endif\n#else\n  THError(\"potrf : Lapack library not found in compile time\\n\");\n#endif\n}", "path": "torch7/lib/TH/generic/THLapack.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "torch/torch7", "stars": 8914, "license": "other", "language": "c", "size": 2624}
{"docstring": "// Host functions for converting between FP32 and FP16 formats\n", "func_signal": "void TH_halfbits2float(unsigned short* src, float* res)", "code": "{\n    unsigned h = *src;\n    unsigned sign = ((h >> 15) & 1);\n    unsigned exponent = ((h >> 10) & 0x1f);\n    unsigned mantissa = ((h & 0x3ff) << 13);\n\n    if (exponent == 0x1f) {  /* NaN or Inf */\n        mantissa = (mantissa ? (sign = 0, 0x7fffff) : 0);\n        exponent = 0xff;\n    } else if (!exponent) {  /* Denorm or Zero */\n        if (mantissa) {\n            unsigned int msb;\n            exponent = 0x71;\n            do {\n                msb = (mantissa & 0x400000);\n                mantissa <<= 1;  /* normalize */\n                --exponent;\n            } while (!msb);\n            mantissa &= 0x7fffff;  /* 1.mantissa is implicit */\n        }\n    } else {\n        exponent += 0x70;\n    }\n\n    *(unsigned*)res = ((sign << 31) | (exponent << 23) | mantissa);\n}", "path": "torch7/lib/TH/THHalf.c", "commit_date": "2017-02-04 00:00:00", "repo_name": "torch/torch7", "stars": 8914, "license": "other", "language": "c", "size": 2624}
{"docstring": "/* Compute for an N-by-N real nonsymmetric matrix A, the eigenvalues and,\noptionally, the left and/or right eigenvectors */\n", "func_signal": "void THLapack_(geev)(char jobvl, char jobvr, int n, real *a, int lda, real *wr, real *wi, real* vl, int ldvl, real *vr, int ldvr, real *work, int lwork, int *info)", "code": "{\n#ifdef USE_LAPACK\n#if defined(TH_REAL_IS_DOUBLE)\n  dgeev_(&jobvl, &jobvr, &n, a, &lda, wr, wi, vl, &ldvl, vr, &ldvr, work, &lwork, info);\n#else\n  sgeev_(&jobvl, &jobvr, &n, a, &lda, wr, wi, vl, &ldvl, vr, &ldvr, work, &lwork, info);\n#endif\n#else\n  THError(\"geev : Lapack library not found in compile time\\n\");\n#endif\n}", "path": "torch7/lib/TH/generic/THLapack.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "torch/torch7", "stars": 8914, "license": "other", "language": "c", "size": 2624}
{"docstring": "/* Pointer-copy init */\n", "func_signal": "THTensor *THTensor_(newWithTensor)(THTensor *tensor)", "code": "{\n  THTensor *self = THAlloc(sizeof(THTensor));\n  THTensor_(rawInit)(self);\n  THTensor_(setStorageNd)(self,\n                          tensor->storage,\n                          tensor->storageOffset,\n                          tensor->nDimension,\n                          tensor->size,\n                          tensor->stride);\n  return self;\n}", "path": "torch7/lib/TH/generic/THTensor.c", "commit_date": "2017-07-13 00:00:00", "repo_name": "torch/torch7", "stars": 8914, "license": "other", "language": "c", "size": 2624}
{"docstring": "/* QR decomposition */\n", "func_signal": "void THLapack_(geqrf)(int m, int n, real *a, int lda, real *tau, real *work, int lwork, int *info)", "code": "{\n#ifdef  USE_LAPACK\n#if defined(TH_REAL_IS_DOUBLE)\n  dgeqrf_(&m, &n, a, &lda, tau, work, &lwork, info);\n#else\n  sgeqrf_(&m, &n, a, &lda, tau, work, &lwork, info);\n#endif\n#else\n  THError(\"geqrf: Lapack library not found in compile time\\n\");\n#endif\n}", "path": "torch7/lib/TH/generic/THLapack.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "torch/torch7", "stars": 8914, "license": "other", "language": "c", "size": 2624}
{"docstring": "/*\nIf a matrix is a regular contiguous matrix, make sure it is transposed\nbecause this is what we return from Lapack calls.\n*/\n", "func_signal": "static void THTensor_(checkTransposed)(THTensor *self)", "code": "{\n  if(THTensor_(isContiguous)(self))\n    THTensor_(transpose)(self, NULL, 0, 1);\n  return;\n}", "path": "torch7/lib/TH/generic/THTensorLapack.c", "commit_date": "2017-06-22 00:00:00", "repo_name": "torch/torch7", "stars": 8914, "license": "other", "language": "c", "size": 2624}
{"docstring": "/* LU decomposition */\n", "func_signal": "void THLapack_(getrf)(int m, int n, real *a, int lda, int *ipiv, int *info)", "code": "{\n#ifdef  USE_LAPACK\n#if defined(TH_REAL_IS_DOUBLE)\n  dgetrf_(&m, &n, a, &lda, ipiv, info);\n#else\n  sgetrf_(&m, &n, a, &lda, ipiv, info);\n#endif\n#else\n  THError(\"getrf : Lapack library not found in compile time\\n\");\n#endif\n}", "path": "torch7/lib/TH/generic/THLapack.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "torch/torch7", "stars": 8914, "license": "other", "language": "c", "size": 2624}
{"docstring": "/* we have to handle the case where the result is a number */\n", "func_signal": "void THTensor_(squeeze)(THTensor *self, THTensor *src)", "code": "{\n  int ndim = 0;\n  int d;\n\n  if(!src)\n    src = self;\n\n  THTensor_(set)(self, src);\n\n  for(d = 0; d < src->nDimension; d++)\n  {\n    if(src->size[d] != 1)\n    {\n      if(d != ndim)\n      {\n        self->size[ndim] = src->size[d];\n        self->stride[ndim] = src->stride[d];\n      }\n      ndim++;\n    }\n  }\n\n  /* right now, we do not handle 0-dimension tensors */\n  if(ndim == 0 && src->nDimension > 0)\n  {\n    self->size[0] = 1;\n    self->stride[0] = 1;\n    ndim = 1;\n  }\n  self->nDimension = ndim;\n}", "path": "torch7/lib/TH/generic/THTensor.c", "commit_date": "2017-07-13 00:00:00", "repo_name": "torch/torch7", "stars": 8914, "license": "other", "language": "c", "size": 2624}
{"docstring": "/*\n  The geqrf function does the main work of QR-decomposing a matrix.\n  However, rather than producing a Q matrix directly, it produces a sequence of\n  elementary reflectors which may later be composed to construct Q - for example\n  with the orgqr function, below.\n\n  Args:\n  * `ra_`   - Result matrix which will contain:\n              i)  The elements of R, on and above the diagonal.\n              ii) Directions of the reflectors implicitly defining Q.\n  * `rtau_` - Result tensor which will contain the magnitudes of the reflectors\n              implicitly defining Q.\n  * `a`     - Input matrix, to decompose. If NULL, `ra_` is used as input.\n\n  For further details, please see the LAPACK documentation.\n\n*/\n", "func_signal": "void THTensor_(geqrf)(THTensor *ra_, THTensor *rtau_, THTensor *a)", "code": "{\n  if (a == NULL) ra_ = a;\n  THArgCheck(a->nDimension == 2, 1, \"A should be 2 dimensional\");\n\n  THTensor *ra__ = NULL;\n\n  /* Prepare the input for LAPACK, making a copy if necessary. */\n  ra__ = THTensor_(cloneColumnMajor)(ra_, a);\n\n  int m = ra__->size[0];\n  int n = ra__->size[1];\n  int k = (m < n ? m : n);\n  int lda = m;\n  THTensor_(resize1d)(rtau_, k);\n\n  /* Dry-run to query the suggested size of the workspace. */\n  int info = 0;\n  real wkopt = 0;\n  THLapack_(geqrf)(m, n, THTensor_(data)(ra__), lda,\n                   THTensor_(data)(rtau_),\n                   &wkopt, -1, &info);\n\n  /* Allocate the workspace and call LAPACK to do the real work. */\n  int lwork = (int)wkopt;\n  THTensor *work = THTensor_(newWithSize1d)(lwork);\n  THLapack_(geqrf)(m, n, THTensor_(data)(ra__), lda,\n                   THTensor_(data)(rtau_),\n                   THTensor_(data)(work), lwork, &info);\n\n  THLapackCheckWithCleanup(\"Lapack Error %s : unknown Lapack error. info = %i\",\n                           THCleanup(\n                               THTensor_(free)(ra__);\n                               THTensor_(free)(work);),\n                           \"geqrf\", info,\"\");\n\n  THTensor_(freeCopyTo)(ra__, ra_);\n  THTensor_(free)(work);\n}", "path": "torch7/lib/TH/generic/THTensorLapack.c", "commit_date": "2017-06-22 00:00:00", "repo_name": "torch/torch7", "stars": 8914, "license": "other", "language": "c", "size": 2624}
{"docstring": "/* Compute the singular value decomposition (SVD) of a real M-by-N matrix A,\noptionally computing the left and/or right singular vectors */\n", "func_signal": "void THLapack_(gesvd)(char jobu, char jobvt, int m, int n, real *a, int lda, real *s, real *u, int ldu, real *vt, int ldvt, real *work, int lwork, int *info)", "code": "{\n#ifdef USE_LAPACK\n#if defined(TH_REAL_IS_DOUBLE)\n  dgesvd_( &jobu,  &jobvt,  &m,  &n,  a,  &lda,  s,  u,  &ldu,  vt,  &ldvt,  work,  &lwork,  info);\n#else\n  sgesvd_( &jobu,  &jobvt,  &m,  &n,  a,  &lda,  s,  u,  &ldu,  vt,  &ldvt,  work,  &lwork,  info);\n#endif\n#else\n  THError(\"gesvd : Lapack library not found in compile time\\n\");\n#endif\n}", "path": "torch7/lib/TH/generic/THLapack.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "torch/torch7", "stars": 8914, "license": "other", "language": "c", "size": 2624}
{"docstring": "/* Credits to Leon Bottou */\n", "func_signal": "double THExpMinusApprox(const double x)", "code": "{\n#define EXACT_EXPONENTIAL 0\n#if EXACT_EXPONENTIAL\n  return exp(-x);\n#else\n  /* fast approximation of exp(-x) for x positive */\n# define A0   (1.0)\n# define A1   (0.125)\n# define A2   (0.0078125)\n# define A3   (0.00032552083)\n# define A4   (1.0172526e-5)\n  if (x < 13.0)\n  {\n/*    assert(x>=0); */\n    double y;\n    y = A0+x*(A1+x*(A2+x*(A3+x*A4)));\n    y *= y;\n    y *= y;\n    y *= y;\n    y = 1/y;\n    return y;\n  }\n  return 0;\n# undef A0\n# undef A1\n# undef A2\n# undef A3\n# undef A4\n#endif\n}", "path": "torch7/lib/TH/THLogAdd.c", "commit_date": "2016-10-03 00:00:00", "repo_name": "torch/torch7", "stars": 8914, "license": "other", "language": "c", "size": 2624}
{"docstring": "// set locations's data\n", "func_signal": "void dt_map_location_set_data(const guint locid, const dt_map_location_data_t *g)", "code": "{\n  if(locid == -1) return;\n  sqlite3_stmt *stmt;\n  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),\n                              \"INSERT OR REPLACE INTO data.locations\"\n                              \"  (tagid, type, longitude, latitude, delta1, delta2, ratio)\"\n                              \"  VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)\",\n                              -1, &stmt, NULL);\n  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, locid);\n  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, g->shape);\n  DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 3, g->lon);\n  DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 4, g->lat);\n  DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 5, g->delta1);\n  DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 6, g->delta2);\n  DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 7, g->ratio);\n  sqlite3_step(stmt);\n  sqlite3_finalize(stmt);\n}", "path": "darktable/src/common/map_locations.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "darktable-org/darktable", "stars": 8659, "license": "gpl-3.0", "language": "c", "size": 1259614}
{"docstring": "// remove a location\n", "func_signal": "void dt_map_location_delete(const guint locid)", "code": "{\n  if(locid == -1) return;\n  char *name = dt_tag_get_name(locid);\n  if(name)\n  {\n    if(g_str_has_prefix(name, location_tag_prefix))\n    {\n      sqlite3_stmt *stmt;\n      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),\n                                  \"DELETE FROM data.locations WHERE tagid=?1\",\n                                  -1, &stmt, NULL);\n      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, locid);\n      sqlite3_step(stmt);\n      sqlite3_finalize(stmt);\n      dt_tag_remove(locid, TRUE);\n    }\n  g_free(name);\n  }\n}", "path": "darktable/src/common/map_locations.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "darktable-org/darktable", "stars": 8659, "license": "gpl-3.0", "language": "c", "size": 1259614}
{"docstring": "/*\n** returns a pointer to a free area with at least 'sz' bytes\n*/\n", "func_signal": "LUALIB_API char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz)", "code": "{\n  lua_State *L = B->L;\n  if (B->size - B->n < sz) {  /* not enough space? */\n    char *newbuff;\n    size_t newsize = B->size * 2;  /* double buffer size */\n    if (newsize - B->n < sz)  /* not big enough? */\n      newsize = B->n + sz;\n    if (newsize < B->n || newsize - B->n < sz)\n      luaL_error(L, \"buffer too large\");\n    /* create larger buffer */\n    if (buffonstack(B))\n      newbuff = (char *)resizebox(L, -1, newsize);\n    else {  /* no buffer yet */\n      newbuff = (char *)newbox(L, newsize);\n      memcpy(newbuff, B->b, B->n * sizeof(char));  /* copy original content */\n    }\n    B->b = newbuff;\n    B->size = newsize;\n  }\n  return &B->b[B->n];\n}", "path": "darktable/src/external/lua/src/lauxlib.c", "commit_date": "2017-01-07 00:00:00", "repo_name": "darktable-org/darktable", "stars": 8659, "license": "gpl-3.0", "language": "c", "size": 1259614}
{"docstring": "/*\n** Again, the use of 'lua_pushvfstring' ensures this function does\n** not need reserved stack space when called. (At worst, it generates\n** an error with \"stack overflow\" instead of the given message.)\n*/\n", "func_signal": "LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...)", "code": "{\n  va_list argp;\n  va_start(argp, fmt);\n  luaL_where(L, 1);\n  lua_pushvfstring(L, fmt, argp);\n  va_end(argp);\n  lua_concat(L, 2);\n  return lua_error(L);\n}", "path": "darktable/src/external/lua/src/lauxlib.c", "commit_date": "2017-01-07 00:00:00", "repo_name": "darktable-org/darktable", "stars": 8659, "license": "gpl-3.0", "language": "c", "size": 1259614}
{"docstring": "/*\n** Find or create a module table with a given name. The function\n** first looks at the _LOADED table and, if that fails, try a\n** global variable with that name. In any case, leaves on the stack\n** the module table.\n*/\n", "func_signal": "LUALIB_API void luaL_pushmodule (lua_State *L, const char *modname,\n                                 int sizehint)", "code": "{\n  luaL_findtable(L, LUA_REGISTRYINDEX, \"_LOADED\", 1);  /* get _LOADED table */\n  if (lua_getfield(L, -1, modname) != LUA_TTABLE) {  /* no _LOADED[modname]? */\n    lua_pop(L, 1);  /* remove previous result */\n    /* try global variable (and create one if it does not exist) */\n    lua_pushglobaltable(L);\n    if (luaL_findtable(L, 0, modname, sizehint) != NULL)\n      luaL_error(L, \"name conflict for module '%s'\", modname);\n    lua_pushvalue(L, -1);\n    lua_setfield(L, -3, modname);  /* _LOADED[modname] = new table */\n  }\n  lua_remove(L, -2);  /* remove _LOADED table */\n}", "path": "darktable/src/external/lua/src/lauxlib.c", "commit_date": "2017-01-07 00:00:00", "repo_name": "darktable-org/darktable", "stars": 8659, "license": "gpl-3.0", "language": "c", "size": 1259614}
{"docstring": "// a paper size has 2 numbers, separated by 'x' or '*' and a unit, either one per number or one in the end (for both)\n// <n> <u>? [x|*] <n> <u>\n// alternatively it could be a well defined format\n", "func_signal": "int dt_pdf_parse_paper_size(const char *str, float *width, float *height)", "code": "{\n  int res = 0;\n  gboolean width_has_unit = FALSE;\n  char *ptr, *nptr, *endptr;\n\n  if(str == NULL || width == NULL || height == NULL)\n    return 0;\n\n  // first check if this is a well known size\n  for(int i = 0; dt_pdf_paper_sizes[i].name; i++)\n  {\n    if(!strcasecmp(str, dt_pdf_paper_sizes[i].name))\n    {\n      *width = dt_pdf_paper_sizes[i].width;\n      *height = dt_pdf_paper_sizes[i].height;\n      return 1;\n    }\n  }\n\n  ptr = nptr = g_strdelimit(g_strdup(str), \",\", '.');\n\n  // width\n  SKIP_SPACES(nptr);\n\n  *width =  g_ascii_strtod(nptr, &endptr);\n\n  if(endptr == NULL || *endptr == '\\0' || errno == ERANGE || !isnormal(*width))\n    goto end;\n\n  nptr = endptr;\n\n  // unit?\n  SKIP_SPACES(nptr);\n\n  for(int i = 0; dt_pdf_units[i].name; i++)\n  {\n    if(g_str_has_prefix(nptr, dt_pdf_units[i].name))\n    {\n      *width *= dt_pdf_units[i].factor;\n      width_has_unit = TRUE;\n      nptr += strlen(dt_pdf_units[i].name);\n      break;\n    }\n  }\n\n  // x\n  SKIP_SPACES(nptr);\n\n  if(*nptr != 'x' && *nptr != '*')\n    goto end;\n\n  nptr++;\n\n  // height\n  SKIP_SPACES(nptr);\n\n  *height =  g_ascii_strtod(nptr, &endptr);\n\n  if(endptr == NULL || *endptr == '\\0' || errno == ERANGE || !isnormal(*height))\n    goto end;\n\n  nptr = endptr;\n\n  // unit\n  SKIP_SPACES(nptr);\n\n  for(int i = 0; dt_pdf_units[i].name; i++)\n  {\n    if(!g_strcmp0(nptr, dt_pdf_units[i].name))\n    {\n      *height *= dt_pdf_units[i].factor;\n      if(width_has_unit == FALSE)\n        *width *= dt_pdf_units[i].factor;\n      res = 1;\n      break;\n    }\n  }\n\nend:\n  g_free(ptr);\n  return res;\n}", "path": "darktable/src/common/pdf.c", "commit_date": "2020-12-25 00:00:00", "repo_name": "darktable-org/darktable", "stars": 8659, "license": "gpl-3.0", "language": "c", "size": 1259614}
{"docstring": "// our writing order is a little strange since we write object 2 (the pages dictionary) at the end of the file\n// because we don't know the number of pages / objects in advance (due to lazy coding)\n", "func_signal": "void dt_pdf_finish(dt_pdf_t *pdf, dt_pdf_page_t **pages, int n_pages)", "code": "{\n  int info_id = pdf->next_id++;\n  size_t bytes_written = 0;\n\n  // the pages dictionary\n  _pdf_set_offset(pdf, 2, pdf->bytes_written + bytes_written);\n  bytes_written += fprintf(pdf->fd,\n    \"2 0 obj\\n\" // yes, this is hardcoded to be object 2, even if written in the end\n    \"<<\\n\"\n    \"/Type /Pages\\n\"\n    \"/Kids [\\n\"\n  );\n  for(int i = 0; i < n_pages; i++)\n    bytes_written += fprintf(pdf->fd, \"%d 0 R\\n\", pages[i]->object_id);\n  bytes_written += fprintf(pdf->fd,\n    \"]\\n\"\n    \"/Count %d\\n\"\n    \">>\\n\"\n    \"endobj\\n\",\n    n_pages\n  );\n\n  // the info\n\n  // the method to get the time_str is taken from pdftex\n  char time_str[30];\n  time_t t;\n  struct tm lt, gmt;\n  size_t size;\n  int off, off_hours, off_mins;\n\n  /* get the time */\n  t = time(NULL);\n  localtime_r(&t, &lt);\n  size = strftime(time_str, sizeof(time_str), \"D:%Y%m%d%H%M%S\", &lt);\n  /* expected format: \"YYYYmmddHHMMSS\" */\n  if(size == 0)\n  {\n    /* unexpected, contents of time_str is undefined */\n    time_str[0] = '\\0';\n    goto time_error;\n  }\n\n  /* correction for seconds: %S can be in range 00..61,\n   *  the PDF reference expects 00..59,\n   *  therefore we map \"60\" and \"61\" to \"59\" */\n  if(time_str[14] == '6')\n  {\n    time_str[14] = '5';\n    time_str[15] = '9';\n    time_str[16] = '\\0';    /* for safety */\n  }\n\n  /* get the time zone offset */\n  gmtime_r(&t, &gmt);\n\n  /* this calculation method was found in exim's tod.c */\n  off = 60 * (lt.tm_hour - gmt.tm_hour) + lt.tm_min - gmt.tm_min;\n  if(lt.tm_year != gmt.tm_year)\n    off += (lt.tm_year > gmt.tm_year) ? 1440 : -1440;\n  else if(lt.tm_yday != gmt.tm_yday)\n    off += (lt.tm_yday > gmt.tm_yday) ? 1440 : -1440;\n\n  if(off == 0)\n  {\n    time_str[size++] = 'Z';\n    time_str[size] = 0;\n  }\n  else\n  {\n    off_hours = off / 60;\n    off_mins = abs(off - off_hours * 60);\n    snprintf(&time_str[size], 9, \"%+03d'%02d'\", off_hours, off_mins);\n  }\n\ntime_error:\n\n  _pdf_set_offset(pdf, info_id, pdf->bytes_written + bytes_written);\n  bytes_written += fprintf(pdf->fd,\n    \"%d 0 obj\\n\"\n    \"<<\\n\"\n    \"/Title (%s)\\n\",\n    info_id, pdf->title ? pdf->title : \"untitled\"\n  );\n  if(*time_str)\n  {\n    bytes_written += fprintf(pdf->fd,\n      \"/CreationDate (%s)\\n\"\n      \"/ModDate (%s)\\n\",\n      time_str, time_str\n    );\n  }\n  bytes_written += fprintf(pdf->fd, \"/Producer (%s https://www.darktable.org)\\n\"\n                                    \">>\\n\"\n                                    \"endobj\\n\",\n                           PACKAGE_STRING);\n\n  pdf->bytes_written += bytes_written;\n\n  // the cross reference table\n  fprintf(pdf->fd,\n    \"xref\\n\"\n    \"0 %d\\n\"\n    \"0000000000 65535 f \\n\",\n    pdf->next_id\n  );\n  for(int i = 0; i < pdf->next_id - 1; i++) fprintf(pdf->fd, \"%010zu 00000 n \\n\", pdf->offsets[i]);\n\n  // the trailer\n  fprintf(pdf->fd,\n    \"trailer\\n\"\n    \"<<\\n\"\n    \"/Size %d\\n\"\n    \"/Info %d 0 R\\n\" // we want to have the Info last in the file, so this is /Size - 1\n    \"/Root 1 0 R\\n\"\n    \"/ID [<dead> <babe>]\\n\" // TODO find something less necrophilic, maybe hash of image + history? or just of filename + date :)\n    \">>\\n\",\n    pdf->next_id, info_id\n  );\n\n  // and finally the file footer with the offset of the xref section\n  fprintf(pdf->fd, \"startxref\\n\"\n                   \"%zu\\n\"\n                   \"%%%%EOF\\n\",\n          pdf->bytes_written);\n\n  fclose(pdf->fd);\n  free(pdf->offsets);\n  free(pdf);\n}", "path": "darktable/src/common/pdf.c", "commit_date": "2020-12-25 00:00:00", "repo_name": "darktable-org/darktable", "stars": 8659, "license": "gpl-3.0", "language": "c", "size": 1259614}
{"docstring": "/*\n** reads the first character of file 'f' and skips an optional BOM mark\n** in its beginning plus its first line if it starts with '#'. Returns\n** true if it skipped the first line.  In any case, '*cp' has the\n** first \"valid\" character of the file (after the optional BOM and\n** a first-line comment).\n*/\n", "func_signal": "static int skipcomment (LoadF *lf, int *cp)", "code": "{\n  int c = *cp = skipBOM(lf);\n  if (c == '#') {  /* first line is a comment (Unix exec. file)? */\n    do {  /* skip first line */\n      c = getc(lf->f);\n    } while (c != EOF && c != '\\n');\n    *cp = getc(lf->f);  /* skip end-of-line, if present */\n    return 1;  /* there was a comment */\n  }\n  else return 0;  /* no comment */\n}", "path": "darktable/src/external/lua/src/lauxlib.c", "commit_date": "2017-01-07 00:00:00", "repo_name": "darktable-org/darktable", "stars": 8659, "license": "gpl-3.0", "language": "c", "size": 1259614}
{"docstring": "/*\n** Stripped-down 'require': After checking \"loaded\" table, calls 'openf'\n** to open a module, registers the result in 'package.loaded' table and,\n** if 'glb' is true, also registers the result in the global table.\n** Leaves resulting module on the top.\n*/\n", "func_signal": "LUALIB_API void luaL_requiref (lua_State *L, const char *modname,\n                               lua_CFunction openf, int glb)", "code": "{\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_getfield(L, -1, modname);  /* _LOADED[modname] */\n  if (!lua_toboolean(L, -1)) {  /* package not already loaded? */\n    lua_pop(L, 1);  /* remove field */\n    lua_pushcfunction(L, openf);\n    lua_pushstring(L, modname);  /* argument to open function */\n    lua_call(L, 1, 1);  /* call 'openf' to open module */\n    lua_pushvalue(L, -1);  /* make copy of module (call result) */\n    lua_setfield(L, -3, modname);  /* _LOADED[modname] = module */\n  }\n  lua_remove(L, -2);  /* remove _LOADED table */\n  if (glb) {\n    lua_pushvalue(L, -1);  /* copy of module */\n    lua_setglobal(L, modname);  /* _G[modname] = module */\n  }\n}", "path": "darktable/src/external/lua/src/lauxlib.c", "commit_date": "2017-01-07 00:00:00", "repo_name": "darktable-org/darktable", "stars": 8659, "license": "gpl-3.0", "language": "c", "size": 1259614}
{"docstring": "// using zlib we get quite small files, but it's slow\n", "func_signal": "static size_t _pdf_stream_encoder_Flate(dt_pdf_t *pdf, const unsigned char *data, size_t len)", "code": "{\n  int result;\n  uLongf destLen = compressBound(len);\n  unsigned char *buffer = (unsigned char *)malloc(destLen);\n\n  result = compress(buffer, &destLen, data, len);\n\n  if(result != Z_OK)\n  {\n    free(buffer);\n    return 0;\n  }\n\n  fwrite(buffer, 1, destLen, pdf->fd);\n\n  free(buffer);\n  return destLen;\n}", "path": "darktable/src/common/pdf.c", "commit_date": "2020-12-25 00:00:00", "repo_name": "darktable-org/darktable", "stars": 8659, "license": "gpl-3.0", "language": "c", "size": 1259614}
{"docstring": "// find locations which match with that image\n", "func_signal": "GList *dt_map_location_find_locations(const guint imgid)", "code": "{\n  GList *tags = NULL;\n  sqlite3_stmt *stmt;\n  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),\n                              \"SELECT l.tagid FROM main.images AS i\"\n                              \"  JOIN data.locations AS l\"\n                              \"  ON (l.type = ?2 AND\"\n                              \"      ((((i.longitude-l.longitude)*(i.longitude-l.longitude))/\"\n                                        \"(delta1*delta1) +\"\n                              \"        ((i.latitude-l.latitude)*(i.latitude-l.latitude))/\"\n                                        \"(delta2*delta2)) <= 1)\"\n                              \"    OR (l.type = ?3 AND\"\n                              \"      i.longitude>=(l.longitude-delta1) AND\"\n                              \"      i.longitude<=(l.longitude+delta1) AND\"\n                              \"      i.latitude>=(l.latitude-delta2) AND\"\n                              \"      i.latitude<=(l.latitude+delta2)))\"\n                              \" WHERE i.id = ?1\",\n                              -1, &stmt, NULL);\n  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);\n  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, MAP_LOCATION_SHAPE_ELLIPSE);\n  DT_DEBUG_SQLITE3_BIND_INT(stmt, 3, MAP_LOCATION_SHAPE_RECTANGLE);\n\n  while(sqlite3_step(stmt) == SQLITE_ROW)\n  {\n    const int id = sqlite3_column_int(stmt, 0);\n    tags = g_list_prepend(tags, GINT_TO_POINTER(id));\n  }\n  sqlite3_finalize(stmt);\n  return tags;\n}", "path": "darktable/src/common/map_locations.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "darktable-org/darktable", "stars": 8659, "license": "gpl-3.0", "language": "c", "size": 1259614}
{"docstring": "/*\n** set functions from list 'l' into table at top - 'nup'; each\n** function gets the 'nup' elements at the top as upvalues.\n** Returns with only the table at the stack.\n*/\n", "func_signal": "LUALIB_API void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup)", "code": "{\n  luaL_checkstack(L, nup, \"too many upvalues\");\n  for (; l->name != NULL; l++) {  /* fill the table with given functions */\n    int i;\n    for (i = 0; i < nup; i++)  /* copy upvalues to the top */\n      lua_pushvalue(L, -nup);\n    lua_pushcclosure(L, l->func, nup);  /* closure with those upvalues */\n    lua_setfield(L, -(nup + 2), l->name);\n  }\n  lua_pop(L, nup);  /* remove upvalues */\n}", "path": "darktable/src/external/lua/src/lauxlib.c", "commit_date": "2017-01-07 00:00:00", "repo_name": "darktable-org/darktable", "stars": 8659, "license": "gpl-3.0", "language": "c", "size": 1259614}
{"docstring": "// free map location list\n", "func_signal": "void dt_map_location_free_result(GList **result)", "code": "{\n  if(result && *result)\n  {\n    g_list_free_full(*result, (GDestroyNotify)_free_result_item);\n  }\n}", "path": "darktable/src/common/map_locations.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "darktable-org/darktable", "stars": 8659, "license": "gpl-3.0", "language": "c", "size": 1259614}
{"docstring": "// update location's images - remove old ones and add new ones\n", "func_signal": "void dt_map_location_update_images(const guint locid)", "code": "{\n  // get previous images\n  GList *imgs = dt_tag_get_images(locid);\n\n  // find images in that location\n  GList *new_imgs = _map_location_find_images(locid);\n\n  // detach images which are not in location anymore\n  for(GList *img = imgs; img; img = g_list_next(img))\n  {\n    if(!g_list_find(new_imgs, img->data))\n    {\n      dt_tag_detach(locid, GPOINTER_TO_INT(img->data), FALSE, FALSE);\n    }\n  }\n\n  // add new images to location\n  for(GList *img = new_imgs; img; img = g_list_next(img))\n  {\n    if(!g_list_find(imgs, img->data))\n    {\n      dt_tag_attach(locid, GPOINTER_TO_INT(img->data), FALSE, FALSE);\n    }\n  }\n  g_list_free(new_imgs);\n  g_list_free(imgs);\n}", "path": "darktable/src/common/map_locations.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "darktable-org/darktable", "stars": 8659, "license": "gpl-3.0", "language": "c", "size": 1259614}
{"docstring": "// rename a location\n", "func_signal": "void dt_map_location_rename(const guint locid, const char *const name)", "code": "{\n  if(locid == -1 || !name || !name[0]) return;\n  char *old_name = dt_tag_get_name(locid);\n  if(old_name)\n  {\n    if(g_str_has_prefix(old_name, location_tag_prefix))\n    {\n      char *new_name = g_strconcat(location_tag_prefix, name, NULL);\n      dt_tag_rename(locid, new_name);\n      g_free(new_name);\n    }\n    g_free(old_name);\n  }\n}", "path": "darktable/src/common/map_locations.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "darktable-org/darktable", "stars": 8659, "license": "gpl-3.0", "language": "c", "size": 1259614}
{"docstring": "// update image's locations - remove old ones and add new ones\n", "func_signal": "void dt_map_location_update_locations(const guint imgid, const GList *tags)", "code": "{\n  // get current locations\n  GList *old_tags = NULL;\n  sqlite3_stmt *stmt;\n  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),\n                              \"SELECT t.id FROM main.tagged_images ti\"\n                              \"  JOIN data.tags AS t ON t.id = ti.tagid\"\n                              \"  JOIN data.locations AS l ON l.tagid = t.id\"\n                              \"  WHERE imgid = ?1\",\n                              -1, &stmt, NULL);\n  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);\n\n  while(sqlite3_step(stmt) == SQLITE_ROW)\n  {\n    const int id = sqlite3_column_int(stmt, 0);\n    old_tags = g_list_prepend(old_tags, GINT_TO_POINTER(id));\n  }\n  sqlite3_finalize(stmt);\n\n  // clean up locations which are not valid anymore\n  for(GList *tag = old_tags; tag; tag = g_list_next(tag))\n  {\n    if(!g_list_find((GList *)tags, tag->data))\n    {\n      dt_tag_detach(GPOINTER_TO_INT(tag->data), imgid,\n      FALSE, FALSE);\n    }\n  }\n\n  // add new locations\n  for(GList *tag = (GList *)tags; tag; tag = g_list_next(tag))\n  {\n    if(!g_list_find(old_tags, tag->data))\n    {\n      dt_tag_attach(GPOINTER_TO_INT(tag->data), imgid,\n                    FALSE, FALSE);\n    }\n  }\n  g_list_free(old_tags);\n}", "path": "darktable/src/common/map_locations.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "darktable-org/darktable", "stars": 8659, "license": "gpl-3.0", "language": "c", "size": 1259614}
{"docstring": "/*\n** Count number of elements in a luaL_Reg list.\n*/\n", "func_signal": "static int libsize (const luaL_Reg *l)", "code": "{\n  int size = 0;\n  for (; l && l->name; l++) size++;\n  return size;\n}", "path": "darktable/src/external/lua/src/lauxlib.c", "commit_date": "2017-01-07 00:00:00", "repo_name": "darktable-org/darktable", "stars": 8659, "license": "gpl-3.0", "language": "c", "size": 1259614}
{"docstring": "/*\n** ensure that stack[idx][fname] has a table and push that table\n** into the stack\n*/\n", "func_signal": "LUALIB_API int luaL_getsubtable (lua_State *L, int idx, const char *fname)", "code": "{\n  if (lua_getfield(L, idx, fname) == LUA_TTABLE)\n    return 1;  /* table already there */\n  else {\n    lua_pop(L, 1);  /* remove previous result */\n    idx = lua_absindex(L, idx);\n    lua_newtable(L);\n    lua_pushvalue(L, -1);  /* copy to be left at top */\n    lua_setfield(L, idx, fname);  /* assign new table to field */\n    return 0;  /* false, because did not find table there */\n  }\n}", "path": "darktable/src/external/lua/src/lauxlib.c", "commit_date": "2017-01-07 00:00:00", "repo_name": "darktable-org/darktable", "stars": 8659, "license": "gpl-3.0", "language": "c", "size": 1259614}
{"docstring": "// FIXME: return 0 on success and 1 on error!\n", "func_signal": "static int initialize_store_wrapper(struct dt_imageio_module_storage_t *self, dt_imageio_module_data_t *data,\n                                    dt_imageio_module_format_t **format, dt_imageio_module_data_t **fdata,\n                                    GList **images, const gboolean high_quality, const gboolean upscale)", "code": "{\n  dt_lua_lock();\n  lua_State *L = darktable.lua_state.state;\n\n  lua_getfield(L, LUA_REGISTRYINDEX, \"dt_lua_storages\");\n  lua_getfield(L, -1, self->plugin_name);\n  lua_getfield(L, -1, \"initialize_store\");\n\n  if(lua_isnil(L, -1))\n  {\n    lua_pop(L, 3);\n    dt_lua_unlock();\n    return 1;\n  }\n\n  luaA_push_type(L, self->parameter_lua_type, data);\n  luaA_push_type(L, (*format)->parameter_lua_type, *fdata);\n\n  GList *imgids = *images;\n  lua_newtable(L);\n  while(imgids)\n  {\n    luaA_push(L, dt_lua_image_t, &(imgids->data));\n    luaL_ref(L, -2);\n    imgids = g_list_next(imgids);\n  }\n  lua_pushboolean(L, high_quality);\n\n  lua_storage_t *d = (lua_storage_t *)data;\n  push_lua_data(L,d);\n  dt_lua_goto_subtable(L,\"extra\");\n\n  dt_lua_treated_pcall(L,5,1);\n  if(!lua_isnoneornil(L, -1))\n  {\n    g_list_free(*images);\n    if(lua_type(L,-1) != LUA_TTABLE)\n    {\n      dt_print(DT_DEBUG_LUA, \"LUA ERROR initialization function of storage did not return nil or table\\n\");\n      dt_lua_unlock();\n      return 1;\n    }\n    GList *new_images = NULL;\n    lua_pushnil(L);\n    while(lua_next(L, -2))\n    {\n      dt_lua_image_t imgid;\n      luaA_to(L, dt_lua_image_t, &imgid, -1);\n      new_images = g_list_prepend(new_images, GINT_TO_POINTER(imgid));\n      lua_pop(L, 1);\n    }\n    new_images = g_list_reverse(new_images);\n    *images = new_images;\n  }\n  lua_pop(L, 3);\n  dt_lua_unlock();\n  return 0;\n}", "path": "darktable/src/lua/luastorage.c", "commit_date": "2020-03-27 00:00:00", "repo_name": "darktable-org/darktable", "stars": 8659, "license": "gpl-3.0", "language": "c", "size": 1259614}
{"docstring": "// sort the tag list considering the '|' character\n", "func_signal": "GList *dt_map_location_sort(GList *tags)", "code": "{\n  // order such that sub tags are coming directly behind their parent\n  GList *sorted_tags;\n  for(GList *taglist = tags; taglist; taglist = g_list_next(taglist))\n  {\n    gchar *tag = ((dt_map_location_t *)taglist->data)->tag;\n    for(char *letter = tag; *letter; letter++)\n      if(*letter == '|') *letter = '\\1';\n  }\n  sorted_tags = g_list_sort(tags, _sort_by_path);\n  for(GList *taglist = sorted_tags; taglist; taglist = g_list_next(taglist))\n  {\n    gchar *tag = ((dt_map_location_t *)taglist->data)->tag;\n    for(char *letter = tag; *letter; letter++)\n      if(*letter == '\\1') *letter = '|';\n  }\n  return sorted_tags;\n}", "path": "darktable/src/common/map_locations.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "darktable-org/darktable", "stars": 8659, "license": "gpl-3.0", "language": "c", "size": 1259614}
{"docstring": "/** @brief Calculate scaled fullscreen movie rectangle with\n *  preserved aspect ratio.\n */\n", "func_signal": "static void calc_fs_rect(d3d_priv *priv)", "code": "{\n    struct mp_rect src_rect;\n    struct mp_rect dst_rect;\n    vo_get_src_dst_rects(priv->vo, &src_rect, &dst_rect, &priv->osd_res);\n\n    priv->fs_movie_rect.left     = dst_rect.x0;\n    priv->fs_movie_rect.right    = dst_rect.x1;\n    priv->fs_movie_rect.top      = dst_rect.y0;\n    priv->fs_movie_rect.bottom   = dst_rect.y1;\n    priv->fs_panscan_rect.left   = src_rect.x0;\n    priv->fs_panscan_rect.right  = src_rect.x1;\n    priv->fs_panscan_rect.top    = src_rect.y0;\n    priv->fs_panscan_rect.bottom = src_rect.y1;\n}", "path": "mpv/video/out/vo_direct3d.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "mpv-player/mpv", "stars": 25392, "license": "other", "language": "c", "size": 102697}
{"docstring": "// Return if the image format can be used. If it can, decide which rendering\n// and conversion mode to use.\n// If initialize is true, actually setup all variables to use the picked\n// rendering mode.\n", "func_signal": "static bool init_rendering_mode(d3d_priv *priv, uint32_t fmt, bool initialize)", "code": "{\n    int blit_d3dfmt = check_format(priv, fmt);\n\n    if (!blit_d3dfmt)\n        return false;\n\n    MP_VERBOSE(priv, \"Accepted rendering methods for \"\n           \"format='%s': StretchRect=%#x.\\n\",\n           vo_format_name(fmt), blit_d3dfmt);\n\n    if (!initialize)\n        return true;\n\n    // initialization doesn't fail beyond this point\n\n    priv->movie_src_fmt = 0;\n    priv->image_format = fmt;\n\n    priv->movie_src_fmt = blit_d3dfmt;\n\n    return true;\n}", "path": "mpv/video/out/vo_direct3d.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "mpv-player/mpv", "stars": 25392, "license": "other", "language": "c", "size": 102697}
{"docstring": "// Allocate video surface.\n", "func_signal": "static bool d3d_configure_video_objects(d3d_priv *priv)", "code": "{\n    assert(priv->image_format != 0);\n\n    if (!priv->d3d_surface &&\n        FAILED(IDirect3DDevice9_CreateOffscreenPlainSurface(\n            priv->d3d_device, priv->src_width, priv->src_height,\n            priv->movie_src_fmt, D3DPOOL_DEFAULT, &priv->d3d_surface, NULL)))\n    {\n        MP_ERR(priv, \"Allocating offscreen surface failed.\\n\");\n        return false;\n    }\n\n    return true;\n}", "path": "mpv/video/out/vo_direct3d.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "mpv-player/mpv", "stars": 25392, "license": "other", "language": "c", "size": 102697}
{"docstring": "/** @brief Reconfigure the whole Direct3D. Called only\n *  when the video adapter becomes uncooperative. (\"Lost\" devices)\n *  @return 1 on success, 0 on failure\n */\n", "func_signal": "static int reconfigure_d3d(d3d_priv *priv)", "code": "{\n    MP_VERBOSE(priv, \"reconfigure_d3d called.\\n\");\n\n    // Force complete destruction of the D3D state.\n    // Note: this step could be omitted. The resize_d3d call below would detect\n    // that d3d_device is NULL, and would properly recreate it. I'm not sure why\n    // the following code to release and recreate the d3d_handle exists.\n    destroy_d3d(priv);\n    if (!init_d3d(priv))\n        return 0;\n\n    // Proper re-initialization.\n    if (!resize_d3d(priv))\n        return 0;\n\n    return 1;\n}", "path": "mpv/video/out/vo_direct3d.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "mpv-player/mpv", "stars": 25392, "license": "other", "language": "c", "size": 102697}
{"docstring": "/** @brief libvo Callback: Uninitializes all pointers and closes\n *         all D3D related stuff,\n */\n", "func_signal": "static void uninit(struct vo *vo)", "code": "{\n    d3d_priv *priv = vo->priv;\n\n    MP_VERBOSE(priv, \"uninit called.\\n\");\n\n    uninit_d3d(priv);\n    vo_w32_uninit(vo);\n    if (priv->d3d9_dll)\n        FreeLibrary(priv->d3d9_dll);\n    priv->d3d9_dll = NULL;\n}", "path": "mpv/video/out/vo_direct3d.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "mpv-player/mpv", "stars": 25392, "license": "other", "language": "c", "size": 102697}
{"docstring": "// Create a cache. This also initializes the cache file from the options. The\n// log parameter must stay valid until demux_cache is destroyed.\n// Free with talloc_free().\n", "func_signal": "struct demux_cache *demux_cache_create(struct mpv_global *global,\n                                       struct mp_log *log)", "code": "{\n    struct demux_cache *cache = talloc_zero(NULL, struct demux_cache);\n    talloc_set_destructor(cache, cache_destroy);\n    cache->opts = mp_get_config_group(cache, global, &demux_cache_conf);\n    cache->log = log;\n    cache->fd = -1;\n\n    char *cache_dir = cache->opts->cache_dir;\n    if (!(cache_dir && cache_dir[0])) {\n        MP_ERR(cache, \"No cache data directory supplied.\\n\");\n        goto fail;\n    }\n\n    cache->filename = mp_path_join(cache, cache_dir, \"mpv-cache-XXXXXX.dat\");\n    cache->fd = mp_mkostemps(cache->filename, 4, O_CLOEXEC);\n    if (cache->fd < 0) {\n        MP_ERR(cache, \"Failed to create cache temporary file.\\n\");\n        goto fail;\n    }\n    cache->need_unlink = true;\n    if (cache->opts->unlink_files >= 2) {\n        if (unlink(cache->filename)) {\n            MP_ERR(cache, \"Failed to unlink cache temporary file after creation.\\n\");\n        } else {\n            cache->need_unlink = false;\n        }\n    }\n\n    return cache;\nfail:\n    talloc_free(cache);\n    return NULL;\n}", "path": "mpv/demux/cache.c", "commit_date": "2020-03-18 00:00:00", "repo_name": "mpv-player/mpv", "stars": 25392, "license": "other", "language": "c", "size": 102697}
{"docstring": "// Adjust the texture size *width/*height to fit the requirements of the D3D\n// device. The texture size is only increased.\n", "func_signal": "static void d3d_fix_texture_size(d3d_priv *priv, int *width, int *height)", "code": "{\n    int tex_width = *width;\n    int tex_height = *height;\n\n    // avoid nasty special cases with 0-sized textures and texture sizes\n    tex_width = MPMAX(tex_width, 1);\n    tex_height = MPMAX(tex_height, 1);\n\n    if (priv->device_caps_power2_only) {\n        tex_width  = 1;\n        tex_height = 1;\n        while (tex_width  < *width) tex_width  <<= 1;\n        while (tex_height < *height) tex_height <<= 1;\n    }\n    if (priv->device_caps_square_only)\n        /* device only supports square textures */\n        tex_width = tex_height = MPMAX(tex_width, tex_height);\n    // better round up to a multiple of 16\n    if (!priv->opt_disable_texture_align) {\n        tex_width  = (tex_width  + 15) & ~15;\n        tex_height = (tex_height + 15) & ~15;\n    }\n\n    *width = tex_width;\n    *height = tex_height;\n}", "path": "mpv/video/out/vo_direct3d.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "mpv-player/mpv", "stars": 25392, "license": "other", "language": "c", "size": 102697}
{"docstring": "/** @brief libvo Callback: Flip next already drawn frame on the\n *         screen.\n */\n", "func_signal": "static void flip_page(struct vo *vo)", "code": "{\n    d3d_priv *priv = vo->priv;\n\n    if (priv->d3d_device && priv->d3d_in_scene) {\n        if (FAILED(IDirect3DDevice9_EndScene(priv->d3d_device))) {\n            MP_ERR(priv, \"EndScene failed.\\n\");\n        }\n    }\n    priv->d3d_in_scene = false;\n\n    RECT rect = {0, 0, vo->dwidth, vo->dheight};\n    if (!priv->d3d_device ||\n        FAILED(IDirect3DDevice9_Present(priv->d3d_device, &rect, 0, 0, 0))) {\n        MP_VERBOSE(priv, \"Trying to reinitialize uncooperative video adapter.\\n\");\n        if (!reconfigure_d3d(priv)) {\n            MP_VERBOSE(priv, \"Reinitialization failed.\\n\");\n            return;\n        } else {\n            MP_VERBOSE(priv, \"Video adapter reinitialized.\\n\");\n        }\n    }\n}", "path": "mpv/video/out/vo_direct3d.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "mpv-player/mpv", "stars": 25392, "license": "other", "language": "c", "size": 102697}
{"docstring": "// Free video surface/textures,  etc.\n", "func_signal": "static void d3d_destroy_video_objects(d3d_priv *priv)", "code": "{\n    d3d_unlock_video_objects(priv);\n\n    if (priv->d3d_surface)\n        IDirect3DSurface9_Release(priv->d3d_surface);\n    priv->d3d_surface = NULL;\n}", "path": "mpv/video/out/vo_direct3d.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "mpv-player/mpv", "stars": 25392, "license": "other", "language": "c", "size": 102697}
{"docstring": "// If this returns true, and *out==NULL, no conversion is necessary.\n", "func_signal": "static bool build_image_converter(struct mp_autoconvert *c, struct mp_log *log,\n                                  struct mp_image *img, struct mp_filter **f_out)", "code": "{\n    struct mp_filter *f = c->f;\n    struct priv *p = f->priv;\n\n    *f_out = NULL;\n\n    if (!p->num_imgfmts)\n        return true;\n\n    for (int n = 0; n < p->num_imgfmts; n++) {\n        bool samefmt = img->params.imgfmt == p->imgfmts[n];\n        bool samesubffmt = img->params.hw_subfmt == p->subfmts[n];\n        if (samefmt && (samesubffmt || !p->subfmts[n])) {\n            if (p->imgparams_set) {\n                if (!mp_image_params_equal(&p->imgparams, &img->params))\n                    break;\n            }\n            return true;\n        }\n    }\n\n    struct mp_filter *conv = mp_filter_create(f, &convert_filter);\n    mp_filter_add_pin(conv, MP_PIN_IN, \"in\");\n    mp_filter_add_pin(conv, MP_PIN_OUT, \"out\");\n\n    // 0: hw->sw download\n    // 1: swscale\n    // 2: sw->hw upload\n    struct mp_filter *filters[3] = {0};\n    bool need_sws = true;\n    bool force_sws_params = false;\n    struct mp_image_params imgpar = img->params;\n\n    int *fmts = p->imgfmts;\n    int num_fmts = p->num_imgfmts;\n    int hwupload_fmt = 0;\n\n    bool imgfmt_is_sw = !IMGFMT_IS_HWACCEL(img->imgfmt);\n\n    // This should not happen. But not enough guarantee to make it an assert().\n    if (imgfmt_is_sw != !img->hwctx)\n        mp_warn(log, \"Unexpected AVFrame/imgfmt hardware context mismatch.\\n\");\n\n    bool dst_all_hw = true;\n    bool dst_have_sw = false;\n    for (int n = 0; n < num_fmts; n++) {\n        bool is_hw = IMGFMT_IS_HWACCEL(fmts[n]);\n        dst_all_hw &= is_hw;\n        dst_have_sw |= !is_hw;\n    }\n\n    // Source is sw, all targets are hw -> try to upload.\n    bool sw_to_hw = imgfmt_is_sw && dst_all_hw;\n    // Source is hw, some targets are sw -> try to download.\n    bool hw_to_sw = !imgfmt_is_sw && dst_have_sw;\n\n    if (sw_to_hw && num_fmts > 0) {\n        // We can probably use this! Very lazy and very approximate.\n        struct mp_hwupload *upload = mp_hwupload_create(conv, fmts[0]);\n        if (upload) {\n            mp_info(log, \"HW-uploading to %s\\n\", mp_imgfmt_to_name(fmts[0]));\n            filters[2] = upload->f;\n            hwupload_fmt = mp_hwupload_find_upload_format(upload, img->imgfmt);\n            fmts = &hwupload_fmt;\n            num_fmts = hwupload_fmt ? 1 : 0;\n            hw_to_sw = false;\n        }\n    }\n\n    int src_fmt = img->imgfmt;\n    if (hw_to_sw) {\n        mp_info(log, \"HW-downloading from %s\\n\", mp_imgfmt_to_name(img->imgfmt));\n        int res_fmt = mp_image_hw_download_get_sw_format(img);\n        if (!res_fmt) {\n            mp_err(log, \"cannot copy surface of this format to CPU memory\\n\");\n            goto fail;\n        }\n        struct mp_hwdownload *hwd = mp_hwdownload_create(conv);\n        if (hwd) {\n            filters[0] = hwd->f;\n            src_fmt = res_fmt;\n            // Downloading from hw will obviously change the parameters. We\n            // stupidly don't know the result parameters, but if it's\n            // sufficiently sane, it will only do the following.\n            imgpar.imgfmt = src_fmt;\n            imgpar.hw_subfmt = 0;\n            // Try to compensate for in-sane cases.\n            mp_image_params_guess_csp(&imgpar);\n        }\n    }\n\n    if (p->imgparams_set) {\n        force_sws_params |= !mp_image_params_equal(&imgpar, &p->imgparams);\n        need_sws |= force_sws_params;\n    }\n\n    if (need_sws) {\n        // Create a new conversion filter.\n        struct mp_sws_filter *sws = mp_sws_filter_create(conv);\n        if (!sws) {\n            mp_err(log, \"error creating conversion filter\\n\");\n            goto fail;\n        }\n\n        sws->force_scaler = c->force_scaler;\n\n        int out = mp_sws_find_best_out_format(sws, src_fmt, fmts, num_fmts);\n        if (!out) {\n            mp_err(log, \"can't find video conversion for %s\\n\",\n                   mp_imgfmt_to_name(src_fmt));\n            goto fail;\n        }\n\n        if (out == src_fmt && !force_sws_params) {\n            // Can happen if hwupload goes to same format.\n            talloc_free(sws->f);\n        } else {\n            sws->out_format = out;\n            sws->out_params = p->imgparams;\n            sws->use_out_params = force_sws_params;\n            mp_info(log, \"Converting %s -> %s\\n\", mp_imgfmt_to_name(src_fmt),\n                    mp_imgfmt_to_name(sws->out_format));\n            filters[1] = sws->f;\n        }\n    }\n\n    mp_chain_filters(conv->ppins[0], conv->ppins[1], filters, 3);\n\n    *f_out = conv;\n    return true;\n\nfail:\n    talloc_free(conv);\n    return false;\n}", "path": "mpv/filters/f_autoconvert.c", "commit_date": "2020-04-13 00:00:00", "repo_name": "mpv-player/mpv", "stars": 25392, "license": "other", "language": "c", "size": 102697}
{"docstring": "// Lock buffers and fill out to point to them.\n// Must call d3d_unlock_video_objects() to unlock the buffers again.\n", "func_signal": "static bool get_video_buffer(d3d_priv *priv, struct mp_image *out)", "code": "{\n    *out = (struct mp_image) {0};\n    mp_image_set_size(out, priv->src_width, priv->src_height);\n    mp_image_setfmt(out, priv->image_format);\n\n    if (!priv->d3d_device)\n        return false;\n\n    if (!priv->locked_rect.pBits) {\n        if (FAILED(IDirect3DSurface9_LockRect(priv->d3d_surface,\n                                              &priv->locked_rect, NULL, 0)))\n        {\n            MP_ERR(priv, \"Surface lock failed.\\n\");\n            return false;\n        }\n    }\n\n    uint8_t *base = priv->locked_rect.pBits;\n    size_t stride = priv->locked_rect.Pitch;\n\n    out->planes[0] = base;\n    out->stride[0] = stride;\n\n    if (out->num_planes == 2) {\n        // NV12, NV21\n        out->planes[1] = base + stride * out->h;\n        out->stride[1] = stride;\n    }\n\n    if (out->num_planes == 3) {\n        bool swap = priv->movie_src_fmt == MAKEFOURCC('Y','V','1','2');\n\n        size_t uv_stride = stride / 2;\n        uint8_t *u = base + out->h * stride;\n        uint8_t *v = u + (out->h / 2) * uv_stride;\n\n        out->planes[1] = swap ? v : u;\n        out->planes[2] = swap ? u : v;\n\n        out->stride[1] = out->stride[2] = uv_stride;\n    }\n\n    return true;\n}", "path": "mpv/video/out/vo_direct3d.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "mpv-player/mpv", "stars": 25392, "license": "other", "language": "c", "size": 102697}
{"docstring": "// Serialize a packet to the cache file. Returns the packet position, which can\n// be passed to demux_cache_read() to read the packet again.\n// Returns a negative value on errors, i.e. writing the file failed.\n", "func_signal": "int64_t demux_cache_write(struct demux_cache *cache, struct demux_packet *dp)", "code": "{\n    assert(dp->avpacket);\n\n    // AV_PKT_FLAG_TRUSTED usually means there are embedded pointers and such\n    // in the packet data. The pointer will become invalid if the packet is\n    // unreferenced.\n    if (dp->avpacket->flags & AV_PKT_FLAG_TRUSTED) {\n        MP_ERR(cache, \"Cannot serialize this packet to cache file.\\n\");\n        return -1;\n    }\n\n    assert(!dp->is_cached);\n    assert(dp->len >= 0 && dp->len <= INT32_MAX);\n    assert(dp->avpacket->flags >= 0 && dp->avpacket->flags <= INT32_MAX);\n    assert(dp->avpacket->side_data_elems >= 0 &&\n           dp->avpacket->side_data_elems <= INT32_MAX);\n\n    if (!do_seek(cache, cache->file_size))\n        return -1;\n\n    uint64_t pos = cache->file_pos;\n\n    struct pkt_header hd = {\n        .data_len  = dp->len,\n        .av_flags = dp->avpacket->flags,\n        .num_sd = dp->avpacket->side_data_elems,\n    };\n\n    if (!write_raw(cache, &hd, sizeof(hd)))\n        goto fail;\n\n    if (!write_raw(cache, dp->buffer, dp->len))\n        goto fail;\n\n    // The handling of FFmpeg side data requires an extra long comment to\n    // explain why this code is fragile and insane.\n    // FFmpeg packet side data is per-packet out of band data, that contains\n    // further information for the decoder (extra metadata and such), which is\n    // not part of the codec itself and thus isn't contained in the packet\n    // payload. All types use a flat byte array. The format of this byte array\n    // is non-standard and FFmpeg-specific, and depends on the side data type\n    // field. The side data type is of course a FFmpeg ABI artifact.\n    // In some cases, the format is described as fixed byte layout. In others,\n    // it contains a struct, i.e. is bound to FFmpeg ABI. Some newer types make\n    // the format explicitly internal (and _not_ part of the ABI), and you need\n    // to use separate accessors to turn it into complex data structures.\n    // As of now, FFmpeg fortunately adheres to the idea that side data can not\n    // contain embedded pointers (due to API rules, but also because they forgot\n    // adding a refcount field, and can't change this until they break ABI).\n    // We rely on this. We hope that FFmpeg won't silently change their\n    // semantics, and add refcounting and embedded pointers. This way we can\n    // for example dump the data in a disk cache, even though we can't use the\n    // data from another process or if this process is restarted (unless we're\n    // absolutely sure the FFmpeg internals didn't change). The data has to be\n    // treated as a memory dump.\n    for (int n = 0; n < dp->avpacket->side_data_elems; n++) {\n        AVPacketSideData *sd = &dp->avpacket->side_data[n];\n\n        assert(sd->size >= 0 && sd->size <= INT32_MAX);\n        assert(sd->type >= 0 && sd->type <= INT32_MAX);\n\n        struct sd_header sd_hd = {\n            .av_type = sd->type,\n            .len = sd->size,\n        };\n\n        if (!write_raw(cache, &sd_hd, sizeof(sd_hd)))\n            goto fail;\n        if (!write_raw(cache, sd->data, sd->size))\n            goto fail;\n    }\n\n    return pos;\n\nfail:\n    // Reset file_size (try not to append crap forever).\n    do_seek(cache, pos);\n    cache->file_size = cache->file_pos;\n    return -1;\n}", "path": "mpv/demux/cache.c", "commit_date": "2020-03-18 00:00:00", "repo_name": "mpv-player/mpv", "stars": 25392, "license": "other", "language": "c", "size": 102697}
{"docstring": "/** @brief libvo Callback: Handle control requests.\n *  @return VO_TRUE on success, VO_NOTIMPL when not implemented\n */\n", "func_signal": "static int control(struct vo *vo, uint32_t request, void *data)", "code": "{\n    d3d_priv *priv = vo->priv;\n\n    switch (request) {\n    case VOCTRL_REDRAW_FRAME:\n        d3d_draw_frame(priv);\n        return VO_TRUE;\n    case VOCTRL_SET_PANSCAN:\n        calc_fs_rect(priv);\n        priv->vo->want_redraw = true;\n        return VO_TRUE;\n    case VOCTRL_SCREENSHOT_WIN:\n        *(struct mp_image **)data = get_window_screenshot(priv);\n        return VO_TRUE;\n    }\n\n    int events = 0;\n    int r = vo_w32_control(vo, &events, request, data);\n\n    if (events & VO_EVENT_RESIZE)\n        resize_d3d(priv);\n\n    if (events & VO_EVENT_EXPOSE)\n        vo->want_redraw = true;\n\n    vo_event(vo, events);\n\n    return r;\n}", "path": "mpv/video/out/vo_direct3d.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "mpv-player/mpv", "stars": 25392, "license": "other", "language": "c", "size": 102697}
{"docstring": "/** @brief libvo Callback: Preinitialize the video card.\n *  Preinit the hardware just enough to be queried about\n *  supported formats.\n *\n *  @return 0 on success, -1 on failure\n */\n", "func_signal": "static int preinit(struct vo *vo)", "code": "{\n    d3d_priv *priv = vo->priv;\n    priv->vo = vo;\n    priv->log = vo->log;\n\n    priv->d3d9_dll = LoadLibraryA(\"d3d9.dll\");\n    if (!priv->d3d9_dll) {\n        MP_ERR(priv, \"Unable to dynamically load d3d9.dll\\n\");\n        goto err_out;\n    }\n\n    priv->pDirect3DCreate9 = (void *)GetProcAddress(priv->d3d9_dll,\n                                                    \"Direct3DCreate9\");\n    if (!priv->pDirect3DCreate9) {\n        MP_ERR(priv, \"Unable to find entry point of Direct3DCreate9\\n\");\n        goto err_out;\n    }\n\n    /* w32_common framework call. Configures window on the screen, gets\n     * fullscreen dimensions and does other useful stuff.\n     */\n    if (!vo_w32_init(vo)) {\n        MP_VERBOSE(priv, \"Configuring onscreen window failed.\\n\");\n        goto err_out;\n    }\n\n    if (!init_d3d(priv))\n        goto err_out;\n\n    return 0;\n\nerr_out:\n    uninit(vo);\n    return -1;\n}", "path": "mpv/video/out/vo_direct3d.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "mpv-player/mpv", "stars": 25392, "license": "other", "language": "c", "size": 102697}
{"docstring": "// Recreate and initialize D3D objects if necessary. The amount of work that\n// needs to be done can be quite different: it could be that full initialization\n// is required, or that some objects need to be created, or that nothing is\n// done.\n", "func_signal": "static bool create_d3d_surfaces(d3d_priv *priv)", "code": "{\n    MP_VERBOSE(priv, \"create_d3d_surfaces called.\\n\");\n\n    if (!priv->d3d_backbuf &&\n        FAILED(IDirect3DDevice9_GetBackBuffer(priv->d3d_device, 0, 0,\n                                              D3DBACKBUFFER_TYPE_MONO,\n                                              &priv->d3d_backbuf))) {\n        MP_ERR(priv, \"Allocating backbuffer failed.\\n\");\n        return 0;\n    }\n\n    if (!d3d_configure_video_objects(priv))\n        return 0;\n\n    /* setup default renderstate */\n    IDirect3DDevice9_SetRenderState(priv->d3d_device,\n                                    D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);\n    IDirect3DDevice9_SetRenderState(priv->d3d_device,\n                                    D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);\n    IDirect3DDevice9_SetRenderState(priv->d3d_device,\n                                    D3DRS_ALPHAFUNC, D3DCMP_GREATER);\n    IDirect3DDevice9_SetRenderState(priv->d3d_device,\n                                    D3DRS_ALPHAREF, (DWORD)0x0);\n    IDirect3DDevice9_SetRenderState(priv->d3d_device,\n                                    D3DRS_LIGHTING, FALSE);\n\n    // we use up to 3 samplers for up to 3 YUV planes\n    // TODO\n    /*\n    for (int n = 0; n < 3; n++) {\n        IDirect3DDevice9_SetSamplerState(priv->d3d_device, n, D3DSAMP_MINFILTER,\n                                         D3DTEXF_LINEAR);\n        IDirect3DDevice9_SetSamplerState(priv->d3d_device, n, D3DSAMP_MAGFILTER,\n                                         D3DTEXF_LINEAR);\n        IDirect3DDevice9_SetSamplerState(priv->d3d_device, n, D3DSAMP_ADDRESSU,\n                                         D3DTADDRESS_CLAMP);\n        IDirect3DDevice9_SetSamplerState(priv->d3d_device, n, D3DSAMP_ADDRESSV,\n                                         D3DTADDRESS_CLAMP);\n    }\n    */\n\n    return 1;\n}", "path": "mpv/video/out/vo_direct3d.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "mpv-player/mpv", "stars": 25392, "license": "other", "language": "c", "size": 102697}
{"docstring": "/** @brief Uninitialize Direct3D and close the window.\n */\n", "func_signal": "static void uninit_d3d(d3d_priv *priv)", "code": "{\n    MP_VERBOSE(priv, \"uninit_d3d called.\\n\");\n\n    destroy_d3d(priv);\n}", "path": "mpv/video/out/vo_direct3d.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "mpv-player/mpv", "stars": 25392, "license": "other", "language": "c", "size": 102697}
{"docstring": "/** @brief Destroy D3D Offscreen and Backbuffer surfaces.\n */\n", "func_signal": "static void destroy_d3d_surfaces(d3d_priv *priv)", "code": "{\n    MP_VERBOSE(priv, \"destroy_d3d_surfaces called.\\n\");\n\n    d3d_destroy_video_objects(priv);\n    d3dtex_release(priv, &priv->osd_texture);\n\n    if (priv->d3d_backbuf)\n        IDirect3DSurface9_Release(priv->d3d_backbuf);\n    priv->d3d_backbuf = NULL;\n\n    priv->d3d_in_scene = false;\n}", "path": "mpv/video/out/vo_direct3d.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "mpv-player/mpv", "stars": 25392, "license": "other", "language": "c", "size": 102697}
{"docstring": "/** @brief Fill D3D Presentation parameters\n */\n", "func_signal": "static void fill_d3d_presentparams(d3d_priv *priv,\n                                   D3DPRESENT_PARAMETERS *present_params)", "code": "{\n    /* Prepare Direct3D initialization parameters. */\n    memset(present_params, 0, sizeof(D3DPRESENT_PARAMETERS));\n    present_params->Windowed               = TRUE;\n    present_params->SwapEffect             =\n        priv->opt_swap_discard ? D3DSWAPEFFECT_DISCARD : D3DSWAPEFFECT_COPY;\n    present_params->Flags                  = D3DPRESENTFLAG_VIDEO;\n    present_params->hDeviceWindow          = vo_w32_hwnd(priv->vo);\n    present_params->BackBufferWidth        = priv->cur_backbuf_width;\n    present_params->BackBufferHeight       = priv->cur_backbuf_height;\n    present_params->MultiSampleType        = D3DMULTISAMPLE_NONE;\n    present_params->PresentationInterval   = D3DPRESENT_INTERVAL_ONE;\n    present_params->BackBufferFormat       = priv->desktop_fmt;\n    present_params->BackBufferCount        = 1;\n    present_params->EnableAutoDepthStencil = FALSE;\n}", "path": "mpv/video/out/vo_direct3d.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "mpv-player/mpv", "stars": 25392, "license": "other", "language": "c", "size": 102697}
{"docstring": "/** @brief Query if movie colorspace is supported by the HW.\n *  @return 0 on failure, device capabilities (not probed\n *          currently) on success.\n */\n", "func_signal": "static int query_format(struct vo *vo, int movie_fmt)", "code": "{\n    d3d_priv *priv = vo->priv;\n    if (!init_rendering_mode(priv, movie_fmt, false))\n        return 0;\n\n    return 1;\n}", "path": "mpv/video/out/vo_direct3d.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "mpv-player/mpv", "stars": 25392, "license": "other", "language": "c", "size": 102697}
{"docstring": "// Resize Direct3D context on window resize.\n// This function also is called when major initializations need to be done.\n", "func_signal": "static bool resize_d3d(d3d_priv *priv)", "code": "{\n    D3DVIEWPORT9 vp = {0, 0, priv->vo->dwidth, priv->vo->dheight, 0, 1};\n\n    MP_VERBOSE(priv, \"resize_d3d %dx%d called.\\n\",\n               priv->vo->dwidth, priv->vo->dheight);\n\n    /* Make sure that backbuffer is large enough to accommodate the new\n       viewport dimensions. Grow it if necessary. */\n\n    bool backbuf_resize = priv->vo->dwidth > priv->cur_backbuf_width ||\n                          priv->vo->dheight > priv->cur_backbuf_height;\n\n    if (priv->opt_exact_backbuffer) {\n        backbuf_resize = priv->vo->dwidth != priv->cur_backbuf_width ||\n                         priv->vo->dheight != priv->cur_backbuf_height;\n    }\n\n    if (backbuf_resize || !priv->d3d_device)\n    {\n        destroy_d3d_surfaces(priv);\n        if (!change_d3d_backbuffer(priv))\n            return 0;\n    }\n\n    if (!priv->d3d_device || !priv->image_format)\n        return 1;\n\n    if (!create_d3d_surfaces(priv))\n        return 0;\n\n    if (FAILED(IDirect3DDevice9_SetViewport(priv->d3d_device, &vp))) {\n        MP_ERR(priv, \"Setting viewport failed.\\n\");\n        return 0;\n    }\n\n    // so that screen coordinates map to D3D ones\n    D3DMATRIX view;\n    d3d_matrix_ortho(&view, 0.5f, vp.Width + 0.5f, vp.Height + 0.5f, 0.5f);\n    IDirect3DDevice9_SetTransform(priv->d3d_device, D3DTS_VIEW, &view);\n\n    calc_fs_rect(priv);\n    priv->vo->want_redraw = true;\n\n    return 1;\n}", "path": "mpv/video/out/vo_direct3d.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "mpv-player/mpv", "stars": 25392, "license": "other", "language": "c", "size": 102697}
{"docstring": "/* Initialize the slow log. This function should be called a single time\n * at server startup. */\n", "func_signal": "void slowlogInit(void)", "code": "{\n    server.slowlog = listCreate();\n    server.slowlog_entry_id = 0;\n    listSetFreeMethod(server.slowlog,slowlogFreeEntry);\n}", "path": "redis/src/slowlog.c", "commit_date": "2019-10-01 00:00:00", "repo_name": "tporadowski/redis", "stars": 8228, "license": "other", "language": "c", "size": 194276}
{"docstring": "/*\n * Allocate a block of virtual memory that is large enough to start with a\n * base_block_t header, followed by an object of specified size and alignment.\n * On success a pointer to the initialized base_block_t header is returned.\n */\n", "func_signal": "static base_block_t *\nbase_block_alloc(tsdn_t *tsdn, base_t *base, extent_hooks_t *extent_hooks,\n    unsigned ind, pszind_t *pind_last, size_t *extent_sn_next, size_t size,\n    size_t alignment)", "code": "{\n\talignment = ALIGNMENT_CEILING(alignment, QUANTUM);\n\tsize_t usize = ALIGNMENT_CEILING(size, alignment);\n\tsize_t header_size = sizeof(base_block_t);\n\tsize_t gap_size = ALIGNMENT_CEILING(header_size, alignment) -\n\t    header_size;\n\t/*\n\t * Create increasingly larger blocks in order to limit the total number\n\t * of disjoint virtual memory ranges.  Choose the next size in the page\n\t * size class series (skipping size classes that are not a multiple of\n\t * HUGEPAGE), or a size large enough to satisfy the requested size and\n\t * alignment, whichever is larger.\n\t */\n\tsize_t min_block_size = HUGEPAGE_CEILING(sz_psz2u(header_size + gap_size\n\t    + usize));\n\tpszind_t pind_next = (*pind_last + 1 < sz_psz2ind(SC_LARGE_MAXCLASS)) ?\n\t    *pind_last + 1 : *pind_last;\n\tsize_t next_block_size = HUGEPAGE_CEILING(sz_pind2sz(pind_next));\n\tsize_t block_size = (min_block_size > next_block_size) ? min_block_size\n\t    : next_block_size;\n\tbase_block_t *block = (base_block_t *)base_map(tsdn, extent_hooks, ind,\n\t    block_size);\n\tif (block == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (metadata_thp_madvise()) {\n\t\tvoid *addr = (void *)block;\n\t\tassert(((uintptr_t)addr & HUGEPAGE_MASK) == 0 &&\n\t\t    (block_size & HUGEPAGE_MASK) == 0);\n\t\tif (opt_metadata_thp == metadata_thp_always) {\n\t\t\tpages_huge(addr, block_size);\n\t\t} else if (opt_metadata_thp == metadata_thp_auto &&\n\t\t    base != NULL) {\n\t\t\t/* base != NULL indicates this is not a new base. */\n\t\t\tmalloc_mutex_lock(tsdn, &base->mtx);\n\t\t\tbase_auto_thp_switch(tsdn, base);\n\t\t\tif (base->auto_thp_switched) {\n\t\t\t\tpages_huge(addr, block_size);\n\t\t\t}\n\t\t\tmalloc_mutex_unlock(tsdn, &base->mtx);\n\t\t}\n\t}\n\n\t*pind_last = sz_psz2ind(block_size);\n\tblock->size = block_size;\n\tblock->next = NULL;\n\tassert(block_size >= header_size);\n\tbase_extent_init(extent_sn_next, &block->extent,\n\t    (void *)((uintptr_t)block + header_size), block_size - header_size);\n\treturn block;\n}", "path": "redis/deps/jemalloc-5.2.1/src/base.c", "commit_date": "2019-10-11 00:00:00", "repo_name": "tporadowski/redis", "stars": 8228, "license": "other", "language": "c", "size": 194276}
{"docstring": "/* Push a new entry into the slow log.\n * This function will make sure to trim the slow log accordingly to the\n * configured max length. */\n", "func_signal": "void slowlogPushEntryIfNeeded(client *c, robj **argv, int argc, PORT_LONGLONG duration)", "code": "{\n    if (server.slowlog_log_slower_than < 0) return; /* Slowlog disabled */\n    if (duration >= server.slowlog_log_slower_than)\n        listAddNodeHead(server.slowlog,\n                        slowlogCreateEntry(c,argv,argc,duration));\n\n    /* Remove old entries if needed. */\n    while (listLength(server.slowlog) > server.slowlog_max_len)\n        listDelNode(server.slowlog,listLast(server.slowlog));\n}", "path": "redis/src/slowlog.c", "commit_date": "2019-10-01 00:00:00", "repo_name": "tporadowski/redis", "stars": 8228, "license": "other", "language": "c", "size": 194276}
{"docstring": "/* Get the socket state. Create if not found. */\n", "func_signal": "iocpSockState* WSIOCP_GetSocketState(int fd)", "code": "{\n    iocpSockState** socketState = (iocpSockState**) FDAPI_GetSocketStatePtr(fd);\n    if (socketState == NULL) {\n        return NULL;\n    } else {\n        if (*socketState == NULL) {\n            // Not found. Do lazy create of socket state.\n            *socketState = (iocpSockState *) CallocMemoryNoCOW(sizeof(iocpSockState));\n            if (*socketState != NULL) {\n                (*socketState)->fd = fd;\n            }\n        }\n        return *socketState;\n    }\n}", "path": "redis/src/Win32_Interop/win32_wsiocp.c", "commit_date": "2019-10-01 00:00:00", "repo_name": "tporadowski/redis", "stars": 8228, "license": "other", "language": "c", "size": 194276}
{"docstring": "/* Listen using extension function to get faster accepts */\n", "func_signal": "int WSIOCP_Listen(int rfd, int backlog)", "code": "{\n    iocpSockState *sockstate = WSIOCP_GetSocketState(rfd);\n    if (sockstate == NULL) {\n        errno = WSAEINVAL;\n        return SOCKET_ERROR;\n    }\n\n    if (WSIOCP_SocketAttach(rfd, sockstate) != 0) {\n        return SOCKET_ERROR;\n    }\n\n    sockstate->masks |= LISTEN_SOCK;\n\n    if (listen(rfd, backlog) != 0) {\n        return SOCKET_ERROR;\n    }\n\n    if (WSIOCP_QueueAccept(rfd) != 0) {\n        return SOCKET_ERROR;\n    }\n\n    return 0;\n}", "path": "redis/src/Win32_Interop/win32_wsiocp.c", "commit_date": "2019-10-01 00:00:00", "repo_name": "tporadowski/redis", "stars": 8228, "license": "other", "language": "c", "size": 194276}
{"docstring": "/* Returns true if the Lua table on top of the stack is exclusively composed\n * of keys from numerical keys from 1 up to N, with N being the total number\n * of elements, without any hole in the middle. */\n", "func_signal": "int table_is_an_array(lua_State *L)", "code": "{\n    int count = 0, max = 0;\n#if LUA_VERSION_NUM < 503\n    lua_Number n;\n#else\n    lua_Integer n;\n#endif\n\n    /* Stack top on function entry */\n    int stacktop;\n\n    stacktop = lua_gettop(L);\n\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        /* Stack: ... key value */\n        lua_pop(L,1); /* Stack: ... key */\n        /* The <= 0 check is valid here because we're comparing indexes. */\n#if LUA_VERSION_NUM < 503\n        if ((LUA_TNUMBER != lua_type(L,-1)) || (n = lua_tonumber(L, -1)) <= 0 ||\n            !IS_INT_EQUIVALENT(n))\n#else\n        if (!lua_isinteger(L,-1) || (n = lua_tointeger(L, -1)) <= 0)\n#endif\n        {\n            lua_settop(L, stacktop);\n            return 0;\n        }\n        max = (n > max ? n : max);\n        count++;\n    }\n    /* We have the total number of elements in \"count\". Also we have\n     * the max index encountered in \"max\". We can't reach this code\n     * if there are indexes <= 0. If you also note that there can not be\n     * repeated keys into a table, you have that if max==count you are sure\n     * that there are all the keys form 1 to count (both included). */\n    lua_settop(L, stacktop);\n    return max == count;\n}", "path": "redis/deps/lua/src/lua_cmsgpack.c", "commit_date": "2020-03-31 00:00:00", "repo_name": "tporadowski/redis", "stars": 8228, "license": "other", "language": "c", "size": 194276}
{"docstring": "/* If the length operator returns non-zero, that is, there is at least\n * an object at key '1', we serialize to message pack list. Otherwise\n * we use a map. */\n", "func_signal": "void mp_encode_lua_table(lua_State *L, mp_buf *buf, int level)", "code": "{\n    if (table_is_an_array(L))\n        mp_encode_lua_table_as_array(L,buf,level);\n    else\n        mp_encode_lua_table_as_map(L,buf,level);\n}", "path": "redis/deps/lua/src/lua_cmsgpack.c", "commit_date": "2020-03-31 00:00:00", "repo_name": "tporadowski/redis", "stars": 8228, "license": "other", "language": "c", "size": 194276}
{"docstring": "/* For each asynch socket, need to associate completion port */\n", "func_signal": "int WSIOCP_SocketAttach(int fd, iocpSockState *socketState)", "code": "{\n    if (socketState == NULL) {\n        socketState = WSIOCP_GetSocketState(fd);\n    }\n\n    if (iocph != NULL && socketState != NULL) {\n        if (FDAPI_SocketAttachIOCP(fd, iocph)) {\n            socketState->masks = SOCKET_ATTACHED;\n            socketState->wreqs = 0;\n            return 0;\n        }\n    } else {\n        errno = WSAEINVAL;\n    }\n\n    return -1;\n}", "path": "redis/src/Win32_Interop/win32_wsiocp.c", "commit_date": "2019-10-01 00:00:00", "repo_name": "tporadowski/redis", "stars": 8228, "license": "other", "language": "c", "size": 194276}
{"docstring": "/* reverse the interleave process\n * derived from http://stackoverflow.com/questions/4909263\n */\n", "func_signal": "static inline uint64_t deinterleave64(uint64_t interleaved)", "code": "{\n    static const uint64_t B[] = {0x5555555555555555ULL, 0x3333333333333333ULL,\n                                 0x0F0F0F0F0F0F0F0FULL, 0x00FF00FF00FF00FFULL,\n                                 0x0000FFFF0000FFFFULL, 0x00000000FFFFFFFFULL};\n    static const unsigned int S[] = {0, 1, 2, 4, 8, 16};\n\n    uint64_t x = interleaved;\n    uint64_t y = interleaved >> 1;\n\n    x = (x | (x >> S[0])) & B[0];\n    y = (y | (y >> S[0])) & B[0];\n\n    x = (x | (x >> S[1])) & B[1];\n    y = (y | (y >> S[1])) & B[1];\n\n    x = (x | (x >> S[2])) & B[2];\n    y = (y | (y >> S[2])) & B[2];\n\n    x = (x | (x >> S[3])) & B[3];\n    y = (y | (y >> S[3])) & B[3];\n\n    x = (x | (x >> S[4])) & B[4];\n    y = (y | (y >> S[4])) & B[4];\n\n    x = (x | (x >> S[5])) & B[5];\n    y = (y | (y >> S[5])) & B[5];\n\n    return x | (y << 32);\n}", "path": "redis/src/geohash.c", "commit_date": "2019-10-05 00:00:00", "repo_name": "tporadowski/redis", "stars": 8228, "license": "other", "language": "c", "size": 194276}
{"docstring": "/*\n * Allocate an extent that is at least as large as specified size, with\n * specified alignment.\n */\n", "func_signal": "static extent_t *\nbase_extent_alloc(tsdn_t *tsdn, base_t *base, size_t size, size_t alignment)", "code": "{\n\tmalloc_mutex_assert_owner(tsdn, &base->mtx);\n\n\textent_hooks_t *extent_hooks = base_extent_hooks_get(base);\n\t/*\n\t * Drop mutex during base_block_alloc(), because an extent hook will be\n\t * called.\n\t */\n\tmalloc_mutex_unlock(tsdn, &base->mtx);\n\tbase_block_t *block = base_block_alloc(tsdn, base, extent_hooks,\n\t    base_ind_get(base), &base->pind_last, &base->extent_sn_next, size,\n\t    alignment);\n\tmalloc_mutex_lock(tsdn, &base->mtx);\n\tif (block == NULL) {\n\t\treturn NULL;\n\t}\n\tblock->next = base->blocks;\n\tbase->blocks = block;\n\tif (config_stats) {\n\t\tbase->allocated += sizeof(base_block_t);\n\t\tbase->resident += PAGE_CEILING(sizeof(base_block_t));\n\t\tbase->mapped += block->size;\n\t\tif (metadata_thp_madvise() &&\n\t\t    !(opt_metadata_thp == metadata_thp_auto\n\t\t      && !base->auto_thp_switched)) {\n\t\t\tassert(base->n_thp > 0);\n\t\t\tbase->n_thp += HUGEPAGE_CEILING(sizeof(base_block_t)) >>\n\t\t\t    LG_HUGEPAGE;\n\t\t}\n\t\tassert(base->allocated <= base->resident);\n\t\tassert(base->resident <= base->mapped);\n\t\tassert(base->n_thp << LG_HUGEPAGE <= base->mapped);\n\t}\n\treturn &block->extent;\n}", "path": "redis/deps/jemalloc-5.2.1/src/base.c", "commit_date": "2019-10-11 00:00:00", "repo_name": "tporadowski/redis", "stars": 8228, "license": "other", "language": "c", "size": 194276}
{"docstring": "/* Wrapper for send.\n * Enables use of WSA Send to get IOCP notification of completion.\n * Returns -1 with errno = WSA_IO_PENDING if callback will be invoked later */\n", "func_signal": "int WSIOCP_SocketSend(int fd, char *buf, int len, void *eventLoop,\n                      void *client, void *data, void *proc)", "code": "{\n    iocpSockState *sockstate;\n    int result;\n    asendreq *areq;\n    DWORD bytesSent = 0;\n\n    sockstate = WSIOCP_GetSocketState(fd);\n\n    if (sockstate != NULL &&\n        (sockstate->masks & CONNECT_PENDING)) {\n        aeWait(fd, AE_WRITABLE, 50);\n    }\n\n    // If not an async socket, do normal send\n    if (sockstate == NULL ||\n        (sockstate->masks & SOCKET_ATTACHED) == 0 ||\n        proc == NULL) {\n        result = (int) write(fd, buf, len);\n        if (result == SOCKET_ERROR) {\n            errno = FDAPI_WSAGetLastError();\n        }\n        return result;\n    }\n\n    // Use overlapped structure to send using IOCP\n    areq = (asendreq *) CallocMemoryNoCOW(sizeof(asendreq));\n    areq->wbuf.len = len;\n    areq->wbuf.buf = buf;\n    areq->eventLoop = (aeEventLoop *) eventLoop;\n    areq->req.client = client;\n    areq->req.data = data;\n    areq->req.len = len;\n    areq->req.buf = buf;\n    areq->proc = (aeFileProc *) proc;\n\n    result = FDAPI_WSASend(fd,\n                           &areq->wbuf,\n                           1,\n                           &bytesSent,\n                           0,\n                           &areq->ov,\n                           NULL);\n\t\n    if (SUCCEEDED_WITH_IOCP(result == 0)) {\n        errno = WSA_IO_PENDING;\n        sockstate->wreqs++;\n        listAddNodeTail(&sockstate->wreqlist, areq);\n    } else {\n        errno = FDAPI_WSAGetLastError();\n        FreeMemoryNoCOW(areq);\n    }\n    return SOCKET_ERROR;\n}", "path": "redis/src/Win32_Interop/win32_wsiocp.c", "commit_date": "2019-10-01 00:00:00", "repo_name": "tporadowski/redis", "stars": 8228, "license": "other", "language": "c", "size": 194276}
{"docstring": "/* --------------------------- Lua types encoding --------------------------- */\n", "func_signal": "void mp_encode_lua_string(lua_State *L, mp_buf *buf)", "code": "{\n    size_t len;\n    const char *s;\n\n    s = lua_tolstring(L,-1,&len);\n    mp_encode_bytes(L,buf,(const unsigned char*)s,len);\n}", "path": "redis/deps/lua/src/lua_cmsgpack.c", "commit_date": "2020-03-31 00:00:00", "repo_name": "tporadowski/redis", "stars": 8228, "license": "other", "language": "c", "size": 194276}
{"docstring": "/* Closes the socket state or sets the CLOSE_PENDING mask bit.\n * Returns TRUE if closed, FALSE if pending. */\n", "func_signal": "BOOL WSIOCP_CloseSocketState(iocpSockState* socketState)", "code": "{\n    socketState->masks &= ~(SOCKET_ATTACHED | AE_WRITABLE | AE_READABLE);\n    if (socketState->wreqs == 0 &&\n        (socketState->masks & (READ_QUEUED | CONNECT_PENDING)) == 0) {\n        FreeMemoryNoCOW(socketState);\n        return TRUE;\n    } else {\n        socketState->masks |= CLOSE_PENDING;\n        return FALSE;\n    }\n}", "path": "redis/src/Win32_Interop/win32_wsiocp.c", "commit_date": "2019-10-01 00:00:00", "repo_name": "tporadowski/redis", "stars": 8228, "license": "other", "language": "c", "size": 194276}
{"docstring": "/* Lua 5.3 has a built in 64-bit integer type */\n", "func_signal": "void mp_encode_lua_integer(lua_State *L, mp_buf *buf)", "code": "{\n#if (LUA_VERSION_NUM < 503) && BITS_32\n    lua_Number i = lua_tonumber(L,-1);\n#else\n    lua_Integer i = lua_tointeger(L,-1);\n#endif\n    mp_encode_int(L, buf, (int64_t)i);\n}", "path": "redis/deps/lua/src/lua_cmsgpack.c", "commit_date": "2020-03-31 00:00:00", "repo_name": "tporadowski/redis", "stars": 8228, "license": "other", "language": "c", "size": 194276}
{"docstring": "/* Create a new slowlog entry.\n * Incrementing the ref count of all the objects retained is up to\n * this function. */\n", "func_signal": "slowlogEntry *slowlogCreateEntry(client *c, robj **argv, int argc, PORT_LONGLONG duration)", "code": "{\n    slowlogEntry *se = zmalloc(sizeof(*se));\n    int j, slargc = argc;\n\n    if (slargc > SLOWLOG_ENTRY_MAX_ARGC) slargc = SLOWLOG_ENTRY_MAX_ARGC;\n    se->argc = slargc;\n    se->argv = zmalloc(sizeof(robj*)*slargc);\n    for (j = 0; j < slargc; j++) {\n        /* Logging too many arguments is a useless memory waste, so we stop\n         * at SLOWLOG_ENTRY_MAX_ARGC, but use the last argument to specify\n         * how many remaining arguments there were in the original command. */\n        if (slargc != argc && j == slargc-1) {\n            se->argv[j] = createObject(OBJ_STRING,\n                sdscatprintf(sdsempty(),\"... (%d more arguments)\",\n                argc-slargc+1));\n        } else {\n            /* Trim too long strings as well... */\n            if (argv[j]->type == OBJ_STRING &&\n                sdsEncodedObject(argv[j]) &&\n                sdslen(argv[j]->ptr) > SLOWLOG_ENTRY_MAX_STRING)\n            {\n                sds s = sdsnewlen(argv[j]->ptr, SLOWLOG_ENTRY_MAX_STRING);\n\n                s = sdscatprintf(s,\"... (%Iu more bytes)\",                      WIN_PORT_FIX /* %lu -> %Iu */\n                    (PORT_ULONG)\n                    sdslen(argv[j]->ptr) - SLOWLOG_ENTRY_MAX_STRING);\n                se->argv[j] = createObject(OBJ_STRING,s);\n            } else if (argv[j]->refcount == OBJ_SHARED_REFCOUNT) {\n                se->argv[j] = argv[j];\n            } else {\n                /* Here we need to dupliacate the string objects composing the\n                 * argument vector of the command, because those may otherwise\n                 * end shared with string objects stored into keys. Having\n                 * shared objects between any part of Redis, and the data\n                 * structure holding the data, is a problem: FLUSHALL ASYNC\n                 * may release the shared string object and create a race. */\n                se->argv[j] = dupStringObject(argv[j]);\n            }\n        }\n    }\n    se->time = time(NULL);\n    se->duration = duration;\n    se->id = server.slowlog_entry_id++;\n    se->peerid = sdsnew(getClientPeerId(c));\n    se->cname = c->name ? sdsnew(c->name->ptr) : sdsempty();\n    return se;\n}", "path": "redis/src/slowlog.c", "commit_date": "2019-10-01 00:00:00", "repo_name": "tporadowski/redis", "stars": 8228, "license": "other", "language": "c", "size": 194276}
{"docstring": "/*\n * Packs all arguments as a stream for multiple upacking later.\n * Returns error if no arguments provided.\n */\n", "func_signal": "int mp_pack(lua_State *L)", "code": "{\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n\n    if (nargs == 0)\n        return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n\n    if (!lua_checkstack(L, nargs))\n        return luaL_argerror(L, 0, \"Too many arguments for MessagePack pack.\");\n\n    buf = mp_buf_new(L);\n    for(i = 1; i <= nargs; i++) {\n        /* Copy argument i to top of stack for _encode processing;\n         * the encode function pops it from the stack when complete. */\n        luaL_checkstack(L, 1, \"in function mp_check\");\n        lua_pushvalue(L, i);\n\n        mp_encode_lua_type(L,buf,0);\n\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n\n        /* Reuse the buffer for the next operation by\n         * setting its free count to the total buffer size\n         * and the current position to zero. */\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n\n    /* Concatenate all nargs buffers together */\n    lua_concat(L, nargs);\n    return 1;\n}", "path": "redis/deps/lua/src/lua_cmsgpack.c", "commit_date": "2020-03-31 00:00:00", "repo_name": "tporadowski/redis", "stars": 8228, "license": "other", "language": "c", "size": 194276}
{"docstring": "/* For non-blocking connect with IOCP */\n", "func_signal": "int WSIOCP_SocketConnect(int fd, const SOCKADDR_STORAGE *socketAddrStorage)", "code": "{\n    const GUID wsaid_connectex = WSAID_CONNECTEX;\n    DWORD result;\n    iocpSockState *sockstate;\n\n    if ((sockstate = WSIOCP_GetSocketState(fd)) == NULL) {\n        errno = WSAEINVAL;\n        return SOCKET_ERROR;\n    }\n\n    if (WSIOCP_SocketAttach(fd, sockstate) != 0) {\n        return SOCKET_ERROR;\n    }\n\n    memset(&sockstate->ov_read, 0, sizeof(sockstate->ov_read));\n    \n    // Need to bind sock before connectex\n    switch (socketAddrStorage->ss_family) {\n        case AF_INET:\n        {\n            SOCKADDR_IN addr;\n            memset(&addr, 0, sizeof(SOCKADDR_IN));\n            addr.sin_family = socketAddrStorage->ss_family;\n            addr.sin_addr.S_un.S_addr = INADDR_ANY;\n            addr.sin_port = 0;\n            result = bind(fd, (SOCKADDR*) &addr, sizeof(addr));\n\n            result = FDAPI_ConnectEx(fd,\n                                     (SOCKADDR*) socketAddrStorage,\n                                     sizeof(SOCKADDR_IN),\n                                     NULL,\n                                     0,\n                                     NULL,\n                                     &sockstate->ov_read);\n            break;\n        }\n        case AF_INET6:\n        {\n            SOCKADDR_IN6 addr;\n            memset(&addr, 0, sizeof(SOCKADDR_IN6));\n            addr.sin6_family = socketAddrStorage->ss_family;\n            memset(&(addr.sin6_addr.u.Byte), 0, 16);\n            addr.sin6_port = 0;\n            result = bind(fd, (SOCKADDR*) &addr, sizeof(addr));\n\n            result = FDAPI_ConnectEx(fd,\n                                     (SOCKADDR*) socketAddrStorage,\n                                     sizeof(SOCKADDR_IN6),\n                                     NULL,\n                                     0,\n                                     NULL,\n                                     &sockstate->ov_read);\n            break;\n        }\n        default:\n        {\n            ASSERT(socketAddrStorage->ss_family == AF_INET || socketAddrStorage->ss_family == AF_INET6);\n            errno = WSAEINVAL;\n            return SOCKET_ERROR;\n        }\n    }\n\n    if (result != TRUE) {\n        result = FDAPI_WSAGetLastError();\n        if (result == ERROR_IO_PENDING) {\n            errno = WSA_IO_PENDING;\n            sockstate->masks |= CONNECT_PENDING;\n        } else {\n            errno = result;\n            return SOCKET_ERROR;\n        }\n    }\n    return 0;\n}", "path": "redis/src/Win32_Interop/win32_wsiocp.c", "commit_date": "2019-10-01 00:00:00", "repo_name": "tporadowski/redis", "stars": 8228, "license": "other", "language": "c", "size": 194276}
{"docstring": "/* After doing a read, the caller needs to call this method in\n * order to continue to check for read events.\n * This is not necessary if the caller will delete read events */\n", "func_signal": "int WSIOCP_QueueNextRead(int fd)", "code": "{\n    iocpSockState *sockstate;\n    int result;\n    WSABUF zreadbuf;\n    DWORD bytesReceived = 0;\n    DWORD recvFlags = 0;\n\n    if ((sockstate = WSIOCP_GetSocketState(fd)) == NULL) {\n        errno = WSAEINVAL;\n        return -1;\n    }\n    if ((sockstate->masks & SOCKET_ATTACHED) == 0) {\n        return 0;\n    }\n\n    // Use zero length read with overlapped to get notification\n    // of when data is available\n    memset(&sockstate->ov_read, 0, sizeof(sockstate->ov_read));\n\n    zreadbuf.buf = zreadchar;\n    zreadbuf.len = 0;\n    result = FDAPI_WSARecv(fd,\n                           &zreadbuf,\n                           1,\n                           &bytesReceived,\n                           &recvFlags,\n                           &sockstate->ov_read,\n                           NULL);\n    if (SUCCEEDED_WITH_IOCP(result == 0)){\n        sockstate->masks |= READ_QUEUED;\n    } else {\n        errno = FDAPI_WSAGetLastError();\n        sockstate->masks &= ~READ_QUEUED;\n        return -1;\n    }\n    return 0;\n}", "path": "redis/src/Win32_Interop/win32_wsiocp.c", "commit_date": "2019-10-01 00:00:00", "repo_name": "tporadowski/redis", "stars": 8228, "license": "other", "language": "c", "size": 194276}
{"docstring": "/* Reverse memory bytes if arch is little endian. Given the conceptual\n * simplicity of the Lua build system we prefer check for endianess at runtime.\n * The performance difference should be acceptable. */\n", "func_signal": "void memrevifle(void *ptr, size_t len)", "code": "{\n    unsigned char   *p = (unsigned char *)ptr,\n                    *e = (unsigned char *)p+len-1,\n                    aux;\n    int test = 1;\n    unsigned char *testp = (unsigned char*) &test;\n\n    if (testp[0] == 0) return; /* Big endian, nothing to do. */\n    len /= 2;\n    while(len--) {\n        aux = *p;\n        *p = *e;\n        *e = aux;\n        p++;\n        e--;\n    }\n}", "path": "redis/deps/lua/src/lua_cmsgpack.c", "commit_date": "2020-03-31 00:00:00", "repo_name": "tporadowski/redis", "stars": 8228, "license": "other", "language": "c", "size": 194276}
{"docstring": "/* The SLOWLOG command. Implements all the subcommands needed to handle the\n * Redis slow log. */\n", "func_signal": "void slowlogCommand(client *c)", "code": "{\n    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\"help\")) {\n        const char *help[] = {\n\"GET [count] -- Return top entries from the slowlog (default: 10).\"\n\"    Entries are made of:\",\n\"    id, timestamp, time in microseconds, arguments array, client IP and port, client name\",\n\"LEN -- Return the length of the slowlog.\",\n\"RESET -- Reset the slowlog.\",\nNULL\n        };\n        addReplyHelp(c, help);\n    } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\"reset\")) {\n        slowlogReset();\n        addReply(c,shared.ok);\n    } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\"len\")) {\n        addReplyLongLong(c,listLength(server.slowlog));\n    } else if ((c->argc == 2 || c->argc == 3) &&\n               !strcasecmp(c->argv[1]->ptr,\"get\"))\n    {\n        PORT_LONG count = 10, sent = 0;\n        listIter li;\n        void *totentries;\n        listNode *ln;\n        slowlogEntry *se;\n\n        if (c->argc == 3 &&\n            getLongFromObjectOrReply(c,c->argv[2],&count,NULL) != C_OK)\n            return;\n\n        listRewind(server.slowlog,&li);\n        totentries = addDeferredMultiBulkLength(c);\n        while(count-- && (ln = listNext(&li))) {\n            int j;\n\n            se = ln->value;\n            addReplyMultiBulkLen(c,6);\n            addReplyLongLong(c,se->id);\n            addReplyLongLong(c,se->time);\n            addReplyLongLong(c,se->duration);\n            addReplyMultiBulkLen(c,se->argc);\n            for (j = 0; j < se->argc; j++)\n                addReplyBulk(c,se->argv[j]);\n            addReplyBulkCBuffer(c,se->peerid,sdslen(se->peerid));\n            addReplyBulkCBuffer(c,se->cname,sdslen(se->cname));\n            sent++;\n        }\n        setDeferredMultiBulkLength(c,totentries,sent);\n    } else {\n        addReplySubcommandSyntaxError(c);\n    }\n}", "path": "redis/src/slowlog.c", "commit_date": "2019-10-01 00:00:00", "repo_name": "tporadowski/redis", "stars": 8228, "license": "other", "language": "c", "size": 194276}
{"docstring": "/*\n * DeferErrorIfFromClauseRecurs returns a deferred error if the\n * given query is not suitable for subquery pushdown.\n *\n * While planning sublinks, we rely on Postgres in the sense that it converts some of\n * sublinks into joins.\n *\n * In some cases, sublinks are pulled up and converted into outer joins. Those cases\n * are already handled with DeferredErrorIfUnsupportedRecurringTuplesJoin().\n *\n * If the sublinks are not pulled up, we should still error out in if the expression\n * in the FROM clause would recur for every shard in a subquery on the WHERE clause.\n *\n * Otherwise, the result would include duplicate rows.\n */\n", "func_signal": "static DeferredErrorMessage *\nDeferErrorIfFromClauseRecurs(Query *queryTree)", "code": "{\n\tif (!queryTree->hasSubLinks)\n\t{\n\t\treturn NULL;\n\t}\n\n\tRecurringTuplesType recurType = FromClauseRecurringTupleType(queryTree);\n\tif (recurType == RECURRING_TUPLES_REFERENCE_TABLE)\n\t{\n\t\treturn DeferredError(ERRCODE_FEATURE_NOT_SUPPORTED,\n\t\t\t\t\t\t\t \"correlated subqueries are not supported when \"\n\t\t\t\t\t\t\t \"the FROM clause contains a reference table\", NULL, NULL);\n\t}\n\telse if (recurType == RECURRING_TUPLES_FUNCTION)\n\t{\n\t\treturn DeferredError(ERRCODE_FEATURE_NOT_SUPPORTED,\n\t\t\t\t\t\t\t \"correlated subqueries are not supported when \"\n\t\t\t\t\t\t\t \"the FROM clause contains a set returning function\", NULL,\n\t\t\t\t\t\t\t NULL);\n\t}\n\telse if (recurType == RECURRING_TUPLES_RESULT_FUNCTION)\n\t{\n\t\treturn DeferredError(ERRCODE_FEATURE_NOT_SUPPORTED,\n\t\t\t\t\t\t\t \"correlated subqueries are not supported when \"\n\t\t\t\t\t\t\t \"the FROM clause contains a CTE or subquery\", NULL, NULL);\n\t}\n\telse if (recurType == RECURRING_TUPLES_EMPTY_JOIN_TREE)\n\t{\n\t\treturn DeferredError(ERRCODE_FEATURE_NOT_SUPPORTED,\n\t\t\t\t\t\t\t \"correlated subqueries are not supported when \"\n\t\t\t\t\t\t\t \"the FROM clause contains a subquery without FROM\", NULL,\n\t\t\t\t\t\t\t NULL);\n\t}\n\n\t/*\n\t * We get here when there is neither a distributed table, nor recurring tuples.\n\t * That usually means that there isn't a FROM at all (only sublinks), this\n\t * implies that queryTree is recurring, but whether this is a problem depends\n\t * on outer queries, not on queryTree itself.\n\t */\n\n\treturn NULL;\n}", "path": "citus/src/backend/distributed/planner/query_pushdown_planning.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "citusdata/citus", "stars": 9511, "license": "agpl-3.0", "language": "c", "size": 63059}
{"docstring": "/*\n * JoinTreeContainsSubqueryWalker returns true if the input joinTreeNode\n * references to a subquery. Otherwise, recurses into the expression.\n */\n", "func_signal": "static bool\nJoinTreeContainsSubqueryWalker(Node *joinTreeNode, void *context)", "code": "{\n\tif (joinTreeNode == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\tif (IsA(joinTreeNode, RangeTblRef))\n\t{\n\t\tQuery *query = (Query *) context;\n\n\t\tRangeTblRef *rangeTableRef = (RangeTblRef *) joinTreeNode;\n\t\tRangeTblEntry *rangeTableEntry = rt_fetch(rangeTableRef->rtindex, query->rtable);\n\n\t\tif (rangeTableEntry->rtekind == RTE_SUBQUERY)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn expression_tree_walker(joinTreeNode, JoinTreeContainsSubqueryWalker, context);\n}", "path": "citus/src/backend/distributed/planner/query_pushdown_planning.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "citusdata/citus", "stars": 9511, "license": "agpl-3.0", "language": "c", "size": 63059}
{"docstring": "/*\n * ExtractSetOperationStatementWalker walks over a set operations statment,\n * and finds all set operations in the tree.\n */\n", "func_signal": "static bool\nExtractSetOperationStatmentWalker(Node *node, List **setOperationList)", "code": "{\n\tif (node == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\tif (IsA(node, SetOperationStmt))\n\t{\n\t\tSetOperationStmt *setOperation = (SetOperationStmt *) node;\n\n\t\t(*setOperationList) = lappend(*setOperationList, setOperation);\n\t}\n\n\tbool walkerResult = expression_tree_walker(node,\n\t\t\t\t\t\t\t\t\t\t\t   ExtractSetOperationStatmentWalker,\n\t\t\t\t\t\t\t\t\t\t\t   setOperationList);\n\n\treturn walkerResult;\n}", "path": "citus/src/backend/distributed/planner/query_pushdown_planning.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "citusdata/citus", "stars": 9511, "license": "agpl-3.0", "language": "c", "size": 63059}
{"docstring": "/*\n * DeferErrorIfUnsupportedTableCombination checks if the given query tree contains any\n * unsupported range table combinations. For this, the function walks over all\n * range tables in the join tree, and checks if they correspond to simple relations\n * or subqueries. It also checks if there is a join between a regular table and\n * a subquery and if join is on more than two range table entries. If any error is found,\n * a deferred error is returned. Else, NULL is returned.\n */\n", "func_signal": "static DeferredErrorMessage *\nDeferErrorIfUnsupportedTableCombination(Query *queryTree)", "code": "{\n\tList *rangeTableList = queryTree->rtable;\n\tList *joinTreeTableIndexList = NIL;\n\tint joinTreeTableIndex = 0;\n\tbool unsupportedTableCombination = false;\n\tchar *errorDetail = NULL;\n\n\t/*\n\t * Extract all range table indexes from the join tree. Note that sub-queries\n\t * that get pulled up by PostgreSQL don't appear in this join tree.\n\t */\n\tExtractRangeTableIndexWalker((Node *) queryTree->jointree,\n\t\t\t\t\t\t\t\t &joinTreeTableIndexList);\n\n\tforeach_int(joinTreeTableIndex, joinTreeTableIndexList)\n\t{\n\t\t/*\n\t\t * Join tree's range table index starts from 1 in the query tree. But,\n\t\t * list indexes start from 0.\n\t\t */\n\t\tint rangeTableListIndex = joinTreeTableIndex - 1;\n\n\t\tRangeTblEntry *rangeTableEntry =\n\t\t\t(RangeTblEntry *) list_nth(rangeTableList, rangeTableListIndex);\n\n\t\t/*\n\t\t * Check if the range table in the join tree is a simple relation, a\n\t\t * subquery, or immutable function.\n\t\t */\n\t\tif (rangeTableEntry->rtekind == RTE_RELATION ||\n\t\t\trangeTableEntry->rtekind == RTE_SUBQUERY\n#if PG_VERSION_NUM >= PG_VERSION_12\n\t\t\t|| rangeTableEntry->rtekind == RTE_RESULT\n#endif\n\t\t\t)\n\t\t{\n\t\t\t/* accepted */\n\t\t}\n\t\telse if (rangeTableEntry->rtekind == RTE_FUNCTION)\n\t\t{\n\t\t\tList *functionList = rangeTableEntry->functions;\n\n\t\t\tif (list_length(functionList) == 1 &&\n\t\t\t\tContainsReadIntermediateResultFunction(linitial(functionList)))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * The read_intermediate_result function is volatile, but we know\n\t\t\t\t * it has the same result across all nodes and can therefore treat\n\t\t\t\t * it as a reference table.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse if (contain_mutable_functions((Node *) functionList))\n\t\t\t{\n\t\t\t\tunsupportedTableCombination = true;\n\t\t\t\terrorDetail = \"Only immutable functions can be used as a table \"\n\t\t\t\t\t\t\t  \"expressions in a multi-shard query\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* immutable function RTEs are treated as reference tables */\n\t\t\t}\n\t\t}\n\t\telse if (rangeTableEntry->rtekind == RTE_CTE)\n\t\t{\n\t\t\tunsupportedTableCombination = true;\n\t\t\terrorDetail = \"CTEs in subqueries are currently unsupported\";\n\t\t\tbreak;\n\t\t}\n\t\telse if (rangeTableEntry->rtekind == RTE_VALUES)\n\t\t{\n\t\t\tunsupportedTableCombination = true;\n\t\t\terrorDetail = \"VALUES in multi-shard queries is currently unsupported\";\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tunsupportedTableCombination = true;\n\t\t\terrorDetail = \"Table expressions other than relations, subqueries, \"\n\t\t\t\t\t\t  \"and immutable functions are currently unsupported\";\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* finally check and error out if not satisfied */\n\tif (unsupportedTableCombination)\n\t{\n\t\treturn DeferredError(ERRCODE_FEATURE_NOT_SUPPORTED,\n\t\t\t\t\t\t\t \"cannot push down this subquery\",\n\t\t\t\t\t\t\t errorDetail, NULL);\n\t}\n\n\treturn NULL;\n}", "path": "citus/src/backend/distributed/planner/query_pushdown_planning.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "citusdata/citus", "stars": 9511, "license": "agpl-3.0", "language": "c", "size": 63059}
{"docstring": "/*\n * IsFunctionRTE determines whether the given node is a function RTE.\n */\n", "func_signal": "static bool\nIsFunctionRTE(Node *node)", "code": "{\n\tif (IsA(node, RangeTblEntry))\n\t{\n\t\tRangeTblEntry *rangeTblEntry = (RangeTblEntry *) node;\n\n\t\tif (rangeTblEntry->rtekind == RTE_FUNCTION)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}", "path": "citus/src/backend/distributed/planner/query_pushdown_planning.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "citusdata/citus", "stars": 9511, "license": "agpl-3.0", "language": "c", "size": 63059}
{"docstring": "/*\n * HasEmptyJoinTree returns whether the query selects from anything.\n */\n", "func_signal": "bool\nHasEmptyJoinTree(Query *query)", "code": "{\n\tif (query->rtable == NIL)\n\t{\n\t\treturn true;\n\t}\n\n#if PG_VERSION_NUM >= PG_VERSION_12\n\telse if (list_length(query->rtable) == 1)\n\t{\n\t\tRangeTblEntry *rte = (RangeTblEntry *) linitial(query->rtable);\n\t\tif (rte->rtekind == RTE_RESULT)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n#endif\n\n\treturn false;\n}", "path": "citus/src/backend/distributed/planner/query_pushdown_planning.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "citusdata/citus", "stars": 9511, "license": "agpl-3.0", "language": "c", "size": 63059}
{"docstring": "/*\n * DeferErrorIfContainsUnsupportedSubqueryPushdown iterates on the query's subquery\n * entry list and uses helper functions to check if we can push down subquery\n * to worker nodes. These helper functions returns a deferred error if we\n * cannot push down the subquery.\n */\n", "func_signal": "DeferredErrorMessage *\nDeferErrorIfUnsupportedSubqueryPushdown(Query *originalQuery,\n\t\t\t\t\t\t\t\t\t\tPlannerRestrictionContext *\n\t\t\t\t\t\t\t\t\t\tplannerRestrictionContext)", "code": "{\n\tbool outerMostQueryHasLimit = false;\n\tListCell *subqueryCell = NULL;\n\tList *subqueryList = NIL;\n\n\tif (originalQuery->limitCount != NULL)\n\t{\n\t\touterMostQueryHasLimit = true;\n\t}\n\n\t/*\n\t * We're checking two things here:\n\t *    (i)   If the query contains a top level union, ensure that all leaves\n\t *          return the partition key at the same position\n\t *    (ii)  Else, check whether all relations joined on the partition key or not\n\t */\n\tif (ContainsUnionSubquery(originalQuery))\n\t{\n\t\tif (!SafeToPushdownUnionSubquery(plannerRestrictionContext))\n\t\t{\n\t\t\treturn DeferredError(ERRCODE_FEATURE_NOT_SUPPORTED,\n\t\t\t\t\t\t\t\t \"cannot pushdown the subquery since not all subqueries \"\n\t\t\t\t\t\t\t\t \"in the UNION have the partition column in the same \"\n\t\t\t\t\t\t\t\t \"position\",\n\t\t\t\t\t\t\t\t \"Each leaf query of the UNION should return the \"\n\t\t\t\t\t\t\t\t \"partition column in the same position and all joins \"\n\t\t\t\t\t\t\t\t \"must be on the partition column\",\n\t\t\t\t\t\t\t\t NULL);\n\t\t}\n\t}\n\telse if (!RestrictionEquivalenceForPartitionKeys(plannerRestrictionContext))\n\t{\n\t\treturn DeferredError(ERRCODE_FEATURE_NOT_SUPPORTED,\n\t\t\t\t\t\t\t \"complex joins are only supported when all distributed tables are \"\n\t\t\t\t\t\t\t \"co-located and joined on their distribution columns\",\n\t\t\t\t\t\t\t NULL, NULL);\n\t}\n\n\t/* we shouldn't allow reference tables in the FROM clause when the query has sublinks */\n\tDeferredErrorMessage *error = DeferErrorIfFromClauseRecurs(originalQuery);\n\tif (error)\n\t{\n\t\treturn error;\n\t}\n\n\t/* we shouldn't allow reference tables in the outer part of outer joins */\n\terror = DeferredErrorIfUnsupportedRecurringTuplesJoin(plannerRestrictionContext);\n\tif (error)\n\t{\n\t\treturn error;\n\t}\n\n\t/*\n\t * We first extract all the queries that appear in the original query. Later,\n\t * we delete the original query given that error rules does not apply to the\n\t * top level query. For instance, we could support any LIMIT/ORDER BY on the\n\t * top level query.\n\t */\n\tExtractQueryWalker((Node *) originalQuery, &subqueryList);\n\tsubqueryList = list_delete(subqueryList, originalQuery);\n\n\t/* iterate on the subquery list and error out accordingly */\n\tforeach(subqueryCell, subqueryList)\n\t{\n\t\tQuery *subquery = lfirst(subqueryCell);\n\t\terror = DeferErrorIfCannotPushdownSubquery(subquery,\n\t\t\t\t\t\t\t\t\t\t\t\t   outerMostQueryHasLimit);\n\t\tif (error)\n\t\t{\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn NULL;\n}", "path": "citus/src/backend/distributed/planner/query_pushdown_planning.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "citusdata/citus", "stars": 9511, "license": "agpl-3.0", "language": "c", "size": 63059}
{"docstring": "/*\n * CanPushdownSubquery checks if we can push down the given\n * subquery to worker nodes.\n */\n", "func_signal": "bool\nCanPushdownSubquery(Query *subqueryTree, bool outerMostQueryHasLimit)", "code": "{\n\treturn DeferErrorIfCannotPushdownSubquery(subqueryTree, outerMostQueryHasLimit) ==\n\t\t   NULL;\n}", "path": "citus/src/backend/distributed/planner/query_pushdown_planning.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "citusdata/citus", "stars": 9511, "license": "agpl-3.0", "language": "c", "size": 63059}
{"docstring": "/*\n * WindowPartitionOnDistributionColumn checks if the given subquery has one\n * or more window functions and at least one of them is not partitioned by\n * distribution column. The function returns false if your window function does not\n * have a partition by clause or it does not include the distribution column.\n *\n * Please note that if the query does not have a window function, the function\n * returns true.\n */\n", "func_signal": "static bool\nWindowPartitionOnDistributionColumn(Query *query)", "code": "{\n\tList *windowClauseList = query->windowClause;\n\tListCell *windowClauseCell = NULL;\n\n\tforeach(windowClauseCell, windowClauseList)\n\t{\n\t\tWindowClause *windowClause = lfirst(windowClauseCell);\n\t\tList *partitionClauseList = windowClause->partitionClause;\n\t\tList *targetEntryList = query->targetList;\n\n\t\tList *groupTargetEntryList =\n\t\t\tGroupTargetEntryList(partitionClauseList, targetEntryList);\n\n\t\tbool partitionOnDistributionColumn =\n\t\t\tTargetListOnPartitionColumn(query, groupTargetEntryList);\n\n\t\tif (!partitionOnDistributionColumn)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "path": "citus/src/backend/distributed/planner/query_pushdown_planning.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "citusdata/citus", "stars": 9511, "license": "agpl-3.0", "language": "c", "size": 63059}
{"docstring": "/*\n * DeferErrorIfSubqueryRequiresMerge returns a deferred error if the subquery\n * requires a merge step on the coordinator (e.g. limit, group by non-distribution\n * column, etc.).\n */\n", "func_signal": "static DeferredErrorMessage *\nDeferErrorIfSubqueryRequiresMerge(Query *subqueryTree)", "code": "{\n\tbool preconditionsSatisfied = true;\n\tchar *errorDetail = NULL;\n\n\tif (subqueryTree->limitOffset)\n\t{\n\t\tpreconditionsSatisfied = false;\n\t\terrorDetail = \"Offset clause is currently unsupported when a subquery \"\n\t\t\t\t\t  \"references a column from another query\";\n\t}\n\n\t/* limit is not supported when SubqueryPushdown is not set */\n\tif (subqueryTree->limitCount && !SubqueryPushdown)\n\t{\n\t\tpreconditionsSatisfied = false;\n\t\terrorDetail = \"Limit in subquery is currently unsupported when a \"\n\t\t\t\t\t  \"subquery references a column from another query\";\n\t}\n\n\t/* group clause list must include partition column */\n\tif (subqueryTree->groupClause)\n\t{\n\t\tList *groupClauseList = subqueryTree->groupClause;\n\t\tList *targetEntryList = subqueryTree->targetList;\n\t\tList *groupTargetEntryList = GroupTargetEntryList(groupClauseList,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  targetEntryList);\n\t\tbool groupOnPartitionColumn =\n\t\t\tTargetListOnPartitionColumn(subqueryTree, groupTargetEntryList);\n\t\tif (!groupOnPartitionColumn)\n\t\t{\n\t\t\tpreconditionsSatisfied = false;\n\t\t\terrorDetail = \"Group by list without partition column is currently \"\n\t\t\t\t\t\t  \"unsupported when a subquery references a column \"\n\t\t\t\t\t\t  \"from another query\";\n\t\t}\n\t}\n\n\t/* we don't support aggregates without group by */\n\tif (subqueryTree->hasAggs && (subqueryTree->groupClause == NULL))\n\t{\n\t\tpreconditionsSatisfied = false;\n\t\terrorDetail = \"Aggregates without group by are currently unsupported \"\n\t\t\t\t\t  \"when a subquery references a column from another query\";\n\t}\n\n\t/* having clause without group by on partition column is not supported */\n\tif (subqueryTree->havingQual && (subqueryTree->groupClause == NULL))\n\t{\n\t\tpreconditionsSatisfied = false;\n\t\terrorDetail = \"Having qual without group by on partition column is \"\n\t\t\t\t\t  \"currently unsupported when a subquery references \"\n\t\t\t\t\t  \"a column from another query\";\n\t}\n\n\t/*\n\t * We support window functions when the window function\n\t * is partitioned on distribution column.\n\t */\n\tStringInfo errorInfo = NULL;\n\tif (subqueryTree->hasWindowFuncs && !SafeToPushdownWindowFunction(subqueryTree,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  &errorInfo))\n\t{\n\t\terrorDetail = (char *) errorInfo->data;\n\t\tpreconditionsSatisfied = false;\n\t}\n\n\t/* distinct clause list must include partition column */\n\tif (subqueryTree->distinctClause)\n\t{\n\t\tList *distinctClauseList = subqueryTree->distinctClause;\n\t\tList *targetEntryList = subqueryTree->targetList;\n\t\tList *distinctTargetEntryList = GroupTargetEntryList(distinctClauseList,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t targetEntryList);\n\t\tbool distinctOnPartitionColumn =\n\t\t\tTargetListOnPartitionColumn(subqueryTree, distinctTargetEntryList);\n\t\tif (!distinctOnPartitionColumn)\n\t\t{\n\t\t\tpreconditionsSatisfied = false;\n\t\t\terrorDetail = \"Distinct on columns without partition column is \"\n\t\t\t\t\t\t  \"currently unsupported\";\n\t\t}\n\t}\n\n\t/* finally check and return deferred if not satisfied */\n\tif (!preconditionsSatisfied)\n\t{\n\t\treturn DeferredError(ERRCODE_FEATURE_NOT_SUPPORTED,\n\t\t\t\t\t\t\t \"cannot push down this subquery\",\n\t\t\t\t\t\t\t errorDetail, NULL);\n\t}\n\n\treturn NULL;\n}", "path": "citus/src/backend/distributed/planner/query_pushdown_planning.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "citusdata/citus", "stars": 9511, "license": "agpl-3.0", "language": "c", "size": 63059}
{"docstring": "/*\n * PartitionColumnForPushedDownSubquery finds the partition column on the target\n * list of a pushed down subquery.\n */\n", "func_signal": "static Var *\nPartitionColumnForPushedDownSubquery(Query *query)", "code": "{\n\tList *targetEntryList = query->targetList;\n\n\tTargetEntry *targetEntry = NULL;\n\tforeach_ptr(targetEntry, targetEntryList)\n\t{\n\t\tif (targetEntry->resjunk)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tExpr *targetExpression = targetEntry->expr;\n\t\tif (IsA(targetExpression, Var))\n\t\t{\n\t\t\tbool isPartitionColumn = IsPartitionColumn(targetExpression, query);\n\t\t\tif (isPartitionColumn)\n\t\t\t{\n\t\t\t\tVar *partitionColumn = copyObject((Var *) targetExpression);\n\n\t\t\t\t/* the pushed down subquery is the only range table entry */\n\t\t\t\tpartitionColumn->varno = 1;\n\n\t\t\t\t/* point the var to the position in the subquery target list */\n\t\t\t\tpartitionColumn->varattno = targetEntry->resno;\n\n\t\t\t\treturn partitionColumn;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}", "path": "citus/src/backend/distributed/planner/query_pushdown_planning.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "citusdata/citus", "stars": 9511, "license": "agpl-3.0", "language": "c", "size": 63059}
{"docstring": "/*\n * JoinTreeContainsSubquery returns true if the input query contains any subqueries\n * in the join tree (e.g., FROM clause).\n */\n", "func_signal": "bool\nJoinTreeContainsSubquery(Query *query)", "code": "{\n\tFromExpr *joinTree = query->jointree;\n\n\tif (!joinTree)\n\t{\n\t\treturn false;\n\t}\n\n\treturn JoinTreeContainsSubqueryWalker((Node *) joinTree, query);\n}", "path": "citus/src/backend/distributed/planner/query_pushdown_planning.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "citusdata/citus", "stars": 9511, "license": "agpl-3.0", "language": "c", "size": 63059}
{"docstring": "/*\n * HasRecurringTuples returns whether any part of the expression will generate\n * the same set of tuples in every query on shards when executing a distributed\n * query.\n */\n", "func_signal": "static bool\nHasRecurringTuples(Node *node, RecurringTuplesType *recurType)", "code": "{\n\tif (node == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\tif (IsA(node, RangeTblEntry))\n\t{\n\t\tRangeTblEntry *rangeTableEntry = (RangeTblEntry *) node;\n\n\t\tif (rangeTableEntry->rtekind == RTE_RELATION)\n\t\t{\n\t\t\tOid relationId = rangeTableEntry->relid;\n\t\t\tif (IsCitusTableType(relationId, REFERENCE_TABLE))\n\t\t\t{\n\t\t\t\t*recurType = RECURRING_TUPLES_REFERENCE_TABLE;\n\n\t\t\t\t/*\n\t\t\t\t * Tuples from reference tables will recur in every query on shards\n\t\t\t\t * that includes it.\n\t\t\t\t */\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse if (rangeTableEntry->rtekind == RTE_FUNCTION)\n\t\t{\n\t\t\tList *functionList = rangeTableEntry->functions;\n\n\t\t\tif (list_length(functionList) == 1 &&\n\t\t\t\tContainsReadIntermediateResultFunction((Node *) functionList))\n\t\t\t{\n\t\t\t\t*recurType = RECURRING_TUPLES_RESULT_FUNCTION;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*recurType = RECURRING_TUPLES_FUNCTION;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Tuples from functions will recur in every query on shards that includes\n\t\t\t * it.\n\t\t\t */\n\t\t\treturn true;\n\t\t}\n#if PG_VERSION_NUM >= PG_VERSION_12\n\t\telse if (rangeTableEntry->rtekind == RTE_RESULT)\n\t\t{\n\t\t\t*recurType = RECURRING_TUPLES_EMPTY_JOIN_TREE;\n\t\t\treturn true;\n\t\t}\n#endif\n\n\t\treturn false;\n\t}\n\telse if (IsA(node, Query))\n\t{\n\t\tQuery *query = (Query *) node;\n\n\t\tif (HasEmptyJoinTree(query))\n\t\t{\n\t\t\t*recurType = RECURRING_TUPLES_EMPTY_JOIN_TREE;\n\n\t\t\t/*\n\t\t\t * Queries with empty join trees will recur in every query on shards\n\t\t\t * that includes it.\n\t\t\t */\n\t\t\treturn true;\n\t\t}\n\n\t\treturn query_tree_walker((Query *) node, HasRecurringTuples,\n\t\t\t\t\t\t\t\t recurType, QTW_EXAMINE_RTES_BEFORE);\n\t}\n\n\treturn expression_tree_walker(node, HasRecurringTuples, recurType);\n}", "path": "citus/src/backend/distributed/planner/query_pushdown_planning.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "citusdata/citus", "stars": 9511, "license": "agpl-3.0", "language": "c", "size": 63059}
{"docstring": "/*\n * IsNodeSubquery returns true if the given node is a Query or SubPlan or a\n * Param node with paramkind PARAM_EXEC.\n *\n * The check for SubPlan is needed when this is used on a already rewritten\n * query. Such a query has SubPlan nodes instead of SubLink nodes (which\n * contain a Query node).\n * The check for PARAM_EXEC is needed because some very simple subqueries like\n * (select 1) are converted to init plans in the rewritten query. In this case\n * the only thing left in the query tree is a Param node with type PARAM_EXEC.\n */\n", "func_signal": "bool\nIsNodeSubquery(Node *node)", "code": "{\n\tif (node == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\tif (IsA(node, Query) || IsA(node, SubPlan))\n\t{\n\t\treturn true;\n\t}\n\n\tif (!IsA(node, Param))\n\t{\n\t\treturn false;\n\t}\n\treturn ((Param *) node)->paramkind == PARAM_EXEC;\n}", "path": "citus/src/backend/distributed/planner/query_pushdown_planning.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "citusdata/citus", "stars": 9511, "license": "agpl-3.0", "language": "c", "size": 63059}
{"docstring": "/*\n * WhereOrHavingClauseContainsSubquery returns true if the input query contains\n * any subqueries in the WHERE or HAVING clause.\n */\n", "func_signal": "bool\nWhereOrHavingClauseContainsSubquery(Query *query)", "code": "{\n\tif (FindNodeMatchingCheckFunction(query->havingQual, IsNodeSubquery))\n\t{\n\t\treturn true;\n\t}\n\n\tif (!query->jointree)\n\t{\n\t\treturn false;\n\t}\n\n\t/*\n\t * We search the whole jointree here, not just the quals. The reason for\n\t * this is that the fromlist can contain other FromExpr nodes again or\n\t * JoinExpr nodes that also have quals. If that's the case we need to check\n\t * those as well if they contain andy subqueries.\n\t */\n\treturn FindNodeMatchingCheckFunction((Node *) query->jointree, IsNodeSubquery);\n}", "path": "citus/src/backend/distributed/planner/query_pushdown_planning.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "citusdata/citus", "stars": 9511, "license": "agpl-3.0", "language": "c", "size": 63059}
{"docstring": "/*\n * SafeToPushdownWindowFunction checks if the query with window function is supported.\n * Returns the result accordingly and modifies errorDetail if non null.\n */\n", "func_signal": "bool\nSafeToPushdownWindowFunction(Query *query, StringInfo *errorDetail)", "code": "{\n\tListCell *windowClauseCell = NULL;\n\tList *windowClauseList = query->windowClause;\n\n\t/*\n\t * We need to check each window clause separately if there is a partition by clause\n\t * and if it is partitioned on the distribution column.\n\t */\n\tforeach(windowClauseCell, windowClauseList)\n\t{\n\t\tWindowClause *windowClause = lfirst(windowClauseCell);\n\n\t\tif (!windowClause->partitionClause)\n\t\t{\n\t\t\tif (errorDetail)\n\t\t\t{\n\t\t\t\t*errorDetail = makeStringInfo();\n\t\t\t\tappendStringInfoString(*errorDetail,\n\t\t\t\t\t\t\t\t\t   \"Window functions without PARTITION BY on distribution \"\n\t\t\t\t\t\t\t\t\t   \"column is currently unsupported\");\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!WindowPartitionOnDistributionColumn(query))\n\t{\n\t\tif (errorDetail)\n\t\t{\n\t\t\t*errorDetail = makeStringInfo();\n\t\t\tappendStringInfoString(*errorDetail,\n\t\t\t\t\t\t\t\t   \"Window functions with PARTITION BY list missing distribution \"\n\t\t\t\t\t\t\t\t   \"column is currently unsupported\");\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "path": "citus/src/backend/distributed/planner/query_pushdown_planning.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "citusdata/citus", "stars": 9511, "license": "agpl-3.0", "language": "c", "size": 63059}
{"docstring": "/*\n * FindResnoForVarInTargetList finds a Var on a target list that has the given varno\n * (range table entry number) and varattno (column number) and returns the resno\n * of the target list entry.\n */\n", "func_signal": "static AttrNumber\nFindResnoForVarInTargetList(List *targetList, int varno, int varattno)", "code": "{\n\tTargetEntry *targetEntry = NULL;\n\tforeach_ptr(targetEntry, targetList)\n\t{\n\t\tif (!IsA(targetEntry->expr, Var))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tVar *targetEntryVar = (Var *) targetEntry->expr;\n\n\t\tif (targetEntryVar->varno == varno && targetEntryVar->varattno == varattno)\n\t\t{\n\t\t\treturn targetEntry->resno;\n\t\t}\n\t}\n\n\treturn InvalidAttrNumber;\n}", "path": "citus/src/backend/distributed/planner/query_pushdown_planning.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "citusdata/citus", "stars": 9511, "license": "agpl-3.0", "language": "c", "size": 63059}
{"docstring": "/*\n * CreateSubqueryTargetListAndAdjustVars creates a target entry for each unique\n * column in the column list, adjusts the columns to point into the subquery target\n * list and returns the new subquery target list.\n */\n", "func_signal": "static List *\nCreateSubqueryTargetListAndAdjustVars(List *columnList)", "code": "{\n\tVar *column = NULL;\n\tList *subqueryTargetEntryList = NIL;\n\n\tforeach_ptr(column, columnList)\n\t{\n\t\t/*\n\t\t * To avoid adding the same column multiple times, we first check whether there\n\t\t * is already a target entry containing a Var with the given varno and varattno.\n\t\t */\n\t\tAttrNumber resNo = FindResnoForVarInTargetList(subqueryTargetEntryList,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   column->varno, column->varattno);\n\t\tif (resNo == InvalidAttrNumber)\n\t\t{\n\t\t\t/* Var is not yet on the target list, create a new entry */\n\t\t\tresNo = list_length(subqueryTargetEntryList) + 1;\n\n\t\t\t/*\n\t\t\t * The join tree in the subquery is an exact duplicate of the original\n\t\t\t * query. Hence, we can make a copy of the original Var. However, if the\n\t\t\t * original Var was in a sublink it would be pointing up whereas now it\n\t\t\t * will be placed directly on the target list. Hence we reset the\n\t\t\t * varlevelsup.\n\t\t\t */\n\t\t\tVar *subqueryTargetListVar = (Var *) copyObject(column);\n\n\t\t\tsubqueryTargetListVar->varlevelsup = 0;\n\n\t\t\tTargetEntry *newTargetEntry = makeNode(TargetEntry);\n\t\t\tnewTargetEntry->expr = (Expr *) subqueryTargetListVar;\n\t\t\tnewTargetEntry->resname = WorkerColumnName(resNo);\n\t\t\tnewTargetEntry->resjunk = false;\n\t\t\tnewTargetEntry->resno = resNo;\n\n\t\t\tsubqueryTargetEntryList = lappend(subqueryTargetEntryList, newTargetEntry);\n\t\t}\n\n\t\t/*\n\t\t * Change the original column reference to point to the target list\n\t\t * entry in the subquery. There is only 1 subquery, so the varno is 1.\n\t\t */\n\t\tcolumn->varno = 1;\n\t\tcolumn->varattno = resNo;\n\t}\n\n\treturn subqueryTargetEntryList;\n}", "path": "citus/src/backend/distributed/planner/query_pushdown_planning.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "citusdata/citus", "stars": 9511, "license": "agpl-3.0", "language": "c", "size": 63059}
{"docstring": "/*\n * IsOuterJoinExpr returns whether the given node is an outer join expression.\n */\n", "func_signal": "static bool\nIsOuterJoinExpr(Node *node)", "code": "{\n\tbool isOuterJoin = false;\n\n\tif (node == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\tif (IsA(node, JoinExpr))\n\t{\n\t\tJoinExpr *joinExpr = (JoinExpr *) node;\n\t\tJoinType joinType = joinExpr->jointype;\n\t\tif (IS_OUTER_JOIN(joinType))\n\t\t{\n\t\t\tisOuterJoin = true;\n\t\t}\n\t}\n\n\treturn isOuterJoin;\n}", "path": "citus/src/backend/distributed/planner/query_pushdown_planning.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "citusdata/citus", "stars": 9511, "license": "agpl-3.0", "language": "c", "size": 63059}
{"docstring": "/*\n * SubqueryPushdownMultiNodeTree creates logical plan for subquery pushdown logic.\n * Note that this logic will be changed in next iterations, so we decoupled it\n * from other parts of code although it causes some code duplication.\n *\n * Current subquery pushdown support in MultiTree logic requires a single range\n * table entry in the top most from clause. Therefore we inject a synthetic\n * query derived from the top level query and make it the only range table\n * entry for the top level query. This way we can push down any subquery joins\n * down to workers without invoking join order planner.\n */\n", "func_signal": "static MultiNode *\nSubqueryPushdownMultiNodeTree(Query *originalQuery)", "code": "{\n\tQuery *queryTree = copyObject(originalQuery);\n\tList *targetEntryList = queryTree->targetList;\n\tMultiCollect *subqueryCollectNode = CitusMakeNode(MultiCollect);\n\n\t/* verify we can perform distributed planning on this query */\n\tDeferredErrorMessage *unsupportedQueryError = DeferErrorIfQueryNotSupported(\n\t\tqueryTree);\n\tif (unsupportedQueryError != NULL)\n\t{\n\t\tRaiseDeferredError(unsupportedQueryError, ERROR);\n\t}\n\n\t/*\n\t * We would be creating a new Query and pushing down top level query's\n\t * contents down to it. Join and filter clauses in higher level query would\n\t * be transferred to lower query. Therefore after this function we would\n\t * only have a single range table entry in the top level query. We need to\n\t * create a target list entry in lower query for each column reference in\n\t * upper level query's target list and having clauses. Any column reference\n\t * in the upper query will be updated to have varno=1, and varattno=<resno>\n\t * of matching target entry in pushed down query.\n\t * Consider query\n\t *      SELECT s1.a, sum(s2.c)\n\t *      FROM (some subquery) s1, (some subquery) s2\n\t *      WHERE s1.a = s2.a\n\t *      GROUP BY s1.a\n\t *      HAVING avg(s2.b);\n\t *\n\t * We want to prepare a multi tree to avoid subquery joins at top level,\n\t * therefore above query is converted to an equivalent\n\t *      SELECT worker_column_0, sum(worker_column_1)\n\t *      FROM (\n\t *              SELECT\n\t *                  s1.a AS worker_column_0,\n\t *                  s2.c AS worker_column_1,\n\t *                  s2.b AS worker_column_2\n\t *              FROM (some subquery) s1, (some subquery) s2\n\t *              WHERE s1.a = s2.a) worker_subquery\n\t *      GROUP BY worker_column_0\n\t *      HAVING avg(worker_column_2);\n\t *  After this conversion MultiTree is created as follows\n\t *\n\t *  MultiExtendedOpNode(\n\t *      targetList : worker_column_0, sum(worker_column_1)\n\t *      groupBy : worker_column_0\n\t *      having :  avg(worker_column_2))\n\t * --->MultiProject (worker_column_0, worker_column_1, worker_column_2)\n\t * --->--->\tMultiTable (subquery : worker_subquery)\n\t *\n\t * Master and worker queries will be created out of this MultiTree at later stages.\n\t */\n\n\t/*\n\t * columnList contains all columns returned by subquery. Subquery target\n\t * entry list, subquery range table entry's column name list are derived from\n\t * columnList. Columns mentioned in multiProject node and multiExtendedOp\n\t * node are indexed with their respective position in columnList.\n\t */\n\tList *targetColumnList = pull_vars_of_level((Node *) targetEntryList, 0);\n\tList *havingClauseColumnList = pull_var_clause_default(queryTree->havingQual);\n\tList *columnList = list_concat(targetColumnList, havingClauseColumnList);\n\n\t/* create a target entry for each unique column */\n\tList *subqueryTargetEntryList = CreateSubqueryTargetListAndAdjustVars(columnList);\n\n\t/* new query only has target entries, join tree, and rtable*/\n\tQuery *pushedDownQuery = makeNode(Query);\n\tpushedDownQuery->commandType = queryTree->commandType;\n\tpushedDownQuery->targetList = subqueryTargetEntryList;\n\tpushedDownQuery->jointree = copyObject(queryTree->jointree);\n\tpushedDownQuery->rtable = copyObject(queryTree->rtable);\n\tpushedDownQuery->setOperations = copyObject(queryTree->setOperations);\n\tpushedDownQuery->querySource = queryTree->querySource;\n\tpushedDownQuery->hasSubLinks = queryTree->hasSubLinks;\n\n\tMultiTable *subqueryNode = MultiSubqueryPushdownTable(pushedDownQuery);\n\n\tSetChild((MultiUnaryNode *) subqueryCollectNode, (MultiNode *) subqueryNode);\n\tMultiNode *currentTopNode = (MultiNode *) subqueryCollectNode;\n\n\t/* build project node for the columns to project */\n\tMultiProject *projectNode = MultiProjectNode(targetEntryList);\n\tSetChild((MultiUnaryNode *) projectNode, currentTopNode);\n\tcurrentTopNode = (MultiNode *) projectNode;\n\n\t/*\n\t * We build the extended operator node to capture aggregate functions, group\n\t * clauses, sort clauses, limit/offset clauses, and expressions. We need to\n\t * distinguish between aggregates and expressions; and we address this later\n\t * in the logical optimizer.\n\t */\n\tMultiExtendedOp *extendedOpNode = MultiExtendedOpNode(queryTree, originalQuery);\n\n\t/*\n\t * Postgres standard planner converts having qual node to a list of and\n\t * clauses and expects havingQual to be of type List when executing the\n\t * query later. This function is called on an original query, therefore\n\t * havingQual has not been converted yet. Perform conversion here.\n\t */\n\tif (extendedOpNode->havingQual != NULL &&\n\t\t!IsA(extendedOpNode->havingQual, List))\n\t{\n\t\textendedOpNode->havingQual =\n\t\t\t(Node *) make_ands_implicit((Expr *) extendedOpNode->havingQual);\n\t}\n\n\t/*\n\t * Group by on primary key allows all columns to appear in the target\n\t * list, but once we wrap the join tree into a subquery the GROUP BY\n\t * will no longer directly refer to the primary key and referencing\n\t * columns that are not in the GROUP BY would result in an error. To\n\t * prevent that we wrap all the columns that do not appear in the\n\t * GROUP BY in an any_value aggregate.\n\t */\n\tif (extendedOpNode->groupClauseList != NIL)\n\t{\n\t\textendedOpNode->targetList = (List *) WrapUngroupedVarsInAnyValueAggregate(\n\t\t\t(Node *) extendedOpNode->targetList,\n\t\t\textendedOpNode->groupClauseList,\n\t\t\textendedOpNode->targetList, true);\n\n\t\textendedOpNode->havingQual = WrapUngroupedVarsInAnyValueAggregate(\n\t\t\t(Node *) extendedOpNode->havingQual,\n\t\t\textendedOpNode->groupClauseList,\n\t\t\textendedOpNode->targetList, false);\n\t}\n\n\t/*\n\t * Postgres standard planner evaluates expressions in the LIMIT/OFFSET clauses.\n\t * Since we're using original query here, we should manually evaluate the\n\t * expression on the LIMIT and OFFSET clauses. Note that logical optimizer\n\t * expects those clauses to be already evaluated.\n\t */\n\textendedOpNode->limitCount =\n\t\tPartiallyEvaluateExpression(extendedOpNode->limitCount, NULL);\n\textendedOpNode->limitOffset =\n\t\tPartiallyEvaluateExpression(extendedOpNode->limitOffset, NULL);\n\n\tSetChild((MultiUnaryNode *) extendedOpNode, currentTopNode);\n\tcurrentTopNode = (MultiNode *) extendedOpNode;\n\n\treturn currentTopNode;\n}", "path": "citus/src/backend/distributed/planner/query_pushdown_planning.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "citusdata/citus", "stars": 9511, "license": "agpl-3.0", "language": "c", "size": 63059}
{"docstring": "/* callback for new session caching, to be set with SSL_CTX_sess_set_new_cb */\n", "func_signal": "int\nngx_http_lua_ssl_sess_store_handler(ngx_ssl_conn_t *ssl_conn,\n    ngx_ssl_session_t *sess)", "code": "{\n    const u_char                    *sess_id;\n    unsigned int                     sess_id_len;\n    lua_State                       *L;\n    ngx_int_t                        rc;\n    ngx_connection_t                *c, *fc = NULL;\n    ngx_http_request_t              *r = NULL;\n    ngx_http_connection_t           *hc;\n    ngx_http_lua_ssl_ctx_t          *cctx;\n    ngx_http_lua_srv_conf_t         *lscf;\n    ngx_http_core_loc_conf_t        *clcf;\n\n    c = ngx_ssl_get_connection(ssl_conn);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                   \"ssl session store: connection reusable: %ud\", c->reusable);\n\n    cctx = ngx_http_lua_ssl_get_ctx(c->ssl->connection);\n\n    dd(\"ssl sess_store handler, sess_store-ctx=%p\", cctx);\n\n    hc = c->data;\n\n    fc = ngx_http_lua_create_fake_connection(NULL);\n    if (fc == NULL) {\n        goto failed;\n    }\n\n    fc->log->handler = ngx_http_lua_log_ssl_sess_store_error;\n    fc->log->data = fc;\n\n    fc->addr_text = c->addr_text;\n    fc->listening = c->listening;\n\n    r = ngx_http_lua_create_fake_request(fc);\n    if (r == NULL) {\n        goto failed;\n    }\n\n    r->main_conf = hc->conf_ctx->main_conf;\n    r->srv_conf = hc->conf_ctx->srv_conf;\n    r->loc_conf = hc->conf_ctx->loc_conf;\n\n    fc->log->file = c->log->file;\n    fc->log->log_level = c->log->log_level;\n    fc->ssl = c->ssl;\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n#if defined(nginx_version) && nginx_version >= 1003014\n\n#   if nginx_version >= 1009000\n\n    ngx_set_connection_log(fc, clcf->error_log);\n\n#   else\n\n    ngx_http_set_connection_log(fc, clcf->error_log);\n\n#   endif\n\n#else\n\n    fc->log->file = clcf->error_log->file;\n\n    if (!(fc->log->log_level & NGX_LOG_DEBUG_CONNECTION)) {\n        fc->log->log_level = clcf->error_log->log_level;\n    }\n\n#endif\n\n    if (cctx == NULL) {\n        cctx = ngx_pcalloc(c->pool, sizeof(ngx_http_lua_ssl_ctx_t));\n        if (cctx == NULL) {\n            goto failed;  /* error */\n        }\n    }\n\n#if OPENSSL_VERSION_NUMBER >= 0x1000200fL\n    sess_id = SSL_SESSION_get_id(sess, &sess_id_len);\n#else\n    sess_id = sess->session_id;\n    sess_id_len = sess->session_id_length;\n#endif\n\n    cctx->connection = c;\n    cctx->request = r;\n    cctx->session = sess;\n    cctx->session_id.data = (u_char *) sess_id;\n    cctx->session_id.len = sess_id_len;\n    cctx->done = 0;\n\n    dd(\"setting cctx\");\n\n    if (SSL_set_ex_data(c->ssl->connection, ngx_http_lua_ssl_ctx_index, cctx)\n        == 0)\n    {\n        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, \"SSL_set_ex_data() failed\");\n        goto failed;\n    }\n\n    lscf = ngx_http_get_module_srv_conf(r, ngx_http_lua_module);\n\n    /* TODO honor lua_code_cache off */\n    L = ngx_http_lua_get_lua_vm(r, NULL);\n\n    c->log->action = \"storing SSL session by lua\";\n\n    rc = lscf->srv.ssl_sess_store_handler(r, lscf, L);\n\n    if (rc >= NGX_OK || rc == NGX_ERROR) {\n        cctx->done = 1;\n\n        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                       \"ssl_session_store_by_lua*: handler return value: %i, \"\n                       \"sess new cb exit code: %d\", rc, cctx->exit_code);\n\n        c->log->action = \"SSL handshaking\";\n\n        /* Return value is a flag indicating whether the passed-in session\n         * has been freed by this callback; always return 0 so OpenSSL will\n         * free the session. Nginx's own session caching logic has the same\n         * practice. */\n        return 0;\n    }\n\n    /* impossible to reach here */\n    ngx_http_lua_assert(0);\n\nfailed:\n\n    if (r && r->pool) {\n        ngx_http_lua_free_fake_request(r);\n    }\n\n    if (fc) {\n        ngx_http_lua_close_fake_connection(fc);\n    }\n\n    return 0;\n}", "path": "tengine/modules/ngx_http_lua_module/src/ngx_http_lua_ssl_session_storeby.c", "commit_date": "2019-01-31 00:00:00", "repo_name": "alibaba/tengine", "stars": 12526, "license": "bsd-2-clause", "language": "c", "size": 24266}
{"docstring": "/* TODO: warn about duplicate indices */\n", "func_signal": "static char *\nngx_http_index_set_index(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)", "code": "{\n    ngx_http_index_loc_conf_t *ilcf = conf;\n\n    ngx_str_t                  *value;\n    ngx_uint_t                  i, n;\n    ngx_http_index_t           *index;\n    ngx_http_script_compile_t   sc;\n\n    if (ilcf->indices == NULL) {\n        ilcf->indices = ngx_array_create(cf->pool, 2, sizeof(ngx_http_index_t));\n        if (ilcf->indices == NULL) {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    value = cf->args->elts;\n\n    for (i = 1; i < cf->args->nelts; i++) {\n\n        if (value[i].data[0] == '/' && i != cf->args->nelts - 1) {\n            ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                               \"only the last index in \\\"index\\\" directive \"\n                               \"should be absolute\");\n        }\n\n        if (value[i].len == 0) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"index \\\"%V\\\" in \\\"index\\\" directive is invalid\",\n                               &value[1]);\n            return NGX_CONF_ERROR;\n        }\n\n        index = ngx_array_push(ilcf->indices);\n        if (index == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        index->name.len = value[i].len;\n        index->name.data = value[i].data;\n        index->lengths = NULL;\n        index->values = NULL;\n\n        n = ngx_http_script_variables_count(&value[i]);\n\n        if (n == 0) {\n            if (ilcf->max_index_len < index->name.len) {\n                ilcf->max_index_len = index->name.len;\n            }\n\n            if (index->name.data[0] == '/') {\n                continue;\n            }\n\n            /* include the terminating '\\0' to the length to use ngx_memcpy() */\n            index->name.len++;\n\n            continue;\n        }\n\n        ngx_memzero(&sc, sizeof(ngx_http_script_compile_t));\n\n        sc.cf = cf;\n        sc.source = &value[i];\n        sc.lengths = &index->lengths;\n        sc.values = &index->values;\n        sc.variables = n;\n        sc.complete_lengths = 1;\n        sc.complete_values = 1;\n\n        if (ngx_http_script_compile(&sc) != NGX_OK) {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    return NGX_CONF_OK;\n}", "path": "tengine/src/http/modules/ngx_http_index_module.c", "commit_date": "2018-07-15 00:00:00", "repo_name": "alibaba/tengine", "stars": 12526, "license": "bsd-2-clause", "language": "c", "size": 24266}
{"docstring": "/* NGX_HAVE_GETADDRINFO && NGX_HAVE_INET6 */\n", "func_signal": "static ngx_int_t\nngx_inet_add_addr(ngx_pool_t *pool, ngx_url_t *u, struct sockaddr *sockaddr,\n    socklen_t socklen, ngx_uint_t total)", "code": "{\n    u_char           *p;\n    size_t            len;\n    ngx_uint_t        i, nports;\n    ngx_addr_t       *addr;\n    struct sockaddr  *sa;\n\n    nports = u->last_port ? u->last_port - u->port + 1 : 1;\n\n    if (u->addrs == NULL) {\n        u->addrs = ngx_palloc(pool, total * nports * sizeof(ngx_addr_t));\n        if (u->addrs == NULL) {\n            return NGX_ERROR;\n        }\n    }\n\n    for (i = 0; i < nports; i++) {\n        sa = ngx_pcalloc(pool, socklen);\n        if (sa == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_memcpy(sa, sockaddr, socklen);\n\n        ngx_inet_set_port(sa, u->port + i);\n\n        switch (sa->sa_family) {\n\n#if (NGX_HAVE_INET6)\n        case AF_INET6:\n            len = NGX_INET6_ADDRSTRLEN + sizeof(\"[]:65536\") - 1;\n            break;\n#endif\n\n        default: /* AF_INET */\n            len = NGX_INET_ADDRSTRLEN + sizeof(\":65535\") - 1;\n        }\n\n        p = ngx_pnalloc(pool, len);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        len = ngx_sock_ntop(sa, socklen, p, len, 1);\n\n        addr = &u->addrs[u->naddrs++];\n\n        addr->sockaddr = sa;\n        addr->socklen = socklen;\n\n        addr->name.len = len;\n        addr->name.data = p;\n    }\n\n    return NGX_OK;\n}", "path": "tengine/src/core/ngx_inet.c", "commit_date": "2019-06-17 00:00:00", "repo_name": "alibaba/tengine", "stars": 12526, "license": "bsd-2-clause", "language": "c", "size": 24266}
{"docstring": "/* auto detect the L2 cache line size of modern and widespread CPUs */\n", "func_signal": "void\nngx_cpuinfo(void)", "code": "{\n    u_char    *vendor;\n    uint32_t   vbuf[5], cpu[4], model;\n\n    vbuf[0] = 0;\n    vbuf[1] = 0;\n    vbuf[2] = 0;\n    vbuf[3] = 0;\n    vbuf[4] = 0;\n\n    ngx_cpuid(0, vbuf);\n\n    vendor = (u_char *) &vbuf[1];\n\n    if (vbuf[0] == 0) {\n        return;\n    }\n\n    ngx_cpuid(1, cpu);\n\n    if (ngx_strcmp(vendor, \"GenuineIntel\") == 0) {\n\n        switch ((cpu[0] & 0xf00) >> 8) {\n\n        /* Pentium */\n        case 5:\n            ngx_cacheline_size = 32;\n            break;\n\n        /* Pentium Pro, II, III */\n        case 6:\n            ngx_cacheline_size = 32;\n\n            model = ((cpu[0] & 0xf0000) >> 8) | (cpu[0] & 0xf0);\n\n            if (model >= 0xd0) {\n                /* Intel Core, Core 2, Atom */\n                ngx_cacheline_size = 64;\n            }\n\n            break;\n\n        /*\n         * Pentium 4, although its cache line size is 64 bytes,\n         * it prefetches up to two cache lines during memory read\n         */\n        case 15:\n            ngx_cacheline_size = 128;\n            break;\n        }\n\n    } else if (ngx_strcmp(vendor, \"AuthenticAMD\") == 0) {\n        ngx_cacheline_size = 64;\n    }\n}", "path": "tengine/src/core/ngx_cpuinfo.c", "commit_date": "2012-02-17 00:00:00", "repo_name": "alibaba/tengine", "stars": 12526, "license": "bsd-2-clause", "language": "c", "size": 24266}
{"docstring": "/*\n * Try to open/test the first index file before the test of directory\n * existence because valid requests should prevail over invalid ones.\n * If open()/stat() of a file will fail then stat() of a directory\n * should be faster because kernel may have already cached some data.\n * Besides, Win32 may return ERROR_PATH_NOT_FOUND (NGX_ENOTDIR) at once.\n * Unix has ENOTDIR error; however, it's less helpful than Win32's one:\n * it only indicates that path points to a regular file, not a directory.\n */\n", "func_signal": "static ngx_int_t\nngx_http_index_handler(ngx_http_request_t *r)", "code": "{\n    u_char                       *p, *name;\n    size_t                        len, root, reserve, allocated;\n    ngx_int_t                     rc;\n    ngx_str_t                     path, uri;\n    ngx_uint_t                    i, dir_tested;\n    ngx_http_index_t             *index;\n    ngx_open_file_info_t          of;\n    ngx_http_script_code_pt       code;\n    ngx_http_script_engine_t      e;\n    ngx_http_core_loc_conf_t     *clcf;\n    ngx_http_index_loc_conf_t    *ilcf;\n    ngx_http_script_len_code_pt   lcode;\n\n    if (r->uri.data[r->uri.len - 1] != '/') {\n        return NGX_DECLINED;\n    }\n\n    if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD|NGX_HTTP_POST))) {\n        return NGX_DECLINED;\n    }\n\n    ilcf = ngx_http_get_module_loc_conf(r, ngx_http_index_module);\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    allocated = 0;\n    root = 0;\n    dir_tested = 0;\n    name = NULL;\n    /* suppress MSVC warning */\n    path.data = NULL;\n\n    index = ilcf->indices->elts;\n    for (i = 0; i < ilcf->indices->nelts; i++) {\n\n        if (index[i].lengths == NULL) {\n\n            if (index[i].name.data[0] == '/') {\n                return ngx_http_internal_redirect(r, &index[i].name, &r->args);\n            }\n\n            reserve = ilcf->max_index_len;\n            len = index[i].name.len;\n\n        } else {\n            ngx_memzero(&e, sizeof(ngx_http_script_engine_t));\n\n            e.ip = index[i].lengths->elts;\n            e.request = r;\n            e.flushed = 1;\n\n            /* 1 is for terminating '\\0' as in static names */\n            len = 1;\n\n            while (*(uintptr_t *) e.ip) {\n                lcode = *(ngx_http_script_len_code_pt *) e.ip;\n                len += lcode(&e);\n            }\n\n            /* 16 bytes are preallocation */\n\n            reserve = len + 16;\n        }\n\n        if (reserve > allocated) {\n\n            name = ngx_http_map_uri_to_path(r, &path, &root, reserve);\n            if (name == NULL) {\n                return NGX_ERROR;\n            }\n\n            allocated = path.data + path.len - name;\n        }\n\n        if (index[i].values == NULL) {\n\n            /* index[i].name.len includes the terminating '\\0' */\n\n            ngx_memcpy(name, index[i].name.data, index[i].name.len);\n\n            path.len = (name + index[i].name.len - 1) - path.data;\n\n        } else {\n            e.ip = index[i].values->elts;\n            e.pos = name;\n\n            while (*(uintptr_t *) e.ip) {\n                code = *(ngx_http_script_code_pt *) e.ip;\n                code((ngx_http_script_engine_t *) &e);\n            }\n\n            if (*name == '/') {\n                uri.len = len - 1;\n                uri.data = name;\n                return ngx_http_internal_redirect(r, &uri, &r->args);\n            }\n\n            path.len = e.pos - path.data;\n\n            *e.pos = '\\0';\n        }\n\n        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"open index \\\"%V\\\"\", &path);\n\n        ngx_memzero(&of, sizeof(ngx_open_file_info_t));\n\n        of.read_ahead = clcf->read_ahead;\n        of.directio = clcf->directio;\n        of.valid = clcf->open_file_cache_valid;\n        of.min_uses = clcf->open_file_cache_min_uses;\n        of.test_only = 1;\n        of.errors = clcf->open_file_cache_errors;\n        of.events = clcf->open_file_cache_events;\n\n        if (ngx_http_set_disable_symlinks(r, clcf, &path, &of) != NGX_OK) {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        if (ngx_open_cached_file(clcf->open_file_cache, &path, &of, r->pool)\n            != NGX_OK)\n        {\n            if (of.err == 0) {\n                return NGX_HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, of.err,\n                           \"%s \\\"%s\\\" failed\", of.failed, path.data);\n\n#if (NGX_HAVE_OPENAT)\n            if (of.err == NGX_EMLINK\n                || of.err == NGX_ELOOP)\n            {\n                return NGX_HTTP_FORBIDDEN;\n            }\n#endif\n\n            if (of.err == NGX_ENOTDIR\n                || of.err == NGX_ENAMETOOLONG\n                || of.err == NGX_EACCES)\n            {\n                return ngx_http_index_error(r, clcf, path.data, of.err);\n            }\n\n            if (!dir_tested) {\n                rc = ngx_http_index_test_dir(r, clcf, path.data, name - 1);\n\n                if (rc != NGX_OK) {\n                    return rc;\n                }\n\n                dir_tested = 1;\n            }\n\n            if (of.err == NGX_ENOENT) {\n                continue;\n            }\n\n            ngx_log_error(NGX_LOG_CRIT, r->connection->log, of.err,\n                          \"%s \\\"%s\\\" failed\", of.failed, path.data);\n\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        uri.len = r->uri.len + len - 1;\n\n        if (!clcf->alias) {\n            uri.data = path.data + root;\n\n        } else {\n            uri.data = ngx_pnalloc(r->pool, uri.len);\n            if (uri.data == NULL) {\n                return NGX_HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            p = ngx_copy(uri.data, r->uri.data, r->uri.len);\n            ngx_memcpy(p, name, len - 1);\n        }\n\n        return ngx_http_internal_redirect(r, &uri, &r->args);\n    }\n\n    return NGX_DECLINED;\n}", "path": "tengine/src/http/modules/ngx_http_index_module.c", "commit_date": "2018-07-15 00:00:00", "repo_name": "alibaba/tengine", "stars": 12526, "license": "bsd-2-clause", "language": "c", "size": 24266}
{"docstring": "/* conf parser for directive ssl_session_store_by_lua */\n", "func_signal": "char *\nngx_http_lua_ssl_sess_store_by_lua(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf)", "code": "{\n    u_char                      *p;\n    u_char                      *name;\n    ngx_str_t                   *value;\n    ngx_http_lua_srv_conf_t     *lscf = conf;\n\n    dd(\"enter\");\n\n    /*  must specify a content handler */\n    if (cmd->post == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    if (lscf->srv.ssl_sess_store_handler) {\n        return \"is duplicate\";\n    }\n\n    if (ngx_http_lua_ssl_init(cf->log) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    value = cf->args->elts;\n\n    lscf->srv.ssl_sess_store_handler =\n        (ngx_http_lua_srv_conf_handler_pt) cmd->post;\n\n    if (cmd->post == ngx_http_lua_ssl_sess_store_handler_file) {\n        /* Lua code in an external file */\n\n        name = ngx_http_lua_rebase_path(cf->pool, value[1].data,\n                                        value[1].len);\n        if (name == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        lscf->srv.ssl_sess_store_src.data = name;\n        lscf->srv.ssl_sess_store_src.len = ngx_strlen(name);\n\n        p = ngx_palloc(cf->pool, NGX_HTTP_LUA_FILE_KEY_LEN + 1);\n        if (p == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        lscf->srv.ssl_sess_store_src_key = p;\n\n        p = ngx_copy(p, NGX_HTTP_LUA_FILE_TAG, NGX_HTTP_LUA_FILE_TAG_LEN);\n        p = ngx_http_lua_digest_hex(p, value[1].data, value[1].len);\n        *p = '\\0';\n\n    } else {\n        /* inlined Lua code */\n\n        lscf->srv.ssl_sess_store_src = value[1];\n\n        p = ngx_palloc(cf->pool,\n                       sizeof(\"ssl_session_store_by_lua\") +\n                       NGX_HTTP_LUA_INLINE_KEY_LEN);\n        if (p == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        lscf->srv.ssl_sess_store_src_key = p;\n\n        p = ngx_copy(p, \"ssl_session_store_by_lua\",\n                     sizeof(\"ssl_session_store_by_lua\") - 1);\n        p = ngx_copy(p, NGX_HTTP_LUA_INLINE_TAG, NGX_HTTP_LUA_INLINE_TAG_LEN);\n        p = ngx_http_lua_digest_hex(p, value[1].data, value[1].len);\n        *p = '\\0';\n    }\n\n    return NGX_CONF_OK;\n}", "path": "tengine/modules/ngx_http_lua_module/src/ngx_http_lua_ssl_session_storeby.c", "commit_date": "2019-01-31 00:00:00", "repo_name": "alibaba/tengine", "stars": 12526, "license": "bsd-2-clause", "language": "c", "size": 24266}
{"docstring": "/* !NGX_HAVE_GETADDRINFO || !NGX_HAVE_INET6 */\n", "func_signal": "ngx_int_t\nngx_inet_resolve_host(ngx_pool_t *pool, ngx_url_t *u)", "code": "{\n    u_char              *host;\n    ngx_uint_t           i, n;\n    struct hostent      *h;\n    struct sockaddr_in   sin;\n#if (T_NGX_DNS_RESOLVE_BACKUP)\n    u_char              *ph;\n    ngx_str_t            path;\n#endif\n\n    /* AF_INET only */\n\n    ngx_memzero(&sin, sizeof(struct sockaddr_in));\n\n    sin.sin_family = AF_INET;\n    sin.sin_addr.s_addr = ngx_inet_addr(u->host.data, u->host.len);\n\n    if (sin.sin_addr.s_addr == INADDR_NONE) {\n        host = ngx_alloc(u->host.len + 1, pool->log);\n        if (host == NULL) {\n            return NGX_ERROR;\n        }\n\n        (void) ngx_cpystrn(host, u->host.data, u->host.len + 1);\n\n        h = gethostbyname((char *) host);\n\n#if (T_NGX_DNS_RESOLVE_BACKUP)\n        ph = (u_char *) getenv(NGX_DNS_RESOLVE_BACKUP_PATH);\n        if (h == NULL && ph != NULL) {\n            path.data = ph;\n            path.len = ngx_strlen(ph);\n            if (ngx_resolve_using_local(pool, &u, path) == NGX_OK) {\n                ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0,\n                              \"dom %V using local dns cache successed\",\n                              &u->host);\n                ngx_free(host);\n                return NGX_OK;\n            }\n        }\n#endif\n\n        ngx_free(host);\n\n        if (h == NULL || h->h_addr_list[0] == NULL) {\n            u->err = \"host not found\";\n            return NGX_ERROR;\n        }\n\n        for (n = 0; h->h_addr_list[n] != NULL; n++) { /* void */ }\n\n        /* MP: ngx_shared_palloc() */\n\n        for (i = 0; i < n; i++) {\n            sin.sin_addr.s_addr = *(in_addr_t *) (h->h_addr_list[i]);\n\n            if (ngx_inet_add_addr(pool, u, (struct sockaddr *) &sin,\n                                  sizeof(struct sockaddr_in), n)\n                != NGX_OK)\n            {\n                return NGX_ERROR;\n            }\n        }\n\n#if (T_NGX_DNS_RESOLVE_BACKUP)\n        ph = (u_char *) getenv(NGX_DNS_RESOLVE_BACKUP_PATH);\n        if (ph != NULL) {\n            path.data = ph;\n            path.len = ngx_strlen(ph);\n            if (ngx_resolve_backup(pool, &u, path) != NGX_OK) {\n                ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0,\n                              \"dom %V backup local dns cache failed\",\n                              &u->host);\n            }\n        }\n#endif\n\n    } else {\n\n        /* MP: ngx_shared_palloc() */\n\n        if (ngx_inet_add_addr(pool, u, (struct sockaddr *) &sin,\n                              sizeof(struct sockaddr_in), 1)\n            != NGX_OK)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    return NGX_OK;\n}", "path": "tengine/src/core/ngx_inet.c", "commit_date": "2019-06-17 00:00:00", "repo_name": "alibaba/tengine", "stars": 12526, "license": "bsd-2-clause", "language": "c", "size": 24266}
{"docstring": "/*\n * We use binary search to find the segment we need\n * if found, return index, or return index to insert.\n */\n", "func_signal": "int32_t\nngx_http_tfs_find_segment(uint32_t seg_count,\n    ngx_http_tfs_segment_info_t *seg_info, int64_t offset)", "code": "{\n    int32_t  start, end, middle;\n\n    start = 0;\n    end = seg_count - 1;\n    middle = (start + end) / 2;\n    while (start <= end) {\n        if (seg_info[middle].offset == offset) {\n            return middle;\n        }\n        if (seg_info[middle].offset < offset) {\n            start = middle + 1;\n\n        } else {\n            end = middle - 1;\n        }\n        middle = (start + end) / 2;\n    }\n    return -start;\n}", "path": "tengine/modules/ngx_http_tfs_module/ngx_http_tfs_data_server_message.c", "commit_date": "2018-12-29 00:00:00", "repo_name": "alibaba/tengine", "stars": 12526, "license": "bsd-2-clause", "language": "c", "size": 24266}
{"docstring": "/* load Lua code from a file for caching new SSL session. */\n", "func_signal": "ngx_int_t\nngx_http_lua_ssl_sess_store_handler_file(ngx_http_request_t *r,\n    ngx_http_lua_srv_conf_t *lscf, lua_State *L)", "code": "{\n    ngx_int_t           rc;\n\n    rc = ngx_http_lua_cache_loadfile(r->connection->log, L,\n                                     lscf->srv.ssl_sess_store_src.data,\n                                     lscf->srv.ssl_sess_store_src_key);\n    if (rc != NGX_OK) {\n        return rc;\n    }\n\n    /*  make sure we have a valid code chunk */\n    ngx_http_lua_assert(lua_isfunction(L, -1));\n\n    return ngx_http_lua_ssl_sess_store_by_chunk(L, r);\n}", "path": "tengine/modules/ngx_http_lua_module/src/ngx_http_lua_ssl_session_storeby.c", "commit_date": "2019-01-31 00:00:00", "repo_name": "alibaba/tengine", "stars": 12526, "license": "bsd-2-clause", "language": "c", "size": 24266}
{"docstring": "/*\n * OpenSSL has no SSL_writev() so we copy several bufs into our 16K buffer\n * before the SSL_write() call to decrease a SSL overhead.\n *\n * Besides for protocols such as HTTP it is possible to always buffer\n * the output to decrease a SSL overhead some more.\n */\n", "func_signal": "ngx_chain_t *\nngx_ssl_send_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)", "code": "{\n    int          n;\n    ngx_uint_t   flush;\n    ssize_t      send, size;\n    ngx_buf_t   *buf;\n\n    if (!c->ssl->buffer) {\n\n        while (in) {\n            if (ngx_buf_special(in->buf)) {\n                in = in->next;\n                continue;\n            }\n\n            n = ngx_ssl_write(c, in->buf->pos, in->buf->last - in->buf->pos);\n\n            if (n == NGX_ERROR) {\n                return NGX_CHAIN_ERROR;\n            }\n\n            if (n == NGX_AGAIN) {\n                return in;\n            }\n\n            in->buf->pos += n;\n\n            if (in->buf->pos == in->buf->last) {\n                in = in->next;\n            }\n        }\n\n        return in;\n    }\n\n\n    /* the maximum limit size is the maximum int32_t value - the page size */\n\n    if (limit == 0 || limit > (off_t) (NGX_MAX_INT32_VALUE - ngx_pagesize)) {\n        limit = NGX_MAX_INT32_VALUE - ngx_pagesize;\n    }\n\n    buf = c->ssl->buf;\n\n    if (buf == NULL) {\n        buf = ngx_create_temp_buf(c->pool, c->ssl->buffer_size);\n        if (buf == NULL) {\n            return NGX_CHAIN_ERROR;\n        }\n\n        c->ssl->buf = buf;\n    }\n\n    if (buf->start == NULL) {\n        buf->start = ngx_palloc(c->pool, c->ssl->buffer_size);\n        if (buf->start == NULL) {\n            return NGX_CHAIN_ERROR;\n        }\n\n        buf->pos = buf->start;\n        buf->last = buf->start;\n        buf->end = buf->start + c->ssl->buffer_size;\n    }\n\n    send = buf->last - buf->pos;\n    flush = (in == NULL) ? 1 : buf->flush;\n\n    for ( ;; ) {\n\n        while (in && buf->last < buf->end && send < limit) {\n            if (in->buf->last_buf || in->buf->flush) {\n                flush = 1;\n            }\n\n            if (ngx_buf_special(in->buf)) {\n                in = in->next;\n                continue;\n            }\n\n            size = in->buf->last - in->buf->pos;\n\n            if (size > buf->end - buf->last) {\n                size = buf->end - buf->last;\n            }\n\n            if (send + size > limit) {\n                size = (ssize_t) (limit - send);\n            }\n\n            ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                           \"SSL buf copy: %z\", size);\n\n            ngx_memcpy(buf->last, in->buf->pos, size);\n\n            buf->last += size;\n            in->buf->pos += size;\n            send += size;\n\n            if (in->buf->pos == in->buf->last) {\n                in = in->next;\n            }\n        }\n\n        if (!flush && send < limit && buf->last < buf->end) {\n            break;\n        }\n\n        size = buf->last - buf->pos;\n\n        if (size == 0) {\n            buf->flush = 0;\n            c->buffered &= ~NGX_SSL_BUFFERED;\n            return in;\n        }\n\n        n = ngx_ssl_write(c, buf->pos, size);\n\n        if (n == NGX_ERROR) {\n            return NGX_CHAIN_ERROR;\n        }\n\n        if (n == NGX_AGAIN) {\n            break;\n        }\n\n        buf->pos += n;\n\n        if (n < size) {\n            break;\n        }\n\n        flush = 0;\n\n        buf->pos = buf->start;\n        buf->last = buf->start;\n\n        if (in == NULL || send == limit) {\n            break;\n        }\n    }\n\n    buf->flush = flush;\n\n    if (buf->pos < buf->last) {\n        c->buffered |= NGX_SSL_BUFFERED;\n\n    } else {\n        c->buffered &= ~NGX_SSL_BUFFERED;\n    }\n\n    return in;\n}", "path": "tengine/src/event/ngx_event_openssl.c", "commit_date": "2020-06-11 00:00:00", "repo_name": "alibaba/tengine", "stars": 12526, "license": "bsd-2-clause", "language": "c", "size": 24266}
{"docstring": "/*\n * The length of the session id is 16 bytes for SSLv2 sessions and\n * between 1 and 32 bytes for SSLv3/TLSv1, typically 32 bytes.\n * It seems that the typical length of the external ASN1 representation\n * of a session is 118 or 119 bytes for SSLv3/TSLv1.\n *\n * Thus on 32-bit platforms we allocate separately an rbtree node,\n * a session id, and an ASN1 representation, they take accordingly\n * 64, 32, and 128 bytes.\n *\n * On 64-bit platforms we allocate separately an rbtree node + session_id,\n * and an ASN1 representation, they take accordingly 128 and 128 bytes.\n *\n * OpenSSL's i2d_SSL_SESSION() and d2i_SSL_SESSION are slow,\n * so they are outside the code locked by shared pool mutex\n */\n", "func_signal": "static int\nngx_ssl_new_session(ngx_ssl_conn_t *ssl_conn, ngx_ssl_session_t *sess)", "code": "{\n    int                       len;\n    u_char                   *p, *id, *cached_sess, *session_id;\n    uint32_t                  hash;\n    SSL_CTX                  *ssl_ctx;\n    unsigned int              session_id_length;\n    ngx_shm_zone_t           *shm_zone;\n    ngx_connection_t         *c;\n    ngx_slab_pool_t          *shpool;\n    ngx_ssl_sess_id_t        *sess_id;\n    ngx_ssl_session_cache_t  *cache;\n    u_char                    buf[NGX_SSL_MAX_SESSION_SIZE];\n\n    len = i2d_SSL_SESSION(sess, NULL);\n\n    /* do not cache too big session */\n\n    if (len > (int) NGX_SSL_MAX_SESSION_SIZE) {\n        return 0;\n    }\n\n    p = buf;\n    i2d_SSL_SESSION(sess, &p);\n\n    c = ngx_ssl_get_connection(ssl_conn);\n\n    ssl_ctx = c->ssl->session_ctx;\n    shm_zone = SSL_CTX_get_ex_data(ssl_ctx, ngx_ssl_session_cache_index);\n\n    cache = shm_zone->data;\n    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n\n    ngx_shmtx_lock(&shpool->mutex);\n\n    /* drop one or two expired sessions */\n    ngx_ssl_expire_sessions(cache, shpool, 1);\n\n    cached_sess = ngx_slab_alloc_locked(shpool, len);\n\n    if (cached_sess == NULL) {\n\n        /* drop the oldest non-expired session and try once more */\n\n        ngx_ssl_expire_sessions(cache, shpool, 0);\n\n        cached_sess = ngx_slab_alloc_locked(shpool, len);\n\n        if (cached_sess == NULL) {\n            sess_id = NULL;\n            goto failed;\n        }\n    }\n\n    sess_id = ngx_slab_alloc_locked(shpool, sizeof(ngx_ssl_sess_id_t));\n\n    if (sess_id == NULL) {\n\n        /* drop the oldest non-expired session and try once more */\n\n        ngx_ssl_expire_sessions(cache, shpool, 0);\n\n        sess_id = ngx_slab_alloc_locked(shpool, sizeof(ngx_ssl_sess_id_t));\n\n        if (sess_id == NULL) {\n            goto failed;\n        }\n    }\n\n    session_id = (u_char *) SSL_SESSION_get_id(sess, &session_id_length);\n\n#if (NGX_PTR_SIZE == 8)\n\n    id = sess_id->sess_id;\n\n#else\n\n    id = ngx_slab_alloc_locked(shpool, session_id_length);\n\n    if (id == NULL) {\n\n        /* drop the oldest non-expired session and try once more */\n\n        ngx_ssl_expire_sessions(cache, shpool, 0);\n\n        id = ngx_slab_alloc_locked(shpool, session_id_length);\n\n        if (id == NULL) {\n            goto failed;\n        }\n    }\n\n#endif\n\n    ngx_memcpy(cached_sess, buf, len);\n\n    ngx_memcpy(id, session_id, session_id_length);\n\n    hash = ngx_crc32_short(session_id, session_id_length);\n\n    ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                   \"ssl new session: %08XD:%ud:%d\",\n                   hash, session_id_length, len);\n\n    sess_id->node.key = hash;\n    sess_id->node.data = (u_char) session_id_length;\n    sess_id->id = id;\n    sess_id->len = len;\n    sess_id->session = cached_sess;\n\n    sess_id->expire = ngx_time() + SSL_CTX_get_timeout(ssl_ctx);\n\n    ngx_queue_insert_head(&cache->expire_queue, &sess_id->queue);\n\n    ngx_rbtree_insert(&cache->session_rbtree, &sess_id->node);\n\n    ngx_shmtx_unlock(&shpool->mutex);\n\n    return 0;\n\nfailed:\n\n    if (cached_sess) {\n        ngx_slab_free_locked(shpool, cached_sess);\n    }\n\n    if (sess_id) {\n        ngx_slab_free_locked(shpool, sess_id);\n    }\n\n    ngx_shmtx_unlock(&shpool->mutex);\n\n    ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n                  \"could not allocate new session%s\", shpool->log_ctx);\n\n    return 0;\n}", "path": "tengine/src/event/ngx_event_openssl.c", "commit_date": "2020-06-11 00:00:00", "repo_name": "alibaba/tengine", "stars": 12526, "license": "bsd-2-clause", "language": "c", "size": 24266}
{"docstring": "/* serialize the session id from lua context into buf.\n * the memory allocation of buf should be handled externally. */\n", "func_signal": "int\nngx_http_lua_ffi_ssl_get_session_id(ngx_http_request_t *r,\n    u_char *buf, char **err)", "code": "{\n    int                              id_len;\n    u_char                          *id;\n    ngx_ssl_conn_t                  *ssl_conn;\n    ngx_connection_t                *c;\n    ngx_http_lua_ssl_ctx_t          *cctx;\n\n    c = r->connection;\n\n    if (c == NULL || c->ssl == NULL) {\n        *err = \"bad request\";\n        return NGX_ERROR;\n    }\n\n    ssl_conn = c->ssl->connection;\n    if (ssl_conn == NULL) {\n        *err = \"bad ssl conn\";\n        return NGX_ERROR;\n    }\n\n    dd(\"get cctx session\");\n    cctx = ngx_http_lua_ssl_get_ctx(c->ssl->connection);\n    if (cctx == NULL) {\n        *err = \"bad lua context\";\n        return NGX_ERROR;\n    }\n\n    id = cctx->session_id.data;\n    if (id == NULL) {\n        *err = \"uninitialized session id in lua context\";\n        return NGX_ERROR;\n    }\n\n    id_len = cctx->session_id.len;\n    if (id_len == 0) {\n        *err = \"uninitialized session id len in lua context\";\n        return NGX_ERROR;\n    }\n\n    ngx_hex_dump(buf, id, id_len);\n\n    return NGX_OK;\n}", "path": "tengine/modules/ngx_http_lua_module/src/ngx_http_lua_ssl_session_storeby.c", "commit_date": "2019-01-31 00:00:00", "repo_name": "alibaba/tengine", "stars": 12526, "license": "bsd-2-clause", "language": "c", "size": 24266}
{"docstring": "/* __amd64__ */\n", "func_signal": "static ngx_inline void\nngx_cpuid(uint32_t i, uint32_t *buf)", "code": "{\n    uint32_t  eax, ebx, ecx, edx;\n\n    __asm__ (\n\n        \"cpuid\"\n\n    : \"=a\" (eax), \"=b\" (ebx), \"=c\" (ecx), \"=d\" (edx) : \"a\" (i) );\n\n    buf[0] = eax;\n    buf[1] = ebx;\n    buf[2] = edx;\n    buf[3] = ecx;\n}", "path": "tengine/src/core/ngx_cpuinfo.c", "commit_date": "2012-02-17 00:00:00", "repo_name": "alibaba/tengine", "stars": 12526, "license": "bsd-2-clause", "language": "c", "size": 24266}
{"docstring": "/*\n * RFC 6347, 4.2.1:\n *\n * When responding to a HelloVerifyRequest, the client MUST use the same\n * parameter values (version, random, session_id, cipher_suites,\n * compression_method) as it did in the original ClientHello.  The\n * server SHOULD use those values to generate its cookie and verify that\n * they are correct upon cookie receipt.\n */\n", "func_signal": "static int\nngx_dtls_client_hmac(SSL *ssl, u_char res[EVP_MAX_MD_SIZE], unsigned int *rlen)", "code": "{\n    u_char            *p;\n    size_t             len;\n    ngx_connection_t  *c;\n\n    u_char             buffer[64];\n\n    c = ngx_ssl_get_connection(ssl);\n\n    p = buffer;\n\n    p = ngx_cpymem(p, c->addr_text.data, c->addr_text.len);\n    p = ngx_sprintf(p, \"%d\", ngx_inet_get_port(c->sockaddr));\n\n    len = p - buffer;\n\n    HMAC(EVP_sha1(), (const void*) c->ssl->dtls_cookie_secret,\n         sizeof(c->ssl->dtls_cookie_secret), (const u_char*) buffer, len, res, rlen);\n\n    return NGX_OK;\n}", "path": "tengine/src/event/ngx_event_openssl.c", "commit_date": "2020-06-11 00:00:00", "repo_name": "alibaba/tengine", "stars": 12526, "license": "bsd-2-clause", "language": "c", "size": 24266}
{"docstring": "/* return the size of serialized session id. */\n", "func_signal": "int\nngx_http_lua_ffi_ssl_get_session_id_size(ngx_http_request_t *r,\n    char **err)", "code": "{\n    ngx_ssl_conn_t                  *ssl_conn;\n    ngx_connection_t                *c;\n    ngx_http_lua_ssl_ctx_t          *cctx;\n\n    c = r->connection;\n\n    if (c == NULL || c->ssl == NULL) {\n        *err = \"bad request\";\n        return NGX_ERROR;\n    }\n\n    ssl_conn = c->ssl->connection;\n    if (ssl_conn == NULL) {\n        *err = \"bad ssl conn\";\n        return NGX_ERROR;\n    }\n\n    dd(\"get cctx session\");\n    cctx = ngx_http_lua_ssl_get_ctx(c->ssl->connection);\n    if (cctx == NULL) {\n        *err = \"bad lua context\";\n        return NGX_ERROR;\n    }\n\n    if (cctx->session_id.len == 0) {\n        *err = \"uninitialized session id len in lua context\";\n        return NGX_ERROR;\n    }\n\n    /* since the session id will be hex dumped to serialize, the serialized\n     * session will be twice the size of the session id: each byte will be a\n     * 2-digit hex value. */\n\n    return 2 * cctx->session_id.len;\n}", "path": "tengine/modules/ngx_http_lua_module/src/ngx_http_lua_ssl_session_storeby.c", "commit_date": "2019-01-31 00:00:00", "repo_name": "alibaba/tengine", "stars": 12526, "license": "bsd-2-clause", "language": "c", "size": 24266}
{"docstring": "/* serialize a session from lua context into buf.\n * the memory allocation of buf should be handled externally. */\n", "func_signal": "int\nngx_http_lua_ffi_ssl_get_serialized_session(ngx_http_request_t *r,\n    u_char *buf, char **err)", "code": "{\n    ngx_ssl_conn_t                  *ssl_conn;\n    ngx_connection_t                *c;\n    ngx_ssl_session_t               *session;\n    ngx_http_lua_ssl_ctx_t          *cctx;\n\n    c = r->connection;\n\n    if (c == NULL || c->ssl == NULL) {\n        *err = \"bad request\";\n        return NGX_ERROR;\n    }\n\n    ssl_conn = c->ssl->connection;\n    if (ssl_conn == NULL) {\n        *err = \"bad ssl conn\";\n        return NGX_ERROR;\n    }\n\n    dd(\"get cctx session\");\n\n    cctx = ngx_http_lua_ssl_get_ctx(c->ssl->connection);\n    if (cctx == NULL) {\n        *err = \"bad lua context\";\n        return NGX_ERROR;\n    }\n\n    session = cctx->session;\n    if (session == NULL) {\n        *err = \"bad session in lua context\";\n        return NGX_ERROR;\n    }\n\n    if (i2d_SSL_SESSION(session, &buf) == 0) {\n        *err = \"i2d_SSL_SESSION() failed\";\n        return NGX_ERROR;\n    }\n\n    return NGX_OK;\n}", "path": "tengine/modules/ngx_http_lua_module/src/ngx_http_lua_ssl_session_storeby.c", "commit_date": "2019-01-31 00:00:00", "repo_name": "alibaba/tengine", "stars": 12526, "license": "bsd-2-clause", "language": "c", "size": 24266}
{"docstring": "/* load lua code from an inline snippet for caching new SSL session */\n", "func_signal": "ngx_int_t\nngx_http_lua_ssl_sess_store_handler_inline(ngx_http_request_t *r,\n    ngx_http_lua_srv_conf_t *lscf, lua_State *L)", "code": "{\n    ngx_int_t           rc;\n\n    rc = ngx_http_lua_cache_loadbuffer(r->connection->log, L,\n                                       lscf->srv.ssl_sess_store_src.data,\n                                       lscf->srv.ssl_sess_store_src.len,\n                                       lscf->srv.ssl_sess_store_src_key,\n                                       \"=ssl_session_store_by_lua_block\");\n    if (rc != NGX_OK) {\n        return rc;\n    }\n\n    /*  make sure we have a valid code chunk */\n    ngx_http_lua_assert(lua_isfunction(L, -1));\n\n    return ngx_http_lua_ssl_sess_store_by_chunk(L, r);\n}", "path": "tengine/modules/ngx_http_lua_module/src/ngx_http_lua_ssl_session_storeby.c", "commit_date": "2019-01-31 00:00:00", "repo_name": "alibaba/tengine", "stars": 12526, "license": "bsd-2-clause", "language": "c", "size": 24266}
{"docstring": "/**\n * Set environment table for the given code closure.\n *\n * Before:\n *         | code closure | <- top\n *         |      ...     |\n *\n * After:\n *         | code closure | <- top\n *         |      ...     |\n * */\n", "func_signal": "static void\nngx_http_lua_body_filter_by_lua_env(lua_State *L, ngx_http_request_t *r,\n    ngx_chain_t *in)", "code": "{\n    ngx_http_lua_main_conf_t    *lmcf;\n\n    ngx_http_lua_set_req(L, r);\n\n    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);\n    lmcf->body_filter_chain = in;\n\n#ifndef OPENRESTY_LUAJIT\n    /**\n     * we want to create empty environment for current script\n     *\n     * setmetatable({}, {__index = _G})\n     *\n     * if a function or symbol is not defined in our env, __index will lookup\n     * in the global env.\n     *\n     * all variables created in the script-env will be thrown away at the end\n     * of the script run.\n     * */\n    ngx_http_lua_create_new_globals_table(L, 0 /* narr */, 1 /* nrec */);\n\n    /*  {{{ make new env inheriting main thread's globals table */\n    lua_createtable(L, 0, 1 /* nrec */);    /*  the metatable for the new\n                                                env */\n    ngx_http_lua_get_globals_table(L);\n    lua_setfield(L, -2, \"__index\");\n    lua_setmetatable(L, -2);    /*  setmetatable({}, {__index = _G}) */\n    /*  }}} */\n\n    lua_setfenv(L, -2);    /*  set new running env for the code closure */\n#endif /* OPENRESTY_LUAJIT */\n}", "path": "tengine/modules/ngx_http_lua_module/src/ngx_http_lua_bodyfilterby.c", "commit_date": "2019-01-31 00:00:00", "repo_name": "alibaba/tengine", "stars": 12526, "license": "bsd-2-clause", "language": "c", "size": 24266}
{"docstring": "/* borrowed the code from ngx_http_request.c:ngx_http_process_user_agent */\n", "func_signal": "static ngx_int_t\nngx_http_set_user_agent_header(ngx_http_request_t *r,\n    ngx_http_lua_header_val_t *hv, ngx_str_t *value)", "code": "{\n    u_char  *user_agent, *msie;\n\n    /* clear existing settings */\n\n    r->headers_in.msie = 0;\n    r->headers_in.msie6 = 0;\n    r->headers_in.opera = 0;\n    r->headers_in.gecko = 0;\n    r->headers_in.chrome = 0;\n    r->headers_in.safari = 0;\n    r->headers_in.konqueror = 0;\n\n    if (value->len == 0) {\n        return ngx_http_set_builtin_header(r, hv, value);\n    }\n\n    /* check some widespread browsers */\n\n    user_agent = value->data;\n\n    msie = ngx_strstrn(user_agent, \"MSIE \", 5 - 1);\n\n    if (msie && msie + 7 < user_agent + value->len) {\n\n        r->headers_in.msie = 1;\n\n        if (msie[6] == '.') {\n\n            switch (msie[5]) {\n            case '4':\n            case '5':\n                r->headers_in.msie6 = 1;\n                break;\n            case '6':\n                if (ngx_strstrn(msie + 8, \"SV1\", 3 - 1) == NULL) {\n                    r->headers_in.msie6 = 1;\n                }\n                break;\n            }\n        }\n    }\n\n    if (ngx_strstrn(user_agent, \"Opera\", 5 - 1)) {\n        r->headers_in.opera = 1;\n        r->headers_in.msie = 0;\n        r->headers_in.msie6 = 0;\n    }\n\n    if (!r->headers_in.msie && !r->headers_in.opera) {\n\n        if (ngx_strstrn(user_agent, \"Gecko/\", 6 - 1)) {\n            r->headers_in.gecko = 1;\n\n        } else if (ngx_strstrn(user_agent, \"Chrome/\", 7 - 1)) {\n            r->headers_in.chrome = 1;\n\n        } else if (ngx_strstrn(user_agent, \"Safari/\", 7 - 1)\n                   && ngx_strstrn(user_agent, \"Mac OS X\", 8 - 1))\n        {\n            r->headers_in.safari = 1;\n\n        } else if (ngx_strstrn(user_agent, \"Konqueror\", 9 - 1)) {\n            r->headers_in.konqueror = 1;\n        }\n    }\n\n    return ngx_http_set_builtin_header(r, hv, value);\n}", "path": "tengine/modules/ngx_http_lua_module/src/ngx_http_lua_headers_in.c", "commit_date": "2019-01-31 00:00:00", "repo_name": "alibaba/tengine", "stars": 12526, "license": "bsd-2-clause", "language": "c", "size": 24266}
{"docstring": "/* initialize lua coroutine for caching new SSL session */\n", "func_signal": "static ngx_int_t\nngx_http_lua_ssl_sess_store_by_chunk(lua_State *L, ngx_http_request_t *r)", "code": "{\n    size_t                   len;\n    u_char                  *err_msg;\n    ngx_int_t                rc;\n    ngx_http_lua_ctx_t      *ctx;\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);\n\n    if (ctx == NULL) {\n        ctx = ngx_http_lua_create_ctx(r);\n        if (ctx == NULL) {\n            rc = NGX_ERROR;\n            ngx_http_lua_finalize_request(r, rc);\n            return rc;\n        }\n\n    } else {\n        dd(\"reset ctx\");\n        ngx_http_lua_reset_ctx(r, L, ctx);\n    }\n\n    ctx->entered_content_phase = 1;\n    ctx->context = NGX_HTTP_LUA_CONTEXT_SSL_SESS_STORE;\n\n    /* init nginx context in Lua VM */\n    ngx_http_lua_set_req(L, r);\n\n#ifndef OPENRESTY_LUAJIT\n    ngx_http_lua_create_new_globals_table(L, 0 /* narr */, 1 /* nrec */);\n\n    /*  {{{ make new env inheriting main thread's globals table */\n    lua_createtable(L, 0, 1 /* nrec */);   /* the metatable for the new env */\n    ngx_http_lua_get_globals_table(L);\n    lua_setfield(L, -2, \"__index\");\n    lua_setmetatable(L, -2);    /*  setmetatable({}, {__index = _G}) */\n    /*  }}} */\n\n    lua_setfenv(L, -2);    /*  set new running env for the code closure */\n#endif\n\n    lua_pushcfunction(L, ngx_http_lua_traceback);\n    lua_insert(L, 1);  /* put it under chunk and args */\n\n    /*  protected call user code */\n    rc = lua_pcall(L, 0, 1, 1);\n\n    lua_remove(L, 1);  /* remove traceback function */\n\n    dd(\"rc == %d\", (int) rc);\n\n    if (rc != 0) {\n        /*  error occurred when running loaded code */\n        err_msg = (u_char *) lua_tolstring(L, -1, &len);\n\n        if (err_msg == NULL) {\n            err_msg = (u_char *) \"unknown reason\";\n            len = sizeof(\"unknown reason\") - 1;\n        }\n\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"failed to run session_store_by_lua*: %*s\", len, err_msg);\n\n        lua_settop(L, 0); /*  clear remaining elems on stack */\n        ngx_http_lua_finalize_request(r, rc);\n\n        return NGX_ERROR;\n    }\n\n    lua_settop(L, 0); /*  clear remaining elems on stack */\n    ngx_http_lua_finalize_request(r, rc);\n    return rc;\n}", "path": "tengine/modules/ngx_http_lua_module/src/ngx_http_lua_ssl_session_storeby.c", "commit_date": "2019-01-31 00:00:00", "repo_name": "alibaba/tengine", "stars": 12526, "license": "bsd-2-clause", "language": "c", "size": 24266}
{"docstring": "/* Render a value to text. */\n", "func_signal": "static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)", "code": "{\n    unsigned char *output = NULL;\n\n    if ((item == NULL) || (output_buffer == NULL))\n    {\n        return false;\n    }\n\n    switch ((item->type) & 0xFF)\n    {\n        case cJSON_NULL:\n            output = ensure(output_buffer, 5);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"null\");\n            return true;\n\n        case cJSON_False:\n            output = ensure(output_buffer, 6);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"false\");\n            return true;\n\n        case cJSON_True:\n            output = ensure(output_buffer, 5);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"true\");\n            return true;\n\n        case cJSON_Number:\n            return print_number(item, output_buffer);\n\n        case cJSON_Raw:\n        {\n            size_t raw_length = 0;\n            if (item->valuestring == NULL)\n            {\n                if (!output_buffer->noalloc)\n                {\n                    output_buffer->hooks.deallocate(output_buffer->buffer);\n                }\n                return false;\n            }\n\n            raw_length = strlen(item->valuestring) + sizeof(\"\");\n            output = ensure(output_buffer, raw_length);\n            if (output == NULL)\n            {\n                return false;\n            }\n            memcpy(output, item->valuestring, raw_length);\n            return true;\n        }\n\n        case cJSON_String:\n            return print_string(item, output_buffer);\n\n        case cJSON_Array:\n            return print_array(item, output_buffer);\n\n        case cJSON_Object:\n            return print_object(item, output_buffer);\n\n        default:\n            return false;\n    }\n}", "path": "ijkplayer/ijkmedia/ijkplayer/ijkavformat/cJSON.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "bilibili/ijkplayer", "stars": 32030, "license": "gpl-2.0", "language": "c", "size": 8283}
{"docstring": "/* Add item to array/object. */\n", "func_signal": "CJSON_PUBLIC(void) cJSON_AddItemToArray(cJSON *array, cJSON *item)", "code": "{\n    cJSON *child = NULL;\n\n    if ((item == NULL) || (array == NULL))\n    {\n        return;\n    }\n\n    child = array->child;\n\n    if (child == NULL)\n    {\n        /* list is empty, start new one */\n        array->child = item;\n    }\n    else\n    {\n        /* append to the end */\n        while (child->next)\n        {\n            child = child->next;\n        }\n        suffix_object(child, item);\n    }\n}", "path": "ijkplayer/ijkmedia/ijkplayer/ijkavformat/cJSON.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "bilibili/ijkplayer", "stars": 32030, "license": "gpl-2.0", "language": "c", "size": 8283}
{"docstring": "/* Render an array to text */\n", "func_signal": "static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer)", "code": "{\n    unsigned char *output_pointer = NULL;\n    size_t length = 0;\n    cJSON *current_element = item->child;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* Compose the output array. */\n    /* opening square bracket */\n    output_pointer = ensure(output_buffer, 1);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n\n    *output_pointer = '[';\n    output_buffer->offset++;\n    output_buffer->depth++;\n\n    while (current_element != NULL)\n    {\n        if (!print_value(current_element, output_buffer))\n        {\n            return false;\n        }\n        update_offset(output_buffer);\n        if (current_element->next)\n        {\n            length = (size_t) (output_buffer->format ? 2 : 1);\n            output_pointer = ensure(output_buffer, length + 1);\n            if (output_pointer == NULL)\n            {\n                return false;\n            }\n            *output_pointer++ = ',';\n            if(output_buffer->format)\n            {\n                *output_pointer++ = ' ';\n            }\n            *output_pointer = '\\0';\n            output_buffer->offset += length;\n        }\n        current_element = current_element->next;\n    }\n\n    output_pointer = ensure(output_buffer, 2);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n    *output_pointer++ = ']';\n    *output_pointer = '\\0';\n    output_buffer->depth--;\n\n    return true;\n}", "path": "ijkplayer/ijkmedia/ijkplayer/ijkavformat/cJSON.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "bilibili/ijkplayer", "stars": 32030, "license": "gpl-2.0", "language": "c", "size": 8283}
{"docstring": "/*\n * Per-Renderer routine\n */\n", "func_signal": "GLboolean IJK_GLES2_Renderer_use(IJK_GLES2_Renderer *renderer)", "code": "{\n    if (!renderer)\n        return GL_FALSE;\n\n    assert(renderer->func_use);\n    if (!renderer->func_use(renderer))\n        return GL_FALSE;\n\n    IJK_GLES_Matrix modelViewProj;\n    IJK_GLES2_loadOrtho(&modelViewProj, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f);\n    glUniformMatrix4fv(renderer->um4_mvp, 1, GL_FALSE, modelViewProj.m);                    IJK_GLES2_checkError_TRACE(\"glUniformMatrix4fv(um4_mvp)\");\n\n    IJK_GLES2_Renderer_TexCoords_reset(renderer);\n    IJK_GLES2_Renderer_TexCoords_reloadVertex(renderer);\n\n    IJK_GLES2_Renderer_Vertices_reset(renderer);\n    IJK_GLES2_Renderer_Vertices_reloadVertex(renderer);\n\n    return GL_TRUE;\n}", "path": "ijkplayer/ijkmedia/ijksdl/gles2/renderer.c", "commit_date": "2017-03-07 00:00:00", "repo_name": "bilibili/ijkplayer", "stars": 32030, "license": "gpl-2.0", "language": "c", "size": 8283}
{"docstring": "/* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */\n", "func_signal": "CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)", "code": "{\n    if (number >= INT_MAX)\n    {\n        object->valueint = INT_MAX;\n    }\n    else if (number <= INT_MIN)\n    {\n        object->valueint = INT_MIN;\n    }\n    else\n    {\n        object->valueint = (int)number;\n    }\n\n    return object->valuedouble = number;\n}", "path": "ijkplayer/ijkmedia/ijkplayer/ijkavformat/cJSON.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "bilibili/ijkplayer", "stars": 32030, "license": "gpl-2.0", "language": "c", "size": 8283}
{"docstring": "/* Utility for array list handling. */\n", "func_signal": "static void suffix_object(cJSON *prev, cJSON *item)", "code": "{\n    prev->next = item;\n    item->prev = prev;\n}", "path": "ijkplayer/ijkmedia/ijkplayer/ijkavformat/cJSON.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "bilibili/ijkplayer", "stars": 32030, "license": "gpl-2.0", "language": "c", "size": 8283}
{"docstring": "/* Duplication */\n", "func_signal": "CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)", "code": "{\n    cJSON *newitem = NULL;\n    cJSON *child = NULL;\n    cJSON *next = NULL;\n    cJSON *newchild = NULL;\n\n    /* Bail on bad ptr */\n    if (!item)\n    {\n        goto fail;\n    }\n    /* Create new item */\n    newitem = cJSON_New_Item(&global_hooks);\n    if (!newitem)\n    {\n        goto fail;\n    }\n    /* Copy over all vars */\n    newitem->type = item->type & (~cJSON_IsReference);\n    newitem->valueint = item->valueint;\n    newitem->valuedouble = item->valuedouble;\n    if (item->valuestring)\n    {\n        newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);\n        if (!newitem->valuestring)\n        {\n            goto fail;\n        }\n    }\n    if (item->string)\n    {\n        newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);\n        if (!newitem->string)\n        {\n            goto fail;\n        }\n    }\n    /* If non-recursive, then we're done! */\n    if (!recurse)\n    {\n        return newitem;\n    }\n    /* Walk the ->next chain for the child. */\n    child = item->child;\n    while (child != NULL)\n    {\n        newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */\n        if (!newchild)\n        {\n            goto fail;\n        }\n        if (next != NULL)\n        {\n            /* If newitem->child already set, then crosswire ->prev and ->next and move on */\n            next->next = newchild;\n            newchild->prev = next;\n            next = newchild;\n        }\n        else\n        {\n            /* Set newitem->child and move to it */\n            newitem->child = newchild;\n            next = newchild;\n        }\n        child = child->next;\n    }\n\n    return newitem;\n\nfail:\n    if (newitem != NULL)\n    {\n        cJSON_Delete(newitem);\n    }\n\n    return NULL;\n}", "path": "ijkplayer/ijkmedia/ijkplayer/ijkavformat/cJSON.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "bilibili/ijkplayer", "stars": 32030, "license": "gpl-2.0", "language": "c", "size": 8283}
{"docstring": "/* Case insensitive string comparison, doesn't consider two NULL pointers equal though */\n", "func_signal": "static int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)", "code": "{\n    if ((string1 == NULL) || (string2 == NULL))\n    {\n        return 1;\n    }\n\n    if (string1 == string2)\n    {\n        return 0;\n    }\n\n    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)\n    {\n        if (*string1 == '\\0')\n        {\n            return 0;\n        }\n    }\n\n    return tolower(*string1) - tolower(*string2);\n}", "path": "ijkplayer/ijkmedia/ijkplayer/ijkavformat/cJSON.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "bilibili/ijkplayer", "stars": 32030, "license": "gpl-2.0", "language": "c", "size": 8283}
{"docstring": "/* realloc printbuffer if necessary to have at least \"needed\" bytes more */\n", "func_signal": "static unsigned char* ensure(printbuffer * const p, size_t needed)", "code": "{\n    unsigned char *newbuffer = NULL;\n    size_t newsize = 0;\n\n    if ((p == NULL) || (p->buffer == NULL))\n    {\n        return NULL;\n    }\n\n    if ((p->length > 0) && (p->offset >= p->length))\n    {\n        /* make sure that offset is valid */\n        return NULL;\n    }\n\n    if (needed > INT_MAX)\n    {\n        /* sizes bigger than INT_MAX are currently not supported */\n        return NULL;\n    }\n\n    needed += p->offset + 1;\n    if (needed <= p->length)\n    {\n        return p->buffer + p->offset;\n    }\n\n    if (p->noalloc) {\n        return NULL;\n    }\n\n    /* calculate new buffer size */\n    if (needed > (INT_MAX / 2))\n    {\n        /* overflow of int, use INT_MAX if possible */\n        if (needed <= INT_MAX)\n        {\n            newsize = INT_MAX;\n        }\n        else\n        {\n            return NULL;\n        }\n    }\n    else\n    {\n        newsize = needed * 2;\n    }\n\n    if (p->hooks.reallocate != NULL)\n    {\n        /* reallocate with realloc if available */\n        newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);\n        if (newbuffer == NULL)\n        {\n            p->hooks.deallocate(p->buffer);\n            p->length = 0;\n            p->buffer = NULL;\n\n            return NULL;\n        }\n    }\n    else\n    {\n        /* otherwise reallocate manually */\n        newbuffer = (unsigned char*)p->hooks.allocate(newsize);\n        if (!newbuffer)\n        {\n            p->hooks.deallocate(p->buffer);\n            p->length = 0;\n            p->buffer = NULL;\n\n            return NULL;\n        }\n        if (newbuffer)\n        {\n            memcpy(newbuffer, p->buffer, p->offset + 1);\n        }\n        p->hooks.deallocate(p->buffer);\n    }\n    p->length = newsize;\n    p->buffer = newbuffer;\n\n    return newbuffer + p->offset;\n}", "path": "ijkplayer/ijkmedia/ijkplayer/ijkavformat/cJSON.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "bilibili/ijkplayer", "stars": 32030, "license": "gpl-2.0", "language": "c", "size": 8283}
{"docstring": "/* Build an array from input text. */\n", "func_signal": "static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)", "code": "{\n    cJSON *head = NULL; /* head of the linked list */\n    cJSON *current_item = NULL;\n\n    if (input_buffer->depth >= CJSON_NESTING_LIMIT)\n    {\n        return false; /* to deeply nested */\n    }\n    input_buffer->depth++;\n\n    if (buffer_at_offset(input_buffer)[0] != '[')\n    {\n        /* not an array */\n        goto fail;\n    }\n\n    input_buffer->offset++;\n    buffer_skip_whitespace(input_buffer);\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ']'))\n    {\n        /* empty array */\n        goto success;\n    }\n\n    /* check if we skipped to the end of the buffer */\n    if (cannot_access_at_index(input_buffer, 0))\n    {\n        input_buffer->offset--;\n        goto fail;\n    }\n\n    /* step back to character in front of the first element */\n    input_buffer->offset--;\n    /* loop through the comma separated array elements */\n    do\n    {\n        /* allocate next item */\n        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));\n        if (new_item == NULL)\n        {\n            goto fail; /* allocation failure */\n        }\n\n        /* attach next item to list */\n        if (head == NULL)\n        {\n            /* start the linked list */\n            current_item = head = new_item;\n        }\n        else\n        {\n            /* add to the end and advance */\n            current_item->next = new_item;\n            new_item->prev = current_item;\n            current_item = new_item;\n        }\n\n        /* parse next value */\n        input_buffer->offset++;\n        buffer_skip_whitespace(input_buffer);\n        if (!parse_value(current_item, input_buffer))\n        {\n            goto fail; /* failed to parse value */\n        }\n        buffer_skip_whitespace(input_buffer);\n    }\n    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));\n\n    if (cannot_access_at_index(input_buffer, 0) || buffer_at_offset(input_buffer)[0] != ']')\n    {\n        goto fail; /* expected end of array */\n    }\n\nsuccess:\n    input_buffer->depth--;\n\n    item->type = cJSON_Array;\n    item->child = head;\n\n    input_buffer->offset++;\n\n    return true;\n\nfail:\n    if (head != NULL)\n    {\n        cJSON_Delete(head);\n    }\n\n    return false;\n}", "path": "ijkplayer/ijkmedia/ijkplayer/ijkavformat/cJSON.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "bilibili/ijkplayer", "stars": 32030, "license": "gpl-2.0", "language": "c", "size": 8283}
{"docstring": "/* Create Arrays: */\n", "func_signal": "CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)", "code": "{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count < 0) || (numbers == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n    for(i = 0; a && (i < (size_t)count); i++)\n    {\n        n = cJSON_CreateNumber(numbers[i]);\n        if (!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a->child = n;\n        }\n        else\n        {\n            suffix_object(p, n);\n        }\n        p = n;\n    }\n\n    return a;\n}", "path": "ijkplayer/ijkmedia/ijkplayer/ijkavformat/cJSON.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "bilibili/ijkplayer", "stars": 32030, "license": "gpl-2.0", "language": "c", "size": 8283}
{"docstring": "/* Delete a cJSON structure. */\n", "func_signal": "CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)", "code": "{\n    cJSON *next = NULL;\n    while (item != NULL)\n    {\n        next = item->next;\n        if (!(item->type & cJSON_IsReference) && (item->child != NULL))\n        {\n            cJSON_Delete(item->child);\n        }\n        if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))\n        {\n            global_hooks.deallocate(item->valuestring);\n        }\n        if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))\n        {\n            global_hooks.deallocate(item->string);\n        }\n        global_hooks.deallocate(item);\n        item = next;\n    }\n}", "path": "ijkplayer/ijkmedia/ijkplayer/ijkavformat/cJSON.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "bilibili/ijkplayer", "stars": 32030, "license": "gpl-2.0", "language": "c", "size": 8283}
{"docstring": "/* Utility for handling references. */\n", "func_signal": "static cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)", "code": "{\n    cJSON *reference = NULL;\n    if (item == NULL)\n    {\n        return NULL;\n    }\n\n    reference = cJSON_New_Item(hooks);\n    if (reference == NULL)\n    {\n        return NULL;\n    }\n\n    memcpy(reference, item, sizeof(cJSON));\n    reference->string = NULL;\n    reference->type |= cJSON_IsReference;\n    reference->next = reference->prev = NULL;\n    return reference;\n}", "path": "ijkplayer/ijkmedia/ijkplayer/ijkavformat/cJSON.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "bilibili/ijkplayer", "stars": 32030, "license": "gpl-2.0", "language": "c", "size": 8283}
{"docstring": "/** Discard data from the FIFO. */\n", "func_signal": "void ijk_av_fifo_drain(IjkFifoBuffer *f, int size)", "code": "{\n    assert(ijk_av_fifo_size(f) >= size);\n    f->rptr += size;\n    if (f->rptr >= f->end)\n        f->rptr -= f->end - f->buffer;\n    f->rndx += size;\n}", "path": "ijkplayer/ijkmedia/ijkplayer/ijkavutil/ijkfifo.c", "commit_date": "2017-02-04 00:00:00", "repo_name": "bilibili/ijkplayer", "stars": 32030, "license": "gpl-2.0", "language": "c", "size": 8283}
{"docstring": "/* Replace array/object items with new ones. */\n", "func_signal": "CJSON_PUBLIC(void) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)", "code": "{\n    cJSON *after_inserted = NULL;\n\n    if (which < 0)\n    {\n        return;\n    }\n\n    after_inserted = get_array_item(array, (size_t)which);\n    if (after_inserted == NULL)\n    {\n        cJSON_AddItemToArray(array, newitem);\n        return;\n    }\n\n    newitem->next = after_inserted;\n    newitem->prev = after_inserted->prev;\n    after_inserted->prev = newitem;\n    if (after_inserted == array->child)\n    {\n        array->child = newitem;\n    }\n    else\n    {\n        newitem->prev->next = newitem;\n    }\n}", "path": "ijkplayer/ijkmedia/ijkplayer/ijkavformat/cJSON.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "bilibili/ijkplayer", "stars": 32030, "license": "gpl-2.0", "language": "c", "size": 8283}
{"docstring": "/* Create basic types: */\n", "func_signal": "CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void)", "code": "{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = cJSON_NULL;\n    }\n\n    return item;\n}", "path": "ijkplayer/ijkmedia/ijkplayer/ijkavformat/cJSON.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "bilibili/ijkplayer", "stars": 32030, "license": "gpl-2.0", "language": "c", "size": 8283}
{"docstring": "/* Render the number nicely from the given item into a string. */\n", "func_signal": "static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)", "code": "{\n    unsigned char *output_pointer = NULL;\n    double d = item->valuedouble;\n    int length = 0;\n    size_t i = 0;\n    unsigned char number_buffer[26]; /* temporary buffer to print the number into */\n    unsigned char decimal_point = get_decimal_point();\n    double test;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* This checks for NaN and Infinity */\n    if ((d * 0) != 0)\n    {\n        length = sprintf((char*)number_buffer, \"null\");\n    }\n    else\n    {\n        /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */\n        length = sprintf((char*)number_buffer, \"%1.15g\", d);\n\n        /* Check whether the original double can be recovered */\n        if ((sscanf((char*)number_buffer, \"%lg\", &test) != 1) || ((double)test != d))\n        {\n            /* If not, print with 17 decimal places of precision */\n            length = sprintf((char*)number_buffer, \"%1.17g\", d);\n        }\n    }\n\n    /* sprintf failed or buffer overrun occured */\n    if ((length < 0) || (length > (int)(sizeof(number_buffer) - 1)))\n    {\n        return false;\n    }\n\n    /* reserve appropriate space in the output */\n    output_pointer = ensure(output_buffer, (size_t)length);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n\n    /* copy the printed number to the output and replace locale\n     * dependent decimal point with '.' */\n    for (i = 0; i < ((size_t)length); i++)\n    {\n        if (number_buffer[i] == decimal_point)\n        {\n            output_pointer[i] = '.';\n            continue;\n        }\n\n        output_pointer[i] = number_buffer[i];\n    }\n    output_pointer[i] = '\\0';\n\n    output_buffer->offset += (size_t)length;\n\n    return true;\n}", "path": "ijkplayer/ijkmedia/ijkplayer/ijkavformat/cJSON.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "bilibili/ijkplayer", "stars": 32030, "license": "gpl-2.0", "language": "c", "size": 8283}
{"docstring": "/* Internal constructor. */\n", "func_signal": "static cJSON *cJSON_New_Item(const internal_hooks * const hooks)", "code": "{\n    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));\n    if (node)\n    {\n        memset(node, '\\0', sizeof(cJSON));\n    }\n\n    return node;\n}", "path": "ijkplayer/ijkmedia/ijkplayer/ijkavformat/cJSON.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "bilibili/ijkplayer", "stars": 32030, "license": "gpl-2.0", "language": "c", "size": 8283}
{"docstring": "/* Render the cstring provided to an escaped version that can be printed. */\n", "func_signal": "static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer)", "code": "{\n    const unsigned char *input_pointer = NULL;\n    unsigned char *output = NULL;\n    unsigned char *output_pointer = NULL;\n    size_t output_length = 0;\n    /* numbers of additional characters needed for escaping */\n    size_t escape_characters = 0;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* empty string */\n    if (input == NULL)\n    {\n        output = ensure(output_buffer, sizeof(\"\\\"\\\"\"));\n        if (output == NULL)\n        {\n            return false;\n        }\n        strcpy((char*)output, \"\\\"\\\"\");\n\n        return true;\n    }\n\n    /* set \"flag\" to 1 if something needs to be escaped */\n    for (input_pointer = input; *input_pointer; input_pointer++)\n    {\n        switch (*input_pointer)\n        {\n            case '\\\"':\n            case '\\\\':\n            case '\\b':\n            case '\\f':\n            case '\\n':\n            case '\\r':\n            case '\\t':\n                /* one character escape sequence */\n                escape_characters++;\n                break;\n            default:\n                if (*input_pointer < 32)\n                {\n                    /* UTF-16 escape sequence uXXXX */\n                    escape_characters += 5;\n                }\n                break;\n        }\n    }\n    output_length = (size_t)(input_pointer - input) + escape_characters;\n\n    output = ensure(output_buffer, output_length + sizeof(\"\\\"\\\"\"));\n    if (output == NULL)\n    {\n        return false;\n    }\n\n    /* no characters have to be escaped */\n    if (escape_characters == 0)\n    {\n        output[0] = '\\\"';\n        memcpy(output + 1, input, output_length);\n        output[output_length + 1] = '\\\"';\n        output[output_length + 2] = '\\0';\n\n        return true;\n    }\n\n    output[0] = '\\\"';\n    output_pointer = output + 1;\n    /* copy the string */\n    for (input_pointer = input; *input_pointer != '\\0'; (void)input_pointer++, output_pointer++)\n    {\n        if ((*input_pointer > 31) && (*input_pointer != '\\\"') && (*input_pointer != '\\\\'))\n        {\n            /* normal character, copy */\n            *output_pointer = *input_pointer;\n        }\n        else\n        {\n            /* character needs to be escaped */\n            *output_pointer++ = '\\\\';\n            switch (*input_pointer)\n            {\n                case '\\\\':\n                    *output_pointer = '\\\\';\n                    break;\n                case '\\\"':\n                    *output_pointer = '\\\"';\n                    break;\n                case '\\b':\n                    *output_pointer = 'b';\n                    break;\n                case '\\f':\n                    *output_pointer = 'f';\n                    break;\n                case '\\n':\n                    *output_pointer = 'n';\n                    break;\n                case '\\r':\n                    *output_pointer = 'r';\n                    break;\n                case '\\t':\n                    *output_pointer = 't';\n                    break;\n                default:\n                    /* escape and print as unicode codepoint */\n                    sprintf((char*)output_pointer, \"u%04x\", *input_pointer);\n                    output_pointer += 4;\n                    break;\n            }\n        }\n    }\n    output[output_length + 1] = '\\\"';\n    output[output_length + 2] = '\\0';\n\n    return true;\n}", "path": "ijkplayer/ijkmedia/ijkplayer/ijkavformat/cJSON.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "bilibili/ijkplayer", "stars": 32030, "license": "gpl-2.0", "language": "c", "size": 8283}
{"docstring": "/* src must NOT be const as it can be a context for func that may need\n * updating (like a pointer or byte counter) */\n", "func_signal": "int ijk_av_fifo_generic_write(IjkFifoBuffer *f, void *src, int size,\n                          int (*func)(void *, void *, int))", "code": "{\n    int total = size;\n    uint32_t wndx= f->wndx;\n    uint8_t *wptr= f->wptr;\n\n    do {\n        int len = FFMIN(f->end - wptr, size);\n        if (func) {\n            len = func(src, wptr, len);\n            if (len <= 0)\n                break;\n        } else {\n            memcpy(wptr, src, len);\n            src = (uint8_t *)src + len;\n        }\n// Write memory barrier needed for SMP here in theory\n        wptr += len;\n        if (wptr >= f->end)\n            wptr = f->buffer;\n        wndx    += len;\n        size    -= len;\n    } while (size > 0);\n    f->wndx= wndx;\n    f->wptr= wptr;\n    return total - size;\n}", "path": "ijkplayer/ijkmedia/ijkplayer/ijkavutil/ijkfifo.c", "commit_date": "2017-02-04 00:00:00", "repo_name": "bilibili/ijkplayer", "stars": 32030, "license": "gpl-2.0", "language": "c", "size": 8283}
{"docstring": "/* XXX ngx_open_and_stat_file is static in the core. sigh. */\n", "func_signal": "ngx_int_t\nngx_http_lua_open_and_stat_file(u_char *name, ngx_open_file_info_t *of,\n    ngx_log_t *log)", "code": "{\n    ngx_fd_t         fd;\n    ngx_file_info_t  fi;\n\n    if (of->fd != NGX_INVALID_FILE) {\n\n        if (ngx_file_info(name, &fi) == NGX_FILE_ERROR) {\n            of->failed = ngx_file_info_n;\n            goto failed;\n        }\n\n        if (of->uniq == ngx_file_uniq(&fi)) {\n            goto done;\n        }\n\n    } else if (of->test_dir) {\n\n        if (ngx_file_info(name, &fi) == NGX_FILE_ERROR) {\n            of->failed = ngx_file_info_n;\n            goto failed;\n        }\n\n        if (ngx_is_dir(&fi)) {\n            goto done;\n        }\n    }\n\n    if (!of->log) {\n\n        /*\n         * Use non-blocking open() not to hang on FIFO files, etc.\n         * This flag has no effect on a regular files.\n         */\n\n        fd = ngx_open_file(name, NGX_FILE_RDONLY|NGX_FILE_NONBLOCK,\n                           NGX_FILE_OPEN, 0);\n\n    } else {\n        fd = ngx_open_file(name, NGX_FILE_APPEND, NGX_FILE_CREATE_OR_OPEN,\n                           NGX_FILE_DEFAULT_ACCESS);\n    }\n\n    if (fd == NGX_INVALID_FILE) {\n        of->failed = ngx_open_file_n;\n        goto failed;\n    }\n\n    if (ngx_fd_info(fd, &fi) == NGX_FILE_ERROR) {\n        ngx_log_error(NGX_LOG_CRIT, log, ngx_errno,\n                      ngx_fd_info_n \" \\\"%s\\\" failed\", name);\n\n        if (ngx_close_file(fd) == NGX_FILE_ERROR) {\n            ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n                          ngx_close_file_n \" \\\"%s\\\" failed\", name);\n        }\n\n        of->fd = NGX_INVALID_FILE;\n\n        return NGX_ERROR;\n    }\n\n    if (ngx_is_dir(&fi)) {\n        if (ngx_close_file(fd) == NGX_FILE_ERROR) {\n            ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n                          ngx_close_file_n \" \\\"%s\\\" failed\", name);\n        }\n\n        of->fd = NGX_INVALID_FILE;\n\n    } else {\n        of->fd = fd;\n\n        if (of->directio <= ngx_file_size(&fi)) {\n            if (ngx_directio_on(fd) == NGX_FILE_ERROR) {\n                ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n                              ngx_directio_on_n \" \\\"%s\\\" failed\", name);\n\n            } else {\n                of->is_directio = 1;\n            }\n        }\n    }\n\ndone:\n\n    of->uniq = ngx_file_uniq(&fi);\n    of->mtime = ngx_file_mtime(&fi);\n    of->size = ngx_file_size(&fi);\n    of->fs_size = ngx_file_fs_size(&fi);\n    of->is_dir = ngx_is_dir(&fi);\n    of->is_file = ngx_is_file(&fi);\n    of->is_link = ngx_is_link(&fi);\n    of->is_exec = ngx_is_exec(&fi);\n\n    return NGX_OK;\n\nfailed:\n\n    of->fd = NGX_INVALID_FILE;\n    of->err = ngx_errno;\n\n    return NGX_ERROR;\n}", "path": "lua-nginx-module/src/ngx_http_lua_util.c", "commit_date": "2020-11-01 00:00:00", "repo_name": "openresty/lua-nginx-module", "stars": 11037, "license": "None", "language": "c", "size": 15364}
{"docstring": "/* post read callback for rewrite and access phases */\n", "func_signal": "void\nngx_http_lua_generic_phase_post_read(ngx_http_request_t *r)", "code": "{\n    ngx_http_lua_ctx_t  *ctx;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"lua post read for rewrite/access phases\");\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);\n\n    ctx->read_body_done = 1;\n\n    r->main->count--;\n\n    if (ctx->waiting_more_body) {\n        ctx->waiting_more_body = 0;\n        ngx_http_core_run_phases(r);\n    }\n}", "path": "lua-nginx-module/src/ngx_http_lua_util.c", "commit_date": "2020-11-01 00:00:00", "repo_name": "openresty/lua-nginx-module", "stars": 11037, "license": "None", "language": "c", "size": 15364}
{"docstring": "/* OPENRESTY_LUAJIT */\n", "func_signal": "ngx_int_t\nngx_http_lua_clfactory_loadfile(lua_State *L, const char *filename)", "code": "{\n    int                         c, status, readstatus;\n    ngx_flag_t                  sharp;\n\n    ngx_http_lua_clfactory_file_ctx_t        lf;\n\n    /* index of filename on the stack */\n    int                         fname_index;\n\n    sharp = 0;\n    fname_index = lua_gettop(L) + 1;\n\n    lf.extraline = 0;\n    lf.file_type = NGX_LUA_TEXT_FILE;\n\n#ifndef OPENRESTY_LUAJIT\n    lf.begin_code.ptr = CLFACTORY_BEGIN_CODE;\n    lf.begin_code_len = CLFACTORY_BEGIN_SIZE;\n    lf.end_code.ptr = CLFACTORY_END_CODE;\n    lf.end_code_len = CLFACTORY_END_SIZE;\n#endif\n\n    lua_pushfstring(L, \"@%s\", filename);\n\n    lf.f = fopen(filename, \"r\");\n    if (lf.f == NULL) {\n        return ngx_http_lua_clfactory_errfile(L, \"open\", fname_index);\n    }\n\n    c = getc(lf.f);\n\n    if (c == '#') {  /* Unix exec. file? */\n        lf.extraline = 1;\n\n        while ((c = getc(lf.f)) != EOF && c != '\\n') {\n            /* skip first line */\n        }\n\n        if (c == '\\n') {\n            c = getc(lf.f);\n        }\n\n        sharp = 1;\n    }\n\n    if (c == LUA_SIGNATURE[0] && filename) {  /* binary file? */\n        lf.f = freopen(filename, \"rb\", lf.f);  /* reopen in binary mode */\n\n        if (lf.f == NULL) {\n            return ngx_http_lua_clfactory_errfile(L, \"reopen\", fname_index);\n        }\n\n        /* check whether lib jit exists */\n        luaL_findtable(L, LUA_REGISTRYINDEX, \"_LOADED\", 1);\n        lua_getfield(L, -1, \"jit\");  /* get _LOADED[\"jit\"] */\n\n        if (lua_istable(L, -1)) {\n            lf.file_type = NGX_LUA_BT_LJ;\n\n        } else {\n            lf.file_type = NGX_LUA_BT_LUA;\n        }\n\n        lua_pop(L, 2);\n\n        /*\n         * Loading bytecode with an extra header is disabled for security\n         * reasons. This may circumvent the usual check for bytecode vs.\n         * Lua code by looking at the first char. Since this is a potential\n         * security violation no attempt is made to echo the chunkname either.\n         */\n        if (lf.file_type == NGX_LUA_BT_LJ && sharp) {\n\n            if (filename) {\n                fclose(lf.f);  /* close file (even in case of errors) */\n            }\n\n            filename = lua_tostring(L, fname_index) + 1;\n            lua_pushfstring(L, \"bad byte-code header in %s\", filename);\n            lua_remove(L, fname_index);\n\n            return LUA_ERRFILE;\n        }\n\n        while ((c = getc(lf.f)) != EOF && c != LUA_SIGNATURE[0]) {\n            /* skip eventual `#!...' */\n        }\n\n#ifndef OPENRESTY_LUAJIT\n        status = ngx_http_lua_clfactory_bytecode_prepare(L, &lf, fname_index);\n\n        if (status != 0) {\n            return status;\n        }\n#endif\n\n        lf.extraline = 0;\n    }\n\n#ifndef OPENRESTY_LUAJIT\n    if (lf.file_type == NGX_LUA_TEXT_FILE) {\n        ungetc(c, lf.f);\n    }\n\n    lf.sent_begin = lf.sent_end = 0;\n\n#else\n    ungetc(c, lf.f);\n#endif\n    status = lua_load(L, ngx_http_lua_clfactory_getF, &lf,\n                      lua_tostring(L, -1));\n\n    readstatus = ferror(lf.f);\n\n    if (filename) {\n        fclose(lf.f);  /* close file (even in case of errors) */\n    }\n\n    if (readstatus) {\n        lua_settop(L, fname_index);  /* ignore results from `lua_load' */\n        return ngx_http_lua_clfactory_errfile(L, \"read\", fname_index);\n    }\n\n    lua_remove(L, fname_index);\n\n    return status;\n}", "path": "lua-nginx-module/src/ngx_http_lua_clfactory.c", "commit_date": "2019-09-30 00:00:00", "repo_name": "openresty/lua-nginx-module", "stars": 11037, "license": "None", "language": "c", "size": 15364}
{"docstring": "/* NGX_HTTP_SSL */\n", "func_signal": "static char *\nngx_http_lua_malloc_trim(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)", "code": "{\n#if (NGX_HTTP_LUA_HAVE_MALLOC_TRIM)\n\n    ngx_int_t       nreqs;\n    ngx_str_t      *value;\n\n    ngx_http_lua_main_conf_t    *lmcf = conf;\n\n    value = cf->args->elts;\n\n    nreqs = ngx_atoi(value[1].data, value[1].len);\n    if (nreqs == NGX_ERROR) {\n        return \"invalid number in the 1st argument\";\n    }\n\n    lmcf->malloc_trim_cycle = (ngx_uint_t) nreqs;\n\n    if (nreqs == 0) {\n        return NGX_CONF_OK;\n    }\n\n    lmcf->requires_log = 1;\n\n#else\n\n    ngx_conf_log_error(NGX_LOG_WARN, cf, 0, \"lua_malloc_trim is not supported \"\n                       \"on this platform, ignored\");\n\n#endif\n    return NGX_CONF_OK;\n}", "path": "lua-nginx-module/src/ngx_http_lua_module.c", "commit_date": "2020-10-09 00:00:00", "repo_name": "openresty/lua-nginx-module", "stars": 11037, "license": "None", "language": "c", "size": 15364}
{"docstring": "/**\n * Set environment table for the given code closure.\n *\n * Before:\n *         | code closure | <- top\n *         |      ...     |\n *\n * After:\n *         | code closure | <- top\n *         |      ...     |\n * */\n", "func_signal": "static void\nngx_http_lua_body_filter_by_lua_env(lua_State *L, ngx_http_request_t *r,\n    ngx_chain_t *in)", "code": "{\n    ngx_http_lua_main_conf_t    *lmcf;\n\n    ngx_http_lua_set_req(L, r);\n\n    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);\n    lmcf->body_filter_chain = in;\n\n#ifndef OPENRESTY_LUAJIT\n    /**\n     * we want to create empty environment for current script\n     *\n     * setmetatable({}, {__index = _G})\n     *\n     * if a function or symbol is not defined in our env, __index will lookup\n     * in the global env.\n     *\n     * all variables created in the script-env will be thrown away at the end\n     * of the script run.\n     * */\n    ngx_http_lua_create_new_globals_table(L, 0 /* narr */, 1 /* nrec */);\n\n    /*  {{{ make new env inheriting main thread's globals table */\n    lua_createtable(L, 0, 1 /* nrec */);    /*  the metatable for the new\n                                                env */\n    ngx_http_lua_get_globals_table(L);\n    lua_setfield(L, -2, \"__index\");\n    lua_setmetatable(L, -2);    /*  setmetatable({}, {__index = _G}) */\n    /*  }}} */\n\n    lua_setfenv(L, -2);    /*  set new running env for the code closure */\n#endif /* OPENRESTY_LUAJIT */\n}", "path": "lua-nginx-module/src/ngx_http_lua_bodyfilterby.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "openresty/lua-nginx-module", "stars": 11037, "license": "None", "language": "c", "size": 15364}
{"docstring": "/* defined(NDK) && NDK */\n", "func_signal": "char *\nngx_http_lua_rewrite_by_lua_block(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf)", "code": "{\n    char        *rv;\n    ngx_conf_t   save;\n\n    save = *cf;\n    cf->handler = ngx_http_lua_rewrite_by_lua;\n    cf->handler_conf = conf;\n\n    rv = ngx_http_lua_conf_lua_block_parse(cf, cmd);\n\n    *cf = save;\n\n    return rv;\n}", "path": "lua-nginx-module/src/ngx_http_lua_directive.c", "commit_date": "2020-07-23 00:00:00", "repo_name": "openresty/lua-nginx-module", "stars": 11037, "license": "None", "language": "c", "size": 15364}
{"docstring": "/* de-serialized a SSL session and set it back to the request at lua context */\n", "func_signal": "int\nngx_http_lua_ffi_ssl_set_serialized_session(ngx_http_request_t *r,\n    const unsigned char *data, int len, char **err)", "code": "{\n    u_char                          *p;\n    u_char                           buf[NGX_SSL_MAX_SESSION_SIZE];\n    ngx_ssl_conn_t                  *ssl_conn;\n    ngx_connection_t                *c;\n    ngx_ssl_session_t               *session = NULL;\n    ngx_ssl_session_t               *old_session;\n    ngx_http_lua_ssl_ctx_t          *cctx;\n\n    c = r->connection;\n\n    if (c == NULL || c->ssl == NULL) {\n        *err = \"bad request\";\n        return NGX_ERROR;\n    }\n\n    ssl_conn = c->ssl->connection;\n    if (ssl_conn == NULL) {\n        *err = \"bad ssl conn\";\n        return NGX_ERROR;\n    }\n\n    ngx_memcpy(buf, data, len);\n    p = buf;\n    session = d2i_SSL_SESSION(NULL, (const unsigned char **)&p,  len);\n    if (session == NULL) {\n        ERR_clear_error();\n        *err = \"failed to de-serialize session\";\n        return NGX_ERROR;\n    }\n\n    cctx = ngx_http_lua_ssl_get_ctx(c->ssl->connection);\n    if (cctx == NULL) {\n        *err = \"bad lua context\";\n        return NGX_ERROR;\n    }\n\n    old_session = cctx->session;\n    cctx->session = session;\n\n    if (old_session != NULL) {\n        ngx_ssl_free_session(old_session);\n    }\n\n    return NGX_OK;\n}", "path": "lua-nginx-module/src/ngx_http_lua_ssl_session_fetchby.c", "commit_date": "2020-10-09 00:00:00", "repo_name": "openresty/lua-nginx-module", "stars": 11037, "license": "None", "language": "c", "size": 15364}
{"docstring": "/* load Lua code from a file for fetching cached SSL session */\n", "func_signal": "ngx_int_t\nngx_http_lua_ssl_sess_fetch_handler_file(ngx_http_request_t *r,\n    ngx_http_lua_srv_conf_t *lscf, lua_State *L)", "code": "{\n    ngx_int_t           rc;\n\n    rc = ngx_http_lua_cache_loadfile(r->connection->log, L,\n                                     lscf->srv.ssl_sess_fetch_src.data,\n                                     &lscf->srv.ssl_sess_fetch_src_ref,\n                                     lscf->srv.ssl_sess_fetch_src_key);\n    if (rc != NGX_OK) {\n        return rc;\n    }\n\n    /*  make sure we have a valid code chunk */\n    ngx_http_lua_assert(lua_isfunction(L, -1));\n\n    return ngx_http_lua_ssl_sess_fetch_by_chunk(L, r);\n}", "path": "lua-nginx-module/src/ngx_http_lua_ssl_session_fetchby.c", "commit_date": "2020-10-09 00:00:00", "repo_name": "openresty/lua-nginx-module", "stars": 11037, "license": "None", "language": "c", "size": 15364}
{"docstring": "/* OPENRESTY_LUAJIT */\n", "func_signal": "static lua_State *\nngx_http_lua_new_state(lua_State *parent_vm, ngx_cycle_t *cycle,\n    ngx_http_lua_main_conf_t *lmcf, ngx_log_t *log)", "code": "{\n    lua_State       *L;\n    const char      *old_path;\n    const char      *new_path;\n    size_t           old_path_len;\n    const char      *old_cpath;\n    const char      *new_cpath;\n    size_t           old_cpath_len;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, log, 0, \"lua creating new vm state\");\n\n    L = luaL_newstate();\n    if (L == NULL) {\n        return NULL;\n    }\n\n    luaL_openlibs(L);\n\n    lua_getglobal(L, \"package\");\n\n    if (!lua_istable(L, -1)) {\n        ngx_log_error(NGX_LOG_EMERG, log, 0,\n                      \"the \\\"package\\\" table does not exist\");\n        return NULL;\n    }\n\n    if (parent_vm) {\n        lua_getglobal(parent_vm, \"package\");\n        lua_getfield(parent_vm, -1, \"path\");\n        old_path = lua_tolstring(parent_vm, -1, &old_path_len);\n        lua_pop(parent_vm, 1);\n\n        lua_pushlstring(L, old_path, old_path_len);\n        lua_setfield(L, -2, \"path\");\n\n        lua_getfield(parent_vm, -1, \"cpath\");\n        old_path = lua_tolstring(parent_vm, -1, &old_path_len);\n        lua_pop(parent_vm, 2);\n\n        lua_pushlstring(L, old_path, old_path_len);\n        lua_setfield(L, -2, \"cpath\");\n\n    } else {\n#ifdef LUA_DEFAULT_PATH\n#   define LUA_DEFAULT_PATH_LEN (sizeof(LUA_DEFAULT_PATH) - 1)\n        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, log, 0,\n                       \"lua prepending default package.path with %s\",\n                       LUA_DEFAULT_PATH);\n\n        lua_pushliteral(L, LUA_DEFAULT_PATH \";\"); /* package default */\n        lua_getfield(L, -2, \"path\"); /* package default old */\n        lua_concat(L, 2); /* package new */\n        lua_setfield(L, -2, \"path\"); /* package */\n#endif\n\n#ifdef LUA_DEFAULT_CPATH\n#   define LUA_DEFAULT_CPATH_LEN (sizeof(LUA_DEFAULT_CPATH) - 1)\n        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, log, 0,\n                       \"lua prepending default package.cpath with %s\",\n                       LUA_DEFAULT_CPATH);\n\n        lua_pushliteral(L, LUA_DEFAULT_CPATH \";\"); /* package default */\n        lua_getfield(L, -2, \"cpath\"); /* package default old */\n        old_cpath = lua_tolstring(L, -1, &old_cpath_len);\n        lua_concat(L, 2); /* package new */\n        lua_setfield(L, -2, \"cpath\"); /* package */\n#endif\n\n        if (lmcf->lua_path.len != 0) {\n            lua_getfield(L, -1, \"path\"); /* get original package.path */\n            old_path = lua_tolstring(L, -1, &old_path_len);\n\n            dd(\"old path: %s\", old_path);\n\n            lua_pushlstring(L, (char *) lmcf->lua_path.data,\n                            lmcf->lua_path.len);\n            new_path = lua_tostring(L, -1);\n\n            ngx_http_lua_set_path(cycle, L, -3, \"path\", new_path, old_path,\n                                  log);\n\n            lua_pop(L, 2);\n        }\n\n        if (lmcf->lua_cpath.len != 0) {\n            lua_getfield(L, -1, \"cpath\"); /* get original package.cpath */\n            old_cpath = lua_tolstring(L, -1, &old_cpath_len);\n\n            dd(\"old cpath: %s\", old_cpath);\n\n            lua_pushlstring(L, (char *) lmcf->lua_cpath.data,\n                            lmcf->lua_cpath.len);\n            new_cpath = lua_tostring(L, -1);\n\n            ngx_http_lua_set_path(cycle, L, -3, \"cpath\", new_cpath, old_cpath,\n                                  log);\n\n\n            lua_pop(L, 2);\n        }\n    }\n\n    lua_pop(L, 1); /* remove the \"package\" table */\n\n    ngx_http_lua_init_registry(L, log);\n    ngx_http_lua_init_globals(L, cycle, lmcf, log);\n\n    return L;\n}", "path": "lua-nginx-module/src/ngx_http_lua_util.c", "commit_date": "2020-11-01 00:00:00", "repo_name": "openresty/lua-nginx-module", "stars": 11037, "license": "None", "language": "c", "size": 15364}
{"docstring": "/**\n * Override Lua print function, output message to nginx error logs. Equal to\n * ngx.log(ngx.NOTICE, ...).\n *\n * @param L Lua state pointer\n * @retval always 0 (don't return values to Lua)\n * */\n", "func_signal": "int\nngx_http_lua_print(lua_State *L)", "code": "{\n    ngx_log_t                   *log;\n    ngx_http_request_t          *r;\n\n    r = ngx_http_lua_get_req(L);\n\n    if (r && r->connection && r->connection->log) {\n        log = r->connection->log;\n\n    } else {\n        log = ngx_cycle->log;\n    }\n\n    return log_wrapper(log, \"[lua] \", NGX_LOG_NOTICE, L);\n}", "path": "lua-nginx-module/src/ngx_http_lua_log.c", "commit_date": "2020-07-20 00:00:00", "repo_name": "openresty/lua-nginx-module", "stars": 11037, "license": "None", "language": "c", "size": 15364}
{"docstring": "/* XXX we also decode '+' to ' ' */\n", "func_signal": "void\nngx_http_lua_unescape_uri(u_char **dst, u_char **src, size_t size,\n    ngx_uint_t type)", "code": "{\n    u_char  *d, *s, ch, c, decoded;\n    enum {\n        sw_usual = 0,\n        sw_quoted,\n        sw_quoted_second,\n    } state;\n\n    d = *dst;\n    s = *src;\n\n    state = 0;\n    decoded = 0;\n\n    while (size--) {\n\n        ch = *s++;\n\n        switch (state) {\n        case sw_usual:\n            if (ch == '?'\n                && (type & (NGX_UNESCAPE_URI|NGX_UNESCAPE_REDIRECT)))\n            {\n                *d++ = ch;\n                goto done;\n            }\n\n            if (ch == '%') {\n                state = sw_quoted;\n                break;\n            }\n\n            if (ch == '+') {\n                *d++ = ' ';\n                break;\n            }\n\n            *d++ = ch;\n            break;\n\n        case sw_quoted:\n\n            if (ch >= '0' && ch <= '9') {\n                decoded = (u_char) (ch - '0');\n                state = sw_quoted_second;\n                break;\n            }\n\n            c = (u_char) (ch | 0x20);\n            if (c >= 'a' && c <= 'f') {\n                decoded = (u_char) (c - 'a' + 10);\n                state = sw_quoted_second;\n                break;\n            }\n\n            /* the invalid quoted character */\n\n            state = sw_usual;\n\n            *d++ = ch;\n\n            break;\n\n        case sw_quoted_second:\n\n            state = sw_usual;\n\n            if (ch >= '0' && ch <= '9') {\n                ch = (u_char) ((decoded << 4) + ch - '0');\n\n                if (type & NGX_UNESCAPE_REDIRECT) {\n                    if (ch > '%' && ch < 0x7f) {\n                        *d++ = ch;\n                        break;\n                    }\n\n                    *d++ = '%'; *d++ = *(s - 2); *d++ = *(s - 1);\n                    break;\n                }\n\n                *d++ = ch;\n\n                break;\n            }\n\n            c = (u_char) (ch | 0x20);\n            if (c >= 'a' && c <= 'f') {\n                ch = (u_char) ((decoded << 4) + c - 'a' + 10);\n\n                if (type & NGX_UNESCAPE_URI) {\n                    if (ch == '?') {\n                        *d++ = ch;\n                        goto done;\n                    }\n\n                    *d++ = ch;\n                    break;\n                }\n\n                if (type & NGX_UNESCAPE_REDIRECT) {\n                    if (ch == '?') {\n                        *d++ = ch;\n                        goto done;\n                    }\n\n                    if (ch > '%' && ch < 0x7f) {\n                        *d++ = ch;\n                        break;\n                    }\n\n                    *d++ = '%'; *d++ = *(s - 2); *d++ = *(s - 1);\n                    break;\n                }\n\n                *d++ = ch;\n\n                break;\n            }\n\n            /* the invalid quoted character */\n\n            break;\n        }\n    }\n\ndone:\n\n    *dst = d;\n    *src = s;\n}", "path": "lua-nginx-module/src/ngx_http_lua_util.c", "commit_date": "2020-11-01 00:00:00", "repo_name": "openresty/lua-nginx-module", "stars": 11037, "license": "None", "language": "c", "size": 15364}
{"docstring": "/*\n * description:\n *  run a Lua coroutine specified by ctx->cur_co_ctx->co\n * return value:\n *  NGX_AGAIN:      I/O interruption: r->main->count intact\n *  NGX_DONE:       I/O interruption: r->main->count already incremented by 1\n *  NGX_ERROR:      error\n *  >= 200          HTTP status code\n */\n", "func_signal": "ngx_int_t\nngx_http_lua_run_thread(lua_State *L, ngx_http_request_t *r,\n    ngx_http_lua_ctx_t *ctx, volatile int nrets)", "code": "{\n    ngx_http_lua_co_ctx_t   *next_coctx, *parent_coctx, *orig_coctx;\n    int                      rv, success = 1;\n    lua_State               *next_co;\n    lua_State               *old_co;\n    const char              *err, *msg, *trace;\n    ngx_int_t                rc;\n#if (NGX_PCRE)\n    ngx_pool_t              *old_pool = NULL;\n#endif\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"lua run thread, top:%d c:%ud\", lua_gettop(L),\n                   r->main->count);\n\n    /* set Lua VM panic handler */\n    lua_atpanic(L, ngx_http_lua_atpanic);\n\n    NGX_LUA_EXCEPTION_TRY {\n\n        /*\n         * silence a -Werror=clobbered warning with gcc 5.4\n         * due to above setjmp\n         */\n        err = NULL;\n        msg = NULL;\n        trace = NULL;\n\n        if (ctx->cur_co_ctx->thread_spawn_yielded) {\n            ngx_http_lua_probe_info(\"thread spawn yielded\");\n\n            ctx->cur_co_ctx->thread_spawn_yielded = 0;\n            nrets = 1;\n        }\n\n        for ( ;; ) {\n\n            dd(\"ctx: %p, co: %p, co status: %d, co is_wrap: %d\",\n               ctx, ctx->cur_co_ctx->co, ctx->cur_co_ctx->co_status,\n               ctx->cur_co_ctx->is_wrap);\n\n#if (NGX_PCRE)\n            /* XXX: work-around to nginx regex subsystem */\n            old_pool = ngx_http_lua_pcre_malloc_init(r->pool);\n#endif\n\n            orig_coctx = ctx->cur_co_ctx;\n\n#ifdef NGX_LUA_USE_ASSERT\n            dd(\"%p: saved co top: %d, nrets: %d, true top: %d\",\n               orig_coctx->co,\n               (int) orig_coctx->co_top, (int) nrets,\n               (int) lua_gettop(orig_coctx->co));\n#endif\n\n#if DDEBUG\n            if (lua_gettop(orig_coctx->co) > 0) {\n                dd(\"co top elem: %s\", luaL_typename(orig_coctx->co, -1));\n            }\n\n            if (orig_coctx->propagate_error) {\n                dd(\"co propagate_error: %d\", orig_coctx->propagate_error);\n            }\n#endif\n\n            if (orig_coctx->propagate_error) {\n                orig_coctx->propagate_error = 0;\n                goto propagate_error;\n            }\n\n            ngx_http_lua_assert(orig_coctx->co_top + nrets\n                                == lua_gettop(orig_coctx->co));\n\n            rv = lua_resume(orig_coctx->co, nrets);\n\n#if (NGX_PCRE)\n            /* XXX: work-around to nginx regex subsystem */\n            ngx_http_lua_pcre_malloc_done(old_pool);\n#endif\n\n#if 0\n            /* test the longjmp thing */\n            if (rand() % 2 == 0) {\n                NGX_LUA_EXCEPTION_THROW(1);\n            }\n#endif\n\n            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                           \"lua resume returned %d\", rv);\n\n            switch (rv) {\n            case LUA_YIELD:\n                /*  yielded, let event handler do the rest job */\n                /*  FIXME: add io cmd dispatcher here */\n\n                ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                               \"lua thread yielded\");\n\n#ifdef NGX_LUA_USE_ASSERT\n                dd(\"%p: saving curr top after yield: %d (co-op: %d)\",\n                   orig_coctx->co,\n                   (int) lua_gettop(orig_coctx->co), (int) ctx->co_op);\n                orig_coctx->co_top = lua_gettop(orig_coctx->co);\n#endif\n\n                if (r->uri_changed) {\n                    return ngx_http_lua_handle_rewrite_jump(L, r, ctx);\n                }\n\n                if (ctx->exited) {\n                    return ngx_http_lua_handle_exit(L, r, ctx);\n                }\n\n                if (ctx->exec_uri.len) {\n                    return ngx_http_lua_handle_exec(L, r, ctx);\n                }\n\n                /*\n                 * check if coroutine.resume or coroutine.yield called\n                 * lua_yield()\n                 */\n                switch (ctx->co_op) {\n\n                case NGX_HTTP_LUA_USER_CORO_NOP:\n                    dd(\"hit! it is the API yield\");\n\n                    ngx_http_lua_assert(lua_gettop(ctx->cur_co_ctx->co) == 0);\n\n                    ctx->cur_co_ctx = NULL;\n\n                    return NGX_AGAIN;\n\n                case NGX_HTTP_LUA_USER_THREAD_RESUME:\n\n                    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                                   \"lua user thread resume\");\n\n                    ctx->co_op = NGX_HTTP_LUA_USER_CORO_NOP;\n                    nrets = lua_gettop(ctx->cur_co_ctx->co) - 1;\n                    dd(\"nrets = %d\", nrets);\n\n#ifdef NGX_LUA_USE_ASSERT\n                    /* ignore the return value (the thread) already pushed */\n                    orig_coctx->co_top--;\n#endif\n\n                    break;\n\n                case NGX_HTTP_LUA_USER_CORO_RESUME:\n                    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                                   \"lua coroutine: resume\");\n\n                    /*\n                     * the target coroutine lies at the base of the\n                     * parent's stack\n                     */\n                    ctx->co_op = NGX_HTTP_LUA_USER_CORO_NOP;\n\n                    old_co = ctx->cur_co_ctx->parent_co_ctx->co;\n\n                    nrets = lua_gettop(old_co);\n                    if (nrets) {\n                        dd(\"moving %d return values to parent\", nrets);\n                        lua_xmove(old_co, ctx->cur_co_ctx->co, nrets);\n\n#ifdef NGX_LUA_USE_ASSERT\n                        ctx->cur_co_ctx->parent_co_ctx->co_top -= nrets;\n#endif\n                    }\n\n                    break;\n\n                default:\n                    /* ctx->co_op == NGX_HTTP_LUA_USER_CORO_YIELD */\n\n                    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                                   \"lua coroutine: yield\");\n\n                    ctx->co_op = NGX_HTTP_LUA_USER_CORO_NOP;\n\n                    if (ngx_http_lua_is_thread(ctx)) {\n                        ngx_http_lua_probe_thread_yield(r, ctx->cur_co_ctx->co);\n\n                        /* discard any return values from user\n                         * coroutine.yield()'s arguments */\n                        lua_settop(ctx->cur_co_ctx->co, 0);\n\n#ifdef NGX_LUA_USE_ASSERT\n                        ctx->cur_co_ctx->co_top = 0;\n#endif\n\n                        ngx_http_lua_probe_info(\"set co running\");\n                        ctx->cur_co_ctx->co_status = NGX_HTTP_LUA_CO_RUNNING;\n\n                        if (ctx->posted_threads) {\n                            ngx_http_lua_post_thread(r, ctx, ctx->cur_co_ctx);\n                            ctx->cur_co_ctx = NULL;\n                            return NGX_AGAIN;\n                        }\n\n                        /* no pending threads, so resume the thread\n                         * immediately */\n\n                        nrets = 0;\n                        continue;\n                    }\n\n                    /* being a user coroutine that has a parent */\n\n                    nrets = lua_gettop(ctx->cur_co_ctx->co);\n\n                    next_coctx = ctx->cur_co_ctx->parent_co_ctx;\n                    next_co = next_coctx->co;\n\n                    if (nrets) {\n                        dd(\"moving %d return values to next co\", nrets);\n                        lua_xmove(ctx->cur_co_ctx->co, next_co, nrets);\n#ifdef NGX_LUA_USE_ASSERT\n                        ctx->cur_co_ctx->co_top -= nrets;\n#endif\n                    }\n\n                    if (!ctx->cur_co_ctx->is_wrap) {\n                        /*\n                         * prepare return values for coroutine.resume\n                         * (true plus any retvals)\n                         */\n                        lua_pushboolean(next_co, 1);\n                        lua_insert(next_co, 1);\n                        nrets++;  /* add the true boolean value */\n                    }\n\n                    ctx->cur_co_ctx = next_coctx;\n\n                    break;\n                }\n\n                /* try resuming on the new coroutine again */\n                continue;\n\n            case 0:\n\n                ngx_http_lua_cleanup_pending_operation(ctx->cur_co_ctx);\n\n                ngx_http_lua_probe_coroutine_done(r, ctx->cur_co_ctx->co, 1);\n\n                ctx->cur_co_ctx->co_status = NGX_HTTP_LUA_CO_DEAD;\n\n                if (ctx->cur_co_ctx->zombie_child_threads) {\n                    ngx_http_lua_cleanup_zombie_child_uthreads(r, L, ctx,\n                                                               ctx->cur_co_ctx);\n                }\n\n                ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                               \"lua light thread ended normally\");\n\n                if (ngx_http_lua_is_entry_thread(ctx)) {\n\n                    lua_settop(L, 0);\n\n                    ngx_http_lua_del_thread(r, L, ctx, ctx->cur_co_ctx);\n\n                    dd(\"uthreads: %d\", (int) ctx->uthreads);\n\n                    if (ctx->uthreads) {\n\n                        ctx->cur_co_ctx = NULL;\n                        return NGX_AGAIN;\n                    }\n\n                    /* all user threads terminated already */\n                    goto done;\n                }\n\n                if (ctx->cur_co_ctx->is_uthread) {\n                    /* being a user thread */\n\n                    lua_settop(L, 0);\n\n                    parent_coctx = ctx->cur_co_ctx->parent_co_ctx;\n\n                    if (ngx_http_lua_coroutine_alive(parent_coctx)) {\n                        if (ctx->cur_co_ctx->waited_by_parent) {\n                            ngx_http_lua_probe_info(\"parent already waiting\");\n                            ctx->cur_co_ctx->waited_by_parent = 0;\n                            success = 1;\n                            goto user_co_done;\n                        }\n\n                        ngx_http_lua_probe_info(\"parent still alive\");\n\n                        if (ngx_http_lua_post_zombie_thread(r, parent_coctx,\n                                                            ctx->cur_co_ctx)\n                            != NGX_OK)\n                        {\n                            return NGX_ERROR;\n                        }\n\n                        lua_pushboolean(ctx->cur_co_ctx->co, 1);\n                        lua_insert(ctx->cur_co_ctx->co, 1);\n\n                        ctx->cur_co_ctx->co_status = NGX_HTTP_LUA_CO_ZOMBIE;\n                        ctx->cur_co_ctx = NULL;\n                        return NGX_AGAIN;\n                    }\n\n                    ngx_http_lua_del_thread(r, L, ctx, ctx->cur_co_ctx);\n                    ctx->uthreads--;\n\n                    if (ctx->uthreads == 0) {\n                        if (ngx_http_lua_entry_thread_alive(ctx)) {\n                            ctx->cur_co_ctx = NULL;\n                            return NGX_AGAIN;\n                        }\n\n                        /* all threads terminated already */\n                        goto done;\n                    }\n\n                    /* some other user threads still running */\n                    ctx->cur_co_ctx = NULL;\n                    return NGX_AGAIN;\n                }\n\n                /* being a user coroutine that has a parent */\n\n                success = 1;\n\nuser_co_done:\n\n                nrets = lua_gettop(ctx->cur_co_ctx->co);\n\n                next_coctx = ctx->cur_co_ctx->parent_co_ctx;\n\n                if (next_coctx == NULL) {\n                    /* being a light thread */\n                    goto no_parent;\n                }\n\n                next_co = next_coctx->co;\n\n                if (nrets) {\n                    lua_xmove(ctx->cur_co_ctx->co, next_co, nrets);\n                }\n\n                if (ctx->cur_co_ctx->is_uthread) {\n                    ngx_http_lua_del_thread(r, L, ctx, ctx->cur_co_ctx);\n                    ctx->uthreads--;\n                }\n\n                if (!ctx->cur_co_ctx->is_wrap) {\n                    /*\n                     * ended successfully, coroutine.resume returns true plus\n                     * any return values\n                     */\n                    lua_pushboolean(next_co, success);\n                    lua_insert(next_co, 1);\n                    nrets++;\n                }\n\n                ctx->cur_co_ctx = next_coctx;\n\n                ngx_http_lua_probe_info(\"set parent running\");\n\n                next_coctx->co_status = NGX_HTTP_LUA_CO_RUNNING;\n\n                ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                               \"lua coroutine: lua user thread ended normally\");\n\n                continue;\n\n            case LUA_ERRRUN:\n                err = \"runtime error\";\n                break;\n\n            case LUA_ERRSYNTAX:\n                err = \"syntax error\";\n                break;\n\n            case LUA_ERRMEM:\n                err = \"memory allocation error\";\n                ngx_quit = 1;\n                break;\n\n            case LUA_ERRERR:\n                err = \"error handler error\";\n                break;\n\n            default:\n                err = \"unknown error\";\n                break;\n            }\n\n            if (ctx->cur_co_ctx != orig_coctx) {\n                ctx->cur_co_ctx = orig_coctx;\n            }\n\n            ngx_http_lua_cleanup_pending_operation(ctx->cur_co_ctx);\n\n            ngx_http_lua_probe_coroutine_done(r, ctx->cur_co_ctx->co, 0);\n\n            ctx->cur_co_ctx->co_status = NGX_HTTP_LUA_CO_DEAD;\n\n            if (orig_coctx->is_uthread\n                || orig_coctx->is_wrap\n                || ngx_http_lua_is_entry_thread(ctx))\n            {\n                ngx_http_lua_thread_traceback(L, orig_coctx->co, orig_coctx);\n                trace = lua_tostring(L, -1);\n\n                if (lua_isstring(orig_coctx->co, -1)) {\n                    msg = lua_tostring(orig_coctx->co, -1);\n                    dd(\"user custom error msg: %s\", msg);\n\n                } else {\n                    msg = \"unknown reason\";\n                }\n            }\n\npropagate_error:\n\n            if (ctx->cur_co_ctx->is_uthread) {\n                ngx_http_lua_assert(err != NULL && msg != NULL\n                                    && trace != NULL);\n\n                ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                              \"lua user thread aborted: %s: %s\\n%s\",\n                              err, msg, trace);\n\n                lua_settop(L, 0);\n\n                parent_coctx = ctx->cur_co_ctx->parent_co_ctx;\n\n                if (ngx_http_lua_coroutine_alive(parent_coctx)) {\n                    if (ctx->cur_co_ctx->waited_by_parent) {\n                        ctx->cur_co_ctx->waited_by_parent = 0;\n                        success = 0;\n                        goto user_co_done;\n                    }\n\n                    if (ngx_http_lua_post_zombie_thread(r, parent_coctx,\n                                                        ctx->cur_co_ctx)\n                        != NGX_OK)\n                    {\n                        return NGX_ERROR;\n                    }\n\n                    lua_pushboolean(ctx->cur_co_ctx->co, 0);\n                    lua_insert(ctx->cur_co_ctx->co, 1);\n\n                    ctx->cur_co_ctx->co_status = NGX_HTTP_LUA_CO_ZOMBIE;\n                    ctx->cur_co_ctx = NULL;\n                    return NGX_AGAIN;\n                }\n\n                ngx_http_lua_del_thread(r, L, ctx, ctx->cur_co_ctx);\n                ctx->uthreads--;\n\n                if (ctx->uthreads == 0) {\n                    if (ngx_http_lua_entry_thread_alive(ctx)) {\n                        ctx->cur_co_ctx = NULL;\n                        return NGX_AGAIN;\n                    }\n\n                    /* all threads terminated already */\n                    goto done;\n                }\n\n                /* some other user threads still running */\n                ctx->cur_co_ctx = NULL;\n                return NGX_AGAIN;\n            }\n\n            if (ngx_http_lua_is_entry_thread(ctx)) {\n                ngx_http_lua_assert(err != NULL && msg != NULL\n                                    && trace != NULL);\n\n                ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                              \"lua entry thread aborted: %s: %s\\n%s\",\n                              err, msg, trace);\n\n                lua_settop(L, 0);\n\n                /* being the entry thread aborted */\n\n                if (r->filter_finalize) {\n                    ngx_http_set_ctx(r, ctx, ngx_http_lua_module);\n                }\n\n                ngx_http_lua_request_cleanup(ctx, 0);\n\n                dd(\"headers sent? %d\", r->header_sent || ctx->header_sent);\n\n                if (ctx->no_abort) {\n                    ctx->no_abort = 0;\n                    return NGX_ERROR;\n                }\n\n                return (r->header_sent || ctx->header_sent) ? NGX_ERROR :\n                       NGX_HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            /* being a user coroutine that has a parent */\n\n            next_coctx = ctx->cur_co_ctx->parent_co_ctx;\n            if (next_coctx == NULL) {\n                goto no_parent;\n            }\n\n            next_co = next_coctx->co;\n\n            ngx_http_lua_probe_info(\"set parent running\");\n\n            next_coctx->co_status = NGX_HTTP_LUA_CO_RUNNING;\n\n            ctx->cur_co_ctx = next_coctx;\n\n            if (orig_coctx->is_wrap) {\n                /*\n                 * coroutine.wrap propagates errors\n                 * to its parent coroutine\n                 */\n                next_coctx->propagate_error = 1;\n                continue;\n            }\n\n            /*\n             * ended with error, coroutine.resume returns false plus\n             * err msg\n             */\n            lua_pushboolean(next_co, 0);\n            lua_xmove(orig_coctx->co, next_co, 1);\n            nrets = 2;\n\n            /* try resuming on the new coroutine again */\n            continue;\n        }\n\n    } NGX_LUA_EXCEPTION_CATCH {\n        dd(\"nginx execution restored\");\n    }\n\n    return NGX_ERROR;\n\nno_parent:\n\n    lua_settop(L, 0);\n\n    ctx->cur_co_ctx->co_status = NGX_HTTP_LUA_CO_DEAD;\n\n    if (r->filter_finalize) {\n        ngx_http_set_ctx(r, ctx, ngx_http_lua_module);\n    }\n\n    ngx_http_lua_request_cleanup(ctx, 0);\n\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, \"lua handler aborted: \"\n                  \"user coroutine has no parent\");\n\n    return (r->header_sent || ctx->header_sent) ?\n                NGX_ERROR : NGX_HTTP_INTERNAL_SERVER_ERROR;\n\ndone:\n\n    if (ctx->entered_content_phase\n        && r->connection->fd != (ngx_socket_t) -1)\n    {\n        rc = ngx_http_lua_send_chain_link(r, ctx,\n                                          NULL /* last_buf */);\n\n        if (rc == NGX_ERROR || rc >= NGX_HTTP_SPECIAL_RESPONSE) {\n            return rc;\n        }\n    }\n\n    return NGX_OK;\n}", "path": "lua-nginx-module/src/ngx_http_lua_util.c", "commit_date": "2020-11-01 00:00:00", "repo_name": "openresty/lua-nginx-module", "stars": 11037, "license": "None", "language": "c", "size": 15364}
{"docstring": "/**\n * Wrapper of nginx log functionality. Take a log level param and varargs of\n * log message params.\n *\n * @param L Lua state pointer\n * @retval always 0 (don't return values to Lua)\n * */\n", "func_signal": "int\nngx_http_lua_ngx_log(lua_State *L)", "code": "{\n    ngx_log_t                   *log;\n    ngx_http_request_t          *r;\n    const char                  *msg;\n    int                          level;\n\n    r = ngx_http_lua_get_req(L);\n\n    if (r && r->connection && r->connection->log) {\n        log = r->connection->log;\n\n    } else {\n        log = ngx_cycle->log;\n    }\n\n    level = luaL_checkint(L, 1);\n    if (level < NGX_LOG_STDERR || level > NGX_LOG_DEBUG) {\n        msg = lua_pushfstring(L, \"bad log level: %d\", level);\n        return luaL_argerror(L, 1, msg);\n    }\n\n    /* remove log-level param from stack */\n    lua_remove(L, 1);\n\n    return log_wrapper(log, \"[lua] \", (ngx_uint_t) level, L);\n}", "path": "lua-nginx-module/src/ngx_http_lua_log.c", "commit_date": "2020-07-20 00:00:00", "repo_name": "openresty/lua-nginx-module", "stars": 11037, "license": "None", "language": "c", "size": 15364}
{"docstring": "/*\n * ngx_http_lua_lex: the \"ovec\" array should be allocated by the caller with at\n * least 2 elements.\n */\n", "func_signal": "int\nngx_http_lua_lex(const u_char *const s, size_t len, int *const ovec)", "code": "{\n    unsigned i = 0;\n    int matched_0 = -1;\n    int matched_1 = -1;\n    int matched_id = NO_MATCH;  /* (pending) matched regex ID */\n    int c;\n    int caps0_0 = -1;\n    int caps0_10 = -1;\n    int caps0_12 = -1;\n    int caps0_14 = -1;\n    int caps0_2 = -1;\n    int caps0_4 = -1;\n    int caps0_6 = -1;\n    int caps0_8 = -1;\n    int caps1_0 = -1;\n    int caps1_10 = -1;\n    int caps1_12 = -1;\n    int caps1_14 = -1;\n    int caps1_2 = -1;\n    int caps1_4 = -1;\n    int caps1_6 = -1;\n    int caps1_8 = -1;\n    int caps2_0 = -1;\n    int caps2_10 = -1;\n    int caps2_2 = -1;\n    int caps2_4 = -1;\n    int caps2_6 = -1;\n    int caps2_8 = -1;\n    int caps3_10 = -1;\n\n    {  /* DFA node {0} 0 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st0_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 34: {\n        /* transfer caps from row 0 to row 1 */\n        /* capture stores */\n        caps0_12 = i - 1;\n        goto st2;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 0 to row 1 */\n        /* capture stores */\n        caps0_14 = i - 1;\n        goto st3;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 0 to row 1 */\n        /* transfer caps from row 0 to row 2 */\n        /* capture stores */\n        caps0_6 = i - 1;\n        caps1_10 = i - 1;\n        goto st4;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 0 to row 1 */\n        /* capture stores */\n        caps0_4 = i - 1;\n        goto st5;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 0 to row 1 */\n        /* capture stores */\n        caps0_8 = i - 1;\n        goto st6;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 0 to row 1 */\n        /* capture stores */\n        caps0_0 = i - 1;\n        goto st7;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 0 to row 1 */\n        /* capture stores */\n        caps0_2 = i - 1;\n        goto st8;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c == 92)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    goto st1;\n    }  /* end state */\n\n    goto st0_error;\n\nst1: {  /* DFA node {1} 1 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st1_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 34: {\n        /* transfer caps from row 0 to row 1 */\n        /* capture stores */\n        caps0_12 = i - 1;\n        goto st2;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 0 to row 1 */\n        /* capture stores */\n        caps0_14 = i - 1;\n        goto st3;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 0 to row 1 */\n        /* transfer caps from row 0 to row 2 */\n        /* capture stores */\n        caps0_6 = i - 1;\n        caps1_10 = i - 1;\n        goto st4;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 0 to row 1 */\n        /* capture stores */\n        caps0_4 = i - 1;\n        goto st5;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 0 to row 1 */\n        /* capture stores */\n        caps0_8 = i - 1;\n        goto st6;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 0 to row 1 */\n        /* capture stores */\n        caps0_0 = i - 1;\n        goto st7;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 0 to row 1 */\n        /* capture stores */\n        caps0_2 = i - 1;\n        goto st8;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c == 92)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    goto st1;\n    }  /* end state */\n\n    goto st1_error;\n\nst2: {  /* DFA node {59,1} 2 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st2_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 1 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st10;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st11;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 1 to row 2 */\n        /* transfer caps from row 1 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st12;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st13;\n        break;\n        }\n    case 92: {\n        goto st14;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st15;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st16;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st17;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    goto st9;\n    }  /* end state */\n\n    goto st2_error;\n\nst3: {  /* DFA node {72,1} 3 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st3_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 1 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st19;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st20;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 1 to row 2 */\n        /* transfer caps from row 1 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st21;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st22;\n        break;\n        }\n    case 92: {\n        goto st23;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st24;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st25;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st26;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    goto st18;\n    }  /* end state */\n\n    goto st3_error;\n\nst4: {  /* DFA node {30,50,1} 4 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st4_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 34: {\n        /* transfer caps from row 2 to row 0 */\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps0_12 = i - 1;\n        goto st2;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 0 */\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps0_14 = i - 1;\n        goto st3;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 3 */\n        /* transfer caps from row 2 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st27;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 0 */\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps0_4 = i - 1;\n        goto st5;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 0 */\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps0_8 = i - 1;\n        goto st6;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 0 */\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps0_0 = i - 1;\n        goto st7;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 0 */\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps0_2 = i - 1;\n        goto st8;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c == 92)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 2 to row 0 */\n    goto st1;\n    }  /* end state */\n\n    goto st4_error;\n\nst5: {  /* DFA node {21,1} 5 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st5_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 34: {\n        /* transfer caps from row 1 to row 0 */\n        /* capture stores */\n        caps0_12 = i - 1;\n        goto st2;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 1 to row 0 */\n        /* capture stores */\n        caps0_14 = i - 1;\n        goto st3;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 1 to row 0 */\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps0_6 = i - 1;\n        caps1_10 = i - 1;\n        goto st4;\n        break;\n        }\n    case 61: {\n        goto st28;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st29;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 1 to row 0 */\n        /* capture stores */\n        caps0_8 = i - 1;\n        goto st6;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 1 to row 0 */\n        /* capture stores */\n        caps0_0 = i - 1;\n        goto st7;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 1 to row 0 */\n        /* capture stores */\n        caps0_2 = i - 1;\n        goto st8;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c == 92)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 1 to row 0 */\n    goto st1;\n    }  /* end state */\n\n    goto st5_error;\n\nst6: {  /* DFA node {41,1} 6 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st6_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 34: {\n        /* transfer caps from row 1 to row 0 */\n        /* capture stores */\n        caps0_12 = i - 1;\n        goto st2;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 1 to row 0 */\n        /* capture stores */\n        caps0_14 = i - 1;\n        goto st3;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 1 to row 0 */\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps0_6 = i - 1;\n        caps1_10 = i - 1;\n        goto st4;\n        break;\n        }\n    case 61: {\n        goto st30;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 1 to row 0 */\n        /* capture stores */\n        caps0_4 = i - 1;\n        goto st5;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st31;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 1 to row 0 */\n        /* capture stores */\n        caps0_0 = i - 1;\n        goto st7;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 1 to row 0 */\n        /* capture stores */\n        caps0_2 = i - 1;\n        goto st8;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c == 92)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 1 to row 0 */\n    goto st1;\n    }  /* end state */\n\n    goto st6_error;\n\nst7: {  /* DFA node {11,1} 7 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 0 to matched */\n    matched_0 = caps0_0;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 0;\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst8: {  /* DFA node {16,1} 8 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 0 to matched */\n    matched_0 = caps0_2;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 1;\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst9: {  /* DFA node {65,1} 9 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st9_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 1 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st10;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st11;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 1 to row 2 */\n        /* transfer caps from row 1 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st12;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st13;\n        break;\n        }\n    case 92: {\n        goto st14;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st15;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st16;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st17;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    goto st9;\n    }  /* end state */\n\n    goto st9_error;\n\nst10: {  /* DFA node {67,59,1} 10 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 0 to matched */\n    matched_0 = caps0_12;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 6;\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst11: {  /* DFA node {65,72,1} 11 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st11_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        goto st36;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        goto st37;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 3 */\n        /* transfer caps from row 2 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st38;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st39;\n        break;\n        }\n    case 92: {\n        goto st40;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st41;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st42;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st43;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    goto st35;\n    }  /* end state */\n\n    goto st11_error;\n\nst12: {  /* DFA node {65,30,50,1} 12 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st12_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 3 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st10;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st11;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 3 to row 4 */\n        /* transfer caps from row 3 to row 5 */\n        /* capture stores */\n        goto st44;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st13;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 3 to row 1 */\n        goto st14;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st15;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st16;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st17;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 3 to row 1 */\n    goto st9;\n    }  /* end state */\n\n    goto st12_error;\n\nst13: {  /* DFA node {65,21,1} 13 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st13_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st10;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st11;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 1 */\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st12;\n        break;\n        }\n    case 61: {\n        goto st45;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st46;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 2 to row 1 */\n        goto st14;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st15;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st16;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st17;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 2 to row 1 */\n    goto st9;\n    }  /* end state */\n\n    goto st13_error;\n\nst14: {  /* DFA node {62,1} 14 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st14_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 1 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st48;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st49;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 1 to row 2 */\n        /* transfer caps from row 1 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st50;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st51;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st52;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st53;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st54;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c == 92)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    goto st47;\n    }  /* end state */\n\n    goto st14_error;\n\nst15: {  /* DFA node {65,41,1} 15 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st15_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st10;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st11;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 1 */\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st12;\n        break;\n        }\n    case 61: {\n        goto st55;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st13;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 2 to row 1 */\n        goto st14;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st56;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st16;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st17;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 2 to row 1 */\n    goto st9;\n    }  /* end state */\n\n    goto st15_error;\n\nst16: {  /* DFA node {65,11,1} 16 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_0;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 0;\n    if (c != -1) {\n        if (c == 34) {\n            goto st58;\n        }\n        if (c == 92) {\n            goto st59;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st57;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst17: {  /* DFA node {65,16,1} 17 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_2;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 1;\n    if (c != -1) {\n        if (c == 34) {\n            goto st58;\n        }\n        if (c == 92) {\n            goto st59;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st57;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst18: {  /* DFA node {78,1} 18 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st18_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 1 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st19;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st20;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 1 to row 2 */\n        /* transfer caps from row 1 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st21;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st22;\n        break;\n        }\n    case 92: {\n        goto st23;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st24;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st25;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st26;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    goto st18;\n    }  /* end state */\n\n    goto st18_error;\n\nst19: {  /* DFA node {78,59,1} 19 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st19_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        goto st61;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        goto st62;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 3 */\n        /* transfer caps from row 2 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st63;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st64;\n        break;\n        }\n    case 92: {\n        goto st65;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st66;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st67;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st68;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    goto st60;\n    }  /* end state */\n\n    goto st19_error;\n\nst20: {  /* DFA node {80,72,1} 20 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 0 to matched */\n    matched_0 = caps0_14;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 7;\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst21: {  /* DFA node {78,30,50,1} 21 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st21_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 3 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st19;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st20;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 3 to row 4 */\n        /* transfer caps from row 3 to row 5 */\n        /* capture stores */\n        goto st70;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st22;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 3 to row 1 */\n        goto st23;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st24;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st25;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st26;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 3 to row 1 */\n    goto st18;\n    }  /* end state */\n\n    goto st21_error;\n\nst22: {  /* DFA node {78,21,1} 22 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st22_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st19;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st20;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 1 */\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st21;\n        break;\n        }\n    case 61: {\n        goto st71;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st72;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 2 to row 1 */\n        goto st23;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st24;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st25;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st26;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 2 to row 1 */\n    goto st18;\n    }  /* end state */\n\n    goto st22_error;\n\nst23: {  /* DFA node {75,1} 23 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st23_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 1 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st74;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st75;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 1 to row 2 */\n        /* transfer caps from row 1 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st76;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st77;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st78;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st79;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st80;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c == 92)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    goto st73;\n    }  /* end state */\n\n    goto st23_error;\n\nst24: {  /* DFA node {78,41,1} 24 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st24_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st19;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st20;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 1 */\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st21;\n        break;\n        }\n    case 61: {\n        goto st81;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st22;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 2 to row 1 */\n        goto st23;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st82;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st25;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st26;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 2 to row 1 */\n    goto st18;\n    }  /* end state */\n\n    goto st24_error;\n\nst25: {  /* DFA node {78,11,1} 25 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_0;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 0;\n    if (c != -1) {\n        if (c == 39) {\n            goto st84;\n        }\n        if (c == 92) {\n            goto st85;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st83;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst26: {  /* DFA node {78,16,1} 26 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_2;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 1;\n    if (c != -1) {\n        if (c == 39) {\n            goto st84;\n        }\n        if (c == 92) {\n            goto st85;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st83;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst27: {  /* DFA node {31,51,30,50,1} 27 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 91) {\n            goto st88;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 90)\n            || (c >= 92 && c <= 255))\n        {\n            /* transfer caps from row 1 to row 0 */\n            caps0_10 = caps1_10;\n            goto st87;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst28: {  /* DFA node {23,1} 28 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st28_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 34: {\n        /* transfer caps from row 1 to row 0 */\n        /* capture stores */\n        caps0_12 = i - 1;\n        goto st2;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 1 to row 0 */\n        /* capture stores */\n        caps0_14 = i - 1;\n        goto st3;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 1 to row 0 */\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps0_6 = i - 1;\n        caps1_10 = i - 1;\n        goto st4;\n        break;\n        }\n    case 61: {\n        goto st28;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st29;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 1 to row 0 */\n        /* capture stores */\n        caps0_8 = i - 1;\n        goto st6;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 1 to row 0 */\n        /* capture stores */\n        caps0_0 = i - 1;\n        goto st7;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 1 to row 0 */\n        /* capture stores */\n        caps0_2 = i - 1;\n        goto st8;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c == 92)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 1 to row 0 */\n    goto st1;\n    }  /* end state */\n\n    goto st28_error;\n\nst29: {  /* DFA node {25,21,1} 29 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 0 to matched */\n    matched_0 = caps0_4;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 2;\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst30: {  /* DFA node {43,1} 30 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st30_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 34: {\n        /* transfer caps from row 1 to row 0 */\n        /* capture stores */\n        caps0_12 = i - 1;\n        goto st2;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 1 to row 0 */\n        /* capture stores */\n        caps0_14 = i - 1;\n        goto st3;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 1 to row 0 */\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps0_6 = i - 1;\n        caps1_10 = i - 1;\n        goto st4;\n        break;\n        }\n    case 61: {\n        goto st30;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 1 to row 0 */\n        /* capture stores */\n        caps0_4 = i - 1;\n        goto st5;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st31;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 1 to row 0 */\n        /* capture stores */\n        caps0_0 = i - 1;\n        goto st7;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 1 to row 0 */\n        /* capture stores */\n        caps0_2 = i - 1;\n        goto st8;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c == 92)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 1 to row 0 */\n    goto st1;\n    }  /* end state */\n\n    goto st30_error;\n\nst31: {  /* DFA node {45,41,1} 31 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 0 to matched */\n    matched_0 = caps0_8;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 4;\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst35: {  /* DFA node {65,78,1} 35 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st35_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        goto st36;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        goto st37;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 3 */\n        /* transfer caps from row 2 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st38;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st39;\n        break;\n        }\n    case 92: {\n        goto st40;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st41;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st42;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st43;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    goto st35;\n    }  /* end state */\n\n    goto st35_error;\n\nst36: {  /* DFA node {67,78,59,1} 36 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 0 to matched */\n    matched_0 = caps0_12;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 6;\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst37: {  /* DFA node {65,80,72,1} 37 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_14;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 7;\n    if (c != -1) {\n        if (c == 34) {\n            goto st58;\n        }\n        if (c == 92) {\n            goto st59;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st57;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst38: {  /* DFA node {65,78,30,50,1} 38 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st38_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 4 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        goto st36;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        goto st37;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 4 to row 5 */\n        /* transfer caps from row 4 to row 6 */\n        /* capture stores */\n        goto st91;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st39;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 4 to row 2 */\n        goto st40;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st41;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st42;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st43;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 4 to row 2 */\n    goto st35;\n    }  /* end state */\n\n    goto st38_error;\n\nst39: {  /* DFA node {65,78,21,1} 39 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st39_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 3 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st36;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st37;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 3 to row 2 */\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st38;\n        break;\n        }\n    case 61: {\n        goto st92;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        goto st93;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 3 to row 2 */\n        goto st40;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st41;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st42;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st43;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 3 to row 2 */\n    goto st35;\n    }  /* end state */\n\n    goto st39_error;\n\nst40: {  /* DFA node {62,75,1} 40 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st40_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        goto st95;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        goto st96;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 3 */\n        /* transfer caps from row 2 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st97;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st98;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st99;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st100;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st101;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c == 92)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    goto st94;\n    }  /* end state */\n\n    goto st40_error;\n\nst41: {  /* DFA node {65,78,41,1} 41 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st41_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 3 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st36;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st37;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 3 to row 2 */\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st38;\n        break;\n        }\n    case 61: {\n        goto st102;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st39;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 3 to row 2 */\n        goto st40;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        goto st103;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st42;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st43;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 3 to row 2 */\n    goto st35;\n    }  /* end state */\n\n    goto st41_error;\n\nst42: {  /* DFA node {65,78,11,1} 42 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_0;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 0;\n    if (c != -1) {\n        if (c == 34) {\n            goto st105;\n        }\n        if (c == 39) {\n            goto st106;\n        }\n        if (c == 92) {\n            goto st107;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st104;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst43: {  /* DFA node {65,78,16,1} 43 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_2;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 1;\n    if (c != -1) {\n        if (c == 34) {\n            goto st105;\n        }\n        if (c == 39) {\n            goto st106;\n        }\n        if (c == 92) {\n            goto st107;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st104;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst44: {  /* DFA node {65,31,51,30,50,1} 44 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 34) {\n            /* transfer caps from row 2 to row 1 */\n            caps1_10 = caps2_10;\n            goto st109;\n        }\n        if (c == 91) {\n            goto st110;\n        }\n        if (c == 92) {\n            /* transfer caps from row 2 to row 1 */\n            caps1_10 = caps2_10;\n            goto st111;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 90)\n            || (c >= 93 && c <= 255))\n        {\n            /* transfer caps from row 2 to row 1 */\n            caps1_10 = caps2_10;\n            goto st108;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst45: {  /* DFA node {65,23,1} 45 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st45_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st10;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st11;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 1 */\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st12;\n        break;\n        }\n    case 61: {\n        goto st45;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st46;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 2 to row 1 */\n        goto st14;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st15;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st16;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st17;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 2 to row 1 */\n    goto st9;\n    }  /* end state */\n\n    goto st45_error;\n\nst46: {  /* DFA node {65,25,21,1} 46 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_4;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 2;\n    if (c != -1) {\n        if (c == 34) {\n            goto st58;\n        }\n        if (c == 92) {\n            goto st59;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st57;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst47: {  /* DFA node {63,1} 47 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st47_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 1 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st10;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st11;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 1 to row 2 */\n        /* transfer caps from row 1 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st12;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st13;\n        break;\n        }\n    case 92: {\n        goto st14;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st15;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st16;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st17;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    goto st9;\n    }  /* end state */\n\n    goto st47_error;\n\nst48: {  /* DFA node {63,59,1} 48 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st48_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st10;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st11;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 1 */\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st12;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st13;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 2 to row 1 */\n        goto st14;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st15;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st16;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st17;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 2 to row 1 */\n    goto st9;\n    }  /* end state */\n\n    goto st48_error;\n\nst49: {  /* DFA node {63,72,1} 49 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st49_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        goto st36;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        goto st37;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 3 */\n        /* transfer caps from row 2 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st38;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st39;\n        break;\n        }\n    case 92: {\n        goto st40;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st41;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st42;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st43;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    goto st35;\n    }  /* end state */\n\n    goto st49_error;\n\nst50: {  /* DFA node {63,30,50,1} 50 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st50_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 3 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st10;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st11;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 3 to row 4 */\n        /* transfer caps from row 3 to row 5 */\n        /* capture stores */\n        goto st44;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st13;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 3 to row 1 */\n        goto st14;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st15;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st16;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st17;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 3 to row 1 */\n    goto st9;\n    }  /* end state */\n\n    goto st50_error;\n\nst51: {  /* DFA node {63,21,1} 51 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st51_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st10;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st11;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 1 */\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st12;\n        break;\n        }\n    case 61: {\n        goto st45;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st46;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 2 to row 1 */\n        goto st14;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st15;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st16;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st17;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 2 to row 1 */\n    goto st9;\n    }  /* end state */\n\n    goto st51_error;\n\nst52: {  /* DFA node {63,41,1} 52 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st52_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st10;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st11;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 1 */\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st12;\n        break;\n        }\n    case 61: {\n        goto st55;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st13;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 2 to row 1 */\n        goto st14;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st56;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st16;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st17;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 2 to row 1 */\n    goto st9;\n    }  /* end state */\n\n    goto st52_error;\n\nst53: {  /* DFA node {63,11,1} 53 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_0;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 0;\n    if (c != -1) {\n        if (c == 34) {\n            goto st58;\n        }\n        if (c == 92) {\n            goto st59;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st57;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst54: {  /* DFA node {63,16,1} 54 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_2;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 1;\n    if (c != -1) {\n        if (c == 34) {\n            goto st58;\n        }\n        if (c == 92) {\n            goto st59;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st57;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst55: {  /* DFA node {65,43,1} 55 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st55_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st10;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st11;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 1 */\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st12;\n        break;\n        }\n    case 61: {\n        goto st55;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st13;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 2 to row 1 */\n        goto st14;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st56;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st16;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st17;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 2 to row 1 */\n    goto st9;\n    }  /* end state */\n\n    goto st55_error;\n\nst56: {  /* DFA node {65,45,41,1} 56 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_8;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 4;\n    if (c != -1) {\n        if (c == 34) {\n            goto st58;\n        }\n        if (c == 92) {\n            goto st59;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st57;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst57: {  /* DFA node {65} 57 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st57_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 34: {\n        goto st58;\n        break;\n        }\n    case 92: {\n        goto st59;\n        break;\n        }\n    default:\n        break;\n    }\n    if ((c >= 0 && c <= 9)\n        || (c >= 11 && c <= 33)\n        || (c >= 35 && c <= 91)\n        || (c >= 93 && c <= 255))\n    {\n        goto st57;\n    }\n    }  /* end state */\n\n    goto st57_error;\n\nst58: {  /* DFA node {67} 58 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 0 to matched */\n    matched_0 = caps0_12;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 6;\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst59: {  /* DFA node {62} 59 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st59_error;\n    }\n\n    c = s[i];\n    i++;\n    if ((c >= 0 && c <= 9) || (c >= 11 && c <= 255)) {\n        goto st112;\n    }\n    }  /* end state */\n\n    goto st59_error;\n\nst60: {  /* DFA node {78,65,1} 60 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st60_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        goto st61;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        goto st62;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 3 */\n        /* transfer caps from row 2 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st63;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st64;\n        break;\n        }\n    case 92: {\n        goto st65;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st66;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st67;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st68;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    goto st60;\n    }  /* end state */\n\n    goto st60_error;\n\nst61: {  /* DFA node {78,67,59,1} 61 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_12;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 6;\n    if (c != -1) {\n        if (c == 39) {\n            goto st84;\n        }\n        if (c == 92) {\n            goto st85;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st83;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst62: {  /* DFA node {80,65,72,1} 62 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 0 to matched */\n    matched_0 = caps0_14;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 7;\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst63: {  /* DFA node {78,65,30,50,1} 63 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st63_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 4 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        goto st61;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        goto st62;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 4 to row 5 */\n        /* transfer caps from row 4 to row 6 */\n        /* capture stores */\n        goto st113;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st64;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 4 to row 2 */\n        goto st65;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st66;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st67;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st68;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 4 to row 2 */\n    goto st60;\n    }  /* end state */\n\n    goto st63_error;\n\nst64: {  /* DFA node {78,65,21,1} 64 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st64_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 3 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st61;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st62;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 3 to row 2 */\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st63;\n        break;\n        }\n    case 61: {\n        goto st114;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        goto st115;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 3 to row 2 */\n        goto st65;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st66;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st67;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st68;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 3 to row 2 */\n    goto st60;\n    }  /* end state */\n\n    goto st64_error;\n\nst65: {  /* DFA node {75,62,1} 65 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st65_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        goto st117;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        goto st118;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 3 */\n        /* transfer caps from row 2 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st119;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st120;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st121;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st122;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st123;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c == 92)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    goto st116;\n    }  /* end state */\n\n    goto st65_error;\n\nst66: {  /* DFA node {78,65,41,1} 66 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st66_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 3 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st61;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st62;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 3 to row 2 */\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st63;\n        break;\n        }\n    case 61: {\n        goto st124;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st64;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 3 to row 2 */\n        goto st65;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        goto st125;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st67;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st68;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 3 to row 2 */\n    goto st60;\n    }  /* end state */\n\n    goto st66_error;\n\nst67: {  /* DFA node {78,65,11,1} 67 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_0;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 0;\n    if (c != -1) {\n        if (c == 34) {\n            goto st127;\n        }\n        if (c == 39) {\n            goto st128;\n        }\n        if (c == 92) {\n            goto st129;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st126;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst68: {  /* DFA node {78,65,16,1} 68 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_2;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 1;\n    if (c != -1) {\n        if (c == 34) {\n            goto st127;\n        }\n        if (c == 39) {\n            goto st128;\n        }\n        if (c == 92) {\n            goto st129;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st126;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst70: {  /* DFA node {78,31,51,30,50,1} 70 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 39) {\n            /* transfer caps from row 2 to row 1 */\n            caps1_10 = caps2_10;\n            goto st131;\n        }\n        if (c == 91) {\n            goto st132;\n        }\n        if (c == 92) {\n            /* transfer caps from row 2 to row 1 */\n            caps1_10 = caps2_10;\n            goto st133;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 38)\n            || (c >= 40 && c <= 90)\n            || (c >= 93 && c <= 255))\n        {\n            /* transfer caps from row 2 to row 1 */\n            caps1_10 = caps2_10;\n            goto st130;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst71: {  /* DFA node {78,23,1} 71 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st71_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st19;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st20;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 1 */\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st21;\n        break;\n        }\n    case 61: {\n        goto st71;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st72;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 2 to row 1 */\n        goto st23;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st24;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st25;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st26;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 2 to row 1 */\n    goto st18;\n    }  /* end state */\n\n    goto st71_error;\n\nst72: {  /* DFA node {78,25,21,1} 72 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_4;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 2;\n    if (c != -1) {\n        if (c == 39) {\n            goto st84;\n        }\n        if (c == 92) {\n            goto st85;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st83;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst73: {  /* DFA node {76,1} 73 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st73_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 1 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st19;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st20;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 1 to row 2 */\n        /* transfer caps from row 1 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st21;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st22;\n        break;\n        }\n    case 92: {\n        goto st23;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st24;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st25;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 1 to row 2 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st26;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    goto st18;\n    }  /* end state */\n\n    goto st73_error;\n\nst74: {  /* DFA node {76,59,1} 74 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st74_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        goto st61;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        goto st62;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 3 */\n        /* transfer caps from row 2 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st63;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st64;\n        break;\n        }\n    case 92: {\n        goto st65;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st66;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st67;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st68;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    goto st60;\n    }  /* end state */\n\n    goto st74_error;\n\nst75: {  /* DFA node {76,72,1} 75 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st75_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st19;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st20;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 1 */\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st21;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st22;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 2 to row 1 */\n        goto st23;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st24;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st25;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st26;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 2 to row 1 */\n    goto st18;\n    }  /* end state */\n\n    goto st75_error;\n\nst76: {  /* DFA node {76,30,50,1} 76 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st76_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 3 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st19;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st20;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 3 to row 4 */\n        /* transfer caps from row 3 to row 5 */\n        /* capture stores */\n        goto st70;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st22;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 3 to row 1 */\n        goto st23;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st24;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st25;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 3 to row 1 */\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st26;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 3 to row 1 */\n    goto st18;\n    }  /* end state */\n\n    goto st76_error;\n\nst77: {  /* DFA node {76,21,1} 77 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st77_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st19;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st20;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 1 */\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st21;\n        break;\n        }\n    case 61: {\n        goto st71;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st72;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 2 to row 1 */\n        goto st23;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_8 = i - 1;\n        goto st24;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st25;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st26;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 2 to row 1 */\n    goto st18;\n    }  /* end state */\n\n    goto st77_error;\n\nst78: {  /* DFA node {76,41,1} 78 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st78_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st19;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st20;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 1 */\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st21;\n        break;\n        }\n    case 61: {\n        goto st81;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st22;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 2 to row 1 */\n        goto st23;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st82;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st25;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st26;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 2 to row 1 */\n    goto st18;\n    }  /* end state */\n\n    goto st78_error;\n\nst79: {  /* DFA node {76,11,1} 79 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_0;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 0;\n    if (c != -1) {\n        if (c == 39) {\n            goto st84;\n        }\n        if (c == 92) {\n            goto st85;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st83;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst80: {  /* DFA node {76,16,1} 80 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_2;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 1;\n    if (c != -1) {\n        if (c == 39) {\n            goto st84;\n        }\n        if (c == 92) {\n            goto st85;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st83;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst81: {  /* DFA node {78,43,1} 81 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st81_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_12 = i - 1;\n        goto st19;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_14 = i - 1;\n        goto st20;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 1 */\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps1_6 = i - 1;\n        caps2_10 = i - 1;\n        goto st21;\n        break;\n        }\n    case 61: {\n        goto st81;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_4 = i - 1;\n        goto st22;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 2 to row 1 */\n        goto st23;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st82;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_0 = i - 1;\n        goto st25;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 1 */\n        /* capture stores */\n        caps1_2 = i - 1;\n        goto st26;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 2 to row 1 */\n    goto st18;\n    }  /* end state */\n\n    goto st81_error;\n\nst82: {  /* DFA node {78,45,41,1} 82 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_8;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 4;\n    if (c != -1) {\n        if (c == 39) {\n            goto st84;\n        }\n        if (c == 92) {\n            goto st85;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st83;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst83: {  /* DFA node {78} 83 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st83_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 39: {\n        goto st84;\n        break;\n        }\n    case 92: {\n        goto st85;\n        break;\n        }\n    default:\n        break;\n    }\n    if ((c >= 0 && c <= 9)\n        || (c >= 11 && c <= 38)\n        || (c >= 40 && c <= 91)\n        || (c >= 93 && c <= 255))\n    {\n        goto st83;\n    }\n    }  /* end state */\n\n    goto st83_error;\n\nst84: {  /* DFA node {80} 84 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 0 to matched */\n    matched_0 = caps0_14;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 7;\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst85: {  /* DFA node {75} 85 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st85_error;\n    }\n\n    c = s[i];\n    i++;\n    if ((c >= 0 && c <= 9) || (c >= 11 && c <= 255)) {\n        goto st134;\n    }\n    }  /* end state */\n\n    goto st85_error;\n\nst87: {  /* DFA node {53} 87 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 0 to matched */\n    matched_0 = caps0_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if ((c >= 0 && c <= 9) || (c >= 11 && c <= 255)) {\n            goto st87;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst88: {  /* DFA node {32,53} 88 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 61) {\n            goto st135;\n        }\n        if (c == 91) {\n            goto st136;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 60)\n            || (c >= 62 && c <= 90)\n            || (c >= 92 && c <= 255))\n        {\n            /* transfer caps from row 1 to row 0 */\n            caps0_10 = caps1_10;\n            goto st87;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst91: {  /* DFA node {65,78,31,51,30,50,1} 91 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 3 to matched */\n    matched_0 = caps3_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 34) {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st138;\n        }\n        if (c == 39) {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st139;\n        }\n        if (c == 91) {\n            goto st140;\n        }\n        if (c == 92) {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st141;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 90)\n            || (c >= 93 && c <= 255))\n        {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st137;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst92: {  /* DFA node {65,78,23,1} 92 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st92_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 3 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st36;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st37;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 3 to row 2 */\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st38;\n        break;\n        }\n    case 61: {\n        goto st92;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        goto st93;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 3 to row 2 */\n        goto st40;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st41;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st42;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st43;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 3 to row 2 */\n    goto st35;\n    }  /* end state */\n\n    goto st92_error;\n\nst93: {  /* DFA node {65,78,25,21,1} 93 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_4;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 2;\n    if (c != -1) {\n        if (c == 34) {\n            goto st105;\n        }\n        if (c == 39) {\n            goto st106;\n        }\n        if (c == 92) {\n            goto st107;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st104;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst94: {  /* DFA node {63,76,1} 94 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st94_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        goto st36;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        goto st37;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 3 */\n        /* transfer caps from row 2 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st38;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st39;\n        break;\n        }\n    case 92: {\n        goto st40;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st41;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st42;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st43;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    goto st35;\n    }  /* end state */\n\n    goto st94_error;\n\nst95: {  /* DFA node {63,76,59,1} 95 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st95_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 3 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st36;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st37;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 3 to row 2 */\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st38;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st39;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 3 to row 2 */\n        goto st40;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st41;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st42;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st43;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 3 to row 2 */\n    goto st35;\n    }  /* end state */\n\n    goto st95_error;\n\nst96: {  /* DFA node {63,76,72,1} 96 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st96_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 3 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st36;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st37;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 3 to row 2 */\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st38;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st39;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 3 to row 2 */\n        goto st40;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st41;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st42;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st43;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 3 to row 2 */\n    goto st35;\n    }  /* end state */\n\n    goto st96_error;\n\nst97: {  /* DFA node {63,76,30,50,1} 97 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st97_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 4 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        goto st36;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        goto st37;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 4 to row 5 */\n        /* transfer caps from row 4 to row 6 */\n        /* capture stores */\n        goto st91;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st39;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 4 to row 2 */\n        goto st40;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st41;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st42;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st43;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 4 to row 2 */\n    goto st35;\n    }  /* end state */\n\n    goto st97_error;\n\nst98: {  /* DFA node {63,76,21,1} 98 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st98_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 3 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st36;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st37;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 3 to row 2 */\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st38;\n        break;\n        }\n    case 61: {\n        goto st92;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        goto st93;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 3 to row 2 */\n        goto st40;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st41;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st42;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st43;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 3 to row 2 */\n    goto st35;\n    }  /* end state */\n\n    goto st98_error;\n\nst99: {  /* DFA node {63,76,41,1} 99 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st99_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 3 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st36;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st37;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 3 to row 2 */\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st38;\n        break;\n        }\n    case 61: {\n        goto st102;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st39;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 3 to row 2 */\n        goto st40;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        goto st103;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st42;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st43;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 3 to row 2 */\n    goto st35;\n    }  /* end state */\n\n    goto st99_error;\n\nst100: {  /* DFA node {63,76,11,1} 100 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_0;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 0;\n    if (c != -1) {\n        if (c == 34) {\n            goto st105;\n        }\n        if (c == 39) {\n            goto st106;\n        }\n        if (c == 92) {\n            goto st107;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st104;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst101: {  /* DFA node {63,76,16,1} 101 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_2;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 1;\n    if (c != -1) {\n        if (c == 34) {\n            goto st105;\n        }\n        if (c == 39) {\n            goto st106;\n        }\n        if (c == 92) {\n            goto st107;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st104;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst102: {  /* DFA node {65,78,43,1} 102 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st102_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 3 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st36;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st37;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 3 to row 2 */\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st38;\n        break;\n        }\n    case 61: {\n        goto st102;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st39;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 3 to row 2 */\n        goto st40;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        goto st103;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st42;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st43;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 3 to row 2 */\n    goto st35;\n    }  /* end state */\n\n    goto st102_error;\n\nst103: {  /* DFA node {65,78,45,41,1} 103 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_8;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 4;\n    if (c != -1) {\n        if (c == 34) {\n            goto st105;\n        }\n        if (c == 39) {\n            goto st106;\n        }\n        if (c == 92) {\n            goto st107;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st104;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst104: {  /* DFA node {65,78} 104 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st104_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 34: {\n        goto st105;\n        break;\n        }\n    case 39: {\n        goto st106;\n        break;\n        }\n    case 92: {\n        goto st107;\n        break;\n        }\n    default:\n        break;\n    }\n    if ((c >= 0 && c <= 9)\n        || (c >= 11 && c <= 33)\n        || (c >= 35 && c <= 38)\n        || (c >= 40 && c <= 91)\n        || (c >= 93 && c <= 255))\n    {\n        goto st104;\n    }\n    }  /* end state */\n\n    goto st104_error;\n\nst105: {  /* DFA node {67,78} 105 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 0 to matched */\n    matched_0 = caps0_12;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 6;\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst106: {  /* DFA node {65,80} 106 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_14;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 7;\n    if (c != -1) {\n        if (c == 34) {\n            goto st58;\n        }\n        if (c == 92) {\n            goto st59;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st57;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst107: {  /* DFA node {62,75} 107 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st107_error;\n    }\n\n    c = s[i];\n    i++;\n    if ((c >= 0 && c <= 9) || (c >= 11 && c <= 255)) {\n        goto st142;\n    }\n    }  /* end state */\n\n    goto st107_error;\n\nst108: {  /* DFA node {65,53} 108 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 34) {\n            goto st109;\n        }\n        if (c == 92) {\n            goto st111;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st108;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst109: {  /* DFA node {67,53} 109 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 0 to matched */\n    matched_0 = caps0_12;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 6;\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst110: {  /* DFA node {65,32,53} 110 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 34) {\n            /* transfer caps from row 2 to row 1 */\n            caps1_10 = caps2_10;\n            goto st109;\n        }\n        if (c == 61) {\n            goto st143;\n        }\n        if (c == 91) {\n            goto st144;\n        }\n        if (c == 92) {\n            /* transfer caps from row 2 to row 1 */\n            caps1_10 = caps2_10;\n            goto st111;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 60)\n            || (c >= 62 && c <= 90)\n            || (c >= 93 && c <= 255))\n        {\n            /* transfer caps from row 2 to row 1 */\n            caps1_10 = caps2_10;\n            goto st108;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst111: {  /* DFA node {62,53} 111 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if ((c >= 0 && c <= 9) || (c >= 11 && c <= 255)) {\n            goto st145;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst112: {  /* DFA node {63} 112 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st112_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 34: {\n        goto st58;\n        break;\n        }\n    case 92: {\n        goto st59;\n        break;\n        }\n    default:\n        break;\n    }\n    if ((c >= 0 && c <= 9)\n        || (c >= 11 && c <= 33)\n        || (c >= 35 && c <= 91)\n        || (c >= 93 && c <= 255))\n    {\n        goto st57;\n    }\n    }  /* end state */\n\n    goto st112_error;\n\nst113: {  /* DFA node {78,65,31,51,30,50,1} 113 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 3 to matched */\n    matched_0 = caps3_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 34) {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st147;\n        }\n        if (c == 39) {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st148;\n        }\n        if (c == 91) {\n            goto st149;\n        }\n        if (c == 92) {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st150;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 90)\n            || (c >= 93 && c <= 255))\n        {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st146;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst114: {  /* DFA node {78,65,23,1} 114 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st114_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 3 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st61;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st62;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 3 to row 2 */\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st63;\n        break;\n        }\n    case 61: {\n        goto st114;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        goto st115;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 3 to row 2 */\n        goto st65;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st66;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st67;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st68;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 3 to row 2 */\n    goto st60;\n    }  /* end state */\n\n    goto st114_error;\n\nst115: {  /* DFA node {78,65,25,21,1} 115 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_4;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 2;\n    if (c != -1) {\n        if (c == 34) {\n            goto st127;\n        }\n        if (c == 39) {\n            goto st128;\n        }\n        if (c == 92) {\n            goto st129;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st126;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst116: {  /* DFA node {76,63,1} 116 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st116_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 2 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        goto st61;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        goto st62;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 2 to row 3 */\n        /* transfer caps from row 2 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st63;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st64;\n        break;\n        }\n    case 92: {\n        goto st65;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st66;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st67;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 2 to row 3 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st68;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    goto st60;\n    }  /* end state */\n\n    goto st116_error;\n\nst117: {  /* DFA node {76,63,59,1} 117 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st117_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 3 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st61;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st62;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 3 to row 2 */\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st63;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st64;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 3 to row 2 */\n        goto st65;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st66;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st67;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st68;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 3 to row 2 */\n    goto st60;\n    }  /* end state */\n\n    goto st117_error;\n\nst118: {  /* DFA node {76,63,72,1} 118 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st118_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 3 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st61;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st62;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 3 to row 2 */\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st63;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st64;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 3 to row 2 */\n        goto st65;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st66;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st67;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st68;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 3 to row 2 */\n    goto st60;\n    }  /* end state */\n\n    goto st118_error;\n\nst119: {  /* DFA node {76,63,30,50,1} 119 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st119_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 4 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        goto st61;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        goto st62;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 4 to row 5 */\n        /* transfer caps from row 4 to row 6 */\n        /* capture stores */\n        goto st113;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st64;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 4 to row 2 */\n        goto st65;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st66;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st67;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 4 to row 2 */\n        /* transfer caps from row 4 to row 3 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st68;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 4 to row 2 */\n    goto st60;\n    }  /* end state */\n\n    goto st119_error;\n\nst120: {  /* DFA node {76,63,21,1} 120 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st120_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 3 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st61;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st62;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 3 to row 2 */\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st63;\n        break;\n        }\n    case 61: {\n        goto st114;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        goto st115;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 3 to row 2 */\n        goto st65;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_8 = i - 1;\n        goto st66;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st67;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st68;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 3 to row 2 */\n    goto st60;\n    }  /* end state */\n\n    goto st120_error;\n\nst121: {  /* DFA node {76,63,41,1} 121 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st121_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 3 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st61;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st62;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 3 to row 2 */\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st63;\n        break;\n        }\n    case 61: {\n        goto st124;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st64;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 3 to row 2 */\n        goto st65;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        goto st125;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st67;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st68;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 3 to row 2 */\n    goto st60;\n    }  /* end state */\n\n    goto st121_error;\n\nst122: {  /* DFA node {76,63,11,1} 122 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_0;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 0;\n    if (c != -1) {\n        if (c == 34) {\n            goto st127;\n        }\n        if (c == 39) {\n            goto st128;\n        }\n        if (c == 92) {\n            goto st129;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st126;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst123: {  /* DFA node {76,63,16,1} 123 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_2;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 1;\n    if (c != -1) {\n        if (c == 34) {\n            goto st127;\n        }\n        if (c == 39) {\n            goto st128;\n        }\n        if (c == 92) {\n            goto st129;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st126;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst124: {  /* DFA node {78,65,43,1} 124 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st124_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 10: {\n        /* transfer caps from row 3 to row 0 */\n        goto st1;\n        break;\n        }\n    case 34: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st61;\n        break;\n        }\n    case 39: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        goto st62;\n        break;\n        }\n    case 45: {\n        /* transfer caps from row 3 to row 2 */\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        caps2_6 = i - 1;\n        caps3_10 = i - 1;\n        goto st63;\n        break;\n        }\n    case 61: {\n        goto st124;\n        break;\n        }\n    case 91: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_4 = i - 1;\n        goto st64;\n        break;\n        }\n    case 92: {\n        /* transfer caps from row 3 to row 2 */\n        goto st65;\n        break;\n        }\n    case 93: {\n        /* transfer caps from row 3 to row 4 */\n        /* capture stores */\n        goto st125;\n        break;\n        }\n    case 123: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_0 = i - 1;\n        goto st67;\n        break;\n        }\n    case 125: {\n        /* transfer caps from row 3 to row 2 */\n        /* capture stores */\n        caps2_2 = i - 1;\n        goto st68;\n        break;\n        }\n    default:\n        break;\n    }\n    /* (c >= 0 && c <= 9)\n     * || (c >= 11 && c <= 33)\n     * || (c >= 35 && c <= 38)\n     * || (c >= 40 && c <= 44)\n     * || (c >= 46 && c <= 60)\n     * || (c >= 62 && c <= 90)\n     * || (c >= 94 && c <= 122)\n     * || (c == 124)\n     * || (c >= 126 && c <= 255)\n     */\n    /* transfer caps from row 3 to row 2 */\n    goto st60;\n    }  /* end state */\n\n    goto st124_error;\n\nst125: {  /* DFA node {78,65,45,41,1} 125 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_8;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 4;\n    if (c != -1) {\n        if (c == 34) {\n            goto st127;\n        }\n        if (c == 39) {\n            goto st128;\n        }\n        if (c == 92) {\n            goto st129;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st126;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst126: {  /* DFA node {78,65} 126 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st126_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 34: {\n        goto st127;\n        break;\n        }\n    case 39: {\n        goto st128;\n        break;\n        }\n    case 92: {\n        goto st129;\n        break;\n        }\n    default:\n        break;\n    }\n    if ((c >= 0 && c <= 9)\n        || (c >= 11 && c <= 33)\n        || (c >= 35 && c <= 38)\n        || (c >= 40 && c <= 91)\n        || (c >= 93 && c <= 255))\n    {\n        goto st126;\n    }\n    }  /* end state */\n\n    goto st126_error;\n\nst127: {  /* DFA node {78,67} 127 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_12;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 6;\n    if (c != -1) {\n        if (c == 39) {\n            goto st84;\n        }\n        if (c == 92) {\n            goto st85;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st83;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst128: {  /* DFA node {80,65} 128 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 0 to matched */\n    matched_0 = caps0_14;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 7;\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst129: {  /* DFA node {75,62} 129 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st129_error;\n    }\n\n    c = s[i];\n    i++;\n    if ((c >= 0 && c <= 9) || (c >= 11 && c <= 255)) {\n        goto st151;\n    }\n    }  /* end state */\n\n    goto st129_error;\n\nst130: {  /* DFA node {78,53} 130 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 39) {\n            goto st131;\n        }\n        if (c == 92) {\n            goto st133;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st130;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst131: {  /* DFA node {80,53} 131 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 0 to matched */\n    matched_0 = caps0_14;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 7;\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst132: {  /* DFA node {78,32,53} 132 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 39) {\n            /* transfer caps from row 2 to row 1 */\n            caps1_10 = caps2_10;\n            goto st131;\n        }\n        if (c == 61) {\n            goto st152;\n        }\n        if (c == 91) {\n            goto st153;\n        }\n        if (c == 92) {\n            /* transfer caps from row 2 to row 1 */\n            caps1_10 = caps2_10;\n            goto st133;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 38)\n            || (c >= 40 && c <= 60)\n            || (c >= 62 && c <= 90)\n            || (c >= 93 && c <= 255))\n        {\n            /* transfer caps from row 2 to row 1 */\n            caps1_10 = caps2_10;\n            goto st130;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst133: {  /* DFA node {75,53} 133 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if ((c >= 0 && c <= 9) || (c >= 11 && c <= 255)) {\n            goto st154;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst134: {  /* DFA node {76} 134 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st134_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 39: {\n        goto st84;\n        break;\n        }\n    case 92: {\n        goto st85;\n        break;\n        }\n    default:\n        break;\n    }\n    if ((c >= 0 && c <= 9)\n        || (c >= 11 && c <= 38)\n        || (c >= 40 && c <= 91)\n        || (c >= 93 && c <= 255))\n    {\n        goto st83;\n    }\n    }  /* end state */\n\n    goto st134_error;\n\nst135: {  /* DFA node {34,53} 135 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 61) {\n            goto st135;\n        }\n        if (c == 91) {\n            goto st136;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 60)\n            || (c >= 62 && c <= 90)\n            || (c >= 92 && c <= 255))\n        {\n            /* transfer caps from row 1 to row 0 */\n            caps0_10 = caps1_10;\n            goto st87;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst136: {  /* DFA node {36,53} 136 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 0 to matched */\n    matched_0 = caps0_6;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 3;\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst137: {  /* DFA node {65,78,53} 137 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 34) {\n            goto st138;\n        }\n        if (c == 39) {\n            goto st139;\n        }\n        if (c == 92) {\n            goto st141;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st137;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst138: {  /* DFA node {67,78,53} 138 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 0 to matched */\n    matched_0 = caps0_12;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 6;\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst139: {  /* DFA node {65,80,53} 139 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_14;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 7;\n    if (c != -1) {\n        if (c == 34) {\n            goto st58;\n        }\n        if (c == 92) {\n            goto st59;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st57;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst140: {  /* DFA node {65,78,32,53} 140 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 3 to matched */\n    matched_0 = caps3_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 34) {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st138;\n        }\n        if (c == 39) {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st139;\n        }\n        if (c == 61) {\n            goto st156;\n        }\n        if (c == 91) {\n            goto st157;\n        }\n        if (c == 92) {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st141;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 60)\n            || (c >= 62 && c <= 90)\n            || (c >= 93 && c <= 255))\n        {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st137;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst141: {  /* DFA node {62,75,53} 141 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if ((c >= 0 && c <= 9) || (c >= 11 && c <= 255)) {\n            goto st158;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst142: {  /* DFA node {63,76} 142 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st142_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 34: {\n        goto st105;\n        break;\n        }\n    case 39: {\n        goto st106;\n        break;\n        }\n    case 92: {\n        goto st107;\n        break;\n        }\n    default:\n        break;\n    }\n    if ((c >= 0 && c <= 9)\n        || (c >= 11 && c <= 33)\n        || (c >= 35 && c <= 38)\n        || (c >= 40 && c <= 91)\n        || (c >= 93 && c <= 255))\n    {\n        goto st104;\n    }\n    }  /* end state */\n\n    goto st142_error;\n\nst143: {  /* DFA node {65,34,53} 143 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 34) {\n            /* transfer caps from row 2 to row 1 */\n            caps1_10 = caps2_10;\n            goto st109;\n        }\n        if (c == 61) {\n            goto st143;\n        }\n        if (c == 91) {\n            goto st144;\n        }\n        if (c == 92) {\n            /* transfer caps from row 2 to row 1 */\n            caps1_10 = caps2_10;\n            goto st111;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 60)\n            || (c >= 62 && c <= 90)\n            || (c >= 93 && c <= 255))\n        {\n            /* transfer caps from row 2 to row 1 */\n            caps1_10 = caps2_10;\n            goto st108;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst144: {  /* DFA node {65,36,53} 144 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_6;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 3;\n    if (c != -1) {\n        if (c == 34) {\n            goto st58;\n        }\n        if (c == 92) {\n            goto st59;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st57;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst145: {  /* DFA node {63,53} 145 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 34) {\n            goto st109;\n        }\n        if (c == 92) {\n            goto st111;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st108;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst146: {  /* DFA node {78,65,53} 146 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 34) {\n            goto st147;\n        }\n        if (c == 39) {\n            goto st148;\n        }\n        if (c == 92) {\n            goto st150;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st146;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst147: {  /* DFA node {78,67,53} 147 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_12;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 6;\n    if (c != -1) {\n        if (c == 39) {\n            goto st84;\n        }\n        if (c == 92) {\n            goto st85;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st83;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst148: {  /* DFA node {80,65,53} 148 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 0 to matched */\n    matched_0 = caps0_14;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 7;\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst149: {  /* DFA node {78,65,32,53} 149 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 3 to matched */\n    matched_0 = caps3_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 34) {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st147;\n        }\n        if (c == 39) {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st148;\n        }\n        if (c == 61) {\n            goto st159;\n        }\n        if (c == 91) {\n            goto st160;\n        }\n        if (c == 92) {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st150;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 60)\n            || (c >= 62 && c <= 90)\n            || (c >= 93 && c <= 255))\n        {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st146;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst150: {  /* DFA node {75,62,53} 150 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if ((c >= 0 && c <= 9) || (c >= 11 && c <= 255)) {\n            goto st161;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst151: {  /* DFA node {76,63} 151 */\n    if (unlikely(i >= len)) {\n        i++;\n        goto st151_error;\n    }\n\n    c = s[i];\n    i++;\n    switch (c) {\n    case 34: {\n        goto st127;\n        break;\n        }\n    case 39: {\n        goto st128;\n        break;\n        }\n    case 92: {\n        goto st129;\n        break;\n        }\n    default:\n        break;\n    }\n    if ((c >= 0 && c <= 9)\n        || (c >= 11 && c <= 33)\n        || (c >= 35 && c <= 38)\n        || (c >= 40 && c <= 91)\n        || (c >= 93 && c <= 255))\n    {\n        goto st126;\n    }\n    }  /* end state */\n\n    goto st151_error;\n\nst152: {  /* DFA node {78,34,53} 152 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 39) {\n            /* transfer caps from row 2 to row 1 */\n            caps1_10 = caps2_10;\n            goto st131;\n        }\n        if (c == 61) {\n            goto st152;\n        }\n        if (c == 91) {\n            goto st153;\n        }\n        if (c == 92) {\n            /* transfer caps from row 2 to row 1 */\n            caps1_10 = caps2_10;\n            goto st133;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 38)\n            || (c >= 40 && c <= 60)\n            || (c >= 62 && c <= 90)\n            || (c >= 93 && c <= 255))\n        {\n            /* transfer caps from row 2 to row 1 */\n            caps1_10 = caps2_10;\n            goto st130;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst153: {  /* DFA node {78,36,53} 153 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_6;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 3;\n    if (c != -1) {\n        if (c == 39) {\n            goto st84;\n        }\n        if (c == 92) {\n            goto st85;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st83;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst154: {  /* DFA node {76,53} 154 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 1 to matched */\n    matched_0 = caps1_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 39) {\n            goto st131;\n        }\n        if (c == 92) {\n            goto st133;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st130;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst156: {  /* DFA node {65,78,34,53} 156 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 3 to matched */\n    matched_0 = caps3_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 34) {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st138;\n        }\n        if (c == 39) {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st139;\n        }\n        if (c == 61) {\n            goto st156;\n        }\n        if (c == 91) {\n            goto st157;\n        }\n        if (c == 92) {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st141;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 60)\n            || (c >= 62 && c <= 90)\n            || (c >= 93 && c <= 255))\n        {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st137;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst157: {  /* DFA node {65,78,36,53} 157 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_6;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 3;\n    if (c != -1) {\n        if (c == 34) {\n            goto st105;\n        }\n        if (c == 39) {\n            goto st106;\n        }\n        if (c == 92) {\n            goto st107;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st104;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst158: {  /* DFA node {63,76,53} 158 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 34) {\n            goto st138;\n        }\n        if (c == 39) {\n            goto st139;\n        }\n        if (c == 92) {\n            goto st141;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st137;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst159: {  /* DFA node {78,65,34,53} 159 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 3 to matched */\n    matched_0 = caps3_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 34) {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st147;\n        }\n        if (c == 39) {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st148;\n        }\n        if (c == 61) {\n            goto st159;\n        }\n        if (c == 91) {\n            goto st160;\n        }\n        if (c == 92) {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st150;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 60)\n            || (c >= 62 && c <= 90)\n            || (c >= 93 && c <= 255))\n        {\n            /* transfer caps from row 3 to row 2 */\n            caps2_10 = caps3_10;\n            goto st146;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst160: {  /* DFA node {78,65,36,53} 160 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_6;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 3;\n    if (c != -1) {\n        if (c == 34) {\n            goto st127;\n        }\n        if (c == 39) {\n            goto st128;\n        }\n        if (c == 92) {\n            goto st129;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st126;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst161: {  /* DFA node {76,63,53} 161 */\n    c = i < len ? s[i] : -1;\n    i++;\n    /* transfer caps from row 2 to matched */\n    matched_0 = caps2_10;\n    /* capture stores */\n    matched_1 = i - 1;\n    matched_id = 5;\n    if (c != -1) {\n        if (c == 34) {\n            goto st147;\n        }\n        if (c == 39) {\n            goto st148;\n        }\n        if (c == 92) {\n            goto st150;\n        }\n        if ((c >= 0 && c <= 9)\n            || (c >= 11 && c <= 33)\n            || (c >= 35 && c <= 38)\n            || (c >= 40 && c <= 91)\n            || (c >= 93 && c <= 255))\n        {\n            goto st146;\n        }\n    }\n    }  /* end state */\n\n    ovec[0] = matched_0;\n    ovec[1] = matched_1;\n    return matched_id;  /* fallback */\n\nst0_error:\nst1_error:\nst2_error:\nst3_error:\nst4_error:\nst5_error:\nst6_error:\nst9_error:\nst11_error:\nst12_error:\nst13_error:\nst14_error:\nst15_error:\nst18_error:\nst19_error:\nst21_error:\nst22_error:\nst23_error:\nst24_error:\nst28_error:\nst30_error:\nst35_error:\nst38_error:\nst39_error:\nst40_error:\nst41_error:\nst45_error:\nst47_error:\nst48_error:\nst49_error:\nst50_error:\nst51_error:\nst52_error:\nst55_error:\nst57_error:\nst59_error:\nst60_error:\nst63_error:\nst64_error:\nst65_error:\nst66_error:\nst71_error:\nst73_error:\nst74_error:\nst75_error:\nst76_error:\nst77_error:\nst78_error:\nst81_error:\nst83_error:\nst85_error:\nst92_error:\nst94_error:\nst95_error:\nst96_error:\nst97_error:\nst98_error:\nst99_error:\nst102_error:\nst104_error:\nst107_error:\nst112_error:\nst114_error:\nst116_error:\nst117_error:\nst118_error:\nst119_error:\nst120_error:\nst121_error:\nst124_error:\nst126_error:\nst129_error:\nst134_error:\nst142_error:\nst151_error:\n\n    if (matched_0 != -1) {\n        ovec[0] = matched_0;\n        ovec[1] = matched_1;\n        return matched_id;  /* fallback */\n    }\n    return NO_MATCH;\n}", "path": "lua-nginx-module/src/ngx_http_lua_lex.c", "commit_date": "2015-09-26 00:00:00", "repo_name": "openresty/lua-nginx-module", "stars": 11037, "license": "None", "language": "c", "size": 15364}
{"docstring": "/**\n * Set environment table for the given code closure.\n *\n * Before:\n *         | code closure | <- top\n *         |      ...     |\n *\n * After:\n *         | code closure | <- top\n *         |      ...     |\n * */\n", "func_signal": "static void\nngx_http_lua_set_by_lua_env(lua_State *L, ngx_http_request_t *r, size_t nargs,\n    ngx_http_variable_value_t *args)", "code": "{\n    ngx_http_lua_main_conf_t        *lmcf;\n\n    ngx_http_lua_set_req(L, r);\n\n    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);\n\n    lmcf->setby_nargs = nargs;\n    lmcf->setby_args = args;\n\n#ifndef OPENRESTY_LUAJIT\n    /**\n     * we want to create empty environment for current script\n     *\n     * newt = {}\n     * newt[\"_G\"] = newt\n     * setmetatable(newt, {__index = _G})\n     *\n     * if a function or symbol is not defined in our env, __index will lookup\n     * in the global env.\n     *\n     * all variables created in the script-env will be thrown away at the end\n     * of the script run.\n     * */\n    ngx_http_lua_create_new_globals_table(L, 0 /* narr */, 1 /* nrec */);\n\n    /*  {{{ make new env inheriting main thread's globals table */\n    /* the metatable for the new env */\n    lua_createtable(L, 0 /* narr */, 1 /* nrec */);\n    ngx_http_lua_get_globals_table(L);\n    lua_setfield(L, -2, \"__index\");\n    lua_setmetatable(L, -2);    /*  setmetatable(newt, {__index = _G}) */\n    /*  }}} */\n\n    lua_setfenv(L, -2);    /*  set new running env for the code closure */\n#endif\n}", "path": "lua-nginx-module/src/ngx_http_lua_setby.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "openresty/lua-nginx-module", "stars": 11037, "license": "None", "language": "c", "size": 15364}
{"docstring": "/* load lua code from an inline snippet for fetching cached SSL session */\n", "func_signal": "ngx_int_t\nngx_http_lua_ssl_sess_fetch_handler_inline(ngx_http_request_t *r,\n    ngx_http_lua_srv_conf_t *lscf, lua_State *L)", "code": "{\n    ngx_int_t           rc;\n\n    rc = ngx_http_lua_cache_loadbuffer(r->connection->log, L,\n                                       lscf->srv.ssl_sess_fetch_src.data,\n                                       lscf->srv.ssl_sess_fetch_src.len,\n                                       &lscf->srv.ssl_sess_fetch_src_ref,\n                                       lscf->srv.ssl_sess_fetch_src_key,\n                                       \"=ssl_session_fetch_by_lua_block\");\n    if (rc != NGX_OK) {\n        return rc;\n    }\n\n    /*  make sure we have a valid code chunk */\n    ngx_http_lua_assert(lua_isfunction(L, -1));\n\n    return ngx_http_lua_ssl_sess_fetch_by_chunk(L, r);\n}", "path": "lua-nginx-module/src/ngx_http_lua_ssl_session_fetchby.c", "commit_date": "2020-10-09 00:00:00", "repo_name": "openresty/lua-nginx-module", "stars": 11037, "license": "None", "language": "c", "size": 15364}
{"docstring": "/**\n * Create new table and set _G field to itself.\n *\n * After:\n *         | new table | <- top\n *         |    ...    |\n * */\n", "func_signal": "void\nngx_http_lua_create_new_globals_table(lua_State *L, int narr, int nrec)", "code": "{\n    lua_createtable(L, narr, nrec + 1);\n    lua_pushvalue(L, -1);\n    lua_setfield(L, -2, \"_G\");\n}", "path": "lua-nginx-module/src/ngx_http_lua_util.c", "commit_date": "2020-11-01 00:00:00", "repo_name": "openresty/lua-nginx-module", "stars": 11037, "license": "None", "language": "c", "size": 15364}
{"docstring": "/* this is for callers other than the content handler */\n", "func_signal": "ngx_int_t\nngx_http_lua_run_posted_threads(ngx_connection_t *c, lua_State *L,\n    ngx_http_request_t *r, ngx_http_lua_ctx_t *ctx, ngx_uint_t nreqs)", "code": "{\n    ngx_int_t                        rc;\n    ngx_http_lua_posted_thread_t    *pt;\n\n    for ( ;; ) {\n        if (c->destroyed || c->requests != nreqs) {\n            return NGX_DONE;\n        }\n\n        pt = ctx->posted_threads;\n        if (pt == NULL) {\n            return NGX_DONE;\n        }\n\n        ctx->posted_threads = pt->next;\n\n        ngx_http_lua_probe_run_posted_thread(r, pt->co_ctx->co,\n                                             (int) pt->co_ctx->co_status);\n\n        if (pt->co_ctx->co_status != NGX_HTTP_LUA_CO_RUNNING) {\n            continue;\n        }\n\n        ctx->cur_co_ctx = pt->co_ctx;\n\n        rc = ngx_http_lua_run_thread(L, r, ctx, 0);\n\n        if (rc == NGX_AGAIN) {\n            continue;\n        }\n\n        if (rc == NGX_DONE) {\n            ngx_http_lua_finalize_request(r, NGX_DONE);\n            continue;\n        }\n\n        /* rc == NGX_ERROR || rc >= NGX_OK */\n\n        if (ctx->entered_content_phase) {\n            ngx_http_lua_finalize_request(r, rc);\n        }\n\n        return rc;\n    }\n\n    /* impossible to reach here */\n}", "path": "lua-nginx-module/src/ngx_http_lua_util.c", "commit_date": "2020-11-01 00:00:00", "repo_name": "openresty/lua-nginx-module", "stars": 11037, "license": "None", "language": "c", "size": 15364}
{"docstring": "/* conf parser for directive ssl_session_fetch_by_lua */\n", "func_signal": "char *\nngx_http_lua_ssl_sess_fetch_by_lua(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf)", "code": "{\n    u_char                      *cache_key = NULL;\n    u_char                      *name;\n    ngx_str_t                   *value;\n    ngx_http_lua_srv_conf_t     *lscf = conf;\n\n    dd(\"enter\");\n\n    /*  must specify a content handler */\n    if (cmd->post == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    if (lscf->srv.ssl_sess_fetch_handler) {\n        return \"is duplicate\";\n    }\n\n    if (ngx_http_lua_ssl_init(cf->log) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    value = cf->args->elts;\n\n    lscf->srv.ssl_sess_fetch_handler =\n        (ngx_http_lua_srv_conf_handler_pt) cmd->post;\n\n    if (cmd->post == ngx_http_lua_ssl_sess_fetch_handler_file) {\n        /* Lua code in an external file */\n        name = ngx_http_lua_rebase_path(cf->pool, value[1].data,\n                                        value[1].len);\n        if (name == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        cache_key = ngx_http_lua_gen_file_cache_key(cf, value[1].data,\n                                                    value[1].len);\n        if (cache_key == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        lscf->srv.ssl_sess_fetch_src.data = name;\n        lscf->srv.ssl_sess_fetch_src.len = ngx_strlen(name);\n\n    } else {\n        cache_key = ngx_http_lua_gen_chunk_cache_key(cf,\n                                                     \"ssl_session_fetch_by_lua\",\n                                                     value[1].data,\n                                                     value[1].len);\n        if (cache_key == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        /* Don't eval nginx variables for inline lua code */\n        lscf->srv.ssl_sess_fetch_src = value[1];\n    }\n\n    lscf->srv.ssl_sess_fetch_src_key = cache_key;\n\n    return NGX_CONF_OK;\n}", "path": "lua-nginx-module/src/ngx_http_lua_ssl_session_fetchby.c", "commit_date": "2020-10-09 00:00:00", "repo_name": "openresty/lua-nginx-module", "stars": 11037, "license": "None", "language": "c", "size": 15364}
{"docstring": "/*\n * ngx_http_lua_strlstrn() is intended to search for static substring\n * with known length in string until the argument last. The argument n\n * must be length of the second substring - 1.\n */\n", "func_signal": "static u_char *\nngx_http_lua_strlstrn(u_char *s1, u_char *last, u_char *s2, size_t n)", "code": "{\n    ngx_uint_t  c1, c2;\n\n    c2 = (ngx_uint_t) *s2++;\n    last -= n;\n\n    do {\n        do {\n            if (s1 >= last) {\n                return NULL;\n            }\n\n            c1 = (ngx_uint_t) *s1++;\n\n            dd(\"testing char '%c' vs '%c'\", (int) c1, (int) c2);\n\n        } while (c1 != c2);\n\n        dd(\"testing against pattern \\\"%.*s\\\"\", (int) n, s2);\n\n    } while (ngx_strncmp(s1, s2, n) != 0);\n\n    return --s1;\n}", "path": "lua-nginx-module/src/ngx_http_lua_directive.c", "commit_date": "2020-07-23 00:00:00", "repo_name": "openresty/lua-nginx-module", "stars": 11037, "license": "None", "language": "c", "size": 15364}
{"docstring": "/* ===============================================================\n *\n *                          DEMO\n *\n * ===============================================================*/\n", "func_signal": "int\nmain(int argc, char *argv[])", "code": "{\n    /* Platform */\n    SDL_Window *win;\n    SDL_GLContext glContext;\n    int win_width, win_height;\n    int running = 1;\n\n    /* GUI */\n    struct nk_context *ctx;\n    struct nk_colorf bg;\n\n    /* SDL setup */\n    SDL_SetHint(SDL_HINT_VIDEO_HIGHDPI_DISABLED, \"0\");\n    SDL_Init(SDL_INIT_VIDEO);\n    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);\n    SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);\n    win = SDL_CreateWindow(\"Demo\",\n        SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,\n        WINDOW_WIDTH, WINDOW_HEIGHT, SDL_WINDOW_OPENGL|SDL_WINDOW_SHOWN|SDL_WINDOW_ALLOW_HIGHDPI);\n    glContext = SDL_GL_CreateContext(win);\n    SDL_GetWindowSize(win, &win_width, &win_height);\n\n    /* GUI */\n    ctx = nk_sdl_init(win);\n    /* Load Fonts: if none of these are loaded a default font will be used  */\n    /* Load Cursor: if you uncomment cursor loading please hide the cursor */\n    {struct nk_font_atlas *atlas;\n    nk_sdl_font_stash_begin(&atlas);\n    /*struct nk_font *droid = nk_font_atlas_add_from_file(atlas, \"../../../extra_font/DroidSans.ttf\", 14, 0);*/\n    /*struct nk_font *roboto = nk_font_atlas_add_from_file(atlas, \"../../../extra_font/Roboto-Regular.ttf\", 16, 0);*/\n    /*struct nk_font *future = nk_font_atlas_add_from_file(atlas, \"../../../extra_font/kenvector_future_thin.ttf\", 13, 0);*/\n    /*struct nk_font *clean = nk_font_atlas_add_from_file(atlas, \"../../../extra_font/ProggyClean.ttf\", 12, 0);*/\n    /*struct nk_font *tiny = nk_font_atlas_add_from_file(atlas, \"../../../extra_font/ProggyTiny.ttf\", 10, 0);*/\n    /*struct nk_font *cousine = nk_font_atlas_add_from_file(atlas, \"../../../extra_font/Cousine-Regular.ttf\", 13, 0);*/\n    nk_sdl_font_stash_end();\n    /*nk_style_load_all_cursors(ctx, atlas->cursors);*/\n    /*nk_style_set_font(ctx, &roboto->handle)*/;}\n\n    #ifdef INCLUDE_STYLE\n    /*set_style(ctx, THEME_WHITE);*/\n    /*set_style(ctx, THEME_RED);*/\n    /*set_style(ctx, THEME_BLUE);*/\n    /*set_style(ctx, THEME_DARK);*/\n    #endif\n\n    bg.r = 0.10f, bg.g = 0.18f, bg.b = 0.24f, bg.a = 1.0f;\n    while (running)\n    {\n        /* Input */\n        SDL_Event evt;\n        nk_input_begin(ctx);\n        while (SDL_PollEvent(&evt)) {\n            if (evt.type == SDL_QUIT) goto cleanup;\n            nk_sdl_handle_event(&evt);\n        }\n        nk_input_end(ctx);\n\n        /* GUI */\n        if (nk_begin(ctx, \"Demo\", nk_rect(50, 50, 230, 250),\n            NK_WINDOW_BORDER|NK_WINDOW_MOVABLE|NK_WINDOW_SCALABLE|\n            NK_WINDOW_MINIMIZABLE|NK_WINDOW_TITLE))\n        {\n            enum {EASY, HARD};\n            static int op = EASY;\n            static int property = 20;\n\n            nk_layout_row_static(ctx, 30, 80, 1);\n            if (nk_button_label(ctx, \"button\"))\n                fprintf(stdout, \"button pressed\\n\");\n            nk_layout_row_dynamic(ctx, 30, 2);\n            if (nk_option_label(ctx, \"easy\", op == EASY)) op = EASY;\n            if (nk_option_label(ctx, \"hard\", op == HARD)) op = HARD;\n            nk_layout_row_dynamic(ctx, 25, 1);\n            nk_property_int(ctx, \"Compression:\", 0, &property, 100, 10, 1);\n\n            nk_layout_row_dynamic(ctx, 20, 1);\n            nk_label(ctx, \"background:\", NK_TEXT_LEFT);\n            nk_layout_row_dynamic(ctx, 25, 1);\n            if (nk_combo_begin_color(ctx, nk_rgb_cf(bg), nk_vec2(nk_widget_width(ctx),400))) {\n                nk_layout_row_dynamic(ctx, 120, 1);\n                bg = nk_color_picker(ctx, bg, NK_RGBA);\n                nk_layout_row_dynamic(ctx, 25, 1);\n                bg.r = nk_propertyf(ctx, \"#R:\", 0, bg.r, 1.0f, 0.01f,0.005f);\n                bg.g = nk_propertyf(ctx, \"#G:\", 0, bg.g, 1.0f, 0.01f,0.005f);\n                bg.b = nk_propertyf(ctx, \"#B:\", 0, bg.b, 1.0f, 0.01f,0.005f);\n                bg.a = nk_propertyf(ctx, \"#A:\", 0, bg.a, 1.0f, 0.01f,0.005f);\n                nk_combo_end(ctx);\n            }\n        }\n        nk_end(ctx);\n\n        /* -------------- EXAMPLES ---------------- */\n        #ifdef INCLUDE_CALCULATOR\n          calculator(ctx);\n        #endif\n        #ifdef INCLUDE_OVERVIEW\n          overview(ctx);\n        #endif\n        #ifdef INCLUDE_NODE_EDITOR\n          node_editor(ctx);\n        #endif\n        /* ----------------------------------------- */\n\n        /* Draw */\n        SDL_GetWindowSize(win, &win_width, &win_height);\n        glViewport(0, 0, win_width, win_height);\n        glClear(GL_COLOR_BUFFER_BIT);\n        glClearColor(bg.r, bg.g, bg.b, bg.a);\n        /* IMPORTANT: `nk_sdl_render` modifies some global OpenGL state\n         * with blending, scissor, face culling, depth test and viewport and\n         * defaults everything back into a default state.\n         * Make sure to either a.) save and restore or b.) reset your own state after\n         * rendering the UI. */\n        nk_sdl_render(NK_ANTI_ALIASING_ON);\n        SDL_GL_SwapWindow(win);\n    }\n\ncleanup:\n    nk_sdl_shutdown();\n    SDL_GL_DeleteContext(glContext);\n    SDL_DestroyWindow(win);\n    SDL_Quit();\n    return 0;\n}", "path": "Nuklear/demo/sdl_opengl2/main.c", "commit_date": "2020-03-09 00:00:00", "repo_name": "Immediate-Mode-UI/Nuklear", "stars": 8350, "license": "None", "language": "c", "size": 10284}
{"docstring": "/* ==============================================================\n *\n *                          COMBO\n *\n * ===============================================================*/\n", "func_signal": "NK_INTERN nk_bool\nnk_combo_begin(struct nk_context *ctx, struct nk_window *win,\n    struct nk_vec2 size, nk_bool is_clicked, struct nk_rect header)", "code": "{\n    struct nk_window *popup;\n    int is_open = 0;\n    int is_active = 0;\n    struct nk_rect body;\n    nk_hash hash;\n\n    NK_ASSERT(ctx);\n    NK_ASSERT(ctx->current);\n    NK_ASSERT(ctx->current->layout);\n    if (!ctx || !ctx->current || !ctx->current->layout)\n        return 0;\n\n    popup = win->popup.win;\n    body.x = header.x;\n    body.w = size.x;\n    body.y = header.y + header.h-ctx->style.window.combo_border;\n    body.h = size.y;\n\n    hash = win->popup.combo_count++;\n    is_open = (popup) ? nk_true:nk_false;\n    is_active = (popup && (win->popup.name == hash) && win->popup.type == NK_PANEL_COMBO);\n    if ((is_clicked && is_open && !is_active) || (is_open && !is_active) ||\n        (!is_open && !is_active && !is_clicked)) return 0;\n    if (!nk_nonblock_begin(ctx, 0, body,\n        (is_clicked && is_open)?nk_rect(0,0,0,0):header, NK_PANEL_COMBO)) return 0;\n\n    win->popup.type = NK_PANEL_COMBO;\n    win->popup.name = hash;\n    return 1;\n}", "path": "Nuklear/src/nuklear_combo.c", "commit_date": "2020-10-07 00:00:00", "repo_name": "Immediate-Mode-UI/Nuklear", "stars": 8350, "license": "None", "language": "c", "size": 10284}
{"docstring": "/* ===============================================================\n *\n *                          DEMO\n *\n * ===============================================================*/\n", "func_signal": "static LRESULT CALLBACK\nWindowProc(HWND wnd, UINT msg, WPARAM wparam, LPARAM lparam)", "code": "{\n    switch (msg)\n    {\n    case WM_DESTROY:\n        PostQuitMessage(0);\n        return 0;\n    }\n\n    if (nk_gdi_handle_event(wnd, msg, wparam, lparam))\n        return 0;\n\n    return DefWindowProcW(wnd, msg, wparam, lparam);\n}", "path": "Nuklear/demo/gdi/main.c", "commit_date": "2018-01-01 00:00:00", "repo_name": "Immediate-Mode-UI/Nuklear", "stars": 8350, "license": "None", "language": "c", "size": 10284}
{"docstring": "/* function icon_load () is not used to build this file but might still be useful :) */\n/*\nstatic struct nk_image\t\nicon_load(const char *filename)\t\n{\t\n    int x,y,n;\t\n    GLuint tex;\t\n    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);\t\n    if (!data) die(\"[SDL]: failed to load image: %s\", filename);\t\n\n     glGenTextures(1, &tex);\t\n    glBindTexture(GL_TEXTURE_2D, tex);\t\n    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_NEAREST);\t\n    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR_MIPMAP_NEAREST);\t\n    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\t\n    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\t\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, x, y, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);\t\n    glGenerateMipmap(GL_TEXTURE_2D);\t\n    stbi_image_free(data);\t\n    return nk_image_id((int)tex);\t\n}\n*/\n", "func_signal": "static void\ndevice_init(struct device *dev)", "code": "{\n    GLint status;\n    static const GLchar *vertex_shader =\n        NK_SHADER_VERSION\n        \"uniform mat4 ProjMtx;\\n\"\n        \"in vec2 Position;\\n\"\n        \"in vec2 TexCoord;\\n\"\n        \"in vec4 Color;\\n\"\n        \"out vec2 Frag_UV;\\n\"\n        \"out vec4 Frag_Color;\\n\"\n        \"void main() {\\n\"\n        \"   Frag_UV = TexCoord;\\n\"\n        \"   Frag_Color = Color;\\n\"\n        \"   gl_Position = ProjMtx * vec4(Position.xy, 0, 1);\\n\"\n        \"}\\n\";\n    static const GLchar *fragment_shader =\n        NK_SHADER_VERSION\n        \"precision mediump float;\\n\"\n        \"uniform sampler2D Texture;\\n\"\n        \"in vec2 Frag_UV;\\n\"\n        \"in vec4 Frag_Color;\\n\"\n        \"out vec4 Out_Color;\\n\"\n        \"void main(){\\n\"\n        \"   Out_Color = Frag_Color * texture(Texture, Frag_UV.st);\\n\"\n        \"}\\n\";\n\n    nk_buffer_init_default(&dev->cmds);\n    dev->prog = glCreateProgram();\n    dev->vert_shdr = glCreateShader(GL_VERTEX_SHADER);\n    dev->frag_shdr = glCreateShader(GL_FRAGMENT_SHADER);\n    glShaderSource(dev->vert_shdr, 1, &vertex_shader, 0);\n    glShaderSource(dev->frag_shdr, 1, &fragment_shader, 0);\n    glCompileShader(dev->vert_shdr);\n    glCompileShader(dev->frag_shdr);\n    glGetShaderiv(dev->vert_shdr, GL_COMPILE_STATUS, &status);\n    assert(status == GL_TRUE);\n    glGetShaderiv(dev->frag_shdr, GL_COMPILE_STATUS, &status);\n    assert(status == GL_TRUE);\n    glAttachShader(dev->prog, dev->vert_shdr);\n    glAttachShader(dev->prog, dev->frag_shdr);\n    glLinkProgram(dev->prog);\n    glGetProgramiv(dev->prog, GL_LINK_STATUS, &status);\n    assert(status == GL_TRUE);\n\n    dev->uniform_tex = glGetUniformLocation(dev->prog, \"Texture\");\n    dev->uniform_proj = glGetUniformLocation(dev->prog, \"ProjMtx\");\n    dev->attrib_pos = glGetAttribLocation(dev->prog, \"Position\");\n    dev->attrib_uv = glGetAttribLocation(dev->prog, \"TexCoord\");\n    dev->attrib_col = glGetAttribLocation(dev->prog, \"Color\");\n\n    {\n        /* buffer setup */\n        GLsizei vs = sizeof(struct nk_glfw_vertex);\n        size_t vp = offsetof(struct nk_glfw_vertex, position);\n        size_t vt = offsetof(struct nk_glfw_vertex, uv);\n        size_t vc = offsetof(struct nk_glfw_vertex, col);\n\n        glGenBuffers(1, &dev->vbo);\n        glGenBuffers(1, &dev->ebo);\n        glGenVertexArrays(1, &dev->vao);\n\n        glBindVertexArray(dev->vao);\n        glBindBuffer(GL_ARRAY_BUFFER, dev->vbo);\n        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, dev->ebo);\n\n        glEnableVertexAttribArray((GLuint)dev->attrib_pos);\n        glEnableVertexAttribArray((GLuint)dev->attrib_uv);\n        glEnableVertexAttribArray((GLuint)dev->attrib_col);\n\n        glVertexAttribPointer((GLuint)dev->attrib_pos, 2, GL_FLOAT, GL_FALSE, vs, (void*)vp);\n        glVertexAttribPointer((GLuint)dev->attrib_uv, 2, GL_FLOAT, GL_FALSE, vs, (void*)vt);\n        glVertexAttribPointer((GLuint)dev->attrib_col, 4, GL_UNSIGNED_BYTE, GL_TRUE, vs, (void*)vc);\n    }\n\n    glBindTexture(GL_TEXTURE_2D, 0);\n    glBindBuffer(GL_ARRAY_BUFFER, 0);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n    glBindVertexArray(0);\n}", "path": "Nuklear/example/canvas.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "Immediate-Mode-UI/Nuklear", "stars": 8350, "license": "None", "language": "c", "size": 10284}
{"docstring": "/* -------------------------------------------------------------\n *\n *                          FONT\n *\n * --------------------------------------------------------------*/\n", "func_signal": "NK_INTERN float\nnk_font_text_width(nk_handle handle, float height, const char *text, int len)", "code": "{\n    nk_rune unicode;\n    int text_len  = 0;\n    float text_width = 0;\n    int glyph_len = 0;\n    float scale = 0;\n\n    struct nk_font *font = (struct nk_font*)handle.ptr;\n    NK_ASSERT(font);\n    NK_ASSERT(font->glyphs);\n    if (!font || !text || !len)\n        return 0;\n\n    scale = height/font->info.height;\n    glyph_len = text_len = nk_utf_decode(text, &unicode, (int)len);\n    if (!glyph_len) return 0;\n    while (text_len <= (int)len && glyph_len) {\n        const struct nk_font_glyph *g;\n        if (unicode == NK_UTF_INVALID) break;\n\n        /* query currently drawn glyph information */\n        g = nk_font_find_glyph(font, unicode);\n        text_width += g->xadvance * scale;\n\n        /* offset next glyph */\n        glyph_len = nk_utf_decode(text + text_len, &unicode, (int)len - text_len);\n        text_len += glyph_len;\n    }\n    return text_width;\n}", "path": "Nuklear/src/nuklear_font.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "Immediate-Mode-UI/Nuklear", "stars": 8350, "license": "None", "language": "c", "size": 10284}
{"docstring": "/* ===============================================================\n *\n *                          DEMO\n *\n * ===============================================================*/\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n    /* Platform */\n    SDL_Window *win;\n    SDL_GLContext glContext;\n    int win_width, win_height;\n    int running = 1;\n\n    /* GUI */\n    struct nk_context *ctx;\n    struct nk_colorf bg;\n\n    /* SDL setup */\n    SDL_SetHint(SDL_HINT_VIDEO_HIGHDPI_DISABLED, \"0\");\n    SDL_Init(SDL_INIT_VIDEO|SDL_INIT_TIMER|SDL_INIT_EVENTS);\n    SDL_GL_SetAttribute (SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG);\n    SDL_GL_SetAttribute (SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);\n    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n    win = SDL_CreateWindow(\"Demo\",\n        SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,\n        WINDOW_WIDTH, WINDOW_HEIGHT, SDL_WINDOW_OPENGL|SDL_WINDOW_SHOWN|SDL_WINDOW_ALLOW_HIGHDPI);\n    glContext = SDL_GL_CreateContext(win);\n    SDL_GetWindowSize(win, &win_width, &win_height);\n\n    /* OpenGL setup */\n    glViewport(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);\n    glewExperimental = 1;\n    if (glewInit() != GLEW_OK) {\n        fprintf(stderr, \"Failed to setup GLEW\\n\");\n        exit(1);\n    }\n\n    ctx = nk_sdl_init(win);\n    /* Load Fonts: if none of these are loaded a default font will be used  */\n    /* Load Cursor: if you uncomment cursor loading please hide the cursor */\n    {struct nk_font_atlas *atlas;\n    nk_sdl_font_stash_begin(&atlas);\n    /*struct nk_font *droid = nk_font_atlas_add_from_file(atlas, \"../../../extra_font/DroidSans.ttf\", 14, 0);*/\n    /*struct nk_font *roboto = nk_font_atlas_add_from_file(atlas, \"../../../extra_font/Roboto-Regular.ttf\", 16, 0);*/\n    /*struct nk_font *future = nk_font_atlas_add_from_file(atlas, \"../../../extra_font/kenvector_future_thin.ttf\", 13, 0);*/\n    /*struct nk_font *clean = nk_font_atlas_add_from_file(atlas, \"../../../extra_font/ProggyClean.ttf\", 12, 0);*/\n    /*struct nk_font *tiny = nk_font_atlas_add_from_file(atlas, \"../../../extra_font/ProggyTiny.ttf\", 10, 0);*/\n    /*struct nk_font *cousine = nk_font_atlas_add_from_file(atlas, \"../../../extra_font/Cousine-Regular.ttf\", 13, 0);*/\n    nk_sdl_font_stash_end();\n    /*nk_style_load_all_cursors(ctx, atlas->cursors);*/\n    /*nk_style_set_font(ctx, &roboto->handle);*/}\n\n    /* style.c */\n    #ifdef INCLUDE_STYLE\n    /*set_style(ctx, THEME_WHITE);*/\n    /*set_style(ctx, THEME_RED);*/\n    /*set_style(ctx, THEME_BLUE);*/\n    /*set_style(ctx, THEME_DARK);*/\n    #endif\n\n    bg.r = 0.10f, bg.g = 0.18f, bg.b = 0.24f, bg.a = 1.0f;\n    while (running)\n    {\n        /* Input */\n        SDL_Event evt;\n        nk_input_begin(ctx);\n        while (SDL_PollEvent(&evt)) {\n            if (evt.type == SDL_QUIT) goto cleanup;\n            nk_sdl_handle_event(&evt);\n        } nk_input_end(ctx);\n\n        /* GUI */\n        if (nk_begin(ctx, \"Demo\", nk_rect(50, 50, 230, 250),\n            NK_WINDOW_BORDER|NK_WINDOW_MOVABLE|NK_WINDOW_SCALABLE|\n            NK_WINDOW_MINIMIZABLE|NK_WINDOW_TITLE))\n        {\n            enum {EASY, HARD};\n            static int op = EASY;\n            static int property = 20;\n\n            nk_layout_row_static(ctx, 30, 80, 1);\n            if (nk_button_label(ctx, \"button\"))\n                printf(\"button pressed!\\n\");\n            nk_layout_row_dynamic(ctx, 30, 2);\n            if (nk_option_label(ctx, \"easy\", op == EASY)) op = EASY;\n            if (nk_option_label(ctx, \"hard\", op == HARD)) op = HARD;\n            nk_layout_row_dynamic(ctx, 22, 1);\n            nk_property_int(ctx, \"Compression:\", 0, &property, 100, 10, 1);\n\n            nk_layout_row_dynamic(ctx, 20, 1);\n            nk_label(ctx, \"background:\", NK_TEXT_LEFT);\n            nk_layout_row_dynamic(ctx, 25, 1);\n            if (nk_combo_begin_color(ctx, nk_rgb_cf(bg), nk_vec2(nk_widget_width(ctx),400))) {\n                nk_layout_row_dynamic(ctx, 120, 1);\n                bg = nk_color_picker(ctx, bg, NK_RGBA);\n                nk_layout_row_dynamic(ctx, 25, 1);\n                bg.r = nk_propertyf(ctx, \"#R:\", 0, bg.r, 1.0f, 0.01f,0.005f);\n                bg.g = nk_propertyf(ctx, \"#G:\", 0, bg.g, 1.0f, 0.01f,0.005f);\n                bg.b = nk_propertyf(ctx, \"#B:\", 0, bg.b, 1.0f, 0.01f,0.005f);\n                bg.a = nk_propertyf(ctx, \"#A:\", 0, bg.a, 1.0f, 0.01f,0.005f);\n                nk_combo_end(ctx);\n            }\n        }\n        nk_end(ctx);\n\n        /* -------------- EXAMPLES ---------------- */\n        #ifdef INCLUDE_CALCULATOR\n          calculator(ctx);\n        #endif\n        #ifdef INCLUDE_OVERVIEW\n          overview(ctx);\n        #endif\n        #ifdef INCLUDE_NODE_EDITOR\n          node_editor(ctx);\n        #endif\n        /* ----------------------------------------- */\n\n        /* Draw */\n        SDL_GetWindowSize(win, &win_width, &win_height);\n        glViewport(0, 0, win_width, win_height);\n        glClear(GL_COLOR_BUFFER_BIT);\n        glClearColor(bg.r, bg.g, bg.b, bg.a);\n        /* IMPORTANT: `nk_sdl_render` modifies some global OpenGL state\n         * with blending, scissor, face culling, depth test and viewport and\n         * defaults everything back into a default state.\n         * Make sure to either a.) save and restore or b.) reset your own state after\n         * rendering the UI. */\n        nk_sdl_render(NK_ANTI_ALIASING_ON, MAX_VERTEX_MEMORY, MAX_ELEMENT_MEMORY);\n        SDL_GL_SwapWindow(win);\n    }\n\ncleanup:\n    nk_sdl_shutdown();\n    SDL_GL_DeleteContext(glContext);\n    SDL_DestroyWindow(win);\n    SDL_Quit();\n    return 0;\n}", "path": "Nuklear/demo/sdl_opengl3/main.c", "commit_date": "2020-03-09 00:00:00", "repo_name": "Immediate-Mode-UI/Nuklear", "stars": 8350, "license": "None", "language": "c", "size": 10284}
{"docstring": "/* glfw callbacks (I don't know if there is a easier way to access text and scroll )*/\n", "func_signal": "static void error_callback(int e, const char *d)", "code": "{printf(\"Error %d: %s\\n\", e, d);}\nstatic void text_input(GLFWwindow *win, unsigned int codepoint)\n{nk_input_unicode((struct nk_context*)glfwGetWindowUserPointer(win), codepoint);}\nstatic void scroll_input(GLFWwindow *win, double _, double yoff)\n{UNUSED(_);nk_input_scroll((struct nk_context*)glfwGetWindowUserPointer(win), nk_vec2(0, (float)yoff));}\n\nint main(int argc, char *argv[])\n{\n    /* Platform */\n    static GLFWwindow *win;\n    int width = 0, height = 0;\n    int display_width=0, display_height=0;\n\n    /* GUI */\n    struct device device;\n    struct nk_font_atlas atlas;\n    struct media media;\n    struct nk_context ctx;\n    struct nk_font *font;\n\n    /* GLFW */\n    glfwSetErrorCallback(error_callback);\n    if (!glfwInit()) {\n        fprintf(stdout, \"[GFLW] failed to init!\\n\");\n        exit(1);\n    }\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n#ifdef __APPLE__\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n#endif\n    win = glfwCreateWindow(WINDOW_WIDTH, WINDOW_HEIGHT, \"Demo\", NULL, NULL);\n    glfwMakeContextCurrent(win);\n    glfwSetWindowUserPointer(win, &ctx);\n    glfwSetCharCallback(win, text_input);\n    glfwSetScrollCallback(win, scroll_input);\n    glfwGetWindowSize(win, &width, &height);\n    glfwGetFramebufferSize(win, &display_width, &display_height);\n\n    /* OpenGL */\n    glViewport(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);\n    glewExperimental = 1;\n    if (glewInit() != GLEW_OK) {\n        fprintf(stderr, \"Failed to setup GLEW\\n\");\n        exit(1);\n    }\n\n    /* GUI */\n    {device_init(&device);\n    {const void *image; int w, h;\n    const char *font_path = (argc > 1) ? argv[1]: 0;\n    nk_font_atlas_init_default(&atlas);\n    nk_font_atlas_begin(&atlas);\n    if (font_path) font = nk_font_atlas_add_from_file(&atlas, font_path, 13.0f, NULL);\n    else font = nk_font_atlas_add_default(&atlas, 13.0f, NULL);\n    image = nk_font_atlas_bake(&atlas, &w, &h, NK_FONT_ATLAS_RGBA32);\n    device_upload_atlas(&device, image, w, h);\n    nk_font_atlas_end(&atlas, nk_handle_id((int)device.font_tex), &device.null);}\n    nk_init_default(&ctx, &font->handle);}\n\n    {   /* skin */\n        glEnable(GL_TEXTURE_2D);\n        media.skin = image_load(\"../skins/gwen.png\");\n        media.check = nk_subimage_id(media.skin, 512,512, nk_rect(464,32,15,15));\n        media.check_cursor = nk_subimage_id(media.skin, 512,512, nk_rect(450,34,11,11));\n        media.option = nk_subimage_id(media.skin, 512,512, nk_rect(464,64,15,15));\n        media.option_cursor = nk_subimage_id(media.skin, 512,512, nk_rect(451,67,9,9));\n        media.header = nk_subimage_id(media.skin, 512,512, nk_rect(128,0,127,24));\n        media.window = nk_subimage_id(media.skin, 512,512, nk_rect(128,23,127,104));\n        media.scrollbar_inc_button = nk_subimage_id(media.skin, 512,512, nk_rect(464,256,15,15));\n        media.scrollbar_inc_button_hover = nk_subimage_id(media.skin, 512,512, nk_rect(464,320,15,15));\n        media.scrollbar_dec_button = nk_subimage_id(media.skin, 512,512, nk_rect(464,224,15,15));\n        media.scrollbar_dec_button_hover = nk_subimage_id(media.skin, 512,512, nk_rect(464,288,15,15));\n        media.button = nk_subimage_id(media.skin, 512,512, nk_rect(384,336,127,31));\n        media.button_hover = nk_subimage_id(media.skin, 512,512, nk_rect(384,368,127,31));\n        media.button_active = nk_subimage_id(media.skin, 512,512, nk_rect(384,400,127,31));\n        media.tab_minimize = nk_subimage_id(media.skin, 512,512, nk_rect(451, 99, 9, 9));\n        media.tab_maximize = nk_subimage_id(media.skin, 512,512, nk_rect(467,99,9,9));\n        media.slider = nk_subimage_id(media.skin, 512,512, nk_rect(418,33,11,14));\n        media.slider_hover = nk_subimage_id(media.skin, 512,512, nk_rect(418,49,11,14));\n        media.slider_active = nk_subimage_id(media.skin, 512,512, nk_rect(418,64,11,14));\n\n        /* window */\n        ctx.style.window.background = nk_rgb(204,204,204);\n        ctx.style.window.fixed_background = nk_style_item_image(media.window);\n        ctx.style.window.border_color = nk_rgb(67,67,67);\n        ctx.style.window.combo_border_color = nk_rgb(67,67,67);\n        ctx.style.window.contextual_border_color = nk_rgb(67,67,67);\n        ctx.style.window.menu_border_color = nk_rgb(67,67,67);\n        ctx.style.window.group_border_color = nk_rgb(67,67,67);\n        ctx.style.window.tooltip_border_color = nk_rgb(67,67,67);\n        ctx.style.window.scrollbar_size = nk_vec2(16,16);\n        ctx.style.window.border_color = nk_rgba(0,0,0,0);\n        ctx.style.window.padding = nk_vec2(8,4);\n        ctx.style.window.border = 3;\n\n        /* window header */\n        ctx.style.window.header.normal = nk_style_item_image(media.header);\n        ctx.style.window.header.hover = nk_style_item_image(media.header);\n        ctx.style.window.header.active = nk_style_item_image(media.header);\n        ctx.style.window.header.label_normal = nk_rgb(95,95,95);\n        ctx.style.window.header.label_hover = nk_rgb(95,95,95);\n        ctx.style.window.header.label_active = nk_rgb(95,95,95);\n\n        /* scrollbar */\n        ctx.style.scrollv.normal          = nk_style_item_color(nk_rgb(184,184,184));\n        ctx.style.scrollv.hover           = nk_style_item_color(nk_rgb(184,184,184));\n        ctx.style.scrollv.active          = nk_style_item_color(nk_rgb(184,184,184));\n        ctx.style.scrollv.cursor_normal   = nk_style_item_color(nk_rgb(220,220,220));\n        ctx.style.scrollv.cursor_hover    = nk_style_item_color(nk_rgb(235,235,235));\n        ctx.style.scrollv.cursor_active   = nk_style_item_color(nk_rgb(99,202,255));\n        ctx.style.scrollv.dec_symbol      = NK_SYMBOL_NONE;\n        ctx.style.scrollv.inc_symbol      = NK_SYMBOL_NONE;\n        ctx.style.scrollv.show_buttons    = nk_true;\n        ctx.style.scrollv.border_color    = nk_rgb(81,81,81);\n        ctx.style.scrollv.cursor_border_color = nk_rgb(81,81,81);\n        ctx.style.scrollv.border          = 1;\n        ctx.style.scrollv.rounding        = 0;\n        ctx.style.scrollv.border_cursor   = 1;\n        ctx.style.scrollv.rounding_cursor = 2;\n\n        /* scrollbar buttons */\n        ctx.style.scrollv.inc_button.normal          = nk_style_item_image(media.scrollbar_inc_button);\n        ctx.style.scrollv.inc_button.hover           = nk_style_item_image(media.scrollbar_inc_button_hover);\n        ctx.style.scrollv.inc_button.active          = nk_style_item_image(media.scrollbar_inc_button_hover);\n        ctx.style.scrollv.inc_button.border_color    = nk_rgba(0,0,0,0);\n        ctx.style.scrollv.inc_button.text_background = nk_rgba(0,0,0,0);\n        ctx.style.scrollv.inc_button.text_normal     = nk_rgba(0,0,0,0);\n        ctx.style.scrollv.inc_button.text_hover      = nk_rgba(0,0,0,0);\n        ctx.style.scrollv.inc_button.text_active     = nk_rgba(0,0,0,0);\n        ctx.style.scrollv.inc_button.border          = 0.0f;\n\n        ctx.style.scrollv.dec_button.normal          = nk_style_item_image(media.scrollbar_dec_button);\n        ctx.style.scrollv.dec_button.hover           = nk_style_item_image(media.scrollbar_dec_button_hover);\n        ctx.style.scrollv.dec_button.active          = nk_style_item_image(media.scrollbar_dec_button_hover);\n        ctx.style.scrollv.dec_button.border_color    = nk_rgba(0,0,0,0);\n        ctx.style.scrollv.dec_button.text_background = nk_rgba(0,0,0,0);\n        ctx.style.scrollv.dec_button.text_normal     = nk_rgba(0,0,0,0);\n        ctx.style.scrollv.dec_button.text_hover      = nk_rgba(0,0,0,0);\n        ctx.style.scrollv.dec_button.text_active     = nk_rgba(0,0,0,0);\n        ctx.style.scrollv.dec_button.border          = 0.0f;\n\n        /* checkbox toggle */\n        {struct nk_style_toggle *toggle;\n        toggle = &ctx.style.checkbox;\n        toggle->normal          = nk_style_item_image(media.check);\n        toggle->hover           = nk_style_item_image(media.check);\n        toggle->active          = nk_style_item_image(media.check);\n        toggle->cursor_normal   = nk_style_item_image(media.check_cursor);\n        toggle->cursor_hover    = nk_style_item_image(media.check_cursor);\n        toggle->text_normal     = nk_rgb(95,95,95);\n        toggle->text_hover      = nk_rgb(95,95,95);\n        toggle->text_active     = nk_rgb(95,95,95);}\n\n        /* option toggle */\n        {struct nk_style_toggle *toggle;\n        toggle = &ctx.style.option;\n        toggle->normal          = nk_style_item_image(media.option);\n        toggle->hover           = nk_style_item_image(media.option);\n        toggle->active          = nk_style_item_image(media.option);\n        toggle->cursor_normal   = nk_style_item_image(media.option_cursor);\n        toggle->cursor_hover    = nk_style_item_image(media.option_cursor);\n        toggle->text_normal     = nk_rgb(95,95,95);\n        toggle->text_hover      = nk_rgb(95,95,95);\n        toggle->text_active     = nk_rgb(95,95,95);}\n\n        /* default button */\n        ctx.style.button.normal = nk_style_item_image(media.button);\n        ctx.style.button.hover = nk_style_item_image(media.button_hover);\n        ctx.style.button.active = nk_style_item_image(media.button_active);\n        ctx.style.button.border_color = nk_rgba(0,0,0,0);\n        ctx.style.button.text_background = nk_rgba(0,0,0,0);\n        ctx.style.button.text_normal = nk_rgb(95,95,95);\n        ctx.style.button.text_hover = nk_rgb(95,95,95);\n        ctx.style.button.text_active = nk_rgb(95,95,95);\n\n        /* default text */\n        ctx.style.text.color = nk_rgb(95,95,95);\n\n        /* contextual button */\n        ctx.style.contextual_button.normal = nk_style_item_color(nk_rgb(206,206,206));\n        ctx.style.contextual_button.hover = nk_style_item_color(nk_rgb(229,229,229));\n        ctx.style.contextual_button.active = nk_style_item_color(nk_rgb(99,202,255));\n        ctx.style.contextual_button.border_color = nk_rgba(0,0,0,0);\n        ctx.style.contextual_button.text_background = nk_rgba(0,0,0,0);\n        ctx.style.contextual_button.text_normal = nk_rgb(95,95,95);\n        ctx.style.contextual_button.text_hover = nk_rgb(95,95,95);\n        ctx.style.contextual_button.text_active = nk_rgb(95,95,95);\n\n        /* menu button */\n        ctx.style.menu_button.normal = nk_style_item_color(nk_rgb(206,206,206));\n        ctx.style.menu_button.hover = nk_style_item_color(nk_rgb(229,229,229));\n        ctx.style.menu_button.active = nk_style_item_color(nk_rgb(99,202,255));\n        ctx.style.menu_button.border_color = nk_rgba(0,0,0,0);\n        ctx.style.menu_button.text_background = nk_rgba(0,0,0,0);\n        ctx.style.menu_button.text_normal = nk_rgb(95,95,95);\n        ctx.style.menu_button.text_hover = nk_rgb(95,95,95);\n        ctx.style.menu_button.text_active = nk_rgb(95,95,95);\n\n        /* tree */\n        ctx.style.tab.text = nk_rgb(95,95,95);\n        ctx.style.tab.tab_minimize_button.normal = nk_style_item_image(media.tab_minimize);\n        ctx.style.tab.tab_minimize_button.hover = nk_style_item_image(media.tab_minimize);\n        ctx.style.tab.tab_minimize_button.active = nk_style_item_image(media.tab_minimize);\n        ctx.style.tab.tab_minimize_button.text_background = nk_rgba(0,0,0,0);\n        ctx.style.tab.tab_minimize_button.text_normal = nk_rgba(0,0,0,0);\n        ctx.style.tab.tab_minimize_button.text_hover = nk_rgba(0,0,0,0);\n        ctx.style.tab.tab_minimize_button.text_active = nk_rgba(0,0,0,0);\n\n        ctx.style.tab.tab_maximize_button.normal = nk_style_item_image(media.tab_maximize);\n        ctx.style.tab.tab_maximize_button.hover = nk_style_item_image(media.tab_maximize);\n        ctx.style.tab.tab_maximize_button.active = nk_style_item_image(media.tab_maximize);\n        ctx.style.tab.tab_maximize_button.text_background = nk_rgba(0,0,0,0);\n        ctx.style.tab.tab_maximize_button.text_normal = nk_rgba(0,0,0,0);\n        ctx.style.tab.tab_maximize_button.text_hover = nk_rgba(0,0,0,0);\n        ctx.style.tab.tab_maximize_button.text_active = nk_rgba(0,0,0,0);\n\n        ctx.style.tab.node_minimize_button.normal = nk_style_item_image(media.tab_minimize);\n        ctx.style.tab.node_minimize_button.hover = nk_style_item_image(media.tab_minimize);\n        ctx.style.tab.node_minimize_button.active = nk_style_item_image(media.tab_minimize);\n        ctx.style.tab.node_minimize_button.text_background = nk_rgba(0,0,0,0);\n        ctx.style.tab.node_minimize_button.text_normal = nk_rgba(0,0,0,0);\n        ctx.style.tab.node_minimize_button.text_hover = nk_rgba(0,0,0,0);\n        ctx.style.tab.node_minimize_button.text_active = nk_rgba(0,0,0,0);\n\n        ctx.style.tab.node_maximize_button.normal = nk_style_item_image(media.tab_maximize);\n        ctx.style.tab.node_maximize_button.hover = nk_style_item_image(media.tab_maximize);\n        ctx.style.tab.node_maximize_button.active = nk_style_item_image(media.tab_maximize);\n        ctx.style.tab.node_maximize_button.text_background = nk_rgba(0,0,0,0);\n        ctx.style.tab.node_maximize_button.text_normal = nk_rgba(0,0,0,0);\n        ctx.style.tab.node_maximize_button.text_hover = nk_rgba(0,0,0,0);\n        ctx.style.tab.node_maximize_button.text_active = nk_rgba(0,0,0,0);\n\n        /* selectable */\n        ctx.style.selectable.normal = nk_style_item_color(nk_rgb(206,206,206));\n        ctx.style.selectable.hover = nk_style_item_color(nk_rgb(206,206,206));\n        ctx.style.selectable.pressed = nk_style_item_color(nk_rgb(206,206,206));\n        ctx.style.selectable.normal_active = nk_style_item_color(nk_rgb(185,205,248));\n        ctx.style.selectable.hover_active = nk_style_item_color(nk_rgb(185,205,248));\n        ctx.style.selectable.pressed_active = nk_style_item_color(nk_rgb(185,205,248));\n        ctx.style.selectable.text_normal = nk_rgb(95,95,95);\n        ctx.style.selectable.text_hover = nk_rgb(95,95,95);\n        ctx.style.selectable.text_pressed = nk_rgb(95,95,95);\n        ctx.style.selectable.text_normal_active = nk_rgb(95,95,95);\n        ctx.style.selectable.text_hover_active = nk_rgb(95,95,95);\n        ctx.style.selectable.text_pressed_active = nk_rgb(95,95,95);\n\n        /* slider */\n        ctx.style.slider.normal          = nk_style_item_hide();\n        ctx.style.slider.hover           = nk_style_item_hide();\n        ctx.style.slider.active          = nk_style_item_hide();\n        ctx.style.slider.bar_normal      = nk_rgb(156,156,156);\n        ctx.style.slider.bar_hover       = nk_rgb(156,156,156);\n        ctx.style.slider.bar_active      = nk_rgb(156,156,156);\n        ctx.style.slider.bar_filled      = nk_rgb(156,156,156);\n        ctx.style.slider.cursor_normal   = nk_style_item_image(media.slider);\n        ctx.style.slider.cursor_hover    = nk_style_item_image(media.slider_hover);\n        ctx.style.slider.cursor_active   = nk_style_item_image(media.slider_active);\n        ctx.style.slider.cursor_size     = nk_vec2(16.5f,21);\n        ctx.style.slider.bar_height      = 1;\n\n        /* progressbar */\n        ctx.style.progress.normal = nk_style_item_color(nk_rgb(231,231,231));\n        ctx.style.progress.hover = nk_style_item_color(nk_rgb(231,231,231));\n        ctx.style.progress.active = nk_style_item_color(nk_rgb(231,231,231));\n        ctx.style.progress.cursor_normal = nk_style_item_color(nk_rgb(63,242,93));\n        ctx.style.progress.cursor_hover = nk_style_item_color(nk_rgb(63,242,93));\n        ctx.style.progress.cursor_active = nk_style_item_color(nk_rgb(63,242,93));\n        ctx.style.progress.border_color = nk_rgb(114,116,115);\n        ctx.style.progress.padding = nk_vec2(0,0);\n        ctx.style.progress.border = 2;\n        ctx.style.progress.rounding = 1;\n\n        /* combo */\n        ctx.style.combo.normal = nk_style_item_color(nk_rgb(216,216,216));\n        ctx.style.combo.hover = nk_style_item_color(nk_rgb(216,216,216));\n        ctx.style.combo.active = nk_style_item_color(nk_rgb(216,216,216));\n        ctx.style.combo.border_color = nk_rgb(95,95,95);\n        ctx.style.combo.label_normal = nk_rgb(95,95,95);\n        ctx.style.combo.label_hover = nk_rgb(95,95,95);\n        ctx.style.combo.label_active = nk_rgb(95,95,95);\n        ctx.style.combo.border = 1;\n        ctx.style.combo.rounding = 1;\n\n        /* combo button */\n        ctx.style.combo.button.normal = nk_style_item_color(nk_rgb(216,216,216));\n        ctx.style.combo.button.hover = nk_style_item_color(nk_rgb(216,216,216));\n        ctx.style.combo.button.active = nk_style_item_color(nk_rgb(216,216,216));\n        ctx.style.combo.button.text_background = nk_rgb(216,216,216);\n        ctx.style.combo.button.text_normal = nk_rgb(95,95,95);\n        ctx.style.combo.button.text_hover = nk_rgb(95,95,95);\n        ctx.style.combo.button.text_active = nk_rgb(95,95,95);\n\n        /* property */\n        ctx.style.property.normal = nk_style_item_color(nk_rgb(216,216,216));\n        ctx.style.property.hover = nk_style_item_color(nk_rgb(216,216,216));\n        ctx.style.property.active = nk_style_item_color(nk_rgb(216,216,216));\n        ctx.style.property.border_color = nk_rgb(81,81,81);\n        ctx.style.property.label_normal = nk_rgb(95,95,95);\n        ctx.style.property.label_hover = nk_rgb(95,95,95);\n        ctx.style.property.label_active = nk_rgb(95,95,95);\n        ctx.style.property.sym_left = NK_SYMBOL_TRIANGLE_LEFT;\n        ctx.style.property.sym_right = NK_SYMBOL_TRIANGLE_RIGHT;\n        ctx.style.property.rounding = 10;\n        ctx.style.property.border = 1;\n\n        /* edit */\n        ctx.style.edit.normal = nk_style_item_color(nk_rgb(240,240,240));\n        ctx.style.edit.hover = nk_style_item_color(nk_rgb(240,240,240));\n        ctx.style.edit.active = nk_style_item_color(nk_rgb(240,240,240));\n        ctx.style.edit.border_color = nk_rgb(62,62,62);\n        ctx.style.edit.cursor_normal = nk_rgb(99,202,255);\n        ctx.style.edit.cursor_hover = nk_rgb(99,202,255);\n        ctx.style.edit.cursor_text_normal = nk_rgb(95,95,95);\n        ctx.style.edit.cursor_text_hover = nk_rgb(95,95,95);\n        ctx.style.edit.text_normal = nk_rgb(95,95,95);\n        ctx.style.edit.text_hover = nk_rgb(95,95,95);\n        ctx.style.edit.text_active = nk_rgb(95,95,95);\n        ctx.style.edit.selected_normal = nk_rgb(99,202,255);\n        ctx.style.edit.selected_hover = nk_rgb(99,202,255);\n        ctx.style.edit.selected_text_normal = nk_rgb(95,95,95);\n        ctx.style.edit.selected_text_hover = nk_rgb(95,95,95);\n        ctx.style.edit.border = 1;\n        ctx.style.edit.rounding = 2;\n\n        /* property buttons */\n        ctx.style.property.dec_button.normal = nk_style_item_color(nk_rgb(216,216,216));\n        ctx.style.property.dec_button.hover = nk_style_item_color(nk_rgb(216,216,216));\n        ctx.style.property.dec_button.active = nk_style_item_color(nk_rgb(216,216,216));\n        ctx.style.property.dec_button.text_background = nk_rgba(0,0,0,0);\n        ctx.style.property.dec_button.text_normal = nk_rgb(95,95,95);\n        ctx.style.property.dec_button.text_hover = nk_rgb(95,95,95);\n        ctx.style.property.dec_button.text_active = nk_rgb(95,95,95);\n        ctx.style.property.inc_button = ctx.style.property.dec_button;\n\n        /* property edit */\n        ctx.style.property.edit.normal = nk_style_item_color(nk_rgb(216,216,216));\n        ctx.style.property.edit.hover = nk_style_item_color(nk_rgb(216,216,216));\n        ctx.style.property.edit.active = nk_style_item_color(nk_rgb(216,216,216));\n        ctx.style.property.edit.border_color = nk_rgba(0,0,0,0);\n        ctx.style.property.edit.cursor_normal = nk_rgb(95,95,95);\n        ctx.style.property.edit.cursor_hover = nk_rgb(95,95,95);\n        ctx.style.property.edit.cursor_text_normal = nk_rgb(216,216,216);\n        ctx.style.property.edit.cursor_text_hover = nk_rgb(216,216,216);\n        ctx.style.property.edit.text_normal = nk_rgb(95,95,95);\n        ctx.style.property.edit.text_hover = nk_rgb(95,95,95);\n        ctx.style.property.edit.text_active = nk_rgb(95,95,95);\n        ctx.style.property.edit.selected_normal = nk_rgb(95,95,95);\n        ctx.style.property.edit.selected_hover = nk_rgb(95,95,95);\n        ctx.style.property.edit.selected_text_normal = nk_rgb(216,216,216);\n        ctx.style.property.edit.selected_text_hover = nk_rgb(216,216,216);\n\n        /* chart */\n        ctx.style.chart.background = nk_style_item_color(nk_rgb(216,216,216));\n        ctx.style.chart.border_color = nk_rgb(81,81,81);\n        ctx.style.chart.color = nk_rgb(95,95,95);\n        ctx.style.chart.selected_color = nk_rgb(255,0,0);\n        ctx.style.chart.border = 1;\n    }\n\n    while (!glfwWindowShouldClose(win))\n    {\n        /* High DPI displays */\n        struct nk_vec2 scale;\n        glfwGetWindowSize(win, &width, &height);\n        glfwGetFramebufferSize(win, &display_width, &display_height);\n        scale.x = (float)display_width/(float)width;\n        scale.y = (float)display_height/(float)height;\n\n        /* Input */\n        {double x, y;\n        nk_input_begin(&ctx);\n        glfwPollEvents();\n        nk_input_key(&ctx, NK_KEY_DEL, glfwGetKey(win, GLFW_KEY_DELETE) == GLFW_PRESS);\n        nk_input_key(&ctx, NK_KEY_ENTER, glfwGetKey(win, GLFW_KEY_ENTER) == GLFW_PRESS);\n        nk_input_key(&ctx, NK_KEY_TAB, glfwGetKey(win, GLFW_KEY_TAB) == GLFW_PRESS);\n        nk_input_key(&ctx, NK_KEY_BACKSPACE, glfwGetKey(win, GLFW_KEY_BACKSPACE) == GLFW_PRESS);\n        nk_input_key(&ctx, NK_KEY_LEFT, glfwGetKey(win, GLFW_KEY_LEFT) == GLFW_PRESS);\n        nk_input_key(&ctx, NK_KEY_RIGHT, glfwGetKey(win, GLFW_KEY_RIGHT) == GLFW_PRESS);\n        nk_input_key(&ctx, NK_KEY_UP, glfwGetKey(win, GLFW_KEY_UP) == GLFW_PRESS);\n        nk_input_key(&ctx, NK_KEY_DOWN, glfwGetKey(win, GLFW_KEY_DOWN) == GLFW_PRESS);\n        if (glfwGetKey(win, GLFW_KEY_LEFT_CONTROL) == GLFW_PRESS ||\n            glfwGetKey(win, GLFW_KEY_RIGHT_CONTROL) == GLFW_PRESS) {\n            nk_input_key(&ctx, NK_KEY_COPY, glfwGetKey(win, GLFW_KEY_C) == GLFW_PRESS);\n            nk_input_key(&ctx, NK_KEY_PASTE, glfwGetKey(win, GLFW_KEY_P) == GLFW_PRESS);\n            nk_input_key(&ctx, NK_KEY_CUT, glfwGetKey(win, GLFW_KEY_X) == GLFW_PRESS);\n            nk_input_key(&ctx, NK_KEY_CUT, glfwGetKey(win, GLFW_KEY_E) == GLFW_PRESS);\n            nk_input_key(&ctx, NK_KEY_SHIFT, 1);\n        } else {\n            nk_input_key(&ctx, NK_KEY_COPY, 0);\n            nk_input_key(&ctx, NK_KEY_PASTE, 0);\n            nk_input_key(&ctx, NK_KEY_CUT, 0);\n            nk_input_key(&ctx, NK_KEY_SHIFT, 0);\n        }\n        glfwGetCursorPos(win, &x, &y);\n        nk_input_motion(&ctx, (int)x, (int)y);\n        nk_input_button(&ctx, NK_BUTTON_LEFT, (int)x, (int)y, glfwGetMouseButton(win, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS);\n        nk_input_button(&ctx, NK_BUTTON_MIDDLE, (int)x, (int)y, glfwGetMouseButton(win, GLFW_MOUSE_BUTTON_MIDDLE) == GLFW_PRESS);\n        nk_input_button(&ctx, NK_BUTTON_RIGHT, (int)x, (int)y, glfwGetMouseButton(win, GLFW_MOUSE_BUTTON_RIGHT) == GLFW_PRESS);\n        nk_input_end(&ctx);}\n\n        /* GUI */\n        {struct nk_panel layout, tab;\n        if (nk_begin(&ctx, \"Demo\", nk_rect(50, 50, 300, 400),\n            NK_WINDOW_BORDER|NK_WINDOW_MOVABLE|NK_WINDOW_TITLE))\n        {\n            int i;\n            float id;\n            static int slider = 10;\n            static int field_len;\n            static nk_size prog_value = 60;\n            static int current_weapon = 0;\n            static char field_buffer[64];\n            static float pos;\n            static const char *weapons[] = {\"Fist\",\"Pistol\",\"Shotgun\",\"Plasma\",\"BFG\"};\n            const float step = (2*3.141592654f) / 32;\n\n            nk_layout_row_static(&ctx, 30, 120, 1);\n            if (nk_button_label(&ctx, \"button\"))\n                fprintf(stdout, \"button pressed\\n\");\n\n            nk_layout_row_dynamic(&ctx, 20, 1);\n            nk_label(&ctx, \"Label\", NK_TEXT_LEFT);\n            nk_layout_row_dynamic(&ctx, 30, 2);\n            nk_check_label(&ctx, \"inactive\", 0);\n            nk_check_label(&ctx, \"active\", 1);\n            nk_option_label(&ctx, \"active\", 1);\n            nk_option_label(&ctx, \"inactive\", 0);\n\n            nk_layout_row_dynamic(&ctx, 30, 1);\n            nk_slider_int(&ctx, 0, &slider, 16, 1);\n            nk_layout_row_dynamic(&ctx, 20, 1);\n            nk_progress(&ctx, &prog_value, 100, NK_MODIFIABLE);\n\n            nk_layout_row_dynamic(&ctx, 25, 1);\n            nk_edit_string(&ctx, NK_EDIT_FIELD, field_buffer, &field_len, 64, nk_filter_default);\n            nk_property_float(&ctx, \"#X:\", -1024.0f, &pos, 1024.0f, 1, 1);\n            current_weapon = nk_combo(&ctx, weapons, LEN(weapons), current_weapon, 25, nk_vec2(nk_widget_width(&ctx),200));\n\n            nk_layout_row_dynamic(&ctx, 100, 1);\n            if (nk_chart_begin_colored(&ctx, NK_CHART_LINES, nk_rgb(255,0,0), nk_rgb(150,0,0), 32, 0.0f, 1.0f)) {\n                nk_chart_add_slot_colored(&ctx, NK_CHART_LINES, nk_rgb(0,0,255), nk_rgb(0,0,150),32, -1.0f, 1.0f);\n                nk_chart_add_slot_colored(&ctx, NK_CHART_LINES, nk_rgb(0,255,0), nk_rgb(0,150,0), 32, -1.0f, 1.0f);\n                for (id = 0, i = 0; i < 32; ++i) {\n                    nk_chart_push_slot(&ctx, (float)fabs(sin(id)), 0);\n                    nk_chart_push_slot(&ctx, (float)cos(id), 1);\n                    nk_chart_push_slot(&ctx, (float)sin(id), 2);\n                    id += step;\n                }\n            }\n            nk_chart_end(&ctx);\n\n            nk_layout_row_dynamic(&ctx, 250, 1);\n            if (nk_group_begin(&ctx, \"Standard\", NK_WINDOW_BORDER|NK_WINDOW_BORDER))\n            {\n                if (nk_tree_push(&ctx, NK_TREE_NODE, \"Window\", NK_MAXIMIZED)) {\n                    static int selected[8];\n                    if (nk_tree_push(&ctx, NK_TREE_NODE, \"Next\", NK_MAXIMIZED)) {\n                        nk_layout_row_dynamic(&ctx, 20, 1);\n                        for (i = 0; i < 4; ++i)\n                            nk_selectable_label(&ctx, (selected[i]) ? \"Selected\": \"Unselected\", NK_TEXT_LEFT, &selected[i]);\n                        nk_tree_pop(&ctx);\n                    }\n                    if (nk_tree_push(&ctx, NK_TREE_NODE, \"Previous\", NK_MAXIMIZED)) {\n                        nk_layout_row_dynamic(&ctx, 20, 1);\n                        for (i = 4; i < 8; ++i)\n                            nk_selectable_label(&ctx, (selected[i]) ? \"Selected\": \"Unselected\", NK_TEXT_LEFT, &selected[i]);\n                        nk_tree_pop(&ctx);\n                    }\n                    nk_tree_pop(&ctx);\n                }\n                nk_group_end(&ctx);\n            }\n        }\n        nk_end(&ctx);}\n\n        /* Draw */\n        glViewport(0, 0, display_width, display_height);\n        glClear(GL_COLOR_BUFFER_BIT);\n        glClearColor(0.5882, 0.6666, 0.6666, 1.0f);\n        device_draw(&device, &ctx, width, height, scale, NK_ANTI_ALIASING_ON);\n        glfwSwapBuffers(win);\n    }\n    glDeleteTextures(1,(const GLuint*)&media.skin);\n    nk_font_atlas_clear(&atlas);\n    nk_free(&ctx);\n    device_shutdown(&device);\n    glfwTerminate();\n    return 0;\n}", "path": "Nuklear/example/skinning.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "Immediate-Mode-UI/Nuklear", "stars": 8350, "license": "None", "language": "c", "size": 10284}
{"docstring": "/* ===============================================================\n *\n *                              SELECTABLE\n *\n * ===============================================================*/\n", "func_signal": "NK_LIB void\nnk_draw_selectable(struct nk_command_buffer *out,\n    nk_flags state, const struct nk_style_selectable *style, nk_bool active,\n    const struct nk_rect *bounds,\n    const struct nk_rect *icon, const struct nk_image *img, enum nk_symbol_type sym,\n    const char *string, int len, nk_flags align, const struct nk_user_font *font)", "code": "{\n    const struct nk_style_item *background;\n    struct nk_text text;\n    text.padding = style->padding;\n\n    /* select correct colors/images */\n    if (!active) {\n        if (state & NK_WIDGET_STATE_ACTIVED) {\n            background = &style->pressed;\n            text.text = style->text_pressed;\n        } else if (state & NK_WIDGET_STATE_HOVER) {\n            background = &style->hover;\n            text.text = style->text_hover;\n        } else {\n            background = &style->normal;\n            text.text = style->text_normal;\n        }\n    } else {\n        if (state & NK_WIDGET_STATE_ACTIVED) {\n            background = &style->pressed_active;\n            text.text = style->text_pressed_active;\n        } else if (state & NK_WIDGET_STATE_HOVER) {\n            background = &style->hover_active;\n            text.text = style->text_hover_active;\n        } else {\n            background = &style->normal_active;\n            text.text = style->text_normal_active;\n        }\n    }\n    /* draw selectable background and text */\n    if (background->type == NK_STYLE_ITEM_IMAGE) {\n        nk_draw_image(out, *bounds, &background->data.image, nk_white);\n        text.background = nk_rgba(0,0,0,0);\n    } else {\n        nk_fill_rect(out, *bounds, style->rounding, background->data.color);\n        text.background = background->data.color;\n    }\n    if (icon) {\n        if (img) nk_draw_image(out, *icon, img, nk_white);\n        else nk_draw_symbol(out, sym, *icon, text.background, text.text, 1, font);\n    }\n    nk_widget_text(out, *bounds, string, len, &text, align, font);\n}", "path": "Nuklear/src/nuklear_selectable.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "Immediate-Mode-UI/Nuklear", "stars": 8350, "license": "None", "language": "c", "size": 10284}
{"docstring": "/* ===============================================================\n *\n *                          EDIT\n *\n * ===============================================================*/\n", "func_signal": "NK_LIB void\nnk_edit_draw_text(struct nk_command_buffer *out,\n    const struct nk_style_edit *style, float pos_x, float pos_y,\n    float x_offset, const char *text, int byte_len, float row_height,\n    const struct nk_user_font *font, struct nk_color background,\n    struct nk_color foreground, nk_bool is_selected)", "code": "{\n    NK_ASSERT(out);\n    NK_ASSERT(font);\n    NK_ASSERT(style);\n    if (!text || !byte_len || !out || !style) return;\n\n    {int glyph_len = 0;\n    nk_rune unicode = 0;\n    int text_len = 0;\n    float line_width = 0;\n    float glyph_width;\n    const char *line = text;\n    float line_offset = 0;\n    int line_count = 0;\n\n    struct nk_text txt;\n    txt.padding = nk_vec2(0,0);\n    txt.background = background;\n    txt.text = foreground;\n\n    glyph_len = nk_utf_decode(text+text_len, &unicode, byte_len-text_len);\n    if (!glyph_len) return;\n    while ((text_len < byte_len) && glyph_len)\n    {\n        if (unicode == '\\n') {\n            /* new line separator so draw previous line */\n            struct nk_rect label;\n            label.y = pos_y + line_offset;\n            label.h = row_height;\n            label.w = line_width;\n            label.x = pos_x;\n            if (!line_count)\n                label.x += x_offset;\n\n            if (is_selected) /* selection needs to draw different background color */\n                nk_fill_rect(out, label, 0, background);\n            nk_widget_text(out, label, line, (int)((text + text_len) - line),\n                &txt, NK_TEXT_CENTERED, font);\n\n            text_len++;\n            line_count++;\n            line_width = 0;\n            line = text + text_len;\n            line_offset += row_height;\n            glyph_len = nk_utf_decode(text + text_len, &unicode, (int)(byte_len-text_len));\n            continue;\n        }\n        if (unicode == '\\r') {\n            text_len++;\n            glyph_len = nk_utf_decode(text + text_len, &unicode, byte_len-text_len);\n            continue;\n        }\n        glyph_width = font->width(font->userdata, font->height, text+text_len, glyph_len);\n        line_width += (float)glyph_width;\n        text_len += glyph_len;\n        glyph_len = nk_utf_decode(text + text_len, &unicode, byte_len-text_len);\n        continue;\n    }\n    if (line_width > 0) {\n        /* draw last line */\n        struct nk_rect label;\n        label.y = pos_y + line_offset;\n        label.h = row_height;\n        label.w = line_width;\n        label.x = pos_x;\n        if (!line_count)\n            label.x += x_offset;\n\n        if (is_selected)\n            nk_fill_rect(out, label, 0, background);\n        nk_widget_text(out, label, line, (int)((text + text_len) - line),\n            &txt, NK_TEXT_LEFT, font);\n    }}\n}", "path": "Nuklear/src/nuklear_edit.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "Immediate-Mode-UI/Nuklear", "stars": 8350, "license": "None", "language": "c", "size": 10284}
{"docstring": "/* ===============================================================\n *\n *                          LAYOUT\n *\n * ===============================================================*/\n", "func_signal": "NK_API void\nnk_layout_set_min_row_height(struct nk_context *ctx, float height)", "code": "{\n    struct nk_window *win;\n    struct nk_panel *layout;\n\n    NK_ASSERT(ctx);\n    NK_ASSERT(ctx->current);\n    NK_ASSERT(ctx->current->layout);\n    if (!ctx || !ctx->current || !ctx->current->layout)\n        return;\n\n    win = ctx->current;\n    layout = win->layout;\n    layout->row.min_height = height;\n}", "path": "Nuklear/src/nuklear_layout.c", "commit_date": "2020-04-09 00:00:00", "repo_name": "Immediate-Mode-UI/Nuklear", "stars": 8350, "license": "None", "language": "c", "size": 10284}
{"docstring": "/* ===============================================================\n *\n *                              SCROLLBAR\n *\n * ===============================================================*/\n", "func_signal": "NK_LIB float\nnk_scrollbar_behavior(nk_flags *state, struct nk_input *in,\n    int has_scrolling, const struct nk_rect *scroll,\n    const struct nk_rect *cursor, const struct nk_rect *empty0,\n    const struct nk_rect *empty1, float scroll_offset,\n    float target, float scroll_step, enum nk_orientation o)", "code": "{\n    nk_flags ws = 0;\n    int left_mouse_down;\n    int left_mouse_clicked;\n    int left_mouse_click_in_cursor;\n    float scroll_delta;\n\n    nk_widget_state_reset(state);\n    if (!in) return scroll_offset;\n\n    left_mouse_down = in->mouse.buttons[NK_BUTTON_LEFT].down;\n    left_mouse_clicked = in->mouse.buttons[NK_BUTTON_LEFT].clicked;\n    left_mouse_click_in_cursor = nk_input_has_mouse_click_down_in_rect(in,\n        NK_BUTTON_LEFT, *cursor, nk_true);\n    if (nk_input_is_mouse_hovering_rect(in, *scroll))\n        *state = NK_WIDGET_STATE_HOVERED;\n\n    scroll_delta = (o == NK_VERTICAL) ? in->mouse.scroll_delta.y: in->mouse.scroll_delta.x;\n    if (left_mouse_down && left_mouse_click_in_cursor && !left_mouse_clicked) {\n        /* update cursor by mouse dragging */\n        float pixel, delta;\n        *state = NK_WIDGET_STATE_ACTIVE;\n        if (o == NK_VERTICAL) {\n            float cursor_y;\n            pixel = in->mouse.delta.y;\n            delta = (pixel / scroll->h) * target;\n            scroll_offset = NK_CLAMP(0, scroll_offset + delta, target - scroll->h);\n            cursor_y = scroll->y + ((scroll_offset/target) * scroll->h);\n            in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.y = cursor_y + cursor->h/2.0f;\n        } else {\n            float cursor_x;\n            pixel = in->mouse.delta.x;\n            delta = (pixel / scroll->w) * target;\n            scroll_offset = NK_CLAMP(0, scroll_offset + delta, target - scroll->w);\n            cursor_x = scroll->x + ((scroll_offset/target) * scroll->w);\n            in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x = cursor_x + cursor->w/2.0f;\n        }\n    } else if ((nk_input_is_key_pressed(in, NK_KEY_SCROLL_UP) && o == NK_VERTICAL && has_scrolling)||\n            nk_button_behavior(&ws, *empty0, in, NK_BUTTON_DEFAULT)) {\n        /* scroll page up by click on empty space or shortcut */\n        if (o == NK_VERTICAL)\n            scroll_offset = NK_MAX(0, scroll_offset - scroll->h);\n        else scroll_offset = NK_MAX(0, scroll_offset - scroll->w);\n    } else if ((nk_input_is_key_pressed(in, NK_KEY_SCROLL_DOWN) && o == NK_VERTICAL && has_scrolling) ||\n        nk_button_behavior(&ws, *empty1, in, NK_BUTTON_DEFAULT)) {\n        /* scroll page down by click on empty space or shortcut */\n        if (o == NK_VERTICAL)\n            scroll_offset = NK_MIN(scroll_offset + scroll->h, target - scroll->h);\n        else scroll_offset = NK_MIN(scroll_offset + scroll->w, target - scroll->w);\n    } else if (has_scrolling) {\n        if ((scroll_delta < 0 || (scroll_delta > 0))) {\n            /* update cursor by mouse scrolling */\n            scroll_offset = scroll_offset + scroll_step * (-scroll_delta);\n            if (o == NK_VERTICAL)\n                scroll_offset = NK_CLAMP(0, scroll_offset, target - scroll->h);\n            else scroll_offset = NK_CLAMP(0, scroll_offset, target - scroll->w);\n        } else if (nk_input_is_key_pressed(in, NK_KEY_SCROLL_START)) {\n            /* update cursor to the beginning  */\n            if (o == NK_VERTICAL) scroll_offset = 0;\n        } else if (nk_input_is_key_pressed(in, NK_KEY_SCROLL_END)) {\n            /* update cursor to the end */\n            if (o == NK_VERTICAL) scroll_offset = target - scroll->h;\n        }\n    }\n    if (*state & NK_WIDGET_STATE_HOVER && !nk_input_is_mouse_prev_hovering_rect(in, *scroll))\n        *state |= NK_WIDGET_STATE_ENTERED;\n    else if (nk_input_is_mouse_prev_hovering_rect(in, *scroll))\n        *state |= NK_WIDGET_STATE_LEFT;\n    return scroll_offset;\n}", "path": "Nuklear/src/nuklear_scrollbar.c", "commit_date": "2018-08-26 00:00:00", "repo_name": "Immediate-Mode-UI/Nuklear", "stars": 8350, "license": "None", "language": "c", "size": 10284}
{"docstring": "/* -------------------------------------------------------------\n *\n *                          FONT ATLAS\n *\n * --------------------------------------------------------------*/\n", "func_signal": "NK_API struct nk_font_config\nnk_font_config(float pixel_height)", "code": "{\n    struct nk_font_config cfg;\n    nk_zero_struct(cfg);\n    cfg.ttf_blob = 0;\n    cfg.ttf_size = 0;\n    cfg.ttf_data_owned_by_atlas = 0;\n    cfg.size = pixel_height;\n    cfg.oversample_h = 3;\n    cfg.oversample_v = 1;\n    cfg.pixel_snap = 0;\n    cfg.coord_type = NK_COORD_UV;\n    cfg.spacing = nk_vec2(0,0);\n    cfg.range = nk_font_default_glyph_ranges();\n    cfg.merge_mode = 0;\n    cfg.fallback_glyph = '?';\n    cfg.font = 0;\n    cfg.n = 0;\n    return cfg;\n}", "path": "Nuklear/src/nuklear_font.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "Immediate-Mode-UI/Nuklear", "stars": 8350, "license": "None", "language": "c", "size": 10284}
{"docstring": "/* ===============================================================\n *\n *                          FILTER\n *\n * ===============================================================*/\n", "func_signal": "NK_API nk_bool\nnk_filter_default(const struct nk_text_edit *box, nk_rune unicode)", "code": "{\n    NK_UNUSED(unicode);\n    NK_UNUSED(box);\n    return nk_true;\n}", "path": "Nuklear/src/nuklear_edit.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "Immediate-Mode-UI/Nuklear", "stars": 8350, "license": "None", "language": "c", "size": 10284}
{"docstring": "/* ===============================================================\n *\n *                          DEMO\n *\n * ===============================================================*/\n", "func_signal": "static LRESULT CALLBACK\nWindowProc(HWND wnd, UINT msg, WPARAM wparam, LPARAM lparam)", "code": "{\n    switch (msg) {\n    case WM_DESTROY:\n        PostQuitMessage(0);\n        return 0;\n    }\n    if (nk_gdip_handle_event(wnd, msg, wparam, lparam))\n        return 0;\n    return DefWindowProcW(wnd, msg, wparam, lparam);\n}", "path": "Nuklear/demo/gdip/main.c", "commit_date": "2018-01-01 00:00:00", "repo_name": "Immediate-Mode-UI/Nuklear", "stars": 8350, "license": "None", "language": "c", "size": 10284}
{"docstring": "/* glfw callbacks (I don't know if there is a easier way to access text and scroll )*/\n", "func_signal": "static void error_callback(int e, const char *d)", "code": "{printf(\"Error %d: %s\\n\", e, d);}\nstatic void text_input(GLFWwindow *win, unsigned int codepoint)\n{nk_input_unicode((struct nk_context*)glfwGetWindowUserPointer(win), codepoint);}\nstatic void scroll_input(GLFWwindow *win, double _, double yoff)\n{UNUSED(_);nk_input_scroll((struct nk_context*)glfwGetWindowUserPointer(win), nk_vec2(0, (float)yoff));}\n\nstatic void\npump_input(struct nk_context *ctx, GLFWwindow *win)\n{\n    double x, y;\n    nk_input_begin(ctx);\n    glfwPollEvents();\n\n    nk_input_key(ctx, NK_KEY_DEL, glfwGetKey(win, GLFW_KEY_DELETE) == GLFW_PRESS);\n    nk_input_key(ctx, NK_KEY_ENTER, glfwGetKey(win, GLFW_KEY_ENTER) == GLFW_PRESS);\n    nk_input_key(ctx, NK_KEY_TAB, glfwGetKey(win, GLFW_KEY_TAB) == GLFW_PRESS);\n    nk_input_key(ctx, NK_KEY_BACKSPACE, glfwGetKey(win, GLFW_KEY_BACKSPACE) == GLFW_PRESS);\n    nk_input_key(ctx, NK_KEY_LEFT, glfwGetKey(win, GLFW_KEY_LEFT) == GLFW_PRESS);\n    nk_input_key(ctx, NK_KEY_RIGHT, glfwGetKey(win, GLFW_KEY_RIGHT) == GLFW_PRESS);\n    nk_input_key(ctx, NK_KEY_UP, glfwGetKey(win, GLFW_KEY_UP) == GLFW_PRESS);\n    nk_input_key(ctx, NK_KEY_DOWN, glfwGetKey(win, GLFW_KEY_DOWN) == GLFW_PRESS);\n\n    if (glfwGetKey(win, GLFW_KEY_LEFT_CONTROL) == GLFW_PRESS ||\n        glfwGetKey(win, GLFW_KEY_RIGHT_CONTROL) == GLFW_PRESS) {\n        nk_input_key(ctx, NK_KEY_COPY, glfwGetKey(win, GLFW_KEY_C) == GLFW_PRESS);\n        nk_input_key(ctx, NK_KEY_PASTE, glfwGetKey(win, GLFW_KEY_P) == GLFW_PRESS);\n        nk_input_key(ctx, NK_KEY_CUT, glfwGetKey(win, GLFW_KEY_X) == GLFW_PRESS);\n        nk_input_key(ctx, NK_KEY_CUT, glfwGetKey(win, GLFW_KEY_E) == GLFW_PRESS);\n        nk_input_key(ctx, NK_KEY_SHIFT, 1);\n    } else {\n        nk_input_key(ctx, NK_KEY_COPY, 0);\n        nk_input_key(ctx, NK_KEY_PASTE, 0);\n        nk_input_key(ctx, NK_KEY_CUT, 0);\n        nk_input_key(ctx, NK_KEY_SHIFT, 0);\n    }\n\n    glfwGetCursorPos(win, &x, &y);\n    nk_input_motion(ctx, (int)x, (int)y);\n    nk_input_button(ctx, NK_BUTTON_LEFT, (int)x, (int)y, glfwGetMouseButton(win, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS);\n    nk_input_button(ctx, NK_BUTTON_MIDDLE, (int)x, (int)y, glfwGetMouseButton(win, GLFW_MOUSE_BUTTON_MIDDLE) == GLFW_PRESS);\n    nk_input_button(ctx, NK_BUTTON_RIGHT, (int)x, (int)y, glfwGetMouseButton(win, GLFW_MOUSE_BUTTON_RIGHT) == GLFW_PRESS);\n    nk_input_end(ctx);\n}", "path": "Nuklear/example/canvas.c", "commit_date": "2020-04-11 00:00:00", "repo_name": "Immediate-Mode-UI/Nuklear", "stars": 8350, "license": "None", "language": "c", "size": 10284}
{"docstring": "/* ==============================================================\n *\n *                          DRAW\n *\n * ===============================================================*/\n", "func_signal": "NK_LIB void\nnk_command_buffer_init(struct nk_command_buffer *cb,\n    struct nk_buffer *b, enum nk_command_clipping clip)", "code": "{\n    NK_ASSERT(cb);\n    NK_ASSERT(b);\n    if (!cb || !b) return;\n    cb->base = b;\n    cb->use_clipping = (int)clip;\n    cb->begin = b->allocated;\n    cb->end = b->allocated;\n    cb->last = b->allocated;\n}", "path": "Nuklear/src/nuklear_draw.c", "commit_date": "2018-04-02 00:00:00", "repo_name": "Immediate-Mode-UI/Nuklear", "stars": 8350, "license": "None", "language": "c", "size": 10284}
{"docstring": "/* ===============================================================\n *\n *                          LIST VIEW\n *\n * ===============================================================*/\n", "func_signal": "NK_API nk_bool\nnk_list_view_begin(struct nk_context *ctx, struct nk_list_view *view,\n    const char *title, nk_flags flags, int row_height, int row_count)", "code": "{\n    int title_len;\n    nk_hash title_hash;\n    nk_uint *x_offset;\n    nk_uint *y_offset;\n\n    int result;\n    struct nk_window *win;\n    struct nk_panel *layout;\n    const struct nk_style *style;\n    struct nk_vec2 item_spacing;\n\n    NK_ASSERT(ctx);\n    NK_ASSERT(view);\n    NK_ASSERT(title);\n    if (!ctx || !view || !title) return 0;\n\n    win = ctx->current;\n    style = &ctx->style;\n    item_spacing = style->window.spacing;\n    row_height += NK_MAX(0, (int)item_spacing.y);\n\n    /* find persistent list view scrollbar offset */\n    title_len = (int)nk_strlen(title);\n    title_hash = nk_murmur_hash(title, (int)title_len, NK_PANEL_GROUP);\n    x_offset = nk_find_value(win, title_hash);\n    if (!x_offset) {\n        x_offset = nk_add_value(ctx, win, title_hash, 0);\n        y_offset = nk_add_value(ctx, win, title_hash+1, 0);\n\n        NK_ASSERT(x_offset);\n        NK_ASSERT(y_offset);\n        if (!x_offset || !y_offset) return 0;\n        *x_offset = *y_offset = 0;\n    } else y_offset = nk_find_value(win, title_hash+1);\n    view->scroll_value = *y_offset;\n    view->scroll_pointer = y_offset;\n\n    *y_offset = 0;\n    result = nk_group_scrolled_offset_begin(ctx, x_offset, y_offset, title, flags);\n    win = ctx->current;\n    layout = win->layout;\n\n    view->total_height = row_height * NK_MAX(row_count,1);\n    view->begin = (int)NK_MAX(((float)view->scroll_value / (float)row_height), 0.0f);\n    view->count = (int)NK_MAX(nk_iceilf((layout->clip.h)/(float)row_height),0);\n    view->count = NK_MIN(view->count, row_count - view->begin);\n    view->end = view->begin + view->count;\n    view->ctx = ctx;\n    return result;\n}", "path": "Nuklear/src/nuklear_list_view.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "Immediate-Mode-UI/Nuklear", "stars": 8350, "license": "None", "language": "c", "size": 10284}
{"docstring": "/* ===============================================================\n *\n *                              STYLE\n *\n * ===============================================================*/\n", "func_signal": "NK_API void nk_style_default(struct nk_context *ctx)", "code": "{nk_style_from_table(ctx, 0);}\n#define NK_COLOR_MAP(NK_COLOR)\\\n    NK_COLOR(NK_COLOR_TEXT,                     175,175,175,255) \\\n    NK_COLOR(NK_COLOR_WINDOW,                   45, 45, 45, 255) \\\n    NK_COLOR(NK_COLOR_HEADER,                   40, 40, 40, 255) \\\n    NK_COLOR(NK_COLOR_BORDER,                   65, 65, 65, 255) \\\n    NK_COLOR(NK_COLOR_BUTTON,                   50, 50, 50, 255) \\\n    NK_COLOR(NK_COLOR_BUTTON_HOVER,             40, 40, 40, 255) \\\n    NK_COLOR(NK_COLOR_BUTTON_ACTIVE,            35, 35, 35, 255) \\\n    NK_COLOR(NK_COLOR_TOGGLE,                   100,100,100,255) \\\n    NK_COLOR(NK_COLOR_TOGGLE_HOVER,             120,120,120,255) \\\n    NK_COLOR(NK_COLOR_TOGGLE_CURSOR,            45, 45, 45, 255) \\\n    NK_COLOR(NK_COLOR_SELECT,                   45, 45, 45, 255) \\\n    NK_COLOR(NK_COLOR_SELECT_ACTIVE,            35, 35, 35,255) \\\n    NK_COLOR(NK_COLOR_SLIDER,                   38, 38, 38, 255) \\\n    NK_COLOR(NK_COLOR_SLIDER_CURSOR,            100,100,100,255) \\\n    NK_COLOR(NK_COLOR_SLIDER_CURSOR_HOVER,      120,120,120,255) \\\n    NK_COLOR(NK_COLOR_SLIDER_CURSOR_ACTIVE,     150,150,150,255) \\\n    NK_COLOR(NK_COLOR_PROPERTY,                 38, 38, 38, 255) \\\n    NK_COLOR(NK_COLOR_EDIT,                     38, 38, 38, 255)  \\\n    NK_COLOR(NK_COLOR_EDIT_CURSOR,              175,175,175,255) \\\n    NK_COLOR(NK_COLOR_COMBO,                    45, 45, 45, 255) \\\n    NK_COLOR(NK_COLOR_CHART,                    120,120,120,255) \\\n    NK_COLOR(NK_COLOR_CHART_COLOR,              45, 45, 45, 255) \\\n    NK_COLOR(NK_COLOR_CHART_COLOR_HIGHLIGHT,    255, 0,  0, 255) \\\n    NK_COLOR(NK_COLOR_SCROLLBAR,                40, 40, 40, 255) \\\n    NK_COLOR(NK_COLOR_SCROLLBAR_CURSOR,         100,100,100,255) \\\n    NK_COLOR(NK_COLOR_SCROLLBAR_CURSOR_HOVER,   120,120,120,255) \\\n    NK_COLOR(NK_COLOR_SCROLLBAR_CURSOR_ACTIVE,  150,150,150,255) \\\n    NK_COLOR(NK_COLOR_TAB_HEADER,               40, 40, 40,255)\n\nNK_GLOBAL const struct nk_color\nnk_default_color_style[NK_COLOR_COUNT] = {\n#define NK_COLOR(a,b,c,d,e) {b,c,d,e},\n    NK_COLOR_MAP(NK_COLOR)\n#undef NK_COLOR\n}", "path": "Nuklear/src/nuklear_style.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "Immediate-Mode-UI/Nuklear", "stars": 8350, "license": "None", "language": "c", "size": 10284}
{"docstring": "/* ===============================================================\n *\n *                          PROGRESS\n *\n * ===============================================================*/\n", "func_signal": "NK_LIB nk_size\nnk_progress_behavior(nk_flags *state, struct nk_input *in,\n    struct nk_rect r, struct nk_rect cursor, nk_size max, nk_size value, nk_bool modifiable)", "code": "{\n    int left_mouse_down = 0;\n    int left_mouse_click_in_cursor = 0;\n\n    nk_widget_state_reset(state);\n    if (!in || !modifiable) return value;\n    left_mouse_down = in && in->mouse.buttons[NK_BUTTON_LEFT].down;\n    left_mouse_click_in_cursor = in && nk_input_has_mouse_click_down_in_rect(in,\n            NK_BUTTON_LEFT, cursor, nk_true);\n    if (nk_input_is_mouse_hovering_rect(in, r))\n        *state = NK_WIDGET_STATE_HOVERED;\n\n    if (in && left_mouse_down && left_mouse_click_in_cursor) {\n        if (left_mouse_down && left_mouse_click_in_cursor) {\n            float ratio = NK_MAX(0, (float)(in->mouse.pos.x - cursor.x)) / (float)cursor.w;\n            value = (nk_size)NK_CLAMP(0, (float)max * ratio, (float)max);\n            in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x = cursor.x + cursor.w/2.0f;\n            *state |= NK_WIDGET_STATE_ACTIVE;\n        }\n    }\n    /* set progressbar widget state */\n    if (*state & NK_WIDGET_STATE_HOVER && !nk_input_is_mouse_prev_hovering_rect(in, r))\n        *state |= NK_WIDGET_STATE_ENTERED;\n    else if (nk_input_is_mouse_prev_hovering_rect(in, r))\n        *state |= NK_WIDGET_STATE_LEFT;\n    return value;\n}", "path": "Nuklear/src/nuklear_progress.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "Immediate-Mode-UI/Nuklear", "stars": 8350, "license": "None", "language": "c", "size": 10284}
{"docstring": "/* ===============================================================\n *\n *                          IMAGE\n *\n * ===============================================================*/\n", "func_signal": "NK_API nk_handle\nnk_handle_ptr(void *ptr)", "code": "{\n    nk_handle handle = {0};\n    handle.ptr = ptr;\n    return handle;\n}", "path": "Nuklear/src/nuklear_image.c", "commit_date": "2020-09-04 00:00:00", "repo_name": "Immediate-Mode-UI/Nuklear", "stars": 8350, "license": "None", "language": "c", "size": 10284}
{"docstring": "/*\n** get field and width arguments for field-manipulation functions,\n** checking whether they are valid.\n** ('luaL_error' called without 'return' to avoid later warnings about\n** 'width' being used uninitialized.)\n*/\n", "func_signal": "static int fieldargs (lua_State *L, int farg, int *width)", "code": "{\n  lua_Integer f = luaL_checkinteger(L, farg);\n  lua_Integer w = luaL_optinteger(L, farg + 1, 1);\n  luaL_argcheck(L, 0 <= f, farg, \"field cannot be negative\");\n  luaL_argcheck(L, 0 < w, farg + 1, \"width must be positive\");\n  if (f + w > LUA_NBITS)\n    luaL_error(L, \"trying to access non-existent bits\");\n  *width = (int)w;\n  return (int)f;\n}", "path": "xLua/build/lua-5.3.4/src/lbitlib.c", "commit_date": "2017-09-01 00:00:00", "repo_name": "Tencent/xLua", "stars": 8981, "license": "other", "language": "c", "size": 25476}
{"docstring": "/*\n** Traverses all arguments from 'argv', returning a mask with those\n** needed before running any Lua code (or an error code if it finds\n** any invalid argument). 'first' returns the first not-handled argument\n** (either the script name or a bad argument in case of error).\n*/\n", "func_signal": "static int collectargs (char **argv, int *first)", "code": "{\n  int args = 0;\n  int i;\n  for (i = 1; argv[i] != NULL; i++) {\n    *first = i;\n    if (argv[i][0] != '-')  /* not an option? */\n        return args;  /* stop handling options */\n    switch (argv[i][1]) {  /* else check option */\n      case '-':  /* '--' */\n        if (argv[i][2] != '\\0')  /* extra characters after '--'? */\n          return has_error;  /* invalid option */\n        *first = i + 1;\n        return args;\n      case '\\0':  /* '-' */\n        return args;  /* script \"name\" is '-' */\n      case 'E':\n        if (argv[i][2] != '\\0')  /* extra characters after 1st? */\n          return has_error;  /* invalid option */\n        args |= has_E;\n        break;\n      case 'i':\n        args |= has_i;  /* (-i implies -v) *//* FALLTHROUGH */\n      case 'v':\n        if (argv[i][2] != '\\0')  /* extra characters after 1st? */\n          return has_error;  /* invalid option */\n        args |= has_v;\n        break;\n      case 'e':\n        args |= has_e;  /* FALLTHROUGH */\n      case 'l':  /* both options need an argument */\n        if (argv[i][2] == '\\0') {  /* no concatenated argument? */\n          i++;  /* try next 'argv' */\n          if (argv[i] == NULL || argv[i][0] == '-')\n            return has_error;  /* no next argument or it is another option */\n        }\n        break;\n      default:  /* invalid option */\n        return has_error;\n    }\n  }\n  *first = i;  /* no script name */\n  return args;\n}", "path": "xLua/build/lua-5.3.4/src/lua.c", "commit_date": "2017-09-01 00:00:00", "repo_name": "Tencent/xLua", "stars": 8981, "license": "other", "language": "c", "size": 25476}
{"docstring": "/*\n** Prints an error message, adding the program name in front of it\n** (if present)\n*/\n", "func_signal": "static void l_message (const char *pname, const char *msg)", "code": "{\n  if (pname) lua_writestringerror(\"%s: \", pname);\n  lua_writestringerror(\"%s\\n\", msg);\n}", "path": "xLua/build/lua-5.3.4/src/lua.c", "commit_date": "2017-09-01 00:00:00", "repo_name": "Tencent/xLua", "stars": 8981, "license": "other", "language": "c", "size": 25476}
{"docstring": "/*\n** Prints (calling the Lua 'print' function) any values on the stack\n*/\n", "func_signal": "static void l_print (lua_State *L)", "code": "{\n  int n = lua_gettop(L);\n  if (n > 0) {  /* any result to be printed? */\n    luaL_checkstack(L, LUA_MINSTACK, \"too many results to print\");\n    lua_getglobal(L, \"print\");\n    lua_insert(L, 1);\n    if (lua_pcall(L, n, 0, 0) != LUA_OK)\n      l_message(progname, lua_pushfstring(L, \"error calling 'print' (%s)\",\n                                             lua_tostring(L, -1)));\n  }\n}", "path": "xLua/build/lua-5.3.4/src/lua.c", "commit_date": "2017-09-01 00:00:00", "repo_name": "Tencent/xLua", "stars": 8981, "license": "other", "language": "c", "size": 25476}
{"docstring": "/*\n** Create the 'arg' table, which stores all arguments from the\n** command line ('argv'). It should be aligned so that, at index 0,\n** it has 'argv[script]', which is the script name. The arguments\n** to the script (everything after 'script') go to positive indices;\n** other arguments (before the script name) go to negative indices.\n** If there is no script name, assume interpreter's name as base.\n*/\n", "func_signal": "static void createargtable (lua_State *L, char **argv, int argc, int script)", "code": "{\n  int i, narg;\n  if (script == argc) script = 0;  /* no script name? */\n  narg = argc - (script + 1);  /* number of positive indices */\n  lua_createtable(L, narg, script + 1);\n  for (i = 0; i < argc; i++) {\n    lua_pushstring(L, argv[i]);\n    lua_rawseti(L, -2, i - script);\n  }\n  lua_setglobal(L, \"arg\");\n}", "path": "xLua/build/lua-5.3.4/src/lua.c", "commit_date": "2017-09-01 00:00:00", "repo_name": "Tencent/xLua", "stars": 8981, "license": "other", "language": "c", "size": 25476}
{"docstring": "/*\n** Check whether 'status' signals a syntax error and the error\n** message at the top of the stack ends with the above mark for\n** incomplete statements.\n*/\n", "func_signal": "static int incomplete (lua_State *L, int status)", "code": "{\n  if (status == LUA_ERRSYNTAX) {\n    size_t lmsg;\n    const char *msg = lua_tolstring(L, -1, &lmsg);\n    if (lmsg >= marklen && strcmp(msg + lmsg - marklen, EOFMARK) == 0) {\n      lua_pop(L, 1);\n      return 1;\n    }\n  }\n  return 0;  /* else... */\n}", "path": "xLua/build/lua-5.3.4/src/lua.c", "commit_date": "2017-09-01 00:00:00", "repo_name": "Tencent/xLua", "stars": 8981, "license": "other", "language": "c", "size": 25476}
{"docstring": "/*\n** Check whether 'status' is not OK and, if so, prints the error\n** message on the top of the stack. It assumes that the error object\n** is a string, as it was either generated by Lua or by 'msghandler'.\n*/\n", "func_signal": "static int report (lua_State *L, int status)", "code": "{\n  if (status != LUA_OK) {\n    const char *msg = lua_tostring(L, -1);\n    l_message(progname, msg);\n    lua_pop(L, 1);  /* remove message */\n  }\n  return status;\n}", "path": "xLua/build/lua-5.3.4/src/lua.c", "commit_date": "2017-09-01 00:00:00", "repo_name": "Tencent/xLua", "stars": 8981, "license": "other", "language": "c", "size": 25476}
{"docstring": "/* Allocate a new MCode area. */\n", "func_signal": "static void mcode_allocarea(jit_State *J)", "code": "{\n  MCode *oldarea = J->mcarea;\n  size_t sz = (size_t)J->param[JIT_P_sizemcode] << 10;\n  sz = (sz + LJ_PAGESIZE-1) & ~(size_t)(LJ_PAGESIZE - 1);\n  J->mcarea = (MCode *)mcode_alloc(J, sz);\n  J->szmcarea = sz;\n  J->mcprot = MCPROT_GEN;\n  J->mctop = (MCode *)((char *)J->mcarea + J->szmcarea);\n  J->mcbot = (MCode *)((char *)J->mcarea + sizeof(MCLink));\n  ((MCLink *)J->mcarea)->next = oldarea;\n  ((MCLink *)J->mcarea)->size = sz;\n  J->szallmcarea += sz;\n}", "path": "xLua/build/luajit-2.1.0b3/src/lj_mcode.c", "commit_date": "2018-07-15 00:00:00", "repo_name": "Tencent/xLua", "stars": 8981, "license": "other", "language": "c", "size": 25476}
{"docstring": "/* Reserve the remainder of the current MCode area. */\n", "func_signal": "MCode *lj_mcode_reserve(jit_State *J, MCode **lim)", "code": "{\n  if (!J->mcarea)\n    mcode_allocarea(J);\n  else\n    mcode_protect(J, MCPROT_GEN);\n  *lim = J->mcbot;\n  return J->mctop;\n}", "path": "xLua/build/luajit-2.1.0b3/src/lj_mcode.c", "commit_date": "2018-07-15 00:00:00", "repo_name": "Tencent/xLua", "stars": 8981, "license": "other", "language": "c", "size": 25476}
{"docstring": "/*\n** Prompt the user, read a line, and push it into the Lua stack.\n*/\n", "func_signal": "static int pushline (lua_State *L, int firstline)", "code": "{\n  char buffer[LUA_MAXINPUT];\n  char *b = buffer;\n  size_t l;\n  const char *prmt = get_prompt(L, firstline);\n  int readstatus = lua_readline(L, b, prmt);\n  if (readstatus == 0)\n    return 0;  /* no input (prompt will be popped by caller) */\n  lua_pop(L, 1);  /* remove prompt */\n  l = strlen(b);\n  if (l > 0 && b[l-1] == '\\n')  /* line ends with newline? */\n    b[--l] = '\\0';  /* remove it */\n  if (firstline && b[0] == '=')  /* for compatibility with 5.2, ... */\n    lua_pushfstring(L, \"return %s\", b + 1);  /* change '=' to 'return' */\n  else\n    lua_pushlstring(L, b, l);\n  lua_freeline(L, b);\n  return 1;\n}", "path": "xLua/build/lua-5.3.4/src/lua.c", "commit_date": "2017-09-01 00:00:00", "repo_name": "Tencent/xLua", "stars": 8981, "license": "other", "language": "c", "size": 25476}
{"docstring": "/* Get memory within relative jump distance of our code in 64 bit mode. */\n", "func_signal": "static void *mcode_alloc(jit_State *J, size_t sz)", "code": "{\n  /* Target an address in the static assembler code (64K aligned).\n  ** Try addresses within a distance of target-range/2+1MB..target+range/2-1MB.\n  ** Use half the jump range so every address in the range can reach any other.\n  */\n#if LJ_TARGET_MIPS\n  /* Use the middle of the 256MB-aligned region. */\n  uintptr_t target = ((uintptr_t)(void *)lj_vm_exit_handler &\n\t\t      ~(uintptr_t)0x0fffffffu) + 0x08000000u;\n#else\n  uintptr_t target = (uintptr_t)(void *)lj_vm_exit_handler & ~(uintptr_t)0xffff;\n#endif\n  const uintptr_t range = (1u << (LJ_TARGET_JUMPRANGE-1)) - (1u << 21);\n  /* First try a contiguous area below the last one. */\n  uintptr_t hint = J->mcarea ? (uintptr_t)J->mcarea - sz : 0;\n  int i;\n  /* Limit probing iterations, depending on the available pool size. */\n  for (i = 0; i < LJ_TARGET_JUMPRANGE; i++) {\n    if (mcode_validptr(hint)) {\n      void *p = mcode_alloc_at(J, hint, sz, MCPROT_GEN);\n\n      if (mcode_validptr(p) &&\n\t  ((uintptr_t)p + sz - target < range || target - (uintptr_t)p < range))\n\treturn p;\n      if (p) mcode_free(J, p, sz);  /* Free badly placed area. */\n    }\n    /* Next try probing 64K-aligned pseudo-random addresses. */\n    do {\n      hint = LJ_PRNG_BITS(J, LJ_TARGET_JUMPRANGE-16) << 16;\n    } while (!(hint + sz < range+range));\n    hint = target + hint - range;\n  }\n  lj_trace_err(J, LJ_TRERR_MCODEAL);  /* Give up. OS probably ignores hints? */\n  return NULL;\n}", "path": "xLua/build/luajit-2.1.0b3/src/lj_mcode.c", "commit_date": "2018-07-15 00:00:00", "repo_name": "Tencent/xLua", "stars": 8981, "license": "other", "language": "c", "size": 25476}
{"docstring": "/*\n** Push on the stack the contents of table 'arg' from 1 to #arg\n*/\n", "func_signal": "static int pushargs (lua_State *L)", "code": "{\n  int i, n;\n  if (lua_getglobal(L, \"arg\") != LUA_TTABLE)\n    luaL_error(L, \"'arg' is not a table\");\n  n = (int)luaL_len(L, -1);\n  luaL_checkstack(L, n + 3, \"too many arguments to script\");\n  for (i = 1; i <= n; i++)\n    lua_rawgeti(L, -i, i);\n  lua_remove(L, -i);  /* remove table from the stack */\n  return n;\n}", "path": "xLua/build/lua-5.3.4/src/lua.c", "commit_date": "2017-09-01 00:00:00", "repo_name": "Tencent/xLua", "stars": 8981, "license": "other", "language": "c", "size": 25476}
{"docstring": "/* Synchronize data/instruction cache. */\n", "func_signal": "void lj_mcode_sync(void *start, void *end)", "code": "{\n#ifdef LUAJIT_USE_VALGRIND\n  VALGRIND_DISCARD_TRANSLATIONS(start, (char *)end-(char *)start);\n#endif\n#if LJ_TARGET_X86ORX64\n  UNUSED(start); UNUSED(end);\n#elif LJ_TARGET_IOS\n  sys_icache_invalidate(start, (char *)end-(char *)start);\n#elif LJ_TARGET_PPC\n  lj_vm_cachesync(start, end);\n#elif defined(__GNUC__)\n  __clear_cache(start, end);\n#else\n#error \"Missing builtin to flush instruction cache\"\n#endif\n}", "path": "xLua/build/luajit-2.1.0b3/src/lj_mcode.c", "commit_date": "2018-07-15 00:00:00", "repo_name": "Tencent/xLua", "stars": 8981, "license": "other", "language": "c", "size": 25476}
{"docstring": "/*\n** Processes options 'e' and 'l', which involve running Lua code.\n** Returns 0 if some code raises an error.\n*/\n", "func_signal": "static int runargs (lua_State *L, char **argv, int n)", "code": "{\n  int i;\n  for (i = 1; i < n; i++) {\n    int option = argv[i][1];\n    lua_assert(argv[i][0] == '-');  /* already checked */\n    if (option == 'e' || option == 'l') {\n      int status;\n      const char *extra = argv[i] + 2;  /* both options need an argument */\n      if (*extra == '\\0') extra = argv[++i];\n      lua_assert(extra != NULL);\n      status = (option == 'e')\n               ? dostring(L, extra, \"=(command line)\")\n               : dolibrary(L, extra);\n      if (status != LUA_OK) return 0;\n    }\n  }\n  return 1;\n}", "path": "xLua/build/lua-5.3.4/src/lua.c", "commit_date": "2017-09-01 00:00:00", "repo_name": "Tencent/xLua", "stars": 8981, "license": "other", "language": "c", "size": 25476}
{"docstring": "/*\n** Function to be called at a C signal. Because a C signal cannot\n** just change a Lua state (as there is no proper synchronization),\n** this function only sets a hook that, when called, will stop the\n** interpreter.\n*/\n", "func_signal": "static void laction (int i)", "code": "{\n  signal(i, SIG_DFL); /* if another SIGINT happens, terminate process */\n  lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);\n}", "path": "xLua/build/lua-5.3.4/src/lua.c", "commit_date": "2017-09-01 00:00:00", "repo_name": "Tencent/xLua", "stars": 8981, "license": "other", "language": "c", "size": 25476}
{"docstring": "/*\n** Calls 'require(name)' and stores the result in a global variable\n** with the given name.\n*/\n", "func_signal": "static int dolibrary (lua_State *L, const char *name)", "code": "{\n  int status;\n  lua_getglobal(L, \"require\");\n  lua_pushstring(L, name);\n  status = docall(L, 1, 1);  /* call 'require(name)' */\n  if (status == LUA_OK)\n    lua_setglobal(L, name);  /* global[name] = require return */\n  return report(L, status);\n}", "path": "xLua/build/lua-5.3.4/src/lua.c", "commit_date": "2017-09-01 00:00:00", "repo_name": "Tencent/xLua", "stars": 8981, "license": "other", "language": "c", "size": 25476}
{"docstring": "/* Change protection of MCode area. */\n", "func_signal": "static void mcode_protect(jit_State *J, int prot)", "code": "{\n  if (J->mcprot != prot) {\n    if (LJ_UNLIKELY(mcode_setprot(J->mcarea, J->szmcarea, prot)))\n      mcode_protfail(J);\n    J->mcprot = prot;\n  }\n}", "path": "xLua/build/luajit-2.1.0b3/src/lj_mcode.c", "commit_date": "2018-07-15 00:00:00", "repo_name": "Tencent/xLua", "stars": 8981, "license": "other", "language": "c", "size": 25476}
{"docstring": "/*\n** Open math library\n*/\n", "func_signal": "LUALIB_API int luaopen_math (lua_State *L)", "code": "{\n  luaL_register(L, LUA_MATHLIBNAME, mathlib);\n  lua_pushnumber(L, PI);\n  lua_setfield(L, -2, \"pi\");\n  lua_pushnumber(L, HUGE_VAL);\n  lua_setfield(L, -2, \"huge\");\n#if defined(LUA_COMPAT_MOD)\n  lua_getfield(L, -1, \"fmod\");\n  lua_setfield(L, -2, \"mod\");\n#endif\n  return 1;\n}", "path": "xLua/build/lua-5.1.5/src/lmathlib.c", "commit_date": "2016-12-20 00:00:00", "repo_name": "Tencent/xLua", "stars": 8981, "license": "other", "language": "c", "size": 25476}
{"docstring": "/*\n** Read a line and try to load (compile) it first as an expression (by\n** adding \"return \" in front of it) and second as a statement. Return\n** the final status of load/call with the resulting function (if any)\n** in the top of the stack.\n*/\n", "func_signal": "static int loadline (lua_State *L)", "code": "{\n  int status;\n  lua_settop(L, 0);\n  if (!pushline(L, 1))\n    return -1;  /* no input */\n  if ((status = addreturn(L)) != LUA_OK)  /* 'return ...' did not work? */\n    status = multiline(L);  /* try as command, maybe with continuation lines */\n  lua_remove(L, 1);  /* remove line from the stack */\n  lua_assert(lua_gettop(L) == 1);\n  return status;\n}", "path": "xLua/build/lua-5.3.4/src/lua.c", "commit_date": "2017-09-01 00:00:00", "repo_name": "Tencent/xLua", "stars": 8981, "license": "other", "language": "c", "size": 25476}
{"docstring": "/*\n** Returns the string to be used as a prompt by the interpreter.\n*/\n", "func_signal": "static const char *get_prompt (lua_State *L, int firstline)", "code": "{\n  const char *p;\n  lua_getglobal(L, firstline ? \"_PROMPT\" : \"_PROMPT2\");\n  p = lua_tostring(L, -1);\n  if (p == NULL) p = (firstline ? LUA_PROMPT : LUA_PROMPT2);\n  return p;\n}", "path": "xLua/build/lua-5.3.4/src/lua.c", "commit_date": "2017-09-01 00:00:00", "repo_name": "Tencent/xLua", "stars": 8981, "license": "other", "language": "c", "size": 25476}
{"docstring": "/* Print a guard line. */\n", "func_signal": "void\ncmdq_guard(struct cmdq_item *item, const char *guard, int flags)", "code": "{\n\tstruct client\t*c = item->client;\n\tlong\t\t t = item->time;\n\tu_int\t\t number = item->number;\n\n\tif (c != NULL && (c->flags & CLIENT_CONTROL))\n\t\tcontrol_write(c, \"%%%s %ld %u %d\", guard, t, number, flags);\n}", "path": "tmux/cmd-queue.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "tmux/tmux", "stars": 32332, "license": "other", "language": "c", "size": 17304}
{"docstring": "/* Find key string in table. */\n", "func_signal": "static key_code\nkey_string_search_table(const char *string)", "code": "{\n\tu_int\ti, user;\n\n\tfor (i = 0; i < nitems(key_string_table); i++) {\n\t\tif (strcasecmp(string, key_string_table[i].string) == 0)\n\t\t\treturn (key_string_table[i].key);\n\t}\n\n\tif (sscanf(string, \"User%u\", &user) == 1 && user < KEYC_NUSER)\n\t\treturn (KEYC_USER + user);\n\n\treturn (KEYC_UNKNOWN);\n}", "path": "tmux/key-string.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "tmux/tmux", "stars": 32332, "license": "other", "language": "c", "size": 17304}
{"docstring": "/* Fire command on command queue. */\n", "func_signal": "static enum cmd_retval\ncmdq_fire_command(struct cmdq_item *item)", "code": "{\n\tconst char\t\t*name = cmdq_name(item->client);\n\tstruct cmdq_state\t*state = item->state;\n\tstruct cmd\t\t*cmd = item->cmd;\n\tstruct args\t\t*args = cmd_get_args(cmd);\n\tconst struct cmd_entry\t*entry = cmd_get_entry(cmd);\n\tstruct client\t\t*tc, *saved = item->client;\n\tenum cmd_retval\t\t retval;\n\tstruct cmd_find_state\t*fsp, fs;\n\tint\t\t\t flags, quiet = 0;\n\tchar\t\t\t*tmp;\n\n\tif (cfg_finished)\n\t\tcmdq_add_message(item);\n\tif (log_get_level() > 1) {\n\t\ttmp = cmd_print(cmd);\n\t\tlog_debug(\"%s %s: (%u) %s\", __func__, name, item->group, tmp);\n\t\tfree(tmp);\n\t}\n\n\tflags = !!(state->flags & CMDQ_STATE_CONTROL);\n\tcmdq_guard(item, \"begin\", flags);\n\n\tif (item->client == NULL)\n\t\titem->client = cmd_find_client(item, NULL, 1);\n\n\tif (entry->flags & CMD_CLIENT_CANFAIL)\n\t\tquiet = 1;\n\tif (entry->flags & CMD_CLIENT_CFLAG) {\n\t\ttc = cmd_find_client(item, args_get(args, 'c'), quiet);\n\t\tif (tc == NULL && !quiet) {\n\t\t\tretval = CMD_RETURN_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t} else if (entry->flags & CMD_CLIENT_TFLAG) {\n\t\ttc = cmd_find_client(item, args_get(args, 't'), quiet);\n\t\tif (tc == NULL && !quiet) {\n\t\t\tretval = CMD_RETURN_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\ttc = cmd_find_client(item, NULL, 1);\n\titem->target_client = tc;\n\n\tretval = cmdq_find_flag(item, &item->source, &entry->source);\n\tif (retval == CMD_RETURN_ERROR)\n\t\tgoto out;\n\tretval = cmdq_find_flag(item, &item->target, &entry->target);\n\tif (retval == CMD_RETURN_ERROR)\n\t\tgoto out;\n\n\tretval = entry->exec(cmd, item);\n\tif (retval == CMD_RETURN_ERROR)\n\t\tgoto out;\n\n\tif (entry->flags & CMD_AFTERHOOK) {\n\t\tif (cmd_find_valid_state(&item->target))\n\t\t\tfsp = &item->target;\n\t\telse if (cmd_find_valid_state(&item->state->current))\n\t\t\tfsp = &item->state->current;\n\t\telse if (cmd_find_from_client(&fs, item->client, 0) == 0)\n\t\t\tfsp = &fs;\n\t\telse\n\t\t\tgoto out;\n\t\tcmdq_insert_hook(fsp->s, item, fsp, \"after-%s\", entry->name);\n\t}\n\nout:\n\titem->client = saved;\n\tif (retval == CMD_RETURN_ERROR)\n\t\tcmdq_guard(item, \"error\", flags);\n\telse\n\t\tcmdq_guard(item, \"end\", flags);\n\treturn (retval);\n}", "path": "tmux/cmd-queue.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "tmux/tmux", "stars": 32332, "license": "other", "language": "c", "size": 17304}
{"docstring": "/* Add a format to command queue. */\n", "func_signal": "void\ncmdq_add_format(struct cmdq_state *state, const char *key, const char *fmt, ...)", "code": "{\n\tva_list\t ap;\n\tchar\t*value;\n\n\tva_start(ap, fmt);\n\txvasprintf(&value, fmt, ap);\n\tva_end(ap);\n\n\tif (state->formats == NULL)\n\t\tstate->formats = format_create(NULL, NULL, FORMAT_NONE, 0);\n\tformat_add(state->formats, key, \"%s\", value);\n\n\tfree(value);\n}", "path": "tmux/cmd-queue.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "tmux/tmux", "stars": 32332, "license": "other", "language": "c", "size": 17304}
{"docstring": "/*\n * Convert an RGB triplet to the xterm(1) 256 colour palette.\n *\n * xterm provides a 6x6x6 colour cube (16 - 231) and 24 greys (232 - 255). We\n * map our RGB colour to the closest in the cube, also work out the closest\n * grey, and use the nearest of the two.\n *\n * Note that the xterm has much lower resolution for darker colours (they are\n * not evenly spread out), so our 6 levels are not evenly spread: 0x0, 0x5f\n * (95), 0x87 (135), 0xaf (175), 0xd7 (215) and 0xff (255). Greys are more\n * evenly spread (8, 18, 28 ... 238).\n */\n", "func_signal": "int\ncolour_find_rgb(u_char r, u_char g, u_char b)", "code": "{\n\tstatic const int\tq2c[6] = { 0x00, 0x5f, 0x87, 0xaf, 0xd7, 0xff };\n\tint\t\t\tqr, qg, qb, cr, cg, cb, d, idx;\n\tint\t\t\tgrey_avg, grey_idx, grey;\n\n\t/* Map RGB to 6x6x6 cube. */\n\tqr = colour_to_6cube(r); cr = q2c[qr];\n\tqg = colour_to_6cube(g); cg = q2c[qg];\n\tqb = colour_to_6cube(b); cb = q2c[qb];\n\n\t/* If we have hit the colour exactly, return early. */\n\tif (cr == r && cg == g && cb == b)\n\t\treturn ((16 + (36 * qr) + (6 * qg) + qb) | COLOUR_FLAG_256);\n\n\t/* Work out the closest grey (average of RGB). */\n\tgrey_avg = (r + g + b) / 3;\n\tif (grey_avg > 238)\n\t\tgrey_idx = 23;\n\telse\n\t\tgrey_idx = (grey_avg - 3) / 10;\n\tgrey = 8 + (10 * grey_idx);\n\n\t/* Is grey or 6x6x6 colour closest? */\n\td = colour_dist_sq(cr, cg, cb, r, g, b);\n\tif (colour_dist_sq(grey, grey, grey, r, g, b) < d)\n\t\tidx = 232 + grey_idx;\n\telse\n\t\tidx = 16 + (36 * qr) + (6 * qg) + qb;\n\treturn (idx | COLOUR_FLAG_256);\n}", "path": "tmux/colour.c", "commit_date": "2020-08-25 00:00:00", "repo_name": "tmux/tmux", "stars": 32332, "license": "other", "language": "c", "size": 17304}
{"docstring": "/* Insert a hook. */\n", "func_signal": "void\ncmdq_insert_hook(struct session *s, struct cmdq_item *item,\n    struct cmd_find_state *current, const char *fmt, ...)", "code": "{\n\tstruct cmdq_state\t\t*state = item->state;\n\tstruct cmd\t\t\t*cmd = item->cmd;\n\tstruct args\t\t\t*args = cmd_get_args(cmd);\n\tstruct args_entry\t\t*entryp;\n\tstruct args_value\t\t*valuep;\n\tstruct options\t\t\t*oo;\n\tva_list\t\t\t\t ap;\n\tchar\t\t\t\t*name, tmp[32], flag, *arguments;\n\tint\t\t\t\t i;\n\tconst char\t\t\t*value;\n\tstruct cmdq_item\t\t*new_item;\n\tstruct cmdq_state\t\t*new_state;\n\tstruct options_entry\t\t*o;\n\tstruct options_array_item\t*a;\n\tstruct cmd_list\t\t\t*cmdlist;\n\n\tif (item->state->flags & CMDQ_STATE_NOHOOKS)\n\t\treturn;\n\tif (s == NULL)\n\t\too = global_s_options;\n\telse\n\t\too = s->options;\n\n\tva_start(ap, fmt);\n\txvasprintf(&name, fmt, ap);\n\tva_end(ap);\n\n\to = options_get(oo, name);\n\tif (o == NULL) {\n\t\tfree(name);\n\t\treturn;\n\t}\n\tlog_debug(\"running hook %s (parent %p)\", name, item);\n\n\t/*\n\t * The hooks get a new state because they should not update the current\n\t * target or formats for any subsequent commands.\n\t */\n\tnew_state = cmdq_new_state(current, &state->event, CMDQ_STATE_NOHOOKS);\n\tcmdq_add_format(new_state, \"hook\", \"%s\", name);\n\n\targuments = args_print(args);\n\tcmdq_add_format(new_state, \"hook_arguments\", \"%s\", arguments);\n\tfree(arguments);\n\n\tfor (i = 0; i < args->argc; i++) {\n\t\txsnprintf(tmp, sizeof tmp, \"hook_argument_%d\", i);\n\t\tcmdq_add_format(new_state, tmp, \"%s\", args->argv[i]);\n\t}\n\tflag = args_first(args, &entryp);\n\twhile (flag != 0) {\n\t\tvalue = args_get(args, flag);\n\t\tif (value == NULL) {\n\t\t\txsnprintf(tmp, sizeof tmp, \"hook_flag_%c\", flag);\n\t\t\tcmdq_add_format(new_state, tmp, \"1\");\n\t\t} else {\n\t\t\txsnprintf(tmp, sizeof tmp, \"hook_flag_%c\", flag);\n\t\t\tcmdq_add_format(new_state, tmp, \"%s\", value);\n\t\t}\n\n\t\ti = 0;\n\t\tvalue = args_first_value(args, flag, &valuep);\n\t\twhile (value != NULL) {\n\t\t\txsnprintf(tmp, sizeof tmp, \"hook_flag_%c_%d\", flag, i);\n\t\t\tcmdq_add_format(new_state, tmp, \"%s\", value);\n\t\t\ti++;\n\t\t\tvalue = args_next_value(&valuep);\n\t\t}\n\n\t\tflag = args_next(&entryp);\n\t}\n\n\ta = options_array_first(o);\n\twhile (a != NULL) {\n\t\tcmdlist = options_array_item_value(a)->cmdlist;\n\t\tif (cmdlist != NULL) {\n\t\t\tnew_item = cmdq_get_command(cmdlist, new_state);\n\t\t\tif (item != NULL)\n\t\t\t\titem = cmdq_insert_after(item, new_item);\n\t\t\telse\n\t\t\t\titem = cmdq_append(NULL, new_item);\n\t\t}\n\t\ta = options_array_next(a);\n\t}\n\n\tcmdq_free_state(new_state);\n\tfree(name);\n}", "path": "tmux/cmd-queue.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "tmux/tmux", "stars": 32332, "license": "other", "language": "c", "size": 17304}
{"docstring": "/* Show message from command. */\n", "func_signal": "void\ncmdq_print(struct cmdq_item *item, const char *fmt, ...)", "code": "{\n\tstruct client\t\t\t*c = item->client;\n\tstruct window_pane\t\t*wp;\n\tstruct window_mode_entry\t*wme;\n\tva_list\t\t\t\t ap;\n\tchar\t\t\t\t*tmp, *msg;\n\n\tva_start(ap, fmt);\n\txvasprintf(&msg, fmt, ap);\n\tva_end(ap);\n\n\tlog_debug(\"%s: %s\", __func__, msg);\n\n\tif (c == NULL)\n\t\t/* nothing */;\n\telse if (c->session == NULL || (c->flags & CLIENT_CONTROL)) {\n\t\tif (~c->flags & CLIENT_UTF8) {\n\t\t\ttmp = msg;\n\t\t\tmsg = utf8_sanitize(tmp);\n\t\t\tfree(tmp);\n\t\t}\n\t\tif (c->flags & CLIENT_CONTROL)\n\t\t\tcontrol_write(c, \"%s\", msg);\n\t\telse\n\t\t\tfile_print(c, \"%s\\n\", msg);\n\t} else {\n\t\twp = server_client_get_pane(c);\n\t\twme = TAILQ_FIRST(&wp->modes);\n\t\tif (wme == NULL || wme->mode != &window_view_mode) {\n\t\t\twindow_pane_set_mode(wp, NULL, &window_view_mode, NULL,\n\t\t\t    NULL);\n\t\t}\n\t\twindow_copy_add(wp, \"%s\", msg);\n\t}\n\n\tfree(msg);\n}", "path": "tmux/cmd-queue.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "tmux/tmux", "stars": 32332, "license": "other", "language": "c", "size": 17304}
{"docstring": "/* Split colour into RGB. */\n", "func_signal": "void\ncolour_split_rgb(int c, u_char *r, u_char *g, u_char *b)", "code": "{\n\t*r = (c >> 16) & 0xff;\n\t*g = (c >> 8) & 0xff;\n\t*b = c & 0xff;\n}", "path": "tmux/colour.c", "commit_date": "2020-08-25 00:00:00", "repo_name": "tmux/tmux", "stars": 32332, "license": "other", "language": "c", "size": 17304}
{"docstring": "/* Merge formats from item. */\n", "func_signal": "void\ncmdq_merge_formats(struct cmdq_item *item, struct format_tree *ft)", "code": "{\n\tconst struct cmd_entry\t*entry;\n\n\tif (item->cmd != NULL) {\n\t\tentry = cmd_get_entry (item->cmd);\n\t\tformat_add(ft, \"command\", \"%s\", entry->name);\n\t}\n\tif (item->state->formats != NULL)\n\t\tformat_merge(ft, item->state->formats);\n}", "path": "tmux/cmd-queue.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "tmux/tmux", "stars": 32332, "license": "other", "language": "c", "size": 17304}
{"docstring": "/* Get command queue from client. */\n", "func_signal": "static struct cmdq_list *\ncmdq_get(struct client *c)", "code": "{\n\tstatic struct cmdq_list *global_queue;\n\n\tif (c == NULL) {\n\t\tif (global_queue == NULL)\n\t\t\tglobal_queue = cmdq_new();\n\t\treturn (global_queue);\n\t}\n\treturn (c->queue);\n}", "path": "tmux/cmd-queue.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "tmux/tmux", "stars": 32332, "license": "other", "language": "c", "size": 17304}
{"docstring": "/* Free a queue. */\n", "func_signal": "void\ncmdq_free(struct cmdq_list *queue)", "code": "{\n\tif (!TAILQ_EMPTY(&queue->list))\n\t\tfatalx(\"queue not empty\");\n\tfree(queue);\n}", "path": "tmux/cmd-queue.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "tmux/tmux", "stars": 32332, "license": "other", "language": "c", "size": 17304}
{"docstring": "/* Convert 256 colour to 16 colour. */\n", "func_signal": "int\ncolour_256to16(int c)", "code": "{\n\tstatic const char table[256] = {\n\t\t 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n\t\t 0,  4,  4,  4, 12, 12,  2,  6,  4,  4, 12, 12,  2,  2,  6,  4,\n\t\t12, 12,  2,  2,  2,  6, 12, 12, 10, 10, 10, 10, 14, 12, 10, 10,\n\t\t10, 10, 10, 14,  1,  5,  4,  4, 12, 12,  3,  8,  4,  4, 12, 12,\n\t\t 2,  2,  6,  4, 12, 12,  2,  2,  2,  6, 12, 12, 10, 10, 10, 10,\n\t\t14, 12, 10, 10, 10, 10, 10, 14,  1,  1,  5,  4, 12, 12,  1,  1,\n\t\t 5,  4, 12, 12,  3,  3,  8,  4, 12, 12,  2,  2,  2,  6, 12, 12,\n\t\t10, 10, 10, 10, 14, 12, 10, 10, 10, 10, 10, 14,  1,  1,  1,  5,\n\t\t12, 12,  1,  1,  1,  5, 12, 12,  1,  1,  1,  5, 12, 12,  3,  3,\n\t\t 3,  7, 12, 12, 10, 10, 10, 10, 14, 12, 10, 10, 10, 10, 10, 14,\n\t\t 9,  9,  9,  9, 13, 12,  9,  9,  9,  9, 13, 12,  9,  9,  9,  9,\n\t\t13, 12,  9,  9,  9,  9, 13, 12, 11, 11, 11, 11,  7, 12, 10, 10,\n\t\t10, 10, 10, 14,  9,  9,  9,  9,  9, 13,  9,  9,  9,  9,  9, 13,\n\t\t 9,  9,  9,  9,  9, 13,  9,  9,  9,  9,  9, 13,  9,  9,  9,  9,\n\t\t 9, 13, 11, 11, 11, 11, 11, 15,  0,  0,  0,  0,  0,  0,  8,  8,\n\t\t 8,  8,  8,  8,  7,  7,  7,  7,  7,  7, 15, 15, 15, 15, 15, 15\n\t};\n\n\treturn (table[c & 0xff]);\n}", "path": "tmux/colour.c", "commit_date": "2020-08-25 00:00:00", "repo_name": "tmux/tmux", "stars": 32332, "license": "other", "language": "c", "size": 17304}
{"docstring": "/* Get running item if any. */\n", "func_signal": "struct cmdq_item *\ncmdq_running(struct client *c)", "code": "{\n\tstruct cmdq_list\t*queue = cmdq_get(c);\n\n\tif (queue->item == NULL)\n        return (NULL);\n    if (queue->item->flags & CMDQ_WAITING)\n        return (NULL);\n    return (queue->item);\n}", "path": "tmux/cmd-queue.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "tmux/tmux", "stars": 32332, "license": "other", "language": "c", "size": 17304}
{"docstring": "/* Convert 256 colour to RGB colour. */\n", "func_signal": "int\ncolour_256toRGB(int c)", "code": "{\n\tstatic const int table[256] = {\n\t\t0x000000, 0x800000, 0x008000, 0x808000,\n\t\t0x000080, 0x800080, 0x008080, 0xc0c0c0,\n\t\t0x808080, 0xff0000, 0x00ff00, 0xffff00,\n\t\t0x0000ff, 0xff00ff, 0x00ffff, 0xffffff,\n\t\t0x000000, 0x00005f, 0x000087, 0x0000af,\n\t\t0x0000d7, 0x0000ff, 0x005f00, 0x005f5f,\n\t\t0x005f87, 0x005faf, 0x005fd7, 0x005fff,\n\t\t0x008700, 0x00875f, 0x008787, 0x0087af,\n\t\t0x0087d7, 0x0087ff, 0x00af00, 0x00af5f,\n\t\t0x00af87, 0x00afaf, 0x00afd7, 0x00afff,\n\t\t0x00d700, 0x00d75f, 0x00d787, 0x00d7af,\n\t\t0x00d7d7, 0x00d7ff, 0x00ff00, 0x00ff5f,\n\t\t0x00ff87, 0x00ffaf, 0x00ffd7, 0x00ffff,\n\t\t0x5f0000, 0x5f005f, 0x5f0087, 0x5f00af,\n\t\t0x5f00d7, 0x5f00ff, 0x5f5f00, 0x5f5f5f,\n\t\t0x5f5f87, 0x5f5faf, 0x5f5fd7, 0x5f5fff,\n\t\t0x5f8700, 0x5f875f, 0x5f8787, 0x5f87af,\n\t\t0x5f87d7, 0x5f87ff, 0x5faf00, 0x5faf5f,\n\t\t0x5faf87, 0x5fafaf, 0x5fafd7, 0x5fafff,\n\t\t0x5fd700, 0x5fd75f, 0x5fd787, 0x5fd7af,\n\t\t0x5fd7d7, 0x5fd7ff, 0x5fff00, 0x5fff5f,\n\t\t0x5fff87, 0x5fffaf, 0x5fffd7, 0x5fffff,\n\t\t0x870000, 0x87005f, 0x870087, 0x8700af,\n\t\t0x8700d7, 0x8700ff, 0x875f00, 0x875f5f,\n\t\t0x875f87, 0x875faf, 0x875fd7, 0x875fff,\n\t\t0x878700, 0x87875f, 0x878787, 0x8787af,\n\t\t0x8787d7, 0x8787ff, 0x87af00, 0x87af5f,\n\t\t0x87af87, 0x87afaf, 0x87afd7, 0x87afff,\n\t\t0x87d700, 0x87d75f, 0x87d787, 0x87d7af,\n\t\t0x87d7d7, 0x87d7ff, 0x87ff00, 0x87ff5f,\n\t\t0x87ff87, 0x87ffaf, 0x87ffd7, 0x87ffff,\n\t\t0xaf0000, 0xaf005f, 0xaf0087, 0xaf00af,\n\t\t0xaf00d7, 0xaf00ff, 0xaf5f00, 0xaf5f5f,\n\t\t0xaf5f87, 0xaf5faf, 0xaf5fd7, 0xaf5fff,\n\t\t0xaf8700, 0xaf875f, 0xaf8787, 0xaf87af,\n\t\t0xaf87d7, 0xaf87ff, 0xafaf00, 0xafaf5f,\n\t\t0xafaf87, 0xafafaf, 0xafafd7, 0xafafff,\n\t\t0xafd700, 0xafd75f, 0xafd787, 0xafd7af,\n\t\t0xafd7d7, 0xafd7ff, 0xafff00, 0xafff5f,\n\t\t0xafff87, 0xafffaf, 0xafffd7, 0xafffff,\n\t\t0xd70000, 0xd7005f, 0xd70087, 0xd700af,\n\t\t0xd700d7, 0xd700ff, 0xd75f00, 0xd75f5f,\n\t\t0xd75f87, 0xd75faf, 0xd75fd7, 0xd75fff,\n\t\t0xd78700, 0xd7875f, 0xd78787, 0xd787af,\n\t\t0xd787d7, 0xd787ff, 0xd7af00, 0xd7af5f,\n\t\t0xd7af87, 0xd7afaf, 0xd7afd7, 0xd7afff,\n\t\t0xd7d700, 0xd7d75f, 0xd7d787, 0xd7d7af,\n\t\t0xd7d7d7, 0xd7d7ff, 0xd7ff00, 0xd7ff5f,\n\t\t0xd7ff87, 0xd7ffaf, 0xd7ffd7, 0xd7ffff,\n\t\t0xff0000, 0xff005f, 0xff0087, 0xff00af,\n\t\t0xff00d7, 0xff00ff, 0xff5f00, 0xff5f5f,\n\t\t0xff5f87, 0xff5faf, 0xff5fd7, 0xff5fff,\n\t\t0xff8700, 0xff875f, 0xff8787, 0xff87af,\n\t\t0xff87d7, 0xff87ff, 0xffaf00, 0xffaf5f,\n\t\t0xffaf87, 0xffafaf, 0xffafd7, 0xffafff,\n\t\t0xffd700, 0xffd75f, 0xffd787, 0xffd7af,\n\t\t0xffd7d7, 0xffd7ff, 0xffff00, 0xffff5f,\n\t\t0xffff87, 0xffffaf, 0xffffd7, 0xffffff,\n\t\t0x080808, 0x121212, 0x1c1c1c, 0x262626,\n\t\t0x303030, 0x3a3a3a, 0x444444, 0x4e4e4e,\n\t\t0x585858, 0x626262, 0x6c6c6c, 0x767676,\n\t\t0x808080, 0x8a8a8a, 0x949494, 0x9e9e9e,\n\t\t0xa8a8a8, 0xb2b2b2, 0xbcbcbc, 0xc6c6c6,\n\t\t0xd0d0d0, 0xdadada, 0xe4e4e4, 0xeeeeee\n\t};\n\n\treturn (table[c & 0xff] | COLOUR_FLAG_RGB);\n}", "path": "tmux/colour.c", "commit_date": "2020-08-25 00:00:00", "repo_name": "tmux/tmux", "stars": 32332, "license": "other", "language": "c", "size": 17304}
{"docstring": "/* Generic error callback. */\n", "func_signal": "static enum cmd_retval\ncmdq_error_callback(struct cmdq_item *item, void *data)", "code": "{\n\tchar\t*error = data;\n\n\tcmdq_error(item, \"%s\", error);\n\tfree(error);\n\n\treturn (CMD_RETURN_NORMAL);\n}", "path": "tmux/cmd-queue.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "tmux/tmux", "stars": 32332, "license": "other", "language": "c", "size": 17304}
{"docstring": "/* Remove all subsequent items that match this item's group. */\n", "func_signal": "static void\ncmdq_remove_group(struct cmdq_item *item)", "code": "{\n\tstruct cmdq_item\t*this, *next;\n\n\tif (item->group == 0)\n\t\treturn;\n\tthis = TAILQ_NEXT(item, entry);\n\twhile (this != NULL) {\n\t\tnext = TAILQ_NEXT(this, entry);\n\t\tif (this->group == item->group)\n\t\t\tcmdq_remove(this);\n\t\tthis = next;\n\t}\n}", "path": "tmux/cmd-queue.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "tmux/tmux", "stars": 32332, "license": "other", "language": "c", "size": 17304}
{"docstring": "/* Remove an item. */\n", "func_signal": "static void\ncmdq_remove(struct cmdq_item *item)", "code": "{\n\tif (item->client != NULL)\n\t\tserver_client_unref(item->client);\n\tif (item->cmdlist != NULL)\n\t\tcmd_list_free(item->cmdlist);\n\tcmdq_free_state(item->state);\n\n\tTAILQ_REMOVE(&item->queue->list, item, entry);\n\n\tfree(item->name);\n\tfree(item);\n}", "path": "tmux/cmd-queue.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "tmux/tmux", "stars": 32332, "license": "other", "language": "c", "size": 17304}
{"docstring": "/* Join RGB into a colour. */\n", "func_signal": "int\ncolour_join_rgb(u_char r, u_char g, u_char b)", "code": "{\n\treturn ((((int)((r) & 0xff)) << 16) |\n\t    (((int)((g) & 0xff)) << 8) |\n\t    (((int)((b) & 0xff))) | COLOUR_FLAG_RGB);\n}", "path": "tmux/colour.c", "commit_date": "2020-08-25 00:00:00", "repo_name": "tmux/tmux", "stars": 32332, "license": "other", "language": "c", "size": 17304}
{"docstring": "/* Append an item. */\n", "func_signal": "struct cmdq_item *\ncmdq_append(struct client *c, struct cmdq_item *item)", "code": "{\n\tstruct cmdq_list\t*queue = cmdq_get(c);\n\tstruct cmdq_item\t*next;\n\n\tdo {\n\t\tnext = item->next;\n\t\titem->next = NULL;\n\n\t\tif (c != NULL)\n\t\t\tc->references++;\n\t\titem->client = c;\n\n\t\titem->queue = queue;\n\t\tTAILQ_INSERT_TAIL(&queue->list, item, entry);\n\t\tlog_debug(\"%s %s: %s\", __func__, cmdq_name(c), item->name);\n\n\t\titem = next;\n\t} while (item != NULL);\n\treturn (TAILQ_LAST(&queue->list, cmdq_item_list));\n}", "path": "tmux/cmd-queue.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "tmux/tmux", "stars": 32332, "license": "other", "language": "c", "size": 17304}
{"docstring": "/* Add a reference to a state. */\n", "func_signal": "struct cmdq_state *\ncmdq_link_state(struct cmdq_state *state)", "code": "{\n\tstate->references++;\n\treturn (state);\n}", "path": "tmux/cmd-queue.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "tmux/tmux", "stars": 32332, "license": "other", "language": "c", "size": 17304}
{"docstring": "/*\n * Drop replication origin.\n *\n * Needs to be called in a transaction.\n */\n", "func_signal": "void\nreplorigin_drop(RepOriginId roident, bool nowait)", "code": "{\n\tHeapTuple\ttuple;\n\tRelation\trel;\n\tint\t\t\ti;\n\n\tAssert(IsTransactionState());\n\n\t/*\n\t * To interlock against concurrent drops, we hold ExclusiveLock on\n\t * pg_replication_origin throughout this function.\n\t */\n\trel = table_open(ReplicationOriginRelationId, ExclusiveLock);\n\n\t/*\n\t * First, clean up the slot state info, if there is any matching slot.\n\t */\nrestart:\n\ttuple = NULL;\n\tLWLockAcquire(ReplicationOriginLock, LW_EXCLUSIVE);\n\n\tfor (i = 0; i < max_replication_slots; i++)\n\t{\n\t\tReplicationState *state = &replication_states[i];\n\n\t\tif (state->roident == roident)\n\t\t{\n\t\t\t/* found our slot, is it busy? */\n\t\t\tif (state->acquired_by != 0)\n\t\t\t{\n\t\t\t\tConditionVariable *cv;\n\n\t\t\t\tif (nowait)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OBJECT_IN_USE),\n\t\t\t\t\t\t\t errmsg(\"could not drop replication origin with OID %d, in use by PID %d\",\n\t\t\t\t\t\t\t\t\tstate->roident,\n\t\t\t\t\t\t\t\t\tstate->acquired_by)));\n\n\t\t\t\t/*\n\t\t\t\t * We must wait and then retry.  Since we don't know which CV\n\t\t\t\t * to wait on until here, we can't readily use\n\t\t\t\t * ConditionVariablePrepareToSleep (calling it here would be\n\t\t\t\t * wrong, since we could miss the signal if we did so); just\n\t\t\t\t * use ConditionVariableSleep directly.\n\t\t\t\t */\n\t\t\t\tcv = &state->origin_cv;\n\n\t\t\t\tLWLockRelease(ReplicationOriginLock);\n\n\t\t\t\tConditionVariableSleep(cv, WAIT_EVENT_REPLICATION_ORIGIN_DROP);\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\t/* first make a WAL log entry */\n\t\t\t{\n\t\t\t\txl_replorigin_drop xlrec;\n\n\t\t\t\txlrec.node_id = roident;\n\t\t\t\tXLogBeginInsert();\n\t\t\t\tXLogRegisterData((char *) (&xlrec), sizeof(xlrec));\n\t\t\t\tXLogInsert(RM_REPLORIGIN_ID, XLOG_REPLORIGIN_DROP);\n\t\t\t}\n\n\t\t\t/* then clear the in-memory slot */\n\t\t\tstate->roident = InvalidRepOriginId;\n\t\t\tstate->remote_lsn = InvalidXLogRecPtr;\n\t\t\tstate->local_lsn = InvalidXLogRecPtr;\n\t\t\tbreak;\n\t\t}\n\t}\n\tLWLockRelease(ReplicationOriginLock);\n\tConditionVariableCancelSleep();\n\n\t/*\n\t * Now, we can delete the catalog entry.\n\t */\n\ttuple = SearchSysCache1(REPLORIGIDENT, ObjectIdGetDatum(roident));\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"cache lookup failed for replication origin with oid %u\",\n\t\t\t roident);\n\n\tCatalogTupleDelete(rel, &tuple->t_self);\n\tReleaseSysCache(tuple);\n\n\tCommandCounterIncrement();\n\n\t/* now release lock again */\n\ttable_close(rel, ExclusiveLock);\n}", "path": "postgres/src/backend/replication/logical/origin.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "postgres/postgres", "stars": 14240, "license": "other", "language": "c", "size": 541268}
{"docstring": "/*\n * Reset replay state previously setup in this session.\n *\n * This function may only be called if an origin was setup with\n * replorigin_session_setup().\n */\n", "func_signal": "void\nreplorigin_session_reset(void)", "code": "{\n\tConditionVariable *cv;\n\n\tAssert(max_replication_slots != 0);\n\n\tif (session_replication_state == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"no replication origin is configured\")));\n\n\tLWLockAcquire(ReplicationOriginLock, LW_EXCLUSIVE);\n\n\tsession_replication_state->acquired_by = 0;\n\tcv = &session_replication_state->origin_cv;\n\tsession_replication_state = NULL;\n\n\tLWLockRelease(ReplicationOriginLock);\n\n\tConditionVariableBroadcast(cv);\n}", "path": "postgres/src/backend/replication/logical/origin.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "postgres/postgres", "stars": 14240, "license": "other", "language": "c", "size": 541268}
{"docstring": "/*\n * Setup a replication origin for this session.\n */\n", "func_signal": "Datum\npg_replication_origin_session_setup(PG_FUNCTION_ARGS)", "code": "{\n\tchar\t   *name;\n\tRepOriginId origin;\n\n\treplorigin_check_prerequisites(true, false);\n\n\tname = text_to_cstring((text *) DatumGetPointer(PG_GETARG_DATUM(0)));\n\torigin = replorigin_by_name(name, false);\n\treplorigin_session_setup(origin);\n\n\treplorigin_session_origin = origin;\n\n\tpfree(name);\n\n\tPG_RETURN_VOID();\n}", "path": "postgres/src/backend/replication/logical/origin.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "postgres/postgres", "stars": 14240, "license": "other", "language": "c", "size": 541268}
{"docstring": "/* ---------------------------------------------------------------------------\n * Perform a checkpoint of each replication origin's progress with respect to\n * the replayed remote_lsn. Make sure that all transactions we refer to in the\n * checkpoint (local_lsn) are actually on-disk. This might not yet be the case\n * if the transactions were originally committed asynchronously.\n *\n * We store checkpoints in the following format:\n * +-------+------------------------+------------------+-----+--------+\n * | MAGIC | ReplicationStateOnDisk | struct Replic... | ... | CRC32C | EOF\n * +-------+------------------------+------------------+-----+--------+\n *\n * So its just the magic, followed by the statically sized\n * ReplicationStateOnDisk structs. Note that the maximum number of\n * ReplicationState is determined by max_replication_slots.\n * ---------------------------------------------------------------------------\n */\n", "func_signal": "void\nCheckPointReplicationOrigin(void)", "code": "{\n\tconst char *tmppath = \"pg_logical/replorigin_checkpoint.tmp\";\n\tconst char *path = \"pg_logical/replorigin_checkpoint\";\n\tint\t\t\ttmpfd;\n\tint\t\t\ti;\n\tuint32\t\tmagic = REPLICATION_STATE_MAGIC;\n\tpg_crc32c\tcrc;\n\n\tif (max_replication_slots == 0)\n\t\treturn;\n\n\tINIT_CRC32C(crc);\n\n\t/* make sure no old temp file is remaining */\n\tif (unlink(tmppath) < 0 && errno != ENOENT)\n\t\tereport(PANIC,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not remove file \\\"%s\\\": %m\",\n\t\t\t\t\t\ttmppath)));\n\n\t/*\n\t * no other backend can perform this at the same time, we're protected by\n\t * CheckpointLock.\n\t */\n\ttmpfd = OpenTransientFile(tmppath,\n\t\t\t\t\t\t\t  O_CREAT | O_EXCL | O_WRONLY | PG_BINARY);\n\tif (tmpfd < 0)\n\t\tereport(PANIC,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not create file \\\"%s\\\": %m\",\n\t\t\t\t\t\ttmppath)));\n\n\t/* write magic */\n\terrno = 0;\n\tif ((write(tmpfd, &magic, sizeof(magic))) != sizeof(magic))\n\t{\n\t\t/* if write didn't set errno, assume problem is no disk space */\n\t\tif (errno == 0)\n\t\t\terrno = ENOSPC;\n\t\tereport(PANIC,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\",\n\t\t\t\t\t\ttmppath)));\n\t}\n\tCOMP_CRC32C(crc, &magic, sizeof(magic));\n\n\t/* prevent concurrent creations/drops */\n\tLWLockAcquire(ReplicationOriginLock, LW_SHARED);\n\n\t/* write actual data */\n\tfor (i = 0; i < max_replication_slots; i++)\n\t{\n\t\tReplicationStateOnDisk disk_state;\n\t\tReplicationState *curstate = &replication_states[i];\n\t\tXLogRecPtr\tlocal_lsn;\n\n\t\tif (curstate->roident == InvalidRepOriginId)\n\t\t\tcontinue;\n\n\t\t/* zero, to avoid uninitialized padding bytes */\n\t\tmemset(&disk_state, 0, sizeof(disk_state));\n\n\t\tLWLockAcquire(&curstate->lock, LW_SHARED);\n\n\t\tdisk_state.roident = curstate->roident;\n\n\t\tdisk_state.remote_lsn = curstate->remote_lsn;\n\t\tlocal_lsn = curstate->local_lsn;\n\n\t\tLWLockRelease(&curstate->lock);\n\n\t\t/* make sure we only write out a commit that's persistent */\n\t\tXLogFlush(local_lsn);\n\n\t\terrno = 0;\n\t\tif ((write(tmpfd, &disk_state, sizeof(disk_state))) !=\n\t\t\tsizeof(disk_state))\n\t\t{\n\t\t\t/* if write didn't set errno, assume problem is no disk space */\n\t\t\tif (errno == 0)\n\t\t\t\terrno = ENOSPC;\n\t\t\tereport(PANIC,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\ttmppath)));\n\t\t}\n\n\t\tCOMP_CRC32C(crc, &disk_state, sizeof(disk_state));\n\t}\n\n\tLWLockRelease(ReplicationOriginLock);\n\n\t/* write out the CRC */\n\tFIN_CRC32C(crc);\n\terrno = 0;\n\tif ((write(tmpfd, &crc, sizeof(crc))) != sizeof(crc))\n\t{\n\t\t/* if write didn't set errno, assume problem is no disk space */\n\t\tif (errno == 0)\n\t\t\terrno = ENOSPC;\n\t\tereport(PANIC,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\",\n\t\t\t\t\t\ttmppath)));\n\t}\n\n\tif (CloseTransientFile(tmpfd) != 0)\n\t\tereport(PANIC,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not close file \\\"%s\\\": %m\",\n\t\t\t\t\t\ttmppath)));\n\n\t/* fsync, rename to permanent file, fsync file and directory */\n\tdurable_rename(tmppath, path, PANIC);\n}", "path": "postgres/src/backend/replication/logical/origin.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "postgres/postgres", "stars": 14240, "license": "other", "language": "c", "size": 541268}
{"docstring": "/*\n * Return oid of a replication origin.\n */\n", "func_signal": "Datum\npg_replication_origin_oid(PG_FUNCTION_ARGS)", "code": "{\n\tchar\t   *name;\n\tRepOriginId roident;\n\n\treplorigin_check_prerequisites(false, false);\n\n\tname = text_to_cstring((text *) DatumGetPointer(PG_GETARG_DATUM(0)));\n\troident = replorigin_by_name(name, true);\n\n\tpfree(name);\n\n\tif (OidIsValid(roident))\n\t\tPG_RETURN_OID(roident);\n\tPG_RETURN_NULL();\n}", "path": "postgres/src/backend/replication/logical/origin.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "postgres/postgres", "stars": 14240, "license": "other", "language": "c", "size": 541268}
{"docstring": "/*\n * Create a replication origin.\n *\n * Needs to be called in a transaction.\n */\n", "func_signal": "RepOriginId\nreplorigin_create(char *roname)", "code": "{\n\tOid\t\t\troident;\n\tHeapTuple\ttuple = NULL;\n\tRelation\trel;\n\tDatum\t\troname_d;\n\tSnapshotData SnapshotDirty;\n\tSysScanDesc scan;\n\tScanKeyData key;\n\n\troname_d = CStringGetTextDatum(roname);\n\n\tAssert(IsTransactionState());\n\n\t/*\n\t * We need the numeric replication origin to be 16bit wide, so we cannot\n\t * rely on the normal oid allocation. Instead we simply scan\n\t * pg_replication_origin for the first unused id. That's not particularly\n\t * efficient, but this should be a fairly infrequent operation - we can\n\t * easily spend a bit more code on this when it turns out it needs to be\n\t * faster.\n\t *\n\t * We handle concurrency by taking an exclusive lock (allowing reads!)\n\t * over the table for the duration of the search. Because we use a \"dirty\n\t * snapshot\" we can read rows that other in-progress sessions have\n\t * written, even though they would be invisible with normal snapshots. Due\n\t * to the exclusive lock there's no danger that new rows can appear while\n\t * we're checking.\n\t */\n\tInitDirtySnapshot(SnapshotDirty);\n\n\trel = table_open(ReplicationOriginRelationId, ExclusiveLock);\n\n\tfor (roident = InvalidOid + 1; roident < PG_UINT16_MAX; roident++)\n\t{\n\t\tbool\t\tnulls[Natts_pg_replication_origin];\n\t\tDatum\t\tvalues[Natts_pg_replication_origin];\n\t\tbool\t\tcollides;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tScanKeyInit(&key,\n\t\t\t\t\tAnum_pg_replication_origin_roident,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(roident));\n\n\t\tscan = systable_beginscan(rel, ReplicationOriginIdentIndex,\n\t\t\t\t\t\t\t\t  true /* indexOK */ ,\n\t\t\t\t\t\t\t\t  &SnapshotDirty,\n\t\t\t\t\t\t\t\t  1, &key);\n\n\t\tcollides = HeapTupleIsValid(systable_getnext(scan));\n\n\t\tsystable_endscan(scan);\n\n\t\tif (!collides)\n\t\t{\n\t\t\t/*\n\t\t\t * Ok, found an unused roident, insert the new row and do a CCI,\n\t\t\t * so our callers can look it up if they want to.\n\t\t\t */\n\t\t\tmemset(&nulls, 0, sizeof(nulls));\n\n\t\t\tvalues[Anum_pg_replication_origin_roident - 1] = ObjectIdGetDatum(roident);\n\t\t\tvalues[Anum_pg_replication_origin_roname - 1] = roname_d;\n\n\t\t\ttuple = heap_form_tuple(RelationGetDescr(rel), values, nulls);\n\t\t\tCatalogTupleInsert(rel, tuple);\n\t\t\tCommandCounterIncrement();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* now release lock again,\t*/\n\ttable_close(rel, ExclusiveLock);\n\n\tif (tuple == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"could not find free replication origin OID\")));\n\n\theap_freetuple(tuple);\n\treturn roident;\n}", "path": "postgres/src/backend/replication/logical/origin.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "postgres/postgres", "stars": 14240, "license": "other", "language": "c", "size": 541268}
{"docstring": "/* ---------------------------------------------------------------------------\n * Functions for handling replication progress.\n * ---------------------------------------------------------------------------\n */\n", "func_signal": "Size\nReplicationOriginShmemSize(void)", "code": "{\n\tSize\t\tsize = 0;\n\n\t/*\n\t * XXX: max_replication_slots is arguably the wrong thing to use, as here\n\t * we keep the replay state of *remote* transactions. But for now it seems\n\t * sufficient to reuse it, rather than introduce a separate GUC.\n\t */\n\tif (max_replication_slots == 0)\n\t\treturn size;\n\n\tsize = add_size(size, offsetof(ReplicationStateCtl, states));\n\n\tsize = add_size(size,\n\t\t\t\t\tmul_size(max_replication_slots, sizeof(ReplicationState)));\n\treturn size;\n}", "path": "postgres/src/backend/replication/logical/origin.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "postgres/postgres", "stars": 14240, "license": "other", "language": "c", "size": 541268}
{"docstring": "/*\n * Setup a replication origin in the shared memory struct if it doesn't\n * already exists and cache access to the specific ReplicationSlot so the\n * array doesn't have to be searched when calling\n * replorigin_session_advance().\n *\n * Obviously only one such cached origin can exist per process and the current\n * cached value can only be set again after the previous value is torn down\n * with replorigin_session_reset().\n */\n", "func_signal": "void\nreplorigin_session_setup(RepOriginId node)", "code": "{\n\tstatic bool registered_cleanup;\n\tint\t\t\ti;\n\tint\t\t\tfree_slot = -1;\n\n\tif (!registered_cleanup)\n\t{\n\t\ton_shmem_exit(ReplicationOriginExitCleanup, 0);\n\t\tregistered_cleanup = true;\n\t}\n\n\tAssert(max_replication_slots > 0);\n\n\tif (session_replication_state != NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"cannot setup replication origin when one is already setup\")));\n\n\t/* Lock exclusively, as we may have to create a new table entry. */\n\tLWLockAcquire(ReplicationOriginLock, LW_EXCLUSIVE);\n\n\t/*\n\t * Search for either an existing slot for the origin, or a free one we can\n\t * use.\n\t */\n\tfor (i = 0; i < max_replication_slots; i++)\n\t{\n\t\tReplicationState *curstate = &replication_states[i];\n\n\t\t/* remember where to insert if necessary */\n\t\tif (curstate->roident == InvalidRepOriginId &&\n\t\t\tfree_slot == -1)\n\t\t{\n\t\t\tfree_slot = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* not our slot */\n\t\tif (curstate->roident != node)\n\t\t\tcontinue;\n\n\t\telse if (curstate->acquired_by != 0)\n\t\t{\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OBJECT_IN_USE),\n\t\t\t\t\t errmsg(\"replication origin with OID %d is already active for PID %d\",\n\t\t\t\t\t\t\tcurstate->roident, curstate->acquired_by)));\n\t\t}\n\n\t\t/* ok, found slot */\n\t\tsession_replication_state = curstate;\n\t}\n\n\n\tif (session_replication_state == NULL && free_slot == -1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"could not find free replication state slot for replication origin with OID %u\",\n\t\t\t\t\t\tnode),\n\t\t\t\t errhint(\"Increase max_replication_slots and try again.\")));\n\telse if (session_replication_state == NULL)\n\t{\n\t\t/* initialize new slot */\n\t\tsession_replication_state = &replication_states[free_slot];\n\t\tAssert(session_replication_state->remote_lsn == InvalidXLogRecPtr);\n\t\tAssert(session_replication_state->local_lsn == InvalidXLogRecPtr);\n\t\tsession_replication_state->roident = node;\n\t}\n\n\n\tAssert(session_replication_state->roident != InvalidRepOriginId);\n\n\tsession_replication_state->acquired_by = MyProcPid;\n\n\tLWLockRelease(ReplicationOriginLock);\n\n\t/* probably this one is pointless */\n\tConditionVariableBroadcast(&session_replication_state->origin_cv);\n}", "path": "postgres/src/backend/replication/logical/origin.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "postgres/postgres", "stars": 14240, "license": "other", "language": "c", "size": 541268}
{"docstring": "/*\n * Reset previously setup origin in this session\n */\n", "func_signal": "Datum\npg_replication_origin_session_reset(PG_FUNCTION_ARGS)", "code": "{\n\treplorigin_check_prerequisites(true, false);\n\n\treplorigin_session_reset();\n\n\treplorigin_session_origin = InvalidRepOriginId;\n\treplorigin_session_origin_lsn = InvalidXLogRecPtr;\n\treplorigin_session_origin_timestamp = 0;\n\n\tPG_RETURN_VOID();\n}", "path": "postgres/src/backend/replication/logical/origin.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "postgres/postgres", "stars": 14240, "license": "other", "language": "c", "size": 541268}
{"docstring": "/*\n * Drop replication origin.\n */\n", "func_signal": "Datum\npg_replication_origin_drop(PG_FUNCTION_ARGS)", "code": "{\n\tchar\t   *name;\n\tRepOriginId roident;\n\n\treplorigin_check_prerequisites(false, false);\n\n\tname = text_to_cstring((text *) DatumGetPointer(PG_GETARG_DATUM(0)));\n\n\troident = replorigin_by_name(name, false);\n\tAssert(OidIsValid(roident));\n\n\treplorigin_drop(roident, true);\n\n\tpfree(name);\n\n\tPG_RETURN_VOID();\n}", "path": "postgres/src/backend/replication/logical/origin.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "postgres/postgres", "stars": 14240, "license": "other", "language": "c", "size": 541268}
{"docstring": "/*\n * Create replication origin for the passed in name, and return the assigned\n * oid.\n */\n", "func_signal": "Datum\npg_replication_origin_create(PG_FUNCTION_ARGS)", "code": "{\n\tchar\t   *name;\n\tRepOriginId roident;\n\n\treplorigin_check_prerequisites(false, false);\n\n\tname = text_to_cstring((text *) DatumGetPointer(PG_GETARG_DATUM(0)));\n\n\t/* Replication origins \"pg_xxx\" are reserved for internal use */\n\tif (IsReservedName(name))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_RESERVED_NAME),\n\t\t\t\t errmsg(\"replication origin name \\\"%s\\\" is reserved\",\n\t\t\t\t\t\tname),\n\t\t\t\t errdetail(\"Origin names starting with \\\"pg_\\\" are reserved.\")));\n\n\t/*\n\t * If built with appropriate switch, whine when regression-testing\n\t * conventions for replication origin names are violated.\n\t */\n#ifdef ENFORCE_REGRESSION_TEST_NAME_RESTRICTIONS\n\tif (strncmp(name, \"regress_\", 8) != 0)\n\t\telog(WARNING, \"replication origins created by regression test cases should have names starting with \\\"regress_\\\"\");\n#endif\n\n\troident = replorigin_create(name);\n\n\tpfree(name);\n\n\tPG_RETURN_OID(roident);\n}", "path": "postgres/src/backend/replication/logical/origin.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "postgres/postgres", "stars": 14240, "license": "other", "language": "c", "size": 541268}
{"docstring": "/*\n * Return the replication progress for origin setup in the current session.\n *\n * If 'flush' is set to true it is ensured that the returned value corresponds\n * to a local transaction that has been flushed. This is useful if asynchronous\n * commits are used when replaying replicated transactions.\n */\n", "func_signal": "Datum\npg_replication_origin_session_progress(PG_FUNCTION_ARGS)", "code": "{\n\tXLogRecPtr\tremote_lsn = InvalidXLogRecPtr;\n\tbool\t\tflush = PG_GETARG_BOOL(0);\n\n\treplorigin_check_prerequisites(true, false);\n\n\tif (session_replication_state == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"no replication origin is configured\")));\n\n\tremote_lsn = replorigin_session_get_progress(flush);\n\n\tif (remote_lsn == InvalidXLogRecPtr)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_LSN(remote_lsn);\n}", "path": "postgres/src/backend/replication/logical/origin.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "postgres/postgres", "stars": 14240, "license": "other", "language": "c", "size": 541268}
{"docstring": "/*\n * Tell the replication origin progress machinery that a commit from 'node'\n * that originated at the LSN remote_commit on the remote node was replayed\n * successfully and that we don't need to do so again. In combination with\n * setting up replorigin_session_origin_lsn and replorigin_session_origin\n * that ensures we won't loose knowledge about that after a crash if the\n * transaction had a persistent effect (think of asynchronous commits).\n *\n * local_commit needs to be a local LSN of the commit so that we can make sure\n * upon a checkpoint that enough WAL has been persisted to disk.\n *\n * Needs to be called with a RowExclusiveLock on pg_replication_origin,\n * unless running in recovery.\n */\n", "func_signal": "void\nreplorigin_advance(RepOriginId node,\n\t\t\t\t   XLogRecPtr remote_commit, XLogRecPtr local_commit,\n\t\t\t\t   bool go_backward, bool wal_log)", "code": "{\n\tint\t\t\ti;\n\tReplicationState *replication_state = NULL;\n\tReplicationState *free_state = NULL;\n\n\tAssert(node != InvalidRepOriginId);\n\n\t/* we don't track DoNotReplicateId */\n\tif (node == DoNotReplicateId)\n\t\treturn;\n\n\t/*\n\t * XXX: For the case where this is called by WAL replay, it'd be more\n\t * efficient to restore into a backend local hashtable and only dump into\n\t * shmem after recovery is finished. Let's wait with implementing that\n\t * till it's shown to be a measurable expense\n\t */\n\n\t/* Lock exclusively, as we may have to create a new table entry. */\n\tLWLockAcquire(ReplicationOriginLock, LW_EXCLUSIVE);\n\n\t/*\n\t * Search for either an existing slot for the origin, or a free one we can\n\t * use.\n\t */\n\tfor (i = 0; i < max_replication_slots; i++)\n\t{\n\t\tReplicationState *curstate = &replication_states[i];\n\n\t\t/* remember where to insert if necessary */\n\t\tif (curstate->roident == InvalidRepOriginId &&\n\t\t\tfree_state == NULL)\n\t\t{\n\t\t\tfree_state = curstate;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* not our slot */\n\t\tif (curstate->roident != node)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* ok, found slot */\n\t\treplication_state = curstate;\n\n\t\tLWLockAcquire(&replication_state->lock, LW_EXCLUSIVE);\n\n\t\t/* Make sure it's not used by somebody else */\n\t\tif (replication_state->acquired_by != 0)\n\t\t{\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OBJECT_IN_USE),\n\t\t\t\t\t errmsg(\"replication origin with OID %d is already active for PID %d\",\n\t\t\t\t\t\t\treplication_state->roident,\n\t\t\t\t\t\t\treplication_state->acquired_by)));\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (replication_state == NULL && free_state == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"could not find free replication state slot for replication origin with OID %u\",\n\t\t\t\t\t\tnode),\n\t\t\t\t errhint(\"Increase max_replication_slots and try again.\")));\n\n\tif (replication_state == NULL)\n\t{\n\t\t/* initialize new slot */\n\t\tLWLockAcquire(&free_state->lock, LW_EXCLUSIVE);\n\t\treplication_state = free_state;\n\t\tAssert(replication_state->remote_lsn == InvalidXLogRecPtr);\n\t\tAssert(replication_state->local_lsn == InvalidXLogRecPtr);\n\t\treplication_state->roident = node;\n\t}\n\n\tAssert(replication_state->roident != InvalidRepOriginId);\n\n\t/*\n\t * If somebody \"forcefully\" sets this slot, WAL log it, so it's durable\n\t * and the standby gets the message. Primarily this will be called during\n\t * WAL replay (of commit records) where no WAL logging is necessary.\n\t */\n\tif (wal_log)\n\t{\n\t\txl_replorigin_set xlrec;\n\n\t\txlrec.remote_lsn = remote_commit;\n\t\txlrec.node_id = node;\n\t\txlrec.force = go_backward;\n\n\t\tXLogBeginInsert();\n\t\tXLogRegisterData((char *) (&xlrec), sizeof(xlrec));\n\n\t\tXLogInsert(RM_REPLORIGIN_ID, XLOG_REPLORIGIN_SET);\n\t}\n\n\t/*\n\t * Due to - harmless - race conditions during a checkpoint we could see\n\t * values here that are older than the ones we already have in memory.\n\t * Don't overwrite those.\n\t */\n\tif (go_backward || replication_state->remote_lsn < remote_commit)\n\t\treplication_state->remote_lsn = remote_commit;\n\tif (local_commit != InvalidXLogRecPtr &&\n\t\t(go_backward || replication_state->local_lsn < local_commit))\n\t\treplication_state->local_lsn = local_commit;\n\tLWLockRelease(&replication_state->lock);\n\n\t/*\n\t * Release *after* changing the LSNs, slot isn't acquired and thus could\n\t * otherwise be dropped anytime.\n\t */\n\tLWLockRelease(ReplicationOriginLock);\n}", "path": "postgres/src/backend/replication/logical/origin.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "postgres/postgres", "stars": 14240, "license": "other", "language": "c", "size": 541268}
{"docstring": "/*\n * Recover replication replay status from checkpoint data saved earlier by\n * CheckPointReplicationOrigin.\n *\n * This only needs to be called at startup and *not* during every checkpoint\n * read during recovery (e.g. in HS or PITR from a base backup) afterwards. All\n * state thereafter can be recovered by looking at commit records.\n */\n", "func_signal": "void\nStartupReplicationOrigin(void)", "code": "{\n\tconst char *path = \"pg_logical/replorigin_checkpoint\";\n\tint\t\t\tfd;\n\tint\t\t\treadBytes;\n\tuint32\t\tmagic = REPLICATION_STATE_MAGIC;\n\tint\t\t\tlast_state = 0;\n\tpg_crc32c\tfile_crc;\n\tpg_crc32c\tcrc;\n\n\t/* don't want to overwrite already existing state */\n#ifdef USE_ASSERT_CHECKING\n\tstatic bool already_started = false;\n\n\tAssert(!already_started);\n\talready_started = true;\n#endif\n\n\tif (max_replication_slots == 0)\n\t\treturn;\n\n\tINIT_CRC32C(crc);\n\n\telog(DEBUG2, \"starting up replication origin progress state\");\n\n\tfd = OpenTransientFile(path, O_RDONLY | PG_BINARY);\n\n\t/*\n\t * might have had max_replication_slots == 0 last run, or we just brought\n\t * up a standby.\n\t */\n\tif (fd < 0 && errno == ENOENT)\n\t\treturn;\n\telse if (fd < 0)\n\t\tereport(PANIC,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\",\n\t\t\t\t\t\tpath)));\n\n\t/* verify magic, that is written even if nothing was active */\n\treadBytes = read(fd, &magic, sizeof(magic));\n\tif (readBytes != sizeof(magic))\n\t{\n\t\tif (readBytes < 0)\n\t\t\tereport(PANIC,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tpath)));\n\t\telse\n\t\t\tereport(PANIC,\n\t\t\t\t\t(errcode(ERRCODE_DATA_CORRUPTED),\n\t\t\t\t\t errmsg(\"could not read file \\\"%s\\\": read %d of %zu\",\n\t\t\t\t\t\t\tpath, readBytes, sizeof(magic))));\n\t}\n\tCOMP_CRC32C(crc, &magic, sizeof(magic));\n\n\tif (magic != REPLICATION_STATE_MAGIC)\n\t\tereport(PANIC,\n\t\t\t\t(errmsg(\"replication checkpoint has wrong magic %u instead of %u\",\n\t\t\t\t\t\tmagic, REPLICATION_STATE_MAGIC)));\n\n\t/* we can skip locking here, no other access is possible */\n\n\t/* recover individual states, until there are no more to be found */\n\twhile (true)\n\t{\n\t\tReplicationStateOnDisk disk_state;\n\n\t\treadBytes = read(fd, &disk_state, sizeof(disk_state));\n\n\t\t/* no further data */\n\t\tif (readBytes == sizeof(crc))\n\t\t{\n\t\t\t/* not pretty, but simple ... */\n\t\t\tfile_crc = *(pg_crc32c *) &disk_state;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (readBytes < 0)\n\t\t{\n\t\t\tereport(PANIC,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tpath)));\n\t\t}\n\n\t\tif (readBytes != sizeof(disk_state))\n\t\t{\n\t\t\tereport(PANIC,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read file \\\"%s\\\": read %d of %zu\",\n\t\t\t\t\t\t\tpath, readBytes, sizeof(disk_state))));\n\t\t}\n\n\t\tCOMP_CRC32C(crc, &disk_state, sizeof(disk_state));\n\n\t\tif (last_state == max_replication_slots)\n\t\t\tereport(PANIC,\n\t\t\t\t\t(errcode(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"could not find free replication state, increase max_replication_slots\")));\n\n\t\t/* copy data to shared memory */\n\t\treplication_states[last_state].roident = disk_state.roident;\n\t\treplication_states[last_state].remote_lsn = disk_state.remote_lsn;\n\t\tlast_state++;\n\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"recovered replication state of node %u to %X/%X\",\n\t\t\t\t\t\tdisk_state.roident,\n\t\t\t\t\t\t(uint32) (disk_state.remote_lsn >> 32),\n\t\t\t\t\t\t(uint32) disk_state.remote_lsn)));\n\t}\n\n\t/* now check checksum */\n\tFIN_CRC32C(crc);\n\tif (file_crc != crc)\n\t\tereport(PANIC,\n\t\t\t\t(errcode(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"replication slot checkpoint has wrong checksum %u, expected %u\",\n\t\t\t\t\t\tcrc, file_crc)));\n\n\tif (CloseTransientFile(fd) != 0)\n\t\tereport(PANIC,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not close file \\\"%s\\\": %m\",\n\t\t\t\t\t\tpath)));\n}", "path": "postgres/src/backend/replication/logical/origin.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "postgres/postgres", "stars": 14240, "license": "other", "language": "c", "size": 541268}
{"docstring": "/*\n * Check for a persistent replication origin identified by name.\n *\n * Returns InvalidOid if the node isn't known yet and missing_ok is true.\n */\n", "func_signal": "RepOriginId\nreplorigin_by_name(char *roname, bool missing_ok)", "code": "{\n\tForm_pg_replication_origin ident;\n\tOid\t\t\troident = InvalidOid;\n\tHeapTuple\ttuple;\n\tDatum\t\troname_d;\n\n\troname_d = CStringGetTextDatum(roname);\n\n\ttuple = SearchSysCache1(REPLORIGNAME, roname_d);\n\tif (HeapTupleIsValid(tuple))\n\t{\n\t\tident = (Form_pg_replication_origin) GETSTRUCT(tuple);\n\t\troident = ident->roident;\n\t\tReleaseSysCache(tuple);\n\t}\n\telse if (!missing_ok)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"replication origin \\\"%s\\\" does not exist\",\n\t\t\t\t\t\troname)));\n\n\treturn roident;\n}", "path": "postgres/src/backend/replication/logical/origin.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "postgres/postgres", "stars": 14240, "license": "other", "language": "c", "size": 541268}
{"docstring": "/*\n * Has a replication origin been setup for this session.\n */\n", "func_signal": "Datum\npg_replication_origin_session_is_setup(PG_FUNCTION_ARGS)", "code": "{\n\treplorigin_check_prerequisites(false, false);\n\n\tPG_RETURN_BOOL(replorigin_session_origin != InvalidRepOriginId);\n}", "path": "postgres/src/backend/replication/logical/origin.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "postgres/postgres", "stars": 14240, "license": "other", "language": "c", "size": 541268}
{"docstring": "/*\n * Tear down a (possibly) configured session replication origin during process\n * exit.\n */\n", "func_signal": "static void\nReplicationOriginExitCleanup(int code, Datum arg)", "code": "{\n\tConditionVariable *cv = NULL;\n\n\tLWLockAcquire(ReplicationOriginLock, LW_EXCLUSIVE);\n\n\tif (session_replication_state != NULL &&\n\t\tsession_replication_state->acquired_by == MyProcPid)\n\t{\n\t\tcv = &session_replication_state->origin_cv;\n\n\t\tsession_replication_state->acquired_by = 0;\n\t\tsession_replication_state = NULL;\n\t}\n\n\tLWLockRelease(ReplicationOriginLock);\n\n\tif (cv)\n\t\tConditionVariableBroadcast(cv);\n}", "path": "postgres/src/backend/replication/logical/origin.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "postgres/postgres", "stars": 14240, "license": "other", "language": "c", "size": 541268}
{"docstring": "/*\n * Lookup replication origin via its oid and return the name.\n *\n * The external name is palloc'd in the calling context.\n *\n * Returns true if the origin is known, false otherwise.\n */\n", "func_signal": "bool\nreplorigin_by_oid(RepOriginId roident, bool missing_ok, char **roname)", "code": "{\n\tHeapTuple\ttuple;\n\tForm_pg_replication_origin ric;\n\n\tAssert(OidIsValid((Oid) roident));\n\tAssert(roident != InvalidRepOriginId);\n\tAssert(roident != DoNotReplicateId);\n\n\ttuple = SearchSysCache1(REPLORIGIDENT,\n\t\t\t\t\t\t\tObjectIdGetDatum((Oid) roident));\n\n\tif (HeapTupleIsValid(tuple))\n\t{\n\t\tric = (Form_pg_replication_origin) GETSTRUCT(tuple);\n\t\t*roname = text_to_cstring(&ric->roname);\n\t\tReleaseSysCache(tuple);\n\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\t*roname = NULL;\n\n\t\tif (!missing_ok)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"replication origin with OID %u does not exist\",\n\t\t\t\t\t\t\troident)));\n\n\t\treturn false;\n\t}\n}", "path": "postgres/src/backend/replication/logical/origin.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "postgres/postgres", "stars": 14240, "license": "other", "language": "c", "size": 541268}
{"docstring": "/*\n * Ask the machinery about the point up to which we successfully replayed\n * changes from an already setup replication origin.\n */\n", "func_signal": "XLogRecPtr\nreplorigin_session_get_progress(bool flush)", "code": "{\n\tXLogRecPtr\tremote_lsn;\n\tXLogRecPtr\tlocal_lsn;\n\n\tAssert(session_replication_state != NULL);\n\n\tLWLockAcquire(&session_replication_state->lock, LW_SHARED);\n\tremote_lsn = session_replication_state->remote_lsn;\n\tlocal_lsn = session_replication_state->local_lsn;\n\tLWLockRelease(&session_replication_state->lock);\n\n\tif (flush && local_lsn != InvalidXLogRecPtr)\n\t\tXLogFlush(local_lsn);\n\n\treturn remote_lsn;\n}", "path": "postgres/src/backend/replication/logical/origin.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "postgres/postgres", "stars": 14240, "license": "other", "language": "c", "size": 541268}
{"docstring": "/*\n * Do the same work replorigin_advance() does, just on the session's\n * configured origin.\n *\n * This is noticeably cheaper than using replorigin_advance().\n */\n", "func_signal": "void\nreplorigin_session_advance(XLogRecPtr remote_commit, XLogRecPtr local_commit)", "code": "{\n\tAssert(session_replication_state != NULL);\n\tAssert(session_replication_state->roident != InvalidRepOriginId);\n\n\tLWLockAcquire(&session_replication_state->lock, LW_EXCLUSIVE);\n\tif (session_replication_state->local_lsn < local_commit)\n\t\tsession_replication_state->local_lsn = local_commit;\n\tif (session_replication_state->remote_lsn < remote_commit)\n\t\tsession_replication_state->remote_lsn = remote_commit;\n\tLWLockRelease(&session_replication_state->lock);\n}", "path": "postgres/src/backend/replication/logical/origin.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "postgres/postgres", "stars": 14240, "license": "other", "language": "c", "size": 541268}
{"docstring": "/*\n * Are there special vdevs?\n */\n", "func_signal": "boolean_t\nzfs_special_devs(nvlist_t *nv, char *type)", "code": "{\n\tchar *bias;\n\tuint_t c;\n\tnvlist_t **child;\n\tuint_t children;\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) != 0) {\n\t\treturn (B_FALSE);\n\t}\n\tfor (c = 0; c < children; c++) {\n\t\tif (nvlist_lookup_string(child[c], ZPOOL_CONFIG_ALLOCATION_BIAS,\n\t\t    &bias) == 0) {\n\t\t\tif (strcmp(bias, VDEV_ALLOC_BIAS_SPECIAL) == 0 ||\n\t\t\t    strcmp(bias, VDEV_ALLOC_BIAS_DEDUP) == 0) {\n\t\t\t\tif (type != NULL && strcmp(bias, type) == 0) {\n\t\t\t\t\treturn (B_TRUE);\n\t\t\t\t} else if (type == NULL) {\n\t\t\t\t\treturn (B_TRUE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn (B_FALSE);\n}", "path": "zfs/module/zcommon/zfs_comutil.c", "commit_date": "2020-01-06 00:00:00", "repo_name": "openzfs/zfs", "stars": 10006, "license": "other", "language": "c", "size": 127681}
{"docstring": "/*\n * Synctask for updating redaction lists.  We first take this txg's list of\n * redacted blocks and append those to the redaction list.  We then update the\n * redaction list's bonus buffer.  We store the furthest blocks we visited and\n * the list of snapshots that we're redacting with respect to.  We need these so\n * that redacted sends and receives can be correctly resumed.\n */\n", "func_signal": "static void\nredaction_list_update_sync(void *arg, dmu_tx_t *tx)", "code": "{\n\tstruct merge_data *md = arg;\n\tuint64_t txg = dmu_tx_get_txg(tx);\n\tlist_t *list = &md->md_blocks[txg & TXG_MASK];\n\tredact_block_phys_t *furthest_visited =\n\t    &md->md_furthest[txg & TXG_MASK];\n\tobjset_t *mos = tx->tx_pool->dp_meta_objset;\n\tredaction_list_t *rl = md->md_redaction_list;\n\tint bufsize = redact_sync_bufsize;\n\tredact_block_phys_t *buf = kmem_alloc(bufsize * sizeof (*buf),\n\t    KM_SLEEP);\n\tint index = 0;\n\n\tdmu_buf_will_dirty(rl->rl_dbuf, tx);\n\n\tfor (struct redact_block_list_node *rbln = list_remove_head(list);\n\t    rbln != NULL; rbln = list_remove_head(list)) {\n\t\tASSERT3U(rbln->block.rbp_object, <=,\n\t\t    furthest_visited->rbp_object);\n\t\tASSERT(rbln->block.rbp_object < furthest_visited->rbp_object ||\n\t\t    rbln->block.rbp_blkid <= furthest_visited->rbp_blkid);\n\t\tbuf[index] = rbln->block;\n\t\tindex++;\n\t\tif (index == bufsize) {\n\t\t\tdmu_write(mos, rl->rl_object,\n\t\t\t    rl->rl_phys->rlp_num_entries * sizeof (*buf),\n\t\t\t    bufsize * sizeof (*buf), buf, tx);\n\t\t\trl->rl_phys->rlp_num_entries += bufsize;\n\t\t\tindex = 0;\n\t\t}\n\t\tkmem_free(rbln, sizeof (*rbln));\n\t}\n\tif (index > 0) {\n\t\tdmu_write(mos, rl->rl_object, rl->rl_phys->rlp_num_entries *\n\t\t    sizeof (*buf), index * sizeof (*buf), buf, tx);\n\t\trl->rl_phys->rlp_num_entries += index;\n\t}\n\tkmem_free(buf, bufsize * sizeof (*buf));\n\n\tmd->md_synctask_txg[txg & TXG_MASK] = B_FALSE;\n\trl->rl_phys->rlp_last_object = furthest_visited->rbp_object;\n\trl->rl_phys->rlp_last_blkid = furthest_visited->rbp_blkid;\n}", "path": "zfs/module/zfs/dmu_redact.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "openzfs/zfs", "stars": 10006, "license": "other", "language": "c", "size": 127681}
{"docstring": "/*\n * Returns TRUE if the property is visible (not hidden).\n */\n", "func_signal": "boolean_t\nzfs_prop_visible(zfs_prop_t prop)", "code": "{\n\treturn (zfs_prop_table[prop].pd_visible &&\n\t    zfs_prop_table[prop].pd_zfs_mod_supported);\n}", "path": "zfs/module/zcommon/zfs_prop.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "openzfs/zfs", "stars": 10006, "license": "other", "language": "c", "size": 127681}
{"docstring": "/*\n * We've found a new redaction candidate.  In order to improve performance, we\n * coalesce these blocks when they're adjacent to each other.  This function\n * handles that.  If the new candidate block range is immediately after the\n * range we're building, coalesce it into the range we're building.  Otherwise,\n * put the record we're building on the queue, and update the build pointer to\n * point to the new record.\n */\n", "func_signal": "static void\nrecord_merge_enqueue(bqueue_t *q, struct redact_record **build,\n    struct redact_record *new)", "code": "{\n\tif (new->eos_marker) {\n\t\tif (*build != NULL)\n\t\t\tbqueue_enqueue(q, *build, sizeof (*build));\n\t\tbqueue_enqueue_flush(q, new, sizeof (*new));\n\t\treturn;\n\t}\n\tif (*build == NULL) {\n\t\t*build = new;\n\t\treturn;\n\t}\n\tstruct redact_record *curbuild = *build;\n\tif ((curbuild->end_object == new->start_object &&\n\t    curbuild->end_blkid + 1 == new->start_blkid &&\n\t    curbuild->end_blkid != UINT64_MAX) ||\n\t    (curbuild->end_object + 1 == new->start_object &&\n\t    curbuild->end_blkid == UINT64_MAX && new->start_blkid == 0)) {\n\t\tcurbuild->end_object = new->end_object;\n\t\tcurbuild->end_blkid = new->end_blkid;\n\t\tkmem_free(new, sizeof (*new));\n\t} else {\n\t\tbqueue_enqueue(q, curbuild, sizeof (*curbuild));\n\t\t*build = new;\n\t}\n}", "path": "zfs/module/zfs/dmu_redact.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "openzfs/zfs", "stars": 10006, "license": "other", "language": "c", "size": 127681}
{"docstring": "/*\n * Remove the given redaction node from both trees, pull a new redaction record\n * off the queue, free the old redaction record, update the redaction node, and\n * reinsert the node into the trees.\n */\n", "func_signal": "static int\nupdate_avl_trees(avl_tree_t *start_tree, avl_tree_t *end_tree,\n    struct redact_node *redact_node)", "code": "{\n\tavl_remove(start_tree, redact_node);\n\tavl_remove(end_tree, redact_node);\n\tredact_node->record = get_next_redact_record(&redact_node->rt_arg->q,\n\t    redact_node->record);\n\tavl_add(end_tree, redact_node);\n\tavl_add(start_tree, redact_node);\n\treturn (redact_node->rt_arg->error_code);\n}", "path": "zfs/module/zfs/dmu_redact.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "openzfs/zfs", "stars": 10006, "license": "other", "language": "c", "size": 127681}
{"docstring": "/*\n * This is a utility function that can do the comparison for the start or ends\n * of the ranges in a redact_record.\n */\n", "func_signal": "static int\nredact_range_compare(uint64_t obj1, uint64_t off1, uint32_t dbss1,\n    uint64_t obj2, uint64_t off2, uint32_t dbss2)", "code": "{\n\tzbookmark_phys_t z1, z2;\n\tcreate_zbookmark_from_obj_off(&z1, obj1, off1);\n\tcreate_zbookmark_from_obj_off(&z2, obj2, off2);\n\n\treturn (zbookmark_compare(dbss1 >> SPA_MINBLOCKSHIFT, 0,\n\t    dbss2 >> SPA_MINBLOCKSHIFT, 0, &z1, &z2));\n}", "path": "zfs/module/zfs/dmu_redact.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "openzfs/zfs", "stars": 10006, "license": "other", "language": "c", "size": 127681}
{"docstring": "/*\n * Returns TRUE if the property is inheritable.\n */\n", "func_signal": "boolean_t\nzfs_prop_inheritable(zfs_prop_t prop)", "code": "{\n\treturn (zfs_prop_table[prop].pd_attr == PROP_INHERIT ||\n\t    zfs_prop_table[prop].pd_attr == PROP_ONETIME);\n}", "path": "zfs/module/zcommon/zfs_prop.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "openzfs/zfs", "stars": 10006, "license": "other", "language": "c", "size": 127681}
{"docstring": "/*\n * Returns TRUE if the property is readonly.\n */\n", "func_signal": "boolean_t\nzfs_prop_readonly(zfs_prop_t prop)", "code": "{\n\treturn (zfs_prop_table[prop].pd_attr == PROP_READONLY ||\n\t    zfs_prop_table[prop].pd_attr == PROP_ONETIME ||\n\t    zfs_prop_table[prop].pd_attr == PROP_ONETIME_DEFAULT);\n}", "path": "zfs/module/zcommon/zfs_prop.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "openzfs/zfs", "stars": 10006, "license": "other", "language": "c", "size": 127681}
{"docstring": "/*\n * Helper function used by both kernelspace and userspace to check the\n * keylocation property. If encrypted is set, the keylocation must be valid\n * for an encrypted dataset.\n */\n", "func_signal": "boolean_t\nzfs_prop_valid_keylocation(const char *str, boolean_t encrypted)", "code": "{\n\tif (strcmp(\"none\", str) == 0)\n\t\treturn (!encrypted);\n\telse if (strcmp(\"prompt\", str) == 0)\n\t\treturn (B_TRUE);\n\telse if (strlen(str) > 8 && strncmp(\"file:///\", str, 8) == 0)\n\t\treturn (B_TRUE);\n\n\treturn (B_FALSE);\n}", "path": "zfs/module/zcommon/zfs_prop.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "openzfs/zfs", "stars": 10006, "license": "other", "language": "c", "size": 127681}
{"docstring": "/*\n * Returns true if this is a valid user-defined property (one with a ':').\n */\n", "func_signal": "boolean_t\nzfs_prop_user(const char *name)", "code": "{\n\tint i;\n\tchar c;\n\tboolean_t foundsep = B_FALSE;\n\n\tfor (i = 0; i < strlen(name); i++) {\n\t\tc = name[i];\n\t\tif (!valid_char(c))\n\t\t\treturn (B_FALSE);\n\t\tif (c == ':')\n\t\t\tfoundsep = B_TRUE;\n\t}\n\n\tif (!foundsep)\n\t\treturn (B_FALSE);\n\n\treturn (B_TRUE);\n}", "path": "zfs/module/zcommon/zfs_prop.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "openzfs/zfs", "stars": 10006, "license": "other", "language": "c", "size": 127681}
{"docstring": "/*\n * We want to store the list of blocks that we're redacting in the bookmark's\n * redaction list.  However, this list is stored in the MOS, which means it can\n * only be written to in syncing context.  To get around this, we create a\n * synctask that will write to the mos for us.  We tell it what to write by\n * a linked list for each current transaction group; every time we decide to\n * redact a block, we append it to the transaction group that is currently in\n * open context.  We also update some progress information that the synctask\n * will store to enable resumable redacted sends.\n */\n", "func_signal": "static void\nupdate_redaction_list(struct merge_data *md, objset_t *os,\n    uint64_t object, uint64_t blkid, uint64_t endblkid, uint32_t blksz)", "code": "{\n\tboolean_t enqueue = B_FALSE;\n\tredact_block_phys_t cur = {0};\n\tuint64_t count = endblkid - blkid + 1;\n\twhile (count > REDACT_BLOCK_MAX_COUNT) {\n\t\tupdate_redaction_list(md, os, object, blkid,\n\t\t    blkid + REDACT_BLOCK_MAX_COUNT - 1, blksz);\n\t\tblkid += REDACT_BLOCK_MAX_COUNT;\n\t\tcount -= REDACT_BLOCK_MAX_COUNT;\n\t}\n\tredact_block_phys_t *coalesce = &md->md_coalesce_block;\n\tboolean_t new;\n\tif (coalesce->rbp_size_count == 0) {\n\t\tnew = B_TRUE;\n\t\tenqueue = B_FALSE;\n\t} else  {\n\t\tuint64_t old_count = redact_block_get_count(coalesce);\n\t\tif (coalesce->rbp_object == object &&\n\t\t    coalesce->rbp_blkid + old_count == blkid &&\n\t\t    old_count + count <= REDACT_BLOCK_MAX_COUNT) {\n\t\t\tASSERT3U(redact_block_get_size(coalesce), ==, blksz);\n\t\t\tredact_block_set_count(coalesce, old_count + count);\n\t\t\tnew = B_FALSE;\n\t\t\tenqueue = B_FALSE;\n\t\t} else {\n\t\t\tnew = B_TRUE;\n\t\t\tenqueue = B_TRUE;\n\t\t}\n\t}\n\n\tif (new) {\n\t\tcur = *coalesce;\n\t\tcoalesce->rbp_blkid = blkid;\n\t\tcoalesce->rbp_object = object;\n\n\t\tredact_block_set_count(coalesce, count);\n\t\tredact_block_set_size(coalesce, blksz);\n\t}\n\n\tif (enqueue && redact_block_get_size(&cur) != 0) {\n\t\tstruct redact_block_list_node *rbln =\n\t\t    kmem_alloc(sizeof (struct redact_block_list_node),\n\t\t    KM_SLEEP);\n\t\trbln->block = cur;\n\t\tlist_insert_tail(&md->md_redact_block_pending, rbln);\n\t}\n\n\tif (gethrtime() > md->md_last_time +\n\t    redaction_list_update_interval_ns) {\n\t\tcommit_rl_updates(os, md, object, blkid);\n\t}\n}", "path": "zfs/module/zfs/dmu_redact.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "openzfs/zfs", "stars": 10006, "license": "other", "language": "c", "size": 127681}
{"docstring": "/*\n * Return the min spa version for a corresponding spa version\n * -1 is returned if no mapping exists.\n */\n", "func_signal": "int\nzfs_spa_version_map(int zpl_version)", "code": "{\n\tint i;\n\tint version = -1;\n\n\tfor (i = 0; zfs_version_table[i].version_zpl; i++) {\n\t\tif (zfs_version_table[i].version_zpl >= zpl_version)\n\t\t\treturn (zfs_version_table[i].version_spa);\n\t}\n\n\treturn (version);\n}", "path": "zfs/module/zcommon/zfs_comutil.c", "commit_date": "2020-01-06 00:00:00", "repo_name": "openzfs/zfs", "stars": 10006, "license": "other", "language": "c", "size": 127681}
{"docstring": "/*\n * Pop a new redaction record off the queue, check that the records are in the\n * right order, and free the old data.\n */\n", "func_signal": "static struct redact_record *\nget_next_redact_record(bqueue_t *bq, struct redact_record *prev)", "code": "{\n\tstruct redact_record *next = bqueue_dequeue(bq);\n\tASSERT(redact_record_before(prev, next));\n\tkmem_free(prev, sizeof (*prev));\n\treturn (next);\n}", "path": "zfs/module/zfs/dmu_redact.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "openzfs/zfs", "stars": 10006, "license": "other", "language": "c", "size": 127681}
{"docstring": "/*\n * Are there allocatable vdevs?\n */\n", "func_signal": "boolean_t\nzfs_allocatable_devs(nvlist_t *nv)", "code": "{\n\tuint64_t is_log;\n\tuint_t c;\n\tnvlist_t **child;\n\tuint_t children;\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) != 0) {\n\t\treturn (B_FALSE);\n\t}\n\tfor (c = 0; c < children; c++) {\n\t\tis_log = 0;\n\t\t(void) nvlist_lookup_uint64(child[c], ZPOOL_CONFIG_IS_LOG,\n\t\t    &is_log);\n\t\tif (!is_log)\n\t\t\treturn (B_TRUE);\n\t}\n\treturn (B_FALSE);\n}", "path": "zfs/module/zcommon/zfs_comutil.c", "commit_date": "2020-01-06 00:00:00", "repo_name": "openzfs/zfs", "stars": 10006, "license": "other", "language": "c", "size": 127681}
{"docstring": "/*\n * Returns TRUE if this property is a string type.  Note that index types\n * (compression, checksum) are treated as strings in userland, even though they\n * are stored numerically on disk.\n */\n", "func_signal": "int\nzfs_prop_is_string(zfs_prop_t prop)", "code": "{\n\treturn (zfs_prop_table[prop].pd_proptype == PROP_TYPE_STRING ||\n\t    zfs_prop_table[prop].pd_proptype == PROP_TYPE_INDEX);\n}", "path": "zfs/module/zcommon/zfs_prop.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "openzfs/zfs", "stars": 10006, "license": "other", "language": "c", "size": 127681}
{"docstring": "/*\n * Returns TRUE if property is one of the encryption properties that requires\n * a loaded encryption key to modify.\n */\n", "func_signal": "boolean_t\nzfs_prop_encryption_key_param(zfs_prop_t prop)", "code": "{\n\t/*\n\t * keylocation does not count as an encryption property. It can be\n\t * changed at will without needing the master keys.\n\t */\n\treturn (prop == ZFS_PROP_PBKDF2_SALT || prop == ZFS_PROP_PBKDF2_ITERS ||\n\t    prop == ZFS_PROP_KEYFORMAT);\n}", "path": "zfs/module/zcommon/zfs_prop.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "openzfs/zfs", "stars": 10006, "license": "other", "language": "c", "size": 127681}
{"docstring": "/*\n * Return the max zpl version for a corresponding spa version\n * -1 is returned if no mapping exists.\n */\n", "func_signal": "int\nzfs_zpl_version_map(int spa_version)", "code": "{\n\tint i;\n\tint version = -1;\n\n\tfor (i = 0; zfs_version_table[i].version_spa; i++) {\n\t\tif (spa_version >= zfs_version_table[i].version_spa)\n\t\t\tversion = zfs_version_table[i].version_zpl;\n\t}\n\n\treturn (version);\n}", "path": "zfs/module/zcommon/zfs_comutil.c", "commit_date": "2020-01-06 00:00:00", "repo_name": "openzfs/zfs", "stars": 10006, "license": "other", "language": "c", "size": 127681}
{"docstring": "/*\n * Returns true if this is a valid written@ property.\n * Note that after the @, any character is valid (eg, another @, for\n * written@pool/fs@origin).\n */\n", "func_signal": "boolean_t\nzfs_prop_written(const char *name)", "code": "{\n\tstatic const char *prop_prefix = \"written@\";\n\tstatic const char *book_prefix = \"written#\";\n\treturn (strncmp(name, prop_prefix, strlen(prop_prefix)) == 0 ||\n\t    strncmp(name, book_prefix, strlen(book_prefix)) == 0);\n}", "path": "zfs/module/zcommon/zfs_prop.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "openzfs/zfs", "stars": 10006, "license": "other", "language": "c", "size": 127681}
{"docstring": "/*\n * Utility function that compares two redaction records to determine if any part\n * of the \"from\" record is before any part of the \"to\" record. Also causes End\n * of Stream redaction records to compare after all others, so that the\n * redaction merging logic can stay simple.\n */\n", "func_signal": "static boolean_t\nredact_record_before(const struct redact_record *from,\n    const struct redact_record *to)", "code": "{\n\tif (from->eos_marker == B_TRUE)\n\t\treturn (B_FALSE);\n\telse if (to->eos_marker == B_TRUE)\n\t\treturn (B_TRUE);\n\treturn (redact_range_compare(from->start_object, from->start_blkid,\n\t    from->datablksz, to->end_object, to->end_blkid,\n\t    to->datablksz) <= 0);\n}", "path": "zfs/module/zfs/dmu_redact.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "openzfs/zfs", "stars": 10006, "license": "other", "language": "c", "size": 127681}
{"docstring": "/*\n * For user property names, we allow all lowercase alphanumeric characters, plus\n * a few useful punctuation characters.\n */\n", "func_signal": "static int\nvalid_char(char c)", "code": "{\n\treturn ((c >= 'a' && c <= 'z') ||\n\t    (c >= '0' && c <= '9') ||\n\t    c == '-' || c == '_' || c == '.' || c == ':');\n}", "path": "zfs/module/zcommon/zfs_prop.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "openzfs/zfs", "stars": 10006, "license": "other", "language": "c", "size": 127681}
{"docstring": "// new/delete hmm_data_t\n", "func_signal": "hmm_data_t *hmm_new_data(int L, const char *seq, const hmm_par_t *hp)", "code": "{\n\thmm_data_t *hd;\n\thd = (hmm_data_t*)calloc(1, sizeof(hmm_data_t));\n\thd->L = L;\n\thd->seq = (char*)malloc(L + 1);\n\tmemcpy(hd->seq + 1, seq, L);\n\treturn hd;\n}", "path": "h2o/deps/klib/khmm.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "h2o/h2o", "stars": 10680, "license": "mit", "language": "c", "size": 119158}
{"docstring": "/* Guess if the user might want to enter more\n * or if he wants an evaluation of his code now */\n", "func_signal": "static mrb_bool\nis_code_block_open(struct mrb_parser_state *parser)", "code": "{\n  mrb_bool code_block_open = FALSE;\n\n  /* check for heredoc */\n  if (parser->parsing_heredoc != NULL) return TRUE;\n\n  /* check for unterminated string */\n  if (parser->lex_strterm) return TRUE;\n\n  /* check if parser error are available */\n  if (0 < parser->nerr) {\n    const char unexpected_end[] = \"syntax error, unexpected $end\";\n    const char *message = parser->error_buffer[0].message;\n\n    /* a parser error occur, we have to check if */\n    /* we need to read one more line or if there is */\n    /* a different issue which we have to show to */\n    /* the user */\n\n    if (strncmp(message, unexpected_end, sizeof(unexpected_end) - 1) == 0) {\n      code_block_open = TRUE;\n    }\n    else if (strcmp(message, \"syntax error, unexpected keyword_end\") == 0) {\n      code_block_open = FALSE;\n    }\n    else if (strcmp(message, \"syntax error, unexpected tREGEXP_BEG\") == 0) {\n      code_block_open = FALSE;\n    }\n    return code_block_open;\n  }\n\n  switch (parser->lstate) {\n\n  /* all states which need more code */\n\n  case EXPR_BEG:\n    /* beginning of a statement, */\n    /* that means previous line ended */\n    code_block_open = FALSE;\n    break;\n  case EXPR_DOT:\n    /* a message dot was the last token, */\n    /* there has to come more */\n    code_block_open = TRUE;\n    break;\n  case EXPR_CLASS:\n    /* a class keyword is not enough! */\n    /* we need also a name of the class */\n    code_block_open = TRUE;\n    break;\n  case EXPR_FNAME:\n    /* a method name is necessary */\n    code_block_open = TRUE;\n    break;\n  case EXPR_VALUE:\n    /* if, elsif, etc. without condition */\n    code_block_open = TRUE;\n    break;\n\n  /* now all the states which are closed */\n\n  case EXPR_ARG:\n    /* an argument is the last token */\n    code_block_open = FALSE;\n    break;\n\n  /* all states which are unsure */\n\n  case EXPR_CMDARG:\n    break;\n  case EXPR_END:\n    /* an expression was ended */\n    break;\n  case EXPR_ENDARG:\n    /* closing parenthese */\n    break;\n  case EXPR_ENDFN:\n    /* definition end */\n    break;\n  case EXPR_MID:\n    /* jump keyword like break, return, ... */\n    break;\n  case EXPR_MAX_STATE:\n    /* don't know what to do with this token */\n    break;\n  default:\n    /* this state is unexpected! */\n    break;\n  }\n\n  return code_block_open;\n}", "path": "h2o/deps/mruby/mrbgems/mruby-bin-mirb/tools/mirb/mirb.c", "commit_date": "2019-02-15 00:00:00", "repo_name": "h2o/h2o", "stars": 10680, "license": "mit", "language": "c", "size": 119158}
{"docstring": "/* This function will create a Huffman tree.\n\n   The catch here is that the tree cannot be arbitrarily deep.\n   Brotli specifies a maximum depth of 15 bits for \"code trees\"\n   and 7 bits for \"code length code trees.\"\n\n   count_limit is the value that is to be faked as the minimum value\n   and this minimum value is raised until the tree matches the\n   maximum length requirement.\n\n   This algorithm is not of excellent performance for very long data blocks,\n   especially when population counts are longer than 2**tree_limit, but\n   we are not planning to use this with extremely long blocks.\n\n   See http://en.wikipedia.org/wiki/Huffman_coding */\n", "func_signal": "void BrotliCreateHuffmanTree(const uint32_t *data,\n                             const size_t length,\n                             const int tree_limit,\n                             HuffmanTree* tree,\n                             uint8_t *depth)", "code": "{\n  uint32_t count_limit;\n  HuffmanTree sentinel;\n  InitHuffmanTree(&sentinel, BROTLI_UINT32_MAX, -1, -1);\n  /* For block sizes below 64 kB, we never need to do a second iteration\n     of this loop. Probably all of our block sizes will be smaller than\n     that, so this loop is mostly of academic interest. If we actually\n     would need this, we would be better off with the Katajainen algorithm. */\n  for (count_limit = 1; ; count_limit *= 2) {\n    size_t n = 0;\n    size_t i;\n    size_t j;\n    size_t k;\n    for (i = length; i != 0;) {\n      --i;\n      if (data[i]) {\n        const uint32_t count = BROTLI_MAX(uint32_t, data[i], count_limit);\n        InitHuffmanTree(&tree[n++], count, -1, (int16_t)i);\n      }\n    }\n\n    if (n == 1) {\n      depth[tree[0].index_right_or_value_] = 1;  /* Only one element. */\n      break;\n    }\n\n    SortHuffmanTreeItems(tree, n, SortHuffmanTree);\n\n    /* The nodes are:\n       [0, n): the sorted leaf nodes that we start with.\n       [n]: we add a sentinel here.\n       [n + 1, 2n): new parent nodes are added here, starting from\n                    (n+1). These are naturally in ascending order.\n       [2n]: we add a sentinel at the end as well.\n       There will be (2n+1) elements at the end. */\n    tree[n] = sentinel;\n    tree[n + 1] = sentinel;\n\n    i = 0;      /* Points to the next leaf node. */\n    j = n + 1;  /* Points to the next non-leaf node. */\n    for (k = n - 1; k != 0; --k) {\n      size_t left, right;\n      if (tree[i].total_count_ <= tree[j].total_count_) {\n        left = i;\n        ++i;\n      } else {\n        left = j;\n        ++j;\n      }\n      if (tree[i].total_count_ <= tree[j].total_count_) {\n        right = i;\n        ++i;\n      } else {\n        right = j;\n        ++j;\n      }\n\n      {\n        /* The sentinel node becomes the parent node. */\n        size_t j_end = 2 * n - k;\n        tree[j_end].total_count_ =\n            tree[left].total_count_ + tree[right].total_count_;\n        tree[j_end].index_left_ = (int16_t)left;\n        tree[j_end].index_right_or_value_ = (int16_t)right;\n\n        /* Add back the last sentinel node. */\n        tree[j_end + 1] = sentinel;\n      }\n    }\n    if (BrotliSetDepth((int)(2 * n - 1), &tree[0], depth, tree_limit)) {\n      /* We need to pack the Huffman tree in tree_limit bits. If this was not\n         successful, add fake entities to the lowest values and retry. */\n      break;\n    }\n  }\n}", "path": "h2o/deps/brotli/c/enc/entropy_encode.c", "commit_date": "2017-12-06 00:00:00", "repo_name": "h2o/h2o", "stars": 10680, "license": "mit", "language": "c", "size": 119158}
{"docstring": "// the EM-Q function\n", "func_signal": "FLOAT hmm_Q(const hmm_par_t *hp, const hmm_exp_t *he)", "code": "{\n\tFLOAT sum = 0.0;\n\tint bb, k, l;\n\tfor (bb = 0; bb != he->m; ++bb) {\n\t\tFLOAT *eb = hp->e[bb], *Eb = he->E[bb];\n\t\tfor (k = 0; k != hp->n; ++k) {\n\t\t\tif (eb[k] <= 0.0) return -HMM_INF;\n\t\t\tsum += Eb[k] * log(eb[k]);\n\t\t}\n\t}\n\tfor (k = 0; k != he->n; ++k) {\n\t\tFLOAT *Ak = he->A[k], *ak = hp->a[k];\n\t\tfor (l = 0; l != he->n; ++l) {\n\t\t\tif (ak[l] <= 0.0) return -HMM_INF;\n\t\t\tsum += Ak[l] * log(ak[l]);\n\t\t}\n\t}\n\treturn (sum -= he->Q0);\n}", "path": "h2o/deps/klib/khmm.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "h2o/h2o", "stars": 10680, "license": "mit", "language": "c", "size": 119158}
{"docstring": "/* Print the command line prompt of the REPL */\n", "func_signal": "static void\nprint_cmdline(int code_block_open)", "code": "{\n  if (code_block_open) {\n    printf(\"* \");\n  }\n  else {\n    printf(\"> \");\n  }\n  fflush(stdout);\n}", "path": "h2o/deps/mruby/mrbgems/mruby-bin-mirb/tools/mirb/mirb.c", "commit_date": "2019-02-15 00:00:00", "repo_name": "h2o/h2o", "stars": 10680, "license": "mit", "language": "c", "size": 119158}
{"docstring": "// simulate sequence\n", "func_signal": "char *hmm_simulate(const hmm_par_t *hp, int L)", "code": "{\n\tint i, k, l, b;\n\tFLOAT x, y, **et;\n\tchar *seq;\n\tseq = (char*)calloc(L+1, 1);\n\t// calculate the transpose of hp->e[][]\n\tet = (FLOAT**)calloc2(hp->n, hp->m, sizeof(FLOAT));\n\tfor (k = 0; k != hp->n; ++k)\n\t\tfor (b = 0; b != hp->m; ++b)\n\t\t\tet[k][b] = hp->e[b][k];\n\t// the initial state, drawn from a0[]\n\tx = drand48();\n\tfor (k = 0, y = 0.0; k != hp->n; ++k) {\n\t\ty += hp->a0[k];\n\t\tif (y >= x) break;\n\t}\n\t// main loop\n\tfor (i = 0; i != L; ++i) {\n\t\tFLOAT *el, *ak = hp->a[k];\n\t\tx = drand48();\n\t\tfor (l = 0, y = 0.0; l != hp->n; ++l) {\n\t\t\ty += ak[l];\n\t\t\tif (y >= x) break;\n\t\t}\n\t\tel = et[l];\n\t\tx = drand48();\n\t\tfor (b = 0, y = 0.0; b != hp->m; ++b) {\n\t\t\ty += el[b];\n\t\t\tif (y >= x) break;\n\t\t} \n\t\tseq[i] = b;\n\t\tk = l;\n\t}\n\tfor (k = 0; k != hp->n; ++k) free(et[k]);\n\tfree(et);\n\treturn seq;\n}", "path": "h2o/deps/klib/khmm.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "h2o/h2o", "stars": 10680, "license": "mit", "language": "c", "size": 119158}
{"docstring": "// expected counts\n", "func_signal": "hmm_exp_t *hmm_expect(const hmm_par_t *hp, const hmm_data_t *hd)", "code": "{\n\tint k, l, u, b, m, n;\n\thmm_exp_t *he;\n\tassert(hd->status & HMM_BACKWARD);\n\the = hmm_new_exp(hp);\n\t// initialization\n\tm = hp->m; n = hp->n;\n\tfor (k = 0; k != n; ++k)\n\t\tfor (l = 0; l != n; ++l) he->A[k][l] = HMM_TINY;\n\tfor (b = 0; b <= m; ++b)\n\t\tfor (l = 0; l != n; ++l) he->E[b][l] = HMM_TINY;\n\t// calculate A_{kl} and E_k(b), k,l\\in[0,n)\n\tfor (u = 1; u < hd->L; ++u) {\n\t\tFLOAT *fu = hd->f[u], *bu = hd->b[u], *bu1 = hd->b[u+1], ss = hd->s[u];\n\t\tFLOAT *Ec = he->E[(int)hd->seq[u]], **p = hp->ae + (int)hd->seq[u+1] * n;\n\t\tfor (k = 0; k != n; ++k) {\n\t\t\tFLOAT *q = p[k], *AA = he->A[k], fuk = fu[k];\n\t\t\tfor (l = 0; l != n; ++l) // this is cache-efficient\n\t\t\t\tAA[l] += fuk * q[l] * bu1[l];\n\t\t\tEc[k] += fuk * bu[k] * ss;\n\t\t}\n\t}\n\t// calculate A0_l\n\tfor (l = 0; l != n; ++l)\n\t\the->A0[l] += hp->a0[l] * hp->e[(int)hd->seq[1]][l] * hd->b[1][l];\n\treturn he;\n}", "path": "h2o/deps/klib/khmm.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "h2o/h2o", "stars": 10680, "license": "mit", "language": "c", "size": 119158}
{"docstring": "// log-likelihood of the observation\n", "func_signal": "FLOAT hmm_lk(const hmm_data_t *hd)", "code": "{\n    FLOAT sum = 0.0, prod = 1.0;\n\tint u, L;\n\tL = hd->L;\n\tassert(hd->status & HMM_FORWARD);\n\tfor (u = 1; u <= L; ++u) {\n\t\tprod *= hd->s[u];\n\t\tif (prod < HMM_TINY || prod >= 1.0/HMM_TINY) { // reset\n\t\t\tsum += log(prod);\n\t\t\tprod = 1.0;\n\t\t}\n\t}\n\tsum += log(prod);\n\treturn sum;\n}", "path": "h2o/deps/klib/khmm.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "h2o/h2o", "stars": 10680, "license": "mit", "language": "c", "size": 119158}
{"docstring": "// forward algorithm\n", "func_signal": "void hmm_forward(const hmm_par_t *hp, hmm_data_t *hd)", "code": "{\n\tFLOAT sum, tmp, **at;\n\tint u, k, l;\n\tint n, m, L;\n\tassert(hp && hd);\n\t// allocate memory for hd->f and hd->s\n\tn = hp->n; m = hp->m; L = hd->L;\n\tif (hd->s) free(hd->s);\n\tif (hd->f) { \n\t\tfor (k = 0; k <= hd->L; ++k) free(hd->f[k]);\n\t\tfree(hd->f);\n\t}\n\thd->f = (FLOAT**)calloc2(hd->L+1, hp->n, sizeof(FLOAT));\n\thd->s = (FLOAT*)calloc(hd->L+1, sizeof(FLOAT));\n\thd->status &= ~(unsigned)HMM_FORWARD;\n\t// at[][] array helps to improve the cache efficiency\n\tat = (FLOAT**)calloc2(n, n, sizeof(FLOAT));\n\t// transpose a[][]\n\tfor (k = 0; k != n; ++k)\n\t\tfor (l = 0; l != n; ++l)\n\t\t\tat[k][l] = hp->a[l][k];\n\t// f[0], but it should never be used\n\thd->s[0] = 1.0;\n\tfor (k = 0; k != n; ++k) hd->f[0][k] = 0.0;\n\t// f[1]\n\tfor (k = 0, sum = 0.0; k != n; ++k)\n\t\tsum += (hd->f[1][k] = hp->a0[k] * hp->e[(int)hd->seq[1]][k]);\n\tfor (k = 0; k != n; ++k) hd->f[1][k] /= sum;\n\thd->s[1] = sum;\n\t// f[2..hmmL], the core loop\n\tfor (u = 2; u <= L; ++u) {\n\t\tFLOAT *fu = hd->f[u], *fu1 = hd->f[u-1], *eu = hp->e[(int)hd->seq[u]];\n\t\tfor (k = 0, sum = 0.0; k != n; ++k) {\n\t\t\tFLOAT *aa = at[k];\n\t\t\tfor (l = 0, tmp = 0.0; l != n; ++l) tmp += fu1[l] * aa[l];\n\t\t\tsum += (fu[k] = eu[k] * tmp);\n\t\t}\n\t\tfor (k = 0; k != n; ++k) fu[k] /= sum;\n\t\thd->s[u] = sum;\n\t}\n\t// free at array\n\tfor (k = 0; k != hp->n; ++k) free(at[k]);\n\tfree(at);\n\thd->status |= HMM_FORWARD;\n}", "path": "h2o/deps/klib/khmm.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "h2o/h2o", "stars": 10680, "license": "mit", "language": "c", "size": 119158}
{"docstring": "/* Adds the next symbol to the current block type and context. When the\n   current block reaches the target size, decides on merging the block. */\n", "func_signal": "static void ContextBlockSplitterAddSymbol(\n    ContextBlockSplitter* self, MemoryManager* m,\n    size_t symbol, size_t context)", "code": "{\n  HistogramAddLiteral(&self->histograms_[self->curr_histogram_ix_ + context],\n      symbol);\n  ++self->block_size_;\n  if (self->block_size_ == self->target_block_size_) {\n    ContextBlockSplitterFinishBlock(self, m, /* is_final = */ BROTLI_FALSE);\n    if (BROTLI_IS_OOM(m)) return;\n  }\n}", "path": "h2o/deps/brotli/c/enc/metablock.c", "commit_date": "2017-12-06 00:00:00", "repo_name": "h2o/h2o", "stars": 10680, "license": "mit", "language": "c", "size": 119158}
{"docstring": "/*\n * call-seq:\n *   sym.length    -> integer\n *\n * Same as <code>sym.to_s.length</code>.\n */\n", "func_signal": "static mrb_value\nmrb_sym_length(mrb_state *mrb, mrb_value self)", "code": "{\n  mrb_int len;\n#ifdef MRB_UTF8_STRING\n  mrb_int byte_len;\n  const char *name = mrb_sym2name_len(mrb, mrb_symbol(self), &byte_len);\n  len = mrb_utf8_len(name, byte_len);\n#else\n  mrb_sym2name_len(mrb, mrb_symbol(self), &len);\n#endif\n  return mrb_fixnum_value(len);\n}", "path": "h2o/deps/mruby/mrbgems/mruby-symbol-ext/src/symbol.c", "commit_date": "2019-02-15 00:00:00", "repo_name": "h2o/h2o", "stars": 10680, "license": "mit", "language": "c", "size": 119158}
{"docstring": "// add he0 to he1\n", "func_signal": "void hmm_add_expect(const hmm_exp_t *he0, hmm_exp_t *he1)", "code": "{\n\tint b, k, l;\n\tassert(he0->m == he1->m && he0->n == he1->n);\n\tfor (k = 0; k != he1->n; ++k) {\n\t\the1->A0[k] += he0->A0[k];\n\t\tfor (l = 0; l != he1->n; ++l)\n\t\t\the1->A[k][l] += he0->A[k][l];\n\t}\n\tfor (b = 0; b != he1->m; ++b) {\n\t\tfor (l = 0; l != he1->n; ++l)\n\t\t\the1->E[b][l] += he0->E[b][l];\n\t}\n}", "path": "h2o/deps/klib/khmm.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "h2o/h2o", "stars": 10680, "license": "mit", "language": "c", "size": 119158}
{"docstring": "// Viterbi algorithm\n", "func_signal": "FLOAT hmm_Viterbi(const hmm_par_t *hp, hmm_data_t *hd)", "code": "{\n\tFLOAT **la, **le, *preV, *curV, max;\n\tint **Vmax, max_l; // backtrace matrix\n\tint k, l, b, u;\n\t\n\tif (hd->v) free(hd->v);\n\thd->v = (int*)calloc(hd->L+1, sizeof(int));\n\tla = (FLOAT**)calloc2(hp->n, hp->n, sizeof(FLOAT));\n\tle = (FLOAT**)calloc2(hp->m + 1, hp->n, sizeof(FLOAT));\n\tVmax = (int**)calloc2(hd->L+1, hp->n, sizeof(int));\n\tpreV = (FLOAT*)malloc(sizeof(FLOAT) * hp->n);\n\tcurV = (FLOAT*)malloc(sizeof(FLOAT) * hp->n);\n\tfor (k = 0; k != hp->n; ++k)\n\t\tfor (l = 0; l != hp->n; ++l)\n\t\t\tla[k][l] = log(hp->a[l][k]); // this is not a bug\n\tfor (b = 0; b != hp->m; ++b)\n\t\tfor (k = 0; k != hp->n; ++k)\n\t\t\tle[b][k] = log(hp->e[b][k]);\n\tfor (k = 0; k != hp->n; ++k) le[hp->m][k] = 0.0;\n\t// V_k(1)\n\tfor (k = 0; k != hp->n; ++k) {\n\t\tpreV[k] = le[(int)hd->seq[1]][k] + log(hp->a0[k]);\n\t\tVmax[1][k] = 0;\n\t}\n\t// all the rest\n\tfor (u = 2; u <= hd->L; ++u) {\n\t\tFLOAT *tmp, *leu = le[(int)hd->seq[u]];\n\t\tfor (k = 0; k != hp->n; ++k) {\n\t\t\tFLOAT *laa = la[k];\n\t\t\tfor (l = 0, max = -HMM_INF, max_l = -1; l != hp->n; ++l) {\n\t\t\t\tif (max < preV[l] + laa[l]) {\n\t\t\t\t\tmax = preV[l] + laa[l];\n\t\t\t\t\tmax_l = l;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(max_l >= 0); // cannot be zero\n\t\t\tcurV[k] = leu[k] + max;\n\t\t\tVmax[u][k] = max_l;\n\t\t}\n\t\ttmp = curV; curV = preV; preV = tmp; // swap\n\t}\n\t// backtrace\n\tfor (k = 0, max_l = -1, max = -HMM_INF; k != hp->n; ++k) {\n\t\tif (max < preV[k]) {\n\t\t\tmax = preV[k]; max_l = k;\n\t\t}\n\t}\n\tassert(max_l >= 0); // cannot be zero\n\thd->v[hd->L] = max_l;\n\tfor (u = hd->L; u >= 1; --u)\n\t\thd->v[u-1] = Vmax[u][hd->v[u]];\n\tfor (k = 0; k != hp->n; ++k) free(la[k]);\n\tfor (b = 0; b < hp->m; ++b) free(le[b]);\n\tfor (u = 0; u <= hd->L; ++u) free(Vmax[u]);\n\tfree(la); free(le); free(Vmax); free(preV); free(curV);\n\thd->status |= HMM_VITERBI;\n\treturn max;\n}", "path": "h2o/deps/klib/khmm.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "h2o/h2o", "stars": 10680, "license": "mit", "language": "c", "size": 119158}
{"docstring": "//  precalculate hp->ae\n", "func_signal": "void hmm_pre_backward(hmm_par_t *hp)", "code": "{\n\tint m, n, b, k, l;\n\tassert(hp);\n\tm = hp->m; n = hp->n;\n\tfor (b = 0; b <= m; ++b) {\n\t\tfor (k = 0; k != n; ++k) {\n\t\t\tFLOAT *p = hp->ae[b * hp->n + k];\n\t\t\tfor (l = 0; l != n; ++l)\n\t\t\t\tp[l] = hp->e[b][l] * hp->a[k][l];\n\t\t}\n\t}\n}", "path": "h2o/deps/klib/khmm.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "h2o/h2o", "stars": 10680, "license": "mit", "language": "c", "size": 119158}
{"docstring": "// posterior probability of states\n", "func_signal": "FLOAT hmm_post_state(const hmm_par_t *hp, const hmm_data_t *hd, int u, FLOAT *prob)", "code": "{\n\tFLOAT sum = 0.0, ss = hd->s[u], *fu = hd->f[u], *bu = hd->b[u];\n\tint k;\n\tfor (k = 0; k != hp->n; ++k)\n\t\tsum += (prob[k] = fu[k] * bu[k] * ss);\n\treturn sum; // in theory, this should always equal to 1.0\n}", "path": "h2o/deps/klib/khmm.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "h2o/h2o", "stars": 10680, "license": "mit", "language": "c", "size": 119158}
{"docstring": "/* Sort the root nodes, least popular first. */\n", "func_signal": "static BROTLI_INLINE BROTLI_BOOL SortHuffmanTree(\n    const HuffmanTree* v0, const HuffmanTree* v1)", "code": "{\n  if (v0->total_count_ != v1->total_count_) {\n    return TO_BROTLI_BOOL(v0->total_count_ < v1->total_count_);\n  }\n  return TO_BROTLI_BOOL(v0->index_right_or_value_ > v1->index_right_or_value_);\n}", "path": "h2o/deps/brotli/c/enc/entropy_encode.c", "commit_date": "2017-12-06 00:00:00", "repo_name": "h2o/h2o", "stars": 10680, "license": "mit", "language": "c", "size": 119158}
{"docstring": "// posterior decoding\n", "func_signal": "void hmm_post_decode(const hmm_par_t *hp, hmm_data_t *hd)", "code": "{\n\tint u, k;\n\tassert(hd->status && HMM_BACKWARD);\n\tif (hd->p) free(hd->p);\n\thd->p = (int*)calloc(hd->L + 1, sizeof(int));\n\tfor (u = 1; u <= hd->L; ++u) {\n\t\tFLOAT prob, max, *fu = hd->f[u], *bu = hd->b[u], su = hd->s[u];\n\t\tint max_k;\n\t\tfor (k = 0, max = -1.0, max_k = -1; k != hp->n; ++k) {\n\t\t\tif (max < (prob = fu[k] * bu[k] * su)) {\n\t\t\t\tmax = prob; max_k = k;\n\t\t\t}\n\t\t}\n\t\tassert(max_k >= 0);\n\t\thd->p[u] = max_k;\n\t}\n\thd->status |= HMM_POSTDEC;\n}", "path": "h2o/deps/klib/khmm.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "h2o/h2o", "stars": 10680, "license": "mit", "language": "c", "size": 119158}
{"docstring": "// new/delete hmm_par_t\n", "func_signal": "hmm_par_t *hmm_new_par(int m, int n)", "code": "{\n\thmm_par_t *hp;\n\tint i;\n\tassert(m > 0 && n > 0);\n\thp = (hmm_par_t*)calloc(1, sizeof(hmm_par_t));\n\thp->m = m; hp->n = n;\n\thp->a0 = (FLOAT*)calloc(n, sizeof(FLOAT));\n\thp->a = (FLOAT**)calloc2(n, n, sizeof(FLOAT));\n\thp->e = (FLOAT**)calloc2(m + 1, n, sizeof(FLOAT));\n\thp->ae = (FLOAT**)calloc2((m + 1) * n, n, sizeof(FLOAT));\n\tfor (i = 0; i != n; ++i) hp->e[m][i] = 1.0;\n\treturn hp;\n}", "path": "h2o/deps/klib/khmm.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "h2o/h2o", "stars": 10680, "license": "mit", "language": "c", "size": 119158}
{"docstring": "// backward algorithm\n", "func_signal": "void hmm_backward(const hmm_par_t *hp, hmm_data_t *hd)", "code": "{\n\tFLOAT tmp;\n\tint k, l, u;\n\tint m, n, L;\n\tassert(hp && hd);\n\tassert(hd->status & HMM_FORWARD);\n\t// allocate memory for hd->b\n\tm = hp->m; n = hp->n; L = hd->L;\n\tif (hd->b) { \n\t\tfor (k = 0; k <= hd->L; ++k) free(hd->b[k]);\n\t\tfree(hd->b);\n\t}\n\thd->status &= ~(unsigned)HMM_BACKWARD;\n\thd->b = (FLOAT**)calloc2(L+1, hp->n, sizeof(FLOAT));\n\t// b[L]\n\tfor (k = 0; k != hp->n; ++k) hd->b[L][k] = 1.0 / hd->s[L];\n\t// b[1..L-1], the core loop\n\tfor (u = L-1; u >= 1; --u) {\n\t\tFLOAT *bu1 = hd->b[u+1], **p = hp->ae + (int)hd->seq[u+1] * n;\n\t\tfor (k = 0; k != n; ++k) {\n\t\t\tFLOAT *q = p[k];\n\t\t\tfor (l = 0, tmp = 0.0; l != n; ++l) tmp += q[l] * bu1[l];\n\t\t\thd->b[u][k] = tmp / hd->s[u];\n\t\t}\n\t}\n\thd->status |= HMM_BACKWARD;\n\tfor (l = 0, tmp = 0.0; l != n; ++l)\n\t\ttmp += hp->a0[l] * hd->b[1][l] * hp->e[(int)hd->seq[1]][l];\n\tif (tmp > 1.0 + 1e-6 || tmp < 1.0 - 1e-6) // in theory, tmp should always equal to 1\n\t\tfprintf(stderr, \"++ Underflow may have happened (%lg).\\n\", tmp);\n}", "path": "h2o/deps/klib/khmm.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "h2o/h2o", "stars": 10680, "license": "mit", "language": "c", "size": 119158}
{"docstring": "// new/delete hmm_exp_t\n", "func_signal": "hmm_exp_t *hmm_new_exp(const hmm_par_t *hp)", "code": "{\n\thmm_exp_t *he;\n\tassert(hp);\n\the = (hmm_exp_t*)calloc(1, sizeof(hmm_exp_t));\n\the->m = hp->m; he->n = hp->n;\n\the->A0 = (FLOAT*)calloc(hp->n, sizeof(FLOAT));\n\the->A = (FLOAT**)calloc2(hp->n, hp->n, sizeof(FLOAT));\n\the->E = (FLOAT**)calloc2(hp->m + 1, hp->n, sizeof(FLOAT));\n\treturn he;\n}", "path": "h2o/deps/klib/khmm.c", "commit_date": "2014-12-17 00:00:00", "repo_name": "h2o/h2o", "stars": 10680, "license": "mit", "language": "c", "size": 119158}
{"docstring": "/* Get or create a redisClusterNode that corresponds to the asking redirection */\n", "func_signal": "static redisClusterNode *cluster_get_asking_node(redisCluster *c)", "code": "{\n    redisClusterNode *pNode;\n    char key[1024];\n    int key_len;\n\n    /* Hashed by host:port */\n    key_len = snprintf(key, sizeof(key), \"%s:%u\", c->redir_host, c->redir_port);\n\n    /* See if we've already attached to it */\n    if ((pNode = zend_hash_str_find_ptr(c->nodes, key, key_len)) != NULL) {\n        return pNode;\n    }\n\n    /* This host:port is unknown to us, so add it */\n    pNode = cluster_node_create(c, c->redir_host, c->redir_host_len,\n        c->redir_port, c->redir_slot, 0);\n\n    /* Return the node */\n   return pNode;\n}", "path": "phpredis/cluster_library.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "phpredis/phpredis", "stars": 9866, "license": "other", "language": "c", "size": 10292}
{"docstring": "/* Iterate through our slots, looking for the host/port in question.  This\n * should perform well enough as in almost all situations, a few or a few\n * dozen servers will map all the slots */\n", "func_signal": "PHP_REDIS_API short cluster_find_slot(redisCluster *c, const char *host,\n                               unsigned short port)", "code": "{\n    int i;\n\n    for (i = 0; i < REDIS_CLUSTER_SLOTS; i++) {\n        if (c->master[i] && c->master[i]->sock &&\n           c->master[i]->sock->port == port &&\n           !strcasecmp(ZSTR_VAL(c->master[i]->sock->host), host))\n        {\n            return i;\n        }\n    }\n\n    // We didn't find it\n    return -1;\n}", "path": "phpredis/cluster_library.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "phpredis/phpredis", "stars": 9866, "license": "other", "language": "c", "size": 10292}
{"docstring": "/* Create a cluster slot cache structure */\n", "func_signal": "PHP_REDIS_API\nredisCachedCluster *cluster_cache_create(zend_string *hash, HashTable *nodes)", "code": "{\n    redisCachedCluster *cc;\n    redisCachedMaster *cm;\n    redisClusterNode *node, *slave;\n\n    cc = pecalloc(1, sizeof(*cc), 1);\n    cc->hash = zend_string_dup(hash, 1);\n\n    /* Copy nodes */\n    cc->master = pecalloc(zend_hash_num_elements(nodes), sizeof(*cc->master), 1);\n    ZEND_HASH_FOREACH_PTR(nodes, node) {\n        /* Skip slaves */\n        if (node->slave) continue;\n\n        cm = &cc->master[cc->count];\n\n        /* Duplicate host/port and clone slot ranges */\n        cm->host.addr = zend_string_dup(node->sock->host, 1);\n        cm->host.port = node->sock->port;\n\n        /* Copy over slot ranges */\n        cm->slot = slot_range_list_clone(&node->slots, &cm->slots);\n\n        /* Attach any slave nodes we have. */\n        if (node->slaves) {\n            /* Allocate memory for slaves */\n            cm->slave = pecalloc(zend_hash_num_elements(node->slaves), sizeof(*cm->slave), 1);\n\n            /* Copy host/port information for each slave */\n            ZEND_HASH_FOREACH_PTR(node->slaves, slave) {\n                cm->slave[cm->slaves].addr = zend_string_dup(slave->sock->host, 1);\n                cm->slave[cm->slaves].port = slave->sock->port;\n                cm->slaves++;\n            } ZEND_HASH_FOREACH_END();\n        }\n\n        cc->count++;\n    } ZEND_HASH_FOREACH_END();\n\n    return cc;\n}", "path": "phpredis/cluster_library.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "phpredis/phpredis", "stars": 9866, "license": "other", "language": "c", "size": 10292}
{"docstring": "/* Helper to find if we've got a host:port mapped in our cluster nodes. */\n", "func_signal": "static redisClusterNode *cluster_find_node(redisCluster *c, const char *host,\n                                           unsigned short port)", "code": "{\n    int key_len;\n    char key[1024];\n\n    key_len = snprintf(key,sizeof(key),\"%s:%d\", host, port);\n\n    return zend_hash_str_find_ptr(c->nodes, key, key_len);\n}", "path": "phpredis/cluster_library.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "phpredis/phpredis", "stars": 9866, "license": "other", "language": "c", "size": 10292}
{"docstring": "/* XINFO */\n", "func_signal": "PHP_REDIS_API void\ncluster_xinfo_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx)", "code": "{\n    zval z_ret;\n\n    array_init(&z_ret);\n    if (redis_read_xinfo_response(c->cmd_sock, &z_ret, c->reply_len) != SUCCESS) {\n        zval_dtor(&z_ret);\n        CLUSTER_RETURN_FALSE(c);\n    }\n\n    if (CLUSTER_IS_ATOMIC(c)) {\n        RETURN_ZVAL(&z_ret, 0, 1);\n    }\n    add_next_index_zval(&c->multi_resp, &z_ret);\n}", "path": "phpredis/cluster_library.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "phpredis/phpredis", "stars": 9866, "license": "other", "language": "c", "size": 10292}
{"docstring": "/* Send a command to a specific slot */\n", "func_signal": "PHP_REDIS_API int cluster_send_slot(redisCluster *c, short slot, char *cmd,\n                             int cmd_len, REDIS_REPLY_TYPE rtype)", "code": "{\n    /* Point our cluster to this slot and it's socket */\n    c->cmd_slot = slot;\n    c->cmd_sock = SLOT_SOCK(c, slot);\n\n    /* Enable multi mode on this slot if we've been directed to but haven't\n     * send it to this node yet */\n    if (c->flags->mode == MULTI && c->cmd_sock->mode != MULTI) {\n        if (cluster_send_multi(c, slot) == -1) {\n            CLUSTER_THROW_EXCEPTION(\"Unable to enter MULTI mode on requested slot\", 0);\n            return -1;\n        }\n    }\n\n    /* Try the slot */\n    if (cluster_sock_write(c, cmd, cmd_len, 1) == -1) {\n        return -1;\n    }\n\n    /* Check our response */\n    if (cluster_check_response(c, &c->reply_type) != 0 ||\n       (rtype != TYPE_EOF && rtype != c->reply_type)) return -1;\n\n    /* Success */\n    return 0;\n}", "path": "phpredis/cluster_library.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "phpredis/phpredis", "stars": 9866, "license": "other", "language": "c", "size": 10292}
{"docstring": "/* A boolean response.  If we get here, we've consumed the '+' reply\n * type and will now just verify we can read the OK */\n", "func_signal": "PHP_REDIS_API void cluster_bool_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                              void *ctx)", "code": "{\n    // Check that we have +OK\n    if (c->reply_type != TYPE_LINE || c->reply_len != 2 ||\n       c->line_reply[0] != 'O' || c->line_reply[1] != 'K')\n    {\n        CLUSTER_RETURN_FALSE(c);\n    }\n\n    CLUSTER_RETURN_BOOL(c, 1);\n}", "path": "phpredis/cluster_library.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "phpredis/phpredis", "stars": 9866, "license": "other", "language": "c", "size": 10292}
{"docstring": "/* Read any sort of response from the socket, having already issued the\n * command and consumed the reply type and meta info (length) */\n", "func_signal": "clusterReply*\ncluster_read_sock_resp(RedisSock *redis_sock, REDIS_REPLY_TYPE type,\n                       char *line_reply, long long len)", "code": "{\n    clusterReply *r;\n\n    r = ecalloc(1, sizeof(clusterReply));\n    r->type = type;\n\n    switch(r->type) {\n        case TYPE_INT:\n            r->integer = len;\n            break;\n        case TYPE_LINE:\n            if (line_reply) {\n                r->str = estrndup(line_reply, len);\n                r->len = len;\n            }\n        case TYPE_ERR:\n            return r;\n        case TYPE_BULK:\n            r->len = len;\n            r->str = redis_sock_read_bulk_reply(redis_sock, len);\n            if (r->len != -1 && !r->str) {\n                cluster_free_reply(r, 1);\n                return NULL;\n            }\n            break;\n        case TYPE_MULTIBULK:\n            r->elements = len;\n            if (r->elements > 0) {\n                r->element = ecalloc(len, sizeof(clusterReply*));\n                if (cluster_multibulk_resp_recursive(redis_sock, len, r->element, line_reply != NULL) < 0) {\n                    cluster_free_reply(r, 1);\n                    return NULL;\n                }\n            }\n            break;\n        default:\n            cluster_free_reply(r, 1);\n            return NULL;\n    }\n\n    // Success, return the reply\n    return r;\n}", "path": "phpredis/cluster_library.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "phpredis/phpredis", "stars": 9866, "license": "other", "language": "c", "size": 10292}
{"docstring": "/* MULTI BULK response where we don't touch the values (e.g. KEYS) */\n", "func_signal": "int mbulk_resp_loop_raw(RedisSock *redis_sock, zval *z_result,\n                        long long count, void *ctx)", "code": "{\n    char *line;\n    int line_len;\n\n    // Iterate over the number we have\n    while (count--) {\n        // Read the line, which should never come back null\n        line = redis_sock_read(redis_sock, &line_len);\n        if (line == NULL) return FAILURE;\n\n        // Add to our result array\n        add_next_index_stringl(z_result, line, line_len);\n        efree(line);\n    }\n\n    // Success!\n    return SUCCESS;\n}", "path": "phpredis/cluster_library.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "phpredis/phpredis", "stars": 9866, "license": "other", "language": "c", "size": 10292}
{"docstring": "/* Hash a key from a ZVAL */\n", "func_signal": "unsigned short cluster_hash_key_zval(zval *z_key)", "code": "{\n    const char *kptr;\n    char buf[255];\n    int klen;\n\n    // Switch based on ZVAL type\n    switch(Z_TYPE_P(z_key)) {\n        case IS_STRING:\n            kptr = Z_STRVAL_P(z_key);\n            klen = Z_STRLEN_P(z_key);\n            break;\n        case IS_LONG:\n            klen = snprintf(buf,sizeof(buf),ZEND_LONG_FMT,Z_LVAL_P(z_key));\n            kptr = (const char *)buf;\n            break;\n        case IS_DOUBLE:\n            klen = snprintf(buf,sizeof(buf),\"%f\",Z_DVAL_P(z_key));\n            kptr = (const char *)buf;\n            break;\n        case IS_ARRAY:\n            kptr = \"Array\";\n            klen = sizeof(\"Array\")-1;\n            break;\n        case IS_OBJECT:\n            kptr = \"Object\";\n            klen = sizeof(\"Object\")-1;\n            break;\n        default:\n            kptr = \"\";\n            klen = 0;\n    }\n\n    // Hash the string representation\n    return cluster_hash_key(kptr, klen);\n}", "path": "phpredis/cluster_library.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "phpredis/phpredis", "stars": 9866, "license": "other", "language": "c", "size": 10292}
{"docstring": "/* Get the hash slot for a given key */\n", "func_signal": "unsigned short cluster_hash_key(const char *key, int len)", "code": "{\n    int s, e;\n\n    // Find first occurrence of {, if any\n    for (s = 0; s < len; s++) {\n        if (key[s]=='{') break;\n    }\n\n    // There is no '{', hash everything\n    if (s == len) return crc16(key, len) & REDIS_CLUSTER_MOD;\n\n    // Found it, look for a tailing '}'\n    for (e =s + 1; e < len; e++) {\n        if (key[e] == '}') break;\n    }\n\n    // Hash the whole key if we don't find a tailing } or if {} is empty\n    if (e == len || e == s+1) return crc16(key, len) & REDIS_CLUSTER_MOD;\n\n    // Hash just the bit between { and }\n    return crc16((char*)key+s+1,e-s-1) & REDIS_CLUSTER_MOD;\n}", "path": "phpredis/cluster_library.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "phpredis/phpredis", "stars": 9866, "license": "other", "language": "c", "size": 10292}
{"docstring": "/* List pure functions */\n", "func_signal": "void\nra_init_function_table(RedisArray *ra)", "code": "{\n    ALLOC_HASHTABLE(ra->pure_cmds);\n    zend_hash_init(ra->pure_cmds, 0, NULL, NULL, 0);\n\n    zend_hash_str_update_ptr(ra->pure_cmds, \"EXISTS\", sizeof(\"EXISTS\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"GET\", sizeof(\"GET\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"GETBIT\", sizeof(\"GETBIT\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"GETRANGE\", sizeof(\"GETRANGE\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"HEXISTS\", sizeof(\"HEXISTS\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"HGET\", sizeof(\"HGET\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"HGETALL\", sizeof(\"HGETALL\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"HKEYS\", sizeof(\"HKEYS\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"HLEN\", sizeof(\"HLEN\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"HMGET\", sizeof(\"HMGET\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"HVALS\", sizeof(\"HVALS\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"LINDEX\", sizeof(\"LINDEX\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"LLEN\", sizeof(\"LLEN\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"LRANGE\", sizeof(\"LRANGE\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"OBJECT\", sizeof(\"OBJECT\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"SCARD\", sizeof(\"SCARD\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"SDIFF\", sizeof(\"SDIFF\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"SINTER\", sizeof(\"SINTER\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"SISMEMBER\", sizeof(\"SISMEMBER\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"SMEMBERS\", sizeof(\"SMEMBERS\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"SRANDMEMBER\", sizeof(\"SRANDMEMBER\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"STRLEN\", sizeof(\"STRLEN\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"SUNION\", sizeof(\"SUNION\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"TYPE\", sizeof(\"TYPE\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"ZCARD\", sizeof(\"ZCARD\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"ZCOUNT\", sizeof(\"ZCOUNT\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"ZRANGE\", sizeof(\"ZRANGE\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"ZRANK\", sizeof(\"ZRANK\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"ZREVRANGE\", sizeof(\"ZREVRANGE\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"ZREVRANGEBYSCORE\", sizeof(\"ZREVRANGEBYSCORE\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"ZREVRANK\", sizeof(\"ZREVRANK\") - 1, NULL);\n    zend_hash_str_update_ptr(ra->pure_cmds, \"ZSCORE\", sizeof(\"ZSCORE\") - 1, NULL);\n}", "path": "phpredis/redis_array_impl.c", "commit_date": "2020-10-30 00:00:00", "repo_name": "phpredis/phpredis", "stars": 9866, "license": "other", "language": "c", "size": 10292}
{"docstring": "/* Boolean response, specialized for PING */\n", "func_signal": "PHP_REDIS_API void cluster_ping_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                              void *ctx)", "code": "{\n    if (c->reply_type != TYPE_LINE || c->reply_len != 4 ||\n       memcmp(c->line_reply,\"PONG\",sizeof(\"PONG\")-1))\n    {\n        CLUSTER_RETURN_FALSE(c);\n    }\n\n    CLUSTER_RETURN_BOOL(c, 1);\n}", "path": "phpredis/cluster_library.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "phpredis/phpredis", "stars": 9866, "license": "other", "language": "c", "size": 10292}
{"docstring": "/* Initialize seeds.  By the time we get here we've already validated our\n * seeds array and know we have a non-empty array of strings all in\n * host:port format. */\n", "func_signal": "PHP_REDIS_API void\ncluster_init_seeds(redisCluster *c, zend_string **seeds, uint32_t nseeds)", "code": "{\n    RedisSock *sock;\n    char *seed, *sep, key[1024];\n    int key_len, i, *map;\n\n    /* Get a randomized order to hit our seeds */\n    map = ecalloc(nseeds, sizeof(*map));\n    for (i = 0; i < nseeds; i++) map[i] = i;\n    fyshuffle(map, nseeds);\n\n    for (i = 0; i < nseeds; i++) {\n        seed = ZSTR_VAL(seeds[map[i]]);\n\n        sep = strrchr(seed, ':');\n        ZEND_ASSERT(sep != NULL);\n\n        // Allocate a structure for this seed\n        sock = redis_sock_create(seed, sep - seed, atoi(sep + 1),\n                                 c->flags->timeout, c->flags->read_timeout,\n                                 c->flags->persistent, NULL, 0);\n\n        /* Stream context */\n        sock->stream_ctx = c->flags->stream_ctx;\n\n        /* Credentials */\n        redis_sock_set_auth(sock, c->flags->user, c->flags->pass);\n\n        // Index this seed by host/port\n        key_len = snprintf(key, sizeof(key), \"%s:%u\", ZSTR_VAL(sock->host),\n            sock->port);\n\n        // Add to our seed HashTable\n        zend_hash_str_update_ptr(c->seeds, key, key_len, sock);\n    }\n\n    efree(map);\n}", "path": "phpredis/cluster_library.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "phpredis/phpredis", "stars": 9866, "license": "other", "language": "c", "size": 10292}
{"docstring": "/* delete key from source server index during rehashing */\n", "func_signal": "static void\nra_remove_from_index(zval *z_redis, const char *key, int key_len)", "code": "{\n\n    zval z_fun_srem, z_ret, z_args[2];\n\n    /* run SREM on source index */\n    ZVAL_STRINGL(&z_fun_srem, \"SREM\", 4);\n    ZVAL_STRINGL(&z_args[0], PHPREDIS_INDEX_NAME, sizeof(PHPREDIS_INDEX_NAME) - 1);\n    ZVAL_STRINGL(&z_args[1], key, key_len);\n\n    call_user_function(&redis_ce->function_table, z_redis, &z_fun_srem, &z_ret, 2, z_args);\n\n    /* cleanup */\n    zval_dtor(&z_fun_srem);\n    zval_dtor(&z_args[1]);\n    zval_dtor(&z_args[0]);\n    zval_dtor(&z_ret);\n}", "path": "phpredis/redis_array_impl.c", "commit_date": "2020-10-30 00:00:00", "repo_name": "phpredis/phpredis", "stars": 9866, "license": "other", "language": "c", "size": 10292}
{"docstring": "/* Initialize cluster from cached slots */\n", "func_signal": "PHP_REDIS_API\nvoid cluster_init_cache(redisCluster *c, redisCachedCluster *cc)", "code": "{\n    RedisSock *sock;\n    redisClusterNode *mnode, *slave;\n    redisCachedMaster *cm;\n    char key[HOST_NAME_MAX];\n    size_t keylen, i, j, s;\n    int *map;\n\n    /* Randomize seeds */\n    map = emalloc(sizeof(*map) * cc->count);\n    for (i = 0; i < cc->count; i++) map[i] = i;\n    fyshuffle(map, cc->count);\n\n    /* Duplicate the hash key so we can invalidate when redirected */\n    c->cache_key = zend_string_copy(cc->hash);\n\n    /* Iterate over masters */\n    for (i = 0; i < cc->count; i++) {\n        /* Grab the next master */\n        cm = &cc->master[map[i]];\n\n        /* Hash our host and port */\n        keylen = snprintf(key, sizeof(key), \"%s:%u\", ZSTR_VAL(cm->host.addr), cm->host.port);\n\n        /* Create socket */\n        sock = redis_sock_create(ZSTR_VAL(cm->host.addr), ZSTR_LEN(cm->host.addr), cm->host.port,\n                                 c->flags->timeout, c->flags->read_timeout, c->flags->persistent,\n                                 NULL, 0);\n\n        /* Stream context */\n        sock->stream_ctx = c->flags->stream_ctx;\n\n        /* Add to seed nodes */\n        zend_hash_str_update_ptr(c->seeds, key, keylen, sock);\n\n        /* Create master node */\n        mnode = cached_master_clone(c, cm);\n\n        /* Add our master */\n        zend_hash_str_update_ptr(c->nodes, key, keylen, mnode);\n\n        /* Attach any slaves */\n        for (s = 0; s < cm->slaves; s++) {\n            zend_string *host = cm->slave[s].addr;\n            slave = cluster_node_create(c, ZSTR_VAL(host), ZSTR_LEN(host), cm->slave[s].port, 0, 1);\n            cluster_node_add_slave(mnode, slave);\n        }\n\n        /* Hook up direct slot access */\n        for (j = 0; j < cm->slots; j++) {\n            for (s = cm->slot[j].low; s <= cm->slot[j].high; s++) {\n                c->master[s] = mnode;\n            }\n        }\n    }\n\n    efree(map);\n}", "path": "phpredis/cluster_library.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "phpredis/phpredis", "stars": 9866, "license": "other", "language": "c", "size": 10292}
{"docstring": "/* Free a redisClusterNode structure */\n", "func_signal": "PHP_REDIS_API void cluster_free_node(redisClusterNode *node)", "code": "{\n    if (node->slaves) {\n        zend_hash_destroy(node->slaves);\n        efree(node->slaves);\n    }\n\n    zend_llist_destroy(&node->slots);\n    redis_free_socket(node->sock);\n\n    efree(node);\n}", "path": "phpredis/cluster_library.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "phpredis/phpredis", "stars": 9866, "license": "other", "language": "c", "size": 10292}
{"docstring": "/* Generic MULTI BULK response processor */\n", "func_signal": "PHP_REDIS_API void cluster_gen_mbulk_resp(INTERNAL_FUNCTION_PARAMETERS,\n                                   redisCluster *c, mbulk_cb cb, void *ctx)", "code": "{\n    zval z_result;\n\n    /* Abort if the reply isn't MULTIBULK or has an invalid length */\n    if (c->reply_type != TYPE_MULTIBULK || c->reply_len < -1) {\n        CLUSTER_RETURN_FALSE(c);\n    }\n\n    if (c->reply_len == -1 && c->flags->null_mbulk_as_null) {\n        ZVAL_NULL(&z_result);\n    } else {\n        array_init(&z_result);\n\n        if (c->reply_len > 0) {\n            /* Push serialization settings from the cluster into our socket */\n            c->cmd_sock->serializer = c->flags->serializer;\n\n            /* Call our specified callback */\n            if (cb(c->cmd_sock, &z_result, c->reply_len, ctx) == FAILURE) {\n                zval_dtor(&z_result);\n                CLUSTER_RETURN_FALSE(c);\n            }\n        }\n    }\n\n    // Success, make this array our return value\n    if (CLUSTER_IS_ATOMIC(c)) {\n        RETVAL_ZVAL(&z_result, 0, 1);\n    } else {\n        add_next_index_zval(&c->multi_resp, &z_result);\n    }\n}", "path": "phpredis/cluster_library.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "phpredis/phpredis", "stars": 9866, "license": "other", "language": "c", "size": 10292}
{"docstring": "/* Attach a slave to a master */\n", "func_signal": "PHP_REDIS_API int\ncluster_node_add_slave(redisClusterNode *master, redisClusterNode *slave)", "code": "{\n    zend_ulong index;\n\n    // Allocate our slaves hash table if we haven't yet\n    if (!master->slaves) {\n        ALLOC_HASHTABLE(master->slaves);\n        zend_hash_init(master->slaves, 0, NULL, ht_free_slave, 0);\n        index = 1;\n    } else {\n        index = master->slaves->nNextFreeElement;\n    }\n\n    return zend_hash_index_update_ptr(master->slaves, index, slave) != NULL;\n}", "path": "phpredis/cluster_library.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "phpredis/phpredis", "stars": 9866, "license": "other", "language": "c", "size": 10292}
{"docstring": "/* Fisher-Yates shuffle for integer array */\n", "func_signal": "static void fyshuffle(int *array, size_t len)", "code": "{\n    int temp, n = len;\n    size_t r;\n\n    /* Randomize */\n    while (n > 1) {\n        r = ((int)((double)n-- * (rand() / (RAND_MAX+1.0))));\n        temp = array[n];\n        array[n] = array[r];\n        array[r] = temp;\n    };\n}", "path": "phpredis/cluster_library.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "phpredis/phpredis", "stars": 9866, "license": "other", "language": "c", "size": 10292}
{"docstring": "/* write a packet ID acknowledgement record to buf, */\n/* removing all acknowledged entries from ack */\n", "func_signal": "bool\nreliable_ack_write(struct reliable_ack *ack,\n                   struct buffer *buf,\n                   const struct session_id *sid, int max, bool prepend)", "code": "{\n    int i, j;\n    uint8_t n;\n    struct buffer sub;\n\n    n = ack->len;\n    if (n > max)\n    {\n        n = max;\n    }\n    sub = buf_sub(buf, ACK_SIZE(n), prepend);\n    if (!BDEF(&sub))\n    {\n        goto error;\n    }\n    ASSERT(buf_write(&sub, &n, sizeof(n)));\n    for (i = 0; i < n; ++i)\n    {\n        packet_id_type pid = ack->packet_id[i];\n        packet_id_type net_pid = htonpid(pid);\n        ASSERT(buf_write(&sub, &net_pid, sizeof(net_pid)));\n        dmsg(D_REL_DEBUG, \"ACK write ID \" packet_id_format \" (ack->len=%d, n=%d)\", (packet_id_print_type)pid, ack->len, n);\n    }\n    if (n)\n    {\n        ASSERT(session_id_defined(sid));\n        ASSERT(session_id_write(sid, &sub));\n        for (i = 0, j = n; j < ack->len; )\n        {\n            ack->packet_id[i++] = ack->packet_id[j++];\n        }\n        ack->len = i;\n    }\n\n    return true;\n\nerror:\n    return false;\n}", "path": "openvpn/src/openvpn/reliable.c", "commit_date": "2020-10-24 00:00:00", "repo_name": "OpenVPN/openvpn", "stars": 9723, "license": "other", "language": "c", "size": 22228}
{"docstring": "/* ifdef ENABLE_PF */\n", "func_signal": "unsigned int\nmroute_extract_addr_ip(struct mroute_addr *src, struct mroute_addr *dest,\n                       const struct buffer *buf)", "code": "{\n    unsigned int ret = 0;\n    if (BLEN(buf) >= 1)\n    {\n        switch (OPENVPN_IPH_GET_VER(*BPTR(buf)))\n        {\n            case 4:\n                if (BLEN(buf) >= (int) sizeof(struct openvpn_iphdr))\n                {\n                    const struct openvpn_iphdr *ip = (const struct openvpn_iphdr *) BPTR(buf);\n\n                    mroute_get_in_addr_t(src, ip->saddr, 0);\n                    mroute_get_in_addr_t(dest, ip->daddr, 0);\n\n                    /* multicast packet? */\n                    if (mroute_is_mcast(ip->daddr))\n                    {\n                        ret |= MROUTE_EXTRACT_MCAST;\n                    }\n\n                    /* IGMP message? */\n                    if (ip->protocol == OPENVPN_IPPROTO_IGMP)\n                    {\n                        ret |= MROUTE_EXTRACT_IGMP;\n                    }\n\n                    ret |= MROUTE_EXTRACT_SUCCEEDED;\n                }\n                break;\n\n            case 6:\n                if (BLEN(buf) >= (int) sizeof(struct openvpn_ipv6hdr))\n                {\n                    const struct openvpn_ipv6hdr *ipv6 = (const struct openvpn_ipv6hdr *) BPTR(buf);\n#if 0                           /* very basic debug */\n                    struct gc_arena gc = gc_new();\n                    msg( M_INFO, \"IPv6 packet! src=%s, dst=%s\",\n                         print_in6_addr( ipv6->saddr, 0, &gc ),\n                         print_in6_addr( ipv6->daddr, 0, &gc ));\n                    gc_free(&gc);\n#endif\n\n                    mroute_get_in6_addr(src, ipv6->saddr, 0);\n                    mroute_get_in6_addr(dest, ipv6->daddr, 0);\n\n                    if (mroute_is_mcast_ipv6(ipv6->daddr))\n                    {\n                        ret |= MROUTE_EXTRACT_MCAST;\n                    }\n\n                    ret |= MROUTE_EXTRACT_SUCCEEDED;\n                }\n                break;\n\n            default:\n                msg(M_WARN, \"IP packet with unknown IP version=%d seen\",\n                    OPENVPN_IPH_GET_VER(*BPTR(buf)));\n        }\n    }\n    return ret;\n}", "path": "openvpn/src/openvpn/mroute.c", "commit_date": "2020-05-07 00:00:00", "repo_name": "OpenVPN/openvpn", "stars": 9723, "license": "other", "language": "c", "size": 22228}
{"docstring": "/* read a packet ID acknowledgement record from buf into ack */\n", "func_signal": "bool\nreliable_ack_read(struct reliable_ack *ack,\n                  struct buffer *buf, const struct session_id *sid)", "code": "{\n    struct gc_arena gc = gc_new();\n    int i;\n    uint8_t count;\n    packet_id_type net_pid;\n    packet_id_type pid;\n    struct session_id session_id_remote;\n\n    if (!buf_read(buf, &count, sizeof(count)))\n    {\n        goto error;\n    }\n    for (i = 0; i < count; ++i)\n    {\n        if (!buf_read(buf, &net_pid, sizeof(net_pid)))\n        {\n            goto error;\n        }\n        if (ack->len >= RELIABLE_ACK_SIZE)\n        {\n            goto error;\n        }\n        pid = ntohpid(net_pid);\n        ack->packet_id[ack->len++] = pid;\n    }\n    if (count)\n    {\n        if (!session_id_read(&session_id_remote, buf))\n        {\n            goto error;\n        }\n        if (!session_id_defined(&session_id_remote)\n            || !session_id_equal(&session_id_remote, sid))\n        {\n            dmsg(D_REL_LOW,\n                 \"ACK read BAD SESSION-ID FROM REMOTE, local=%s, remote=%s\",\n                 session_id_print(sid, &gc), session_id_print(&session_id_remote, &gc));\n            goto error;\n        }\n    }\n    gc_free(&gc);\n    return true;\n\nerror:\n    gc_free(&gc);\n    return false;\n}", "path": "openvpn/src/openvpn/reliable.c", "commit_date": "2020-10-24 00:00:00", "repo_name": "OpenVPN/openvpn", "stars": 9723, "license": "other", "language": "c", "size": 22228}
{"docstring": "/*\n * Don't learn certain addresses.\n */\n", "func_signal": "bool\nmroute_learnable_address(const struct mroute_addr *addr, struct gc_arena *gc)", "code": "{\n    int i;\n    bool all_zeros = true;\n    bool all_ones = true;\n\n    for (i = 0; i < addr->len; ++i)\n    {\n        int b = addr->raw_addr[i];\n        if (b != 0x00)\n        {\n            all_zeros = false;\n        }\n        if (b != 0xFF)\n        {\n            all_ones = false;\n        }\n    }\n\n    /* only networkss shorter than 8 bits are allowed to be all 0s. */\n    if (all_zeros\n        && !((addr->type & MR_WITH_NETBITS) && (addr->netbits < 8)))\n    {\n        msg(D_MULTI_LOW, \"Can't learn %s: network is all 0s, but netbits >= 8\",\n            mroute_addr_print(addr, gc));\n        return false;\n    }\n\n    if (all_ones)\n    {\n        msg(D_MULTI_LOW, \"Can't learn %s: network is all 1s\",\n            mroute_addr_print(addr, gc));\n        return false;\n    }\n\n    if (is_mac_mcast_maddr(addr))\n    {\n        msg(D_MULTI_LOW, \"Can't learn %s: network is a multicast address\",\n            mroute_addr_print(addr, gc));\n        return false;\n    }\n\n    return true;\n}", "path": "openvpn/src/openvpn/mroute.c", "commit_date": "2020-05-07 00:00:00", "repo_name": "OpenVPN/openvpn", "stars": 9723, "license": "other", "language": "c", "size": 22228}
{"docstring": "/*\n * mroute_helper's main job is keeping track of\n * currently used CIDR netlengths, so we don't\n * have to cycle through all 33.\n */\n", "func_signal": "struct mroute_helper *\nmroute_helper_init(int ageable_ttl_secs)", "code": "{\n    struct mroute_helper *mh;\n    ALLOC_OBJ_CLEAR(mh, struct mroute_helper);\n    mh->ageable_ttl_secs = ageable_ttl_secs;\n    return mh;\n}", "path": "openvpn/src/openvpn/mroute.c", "commit_date": "2020-05-07 00:00:00", "repo_name": "OpenVPN/openvpn", "stars": 9723, "license": "other", "language": "c", "size": 22228}
{"docstring": "/* print a reliable ACK record coming off the wire */\n", "func_signal": "const char *\nreliable_ack_print(struct buffer *buf, bool verbose, struct gc_arena *gc)", "code": "{\n    int i;\n    uint8_t n_ack;\n    struct session_id sid_ack;\n    packet_id_type pid;\n    struct buffer out = alloc_buf_gc(256, gc);\n\n    buf_printf(&out, \"[\");\n    if (!buf_read(buf, &n_ack, sizeof(n_ack)))\n    {\n        goto done;\n    }\n    for (i = 0; i < n_ack; ++i)\n    {\n        if (!buf_read(buf, &pid, sizeof(pid)))\n        {\n            goto done;\n        }\n        pid = ntohpid(pid);\n        buf_printf(&out, \" \" packet_id_format, (packet_id_print_type)pid);\n    }\n    if (n_ack)\n    {\n        if (!session_id_read(&sid_ack, buf))\n        {\n            goto done;\n        }\n        if (verbose)\n        {\n            buf_printf(&out, \" sid=%s\", session_id_print(&sid_ack, gc));\n        }\n    }\n\ndone:\n    buf_printf(&out, \" ]\");\n    return BSTR(&out);\n}", "path": "openvpn/src/openvpn/reliable.c", "commit_date": "2020-10-24 00:00:00", "repo_name": "OpenVPN/openvpn", "stars": 9723, "license": "other", "language": "c", "size": 22228}
{"docstring": "/* return true if reliable_send would return a non-NULL result */\n", "func_signal": "bool\nreliable_can_send(const struct reliable *rel)", "code": "{\n    struct gc_arena gc = gc_new();\n    int i;\n    int n_active = 0, n_current = 0;\n    for (i = 0; i < rel->size; ++i)\n    {\n        const struct reliable_entry *e = &rel->array[i];\n        if (e->active)\n        {\n            ++n_active;\n            if (now >= e->next_try)\n            {\n                ++n_current;\n            }\n        }\n    }\n    dmsg(D_REL_DEBUG, \"ACK reliable_can_send active=%d current=%d : %s\",\n         n_active,\n         n_current,\n         reliable_print_ids(rel, &gc));\n\n    gc_free(&gc);\n    return n_current > 0 && !rel->hold;\n}", "path": "openvpn/src/openvpn/reliable.c", "commit_date": "2020-10-24 00:00:00", "repo_name": "OpenVPN/openvpn", "stars": 9723, "license": "other", "language": "c", "size": 22228}
{"docstring": "/* SELECT */\n", "func_signal": "static struct event_set *\nevent_set_init_simple(int *maxevents, unsigned int flags)", "code": "{\n    struct event_set *ret = NULL;\n#ifdef _WIN32\n    ret = we_init(maxevents, flags);\n#elif POLL && SELECT\n#if 0 /* Define to 1 if EVENT_METHOD_US_TIMEOUT should cause select to be favored over poll */\n    if (flags & EVENT_METHOD_US_TIMEOUT)\n    {\n        ret = se_init(maxevents, flags);\n    }\n#endif\n#ifdef SELECT_PREFERRED_OVER_POLL\n    if (!ret)\n    {\n        ret = se_init(maxevents, flags);\n    }\n    if (!ret)\n    {\n        ret = po_init(maxevents, flags);\n    }\n#else  /* ifdef SELECT_PREFERRED_OVER_POLL */\n    if (!ret)\n    {\n        ret = po_init(maxevents, flags);\n    }\n    if (!ret)\n    {\n        ret = se_init(maxevents, flags);\n    }\n#endif\n#elif POLL\n    ret = po_init(maxevents, flags);\n#elif SELECT\n    ret = se_init(maxevents, flags);\n#else  /* ifdef _WIN32 */\n#error At least one of poll, select, or WSAWaitForMultipleEvents must be supported by the kernel\n#endif /* ifdef _WIN32 */\n    ASSERT(ret);\n    return ret;\n}", "path": "openvpn/src/openvpn/event.c", "commit_date": "2018-12-12 00:00:00", "repo_name": "OpenVPN/openvpn", "stars": 9723, "license": "other", "language": "c", "size": 22228}
{"docstring": "/*\n * struct reliable member functions.\n */\n", "func_signal": "void\nreliable_init(struct reliable *rel, int buf_size, int offset, int array_size, bool hold)", "code": "{\n    int i;\n\n    CLEAR(*rel);\n    ASSERT(array_size > 0 && array_size <= RELIABLE_CAPACITY);\n    rel->hold = hold;\n    rel->size = array_size;\n    rel->offset = offset;\n    for (i = 0; i < rel->size; ++i)\n    {\n        struct reliable_entry *e = &rel->array[i];\n        e->buf = alloc_buf(buf_size);\n        ASSERT(buf_init(&e->buf, offset));\n    }\n}", "path": "openvpn/src/openvpn/reliable.c", "commit_date": "2020-10-24 00:00:00", "repo_name": "OpenVPN/openvpn", "stars": 9723, "license": "other", "language": "c", "size": 22228}
{"docstring": "/* get active buffer for next sequentially increasing key ID */\n", "func_signal": "struct buffer *\nreliable_get_buf_sequenced(struct reliable *rel)", "code": "{\n    int i;\n    for (i = 0; i < rel->size; ++i)\n    {\n        struct reliable_entry *e = &rel->array[i];\n        if (e->active && e->packet_id == rel->packet_id)\n        {\n            return &e->buf;\n        }\n    }\n    return NULL;\n}", "path": "openvpn/src/openvpn/reliable.c", "commit_date": "2020-10-24 00:00:00", "repo_name": "OpenVPN/openvpn", "stars": 9723, "license": "other", "language": "c", "size": 22228}
{"docstring": "/* make sure that incoming packet ID isn't a replay */\n", "func_signal": "bool\nreliable_not_replay(const struct reliable *rel, packet_id_type id)", "code": "{\n    struct gc_arena gc = gc_new();\n    int i;\n    if (reliable_pid_min(id, rel->packet_id))\n    {\n        goto bad;\n    }\n    for (i = 0; i < rel->size; ++i)\n    {\n        const struct reliable_entry *e = &rel->array[i];\n        if (e->active && e->packet_id == id)\n        {\n            goto bad;\n        }\n    }\n    gc_free(&gc);\n    return true;\n\nbad:\n    dmsg(D_REL_DEBUG, \"ACK \" packet_id_format \" is a replay: %s\", (packet_id_print_type)id, reliable_print_ids(rel, &gc));\n    gc_free(&gc);\n    return false;\n}", "path": "openvpn/src/openvpn/reliable.c", "commit_date": "2020-10-24 00:00:00", "repo_name": "OpenVPN/openvpn", "stars": 9723, "license": "other", "language": "c", "size": 22228}
{"docstring": "/* return next buffer to send to remote */\n", "func_signal": "struct buffer *\nreliable_send(struct reliable *rel, int *opcode)", "code": "{\n    int i;\n    struct reliable_entry *best = NULL;\n    const time_t local_now = now;\n\n    for (i = 0; i < rel->size; ++i)\n    {\n        struct reliable_entry *e = &rel->array[i];\n        if (e->active && local_now >= e->next_try)\n        {\n            if (!best || reliable_pid_min(e->packet_id, best->packet_id))\n            {\n                best = e;\n            }\n        }\n    }\n    if (best)\n    {\n#ifdef EXPONENTIAL_BACKOFF\n        /* exponential backoff */\n        best->next_try = local_now + best->timeout;\n        best->timeout *= 2;\n#else\n        /* constant timeout, no backoff */\n        best->next_try = local_now + best->timeout;\n#endif\n        *opcode = best->opcode;\n        dmsg(D_REL_DEBUG, \"ACK reliable_send ID \" packet_id_format \" (size=%d to=%d)\",\n             (packet_id_print_type)best->packet_id, best->buf.len,\n             (int)(best->next_try - local_now));\n        return &best->buf;\n    }\n    return NULL;\n}", "path": "openvpn/src/openvpn/reliable.c", "commit_date": "2020-10-24 00:00:00", "repo_name": "OpenVPN/openvpn", "stars": 9723, "license": "other", "language": "c", "size": 22228}
{"docstring": "/* grab a free buffer */\n", "func_signal": "struct buffer *\nreliable_get_buf(struct reliable *rel)", "code": "{\n    int i;\n    for (i = 0; i < rel->size; ++i)\n    {\n        struct reliable_entry *e = &rel->array[i];\n        if (!e->active)\n        {\n            ASSERT(buf_init(&e->buf, rel->offset));\n            return &e->buf;\n        }\n    }\n    return NULL;\n}", "path": "openvpn/src/openvpn/reliable.c", "commit_date": "2020-10-24 00:00:00", "repo_name": "OpenVPN/openvpn", "stars": 9723, "license": "other", "language": "c", "size": 22228}
{"docstring": "/* print the current sequence of active packet IDs */\n", "func_signal": "static const char *\nreliable_print_ids(const struct reliable *rel, struct gc_arena *gc)", "code": "{\n    struct buffer out = alloc_buf_gc(256, gc);\n    int i;\n\n    buf_printf(&out, \"[\" packet_id_format \"]\", (packet_id_print_type)rel->packet_id);\n    for (i = 0; i < rel->size; ++i)\n    {\n        const struct reliable_entry *e = &rel->array[i];\n        if (e->active)\n        {\n            buf_printf(&out, \" \" packet_id_format, (packet_id_print_type)e->packet_id);\n        }\n    }\n    return BSTR(&out);\n}", "path": "openvpn/src/openvpn/reliable.c", "commit_date": "2020-10-24 00:00:00", "repo_name": "OpenVPN/openvpn", "stars": 9723, "license": "other", "language": "c", "size": 22228}
{"docstring": "/* no active buffers? */\n", "func_signal": "bool\nreliable_empty(const struct reliable *rel)", "code": "{\n    int i;\n    for (i = 0; i < rel->size; ++i)\n    {\n        const struct reliable_entry *e = &rel->array[i];\n        if (e->active)\n        {\n            return false;\n        }\n    }\n    return true;\n}", "path": "openvpn/src/openvpn/reliable.c", "commit_date": "2020-10-24 00:00:00", "repo_name": "OpenVPN/openvpn", "stars": 9723, "license": "other", "language": "c", "size": 22228}
{"docstring": "/*\n * verify that test - base < extent while allowing for base or test wraparound\n */\n", "func_signal": "static inline bool\nreliable_pid_in_range1(const packet_id_type test,\n                       const packet_id_type base,\n                       const unsigned int extent)", "code": "{\n    if (test >= base)\n    {\n        if (test - base < extent)\n        {\n            return true;\n        }\n    }\n    else\n    {\n        if ((test+0x80000000u) - (base+0x80000000u) < extent)\n        {\n            return true;\n        }\n    }\n\n    return false;\n}", "path": "openvpn/src/openvpn/reliable.c", "commit_date": "2020-10-24 00:00:00", "repo_name": "OpenVPN/openvpn", "stars": 9723, "license": "other", "language": "c", "size": 22228}
{"docstring": "/* In the v2 compression schemes, an uncompressed packet has\n * has no opcode in front, unless the first byte is 0x50. In this\n * case the packet needs to be escaped */\n", "func_signal": "void\ncompv2_escape_data_ifneeded(struct buffer *buf)", "code": "{\n    uint8_t *head = BPTR(buf);\n    if (head[0] != COMP_ALGV2_INDICATOR_BYTE)\n    {\n        return;\n    }\n\n    /* Header is 0x50 */\n    ASSERT(buf_prepend(buf, 2));\n\n    head = BPTR(buf);\n    head[0] = COMP_ALGV2_INDICATOR_BYTE;\n    head[1] = COMP_ALGV2_UNCOMPRESSED;\n}", "path": "openvpn/src/openvpn/comp.c", "commit_date": "2020-06-26 00:00:00", "repo_name": "OpenVPN/openvpn", "stars": 9723, "license": "other", "language": "c", "size": 22228}
{"docstring": "/* check if a particular packet_id is present in ack */\n", "func_signal": "static inline bool\nreliable_ack_packet_id_present(struct reliable_ack *ack, packet_id_type pid)", "code": "{\n    int i;\n    for (i = 0; i < ack->len; ++i)\n    {\n        if (ack->packet_id[i] == pid)\n        {\n            return true;\n        }\n    }\n    return false;\n}", "path": "openvpn/src/openvpn/reliable.c", "commit_date": "2020-10-24 00:00:00", "repo_name": "OpenVPN/openvpn", "stars": 9723, "license": "other", "language": "c", "size": 22228}
{"docstring": "/*\n * Zero off the host bits in an address, leaving\n * only the network bits, using the netbits member of\n * struct mroute_addr as the controlling parameter.\n *\n * TODO: this is called for route-lookup for every yet-unhashed\n * destination address, so for lots of active net-iroutes, this\n * might benefit from some \"zeroize 32 bit at a time\" improvements\n */\n", "func_signal": "void\nmroute_addr_mask_host_bits(struct mroute_addr *ma)", "code": "{\n    if ((ma->type & MR_ADDR_MASK) == MR_ADDR_IPV4)\n    {\n        in_addr_t addr = ntohl(ma->v4.addr);\n        addr &= netbits_to_netmask(ma->netbits);\n        ma->v4.addr = htonl(addr);\n    }\n    else if ((ma->type & MR_ADDR_MASK) == MR_ADDR_IPV6)\n    {\n        int byte = sizeof(ma->v6.addr) - 1;     /* rightmost byte in address */\n        int bits_to_clear = 128 - ma->netbits;\n\n        while (byte >= 0 && bits_to_clear > 0)\n        {\n            if (bits_to_clear >= 8)\n            {\n                ma->v6.addr.s6_addr[byte--] = 0;\n                bits_to_clear -= 8;\n            }\n            else\n            {\n                ma->v6.addr.s6_addr[byte--] &= (IPV4_NETMASK_HOST << bits_to_clear);\n                bits_to_clear = 0;\n            }\n        }\n        ASSERT( bits_to_clear == 0 );\n    }\n    else\n    {\n        ASSERT(0);\n    }\n}", "path": "openvpn/src/openvpn/mroute.c", "commit_date": "2020-05-07 00:00:00", "repo_name": "OpenVPN/openvpn", "stars": 9723, "license": "other", "language": "c", "size": 22228}
{"docstring": "/* true if at least one free buffer available */\n", "func_signal": "bool\nreliable_can_get(const struct reliable *rel)", "code": "{\n    struct gc_arena gc = gc_new();\n    int i;\n    for (i = 0; i < rel->size; ++i)\n    {\n        const struct reliable_entry *e = &rel->array[i];\n        if (!e->active)\n        {\n            return true;\n        }\n    }\n    dmsg(D_REL_LOW, \"ACK no free receive buffer available: %s\", reliable_print_ids(rel, &gc));\n    gc_free(&gc);\n    return false;\n}", "path": "openvpn/src/openvpn/reliable.c", "commit_date": "2020-10-24 00:00:00", "repo_name": "OpenVPN/openvpn", "stars": 9723, "license": "other", "language": "c", "size": 22228}
{"docstring": "/**\n * Native audio mixer\n * I/O Writes\n */\n", "func_signal": "static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)", "code": "{\n    AC97LinkState *s = opaque;\n    dolog (\"U nam writeb %#x <- %#x\\n\", addr, val);\n    s->cas = 0;\n}", "path": "qemu/hw/audio/ac97.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "qemu/qemu", "stars": 9044, "license": "other", "language": "c", "size": 528605}
{"docstring": "/* Unsigned 128x64 division.  Returns 1 if overflow (divide by zero or */\n/* quotient exceeds 64 bits).  Otherwise returns quotient via plow and */\n/* remainder via phigh. */\n", "func_signal": "int divu128(uint64_t *plow, uint64_t *phigh, uint64_t divisor)", "code": "{\n    uint64_t dhi = *phigh;\n    uint64_t dlo = *plow;\n    unsigned i;\n    uint64_t carry = 0;\n\n    if (divisor == 0) {\n        return 1;\n    } else if (dhi == 0) {\n        *plow  = dlo / divisor;\n        *phigh = dlo % divisor;\n        return 0;\n    } else if (dhi > divisor) {\n        return 1;\n    } else {\n\n        for (i = 0; i < 64; i++) {\n            carry = dhi >> 63;\n            dhi = (dhi << 1) | (dlo >> 63);\n            if (carry || (dhi >= divisor)) {\n                dhi -= divisor;\n                carry = 1;\n            } else {\n                carry = 0;\n            }\n            dlo = (dlo << 1) | carry;\n        }\n\n        *plow = dlo;\n        *phigh = dhi;\n        return 0;\n    }\n}", "path": "qemu/util/host-utils.c", "commit_date": "2017-01-30 00:00:00", "repo_name": "qemu/qemu", "stars": 9044, "license": "other", "language": "c", "size": 528605}
{"docstring": "/* Attach or detach a device on our only port.  */\n", "func_signal": "static void musb_attach(USBPort *port)", "code": "{\n    MUSBState *s = (MUSBState *) port->opaque;\n\n    musb_intr_set(s, musb_irq_vbus_request, 1);\n    musb_session_update(s, 0, s->session);\n}", "path": "qemu/hw/usb/hcd-musb.c", "commit_date": "2020-06-12 00:00:00", "repo_name": "qemu/qemu", "stars": 9044, "license": "other", "language": "c", "size": 528605}
{"docstring": "/* virtio-9p-pci */\n", "func_signal": "static void virtio_9p_pci_destructor(QOSGraphObject *obj)", "code": "{\n    QVirtio9PPCI *v9_pci = (QVirtio9PPCI *) obj;\n    QVirtio9P *interface = &v9_pci->v9p;\n    QOSGraphObject *pci_vobj =  &v9_pci->pci_vdev.obj;\n\n    virtio_9p_cleanup(interface);\n    qvirtio_pci_destructor(pci_vobj);\n}", "path": "qemu/tests/qtest/libqos/virtio-9p.c", "commit_date": "2020-11-01 00:00:00", "repo_name": "qemu/qemu", "stars": 9044, "license": "other", "language": "c", "size": 528605}
{"docstring": "/* Generic control */\n", "func_signal": "static uint32_t musb_readb(void *opaque, hwaddr addr)", "code": "{\n    MUSBState *s = (MUSBState *) opaque;\n    int ep, i;\n    uint8_t ret;\n\n    switch (addr) {\n    case MUSB_HDRC_FADDR:\n        return s->faddr;\n    case MUSB_HDRC_POWER:\n        return s->power;\n    case MUSB_HDRC_INTRUSB:\n        ret = s->intr;\n        for (i = 0; i < sizeof(ret) * 8; i ++)\n            if (ret & (1 << i))\n                musb_intr_set(s, i, 0);\n        return ret;\n    case MUSB_HDRC_INTRUSBE:\n        return s->mask;\n    case MUSB_HDRC_INDEX:\n        return s->idx;\n    case MUSB_HDRC_TESTMODE:\n        return 0x00;\n\n    case MUSB_HDRC_EP_IDX ... (MUSB_HDRC_EP_IDX + 0xf):\n        return musb_ep_readb(s, s->idx, addr & 0xf);\n\n    case MUSB_HDRC_DEVCTL:\n        return s->devctl;\n\n    case MUSB_HDRC_TXFIFOSZ:\n    case MUSB_HDRC_RXFIFOSZ:\n    case MUSB_HDRC_VCTRL:\n        /* TODO */\n        return 0x00;\n\n    case MUSB_HDRC_HWVERS:\n        return (1 << 10) | 400;\n\n    case (MUSB_HDRC_VCTRL | 1):\n    case (MUSB_HDRC_HWVERS | 1):\n    case (MUSB_HDRC_DEVCTL | 1):\n        return 0x00;\n\n    case MUSB_HDRC_BUSCTL ... (MUSB_HDRC_BUSCTL + 0x7f):\n        ep = (addr >> 3) & 0xf;\n        return musb_busctl_readb(s, ep, addr & 0x7);\n\n    case MUSB_HDRC_EP ... (MUSB_HDRC_EP + 0xff):\n        ep = (addr >> 4) & 0xf;\n        return musb_ep_readb(s, ep, addr & 0xf);\n\n    case MUSB_HDRC_FIFO ... (MUSB_HDRC_FIFO + 0x3f):\n        ep = ((addr - MUSB_HDRC_FIFO) >> 2) & 0xf;\n        return musb_read_fifo(s->ep + ep);\n\n    default:\n        TRACE(\"unknown register 0x%02x\", (int) addr);\n        return 0x00;\n    };\n}", "path": "qemu/hw/usb/hcd-musb.c", "commit_date": "2020-06-12 00:00:00", "repo_name": "qemu/qemu", "stars": 9044, "license": "other", "language": "c", "size": 528605}
{"docstring": "/* ISA information. */\n", "func_signal": "xtensa_isa xtensa_isa_init(void *xtensa_modules, xtensa_isa_status *errno_p,\n                           char **error_msg_p)", "code": "{\n    xtensa_isa_internal *isa = xtensa_modules;\n    int n, is_user;\n\n    /* Set up the opcode name lookup table. */\n    isa->opname_lookup_table =\n        malloc(isa->num_opcodes * sizeof(xtensa_lookup_entry));\n    CHECK_ALLOC_FOR_INIT(isa->opname_lookup_table, NULL, errno_p, error_msg_p);\n    for (n = 0; n < isa->num_opcodes; n++) {\n        isa->opname_lookup_table[n].key = isa->opcodes[n].name;\n        isa->opname_lookup_table[n].u.opcode = n;\n    }\n    qsort(isa->opname_lookup_table, isa->num_opcodes,\n          sizeof(xtensa_lookup_entry), xtensa_isa_name_compare);\n\n    /* Set up the state name lookup table. */\n    isa->state_lookup_table =\n        malloc(isa->num_states * sizeof(xtensa_lookup_entry));\n    CHECK_ALLOC_FOR_INIT(isa->state_lookup_table, NULL, errno_p, error_msg_p);\n    for (n = 0; n < isa->num_states; n++) {\n        isa->state_lookup_table[n].key = isa->states[n].name;\n        isa->state_lookup_table[n].u.state = n;\n    }\n    qsort(isa->state_lookup_table, isa->num_states,\n          sizeof(xtensa_lookup_entry), xtensa_isa_name_compare);\n\n    /* Set up the sysreg name lookup table. */\n    isa->sysreg_lookup_table =\n        malloc(isa->num_sysregs * sizeof(xtensa_lookup_entry));\n    CHECK_ALLOC_FOR_INIT(isa->sysreg_lookup_table, NULL, errno_p, error_msg_p);\n    for (n = 0; n < isa->num_sysregs; n++) {\n        isa->sysreg_lookup_table[n].key = isa->sysregs[n].name;\n        isa->sysreg_lookup_table[n].u.sysreg = n;\n    }\n    qsort(isa->sysreg_lookup_table, isa->num_sysregs,\n          sizeof(xtensa_lookup_entry), xtensa_isa_name_compare);\n\n    /* Set up the user & system sysreg number tables. */\n    for (is_user = 0; is_user < 2; is_user++) {\n        isa->sysreg_table[is_user] =\n            malloc((isa->max_sysreg_num[is_user] + 1) * sizeof(xtensa_sysreg));\n        CHECK_ALLOC_FOR_INIT(isa->sysreg_table[is_user], NULL,\n                             errno_p, error_msg_p);\n\n        for (n = 0; n <= isa->max_sysreg_num[is_user]; n++) {\n            isa->sysreg_table[is_user][n] = XTENSA_UNDEFINED;\n        }\n    }\n    for (n = 0; n < isa->num_sysregs; n++) {\n        xtensa_sysreg_internal *sreg = &isa->sysregs[n];\n        is_user = sreg->is_user;\n\n        if (sreg->number >= 0) {\n            isa->sysreg_table[is_user][sreg->number] = n;\n        }\n    }\n\n    /* Set up the interface lookup table. */\n    isa->interface_lookup_table =\n        malloc(isa->num_interfaces * sizeof(xtensa_lookup_entry));\n    CHECK_ALLOC_FOR_INIT(isa->interface_lookup_table, NULL, errno_p,\n                         error_msg_p);\n    for (n = 0; n < isa->num_interfaces; n++) {\n        isa->interface_lookup_table[n].key = isa->interfaces[n].name;\n        isa->interface_lookup_table[n].u.intf = n;\n    }\n    qsort(isa->interface_lookup_table, isa->num_interfaces,\n          sizeof(xtensa_lookup_entry), xtensa_isa_name_compare);\n\n    /* Set up the funcUnit lookup table. */\n    isa->funcUnit_lookup_table =\n        malloc(isa->num_funcUnits * sizeof(xtensa_lookup_entry));\n    CHECK_ALLOC_FOR_INIT(isa->funcUnit_lookup_table, NULL, errno_p,\n                         error_msg_p);\n    for (n = 0; n < isa->num_funcUnits; n++) {\n        isa->funcUnit_lookup_table[n].key = isa->funcUnits[n].name;\n        isa->funcUnit_lookup_table[n].u.fun = n;\n    }\n    qsort(isa->funcUnit_lookup_table, isa->num_funcUnits,\n          sizeof(xtensa_lookup_entry), xtensa_isa_name_compare);\n\n    isa->insnbuf_size = ((isa->insn_size + sizeof(xtensa_insnbuf_word) - 1) /\n                         sizeof(xtensa_insnbuf_word));\n    isa->num_stages = XTENSA_UNDEFINED;\n\n    return (xtensa_isa)isa;\n}", "path": "qemu/target/xtensa/xtensa-isa.c", "commit_date": "2018-02-09 00:00:00", "repo_name": "qemu/qemu", "stars": 9044, "license": "other", "language": "c", "size": 528605}
{"docstring": "/* virtio-9p-device */\n", "func_signal": "static void virtio_9p_device_destructor(QOSGraphObject *obj)", "code": "{\n    QVirtio9PDevice *v_9p = (QVirtio9PDevice *) obj;\n    QVirtio9P *v9p = &v_9p->v9p;\n\n    virtio_9p_cleanup(v9p);\n}", "path": "qemu/tests/qtest/libqos/virtio-9p.c", "commit_date": "2020-11-01 00:00:00", "repo_name": "qemu/qemu", "stars": 9044, "license": "other", "language": "c", "size": 528605}
{"docstring": "/* Bus control */\n", "func_signal": "static uint8_t musb_busctl_readb(void *opaque, int ep, int addr)", "code": "{\n    MUSBState *s = (MUSBState *) opaque;\n\n    switch (addr) {\n    /* For USB2.0 HS hubs only */\n    case MUSB_HDRC_TXHUBADDR:\n        return s->ep[ep].haddr[0];\n    case MUSB_HDRC_TXHUBPORT:\n        return s->ep[ep].hport[0];\n    case MUSB_HDRC_RXHUBADDR:\n        return s->ep[ep].haddr[1];\n    case MUSB_HDRC_RXHUBPORT:\n        return s->ep[ep].hport[1];\n\n    default:\n        TRACE(\"unknown register 0x%02x\", addr);\n        return 0x00;\n    };\n}", "path": "qemu/hw/usb/hcd-musb.c", "commit_date": "2020-06-12 00:00:00", "repo_name": "qemu/qemu", "stars": 9044, "license": "other", "language": "c", "size": 528605}
{"docstring": "/* min_size must be a power of 2. */\n", "func_signal": "static void ipmi_kcs_init(IPMIInterface *ii, unsigned int min_size,\n                          Error **errp)", "code": "{\n    IPMIInterfaceClass *iic = IPMI_INTERFACE_GET_CLASS(ii);\n    IPMIKCS *ik = iic->get_backend_data(ii);\n\n    if (min_size == 0) {\n        min_size = 2;\n    }\n    ik->size_mask = min_size - 1;\n    ik->io_length = 2;\n    memory_region_init_io(&ik->io, NULL, &ipmi_kcs_io_ops, ii, \"ipmi-kcs\",\n                          min_size);\n}", "path": "qemu/hw/ipmi/ipmi_kcs.c", "commit_date": "2019-09-20 00:00:00", "repo_name": "qemu/qemu", "stars": 9044, "license": "other", "language": "c", "size": 528605}
{"docstring": "/**\n * Native audio bus master\n * I/O Reads\n */\n", "func_signal": "static uint32_t nabm_readb (void *opaque, uint32_t addr)", "code": "{\n    AC97LinkState *s = opaque;\n    AC97BusMasterRegs *r = NULL;\n    uint32_t index = addr;\n    uint32_t val = ~0U;\n\n    switch (index) {\n    case CAS:\n        dolog (\"CAS %d\\n\", s->cas);\n        val = s->cas;\n        s->cas = 1;\n        break;\n    case PI_CIV:\n    case PO_CIV:\n    case MC_CIV:\n        r = &s->bm_regs[GET_BM (index)];\n        val = r->civ;\n        dolog (\"CIV[%d] -> %#x\\n\", GET_BM (index), val);\n        break;\n    case PI_LVI:\n    case PO_LVI:\n    case MC_LVI:\n        r = &s->bm_regs[GET_BM (index)];\n        val = r->lvi;\n        dolog (\"LVI[%d] -> %#x\\n\", GET_BM (index), val);\n        break;\n    case PI_PIV:\n    case PO_PIV:\n    case MC_PIV:\n        r = &s->bm_regs[GET_BM (index)];\n        val = r->piv;\n        dolog (\"PIV[%d] -> %#x\\n\", GET_BM (index), val);\n        break;\n    case PI_CR:\n    case PO_CR:\n    case MC_CR:\n        r = &s->bm_regs[GET_BM (index)];\n        val = r->cr;\n        dolog (\"CR[%d] -> %#x\\n\", GET_BM (index), val);\n        break;\n    case PI_SR:\n    case PO_SR:\n    case MC_SR:\n        r = &s->bm_regs[GET_BM (index)];\n        val = r->sr & 0xff;\n        dolog (\"SRb[%d] -> %#x\\n\", GET_BM (index), val);\n        break;\n    default:\n        dolog (\"U nabm readb %#x -> %#x\\n\", addr, val);\n        break;\n    }\n    return val;\n}", "path": "qemu/hw/audio/ac97.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "qemu/qemu", "stars": 9044, "license": "other", "language": "c", "size": 528605}
{"docstring": "/* Signed 64x64 -> 128 multiplication */\n", "func_signal": "void muls64 (uint64_t *plow, uint64_t *phigh, int64_t a, int64_t b)", "code": "{\n    uint64_t rh;\n\n    mul64(plow, &rh, a, b);\n\n    /* Adjust for signs.  */\n    if (b < 0) {\n        rh -= a;\n    }\n    if (a < 0) {\n        rh -= b;\n    }\n    *phigh = rh;\n}", "path": "qemu/util/host-utils.c", "commit_date": "2017-01-30 00:00:00", "repo_name": "qemu/qemu", "stars": 9044, "license": "other", "language": "c", "size": 528605}
{"docstring": "/* Long integer helpers */\n", "func_signal": "static inline void mul64(uint64_t *plow, uint64_t *phigh,\n                         uint64_t a, uint64_t b)", "code": "{\n    typedef union {\n        uint64_t ll;\n        struct {\n#ifdef HOST_WORDS_BIGENDIAN\n            uint32_t high, low;\n#else\n            uint32_t low, high;\n#endif\n        } l;\n    } LL;\n    LL rl, rm, rn, rh, a0, b0;\n    uint64_t c;\n\n    a0.ll = a;\n    b0.ll = b;\n\n    rl.ll = (uint64_t)a0.l.low * b0.l.low;\n    rm.ll = (uint64_t)a0.l.low * b0.l.high;\n    rn.ll = (uint64_t)a0.l.high * b0.l.low;\n    rh.ll = (uint64_t)a0.l.high * b0.l.high;\n\n    c = (uint64_t)rl.l.high + rm.l.low + rn.l.low;\n    rl.l.high = c;\n    c >>= 32;\n    c = c + rm.l.high + rn.l.high + rh.l.low;\n    rh.l.low = c;\n    rh.l.high += (uint32_t)(c >> 32);\n\n    *plow = rl.ll;\n    *phigh = rh.ll;\n}", "path": "qemu/util/host-utils.c", "commit_date": "2017-01-30 00:00:00", "repo_name": "qemu/qemu", "stars": 9044, "license": "other", "language": "c", "size": 528605}
{"docstring": "/**\n * Performs regular expression based search and replace on @a haystack.\n *\n * @param haystack - input string to be parsed, result of replacement is\n *                   stored back to @a haystack\n * @param pattern - the regular expression pattern for scanning @a haystack\n * @param replace_fmt - matches of supplied @a pattern are replaced by this,\n *                      if necessary glib printf format can be used to add\n *                      variable arguments of this function to this\n *                      replacement string\n */\n", "func_signal": "static void regex_replace(GString *haystack, const char *pattern,\n                          const char *replace_fmt, ...)", "code": "{\n    GRegex *regex;\n    char *replace, *s;\n    va_list argp;\n\n    va_start(argp, replace_fmt);\n    replace = g_strdup_vprintf(replace_fmt, argp);\n    va_end(argp);\n\n    regex = g_regex_new(pattern, 0, 0, NULL);\n    s = g_regex_replace(regex, haystack->str, -1, 0, replace, 0, NULL);\n    g_string_assign(haystack, s);\n    g_free(s);\n    g_regex_unref(regex);\n    g_free(replace);\n}", "path": "qemu/tests/qtest/libqos/virtio-9p.c", "commit_date": "2020-11-01 00:00:00", "repo_name": "qemu/qemu", "stars": 9044, "license": "other", "language": "c", "size": 528605}
{"docstring": "/**\n * Native audio bus master\n * I/O Writes\n */\n", "func_signal": "static void nabm_writeb (void *opaque, uint32_t addr, uint32_t val)", "code": "{\n    AC97LinkState *s = opaque;\n    AC97BusMasterRegs *r = NULL;\n    uint32_t index = addr;\n    switch (index) {\n    case PI_LVI:\n    case PO_LVI:\n    case MC_LVI:\n        r = &s->bm_regs[GET_BM (index)];\n        if ((r->cr & CR_RPBM) && (r->sr & SR_DCH)) {\n            r->sr &= ~(SR_DCH | SR_CELV);\n            r->civ = r->piv;\n            r->piv = (r->piv + 1) % 32;\n            fetch_bd (s, r);\n        }\n        r->lvi = val % 32;\n        dolog (\"LVI[%d] <- %#x\\n\", GET_BM (index), val);\n        break;\n    case PI_CR:\n    case PO_CR:\n    case MC_CR:\n        r = &s->bm_regs[GET_BM (index)];\n        if (val & CR_RR) {\n            reset_bm_regs (s, r);\n        }\n        else {\n            r->cr = val & CR_VALID_MASK;\n            if (!(r->cr & CR_RPBM)) {\n                voice_set_active (s, r - s->bm_regs, 0);\n                r->sr |= SR_DCH;\n            }\n            else {\n                r->civ = r->piv;\n                r->piv = (r->piv + 1) % 32;\n                fetch_bd (s, r);\n                r->sr &= ~SR_DCH;\n                voice_set_active (s, r - s->bm_regs, 1);\n            }\n        }\n        dolog (\"CR[%d] <- %#x (cr %#x)\\n\", GET_BM (index), val, r->cr);\n        break;\n    case PI_SR:\n    case PO_SR:\n    case MC_SR:\n        r = &s->bm_regs[GET_BM (index)];\n        r->sr |= val & ~(SR_RO_MASK | SR_WCLEAR_MASK);\n        update_sr (s, r, r->sr & ~(val & SR_WCLEAR_MASK));\n        dolog (\"SR[%d] <- %#x (sr %#x)\\n\", GET_BM (index), val, r->sr);\n        break;\n    default:\n        dolog (\"U nabm writeb %#x <- %#x\\n\", addr, val);\n        break;\n    }\n}", "path": "qemu/hw/audio/ac97.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "qemu/qemu", "stars": 9044, "license": "other", "language": "c", "size": 528605}
{"docstring": "/**\n * Native audio mixer\n * I/O Reads\n */\n", "func_signal": "static uint32_t nam_readb (void *opaque, uint32_t addr)", "code": "{\n    AC97LinkState *s = opaque;\n    dolog (\"U nam readb %#x\\n\", addr);\n    s->cas = 0;\n    return ~0U;\n}", "path": "qemu/hw/audio/ac97.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "qemu/qemu", "stars": 9044, "license": "other", "language": "c", "size": 528605}
{"docstring": "/*\n * Prepare processing.\n */\n", "func_signal": "void *st_rate_start (int inrate, int outrate)", "code": "{\n    struct rate *rate = audio_calloc(__func__, 1, sizeof(*rate));\n\n    if (!rate) {\n        dolog (\"Could not allocate resampler (%zu bytes)\\n\", sizeof (*rate));\n        return NULL;\n    }\n\n    rate->opos = 0;\n\n    /* increment */\n    rate->opos_inc = ((uint64_t) inrate << 32) / outrate;\n\n    rate->ipos = 0;\n    rate->ilast.l = 0;\n    rate->ilast.r = 0;\n    return rate;\n}", "path": "qemu/audio/mixeng.c", "commit_date": "2020-05-26 00:00:00", "repo_name": "qemu/qemu", "stars": 9044, "license": "other", "language": "c", "size": 528605}
{"docstring": "/* Endpoint control */\n", "func_signal": "static uint8_t musb_ep_readb(void *opaque, int ep, int addr)", "code": "{\n    MUSBState *s = (MUSBState *) opaque;\n\n    switch (addr) {\n    case MUSB_HDRC_TXTYPE:\n        return s->ep[ep].type[0];\n    case MUSB_HDRC_TXINTERVAL:\n        return s->ep[ep].interval[0];\n    case MUSB_HDRC_RXTYPE:\n        return s->ep[ep].type[1];\n    case MUSB_HDRC_RXINTERVAL:\n        return s->ep[ep].interval[1];\n    case (MUSB_HDRC_FIFOSIZE & ~1):\n        return 0x00;\n    case MUSB_HDRC_FIFOSIZE:\n        return ep ? s->ep[ep].fifosize : s->ep[ep].config;\n    case MUSB_HDRC_RXCOUNT:\n        return s->ep[ep].rxcount;\n\n    default:\n        TRACE(\"unknown register 0x%02x\", addr);\n        return 0x00;\n    };\n}", "path": "qemu/hw/usb/hcd-musb.c", "commit_date": "2020-06-12 00:00:00", "repo_name": "qemu/qemu", "stars": 9044, "license": "other", "language": "c", "size": 528605}
{"docstring": "/**\n * urshift - 128-bit Unsigned Right Shift.\n * @plow: in/out - lower 64-bit integer.\n * @phigh: in/out - higher 64-bit integer.\n * @shift: in - bytes to shift, between 0 and 127.\n *\n * Result is zero-extended and stored in plow/phigh, which are\n * input/output variables. Shift values outside the range will\n * be mod to 128. In other words, the caller is responsible to\n * verify/assert both the shift range and plow/phigh pointers.\n */\n", "func_signal": "void urshift(uint64_t *plow, uint64_t *phigh, int32_t shift)", "code": "{\n    shift &= 127;\n    if (shift == 0) {\n        return;\n    }\n\n    uint64_t h = *phigh >> (shift & 63);\n    if (shift >= 64) {\n        *plow = h;\n        *phigh = 0;\n    } else {\n        *plow = (*plow >> (shift & 63)) | (*phigh << (64 - (shift & 63)));\n        *phigh = h;\n    }\n}", "path": "qemu/util/host-utils.c", "commit_date": "2017-01-30 00:00:00", "repo_name": "qemu/qemu", "stars": 9044, "license": "other", "language": "c", "size": 528605}
{"docstring": "/*\n * Inward conversion from byte stream to xtensa_insnbuf. See\n * xtensa_insnbuf_to_chars for a discussion of why this is complicated\n * by endianness.\n */\n", "func_signal": "void xtensa_insnbuf_from_chars(xtensa_isa isa,\n                               xtensa_insnbuf insn,\n                               const unsigned char *cp,\n                               int num_chars)", "code": "{\n    xtensa_isa_internal *intisa = (xtensa_isa_internal *)isa;\n    int max_size, insn_size, fence_post, start, increment, i;\n\n    max_size = xtensa_isa_maxlength(isa);\n\n    /* Decode the instruction length so we know how many bytes to read. */\n    insn_size = (intisa->length_decode_fn)(cp);\n    if (insn_size == XTENSA_UNDEFINED) {\n        /*\n         * This should never happen when the byte stream contains a\n         * valid instruction. Just read the maximum number of bytes....\n         */\n        insn_size = max_size;\n    }\n\n    if (num_chars == 0 || num_chars > insn_size) {\n        num_chars = insn_size;\n    }\n\n    if (intisa->is_big_endian) {\n        start = max_size - 1;\n        increment = -1;\n    } else {\n        start = 0;\n        increment = 1;\n    }\n\n    fence_post = start + (num_chars * increment);\n    memset(insn, 0, xtensa_insnbuf_size(isa) * sizeof(xtensa_insnbuf_word));\n\n    for (i = start; i != fence_post; i += increment, ++cp) {\n        int word_inx = byte_to_word_index(i);\n        int bit_inx = byte_to_bit_index(i);\n\n        insn[word_inx] |= (*cp & 0xff) << bit_inx;\n    }\n}", "path": "qemu/target/xtensa/xtensa-isa.c", "commit_date": "2018-02-09 00:00:00", "repo_name": "qemu/qemu", "stars": 9044, "license": "other", "language": "c", "size": 528605}
{"docstring": "/*\n * Copy an instruction in the 32-bit words pointed at by \"insn\" to\n * characters pointed at by \"cp\". This is more complicated than you\n * might think because we want 16-bit instructions in bytes 2 & 3 for\n * big-endian configurations. This function allows us to specify\n * which byte in \"insn\" to start with and which way to increment,\n * allowing trivial implementation for both big- and little-endian\n * configurations....and it seems to make pretty good code for\n * both.\n */\n", "func_signal": "int xtensa_insnbuf_to_chars(xtensa_isa isa,\n                            const xtensa_insnbuf insn,\n                            unsigned char *cp,\n                            int num_chars)", "code": "{\n    xtensa_isa_internal *intisa = (xtensa_isa_internal *)isa;\n    int insn_size = xtensa_isa_maxlength(isa);\n    int fence_post, start, increment, i, byte_count;\n    xtensa_format fmt;\n\n    if (num_chars == 0) {\n        num_chars = insn_size;\n    }\n\n    if (intisa->is_big_endian) {\n        start = insn_size - 1;\n        increment = -1;\n    } else {\n        start = 0;\n        increment = 1;\n    }\n\n    /*\n     * Find the instruction format. Do nothing if the buffer does not contain\n     * a valid instruction since we need to know how many bytes to copy.\n     */\n    fmt = xtensa_format_decode(isa, insn);\n    if (fmt == XTENSA_UNDEFINED) {\n        return XTENSA_UNDEFINED;\n    }\n\n    byte_count = xtensa_format_length(isa, fmt);\n    if (byte_count == XTENSA_UNDEFINED) {\n        return XTENSA_UNDEFINED;\n    }\n\n    if (byte_count > num_chars) {\n        xtisa_errno = xtensa_isa_buffer_overflow;\n        strcpy(xtisa_error_msg, \"output buffer too small for instruction\");\n        return XTENSA_UNDEFINED;\n    }\n\n    fence_post = start + (byte_count * increment);\n\n    for (i = start; i != fence_post; i += increment, ++cp) {\n        int word_inx = byte_to_word_index(i);\n        int bit_inx = byte_to_bit_index(i);\n\n        *cp = (insn[word_inx] >> bit_inx) & 0xff;\n    }\n\n    return byte_count;\n}", "path": "qemu/target/xtensa/xtensa-isa.c", "commit_date": "2018-02-09 00:00:00", "repo_name": "qemu/qemu", "stars": 9044, "license": "other", "language": "c", "size": 528605}
{"docstring": "////////////////////////////////////////////////////////////////////////////////\n// control command\n", "func_signal": "eia608_control_t eia608_parse_control(uint16_t cc_data, int* cc)", "code": "{\n    if (0x0200 & cc_data) {\n        (*cc) = (cc_data & 0x0800 ? 0x01 : 0x00);\n        return (eia608_control_t)(0x177F & cc_data);\n    } else {\n        (*cc) = (cc_data & 0x0800 ? 0x01 : 0x00) | (cc_data & 0x0100 ? 0x02 : 0x00);\n        return (eia608_control_t)(0x167F & cc_data);\n    }\n}", "path": "obs-studio/deps/libcaption/src/eia608.c", "commit_date": "2018-07-08 00:00:00", "repo_name": "obsproject/obs-studio", "stars": 54512, "license": "gpl-2.0", "language": "c", "size": 68469}
{"docstring": "/*\n * The next two internal support functions depend on only being\n * called by the thread that owns the robust mutex. This enables\n * us to avoid additional locks.\n * Any mutex currently in the thread's robust mutex list is held\n * by the thread, again eliminating the need for locks.\n * The forward/backward links allow the thread to unlock mutexes\n * in any order, not necessarily the reverse locking order.\n * This is all possible because it is an error if a thread that\n * does not own the [robust] mutex attempts to unlock it.\n */\n", "func_signal": "INLINE\nvoid\nptw32_robust_mutex_add(pthread_mutex_t* mutex, pthread_t self)", "code": "{\n  ptw32_robust_node_t** list;\n  pthread_mutex_t mx = *mutex;\n  ptw32_thread_t* tp = (ptw32_thread_t*)self.p;\n  ptw32_robust_node_t* robust = mx->robustNode;\n\n  list = &tp->robustMxList;\n  mx->ownerThread = self;\n  if (NULL == *list)\n    {\n      robust->prev = NULL;\n      robust->next = NULL;\n      *list = robust;\n    }\n  else\n    {\n      robust->prev = NULL;\n      robust->next = *list;\n      (*list)->prev = robust;\n      *list = robust;\n    }\n}", "path": "obs-studio/deps/w32-pthreads/pthread_mutex_consistent.c", "commit_date": "2015-07-11 00:00:00", "repo_name": "obsproject/obs-studio", "stars": 54512, "license": "gpl-2.0", "language": "c", "size": 68469}
{"docstring": "/**\n * get the default properties\n */\n", "func_signal": "static pa_proplist *pulseaudio_properties()", "code": "{\n\tpa_proplist *p = pa_proplist_new();\n\n\tpa_proplist_sets(p, PA_PROP_APPLICATION_NAME, \"OBS\");\n\tpa_proplist_sets(p, PA_PROP_APPLICATION_ICON_NAME, \"obs\");\n\tpa_proplist_sets(p, PA_PROP_MEDIA_ROLE, \"production\");\n\n\treturn p;\n}", "path": "obs-studio/libobs/audio-monitoring/pulse/pulseaudio-wrapper.c", "commit_date": "2020-01-18 00:00:00", "repo_name": "obsproject/obs-studio", "stars": 54512, "license": "gpl-2.0", "language": "c", "size": 68469}
{"docstring": "/**\n * Create the plugin object\n */\n", "func_signal": "static void *jack_create(obs_data_t *settings, obs_source_t *source)", "code": "{\n\tstruct jack_data *data = bzalloc(sizeof(struct jack_data));\n\n\tpthread_mutex_init(&data->jack_mutex, NULL);\n\tdata->source = source;\n\tdata->channels = -1;\n\n\tjack_update(data, settings);\n\n\tif (data->jack_client == NULL) {\n\t\tjack_destroy(data);\n\t\treturn NULL;\n\t}\n\treturn data;\n}", "path": "obs-studio/plugins/linux-jack/jack-input.c", "commit_date": "2019-11-25 00:00:00", "repo_name": "obsproject/obs-studio", "stars": 54512, "license": "gpl-2.0", "language": "c", "size": 68469}
{"docstring": "/* inlen, at least, should be uint64_t. Others can be size_t. */\n", "func_signal": "int blake2b( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen )", "code": "{\n  blake2b_state S[1];\n\n  /* Verify parameters */\n  if ( NULL == in && inlen > 0 ) return -1;\n\n  if ( NULL == out ) return -1;\n\n  if( NULL == key && keylen > 0 ) return -1;\n\n  if( !outlen || outlen > BLAKE2B_OUTBYTES ) return -1;\n\n  if( keylen > BLAKE2B_KEYBYTES ) return -1;\n\n  if( keylen > 0 )\n  {\n    if( blake2b_init_key( S, outlen, key, keylen ) < 0 ) return -1;\n  }\n  else\n  {\n    if( blake2b_init( S, outlen ) < 0 ) return -1;\n  }\n\n  blake2b_update( S, ( const uint8_t * )in, inlen );\n  blake2b_final( S, out, outlen );\n  return 0;\n}", "path": "obs-studio/deps/blake2/src/blake2b-ref.c", "commit_date": "2017-02-24 00:00:00", "repo_name": "obsproject/obs-studio", "stars": 54512, "license": "gpl-2.0", "language": "c", "size": 68469}
{"docstring": "/**\n * context status change callback\n *\n * @todo this is currently a noop, we want to reconnect here if the connection\n *       is lost ...\n */\n", "func_signal": "static void pulseaudio_context_state_changed(pa_context *c, void *userdata)", "code": "{\n\tUNUSED_PARAMETER(userdata);\n\tUNUSED_PARAMETER(c);\n\n\tpulseaudio_signal(0);\n}", "path": "obs-studio/libobs/audio-monitoring/pulse/pulseaudio-wrapper.c", "commit_date": "2020-01-18 00:00:00", "repo_name": "obsproject/obs-studio", "stars": 54512, "license": "gpl-2.0", "language": "c", "size": 68469}
{"docstring": "// gain stage and ballistics in dB domain\n", "func_signal": "static inline void process_expansion(struct expander_data *cd, float **samples,\n\t\t\t\t     uint32_t num_samples)", "code": "{\n\tconst float attack_gain = cd->attack_gain;\n\tconst float release_gain = cd->release_gain;\n\n\tif (cd->gaindB_len < num_samples)\n\t\tresize_gaindB_buffer(cd, num_samples);\n\tfor (int i = 0; i < MAX_AUDIO_CHANNELS; i++)\n\t\tmemset(cd->gaindB[i], 0,\n\t\t       num_samples * sizeof(cd->gaindB[i][0]));\n\n\tfor (size_t chan = 0; chan < cd->num_channels; chan++) {\n\t\tfor (size_t i = 0; i < num_samples; ++i) {\n\t\t\t// gain stage of expansion\n\t\t\tfloat env_db = mul_to_db(cd->envelope_buf[chan][i]);\n\t\t\tfloat gain =\n\t\t\t\tcd->threshold - env_db > 0.0f\n\t\t\t\t\t? fmaxf(cd->slope * (cd->threshold -\n\t\t\t\t\t\t\t     env_db),\n\t\t\t\t\t\t-60.0f)\n\t\t\t\t\t: 0.0f;\n\t\t\t// ballistics (attack/release)\n\t\t\tif (i > 0) {\n\t\t\t\tif (gain > cd->gaindB[chan][i - 1])\n\t\t\t\t\tcd->gaindB[chan][i] =\n\t\t\t\t\t\tattack_gain *\n\t\t\t\t\t\t\tcd->gaindB[chan][i - 1] +\n\t\t\t\t\t\t(1.0f - attack_gain) * gain;\n\t\t\t\telse\n\t\t\t\t\tcd->gaindB[chan][i] =\n\t\t\t\t\t\trelease_gain *\n\t\t\t\t\t\t\tcd->gaindB[chan][i - 1] +\n\t\t\t\t\t\t(1.0f - release_gain) * gain;\n\t\t\t} else {\n\t\t\t\tif (gain > cd->gaindB_buf[chan])\n\t\t\t\t\tcd->gaindB[chan][i] =\n\t\t\t\t\t\tattack_gain *\n\t\t\t\t\t\t\tcd->gaindB_buf[chan] +\n\t\t\t\t\t\t(1.0f - attack_gain) * gain;\n\t\t\t\telse\n\t\t\t\t\tcd->gaindB[chan][i] =\n\t\t\t\t\t\trelease_gain *\n\t\t\t\t\t\t\tcd->gaindB_buf[chan] +\n\t\t\t\t\t\t(1.0f - release_gain) * gain;\n\t\t\t}\n\n\t\t\tgain = db_to_mul(fminf(0, cd->gaindB[chan][i]));\n\t\t\tif (samples[chan])\n\t\t\t\tsamples[chan][i] *= gain * cd->output_gain;\n\t\t}\n\t\tcd->gaindB_buf[chan] = cd->gaindB[chan][num_samples - 1];\n\t}\n}", "path": "obs-studio/plugins/obs-filters/expander-filter.c", "commit_date": "2019-07-18 00:00:00", "repo_name": "obsproject/obs-studio", "stars": 54512, "license": "gpl-2.0", "language": "c", "size": 68469}
{"docstring": "/**\n * wait for context to be ready\n */\n", "func_signal": "static int_fast32_t pulseaudio_context_ready()", "code": "{\n\tpulseaudio_lock();\n\n\tif (!PA_CONTEXT_IS_GOOD(pa_context_get_state(pulseaudio_context))) {\n\t\tpulseaudio_unlock();\n\t\treturn -1;\n\t}\n\n\twhile (pa_context_get_state(pulseaudio_context) != PA_CONTEXT_READY)\n\t\tpulseaudio_wait();\n\n\tpulseaudio_unlock();\n\treturn 0;\n}", "path": "obs-studio/libobs/audio-monitoring/pulse/pulseaudio-wrapper.c", "commit_date": "2020-01-18 00:00:00", "repo_name": "obsproject/obs-studio", "stars": 54512, "license": "gpl-2.0", "language": "c", "size": 68469}
{"docstring": "/**\n * Update the input settings\n */\n", "func_signal": "static void jack_update(void *vptr, obs_data_t *settings)", "code": "{\n\tstruct jack_data *data = (struct jack_data *)vptr;\n\tif (!data)\n\t\treturn;\n\n\tconst char *new_device;\n\tbool settings_changed = false;\n\tbool new_jack_start_server = obs_data_get_bool(settings, \"startjack\");\n\tint new_channel_count = obs_data_get_int(settings, \"channels\");\n\n\tif (new_jack_start_server != data->start_jack_server) {\n\t\tdata->start_jack_server = new_jack_start_server;\n\t\tsettings_changed = true;\n\t}\n\n\tif (new_channel_count != data->channels)\n\t\t/*\n\t\t * keep \"old\" channel count  for now,\n\t\t * we need to destroy the correct number of channels\n\t\t */\n\t\tsettings_changed = true;\n\n\tnew_device = obs_source_get_name(data->source);\n\tif (!data->device || strcmp(data->device, new_device) != 0) {\n\t\tif (data->device)\n\t\t\tbfree(data->device);\n\t\tdata->device = bstrdup(new_device);\n\t\tsettings_changed = true;\n\t}\n\n\tif (settings_changed) {\n\t\tdeactivate_jack(data);\n\n\t\tdata->channels = new_channel_count;\n\n\t\tif (jack_init(data) != 0) {\n\t\t\tdeactivate_jack(data);\n\t\t}\n\t}\n}", "path": "obs-studio/plugins/linux-jack/jack-input.c", "commit_date": "2019-11-25 00:00:00", "repo_name": "obsproject/obs-studio", "stars": 54512, "license": "gpl-2.0", "language": "c", "size": 68469}
{"docstring": "/* should return $HOME/.[name], or when using XDG,\n * should return $HOME/.config/[name] as default */\n", "func_signal": "char *os_get_config_path_ptr(const char *name)", "code": "{\n#ifdef USE_XDG\n\tstruct dstr path;\n\tchar *xdg_ptr = getenv(\"XDG_CONFIG_HOME\");\n\n\t/* If XDG_CONFIG_HOME is unset,\n\t * we use the default $HOME/.config/[name] instead */\n\tif (xdg_ptr == NULL) {\n\t\tchar *home_ptr = getenv(\"HOME\");\n\t\tif (home_ptr == NULL)\n\t\t\tbcrash(\"Could not get $HOME\\n\");\n\n\t\tdstr_init_copy(&path, home_ptr);\n\t\tdstr_cat(&path, \"/.config/\");\n\t\tdstr_cat(&path, name);\n\t} else {\n\t\tdstr_init_copy(&path, xdg_ptr);\n\t\tdstr_cat(&path, \"/\");\n\t\tdstr_cat(&path, name);\n\t}\n\treturn path.array;\n#else\n\tchar *path_ptr = getenv(\"HOME\");\n\tif (path_ptr == NULL)\n\t\tbcrash(\"Could not get $HOME\\n\");\n\n\tstruct dstr path;\n\tdstr_init_copy(&path, path_ptr);\n\tdstr_cat(&path, \"/.\");\n\tdstr_cat(&path, name);\n\treturn path.array;\n#endif\n}", "path": "obs-studio/libobs/util/platform-nix.c", "commit_date": "2020-11-14 00:00:00", "repo_name": "obsproject/obs-studio", "stars": 54512, "license": "gpl-2.0", "language": "c", "size": 68469}
{"docstring": "// detection stage\n", "func_signal": "static void analyze_envelope(struct expander_data *cd, float **samples,\n\t\t\t     const uint32_t num_samples)", "code": "{\n\tif (cd->envelope_buf_len < num_samples)\n\t\tresize_env_buffer(cd, num_samples);\n\tif (cd->runaverage_len < num_samples)\n\t\tresize_runaverage_buffer(cd, num_samples);\n\tif (cd->env_in_len < num_samples)\n\t\tresize_env_in_buffer(cd, num_samples);\n\n\t// 10 ms RMS window\n\tconst float rmscoef = exp2f(-100.0f / cd->sample_rate);\n\n\tfor (int i = 0; i < MAX_AUDIO_CHANNELS; i++) {\n\t\tmemset(cd->envelope_buf[i], 0,\n\t\t       num_samples * sizeof(cd->envelope_buf[i][0]));\n\t\tmemset(cd->runaverage[i], 0,\n\t\t       num_samples * sizeof(cd->runaverage[i][0]));\n\t}\n\tmemset(cd->env_in, 0, num_samples * sizeof(cd->env_in[0]));\n\n\tfor (size_t chan = 0; chan < cd->num_channels; ++chan) {\n\t\tif (!samples[chan])\n\t\t\tcontinue;\n\n\t\tfloat *envelope_buf = cd->envelope_buf[chan];\n\t\tfloat *runave = cd->runaverage[chan];\n\t\tfloat *env_in = cd->env_in;\n\n\t\tif (cd->detector == RMS_DETECT) {\n\t\t\trunave[0] =\n\t\t\t\trmscoef * cd->runave[chan] +\n\t\t\t\t(1 - rmscoef) * powf(samples[chan][0], 2.0f);\n\t\t\tenv_in[0] = sqrtf(fmaxf(runave[0], 0));\n\t\t\tfor (uint32_t i = 1; i < num_samples; ++i) {\n\t\t\t\trunave[i] =\n\t\t\t\t\trmscoef * runave[i - 1] +\n\t\t\t\t\t(1 - rmscoef) *\n\t\t\t\t\t\tpowf(samples[chan][i], 2.0f);\n\t\t\t\tenv_in[i] = sqrtf(runave[i]);\n\t\t\t}\n\t\t} else if (cd->detector == PEAK_DETECT) {\n\t\t\tfor (uint32_t i = 0; i < num_samples; ++i) {\n\t\t\t\trunave[i] = powf(samples[chan][i], 2);\n\t\t\t\tenv_in[i] = fabsf(samples[chan][i]);\n\t\t\t}\n\t\t}\n\n\t\tcd->runave[chan] = runave[num_samples - 1];\n\t\tfor (uint32_t i = 0; i < num_samples; ++i)\n\t\t\tenvelope_buf[i] = fmaxf(envelope_buf[i], env_in[i]);\n\t\tcd->envelope[chan] = cd->envelope_buf[chan][num_samples - 1];\n\t}\n}", "path": "obs-studio/plugins/obs-filters/expander-filter.c", "commit_date": "2019-07-18 00:00:00", "repo_name": "obsproject/obs-studio", "stars": 54512, "license": "gpl-2.0", "language": "c", "size": 68469}
{"docstring": "/**\n * Initialize the pulse audio context with properties and callback\n */\n", "func_signal": "static void pulseaudio_init_context()", "code": "{\n\tpulseaudio_lock();\n\n\tpa_proplist *p = pulseaudio_properties();\n\tpulseaudio_context = pa_context_new_with_proplist(\n\t\tpa_threaded_mainloop_get_api(pulseaudio_mainloop),\n\t\t\"OBS-Monitor\", p);\n\n\tpa_context_set_state_callback(pulseaudio_context,\n\t\t\t\t      pulseaudio_context_state_changed, NULL);\n\n\tpa_context_connect(pulseaudio_context, NULL, PA_CONTEXT_NOAUTOSPAWN,\n\t\t\t   NULL);\n\tpa_proplist_free(p);\n\n\tpulseaudio_unlock();\n}", "path": "obs-studio/libobs/audio-monitoring/pulse/pulseaudio-wrapper.c", "commit_date": "2020-01-18 00:00:00", "repo_name": "obsproject/obs-studio", "stars": 54512, "license": "gpl-2.0", "language": "c", "size": 68469}
{"docstring": "/*\n * Create the cursor texture, either by updating if the new cursor has the same\n * size or by creating a new texture if the size is different\n */\n", "func_signal": "static void xcb_xcursor_create(xcb_xcursor_t *data,\n\t\t\t       xcb_xfixes_get_cursor_image_reply_t *xc)", "code": "{\n\tuint32_t *pixels = xcb_xfixes_get_cursor_image_cursor_image(xc);\n\tif (!pixels)\n\t\treturn;\n\n\tif (data->tex && data->last_height == xc->width &&\n\t    data->last_width == xc->height) {\n\t\tgs_texture_set_image(data->tex, (const uint8_t *)pixels,\n\t\t\t\t     xc->width * sizeof(uint32_t), false);\n\t} else {\n\t\tif (data->tex)\n\t\t\tgs_texture_destroy(data->tex);\n\n\t\tdata->tex = gs_texture_create(xc->width, xc->height, GS_BGRA, 1,\n\t\t\t\t\t      (const uint8_t **)&pixels,\n\t\t\t\t\t      GS_DYNAMIC);\n\t}\n\n\tdata->last_serial = xc->cursor_serial;\n\tdata->last_width = xc->width;\n\tdata->last_height = xc->height;\n}", "path": "obs-studio/plugins/linux-capture/xcursor-xcb.c", "commit_date": "2019-06-24 00:00:00", "repo_name": "obsproject/obs-studio", "stars": 54512, "license": "gpl-2.0", "language": "c", "size": 68469}
{"docstring": "/**\n * Returns the name of the plugin\n */\n", "func_signal": "static const char *jack_input_getname(void *unused)", "code": "{\n\tUNUSED_PARAMETER(unused);\n\treturn obs_module_text(\"JACKInput\");\n}", "path": "obs-studio/plugins/linux-jack/jack-input.c", "commit_date": "2019-11-25 00:00:00", "repo_name": "obsproject/obs-studio", "stars": 54512, "license": "gpl-2.0", "language": "c", "size": 68469}
{"docstring": "/**\n * Get plugin defaults\n */\n", "func_signal": "static void jack_input_defaults(obs_data_t *settings)", "code": "{\n\tobs_data_set_default_int(settings, \"channels\", 2);\n\tobs_data_set_default_bool(settings, \"startjack\", false);\n}", "path": "obs-studio/plugins/linux-jack/jack-input.c", "commit_date": "2019-11-25 00:00:00", "repo_name": "obsproject/obs-studio", "stars": 54512, "license": "gpl-2.0", "language": "c", "size": 68469}
{"docstring": "/* init xors IV with input parameter block */\n", "func_signal": "int blake2b_init_param( blake2b_state *S, const blake2b_param *P )", "code": "{\n  const uint8_t *p = ( const uint8_t * )( P );\n  size_t i;\n\n  blake2b_init0( S );\n\n  /* IV XOR ParamBlock */\n  for( i = 0; i < 8; ++i )\n    S->h[i] ^= load64( p + sizeof( S->h[i] ) * i );\n\n  S->outlen = P->digest_length;\n  return 0;\n}", "path": "obs-studio/deps/blake2/src/blake2b-ref.c", "commit_date": "2017-02-24 00:00:00", "repo_name": "obsproject/obs-studio", "stars": 54512, "license": "gpl-2.0", "language": "c", "size": 68469}
{"docstring": "/**\n * Get plugin properties\n */\n", "func_signal": "static obs_properties_t *jack_input_properties(void *unused)", "code": "{\n\t(void)unused;\n\n\tobs_properties_t *props = obs_properties_create();\n\n\tobs_properties_add_int(props, \"channels\", obs_module_text(\"Channels\"),\n\t\t\t       1, 8, 1);\n\tobs_properties_add_bool(props, \"startjack\",\n\t\t\t\tobs_module_text(\"StartJACKServer\"));\n\n\treturn props;\n}", "path": "obs-studio/plugins/linux-jack/jack-input.c", "commit_date": "2019-11-25 00:00:00", "repo_name": "obsproject/obs-studio", "stars": 54512, "license": "gpl-2.0", "language": "c", "size": 68469}
{"docstring": "/* should return $HOME/.[name], or when using XDG,\n * should return $HOME/.config/[name] as default */\n", "func_signal": "int os_get_config_path(char *dst, size_t size, const char *name)", "code": "{\n#ifdef USE_XDG\n\tchar *xdg_ptr = getenv(\"XDG_CONFIG_HOME\");\n\n\t// If XDG_CONFIG_HOME is unset,\n\t// we use the default $HOME/.config/[name] instead\n\tif (xdg_ptr == NULL) {\n\t\tchar *home_ptr = getenv(\"HOME\");\n\t\tif (home_ptr == NULL)\n\t\t\tbcrash(\"Could not get $HOME\\n\");\n\n\t\tif (!name || !*name) {\n\t\t\treturn snprintf(dst, size, \"%s/.config\", home_ptr);\n\t\t} else {\n\t\t\treturn snprintf(dst, size, \"%s/.config/%s\", home_ptr,\n\t\t\t\t\tname);\n\t\t}\n\t} else {\n\t\tif (!name || !*name)\n\t\t\treturn snprintf(dst, size, \"%s\", xdg_ptr);\n\t\telse\n\t\t\treturn snprintf(dst, size, \"%s/%s\", xdg_ptr, name);\n\t}\n#else\n\tchar *path_ptr = getenv(\"HOME\");\n\tif (path_ptr == NULL)\n\t\tbcrash(\"Could not get $HOME\\n\");\n\n\tif (!name || !*name)\n\t\treturn snprintf(dst, size, \"%s\", path_ptr);\n\telse\n\t\treturn snprintf(dst, size, \"%s/.%s\", path_ptr, name);\n#endif\n}", "path": "obs-studio/libobs/util/platform-nix.c", "commit_date": "2020-11-14 00:00:00", "repo_name": "obsproject/obs-studio", "stars": 54512, "license": "gpl-2.0", "language": "c", "size": 68469}
{"docstring": "/**\n * Destroy the plugin object and free all memory\n */\n", "func_signal": "static void jack_destroy(void *vptr)", "code": "{\n\tstruct jack_data *data = (struct jack_data *)vptr;\n\n\tif (!data)\n\t\treturn;\n\n\tdeactivate_jack(data);\n\n\tif (data->device)\n\t\tbfree(data->device);\n\tpthread_mutex_destroy(&data->jack_mutex);\n\tbfree(data);\n}", "path": "obs-studio/plugins/linux-jack/jack-input.c", "commit_date": "2019-11-25 00:00:00", "repo_name": "obsproject/obs-studio", "stars": 54512, "license": "gpl-2.0", "language": "c", "size": 68469}
{"docstring": "// a bit modified version of https://stackoverflow.com/a/31495527\n", "func_signal": "ssize_t os_openbsd_get_executable_path(char *epath)", "code": "{\n\tint mib[4];\n\tchar **argv;\n\tsize_t len;\n\tconst char *comm;\n\tint ok = 0;\n\n\tmib[0] = CTL_KERN;\n\tmib[1] = KERN_PROC_ARGS;\n\tmib[2] = getpid();\n\tmib[3] = KERN_PROC_ARGV;\n\n\tif (sysctl(mib, 4, NULL, &len, NULL, 0) < 0)\n\t\tabort();\n\n\tif (!(argv = malloc(len)))\n\t\tabort();\n\n\tif (sysctl(mib, 4, argv, &len, NULL, 0) < 0)\n\t\tabort();\n\n\tcomm = argv[0];\n\n\tif (*comm == '/' || *comm == '.') {\n\t\tif (realpath(comm, epath))\n\t\t\tok = 1;\n\t} else {\n\t\tchar *sp;\n\t\tchar *xpath = strdup(getenv(\"PATH\"));\n\t\tchar *path = strtok_r(xpath, \":\", &sp);\n\t\tstruct stat st;\n\n\t\tif (!xpath)\n\t\t\tabort();\n\n\t\twhile (path) {\n\t\t\tsnprintf(epath, PATH_MAX, \"%s/%s\", path, comm);\n\n\t\t\tif (!stat(epath, &st) && (st.st_mode & S_IXUSR)) {\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpath = strtok_r(NULL, \":\", &sp);\n\t\t}\n\n\t\tfree(xpath);\n\t}\n\n\tfree(argv);\n\treturn ok ? (ssize_t)strlen(epath) : -1;\n}", "path": "obs-studio/libobs/util/platform-nix.c", "commit_date": "2020-11-14 00:00:00", "repo_name": "obsproject/obs-studio", "stars": 54512, "license": "gpl-2.0", "language": "c", "size": 68469}
{"docstring": "/*\n * @brief write secure auxiliary regs on behalf of normal mode\n *\n * @param aux_reg address of aux reg\n * @param val, the val to write\n *\n *  Some aux regs require secure privilege, this function implements\n * an secure service to access secure aux regs. Check should be done\n * to decide whether the access is valid.\n */\n", "func_signal": "static int32_t arc_s_aux_write(uint32_t aux_reg, uint32_t val)", "code": "{\n\tif (aux_reg == _ARC_V2_AUX_IRQ_ACT) {\n\t\t/* 0 -> CONFIG_NUM_IRQ_PRIO_LEVELS allocated to secure world\n\t\t * left prio levels allocated to normal world\n\t\t */\n\t\tval &= IRQ_PRIO_MASK;\n\t\tz_arc_v2_aux_reg_write(_ARC_V2_AUX_IRQ_ACT, val |\n\t\t(z_arc_v2_aux_reg_read(_ARC_V2_AUX_IRQ_ACT) &\n\t\t\t(~IRQ_PRIO_MASK)));\n\n\t\treturn  0;\n\t}\n\n\treturn -1;\n}", "path": "zephyr/arch/arc/core/secureshield/secure_sys_services.c", "commit_date": "2020-06-08 00:00:00", "repo_name": "zephyrproject-rtos/zephyr", "stars": 9307, "license": "apache-2.0", "language": "c", "size": 633672}
{"docstring": "/* API Functions */\n", "func_signal": "static int i2c_sifive_configure(const struct device *dev, uint32_t dev_config)", "code": "{\n\tconst struct i2c_sifive_cfg *config = NULL;\n\tuint32_t i2c_speed = 0U;\n\tuint16_t prescale = 0U;\n\n\t/* Check for NULL pointers */\n\tif (dev == NULL) {\n\t\tLOG_ERR(\"Device handle is NULL\");\n\t\treturn -EINVAL;\n\t}\n\tconfig = dev->config;\n\tif (config == NULL) {\n\t\tLOG_ERR(\"Device config is NULL\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Disable the I2C peripheral */\n\tsys_write8(0, I2C_REG(config, REG_CONTROL));\n\n\t/* Configure bus frequency */\n\tswitch (I2C_SPEED_GET(dev_config)) {\n\tcase I2C_SPEED_STANDARD:\n\t\ti2c_speed = 100000U; /* 100 KHz */\n\t\tbreak;\n\tcase I2C_SPEED_FAST:\n\t\ti2c_speed = 400000U; /* 400 KHz */\n\t\tbreak;\n\tcase I2C_SPEED_FAST_PLUS:\n\tcase I2C_SPEED_HIGH:\n\tcase I2C_SPEED_ULTRA:\n\tdefault:\n\t\tLOG_ERR(\"Unsupported I2C speed requested\");\n\t\treturn -ENOTSUP;\n\t}\n\n\t/* Calculate prescale value */\n\tprescale = (config->f_sys / (i2c_speed * 5U)) - 1;\n\n\t/* Configure peripheral with calculated prescale */\n\tsys_write8((uint8_t) (0xFF & prescale), I2C_REG(config, REG_PRESCALE_LOW));\n\tsys_write8((uint8_t) (0xFF & (prescale >> 8)),\n\t\t   I2C_REG(config, REG_PRESCALE_HIGH));\n\n\t/* Support I2C Master mode only */\n\tif (!(dev_config & I2C_MODE_MASTER)) {\n\t\tLOG_ERR(\"I2C only supports operation as master\");\n\t\treturn -ENOTSUP;\n\t}\n\n\t/*\n\t * Driver does not support 10-bit addressing. This can be added\n\t * in the future when needed.\n\t */\n\tif (dev_config & I2C_ADDR_10_BITS) {\n\t\tLOG_ERR(\"I2C driver does not support 10-bit addresses\");\n\t\treturn -ENOTSUP;\n\t}\n\n\t/* Enable the I2C peripheral */\n\tsys_write8(SF_CONTROL_EN, I2C_REG(config, REG_CONTROL));\n\n\treturn 0;\n}", "path": "zephyr/drivers/i2c/i2c_sifive.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "zephyrproject-rtos/zephyr", "stars": 9307, "license": "apache-2.0", "language": "c", "size": 633672}
{"docstring": "/**\n * @brief initialise the fuel gauge\n *\n * @return 0 for success\n * @return -EINVAL if the I2C controller could not be found\n */\n", "func_signal": "static int max17055_gauge_init(const struct device *dev)", "code": "{\n\tstruct max17055_data *priv = dev->data;\n\tconst struct max17055_config *const config = dev->config;\n\n\tpriv->i2c = device_get_binding(config->bus_name);\n\tif (!priv->i2c) {\n\t\tLOG_ERR(\"Could not get pointer to %s device\", config->bus_name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "path": "zephyr/drivers/sensor/max17055/max17055.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "zephyrproject-rtos/zephyr", "stars": 9307, "license": "apache-2.0", "language": "c", "size": 633672}
{"docstring": "/*\n * @brief initializaiton of secureshield related functions.\n */\n", "func_signal": "static int arc_secureshield_init(const struct device *arg)", "code": "{\n\tsjli_table_init();\n\n\t/* set nic bit to enable seti/clri and\n\t * sleep/wevt in normal mode.\n\t * If not set, direct call of seti/clri etc. will raise exception.\n\t * Then, these seti/clri instructions should be replaced with secure\n\t * secure services (sjli call)\n\t *\n\t */\n\t__asm__ volatile(\"sflag  0x20\");\n\n\treturn 0;\n}", "path": "zephyr/arch/arc/core/secureshield/arc_sjli.c", "commit_date": "2020-09-02 00:00:00", "repo_name": "zephyrproject-rtos/zephyr", "stars": 9307, "license": "apache-2.0", "language": "c", "size": 633672}
{"docstring": "/**\n *\n * @brief ISR for IRQ0\n *\n * @return N/A\n */\n", "func_signal": "void isr0(void)", "code": "{\n\tprintk(\"%s ran!\\n\", __func__);\n\tk_sem_give(&sem[0]);\n\tz_arm_int_exit();\n}", "path": "zephyr/tests/arch/arm/arm_irq_vector_table/src/arm_irq_vector_table.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "zephyrproject-rtos/zephyr", "stars": 9307, "license": "apache-2.0", "language": "c", "size": 633672}
{"docstring": "/* dynamic command creation */\n", "func_signal": "static void dynamic_cmd_get(size_t idx, struct shell_static_entry *entry)", "code": "{\n\tif (idx < dynamic_cmd_cnt) {\n\t\t/* m_dynamic_cmd_buffer must be sorted alphabetically to ensure\n\t\t * correct CLI completion\n\t\t */\n\t\tentry->syntax = dynamic_cmd_buffer[idx];\n\t\tentry->handler  = NULL;\n\t\tentry->subcmd = NULL;\n\t\tentry->help = \"Show dynamic command name.\";\n\t} else {\n\t\t/* if there are no more dynamic commands available syntax\n\t\t * must be set to NULL.\n\t\t */\n\t\tentry->syntax = NULL;\n\t}\n}", "path": "zephyr/samples/subsys/shell/shell_module/src/dynamic_cmd.c", "commit_date": "2020-06-08 00:00:00", "repo_name": "zephyrproject-rtos/zephyr", "stars": 9307, "license": "apache-2.0", "language": "c", "size": 633672}
{"docstring": "/* Helper functions */\n", "func_signal": "static inline bool i2c_sifive_busy(const struct device *dev)", "code": "{\n\tconst struct i2c_sifive_cfg *config = dev->config;\n\n\treturn IS_SET(config, REG_STATUS, SF_STATUS_TIP);\n}", "path": "zephyr/drivers/i2c/i2c_sifive.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "zephyrproject-rtos/zephyr", "stars": 9307, "license": "apache-2.0", "language": "c", "size": 633672}
{"docstring": "/* Some architectures don't/can't interpret flags or priority and have\n * no more processing to do than this.  Provide a generic fallback.\n */\n", "func_signal": "int __weak arch_irq_connect_dynamic(unsigned int irq,\n\t\t\t\t    unsigned int priority,\n\t\t\t\t    void (*routine)(const void *),\n\t\t\t\t    const void *parameter,\n\t\t\t\t    uint32_t flags)", "code": "{\n\tARG_UNUSED(flags);\n\tARG_UNUSED(priority);\n\n\tz_isr_install(irq, routine, parameter);\n\treturn irq;\n}", "path": "zephyr/arch/common/sw_isr_common.c", "commit_date": "2020-09-02 00:00:00", "repo_name": "zephyrproject-rtos/zephyr", "stars": 9307, "license": "apache-2.0", "language": "c", "size": 633672}
{"docstring": "/*test case main entry*/\n", "func_signal": "void test_main(void)", "code": "{\n\tztest_test_suite(test_desc,\n\t\t\t ztest_unit_test(test_desc_sections));\n\tztest_run_test_suite(test_desc);\n}", "path": "zephyr/tests/subsys/usb/desc_sections/src/desc_sections.c", "commit_date": "2020-06-08 00:00:00", "repo_name": "zephyrproject-rtos/zephyr", "stars": 9307, "license": "apache-2.0", "language": "c", "size": 633672}
{"docstring": "/* d-cache operation succeeded */\n", "func_signal": "static bool dcache_available(void)", "code": "{\n\tunsigned long val = z_arc_v2_aux_reg_read(_ARC_V2_D_CACHE_BUILD);\n\n\tval &= 0xff; /* extract version */\n\treturn (val == 0) ? false : true;\n}", "path": "zephyr/arch/arc/core/cache.c", "commit_date": "2020-09-02 00:00:00", "repo_name": "zephyrproject-rtos/zephyr", "stars": 9307, "license": "apache-2.0", "language": "c", "size": 633672}
{"docstring": "/*\n * @brief allocate interrupt for normal world\n *\n * @param intno, the interrupt to be allocated to normal world\n *\n * By default, most interrupts are configured to be secure in initialization.\n * If normal world wants to use an interrupt, through this secure service to\n * apply one. Necessary check should be done to decide whether the apply is\n * valid\n */\n", "func_signal": "static int32_t arc_s_irq_alloc(uint32_t intno)", "code": "{\n\tz_arc_v2_irq_uinit_secure_set(intno, 0);\n\treturn 0;\n}", "path": "zephyr/arch/arc/core/secureshield/secure_sys_services.c", "commit_date": "2020-06-08 00:00:00", "repo_name": "zephyrproject-rtos/zephyr", "stars": 9307, "license": "apache-2.0", "language": "c", "size": 633672}
{"docstring": "/**\n *\n * @brief ISR for IRQ2\n *\n * @return N/A\n */\n", "func_signal": "void isr2(void)", "code": "{\n\tprintk(\"%s ran!\\n\", __func__);\n\tk_sem_give(&sem[2]);\n\tz_arm_int_exit();\n}", "path": "zephyr/tests/arch/arm/arm_irq_vector_table/src/arm_irq_vector_table.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "zephyrproject-rtos/zephyr", "stars": 9307, "license": "apache-2.0", "language": "c", "size": 633672}
{"docstring": "/**\n *\n * @brief Mutex lock/unlock test\n *\n * @return N/A\n */\n", "func_signal": "void mutex_test(void)", "code": "{\n\tuint32_t et; /* elapsed time */\n\tint i;\n\n\tPRINT_STRING(dashline, output_file);\n\tet = BENCH_START();\n\tfor (i = 0; i < NR_OF_MUTEX_RUNS; i++) {\n\t\tk_mutex_lock(&DEMO_MUTEX, K_FOREVER);\n\t\tk_mutex_unlock(&DEMO_MUTEX);\n\t}\n\tet = TIME_STAMP_DELTA_GET(et);\n\tcheck_result();\n\n\tPRINT_F(output_file, FORMAT, \"average lock and unlock mutex\",\n\t\tSYS_CLOCK_HW_CYCLES_TO_NS_AVG(et, (2 * NR_OF_MUTEX_RUNS)));\n}", "path": "zephyr/tests/benchmarks/app_kernel/src/mutex_b.c", "commit_date": "2020-06-08 00:00:00", "repo_name": "zephyrproject-rtos/zephyr", "stars": 9307, "license": "apache-2.0", "language": "c", "size": 633672}
{"docstring": "/**\n * @brief Get the number of supported MPU regions\n *\n */\n", "func_signal": "static inline uint8_t get_num_regions(void)", "code": "{\n\tuint32_t num = z_arc_v2_aux_reg_read(_ARC_V2_MPU_BUILD);\n\n\tnum = (num & 0xFF00U) >> 8U;\n\n\treturn (uint8_t)num;\n}", "path": "zephyr/arch/arc/core/mpu/arc_mpu.c", "commit_date": "2020-06-08 00:00:00", "repo_name": "zephyrproject-rtos/zephyr", "stars": 9307, "license": "apache-2.0", "language": "c", "size": 633672}
{"docstring": "/**\n * This internal function is utilized by the MPU driver to parse the intent\n * type (i.e. THREAD_STACK_REGION) and return the correct parameter set.\n */\n", "func_signal": "static inline uint32_t get_region_attr_by_type(uint32_t type)", "code": "{\n\tswitch (type) {\n\tcase THREAD_STACK_USER_REGION:\n\t\treturn REGION_RAM_ATTR;\n\tcase THREAD_STACK_REGION:\n\t\treturn AUX_MPU_ATTR_KW | AUX_MPU_ATTR_KR;\n\tcase THREAD_APP_DATA_REGION:\n\t\treturn REGION_RAM_ATTR;\n\tcase THREAD_STACK_GUARD_REGION:\n\t\t/* no Write and Execute to guard region */\n\t\treturn AUX_MPU_ATTR_UR | AUX_MPU_ATTR_KR;\n\tdefault:\n\t\t/* unknown type */\n\t\treturn 0;\n\t}\n}", "path": "zephyr/arch/arc/core/mpu/arc_mpu.c", "commit_date": "2020-06-08 00:00:00", "repo_name": "zephyrproject-rtos/zephyr", "stars": 9307, "license": "apache-2.0", "language": "c", "size": 633672}
{"docstring": "/**\n * @brief Read a register value\n *\n * Registers have an address and a 16-bit value\n *\n * @param priv Private data for the driver\n * @param reg_addr Register address to read\n * @param val Place to put the value on success\n * @return 0 if successful, or negative error code from I2C API\n */\n", "func_signal": "static int max17055_reg_read(struct max17055_data *priv, int reg_addr,\n\t\t\t     int16_t *valp)", "code": "{\n\tuint8_t i2c_data[2];\n\tint rc;\n\n\trc = i2c_burst_read(priv->i2c, DT_INST_REG_ADDR(0), reg_addr,\n\t\t\t    i2c_data, 2);\n\tif (rc < 0) {\n\t\tLOG_ERR(\"Unable to read register\");\n\t\treturn rc;\n\t}\n\t*valp = (i2c_data[1] << 8) | i2c_data[0];\n\n\treturn 0;\n}", "path": "zephyr/drivers/sensor/max17055/max17055.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "zephyrproject-rtos/zephyr", "stars": 9307, "license": "apache-2.0", "language": "c", "size": 633672}
{"docstring": "/**\n * @brief Convert capacity in MAX17055 units to milliamps\n *\n * @param rsense_mohms Value of Rsense in milliohms\n * @param val Value to convert (taken from a MAX17055 register)\n * @return corresponding value in milliamps\n */\n", "func_signal": "static int capacity_to_ma(unsigned int rsense_mohms, int16_t val)", "code": "{\n\tint lsb_units, rem;\n\n\t/* Get units for the LSB in uA */\n\tlsb_units = 5 * 1000 / rsense_mohms;\n\t/* Get remaining capacity in uA */\n\trem = val * lsb_units;\n\n\treturn rem;\n}", "path": "zephyr/drivers/sensor/max17055/max17055.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "zephyrproject-rtos/zephyr", "stars": 9307, "license": "apache-2.0", "language": "c", "size": 633672}
{"docstring": "/* CONFIG_MULTI_LEVEL_INTERRUPTS */\n", "func_signal": "void z_isr_install(unsigned int irq, void (*routine)(const void *),\n\t\t   const void *param)", "code": "{\n\tunsigned int table_idx;\n\n\t/*\n\t * Do not assert on the IRQ enable status for ARM GIC since the SGI\n\t * type interrupts are always enabled and attempting to install an ISR\n\t * for them will cause the assertion to fail.\n\t */\n#ifndef CONFIG_GIC\n\t__ASSERT(!irq_is_enabled(irq), \"IRQ %d is enabled\", irq);\n#endif /* !CONFIG_GIC */\n\n#ifdef CONFIG_MULTI_LEVEL_INTERRUPTS\n\tunsigned int level;\n\tunsigned int parent_irq;\n\tunsigned int parent_offset;\n\n\tlevel = irq_get_level(irq);\n\n\tif (level == 2) {\n\t\tparent_irq = irq_parent_level_2(irq);\n\t\tparent_offset = get_parent_offset(parent_irq,\n\t\t\tlvl2_irq_list,\n\t\t\tCONFIG_NUM_2ND_LEVEL_AGGREGATORS);\n\t\ttable_idx = parent_offset + irq_from_level_2(irq);\n\t}\n#ifdef CONFIG_3RD_LEVEL_INTERRUPTS\n\telse if (level == 3) {\n\t\tparent_irq = irq_parent_level_3(irq);\n\t\tparent_offset = get_parent_offset(parent_irq,\n\t\t\tlvl3_irq_list,\n\t\t\tCONFIG_NUM_3RD_LEVEL_AGGREGATORS);\n\t\ttable_idx = parent_offset + irq_from_level_3(irq);\n\t}\n#endif /* CONFIG_3RD_LEVEL_INTERRUPTS */\n\telse {\n\t\ttable_idx = irq;\n\t}\n\n\ttable_idx -= CONFIG_GEN_IRQ_START_VECTOR;\n#else\n\ttable_idx = irq - CONFIG_GEN_IRQ_START_VECTOR;\n#endif /* CONFIG_MULTI_LEVEL_INTERRUPTS */\n\n\t/* If dynamic IRQs are enabled, then the _sw_isr_table is in RAM and\n\t * can be modified\n\t */\n\t_sw_isr_table[table_idx].arg = param;\n\t_sw_isr_table[table_idx].isr = routine;\n}", "path": "zephyr/arch/common/sw_isr_common.c", "commit_date": "2020-09-02 00:00:00", "repo_name": "zephyrproject-rtos/zephyr", "stars": 9307, "license": "apache-2.0", "language": "c", "size": 633672}
{"docstring": "/*\n * offset and len must be aligned on 8 for write,\n * positive and not beyond end of flash\n */\n", "func_signal": "bool flash_stm32_valid_range(const struct device *dev, off_t offset,\n\t\t\t     uint32_t len,\n\t\t\t     bool write)", "code": "{\n\treturn (!write || (offset % 8 == 0 && len % 8 == 0)) &&\n\t\tflash_stm32_range_exists(dev, offset, len);\n}", "path": "zephyr/drivers/flash/flash_stm32g0x.c", "commit_date": "2020-09-02 00:00:00", "repo_name": "zephyrproject-rtos/zephyr", "stars": 9307, "license": "apache-2.0", "language": "c", "size": 633672}
{"docstring": "/**\n * @brief sensor value get\n *\n * @param dev MAX17055 device to access\n * @param chan Channel number to read\n * @param valp Returns the sensor value read on success\n * @return 0 if successful\n * @return -ENOTSUP for unsupported channels\n */\n", "func_signal": "static int max17055_channel_get(const struct device *dev,\n\t\t\t\tenum sensor_channel chan,\n\t\t\t\tstruct sensor_value *valp)", "code": "{\n\tconst struct max17055_config *const config = dev->config;\n\tstruct max17055_data *const priv = dev->data;\n\tunsigned int tmp;\n\n\tswitch (chan) {\n\tcase SENSOR_CHAN_GAUGE_VOLTAGE:\n\t\t/* Get voltage in uV */\n\t\ttmp = priv->voltage * 1250 / 16;\n\t\tvalp->val1 = tmp / 1000000;\n\t\tvalp->val2 = tmp % 1000000;\n\t\tbreak;\n\tcase SENSOR_CHAN_GAUGE_AVG_CURRENT: {\n\t\tint cap_ma;\n\n\t\tcap_ma = capacity_to_ma(config->rsense_mohms,\n\t\t\t\t\tpriv->avg_current);\n\t\tset_millis(valp, cap_ma);\n\t\tbreak;\n\t}\n\tcase SENSOR_CHAN_GAUGE_STATE_OF_CHARGE:\n\t\tvalp->val1 = priv->state_of_charge / 256;\n\t\tvalp->val2 = priv->state_of_charge % 256 * 1000000 / 256;\n\t\tbreak;\n\tcase SENSOR_CHAN_GAUGE_TEMP:\n\t\tvalp->val1 = priv->internal_temp / 256;\n\t\tvalp->val2 = priv->internal_temp % 256 * 1000000 / 256;\n\t\tbreak;\n\tcase SENSOR_CHAN_GAUGE_FULL_CHARGE_CAPACITY:\n\t\ttmp = capacity_to_ma(config->rsense_mohms, priv->full_cap);\n\t\tset_millis(valp, tmp);\n\t\tbreak;\n\tcase SENSOR_CHAN_GAUGE_REMAINING_CHARGE_CAPACITY:\n\t\ttmp = capacity_to_ma(config->rsense_mohms, priv->remaining_cap);\n\t\tset_millis(valp, tmp);\n\t\tbreak;\n\tcase SENSOR_CHAN_GAUGE_TIME_TO_EMPTY:\n\t\t/* Get time in ms */\n\t\tif (priv->time_to_empty == 0xffff) {\n\t\t\tvalp->val1 = 0;\n\t\t\tvalp->val2 = 0;\n\t\t} else {\n\t\t\ttmp = priv->time_to_empty * 5625;\n\t\t\tset_millis(valp, tmp);\n\t\t}\n\t\tbreak;\n\tcase SENSOR_CHAN_GAUGE_TIME_TO_FULL:\n\t\tif (priv->time_to_full == 0xffff) {\n\t\t\tvalp->val1 = 0;\n\t\t\tvalp->val2 = 0;\n\t\t} else {\n\t\t\t/* Get time in ms */\n\t\t\ttmp = priv->time_to_full * 5625;\n\t\t\tset_millis(valp, tmp);\n\t\t}\n\t\tbreak;\n\tcase SENSOR_CHAN_GAUGE_CYCLE_COUNT:\n\t\tvalp->val1 = priv->cycle_count / 100;\n\t\tvalp->val2 = priv->cycle_count % 100 * 10000;\n\t\tbreak;\n\tcase SENSOR_CHAN_GAUGE_NOM_AVAIL_CAPACITY:\n\t\ttmp = capacity_to_ma(config->rsense_mohms, priv->design_cap);\n\t\tset_millis(valp, tmp);\n\t\tbreak;\n\tcase SENSOR_CHAN_GAUGE_DESIGN_VOLTAGE:\n\t\tset_millis(valp, config->design_voltage);\n\t\tbreak;\n\tcase SENSOR_CHAN_GAUGE_DESIRED_VOLTAGE:\n\t\tset_millis(valp, config->desired_voltage);\n\t\tbreak;\n\tcase SENSOR_CHAN_GAUGE_DESIRED_CHARGING_CURRENT:\n\t\tvalp->val1 = config->desired_charging_current;\n\t\tvalp->val2 = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn 0;\n}", "path": "zephyr/drivers/sensor/max17055/max17055.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "zephyrproject-rtos/zephyr", "stars": 9307, "license": "apache-2.0", "language": "c", "size": 633672}
{"docstring": "/* Set v1+ disk interface callback functions */\n", "func_signal": "void disk_control_set_ext_callback(\n      disk_control_interface_t *disk_control,\n      const struct retro_disk_control_ext_callback *cb)", "code": "{\n   if (!disk_control)\n      return;\n\n   disk_control_reset_callback(disk_control);\n\n   if (!cb)\n      return;\n\n   disk_control->cb.set_eject_state     = cb->set_eject_state;\n   disk_control->cb.get_eject_state     = cb->get_eject_state;\n   disk_control->cb.get_image_index     = cb->get_image_index;\n   disk_control->cb.set_image_index     = cb->set_image_index;\n   disk_control->cb.get_num_images      = cb->get_num_images;\n   disk_control->cb.replace_image_index = cb->replace_image_index;\n   disk_control->cb.add_image_index     = cb->add_image_index;\n\n   disk_control->cb.set_initial_image   = cb->set_initial_image;\n   disk_control->cb.get_image_path      = cb->get_image_path;\n   disk_control->cb.get_image_label     = cb->get_image_label;\n}", "path": "RetroArch/disk_control_interface.c", "commit_date": "2020-07-17 00:00:00", "repo_name": "libretro/RetroArch", "stars": 9033, "license": "gpl-3.0", "language": "c", "size": 475180}
{"docstring": "/* Returns number of entries in core backup list */\n", "func_signal": "size_t core_backup_list_size(core_backup_list_t *backup_list)", "code": "{\n   if (!backup_list)\n      return 0;\n\n   return backup_list->size;\n}", "path": "RetroArch/core_backup.c", "commit_date": "2020-08-31 00:00:00", "repo_name": "libretro/RetroArch", "stars": 9033, "license": "gpl-3.0", "language": "c", "size": 475180}
{"docstring": "/* Creates a new core backup list containing entries\n * for all existing backup files.\n * Returns a handle to a new core_backup_list_t object\n * on success, otherwise returns NULL. */\n", "func_signal": "core_backup_list_t *core_backup_list_init(\n      const char *core_path, const char *dir_core_assets)", "code": "{\n   size_t i;\n   const char *core_filename         = NULL;\n   struct string_list *dir_list      = NULL;\n   core_backup_list_t *backup_list   = NULL;\n   core_backup_list_entry_t *entries = NULL;\n   char core_dir[PATH_MAX_LENGTH];\n   char backup_dir[PATH_MAX_LENGTH];\n\n   core_dir[0]   = '\\0'; \n   backup_dir[0] = '\\0';\n\n   /* Get core filename and parent directory */\n   if (string_is_empty(core_path))\n      goto error;\n\n   core_filename = path_basename(core_path);\n\n   if (string_is_empty(core_filename))\n      goto error;\n\n   fill_pathname_parent_dir(core_dir, core_path, sizeof(core_dir));\n\n   if (string_is_empty(core_dir))\n      goto error;\n\n   /* Get backup directory */\n   if (!core_backup_get_backup_dir(core_dir, dir_core_assets, core_filename,\n         backup_dir, sizeof(backup_dir)))\n      goto error;\n\n   /* Get backup file list */\n   dir_list = dir_list_new(\n         backup_dir,\n         FILE_PATH_CORE_BACKUP_EXTENSION,\n         false, /* include_dirs */\n         false, /* include_hidden */\n         false, /* include_compressed */\n         false  /* recursive */\n   );\n\n   /* Sanity check */\n   if (!dir_list)\n      goto error;\n\n   if (dir_list->size < 1)\n      goto error;\n\n   /* Ensure list is sorted in alphabetical order\n    * > This corresponds to 'timestamp' order */\n   dir_list_sort(dir_list, true);\n\n   /* Create core backup list */\n   backup_list = (core_backup_list_t*)malloc(sizeof(*backup_list));\n\n   if (!backup_list)\n      goto error;\n\n   backup_list->entries  = NULL;\n   backup_list->capacity = 0;\n   backup_list->size     = 0;\n\n   /* Create entries array\n    * (Note: Set this to the full size of the directory\n    * list - this may be larger than we need, but saves\n    * many inefficiencies later)   */\n   entries               = (core_backup_list_entry_t*)\n      calloc(dir_list->size, sizeof(*entries));\n\n   if (!entries)\n      goto error;\n\n   backup_list->entries  = entries;\n   backup_list->capacity = dir_list->size;\n\n   /* Loop over backup files and parse file names */\n   for (i = 0; i < dir_list->size; i++)\n   {\n      const char *backup_path = dir_list->elems[i].data;\n      core_backup_add_entry(backup_list, core_filename, backup_path);\n   }\n\n   if (backup_list->size == 0)\n      goto error;\n\n   string_list_free(dir_list);\n\n   return backup_list;\n\nerror:\n   if (dir_list)\n      string_list_free(dir_list);\n\n   if (backup_list)\n      core_backup_list_free(backup_list);\n\n   return NULL;\n}", "path": "RetroArch/core_backup.c", "commit_date": "2020-08-31 00:00:00", "repo_name": "libretro/RetroArch", "stars": 9033, "license": "gpl-3.0", "language": "c", "size": 475180}
{"docstring": "/* Returns true if core supports disk append\n * functionality\n * - replace_image_index\n * - add_image_index */\n", "func_signal": "bool disk_control_append_enabled(\n      disk_control_interface_t *disk_control)", "code": "{\n   if (!disk_control)\n      return false;\n\n   if (disk_control->cb.replace_image_index &&\n       disk_control->cb.add_image_index)\n      return true;\n\n   return false;\n}", "path": "RetroArch/disk_control_interface.c", "commit_date": "2020-07-17 00:00:00", "repo_name": "libretro/RetroArch", "stars": 9033, "license": "gpl-3.0", "language": "c", "size": 475180}
{"docstring": "/* Returns currently selected disk image index */\n", "func_signal": "unsigned disk_control_get_image_index(\n      disk_control_interface_t *disk_control)", "code": "{\n   if (!disk_control || !disk_control->cb.get_image_index)\n      return 0;\n   return disk_control->cb.get_image_index();\n}", "path": "RetroArch/disk_control_interface.c", "commit_date": "2020-07-17 00:00:00", "repo_name": "libretro/RetroArch", "stars": 9033, "license": "gpl-3.0", "language": "c", "size": 475180}
{"docstring": "/* Fetches core path associated with specified core\n * backup file. Returns detected type of backup\n * file - CORE_BACKUP_TYPE_INVALID indicates that\n * backup file cannot be restored/installed, or\n * arguments are otherwise invalid */\n", "func_signal": "enum core_backup_type core_backup_get_core_path(\n      const char *backup_path, const char *dir_libretro,\n      char *core_path, size_t len)", "code": "{\n   const char *backup_filename       = NULL;\n   char *core_filename               = NULL;\n   enum core_backup_type backup_type = CORE_BACKUP_TYPE_INVALID;\n\n   if (string_is_empty(backup_path) || string_is_empty(dir_libretro))\n      return backup_type;\n\n   backup_filename = path_basename(backup_path);\n\n   if (string_is_empty(backup_filename))\n      return backup_type;\n\n   /* Check backup type */\n   switch (core_backup_get_backup_type(backup_path))\n   {\n      case CORE_BACKUP_TYPE_ARCHIVE:\n         {\n            char *period  = NULL;\n\n            /* This is an archived backup with timestamp/crc\n             * metadata in the filename */\n            core_filename = strdup(backup_filename);\n\n            /* Find the location of the second period */\n            period = strchr(core_filename, '.');\n            if (!period || (*(++period) == '\\0'))\n               break;\n\n            period = strchr(period, '.');\n            if (!period)\n               break;\n\n            /* Trim everything after (and including) the\n             * second period */\n            *period = '\\0';\n\n            if (string_is_empty(core_filename))\n               break;\n\n            /* All good - build core path */\n            fill_pathname_join(core_path, dir_libretro,\n                  core_filename, len);\n\n            backup_type = CORE_BACKUP_TYPE_ARCHIVE;\n         }\n         break;\n      case CORE_BACKUP_TYPE_LIB:\n         /* This is a plain dynamic library file */\n         fill_pathname_join(core_path, dir_libretro,\n               backup_filename, len);\n         backup_type = CORE_BACKUP_TYPE_LIB;\n         break;\n      default:\n         /* Backup is invalid */\n         break;\n   }\n\n   if (core_filename)\n   {\n      free(core_filename);\n      core_filename = NULL;\n   }\n\n   return backup_type;\n}", "path": "RetroArch/core_backup.c", "commit_date": "2020-08-31 00:00:00", "repo_name": "libretro/RetroArch", "stars": 9033, "license": "gpl-3.0", "language": "c", "size": 475180}
{"docstring": "/* Fetches core-provided disk image label\n * (label is set to an empty string if core\n * does not support image labels) */\n", "func_signal": "void disk_control_get_image_label(\n      disk_control_interface_t *disk_control,\n      unsigned index, char *label, size_t len)", "code": "{\n   if (!label || len < 1)\n      return;\n\n   if (!disk_control)\n      goto error;\n\n   if (!disk_control->cb.get_image_label)\n      goto error;\n\n   if (!disk_control->cb.get_image_label(index, label, len))\n      goto error;\n\n   return;\n\nerror:\n   label[0] = '\\0';\n}", "path": "RetroArch/disk_control_interface.c", "commit_date": "2020-07-17 00:00:00", "repo_name": "libretro/RetroArch", "stars": 9033, "license": "gpl-3.0", "language": "c", "size": 475180}
{"docstring": "/* Checks that initial index has been set correctly\n * and provides user notification.\n * > Sets disk_control->initial_num_images if\n *   if functionality is supported by core\n * NOTE: Must be called immediately after\n * loading content */\n", "func_signal": "bool disk_control_verify_initial_index(\n      disk_control_interface_t *disk_control,\n      bool verbosity)", "code": "{\n   bool success         = false;\n   unsigned image_index = 0;\n   char image_path[PATH_MAX_LENGTH];\n\n   image_path[0] = '\\0';\n\n   if (!disk_control)\n      return false;\n\n   /* If index record is disabled, can return immediately */\n   if (!disk_control->record_enabled)\n      return false;\n\n   /* Check that 'initial index' functionality is enabled */\n   if (!disk_control->cb.set_initial_image ||\n       !disk_control->cb.get_num_images ||\n       !disk_control->cb.get_image_index ||\n       !disk_control->cb.get_image_path)\n      return false;\n\n   /* Cache initial number of images\n    * (required for error checking when saving\n    * disk index file) */\n   disk_control->initial_num_images =\n         disk_control->cb.get_num_images();\n\n   /* Get current image index + path */\n   image_index = disk_control->cb.get_image_index();\n\n   if (disk_control->cb.get_image_path(\n         image_index, image_path, sizeof(image_path)))\n   {\n      /* Check whether index + path match set\n       * values\n       * > Note that if set index was zero and\n       *   set path was empty, we ignore the path\n       *   read here (since this corresponds to a\n       *   'first run', where no existing disk index\n       *   file was present) */\n      if ((image_index == disk_control->index_record.image_index) &&\n          (string_is_equal(image_path, disk_control->index_record.image_path) ||\n               ((disk_control->index_record.image_index == 0) &&\n                string_is_empty(disk_control->index_record.image_path))))\n         success = true;\n   }\n\n   /* If current disk is incorrect, notify user */\n   if (!success)\n   {\n      RARCH_ERR(\n               \"Failed to set initial disk index:\\n> Expected [%u] %s\\n> Detected [%u] %s\\n\",\n               disk_control->index_record.image_index + 1,\n               disk_control->index_record.image_path,\n               image_index + 1,\n               image_path);\n\n      /* Ignore 'verbosity' setting - errors should\n       * always be displayed */\n      runloop_msg_queue_push(\n            msg_hash_to_str(MSG_FAILED_TO_SET_INITIAL_DISK),\n            0, 60,\n            true, NULL,\n            MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n\n      /* Since a failure here typically means that the\n       * original M3U content file has been altered,\n       * any existing disk index record file will be\n       * invalid. We therefore 'reset' and save the disk\n       * index record to prevent a repeat of the error on\n       * the next run */\n      disk_index_file_set(&disk_control->index_record, 0, NULL);\n      disk_index_file_save(&disk_control->index_record);\n   }\n   /* If current disk is correct and recorded image\n    * path is empty (i.e. first run), need to register\n    * current image path */\n   else if (string_is_empty(disk_control->index_record.image_path))\n      disk_index_file_set(\n            &disk_control->index_record, image_index, image_path);\n\n   /* Regardless of success/failure, notify user of\n    * current disk index *if* more than one disk\n    * is available */\n   if (disk_control->initial_num_images > 1)\n   {\n      unsigned msg_duration = 0;\n      char msg[PATH_MAX_LENGTH];\n\n      msg[0] = '\\0';\n\n      disk_control_get_index_set_msg(\n            disk_control, disk_control->initial_num_images, image_index, true,\n            &msg_duration, msg, sizeof(msg));\n\n      RARCH_LOG(\"%s\\n\", msg);\n\n      /* Note: Do not flush message queue here, since\n       * it is likely other notifications will be\n       * generated before setting the disk index, and\n       * we do not want to 'overwrite' them */\n      if (verbosity)\n         runloop_msg_queue_push(\n               msg,\n               0, msg_duration,\n               false, NULL,\n               MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n   }\n\n   return success;\n}", "path": "RetroArch/disk_control_interface.c", "commit_date": "2020-07-17 00:00:00", "repo_name": "libretro/RetroArch", "stars": 9033, "license": "gpl-3.0", "language": "c", "size": 475180}
{"docstring": "/* Returns true if core supports setting\n * initial disk index\n * - set_initial_image\n * - get_image_path */\n", "func_signal": "bool disk_control_initial_image_enabled(\n      disk_control_interface_t *disk_control)", "code": "{\n   if (!disk_control)\n      return false;\n\n   if (disk_control->cb.set_initial_image &&\n       disk_control->cb.get_image_path)\n      return true;\n\n   return false;\n}", "path": "RetroArch/disk_control_interface.c", "commit_date": "2020-07-17 00:00:00", "repo_name": "libretro/RetroArch", "stars": 9033, "license": "gpl-3.0", "language": "c", "size": 475180}
{"docstring": "/* Sets all disk interface callback functions\n * to NULL */\n", "func_signal": "static void disk_control_reset_callback(\n      disk_control_interface_t *disk_control)", "code": "{\n   if (!disk_control)\n      return;\n\n   memset(&disk_control->cb, 0,\n         sizeof(struct retro_disk_control_ext_callback));\n}", "path": "RetroArch/disk_control_interface.c", "commit_date": "2020-07-17 00:00:00", "repo_name": "libretro/RetroArch", "stars": 9033, "license": "gpl-3.0", "language": "c", "size": 475180}
{"docstring": "/* Fetches a string representation of a backup\n * list entry crc value.\n * Returns false in the event of an error */\n", "func_signal": "bool core_backup_list_get_entry_crc_str(\n      const core_backup_list_entry_t *entry,\n      char *crc, size_t len)", "code": "{\n   int n;\n\n   if (!entry || (len < 9))\n      return false;\n\n   n = snprintf(crc, len, \"%08x\", entry->crc);\n\n   if ((n < 0) || (n >= 32))\n      n = 0; /* Silence GCC warnings... */\n\n   return true;\n}", "path": "RetroArch/core_backup.c", "commit_date": "2020-08-31 00:00:00", "repo_name": "libretro/RetroArch", "stars": 9033, "license": "gpl-3.0", "language": "c", "size": 475180}
{"docstring": "/* Saves current disk index to file, if supported\n * by current core */\n", "func_signal": "bool disk_control_save_image_index(\n      disk_control_interface_t *disk_control)", "code": "{\n   if (!disk_control)\n      return false;\n\n   /* If index record is disabled, can return immediately */\n   if (!disk_control->record_enabled)\n      return false;\n\n   /* If core started with less than two disks,\n    * then a disk index record is unnecessary */\n   if (disk_control->initial_num_images < 2)\n      return false;\n\n   /* If current index is greater than initial\n    * number of disks then user has appended a\n    * disk and it is currently active. This setup\n    * *cannot* be restored, so cancel the file save */\n   if (disk_control->index_record.image_index >=\n         disk_control->initial_num_images)\n      return false;\n\n   /* Save record */\n   return disk_index_file_save(&disk_control->index_record);\n}", "path": "RetroArch/disk_control_interface.c", "commit_date": "2020-07-17 00:00:00", "repo_name": "libretro/RetroArch", "stars": 9033, "license": "gpl-3.0", "language": "c", "size": 475180}
{"docstring": "/* Returns true if disk is currently ejected */\n", "func_signal": "bool disk_control_get_eject_state(\n      disk_control_interface_t *disk_control)", "code": "{\n   if (!disk_control || !disk_control->cb.get_eject_state)\n      return false;\n   return disk_control->cb.get_eject_state();\n}", "path": "RetroArch/disk_control_interface.c", "commit_date": "2020-07-17 00:00:00", "repo_name": "libretro/RetroArch", "stars": 9033, "license": "gpl-3.0", "language": "c", "size": 475180}
{"docstring": "/* Fetches a string representation of a backup\n * list entry timestamp.\n * Returns false in the event of an error */\n", "func_signal": "bool core_backup_list_get_entry_timestamp_str(\n      const core_backup_list_entry_t *entry,\n      enum core_backup_date_separator_type date_separator,\n      char *timestamp, size_t len)", "code": "{\n   int n;\n   const char *format_str = \"\";\n\n   if (!entry || (len < 20))\n      return false;\n\n   /* Get time format string */\n   switch (date_separator)\n   {\n      case CORE_BACKUP_DATE_SEPARATOR_SLASH:\n         format_str = \"%04u/%02u/%02u %02u:%02u:%02u\";\n         break;\n      case CORE_BACKUP_DATE_SEPARATOR_PERIOD:\n         format_str = \"%04u.%02u.%02u %02u:%02u:%02u\";\n         break;\n      default:\n         format_str = \"%04u-%02u-%02u %02u:%02u:%02u\";\n         break;\n   }\n\n   n = snprintf(timestamp, len,\n         format_str,\n         entry->date.year,\n         entry->date.month,\n         entry->date.day,\n         entry->date.hour,\n         entry->date.minute,\n         entry->date.second);\n\n   if ((n < 0) || (n >= 32))\n      n = 0; /* Silence GCC warnings... */\n\n   return true;\n}", "path": "RetroArch/core_backup.c", "commit_date": "2020-08-31 00:00:00", "repo_name": "libretro/RetroArch", "stars": 9033, "license": "gpl-3.0", "language": "c", "size": 475180}
{"docstring": "/* Parses backup file name and adds to backup list, if valid */\n", "func_signal": "static bool core_backup_add_entry(core_backup_list_t *backup_list,\n      const char *core_filename, const char *backup_path)", "code": "{\n   char *backup_filename           = NULL;\n   core_backup_list_entry_t *entry = NULL;\n   unsigned backup_mode            = 0;\n\n   if (!backup_list ||\n       string_is_empty(core_filename) ||\n       string_is_empty(backup_path) ||\n       (backup_list->size >= backup_list->capacity))\n      goto error;\n\n   backup_filename = strdup(path_basename(backup_path));\n\n   if (string_is_empty(backup_filename))\n      goto error;\n\n   /* Ensure base backup filename matches core */\n   if (!string_starts_with(backup_filename, core_filename))\n      goto error;\n\n   /* Remove backup file extension */\n   path_remove_extension(backup_filename);\n\n   /* Parse backup filename metadata\n    * - <core_filename>.<timestamp>.<crc>.<backup_mode>\n    * - timestamp: YYYYMMDDTHHMMSS */\n   entry = &backup_list->entries[backup_list->size];\n\n   if (sscanf(backup_filename + strlen(core_filename),\n       \".%04u%02u%02uT%02u%02u%02u.%08x.%u\",\n       &entry->date.year, &entry->date.month, &entry->date.day,\n       &entry->date.hour, &entry->date.minute, &entry->date.second,\n       &entry->crc, &backup_mode) != 8)\n      goto error;\n\n   entry->backup_mode = (enum core_backup_mode)backup_mode;\n\n   /* Cache backup path */\n   entry->backup_path = strdup(backup_path);\n   backup_list->size++;\n\n   free(backup_filename);\n\n   return true;\n\nerror:\n   if (backup_filename)\n      free(backup_filename);\n\n   return false;\n}", "path": "RetroArch/core_backup.c", "commit_date": "2020-08-31 00:00:00", "repo_name": "libretro/RetroArch", "stars": 9033, "license": "gpl-3.0", "language": "c", "size": 475180}
{"docstring": "/* Returns detected type of specified core backup file */\n", "func_signal": "enum core_backup_type core_backup_get_backup_type(const char *backup_path)", "code": "{\n   const char *backup_ext            = NULL;\n   struct string_list *metadata_list = NULL;\n   char core_ext[255];\n\n   core_ext[0] = '\\0';\n\n   if (string_is_empty(backup_path) || !path_is_valid(backup_path))\n      goto error;\n\n   /* Get backup file extension */\n   backup_ext = path_get_extension(backup_path);\n\n   if (string_is_empty(backup_ext))\n      goto error;\n\n   /* Get platform-specific dynamic library extension */\n   if (!frontend_driver_get_core_extension(core_ext, sizeof(core_ext)))\n      goto error;\n\n   /* Check if this is an archived backup */\n   if (string_is_equal_noncase(backup_ext,\n         FILE_PATH_CORE_BACKUP_EXTENSION_NO_DOT))\n   {\n      const char *backup_filename = NULL;\n      const char *src_ext         = NULL;\n\n      /* Split the backup filename into its various\n       * metadata components */\n      backup_filename = path_basename(backup_path);\n\n      if (string_is_empty(backup_filename))\n         goto error;\n\n      metadata_list = string_split(backup_filename, \".\");\n\n      if (!metadata_list || (metadata_list->size != 6))\n         goto error;\n\n      /* Get extension of source core file */\n      src_ext = metadata_list->elems[1].data;\n\n      if (string_is_empty(src_ext))\n         goto error;\n\n      /* Check whether extension is valid */\n      if (!string_is_equal_noncase(src_ext, core_ext))\n         goto error;\n\n      string_list_free(metadata_list);\n      metadata_list = NULL;\n   \n      return CORE_BACKUP_TYPE_ARCHIVE;\n   }\n\n   /* Check if this is a plain dynamic library file */\n   if (string_is_equal_noncase(backup_ext, core_ext))\n      return CORE_BACKUP_TYPE_LIB;\n\nerror:\n   if (metadata_list)\n   {\n      string_list_free(metadata_list);\n      metadata_list = NULL;\n   }\n\n   return CORE_BACKUP_TYPE_INVALID;\n}", "path": "RetroArch/core_backup.c", "commit_date": "2020-08-31 00:00:00", "repo_name": "libretro/RetroArch", "stars": 9033, "license": "gpl-3.0", "language": "c", "size": 475180}
{"docstring": "/* Sets the eject state of the virtual disk tray */\n", "func_signal": "bool disk_control_set_eject_state(\n      disk_control_interface_t *disk_control,\n      bool eject, bool verbosity)", "code": "{\n   bool error = false;\n   char msg[128];\n\n   msg[0] = '\\0';\n\n   if (!disk_control || !disk_control->cb.set_eject_state)\n      return false;\n\n   /* Set eject state */\n   if (disk_control->cb.set_eject_state(eject))\n      snprintf(\n            msg, sizeof(msg), \"%s %s\",\n            eject ? msg_hash_to_str(MSG_DISK_EJECTED) :\n                  msg_hash_to_str(MSG_DISK_CLOSED),\n            msg_hash_to_str(MSG_VIRTUAL_DISK_TRAY));\n   else\n   {\n      error = true;\n      snprintf(\n            msg, sizeof(msg), \"%s %s %s\",\n            msg_hash_to_str(MSG_FAILED_TO),\n            eject ? msg_hash_to_str(MSG_VIRTUAL_DISK_TRAY_EJECT) :\n                  msg_hash_to_str(MSG_VIRTUAL_DISK_TRAY_CLOSE),\n            msg_hash_to_str(MSG_VIRTUAL_DISK_TRAY));\n   }\n\n   if (!string_is_empty(msg))\n   {\n      if (error)\n         RARCH_ERR(\"%s\\n\", msg);\n      else\n         RARCH_LOG(\"%s\\n\", msg);\n\n      /* Errors should always be displayed */\n      if (verbosity || error)\n         runloop_msg_queue_push(\n               msg, 1, error ? 180 : 60,\n               true, NULL,\n               MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n   }\n\n   return !error;\n}", "path": "RetroArch/disk_control_interface.c", "commit_date": "2020-07-17 00:00:00", "repo_name": "libretro/RetroArch", "stars": 9033, "license": "gpl-3.0", "language": "c", "size": 475180}
{"docstring": "/* Fetches core backup list entry corresponding\n * to the specified core crc checksum value.\n * Note that 'manual' and 'auto' backups are\n * considered independent - we only compare\n * crc values for the specified backup_mode.\n * Returns false if entry is not found. */\n", "func_signal": "bool core_backup_list_get_crc(\n      core_backup_list_t *backup_list,\n      uint32_t crc, enum core_backup_mode backup_mode,\n      const core_backup_list_entry_t **entry)", "code": "{\n   size_t i;\n\n   if (!backup_list || !backup_list->entries || !entry)\n      return false;\n\n   for (i = 0; i < backup_list->size; i++)\n   {\n      core_backup_list_entry_t *current_entry = &backup_list->entries[i];\n\n      if (current_entry &&\n          (current_entry->crc == crc) &&\n          (current_entry->backup_mode == backup_mode))\n      {\n         *entry = current_entry;\n         return true;\n      }\n   }\n\n   return false;\n}", "path": "RetroArch/core_backup.c", "commit_date": "2020-08-31 00:00:00", "repo_name": "libretro/RetroArch", "stars": 9033, "license": "gpl-3.0", "language": "c", "size": 475180}
{"docstring": "/* Returns number of entries of specified 'backup mode'\n * (manual or automatic) in core backup list */\n", "func_signal": "size_t core_backup_list_get_num_backups(\n      core_backup_list_t *backup_list,\n      enum core_backup_mode backup_mode)", "code": "{\n   size_t i;\n   size_t num_backups = 0;\n\n   if (!backup_list || !backup_list->entries)\n      return 0;\n\n   for (i = 0; i < backup_list->size; i++)\n   {\n      core_backup_list_entry_t *current_entry = &backup_list->entries[i];\n\n      if (current_entry &&\n          (current_entry->backup_mode == backup_mode))\n         num_backups++;\n   }\n\n   return num_backups;\n}", "path": "RetroArch/core_backup.c", "commit_date": "2020-08-31 00:00:00", "repo_name": "libretro/RetroArch", "stars": 9033, "license": "gpl-3.0", "language": "c", "size": 475180}
{"docstring": "/* Returns number of disk images registered\n * by the core */\n", "func_signal": "unsigned disk_control_get_num_images(\n      disk_control_interface_t *disk_control)", "code": "{\n   if (!disk_control || !disk_control->cb.get_num_images)\n      return 0;\n   return disk_control->cb.get_num_images();\n}", "path": "RetroArch/disk_control_interface.c", "commit_date": "2020-07-17 00:00:00", "repo_name": "libretro/RetroArch", "stars": 9033, "license": "gpl-3.0", "language": "c", "size": 475180}
{"docstring": "/* Read LEN bytes from the file NODE on disk DISK into the buffer BUF,\n   beginning with the block POS.  READ_HOOK should be set before\n   reading a block from the file.  READ_HOOK_DATA is passed through as\n   the DATA argument to READ_HOOK.  GET_BLOCK is used to translate\n   file blocks to disk blocks.  The file is FILESIZE bytes big and the\n   blocks have a size of LOG2BLOCKSIZE (in log2).  */\n", "func_signal": "grub_ssize_t\ngrub_fshelp_read_file (grub_disk_t disk, grub_fshelp_node_t node,\n\t\t       grub_disk_read_hook_t read_hook, void *read_hook_data,\n\t\t       grub_off_t pos, grub_size_t len, char *buf,\n\t\t       grub_disk_addr_t (*get_block) (grub_fshelp_node_t node,\n                                                      grub_disk_addr_t block),\n\t\t       grub_off_t filesize, int log2blocksize,\n\t\t       grub_disk_addr_t blocks_start)", "code": "{\n  grub_disk_addr_t i, blockcnt;\n  int blocksize = 1 << (log2blocksize + GRUB_DISK_SECTOR_BITS);\n\n  if (pos > filesize)\n    {\n      grub_error (GRUB_ERR_OUT_OF_RANGE,\n\t\t  N_(\"attempt to read past the end of file\"));\n      return -1;\n    }\n\n  /* Adjust LEN so it we can't read past the end of the file.  */\n  if (pos + len > filesize)\n    len = filesize - pos;\n\n  blockcnt = ((len + pos) + blocksize - 1) >> (log2blocksize + GRUB_DISK_SECTOR_BITS);\n\n  for (i = pos >> (log2blocksize + GRUB_DISK_SECTOR_BITS); i < blockcnt; i++)\n    {\n      grub_disk_addr_t blknr;\n      int blockoff = pos & (blocksize - 1);\n      int blockend = blocksize;\n\n      int skipfirst = 0;\n\n      blknr = get_block (node, i);\n      if (grub_errno)\n\treturn -1;\n\n      blknr = blknr << log2blocksize;\n\n      /* Last block.  */\n      if (i == blockcnt - 1)\n\t{\n\t  blockend = (len + pos) & (blocksize - 1);\n\n\t  /* The last portion is exactly blocksize.  */\n\t  if (! blockend)\n\t    blockend = blocksize;\n\t}\n\n      /* First block.  */\n      if (i == (pos >> (log2blocksize + GRUB_DISK_SECTOR_BITS)))\n\t{\n\t  skipfirst = blockoff;\n\t  blockend -= skipfirst;\n\t}\n\n      /* If the block number is 0 this block is not stored on disk but\n\t is zero filled instead.  */\n      if (blknr)\n\t{\n\t  disk->read_hook = read_hook;\n\t  disk->read_hook_data = read_hook_data;\n\n\t  grub_disk_read (disk, blknr + blocks_start, skipfirst,\n\t\t\t  blockend, buf);\n\t  disk->read_hook = 0;\n\t  if (grub_errno)\n\t    return -1;\n\t}\n      else if (read_hook != (grub_disk_read_hook_t)grub_disk_blocklist_read)\n\tgrub_memset (buf, 0, blockend);\n\n      buf += blocksize - skipfirst;\n    }\n\n  return len;\n}", "path": "Ventoy/GRUB2/MOD_SRC/grub-2.04/grub-core/fs/fshelp.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "ventoy/Ventoy", "stars": 56826, "license": "gpl-3.0", "language": "c", "size": 212932}
{"docstring": "/* Helper for find_file_iter.  */\n", "func_signal": "static void\nfree_node (grub_fshelp_node_t node, struct grub_fshelp_find_file_ctx *ctx)", "code": "{\n  if (node != ctx->rootnode)\n    grub_free (node);\n}", "path": "Ventoy/GRUB2/MOD_SRC/grub-2.04/grub-core/fs/fshelp.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "ventoy/Ventoy", "stars": 56826, "license": "gpl-3.0", "language": "c", "size": 212932}
{"docstring": "/* Read data from the disk.  */\n", "func_signal": "grub_err_t\ngrub_disk_read (grub_disk_t disk, grub_disk_addr_t sector,\n\t\tgrub_off_t offset, grub_size_t size, void *buf)", "code": "{\n    if (disk->read_hook == (grub_disk_read_hook_t)grub_disk_blocklist_read)\n    {\n        return grub_disk_blocklist_read((ventoy_img_chunk_list *)disk->read_hook_data, sector, size, disk->log_sector_size);\n    }\n\n  /* First of all, check if the region is within the disk.  */\n  if (grub_disk_adjust_range (disk, &sector, &offset, size) != GRUB_ERR_NONE)\n    {\n      grub_error_push ();\n      grub_dprintf (\"disk\", \"Read out of range: sector 0x%llx (%s).\\n\",\n\t\t    (unsigned long long) sector, grub_errmsg);\n      grub_error_pop ();\n      return grub_errno;\n    }\n\n  /* First read until first cache boundary.   */\n  if (offset || (sector & (GRUB_DISK_CACHE_SIZE - 1)))\n    {\n      grub_disk_addr_t start_sector;\n      grub_size_t pos;\n      grub_err_t err;\n      grub_size_t len;\n\n      start_sector = sector & ~((grub_disk_addr_t) GRUB_DISK_CACHE_SIZE - 1);\n      pos = (sector - start_sector) << GRUB_DISK_SECTOR_BITS;\n      len = ((GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS)\n\t     - pos - offset);\n      if (len > size)\n\tlen = size;\n      err = grub_disk_read_small (disk, start_sector,\n\t\t\t\t  offset + pos, len, buf);\n      if (err)\n\treturn err;\n      buf = (char *) buf + len;\n      size -= len;\n      offset += len;\n      sector += (offset >> GRUB_DISK_SECTOR_BITS);\n      offset &= ((1 << GRUB_DISK_SECTOR_BITS) - 1);\n    }\n\n  /* Until SIZE is zero...  */\n  while (size >= (GRUB_DISK_CACHE_SIZE << GRUB_DISK_SECTOR_BITS))\n    {\n      char *data = NULL;\n      grub_disk_addr_t agglomerate;\n      grub_err_t err;\n\n      /* agglomerate read until we find a first cached entry.  */\n      for (agglomerate = 0; agglomerate\n\t     < (size >> (GRUB_DISK_SECTOR_BITS + GRUB_DISK_CACHE_BITS))\n\t     && agglomerate < disk->max_agglomerate;\n\t   agglomerate++)\n\t{\n\t  data = grub_disk_cache_fetch (disk->dev->id, disk->id,\n\t\t\t\t\tsector + (agglomerate\n\t\t\t\t\t\t  << GRUB_DISK_CACHE_BITS));\n\t  if (data)\n\t    break;\n\t}\n\n      if (data)\n\t{\n\t  grub_memcpy ((char *) buf\n\t\t       + (agglomerate << (GRUB_DISK_CACHE_BITS\n\t\t\t\t\t  + GRUB_DISK_SECTOR_BITS)),\n\t\t       data, GRUB_DISK_CACHE_SIZE << GRUB_DISK_SECTOR_BITS);\n\t  grub_disk_cache_unlock (disk->dev->id, disk->id,\n\t\t\t\t  sector + (agglomerate\n\t\t\t\t\t    << GRUB_DISK_CACHE_BITS));\n\t}\n\n      if (agglomerate)\n\t{\n\t  grub_disk_addr_t i;\n\n\t  err = (disk->dev->disk_read) (disk, transform_sector (disk, sector),\n\t\t\t\t\tagglomerate << (GRUB_DISK_CACHE_BITS\n\t\t\t\t\t\t\t+ GRUB_DISK_SECTOR_BITS\n\t\t\t\t\t\t\t- disk->log_sector_size),\n\t\t\t\t\tbuf);\n\t  if (err)\n\t    return err;\n\t  \n\t  for (i = 0; i < agglomerate; i ++)\n\t    grub_disk_cache_store (disk->dev->id, disk->id,\n\t\t\t\t   sector + (i << GRUB_DISK_CACHE_BITS),\n\t\t\t\t   (char *) buf\n\t\t\t\t   + (i << (GRUB_DISK_CACHE_BITS\n\t\t\t\t\t    + GRUB_DISK_SECTOR_BITS)));\n\n\n\t  if (disk->read_hook)\n\t    (disk->read_hook) (sector, 0, agglomerate << (GRUB_DISK_CACHE_BITS + GRUB_DISK_SECTOR_BITS),\n\t\t\t       disk->read_hook_data);\n\n\t  sector += agglomerate << GRUB_DISK_CACHE_BITS;\n\t  size -= agglomerate << (GRUB_DISK_CACHE_BITS + GRUB_DISK_SECTOR_BITS);\n\t  buf = (char *) buf \n\t    + (agglomerate << (GRUB_DISK_CACHE_BITS + GRUB_DISK_SECTOR_BITS));\n\t}\n\n      if (data)\n\t{\n\t  if (disk->read_hook)\n\t    (disk->read_hook) (sector, 0, (GRUB_DISK_CACHE_SIZE << GRUB_DISK_SECTOR_BITS),\n\t\t\t       disk->read_hook_data);\n\t  sector += GRUB_DISK_CACHE_SIZE;\n\t  buf = (char *) buf + (GRUB_DISK_CACHE_SIZE << GRUB_DISK_SECTOR_BITS);\n\t  size -= (GRUB_DISK_CACHE_SIZE << GRUB_DISK_SECTOR_BITS);\n\t}\n    }\n\n  /* And now read the last part.  */\n  if (size)\n    {\n      grub_err_t err;\n      err = grub_disk_read_small (disk, sector, 0, size, buf);\n      if (err)\n\treturn err;\n    }\n\n  return grub_errno;\n}", "path": "Ventoy/GRUB2/MOD_SRC/grub-2.04/grub-core/kern/disk.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "ventoy/Ventoy", "stars": 56826, "license": "gpl-3.0", "language": "c", "size": 212932}
{"docstring": "/* The main routine.  */\n", "func_signal": "void __attribute__ ((noreturn))\ngrub_main (void)", "code": "{\n  /* First of all, initialize the machine.  */\n  grub_machine_init ();\n\n  grub_boot_time (\"After machine init.\");\n\n  /* Hello.  */\n  grub_setcolorstate (GRUB_TERM_COLOR_HIGHLIGHT);\n  //grub_printf (\"Welcome to GRUB!\\n\\n\");\n  grub_setcolorstate (GRUB_TERM_COLOR_STANDARD);\n\n  grub_load_config ();\n\n  grub_boot_time (\"Before loading embedded modules.\");\n\n  /* Load pre-loaded modules and free the space.  */\n  grub_register_exported_symbols ();\n#ifdef GRUB_LINKER_HAVE_INIT\n  grub_arch_dl_init_linker ();\n#endif  \n  grub_load_modules ();\n\n  grub_boot_time (\"After loading embedded modules.\");\n\n  /* It is better to set the root device as soon as possible,\n     for convenience.  */\n  grub_set_prefix_and_root ();\n  grub_env_export (\"root\");\n  grub_env_export (\"prefix\");\n\n#ifndef GRUB_MACHINE_EFI\n  if (0 == ventoy_check_file_exist(\"%s/grub.cfg\", grub_env_get(\"prefix\"))) {\n      ventoy_legacy_limit_workaround();\n  }\n#endif\n\n  /* Reclaim space used for modules.  */\n  reclaim_module_space ();\n\n  grub_boot_time (\"After reclaiming module space.\");\n\n  grub_register_core_commands ();\n\n  grub_boot_time (\"Before execution of embedded config.\");\n\n  if (load_config)\n    grub_parser_execute (load_config);\n\n  grub_boot_time (\"After execution of embedded config. Attempt to go to normal mode\");\n\n  grub_load_normal_mode ();\n  grub_rescue_run ();\n}", "path": "Ventoy/GRUB2/MOD_SRC/grub-2.04/grub-core/kern/main.c", "commit_date": "2020-08-07 00:00:00", "repo_name": "ventoy/Ventoy", "stars": 56826, "license": "gpl-3.0", "language": "c", "size": 212932}
{"docstring": "/* Sets MESSAGE as the progress message for the view.\n   MESSAGE can be 0, in which case no message is displayed.  */\n", "func_signal": "static void\nset_progress_message (grub_gfxmenu_view_t view, const char *message)", "code": "{\n  grub_free (view->progress_message_text);\n  if (message)\n    view->progress_message_text = grub_strdup (message);\n  else\n    view->progress_message_text = 0;\n}", "path": "Ventoy/GRUB2/MOD_SRC/grub-2.04/grub-core/gfxmenu/view.c", "commit_date": "2020-09-13 00:00:00", "repo_name": "ventoy/Ventoy", "stars": 56826, "license": "gpl-3.0", "language": "c", "size": 212932}
{"docstring": "/* Helper for grub_fshelp_find_file.  */\n", "func_signal": "static int\nfind_file_iter (const char *filename, enum grub_fshelp_filetype filetype,\n\t\tgrub_fshelp_node_t node, void *data)", "code": "{\n  struct grub_fshelp_find_file_iter_ctx *ctx = data;\n\n  if (g_ventoy_case_insensitive)\n  {\n      filetype |= GRUB_FSHELP_CASE_INSENSITIVE;\n  }\n\n  if (filetype == GRUB_FSHELP_UNKNOWN ||\n      ((filetype & GRUB_FSHELP_CASE_INSENSITIVE)\n       ? grub_strcasecmp (ctx->name, filename)\n       : grub_strcmp (ctx->name, filename)))\n    {\n      grub_free (node);\n      return 0;\n    }\n\n  /* The node is found, stop iterating over the nodes.  */\n  *ctx->foundnode = node;\n  *ctx->foundtype = filetype;\n  return 1;\n}", "path": "Ventoy/GRUB2/MOD_SRC/grub-2.04/grub-core/fs/fshelp.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "ventoy/Ventoy", "stars": 56826, "license": "gpl-3.0", "language": "c", "size": 212932}
{"docstring": "/* Create a new view object, loading the theme specified by THEME_PATH and\n   associating MODEL with the view.  */\n", "func_signal": "grub_gfxmenu_view_t\ngrub_gfxmenu_view_new (const char *theme_path,\n\t\t       int width, int height)", "code": "{\n  grub_gfxmenu_view_t view;\n  grub_font_t default_font;\n  grub_video_rgba_color_t default_fg_color;\n  grub_video_rgba_color_t default_bg_color;\n\n  view = grub_malloc (sizeof (*view));\n  if (! view)\n    return 0;\n\n  while (grub_gfxmenu_timeout_notifications)\n    {\n      struct grub_gfxmenu_timeout_notify *p;\n      p = grub_gfxmenu_timeout_notifications;\n      grub_gfxmenu_timeout_notifications = grub_gfxmenu_timeout_notifications->next;\n      grub_free (p);\n    }\n\n  view->screen.x = 0;\n  view->screen.y = 0;\n  view->screen.width = width;\n  view->screen.height = height;\n\n  view->need_to_check_sanity = 1;\n  view->terminal_border = 3;\n  view->terminal_rect.width = view->screen.width * 7 / 10;\n  view->terminal_rect.height = view->screen.height * 7 / 10;\n  view->terminal_rect.x = view->screen.x + (view->screen.width\n                                            - view->terminal_rect.width) / 2;\n  view->terminal_rect.y = view->screen.y + (view->screen.height\n                                            - view->terminal_rect.height) / 2;\n\n  default_font = grub_font_get (\"Unknown Regular 16\");\n  default_fg_color = grub_video_rgba_color_rgb (0, 0, 0);\n  default_bg_color = grub_video_rgba_color_rgb (255, 255, 255);\n\n  view->canvas = 0;\n\n  view->title_font = default_font;\n  view->message_font = default_font;\n  view->terminal_font_name = grub_strdup (\"Fixed 10\");\n  view->title_color = default_fg_color;\n  view->message_color = default_bg_color;\n  view->message_bg_color = default_fg_color;\n  view->raw_desktop_image = 0;\n  view->scaled_desktop_image = 0;\n  view->desktop_image_scale_method = GRUB_VIDEO_BITMAP_SELECTION_METHOD_STRETCH;\n  view->desktop_image_h_align = GRUB_VIDEO_BITMAP_H_ALIGN_CENTER;\n  view->desktop_image_v_align = GRUB_VIDEO_BITMAP_V_ALIGN_CENTER;\n  view->desktop_color = default_bg_color;\n  view->terminal_box = grub_gfxmenu_create_box (0, 0);\n  view->title_text = grub_strdup (_(\"GRUB Boot Menu\"));\n  view->progress_message_text = 0;\n  view->theme_path = 0;\n\n  /* Set the timeout bar's frame.  */\n  view->progress_message_frame.width = view->screen.width * 4 / 5;\n  view->progress_message_frame.height = 50;\n  view->progress_message_frame.x = view->screen.x\n    + (view->screen.width - view->progress_message_frame.width) / 2;\n  view->progress_message_frame.y = view->screen.y\n    + view->screen.height - 90 - 20 - view->progress_message_frame.height;\n\n  if (grub_gfxmenu_view_load_theme (view, theme_path) != 0)\n    {\n      grub_gfxmenu_view_destroy (view);\n      return 0;\n    }\n\n  return view;\n}", "path": "Ventoy/GRUB2/MOD_SRC/grub-2.04/grub-core/gfxmenu/view.c", "commit_date": "2020-09-13 00:00:00", "repo_name": "ventoy/Ventoy", "stars": 56826, "license": "gpl-3.0", "language": "c", "size": 212932}
{"docstring": "/*\n * You can control the verbosity of the driver output by setting the shell environment\n * variable FS_LOGGING to one of the values defined in the FS_LOGLEVEL constants\n */\n", "func_signal": "VOID\nSetLogging(VOID)", "code": "{\n\tEFI_STATUS Status;\n\tCHAR16 LogVar[4];\n\tUINTN i, LogVarSize = sizeof(LogVar);\n\n\tStatus = RT->GetVariable(L\"FS_LOGGING\", &ShellVariable, NULL, &LogVarSize, LogVar);\n\tif (Status == EFI_SUCCESS)\n\t\tLogLevel = Atoi(LogVar);\n\n\tfor (i=0; i<ARRAYSIZE(PrintTable); i++)\n\t\t*PrintTable[i] = (i < LogLevel)?(Print_t)Print:(Print_t)PrintNone;\n\n\tPrintExtra(L\"LogLevel = %d\\n\", LogLevel);\n}", "path": "Ventoy/EDK2/efiffs/org/src/logging.c", "commit_date": "2020-05-20 00:00:00", "repo_name": "ventoy/Ventoy", "stars": 56826, "license": "gpl-3.0", "language": "c", "size": 212932}
{"docstring": "/* Load the normal mode module and execute the normal mode if possible.  */\n", "func_signal": "static void\ngrub_load_normal_mode (void)", "code": "{\n  /* Load the module.  */\n  grub_dl_load (\"normal\");\n\n  /* Print errors if any.  */\n  grub_print_error ();\n  grub_errno = 0;\n\n  grub_command_execute (\"normal\", 0, 0);\n}", "path": "Ventoy/GRUB2/MOD_SRC/grub-2.04/grub-core/kern/main.c", "commit_date": "2020-08-07 00:00:00", "repo_name": "ventoy/Ventoy", "stars": 56826, "license": "gpl-3.0", "language": "c", "size": 212932}
{"docstring": "/* Update any boot menu components with the current menu model and\n   theme path.  */\n", "func_signal": "static void\nupdate_menu_components (grub_gfxmenu_view_t view)", "code": "{\n  grub_gui_iterate_recursively ((grub_gui_component_t) view->canvas,\n                                update_menu_visit, view);\n}", "path": "Ventoy/GRUB2/MOD_SRC/grub-2.04/grub-core/gfxmenu/view.c", "commit_date": "2020-09-13 00:00:00", "repo_name": "ventoy/Ventoy", "stars": 56826, "license": "gpl-3.0", "language": "c", "size": 212932}
{"docstring": "/* Lookup the node PATH.  The node ROOTNODE describes the root of the\n   directory tree.  The node found is returned in FOUNDNODE, which is\n   either a ROOTNODE or a new malloc'ed node.  ITERATE_DIR is used to\n   iterate over all directory entries in the current node.\n   READ_SYMLINK is used to read the symlink if a node is a symlink.\n   EXPECTTYPE is the type node that is expected by the called, an\n   error is generated if the node is not of the expected type.  */\n", "func_signal": "grub_err_t\ngrub_fshelp_find_file (const char *path, grub_fshelp_node_t rootnode,\n\t\t       grub_fshelp_node_t *foundnode,\n\t\t       iterate_dir_func iterate_dir,\n\t\t       read_symlink_func read_symlink,\n\t\t       enum grub_fshelp_filetype expecttype)", "code": "{\n  return grub_fshelp_find_file_real (path, rootnode, foundnode,\n\t\t\t\t     iterate_dir, NULL, \n\t\t\t\t     read_symlink, expecttype);\n\n}", "path": "Ventoy/GRUB2/MOD_SRC/grub-2.04/grub-core/fs/fshelp.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "ventoy/Ventoy", "stars": 56826, "license": "gpl-3.0", "language": "c", "size": 212932}
{"docstring": "/* Print all variables in current context.  */\n", "func_signal": "static int\nprint_var (const char *name, const char *value,\n           void *hook_data __attribute__ ((unused)))", "code": "{\n  grub_printf (\"%s=%s\\n\", name, value);\n  return 0;\n}", "path": "Ventoy/GRUB2/MOD_SRC/grub-2.04/grub-core/commands/loadenv.c", "commit_date": "2020-08-07 00:00:00", "repo_name": "ventoy/Ventoy", "stars": 56826, "license": "gpl-3.0", "language": "c", "size": 212932}
{"docstring": "/* Destroy the view object.  All used memory is freed.  */\n", "func_signal": "void\ngrub_gfxmenu_view_destroy (grub_gfxmenu_view_t view)", "code": "{\n  if (!view)\n    return;\n  while (grub_gfxmenu_timeout_notifications)\n    {\n      struct grub_gfxmenu_timeout_notify *p;\n      p = grub_gfxmenu_timeout_notifications;\n      grub_gfxmenu_timeout_notifications = grub_gfxmenu_timeout_notifications->next;\n      grub_free (p);\n    }\n  grub_video_bitmap_destroy (view->raw_desktop_image);\n  grub_video_bitmap_destroy (view->scaled_desktop_image);\n  if (view->terminal_box)\n    view->terminal_box->destroy (view->terminal_box);\n  grub_free (view->terminal_font_name);\n  grub_free (view->title_text);\n  grub_free (view->progress_message_text);\n  grub_free (view->theme_path);\n  if (view->canvas)\n    view->canvas->component.ops->destroy (view->canvas);\n  grub_free (view);\n}", "path": "Ventoy/GRUB2/MOD_SRC/grub-2.04/grub-core/gfxmenu/view.c", "commit_date": "2020-09-13 00:00:00", "repo_name": "ventoy/Ventoy", "stars": 56826, "license": "gpl-3.0", "language": "c", "size": 212932}
{"docstring": "/* Refresh list information (useful for submenus) */\n", "func_signal": "static void\nrefresh_menu_components (grub_gfxmenu_view_t view)", "code": "{\n  grub_gui_iterate_recursively ((grub_gui_component_t) view->canvas,\n                                refresh_menu_visit, view);\n}", "path": "Ventoy/GRUB2/MOD_SRC/grub-2.04/grub-core/gfxmenu/view.c", "commit_date": "2020-09-13 00:00:00", "repo_name": "ventoy/Ventoy", "stars": 56826, "license": "gpl-3.0", "language": "c", "size": 212932}
{"docstring": "/* Store blocklists in a linked list.  */\n", "func_signal": "static void\nsave_env_read_hook (grub_disk_addr_t sector, unsigned offset, unsigned length,\n\t\t    void *data)", "code": "{\n  struct grub_cmd_save_env_ctx *ctx = data;\n  struct blocklist *block;\n\n  block = grub_malloc (sizeof (*block));\n  if (! block)\n    return;\n\n  block->sector = sector;\n  block->offset = offset;\n  block->length = length;\n\n  /* Slightly complicated, because the list should be FIFO.  */\n  block->next = 0;\n  if (ctx->tail)\n    ctx->tail->next = block;\n  ctx->tail = block;\n  if (! ctx->head)\n    ctx->head = block;\n}", "path": "Ventoy/GRUB2/MOD_SRC/grub-2.04/grub-core/commands/loadenv.c", "commit_date": "2020-08-07 00:00:00", "repo_name": "ventoy/Ventoy", "stars": 56826, "license": "gpl-3.0", "language": "c", "size": 212932}
{"docstring": "/* Load all modules in core.  */\n", "func_signal": "static void\ngrub_load_modules (void)", "code": "{\n  struct grub_module_header *header;\n  FOR_MODULES (header)\n  {\n    /* Not an ELF module, skip.  */\n    if (header->type != OBJ_TYPE_ELF)\n      continue;\n\n    if (! grub_dl_load_core ((char *) header + sizeof (struct grub_module_header),\n\t\t\t     (header->size - sizeof (struct grub_module_header))))\n      grub_fatal (\"%s\", grub_errmsg);\n\n    if (grub_errno)\n      grub_print_error ();\n  }\n}", "path": "Ventoy/GRUB2/MOD_SRC/grub-2.04/grub-core/kern/main.c", "commit_date": "2020-08-07 00:00:00", "repo_name": "ventoy/Ventoy", "stars": 56826, "license": "gpl-3.0", "language": "c", "size": 212932}
{"docstring": "/*\n * Makefile.am mimics this when generating tests/syslinux/ubuntu10.04_grub.cfg,\n * so changes here may need to be reflected there too.\n */\n", "func_signal": "static void\nsimplify_filename (char *str)", "code": "{\n  char *iptr, *optr = str;\n  for (iptr = str; *iptr; iptr++)\n    {\n      if (*iptr == '/' && optr != str && optr[-1] == '/')\n\tcontinue;\n      if (iptr[0] == '/' && iptr[1] == '.' && iptr[2] == '/')\n\t{\n\t  iptr += 2;\n\t  continue;\n\t}\n      if (iptr[0] == '/' && iptr[1] == '.' && iptr[2] == '.'\n\t  && iptr[3] == '/')\n\t{\n\t  iptr += 3;\n\t  while (optr >= str && *optr != '/')\n\t    optr--;\n\t  if (optr < str)\n\t    {\n\t      str[0] = '/';\n\t      optr = str;\n\t    }\n\t  optr++;\n\t  continue;\n\t}\n      *optr++ = *iptr;\n    }\n  *optr = '\\0';\n}", "path": "Ventoy/GRUB2/MOD_SRC/grub-2.04/grub-core/lib/syslinux_parse.c", "commit_date": "2020-08-13 00:00:00", "repo_name": "ventoy/Ventoy", "stars": 56826, "license": "gpl-3.0", "language": "c", "size": 212932}
{"docstring": "/* Small read (less than cache size and not pass across cache unit boundaries).\n   sector is already adjusted and is divisible by cache unit size.\n */\n", "func_signal": "static grub_err_t\ngrub_disk_read_small_real (grub_disk_t disk, grub_disk_addr_t sector,\n\t\t\t   grub_off_t offset, grub_size_t size, void *buf)", "code": "{\n  char *data;\n  char *tmp_buf;\n\n  /* Fetch the cache.  */\n  data = grub_disk_cache_fetch (disk->dev->id, disk->id, sector);\n  if (data)\n    {\n      /* Just copy it!  */\n      grub_memcpy (buf, data + offset, size);\n      grub_disk_cache_unlock (disk->dev->id, disk->id, sector);\n      return GRUB_ERR_NONE;\n    }\n\n  /* Allocate a temporary buffer.  */\n  tmp_buf = grub_malloc (GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS);\n  if (! tmp_buf)\n    return grub_errno;\n\n  /* Otherwise read data from the disk actually.  */\n  if (disk->total_sectors == GRUB_DISK_SIZE_UNKNOWN\n      || sector + GRUB_DISK_CACHE_SIZE\n      < (disk->total_sectors << (disk->log_sector_size - GRUB_DISK_SECTOR_BITS)))\n    {\n      grub_err_t err;\n      err = (disk->dev->disk_read) (disk, transform_sector (disk, sector),\n\t\t\t\t    1U << (GRUB_DISK_CACHE_BITS\n\t\t\t\t\t   + GRUB_DISK_SECTOR_BITS\n\t\t\t\t\t   - disk->log_sector_size), tmp_buf);\n      if (!err)\n\t{\n\t  /* Copy it and store it in the disk cache.  */\n\t  grub_memcpy (buf, tmp_buf + offset, size);\n\t  grub_disk_cache_store (disk->dev->id, disk->id,\n\t\t\t\t sector, tmp_buf);\n\t  grub_free (tmp_buf);\n\t  return GRUB_ERR_NONE;\n\t}\n    }\n\n  grub_free (tmp_buf);\n  grub_errno = GRUB_ERR_NONE;\n\n  {\n    /* Uggh... Failed. Instead, just read necessary data.  */\n    unsigned num;\n    grub_disk_addr_t aligned_sector;\n\n    sector += (offset >> GRUB_DISK_SECTOR_BITS);\n    offset &= ((1 << GRUB_DISK_SECTOR_BITS) - 1);\n    aligned_sector = (sector & ~((1ULL << (disk->log_sector_size\n\t\t\t\t\t   - GRUB_DISK_SECTOR_BITS))\n\t\t\t\t - 1));\n    offset += ((sector - aligned_sector) << GRUB_DISK_SECTOR_BITS);\n    num = ((size + offset + (1ULL << (disk->log_sector_size))\n\t    - 1) >> (disk->log_sector_size));\n\n    tmp_buf = grub_malloc (num << disk->log_sector_size);\n    if (!tmp_buf)\n      return grub_errno;\n    \n    if ((disk->dev->disk_read) (disk, transform_sector (disk, aligned_sector),\n\t\t\t\tnum, tmp_buf))\n      {\n\tgrub_error_push ();\n\tgrub_dprintf (\"disk\", \"%s read failed\\n\", disk->name);\n\tgrub_error_pop ();\n\tgrub_free (tmp_buf);\n\treturn grub_errno;\n      }\n    grub_memcpy (buf, tmp_buf + offset, size);\n    grub_free (tmp_buf);\n    return GRUB_ERR_NONE;\n  }\n}", "path": "Ventoy/GRUB2/MOD_SRC/grub-2.04/grub-core/kern/disk.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "ventoy/Ventoy", "stars": 56826, "license": "gpl-3.0", "language": "c", "size": 212932}
{"docstring": "/* Helper for grub_cmd_blocklist.  */\n", "func_signal": "static void\nread_blocklist (grub_disk_addr_t sector, unsigned offset, unsigned length,\n\t\tvoid *data)", "code": "{\n  struct blocklist_ctx *ctx = data;\n\n  if (ctx->num_sectors > 0)\n    {\n      if (ctx->start_sector + ctx->num_sectors == sector\n\t  && offset == 0 && length >= GRUB_DISK_SECTOR_SIZE)\n\t{\n\t  ctx->num_sectors += length >> GRUB_DISK_SECTOR_BITS;\n\t  sector += length >> GRUB_DISK_SECTOR_BITS;\n\t  length &= (GRUB_DISK_SECTOR_SIZE - 1);\n\t}\n\n      if (!length)\n\treturn;\n      print_blocklist (ctx->start_sector, ctx->num_sectors, 0, 0, ctx);\n      ctx->num_sectors = 0;\n    }\n\n  if (offset)\n    {\n      unsigned l = length + offset;\n      l &= (GRUB_DISK_SECTOR_SIZE - 1);\n      l -= offset;\n      print_blocklist (sector, 0, offset, l, ctx);\n      length -= l;\n      sector++;\n      offset = 0;\n    }\n\n  if (!length)\n    return;\n\n  if (length & (GRUB_DISK_SECTOR_SIZE - 1))\n    {\n      if (length >> GRUB_DISK_SECTOR_BITS)\n\t{\n\t  print_blocklist (sector, length >> GRUB_DISK_SECTOR_BITS, 0, 0, ctx);\n\t  sector += length >> GRUB_DISK_SECTOR_BITS;\n\t}\n      print_blocklist (sector, 0, 0, length & (GRUB_DISK_SECTOR_SIZE - 1), ctx);\n    }\n  else\n    {\n      ctx->start_sector = sector;\n      ctx->num_sectors = length >> GRUB_DISK_SECTOR_BITS;\n    }\n}", "path": "Ventoy/GRUB2/MOD_SRC/grub-2.04/grub-core/commands/blocklist.c", "commit_date": "2020-05-20 00:00:00", "repo_name": "ventoy/Ventoy", "stars": 56826, "license": "gpl-3.0", "language": "c", "size": 212932}
{"docstring": "/* Write hook for the environment variables of root. Remove surrounding\n   parentheses, if any.  */\n", "func_signal": "static char *\ngrub_env_write_root (struct grub_env_var *var __attribute__ ((unused)),\n\t\t     const char *val)", "code": "{\n  /* XXX Is it better to check the existence of the device?  */\n  grub_size_t len = grub_strlen (val);\n\n  if (val[0] == '(' && val[len - 1] == ')')\n    return grub_strndup (val + 1, len - 2);\n\n  return grub_strdup (val);\n}", "path": "Ventoy/GRUB2/MOD_SRC/grub-2.04/grub-core/kern/main.c", "commit_date": "2020-08-07 00:00:00", "repo_name": "ventoy/Ventoy", "stars": 56826, "license": "gpl-3.0", "language": "c", "size": 212932}
{"docstring": "/* LibVLC internal version */\n", "func_signal": "int libvlc_media_list_internal_remove_index( libvlc_media_list_t * p_mlist,\n                                             int index )", "code": "{\n    libvlc_media_t * p_md;\n\n    if( (size_t) index >= vlc_array_count( &p_mlist->items ))\n    {\n        libvlc_printerr( \"Index out of bounds\" );\n        return -1;\n    }\n\n    p_md = vlc_array_item_at_index( &p_mlist->items, index );\n\n    notify_item_deletion( p_mlist, p_md, index, EventWillHappen );\n    vlc_array_remove( &p_mlist->items, index );\n    notify_item_deletion( p_mlist, p_md, index, EventDidHappen );\n\n    libvlc_media_release( p_md );\n    return 0;\n}", "path": "vlc/lib/media_list.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "videolan/vlc", "stars": 12699, "license": "gpl-2.0", "language": "c", "size": 531455}
{"docstring": "/* LibVLC internal */\n", "func_signal": "void libvlc_media_list_internal_end_reached( libvlc_media_list_t * p_mlist )", "code": "{\n    libvlc_event_t event;\n\n    event.type = libvlc_MediaListEndReached;\n\n    /* Send the event */\n    libvlc_event_send( &p_mlist->event_manager, &event );\n}", "path": "vlc/lib/media_list.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "videolan/vlc", "stars": 12699, "license": "gpl-2.0", "language": "c", "size": 531455}
{"docstring": "/**************************************************************************\n *       libvlc_media_list_new (Public)\n *\n * Init an object.\n **************************************************************************/\n", "func_signal": "libvlc_media_list_t *libvlc_media_list_new(void)", "code": "{\n    libvlc_media_list_t * p_mlist;\n\n    p_mlist = malloc(sizeof(libvlc_media_list_t));\n    if( unlikely(p_mlist == NULL) )\n    {\n        libvlc_printerr( \"Not enough memory\" );\n        return NULL;\n    }\n\n    libvlc_event_manager_init( &p_mlist->event_manager, p_mlist );\n    p_mlist->b_read_only = false;\n\n    vlc_mutex_init( &p_mlist->object_lock );\n    vlc_atomic_rc_init( &p_mlist->rc );\n\n    vlc_array_init( &p_mlist->items );\n    assert( p_mlist->items.i_count == 0 );\n    p_mlist->p_md = NULL;\n    p_mlist->p_internal_md = NULL;\n\n    return p_mlist;\n}", "path": "vlc/lib/media_list.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "videolan/vlc", "stars": 12699, "license": "gpl-2.0", "language": "c", "size": 531455}
{"docstring": "/**************************************************************************\n *       libvlc_media_list_item_at_index (Public)\n *\n * Lock should be held when entering.\n **************************************************************************/\n", "func_signal": "libvlc_media_t *\nlibvlc_media_list_item_at_index( libvlc_media_list_t * p_mlist,\n                                 int index )", "code": "{\n    libvlc_media_t * p_md;\n\n    if( (size_t) index >= vlc_array_count( &p_mlist->items ))\n    {\n        libvlc_printerr( \"Index out of bounds\" );\n        return NULL;\n    }\n\n    p_md = vlc_array_item_at_index( &p_mlist->items, index );\n    libvlc_media_retain( p_md );\n    return p_md;\n}", "path": "vlc/lib/media_list.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "videolan/vlc", "stars": 12699, "license": "gpl-2.0", "language": "c", "size": 531455}
{"docstring": "/**************************************************************************\n *       libvlc_media_list_insert_media (Public)\n *\n * Lock should be hold when entering.\n **************************************************************************/\n", "func_signal": "int libvlc_media_list_insert_media( libvlc_media_list_t * p_mlist,\n                                    libvlc_media_t * p_md,\n                                    int index )", "code": "{\n    if( !mlist_is_writable(p_mlist) )\n        return -1;\n    libvlc_media_list_internal_insert_media( p_mlist, p_md, index );\n    return 0;\n}", "path": "vlc/lib/media_list.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "videolan/vlc", "stars": 12699, "license": "gpl-2.0", "language": "c", "size": 531455}
{"docstring": "/**************************************************************************\n *       notify_item_deletion (private)\n *\n * Do the appropriate action when an item is added.\n **************************************************************************/\n", "func_signal": "static void\nnotify_item_deletion( libvlc_media_list_t * p_mlist,\n                      libvlc_media_t * p_md,\n                      int index,\n                      EventPlaceInTime event_status )", "code": "{\n    libvlc_event_t event;\n\n    /* Construct the event */\n    if( event_status == EventDidHappen )\n    {\n        event.type = libvlc_MediaListItemDeleted;\n        event.u.media_list_item_deleted.item = p_md;\n        event.u.media_list_item_deleted.index = index;\n    }\n    else /* if( event_status == EventWillHappen ) */\n    {\n        event.type = libvlc_MediaListWillDeleteItem;\n        event.u.media_list_will_delete_item.item = p_md;\n        event.u.media_list_will_delete_item.index = index;\n    }\n\n    /* Send the event */\n    libvlc_event_send( &p_mlist->event_manager, &event );\n}", "path": "vlc/lib/media_list.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "videolan/vlc", "stars": 12699, "license": "gpl-2.0", "language": "c", "size": 531455}
{"docstring": "/**************************************************************************\n *       notify_item_addition (private)\n *\n * Do the appropriate action when an item is deleted.\n **************************************************************************/\n", "func_signal": "static void\nnotify_item_addition( libvlc_media_list_t * p_mlist,\n                      libvlc_media_t * p_md,\n                      int index,\n                      EventPlaceInTime event_status )", "code": "{\n    libvlc_event_t event;\n\n    /* Construct the event */\n    if( event_status == EventDidHappen )\n    {\n        event.type = libvlc_MediaListItemAdded;\n        event.u.media_list_item_added.item = p_md;\n        event.u.media_list_item_added.index = index;\n    }\n    else /* if( event_status == EventWillHappen ) */\n    {\n        event.type = libvlc_MediaListWillAddItem;\n        event.u.media_list_will_add_item.item = p_md;\n        event.u.media_list_will_add_item.index = index;\n    }\n\n    /* Send the event */\n    libvlc_event_send( &p_mlist->event_manager, &event );\n}", "path": "vlc/lib/media_list.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "videolan/vlc", "stars": 12699, "license": "gpl-2.0", "language": "c", "size": 531455}
{"docstring": "/**************************************************************************\n *       libvlc_media_list_add_media (Public)\n *\n * Lock should be held when entering.\n **************************************************************************/\n", "func_signal": "int libvlc_media_list_add_media( libvlc_media_list_t * p_mlist,\n                                 libvlc_media_t * p_md )", "code": "{\n    if( !mlist_is_writable(p_mlist) )\n        return -1;\n    libvlc_media_list_internal_add_media( p_mlist, p_md );\n    return 0;\n}", "path": "vlc/lib/media_list.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "videolan/vlc", "stars": 12699, "license": "gpl-2.0", "language": "c", "size": 531455}
{"docstring": "/**************************************************************************\n *       libvlc_media_list_release (Public)\n *\n * Release an object.\n **************************************************************************/\n", "func_signal": "void libvlc_media_list_release( libvlc_media_list_t * p_mlist )", "code": "{\n    if( !vlc_atomic_rc_dec( &p_mlist->rc ) )\n        return;\n\n    /* Refcount null, time to free */\n\n    libvlc_event_manager_destroy( &p_mlist->event_manager );\n    libvlc_media_release( p_mlist->p_md );\n\n    for( size_t i = 0; i < vlc_array_count( &p_mlist->items ); i++ )\n    {\n        libvlc_media_t* p_md = vlc_array_item_at_index( &p_mlist->items, i );\n        libvlc_media_release( p_md );\n    }\n\n    vlc_array_clear( &p_mlist->items );\n\n    free( p_mlist );\n}", "path": "vlc/lib/media_list.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "videolan/vlc", "stars": 12699, "license": "gpl-2.0", "language": "c", "size": 531455}
{"docstring": "/**\n * Callback called to tell the size of the surface that should be available\n * to VLC to draw into.\n *\n * This is called outside of the UI thread (not the VLC rendering thread).\n */\n", "func_signal": "static bool Resize(struct render_context *ctx, unsigned width, unsigned height,\n                   IDirect3DDevice9 *vlc_device,\n                   libvlc_video_output_cfg_t *out)", "code": "{\n    HRESULT hr;\n    D3DDISPLAYMODE d3ddm;\n\n    hr = IDirect3D9Ex_GetAdapterDisplayMode(ctx->d3d, 0, &d3ddm);\n\n    /* create the output surface VLC will write to */\n    if (ctx->renderTexture)\n    {\n        IDirect3DTexture9_Release(ctx->renderTexture);\n        ctx->renderTexture = NULL;\n        ctx->sharedHandled = NULL;\n    }\n    if (ctx->sharedRenderTexture)\n    {\n        IDirect3DTexture9_Release(ctx->sharedRenderTexture);\n        ctx->sharedRenderTexture = NULL;\n    }\n    if (ctx->sharedRenderSurface)\n    {\n        IDirect3DSurface9_Release(ctx->sharedRenderSurface);\n        ctx->sharedRenderSurface = NULL;\n    }\n    /* the device to use may have changed */\n    if (ctx->libvlc_d3d)\n    {\n        IDirect3DDevice9_Release(ctx->libvlc_d3d);\n    }\n    ctx->libvlc_d3d = vlc_device;\n    IDirect3DDevice9_AddRef(ctx->libvlc_d3d);\n\n    /* texture we can use on our device */\n    hr = IDirect3DDevice9_CreateTexture(ctx->d3ddev, width, height, 1, D3DUSAGE_RENDERTARGET,\n                                        d3ddm.Format,\n                                        D3DPOOL_DEFAULT,\n                                        &ctx->renderTexture,\n                                        &ctx->sharedHandled);\n    if (FAILED(hr))\n        return false;\n\n    /* texture/surface that is set as the render target for libvlc on its device */\n    hr = IDirect3DDevice9_CreateTexture(ctx->libvlc_d3d, width, height, 1, D3DUSAGE_RENDERTARGET,\n                                        d3ddm.Format,\n                                        D3DPOOL_DEFAULT,\n                                        &ctx->sharedRenderTexture,\n                                        &ctx->sharedHandled);\n    if (FAILED(hr))\n        return false;\n\n    hr = IDirect3DTexture9_GetSurfaceLevel(ctx->sharedRenderTexture, 0, &ctx->sharedRenderSurface);\n    if (FAILED(hr))\n        return false;\n\n    hr = IDirect3DDevice9_SetRenderTarget(ctx->libvlc_d3d, 0, ctx->sharedRenderSurface);\n    if (FAILED(hr)) return false;\n\n    out->d3d9_format    = d3ddm.Format;\n    out->full_range     = true;\n    out->colorspace     = libvlc_video_colorspace_BT709;\n    out->primaries      = libvlc_video_primaries_BT709;\n    out->transfer       = libvlc_video_transfer_func_SRGB;\n\n    return true;\n}", "path": "vlc/doc/libvlc/d3d9_player.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "videolan/vlc", "stars": 12699, "license": "gpl-2.0", "language": "c", "size": 531455}
{"docstring": "/**************************************************************************\n *       static mlist_is_writable (private)\n **************************************************************************/\n", "func_signal": "static inline\nbool mlist_is_writable( libvlc_media_list_t *p_mlist )", "code": "{\n    if( !p_mlist||p_mlist->b_read_only )\n    {\n        /* We are read-only from user side */\n        libvlc_printerr( \"Attempt to write a read-only media list\" );\n        return false;\n    }\n    return true;\n}", "path": "vlc/lib/media_list.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "videolan/vlc", "stars": 12699, "license": "gpl-2.0", "language": "c", "size": 531455}
{"docstring": "/**\n * Callback called just before VLC starts/finishes drawing the video.\n *\n * Set the surface VLC will render to (could be the backbuffer if nothing else\n * needs to be displayed). And then call BeginScene().\n *\n * This is called outside of the UI thread (in the VLC rendering thread).\n */\n", "func_signal": "static bool StartRendering_cb( void *opaque, bool enter )", "code": "{\n    struct render_context *ctx = opaque;\n    if ( enter )\n    {\n        /* we already set the RenderTarget on the IDirect3DDevice9 */\n        return true;\n    }\n\n    /* VLC has finished preparing drawning on our surface, we need do the drawing now\n       so the surface is finished rendering when Swap() is called to do our own\n       rendering */\n    IDirect3DDevice9_Present(ctx->libvlc_d3d, NULL, NULL, NULL, NULL);\n    return true;\n}", "path": "vlc/doc/libvlc/d3d9_player.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "videolan/vlc", "stars": 12699, "license": "gpl-2.0", "language": "c", "size": 531455}
{"docstring": "/**************************************************************************\n *       media (Public)\n *\n * If this media_list comes is a media's subitems,\n * This holds the corresponding media.\n * This md is also seen as the information holder for the media_list.\n * Indeed a media_list can have meta information through this\n * media.\n **************************************************************************/\n", "func_signal": "libvlc_media_t *\nlibvlc_media_list_media( libvlc_media_list_t * p_mlist )", "code": "{\n    libvlc_media_t *p_md;\n\n    vlc_mutex_lock( &p_mlist->object_lock );\n    p_md = p_mlist->p_internal_md ? p_mlist->p_internal_md : p_mlist->p_md;\n    if( p_md )\n        libvlc_media_retain( p_md );\n    vlc_mutex_unlock( &p_mlist->object_lock );\n\n    return p_md;\n}", "path": "vlc/lib/media_list.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "videolan/vlc", "stars": 12699, "license": "gpl-2.0", "language": "c", "size": 531455}
{"docstring": "/**************************************************************************\n *       libvlc_media_list_index_of_item (Public)\n *\n * Lock should be held when entering.\n * Warning: this function returns the first matching item.\n **************************************************************************/\n", "func_signal": "int libvlc_media_list_index_of_item( libvlc_media_list_t * p_mlist,\n                                     libvlc_media_t * p_searched_md )", "code": "{\n    int idx = vlc_array_index_of_item( &p_mlist->items, p_searched_md );\n    if( idx == -1 )\n        libvlc_printerr( \"Media not found\" );\n\n    return idx;\n}", "path": "vlc/lib/media_list.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "videolan/vlc", "stars": 12699, "license": "gpl-2.0", "language": "c", "size": 531455}
{"docstring": "/**************************************************************************\n *       set_media (Public)\n **************************************************************************/\n", "func_signal": "void libvlc_media_list_set_media( libvlc_media_list_t * p_mlist,\n                                  libvlc_media_t * p_md )", "code": "{\n    vlc_mutex_lock( &p_mlist->object_lock );\n    if( p_mlist->p_internal_md || !mlist_is_writable(p_mlist) )\n    {\n        vlc_mutex_unlock( &p_mlist->object_lock );\n        return;\n    }\n    libvlc_media_release( p_mlist->p_md );\n    libvlc_media_retain( p_md );\n    p_mlist->p_md = p_md;\n    vlc_mutex_unlock( &p_mlist->object_lock );\n}", "path": "vlc/lib/media_list.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "videolan/vlc", "stars": 12699, "license": "gpl-2.0", "language": "c", "size": 531455}
{"docstring": "/* LibVLC internal version */\n", "func_signal": "void libvlc_media_list_internal_add_media( libvlc_media_list_t * p_mlist,\n                                           libvlc_media_t * p_md )", "code": "{\n    libvlc_media_retain( p_md );\n\n    notify_item_addition( p_mlist, p_md, vlc_array_count( &p_mlist->items ),\n                          EventWillHappen );\n    vlc_array_append_or_abort( &p_mlist->items, p_md );\n    notify_item_addition( p_mlist, p_md, vlc_array_count( &p_mlist->items )-1,\n                          EventDidHappen );\n}", "path": "vlc/lib/media_list.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "videolan/vlc", "stars": 12699, "license": "gpl-2.0", "language": "c", "size": 531455}
{"docstring": "/**\n * Get the monotonic time (CLOCK_MONOTONIC)\n * \n * Calculates a monotically incrasing time since system boot\n * that continues to increment when the system is asleep.\n * \n * Warnings to everyone trying to simplify this:\n * - Using mach_continuous_time is not equivalent to this, see\n *   the darwin manpage about CLOCK_MONOTONIC_RAW for an explanation.\n * - Using mach_absolute_time is not equivalent to this, as it does\n *   not continue to increment when the system is asleep.\n * - The boot time is queried twice in a loop and only used if both\n *   match. This is done to detect if the boot time change since we\n *   obtained the current time of day, as the boot time can change\n *   when the system wallclock is adjusted, as that will adjust the\n *   boot time accordingly.\n *\n * \\param[out]  tv   Timeval struct to write the monotonic time to\n *\n * \\return 0 on success, else -1 and errno set\n */\n", "func_signal": "static int vlc__get_monotonic(struct timeval *tv)", "code": "{\n    int ret;\n    struct timeval currenttime;\n    struct timeval boottime_begin;\n    struct timeval boottime_end;\n\n    do {\n        ret = vlc__get_system_boottime(&boottime_begin);\n        if (ret != 0)\n            return ret;\n\n        ret = gettimeofday(&currenttime, NULL);\n        if (ret != 0)\n            return ret;\n\n        ret = vlc__get_system_boottime(&boottime_end);\n        if (ret != 0)\n            return ret;\n    } while (timercmp(&boottime_begin, &boottime_end, !=));\n\n    timersub(&currenttime, &boottime_begin, tv);\n    return 0;\n}", "path": "vlc/compat/clock_gettime.c", "commit_date": "2020-03-24 00:00:00", "repo_name": "videolan/vlc", "stars": 12699, "license": "gpl-2.0", "language": "c", "size": 531455}
{"docstring": "/**************************************************************************\n *       libvlc_media_list_remove_index (Public)\n *\n * Lock should be held when entering.\n **************************************************************************/\n", "func_signal": "int libvlc_media_list_remove_index( libvlc_media_list_t * p_mlist,\n                                     int index )", "code": "{\n    if( !mlist_is_writable(p_mlist) )\n        return -1;\n    return libvlc_media_list_internal_remove_index( p_mlist, index );\n}", "path": "vlc/lib/media_list.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "videolan/vlc", "stars": 12699, "license": "gpl-2.0", "language": "c", "size": 531455}
{"docstring": "/**\n * Get the absolute time at which the system was booted\n * \n * This time is changed whenever the clock is adjusted to\n * correctly reflect the boot time with the adjusted clock,\n * so just querying it once and reusing the value is not safe.\n *\n * \\param[out]  tv   Timeval struct to write the boottime to\n * \n * \\note\n * The boot time only has microsecond precision\n *\n * \\return 0 on success, else -1 and errno set\n */\n", "func_signal": "static int vlc__get_system_boottime(struct timeval *tv)", "code": "{\n    int ret = sysctl((int[]){ CTL_KERN, KERN_BOOTTIME }, 2,\n                     tv, &(size_t){ sizeof(*tv) }, NULL, 0);\n\n    if (ret != 0)\n        return errno;\n\n    return 0;\n}", "path": "vlc/compat/clock_gettime.c", "commit_date": "2020-03-24 00:00:00", "repo_name": "videolan/vlc", "stars": 12699, "license": "gpl-2.0", "language": "c", "size": 531455}
{"docstring": "/* LibVLC internal version */\n", "func_signal": "void libvlc_media_list_internal_insert_media( libvlc_media_list_t * p_mlist,\n                                              libvlc_media_t * p_md,\n                                              int index )", "code": "{\n    libvlc_media_retain( p_md );\n\n    notify_item_addition( p_mlist, p_md, index, EventWillHappen );\n    vlc_array_insert_or_abort( &p_mlist->items, p_md, index );\n    notify_item_addition( p_mlist, p_md, index, EventDidHappen );\n}", "path": "vlc/lib/media_list.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "videolan/vlc", "stars": 12699, "license": "gpl-2.0", "language": "c", "size": 531455}
{"docstring": "/* ################################################################\n * #\n * # Default ACL access\n * #\n * ################################################################ */\n", "func_signal": "static int dynsec__set_default_acl_access(int argc, char *argv[], cJSON *j_command)", "code": "{\n\tchar *acltype, *access;\n\tcJSON *j_acls, *j_acl;\n\n\tif(argc == 2){\n\t\tacltype = argv[0];\n\t\taccess = argv[1];\n\t}else{\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\n\tif(strcasecmp(acltype, \"publishClientSend\")\n\t\t\t&& strcasecmp(acltype, \"publishClientReceive\")\n\t\t\t&& strcasecmp(acltype, \"subscribe\")\n\t\t\t&& strcasecmp(acltype, \"unsubscribe\")){\n\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\n\tif(strcasecmp(access, \"allow\") && strcasecmp(access, \"deny\")){\n\t\tfprintf(stderr, \"Error: access must be \\\"allow\\\" or \\\"deny\\\".\\n\");\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\n\tif(cJSON_AddStringToObject(j_command, \"command\", \"setDefaultACLAccess\") == NULL\n\t\t\t|| (j_acls = cJSON_AddArrayToObject(j_command, \"acls\")) == NULL\n\t\t\t){\n\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\n\tj_acl = cJSON_CreateObject();\n\tif(j_acl == NULL){\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\tcJSON_AddItemToArray(j_acls, j_acl);\n\tif(cJSON_AddStringToObject(j_acl, \"acltype\", acltype) == NULL\n\t\t\t|| cJSON_AddStringToObject(j_acl, \"access\", access) == NULL\n\t\t\t){\n\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\n\treturn MOSQ_ERR_SUCCESS;\n}", "path": "mosquitto/apps/mosquitto_ctrl/dynsec.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "eclipse/mosquitto", "stars": 8219, "license": "other", "language": "c", "size": 15382}
{"docstring": "/* ################################################################\n * #\n * # Utility functions\n * #\n * ################################################################ */\n", "func_signal": "static int client_cmp(void *a, void *b)", "code": "{\n\tstruct dynsec__client *client_a = a;\n\tstruct dynsec__client *client_b = b;\n\n\treturn strcmp(client_a->username, client_b->username);\n}", "path": "mosquitto/plugins/dynamic-security/clients.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "eclipse/mosquitto", "stars": 8219, "license": "other", "language": "c", "size": 15382}
{"docstring": "/* Convert %25 -> %, %3a, %3A -> :, %40 -> @ */\n", "func_signal": "static int mosquitto__urldecode(char *str)", "code": "{\n\tint i, j;\n\tsize_t len;\n\tif(!str) return 0;\n\n\tif(!strchr(str, '%')) return 0;\n\n\tlen = strlen(str);\n\tfor(i=0; i<len; i++){\n\t\tif(str[i] == '%'){\n\t\t\tif(i+2 >= len){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif(str[i+1] == '2' && str[i+2] == '5'){\n\t\t\t\tstr[i] = '%';\n\t\t\t\tlen -= 2;\n\t\t\t\tfor(j=i+1; j<len; j++){\n\t\t\t\t\tstr[j] = str[j+2];\n\t\t\t\t}\n\t\t\t\tstr[j] = '\\0';\n\t\t\t}else if(str[i+1] == '3' && (str[i+2] == 'A' || str[i+2] == 'a')){\n\t\t\t\tstr[i] = ':';\n\t\t\t\tlen -= 2;\n\t\t\t\tfor(j=i+1; j<len; j++){\n\t\t\t\t\tstr[j] = str[j+2];\n\t\t\t\t}\n\t\t\t\tstr[j] = '\\0';\n\t\t\t}else if(str[i+1] == '4' && str[i+2] == '0'){\n\t\t\t\tstr[i] = ':';\n\t\t\t\tlen -= 2;\n\t\t\t\tfor(j=i+1; j<len; j++){\n\t\t\t\t\tstr[j] = str[j+2];\n\t\t\t\t}\n\t\t\t\tstr[j] = '\\0';\n\t\t\t}else{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}", "path": "mosquitto/client/client_shared.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "eclipse/mosquitto", "stars": 8219, "license": "other", "language": "c", "size": 15382}
{"docstring": "/* Callback called when the client receives a CONNACK message from the broker. */\n", "func_signal": "void on_connect(struct mosquitto *mosq, void *obj, int reason_code)", "code": "{\n\t/* Print out the connection result. mosquitto_connack_string() produces an\n\t * appropriate string for MQTT v3.x clients, the equivalent for MQTT v5.0\n\t * clients is mosquitto_reason_string().\n\t */\n\tprintf(\"on_connect: %s\\n\", mosquitto_connack_string(reason_code));\n\tif(reason_code != 0){\n\t\t/* If the connection fails for any reason, we don't want to keep on\n\t\t * retrying in this example, so disconnect. Without this, the client\n\t\t * will attempt to reconnect. */\n\t\tmosquitto_disconnect(mosq);\n\t}\n\n\t/* You may wish to set a flag here to indicate to your application that the\n\t * client is now connected. */\n}", "path": "mosquitto/examples/publish/basic-1.c", "commit_date": "2019-12-12 00:00:00", "repo_name": "eclipse/mosquitto", "stars": 8219, "license": "other", "language": "c", "size": 15382}
{"docstring": "/* ################################################################\n * #\n * # Username/password check\n * #\n * ################################################################ */\n", "func_signal": "static int memcmp_const(const void *a, const void *b, size_t len)", "code": "{\n\tsize_t i;\n\tint rc = 0;\n\n\tif(!a || !b) return 1;\n\n\tfor(i=0; i<len; i++){\n\t\tif( ((char *)a)[i] != ((char *)b)[i] ){\n\t\t\trc = 1;\n\t\t}\n\t}\n\treturn rc;\n}", "path": "mosquitto/plugins/dynamic-security/auth.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "eclipse/mosquitto", "stars": 8219, "license": "other", "language": "c", "size": 15382}
{"docstring": "/* mosquitto_ctrl dynsec init <filename> <admin-user> <admin-password> [role-name] */\n", "func_signal": "int dynsec_init(int argc, char *argv[])", "code": "{\n\tchar *filename;\n\tchar *admin_user;\n\tchar *admin_password;\n\tchar *json_str;\n\tcJSON *tree;\n\tFILE *fptr;\n\tchar prompt[200], verify_prompt[200];\n\tchar password[200];\n\tint rc;\n\n\tif(argc < 2){\n\t\tfprintf(stderr, \"dynsec init: Not enough arguments - filename, or admin-user missing.\\n\");\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\n\tif(argc > 3){\n\t\tfprintf(stderr, \"dynsec init: Too many arguments.\\n\");\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\n\tfilename = argv[0];\n\tadmin_user = argv[1];\n\n\tif(argc == 3){\n\t\tadmin_password = argv[2];\n\t}else{\n\t\tsnprintf(prompt, sizeof(prompt), \"New password for %s: \", admin_user);\n\t\tsnprintf(verify_prompt, sizeof(verify_prompt), \"Reenter password for %s: \", admin_user);\n\t\trc = get_password(prompt, verify_prompt, false, password, sizeof(password));\n\t\tif(rc){\n\t\t\tfprintf(stderr, \"Error getting password.\\n\");\n\t\t\tmosquitto_lib_cleanup();\n\t\t\treturn 1;\n\t\t}\n\t\tadmin_password = password;\n\t}\n\n\tfptr = fopen(filename, \"rb\");\n\tif(fptr){\n\t\tfclose(fptr);\n\t\tfprintf(stderr, \"dynsec init: '%s' already exists. Remove the file or use a different location..\\n\", filename);\n\t\treturn -1;\n\t}\n\n\ttree = init_create(admin_user, admin_password, \"admin\");\n\tif(tree == NULL){\n\t\tfprintf(stderr, \"dynsec init: Out of memory.\\n\");\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\tjson_str = cJSON_Print(tree);\n\tcJSON_Delete(tree);\n\n\tfptr = fopen(filename, \"wb\");\n\tif(fptr){\n\t\tfprintf(fptr, \"%s\", json_str);\n\t\tfree(json_str);\n\t\tfclose(fptr);\n\t}else{\n\t\tfree(json_str);\n\t\tfprintf(stderr, \"dynsec init: Unable to open '%s' for writing.\\n\", filename);\n\t\treturn -1;\n\t}\n\n\tprintf(\"The client '%s' has been created in the file '%s'.\\n\", admin_user, filename);\n\tprintf(\"This client is configured to allow you to administer the dynamic security plugin only.\\n\");\n\tprintf(\"It does not have access to publish messages to normal topics.\\n\");\n\tprintf(\"You should create your application clients to do that, for example:\\n\");\n\tprintf(\"   mosquitto_ctrl <connect options> dynsec createClient <username>\\n\");\n\tprintf(\"   mosquitto_ctrl <connect options> dynsec createRole <rolename>\\n\");\n\tprintf(\"   mosquitto_ctrl <connect options> dynsec addRoleACL <rolename> publishClientSend my/topic [priority]\\n\");\n\tprintf(\"   mosquitto_ctrl <connect options> dynsec addClientRole <username> <rolename> [priority]\\n\");\n\tprintf(\"See https://mosquitto.org/documentation/dynamic-security/ for details of all commands.\\n\");\n\n\treturn -1; /* Suppress client connection */\n}", "path": "mosquitto/apps/mosquitto_ctrl/dynsec.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "eclipse/mosquitto", "stars": 8219, "license": "other", "language": "c", "size": 15382}
{"docstring": "/* Check that a topic used for publishing is valid.\n * Search for + or # in a topic. Return MOSQ_ERR_INVAL if found.\n * Also returns MOSQ_ERR_INVAL if the topic string is too long.\n * Returns MOSQ_ERR_SUCCESS if everything is fine.\n */\n", "func_signal": "int mosquitto_pub_topic_check(const char *str)", "code": "{\n\tint len = 0;\n#ifdef WITH_BROKER\n\tint hier_count = 0;\n#endif\n\twhile(str && str[0]){\n\t\tif(str[0] == '+' || str[0] == '#'){\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n#ifdef WITH_BROKER\n\t\telse if(str[0] == '/'){\n\t\t\thier_count++;\n\t\t}\n#endif\n\t\tlen++;\n\t\tstr = &str[1];\n\t}\n\tif(len > 65535) return MOSQ_ERR_INVAL;\n#ifdef WITH_BROKER\n\tif(hier_count > TOPIC_HIERARCHY_LIMIT) return MOSQ_ERR_INVAL;\n#endif\n\n\treturn MOSQ_ERR_SUCCESS;\n}", "path": "mosquitto/lib/util_topic.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "eclipse/mosquitto", "stars": 8219, "license": "other", "language": "c", "size": 15382}
{"docstring": "/* ################################################################\n * #\n * # Payload callback\n * #\n * ################################################################ */\n", "func_signal": "static void print_list(cJSON *j_response, const char *arrayname, const char *keyname)", "code": "{\n\tcJSON *j_data, *j_array, *j_elem, *j_name;\n\n\tj_data = cJSON_GetObjectItem(j_response, \"data\");\n\tif(j_data == NULL){\n\t\tfprintf(stderr, \"Error: Invalid response from server.\\n\");\n\t\treturn;\n\t}\n\n\tj_array = cJSON_GetObjectItem(j_data, arrayname);\n\tif(j_array == NULL || !cJSON_IsArray(j_array)){\n\t\tfprintf(stderr, \"Error: Invalid response from server.\\n\");\n\t\treturn;\n\t}\n\n\tcJSON_ArrayForEach(j_elem, j_array){\n\t\tif(cJSON_IsObject(j_elem)){\n\t\t\tj_name = cJSON_GetObjectItem(j_elem, keyname);\n\t\t\tif(j_name && cJSON_IsString(j_name)){\n\t\t\t\tprintf(\"%s\\n\", j_name->valuestring);\n\t\t\t}\n\t\t}else if(cJSON_IsString(j_elem)){\n\t\t\tprintf(\"%s\\n\", j_elem->valuestring);\n\t\t}\n\t}\n}", "path": "mosquitto/apps/mosquitto_ctrl/dynsec.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "eclipse/mosquitto", "stars": 8219, "license": "other", "language": "c", "size": 15382}
{"docstring": "/* Called on reconnect to set outgoing messages to a sensible state and force a\n * retry, and to set incoming messages to expect an appropriate retry. */\n", "func_signal": "int db__message_reconnect_reset_outgoing(struct mosquitto *context)", "code": "{\n\tstruct mosquitto_client_msg *msg, *tmp;\n\n\tcontext->msgs_out.msg_bytes = 0;\n\tcontext->msgs_out.msg_bytes12 = 0;\n\tcontext->msgs_out.msg_count = 0;\n\tcontext->msgs_out.msg_count12 = 0;\n\tcontext->msgs_out.inflight_quota = context->msgs_out.inflight_maximum;\n\n\tDL_FOREACH_SAFE(context->msgs_out.inflight, msg, tmp){\n\t\tcontext->msgs_out.msg_count++;\n\t\tcontext->msgs_out.msg_bytes += msg->store->payloadlen;\n\t\tif(msg->qos > 0){\n\t\t\tcontext->msgs_out.msg_count12++;\n\t\t\tcontext->msgs_out.msg_bytes12 += msg->store->payloadlen;\n\t\t\tutil__decrement_send_quota(context);\n\t\t}\n\n\t\tswitch(msg->qos){\n\t\t\tcase 0:\n\t\t\t\tmsg->state = mosq_ms_publish_qos0;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tmsg->state = mosq_ms_publish_qos1;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif(msg->state == mosq_ms_wait_for_pubcomp){\n\t\t\t\t\tmsg->state = mosq_ms_resend_pubrel;\n\t\t\t\t}else{\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* Messages received when the client was disconnected are put\n\t * in the mosq_ms_queued state. If we don't change them to the\n\t * appropriate \"publish\" state, then the queued messages won't\n\t * get sent until the client next receives a message - and they\n\t * will be sent out of order.\n\t */\n\tDL_FOREACH_SAFE(context->msgs_out.queued, msg, tmp){\n\t\tcontext->msgs_out.msg_count++;\n\t\tcontext->msgs_out.msg_bytes += msg->store->payloadlen;\n\t\tif(msg->qos > 0){\n\t\t\tcontext->msgs_out.msg_count12++;\n\t\t\tcontext->msgs_out.msg_bytes12 += msg->store->payloadlen;\n\t\t}\n\t\tif(db__ready_for_flight(&context->msgs_out, msg->qos)){\n\t\t\tswitch(msg->qos){\n\t\t\t\tcase 0:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos2;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdb__message_dequeue_first(context, &context->msgs_out);\n\t\t}\n\t}\n\n\treturn MOSQ_ERR_SUCCESS;\n}", "path": "mosquitto/src/database.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "eclipse/mosquitto", "stars": 8219, "license": "other", "language": "c", "size": 15382}
{"docstring": "/* This function pretends to read some data from a sensor and publish it.*/\n", "func_signal": "void publish_sensor_data(struct mosquitto *mosq)", "code": "{\n\tchar payload[20];\n\tint temp;\n\tint rc;\n\n\t/* Get our pretend data */\n\ttemp = get_temperature();\n\t/* Print it to a string for easy human reading - payload format is highly\n\t * application dependent. */\n\tsnprintf(payload, sizeof(payload), \"%d\", temp);\n\n\t/* Publish the message\n\t * mosq - our client instance\n\t * *mid = NULL - we don't want to know what the message id for this message is\n\t * topic = \"example/temperature\" - the topic on which this message will be published\n\t * payloadlen = strlen(payload) - the length of our payload in bytes\n\t * payload - the actual payload\n\t * qos = 2 - publish with QoS 2 for this example\n\t * retain = false - do not use the retained message feature for this message\n\t */\n\trc = mosquitto_publish(mosq, NULL, \"example/temperature\", strlen(payload), payload, 2, false);\n\tif(rc != MOSQ_ERR_SUCCESS){\n\t\tfprintf(stderr, \"Error publishing: %s\\n\", mosquitto_strerror(rc));\n\t}\n}", "path": "mosquitto/examples/publish/basic-1.c", "commit_date": "2019-12-12 00:00:00", "repo_name": "eclipse/mosquitto", "stars": 8219, "license": "other", "language": "c", "size": 15382}
{"docstring": "/* Called on reconnect to set incoming messages to expect an appropriate retry. */\n", "func_signal": "int db__message_reconnect_reset_incoming(struct mosquitto *context)", "code": "{\n\tstruct mosquitto_client_msg *msg, *tmp;\n\n\tcontext->msgs_in.msg_bytes = 0;\n\tcontext->msgs_in.msg_bytes12 = 0;\n\tcontext->msgs_in.msg_count = 0;\n\tcontext->msgs_in.msg_count12 = 0;\n\tcontext->msgs_in.inflight_quota = context->msgs_in.inflight_maximum;\n\n\tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n\t\tcontext->msgs_in.msg_count++;\n\t\tcontext->msgs_in.msg_bytes += msg->store->payloadlen;\n\t\tif(msg->qos > 0){\n\t\t\tcontext->msgs_in.msg_count12++;\n\t\t\tcontext->msgs_in.msg_bytes12 += msg->store->payloadlen;\n\t\t\tutil__decrement_receive_quota(context);\n\t\t}\n\n\t\tif(msg->qos != 2){\n\t\t\t/* Anything <QoS 2 can be completely retried by the client at\n\t\t\t * no harm. */\n\t\t\tdb__message_remove(&context->msgs_in, msg);\n\t\t}else{\n\t\t\t/* Message state can be preserved here because it should match\n\t\t\t * whatever the client has got. */\n\t\t}\n\t}\n\n\t/* Messages received when the client was disconnected are put\n\t * in the mosq_ms_queued state. If we don't change them to the\n\t * appropriate \"publish\" state, then the queued messages won't\n\t * get sent until the client next receives a message - and they\n\t * will be sent out of order.\n\t */\n\tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n\t\tcontext->msgs_in.msg_count++;\n\t\tcontext->msgs_in.msg_bytes += msg->store->payloadlen;\n\t\tif(msg->qos > 0){\n\t\t\tcontext->msgs_in.msg_count12++;\n\t\t\tcontext->msgs_in.msg_bytes12 += msg->store->payloadlen;\n\t\t}\n\t\tif(db__ready_for_flight(&context->msgs_in, msg->qos)){\n\t\t\tswitch(msg->qos){\n\t\t\t\tcase 0:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos2;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdb__message_dequeue_first(context, &context->msgs_in);\n\t\t}\n\t}\n\n\treturn MOSQ_ERR_SUCCESS;\n}", "path": "mosquitto/src/database.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "eclipse/mosquitto", "stars": 8219, "license": "other", "language": "c", "size": 15382}
{"docstring": "/* Check that a topic used for subscriptions is valid.\n * Search for + or # in a topic, check they aren't in invalid positions such as\n * foo/#/bar, foo/+bar or foo/bar#.\n * Return MOSQ_ERR_INVAL if invalid position found.\n * Also returns MOSQ_ERR_INVAL if the topic string is too long.\n * Returns MOSQ_ERR_SUCCESS if everything is fine.\n */\n", "func_signal": "int mosquitto_sub_topic_check(const char *str)", "code": "{\n\tchar c = '\\0';\n\tint len = 0;\n#ifdef WITH_BROKER\n\tint hier_count = 0;\n#endif\n\n\twhile(str && str[0]){\n\t\tif(str[0] == '+'){\n\t\t\tif((c != '\\0' && c != '/') || (str[1] != '\\0' && str[1] != '/')){\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t}else if(str[0] == '#'){\n\t\t\tif((c != '\\0' && c != '/')  || str[1] != '\\0'){\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t}\n#ifdef WITH_BROKER\n\t\telse if(str[0] == '/'){\n\t\t\thier_count++;\n\t\t}\n#endif\n\t\tlen++;\n\t\tc = str[0];\n\t\tstr = &str[1];\n\t}\n\tif(len > 65535) return MOSQ_ERR_INVAL;\n#ifdef WITH_BROKER\n\tif(hier_count > TOPIC_HIERARCHY_LIMIT) return MOSQ_ERR_INVAL;\n#endif\n\n\treturn MOSQ_ERR_SUCCESS;\n}", "path": "mosquitto/lib/util_topic.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "eclipse/mosquitto", "stars": 8219, "license": "other", "language": "c", "size": 15382}
{"docstring": "/**\n * Is this context ready to take more in flight messages right now?\n * @param context the client context of interest\n * @param qos qos for the packet of interest\n * @return true if more in flight are allowed.\n */\n", "func_signal": "bool db__ready_for_flight(struct mosquitto_msg_data *msgs, int qos)", "code": "{\n\tbool valid_bytes;\n\tbool valid_count;\n\n\tif(msgs->inflight_maximum == 0 && db.config->max_inflight_bytes == 0){\n\t\treturn true;\n\t}\n\n\tif(qos == 0){\n\t\t/* Deliver QoS 0 messages unless the queue is already full.\n\t\t * For QoS 0 messages the choice is either \"inflight\" or dropped.\n\t\t * There is no queueing option, unless the client is offline and\n\t\t * queue_qos0_messages is enabled.\n\t\t */\n\t\tif(db.config->max_queued_messages == 0 && db.config->max_inflight_bytes == 0){\n\t\t\treturn true;\n\t\t}\n\t\tvalid_bytes = msgs->msg_bytes - db.config->max_inflight_bytes < db.config->max_queued_bytes;\n\t\tvalid_count = msgs->msg_count - msgs->inflight_maximum < db.config->max_queued_messages;\n\n\t\tif(db.config->max_queued_messages == 0){\n\t\t\treturn valid_bytes;\n\t\t}\n\t\tif(db.config->max_queued_bytes == 0){\n\t\t\treturn valid_count;\n\t\t}\n\t}else{\n\t\tvalid_bytes = msgs->msg_bytes12 < db.config->max_inflight_bytes;\n\t\tvalid_count = msgs->inflight_quota > 0;\n\n\t\tif(msgs->inflight_maximum == 0){\n\t\t\treturn valid_bytes;\n\t\t}\n\t\tif(db.config->max_inflight_bytes == 0){\n\t\t\treturn valid_count;\n\t\t}\n\t}\n\n\treturn valid_bytes && valid_count;\n}", "path": "mosquitto/src/database.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "eclipse/mosquitto", "stars": 8219, "license": "other", "language": "c", "size": 15382}
{"docstring": "/* Does a topic match a subscription? */\n", "func_signal": "int mosquitto_topic_matches_sub2(const char *sub, size_t sublen, const char *topic, size_t topiclen, bool *result)", "code": "{\n\tsize_t spos;\n\n\tUNUSED(sublen);\n\tUNUSED(topiclen);\n\n\tif(!result) return MOSQ_ERR_INVAL;\n\t*result = false;\n\n\tif(!sub || !topic || sub[0] == 0 || topic[0] == 0){\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\n\tif((sub[0] == '$' && topic[0] != '$')\n\t\t\t|| (topic[0] == '$' && sub[0] != '$')){\n\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n\n\tspos = 0;\n\n\twhile(sub[0] != 0){\n\t\tif(topic[0] == '+' || topic[0] == '#'){\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n\t\tif(sub[0] != topic[0] || topic[0] == 0){ /* Check for wildcard matches */\n\t\t\tif(sub[0] == '+'){\n\t\t\t\t/* Check for bad \"+foo\" or \"a/+foo\" subscription */\n\t\t\t\tif(spos > 0 && sub[-1] != '/'){\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}\n\t\t\t\t/* Check for bad \"foo+\" or \"foo+/a\" subscription */\n\t\t\t\tif(sub[1] != 0 && sub[1] != '/'){\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}\n\t\t\t\tspos++;\n\t\t\t\tsub++;\n\t\t\t\twhile(topic[0] != 0 && topic[0] != '/'){\n\t\t\t\t\tif(topic[0] == '+' || topic[0] == '#'){\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\ttopic++;\n\t\t\t\t}\n\t\t\t\tif(topic[0] == 0 && sub[0] == 0){\n\t\t\t\t\t*result = true;\n\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t\t}\n\t\t\t}else if(sub[0] == '#'){\n\t\t\t\t/* Check for bad \"foo#\" subscription */\n\t\t\t\tif(spos > 0 && sub[-1] != '/'){\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}\n\t\t\t\t/* Check for # not the final character of the sub, e.g. \"#foo\" */\n\t\t\t\tif(sub[1] != 0){\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}else{\n\t\t\t\t\twhile(topic[0] != 0){\n\t\t\t\t\t\tif(topic[0] == '+' || topic[0] == '#'){\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttopic++;\n\t\t\t\t\t}\n\t\t\t\t\t*result = true;\n\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t/* Check for e.g. foo/bar matching foo/+/# */\n\t\t\t\tif(topic[0] == 0\n\t\t\t\t\t\t&& spos > 0\n\t\t\t\t\t\t&& sub[-1] == '+'\n\t\t\t\t\t\t&& sub[0] == '/'\n\t\t\t\t\t\t&& sub[1] == '#')\n\t\t\t\t{\n\t\t\t\t\t*result = true;\n\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t\t}\n\n\t\t\t\t/* There is no match at this point, but is the sub invalid? */\n\t\t\t\twhile(sub[0] != 0){\n\t\t\t\t\tif(sub[0] == '#' && sub[1] != 0){\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tspos++;\n\t\t\t\t\tsub++;\n\t\t\t\t}\n\n\t\t\t\t/* Valid input, but no match */\n\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t}\n\t\t}else{\n\t\t\t/* sub[spos] == topic[tpos] */\n\t\t\tif(topic[1] == 0){\n\t\t\t\t/* Check for e.g. foo matching foo/# */\n\t\t\t\tif(sub[1] == '/'\n\t\t\t\t\t\t&& sub[2] == '#'\n\t\t\t\t\t\t&& sub[3] == 0){\n\t\t\t\t\t*result = true;\n\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspos++;\n\t\t\tsub++;\n\t\t\ttopic++;\n\t\t\tif(sub[0] == 0 && topic[0] == 0){\n\t\t\t\t*result = true;\n\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t}else if(topic[0] == 0 && sub[0] == '+' && sub[1] == 0){\n\t\t\t\tif(spos > 0 && sub[-1] != '/'){\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}\n\t\t\t\tspos++;\n\t\t\t\tsub++;\n\t\t\t\t*result = true;\n\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\tif((topic[0] != 0 || sub[0] != 0)){\n\t\t*result = false;\n\t}\n\twhile(topic[0] != 0){\n\t\tif(topic[0] == '+' || topic[0] == '#'){\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n\t\ttopic++;\n\t}\n\n\treturn MOSQ_ERR_SUCCESS;\n}", "path": "mosquitto/lib/util_topic.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "eclipse/mosquitto", "stars": 8219, "license": "other", "language": "c", "size": 15382}
{"docstring": "/* ################################################################\n * #\n * # Base64 encoding/decoding\n * #\n * ################################################################ */\n", "func_signal": "int dynsec_auth__base64_encode(unsigned char *in, int in_len, char **encoded)", "code": "{\n\tBIO *bmem, *b64;\n\tBUF_MEM *bptr;\n\n\tif(in_len < 0) return 1;\n\n\tb64 = BIO_new(BIO_f_base64());\n\tif(b64 == NULL) return 1;\n\n\tBIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);\n\tbmem = BIO_new(BIO_s_mem());\n\tif(bmem == NULL){\n\t\tBIO_free_all(b64);\n\t\treturn 1;\n\t}\n\tb64 = BIO_push(b64, bmem);\n\tBIO_write(b64, in, in_len);\n\tif(BIO_flush(b64) != 1){\n\t\tBIO_free_all(b64);\n\t\treturn 1;\n\t}\n\tBIO_get_mem_ptr(b64, &bptr);\n\t*encoded = mosquitto_malloc(bptr->length+1);\n\tif(!(*encoded)){\n\t\tBIO_free_all(b64);\n\t\treturn 1;\n\t}\n\tmemcpy(*encoded, bptr->data, bptr->length);\n\t(*encoded)[bptr->length] = '\\0';\n\tBIO_free_all(b64);\n\n\treturn 0;\n}", "path": "mosquitto/plugins/dynamic-security/auth.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "eclipse/mosquitto", "stars": 8219, "license": "other", "language": "c", "size": 15382}
{"docstring": "/* ################################################################\n * #\n * # Main\n * #\n * ################################################################ */\n", "func_signal": "int dynsec__main(int argc, char *argv[], struct mosq_ctrl *ctrl)", "code": "{\n\tint rc = -1;\n\tcJSON *j_tree;\n\tcJSON *j_commands, *j_command;\n\n\tif(!strcasecmp(argv[0], \"help\")){\n\t\tdynsec__print_usage();\n\t\treturn -1;\n\t}else if(!strcasecmp(argv[0], \"init\")){\n\t\treturn dynsec_init(argc-1, &argv[1]);\n\t}\n\n\t/* The remaining commands need a network connection and JSON command. */\n\n\tctrl->payload_callback = dynsec__payload_callback;\n\tctrl->request_topic = strdup(\"$CONTROL/dynamic-security/v1\");\n\tctrl->response_topic = strdup(\"$CONTROL/dynamic-security/v1/response\");\n\tif(ctrl->request_topic == NULL || ctrl->response_topic == NULL){\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\tj_tree = cJSON_CreateObject();\n\tif(j_tree == NULL) return MOSQ_ERR_NOMEM;\n\tj_commands = cJSON_AddArrayToObject(j_tree, \"commands\");\n\tif(j_commands == NULL){\n\t\tcJSON_Delete(j_tree);\n\t\tj_tree = NULL;\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\tj_command = cJSON_CreateObject();\n\tif(j_command == NULL){\n\t\tcJSON_Delete(j_tree);\n\t\tj_tree = NULL;\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\tcJSON_AddItemToArray(j_commands, j_command);\n\n\tif(!strcasecmp(argv[0], \"setDefaultACLAccess\")){\n\t\trc = dynsec__set_default_acl_access(argc-1, &argv[1], j_command);\n\t}else if(!strcasecmp(argv[0], \"getDefaultACLAccess\")){\n\t\trc = dynsec__get_default_acl_access(argc-1, &argv[1], j_command);\n\n\t}else if(!strcasecmp(argv[0], \"createClient\")){\n\t\trc = dynsec_client__create(argc-1, &argv[1], j_command);\n\t}else if(!strcasecmp(argv[0], \"deleteClient\")){\n\t\trc = dynsec_client__delete(argc-1, &argv[1], j_command);\n\t}else if(!strcasecmp(argv[0], \"getClient\")){\n\t\trc = dynsec_client__get(argc-1, &argv[1], j_command);\n\t}else if(!strcasecmp(argv[0], \"listClients\")){\n\t\trc = dynsec_client__list_all(argc-1, &argv[1], j_command);\n\t}else if(!strcasecmp(argv[0], \"setClientId\")){\n\t\trc = dynsec_client__set_id(argc-1, &argv[1], j_command);\n\t}else if(!strcasecmp(argv[0], \"setClientPassword\")){\n\t\trc = dynsec_client__set_password(argc-1, &argv[1], j_command);\n\t}else if(!strcasecmp(argv[0], \"addClientRole\")){\n\t\trc = dynsec_client__add_remove_role(argc-1, &argv[1], j_command, argv[0]);\n\t}else if(!strcasecmp(argv[0], \"removeClientRole\")){\n\t\trc = dynsec_client__add_remove_role(argc-1, &argv[1], j_command, argv[0]);\n\t}else if(!strcasecmp(argv[0], \"enableClient\")){\n\t\trc = dynsec_client__enable_disable(argc-1, &argv[1], j_command, argv[0]);\n\t}else if(!strcasecmp(argv[0], \"disableClient\")){\n\t\trc = dynsec_client__enable_disable(argc-1, &argv[1], j_command, argv[0]);\n\n\t}else if(!strcasecmp(argv[0], \"createGroup\")){\n\t\trc = dynsec_group__create(argc-1, &argv[1], j_command);\n\t}else if(!strcasecmp(argv[0], \"deleteGroup\")){\n\t\trc = dynsec_group__delete(argc-1, &argv[1], j_command);\n\t}else if(!strcasecmp(argv[0], \"getGroup\")){\n\t\trc = dynsec_group__get(argc-1, &argv[1], j_command);\n\t}else if(!strcasecmp(argv[0], \"listGroups\")){\n\t\trc = dynsec_group__list_all(argc-1, &argv[1], j_command);\n\t}else if(!strcasecmp(argv[0], \"addGroupRole\")){\n\t\trc = dynsec_group__add_remove_role(argc-1, &argv[1], j_command, argv[0]);\n\t}else if(!strcasecmp(argv[0], \"removeGroupRole\")){\n\t\trc = dynsec_group__add_remove_role(argc-1, &argv[1], j_command, argv[0]);\n\t}else if(!strcasecmp(argv[0], \"addGroupClient\")){\n\t\trc = dynsec_group__add_remove_client(argc-1, &argv[1], j_command, argv[0]);\n\t}else if(!strcasecmp(argv[0], \"removeGroupClient\")){\n\t\trc = dynsec_group__add_remove_client(argc-1, &argv[1], j_command, argv[0]);\n\t}else if(!strcasecmp(argv[0], \"setAnonymousGroup\")){\n\t\trc = dynsec_group__set_anonymous(argc-1, &argv[1], j_command);\n\t}else if(!strcasecmp(argv[0], \"getAnonymousGroup\")){\n\t\trc = dynsec_group__get_anonymous(argc-1, &argv[1], j_command);\n\n\t}else if(!strcasecmp(argv[0], \"createRole\")){\n\t\trc = dynsec_role__create(argc-1, &argv[1], j_command);\n\t}else if(!strcasecmp(argv[0], \"deleteRole\")){\n\t\trc = dynsec_role__delete(argc-1, &argv[1], j_command);\n\t}else if(!strcasecmp(argv[0], \"getRole\")){\n\t\trc = dynsec_role__get(argc-1, &argv[1], j_command);\n\t}else if(!strcasecmp(argv[0], \"listRoles\")){\n\t\trc = dynsec_role__list_all(argc-1, &argv[1], j_command);\n\t}else if(!strcasecmp(argv[0], \"addRoleACL\")){\n\t\trc = dynsec_role__add_acl(argc-1, &argv[1], j_command);\n\t}else if(!strcasecmp(argv[0], \"removeRoleACL\")){\n\t\trc = dynsec_role__remove_acl(argc-1, &argv[1], j_command);\n\n\t}else{\n\t\tfprintf(stderr, \"Command '%s' not recognised.\\n\", argv[0]);\n\t\treturn MOSQ_ERR_UNKNOWN;\n\t}\n\n\tif(rc == MOSQ_ERR_SUCCESS){\n\t\tctrl->payload = cJSON_PrintUnformatted(j_tree);\n\t\tcJSON_Delete(j_tree);\n\t\tif(ctrl->payload == NULL){\n\t\t\tfprintf(stderr, \"Error: Out of memory.\\n\");\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t}\n\treturn rc;\n}", "path": "mosquitto/apps/mosquitto_ctrl/dynsec.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "eclipse/mosquitto", "stars": 8219, "license": "other", "language": "c", "size": 15382}
{"docstring": "/* ################################################################\n * #\n * # Config file load and save\n * #\n * ################################################################ */\n", "func_signal": "int dynsec_clients__config_load(cJSON *tree)", "code": "{\n\tcJSON *j_clients, *j_client, *jtmp, *j_roles, *j_role;\n\tcJSON *j_salt, *j_password, *j_iterations;\n\tstruct dynsec__client *client;\n\tstruct dynsec__role *role;\n\tunsigned char *buf;\n\tint buf_len;\n\tint priority;\n\tint iterations;\n\n\tj_clients = cJSON_GetObjectItem(tree, \"clients\");\n\tif(j_clients == NULL){\n\t\treturn 0;\n\t}\n\n\tif(cJSON_IsArray(j_clients) == false){\n\t\treturn 1;\n\t}\n\n\tcJSON_ArrayForEach(j_client, j_clients){\n\t\tif(cJSON_IsObject(j_client) == true){\n\t\t\tclient = mosquitto_calloc(1, sizeof(struct dynsec__client));\n\t\t\tif(client == NULL){\n\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t}\n\n\t\t\t/* Username */\n\t\t\tjtmp = cJSON_GetObjectItem(j_client, \"username\");\n\t\t\tif(jtmp == NULL || !cJSON_IsString(jtmp)){\n\t\t\t\tmosquitto_free(client);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclient->username = mosquitto_strdup(jtmp->valuestring);\n\t\t\tif(client->username == NULL){\n\t\t\t\tmosquitto_free(client);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tjtmp = cJSON_GetObjectItem(j_client, \"disabled\");\n\t\t\tif(jtmp && cJSON_IsBool(jtmp)){\n\t\t\t\tclient->disabled = cJSON_IsTrue(jtmp);\n\t\t\t}\n\n\t\t\t/* Salt */\n\t\t\tj_salt = cJSON_GetObjectItem(j_client, \"salt\");\n\t\t\tj_password = cJSON_GetObjectItem(j_client, \"password\");\n\t\t\tj_iterations = cJSON_GetObjectItem(j_client, \"iterations\");\n\n\t\t\tif(j_salt && cJSON_IsString(j_salt) \n\t\t\t\t\t&& j_password && cJSON_IsString(j_password)\n\t\t\t\t\t&& j_iterations && cJSON_IsNumber(j_iterations)){\n\n\t\t\t\titerations = (int)j_iterations->valuedouble;\n\t\t\t\tif(iterations < 1){\n\t\t\t\t\tmosquitto_free(client->username);\n\t\t\t\t\tmosquitto_free(client);\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tclient->pw.iterations = iterations;\n\t\t\t\t}\n\n\t\t\t\tif(dynsec_auth__base64_decode(j_salt->valuestring, &buf, &buf_len) != MOSQ_ERR_SUCCESS\n\t\t\t\t\t\t|| buf_len != sizeof(client->pw.salt)){\n\n\t\t\t\t\tmosquitto_free(client->username);\n\t\t\t\t\tmosquitto_free(client);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmemcpy(client->pw.salt, buf, (size_t)buf_len);\n\t\t\t\tmosquitto_free(buf);\n\n\t\t\t\tif(dynsec_auth__base64_decode(j_password->valuestring, &buf, &buf_len) != MOSQ_ERR_SUCCESS\n\t\t\t\t\t\t|| buf_len != sizeof(client->pw.password_hash)){\n\n\t\t\t\t\tmosquitto_free(client->username);\n\t\t\t\t\tmosquitto_free(client);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmemcpy(client->pw.password_hash, buf, (size_t)buf_len);\n\t\t\t\tmosquitto_free(buf);\n\t\t\t\tclient->pw.valid = true;\n\t\t\t}else{\n\t\t\t\tclient->pw.valid = false;\n\t\t\t}\n\n\t\t\t/* Client id */\n\t\t\tjtmp = cJSON_GetObjectItem(j_client, \"clientid\");\n\t\t\tif(jtmp != NULL && cJSON_IsString(jtmp)){\n\t\t\t\tclient->clientid = mosquitto_strdup(jtmp->valuestring);\n\t\t\t\tif(client->clientid == NULL){\n\t\t\t\t\tmosquitto_free(client->username);\n\t\t\t\t\tmosquitto_free(client);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Text name */\n\t\t\tjtmp = cJSON_GetObjectItem(j_client, \"textname\");\n\t\t\tif(jtmp != NULL && cJSON_IsString(jtmp)){\n\t\t\t\tclient->text_name = mosquitto_strdup(jtmp->valuestring);\n\t\t\t\tif(client->text_name == NULL){\n\t\t\t\t\tmosquitto_free(client->clientid);\n\t\t\t\t\tmosquitto_free(client->username);\n\t\t\t\t\tmosquitto_free(client);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Text description */\n\t\t\tjtmp = cJSON_GetObjectItem(j_client, \"textdescription\");\n\t\t\tif(jtmp != NULL && cJSON_IsString(jtmp)){\n\t\t\t\tclient->text_description = mosquitto_strdup(jtmp->valuestring);\n\t\t\t\tif(client->text_description == NULL){\n\t\t\t\t\tmosquitto_free(client->text_name);\n\t\t\t\t\tmosquitto_free(client->clientid);\n\t\t\t\t\tmosquitto_free(client->username);\n\t\t\t\t\tmosquitto_free(client);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Roles */\n\t\t\tj_roles = cJSON_GetObjectItem(j_client, \"roles\");\n\t\t\tif(j_roles && cJSON_IsArray(j_roles)){\n\t\t\t\tcJSON_ArrayForEach(j_role, j_roles){\n\t\t\t\t\tif(cJSON_IsObject(j_role)){\n\t\t\t\t\t\tjtmp = cJSON_GetObjectItem(j_role, \"rolename\");\n\t\t\t\t\t\tif(jtmp && cJSON_IsString(jtmp)){\n\t\t\t\t\t\t\tjson_get_int(j_role, \"priority\", &priority, true, -1);\n\t\t\t\t\t\t\trole = dynsec_roles__find(jtmp->valuestring);\n\t\t\t\t\t\t\tdynsec_rolelist__client_add(client, role, priority);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tHASH_ADD_KEYPTR(hh, local_clients, client->username, strlen(client->username), client);\n\t\t}\n\t}\n\tHASH_SORT(local_clients, client_cmp);\n\n\treturn 0;\n}", "path": "mosquitto/plugins/dynamic-security/clients.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "eclipse/mosquitto", "stars": 8219, "license": "other", "language": "c", "size": 15382}
{"docstring": "/* ################################################################\n * #\n * # Password functions\n * #\n * ################################################################ */\n", "func_signal": "int dynsec_auth__pw_hash(struct dynsec__client *client, const char *password, unsigned char *password_hash, int password_hash_len, bool new_password)", "code": "{\n\tconst EVP_MD *digest;\n\tint iterations;\n\n\tif(new_password){\n\t\tif(RAND_bytes(client->pw.salt, sizeof(client->pw.salt)) != 1){\n\t\t\treturn MOSQ_ERR_UNKNOWN;\n\t\t}\n\t\titerations = PW_DEFAULT_ITERATIONS;\n\t}else{\n\t\titerations = client->pw.iterations;\n\t}\n\tif(iterations < 1){\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\tclient->pw.iterations = iterations;\n\n\tdigest = EVP_get_digestbyname(\"sha512\");\n\tif(!digest){\n\t\treturn MOSQ_ERR_UNKNOWN;\n\t}\n\n\treturn !PKCS5_PBKDF2_HMAC(password, (int)strlen(password),\n\t\t\tclient->pw.salt, sizeof(client->pw.salt), iterations,\n\t\t\tdigest, password_hash_len, password_hash);\n}", "path": "mosquitto/plugins/dynamic-security/auth.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "eclipse/mosquitto", "stars": 8219, "license": "other", "language": "c", "size": 15382}
{"docstring": "/* ################################################################\n * #\n * # Init\n * #\n * ################################################################ */\n", "func_signal": "static cJSON *init_add_acl_to_role(cJSON *j_acls, const char *type, const char *topic)", "code": "{\n\tcJSON *j_acl;\n\n\tj_acl = cJSON_CreateObject();\n\tif(j_acl == NULL) return NULL;\n\n\tif(cJSON_AddStringToObject(j_acl, \"acltype\", type) == NULL\n\t\t\t|| cJSON_AddStringToObject(j_acl, \"topic\", topic) == NULL\n\t\t\t|| cJSON_AddBoolToObject(j_acl, \"allow\", true) == NULL\n\t\t\t){\n\n\t\tcJSON_Delete(j_acl);\n\t\treturn NULL;\n\t}\n\tcJSON_AddItemToArray(j_acls, j_acl);\n\treturn j_acl;\n}", "path": "mosquitto/apps/mosquitto_ctrl/dynsec.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "eclipse/mosquitto", "stars": 8219, "license": "other", "language": "c", "size": 15382}
{"docstring": "/* Remove any queued messages that are no longer allowed through ACL,\n * assuming a possible change of username. */\n", "func_signal": "void connection_check_acl(struct mosquitto *context, struct mosquitto_client_msg **head)", "code": "{\n\tstruct mosquitto_client_msg *msg_tail, *tmp;\n\n\tDL_FOREACH_SAFE((*head), msg_tail, tmp){\n\t\tif(msg_tail->direction == mosq_md_out){\n\t\t\tif(mosquitto_acl_check(context, msg_tail->store->topic,\n\t\t\t\t\t\t\t\t   msg_tail->store->payloadlen, msg_tail->store->payload,\n\t\t\t\t\t\t\t\t   msg_tail->store->qos, msg_tail->store->retain, MOSQ_ACL_READ) != MOSQ_ERR_SUCCESS){\n\n\t\t\t\tDL_DELETE((*head), msg_tail);\n\t\t\t\tdb__msg_store_ref_dec(&msg_tail->store);\n\t\t\t\tmosquitto_property_free_all(&msg_tail->properties);\n\t\t\t\tmosquitto__free(msg_tail);\n\t\t\t}\n\t\t}\n\t}\n}", "path": "mosquitto/src/handle_connect.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "eclipse/mosquitto", "stars": 8219, "license": "other", "language": "c", "size": 15382}
{"docstring": "// Draw rectangle using rlgl OpenGL 1.1 style coding (translated to OpenGL 3.3 internally)\n", "func_signal": "static void DrawRectangleV(Vector2 position, Vector2 size, Color color)", "code": "{\n    rlBegin(RL_TRIANGLES);\n        rlColor4ub(color.r, color.g, color.b, color.a);\n\n        rlVertex2i(position.x, position.y);\n        rlVertex2i(position.x, position.y + size.y);\n        rlVertex2i(position.x + size.x, position.y + size.y);\n\n        rlVertex2i(position.x, position.y);\n        rlVertex2i(position.x + size.x, position.y + size.y);\n        rlVertex2i(position.x + size.x, position.y);\n    rlEnd();\n}", "path": "raylib/examples/others/rlgl_standalone.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "raysan5/raylib", "stars": 18133, "license": "zlib", "language": "c", "size": 394813}
{"docstring": "//------------------------------------------------------------------------------------\n// Program main entry point\n//------------------------------------------------------------------------------------\n", "func_signal": "int main(void)", "code": "{\n    // Initialization\n    //--------------------------------------------------------------------------------------\n    const int screenWidth = 800;\n    const int screenHeight = 450;\n\n    const float sunRadius = 4.0f;\n    const float earthRadius = 0.6f;\n    const float earthOrbitRadius = 8.0f;\n    const float moonRadius = 0.16f;\n    const float moonOrbitRadius = 1.5f;\n\n    InitWindow(screenWidth, screenHeight, \"raylib [models] example - rlgl module usage with push/pop matrix transformations\");\n\n    // Define the camera to look into our 3d world\n    Camera camera = { 0 };\n    camera.position = (Vector3){ 16.0f, 16.0f, 16.0f };\n    camera.target = (Vector3){ 0.0f, 0.0f, 0.0f };\n    camera.up = (Vector3){ 0.0f, 1.0f, 0.0f };\n    camera.fovy = 45.0f;\n    camera.type = CAMERA_PERSPECTIVE;\n\n    SetCameraMode(camera, CAMERA_FREE);\n\n    float rotationSpeed = 0.2f;         // General system rotation speed\n\n    float earthRotation = 0.0f;         // Rotation of earth around itself (days) in degrees\n    float earthOrbitRotation = 0.0f;    // Rotation of earth around the Sun (years) in degrees\n    float moonRotation = 0.0f;          // Rotation of moon around itself\n    float moonOrbitRotation = 0.0f;     // Rotation of moon around earth in degrees\n\n    SetTargetFPS(60);                   // Set our game to run at 60 frames-per-second\n    //--------------------------------------------------------------------------------------\n\n    // Main game loop\n    while (!WindowShouldClose())        // Detect window close button or ESC key\n    {\n        // Update\n        //----------------------------------------------------------------------------------\n        UpdateCamera(&camera);\n\n        earthRotation += (5.0f*rotationSpeed);\n        earthOrbitRotation += (365/360.0f*(5.0f*rotationSpeed)*rotationSpeed);\n        moonRotation += (2.0f*rotationSpeed);\n        moonOrbitRotation += (8.0f*rotationSpeed);\n        //----------------------------------------------------------------------------------\n\n        // Draw\n        //----------------------------------------------------------------------------------\n        BeginDrawing();\n\n            ClearBackground(RAYWHITE);\n\n            BeginMode3D(camera);\n\n                rlPushMatrix();\n                    rlScalef(sunRadius, sunRadius, sunRadius);          // Scale Sun\n                    DrawSphereBasic(GOLD);                              // Draw the Sun\n                rlPopMatrix();\n\n                rlPushMatrix();\n                    rlRotatef(earthOrbitRotation, 0.0f, 1.0f, 0.0f);    // Rotation for Earth orbit around Sun\n                    rlTranslatef(earthOrbitRadius, 0.0f, 0.0f);         // Translation for Earth orbit\n                    rlRotatef(-earthOrbitRotation, 0.0f, 1.0f, 0.0f);   // Rotation for Earth orbit around Sun inverted\n\n                    rlPushMatrix();\n                        rlRotatef(earthRotation, 0.25, 1.0, 0.0);       // Rotation for Earth itself\n                        rlScalef(earthRadius, earthRadius, earthRadius);// Scale Earth\n\n                        DrawSphereBasic(BLUE);                          // Draw the Earth\n                    rlPopMatrix();\n\n                    rlRotatef(moonOrbitRotation, 0.0f, 1.0f, 0.0f);     // Rotation for Moon orbit around Earth\n                    rlTranslatef(moonOrbitRadius, 0.0f, 0.0f);          // Translation for Moon orbit\n                    rlRotatef(-moonOrbitRotation, 0.0f, 1.0f, 0.0f);    // Rotation for Moon orbit around Earth inverted\n                    rlRotatef(moonRotation, 0.0f, 1.0f, 0.0f);          // Rotation for Moon itself\n                    rlScalef(moonRadius, moonRadius, moonRadius);       // Scale Moon\n\n                    DrawSphereBasic(LIGHTGRAY);                         // Draw the Moon\n                rlPopMatrix();\n\n                // Some reference elements (not affected by previous matrix transformations)\n                DrawCircle3D((Vector3){ 0.0f, 0.0f, 0.0f }, earthOrbitRadius, (Vector3){ 1, 0, 0 }, 90.0f, Fade(RED, 0.5f));\n                DrawGrid(20, 1.0f);\n\n            EndMode3D();\n\n            DrawText(\"EARTH ORBITING AROUND THE SUN!\", 400, 10, 20, MAROON);\n            DrawFPS(10, 10);\n\n        EndDrawing();\n        //----------------------------------------------------------------------------------\n    }\n\n    // De-Initialization\n    //--------------------------------------------------------------------------------------\n    CloseWindow();        // Close window and OpenGL context\n    //--------------------------------------------------------------------------------------\n\n    return 0;\n}", "path": "raylib/examples/models/models_rlgl_solar_system.c", "commit_date": "2020-01-28 00:00:00", "repo_name": "raysan5/raylib", "stars": 18133, "license": "zlib", "language": "c", "size": 394813}
{"docstring": "// Required for GUI controls\n", "func_signal": "int main(void)", "code": "{\n    // Initialization\n    //--------------------------------------------------------------------------------------\n    const int screenWidth = 800;\n    const int screenHeight = 450;\n\n    InitWindow(screenWidth, screenHeight, \"raylib [shapes] example - draw circle sector\");\n\n    Vector2 center = {(GetScreenWidth() - 300)/2, GetScreenHeight()/2 };\n\n    float outerRadius = 180.0f;\n    int startAngle = 0;\n    int endAngle = 180;\n    int segments = 0;\n\n    SetTargetFPS(60);               // Set our game to run at 60 frames-per-second\n    //--------------------------------------------------------------------------------------\n\n    // Main game loop\n    while (!WindowShouldClose())    // Detect window close button or ESC key\n    {\n        // Update\n        //----------------------------------------------------------------------------------\n        // NOTE: All variables update happens inside GUI control functions\n        //----------------------------------------------------------------------------------\n        \n        // Draw\n        //----------------------------------------------------------------------------------\n        BeginDrawing();\n        \n            ClearBackground(RAYWHITE);\n        \n            DrawLine(500, 0, 500, GetScreenHeight(), Fade(LIGHTGRAY, 0.6f));\n            DrawRectangle(500, 0, GetScreenWidth() - 500, GetScreenHeight(), Fade(LIGHTGRAY, 0.3f));\n\n            DrawCircleSector(center, outerRadius, startAngle, endAngle, segments, Fade(MAROON, 0.3));\n            DrawCircleSectorLines(center, outerRadius, startAngle, endAngle, segments, Fade(MAROON, 0.6));\n            \n            // Draw GUI controls\n            //------------------------------------------------------------------------------\n            startAngle = GuiSliderBar((Rectangle){ 600, 40, 120, 20}, \"StartAngle\", NULL, startAngle, 0, 720);\n            endAngle = GuiSliderBar((Rectangle){ 600, 70, 120, 20}, \"EndAngle\", NULL, endAngle, 0, 720);\n            \n            outerRadius = GuiSliderBar((Rectangle){ 600, 140, 120, 20}, \"Radius\", NULL, outerRadius, 0, 200);\n            segments = GuiSliderBar((Rectangle){ 600, 170, 120, 20}, \"Segments\", NULL, segments, 0, 100);\n            //------------------------------------------------------------------------------\n            \n            DrawText(TextFormat(\"MODE: %s\", (segments >= 4)? \"MANUAL\" : \"AUTO\"), 600, 200, 10, (segments >= 4)? MAROON : DARKGRAY);\n            \n            DrawFPS(10, 10);\n            \n        EndDrawing();\n        //----------------------------------------------------------------------------------\n    }\n\n    // De-Initialization\n    //--------------------------------------------------------------------------------------  \n    CloseWindow();        // Close window and OpenGL context\n    //--------------------------------------------------------------------------------------\n\n    return 0;\n}", "path": "raylib/examples/shapes/shapes_draw_circle_sector.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "raysan5/raylib", "stars": 18133, "license": "zlib", "language": "c", "size": 394813}
{"docstring": "// Image file exported with ExportImageAsCode()\n", "func_signal": "int main(void)", "code": "{\n    // Initialization\n    //--------------------------------------------------------------------------------------\n    const int screenWidth = 800;\n    const int screenHeight = 450;\n\n    InitWindow(screenWidth, screenHeight, \"raylib [others] example - embedded files loading\");\n\n    InitAudioDevice();              // Initialize audio device\n\n    // Loaded in CPU memory (RAM) from header file (audio_data.h)\n    // Same as: Wave wave = LoadWave(\"sound.wav\"); \n    Wave wave = {\n        .data = AUDIO_DATA,\n        .sampleCount = AUDIO_SAMPLE_COUNT,\n        .sampleRate = AUDIO_SAMPLE_RATE,\n        .sampleSize = AUDIO_SAMPLE_SIZE,\n        .channels = AUDIO_CHANNELS\n    };\n\n    // Wave converted to Sound to be played\n    Sound sound = LoadSoundFromWave(wave);\n    \n    // With a Wave loaded from file, after Sound is loaded, we can unload Wave\n    // but in our case, Wave is embedded in executable, in program .data segment\n    // we can not (and should not) try to free that private memory region\n    //UnloadWave(wave);             // Do not unload wave data!\n\n    // Loaded in CPU memory (RAM) from header file (image_data.h)\n    // Same as: Image image = LoadImage(\"raylib_logo.png\"); \n    Image image = {\n        .data = IMAGE_DATA,\n        .width = IMAGE_WIDTH,\n        .height = IMAGE_HEIGHT,\n        .format = IMAGE_FORMAT,\n        .mipmaps = 1\n    };\n    \n    // Image converted to Texture (VRAM) to be drawn\n    Texture2D texture = LoadTextureFromImage(image); \n    \n    // With an Image loaded from file, after Texture is loaded, we can unload Image\n    // but in our case, Image is embedded in executable, in program .data segment\n    // we can not (and should not) try to free that private memory region\n    //UnloadImage(image);           // Do not unload image data!\n \n    SetTargetFPS(60);               // Set our game to run at 60 frames-per-second\n    //--------------------------------------------------------------------------------------\n\n    // Main game loop\n    while (!WindowShouldClose())    // Detect window close button or ESC key\n    {\n        // Update\n        //----------------------------------------------------------------------------------\n        if (IsKeyPressed(KEY_SPACE)) PlaySound(sound);      // Play sound\n        //----------------------------------------------------------------------------------\n\n        // Draw\n        //----------------------------------------------------------------------------------\n        BeginDrawing();\n\n            ClearBackground(RAYWHITE);\n\n            DrawTexture(texture, screenWidth/2 - texture.width/2, 40, WHITE);\n\n            DrawText(\"raylib logo and sound loaded from header files\", 65, 320, 20, LIGHTGRAY);\n            DrawText(\"Press SPACE to PLAY the sound!\", 200, 360, 20, LIGHTGRAY);\n\n        EndDrawing();\n        //----------------------------------------------------------------------------------\n    }\n\n    // De-Initialization\n    //--------------------------------------------------------------------------------------\n    UnloadSound(sound);     // Unload sound from VRAM\n    UnloadTexture(texture); // Unload texture from VRAM\n\n    CloseAudioDevice();     // Close audio device\n\n    CloseWindow();          // Close window and OpenGL context\n    //--------------------------------------------------------------------------------------\n\n    return 0;\n}", "path": "raylib/examples/others/embedded_files_loading.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "raysan5/raylib", "stars": 18133, "license": "zlib", "language": "c", "size": 394813}
{"docstring": "// Data progress accumulator\n", "func_signal": "int main(void)", "code": "{\n    // Initialization\n    //--------------------------------------------------------------------------------------\n    const int screenWidth = 800;\n    const int screenHeight = 450;\n\n    InitWindow(screenWidth, screenHeight, \"raylib [core] example - loading thread\");\n\n    pthread_t threadId;             // Loading data thread id\n\n    enum { STATE_WAITING, STATE_LOADING, STATE_FINISHED } state = STATE_WAITING;\n    int framesCounter = 0;\n\n    SetTargetFPS(60);               // Set our game to run at 60 frames-per-second\n    //--------------------------------------------------------------------------------------\n\n    // Main game loop\n    while (!WindowShouldClose())    // Detect window close button or ESC key\n    {\n        // Update\n        //----------------------------------------------------------------------------------\n        switch (state)\n        {\n            case STATE_WAITING:\n            {\n                if (IsKeyPressed(KEY_ENTER))\n                {\n                    int error = pthread_create(&threadId, NULL, &LoadDataThread, NULL);\n                    if (error != 0) TraceLog(LOG_ERROR, \"Error creating loading thread\");\n                    else TraceLog(LOG_INFO, \"Loading thread initialized successfully\");\n\n                    state = STATE_LOADING;\n                }\n            } break;\n            case STATE_LOADING:\n            {\n                framesCounter++;\n                if (atomic_load(&dataLoaded))\n                {\n                    framesCounter = 0;\n                    state = STATE_FINISHED;\n                }\n            } break;\n            case STATE_FINISHED:\n            {\n                if (IsKeyPressed(KEY_ENTER))\n                {\n                    // Reset everything to launch again\n                    atomic_store(&dataLoaded, false);\n                    dataProgress = 0;\n                    state = STATE_WAITING;\n                }\n            } break;\n            default: break;\n        }\n        //----------------------------------------------------------------------------------\n\n        // Draw\n        //----------------------------------------------------------------------------------\n        BeginDrawing();\n\n            ClearBackground(RAYWHITE);\n\n            switch (state)\n            {\n                case STATE_WAITING: DrawText(\"PRESS ENTER to START LOADING DATA\", 150, 170, 20, DARKGRAY); break;\n                case STATE_LOADING:\n                {\n                    DrawRectangle(150, 200, dataProgress, 60, SKYBLUE);\n                    if ((framesCounter/15)%2) DrawText(\"LOADING DATA...\", 240, 210, 40, DARKBLUE);\n\n                } break;\n                case STATE_FINISHED:\n                {\n                    DrawRectangle(150, 200, 500, 60, LIME);\n                    DrawText(\"DATA LOADED!\", 250, 210, 40, GREEN);\n\n                } break;\n                default: break;\n            }\n\n            DrawRectangleLines(150, 200, 500, 60, DARKGRAY);\n\n        EndDrawing();\n        //----------------------------------------------------------------------------------\n    }\n\n    // De-Initialization\n    //--------------------------------------------------------------------------------------\n    CloseWindow();        // Close window and OpenGL context\n    //--------------------------------------------------------------------------------------\n\n    return 0;\n}", "path": "raylib/examples/core/core_loading_thread.c", "commit_date": "2019-05-20 00:00:00", "repo_name": "raysan5/raylib", "stars": 18133, "license": "zlib", "language": "c", "size": 394813}
{"docstring": "// Draw cube wires\n", "func_signal": "static void DrawCubeWires(Vector3 position, float width, float height, float length, Color color)", "code": "{\n    float x = 0.0f;\n    float y = 0.0f;\n    float z = 0.0f;\n\n    rlPushMatrix();\n\n        rlTranslatef(position.x, position.y, position.z);\n        //rlRotatef(45, 0, 1, 0);\n\n        rlBegin(RL_LINES);\n            rlColor4ub(color.r, color.g, color.b, color.a);\n\n            // Front Face -----------------------------------------------------\n            // Bottom Line\n            rlVertex3f(x-width/2, y-height/2, z+length/2);  // Bottom Left\n            rlVertex3f(x+width/2, y-height/2, z+length/2);  // Bottom Right\n\n            // Left Line\n            rlVertex3f(x+width/2, y-height/2, z+length/2);  // Bottom Right\n            rlVertex3f(x+width/2, y+height/2, z+length/2);  // Top Right\n\n            // Top Line\n            rlVertex3f(x+width/2, y+height/2, z+length/2);  // Top Right\n            rlVertex3f(x-width/2, y+height/2, z+length/2);  // Top Left\n\n            // Right Line\n            rlVertex3f(x-width/2, y+height/2, z+length/2);  // Top Left\n            rlVertex3f(x-width/2, y-height/2, z+length/2);  // Bottom Left\n\n            // Back Face ------------------------------------------------------\n            // Bottom Line\n            rlVertex3f(x-width/2, y-height/2, z-length/2);  // Bottom Left\n            rlVertex3f(x+width/2, y-height/2, z-length/2);  // Bottom Right\n\n            // Left Line\n            rlVertex3f(x+width/2, y-height/2, z-length/2);  // Bottom Right\n            rlVertex3f(x+width/2, y+height/2, z-length/2);  // Top Right\n\n            // Top Line\n            rlVertex3f(x+width/2, y+height/2, z-length/2);  // Top Right\n            rlVertex3f(x-width/2, y+height/2, z-length/2);  // Top Left\n\n            // Right Line\n            rlVertex3f(x-width/2, y+height/2, z-length/2);  // Top Left\n            rlVertex3f(x-width/2, y-height/2, z-length/2);  // Bottom Left\n\n            // Top Face -------------------------------------------------------\n            // Left Line\n            rlVertex3f(x-width/2, y+height/2, z+length/2);  // Top Left Front\n            rlVertex3f(x-width/2, y+height/2, z-length/2);  // Top Left Back\n\n            // Right Line\n            rlVertex3f(x+width/2, y+height/2, z+length/2);  // Top Right Front\n            rlVertex3f(x+width/2, y+height/2, z-length/2);  // Top Right Back\n\n            // Bottom Face  ---------------------------------------------------\n            // Left Line\n            rlVertex3f(x-width/2, y-height/2, z+length/2);  // Top Left Front\n            rlVertex3f(x-width/2, y-height/2, z-length/2);  // Top Left Back\n\n            // Right Line\n            rlVertex3f(x+width/2, y-height/2, z+length/2);  // Top Right Front\n            rlVertex3f(x+width/2, y-height/2, z-length/2);  // Top Right Back\n        rlEnd();\n    rlPopMatrix();\n}", "path": "raylib/examples/others/rlgl_standalone.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "raysan5/raylib", "stars": 18133, "license": "zlib", "language": "c", "size": 394813}
{"docstring": "// Draw sphere without any matrix transformation\n// NOTE: Sphere is drawn in world position ( 0, 0, 0 ) with radius 1.0f\n", "func_signal": "void DrawSphereBasic(Color color)", "code": "{\n    int rings = 16;\n    int slices = 16;\n\n    rlBegin(RL_TRIANGLES);\n        rlColor4ub(color.r, color.g, color.b, color.a);\n\n        for (int i = 0; i < (rings + 2); i++)\n        {\n            for (int j = 0; j < slices; j++)\n            {\n                rlVertex3f(cosf(DEG2RAD*(270+(180/(rings + 1))*i))*sinf(DEG2RAD*(j*360/slices)),\n                           sinf(DEG2RAD*(270+(180/(rings + 1))*i)),\n                           cosf(DEG2RAD*(270+(180/(rings + 1))*i))*cosf(DEG2RAD*(j*360/slices)));\n                rlVertex3f(cosf(DEG2RAD*(270+(180/(rings + 1))*(i+1)))*sinf(DEG2RAD*((j+1)*360/slices)),\n                           sinf(DEG2RAD*(270+(180/(rings + 1))*(i+1))),\n                           cosf(DEG2RAD*(270+(180/(rings + 1))*(i+1)))*cosf(DEG2RAD*((j+1)*360/slices)));\n                rlVertex3f(cosf(DEG2RAD*(270+(180/(rings + 1))*(i+1)))*sinf(DEG2RAD*(j*360/slices)),\n                           sinf(DEG2RAD*(270+(180/(rings + 1))*(i+1))),\n                           cosf(DEG2RAD*(270+(180/(rings + 1))*(i+1)))*cosf(DEG2RAD*(j*360/slices)));\n\n                rlVertex3f(cosf(DEG2RAD*(270+(180/(rings + 1))*i))*sinf(DEG2RAD*(j*360/slices)),\n                           sinf(DEG2RAD*(270+(180/(rings + 1))*i)),\n                           cosf(DEG2RAD*(270+(180/(rings + 1))*i))*cosf(DEG2RAD*(j*360/slices)));\n                rlVertex3f(cosf(DEG2RAD*(270+(180/(rings + 1))*(i)))*sinf(DEG2RAD*((j+1)*360/slices)),\n                           sinf(DEG2RAD*(270+(180/(rings + 1))*(i))),\n                           cosf(DEG2RAD*(270+(180/(rings + 1))*(i)))*cosf(DEG2RAD*((j+1)*360/slices)));\n                rlVertex3f(cosf(DEG2RAD*(270+(180/(rings + 1))*(i+1)))*sinf(DEG2RAD*((j+1)*360/slices)),\n                           sinf(DEG2RAD*(270+(180/(rings + 1))*(i+1))),\n                           cosf(DEG2RAD*(270+(180/(rings + 1))*(i+1)))*cosf(DEG2RAD*((j+1)*360/slices)));\n            }\n        }\n    rlEnd();\n}", "path": "raylib/examples/models/models_rlgl_solar_system.c", "commit_date": "2020-01-28 00:00:00", "repo_name": "raysan5/raylib", "stars": 18133, "license": "zlib", "language": "c", "size": 394813}
{"docstring": "// NoEase function, used when \"no easing\" is selected for any axis. It just ignores all parameters besides b.\n", "func_signal": "static float NoEase(float t, float b, float c, float d)", "code": "{\n    float burn = t + b + c + d;  // Hack to avoid compiler warning (about unused variables)\n    d += burn;\n\n    return b;\n}", "path": "raylib/examples/others/easings_testbed.c", "commit_date": "2019-05-24 00:00:00", "repo_name": "raysan5/raylib", "stars": 18133, "license": "zlib", "language": "c", "size": 394813}
{"docstring": "// Maximum value of a float, from bit pattern 01111111011111111111111111111111\n", "func_signal": "int main(void)", "code": "{\n    // Initialization\n    //--------------------------------------------------------------------------------------\n    const int screenWidth = 800;\n    const int screenHeight = 450;\n\n    InitWindow(screenWidth, screenHeight, \"raylib [models] example - mesh picking\");\n\n    // Define the camera to look into our 3d world\n    Camera camera = { 0 };\n    camera.position = (Vector3){ 20.0f, 20.0f, 20.0f }; // Camera position\n    camera.target = (Vector3){ 0.0f, 8.0f, 0.0f };      // Camera looking at point\n    camera.up = (Vector3){ 0.0f, 1.6f, 0.0f };          // Camera up vector (rotation towards target)\n    camera.fovy = 45.0f;                                // Camera field-of-view Y\n    camera.type = CAMERA_PERSPECTIVE;                   // Camera mode type\n\n    Ray ray = { 0 };        // Picking ray\n\n    Model tower = LoadModel(\"resources/models/turret.obj\");                 // Load OBJ model\n    Texture2D texture = LoadTexture(\"resources/models/turret_diffuse.png\"); // Load model texture\n    tower.materials[0].maps[MAP_DIFFUSE].texture = texture;                 // Set model diffuse texture\n\n    Vector3 towerPos = { 0.0f, 0.0f, 0.0f };                    // Set model position\n    BoundingBox towerBBox = MeshBoundingBox(tower.meshes[0]);   // Get mesh bounding box\n    bool hitMeshBBox = false;\n    bool hitTriangle = false;\n\n    // Test triangle\n    Vector3 ta = (Vector3){ -25.0, 0.5, 0.0 };\n    Vector3 tb = (Vector3){ -4.0, 2.5, 1.0 };\n    Vector3 tc = (Vector3){ -8.0, 6.5, 0.0 };\n\n    Vector3 bary = { 0.0f, 0.0f, 0.0f };\n\n    SetCameraMode(camera, CAMERA_FREE); // Set a free camera mode\n\n    SetTargetFPS(60);                   // Set our game to run at 60 frames-per-second\n    //--------------------------------------------------------------------------------------\n    // Main game loop\n    while (!WindowShouldClose())        // Detect window close button or ESC key\n    {\n        // Update\n        //----------------------------------------------------------------------------------\n        UpdateCamera(&camera);          // Update camera\n\n        // Display information about closest hit\n        RayHitInfo nearestHit = { 0 };\n        char *hitObjectName = \"None\";\n        nearestHit.distance = FLT_MAX;\n        nearestHit.hit = false;\n        Color cursorColor = WHITE;\n\n        // Get ray and test against ground, triangle, and mesh\n        ray = GetMouseRay(GetMousePosition(), camera);\n\n        // Check ray collision aginst ground plane\n        RayHitInfo groundHitInfo = GetCollisionRayGround(ray, 0.0f);\n\n        if ((groundHitInfo.hit) && (groundHitInfo.distance < nearestHit.distance))\n        {\n            nearestHit = groundHitInfo;\n            cursorColor = GREEN;\n            hitObjectName = \"Ground\";\n        }\n\n        // Check ray collision against test triangle\n        RayHitInfo triHitInfo = GetCollisionRayTriangle(ray, ta, tb, tc);\n\n        if ((triHitInfo.hit) && (triHitInfo.distance < nearestHit.distance))\n        {\n            nearestHit = triHitInfo;\n            cursorColor = PURPLE;\n            hitObjectName = \"Triangle\";\n\n            bary = Vector3Barycenter(nearestHit.position, ta, tb, tc);\n            hitTriangle = true;\n        }\n        else hitTriangle = false;\n\n        RayHitInfo meshHitInfo = { 0 };\n\n        // Check ray collision against bounding box first, before trying the full ray-mesh test\n        if (CheckCollisionRayBox(ray, towerBBox))\n        {\n            hitMeshBBox = true;\n\n            // Check ray collision against model\n            // NOTE: It considers model.transform matrix!\n            meshHitInfo = GetCollisionRayModel(ray, tower);\n\n            if ((meshHitInfo.hit) && (meshHitInfo.distance < nearestHit.distance))\n            {\n                nearestHit = meshHitInfo;\n                cursorColor = ORANGE;\n                hitObjectName = \"Mesh\";\n            }\n        }\n\n        hitMeshBBox = false;\n        //----------------------------------------------------------------------------------\n\n        // Draw\n        //----------------------------------------------------------------------------------\n        BeginDrawing();\n\n            ClearBackground(RAYWHITE);\n\n            BeginMode3D(camera);\n\n                // Draw the tower\n                // WARNING: If scale is different than 1.0f,\n                // not considered by GetCollisionRayModel()\n                DrawModel(tower, towerPos, 1.0f, WHITE);\n\n                // Draw the test triangle\n                DrawLine3D(ta, tb, PURPLE);\n                DrawLine3D(tb, tc, PURPLE);\n                DrawLine3D(tc, ta, PURPLE);\n\n                // Draw the mesh bbox if we hit it\n                if (hitMeshBBox) DrawBoundingBox(towerBBox, LIME);\n\n                // If we hit something, draw the cursor at the hit point\n                if (nearestHit.hit)\n                {\n                    DrawCube(nearestHit.position, 0.3, 0.3, 0.3, cursorColor);\n                    DrawCubeWires(nearestHit.position, 0.3, 0.3, 0.3, RED);\n\n                    Vector3 normalEnd;\n                    normalEnd.x = nearestHit.position.x + nearestHit.normal.x;\n                    normalEnd.y = nearestHit.position.y + nearestHit.normal.y;\n                    normalEnd.z = nearestHit.position.z + nearestHit.normal.z;\n\n                    DrawLine3D(nearestHit.position, normalEnd, RED);\n                }\n\n                DrawRay(ray, MAROON);\n\n                DrawGrid(10, 10.0f);\n\n            EndMode3D();\n\n            // Draw some debug GUI text\n            DrawText(TextFormat(\"Hit Object: %s\", hitObjectName), 10, 50, 10, BLACK);\n\n            if (nearestHit.hit)\n            {\n                int ypos = 70;\n\n                DrawText(TextFormat(\"Distance: %3.2f\", nearestHit.distance), 10, ypos, 10, BLACK);\n\n                DrawText(TextFormat(\"Hit Pos: %3.2f %3.2f %3.2f\",\n                                    nearestHit.position.x,\n                                    nearestHit.position.y,\n                                    nearestHit.position.z), 10, ypos + 15, 10, BLACK);\n\n                DrawText(TextFormat(\"Hit Norm: %3.2f %3.2f %3.2f\",\n                                    nearestHit.normal.x,\n                                    nearestHit.normal.y,\n                                    nearestHit.normal.z), 10, ypos + 30, 10, BLACK);\n\n                if (hitTriangle) DrawText(TextFormat(\"Barycenter: %3.2f %3.2f %3.2f\",  bary.x, bary.y, bary.z), 10, ypos + 45, 10, BLACK);\n            }\n\n            DrawText(\"Use Mouse to Move Camera\", 10, 430, 10, GRAY);\n\n            DrawText(\"(c) Turret 3D model by Alberto Cano\", screenWidth - 200, screenHeight - 20, 10, GRAY);\n\n            DrawFPS(10, 10);\n\n        EndDrawing();\n        //----------------------------------------------------------------------------------\n    }\n\n    // De-Initialization\n    //--------------------------------------------------------------------------------------\n    UnloadModel(tower);         // Unload model\n    UnloadTexture(texture);     // Unload texture\n\n    CloseWindow();              // Close window and OpenGL context\n    //--------------------------------------------------------------------------------------\n\n    return 0;\n}", "path": "raylib/examples/models/models_mesh_picking.c", "commit_date": "2020-08-16 00:00:00", "repo_name": "raysan5/raylib", "stars": 18133, "license": "zlib", "language": "c", "size": 394813}
{"docstring": "// Loading data thread function definition\n", "func_signal": "static void *LoadDataThread(void *arg)", "code": "{\n    int timeCounter = 0;            // Time counted in ms\n    clock_t prevTime = clock();     // Previous time\n\n    // We simulate data loading with a time counter for 5 seconds\n    while (timeCounter < 5000)\n    {\n        clock_t currentTime = clock() - prevTime;\n        timeCounter = currentTime*1000/CLOCKS_PER_SEC;\n\n        // We accumulate time over a global variable to be used in\n        // main thread as a progress bar\n        dataProgress = timeCounter/10;\n    }\n\n    // When data has finished loading, we set global variable\n    atomic_store(&dataLoaded, true);\n\n    return NULL;\n}", "path": "raylib/examples/core/core_loading_thread.c", "commit_date": "2019-05-20 00:00:00", "repo_name": "raysan5/raylib", "stars": 18133, "license": "zlib", "language": "c", "size": 394813}
{"docstring": "// Draw a grid centered at (0, 0, 0)\n", "func_signal": "static void DrawGrid(int slices, float spacing)", "code": "{\n    int halfSlices = slices / 2;\n\n    rlBegin(RL_LINES);\n        for(int i = -halfSlices; i <= halfSlices; i++)\n        {\n            if (i == 0)\n            {\n                rlColor3f(0.5f, 0.5f, 0.5f);\n                rlColor3f(0.5f, 0.5f, 0.5f);\n                rlColor3f(0.5f, 0.5f, 0.5f);\n                rlColor3f(0.5f, 0.5f, 0.5f);\n            }\n            else\n            {\n                rlColor3f(0.75f, 0.75f, 0.75f);\n                rlColor3f(0.75f, 0.75f, 0.75f);\n                rlColor3f(0.75f, 0.75f, 0.75f);\n                rlColor3f(0.75f, 0.75f, 0.75f);\n            }\n\n            rlVertex3f((float)i*spacing, 0.0f, (float)-halfSlices*spacing);\n            rlVertex3f((float)i*spacing, 0.0f, (float)halfSlices*spacing);\n\n            rlVertex3f((float)-halfSlices*spacing, 0.0f, (float)i*spacing);\n            rlVertex3f((float)halfSlices*spacing, 0.0f, (float)i*spacing);\n        }\n    rlEnd();\n}", "path": "raylib/examples/others/rlgl_standalone.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "raysan5/raylib", "stars": 18133, "license": "zlib", "language": "c", "size": 394813}
{"docstring": "// Draw angle gauge controls\n", "func_signal": "void DrawAngleGauge(Texture2D angleGauge, int x, int y, float angle, char title[], Color color)", "code": "{\n    Rectangle srcRec = { 0, 0, angleGauge.width, angleGauge.height };\n    Rectangle dstRec = { x, y, angleGauge.width, angleGauge.height };\n    Vector2 origin = { angleGauge.width/2, angleGauge.height/2};\n    int textSize = 20;\n\n    DrawTexturePro(angleGauge, srcRec, dstRec, origin, angle, color);\n\n    DrawText(TextFormat(\"%5.1f\", angle), x - MeasureText(TextFormat(\"%5.1f\", angle), textSize) / 2, y + 10, textSize, DARKGRAY);\n    DrawText(title, x - MeasureText(title, textSize) / 2, y + 60, textSize, DARKGRAY);\n}", "path": "raylib/examples/models/models_yaw_pitch_roll.c", "commit_date": "2020-10-28 00:00:00", "repo_name": "raysan5/raylib", "stars": 18133, "license": "zlib", "language": "c", "size": 394813}
{"docstring": "// Required for: free()\n", "func_signal": "int main(void)", "code": "{\n    // Initialization\n    //--------------------------------------------------------------------------------------\n    const int screenWidth = 800;\n    const int screenHeight = 450;\n\n    InitWindow(screenWidth, screenHeight, \"raylib [models] example - first person maze\");\n\n    // Define the camera to look into our 3d world\n    Camera camera = { { 0.2f, 0.4f, 0.2f }, { 0.0f, 0.0f, 0.0f }, { 0.0f, 1.0f, 0.0f }, 45.0f, 0 };\n\n    Image imMap = LoadImage(\"resources/cubicmap.png\");      // Load cubicmap image (RAM)\n    Texture2D cubicmap = LoadTextureFromImage(imMap);       // Convert image to texture to display (VRAM)\n    Mesh mesh = GenMeshCubicmap(imMap, (Vector3){ 1.0f, 1.0f, 1.0f });\n    Model model = LoadModelFromMesh(mesh);\n\n    // NOTE: By default each cube is mapped to one part of texture atlas\n    Texture2D texture = LoadTexture(\"resources/cubicmap_atlas.png\");    // Load map texture\n    model.materials[0].maps[MAP_DIFFUSE].texture = texture;             // Set map diffuse texture\n\n    // Get map image data to be used for collision detection\n    Color *mapPixels = GetImageData(imMap);\n    UnloadImage(imMap);             // Unload image from RAM\n\n    Vector3 mapPosition = { -16.0f, 0.0f, -8.0f };  // Set model position\n    Vector3 playerPosition = camera.position;       // Set player position\n\n    SetCameraMode(camera, CAMERA_FIRST_PERSON);     // Set camera mode\n\n    SetTargetFPS(60);               // Set our game to run at 60 frames-per-second\n    //--------------------------------------------------------------------------------------\n\n    // Main game loop\n    while (!WindowShouldClose())    // Detect window close button or ESC key\n    {\n        // Update\n        //----------------------------------------------------------------------------------\n        Vector3 oldCamPos = camera.position;    // Store old camera position\n\n        UpdateCamera(&camera);      // Update camera\n\n        // Check player collision (we simplify to 2D collision detection)\n        Vector2 playerPos = { camera.position.x, camera.position.z };\n        float playerRadius = 0.1f;  // Collision radius (player is modelled as a cilinder for collision)\n\n        int playerCellX = (int)(playerPos.x - mapPosition.x + 0.5f);\n        int playerCellY = (int)(playerPos.y - mapPosition.z + 0.5f);\n\n        // Out-of-limits security check\n        if (playerCellX < 0) playerCellX = 0;\n        else if (playerCellX >= cubicmap.width) playerCellX = cubicmap.width - 1;\n\n        if (playerCellY < 0) playerCellY = 0;\n        else if (playerCellY >= cubicmap.height) playerCellY = cubicmap.height - 1;\n\n        // Check map collisions using image data and player position\n        // TODO: Improvement: Just check player surrounding cells for collision\n        for (int y = 0; y < cubicmap.height; y++)\n        {\n            for (int x = 0; x < cubicmap.width; x++)\n            {\n                if ((mapPixels[y*cubicmap.width + x].r == 255) &&       // Collision: white pixel, only check R channel\n                    (CheckCollisionCircleRec(playerPos, playerRadius,\n                    (Rectangle){ mapPosition.x - 0.5f + x*1.0f, mapPosition.z - 0.5f + y*1.0f, 1.0f, 1.0f })))\n                {\n                    // Collision detected, reset camera position\n                    camera.position = oldCamPos;\n                }\n            }\n        }\n        //----------------------------------------------------------------------------------\n\n        // Draw\n        //----------------------------------------------------------------------------------\n        BeginDrawing();\n\n            ClearBackground(RAYWHITE);\n\n            BeginMode3D(camera);\n\n                DrawModel(model, mapPosition, 1.0f, WHITE);                     // Draw maze map\n                //DrawCubeV(playerPosition, (Vector3){ 0.2f, 0.4f, 0.2f }, RED);  // Draw player\n\n            EndMode3D();\n\n            DrawTextureEx(cubicmap, (Vector2){ GetScreenWidth() - cubicmap.width*4 - 20, 20 }, 0.0f, 4.0f, WHITE);\n            DrawRectangleLines(GetScreenWidth() - cubicmap.width*4 - 20, 20, cubicmap.width*4, cubicmap.height*4, GREEN);\n\n            // Draw player position radar\n            DrawRectangle(GetScreenWidth() - cubicmap.width*4 - 20 + playerCellX*4, 20 + playerCellY*4, 4, 4, RED);\n\n            DrawFPS(10, 10);\n\n        EndDrawing();\n        //----------------------------------------------------------------------------------\n    }\n\n    // De-Initialization\n    //--------------------------------------------------------------------------------------\n    free(mapPixels);            // Unload color array\n\n    UnloadTexture(cubicmap);    // Unload cubicmap texture\n    UnloadTexture(texture);     // Unload map texture\n    UnloadModel(model);         // Unload map model\n\n    CloseWindow();              // Close window and OpenGL context\n    //--------------------------------------------------------------------------------------\n\n    return 0;\n}", "path": "raylib/examples/models/models_first_person_maze.c", "commit_date": "2019-05-26 00:00:00", "repo_name": "raysan5/raylib", "stars": 18133, "license": "zlib", "language": "c", "size": 394813}
{"docstring": "// Custom logging funtion\n", "func_signal": "void LogCustom(int msgType, const char *text, va_list args)", "code": "{\n    char timeStr[64] = { 0 };\n    time_t now = time(NULL);\n    struct tm *tm_info = localtime(&now);\n\n    strftime(timeStr, sizeof(timeStr), \"%Y-%m-%d %H:%M:%S\", tm_info);\n    printf(\"[%s] \", timeStr);\n\n    switch (msgType)\n    {\n        case LOG_INFO: printf(\"[INFO] : \"); break;\n        case LOG_ERROR: printf(\"[ERROR]: \"); break;\n        case LOG_WARNING: printf(\"[WARN] : \"); break;\n        case LOG_DEBUG: printf(\"[DEBUG]: \"); break;\n        default: break;\n    }\n\n    vprintf(text, args);\n    printf(\"\\n\");\n}", "path": "raylib/examples/core/core_custom_logging.c", "commit_date": "2019-05-26 00:00:00", "repo_name": "raysan5/raylib", "stars": 18133, "license": "zlib", "language": "c", "size": 394813}
{"docstring": "// Required for abs()\n", "func_signal": "int main(void)", "code": "{\n    // Initialization\n    //---------------------------------------------------------\n    const int screenWidth = 800;\n    const int screenHeight = 450;\n\n    InitWindow(screenWidth, screenHeight, \"raylib [shapes] example - collision area\");\n\n    // Box A: Moving box\n    Rectangle boxA = { 10, GetScreenHeight()/2 - 50, 200, 100 };\n    int boxASpeedX = 4;\n\n    // Box B: Mouse moved box\n    Rectangle boxB = { GetScreenWidth()/2 - 30, GetScreenHeight()/2 - 30, 60, 60 };\n\n    Rectangle boxCollision = { 0 }; // Collision rectangle\n\n    int screenUpperLimit = 40;      // Top menu limits\n\n    bool pause = false;             // Movement pause\n    bool collision = false;         // Collision detection\n\n    SetTargetFPS(60);               // Set our game to run at 60 frames-per-second\n    //----------------------------------------------------------\n\n    // Main game loop\n    while (!WindowShouldClose())    // Detect window close button or ESC key\n    {\n        // Update\n        //-----------------------------------------------------\n        // Move box if not paused\n        if (!pause) boxA.x += boxASpeedX;\n\n        // Bounce box on x screen limits\n        if (((boxA.x + boxA.width) >= GetScreenWidth()) || (boxA.x <= 0)) boxASpeedX *= -1;\n\n        // Update player-controlled-box (box02)\n        boxB.x = GetMouseX() - boxB.width/2;\n        boxB.y = GetMouseY() - boxB.height/2;\n\n        // Make sure Box B does not go out of move area limits\n        if ((boxB.x + boxB.width) >= GetScreenWidth()) boxB.x = GetScreenWidth() - boxB.width;\n        else if (boxB.x <= 0) boxB.x = 0;\n\n        if ((boxB.y + boxB.height) >= GetScreenHeight()) boxB.y = GetScreenHeight() - boxB.height;\n        else if (boxB.y <= screenUpperLimit) boxB.y = screenUpperLimit;\n\n        // Check boxes collision\n        collision = CheckCollisionRecs(boxA, boxB);\n\n        // Get collision rectangle (only on collision)\n        if (collision) boxCollision = GetCollisionRec(boxA, boxB);\n\n        // Pause Box A movement\n        if (IsKeyPressed(KEY_SPACE)) pause = !pause;\n        //-----------------------------------------------------\n\n        // Draw\n        //-----------------------------------------------------\n        BeginDrawing();\n\n            ClearBackground(RAYWHITE);\n\n            DrawRectangle(0, 0, screenWidth, screenUpperLimit, collision? RED : BLACK);\n\n            DrawRectangleRec(boxA, GOLD);\n            DrawRectangleRec(boxB, BLUE);\n\n            if (collision)\n            {\n                // Draw collision area\n                DrawRectangleRec(boxCollision, LIME);\n\n                // Draw collision message\n                DrawText(\"COLLISION!\", GetScreenWidth()/2 - MeasureText(\"COLLISION!\", 20)/2, screenUpperLimit/2 - 10, 20, BLACK);\n\n                // Draw collision area\n                DrawText(TextFormat(\"Collision Area: %i\", (int)boxCollision.width*(int)boxCollision.height), GetScreenWidth()/2 - 100, screenUpperLimit + 10, 20, BLACK);\n            }\n\n            DrawFPS(10, 10);\n\n        EndDrawing();\n        //-----------------------------------------------------\n    }\n\n    // De-Initialization\n    //---------------------------------------------------------\n    CloseWindow();        // Close window and OpenGL context\n    //----------------------------------------------------------\n\n    return 0;\n}", "path": "raylib/examples/shapes/shapes_collision_area.c", "commit_date": "2020-08-16 00:00:00", "repo_name": "raysan5/raylib", "stars": 18133, "license": "zlib", "language": "c", "size": 394813}
{"docstring": "// Required for GUI controls\n", "func_signal": "int main(void)", "code": "{\n    // Initialization\n    //--------------------------------------------------------------------------------------\n    const int screenWidth = 800;\n    const int screenHeight = 450;\n\n    InitWindow(screenWidth, screenHeight, \"raylib [shapes] example - draw rectangle rounded\");\n\n    float roundness = 0.2f;\n    int width = 200;\n    int height = 100;\n    int segments = 0;\n    int lineThick = 1;\n\n    bool drawRect = false;\n    bool drawRoundedRect = true;\n    bool drawRoundedLines = false;\n\n    SetTargetFPS(60);               // Set our game to run at 60 frames-per-second\n    //--------------------------------------------------------------------------------------\n\n    // Main game loop\n    while (!WindowShouldClose())    // Detect window close button or ESC key\n    {\n        // Update\n        //----------------------------------------------------------------------------------\n        Rectangle rec = { (GetScreenWidth() - width - 250)/2, (GetScreenHeight() - height)/2, width, height };\n        //----------------------------------------------------------------------------------\n\n        // Draw\n        //----------------------------------------------------------------------------------\n        BeginDrawing();\n\n            ClearBackground(RAYWHITE);\n\n            DrawLine(560, 0, 560, GetScreenHeight(), Fade(LIGHTGRAY, 0.6f));\n            DrawRectangle(560, 0, GetScreenWidth() - 500, GetScreenHeight(), Fade(LIGHTGRAY, 0.3f));\n\n            if (drawRect) DrawRectangleRec(rec, Fade(GOLD, 0.6));\n            if (drawRoundedRect) DrawRectangleRounded(rec, roundness, segments, Fade(MAROON, 0.2));\n            if (drawRoundedLines) DrawRectangleRoundedLines(rec,roundness, segments, lineThick, Fade(MAROON, 0.4));\n\n            // Draw GUI controls\n            //------------------------------------------------------------------------------\n            width = GuiSliderBar((Rectangle){ 640, 40, 105, 20 }, \"Width\", NULL, width, 0, GetScreenWidth() - 300);\n            height = GuiSliderBar((Rectangle){ 640, 70, 105, 20 }, \"Height\", NULL, height, 0, GetScreenHeight() - 50);\n            roundness = GuiSliderBar((Rectangle){ 640, 140, 105, 20 }, \"Roundness\", NULL, roundness, 0.0f, 1.0f);\n            lineThick = GuiSliderBar((Rectangle){ 640, 170, 105, 20 }, \"Thickness\", NULL, lineThick, 0, 20);\n            segments = GuiSliderBar((Rectangle){ 640, 240, 105, 20}, \"Segments\", NULL, segments, 0, 60);\n\n            drawRoundedRect = GuiCheckBox((Rectangle){ 640, 320, 20, 20 }, \"DrawRoundedRect\", drawRoundedRect);\n            drawRoundedLines = GuiCheckBox((Rectangle){ 640, 350, 20, 20 }, \"DrawRoundedLines\", drawRoundedLines);\n            drawRect = GuiCheckBox((Rectangle){ 640, 380, 20, 20}, \"DrawRect\", drawRect);\n            //------------------------------------------------------------------------------\n\n            DrawText(TextFormat(\"MODE: %s\", (segments >= 4)? \"MANUAL\" : \"AUTO\"), 640, 280, 10, (segments >= 4)? MAROON : DARKGRAY);\n\n            DrawFPS(10, 10);\n\n        EndDrawing();\n        //----------------------------------------------------------------------------------\n    }\n\n    // De-Initialization\n    //--------------------------------------------------------------------------------------\n    CloseWindow();        // Close window and OpenGL context\n    //--------------------------------------------------------------------------------------\n\n    return 0;\n}", "path": "raylib/examples/shapes/shapes_draw_rectangle_rounded.c", "commit_date": "2020-12-24 00:00:00", "repo_name": "raysan5/raylib", "stars": 18133, "license": "zlib", "language": "c", "size": 394813}
{"docstring": "// Parametric 3d shapes to generate\n", "func_signal": "int main(void)", "code": "{\n    // Initialization\n    //--------------------------------------------------------------------------------------\n    const int screenWidth = 800;\n    const int screenHeight = 450;\n\n    InitWindow(screenWidth, screenHeight, \"raylib [models] example - mesh generation\");\n\n    // We generate a checked image for texturing\n    Image checked = GenImageChecked(2, 2, 1, 1, RED, GREEN);\n    Texture2D texture = LoadTextureFromImage(checked);\n    UnloadImage(checked);\n\n    Model models[NUM_MODELS] = { 0 };\n\n    models[0] = LoadModelFromMesh(GenMeshPlane(2, 2, 5, 5));\n    models[1] = LoadModelFromMesh(GenMeshCube(2.0f, 1.0f, 2.0f));\n    models[2] = LoadModelFromMesh(GenMeshSphere(2, 32, 32));\n    models[3] = LoadModelFromMesh(GenMeshHemiSphere(2, 16, 16));\n    models[4] = LoadModelFromMesh(GenMeshCylinder(1, 2, 16));\n    models[5] = LoadModelFromMesh(GenMeshTorus(0.25f, 4.0f, 16, 32));\n    models[6] = LoadModelFromMesh(GenMeshKnot(1.0f, 2.0f, 16, 128));\n    models[7] = LoadModelFromMesh(GenMeshPoly(5, 2.0f));\n\n    // Set checked texture as default diffuse component for all models material\n    for (int i = 0; i < NUM_MODELS; i++) models[i].materials[0].maps[MAP_DIFFUSE].texture = texture;\n\n    // Define the camera to look into our 3d world\n    Camera camera = { { 5.0f, 5.0f, 5.0f }, { 0.0f, 0.0f, 0.0f }, { 0.0f, 1.0f, 0.0f }, 45.0f, 0 };\n\n    // Model drawing position\n    Vector3 position = { 0.0f, 0.0f, 0.0f };\n\n    int currentModel = 0;\n\n    SetCameraMode(camera, CAMERA_ORBITAL);  // Set a orbital camera mode\n\n    SetTargetFPS(60);               // Set our game to run at 60 frames-per-second\n    //--------------------------------------------------------------------------------------\n\n    // Main game loop\n    while (!WindowShouldClose())    // Detect window close button or ESC key\n    {\n        // Update\n        //----------------------------------------------------------------------------------\n        UpdateCamera(&camera);      // Update internal camera and our camera\n\n        if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON))\n        {\n            currentModel = (currentModel + 1)%NUM_MODELS; // Cycle between the textures\n        }\n\n        if (IsKeyPressed(KEY_RIGHT))\n        {\n            currentModel++;\n            if (currentModel >= NUM_MODELS) currentModel = 0;\n        }\n        else if (IsKeyPressed(KEY_LEFT))\n        {\n            currentModel--;\n            if (currentModel < 0) currentModel = NUM_MODELS - 1;\n        }\n        //----------------------------------------------------------------------------------\n\n        // Draw\n        //----------------------------------------------------------------------------------\n        BeginDrawing();\n\n            ClearBackground(RAYWHITE);\n\n            BeginMode3D(camera);\n\n                DrawModel(models[currentModel], position, 1.0f, WHITE);\n\n                DrawGrid(10, 1.0);\n\n            EndMode3D();\n\n            DrawRectangle(30, 400, 310, 30, Fade(SKYBLUE, 0.5f));\n            DrawRectangleLines(30, 400, 310, 30, Fade(DARKBLUE, 0.5f));\n            DrawText(\"MOUSE LEFT BUTTON to CYCLE PROCEDURAL MODELS\", 40, 410, 10, BLUE);\n\n            switch(currentModel)\n            {\n                case 0: DrawText(\"PLANE\", 680, 10, 20, DARKBLUE); break;\n                case 1: DrawText(\"CUBE\", 680, 10, 20, DARKBLUE); break;\n                case 2: DrawText(\"SPHERE\", 680, 10, 20, DARKBLUE); break;\n                case 3: DrawText(\"HEMISPHERE\", 640, 10, 20, DARKBLUE); break;\n                case 4: DrawText(\"CYLINDER\", 680, 10, 20, DARKBLUE); break;\n                case 5: DrawText(\"TORUS\", 680, 10, 20, DARKBLUE); break;\n                case 6: DrawText(\"KNOT\", 680, 10, 20, DARKBLUE); break;\n                case 7: DrawText(\"POLY\", 680, 10, 20, DARKBLUE); break;\n                default: break;\n            }\n\n        EndDrawing();\n        //----------------------------------------------------------------------------------\n    }\n\n    // De-Initialization\n    //--------------------------------------------------------------------------------------\n    UnloadTexture(texture); // Unload texture\n\n    // Unload models data (GPU VRAM)\n    for (int i = 0; i < NUM_MODELS; i++) UnloadModel(models[i]);\n\n    CloseWindow();          // Close window and OpenGL context\n    //--------------------------------------------------------------------------------------\n\n    return 0;\n}", "path": "raylib/examples/models/models_mesh_generation.c", "commit_date": "2019-08-26 00:00:00", "repo_name": "raysan5/raylib", "stars": 18133, "license": "zlib", "language": "c", "size": 394813}
{"docstring": "// Draw cube\n// NOTE: Cube position is the center position\n", "func_signal": "static void DrawCube(Vector3 position, float width, float height, float length, Color color)", "code": "{\n    float x = 0.0f;\n    float y = 0.0f;\n    float z = 0.0f;\n\n    rlPushMatrix();\n\n        // NOTE: Be careful! Function order matters (rotate -> scale -> translate)\n        rlTranslatef(position.x, position.y, position.z);\n        //rlScalef(2.0f, 2.0f, 2.0f);\n        //rlRotatef(45, 0, 1, 0);\n\n        rlBegin(RL_TRIANGLES);\n            rlColor4ub(color.r, color.g, color.b, color.a);\n\n            // Front Face -----------------------------------------------------\n            rlVertex3f(x-width/2, y-height/2, z+length/2);  // Bottom Left\n            rlVertex3f(x+width/2, y-height/2, z+length/2);  // Bottom Right\n            rlVertex3f(x-width/2, y+height/2, z+length/2);  // Top Left\n\n            rlVertex3f(x+width/2, y+height/2, z+length/2);  // Top Right\n            rlVertex3f(x-width/2, y+height/2, z+length/2);  // Top Left\n            rlVertex3f(x+width/2, y-height/2, z+length/2);  // Bottom Right\n\n            // Back Face ------------------------------------------------------\n            rlVertex3f(x-width/2, y-height/2, z-length/2);  // Bottom Left\n            rlVertex3f(x-width/2, y+height/2, z-length/2);  // Top Left\n            rlVertex3f(x+width/2, y-height/2, z-length/2);  // Bottom Right\n\n            rlVertex3f(x+width/2, y+height/2, z-length/2);  // Top Right\n            rlVertex3f(x+width/2, y-height/2, z-length/2);  // Bottom Right\n            rlVertex3f(x-width/2, y+height/2, z-length/2);  // Top Left\n\n            // Top Face -------------------------------------------------------\n            rlVertex3f(x-width/2, y+height/2, z-length/2);  // Top Left\n            rlVertex3f(x-width/2, y+height/2, z+length/2);  // Bottom Left\n            rlVertex3f(x+width/2, y+height/2, z+length/2);  // Bottom Right\n\n            rlVertex3f(x+width/2, y+height/2, z-length/2);  // Top Right\n            rlVertex3f(x-width/2, y+height/2, z-length/2);  // Top Left\n            rlVertex3f(x+width/2, y+height/2, z+length/2);  // Bottom Right\n\n            // Bottom Face ----------------------------------------------------\n            rlVertex3f(x-width/2, y-height/2, z-length/2);  // Top Left\n            rlVertex3f(x+width/2, y-height/2, z+length/2);  // Bottom Right\n            rlVertex3f(x-width/2, y-height/2, z+length/2);  // Bottom Left\n\n            rlVertex3f(x+width/2, y-height/2, z-length/2);  // Top Right\n            rlVertex3f(x+width/2, y-height/2, z+length/2);  // Bottom Right\n            rlVertex3f(x-width/2, y-height/2, z-length/2);  // Top Left\n\n            // Right face -----------------------------------------------------\n            rlVertex3f(x+width/2, y-height/2, z-length/2);  // Bottom Right\n            rlVertex3f(x+width/2, y+height/2, z-length/2);  // Top Right\n            rlVertex3f(x+width/2, y+height/2, z+length/2);  // Top Left\n\n            rlVertex3f(x+width/2, y-height/2, z+length/2);  // Bottom Left\n            rlVertex3f(x+width/2, y-height/2, z-length/2);  // Bottom Right\n            rlVertex3f(x+width/2, y+height/2, z+length/2);  // Top Left\n\n            // Left Face ------------------------------------------------------\n            rlVertex3f(x-width/2, y-height/2, z-length/2);  // Bottom Right\n            rlVertex3f(x-width/2, y+height/2, z+length/2);  // Top Left\n            rlVertex3f(x-width/2, y+height/2, z-length/2);  // Top Right\n\n            rlVertex3f(x-width/2, y-height/2, z+length/2);  // Bottom Left\n            rlVertex3f(x-width/2, y+height/2, z+length/2);  // Top Left\n            rlVertex3f(x-width/2, y-height/2, z-length/2);  // Bottom Right\n        rlEnd();\n    rlPopMatrix();\n}", "path": "raylib/examples/others/rlgl_standalone.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "raysan5/raylib", "stars": 18133, "license": "zlib", "language": "c", "size": 394813}
{"docstring": "// Clamp Vector2 value with min and max and return a new vector2\n// NOTE: Required for virtual mouse, to clamp inside virtual game size\n", "func_signal": "Vector2 ClampValue(Vector2 value, Vector2 min, Vector2 max)", "code": "{\n    Vector2 result = value;\n    result.x = (result.x > max.x)? max.x : result.x;\n    result.x = (result.x < min.x)? min.x : result.x;\n    result.y = (result.y > max.y)? max.y : result.y;\n    result.y = (result.y < min.y)? min.y : result.y;\n    return result;\n}", "path": "raylib/examples/core/core_window_letterbox.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "raysan5/raylib", "stars": 18133, "license": "zlib", "language": "c", "size": 394813}
{"docstring": "// GLFW3: Keyboard callback\n", "func_signal": "static void KeyCallback(GLFWwindow *window, int key, int scancode, int action, int mods)", "code": "{\n    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)\n    {\n        glfwSetWindowShouldClose(window, GL_TRUE);\n    }\n}", "path": "raylib/examples/others/rlgl_standalone.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "raysan5/raylib", "stars": 18133, "license": "zlib", "language": "c", "size": 394813}
{"docstring": "/**\n * cockpit_memory_clear:\n *\n * The cockpit_memory_clear function overwrites LEN bytes of memory\n * pointed to by DATA with non-sensitive values.  When LEN is -1, DATA\n * must be zero-terminated and all bytes until the zero are\n * overwritten.\n *\n * This is very similar to memset but we take extra measures to\n * prevent the compiler from optimizing it away.\n *\n * See http://www.dwheeler.com/secure-class/Secure-Programs-HOWTO/protect-secrets.html\n */\n", "func_signal": "void\ncockpit_memory_clear (void * data,\n                      ssize_t len)", "code": "{\n  volatile char *vp;\n\n  if (!data)\n    return;\n\n  if (len < 0)\n    len = strlen (data);\n\n  /* Defeats some optimizations */\n  memset (data, 0xAA, len);\n  memset (data, 0xBB, len);\n\n  /* Defeats others */\n  vp = (volatile char *)data;\n  while (len--)\n    {\n      cockpit_secmem_drain |= *vp;\n      *(vp++) = 0xAA;\n    }\n}", "path": "cockpit/src/common/cockpitmemory.c", "commit_date": "2019-08-01 00:00:00", "repo_name": "cockpit-project/cockpit", "stars": 10046, "license": "lgpl-2.1", "language": "c", "size": 185096}
{"docstring": "/**\n * cockpit_frame_parse:\n * @input: An buffer of bytes\n * @length: The length of @input buffer\n * @consumed: Number of bytes consumed from @input\n *\n * Parse message framing length string from the top\n * of the @input buffer. These are used by Cockpit transport framing\n * over a stream based protocol.\n *\n * Returns: The length, zero if more data is needed, or -1 if an error.\n */\n", "func_signal": "ssize_t\ncockpit_frame_parse (unsigned char *input,\n                     size_t length,\n                     size_t *consumed)", "code": "{\n  size_t size = 0;\n  size_t i;\n\n  assert (input != NULL || length == 0);\n\n  size = 0;\n  for (i = 0; i < length; i++)\n    {\n      /* Check invalid characters, prevent integer overflow, limit max length */\n      if (i >= MAX_FRAME_SIZE_BYTES || (char)(input[i]) < '0' || (char)(input[i]) > '9')\n        break;\n      size *= 10;\n      size += (char)(input[i]) - '0';\n    }\n\n  /* Want more data */\n  if (i == length)\n    return 0;\n\n  /* Improperly formatted if any of the following cases:\n   *   - no digits read\n   *   - digits not followed by newline\n   *   - size had a leading zero\n   */\n  if (size == 0 || input[i] != '\\n' || input[0] == '0')\n    return -1;\n\n  if (consumed)\n    *consumed = i + 1;\n  return size;\n}", "path": "cockpit/src/common/cockpitframe.c", "commit_date": "2020-12-09 00:00:00", "repo_name": "cockpit-project/cockpit", "stars": 10046, "license": "lgpl-2.1", "language": "c", "size": 185096}
{"docstring": "/* See https://developer.gnome.org/glib/stable/glib-Key-value-file-parser.html for the spec */\n", "func_signal": "static bool\nload_key_file (const char *file_path)", "code": "{\n  FILE *f = NULL;\n  char *cur_section = NULL;\n  regex_t re_section, re_keyval, re_ignore;\n  char *line = NULL;\n  bool ret = true;\n  size_t line_size = 0;\n\n  cockpit_conf_loaded = true;\n\n  f = fopen (file_path, \"r\");\n  if (!f)\n    {\n      if (errno != ENOENT)\n        warnx (\"couldn't load configuration file: %s: %m\\n\", file_path);\n      return false;\n    }\n\n  regcompx (&re_section, \"^[[:space:]]*\\\\[([^][[:cntrl:]]+)\\\\][[:space:]]*$\", REG_EXTENDED|REG_NEWLINE);\n  regcompx (&re_keyval, \"^[[:space:]]*([[:alnum:]-]+)[[:space:]]*=[[:space:]]*(.*)$\", REG_EXTENDED|REG_NEWLINE);\n  regcompx (&re_ignore, \"^[[:space:]]*(#.*)?$\", REG_EXTENDED|REG_NOSUB);\n\n  for (;;)\n    {\n      /* getline returns with -1 and not setting errno on EOL */\n      errno = 0;\n      if (getline (&line, &line_size, f) < 0)\n        {\n          if (errno != 0)\n            {\n              perror (\"failed to read line from config file\");\n              abort ();\n            }\n          else\n            {\n              break; /* EOL */\n            }\n        }\n\n      /* maximum number of () matches that we want to capture from the above REs, + 1 for the entire string (group 0) */\n      const int MAX_MATCH = 3;\n      regmatch_t matches[MAX_MATCH];\n\n      if (regexec (&re_section, line, MAX_MATCH, matches, 0) == 0)\n        {\n          free (cur_section);\n          cur_section = strndupx (line + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so);\n        }\n\n      else if (regexec (&re_keyval, line, 3, matches, 0) == 0)\n        {\n          Entry *e;\n\n          if (!cur_section)\n            {\n              warnx (\"%s: key=val line not in any section: %s\", file_path, line);\n              ret = false;\n              break;\n            }\n\n          e = mallocx (sizeof (Entry));\n          e->section = strdupx (cur_section);\n          e->key = strndupx (line + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so);\n          e->value = strndupx (line + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so);\n          e->strv_value = NULL;\n          e->strv_cache = NULL;\n          /* prepend new Entry to cockpit_conf; that way, later values win over earlier ones in a forward search */\n          e->next = cockpit_conf;\n          cockpit_conf = e;\n        }\n\n      else if (regexec (&re_ignore, line, 0, NULL, 0) == 0)\n        {\n          /* comment or empty line */\n        }\n      else\n        {\n          warnx (\"%s: invalid line: %s\", file_path, line);\n          ret = false;\n          break;\n        }\n    }\n\n  free (line);\n  regfree (&re_section);\n  regfree (&re_keyval);\n  regfree (&re_ignore);\n  fclose (f);\n  free (cur_section);\n\n  if (ret)\n    debug (\"Loaded configuration from: %s\\n\", file_path);\n  else\n    cockpit_conf_cleanup ();\n\n  return ret;\n}", "path": "cockpit/src/common/cockpitconf.c", "commit_date": "2019-06-17 00:00:00", "repo_name": "cockpit-project/cockpit", "stars": 10046, "license": "lgpl-2.1", "language": "c", "size": 185096}
{"docstring": "/**\n * cockpit_channel_send:\n * @self: a pipe\n * @payload: the message payload to send\n * @trust_is_utf8: set to true if sure data is UTF8\n *\n * Called by implementations to send a message over the transport\n * on the right channel.\n *\n * This message is queued, and sent once the transport can.\n */\n", "func_signal": "void\ncockpit_channel_send (CockpitChannel *self,\n                      GBytes *payload,\n                      gboolean trust_is_utf8)", "code": "{\n  CockpitChannelPrivate *priv = cockpit_channel_get_instance_private (self);\n  const guint8 *data;\n  gsize length;\n  GBytes *send_data = payload;\n  GByteArray *combined;\n\n  if (priv->buffer_timeout)\n    g_source_remove(priv->buffer_timeout);\n  priv->buffer_timeout = 0;\n\n  if (priv->out_buffer)\n    {\n      combined = g_bytes_unref_to_array (priv->out_buffer);\n      priv->out_buffer = NULL;\n\n      data = g_bytes_get_data (payload, &length);\n      g_byte_array_append (combined, data, length);\n      send_data = g_byte_array_free_to_bytes (combined);\n\n      trust_is_utf8 = FALSE;\n    }\n\n  if (!trust_is_utf8 && !priv->binary_ok)\n    {\n      if (cockpit_unicode_has_incomplete_ending (send_data))\n        {\n          priv->out_buffer = g_bytes_ref (send_data);\n          priv->buffer_timeout = g_timeout_add (500, flush_buffer, self);\n        }\n    }\n\n  if (!priv->buffer_timeout)\n    cockpit_channel_actual_send (self, send_data, trust_is_utf8);\n\n  if (send_data != payload)\n    g_bytes_unref (send_data);\n}", "path": "cockpit/src/common/cockpitchannel.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "cockpit-project/cockpit", "stars": 10046, "license": "lgpl-2.1", "language": "c", "size": 185096}
{"docstring": "/**\n * cockpit_channel_close:\n * @self: a channel\n * @problem: the problem or NULL\n *\n * Close the channel. This can be called multiple times.\n *\n * It may be that the channel doesn't close immediately.\n * The channel will emit the CockpitChannel::closed signal when the\n * channel actually closes.\n *\n * If this is called immediately after or during construction then\n * the closing will happen after the main loop so that handlers\n * can connect appropriately.\n *\n * A @problem of NULL represents an orderly close.\n */\n", "func_signal": "void\ncockpit_channel_close (CockpitChannel *self,\n                       const gchar *problem)", "code": "{\n  CockpitChannelPrivate *priv = cockpit_channel_get_instance_private (self);\n  CockpitChannelClass *klass;\n\n  g_return_if_fail (COCKPIT_IS_CHANNEL (self));\n\n  /* No further messages should be received */\n  if (priv->recv_sig)\n    g_signal_handler_disconnect (priv->transport, priv->recv_sig);\n  priv->recv_sig = 0;\n\n  if (priv->control_sig)\n    g_signal_handler_disconnect (priv->transport, priv->control_sig);\n  priv->control_sig = 0;\n\n  if (priv->close_sig)\n    g_signal_handler_disconnect (priv->transport, priv->close_sig);\n  priv->close_sig = 0;\n\n  klass = COCKPIT_CHANNEL_GET_CLASS (self);\n  g_assert (klass->close != NULL);\n  priv->emitted_close = TRUE;\n  (klass->close) (self, problem);\n}", "path": "cockpit/src/common/cockpitchannel.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "cockpit-project/cockpit", "stars": 10046, "license": "lgpl-2.1", "language": "c", "size": 185096}
{"docstring": "/* DEBUG_BATCHES */\n", "func_signal": "static void\nbatch_free (BatchData *batch)", "code": "{\n#if DEBUG_BATCHES\n  g_slist_foreach (batch->debug, (GFunc)g_free, NULL);\n#endif\n  g_slice_free (BatchData, batch);\n}", "path": "cockpit/src/bridge/cockpitdbuscache.c", "commit_date": "2019-11-18 00:00:00", "repo_name": "cockpit-project/cockpit", "stars": 10046, "license": "lgpl-2.1", "language": "c", "size": 185096}
{"docstring": "/* D-Bus interface */\n", "func_signal": "static GVariant *\npackages_get_manifests (CockpitPackages *packages)", "code": "{\n  GBytes *content = cockpit_json_write_bytes (packages->json);\n  GVariant *manifests = g_variant_new (\"s\", g_bytes_get_data (content, NULL));\n  g_bytes_unref (content);\n  return manifests;\n}", "path": "cockpit/src/bridge/cockpitpackages.c", "commit_date": "2020-09-29 00:00:00", "repo_name": "cockpit-project/cockpit", "stars": 10046, "license": "lgpl-2.1", "language": "c", "size": 185096}
{"docstring": "/**\n * cockpit_channel_close_options\n * @self: a channel\n *\n * Called by implementations to get the channel's close options.\n *\n * Returns: (transfer none): the close options, should not be NULL\n */\n", "func_signal": "JsonObject *\ncockpit_channel_close_options (CockpitChannel *self)", "code": "{\n  CockpitChannelPrivate *priv = cockpit_channel_get_instance_private (self);\n\n  g_return_val_if_fail (COCKPIT_IS_CHANNEL (self), NULL);\n  if (!priv->close_options)\n    priv->close_options = json_object_new ();\n  return priv->close_options;\n}", "path": "cockpit/src/common/cockpitchannel.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "cockpit-project/cockpit", "stars": 10046, "license": "lgpl-2.1", "language": "c", "size": 185096}
{"docstring": "/**\n * cockpit_certificate_parse:\n *\n * Load the ws certificate file, and split it into the private key and\n * certificates PEM strings.\n *\n * Return 0 on success, or -errno on failure. This can be an error from open()\n * or read(), or ENOKEY if private key is missing.\n */\n", "func_signal": "int\ncockpit_certificate_parse (const char *file, char **cert, char **key)", "code": "{\n  int fd = -1;\n  char *data = NULL;\n  ssize_t r;\n  int ret = 0;\n  const char *start, *end, *footer;\n  struct stat buf;\n\n  /* load the entire file */\n  fd = open (file, O_RDONLY);\n  if (fd < 0)\n    return -errno;\n\n  if (fstat (fd, &buf) < 0)\n    {\n      ret = -errno;\n      goto out;\n    }\n\n  if (!S_ISREG (buf.st_mode))\n    {\n      ret = -EBADF;\n      goto out;\n    }\n\n  if (buf.st_size >= SSIZE_MAX)\n    {\n      ret = -ENOMEM;\n      goto out;\n    }\n\n  data = mallocx (buf.st_size + 1);\n\n  do\n    {\n      r = read (fd, data, buf.st_size);\n    }\n  while (r < 0 && errno == EINTR);\n\n  if (r < 0)\n    {\n      ret = -errno;\n      goto out;\n    }\n\n  close (fd);\n  fd = -1;\n\n  assert (r <= buf.st_size);\n  data[r] = '\\0';\n\n  *cert = NULL;\n  *key = NULL;\n\n  /* find the private key; we ignore/reject encrypted private keys */\n  start = strstr (data, PEM_PKCS1_PRIVKEY_HEADER);\n  if (start)\n    footer = PEM_PKCS1_PRIVKEY_FOOTER;\n  else\n    {\n      start = strstr (data, PEM_PKCS1_ECCKEY_HEADER);\n      if (start)\n        footer = PEM_PKCS1_ECCKEY_FOOTER;\n      else\n        {\n          start = strstr (data, PEM_PKCS8_PRIVKEY_HEADER);\n          if (start)\n            footer = PEM_PKCS8_PRIVKEY_FOOTER;\n          else\n            {\n              ret = -ENOKEY;\n              goto out;\n            }\n        }\n    }\n\n  end = strstr (start, footer);\n  if (!end)\n    {\n      ret = -ENOKEY;\n      goto out;\n    }\n  end += strlen (footer);\n  while (*end == '\\r' || *end == '\\n')\n    end++;\n\n  /* cut out the private key */\n  *key = strndupx (start, end - start);\n\n  /* everything else before and after is the public key */\n  asprintfx(cert, \"%.*s%s\", (int) (start - data), data, end);\n\nout:\n  if (fd >= 0)\n    close (fd);\n  free (data);\n  return ret;\n}", "path": "cockpit/src/common/cockpitwebcertificate.c", "commit_date": "2020-01-18 00:00:00", "repo_name": "cockpit-project/cockpit", "stars": 10046, "license": "lgpl-2.1", "language": "c", "size": 185096}
{"docstring": "/**\n * cockpit_certificate_locate:\n *\n * Find Cockpit web server certificate in $XDG_CONFIG_DIRS/cockpit/ws-certs.d/.\n * The asciibetically latest *.crt or *.cert file wins.\n *\n * Return certificate path on success, or %NULL on error; in the latter case,\n * @error gets set to an error message.\n */\n", "func_signal": "char *\ncockpit_certificate_locate (char **error)", "code": "{\n  const char * const *dirs = cockpit_conf_get_dirs ();\n\n  *error = NULL;\n\n  for (int i = 0; dirs[i]; i++)\n    {\n      char *cert_dir;\n      char *cert_path;\n\n      asprintfx (&cert_dir, \"%s/cockpit/ws-certs.d\", dirs[i]);\n      cert_path = load_cert_from_dir (cert_dir, error);\n      free (cert_dir);\n\n      if (*error != NULL)\n        return NULL;\n\n      if (cert_path)\n        return cert_path;\n    }\n\n  asprintfx (error, \"No certificate found in dir: %s/cockpit/ws-certs.d\", dirs[0]);\n  return NULL;\n}", "path": "cockpit/src/common/cockpitwebcertificate.c", "commit_date": "2020-01-18 00:00:00", "repo_name": "cockpit-project/cockpit", "stars": 10046, "license": "lgpl-2.1", "language": "c", "size": 185096}
{"docstring": "/**\n * cockpit_certificate_key_path:\n *\n * Return key file path for given certfile, i. e. replace \".crt\" or \".cert\"\n * suffix with \".key\". Invalid names exit the program. All usages of this\n * function in our code control the file name, so that should not happen.\n */\n", "func_signal": "char *\ncockpit_certificate_key_path (const char *certfile)", "code": "{\n  int len = strlen (certfile);\n  char *keypath = NULL;\n\n  /* .cert suffix case: chop off suffix, append \".key\" */\n  if (len > 5 && strcmp (certfile + len - 5, \".cert\") == 0)\n    asprintfx (&keypath, \"%.*s.key\", len - 5, certfile);\n  /* *.crt suffix case */\n  else if (len > 4 && strcmp (certfile + len - 4, \".crt\") == 0)\n    asprintfx (&keypath, \"%.*s.key\", len - 4, certfile);\n  else\n    errx (EXIT_FAILURE, \"internal error: invalid certificate file name: %s\", certfile);\n\n  return keypath;\n}", "path": "cockpit/src/common/cockpitwebcertificate.c", "commit_date": "2020-01-18 00:00:00", "repo_name": "cockpit-project/cockpit", "stars": 10046, "license": "lgpl-2.1", "language": "c", "size": 185096}
{"docstring": "/* TODO: this should be optimized so we don't allocate memory and call open()/close() all the time */\n", "func_signal": "void\ncockpit_cpu_samples (CockpitSamples *samples)", "code": "{\n  gchar *contents = NULL;\n  GError *error = NULL;\n  gchar **lines = NULL;\n  guint64 user_hz;\n  gsize len;\n  guint n;\n\n  if (!g_file_get_contents (\"/proc/stat\", &contents, &len, &error))\n    {\n      g_message (\"error loading contents /proc/stat: %s\", error->message);\n      g_error_free (error);\n      goto out;\n    }\n\n  /* see 'man proc' for the format of /proc/stat */\n\n  lines = g_strsplit (contents, \"\\n\", -1);\n  for (n = 0; lines != NULL && lines[n] != NULL; n++)\n    {\n      const gchar *line = lines[n];\n      guint64 user;\n      guint64 nice;\n      guint64 system;\n      guint64 idle;\n      guint64 iowait;\n\n      if (!(g_str_has_prefix (line, \"cpu \")))\n        continue;\n\n      #define FMT64 \"%\" G_GUINT64_FORMAT \" \"\n      if (sscanf (line + sizeof (\"cpu \") - 1, FMT64 FMT64 FMT64 FMT64 FMT64,\n                  &user,\n                  &nice,\n                  &system,\n                  &idle,\n                  &iowait) != 5)\n        {\n          g_warning (\"Error parsing line %d of /proc/stat with content `%s'\", n, line);\n          continue;\n        }\n\n      user_hz = ensure_user_hz ();\n      cockpit_samples_sample (samples, \"cpu.basic.nice\", NULL, nice*1000/user_hz);\n      cockpit_samples_sample (samples, \"cpu.basic.user\", NULL, user*1000/user_hz);\n      cockpit_samples_sample (samples, \"cpu.basic.system\", NULL, system*1000/user_hz);\n      cockpit_samples_sample (samples, \"cpu.basic.iowait\", NULL, iowait*1000/user_hz);\n      break;\n    }\n\nout:\n  g_strfreev (lines);\n  g_free (contents);\n}", "path": "cockpit/src/bridge/cockpitcpusamples.c", "commit_date": "2015-03-18 00:00:00", "repo_name": "cockpit-project/cockpit", "stars": 10046, "license": "lgpl-2.1", "language": "c", "size": 185096}
{"docstring": "/**\n * cockpit_channel_prepare:\n * @self: the channel\n *\n * Usually this is automatically called after the channel is\n * created and control returns to the mainloop. However you\n * can preempt that by calling this function. In the case of\n * a frozen channel, this method needs to be called to set\n * things in motion.\n */\n", "func_signal": "void\ncockpit_channel_prepare (CockpitChannel *self)", "code": "{\n  CockpitChannelPrivate *priv = cockpit_channel_get_instance_private (self);\n  CockpitChannelClass *klass;\n\n  g_return_if_fail (COCKPIT_IS_CHANNEL (self));\n\n  if (priv->prepared)\n    return;\n\n  if (priv->prepare_tag)\n    {\n      g_source_remove (priv->prepare_tag);\n      priv->prepare_tag = 0;\n    }\n\n  priv->prepared = TRUE;\n  if (!priv->emitted_close)\n    {\n      klass = COCKPIT_CHANNEL_GET_CLASS (self);\n      g_assert (klass->prepare);\n      (klass->prepare) (self);\n    }\n}", "path": "cockpit/src/common/cockpitchannel.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "cockpit-project/cockpit", "stars": 10046, "license": "lgpl-2.1", "language": "c", "size": 185096}
{"docstring": "/* this is like reallocarray(3), but this does not yet exist everywhere; plus\n * abort() on ENOMEM */\n", "func_signal": "void *\nreallocarrayx (void *ptr,\n               size_t nmemb,\n               size_t size)", "code": "{\n  void *r;\n\n  if (nmemb >= SIZE_MAX / size)\n    {\n      fprintf (stderr, \"reallocarr: overflow (nmemb %zu)\\n\", nmemb);\n      abort ();\n    }\n  r = realloc (ptr, nmemb * size);\n  if (r == NULL)\n    abort_errno (\"failed to allocate memory for realloc\");\n  return r;\n}", "path": "cockpit/src/common/cockpitmemory.c", "commit_date": "2019-08-01 00:00:00", "repo_name": "cockpit-project/cockpit", "stars": 10046, "license": "lgpl-2.1", "language": "c", "size": 185096}
{"docstring": "/**\n * cockpit_channel_get_option:\n * @self: a channel\n *\n * Called by implementations to get the channel's open options.\n *\n * Returns: (transfer none): the open options, should not be NULL\n */\n", "func_signal": "JsonObject *\ncockpit_channel_get_options (CockpitChannel *self)", "code": "{\n  CockpitChannelPrivate *priv = cockpit_channel_get_instance_private (self);\n\n  g_return_val_if_fail (COCKPIT_IS_CHANNEL (self), NULL);\n  return priv->open_options;\n}", "path": "cockpit/src/common/cockpitchannel.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "cockpit-project/cockpit", "stars": 10046, "license": "lgpl-2.1", "language": "c", "size": 185096}
{"docstring": "/**\n * cockpit_packages_get_bridges:\n * @packages: The packages object\n *\n * Get a list of configured \"bridges\" JSON config objects in\n * the order of priority. See doc/guide/ for the actual format\n * of the JSON objects.\n *\n * Returns: (transfer container): A list of JSONObject each owned\n *          by CockpitPackages. Free with g_list_free() when done.\n */\n", "func_signal": "GList *\ncockpit_packages_get_bridges (CockpitPackages *packages)", "code": "{\n  CockpitPackage *package;\n  GList *l, *listing;\n  GList *result = NULL;\n  JsonArray *bridges;\n  JsonArray *bridge;\n  JsonObject *item;\n  JsonObject *match;\n  gboolean privileged;\n  const gchar *problem;\n  JsonNode *node;\n  guint i;\n\n  g_return_val_if_fail (packages != NULL, NULL);\n\n  listing = g_hash_table_get_values (packages->listing);\n  listing = g_list_sort_with_data (listing, compar_package_priority, NULL);\n  listing = g_list_reverse (listing);\n\n  /* Convert every package to the equivalent bridge listing */\n  for (l = listing; l != NULL; l = g_list_next (l))\n    {\n      package = l->data;\n      if (!cockpit_json_get_array (package->manifest, \"bridges\", NULL, &bridges))\n        {\n          g_message (\"%s: invalid \\\"bridges\\\" field in package manifest\", package->name);\n          continue;\n        }\n\n      for (i = 0; bridges && i < json_array_get_length (bridges); i++)\n        {\n          node = json_array_get_element (bridges, i);\n          if (!node || !JSON_NODE_HOLDS_OBJECT (node))\n            {\n              g_message (\"%s: invalid bridge in \\\"bridges\\\" field in package manifest\", package->name);\n              continue;\n            }\n\n          item = json_node_get_object (node);\n          if (!cockpit_json_get_array (item, \"spawn\", NULL, &bridge))\n            {\n              g_message (\"%s: invalid \\\"spawn\\\" field in package manifest\", package->name);\n            }\n          else if (!cockpit_json_get_array (item, \"environ\", NULL, &bridge))\n            {\n              g_message (\"%s: invalid \\\"environ\\\" field in package manifest\", package->name);\n            }\n          else if (!cockpit_json_get_object (item, \"match\", NULL, &match))\n            {\n              g_message (\"%s: invalid \\\"match\\\" field in package manifest\", package->name);\n            }\n          else if (!cockpit_json_get_bool (item, \"privileged\", FALSE, &privileged))\n            {\n              g_message (\"%s: invalid \\\"privileged\\\" field in package manifest\", package->name);\n            }\n          else if ((match == NULL) != privileged)\n            {\n              g_message (\"%s: Exactly one of \\\"match\\\" or \\\"privileged\\\" required\", package->name);\n            }\n          else if (!cockpit_json_get_string (item, \"problem\", NULL, &problem))\n            {\n              g_message (\"%s: invalid \\\"problem\\\" field in package manifest\", package->name);\n            }\n          else\n            {\n              result = g_list_prepend (result, item);\n            }\n        }\n    }\n\n  g_list_free (listing);\n  return g_list_reverse (result);\n}", "path": "cockpit/src/bridge/cockpitpackages.c", "commit_date": "2020-09-29 00:00:00", "repo_name": "cockpit-project/cockpit", "stars": 10046, "license": "lgpl-2.1", "language": "c", "size": 185096}
{"docstring": "/**\n * cockpit_channel_control:\n * @self: the channel\n * @command: the control command\n * @options: optional control message or NULL\n *\n * Send a control message to the other side.\n *\n * If @options is not NULL, then it may be modified by this code.\n *\n * With @command of \"done\" will send an EOF to the other side. This\n * should only be called once. Whether an EOF should be sent or not\n * depends on the payload type.\n */\n", "func_signal": "void\ncockpit_channel_control (CockpitChannel *self,\n                         const gchar *command,\n                         JsonObject *options)", "code": "{\n  CockpitChannelPrivate *priv = cockpit_channel_get_instance_private (self);\n  JsonObject *object;\n  GBytes *message;\n  const gchar *problem = NULL;\n  gchar *problem_copy = NULL;\n\n  g_return_if_fail (COCKPIT_IS_CHANNEL (self));\n  g_return_if_fail (command != NULL);\n\n  if (g_str_equal (command, \"done\"))\n    {\n      g_return_if_fail (priv->sent_done == FALSE);\n      priv->sent_done = TRUE;\n    }\n\n  /* If closing save the close options\n   * and let close send the message */\n  else if (g_str_equal (command, \"close\"))\n    {\n      if (options)\n        {\n          if (!priv->close_options)\n            {\n              /* Ref for close_options, freed in parent */\n              priv->close_options = json_object_ref (options);\n            }\n\n          if (!cockpit_json_get_string (options, \"problem\", NULL, &problem))\n            problem = NULL;\n        }\n\n      /* Use a problem copy so it out lasts the value in close_options */\n      problem_copy = g_strdup (problem);\n      cockpit_channel_close (self, problem_copy);\n      goto out;\n    }\n\n  if (options)\n    object = json_object_ref (options);\n  else\n    object = json_object_new ();\n\n  json_object_set_string_member (object, \"command\", command);\n  json_object_set_string_member (object, \"channel\", priv->id);\n\n  message = cockpit_json_write_bytes (object);\n  json_object_unref (object);\n\n  cockpit_transport_send (priv->transport, NULL, message);\n  g_bytes_unref (message);\n\nout:\n  g_free (problem_copy);\n}", "path": "cockpit/src/common/cockpitchannel.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "cockpit-project/cockpit", "stars": 10046, "license": "lgpl-2.1", "language": "c", "size": 185096}
{"docstring": "/* For optimization, this modifies string; the returned array has pointers into string\n * The array itself gets allocated and must be freed after use. */\n", "func_signal": "static const char **\nstrsplit (char *string, char delimiter)", "code": "{\n  const char ** parts = reallocarrayx (NULL, 2, sizeof (char*));\n  char *cur = string;\n  bool done = false;\n  unsigned len = 0;\n\n  /* backwards compatible special case: a totally empty string gives [], while \":\" splits into [\"\", \"\"] */\n  if (string && *string)\n    {\n      while (!done)\n        {\n          char *next_delim = strchr (cur, delimiter);\n\n          if (next_delim)\n            *next_delim = '\\0';\n          else\n            done = true;\n\n          parts = reallocarrayx (parts, len + 2, sizeof (char*));\n          parts[len++] = cur;\n\n          if (next_delim)\n            cur = next_delim + 1;\n        }\n    }\n\n  parts[len] = NULL;\n  return parts;\n}", "path": "cockpit/src/common/cockpitconf.c", "commit_date": "2019-06-17 00:00:00", "repo_name": "cockpit-project/cockpit", "stars": 10046, "license": "lgpl-2.1", "language": "c", "size": 185096}
{"docstring": "/*\n * cockpit_channel_fail:\n * @self: a channel\n * @problem: the problem\n *\n * Close the channel with a @problem. In addition a \"message\" field\n * will be set on the channel, using the @format argument to build\n * the message. The message will also be logged.\n *\n * See cockpit_channel_close() for further info.\n */\n", "func_signal": "void\ncockpit_channel_fail (CockpitChannel *self,\n                      const gchar *problem,\n                      const gchar *format,\n                      ...)", "code": "{\n  CockpitChannelPrivate *priv = cockpit_channel_get_instance_private (self);\n  JsonObject *options;\n  gchar *message;\n  va_list va;\n\n  g_return_if_fail (problem != NULL);\n  g_return_if_fail (COCKPIT_IS_CHANNEL (self));\n\n  va_start (va, format);\n  message = g_strdup_vprintf (format, va);\n  va_end (va);\n\n  options = cockpit_channel_close_options (self);\n  if (!json_object_has_member (options, \"message\"))\n    json_object_set_string_member (options, \"message\", message);\n  g_message (\"%s: %s\", priv->id, message);\n  g_free (message);\n\n  cockpit_channel_close (self, problem);\n}", "path": "cockpit/src/common/cockpitchannel.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "cockpit-project/cockpit", "stars": 10046, "license": "lgpl-2.1", "language": "c", "size": 185096}
{"docstring": "/**\n * SECTION:cockpiterror\n * @title: CockpitError\n * @short_description: Possible errors that can be returned\n *\n * Error codes.\n */\n", "func_signal": "GQuark\ncockpit_error_quark (void)", "code": "{\n  static GQuark domain = 0;\n  static volatile gsize quark_volatile = 0;\n\n  if (g_once_init_enter (&quark_volatile)) {\n      domain = g_quark_from_static_string (\"cockpit-error\");\n      g_once_init_leave (&quark_volatile, 1);\n  }\n\n  return domain;\n}", "path": "cockpit/src/common/cockpiterror.c", "commit_date": "2016-11-28 00:00:00", "repo_name": "cockpit-project/cockpit", "stars": 10046, "license": "lgpl-2.1", "language": "c", "size": 185096}
{"docstring": "// See comment on pollfd_freelist for context\n", "func_signal": "static void poll_fd_free(struct poll_fd *poll_fd)", "code": "{\n    struct poll *poll = poll_fd->poll;\n    memset(poll_fd, 0xba, sizeof(*poll_fd));\n    poll_fd->poll = NULL; // used to mark it as free\n    list_add(&poll->pollfd_freelist, &poll_fd->fds);\n}", "path": "ish/fs/poll.c", "commit_date": "2020-06-27 00:00:00", "repo_name": "ish-app/ish", "stars": 15648, "license": "other", "language": "c", "size": 5053}
{"docstring": "// FIXME this looks like it has the classic refcount UAF\n", "func_signal": "void fdtable_release(struct fdtable *table)", "code": "{\n    lock(&table->lock);\n    if (--table->refcount == 0) {\n        for (fd_t f = 0; (unsigned) f < table->size; f++)\n            fdtable_close(table, f);\n        free(table->files);\n        free(table->cloexec);\n        unlock(&table->lock);\n        free(table);\n    } else {\n        unlock(&table->lock);\n    }\n}", "path": "ish/fs/fd.c", "commit_date": "2020-05-23 00:00:00", "repo_name": "ish-app/ish", "stars": 15648, "license": "other", "language": "c", "size": 5053}
{"docstring": "// always called from init process\n", "func_signal": "static void halt_system(void)", "code": "{\n    // brutally murder everything\n    // which will leave everything in an inconsistent state. I will solve this problem later.\n    for (int i = 2; i < MAX_PID; i++) {\n        struct task *task = pid_get_task(i);\n        if (task != NULL)\n            pthread_kill(task->thread, SIGKILL);\n    }\n\n    // unmount all filesystems\n    lock(&mounts_lock);\n    struct mount *mount, *tmp;\n    list_for_each_entry_safe(&mounts, mount, tmp, mounts) {\n        mount_remove(mount);\n    }\n    unlock(&mounts_lock);\n}", "path": "ish/kernel/exit.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "ish-app/ish", "stars": 15648, "license": "other", "language": "c", "size": 5053}
{"docstring": "// FIXME: this is shit\n", "func_signal": "bool mount_param_flag(const char *info, const char *flag)", "code": "{\n    while (*info != '\\0') {\n        if (strncmp(info, flag, strlen(flag)) == 0)\n            return true;\n        info += strcspn(info, \",\");\n    }\n    return false;\n}", "path": "ish/fs/mount.c", "commit_date": "2020-04-13 00:00:00", "repo_name": "ish-app/ish", "stars": 15648, "license": "other", "language": "c", "size": 5053}
{"docstring": "// Returns stopped child with the given pid, locked with the ptrace lock\n", "func_signal": "static struct task *find_child(pid_t_ pid)", "code": "{\n    struct task *child = NULL;\n    list_for_each_entry(&current->children, child, siblings) {\n        if (child->pid == pid) {\n            lock(&child->ptrace.lock);\n            if (child->ptrace.stopped) {\n                goto found;\n            }\n\n            unlock(&child->ptrace.lock);\n        }\n    }\n    child = NULL;\nfound:\n    return child;\n}", "path": "ish/kernel/ptrace.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "ish-app/ish", "stars": 15648, "license": "other", "language": "c", "size": 5053}
{"docstring": "// Dan Bernstein's simple and decently effective hash function\n", "func_signal": "static uint32_t str_hash(const char *str)", "code": "{\n    uint32_t hash = 5381;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        hash = 33 * hash ^ str[i];\n    }\n    return hash;\n}", "path": "ish/fs/sock.c", "commit_date": "2020-08-23 00:00:00", "repo_name": "ish-app/ish", "stars": 15648, "license": "other", "language": "c", "size": 5053}
{"docstring": "// TODO: should this function even exist? can't tmpfs_dir_link check for existence?\n", "func_signal": "static int tmpfs_dir_lookup_existence(struct tmp_dirent *dir, const char *name)", "code": "{\n    struct tmp_dirent *dirent = tmpfs_dir_lookup(dir, name);\n    if (dirent == ERR_PTR(_ENOENT))\n        return 0;\n    if (IS_ERR(dirent))\n        return PTR_ERR(dirent);\n    tmp_dirent_release(dirent);\n    return _EEXIST;\n}", "path": "ish/fs/tmp.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "ish-app/ish", "stars": 15648, "license": "other", "language": "c", "size": 5053}
{"docstring": "// lock order: fd, then poll\n", "func_signal": "struct poll *poll_create()", "code": "{\n    struct poll *poll = malloc(sizeof(struct poll));\n    if (poll == NULL)\n        return ERR_PTR(_ENOMEM);\n    int err = real_poll_init(&poll->real);\n    if (err < 0)\n        return ERR_PTR(errno_map());\n    poll->waiters = 0;\n    poll->notify_pipe[0] = -1;\n    poll->notify_pipe[1] = -1;\n    list_init(&poll->poll_fds);\n    list_init(&poll->pollfd_freelist);\n    lock_init(&poll->lock);\n    return poll;\n}", "path": "ish/fs/poll.c", "commit_date": "2020-06-27 00:00:00", "repo_name": "ish-app/ish", "stars": 15648, "license": "other", "language": "c", "size": 5053}
{"docstring": "/* specific precise single step test */\n", "func_signal": "void sig_trap_handler(int sig, siginfo_t *info, void *puc)", "code": "{\n    ucontext_t *uc = puc;\n    printf(\"EIP=\" FMTLX \"\\n\", (long)uc->uc_mcontext.gregs[REG_EIP]);\n}", "path": "ish/tests/e2e/qemu/qemu-test.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "ish-app/ish", "stars": 15648, "license": "other", "language": "c", "size": 5053}
{"docstring": "/* various jump tests */\n", "func_signal": "void test_jcc(void)", "code": "{\n    TEST_JCC(\"ne\", 1, 1);\n    TEST_JCC(\"ne\", 1, 0);\n\n    TEST_JCC(\"e\", 1, 1);\n    TEST_JCC(\"e\", 1, 0);\n\n    TEST_JCC(\"l\", 1, 1);\n    TEST_JCC(\"l\", 1, 0);\n    TEST_JCC(\"l\", 1, -1);\n\n    TEST_JCC(\"le\", 1, 1);\n    TEST_JCC(\"le\", 1, 0);\n    TEST_JCC(\"le\", 1, -1);\n\n    TEST_JCC(\"ge\", 1, 1);\n    TEST_JCC(\"ge\", 1, 0);\n    TEST_JCC(\"ge\", -1, 1);\n\n    TEST_JCC(\"g\", 1, 1);\n    TEST_JCC(\"g\", 1, 0);\n    TEST_JCC(\"g\", 1, -1);\n\n    TEST_JCC(\"b\", 1, 1);\n    TEST_JCC(\"b\", 1, 0);\n    TEST_JCC(\"b\", 1, -1);\n\n    TEST_JCC(\"be\", 1, 1);\n    TEST_JCC(\"be\", 1, 0);\n    TEST_JCC(\"be\", 1, -1);\n\n    TEST_JCC(\"ae\", 1, 1);\n    TEST_JCC(\"ae\", 1, 0);\n    TEST_JCC(\"ae\", 1, -1);\n\n    TEST_JCC(\"a\", 1, 1);\n    TEST_JCC(\"a\", 1, 0);\n    TEST_JCC(\"a\", 1, -1);\n\n\n    TEST_JCC(\"p\", 1, 1);\n    TEST_JCC(\"p\", 1, 0);\n\n    TEST_JCC(\"np\", 1, 1);\n    TEST_JCC(\"np\", 1, 0);\n\n    TEST_JCC(\"o\", 0x7fffffff, 0);\n    TEST_JCC(\"o\", 0x7fffffff, -1);\n\n    TEST_JCC(\"no\", 0x7fffffff, 0);\n    TEST_JCC(\"no\", 0x7fffffff, -1);\n\n    TEST_JCC(\"s\", 0, 1);\n    TEST_JCC(\"s\", 0, -1);\n    TEST_JCC(\"s\", 0, 0);\n\n    TEST_JCC(\"ns\", 0, 1);\n    TEST_JCC(\"ns\", 0, -1);\n    TEST_JCC(\"ns\", 0, 0);\n}", "path": "ish/tests/e2e/qemu/qemu-test.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "ish-app/ish", "stars": 15648, "license": "other", "language": "c", "size": 5053}
{"docstring": "// Frees the child inode on failure, so you don't need to! But be careful you don't free it yourself.\n// In other words: Takes ownership of `child`\n", "func_signal": "static int tmpfs_dir_link(struct tmp_dirent *dir, const char *name, struct tmp_inode *child, struct tmp_dirent **dirent_out)", "code": "{\n    if (!S_ISDIR(dir->inode->stat.mode)) {\n        tmp_inode_release(child);\n        return _ENOTDIR;\n    }\n    struct tmp_dirent *new_dirent = malloc(sizeof(struct tmp_dirent));\n    if (new_dirent == NULL) {\n        tmp_inode_release(child);\n        return _ENOMEM;\n    }\n\n    tmp_dirent_init(new_dirent);\n    strcpy(new_dirent->name, name);\n    new_dirent->inode = tmp_inode_retain(child);\n    new_dirent->index = dir->next_index++;\n    new_dirent->parent = tmp_dirent_retain(dir);\n    list_add_tail(&dir->children, &new_dirent->dir);\n\n    if (dirent_out)\n        *dirent_out = tmp_dirent_retain(new_dirent);\n    return 0;\n}", "path": "ish/fs/tmp.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "ish-app/ish", "stars": 15648, "license": "other", "language": "c", "size": 5053}
{"docstring": "// Remove all pointers to the block. It can't be freed yet because another\n// thread may be executing it.\n", "func_signal": "static void jit_block_disconnect(struct jit *jit, struct jit_block *block)", "code": "{\n    if (jit != NULL) {\n        jit->mem_used -= block->used;\n        jit->num_blocks--;\n    }\n    list_remove(&block->chain);\n    for (int i = 0; i <= 1; i++) {\n        list_remove(&block->page[i]);\n        list_remove_safe(&block->jumps_from_links[i]);\n\n        struct jit_block *prev_block, *tmp;\n        list_for_each_entry_safe(&block->jumps_from[i], prev_block, tmp, jumps_from_links[i]) {\n            if (prev_block->jump_ip[i] != NULL)\n                *prev_block->jump_ip[i] = prev_block->old_jump_ip[i];\n            list_remove(&prev_block->jumps_from_links[i]);\n        }\n    }\n}", "path": "ish/jit/jit.c", "commit_date": "2020-12-21 00:00:00", "repo_name": "ish-app/ish", "stars": 15648, "license": "other", "language": "c", "size": 5053}
{"docstring": "// does not do its own locking\n", "func_signal": "static struct poll_fd *poll_find_fd(struct poll *poll, struct fd *fd)", "code": "{\n    struct poll_fd *poll_fd, *tmp;\n    list_for_each_entry_safe(&poll->poll_fds, poll_fd, tmp, fds) {\n        if (poll_fd->fd == fd)\n            return poll_fd;\n    }\n    return NULL;\n}", "path": "ish/fs/poll.c", "commit_date": "2020-06-27 00:00:00", "repo_name": "ish-app/ish", "stars": 15648, "license": "other", "language": "c", "size": 5053}
{"docstring": "// returns false if the task cannot be reaped and true if the task was reaped\n", "func_signal": "static bool reap_if_zombie(struct task *task, struct siginfo_ *info_out, struct rusage_ *rusage_out, int options)", "code": "{\n    if (!task->zombie)\n        return false;\n    lock(&task->group->lock);\n\n    dword_t exit_code = task->exit_code;\n    if (task->group->doing_group_exit)\n        exit_code = task->group->group_exit_code;\n    info_out->child.status = exit_code;\n\n    struct rusage_ rusage = task->group->rusage;\n    if (!(options & WNOWAIT_)) {\n        lock(&current->group->lock);\n        rusage_add(&current->group->children_rusage, &rusage);\n        unlock(&current->group->lock);\n    }\n    if (rusage_out != NULL)\n        *rusage_out = rusage;\n\n    unlock(&task->group->lock);\n\n    // WNOWAIT means don't destroy the child, instead leave it so it could be waited for again.\n    if (options & WNOWAIT_)\n        return true;\n\n    // tear down group\n    cond_destroy(&task->group->child_exit);\n    task_leave_session(task);\n    list_remove(&task->group->pgroup);\n    free(task->group);\n\n    task_destroy(task);\n    return true;\n}", "path": "ish/kernel/exit.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "ish-app/ish", "stars": 15648, "license": "other", "language": "c", "size": 5053}
{"docstring": "// TODO error propagation\n", "func_signal": "static struct task *construct_task(struct task *parent)", "code": "{\n    struct task *task = task_create_(parent);\n\n    struct tgroup *group = malloc(sizeof(struct tgroup));\n    *group = (struct tgroup) {};\n    list_init(&group->threads);\n    lock_init(&group->lock);\n    cond_init(&group->child_exit);\n    cond_init(&group->stopped_cond);\n    memcpy(group->limits, init_rlimits, sizeof(init_rlimits));\n    group->leader = task;\n    group->personality = ADDR_NO_RANDOMIZE_;\n    list_add(&group->threads, &task->group_links);\n    task->group = group;\n    task->tgid = task->pid;\n    task_setsid(task);\n\n    task_set_mm(task, mm_new());\n    task->sighand = sighand_new();\n    task->files = fdtable_new(3); // why is there a 3 here\n\n    task->fs = fs_info_new();\n    task->fs->umask = 0022;\n    // we'll need to have current set to do the open call\n    struct task *old_current = current;\n    current = task;\n    task->fs->root = generic_open(\"/\", O_RDONLY_, 0);\n    if (IS_ERR(task->fs->root))\n        return ERR_PTR(task->fs->root);\n    task->fs->pwd = fd_retain(task->fs->root);\n    current = old_current;\n\n    return task;\n}", "path": "ish/kernel/init.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "ish-app/ish", "stars": 15648, "license": "other", "language": "c", "size": 5053}
{"docstring": "// This is the only place where a tmpfs directory tree is recursively freed.\n", "func_signal": "static void tmpfs_unmount_tree(struct tmp_inode *tree)", "code": "{\n    assert(refcount_get(tree) == 1); // otherwise mount_remove should have returned EBUSY\n    if (S_ISDIR(tree->stat.mode)) {\n        struct tmp_dirent *dirent, *tmp;\n        list_for_each_entry_safe(&tree->dir.entries, dirent, tmp, dir) {\n            if (dirent->inode != NULL)\n                tmpfs_unmount_tree(dirent->inode);\n            tmp_dirent_release(dirent);\n        }\n    }\n    tmp_inode_release(tree);\n}", "path": "ish/fs/tmp.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "ish-app/ish", "stars": 15648, "license": "other", "language": "c", "size": 5053}
{"docstring": "//#define FPUS_EMASK 0x007f\n", "func_signal": "void test_fcmp(double a, double b)", "code": "{\n    long eflags, fpus;\n\n    fpu_clear_exceptions();\n    asm(\"fcom %2\\n\"\n        \"fstsw %%ax\\n\"\n        : \"=a\" (fpus)\n        : \"t\" (a), \"u\" (b));\n    printf(\"fcom(%f %f)=%04lx\\n\",\n           a, b, fpus & (0x4500 | FPUS_EMASK));\n    fpu_clear_exceptions();\n    asm(\"fucom %2\\n\"\n        \"fstsw %%ax\\n\"\n        : \"=a\" (fpus)\n        : \"t\" (a), \"u\" (b));\n    printf(\"fucom(%f %f)=%04lx\\n\",\n           a, b, fpus & (0x4500 | FPUS_EMASK));\n    if (TEST_FCOMI) {\n        /* test f(u)comi instruction */\n        fpu_clear_exceptions();\n        asm(\"fcomi %3, %2\\n\"\n            \"fstsw %%ax\\n\"\n            \"pushf\\n\"\n            \"pop %0\\n\"\n            : \"=r\" (eflags), \"=a\" (fpus)\n            : \"t\" (a), \"u\" (b));\n        printf(\"fcomi(%f %f)=%04lx %02lx\\n\",\n               a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C));\n        fpu_clear_exceptions();\n        asm(\"fucomi %3, %2\\n\"\n            \"fstsw %%ax\\n\"\n            \"pushf\\n\"\n            \"pop %0\\n\"\n            : \"=r\" (eflags), \"=a\" (fpus)\n            : \"t\" (a), \"u\" (b));\n        printf(\"fucomi(%f %f)=%04lx %02lx\\n\",\n               a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C));\n    }\n    fpu_clear_exceptions();\n    asm volatile(\"fxam\\n\"\n                 \"fstsw %%ax\\n\"\n                 : \"=a\" (fpus)\n                 : \"t\" (a));\n    printf(\"fxam(%f)=%04lx\\n\", a, fpus & 0x4700);\n    fpu_clear_exceptions();\n}", "path": "ish/tests/e2e/qemu/qemu-test.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "ish-app/ish", "stars": 15648, "license": "other", "language": "c", "size": 5053}
{"docstring": "// Ensure stopped, ptrace locked, etc. before calling this\n", "func_signal": "static void set_user_regs(struct cpu_state *cpu, struct user_regs_struct_ *user_regs_)", "code": "{\n    cpu->ebx = user_regs_->ebx;\n    cpu->ecx = user_regs_->ecx;\n    cpu->edx = user_regs_->edx;\n    cpu->esi = user_regs_->esi;\n    cpu->edi = user_regs_->edi;\n    cpu->ebp = user_regs_->ebp;\n    cpu->eax = user_regs_->eax;\n//  cpu->xds = user_regs_->xds;\n//  cpu->xes = user_regs_->xes;\n//  cpu->xfs = user_regs_->xfs;\n//  cpu->xgs = user_regs_->xgs;\n//  cpu->eax = user_regs_->orig_eax;\n    cpu->eip = user_regs_->eip;\n//  cpu->xcs = user_regs_->xcs;\n    cpu->eflags = user_regs_->eflags;\n    cpu->esp = user_regs_->esp;\n//  cpu->xss = user_regs_->xss;\n}", "path": "ish/kernel/ptrace.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "ish-app/ish", "stars": 15648, "license": "other", "language": "c", "size": 5053}
{"docstring": "// I hate this code\n", "func_signal": "static bool path_normalize(const char *path, char *out)", "code": "{\n#define ends_path(c) (c == '\\0' || c == '/')\n    // normalized format:\n    // ( '/' path-component ) *\n    while (path[0] != '\\0') {\n        while (path[0] == '/')\n            path++;\n        if (path[0] == '\\0')\n            break; // if the path ends with a slash\n        // path points to the start of a path component\n        if (path[0] == '.' && path[1] == '.' && ends_path(path[2]))\n            return false; // no dotdot allowed!\n        if (path[0] == '.' && ends_path(path[1])) {\n            path++;\n        } else {\n            *out++ = '/';\n            while (path[0] != '/' && path[0] != '\\0')\n                *out++ = *path++;\n        }\n    }\n    *out = '\\0';\n    return true;\n}", "path": "ish/tools/fakefs.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "ish-app/ish", "stars": 15648, "license": "other", "language": "c", "size": 5053}
{"docstring": "// Ensure stopped, ptrace locked, etc. before calling this\n", "func_signal": "static void get_user_regs(struct cpu_state *cpu, struct user_regs_struct_ *user_regs_)", "code": "{\n    user_regs_->ebx = cpu->ebx;\n    user_regs_->ecx = cpu->ecx;\n    user_regs_->edx = cpu->edx;\n    user_regs_->esi = cpu->esi;\n    user_regs_->edi = cpu->edi;\n    user_regs_->ebp = cpu->ebp;\n    user_regs_->eax = cpu->eax;\n//  user_regs_->xds = cpu->xds;\n//  user_regs_->xes = cpu->xes;\n//  user_regs_->xfs = cpu->xfs;\n//  user_regs_->xgs = cpu->xgs;\n    user_regs_->orig_eax = cpu->eax;\n    user_regs_->eip = cpu->eip;\n//  user_regs_->xcs = cpu->xcs;\n    user_regs_->eflags = cpu->eflags;\n    user_regs_->esp = cpu->esp;\n//  user_regs_->xss = cpu->xss;\n}", "path": "ish/kernel/ptrace.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "ish-app/ish", "stars": 15648, "license": "other", "language": "c", "size": 5053}
{"docstring": "/**\n * Applies configuration to teletypewriter.\n *\n * @param opt_out_oldconf is only modified if successful\n * @return 0 on success, or -1 w/ errno\n * @see ttyconfig(), ttyrestore()\n */\n", "func_signal": "int ttyconfig(int ttyfd, ttyconf_f fn, int64_t arg,\n              const struct termios *opt_out_oldconf)", "code": "{\n  struct termios conf[2];\n  if (tcgetattr(ttyfd, &conf[0]) != -1 &&\n      fn(memcpy(&conf[1], &conf[0], sizeof(conf[0])), arg) != -1 &&\n      tcsetattr(ttyfd, TCSAFLUSH, &conf[1]) != -1) {\n    if (opt_out_oldconf) {\n      memcpy(opt_out_oldconf, &conf[0], sizeof(conf[0]));\n    }\n    return 0;\n  } else {\n    return -1;\n  }\n}", "path": "cosmopolitan/dsp/tty/config.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "jart/cosmopolitan", "stars": 14195, "license": "isc", "language": "c", "size": 304982}
{"docstring": "/* TODO(jart): DELETE */\n", "func_signal": "static int ttysetcursor(int fd, bool visible)", "code": "{\n  struct NtConsoleCursorInfo ntcursor;\n  char code[8] = \"\\e[?25l\";\n  if (isterminalinarticulate()) return 0;\n  if (visible) code[5] = 'h';\n  if (SupportsWindows()) {\n    GetConsoleCursorInfo(GetStdHandle(kNtStdOutputHandle), &ntcursor);\n    ntcursor.bVisible = visible;\n    SetConsoleCursorInfo(GetStdHandle(kNtStdOutputHandle), &ntcursor);\n  }\n  return ttysend(fd, code);\n}", "path": "cosmopolitan/dsp/tty/hidecursor.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "jart/cosmopolitan", "stars": 14195, "license": "isc", "language": "c", "size": 304982}
{"docstring": "/* Use the ESC [6n escape sequence to query the horizontal cursor position\n * and return it. On error -1 is returned, on success the position of the\n * cursor is stored at *rows and *cols and 0 is returned. */\n", "func_signal": "int getCursorPosition(int64_t ifd, int64_t ofd, int *rows, int *cols)", "code": "{\n  char buf[32];\n  unsigned i = 0;\n\n  /* Report cursor location */\n  if (write(ofd, \"\\e[6n\", 4) != 4) return -1;\n\n  /* Read the response: ESC [ rows ; cols R */\n  while (i < sizeof(buf) - 1) {\n    if (read(ifd, buf + i, 1) != 1) break;\n    if (buf[i] == 'R') break;\n    i++;\n  }\n  buf[i] = '\\0';\n\n  /* Parse it. */\n  if (buf[0] != CTRL('[') || buf[1] != '[') return -1;\n  if (sscanf(buf + 2, \"%d;%d\", rows, cols) != 2) return -1;\n  return 0;\n}", "path": "cosmopolitan/examples/kilo.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "jart/cosmopolitan", "stars": 14195, "license": "isc", "language": "c", "size": 304982}
{"docstring": "/* Save the current file on disk. Return 0 on success, 1 on error. */\n", "func_signal": "int editorSave(void)", "code": "{\n  int len;\n  char *buf = editorRowsToString(&len);\n  int64_t fd = open(E.filename, O_RDWR | O_CREAT, 0644);\n  if (fd == -1) goto writeerr;\n\n  /* Use truncate + a single write(2) call in order to make saving\n   * a bit safer, under the limits of what we can do in a small editor. */\n  if (ftruncate(fd, len) == -1) goto writeerr;\n  if (write(fd, buf, len) != len) goto writeerr;\n\n  close(fd);\n  free(buf);\n  E.dirty = 0;\n  editorSetStatusMessage(\"%d bytes written on disk\", len);\n  return 0;\n\nwriteerr:\n  free(buf);\n  if (fd != -1) close(fd);\n  editorSetStatusMessage(\"Can't save! I/O error: %s\", strerror(errno));\n  return 1;\n}", "path": "cosmopolitan/examples/kilo.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "jart/cosmopolitan", "stars": 14195, "license": "isc", "language": "c", "size": 304982}
{"docstring": "/**\n * Computes \ud835\udc00\u207b\u00b9 inverted 3\u00d73 matrix, if it exists.\n *\n * @param \ud835\udc01 is destination memory\n * @param \ud835\udc00 is input matrix, which can't overlap \ud835\udc01\n * @param \ud835\udc51 is |\ud835\udc00| the determinant scalar or 0 if degenerate\n * @return \ud835\udc00\u207b\u00b9 stored inside \ud835\udc01 or NaNs if \ud835\udc51=0\n * @define \ud835\udc00\u207b\u00b9=\ud835\udc01 such that \ud835\udc00\u00d7\ud835\udc01=\ud835\udc01\u00d7\ud835\udc00=\ud835\udc08\u2099\n * @see det3()\n */\n", "func_signal": "void *inv3(double B[restrict 3][3], const double A[restrict 3][3], double d)", "code": "{\n  d = d ? 1 / d : NAN;\n  B[0][0] = (A[1][1] * A[2][2] - A[2][1] * A[1][2]) * d;\n  B[0][1] = (A[2][1] * A[0][2] - A[0][1] * A[2][2]) * d;\n  B[0][2] = (A[0][1] * A[1][2] - A[1][1] * A[0][2]) * d;\n  B[1][0] = (A[2][0] * A[1][2] - A[1][0] * A[2][2]) * d;\n  B[1][1] = (A[0][0] * A[2][2] - A[2][0] * A[0][2]) * d;\n  B[1][2] = (A[1][0] * A[0][2] - A[0][0] * A[1][2]) * d;\n  B[2][0] = (A[1][0] * A[2][1] - A[2][0] * A[1][1]) * d;\n  B[2][1] = (A[2][0] * A[0][1] - A[0][0] * A[2][1]) * d;\n  B[2][2] = (A[0][0] * A[1][1] - A[1][0] * A[0][1]) * d;\n  return B;\n}", "path": "cosmopolitan/dsp/core/inv3.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "jart/cosmopolitan", "stars": 14195, "license": "isc", "language": "c", "size": 304982}
{"docstring": "/**\n * Makes educated guess about name of teletypewriter.\n */\n", "func_signal": "char *ttydescribe(char *out, size_t size, const struct TtyIdent *ti)", "code": "{\n  char b1[BUFFY], b2[BUFFY];\n  if (ti) {\n    ttydescriber(b1, ti);\n    if (ti->next) {\n      snprintf(out, size, \"%s%s%s\", ttydescriber(b2, ti->next), \" inside \", b1);\n    } else {\n      snprintf(out, size, \"%s\", b1);\n    }\n  } else {\n    snprintf(out, size, \"%s\", \"no tty\");\n  }\n  return out;\n}", "path": "cosmopolitan/dsp/tty/describe.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "jart/cosmopolitan", "stars": 14195, "license": "isc", "language": "c", "size": 304982}
{"docstring": "/* Delete the char at the current prompt position. */\n", "func_signal": "void editorDelChar(void)", "code": "{\n  int filerow = E.rowoff + E.cy;\n  int filecol = E.coloff + E.cx;\n  erow *row = (filerow >= E.numrows) ? NULL : &E.row[filerow];\n\n  if (!row || (filecol == 0 && filerow == 0)) return;\n  if (filecol == 0) {\n    /* Handle the case of column 0, we need to move the current line\n     * on the right of the previous one. */\n    filecol = E.row[filerow - 1].size;\n    editorRowAppendString(&E.row[filerow - 1], row->chars, row->size);\n    editorDelRow(filerow);\n    row = NULL;\n    if (E.cy == 0)\n      E.rowoff--;\n    else\n      E.cy--;\n    E.cx = filecol;\n    if (E.cx >= E.screencols) {\n      int shift = (E.screencols - E.cx) + 1;\n      E.cx -= shift;\n      E.coloff += shift;\n    }\n  } else {\n    editorRowDelChar(row, filecol - 1);\n    if (E.cx == 0 && E.coloff)\n      E.coloff--;\n    else\n      E.cx--;\n  }\n  if (row) editorUpdateRow(row);\n  E.dirty++;\n}", "path": "cosmopolitan/examples/kilo.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "jart/cosmopolitan", "stars": 14195, "license": "isc", "language": "c", "size": 304982}
{"docstring": "/* Raw mode: 1960 magic shit. */\n", "func_signal": "int enableRawMode(int64_t fd)", "code": "{\n  struct termios raw;\n\n  if (E.rawmode) return 0; /* Already enabled. */\n  if (!isatty(STDIN_FILENO)) goto fatal;\n  atexit(editorAtExit);\n  if (tcgetattr(fd, &orig_termios) == -1) goto fatal;\n\n  raw = orig_termios; /* modify the original mode */\n  /* input modes: no break, no CR to NL, no parity check, no strip char,\n   * no start/stop output control. */\n  raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);\n  /* output modes - disable post processing */\n  raw.c_oflag &= ~(OPOST);\n  /* control modes - set 8 bit chars */\n  raw.c_cflag |= (CS8);\n  /* local modes - choing off, canonical off, no extended functions,\n   * no signal chars (^Z,^C) */\n  raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);\n  /* control chars - set return condition: min number of bytes and timer. */\n  raw.c_cc[VMIN] = 0;  /* Return each byte, or zero for timeout. */\n  raw.c_cc[VTIME] = 1; /* 100 ms timeout (unit is tens of second). */\n\n  /* put terminal in raw mode after flushing */\n  if (tcsetattr(fd, TCSAFLUSH, &raw) < 0) goto fatal;\n  E.rawmode = 1;\n  return 0;\n\nfatal:\n  errno = ENOTTY;\n  return -1;\n}", "path": "cosmopolitan/examples/kilo.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "jart/cosmopolitan", "stars": 14195, "license": "isc", "language": "c", "size": 304982}
{"docstring": "/* Load the specified program in the editor memory and returns 0 on success\n * or 1 on error. */\n", "func_signal": "int editorOpen(char *filename)", "code": "{\n  FILE *fp;\n\n  E.dirty = 0;\n  free(E.filename);\n  E.filename = strdup(filename);\n\n  fp = fopen(filename, \"r\");\n  if (!fp) {\n    if (errno != ENOENT) {\n      perror(\"Opening file\");\n      exit(1);\n    }\n    return 1;\n  }\n\n  char *line = NULL;\n  size_t linecap = 0;\n  ssize_t linelen;\n  while ((linelen = getline(&line, &linecap, fp)) != -1) {\n    if (linelen && (line[linelen - 1] == '\\n' || line[linelen - 1] == '\\r'))\n      line[--linelen] = '\\0';\n    editorInsertRow(E.numrows, line, linelen);\n  }\n  free(line);\n  fclose(fp);\n  E.dirty = 0;\n  return 0;\n}", "path": "cosmopolitan/examples/kilo.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "jart/cosmopolitan", "stars": 14195, "license": "isc", "language": "c", "size": 304982}
{"docstring": "/* Insert a row at the specified position, shifting the other rows on the bottom\n * if required. */\n", "func_signal": "void editorInsertRow(int at, char *s, size_t len)", "code": "{\n  if (at > E.numrows) return;\n  E.row = realloc(E.row, sizeof(erow) * (E.numrows + 1));\n  if (at != E.numrows) {\n    memmove(E.row + at + 1, E.row + at, sizeof(E.row[0]) * (E.numrows - at));\n    for (int j = at + 1; j <= E.numrows; j++) E.row[j].idx++;\n  }\n  E.row[at].size = len;\n  E.row[at].chars = malloc(len + 1);\n  memcpy(E.row[at].chars, s, len + 1);\n  E.row[at].hl = NULL;\n  E.row[at].hl_oc = 0;\n  E.row[at].render = NULL;\n  E.row[at].rsize = 0;\n  E.row[at].idx = at;\n  editorUpdateRow(E.row + at);\n  E.numrows++;\n  E.dirty++;\n}", "path": "cosmopolitan/examples/kilo.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "jart/cosmopolitan", "stars": 14195, "license": "isc", "language": "c", "size": 304982}
{"docstring": "/* This function writes the whole screen using VT100 escape characters\n * starting from the logical state of the editor in the global state 'E'. */\n", "func_signal": "void editorRefreshScreen(void)", "code": "{\n  int y;\n  erow *r;\n  char buf[32];\n  struct abuf ab;\n\n  memset(&ab, 0, sizeof(ab));\n  abAppend(&ab, \"\\e[?25l\", 6); /* Hide cursor. */\n  abAppend(&ab, \"\\e[H\", 3);    /* Go home. */\n  for (y = 0; y < E.screenrows; y++) {\n    int filerow = E.rowoff + y;\n\n    if (filerow >= E.numrows) {\n      if (E.numrows == 0 && y == E.screenrows / 3) {\n        char welcome[80];\n        int welcomelen =\n            snprintf(welcome, sizeof(welcome),\n                     \"Kilo editor -- verison %s\\e[0K\\r\\n\", KILO_VERSION);\n        int padding = (E.screencols - welcomelen) / 2;\n        if (padding) {\n          abAppend(&ab, \"~\", 1);\n          padding--;\n        }\n        while (padding--) abAppend(&ab, \" \", 1);\n        abAppend(&ab, welcome, welcomelen);\n      } else {\n        abAppend(&ab, \"~\\e[0K\\r\\n\", 7);\n      }\n      continue;\n    }\n\n    r = &E.row[filerow];\n\n    int len = r->rsize - E.coloff;\n#if SYNTAX\n    int current_color = -1;\n#endif\n    if (len > 0) {\n      if (len > E.screencols) len = E.screencols;\n      char *c = r->render + E.coloff;\n#if SYNTAX\n      unsigned char *hl = r->hl + E.coloff;\n#endif\n      int j;\n      for (j = 0; j < len; j++) {\n#if SYNTAX\n        if (hl[j] == HL_NONPRINT) {\n          char sym;\n          abAppend(&ab, \"\\e[7m\", 4);\n          if (c[j] <= 26)\n            sym = '@' + c[j];\n          else\n            sym = '?';\n          abAppend(&ab, &sym, 1);\n          abAppend(&ab, \"\\e[0m\", 4);\n        } else if (hl[j] == HL_NORMAL) {\n          if (current_color != -1) {\n            abAppend(&ab, \"\\e[39m\", 5);\n            current_color = -1;\n          }\n#endif\n          abAppend(&ab, c + j, 1);\n#if SYNTAX\n        } else {\n          int color = editorSyntaxToColor(hl[j]);\n          if (color != current_color) {\n            char buf_[16];\n            int clen = snprintf(buf_, sizeof(buf_), \"\\e[%dm\", color);\n            current_color = color;\n            abAppend(&ab, buf_, clen);\n          }\n          abAppend(&ab, c + j, 1);\n        }\n#endif\n      }\n    }\n    abAppend(&ab, \"\\e[39m\", 5);\n    abAppend(&ab, \"\\e[0K\", 4);\n    abAppend(&ab, \"\\r\\n\", 2);\n  }\n\n  /* Create a two rows status. First row: */\n  abAppend(&ab, \"\\e[0K\", 4);\n  abAppend(&ab, \"\\e[7m\", 4);\n  char status[80], rstatus[80];\n  int len = snprintf(status, sizeof(status), \"%.20s - %d lines %s\", E.filename,\n                     E.numrows, E.dirty ? \"(modified)\" : \"\");\n  int rlen = snprintf(rstatus, sizeof(rstatus), \"%d/%d\", E.rowoff + E.cy + 1,\n                      E.numrows);\n  if (len > E.screencols) len = E.screencols;\n  abAppend(&ab, status, len);\n  while (len < E.screencols) {\n    if (E.screencols - len == rlen) {\n      abAppend(&ab, rstatus, rlen);\n      break;\n    } else {\n      abAppend(&ab, \" \", 1);\n      len++;\n    }\n  }\n  abAppend(&ab, \"\\e[0m\\r\\n\", 6);\n\n  /* Second row depends on E.statusmsg and the status message update time. */\n  abAppend(&ab, \"\\e[0K\", 4);\n  int msglen = strlen(E.statusmsg);\n  if (msglen && time(NULL) - E.statusmsg_time < 5)\n    abAppend(&ab, E.statusmsg, msglen <= E.screencols ? msglen : E.screencols);\n\n  /* Put cursor at its current position. Note that the horizontal position\n   * at which the cursor is displayed may be different compared to 'E.cx'\n   * because of TABs. */\n  int j;\n  int cx = 1;\n  int filerow = E.rowoff + E.cy;\n  erow *row = (filerow >= E.numrows) ? NULL : &E.row[filerow];\n  if (row) {\n    for (j = E.coloff; j < (E.cx + E.coloff); j++) {\n      if (j < row->size && row->chars[j] == CTRL('I')) cx += 7 - ((cx) % 8);\n      cx++;\n    }\n  }\n  snprintf(buf, sizeof(buf), \"\\e[%d;%dH\", E.cy + 1, cx);\n  abAppend(&ab, buf, strlen(buf));\n  abAppend(&ab, \"\\e[?25h\", 6); /* Show cursor. */\n  write(STDOUT_FILENO, ab.p, ab.i);\n  free(ab.p);\n}", "path": "cosmopolitan/examples/kilo.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "jart/cosmopolitan", "stars": 14195, "license": "isc", "language": "c", "size": 304982}
{"docstring": "/**\n * Multiplies 3\u00d73 matrices.\n */\n", "func_signal": "void *matmul3(double R[restrict 3][3], const double A[3][3],\n              const double B[3][3])", "code": "{\n  int i, j, k;\n  memset(R, 0, sizeof(double) * 3 * 3);\n  for (i = 0; i < 3; ++i) {\n    for (j = 0; j < 3; ++j) {\n      for (k = 0; k < 3; ++k) {\n        R[i][j] += A[k][j] * B[i][k];\n      }\n    }\n  }\n  return R;\n}", "path": "cosmopolitan/dsp/core/matmul3.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "jart/cosmopolitan", "stars": 14195, "license": "isc", "language": "c", "size": 304982}
{"docstring": "/* Remove the row at the specified position, shifting the remainign on the\n * top. */\n", "func_signal": "void editorDelRow(int at)", "code": "{\n  erow *row;\n\n  if (at >= E.numrows) return;\n  row = E.row + at;\n  editorFreeRow(row);\n  memmove(E.row + at, E.row + at + 1, sizeof(E.row[0]) * (E.numrows - at - 1));\n  for (int j = at; j < E.numrows - 1; j++) E.row[j].idx++;\n  E.numrows--;\n  E.dirty++;\n}", "path": "cosmopolitan/examples/kilo.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "jart/cosmopolitan", "stars": 14195, "license": "isc", "language": "c", "size": 304982}
{"docstring": "/* Inserting a newline is slightly complex as we have to handle inserting a\n * newline in the middle of a line, splitting the line as needed. */\n", "func_signal": "void editorInsertNewline(void)", "code": "{\n  int filerow = E.rowoff + E.cy;\n  int filecol = E.coloff + E.cx;\n  erow *row = (filerow >= E.numrows) ? NULL : &E.row[filerow];\n\n  if (!row) {\n    if (filerow == E.numrows) {\n      editorInsertRow(filerow, \"\", 0);\n      goto fixcursor;\n    }\n    return;\n  }\n  /* If the cursor is over the current line size, we want to conceptually\n   * think it's just over the last character. */\n  if (filecol >= row->size) filecol = row->size;\n  if (filecol == 0) {\n    editorInsertRow(filerow, \"\", 0);\n  } else {\n    /* We are in the middle of a line. Split it between two rows. */\n    editorInsertRow(filerow + 1, row->chars + filecol, row->size - filecol);\n    row = &E.row[filerow];\n    row->chars[filecol] = '\\0';\n    row->size = filecol;\n    editorUpdateRow(row);\n  }\nfixcursor:\n  if (E.cy == E.screenrows - 1) {\n    E.rowoff++;\n  } else {\n    E.cy++;\n  }\n  E.cx = 0;\n  E.coloff = 0;\n}", "path": "cosmopolitan/examples/kilo.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "jart/cosmopolitan", "stars": 14195, "license": "isc", "language": "c", "size": 304982}
{"docstring": "/**\n * Sets raw mode, safely, the easy way.\n *\n * This should be called after your signal handlers have been installed.\n */\n", "func_signal": "textstartup int ttyraw(enum TtyRawFlags flags)", "code": "{\n  int rc;\n  if ((g_ttyraw.flags = flags) != -1) {\n    if (!g_ttyraw.initialized) {\n      g_ttyraw.initialized = true;\n      ttyraw_init();\n    }\n    if ((rc = ttyraw_enable()) != -1) {\n      ttyraw_hidecursor();\n    }\n  } else {\n    rc = ttyraw_disable();\n  }\n  return rc;\n}", "path": "cosmopolitan/dsp/tty/ttyraw.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "jart/cosmopolitan", "stars": 14195, "license": "isc", "language": "c", "size": 304982}
{"docstring": "/* Select the syntax highlight scheme depending on the filename,\n * setting it in the global state E.syntax. */\n", "func_signal": "void editorSelectSyntaxHighlight(char *filename)", "code": "{\n  for (unsigned j = 0; j < HLDB_ENTRIES; j++) {\n    struct editorSyntax *s = HLDB + j;\n    unsigned i = 0;\n    while (s->filematch[i]) {\n      char *p;\n      int patlen = strlen(s->filematch[i]);\n      if ((p = strstr(filename, s->filematch[i])) != NULL) {\n        if (s->filematch[i][0] != '.' || p[patlen] == '\\0') {\n          E.syntax = s;\n          return;\n        }\n      }\n      i++;\n    }\n  }\n}", "path": "cosmopolitan/examples/kilo.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "jart/cosmopolitan", "stars": 14195, "license": "isc", "language": "c", "size": 304982}
{"docstring": "/* Maps syntax highlight token types to terminal colors. */\n", "func_signal": "int editorSyntaxToColor(int hl)", "code": "{\n  switch (hl) {\n    case HL_COMMENT:\n    case HL_MLCOMMENT:\n      return 36; /* cyan */\n    case HL_KEYWORD1:\n      return 33; /* yellow */\n    case HL_KEYWORD2:\n      return 32; /* green */\n    case HL_STRING:\n      return 35; /* magenta */\n    case HL_NUMBER:\n      return 31; /* red */\n    case HL_MATCH:\n      return 34; /* blu */\n    default:\n      return 37; /* white */\n  }\n}", "path": "cosmopolitan/examples/kilo.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "jart/cosmopolitan", "stars": 14195, "license": "isc", "language": "c", "size": 304982}
{"docstring": "/* Append the string 's' at the end of a row */\n", "func_signal": "void editorRowAppendString(erow *row, char *s, size_t len)", "code": "{\n  row->chars = realloc(row->chars, row->size + len + 1);\n  memcpy(row->chars + row->size, s, len);\n  row->size += len;\n  row->chars[row->size] = '\\0';\n  editorUpdateRow(row);\n  E.dirty++;\n}", "path": "cosmopolitan/examples/kilo.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "jart/cosmopolitan", "stars": 14195, "license": "isc", "language": "c", "size": 304982}
{"docstring": "/* Turn the editor rows into a single heap-allocated string.\n * Returns the pointer to the heap-allocated string and populate the\n * integer pointed by 'buflen' with the size of the string, escluding\n * the final nulterm. */\n", "func_signal": "char *editorRowsToString(int *buflen)", "code": "{\n  char *buf = NULL, *p;\n  int totlen = 0;\n  int j;\n\n  /* Compute count of bytes */\n  for (j = 0; j < E.numrows; j++) {\n    totlen += E.row[j].size + 1; /* +1 is for \"\\n\" at end of every row */\n  }\n  *buflen = totlen;\n  totlen++; /* Also make space for nulterm */\n\n  p = buf = malloc(totlen);\n  for (j = 0; j < E.numrows; j++) {\n    memcpy(p, E.row[j].chars, E.row[j].size);\n    p += E.row[j].size;\n    *p = '\\n';\n    p++;\n  }\n  *p = '\\0';\n  return buf;\n}", "path": "cosmopolitan/examples/kilo.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "jart/cosmopolitan", "stars": 14195, "license": "isc", "language": "c", "size": 304982}
{"docstring": "/* clang-format off */\n// ----------------------------------------------------------------------------\n// plm_demux implementation\n", "func_signal": "plm_demux_t *plm_demux_create(plm_buffer_t *buffer, int destroy_when_done)", "code": "{\n\tplm_demux_t *self = (plm_demux_t *)malloc(sizeof(plm_demux_t));\n\tmemset(self, 0, sizeof(plm_demux_t));\n\n\tself->buffer = buffer;\n\tself->destroy_buffer_when_done = destroy_when_done;\n\n\tif (plm_buffer_find_start_code(self->buffer, START_PACK) != -1) {\n\t\tplm_demux_decode_pack_header(self);\n\t}\n\tif (plm_buffer_find_start_code(self->buffer, START_SYSTEM) != -1) {\n\t\tplm_demux_decode_system_header(self);\n\t}\n\treturn self;\n}", "path": "cosmopolitan/dsp/mpeg/demux.c", "commit_date": "2020-06-15 00:00:00", "repo_name": "jart/cosmopolitan", "stars": 14195, "license": "isc", "language": "c", "size": 304982}
{"docstring": "/*\n**++\n**  FUNCTIONAL DESCRIPTION:\n**\n**      This function puts the SMC37c669 Super I/O controller into,\n**\tand takes it out of, configuration mode.\n**\n**  FORMAL PARAMETERS:\n**\n**      enable:\n**          TRUE to enter configuration mode, FALSE to exit.\n**\n**  RETURN VALUE:\n**\n**      None\n**\n**  SIDE EFFECTS:\n**\n**      The SMC37c669 controller may be left in configuration mode.\n**\n**--\n*/\n", "func_signal": "static void __init SMC37c669_config_mode( \n    unsigned int enable )", "code": "{\n    if ( enable ) {\n/*\n** To enter configuration mode, two writes in succession to the index\n** port are required.  If a write to another address or port occurs\n** between these two writes, the chip does not enter configuration\n** mode.  Therefore, a spinlock is placed around the two writes to \n** guarantee that they complete uninterrupted.\n*/\n\tspin_lock(&smc_lock);\n    \twb( &SMC37c669->index_port, SMC37c669_CONFIG_ON_KEY );\n    \twb( &SMC37c669->index_port, SMC37c669_CONFIG_ON_KEY );\n\tspin_unlock(&smc_lock);\n    }\n    else {\n    \twb( &SMC37c669->index_port, SMC37c669_CONFIG_OFF_KEY );\n    }\n}", "path": "linux-rpi-6.1.y/arch/alpha/kernel/smc37c669.c", "commit_date": "2019-04-23 00:00:00", "repo_name": "raspberrypi/linux", "stars": 10528, "license": "other", "language": "c", "size": 3940105}
{"docstring": "/*\n**++\n**  FUNCTIONAL DESCRIPTION:\n**\n**      This function initializes the local device\n**\tconfiguration storage.  This function assumes\n**\tthat the device is already in configuration\n**\tmode.\n**\n**  FORMAL PARAMETERS:\n**\n**      None\n**\n**  RETURN VALUE:\n**\n**      None\n**\n**  SIDE EFFECTS:\n**\n**      Local storage for device configuration information\n**\tis initialized.\n**\n**--\n*/\n", "func_signal": "static void __init SMC37c669_init_local_config ( void )", "code": "{\n    SMC37c669_SERIAL_BASE_ADDRESS_REGISTER uart_base;\n    SMC37c669_SERIAL_IRQ_REGISTER uart_irqs;\n    SMC37c669_PARALLEL_BASE_ADDRESS_REGISTER ppt_base;\n    SMC37c669_PARALLEL_FDC_IRQ_REGISTER ppt_fdc_irqs;\n    SMC37c669_PARALLEL_FDC_DRQ_REGISTER ppt_fdc_drqs;\n    SMC37c669_FDC_BASE_ADDRESS_REGISTER fdc_base;\n    SMC37c669_IDE_ADDRESS_REGISTER ide_base;\n    SMC37c669_IDE_ADDRESS_REGISTER ide_alt;\n\n/*\n** Get serial port 1 base address \n*/\n    uart_base.as_uchar = \n\tSMC37c669_read_config( SMC37c669_SERIAL0_BASE_ADDRESS_INDEX );\n/*\n** Get IRQs for serial ports 1 & 2\n*/\n    uart_irqs.as_uchar = \n\tSMC37c669_read_config( SMC37c669_SERIAL_IRQ_INDEX );\n/*\n** Store local configuration information for serial port 1\n*/\n    local_config[SERIAL_0].port1 = uart_base.by_field.addr9_3 << 3;\n    local_config[SERIAL_0].irq = \n\tSMC37c669_xlate_irq( \n\t    SMC37c669_DEVICE_IRQ( uart_irqs.by_field.uart1_irq ) \n\t);\n/*\n** Get serial port 2 base address\n*/\n    uart_base.as_uchar = \n\tSMC37c669_read_config( SMC37c669_SERIAL1_BASE_ADDRESS_INDEX );\n/*\n** Store local configuration information for serial port 2\n*/\n    local_config[SERIAL_1].port1 = uart_base.by_field.addr9_3 << 3;\n    local_config[SERIAL_1].irq = \n\tSMC37c669_xlate_irq( \n\t    SMC37c669_DEVICE_IRQ( uart_irqs.by_field.uart2_irq ) \n\t);\n/*\n** Get parallel port base address\n*/\n    ppt_base.as_uchar =\n\tSMC37c669_read_config( SMC37c669_PARALLEL0_BASE_ADDRESS_INDEX );\n/*\n** Get IRQs for parallel port and floppy controller\n*/\n    ppt_fdc_irqs.as_uchar =\n\tSMC37c669_read_config( SMC37c669_PARALLEL_FDC_IRQ_INDEX );\n/*\n** Get DRQs for parallel port and floppy controller\n*/\n    ppt_fdc_drqs.as_uchar =\n\tSMC37c669_read_config( SMC37c669_PARALLEL_FDC_DRQ_INDEX );\n/*\n** Store local configuration information for parallel port\n*/\n    local_config[PARALLEL_0].port1 = ppt_base.by_field.addr9_2 << 2;\n    local_config[PARALLEL_0].irq =\n\tSMC37c669_xlate_irq(\n\t    SMC37c669_DEVICE_IRQ( ppt_fdc_irqs.by_field.ppt_irq )\n\t);\n    local_config[PARALLEL_0].drq =\n\tSMC37c669_xlate_drq(\n\t    SMC37c669_DEVICE_DRQ( ppt_fdc_drqs.by_field.ppt_drq )\n\t);\n/*\n** Get floppy controller base address\n*/\n    fdc_base.as_uchar = \n\tSMC37c669_read_config( SMC37c669_FDC_BASE_ADDRESS_INDEX );\n/*\n** Store local configuration information for floppy controller\n*/\n    local_config[FLOPPY_0].port1 = fdc_base.by_field.addr9_4 << 4;\n    local_config[FLOPPY_0].irq =\n\tSMC37c669_xlate_irq(\n\t    SMC37c669_DEVICE_IRQ( ppt_fdc_irqs.by_field.fdc_irq )\n\t);\n    local_config[FLOPPY_0].drq =\n\tSMC37c669_xlate_drq(\n\t    SMC37c669_DEVICE_DRQ( ppt_fdc_drqs.by_field.fdc_drq )\n\t);\n/*\n** Get IDE controller base address\n*/\n    ide_base.as_uchar =\n\tSMC37c669_read_config( SMC37c669_IDE_BASE_ADDRESS_INDEX );\n/*\n** Get IDE alternate status base address\n*/\n    ide_alt.as_uchar =\n\tSMC37c669_read_config( SMC37c669_IDE_ALTERNATE_ADDRESS_INDEX );\n/*\n** Store local configuration information for IDE controller\n*/\n    local_config[IDE_0].port1 = ide_base.by_field.addr9_4 << 4;\n    local_config[IDE_0].port2 = ide_alt.by_field.addr9_4 << 4;\n    local_config[IDE_0].irq = 14;\n}", "path": "linux-rpi-6.1.y/arch/alpha/kernel/smc37c669.c", "commit_date": "2019-04-23 00:00:00", "repo_name": "raspberrypi/linux", "stars": 10528, "license": "other", "language": "c", "size": 3940105}
{"docstring": "/*\n * Titan Family\n */\n", "func_signal": "static void __init\ntitan_request_irq(unsigned int irq, irq_handler_t handler,\n\t\t  unsigned long irqflags, const char *devname,\n\t\t  void *dev_id)", "code": "{\n\tint err;\n\terr = request_irq(irq, handler, irqflags, devname, dev_id);\n\tif (err) {\n\t\tprintk(\"titan_request_irq for IRQ %d returned %d; ignoring\\n\",\n\t\t       irq, err);\n\t}\n}", "path": "linux-rpi-6.1.y/arch/alpha/kernel/sys_titan.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "raspberrypi/linux", "stars": 10528, "license": "other", "language": "c", "size": 3940105}
{"docstring": "/*\n * CIA Pass 1 and PYXIS Pass 1 and 2 have a broken scatter-gather tlb.\n * It cannot be invalidated.  Rather than hard code the pass numbers,\n * actually try the tbia to see if it works.\n */\n", "func_signal": "void\ncia_pci_tbi(struct pci_controller *hose, dma_addr_t start, dma_addr_t end)", "code": "{\n\twmb();\n\t*(vip)CIA_IOC_PCI_TBIA = 3;\t/* Flush all locked and unlocked.  */\n\tmb();\n\t*(vip)CIA_IOC_PCI_TBIA;\n}", "path": "linux-rpi-6.1.y/arch/alpha/kernel/core_cia.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "raspberrypi/linux", "stars": 10528, "license": "other", "language": "c", "size": 3940105}
{"docstring": "/*\n *  Interrupt routing:\n *\n *\t\tPrimary bus\n *\t  IdSel\t\tINTA\tINTB\tINTC\tINTD\n * 21052   13\t\t  -\t  -\t  -\t  -\n * SIO\t   14\t\t 23\t  -\t  -\t  -\n * 21143   15\t\t 44\t  -\t  -\t  -\n * Slot 0  17\t\t 43\t 42\t 41\t 40\n *\n *\t\tSecondary bus\n *\t  IdSel\t\tINTA\tINTB\tINTC\tINTD\n * Slot 0   8 (18)\t 19\t 18\t 17\t 16\n * Slot 1   9 (19)\t 31\t 30\t 29\t 28\n * Slot 2  10 (20)\t 27\t 26\t 25\t 24\n * Slot 3  11 (21)\t 39\t 38\t 37\t 36\n * Slot 4  12 (22)\t 35\t 34\t 33\t 32\n * 53c875  13 (23)\t 20\t  -\t  -\t  -\n *\n */\n", "func_signal": "static int\nruffian_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)", "code": "{\n        static char irq_tab[11][5] = {\n\t      /*INT  INTA INTB INTC INTD */\n\t\t{-1,  -1,  -1,  -1,  -1},  /* IdSel 13,  21052\t     */\n\t\t{-1,  -1,  -1,  -1,  -1},  /* IdSel 14,  SIO\t     */\n\t\t{44,  44,  44,  44,  44},  /* IdSel 15,  21143\t     */\n\t\t{-1,  -1,  -1,  -1,  -1},  /* IdSel 16,  none\t     */\n\t\t{43,  43,  42,  41,  40},  /* IdSel 17,  64-bit slot */\n\t\t/* the next 6 are actually on PCI bus 1, across the bridge */\n\t\t{19,  19,  18,  17,  16},  /* IdSel  8,  slot 0\t     */\n\t\t{31,  31,  30,  29,  28},  /* IdSel  9,  slot 1\t     */\n\t\t{27,  27,  26,  25,  24},  /* IdSel 10,  slot 2\t     */\n\t\t{39,  39,  38,  37,  36},  /* IdSel 11,  slot 3\t     */\n\t\t{35,  35,  34,  33,  32},  /* IdSel 12,  slot 4\t     */\n\t\t{20,  20,  20,  20,  20},  /* IdSel 13,  53c875\t     */\n        };\n\tconst long min_idsel = 13, max_idsel = 23, irqs_per_slot = 5;\n\treturn COMMON_TABLE_LOOKUP;\n}", "path": "linux-rpi-6.1.y/arch/alpha/kernel/sys_ruffian.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "raspberrypi/linux", "stars": 10528, "license": "other", "language": "c", "size": 3940105}
{"docstring": "/*\n * The DeskStation Ruffian motherboard firmware does not place\n * the memory size in the PALimpure area.  Therefore, we use\n * the Bank Configuration Registers in PYXIS to obtain the size.\n */\n", "func_signal": "static unsigned long __init\nruffian_get_bank_size(unsigned long offset)", "code": "{\n\tunsigned long bank_addr, bank, ret = 0;\n\n\t/* Valid offsets are: 0x800, 0x840 and 0x880\n\t   since Ruffian only uses three banks.  */\n\tbank_addr = (unsigned long)PYXIS_MCR + offset;\n\tbank = *(vulp)bank_addr;\n\n\t/* Check BANK_ENABLE */\n\tif (bank & 0x01) {\n\t\tstatic unsigned long size[] __initdata = {\n\t\t\t0x40000000UL, /* 0x00,   1G */\n\t\t\t0x20000000UL, /* 0x02, 512M */\n\t\t\t0x10000000UL, /* 0x04, 256M */\n\t\t\t0x08000000UL, /* 0x06, 128M */\n\t\t\t0x04000000UL, /* 0x08,  64M */\n\t\t\t0x02000000UL, /* 0x0a,  32M */\n\t\t\t0x01000000UL, /* 0x0c,  16M */\n\t\t\t0x00800000UL, /* 0x0e,   8M */\n\t\t\t0x80000000UL, /* 0x10,   2G */\n\t\t};\n\n\t\tbank = (bank & 0x1e) >> 1;\n\t\tif (bank < ARRAY_SIZE(size))\n\t\t\tret = size[bank];\n\t}\n\n\treturn ret;\n}", "path": "linux-rpi-6.1.y/arch/alpha/kernel/sys_ruffian.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "raspberrypi/linux", "stars": 10528, "license": "other", "language": "c", "size": 3940105}
{"docstring": "/*\n * PCI Fixup configuration for ALPHA LYNX (2100A)\n *\n * The device to slot mapping looks like:\n *\n * Slot     Device\n *  0       none\n *  1       none\n *  2       PCI-EISA bridge\n *  3       PCI-PCI bridge\n *  4       NCR 810 (Demi-Lynx only)\n *  5       none\n *  6       PCI on board slot 4\n *  7       PCI on board slot 5\n *  8       PCI on board slot 6\n *  9       PCI on board slot 7\n *\n * And behind the PPB we have:\n *\n * 11       PCI on board slot 0\n * 12       PCI on board slot 1\n * 13       PCI on board slot 2\n * 14       PCI on board slot 3\n */\n/*\n * NOTE: the IRQ assignments below are arbitrary, but need to be consistent\n * with the values in the irq swizzling tables above.\n */\n", "func_signal": "static int\nlynx_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)", "code": "{\n\tstatic char irq_tab[19][5] = {\n\t\t/*INT    INTA   INTB   INTC   INTD */\n\t\t{   -1,    -1,    -1,    -1,    -1},  /* IdSel 13,  PCEB   */\n\t\t{   -1,    -1,    -1,    -1,    -1},  /* IdSel 14,  PPB    */\n\t\t{   28,    28,    28,    28,    28},  /* IdSel 15,  NCR demi */\n\t\t{   -1,    -1,    -1,    -1,    -1},  /* IdSel 16,  none   */\n\t\t{   32,    32,    33,    34,    35},  /* IdSel 17,  slot 4 */\n\t\t{   36,    36,    37,    38,    39},  /* IdSel 18,  slot 5 */\n\t\t{   40,    40,    41,    42,    43},  /* IdSel 19,  slot 6 */\n\t\t{   44,    44,    45,    46,    47},  /* IdSel 20,  slot 7 */\n\t\t{   -1,    -1,    -1,    -1,    -1},  /* IdSel 22,  none   */\n\t\t/* The following are actually behind the PPB. */\n\t\t{   -1,    -1,    -1,    -1,    -1},  /* IdSel 16   none */\n\t\t{   28,    28,    28,    28,    28},  /* IdSel 17   NCR lynx */\n\t\t{   -1,    -1,    -1,    -1,    -1},  /* IdSel 18   none */\n\t\t{   -1,    -1,    -1,    -1,    -1},  /* IdSel 19   none */\n\t\t{   -1,    -1,    -1,    -1,    -1},  /* IdSel 20   none */\n\t\t{   -1,    -1,    -1,    -1,    -1},  /* IdSel 21   none */\n\t\t{   48,    48,    49,    50,    51},  /* IdSel 22   slot 0 */\n\t\t{   52,    52,    53,    54,    55},  /* IdSel 23   slot 1 */\n\t\t{   56,    56,    57,    58,    59},  /* IdSel 24   slot 2 */\n\t\t{   60,    60,    61,    62,    63}   /* IdSel 25   slot 3 */\n\t};\n\tconst long min_idsel = 2, max_idsel = 20, irqs_per_slot = 5;\n\treturn COMMON_TABLE_LOOKUP;\n}", "path": "linux-rpi-6.1.y/arch/alpha/kernel/sys_sable.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "raspberrypi/linux", "stars": 10528, "license": "other", "language": "c", "size": 3940105}
{"docstring": "/* Always called with interrupts disabled */\n", "func_signal": "void\ncia_pci_tbi_try2(struct pci_controller *hose,\n\t\t dma_addr_t start, dma_addr_t end)", "code": "{\n\tvoid __iomem *bus_addr;\n\tint ctrl;\n\n\t/* Put the chip into PCI loopback mode.  */\n\tmb();\n\tctrl = *(vip)CIA_IOC_CIA_CTRL;\n\t*(vip)CIA_IOC_CIA_CTRL = ctrl | CIA_CTRL_PCI_LOOP_EN;\n\tmb();\n\t*(vip)CIA_IOC_CIA_CTRL;\n\tmb();\n\n\t/* Read from PCI dense memory space at TBI_ADDR, skipping 32k on\n\t   each read.  This forces SG TLB misses.  NetBSD claims that the\n\t   TLB entries are not quite LRU, meaning that we need to read more\n\t   times than there are actual tags.  The 2117x docs claim strict\n\t   round-robin.  Oh well, we've come this far...  */\n\t/* Even better - as seen on the PYXIS rev 1 the TLB tags 0-3 can\n\t   be filled by the TLB misses *only once* after being invalidated\n\t   (by tbia or direct write). Next misses won't update them even\n\t   though the lock bits are cleared. Tags 4-7 are \"quite LRU\" though,\n\t   so use them and read at window 3 base exactly 4 times. Reading\n\t   more sometimes makes the chip crazy.  -ink */\n\n\tbus_addr = cia_ioremap(CIA_BROKEN_TBIA_BASE, 32768 * 4);\n\n\tcia_readl(bus_addr + 0x00000);\n\tcia_readl(bus_addr + 0x08000);\n\tcia_readl(bus_addr + 0x10000);\n\tcia_readl(bus_addr + 0x18000);\n\n\tcia_iounmap(bus_addr);\n\n\t/* Restore normal PCI operation.  */\n\tmb();\n\t*(vip)CIA_IOC_CIA_CTRL = ctrl;\n\tmb();\n\t*(vip)CIA_IOC_CIA_CTRL;\n\tmb();\n}", "path": "linux-rpi-6.1.y/arch/alpha/kernel/core_cia.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "raspberrypi/linux", "stars": 10528, "license": "other", "language": "c", "size": 3940105}
{"docstring": "/*\n**++\n**  FUNCTIONAL DESCRIPTION:\n**\n**      This function displays the current state of the SMC37c699\n**\tSuper I/O controller's device functions.\n**\n**  FORMAL PARAMETERS:\n**\n**      None\n**\n**  RETURN VALUE:\n**\n**      None\n**\n**  SIDE EFFECTS:\n**\n**      None\n**\n**--\n*/\n", "func_signal": "void __init SMC37c669_display_device_info ( void )", "code": "{\n    if ( SMC37c669_is_device_enabled( SERIAL_0 ) ) {\n    \tprintk( \"  Serial 0:    Enabled [ Port 0x%x, IRQ %d ]\\n\",\n\t\t local_config[ SERIAL_0 ].port1,\n\t\t local_config[ SERIAL_0 ].irq\n\t);\n    }\n    else {\n    \tprintk( \"  Serial 0:    Disabled\\n\" );\n    }\n\n    if ( SMC37c669_is_device_enabled( SERIAL_1 ) ) {\n    \tprintk( \"  Serial 1:    Enabled [ Port 0x%x, IRQ %d ]\\n\",\n\t\t local_config[ SERIAL_1 ].port1,\n\t\t local_config[ SERIAL_1 ].irq\n\t);\n    }\n    else {\n    \tprintk( \"  Serial 1:    Disabled\\n\" );\n    }\n\n    if ( SMC37c669_is_device_enabled( PARALLEL_0 ) ) {\n    \tprintk( \"  Parallel:    Enabled [ Port 0x%x, IRQ %d/%d ]\\n\",\n\t\t local_config[ PARALLEL_0 ].port1,\n\t\t local_config[ PARALLEL_0 ].irq,\n\t\t local_config[ PARALLEL_0 ].drq\n\t);\n    }\n    else {\n    \tprintk( \"  Parallel:    Disabled\\n\" );\n    }\n\n    if ( SMC37c669_is_device_enabled( FLOPPY_0 ) ) {\n    \tprintk( \"  Floppy Ctrl: Enabled [ Port 0x%x, IRQ %d/%d ]\\n\",\n\t\t local_config[ FLOPPY_0 ].port1,\n\t\t local_config[ FLOPPY_0 ].irq,\n\t\t local_config[ FLOPPY_0 ].drq\n\t);\n    }\n    else {\n    \tprintk( \"  Floppy Ctrl: Disabled\\n\" );\n    }\n\n    if ( SMC37c669_is_device_enabled( IDE_0 ) ) {\n    \tprintk( \"  IDE 0:       Enabled [ Port 0x%x, IRQ %d ]\\n\",\n\t\t local_config[ IDE_0 ].port1,\n\t\t local_config[ IDE_0 ].irq\n\t);\n    }\n    else {\n    \tprintk( \"  IDE 0:       Disabled\\n\" );\n    }\n}", "path": "linux-rpi-6.1.y/arch/alpha/kernel/smc37c669.c", "commit_date": "2019-04-23 00:00:00", "repo_name": "raspberrypi/linux", "stars": 10528, "license": "other", "language": "c", "size": 3940105}
{"docstring": "/*\n * Generic\n */\n", "func_signal": "void\nmchk_dump_mem(void *data, size_t length, char **annotation)", "code": "{\n\tunsigned long *ldata = data;\n\tsize_t i;\n\t\n\tfor (i = 0; (i * sizeof(*ldata)) < length; i++) {\n\t\tif (annotation && !annotation[i]) \n\t\t\tannotation = NULL;\n\t\tprintk(\"%s    %08x: %016lx    %s\\n\",\n\t\t       err_print_prefix,\n\t\t       (unsigned)(i * sizeof(*ldata)), ldata[i],\n\t\t       annotation ? annotation[i] : \"\");\n\t}\n}", "path": "linux-rpi-6.1.y/arch/alpha/kernel/err_common.c", "commit_date": "2017-11-02 00:00:00", "repo_name": "raspberrypi/linux", "stars": 10528, "license": "other", "language": "c", "size": 3940105}
{"docstring": "/*\n**++\n**  FUNCTIONAL DESCRIPTION:\n**\n**      This function writes an SMC37c669 Super I/O controller\n**\tconfiguration register.  This function assumes that the\n**\tdevice is already in configuration mode.\n**\n**  FORMAL PARAMETERS:\n**\n**      index:\n**          Index of configuration register to write\n**       \n**      data:\n**          Data to be written\n**\n**  RETURN VALUE:\n**\n**      None\n**\n**  SIDE EFFECTS:\n**\n**      None\n**\n**--\n*/\n", "func_signal": "static void __init SMC37c669_write_config( \n    unsigned char index, \n    unsigned char data )", "code": "{\n    wb( &SMC37c669->index_port, index );\n    wb( &SMC37c669->data_port, data );\n}", "path": "linux-rpi-6.1.y/arch/alpha/kernel/smc37c669.c", "commit_date": "2019-04-23 00:00:00", "repo_name": "raspberrypi/linux", "stars": 10528, "license": "other", "language": "c", "size": 3940105}
{"docstring": "/*\n**++\n**  FUNCTIONAL DESCRIPTION:\n**\n**      This function reads an SMC37c669 Super I/O controller\n**\tconfiguration register.  This function assumes that the\n**\tdevice is already in configuration mode.\n**\n**  FORMAL PARAMETERS:\n**\n**      index:\n**          Index value of configuration register to read\n**\n**  RETURN VALUE:\n**\n**      Data read from configuration register\n**\n**  SIDE EFFECTS:\n**\n**      None\n**\n**--\n*/\n", "func_signal": "static unsigned char __init SMC37c669_read_config( \n    unsigned char index )", "code": "{\n\twb(&SMC37c669->index_port, index);\n\treturn rb(&SMC37c669->data_port);\n}", "path": "linux-rpi-6.1.y/arch/alpha/kernel/smc37c669.c", "commit_date": "2019-04-23 00:00:00", "repo_name": "raspberrypi/linux", "stars": 10528, "license": "other", "language": "c", "size": 3940105}
{"docstring": "/*\n * Privateer\n */\n", "func_signal": "static void __init\nprivateer_init_pci(void)", "code": "{\n\t/*\n\t * Hook a couple of extra err interrupts that the\n\t * common titan code won't.\n\t */\n\ttitan_request_irq(53+16, titan_intr_nop, 0,\n\t\t    \"NMI\", NULL);\n\ttitan_request_irq(50+16, titan_intr_nop, 0,\n\t\t    \"Temperature Warning\", NULL);\n\n\t/*\n\t * Finish with the common version.\n\t */\n\treturn titan_init_pci();\n}", "path": "linux-rpi-6.1.y/arch/alpha/kernel/sys_titan.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "raspberrypi/linux", "stars": 10528, "license": "other", "language": "c", "size": 3940105}
{"docstring": "/* CONFIG_VERBOSE_MCHECK */\n", "func_signal": "static int\ncia_decode_mchk(unsigned long la_ptr)", "code": "{\n\tstruct el_common *com;\n\tstruct el_CIA_sysdata_mcheck *cia;\n\n\tcom = (void *)la_ptr;\n\tcia = (void *)(la_ptr + com->sys_offset);\n\n\tif ((cia->cia_err & CIA_ERR_VALID) == 0)\n\t\treturn 0;\n\n#ifdef CONFIG_VERBOSE_MCHECK\n\tif (!alpha_verbose_mcheck)\n\t\treturn 1;\n\n\tswitch (ffs(cia->cia_err & 0xfff) - 1) {\n\tcase 0: /* CIA_ERR_COR_ERR */\n\t\tcia_decode_ecc_error(cia, \"Corrected ECC error\");\n\t\tbreak;\n\tcase 1: /* CIA_ERR_UN_COR_ERR */\n\t\tcia_decode_ecc_error(cia, \"Uncorrected ECC error\");\n\t\tbreak;\n\tcase 2: /* CIA_ERR_CPU_PE */\n\t\tcia_decode_parity_error(cia);\n\t\tbreak;\n\tcase 3: /* CIA_ERR_MEM_NEM */\n\t\tcia_decode_mem_error(cia, \"Access to nonexistent memory\");\n\t\tbreak;\n\tcase 4: /* CIA_ERR_PCI_SERR */\n\t\tcia_decode_pci_error(cia, \"PCI bus system error\");\n\t\tbreak;\n\tcase 5: /* CIA_ERR_PERR */\n\t\tcia_decode_pci_error(cia, \"PCI data parity error\");\n\t\tbreak;\n\tcase 6: /* CIA_ERR_PCI_ADDR_PE */\n\t\tcia_decode_pci_error(cia, \"PCI address parity error\");\n\t\tbreak;\n\tcase 7: /* CIA_ERR_RCVD_MAS_ABT */\n\t\tcia_decode_pci_error(cia, \"PCI master abort\");\n\t\tbreak;\n\tcase 8: /* CIA_ERR_RCVD_TAR_ABT */\n\t\tcia_decode_pci_error(cia, \"PCI target abort\");\n\t\tbreak;\n\tcase 9: /* CIA_ERR_PA_PTE_INV */\n\t\tcia_decode_pci_error(cia, \"PCI invalid PTE\");\n\t\tbreak;\n\tcase 10: /* CIA_ERR_FROM_WRT_ERR */\n\t\tcia_decode_mem_error(cia, \"Write to flash ROM attempted\");\n\t\tbreak;\n\tcase 11: /* CIA_ERR_IOA_TIMEOUT */\n\t\tcia_decode_pci_error(cia, \"I/O timeout\");\n\t\tbreak;\n\t}\n\n\tif (cia->cia_err & CIA_ERR_LOST_CORR_ERR)\n\t\tprintk(KERN_CRIT \"CIA lost machine check: \"\n\t\t       \"Correctable ECC error\\n\");\n\tif (cia->cia_err & CIA_ERR_LOST_UN_CORR_ERR)\n\t\tprintk(KERN_CRIT \"CIA lost machine check: \"\n\t\t       \"Uncorrectable ECC error\\n\");\n\tif (cia->cia_err & CIA_ERR_LOST_CPU_PE)\n\t\tprintk(KERN_CRIT \"CIA lost machine check: \"\n\t\t       \"System bus parity error\\n\");\n\tif (cia->cia_err & CIA_ERR_LOST_MEM_NEM)\n\t\tprintk(KERN_CRIT \"CIA lost machine check: \"\n\t\t       \"Access to nonexistent memory\\n\");\n\tif (cia->cia_err & CIA_ERR_LOST_PERR)\n\t\tprintk(KERN_CRIT \"CIA lost machine check: \"\n\t\t       \"PCI data parity error\\n\");\n\tif (cia->cia_err & CIA_ERR_LOST_PCI_ADDR_PE)\n\t\tprintk(KERN_CRIT \"CIA lost machine check: \"\n\t\t       \"PCI address parity error\\n\");\n\tif (cia->cia_err & CIA_ERR_LOST_RCVD_MAS_ABT)\n\t\tprintk(KERN_CRIT \"CIA lost machine check: \"\n\t\t       \"PCI master abort\\n\");\n\tif (cia->cia_err & CIA_ERR_LOST_RCVD_TAR_ABT)\n\t\tprintk(KERN_CRIT \"CIA lost machine check: \"\n\t\t       \"PCI target abort\\n\");\n\tif (cia->cia_err & CIA_ERR_LOST_PA_PTE_INV)\n\t\tprintk(KERN_CRIT \"CIA lost machine check: \"\n\t\t       \"PCI invalid PTE\\n\");\n\tif (cia->cia_err & CIA_ERR_LOST_FROM_WRT_ERR)\n\t\tprintk(KERN_CRIT \"CIA lost machine check: \"\n\t\t       \"Write to flash ROM attempted\\n\");\n\tif (cia->cia_err & CIA_ERR_LOST_IOA_TIMEOUT)\n\t\tprintk(KERN_CRIT \"CIA lost machine check: \"\n\t\t       \"I/O timeout\\n\");\n#endif /* CONFIG_VERBOSE_MCHECK */\n\n\treturn 1;\n}", "path": "linux-rpi-6.1.y/arch/alpha/kernel/core_cia.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "raspberrypi/linux", "stars": 10528, "license": "other", "language": "c", "size": 3940105}
{"docstring": "/*+\n * ============================================================================\n * = SMC_init - SMC37c669 Super I/O controller initialization                 =\n * ============================================================================\n *\n * OVERVIEW:\n *\n *      This routine configures and enables device functions on the\n *      SMC37c669 Super I/O controller.\n *\n * FORM OF CALL:\n *\n *      SMC_init( );\n *\n * RETURNS:\n *\n *      Nothing\n *\n * ARGUMENTS:\n *\n *      None\n *\n * SIDE EFFECTS:\n *\n *      None\n *\n */\n", "func_signal": "void __init SMC669_Init ( int index )", "code": "{\n    SMC37c669_CONFIG_REGS *SMC_base;\n    unsigned long flags;\n\n    local_irq_save(flags);\n    if ( ( SMC_base = SMC37c669_detect( index ) ) != NULL ) {\n#if SMC_DEBUG\n\tSMC37c669_config_mode( TRUE );\n\tSMC37c669_dump_registers( );\n\tSMC37c669_config_mode( FALSE );\n        SMC37c669_display_device_info( );\n#endif\n        SMC37c669_disable_device( SERIAL_0 );\n        SMC37c669_configure_device(\n            SERIAL_0,\n            COM1_BASE,\n            COM1_IRQ,\n            -1\n        );\n        SMC37c669_enable_device( SERIAL_0 );\n\n        SMC37c669_disable_device( SERIAL_1 );\n        SMC37c669_configure_device(\n            SERIAL_1,\n            COM2_BASE,\n            COM2_IRQ,\n            -1\n        );\n        SMC37c669_enable_device( SERIAL_1 );\n\n        SMC37c669_disable_device( PARALLEL_0 );\n        SMC37c669_configure_device(\n            PARALLEL_0,\n            PARP_BASE,\n            PARP_IRQ,\n            PARP_DRQ\n        );\n        SMC37c669_enable_device( PARALLEL_0 );\n\n        SMC37c669_disable_device( FLOPPY_0 );\n        SMC37c669_configure_device(\n            FLOPPY_0,\n            FDC_BASE,\n            FDC_IRQ,\n            FDC_DRQ\n        );\n        SMC37c669_enable_device( FLOPPY_0 );\n          \n\t/* Wake up sometimes forgotten floppy, especially on DP264. */\n\toutb(0xc, 0x3f2);\n\n        SMC37c669_disable_device( IDE_0 );\n\n#if SMC_DEBUG\n\tSMC37c669_config_mode( TRUE );\n\tSMC37c669_dump_registers( );\n\tSMC37c669_config_mode( FALSE );\n        SMC37c669_display_device_info( );\n#endif\n\tlocal_irq_restore(flags);\n        printk( \"SMC37c669 Super I/O Controller found @ 0x%p\\n\",\n\t\tSMC_base );\n    }\n    else {\n\tlocal_irq_restore(flags);\n#if SMC_DEBUG\n        printk( \"No SMC37c669 Super I/O Controller found\\n\" );\n#endif\n    }\n}", "path": "linux-rpi-6.1.y/arch/alpha/kernel/smc37c669.c", "commit_date": "2019-04-23 00:00:00", "repo_name": "raspberrypi/linux", "stars": 10528, "license": "other", "language": "c", "size": 3940105}
{"docstring": "/* This is called from init_IRQ, since we cannot take interrupts\n   before then.  Which means we cannot do this in init_arch.  */\n", "func_signal": "void __init\nmcpcia_init_hoses(void)", "code": "{\n\tstruct pci_controller *hose;\n\tint hose_count;\n\tint h;\n\n\t/* First, find how many hoses we have.  */\n\those_count = 0;\n\tfor (h = 0; h < MCPCIA_MAX_HOSES; ++h) {\n\t\tif (mcpcia_probe_hose(h)) {\n\t\t\tif (h != 0)\n\t\t\t\tmcpcia_new_hose(h);\n\t\t\those_count++;\n\t\t}\n\t}\n\n\tprintk(\"mcpcia_init_hoses: found %d hoses\\n\", hose_count);\n\n\t/* Now do init for each hose.  */\n\tfor (hose = hose_head; hose; hose = hose->next)\n\t\tmcpcia_startup_hose(hose);\n}", "path": "linux-rpi-6.1.y/arch/alpha/kernel/core_mcpcia.c", "commit_date": "2018-10-31 00:00:00", "repo_name": "raspberrypi/linux", "stars": 10528, "license": "other", "language": "c", "size": 3940105}
{"docstring": "/*\n * The Takara has PCI devices 1, 2, and 3 configured to slots 20,\n * 19, and 18 respectively, in the default configuration. They can\n * also be jumpered to slots 8, 7, and 6 respectively, which is fun\n * because the SIO ISA bridge can also be slot 7. However, the SIO\n * doesn't explicitly generate PCI-type interrupts, so we can\n * assign it whatever the hell IRQ we like and it doesn't matter.\n */\n", "func_signal": "static int\ntakara_map_irq_srm(const struct pci_dev *dev, u8 slot, u8 pin)", "code": "{\n\tstatic char irq_tab[15][5] = {\n\t\t{ 16+3, 16+3, 16+3, 16+3, 16+3},   /* slot  6 == device 3 */\n\t\t{ 16+2, 16+2, 16+2, 16+2, 16+2},   /* slot  7 == device 2 */\n\t\t{ 16+1, 16+1, 16+1, 16+1, 16+1},   /* slot  8 == device 1 */\n\t\t{   -1,   -1,   -1,   -1,   -1},   /* slot  9 == nothing */\n\t\t{   -1,   -1,   -1,   -1,   -1},   /* slot 10 == nothing */\n\t\t{   -1,   -1,   -1,   -1,   -1},   /* slot 11 == nothing */\n\t\t/* These are behind the bridges.  */\n\t\t{   12,   12,   13,   14,   15},   /* slot 12 == nothing */\n\t\t{    8,    8,    9,   19,   11},   /* slot 13 == nothing */\n\t\t{    4,    4,    5,    6,    7},   /* slot 14 == nothing */\n\t\t{    0,    0,    1,    2,    3},   /* slot 15 == nothing */\n\t\t{   -1,   -1,   -1,   -1,   -1},   /* slot 16 == nothing */\n\t\t{64+ 0, 64+0, 64+1, 64+2, 64+3},   /* slot 17= device 4 */\n\t\t{48+ 0, 48+0, 48+1, 48+2, 48+3},   /* slot 18= device 3 */\n\t\t{32+ 0, 32+0, 32+1, 32+2, 32+3},   /* slot 19= device 2 */\n\t\t{16+ 0, 16+0, 16+1, 16+2, 16+3},   /* slot 20= device 1 */\n\t};\n\tconst long min_idsel = 6, max_idsel = 20, irqs_per_slot = 5;\n        int irq = COMMON_TABLE_LOOKUP;\n\tif (irq >= 0 && irq < 16) {\n\t\t/* Guess that we are behind a bridge.  */\n\t\tunsigned int busslot = PCI_SLOT(dev->bus->self->devfn);\n\t\tirq += irq_tab[busslot-min_idsel][0];\n\t}\n\treturn irq;\n}", "path": "linux-rpi-6.1.y/arch/alpha/kernel/sys_takara.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "raspberrypi/linux", "stars": 10528, "license": "other", "language": "c", "size": 3940105}
{"docstring": "/* use 'ABCDEF' instead of 'abcdef' */\n", "func_signal": "static char * number(char * str, unsigned long long num, int base, int size, int precision, int type)", "code": "{\n\tchar c,sign,tmp[66];\n\tconst char *digits=\"0123456789abcdefghijklmnopqrstuvwxyz\";\n\tint i;\n\n\tif (type & LARGE)\n\t\tdigits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\tif (type & LEFT)\n\t\ttype &= ~ZEROPAD;\n\tif (base < 2 || base > 36)\n\t\treturn 0;\n\tc = (type & ZEROPAD) ? '0' : ' ';\n\tsign = 0;\n\tif (type & SIGN) {\n\t\tif ((signed long long)num < 0) {\n\t\t\tsign = '-';\n\t\t\tnum = - (signed long long)num;\n\t\t\tsize--;\n\t\t} else if (type & PLUS) {\n\t\t\tsign = '+';\n\t\t\tsize--;\n\t\t} else if (type & SPACE) {\n\t\t\tsign = ' ';\n\t\t\tsize--;\n\t\t}\n\t}\n\tif (type & SPECIAL) {\n\t\tif (base == 16)\n\t\t\tsize -= 2;\n\t\telse if (base == 8)\n\t\t\tsize--;\n\t}\n\ti = 0;\n\tif (num == 0)\n\t\ttmp[i++]='0';\n\telse while (num != 0) {\n\t\ttmp[i++] = digits[do_div(num, base)];\n\t}\n\tif (i > precision)\n\t\tprecision = i;\n\tsize -= precision;\n\tif (!(type&(ZEROPAD+LEFT)))\n\t\twhile(size-->0)\n\t\t\t*str++ = ' ';\n\tif (sign)\n\t\t*str++ = sign;\n\tif (type & SPECIAL) {\n\t\tif (base==8)\n\t\t\t*str++ = '0';\n\t\telse if (base==16) {\n\t\t\t*str++ = '0';\n\t\t\t*str++ = digits[33];\n\t\t}\n\t}\n\tif (!(type & LEFT))\n\t\twhile (size-- > 0)\n\t\t\t*str++ = c;\n\twhile (i < precision--)\n\t\t*str++ = '0';\n\twhile (i-- > 0)\n\t\t*str++ = tmp[i];\n\twhile (size-- > 0)\n\t\t*str++ = ' ';\n\treturn str;\n}", "path": "linux-rpi-6.1.y/arch/alpha/boot/stdio.c", "commit_date": "2019-05-30 00:00:00", "repo_name": "raspberrypi/linux", "stars": 10528, "license": "other", "language": "c", "size": 3940105}
{"docstring": "/*\n * PCI Fixup configuration for ALPHA SABLE (2100).\n *\n * The device to slot mapping looks like:\n *\n * Slot     Device\n *  0       TULIP\n *  1       SCSI\n *  2       PCI-EISA bridge\n *  3       none\n *  4       none\n *  5       none\n *  6       PCI on board slot 0\n *  7       PCI on board slot 1\n *  8       PCI on board slot 2\n *   \n *\n * This two layered interrupt approach means that we allocate IRQ 16 and \n * above for PCI interrupts.  The IRQ relates to which bit the interrupt\n * comes in on.  This makes interrupt processing much easier.\n */\n/*\n * NOTE: the IRQ assignments below are arbitrary, but need to be consistent\n * with the values in the irq swizzling tables above.\n */\n", "func_signal": "static int\nsable_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)", "code": "{\n\tstatic char irq_tab[9][5] = {\n\t\t/*INT    INTA   INTB   INTC   INTD */\n\t\t{ 32+0,  32+0,  32+0,  32+0,  32+0},  /* IdSel 0,  TULIP  */\n\t\t{ 32+1,  32+1,  32+1,  32+1,  32+1},  /* IdSel 1,  SCSI   */\n\t\t{   -1,    -1,    -1,    -1,    -1},  /* IdSel 2,  SIO   */\n\t\t{   -1,    -1,    -1,    -1,    -1},  /* IdSel 3,  none   */\n\t\t{   -1,    -1,    -1,    -1,    -1},  /* IdSel 4,  none   */\n\t\t{   -1,    -1,    -1,    -1,    -1},  /* IdSel 5,  none   */\n\t\t{ 32+2,  32+2,  32+2,  32+2,  32+2},  /* IdSel 6,  slot 0 */\n\t\t{ 32+3,  32+3,  32+3,  32+3,  32+3},  /* IdSel 7,  slot 1 */\n\t\t{ 32+4,  32+4,  32+4,  32+4,  32+4}   /* IdSel 8,  slot 2 */\n\t};\n\tlong min_idsel = 0, max_idsel = 8, irqs_per_slot = 5;\n\treturn COMMON_TABLE_LOOKUP;\n}", "path": "linux-rpi-6.1.y/arch/alpha/kernel/sys_sable.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "raspberrypi/linux", "stars": 10528, "license": "other", "language": "c", "size": 3940105}
{"docstring": "/***********************************************************************/\n/* GENERIC irq routines */\n", "func_signal": "static inline void\nsable_lynx_enable_irq(struct irq_data *d)", "code": "{\n\tunsigned long bit, mask;\n\n\tbit = sable_lynx_irq_swizzle->irq_to_mask[d->irq];\n\tspin_lock(&sable_lynx_irq_lock);\n\tmask = sable_lynx_irq_swizzle->shadow_mask &= ~(1UL << bit);\n\tsable_lynx_irq_swizzle->update_irq_hw(bit, mask);\n\tspin_unlock(&sable_lynx_irq_lock);\n#if 0\n\tprintk(\"%s: mask 0x%lx bit 0x%lx irq 0x%x\\n\",\n\t       __func__, mask, bit, irq);\n#endif\n}", "path": "linux-rpi-6.1.y/arch/alpha/kernel/sys_sable.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "raspberrypi/linux", "stars": 10528, "license": "other", "language": "c", "size": 3940105}
